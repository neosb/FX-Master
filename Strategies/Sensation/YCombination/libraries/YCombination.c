/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2009 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Data declarations

extern _UNKNOWN loc_10001530; // weak
extern _UNKNOWN loc_10001BD0; // weak
extern _UNKNOWN loc_10001D10; // weak
extern _UNKNOWN loc_10001E40; // weak
extern _UNKNOWN loc_100020F0; // weak
extern _UNKNOWN loc_100043A0; // weak
extern _UNKNOWN loc_10004C50; // weak
extern _UNKNOWN loc_10004D00; // weak
extern _UNKNOWN loc_10005070; // weak
extern _UNKNOWN loc_10005190; // weak
extern _UNKNOWN loc_10005370; // weak
extern _UNKNOWN loc_100054B0; // weak
extern _UNKNOWN loc_10005620; // weak
extern _UNKNOWN loc_100072D0; // weak
extern _UNKNOWN loc_10007D30; // weak
extern _UNKNOWN loc_10008250; // weak
extern _UNKNOWN loc_100086C0; // weak
extern _UNKNOWN loc_100088D0; // weak
extern _UNKNOWN loc_10008970; // weak
extern _UNKNOWN loc_10009490; // weak
extern _UNKNOWN loc_10009590; // weak
extern _UNKNOWN loc_1000ACE0; // weak
extern _UNKNOWN loc_1000B560; // weak
extern _UNKNOWN loc_1000BA70; // weak
extern _UNKNOWN loc_1000CE50; // weak
extern _UNKNOWN loc_1000D0A0; // weak
extern _UNKNOWN loc_1000E1E0; // weak
extern _UNKNOWN loc_1000E3F0; // weak
extern _UNKNOWN loc_1000EBE0; // weak
extern _UNKNOWN loc_1000ED20; // weak
extern _UNKNOWN loc_1000FDE0; // weak
extern _UNKNOWN loc_10010140; // weak
extern _UNKNOWN loc_10010220; // weak
extern _UNKNOWN loc_10010310; // weak
extern _UNKNOWN loc_100104C0; // weak
extern _UNKNOWN loc_100108B0; // weak
extern _UNKNOWN loc_100129B0; // weak
extern _UNKNOWN loc_10013E60; // weak
extern _UNKNOWN loc_10015090; // weak
extern _UNKNOWN loc_10015200; // weak
extern _UNKNOWN loc_100157A0; // weak
extern _UNKNOWN loc_10015870; // weak
extern _UNKNOWN loc_10018010; // weak
extern _UNKNOWN loc_10018880; // weak
extern _UNKNOWN loc_10018D70; // weak
extern _UNKNOWN loc_100193C0; // weak
extern _UNKNOWN loc_10019CF0; // weak
extern _UNKNOWN loc_10019D80; // weak
extern _UNKNOWN loc_1001DE40; // weak
extern _UNKNOWN loc_10020810; // weak
extern _UNKNOWN loc_10020AC0; // weak
extern _UNKNOWN loc_100214A0; // weak
extern _UNKNOWN loc_10023E73; // weak
extern _UNKNOWN loc_10023F4A; // weak
extern _UNKNOWN loc_10028386; // weak
extern _UNKNOWN loc_1002C766; // weak
extern _UNKNOWN loc_1002D74D; // weak
extern _UNKNOWN loc_1002E165; // weak
extern _UNKNOWN loc_1002E48A; // weak
extern _UNKNOWN loc_1002E5B9; // weak
extern _UNKNOWN loc_10030D9F; // weak
extern _UNKNOWN loc_10031B8C; // weak
extern _UNKNOWN loc_10031B98; // weak
extern _UNKNOWN loc_10031CFF; // weak
extern _UNKNOWN loc_10031D08; // weak
extern _UNKNOWN loc_100325BF; // weak
extern _UNKNOWN loc_10032A69; // weak
extern _UNKNOWN loc_100376A0; // weak
extern _UNKNOWN loc_1003A3A8; // weak
extern _UNKNOWN loc_1003DB84; // weak
extern _UNKNOWN loc_1003DBB7; // weak
extern _UNKNOWN loc_1003E053; // weak
extern _UNKNOWN loc_1003E5D4; // weak
extern _UNKNOWN loc_1003EC6F; // weak
extern _UNKNOWN loc_1003EC7E; // weak
extern _UNKNOWN loc_1003ECB1; // weak
extern _UNKNOWN loc_1003FD27; // weak
extern _UNKNOWN loc_1003FEA8; // weak
extern _UNKNOWN loc_10040695; // weak
extern _UNKNOWN sub_1004371B; // weak
extern _UNKNOWN loc_10044C67; // weak
extern _UNKNOWN loc_1004558C; // weak
extern _UNKNOWN loc_10048CD2; // weak
extern _UNKNOWN loc_10048DA0; // weak
extern _UNKNOWN loc_1004A355; // weak
extern _UNKNOWN loc_1004B5A3; // weak
extern _UNKNOWN loc_1004BDDE; // weak
extern _UNKNOWN loc_1004C016; // weak
extern _UNKNOWN loc_1004EE20; // weak
extern _UNKNOWN sub_1004FA58; // weak
extern _UNKNOWN sub_1004FA7B; // weak
extern _UNKNOWN sub_1004FAA6; // weak
extern _UNKNOWN sub_1004FAC1; // weak
extern _UNKNOWN sub_1004FADC; // weak
extern _UNKNOWN sub_1004FAF7; // weak
extern _UNKNOWN sub_1004FB53; // weak
extern _UNKNOWN sub_1004FB99; // weak
extern _UNKNOWN sub_1004FBBC; // weak
extern _UNKNOWN sub_1004FBDF; // weak
extern _UNKNOWN sub_1004FC0C; // weak
extern _UNKNOWN sub_1004FC35; // weak
extern _UNKNOWN sub_1004FC72; // weak
extern _UNKNOWN sub_1004FC98; // weak
extern _UNKNOWN sub_1004FCBB; // weak
extern _UNKNOWN sub_1004FCE6; // weak
extern _UNKNOWN sub_1004FD13; // weak
extern _UNKNOWN sub_1004FD41; // weak
extern _UNKNOWN sub_1004FD6A; // weak
extern _UNKNOWN sub_1004FD90; // weak
extern _UNKNOWN sub_1004FDB3; // weak
extern _UNKNOWN sub_1004FDD6; // weak
extern _UNKNOWN sub_1004FDF9; // weak
extern _UNKNOWN sub_1004FE30; // weak
extern _UNKNOWN sub_1004FE4B; // weak
extern _UNKNOWN sub_1004FE69; // weak
extern _UNKNOWN sub_1004FEA8; // weak
extern _UNKNOWN sub_1004FECB; // weak
extern _UNKNOWN sub_1004FEEE; // weak
extern _UNKNOWN sub_1004FF19; // weak
extern _UNKNOWN sub_1004FF3C; // weak
extern _UNKNOWN sub_1004FFD9; // weak
extern _UNKNOWN sub_10050076; // weak
extern _UNKNOWN sub_100500AA; // weak
extern _UNKNOWN sub_100500D5; // weak
extern _UNKNOWN sub_100500F0; // weak
extern _UNKNOWN sub_10050131; // weak
extern _UNKNOWN sub_10050160; // weak
extern _UNKNOWN sub_1005017B; // weak
extern _UNKNOWN sub_100501AC; // weak
extern _UNKNOWN sub_100501DD; // weak
extern _UNKNOWN sub_10050202; // weak
extern _UNKNOWN sub_10050239; // weak
extern _UNKNOWN sub_10050270; // weak
extern _UNKNOWN sub_10050293; // weak
extern _UNKNOWN sub_100502B6; // weak
extern _UNKNOWN sub_100502D9; // weak
extern _UNKNOWN sub_100502F4; // weak
extern _UNKNOWN sub_1005031A; // weak
extern _UNKNOWN sub_1005034A; // weak
extern _UNKNOWN sub_10050378; // weak
extern _UNKNOWN sub_1005039B; // weak
extern _UNKNOWN sub_100503BE; // weak
extern _UNKNOWN sub_100503EE; // weak
extern _UNKNOWN sub_10050411; // weak
extern _UNKNOWN sub_10050463; // weak
extern _UNKNOWN sub_10050489; // weak
extern _UNKNOWN sub_100504AF; // weak
extern _UNKNOWN sub_100504D4; // weak
extern _UNKNOWN sub_100504EF; // weak
extern _UNKNOWN sub_10050523; // weak
extern _UNKNOWN sub_10050554; // weak
extern _UNKNOWN sub_1005057A; // weak
extern _UNKNOWN sub_1005059D; // weak
extern _UNKNOWN sub_100505D1; // weak
extern _UNKNOWN sub_10050602; // weak
extern _UNKNOWN sub_10050628; // weak
extern _UNKNOWN sub_1005064B; // weak
extern _UNKNOWN sub_1005066E; // weak
extern _UNKNOWN sub_1005069E; // weak
extern _UNKNOWN sub_100506C4; // weak
extern _UNKNOWN sub_100506E7; // weak
extern _UNKNOWN sub_1005070C; // weak
extern _UNKNOWN sub_1005072F; // weak
extern _UNKNOWN sub_10050752; // weak
extern _UNKNOWN sub_10050778; // weak
extern _UNKNOWN sub_1005079E; // weak
extern _UNKNOWN sub_100507C3; // weak
extern _UNKNOWN sub_100507E6; // weak
extern _UNKNOWN sub_1005081B; // weak
extern _UNKNOWN sub_10050848; // weak
extern _UNKNOWN sub_100508A9; // weak
extern _UNKNOWN sub_100508D8; // weak
extern _UNKNOWN sub_10050900; // weak
extern _UNKNOWN sub_10050928; // weak
extern _UNKNOWN sub_10050969; // weak
extern _UNKNOWN sub_100509A0; // weak
extern _UNKNOWN sub_100509D9; // weak
extern _UNKNOWN sub_10050A00; // weak
extern _UNKNOWN sub_10050A28; // weak
extern _UNKNOWN sub_10050A50; // weak
extern _UNKNOWN sub_10050A78; // weak
extern _UNKNOWN sub_10050AAA; // weak
extern _UNKNOWN sub_10050AD8; // weak
extern _UNKNOWN sub_10050B08; // weak
extern _UNKNOWN sub_10050B5F; // weak
extern _UNKNOWN sub_10050B88; // weak
extern _UNKNOWN sub_10050BC6; // weak
extern _UNKNOWN sub_10050C3A; // weak
extern _UNKNOWN sub_10050C68; // weak
extern _UNKNOWN sub_10050C98; // weak
extern _UNKNOWN sub_10050CC8; // weak
extern _UNKNOWN sub_10050D08; // weak
extern _UNKNOWN sub_10050D63; // weak
extern _UNKNOWN sub_10050D98; // weak
extern _UNKNOWN sub_10050DC8; // weak
extern _UNKNOWN sub_10050E10; // weak
extern _UNKNOWN sub_10050E4B; // weak
extern _UNKNOWN sub_10050E7B; // weak
extern _UNKNOWN sub_10050ECC; // weak
extern _UNKNOWN sub_10050EF0; // weak
extern _UNKNOWN sub_10050F30; // weak
extern _UNKNOWN sub_10050F60; // weak
extern _UNKNOWN sub_10050F90; // weak
extern _UNKNOWN sub_10050FB8; // weak
extern _UNKNOWN sub_10050FF9; // weak
extern _UNKNOWN sub_10051040; // weak
extern _UNKNOWN sub_100510A0; // weak
extern _UNKNOWN sub_100510D0; // weak
extern _UNKNOWN sub_10051118; // weak
extern _UNKNOWN sub_10051150; // weak
extern _UNKNOWN sub_10051180; // weak
extern _UNKNOWN sub_100511B8; // weak
extern _UNKNOWN sub_100511EF; // weak
extern _UNKNOWN sub_10051228; // weak
extern _UNKNOWN sub_10051260; // weak
extern _UNKNOWN sub_10051288; // weak
extern _UNKNOWN sub_100512B8; // weak
extern _UNKNOWN sub_100512F1; // weak
extern _UNKNOWN sub_1005132B; // weak
extern _UNKNOWN sub_10051383; // weak
extern _UNKNOWN sub_100513D0; // weak
extern _UNKNOWN sub_100513F5; // weak
extern _UNKNOWN sub_10051453; // weak
extern _UNKNOWN sub_1005148B; // weak
extern _UNKNOWN sub_100514E4; // weak
extern _UNKNOWN sub_10051551; // weak
extern _UNKNOWN sub_1005158B; // weak
extern _UNKNOWN sub_100515C0; // weak
extern _UNKNOWN sub_100515F0; // weak
extern _UNKNOWN sub_10051610; // weak
extern _UNKNOWN sub_10051640; // weak
extern _UNKNOWN sub_1005167B; // weak
extern _UNKNOWN sub_100516B8; // weak
extern _UNKNOWN sub_10051711; // weak
extern _UNKNOWN sub_10051761; // weak
extern _UNKNOWN sub_1005179E; // weak
extern _UNKNOWN sub_100517D3; // weak
extern _UNKNOWN sub_100517FB; // weak
extern _UNKNOWN sub_10051839; // weak
extern _UNKNOWN sub_10051870; // weak
extern _UNKNOWN sub_100518B6; // weak
extern _UNKNOWN sub_100518E8; // weak
extern _UNKNOWN sub_10051918; // weak
extern _UNKNOWN sub_10051948; // weak
extern _UNKNOWN sub_10051980; // weak
extern _UNKNOWN sub_100519A0; // weak
extern _UNKNOWN sub_100519C0; // weak
extern _UNKNOWN sub_100519E8; // weak
extern _UNKNOWN sub_10051A30; // weak
extern _UNKNOWN sub_10051A80; // weak
extern _UNKNOWN sub_10051AC0; // weak
extern _UNKNOWN sub_10051B14; // weak
extern _UNKNOWN sub_10051B38; // weak
extern _UNKNOWN sub_10051B68; // weak
extern _UNKNOWN sub_10051B98; // weak
extern _UNKNOWN sub_10051BD9; // weak
extern _UNKNOWN sub_10051C08; // weak
extern _UNKNOWN sub_10051C49; // weak
extern _UNKNOWN sub_10051C78; // weak
extern _UNKNOWN sub_10051CC4; // weak
extern _UNKNOWN sub_10051D1B; // weak
extern _UNKNOWN sub_10051D58; // weak
extern _UNKNOWN sub_10051D88; // weak
extern _UNKNOWN sub_10051DE1; // weak
extern _UNKNOWN sub_10051E44; // weak
extern _UNKNOWN sub_10051E98; // weak
extern _UNKNOWN sub_10051EE1; // weak
extern _UNKNOWN sub_10051F18; // weak
extern _UNKNOWN sub_10051F40; // weak
extern _UNKNOWN sub_10051F70; // weak
extern _UNKNOWN sub_10051FB9; // weak
extern _UNKNOWN sub_10051FF9; // weak
extern _UNKNOWN sub_1005204E; // weak
extern _UNKNOWN sub_10052088; // weak
extern _UNKNOWN sub_100520D4; // weak
extern _UNKNOWN sub_10052130; // weak
extern _UNKNOWN sub_10052174; // weak
extern _UNKNOWN sub_100521B3; // weak
extern _UNKNOWN sub_100521E8; // weak
extern _UNKNOWN sub_1005223F; // weak
extern _UNKNOWN sub_1005226B; // weak
extern _UNKNOWN sub_100522BC; // weak
extern _UNKNOWN sub_100522FE; // weak
extern _UNKNOWN sub_100523BD; // weak
extern _UNKNOWN sub_10052401; // weak
extern _UNKNOWN sub_1005242B; // weak
extern _UNKNOWN sub_10052463; // weak
extern _UNKNOWN sub_1005248B; // weak
extern _UNKNOWN sub_100524D9; // weak
extern _UNKNOWN sub_10052566; // weak
extern _UNKNOWN sub_100525A6; // weak
extern _UNKNOWN sub_100525D8; // weak
extern _UNKNOWN sub_1005260B; // weak
extern _UNKNOWN sub_1005266A; // weak
extern _UNKNOWN sub_100526BC; // weak
extern _UNKNOWN sub_100526F3; // weak
extern _UNKNOWN sub_10052741; // weak
extern _UNKNOWN sub_10052773; // weak
extern _UNKNOWN sub_1005280D; // weak
extern _UNKNOWN sub_1005285C; // weak
extern _UNKNOWN sub_1005289E; // weak
extern _UNKNOWN sub_100528C8; // weak
extern _UNKNOWN sub_10052978; // weak
extern _UNKNOWN sub_100529A8; // weak
extern _UNKNOWN sub_100529D8; // weak
extern _UNKNOWN sub_10052A08; // weak
extern _UNKNOWN sub_10052A80; // weak
extern _UNKNOWN sub_10052AC0; // weak
extern _UNKNOWN sub_10052B40; // weak
extern _UNKNOWN sub_10052B80; // weak
extern _UNKNOWN sub_10052BB8; // weak
extern _UNKNOWN sub_10052BE8; // weak
extern _UNKNOWN sub_10052C18; // weak
extern _UNKNOWN sub_10052C69; // weak
extern _UNKNOWN sub_10052CB0; // weak
extern _UNKNOWN sub_10052CE8; // weak
extern _UNKNOWN sub_10052D18; // weak
extern _UNKNOWN sub_10052D6C; // weak
extern _UNKNOWN sub_10052E21; // weak
extern _UNKNOWN sub_10052E60; // weak
extern _UNKNOWN sub_10052E98; // weak
extern _UNKNOWN sub_10052ED8; // weak
extern _UNKNOWN sub_10052F10; // weak
extern _UNKNOWN sub_10052F50; // weak
extern _UNKNOWN sub_10052F98; // weak
extern _UNKNOWN sub_10052FE8; // weak
extern _UNKNOWN sub_10053028; // weak
extern _UNKNOWN sub_10053071; // weak
extern _UNKNOWN sub_100530C0; // weak
extern _UNKNOWN sub_100530F8; // weak
extern _UNKNOWN sub_1005312B; // weak
extern _UNKNOWN sub_10053160; // weak
extern _UNKNOWN sub_10053188; // weak
extern _UNKNOWN sub_100531B8; // weak
extern _UNKNOWN sub_100531E8; // weak
extern _UNKNOWN sub_10053228; // weak
extern _UNKNOWN sub_1005326B; // weak
extern _UNKNOWN sub_10053298; // weak
extern _UNKNOWN sub_100532C8; // weak
extern _UNKNOWN sub_100532F8; // weak
extern _UNKNOWN sub_10053330; // weak
extern _UNKNOWN sub_1005335B; // weak
extern _UNKNOWN sub_10053393; // weak
extern _UNKNOWN sub_100533CB; // weak
extern _UNKNOWN sub_100533F8; // weak
extern _UNKNOWN sub_10053438; // weak
extern _UNKNOWN sub_10053470; // weak
extern _UNKNOWN sub_100534A0; // weak
extern _UNKNOWN sub_100534C8; // weak
extern _UNKNOWN sub_100534F8; // weak
extern _UNKNOWN sub_10053528; // weak
extern _UNKNOWN sub_10053558; // weak
extern _UNKNOWN sub_10053588; // weak
extern _UNKNOWN sub_100535B8; // weak
extern _UNKNOWN sub_10053608; // weak
extern _UNKNOWN sub_10053640; // weak
extern _UNKNOWN sub_10053670; // weak
extern _UNKNOWN sub_100536A8; // weak
extern _UNKNOWN sub_100536D8; // weak
extern _UNKNOWN sub_10053708; // weak
extern _UNKNOWN sub_10053738; // weak
extern _UNKNOWN sub_10053776; // weak
extern _UNKNOWN sub_100537B3; // weak
extern _UNKNOWN sub_10053813; // weak
extern _UNKNOWN sub_10053869; // weak
extern _UNKNOWN sub_10053898; // weak
extern _UNKNOWN sub_100538C8; // weak
extern _UNKNOWN unk_100541F8; // weak
extern _UNKNOWN unk_1005425C; // weak
extern _UNKNOWN unk_10054260; // weak
extern _UNKNOWN unk_10054278; // weak
extern _UNKNOWN unk_1005427C; // weak
extern _UNKNOWN unk_10054290; // weak
extern _UNKNOWN unk_10054294; // weak
extern _UNKNOWN unk_10054298; // weak
extern int (__stdcall *off_100542A4)(char); // weak
extern char aBadAllocation[15]; // weak
extern int (__stdcall *off_100542C0)(char); // weak
extern int (__stdcall *off_100542CC)(char); // weak
extern int (__stdcall *off_100542D8)(char); // weak
extern int (__stdcall *off_100542E4)(char); // weak
extern int (__stdcall *off_100542F0)(char); // weak
extern int (__stdcall *off_100542FC)(char); // weak
extern char aBadFunctionCal[18]; // weak
extern int (__stdcall *off_1005431C)(char); // weak
extern int (__stdcall *off_1005438C)(char); // weak
extern char aRegex_errorErr[88]; // weak
extern char aRegex_errorE_0[84]; // weak
extern char aRegex_errorE_1[104]; // weak
extern char aRegex_errorE_2[80]; // weak
extern char aRegex_errorE_3[71]; // weak
extern char aRegex_errorE_4[71]; // weak
extern char aRegex_errorE_5[71]; // weak
extern char aRegex_errorE_6[92]; // weak
extern char aRegex_errorE_7[112]; // weak
extern char aRegex_errorE_8[111]; // weak
extern char aRegex_errorE_9[90]; // weak
extern char aRegex_error_10[123]; // weak
extern char aRegex_error_11[146]; // weak
extern char aRegex_error_12[25]; // weak
extern char aRegex_error_13[26]; // weak
extern char aRegex_error[12]; // weak
extern _UNKNOWN unk_100548D0; // weak
extern char *off_100548D4; // weak
extern _UNKNOWN unk_10054B28; // weak
extern char *off_10054B2C; // weak
extern int dword_10055628; // weak
extern int dword_1005562C; // weak
extern int (__stdcall *off_10055634)(char); // weak
extern int (__stdcall *off_10055644)(char); // weak
extern _UNKNOWN unk_10055650; // weak
extern _UNKNOWN unk_10055654; // weak
extern int (*off_1005565C[3])(); // weak
extern int (__stdcall *off_10055678)(char); // weak
extern int (__stdcall *off_10055684)(char); // weak
extern int (__stdcall *off_10055690)(char); // weak
extern int (__stdcall *off_1005569C)(char); // weak
extern int (*off_100556A8)(); // weak
extern int (__stdcall *off_100556B0)(char); // weak
extern int (__stdcall *off_100556E0)(char); // weak
extern int (__stdcall *off_10055710)(char); // weak
extern int (__stdcall *off_1005573C)(char); // weak
extern int (__stdcall *off_100558C4)(char); // weak
extern int (*off_100558D0[2])(); // weak
extern char aBadException[14]; // weak
extern char a_debugmallocat[52]; // weak
extern int (*off_10055928[2])(); // weak
extern int (*off_1005593C)(); // weak
extern int (__stdcall *off_10055950)(char); // weak
extern char aUnknownExcepti[18]; // weak
extern int (__stdcall *off_10055970)(char); // weak
extern int (__stdcall *off_1005597C)(char); // weak
extern int (__stdcall *off_10055988)(char); // weak
extern int (__stdcall *off_10055994)(char); // weak
extern int (__stdcall *off_1005599C)(char); // weak
extern char aLockAlreadyTak[19]; // weak
extern int (__stdcall *off_100559BC)(char); // weak
extern int (__stdcall *off_100559C8)(char); // weak
extern int (__stdcall *off_100559D4)(char); // weak
extern int (__stdcall *off_100559E0)(char); // weak
extern int (__stdcall *off_100559EC)(char); // weak
extern int (__stdcall *off_100559F8)(char); // weak
extern int (__stdcall *off_10055A04)(char); // weak
extern int (__stdcall *off_10055A10)(char); // weak
extern int (__stdcall *off_10055A1C)(char); // weak
extern int (__stdcall *off_10055A28)(char); // weak
extern int (__stdcall *off_10055A34)(char); // weak
extern int (__stdcall *off_10055A40)(char); // weak
extern int (__stdcall *off_10055A4C)(char); // weak
extern int (__stdcall *off_10055A58)(char); // weak
extern int (__stdcall *off_10055A64)(char); // weak
extern int (__stdcall *off_10055A70)(char); // weak
extern int (*off_10055A7C[5])(); // weak
extern int (__stdcall *off_10055A94)(int, int); // weak
extern int (*off_10055AAC[5])(); // weak
extern int (__stdcall *off_10055AC8)(int, int); // weak
extern int (__stdcall *off_10055AE4)(int, int); // weak
extern int (__stdcall *off_10055B00)(char); // weak
extern char aPevents[8]; // weak
extern int (__stdcall *off_10055B10)(char); // weak
extern int (__stdcall *off_10055B1C)(int); // weak
extern int (__stdcall *off_10055B28)(char); // weak
extern int (*off_10055B30[5])(); // weak
extern int (*off_10055B4C[5])(); // weak
extern int (__stdcall *off_10055B98)(char); // weak
extern int (__stdcall *off_10055BA8)(char); // weak
extern struct _EXCEPTION_POINTERS ExceptionInfo; // idb
extern int dword_10055BC0[]; // weak
extern const WCHAR LibFileName[]; // idb
extern char ProcName[]; // idb
extern char aUnregistertrac[21]; // weak
extern char aTraceevent[11]; // weak
extern char aGettracelogger[21]; // weak
extern char aGettraceenable[20]; // weak
extern char aGettraceenab_0[20]; // weak
extern int (__stdcall *off_10055DE0)(char); // weak
extern int (*off_10055DF4[4])(); // weak
extern int (__stdcall *off_10055E0C)(char); // weak
extern int (__stdcall *off_10055E44)(char); // weak
extern int (__stdcall *off_10055E4C)(char); // weak
extern int (__stdcall *off_10055E54)(char); // weak
extern int (__stdcall *off_10055EB8)(char); // weak
extern int (__stdcall *off_10055ECC)(int, int); // weak
extern int (__stdcall *off_10055EF8)(char); // weak
extern int (__stdcall *off_10055F0C)(int, int); // weak
extern char aEventobject[12]; // weak
extern char aPpvirtualproce[24]; // weak
extern char aCount[6]; // weak
extern int (__stdcall *dword_10055F60)(_DWORD, _DWORD, _DWORD); // weak
extern _UNKNOWN unk_10055F64; // weak
extern int (__cdecl *off_10055F84)(_DWORD, _DWORD); // weak
extern wchar_t asc_10056088[33]; // weak
extern _UNKNOWN unk_10056510; // weak
extern _UNKNOWN unk_10056690; // weak
extern int (__cdecl *off_10056790)(_DWORD); // weak
extern const WCHAR ModuleName[]; // idb
extern char aFlsalloc[]; // idb
extern char aFlsfree[]; // idb
extern char aFlsgetvalue[]; // idb
extern char aFlssetvalue[]; // idb
extern char aInitializecrit[]; // idb
extern char aCreatesemaphor[]; // idb
extern char aSetthreadstack[]; // idb
extern char aCreatethreadpo[]; // idb
extern char aSetthreadpoolt[]; // idb
extern char aWaitforthreadp[]; // idb
extern char aClosethreadpoo[]; // idb
extern char aCreatethread_0[]; // idb
extern char aSetthreadpoolw[]; // idb
extern char aClosethreadp_0[]; // idb
extern char aFlushprocesswr[]; // idb
extern char aFreelibrarywhe[]; // idb
extern char aGetcurrentproc[]; // idb
extern char aGetlogicalproc[]; // idb
extern char aCreatesymbolic[]; // idb
extern char aSetdefaultdlld[]; // idb
extern char aEnumsystemloca[]; // idb
extern char aComparestringe[]; // idb
extern char aGetdateformate[]; // idb
extern char aGetlocaleinfoe[]; // idb
extern char aGettimeformate[]; // idb
extern char aGetuserdefault[]; // idb
extern char aIsvalidlocalen[]; // idb
extern char aLcmapstringex[]; // idb
extern char aGetcurrentpack[]; // idb
extern int dword_10056A18[]; // weak
extern _DWORD off_10056A1C[2]; // idb
extern void *off_10057138; // weak
extern int dword_1005713C[]; // weak
extern const WCHAR aMscoree_dll[]; // idb
extern char aCorexitprocess[]; // idb
extern int dword_10059378[]; // weak
extern _DWORD off_1005937C[2]; // idb
extern wchar_t aRuntimeErrorPr[26]; // weak
extern wchar_t aProgramNameUnk[23]; // weak
extern wchar_t a___[4]; // weak
extern wchar_t asc_100594F8[3]; // weak
extern wchar_t aMicrosoftVisua[37]; // weak
extern char aSetthreadgroup[]; // idb
extern char aGetthreadgroup[]; // idb
extern char aGetcurrentpr_0[]; // idb
extern char aGetlogicalpr_0[]; // idb
extern int (*off_100595C0)(); // weak
extern int (*off_100595CC[3])(); // weak
extern int (*off_100595E4[2])(); // weak
extern char aPscheduler[11]; // weak
extern int (__stdcall *off_1005961C)(char); // weak
extern int (__stdcall *off_10059630)(int, int); // weak
extern char aProc[5]; // weak
extern int (__stdcall *off_10059B08)(char); // weak
extern int (*off_10059B30[5])(); // weak
extern int (*off_10059B48[3])(); // weak
extern int (*off_10059B74[5])(); // weak
extern char aPthreadproxy[13]; // weak
extern int (*off_10059BD4[5])(); // weak
extern int (*off_10059C20[7])(); // weak
extern int (*off_10059C40[3])(); // weak
extern int (*off_10059C6C[5])(); // weak
extern int (*off_10059CB8[2])(); // weak
extern int (__stdcall *off_10059CDC)(int); // weak
extern _UNKNOWN unk_10059D40; // weak
extern int dword_10059DD0; // weak
extern int dword_10059DD8; // weak
extern int dword_10059DDC; // weak
extern int (*off_10059DE8)(); // weak
extern wchar_t *off_10059DEC; // weak
extern wchar_t *off_10059E1C; // weak
extern const CHAR MultiByteStr; // idb
extern wchar_t asc_10059F28[3]; // weak
extern wchar_t asc_10059F30[2]; // weak
extern wchar_t aC[2]; // weak
extern wchar_t a__[4]; // weak
extern wchar_t *off_10059F4C[4]; // weak
extern wchar_t *off_10059F50[3]; // weak
extern wchar_t *off_10059F54[2]; // weak
extern wchar_t *off_10059F58; // weak
extern _UNKNOWN unk_10059F5C; // weak
extern _UNKNOWN unk_10059F60; // weak
extern _UNKNOWN unk_10059F64; // weak
extern char aLog10[6]; // weak
extern char aAsin[5]; // weak
extern char aAcos[5]; // weak
extern char aAtan[5]; // weak
extern char aSqrt_0[5]; // weak
extern char aSin[4]; // weak
extern char aCos[4]; // weak
extern char aTan[4]; // weak
extern char aCeil[5]; // weak
extern char aFloor[6]; // weak
extern char aModf[5]; // weak
extern char aE000[6]; // weak
extern _UNKNOWN unk_1005A08C; // weak
extern const WCHAR aUser32_dll[]; // idb
extern char aMessageboxw[]; // idb
extern char aGetactivewindo[]; // idb
extern char aGetlastactivep[]; // idb
extern char aGetuserobjecti[]; // idb
extern char aGetprocesswind[]; // idb
extern int (*off_1005A88C[2])(); // weak
extern char aPcontext[9]; // weak
extern const WCHAR aCombase_dll[]; // idb
extern char aRoinitialize[]; // idb
extern char aRouninitialize[15]; // weak
extern int (*off_1005A940)(); // weak
extern int (*off_1005A95C[5])(); // weak
extern int dword_1005A974[]; // weak
extern void *off_1005A984; // weak
extern int (__stdcall *off_1005A988)(int, int); // weak
extern int (__stdcall *off_1005A9B4)(int, int); // weak
extern void *off_1005A9C0; // weak
extern char byte_1005A9E0[]; // weak
extern int (__stdcall *off_1005AA40)(char); // weak
extern wchar_t *off_1005AA68; // weak
extern wchar_t *off_1005B518; // weak
extern int dword_1005B7EC; // weak
extern int dword_1005B7F0; // weak
extern wchar_t aAcp[4]; // weak
extern wchar_t aOcp[4]; // weak
extern __int16 word_1005B804; // weak
extern int (*off_1005B81C[2])(); // weak
extern int (*off_1005B848[2])(); // weak
extern char aSwitchstate[12]; // weak
extern char aBadDynamic_cas[18]; // weak
extern int (*off_1005B8B8[4])(); // weak
extern char a1Snan[7]; // weak
extern char a1Ind[6]; // weak
extern char a1Inf[6]; // weak
extern char a1Qnan[7]; // weak
extern _UNKNOWN unk_1005BE2A; // weak
extern const WCHAR FileName[]; // idb
extern char aExp10[6]; // weak
extern char aGeneric[8]; // weak
extern char aUnknownError[14]; // weak
extern char aIostream[9]; // weak
extern char aIostreamStream[22]; // weak
extern char aSystem[7]; // weak
extern char aVectorTTooLong[19]; // weak
extern _DWORD dword_1005BFA0[4]; // idb
extern _DWORD dword_1005BFB0[4]; // idb
extern _DWORD dword_1005BFC0[4]; // idb
extern _DWORD dword_1005BFE0[4]; // idb
extern _UNKNOWN unk_1005BFF0; // weak
extern int (*off_1005C020[5])(); // weak
extern int (*off_1005C03C[2])(); // weak
extern char aAValidJsonDocu[66]; // weak
extern char aSyntaxErrorVal[47]; // weak
extern char byte_1005C0C4[]; // weak
extern char byte_1005C0C8[]; // weak
extern char byte_1005C0D0[]; // weak
extern _UNKNOWN unk_1005C0D4; // weak
extern char aMissingAfterOb[37]; // weak
extern char aMissingOrInObj[41]; // weak
extern char aMissingOrObjec[34]; // weak
extern char aMissingOrInArr[40]; // weak
extern char aIsNotANumber_[19]; // weak
extern char asc_1005C18C[2]; // weak
extern char aLf[4]; // weak
extern char aAdditionalSixC[68]; // weak
extern char aExpectingAnoth[80]; // weak
extern char aBadUnicodeEsca[61]; // weak
extern char aBadUnicodeEs_0[67]; // weak
extern char aCommentsMustSt[27]; // weak
extern char a_16g[7]; // weak
extern _UNKNOWN unk_1005C520; // weak
extern _UNKNOWN unk_1005C528; // weak
extern _UNKNOWN unk_1005C52C; // weak
extern _UNKNOWN unk_1005C530; // weak
extern _UNKNOWN unk_1005C534; // weak
extern _UNKNOWN unk_1005C538; // weak
extern _UNKNOWN unk_1005C53C; // weak
extern _UNKNOWN unk_1005C540; // weak
extern _UNKNOWN unk_1005C544; // weak
extern char aNull[5]; // weak
extern char asc_1005C554[2]; // weak
extern char asc_1005C558[2]; // weak
extern char asc_1005C55C[2]; // weak
extern char asc_1005C560[2]; // weak
extern char asc_1005C564[3]; // weak
extern char asc_1005C568[2]; // weak
extern char asc_1005C56C[2]; // weak
extern char aInvalidMapSetT[28]; // weak
extern char aMapSetTTooLong[20]; // weak
extern char aPp[3]; // weak
extern char aEe[3]; // weak
extern char aP[3]; // weak
extern char aLu[3]; // weak
extern char aLd[3]; // weak
extern char aLu_0[3]; // weak
extern char aLd_0[3]; // weak
extern int (__stdcall *off_1005C5D4)(char); // weak
extern int (__stdcall *off_1005C610)(char); // weak
extern int (*off_1005C64C[6])(); // weak
extern int (*off_1005C658[3])(); // weak
extern char aBadLocaleName[16]; // weak
extern char aBadCast[9]; // weak
extern int (__stdcall *off_1005C6C8)(char); // weak
extern int (__stdcall *off_1005C6D0)(char); // weak
extern _UNKNOWN unk_1005C6D8; // weak
extern int (__stdcall *off_1005C6E0)(char); // weak
extern int (__stdcall *off_1005C6EC)(char); // weak
extern char aFalse[6]; // weak
extern char aTrue[5]; // weak
extern char a__[23]; // weak
extern _UNKNOWN unk_1005C72F; // weak
extern char aBIUrl__1[26]; // weak
extern char aB[2]; // weak
extern char aI[2]; // weak
extern char aUrl[4]; // weak
extern int (__stdcall *off_1005C820[5])(char); // weak
extern int (__stdcall *off_1005C824[4])(char); // weak
extern int (__stdcall *off_1005C828[3])(char); // weak
extern int (__stdcall *off_1005C82C[2])(char); // weak
extern int (__stdcall *off_1005C830)(char); // weak
extern char *off_1005C838; // weak
extern int dword_1005C83C; // weak
extern __int16 word_1005C840[]; // weak
extern char aJsonParsingFai[20]; // weak
extern char aYcombination[13]; // weak
extern char a1_00[5]; // weak
extern wchar_t aHttpForexsensa[33]; // weak
extern char aName[5]; // weak
extern char aVersion[8]; // weak
extern char aCode[5]; // weak
extern char aBroker[7]; // weak
extern char aServer[7]; // weak
extern char aAccount[8]; // weak
extern char aType[5]; // weak
extern char aBalance[8]; // weak
extern char aCurrency[9]; // weak
extern char aData[5]; // weak
extern char aFlags[6]; // weak
extern char aUtc_0[4]; // weak
extern char aMsg1[5]; // weak
extern char aMsg2[5]; // weak
extern char aAuth_interval[14]; // weak
extern char aRequestIsNotRe[21]; // weak
extern const WCHAR szHeaders[]; // idb
extern int (__stdcall *off_1005CBF8[2])(int); // weak
extern void *off_1005CC14; // weak
extern int (__stdcall *off_1005CC30)(char); // weak
extern int (__stdcall *off_1005CC38[2])(int); // weak
extern int (__stdcall *off_1005CC54[3])(int); // weak
extern int (__stdcall *off_1005CC8C[2])(char); // weak
extern int (__stdcall *off_1005CC90)(char); // weak
extern void *off_1005CC94; // weak
extern int (*off_1005CCB0[2])(); // weak
extern void *off_1005CCC0; // weak
extern void *off_1005CCDC; // weak
extern void *off_1005CCF8; // weak
extern void *off_1005CD14; // weak
extern void *off_1005CD30; // weak
extern int (*off_1005CD4C[2])(); // weak
extern int (__stdcall *off_1005CD5C)(int); // weak
extern int (*off_1005CD6C[2])(); // weak
extern int (__stdcall *off_1005CD7C)(int); // weak
extern int (__stdcall *off_1005CDA4)(int); // weak
extern int (__stdcall *off_1005CDCC)(char); // weak
extern int (__stdcall *off_1005CDE8)(char); // weak
extern int (__stdcall *off_1005CE04)(char); // weak
extern int (__stdcall *off_1005CE0C)(char); // weak
extern char aThenCannotBeCa[55]; // weak
extern int (__stdcall *off_1005CE4C)(char); // weak
extern int (__stdcall *off_1005CE54[3])(int, int, int); // weak
extern int (__stdcall *off_1005CE6C)(char); // weak
extern int (__stdcall *off_1005CE74)(char); // weak
extern int (*off_1005CE78)(); // weak
extern char a_ptarget[9]; // weak
extern int (__stdcall *off_1005CF90)(char); // weak
extern void *off_1005CFF0; // weak
extern int (*off_1005D010)(); // weak
extern int (__stdcall *off_1005D068)(char); // weak
extern void *off_1005D0D4; // weak
extern int (__stdcall *off_1005D0EC)(char); // weak
extern int (__stdcall *off_1005D17C)(char); // weak
extern int (__stdcall *off_1005D1A8)(char); // weak
extern char aDeletingLinkRe[53]; // weak
extern int (__stdcall *off_1005D208[3])(int); // weak
extern int (__stdcall *off_1005D22C)(char); // weak
extern char aWaitCannotBeCa[55]; // weak
extern void *off_1005D290; // weak
extern int (__stdcall *off_1005D2AC)(char); // weak
extern int (__stdcall *off_1005D2B4)(char); // weak
extern int (__stdcall *off_1005D2BC)(char); // weak
extern wchar_t aClient[7]; // weak
extern char aInvalidConnect[19]; // weak
extern wchar_t aPost[5]; // weak
extern wchar_t aGet[4]; // weak
extern int (__stdcall *off_1005D328)(char); // weak
extern _UNKNOWN unk_1005F818; // weak
extern _UNKNOWN unk_1005F820; // weak
extern _UNKNOWN unk_1005F828; // weak
extern _UNKNOWN unk_1005F860; // weak
extern _UNKNOWN unk_1005F89C; // weak
extern _UNKNOWN unk_1005F8D8; // weak
extern _UNKNOWN unk_1005F910; // weak
extern _UNKNOWN unk_1005FC7C; // weak
extern _UNKNOWN unk_1005FD6C; // weak
extern _UNKNOWN unk_1006008C; // weak
extern _UNKNOWN unk_100600C4; // weak
extern _UNKNOWN unk_100600FC; // weak
extern _UNKNOWN unk_100601A0; // weak
extern _UNKNOWN unk_10060498; // weak
extern _UNKNOWN unk_100604D0; // weak
extern _UNKNOWN unk_10060508; // weak
extern _EH4_SCOPETABLE stru_100605D0[1]; // weak
extern _UNKNOWN unk_1006091C; // weak
extern _UNKNOWN unk_10060CF4; // weak
extern _UNKNOWN unk_10060D2C; // weak
extern _UNKNOWN unk_10060D64; // weak
extern _UNKNOWN unk_10060E88; // weak
extern _UNKNOWN unk_10060EC0; // weak
extern _UNKNOWN unk_10060EF8; // weak
extern _UNKNOWN unk_10060F30; // weak
extern _UNKNOWN unk_10061140; // weak
extern _UNKNOWN unk_1006140C; // weak
extern _UNKNOWN unk_100614E0; // weak
extern _UNKNOWN unk_10061540; // weak
extern _UNKNOWN unk_100615D4; // weak
extern _UNKNOWN unk_100615F0; // weak
extern _UNKNOWN unk_1006162C; // weak
extern _UNKNOWN unk_1006169C; // weak
extern _UNKNOWN unk_10061764; // weak
extern _UNKNOWN unk_100617A0; // weak
extern volatile LONG Addend; // idb
extern int dword_10066258; // weak
extern int dword_1006636C; // weak
extern int (__stdcall **off_100664D8)(char); // weak
extern int (__stdcall **off_100664F8)(char); // weak
extern DWORD dwSpinCount; // idb
extern void **off_10066C60; // weak
extern void *off_10066C68; // weak
extern void *off_10066C6C; // weak
extern void *off_10066C70; // weak
extern void *off_10066C74; // weak
extern void *off_10066C78; // weak
extern void *off_10066C7C; // weak
extern void *off_10066C80; // weak
extern void *off_10066C84; // weak
extern void *off_10066C88; // weak
extern void *off_10066C8C; // weak
extern void *off_10066C98; // weak
extern void *off_10066C9C; // weak
extern void *off_10066CA0; // weak
extern void *off_10066CA4; // weak
extern void *off_10066CA8; // weak
extern void *off_10066CAC; // weak
extern void *off_10066CB0; // weak
extern void *off_10066CB4; // weak
extern void *off_10066CC0; // weak
extern int dword_10066D24; // weak
extern LPCRITICAL_SECTION lpCriticalSection; // idb
extern wchar_t *off_10067090; // weak
extern void *off_10067094; // weak
extern int dword_10067098[]; // weak
extern int dword_1006709C[]; // weak
extern _UNKNOWN unk_10067200; // weak
extern _UNKNOWN unk_10067204; // weak
extern int __security_cookie; // weak
extern int dword_10067214; // weak
extern int dword_10067220; // weak
extern int dword_10067238; // weak
extern int dword_10067248; // weak
extern int dword_10067250; // weak
extern _UNKNOWN unk_10067260; // weak
extern _UNKNOWN unk_10067268; // weak
extern char *off_100673A4; // weak
extern wchar_t *off_100673A8; // weak
extern _UNKNOWN unk_100673AC; // weak
extern void *off_100673B0; // weak
extern volatile LONG *off_10067514; // idb
extern volatile LONG dword_10067518; // idb
extern wchar_t *off_100675A8; // weak
extern int dword_100675D4; // weak
extern _UNKNOWN unk_100675D8; // weak
extern char *off_10067600[11]; // weak
extern char *off_10067608[9]; // weak
extern void *off_10067790; // weak
extern _UNKNOWN unk_100679F0; // weak
extern _UNKNOWN unk_10067A10; // weak
extern wchar_t *off_10067A50; // weak
extern LPVOID lpAddend; // idb
extern char byte_10067A5C[]; // weak
extern int dword_10067A60; // weak
extern char aVyv[6]; // weak
extern char aJ[3]; // weak
extern char byte_10067B50[]; // weak
extern char byte_10067C58[]; // weak
extern _UNKNOWN unk_10067D58; // weak
extern double dbl_10067F78; // weak
extern double dbl_10067F80; // weak
extern double dbl_10067F88; // weak
extern double dbl_10067F98; // weak
extern int dword_10067FA0[]; // weak
extern void *off_10067FA4; // weak
extern int dword_100680A0; // weak
extern int (*off_100680A4[10])(); // weak
extern int (*off_100680A8[9])(); // weak
extern int (*off_100680AC[8])(); // weak
extern int (*off_100680B0[7])(); // weak
extern int (*off_100680B4[6])(); // weak
extern int (*off_100680B8[5])(); // weak
extern PVOID off_100680BC; // idb
extern PVOID off_100680C0; // idb
extern PVOID off_100680C4; // idb
extern PVOID off_100680C8; // idb
extern _DWORD dword_100683F0[4]; // idb
extern int dword_10068400; // weak
extern char byte_10068528[]; // weak
extern int dword_10068628; // weak
extern int dword_1006862C; // weak
extern int dword_10068630; // weak
extern int dword_10068634; // weak
extern int dword_10068638; // weak
extern int dword_1006863C; // weak
extern int dword_10068640; // weak
extern int dword_10068644; // weak
extern int dword_10068648; // weak
extern int dword_1006864C; // weak
extern int dword_10068650; // weak
extern int dword_10068654; // weak
extern HANDLE hConsoleOutput; // idb
extern _UNKNOWN unk_10068668; // weak
extern _UNKNOWN unk_100687C8; // weak
extern int (__stdcall **off_10068A94)(char); // weak
extern int (__stdcall **off_10068ACC)(char); // weak
extern int (__stdcall **off_10068B04)(char); // weak
extern int (__stdcall **off_10068B3C)(char); // weak
extern int (__stdcall **off_10068B74)(char); // weak
extern int (__stdcall **off_10068BAC)(char); // weak
extern int (__stdcall **off_10068BE4)(char); // weak
extern int (__stdcall **off_10068C1C)(char); // weak
extern int (__stdcall **off_10068C54)(char); // weak
extern int (__stdcall **off_10068C90)(char); // weak
extern int (__stdcall **off_10068DEC)(char); // weak
extern int (__stdcall *off_10068E24[3])(char); // weak
extern int (__stdcall *off_10068E28[2])(char); // weak
extern int dword_10068E30; // weak
extern int dword_10068E40; // weak
extern int dword_10068E44; // weak
extern int dword_10068E48; // weak
extern int dword_10068E58; // weak
extern int dword_10068E5C; // weak
extern int dword_10068E60; // weak
extern int dword_10068E70; // weak
extern int dword_10068E74; // weak
extern int dword_10068E78; // weak
extern int dword_10068E88; // weak
extern int dword_10068E8C; // weak
extern LPCWSTR pszAgentW; // idb
extern int dword_10068EA0; // weak
extern int dword_10068EA4; // weak
extern char byte_10068EF0[]; // weak
extern int dword_10068F04; // weak
extern int dword_10068F08; // weak
extern int dword_10068F0C; // weak
extern int dword_10068F10; // weak
extern int dword_10068F14; // weak
extern int dword_10068F28; // weak
extern char byte_10068F30; // weak
extern _UNKNOWN unk_10068F38; // weak
extern struct _RTL_CRITICAL_SECTION CriticalSection; // idb
extern _UNKNOWN unk_10068FA0; // weak
extern int dword_10068FA4; // weak
extern _UNKNOWN unk_10068FA8; // weak
extern _UNKNOWN dword_10068FD0; // weak
extern _UNKNOWN unk_10068FF8; // weak
extern int dword_10069098; // weak
extern int dword_1006909C; // weak
extern int dword_100690A8; // weak
extern int dword_100690AC; // weak
extern int dword_100690B4; // weak
extern int dword_100690C0; // weak
extern int dword_100690C4; // weak
extern int dword_100690CC; // weak
extern int dword_100690D0; // weak
extern int dword_100690D4; // weak
extern int dword_10069110; // weak
extern __int16 word_1006919C; // weak
extern __int16 word_100691A0; // weak
extern __int16 word_100691A4; // weak
extern __int16 word_100691A8; // weak
extern int dword_100691AC; // weak
extern int dword_100691B0; // weak
extern int dword_100691B4; // weak
extern int dword_100691B8; // weak
extern int dword_100691BC; // weak
extern int dword_100691C0; // weak
extern int dword_100691C4; // weak
extern int dword_100691C8; // weak
extern __int16 word_100691CC; // weak
extern int dword_100691D0; // weak
extern int dword_100691D4; // weak
extern __int16 word_100691D8; // weak
extern int dword_100693DC; // weak
extern int dword_100693E8; // weak
extern char byte_100693EC; // weak
extern int dword_100693F0; // weak
extern int dword_100693F4; // weak
extern int dword_100693F8; // weak
extern int dword_10069400; // weak
extern int dword_10069404; // weak
extern int dword_10069410; // weak
extern int dword_10069414; // weak
extern DWORD dwTlsIndex; // idb
extern _UNKNOWN unk_1006941C; // weak
extern int dword_10069420; // weak
extern int dword_10069424; // weak
extern _UNKNOWN unk_10069440; // weak
extern HMODULE hLibModule; // idb
extern int dword_1006944C; // weak
extern int dword_10069450; // weak
extern LPVOID dword_10069454; // idb
extern _UNKNOWN unk_10069460; // weak
extern int dword_100695B0; // weak
extern int dword_100695B4; // weak
extern int (__stdcall *dword_100695B8)(_DWORD, _DWORD, _DWORD); // weak
extern PVOID dword_100695BC; // idb
extern int dword_100695C0; // weak
extern int dword_100695C4; // weak
extern char byte_100695CC; // weak
extern int dword_100695D0; // weak
extern int dword_100695DC; // weak
extern int dword_100695E0; // weak
extern LPVOID dword_100695E4; // idb
extern LPVOID dword_100695E8; // idb
extern LPVOID dword_100695EC; // idb
extern LPVOID lpMem; // idb
extern int dword_100695F4; // weak
extern int dword_10069600; // weak
extern _UNKNOWN unk_10069608; // weak
extern WCHAR Filename; // idb
extern __int16 word_10069842; // weak
extern PVOID dword_10069C30; // idb
extern _UNKNOWN unk_10069C34; // weak
extern LPVOID dword_10069C38; // idb
extern int dword_10069C3C; // weak
extern int dword_10069C40; // weak
extern int dword_10069C44; // weak
extern int dword_10069C4C; // weak
extern ULONG_PTR ProcessAffinityMask; // idb
extern ULONG_PTR SystemAffinityMask; // idb
extern int dword_10069C58; // weak
extern int dword_10069C5C; // weak
extern int dword_10069C60; // weak
extern char byte_10069C64; // weak
extern int dword_10069C68; // weak
extern int dword_10069C6C; // weak
extern int dword_10069C70; // weak
extern int dword_10069C74; // weak
extern LPVOID dword_10069C78; // idb
extern PVOID dword_10069C80; // idb
extern PVOID dword_10069C8C; // idb
extern int dword_10069C90; // weak
extern HANDLE hHeap; // idb
extern int dword_10069C98; // weak
extern union _SLIST_HEADER ListHead; // idb
extern int dword_10069CA8; // weak
extern int dword_10069CAC; // weak
extern int dword_10069CB0; // weak
extern int dword_10069CB4; // weak
extern int dword_10069CB8; // weak
extern DWORD dword_10069CD0; // idb
extern int dword_10069CD8; // weak
extern int dword_10069CE0[]; // weak
extern char byte_10069DE0[260]; // idb
extern char byte_10069EE4; // weak
extern int dword_10069EE8; // weak
extern int dword_10069EEC; // weak
extern int dword_10069EF0; // weak
extern int dword_10069EF4; // weak
extern __int16 word_10069EF8[]; // weak
extern int dword_10069F04; // weak
extern PVOID dword_10069F08; // idb
extern int dword_10069F0C; // weak
extern PVOID dword_10069F10; // idb
extern int dword_10069F14; // weak
extern int dword_10069FDC; // weak
extern LPVOID dword_10069FE0; // idb
extern LPVOID dword_10069FE4; // idb
extern int dword_10069FE8; // weak
extern PVOID dword_10069FEC; // idb
extern PVOID dword_10069FF0; // idb
extern PVOID dword_10069FF4; // idb
extern PVOID dword_10069FF8; // idb
extern PVOID dword_10069FFC; // idb
extern int dword_1006A044; // weak
extern int dword_1006A048; // weak
extern int dword_1006A04C; // weak
extern _UNKNOWN unk_1006A050; // weak
extern int dword_1006A058; // weak
extern int dword_1006A060; // weak
extern char byte_1006A070; // weak
extern _UNKNOWN unk_1006A074; // weak
extern int dword_1006A0D8; // weak
extern int dword_1006A0E0; // weak
extern int dword_1006A0E4; // weak
extern int dword_1006A0E8; // weak
extern int dword_1006A0EC; // weak
extern int dword_1006A0F0; // weak
extern int dword_1006A0F4; // weak
extern int dword_1006A0F8; // weak
extern int dword_1006A110; // weak
extern int dword_1006A120; // weak
extern int dword_1006A124; // weak
extern int dword_1006A128; // weak
extern int dword_1006A138; // weak
extern int dword_1006A13C; // weak
extern int dword_1006A140; // weak
extern int dword_1006A150; // weak
extern int dword_1006A154; // weak
extern int dword_1006A158; // weak
extern int dword_1006A15C; // weak
extern int dword_1006A168; // weak
extern int dword_1006A178; // weak
extern int dword_1006A17C; // weak
extern int dword_1006A180; // weak
extern int dword_1006A184; // weak
extern __int64 qword_1006A188; // weak
extern int dword_1006A190; // weak
extern int dword_1006A194; // weak
extern int dword_1006A1A4; // weak
extern int dword_1006A1A8; // weak
extern int dword_1006A1AC; // weak
extern int dword_1006A1B0; // weak
extern int dword_1006A1B4; // weak
extern int dword_1006A1B8; // weak
extern int dword_1006A1BC; // weak
extern int dword_1006A1C0; // weak
extern int dword_1006A1D0; // weak
extern int dword_1006A1D4; // weak
extern int dword_1006A1D8; // weak
extern int dword_1006A1DC; // weak
extern int dword_1006A1E0; // weak
extern int dword_1006A1E4; // weak
extern int dword_1006A1E8; // weak
extern int dword_1006A1F0; // weak
extern _UNKNOWN unk_1006A2E8; // weak
extern int dword_1006A2F8; // weak
extern int dword_1006A300; // weak
extern int dword_1006A304; // weak
extern int dword_1006A308; // weak
extern _UNKNOWN unk_1006A30C; // weak
extern int dword_1006A324; // weak
extern int dword_1006A328; // weak
extern _UNKNOWN unk_1006A330; // weak
extern int dword_1006A338; // weak
extern _UNKNOWN unk_1006A344; // weak
extern int dword_1006A35C; // weak
extern int dword_1006A360; // weak
extern HINTERNET hInternet; // idb
extern WINHTTP_CURRENT_USER_IE_PROXY_CONFIG pProxyConfig; // idb
extern int dword_1006A380; // weak
extern int dword_1006A384; // weak
extern int dword_1006A388; // weak
extern PVOID dword_1006A38C; // idb
extern int dword_1006A390; // weak
extern int dword_1006A394; // weak
extern LPVOID dword_1006A398; // idb
extern int dword_1006A39C; // weak
extern int dword_1006B3A0; // weak
extern int (__thiscall *dword_1006B3A4)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
extern PVOID dword_1006B3A8; // idb
extern PVOID Ptr; // idb
extern int dword_1006B3B0; // weak
extern int dword_1006B3B4; // weak
extern int dword_1006B3C0; // weak
extern int dword_1006B3C4; // weak
extern int dword_1006B3C8; // weak
extern int dword_1006B3CC; // weak
extern int dword_1006B3D0; // weak
extern int dword_1006B3D4; // weak
extern int dword_1006B3D8; // weak
extern int dword_1006B3DC; // weak
extern int dword_1006B3E0; // weak
extern int dword_1006B3E4; // weak
extern int dword_1006B3E8; // weak
extern int dword_1006B3EC; // weak
extern int dword_1006B3F0; // weak
extern int dword_1006B3F4; // weak
extern int dword_1006B3F8; // weak
extern int dword_1006B3FC; // weak
extern int dword_1006B400; // weak
extern int dword_1006B404; // weak
extern int dword_1006B408; // weak
extern int dword_1006B40C; // weak
extern int dword_1006B410; // weak
extern int dword_1006B414; // weak
extern int dword_1006B418; // weak
extern int dword_1006B41C; // weak
extern int dword_1006B420; // weak
extern int dword_1006B424; // weak
extern int dword_1006B428; // weak
extern int dword_1006B42C; // weak
extern int dword_1006B430; // weak
extern int dword_1006B434; // weak

//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int loc_10001000(); // weak
int __cdecl sub_10001010(int a1);
int __cdecl sub_10001090(int a1);
int __thiscall nullsub_3(_DWORD); // weak
void *__thiscall sub_100010C0(void *this, char a2);
int __thiscall sub_100010F0(void *this, int a2, int a3);
char __thiscall sub_10001110(void *this, int a2, int a3);
char __thiscall sub_10001150(void *this, int a2, int a3);
int __cdecl sub_10001170();
int __stdcall sub_10001180(int a1, int a2);
int __cdecl sub_100011F0();
int __stdcall sub_10001200(int a1, int a2);
int __cdecl sub_10001250();
int __stdcall sub_10001260(int a1, int a2);
int __stdcall sub_100012D0(int a1, int a2);
int __thiscall sub_10001320(void *this);
int __thiscall sub_10001340(void *this);
void *__thiscall sub_10001350(void *this, char a2);
int __thiscall sub_10001380(int this, int a2);
char __cdecl sub_100013B0(int a1);
int loc_100013D0(); // weak
int __thiscall sub_100013E0(int this, int a2, int a3);
int loc_10001480(); // weak
int __thiscall sub_10001490(void *this);
int __stdcall sub_100014C0(int a1);
void *__thiscall sub_100014D0(void *this, char a2);
int __thiscall sub_10001500(void *this);
// int __usercall sub_10001590<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
// char __userpurge sub_100015F0<al>(int a1<ecx>, int a2<edi>, int a3);
// int __userpurge sub_100016A0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4, int a5);
int __stdcall loc_100016FC(int, int); // weak
int (__stdcall *__cdecl sub_10001722())(int, int);
int __thiscall sub_10001730(int this);
int loc_10001870(); // weak
void __thiscall sub_100018B0(int this, int a2);
void __thiscall sub_10001940(int this, int a2);
signed int __stdcall sub_100019C0(int a1, int a2, int a3);
int __thiscall sub_100019D0(int this, const char *a2);
int __thiscall sub_10001A30(int this);
int __thiscall sub_10001A60(int this);
int __thiscall sub_10001AA0(int this, int a2);
int __thiscall sub_10001B10(_DWORD); // weak
// int __userpurge sub_10001B20<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10001B40<eax>(int a1<ecx>, int a2<ebx>, char a3);
int loc_10001B70(); // weak
void *__thiscall sub_10001BA0(void *this, char a2);
int __thiscall sub_10001CD0(int this, int a2);
void *__thiscall sub_10001D00(void *this);
// int (__cdecl *__usercall sub_10001FA0<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<ebx>, int a5<edi>, int a6<esi>, int a7, unsigned int a8))(int, int);
int __cdecl loc_10002055(int, int); // weak
// int __usercall sub_10002120<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4);
_DWORD __stdcall nullsub_1(_DWORD); // weak
void *__thiscall sub_100021F0(void *this, int a2);
// int __usercall sub_10002260<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
int __thiscall sub_10002270(void *this);
int __fastcall sub_10002280(int a1, const char *a2);
bool __stdcall CheckVersion(const char *a1);
void __stdcall Initialize(const char *a1, const char *a2, int a3, int a4, const char *a5);
int __cdecl Status();
int __cdecl Utc();
int __stdcall Msg(int a1, int a2, int a3);
// signed int __userpurge GetMsg<eax>(int a1<ebx>, int a2, int a3, int a4, int a5, int a6);
char __fastcall sub_100026D0(int a1, int a2);
int __fastcall sub_10002720(int a1, int a2, unsigned int a3);
int __thiscall sub_10002780(void *this, int a2);
int __thiscall sub_100027E0(int this, int a2);
int __fastcall sub_10002850(int a1, unsigned int a2);
char __fastcall sub_10002A80(unsigned int a1, unsigned int a2);
// int __usercall sub_10002AA0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
char __thiscall sub_10002BD0(int this, int a2, int a3, int a4, int a5);
char __thiscall sub_10002D20(int this);
char __thiscall sub_10002F90(int this, int a2);
char __thiscall sub_10003200(int this, int a2);
char __thiscall sub_100034D0(int this);
// int __userpurge sub_10003580<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5, int a6);
bool __thiscall sub_10003670(int this);
void __thiscall sub_100036C0(int this);
bool __thiscall sub_10003700(int this);
// char __userpurge sub_10003740<al>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// char __userpurge sub_10003AA0<al>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
char __thiscall sub_10003D20(void *this, int a2);
char __thiscall sub_10004050(void *this, int a2);
// char __userpurge sub_10004290<al>(int a1<ecx>, int a2<ebx>, int a3);
char __thiscall sub_10004720(void *this, int a2, int *a3, int a4, int a5);
char __thiscall sub_10004890(void *this, int a2, int *a3, int a4, int a5);
char __thiscall sub_100049E0(void *this, int *a2, int a3, int a4);
char __thiscall sub_10004AD0(int this, int a2);
char __thiscall sub_10004B20(void *this, int *a2, int a3, int a4);
int __thiscall sub_10004B80(int this);
int __thiscall sub_10004BD0(int this);
void *__thiscall sub_10004CE0(void *this);
int sub_10004CF0(); // weak
int loc_10004D80(); // weak
int __fastcall sub_10004DA0(int a1, int a2, int a3);
// int __usercall sub_10004F60<eax>(int a1<ecx>, int a2<ebx>);
int __fastcall sub_10004FF0(int a1, int a2, int a3);
char __thiscall sub_10005730(void *_ECX);
int __thiscall sub_100057B0(void *this);
// int __userpurge sub_10005820<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4);
// void __usercall sub_100059C0(int a1<ecx>, int a2<ebx>);
int __fastcall sub_10005A20(int a1, int a2, int a3, int a4);
int __fastcall sub_10005BD0(int a1, int a2, int a3, int a4, int a5);
int __thiscall sub_10005C30(void *this, int a2);
// int __userpurge sub_10005ED0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
void *__thiscall sub_10005F70(void *this, int a2, unsigned int a3);
void *__thiscall sub_10006050(void *this, int a2, int a3);
// int __usercall sub_100060F0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
int __fastcall sub_10006250(int a1, char a2);
int __fastcall sub_100062C0(int a1, int a2);
void __thiscall sub_100067D0(int this, int a2);
void *__thiscall sub_10006860(void *this, char a2);
int __thiscall sub_10006890(void *this, int a2, int a3);
// int __userpurge sub_10006900<eax>(int a1<ecx>, int a2<edi>, int a3);
int __stdcall sub_10006D70(const char *a1);
int __thiscall sub_10006DB0(int this, int a2);
_DWORD __stdcall sub_10006DE0(_DWORD); // weak
int __thiscall sub_10006F90(void *this, int a2, int a3);
int __thiscall sub_10007250(void *this, int a2, int a3);
int __fastcall sub_10007450(int a1, int a2, int a3);
// int __userpurge sub_10007530<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5);
int __thiscall sub_10007600(void *this, int a2);
int __thiscall sub_10007620(int this);
signed int __thiscall sub_100078B0(int this, signed int a2);
signed int __thiscall sub_10007910(int this);
int __thiscall sub_10007970(int this, int a2, __int64 a3, int a4, char a5);
int __thiscall sub_10007B40(int this, int a2, __int64 a3, __int64 a4, int a5, int a6, char a7);
void *__thiscall sub_10007C90(void *this, char a2);
void *__thiscall sub_10007D00(int this, char a2);
// void *__userpurge sub_10007DE0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6);
int __thiscall sub_10007E80(void *this, int a2, int a3, int a4);
void *__thiscall sub_10007F40(void *this, int a2);
int __thiscall sub_10007FE0(void *this, int a2);
int __thiscall sub_10008060(void *this, int a2);
int __thiscall sub_100080C0(void *this, int a2);
char __stdcall sub_10008120(int a1, int a2);
int __fastcall sub_10008180(int a1);
void *__thiscall sub_100081A0(void *this);
void *__thiscall sub_100081F0(void *this);
int __thiscall sub_100082E0(int this);
int __thiscall sub_10008340(int this, int a2);
int __thiscall sub_10008370(int this, int a2);
// int __userpurge sub_100083A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int **a5, int a6, int a7, int **a8, int a9, int a10);
int __thiscall sub_10008830(int this);
int __thiscall sub_10008A10(int this, int a2);
// int __userpurge sub_10008B70<eax>(int a1<ecx>, int a2<edi>, int a3, int a4, int a5, int a6, char a7, unsigned __int8 a8);
int __thiscall sub_10008D60(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7);
int __thiscall sub_10008DE0(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7);
int __thiscall sub_10008E60(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7, int a8);
int __thiscall sub_10008EE0(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7, int a8);
// int __userpurge sub_10008F70<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6, unsigned __int8 a7, __int64 a8);
// int __userpurge sub_100091B0<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6, unsigned __int8 a7, __int64 a8);
int __thiscall sub_10009360(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7);
int __fastcall sub_100093D0(int a1, int a2, int a3, int a4);
void *__thiscall sub_10009460(void *this, char a2);
// int __usercall sub_100096C0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<ebp>, int a5<edi>);
// int __userpurge sub_100098D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7);
int __cdecl sub_10009930(int a1, int a2, char a3, __int16 a4);
int __cdecl sub_100099F0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8, int a9, int a10, unsigned int a11);
int __cdecl sub_10009E70(int a1, int a2, int a3, __int16 a4);
int __cdecl sub_10009F00(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8);
int __cdecl sub_1000A2A0(int a1, int a2, int a3, int a4, unsigned __int8 *a5, int a6);
int __cdecl sub_1000A320(int a1, int a2, int a3, int a4, unsigned __int8 a5, int a6);
int __fastcall sub_1000A3A0(int a1, int a2, int a3, int a4);
// int __usercall sub_1000A430<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
int __fastcall sub_1000A460(int a1, int a2, int a3);
int __fastcall sub_1000A4F0(int a1, int a2, const char *a3);
int __thiscall sub_1000A590(_DWORD); // weak
// int __usercall sub_1000A840<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4);
int __thiscall sub_1000A970(void *this, int a2, int a3);
// int __usercall sub_1000A9F0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int **a4, int a5, int a6, int **a7, int a8, int a9, int **a10, int a11, int a12);
// int __usercall sub_1000AB10<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int **a4, int a5, int a6, int **a7, int a8, int a9, int **a10, int a11, int a12);
signed int __fastcall sub_1000AC30(int a1, int a2, int a3, int a4);
int __stdcall sub_1000AF70(int a1);
// void __usercall sub_1000B01B(int a1<ebp>);
int __thiscall sub_1000B030(int this, int a2, int a3, int a4, int a5);
void __thiscall sub_1000B230(int this);
int __thiscall sub_1000B250(void *this, int a2, int a3, int a4);
// int __usercall sub_1000B310<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12);
// int __usercall sub_1000B400<eax>(int a1<ecx>, int a2<edi>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
// int __userpurge sub_1000B4F0<eax>(int a1<ebx>, int a2);
// int __userpurge sub_1000B5A0<eax>(int a1<ecx>, int a2<ebx>, int a3, char a4, int a5, int a6, int a7);
int __thiscall sub_1000B810(void *this, int a2, int a3, int a4, int a5);
int __fastcall sub_1000B9D0(int a1, int a2, int a3);
int __thiscall sub_1000BA54(void *this);
void *__thiscall sub_1000BA5F(void *this, char a2);
int __thiscall sub_1000BB80(void *this, int a2);
int __thiscall sub_1000BBA0(void *this, int a2);
int __thiscall sub_1000BBC0(void *this, int a2);
int __thiscall sub_1000BBE0(int this, int a2);
int __thiscall sub_1000BC60(int this, char a2);
char __thiscall sub_1000BCB0(int this);
char __thiscall sub_1000BCC0(int this);
int __thiscall sub_1000BCD0(int this, int a2);
int __thiscall sub_1000BD30(int this, int a2);
int __thiscall sub_1000BD90(int this, int a2);
int __thiscall sub_1000BDF0(int this);
// int __userpurge sub_1000BE10<eax>(int a1<ecx>, int a2<edi>, int a3, char a4);
signed int __fastcall sub_1000BF70(int a1, int a2, int a3, int a4);
// int __usercall sub_1000C040<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4);
int __thiscall sub_1000C170(int this, char a2);
signed int __stdcall sub_1000C1C0(int a1);
__int64 __cdecl sub_1000C1D0();
__int64 __thiscall sub_1000C1E0(int this);
signed int __cdecl sub_1000C200();
int __thiscall sub_1000C210(void *this);
int __thiscall sub_1000C240(int this, void *a2, unsigned int a3, int a4);
__int64 __thiscall sub_1000C350(int this);
int __thiscall sub_1000C370(int this, const void *a2, unsigned int a3, int a4);
int __stdcall sub_1000C480(int a1, int a2, int a3, int a4, int a5);
int __stdcall sub_1000C4B0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
void *__thiscall sub_1000C4E0(void *this, int a2, int a3, int a4);
void *__thiscall sub_1000C540(void *this, char a2);
void *__thiscall sub_1000C589(void *this, char a2);
int __thiscall sub_1000C591(void *this);
// int __usercall sub_1000C5A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<ebp>, int a5<edi>);
// int __userpurge sub_1000C630<eax>(int a1<ecx>, int a2<ebx>, char a3);
int *__thiscall sub_1000C690(void *this, int *a2, int a3);
// int __userpurge sub_1000C6C0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned __int8 a4);
int *__thiscall sub_1000C6E0(void *this, int *a2, int a3);
// int __userpurge sub_1000C710<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned __int8 a4);
int __stdcall sub_1000C730(const void *a1, int a2, void *a3);
int __stdcall sub_1000C750(const void *a1, int a2, int a3, void *a4);
char __stdcall sub_1000C770(char a1, int a2);
// int __userpurge sub_1000C780<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
int loc_1000C850(); // weak
// void __usercall sub_1000C870(void *this<ecx>, int a2<ebx>);
signed int __fastcall sub_1000C910(int a1, int a2, int a3, int a4);
// int __usercall sub_1000C9E0<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4);
char __stdcall sub_1000CB10(char a1);
// int __userpurge sub_1000CB20<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6);
void __thiscall sub_1000CBE0(void *this);
int __thiscall sub_1000CC00(int this, int a2);
int loc_1000CC20(); // weak
int __thiscall sub_1000CC40(void *this);
int loc_1000CCBC(); // weak
int (*__cdecl sub_1000CCCE())();
int loc_1000CCE0(); // weak
int __cdecl sub_1000CD10();
int __thiscall sub_1000CD20(void *this, const char *a2, int a3);
// int __userpurge sub_1000CDF0<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1000CE20<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_1000CEE0(int this);
void *__thiscall sub_1000CFD0(void *this, int a2);
char __thiscall sub_1000D060(int this, int a2, signed int a3, unsigned __int8 a4);
int __thiscall sub_1000D170(int this, char a2);
void *__thiscall sub_1000D200(void *this, char a2);
int __thiscall sub_1000D250(void *this);
void *__thiscall sub_1000D260(void *this);
int __stdcall sub_1000D280(int a1, int a2);
int loc_1000D2C0(); // weak
// int __userpurge sub_1000D300<eax>(int a1<ecx>, int a2<ebx>, int a3);
void *__thiscall sub_1000D320(void *this, char a2);
int __fastcall sub_1000D350(int a1, int a2);
void *__thiscall sub_1000D380(int this, char a2);
int __fastcall sub_1000D3D0(int a1);
void *__thiscall sub_1000D430(int this, char a2);
int __thiscall sub_1000D460(int this, int a2);
int loc_1000D4A0(); // weak
char __thiscall sub_1000D4F0(void *this, int a2);
int loc_1000DAD0(); // weak
void __thiscall sub_1000DB30(void *this, __int64 a2, int a3);
void __thiscall sub_1000DD00(void *this, int a2, int a3, int a4);
void __thiscall sub_1000DD70(int this, unsigned int a2);
int __thiscall sub_1000DE40(int this);
int __thiscall sub_1000DEB0(int this, int a2, int a3, int a4, int a5);
int __thiscall sub_1000DF90(int this, int a2, int a3);
int __thiscall sub_1000E030(int this, int a2);
int __thiscall sub_1000E160(int this, int a2);
int __thiscall sub_1000E270(int this);
int __thiscall sub_1000E370(int this, int a2);
// int __userpurge sub_1000E460<eax>(int a1<ecx>, int a2<edi>, int a3, int a4);
char __fastcall sub_1000E500(int a1, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_1000E6A0(int this);
void __thiscall sub_1000E770(int this, int a2);
int loc_1000E810(); // weak
int loc_1000E870(); // weak
LPVOID __thiscall sub_1000E8E0(LPVOID *this);
signed int __thiscall sub_1000E910(void *this, int a2);
int __thiscall sub_1000E9F0(int this, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __thiscall sub_1000EB40(int this, unsigned int a2);
int __thiscall sub_1000ECE0(void *this, int a2, int a3);
// void *__userpurge sub_1000ED90<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6);
int __thiscall sub_1000EE70(int this, int a2, int a3, int a4, int a5);
char __thiscall sub_1000F1D0(int this, int a2, int a3);
void *__thiscall sub_1000F380(void *this, int a2);
// char __userpurge sub_1000F3C0<al>(int a1<ecx>, int a2<ebx>, int a3<edi>, __int16 a4);
// bool __userpurge sub_1000F490<eax>(int a1<ecx>, char a2<bl>, unsigned __int8 a3, int a4);
void __thiscall sub_1000F580(int this, int a2, int a3);
int __thiscall sub_1000F640(void *this, int a2, unsigned int a3);
void *__thiscall sub_1000F6A0(void *this, int a2);
int __thiscall sub_1000F790(int this, unsigned int a2);
int __thiscall sub_1000F830(int this);
void *__thiscall sub_1000F8D0(int this, char a2);
// int __usercall sub_1000F900<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
int __thiscall sub_1000F980(int this, int a2);
int __thiscall sub_1000F9E0(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_1000FB10(void *this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_1000FC10(int this, int a2);
int __thiscall sub_1000FD20(int this, unsigned int a2);
int __thiscall sub_1000FE50(void *this, int a2, int a3, int a4);
// bool __userpurge sub_1000FE80<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6);
int __thiscall sub_1000FEC0(void *this, int a2, const CHAR *a3, UINT a4);
int __stdcall sub_1000FFD0(int a1, int a2);
int __thiscall sub_10010010(int this, int a2, int a3);
// void *__userpurge sub_10010070<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __thiscall sub_100100B0(int this, int a2);
int __thiscall sub_100100D0(int this, int a2, int a3, int a4);
int __thiscall sub_10010290(int this, int a2, int a3, int a4);
int __thiscall sub_100103B0(int this, unsigned int a2, int a3);
int __thiscall sub_10010430(void *this, int a2, void *a3, const void *a4);
int __thiscall sub_100106D0(int this, int a2);
// int __userpurge sub_10010710<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6);
int __thiscall sub_100107F0(_DWORD); // weak
int __fastcall sub_10010DE0(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, char a8);
int __fastcall sub_10010E70(int a1, int a2, int a3, int a4);
char __fastcall sub_10010F00(unsigned __int8 a1, int a2, void *a3);
int __fastcall sub_100111B0(int a1, int a2, int a3);
void *__thiscall sub_100111E0(void *this, int a2, int a3);
void __fastcall sub_10011220(int _ECX, int a2);
int __fastcall sub_10011240(int a1, int a2, int a3);
// int __usercall sub_10011270<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4);
signed int __fastcall sub_100113A0(int a1, int a2, int a3, void *a4);
int __thiscall sub_10011490(int this, int a2);
char __thiscall sub_10011500(void *this);
int __thiscall sub_100116B0(int this);
// int __userpurge sub_100117D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6);
int __fastcall sub_10011850(int a1, int a2, int a3);
// int __userpurge sub_100118F0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// int __usercall sub_10011960<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
char __thiscall sub_100119D0(void *this, int a2);
char __thiscall sub_10011BE0(void *this, int a2, char a3, signed int a4);
char __thiscall sub_10011E50(int this, int a2);
char __thiscall sub_10012050(int this);
// int __usercall sub_10012180<eax>(char a1<dl>, int a2<ecx>, __int16 a3<bx>, int a4, int a5, int a6, int a7, __int16 a8, char a9);
int __fastcall sub_10012210(int a1, int a2, int a3, int a4, int a5, int a6, char a7);
int __fastcall sub_10012410(int a1, int a2, int a3, int *a4, int a5, char a6, char a7);
int __fastcall sub_100124C0(int a1, int a2, int a3, int a4, int a5, int a6, char a7);
int __thiscall sub_10012560(void *this, int a2, int a3, int a4);
int __fastcall sub_10012700(int a1, int a2, int a3);
void __fastcall sub_10012730(int a1, int a2);
// signed int __usercall sub_10012750<eax>(signed int result<eax>, int a2<ecx>, int a3, unsigned int a4, int a5, int a6);
void __fastcall sub_100127A0(int a1, int a2);
int __thiscall sub_100127C0(int this, int a2);
// char __userpurge sub_10012830<al>(int a1<ecx>, char a2<bl>, int a3, int a4);
char __thiscall sub_10012920(int this);
char __thiscall sub_10012960(void *this);
char __thiscall sub_10012DF0(int this);
// int __usercall sub_10012E30<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __userpurge sub_10012EA0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
int __fastcall sub_10012F60(int a1, int a2, int a3, int a4);
char __thiscall sub_10013000(void *this, int a2, char a3);
// int __usercall sub_100132A0<eax>(char a1<dl>, int a2<ecx>, __int16 a3<bx>, int a4, int a5, int a6, int a7, int a8);
int __fastcall sub_100134A0(int a1, char a2, int a3, int *a4, int a5, int a6, char a7);
int __fastcall sub_10013550(int a1, char a2, int a3, int a4, int a5, int a6);
void *__thiscall sub_100135F0(void *this, int a2, int a3, unsigned int a4, int a5, int a6, int a7, unsigned int a8);
void *__thiscall sub_10013670(void *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
// int __usercall sub_10013760<eax>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>);
// int __usercall sub_10013AD0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_10013B30<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_10013B90<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __userpurge sub_10013BF0<eax>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>, int a5);
int __thiscall sub_10013D00(int this, int a2, int a3);
void *__thiscall sub_10013D70(void *this, int a2, int a3);
char __thiscall sub_10013DA0(int this);
// char __userpurge sub_10013DC0<al>(int a1<ecx>, char a2<bl>, char a3);
// signed int __usercall sub_10014140<eax>(int a1<edx>, int a2<ecx>, int a3<edi>);
// int __userpurge sub_100141D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, char a4);
// int __usercall sub_10014200<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __userpurge sub_10014290<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// int __userpurge sub_10014300<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5, char a6);
// int __usercall sub_10014440<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
void *__thiscall sub_100144C0(void *this, int a2, int a3);
// void *__userpurge sub_100144F0<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __thiscall sub_10014520(int this, int a2, int a3);
int __thiscall sub_10014600(int this);
char __thiscall sub_10014890(int this, char a2);
int __thiscall sub_10014910(void *this, int a2, int a3, char a4);
// int __userpurge sub_100149D0<eax>(int a1<edx>, int a2<ecx>, __int16 a3<bx>, int a4, int a5);
// int __userpurge sub_10014C30<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, char a4);
// char __userpurge sub_10014D40<al>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>, int a5);
// int __userpurge sub_10014E30<eax>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>, int a5);
int __thiscall sub_10014F40(int this, int a2, int a3, int a4, int a5);
char __stdcall sub_10015280(int a1, int a2, int a3);
char __thiscall sub_10015300(int this, int a2, int a3, int a4);
int __fastcall sub_100154A0(int a1, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10015510(void *this, int a2, int a3, int a4);
void *__thiscall sub_100156A0(void *this, int a2, int a3);
int __fastcall sub_100156D0(int a1, int a2, int a3);
int __thiscall sub_10015800(void *this, int a2, int a3);
int __thiscall sub_100159A0(void *this, int a2);
// int __userpurge sub_10015B00<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int *a4);
// int *__usercall sub_10015CB0<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_10015F20<eax>(int a1<ebx>);
void __stdcall sub_100161B0(int a1, int a2, void *a3, int a4, int a5, int a6, unsigned int a7, signed int a8, void *a9, int a10, int a11, int a12, int a13, signed int a14, void *a15, int a16, int a17, int a18, unsigned int a19, unsigned int a20);
// int __userpurge sub_100163C0<eax>(int a1<ebx>, char a2);
// void __userpurge sub_10016470(int a1<ecx>, int a2<ebx>, int a3);
// BOOL __userpurge sub_100165D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
void __thiscall sub_100166D0(int this, int a2);
int __thiscall sub_10016760(void *this, int a2);
int __thiscall sub_10016C00(void *this, char a2, int a3);
int __stdcall loc_10016ED7(char, int); // weak
// int (*__usercall sub_10016F35<eax>(int a1<ebp>))();
int loc_10016FAC(); // weak
// int (__stdcall *__usercall sub_10016FC3<eax>(int a1<ebp>))(char, int);
int __thiscall sub_10017040(int this, char a2, int a3);
// int __usercall sub_100170C0<eax>(int a1<ecx>, int a2<ebx>);
signed int __thiscall sub_10017170(void *this, int a2, int a3);
signed int __thiscall sub_100171B0(void *this, int a2, int a3);
char __cdecl sub_100171F0();
int __thiscall sub_10017230(int this);
int __stdcall sub_100172E0(int a1);
char __thiscall sub_10017300(int this, int a2);
char __thiscall sub_10017320(void *this, int a2);
int __thiscall sub_10017350(int this);
int __thiscall sub_10017370(void *this, int a2);
int __thiscall sub_100173A0(int this, int a2);
int __thiscall sub_100173D0(int this, unsigned int a2);
unsigned int __thiscall sub_100173F0(int this, int a2);
int loc_10017420(); // weak
// int __usercall sub_10017430<eax>(int a1<ecx>, int a2<ebx>);
signed int __stdcall sub_100176B0(int a1, int a2);
int __thiscall sub_100176C0(void *this, int a2);
// char __userpurge sub_10017770<al>(int a1<ecx>, int a2<ebx>, int a3);
void __thiscall sub_100177A0(void *this);
int loc_100178B0(); // weak
char __cdecl sub_100178C0();
// void __usercall sub_100178D0(void *a1<ecx>, int a2<ebx>);
void __thiscall sub_10017A00(int this, int a2, int a3);
void __thiscall sub_10017BE0(void *this);
int __fastcall sub_10017CA0(int a1);
int __stdcall sub_10017CE0(int a1, int a2, int a3);
int __stdcall sub_10017D00(int a1, int a2, int a3);
int __stdcall sub_10017D60(void *a1);
int loc_10017D80(); // weak
// void __usercall sub_10017D90(int a1<ecx>, int a2<ebx>, int a3<edi>);
int __thiscall sub_10017E50(int this, int a2);
char __thiscall sub_10017E80(int this, int a2);
int __thiscall sub_10017EB0(void *this);
int __thiscall sub_10017F10(int this, int a2);
// unsigned int __userpurge sub_10017F40<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_10018000(int this);
char __thiscall sub_10018090(int this, int a2);
char __thiscall sub_100180C0(int this, int a2);
bool __thiscall sub_100180E0(int this);
int __thiscall sub_100180F0(int this, int a2);
int __thiscall sub_10018110(int this, int a2);
// void __usercall sub_10018130(int a1<ecx>, int a2<ebx>, int a3<edi>);
void __thiscall sub_100181E0(void *this, int a2);
void __thiscall sub_100182A0(void *this, int a2);
void __thiscall sub_10018360(void *this);
char __thiscall sub_10018490(void *this, int a2, int a3);
void __thiscall sub_10018570(void *this, int a2, int a3);
int __thiscall sub_10018720(void *this, int a2);
int __thiscall sub_10018740(void *this, int a2);
int __thiscall sub_100187D0(void *this, int a2);
int __thiscall sub_100187E0(void *this, int a2);
int __thiscall sub_10018860(int this);
int __thiscall sub_10018870(int this);
// void *__userpurge sub_100188F0<eax>(int a1<ecx>, int a2<ebx>, char a3);
void *__thiscall sub_10018920(int this, char a2);
void *__thiscall sub_10018950(void *this, char a2);
// void *__userpurge sub_10018980<eax>(int a1<ecx>, int a2<ebx>, char a3);
void *__thiscall sub_100189B0(void *this, char a2);
// void *__userpurge sub_100189E0<eax>(void *a1<ecx>, int a2<ebx>, char a3);
// void *__userpurge sub_10018A10<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
// void *__userpurge sub_10018A90<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
// char __userpurge sub_10018AC0<al>(int a1<ecx>, int a2<ebx>, char a3, int a4, int a5, int a6);
char __thiscall sub_10018CC0(void *this, char a2, int a3);
char __thiscall sub_10018E20(int this, int a2);
int loc_10018E80(); // weak
// int __usercall sub_10018EB0<eax>(int a1<ecx>, int a2<ebx>);
int __thiscall sub_10018F80(int this, int a2, int a3);
int __thiscall sub_10019020(int this);
int __thiscall sub_100190E0(void *this);
char __thiscall sub_10019160(int this, int a2);
int __thiscall sub_10019240(int this, int a2);
char __thiscall sub_100192C0(void *this);
void __thiscall sub_10019320(void *this, int a2);
int __cdecl sub_10019510(int a1);
// int __usercall sub_10019520<eax>(int a1<ecx>, int a2<ebx>);
int __thiscall sub_100195C0(int this, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_10019660<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
int __thiscall sub_10019710(int this);
// int __usercall sub_10019790<eax>(int a1<ecx>, int a2<ebx>);
char __thiscall sub_10019830(void *this, char a2, char a3, int a4, int a5);
int __fastcall sub_10019980(int a1, int a2, int a3);
// int __userpurge sub_100199B0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
int __thiscall sub_100199E0(int this, char a2);
// void *__userpurge sub_10019A70<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __thiscall sub_10019AA0(void *this);
void __thiscall sub_10019AE0(int this);
int __fastcall sub_10019BD0(int a1, int a2);
int __thiscall sub_10019C70(int this, int a2, int a3, int a4);
int __thiscall sub_10019DF0(int this, int a2, int a3);
char __thiscall sub_10019E80(int this, int a2);
// int __userpurge sub_10019FA0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, char a4, int a5, int a6, int a7);
// int __userpurge sub_1001A050<eax>(int a1<ecx>, int a2<edi>, int a3);
void __thiscall sub_1001A0B0(int this, int a2);
// void *__userpurge sub_1001A200<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __thiscall sub_1001A230(int this, int a2);
// void __usercall sub_1001A2F0(int a1<ecx>, int a2<ebx>);
int __fastcall sub_1001A370(int a1, int a2, int a3, int a4);
_DWORD __cdecl sub_1001A3B0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char); // weak
// int __userpurge sub_1001A490<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5);
// int __userpurge sub_1001A4D0<eax>(int a1<ecx>, int a2<ebx>, int a3);
char __thiscall sub_1001A500(void *this);
char __thiscall sub_1001A630(void *this, char a2, char a3, int a4, int a5);
int __thiscall sub_1001A780(int this, char a2);
// void *__usercall sub_1001A830<eax>(void *a1<ecx>, int a2<ebx>, char a3);
int __fastcall sub_1001A890(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
// int __usercall sub_1001A980<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, unsigned int a4, void *a5, int a6, int a7, int a8, int a9, signed int a10, char a11);
// int __userpurge sub_1001AAF0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9);
char __thiscall sub_1001ABD0(void *this, char a2, int a3, int a4);
int __fastcall sub_1001ACD0(int a1, int a2);
int __thiscall sub_1001AD20(void *this, int a2, int a3, int a4);
int __thiscall sub_1001ADE0(int this, int a2, int a3, unsigned int a4);
int __thiscall sub_1001AF20(void *this, int a2);
int __thiscall sub_1001AFD0(void *this, int a2, int a3, int a4);
// int __usercall sub_1001B0D0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, char a4);
int __thiscall sub_1001B150(int this, int a2);
int __thiscall sub_1001B210(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_1001B280(int this);
int __thiscall sub_1001B300(int this, int a2);
// int __userpurge sub_1001B320<eax>(int a1<ecx>, int a2<edi>, int a3);
void __thiscall sub_1001B460(int this, LPCWSTR pwszObjectName);
void __thiscall sub_1001B5C0(DWORD_PTR this);
int __thiscall sub_1001B5E0(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_1001B660(int this);
// int __userpurge sub_1001B6F0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
// int __userpurge sub_1001B720<eax>(int a1<ecx>, int a2<ebx>, char a3);
// void *__userpurge sub_1001B780<eax>(int a1<ecx>, int a2<ebx>, char a3);
// int __usercall sub_1001B7F0<eax>(int a1<ecx>, int _EBX<ebx>);
// int __usercall sub_1001B8A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
// int __userpurge sub_1001B8E0<eax>(int a1<ecx>, int _EBX<ebx>, char a3);
// char __usercall sub_1001B980<al>(int a1<edx>, int a2<ecx>, int a3<ebx>);
// int __userpurge sub_1001BAE0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5);
int __thiscall sub_1001BB20(int this, int a2, char a3, int a4);
int __thiscall sub_1001BC40(int this, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
// int __userpurge sub_1001BE60<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5);
int __thiscall sub_1001BEA0(int this, int a2, int a3);
// int __usercall sub_1001BF10<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
// int __userpurge sub_1001BFC0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4);
void __cdecl sub_1001C080(int a2);
void __cdecl sub_1001C090(int a2);
// int __usercall sub_1001C0A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
int __thiscall sub_1001C120(int this, int a2);
void __thiscall sub_1001C1E0(int this);
void __thiscall sub_1001C2E0(int this);
int *__thiscall sub_1001C3E0(int this);
int __thiscall sub_1001C4A0(int this, int a2, int a3);
// char __userpurge sub_1001C5C0<al>(int a1<ecx>, int a2<ebx>, int a3, int a4);
int __thiscall sub_1001C6A0(void *this);
void __thiscall sub_1001C750(void *this, int a2);
void __thiscall sub_1001C810(void *this);
int __thiscall sub_1001C910(int this, int a2, int a3);
int __thiscall sub_1001CB40(void *this, int a2);
int __thiscall sub_1001CB50(void *this, int a2);
bool __thiscall sub_1001CB60(void *this, int a2, int a3);
int __thiscall sub_1001CCF0(int this);
int __thiscall sub_1001CD00(int this);
int __thiscall sub_1001CD10(int this);
// int __userpurge sub_1001CDC0<eax>(int a1<eax>, int a2<ecx>, int _EBX<ebx>, int a4);
// int __usercall sub_1001CFD0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
char __thiscall sub_1001D010(int this);
_DWORD __stdcall sub_1001D130(_DWORD, _DWORD); // weak
// void __userpurge sub_1001D260(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
int __thiscall sub_1001D480(int this, char a2, int a3, int a4, int a5, int a6);
int __thiscall sub_1001D500(int this, char a2, int a3, int a4, int a5, char *a6);
int __thiscall sub_1001D590(int this, char a2, int a3);
int loc_1001D620(); // weak
// int __userpurge sub_1001D630<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9);
char __cdecl sub_1001D710(int a1, int a2);
// int __userpurge sub_1001D750<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9);
// int __usercall sub_1001D830<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
// int __usercall sub_1001D8B0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>);
int __thiscall sub_1001D9A0(int this, int a2);
int (__stdcall ***__cdecl sub_1001D9C0())(char);
int __thiscall sub_1001D9D0(void *this);
int __thiscall sub_1001D9E0(void *this, char a2);
int __thiscall sub_1001DA10(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_1001DAC0(int this, int a2);
int (__stdcall ***__cdecl sub_1001DAE0())(char);
int __thiscall sub_1001DB30(int this, int a2);
int (__stdcall ***__cdecl sub_1001DB50())(char);
int __thiscall sub_1001DBA0(int this);
int (__stdcall ***__cdecl sub_1001DBB0())(char);
void __thiscall sub_1001DC00(int this, int a2);
int (__stdcall ***__cdecl sub_1001DC80())(char);
int __thiscall sub_1001DC90(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_1001DD00(int this);
// void __userpurge sub_1001DD10(int *a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_1001DDD0(int this, int a2);
int __thiscall sub_1001DF40(int this, int *a2);
void __cdecl sub_1001DFE0(int a1);
// int __usercall sub_1001DFF0<eax>(int a1<eax>, int a2);
int __cdecl loc_1001E000(int); // weak
int (__stdcall ***__cdecl sub_1001E220())(char);
int __thiscall sub_1001E230(int this, int a2, int a3);
int __thiscall sub_1001E2E0(int this);
int loc_1001E3C0(); // weak
// int __userpurge sub_1001E410<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
// int __userpurge sub_1001E440<eax>(int a1<ecx>, int a2<ebx>, char a3);
// int __userpurge sub_1001E4A0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
// int __userpurge sub_1001E610<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
int __fastcall sub_1001E780(int a1, int a2, int a3);
// void __usercall sub_1001E7D0(int a1<ecx>, int a2<ebx>, int a3);
// int __usercall sub_1001E7E0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
// int __userpurge sub_1001E8A0<eax>(int a1<edx>, int *a2<ecx>, int a3<ebx>, int a4, int a5);
// void __usercall sub_1001E960(int a1<ecx>, int a2<ebx>);
// int __userpurge sub_1001EA50<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1001EAF0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8);
// BOOL __userpurge sub_1001EB60<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
int (__stdcall ***__cdecl sub_1001EB70())(char);
// int __userpurge sub_1001EB80<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
int (__stdcall ***__cdecl sub_1001EC10())(char);
int __thiscall sub_1001EC20(void *this);
// int __userpurge sub_1001EC30<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
// int __userpurge sub_1001ECD0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9);
// int __userpurge sub_1001EDB0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4);
int (__stdcall ***__cdecl sub_1001EE80())(char);
int __thiscall sub_1001EE90(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_1001EF00(int this);
void *__thiscall sub_1001EFA0(int this, char a2);
// int __userpurge sub_1001F010<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
// int __usercall sub_1001F040<eax>(int a1<eax>, int a2);
// void __userpurge sub_1001F150(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
int __thiscall sub_1001F350(int this, char a2, int a3, int a4, int a5, int a6);
char __thiscall sub_1001F3D0(int this, char a2, int a3);
// int __usercall sub_1001F460<eax>(int a1<edx>, int a2<ecx>, int a3<edi>);
int __thiscall sub_1001F510(int this, char a2, int a3);
// int __userpurge sub_1001F5E0<eax>(int a1<ecx>, int a2<ebx>, int a3);
int (__stdcall ***__cdecl sub_1001F630())(char);
void *__thiscall sub_1001F640(int this, char a2);
// int __userpurge sub_1001F6A0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
// int __userpurge sub_1001F740<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4);
// char __usercall sub_1001F7E0<al>(int a1<eax>, int a2<ecx>, int a3);
// void *__userpurge sub_1001F928<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
int __thiscall sub_1001F930(int this);
void __thiscall sub_1001F940(void *this, int a2);
void *__thiscall sub_1001FB00(void *this, int a2);
// int __usercall sub_1001FBD0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
// int __usercall sub_1001FC80<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
int __cdecl sub_1001FCC0(int a1);
int __thiscall sub_1001FCE0(int this, int a2);
int __thiscall sub_1001FDA0(void *this, int a2);
// int __userpurge sub_1001FE60<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1001FE80<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall j_nullsub_2(_DWORD); // weak
// int __userpurge sub_1001FEB0<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1001FED0<eax>(int a1<ecx>, int a2<ebx>, int a3);
DWORD __thiscall sub_1001FEF0(int this);
char __thiscall sub_1001FF20(int this);
// int __userpurge sub_1001FFA0<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1001FFC0<eax>(int a1<ecx>, int a2<ebx>, int a3);
void *__thiscall sub_1001FFE0(void *this, int a2);
// int __usercall sub_10020060<eax>(const void *a1<ecx>, int a2<edi>, char a3);
// int __usercall sub_100200C0<eax>(int a1<ecx>, int a2<edi>);
// signed int __usercall sub_10020140<eax>(int a1<ecx>, int a2<ebx>);
int __thiscall sub_10020240(int this, char a2);
void *__thiscall sub_100202F0(void *this, int a2);
// int __usercall sub_100203A0<eax>(int a1<ecx>, int a2<edi>);
void *__thiscall sub_10020470(void *this, char a2);
_DWORD __cdecl sub_100204A0(_DWORD); // weak
int (__stdcall ***__cdecl sub_100204B0())(char);
char __thiscall sub_100204C0(void *this, char a2, char a3, int a4, int a5);
void *__thiscall sub_10020610(int this, char a2);
int __thiscall sub_10020640(int this);
int loc_10020730(); // weak
// int __userpurge sub_10020930<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, unsigned int a4);
// int (__cdecl *__usercall sub_10020960<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<ebx>, int a5<edi>, int a6<esi>, int a7, int a8))(int, int);
int __cdecl loc_10020A1E(int, int); // weak
int __thiscall sub_10020BC0(void *this, int a2, DWORD a3);
int __fastcall sub_10020C60(int a1, DWORD a2);
HINTERNET __cdecl sub_10020D80();
// void *__userpurge sub_10020E80<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
// int __usercall sub_10020EB0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
int __thiscall sub_10020F80(int this, int a2);
int __thiscall sub_10021140(void *this, int a2);
void __thiscall sub_10021150(int this, LPCWSTR pwszObjectName);
void __thiscall sub_100212B0(DWORD_PTR this);
int __stdcall sub_100213F0(char a1, int a2);
void __thiscall sub_10021540(DWORD_PTR dwContext, LPVOID lpOptional, DWORD dwOptionalLength, DWORD dwTotalLength, LPCWSTR lpszHeaders);
// void __userpurge fnInternetCallback(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, unsigned int a6, int a7, int a8);
int __thiscall sub_100218F0(int this, int a2);
// void *__usercall sub_100219B0<eax>(void *a1<ecx>, int a2<ebx>, char a3);
// int __userpurge sub_10021A10<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10021A2B<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10021A46<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10021A61<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10021A7C<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_10021AA0(void *this, int a2);
// void __usercall sub_10021AD0(int a1<ecx>, int a2<ebx>);
// void *__userpurge sub_10021AE0<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __cdecl sub_10021B05(int a1);
void __cdecl sub_10021BC5();
void __cdecl sub_10021BF6();
void __cdecl sub_10021C1A(int a1);
void __cdecl sub_10021C48(int a1);
int __cdecl sub_10021C76(int); // weak
int __cdecl sub_10021C9C(int a1);
int __cdecl sub_10021CC6(int a1);
// int __usercall sub_10021CF0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int dwBytes);
int __cdecl sub_10021CF9(int a1, int a2, int a3);
int __cdecl sub_10021D13(int a1, int a2, int a3);
int __thiscall sub_10021D27(int this, int a2);
char __cdecl sub_10021D4C(int a1);
void *__thiscall sub_10021D89(int this);
int sub_10021DCB(void); // weak
void *__thiscall sub_10021DD0(void *this, char a2);
int __thiscall sub_10021E0D(int this);
// void __usercall sub_10021E46(int a1<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>);
int __fastcall sub_10021E71(int a1, int a2, int a3);
// void *__userpurge sub_10021EC5<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
// int __usercall sub_10021EE4<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
int __cdecl sub_10021F0C();
// int __usercall sub_10021F12<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __usercall sub_10021F8E<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
int __cdecl sub_10021FE7(int a1, const CHAR *a2);
void __cdecl sub_10022032(int a1);
// void *__usercall sub_1002204C<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, char a5);
int __cdecl sub_1002206B(int a1);
int __cdecl sub_10022093(int a1);
// void __usercall sub_100220B2(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
void *__thiscall sub_100220DC(void *this);
// int __userpurge sub_1002210B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5);
void __thiscall sub_10022167(void *this);
// int __usercall sub_1002218B<eax>(int a1<ebx>, int a2<edi>, int a3);
// int __usercall sub_100221F7<eax>(int a1<ebx>, int a2<edi>, int a3, int MultiByteStr);
// int __usercall sub_100222F4<eax>(int a1<ebx>, int a2<edi>, int a3, int MultiByteStr);
int __cdecl sub_100223F1(int a1);
// int __usercall sub_1002245A<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1002247B<eax>(int a1<ebx>, int a2, int a3, int a4, int a5, int a6);
signed int __cdecl sub_10022510(LPWSTR lpDestStr, int a2, LPCSTR lpMultiByteStr, UINT CodePage, int a5);
DWORD __cdecl sub_100225B6();
int __fastcall sub_100225DD(int a1, int a2, unsigned int a3);
int __thiscall sub_1002264A(int this);
// void __usercall sub_10022654(int a1<ecx>, int a2<ebx>);
int __thiscall sub_10022664(int this);
int sub_100226BD(); // weak
int __thiscall sub_100226C2(int this, char a2);
// void *__userpurge sub_10022710<eax>(int a1<ecx>, int a2<ebx>, char a3);
char __thiscall sub_1002272F(int this);
int __thiscall sub_10022752(void *this);
char __thiscall sub_10022792(int this, int a2);
int __thiscall sub_100227DB(int this, int a2);
// int __userpurge sub_10022813<eax>(int a1<ebp>, int a2, int a3, int a4);
_DWORD __stdcall sub_100228C8(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __thiscall sub_10022A06(int this);
PVOID __cdecl sub_10022A47(PVOID Ptr);
void __cdecl sub_10022A75(LPCRITICAL_SECTION lpCriticalSection);
int __cdecl sub_10022A83(LPCRITICAL_SECTION lpCriticalSection); // idb
void __cdecl sub_10022A9A(LPCRITICAL_SECTION lpCriticalSection);
void __cdecl sub_10022AA8(LPCRITICAL_SECTION lpCriticalSection);
// int __usercall sub_10022AB6<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, unsigned int a4, int a5);
// void __usercall sub_10022B1B(int a1<ebx>, int a2);
// int __usercall sub_10022B30<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, int ecx0<ecx>, char a4);
// int __userpurge sub_10022B3F<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4);
// void __usercall sub_10022B8A(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __userpurge sub_10022BA9<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4, int a5);
// void __usercall sub_10022BF6(int a1<ebp>);
// int __userpurge sub_10022C07<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
// int __userpurge sub_10022C3E<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5);
int __thiscall sub_10022C7A(int this, int a2, char a3);
int loc_10022DCD(); // weak
// void __usercall sub_10022DD9(int a1<ecx>, int a2<ebx>, int a3<edi>);
void *__thiscall sub_10022E63(void *this, int a2);
void *__thiscall sub_10022E9C(void *this, char a2);
int __thiscall sub_10022EBC(int this, char a2);
// void *__userpurge sub_10022EE2<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __thiscall sub_10022F07(int this, int a2);
int __cdecl sub_10022F2F(int a1);
// int __userpurge sub_10022F59<eax>(int a1<ebp>, int a2, int a3, int a4, int a5);
// int __usercall sub_10022FE3<eax>(int a1<ebp>);
// int (*__usercall sub_100230EE<eax>(int a1<ebx>, int a2<ebp>))();
int loc_10023110(); // weak
// void __usercall sub_10023115(int a1<ebx>, int a2<edi>);
// int __usercall sub_1002311B<eax>(int a1<ebp>);
// void __usercall sub_10023220(int a1<ebx>, int a2<edi>, LPVOID lpMem);
int __thiscall sub_10023231(void *this);
// void __usercall sub_1002323D(LPVOID lpMem<ecx>, int a2<ebx>);
// int __usercall sub_10023250<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
int __thiscall sub_10023268(int this);
int __thiscall sub_10023270(void *this, void *a2);
int __cdecl sub_10023294(_DWORD); // weak
int __thiscall sub_100232EF(int this, int a2, int a3);
int __thiscall sub_10023311(int this, int a2, int a3);
// void __usercall sub_10023334(const void *a1<ecx>, int a2<edi>);
int __cdecl sub_10023441(int, int); // weak
void *__cdecl sub_10023461(void *a1);
int __cdecl sub_10023491(int a1);
// int __usercall sub_100234A4<eax>(int a1<ebp>);
int __cdecl sub_100234E2(int a1);
// void __usercall sub_100234F1(const void *a1<ecx>, int a2<edi>, const void **a3);
// unsigned int __userpurge sub_100234FF<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, unsigned int a4);
// int __userpurge sub_10023571<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
int __thiscall sub_100235FE(int this, char a2);
// int __userpurge sub_10023619<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_10023634(int this, char a2);
// int __userpurge sub_10023650<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_1002366B(int this, char a2);
int __thiscall sub_10023687(int this, int *a2);
int __thiscall sub_100236AC(int this, int a2, int a3);
// int __userpurge sub_100236C7<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_100236EA(int this);
// void __usercall sub_100236FB(int a1<ecx>, int a2<ebx>);
// int __userpurge sub_10023706<eax>(int a1<ecx>, int a2<ebx>, int a3);
// void *__userpurge sub_10023739<eax>(int a1<ecx>, int a2<ebx>, char a3);
void __thiscall sub_1002375E(void *this, int a2);
// void __usercall sub_1002379C(int a1<ecx>, int a2<ebx>);
int __thiscall sub_100237B8(int this);
void *__cdecl sub_100237D0(void *a1, const void *a2, unsigned int a3);
int __cdecl loc_10023A18(int, int, int); // weak
int __cdecl off_10023B08(int, int, int); // weak
int __cdecl loc_10023B18(int, int, int); // weak
int __cdecl loc_10023BA4(int, int, int); // weak
signed int __stdcall sub_10023E14(int a1, int a2, int a3, void (__thiscall *a4)(_DWORD));
int __stdcall sub_10023E83(int a1, int a2, int a3, int (*a4)(void));
// signed int __usercall sub_10023EE1<eax>(int a1<ecx>, int a2<ebx>);
// void __usercall sub_10023F10(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, PVOID Ptr);
PVOID __cdecl sub_10023F50(PVOID Ptr);
// int __usercall sub_10024006<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, void *a5);
_DWORD __cdecl sub_1002401B(LPVOID lpMem); // weak
// void __usercall sub_10024020(int a1<ebx>);
_DWORD __cdecl sub_1002404A(LPVOID lpMem); // weak
// void __usercall sub_1002404F(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
bool __thiscall sub_1002405D(void *this, int a2);
// void *__userpurge sub_1002407B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, char a5);
PVOID __thiscall sub_1002409A(PVOID Parameter, DWORD DueTime);
int __thiscall sub_10024163(int this);
int __thiscall sub_1002416F(int this);
LPCRITICAL_SECTION __thiscall sub_1002417F(LPCRITICAL_SECTION lpCriticalSection);
int __thiscall sub_10024193(int this);
// int __userpurge sub_100241AA<eax>(int a1<ebp>, int a2);
// int __userpurge sub_100241EF<eax>(int a1<ebp>, int a2);
int __thiscall sub_10024232(int this);
// int __userpurge sub_10024252<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1002426D<eax>(int a1<ebp>, int a2);
void __thiscall sub_100242B2(LPCRITICAL_SECTION lpCriticalSection);
void __thiscall sub_100242BA(void *this);
void __cdecl sub_100242C1();
// void *__userpurge sub_100242C8<eax>(int a1<ecx>, int a2<ebx>, char a3);
// int __userpurge sub_100242E7<eax>(void *this<ecx>, int ebx0<ebx>, unsigned int a2);
// LPVOID __usercall sub_1002436D<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
int __thiscall sub_1002438F(int this);
int __stdcall sub_100243AD(int a1, int a2, int a3);
int __stdcall Callback(int a1, int a2);
// int __usercall sub_10024425<eax>(int this<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>);
char __thiscall sub_1002444A(void *this);
int __thiscall sub_1002446D(int this, int a2);
int __thiscall sub_100244C0(int this);
void __thiscall sub_100244EB(LPCRITICAL_SECTION lpCriticalSection);
DWORD __thiscall sub_100244F3(void *this, int a2);
int __thiscall sub_10024528(void *this);
int __thiscall sub_10024558(void *this);
bool __thiscall sub_1002458C(int this, int a2, char a3);
int __thiscall sub_1002462B(void *this);
void __thiscall sub_10024641(int this);
int __cdecl sub_10024659();
void __thiscall sub_10024670(LPCRITICAL_SECTION lpCriticalSection);
int __cdecl sub_1002468A();
int __thiscall sub_10024692(void *this);
int __thiscall sub_100246A3(int this, int a2);
char __thiscall sub_100246C7(void *this);
int __thiscall sub_10024734(int this, int a2);
char __thiscall sub_10024783(void *_ECX);
DWORD __cdecl sub_100247A0();
int __cdecl sub_100247A6(int a1, int a2, int a3);
int __thiscall sub_100247DF(void *this);
int loc_1002480D(); // weak
int __thiscall sub_1002487E(int this);
int __thiscall sub_10024890(int this);
int __thiscall sub_100248A2(int this);
int __thiscall sub_100248B4(int this);
int __thiscall sub_100248C6(int this, char a2);
int __thiscall sub_100248E2(int this);
int __thiscall sub_100248F4(int this);
int __thiscall sub_10024906(int this, char a2);
int __thiscall sub_10024922(int this);
int __thiscall sub_10024934(int this, char a2);
int __thiscall sub_10024950(int this);
int __thiscall sub_10024962(int this);
int __thiscall sub_10024974(int this, char a2);
int __thiscall sub_10024990(int this);
int __thiscall sub_100249A2(int this, char a2);
int __thiscall sub_100249BE(int this);
int __thiscall sub_100249D0(int this);
int __thiscall sub_100249E2(int this);
int __thiscall sub_100249F4(int this, int a2);
int __thiscall sub_10024A12(int this, int a2);
int __thiscall sub_10024A2D(int this);
int __thiscall sub_10024A3F(int this);
int __thiscall sub_10024A51(int this, int a2, char a3, char a4);
_DWORD __stdcall sub_10024A9A(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __thiscall sub_10024B43(int this);
int __thiscall sub_10024B5E(int this, int a2, char a3, char a4);
int __thiscall sub_10024B8E(int this, int a2, char a3, char a4);
int __thiscall sub_10024BBF(int this);
int __thiscall sub_10024BDF(int this);
unsigned int __thiscall sub_10024C08(void *this);
// int __usercall sub_10024C22<eax>(int a1<ebp>);
// void *__userpurge sub_10024C97<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __thiscall nullsub_2(_DWORD); // weak
int __stdcall sub_10024CC6(int a1, int a2, int a3);
int __stdcall sub_10024D13(int a1, int a2);
int __cdecl sub_10024D61();
int __thiscall sub_10024DFF(int this);
char __thiscall sub_10024E1E(int this);
char __thiscall sub_10024E57(int this, int a2, int a3);
char __thiscall sub_10024EA6(void *this, int a2, int a3);
char __thiscall sub_10024EE3(void *this, int a2, int a3);
int __thiscall sub_10024F1C(void *this);
int __thiscall sub_10024F56(int this, int a2, int a3);
int __cdecl sub_10024FFA(int a1, char a2);
char __thiscall sub_10025034(void *this);
char __thiscall sub_10025054(int this);
char __thiscall sub_10025081(int this);
_DWORD __stdcall sub_100250A5(_DWORD); // weak
int __stdcall loc_100250E8(int); // weak
// int __usercall sub_10025148<eax>(int a1<ebp>);
// int __userpurge sub_10025249<eax>(int a1<ebp>, int ebx0<ebx>, int a3<edi>, int a2);
// int __usercall sub_1002531E<eax>(int a1<ebp>);
// void __usercall sub_1002563B(int a1<ebx>, int a2);
// int __userpurge sub_10025659<eax>(int a1<ebp>, int a2);
// int __userpurge sub_100256A6<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_100256C1<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4);
// int __userpurge sub_100257BF<eax>(int a1<ebp>, int a2);
// int __userpurge sub_10025881<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1002589C<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_100258C7(int this);
int loc_100258D7(); // weak
// int __usercall sub_100258E1<eax>(int a1<ebp>);
// void *__userpurge sub_1002599B<eax>(int a1<ecx>, int a2<ebx>, char a3);
// int __userpurge sub_100259C4<eax>(int a1<ebp>, int a2);
int __thiscall sub_100259FE(void *this, char a2, char a3);
int __thiscall sub_10025A21(unsigned int *this, int a2, int a3);
char __thiscall sub_10025A57(unsigned int *this, int a2, int a3);
int __thiscall sub_10025A96(int this, char a2);
int __thiscall sub_10025AF2(unsigned int *this, int a2, int a3);
char __thiscall sub_10025B56(int this, int a2);
int __thiscall sub_10025BC8(int this, int a2, int a3);
int __thiscall sub_10025C10(int this, char a2);
int __thiscall sub_10025D3D(void *this, int a2);
// int __usercall sub_10025D85<eax>(int a1<ebp>, int a2<ebx>, int a3<edi>);
// char __usercall sub_10025E11<al>(int a1<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>);
// char __userpurge sub_10025E65<al>(void *this<ecx>, int ebx0<ebx>, int edi0<edi>, int a2, int a3);
// char __usercall sub_10025F04<al>(int a1<ecx>, int a2<ebx>, int a3<edi>);
int __stdcall sub_10025F12(int a1, int a2);
int __thiscall sub_10025F31(int this, int a2);
// int __userpurge sub_10025FD2<eax>(int a1<ebp>, int a2, int a3);
// char __usercall sub_1002605A<al>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
bool __cdecl sub_10026066(int a1, int a2);
int __cdecl sub_1002607B(void *a2);
int __thiscall sub_10026087(int this);
int __thiscall sub_100260B5(void *this);
// int __userpurge sub_100260C0<eax>(int a1<ebp>, int a2);
int __thiscall sub_1002618A(void *this);
char __thiscall sub_1002618E(int this);
// int __usercall sub_100261DF<eax>(int a1<ebp>);
bool __thiscall sub_1002620F(int this);
bool __thiscall sub_10026222(int this);
bool __thiscall sub_10026235(int this);
int __thiscall sub_10026243(int this);
// int __usercall sub_1002624C<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
int __thiscall sub_1002627F(void *this, int a2);
// int __usercall sub_100262C8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>);
int __thiscall sub_100262EE(int this);
int __thiscall sub_100262F2(int this);
// int __usercall sub_1002630D<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10026328<eax>(int a1<ecx>, int a2<ebp>);
// int __usercall sub_1002635C<eax>(int a1<ebx>, int a2<edi>);
int __thiscall sub_10026399(void *this, int a2);
// int __userpurge sub_10026494<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5);
// int __userpurge sub_10026854<eax>(int a1<ebp>, int a2);
int __stdcall loc_1002687B(int); // weak
// void __userpurge sub_10026921(int a1<ebp>, int a2);
char __thiscall sub_1002693A(int this, int a2);
char __cdecl sub_10026974(int a1, int a2);
// bool __userpurge sub_1002698D<eax>(int a1<ecx>, int a2<edi>, char a3);
// int __usercall sub_100269E3<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __userpurge sub_100269FC<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4);
int __thiscall sub_10026ABF(int this);
int __thiscall sub_10026AD6(int this);
int __thiscall sub_10026B16(void *this);
int loc_10026B44(); // weak
int loc_10026B4E(); // weak
bool __thiscall sub_10026B55(int this, int a2);
int __thiscall sub_10026B79(int this, signed int a2);
void *__thiscall sub_10026BAD(void *this, char a2);
void *__thiscall sub_10026BCD(void *this, char a2);
int __thiscall sub_10026BEC(void *this, char a2);
int __thiscall sub_10026C15(int this, int a2);
int __thiscall sub_10026D6E(void *this, int a2, char a3);
int __thiscall sub_10026D9E(void *this, int a2);
int __thiscall sub_10026DCD(int this, int a2);
int __thiscall sub_10026DF4(int this, int a2);
bool __thiscall sub_10026E61(int this, int a2);
// int __userpurge sub_10026E93<eax>(int a1<ebp>, int a2);
bool __cdecl sub_10026F80(int a1);
// int __usercall sub_10026F8C<eax>(int a1<ecx>, int a2<ebp>);
void __thiscall sub_10026FAD(void *this);
BOOL __cdecl sub_10026FEC();
// int __usercall sub_10026FFD<eax>(int a1<ebx>, int a2<ebp>);
int __stdcall sub_1002707C(int a1);
void __cdecl sub_100271BB();
// int __usercall sub_100271C3<eax>(int a1<ebp>);
// void __usercall sub_100271CF(int a1<eax>, int a2<ebp>);
// int __usercall sub_100271DA<eax>(int a1<ebp>, int a2<edi>);
int __thiscall sub_100271E9(int this);
int __thiscall sub_100271F1(int this);
int __thiscall sub_100271FC(int this);
int __thiscall sub_10027204(int this);
int __thiscall sub_1002720F(int this, int a2);
bool __thiscall sub_1002725B(int this);
int __thiscall sub_1002726F(int this);
int __thiscall sub_10027273(int this);
int __thiscall sub_10027277(int this);
int __thiscall sub_10027288(int this);
int __thiscall sub_1002729E(int this);
char __thiscall sub_100272A2(int this, int a2, int a3);
char __thiscall sub_1002738C(int this, int a2, char a3);
int __thiscall sub_100273C5(int this, int a2);
int __thiscall sub_100273E8(int this, int a2);
// int __usercall sub_10027419<eax>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_10027473(int this);
int __thiscall sub_10027490(int this, int a2);
int __thiscall sub_100274F1(int this, int a2);
int __thiscall sub_10027537(LPVOID lpTlsValue, int); // idb
int __thiscall sub_10027551(int this, int a2, int a3);
// int __userpurge sub_10027564<eax>(int a1<ecx>, int a2<ebx>, int a3);
char __thiscall sub_100275E1(int this);
int __thiscall sub_10027668(void *this);
// int __usercall sub_10027673<eax>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_100276CA(void *this, int a2);
char __thiscall sub_100276F8(void *ListHead, int a2, signed int a3, char a4);
int __thiscall sub_100277EE(int this, int a2);
int __thiscall sub_10027815(void *this, int a2);
BOOL __thiscall sub_1002782B(LPVOID lpTlsValue);
int __thiscall sub_10027839(int this, int a2);
_DWORD __thiscall sub_10027846(_DWORD ecx0); // weak
char __thiscall sub_1002784B(void *this);
int __cdecl sub_100278C7(int (__cdecl *a1)(_DWORD, _DWORD), int a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __thiscall sub_10027969(void *this, int a2, int a3, int a4);
int __cdecl sub_10027AF1(char a1, char a2, int a3, int a4);
char __thiscall sub_10027B62(void *this, int a2, char a3);
int __stdcall sub_10027BAF(char a1, char a2, int a3, int a4);
int __thiscall sub_10027BDC(int this, int a2);
int __thiscall sub_10027C3F(int this, int a2);
int __thiscall sub_10027C4E(int this, int a2);
// char *__usercall sub_10027C83<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
int __thiscall sub_10027C8C(int this);
int __thiscall sub_10027CA0(int this, int a2, int a3, int a4);
void *__thiscall sub_10027CD1(void *this, char a2);
// int __userpurge sub_10027CF1<eax>(int a1<ebp>, int a2);
int __thiscall sub_10027DA2(int this);
// int __usercall sub_10027DAA<eax>(void *this<ecx>, int a2<ebp>);
// int __userpurge sub_10027DED<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6);
int __thiscall sub_10027E26(int this, int a2);
// int __usercall sub_10027E8B<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
// int __usercall sub_10027E9C<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4, int a5);
// int __usercall sub_10027EB3<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int dwBytes);
// signed int __usercall sub_10027F02<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_10027FA6(struct _EXCEPTION_POINTERS *ExceptionInfo); // idb
// int __usercall sub_10027FE6<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, char a4);
// int __usercall sub_100280DF<eax>(int a1<ebx>, int a2<edi>, int a3<esi>);
// int __usercall sub_100280EB<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, int a4);
// int __usercall sub_100281B9<eax>(int a1<ebx>, int a2, int a3, char a4);
// int __usercall sub_100281D7<eax>(int a1<ebx>, int (__cdecl *a2)(_DWORD, _DWORD, _DWORD, _DWORD), int a3, int a4, int a5, int a6);
// int __usercall sub_10028248<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned int a4, int a5, char a6);
// int __usercall sub_10028264<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int dwBytes);
// void __usercall sub_100282F6(int a1<ebx>, LPVOID lpMem);
signed int __stdcall sub_1002832E(int a1, int a2, int a3, void (__thiscall *a4)(_DWORD), int a5);
int __cdecl sub_100283A0(int a1, unsigned __int8 a2);
char __cdecl sub_100284D0(int a1, int a2);
// void **__usercall sub_10028510<eax>(int a1<ebx>, int a2<edi>);
signed int __cdecl sub_10028540(int a1, int a2);
// int __usercall sub_10028586<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, LPVOID lpMem, int dwBytes);
int __thiscall sub_10028631(int this);
void __thiscall sub_10028646(void *this);
int __thiscall sub_10028669(int this);
// int __usercall sub_10028682<eax>(int a1<ebx>, int a2<edi>, unsigned int a3);
_DWORD __cdecl loc_100286CD(_DWORD); // weak
char __thiscall sub_1002871D(int this, int a2);
// void __usercall sub_10028747(int a1<ebx>, int a2<edi>, int a3);
char __thiscall sub_10028761(void *this, int a2);
int __cdecl sub_10028798(int a1);
// int __usercall sub_100287ED<eax>(int a1<ebx>, int a2);
void *__thiscall sub_10028826(void *this);
int loc_100288DC(); // weak
signed int __stdcall sub_100288E5(int a1, int a2, int a3, int a4);
int __thiscall sub_100289AA(int this, int a2, int a3);
char __thiscall sub_100289DD(int this, int a2, int a3);
int __thiscall sub_10028A10(int this, int a2);
int __thiscall sub_10028A40(void *this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10028A7A(int this, int a2, int a3, int a4);
int __thiscall sub_10028AA9(int this, int a2, int a3);
int __thiscall sub_10028AD5(void *this);
// int *__usercall sub_10028B06<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __usercall sub_10028B1A<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __usercall sub_10028B89<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4, int a5, int a6, int a7);
int __cdecl sub_10028C64();
// int __usercall sub_10028CA4<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
int sub_10028CB0(void); // weak
// int __usercall sub_10028CB5<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
int __thiscall sub_10028CC1(int this, int a2, char a3);
void __thiscall sub_10028CE0(int this);
void *__thiscall sub_10028CF1(int this, char a2);
int __stdcall sub_10028D10(int a1, int a2);
BOOL __thiscall sub_10028D1F(char *Parameter);
DWORD __thiscall sub_10028D82(int this);
// int __userpurge sub_10028D9E<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned int a4);
void *__thiscall sub_10028DDC(void *this);
void *__thiscall sub_10028DF3(void *this, int a2, int a3, int a4);
void *__thiscall sub_10028E2A(void *this, int a2, int a3, int a4);
// int __userpurge sub_10028E71<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
// int __userpurge sub_10028EB7<eax>(int a1<ebp>, int a2);
void *__thiscall sub_100291C2(void *this);
// int __userpurge sub_100291E7<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10029202<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1002921D<eax>(int a1<ecx>, int a2<ebx>, int a3);
int loc_10029241(); // weak
int __thiscall sub_10029254(PSLIST_HEADER ListHead);
int __thiscall sub_100292CB(int this);
int __thiscall sub_100292E2(int this);
int loc_10029300(); // weak
_DWORD __thiscall sub_10029307(_DWORD ecx0); // weak
int __thiscall sub_100293B5(int this, char a2);
void *__thiscall sub_100293FF(void *this, char a2);
void *__thiscall sub_1002941F(void *this, char a2);
void *__thiscall sub_1002943F(void *this, char a2);
void *__thiscall sub_1002945E(void *this, char a2);
int __thiscall sub_1002948A(int this, int a2);
// int __userpurge sub_100295E3<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
int __thiscall sub_10029610(void *this, int a2);
int __thiscall sub_10029649(void *this, int a2);
int __thiscall sub_10029676(int this, int a2);
int __thiscall sub_1002969D(void *this, int a2, unsigned int a3);
// int __userpurge sub_10029761<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5);
// int __userpurge sub_1002979C<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4);
char __cdecl sub_100297E5();
// int __usercall sub_100297E8<eax>(int a1<ecx>, int a2<ebx>);
// int __userpurge sub_1002982E<eax>(void *a1<ecx>, int a2<ebx>, int a3);
BOOL __thiscall sub_10029897(void *this);
int __thiscall sub_100298BA(void *this);
int __cdecl sub_10029942(int a1);
int __cdecl sub_1002994E(int a1);
int __cdecl sub_1002995A();
// int __usercall sub_1002997E<eax>(int a1<ebp>);
// int __usercall sub_100299DA<eax>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_10029A72(int this);
int __thiscall sub_10029AB5(int this, unsigned int a2);
signed int __thiscall sub_10029B42(int this);
// int __userpurge sub_10029BCB<eax>(int a1<ecx>, int a2<edi>, int a3);
int __stdcall sub_10029C28(int a2);
int __cdecl sub_10029C31();
// int __usercall sub_10029C4D<eax>(int a1<ebx>, int a2<edi>, void *a3);
// int __usercall sub_10029C73<eax>(int this<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>);
int __thiscall sub_10029C7F(int this);
BOOL __thiscall sub_10029C9A(int this);
int __stdcall sub_10029CBA(int a1);
int __stdcall sub_10029CD8(int a1);
int __thiscall sub_10029CFA(void *this);
int __thiscall sub_10029D17(void *this);
int __thiscall sub_10029D54(int this);
char __thiscall sub_10029D8B(void *this, int a2, char a3);
LPVOID __cdecl sub_10029DCE();
int __cdecl sub_10029DDB();
int __thiscall sub_10029DEE(int this);
int __thiscall sub_10029E0B(int this);
int __thiscall sub_10029F04(void *this);
int __thiscall sub_10029F3F(int this, int a2);
int __stdcall sub_10029F93(int a1, int a2, int a3, int a4);
int __thiscall sub_10029FBE(void *this, int a2, int a3, int a4);
char __thiscall sub_10029FED(int this, int a2, int a3, int a4, int a5, int a6, int a7);
char __thiscall sub_1002A0EA(int this);
char __thiscall sub_1002A114(void *this);
int __thiscall sub_1002A1DB(int this);
// int __userpurge sub_1002A1E4<eax>(int a1<ebp>, int a2, int a3);
// int __usercall sub_1002A28E<eax>(int a1<ebp>, int a2<edi>);
// int __userpurge sub_1002A31E<eax>(int a1<ebx>, int a2<ebp>, int a3);
// int __userpurge sub_1002A37E<eax>(int a1<ebp>, int a2);
int __thiscall sub_1002A48B(void *this);
int __thiscall sub_1002A49A(void *this);
int __cdecl sub_1002A4A9();
int __thiscall sub_1002A4B7(int this);
int __stdcall sub_1002A4EC(int a1, int a2, int a3);
int __thiscall sub_1002A528(int this, int a2, int a3);
int __thiscall sub_1002A552(int this);
int __thiscall sub_1002A573(int this, int a2);
int __thiscall sub_1002A595(int this, int a2, int a3);
int __thiscall sub_1002A5CA(int this);
// int __userpurge sub_1002A5CE<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// int __userpurge sub_1002A5E9<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4, int a5);
int __thiscall sub_1002A642(int this);
int __thiscall sub_1002A659(int this, char a2);
int __thiscall sub_1002A677(void *this);
// int __usercall sub_1002A68A<eax>(int a1<ebp>, int a2<edi>);
int __thiscall sub_1002A6EB(int this, int a2);
void __thiscall sub_1002A70E(void *this, int a2);
void __thiscall sub_1002A78D(void *this, int a2);
bool __thiscall sub_1002A7FD(int this);
int __cdecl sub_1002A812(int a1, unsigned int a2);
int __thiscall sub_1002A83E(int this);
int __thiscall sub_1002A845(_DWORD); // weak
int __thiscall sub_1002AC70(void *this);
// int __userpurge sub_1002AC7E<eax>(int a1<ebp>, int a2);
int __thiscall sub_1002AD41(void *this);
bool __thiscall sub_1002AD6F(int this, int a2);
int __thiscall sub_1002ADAD(int this, int (__cdecl *a2)(_DWORD), int a3, int a4);
int __thiscall sub_1002ADE0(int this, int a2);
char __thiscall sub_1002AE24(int this);
char __thiscall sub_1002AE41(void *this, int a2);
int __thiscall sub_1002AE75(int this, int a2, int a3);
int __stdcall sub_1002AE9F(int a1, int a2, int a3, int a4);
char __thiscall sub_1002AEB0(int this, int a2);
char __thiscall sub_1002AED2(int this, int a2);
DWORD __cdecl sub_1002AF61();
BOOL __cdecl sub_1002AFAF();
int __thiscall sub_1002AFC8(void *this, int a2);
int __thiscall sub_1002B165(int this);
int __thiscall sub_1002B1DB(int this);
int __thiscall sub_1002B263(void *this);
int __thiscall sub_1002B27B(void *_ECX, int a2);
char __thiscall sub_1002B299(void *this, int a2, char a3, int a4, int a5, int a6);
// int __userpurge sub_1002B2FD<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
int __thiscall sub_1002B334(int this);
int __thiscall sub_1002B34C(int this);
int __thiscall sub_1002B3B7(void *this);
// int __userpurge sub_1002B3C9<eax>(int a1<ecx>, int a2<edi>, HANDLE hSourceHandle);
int __thiscall sub_1002B47A(int this);
USHORT __thiscall sub_1002B494(int this, int a2);
int __thiscall sub_1002B4DB(void *this);
PSINGLE_LIST_ENTRY __thiscall sub_1002B4ED(int this, int a2, char a3);
int __thiscall sub_1002B52D(int this, int a2);
PSINGLE_LIST_ENTRY __thiscall sub_1002B571(int this);
BOOL __thiscall sub_1002B5BE(int this, LONG lReleaseCount);
int __thiscall sub_1002B5DC(void *this, int a2);
char __thiscall sub_1002B60E(void *ListHead, int a2, signed int a3, char a4);
char __thiscall sub_1002B70C(void *ListHead, int a2, signed int a3, char a4);
int __thiscall sub_1002B80A(void *this);
_DWORD *__thiscall sub_1002B832(void *this);
_DWORD *__thiscall sub_1002B856(int this);
int __thiscall sub_1002B879(int this, int a2);
char __thiscall sub_1002B8B5(int this, int a2);
char __thiscall sub_1002B8CD(int this);
int __thiscall sub_1002B8DB(void *this, int a2, unsigned int a3);
int __thiscall sub_1002B9D1(void *this);
void *__cdecl sub_1002BA1E(void *ListEntry);
LPVOID __cdecl sub_1002BA65();
char __thiscall sub_1002BA81(void *this);
int __thiscall sub_1002BAA3(void *this);
int __thiscall sub_1002BAD8(void *this, int a2, int a3, int a4);
void __thiscall sub_1002BB0E(int this, int a2);
int __cdecl sub_1002BB33(int a1, int a2);
int __cdecl sub_1002BB64(int a1, int a2);
char __thiscall sub_1002BB9E(void *this, int a2, char a3, int a4, int a5, int a6);
char __thiscall sub_1002BBC4(void *this, int a2, char a3, int a4, int a5, int a6, int a7);
void __cdecl sub_1002BC18();
int __thiscall sub_1002BC7B(void *this, int a2, int a3, int a4);
BOOL __thiscall sub_1002BDB4(void *this);
char __thiscall sub_1002BE3E(int this);
char __stdcall sub_1002BF63(int a1, int a2);
char __stdcall sub_1002BF72(int a1, int a2);
int __thiscall sub_1002BFBA(int this, int a2);
int __cdecl sub_1002C051(char a1, char a2, int a3);
int __stdcall sub_1002C0BC(char a1, char a2, int a3);
int __thiscall sub_1002C0E6(int this, int a2);
signed int __thiscall sub_1002C11B(int this);
int __thiscall sub_1002C149(int this, int a2);
signed int __thiscall sub_1002C191(int this);
char __thiscall sub_1002C1C3(int this, int a2);
int __thiscall sub_1002C264(void *this, char a2);
void __thiscall sub_1002C2C0(int this);
int __thiscall sub_1002C30A(void *this);
int __thiscall sub_1002C311(void *this);
void __cdecl sub_1002C318();
void *__thiscall sub_1002C326(void *this, int a2);
_DWORD *__thiscall sub_1002C36C(void *this);
int __cdecl sub_1002C373(int a1);
BOOL __cdecl sub_1002C380(int a1);
HMODULE __cdecl sub_1002C3BC(DWORD dwExitCode);
unsigned int __cdecl sub_1002C3E7();
HANDLE __cdecl sub_1002C433(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
HMODULE __cdecl sub_1002C47E();
int __cdecl sub_1002C512(unsigned int a1, int a2, int a3);
int __cdecl sub_1002C56C(int a1, int a2, int a3);
int __cdecl sub_1002C5AA(int a1, int a2);
int __cdecl sub_1002C5E0(int a1, int a2);
int __thiscall sub_1002C615(void *this);
int __thiscall sub_1002C625(void *this);
void __cdecl sub_1002C630();
char __thiscall sub_1002C639(void *this);
char __thiscall sub_1002C659(void *this);
BOOL __cdecl sub_1002C66E();
// void __usercall sub_1002C684(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, int a7);
BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);
// int __usercall sub_1002C819<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4, int a5, int a6);
// int __usercall sub_1002C927<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, int a7, int a8, int a9);
void *__cdecl sub_1002C950(void *a1, const void *a2, unsigned int a3);
int __cdecl loc_1002CB98(int, int, int); // weak
int __cdecl off_1002CC88(int, int, int); // weak
int __cdecl loc_1002CC98(int, int, int); // weak
int __cdecl loc_1002CD24(int, int, int); // weak
int __cdecl sub_1002CFA0(int a1);
void __stdcall sub_1002D02B(int a1, int a2);
int __cdecl sub_1002D086(_DWORD); // weak
int __thiscall sub_1002D09A(_DWORD); // weak
int sub_1002D0A9(void); // weak
char *__cdecl sub_1002D0B8();
char *__cdecl sub_1002D0EB();
char *__cdecl sub_1002D121();
char *__cdecl sub_1002D157();
// int __usercall sub_1002D190<eax>(int a1<ebx>, int a2<edi>, PEXCEPTION_RECORD ExceptionRecord, int TargetFrame, int a5);
// int __usercall sub_1002D1C1<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4<esi>);
// void __usercall sub_1002D25E(int a1<edi>, int a2<esi>, int a3, int a4, int a5, int a6, int a7);
_DWORD __cdecl sub_1002D2BC(_DWORD, _DWORD); // weak
// signed int __usercall sub_1002D2C3<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __cdecl loc_1002D36C(int, int, int, int, int, int, int); // weak
int __cdecl sub_1002D398(int a1, int a2, int a3, int a4, int a5);
// int __usercall sub_1002D417<eax>(int a1<ebp>, int a2, int a3);
// DWORD __userpurge sub_1002D447<eax>(int a1<edi>, int a2<esi>, PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord);
int __stdcall loc_1002D471(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord); // weak
// int __usercall sub_1002D49A<eax>(int a1<ebx>, int a2<edi>, int a3, int a4);
// void __usercall sub_1002D4C4(int a1<ebx>, int a2<edi>, int a3);
// signed int __usercall sub_1002D514<eax>(int a1<ebx>, int a2<edi>, int a3);
// int __usercall sub_1002D53D<eax>(int a1<eax>, int a2<ebx>, int a3<edi>, int ExceptionRecord, int a5, int a6, int a7);
int __cdecl sub_1002D573(int a1);
int __cdecl sub_1002D5FE(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
// void __usercall sub_1002D7CC(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __usercall sub_1002D80C<eax>(int a1<ebx>, int a2<esi>, PEXCEPTION_RECORD ExceptionRecord, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, PVOID TargetFrame);
// signed int __usercall sub_1002D887<eax>(int a1<ebx>, int a2<edi>, int a3);
void __cdecl sub_1002D8D4(int ExceptionRecord, int a2, int a3, int a4, int a5, char a6, int a7, PVOID TargetFrame);
// void __usercall sub_1002DC6F(int a1<ebx>, PEXCEPTION_RECORD ExceptionRecord, int a3, int a4, int a5, int a6, int a7, int a8, PVOID TargetFrame);
// char __usercall sub_1002DD89<al>(int a1<ebx>, int a2<edi>, int a3, int a4);
// char __usercall sub_1002DE0F<al>(int a1<ebx>, int a2<edi>);
int __cdecl sub_1002DE20(int a1, int a2);
int __cdecl sub_1002DE45(int a1, int a2, int a3, int a4);
int __cdecl sub_1002DED3(int a1, int a2, int a3, int a4);
// void __usercall sub_1002E058(int a1<ebx>, int a2<edi>, int a3);
// int __usercall sub_1002E0A6<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6);
// int __usercall sub_1002E17F<eax>(int a1<ebx>, int a2<edi>, int ExceptionRecord, int a4, int a5, int a6, int a7, int a8, PVOID TargetFrame, char a10);
bool __cdecl sub_1002E25E(int a1, int a2, int a3);
void __cdecl sub_1002E2BB(unsigned int a1, LPCSTR lpWideCharStr);
// void __usercall sub_1002E493(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// void __usercall sub_1002E51B(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
signed int __cdecl sub_1002E5C2();
void __cdecl sub_1002E5F7(int a1);
// int __usercall sub_1002E60C<eax>(int a1<ebx>, int a2<edi>);
// int __userpurge sub_1002E635<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
// int __usercall sub_1002E6BD<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4);
// int __usercall sub_1002E70D<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4);
// int __usercall sub_1002E75D<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4);
// int __usercall sub_1002E7AD<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4);
// int __usercall sub_1002E7FD<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4);
// int __usercall sub_1002E853<eax>(int a1<ebx>, int a2<edi>, signed int a3);
// int __usercall sub_1002E87E<eax>(int a1<ebx>, int a2<edi>, signed int a3);
// int __usercall sub_1002E8A9<eax>(int a1<ebx>, int a2<edi>, signed int a3);
// int __usercall sub_1002E8D4<eax>(int a1<ebx>, int a2<edi>, signed int a3);
// int __usercall sub_1002E8FF<eax>(int a1<ebx>, int a2<edi>, signed int a3);
// int __usercall sub_1002E92C<eax>(int a1<ebx>, int a2);
// int __usercall sub_1002E97F<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1002E9A5<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1002E9CB<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1002E9F3<eax>(int a1<ebx>, int a2<edi>);
int __fastcall sub_1002EA19(int a1, int a2, int a3);
// unsigned int __usercall sub_1002EDB1<eax>(int a1<ebx>, int a2, int a3, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpDestStr, int cchDest, UINT CodePage, int a10);
// unsigned int __usercall sub_1002EF9A<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpDestStr, int cchDest, UINT CodePage, int a11);
// LPVOID __usercall sub_1002EFE1<eax>(int this<ecx>, int ebx0<ebx>, unsigned int a2, unsigned int a3);
// int __usercall sub_1002F02B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int dwBytes);
// int __usercall sub_1002F074<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, LPVOID lpMem, int dwBytes);
// int __usercall sub_1002F0C0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, const void *lpMem, unsigned int a5, unsigned int a6);
// int __usercall sub_1002F110<eax>(int a1<ebx>);
// int __usercall sub_1002F123<eax>(int a1<ebx>, int a2);
// int __usercall sub_1002F144<eax>(int a1<ebx>);
signed int __cdecl sub_1002F157(int a1);
// signed int __usercall sub_1002F198<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned __int8 a4, int a5, unsigned __int8 a6);
// signed int __usercall sub_1002F1EE<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3);
int __cdecl sub_1002F204(int a1, int a2, unsigned int a3);
int __cdecl sub_1003097C(int, int, DWORD dwCmpFlags, int, int, int, int, UINT CodePage); // idb
int __cdecl sub_10030BE7(int a1, int a2);
// int __usercall sub_10030C07<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, DWORD dwCmpFlags, int a6, int a7, int a8, int a9, UINT CodePage);
int __stdcall sub_10030C50(unsigned __int64 a1, __int64 a2);
void *__cdecl sub_10030CF0(void *a1, unsigned __int8 a2, signed int a3);
int __cdecl sub_10030D80(int a1, int a2);
int __cdecl sub_10030DF0(int a1, int a2);
// signed int (__usercall *__usercall sub_10030E7C<eax>(int a1<ebx>, int a2<edi>, int a3))<eax>(int<edi>, int, int, unsigned int, int, int, int);
signed int (__usercall *__cdecl sub_10030E93())<eax>(int<edi>, int, int, unsigned int, int, int, int);
int __cdecl sub_10030EF3(int a1);
int __cdecl sub_10030F0A(int a1);
HANDLE __stdcall sub_10030F21(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, int a5, int a6);
int __cdecl sub_10030F4A(int a1, int a2, int a3);
int __cdecl sub_10030F6B(int a1, int a2, int a3);
DWORD __cdecl sub_10030F8C(int a1);
BOOL __cdecl sub_10030FAA(DWORD a1);
LPVOID __cdecl sub_10030FC9(DWORD a1);
BOOL __cdecl sub_10030FE8(DWORD a1, void *a2);
int __cdecl sub_1003100A();
int __cdecl sub_1003101A(int a1, int a2);
int __cdecl sub_10031034();
int __cdecl sub_10031046(int a1, int a2);
int __cdecl sub_1003106C(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, int); // idb
char __cdecl sub_1003109A();
int __cdecl sub_10031317(int a1, int a2, int a3, int a4);
int __cdecl sub_10031337(int a1, int a2, int a3);
int __cdecl sub_10031354(UINT uExitCode); // idb
LONG __cdecl sub_10031369(struct _EXCEPTION_POINTERS *ExceptionInfo);
int __cdecl sub_1003137F(int a1, int a2);
int __cdecl sub_10031399(int a1);
// int __usercall sub_100313B2<eax>(int a1<ebx>, int a2<edi>, int a3, int a4);
// int __usercall sub_100314F3<eax>(int a1<ebx>, int a2<edi>, int a3);
__int64 __stdcall sub_100315D0(__int64 a1, __int64 a2);
__int64 __stdcall sub_10031610(unsigned __int64 a1, unsigned int a2, unsigned int a3);
int __cdecl sub_10031678(int a1);
int __cdecl sub_100316AD(int a1);
int __cdecl sub_100316FB(int, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2); // idb
int __cdecl sub_10031747(int a1, int a2, int a3);
int __cdecl sub_100317C3(int a1);
int __stdcall LocaleEnumProc(int a1);
BOOL __cdecl sub_10031801(int (__stdcall *a1)(_DWORD, _DWORD, _DWORD), int a2, int a3);
int __cdecl sub_1003183E(int a1, LCTYPE a2, WCHAR *a3, int a4);
int __cdecl sub_1003186D(int a1, int a2);
BOOL __cdecl sub_10031898(int a1);
int __cdecl sub_100318C3(int, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest); // idb
int __cdecl sub_1003190F(int a1, unsigned __int16 *a2, int a3);
int __cdecl sub_1003197D(int a1, DWORD dwMapFlags, LPCWSTR lpSrcStr, unsigned int cchSrc, LPWSTR lpDestStr, int cchDest);
double sub_100319B0(void); // weak
double __cdecl sub_100319CD(_DWORD, _DWORD); // weak
// void __userpurge sub_10031A6A(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, LPVOID lpMem);
// void __usercall sub_10031BA1(int a1<ebx>, int a2<edi>, LPVOID lpMem);
// int __usercall sub_10031BD7<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_10031BEF<eax>(int a1<ebx>);
// void __usercall sub_10031C5E(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
// signed int __usercall sub_10031D11<eax>(int a1<ebx>);
void __cdecl sub_10031D87();
// void __usercall sub_10031DA4(int a1<ebx>, int a2<edi>);
// void __usercall sub_10031DDC(int a1<ebx>, int a2<edi>);
// void __usercall sub_10031E10(int a1<ebx>, int a2<edi>);
PVOID __cdecl sub_10031E23();
// int __usercall sub_10031E40<eax>(unsigned int a1<eax>, int a2<ecx>, char a3);
// signed int __usercall sub_10031E6C<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
int __cdecl sub_10031EC1();
// _DWORD __cdecl _SEH_prolog4(_DWORD, _DWORD); weak
// int __stdcall _SEH_epilog4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_10032060(PEXCEPTION_RECORD ExceptionRecord, int TargetFrame, int a3);
int (__stdcall *__thiscall sub_100321F5(HMODULE this, int a2))();
void __thiscall sub_10032227(HMODULE this, UINT uExitCode);
// void __usercall sub_1003223D(int a1<ebx>);
// void __usercall sub_1003234D(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// void __usercall sub_10032369(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_10032378<eax>(int a1<eax>, int a2<ebx>, int a3<edi>, int a4);
// void __usercall sub_10032409(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, UINT uExitCode);
unsigned int __cdecl sub_1003241D();
void __cdecl sub_10032455(unsigned int a1, unsigned int a2);
int __cdecl sub_10032471(unsigned int a1, unsigned int a2);
// void __usercall sub_10032493(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
void __cdecl sub_1003249C();
// void __usercall sub_100324A5(int a1<edx>, int ecx0<ecx>, int ebx0<ebx>, int a4<edi>, UINT uExitCode, int a2, int a3);
// SIZE_T __usercall sub_100325D4<eax>(int a1<ebx>, int a2<edi>, LPCVOID lpMem);
// void *__usercall sub_10032605<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
wchar_t *__cdecl sub_1003263E(int a1);
// void *__usercall sub_10032662<eax>(int a1<ebx>, int a2);
signed int __cdecl sub_1003281D(int a1, int a2, int a3, LCTYPE a4, LPVOID *a5);
void *__cdecl sub_100329F4(void *a1);
// void __usercall sub_10032A01(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
int __cdecl sub_10032A72();
DWORD __cdecl sub_10032B24(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent);
int __cdecl sub_10032B4B(int a1);
// int __usercall sub_10032B61<eax>(int a1<ebx>, int a2);
int __cdecl sub_10032BFC(int, int); // weak
signed int __cdecl sub_10032CB6(int a1, int a2);
signed int __cdecl sub_10032D03(HANDLE hThread, DWORD_PTR *a2);
int __thiscall sub_10032D3B(int this, int a2);
int __thiscall sub_10032D5C(_DWORD); // weak
// int __userpurge sub_10032E56<eax>(int a1<ecx>, int a2<ebx>, int a3);
int sub_10032E71(); // weak
// int __usercall sub_10032E7B<eax>(int a1<ebp>);
int loc_10032F3B(); // weak
int __thiscall sub_10032F42(int this, char a2);
int __thiscall sub_10032F90(int this, int a2);
unsigned int __thiscall sub_10032FCA(int this, unsigned int a2, unsigned int a3, unsigned int a4);
int __thiscall sub_1003309A(int this, int a2);
int __cdecl sub_100330BD(int a1);
int __cdecl sub_100330EC(int a1);
signed int __thiscall sub_10033113(DWORD_PTR *this, HANDLE hThread);
// int __usercall sub_10033125<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
// void __usercall sub_1003323C(int a1<ebx>);
int __thiscall sub_10033257(void *this, int a2);
int __thiscall sub_10033364(int this);
int __thiscall sub_10033387(int this);
// int __usercall sub_100333B4<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
void __thiscall sub_100334E1(LPVOID lpParameter);
int __cdecl sub_10033554(_DWORD); // weak
_DWORD __stdcall sub_10033559(_DWORD); // weak
// int __usercall sub_100335B5<eax>(int a1<ebp>, int a2<edi>);
int __thiscall sub_1003364A(int this, int a2, int a3);
int __thiscall sub_100336B7(int this);
int __thiscall sub_100336D0(int this, int a2);
// void __usercall sub_1003370A(int a1<ecx>, int a2<ebx>);
int __thiscall sub_10033A22(int this);
char __thiscall sub_10033A6F(int this);
void __thiscall sub_10033C1C(int this, int a2, char a3, char a4, int a5, unsigned int a6);
void __thiscall sub_10033D56(int this, int a2, int a3);
int __thiscall sub_10033ED7(int this);
char *__thiscall sub_10034139(int this, int a2, int a3, int a4, char a5);
char *__thiscall sub_100341A5(void *this, int a2, int a3, int a4, unsigned int a5);
int __stdcall StartAddress(int a1);
// int __usercall sub_10034326<eax>(int a1<ebp>);
int __thiscall sub_10034427(int this, int *a2, unsigned int *a3, int a4, int a5, unsigned int a6);
int __thiscall sub_1003476C(void *this, int a2, int a3, int a4);
char __thiscall sub_10034878(void *this, int a2, int a3, int a4, unsigned int a5);
int __thiscall sub_10034982(int this, __int16 a2);
BOOL __thiscall sub_100349BD(DWORD this);
int __thiscall sub_100349ED(int this);
// int __usercall sub_100349F1<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4<esi>);
// int __userpurge sub_10034A3C<eax>(int a1<ecx>, int a2<esi>, int a3);
int __thiscall sub_10034B51(int this);
int __thiscall sub_10034B5B(int this);
int __thiscall sub_10034B62(int this);
int __thiscall sub_10034B69(int this);
int __thiscall sub_10034B80(int this);
int __thiscall sub_10034B97(int this, int a2);
int __thiscall sub_10034BBC(int this, int a2);
// int __usercall sub_10034BE1<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4<esi>);
int __thiscall sub_10034C2C(int this);
int sub_10034C33(void); // weak
int __cdecl sub_10034C38();
int sub_10034C3D(void); // weak
int __cdecl sub_10034C42();
// int __usercall sub_10034C50<eax>(int a1<ebx>, int a2);
unsigned int __thiscall sub_10034C79(int this, int a2, int a3);
int __thiscall sub_10034D92(void *this, int a2, int a3);
void __thiscall sub_10034EE7(int this);
// char __userpurge sub_10034F1D<al>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, char a7);
// void *__userpurge sub_10034F56<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, unsigned __int16 a6, unsigned __int16 a7, void *a8, int a9, char a10);
void *__thiscall sub_1003506F(int this);
// void __usercall sub_10035131(int a1<ebx>, int a2<edi>, int a3<esi>, char a4);
int __thiscall sub_10035370(int this);
// int __userpurge sub_10035389<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, char a5);
int __thiscall sub_100354DF(int this, int a2, int a3, int a4);
void *__thiscall sub_100355A5(int this);
void __fastcall sub_100356B5(int a1);
unsigned int __thiscall sub_10035786(int this);
unsigned int __thiscall sub_100357B5(void *this, unsigned int a2);
unsigned int __thiscall sub_100359E4(int this, int a2, unsigned int a3, unsigned int a4, unsigned int a5);
int __thiscall sub_10035DB7(void *this);
int __stdcall sub_10035DC3(int a1, int a2);
// int __usercall sub_10035E16<eax>(int a1<ebp>);
unsigned int __thiscall sub_10035EAD(int this, int a2, unsigned int a3, int a4);
char __thiscall sub_10035F02(int this, int a2, int a3, int a4);
int __thiscall sub_10035FF8(int this, int a2);
// int __userpurge sub_1003602E<eax>(int a1<ebp>, int a2);
// int __userpurge sub_100360A2<eax>(int a1<ebp>, int a2, int a3);
unsigned int __thiscall sub_100361AD(int this, int a2, unsigned int a3);
unsigned int __thiscall sub_100361E1(int this, int a2, unsigned int a3, int a4);
int __thiscall sub_100363B3(int this);
// DWORD __usercall sub_1003640A<eax>(int a1<esi>);
void __cdecl sub_100364F2(int a1, unsigned int a2);
char __thiscall sub_100366B1(void *this);
int __thiscall sub_100366D0(void *this, int a2);
int __thiscall sub_1003689F(int this, int a2, char a3);
int __thiscall sub_1003696D(int this, int a2);
// int __userpurge sub_10036A26<eax>(int a1<ebp>, int a2);
int __thiscall sub_10036A77(int this, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_10036AE4<eax>(int a1<ebp>, int a2<esi>);
// void __usercall sub_10036B2D(int a1<ebx>, int a2<edi>, int a3<esi>, int a4, int a5, int a6);
void *__cdecl sub_10036C50(void *a1);
// int __usercall sub_10036C5D<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6, int a7);
// int __usercall sub_10036C88<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_10036C98<eax>(int a1<ebx>, int a2<edi>);
int __cdecl sub_10036CC3(int a1);
int __cdecl sub_10036CEA(int a1);
void __thiscall sub_10036CF8(int this, int a2);
_DWORD __stdcall loc_10036D10(_DWORD); // weak
char __thiscall sub_10036DAB(int this, char a2);
int sub_10036DB8(); // weak
int sub_10036EFA(); // weak
// void (__usercall *__usercall sub_10037024<eax>(int a1<ebp>, int a2<edi>))(int<ebp>);
// void __usercall sub_10037047(int a1<ebp>);
// void (__usercall *__usercall sub_1003707D<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>))(int<ebp>);
// int (__usercall *__usercall sub_10037099<eax>(int a1<ebp>, int a2<edi>))<eax>(int<ebp>);
// int __usercall sub_100370BC<eax>(int a1<ebp>);
int loc_100370CE(); // weak
int __thiscall sub_100371BF(int this, int a2);
signed int __thiscall sub_100371E5(int this, int a2);
char __thiscall sub_1003720D(int this);
int __thiscall sub_10037235(int this);
// int __usercall sub_10037260<eax>(int a1<ebx>, int a2<ebp>);
// int __usercall sub_100372CF<eax>(int a1<ebx>, int a2<ebp>);
char __thiscall sub_1003733F(int this);
int __fastcall sub_100373AC(int a1, int a2, int a3);
// int __usercall sub_1003740B<eax>(int a1<ebp>);
char __thiscall sub_10037457(void *this);
bool __thiscall sub_100374AD(int this);
int __thiscall sub_100374C3(int this, int a2);
int __thiscall sub_100374E7(void *this);
int __thiscall sub_10037521(int this, int a2);
int __cdecl sub_10037545(int a1);
int __cdecl sub_10037556(int a1);
// int __userpurge sub_10037567<eax>(int a1<ebp>, int a2);
int __cdecl sub_10037646(int (__cdecl *a1)(_DWORD, _DWORD), int a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __thiscall sub_10037652(int this, char a2, int a3);
int __thiscall sub_100376B8(void *this, char a2, int a3);
int __thiscall sub_10037746(int this, char a2);
int __thiscall sub_100377ED(void *ListHead, int a2, signed int a3, int a4);
// int __userpurge sub_100378DE<eax>(int a1<ebp>, int a2, int a3, int a4, int a5);
// int __userpurge sub_10037958<eax>(int a1<ebp>, int a2, int a3);
// int __userpurge sub_100379B1<eax>(int a1<ebp>, int a2, int a3, int a4);
_DWORD __stdcall sub_10037A6A(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __thiscall sub_10037AD6(PSLIST_HEADER ListHead);
int __thiscall sub_10037B48(PSLIST_HEADER ListHead);
// int __usercall sub_10037BBF<eax>(int a1<ebp>);
// int __usercall sub_10037C09<eax>(int a1<ebp>);
int __thiscall sub_10037C6D(int this, int a2);
int __thiscall sub_10037C97(int this, signed int a2);
void *__thiscall sub_10037CDD(void *this, char a2);
void *__thiscall sub_10037CFD(void *this, char a2);
int __thiscall sub_10037D1C(int this, int a2);
int __thiscall sub_10037E74(int this, int a2);
char __thiscall sub_10037FD0(void *this, int a2, char a3, int a4, int a5, int a6);
bool __cdecl sub_100380B3(int a1);
int __thiscall sub_100380BF(int this, int a2, int a3);
int __thiscall sub_100380E4(void *this, int a2, int a3);
// int __usercall sub_1003817C<eax>(int a1<ebp>);
// char __userpurge sub_100381F2<al>(int a1<ecx>, int i<edi>, int a3);
int __thiscall sub_100382D7(int this, int a2);
int __thiscall sub_1003831D(int this, int a2);
int __thiscall sub_1003834D(void *this, int a2, int a3);
int __thiscall sub_1003839F(int this);
int __thiscall sub_10038404(void *this, int a2, char a3);
int __thiscall sub_10038437(void *this);
// int __userpurge sub_10038447<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4);
bool __thiscall sub_10038491(int this);
bool __thiscall sub_1003849A(void *this);
// int __userpurge sub_100384A6<eax>(int a1<ecx>, int a2<edi>, int a3);
int __thiscall sub_100384CF(int this, int a2);
int __thiscall sub_100384E2(int this, int a2, int a3, int a4);
// int __userpurge sub_10038564<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned int a4, char a5);
int __thiscall sub_100385AE(int this, int a2, char a3);
bool __thiscall sub_10038667(void *this);
int __thiscall sub_100386BA(void *this);
int __thiscall sub_100386DB(void *this, int a2);
PSINGLE_LIST_ENTRY __thiscall sub_100386F4(void *this, int a2);
char __thiscall sub_1003871A(void *ListHead, int a2, signed int a3, char a4);
char __thiscall sub_10038810(int this);
char __thiscall sub_10038833(int this);
int __thiscall sub_10038872(int this, int a2);
char __thiscall sub_10038899(int this, int a2);
int __thiscall sub_100388DB(void *this, int a2, int a3, int a4);
int __thiscall sub_100388F9(void *this, int a2, int a3);
int __thiscall sub_1003890F(int this, int a2, int a3);
int __thiscall sub_10038A3B(int this, int a2);
// int __userpurge sub_10038A61<eax>(int a1<ecx>, int a2<edi>, char a3);
bool __cdecl sub_10038C10(int a1);
void *__cdecl sub_10038C36(void *a1);
void __cdecl sub_10038C43();
// signed int __usercall sub_10038C4B<eax>(int a1<edx>, int a2<ebx>, int a3, unsigned int *a4, void **a5, const void *a6, int a7);
// int __usercall sub_10038CAA<eax>(int a1<edi>, unsigned __int8 a2);
// signed int __usercall sub_10038CCB<eax>(int a1<edx>, int a2<ebx>, int a3);
signed int __cdecl sub_10038CED(int a1, int a2, int a3, int a4);
// int __usercall sub_10039DDB<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4, int a5);
// signed int __usercall sub_10039E09<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3, int a4);
// int __usercall sub_10039F56<eax>(int a1<ebx>, int (__cdecl *a2)(_DWORD, _DWORD, _DWORD, _DWORD), int a3, unsigned int a4, int a5, int a6, int a7);
// int __usercall sub_1003A01E<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned int a4, int a5, int a6, int a7);
bool __cdecl sub_1003A093();
void __cdecl sub_1003A0A8();
LONG __cdecl sub_1003A0B0(volatile LONG *lpAddend);
void __cdecl sub_1003A140(LPVOID lpMem);
volatile LONG *__cdecl sub_1003A29A(volatile LONG *lpAddend);
// void __usercall sub_1003A335(int a1<ebx>, int a2<edi>);
volatile LONG *__cdecl sub_1003A3B1(volatile LONG **a1, volatile LONG *lpAddend);
// signed int __usercall sub_1003A3FC<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6);
// int __usercall sub_1003A4BA<eax>(int a1<ebx>, int a2, int a3, char a4);
// int __userpurge sub_1003A4D8<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, const void **a5);
// int __userpurge sub_1003A4FE<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1003A519<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1003A534<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_1003A54F(LPVOID *this);
void **__thiscall sub_1003A558(void **this, const void **a2);
int __thiscall sub_1003A576(void *this, unsigned int a2);
char __thiscall sub_1003A5AC(void *this);
char __cdecl sub_1003A5CA(unsigned int a1, unsigned int a2);
// int __userpurge sub_1003A5E8<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4);
int __stdcall loc_1003A655(int, int); // weak
// void __userpurge sub_1003A6B9(int a1<ebp>, int a2, int a3);
int __thiscall sub_1003A6C8(void *this);
char *__cdecl sub_1003A710(unsigned int a1);
char __cdecl sub_1003A727(int a1, signed int a2);
int __thiscall sub_1003A7E3(void *this);
int __fastcall sub_1003A82C(int a1, int a2, int a3);
int __fastcall sub_1003A893(int a1, int a2);
int __thiscall sub_1003A8E4(int this);
int __thiscall sub_1003A8FB(int this);
// int __usercall sub_1003A912<eax>(int a1<ebp>);
void *__thiscall sub_1003A95D(void *this, char a2);
char __thiscall sub_1003A97C(int this, unsigned int a2);
int __thiscall sub_1003A9B3(void *this, int a2);
char __thiscall sub_1003A9F0(int this);
bool __cdecl sub_1003AA34(int a1);
char __thiscall sub_1003AA40(int this, int a2);
char __thiscall sub_1003AA87(int this, int a2, int a3, char a4);
signed int __thiscall sub_1003AB2C(int this, int a2);
int __thiscall sub_1003AB51(int this);
int __stdcall sub_1003AB5D(int a1);
int __thiscall sub_1003AB81(int this);
int __thiscall sub_1003AB9E(int this);
char __thiscall sub_1003ABAA(int this, int a2, int a3, int a4);
char __thiscall sub_1003AC1E(int this, int a2);
// int __usercall sub_1003AC49<eax>(int a1<ecx>, int a2<ebp>, int a3<edi>);
int __thiscall sub_1003AC62(int this, int a2, int a3);
int __thiscall sub_1003AD9F(int this, unsigned int a2);
int __thiscall sub_1003ADE1(int this, unsigned int a2);
int __thiscall sub_1003AE27(int this, int a2, char a3);
char __thiscall sub_1003AEA5(int this);
int __thiscall sub_1003AEF9(int this);
signed int __thiscall sub_1003AF1C(int this);
int __cdecl sub_1003AF6A();
char __thiscall sub_1003AF6D(void *ListHead, int a2, signed int a3, char a4);
char __thiscall sub_1003B068(int this);
char __thiscall sub_1003B1AB(int this);
int __thiscall sub_1003B1BF(void *this, int a2);
int __thiscall sub_1003B1F9(int this, unsigned int a2);
int __thiscall sub_1003B241(int this, unsigned int a2);
char __thiscall sub_1003B289(int this, int a2, int a3);
int __cdecl sub_1003B312(int a1);
int __cdecl sub_1003B32B(char a1, char a2, int a3, int a4);
int __stdcall sub_1003B39C(int a1);
int __stdcall sub_1003B3A6(char a1, char a2, int a3, int a4);
char __thiscall sub_1003B3D3(int this, char a2, char a3);
int __thiscall sub_1003B431(int this);
// int __userpurge sub_1003B44E<eax>(int a1<ebp>, int a2, int a3, int a4);
int __thiscall sub_1003B4CB(PSLIST_HEADER ListHead);
// int __usercall sub_1003B541<eax>(int a1<ebp>);
int __thiscall sub_1003B581(int this, int a2);
int __thiscall sub_1003B6DA(void *this, int a2, char a3);
int __thiscall sub_1003B7C3(int this, int a2);
int __thiscall sub_1003B800(void *this, int a2);
char __thiscall sub_1003B85D(void *this, int a2, int a3, int a4, int a5, int a6, int a7);
int __thiscall sub_1003B8CD(void *this, int a2);
// int __userpurge sub_1003B8F1<eax>(int a1<ebp>, int a2);
int __thiscall sub_1003B931(void *this, char a2);
void *__thiscall sub_1003B9AF(void *this, int a2);
// int __userpurge sub_1003BA22<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1003BA3D<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1003BA58<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1003BA73<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __usercall sub_1003BA8E<eax>(int a1<ebp>);
void *__thiscall sub_1003BAC9(void *this, char a2);
char __thiscall sub_1003BAF0(void *this, char a2, int a3, int a4, int a5);
// int __userpurge sub_1003BC69<eax>(int a1<ebp>, int a2);
int __thiscall sub_1003BCBA(void *this);
char __thiscall sub_1003BDDE(int this);
// void __usercall sub_1003BE50(int a1<ecx>, int a2<ebp>);
// int __usercall sub_1003BE68<eax>(int this<ecx>, int a2<ebp>);
// int __userpurge sub_1003BE83<eax>(int a1<ebp>, int a2);
int __thiscall sub_1003BFF7(int this, int a2);
// char __usercall sub_1003C034<al>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_1003C09E(int this, int a2, int a3);
// int __userpurge sub_1003C1A0<eax>(int a1<ecx>, int a2<edi>, int a3);
int __thiscall sub_1003C1CC(int this, int a2);
int __thiscall sub_1003C1FA(int this);
int __thiscall sub_1003C1FE(int this);
int __thiscall sub_1003C206(int this);
int __thiscall sub_1003C20D(int this);
signed int __thiscall sub_1003C215(void *this);
int __thiscall sub_1003C241(void *this, int a2, int a3, int a4);
bool __thiscall sub_1003C3A8(int this);
// char __usercall sub_1003C3B4<al>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_1003C412(void *this);
void __thiscall sub_1003C4E8(int this, char a2);
int __thiscall sub_1003C55C(int this, int a2, int a3, char a4);
int __thiscall sub_1003C5C5(int this, int a2);
int __thiscall sub_1003C5DC(int this, int a2);
void __thiscall sub_1003C61D(int this);
int __thiscall sub_1003C66C(void *this);
// void __usercall sub_1003C68B(int a1<ecx>, int a2<ebp>);
int __thiscall sub_1003C6AE(int this, int a2);
char __thiscall sub_1003C6EE(int this);
char __cdecl sub_1003C719(int a1, int a2);
int __thiscall sub_1003C746(void *this);
void __thiscall sub_1003C7D6(int this, int a2, char a3);
char __thiscall sub_1003C827(int this, int a2);
int __thiscall sub_1003C913(int this, int a2, int a3);
int __fastcall sub_1003CA0A(int a1);
int __thiscall sub_1003CAAE(int this);
char __thiscall sub_1003CB9E(int this, int a2);
int __thiscall sub_1003CC05(void *this);
// int __userpurge sub_1003CD40<eax>(int a1<ebp>, int a2, int a3);
int __thiscall sub_1003CDC6(PSLIST_HEADER ListHead);
// int __usercall sub_1003CE3C<eax>(int a1<ebp>);
int __thiscall sub_1003CE6F(int this);
bool __cdecl sub_1003CEA1(int a1);
int __stdcall sub_1003CEAD(int a1);
char __thiscall sub_1003CED1(void *ListHead, int a2, signed int a3, char a4);
char __thiscall sub_1003CFCC(void *this, int a2);
int __thiscall sub_1003CFF5(int *this, int a2, int a3);
// int __userpurge sub_1003D045<eax>(int a1<ecx>, int a2<edi>, int a3, int a4);
int __thiscall sub_1003D098(int this, int a2);
int __thiscall sub_1003D0CB(int this, int a2);
// int __userpurge sub_1003D103<eax>(int a1<ecx>, int a2<edi>, int a3, int a4, int a5, int a6);
// int __userpurge sub_1003D129<eax>(int a1<ecx>, int a2<edi>, int a3, int a4);
int __thiscall sub_1003D141(int this);
bool __thiscall sub_1003D174(void *this, int a2);
int __thiscall sub_1003D1B2(int this, int a2, int a3);
int __thiscall sub_1003D1D8(int this, int a2);
int __thiscall sub_1003D1E7(int this, int a2, int a3);
int __thiscall sub_1003D213(int this, int a2, char a3);
// int __userpurge sub_1003D279<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4);
// int __usercall sub_1003D33F<eax>(int a1<ebp>);
void *__thiscall sub_1003D36C(void *this, char a2);
// int __userpurge sub_1003D38B<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
DWORD __thiscall sub_1003D3AC(int this);
// int __usercall sub_1003D3E6<eax>(int a1<ecx>, int a2<ebp>);
// char __userpurge sub_1003D43E<al>(void *this<ecx>, int edi0<edi>, int a2);
// int __usercall sub_1003D463<eax>(int a1<ecx>, int a2<ebp>, int a3<edi>);
signed int __cdecl sub_1003D485();
int __stdcall sub_1003D489(int a1, int a2, int a3, int a4);
char __stdcall sub_1003D4AB(int a1, int a2);
bool __thiscall sub_1003D4CE(int this);
void __thiscall sub_1003D4DA(int this, char a2);
DWORD __thiscall sub_1003D511(int Context, char a2);
// BOOL __usercall sub_1003D5DE<eax>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_1003D600(void *this);
int __thiscall sub_1003D605(void *this);
void *__thiscall sub_1003D69B(void *this, int a2);
void *__thiscall sub_1003D6BD(void *this, int a2);
int __thiscall sub_1003D6EA(int this);
void __stdcall sub_1003D6FE(int a1);
void *__thiscall sub_1003D706(void *this, char a2);
int __stdcall loc_1003D70E(int); // weak
int __thiscall sub_1003D759(void *this, int a2, unsigned int a3);
// int __usercall sub_1003D765<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __usercall sub_1003D798<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __userpurge sub_1003D7D6<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5);
signed int __cdecl sub_1003D80E();
int __thiscall sub_1003D812(void *this);
int __thiscall sub_1003D816(int this);
// int __userpurge sub_1003D81E<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// int __userpurge sub_1003D838<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
int __thiscall sub_1003D843(void *this, int a2, unsigned int a3);
int __thiscall sub_1003D84F(void *this, int a2, int a3, int a4);
DWORD __cdecl sub_1003D85B();
BOOL __cdecl sub_1003D89F();
// signed int __usercall sub_1003D8B3<eax>(int a1<ecx>, int a2<ebx>);
// void __usercall sub_1003D926(int a1<edx>, int a2<ecx>, int a3<ebx>);
void **__cdecl sub_1003D94D();
// void __usercall sub_1003D953(int a1<edx>, int a2<ebx>, int a3<edi>, unsigned int a4);
// void __usercall sub_1003D992(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5, int a6);
void __cdecl sub_1003D9C2(unsigned int a1);
void __cdecl sub_1003D9FC(signed int a1, int a2);
// void __usercall sub_1003DA29(int a1<ebx>, int a2<edi>, int edx0<edx>, int a4<ecx>, int a3);
signed int __cdecl sub_1003DA6F(int a1);
// void __usercall sub_1003DAD3(int a1<edx>, int a2<ecx>, int a3<ebx>);
// void __usercall sub_1003DADC(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
// int __usercall sub_1003DC35<eax>(int a1<ebx>, int a2, int a3);
// int __usercall sub_1003DD90<eax>(int a1<ebx>, int a2, int a3);
// void __usercall sub_1003DDAE(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// void __usercall sub_1003E05C(int a1<ebx>);
// signed int __usercall sub_1003E0AE<eax>(int a1<ebx>);
int __cdecl sub_1003E15F(int a1, int a2, int a3, int a4, int a5);
// signed int __usercall sub_1003E2DB<eax>(int a1<ecx>, int a2<ebx>);
signed int __cdecl sub_1003E3BC();
// int __usercall sub_1003E456<eax>(int a1<ebx>);
void __cdecl sub_1003E4E1();
void __cdecl sub_1003E501();
// void __userpurge sub_1003E530(int a1<ebp>, int a2<edi>, int a3<esi>, int a4, int a5, int a6);
int __cdecl sub_1003E57C(int a1);
// void __usercall sub_1003E58B(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
int __cdecl sub_1003E5DD(int a1);
// void __usercall sub_1003E641(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6);
int __cdecl sub_1003E6AF(int, int); // weak
void __cdecl sub_1003E7D9(void *lpAddend, const void *a2);
int __cdecl sub_1003E805(int a1, int a2, int a3, int a4, int a5, int a6);
void __fastcall sub_1003EAFA(int a1, int a2, int a3, int a4, int a5);
// void __usercall sub_1003EB39(int a1<edi>, unsigned int a2, int a3);
// int __usercall sub_1003ECB6<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
int __fastcall sub_1003EE2A(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1003F0B1(int a1, int a2, int a3);
int __cdecl sub_1003F449(LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int cchWideChar, int); // idb
int __cdecl sub_1003F5A8(int, LPWSTR lpWideCharStr, int cchWideChar, LPCSTR lpMultiByteStr, int, int); // idb
int __cdecl sub_1003F684(int, LPWSTR lpWideCharStr, int cchWideChar, LPCSTR lpMultiByteStr, int); // idb
signed int __cdecl sub_1003F6A2(CHAR *a1, int lpWideCharStr, int cbMultiByte, int a4);
// signed int __usercall sub_1003F907<eax>(int a1<ebx>, int a2, CHAR *a3, int cbMultiByte, int lpWideCharStr, int a6, int a7);
// int __usercall sub_1003F9D0<eax>(int a1<ebx>);
wchar_t *__cdecl sub_1003F9EE(int a1);
// UINT __usercall sub_1003FA28<eax>(int a1<ebx>, int a2<edi>, UINT a3);
int __cdecl sub_1003FA94(int a1);
char __cdecl sub_1003FAFD(int a1);
// void __usercall sub_1003FC8B(int a1<ebx>, int a2<edi>);
// void __usercall sub_1003FD30(int a1<ebx>, UINT a2);
// signed int __usercall sub_1003FEDE<eax>(int a1<ebx>, int a2<edi>, UINT a3, int a4);
// int __usercall sub_100400D3<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4, int a5);
// LPVOID __usercall sub_10040182<eax>(void *a1<ecx>, int a2<ebx>, unsigned int a3, unsigned int a4);
// signed int __usercall sub_100401C0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, int a7);
int __cdecl sub_1004021C(int, DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, int); // idb
// int __usercall sub_10040308<eax>(int a1<ebx>, int a2<edi>, int a3, DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, int a9);
// int __usercall sub_10040346<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, const void *lpMem, unsigned int a5, unsigned int a6);
// LPVOID __usercall sub_100403AF<eax>(void *this<ecx>, int ebx0<ebx>, unsigned int a2, unsigned int a3, int a4);
PVOID __cdecl sub_100404F1();
int __cdecl sub_100404FE(int a1);
void __cdecl sub_1004051A(int a1);
unsigned int __cdecl sub_100406CF(int a1, unsigned int a2);
int __cdecl sub_1004070B(double); // idb
int __cdecl sub_100407A7(double, int); // idb
double __cdecl sub_10040879(double a1, __int16 a2);
signed int __cdecl sub_100408A4(int a1, int a2);
int __cdecl sub_10040900(char a1);
double __cdecl sub_10040932(char, _DWORD, _DWORD); // weak
bool __cdecl sub_100409FA(signed int a1, double a2);
// double __usercall sub_10040BD6<st0>(__int16 a1<cx>, int a2<ebx>, int a3, double a4);
int __cdecl sub_10040C26(ULONG_PTR Arguments, int a2, char a3, int a4, int a5, int a6);
int __cdecl sub_10040C47(ULONG_PTR Arguments, int a2, char a3, int a4, int a5, int a6, int a7);
// int __usercall sub_10040F2C<eax>(int a1<ebx>, int a2);
// double __usercall sub_10040F59<st0>(int a1<ebx>, int a2, int a3, int a4, int a5, int a6, int a7, double a8);
int __cdecl sub_10040FF7(int a1);
int __thiscall sub_1004106D(int (*this)(void));
int __fastcall sub_1004107C(__int16 a1);
void __cdecl sub_100410A5();
int __thiscall sub_100410FB(int (*this)(void));
// signed int __usercall sub_10041109<eax>(int a1<edi>, int a2, int a3, unsigned int a4, int a5, int a6, int a7);
// signed int __usercall sub_1004112A<eax>(int a1<edi>, int a2, int a3, unsigned int a4, int a5, int a6, int a7, int a8);
// signed int __usercall sub_100411B0<eax>(int a1<edi>, int a2, int a3, unsigned int a4, int a5, int a6, int a7);
signed int __cdecl sub_1004150A(int a1, int a2, unsigned int a3, int a4, int a5);
// int __usercall sub_10041528<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned int a4, int a5, int a6, int a7, char a8, int a9);
signed int __cdecl sub_10041677(int a1, int a2, unsigned int a3, int a4, int a5, int a6);
// signed int __usercall sub_10041743<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6, char a7, int a8);
signed int __cdecl sub_1004182D(int a1, int a2, int a3, int a4, int a5);
signed int __cdecl sub_100418EC(int a1, int a2, unsigned int a3, int a4, int a5, int a6);
// char __usercall sub_100419E9<al>(int a1<ebx>, int a2<edi>, int a3);
// char __usercall sub_100419FA<al>(int a1<ebx>, int a2<edi>, int a3, int a4);
// int __usercall sub_10041A78<eax>(int a1<ebx>, int a2, int a3, int a4);
// int __usercall sub_10041A90<eax>(int a1<ebx>, int a2, int a3, int a4, int a5);
// char __usercall sub_10041AD0<al>(int a1<ebx>, int a2<edi>, int *a3);
// char __usercall sub_10041AE1<al>(int a1<ebx>, int a2<edi>, int *a3, int a4);
bool __cdecl sub_10041B53(int a1);
void __cdecl sub_10041B6D(int a1, int a2);
// signed int __usercall sub_10041B95<eax>(int a1<ebx>, int a2<edi>);
int (*__cdecl sub_10041BBC())();
// int __usercall sub_10041BDB<eax>(int a1<ebx>, int a2<edi>, int a3, const WCHAR *a4);
// int __usercall sub_10041C6E<eax>(int a1<ebx>, int a2<edi>, int a3, const WCHAR *a4, int a5);
// int __usercall sub_10041D47<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3, int a4);
// int __usercall sub_10041D7D<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3);
unsigned int __cdecl sub_10041D8E(int a1, unsigned int a2);
// int __usercall sub_10041DB0<eax>(int a1<edx>, __int16 a2<cx>, int a3<ebp>, __int16 a4<fpstat>, double _ST7<st0>, char a6, char a7, char a8);
// int __usercall sub_10041E17<eax>(int a1<edx>, int a2<ebp>, __int16 a3<fpstat>, double _ST6<st1>, double a5<st0>, char a6, char a7, char a8);
int loc_10041EB6(); // weak
double __cdecl sub_10041EBD();
// double __usercall sub_10041EC2<st0>(int a1<ebp>, double a2<st0>);
// void __usercall sub_10041F69(int a1<ebp>);
void __cdecl sub_10041F80();
// double __usercall sub_10041F97<st0>(int a1<eax>, int a2<edx>, int a3<ecx>, double a4<st0>, __int16 a5, int a6, int a7, int a8);
int __cdecl loc_10041FA0(__int16, int, int, int); // weak
double __cdecl sub_10041FF5(_DWORD); // weak
// double __usercall sub_1004200C<st0>(int a1<eax>, double result<st0>);
double __fastcall sub_10042025(int a1, int a2);
int __cdecl sub_10042068(int a1, int a2);
// int __usercall sub_10042170<eax>(unsigned int a1<eax>, int a2<ecx>);
int __cdecl sub_100421A0(int a1, unsigned int a2);
// unsigned int __usercall sub_100421F0<eax>(int a1<eax>, int a2);
char __cdecl sub_100422B0(int a1);
// int __usercall sub_100422F0<eax>(int a1<ebp>, int a2, int a3, unsigned int a4);
int __cdecl loc_10042380(int, int, int, int); // weak
int __thiscall sub_100423E2(void *this);
int __fastcall sub_100423F9(int a1, int a2);
void __fastcall sub_10042412(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord);
int __fastcall loc_10042426(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord); // weak
int __fastcall sub_1004242B(int a1, unsigned int a2, int a3, int a4);
int __cdecl sub_10042442(int a1);
// signed int __usercall sub_1004244F<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6);
// signed int __usercall sub_100424BB<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5);
int __cdecl sub_100424FB(const WCHAR *a1, int a2, int a3);
// int __usercall sub_100426DD<eax>(int a1<edi>, int a2, int a3, LCTYPE a4, LPSTR lpMultiByteStr, int cbMultiByte);
// int __usercall sub_100427B5<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, LCTYPE a5, LPSTR lpMultiByteStr, int cbMultiByte);
int __thiscall sub_100427ED(int this, int a2, int a3, int a4);
int __thiscall sub_10042854(int this, int a2, int a3);
int __thiscall sub_100428B3(int this);
void __thiscall sub_100428C5(int this);
int __thiscall sub_10042930(int this);
int __thiscall sub_10042934(int this);
BOOL __thiscall sub_10042938(int lpTlsValue);
int __thiscall sub_10042A04(int this, int a2);
BOOL __thiscall sub_10042A70(int this);
BOOL __thiscall sub_10042A8B(LPVOID lpTlsValue);
unsigned int __cdecl sub_10042AAD(unsigned int a1);
double __cdecl sub_10042AC5(double a1);
int __thiscall sub_10042AFB(int this, int a2, unsigned int a3, int a4);
int __thiscall sub_10042B85(int this, double a2, int a3);
double __stdcall sub_10042BA8(unsigned int a1, unsigned int a2, int a3, int a4);
double __thiscall sub_10042BE3(void *this, int a2, int a3);
double __thiscall sub_10042C9B(int this);
int __thiscall sub_10042CD2(int this, int a2);
__int64 __fastcall sub_10042D17(int a1);
int __thiscall sub_10042D5B(void *this, int a2);
bool __thiscall sub_10042D86(int this);
char __stdcall sub_10042D9F(int a1);
double __fastcall sub_10042DCF(int a1);
int __thiscall sub_10042DEF(int this, unsigned int a2);
int __thiscall sub_10042EBF(int this, int a2, unsigned int a3, int a4, int a5);
double __fastcall sub_1004307E(int a1);
_DWORD __stdcall sub_100430CA(_DWORD, _DWORD, _DWORD); // weak
int sub_10043320(void); // weak
char *__thiscall sub_10043369(int this, int a2, int a3, char a4);
_DWORD __stdcall sub_10043421(_DWORD); // weak
int __thiscall sub_10043479(int this, int a2);
int __thiscall sub_100434B2(int this, int a2);
_DWORD __stdcall sub_100434C1(_DWORD, _DWORD); // weak
int __thiscall sub_10043555(void *this, int a2);
int __thiscall sub_100435C5(void *this, int a2);
int __thiscall sub_10043618(void *this);
// int __userpurge sub_100436D4<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4);
// int __userpurge sub_100437D7<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5);
int __thiscall sub_1004380F(int this, int a2);
int __thiscall sub_10043867(int this, int a2, int a3, char a4);
int __thiscall sub_100438E2(void *this);
int __thiscall sub_100438F7(int this, int a2);
_DWORD __stdcall sub_10043983(_DWORD); // weak
int __thiscall sub_100439EF(void *this);
LPVOID __thiscall sub_100439FF(int this);
// int __userpurge sub_10043A1C<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10043A5C<eax>(int a1<ebp>, int a2);
int __thiscall sub_10043AAA(int this, unsigned int a2, int a3, char a4);
int __thiscall sub_10043D88(int this, int a2);
int __thiscall sub_10043DE4(int this, int a2, int a3, char a4);
// int __usercall sub_10043E66<eax>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_10043EEC(int this, int a2);
// int __userpurge sub_10043F22<eax>(int a1<ebp>, int a2, int a3);
int __thiscall sub_10043FF1(void *this, void *a2);
int __thiscall sub_1004401A(int this, int a2);
_DWORD __stdcall sub_1004402D(_DWORD, _DWORD); // weak
int __thiscall sub_100440F2(int this);
// int __usercall sub_100440FC<eax>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_10044106(int this, int a2, int a3);
int __stdcall sub_1004413B(int a1);
int __cdecl sub_10044181(int a1);
_DWORD __cdecl loc_10044230(_DWORD); // weak
int __cdecl sub_10044246();
int __thiscall sub_10044254(int this, int a2);
void *__thiscall sub_10044287(void *this, int a2, int a3);
int __thiscall sub_100442B8(int this, int a2);
// int __usercall sub_100442DE<eax>(int a1<ebp>);
// int __usercall sub_10044341<eax>(int a1<ebp>);
void *__thiscall sub_10044388(void *this, char a2);
void *__thiscall sub_100443AD(void *this, char a2);
// int __userpurge sub_100443CD<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4);
// int __usercall sub_10044402<eax>(int a1<ebx>, int a2<edi>, int a3);
int __thiscall sub_10044426(int this);
// int __usercall sub_1004442A<eax>(int a1<ebx>, int a2<ebp>);
int __stdcall sub_1004446F(int, int nPriority); // idb
__int16 __thiscall sub_10044487(void *this, int a2);
void __thiscall sub_100444E0(int this, int a2);
int __thiscall sub_10044571(void *this);
int __thiscall sub_1004459A(void *this, unsigned int a2, int a3);
BOOL __stdcall sub_10044608(int a1);
PSINGLE_LIST_ENTRY __thiscall sub_10044617(void *this);
int __thiscall sub_1004466D(int this);
void __cdecl sub_10044681();
// double __usercall sub_100446D6<st0>(double<st0>); weak
int __thiscall sub_1004474B(int this, int a2, int a3, int a4, int a5);
bool __thiscall sub_10044770(int this, char a2);
char __thiscall sub_1004479B(int this, int a2);
char __thiscall sub_100447E2(int this, int a2);
// signed int __usercall sub_1004482A<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
// signed int __usercall sub_1004494B<eax>(int a1<ebx>, int a2<edi>, int a3);
// signed int __usercall sub_1004496F<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5);
// signed int __usercall sub_10044A4F<eax>(int a1<edi>, LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int a4, int a5);
// signed int __usercall sub_10044B42<eax>(int a1<edi>, LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int a4);
// int __usercall sub_10044B5A<eax>(int a1<ebx>, int a2<edi>, signed int a3);
// void __usercall sub_10044BAE(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, const void *a6, int nNumberOfBytesToWrite);
// int __usercall sub_10044C90<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<esi>, signed int a5, const void *a6, int nNumberOfBytesToWrite);
// void __usercall sub_100454BA(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, LARGE_INTEGER liDistanceToMove, DWORD dwMoveMethod);
// LARGE_INTEGER __usercall sub_100455B6<edx:eax>(int a1<ebx>, int a2<edi>, signed int a3, LARGE_INTEGER liDistanceToMove, DWORD dwMoveMethod);
// int __usercall sub_10045627<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
signed int __cdecl sub_1004566D(int a1, int a2, int a3, int a4);
// int __usercall sub_100461D5<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3, int a4, int a5);
// int __usercall sub_1004621B<eax>(int a1<ebx>, unsigned __int8 a2, int a3, int a4, int a5);
int __cdecl sub_10046247(unsigned __int8 *a1, int a2, int a3, int a4, int *a5);
bool __cdecl sub_100462BF();
int __cdecl sub_100462D4(int, LPSTR UsedDefaultChar, int cbMultiByte, const WCHAR WideCharStr, int); // idb
int __cdecl sub_100463F6(int a1, LPSTR UsedDefaultChar, int cbMultiByte, const WCHAR WideCharStr);
// void __usercall sub_10046411(int a1<ebx>, int a2);
signed int __cdecl sub_1004650D(int lpMem);
// void __usercall sub_100468AF(int a1<ebx>, int a2);
int __thiscall sub_10046916(int this, int lpMem);
// void __usercall sub_10046B1E(int a1<ebx>, int a2);
signed int __thiscall sub_10046E9E(int this, int a2);
int __cdecl sub_10046F1A(int a1, int a2);
int __thiscall sub_1004770B(int this, int a2);
unsigned int __thiscall sub_10047731(int this, int a2);
// int __usercall sub_10047782<eax>(int a1<ecx>, int a2<edi>);
int __thiscall sub_100477CB(int this, int a2);
char __thiscall sub_10047801(int this, int a2);
char __thiscall sub_1004781F(int this, int a2, int a3, char a4);
int __thiscall sub_100478B6(int this, int a2, int a3);
int __thiscall sub_10047903(int this, int a2);
int __thiscall sub_1004793E(int this, int a2);
char __stdcall sub_1004797C(int a1, int a2, char a3);
char __thiscall sub_100479CC(void *this, int a2, int a3, char a4, int a5, char a6);
char __stdcall sub_10047A4D(int a1, int a2);
char __thiscall sub_10047A7E(void *this, int a2, int a3, int a4, char a5);
// char __userpurge sub_10047AF9<al>(int a1<edi>, int a2, int a3, char a4, char a5);
char __thiscall sub_10047B4C(void *this, int a2, int a3, char a4, int a5, char a6);
int __thiscall sub_10047BDA(int this);
int __thiscall sub_10047C0F(void *this, int a2);
char __thiscall sub_10047C2E(void *this, int a2);
// char __userpurge sub_10047C5E<al>(int a1<edi>, int a2, int a3, char a4, unsigned int a5);
// char __userpurge sub_10047CCB<al>(int a1<edi>, int a2, int a3, char a4, unsigned int a5);
DWORD __thiscall sub_10047D39(int this, int a2, int a3);
// bool __usercall sub_10047D8D<eax>(int a1<ecx>, int a2<edi>);
char __thiscall sub_10047E0B(void *this, int a2, int a3, char a4, unsigned int a5);
char __thiscall sub_100480C9(void *this, int a2, int a3, char a4, unsigned int a5);
char __thiscall sub_10048348(void *this, int a2, int a3, int a4, char a5, int a6, unsigned int a7, char a8);
char __thiscall sub_10048441(void *this, int a2, int a3, int a4, int a5, int i, unsigned int a7, char a8);
char __thiscall sub_10048547(void *this, int a2, int a3, int a4, char a5, int a6, unsigned int a7, char a8);
char __thiscall sub_10048643(void *this, int a2, int a3, int a4, unsigned int a5);
char __thiscall sub_10048756(void *this, int a2, int a3, int a4, unsigned int a5);
char __stdcall sub_10048864(int a1, int a2, char a3);
char __stdcall sub_100488F8(int a1, int a2);
char __stdcall sub_10048966(int a1, int a2, char a3);
int __thiscall sub_100489FE(int this, int a2);
int __thiscall sub_10048A1B(int this, int a2);
char __thiscall sub_10048A38(void *this, int a2, int a3, int a4, char a5);
char __thiscall sub_10048AC0(void *this, int a2, int a3);
char __thiscall sub_10048B02(void *this, int a2, int a3, int a4);
// int __usercall sub_10048B6E<eax>(int a1<ecx>, int a2<ebp>);
void __thiscall sub_10048B85(void *this, int a2);
int __thiscall sub_10048BDA(int this);
// int __userpurge sub_10048BE2<eax>(int a1<ebp>, int a2, int a3);
void *__thiscall sub_10048C19(void *this, char a2);
// void __usercall sub_10048C3E(int a1<edx>, int a2<ecx>, int a3<ebx>);
// void __usercall sub_10048CDB(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
int __cdecl sub_10048DF0(int, int, int, int, int); // weak
// int __usercall sub_10048E35<eax>(int a1<ebp>, int a2, unsigned int a3);
void __cdecl sub_10048EDC();
// int __userpurge sub_10048EE5<eax>(int result<eax>, int a2<ebp>, int a3);
int __stdcall loc_10048EF0(int); // weak
// int __usercall sub_10048F04<eax>(int (*a1)(void)<eax>);
int __cdecl sub_10048F07(int a1, int a2);
int __cdecl sub_10048F45(int a1, int a2);
int __cdecl sub_10048F94(int a1, int a2, int a3);
int __cdecl sub_10048FCA(int a1, int a2);
// int __usercall sub_1004900C<eax>(int a1<ebx>, int a2<edi>, int a3);
int __cdecl sub_10049083(int); // weak
BOOL __cdecl sub_100490F7(int a1);
int __cdecl sub_10049141(unsigned __int16 *a1);
// unsigned int __userpurge sub_10049173<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
// unsigned int __userpurge sub_10049391<eax>(int a1<ebx>, int a2, int a3, int a4);
// int __usercall sub_10049442<eax>(int a1<ebx>, int a2<edi>, int a3, int a4);
int __cdecl sub_100494D7(int a1);
// signed int __usercall sub_10049521<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
// unsigned int __userpurge sub_100496E3<eax>(int a1<ebx>, int a2<edi>, int a3);
// int __usercall sub_10049791<eax>(int a1<ebx>, int a2<edi>, int a3);
// BOOL __usercall sub_100497D1<eax>(int a1<ebx>, int a2<edi>, int a3);
// int __usercall sub_1004984E<eax>(int a1<ebx>, int a2<edi>, int a3);
int __cdecl sub_100498A7(unsigned __int16 *a1);
// signed int __userpurge sub_100498D1<eax>(int a1<ebx>, int a2<edi>, int a3);
// signed int __userpurge sub_10049AC4<eax>(int a1<ebx>, int a2<edi>, int a3);
int __cdecl sub_10049B9D(int a1);
// int __usercall sub_10049BEC<eax>(int a1<ebx>, int a2<edi>, int LCData, int a4);
signed int __cdecl sub_10049C77(__int16 a1);
// bool __usercall sub_10049C99<eax>(int a1<ebx>, int a2<edi>, int a3, int a4);
bool __cdecl sub_10049D01(int a1, int a2, int *a3);
// signed int __usercall sub_10049D6D<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
int __thiscall sub_10049F90(void *this, unsigned int a2, unsigned __int8 a3);
// signed int __usercall sub_1004A0C7<eax>(int a1<ebx>, int a2, unsigned int a3, int a4, int a5);
// signed int __usercall sub_1004A177<eax>(int a1<ebx>, int a2, int a3, int a4);
// signed int __usercall sub_1004A203<eax>(int a1<ebx>, int a2, int a3, int a4);
__int16 __cdecl sub_1004A28F(int a1, int a2);
int __stdcall sub_1004A3F0(unsigned __int64 a1, __int64 a2);
// unsigned __int64 __usercall sub_1004A4D0<edx:eax>(unsigned __int64 a1<edx:eax>, unsigned __int8 a2<cl>);
// signed int __usercall sub_1004A4EF<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
// void __usercall sub_1004A54C(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// WCHAR __usercall sub_1004A555<ax>(int a1<ebx>, int a2<edi>, const WCHAR SrcStr, int a4);
int __thiscall sub_1004A607(void *this, const WCHAR SrcStr, __int16 a3);
// int __usercall sub_1004A659<eax>(int a1<ebp>, int a2, int a3, int a4);
double sub_1004A7AC(void); // weak
int __thiscall sub_1004A7FB(int this, int a2, int a3, int a4);
int __thiscall sub_1004A842(int this, char a2);
int __thiscall sub_1004A869(int this);
int __thiscall sub_1004A871(int this);
int __thiscall sub_1004A875(int this);
int __thiscall sub_1004A87C(int this, int a2);
int __thiscall sub_1004A8E1(int this);
int __thiscall sub_1004A8F9(int this);
int __thiscall sub_1004A906(int this);
int __thiscall sub_1004A913(int this, int a2, int a3, int a4);
bool __thiscall sub_1004A942(int this, int a2);
int __thiscall sub_1004A963(void *this);
BOOL __thiscall sub_1004A992(void *this, int a2);
int __thiscall sub_1004AA44(void *this, int a2);
char __thiscall sub_1004AAA1(int this, int a2);
BOOL __thiscall sub_1004AB87(int this, int a2);
int __thiscall sub_1004AC04(int this, int a2);
int __thiscall sub_1004AC61(void *this, int a2, __int16 a3, int a4);
char __thiscall sub_1004AC97(void *this);
int __thiscall sub_1004ACC5(int this, int a2);
void __fastcall sub_1004ACDA(int a1);
int __thiscall sub_1004AD54(int this);
int __thiscall sub_1004AD64(int this, int a2);
BOOL __thiscall sub_1004ADC6(void *this, int a2, int a3);
int __cdecl sub_1004AE68(int a1);
int __cdecl sub_1004AE85(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1004AF98(int a1, int a2, int a3);
int __cdecl sub_1004B01E(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1004B19B(int a1, int a2);
bool __cdecl sub_1004B1BF(int a1, int a2, int a3, int a4, int a5);
LPVOID __thiscall sub_1004B29B(LPVOID lpParameter, int a2, int a3);
int __thiscall sub_1004B39B(int this);
void *__thiscall sub_1004B3BF(int this, char a2);
BOOL __thiscall sub_1004B3DE(int this);
int __thiscall sub_1004B3EF(int this);
BOOL __thiscall sub_1004B3F3(int this);
BOOL __thiscall sub_1004B3FD(int this, int nPriority);
char __thiscall sub_1004B447(int this);
int __thiscall sub_1004B472(int this);
int __stdcall sub_1004B48C(int a1);
// void __usercall sub_1004B4C4(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5, const CHAR *lpWideCharStr, signed int nNumberOfBytesToRead);
// signed int __usercall sub_1004B5CC<eax>(int a1<ebx>, unsigned int a2, const CHAR *lpWideCharStr, signed int nNumberOfBytesToRead);
// void __usercall sub_1004BD5B(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
// signed int __usercall sub_1004BDE7<eax>(int a1<ebx>, signed int a2);
// signed int __usercall sub_1004BE6D<eax>(int a1<ebx>, int a2<edi>, signed int a3);
void __cdecl sub_1004BED4(signed int a1);
signed __int16 __thiscall sub_1004BEFA(DWORD this, __int16 Buffer);
// signed int __usercall sub_1004BF3B<eax>(int a1<ebx>, int a2);
// void __usercall sub_1004BFA7(int a1<edx>, int a2<ebx>, unsigned int a3);
// int __usercall sub_1004C01E<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, unsigned int a5, int a6);
// int __usercall sub_1004C1FA<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, unsigned int a5);
// signed int __usercall sub_1004C212<eax>(int a1<ebx>, int a2<edi>, unsigned int a3, int a4, unsigned int a5, unsigned int a6);
// signed int __userpurge sub_1004C23B<eax>(int a1<ebx>, int a2<edi>, unsigned int a3, int a4, unsigned int a5, unsigned int a6, int a7);
// int __usercall sub_1004C32E<eax>(int a1<ebx>, int a2<edi>, int a3);
int __cdecl sub_1004C342(int a1, unsigned __int16 a2);
// signed int __usercall sub_1004C3F0<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
// signed int __usercall sub_1004C4A4<eax>(int a1<edi>, int a2, int a3, int a4, int a5);
signed int __cdecl sub_1004C59B(int a1, int a2);
signed int __cdecl sub_1004CB0B(int a1, int a2);
signed int __cdecl sub_1004D07B(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
signed int __cdecl sub_1004D7F7(__int64 a1, __int16 a2, int a3, char a4, int a5);
signed int __cdecl sub_1004E1BB(int a1);
int __cdecl sub_1004E264(int a1, int a2);
signed int __cdecl sub_1004E564(int a1);
int __cdecl sub_1004E5FB();
// void __usercall sub_1004E610(int a1<ebx>, __int64 a2<st0>);
// double __usercall sub_1004E62E<st0>(int a1<ebx>, __int64 a2);
// double __usercall sub_1004E8E1<st0>(int a1<ebp>, double result<st0>);
double __fastcall sub_1004EA11(char a1);
int sub_1004EA1E(void); // weak
// double __usercall sub_1004EA61<st0>(double result<st0>);
// void __usercall sub_1004EB0E(int a1<edx>, __int16 a2<cx>, __int16 a3<fpstat>, double a4<st0>, char a5, char a6, char a7);
int sub_1004EB8C(void); // weak
// double __usercall sub_1004EB93<st0>(int a1<ebp>, double result<st0>);
// int __usercall sub_1004ECDA<eax>(__int16 a1<fpstat>, char a2, char a3, char a4, double a5);
double __cdecl sub_1004ED0D(double a1);
BOOL __cdecl sub_1004ED49();
HANDLE __cdecl sub_1004ED60();
// void __usercall sub_1004ED7F(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// signed int __usercall sub_1004EE49<eax>(int a1<ebx>, int a2);
// int __usercall sub_1004EEE3<eax>(int a1<ebx>, int a2);
int __cdecl sub_1004EF13(unsigned __int16 a1);
int __cdecl sub_1004F0B2(unsigned int *a1, int a2, int a3);
// int __usercall sub_1004F294<eax>(int a1<ebx>, int a2, int a3, int a4, signed int a5);
int __cdecl sub_1004F57C(double); // idb
signed int __cdecl sub_1004F5E2(long double a1, double a2, int a3);
double __cdecl sub_1004F718(double a1);
// BOOL __stdcall IsProcessorFeaturePresent(DWORD ProcessorFeature);
// void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
int __stdcall sub_1004F7A0(unsigned __int64 a1, unsigned int a2, int a3);
// double __usercall sub_1004F850<st0>(__int16 a1<cx>, int a2<ebx>, double a3);
// void __usercall sub_1004FA50(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1004FA73<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1004FA96<eax>(int a1<ebp>);
// _DWORD *__usercall sub_1004FA9E<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1004FB12();
// int __usercall sub_1004FB1A<eax>(int a1<ebp>);
int __thiscall sub_1004FB24(void *this);
// int __usercall sub_1004FB32<eax>(int a1<ebp>);
// void __usercall sub_1004FB4B(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1004FB6E<eax>(int a1<ebp>);
// void __usercall sub_1004FB78(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1004FB80<eax>(int a1<ebp>);
// void __usercall sub_1004FBB4(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// void __usercall sub_1004FBD7(int a1<ebp>);
int __thiscall sub_1004FBFA(void *this);
int __thiscall sub_1004FC27(void *this);
int __thiscall sub_1004FC50(void *this);
int __thiscall sub_1004FC61(void *this);
// int __usercall sub_1004FC8D<eax>(int a1<ebp>);
void __cdecl sub_1004FCB3();
// void __usercall sub_1004FCD6(int a1<ebx>, int a2<ebp>);
void __cdecl sub_1004FCDE();
void __cdecl sub_1004FD0B();
// unsigned int __usercall sub_1004FD2E<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1004FD36();
// int __usercall sub_1004FD5F<eax>(int a1<ebp>);
// int __usercall sub_1004FD85<eax>(int a1<ebp>);
// void __usercall sub_1004FDAB(int a1<ebp>);
int __cdecl sub_1004FDCE();
// void __usercall sub_1004FDF1(int a1<ebx>, int a2<ebp>);
int __thiscall sub_1004FE1E(void *this);
// void __usercall sub_1004FE84(int a1<ebp>);
// int __usercall sub_1004FE8C<eax>(int a1<ebp>);
// int __usercall sub_1004FE9A<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1004FEC3();
// int __usercall sub_1004FEE6<eax>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1004FF09<eax>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1004FF11<eax>(int a1<ebp>);
// int __usercall sub_1004FF34<eax>(int a1<ebp>);
// void __usercall sub_1004FF57(int a1<ebp>);
// int __usercall sub_1004FF5F<eax>(LPVOID *this<ecx>, int a2<ebp>);
// int __usercall sub_1004FF6A<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1004FF75<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1004FF80<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1004FF8B<eax>(int a1<ebp>);
// int __usercall sub_1004FF96<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// int __usercall sub_1004FFA1<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// void __usercall sub_1004FFAF(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
void __cdecl sub_1004FFBD();
void __cdecl sub_1004FFCB();
void __cdecl sub_1004FFF4();
// int __usercall sub_1004FFFC<eax>(LPVOID *this<ecx>, int a2<ebp>);
// int __usercall sub_10050007<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10050012<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005001D<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10050028();
// int __usercall sub_10050033<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// int __usercall sub_1005003E<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// void __usercall sub_1005004C(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
void __cdecl sub_1005005A();
void __cdecl sub_10050068();
// int __usercall sub_10050091<eax>(int a1<ebp>);
void __cdecl sub_100500C5();
// int __usercall sub_100500CD<eax>(LPVOID *this<ecx>, int a2<ebp>);
// int __usercall sub_1005010B<eax>(int a1<ebp>);
void __cdecl sub_10050115();
// int __usercall sub_1005011D<eax>(int a1<ebp>);
// int __usercall sub_10050127<eax>(int a1<ebp>);
// int __usercall sub_1005014C<eax>(int a1<ebp>);
// int __usercall sub_10050156<eax>(int a1<ebp>);
// void __usercall sub_10050196(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
// int __usercall sub_100501A1<eax>(int a1<ebp>);
// void __usercall sub_100501C7(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
// int __usercall sub_100501D2<eax>(int a1<ebp>);
// int __usercall sub_100501F8<eax>(int a1<ebp>);
// int __usercall sub_10050227<eax>(LPVOID *this<ecx>, int a2<ebp>);
// int __usercall sub_1005022F<eax>(int a1<ebp>);
void __cdecl sub_10050254();
// int __usercall sub_1005025C<eax>(int a1<ebp>);
// int __usercall sub_10050266<eax>(int a1<ebp>);
void __cdecl sub_1005028B();
// void __usercall sub_100502AE(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
void __cdecl sub_100502D1();
// int __usercall sub_1005030F<eax>(int a1<ebp>);
// int __usercall sub_10050342<eax>(int a1<ebp>);
// int __usercall sub_10050365<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005036D<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10050393();
void __cdecl sub_100503B6();
void __cdecl sub_100503D9();
// int __usercall sub_100503E4<eax>(int a1<ebp>);
// void __usercall sub_10050409(int a1<ebp>);
void __cdecl sub_1005042C();
void __cdecl sub_10050437();
// int __usercall sub_1005043F<eax>(int a1<ebp>);
// int __usercall sub_1005044A<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// int __usercall sub_10050455<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
void __cdecl sub_1005047E();
void __cdecl sub_100504A4();
// int __usercall sub_100504CA<eax>(int a1<ebp>);
// int __usercall sub_1005050A<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10050515();
void __cdecl sub_1005053E();
void __cdecl sub_10050549();
// int __usercall sub_1005056F<eax>(void *this<ecx>, int a2<ebp>);
int __cdecl sub_10050595();
// int __usercall sub_100505B8<eax>(LPVOID *this<ecx>, int a2<ebp>);
// int __usercall sub_100505EC<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// int __usercall sub_100505F7<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// int __usercall sub_1005061D<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// int __usercall sub_10050643<eax>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10050666<eax>(void *this<ecx>, int a2<ebp>);
// void __usercall sub_10050689(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
// int __usercall sub_10050694<eax>(int a1<ebp>);
// void __usercall sub_100506B9(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
void __cdecl sub_100506DF();
// int __usercall sub_10050702<eax>(int a1<ebp>);
void __cdecl sub_10050727();
void __cdecl sub_1005074A();
// void __usercall sub_1005076D(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
// void __usercall sub_10050793(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
// int __usercall sub_100507B9<eax>(int a1<ebp>);
// int __usercall sub_100507DE<eax>(int a1<ebp>);
void __cdecl sub_10050810();
void __cdecl sub_10050840();
int __cdecl sub_10050870(int, int); // weak
// int __usercall sub_10050890<eax>(int a1<ebp>);
// int __usercall sub_100508D0<eax>(int a1<ebp>);
// int __usercall sub_10050920<eax>(int a1<ebp>);
// int __usercall sub_10050950<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10050990();
void __cdecl sub_10050998();
int __thiscall sub_100509C0(void *this);
void __cdecl sub_100509D1();
void __cdecl sub_10050A20();
// void __usercall sub_10050A70(int a1<ebx>, int a2<ebp>);
// void __usercall sub_10050AD0(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10050B00<eax>(int a1<ebp>);
// char __usercall sub_10050B30<al>(int a1<ebp>);
// int __usercall sub_10050B4C<eax>(int a1<ebp>);
// void __usercall sub_10050B57(int a1<ebp>);
// int __usercall sub_10050B80<eax>(int a1<ebp>);
// int __usercall sub_10050BB0<eax>(int a1<ebp>);
// int __usercall sub_10050BBB<eax>(int a1<ebp>);
// void __usercall sub_10050BF0(void *this<ecx>, int a2<ebp>);
// void __usercall sub_10050BF8(int a1<ebx>, int a2<ebp>);
void __cdecl sub_10050C03();
void __cdecl sub_10050C0E();
void __cdecl sub_10050C19();
void __cdecl sub_10050C24();
void __cdecl sub_10050C2F();
// int __usercall sub_10050C60<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10050C90<eax>(int a1<ebp>);
void __cdecl sub_10050CC0();
void __cdecl sub_10050CF0();
void __cdecl sub_10050CF8();
// void __usercall sub_10050D00(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10050D30<eax>(int a1<ebp>);
// int __usercall sub_10050D3B<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_10050D43();
void __cdecl sub_10050D4B();
// void __usercall sub_10050D53(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_10050D5B();
void __cdecl sub_10050D90();
void __cdecl sub_10050DC0();
// void __usercall sub_10050DF0(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10050DF8<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_10050E00(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10050E08<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10050E40<eax>(int a1<ebp>);
// int __usercall sub_10050E70<eax>(int a1<ebp>);
// int __usercall sub_10050EA0<eax>(int a1<ebp>);
// void __usercall sub_10050EAB(void *this<ecx>, int a2<ebx>, int a3<ebp>);
// void __usercall sub_10050EC4(int a1<ebp>);
// void __usercall sub_10050F10(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10050F18<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_10050F20(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10050F28<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10050F80<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10050F88<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10050FB0<eax>(int a1<ebp>);
// int __usercall sub_10050FE0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051020<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051028<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051030<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051038<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10051070<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10051078<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051080<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051088<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051090<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10051098<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_100510C0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_100510C8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10051100<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051108<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051110<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051140<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051148<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_10051170(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10051178<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_100511B0();
// int __usercall sub_10051220<eax>(int a1<ebp>);
void __cdecl sub_10051250();
// int __usercall sub_10051258<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_10051280(void *this<ecx>, int a2<ebp>);
// int __usercall sub_100512B0<eax>(int this<ecx>, int a2<ebp>);
int __thiscall sub_100512E0(void *this);
// int __usercall sub_10051310<eax>(int a1<ebp>);
// int __usercall sub_1005131B<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10051323<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051350<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051358<eax>(int a1<ebp>);
// int __usercall sub_10051363<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005136B<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051373<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005137B<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_100513B0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_100513B8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_100513C0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_100513C8<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051420<eax>(int a1<ebp>);
// int __usercall sub_1005142B<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_10051433();
void __cdecl sub_1005143B();
// void __usercall sub_10051443(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005144B();
// int __usercall sub_10051480<eax>(int a1<ebp>);
// int __usercall sub_100514B0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_100514BB<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_100514C6<eax>(int this<ecx>, int a2<ebp>);
// char __usercall sub_100514CE<al>(int a1<ebp>);
// int __usercall sub_100514D9<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051510<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005151B<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051523<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005152B<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051533<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005153B<eax>(int a1<ebp>);
// int __usercall sub_10051546<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_10051580(int a1<ebp>);
// void __usercall sub_100515B0(void *this<ecx>, int a2<ebp>);
// void __usercall sub_100515B8(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10051630<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051638<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051670<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_100516B0<eax>(int a1<ebp>);
// int __usercall sub_100516E0<eax>(int this<ecx>, int a2<ebp>);
// LPVOID __usercall sub_100516F9<eax>(LPVOID *this<ecx>, int a2<ebp>);
// void __usercall sub_10051701(void *this<ecx>, int a2<ebp>);
// void __usercall sub_10051709(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10051730<eax>(int this<ecx>, int a2<ebp>);
// LPVOID __usercall sub_10051749<eax>(LPVOID *this<ecx>, int a2<ebp>);
// void __usercall sub_10051751(void *this<ecx>, int a2<ebp>);
// void __usercall sub_10051759(void *this<ecx>, int a2<ebp>);
void __cdecl sub_10051780();
void __cdecl sub_10051788();
// LPVOID __usercall sub_10051793<eax>(LPVOID *this<ecx>, int a2<ebp>);
// LPVOID __usercall sub_100517C0<eax>(LPVOID *this<ecx>, int a2<ebp>);
// LPVOID __usercall sub_100517C8<eax>(int a1<ebp>);
// int __usercall sub_100517F0<eax>(int a1<ebp>);
// int __usercall sub_10051820<eax>(int a1<ebp>);
// void __usercall sub_10051860(void *this<ecx>, int a2<ebp>);
// void __usercall sub_10051868(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10051890<eax>(int a1<ebp>);
void __cdecl sub_10051898();
void __cdecl sub_100518A3();
// int __usercall sub_100518AE<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_100518E0(void *this<ecx>, int a2<ebp>);
// void __usercall sub_10051910(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10051940<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_10051970(void *this<ecx>, int a2<ebp>);
// void __usercall sub_10051978(void *this<ecx>, int a2<ebp>);
// void __usercall sub_100519E0(void *this<ecx>, int a2<ebp>);
void __cdecl sub_10051A10();
void __cdecl sub_10051A18();
void __cdecl sub_10051A20();
void __cdecl sub_10051A28();
// int __usercall sub_10051A60<eax>(int a1<ebp>);
// int __usercall sub_10051A68<eax>(int a1<ebp>);
void __cdecl sub_10051A70();
void __cdecl sub_10051A78();
void __cdecl sub_10051AB0();
void __cdecl sub_10051AB8();
// int __usercall sub_10051AF0<eax>(int a1<ebp>);
// int __usercall sub_10051AFB<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_10051B30(void *this<ecx>, int a2<ebp>);
void __cdecl sub_10051B60();
// int __usercall sub_10051B90<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051BC0<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_10051C00(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10051C30<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_10051C70(void *this<ecx>, int a2<ebp>);
void __cdecl sub_10051CA0();
int __thiscall sub_10051CA8(void *this);
// int __usercall sub_10051CBC<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10051CE0<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10051CE8();
void __cdecl sub_10051CF0();
// int __usercall sub_10051CF8<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_10051D00();
// int __usercall sub_10051D08<eax>(int a1<ebp>);
void __cdecl sub_10051D13();
// int __usercall sub_10051D40<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_10051D48();
void __cdecl sub_10051D50();
void __cdecl sub_10051D80();
// int __usercall sub_10051DB0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_10051DB8();
// int __usercall sub_10051DC0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10051DC8<eax>(int a1<ebp>);
// int __usercall sub_10051E00<eax>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10051E08<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_10051E10();
// int __usercall sub_10051E18<eax>(int a1<ebp>);
void __cdecl sub_10051E23();
// int __usercall sub_10051E2B<eax>(int a1<ebp>);
void __cdecl sub_10051E60();
int __cdecl sub_10051E68(int, int); // weak
void __cdecl sub_10051E90();
int __thiscall sub_10051EC0(void *this);
// void __usercall sub_10051ED1(int a1<ebp>);
void __cdecl sub_10051ED9();
void __cdecl sub_10051F00();
// int __usercall sub_10051F08<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10051F10();
void __cdecl sub_10051F60();
void __cdecl sub_10051F68();
// int __usercall sub_10051FA0<eax>(int a1<ebp>);
// int __usercall sub_10051FE0<eax>(int a1<ebp>);
// int *__usercall sub_10052020<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10052028();
void __cdecl sub_10052030();
// int __usercall sub_1005203B<eax>(int a1<ebp>);
// int __usercall sub_10052043<eax>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10052080<eax>(int a1<ebp>);
// int __usercall sub_100520B0<eax>(int a1<ebp>);
// int __usercall sub_100520BB<eax>(int a1<ebp>);
// int __usercall sub_100520F0<eax>(int a1<ebp>);
// void __usercall sub_100520FB(int a1<ebp>);
int __thiscall sub_10052103(void *this);
// int __usercall sub_10052117<eax>(int a1<ebp>);
// int __usercall sub_10052150<eax>(int a1<ebp>);
// int __usercall sub_1005215B<eax>(int a1<ebp>);
// int __usercall sub_10052190<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>);
// int __usercall sub_10052198<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>);
// int __usercall sub_100521A0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_100521AB<eax>(int a1<ebp>);
void __cdecl sub_100521E0();
void __cdecl sub_10052210();
int __thiscall sub_10052218(void *this);
// int __usercall sub_1005222C<eax>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10052234<eax>(int a1<ebp>);
// void __usercall sub_10052260(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_10052290();
void __cdecl sub_10052298();
// void __usercall sub_100522A3(void *a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_100522AE<eax>(int a1<ebp>);
// void __usercall sub_100522E0(int a1<ebp>);
// int __usercall sub_100522E8<eax>(void *this<ecx>, int a2<ebp>);
// void __usercall sub_100522F3(void *a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052320<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10052328<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10052333<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005233E<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10052349();
void __cdecl sub_10052357();
void __cdecl sub_10052365();
// int __usercall sub_1005236D<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10052375<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005237D();
// int __usercall sub_10052385<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10052393<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_100523A1();
void __cdecl sub_100523AF();
// int __usercall sub_100523E0<eax>(int a1<ebp>);
// int __usercall sub_100523EB<eax>(int a1<ebp>);
void __cdecl sub_100523F6();
void __cdecl sub_10052420();
// int __usercall sub_10052450<eax>(int a1<ebp>);
// int __usercall sub_10052458<eax>(int a1<ebp>);
void __cdecl sub_10052480();
void __cdecl sub_100524B0();
// int __usercall sub_100524B8<eax>(int a1<ebp>);
// int __usercall sub_100524C3<eax>(int a1<ebp>);
void __cdecl sub_100524CE();
// int __usercall sub_10052500<eax>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10052508<eax>(int a1<ebp>);
// int __usercall sub_10052513<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005251E();
int __cdecl sub_10052529(int, int); // weak
// int __usercall sub_10052550<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10052558<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052590<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052598<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_100525D0(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_10052600();
// void __usercall sub_10052630(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005263B<eax>(int a1<ebp>);
// int __usercall sub_10052646<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10052651<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005265C<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10052690();
void __cdecl sub_10052698();
// void __usercall sub_100526A3(void *a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_100526AE<eax>(int a1<ebp>);
// int __usercall sub_100526E0<eax>(int a1<ebp>);
void __cdecl sub_100526E8();
void __cdecl sub_10052710();
// int __usercall sub_10052718<eax>(void *this<ecx>, int a2<ebp>);
// void __usercall sub_10052723(void *a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005272E<eax>(int a1<ebp>);
void __cdecl sub_10052736();
// void __usercall sub_10052760(int this<ecx>, int a2<ebp>);
// void __usercall sub_10052768(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>);
// int __usercall sub_10052790<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10052798<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_100527A3<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_100527AE<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_100527B9<eax>(int a1<ebp>);
void __cdecl sub_100527C7();
// int __usercall sub_100527D5<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_100527E3<eax>(int a1<ebp>);
void __cdecl sub_100527F1();
// int __usercall sub_100527FF<eax>(int a1<ebp>);
// int __usercall sub_10052830<eax>(int a1<ebp>);
// int __usercall sub_1005283B<eax>(int a1<ebp>);
void __cdecl sub_10052846();
// int __usercall sub_10052851<eax>(int a1<ebp>);
// int __usercall sub_10052880<eax>(int a1<ebp>);
// void __usercall sub_1005288B(int this<ecx>, int a2<ebp>);
// void __usercall sub_10052893(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>);
void __cdecl sub_100528C0();
void __cdecl sub_100528F0();
// int __usercall sub_100528F8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052900<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052908<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052910<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052918<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10052923<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005292E<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052936<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10052941<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005294C<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10052957<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10052962<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005296D<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_100529A0();
void __cdecl sub_100529D0();
void __cdecl sub_10052A00();
void __cdecl sub_10052A30();
void __cdecl sub_10052A38();
int __cdecl sub_10052A40(int, int); // weak
void __cdecl sub_10052A70();
void __cdecl sub_10052A78();
void __cdecl sub_10052AB0();
void __cdecl sub_10052AB8();
void __cdecl sub_10052AF0();
void __cdecl sub_10052AF8();
int __cdecl sub_10052B00(int, int); // weak
void __cdecl sub_10052B30();
void __cdecl sub_10052B38();
void __cdecl sub_10052B70();
void __cdecl sub_10052B78();
// int __usercall sub_10052BB0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>);
// void __usercall sub_10052BE0(int a1<ebp>);
// int __usercall sub_10052C10<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10052C40<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_10052C48();
// int __usercall sub_10052C50<eax>(int a1<ebp>);
// int __usercall sub_10052C90<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10052C98<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10052CA0<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10052CA8();
void __cdecl sub_10052CE0();
void __cdecl sub_10052D10();
// int __usercall sub_10052D40<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10052D4B<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052D56<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052D61<eax>(int a1<ebp>);
// int __usercall sub_10052DA0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052DA8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052DB0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052DB8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052DC0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052DC8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052DD0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052DD8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052DE0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052DE8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052DF0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10052DF8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_10052E00();
// int __usercall sub_10052E08<eax>(int a1<ebp>);
void __cdecl sub_10052E50();
void __cdecl sub_10052E58();
void __cdecl sub_10052E90();
void __cdecl sub_10052EC0();
void __cdecl sub_10052EC8();
// int __usercall sub_10052ED0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10052F00<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_10052F08();
void __cdecl sub_10052F40();
void __cdecl sub_10052F48();
void __cdecl sub_10052F70();
void __cdecl sub_10052F78();
void __cdecl sub_10052F80();
// int __usercall sub_10052F88<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10052F90();
void __cdecl sub_10052FC0();
void __cdecl sub_10052FC8();
void __cdecl sub_10052FD0();
// int __usercall sub_10052FD8<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10052FE0();
void __cdecl sub_10053010();
// int __usercall sub_10053018<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10053020();
int __thiscall sub_10053050(void *this);
void __cdecl sub_10053061();
void __cdecl sub_10053069();
int __cdecl sub_10053090(int, int); // weak
// int __usercall sub_100530B0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_100530B8();
void __cdecl sub_100530F0();
// int __usercall sub_10053120<eax>(int a1<ebp>);
// int __usercall sub_10053150<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10053158();
// int __usercall sub_10053180<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_100531B0();
void __cdecl sub_100531E0();
void __cdecl sub_10053210();
void __cdecl sub_10053218();
void __cdecl sub_10053220();
void __cdecl sub_10053250();
// int __usercall sub_10053258<eax>(int a1<ebp>);
// int __usercall sub_10053263<eax>(int a1<ebp>);
void __cdecl sub_10053290();
void __cdecl sub_100532C0();
// void __usercall sub_100532F0(void *this<ecx>, int a2<ebp>);
void __cdecl sub_10053320();
void __cdecl sub_10053328();
// int __usercall sub_10053350<eax>(int a1<ebp>);
// int __usercall sub_10053380<eax>(int a1<ebp>);
// void __usercall sub_1005338B(void *this<ecx>, int a2<ebp>);
void __cdecl sub_100533C0();
// void __usercall sub_100533F0(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10053420<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10053428();
// int __usercall sub_10053430<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10053460();
// int __usercall sub_10053468<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10053490();
// int __usercall sub_10053498<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_100534C0(void *this<ecx>, int a2<ebp>);
// void __usercall sub_100534F0(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10053520<eax>(int a1<ebp>);
// void __usercall sub_10053550(void *this<ecx>, int a2<ebp>);
// void __usercall sub_10053580(void *this<ecx>, int a2<ebp>);
void __cdecl sub_100535B0();
// int __usercall sub_100535E0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_100535E8<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_100535F0();
// int __usercall sub_100535F8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_10053600();
void __cdecl sub_10053630();
void __cdecl sub_10053638();
// int __usercall sub_10053660<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10053668();
// void __usercall sub_100536A0(void *this<ecx>, int a2<ebp>);
void __cdecl sub_100536D0();
// int __usercall sub_10053700<eax>(int a1<ebp>);
// int __usercall sub_10053730<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10053760<eax>(int a1<ebp>);
// int __usercall sub_1005376B<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_100537A0();
void __cdecl sub_100537A8();
// int __usercall sub_100537E0<eax>(int a1<ebp>);
// int __usercall sub_100537E8<eax>(int a1<ebp>);
// int __usercall sub_100537F0<eax>(int a1<ebp>);
// int __usercall sub_100537FB<eax>(int a1<ebp>);
// int __usercall sub_10053803<eax>(int a1<ebp>);
// int __usercall sub_1005380B<eax>(int a1<ebp>);
// int __usercall sub_10053850<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10053890();
// int __usercall sub_100538C0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_100538F0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
// int __usercall sub_10053910<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_10053920<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_10053930<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_10053940<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_10053960<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_10053980<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_100539A0<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_100539C0<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_100539E0<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_10053A00<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_10053A47<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_10053A53<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_10053A5F<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_10053A75<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_10053A81<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_10053A97<eax>(int a1<ebx>, int a2<edi>);
void **__cdecl sub_10053AAF();
unsigned int __cdecl sub_10053ABD();
void __cdecl sub_10053AC8();
void __cdecl sub_10053AD3();
void __cdecl sub_10053ADE();
void __cdecl sub_10053AE9();
void __cdecl sub_10053AF4();
int sub_10053B00(); // weak
void __cdecl sub_10053B10();
int sub_10053B20(); // weak
int sub_10053B30(); // weak
int sub_10053B40(); // weak
int __cdecl sub_10053B50();
int __cdecl sub_10053BB0();
int __cdecl sub_10053C10();
int __cdecl sub_10053C70();
int __cdecl sub_10053CD0();
int __cdecl sub_10053D30();
int sub_10053D80(); // weak
int sub_10053D8A(); // weak
int sub_10053D94(); // weak
int sub_10053D9E(); // weak
int sub_10053DA8(); // weak
int sub_10053DB2(); // weak
// HANDLE __stdcall CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// BOOL __stdcall WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// BOOL __stdcall ReadConsoleW(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable);
// BOOL __stdcall FlushFileBuffers(HANDLE hFile);
// BOOL __stdcall SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// int __stdcall GetThreadPriority(HANDLE hThread);
// DWORD __stdcall FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments);
// DWORD __stdcall GetLastError();
// HGLOBAL __stdcall GlobalFree(HGLOBAL hMem);
// HLOCAL __stdcall LocalFree(HLOCAL hMem);
// LONG __stdcall InterlockedIncrement(volatile LONG *lpAddend);
// LONG __stdcall InterlockedDecrement(volatile LONG *lpAddend);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);
// PVOID __stdcall EncodePointer(PVOID Ptr);
// PVOID __stdcall DecodePointer(PVOID Ptr);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall Sleep(DWORD dwMilliseconds);
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// BOOL __stdcall GetStringTypeW(DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
// void __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments);
// BOOL __stdcall InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);
// DWORD __stdcall GetCurrentThreadId();
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// BOOL __stdcall CreateTimerQueueTimer(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags);
// HANDLE __stdcall CreateTimerQueue();
// PSINGLE_LIST_ENTRY __stdcall InterlockedPopEntrySList(PSLIST_HEADER ListHead);
// PSINGLE_LIST_ENTRY __stdcall InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSINGLE_LIST_ENTRY ListEntry);
// PSINGLE_LIST_ENTRY __stdcall InterlockedFlushSList(PSLIST_HEADER ListHead);
// USHORT __stdcall QueryDepthSList(PSLIST_HEADER ListHead);
// BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);
// BOOL __stdcall IsDebuggerPresent();
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// void __stdcall SetLastError(DWORD dwErrCode);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// HMODULE __stdcall LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// HMODULE __stdcall LoadLibraryW(LPCWSTR lpLibFileName);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
// BOOL __stdcall SetEvent(HANDLE hEvent);
// BOOL __stdcall ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// HANDLE __stdcall CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
// void __stdcall InitializeSListHead(PSLIST_HEADER ListHead);
// HANDLE __stdcall GetCurrentProcess();
// BOOL __stdcall SwitchToThread();
// DWORD __stdcall TlsAlloc();
// BOOL __stdcall TlsFree(DWORD dwTlsIndex);
// DWORD __stdcall GetTickCount();
// BOOL __stdcall UnregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent);
// BOOL __stdcall ChangeTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period);
// BOOL __stdcall GetNumaHighestNodeNumber(PULONG HighestNodeNumber);
// BOOL __stdcall RegisterWaitForSingleObject(PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags);
// void __stdcall OutputDebugStringW(LPCWSTR lpOutputString);
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// HANDLE __stdcall GetCurrentThread();
// BOOL __stdcall GetThreadTimes(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// void __stdcall FreeLibraryAndExitThread(HMODULE hLibModule, DWORD dwExitCode);
// DWORD __stdcall GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// LPSTR __stdcall GetCommandLineA();
// void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
// BOOL __stdcall GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo);
// LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// void __stdcall GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo);
// HMODULE __stdcall GetModuleHandleW(LPCWSTR lpModuleName);
// HANDLE __stdcall CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName);
// int __stdcall CompareStringW(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2);
// int __stdcall LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
// int __stdcall GetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData);
// BOOL __stdcall IsValidLocale(LCID Locale, DWORD dwFlags);
// LCID __stdcall GetUserDefaultLCID();
// BOOL __stdcall EnumSystemLocalesW(LOCALE_ENUMPROCW lpLocaleEnumProc, DWORD dwFlags);
// void __stdcall ExitProcess(UINT uExitCode);
// BOOL __stdcall GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule);
// SIZE_T __stdcall HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
// HANDLE __stdcall GetStdHandle(DWORD nStdHandle);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall DeleteTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent);
// BOOL __stdcall GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask);
// DWORD_PTR __stdcall SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask);
// BOOL __stdcall SetThreadPriority(HANDLE hThread, int nPriority);
// BOOL __stdcall GetVersionExW(LPOSVERSIONINFOW lpVersionInformation);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// HANDLE __stdcall GetProcessHeap();
// BOOL __stdcall UnregisterWait(HANDLE WaitHandle);
// DWORD __stdcall GetFileType(HANDLE hFile);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
// DWORD __stdcall GetCurrentProcessId();
// LPWCH __stdcall GetEnvironmentStringsW();
// BOOL __stdcall FreeEnvironmentStringsW(LPWCH);
// UINT __stdcall GetACP();
// BOOL __stdcall IsValidCodePage(UINT CodePage);
// UINT __stdcall GetOEMCP();
// BOOL __stdcall WinHttpReadData(HINTERNET hRequest, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead);
// BOOL __stdcall WinHttpCrackUrl(LPCWSTR pwszUrl, DWORD dwUrlLength, DWORD dwFlags, LPURL_COMPONENTS lpUrlComponents);
// HINTERNET __stdcall WinHttpOpenRequest(HINTERNET hConnect, LPCWSTR pwszVerb, LPCWSTR pwszObjectName, LPCWSTR pwszVersion, LPCWSTR pwszReferrer, LPCWSTR *ppwszAcceptTypes, DWORD dwFlags);
// HINTERNET __stdcall WinHttpOpen(LPCWSTR pszAgentW, DWORD dwAccessType, LPCWSTR pszProxyW, LPCWSTR pszProxyBypassW, DWORD dwFlags);
// BOOL __stdcall WinHttpQueryDataAvailable(HINTERNET hRequest, LPDWORD lpdwNumberOfBytesAvailable);
// WINHTTP_STATUS_CALLBACK __stdcall WinHttpSetStatusCallback(HINTERNET hInternet, WINHTTP_STATUS_CALLBACK lpfnInternetCallback, DWORD dwNotificationFlags, DWORD_PTR dwReserved);
// BOOL __stdcall WinHttpQueryHeaders(HINTERNET hRequest, DWORD dwInfoLevel, LPCWSTR pwszName, LPVOID lpBuffer, LPDWORD lpdwBufferLength, LPDWORD lpdwIndex);
// BOOL __stdcall WinHttpCloseHandle(HINTERNET hInternet);
// BOOL __stdcall WinHttpSendRequest(HINTERNET hRequest, LPCWSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength, DWORD dwTotalLength, DWORD_PTR dwContext);
// BOOL __stdcall WinHttpGetIEProxyConfigForCurrentUser(WINHTTP_CURRENT_USER_IE_PROXY_CONFIG *pProxyConfig);
// BOOL __stdcall WinHttpReceiveResponse(HINTERNET hRequest, LPVOID lpReserved);


//----- (10001010) --------------------------------------------------------
int __cdecl sub_10001010(int a1)
{
  int ebp0; // ebp@0

  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  sub_10023491(a1);
  sub_100234A4(ebp0);
  return a1;
}

//----- (10001090) --------------------------------------------------------
int __cdecl sub_10001090(int a1)
{
  sub_10001010(a1);
  return a1;
}

//----- (100010C0) --------------------------------------------------------
void *__thiscall sub_100010C0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_1005431C;
  if ( a2 & 1 )
    sub_1002404A(this);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005431C: using guessed type int (__stdcall *off_1005431C)(char);

//----- (100010F0) --------------------------------------------------------
int __thiscall sub_100010F0(void *this, int a2, int a3)
{
  int result; // eax@1

  result = a2;
  *(_DWORD *)a2 = a3;
  *(_DWORD *)(a2 + 4) = this;
  return result;
}

//----- (10001110) --------------------------------------------------------
char __thiscall sub_10001110(void *this, int a2, int a3)
{
  int v3; // eax@1
  char v5; // [sp+0h] [bp-8h]@1

  v3 = (*(int (__stdcall **)(char *, int))(*(_DWORD *)this + 12))(&v5, a2);
  return *(_DWORD *)(v3 + 4) == *(_DWORD *)(a3 + 4) && *(_DWORD *)v3 == *(_DWORD *)a3;
}

//----- (10001150) --------------------------------------------------------
char __thiscall sub_10001150(void *this, int a2, int a3)
{
  return this == *(void **)(a2 + 4) && *(_DWORD *)a2 == a3;
}

//----- (10001170) --------------------------------------------------------
int __cdecl sub_10001170()
{
  return (int)"generic";
}

//----- (10001180) --------------------------------------------------------
int __stdcall sub_10001180(int a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edx@1
  int result; // eax@4

  v2 = sub_10021C9C(a2);
  v3 = "unknown error";
  if ( v2 )
    v3 = (const char *)v2;
  *(_DWORD *)(a1 + 20) = 15;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)a1 = 0;
  if ( *v3 )
  {
    loc_10001BD0(a1, v3, strlen(v3));
    result = a1;
  }
  else
  {
    loc_10001BD0(a1, v3, 0);
    result = a1;
  }
  return result;
}

//----- (100011F0) --------------------------------------------------------
int __cdecl sub_100011F0()
{
  return (int)"iostream";
}

//----- (10001200) --------------------------------------------------------
int __stdcall sub_10001200(int a1, int a2)
{
  int result; // eax@2

  if ( a2 == 1 )
  {
    *(_DWORD *)(a1 + 20) = 15;
    *(_DWORD *)(a1 + 16) = 0;
    *(_BYTE *)a1 = 0;
    loc_10001BD0(a1, "iostream stream error", 21);
    result = a1;
  }
  else
  {
    sub_10001180(a1, a2);
    result = a1;
  }
  return result;
}

//----- (10001250) --------------------------------------------------------
int __cdecl sub_10001250()
{
  return (int)"system";
}

//----- (10001260) --------------------------------------------------------
int __stdcall sub_10001260(int a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edx@1
  int result; // eax@4

  v2 = sub_10021CC6(a2);
  v3 = "unknown error";
  if ( v2 )
    v3 = (const char *)v2;
  *(_DWORD *)(a1 + 20) = 15;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)a1 = 0;
  if ( *v3 )
  {
    loc_10001BD0(a1, v3, strlen(v3));
    result = a1;
  }
  else
  {
    loc_10001BD0(a1, v3, 0);
    result = a1;
  }
  return result;
}

//----- (100012D0) --------------------------------------------------------
int __stdcall sub_100012D0(int a1, int a2)
{
  int result; // eax@1
  char v3; // zf@1

  v3 = sub_10021C9C(a2) == 0;
  result = a1;
  *(_DWORD *)a1 = a2;
  if ( v3 )
    *(_DWORD *)(a1 + 4) = off_10068E24;
  else
    *(_DWORD *)(a1 + 4) = off_10068E28;
  return result;
}
// 10068E24: using guessed type int (__stdcall *off_10068E24[3])(char);
// 10068E28: using guessed type int (__stdcall *off_10068E28[2])(char);

//----- (10001320) --------------------------------------------------------
int __thiscall sub_10001320(void *this)
{
  int v1; // esi@1

  _EDX = (int)((char *)this + 4);
  _ESI = -1;
  __asm { lock xadd [edx], esi }
  v1 = _ESI - 1;
  if ( !v1 )
    (*(void (**)(void))(*(_DWORD *)this + 4))();
  return v1;
}

//----- (10001340) --------------------------------------------------------
int __thiscall sub_10001340(void *this)
{
  int result; // eax@2

  if ( this )
    result = (**(int (__stdcall ***)(_DWORD))this)(1);
  return result;
}

//----- (10001350) --------------------------------------------------------
void *__thiscall sub_10001350(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10055B10;
  if ( a2 & 1 )
    sub_1002404A(this);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10055B10: using guessed type int (__stdcall *off_10055B10)(char);

//----- (10001380) --------------------------------------------------------
int __thiscall sub_10001380(int this, int a2)
{
  *(_DWORD *)this = &off_10055B10;
  *(_DWORD *)(this + 4) = a2;
  *(_DWORD *)this = &off_10055B98;
  *(_DWORD *)(this + 8) = 3;
  *(_DWORD *)(this + 16) = 0;
  return this;
}
// 10055B10: using guessed type int (__stdcall *off_10055B10)(char);
// 10055B98: using guessed type int (__stdcall *off_10055B98)(char);

//----- (100013B0) --------------------------------------------------------
char __cdecl sub_100013B0(int a1)
{
  return a1 && a1 != 2;
}

//----- (100013E0) --------------------------------------------------------
int __thiscall sub_100013E0(int this, int a2, int a3)
{
  int ebp0; // ebp@0
  int v4; // edi@1
  int result; // eax@2
  char *v13; // esi@3

  v4 = this;
  _EAX = this + 4;
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  if ( a3 )
  {
    v13 = sub_10027C83(a3, ebp0, this);
    ++*(_DWORD *)v13;
    if ( *(_DWORD *)v13 > (unsigned int)a3 )
    {
      sub_10026854(ebp0, a2);
      result = 0;
    }
    else
    {
      result = sub_10026494(a3, ebp0, v4, v4 + 8, a2);
    }
    --*(_DWORD *)v13;
  }
  else
  {
    sub_10026854(ebp0, a2);
    result = 0;
  }
  return result;
}

//----- (10001490) --------------------------------------------------------
int __thiscall sub_10001490(void *this)
{
  int result; // eax@1
  void *v3; // esi@1

  v3 = this;
  _EDI = -1;
  _EDX = (int)((char *)this + 4);
  _EAX = -1;
  __asm { lock xadd [edx], eax }
  if ( _ZF )
  {
    (**(void (***)(void))this)();
    result = (int)((char *)v3 + 8);
    __asm { lock xadd [eax], edi }
    if ( _EDI == 1 )
      result = (*(int (__thiscall **)(void *))(*(_DWORD *)v3 + 4))(v3);
  }
  return result;
}

//----- (100014C0) --------------------------------------------------------
int __stdcall sub_100014C0(int a1)
{
  return 0;
}

//----- (100014D0) --------------------------------------------------------
void *__thiscall sub_100014D0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_100558D0;
  if ( a2 & 1 )
    sub_1002404A(this);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 100558D0: using guessed type int (*off_100558D0[2])();

//----- (10001500) --------------------------------------------------------
int __thiscall sub_10001500(void *this)
{
  int v1; // ecx@1
  void *v2; // esi@1
  int result; // eax@2

  v2 = this;
  v1 = *(_DWORD *)this;
  if ( v1 )
  {
    result = v1 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      result = (*(int (**)(void))(*(_DWORD *)v1 + 4))();
  }
  *(_DWORD *)v2 = 0;
  return result;
}

//----- (10001590) --------------------------------------------------------
int __usercall sub_10001590<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // esi@1

  v3 = a1;
  if ( !*(_DWORD *)a1 )
    sub_1002635C(a2, a3);
  return sub_100234E2(v3 + 4);
}

//----- (100015F0) --------------------------------------------------------
char __userpurge sub_100015F0<al>(int a1<ecx>, int a2<edi>, int a3)
{
  char v3; // bl@1
  int v4; // esi@1
  int v5; // esi@1
  int v6; // eax@1
  char v7; // al@1
  char v23; // [sp+10h] [bp-1Ch]@1
  int v24; // [sp+14h] [bp-18h]@1
  int v25; // [sp+18h] [bp-14h]@1
  int v26; // [sp+28h] [bp-4h]@1

  v5 = a1;
  v25 = *(_DWORD *)(a1 + 148);
  v6 = sub_10002120(a3, (int)&v23, a2, (int)&v25);
  v26 = 0;
  v7 = (*(int (__thiscall **)(int, signed int, signed int, _DWORD, int))(*(_DWORD *)v5 + 4))(v5, 1, 1, 0, v6);
  v26 = -1;
  v4 = v24;
  v3 = v7;
  if ( v24 )
  {
    _EDI = -1;
    _EDX = v24 + 4;
    _ECX = -1;
    __asm { lock xadd [edx], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v4)(v4);
      _EAX = v4 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (**)(void))(*(_DWORD *)v4 + 4))();
    }
  }
  return v3;
}

//----- (100016A0) --------------------------------------------------------
int __userpurge sub_100016A0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4, int a5)
{
  int ebp0; // ebp@0
  int v7; // esi@1
  int v8; // eax@1
  char v9; // [sp+0h] [bp-24h]@1
  int v10; // [sp+10h] [bp-14h]@1
  char *v11; // [sp+14h] [bp-10h]@1
  int v12; // [sp+20h] [bp-4h]@1

  v11 = &v9;
  v7 = a1;
  v10 = a1;
  v8 = sub_1002624C(a2, ebp0, a3);
  *(_DWORD *)(v7 + 144) = v8;
  v12 = 0;
  sub_100013E0(v8, a4, a5);
  v12 = -1;
  return sub_10025148(ebp0);
}

//----- (10001722) --------------------------------------------------------
int (__stdcall *__cdecl sub_10001722())(int, int)
{
  return loc_100016FC;
}
// 100016FC: using guessed type int __stdcall loc_100016FC(int, int);

//----- (10001730) --------------------------------------------------------
int __thiscall sub_10001730(int this)
{
  int result; // eax@1
  int v2; // ebx@1
  int v3; // esi@1
  int (__thiscall **v4)(_DWORD, _DWORD); // eax@2
  int v5; // edi@2
  int v6; // esi@7
  int v19; // [sp+14h] [bp-1Ch]@1
  int v20; // [sp+18h] [bp-18h]@2
  unsigned int v21; // [sp+1Ch] [bp-14h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+2Ch] [bp-4h]@2

  v21 = (unsigned int)&v19 ^ __security_cookie;
  result = (int)&v22;
  v2 = this;
  v3 = *(_DWORD *)(this + 132);
  *(_DWORD *)(this + 132) = 0;
  if ( v3 )
  {
    do
    {
      v4 = *(int (__thiscall ***)(_DWORD, _DWORD))v3;
      v5 = *(_DWORD *)(v3 + 20);
      v19 = 0;
      v20 = 0;
      ((int (__thiscall **)(int, int *))v4)[1](v3, &v19);
      v23 = 0;
      if ( *(_DWORD *)(v2 + 84) != 4 || *(_BYTE *)(v3 + 25) )
      {
        if ( *(_DWORD *)(v19 + 84) != 4 )
        {
          result = sub_100016A0(v19, v2, v5, v3, *(_DWORD *)(v3 + 28));
          goto LABEL_7;
        }
      }
      else
      {
        if ( *(_DWORD *)(v2 + 92) )
          (*(void (__stdcall **)(signed int, signed int, signed int, int))(*(_DWORD *)v19 + 4))(1, 1, 1, v2 + 92);
        else
          (*(void (__stdcall **)(signed int, _DWORD, _DWORD, int))(*(_DWORD *)v19 + 4))(1, 0, 0, v19 + 92);
      }
      result = (**(int (__thiscall ***)(_DWORD, _DWORD))v3)(v3, 1);
LABEL_7:
      v23 = -1;
      v6 = v20;
      if ( v20 )
      {
        _ECX = -1;
        result = v20 + 4;
        __asm { lock xadd [eax], ecx }
        if ( _ZF )
        {
          (**(void (__thiscall ***)(_DWORD))v6)(v6);
          _EDX = -1;
          result = v6 + 8;
          __asm { lock xadd [eax], edx }
          if ( _ZF )
            result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v6 + 4))(v6, _EDX);
        }
      }
      v3 = v5;
    }
    while ( v5 );
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;

//----- (100018B0) --------------------------------------------------------
void __thiscall sub_100018B0(int this, int a2)
{
  dword_1006A1AC = 0;
  dword_1006A1B0 = 0;
  dword_1006A1B4 = 0;
  dword_1006A1D8 = 0;
  dword_1006A1DC = 0;
  dword_1006A1E0 = 0;
  sub_10001940((int)&dword_1006A1F0, this);
  dword_1006A2F8 = 0;
  dword_1006A300 = 0;
  dword_1006A304 = 0;
  dword_1006A308 = 0;
  dword_1006A324 = 0;
  dword_1006A328 = 0;
}
// 1006A1AC: using guessed type int dword_1006A1AC;
// 1006A1B0: using guessed type int dword_1006A1B0;
// 1006A1B4: using guessed type int dword_1006A1B4;
// 1006A1D8: using guessed type int dword_1006A1D8;
// 1006A1DC: using guessed type int dword_1006A1DC;
// 1006A1E0: using guessed type int dword_1006A1E0;
// 1006A1F0: using guessed type int dword_1006A1F0;
// 1006A2F8: using guessed type int dword_1006A2F8;
// 1006A300: using guessed type int dword_1006A300;
// 1006A304: using guessed type int dword_1006A304;
// 1006A308: using guessed type int dword_1006A308;
// 1006A324: using guessed type int dword_1006A324;
// 1006A328: using guessed type int dword_1006A328;

//----- (10001940) --------------------------------------------------------
void __thiscall sub_10001940(int this, int a2)
{
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 68) = 0;
  *(_DWORD *)(this + 80) = 0;
  *(_DWORD *)(this + 84) = 0;
  *(_DWORD *)(this + 104) = 0;
  *(_DWORD *)(this + 144) = 0;
  *(_DWORD *)(this + 148) = 0;
  *(_DWORD *)(this + 156) = 0;
  *(_DWORD *)(this + 160) = 0;
  *(_DWORD *)(this + 192) = 0;
  *(_DWORD *)(this + 216) = 0;
  *(_DWORD *)(this + 240) = 0;
}

//----- (100019C0) --------------------------------------------------------
signed int __stdcall sub_100019C0(int a1, int a2, int a3)
{
  return 1;
}

//----- (100019D0) --------------------------------------------------------
int __thiscall sub_100019D0(int this, const char *a2)
{
  int v2; // esi@1
  int result; // eax@2

  v2 = this;
  *(_DWORD *)(this + 20) = 15;
  *(_DWORD *)(this + 16) = 0;
  *(_BYTE *)this = 0;
  if ( *a2 )
  {
    loc_10001BD0(this, a2, strlen(a2));
    result = v2;
  }
  else
  {
    loc_10001BD0(this, a2, 0);
    result = v2;
  }
  return result;
}

//----- (10001A30) --------------------------------------------------------
int __thiscall sub_10001A30(int this)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = this;
  if ( *(_DWORD *)(this + 20) >= 0x10u )
    result = sub_1002404A(*(LPVOID *)this);
  *(_DWORD *)(v1 + 20) = 15;
  *(_DWORD *)(v1 + 16) = 0;
  *(_BYTE *)v1 = 0;
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10001A60) --------------------------------------------------------
int __thiscall sub_10001A60(int this)
{
  int v1; // ecx@1
  int v2; // esi@1
  int result; // eax@2
  int v4; // ecx@3

  v2 = this;
  v1 = *(_DWORD *)(this + 16);
  if ( v1 )
  {
    result = (*(int (__stdcall **)(bool))(*(_DWORD *)v1 + 16))(v1 != v2);
    *(_DWORD *)(v2 + 16) = 0;
  }
  v4 = *(_DWORD *)(v2 + 16);
  if ( v4 )
  {
    result = (*(int (__stdcall **)(bool))(*(_DWORD *)v4 + 16))(v4 != v2);
    *(_DWORD *)(v2 + 16) = 0;
  }
  return result;
}

//----- (10001AA0) --------------------------------------------------------
int __thiscall sub_10001AA0(int this, int a2)
{
  int v2; // ebx@1
  int v3; // esi@1
  int v11; // edi@3
  int v27; // [sp+14h] [bp+8h]@1

  v3 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  v2 = *(_DWORD *)(a2 + 4);
  v27 = *(_DWORD *)a2;
  if ( v2 )
  {
    _EAX = v2 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v11 = *(_DWORD *)(v3 + 4);
  if ( v11 )
  {
    _ECX = v11 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v11)(v11);
      _EAX = v11 + 8;
      _ECX = -1;
      __asm { lock xadd [eax], ecx }
      if ( _ZF )
        (*(void (__thiscall **)(int))(*(_DWORD *)v11 + 4))(v11);
    }
  }
  *(_DWORD *)v3 = v27;
  *(_DWORD *)(v3 + 4) = v2;
  return v3;
}

//----- (10001B20) --------------------------------------------------------
int __userpurge sub_10001B20<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_1005569C;
  return v4;
}
// 1005569C: using guessed type int (__stdcall *off_1005569C)(char);

//----- (10001B40) --------------------------------------------------------
int __userpurge sub_10001B40<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  int v3; // esi@1

  v3 = a1;
  sub_100236FB(a1, a2);
  if ( a3 & 1 )
    sub_1002404A((LPVOID)v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10001BA0) --------------------------------------------------------
void *__thiscall sub_10001BA0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_1005C020;
  if ( a2 & 1 )
    sub_1002404A(this);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005C020: using guessed type int (*off_1005C020[5])();

//----- (10001CD0) --------------------------------------------------------
int __thiscall sub_10001CD0(int this, int a2)
{
  char v2; // cf@1
  int result; // eax@2

  v2 = *(_DWORD *)(this + 20) < 0x10u;
  *(_DWORD *)(this + 16) = a2;
  if ( v2 )
  {
    *(_BYTE *)(this + a2) = 0;
  }
  else
  {
    result = *(_DWORD *)this;
    *(_BYTE *)(*(_DWORD *)this + a2) = 0;
  }
  return result;
}

//----- (10001D00) --------------------------------------------------------
void *__thiscall sub_10001D00(void *this)
{
  return this;
}

//----- (10001FA0) --------------------------------------------------------
int (__cdecl *__usercall sub_10001FA0<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<ebx>, int a5<edi>, int a6<esi>, int a7, unsigned int a8))(int, int)
{
  unsigned int v8; // edi@1
  int v9; // esi@1
  unsigned int v10; // ecx@3
  int v11; // eax@6
  int v12; // ecx@6
  int (__cdecl *result)(int, int); // eax@9
  unsigned int v14; // ebx@10
  const void *v15; // ecx@12
  int v16; // [sp-10h] [bp-28h]@1
  int v17; // [sp-Ch] [bp-24h]@1
  int v18; // [sp-8h] [bp-20h]@1
  int v19; // [sp-4h] [bp-1Ch]@1
  int v20; // [sp+0h] [bp-18h]@1
  int v21; // [sp+4h] [bp-14h]@6
  void **v22; // [sp+8h] [bp-10h]@1
  int v23; // [sp+Ch] [bp-Ch]@1
  int (__cdecl *v24)(int, int); // [sp+10h] [bp-8h]@1
  int v25; // [sp+14h] [bp-4h]@1
  void *v26; // [sp+1Ch] [bp+4h]@9

  v25 = -1;
  v24 = sub_10050870;
  v23 = a1;
  v19 = a4;
  v18 = a6;
  v17 = a5;
  v16 = a1;
  v22 = (void **)&v16;
  v9 = a3;
  v20 = a3;
  v8 = a7 | 0xF;
  if ( (a7 | 0xFu) <= 0xFFFFFFFE )
  {
    a4 = *(_DWORD *)(a3 + 20);
    v10 = *(_DWORD *)(a3 + 20) >> 1;
    a2 = v8 / 3;
    if ( v10 > v8 / 3 )
    {
      v8 = v10 + a4;
      if ( a4 > -2 - v10 )
        v8 = -2;
    }
  }
  else
  {
    v8 = a7;
  }
  v12 = v8 + 1;
  v11 = 0;
  v25 = 0;
  v21 = 0;
  if ( v8 == -1 || (unsigned int)v12 <= 0xFFFFFFFF && (v11 = sub_10027EB3(a2, v12, a4, v8, v8 + 1), v21 = v11, v11) )
  {
    v14 = a8;
    if ( a8 )
    {
      if ( *(_DWORD *)(v9 + 20) < 0x10u )
        v15 = (const void *)v9;
      else
        v15 = *(const void **)v9;
      if ( a8 )
        sub_1002C950((void *)v11, v15, a8);
    }
    if ( *(_DWORD *)(v9 + 20) >= 0x10u )
      sub_1002404A(*(LPVOID *)v9);
    result = (int (__cdecl *)(int, int))v21;
    *(_BYTE *)v9 = 0;
    *(_DWORD *)v9 = result;
    *(_DWORD *)(v9 + 20) = v8;
    *(_DWORD *)(v9 + 16) = v14;
    if ( v8 >= 0x10 )
      v9 = (int)result;
    *(_BYTE *)(v9 + v14) = 0;
  }
  else
  {
    sub_10021BC5();
    v21 = a7;
    v22 = &v26;
    LOBYTE(v25) = 2;
    loc_100020F0((char *)&a7 + 3, a7 + 1);
    result = loc_10002055;
  }
  return result;
}
// 10002055: using guessed type int __cdecl loc_10002055(int, int);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10050870: using guessed type int __cdecl sub_10050870(int, int);

//----- (10002120) --------------------------------------------------------
int __usercall sub_10002120<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4)
{
  int v4; // eax@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // esi@3
  int v9; // [sp+20h] [bp-10h]@1

  v9 = a1;
  v5 = a2;
  v4 = sub_10027EB3(a1, a2, a2, a3, 28);
  v6 = v4;
  if ( v4 )
  {
    *(_DWORD *)(v4 + 4) = 1;
    *(_DWORD *)(v4 + 8) = 1;
    *(_DWORD *)v4 = off_1005C03C;
    if ( v4 != -12 )
    {
      v7 = *(_DWORD *)a4;
      *(_DWORD *)(v4 + 12) = 0;
      sub_10023441(v4 + 16, v9);
      *(_DWORD *)(v6 + 24) = v7;
    }
  }
  else
  {
    v6 = 0;
  }
  *(_DWORD *)v5 = v6 + 12;
  *(_DWORD *)(v5 + 4) = v6;
  return v5;
}
// 10023441: using guessed type int __cdecl sub_10023441(int, int);
// 1005C03C: using guessed type int (*off_1005C03C[2])();

//----- (100021F0) --------------------------------------------------------
void *__thiscall sub_100021F0(void *this, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  void *v4; // esi@1
  int v5; // edi@3
  void *result; // eax@7
  char v21; // [sp+8h] [bp-8h]@1

  v2 = 0;
  v4 = this;
  v3 = 0;
  if ( &v21 != (char *)a2 )
  {
    v2 = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a2 + 4) = 0;
    v3 = *(_DWORD *)a2;
    *(_DWORD *)a2 = 0;
  }
  v5 = *((_DWORD *)v4 + 1);
  *((_DWORD *)v4 + 1) = v2;
  *(_DWORD *)v4 = v3;
  if ( v5 )
  {
    _EBX = -1;
    _ECX = v5 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      _EAX = v5 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
    }
    result = v4;
  }
  else
  {
    result = v4;
  }
  return result;
}

//----- (10002260) --------------------------------------------------------
int __usercall sub_10002260<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  return sub_10001590(a1 + 12, a2, a3);
}

//----- (10002270) --------------------------------------------------------
int __thiscall sub_10002270(void *this)
{
  int result; // eax@2

  if ( this )
    result = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)this + 8))(1);
  return result;
}

//----- (10002280) --------------------------------------------------------
int __fastcall sub_10002280(int a1, const char *a2)
{
  int v2; // esi@1
  char v3; // bl@2
  int *v4; // edi@2
  char v5; // zf@3
  unsigned int v6; // ecx@4
  char v7; // bl@11
  void *v9; // [sp+10h] [bp-40h]@2
  int v10; // [sp+20h] [bp-30h]@2
  unsigned int v11; // [sp+24h] [bp-2Ch]@2
  void *v12; // [sp+28h] [bp-28h]@3
  int v13; // [sp+38h] [bp-18h]@3
  unsigned int v14; // [sp+3Ch] [bp-14h]@3
  int v15; // [sp+40h] [bp-10h]@1

  v2 = a1;
  v15 = 0;
  if ( a2 )
  {
    v5 = *a2 == 0;
    v14 = 15;
    v13 = 0;
    LOBYTE(v12) = 0;
    if ( v5 )
      v6 = 0;
    else
      v6 = strlen(a2);
    loc_10001BD0(&v12, a2, v6);
    v4 = (int *)&v12;
    v3 = 2;
  }
  else
  {
    v11 = 15;
    v10 = 0;
    LOBYTE(v9) = 0;
    v4 = (int *)&v9;
    v3 = 1;
  }
  *(_DWORD *)(v2 + 20) = 15;
  *(_DWORD *)(v2 + 16) = 0;
  *(_BYTE *)v2 = 0;
  if ( (unsigned int)v4[5] >= 0x10 )
  {
    *(_DWORD *)v2 = *v4;
    *v4 = 0;
  }
  else
  {
    if ( v4[4] != -1 )
      sub_100237D0((void *)v2, v4, v4[4] + 1);
  }
  *(_DWORD *)(v2 + 16) = v4[4];
  v7 = v3 | 4;
  *(_DWORD *)(v2 + 20) = v4[5];
  v4[5] = 15;
  v4[4] = 0;
  *(_BYTE *)v4 = 0;
  if ( v7 & 2 )
  {
    v7 &= 0xFDu;
    if ( v14 >= 0x10 )
      sub_1002404A(v12);
    v14 = 15;
    v13 = 0;
    LOBYTE(v12) = 0;
  }
  if ( v7 & 1 )
  {
    if ( v11 >= 0x10 )
      sub_1002404A(v9);
  }
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (100023C0) --------------------------------------------------------
bool __stdcall CheckVersion(const char *a1)
{
  int v1; // eax@1
  int v2; // edx@1
  int v3; // ecx@1
  unsigned int v4; // edi@3
  unsigned int v5; // eax@5
  int v6; // esi@5
  signed int v7; // eax@7
  bool v8; // ebx@11
  void *v10; // [sp+10h] [bp-18h]@1
  unsigned int v11; // [sp+24h] [bp-4h]@11

  v1 = sub_10002280((int)&v10, a1);
  v3 = v1;
  v2 = (int)&dword_10068E78;
  if ( (unsigned int)dword_10068E8C >= 0x10 )
    v2 = dword_10068E78;
  v4 = *(_DWORD *)(v1 + 16);
  if ( *(_DWORD *)(v1 + 20) >= 0x10u )
    v3 = *(_DWORD *)v1;
  v6 = dword_10068E88;
  v5 = dword_10068E88;
  if ( v4 < dword_10068E88 )
    v5 = v4;
  v7 = sub_10002720(v3, v2, v5);
  if ( !v7 )
  {
    if ( v4 >= v6 )
      v7 = v4 != v6;
    else
      v7 = -1;
  }
  v8 = v7 == 0;
  if ( v11 >= 0x10 )
    sub_1002404A(v10);
  return v8;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10068E78: using guessed type int dword_10068E78;
// 10068E88: using guessed type int dword_10068E88;
// 10068E8C: using guessed type int dword_10068E8C;

//----- (10002450) --------------------------------------------------------
void __stdcall Initialize(const char *a1, const char *a2, int a3, int a4, const char *a5)
{
  char v5; // [sp-48h] [bp-50h]@1
  int v6; // [sp-44h] [bp-4Ch]@1
  int v7; // [sp-40h] [bp-48h]@1
  int v8; // [sp-3Ch] [bp-44h]@1
  unsigned int v9; // [sp-38h] [bp-40h]@1
  signed int v10; // [sp-34h] [bp-3Ch]@1
  char v11; // [sp-30h] [bp-38h]@1
  int v12; // [sp-2Ch] [bp-34h]@1
  int v13; // [sp-28h] [bp-30h]@1
  int v14; // [sp-24h] [bp-2Ch]@1
  int v15; // [sp-20h] [bp-28h]@1
  signed int v16; // [sp-1Ch] [bp-24h]@1
  char v17; // [sp-18h] [bp-20h]@1
  int v18; // [sp-14h] [bp-1Ch]@1
  int v19; // [sp-10h] [bp-18h]@1
  int v20; // [sp-Ch] [bp-14h]@1
  unsigned int v21; // [sp-8h] [bp-10h]@1
  unsigned int v22; // [sp-4h] [bp-Ch]@1

  sub_10002280((int)&v17, a5);
  sub_10002280((int)&v11, a2);
  sub_10002280((int)&v5, a1);
  sub_100161B0(
    a3,
    a4,
    *(void **)&v5,
    v6,
    v7,
    v8,
    v9,
    v10,
    *(void **)&v11,
    v12,
    v13,
    v14,
    v15,
    v16,
    *(void **)&v17,
    v18,
    v19,
    v20,
    v21,
    v22);
}

//----- (10002510) --------------------------------------------------------
int __cdecl Status()
{
  return dword_1006A180;
}
// 1006A180: using guessed type int dword_1006A180;

//----- (10002520) --------------------------------------------------------
int __cdecl Utc()
{
  __int64 v0; // qax@4
  __int64 v1; // qax@4

  if ( HIDWORD(qword_1006A188) >= -2147483648 && (HIDWORD(qword_1006A188) > -2147483648 || (_DWORD)qword_1006A188) )
  {
    LODWORD(v1) = sub_100225B6();
    v0 = v1 - qword_1006A188;
  }
  else
  {
    LODWORD(v0) = sub_100225B6();
  }
  return sub_1004F7A0(v0 + 5000000, 0x989680u, 0);
}
// 1006A188: using guessed type __int64 qword_1006A188;

//----- (10002570) --------------------------------------------------------
int __stdcall Msg(int a1, int a2, int a3)
{
  int *v3; // edx@3

  if ( a1 == 1 )
  {
    v3 = &dword_1006A190;
  }
  else
  {
    if ( a1 != 2 )
      return 0;
    v3 = &dword_1006A1BC;
  }
  *(_DWORD *)a3 = v3[10];
  return (v3[8] - v3[7]) / 12;
}
// 1006A190: using guessed type int dword_1006A190;
// 1006A1BC: using guessed type int dword_1006A1BC;

//----- (100025B0) --------------------------------------------------------
signed int __userpurge GetMsg<eax>(int a1<ebx>, int a2, int a3, int a4, int a5, int a6)
{
  int *v6; // esi@3
  int *v8; // eax@6
  int v9; // ebx@8
  int v10; // eax@9
  int v11; // ecx@9
  int v12; // edi@9
  int v13; // eax@11
  int v14; // esi@11
  char v15; // cf@13
  int v16; // [sp+Ch] [bp-2Ch]@1
  int *v17; // [sp+10h] [bp-28h]@6
  int v18; // [sp+14h] [bp-24h]@8
  int v19; // [sp+18h] [bp-20h]@1
  void *v20; // [sp+1Ch] [bp-1Ch]@11
  unsigned int v21; // [sp+30h] [bp-8h]@11
  unsigned int v22; // [sp+34h] [bp-4h]@1

  v22 = (unsigned int)&v16 ^ __security_cookie;
  v19 = a5;
  if ( a2 == 1 )
  {
    v6 = &dword_1006A190;
  }
  else
  {
    if ( a2 != 2 )
      return 0;
    v6 = &dword_1006A1BC;
  }
  v17 = v6;
  sub_100163C0(a1, 0);
  v8 = &v16;
  if ( (v6[8] - v6[7]) / 12 >= a6 )
    v8 = &a6;
  v16 = (v6[8] - v6[7]) / 12;
  v9 = 0;
  v18 = *v8;
  if ( v18 > 0 )
  {
    v11 = v18;
    v10 = 0;
    v16 = 0;
    v12 = a4 + 4;
    do
    {
      if ( *(_DWORD *)v12 )
      {
        v14 = v10 + v6[7];
        sub_1000D460(v14, (int)&v20);
        v13 = (int)&v20;
        if ( v21 >= 0x10 )
          v13 = (int)v20;
        sub_10027F02(v9, v12, *(_DWORD *)v12, 60, v13, -1);
        v15 = v21 < 0x10;
        *(_DWORD *)(v19 + 4 * v9) = *(_DWORD *)(v14 + 8);
        if ( !v15 )
          sub_1002404A(v20);
        v11 = v18;
        v6 = v17;
        v10 = v16;
      }
      ++v9;
      v10 += 12;
      v12 += 8;
      v16 = v10;
    }
    while ( v9 < v11 );
  }
  return 1;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;
// 1006A190: using guessed type int dword_1006A190;
// 1006A1BC: using guessed type int dword_1006A1BC;

//----- (100026D0) --------------------------------------------------------
char __fastcall sub_100026D0(int a1, int a2)
{
  unsigned int v2; // edi@1
  unsigned int v3; // esi@3
  unsigned int v4; // eax@5
  int v5; // ecx@7

  v2 = *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 20) >= 0x10u )
    a2 = *(_DWORD *)a2;
  v3 = *(_DWORD *)(a1 + 16);
  if ( *(_DWORD *)(a1 + 20) >= 0x10u )
    a1 = *(_DWORD *)a1;
  v4 = v2;
  if ( v3 < v2 )
    v4 = v3;
  v5 = sub_10002720(a1, a2, v4);
  if ( !v5 )
  {
    if ( v3 < v2 )
      return 0;
    v5 = v3 != v2;
  }
  return v5 == 0;
}

//----- (10002720) --------------------------------------------------------
int __fastcall sub_10002720(int a1, int a2, unsigned int a3)
{
  int v3; // esi@2
  char v4; // cf@4
  unsigned __int8 v5; // cf@6
  unsigned __int8 v6; // al@8
  unsigned __int8 v7; // al@10
  unsigned __int8 v8; // al@12

  if ( !a3 )
    return 0;
  v3 = a3 - 4;
  if ( a3 < 4 )
  {
LABEL_5:
    if ( v3 == -4 )
      return 0;
  }
  else
  {
    while ( *(_DWORD *)a1 == *(_DWORD *)a2 )
    {
      a1 += 4;
      a2 += 4;
      v4 = (unsigned int)v3 < 4;
      v3 -= 4;
      if ( v4 )
        goto LABEL_5;
    }
  }
  v5 = *(_BYTE *)a1 < *(_BYTE *)a2;
  if ( *(_BYTE *)a1 != *(_BYTE *)a2
    || v3 != -3
    && ((v6 = *(_BYTE *)(a1 + 1), v5 = v6 < *(_BYTE *)(a2 + 1), v6 != *(_BYTE *)(a2 + 1))
     || v3 != -2
     && ((v7 = *(_BYTE *)(a1 + 2), v5 = v7 < *(_BYTE *)(a2 + 2), v7 != *(_BYTE *)(a2 + 2))
      || v3 != -1 && (v8 = *(_BYTE *)(a1 + 3), v5 = v8 < *(_BYTE *)(a2 + 3), v8 != *(_BYTE *)(a2 + 3)))) )
    return -v5 | 1;
  return 0;
}

//----- (10002780) --------------------------------------------------------
int __thiscall sub_10002780(void *this, int a2)
{
  void *v2; // edi@1
  int result; // eax@7

  v2 = this;
  if ( *(_DWORD *)(a2 + 20) >= 0x10u )
  {
    if ( this )
      *(_DWORD *)this = *(_DWORD *)a2;
    *(_DWORD *)a2 = 0;
  }
  else
  {
    if ( *(_DWORD *)(a2 + 16) != -1 )
      sub_100237D0(this, (const void *)a2, *(_DWORD *)(a2 + 16) + 1);
  }
  *((_DWORD *)v2 + 4) = *(_DWORD *)(a2 + 16);
  result = *(_DWORD *)(a2 + 20);
  *((_DWORD *)v2 + 5) = result;
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  return result;
}

//----- (100027E0) --------------------------------------------------------
int __thiscall sub_100027E0(int this, int a2)
{
  int v2; // edi@1
  int result; // eax@5

  v2 = this;
  *(_DWORD *)(this + 20) = 15;
  *(_DWORD *)(this + 16) = 0;
  *(_BYTE *)this = 0;
  if ( *(_DWORD *)(a2 + 20) >= 0x10u )
  {
    *(_DWORD *)this = *(_DWORD *)a2;
    *(_DWORD *)a2 = 0;
  }
  else
  {
    if ( *(_DWORD *)(a2 + 16) != -1 )
      sub_100237D0((void *)this, (const void *)a2, *(_DWORD *)(a2 + 16) + 1);
  }
  *(_DWORD *)(v2 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(v2 + 20) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  result = v2;
  *(_BYTE *)a2 = 0;
  return result;
}

//----- (10002850) --------------------------------------------------------
int __fastcall sub_10002850(int a1, unsigned int a2)
{
  unsigned int v2; // ebx@1
  int v3; // esi@1
  unsigned int v4; // ecx@2
  char v5; // cf@3
  int v6; // eax@8
  unsigned int v7; // ecx@11
  char v8; // cf@12
  int v9; // ecx@17
  unsigned int v10; // ecx@23
  char v11; // cf@24
  int v12; // ecx@29
  int v13; // ecx@32
  int v14; // ecx@39
  int v15; // ecx@42
  int v16; // ecx@45

  v2 = a2;
  v3 = a1;
  *(_DWORD *)(a1 + 20) = 15;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)a1 = 0;
  if ( a2 <= 0x7F )
  {
    v4 = *(_DWORD *)(a1 + 16);
    if ( v4 < 1 )
    {
      loc_10007D30(v3, 1 - v4, 0);
    }
    else
    {
      v5 = *(_DWORD *)(v3 + 20) < 0x10u;
      *(_DWORD *)(v3 + 16) = 1;
      if ( v5 )
        *(_BYTE *)(v3 + 1) = 0;
      else
        *(_BYTE *)(*(_DWORD *)v3 + 1) = 0;
    }
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v6 = v3;
    else
      v6 = *(_DWORD *)v3;
LABEL_51:
    *(_BYTE *)v6 = v2;
    return v3;
  }
  if ( a2 <= 0x7FF )
  {
    v7 = *(_DWORD *)(a1 + 16);
    if ( v7 < 2 )
    {
      loc_10007D30(v3, 2 - v7, 0);
    }
    else
    {
      v8 = *(_DWORD *)(v3 + 20) < 0x10u;
      *(_DWORD *)(v3 + 16) = 2;
      if ( v8 )
        *(_BYTE *)(v3 + 2) = 0;
      else
        *(_BYTE *)(*(_DWORD *)v3 + 2) = 0;
    }
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v9 = v3;
    else
      v9 = *(_DWORD *)v3;
    *(_BYTE *)(v9 + 1) = v2 & 0x3F | 0x80;
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
    {
      v6 = v3;
      LOBYTE(v2) = (v2 >> 6) & 0x1F | 0xC0;
    }
    else
    {
      v6 = *(_DWORD *)v3;
      LOBYTE(v2) = (v2 >> 6) & 0x1F | 0xC0;
    }
    goto LABEL_51;
  }
  if ( a2 <= 0xFFFF )
  {
    v10 = *(_DWORD *)(a1 + 16);
    if ( v10 < 3 )
    {
      loc_10007D30(v3, 3 - v10, 0);
    }
    else
    {
      v11 = *(_DWORD *)(v3 + 20) < 0x10u;
      *(_DWORD *)(v3 + 16) = 3;
      if ( v11 )
        *(_BYTE *)(v3 + 3) = 0;
      else
        *(_BYTE *)(*(_DWORD *)v3 + 3) = 0;
    }
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v12 = v3;
    else
      v12 = *(_DWORD *)v3;
    *(_BYTE *)(v12 + 2) = v2 & 0x3F | 0x80;
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v13 = v3;
    else
      v13 = *(_DWORD *)v3;
    *(_BYTE *)(v13 + 1) = (v2 >> 6) & 0x3F | 0x80;
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
    {
      v6 = v3;
      LOBYTE(v2) = (v2 >> 12) & 0xF | 0xE0;
    }
    else
    {
      v6 = *(_DWORD *)v3;
      LOBYTE(v2) = (v2 >> 12) & 0xF | 0xE0;
    }
    goto LABEL_51;
  }
  if ( a2 <= 0x10FFFF )
  {
    sub_10006DB0(a1, 4);
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v14 = v3;
    else
      v14 = *(_DWORD *)v3;
    *(_BYTE *)(v14 + 3) = v2 & 0x3F | 0x80;
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v15 = v3;
    else
      v15 = *(_DWORD *)v3;
    *(_BYTE *)(v15 + 2) = (v2 >> 6) & 0x3F | 0x80;
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v16 = v3;
    else
      v16 = *(_DWORD *)v3;
    *(_BYTE *)(v16 + 1) = (v2 >> 12) & 0x3F | 0x80;
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v6 = v3;
    else
      v6 = *(_DWORD *)v3;
    LOBYTE(v2) = (v2 >> 18) & 7 | 0xF0;
    goto LABEL_51;
  }
  return v3;
}

//----- (10002A80) --------------------------------------------------------
char __fastcall sub_10002A80(unsigned int a1, unsigned int a2)
{
  char result; // al@5

  if ( a1 >= a2 )
  {
LABEL_5:
    result = 0;
  }
  else
  {
    while ( *(_BYTE *)a1 != 10 && *(_BYTE *)a1 != 13 )
    {
      ++a1;
      if ( a1 >= a2 )
        goto LABEL_5;
    }
    result = 1;
  }
  return result;
}

//----- (10002AA0) --------------------------------------------------------
int __usercall sub_10002AA0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // esi@1
  int v8; // eax@3
  int v9; // edi@3

  v7 = a2;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  v4 = sub_10027EB3(a1, a2, a3, a4, 8);
  if ( !v4 )
    sub_10021BC5();
  *(_DWORD *)v7 = v4;
  *(_DWORD *)v4 = 0;
  *(_DWORD *)(v4 + 4) = 0;
  **(_DWORD **)v7 = v7;
  v9 = v7 + 20;
  *(_DWORD *)(v7 + 20) = 0;
  *(_DWORD *)(v7 + 24) = 0;
  *(_DWORD *)(v7 + 28) = 0;
  *(_DWORD *)(v7 + 32) = 0;
  *(_DWORD *)(v7 + 36) = 0;
  v8 = sub_10027EB3(v5, v6, a3, v7 + 20, 8);
  if ( !v8 )
    sub_10021BC5();
  *(_DWORD *)v9 = v8;
  *(_DWORD *)v8 = 0;
  *(_DWORD *)(v8 + 4) = 0;
  **(_DWORD **)v9 = v9;
  *(_DWORD *)(v7 + 60) = 15;
  *(_DWORD *)(v7 + 56) = 0;
  *(_BYTE *)(v7 + 40) = 0;
  *(_DWORD *)(v7 + 104) = 15;
  *(_DWORD *)(v7 + 100) = 0;
  *(_BYTE *)(v7 + 84) = 0;
  *(_WORD *)(v7 + 108) = 1;
  return v7;
}

//----- (10002BD0) --------------------------------------------------------
char __thiscall sub_10002BD0(int this, int a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  unsigned int v6; // ST08_4@1
  int v7; // eax@2
  int v8; // edx@7
  char v9; // bl@7
  char v10; // al@11
  char result; // al@16
  void *v12; // [sp+Ch] [bp-40h]@14
  unsigned int v13; // [sp+20h] [bp-2Ch]@14
  int v14; // [sp+24h] [bp-28h]@7
  int v15; // [sp+28h] [bp-24h]@14
  int v16; // [sp+2Ch] [bp-20h]@14
  int v17; // [sp+30h] [bp-1Ch]@1
  int v18; // [sp+34h] [bp-18h]@1
  int v19; // [sp+38h] [bp-14h]@1
  unsigned int v20; // [sp+3Ch] [bp-10h]@1
  int v21; // [sp+48h] [bp-4h]@14
  int v22; // [sp+4Ch] [bp+0h]@1

  v20 = (unsigned int)&v22 ^ __security_cookie;
  v6 = (unsigned int)&v22 ^ __security_cookie;
  v5 = this;
  v18 = a3;
  *(_DWORD *)(this + 68) = a3;
  v17 = a2;
  v19 = a4;
  *(_DWORD *)(this + 64) = a2;
  *(_BYTE *)(this + 110) = 0;
  *(_DWORD *)(this + 72) = a2;
  *(_DWORD *)(this + 76) = 0;
  *(_DWORD *)(this + 80) = 0;
  loc_10001BD0(this + 84, &unk_1005C72F, 0, v6);
  sub_10008830(v5 + 20);
  if ( *(_DWORD *)(v5 + 16) )
  {
    v7 = *(_DWORD *)(v5 + 16);
    while ( v7 )
    {
      --v7;
      if ( !v7 )
        *(_DWORD *)(v5 + 12) = 0;
    }
    *(_DWORD *)(v5 + 16) = v7;
  }
  loc_10008250(v5, &v19);
  v9 = sub_10002D20(v5);
  sub_10002F90(v5, (int)&v14);
  if ( *(_BYTE *)(v5 + 110) )
  {
    if ( *(_DWORD *)(v5 + 100) )
      sub_10005ED0(v8, a4, a4, v5 + 84, 2);
  }
  if ( *(_BYTE *)(v5 + 109) && (v10 = *(_BYTE *)(a4 + 8)) != 0 && v10 != 6 && v10 != 7 )
  {
    v15 = v17;
    v14 = 13;
    v16 = v18;
    sub_100019D0((int)&v12, "A valid JSON document must be either an array or an object value.");
    v21 = 0;
    sub_100049E0((void *)v5, (int *)&v12, (int)&v14, 0);
    if ( v13 >= 0x10 )
      sub_1002404A(v12);
    result = 0;
  }
  else
  {
    result = v9;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (10002D20) --------------------------------------------------------
char __thiscall sub_10002D20(int this)
{
  int v1; // edx@1
  int v2; // ecx@1
  char v3; // bl@1
  int v4; // edi@1
  int v5; // eax@3
  int v6; // esi@3
  int v7; // ST08_4@3
  int v8; // eax@3
  int v9; // edx@3
  int v10; // ecx@7
  int v11; // eax@14
  int v12; // edx@14
  int v13; // eax@16
  int v14; // esi@16
  int v15; // ST08_4@16
  int v16; // eax@16
  int v17; // edx@16
  char result; // al@18
  int v19; // [sp+10h] [bp-5Ch]@1
  LPVOID v20[4]; // [sp+1Ch] [bp-50h]@3
  int v21; // [sp+2Ch] [bp-40h]@19
  unsigned int v22; // [sp+30h] [bp-3Ch]@19
  int v23; // [sp+34h] [bp-38h]@3
  int v24; // [sp+3Ch] [bp-30h]@11
  int v25; // [sp+40h] [bp-2Ch]@11
  char v26; // [sp+44h] [bp-28h]@16
  char v27; // [sp+50h] [bp-1Ch]@16
  int v28; // [sp+68h] [bp-4h]@11

  v4 = this;
  sub_10002F90(this, (int)&v19);
  v3 = 1;
  if ( *(_BYTE *)(v4 + 110) )
  {
    if ( *(_DWORD *)(v4 + 100) )
    {
      v7 = v2;
      v8 = sub_10008370(v4, (int)&v23);
      v5 = sub_1000A3A0(v8, v9, (int)v20, v7);
      v6 = *(_DWORD *)v5;
      if ( *(_DWORD *)v5 )
        v6 = *(_DWORD *)v6;
      sub_10005ED0(
        *(_DWORD *)(v5 + 8) & 3,
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 4 * ((*(_DWORD *)(v5 + 8) >> 2) & (*(_DWORD *)(v6 + 8) - 1)))
                  + 4 * (*(_DWORD *)(v5 + 8) & 3)),
        v4,
        v4 + 84,
        0);
      loc_10001BD0(v4 + 84, &unk_1005C72F, 0);
    }
  }
  switch ( v19 )
  {
    case 1:
      v3 = sub_10003740(v1, v4, 1, v4, v2);
      goto LABEL_15;
    case 3:
      v3 = sub_10003AA0(v1, v4, 1, v4, v2);
      goto LABEL_15;
    case 6:
      v3 = sub_10003D20((void *)v4, (int)&v19);
      goto LABEL_15;
    case 5:
      v3 = sub_10004290(v4, 1, (int)&v19);
      goto LABEL_15;
    case 7:
      v24 = v24 & 0xFFFFFF05 | 5;
      v25 = 0;
      LOBYTE(v23) = 1;
      v28 = 0;
      goto LABEL_14;
    case 8:
      v24 = v24 & 0xFFFFFF05 | 5;
      v25 = 0;
      LOBYTE(v23) = 0;
      v28 = 1;
      goto LABEL_14;
    case 9:
      v24 &= 0xFFFFFE00u;
      v25 = 0;
      v28 = 3;
LABEL_14:
      v11 = sub_10004B80(v4);
      sub_10004FF0(v11, v12, (int)&v23);
      v28 = -1;
      sub_10004F60((int)&v23, 1);
LABEL_15:
      if ( !*(_BYTE *)(v4 + 110) )
        goto LABEL_21;
      *(_DWORD *)(v4 + 76) = *(_DWORD *)(v4 + 72);
      v15 = v10;
      v16 = sub_10008370(v4, (int)&v27);
      v13 = sub_1000A3A0(v16, v17, (int)&v26, v15);
      v14 = *(_DWORD *)v13;
      if ( *(_DWORD *)v13 )
        v14 = *(_DWORD *)v14;
      *(_DWORD *)(v4 + 80) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v14 + 4)
                                                   + 4 * ((*(_DWORD *)(v14 + 8) - 1) & (*(_DWORD *)(v13 + 8) >> 2)))
                                       + 4 * (*(_DWORD *)(v13 + 8) & 3));
      result = v3;
      break;
    default:
      v22 = 15;
      v21 = 0;
      LOBYTE(v20[0]) = 0;
      loc_10001BD0(v20, "Syntax error: value, object or array expected.", 46);
      v28 = 4;
      v3 = sub_100049E0((void *)v4, (int *)v20, (int)&v19, 0);
      if ( v22 >= 0x10 )
        sub_1002404A(v20[0]);
LABEL_21:
      result = v3;
      break;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10002F90) --------------------------------------------------------
char __thiscall sub_10002F90(int this, int a2)
{
  int v2; // esi@1
  int v3; // edx@2
  char v4; // al@3
  int v5; // ecx@3
  int v6; // eax@8
  char v7; // cl@9
  char v8; // al@16
  char v9; // zf@20
  int v10; // eax@20
  int v11; // edx@23
  signed int v12; // ecx@24
  char v13; // al@25
  int v14; // edx@28
  signed int v15; // ecx@29
  char v16; // al@30
  int v17; // edx@33
  signed int v18; // ecx@34
  char v19; // al@35

  v2 = this;
  if ( *(_BYTE *)(this + 108) )
  {
    do
    {
      v3 = *(_DWORD *)(v2 + 68);
      if ( *(_DWORD *)(v2 + 72) != v3 )
      {
        do
        {
          v5 = *(_DWORD *)(v2 + 72);
          v4 = *(_BYTE *)v5;
          if ( *(_BYTE *)v5 != 32 && v4 != 9 && v4 != 13 && v4 != 10 )
            break;
          *(_DWORD *)(v2 + 72) = v5 + 1;
        }
        while ( v5 + 1 != v3 );
      }
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(v2 + 72);
      v6 = *(_DWORD *)(v2 + 72);
      if ( v6 == *(_DWORD *)(v2 + 68) )
      {
        v7 = 0;
      }
      else
      {
        v7 = *(_BYTE *)v6;
        *(_DWORD *)(v2 + 72) = v6 + 1;
      }
      switch ( v7 )
      {
        case 123:
          *(_DWORD *)a2 = 1;
          goto LABEL_20;
        case 125:
          *(_DWORD *)a2 = 2;
          goto LABEL_20;
        case 91:
          *(_DWORD *)a2 = 3;
          goto LABEL_20;
        case 93:
          *(_DWORD *)a2 = 4;
          goto LABEL_20;
        case 34:
          *(_DWORD *)a2 = 5;
          v8 = sub_10003700(v2);
          goto LABEL_18;
        case 47:
          *(_DWORD *)a2 = 12;
          v8 = sub_100034D0(v2);
LABEL_18:
          if ( !v8 )
            goto LABEL_19;
          goto LABEL_20;
        default:
          goto LABEL_19;
        case 45:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          *(_DWORD *)a2 = 6;
          sub_100036C0(v2);
          goto LABEL_20;
        case 116:
          *(_DWORD *)a2 = 7;
          v11 = *(_DWORD *)(v2 + 72);
          if ( *(_DWORD *)(v2 + 68) - v11 < 3 )
            goto LABEL_19;
          v12 = 3;
          while ( 1 )
          {
            v13 = *(_BYTE *)(v11 + v12-- - 1);
            if ( v13 != byte_1005C0C4[v12] )
              goto LABEL_19;
            if ( !v12 )
            {
              *(_DWORD *)(v2 + 72) = v11 + 3;
              goto LABEL_20;
            }
          }
        case 102:
          *(_DWORD *)a2 = 8;
          v14 = *(_DWORD *)(v2 + 72);
          if ( *(_DWORD *)(v2 + 68) - v14 < 4 )
            goto LABEL_19;
          v15 = 4;
          while ( 1 )
          {
            v16 = *(_BYTE *)(v14 + v15-- - 1);
            if ( v16 != byte_1005C0C8[v15] )
              goto LABEL_19;
            if ( !v15 )
            {
              *(_DWORD *)(v2 + 72) = v14 + 4;
              goto LABEL_20;
            }
          }
        case 110:
          *(_DWORD *)a2 = 9;
          v17 = *(_DWORD *)(v2 + 72);
          if ( *(_DWORD *)(v2 + 68) - v17 < 3 )
            goto LABEL_19;
          v18 = 3;
          break;
        case 44:
          *(_DWORD *)a2 = 10;
          goto LABEL_20;
        case 58:
          *(_DWORD *)a2 = 11;
          goto LABEL_20;
        case 0:
          *(_DWORD *)a2 = 0;
          goto LABEL_20;
      }
      do
      {
        v19 = *(_BYTE *)(v17 + v18-- - 1);
        if ( v19 != byte_1005C0D0[v18] )
        {
LABEL_19:
          *(_DWORD *)a2 = 13;
          goto LABEL_20;
        }
      }
      while ( v18 );
      *(_DWORD *)(v2 + 72) = v17 + 3;
LABEL_20:
      v9 = *(_DWORD *)a2 == 12;
      v10 = *(_DWORD *)(v2 + 72);
      *(_DWORD *)(a2 + 8) = v10;
    }
    while ( v9 );
  }
  else
  {
    LOBYTE(v10) = sub_10003200(this, a2);
  }
  return v10;
}

//----- (10003200) --------------------------------------------------------
char __thiscall sub_10003200(int this, int a2)
{
  int v2; // edx@1
  int v3; // esi@1
  char v4; // al@2
  int v5; // ecx@2
  int v6; // eax@7
  char v7; // cl@8
  char v9; // al@15
  int v10; // edx@21
  signed int v11; // ecx@22
  char v12; // al@23
  int v13; // edx@26
  signed int v14; // ecx@27
  char v15; // al@28
  int v16; // edx@31
  signed int v17; // ecx@32
  char v18; // al@33

  v3 = this;
  v2 = *(_DWORD *)(this + 68);
  if ( *(_DWORD *)(this + 72) != v2 )
  {
    do
    {
      v5 = *(_DWORD *)(v3 + 72);
      v4 = *(_BYTE *)v5;
      if ( *(_BYTE *)v5 != 32 && v4 != 9 && v4 != 13 && v4 != 10 )
        break;
      *(_DWORD *)(v3 + 72) = v5 + 1;
    }
    while ( v5 + 1 != v2 );
  }
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(v3 + 72);
  v6 = *(_DWORD *)(v3 + 72);
  if ( v6 == *(_DWORD *)(v3 + 68) )
  {
    v7 = 0;
  }
  else
  {
    v7 = *(_BYTE *)v6;
    *(_DWORD *)(v3 + 72) = v6 + 1;
  }
  switch ( v7 )
  {
    case 123:
      *(_DWORD *)a2 = 1;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 125:
      *(_DWORD *)a2 = 2;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 91:
      *(_DWORD *)a2 = 3;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 93:
      *(_DWORD *)a2 = 4;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 34:
      *(_DWORD *)a2 = 5;
      v9 = sub_10003700(v3);
      goto LABEL_17;
    case 47:
      *(_DWORD *)a2 = 12;
      v9 = sub_100034D0(v3);
LABEL_17:
      if ( !v9 )
        goto LABEL_18;
      goto LABEL_19;
    default:
      goto LABEL_18;
    case 45:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      *(_DWORD *)a2 = 6;
      sub_100036C0(v3);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 116:
      *(_DWORD *)a2 = 7;
      v10 = *(_DWORD *)(v3 + 72);
      if ( *(_DWORD *)(v3 + 68) - v10 < 3 )
        goto LABEL_18;
      v11 = 3;
      while ( 1 )
      {
        v12 = *(_BYTE *)(v10 + v11-- - 1);
        if ( v12 != byte_1005C0C4[v11] )
          break;
        if ( !v11 )
        {
          *(_DWORD *)(v3 + 72) = v10 + 3;
          *(_DWORD *)(a2 + 8) = v10 + 3;
          return 1;
        }
      }
      goto LABEL_18;
    case 102:
      *(_DWORD *)a2 = 8;
      v13 = *(_DWORD *)(v3 + 72);
      if ( *(_DWORD *)(v3 + 68) - v13 < 4 )
        goto LABEL_18;
      v14 = 4;
      while ( 1 )
      {
        v15 = *(_BYTE *)(v13 + v14-- - 1);
        if ( v15 != byte_1005C0C8[v14] )
          break;
        if ( !v14 )
        {
          *(_DWORD *)(v3 + 72) = v13 + 4;
          *(_DWORD *)(a2 + 8) = v13 + 4;
          return 1;
        }
      }
      goto LABEL_18;
    case 110:
      *(_DWORD *)a2 = 9;
      v16 = *(_DWORD *)(v3 + 72);
      if ( *(_DWORD *)(v3 + 68) - v16 < 3 )
        goto LABEL_18;
      v17 = 3;
      break;
    case 44:
      *(_DWORD *)a2 = 10;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 58:
      *(_DWORD *)a2 = 11;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 0:
      *(_DWORD *)a2 = 0;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
  }
  while ( 1 )
  {
    v18 = *(_BYTE *)(v16 + v17-- - 1);
    if ( v18 != byte_1005C0D0[v17] )
      break;
    if ( !v17 )
    {
      *(_DWORD *)(v3 + 72) = v16 + 3;
      *(_DWORD *)(a2 + 8) = v16 + 3;
      return 1;
    }
  }
LABEL_18:
  *(_DWORD *)a2 = 13;
LABEL_19:
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
  return 1;
}

//----- (100034D0) --------------------------------------------------------
char __thiscall sub_100034D0(int this)
{
  int v1; // eax@1
  int v2; // edx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // eax@2
  char v6; // ch@2
  char v8; // cl@7
  unsigned int v9; // eax@13
  int v10; // ebx@13
  char v11; // [sp+Fh] [bp-1h]@2

  v4 = this;
  v1 = *(_DWORD *)(this + 72);
  v2 = *(_DWORD *)(this + 68);
  v3 = v1 - 1;
  if ( v1 == v2 )
    return 0;
  v6 = *(_BYTE *)v1;
  v5 = v1 + 1;
  v11 = v6;
  *(_DWORD *)(v4 + 72) = v5;
  if ( v6 == 42 )
  {
    if ( !sub_10003670(v4) )
      return 0;
    v6 = v11;
  }
  else
  {
    if ( v6 != 47 )
      return 0;
    if ( v5 != v2 )
    {
      do
      {
        v8 = *(_BYTE *)v5++;
        *(_DWORD *)(v4 + 72) = v5;
      }
      while ( v8 != 13 && v8 != 10 && v5 != v2 );
    }
  }
  if ( *(_BYTE *)(v4 + 110) )
  {
    v9 = *(_DWORD *)(v4 + 76);
    v10 = 0;
    if ( v9 )
    {
      if ( v9 >= v3 )
      {
LABEL_18:
        if ( v6 != 42 || !sub_10002A80(v3, *(_DWORD *)(v4 + 72)) )
          v10 = 1;
      }
      else
      {
        while ( *(_BYTE *)v9 != 10 && *(_BYTE *)v9 != 13 )
        {
          ++v9;
          if ( v9 >= v3 )
            goto LABEL_18;
        }
      }
    }
    sub_10003580(v2, v4, v3, v3, *(_DWORD *)(v4 + 72), v10);
  }
  return 1;
}

//----- (10003580) --------------------------------------------------------
int __userpurge sub_10003580<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5, int a6)
{
  int v6; // esi@1
  int result; // eax@4
  int v8; // [sp-4h] [bp-50h]@5
  int v9; // [sp+Ch] [bp-40h]@8
  int v10; // [sp+1Ch] [bp-30h]@8
  unsigned int v11; // [sp+20h] [bp-2Ch]@8
  int v12; // [sp+24h] [bp-28h]@2
  int v13; // [sp+34h] [bp-18h]@2
  unsigned int v14; // [sp+38h] [bp-14h]@2
  int v15; // [sp+48h] [bp-4h]@4

  v6 = a2;
  if ( a6 == 1 )
  {
    v14 = 15;
    v13 = 0;
    LOBYTE(v12) = 0;
    if ( a4 != a5 )
      loc_10001BD0(&v12, a4, a5 - a4);
    v15 = 0;
    result = sub_10005ED0(a1, *(_DWORD *)(v6 + 80), a3, (int)&v12, 1);
    if ( v14 >= 0x10 )
    {
      v8 = v12;
      return sub_1002404A((LPVOID)v8);
    }
  }
  else
  {
    if ( *(_DWORD *)(a2 + 100) )
      loc_10009590(a2 + 84, &unk_1005C0D4, 1);
    v11 = 15;
    v10 = 0;
    LOBYTE(v9) = 0;
    if ( a4 != a5 )
      loc_10001BD0(&v9, a4, a5 - a4);
    v15 = 1;
    result = loc_10009490(v6 + 84, &v9, 0, -1);
    if ( v11 >= 0x10 )
    {
      v8 = v9;
      return sub_1002404A((LPVOID)v8);
    }
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10003670) --------------------------------------------------------
bool __thiscall sub_10003670(int this)
{
  int v1; // eax@1
  int v2; // edx@1
  int v3; // esi@1
  char v4; // cl@2
  int v5; // eax@5
  bool result; // eax@6
  char v7; // cl@7

  v3 = this;
  v1 = *(_DWORD *)(this + 72);
  v2 = *(_DWORD *)(this + 68);
  if ( v1 != v2 )
  {
    do
    {
      v4 = *(_BYTE *)v1++;
      *(_DWORD *)(v3 + 72) = v1;
    }
    while ( (v4 != 42 || *(_BYTE *)v1 != 47) && v1 != v2 );
  }
  v5 = *(_DWORD *)(v3 + 72);
  if ( v5 == v2 )
  {
    result = 0;
  }
  else
  {
    v7 = *(_BYTE *)v5;
    *(_DWORD *)(v3 + 72) = v5 + 1;
    result = v7 == 47;
  }
  return result;
}

//----- (100036C0) --------------------------------------------------------
void __thiscall sub_100036C0(int this)
{
  int v1; // esi@1
  char v2; // al@2
  int v3; // edx@2

  v1 = *(_DWORD *)(this + 68);
  if ( *(_DWORD *)(this + 72) != v1 )
  {
    do
    {
      v3 = *(_DWORD *)(this + 72);
      v2 = *(_BYTE *)v3;
      if ( (*(_BYTE *)v3 < 48 || v2 > 57) && v2 != 46 && v2 != 101 && v2 != 69 && v2 != 43 && v2 != 45 )
        break;
      *(_DWORD *)(this + 72) = v3 + 1;
    }
    while ( v3 + 1 != v1 );
  }
}

//----- (10003700) --------------------------------------------------------
bool __thiscall sub_10003700(int this)
{
  int v1; // eax@1
  char i; // dl@1
  int v3; // esi@1
  int v4; // eax@2

  v1 = *(_DWORD *)(this + 72);
  v3 = *(_DWORD *)(this + 68);
  for ( i = 0; v1 != v3; v1 = *(_DWORD *)(this + 72) )
  {
    i = *(_BYTE *)v1;
    v4 = v1 + 1;
    *(_DWORD *)(this + 72) = v4;
    if ( i == 92 )
    {
      if ( v4 != v3 )
        *(_DWORD *)(this + 72) = v4 + 1;
    }
    else
    {
      if ( i == 34 )
        return i == 34;
    }
  }
  return i == 34;
}

//----- (10003740) --------------------------------------------------------
char __userpurge sub_10003740<al>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // eax@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // eax@4
  int v11; // edi@4
  int v12; // ST08_4@4
  int v13; // eax@4
  int v14; // edx@4
  int v15; // eax@7
  char v16; // cl@7
  int v17; // ecx@13
  char v18; // al@13
  int v19; // ecx@14
  int v20; // eax@16
  int v21; // ST08_4@16
  int v22; // eax@16
  int v23; // edx@16
  int v24; // edi@17
  int v25; // eax@19
  int v26; // edx@19
  int v27; // ecx@19
  char v28; // al@21
  int v29; // ecx@21
  int v30; // ecx@22
  int v31; // eax@26
  char i; // cl@29
  char v33; // bl@34
  int *v35; // eax@40
  char v36; // [sp+10h] [bp-78h]@16
  int v37; // [sp+1Ch] [bp-6Ch]@4
  int v38; // [sp+28h] [bp-60h]@4
  int v39; // [sp+34h] [bp-54h]@6
  int v40; // [sp+40h] [bp-48h]@1
  void *v41; // [sp+44h] [bp-44h]@34
  int v42; // [sp+4Ch] [bp-3Ch]@4
  char v43; // [sp+50h] [bp-38h]@16
  int v44; // [sp+54h] [bp-34h]@1
  unsigned int v45; // [sp+58h] [bp-30h]@1
  void *v46; // [sp+5Ch] [bp-2Ch]@1
  int v47; // [sp+6Ch] [bp-1Ch]@1
  unsigned int v48; // [sp+70h] [bp-18h]@1
  unsigned int v49; // [sp+74h] [bp-14h]@1
  int v50; // [sp+84h] [bp-4h]@1
  int v51; // [sp+88h] [bp+0h]@1

  v49 = (unsigned int)&v51 ^ __security_cookie;
  v9 = a2;
  v48 = 15;
  v47 = 0;
  LOBYTE(v46) = 0;
  v50 = 0;
  v44 = v44 & 0xFFFFFE07 | 7;
  v45 = 0;
  v5 = sub_10027EB3(a1, a2, a3, a4, 8);
  v8 = v5;
  v40 = v5;
  LOBYTE(v50) = 1;
  if ( v5 )
  {
    *(_DWORD *)v5 = 0;
    *(_DWORD *)(v5 + 4) = 0;
    *(_DWORD *)v5 = sub_1000A430(v6, v7, a3, v5);
  }
  else
  {
    v8 = 0;
  }
  v42 = v8;
  v12 = v7;
  LOBYTE(v50) = 2;
  v13 = sub_10008370(v9, (int)&v38);
  v10 = sub_1000A3A0(v13, v14, (int)&v37, v12);
  v11 = *(_DWORD *)v10;
  if ( *(_DWORD *)v10 )
    v11 = *(_DWORD *)v11;
  sub_10004FF0(
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v11 + 4) + 4 * ((*(_DWORD *)(v10 + 8) >> 2) & (*(_DWORD *)(v11 + 8) - 1)))
              + 4 * (*(_DWORD *)(v10 + 8) & 3)),
    *(_DWORD *)(v10 + 8) & 3,
    (int)&v42);
  LOBYTE(v50) = 0;
  sub_10004F60((int)&v42, a3);
  if ( sub_10003200(v9, (int)&v39) )
  {
    while ( 1 )
    {
      v15 = v39;
      v16 = 1;
      if ( v39 == 12 )
      {
        while ( v16 )
        {
          v16 = sub_10003200(v9, (int)&v39);
          v15 = v39;
          if ( v39 != 12 )
          {
            if ( !v16 )
              goto LABEL_34;
            goto LABEL_11;
          }
        }
        goto LABEL_34;
      }
LABEL_11:
      if ( v15 == 2 )
        break;
      if ( v15 != 5 )
        goto LABEL_34;
      loc_10001BD0(&v46, &unk_1005C72F, 0);
      v18 = loc_100043A0(v9, &v39, &v46);
      v17 = v9;
      if ( !v18 )
      {
LABEL_44:
        v33 = sub_10004AD0(v17, 2);
        goto LABEL_37;
      }
      if ( !sub_10003200(v9, (int)&v37) || v37 != 11 )
      {
        sub_100019D0((int)&v41, "Missing ':' after object member name");
        LOBYTE(v50) = 3;
        v35 = &v37;
LABEL_42:
        v33 = sub_10004B20((void *)v9, (int *)&v41, (int)v35, 2);
        if ( v45 >= 0x10 )
          sub_1002404A(v41);
        goto LABEL_37;
      }
      v21 = v19;
      v22 = sub_10008370(v9, (int)&v43);
      v20 = sub_1000A3A0(v22, v23, (int)&v36, v21);
      if ( *(_DWORD *)v20 )
        v24 = **(_DWORD **)v20;
      else
        v24 = 0;
      v26 = *(_DWORD *)(v20 + 8) & 3;
      v27 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v24 + 4) + 4
                                                         * ((*(_DWORD *)(v20 + 8) >> 2) & (*(_DWORD *)(v24 + 8) - 1)))
                      + 4 * v26);
      v25 = (int)&v46;
      if ( v48 >= 0x10 )
        v25 = (int)v46;
      v40 = sub_10005A20(v27, v26, v25, v27);
      loc_10008250(v9, &v40);
      v28 = sub_10002D20(v9);
      v29 = *(_DWORD *)(v9 + 16);
      if ( v29 )
      {
        v30 = v29 - 1;
        *(_DWORD *)(v9 + 16) = v30;
        if ( !v30 )
          *(_DWORD *)(v9 + 12) = 0;
      }
      v17 = v9;
      if ( !v28 )
        goto LABEL_44;
      if ( !sub_10003200(v9, (int)&v38) || (v31 = v38, v38 != 2) && v38 != 10 && v38 != 12 )
      {
        sub_100019D0((int)&v41, "Missing ',' or '}' in object declaration");
        LOBYTE(v50) = 4;
        v35 = &v38;
        goto LABEL_42;
      }
      for ( i = 1; v38 == 12; v31 = v38 )
      {
        if ( !i )
          break;
        i = sub_10003200(v9, (int)&v38);
      }
      if ( v31 == 2 )
        goto LABEL_46;
      if ( !sub_10003200(v9, (int)&v39) )
        goto LABEL_34;
    }
    if ( v47 )
      goto LABEL_34;
LABEL_46:
    v33 = 1;
  }
  else
  {
LABEL_34:
    v45 = 15;
    v44 = 0;
    LOBYTE(v41) = 0;
    loc_10001BD0(&v41, "Missing '}' or object member name", 33);
    LOBYTE(v50) = 5;
    v33 = sub_10004B20((void *)v9, (int *)&v41, (int)&v39, 2);
    if ( v45 >= 0x10 )
      sub_1002404A(v41);
    v45 = 15;
    v44 = 0;
    LOBYTE(v41) = 0;
  }
LABEL_37:
  if ( v48 >= 0x10 )
    sub_1002404A(v46);
  return v33;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (10003AA0) --------------------------------------------------------
char __userpurge sub_10003AA0<al>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // eax@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // eax@4
  int v11; // edi@4
  int v12; // ST08_4@4
  int v13; // eax@4
  int v14; // edx@4
  int v15; // edx@6
  int i; // ecx@6
  char v17; // al@7
  char result; // al@13
  int v19; // ebx@14
  int v20; // eax@15
  int v21; // ST08_4@15
  int v22; // eax@15
  int v23; // edx@15
  int v24; // edi@16
  char v25; // al@18
  int v26; // ecx@18
  int v27; // ecx@19
  char v28; // al@22
  char v29; // dl@27
  char v30; // bl@33
  void *v31; // [sp+10h] [bp-54h]@33
  int v32; // [sp+20h] [bp-44h]@33
  unsigned int v33; // [sp+24h] [bp-40h]@33
  int v34; // [sp+28h] [bp-3Ch]@4
  char v35; // [sp+2Ch] [bp-38h]@15
  int v36; // [sp+30h] [bp-34h]@1
  int v37; // [sp+34h] [bp-30h]@1
  char v38; // [sp+38h] [bp-2Ch]@4
  int v39; // [sp+44h] [bp-20h]@4
  int v40; // [sp+50h] [bp-14h]@1
  int v41; // [sp+60h] [bp-4h]@1

  v9 = a2;
  v36 = v36 & 0xFFFFFE06 | 6;
  v37 = 0;
  v5 = sub_10027EB3(a1, a2, a3, a4, 8);
  v8 = v5;
  v40 = v5;
  v41 = 0;
  if ( v5 )
  {
    *(_DWORD *)v5 = 0;
    *(_DWORD *)(v5 + 4) = 0;
    *(_DWORD *)v5 = sub_1000A430(v6, v7, a3, v5);
  }
  else
  {
    v8 = 0;
  }
  v34 = v8;
  v12 = v7;
  v41 = 1;
  v13 = sub_10008370(v9, (int)&v38);
  v10 = sub_1000A3A0(v13, v14, (int)&v39, v12);
  v11 = *(_DWORD *)v10;
  if ( *(_DWORD *)v10 )
    v11 = *(_DWORD *)v11;
  sub_10004FF0(
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v11 + 4) + 4 * ((*(_DWORD *)(v10 + 8) >> 2) & (*(_DWORD *)(v11 + 8) - 1)))
              + 4 * (*(_DWORD *)(v10 + 8) & 3)),
    *(_DWORD *)(v10 + 8) & 3,
    (int)&v34);
  v41 = -1;
  sub_10004F60((int)&v34, a3);
  v15 = *(_DWORD *)(v9 + 68);
  if ( *(_DWORD *)(v9 + 72) != v15 )
  {
    do
    {
      i = *(_DWORD *)(v9 + 72);
      v17 = *(_BYTE *)i;
      if ( *(_BYTE *)i != 32 && v17 != 9 && v17 != 13 && v17 != 10 )
        break;
      *(_DWORD *)(v9 + 72) = i + 1;
    }
    while ( i + 1 != v15 );
  }
  if ( **(_BYTE **)(v9 + 72) == 93 )
  {
    sub_10003200(v9, (int)&v38);
    result = 1;
  }
  else
  {
    v19 = 0;
    while ( 1 )
    {
      v21 = i;
      v22 = sub_10008370(v9, (int)&v35);
      v20 = sub_1000A3A0(v22, v23, (int)&v38, v21);
      if ( *(_DWORD *)v20 )
        v24 = **(_DWORD **)v20;
      else
        v24 = 0;
      v40 = sub_10005820(
              *(_DWORD *)(v20 + 8) & 3,
              *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v24 + 4)
                                    + 4 * ((*(_DWORD *)(v20 + 8) >> 2) & (*(_DWORD *)(v24 + 8) - 1)))
                        + 4 * (*(_DWORD *)(v20 + 8) & 3)),
              v24,
              v19++);
      loc_10008250(v9, &v40);
      v25 = sub_10002D20(v9);
      v26 = *(_DWORD *)(v9 + 16);
      if ( v26 )
      {
        v27 = v26 - 1;
        *(_DWORD *)(v9 + 16) = v27;
        if ( !v27 )
          *(_DWORD *)(v9 + 12) = 0;
      }
      if ( !v25 )
        return sub_10004AD0(v9, 4);
      v28 = sub_10003200(v9, (int)&v39);
      for ( i = v39; v39 == 12; i = v39 )
      {
        if ( !v28 )
          break;
        v28 = sub_10003200(v9, (int)&v39);
      }
      v29 = i == 10 || i == 4 ? 0 : 1;
      if ( !v28 || v29 )
        break;
      if ( i == 4 )
        return 1;
    }
    v33 = 15;
    v32 = 0;
    LOBYTE(v31) = 0;
    loc_10001BD0(&v31, "Missing ',' or ']' in array declaration", 39);
    v41 = 2;
    v30 = sub_10004B20((void *)v9, (int *)&v31, (int)&v39, 4);
    if ( v33 >= 0x10 )
      sub_1002404A(v31);
    result = v30;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10003D20) --------------------------------------------------------
char __thiscall sub_10003D20(void *this, int a2)
{
  char v2; // al@1
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // ebx@1
  void *v6; // esi@1
  char v7; // al@3
  char result; // al@13
  int v9; // esi@14
  signed int v10; // eax@15
  signed int v11; // edi@15
  int v12; // edx@17
  int v13; // ecx@17
  unsigned int v14; // edi@17
  unsigned __int64 v15; // ST00_8@17
  __int64 v16; // qax@17
  char v17; // al@18
  int v18; // eax@20
  __int64 v19; // qt0@25
  unsigned __int8 v20; // cf@25
  int v21; // edx@25
  unsigned __int8 v22; // cf@25
  int v23; // eax@27
  int v24; // esi@27
  int v25; // edx@27
  int v26; // ST0C_4@27
  int v27; // eax@27
  int v28; // edx@27
  int v29; // eax@30
  char v30; // bl@32
  int v31; // eax@32
  int v32; // eax@32
  int v33; // edx@40
  int v34; // ecx@40
  int v35; // [sp-4h] [bp-80h]@40
  void *v36; // [sp+10h] [bp-6Ch]@30
  int v37; // [sp+18h] [bp-64h]@27
  int v38; // [sp+1Ch] [bp-60h]@27
  int v39; // [sp+20h] [bp-5Ch]@27
  unsigned int v40; // [sp+24h] [bp-58h]@27
  void *v41; // [sp+28h] [bp-54h]@32
  char v42; // [sp+34h] [bp-48h]@27
  int v43; // [sp+38h] [bp-44h]@34
  unsigned int v44; // [sp+3Ch] [bp-40h]@32
  void *v45; // [sp+40h] [bp-3Ch]@32
  char v46; // [sp+4Ch] [bp-30h]@27
  __int64 v47; // [sp+50h] [bp-2Ch]@17
  unsigned int v48; // [sp+58h] [bp-24h]@17
  unsigned int v49; // [sp+5Ch] [bp-20h]@17
  unsigned int v50; // [sp+60h] [bp-1Ch]@17
  void *v51; // [sp+64h] [bp-18h]@1
  char v52; // [sp+6Bh] [bp-11h]@14
  int v53; // [sp+78h] [bp-4h]@27

  v6 = this;
  v51 = this;
  v2 = 0;
  v4 = *(_DWORD *)(a2 + 4);
  v5 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)(a2 + 4);
  if ( v3 == v5 )
    goto LABEL_49;
  do
  {
    v2 = v2 || (v7 = *(_BYTE *)v3, *(_BYTE *)v3 == 46) || v7 == 101 || v7 == 69 || v7 == 43 || v7 == 45 && v3 != v4;
    ++v3;
  }
  while ( v3 != v5 );
  if ( v2 )
  {
    result = sub_10004050(v6, a2);
  }
  else
  {
LABEL_49:
    v9 = *(_DWORD *)(a2 + 4);
    v52 = *(_BYTE *)v4 == 45;
    if ( v52 )
    {
      v9 = v4 + 1;
      v11 = 0;
      v10 = -2147483648;
    }
    else
    {
      v11 = -1;
      v10 = -1;
    }
    HIDWORD(v15) = v10;
    LODWORD(v15) = v11;
    v16 = sub_10031610(v15, 0xAu, 0);
    v13 = 10 * v16;
    __asm
    {
      xorps   xmm0, xmm0
      movlpd  [ebp+var_2C], xmm0
    }
    v50 = HIDWORD(v16);
    v12 = v47;
    v48 = v11 - 10 * v16;
    v14 = HIDWORD(v47);
    v49 = v16;
    if ( v9 >= (unsigned int)v5 )
    {
LABEL_26:
      if ( v52 )
      {
        v25 = -v12;
        v39 = v39 & 0xFFFFFF01 | 1;
        v40 = 0;
        v37 = v25;
        v38 = (unsigned __int64)-__PAIR__(v14, v25) >> 32;
        v26 = v13;
        v53 = 3;
        v27 = sub_10008370((int)v51, (int)&v42);
        v23 = sub_1000A3A0(v27, v28, (int)&v46, v26);
        v24 = *(_DWORD *)v23;
        if ( *(_DWORD *)v23 )
          v24 = *(_DWORD *)v24;
        v33 = *(_DWORD *)(v23 + 8) & 3;
        v35 = (int)&v37;
        v34 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v24 + 4)
                                    + 4 * ((*(_DWORD *)(v23 + 8) >> 2) & (*(_DWORD *)(v24 + 8) - 1)))
                        + 4 * v33);
      }
      else
      {
        if ( v14 || (unsigned int)v12 > 0x7FFFFFFF )
        {
          v39 = v39 & 0xFFFFFF02 | 2;
          v40 = 0;
          v37 = v12;
          v38 = v14;
          v53 = 5;
        }
        else
        {
          v39 = v39 & 0xFFFFFF01 | 1;
          v40 = 0;
          v37 = v12;
          v38 = v14;
          v53 = 4;
        }
        v35 = (int)&v37;
        v34 = sub_10004B80((int)v51);
      }
      sub_10004FF0(v34, v33, v35);
      v53 = -1;
      sub_10004F60((int)&v37, v5);
      result = 1;
    }
    else
    {
      while ( 1 )
      {
        v17 = *(_BYTE *)v9++;
        if ( v17 < 48 )
          break;
        if ( v17 > 57 )
          break;
        v18 = v17 - 48;
        HIDWORD(v47) = v18;
        if ( v14 >= v50 && (v14 > v50 || v12 >= v49) && (v9 != v5 || v18 > v48) )
          return sub_10004050(v51, a2);
        HIDWORD(v19) = v14;
        LODWORD(v19) = v12;
        v13 = (unsigned __int64)(4 * v19) >> 32;
        v20 = 4 * v12 >= (unsigned int)-v12;
        v21 = 5 * v12;
        HIDWORD(v19) = v13 + v20 + v14;
        LODWORD(v19) = v21;
        v21 *= 2;
        v22 = HIDWORD(v47) >= (unsigned int)-v21;
        v12 = HIDWORD(v47) + v21;
        v14 = v22 + ((unsigned __int64)(2 * v19) >> 32);
        if ( v9 >= (unsigned int)v5 )
          goto LABEL_26;
      }
      v40 = 15;
      v29 = *(_DWORD *)(a2 + 4);
      v39 = 0;
      LOBYTE(v36) = 0;
      if ( v29 != v5 )
        loc_10001BD0(&v36, v29, v5 - v29);
      v53 = 0;
      v31 = sub_1000A460((int)&v45, (int)"'", (int)&v36);
      LOBYTE(v53) = 1;
      v32 = sub_1000A4F0((int)&v41, v31, "' is not a number.");
      LOBYTE(v53) = 2;
      v30 = sub_100049E0(v51, (int *)v32, a2, 0);
      if ( v44 >= 0x10 )
        sub_1002404A(v41);
      v44 = 15;
      v43 = 0;
      LOBYTE(v41) = 0;
      if ( HIDWORD(v47) >= 0x10u )
        sub_1002404A(v45);
      v47 = 64424509440i64;
      LOBYTE(v45) = 0;
      if ( v40 >= 0x10 )
        sub_1002404A(v36);
      result = v30;
    }
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10004050) --------------------------------------------------------
char __thiscall sub_10004050(void *this, int a2)
{
  int v2; // eax@1
  int v3; // ecx@1
  int v4; // ebx@1
  int v5; // esi@1
  int v6; // ecx@3
  int v7; // esi@3
  int v8; // eax@6
  int v9; // eax@11
  int v10; // ecx@11
  char v11; // bl@13
  int v12; // eax@13
  int v13; // eax@13
  char result; // al@19
  int v15; // eax@20
  int v16; // esi@20
  int v17; // ST08_4@20
  int v18; // eax@20
  int v19; // edx@20
  char v20; // [sp+Ch] [bp-8Ch]@20
  char v21; // [sp+18h] [bp-80h]@20
  void *v22; // [sp+24h] [bp-74h]@13
  int v23; // [sp+34h] [bp-64h]@15
  unsigned int v24; // [sp+38h] [bp-60h]@13
  __int64 v25; // [sp+3Ch] [bp-5Ch]@1
  void *v26; // [sp+44h] [bp-54h]@5
  __int64 v27; // [sp+4Ch] [bp-4Ch]@20
  int v28; // [sp+54h] [bp-44h]@5
  unsigned int v29; // [sp+58h] [bp-40h]@5
  char v30[8]; // [sp+60h] [bp-38h]@2
  void *v31; // [sp+68h] [bp-30h]@13
  int v32; // [sp+78h] [bp-20h]@17
  unsigned int v33; // [sp+7Ch] [bp-1Ch]@15
  unsigned int v34; // [sp+84h] [bp-14h]@1
  int v35; // [sp+94h] [bp-4h]@13
  int v36; // [sp+98h] [bp+0h]@1

  v34 = (unsigned int)&v36 ^ __security_cookie;
  v4 = (int)this;
  __asm { xorps   xmm0, xmm0 }
  v3 = *(_DWORD *)(a2 + 8);
  v2 = *(_DWORD *)(a2 + 4);
  v5 = *(_DWORD *)(a2 + 8) - v2;
  __asm { movsd   [ebp+var_5C], xmm0 }
  if ( v5 <= 32 )
  {
    sub_1002C950(v30, (const void *)v2, v5);
    if ( (unsigned int)v5 < 0x21 )
    {
      v30[v5] = 0;
      v7 = sub_100281B9(v4, (int)v30, (int)"%lf", (unsigned int)&v25);
      goto LABEL_10;
    }
    v2 = sub_100280DF(v4, a2, v5);
  }
  v29 = 15;
  v28 = 0;
  LOBYTE(v26) = 0;
  if ( v2 == v3 || (loc_10001BD0(&v26, v2, v3 - v2), v8 = (int)v26, v29 < 0x10) )
    v8 = (int)&v26;
  v7 = sub_100281B9(v4, v8, (int)"%lf", (unsigned int)&v25);
  if ( v29 >= 0x10 )
    sub_1002404A(v26);
LABEL_10:
  if ( v7 == 1 )
  {
    __asm { movsd   xmm0, [ebp+var_5C] }
    v28 = v28 & 0xFFFFFF03 | 3;
    v29 = 0;
    __asm { movsd   [ebp+var_4C], xmm0 }
    v17 = v6;
    v35 = 3;
    v18 = sub_10008370(v4, (int)&v21);
    v15 = sub_1000A3A0(v18, v19, (int)&v20, v17);
    v16 = *(_DWORD *)v15;
    if ( *(_DWORD *)v15 )
      v16 = *(_DWORD *)v16;
    sub_10004FF0(
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v16 + 4) + 4 * ((*(_DWORD *)(v15 + 8) >> 2) & (*(_DWORD *)(v16 + 8) - 1)))
                + 4 * (*(_DWORD *)(v15 + 8) & 3)),
      *(_DWORD *)(v15 + 8) & 3,
      (int)&v27);
    v35 = -1;
    sub_10004F60((int)&v27, v4);
    result = 1;
  }
  else
  {
    v9 = *(_DWORD *)(a2 + 8);
    v10 = *(_DWORD *)(a2 + 4);
    v29 = 15;
    v28 = 0;
    LOBYTE(v26) = 0;
    if ( v10 != v9 )
      loc_10001BD0(&v26, v10, v9 - v10);
    v35 = 0;
    v12 = sub_1000A460((int)&v31, (int)"'", (int)&v26);
    LOBYTE(v35) = 1;
    v13 = sub_1000A4F0((int)&v22, v12, "' is not a number.");
    LOBYTE(v35) = 2;
    v11 = sub_100049E0((void *)v4, (int *)v13, a2, 0);
    if ( v24 >= 0x10 )
      sub_1002404A(v22);
    v24 = 15;
    v23 = 0;
    LOBYTE(v22) = 0;
    if ( v33 >= 0x10 )
      sub_1002404A(v31);
    v33 = 15;
    v32 = 0;
    LOBYTE(v31) = 0;
    if ( v29 >= 0x10 )
      sub_1002404A(v26);
    result = v11;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;
// 10004050: using guessed type char var_38[8];

//----- (10004290) --------------------------------------------------------
char __userpurge sub_10004290<al>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v3; // esi@1
  char v4; // bl@2
  int *v5; // ecx@3
  int v6; // eax@5
  int v7; // esi@5
  int v8; // ecx@5
  int v9; // ST08_4@5
  int v10; // eax@5
  int v11; // edx@5
  char v13; // [sp+Ch] [bp-54h]@5
  char v14; // [sp+18h] [bp-48h]@5
  int v15; // [sp+24h] [bp-3Ch]@5
  int v16; // [sp+2Ch] [bp-34h]@5
  int v17; // [sp+30h] [bp-30h]@5
  void *v18; // [sp+34h] [bp-2Ch]@1
  int v19; // [sp+44h] [bp-1Ch]@1
  unsigned int v20; // [sp+48h] [bp-18h]@1
  unsigned int v21; // [sp+4Ch] [bp-14h]@1
  int v22; // [sp+5Ch] [bp-4h]@1
  int v23; // [sp+60h] [bp+0h]@1

  v21 = (unsigned int)&v23 ^ __security_cookie;
  v3 = a1;
  v20 = 15;
  v19 = 0;
  LOBYTE(v18) = 0;
  v22 = 0;
  if ( (unsigned __int8)loc_100043A0(a3, &v18, (unsigned int)&v23 ^ __security_cookie) )
  {
    v5 = (int *)&v18;
    if ( v20 >= 0x10 )
      v5 = (int *)v18;
    v16 = v16 & 0xFFFFFF04 | 0x104;
    v17 = 0;
    v15 = loc_10004C50(v5, v19);
    v9 = v8;
    LOBYTE(v22) = 1;
    v10 = sub_10008370(v3, (int)&v14);
    v6 = sub_1000A3A0(v10, v11, (int)&v13, v9);
    v7 = *(_DWORD *)v6;
    if ( *(_DWORD *)v6 )
      v7 = *(_DWORD *)v7;
    sub_10004FF0(
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 4) + 4 * ((*(_DWORD *)(v6 + 8) >> 2) & (*(_DWORD *)(v7 + 8) - 1)))
                + 4 * (*(_DWORD *)(v6 + 8) & 3)),
      *(_DWORD *)(v6 + 8) & 3,
      (int)&v15);
    LOBYTE(v22) = 0;
    sub_10004F60((int)&v15, a2);
    v4 = 1;
  }
  else
  {
    v4 = 0;
  }
  if ( v20 >= 0x10 )
    sub_1002404A(v18);
  return v4;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (10004720) --------------------------------------------------------
char __thiscall sub_10004720(void *this, int a2, int *a3, int a4, int a5)
{
  int v5; // edi@1
  int v7; // ecx@5
  char v8; // bl@6
  char v9; // al@7
  int v10; // edx@7
  char v11; // cl@8
  char v12; // bl@12
  char v13; // [sp+10h] [bp-40h]@12
  char v14; // [sp+28h] [bp-28h]@6
  void *v15; // [sp+40h] [bp-10h]@1
  int v16; // [sp+4Ch] [bp-4h]@6

  v15 = this;
  v5 = a5;
  if ( !sub_10004890(this, a2, a3, a4, a5) )
    return 0;
  if ( *(_DWORD *)v5 < 0xD800u || *(_DWORD *)v5 > 0xDBFFu )
    return 1;
  v7 = *a3;
  if ( a4 - *a3 < 6 )
  {
    sub_100019D0((int)&v14, "additional six characters expected to parse unicode surrogate pair.");
    v16 = 0;
    v8 = sub_100049E0(v15, (int *)&v14, a2, *a3);
    sub_10001A30((int)&v14);
    return v8;
  }
  v9 = *(_BYTE *)v7;
  v10 = v7 + 1;
  *a3 = v7 + 1;
  if ( v9 == 92 )
  {
    v11 = *(_BYTE *)v10;
    *a3 = v10 + 1;
    if ( v11 == 117 )
    {
      if ( !sub_10004890(v15, a2, a3, a4, (int)&a5) )
        return 0;
      *(_DWORD *)v5 = (a5 & 0x3FF) + (((*(_DWORD *)v5 & 0x3FF) + 64) << 10);
      return 1;
    }
  }
  sub_100019D0((int)&v13, "expecting another \\u token to begin the second half of a unicode surrogate pair");
  v16 = 1;
  v12 = sub_100049E0(v15, (int *)&v13, a2, *a3);
  sub_10001A30((int)&v13);
  return v12;
}

//----- (10004890) --------------------------------------------------------
char __thiscall sub_10004890(void *this, int a2, int *a3, int a4, int a5)
{
  void *v5; // esi@1
  char v6; // bl@2
  signed int v7; // edi@4
  int v8; // edx@5
  char v9; // cl@5
  int v10; // eax@6
  int v12; // [sp-4h] [bp-54h]@3
  int v13; // [sp+10h] [bp-40h]@13
  int v14; // [sp+20h] [bp-30h]@13
  unsigned int v15; // [sp+24h] [bp-2Ch]@13
  int v16; // [sp+28h] [bp-28h]@2
  int v17; // [sp+38h] [bp-18h]@2
  unsigned int v18; // [sp+3Ch] [bp-14h]@2
  void *v19; // [sp+40h] [bp-10h]@1
  int v20; // [sp+4Ch] [bp-4h]@2

  v5 = this;
  v19 = this;
  if ( a4 - *a3 < 4 )
  {
    v18 = 15;
    v17 = 0;
    LOBYTE(v16) = 0;
    loc_10001BD0(&v16, "Bad unicode escape sequence in string: four digits expected.", 60);
    v20 = 0;
    v6 = sub_100049E0(v5, &v16, a2, *a3);
    if ( v18 >= 0x10 )
    {
      v12 = v16;
      goto LABEL_15;
    }
    return v6;
  }
  v7 = 0;
  *(_DWORD *)a5 = 0;
  while ( 1 )
  {
    v9 = *(_BYTE *)*a3++;
    v8 = 16 * *(_DWORD *)a5;
    *(_DWORD *)a5 = v8;
    if ( (unsigned __int8)(v9 - 48) > 9u )
      break;
    v10 = v9 - 48;
LABEL_11:
    ++v7;
    *(_DWORD *)a5 = v8 + v10;
    if ( v7 >= 4 )
      return 1;
  }
  if ( (unsigned __int8)(v9 - 97) <= 5u )
  {
    v10 = v9 - 87;
    goto LABEL_11;
  }
  if ( (unsigned __int8)(v9 - 65) <= 5u )
  {
    v10 = v9 - 55;
    goto LABEL_11;
  }
  v15 = 15;
  v14 = 0;
  LOBYTE(v13) = 0;
  loc_10001BD0(&v13, "Bad unicode escape sequence in string: hexadecimal digit expected.", 66);
  v20 = 1;
  v6 = sub_100049E0(v19, &v13, a2, *a3);
  if ( v15 >= 0x10 )
  {
    v12 = v13;
LABEL_15:
    sub_1002404A((LPVOID)v12);
  }
  return v6;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (100049E0) --------------------------------------------------------
char __thiscall sub_100049E0(void *this, int *a2, int a3, int a4)
{
  int v4; // edx@1
  void *v5; // esi@1
  __int64 v8; // [sp+Ch] [bp-3Ch]@1
  int v9; // [sp+14h] [bp-34h]@1
  void *v10; // [sp+18h] [bp-30h]@1
  int v11; // [sp+28h] [bp-20h]@1
  unsigned int v12; // [sp+2Ch] [bp-1Ch]@1
  int v13; // [sp+30h] [bp-18h]@1
  unsigned int v14; // [sp+34h] [bp-14h]@1
  int v15; // [sp+44h] [bp-4h]@1
  int v16; // [sp+48h] [bp+0h]@1

  v14 = (unsigned int)&v16 ^ __security_cookie;
  v5 = this;
  v4 = (int)a2;
  _EAX = a3;
  v13 = 0;
  v12 = 15;
  v11 = 0;
  LOBYTE(v10) = 0;
  v15 = 0;
  __asm { movq    xmm0, qword ptr [eax] }
  v9 = *(_DWORD *)(a3 + 8);
  __asm { movq    [ebp+var_3C], xmm0 }
  if ( &v10 != (void **)a2 )
    loc_10001D10(&v10, a2, 0, -1);
  v13 = a4;
  sub_10007450((int)((char *)v5 + 20), v4, (int)&v8);
  if ( v12 >= 0x10 )
    sub_1002404A(v10);
  return 0;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (10004AD0) --------------------------------------------------------
char __thiscall sub_10004AD0(int this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v5; // [sp+10h] [bp-Ch]@2

  v3 = this;
  v2 = *(_DWORD *)(this + 36);
  do
  {
    if ( !sub_10003200(v3, (int)&v5) )
      loc_100072D0(v3 + 20, v2);
  }
  while ( v5 != a2 && v5 );
  loc_100072D0(v3 + 20, v2);
  return 0;
}

//----- (10004B20) --------------------------------------------------------
char __thiscall sub_10004B20(void *this, int *a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  int v7; // [sp+10h] [bp-Ch]@2

  v5 = (int)this;
  sub_100049E0(this, a2, a3, 0);
  v4 = *(_DWORD *)(v5 + 36);
  do
  {
    if ( !sub_10003200(v5, (int)&v7) )
      loc_100072D0(v5 + 20, v4);
  }
  while ( v7 != a4 && v7 );
  loc_100072D0(v5 + 20, v4);
  return 0;
}

//----- (10004B80) --------------------------------------------------------
int __thiscall sub_10004B80(int this)
{
  int v1; // eax@1
  int v2; // esi@1
  int v3; // ST08_4@1
  int v4; // eax@1
  int v5; // eax@1
  int v6; // edx@1
  char v8; // [sp+4h] [bp-18h]@1
  char v9; // [sp+10h] [bp-Ch]@1

  v3 = this;
  v4 = sub_10008370(this, (int)&v8);
  v5 = sub_1000A3A0(v4, v6, (int)&v9, v3);
  v2 = v5;
  v1 = *(_DWORD *)v5;
  if ( v1 )
    v1 = *(_DWORD *)v1;
  return *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 4) + 4 * ((*(_DWORD *)(v1 + 8) - 1) & (*(_DWORD *)(v2 + 8) >> 2)))
                   + 4 * (*(_DWORD *)(v2 + 8) & 3));
}

//----- (10004BD0) --------------------------------------------------------
int __thiscall sub_10004BD0(int this)
{
  int v1; // edi@1
  int result; // eax@5

  v1 = this;
  if ( *(_DWORD *)(this + 104) >= 0x10u )
    sub_1002404A(*(LPVOID *)(this + 84));
  *(_DWORD *)(v1 + 104) = 15;
  *(_DWORD *)(v1 + 100) = 0;
  *(_BYTE *)(v1 + 84) = 0;
  if ( *(_DWORD *)(v1 + 60) >= 0x10u )
    sub_1002404A(*(LPVOID *)(v1 + 40));
  *(_DWORD *)(v1 + 60) = 15;
  *(_DWORD *)(v1 + 56) = 0;
  *(_BYTE *)(v1 + 40) = 0;
  sub_10008830(v1 + 20);
  sub_1002404A(*(LPVOID *)(v1 + 20));
  *(_DWORD *)(v1 + 20) = 0;
  sub_100082E0(v1);
  result = sub_1002404A(*(LPVOID *)v1);
  *(_DWORD *)v1 = 0;
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10004CE0) --------------------------------------------------------
void *__thiscall sub_10004CE0(void *this)
{
  *(_DWORD *)this = 0;
  return this;
}

//----- (10004DA0) --------------------------------------------------------
int __fastcall sub_10004DA0(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  char v5; // al@1
  int v6; // eax@4
  int v7; // eax@6
  int v8; // esi@6
  int v9; // eax@11
  int v10; // esi@12
  signed int v11; // esi@14
  int v12; // edi@15
  void *v13; // eax@16
  int v14; // eax@16
  int (__stdcall **v16)(char); // [sp+Ch] [bp-24h]@23
  int v17; // [sp+18h] [bp-18h]@6
  int v18; // [sp+1Ch] [bp-14h]@1
  unsigned int v19; // [sp+20h] [bp-10h]@1
  int v20; // [sp+2Ch] [bp-4h]@6
  int v21; // [sp+30h] [bp+0h]@1

  v19 = (unsigned int)&v21 ^ __security_cookie;
  v3 = a1;
  v4 = a3;
  v18 = a3;
  v5 = *(_BYTE *)(a3 + 8);
  *(_BYTE *)(a1 + 8) = v5;
  *(_DWORD *)(a1 + 12) = 0;
  switch ( v5 )
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 5:
      *(_DWORD *)a1 = *(_DWORD *)a3;
      *(_DWORD *)(a1 + 4) = *(_DWORD *)(a3 + 4);
      break;
    case 4:
      a1 = *(_DWORD *)a3;
      if ( *(_DWORD *)a3 )
      {
        v6 = loc_10004C50(a1, -1);
        *(_DWORD *)(v3 + 8) |= 0x100u;
        *(_DWORD *)v3 = v6;
      }
      else
      {
        *(_DWORD *)v3 = 0;
      }
      break;
    case 6:
    case 7:
      v7 = sub_10027EB3(a2, a1, a1, a3, 8);
      v8 = v7;
      v17 = v7;
      v20 = 0;
      if ( v7 )
      {
        *(_DWORD *)v7 = 0;
        sub_10007DE0(a2, v7, v3, a3, *(_DWORD *)a3, a1);
      }
      else
      {
        v8 = 0;
      }
      v20 = -1;
      *(_DWORD *)v3 = v8;
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a3 + 12) )
  {
    v9 = sub_10021CF0(a2, a1, v3, a3, 16);
    v17 = v9;
    v20 = 1;
    if ( v9 )
    {
      v10 = v9 + 4;
      *(_DWORD *)v9 = 3;
      sub_1002832E(v9 + 4, 4, 3, (void (__thiscall *)(_DWORD))sub_10004CE0, (int)sub_10004CF0);
    }
    else
    {
      v10 = 0;
    }
    v20 = -1;
    *(_DWORD *)(v3 + 12) = v10;
    v11 = 0;
    while ( 1 )
    {
      v12 = *(_DWORD *)(*(_DWORD *)(v4 + 12) + v11);
      if ( v12 )
      {
        v14 = v11 + *(_DWORD *)(v3 + 12);
        v17 = v14;
        v13 = *(void **)v14;
        if ( v13 )
          sub_100282F6(v3, v13);
        if ( *(_BYTE *)v12 && *(_BYTE *)v12 != 47 )
        {
          v18 = (int)"Comments must start with /";
          sub_10023687((int)&v16, &v18);
          v16 = &off_100542F0;
          sub_1002D02B((int)&v16, (int)&unk_100615D4);
          return v3;
        }
        *(_DWORD *)v17 = loc_10004C50(v12, -1);
      }
      v11 += 4;
      if ( v11 >= 12 )
        return v3;
      v4 = v18;
    }
  }
  return v3;
}
// 10004CF0: using guessed type int sub_10004CF0();
// 100542F0: using guessed type int (__stdcall *off_100542F0)(char);
// 10067210: using guessed type int __security_cookie;

//----- (10004F60) --------------------------------------------------------
int __usercall sub_10004F60<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // eax@1
  int v3; // esi@1
  void *v4; // edi@3
  int result; // eax@8
  void *v6; // esi@9
  char v7; // [sp+8h] [bp-4h]@4

  v3 = a1;
  v2 = *(_BYTE *)(a1 + 8);
  if ( v2 == 4 )
  {
    if ( *(_DWORD *)(a1 + 8) & 0x100 )
    {
      if ( *(_DWORD *)a1 )
        sub_100282F6(a2, *(LPVOID *)a1);
    }
  }
  else
  {
    if ( (unsigned int)(v2 - 6) <= 1 )
    {
      v4 = *(void **)a1;
      if ( *(_DWORD *)a1 )
      {
        sub_10007E80(v4, (int)&v7, **(_DWORD **)v4, *(_DWORD *)v4);
        sub_1002404A(*(LPVOID *)v4);
        sub_1002404A(v4);
      }
    }
  }
  result = *(_DWORD *)(v3 + 12);
  if ( result )
  {
    v6 = (void *)(result - 4);
    sub_10023E14(result, 4, *(_DWORD *)(result - 4), (void (__thiscall *)(_DWORD))sub_10004CF0);
    result = sub_1002401B(v6);
  }
  return result;
}
// 10004CF0: using guessed type int sub_10004CF0();
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10004FF0) --------------------------------------------------------
int __fastcall sub_10004FF0(int a1, int a2, int a3)
{
  int v4; // esi@1
  int v5; // ebx@1
  unsigned __int8 v6; // al@1
  int v7; // ecx@1
  int v8; // edx@1
  int v9; // ebx@1
  int v10; // eax@1
  int v11; // ebx@1
  int v12; // [sp+8h] [bp-14h]@1
  int v13; // [sp+Ch] [bp-10h]@1
  int v14; // [sp+10h] [bp-Ch]@1
  int v15; // [sp+14h] [bp-8h]@1

  v4 = a1;
  v15 = 0;
  sub_10004DA0((int)&v12, a2, a3);
  v5 = v14;
  v6 = v14 ^ *(_BYTE *)(v4 + 8);
  *(_BYTE *)(v4 + 8) = v14;
  v7 = *(_DWORD *)v4;
  v8 = *(_DWORD *)(v4 + 4);
  v9 = v6 ^ v5;
  *(_DWORD *)v4 = v12;
  *(_DWORD *)(v4 + 4) = v13;
  v13 = v8;
  v12 = v7;
  v10 = *(_DWORD *)(v4 + 8) ^ ((_WORD)v9 ^ (unsigned __int16)*(_DWORD *)(v4 + 8)) & 0x100;
  v11 = ((_WORD)v9 ^ (unsigned __int16)((unsigned __int16)(*(_DWORD *)(v4 + 8) << 23 >> 31) << 8)) & 0x100 ^ v9;
  *(_DWORD *)(v4 + 8) = v10;
  v14 = v11;
  sub_10004F60((int)&v12, v11);
  return v4;
}

//----- (10005730) --------------------------------------------------------
char __thiscall sub_10005730(void *_ECX)
{
  char result; // al@3

  switch ( *((_BYTE *)_ECX + 8) )
  {
    case 1:
    case 2:
      if ( *(_QWORD *)_ECX )
        goto LABEL_5;
      goto LABEL_3;
    case 3:
      __asm
      {
        movsd   xmm0, qword ptr [ecx]; jumptable 10005739 case 3
        ucomisd xmm0, ds:qword_1005D348
        lahf
      }
      if ( !__SETP__(_AH & 0x44, 0) )
        goto LABEL_3;
LABEL_5:
      result = 1;
      break;
    case 5:
      result = *(_BYTE *)_ECX;
      break;
    case 4:
      if ( *(_DWORD *)_ECX && **(_BYTE **)_ECX )
        result = 1;
      else
LABEL_3:
        result = 0;
      break;
    case 6:
    case 7:
      result = *(_DWORD *)(*(_DWORD *)_ECX + 4) != 0;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (100057B0) --------------------------------------------------------
int __thiscall sub_100057B0(void *this)
{
  int result; // eax@3
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  switch ( *((_BYTE *)this + 8) )
  {
    case 6:
      if ( !*(_DWORD *)(*(_DWORD *)this + 4) )
        goto LABEL_5;
      v2 = (void *)**(_DWORD **)this;
      sub_100081F0(&v2);
      result = *((_DWORD *)v2 + 5) + 1;
      break;
    case 7:
      result = *(_DWORD *)(*(_DWORD *)this + 4);
      break;
    default:
LABEL_5:
      result = 0;
      break;
  }
  return result;
}

//----- (10005820) --------------------------------------------------------
int __userpurge sub_10005820<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4)
{
  void **v4; // ebx@1
  int v5; // eax@2
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // esi@2
  int v9; // eax@6
  int v10; // edx@6
  int v11; // esi@6
  void *v12; // edi@6
  int v13; // eax@7
  int v14; // ecx@8
  unsigned __int8 v15; // cf@9
  char v16; // zf@13
  int result; // eax@17
  int v18; // esi@18
  void *v19; // edi@18
  int v20; // eax@18
  int v21; // [sp+Ch] [bp-44h]@5
  int v22; // [sp+14h] [bp-3Ch]@2
  int v23; // [sp+18h] [bp-38h]@2
  int v24; // [sp+20h] [bp-30h]@2
  LPVOID lpMem; // [sp+24h] [bp-2Ch]@18
  int v26; // [sp+28h] [bp-28h]@18
  char v27; // [sp+2Ch] [bp-24h]@18
  unsigned int v28; // [sp+3Ch] [bp-14h]@1
  int v29; // [sp+4Ch] [bp-4h]@2
  int v30; // [sp+50h] [bp+0h]@1

  v28 = (unsigned int)&v30 ^ __security_cookie;
  v4 = (void **)a2;
  if ( !*(_BYTE *)(a2 + 8) )
  {
    v22 = v22 & 0xFFFFFE06 | 6;
    v23 = 0;
    v5 = sub_10027EB3(a1, a2, a2, a3, 8);
    v8 = v5;
    v24 = v5;
    v29 = 0;
    if ( v5 )
    {
      *(_DWORD *)v5 = 0;
      *(_DWORD *)(v5 + 4) = 0;
      *(_DWORD *)v5 = sub_1000A430(v6, v7, (int)v4, a3);
    }
    else
    {
      v8 = 0;
    }
    v21 = v8;
    v29 = 1;
    sub_10004FF0((int)v4, v6, (int)&v21);
    v29 = -1;
    sub_10004F60((int)&v21, (int)v4);
  }
  v22 = 0;
  v23 = a4;
  v29 = 2;
  v12 = *v4;
  v9 = sub_10007FE0(*v4, (int)&v22);
  v11 = v9;
  if ( v9 == *(_DWORD *)v12 )
    goto LABEL_24;
  v13 = *(_DWORD *)(v9 + 16);
  if ( v13 )
  {
    v14 = 0;
    while ( 1 )
    {
      LOBYTE(v10) = *(_BYTE *)v13;
      v15 = *(_BYTE *)v13 < *(_BYTE *)v14;
      if ( *(_BYTE *)v13 != *(_BYTE *)v14 )
        break;
      if ( !(_BYTE)v10 )
        goto LABEL_13;
      LOBYTE(v10) = *(_BYTE *)(v13 + 1);
      v15 = (_BYTE)v10 < *(_BYTE *)(v14 + 1);
      if ( (_BYTE)v10 != *(_BYTE *)(v14 + 1) )
        break;
      v13 += 2;
      v14 += 2;
      if ( !(_BYTE)v10 )
      {
LABEL_13:
        v16 = 1;
        goto LABEL_16;
      }
    }
    v16 = (-v15 | 1) == 0;
  }
  else
  {
    v16 = *(_DWORD *)(v11 + 20) == a4;
  }
LABEL_16:
  if ( v16 )
  {
    result = v11 + 24;
  }
  else
  {
LABEL_24:
    lpMem = 0;
    v26 = a4;
    LOBYTE(v29) = 3;
    sub_10004DA0((int)&v27, v10, (int)&unk_1006A330);
    LOBYTE(v29) = 4;
    v19 = *v4;
    v20 = sub_1000AF70((int)&lpMem);
    sub_1000B030((int)v19, (int)&v24, v11, v20 + 16, v20);
    v18 = v24 + 24;
    LOBYTE(v29) = 5;
    sub_10004F60((int)&v27, (int)v4);
    if ( lpMem )
    {
      if ( v26 == 1 )
        sub_100282F6((int)v4, lpMem);
    }
    result = v18;
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;

//----- (100059C0) --------------------------------------------------------
void __usercall sub_100059C0(int a1<ecx>, int a2<ebx>)
{
  int v2; // esi@1

  v2 = a1;
  sub_10004F60(a1 + 8, a2);
  if ( *(_DWORD *)v2 )
  {
    if ( *(_DWORD *)(v2 + 4) == 1 )
      sub_100282F6(a2, *(LPVOID *)v2);
  }
}

//----- (10005A20) --------------------------------------------------------
int __fastcall sub_10005A20(int a1, int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // eax@2
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // esi@2
  int v9; // eax@6
  int v10; // edx@6
  int v11; // esi@6
  void *v12; // edi@6
  int v13; // eax@7
  int v14; // ecx@8
  unsigned __int8 v15; // cf@9
  char v16; // zf@13
  int result; // eax@17
  void *v18; // eax@19
  int v19; // ebx@21
  int v20; // esi@21
  int v21; // edi@21
  int v22; // eax@21
  int v23; // [sp+Ch] [bp-48h]@5
  int v24; // [sp+14h] [bp-40h]@2
  int v25; // [sp+18h] [bp-3Ch]@2
  int v26; // [sp+20h] [bp-34h]@6
  int v27; // [sp+24h] [bp-30h]@2
  int v28; // [sp+28h] [bp-2Ch]@1
  LPVOID lpMem; // [sp+2Ch] [bp-28h]@21
  int v30; // [sp+30h] [bp-24h]@21
  char v31; // [sp+34h] [bp-20h]@21
  unsigned int v32; // [sp+44h] [bp-10h]@1
  int v33; // [sp+50h] [bp-4h]@2
  int v34; // [sp+54h] [bp+0h]@1

  v32 = (unsigned int)&v34 ^ __security_cookie;
  v4 = a1;
  v28 = a1;
  if ( !*(_BYTE *)(a1 + 8) )
  {
    v24 = v24 & 0xFFFFFE07 | 7;
    v25 = 0;
    v5 = sub_10027EB3(a2, a1, a3, a1, 8);
    v8 = v5;
    v27 = v5;
    v33 = 0;
    if ( v5 )
    {
      *(_DWORD *)v5 = 0;
      *(_DWORD *)(v5 + 4) = 0;
      *(_DWORD *)v5 = sub_1000A430(v6, v7, a3, v4);
    }
    else
    {
      v8 = 0;
    }
    v23 = v8;
    v33 = 1;
    sub_10004FF0(v4, v6, (int)&v23);
    v33 = -1;
    sub_10004F60((int)&v23, a3);
  }
  v26 = a3;
  v27 = 2;
  v33 = 2;
  v12 = *(void **)v4;
  v9 = sub_10007FE0(v12, (int)&v26);
  v11 = v9;
  if ( v9 == *(_DWORD *)v12 )
    goto LABEL_27;
  v13 = *(_DWORD *)(v9 + 16);
  if ( v13 )
  {
    v14 = a3;
    while ( 1 )
    {
      LOBYTE(v10) = *(_BYTE *)v13;
      v15 = *(_BYTE *)v13 < *(_BYTE *)v14;
      if ( *(_BYTE *)v13 != *(_BYTE *)v14 )
        break;
      if ( !(_BYTE)v10 )
        goto LABEL_13;
      LOBYTE(v10) = *(_BYTE *)(v13 + 1);
      v15 = (_BYTE)v10 < *(_BYTE *)(v14 + 1);
      if ( (_BYTE)v10 != *(_BYTE *)(v14 + 1) )
        break;
      v13 += 2;
      v14 += 2;
      if ( !(_BYTE)v10 )
      {
LABEL_13:
        v16 = 1;
        goto LABEL_16;
      }
    }
    v16 = (-v15 | 1) == 0;
  }
  else
  {
    v16 = *(_DWORD *)(v11 + 20) == 2;
  }
LABEL_16:
  if ( v16 )
  {
    result = v11 + 24;
  }
  else
  {
LABEL_27:
    if ( a3 )
      v18 = (void *)loc_10004C50(a3, -1);
    else
      v18 = 0;
    v19 = 2 - (a3 != 0);
    lpMem = v18;
    v30 = 2 - (a3 != 0);
    LOBYTE(v33) = 3;
    sub_10004DA0((int)&v31, v10, (int)&unk_1006A330);
    LOBYTE(v33) = 4;
    v21 = *(_DWORD *)v28;
    v22 = sub_1000AF70((int)&lpMem);
    sub_1000B030(v21, (int)&v28, v11, v22 + 16, v22);
    v20 = v28 + 24;
    LOBYTE(v33) = 5;
    sub_10004F60((int)&v31, v19);
    if ( lpMem )
    {
      if ( v30 == 1 )
        sub_100282F6(v19, lpMem);
    }
    result = v20;
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;

//----- (10005BD0) --------------------------------------------------------
int __fastcall sub_10005BD0(int a1, int a2, int a3, int a4, int a5)
{
  char v5; // zf@1
  int v6; // eax@2
  int v7; // eax@3
  void *v8; // esi@3
  int v10; // [sp+8h] [bp-14h]@3
  int v11; // [sp+Ch] [bp-10h]@3
  char v12; // [sp+10h] [bp-Ch]@3
  int v13; // [sp+14h] [bp-8h]@1

  v5 = *(_BYTE *)(a1 + 8) == 0;
  v13 = 0;
  if ( v5
    || (v8 = *(void **)a1,
        v10 = (int)"flags",
        v11 = 0,
        v7 = *(_DWORD *)sub_10007250(v8, (int)&v12, (int)&v10),
        v7 == *(_DWORD *)v8) )
    v6 = (int)&unk_1006A330;
  else
    v6 = v7 + 24;
  if ( (_UNKNOWN *)v6 == &unk_1006A330 )
    v6 = a5;
  sub_10004DA0(a3, a2, v6);
  return a3;
}

//----- (10005C30) --------------------------------------------------------
int __thiscall sub_10005C30(void *this, int a2)
{
  void *v2; // edi@1
  char v3; // zf@1
  int result; // eax@2
  unsigned int v5; // eax@3
  unsigned int v6; // ebx@3
  int v7; // edi@7
  int v8; // esi@7
  int v9; // edx@8
  int v10; // ecx@9
  int v11; // ecx@10
  char v12; // al@11
  int *v13; // ecx@13
  int v14; // eax@15
  int v15; // ecx@17
  int v16; // eax@17
  int v17; // eax@34
  int j; // eax@35
  int i; // eax@38
  int v20; // ecx@43
  void *v21; // [sp+10h] [bp-3Ch]@8
  int v22; // [sp+20h] [bp-2Ch]@8
  unsigned int v23; // [sp+24h] [bp-28h]@8
  unsigned int v24; // [sp+28h] [bp-24h]@3
  unsigned int v25; // [sp+2Ch] [bp-20h]@3
  int v26; // [sp+30h] [bp-1Ch]@3
  int v27; // [sp+34h] [bp-18h]@1
  int v28; // [sp+38h] [bp-14h]@10
  int v29; // [sp+48h] [bp-4h]@3

  v2 = this;
  v3 = *((_BYTE *)this + 8) == 0;
  v27 = 0;
  if ( v3 )
  {
    result = a2;
    *(_DWORD *)a2 = 0;
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)(a2 + 8) = 0;
  }
  else
  {
    v6 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v29 = 0;
    v5 = *(_DWORD *)(*(_DWORD *)this + 4);
    if ( v5 )
    {
      if ( v5 > 0xAAAAAAA )
        sub_10021C1A((int)"vector<T> too long");
      loc_100088D0(&v24, v5);
      v6 = v25;
    }
    v7 = **(_DWORD **)v2;
    v8 = *(_DWORD *)v7;
    while ( v8 != v7 )
    {
      v9 = *(_DWORD *)(v8 + 16);
      v23 = 15;
      v22 = 0;
      LOBYTE(v21) = 0;
      if ( *(_BYTE *)v9 )
      {
        v11 = v9;
        v28 = v9 + 1;
        do
          v12 = *(_BYTE *)v11++;
        while ( v12 );
        v10 = v11 - v28;
      }
      else
      {
        v10 = 0;
      }
      loc_10001BD0(&v21, v9, v10);
      LOBYTE(v29) = 1;
      if ( (unsigned int)&v21 >= v6 || (v13 = (int *)&v21, v24 > (unsigned int)&v21) )
      {
        if ( v6 == v26 )
        {
          loc_10008970(&v24, v13);
          v6 = v25;
        }
        if ( v6 )
        {
          *(_DWORD *)(v6 + 20) = 15;
          *(_DWORD *)(v6 + 16) = 0;
          *(_BYTE *)v6 = 0;
          if ( v23 >= 0x10 )
          {
            *(_DWORD *)v6 = v21;
            v21 = 0;
          }
          else
          {
            if ( v22 != -1 )
              sub_100237D0((void *)v6, &v21, v22 + 1);
          }
          *(_DWORD *)(v6 + 16) = v22;
          *(_DWORD *)(v6 + 20) = v23;
          v23 = 15;
          v22 = 0;
          LOBYTE(v21) = 0;
        }
      }
      else
      {
        v14 = (signed int)((char *)&v21 - v24) / 24;
        v28 = (signed int)((char *)&v21 - v24) / 24;
        if ( v6 == v26 )
        {
          loc_10008970(
            &v24,
            (signed int)((unsigned __int64)(715827883i64 * (signed int)((char *)&v21 - v24)) >> 32) >> 2,
            (char *)&v21 - v24);
          v6 = v25;
          v14 = v28;
        }
        v16 = 3 * v14;
        v15 = v24 + 8 * v16;
        v28 = v24 + 8 * v16;
        if ( v6 )
        {
          *(_DWORD *)(v6 + 20) = 15;
          *(_DWORD *)(v6 + 16) = 0;
          *(_BYTE *)v6 = 0;
          if ( *(_DWORD *)(v15 + 20) >= 0x10u )
          {
            *(_DWORD *)v6 = *(_DWORD *)v15;
            *(_DWORD *)v15 = 0;
          }
          else
          {
            if ( *(_DWORD *)(v15 + 16) != -1 )
            {
              sub_100237D0((void *)v6, (const void *)v15, *(_DWORD *)(v15 + 16) + 1);
              v15 = v28;
            }
          }
          *(_DWORD *)(v6 + 16) = *(_DWORD *)(v15 + 16);
          *(_DWORD *)(v6 + 20) = *(_DWORD *)(v15 + 20);
          *(_DWORD *)(v15 + 20) = 15;
          *(_DWORD *)(v15 + 16) = 0;
          *(_BYTE *)v15 = 0;
        }
      }
      v6 += 24;
      LOBYTE(v29) = 0;
      v25 = v6;
      if ( v23 >= 0x10 )
        sub_1002404A(v21);
      if ( !*(_BYTE *)(v8 + 13) )
      {
        v17 = *(_DWORD *)(v8 + 8);
        if ( *(_BYTE *)(v17 + 13) )
        {
          for ( i = *(_DWORD *)(v8 + 4); !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 4) )
          {
            if ( v8 != *(_DWORD *)(i + 8) )
              break;
            v8 = i;
          }
          v8 = i;
        }
        else
        {
          v8 = *(_DWORD *)(v8 + 8);
          for ( j = *(_DWORD *)v17; !*(_BYTE *)(j + 13); j = *(_DWORD *)j )
            v8 = j;
        }
      }
    }
    result = a2;
    *(_DWORD *)a2 = v24;
    v20 = v26;
    *(_DWORD *)(a2 + 4) = v6;
    *(_DWORD *)(a2 + 8) = v20;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10005ED0) --------------------------------------------------------
int __userpurge sub_10005ED0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@4
  int v8; // edi@5

  v5 = a2;
  v6 = a4;
  if ( *(_DWORD *)(a4 + 20) >= 0x10u )
    v6 = *(_DWORD *)a4;
  if ( !*(_DWORD *)(a2 + 12) )
  {
    v7 = sub_10021CF0(a1, a2, a2, a3, 16);
    if ( v7 )
    {
      v8 = v7 + 4;
      *(_DWORD *)v7 = 3;
      sub_1002832E(v7 + 4, 4, 3, (void (__thiscall *)(_DWORD))sub_10004CE0, (int)sub_10004CF0);
    }
    else
    {
      v8 = 0;
    }
    *(_DWORD *)(v5 + 12) = v8;
  }
  return loc_10004D00(v6);
}
// 10004CF0: using guessed type int sub_10004CF0();

//----- (10005F70) --------------------------------------------------------
void *__thiscall sub_10005F70(void *this, int a2, unsigned int a3)
{
  int v3; // edx@1
  int v4; // edi@1
  char *v5; // esi@6
  char v6; // al@7
  unsigned __int64 v7; // ST00_8@7
  __int64 v8; // qax@7
  unsigned int v9; // eax@11
  void *v11; // [sp+10h] [bp-2Ch]@1
  int v12; // [sp+14h] [bp-28h]@1
  char v13; // [sp+1Bh] [bp-21h]@4
  char v14; // [sp+34h] [bp-8h]@6
  unsigned int v15; // [sp+38h] [bp-4h]@1
  int v16; // [sp+3Ch] [bp+0h]@1

  v15 = (unsigned int)&v16 ^ __security_cookie;
  v3 = a2;
  v4 = a3;
  v11 = this;
  LOBYTE(v12) = a2;
  if ( (signed int)a3 <= 0 && (signed int)a3 < 0 )
  {
    v3 = -a2;
    v13 = 1;
    v12 = -a2;
    v4 = (unsigned __int64)-__PAIR__(a3, -a2) >> 32;
  }
  else
  {
    v13 = 0;
  }
  v5 = &v14;
  v14 = 0;
  do
  {
    HIDWORD(v7) = v4;
    LODWORD(v7) = v3;
    --v5;
    v8 = sub_10031610(v7, 0xAu, 0);
    v4 = HIDWORD(v8);
    *v5 = (_BYTE)v12 - 10 * v8 + 48;
    v3 = v8;
    v6 = v4 | v8;
    LOBYTE(v12) = v3;
  }
  while ( v4 | v3 );
  if ( v13 != v6 )
  {
    --v5;
    *v5 = 45;
  }
  *((_DWORD *)v11 + 5) = 15;
  *((_DWORD *)v11 + 4) = 0;
  *(_BYTE *)v11 = 0;
  if ( *v5 )
    v9 = strlen(v5);
  else
    v9 = 0;
  loc_10001BD0(v11, v5, v9);
  return v11;
}
// 10067210: using guessed type int __security_cookie;

//----- (10006050) --------------------------------------------------------
void *__thiscall sub_10006050(void *this, int a2, int a3)
{
  int v3; // edx@1
  int v4; // edi@1
  char *v5; // esi@1
  unsigned int v6; // eax@2
  unsigned __int64 v7; // ST00_8@2
  __int64 v8; // qax@2
  void *v10; // [sp+10h] [bp-28h]@1
  char v11; // [sp+14h] [bp-24h]@1
  char v12; // [sp+30h] [bp-8h]@1
  unsigned int v13; // [sp+34h] [bp-4h]@1
  int v14; // [sp+38h] [bp+0h]@1

  v13 = (unsigned int)&v14 ^ __security_cookie;
  v3 = a2;
  v4 = a3;
  v10 = this;
  v11 = a2;
  v5 = &v12;
  v12 = 0;
  do
  {
    HIDWORD(v7) = v4;
    LODWORD(v7) = v3;
    --v5;
    v8 = sub_10031610(v7, 0xAu, 0);
    v4 = HIDWORD(v8);
    *v5 = v11 - 10 * v8 + 48;
    v3 = v8;
    v6 = v4 | v8;
    v11 = v3;
  }
  while ( v4 | v3 );
  *((_DWORD *)v10 + 5) = 15;
  *((_DWORD *)v10 + 4) = v6;
  *(_BYTE *)v10 = v6;
  if ( *v5 != (_BYTE)v6 )
    v6 = strlen(v5);
  loc_10001BD0(v10, v5, v6);
  return v10;
}
// 10067210: using guessed type int __security_cookie;

//----- (100060F0) --------------------------------------------------------
int __usercall sub_100060F0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  char *v3; // ecx@1
  int v4; // esi@1
  __int64 v6; // ST0C_8@1
  char v7; // al@2
  char *v8; // eax@3
  char *v9; // edx@5
  char *v10; // ecx@5
  char v11; // al@6
  char *v12; // edx@11
  int v13; // ecx@16
  char v14; // al@19
  char v15; // al@23
  char v16; // al@26
  int v18; // [sp+10h] [bp-28h]@3
  char v19; // [sp+14h] [bp-24h]@1
  char v20; // [sp+15h] [bp-23h]@3
  unsigned int v21; // [sp+34h] [bp-4h]@1
  int v22; // [sp+38h] [bp+0h]@1

  v21 = (unsigned int)&v22 ^ __security_cookie;
  __asm
  {
    movapd  xmm0, xmm1
    movsd   [esp+38h+var_38], xmm0
  }
  v4 = a1;
  sub_10028248(a2, a3, (int)&v19, 0x20u, (int)"%#.16g", v6);
  v3 = &v19;
  do
    v7 = *v3++;
  while ( v7 );
  v8 = (char *)&v18 + v3 - &v20 + 3;
  if ( *v8 == 48 )
  {
    for ( ; v8 > &v19; --v8 )
    {
      if ( *v8 != 48 )
        break;
    }
    v12 = v8;
    if ( v8 >= &v19 )
    {
      while ( *v8 != 46 )
      {
        if ( (unsigned __int8)(*v8 - 48) > 9u )
        {
          *(_DWORD *)(v4 + 20) = 15;
          *(_DWORD *)(v4 + 16) = 0;
          *(_BYTE *)v4 = 0;
          if ( !v19 )
            goto LABEL_16;
          v10 = &v19;
          v9 = &v20;
          do
            v14 = *v10++;
          while ( v14 );
          goto LABEL_27;
        }
        --v8;
        if ( v8 < &v19 )
          goto LABEL_15;
      }
      v12[2] = 0;
      *(_DWORD *)(v4 + 20) = 15;
      *(_DWORD *)(v4 + 16) = 0;
      *(_BYTE *)v4 = 0;
      if ( !v19 )
        goto LABEL_16;
      v10 = &v19;
      v9 = &v20;
      do
        v15 = *v10++;
      while ( v15 );
      goto LABEL_27;
    }
LABEL_15:
    *(_DWORD *)(v4 + 20) = 15;
    *(_DWORD *)(v4 + 16) = 0;
    *(_BYTE *)v4 = 0;
    if ( v19 )
    {
      v10 = &v19;
      v9 = &v20;
      do
        v16 = *v10++;
      while ( v16 );
      goto LABEL_27;
    }
  }
  else
  {
    *(_DWORD *)(v4 + 20) = 15;
    *(_DWORD *)(v4 + 16) = 0;
    *(_BYTE *)v4 = 0;
    if ( v19 )
    {
      v10 = &v19;
      v9 = &v20;
      do
        v11 = *v10++;
      while ( v11 );
LABEL_27:
      v13 = v10 - v9;
      goto LABEL_28;
    }
  }
LABEL_16:
  v13 = 0;
LABEL_28:
  loc_10001BD0(v4, &v19, v13);
  return v4;
}
// 10067210: using guessed type int __security_cookie;

//----- (10006250) --------------------------------------------------------
int __fastcall sub_10006250(int a1, char a2)
{
  const char *v2; // edi@1
  int v3; // esi@1
  int result; // eax@4

  v3 = a1;
  v2 = "true";
  if ( !a2 )
    v2 = "false";
  *(_DWORD *)(a1 + 20) = 15;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)a1 = 0;
  if ( *v2 )
  {
    loc_10001BD0(a1, v2, strlen(v2));
    result = v3;
  }
  else
  {
    loc_10001BD0(v2, 0);
    result = v3;
  }
  return result;
}

//----- (100062C0) --------------------------------------------------------
int __fastcall sub_100062C0(int a1, int a2)
{
  int v2; // ebx@1
  const char *v3; // edi@1
  int v4; // eax@1
  const char *v5; // ecx@2
  char v6; // cf@3
  int v7; // eax@5
  unsigned int v8; // ecx@9
  int *v9; // eax@11
  int v10; // ecx@14
  int v11; // esi@24
  int v12; // edx@24
  int v13; // ST08_4@24
  int v14; // ecx@25
  int v15; // eax@28
  int v16; // eax@30
  int v17; // eax@30
  int v18; // ecx@35
  int v20; // [sp-8h] [bp-10Ch]@14
  unsigned int v21; // [sp-4h] [bp-108h]@1
  void *v22; // [sp+14h] [bp-F0h]@5
  char v23; // [sp+1Ch] [bp-E8h]@30
  int v24; // [sp+24h] [bp-E0h]@5
  unsigned int v25; // [sp+28h] [bp-DCh]@5
  void *v26; // [sp+2Ch] [bp-D8h]@5
  int v27; // [sp+3Ch] [bp-C8h]@7
  unsigned int v28; // [sp+40h] [bp-C4h]@5
  int v29; // [sp+44h] [bp-C0h]@24
  char v30; // [sp+48h] [bp-BCh]@32
  int (__stdcall **v31)(char); // [sp+94h] [bp-70h]@32
  int *v32; // [sp+DCh] [bp-28h]@9
  int v33; // [sp+ECh] [bp-18h]@9
  unsigned int v34; // [sp+F0h] [bp-14h]@9
  unsigned int v35; // [sp+F4h] [bp-10h]@1
  int v36; // [sp+100h] [bp-4h]@5
  int v37; // [sp+104h] [bp+0h]@1

  v35 = (unsigned int)&v37 ^ __security_cookie;
  v21 = (unsigned int)&v37 ^ __security_cookie;
  v3 = (const char *)a2;
  v2 = a1;
  LOBYTE(v4) = sub_100284D0(a2, (int)&unk_1005C520);
  if ( !v4 )
  {
    v5 = v3;
    if ( !*v3 )
    {
LABEL_5:
      v25 = 15;
      v24 = 0;
      LOBYTE(v22) = 0;
      loc_10001BD0(&v22, &unk_1005C528, 1, v21);
      v36 = 0;
      v7 = sub_1000A4F0((int)&v26, (int)&v22, v3);
      LOBYTE(v36) = 1;
      sub_1000A4F0(v2, v7, (const char *)&unk_1005C528);
      if ( v28 >= 0x10 )
        sub_1002404A(v26);
      v28 = 15;
      v27 = 0;
      LOBYTE(v26) = 0;
      if ( v25 >= 0x10 )
        sub_1002404A(v22);
      return v2;
    }
    while ( 1 )
    {
      v6 = (unsigned __int8)(*v5++ - 1) > 0x1Eu;
      if ( 1 != v6 )
        break;
      if ( !*v5 )
        goto LABEL_5;
    }
  }
  v34 = 15;
  v8 = 2 * strlen(v3) + 3;
  v33 = 0;
  LOBYTE(v32) = 0;
  v36 = 2;
  if ( v8 != 15 )
  {
    if ( (unsigned __int8)loc_10001E40(&v32, v8, 1) )
    {
      v9 = (int *)&v32;
      if ( v34 >= 0x10 )
        v9 = v32;
      v33 = 0;
      *(_BYTE *)v9 = 0;
    }
  }
  loc_10009590(&v32, &unk_1005C528, 1, v21);
  for ( ; *v3; ++v3 )
  {
    LOBYTE(v10) = *v3;
    switch ( *v3 )
    {
      case 34:
        loc_10009590(&v32, &unk_1005C52C, 2);
        break;
      case 92:
        loc_10009590(&v32, &unk_1005C530, 2);
        break;
      case 8:
        loc_10009590(&v32, &unk_1005C534, 2);
        break;
      case 12:
        loc_10009590(&v32, &unk_1005C538, 2);
        break;
      case 10:
        loc_10009590(&v32, &unk_1005C53C, 2);
        break;
      case 13:
        loc_10009590(&v32, &unk_1005C540, 2);
        break;
      case 9:
        loc_10009590(&v32, &unk_1005C544, 2);
        break;
      default:
        if ( (unsigned __int8)(v10 - 1) > 0x1Eu )
        {
          loc_10007D30(&v32, 1, v10);
        }
        else
        {
          sub_100067D0((int)&v29, v10);
          sub_10007530(v12, (int)&v29, v2, v20, v13);
          LOBYTE(v36) = 3;
          v11 = sub_1000A590(&v29);
          if ( v11 )
            v14 = v11 + *(_DWORD *)(*(_DWORD *)v11 + 4);
          else
            v14 = 0;
          *(_DWORD *)(v14 + 20) = *(_DWORD *)(v14 + 20) & 0xFFFFF9FF | 0x800;
          if ( v11 )
            v15 = v11 + *(_DWORD *)(*(_DWORD *)v11 + 4);
          else
            v15 = 0;
          *(_DWORD *)(v15 + 20) |= 4u;
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)v11 + 4) + v11 + 64) = 48;
          v16 = sub_10021CF9((int)&v23, 4, 0);
          (*(void (__cdecl **)(int, _DWORD, _DWORD))v16)(
            v11 + *(_DWORD *)(*(_DWORD *)v11 + 4),
            *(_DWORD *)(v16 + 8),
            *(_DWORD *)(v16 + 12));
          sub_10006DE0(*v3);
          v17 = sub_10007600(&v29, (int)&v26);
          LOBYTE(v36) = 4;
          loc_10009490(&v32, v17, 0, -1);
          if ( v28 >= 0x10 )
            sub_1002404A(v26);
          LOBYTE(v36) = 2;
          v28 = 15;
          v27 = 0;
          LOBYTE(v26) = 0;
          *(int *)((char *)&v29 + *(_DWORD *)(v29 + 4)) = (int)off_1005C64C;
          *(unsigned int *)((char *)&v28 + *(_DWORD *)(v29 + 4)) = *(_DWORD *)(v29 + 4) - 80;
          sub_10007620((int)&v30);
          *(int *)((char *)&v29 + *(_DWORD *)(v29 + 4)) = (int)off_1005C658;
          *(unsigned int *)((char *)&v28 + *(_DWORD *)(v29 + 4)) = *(_DWORD *)(v29 + 4) - 8;
          v31 = &off_1005C6EC;
          sub_10021D4C((int)&v31);
        }
        break;
    }
  }
  loc_10009590(&v32, &unk_1005C528, 1);
  *(_DWORD *)(v2 + 20) = 15;
  *(_DWORD *)(v2 + 16) = 0;
  *(_BYTE *)v2 = 0;
  v18 = v34;
  if ( v34 >= 0x10 )
  {
    *(_DWORD *)v2 = v32;
  }
  else
  {
    if ( v33 != -1 )
    {
      sub_100237D0((void *)v2, &v32, v33 + 1);
      v18 = v34;
    }
  }
  *(_DWORD *)(v2 + 16) = v33;
  *(_DWORD *)(v2 + 20) = v18;
  return v2;
}
// 10006DE0: using guessed type _DWORD __stdcall sub_10006DE0(_DWORD);
// 1000A590: using guessed type int __thiscall sub_1000A590(_DWORD);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005C64C: using guessed type int (*off_1005C64C[6])();
// 1005C658: using guessed type int (*off_1005C658[3])();
// 1005C6EC: using guessed type int (__stdcall *off_1005C6EC)(char);
// 10067210: using guessed type int __security_cookie;

//----- (100067D0) --------------------------------------------------------
void __thiscall sub_100067D0(int this, int a2)
{
  *(_DWORD *)this = &unk_1005C6D8;
  *(_DWORD *)(this + 120) = 0;
  *(_DWORD *)(this + 124) = 0;
  *(_DWORD *)(this + 128) = 0;
  *(_DWORD *)(this + 136) = 0;
  *(_DWORD *)(this + 140) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 52) = 0;
  *(_DWORD *)(this + 56) = 0;
  *(_DWORD *)(this + 60) = 0;
}

//----- (10006860) --------------------------------------------------------
void *__thiscall sub_10006860(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_1005C6D0;
  if ( a2 & 1 )
    sub_1002404A(this);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005C6D0: using guessed type int (__stdcall *off_1005C6D0)(char);

//----- (10006890) --------------------------------------------------------
int __thiscall sub_10006890(void *this, int a2, int a3)
{
  int v4; // esi@1
  int v5; // edi@1

  v4 = (int)this;
  v5 = (int)((char *)this + 4);
  loc_10001BD0((char *)this + 4, &unk_1005C72F, 0);
  sub_10006900(v4, v5, a3);
  loc_10009590(v5, &unk_1005C0D4, 1);
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  loc_10001D10(a2, v5, 0, -1);
  return a2;
}

//----- (10006900) --------------------------------------------------------
int __userpurge sub_10006900<eax>(int a1<ecx>, int a2<edi>, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // eax@3
  void *v6; // eax@3
  unsigned int v7; // edx@3
  int v8; // eax@4
  void *v9; // eax@4
  int v10; // edx@4
  int v11; // eax@5
  int v12; // eax@6
  char v13; // al@7
  int v14; // eax@7
  int v15; // edi@8
  int v16; // esi@8
  int v17; // eax@12
  int v18; // eax@13
  int v19; // esi@13
  int v20; // ecx@13
  char v21; // zf@13
  int v22; // eax@18
  int v23; // edi@18
  int i; // esi@18
  int v25; // edx@22
  int v26; // eax@24
  const char *v27; // edx@26
  char v28; // zf@28
  unsigned int v29; // ecx@29
  int v30; // eax@32
  int v31; // eax@35
  int v32; // eax@36
  int v33; // edi@36
  char v34; // zf@36
  void *v35; // esi@40
  int v36; // [sp+1Ch] [bp-C4h]@8
  int v37; // [sp+1Ch] [bp-C4h]@18
  int v38; // [sp+20h] [bp-C0h]@1
  int v39; // [sp+24h] [bp-BCh]@18
  int v40; // [sp+28h] [bp-B8h]@18
  int v41; // [sp+2Ch] [bp-B4h]@18
  int v42; // [sp+30h] [bp-B0h]@13
  int v43; // [sp+34h] [bp-ACh]@13
  int v44; // [sp+38h] [bp-A8h]@8
  char v45; // [sp+3Ch] [bp-A4h]@13
  void *v46; // [sp+40h] [bp-A0h]@24
  int v47; // [sp+50h] [bp-90h]@28
  unsigned int v48; // [sp+54h] [bp-8Ch]@24
  char v49; // [sp+88h] [bp-58h]@6
  char v50; // [sp+B8h] [bp-28h]@7
  int v51; // [sp+DCh] [bp-4h]@6
  char v52; // [sp+11Ch] [bp+3Ch]@3
  char v53; // [sp+134h] [bp+54h]@5
  char v54; // [sp+14Ch] [bp+6Ch]@6
  char v55; // [sp+164h] [bp+84h]@4
  char v56; // [sp+17Ch] [bp+9Ch]@7
  int v57; // [sp+1A0h] [bp+C0h]@3

  v4 = a1;
  v38 = a1;
  result = *(_BYTE *)(a3 + 8);
  switch ( result )
  {
    case 0:
      result = sub_10006D70("null");
      break;
    case 1:
      v5 = loc_10005370(a3);
      v6 = sub_10005F70(&v52, v5, v7);
      v57 = 0;
      loc_10009490(v4 + 4, v6, 0, -1);
      result = sub_10001A30((int)&v52);
      break;
    case 2:
      v8 = loc_100054B0(a3);
      v9 = sub_10006050(&v55, v8, v10);
      v57 = 1;
      loc_10009490(v4 + 4, v9, 0, -1);
      result = sub_10001A30((int)&v55);
      break;
    case 3:
      loc_10005620(a3);
      __asm { movapd  xmm1, xmm0 }
      v11 = sub_100060F0((int)&v53, a3, a2);
      v57 = 2;
      loc_10009490(v4 + 4, v11, 0, -1);
      result = sub_10001A30((int)&v53);
      break;
    case 4:
      v12 = sub_100062C0((int)&v49, *(_DWORD *)a3);
      v51 = 3;
      loc_10009490(v4 + 4, v12, 0, -1);
      result = sub_10001A30((int)&v54);
      break;
    case 5:
      v13 = sub_10005730((void *)a3);
      v14 = sub_10006250((int)&v50, v13);
      v51 = 4;
      loc_10009490(v4 + 4, v14, 0, -1);
      result = sub_10001A30((int)&v56);
      break;
    case 6:
      v16 = a1 + 4;
      v36 = a1 + 4;
      sub_10006D70("[");
      v15 = 0;
      v44 = sub_100057B0((void *)a3);
      if ( v44 > 0 )
      {
        do
        {
          if ( v15 > 0 )
            loc_10009590(v16, ",", 1);
          if ( *(_BYTE *)(a3 + 8) )
          {
            v19 = *(_DWORD *)a3;
            v20 = *(_DWORD *)a3;
            v42 = 0;
            v43 = v15;
            v18 = *(_DWORD *)sub_10007250((void *)v20, (int)&v45, (int)&v42);
            v21 = v18 == *(_DWORD *)v19;
            v16 = v36;
            if ( v21 )
              v17 = (int)&unk_1006A330;
            else
              v17 = v18 + 24;
          }
          else
          {
            v17 = (int)&unk_1006A330;
          }
          sub_10006900(v17);
          ++v15;
        }
        while ( v15 < v44 );
      }
      result = loc_10009590("]");
      break;
    case 7:
      v39 = 0;
      v40 = 0;
      v41 = 0;
      sub_10005C30((void *)a3, (int)&v39);
      v23 = v4 + 4;
      v51 = 5;
      v37 = v4 + 4;
      sub_10006D70("{");
      v22 = v39;
      for ( i = v39; i != v40; i += 24 )
      {
        if ( i != v22 )
          loc_10009590(v23, ",", 1);
        if ( *(_DWORD *)(i + 20) < 0x10u )
          v25 = i;
        else
          v25 = *(_DWORD *)i;
        v26 = sub_100062C0((int)&v46, v25);
        LOBYTE(v51) = 6;
        loc_10009490(v23, v26, 0, -1);
        LOBYTE(v51) = 5;
        if ( v48 >= 0x10 )
          sub_1002404A(v46);
        v27 = ": ";
        if ( !*(_BYTE *)(v38 + 28) )
          v27 = ":";
        v48 = 15;
        v28 = *v27 == 0;
        v47 = 0;
        LOBYTE(v46) = 0;
        if ( v28 )
        {
          v29 = 0;
        }
        else
        {
          v29 = strlen(v27);
          v23 = v37;
        }
        loc_10009590(v23, v27, v29);
        if ( *(_DWORD *)(i + 20) < 0x10u )
          v30 = i;
        else
          v30 = *(_DWORD *)i;
        if ( *(_BYTE *)(a3 + 8) )
        {
          v33 = *(_DWORD *)a3;
          v42 = v30;
          v43 = 0;
          v32 = *(_DWORD *)sub_10007250((void *)v33, (int)&v45, (int)&v42);
          v34 = v32 == *(_DWORD *)v33;
          v23 = v37;
          if ( v34 )
            v31 = (int)&unk_1006A330;
          else
            v31 = v32 + 24;
        }
        else
        {
          v31 = (int)&unk_1006A330;
        }
        sub_10006900(v31);
        v22 = v39;
      }
      result = loc_10009590(v23, "}", 1);
      v35 = (void *)v39;
      if ( v39 )
      {
        sub_1000D280(v39, v40);
        result = sub_1002404A(v35);
      }
      break;
    default:
      return result;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10006D70) --------------------------------------------------------
int __stdcall sub_10006D70(const char *a1)
{
  int result; // eax@2

  if ( *a1 )
    result = loc_10009590(a1, strlen(a1));
  else
    result = loc_10009590(a1, 0);
  return result;
}

//----- (10006DB0) --------------------------------------------------------
int __thiscall sub_10006DB0(int this, int a2)
{
  int result; // eax@1
  unsigned int v3; // edx@1
  char v4; // cf@2

  v3 = *(_DWORD *)(this + 16);
  result = a2;
  if ( a2 > v3 )
  {
    result = loc_10007D30(a2 - v3, 0);
  }
  else
  {
    v4 = *(_DWORD *)(this + 20) < 0x10u;
    *(_DWORD *)(this + 16) = a2;
    if ( !v4 )
      this = *(_DWORD *)this;
    *(_BYTE *)(this + a2) = 0;
  }
  return result;
}

//----- (10006DE0) --------------------------------------------------------
#error "10006F80: positive sp value has been found (funcsize=125)"

//----- (10006F90) --------------------------------------------------------
int __thiscall sub_10006F90(void *this, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@4
  int v5; // edx@7
  int v6; // esi@8
  int v7; // eax@15
  int i; // edx@17
  int v9; // eax@18
  int v10; // eax@33
  char v11; // cl@36
  int v12; // ecx@37
  int v13; // ecx@40
  int v14; // esi@62
  int v15; // ecx@65
  int result; // eax@67
  int v17; // [sp+18h] [bp-10h]@1

  v3 = (int)this;
  v17 = a3;
  if ( *(_BYTE *)(a3 + 13) )
    sub_10021C48((int)"invalid map/set<T> iterator");
  sub_100081A0(&a3);
  if ( *(_BYTE *)(*(_DWORD *)v17 + 13) )
  {
    v4 = *(_DWORD *)(v17 + 8);
  }
  else
  {
    if ( *(_BYTE *)(*(_DWORD *)(v17 + 8) + 13) )
    {
      v4 = *(_DWORD *)v17;
    }
    else
    {
      v5 = a3;
      v4 = *(_DWORD *)(a3 + 8);
      if ( a3 != v17 )
      {
        *(_DWORD *)(*(_DWORD *)v17 + 4) = a3;
        *(_DWORD *)v5 = *(_DWORD *)v17;
        if ( v5 == *(_DWORD *)(v17 + 8) )
        {
          v6 = v5;
        }
        else
        {
          v6 = *(_DWORD *)(v5 + 4);
          if ( !*(_BYTE *)(v4 + 13) )
            *(_DWORD *)(v4 + 4) = v6;
          *(_DWORD *)v6 = v4;
          *(_DWORD *)(v5 + 8) = *(_DWORD *)(v17 + 8);
          *(_DWORD *)(*(_DWORD *)(v17 + 8) + 4) = v5;
        }
        if ( *(_DWORD *)(*(_DWORD *)v3 + 4) == v17 )
        {
          *(_DWORD *)(*(_DWORD *)v3 + 4) = v5;
        }
        else
        {
          v10 = *(_DWORD *)(v17 + 4);
          if ( *(_DWORD *)v10 == v17 )
            *(_DWORD *)v10 = v5;
          else
            *(_DWORD *)(v10 + 8) = v5;
        }
        *(_DWORD *)(v5 + 4) = *(_DWORD *)(v17 + 4);
        v11 = *(_BYTE *)(v5 + 12);
        *(_BYTE *)(v5 + 12) = *(_BYTE *)(v17 + 12);
        *(_BYTE *)(v17 + 12) = v11;
        goto LABEL_37;
      }
    }
  }
  v6 = *(_DWORD *)(v17 + 4);
  if ( !*(_BYTE *)(v4 + 13) )
    *(_DWORD *)(v4 + 4) = v6;
  if ( *(_DWORD *)(*(_DWORD *)v3 + 4) == v17 )
  {
    *(_DWORD *)(*(_DWORD *)v3 + 4) = v4;
  }
  else
  {
    if ( *(_DWORD *)v6 == v17 )
      *(_DWORD *)v6 = v4;
    else
      *(_DWORD *)(v6 + 8) = v4;
  }
  v7 = *(_DWORD *)v3;
  if ( **(_DWORD **)v3 == v17 )
  {
    if ( *(_BYTE *)(v4 + 13) )
    {
      i = v6;
    }
    else
    {
      v9 = *(_DWORD *)v4;
      for ( i = v4; !*(_BYTE *)(v9 + 13); v9 = *(_DWORD *)v9 )
        i = v9;
      v7 = *(_DWORD *)v3;
    }
    *(_DWORD *)v7 = i;
  }
  if ( *(_DWORD *)(*(_DWORD *)v3 + 8) == v17 )
  {
    if ( *(_BYTE *)(v4 + 13) )
      *(_DWORD *)(*(_DWORD *)v3 + 8) = v6;
    else
      *(_DWORD *)(*(_DWORD *)v3 + 8) = sub_10008180(v4);
  }
LABEL_37:
  v12 = v17;
  if ( *(_BYTE *)(v17 + 12) != 1 )
    goto LABEL_62;
  if ( v4 == *(_DWORD *)(*(_DWORD *)v3 + 4) )
    goto LABEL_61;
  while ( *(_BYTE *)(v4 + 12) == 1 )
  {
    v13 = *(_DWORD *)v6;
    if ( v4 == *(_DWORD *)v6 )
    {
      v13 = *(_DWORD *)(v6 + 8);
      if ( !*(_BYTE *)(v13 + 12) )
      {
        *(_BYTE *)(v13 + 12) = 1;
        *(_BYTE *)(v6 + 12) = 0;
        sub_10008060((void *)v3, v6);
        v13 = *(_DWORD *)(v6 + 8);
      }
      if ( *(_BYTE *)(v13 + 13) )
        goto LABEL_55;
      if ( *(_BYTE *)(*(_DWORD *)v13 + 12) != 1 || *(_BYTE *)(*(_DWORD *)(v13 + 8) + 12) != 1 )
      {
        if ( *(_BYTE *)(*(_DWORD *)(v13 + 8) + 12) == 1 )
        {
          *(_BYTE *)(*(_DWORD *)v13 + 12) = 1;
          *(_BYTE *)(v13 + 12) = 0;
          sub_100080C0((void *)v3, v13);
          v13 = *(_DWORD *)(v6 + 8);
        }
        *(_BYTE *)(v13 + 12) = *(_BYTE *)(v6 + 12);
        *(_BYTE *)(v6 + 12) = 1;
        *(_BYTE *)(*(_DWORD *)(v13 + 8) + 12) = 1;
        sub_10008060((void *)v3, v6);
        break;
      }
    }
    else
    {
      if ( !*(_BYTE *)(v13 + 12) )
      {
        *(_BYTE *)(v13 + 12) = 1;
        *(_BYTE *)(v6 + 12) = 0;
        sub_100080C0((void *)v3, v6);
        v13 = *(_DWORD *)v6;
      }
      if ( *(_BYTE *)(v13 + 13) )
        goto LABEL_55;
      if ( *(_BYTE *)(*(_DWORD *)(v13 + 8) + 12) != 1 || *(_BYTE *)(*(_DWORD *)v13 + 12) != 1 )
      {
        if ( *(_BYTE *)(*(_DWORD *)v13 + 12) == 1 )
        {
          *(_BYTE *)(*(_DWORD *)(v13 + 8) + 12) = 1;
          *(_BYTE *)(v13 + 12) = 0;
          sub_10008060((void *)v3, v13);
          v13 = *(_DWORD *)v6;
        }
        *(_BYTE *)(v13 + 12) = *(_BYTE *)(v6 + 12);
        *(_BYTE *)(v6 + 12) = 1;
        *(_BYTE *)(*(_DWORD *)v13 + 12) = 1;
        sub_100080C0((void *)v3, v6);
        break;
      }
    }
    *(_BYTE *)(v13 + 12) = 0;
LABEL_55:
    v4 = v6;
    v6 = *(_DWORD *)(v6 + 4);
    if ( v4 == *(_DWORD *)(*(_DWORD *)v3 + 4) )
      break;
  }
  v12 = v17;
LABEL_61:
  *(_BYTE *)(v4 + 12) = 1;
LABEL_62:
  v14 = v12 + 16;
  sub_10004F60(v12 + 24, v3);
  if ( *(_DWORD *)v14 )
  {
    if ( *(_DWORD *)(v14 + 4) == 1 )
      sub_100282F6(v3, *(LPVOID *)v14);
  }
  sub_1002404A((LPVOID)v17);
  v15 = *(_DWORD *)(v3 + 4);
  if ( v15 )
    *(_DWORD *)(v3 + 4) = v15 - 1;
  result = a2;
  *(_DWORD *)a2 = a3;
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10007250) --------------------------------------------------------
int __thiscall sub_10007250(void *this, int a2, int a3)
{
  int v3; // eax@1
  int v4; // esi@1
  void *v5; // esi@1
  int v6; // ecx@2
  int v7; // edx@3
  char v8; // bl@6
  int result; // eax@13
  int v11; // [sp+14h] [bp+Ch]@11

  v5 = this;
  v3 = sub_10007FE0(this, a3);
  v4 = *(_DWORD *)v5;
  if ( v3 == v4 )
    goto LABEL_16;
  v6 = *(_DWORD *)a3;
  if ( *(_DWORD *)a3 )
  {
    v7 = *(_DWORD *)(v3 + 16);
    while ( *(_BYTE *)v6 == *(_BYTE *)v7 )
    {
      if ( !*(_BYTE *)v6 )
        goto LABEL_8;
      v8 = *(_BYTE *)(v6 + 1);
      if ( v8 != *(_BYTE *)(v7 + 1) )
        break;
      v6 += 2;
      v7 += 2;
      if ( !v8 )
      {
LABEL_8:
        __asm { sets    cl }
        goto LABEL_11;
      }
    }
    __asm { sets    cl }
  }
  else
  {
    _CL = *(_DWORD *)(a3 + 4) < *(_DWORD *)(v3 + 20);
  }
LABEL_11:
  v11 = v3;
  if ( _CL )
LABEL_16:
    v11 = v4;
  result = a2;
  *(_DWORD *)a2 = v11;
  return result;
}

//----- (10007450) --------------------------------------------------------
int __fastcall sub_10007450(int a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // ecx@3
  int v5; // ebx@3
  int v6; // eax@3
  int v7; // ecx@3
  int v8; // ecx@4
  int result; // eax@7

  v3 = a1;
  if ( *(_DWORD *)(a1 + 8) <= (unsigned int)(*(_DWORD *)(a1 + 16) + 1) )
    loc_100086C0(a1);
  v6 = *(_DWORD *)(v3 + 16);
  v7 = *(_DWORD *)(v3 + 8) - 1;
  *(_DWORD *)(v3 + 12) &= v7;
  v4 = (*(_DWORD *)(v3 + 12) + v6) & v7;
  v5 = 4 * v4;
  if ( !*(_DWORD *)(4 * v4 + *(_DWORD *)(v3 + 4)) )
  {
    v8 = sub_10027EB3(a2, v4, v5, v3, 40);
    if ( !v8 )
      sub_10021BC5();
    *(_DWORD *)(v5 + *(_DWORD *)(v3 + 4)) = v8;
  }
  result = *(_DWORD *)(v3 + 4);
  _EBX = *(_DWORD *)(v5 + result);
  if ( _EBX )
  {
    _ESI = a3;
    __asm
    {
      movq    xmm0, qword ptr [esi]
      movq    qword ptr [ebx], xmm0
    }
    *(_DWORD *)(_EBX + 8) = *(_DWORD *)(a3 + 8);
    *(_DWORD *)(_EBX + 32) = 15;
    *(_DWORD *)(_EBX + 28) = 0;
    *(_BYTE *)(_EBX + 12) = 0;
    loc_10001D10(a3 + 12, 0, -1);
    result = *(_DWORD *)(a3 + 36);
    *(_DWORD *)(_EBX + 36) = result;
  }
  ++*(_DWORD *)(v3 + 16);
  return result;
}

//----- (10007530) --------------------------------------------------------
int __userpurge sub_10007530<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5)
{
  int ebp0; // ebp@0
  int v7; // edi@1
  int v8; // esi@1
  int v9; // ST04_4@1
  int v10; // edx@1

  v7 = a2;
  *(_DWORD *)a2 = &unk_1005C6D8;
  *(_DWORD *)(a2 + 80) = &off_1005C6E0;
  v8 = a2 + 4;
  *(_DWORD *)(a2 + *(_DWORD *)(*(_DWORD *)a2 + 4)) = off_1005C658;
  v9 = *(_DWORD *)(*(_DWORD *)a2 + 4);
  *(_DWORD *)(v9 + a2 - 4) = v9 - 8;
  sub_1000CB20(a1, v7 + *(_DWORD *)(*(_DWORD *)a2 + 4), a3, v7, a2 + 4, v9);
  *(_DWORD *)(v7 + *(_DWORD *)(*(_DWORD *)v7 + 4)) = off_1005C64C;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v7 + 4) + v7 - 4) = *(_DWORD *)(*(_DWORD *)v7 + 4) - 80;
  sub_100096C0(v10, v8, a3, ebp0, v7);
  *(_DWORD *)v8 = &off_1005C610;
  *(_DWORD *)(v8 + 56) = 0;
  *(_DWORD *)(v8 + 60) = 4;
  return v7;
}
// 1005C610: using guessed type int (__stdcall *off_1005C610)(char);
// 1005C64C: using guessed type int (*off_1005C64C[6])();
// 1005C658: using guessed type int (*off_1005C658[3])();
// 1005C6E0: using guessed type int (__stdcall *off_1005C6E0)(char);

//----- (10007600) --------------------------------------------------------
int __thiscall sub_10007600(void *this, int a2)
{
  sub_10008A10((int)((char *)this + 4), a2);
  return a2;
}

//----- (10007620) --------------------------------------------------------
int __thiscall sub_10007620(int this)
{
  int v1; // esi@1
  char v2; // zf@1
  int result; // eax@3
  void *v4; // esi@3
  int v5; // eax@5

  v1 = this;
  v2 = (*(_BYTE *)(this + 60) & 1) == 0;
  *(_DWORD *)this = &off_1005C610;
  if ( !v2 )
    sub_1002404A(**(LPVOID **)(this + 12));
  **(_DWORD **)(v1 + 12) = 0;
  **(_DWORD **)(v1 + 28) = 0;
  **(_DWORD **)(v1 + 44) = 0;
  **(_DWORD **)(v1 + 16) = 0;
  **(_DWORD **)(v1 + 32) = 0;
  result = *(_DWORD *)(v1 + 48);
  *(_DWORD *)result = 0;
  *(_DWORD *)(v1 + 60) &= 0xFFFFFFFEu;
  *(_DWORD *)(v1 + 56) = 0;
  *(_DWORD *)v1 = &off_1005C5D4;
  v4 = *(void **)(v1 + 52);
  if ( v4 )
  {
    if ( *(_DWORD *)v4 )
    {
      v5 = (*(int (**)(void))(**(_DWORD **)v4 + 8))();
      if ( v5 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v5)(v5, 1);
    }
    result = sub_1002404A(v4);
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005C5D4: using guessed type int (__stdcall *off_1005C5D4)(char);
// 1005C610: using guessed type int (__stdcall *off_1005C610)(char);

//----- (100078B0) --------------------------------------------------------
signed int __thiscall sub_100078B0(int this, signed int a2)
{
  unsigned int v2; // esi@1
  signed int result; // eax@7

  v2 = **(_DWORD **)(this + 28);
  if ( !v2 || v2 <= **(_DWORD **)(this + 12) || a2 != -1 && (_BYTE)a2 != *(_BYTE *)(v2 - 1) && *(_BYTE *)(this + 60) & 2 )
  {
    result = -1;
  }
  else
  {
    ++**(_DWORD **)(this + 44);
    --**(_DWORD **)(this + 28);
    if ( a2 == -1 )
    {
      result = 0;
    }
    else
    {
      ***(_BYTE ***)(this + 28) = a2;
      result = a2;
    }
  }
  return result;
}

//----- (10007910) --------------------------------------------------------
signed int __thiscall sub_10007910(int this)
{
  unsigned int v1; // edx@1
  unsigned int *v2; // esi@1
  signed int result; // eax@2
  int v4; // edi@3
  unsigned int v5; // eax@6

  v2 = *(unsigned int **)(this + 28);
  v1 = *v2;
  if ( *v2 )
  {
    v4 = *(_DWORD *)(this + 44);
    if ( v1 >= v1 + *(_DWORD *)v4 )
    {
      if ( *(_BYTE *)(this + 60) & 4 || (v5 = **(_DWORD **)(this + 32), !v5) || v5 <= v1 && *(_DWORD *)(this + 56) <= v1 )
      {
        result = -1;
      }
      else
      {
        if ( *(_DWORD *)(this + 56) < v5 )
          *(_DWORD *)(this + 56) = v5;
        *(_DWORD *)v4 = *(_DWORD *)(this + 56) - *v2;
        result = ***(_BYTE ***)(this + 28);
      }
    }
    else
    {
      result = *(_BYTE *)v1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10007970) --------------------------------------------------------
int __thiscall sub_10007970(int this, int a2, __int64 a3, int a4, char a5)
{
  unsigned int v5; // eax@1
  unsigned int *v6; // edx@1
  int v7; // ebx@1
  int v8; // esi@5
  int v9; // edi@7
  int v10; // esi@7
  __int64 v11; // qax@7
  int v12; // eax@10
  __int64 v13; // qax@15
  int v14; // ecx@15
  int v15; // ecx@18
  int v16; // edx@20
  int v17; // ecx@20
  unsigned int v18; // edx@22
  __int64 v19; // qax@24
  __int64 v20; // qax@26
  __int64 v21; // qax@31
  int v22; // ecx@31
  int v23; // ecx@34
  int result; // eax@37
  int v25; // [sp+Ch] [bp-4h]@5
  int v26; // [sp+28h] [bp+18h]@19
  unsigned int v27; // [sp+28h] [bp+18h]@22

  v7 = this;
  v6 = *(unsigned int **)(this + 32);
  v5 = *v6;
  if ( *v6 )
  {
    if ( *(_DWORD *)(this + 56) < v5 )
      *(_DWORD *)(this + 56) = v5;
  }
  if ( !(a5 & 1) || (v8 = **(_DWORD **)(this + 28), v25 = v8, !v8) )
  {
    if ( a5 & 2 && (v18 = *v6, v27 = v18, v18) )
    {
      if ( a4 == 2 )
      {
        v19 = *(_DWORD *)(this + 56) - **(_DWORD **)(this + 12);
        v10 = v19 + a3;
        v9 = (unsigned __int64)(v19 + a3) >> 32;
      }
      else
      {
        if ( a4 == 1 )
        {
          v20 = (signed int)(v18 - **(_DWORD **)(this + 12));
          v10 = v20 + a3;
          v9 = (unsigned __int64)(v20 + a3) >> 32;
        }
        else
        {
          if ( a4 )
          {
            v10 = dword_10055628;
            v9 = dword_1005562C;
          }
          else
          {
            v9 = HIDWORD(a3);
            v10 = a3;
          }
        }
      }
      if ( v9 >= 0 )
      {
        v22 = **(_DWORD **)(this + 12);
        v21 = *(_DWORD *)(v7 + 56) - v22;
        if ( v9 <= HIDWORD(v21) )
        {
          if ( v9 < HIDWORD(v21) || (unsigned int)v10 <= (_DWORD)v21 )
          {
            v23 = v10 + v22 - v27;
            **(_DWORD **)(v7 + 48) -= v23;
            **(_DWORD **)(v7 + 32) += v23;
            goto LABEL_37;
          }
        }
      }
    }
    else
    {
      v10 = a3;
      v9 = HIDWORD(a3);
      if ( !a3 )
        goto LABEL_37;
    }
LABEL_36:
    v10 = dword_10055628;
    v9 = dword_1005562C;
    goto LABEL_37;
  }
  if ( a4 != 2 )
  {
    if ( a4 == 1 )
    {
      if ( !(a5 & 2) )
      {
        v12 = v8 - **(_DWORD **)(this + 12);
        v10 = v12 + a3;
        v9 = (unsigned __int64)(v12 + a3) >> 32;
        goto LABEL_14;
      }
    }
    else
    {
      if ( !a4 )
      {
        v9 = HIDWORD(a3);
        v10 = a3;
        goto LABEL_14;
      }
    }
    v10 = dword_10055628;
    v9 = dword_1005562C;
    goto LABEL_14;
  }
  v11 = *(_DWORD *)(this + 56) - **(_DWORD **)(this + 12);
  v10 = v11 + a3;
  v9 = (unsigned __int64)(v11 + a3) >> 32;
LABEL_14:
  if ( v9 < 0
    || (v14 = **(_DWORD **)(this + 12), v13 = *(_DWORD *)(v7 + 56) - v14, v9 > HIDWORD(v13))
    || v9 >= HIDWORD(v13) && (unsigned int)v10 > (_DWORD)v13 )
    goto LABEL_36;
  v15 = v10 + v14 - v25;
  **(_DWORD **)(v7 + 44) -= v15;
  **(_DWORD **)(v7 + 28) += v15;
  if ( a5 & 2 )
  {
    v26 = **(_DWORD **)(v7 + 32);
    if ( v26 )
    {
      v16 = **(_DWORD **)(v7 + 28);
      v17 = v26 + **(_DWORD **)(v7 + 48);
      **(_DWORD **)(v7 + 32) = v16;
      **(_DWORD **)(v7 + 48) = v17 - v16;
    }
  }
LABEL_37:
  result = a2;
  *(_DWORD *)(a2 + 4) = v9;
  *(_DWORD *)a2 = v10;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  return result;
}
// 10055628: using guessed type int dword_10055628;
// 1005562C: using guessed type int dword_1005562C;

//----- (10007B40) --------------------------------------------------------
int __thiscall sub_10007B40(int this, int a2, __int64 a3, __int64 a4, int a5, int a6, char a7)
{
  unsigned int v7; // eax@1
  unsigned int *v8; // edx@1
  int v9; // ebx@1
  int v10; // edi@1
  int v11; // esi@1
  int v12; // eax@4
  __int64 v13; // qax@9
  int v14; // ecx@9
  int v15; // ecx@12
  int v16; // edx@14
  int v17; // ecx@14
  __int64 v18; // qax@20
  int v19; // ecx@20
  int v20; // ecx@23
  int result; // eax@26
  int v22; // [sp+Ch] [bp-Ch]@7
  int v23; // [sp+Ch] [bp-Ch]@13

  v11 = a4 + a3;
  v9 = (unsigned __int64)(a4 + a3) >> 32;
  v10 = this;
  v8 = *(unsigned int **)(this + 32);
  v7 = *v8;
  if ( *v8 )
  {
    if ( *(_DWORD *)(this + 56) < v7 )
      *(_DWORD *)(this + 56) = v7;
  }
  v12 = dword_1005562C;
  if ( v11 != dword_10055628 || v9 != dword_1005562C )
  {
    if ( a7 & 1 )
    {
      v22 = **(_DWORD **)(this + 28);
      if ( v22 )
      {
        if ( v9 >= 0 )
        {
          v14 = **(_DWORD **)(this + 12);
          v13 = *(_DWORD *)(v10 + 56) - v14;
          if ( v9 <= HIDWORD(v13) )
          {
            if ( v9 < HIDWORD(v13) || (unsigned int)v11 <= (_DWORD)v13 )
            {
              v15 = v11 + v14 - v22;
              **(_DWORD **)(v10 + 44) -= v15;
              **(_DWORD **)(v10 + 28) += v15;
              if ( a7 & 2 )
              {
                v23 = **(_DWORD **)(v10 + 32);
                if ( v23 )
                {
                  v16 = **(_DWORD **)(v10 + 28);
                  v17 = v23 + **(_DWORD **)(v10 + 48);
                  **(_DWORD **)(v10 + 32) = v16;
                  **(_DWORD **)(v10 + 48) = v17 - v16;
                }
              }
              goto LABEL_26;
            }
          }
        }
        goto LABEL_15;
      }
      v12 = dword_1005562C;
    }
    if ( !(a7 & 2) || !*v8 )
    {
      v9 = v12;
      goto LABEL_25;
    }
    if ( v9 >= 0 )
    {
      v19 = **(_DWORD **)(this + 12);
      v18 = *(_DWORD *)(v10 + 56) - v19;
      if ( v9 <= HIDWORD(v18) )
      {
        if ( v9 < HIDWORD(v18) || (unsigned int)v11 <= (_DWORD)v18 )
        {
          v20 = v11 + v19 - **(_DWORD **)(v10 + 32);
          **(_DWORD **)(v10 + 48) -= v20;
          **(_DWORD **)(v10 + 32) += v20;
          goto LABEL_26;
        }
      }
    }
LABEL_15:
    v9 = dword_1005562C;
LABEL_25:
    v11 = dword_10055628;
  }
LABEL_26:
  result = a2;
  *(_DWORD *)a2 = v11;
  *(_DWORD *)(a2 + 4) = v9;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  return result;
}
// 10055628: using guessed type int dword_10055628;
// 1005562C: using guessed type int dword_1005562C;

//----- (10007C90) --------------------------------------------------------
void *__thiscall sub_10007C90(void *this, char a2)
{
  void *v2; // edi@1
  int v3; // esi@1

  v2 = (char *)this - 80;
  v3 = (int)this;
  *(_DWORD *)(this + *(_DWORD *)(*((_DWORD *)this - 20) + 4) - 80) = off_1005C64C;
  *(_DWORD *)(this + *(_DWORD *)(*((_DWORD *)this - 20) + 4) - 84) = *(_DWORD *)(*((_DWORD *)this - 20) + 4) - 80;
  sub_10007620((int)((char *)this - 76));
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v3 - 80) + 4) + v3 - 80) = off_1005C658;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v3 - 80) + 4) + v3 - 84) = *(_DWORD *)(*(_DWORD *)(v3 - 80) + 4) - 8;
  *(_DWORD *)v3 = &off_1005C6EC;
  sub_10021D4C(v3);
  if ( a2 & 1 )
    sub_1002404A(v2);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005C64C: using guessed type int (*off_1005C64C[6])();
// 1005C658: using guessed type int (*off_1005C658[3])();
// 1005C6EC: using guessed type int (__stdcall *off_1005C6EC)(char);

//----- (10007D00) --------------------------------------------------------
void *__thiscall sub_10007D00(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_10007620(this);
  if ( a2 & 1 )
    sub_1002404A(v2);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10007DE0) --------------------------------------------------------
void *__userpurge sub_10007DE0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6)
{
  void *v7; // esi@1
  char v8; // [sp+0h] [bp-28h]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  char *v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+24h] [bp-4h]@1

  v11 = &v8;
  v7 = (void *)a2;
  v9 = a2;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)a2 = sub_1000A430(a1, a2, a3, a4);
  v12 = 0;
  LOBYTE(v12) = 1;
  LOBYTE(v10) = 0;
  sub_1000A970(v7, a5, v10);
  return v7;
}

//----- (10007E80) --------------------------------------------------------
int __thiscall sub_10007E80(void *this, int a2, int a3, int a4)
{
  int v4; // eax@1
  void *v5; // edi@1
  int v6; // esi@1
  int result; // eax@3
  int v8; // ecx@3
  int v9; // ecx@5
  int i; // edx@6
  int j; // eax@7
  char v12; // [sp+Ch] [bp-4h]@14

  v4 = a3;
  v5 = this;
  v6 = *(_DWORD *)this;
  if ( a3 != **(_DWORD **)this || a4 != v6 )
  {
    for ( ; a3 != a4; v4 = a3 )
    {
      v9 = v4;
      if ( !*(_BYTE *)(v4 + 13) )
      {
        i = *(_DWORD *)(v4 + 8);
        if ( *(_BYTE *)(i + 13) )
        {
          for ( i = *(_DWORD *)(v4 + 4); !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 4) )
          {
            if ( v4 != *(_DWORD *)(i + 8) )
              break;
            v4 = i;
          }
        }
        else
        {
          for ( j = *(_DWORD *)i; !*(_BYTE *)(j + 13); j = *(_DWORD *)j )
            i = j;
        }
        a3 = i;
      }
      sub_10006F90(v5, (int)&v12, v9);
    }
    *(_DWORD *)a2 = v4;
    result = a2;
  }
  else
  {
    sub_10007F40(this, *(_DWORD *)(v6 + 4));
    result = a2;
    *(_DWORD *)(*(_DWORD *)v5 + 4) = *(_DWORD *)v5;
    **(_DWORD **)v5 = *(_DWORD *)v5;
    *(_DWORD *)(*(_DWORD *)v5 + 8) = *(_DWORD *)v5;
    v8 = *(_DWORD *)v5;
    *((_DWORD *)v5 + 1) = 0;
    *(_DWORD *)a2 = *(_DWORD *)v8;
  }
  return result;
}

//----- (10007F40) --------------------------------------------------------
void *__thiscall sub_10007F40(void *this, int a2)
{
  void *result; // eax@1
  int v3; // edi@1
  int i; // esi@1
  void *v5; // [sp+10h] [bp-10h]@1

  result = this;
  v5 = this;
  v3 = a2;
  for ( i = a2; !*(_BYTE *)(i + 13); v3 = i )
  {
    sub_10007F40(result, *(_DWORD *)(i + 8));
    i = *(_DWORD *)i;
    sub_10004F60(v3 + 24, v3 + 16);
    if ( *(_DWORD *)(v3 + 16) )
    {
      if ( *(_DWORD *)(v3 + 20) == 1 )
        sub_100282F6(v3 + 16, *(LPVOID *)(v3 + 16));
    }
    sub_1002404A((LPVOID)v3);
    result = v5;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10007FE0) --------------------------------------------------------
int __thiscall sub_10007FE0(void *this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v4; // eax@2
  int v5; // ecx@3
  char v6; // dl@6

  v2 = *(_DWORD *)this;
  v3 = *(_DWORD *)(*(_DWORD *)this + 4);
  while ( !*(_BYTE *)(v3 + 13) )
  {
    v4 = *(_DWORD *)(v3 + 16);
    if ( v4 )
    {
      v5 = *(_DWORD *)a2;
      while ( *(_BYTE *)v4 == *(_BYTE *)v5 )
      {
        if ( !*(_BYTE *)v4 )
          goto LABEL_8;
        v6 = *(_BYTE *)(v4 + 1);
        if ( v6 != *(_BYTE *)(v5 + 1) )
          break;
        v4 += 2;
        v5 += 2;
        if ( !v6 )
        {
LABEL_8:
          __asm { sets    al }
          goto LABEL_11;
        }
      }
      __asm { sets    al }
    }
    else
    {
      _AL = *(_DWORD *)(v3 + 20) < *(_DWORD *)(a2 + 4);
    }
LABEL_11:
    if ( _AL )
    {
      v3 = *(_DWORD *)(v3 + 8);
    }
    else
    {
      v2 = v3;
      v3 = *(_DWORD *)v3;
    }
  }
  return v2;
}

//----- (10008060) --------------------------------------------------------
int __thiscall sub_10008060(void *this, int a2)
{
  int v2; // esi@1
  int result; // eax@3

  v2 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)v2;
  if ( !*(_BYTE *)(*(_DWORD *)v2 + 13) )
    *(_DWORD *)(*(_DWORD *)v2 + 4) = a2;
  *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
  result = *(_DWORD *)this;
  if ( a2 == *(_DWORD *)(*(_DWORD *)this + 4) )
  {
    *(_DWORD *)(result + 4) = v2;
    *(_DWORD *)v2 = a2;
    *(_DWORD *)(a2 + 4) = v2;
  }
  else
  {
    result = *(_DWORD *)(a2 + 4);
    if ( a2 == *(_DWORD *)result )
    {
      *(_DWORD *)result = v2;
      *(_DWORD *)v2 = a2;
      *(_DWORD *)(a2 + 4) = v2;
    }
    else
    {
      *(_DWORD *)(result + 8) = v2;
      *(_DWORD *)v2 = a2;
      *(_DWORD *)(a2 + 4) = v2;
    }
  }
  return result;
}

//----- (100080C0) --------------------------------------------------------
int __thiscall sub_100080C0(void *this, int a2)
{
  int v2; // eax@1
  int v3; // esi@1
  int result; // eax@3

  v3 = *(_DWORD *)a2;
  *(_DWORD *)a2 = *(_DWORD *)(*(_DWORD *)a2 + 8);
  v2 = *(_DWORD *)(v3 + 8);
  if ( !*(_BYTE *)(v2 + 13) )
    *(_DWORD *)(v2 + 4) = a2;
  *(_DWORD *)(v3 + 4) = *(_DWORD *)(a2 + 4);
  result = *(_DWORD *)this;
  if ( a2 == *(_DWORD *)(*(_DWORD *)this + 4) )
  {
    *(_DWORD *)(result + 4) = v3;
    *(_DWORD *)(v3 + 8) = a2;
    *(_DWORD *)(a2 + 4) = v3;
  }
  else
  {
    result = *(_DWORD *)(a2 + 4);
    if ( a2 == *(_DWORD *)(result + 8) )
    {
      *(_DWORD *)(result + 8) = v3;
      *(_DWORD *)(v3 + 8) = a2;
      *(_DWORD *)(a2 + 4) = v3;
    }
    else
    {
      *(_DWORD *)result = v3;
      *(_DWORD *)(v3 + 8) = a2;
      *(_DWORD *)(a2 + 4) = v3;
    }
  }
  return result;
}

//----- (10008120) --------------------------------------------------------
char __stdcall sub_10008120(int a1, int a2)
{
  char result; // al@3

  if ( *(_DWORD *)a1 )
  {
    if ( strcmp(*(const char **)a1, *(const char **)a2) )
      __asm { sets    al }
    else
      __asm { sets    al }
  }
  else
  {
    result = *(_DWORD *)(a1 + 4) < *(_DWORD *)(a2 + 4);
  }
  return result;
}

//----- (10008180) --------------------------------------------------------
int __fastcall sub_10008180(int a1)
{
  int i; // eax@1

  for ( i = *(_DWORD *)(a1 + 8); !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 8) )
    a1 = i;
  return a1;
}

//----- (100081A0) --------------------------------------------------------
void *__thiscall sub_100081A0(void *this)
{
  int v1; // eax@1
  void *v2; // edx@1
  int v3; // ecx@2
  int j; // eax@3
  int i; // eax@6

  v2 = this;
  v1 = *(_DWORD *)this;
  if ( *(_BYTE *)(*(_DWORD *)this + 13) )
    return v2;
  v3 = *(_DWORD *)(v1 + 8);
  if ( *(_BYTE *)(v3 + 13) )
  {
    for ( i = *(_DWORD *)(v1 + 4); !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 4) )
    {
      if ( *(_DWORD *)v2 != *(_DWORD *)(i + 8) )
        break;
      *(_DWORD *)v2 = i;
    }
    *(_DWORD *)v2 = i;
    return v2;
  }
  for ( j = *(_DWORD *)v3; !*(_BYTE *)(j + 13); j = *(_DWORD *)j )
    v3 = j;
  *(_DWORD *)v2 = v3;
  return v2;
}

//----- (100081F0) --------------------------------------------------------
void *__thiscall sub_100081F0(void *this)
{
  int v1; // eax@1
  void *v2; // edx@1
  int i; // ecx@3
  int v5; // eax@4
  int v6; // ecx@5

  v2 = this;
  v1 = *(_DWORD *)this;
  if ( *(_BYTE *)(*(_DWORD *)this + 13) )
  {
    *(_DWORD *)this = *(_DWORD *)(v1 + 8);
    return this;
  }
  i = *(_DWORD *)v1;
  if ( *(_BYTE *)(*(_DWORD *)v1 + 13) )
  {
    for ( i = *(_DWORD *)(v1 + 4); !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 4) )
    {
      if ( *(_DWORD *)v2 != *(_DWORD *)i )
        break;
      *(_DWORD *)v2 = i;
    }
    if ( *(_BYTE *)(*(_DWORD *)v2 + 13) )
      return v2;
    goto LABEL_11;
  }
  v5 = *(_DWORD *)(i + 8);
  if ( *(_BYTE *)(v5 + 13) )
  {
LABEL_11:
    *(_DWORD *)v2 = i;
    return v2;
  }
  do
  {
    v6 = v5;
    v5 = *(_DWORD *)(v5 + 8);
  }
  while ( !*(_BYTE *)(v5 + 13) );
  *(_DWORD *)v2 = v6;
  return v2;
}

//----- (100082E0) --------------------------------------------------------
int __thiscall sub_100082E0(int this)
{
  int v1; // eax@1
  int v2; // esi@1
  int v3; // edi@6
  int result; // eax@10

  v2 = this;
  v1 = *(_DWORD *)(this + 16);
  if ( v1 )
  {
    do
    {
      --v1;
      if ( !v1 )
        *(_DWORD *)(this + 12) = 0;
    }
    while ( v1 );
    *(_DWORD *)(this + 16) = 0;
  }
  v3 = *(_DWORD *)(this + 8);
  while ( v3 )
  {
    --v3;
    if ( *(_DWORD *)(*(_DWORD *)(v2 + 4) + 4 * v3) )
      sub_1002404A(*(LPVOID *)(*(_DWORD *)(v2 + 4) + 4 * v3));
  }
  result = *(_DWORD *)(v2 + 4);
  if ( result )
    result = sub_1002404A(*(LPVOID *)(v2 + 4));
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10008340) --------------------------------------------------------
int __thiscall sub_10008340(int this, int a2)
{
  int result; // eax@1
  int v3; // edx@1

  result = a2;
  v3 = *(_DWORD *)(this + 12);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)a2 = *(_DWORD *)this;
  *(_DWORD *)(a2 + 8) = v3;
  return result;
}

//----- (10008370) --------------------------------------------------------
int __thiscall sub_10008370(int this, int a2)
{
  int result; // eax@1
  int v3; // edx@1

  result = a2;
  v3 = *(_DWORD *)(this + 12) + *(_DWORD *)(this + 16);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)a2 = *(_DWORD *)this;
  *(_DWORD *)(a2 + 8) = v3;
  return result;
}

//----- (100083A0) --------------------------------------------------------
int __userpurge sub_100083A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int **a5, int a6, int a7, int **a8, int a9, int a10)
{
  int v10; // esi@1
  int v11; // edx@5
  int v12; // edx@9
  int v13; // edi@9
  int v14; // eax@9
  unsigned int v15; // ebx@9
  int v16; // eax@9
  int v17; // edx@18
  int v18; // ebx@20
  char v19; // zf@22
  int v20; // edx@31
  int v21; // ecx@36
  int v22; // ebx@37
  char v23; // zf@39
  int v25; // edi@42
  int v26; // eax@42
  int v27; // edx@42
  char v28; // [sp-28h] [bp-84h]@18
  int v29; // [sp-24h] [bp-80h]@18
  int v30; // [sp-20h] [bp-7Ch]@18
  int **v31; // [sp-1Ch] [bp-78h]@14
  int v32; // [sp-18h] [bp-74h]@14
  int v33; // [sp-14h] [bp-70h]@18
  int v34; // [sp-10h] [bp-6Ch]@1
  int v35; // [sp-Ch] [bp-68h]@1
  int v36; // [sp-8h] [bp-64h]@14
  unsigned int v37; // [sp-4h] [bp-60h]@1
  char v38; // [sp+Ch] [bp-50h]@42
  char v39; // [sp+18h] [bp-44h]@9
  int v40; // [sp+24h] [bp-38h]@1
  char v41; // [sp+28h] [bp-34h]@12
  int ****v42; // [sp+2Ch] [bp-30h]@5
  int v43; // [sp+34h] [bp-28h]@9
  int **v44; // [sp+38h] [bp-24h]@9
  int v45; // [sp+40h] [bp-1Ch]@9
  int v46; // [sp+44h] [bp-18h]@3
  char v47; // [sp+48h] [bp-14h]@16
  unsigned int v48; // [sp+4Ch] [bp-10h]@1
  int v49; // [sp+58h] [bp-4h]@14
  int v50; // [sp+5Ch] [bp+0h]@1

  v48 = (unsigned int)&v50 ^ __security_cookie;
  v37 = (unsigned int)&v50 ^ __security_cookie;
  v10 = a2;
  v40 = a4;
  v34 = 0;
  v35 = 0;
  if ( a5 )
  {
    if ( *a5 )
    {
      v34 = **a5;
    }
    else
    {
      sub_1002210B(a1, (int)&v46, a3, (int)&v34, 3);
      sub_10022167(&v46);
    }
  }
  sub_100098D0(a1, v10, a3, (int)&v42, v34, v35, a7);
  v34 = 0;
  v35 = 0;
  if ( a8 )
  {
    if ( *a8 )
    {
      v34 = **a8;
    }
    else
    {
      sub_1002210B(v11, (int)&v46, a3, (int)&v34, 3);
      sub_10022167(&v46);
    }
  }
  sub_100098D0(v11, v10, a3, (int)&v44, v34, v35, a10);
  v14 = sub_10008340(v10, (int)&v39);
  v13 = v45 - v43;
  v46 = v43 - *(_DWORD *)(v14 + 8);
  v15 = v46;
  v16 = sub_10008370(v10, (int)&v39);
  LOBYTE(v16) = v15 < *(_DWORD *)(v16 + 8) - v45;
  v34 = 0;
  v35 = 0;
  if ( (_BYTE)v16 )
  {
    if ( v44 )
    {
      if ( *v44 )
      {
        v34 = **v44;
      }
      else
      {
        sub_1002210B(v12, (int)&v41, (int)&v34, v13, 3);
        sub_10022167(&v41);
      }
    }
    v36 = v45;
    v49 = 0;
    v31 = 0;
    v32 = 0;
    if ( v42 )
    {
      if ( *v42 )
      {
        v31 = **v42;
      }
      else
      {
        sub_1002210B(v12, (int)&v47, (int)&v31, v13, 3);
        sub_10022167(&v47);
      }
    }
    v33 = v43;
    sub_10008340(v10, (int)&v28);
    v49 = -1;
    sub_1000A9F0(v17, (int)&v39, (int)&v31, *(int ***)&v28, v29, v30, v31, v32, v33, (int **)v34, v35, v36);
    for ( ; v13; --v13 )
    {
      if ( *(_DWORD *)(v10 + 16) )
      {
        v18 = *(_DWORD *)(*(_DWORD *)(v10 + 4) + 4 * (*(_DWORD *)(v10 + 12) & (*(_DWORD *)(v10 + 8) - 1)));
        if ( *(_DWORD *)(v18 + 32) >= 0x10u )
        {
          v36 = *(_DWORD *)(v18 + 12);
          sub_1002404A((LPVOID)v36);
        }
        *(_DWORD *)(v18 + 32) = 15;
        *(_DWORD *)(v18 + 28) = 0;
        *(_BYTE *)(v18 + 12) = 0;
        v19 = *(_DWORD *)(v10 + 16)-- == 1;
        if ( v19 )
          *(_DWORD *)(v10 + 12) = 0;
        else
          ++*(_DWORD *)(v10 + 12);
      }
    }
  }
  else
  {
    if ( v42 )
    {
      if ( *v42 )
      {
        v34 = (int)**v42;
      }
      else
      {
        sub_1002210B(v12, (int)&v47, (int)&v34, v13, 3);
        sub_10022167(&v47);
      }
    }
    v36 = v43;
    v49 = 1;
    sub_10008370(v10, (int)&v31);
    LOBYTE(v49) = 2;
    *(_DWORD *)&v28 = 0;
    v29 = 0;
    if ( v44 )
    {
      if ( *v44 )
      {
        *(_DWORD *)&v28 = **v44;
      }
      else
      {
        sub_1002210B(v20, (int)&v47, (int)&v28, v13, 3);
        sub_10022167(&v47);
      }
    }
    v49 = -1;
    sub_1000AB10(v20, (int)&v39, (int)&v28, *(int ***)&v28, v29, v45, v31, v32, v33, (int **)v34, v35, v36);
    for ( ; v13; --v13 )
    {
      v21 = *(_DWORD *)(v10 + 16);
      if ( v21 )
      {
        v22 = *(_DWORD *)(*(_DWORD *)(v10 + 4) + 4 * ((v21 - 1 + *(_DWORD *)(v10 + 12)) & (*(_DWORD *)(v10 + 8) - 1)));
        if ( *(_DWORD *)(v22 + 32) >= 0x10u )
        {
          v36 = *(_DWORD *)(v22 + 12);
          sub_1002404A((LPVOID)v36);
        }
        *(_DWORD *)(v22 + 32) = 15;
        *(_DWORD *)(v22 + 28) = 0;
        *(_BYTE *)(v22 + 12) = 0;
        v23 = *(_DWORD *)(v10 + 16)-- == 1;
        if ( v23 )
          *(_DWORD *)(v10 + 12) = 0;
      }
    }
  }
  v36 = v46;
  v25 = v40;
  v35 = v40;
  v26 = sub_10008340(v10, (int)&v38);
  sub_100093D0(v26, v27, v35, v36);
  return v25;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (10008830) --------------------------------------------------------
int __thiscall sub_10008830(int this)
{
  int v1; // ecx@1
  int v2; // esi@1
  int v3; // edi@2
  char v4; // zf@4
  int v5; // edi@7
  int result; // eax@11

  v2 = this;
  v1 = *(_DWORD *)(this + 16);
  while ( v1 )
  {
    v3 = *(_DWORD *)(*(_DWORD *)(v2 + 4) + 4 * ((v1 + *(_DWORD *)(v2 + 12) - 1) & (*(_DWORD *)(v2 + 8) - 1)));
    if ( *(_DWORD *)(v3 + 32) >= 0x10u )
      sub_1002404A(*(LPVOID *)(v3 + 12));
    *(_DWORD *)(v3 + 32) = 15;
    *(_DWORD *)(v3 + 28) = 0;
    *(_BYTE *)(v3 + 12) = 0;
    v4 = *(_DWORD *)(v2 + 16)-- == 1;
    v1 = *(_DWORD *)(v2 + 16);
    if ( v4 )
      *(_DWORD *)(v2 + 12) = 0;
  }
  v5 = *(_DWORD *)(v2 + 8);
  while ( v5 )
  {
    --v5;
    if ( *(_DWORD *)(*(_DWORD *)(v2 + 4) + 4 * v5) )
      sub_1002404A(*(LPVOID *)(*(_DWORD *)(v2 + 4) + 4 * v5));
  }
  result = *(_DWORD *)(v2 + 4);
  if ( result )
    result = sub_1002404A(*(LPVOID *)(v2 + 4));
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10008A10) --------------------------------------------------------
int __thiscall sub_10008A10(int this, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  unsigned int v4; // eax@2
  unsigned int v5; // ecx@3
  int v6; // ST08_4@5
  int v7; // ST04_4@5
  int v9; // eax@8
  int v10; // ST08_4@9
  int v11; // ST04_4@9
  int v12; // ecx@11
  void *v13; // [sp+Ch] [bp-20h]@5
  int v14; // [sp+1Ch] [bp-10h]@5
  unsigned int v15; // [sp+20h] [bp-Ch]@5
  unsigned int v16; // [sp+24h] [bp-8h]@1
  int v17; // [sp+2Ch] [bp+0h]@1

  v16 = (unsigned int)&v17 ^ __security_cookie;
  v2 = this;
  v3 = *(_DWORD *)(this + 60);
  if ( v3 & 2 || (v4 = **(_DWORD **)(v2 + 32), !v4) )
  {
    if ( v3 & 4 || (v9 = *(_DWORD *)(v2 + 28), !*(_DWORD *)v9) )
    {
      v15 = 15;
      v14 = 0;
      LOBYTE(v13) = 0;
      *(_DWORD *)(a2 + 20) = 15;
      *(_DWORD *)(a2 + 16) = 0;
      *(_BYTE *)a2 = 0;
      v12 = v15;
      if ( v15 >= 0x10 )
      {
        *(_DWORD *)a2 = v13;
      }
      else
      {
        if ( v14 != -1 )
        {
          sub_100237D0((void *)a2, &v13, v14 + 1);
          v12 = v15;
        }
      }
      *(_DWORD *)(a2 + 16) = v14;
      *(_DWORD *)(a2 + 20) = v12;
    }
    else
    {
      v10 = *(_DWORD *)v9 + **(_DWORD **)(v2 + 44) - **(_DWORD **)(v2 + 12);
      v11 = **(_DWORD **)(v2 + 12);
      v15 = 15;
      v14 = 0;
      LOBYTE(v13) = 0;
      loc_10001BD0(&v13, v11, v10);
      sub_100027E0(a2, (int)&v13);
      if ( v15 >= 0x10 )
      {
        sub_1002404A(v13);
        return a2;
      }
    }
  }
  else
  {
    v5 = *(_DWORD *)(v2 + 56);
    if ( v5 < v4 )
      v5 = **(_DWORD **)(v2 + 32);
    v6 = v5 - **(_DWORD **)(v2 + 16);
    v7 = **(_DWORD **)(v2 + 16);
    v15 = 15;
    v14 = 0;
    LOBYTE(v13) = 0;
    loc_10001BD0(&v13, v7, v6);
    sub_100027E0(a2, (int)&v13);
    if ( v15 >= 0x10 )
    {
      sub_1002404A(v13);
      return a2;
    }
  }
  return a2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (10008B70) --------------------------------------------------------
int __userpurge sub_10008B70<eax>(int a1<ecx>, int a2<edi>, int a3, int a4, int a5, int a6, char a7, unsigned __int8 a8)
{
  char v8; // zf@1
  void *v9; // edi@3
  int v10; // eax@3
  int v11; // eax@3
  int v12; // edx@3
  int v13; // eax@4
  int v14; // eax@7
  int v15; // ecx@11
  unsigned int v16; // edi@14
  int v17; // edi@15
  int v18; // eax@18
  int v19; // edx@18
  int v20; // eax@18
  unsigned __int8 *v21; // eax@20
  int v22; // eax@22
  unsigned __int8 v23; // ST10_1@22
  int v24; // ST08_4@22
  int v25; // ST00_4@22
  int v27; // [sp+10h] [bp-54h]@1
  int v28; // [sp+14h] [bp-50h]@1
  int v29; // [sp+18h] [bp-4Ch]@3
  void *v30; // [sp+20h] [bp-44h]@7
  unsigned int v31; // [sp+34h] [bp-30h]@9
  void *v32; // [sp+38h] [bp-2Ch]@6
  unsigned int v33; // [sp+48h] [bp-1Ch]@6
  unsigned int v34; // [sp+4Ch] [bp-18h]@6
  unsigned int v35; // [sp+50h] [bp-14h]@1
  int v36; // [sp+60h] [bp-4h]@3
  int v37; // [sp+74h] [bp+10h]@22

  v35 = (unsigned int)&v27 ^ __security_cookie;
  v28 = a1;
  v8 = (*(_DWORD *)(a6 + 20) & 0x4000) == 0;
  LOBYTE(v27) = a7;
  if ( v8 )
  {
    (*(void (__stdcall **)(int, int, int, int, int, _DWORD))(*(_DWORD *)a1 + 36))(a3, a4, a5, a6, v27, a8);
  }
  else
  {
    v10 = sub_1000CC00(a6, (int)&v29);
    v36 = 0;
    v11 = sub_1000C040(v12, a3, a2, v10);
    v36 = -1;
    v9 = (void *)v11;
    if ( v29 )
    {
      v13 = (*(int (**)(void))(*(_DWORD *)v29 + 8))();
      if ( v13 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v13)(v13, 1);
    }
    v34 = 15;
    v33 = 0;
    LOBYTE(v32) = 0;
    v36 = 1;
    if ( a8 )
      v14 = sub_1000BBC0(v9, (int)&v30);
    else
      v14 = sub_1000BBA0(v9, (int)&v30);
    sub_1000BBE0((int)&v32, v14);
    if ( v31 >= 0x10 )
      sub_1002404A(v30);
    v15 = v33;
    if ( *(_DWORD *)(a6 + 36) >= 0
      && (*(_DWORD *)(a6 + 36) > 0 || *(_DWORD *)(a6 + 32))
      && (v16 = *(_DWORD *)(a6 + 32), v16 > v33) )
      v17 = v16 - v33;
    else
      v17 = 0;
    if ( (*(_DWORD *)(a6 + 20) & 0x1C0) == 64 )
    {
      v18 = a5;
      v19 = a4;
    }
    else
    {
      v20 = sub_1000A320(v28, (int)&v29, a4, a5, v27, v17);
      v19 = *(_DWORD *)v20;
      v15 = v33;
      v18 = *(_DWORD *)(v20 + 4);
      v17 = 0;
    }
    v29 = v18;
    v21 = (unsigned __int8 *)&v32;
    if ( v34 >= 0x10 )
      v21 = (unsigned __int8 *)v32;
    v22 = sub_1000A2A0(v28, (int)&v29, v19, v29, v21, v15);
    v23 = v27;
    v24 = *(_DWORD *)v22;
    v25 = v28;
    v37 = *(_DWORD *)(v22 + 4);
    *(_DWORD *)(a6 + 32) = 0;
    *(_DWORD *)(a6 + 36) = 0;
    sub_1000A320(v25, a3, v24, v37, v23, v17);
    if ( v34 >= 0x10 )
      sub_1002404A(v32);
  }
  return a3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (10008D60) --------------------------------------------------------
int __thiscall sub_10008D60(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7)
{
  int v8; // edi@1
  int v9; // eax@1
  int v10; // eax@1
  char v11; // [sp+Ch] [bp-54h]@1
  char v12; // [sp+10h] [bp-50h]@1
  char v13; // [sp+18h] [bp-48h]@1
  unsigned int v14; // [sp+5Ch] [bp-4h]@1

  v14 = (unsigned int)&v11 ^ __security_cookie;
  v8 = this;
  v9 = sub_10009E70(this, (int)&v12, (int)"ld", *(_DWORD *)(a5 + 20));
  v10 = sub_10028248(a2, v8, (int)&v13, 0x40u, v9, a7);
  sub_10009F00(v8, a2, a3, a4, a5, a6, (int)&v13, v10);
  return a2;
}
// 10067210: using guessed type int __security_cookie;

//----- (10008DE0) --------------------------------------------------------
int __thiscall sub_10008DE0(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7)
{
  int v8; // edi@1
  int v9; // eax@1
  int v10; // eax@1
  char v11; // [sp+Ch] [bp-54h]@1
  char v12; // [sp+10h] [bp-50h]@1
  char v13; // [sp+18h] [bp-48h]@1
  unsigned int v14; // [sp+5Ch] [bp-4h]@1

  v14 = (unsigned int)&v11 ^ __security_cookie;
  v8 = this;
  v9 = sub_10009E70(this, (int)&v12, (int)"lu", *(_DWORD *)(a5 + 20));
  v10 = sub_10028248(a2, v8, (int)&v13, 0x40u, v9, a7);
  sub_10009F00(v8, a2, a3, a4, a5, a6, (int)&v13, v10);
  return a2;
}
// 10067210: using guessed type int __security_cookie;

//----- (10008E60) --------------------------------------------------------
int __thiscall sub_10008E60(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7, int a8)
{
  int v9; // edi@1
  int v10; // eax@1
  int v11; // eax@1
  char v12; // [sp+Ch] [bp-54h]@1
  char v13; // [sp+10h] [bp-50h]@1
  char v14; // [sp+18h] [bp-48h]@1
  unsigned int v15; // [sp+5Ch] [bp-4h]@1

  v15 = (unsigned int)&v12 ^ __security_cookie;
  v9 = this;
  v10 = sub_10009E70(this, (int)&v13, (int)"Ld", *(_DWORD *)(a5 + 20));
  v11 = sub_10028248(a2, v9, (int)&v14, 0x40u, v10, a7);
  sub_10009F00(v9, a2, a3, a4, a5, a6, (int)&v14, v11);
  return a2;
}
// 10067210: using guessed type int __security_cookie;

//----- (10008EE0) --------------------------------------------------------
int __thiscall sub_10008EE0(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7, int a8)
{
  int v9; // edi@1
  int v10; // eax@1
  int v11; // eax@1
  char v12; // [sp+Ch] [bp-54h]@1
  char v13; // [sp+10h] [bp-50h]@1
  char v14; // [sp+18h] [bp-48h]@1
  unsigned int v15; // [sp+5Ch] [bp-4h]@1

  v15 = (unsigned int)&v12 ^ __security_cookie;
  v9 = this;
  v10 = sub_10009E70(this, (int)&v13, (int)"Lu", *(_DWORD *)(a5 + 20));
  v11 = sub_10028248(a2, v9, (int)&v14, 0x40u, v10, a7);
  sub_10009F00(v9, a2, a3, a4, a5, a6, (int)&v14, v11);
  return a2;
}
// 10067210: using guessed type int __security_cookie;

//----- (10008F70) --------------------------------------------------------
int __userpurge sub_10008F70<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6, unsigned __int8 a7, __int64 a8)
{
  int v8; // edi@1
  signed int v9; // esi@1
  signed int v10; // eax@9
  unsigned int v11; // edx@11
  unsigned int v12; // ecx@11
  int v13; // edi@11
  int v14; // esi@11
  unsigned __int8 v15; // cf@11
  int v16; // eax@11
  char v22; // al@13
  unsigned __int8 v43; // cf@26
  char *v44; // eax@32
  int v45; // edx@32
  int v46; // edi@32
  int v47; // ecx@36
  int v48; // ecx@39
  char v52; // ST38_1@46
  int v53; // eax@46
  int v54; // ST24_4@46
  int v55; // esi@46
  int v56; // [sp+10h] [bp-98h]@1
  int v57; // [sp+14h] [bp-94h]@11
  int v58; // [sp+18h] [bp-90h]@9
  int v59; // [sp+1Ch] [bp-8Ch]@1
  int v60; // [sp+20h] [bp-88h]@1
  int v61; // [sp+24h] [bp-84h]@1
  char v62; // [sp+28h] [bp-80h]@32
  char v63; // [sp+29h] [bp-7Fh]@32
  char v64; // [sp+2Ah] [bp-7Eh]@33
  char v65; // [sp+30h] [bp-78h]@46
  unsigned int v66; // [sp+A4h] [bp-4h]@1

  v66 = (unsigned int)&v56 ^ __security_cookie;
  v60 = a3;
  v8 = *(_DWORD *)(a6 + 28);
  v9 = *(_DWORD *)(a6 + 24);
  v61 = a1;
  v59 = a6;
  if ( v8 > 0 )
    goto LABEL_49;
  if ( v8 < 0 || !v9 )
  {
    if ( !(*(_DWORD *)(a6 + 20) & 0x2000) )
    {
      v9 = 6;
      v8 = 0;
    }
  }
  if ( v8 < 0 || v8 <= 0 && (unsigned int)v9 <= 0x24 )
  {
    v10 = v9;
    v58 = v9;
  }
  else
  {
LABEL_49:
    v10 = 36;
    v58 = 36;
  }
  __asm { movsd   xmm1, [ebp+arg_14] }
  v15 = v9 < (unsigned int)v10;
  v14 = v9 - v10;
  v13 = v8 - (v15 + ((unsigned __int64)v10 >> 32));
  v11 = 0;
  v12 = 0;
  v16 = *(_DWORD *)(v59 + 20) & 0x3000;
  v56 = 0;
  v57 = 0;
  if ( v16 == 8192 )
  {
    __asm
    {
      movapd  xmm0, xmm1
      mulsd   xmm0, ds:qword_1005D358
      ucomisd xmm0, xmm1
      lahf
    }
    if ( __SETP__(_AH & 0x44, 0) )
    {
      __asm
      {
        movsd   xmm4, ds:qword_1005D3A0
        xorps   xmm3, xmm3
        comisd  xmm3, xmm1
      }
      v22 = !(_CF | _ZF);
      if ( !(_CF | _ZF) )
        __asm { xorpd   xmm1, xmm4 }
      __asm
      {
        movsd   xmm0, ds:qword_1005D388
        comisd  xmm1, xmm0
        movsd   xmm2, ds:qword_1005D370
      }
      if ( !_CF )
      {
        do
        {
          if ( v11 >= 0x1388 )
            break;
          __asm { divsd   xmm1, xmm2 }
          v11 += 10;
          __asm { comisd  xmm1, xmm0 }
        }
        while ( !_CF );
        v56 = v11;
      }
      __asm { comisd  xmm1, xmm3 }
      if ( !(_CF | _ZF) )
      {
        if ( v13 >= 0 )
        {
          if ( v13 > 0 || (unsigned int)v14 >= 0xA )
          {
            __asm { movsd   xmm0, ds:qword_1005D350 }
            while ( 1 )
            {
              __asm { comisd  xmm0, xmm1 }
              if ( _CF )
                break;
              if ( v12 >= 0x1388 )
                break;
              v43 = (unsigned int)v14 >= 0xA;
              v14 -= 10;
              v13 = v43 + v13 - 1;
              v12 += 10;
              __asm { mulsd   xmm1, xmm2 }
              if ( v13 <= 0 )
              {
                if ( v13 < 0 || (unsigned int)v14 < 0xA )
                  break;
              }
            }
            v57 = v12;
          }
        }
      }
      if ( v22 )
        __asm { xorpd   xmm1, xmm4 }
    }
  }
  v46 = v59;
  v62 = 37;
  v45 = *(_DWORD *)(v59 + 20);
  v44 = &v63;
  if ( v45 & 0x20 )
  {
    v63 = 43;
    v44 = &v64;
  }
  if ( v45 & 0x10 )
    *v44++ = 35;
  v47 = v45 & 0x3000;
  *(_WORD *)v44 = 10798;
  if ( v45 & 4 )
  {
    if ( v47 != 8192 )
    {
      if ( v47 == 12288 )
      {
        LOBYTE(v48) = 65;
      }
      else
      {
        LOBYTE(v47) = v47 != 4096;
        v48 = 2 * v47 + 69;
      }
      goto LABEL_46;
    }
LABEL_42:
    LOBYTE(v48) = 102;
    goto LABEL_46;
  }
  if ( v47 == 8192 )
    goto LABEL_42;
  if ( v47 == 12288 )
  {
    LOBYTE(v48) = 97;
  }
  else
  {
    LOBYTE(v47) = v47 != 4096;
    v48 = 2 * v47 + 101;
  }
LABEL_46:
  v44[2] = v48;
  __asm { movsd   [esp+0A8h+var_A8], xmm1 }
  v52 = v58;
  v44[3] = 0;
  v53 = sub_10028248(a2, v46, (int)&v65, 0x6Cu, (int)&v62, v52);
  v54 = v14;
  v55 = v60;
  sub_100099F0(v61, v60, a4, a5, v46, a7, (int)&v65, v56, v57, v54, v53);
  return v55;
}
// 10067210: using guessed type int __security_cookie;

//----- (100091B0) --------------------------------------------------------
int __userpurge sub_100091B0<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6, unsigned __int8 a7, __int64 a8)
{
  int v8; // edi@1
  signed int v9; // esi@1
  signed int v10; // eax@9
  unsigned int v11; // edx@11
  unsigned int v12; // ecx@11
  int v13; // edi@11
  int v14; // esi@11
  unsigned __int8 v15; // cf@11
  char v16; // al@12
  unsigned __int8 v37; // cf@25
  int v39; // edi@31
  char v42; // ST38_1@31
  int v43; // eax@31
  int v44; // eax@31
  int v45; // ST24_4@31
  int v46; // esi@31
  int v47; // [sp+10h] [bp-98h]@1
  int v48; // [sp+14h] [bp-94h]@9
  int v49; // [sp+18h] [bp-90h]@11
  int v50; // [sp+1Ch] [bp-8Ch]@11
  int v51; // [sp+20h] [bp-88h]@1
  int v52; // [sp+24h] [bp-84h]@1
  int v53; // [sp+28h] [bp-80h]@11
  char v54; // [sp+30h] [bp-78h]@31
  unsigned int v55; // [sp+A4h] [bp-4h]@1

  v55 = (unsigned int)&v47 ^ __security_cookie;
  v51 = a3;
  v8 = *(_DWORD *)(a6 + 28);
  v9 = *(_DWORD *)(a6 + 24);
  v52 = a1;
  v47 = a6;
  if ( v8 > 0 )
    goto LABEL_34;
  if ( v8 < 0 || !v9 )
  {
    if ( !(*(_DWORD *)(a6 + 20) & 0x2000) )
    {
      v9 = 6;
      v8 = 0;
    }
  }
  if ( v8 < 0 || v8 <= 0 && (unsigned int)v9 <= 0x24 )
  {
    v10 = v9;
    v48 = v9;
  }
  else
  {
LABEL_34:
    v10 = 36;
    v48 = 36;
  }
  __asm { movsd   xmm0, [ebp+arg_14] }
  v15 = v9 < (unsigned int)v10;
  v14 = v9 - v10;
  v13 = v8 - (v15 + ((unsigned __int64)v10 >> 32));
  v53 = *(_DWORD *)(v47 + 20);
  v11 = 0;
  v12 = 0;
  v50 = 0;
  v49 = 0;
  if ( (v53 & 0x3000) == 8192 )
  {
    __asm
    {
      movsd   xmm4, ds:qword_1005D3A0
      xorps   xmm3, xmm3
      comisd  xmm3, xmm0
    }
    v16 = !(_CF | _ZF);
    if ( !(_CF | _ZF) )
      __asm { xorpd   xmm0, xmm4 }
    __asm
    {
      movsd   xmm1, ds:qword_1005D388
      comisd  xmm0, xmm1
      movsd   xmm2, ds:qword_1005D370
    }
    if ( !_CF )
    {
      do
      {
        if ( v11 >= 0x1388 )
          break;
        __asm { divsd   xmm0, xmm2 }
        v11 += 10;
        __asm { comisd  xmm0, xmm1 }
      }
      while ( !_CF );
      v50 = v11;
    }
    __asm { comisd  xmm0, xmm3 }
    if ( !(_CF | _ZF) )
    {
      if ( v13 >= 0 )
      {
        if ( v13 > 0 || (unsigned int)v14 >= 0xA )
        {
          __asm { movsd   xmm1, ds:qword_1005D350 }
          while ( 1 )
          {
            __asm { comisd  xmm1, xmm0 }
            if ( _CF )
              break;
            if ( v12 >= 0x1388 )
              break;
            v37 = (unsigned int)v14 >= 0xA;
            v14 -= 10;
            v13 = v37 + v13 - 1;
            v12 += 10;
            __asm { mulsd   xmm0, xmm2 }
            if ( v13 <= 0 )
            {
              if ( v13 < 0 || (unsigned int)v14 < 0xA )
                break;
            }
          }
          v49 = v12;
        }
      }
    }
    if ( v16 )
      __asm { xorpd   xmm0, xmm4 }
  }
  v39 = v52;
  __asm { movsd   [esp+0A8h+var_A8], xmm0 }
  v42 = v48;
  v43 = sub_10009930(v52, (int)&v53, 76, v53);
  v44 = sub_10028248(a2, v39, (int)&v54, 0x6Cu, v43, v42);
  v45 = v14;
  v46 = v51;
  sub_100099F0(v39, v51, a4, a5, v47, a7, (int)&v54, v50, v49, v45, v44);
  return v46;
}
// 10067210: using guessed type int __security_cookie;

//----- (10009360) --------------------------------------------------------
int __thiscall sub_10009360(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7)
{
  int v8; // edi@1
  int v9; // eax@1
  char v10; // [sp+Ch] [bp-4Ch]@1
  char v11; // [sp+10h] [bp-48h]@1
  unsigned int v12; // [sp+54h] [bp-4h]@1

  v12 = (unsigned int)&v10 ^ __security_cookie;
  v8 = this;
  v9 = sub_10028248(a2, this, (int)&v11, 0x40u, (int)"%p", a7);
  sub_10009F00(v8, a2, a3, a4, a5, a6, (int)&v11, v9);
  return a2;
}
// 10067210: using guessed type int __security_cookie;

//----- (100093D0) --------------------------------------------------------
int __fastcall sub_100093D0(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@1
  int *v6; // eax@2
  int v7; // edi@5
  char v9; // [sp+Ch] [bp-8h]@3
  unsigned int v10; // [sp+10h] [bp-4h]@1
  int v11; // [sp+14h] [bp+0h]@1

  v10 = (unsigned int)&v11 ^ __security_cookie;
  v5 = a1;
  v4 = 0;
  if ( *(_DWORD *)a1 )
  {
    v6 = (int *)**(_DWORD **)a1;
    if ( v6 )
    {
      v4 = *v6;
    }
    else
    {
      sub_1002210B(a2, (int)&v9, 0, a1, 3);
      sub_10022167(&v9);
    }
  }
  v7 = a4 + *(_DWORD *)(v5 + 8);
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  if ( v4 )
  {
    if ( *(_DWORD *)v4 )
    {
      *(_DWORD *)a3 = **(_DWORD **)v4;
    }
    else
    {
      sub_1002210B(a2, (int)&v9, v4, v7, 3);
      sub_10022167(&v9);
    }
  }
  *(_DWORD *)(a3 + 8) = v7;
  return a3;
}
// 10067210: using guessed type int __security_cookie;

//----- (10009460) --------------------------------------------------------
void *__thiscall sub_10009460(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10055634;
  if ( a2 & 1 )
    sub_1002404A(this);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10055634: using guessed type int (__stdcall *off_10055634)(char);

//----- (100096C0) --------------------------------------------------------
int __usercall sub_100096C0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<ebp>, int a5<edi>)
{
  int v5; // eax@1
  int v6; // edi@1
  int v7; // esi@1

  v7 = a2;
  *(_DWORD *)a2 = &off_1005C5D4;
  v5 = sub_10027EB3(a1, a2, a3, a5, 4);
  v6 = v5;
  if ( v5 )
  {
    *(_DWORD *)v5 = 0;
    *(_DWORD *)v5 = sub_10021F12(a3, a4, v5);
  }
  else
  {
    v6 = 0;
  }
  *(_DWORD *)(v7 + 12) = v7 + 4;
  *(_DWORD *)(v7 + 28) = v7 + 20;
  *(_DWORD *)(v7 + 32) = v7 + 24;
  *(_DWORD *)(v7 + 52) = v6;
  *(_DWORD *)(v7 + 44) = v7 + 36;
  *(_DWORD *)(v7 + 16) = v7 + 8;
  *(_DWORD *)(v7 + 48) = v7 + 40;
  *(_DWORD *)(v7 + 8) = 0;
  **(_DWORD **)(v7 + 32) = 0;
  **(_DWORD **)(v7 + 48) = 0;
  **(_DWORD **)(v7 + 12) = 0;
  **(_DWORD **)(v7 + 28) = 0;
  **(_DWORD **)(v7 + 44) = 0;
  return v7;
}
// 1005C5D4: using guessed type int (__stdcall *off_1005C5D4)(char);

//----- (100098D0) --------------------------------------------------------
int __userpurge sub_100098D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7)
{
  char v8; // [sp+8h] [bp-8h]@2
  unsigned int v9; // [sp+Ch] [bp-4h]@1
  int v10; // [sp+10h] [bp+0h]@1

  v9 = (unsigned int)&v10 ^ __security_cookie;
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  if ( a2 )
  {
    *(_DWORD *)a4 = *(_DWORD *)a2;
  }
  else
  {
    sub_1002210B(a1, (int)&v8, a3, a7, 3);
    sub_10022167(&v8);
  }
  *(_DWORD *)(a4 + 8) = a7;
  return a4;
}
// 10067210: using guessed type int __security_cookie;

//----- (10009930) --------------------------------------------------------
int __cdecl sub_10009930(int a1, int a2, char a3, __int16 a4)
{
  int v4; // eax@1
  int v5; // eax@5
  int v6; // ecx@7
  int result; // eax@10

  *(_BYTE *)a2 = 37;
  v4 = a2 + 1;
  if ( a4 & 0x20 )
  {
    *(_BYTE *)v4 = 43;
    v4 = a2 + 2;
  }
  if ( a4 & 0x10 )
    *(_BYTE *)v4++ = 35;
  *(_WORD *)v4 = 10798;
  v5 = v4 + 2;
  if ( a3 )
    *(_BYTE *)v5++ = a3;
  v6 = a4 & 0x3000;
  if ( a4 & 4 )
  {
    if ( v6 != 8192 )
    {
      if ( v6 == 12288 )
      {
        *(_BYTE *)v5 = 65;
        *(_BYTE *)(v5 + 1) = 0;
        result = a2;
      }
      else
      {
        *(_BYTE *)v5 = 2 * (v6 != 4096) + 69;
        *(_BYTE *)(v5 + 1) = 0;
        result = a2;
      }
      return result;
    }
LABEL_13:
    *(_BYTE *)v5 = 102;
    *(_BYTE *)(v5 + 1) = 0;
    return a2;
  }
  if ( v6 == 8192 )
    goto LABEL_13;
  if ( v6 == 12288 )
  {
    *(_BYTE *)v5 = 97;
    *(_BYTE *)(v5 + 1) = 0;
    result = a2;
  }
  else
  {
    *(_BYTE *)v5 = 2 * (v6 != 4096) + 101;
    *(_BYTE *)(v5 + 1) = 0;
    result = a2;
  }
  return result;
}

//----- (100099F0) --------------------------------------------------------
int __cdecl sub_100099F0(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8, int a9, int a10, unsigned int a11)
{
  int v11; // edi@4
  int v12; // eax@6
  int v13; // edx@7
  int v14; // eax@8
  char v15; // cl@10
  int v16; // eax@13
  int v17; // eax@13
  int v18; // edx@13
  int v19; // eax@14
  int *v20; // eax@16
  void *v21; // ebx@18
  int v22; // eax@18
  int v23; // eax@18
  int v24; // edx@18
  int v25; // eax@19
  int v26; // ebx@22
  int *v27; // eax@23
  int v28; // edx@23
  char v29; // cl@23
  int v30; // esi@23
  char v31; // al@23
  int *v32; // esi@26
  char i; // al@28
  unsigned __int8 v34; // zf@34
  unsigned __int8 v35; // sf@34
  int v36; // ebx@34
  unsigned int v37; // esi@37
  int v38; // esi@38
  int v39; // eax@40
  unsigned __int8 *v40; // eax@42
  int v41; // ecx@42
  int v42; // eax@44
  unsigned __int8 *v43; // eax@45
  int v44; // eax@47
  unsigned __int8 *v45; // eax@48
  int *v46; // eax@51
  int v47; // edx@51
  int v48; // ebx@53
  int v49; // eax@53
  int v50; // ST1C_4@53
  int v52; // [sp+50h] [bp-74h]@1
  int v53; // [sp+54h] [bp-70h]@13
  int v54; // [sp+58h] [bp-6Ch]@1
  int v55; // [sp+60h] [bp-64h]@13
  int v56; // [sp+64h] [bp-60h]@13
  unsigned int v57; // [sp+68h] [bp-5Ch]@1
  unsigned int v58; // [sp+6Ch] [bp-58h]@21
  int v59; // [sp+70h] [bp-54h]@13
  int v60; // [sp+74h] [bp-50h]@16
  int v61; // [sp+78h] [bp-4Ch]@1
  __int16 v62; // [sp+7Ch] [bp-48h]@13
  void *v63; // [sp+80h] [bp-44h]@16
  unsigned int v64; // [sp+90h] [bp-34h]@16
  unsigned int v65; // [sp+94h] [bp-30h]@16
  void *v66; // [sp+98h] [bp-2Ch]@21
  int v67; // [sp+A8h] [bp-1Ch]@55
  unsigned int v68; // [sp+ACh] [bp-18h]@26
  unsigned int v69; // [sp+B0h] [bp-14h]@1
  int v70; // [sp+C0h] [bp-4h]@13
  int v71; // [sp+D4h] [bp+10h]@53

  v69 = (unsigned int)&v52 ^ __security_cookie;
  v61 = a2;
  v54 = a5;
  v57 = a11;
  v11 = a11 && (*(_BYTE *)a7 == 43 || *(_BYTE *)a7 == 45);
  v12 = *(_DWORD *)(a5 + 20) & 0x3000;
  v52 = v11;
  if ( v12 == 12288 )
  {
    v14 = v11 + 2;
    v13 = (int)"pP";
    if ( v11 + 2 <= a11 )
    {
      if ( *(_BYTE *)(a7 + v11) == 48 )
      {
        v15 = *(_BYTE *)(a7 + v11 + 1);
        if ( v15 == 120 || v15 == 88 )
        {
          v11 += 2;
          v52 = v14;
        }
      }
    }
  }
  else
  {
    v13 = (int)"eE";
  }
  v59 = sub_10028540(a7, v13);
  v62 = 46;
  LOBYTE(v62) = *(_BYTE *)*sub_10028510(a7, v11);
  v55 = sub_10028540(a7, (int)&v62);
  v16 = sub_1000CC00(a5, (int)&v56);
  v70 = 0;
  v17 = sub_1000C9E0(v18, a7, v11, v16);
  v70 = -1;
  v53 = v17;
  if ( v56 )
  {
    v19 = (*(int (**)(void))(*(_DWORD *)v56 + 8))();
    if ( v19 )
      (**(void (__stdcall ***)(_DWORD))v19)(1);
  }
  LOBYTE(v60) = (*(int (__stdcall **)(signed int))(*(_DWORD *)v53 + 32))(48);
  v65 = 15;
  v64 = 0;
  LOBYTE(v63) = 0;
  loc_1000D0A0(&v63, v57, 0);
  v70 = 1;
  v20 = (int *)&v63;
  if ( v65 >= 0x10 )
    v20 = (int *)v63;
  (*(void (__thiscall **)(int, int, unsigned int, int *))(*(_DWORD *)v53 + 28))(v53, a7, a7 + v57, v20);
  v22 = sub_1000CC00(a5, (int)&v56);
  LOBYTE(v70) = 2;
  v23 = sub_1000C040(v24, a7, v11, v22);
  LOBYTE(v70) = 1;
  v21 = (void *)v23;
  v53 = v23;
  if ( v56 )
  {
    v25 = (*(int (**)(void))(*(_DWORD *)v56 + 8))();
    if ( v25 )
      (**(void (__stdcall ***)(_DWORD))v25)(1);
  }
  sub_1000BB80(v21, (int)&v66);
  LOBYTE(v70) = 3;
  LOBYTE(v58) = (*(int (__thiscall **)(void *))(*(_DWORD *)v21 + 16))(v21);
  if ( v55 == v57 )
  {
    v26 = v59 + a8;
    loc_1000BA70(&v63, v59, a8, v60);
  }
  else
  {
    v30 = v60;
    v26 = v55 + a8;
    loc_1000BA70(&v63, v59, a10, v60);
    loc_1000BA70(&v63, v55 + 1, a9, v30);
    v31 = (*(int (__thiscall **)(int))(*(_DWORD *)v53 + 12))(v53);
    v28 = v55;
    v29 = v31;
    v27 = (int *)&v63;
    if ( v65 >= 0x10 )
      v27 = (int *)v63;
    *((_BYTE *)v27 + v55) = v29;
    loc_1000BA70(&v63, v28, a8, v30);
    v11 = v52;
  }
  v32 = (int *)&v66;
  if ( v68 >= 0x10 )
    v32 = (int *)v66;
  for ( i = *(_BYTE *)v32; *(_BYTE *)v32 != 127; i = *(_BYTE *)v32 )
  {
    if ( i <= 0 )
      break;
    if ( i >= (unsigned int)(v26 - v11) )
      break;
    v26 -= i;
    loc_1000BA70(&v63, v26, 1, v58);
    if ( *((_BYTE *)v32 + 1) > 0 )
      v32 = (int *)((char *)v32 + 1);
  }
  v36 = v54;
  v34 = *(_DWORD *)(v54 + 36) == 0;
  v35 = *(_DWORD *)(v54 + 36) < 0;
  v58 = v64;
  if ( v35 || v35 | v34 && !*(_DWORD *)(v54 + 32) || (v37 = *(_DWORD *)(v54 + 32), v37 <= v64) )
    v38 = 0;
  else
    v38 = v37 - v64;
  v39 = *(_DWORD *)(v54 + 20) & 0x1C0;
  if ( v39 == 64 )
  {
    v45 = (unsigned __int8 *)&v63;
    if ( v65 >= 0x10 )
      v45 = (unsigned __int8 *)v63;
    v42 = sub_1000A2A0(a1, (int)&v54, a3, a4, v45, v11);
  }
  else
  {
    if ( v39 == 256 )
    {
      v43 = (unsigned __int8 *)&v63;
      if ( v65 >= 0x10 )
        v43 = (unsigned __int8 *)v63;
      v44 = sub_1000A2A0(a1, (int)&v54, a3, a4, v43, v11);
      v42 = sub_1000A320(a1, (int)&v54, *(_DWORD *)v44, *(_DWORD *)(v44 + 4), a6, v38);
      v38 = 0;
    }
    else
    {
      v41 = sub_1000A320(a1, (int)&v54, a3, a4, a6, v38);
      v38 = 0;
      v40 = (unsigned __int8 *)&v63;
      if ( v65 >= 0x10 )
        v40 = (unsigned __int8 *)v63;
      v42 = sub_1000A2A0(a1, (int)&v54, *(_DWORD *)v41, *(_DWORD *)(v41 + 4), v40, v11);
    }
  }
  v47 = *(_DWORD *)v42;
  v52 = *(_DWORD *)(v42 + 4);
  v46 = (int *)&v63;
  if ( v65 >= 0x10 )
    v46 = (int *)v63;
  v49 = sub_1000A2A0(a1, (int)&v54, v47, v52, (unsigned __int8 *)v46 + v11, v58 - v11);
  v71 = *(_DWORD *)v49;
  v50 = *(_DWORD *)(v49 + 4);
  *(_DWORD *)(v36 + 32) = 0;
  *(_DWORD *)(v36 + 36) = 0;
  v48 = v61;
  sub_1000A320(a1, v61, v71, v50, a6, v38);
  if ( v68 >= 0x10 )
    sub_1002404A(v66);
  v68 = 15;
  v67 = 0;
  LOBYTE(v66) = 0;
  if ( v65 >= 0x10 )
    sub_1002404A(v63);
  return v48;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (10009E70) --------------------------------------------------------
int __cdecl sub_10009E70(int a1, int a2, int a3, __int16 a4)
{
  int v4; // eax@1
  int v5; // eax@6
  int v6; // edx@8
  int result; // eax@9

  *(_BYTE *)a2 = 37;
  v4 = a2 + 1;
  if ( a4 & 0x20 )
  {
    *(_BYTE *)v4 = 43;
    v4 = a2 + 2;
  }
  if ( a4 & 8 )
    *(_BYTE *)v4++ = 35;
  if ( *(_BYTE *)a3 == 76 )
  {
    *(_WORD *)v4 = 13897;
    *(_BYTE *)(v4 + 2) = 52;
    v5 = v4 + 3;
  }
  else
  {
    *(_BYTE *)v4 = *(_BYTE *)a3;
    v5 = v4 + 1;
  }
  v6 = a4 & 0xE00;
  if ( v6 == 1024 )
  {
    *(_BYTE *)v5 = 111;
    *(_BYTE *)(v5 + 1) = 0;
    result = a2;
  }
  else
  {
    if ( v6 == 2048 )
    {
      *(_BYTE *)v5 = ~(8 * a4) & 0x20 | 0x58;
      *(_BYTE *)(v5 + 1) = 0;
      result = a2;
    }
    else
    {
      *(_BYTE *)v5 = *(_BYTE *)(a3 + 1);
      *(_BYTE *)(v5 + 1) = 0;
      result = a2;
    }
  }
  return result;
}

//----- (10009F00) --------------------------------------------------------
int __cdecl sub_10009F00(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8)
{
  int v8; // edi@1
  int v9; // ebx@4
  char v10; // cl@9
  int v11; // eax@12
  int v12; // eax@12
  int v13; // edx@12
  int v14; // eax@13
  int *v15; // eax@15
  void *v16; // esi@17
  int v17; // eax@17
  int v18; // eax@17
  int v19; // edx@17
  int v20; // eax@18
  int *v21; // esi@20
  char i; // al@24
  unsigned __int8 v23; // zf@30
  unsigned __int8 v24; // sf@30
  int v25; // esi@30
  unsigned int v26; // edi@33
  int v27; // edi@34
  int v28; // eax@36
  int v29; // edx@38
  unsigned __int8 *v30; // ecx@38
  int v31; // eax@40
  unsigned __int8 *v32; // eax@41
  int v33; // eax@43
  unsigned __int8 *v34; // eax@44
  int *v35; // eax@47
  int v36; // edx@47
  int v37; // esi@49
  int v38; // eax@49
  int v39; // ST0C_4@49
  int v41; // [sp+28h] [bp-5Ch]@1
  int v42; // [sp+2Ch] [bp-58h]@12
  int v43; // [sp+30h] [bp-54h]@1
  int v44; // [sp+38h] [bp-4Ch]@12
  int v45; // [sp+3Ch] [bp-48h]@1
  void *v46; // [sp+40h] [bp-44h]@15
  unsigned int v47; // [sp+50h] [bp-34h]@15
  unsigned int v48; // [sp+54h] [bp-30h]@15
  void *v49; // [sp+58h] [bp-2Ch]@20
  int v50; // [sp+68h] [bp-1Ch]@51
  unsigned int v51; // [sp+6Ch] [bp-18h]@20
  unsigned int v52; // [sp+70h] [bp-14h]@1
  int v53; // [sp+80h] [bp-4h]@12
  int v54; // [sp+94h] [bp+10h]@49

  v52 = (unsigned int)&v41 ^ __security_cookie;
  v8 = a8;
  v45 = a2;
  v43 = a5;
  v41 = a7;
  v9 = a8 && (*(_BYTE *)a7 == 43 || *(_BYTE *)a7 == 45);
  if ( (*(_DWORD *)(a5 + 20) & 0xE00) == 2048 )
  {
    if ( v9 + 2 <= (unsigned int)a8 )
    {
      if ( *(_BYTE *)(a7 + v9) == 48 )
      {
        v10 = *(_BYTE *)(a7 + v9 + 1);
        if ( v10 == 120 || v10 == 88 )
          v9 += 2;
      }
    }
  }
  v11 = sub_1000CC00(a5, (int)&v44);
  v53 = 0;
  v12 = sub_1000C9E0(v13, v9, a8, v11);
  v53 = -1;
  v42 = v12;
  if ( v44 )
  {
    v14 = (*(int (**)(void))(*(_DWORD *)v44 + 8))();
    if ( v14 )
      (**(void (__thiscall ***)(_DWORD, _DWORD))v14)(v14, 1);
  }
  v48 = 15;
  v47 = 0;
  LOBYTE(v46) = 0;
  loc_1000D0A0(&v46, a8, 0);
  v53 = 1;
  v15 = (int *)&v46;
  if ( v48 >= 0x10 )
    v15 = (int *)v46;
  (*(void (__thiscall **)(int, int, int, int *))(*(_DWORD *)v42 + 28))(v42, v41, a8 + v41, v15);
  v17 = sub_1000CC00(a5, (int)&v41);
  LOBYTE(v53) = 2;
  v18 = sub_1000C040(v19, v9, a8, v17);
  LOBYTE(v53) = 1;
  v16 = (void *)v18;
  v44 = v18;
  if ( v41 )
  {
    v20 = (*(int (**)(void))(*(_DWORD *)v41 + 8))();
    if ( v20 )
      (**(void (__thiscall ***)(_DWORD, _DWORD))v20)(v20, 1);
  }
  sub_1000BB80(v16, (int)&v49);
  LOBYTE(v53) = 3;
  v21 = (int *)&v49;
  if ( v51 >= 0x10 )
    v21 = (int *)v49;
  if ( *(_BYTE *)v21 != 127 )
  {
    if ( *(_BYTE *)v21 > 0 )
    {
      LOBYTE(v41) = (*(int (__thiscall **)(int))(*(_DWORD *)v44 + 16))(v44);
      for ( i = *(_BYTE *)v21; *(_BYTE *)v21 != 127; i = *(_BYTE *)v21 )
      {
        if ( i <= 0 )
          break;
        if ( i >= (unsigned int)(v8 - v9) )
          break;
        v8 -= i;
        loc_1000BA70(&v46, v8, 1, v41);
        if ( *((_BYTE *)v21 + 1) > 0 )
          v21 = (int *)((char *)v21 + 1);
      }
    }
  }
  v25 = v43;
  v23 = *(_DWORD *)(v43 + 36) == 0;
  v24 = *(_DWORD *)(v43 + 36) < 0;
  v41 = v47;
  if ( v24 || v24 | v23 && !*(_DWORD *)(v43 + 32) || (v26 = *(_DWORD *)(v43 + 32), v26 <= v47) )
    v27 = 0;
  else
    v27 = v26 - v47;
  v28 = *(_DWORD *)(v43 + 20) & 0x1C0;
  if ( v28 == 64 )
  {
    v34 = (unsigned __int8 *)&v46;
    if ( v48 >= 0x10 )
      v34 = (unsigned __int8 *)v46;
    v31 = sub_1000A2A0(a1, (int)&v43, a3, a4, v34, v9);
  }
  else
  {
    if ( v28 == 256 )
    {
      v32 = (unsigned __int8 *)&v46;
      if ( v48 >= 0x10 )
        v32 = (unsigned __int8 *)v46;
      v33 = sub_1000A2A0(a1, (int)&v43, a3, a4, v32, v9);
      v31 = sub_1000A320(a1, (int)&v43, *(_DWORD *)v33, *(_DWORD *)(v33 + 4), a6, v27);
      v27 = 0;
    }
    else
    {
      v29 = sub_1000A320(a1, (int)&v43, a3, a4, a6, v27);
      v27 = 0;
      v30 = (unsigned __int8 *)&v46;
      if ( v48 >= 0x10 )
        v30 = (unsigned __int8 *)v46;
      v31 = sub_1000A2A0(a1, (int)&v43, *(_DWORD *)v29, *(_DWORD *)(v29 + 4), v30, v9);
    }
  }
  v36 = *(_DWORD *)v31;
  v42 = *(_DWORD *)(v31 + 4);
  v35 = (int *)&v46;
  if ( v48 >= 0x10 )
    v35 = (int *)v46;
  v38 = sub_1000A2A0(a1, (int)&v43, v36, v42, (unsigned __int8 *)v35 + v9, v41 - v9);
  v54 = *(_DWORD *)v38;
  v39 = *(_DWORD *)(v38 + 4);
  *(_DWORD *)(v25 + 32) = 0;
  *(_DWORD *)(v25 + 36) = 0;
  v37 = v45;
  sub_1000A320(a1, v45, v54, v39, a6, v27);
  if ( v51 >= 0x10 )
    sub_1002404A(v49);
  v51 = 15;
  v50 = 0;
  LOBYTE(v49) = 0;
  if ( v48 >= 0x10 )
    sub_1002404A(v46);
  return v37;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (1000A2A0) --------------------------------------------------------
int __cdecl sub_1000A2A0(int a1, int a2, int a3, int a4, unsigned __int8 *a5, int a6)
{
  int result; // eax@1
  unsigned __int8 *v7; // ebx@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edx@4
  int v11; // eax@5
  int v12; // ecx@5
  int v13; // edx@5
  unsigned __int8 v14; // [sp+13h] [bp-1h]@3

  result = a2;
  v7 = a5;
  v9 = a4;
  v8 = a6;
  if ( a6 )
  {
    do
    {
      if ( !v9
        || ((v14 = *v7, !**(_DWORD **)(v9 + 32)) || (v10 = *(_DWORD *)(v9 + 48), *(_DWORD *)v10 <= 0) ? (v11 = (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)v9 + 12))(v9, *v7)) : (--*(_DWORD *)v10, v12 = *(_DWORD *)(v9 + 32), v13 = *(_DWORD *)v12, ++*(_DWORD *)v12, *(_BYTE *)v13 = v14, v11 = v14),
            v9 = a4,
            v11 == -1) )
        LOBYTE(a3) = 1;
      ++v7;
      --v8;
    }
    while ( v8 );
    result = a2;
  }
  *(_DWORD *)(result + 4) = v9;
  *(_DWORD *)result = a3;
  return result;
}

//----- (1000A320) --------------------------------------------------------
int __cdecl sub_1000A320(int a1, int a2, int a3, int a4, unsigned __int8 a5, int a6)
{
  int result; // eax@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // ecx@4
  int v10; // eax@5
  int v11; // ecx@5
  int v12; // edx@5

  result = a2;
  v8 = a4;
  v7 = a6;
  if ( a6 )
  {
    do
    {
      if ( !v8
        || (!**(_DWORD **)(v8 + 32) || (v9 = *(_DWORD *)(v8 + 48), *(_DWORD *)v9 <= 0) ? (v10 = (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)v8 + 12))(
                                                                                                  v8,
                                                                                                  a5)) : (--*(_DWORD *)v9, v11 = *(_DWORD *)(v8 + 32), v12 = *(_DWORD *)v11, ++*(_DWORD *)v11, *(_BYTE *)v12 = a5, v10 = a5),
            v8 = a4,
            v10 == -1) )
        LOBYTE(a3) = 1;
      --v7;
    }
    while ( v7 );
    result = a2;
  }
  *(_DWORD *)(result + 4) = v8;
  *(_DWORD *)result = a3;
  return result;
}

//----- (1000A3A0) --------------------------------------------------------
int __fastcall sub_1000A3A0(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@1
  int *v6; // eax@2
  int v7; // edi@5
  char v9; // [sp+Ch] [bp-8h]@3
  unsigned int v10; // [sp+10h] [bp-4h]@1
  int v11; // [sp+14h] [bp+0h]@1

  v10 = (unsigned int)&v11 ^ __security_cookie;
  v5 = a1;
  v4 = 0;
  if ( *(_DWORD *)a1 )
  {
    v6 = (int *)**(_DWORD **)a1;
    if ( v6 )
    {
      v4 = *v6;
    }
    else
    {
      sub_1002210B(a2, (int)&v9, 0, a1, 3);
      sub_10022167(&v9);
    }
  }
  v7 = *(_DWORD *)(v5 + 8) - 1;
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  if ( v4 )
  {
    if ( *(_DWORD *)v4 )
    {
      *(_DWORD *)a3 = **(_DWORD **)v4;
    }
    else
    {
      sub_1002210B(a2, (int)&v9, v4, v7, 3);
      sub_10022167(&v9);
    }
  }
  *(_DWORD *)(a3 + 8) = v7;
  return a3;
}
// 10067210: using guessed type int __security_cookie;

//----- (1000A430) --------------------------------------------------------
int __usercall sub_1000A430<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int result; // eax@1

  result = sub_10027EB3(a1, a2, a3, a4, 40);
  JUMPOUT(result, 0, *(unsigned int *)sub_10021BC5);
  *(_DWORD *)result = result;
  if ( result != -4 )
    *(_DWORD *)(result + 4) = result;
  if ( result != -8 )
    *(_DWORD *)(result + 8) = result;
  *(_WORD *)(result + 12) = 257;
  return result;
}

//----- (1000A460) --------------------------------------------------------
int __fastcall sub_1000A460(int a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@2
  int v5; // esi@3
  char v6; // al@4
  int v7; // eax@6
  int v8; // esi@6
  unsigned int v9; // eax@7
  int result; // eax@10

  v3 = a1;
  if ( *(_BYTE *)a2 )
  {
    v5 = a2;
    a1 = a2 + 1;
    do
      v6 = *(_BYTE *)v5++;
    while ( v6 );
    v4 = v5 - a1;
  }
  else
  {
    v4 = 0;
  }
  v7 = loc_1000ACE0(a3, a1, a2, v4);
  v8 = v7;
  *(_DWORD *)(v3 + 20) = 15;
  *(_DWORD *)(v3 + 16) = 0;
  *(_BYTE *)v3 = 0;
  if ( *(_DWORD *)(v7 + 20) >= 0x10u )
  {
    *(_DWORD *)v3 = *(_DWORD *)v7;
    *(_DWORD *)v7 = 0;
  }
  else
  {
    v9 = *(_DWORD *)(v7 + 16) + 1;
    if ( v9 )
      sub_100237D0((void *)v3, (const void *)v8, v9);
  }
  *(_DWORD *)(v3 + 16) = *(_DWORD *)(v8 + 16);
  *(_DWORD *)(v3 + 20) = *(_DWORD *)(v8 + 20);
  *(_DWORD *)(v8 + 20) = 15;
  *(_DWORD *)(v8 + 16) = 0;
  result = v3;
  *(_BYTE *)v8 = 0;
  return result;
}

//----- (1000A4F0) --------------------------------------------------------
int __fastcall sub_1000A4F0(int a1, int a2, const char *a3)
{
  int v3; // edi@1
  unsigned int v4; // esi@2
  int v5; // eax@4
  int v6; // esi@4
  unsigned int v7; // eax@5
  int result; // eax@8

  v3 = a1;
  if ( *a3 )
    v4 = strlen(a3);
  else
    v4 = 0;
  v5 = loc_10009590(a2, a3, v4);
  v6 = v5;
  *(_DWORD *)(v3 + 20) = 15;
  *(_DWORD *)(v3 + 16) = 0;
  *(_BYTE *)v3 = 0;
  if ( *(_DWORD *)(v5 + 20) >= 0x10u )
  {
    *(_DWORD *)v3 = *(_DWORD *)v5;
    *(_DWORD *)v5 = 0;
  }
  else
  {
    v7 = *(_DWORD *)(v5 + 16) + 1;
    if ( v7 )
      sub_100237D0((void *)v3, (const void *)v6, v7);
  }
  *(_DWORD *)(v3 + 16) = *(_DWORD *)(v6 + 16);
  *(_DWORD *)(v3 + 20) = *(_DWORD *)(v6 + 20);
  *(_DWORD *)(v6 + 20) = 15;
  *(_DWORD *)(v6 + 16) = 0;
  result = v3;
  *(_BYTE *)v6 = 0;
  return result;
}

//----- (1000A590) --------------------------------------------------------
#error "1000A833: positive sp value has been found (funcsize=219)"

//----- (1000A840) --------------------------------------------------------
int __usercall sub_1000A840<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4)
{
  int v4; // edx@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // ecx@5
  int v8; // esi@6
  int v9; // eax@10
  int v10; // edx@17
  int v11; // ecx@17
  char v13; // [sp+Ch] [bp-2Ch]@16
  int v14; // [sp+18h] [bp-20h]@1
  int v15; // [sp+1Ch] [bp-1Ch]@1
  char v16; // [sp+20h] [bp-18h]@1
  char v17; // [sp+24h] [bp-14h]@2
  unsigned int v18; // [sp+28h] [bp-10h]@1
  int v19; // [sp+34h] [bp-4h]@1
  int v20; // [sp+38h] [bp+0h]@1

  v18 = (unsigned int)&v20 ^ __security_cookie;
  v14 = a4;
  sub_1002210B(a1, (int)&v16, a2, a3, 0);
  v19 = 0;
  v6 = dword_1006A384;
  v5 = dword_1006A0E0;
  v15 = dword_1006A0E0;
  if ( !dword_1006A384 )
  {
    sub_1002210B(v4, (int)&v17, dword_1006A0E0, dword_1006A384, dword_1006A384);
    if ( dword_1006A384 == v6 )
    {
      ++dword_10068F04;
      dword_1006A384 = dword_10068F04;
    }
    sub_10022167(&v17);
    v6 = dword_1006A384;
  }
  v7 = *(_DWORD *)a4;
  if ( (unsigned int)v6 >= *(_DWORD *)(*(_DWORD *)a4 + 12) )
  {
    v8 = 0;
  }
  else
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v7 + 8) + 4 * v6);
    if ( v8 )
      goto LABEL_18;
  }
  if ( !*(_BYTE *)(v7 + 20) )
    goto LABEL_12;
  v9 = sub_10021F0C();
  if ( (unsigned int)v6 < *(_DWORD *)(v9 + 12) )
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v9 + 8) + 4 * v6);
LABEL_12:
    if ( v8 )
      goto LABEL_18;
  }
  if ( v5 )
  {
    v8 = v5;
  }
  else
  {
    if ( sub_1000AC30(v7, v4, (int)&v15, v14) == -1 )
    {
      sub_10023634((int)&v13, (unsigned int)"bad cast");
      sub_1002D02B((int)&v13, (int)&unk_10061540);
    }
    v8 = v15;
    dword_1006A0E0 = v15;
    (*(void (__thiscall **)(int))(*(_DWORD *)v15 + 4))(v15);
    sub_10021EE4(v10, v11, v5, v6, v8);
  }
LABEL_18:
  sub_10022167(&v16);
  return v8;
}
// 10067210: using guessed type int __security_cookie;
// 10068F04: using guessed type int dword_10068F04;
// 1006A0E0: using guessed type int dword_1006A0E0;
// 1006A384: using guessed type int dword_1006A384;

//----- (1000A970) --------------------------------------------------------
int __thiscall sub_1000A970(void *this, int a2, int a3)
{
  int v3; // edx@1
  int v4; // ecx@1
  void *v5; // ebx@1
  int i; // eax@2
  int result; // eax@4
  int v8; // ecx@4

  v5 = this;
  *(_DWORD *)(*(_DWORD *)this + 4) = sub_1000B250(this, *(_DWORD *)(*(_DWORD *)a2 + 4), *(_DWORD *)this, a3);
  v3 = *(_DWORD *)v5;
  *((_DWORD *)v5 + 1) = *(_DWORD *)(a2 + 4);
  v4 = *(_DWORD *)(v3 + 4);
  if ( *(_BYTE *)(v4 + 13) )
  {
    *(_DWORD *)v3 = v3;
    result = *(_DWORD *)v5;
    *(_DWORD *)(result + 8) = result;
  }
  else
  {
    for ( i = *(_DWORD *)v4; !*(_BYTE *)(i + 13); i = *(_DWORD *)i )
      v4 = i;
    *(_DWORD *)v3 = v4;
    v8 = *(_DWORD *)(*(_DWORD *)v5 + 4);
    for ( result = *(_DWORD *)(v8 + 8); !*(_BYTE *)(result + 13); result = *(_DWORD *)(result + 8) )
      v8 = result;
    *(_DWORD *)(*(_DWORD *)v5 + 8) = v8;
  }
  return result;
}

//----- (1000A9F0) --------------------------------------------------------
int __usercall sub_1000A9F0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int **a4, int a5, int a6, int **a7, int a8, int a9, int **a10, int a11, int a12)
{
  int v12; // edi@1
  int v14; // [sp-2Ch] [bp-50h]@9
  int v15; // [sp-20h] [bp-44h]@5
  int v16; // [sp-14h] [bp-38h]@1
  char v17; // [sp+8h] [bp-1Ch]@3
  char v18; // [sp+Ch] [bp-18h]@7
  int v19; // [sp+10h] [bp-14h]@11
  unsigned int v20; // [sp+14h] [bp-10h]@1
  int v21; // [sp+20h] [bp-4h]@5
  int v22; // [sp+24h] [bp+0h]@1

  v20 = (unsigned int)&v22 ^ __security_cookie;
  v12 = a2;
  v16 = 0;
  if ( a10 )
  {
    if ( *a10 )
    {
      v16 = **a10;
    }
    else
    {
      sub_1002210B(a1, (int)&v17, a3, a2, 3);
      sub_10022167(&v17);
    }
  }
  v21 = 0;
  v15 = 0;
  if ( a7 )
  {
    if ( *a7 )
    {
      v15 = **a7;
    }
    else
    {
      sub_1002210B(a1, (int)&v18, a3, v12, 3);
      sub_10022167(&v18);
    }
  }
  LOBYTE(v21) = 1;
  v14 = 0;
  if ( a4 )
  {
    if ( *a4 )
    {
      v14 = **a4;
    }
    else
    {
      sub_1002210B(a1, (int)&v19, a3, v12, 3);
      sub_10022167(&v19);
    }
  }
  v21 = -1;
  sub_1000B310(a1, v12, v12, v14, 0, a6, v15, 0, a9, v16, 0, a12);
  return v12;
}
// 10067210: using guessed type int __security_cookie;

//----- (1000AB10) --------------------------------------------------------
int __usercall sub_1000AB10<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int **a4, int a5, int a6, int **a7, int a8, int a9, int **a10, int a11, int a12)
{
  int v12; // edi@1
  int v14; // [sp-2Ch] [bp-50h]@9
  int v15; // [sp-20h] [bp-44h]@5
  int v16; // [sp-14h] [bp-38h]@1
  char v17; // [sp+8h] [bp-1Ch]@3
  char v18; // [sp+Ch] [bp-18h]@7
  int v19; // [sp+10h] [bp-14h]@11
  unsigned int v20; // [sp+14h] [bp-10h]@1
  int v21; // [sp+20h] [bp-4h]@5
  int v22; // [sp+24h] [bp+0h]@1

  v20 = (unsigned int)&v22 ^ __security_cookie;
  v12 = a2;
  v16 = 0;
  if ( a10 )
  {
    if ( *a10 )
    {
      v16 = **a10;
    }
    else
    {
      sub_1002210B(a1, (int)&v17, a3, a2, 3);
      sub_10022167(&v17);
    }
  }
  v21 = 0;
  v15 = 0;
  if ( a7 )
  {
    if ( *a7 )
    {
      v15 = **a7;
    }
    else
    {
      sub_1002210B(a1, (int)&v18, a3, v12, 3);
      sub_10022167(&v18);
    }
  }
  LOBYTE(v21) = 1;
  v14 = 0;
  if ( a4 )
  {
    if ( *a4 )
    {
      v14 = **a4;
    }
    else
    {
      sub_1002210B(a1, (int)&v19, a3, v12, 3);
      sub_10022167(&v19);
    }
  }
  v21 = -1;
  sub_1000B400(v12, v12, v14, 0, a6, v15, 0, a9, v16, 0, a12);
  return v12;
}
// 10067210: using guessed type int __security_cookie;

//----- (1000AC30) --------------------------------------------------------
signed int __fastcall sub_1000AC30(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edx@3
  int v6; // esi@3
  int v7; // ecx@4
  int v8; // eax@5
  char v10; // [sp+10h] [bp-44h]@8
  int v11; // [sp+44h] [bp-10h]@1
  int v12; // [sp+50h] [bp-4h]@3

  v4 = 0;
  v11 = 0;
  if ( a3 )
  {
    if ( !*(_DWORD *)a3 )
    {
      v6 = sub_10027EB3(a2, a1, 0, a3, 8);
      v12 = 0;
      if ( v6 )
      {
        v7 = *(_DWORD *)a4;
        if ( *(_DWORD *)a4 )
        {
          v8 = *(_DWORD *)(v7 + 24);
          if ( !v8 )
            v8 = v7 + 28;
        }
        else
        {
          v8 = (int)&unk_1005C72F;
        }
        sub_1000C780(v5, (int)&v10, 0, v8);
        v4 = 1;
        *(_DWORD *)(v6 + 4) = 0;
        *(_DWORD *)v6 = &off_100556E0;
      }
      else
      {
        v6 = 0;
      }
      *(_DWORD *)a3 = v6;
      if ( v4 & 1 )
        sub_1000C870(&v10, v4);
    }
  }
  return 4;
}
// 100556E0: using guessed type int (__stdcall *off_100556E0)(char);

//----- (1000AF70) --------------------------------------------------------
int __stdcall sub_1000AF70(int a1)
{
  int v1; // edx@1
  int v2; // ebx@1
  int v3; // eax@4
  bool v4; // eax@7
  char v6; // [sp+0h] [bp-2Ch]@1
  int v7; // [sp+10h] [bp-1Ch]@1
  int v8; // [sp+14h] [bp-18h]@1
  int v9; // [sp+18h] [bp-14h]@1
  char *v10; // [sp+1Ch] [bp-10h]@1
  int v11; // [sp+28h] [bp-4h]@1

  v10 = &v6;
  v2 = loc_1000B560();
  v11 = 0;
  v9 = v2;
  *(_WORD *)(v2 + 12) = 0;
  v8 = v2 + 16;
  v7 = v2 + 16;
  LOBYTE(v11) = 1;
  if ( v2 != -16 )
  {
    if ( *(_DWORD *)(a1 + 4) && *(_DWORD *)a1 )
      v3 = loc_10004C50(*(_DWORD *)a1, -1);
    else
      v3 = *(_DWORD *)a1;
    *(_DWORD *)(v2 + 16) = v3;
    if ( *(_DWORD *)a1 )
      v4 = *(_DWORD *)(a1 + 4) != 0;
    else
      v4 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(v2 + 20) = v4;
    LOBYTE(v11) = 2;
    sub_10004DA0(v2 + 24, v1, a1 + 8);
  }
  return v2;
}

//----- (1000B01B) --------------------------------------------------------
void __usercall sub_1000B01B(int a1<ebp>)
{
  sub_1002404A(*(LPVOID *)(a1 - 20));
  sub_1002D02B(0, 0);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_1000B030);
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1000B030) --------------------------------------------------------
int __thiscall sub_1000B030(int this, int a2, int a3, int a4, int a5)
{
  char v5; // zf@1
  int v7; // edi@3
  int v8; // ecx@4
  int v9; // esi@7
  int v10; // ebx@9
  int v11; // ecx@10
  int v12; // ebx@10
  int v13; // esi@12
  int v14; // ebx@16
  int v15; // eax@21
  char v16; // [sp+0h] [bp-38h]@1
  char v17; // [sp+10h] [bp-28h]@21
  int v18; // [sp+14h] [bp-24h]@1
  int v19; // [sp+18h] [bp-20h]@1
  int v20; // [sp+1Ch] [bp-1Ch]@10
  int v21; // [sp+20h] [bp-18h]@1
  int v22; // [sp+24h] [bp-14h]@1
  char *v23; // [sp+28h] [bp-10h]@1
  int v24; // [sp+34h] [bp-4h]@1

  v23 = &v16;
  v21 = this;
  v24 = 0;
  v5 = *(_DWORD *)(this + 4) == 0;
  v19 = a2;
  v22 = a5;
  v18 = a5;
  if ( v5 )
  {
    sub_1000B5A0(this, a2, a2, 1, *(_DWORD *)this, a5, a5);
    return a2;
  }
  v7 = *(_DWORD *)this;
  if ( a3 == **(_DWORD **)this )
  {
    if ( sub_10008120(a4, a3 + 16) )
    {
      sub_1000B5A0(v21, a2, a2, 1, a3, v8, v22);
      return a2;
    }
  }
  else
  {
    if ( a3 == v7 )
    {
      v9 = *(_DWORD *)(v7 + 8);
      if ( sub_10008120(v9 + 16, a4) )
      {
        sub_1000B5A0(v21, a2, a2, 0, v9, v8, v22);
        return a2;
      }
    }
    else
    {
      v10 = a4;
      if ( sub_10008120(a4, a3 + 16) )
      {
        v20 = a3;
        sub_100081F0(&v20);
        v12 = v20;
        if ( sub_10008120(v20 + 16, a4) )
        {
          if ( *(_BYTE *)(*(_DWORD *)(v12 + 8) + 13) )
          {
            v13 = v19;
            sub_1000B5A0(v21, v12, v19, 0, v12, v11, v22);
          }
          else
          {
            v13 = v19;
            sub_1000B5A0(v21, v12, v19, 1, a3, v11, v22);
          }
          return v13;
        }
        v10 = a4;
      }
      if ( sub_10008120(a3 + 16, v10) )
      {
        v20 = a3;
        sub_100081A0(&v20);
        v14 = v20;
        if ( v20 == v7 || sub_10008120(a4, v20 + 16) )
        {
          if ( *(_BYTE *)(*(_DWORD *)(a3 + 8) + 13) )
          {
            v13 = v19;
            sub_1000B5A0(v21, v14, v19, 0, a3, v8, v22);
          }
          else
          {
            v13 = v19;
            sub_1000B5A0(v21, v14, v19, 1, v14, v8, v22);
          }
          return v13;
        }
      }
    }
  }
  v24 = -1;
  v15 = sub_1000B810((void *)v21, (int)&v17, v8, a4, v22);
  v13 = v19;
  *(_DWORD *)v19 = *(_DWORD *)v15;
  return v13;
}

//----- (1000B230) --------------------------------------------------------
void __thiscall sub_1000B230(int this)
{
  if ( this )
  {
    *(_DWORD *)(this + 32) = 15;
    *(_DWORD *)(this + 28) = 0;
    *(_BYTE *)(this + 12) = 0;
  }
}

//----- (1000B250) --------------------------------------------------------
int __thiscall sub_1000B250(void *this, int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // eax@2
  int v6; // ebx@2
  char v7; // zf@2
  char v9; // [sp+0h] [bp-24h]@1
  void *v10; // [sp+10h] [bp-14h]@1
  char *v11; // [sp+14h] [bp-10h]@1
  int v12; // [sp+20h] [bp-4h]@2

  v11 = &v9;
  v10 = this;
  v4 = *(_DWORD *)this;
  if ( !*(_BYTE *)(a2 + 13) )
  {
    v5 = sub_1000AF70(a2 + 16);
    v6 = v5;
    *(_DWORD *)(v5 + 4) = a3;
    *(_BYTE *)(v5 + 12) = *(_BYTE *)(a2 + 12);
    v7 = *(_BYTE *)(v4 + 13) == 0;
    v12 = 0;
    if ( !v7 )
      v4 = v5;
    *(_DWORD *)v5 = sub_1000B250(*(_DWORD *)a2, v5, a4);
    *(_DWORD *)(v6 + 8) = sub_1000B250(*(_DWORD *)(a2 + 8), v6, a4);
  }
  return v4;
}

//----- (1000B310) --------------------------------------------------------
int __usercall sub_1000B310<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
  int v12; // eax@1
  int v13; // ebx@1
  int v14; // eax@3
  int v15; // edx@3
  int v16; // eax@5
  int v18; // ecx@5
  int v19; // eax@5
  int v22; // [sp-8h] [bp-14h]@2
  char v23; // [sp+4h] [bp-8h]@13
  unsigned int v24; // [sp+8h] [bp-4h]@1
  int v25; // [sp+Ch] [bp+0h]@1
  int v26; // [sp+28h] [bp+1Ch]@3

  v24 = (unsigned int)&v25 ^ __security_cookie;
  v12 = a9;
  v13 = a2;
  if ( a6 != a9 )
  {
    v22 = a3;
    do
    {
      v15 = a7;
      v14 = v12 - 1;
      v26 = v14;
      if ( a7 )
        v15 = *(_DWORD *)a7;
      v18 = v14 & (*(_DWORD *)(v15 + 8) - 1);
      v19 = *(_DWORD *)(v15 + 4);
      a1 = a10;
      _ESI = *(_DWORD *)(v19 + 4 * v18);
      v16 = a12-- - 1;
      if ( a10 )
        a1 = *(_DWORD *)a10;
      __asm { movq    xmm0, qword ptr [esi] }
      _EDI = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * (v16 & (*(_DWORD *)(a1 + 8) - 1)));
      __asm { movq    qword ptr [edi], xmm0 }
      *(_DWORD *)(_EDI + 8) = *(_DWORD *)(_ESI + 8);
      if ( _EDI + 12 != _ESI + 12 )
        loc_10001D10(_EDI + 12, _ESI + 12, 0, -1);
      *(_DWORD *)(_EDI + 36) = *(_DWORD *)(_ESI + 36);
      v12 = v26;
    }
    while ( a6 != v26 );
    a3 = v22;
  }
  *(_DWORD *)v13 = 0;
  *(_DWORD *)(v13 + 4) = 0;
  if ( a10 )
  {
    if ( !*(_DWORD *)a10 )
    {
      sub_1002210B(a1, (int)&v23, v13, a3, 3);
      sub_10022167(&v23);
      *(_DWORD *)(v13 + 8) = a12;
      return v13;
    }
    *(_DWORD *)v13 = **(_DWORD **)a10;
  }
  *(_DWORD *)(v13 + 8) = a12;
  return v13;
}
// 10067210: using guessed type int __security_cookie;

//----- (1000B400) --------------------------------------------------------
int __usercall sub_1000B400<eax>(int a1<ecx>, int a2<edi>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  int v11; // eax@1
  int v12; // edx@1
  int v13; // ebx@1
  int v14; // esi@4
  int v15; // edi@7
  int v19; // [sp-8h] [bp-14h]@2
  char v20; // [sp+4h] [bp-8h]@15
  unsigned int v21; // [sp+8h] [bp-4h]@1
  int v22; // [sp+Ch] [bp+0h]@1

  v21 = (unsigned int)&v22 ^ __security_cookie;
  v11 = a5;
  v12 = a11;
  v13 = a1;
  if ( a5 != a8 )
  {
    v19 = a2;
    do
    {
      if ( a3 )
        v14 = *(_DWORD *)a3;
      else
        v14 = 0;
      if ( a9 )
        v15 = *(_DWORD *)a9;
      else
        v15 = 0;
      _ESI = *(_DWORD *)(*(_DWORD *)(v14 + 4) + 4 * (v11 & (*(_DWORD *)(v14 + 8) - 1)));
      __asm { movq    xmm0, qword ptr [esi] }
      _EDI = *(_DWORD *)(*(_DWORD *)(v15 + 4) + 4 * (v12 & (*(_DWORD *)(v15 + 8) - 1)));
      __asm { movq    qword ptr [edi], xmm0 }
      *(_DWORD *)(_EDI + 8) = *(_DWORD *)(_ESI + 8);
      if ( _EDI + 12 != _ESI + 12 )
        loc_10001D10(_EDI + 12, _ESI + 12, 0, -1);
      *(_DWORD *)(_EDI + 36) = *(_DWORD *)(_ESI + 36);
      v11 = a5 + 1;
      v12 = a11++ + 1;
      a5 = v11;
    }
    while ( v11 != a8 );
    a2 = v19;
  }
  *(_DWORD *)v13 = 0;
  *(_DWORD *)(v13 + 4) = 0;
  if ( a9 )
  {
    if ( !*(_DWORD *)a9 )
    {
      sub_1002210B(v12, (int)&v20, v13, a2, 3);
      sub_10022167(&v20);
      *(_DWORD *)(v13 + 8) = a11;
      return v13;
    }
    *(_DWORD *)v13 = **(_DWORD **)a9;
  }
  *(_DWORD *)(v13 + 8) = v12;
  return v13;
}
// 10067210: using guessed type int __security_cookie;

//----- (1000B4F0) --------------------------------------------------------
int __userpurge sub_1000B4F0<eax>(int a1<ebx>, int a2)
{
  sub_10004F60(a2 + 24, a1);
  if ( *(_DWORD *)(a2 + 16) )
  {
    if ( *(_DWORD *)(a2 + 20) == 1 )
      sub_100282F6(a1, *(LPVOID *)(a2 + 16));
  }
  return sub_1002404A((LPVOID)a2);
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1000B5A0) --------------------------------------------------------
int __userpurge sub_1000B5A0<eax>(int a1<ecx>, int a2<ebx>, int a3, char a4, int a5, int a6, int a7)
{
  unsigned int v7; // eax@1
  int v8; // edi@1
  int v9; // eax@13
  int v10; // edx@14
  int v11; // ecx@14
  int v12; // esi@14
  int v13; // edx@17
  int v14; // ecx@21
  int v15; // edx@25
  int v16; // ecx@25
  int v17; // esi@25
  int v18; // ecx@29
  int v19; // edx@35
  int v20; // ecx@35
  int v21; // ecx@39
  int v22; // ecx@47
  int result; // eax@53

  v8 = a1;
  v7 = *(_DWORD *)(a1 + 4);
  if ( v7 >= 0x6666665 )
  {
    v8 = a7;
    *(_DWORD *)&a4 = a7 + 16;
    sub_10004F60(a7 + 24, a2);
    if ( *(_DWORD *)(a7 + 16) )
    {
      if ( *(_DWORD *)(a7 + 20) == 1 )
        sub_100282F6(a2, *(LPVOID *)(a7 + 16));
    }
    sub_1002404A((LPVOID)a7);
    sub_10021C1A((int)"map/set<T> too long");
  }
  *(_DWORD *)(v8 + 4) = v7 + 1;
  *(_DWORD *)(a7 + 4) = a5;
  if ( a5 == *(_DWORD *)v8 )
  {
    *(_DWORD *)(*(_DWORD *)v8 + 4) = a7;
    **(_DWORD **)v8 = a7;
    *(_DWORD *)(*(_DWORD *)v8 + 8) = a7;
  }
  else
  {
    if ( a4 )
    {
      *(_DWORD *)a5 = a7;
      if ( a5 == **(_DWORD **)v8 )
        **(_DWORD **)v8 = a7;
    }
    else
    {
      *(_DWORD *)(a5 + 8) = a7;
      if ( a5 == *(_DWORD *)(*(_DWORD *)v8 + 8) )
        *(_DWORD *)(*(_DWORD *)v8 + 8) = a7;
    }
  }
  v9 = a7;
  while ( !*(_BYTE *)(*(_DWORD *)(v9 + 4) + 12) )
  {
    v11 = *(_DWORD *)(v9 + 4);
    v12 = *(_DWORD *)(v11 + 4);
    v10 = *(_DWORD *)v12;
    if ( v11 == *(_DWORD *)v12 )
    {
      v10 = *(_DWORD *)(v12 + 8);
      if ( *(_BYTE *)(v10 + 12) )
      {
        if ( v9 == *(_DWORD *)(v11 + 8) )
        {
          v9 = *(_DWORD *)(v9 + 4);
          v13 = *(_DWORD *)(v11 + 8);
          *(_DWORD *)(v11 + 8) = *(_DWORD *)v13;
          if ( !*(_BYTE *)(*(_DWORD *)v13 + 13) )
            *(_DWORD *)(*(_DWORD *)v13 + 4) = v9;
          *(_DWORD *)(v13 + 4) = *(_DWORD *)(v9 + 4);
          if ( v9 == *(_DWORD *)(*(_DWORD *)v8 + 4) )
          {
            *(_DWORD *)(*(_DWORD *)v8 + 4) = v13;
          }
          else
          {
            v14 = *(_DWORD *)(v9 + 4);
            if ( v9 == *(_DWORD *)v14 )
              *(_DWORD *)v14 = v13;
            else
              *(_DWORD *)(v14 + 8) = v13;
          }
          *(_DWORD *)v13 = v9;
          *(_DWORD *)(v9 + 4) = v13;
        }
        *(_BYTE *)(*(_DWORD *)(v9 + 4) + 12) = 1;
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 12) = 0;
        v15 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
        v17 = *(_DWORD *)v15;
        *(_DWORD *)v15 = *(_DWORD *)(*(_DWORD *)v15 + 8);
        v16 = *(_DWORD *)(v17 + 8);
        if ( !*(_BYTE *)(v16 + 13) )
          *(_DWORD *)(v16 + 4) = v15;
        *(_DWORD *)(v17 + 4) = *(_DWORD *)(v15 + 4);
        if ( v15 == *(_DWORD *)(*(_DWORD *)v8 + 4) )
        {
          *(_DWORD *)(*(_DWORD *)v8 + 4) = v17;
          *(_DWORD *)(v17 + 8) = v15;
        }
        else
        {
          v18 = *(_DWORD *)(v15 + 4);
          if ( v15 == *(_DWORD *)(v18 + 8) )
          {
            *(_DWORD *)(v18 + 8) = v17;
            *(_DWORD *)(v17 + 8) = v15;
          }
          else
          {
            *(_DWORD *)v18 = v17;
            *(_DWORD *)(v17 + 8) = v15;
          }
        }
LABEL_51:
        *(_DWORD *)(v15 + 4) = v17;
        continue;
      }
    }
    else
    {
      if ( *(_BYTE *)(v10 + 12) )
      {
        if ( v9 == *(_DWORD *)v11 )
        {
          v9 = *(_DWORD *)(v9 + 4);
          v19 = *(_DWORD *)v11;
          *(_DWORD *)v11 = *(_DWORD *)(*(_DWORD *)v11 + 8);
          v20 = *(_DWORD *)(v19 + 8);
          if ( !*(_BYTE *)(v20 + 13) )
            *(_DWORD *)(v20 + 4) = v9;
          *(_DWORD *)(v19 + 4) = *(_DWORD *)(v9 + 4);
          if ( v9 == *(_DWORD *)(*(_DWORD *)v8 + 4) )
          {
            *(_DWORD *)(*(_DWORD *)v8 + 4) = v19;
          }
          else
          {
            v21 = *(_DWORD *)(v9 + 4);
            if ( v9 == *(_DWORD *)(v21 + 8) )
              *(_DWORD *)(v21 + 8) = v19;
            else
              *(_DWORD *)v21 = v19;
          }
          *(_DWORD *)(v19 + 8) = v9;
          *(_DWORD *)(v9 + 4) = v19;
        }
        *(_BYTE *)(*(_DWORD *)(v9 + 4) + 12) = 1;
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 12) = 0;
        v15 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
        v17 = *(_DWORD *)(v15 + 8);
        *(_DWORD *)(v15 + 8) = *(_DWORD *)v17;
        if ( !*(_BYTE *)(*(_DWORD *)v17 + 13) )
          *(_DWORD *)(*(_DWORD *)v17 + 4) = v15;
        *(_DWORD *)(v17 + 4) = *(_DWORD *)(v15 + 4);
        if ( v15 == *(_DWORD *)(*(_DWORD *)v8 + 4) )
        {
          *(_DWORD *)(*(_DWORD *)v8 + 4) = v17;
        }
        else
        {
          v22 = *(_DWORD *)(v15 + 4);
          if ( v15 == *(_DWORD *)v22 )
            *(_DWORD *)v22 = v17;
          else
            *(_DWORD *)(v22 + 8) = v17;
        }
        *(_DWORD *)v17 = v15;
        goto LABEL_51;
      }
    }
    *(_BYTE *)(v11 + 12) = 1;
    *(_BYTE *)(v10 + 12) = 1;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 12) = 0;
    v9 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
  }
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)v8 + 4) + 12) = 1;
  result = a3;
  *(_DWORD *)a3 = a7;
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1000B810) --------------------------------------------------------
int __thiscall sub_1000B810(void *this, int a2, int a3, int a4, int a5)
{
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // ebx@1
  int v9; // edi@1
  int v10; // esi@1
  char v11; // zf@1
  int v12; // edi@2
  int v13; // eax@4
  int v14; // ecx@4
  char v15; // dl@7
  int v16; // esi@17
  int result; // eax@20
  int v18; // ecx@20
  int v19; // eax@22
  char v20; // dl@26
  int v22; // ebx@33
  int v23; // edi@33
  char v24; // [sp-10h] [bp-40h]@19
  int v25; // [sp-Ch] [bp-3Ch]@19
  int v26; // [sp-8h] [bp-38h]@19
  int v27; // [sp-4h] [bp-34h]@19
  char v28; // [sp+0h] [bp-30h]@1
  int v29; // [sp+10h] [bp-20h]@1
  int v30; // [sp+14h] [bp-1Ch]@1
  int v31; // [sp+18h] [bp-18h]@1
  int v32; // [sp+1Ch] [bp-14h]@1
  char *v33; // [sp+20h] [bp-10h]@1
  int v34; // [sp+2Ch] [bp-4h]@1

  v33 = &v28;
  v9 = (int)this;
  v29 = (int)this;
  v34 = 0;
  v6 = *(_DWORD *)this;
  v8 = a4;
  v10 = *(_DWORD *)(*(_DWORD *)this + 4);
  v7 = v6;
  v11 = *(_BYTE *)(v10 + 13) == 0;
  _AL = 1;
  v30 = v6;
  v32 = v6;
  LOBYTE(v31) = 1;
  if ( v11 )
  {
    v12 = *(_DWORD *)a4;
    do
    {
      v7 = v10;
      v32 = v10;
      if ( v12 )
      {
        v14 = *(_DWORD *)(v10 + 16);
        v13 = v12;
        while ( *(_BYTE *)v13 == *(_BYTE *)v14 )
        {
          if ( !*(_BYTE *)v13 )
            goto LABEL_9;
          v15 = *(_BYTE *)(v13 + 1);
          if ( v15 != *(_BYTE *)(v14 + 1) )
            break;
          v13 += 2;
          v14 += 2;
          if ( !v15 )
          {
LABEL_9:
            v7 = v32;
            __asm { sets    al }
            goto LABEL_12;
          }
        }
        v7 = v32;
        __asm { sets    al }
      }
      else
      {
        _AL = *(_DWORD *)(a4 + 4) < *(_DWORD *)(v10 + 20);
      }
LABEL_12:
      LOBYTE(v31) = _AL;
      if ( _AL )
        v10 = *(_DWORD *)v10;
      else
        v10 = *(_DWORD *)(v10 + 8);
    }
    while ( !*(_BYTE *)(v10 + 13) );
    v6 = v30;
    v9 = v29;
  }
  v16 = v7;
  a4 = v7;
  if ( _AL )
  {
    if ( v7 == *(_DWORD *)v6 )
    {
      v27 = a5;
      v26 = v7;
      v25 = v7;
      v24 = 1;
LABEL_20:
      v18 = *(_DWORD *)sub_1000B5A0(v9, v8, (int)&a4, v24, v25, v26, v27);
      result = a2;
      *(_DWORD *)a2 = v18;
      *(_BYTE *)(a2 + 4) = 1;
      return result;
    }
    sub_100081F0(&a4);
    v16 = a4;
  }
  v19 = *(_DWORD *)(v16 + 16);
  if ( v19 )
  {
    v7 = *(_DWORD *)v8;
    while ( *(_BYTE *)v19 == *(_BYTE *)v7 )
    {
      if ( !*(_BYTE *)v19 )
        goto LABEL_28;
      v20 = *(_BYTE *)(v19 + 1);
      if ( v20 != *(_BYTE *)(v7 + 1) )
        break;
      v19 += 2;
      v7 += 2;
      if ( !v20 )
      {
LABEL_28:
        __asm { sets    al }
        goto LABEL_31;
      }
    }
    __asm { sets    al }
  }
  else
  {
    _AL = *(_DWORD *)(v16 + 20) < *(_DWORD *)(v8 + 4);
  }
LABEL_31:
  if ( _AL )
  {
    v27 = a5;
    v26 = v7;
    v25 = v32;
    v24 = v31;
    goto LABEL_20;
  }
  v22 = a5;
  v23 = a5 + 16;
  a4 = a5 + 16;
  LOBYTE(v34) = 1;
  sub_10004F60(a5 + 24, a5);
  if ( *(_DWORD *)v23 )
  {
    if ( *(_DWORD *)(v23 + 4) == 1 )
      sub_100282F6(v22, *(LPVOID *)v23);
  }
  sub_1002404A((LPVOID)v22);
  result = a2;
  *(_DWORD *)a2 = v16;
  *(_BYTE *)(a2 + 4) = 0;
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1000B9D0) --------------------------------------------------------
int __fastcall sub_1000B9D0(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@2
  int v5; // esi@2
  int result; // eax@10

  v3 = a2;
  if ( a1 == a2 )
  {
    result = a3;
  }
  else
  {
    v4 = a3;
    v5 = a1 + 16;
    do
    {
      if ( v4 )
      {
        *(_DWORD *)(v4 + 20) = 15;
        *(_DWORD *)(v4 + 16) = 0;
        *(_BYTE *)v4 = 0;
        if ( *(_DWORD *)(v5 + 4) >= 0x10u )
        {
          *(_DWORD *)v4 = *(_DWORD *)(v5 - 16);
          *(_DWORD *)(v5 - 16) = 0;
        }
        else
        {
          if ( *(_DWORD *)v5 != -1 )
            sub_100237D0((void *)v4, (const void *)(v5 - 16), *(_DWORD *)v5 + 1);
        }
        *(_DWORD *)(v4 + 16) = *(_DWORD *)v5;
        *(_DWORD *)(v4 + 20) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(v5 + 4) = 15;
        *(_DWORD *)v5 = 0;
        *(_BYTE *)(v5 - 16) = 0;
      }
      v5 += 24;
      v4 += 24;
    }
    while ( v5 - 16 != v3 );
    result = v4;
  }
  return result;
}

//----- (1000BA54) --------------------------------------------------------
int __thiscall sub_1000BA54(void *this)
{
  return nullsub_3(this + -*((_DWORD *)this - 1) - 72);
}
// 100010B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1000BA5F) --------------------------------------------------------
void *__thiscall sub_1000BA5F(void *this, char a2)
{
  return sub_10007C90((char *)this - *((_DWORD *)this - 1), a2);
}

//----- (1000BB80) --------------------------------------------------------
int __thiscall sub_1000BB80(void *this, int a2)
{
  (*(void (__stdcall **)(int, _DWORD))(*(_DWORD *)this + 20))(a2, 0);
  return a2;
}

//----- (1000BBA0) --------------------------------------------------------
int __thiscall sub_1000BBA0(void *this, int a2)
{
  (*(void (__stdcall **)(int, _DWORD))(*(_DWORD *)this + 24))(a2, 0);
  return a2;
}

//----- (1000BBC0) --------------------------------------------------------
int __thiscall sub_1000BBC0(void *this, int a2)
{
  (*(void (__stdcall **)(int, _DWORD))(*(_DWORD *)this + 28))(a2, 0);
  return a2;
}

//----- (1000BBE0) --------------------------------------------------------
int __thiscall sub_1000BBE0(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  if ( this != a2 )
  {
    if ( *(_DWORD *)(this + 20) >= 0x10u )
      sub_1002404A(*(LPVOID *)this);
    *(_DWORD *)(v2 + 20) = 15;
    *(_DWORD *)(v2 + 16) = 0;
    *(_BYTE *)v2 = 0;
    if ( *(_DWORD *)(a2 + 20) >= 0x10u )
    {
      *(_DWORD *)v2 = *(_DWORD *)a2;
      *(_DWORD *)a2 = 0;
    }
    else
    {
      if ( *(_DWORD *)(a2 + 16) != -1 )
        sub_100237D0((void *)v2, (const void *)a2, *(_DWORD *)(a2 + 16) + 1);
    }
    *(_DWORD *)(v2 + 16) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(v2 + 20) = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(a2 + 20) = 15;
    *(_DWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1000BC60) --------------------------------------------------------
int __thiscall sub_1000BC60(int this, char a2)
{
  int v2; // esi@1
  void *v3; // ST08_4@1

  v2 = this;
  v3 = *(void **)(this + 8);
  *(_DWORD *)this = &off_10055710;
  sub_1002401B(v3);
  sub_1002401B(*(LPVOID *)(v2 + 16));
  sub_1002401B(*(LPVOID *)(v2 + 20));
  *(_DWORD *)v2 = &off_10055634;
  if ( a2 & 1 )
    sub_1002404A((LPVOID)v2);
  return v2;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10055634: using guessed type int (__stdcall *off_10055634)(char);
// 10055710: using guessed type int (__stdcall *off_10055710)(char);

//----- (1000BCB0) --------------------------------------------------------
char __thiscall sub_1000BCB0(int this)
{
  return *(_BYTE *)(this + 12);
}

//----- (1000BCC0) --------------------------------------------------------
char __thiscall sub_1000BCC0(int this)
{
  return *(_BYTE *)(this + 13);
}

//----- (1000BCD0) --------------------------------------------------------
int __thiscall sub_1000BCD0(int this, int a2)
{
  const char *v2; // edx@1
  int result; // eax@2

  v2 = *(const char **)(this + 8);
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  if ( *v2 )
  {
    loc_10001BD0(a2, v2, strlen(v2));
    result = a2;
  }
  else
  {
    loc_10001BD0(a2, v2, 0);
    result = a2;
  }
  return result;
}

//----- (1000BD30) --------------------------------------------------------
int __thiscall sub_1000BD30(int this, int a2)
{
  const char *v2; // edx@1
  int result; // eax@2

  v2 = *(const char **)(this + 16);
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  if ( *v2 )
  {
    loc_10001BD0(a2, v2, strlen(v2));
    result = a2;
  }
  else
  {
    loc_10001BD0(a2, v2, 0);
    result = a2;
  }
  return result;
}

//----- (1000BD90) --------------------------------------------------------
int __thiscall sub_1000BD90(int this, int a2)
{
  const char *v2; // edx@1
  int result; // eax@2

  v2 = *(const char **)(this + 20);
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  if ( *v2 )
  {
    loc_10001BD0(a2, v2, strlen(v2));
    result = a2;
  }
  else
  {
    loc_10001BD0(a2, v2, 0);
    result = a2;
  }
  return result;
}

//----- (1000BDF0) --------------------------------------------------------
int __thiscall sub_1000BDF0(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002401B(*(LPVOID *)(this + 8));
  sub_1002401B(*(LPVOID *)(v2 + 16));
  return sub_1002401B(*(LPVOID *)(v2 + 20));
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (1000BE10) --------------------------------------------------------
int __userpurge sub_1000BE10<eax>(int a1<ecx>, int a2<edi>, int a3, char a4)
{
  int v4; // ebx@1
  void **v5; // esi@1
  void *v6; // esi@2
  int v7; // edx@4
  int v8; // ecx@4
  void *v9; // edi@4
  char v10; // al@5
  int v11; // eax@6
  int v12; // ecx@6
  int v13; // edi@6
  int v14; // eax@9
  int v15; // edx@9
  int v16; // ecx@9
  signed int v17; // edi@9
  int v18; // esi@9
  int result; // eax@11
  signed int v20; // edi@11
  int v21; // esi@11
  int v22; // ecx@15
  char v23; // [sp+0h] [bp-54h]@1
  char v24; // [sp+10h] [bp-44h]@1
  int v25; // [sp+3Ch] [bp-18h]@1
  int v26; // [sp+40h] [bp-14h]@1
  char *v27; // [sp+44h] [bp-10h]@1
  int v28; // [sp+50h] [bp-4h]@1

  v27 = &v23;
  v4 = a1;
  v26 = a1;
  v5 = sub_10028510(a1, a2);
  v25 = (int)v5;
  sub_100223F1((int)&v24);
  *(_DWORD *)(v4 + 8) = 0;
  *(_DWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 20) = 0;
  v28 = 0;
  if ( a4 )
    v6 = &unk_1005C72F;
  else
    v6 = v5[2];
  sub_100223F1((int)&v24);
  v9 = v6;
  v8 = (int)((char *)v6 + 1);
  do
  {
    v10 = *(_BYTE *)v9;
    v9 = (char *)v9 + 1;
  }
  while ( v10 );
  v13 = (int)(v9 + -v8 + 1);
  v11 = sub_10021CF0(v7, v8, v4, v13, v13);
  if ( v13 )
  {
    v12 = v11 - (_DWORD)v6;
    do
    {
      *((_BYTE *)v6 + v12) = *(_BYTE *)v6;
      v6 = (char *)v6 + 1;
      --v13;
    }
    while ( v13 );
  }
  v17 = 6;
  *(_DWORD *)(v4 + 8) = v11;
  v18 = (int)"false";
  v14 = sub_10021CF0(v11, v12, v4, 6, 6);
  v15 = v14 - (_DWORD)"false";
  do
  {
    LOBYTE(v16) = *(_BYTE *)v18;
    *(_BYTE *)(v15 + v18) = *(_BYTE *)v18;
    ++v18;
    --v17;
  }
  while ( v17 );
  v20 = 5;
  *(_DWORD *)(v4 + 16) = v14;
  v21 = (int)"true";
  result = sub_10021CF0(v15, v16, v4, 5, 5);
  do
  {
    *(_BYTE *)(result - (_DWORD)"true" + v21) = *(_BYTE *)v21;
    ++v21;
    --v20;
  }
  while ( v20 );
  *(_DWORD *)(v4 + 20) = result;
  if ( a4 )
  {
    *(_WORD *)(v4 + 12) = 11310;
  }
  else
  {
    v22 = v25;
    *(_BYTE *)(v4 + 12) = **(_BYTE **)v25;
    result = **(_BYTE **)(v22 + 4);
    *(_BYTE *)(v4 + 13) = result;
  }
  return result;
}

//----- (1000BF70) --------------------------------------------------------
signed int __fastcall sub_1000BF70(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edx@3
  int v6; // esi@3
  int v7; // ecx@4
  int v8; // eax@5
  int v9; // eax@8
  char v11; // [sp+10h] [bp-44h]@8
  int v12; // [sp+44h] [bp-10h]@1
  int v13; // [sp+50h] [bp-4h]@3

  v4 = 0;
  v12 = 0;
  if ( a3 )
  {
    if ( !*(_DWORD *)a3 )
    {
      v6 = sub_10027EB3(a2, a1, 0, a3, 24);
      v13 = 0;
      if ( v6 )
      {
        *(_DWORD *)(v6 + 8) = 0;
        *(_DWORD *)(v6 + 16) = 0;
        *(_DWORD *)(v6 + 20) = 0;
        v7 = *(_DWORD *)a4;
        if ( *(_DWORD *)a4 )
        {
          v8 = *(_DWORD *)(v7 + 24);
          if ( !v8 )
            v8 = v7 + 28;
        }
        else
        {
          v8 = (int)&unk_1005C72F;
        }
        v9 = sub_1000C780(v5, (int)&v11, 0, v8);
        v4 = 1;
        v12 = 1;
        *(_DWORD *)(v6 + 4) = 0;
        v13 = 2;
        *(_DWORD *)v6 = &off_10055710;
        sub_1000BE10(v6, a3, v9, 1);
      }
      else
      {
        v6 = 0;
      }
      *(_DWORD *)a3 = v6;
      if ( v4 & 1 )
        sub_1000C870(&v11, v4);
    }
  }
  return 4;
}
// 10055710: using guessed type int (__stdcall *off_10055710)(char);

//----- (1000C040) --------------------------------------------------------
int __usercall sub_1000C040<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4)
{
  int v4; // edx@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // ecx@5
  int v8; // esi@6
  int v9; // eax@10
  int v10; // edx@17
  int v11; // ecx@17
  char v13; // [sp+Ch] [bp-2Ch]@16
  int v14; // [sp+18h] [bp-20h]@1
  int v15; // [sp+1Ch] [bp-1Ch]@1
  char v16; // [sp+20h] [bp-18h]@1
  char v17; // [sp+24h] [bp-14h]@2
  unsigned int v18; // [sp+28h] [bp-10h]@1
  int v19; // [sp+34h] [bp-4h]@1
  int v20; // [sp+38h] [bp+0h]@1

  v18 = (unsigned int)&v20 ^ __security_cookie;
  v14 = a4;
  sub_1002210B(a1, (int)&v16, a2, a3, 0);
  v19 = 0;
  v6 = dword_1006A380;
  v5 = dword_1006A0E4;
  v15 = dword_1006A0E4;
  if ( !dword_1006A380 )
  {
    sub_1002210B(v4, (int)&v17, dword_1006A0E4, dword_1006A380, dword_1006A380);
    if ( dword_1006A380 == v6 )
    {
      ++dword_10068F04;
      dword_1006A380 = dword_10068F04;
    }
    sub_10022167(&v17);
    v6 = dword_1006A380;
  }
  v7 = *(_DWORD *)a4;
  if ( (unsigned int)v6 >= *(_DWORD *)(*(_DWORD *)a4 + 12) )
  {
    v8 = 0;
  }
  else
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v7 + 8) + 4 * v6);
    if ( v8 )
      goto LABEL_18;
  }
  if ( !*(_BYTE *)(v7 + 20) )
    goto LABEL_12;
  v9 = sub_10021F0C();
  if ( (unsigned int)v6 < *(_DWORD *)(v9 + 12) )
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v9 + 8) + 4 * v6);
LABEL_12:
    if ( v8 )
      goto LABEL_18;
  }
  if ( v5 )
  {
    v8 = v5;
  }
  else
  {
    if ( sub_1000BF70(v7, v4, (int)&v15, v14) == -1 )
    {
      sub_10023634((int)&v13, (unsigned int)"bad cast");
      sub_1002D02B((int)&v13, (int)&unk_10061540);
    }
    v8 = v15;
    dword_1006A0E4 = v15;
    (*(void (__thiscall **)(int))(*(_DWORD *)v15 + 4))(v15);
    sub_10021EE4(v10, v11, v5, v6, v8);
  }
LABEL_18:
  sub_10022167(&v16);
  return v8;
}
// 10067210: using guessed type int __security_cookie;
// 10068F04: using guessed type int dword_10068F04;
// 1006A0E4: using guessed type int dword_1006A0E4;
// 1006A380: using guessed type int dword_1006A380;

//----- (1000C170) --------------------------------------------------------
int __thiscall sub_1000C170(int this, char a2)
{
  void *v2; // edi@1
  int v3; // esi@1
  int v4; // eax@3

  v3 = this;
  v2 = *(void **)(this + 52);
  *(_DWORD *)this = &off_1005C5D4;
  if ( v2 )
  {
    if ( *(_DWORD *)v2 )
    {
      v4 = (*(int (**)(void))(**(_DWORD **)v2 + 8))();
      if ( v4 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v4)(v4, 1);
    }
    sub_1002404A(v2);
  }
  if ( a2 & 1 )
    sub_1002404A((LPVOID)v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005C5D4: using guessed type int (__stdcall *off_1005C5D4)(char);

//----- (1000C1C0) --------------------------------------------------------
signed int __stdcall sub_1000C1C0(int a1)
{
  return -1;
}

//----- (1000C1D0) --------------------------------------------------------
__int64 __cdecl sub_1000C1D0()
{
  return 0i64;
}

//----- (1000C1E0) --------------------------------------------------------
__int64 __thiscall sub_1000C1E0(int this)
{
  __int64 result; // qax@2

  if ( **(_DWORD **)(this + 28) )
    result = **(_DWORD **)(this + 44);
  else
    result = 0i64;
  return result;
}

//----- (1000C200) --------------------------------------------------------
signed int __cdecl sub_1000C200()
{
  return -1;
}

//----- (1000C210) --------------------------------------------------------
int __thiscall sub_1000C210(void *this)
{
  int result; // eax@1
  void *v2; // esi@1
  int v3; // ecx@3
  int *v4; // edx@3

  v2 = this;
  result = (*(int (**)(void))(*(_DWORD *)this + 24))();
  if ( result != -1 )
  {
    --**((_DWORD **)v2 + 11);
    v3 = *((_DWORD *)v2 + 7);
    v4 = (int *)*(_DWORD *)v3++;
    result = *(_BYTE *)v4;
  }
  return result;
}

//----- (1000C240) --------------------------------------------------------
int __thiscall sub_1000C240(int this, void *a2, unsigned int a3, int a4)
{
  int v4; // ebx@1
  unsigned int v5; // edi@2
  __int64 v6; // qax@5
  unsigned int v7; // esi@5
  unsigned __int8 v8; // cf@14
  unsigned __int8 v9; // cf@14
  int v10; // eax@15
  unsigned __int8 v11; // cf@16
  unsigned __int8 v12; // cf@16
  int result; // eax@20
  int v14; // [sp+8h] [bp-14h]@4
  int v15; // [sp+Ch] [bp-10h]@4
  int v16; // [sp+10h] [bp-Ch]@1
  __int64 v17; // [sp+14h] [bp-8h]@1
  int v18; // [sp+14h] [bp-8h]@5

  v4 = a4;
  __asm { xorps   xmm0, xmm0 }
  v16 = this;
  __asm { movlpd  [esp+20h+var_8], xmm0 }
  if ( a4 >= 0 && ((v5 = a3, a4 > 0) || a3) )
  {
    v14 = HIDWORD(v17);
    v15 = v17;
    do
    {
      v6 = sub_1000C1E0(this);
      v7 = v6;
      v18 = HIDWORD(v6);
      if ( HIDWORD(v6) >= 0 && (HIDWORD(v6) > 0 || (_DWORD)v6) )
      {
        if ( v4 <= HIDWORD(v6) )
        {
          if ( v4 < HIDWORD(v6) || v5 < (_DWORD)v6 )
          {
            v7 = v5;
            v18 = v4;
          }
        }
        if ( v7 )
          sub_1002C950(a2, **(const void ***)(v16 + 28), v7);
        a2 = (char *)a2 + v7;
        v8 = v7 >= -v15;
        v15 += v7;
        this = v16;
        v14 += v18 + v8;
        v9 = v5 < v7;
        v5 -= v7;
        v4 -= v9 + v18;
        **(_DWORD **)(v16 + 44) -= v7;
        **(_DWORD **)(v16 + 28) += v7;
      }
      else
      {
        v10 = (*(int (**)(void))(*(_DWORD *)v16 + 28))();
        if ( v10 == -1 )
          break;
        v11 = (unsigned int)v15++ >= 0xFFFFFFFF;
        *(_BYTE *)a2 = v10;
        a2 = (char *)a2 + 1;
        v14 += v11;
        this = v16;
        v12 = v5-- >= 1;
        v4 = v12 + v4 - 1;
      }
    }
    while ( v4 > 0 || v4 >= 0 && v5 );
    result = v15;
  }
  else
  {
    result = v17;
  }
  return result;
}

//----- (1000C350) --------------------------------------------------------
__int64 __thiscall sub_1000C350(int this)
{
  __int64 result; // qax@2

  if ( **(_DWORD **)(this + 32) )
    result = **(_DWORD **)(this + 48);
  else
    result = 0i64;
  return result;
}

//----- (1000C370) --------------------------------------------------------
int __thiscall sub_1000C370(int this, const void *a2, unsigned int a3, int a4)
{
  int v4; // ebx@1
  unsigned int v5; // edi@2
  __int64 v6; // qax@5
  unsigned int v7; // esi@5
  unsigned __int8 v8; // cf@14
  unsigned __int8 v9; // cf@14
  unsigned __int8 v10; // cf@16
  unsigned __int8 v11; // cf@16
  int result; // eax@20
  int v13; // [sp+8h] [bp-14h]@4
  int v14; // [sp+Ch] [bp-10h]@4
  int v15; // [sp+10h] [bp-Ch]@1
  __int64 v16; // [sp+14h] [bp-8h]@1
  int v17; // [sp+14h] [bp-8h]@5

  v4 = a4;
  __asm { xorps   xmm0, xmm0 }
  v15 = this;
  __asm { movlpd  [esp+20h+var_8], xmm0 }
  if ( a4 >= 0 && ((v5 = a3, a4 > 0) || a3) )
  {
    v13 = HIDWORD(v16);
    v14 = v16;
    do
    {
      v6 = sub_1000C350(this);
      v7 = v6;
      v17 = HIDWORD(v6);
      if ( HIDWORD(v6) >= 0 && (HIDWORD(v6) > 0 || (_DWORD)v6) )
      {
        if ( v4 <= HIDWORD(v6) )
        {
          if ( v4 < HIDWORD(v6) || v5 < (_DWORD)v6 )
          {
            v7 = v5;
            v17 = v4;
          }
        }
        if ( v7 )
          sub_1002C950(**(void ***)(v15 + 32), a2, v7);
        a2 = (char *)a2 + v7;
        v8 = v7 >= -v14;
        v14 += v7;
        this = v15;
        v13 += v17 + v8;
        v9 = v5 < v7;
        v5 -= v7;
        v4 -= v9 + v17;
        **(_DWORD **)(v15 + 48) -= v7;
        **(_DWORD **)(v15 + 32) += v7;
      }
      else
      {
        if ( (*(int (__stdcall **)(_DWORD))(*(_DWORD *)v15 + 12))(*(_BYTE *)a2) == -1 )
          break;
        this = v15;
        v10 = (unsigned int)v14++ >= 0xFFFFFFFF;
        a2 = (char *)a2 + 1;
        v13 += v10;
        v11 = v5-- >= 1;
        v4 = v11 + v4 - 1;
      }
    }
    while ( v4 > 0 || v4 >= 0 && v5 );
    result = v14;
  }
  else
  {
    result = v16;
  }
  return result;
}

//----- (1000C480) --------------------------------------------------------
int __stdcall sub_1000C480(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = dword_10055628;
  *(_DWORD *)(a1 + 4) = dword_1005562C;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}
// 10055628: using guessed type int dword_10055628;
// 1005562C: using guessed type int dword_1005562C;

//----- (1000C4B0) --------------------------------------------------------
int __stdcall sub_1000C4B0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = dword_10055628;
  *(_DWORD *)(a1 + 4) = dword_1005562C;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}
// 10055628: using guessed type int dword_10055628;
// 1005562C: using guessed type int dword_1005562C;

//----- (1000C4E0) --------------------------------------------------------
void *__thiscall sub_1000C4E0(void *this, int a2, int a3, int a4)
{
  return this;
}

//----- (1000C540) --------------------------------------------------------
void *__thiscall sub_1000C540(void *this, char a2)
{
  void *v2; // esi@1

  v2 = (char *)this - 8;
  *(_DWORD *)(this + *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 8) = off_1005C658;
  *(_DWORD *)(this + *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 12) = *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 8;
  *(_DWORD *)this = &off_1005C6EC;
  sub_10021D4C((int)this);
  if ( a2 & 1 )
    sub_1002404A(v2);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005C658: using guessed type int (*off_1005C658[3])();
// 1005C6EC: using guessed type int (__stdcall *off_1005C6EC)(char);

//----- (1000C589) --------------------------------------------------------
void *__thiscall sub_1000C589(void *this, char a2)
{
  return sub_1000C540((char *)this - *((_DWORD *)this - 1), a2);
}

//----- (1000C591) --------------------------------------------------------
int __thiscall sub_1000C591(void *this)
{
  return nullsub_3((char *)this - *((_DWORD *)this - 1));
}
// 100010B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1000C5A0) --------------------------------------------------------
int __usercall sub_1000C5A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<ebp>, int a5<edi>)
{
  int result; // eax@1
  int v6; // edi@1
  int v7; // esi@1

  v7 = a2;
  *(_DWORD *)(a2 + 48) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 513;
  *(_DWORD *)(a2 + 24) = 6;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 32) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  *(_DWORD *)(a2 + 40) = 0;
  *(_DWORD *)(a2 + 44) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  result = sub_10027EB3(a1, a2, a3, a5, 4);
  v6 = result;
  if ( result )
  {
    *(_DWORD *)result = 0;
    result = sub_10021F12(a3, a4, result);
    *(_DWORD *)v6 = result;
    *(_DWORD *)(v7 + 48) = v6;
  }
  else
  {
    *(_DWORD *)(v7 + 48) = 0;
  }
  return result;
}

//----- (1000C630) --------------------------------------------------------
int __userpurge sub_1000C630<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  int v3; // eax@1
  int v4; // esi@1

  v4 = a1;
  v3 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)a1 = &off_100556B0;
  if ( v3 <= 0 )
  {
    if ( v3 < 0 )
      sub_1002401B(*(LPVOID *)(a1 + 12));
  }
  else
  {
    sub_100282F6(a2, *(LPVOID *)(a1 + 12));
  }
  sub_100282F6(a2, *(LPVOID *)(v4 + 20));
  *(_DWORD *)v4 = &off_10055634;
  if ( a3 & 1 )
    sub_1002404A((LPVOID)v4);
  return v4;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10055634: using guessed type int (__stdcall *off_10055634)(char);
// 100556B0: using guessed type int (__stdcall *off_100556B0)(char);

//----- (1000C690) --------------------------------------------------------
int *__thiscall sub_1000C690(void *this, int *a2, int a3)
{
  int *v3; // esi@1
  int v4; // ebx@2

  v3 = a2;
  if ( a2 != (int *)a3 )
  {
    v4 = (int)((char *)this + 8);
    do
    {
      *(_BYTE *)v3 = sub_100221F7(v4, a3, *(_BYTE *)v3, v4);
      v3 = (int *)((char *)v3 + 1);
    }
    while ( v3 != (int *)a3 );
  }
  return v3;
}

//----- (1000C6C0) --------------------------------------------------------
int __userpurge sub_1000C6C0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned __int8 a4)
{
  return sub_100221F7(a2, a3, a4, a1 + 8);
}

//----- (1000C6E0) --------------------------------------------------------
int *__thiscall sub_1000C6E0(void *this, int *a2, int a3)
{
  int *v3; // esi@1
  int v4; // ebx@2

  v3 = a2;
  if ( a2 != (int *)a3 )
  {
    v4 = (int)((char *)this + 8);
    do
    {
      *(_BYTE *)v3 = sub_100222F4(v4, a3, *(_BYTE *)v3, v4);
      v3 = (int *)((char *)v3 + 1);
    }
    while ( v3 != (int *)a3 );
  }
  return v3;
}

//----- (1000C710) --------------------------------------------------------
int __userpurge sub_1000C710<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned __int8 a4)
{
  return sub_100222F4(a2, a3, a4, a1 + 8);
}

//----- (1000C730) --------------------------------------------------------
int __stdcall sub_1000C730(const void *a1, int a2, void *a3)
{
  sub_1002C950(a3, a1, a2 - (_DWORD)a1);
  return a2;
}

//----- (1000C750) --------------------------------------------------------
int __stdcall sub_1000C750(const void *a1, int a2, int a3, void *a4)
{
  sub_1002C950(a4, a1, a2 - (_DWORD)a1);
  return a2;
}

//----- (1000C770) --------------------------------------------------------
char __stdcall sub_1000C770(char a1, int a2)
{
  return a1;
}

//----- (1000C780) --------------------------------------------------------
int __userpurge sub_1000C780<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // esi@1
  int (__stdcall **v6)(char); // [sp+8h] [bp-24h]@2
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@2
  unsigned int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+28h] [bp-4h]@1
  int v11; // [sp+2Ch] [bp+0h]@1

  v9 = (unsigned int)&v11 ^ __security_cookie;
  v4 = a2;
  v7 = a2;
  sub_1002210B(a1, a2, a3, a4, 0);
  v10 = 0;
  *(_DWORD *)(v4 + 4) = 0;
  *(_BYTE *)(v4 + 8) = 0;
  *(_DWORD *)(v4 + 12) = 0;
  *(_BYTE *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 20) = 0;
  *(_WORD *)(v4 + 24) = 0;
  *(_DWORD *)(v4 + 28) = 0;
  *(_WORD *)(v4 + 32) = 0;
  *(_DWORD *)(v4 + 36) = 0;
  *(_BYTE *)(v4 + 40) = 0;
  *(_DWORD *)(v4 + 44) = 0;
  *(_BYTE *)(v4 + 48) = 0;
  LOBYTE(v10) = 6;
  if ( !a4 )
  {
    v8 = (int)"bad locale name";
    sub_10023687((int)&v6, &v8);
    v6 = &off_100542F0;
    sub_1002D02B((int)&v6, (int)&unk_100615D4);
  }
  sub_10021FE7(v4, (const CHAR *)a4);
  return v4;
}
// 100542F0: using guessed type int (__stdcall *off_100542F0)(char);
// 10067210: using guessed type int __security_cookie;

//----- (1000C870) --------------------------------------------------------
void __usercall sub_1000C870(void *this<ecx>, int a2<ebx>)
{
  void *v2; // esi@1

  v2 = this;
  sub_10022032((int)this);
  if ( *((_DWORD *)v2 + 11) )
    sub_100282F6(a2, *((LPVOID *)v2 + 11));
  *((_DWORD *)v2 + 11) = 0;
  if ( *((_DWORD *)v2 + 9) )
    sub_100282F6(a2, *((LPVOID *)v2 + 9));
  *((_DWORD *)v2 + 9) = 0;
  if ( *((_DWORD *)v2 + 7) )
    sub_100282F6(a2, *((LPVOID *)v2 + 7));
  *((_DWORD *)v2 + 7) = 0;
  if ( *((_DWORD *)v2 + 5) )
    sub_100282F6(a2, *((LPVOID *)v2 + 5));
  *((_DWORD *)v2 + 5) = 0;
  if ( *((_DWORD *)v2 + 3) )
    sub_100282F6(a2, *((LPVOID *)v2 + 3));
  *((_DWORD *)v2 + 3) = 0;
  if ( *((_DWORD *)v2 + 1) )
    sub_100282F6(a2, *((LPVOID *)v2 + 1));
  *((_DWORD *)v2 + 1) = 0;
  sub_10022167(v2);
}

//----- (1000C910) --------------------------------------------------------
signed int __fastcall sub_1000C910(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edx@3
  int v7; // ecx@4
  int v8; // eax@5
  char v11; // [sp+14h] [bp-54h]@8
  char v12; // [sp+48h] [bp-20h]@8
  int v13; // [sp+58h] [bp-10h]@1
  int v14; // [sp+64h] [bp-4h]@3

  v4 = 0;
  v13 = 0;
  if ( a3 )
  {
    if ( !*(_DWORD *)a3 )
    {
      _ESI = sub_10027EB3(a2, a1, 0, a3, 24);
      v14 = 0;
      if ( _ESI )
      {
        v7 = *(_DWORD *)a4;
        if ( *(_DWORD *)a4 )
        {
          v8 = *(_DWORD *)(v7 + 24);
          if ( !v8 )
            v8 = v7 + 28;
        }
        else
        {
          v8 = (int)&unk_1005C72F;
        }
        sub_1000C780(v5, (int)&v11, 0, v8);
        v4 = 1;
        *(_DWORD *)(_ESI + 4) = 0;
        *(_DWORD *)_ESI = &off_100556B0;
        _EAX = sub_1002218B(1, a3, (int)&v12);
        __asm
        {
          movq    xmm0, qword ptr [eax]
          movq    qword ptr [esi+8], xmm0
          movq    xmm0, qword ptr [eax+8]
          movq    qword ptr [esi+10h], xmm0
        }
      }
      else
      {
        _ESI = 0;
      }
      *(_DWORD *)a3 = _ESI;
      if ( v4 & 1 )
        sub_1000C870(&v11, v4);
    }
  }
  return 2;
}
// 100556B0: using guessed type int (__stdcall *off_100556B0)(char);

//----- (1000C9E0) --------------------------------------------------------
int __usercall sub_1000C9E0<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4)
{
  int v4; // edx@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // ecx@5
  int v8; // esi@6
  int v9; // eax@10
  int v10; // edx@17
  int v11; // ecx@17
  char v13; // [sp+Ch] [bp-2Ch]@16
  int v14; // [sp+18h] [bp-20h]@1
  int v15; // [sp+1Ch] [bp-1Ch]@1
  char v16; // [sp+20h] [bp-18h]@1
  char v17; // [sp+24h] [bp-14h]@2
  unsigned int v18; // [sp+28h] [bp-10h]@1
  int v19; // [sp+34h] [bp-4h]@1
  int v20; // [sp+38h] [bp+0h]@1

  v18 = (unsigned int)&v20 ^ __security_cookie;
  v14 = a4;
  sub_1002210B(a1, (int)&v16, a2, a3, 0);
  v19 = 0;
  v6 = dword_10068F14;
  v5 = dword_1006A0E8;
  v15 = dword_1006A0E8;
  if ( !dword_10068F14 )
  {
    sub_1002210B(v4, (int)&v17, dword_1006A0E8, dword_10068F14, dword_10068F14);
    if ( dword_10068F14 == v6 )
    {
      ++dword_10068F04;
      dword_10068F14 = dword_10068F04;
    }
    sub_10022167(&v17);
    v6 = dword_10068F14;
  }
  v7 = *(_DWORD *)a4;
  if ( (unsigned int)v6 >= *(_DWORD *)(*(_DWORD *)a4 + 12) )
  {
    v8 = 0;
  }
  else
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v7 + 8) + 4 * v6);
    if ( v8 )
      goto LABEL_18;
  }
  if ( !*(_BYTE *)(v7 + 20) )
    goto LABEL_12;
  v9 = sub_10021F0C();
  if ( (unsigned int)v6 < *(_DWORD *)(v9 + 12) )
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v9 + 8) + 4 * v6);
LABEL_12:
    if ( v8 )
      goto LABEL_18;
  }
  if ( v5 )
  {
    v8 = v5;
  }
  else
  {
    if ( sub_1000C910(v7, v4, (int)&v15, v14) == -1 )
    {
      sub_10023634((int)&v13, (unsigned int)"bad cast");
      sub_1002D02B((int)&v13, (int)&unk_10061540);
    }
    v8 = v15;
    dword_1006A0E8 = v15;
    (*(void (__thiscall **)(int))(*(_DWORD *)v15 + 4))(v15);
    sub_10021EE4(v10, v11, v5, v6, v8);
  }
LABEL_18:
  sub_10022167(&v16);
  return v8;
}
// 10067210: using guessed type int __security_cookie;
// 10068F04: using guessed type int dword_10068F04;
// 10068F14: using guessed type int dword_10068F14;
// 1006A0E8: using guessed type int dword_1006A0E8;

//----- (1000CB10) --------------------------------------------------------
char __stdcall sub_1000CB10(char a1)
{
  return a1;
}

//----- (1000CB20) --------------------------------------------------------
int __userpurge sub_1000CB20<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6)
{
  int ebp0; // ebp@0
  int v7; // edi@1
  int v8; // esi@1
  int v9; // eax@1
  int v10; // edx@1
  int v11; // eax@2
  int result; // eax@4
  char v13; // zf@4

  v8 = a2;
  sub_1000C5A0(a1, a2, a3, ebp0, a4);
  *(_DWORD *)(v8 + 56) = a5;
  *(_DWORD *)(v8 + 60) = 0;
  v9 = sub_1000CC00(v8, (int)&a5);
  v7 = sub_1000C9E0(v10, a3, a4, v9);
  if ( a5 )
  {
    v11 = (*(int (**)(void))(*(_DWORD *)a5 + 8))();
    if ( v11 )
      (**(void (__thiscall ***)(_DWORD, _DWORD))v11)(v11, 1);
  }
  result = (*(int (__thiscall **)(int, signed int))(*(_DWORD *)v7 + 32))(v7, 32);
  v13 = *(_DWORD *)(v8 + 56) == 0;
  *(_BYTE *)(v8 + 64) = result;
  if ( v13 )
  {
    result = ((unsigned __int8)*(_DWORD *)(v8 + 12) | 4) & 0x17;
    *(_DWORD *)(v8 + 12) = result;
    if ( result & *(_DWORD *)(v8 + 16) )
      result = loc_1000CE50(v8, 0);
  }
  return result;
}

//----- (1000CBE0) --------------------------------------------------------
void __thiscall sub_1000CBE0(void *this)
{
  int v1; // ecx@1
  int v2; // eax@2

  v1 = *(_DWORD *)this;
  if ( v1 )
  {
    v2 = (*(int (**)(void))(*(_DWORD *)v1 + 8))();
    if ( v2 )
      (**(void (__thiscall ***)(_DWORD, _DWORD))v2)(v2, 1);
  }
}

//----- (1000CC00) --------------------------------------------------------
int __thiscall sub_1000CC00(int this, int a2)
{
  int v3; // eax@1
  int v4; // ecx@1

  v3 = *(_DWORD *)(this + 48);
  v4 = *(_DWORD *)v3;
  *(_DWORD *)a2 = *(_DWORD *)v3;
  (*(void (**)(void))(*(_DWORD *)v4 + 4))();
  return a2;
}

//----- (1000CC40) --------------------------------------------------------
int __thiscall sub_1000CC40(void *this)
{
  int result; // eax@1
  void *v2; // esi@1
  char v3; // al@4
  int v4; // ecx@4
  int v5; // ecx@4
  int v6; // eax@4
  char v7; // [sp+0h] [bp-20h]@1
  char *v8; // [sp+10h] [bp-10h]@1
  int v9; // [sp+1Ch] [bp-4h]@1

  v8 = &v7;
  v2 = this;
  v9 = 0;
  result = *(_DWORD *)(*(_DWORD *)this + 4);
  if ( !*(_DWORD *)(this + result + 12) )
  {
    if ( *((_BYTE *)this + result + 20) & 2 )
    {
      result = (*(int (**)(void))(**(_DWORD **)(this + result + 56) + 52))();
      if ( result == -1 )
      {
        v5 = *(_DWORD *)(*(_DWORD *)v2 + 4);
        v6 = *(_DWORD *)(v2 + v5 + 12);
        v4 = (int)((char *)v2 + v5);
        v3 = v6 | 4;
        if ( !*(_DWORD *)(v4 + 56) )
          v3 |= 4u;
        result = v3 & 0x17;
        *(_DWORD *)(v4 + 12) = result;
        if ( result & *(_DWORD *)(v4 + 16) )
          result = loc_1000CE50(0);
      }
    }
  }
  return result;
}

//----- (1000CCCE) --------------------------------------------------------
int (*__cdecl sub_1000CCCE())()
{
  return loc_1000CCBC;
}
// 1000CCBC: using guessed type int loc_1000CCBC();

//----- (1000CD10) --------------------------------------------------------
int __cdecl sub_1000CD10()
{
  return 0;
}

//----- (1000CD20) --------------------------------------------------------
int __thiscall sub_1000CD20(void *this, const char *a2, int a3)
{
  int v3; // ebx@1
  char v4; // zf@1
  unsigned int v5; // eax@2
  int *v6; // eax@4
  int v7; // edi@4
  int v8; // esi@4
  char v9; // cf@6
  int result; // eax@8
  void *v11; // [sp+14h] [bp-24h]@1
  int v12; // [sp+24h] [bp-14h]@1
  unsigned int v13; // [sp+28h] [bp-10h]@1
  int v14; // [sp+34h] [bp-4h]@4

  v3 = (int)this;
  v13 = 15;
  v4 = *a2 == 0;
  v12 = 0;
  LOBYTE(v11) = 0;
  if ( v4 )
    v5 = 0;
  else
    v5 = strlen(a2);
  loc_10001BD0(&v11, a2, v5);
  v14 = 0;
  v8 = *(_DWORD *)a3;
  v7 = *(_DWORD *)(a3 + 4);
  v6 = (int *)&v11;
  if ( v13 >= 0x10 )
    v6 = (int *)v11;
  a2 = (const char *)v6;
  sub_10023687(v3, (int *)&a2);
  v9 = v13 < 0x10;
  *(_DWORD *)v3 = &off_1005D2BC;
  *(_DWORD *)(v3 + 12) = v8;
  *(_DWORD *)(v3 + 16) = v7;
  if ( !v9 )
    sub_1002404A(v11);
  result = v3;
  *(_DWORD *)v3 = &off_1005D2BC;
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005D2BC: using guessed type int (__stdcall *off_1005D2BC)(char);

//----- (1000CDF0) --------------------------------------------------------
int __userpurge sub_1000CDF0<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // edi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_1005D2BC;
  *(_DWORD *)(v4 + 12) = *(_DWORD *)(a3 + 12);
  *(_DWORD *)(v4 + 16) = *(_DWORD *)(a3 + 16);
  *(_DWORD *)v4 = &off_1005D2BC;
  return v4;
}
// 1005D2BC: using guessed type int (__stdcall *off_1005D2BC)(char);

//----- (1000CE20) --------------------------------------------------------
int __userpurge sub_1000CE20<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // edi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_1005D2BC;
  *(_DWORD *)(v4 + 12) = *(_DWORD *)(a3 + 12);
  *(_DWORD *)(v4 + 16) = *(_DWORD *)(a3 + 16);
  return v4;
}
// 1005D2BC: using guessed type int (__stdcall *off_1005D2BC)(char);

//----- (1000CEE0) --------------------------------------------------------
int __thiscall sub_1000CEE0(int this)
{
  int v1; // esi@1
  char v2; // al@4
  int v3; // ecx@4
  int v4; // ecx@4
  int v5; // eax@4
  int v6; // eax@6
  int v7; // ecx@10
  void *v9; // [sp+8h] [bp-1Ch]@1
  int v10; // [sp+Ch] [bp-18h]@2
  unsigned int v11; // [sp+10h] [bp-14h]@1
  int v12; // [sp+20h] [bp-4h]@2

  v11 = (unsigned int)&v9 ^ __security_cookie;
  v1 = this;
  if ( *(_DWORD *)(*(_DWORD *)(*(_DWORD *)this + 4) + this + 56) )
  {
    sub_1000CFD0(&v9, this);
    v12 = 0;
    if ( (_BYTE)v10 )
    {
      if ( (*(int (**)(void))(**(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + v1 + 56) + 52))() == -1 )
      {
        v4 = *(_DWORD *)(*(_DWORD *)v1 + 4);
        v5 = *(_DWORD *)(v4 + v1 + 12);
        v3 = v1 + v4;
        v2 = v5 | 4;
        if ( !*(_DWORD *)(v3 + 56) )
          v2 |= 4u;
        v6 = v2 & 0x17;
        *(_DWORD *)(v3 + 12) = v6;
        if ( v6 & *(_DWORD *)(v3 + 16) )
          loc_1000CE50(0);
      }
    }
    v12 = -1;
    if ( !(unsigned __int8)sub_10021DCB() )
      sub_1000CC40(v9);
    v7 = *(_DWORD *)(v9 + *(_DWORD *)(*(_DWORD *)v9 + 4) + 56);
    if ( v7 )
      (*(void (**)(void))(*(_DWORD *)v7 + 8))();
  }
  return v1;
}
// 10021DCB: using guessed type int sub_10021DCB(void);
// 10067210: using guessed type int __security_cookie;

//----- (1000CFD0) --------------------------------------------------------
void *__thiscall sub_1000CFD0(void *this, int a2)
{
  int v2; // ecx@1
  void *v3; // edi@1
  int v4; // eax@3
  int v5; // ecx@4

  v3 = this;
  *(_DWORD *)this = a2;
  v2 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a2 + 4) + a2 + 56);
  if ( v2 )
    (*(void (**)(void))(*(_DWORD *)v2 + 4))();
  v4 = *(_DWORD *)(*(_DWORD *)a2 + 4);
  if ( !*(_DWORD *)(v4 + a2 + 12) )
  {
    v5 = *(_DWORD *)(v4 + a2 + 60);
    if ( v5 )
      sub_1000CEE0(v5);
  }
  *((_BYTE *)v3 + 4) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a2 + 4) + a2 + 12) == 0;
  return v3;
}

//----- (1000D060) --------------------------------------------------------
char __thiscall sub_1000D060(int this, int a2, signed int a3, unsigned __int8 a4)
{
  char result; // al@4

  if ( a3 == 1 )
  {
    if ( *(_DWORD *)(this + 20) >= 0x10u )
      this = *(_DWORD *)this;
    result = a4;
    *(_BYTE *)(this + a2) = a4;
  }
  else
  {
    if ( *(_DWORD *)(this + 20) >= 0x10u )
      this = *(_DWORD *)this;
    result = (unsigned int)sub_10030CF0((void *)(this + a2), a4, a3);
  }
  return result;
}

//----- (1000D170) --------------------------------------------------------
int __thiscall sub_1000D170(int this, char a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_1005C6C8;
  if ( *(_DWORD *)(this + 24) >= 0x10u )
    sub_1002404A(*(LPVOID *)(this + 4));
  *(_DWORD *)(v2 + 24) = 15;
  *(_DWORD *)(v2 + 20) = 0;
  *(_BYTE *)(v2 + 4) = 0;
  *(_DWORD *)v2 = &off_1005C6D0;
  if ( a2 & 1 )
    sub_1002404A((LPVOID)v2);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005C6C8: using guessed type int (__stdcall *off_1005C6C8)(char);
// 1005C6D0: using guessed type int (__stdcall *off_1005C6D0)(char);

//----- (1000D200) --------------------------------------------------------
void *__thiscall sub_1000D200(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_1005C6EC;
  sub_10021D4C((int)this);
  if ( a2 & 1 )
    sub_1002404A(v2);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005C6EC: using guessed type int (__stdcall *off_1005C6EC)(char);

//----- (1000D250) --------------------------------------------------------
int __thiscall sub_1000D250(void *this)
{
  int result; // eax@1

  _ECX = (int)((char *)this + 4);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (1000D260) --------------------------------------------------------
void *__thiscall sub_1000D260(void *this)
{
  void *result; // eax@1

  _EAX = (int)((char *)this + 4);
  _EDX = -1;
  __asm { lock xadd [eax], edx }
  result = 0;
  if ( _ZF )
    result = this;
  return result;
}

//----- (1000D280) --------------------------------------------------------
int __stdcall sub_1000D280(int a1, int a2)
{
  int i; // esi@1
  int result; // eax@3

  for ( i = a1; i != a2; i += 24 )
  {
    if ( *(_DWORD *)(i + 20) >= 0x10u )
      result = sub_1002404A(*(LPVOID *)i);
    *(_DWORD *)(i + 20) = 15;
    *(_DWORD *)(i + 16) = 0;
    *(_BYTE *)i = 0;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1000D300) --------------------------------------------------------
int __userpurge sub_1000D300<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_100542F0;
  return v4;
}
// 100542F0: using guessed type int (__stdcall *off_100542F0)(char);

//----- (1000D320) --------------------------------------------------------
void *__thiscall sub_1000D320(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_1005C830;
  if ( a2 & 1 )
    sub_1002404A(this);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005C830: using guessed type int (__stdcall *off_1005C830)(char);

//----- (1000D350) --------------------------------------------------------
int __fastcall sub_1000D350(int a1, int a2)
{
  int v2; // edi@1
  int i; // esi@1
  int v4; // eax@3
  int result; // eax@3
  int v6; // ecx@3

  v2 = a2;
  for ( i = a1; i != v2; result = (**(int (__stdcall ***)(_DWORD))v6)(1) )
  {
    if ( !i )
      break;
    v4 = i + 12;
    v6 = i;
    i = *(_DWORD *)(i + 12);
    *(_DWORD *)v4 = 0;
  }
  return result;
}

//----- (1000D380) --------------------------------------------------------
void *__thiscall sub_1000D380(int this, char a2)
{
  void *v2; // edi@1
  int v3; // esi@1
  int v4; // eax@2
  int v5; // ecx@2

  v2 = (void *)this;
  v3 = *(_DWORD *)(this + 20);
  *(_DWORD *)this = off_1005C82C;
  while ( v3 )
  {
    v4 = v3 + 12;
    v5 = v3;
    v3 = *(_DWORD *)(v3 + 12);
    *(_DWORD *)v4 = 0;
    (**(void (__stdcall ***)(_DWORD))v5)(1);
  }
  *(_DWORD *)v2 = &off_1005C830;
  if ( a2 & 1 )
    sub_1002404A(v2);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005C82C: using guessed type int (__stdcall *off_1005C82C[2])(char);
// 1005C830: using guessed type int (__stdcall *off_1005C830)(char);

//----- (1000D3D0) --------------------------------------------------------
int __fastcall sub_1000D3D0(int a1)
{
  int v1; // edi@1
  int result; // eax@2
  int v3; // ebx@2
  int v4; // esi@2
  int v5; // eax@4
  int v6; // ecx@4
  int v7; // [sp+4h] [bp-4h]@1

  v1 = *(_DWORD *)(a1 + 24);
  v7 = a1;
  *(_DWORD *)a1 = off_1005C828;
  while ( v1 )
  {
    result = v1 + 24;
    v4 = v1;
    v1 = *(_DWORD *)(v1 + 24);
    *(_DWORD *)result = 0;
    v3 = *(_DWORD *)(a1 + 20);
    if ( v4 != v3 )
    {
      do
      {
        if ( !v4 )
          break;
        v5 = v4 + 12;
        v6 = v4;
        v4 = *(_DWORD *)(v4 + 12);
        *(_DWORD *)v5 = 0;
        result = (**(int (__stdcall ***)(_DWORD))v6)(1);
      }
      while ( v4 != v3 );
      a1 = v7;
    }
  }
  *(_DWORD *)a1 = &off_1005C830;
  return result;
}
// 1005C828: using guessed type int (__stdcall *off_1005C828[3])(char);
// 1005C830: using guessed type int (__stdcall *off_1005C830)(char);

//----- (1000D430) --------------------------------------------------------
void *__thiscall sub_1000D430(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_1000D3D0(this);
  if ( a2 & 1 )
    sub_1002404A(v2);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1000D460) --------------------------------------------------------
int __thiscall sub_1000D460(int this, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1

  v2 = *(_DWORD *)(this + 4);
  v3 = *(_DWORD *)this;
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  if ( v3 != v2 )
    loc_10001BD0(a2, v3, v2 - v3);
  return a2;
}

//----- (1000D4F0) --------------------------------------------------------
char __thiscall sub_1000D4F0(void *this, int a2)
{
  int v2; // ecx@1
  unsigned int v3; // edi@1
  int v4; // edx@2
  unsigned int v5; // ebx@4
  unsigned int v6; // eax@6
  char v7; // zf@8
  int v8; // eax@8
  bool v9; // eax@10
  int v10; // eax@13
  int v11; // ebx@14
  unsigned int v12; // edi@16
  int v13; // esi@17
  int v14; // edx@19
  unsigned int v15; // ecx@19
  int v16; // eax@20
  unsigned int v17; // edx@21
  int v18; // edi@21
  int v19; // ecx@22
  int v20; // eax@24
  int v21; // ecx@25
  int v22; // esi@28
  int v26; // ecx@40
  int *v27; // ecx@42
  unsigned int v28; // edi@42
  signed int v29; // edx@44
  int v30; // edx@47
  int v31; // esi@47
  char v32; // cf@47
  char v33; // cf@49
  unsigned __int8 v34; // cf@51
  unsigned __int8 v35; // al@53
  unsigned __int8 v36; // al@55
  unsigned __int8 v37; // al@57
  int v38; // eax@58
  char v39; // zf@60
  bool v40; // eax@62
  signed int v41; // edi@66
  int *v42; // edx@67
  signed int v43; // ecx@69
  int v44; // ecx@72
  int v45; // esi@72
  char v46; // cf@72
  char v47; // cf@74
  unsigned __int8 v48; // cf@76
  unsigned __int8 v49; // al@78
  unsigned __int8 v50; // al@80
  unsigned __int8 v51; // al@82
  int v52; // eax@83
  char v53; // zf@85
  bool v54; // eax@87
  int v55; // ecx@92
  unsigned int v56; // eax@94
  char v57; // zf@96
  int v58; // eax@96
  bool v59; // eax@98
  int v60; // ecx@103
  int v61; // ecx@105
  unsigned int v63; // ecx@109
  int v64; // ebx@109
  int v65; // eax@110
  int v66; // edx@112
  char v68; // zf@121
  int i; // esi@122
  int v70; // eax@123
  int v71; // ecx@123
  int v72; // eax@123
  int v73; // edx@126
  char v75; // [sp-10h] [bp-168h]@39
  int v76; // [sp-Ch] [bp-164h]@21
  int v77; // [sp-8h] [bp-160h]@21
  unsigned int v78; // [sp-4h] [bp-15Ch]@1
  char v79; // [sp+Ch] [bp-14Ch]@107
  void *v80; // [sp+24h] [bp-134h]@107
  int v81; // [sp+54h] [bp-104h]@27
  int v82; // [sp+58h] [bp-100h]@27
  int v83; // [sp+5Ch] [bp-FCh]@27
  int v84; // [sp+60h] [bp-F8h]@35
  int v85; // [sp+64h] [bp-F4h]@27
  void *v86; // [sp+6Ch] [bp-ECh]@27
  int v87; // [sp+70h] [bp-E8h]@27
  int v88; // [sp+74h] [bp-E4h]@27
  __int64 v89; // [sp+9Ch] [bp-BCh]@36
  int v90; // [sp+A4h] [bp-B4h]@36
  __int64 v91; // [sp+A8h] [bp-B0h]@39
  __int64 v92; // [sp+B4h] [bp-A4h]@36
  int v93; // [sp+BCh] [bp-9Ch]@36
  int v94; // [sp+C0h] [bp-98h]@46
  __int64 v95; // [sp+C4h] [bp-94h]@105
  int v96; // [sp+D0h] [bp-88h]@1
  int v97; // [sp+D4h] [bp-84h]@21
  int v98; // [sp+D8h] [bp-80h]@21
  int v99; // [sp+DCh] [bp-7Ch]@21
  int v100; // [sp+E0h] [bp-78h]@35
  int v101; // [sp+E4h] [bp-74h]@21
  int v102; // [sp+ECh] [bp-6Ch]@21
  int v103; // [sp+F0h] [bp-68h]@21
  int v104; // [sp+F4h] [bp-64h]@21
  __int64 v105; // [sp+F8h] [bp-60h]@38
  char v106; // [sp+100h] [bp-58h]@37
  int v107; // [sp+104h] [bp-54h]@105
  char v108; // [sp+110h] [bp-48h]@40
  void *v109; // [sp+11Ch] [bp-3Ch]@42
  unsigned int v110; // [sp+12Ch] [bp-2Ch]@42
  unsigned int v111; // [sp+130h] [bp-28h]@42
  int v112; // [sp+134h] [bp-24h]@21
  int v113; // [sp+138h] [bp-20h]@21
  int v114; // [sp+13Ch] [bp-1Ch]@21
  int v115; // [sp+140h] [bp-18h]@21
  unsigned int v116; // [sp+144h] [bp-14h]@1
  int v117; // [sp+154h] [bp-4h]@21
  int v118; // [sp+158h] [bp+0h]@1

  v116 = (unsigned int)&v118 ^ __security_cookie;
  v78 = (unsigned int)&v118 ^ __security_cookie;
  v96 = (int)this;
  v2 = (int)((char *)this + 4);
  v3 = *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 20) < 0x10u )
    v4 = a2;
  else
    v4 = *(_DWORD *)a2;
  v5 = *(_DWORD *)(v2 + 16);
  if ( *(_DWORD *)(v2 + 20) >= 0x10u )
    v2 = *(_DWORD *)v2;
  v6 = *(_DWORD *)(a2 + 16);
  if ( v5 < v3 )
    v6 = v5;
  v8 = sub_10002720(v2, v4, v6);
  v7 = v8 == 0;
  if ( !v8 )
  {
    if ( v5 >= v3 )
      v9 = v5 != v3;
    else
      v9 = -1;
    v7 = v9 == 0;
  }
  LOBYTE(v10) = v7;
  if ( !v7 )
  {
    v11 = v96 + 4;
    *(_DWORD *)(v96 + 32) = *(_DWORD *)(v96 + 28);
    if ( v11 != a2 )
      loc_10001D10(v11, a2, 0, -1);
    v12 = *(_DWORD *)(v11 + 16);
    if ( *(_DWORD *)(v11 + 20) < 0x10u )
      v13 = v11;
    else
      v13 = *(_DWORD *)v11;
    v15 = 0;
    v14 = -2128831035;
    if ( v12 )
    {
      do
      {
        v16 = *(_BYTE *)(v13 + v15++);
        v14 = 16777619 * (v16 ^ v14);
      }
      while ( v15 < v12 );
    }
    v18 = v96;
    *(_DWORD *)(v96 + 40) = v14;
    v112 = 0;
    v113 = 0;
    v114 = 0;
    v115 = 0;
    sub_1000E460((int)&v112, v18, v76, v77);
    v117 = 0;
    v17 = *(_DWORD *)(v11 + 20);
    v97 = 0;
    v98 = 0;
    v99 = 0;
    v101 = 0;
    v102 = 0;
    v103 = 0;
    v104 = 0;
    if ( v17 < 0x10 )
      v19 = v11;
    else
      v19 = *(_DWORD *)v11;
    v20 = v19 + *(_DWORD *)(v11 + 16);
    if ( v17 < 0x10 )
      v21 = v11;
    else
      v21 = *(_DWORD *)v11;
    sub_1000DEB0((int)&v97, v21, v20, (int)&v112, v21);
    v81 = 0;
    v82 = 0;
    v83 = 0;
    v85 = 0;
    v86 = 0;
    v87 = 0;
    v88 = 0;
    sub_1000DE40((int)&v81);
    LOBYTE(v117) = 2;
    if ( *(_DWORD *)(v11 + 20) < 0x10u )
      v22 = v11;
    else
      v22 = *(_DWORD *)v11;
    _EBX = (int)v86;
    while ( 1 )
    {
      if ( v99 == v83 )
      {
        if ( !v99 )
          goto LABEL_130;
        if ( v97 == v81 )
        {
          if ( v98 == v82 )
          {
            if ( v100 == v84 )
            {
              __asm { movq    xmm0, qword ptr [ebx] }
              v90 = *(_DWORD *)(_EBX + 8);
              _EAX = v102;
              __asm
              {
                movq    [ebp+var_BC], xmm0
                movq    xmm0, qword ptr [eax]
              }
              v93 = *(_DWORD *)(v102 + 8);
              __asm { movq    [ebp+var_A4], xmm0 }
              if ( !sub_1000E910(&v92, (int)&v89) )
              {
LABEL_130:
                v63 = *(_DWORD *)(v18 + 24);
                v64 = v18 + 4;
                if ( v63 < 0x10 )
                  v65 = v18 + 4;
                else
                  v65 = *(_DWORD *)v64;
                v66 = *(_DWORD *)(v18 + 20);
                if ( v22 != v66 + v65 )
                {
                  if ( v63 >= 0x10 )
                    v64 = *(_DWORD *)v64;
                  HIDWORD(v95) = v64 + v66;
                  _EAX = &v75;
                  LODWORD(v95) = v22;
                  __asm
                  {
                    movq    xmm0, [ebp+var_94]
                    movq    qword ptr [eax], xmm0
                  }
                  sub_1000DB30((void *)v18, *(__int64 *)&v75, 0);
                }
                if ( v86 )
                  sub_1002404A(v86);
                if ( v102 )
                {
                  sub_1002404A((LPVOID)v102);
                  v102 = 0;
                  v103 = 0;
                  v104 = 0;
                }
                v117 = -1;
                LOBYTE(v10) = v112;
                if ( v112 )
                {
                  v68 = *(_DWORD *)(v112 + 32)-- == 1;
                  if ( v68 )
                  {
                    for ( i = v112; i; LOBYTE(v10) = (*(int (__stdcall **)(signed int))v72)(1) )
                    {
                      v70 = i + 12;
                      v71 = i;
                      i = *(_DWORD *)(i + 12);
                      *(_DWORD *)v70 = 0;
                      v72 = *(_DWORD *)v71;
                      v77 = 1;
                    }
                  }
                }
                v112 = 0;
                if ( v115 )
                {
                  v10 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v115 + 8))(v78);
                  if ( v10 )
                  {
                    v73 = *(_DWORD *)v10;
                    v77 = 1;
                    LOBYTE(v10) = (*(int (__thiscall **)(int, signed int))v73)(v10, 1);
                  }
                }
                return v10;
              }
            }
          }
        }
      }
      if ( v106 )
      {
        if ( HIDWORD(v105) - (_DWORD)v105 > 0 )
        {
          _EAX = &v75;
          v91 = v105;
          __asm
          {
            movq    xmm0, [ebp+var_B0]
            movq    qword ptr [eax], xmm0
          }
          sub_1000DB30((void *)v18, *(__int64 *)&v75, 0);
        }
      }
      v26 = (int)&v108;
      if ( (unsigned int)((v103 - v102) / 12) > 1 )
        v26 = v102 + 12;
      sub_1000E030(v26, (int)&v109);
      LOBYTE(v117) = 3;
      v28 = v110;
      v27 = (int *)&v109;
      if ( v111 >= 0x10 )
        v27 = (int *)v109;
      v29 = 1;
      if ( v110 < 1 )
        v29 = v110;
      v94 = 0;
      if ( v29 )
        break;
LABEL_61:
      if ( v110 >= 1 )
        v40 = v110 != 1;
      else
        v40 = -1;
      v39 = v40 == 0;
LABEL_65:
      if ( v39 )
      {
        v41 = 1;
        goto LABEL_103;
      }
      v42 = (int *)&v109;
      if ( v111 >= 0x10 )
        v42 = (int *)v109;
      v43 = 1;
      if ( v110 < 1 )
        v43 = v110;
      if ( !v43 )
      {
LABEL_86:
        if ( v110 >= 1 )
          v54 = v110 != 1;
        else
          v54 = -1;
        v53 = v54 == 0;
        goto LABEL_90;
      }
      v45 = (int)"i";
      v46 = (unsigned int)v43 < 4;
      v44 = v43 - 4;
      if ( v46 )
      {
LABEL_75:
        if ( v44 == -4 )
          goto LABEL_84;
      }
      else
      {
        while ( *v42 == *(_DWORD *)v45 )
        {
          ++v42;
          v45 += 4;
          v47 = (unsigned int)v44 < 4;
          v44 -= 4;
          if ( v47 )
            goto LABEL_75;
        }
      }
      v48 = *(_BYTE *)v42 < *(_BYTE *)v45;
      if ( *(_BYTE *)v42 != *(_BYTE *)v45
        || v44 != -3
        && ((v49 = *((_BYTE *)v42 + 1), v48 = v49 < *(_BYTE *)(v45 + 1), v49 != *(_BYTE *)(v45 + 1))
         || v44 != -2
         && ((v50 = *((_BYTE *)v42 + 2), v48 = v50 < *(_BYTE *)(v45 + 2), v50 != *(_BYTE *)(v45 + 2))
          || v44 != -1 && (v51 = *((_BYTE *)v42 + 3), v48 = v51 < *(_BYTE *)(v45 + 3), v51 != *(_BYTE *)(v45 + 3)))) )
      {
        v52 = -v48 | 1;
        goto LABEL_85;
      }
LABEL_84:
      v52 = 0;
LABEL_85:
      v53 = v52 == 0;
      if ( !v52 )
        goto LABEL_86;
LABEL_90:
      if ( v53 )
      {
        v41 = 2;
      }
      else
      {
        v55 = (int)&v109;
        if ( v111 >= 0x10 )
          v55 = (int)v109;
        v56 = 3;
        if ( v110 < 3 )
          v56 = v110;
        v58 = sub_10002720(v55, (int)"url", v56);
        v57 = v58 == 0;
        if ( !v58 )
        {
          if ( v28 >= 3 )
            v59 = v28 != 3;
          else
            v59 = -1;
          v57 = v59 == 0;
        }
        v41 = v94;
        if ( v57 )
          v41 = 8;
      }
LABEL_103:
      v60 = (int)&v108;
      if ( (unsigned int)((v103 - v102) / 12) > 2 )
        v60 = v102 + 24;
      v95 = *(_QWORD *)v60;
      __asm { movq    xmm0, [ebp+var_94] }
      _EAX = &v75;
      __asm { movq    qword ptr [eax], xmm0 }
      v77 = v41;
      v18 = v96;
      sub_1000DB30((void *)v96, *(__int64 *)&v75, v77);
      v22 = v107;
      LOBYTE(v117) = 2;
      if ( v111 >= 0x10 )
        sub_1002404A(v109);
      sub_1000DF90((int)&v97, (int)&v79, v61);
      if ( v80 )
        sub_1002404A(v80);
    }
    v31 = (int)"b";
    v32 = (unsigned int)v29 < 4;
    v30 = v29 - 4;
    if ( v32 )
    {
LABEL_50:
      if ( v30 == -4 )
        goto LABEL_59;
    }
    else
    {
      while ( *v27 == *(_DWORD *)v31 )
      {
        ++v27;
        v31 += 4;
        v33 = (unsigned int)v30 < 4;
        v30 -= 4;
        if ( v33 )
          goto LABEL_50;
      }
    }
    v34 = *(_BYTE *)v27 < *(_BYTE *)v31;
    if ( *(_BYTE *)v27 != *(_BYTE *)v31
      || v30 != -3
      && ((v35 = *((_BYTE *)v27 + 1), v34 = v35 < *(_BYTE *)(v31 + 1), v35 != *(_BYTE *)(v31 + 1))
       || v30 != -2
       && ((v36 = *((_BYTE *)v27 + 2), v34 = v36 < *(_BYTE *)(v31 + 2), v36 != *(_BYTE *)(v31 + 2))
        || v30 != -1 && (v37 = *((_BYTE *)v27 + 3), v34 = v37 < *(_BYTE *)(v31 + 3), v37 != *(_BYTE *)(v31 + 3)))) )
    {
      v38 = -v34 | 1;
      goto LABEL_60;
    }
LABEL_59:
    v38 = 0;
LABEL_60:
    v39 = v38 == 0;
    if ( v38 )
      goto LABEL_65;
    goto LABEL_61;
  }
  return v10;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (1000DB30) --------------------------------------------------------
void __thiscall sub_1000DB30(void *this, __int64 a2, int a3)
{
  int v3; // eax@1
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // ebx@2
  void *v8; // ecx@6
  unsigned int v9; // edx@12
  int v10; // esi@13
  int v11; // ecx@14
  int v12; // ebx@14
  unsigned int v13; // eax@15
  unsigned int v14; // edx@16
  signed int v15; // edx@17
  int v16; // ecx@17
  int v17; // eax@17
  int v21; // eax@25
  char v22; // [sp-Ch] [bp-50h]@6
  int v23; // [sp-8h] [bp-4Ch]@6
  _DWORD v24[3]; // [sp+Ch] [bp-38h]@12
  __int64 v25; // [sp+18h] [bp-2Ch]@15
  int v26; // [sp+20h] [bp-24h]@14
  int v27; // [sp+24h] [bp-20h]@2
  int v28; // [sp+28h] [bp-1Ch]@1
  int v29; // [sp+2Ch] [bp-18h]@13
  int v30; // [sp+30h] [bp-14h]@12
  __int64 v31; // [sp+34h] [bp-10h]@12
  int v32; // [sp+3Ch] [bp-8h]@12
  unsigned int v33; // [sp+40h] [bp-4h]@1
  int v34; // [sp+44h] [bp+0h]@1

  v33 = (unsigned int)&v34 ^ __security_cookie;
  v3 = a2;
  v5 = (int)this;
  v4 = HIDWORD(a2);
  v28 = v5;
  while ( 1 )
  {
    v6 = v3;
    v27 = v3;
    if ( v3 == v4 )
      break;
    while ( *(_BYTE *)v6 != 10 )
    {
      ++v6;
      v27 = v6;
      if ( v6 == v4 )
        goto LABEL_5;
    }
    if ( v6 == v4 )
    {
LABEL_5:
      if ( v3 != v4 )
      {
        __asm { movq    xmm0, [ebp+arg_0] }
        _EDX = &v22;
        v8 = (void *)v5;
        __asm { movq    qword ptr [edx], xmm0 }
        sub_1000DD00(v8, *(int *)&v22, v23, a3);
      }
      return;
    }
    if ( v6 == v3 )
    {
      if ( (*(_DWORD *)(v5 + 32) - *(_DWORD *)(v5 + 28)) / 12 )
      {
        *(_DWORD *)(*(_DWORD *)(v5 + 32) - 4) |= 4u;
        v4 = HIDWORD(a2);
        v3 = v6 + 1;
        LODWORD(a2) = v6 + 1;
        continue;
      }
    }
    else
    {
      v30 = a3 | 4;
      v32 = a3 | 4;
      v9 = *(_DWORD *)v5;
      v24[0] = v3;
      v24[1] = v6;
      __asm
      {
        movq    xmm0, qword ptr [ebp+var_38]
        movq    [ebp+var_10], xmm0
      }
      if ( !v9 )
        goto LABEL_32;
      v29 = v6 - v3;
      v10 = v31;
      if ( v6 - v3 > v9 )
      {
        v11 = v30;
        v12 = v29;
        v26 = v30;
        do
        {
          HIDWORD(v25) = v9 + v10;
          v13 = *(_DWORD *)(v5 + 32);
          LODWORD(v25) = v10;
          if ( (unsigned int)&v25 >= v13 || (v14 = *(_DWORD *)(v5 + 28), v11 = v30, v14 > (unsigned int)&v25) )
          {
            if ( v13 == *(_DWORD *)(v5 + 36) )
            {
              loc_1000E1E0(v5 + 28, v11);
              v11 = v30;
            }
            _EAX = *(_DWORD *)(v5 + 32);
            if ( _EAX )
            {
              __asm
              {
                movq    xmm0, [ebp+var_2C]
                movq    qword ptr [eax], xmm0
              }
              *(_DWORD *)(_EAX + 8) = v11;
            }
          }
          else
          {
            v17 = *(_DWORD *)(v5 + 32);
            v15 = (signed int)((unsigned __int64)(715827883i64 * (signed int)((char *)&v25 - v14)) >> 32) >> 1;
            v16 = v15 + ((unsigned int)v15 >> 31);
            v29 = v15 + ((unsigned int)v15 >> 31);
            if ( v17 == *(_DWORD *)(v5 + 36) )
            {
              loc_1000E1E0(v5 + 28, v15 + ((unsigned int)v15 >> 31));
              v16 = v29;
            }
            _EAX = *(_DWORD *)(v5 + 28) + 12 * v16;
            _ECX = *(_DWORD *)(v5 + 32);
            if ( _ECX )
            {
              __asm
              {
                movq    xmm0, qword ptr [eax]
                movq    qword ptr [ecx], xmm0
              }
              *(_DWORD *)(_ECX + 8) = *(_DWORD *)(_EAX + 8);
            }
          }
          v21 = v28;
          *(_DWORD *)(v5 + 32) += 12;
          v9 = *(_DWORD *)v21;
          v11 = v30;
          v12 -= *(_DWORD *)v21;
          v10 += *(_DWORD *)v21;
        }
        while ( (unsigned int)v12 > *(_DWORD *)v21 );
        v4 = HIDWORD(a2);
        v6 = v27;
        LODWORD(v31) = v10;
        v5 = v21;
      }
      if ( v10 != HIDWORD(v31) )
      {
LABEL_32:
        sub_1000DD70(v5 + 28, (unsigned int)&v31);
        v4 = HIDWORD(a2);
      }
    }
    v3 = v6 + 1;
    LODWORD(a2) = v6 + 1;
  }
}
// 10067210: using guessed type int __security_cookie;

//----- (1000DD00) --------------------------------------------------------
void __thiscall sub_1000DD00(void *this, int a2, int a3, int a4)
{
  void *v4; // ebx@1
  unsigned int v5; // esi@1
  int v6; // eax@2
  int v7; // edx@2
  int v8; // edi@2
  int v9; // ecx@3
  int v10; // [sp+8h] [bp-Ch]@4
  unsigned int v11; // [sp+Ch] [bp-8h]@4
  int v12; // [sp+10h] [bp-4h]@4

  v4 = this;
  v5 = *(_DWORD *)this;
  if ( !*(_DWORD *)this )
    goto LABEL_10;
  v7 = a3;
  v6 = a2;
  v8 = a3 - a2;
  if ( a3 - a2 > v5 )
  {
    v9 = (int)((char *)this + 28);
    do
    {
      v10 = v6;
      v11 = v5 + v6;
      v12 = a4;
      sub_1000DD70(v9, (unsigned int)&v10);
      v5 = *(_DWORD *)v4;
      v6 = *(_DWORD *)v4 + a2;
      v8 -= *(_DWORD *)v4;
      a2 += *(_DWORD *)v4;
      v9 = (int)((char *)v4 + 28);
    }
    while ( v8 > v5 );
    v7 = a3;
  }
  if ( v6 != v7 )
LABEL_10:
    sub_1000DD70((int)((char *)v4 + 28), (unsigned int)&a2);
}

//----- (1000DD70) --------------------------------------------------------
void __thiscall sub_1000DD70(int this, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int v4; // esi@1
  int v5; // edi@3
  signed int v6; // edx@3

  v4 = this;
  v2 = *(_DWORD *)(this + 4);
  _EDI = a2;
  if ( a2 >= v2 || *(_DWORD *)v4 > a2 )
  {
    if ( v2 == *(_DWORD *)(v4 + 8) )
      loc_1000E1E0(v4, v2);
    _ECX = *(_DWORD *)(v4 + 4);
    if ( _ECX )
    {
      __asm
      {
        movq    xmm0, qword ptr [edi]
        movq    qword ptr [ecx], xmm0
      }
      *(_DWORD *)(_ECX + 8) = *(_DWORD *)(a2 + 8);
    }
  }
  else
  {
    v6 = (signed int)((unsigned __int64)(715827883i64 * (signed int)(a2 - *(_DWORD *)v4)) >> 32) >> 1;
    v5 = v6 + ((unsigned int)v6 >> 31);
    if ( v2 == *(_DWORD *)(v4 + 8) )
      loc_1000E1E0(v4, v2);
    _EAX = *(_DWORD *)v4 + 12 * v5;
    _ECX = *(_DWORD *)(v4 + 4);
    if ( _ECX )
    {
      __asm
      {
        movq    xmm0, qword ptr [eax]
        movq    qword ptr [ecx], xmm0
      }
      *(_DWORD *)(_ECX + 8) = *(_DWORD *)(_EAX + 8);
      *(_DWORD *)(v4 + 4) += 12;
      return;
    }
  }
  *(_DWORD *)(v4 + 4) += 12;
}

//----- (1000DE40) --------------------------------------------------------
int __thiscall sub_1000DE40(int this)
{
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_BYTE *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 40) = 0;
  *(_BYTE *)(this + 44) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 52) = 0;
  *(_BYTE *)(this + 56) = 0;
  *(_DWORD *)(this + 60) = 0;
  *(_DWORD *)(this + 64) = 0;
  *(_BYTE *)(this + 68) = 0;
  return this;
}

//----- (1000DEB0) --------------------------------------------------------
int __thiscall sub_1000DEB0(int this, int a2, int a3, int a4, int a5)
{
  int result; // eax@1
  int v6; // esi@1
  int v7; // ecx@1
  char v8; // zf@1

  v6 = this;
  *(_DWORD *)this = a2;
  *(_DWORD *)(this + 4) = a3;
  v7 = this + 16;
  *(_DWORD *)(v6 + 8) = a4;
  *(_DWORD *)(v6 + 12) = 0;
  *(_DWORD *)v7 = 0;
  *(_BYTE *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) = 0;
  *(_DWORD *)(v7 + 12) = 0;
  *(_DWORD *)(v7 + 16) = 0;
  *(_DWORD *)(v7 + 20) = 0;
  *(_DWORD *)(v7 + 24) = 0;
  *(_BYTE *)(v7 + 28) = 0;
  *(_DWORD *)(v7 + 32) = 0;
  *(_DWORD *)(v7 + 36) = 0;
  *(_BYTE *)(v7 + 40) = 0;
  *(_DWORD *)(v7 + 44) = 0;
  *(_DWORD *)(v7 + 48) = 0;
  *(_BYTE *)(v7 + 52) = 0;
  v8 = sub_1000E500(v7, *(_DWORD *)(v6 + 8), *(_DWORD *)v6, *(_DWORD *)(v6 + 4), *(_DWORD *)(v6 + 12), *(_DWORD *)v6) == 0;
  result = v6;
  if ( v8 )
    *(_DWORD *)(v6 + 8) = 0;
  return result;
}

//----- (1000DF90) --------------------------------------------------------
int __thiscall sub_1000DF90(int this, int a2, int a3)
{
  int v4; // edi@1

  v4 = this;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 32) = 0;
  sub_1000E160(a2, this);
  sub_1000E270(v4);
  return a2;
}

//----- (1000E030) --------------------------------------------------------
int __thiscall sub_1000E030(int this, int a2)
{
  int v2; // eax@2
  int v3; // ecx@2
  char v4; // bl@4
  int *v5; // edi@4
  char v6; // bl@10
  void *v8; // [sp+10h] [bp-34h]@2
  int v9; // [sp+20h] [bp-24h]@2
  unsigned int v10; // [sp+24h] [bp-20h]@2
  void *v11; // [sp+28h] [bp-1Ch]@5
  int v12; // [sp+38h] [bp-Ch]@5
  unsigned int v13; // [sp+3Ch] [bp-8h]@5

  if ( *(_BYTE *)(this + 8) )
  {
    v2 = *(_DWORD *)(this + 4);
    v3 = *(_DWORD *)this;
    v10 = 15;
    v9 = 0;
    LOBYTE(v8) = 0;
    if ( v3 != v2 )
      loc_10001BD0(&v8, v3, v2 - v3);
    v5 = (int *)&v8;
    v4 = 1;
  }
  else
  {
    v13 = 15;
    v12 = 0;
    LOBYTE(v11) = 0;
    v5 = (int *)&v11;
    v4 = 2;
  }
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  if ( (unsigned int)v5[5] >= 0x10 )
  {
    *(_DWORD *)a2 = *v5;
    *v5 = 0;
  }
  else
  {
    if ( v5[4] != -1 )
      sub_100237D0((void *)a2, v5, v5[4] + 1);
  }
  *(_DWORD *)(a2 + 16) = v5[4];
  v6 = v4 | 4;
  *(_DWORD *)(a2 + 20) = v5[5];
  v5[5] = 15;
  v5[4] = 0;
  *(_BYTE *)v5 = 0;
  if ( v6 & 2 )
  {
    v6 &= 0xFDu;
    if ( v13 >= 0x10 )
      sub_1002404A(v11);
    v13 = 15;
    v12 = 0;
    LOBYTE(v11) = 0;
  }
  if ( v6 & 1 )
  {
    if ( v10 >= 0x10 )
      sub_1002404A(v8);
  }
  return a2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1000E160) --------------------------------------------------------
int __thiscall sub_1000E160(int this, int a2)
{
  _ESI = a2;
  _EDI = this;
  *(_DWORD *)this = *(_DWORD *)a2;
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(this + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(this + 16) = *(_DWORD *)(a2 + 16);
  *(_BYTE *)(this + 20) = *(_BYTE *)(a2 + 20);
  sub_1000E370(this + 24, a2 + 24);
  __asm
  {
    movq    xmm0, qword ptr [esi+24h]
    movq    qword ptr [edi+24h], xmm0
  }
  *(_DWORD *)(_EDI + 44) = *(_DWORD *)(a2 + 44);
  __asm
  {
    movq    xmm0, qword ptr [esi+30h]
    movq    qword ptr [edi+30h], xmm0
  }
  *(_DWORD *)(_EDI + 56) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(_EDI + 60) = 0;
  *(_DWORD *)(_EDI + 64) = 0;
  *(_BYTE *)(_EDI + 68) = 0;
  return _EDI;
}

//----- (1000E270) --------------------------------------------------------
int __thiscall sub_1000E270(int this)
{
  int v1; // edx@1
  int v2; // edi@1
  int v3; // eax@2
  int v4; // esi@2
  int v5; // ST0C_4@6

  v2 = this;
  v1 = *(_DWORD *)(this + 8);
  if ( !v1 )
    return v2;
  v3 = *(_DWORD *)(this + 24);
  v4 = *(_DWORD *)(v3 + 4);
  if ( *(_DWORD *)v3 != v4 )
    goto LABEL_6;
  if ( v4 == *(_DWORD *)(this + 4) )
  {
LABEL_7:
    *(_DWORD *)(v2 + 8) = 0;
    return v2;
  }
  if ( !sub_1000E500(this + 16, v1, v4, *(_DWORD *)(this + 4), *(_DWORD *)(this + 12) | 0x60, *(_DWORD *)this) )
  {
    ++v4;
LABEL_6:
    v5 = *(_DWORD *)v2;
    *(_DWORD *)(v2 + 12) |= 0x100u;
    if ( !sub_1000E500(v2 + 16, *(_DWORD *)(v2 + 8), v4, *(_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 12), v5) )
      goto LABEL_7;
  }
  return v2;
}

//----- (1000E370) --------------------------------------------------------
int __thiscall sub_1000E370(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  if ( (unsigned __int8)loc_1000E3F0((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) / 12) )
    *(_DWORD *)(v2 + 4) = sub_100111E0(*(void **)v2, *(_DWORD *)a2, *(_DWORD *)(a2 + 4));
  return v2;
}

//----- (1000E460) --------------------------------------------------------
int __userpurge sub_1000E460<eax>(int a1<ecx>, int a2<edi>, int a3, int a4)
{
  int v4; // ecx@1
  int v5; // ebx@1
  int ebp0; // ebp@0
  int v7; // edi@1
  int v9; // [sp+10h] [bp-10h]@1

  v5 = a1;
  v9 = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = sub_10021F12(a1, ebp0, a2);
  v7 = (int)&dword_10068E30;
  v4 = (int)&dword_10068E30;
  if ( (unsigned int)dword_10068E44 >= 0x10 )
    v4 = dword_10068E30;
  if ( (unsigned int)dword_10068E44 >= 0x10 )
    v7 = dword_10068E30;
  sub_1000ED90(v5, v5, v7, v4 + dword_10068E40, v4, v9);
  return v5;
}
// 10068E30: using guessed type int dword_10068E30;
// 10068E40: using guessed type int dword_10068E40;
// 10068E44: using guessed type int dword_10068E44;

//----- (1000E500) --------------------------------------------------------
char __fastcall sub_1000E500(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // edi@1
  int v8; // edx@3
  int v9; // ecx@3
  char v10; // bl@3
  int v11; // esi@3
  int v12; // eax@7
  int v13; // ecx@9
  int v14; // eax@12
  int v15; // ecx@12
  int v16; // [sp+10h] [bp-94h]@1
  char v17; // [sp+14h] [bp-90h]@3
  int v18; // [sp+68h] [bp-3Ch]@13
  int v19; // [sp+74h] [bp-30h]@12
  unsigned int v20; // [sp+94h] [bp-10h]@1
  int v21; // [sp+A0h] [bp-4h]@9
  int v22; // [sp+A4h] [bp+0h]@1
  int i; // [sp+ACh] [bp+8h]@12

  v20 = (unsigned int)&v22 ^ __security_cookie;
  v16 = a2;
  v6 = a1;
  if ( !*(_DWORD *)a2 )
    return 0;
  v11 = a3;
  v10 = 0;
  sub_1000E770((int)&v17, a1);
  v8 = v16;
  v9 = *(_DWORD *)v16;
  if ( *(_DWORD *)v16 )
    v16 = *(_DWORD *)(v9 + 20);
  else
    v16 = 0;
  if ( v9 )
    v12 = *(_DWORD *)(v9 + 28) - 1;
  else
    v12 = 0;
  sub_1000E9F0((int)&v17, a3, a4, v8 + 4, v9, v12 + 1, v16, a5);
  v21 = 0;
  if ( sub_1000F1D0((int)&v17, v6, v13) )
    goto LABEL_16;
  if ( a3 == a4 || a5 & 0x40 )
    goto LABEL_18;
  v19 = (v19 | 0x100) & 0xFFFFDFFF;
  v14 = *(_DWORD *)sub_1000EE70((int)&v17, (int)&v16, a3 + 1, a4, 0);
  v15 = a4;
  for ( i = v14; v14 != a4; i = v14 )
  {
    v18 = v14;
    if ( sub_1000F1D0((int)&v17, v6, v15) )
      goto LABEL_16;
    v14 = *(_DWORD *)sub_1000EE70((int)&v17, (int)&v16, i + 1, a4, 0);
    v15 = a4;
  }
  v18 = v15;
  if ( sub_1000F1D0((int)&v17, v6, v15) )
  {
LABEL_16:
    v10 = 1;
    if ( v6 )
    {
      *(_DWORD *)v6 = a6;
      *(_DWORD *)(v6 + 20) = v11;
    }
  }
LABEL_18:
  sub_1000E6A0((int)&v17);
  return v10;
}
// 10067210: using guessed type int __security_cookie;

//----- (1000E6A0) --------------------------------------------------------
int __thiscall sub_1000E6A0(int this)
{
  int v1; // esi@1
  int result; // eax@9

  v1 = this;
  if ( *(_DWORD *)(this + 64) )
  {
    sub_1002404A(*(LPVOID *)(this + 64));
    *(_DWORD *)(v1 + 64) = 0;
    *(_DWORD *)(v1 + 68) = 0;
    *(_DWORD *)(v1 + 72) = 0;
  }
  if ( *(_DWORD *)(v1 + 52) )
  {
    sub_1002404A(*(LPVOID *)(v1 + 52));
    *(_DWORD *)(v1 + 52) = 0;
    *(_DWORD *)(v1 + 56) = 0;
    *(_DWORD *)(v1 + 60) = 0;
  }
  *(_DWORD *)(v1 + 48) = 0;
  if ( *(_DWORD *)(v1 + 36) )
  {
    sub_1002404A(*(LPVOID *)(v1 + 36));
    *(_DWORD *)(v1 + 36) = 0;
    *(_DWORD *)(v1 + 40) = 0;
    *(_DWORD *)(v1 + 44) = 0;
  }
  if ( *(_DWORD *)(v1 + 20) )
  {
    sub_1002404A(*(LPVOID *)(v1 + 20));
    *(_DWORD *)(v1 + 20) = 0;
    *(_DWORD *)(v1 + 24) = 0;
    *(_DWORD *)(v1 + 28) = 0;
  }
  *(_DWORD *)(v1 + 16) = 0;
  result = *(_DWORD *)(v1 + 4);
  if ( result )
  {
    result = sub_1002404A(*(LPVOID *)(v1 + 4));
    *(_DWORD *)(v1 + 4) = 0;
    *(_DWORD *)(v1 + 8) = 0;
    *(_DWORD *)(v1 + 12) = 0;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1000E770) --------------------------------------------------------
void __thiscall sub_1000E770(int this, int a2)
{
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 40) = 0;
  *(_DWORD *)(this + 44) = 0;
  *(_DWORD *)(this + 52) = 0;
  *(_DWORD *)(this + 56) = 0;
  *(_DWORD *)(this + 60) = 0;
  *(_DWORD *)(this + 64) = 0;
  *(_DWORD *)(this + 68) = 0;
  *(_DWORD *)(this + 72) = 0;
  *(_DWORD *)(this + 76) = 0;
  *(_DWORD *)(this + 80) = 0;
  *(_DWORD *)(this + 84) = 0;
  *(_DWORD *)(this + 88) = 0;
}

//----- (1000E8E0) --------------------------------------------------------
LPVOID __thiscall sub_1000E8E0(LPVOID *this)
{
  LPVOID result; // eax@1
  LPVOID *v2; // esi@1

  v2 = this;
  result = *this;
  if ( *this )
  {
    result = (LPVOID)sub_1002404A(*this);
    *v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1000E910) --------------------------------------------------------
signed int __thiscall sub_1000E910(void *this, int a2)
{
  int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  unsigned int v7; // esi@3
  unsigned int v8; // eax@5
  signed int v9; // ebx@7
  void *v11; // [sp+14h] [bp-40h]@1
  unsigned int v12; // [sp+28h] [bp-2Ch]@13
  void *v13; // [sp+2Ch] [bp-28h]@1
  int v14; // [sp+3Ch] [bp-18h]@13
  unsigned int v15; // [sp+40h] [bp-14h]@11
  int v16; // [sp+50h] [bp-4h]@1
  unsigned int v17; // [sp+5Ch] [bp+8h]@1

  v6 = (int)this;
  v5 = sub_1000E030(a2, (int)&v11);
  v16 = 0;
  v2 = sub_1000E030(v6, (int)&v13);
  v3 = *(_DWORD *)(v5 + 16);
  v4 = v2;
  v17 = *(_DWORD *)(v5 + 16);
  if ( *(_DWORD *)(v5 + 20) >= 0x10u )
    v5 = *(_DWORD *)v5;
  v7 = *(_DWORD *)(v2 + 16);
  if ( *(_DWORD *)(v2 + 20) >= 0x10u )
    v4 = *(_DWORD *)v2;
  v8 = v3;
  if ( v7 < v3 )
    v8 = v7;
  v9 = sub_10002720(v4, v5, v8);
  if ( !v9 )
  {
    if ( v7 >= v17 )
      v9 = v7 != v17;
    else
      v9 = -1;
  }
  if ( v15 >= 0x10 )
    sub_1002404A(v13);
  v15 = 15;
  v14 = 0;
  LOBYTE(v13) = 0;
  if ( v12 >= 0x10 )
    sub_1002404A(v11);
  return v9;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1000E9F0) --------------------------------------------------------
int __thiscall sub_1000E9F0(int this, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // edi@1
  char v9; // al@3
  int v11; // [sp+10h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-4h]@1

  v8 = this;
  *(_DWORD *)this = 0;
  v11 = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  sub_1000ECE0((void *)(this + 4), 0, (int)&v11);
  *(_DWORD *)(v8 + 16) = 0;
  *(_DWORD *)(v8 + 20) = 0;
  *(_DWORD *)(v8 + 24) = 0;
  *(_DWORD *)(v8 + 28) = 0;
  v12 = 0;
  *(_DWORD *)(v8 + 32) = 0;
  v11 = 0;
  *(_DWORD *)(v8 + 36) = 0;
  *(_DWORD *)(v8 + 40) = 0;
  *(_DWORD *)(v8 + 44) = 0;
  sub_1000ECE0((void *)(v8 + 36), 0, (int)&v11);
  *(_DWORD *)(v8 + 48) = 0;
  *(_DWORD *)(v8 + 52) = 0;
  *(_DWORD *)(v8 + 56) = 0;
  *(_DWORD *)(v8 + 60) = 0;
  *(_DWORD *)(v8 + 64) = 0;
  *(_DWORD *)(v8 + 68) = 0;
  *(_DWORD *)(v8 + 72) = 0;
  LOBYTE(v12) = 2;
  *(_DWORD *)(v8 + 76) = 0;
  *(_DWORD *)(v8 + 80) = a3;
  *(_DWORD *)(v8 + 84) = a2;
  *(_DWORD *)(v8 + 92) = a7;
  *(_DWORD *)(v8 + 88) = a5;
  *(_DWORD *)(v8 + 96) = a8;
  *(_BYTE *)(v8 + 100) = 0;
  *(_DWORD *)(v8 + 104) = a6;
  v9 = *(_BYTE *)(a5 + 8) & 8 && !(a8 & 0x10);
  *(_BYTE *)(v8 + 108) = v9;
  *(_DWORD *)(v8 + 112) = a4;
  sub_1000EB40(v8 + 64, *(_DWORD *)(a5 + 24));
  return v8;
}

//----- (1000EB40) --------------------------------------------------------
int __thiscall sub_1000EB40(int this, unsigned int a2)
{
  int result; // eax@1
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // edx@2

  v4 = this;
  v5 = *(_DWORD *)(this + 4);
  result = *(_DWORD *)this;
  v3 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 3;
  if ( v3 <= a2 )
  {
    if ( v3 >= a2 )
      return result;
    loc_1000EBE0(v4, a2 - v3);
    sub_10011220(*(_DWORD *)(v4 + 4), a2 - ((*(_DWORD *)(v4 + 4) - *(_DWORD *)v4) >> 3));
    result = *(_DWORD *)(v4 + 4) + 8 * (a2 - ((*(_DWORD *)(v4 + 4) - *(_DWORD *)v4) >> 3));
    goto LABEL_9;
  }
  v6 = result + 8 * a2;
  if ( v6 == result )
  {
LABEL_9:
    *(_DWORD *)(v4 + 4) = result;
    return result;
  }
  if ( v6 != v5 )
  {
    result = v5;
    *(_DWORD *)(v4 + 4) = v6;
  }
  return result;
}

//----- (1000ECE0) --------------------------------------------------------
int __thiscall sub_1000ECE0(void *this, int a2, int a3)
{
  int result; // eax@1
  void *v4; // ebx@1
  int v5; // esi@1
  int v6; // eax@2
  int v7; // edx@2
  int v8; // ecx@2
  int v9; // [sp+10h] [bp+8h]@2

  v5 = a2;
  v4 = this;
  result = loc_1000ED20(a2);
  if ( (_BYTE)result )
  {
    v6 = *(_DWORD *)v4;
    v9 = *(_DWORD *)v4;
    v8 = v5;
    v7 = *(_DWORD *)v4;
    if ( v5 )
    {
      do
      {
        *(_DWORD *)v7 = *(_DWORD *)a3;
        v7 += 4;
        --v8;
      }
      while ( v8 );
      v6 = v9;
    }
    result = v6 + 4 * v5;
    *((_DWORD *)v4 + 1) = result;
  }
  return result;
}

//----- (1000ED90) --------------------------------------------------------
void *__userpurge sub_1000ED90<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int *v7; // edi@1
  int v8; // esi@1
  int v9; // ecx@3
  char v10; // zf@4
  void *result; // eax@6
  int v12; // [sp+Ch] [bp-68h]@1
  int v13; // [sp+10h] [bp-64h]@1
  int v14; // [sp+14h] [bp-60h]@1
  void *v15; // [sp+20h] [bp-54h]@1
  int v16; // [sp+24h] [bp-50h]@1
  int v17; // [sp+28h] [bp-4Ch]@1
  int v18; // [sp+2Ch] [bp-48h]@6
  int v19; // [sp+30h] [bp-44h]@1
  int v20; // [sp+34h] [bp-40h]@1
  unsigned int v21; // [sp+64h] [bp-10h]@1
  int v22; // [sp+70h] [bp-4h]@1
  int v23; // [sp+74h] [bp+0h]@1

  v21 = (unsigned int)&v23 ^ __security_cookie;
  v7 = (int *)a1;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v19 = 0;
  v20 = 0;
  sub_10010710((int)&v12, a2, a1 + 4, a3, a4, a1);
  v22 = 0;
  v6 = sub_100107F0(&v12);
  v8 = v6;
  if ( v6 )
    ++*(_DWORD *)(v6 + 32);
  v9 = *v7;
  if ( *v7 )
  {
    v10 = *(_DWORD *)(v9 + 32)-- == 1;
    if ( v10 )
      sub_1000D350(*v7, 0);
  }
  result = v15;
  *v7 = v8;
  v18 = 0;
  if ( result )
    result = (void *)sub_1002404A(result);
  return result;
}
// 100107F0: using guessed type int __thiscall sub_100107F0(_DWORD);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (1000EE70) --------------------------------------------------------
int __thiscall sub_1000EE70(int this, int a2, int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // esi@1
  int v8; // eax@3
  int v9; // edx@3
  int v10; // edx@19
  int v11; // ebx@19
  int v12; // esi@19
  int v13; // eax@20
  int v14; // ecx@24
  int v16; // esi@30
  int v17; // eax@31
  int v18; // ecx@31
  char v19; // bl@32
  char v20; // bl@35
  char v21; // al@35
  int v22; // ecx@37
  int v23; // esi@37
  int v24; // esi@38
  int v25; // edx@41
  unsigned __int8 v26; // sf@41
  unsigned __int8 v27; // of@41
  int v28; // ebx@47
  int v29; // ecx@48
  int v30; // esi@48
  int v31; // ebx@54
  char v32; // al@55
  char v33; // zf@55
  int v34; // esi@57
  char v35; // al@58
  char v36; // zf@58
  int v37; // ecx@64
  char v38; // [sp+10h] [bp-28h]@67
  char v39; // [sp+14h] [bp-24h]@22
  char v40; // [sp+18h] [bp-20h]@31
  char v41; // [sp+1Ch] [bp-1Ch]@23
  char v42; // [sp+20h] [bp-18h]@20
  int v43; // [sp+24h] [bp-14h]@23
  int v44; // [sp+28h] [bp-10h]@1
  int v45; // [sp+2Ch] [bp-Ch]@1
  int v46; // [sp+30h] [bp-8h]@19
  unsigned int v47; // [sp+34h] [bp-4h]@1
  int v48; // [sp+38h] [bp+0h]@1

  v47 = (unsigned int)&v48 ^ __security_cookie;
  v7 = a2;
  v6 = a5;
  v5 = this;
  v45 = this;
  v44 = a2;
  if ( !a5 )
    v6 = *(_DWORD *)(this + 88);
  v8 = a3;
  v9 = a4;
  if ( a3 != a4 )
  {
    while ( 2 )
    {
      if ( v6 )
      {
        switch ( *(_DWORD *)(v6 + 4) )
        {
          case 0xC:
          case 0x15:
            v6 = 0;
            continue;
          case 1:
          case 8:
          case 9:
          case 0xD:
          case 0xE:
          case 0x14:
            v6 = *(_DWORD *)(v6 + 12);
            continue;
          case 2:
            if ( *(_BYTE *)(this + 96) & 1 )
              goto LABEL_68;
            if ( a3 != a4 )
            {
              do
              {
                if ( *(_BYTE *)(v8 - 1) == 10 )
                  break;
                ++v8;
              }
              while ( v8 != a4 );
            }
            goto LABEL_27;
          case 3:
            if ( *(_BYTE *)(this + 96) & 2 )
              goto LABEL_68;
            if ( a3 != a4 )
            {
              do
              {
                if ( *(_BYTE *)v8 == 10 )
                  break;
                ++v8;
              }
              while ( v8 != a4 );
            }
            goto LABEL_27;
          case 6:
            if ( a3 == a4 )
              goto LABEL_27;
            do
            {
              v12 = *(_DWORD *)(v5 + 92);
              v10 = *(_DWORD *)(v6 + 28);
              LOBYTE(v46) = (*(_DWORD *)(v5 + 96) >> 7) & 1;
              v11 = v10 + 1;
              if ( v12 & 0x800 )
              {
                v13 = sub_10012210((int)&v42, *(_DWORD *)(v6 + 28), v8, v8 + 1, v11, *(_DWORD *)(v45 + 112), v46);
              }
              else
              {
                if ( v12 & 0x100 )
                {
                  v13 = sub_10012410(
                          (int)&v39,
                          *(_DWORD *)(v6 + 28),
                          v8,
                          (int *)(v8 + 1),
                          v11,
                          *(_DWORD *)(v45 + 112),
                          v46);
                }
                else
                {
                  LOBYTE(v43) = 0;
                  v13 = sub_100124C0((int)&v41, v10, v8, v8 + 1, v10 + 1, v43, v46);
                }
              }
              v14 = *(_DWORD *)v13;
              v8 = a3;
              if ( v14 != a3 )
                break;
              v5 = v45;
              v8 = a3 + 1;
              a3 = v8;
            }
            while ( v8 != a4 );
            goto LABEL_26;
          default:
            goto LABEL_27;
          case 7:
            if ( a3 == a4 )
              goto LABEL_27;
            break;
          case 0x10:
            if ( a3 != a4 )
            {
              do
              {
                if ( !v6 )
                  break;
                v9 = *(_DWORD *)sub_1000EE70(&v38, v8, v9, *(_DWORD *)(v6 + 12));
                v8 = a3;
                v6 = *(_DWORD *)(v6 + 24);
              }
              while ( a3 != v9 );
            }
LABEL_68:
            *(_DWORD *)a2 = v9;
            return v7;
        }
        while ( 1 )
        {
          v16 = *(_DWORD *)(v6 + 20);
          LOBYTE(v46) = *(_BYTE *)v8;
          if ( v16 )
          {
            v17 = sub_10010E70((int)&v40, v16, v8, v8 + 1);
            v9 = a4;
            v18 = v17;
            v8 = a3;
            if ( *(_DWORD *)v18 != a3 )
            {
              v19 = 1;
              goto LABEL_61;
            }
          }
          if ( *(_DWORD *)(v6 + 32) )
          {
            if ( *(_DWORD *)(v5 + 92) & 0x800 )
            {
              v21 = sub_1000F3C0(*(_DWORD *)(v5 + 112), v5, v6, v46);
              v9 = a4;
              v20 = v21;
              v8 = a3;
            }
            else
            {
              v20 = v46;
            }
            v23 = *(_DWORD *)(v6 + 32);
            v22 = 0;
            if ( *(_DWORD *)(v23 + 4) > 0 )
              break;
          }
LABEL_42:
          if ( dword_1006A0F8 > (char)v46 || (char)v46 >= 256 )
          {
            v28 = *(_DWORD *)(v6 + 28);
            if ( v28 )
            {
              v30 = *(_DWORD *)(v28 + 8);
              v29 = v30 + *(_DWORD *)(v28 + 4);
              if ( v30 != v29 )
              {
                do
                {
                  if ( *(_BYTE *)v30 == (_BYTE)v46 )
                    break;
                  ++v30;
                }
                while ( v30 != v29 );
                v9 = a4;
              }
              if ( v30 != *(_DWORD *)(v28 + 4) + *(_DWORD *)(v28 + 8) )
              {
                v19 = 1;
                goto LABEL_61;
              }
            }
            v31 = v45;
            if ( *(_WORD *)(v6 + 36) )
            {
              v32 = sub_1000F490(*(_DWORD *)(v45 + 112), v45, v46, *(_WORD *)(v6 + 36));
              v9 = a4;
              v33 = v32 == 0;
              v8 = a3;
              if ( !v33 )
              {
                v19 = 1;
                goto LABEL_61;
              }
            }
            v34 = *(_DWORD *)(v6 + 40);
            if ( v34 )
            {
              v35 = sub_10010F00(v46, v34, *(void **)(v31 + 112));
              v9 = a4;
              v36 = v35 == 0;
              v8 = a3;
              if ( !v36 )
                goto LABEL_59;
            }
          }
          else
          {
            if ( *(_DWORD *)(v6 + 24)
              && (unsigned __int8)(1 << (v46 & 7)) & *(_BYTE *)(((unsigned int)(char)v46 >> 3) + *(_DWORD *)(v6 + 24)) )
            {
              v19 = 1;
              goto LABEL_61;
            }
          }
          v19 = 0;
LABEL_61:
          if ( v19 != (*(_BYTE *)(v6 + 8) & 1) )
          {
            v37 = v44;
            *(_DWORD *)v44 = v8;
            return v37;
          }
          v5 = v45;
          ++v8;
          a3 = v8;
          if ( v8 == v9 )
          {
LABEL_26:
            v7 = v44;
            goto LABEL_27;
          }
        }
        v24 = *(_DWORD *)(v23 + 8);
        while ( *(_BYTE *)(v24 + v22) > v20 || v20 > *(_BYTE *)(v24 + v22 + 1) )
        {
          v25 = *(_DWORD *)(v6 + 32);
          v22 += 2;
          v27 = __SETO__(v22, *(_DWORD *)(v25 + 4));
          v26 = v22 - *(_DWORD *)(v25 + 4) < 0;
          v9 = a4;
          if ( !(v26 ^ v27) )
            goto LABEL_42;
        }
LABEL_59:
        v19 = 1;
        goto LABEL_61;
      }
      break;
    }
  }
LABEL_27:
  *(_DWORD *)v7 = v8;
  return v7;
}
// 10067210: using guessed type int __security_cookie;
// 1006A0F8: using guessed type int dword_1006A0F8;

//----- (1000F1D0) --------------------------------------------------------
char __thiscall sub_1000F1D0(int this, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int v5; // eax@1
  int v6; // ST00_4@1
  int v7; // ST04_4@1
  int v8; // eax@3
  unsigned int v9; // edx@7
  int v10; // ebx@7
  int v11; // edi@8
  int v12; // ebx@9
  int v13; // ebx@11
  int v15; // eax@15
  int v16; // ecx@19

  v4 = this;
  v5 = *(_DWORD *)(this + 84);
  v6 = *(_DWORD *)(this + 104);
  *(_DWORD *)(this + 76) = v5;
  *(_DWORD *)this = v5;
  sub_1000F580(this + 4, v6, this);
  sub_1000F790(v4 + 20, *(_DWORD *)(v4 + 104));
  v3 = a2;
  v7 = *(_DWORD *)(v4 + 88);
  *(_BYTE *)(v4 + 101) = a2 != 0;
  *(_BYTE *)(v4 + 116) = 0;
  *(_DWORD *)(v4 + 120) = 10000000;
  *(_DWORD *)(v4 + 124) = 1000;
  *(_BYTE *)(v4 + 100) = 0;
  if ( !(unsigned __int8)loc_100108B0(v4, v7) )
  {
    if ( !(*(_BYTE *)(v4 + 96) & 0x80) || (v8 = *(_DWORD *)(v4 + 80), *(_DWORD *)v4 != v8) || *(_DWORD *)(v4 + 84) == v8 )
      return 0;
    sub_1000F380((void *)(v4 + 32), v4);
    *(_BYTE *)(v4 + 100) = 1;
  }
  if ( a2 )
  {
    v10 = a2 + 8;
    sub_1000FD20(a2 + 8, *(_DWORD *)(v4 + 104));
    v9 = 0;
    if ( *(_DWORD *)(v4 + 104) > 0 )
    {
      v11 = 0;
      do
      {
        v12 = *(_DWORD *)(v4 + 36);
        if ( (signed int)v9 < 0 && v9 )
          v13 = v12 - (4 * ((-1 - v9) >> 5) + 4);
        else
          v13 = v12 + 4 * (v9 >> 5);
        if ( (1 << (v9 & 0x1F)) & *(_DWORD *)v13 )
        {
          v10 = a2 + 8;
          *(_BYTE *)(v11 + *(_DWORD *)(a2 + 8) + 8) = 1;
          *(_DWORD *)(v11 + *(_DWORD *)(a2 + 8)) = *(_DWORD *)(*(_DWORD *)(v4 + 52) + 8 * v9);
          v15 = *(_DWORD *)(*(_DWORD *)(v4 + 52) + 8 * v9 + 4);
        }
        else
        {
          v10 = a2 + 8;
          *(_BYTE *)(v11 + *(_DWORD *)(a2 + 8) + 8) = 0;
          *(_DWORD *)(v11 + *(_DWORD *)(a2 + 8)) = *(_DWORD *)(v4 + 80);
          v15 = *(_DWORD *)(v4 + 80);
        }
        ++v9;
        *(_DWORD *)(v11 + *(_DWORD *)v10 + 4) = v15;
        v11 += 12;
      }
      while ( (signed int)v9 < *(_DWORD *)(v4 + 104) );
      v3 = a2;
    }
    v16 = *(_DWORD *)v10;
    *(_DWORD *)v3 = *(_DWORD *)(v4 + 76);
    *(_BYTE *)(v3 + 28) = 1;
    *(_DWORD *)(v3 + 20) = *(_DWORD *)(v4 + 76);
    *(_DWORD *)(v3 + 24) = *(_DWORD *)v16;
    *(_BYTE *)(v3 + 40) = 1;
    *(_DWORD *)(v3 + 32) = *(_DWORD *)(v16 + 4);
    *(_DWORD *)(v3 + 36) = *(_DWORD *)(v4 + 80);
    *(_DWORD *)(v3 + 44) = *(_DWORD *)(v4 + 80);
    *(_DWORD *)(v3 + 48) = *(_DWORD *)(v4 + 80);
    *(_BYTE *)(v3 + 4) = 1;
  }
  return 1;
}

//----- (1000F380) --------------------------------------------------------
void *__thiscall sub_1000F380(void *this, int a2)
{
  void *v3; // edi@1
  int v4; // ecx@1

  v3 = this;
  *(_DWORD *)this = *(_DWORD *)a2;
  v4 = (int)((char *)this + 4);
  *(_DWORD *)(v4 + 12) = *(_DWORD *)(a2 + 16);
  sub_1000FC10(v4, a2 + 4);
  sub_1000F6A0((char *)v3 + 20, a2 + 20);
  return v3;
}

//----- (1000F3C0) --------------------------------------------------------
char __userpurge sub_1000F3C0<al>(int a1<ecx>, int a2<ebx>, int a3<edi>, __int16 a4)
{
  void **v4; // esi@1
  int v5; // ecx@2
  int v6; // eax@2
  int v7; // eax@2
  int v8; // edx@2
  int v9; // eax@3
  int *v10; // eax@6
  char v11; // bl@8
  unsigned int v13; // [sp-4h] [bp-3Ch]@1
  int v14; // [sp+8h] [bp-30h]@2
  void *v15; // [sp+Ch] [bp-2Ch]@5
  int v16; // [sp+1Ch] [bp-1Ch]@5
  unsigned int v17; // [sp+20h] [bp-18h]@6
  unsigned int v18; // [sp+24h] [bp-14h]@1
  int v19; // [sp+34h] [bp-4h]@2
  int v20; // [sp+38h] [bp+0h]@1

  v18 = (unsigned int)&v20 ^ __security_cookie;
  v13 = (unsigned int)&v20 ^ __security_cookie;
  v4 = (void **)a1;
  if ( !*(_DWORD *)a1 )
  {
    v6 = sub_100100B0(a1, (int)&v14);
    v19 = 0;
    v7 = sub_10011270(v8, a2, a3, v6);
    v19 = -1;
    v5 = v14;
    *v4 = (void *)v7;
    if ( v5 )
    {
      v9 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v5 + 8))(v13);
      if ( v9 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v9)(v9, 1);
    }
  }
  sub_1000FE50(*v4, (int)&v15, (int)&a4, (int)((char *)&a4 + 1));
  if ( v16 == 1 )
  {
    v10 = (int *)&v15;
    if ( v17 >= 0x10 )
      v10 = (int *)v15;
    v11 = *(_BYTE *)v10;
  }
  else
  {
    v11 = a4;
  }
  if ( v17 >= 0x10 )
    sub_1002404A(v15);
  return v11;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (1000F490) --------------------------------------------------------
bool __userpurge sub_1000F490<eax>(int a1<ecx>, char a2<bl>, unsigned __int8 a3, int a4)
{
  unsigned __int16 v4; // di@1
  int v5; // esi@1
  int v6; // ecx@3
  int v7; // eax@3
  int v8; // eax@3
  int v9; // edx@3
  int v10; // eax@4
  bool result; // eax@6

  v5 = a1;
  v4 = a4;
  if ( (_WORD)a4 == -1 )
  {
    result = a3 == 95 || *(_WORD *)(*(_DWORD *)(sub_1000F900(a1, a3, (unsigned __int16)a4) + 12) + 2 * a3) & 0x107;
  }
  else
  {
    if ( !*(_DWORD *)(a1 + 4) )
    {
      v7 = sub_100100B0(a1, (int)&a4);
      v8 = sub_1000C9E0(v9, a2, v4, v7);
      v6 = a4;
      *(_DWORD *)(v5 + 4) = v8;
      if ( v6 )
      {
        v10 = (*(int (**)(void))(*(_DWORD *)v6 + 8))();
        if ( v10 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v10)(v10, 1);
      }
    }
    result = (v4 & *(_WORD *)(*(_DWORD *)(*(_DWORD *)(v5 + 4) + 12) + 2 * a3)) != 0;
  }
  return result;
}

//----- (1000F580) --------------------------------------------------------
void __thiscall sub_1000F580(int this, int a2, int a3)
{
  unsigned int v3; // esi@1
  int v4; // edx@2
  int v5; // edi@2
  int v6; // eax@10
  int v7; // edi@10
  int v8; // esi@10
  int v9; // eax@10
  char v10; // [sp+10h] [bp-20h]@10
  char v11; // [sp+18h] [bp-18h]@10
  int v12; // [sp+20h] [bp-10h]@8
  int v13; // [sp+24h] [bp-Ch]@10
  int v14; // [sp+28h] [bp-8h]@1
  char v15; // [sp+2Ch] [bp-4h]@1

  v3 = *(_DWORD *)(this + 12);
  v14 = this;
  v15 = 0;
  if ( a2 <= v3 )
  {
    if ( a2 < v3 )
    {
      v6 = sub_1000F980(this, (int)&v11);
      v7 = *(_DWORD *)v6;
      v8 = *(_DWORD *)(v6 + 4);
      v12 = *(_DWORD *)v14;
      v13 = 0;
      v9 = sub_10010010((int)&v12, (int)&v10, a2);
      sub_1000F9E0(v14, (int)&v12, *(_DWORD *)v9, *(_DWORD *)(v9 + 4), v7, v8);
    }
  }
  else
  {
    v5 = *(_DWORD *)this;
    v4 = 0;
    if ( v3 )
    {
      if ( (signed int)v3 < 0 && v3 )
      {
        this = v14;
        v5 += -4 - 4 * ((-1 - v3) >> 5);
      }
      else
      {
        v5 += 4 * (v3 >> 5);
      }
      v4 = v3 & 0x1F;
    }
    sub_1000FB10((void *)this, (int)&v12, a2 - v3, (int)&v15, v5, v4);
  }
}

//----- (1000F640) --------------------------------------------------------
int __thiscall sub_1000F640(void *this, int a2, unsigned int a3)
{
  int v3; // esi@1
  int result; // eax@3

  v3 = *(_DWORD *)this;
  if ( (signed int)a3 < 0 && a3 )
  {
    result = a2;
    *(_DWORD *)a2 = -4 - 4 * ((-1 - a3) >> 5) + v3;
    *(_DWORD *)(a2 + 4) = a3 & 0x1F;
  }
  else
  {
    result = a2;
    *(_DWORD *)a2 = v3 + 4 * (a3 >> 5);
    *(_DWORD *)(a2 + 4) = a3 & 0x1F;
  }
  return result;
}

//----- (1000F6A0) --------------------------------------------------------
void *__thiscall sub_1000F6A0(void *this, int a2)
{
  void *v2; // edi@1
  int v3; // ecx@2
  int v4; // esi@2
  int v6; // edx@4
  int v7; // eax@6
  int v8; // ecx@9
  int v9; // esi@9
  int v10; // [sp-10h] [bp-20h]@9
  int v11; // [sp+8h] [bp-8h]@4

  v2 = this;
  if ( this == (void *)a2 )
    return v2;
  v3 = *(_DWORD *)a2;
  v4 = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)a2 == v4 )
  {
    *((_DWORD *)v2 + 1) = *(_DWORD *)v2;
    return v2;
  }
  v6 = *(_DWORD *)v2;
  v11 = (*((_DWORD *)v2 + 1) - *(_DWORD *)v2) >> 3;
  if ( (v4 - v3) >> 3 > (unsigned int)v11 )
  {
    if ( (v4 - v3) >> 3 > (unsigned int)((*((_DWORD *)v2 + 2) - v6) >> 3) )
    {
      if ( v6 )
        sub_1002404A((LPVOID)v6);
      if ( !(unsigned __int8)loc_1000FDE0(v2, (*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 3) )
        return v2;
      v10 = *(_DWORD *)v2;
      v8 = *(_DWORD *)a2;
    }
    else
    {
      v9 = v3 + 8 * v11;
      sub_10011240(v3, v3 + 8 * v11, v6);
      v10 = *((_DWORD *)v2 + 1);
      v8 = v9;
    }
    *((_DWORD *)v2 + 1) = sub_10012700(v8, *(_DWORD *)(a2 + 4), v10);
    return v2;
  }
  for ( ; v3 != v4; v6 += 8 )
  {
    *(_DWORD *)v6 = *(_DWORD *)v3;
    v7 = *(_DWORD *)(v3 + 4);
    v3 += 8;
    *(_DWORD *)(v6 + 4) = v7;
  }
  *((_DWORD *)v2 + 1) = *(_DWORD *)v2 + 8 * ((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 3);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1000F790) --------------------------------------------------------
int __thiscall sub_1000F790(int this, unsigned int a2)
{
  int result; // eax@1
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // edx@2

  v4 = this;
  v5 = *(_DWORD *)(this + 4);
  result = *(_DWORD *)this;
  v3 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 3;
  if ( v3 <= a2 )
  {
    if ( v3 >= a2 )
      return result;
    loc_1000EBE0(v4, a2 - v3);
    sub_10012730(*(_DWORD *)(v4 + 4), a2 - ((*(_DWORD *)(v4 + 4) - *(_DWORD *)v4) >> 3));
    result = *(_DWORD *)(v4 + 4) + 8 * (a2 - ((*(_DWORD *)(v4 + 4) - *(_DWORD *)v4) >> 3));
    goto LABEL_9;
  }
  v6 = result + 8 * a2;
  if ( v6 == result )
  {
LABEL_9:
    *(_DWORD *)(v4 + 4) = result;
    return result;
  }
  if ( v6 != v5 )
  {
    result = v5;
    *(_DWORD *)(v4 + 4) = v6;
  }
  return result;
}

//----- (1000F830) --------------------------------------------------------
int __thiscall sub_1000F830(int this)
{
  int v1; // ebx@1
  int v2; // edi@1
  int v3; // esi@2
  int result; // eax@3
  int v5; // esi@3
  int v6; // esi@5
  int i; // edi@7
  int v8; // esi@8

  v1 = this;
  v2 = *(_DWORD *)(this + 20);
  *(_DWORD *)this = off_1005C824;
  while ( v2 )
  {
    v3 = v2;
    v2 = *(_DWORD *)(v2 + 16);
    sub_100282F6(v1, *(LPVOID *)(v3 + 12));
    sub_1002404A((LPVOID)v3);
  }
  result = sub_1002404A(*(LPVOID *)(v1 + 24));
  v5 = *(_DWORD *)(v1 + 28);
  if ( v5 )
  {
    sub_100282F6(v1, *(LPVOID *)(v5 + 8));
    result = sub_1002404A((LPVOID)v5);
  }
  v6 = *(_DWORD *)(v1 + 32);
  if ( v6 )
  {
    sub_100282F6(v1, *(LPVOID *)(v6 + 8));
    result = sub_1002404A((LPVOID)v6);
  }
  for ( i = *(_DWORD *)(v1 + 40); i; result = sub_1002404A((LPVOID)v8) )
  {
    v8 = i;
    i = *(_DWORD *)(i + 16);
    sub_100282F6(v1, *(LPVOID *)(v8 + 12));
  }
  *(_DWORD *)v1 = &off_1005C830;
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005C824: using guessed type int (__stdcall *off_1005C824[4])(char);
// 1005C830: using guessed type int (__stdcall *off_1005C830)(char);

//----- (1000F8D0) --------------------------------------------------------
void *__thiscall sub_1000F8D0(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_1000F830(this);
  if ( a2 & 1 )
    sub_1002404A(v2);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1000F900) --------------------------------------------------------
int __usercall sub_1000F900<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // esi@1
  int result; // eax@2
  int v5; // ecx@2
  int v6; // eax@2
  int v7; // edx@2
  int v8; // eax@3
  int v9; // [sp+8h] [bp-10h]@2
  int v10; // [sp+14h] [bp-4h]@2

  v3 = a1;
  if ( !*(_DWORD *)(a1 + 4) )
  {
    v6 = sub_100100B0(a1, (int)&v9);
    v10 = 0;
    result = sub_1000C9E0(v7, a2, a3, v6);
    v10 = -1;
    v5 = v9;
    *(_DWORD *)(v3 + 4) = result;
    if ( !v5 )
      return result;
    v8 = (*(int (**)(void))(*(_DWORD *)v5 + 8))();
    if ( v8 )
      (**(void (__thiscall ***)(_DWORD, _DWORD))v8)(v8, 1);
  }
  return *(_DWORD *)(v3 + 4);
}

//----- (1000F980) --------------------------------------------------------
int __thiscall sub_1000F980(int this, int a2)
{
  unsigned int v2; // edx@1
  int v3; // edi@1
  int result; // eax@4

  v2 = *(_DWORD *)(this + 12);
  v3 = *(_DWORD *)this;
  *(_DWORD *)a2 = *(_DWORD *)this;
  *(_DWORD *)(a2 + 4) = 0;
  if ( v2 )
  {
    if ( (signed int)v2 < 0 && v2 )
    {
      result = a2;
      *(_DWORD *)a2 = v3 - (4 * ((-1 - v2) >> 5) + 4);
      *(_DWORD *)(a2 + 4) = v2 & 0x1F;
      return result;
    }
    *(_DWORD *)a2 = v3 + 4 * (v2 >> 5);
    *(_DWORD *)(a2 + 4) = v2 & 0x1F;
  }
  return a2;
}

//----- (1000F9E0) --------------------------------------------------------
int __thiscall sub_1000F9E0(int this, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // ecx@1
  int v7; // ebx@1
  unsigned int v8; // esi@1
  int v9; // eax@3
  int v10; // edx@3
  unsigned int v11; // edx@4
  int v12; // ecx@10
  int v13; // ecx@12
  int result; // eax@14
  int v15; // [sp+14h] [bp-20h]@1
  unsigned int v16; // [sp+18h] [bp-1Ch]@1
  int v17; // [sp+1Ch] [bp-18h]@1
  int v18; // [sp+20h] [bp-14h]@1
  int v19; // [sp+24h] [bp-10h]@1
  unsigned int v20; // [sp+28h] [bp-Ch]@2
  unsigned int v21; // [sp+2Ch] [bp-8h]@1
  int v22; // [sp+34h] [bp+0h]@1

  v21 = (unsigned int)&v22 ^ __security_cookie;
  v17 = a2;
  v7 = this;
  v18 = this;
  v15 = 0;
  sub_100100D0(this, (int)&v15, a3, a4);
  v19 = 0;
  sub_100100D0(v7, (int)&v19, a5, a6);
  v6 = *(_DWORD *)v7;
  v8 = v16 + 32 * ((v15 - *(_DWORD *)v7) >> 2);
  if ( v15 != v19 || v16 != v20 )
  {
    v10 = 0;
    v9 = *(_DWORD *)(v18 + 12);
    if ( v9 )
    {
      v11 = *(_DWORD *)(v18 + 12);
      if ( v9 < 0 && v9 )
      {
        v8 = v16 + 32 * ((v15 - *(_DWORD *)v7) >> 2);
        v6 = -4 - 4 * ((-1 - v11) >> 5) + *(_DWORD *)v18;
      }
      else
      {
        v6 += 4 * (v11 >> 5);
      }
      v10 = v11 & 0x1F;
    }
    sub_100135F0(&v19, v17, v19, v20, v6, v10, v15, v16);
    loc_10010220(v18, v20 + 32 * ((v19 - *(_DWORD *)v18) >> 2));
  }
  v20 = 0;
  v12 = *(_DWORD *)v18;
  if ( (signed int)v8 < 0 && v8 )
    v13 = -4 - 4 * ((-1 - v8) >> 5) + v12;
  else
    v13 = v12 + 4 * (v8 >> 5);
  result = v17;
  *(_DWORD *)v17 = v13;
  *(_DWORD *)(result + 4) = v8 & 0x1F;
  return result;
}
// 10067210: using guessed type int __security_cookie;

//----- (1000FB10) --------------------------------------------------------
int __thiscall sub_1000FB10(void *this, int a2, int a3, int a4, int a5, int a6)
{
  unsigned int v6; // edx@1
  unsigned int v7; // edi@1
  void *v8; // ebx@1
  int v9; // edx@5
  int v10; // ecx@7
  int v11; // ecx@9
  int v12; // esi@9
  int result; // eax@11
  void *v14; // [sp+14h] [bp-8h]@1
  int v15; // [sp+18h] [bp-4h]@1
  int v16; // [sp+28h] [bp+Ch]@1
  int v17; // [sp+28h] [bp+Ch]@3

  v8 = this;
  v14 = this;
  v7 = loc_10010140(a3, a5, a6);
  v6 = v7 + a3;
  v15 = *(_DWORD *)v8;
  v16 = *(_DWORD *)v8;
  if ( (signed int)v6 < 0 && v6 )
    v17 = -4 - 4 * ((-1 - v6) >> 5) + v16;
  else
    v17 = v16 + 4 * (v6 >> 5);
  v9 = v6 & 0x1F;
  if ( (signed int)v7 < 0 && v7 )
    v10 = -4 - 4 * ((-1 - v7) >> 5) + v15;
  else
    v10 = v15 + 4 * (v7 >> 5);
  v12 = v7 & 0x1F;
  sub_10012750(v7 & 0x1F, a4, v10, v7 & 0x1F, v17, v9);
  v11 = *(_DWORD *)v14;
  if ( (signed int)v7 < 0 && v7 )
  {
    result = a2;
    *(_DWORD *)a2 = -4 - 4 * ((-1 - v7) >> 5) + v11;
    *(_DWORD *)(a2 + 4) = v12;
  }
  else
  {
    result = a2;
    *(_DWORD *)(a2 + 4) = v12;
    *(_DWORD *)a2 = v11 + 4 * (v7 >> 5);
  }
  return result;
}

//----- (1000FC10) --------------------------------------------------------
int __thiscall sub_1000FC10(int this, int a2)
{
  int v2; // ebx@1
  int v3; // eax@2
  const void *v4; // edi@2
  int v6; // edx@4
  void *v7; // ecx@4
  const void *v8; // edi@7
  unsigned int v9; // esi@7
  unsigned int v10; // esi@11
  int v11; // [sp+8h] [bp-4h]@4

  v2 = this;
  if ( this != a2 )
  {
    v3 = *(_DWORD *)(a2 + 4);
    v4 = *(const void **)a2;
    if ( *(_DWORD *)a2 == v3 )
    {
      *(_DWORD *)(this + 4) = *(_DWORD *)this;
      return this;
    }
    v7 = *(void **)this;
    v6 = (v3 - (_DWORD)v4) >> 2;
    v11 = (*(_DWORD *)(v2 + 4) - *(_DWORD *)v2) >> 2;
    if ( v6 <= (unsigned int)v11 )
    {
      sub_100237D0(v7, v4, (v3 - (_DWORD)v4) & 0xFFFFFFFC);
      *(_DWORD *)(v2 + 4) = *(_DWORD *)v2 + 4 * ((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 2);
      return v2;
    }
    if ( v6 <= (unsigned int)((*(_DWORD *)(v2 + 8) - (_DWORD)v7) >> 2) )
    {
      v8 = (char *)v4 + 4 * v11;
      sub_100237D0(v7, *(const void **)a2, (unsigned int)((char *)v8 - *(_DWORD *)a2) & 0xFFFFFFFC);
      v9 = 4 * ((*(_DWORD *)(a2 + 4) - (_DWORD)v8) >> 2);
      *(_DWORD *)(v2 + 4) = (char *)sub_100237D0(*(void **)(v2 + 4), v8, v9) + v9;
      return v2;
    }
    if ( v7 )
      sub_1002404A(v7);
    if ( (unsigned __int8)loc_1000ED20(v2, (*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 2) )
    {
      v10 = 4 * ((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 2);
      *(_DWORD *)(v2 + 4) = (char *)sub_100237D0(*(void **)v2, *(const void **)a2, v10) + v10;
    }
  }
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1000FD20) --------------------------------------------------------
int __thiscall sub_1000FD20(int this, unsigned int a2)
{
  signed __int64 v2; // qax@1
  int v3; // ecx@1
  unsigned int v4; // ebx@1
  int v5; // edi@1
  int v6; // esi@1
  int v8; // [sp+Ch] [bp-4h]@1

  v4 = a2;
  v5 = this;
  v6 = *(_DWORD *)(this + 4);
  v8 = this;
  v2 = 715827883i64 * (*(_DWORD *)(this + 4) - *(_DWORD *)this);
  v3 = (HIDWORD(v2) >> 1) + (HIDWORD(v2) >> 31);
  if ( v3 <= a2 )
  {
    if ( v3 < a2 )
    {
      loc_10010310(v5, a2 - v3);
      sub_100127A0(*(_DWORD *)(v5 + 4), v4 - (*(_DWORD *)(v5 + 4) - *(_DWORD *)v8) / 12);
      LODWORD(v2) = *(_DWORD *)(v8 + 4) + 12 * (v4 - (*(_DWORD *)(v8 + 4) - *(_DWORD *)v8) / 12);
      *(_DWORD *)(v8 + 4) = v2;
    }
  }
  else
  {
    LODWORD(v2) = sub_10010290(v5, (int)&a2, *(_DWORD *)v5 + 12 * a2, v6);
  }
  return v2;
}

//----- (1000FE50) --------------------------------------------------------
int __thiscall sub_1000FE50(void *this, int a2, int a3, int a4)
{
  (*(void (__stdcall **)(int, int, int, _DWORD))(*(_DWORD *)this + 16))(a2, a3, a4, 0);
  return a2;
}

//----- (1000FE80) --------------------------------------------------------
bool __userpurge sub_1000FE80<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  bool result; // eax@2

  v6 = sub_1002247B(a2, a3, a4, a5, a6, a1 + 8);
  if ( v6 >= 0 )
    result = v6 != 0;
  else
    result = -1;
  return result;
}

//----- (1000FEC0) --------------------------------------------------------
int __thiscall sub_1000FEC0(void *this, int a2, const CHAR *a3, UINT a4)
{
  signed int v4; // eax@1
  UINT v5; // ebx@1
  unsigned int v6; // ecx@3
  char v7; // cf@4
  unsigned int v8; // eax@8
  int v9; // edx@9
  WCHAR *v10; // ecx@12
  unsigned int v11; // ecx@16
  char v12; // cf@17
  int v14; // [sp+30h] [bp+10h]@2

  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  v5 = a4;
  v4 = a4 - (_DWORD)a3;
  if ( (const CHAR *)a4 != a3 )
  {
    v14 = (int)((char *)this + 8);
    do
    {
      v6 = *(_DWORD *)(a2 + 16);
      if ( v4 > v6 )
      {
        loc_10007D30(a2, v4 - v6, 0);
      }
      else
      {
        v7 = *(_DWORD *)(a2 + 20) < 0x10u;
        *(_DWORD *)(a2 + 16) = v4;
        if ( v7 )
          *(_BYTE *)(a2 + v4) = 0;
        else
          *(_BYTE *)(*(_DWORD *)a2 + v4) = 0;
      }
      v8 = *(_DWORD *)(a2 + 20);
      if ( v8 < 0x10 )
        v9 = a2;
      else
        v9 = *(_DWORD *)a2;
      if ( v8 < 0x10 )
        v10 = (WCHAR *)a2;
      else
        v10 = *(WCHAR **)a2;
      v4 = sub_10022510(v10, v9 + *(_DWORD *)(a2 + 16), a3, v5, v14);
    }
    while ( (unsigned int)v4 > *(_DWORD *)(a2 + 16) && v4 );
  }
  v11 = *(_DWORD *)(a2 + 16);
  if ( v4 > v11 )
  {
    loc_10007D30(a2, v4 - v11, 0);
  }
  else
  {
    v12 = *(_DWORD *)(a2 + 20) < 0x10u;
    *(_DWORD *)(a2 + 16) = v4;
    if ( v12 )
      *(_BYTE *)(a2 + v4) = 0;
    else
      *(_BYTE *)(*(_DWORD *)a2 + v4) = 0;
  }
  return a2;
}

//----- (1000FFD0) --------------------------------------------------------
int __stdcall sub_1000FFD0(int a1, int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  int v4; // eax@2

  v2 = -2128831035;
  v3 = 0;
  if ( a2 != a1 )
  {
    do
    {
      v4 = *(_BYTE *)(v3++ + a1);
      v2 = 16777619 * (v4 ^ v2);
    }
    while ( v3 < a2 - a1 );
  }
  return v2;
}

//----- (10010010) --------------------------------------------------------
int __thiscall sub_10010010(int this, int a2, int a3)
{
  unsigned int v3; // edx@1
  int v4; // esi@1
  int result; // eax@3
  int v6; // edx@3
  unsigned int v7; // edx@4

  v3 = *(_DWORD *)(this + 4);
  v4 = *(_DWORD *)this;
  if ( a3 >= 0 || v3 >= -a3 )
  {
    v7 = a3 + v3;
    result = a2;
    *(_DWORD *)a2 = v4 + 4 * (v7 >> 5);
    *(_DWORD *)(a2 + 4) = v7 & 0x1F;
  }
  else
  {
    v6 = a3 + v3;
    result = a2;
    *(_DWORD *)a2 = -4 - 4 * ((unsigned int)(-1 - v6) >> 5) + v4;
    *(_DWORD *)(a2 + 4) = v6 & 0x1F;
  }
  return result;
}

//----- (10010070) --------------------------------------------------------
void *__userpurge sub_10010070<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1
  void *v4; // ST00_4@1

  v3 = (void *)a1;
  v4 = *(void **)(a1 + 12);
  *(_DWORD *)a1 = &off_1005573C;
  sub_100282F6(a2, v4);
  *(_DWORD *)v3 = &off_10055634;
  if ( a3 & 1 )
    sub_1002404A(v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10055634: using guessed type int (__stdcall *off_10055634)(char);
// 1005573C: using guessed type int (__stdcall *off_1005573C)(char);

//----- (100100B0) --------------------------------------------------------
int __thiscall sub_100100B0(int this, int a2)
{
  int v3; // ecx@1

  v3 = *(_DWORD *)(this + 8);
  *(_DWORD *)a2 = v3;
  (*(void (**)(void))(*(_DWORD *)v3 + 4))();
  return a2;
}

//----- (100100D0) --------------------------------------------------------
int __thiscall sub_100100D0(int this, int a2, int a3, int a4)
{
  unsigned int v4; // esi@2
  int v5; // esi@2
  char v6; // sf@2

  *(_DWORD *)a2 = 0;
  *(_DWORD *)a2 = *(_DWORD *)this;
  *(_DWORD *)(a2 + 4) = 0;
  if ( *(_DWORD *)(this + 12) )
  {
    v5 = 32 * ((a3 - *(_DWORD *)this) >> 2);
    v6 = a4 + v5 < 0;
    v4 = a4 + v5;
    if ( v6 && v4 )
    {
      *(_DWORD *)a2 += -4 - 4 * ((-1 - v4) >> 5);
      *(_DWORD *)(a2 + 4) = v4 & 0x1F;
      return a2;
    }
    *(_DWORD *)a2 += 4 * (v4 >> 5);
    *(_DWORD *)(a2 + 4) = v4 & 0x1F;
  }
  return a2;
}

//----- (10010290) --------------------------------------------------------
int __thiscall sub_10010290(int this, int a2, int a3, int a4)
{
  int v4; // edx@1
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@5
  int v8; // ecx@5
  int v9; // edx@6

  v4 = a3;
  v5 = this;
  v6 = a4;
  if ( a3 != *(_DWORD *)this || a4 != *(_DWORD *)(this + 4) )
  {
    if ( a3 != a4 )
    {
      v7 = *(_DWORD *)(this + 4);
      v8 = a3;
      if ( a4 != v7 )
      {
        v9 = *(_DWORD *)(v5 + 4);
        do
        {
          *(_DWORD *)v8 = *(_DWORD *)v6;
          *(_DWORD *)(v8 + 4) = *(_DWORD *)(v6 + 4);
          *(_BYTE *)(v8 + 8) = *(_BYTE *)(v6 + 8);
          v6 += 12;
          v8 += 12;
        }
        while ( v6 != v9 );
        v4 = a3;
      }
      *(_DWORD *)(v5 + 4) = v8;
    }
  }
  else
  {
    *(_DWORD *)(this + 4) = *(_DWORD *)this;
  }
  *(_DWORD *)a2 = v4;
  return a2;
}

//----- (100103B0) --------------------------------------------------------
int __thiscall sub_100103B0(int this, unsigned int a2, int a3)
{
  int result; // eax@1
  int v4; // ecx@1
  int v5; // ebx@1
  void *v6; // edi@1
  void *v7; // esi@2
  char v8; // [sp+8h] [bp-4h]@8

  v5 = this;
  result = *(_DWORD *)(this + 4);
  v6 = *(void **)this;
  v4 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 2;
  if ( v4 <= a2 )
  {
    if ( v4 < a2 )
      result = loc_100104C0(v5, &v8, result, a2 - v4, a3);
  }
  else
  {
    v7 = (char *)v6 + 4 * a2;
    if ( v7 == v6 )
    {
      *(_DWORD *)(v5 + 4) = v6;
    }
    else
    {
      if ( v7 != (void *)result )
      {
        sub_100237D0(v7, (const void *)result, 0);
        result = (int)((char *)v6 + 4 * a2);
        *(_DWORD *)(v5 + 4) = v7;
      }
    }
  }
  return result;
}

//----- (10010430) --------------------------------------------------------
int __thiscall sub_10010430(void *this, int a2, void *a3, const void *a4)
{
  void *v4; // eax@1
  void *v5; // ecx@1
  unsigned int v7; // esi@6
  void *v8; // [sp+8h] [bp-8h]@1

  v4 = this;
  v5 = *(void **)this;
  v8 = v4;
  if ( a3 == v5 && a4 == *((const void **)v4 + 1) )
  {
    *((_DWORD *)v4 + 1) = v5;
LABEL_4:
    *(_DWORD *)a2 = a3;
    return a2;
  }
  if ( a3 == a4 )
    goto LABEL_4;
  v7 = 4 * ((*((_DWORD *)v4 + 1) - (_DWORD)a4) >> 2);
  sub_100237D0(a3, a4, v7);
  *((_DWORD *)v8 + 1) = (char *)a3 + v7;
  *(_DWORD *)a2 = a3;
  return a2;
}

//----- (100106D0) --------------------------------------------------------
int __thiscall sub_100106D0(int this, int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  int v4; // edx@2
  int result; // eax@4
  int v6; // edx@5

  v2 = (*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 2;
  v3 = (unsigned int)(*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 3;
  if ( 1073741823 - v3 >= v2 )
  {
    v6 = v3 + v2;
    if ( v6 < (unsigned int)a2 )
      v6 = a2;
    result = v6;
  }
  else
  {
    v4 = 0;
    if ( (unsigned int)a2 > 0 )
      v4 = a2;
    result = v4;
  }
  return result;
}

//----- (10010710) --------------------------------------------------------
int __userpurge sub_10010710<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6)
{
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // edi@1
  int v10; // [sp+14h] [bp-10h]@1
  int v11; // [sp+20h] [bp-4h]@3

  v8 = a1;
  *(_DWORD *)a1 = a4;
  *(_DWORD *)(a1 + 4) = a4;
  *(_DWORD *)(a1 + 8) = a5;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  v10 = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  sub_1000ECE0((void *)(a1 + 20), 0, (int)&v10);
  *(_DWORD *)(v8 + 32) = 0;
  v7 = *(_DWORD *)(v8 + 20);
  v6 = (*(_DWORD *)(v8 + 24) - v7) >> 2;
  if ( v6 )
    sub_10010430((void *)(v8 + 20), (int)&v10, (void *)v7, *(const void **)(v8 + 24));
  *(_DWORD *)(v8 + 32) = 0;
  v11 = 1;
  sub_100117D0(v6, v8 + 36, a2, v8, a3, v7);
  *(_DWORD *)(v8 + 60) = a3;
  *(_DWORD *)(v8 + 64) = 1;
  *(_DWORD *)(v8 + 80) = 142040571;
  sub_10011500((void *)v8);
  return v8;
}

//----- (100107F0) --------------------------------------------------------
#error "10010876: positive sp value has been found (funcsize=47)"

//----- (10010DE0) --------------------------------------------------------
int __fastcall sub_10010DE0(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, char a8)
{
  int v8; // esi@1
  int v9; // eax@2
  int v11; // [sp+8h] [bp-8h]@2
  unsigned int v12; // [sp+Ch] [bp-4h]@1
  int v13; // [sp+10h] [bp+0h]@1

  v12 = (unsigned int)&v13 ^ __security_cookie;
  v8 = a1;
  *(_DWORD *)a1 = a4;
  if ( a7 & 0x800 )
  {
    v9 = sub_10012210((int)&v11, a2, a3, a4, a5, a6, a8);
  }
  else
  {
    if ( a7 & 0x100 )
    {
      v9 = sub_10012410((int)&v11, a2, a3, (int *)a4, a5, a6, a8);
    }
    else
    {
      LOBYTE(v11) = 0;
      v9 = sub_100124C0((int)&v11, a2, a3, a4, a5, v11, a8);
    }
  }
  *(_DWORD *)v8 = *(_DWORD *)v9;
  return v8;
}
// 10067210: using guessed type int __security_cookie;

//----- (10010E70) --------------------------------------------------------
int __fastcall sub_10010E70(int a1, int a2, int a3, int a4)
{
  int v4; // eax@1
  int v5; // edx@2
  unsigned int v6; // eax@3
  int v7; // ecx@4
  unsigned int v8; // ebx@4
  int v9; // edx@5
  char v10; // al@6
  char v11; // zf@6
  int result; // eax@14
  int v13; // [sp+Ch] [bp-14h]@2
  int v14; // [sp+10h] [bp-10h]@1
  unsigned int v15; // [sp+14h] [bp-Ch]@3
  int v16; // [sp+18h] [bp-8h]@1
  int v17; // [sp+1Ch] [bp-4h]@2

  v4 = a2;
  v16 = a2;
  v14 = a1;
  if ( a2 )
  {
    while ( 1 )
    {
      v5 = 0;
      v17 = 0;
      v13 = *(_DWORD *)(v4 + 8);
      if ( v13 > 0 )
        break;
LABEL_12:
      v4 = *(_DWORD *)(v4 + 16);
      v16 = v4;
      if ( !v4 )
      {
        a1 = v14;
        goto LABEL_14;
      }
    }
    v6 = *(_DWORD *)v4;
    v15 = v6;
    while ( 1 )
    {
      v8 = 0;
      v7 = a3;
      if ( v6 )
      {
        v9 = v17 + *(_DWORD *)(v16 + 12);
        do
        {
          v10 = *(_BYTE *)v7++;
          v11 = v10 == *(_BYTE *)v9;
          v6 = v15;
          if ( !v11 )
            break;
          ++v8;
          ++v9;
        }
        while ( v8 < v15 );
        v5 = v17;
      }
      if ( v7 == a4 )
        break;
      v5 += v6;
      v17 = v5;
      if ( v5 >= v13 )
      {
        v4 = v16;
        goto LABEL_12;
      }
    }
    result = v14;
    *(_DWORD *)v14 = a4;
  }
  else
  {
LABEL_14:
    *(_DWORD *)a1 = a3;
    result = a1;
  }
  return result;
}

//----- (10010F00) --------------------------------------------------------
char __fastcall sub_10010F00(unsigned __int8 a1, int a2, void *a3)
{
  int v3; // ebx@1
  void *v4; // edi@1
  int v5; // esi@1
  int v6; // ecx@8
  int *v7; // ecx@9
  int v8; // ecx@11
  int v9; // esi@13
  int *v10; // edx@23
  int *v11; // eax@25
  unsigned int v12; // esi@27
  char v13; // cf@30
  int v14; // esi@30
  char v15; // cf@32
  unsigned __int8 v16; // cf@34
  unsigned __int8 v17; // cl@36
  unsigned __int8 v18; // cl@38
  unsigned __int8 v19; // al@40
  int v20; // eax@41
  char v21; // bl@48
  int v23; // [sp-8h] [bp-80h]@11
  void *v24; // [sp+10h] [bp-68h]@1
  unsigned int v25; // [sp+24h] [bp-54h]@5
  void *v26; // [sp+28h] [bp-50h]@1
  int v27; // [sp+2Ch] [bp-4Ch]@8
  int v28; // [sp+30h] [bp-48h]@1
  void *v29; // [sp+34h] [bp-44h]@1
  unsigned int v30; // [sp+44h] [bp-34h]@1
  unsigned int v31; // [sp+48h] [bp-30h]@1
  void *v32; // [sp+4Ch] [bp-2Ch]@1
  unsigned int v33; // [sp+5Ch] [bp-1Ch]@1
  unsigned int v34; // [sp+60h] [bp-18h]@1
  unsigned int v35; // [sp+64h] [bp-14h]@1
  int v36; // [sp+74h] [bp-4h]@1
  int v37; // [sp+78h] [bp+0h]@1

  v35 = (unsigned int)&v37 ^ __security_cookie;
  v3 = a2;
  v28 = a2;
  v4 = a3;
  v26 = a3;
  v34 = 15;
  v33 = 0;
  LOBYTE(v32) = 0;
  v36 = 0;
  v31 = 15;
  LOWORD(v29) = a1;
  v30 = 1;
  LOBYTE(v36) = 1;
  v5 = sub_10012560(a3, (int)&v24, (int)&v29, (int)((char *)&v29 + 1));
  if ( &v29 != (void **)v5 )
  {
    if ( v31 >= 0x10 )
      sub_1002404A(v29);
    v31 = 15;
    v30 = 0;
    LOBYTE(v29) = 0;
    sub_10002780(&v29, v5);
  }
  if ( v25 >= 0x10 )
    sub_1002404A(v24);
  if ( !v3 )
  {
LABEL_48:
    v21 = 0;
    goto LABEL_49;
  }
  while ( 1 )
  {
    v6 = 0;
    v27 = 0;
    if ( *(_DWORD *)(v3 + 8) > 0 )
      break;
LABEL_47:
    v3 = *(_DWORD *)(v3 + 16);
    v28 = v3;
    if ( !v3 )
      goto LABEL_48;
  }
  while ( 1 )
  {
    loc_10001BD0(&v32, v6 + *(_DWORD *)(v3 + 12), *(_DWORD *)v3);
    v7 = (int *)&v32;
    if ( v34 >= 0x10 )
      v7 = (int *)v32;
    v23 = (int)((char *)v7 + v33);
    v8 = (int)&v32;
    if ( v34 >= 0x10 )
      v8 = (int)v32;
    v9 = sub_10012560(v4, (int)&v24, v8, v23);
    if ( &v32 != (void **)v9 )
    {
      if ( v34 >= 0x10 )
        sub_1002404A(v32);
      v34 = 15;
      v33 = 0;
      LOBYTE(v32) = 0;
      if ( *(_DWORD *)(v9 + 20) >= 0x10u )
      {
        v32 = *(void **)v9;
        *(_DWORD *)v9 = 0;
      }
      else
      {
        if ( *(_DWORD *)(v9 + 16) != -1 )
          sub_100237D0(&v32, (const void *)v9, *(_DWORD *)(v9 + 16) + 1);
      }
      v33 = *(_DWORD *)(v9 + 16);
      v34 = *(_DWORD *)(v9 + 20);
      *(_DWORD *)(v9 + 20) = 15;
      *(_DWORD *)(v9 + 16) = 0;
      *(_BYTE *)v9 = 0;
    }
    if ( v25 >= 0x10 )
      sub_1002404A(v24);
    v10 = (int *)&v29;
    if ( v31 >= 0x10 )
      v10 = (int *)v29;
    v11 = (int *)&v32;
    if ( v34 >= 0x10 )
      v11 = (int *)v32;
    v12 = v30;
    if ( v33 < v30 )
      v12 = v33;
    if ( !v12 )
      break;
    v13 = v12 < 4;
    v14 = v12 - 4;
    if ( v13 )
    {
LABEL_33:
      if ( v14 == -4 )
        goto LABEL_42;
    }
    else
    {
      while ( *v11 == *v10 )
      {
        ++v11;
        ++v10;
        v15 = (unsigned int)v14 < 4;
        v14 -= 4;
        if ( v15 )
          goto LABEL_33;
      }
    }
    v16 = *(_BYTE *)v11 < *(_BYTE *)v10;
    if ( *(_BYTE *)v11 != *(_BYTE *)v10
      || v14 != -3
      && ((v17 = *((_BYTE *)v11 + 1), v16 = v17 < *((_BYTE *)v10 + 1), v17 != *((_BYTE *)v10 + 1))
       || v14 != -2
       && ((v18 = *((_BYTE *)v11 + 2), v16 = v18 < *((_BYTE *)v10 + 2), v18 != *((_BYTE *)v10 + 2))
        || v14 != -1 && (v19 = *((_BYTE *)v11 + 3), v16 = v19 < *((_BYTE *)v10 + 3), v19 != *((_BYTE *)v10 + 3)))) )
    {
      v20 = -v16 | 1;
      goto LABEL_43;
    }
LABEL_42:
    v20 = 0;
LABEL_43:
    if ( !v20 )
      break;
LABEL_46:
    v3 = v28;
    v6 = *(_DWORD *)v28 + v27;
    v4 = v26;
    v27 = v6;
    if ( v6 >= *(_DWORD *)(v28 + 8) )
      goto LABEL_47;
  }
  if ( v33 < v30 || v33 != v30 )
    goto LABEL_46;
  v21 = 1;
LABEL_49:
  if ( v31 >= 0x10 )
    sub_1002404A(v29);
  v31 = 15;
  v30 = 0;
  LOBYTE(v29) = 0;
  if ( v34 >= 0x10 )
    sub_1002404A(v32);
  return v21;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (100111B0) --------------------------------------------------------
int __fastcall sub_100111B0(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a3;
  for ( _ESI = a1; _ESI != a2; result += 12 )
  {
    if ( result )
    {
      __asm
      {
        movq    xmm0, qword ptr [esi]
        movq    qword ptr [eax], xmm0
      }
      *(_DWORD *)(result + 8) = *(_DWORD *)(_ESI + 8);
    }
    _ESI += 12;
  }
  return result;
}

//----- (100111E0) --------------------------------------------------------
void *__thiscall sub_100111E0(void *this, int a2, int a3)
{
  void *result; // eax@1

  result = this;
  for ( _ECX = a2; _ECX != a3; result = (char *)result + 12 )
  {
    if ( result )
    {
      __asm
      {
        movq    xmm0, qword ptr [ecx]
        movq    qword ptr [eax], xmm0
      }
      *((_DWORD *)result + 2) = *(_DWORD *)(_ECX + 8);
    }
    _ECX += 12;
  }
  return result;
}

//----- (10011220) --------------------------------------------------------
void __fastcall sub_10011220(int _ECX, int a2)
{
  for ( ; a2; --a2 )
  {
    if ( _ECX )
    {
      __asm
      {
        xorps   xmm0, xmm0
        movq    qword ptr [ecx], xmm0
      }
    }
    _ECX += 8;
  }
}

//----- (10011240) --------------------------------------------------------
int __fastcall sub_10011240(int a1, int a2, int a3)
{
  int result; // eax@1

  for ( result = a3; a1 != a2; result += 8 )
  {
    *(_DWORD *)result = *(_DWORD *)a1;
    *(_DWORD *)(result + 4) = *(_DWORD *)(a1 + 4);
    a1 += 8;
  }
  return result;
}

//----- (10011270) --------------------------------------------------------
int __usercall sub_10011270<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4)
{
  int v4; // edx@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // ecx@5
  int v8; // esi@6
  int v9; // eax@10
  int v10; // edx@17
  int v11; // ecx@17
  char v13; // [sp+Ch] [bp-2Ch]@16
  void *v14; // [sp+18h] [bp-20h]@1
  int v15; // [sp+1Ch] [bp-1Ch]@1
  char v16; // [sp+20h] [bp-18h]@1
  char v17; // [sp+24h] [bp-14h]@2
  unsigned int v18; // [sp+28h] [bp-10h]@1
  int v19; // [sp+34h] [bp-4h]@1
  int v20; // [sp+38h] [bp+0h]@1

  v18 = (unsigned int)&v20 ^ __security_cookie;
  v14 = (void *)a4;
  sub_1002210B(a1, (int)&v16, a2, a3, 0);
  v19 = 0;
  v6 = dword_1006A388;
  v5 = dword_1006A0F4;
  v15 = dword_1006A0F4;
  if ( !dword_1006A388 )
  {
    sub_1002210B(v4, (int)&v17, dword_1006A0F4, dword_1006A388, dword_1006A388);
    if ( dword_1006A388 == v6 )
    {
      ++dword_10068F04;
      dword_1006A388 = dword_10068F04;
    }
    sub_10022167(&v17);
    v6 = dword_1006A388;
  }
  v7 = *(_DWORD *)a4;
  if ( (unsigned int)v6 >= *(_DWORD *)(*(_DWORD *)a4 + 12) )
  {
    v8 = 0;
  }
  else
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v7 + 8) + 4 * v6);
    if ( v8 )
      goto LABEL_18;
  }
  if ( !*(_BYTE *)(v7 + 20) )
    goto LABEL_12;
  v9 = sub_10021F0C();
  if ( (unsigned int)v6 < *(_DWORD *)(v9 + 12) )
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v9 + 8) + 4 * v6);
LABEL_12:
    if ( v8 )
      goto LABEL_18;
  }
  if ( v5 )
  {
    v8 = v5;
  }
  else
  {
    if ( sub_100113A0(v7, v4, (int)&v15, v14) == -1 )
    {
      sub_10023634((int)&v13, (unsigned int)"bad cast");
      sub_1002D02B((int)&v13, (int)&unk_10061540);
    }
    v8 = v15;
    dword_1006A0F4 = v15;
    (*(void (__thiscall **)(int))(*(_DWORD *)v15 + 4))(v15);
    sub_10021EE4(v10, v11, v5, v6, v8);
  }
LABEL_18:
  sub_10022167(&v16);
  return v8;
}
// 10067210: using guessed type int __security_cookie;
// 10068F04: using guessed type int dword_10068F04;
// 1006A0F4: using guessed type int dword_1006A0F4;
// 1006A388: using guessed type int dword_1006A388;

//----- (100113A0) --------------------------------------------------------
signed int __fastcall sub_100113A0(int a1, int a2, int a3, void *a4)
{
  int v4; // ebx@1
  int v5; // esi@3
  int v6; // eax@4
  int v7; // edx@4
  int v8; // edx@6
  void *v10; // [sp+18h] [bp-5Ch]@4
  unsigned int v11; // [sp+2Ch] [bp-48h]@11
  char v12; // [sp+30h] [bp-44h]@6
  int v13; // [sp+70h] [bp-4h]@3

  v4 = 0;
  if ( a3 )
  {
    if ( !*(_DWORD *)a3 )
    {
      v5 = sub_10027EB3(a2, a1, 0, a3, 16);
      v13 = 0;
      if ( v5 )
      {
        v6 = sub_100159A0(a4, (int)&v10);
        LOBYTE(v13) = 1;
        if ( *(_DWORD *)(v6 + 20) >= 0x10u )
          v6 = *(_DWORD *)v6;
        sub_1000C780(v7, (int)&v12, 0, v6);
        v4 = 3;
        *(_DWORD *)(v5 + 4) = 0;
        *(_DWORD *)v5 = &off_1005573C;
        *(_DWORD *)(v5 + 8) = sub_1002245A(3, a3);
        *(_DWORD *)(v5 + 12) = v8;
      }
      else
      {
        v5 = 0;
      }
      *(_DWORD *)a3 = v5;
      if ( v4 & 2 )
      {
        v4 &= 0xFFFFFFFDu;
        sub_1000C870(&v12, v4);
      }
      if ( v4 & 1 )
      {
        if ( v11 >= 0x10 )
          sub_1002404A(v10);
      }
    }
  }
  return 1;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005573C: using guessed type int (__stdcall *off_1005573C)(char);

//----- (10011490) --------------------------------------------------------
int __thiscall sub_10011490(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  if ( (unsigned __int8)loc_1000ED20((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 2) )
    *(_DWORD *)(v2 + 4) = sub_10013D70(*(void **)v2, *(_DWORD *)a2, *(_DWORD *)(a2 + 4));
  return v2;
}

//----- (10011500) --------------------------------------------------------
char __thiscall sub_10011500(void *this)
{
  int v1; // esi@1
  unsigned __int8 v2; // al@3
  int v3; // eax@4
  int v4; // eax@7
  char v5; // zf@13

  v1 = (int)this;
  if ( *(_DWORD *)this == *((_DWORD *)this + 2) )
  {
    *((_DWORD *)this + 19) = -1;
    *((_BYTE *)this + 72) = -1;
  }
  else
  {
    v2 = **(_BYTE **)this;
    *((_BYTE *)this + 72) = v2;
    if ( sub_100283A0((int)"()$^.*+?[]|\\-{},:=!\n\r\b", v2) )
      v3 = *(_BYTE *)(v1 + 72);
    else
      v3 = 0;
    *(_DWORD *)(v1 + 76) = v3;
  }
  v4 = *(_BYTE *)(v1 + 72) - 10;
  switch ( *(_BYTE *)(v1 + 72) )
  {
    case 92:
      LOBYTE(v4) = sub_10012920(v1);
      if ( (_BYTE)v4 )
      {
        LOBYTE(v4) = *(_BYTE *)(*(_DWORD *)v1 + 1);
        *(_BYTE *)(v1 + 72) = v4;
        *(_DWORD *)(v1 + 76) = (char)v4;
      }
      return v4;
    case 10:
      if ( *(_BYTE *)(v1 + 80) & 4 )
      {
        if ( !*(_DWORD *)(v1 + 16) )
          *(_DWORD *)(v1 + 76) = 124;
      }
      return v4;
    case 40:
    case 41:
      v5 = (*(_BYTE *)(v1 + 80) & 8) == 0;
      goto LABEL_26;
    case 123:
    case 125:
      v5 = (*(_BYTE *)(v1 + 80) & 0x10) == 0;
      goto LABEL_26;
    case 42:
      if ( *(_DWORD *)(v1 + 80) & 0x4000000 )
      {
        LOBYTE(v4) = sub_10012DF0(v1 + 36);
        if ( (_BYTE)v4 )
          *(_DWORD *)(v1 + 76) = 0;
      }
      return v4;
    case 94:
      if ( !(*(_DWORD *)(v1 + 80) & 0x2000000) )
        return v4;
      LOBYTE(v4) = sub_10012DF0(v1 + 36);
      v5 = (_BYTE)v4 == 0;
      goto LABEL_26;
    case 36:
      if ( *(_DWORD *)(v1 + 80) & 0x2000000 )
      {
        v4 = *(_DWORD *)v1 + 1;
        if ( v4 != *(_DWORD *)(v1 + 8) )
        {
          if ( *(_BYTE *)v4 != 10 )
            *(_DWORD *)(v1 + 76) = 0;
        }
      }
      return v4;
    case 43:
    case 63:
      v5 = (*(_BYTE *)(v1 + 80) & 1) == 0;
      goto LABEL_26;
    case 124:
      v5 = (*(_BYTE *)(v1 + 80) & 2) == 0;
LABEL_26:
      if ( v5 )
        *(_DWORD *)(v1 + 76) = 0;
      break;
    default:
      return v4;
  }
  return v4;
}

//----- (100116B0) --------------------------------------------------------
int __thiscall sub_100116B0(int this)
{
  int result; // eax@1
  int v2; // edx@1
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // eax@3
  int v6; // eax@5
  int v7; // ecx@5
  int v8; // eax@7
  int v9; // ecx@8
  int v10; // edx@16
  int v11; // ecx@16
  int v12; // eax@17
  int v14; // ecx@20
  int i; // [sp+Ch] [bp-4h]@4

  v4 = this;
  v3 = *(_DWORD *)(this + 40);
  result = loc_100129B0();
  if ( !(_BYTE)result )
  {
    if ( *(_DWORD *)(v4 + 76) != 124 )
      return result;
    v5 = sub_10012E30(v2, v4 + 36, v3, v4);
    sub_10011850(v4 + 36, v2, v5);
  }
  result = sub_10012EA0(v2, v4 + 36, v3, v3);
  for ( i = result; *(_DWORD *)(v4 + 76) == 124; result = sub_10012F60(v4 + 36, v10, v3, i) )
  {
    v6 = *(_DWORD *)v4;
    v7 = *(_DWORD *)(v4 + 8);
    if ( *(_DWORD *)v4 != v7 )
    {
      if ( *(_BYTE *)v6 == 92 )
      {
        v8 = v6 + 1;
        if ( v8 != v7 )
        {
          v9 = *(_DWORD *)(v4 + 80);
          if ( !(v9 & 8) && (*(_BYTE *)v8 == 40 || *(_BYTE *)v8 == 41)
            || !(v9 & 0x10) && (*(_BYTE *)v8 == 123 || *(_BYTE *)v8 == 125) )
            *(_DWORD *)v4 = v8;
        }
      }
      ++*(_DWORD *)v4;
    }
    sub_10011500((void *)v4);
    if ( !(unsigned __int8)loc_100129B0(v4) )
    {
      v12 = sub_10027EB3(v10, v11, v3, v4, 20);
      if ( v12 )
      {
        *(_DWORD *)v12 = &off_1005C830;
        *(_DWORD *)(v12 + 4) = 8;
        *(_DWORD *)(v12 + 8) = 0;
        *(_DWORD *)(v12 + 12) = 0;
        *(_DWORD *)(v12 + 16) = 0;
      }
      else
      {
        v12 = 0;
      }
      *(_DWORD *)(v12 + 16) = *(_DWORD *)(v4 + 40);
      v14 = *(_DWORD *)(*(_DWORD *)(v4 + 40) + 12);
      if ( v14 )
      {
        *(_DWORD *)(v12 + 12) = v14;
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v4 + 40) + 12) + 16) = v12;
      }
      *(_DWORD *)(*(_DWORD *)(v4 + 40) + 12) = v12;
      *(_DWORD *)(v4 + 40) = v12;
      sub_10011850(v4 + 36, v10, v12);
    }
  }
  return result;
}
// 1005C830: using guessed type int (__stdcall *off_1005C830)(char);

//----- (100117D0) --------------------------------------------------------
int __userpurge sub_100117D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6)
{
  int v6; // eax@1
  int v7; // esi@1

  v7 = a2;
  v6 = sub_10027EB3(a1, a2, a3, a4, 36);
  if ( v6 )
  {
    *(_DWORD *)(v6 + 4) = 20;
    *(_DWORD *)(v6 + 8) = 0;
    *(_DWORD *)(v6 + 12) = 0;
    *(_DWORD *)(v6 + 16) = 0;
    *(_DWORD *)v6 = &off_1005C830;
    *(_DWORD *)(v6 + 24) = 0;
    *(_DWORD *)(v6 + 28) = 0;
    *(_DWORD *)(v6 + 32) = 0;
  }
  else
  {
    v6 = 0;
  }
  *(_DWORD *)v7 = v6;
  *(_DWORD *)(v7 + 4) = v6;
  *(_DWORD *)(v7 + 12) = a5;
  *(_DWORD *)(v7 + 8) = 1;
  *(_DWORD *)(v7 + 16) = 256;
  *(_DWORD *)(v7 + 20) = 4;
  return v7;
}
// 1005C830: using guessed type int (__stdcall *off_1005C830)(char);

//----- (10011850) --------------------------------------------------------
int __fastcall sub_10011850(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // esi@1
  int v5; // ebx@2
  int v6; // eax@6
  int v7; // ecx@6
  int v8; // eax@9
  int result; // eax@11

  v4 = a1;
  v3 = *(_DWORD *)(a3 + 4);
  if ( v3 == 8 )
  {
    v5 = 9;
  }
  else
  {
    if ( v3 == 10 )
      v5 = 12;
    else
      v5 = 2 * (v3 != 11) + 12;
  }
  v6 = sub_10027EB3(a2, a1, v5, a3, 24);
  v7 = v6;
  if ( v6 )
  {
    *(_DWORD *)(v6 + 4) = v5;
    *(_DWORD *)(v6 + 8) = 0;
    *(_DWORD *)(v6 + 12) = 0;
    *(_DWORD *)(v6 + 16) = 0;
    *(_DWORD *)v6 = &off_1005C830;
    *(_DWORD *)(v6 + 20) = a3;
  }
  else
  {
    v7 = 0;
  }
  *(_DWORD *)(v7 + 16) = *(_DWORD *)(v4 + 4);
  v8 = *(_DWORD *)(*(_DWORD *)(v4 + 4) + 12);
  if ( v8 )
  {
    *(_DWORD *)(v7 + 12) = v8;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v4 + 4) + 12) + 16) = v7;
  }
  result = *(_DWORD *)(v4 + 4);
  *(_DWORD *)(result + 12) = v7;
  *(_DWORD *)(v4 + 4) = v7;
  return result;
}
// 1005C830: using guessed type int (__stdcall *off_1005C830)(char);

//----- (100118F0) --------------------------------------------------------
int __userpurge sub_100118F0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v5 = sub_10027EB3(a1, a2, a3, a4, 24);
  if ( v5 )
  {
    *(_DWORD *)(v5 + 4) = 13;
    *(_DWORD *)(v5 + 8) = 0;
    *(_DWORD *)(v5 + 12) = 0;
    *(_DWORD *)(v5 + 16) = 0;
    *(_DWORD *)v5 = &off_1005C830;
    *(_DWORD *)(v5 + 20) = a5;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  result = v5;
  *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) = v5;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 1005C830: using guessed type int (__stdcall *off_1005C830)(char);

//----- (10011960) --------------------------------------------------------
int __usercall sub_10011960<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v4 = sub_10027EB3(a1, a2, a3, a4, 20);
  v5 = v4;
  if ( v4 )
  {
    *(_DWORD *)v4 = &off_1005C830;
    *(_DWORD *)(v4 + 4) = 21;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) = v5;
  result = *(_DWORD *)v6;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 1005C830: using guessed type int (__stdcall *off_1005C830)(char);

//----- (100119D0) --------------------------------------------------------
char __thiscall sub_100119D0(void *this, int a2)
{
  char v2; // al@1
  int v3; // ebx@1
  void *v4; // edi@1
  int v5; // eax@1
  int v6; // esi@1
  int v7; // eax@1
  int v8; // esi@2
  int v9; // ecx@3
  int v10; // eax@5
  int v11; // edi@5
  int *v12; // esi@10
  char v13; // bl@12
  void *v15; // [sp+10h] [bp-68h]@1
  int v16; // [sp+14h] [bp-64h]@1
  int v17; // [sp+18h] [bp-60h]@1
  signed int v18; // [sp+1Ch] [bp-5Ch]@1
  char v19; // [sp+23h] [bp-55h]@1
  int v20; // [sp+24h] [bp-54h]@1
  void *v21; // [sp+28h] [bp-50h]@1
  int v22; // [sp+2Ch] [bp-4Ch]@1
  int v23; // [sp+30h] [bp-48h]@1
  int v24; // [sp+34h] [bp-44h]@1
  void *v25; // [sp+38h] [bp-40h]@1
  int v26; // [sp+3Ch] [bp-3Ch]@1
  int v27; // [sp+40h] [bp-38h]@1
  int v28; // [sp+44h] [bp-34h]@1
  void *v29; // [sp+48h] [bp-30h]@1
  int v30; // [sp+4Ch] [bp-2Ch]@1
  int v31; // [sp+50h] [bp-28h]@1
  int v32; // [sp+54h] [bp-24h]@1
  void *v33; // [sp+58h] [bp-20h]@1
  int v34; // [sp+5Ch] [bp-1Ch]@1
  int v35; // [sp+60h] [bp-18h]@1
  unsigned int v36; // [sp+64h] [bp-14h]@1
  int v37; // [sp+74h] [bp-4h]@1
  int v38; // [sp+78h] [bp+0h]@1

  v36 = (unsigned int)&v38 ^ __security_cookie;
  v4 = this;
  v15 = this;
  v5 = *(_DWORD *)this;
  v3 = a2;
  v6 = (int)((char *)this + 4);
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v28 = v5;
  v16 = (int)((char *)this + 4);
  sub_10011490((int)&v29, (int)((char *)this + 4));
  v32 = *(_DWORD *)(v6 + 12);
  v37 = 0;
  v17 = (int)((char *)v4 + 20);
  sub_100127C0((int)&v33, (int)((char *)v4 + 20));
  v37 = 1;
  v7 = *(_DWORD *)v4;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v20 = v7;
  sub_10011490((int)&v21, v6);
  v24 = *(_DWORD *)(v6 + 12);
  LOBYTE(v37) = 2;
  sub_100127C0((int)&v25, (int)((char *)v4 + 20));
  v2 = 0;
  LOBYTE(v37) = 3;
  v19 = 0;
  v18 = -1;
  if ( a2 )
  {
    v8 = v28;
    do
    {
      v9 = v32;
      *(_DWORD *)v4 = v8;
      *((_DWORD *)v4 + 4) = v9;
      sub_1000FC10((int)((char *)v4 + 4), (int)&v29);
      sub_1000F6A0((char *)v4 + 20, (int)&v33);
      if ( (unsigned __int8)loc_100108B0(v4, *(_DWORD *)(v3 + 12)) )
      {
        if ( !*((_BYTE *)v4 + 108) )
        {
          v13 = 1;
          goto LABEL_13;
        }
        v10 = *(_DWORD *)v4;
        v11 = *(_DWORD *)v4 - v8;
        if ( v18 < v11 )
        {
          v20 = v10;
          v24 = *(_DWORD *)(v16 + 12);
          sub_1000FC10((int)&v21, v16);
          sub_1000F6A0(&v25, v17);
          v18 = v11;
        }
        v4 = v15;
        v2 = 1;
        v19 = 1;
      }
      else
      {
        v2 = v19;
      }
      v3 = *(_DWORD *)(v3 + 24);
    }
    while ( v3 );
  }
  v12 = &v20;
  if ( !v2 )
    v12 = &v28;
  *(_DWORD *)v4 = *v12;
  *((_DWORD *)v4 + 4) = v12[4];
  sub_1000FC10((int)((char *)v4 + 4), (int)(v12 + 1));
  sub_1000F6A0((char *)v4 + 20, (int)(v12 + 5));
  v13 = v19;
LABEL_13:
  if ( v25 )
    sub_1002404A(v25);
  if ( v21 )
    sub_1002404A(v21);
  if ( v33 )
    sub_1002404A(v33);
  if ( v29 )
    sub_1002404A(v29);
  return v13;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (10011BE0) --------------------------------------------------------
char __thiscall sub_10011BE0(void *this, int a2, char a3, signed int a4)
{
  unsigned __int8 v4; // zf@1
  char v5; // sf@1
  char v6; // of@1
  void *v7; // ebx@1
  int i; // eax@2
  int v9; // ecx@2
  bool v10; // eax@6
  int v12; // eax@9
  int v13; // eax@9
  int v14; // ecx@9
  int v15; // esi@9
  int v16; // eax@9
  int v17; // ecx@9
  char v18; // al@11
  char v19; // sf@13
  int v20; // eax@21
  int v21; // ecx@21
  int v22; // eax@26
  int v23; // edx@29
  int v24; // eax@30
  int v25; // [sp-8h] [bp-60h]@17
  int v26; // [sp+10h] [bp-48h]@9
  void *v27; // [sp+14h] [bp-44h]@9
  int v28; // [sp+18h] [bp-40h]@9
  int v29; // [sp+1Ch] [bp-3Ch]@9
  int v30; // [sp+20h] [bp-38h]@9
  void *v31; // [sp+24h] [bp-34h]@9
  int v32; // [sp+28h] [bp-30h]@9
  int v33; // [sp+2Ch] [bp-2Ch]@9
  int v34; // [sp+30h] [bp-28h]@9
  int v35; // [sp+34h] [bp-24h]@9
  int v36; // [sp+38h] [bp-20h]@9
  char v37; // [sp+3Eh] [bp-1Ah]@13
  char v38; // [sp+3Fh] [bp-19h]@9
  int v39; // [sp+40h] [bp-18h]@9
  unsigned int v40; // [sp+44h] [bp-14h]@1
  int v41; // [sp+54h] [bp-4h]@9
  int v42; // [sp+58h] [bp+0h]@1

  v40 = (unsigned int)&v42 ^ __security_cookie;
  v7 = this;
  v6 = 0;
  v4 = *(_DWORD *)(a2 + 36) == 0;
  v5 = *(_DWORD *)(a2 + 36) < 0;
  if ( *(_DWORD *)(a2 + 36) < 0 )
  {
    v9 = *(_DWORD *)(a2 + 12);
    for ( i = *(_DWORD *)(v9 + 4); i != 19; i = *(_DWORD *)(v9 + 4) )
    {
      if ( i == 16 )
        break;
      if ( i == 18 )
        break;
      v9 = *(_DWORD *)(v9 + 12);
    }
    v10 = *(_DWORD *)(v9 + 4) == 19;
    *(_DWORD *)(a2 + 36) = v10;
    v6 = 0;
    v4 = v10 == 0;
    v5 = v10 < 0;
  }
  if ( !((unsigned __int8)(v5 ^ v6) | v4) )
    return sub_10013000(v7, a2, a3);
  v13 = *(_DWORD *)v7;
  v38 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v26 = v13;
  sub_10011490((int)&v27, (int)((char *)v7 + 4));
  v30 = *((_DWORD *)v7 + 4);
  v41 = 0;
  sub_100127C0((int)&v31, (int)((char *)v7 + 20));
  v41 = 1;
  v16 = *((_DWORD *)v7 + 16);
  v17 = *(_DWORD *)(a2 + 32);
  v15 = *(_DWORD *)(v16 + 8 * v17 + 4);
  v14 = v16 + 8 * v17;
  v36 = v14;
  v34 = *(_DWORD *)v14;
  v12 = *(_DWORD *)v7;
  v35 = v15;
  v39 = v12;
  v18 = !a4 || *(_DWORD *)v15 != v12;
  v19 = *(_DWORD *)(a2 + 24) < 0;
  v37 = v18;
  if ( v19 || *(_DWORD *)(a2 + 24) > a4 )
  {
    if ( a4 < *(_DWORD *)(a2 + 20) )
    {
      if ( v18 )
      {
        *(_DWORD *)v14 = a4 + 1;
        *(_DWORD *)(v14 + 4) = &v39;
        v25 = *(_DWORD *)(a2 + 12);
        goto LABEL_28;
      }
      goto LABEL_27;
    }
    if ( !a3 )
    {
      v38 = loc_100108B0(v7, *(_DWORD *)(*(_DWORD *)(a2 + 28) + 12));
      if ( v38 )
        goto LABEL_30;
      if ( v37 )
      {
        v20 = v30;
        *(_DWORD *)v7 = v26;
        *((_DWORD *)v7 + 4) = v20;
        sub_1000FC10((int)((char *)v7 + 4), (int)&v27);
        sub_1000F6A0((char *)v7 + 20, (int)&v31);
        v21 = v36;
        *(_DWORD *)v36 = a4 + 1;
        *(_DWORD *)(v21 + 4) = &v39;
        v25 = *(_DWORD *)(a2 + 12);
        goto LABEL_28;
      }
LABEL_29:
      v23 = v30;
      *(_DWORD *)v7 = v26;
      *((_DWORD *)v7 + 4) = v23;
      sub_1000FC10((int)((char *)v7 + 4), (int)&v27);
      sub_1000F6A0((char *)v7 + 20, (int)&v31);
      goto LABEL_30;
    }
    if ( v18 )
    {
      *(_DWORD *)v14 = a4 + 1;
      *(_DWORD *)(v14 + 4) = &v39;
      v38 = loc_100108B0(v7, *(_DWORD *)(a2 + 12));
      if ( v38 )
        goto LABEL_30;
      v14 = v36;
    }
    else
    {
      if ( a4 > 1 )
        goto LABEL_29;
    }
    *(_DWORD *)v14 = v34;
    *(_DWORD *)(v14 + 4) = v35;
    v22 = v30;
    *(_DWORD *)v7 = v26;
    *((_DWORD *)v7 + 4) = v22;
    sub_1000FC10((int)((char *)v7 + 4), (int)&v27);
    sub_1000F6A0((char *)v7 + 20, (int)&v31);
  }
LABEL_27:
  v25 = *(_DWORD *)(*(_DWORD *)(a2 + 28) + 12);
LABEL_28:
  v38 = loc_100108B0(v7, v25);
  if ( !v38 )
    goto LABEL_29;
LABEL_30:
  v24 = v36;
  *(_DWORD *)v36 = v34;
  *(_DWORD *)(v24 + 4) = v35;
  if ( v31 )
    sub_1002404A(v31);
  if ( v27 )
    sub_1002404A(v27);
  return v38;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (10011E50) --------------------------------------------------------
char __thiscall sub_10011E50(int this, int a2)
{
  int v2; // ecx@1
  char v3; // bl@1
  int v4; // edi@1
  char v5; // zf@1
  int v6; // eax@1
  int v7; // esi@2
  int v8; // ecx@3
  int v9; // eax@3
  int v10; // eax@3
  int v11; // edx@3
  int v12; // eax@4
  char v13; // al@6
  int v14; // edx@7
  int v15; // esi@7
  int v16; // eax@8
  char v17; // cl@9
  char v18; // cl@13
  int v19; // eax@15
  int v20; // edx@15
  int v21; // edx@16
  unsigned int v22; // edx@21
  int v23; // ebx@23
  char v24; // zf@24
  int v25; // edx@25
  int i; // eax@26
  int v27; // ecx@26
  int v28; // eax@32
  int v29; // edx@36
  char result; // al@42
  unsigned int v31; // [sp-4h] [bp-3Ch]@1
  char v32; // [sp+10h] [bp-28h]@8
  int v33; // [sp+14h] [bp-24h]@15
  int v34; // [sp+18h] [bp-20h]@7
  int v35; // [sp+1Ch] [bp-1Ch]@3
  int v36; // [sp+20h] [bp-18h]@1
  int v37; // [sp+24h] [bp-14h]@1
  unsigned int v38; // [sp+28h] [bp-10h]@1
  int v39; // [sp+34h] [bp-4h]@3
  int v40; // [sp+38h] [bp+0h]@1

  v38 = (unsigned int)&v40 ^ __security_cookie;
  v31 = (unsigned int)&v40 ^ __security_cookie;
  v4 = this;
  v5 = (*(_DWORD *)(this + 92) & 0x100) == 0;
  v6 = *(_DWORD *)this;
  v2 = a2;
  v3 = *(_BYTE *)v6;
  v37 = a2;
  LOBYTE(v36) = v3;
  if ( !v5 )
  {
    v7 = *(_DWORD *)(v4 + 112);
    if ( !*(_DWORD *)(v7 + 4) )
    {
      v9 = sub_100100B0(v7, (int)&v35);
      v39 = 0;
      v10 = sub_1000C9E0(v11, v3, v4, v9);
      v39 = -1;
      v8 = v35;
      *(_DWORD *)(v7 + 4) = v10;
      if ( v8 )
      {
        v12 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v8 + 8))(v31);
        if ( v12 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v12)(v12, 1);
      }
    }
    v13 = (*(int (__stdcall **)(int))(**(_DWORD **)(v7 + 4) + 16))(v36);
    v2 = v37;
    v3 = v13;
    LOBYTE(v36) = v13;
  }
  v14 = *(_DWORD *)(v2 + 20);
  v15 = *(_DWORD *)v4 + 1;
  v34 = *(_DWORD *)v4 + 1;
  if ( v14 )
  {
    v16 = *(_DWORD *)sub_10010E70((int)&v32, v14, *(_DWORD *)v4, *(_DWORD *)(v4 + 80));
    if ( v16 != *(_DWORD *)v4 )
    {
      v15 = v16;
      v17 = 1;
      goto LABEL_41;
    }
    v2 = v37;
  }
  if ( *(_DWORD *)(v2 + 32) )
  {
    if ( *(_DWORD *)(v4 + 92) & 0x800 )
      v18 = sub_1000F3C0(*(_DWORD *)(v4 + 112), v3, v4, v36);
    else
      v18 = v3;
    v20 = *(_DWORD *)(v37 + 32);
    v19 = 0;
    v33 = v20;
    if ( *(_DWORD *)(v20 + 4) > 0 )
    {
      v21 = *(_DWORD *)(v20 + 8);
      while ( *(_BYTE *)(v21 + v19) > v18 || v18 > *(_BYTE *)(v21 + v19 + 1) )
      {
        v19 += 2;
        v15 = v34;
        if ( v19 >= *(_DWORD *)(v33 + 4) )
          goto LABEL_20;
      }
      goto LABEL_39;
    }
LABEL_20:
    v2 = v37;
  }
  v22 = v3;
  if ( dword_1006A0F0 > v3 || v3 >= 256 )
  {
    v25 = *(_DWORD *)(v2 + 28);
    if ( v25 )
    {
      v27 = *(_DWORD *)(v25 + 8);
      for ( i = v27 + *(_DWORD *)(v25 + 4); v27 != i; ++v27 )
      {
        if ( *(_BYTE *)v27 == v3 )
          break;
      }
      if ( v27 != *(_DWORD *)(v25 + 4) + *(_DWORD *)(v25 + 8) )
      {
        v17 = 1;
        goto LABEL_41;
      }
      v2 = v37;
    }
    v28 = *(_WORD *)(v2 + 36);
    if ( (_WORD)v28 )
    {
      if ( sub_1000F490(*(_DWORD *)(v4 + 112), v3, v36, v28) )
      {
        v17 = 1;
        goto LABEL_41;
      }
      v2 = v37;
    }
    v29 = *(_DWORD *)(v2 + 40);
    if ( !v29 )
      goto LABEL_40;
    v24 = sub_10010F00(v3, v29, *(void **)(v4 + 112)) == 0;
  }
  else
  {
    v23 = *(_DWORD *)(v2 + 24);
    if ( !v23 )
      goto LABEL_40;
    v24 = ((unsigned __int8)(1 << (v22 & 7)) & *(_BYTE *)((v22 >> 3) + v23)) == 0;
  }
  if ( !v24 )
  {
LABEL_39:
    v17 = 1;
    goto LABEL_41;
  }
LABEL_40:
  v17 = 0;
LABEL_41:
  if ( v17 == (*(_BYTE *)(v37 + 8) & 1) )
  {
    result = 0;
  }
  else
  {
    *(_DWORD *)v4 = v15;
    result = 1;
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006A0F0: using guessed type int dword_1006A0F0;

//----- (10012050) --------------------------------------------------------
char __thiscall sub_10012050(int this)
{
  unsigned int v1; // eax@1
  int v2; // edx@2
  int v3; // edi@4
  int v4; // edi@7
  int v5; // edi@9
  int v6; // edx@12
  int v7; // esi@12

  v1 = 0;
  if ( *(_DWORD *)(this + 104) <= 0 )
    return 0;
  while ( 1 )
  {
    v2 = *(_DWORD *)(this + 36);
    if ( (signed int)v1 < 0 && v1 )
      v3 = v2 - (4 * ((-1 - v1) >> 5) + 4);
    else
      v3 = v2 + 4 * (v1 >> 5);
    if ( !((1 << (v1 & 0x1F)) & *(_DWORD *)v3)
      || ((v4 = *(_DWORD *)(this + 4), (signed int)v1 >= 0) || !v1 ? (v5 = v4 + 4 * (v1 >> 5)) : (v5 = v4 - (4 * ((-1 - v1) >> 5) + 4)),
          !((1 << (v1 & 0x1F)) & *(_DWORD *)v5)) )
      goto LABEL_14;
    v6 = *(_DWORD *)(this + 52) + 8 * v1;
    v7 = *(_DWORD *)(this + 20) + 8 * v1;
    if ( *(_DWORD *)v6 != *(_DWORD *)v7 )
      return *(_DWORD *)(*(_DWORD *)(this + 52) + 8 * v1) - *(_DWORD *)(this + 76) < *(_DWORD *)(*(_DWORD *)(this + 20)
                                                                                               + 8 * v1)
                                                                                   - *(_DWORD *)(this + 76);
    if ( *(_DWORD *)(v6 + 4) != *(_DWORD *)(v7 + 4) )
      return *(_DWORD *)(*(_DWORD *)(this + 52) + 8 * v1 + 4) - *(_DWORD *)(this + 76) < *(_DWORD *)(*(_DWORD *)(this + 20) + 8 * v1 + 4)
                                                                                       - *(_DWORD *)(this + 76);
LABEL_14:
    ++v1;
    if ( (signed int)v1 >= *(_DWORD *)(this + 104) )
      return 0;
  }
}

//----- (10012180) --------------------------------------------------------
int __usercall sub_10012180<eax>(char a1<dl>, int a2<ecx>, __int16 a3<bx>, int a4, int a5, int a6, int a7, __int16 a8, char a9)
{
  int v9; // esi@1
  int v10; // eax@2
  int v12; // [sp+8h] [bp-8h]@2
  unsigned int v13; // [sp+Ch] [bp-4h]@1
  int v14; // [sp+10h] [bp+0h]@1

  v13 = (unsigned int)&v14 ^ __security_cookie;
  v9 = a2;
  *(_DWORD *)a2 = a5;
  if ( a8 & 0x800 )
  {
    v10 = sub_100132A0(a9, (int)&v12, a3, a4, a5, a6, a7, a1);
  }
  else
  {
    if ( a8 & 0x100 )
    {
      v10 = sub_100134A0((int)&v12, a9, a4, (int *)a5, a6, a7, a1);
    }
    else
    {
      LOBYTE(v12) = 0;
      v10 = sub_10013550((int)&v12, a9, a4, a5, a6, a7);
    }
  }
  *(_DWORD *)v9 = *(_DWORD *)v10;
  return v9;
}
// 10067210: using guessed type int __security_cookie;

//----- (10012210) --------------------------------------------------------
int __fastcall sub_10012210(int a1, int a2, int a3, int a4, int a5, int a6, char a7)
{
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // ebx@1
  int v10; // edi@1
  int v11; // esi@1
  void **v12; // edi@3
  int v13; // ecx@4
  int v14; // eax@4
  int v15; // eax@4
  int v16; // edx@4
  int v17; // eax@5
  int *v18; // eax@8
  void **v19; // edi@14
  int v20; // ecx@15
  int v21; // eax@15
  int v22; // eax@15
  int v23; // edx@15
  int v24; // eax@16
  int *v25; // eax@19
  char v26; // zf@30
  int *v27; // eax@30
  int result; // eax@32
  unsigned int v29; // [sp-4h] [bp-74h]@1
  int v30; // [sp+10h] [bp-60h]@15
  int v31; // [sp+14h] [bp-5Ch]@4
  int v32; // [sp+18h] [bp-58h]@1
  int v33; // [sp+1Ch] [bp-54h]@1
  void *v34; // [sp+20h] [bp-50h]@18
  int v35; // [sp+30h] [bp-40h]@18
  unsigned int v36; // [sp+34h] [bp-3Ch]@19
  void *v37; // [sp+38h] [bp-38h]@7
  int v38; // [sp+48h] [bp-28h]@7
  unsigned int v39; // [sp+4Ch] [bp-24h]@8
  int v40; // [sp+50h] [bp-20h]@1
  char v41; // [sp+54h] [bp-1Ch]@3
  char v42; // [sp+55h] [bp-1Bh]@7
  char v43; // [sp+58h] [bp-18h]@14
  char v44; // [sp+59h] [bp-17h]@18
  unsigned int v45; // [sp+5Ch] [bp-14h]@1
  int v46; // [sp+6Ch] [bp-4h]@4
  int v47; // [sp+70h] [bp+0h]@1

  v45 = (unsigned int)&v47 ^ __security_cookie;
  v29 = (unsigned int)&v47 ^ __security_cookie;
  v32 = a2;
  v10 = a1;
  v33 = a1;
  v8 = a3;
  v7 = a4;
  v9 = a5;
  v11 = a3;
  v40 = a3;
  if ( a3 == a4 )
  {
LABEL_28:
    if ( a2 != v9 )
    {
      if ( !a7 || (v26 = v8 == v7, v27 = &a3, !v26) )
        v27 = &v40;
      goto LABEL_32;
    }
  }
  else
  {
    while ( a2 != v9 )
    {
      v12 = (void **)a6;
      LOBYTE(v9) = *(_BYTE *)a2;
      a3 = v8 + 1;
      v41 = *(_BYTE *)v8;
      if ( !*(_DWORD *)a6 )
      {
        v14 = sub_100100B0(a6, (int)&v31);
        v46 = 0;
        v15 = sub_10011270(v16, v9, (int)v12, v14);
        v46 = -1;
        v13 = v31;
        *v12 = (void *)v15;
        if ( v13 )
        {
          v17 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v13 + 8))(v29);
          if ( v17 )
            (**(void (__thiscall ***)(_DWORD, _DWORD))v17)(v17, 1);
        }
      }
      sub_1000FE50(*v12, (int)&v37, (int)&v41, (int)&v42);
      if ( v38 == 1 )
      {
        v18 = (int *)&v37;
        if ( v39 >= 0x10 )
          v18 = (int *)v37;
        BYTE1(v9) = *(_BYTE *)v18;
      }
      else
      {
        BYTE1(v9) = v41;
      }
      if ( v39 >= 0x10 )
        sub_1002404A(v37);
      v19 = (void **)a6;
      v39 = 15;
      v38 = 0;
      LOBYTE(v37) = 0;
      v43 = v9;
      if ( !*(_DWORD *)a6 )
      {
        v21 = sub_100100B0(a6, (int)&v30);
        v46 = 1;
        v22 = sub_10011270(v23, v9, (int)v19, v21);
        v46 = -1;
        v20 = v30;
        *v19 = (void *)v22;
        if ( v20 )
        {
          v24 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v20 + 8))(v29);
          if ( v24 )
            (**(void (__thiscall ***)(_DWORD, _DWORD))v24)(v24, 1);
        }
      }
      sub_1000FE50(*v19, (int)&v34, (int)&v43, (int)&v44);
      if ( v35 == 1 )
      {
        v25 = (int *)&v34;
        if ( v36 >= 0x10 )
          v25 = (int *)v34;
        LOBYTE(v9) = *(_BYTE *)v25;
      }
      else
      {
        LOBYTE(v9) = v43;
      }
      if ( v36 >= 0x10 )
        sub_1002404A(v34);
      a2 = v32 + 1;
      v36 = 15;
      v35 = 0;
      LOBYTE(v34) = 0;
      ++v32;
      if ( BYTE1(v9) != (_BYTE)v9 )
      {
        result = v33;
        *(_DWORD *)v33 = v11;
        return result;
      }
      v8 = a3;
      v7 = a4;
      v9 = a5;
      if ( a3 == a4 )
      {
        v10 = v33;
        goto LABEL_28;
      }
    }
    v10 = v33;
  }
  v27 = &a3;
LABEL_32:
  *(_DWORD *)v10 = *v27;
  return v10;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (10012410) --------------------------------------------------------
int __fastcall sub_10012410(int a1, int a2, int a3, int *a4, int a5, char a6, char a7)
{
  int *v7; // eax@1
  int v8; // edx@1
  int *v9; // ecx@1
  int v10; // ebx@1
  int v11; // edi@1
  int v12; // esi@1
  char v13; // zf@8
  int *v14; // eax@8
  int result; // eax@10
  int v16; // [sp+Ch] [bp-Ch]@1
  int v17; // [sp+10h] [bp-8h]@1
  unsigned int v18; // [sp+14h] [bp-4h]@1
  int v19; // [sp+18h] [bp+0h]@1

  v18 = (unsigned int)&v19 ^ __security_cookie;
  v7 = a4;
  v10 = a5;
  v11 = a2;
  v8 = a1;
  v9 = (int *)a3;
  v12 = a3;
  v16 = v8;
  v17 = a3;
  if ( (int *)a3 == a4 )
  {
LABEL_6:
    if ( v11 != v10 )
    {
      if ( !a7 || (v13 = v9 == v7, v14 = &a3, !v13) )
        v14 = &v17;
      goto LABEL_10;
    }
  }
  else
  {
    while ( v11 != v10 )
    {
      LOBYTE(v8) = *(_BYTE *)v11;
      a3 = (int)((char *)v9 + 1);
      ++v11;
      if ( !sub_10012830((int)&a6, v10, *(_BYTE *)v9, v8) )
      {
        result = v16;
        *(_DWORD *)v16 = v12;
        return result;
      }
      v9 = (int *)a3;
      v7 = a4;
      if ( (int *)a3 == a4 )
      {
        v8 = v16;
        goto LABEL_6;
      }
    }
    v8 = v16;
  }
  v14 = &a3;
LABEL_10:
  *(_DWORD *)v8 = *v14;
  return v8;
}
// 10067210: using guessed type int __security_cookie;

//----- (100124C0) --------------------------------------------------------
int __fastcall sub_100124C0(int a1, int a2, int a3, int a4, int a5, int a6, char a7)
{
  int v7; // eax@1
  int v8; // edx@1
  int v9; // ecx@1
  int v10; // ebx@1
  int v11; // edi@1
  char v12; // dl@3
  int v13; // eax@3
  int *v14; // eax@8
  int result; // eax@10
  int v16; // [sp+Ch] [bp-Ch]@1
  int v17; // [sp+10h] [bp-8h]@1
  unsigned int v18; // [sp+14h] [bp-4h]@1
  int v19; // [sp+18h] [bp+0h]@1

  v18 = (unsigned int)&v19 ^ __security_cookie;
  v7 = a5;
  v10 = a2;
  v8 = a1;
  v9 = a3;
  v11 = a3;
  v16 = v8;
  v17 = a3;
  if ( a3 == a4 )
  {
LABEL_6:
    if ( v10 != v7 )
    {
      if ( !a7 || (v14 = &a3, v9 != a4) )
        v14 = &v17;
      goto LABEL_10;
    }
  }
  else
  {
    while ( v10 != v7 )
    {
      v12 = *(_BYTE *)v10;
      v13 = v9++;
      a3 = v9;
      ++v10;
      if ( *(_BYTE *)v13 != v12 )
      {
        result = v16;
        *(_DWORD *)v16 = v11;
        return result;
      }
      v7 = a5;
      if ( v9 == a4 )
      {
        v8 = v16;
        goto LABEL_6;
      }
    }
    v8 = v16;
  }
  v14 = &a3;
LABEL_10:
  *(_DWORD *)v8 = *v14;
  return v8;
}
// 10067210: using guessed type int __security_cookie;

//----- (10012560) --------------------------------------------------------
int __thiscall sub_10012560(void *this, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@2
  char v6; // zf@2
  int v7; // ecx@3
  int v8; // eax@3
  int v9; // eax@3
  int v10; // edx@3
  int v11; // eax@4
  int v12; // ecx@7
  int v13; // eax@7
  int v14; // eax@7
  int v15; // edx@7
  int v16; // eax@8
  int v17; // ebx@10
  void *v19; // [sp+10h] [bp-44h]@10
  unsigned int v20; // [sp+24h] [bp-30h]@14
  int v21; // [sp+28h] [bp-2Ch]@1
  int v22; // [sp+2Ch] [bp-28h]@1
  int v23; // [sp+30h] [bp-24h]@2
  int v24; // [sp+34h] [bp-20h]@2
  int v25; // [sp+38h] [bp-1Ch]@2
  int v26; // [sp+3Ch] [bp-18h]@2
  int v27; // [sp+40h] [bp-14h]@3
  int v28; // [sp+50h] [bp-4h]@1

  v4 = (int)this;
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  v21 = a2;
  *(_BYTE *)a2 = 0;
  v28 = 0;
  v22 = 1;
  if ( a3 != a4 )
  {
    v23 = 0;
    v24 = 0;
    v25 = 0;
    sub_10013D00((int)&v23, a3, a4);
    v28 = 1;
    v5 = v23;
    v6 = *(_DWORD *)(v4 + 4) == 0;
    v26 = v24 - v23;
    if ( v6 )
    {
      v8 = sub_100100B0(v4, (int)&v27);
      LOBYTE(v28) = 2;
      v9 = sub_1000C9E0(v10, v4, v5, v8);
      LOBYTE(v28) = 1;
      v7 = v27;
      *(_DWORD *)(v4 + 4) = v9;
      if ( v7 )
      {
        v11 = (*(int (**)(void))(*(_DWORD *)v7 + 8))();
        if ( v11 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v11)(v11, 1);
      }
    }
    (*(void (__stdcall **)(int, int))(**(_DWORD **)(v4 + 4) + 12))(v5, v5 + v26);
    if ( !*(_DWORD *)v4 )
    {
      v13 = sub_100100B0(v4, (int)&v27);
      LOBYTE(v28) = 3;
      v14 = sub_10011270(v15, v4, v5, v13);
      LOBYTE(v28) = 1;
      v12 = v27;
      *(_DWORD *)v4 = v14;
      if ( v12 )
      {
        v16 = (*(int (**)(void))(*(_DWORD *)v12 + 8))();
        if ( v16 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v16)(v16, 1);
      }
    }
    v17 = sub_1000FE50(*(void **)v4, (int)&v19, v5, v5 + v26);
    if ( a2 != v17 )
    {
      if ( *(_DWORD *)(a2 + 20) >= 0x10u )
        sub_1002404A(*(LPVOID *)a2);
      *(_DWORD *)(a2 + 20) = 15;
      *(_DWORD *)(a2 + 16) = 0;
      *(_BYTE *)a2 = 0;
      sub_10002780((void *)a2, v17);
    }
    if ( v20 >= 0x10 )
      sub_1002404A(v19);
    if ( v5 )
      sub_1002404A((LPVOID)v5);
  }
  return a2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10012700) --------------------------------------------------------
int __fastcall sub_10012700(int a1, int a2, int a3)
{
  int result; // eax@1
  int i; // esi@1

  result = a3;
  for ( i = a1; i != a2; result += 8 )
  {
    if ( result )
    {
      *(_DWORD *)result = *(_DWORD *)i;
      *(_DWORD *)(result + 4) = *(_DWORD *)(i + 4);
    }
    i += 8;
  }
  return result;
}

//----- (10012730) --------------------------------------------------------
void __fastcall sub_10012730(int a1, int a2)
{
  for ( ; a2; --a2 )
  {
    if ( a1 )
    {
      *(_DWORD *)a1 = 0;
      *(_DWORD *)(a1 + 4) = 0;
    }
    a1 += 8;
  }
}

//----- (10012750) --------------------------------------------------------
signed int __usercall sub_10012750<eax>(signed int result<eax>, int a2<ecx>, int a3, unsigned int a4, int a5, int a6)
{
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // esi@1

  v6 = a3;
  v8 = a2;
  v7 = a4;
  while ( v6 != a5 || v7 != a6 )
  {
    result = 1 << v7;
    if ( *(_BYTE *)v8 )
    {
      *(_DWORD *)v6 |= result;
    }
    else
    {
      result = ~result;
      *(_DWORD *)v6 &= result;
    }
    v6 = a3;
    if ( a4 >= 0x1F )
    {
      v7 = 0;
      v6 = a3 + 4;
      a4 = 0;
      a3 += 4;
    }
    else
    {
      v7 = a4++ + 1;
    }
  }
  return result;
}

//----- (100127A0) --------------------------------------------------------
void __fastcall sub_100127A0(int a1, int a2)
{
  for ( ; a2; --a2 )
  {
    if ( a1 )
    {
      *(_DWORD *)a1 = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_BYTE *)(a1 + 8) = 0;
    }
    a1 += 12;
  }
}

//----- (100127C0) --------------------------------------------------------
int __thiscall sub_100127C0(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  if ( (unsigned __int8)loc_1000FDE0((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 3) )
    *(_DWORD *)(v2 + 4) = sub_100144C0(*(void **)v2, *(_DWORD *)a2, *(_DWORD *)(a2 + 4));
  return v2;
}

//----- (10012830) --------------------------------------------------------
char __userpurge sub_10012830<al>(int a1<ecx>, char a2<bl>, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ecx@2
  int v7; // eax@2
  int v8; // eax@2
  int v9; // edx@2
  int v10; // eax@3
  char v11; // bl@5
  int v12; // esi@5
  char v13; // al@5
  int v14; // ecx@6
  int v15; // eax@6
  int v16; // eax@6
  int v17; // edx@6
  int v18; // eax@7
  int v20; // [sp+10h] [bp-10h]@2
  int v21; // [sp+1Ch] [bp-4h]@2

  v4 = a1;
  v5 = *(_DWORD *)a1;
  if ( !*(_DWORD *)(*(_DWORD *)a1 + 4) )
  {
    v7 = sub_100100B0(v5, (int)&v20);
    v21 = 0;
    v8 = sub_1000C9E0(v9, a2, v4, v7);
    v21 = -1;
    v6 = v20;
    *(_DWORD *)(v5 + 4) = v8;
    if ( v6 )
    {
      v10 = (*(int (**)(void))(*(_DWORD *)v6 + 8))();
      if ( v10 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v10)(v10, 1);
    }
  }
  v13 = (*(int (__stdcall **)(int))(**(_DWORD **)(v5 + 4) + 16))(a3);
  v12 = *(_DWORD *)v4;
  v11 = v13;
  if ( !*(_DWORD *)(*(_DWORD *)v4 + 4) )
  {
    v15 = sub_100100B0(v12, (int)&a3);
    v21 = 1;
    v16 = sub_1000C9E0(v17, v11, v4, v15);
    v21 = -1;
    v14 = a3;
    *(_DWORD *)(v12 + 4) = v16;
    if ( v14 )
    {
      v18 = (*(int (**)(void))(*(_DWORD *)v14 + 8))();
      if ( v18 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v18)(v18, 1);
    }
  }
  return v11 == (unsigned __int8)(*(int (__cdecl **)(int))(**(_DWORD **)(v12 + 4) + 16))(a4);
}

//----- (10012920) --------------------------------------------------------
char __thiscall sub_10012920(int this)
{
  int v1; // eax@1
  int v2; // ecx@2
  char v3; // al@6

  v1 = *(_DWORD *)this + 1;
  return v1 != *(_DWORD *)(this + 8)
      && ((v2 = *(_DWORD *)(this + 80), !(v2 & 8)) && (*(_BYTE *)v1 == 40 || *(_BYTE *)v1 == 41)
       || !(v2 & 0x10) && ((v3 = *(_BYTE *)v1, v3 == 123) || v3 == 125));
}

//----- (10012960) --------------------------------------------------------
char __thiscall sub_10012960(void *this)
{
  int v1; // eax@1
  int v2; // edx@1
  int v3; // eax@3
  int v4; // edx@4

  v1 = *(_DWORD *)this;
  v2 = *((_DWORD *)this + 2);
  if ( *(_DWORD *)this != v2 )
  {
    if ( *(_BYTE *)v1 == 92 )
    {
      v3 = v1 + 1;
      if ( v3 != v2 )
      {
        v4 = *((_DWORD *)this + 20);
        if ( !(v4 & 8) && (*(_BYTE *)v3 == 40 || *(_BYTE *)v3 == 41)
          || !(v4 & 0x10) && (*(_BYTE *)v3 == 123 || *(_BYTE *)v3 == 125) )
          *(_DWORD *)this = v3;
      }
    }
    ++*(_DWORD *)this;
  }
  return sub_10011500(this);
}

//----- (10012DF0) --------------------------------------------------------
char __thiscall sub_10012DF0(int this)
{
  int v1; // eax@1
  int v2; // ecx@1
  int v3; // eax@5

  v2 = *(_DWORD *)(this + 4);
  v1 = *(_DWORD *)(v2 + 4);
  return v1 == 20
      || v1 == 8
      || v1 == 13
      || v1 == 2 && ((v3 = *(_DWORD *)(*(_DWORD *)(v2 + 16) + 4), v3 == 20) || v3 == 8 || v3 == 13);
}

//----- (10012E30) --------------------------------------------------------
int __usercall sub_10012E30<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v4 = sub_10027EB3(a1, a2, a3, a4, 20);
  v5 = v4;
  if ( v4 )
  {
    *(_DWORD *)v4 = &off_1005C830;
    *(_DWORD *)(v4 + 4) = 8;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  result = v5;
  *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) = v5;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 1005C830: using guessed type int (__stdcall *off_1005C830)(char);

//----- (10012EA0) --------------------------------------------------------
int __userpurge sub_10012EA0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // eax@4
  int v10; // eax@6
  int v12; // edx@9

  v7 = a2;
  v4 = sub_10027EB3(a1, a2, a3, a2, 20);
  v8 = v4;
  if ( v4 )
  {
    *(_DWORD *)(v4 + 4) = 17;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    *(_DWORD *)v4 = &off_1005C830;
  }
  else
  {
    v8 = 0;
  }
  *(_DWORD *)(v8 + 16) = *(_DWORD *)(v7 + 4);
  v9 = *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12);
  if ( v9 )
  {
    *(_DWORD *)(v8 + 12) = v9;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) + 16) = v8;
  }
  *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) = v8;
  *(_DWORD *)(v7 + 4) = v8;
  v10 = sub_10027EB3(v5, v6, a3, v7, 28);
  if ( v10 )
  {
    *(_DWORD *)(v10 + 4) = 16;
    *(_DWORD *)(v10 + 8) = 0;
    *(_DWORD *)(v10 + 12) = 0;
    *(_DWORD *)(v10 + 16) = 0;
    *(_DWORD *)v10 = off_1005C828;
    *(_DWORD *)(v10 + 20) = v8;
    *(_DWORD *)(v10 + 24) = 0;
  }
  else
  {
    v10 = 0;
  }
  v12 = *(_DWORD *)(a4 + 12);
  *(_DWORD *)(v10 + 16) = *(_DWORD *)(v12 + 16);
  *(_DWORD *)(*(_DWORD *)(v12 + 16) + 12) = v10;
  *(_DWORD *)(v10 + 12) = v12;
  *(_DWORD *)(v12 + 16) = v10;
  return v8;
}
// 1005C828: using guessed type int (__stdcall *off_1005C828[3])(char);
// 1005C830: using guessed type int (__stdcall *off_1005C830)(char);

//----- (10012F60) --------------------------------------------------------
int __fastcall sub_10012F60(int a1, int a2, int a3, int a4)
{
  int v4; // eax@1
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@1
  char v8; // zf@2
  int v9; // eax@3
  int result; // eax@4

  v6 = *(_DWORD *)(a3 + 12);
  v5 = *(_DWORD *)(a4 + 12);
  *(_DWORD *)(a4 + 12) = 0;
  v7 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 4) = a4;
  *(_DWORD *)(a4 + 12) = 0;
  *(_DWORD *)(v7 + 12) = a4;
  v4 = v6 + 24;
  if ( *(_DWORD *)(v6 + 24) )
  {
    do
    {
      v6 = *(_DWORD *)v4;
      v8 = *(_DWORD *)(*(_DWORD *)v4 + 24) == 0;
      v4 = *(_DWORD *)v4 + 24;
    }
    while ( !v8 );
  }
  v9 = sub_10027EB3(a2, a1, v5, a4, 28);
  if ( v9 )
  {
    *(_DWORD *)(v9 + 20) = a4;
    *(_DWORD *)(v9 + 4) = 16;
    *(_DWORD *)(v9 + 8) = 0;
    *(_DWORD *)(v9 + 12) = 0;
    *(_DWORD *)(v9 + 16) = 0;
    *(_DWORD *)v9 = off_1005C828;
    *(_DWORD *)(v9 + 24) = 0;
    *(_DWORD *)(v6 + 24) = v9;
    *(_DWORD *)(v9 + 12) = v5;
    result = *(_DWORD *)(v6 + 24);
    *(_DWORD *)(v5 + 16) = result;
  }
  else
  {
    *(_DWORD *)(v6 + 24) = 0;
    vc = v5;
    result = *(_DWORD *)(v6 + 24);
    *(_DWORD *)(v5 + 16) = result;
  }
  return result;
}
// 1005C828: using guessed type int (__stdcall *off_1005C828[3])(char);

//----- (10013000) --------------------------------------------------------
char __thiscall sub_10013000(void *this, int a2, char a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  void *v5; // esi@1
  int v6; // esi@2
  int v7; // eax@6
  int v8; // edi@6
  int v9; // ecx@9
  int v10; // eax@10
  int v11; // ecx@11
  int v12; // esi@12
  char v13; // bl@17
  int *v14; // esi@19
  int v16; // [sp+10h] [bp-64h]@1
  int v17; // [sp+14h] [bp-60h]@1
  void *v18; // [sp+1Ch] [bp-58h]@1
  char v19; // [sp+23h] [bp-51h]@6
  int v20; // [sp+24h] [bp-50h]@1
  void *v21; // [sp+28h] [bp-4Ch]@1
  int v22; // [sp+2Ch] [bp-48h]@1
  int v23; // [sp+30h] [bp-44h]@1
  int v24; // [sp+34h] [bp-40h]@1
  void *v25; // [sp+38h] [bp-3Ch]@1
  int v26; // [sp+3Ch] [bp-38h]@1
  int v27; // [sp+40h] [bp-34h]@1
  int v28; // [sp+44h] [bp-30h]@6
  void *v29; // [sp+48h] [bp-2Ch]@6
  int v30; // [sp+4Ch] [bp-28h]@6
  int v31; // [sp+50h] [bp-24h]@6
  int v32; // [sp+54h] [bp-20h]@6
  void *v33; // [sp+58h] [bp-1Ch]@6
  int v34; // [sp+5Ch] [bp-18h]@6
  int v35; // [sp+60h] [bp-14h]@6
  unsigned int v36; // [sp+64h] [bp-10h]@1
  int v37; // [sp+70h] [bp-4h]@1
  int v38; // [sp+74h] [bp+0h]@1

  v36 = (unsigned int)&v38 ^ __security_cookie;
  v5 = this;
  v18 = this;
  v4 = a2;
  v3 = 0;
  v20 = *(_DWORD *)this;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v17 = (int)((char *)this + 4);
  sub_10011490((int)&v21, (int)((char *)this + 4));
  v24 = *((_DWORD *)v5 + 4);
  v37 = 0;
  v16 = (int)((char *)v5 + 20);
  sub_100127C0((int)&v25, (int)((char *)v5 + 20));
  v37 = 1;
  if ( *(_DWORD *)(a2 + 20) <= 0 )
  {
LABEL_6:
    v7 = *(_DWORD *)v5;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v33 = 0;
    v34 = 0;
    v35 = 0;
    v28 = v7;
    sub_10011490((int)&v29, (int)((char *)v5 + 4));
    v32 = *((_DWORD *)v5 + 4);
    LOBYTE(v37) = 2;
    sub_100127C0((int)&v33, (int)((char *)v5 + 20));
    v19 = 0;
    LOBYTE(v37) = 3;
    v8 = *(_DWORD *)v5;
    if ( !(unsigned __int8)loc_100108B0(v5, *(_DWORD *)(*(_DWORD *)(a2 + 28) + 12)) )
      goto LABEL_9;
    if ( a3 )
    {
      v28 = *(_DWORD *)v5;
      v32 = *((_DWORD *)v5 + 4);
      sub_1000FC10((int)&v29, (int)((char *)v5 + 4));
      sub_1000F6A0(&v33, (int)((char *)v5 + 20));
      v19 = 1;
LABEL_9:
      while ( 1 )
      {
        v9 = *(_DWORD *)(a2 + 24);
        if ( v9 != -1 )
        {
          v10 = v3++;
          if ( v10 >= v9 )
            break;
        }
        v11 = v24;
        *(_DWORD *)v5 = v8;
        *((_DWORD *)v5 + 4) = v11;
        sub_1000FC10((int)((char *)v5 + 4), (int)&v21);
        if ( !(unsigned __int8)loc_100108B0(v5, *(_DWORD *)(a2 + 12)) )
          break;
        v12 = *(_DWORD *)v5;
        if ( (unsigned __int8)loc_100108B0(v18, *(_DWORD *)(*(_DWORD *)(a2 + 28) + 12)) )
        {
          if ( !a3 )
            goto LABEL_18;
          v28 = *(_DWORD *)v18;
          v32 = *(_DWORD *)(v17 + 12);
          sub_1000FC10((int)&v29, v17);
          sub_1000F6A0(&v33, v16);
          v19 = 1;
        }
        if ( v8 == v12 )
          break;
        v8 = v12;
        v5 = v18;
      }
      v13 = v19;
      v14 = &v28;
      if ( !v19 )
        v14 = &v20;
      *(_DWORD *)v18 = *v14;
      *(_DWORD *)(v17 + 12) = v14[4];
      sub_1000FC10(v17, (int)(v14 + 1));
      sub_1000F6A0((void *)v16, (int)(v14 + 5));
    }
    else
    {
LABEL_18:
      v13 = 1;
    }
    if ( v33 )
      sub_1002404A(v33);
    if ( v29 )
      sub_1002404A(v29);
  }
  else
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)v5;
      if ( !(unsigned __int8)loc_100108B0(v18, *(_DWORD *)(v4 + 12)) )
        break;
      v4 = a2;
      if ( v6 == *(_DWORD *)v18 )
        v3 = *(_DWORD *)(a2 + 20) - 1;
      v5 = v18;
      ++v3;
      if ( v3 >= *(_DWORD *)(a2 + 20) )
        goto LABEL_6;
    }
    *(_DWORD *)v18 = v20;
    *((_DWORD *)v18 + 4) = v24;
    sub_1000FC10((int)((char *)v18 + 4), (int)&v21);
    sub_1000F6A0((char *)v18 + 20, (int)&v25);
    v13 = 0;
  }
  if ( v25 )
    sub_1002404A(v25);
  if ( v21 )
    sub_1002404A(v21);
  return v13;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (100132A0) --------------------------------------------------------
int __usercall sub_100132A0<eax>(char a1<dl>, int a2<ecx>, __int16 a3<bx>, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // eax@1
  int v9; // edx@1
  char v10; // bl@1
  int v11; // edi@1
  int v12; // esi@1
  int v13; // ecx@3
  void **v14; // esi@3
  char v15; // al@3
  int v16; // ecx@4
  int v17; // eax@4
  int v18; // eax@4
  int v19; // edx@4
  int v20; // eax@5
  int *v21; // eax@8
  void **v22; // esi@14
  int v23; // ecx@15
  int v24; // eax@15
  int v25; // eax@15
  int v26; // edx@15
  int v27; // eax@16
  int *v28; // eax@19
  char v29; // zf@30
  int *v30; // eax@30
  int result; // eax@32
  unsigned int v32; // [sp-4h] [bp-74h]@1
  int v33; // [sp+10h] [bp-60h]@15
  int v34; // [sp+14h] [bp-5Ch]@4
  int v35; // [sp+18h] [bp-58h]@1
  char v36; // [sp+1Fh] [bp-51h]@1
  void *v37; // [sp+20h] [bp-50h]@18
  int v38; // [sp+30h] [bp-40h]@18
  unsigned int v39; // [sp+34h] [bp-3Ch]@19
  void *v40; // [sp+38h] [bp-38h]@7
  int v41; // [sp+48h] [bp-28h]@7
  unsigned int v42; // [sp+4Ch] [bp-24h]@8
  int v43; // [sp+50h] [bp-20h]@1
  char v44; // [sp+54h] [bp-1Ch]@3
  char v45; // [sp+55h] [bp-1Bh]@7
  char v46; // [sp+58h] [bp-18h]@14
  char v47; // [sp+59h] [bp-17h]@18
  unsigned int v48; // [sp+5Ch] [bp-14h]@1
  int v49; // [sp+6Ch] [bp-4h]@4
  int v50; // [sp+70h] [bp+0h]@1

  v48 = (unsigned int)&v50 ^ __security_cookie;
  v32 = (unsigned int)&v50 ^ __security_cookie;
  v10 = a1;
  v36 = a1;
  v9 = a2;
  v35 = a2;
  v12 = a4;
  v8 = a5;
  v11 = a4;
  v43 = a4;
  if ( a4 == a5 )
  {
LABEL_28:
    if ( a6 != a7 )
    {
      if ( !v10 || (v29 = v12 == v8, v30 = &a4, !v29) )
        v30 = &v43;
      goto LABEL_32;
    }
  }
  else
  {
    while ( a6 != a7 )
    {
      v13 = a6++;
      a4 = v12 + 1;
      v15 = *(_BYTE *)v12;
      v14 = (void **)a8;
      LOBYTE(a3) = *(_BYTE *)v13;
      v44 = v15;
      if ( !*(_DWORD *)a8 )
      {
        v17 = sub_100100B0(a8, (int)&v34);
        v49 = 0;
        v18 = sub_10011270(v19, a3, v11, v17);
        v49 = -1;
        v16 = v34;
        *v14 = (void *)v18;
        if ( v16 )
        {
          v20 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v16 + 8))(v32);
          if ( v20 )
            (**(void (__thiscall ***)(_DWORD, _DWORD))v20)(v20, 1);
        }
      }
      sub_1000FE50(*v14, (int)&v40, (int)&v44, (int)&v45);
      if ( v41 == 1 )
      {
        v21 = (int *)&v40;
        if ( v42 >= 0x10 )
          v21 = (int *)v40;
        HIBYTE(a3) = *(_BYTE *)v21;
      }
      else
      {
        HIBYTE(a3) = v44;
      }
      if ( v42 >= 0x10 )
        sub_1002404A(v40);
      v22 = (void **)a8;
      v42 = 15;
      v41 = 0;
      LOBYTE(v40) = 0;
      v46 = a3;
      if ( !*(_DWORD *)a8 )
      {
        v24 = sub_100100B0(a8, (int)&v33);
        v49 = 1;
        v25 = sub_10011270(v26, a3, v11, v24);
        v49 = -1;
        v23 = v33;
        *v22 = (void *)v25;
        if ( v23 )
        {
          v27 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v23 + 8))(v32);
          if ( v27 )
            (**(void (__thiscall ***)(_DWORD, _DWORD))v27)(v27, 1);
        }
      }
      sub_1000FE50(*v22, (int)&v37, (int)&v46, (int)&v47);
      if ( v38 == 1 )
      {
        v28 = (int *)&v37;
        if ( v39 >= 0x10 )
          v28 = (int *)v37;
        LOBYTE(a3) = *(_BYTE *)v28;
      }
      else
      {
        LOBYTE(a3) = v46;
      }
      if ( v39 >= 0x10 )
        sub_1002404A(v37);
      v39 = 15;
      v38 = 0;
      LOBYTE(v37) = 0;
      if ( HIBYTE(a3) != (_BYTE)a3 )
      {
        result = v35;
        *(_DWORD *)v35 = v11;
        return result;
      }
      v12 = a4;
      v8 = a5;
      if ( a4 == a5 )
      {
        v9 = v35;
        v10 = v36;
        goto LABEL_28;
      }
    }
    v9 = v35;
  }
  v30 = &a4;
LABEL_32:
  *(_DWORD *)v9 = *v30;
  return v9;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (100134A0) --------------------------------------------------------
int __fastcall sub_100134A0(int a1, char a2, int a3, int *a4, int a5, int a6, char a7)
{
  int *v7; // eax@1
  int v8; // ebx@1
  int v9; // edi@1
  int *v10; // esi@1
  int *v11; // ecx@3
  int *v12; // eax@7
  char v14; // zf@10
  char v15; // [sp+Fh] [bp-9h]@1
  int v16; // [sp+10h] [bp-8h]@1
  unsigned int v17; // [sp+14h] [bp-4h]@1
  int v18; // [sp+18h] [bp+0h]@1

  v17 = (unsigned int)&v18 ^ __security_cookie;
  v7 = a4;
  v10 = (int *)a3;
  v9 = a3;
  v15 = a2;
  v8 = a1;
  v16 = a3;
  if ( (int *)a3 == a4 )
  {
LABEL_6:
    if ( a5 != a6 )
    {
      if ( !a2 || (v14 = v10 == v7, v12 = &a3, !v14) )
        v12 = &v16;
      goto LABEL_12;
    }
  }
  else
  {
    while ( a5 != a6 )
    {
      v11 = (int *)a5++;
      a3 = (int)((char *)v10 + 1);
      if ( !sub_10012830((int)&a7, v8, *(_BYTE *)v10, *(_BYTE *)v11) )
      {
        *(_DWORD *)v8 = v9;
        return v8;
      }
      v10 = (int *)a3;
      v7 = a4;
      if ( (int *)a3 == a4 )
      {
        a2 = v15;
        goto LABEL_6;
      }
    }
  }
  v12 = &a3;
LABEL_12:
  *(_DWORD *)v8 = *v12;
  return v8;
}
// 10067210: using guessed type int __security_cookie;

//----- (10013550) --------------------------------------------------------
int __fastcall sub_10013550(int a1, char a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int v7; // edx@1
  int v8; // ebx@1
  int v9; // esi@1
  int v10; // ecx@3
  int v11; // eax@3
  int *v12; // eax@6
  char v14; // [sp+Fh] [bp-9h]@1
  int v15; // [sp+10h] [bp-8h]@1
  unsigned int v16; // [sp+14h] [bp-4h]@1
  int v17; // [sp+18h] [bp+0h]@1

  v16 = (unsigned int)&v17 ^ __security_cookie;
  v6 = a6;
  v9 = a3;
  v14 = a2;
  v7 = a5;
  v8 = a1;
  v15 = a3;
  if ( a3 == a4 )
  {
LABEL_5:
    if ( v7 != v6 )
    {
      if ( !v14 || (v12 = &a3, v9 != a4) )
        v12 = &v15;
      goto LABEL_11;
    }
  }
  else
  {
    while ( v7 != v6 )
    {
      v10 = v7;
      v11 = v9;
      ++v7;
      ++v9;
      a5 = v7;
      a3 = v9;
      if ( *(_BYTE *)v11 != *(_BYTE *)v10 )
      {
        *(_DWORD *)v8 = v15;
        return v8;
      }
      v6 = a6;
      if ( v9 == a4 )
        goto LABEL_5;
    }
  }
  v12 = &a3;
LABEL_11:
  *(_DWORD *)v8 = *v12;
  return v8;
}
// 10067210: using guessed type int __security_cookie;

//----- (100135F0) --------------------------------------------------------
void *__thiscall sub_100135F0(void *this, int a2, int a3, unsigned int a4, int a5, int a6, int a7, unsigned int a8)
{
  int v8; // edx@1
  int v9; // ecx@1
  void *v10; // ebx@1
  int v11; // edi@1
  int v12; // esi@1

  v8 = a8;
  v12 = a7;
  v11 = a3;
  v10 = this;
  v9 = a4;
  while ( v11 != a5 || v9 != a6 )
  {
    if ( (1 << v9) & *(_DWORD *)v11 )
      *(_DWORD *)v12 |= 1 << v8;
    else
      *(_DWORD *)v12 &= ~(1 << v8);
    v12 = a7;
    if ( a8 >= 0x1F )
    {
      v8 = 0;
      v12 = a7 + 4;
      a7 += 4;
    }
    else
    {
      v8 = a8 + 1;
    }
    v11 = a3;
    a8 = v8;
    if ( a4 >= 0x1F )
    {
      v9 = 0;
      v11 = a3 + 4;
      a4 = 0;
      a3 += 4;
    }
    else
    {
      v9 = a4++ + 1;
    }
  }
  *(_DWORD *)v10 = v12;
  *((_DWORD *)v10 + 1) = v8;
  return v10;
}

//----- (10013670) --------------------------------------------------------
void *__thiscall sub_10013670(void *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  void *v8; // ebx@1
  int v9; // edi@2
  int v10; // ecx@5
  int v11; // esi@7
  int v12; // edx@8

  v8 = this;
  while ( 1 )
  {
    v9 = a5;
    if ( a3 == a5 )
    {
      if ( a4 == a6 )
        break;
    }
    if ( a6 )
    {
      v10 = a6 - 1;
    }
    else
    {
      v9 = a5 - 4;
      v10 = 31;
      a5 -= 4;
    }
    v11 = a7;
    a6 = v10;
    if ( a8 )
    {
      v12 = a8 - 1;
    }
    else
    {
      v11 = a7 - 4;
      v12 = 31;
      a7 -= 4;
    }
    a8 = v12;
    if ( (1 << v10) & *(_DWORD *)v9 )
      *(_DWORD *)v11 |= 1 << v12;
    else
      *(_DWORD *)v11 &= ~(1 << v12);
  }
  *(_DWORD *)v8 = a7;
  *((_DWORD *)v8 + 1) = a8;
  return v8;
}

//----- (10013760) --------------------------------------------------------
int __usercall sub_10013760<eax>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>)
{
  int v4; // edx@1
  int v5; // esi@1
  int v6; // eax@2
  int v7; // ecx@2
  int v8; // eax@4
  int v9; // ecx@5
  int v10; // ecx@16

  v5 = a2;
  sub_10014200(a1, a2 + 36, a3, a4);
  if ( *(_DWORD *)(v5 + 76) == 94 )
  {
    *(_DWORD *)(*(_DWORD *)(v5 + 40) + 8) ^= 1u;
    v6 = *(_DWORD *)v5;
    v7 = *(_DWORD *)(v5 + 8);
    if ( *(_DWORD *)v5 != v7 )
    {
      if ( *(_BYTE *)v6 == 92 )
      {
        v8 = v6 + 1;
        if ( v8 != v7 )
        {
          v9 = *(_DWORD *)(v5 + 80);
          if ( !(v9 & 8) && (*(_BYTE *)v8 == 40 || *(_BYTE *)v8 == 41)
            || !(v9 & 0x10) && (*(_BYTE *)v8 == 123 || *(_BYTE *)v8 == 125) )
            *(_DWORD *)v5 = v8;
        }
      }
      ++*(_DWORD *)v5;
    }
    sub_10011500((void *)v5);
  }
  if ( *(_DWORD *)(v5 + 80) & 0x20000000 && *(_DWORD *)(v5 + 76) == 93 )
  {
    v10 = v5 + 36;
    if ( dword_1006A0EC <= 93 )
    {
      sub_10014D40(v4, v10, a3, a4, 93);
      sub_10012960((void *)v5);
      return loc_10013E60(v5);
    }
    sub_10014E30(v4, v10, a3, a4, 93);
    sub_10012960((void *)v5);
  }
  return loc_10013E60(v5);
}
// 1006A0EC: using guessed type int dword_1006A0EC;

//----- (10013AD0) --------------------------------------------------------
int __usercall sub_10013AD0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v4 = sub_10027EB3(a1, a2, a3, a4, 20);
  v5 = v4;
  if ( v4 )
  {
    *(_DWORD *)v4 = &off_1005C830;
    *(_DWORD *)(v4 + 4) = 2;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  result = *(_DWORD *)(v6 + 4);
  *(_DWORD *)(result + 12) = v5;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 1005C830: using guessed type int (__stdcall *off_1005C830)(char);

//----- (10013B30) --------------------------------------------------------
int __usercall sub_10013B30<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v4 = sub_10027EB3(a1, a2, a3, a4, 20);
  v5 = v4;
  if ( v4 )
  {
    *(_DWORD *)v4 = &off_1005C830;
    *(_DWORD *)(v4 + 4) = 3;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  result = *(_DWORD *)(v6 + 4);
  *(_DWORD *)(result + 12) = v5;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 1005C830: using guessed type int (__stdcall *off_1005C830)(char);

//----- (10013B90) --------------------------------------------------------
int __usercall sub_10013B90<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v4 = sub_10027EB3(a1, a2, a3, a4, 20);
  v5 = v4;
  if ( v4 )
  {
    *(_DWORD *)v4 = &off_1005C830;
    *(_DWORD *)(v4 + 4) = 4;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  result = *(_DWORD *)(v6 + 4);
  *(_DWORD *)(result + 12) = v5;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 1005C830: using guessed type int (__stdcall *off_1005C830)(char);

//----- (10013BF0) --------------------------------------------------------
int __userpurge sub_10013BF0<eax>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>, int a5)
{
  int v5; // eax@1
  int v6; // esi@1
  int v7; // eax@4
  int v8; // edi@5
  int v9; // ecx@6
  int v10; // eax@6
  int v11; // eax@6
  int v12; // edx@6
  int v13; // eax@7
  char v14; // bl@9
  unsigned int v15; // eax@13
  int v16; // esi@13
  int v17; // eax@14
  int v18; // edi@14
  int result; // eax@17
  int v20; // [sp+14h] [bp-10h]@6
  int v21; // [sp+20h] [bp-4h]@6

  v6 = a2;
  v5 = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(v5 + 4) != 6 || *(_BYTE *)(v5 + 8) & 4 )
    sub_10014440(a1, a2, a3, a4);
  v7 = *(_DWORD *)(v6 + 8);
  if ( v7 & 0x100 )
  {
    v8 = *(_DWORD *)(v6 + 12);
    if ( !*(_DWORD *)(v8 + 4) )
    {
      v10 = sub_100100B0(v8, (int)&v20);
      v21 = 0;
      v11 = sub_1000C9E0(v12, a3, v8, v10);
      v21 = -1;
      v9 = v20;
      *(_DWORD *)(v8 + 4) = v11;
      if ( v9 )
      {
        v13 = (*(int (**)(void))(*(_DWORD *)v9 + 8))();
        if ( v13 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v13)(v13, 1);
      }
    }
    v14 = (*(int (__stdcall **)(int))(**(_DWORD **)(v8 + 4) + 16))(a5);
  }
  else
  {
    if ( v7 & 0x800 )
      v14 = sub_1000F3C0(*(_DWORD *)(v6 + 12), a3, a4, a5);
    else
      v14 = a5;
  }
  v16 = *(_DWORD *)(v6 + 4);
  v15 = *(_DWORD *)(v16 + 24);
  if ( *(_DWORD *)(v16 + 20) <= v15 )
  {
    v18 = v15 + 16;
    v17 = sub_10028586(a1, a2, v14, v15 + 16, *(LPVOID *)(v16 + 28), v15 + 16);
    if ( !v17 )
      sub_10021BC5();
    *(_DWORD *)(v16 + 28) = v17;
    *(_DWORD *)(v16 + 20) = v18;
  }
  result = *(_DWORD *)(v16 + 24);
  *(_BYTE *)(*(_DWORD *)(v16 + 28) + result) = v14;
  ++*(_DWORD *)(v16 + 24);
  return result;
}

//----- (10013D00) --------------------------------------------------------
int __thiscall sub_10013D00(int this, int a2, int a3)
{
  char v4; // [sp+0h] [bp-24h]@1
  int v5; // [sp+10h] [bp-14h]@1
  char *v6; // [sp+14h] [bp-10h]@1
  int v7; // [sp+20h] [bp-4h]@1

  v6 = &v4;
  v7 = 0;
  v5 = this;
  return sub_10014F40(this, *(_DWORD *)this, a2, a3, this);
}

//----- (10013D70) --------------------------------------------------------
void *__thiscall sub_10013D70(void *this, int a2, int a3)
{
  void *result; // eax@1
  int i; // ecx@1

  result = this;
  for ( i = a2; i != a3; result = (char *)result + 4 )
  {
    if ( result )
      *(_DWORD *)result = *(_DWORD *)i;
    i += 4;
  }
  return result;
}

//----- (10013DA0) --------------------------------------------------------
char __thiscall sub_10013DA0(int this)
{
  return sub_10014520(this, 10, 2147483647) != 2147483647;
}

//----- (10013DC0) --------------------------------------------------------
char __userpurge sub_10013DC0<al>(int a1<ecx>, char a2<bl>, char a3)
{
  int v3; // esi@1
  unsigned __int16 v4; // ax@2
  int v5; // edx@2
  int v6; // edi@2
  char result; // al@7

  v3 = a1;
  if ( *(_DWORD *)a1 != *(_DWORD *)(a1 + 8)
    && (v4 = sub_10014910(*(void **)(a1 + 60), *(_DWORD *)a1, *(_DWORD *)a1 + 1, (*(_DWORD *)(a1 + 64) & 0x100) != 0),
        v6 = v4,
        v4) )
  {
    if ( a3 )
      sub_10014200(v5, v3 + 36, a2, v4);
    sub_10015280(*(_DWORD *)(v3 + 40), v6, *(_DWORD *)(v3 + 48));
    if ( sub_1000F490(*(_DWORD *)(v3 + 60), a2, *(_BYTE *)(v3 + 72), 1) )
      *(_DWORD *)(*(_DWORD *)(v3 + 40) + 8) ^= 1u;
    sub_10012960((void *)v3);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10014140) --------------------------------------------------------
signed int __usercall sub_10014140<eax>(int a1<edx>, int a2<ecx>, int a3<edi>)
{
  unsigned int v3; // edx@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // edx@1
  int v8; // ecx@1
  int v9; // esi@3
  signed int result; // eax@5

  v5 = a2;
  ++*(_DWORD *)(v5 + 12);
  v6 = sub_100118F0(a1, a2 + 36, a2, a3, *(_DWORD *)(a2 + 12));
  sub_100116B0(v5);
  sub_10011850(v5 + 36, v7, v6);
  sub_1000F580(v5 + 20, *(_DWORD *)(v5 + 12) + 1, v8);
  v3 = *(_DWORD *)(v6 + 20);
  v4 = *(_DWORD *)(v5 + 20);
  if ( (signed int)v3 < 0 && v3 )
    v9 = -4 - 4 * ((-1 - v3) >> 5) + v4;
  else
    v9 = v4 + 4 * (v3 >> 5);
  result = 1 << (v3 & 0x1F);
  *(_DWORD *)v9 |= result;
  return result;
}

//----- (100141D0) --------------------------------------------------------
int __userpurge sub_100141D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, char a4)
{
  int result; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // edx@1

  v5 = a2;
  v6 = sub_10014C30(a1, a2 + 36, a3, a4);
  sub_100116B0(v5);
  result = sub_10011850(v5 + 36, v7, v6);
  *(_DWORD *)(v5 + 40) = v6;
  return result;
}

//----- (10014200) --------------------------------------------------------
int __usercall sub_10014200<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // edx@1
  int v5; // esi@1
  int v6; // eax@4
  int result; // eax@6

  v5 = a2;
  v4 = sub_10027EB3(a1, a2, a3, a4, 44);
  if ( v4 )
  {
    *(_DWORD *)(v4 + 4) = 7;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    *(_DWORD *)v4 = off_1005C824;
    *(_DWORD *)(v4 + 20) = 0;
    *(_DWORD *)(v4 + 24) = 0;
    *(_DWORD *)(v4 + 28) = 0;
    *(_DWORD *)(v4 + 32) = 0;
    *(_WORD *)(v4 + 36) = 0;
    *(_DWORD *)(v4 + 40) = 0;
  }
  else
  {
    v4 = 0;
  }
  *(_DWORD *)(v4 + 16) = *(_DWORD *)(v5 + 4);
  v6 = *(_DWORD *)(*(_DWORD *)(v5 + 4) + 12);
  if ( v6 )
  {
    *(_DWORD *)(v4 + 12) = v6;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v5 + 4) + 12) + 16) = v4;
  }
  result = *(_DWORD *)(v5 + 4);
  *(_DWORD *)(result + 12) = v4;
  *(_DWORD *)(v5 + 4) = v4;
  return result;
}
// 1005C824: using guessed type int (__stdcall *off_1005C824[4])(char);

//----- (10014290) --------------------------------------------------------
int __userpurge sub_10014290<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // eax@1
  int v6; // edx@1
  int v7; // esi@1
  int v8; // eax@4
  int result; // eax@6

  v7 = a2;
  v5 = sub_10027EB3(a1, a2, a3, a4, 24);
  v6 = v5;
  if ( v5 )
  {
    *(_DWORD *)(v5 + 4) = 15;
    *(_DWORD *)(v5 + 8) = 0;
    *(_DWORD *)(v5 + 12) = 0;
    *(_DWORD *)(v5 + 16) = 0;
    *(_DWORD *)v5 = &off_1005C830;
    *(_DWORD *)(v5 + 20) = a5;
  }
  else
  {
    v6 = 0;
  }
  *(_DWORD *)(v6 + 16) = *(_DWORD *)(v7 + 4);
  v8 = *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12);
  if ( v8 )
  {
    *(_DWORD *)(v6 + 12) = v8;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) + 16) = v6;
  }
  result = *(_DWORD *)(v7 + 4);
  *(_DWORD *)(result + 12) = v6;
  *(_DWORD *)(v7 + 4) = v6;
  return result;
}
// 1005C830: using guessed type int (__stdcall *off_1005C830)(char);

//----- (10014300) --------------------------------------------------------
int __userpurge sub_10014300<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5, char a6)
{
  int v6; // eax@1
  int v7; // ebx@1
  int v8; // eax@4
  int v9; // edx@4
  int v10; // ecx@4
  int v11; // esi@4
  int v12; // eax@7
  int v13; // edi@7
  signed int v14; // eax@8
  int v15; // edx@8
  int v16; // eax@12
  int v17; // eax@14
  int v18; // ecx@14
  int result; // eax@17
  int v20; // [sp+10h] [bp-4h]@4

  v7 = a2;
  v6 = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(v6 + 4) == 6 )
  {
    if ( *(_DWORD *)(v6 + 24) != 1 )
    {
      --*(_DWORD *)(v6 + 24);
      sub_10013BF0(a1, a2, a2, a3, *(_BYTE *)(*(_DWORD *)(v6 + 28) + *(_DWORD *)(v6 + 24)));
    }
  }
  v20 = *(_DWORD *)(v7 + 4);
  v8 = sub_10027EB3(a1, a2, v7, a3, 24);
  v11 = v8;
  if ( v8 )
  {
    *(_DWORD *)(v8 + 4) = 19;
    *(_DWORD *)(v8 + 8) = 0;
    *(_DWORD *)(v8 + 12) = 0;
    *(_DWORD *)(v8 + 16) = 0;
    *(_DWORD *)v8 = &off_1005C830;
    *(_DWORD *)(v8 + 20) = 0;
  }
  else
  {
    v11 = 0;
  }
  v12 = sub_10027EB3(v9, v10, v7, a3, 40);
  v13 = v12;
  if ( v12 )
  {
    *(_DWORD *)(v12 + 12) = 0;
    *(_DWORD *)(v12 + 16) = 0;
    *(_DWORD *)(v12 + 28) = 0;
    v15 = *(_DWORD *)(*(_DWORD *)v7 + 24);
    *(_DWORD *)(*(_DWORD *)v7 + 24) = v15 + 1;
    v14 = 0;
    if ( a6 )
      v14 = 2;
    *(_DWORD *)(v13 + 8) = v14;
    *(_DWORD *)(v13 + 20) = a4;
    *(_DWORD *)(v13 + 4) = 18;
    *(_DWORD *)(v13 + 12) = 0;
    *(_DWORD *)(v13 + 16) = 0;
    *(_DWORD *)v13 = &off_1005C830;
    *(_DWORD *)(v13 + 24) = a5;
    *(_DWORD *)(v13 + 28) = v11;
    *(_DWORD *)(v13 + 32) = v15;
    *(_DWORD *)(v13 + 36) = -1;
  }
  else
  {
    v13 = 0;
  }
  *(_DWORD *)(v11 + 20) = v13;
  *(_DWORD *)(v11 + 16) = *(_DWORD *)(v7 + 4);
  v16 = *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12);
  if ( v16 )
  {
    *(_DWORD *)(v11 + 12) = v16;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) + 16) = v11;
  }
  v18 = v20;
  *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) = v11;
  *(_DWORD *)(v7 + 4) = v11;
  v17 = *(_DWORD *)(v20 + 4);
  if ( v17 == 9 || v17 == 14 )
    v18 = *(_DWORD *)(v20 + 20);
  *(_DWORD *)(*(_DWORD *)(v18 + 16) + 12) = v13;
  result = *(_DWORD *)(v18 + 16);
  *(_DWORD *)(v13 + 16) = result;
  *(_DWORD *)(v18 + 16) = v13;
  *(_DWORD *)(v13 + 12) = v18;
  return result;
}
// 1005C830: using guessed type int (__stdcall *off_1005C830)(char);

//----- (10014440) --------------------------------------------------------
int __usercall sub_10014440<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v4 = sub_10027EB3(a1, a2, a3, a4, 32);
  v5 = v4;
  if ( v4 )
  {
    *(_DWORD *)(v4 + 4) = 6;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    *(_DWORD *)v4 = off_1005C820;
    *(_DWORD *)(v4 + 20) = 0;
    *(_DWORD *)(v4 + 24) = 0;
    *(_DWORD *)(v4 + 28) = 0;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  result = *(_DWORD *)(v6 + 4);
  *(_DWORD *)(result + 12) = v5;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 1005C820: using guessed type int (__stdcall *off_1005C820[5])(char);

//----- (100144C0) --------------------------------------------------------
void *__thiscall sub_100144C0(void *this, int a2, int a3)
{
  void *result; // eax@1
  int i; // ecx@1

  result = this;
  for ( i = a2; i != a3; result = (char *)result + 8 )
  {
    if ( result )
    {
      *(_DWORD *)result = *(_DWORD *)i;
      *((_DWORD *)result + 1) = *(_DWORD *)(i + 4);
    }
    i += 8;
  }
  return result;
}

//----- (100144F0) --------------------------------------------------------
void *__userpurge sub_100144F0<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_100282F6(a2, *(LPVOID *)(a1 + 28));
  *(_DWORD *)v3 = &off_1005C830;
  if ( a3 & 1 )
    sub_1002404A(v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005C830: using guessed type int (__stdcall *off_1005C830)(char);

//----- (10014520) --------------------------------------------------------
int __thiscall sub_10014520(int this, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@1
  char v5; // cl@2
  int v6; // ecx@7
  int v7; // eax@13
  int v8; // ecx@13
  int v9; // eax@13
  int v10; // eax@15
  int v11; // ecx@16

  v3 = a3;
  v4 = this;
  *(_DWORD *)(this + 68) = 0;
  if ( a3 )
  {
    while ( 1 )
    {
      v5 = *(_BYTE *)(v4 + 72);
      if ( a2 == 8 )
      {
        if ( (unsigned __int8)(v5 - 48) > 7u )
          return v3;
      }
      else
      {
        if ( v5 < 48 || v5 > 57 )
        {
          if ( a2 != 16 )
            return v3;
          if ( (unsigned __int8)(v5 - 97) > 5u )
          {
            if ( (unsigned __int8)(v5 - 65) > 5u )
              return v3;
            v6 = v5 - 55;
          }
          else
          {
            v6 = v5 - 87;
          }
          goto LABEL_12;
        }
      }
      v6 = v5 - 48;
LABEL_12:
      if ( v6 != -1 )
      {
        v9 = v6 + a2 * *(_DWORD *)(v4 + 68);
        v8 = *(_DWORD *)(v4 + 8);
        *(_DWORD *)(v4 + 68) = v9;
        v7 = *(_DWORD *)v4;
        --v3;
        if ( *(_DWORD *)v4 != v8 )
        {
          if ( *(_BYTE *)v7 == 92 )
          {
            v10 = v7 + 1;
            if ( v10 != v8 )
            {
              v11 = *(_DWORD *)(v4 + 80);
              if ( !(v11 & 8) && (*(_BYTE *)v10 == 40 || *(_BYTE *)v10 == 41)
                || !(v11 & 0x10) && (*(_BYTE *)v10 == 123 || *(_BYTE *)v10 == 125) )
                *(_DWORD *)v4 = v10;
            }
          }
          ++*(_DWORD *)v4;
        }
        sub_10011500((void *)v4);
        if ( v3 )
          continue;
      }
      return v3;
    }
  }
  return 0;
}

//----- (10014600) --------------------------------------------------------
int __thiscall sub_10014600(int this)
{
  int v1; // eax@1
  int v2; // esi@1
  int v3; // eax@2
  int v4; // ecx@2
  int v5; // eax@4
  int v6; // ecx@5
  int v7; // eax@13
  int v8; // ecx@13
  int result; // eax@14
  int v10; // edi@23

  v2 = this;
  v1 = *(_DWORD *)(this + 76);
  switch ( v1 )
  {
    case -4294967204:
      v3 = *(_DWORD *)this;
      v4 = *(_DWORD *)(this + 8);
      if ( *(_DWORD *)v2 != v4 )
      {
        if ( *(_BYTE *)v3 == 92 )
        {
          v5 = v3 + 1;
          if ( v5 != v4 )
          {
            v6 = *(_DWORD *)(v2 + 80);
            if ( !(v6 & 8) && (*(_BYTE *)v5 == 40 || *(_BYTE *)v5 == 41)
              || !(v6 & 0x10) && (*(_BYTE *)v5 == 123 || *(_BYTE *)v5 == 125) )
              *(_DWORD *)v2 = v5;
          }
        }
        ++*(_DWORD *)v2;
      }
      sub_10011500((void *)v2);
      v7 = *(_DWORD *)(v2 + 80);
      if ( v7 & 0x200000 )
        return loc_10015200(v2, v8);
      if ( v7 & 0x10000 && sub_10014890(v2, *(_BYTE *)(v2 + 72)) )
        goto LABEL_20;
      if ( *(_DWORD *)(v2 + 80) & 0x8000 && *(_BYTE *)(v2 + 72) == 97 )
      {
        *(_DWORD *)(v2 + 68) = 7;
LABEL_20:
        sub_10012960((void *)v2);
        return 1;
      }
      *(_DWORD *)(v2 + 68) = 92;
      result = 1;
      break;
    case -4294967205:
      sub_10012960((void *)this);
      v10 = *(_DWORD *)(v2 + 76);
      if ( v10 == 58 || v10 == 61 || v10 == 46 )
      {
        sub_10012960((void *)v2);
        loc_10015090(v2, v10);
        result = 2;
      }
      else
      {
        *(_DWORD *)(v2 + 68) = 91;
        result = 1;
      }
      break;
    case -4294967203:
    case -1:
      result = 0;
      break;
    default:
      *(_DWORD *)(this + 68) = *(_BYTE *)(this + 72);
      sub_10012960((void *)this);
      result = 1;
      break;
  }
  return result;
}

//----- (10014890) --------------------------------------------------------
char __thiscall sub_10014890(int this, char a2)
{
  char result; // al@2

  switch ( a2 )
  {
    case 98:
      *(_DWORD *)(this + 68) = 8;
      result = 1;
      break;
    case 102:
      *(_DWORD *)(this + 68) = 12;
      result = 1;
      break;
    case 110:
      *(_DWORD *)(this + 68) = 10;
      result = 1;
      break;
    case 114:
      *(_DWORD *)(this + 68) = 13;
      result = 1;
      break;
    case 116:
      *(_DWORD *)(this + 68) = 9;
      result = 1;
      break;
    case 118:
      *(_DWORD *)(this + 68) = 11;
      result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (10014910) --------------------------------------------------------
int __thiscall sub_10014910(void *this, int a2, int a3, char a4)
{
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // eax@2
  char **v7; // edx@2
  int v8; // eax@3
  char *v9; // ebx@3
  int v10; // esi@3
  int v11; // eax@5
  char v12; // al@5
  int result; // eax@10
  int v14; // ecx@10
  int v15; // [sp+0h] [bp-Ch]@2
  int v16; // [sp+4h] [bp-8h]@3
  int v17; // [sp+8h] [bp-4h]@1

  v4 = (int)this;
  v5 = 0;
  v17 = 0;
  if ( off_1005C838 )
  {
    v15 = v4;
    v6 = 0;
    v7 = &off_1005C838;
    do
    {
      v9 = *v7;
      v10 = a2;
      v8 = (int)&(*v7)[*(int *)((char *)&dword_1005C83C + v6)];
      v16 = v8;
      if ( a2 == a3 )
      {
LABEL_8:
        if ( v9 == (char *)v8 )
          break;
      }
      else
      {
        while ( v9 != (char *)v8 )
        {
          LOBYTE(v5) = *v9;
          v11 = *(_BYTE *)v10++;
          v12 = sub_10012830((int)&v15, (char)v9++, v11, v5);
          if ( !v12 )
            goto LABEL_17;
          v8 = v16;
          if ( v10 == a3 )
            goto LABEL_7;
        }
        if ( v10 == a3 )
        {
LABEL_7:
          v5 = v17;
          goto LABEL_8;
        }
LABEL_17:
        v5 = v17;
      }
      ++v5;
      v17 = v5;
      v6 = 12 * v5;
      v7 = &(&off_1005C838)[12 * v5];
    }
    while ( (&off_1005C838)[12 * v5] );
  }
  v14 = 3 * v5;
  result = 0;
  if ( (&off_1005C838)[4 * v14] )
    result = (unsigned __int16)word_1005C840[2 * v14];
  if ( a4 )
  {
    if ( result & 3 )
      result |= 3u;
  }
  return result;
}
// 1005C838: using guessed type char *off_1005C838;
// 1005C83C: using guessed type int dword_1005C83C;
// 1005C840: using guessed type __int16 word_1005C840[];

//----- (100149D0) --------------------------------------------------------
int __userpurge sub_100149D0<eax>(int a1<edx>, int a2<ecx>, __int16 a3<bx>, int a4, int a5)
{
  int v5; // edi@1
  int v6; // esi@2
  int v7; // ecx@3
  int v8; // eax@3
  int v9; // eax@3
  int v10; // edx@3
  int v11; // eax@4
  int v12; // esi@6
  char v13; // al@6
  int v14; // ecx@7
  int v15; // eax@7
  int v16; // eax@7
  int v17; // edx@7
  int v18; // eax@8
  int v19; // esi@12
  int v20; // eax@14
  int result; // eax@25
  int v23; // eax@31
  unsigned int v24; // eax@35
  int v25; // edi@35
  int v26; // eax@36
  int v27; // ecx@39
  unsigned int v28; // edi@39
  int v29; // esi@39
  int v30; // eax@40
  int v31; // edi@40
  int v32; // [sp+10h] [bp-14h]@7
  int v33; // [sp+14h] [bp-10h]@3
  int v34; // [sp+20h] [bp-4h]@3
  int v35; // [sp+2Ch] [bp+8h]@36
  int v36; // [sp+30h] [bp+Ch]@14

  v5 = a2;
  if ( *(_DWORD *)(a2 + 8) & 0x100 )
  {
    v6 = *(_DWORD *)(a2 + 12);
    if ( !*(_DWORD *)(v6 + 4) )
    {
      v8 = sub_100100B0(v6, (int)&v33);
      v34 = 0;
      v9 = sub_1000C9E0(v10, a3, v5, v8);
      v34 = -1;
      v7 = v33;
      *(_DWORD *)(v6 + 4) = v9;
      if ( v7 )
      {
        v11 = (*(int (**)(void))(*(_DWORD *)v7 + 8))();
        if ( v11 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v11)(v11, 1);
      }
    }
    v13 = (*(int (__stdcall **)(int))(**(_DWORD **)(v6 + 4) + 16))(a4);
    v12 = *(_DWORD *)(v5 + 12);
    LOBYTE(a3) = v13;
    LOBYTE(a4) = v13;
    if ( !*(_DWORD *)(v12 + 4) )
    {
      v15 = sub_100100B0(v12, (int)&v32);
      v34 = 1;
      v16 = sub_1000C9E0(v17, a3, v5, v15);
      v34 = -1;
      v14 = v32;
      *(_DWORD *)(v12 + 4) = v16;
      if ( v14 )
      {
        v18 = (*(int (**)(void))(*(_DWORD *)v14 + 8))();
        if ( v18 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v18)(v18, 1);
      }
    }
    HIBYTE(a3) = (*(int (__stdcall **)(int))(**(_DWORD **)(v12 + 4) + 16))(a5);
  }
  else
  {
    LOBYTE(a3) = a4;
    HIBYTE(a3) = a5;
  }
  v19 = *(_DWORD *)(v5 + 4);
  if ( (_BYTE)a3 < 0 )
    goto LABEL_46;
  if ( (_BYTE)a3 <= HIBYTE(a3) )
  {
    v20 = SHIBYTE(a3);
    v36 = SHIBYTE(a3);
    do
    {
      if ( v20 >= *(_DWORD *)(v5 + 16) )
        break;
      if ( !*(_DWORD *)(v19 + 24) )
      {
        _EAX = sub_10027EB3(a1, a2, a3, v5, 32);
        if ( _EAX )
        {
          __asm
          {
            xorps   xmm0, xmm0
            movq    qword ptr [eax], xmm0
            movq    qword ptr [eax+8], xmm0
            movq    qword ptr [eax+10h], xmm0
            movq    qword ptr [eax+18h], xmm0
          }
        }
        else
        {
          _EAX = 0;
        }
        *(_DWORD *)(v19 + 24) = _EAX;
      }
      a1 = ((unsigned int)(char)a3 >> 3) + *(_DWORD *)(v19 + 24);
      a2 = a3 & 7;
      *(_BYTE *)a1 |= 1 << a2;
      if ( (_BYTE)a3 == HIBYTE(a3) )
        break;
      v20 = v36;
      LOBYTE(a3) = a3 + 1;
    }
    while ( (_BYTE)a3 <= HIBYTE(a3) );
    LOBYTE(a4) = a3;
  }
  if ( (_BYTE)a3 < 0 || (result = (char)a3, a2 = SHIBYTE(a3) - (char)a3, a2 >= *(_DWORD *)(v5 + 20)) )
  {
LABEL_46:
    if ( !*(_DWORD *)(v19 + 32) )
    {
      v23 = sub_10027EB3(a1, a2, a3, v5, 12);
      if ( v23 )
      {
        *(_DWORD *)v23 = 0;
        *(_DWORD *)(v23 + 4) = 0;
        *(_DWORD *)(v23 + 8) = 0;
      }
      else
      {
        v23 = 0;
      }
      *(_DWORD *)(v19 + 32) = v23;
    }
    v25 = *(_DWORD *)(v19 + 32);
    v24 = *(_DWORD *)(v25 + 4);
    if ( *(_DWORD *)v25 <= v24 )
    {
      v35 = v24 + 16;
      v26 = sub_10028586(a1, a2, a3, v25, *(LPVOID *)(v25 + 8), v24 + 16);
      if ( !v26 )
        sub_10021BC5();
      *(_DWORD *)(v25 + 8) = v26;
      *(_DWORD *)v25 = v35;
    }
    v27 = *(_DWORD *)(v25 + 8);
    *(_BYTE *)(v27 + *(_DWORD *)(v25 + 4)++) = a3;
    v29 = *(_DWORD *)(v19 + 32);
    v28 = *(_DWORD *)(v29 + 4);
    if ( *(_DWORD *)v29 <= v28 )
    {
      v31 = v28 + 16;
      v30 = sub_10028586(a1, v27, a3, v31, *(LPVOID *)(v29 + 8), v31);
      if ( !v30 )
        sub_10021BC5();
      *(_DWORD *)(v29 + 8) = v30;
      *(_DWORD *)v29 = v31;
    }
    result = *(_DWORD *)(v29 + 4);
    *(_BYTE *)(*(_DWORD *)(v29 + 8) + result) = HIBYTE(a3);
    ++*(_DWORD *)(v29 + 4);
  }
  else
  {
    for ( ; (_BYTE)a3 <= HIBYTE(a3); LOBYTE(a4) = a3 )
    {
      result = sub_10014E30(a1, v5, a3, v5, a4);
      if ( (_BYTE)a3 == HIBYTE(a3) )
        break;
      LOBYTE(a3) = a3 + 1;
    }
  }
  return result;
}

//----- (10014C30) --------------------------------------------------------
int __userpurge sub_10014C30<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, char a4)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // eax@4
  int v10; // edx@4
  int v11; // eax@7
  int result; // eax@9
  char v13; // [sp+0h] [bp-20h]@1
  char *v14; // [sp+10h] [bp-10h]@1
  int v15; // [sp+1Ch] [bp-4h]@4

  v14 = &v13;
  v7 = a2;
  v4 = sub_10027EB3(a1, a2, a3, a2, 24);
  v8 = v4;
  if ( v4 )
  {
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    *(_DWORD *)v4 = off_1005C82C;
    *(_DWORD *)(v4 + 20) = 0;
    *(_DWORD *)(v4 + 4) = (a4 != 0) + 10;
  }
  else
  {
    v8 = 0;
  }
  v15 = 0;
  v9 = sub_10027EB3(v5, v6, a3, v7, 20);
  v10 = v9;
  if ( v9 )
  {
    *(_DWORD *)v9 = &off_1005C830;
    *(_DWORD *)(v9 + 4) = 1;
    *(_DWORD *)(v9 + 8) = 0;
    *(_DWORD *)(v9 + 12) = 0;
    *(_DWORD *)(v9 + 16) = 0;
  }
  else
  {
    v10 = 0;
  }
  *(_DWORD *)(v8 + 16) = *(_DWORD *)(v7 + 4);
  v11 = *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12);
  if ( v11 )
  {
    *(_DWORD *)(v8 + 12) = v11;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) + 16) = v8;
  }
  result = v8;
  *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) = v8;
  *(_DWORD *)(v8 + 20) = v10;
  *(_DWORD *)(v10 + 16) = v8;
  *(_DWORD *)(v7 + 4) = v10;
  return result;
}
// 1005C82C: using guessed type int (__stdcall *off_1005C82C[2])(char);
// 1005C830: using guessed type int (__stdcall *off_1005C830)(char);

//----- (10014D40) --------------------------------------------------------
char __userpurge sub_10014D40<al>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>, int a5)
{
  int v5; // esi@1
  int v6; // ecx@3
  int v7; // eax@3
  int v8; // eax@3
  int v9; // edx@3
  int v10; // eax@4
  char v11; // bl@6
  int v12; // esi@8
  char result; // al@13
  unsigned int v15; // edx@13
  int v16; // [sp+10h] [bp-10h]@3
  int v17; // [sp+1Ch] [bp-4h]@3

  v5 = a2;
  if ( *(_DWORD *)(a2 + 8) & 0x100 )
  {
    a4 = *(_DWORD *)(a2 + 12);
    if ( !*(_DWORD *)(a4 + 4) )
    {
      v7 = sub_100100B0(a4, (int)&v16);
      v17 = 0;
      v8 = sub_1000C9E0(v9, a3, a4, v7);
      v17 = -1;
      v6 = v16;
      *(_DWORD *)(a4 + 4) = v8;
      if ( v6 )
      {
        v10 = (*(int (**)(void))(*(_DWORD *)v6 + 8))();
        if ( v10 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v10)(v10, 1);
      }
    }
    v11 = (*(int (__stdcall **)(int))(**(_DWORD **)(a4 + 4) + 16))(a5);
  }
  else
  {
    v11 = a5;
  }
  v12 = *(_DWORD *)(v5 + 4);
  if ( !*(_DWORD *)(v12 + 24) )
  {
    _EAX = sub_10027EB3(a1, a2, v11, a4, 32);
    if ( _EAX )
    {
      __asm
      {
        xorps   xmm0, xmm0
        movq    qword ptr [eax], xmm0
        movq    qword ptr [eax+8], xmm0
        movq    qword ptr [eax+10h], xmm0
        movq    qword ptr [eax+18h], xmm0
      }
    }
    else
    {
      _EAX = 0;
    }
    *(_DWORD *)(v12 + 24) = _EAX;
  }
  v15 = ((unsigned int)v11 >> 3) + *(_DWORD *)(v12 + 24);
  result = 1 << (v11 & 7);
  *(_BYTE *)v15 |= result;
  return result;
}

//----- (10014E30) --------------------------------------------------------
int __userpurge sub_10014E30<eax>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>, int a5)
{
  int v5; // esi@1
  int v6; // ecx@3
  int v7; // eax@3
  int v8; // eax@3
  int v9; // edx@3
  int v10; // eax@4
  char v11; // bl@6
  int v12; // esi@8
  int v13; // eax@9
  unsigned int v14; // eax@13
  int v15; // esi@13
  int v16; // eax@14
  int v17; // edi@14
  int result; // eax@17
  int v19; // [sp+10h] [bp-10h]@3
  int v20; // [sp+1Ch] [bp-4h]@3

  v5 = a2;
  if ( *(_DWORD *)(a2 + 8) & 0x100 )
  {
    a4 = *(_DWORD *)(a2 + 12);
    if ( !*(_DWORD *)(a4 + 4) )
    {
      v7 = sub_100100B0(a4, (int)&v19);
      v20 = 0;
      v8 = sub_1000C9E0(v9, a3, a4, v7);
      v20 = -1;
      v6 = v19;
      *(_DWORD *)(a4 + 4) = v8;
      if ( v6 )
      {
        v10 = (*(int (**)(void))(*(_DWORD *)v6 + 8))();
        if ( v10 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v10)(v10, 1);
      }
    }
    v11 = (*(int (__stdcall **)(int))(**(_DWORD **)(a4 + 4) + 16))(a5);
  }
  else
  {
    v11 = a5;
  }
  v12 = *(_DWORD *)(v5 + 4);
  if ( !*(_DWORD *)(v12 + 28) )
  {
    v13 = sub_10027EB3(a1, a2, v11, a4, 12);
    if ( v13 )
    {
      *(_DWORD *)v13 = 0;
      *(_DWORD *)(v13 + 4) = 0;
      *(_DWORD *)(v13 + 8) = 0;
    }
    else
    {
      v13 = 0;
    }
    *(_DWORD *)(v12 + 28) = v13;
  }
  v15 = *(_DWORD *)(v12 + 28);
  v14 = *(_DWORD *)(v15 + 4);
  if ( *(_DWORD *)v15 <= v14 )
  {
    v17 = v14 + 16;
    v16 = sub_10028586(a1, a2, v11, v14 + 16, *(LPVOID *)(v15 + 8), v14 + 16);
    if ( !v16 )
      sub_10021BC5();
    *(_DWORD *)(v15 + 8) = v16;
    *(_DWORD *)v15 = v17;
  }
  result = *(_DWORD *)(v15 + 4);
  *(_BYTE *)(*(_DWORD *)(v15 + 8) + result) = v11;
  ++*(_DWORD *)(v15 + 4);
  return result;
}

//----- (10014F40) --------------------------------------------------------
int __thiscall sub_10014F40(int this, int a2, int a3, int a4, int a5)
{
  int result; // eax@1
  int v6; // ebx@1
  int v7; // esi@1
  void *v8; // ecx@2
  char v9; // cf@2
  const void *v10; // edx@3
  int v11; // edx@4
  int v12; // ecx@4
  int v13; // ecx@4
  unsigned int v14; // edi@4
  int v15; // edi@5
  int v16; // ecx@9
  int v17; // esi@12
  int v18; // esi@12
  void *v19; // eax@12
  void *v20; // eax@12
  int v21; // edx@15
  int v22; // [sp+8h] [bp-Ch]@9

  result = a4;
  v7 = a4 - a3;
  v6 = this;
  if ( a4 != a3 )
  {
    v9 = *(_DWORD *)(this + 8) - *(_DWORD *)(this + 4) < (unsigned int)v7;
    v8 = *(void **)(this + 4);
    if ( v9 )
    {
      v10 = *(const void **)v6;
      if ( *(_DWORD *)v6 - (_DWORD)v8 - 1 < (unsigned int)v7 )
      {
        sub_10021C1A((int)"vector<T> too long");
      }
      else
      {
        v13 = v8 - v10;
        v14 = *(_DWORD *)(v6 + 8) - (_DWORD)v10;
        v11 = v14 >> 1;
        v12 = v7 + v13;
        if ( -1 - (v14 >> 1) >= v14 )
          v15 = v11 + v14;
        else
          v15 = 0;
        if ( v15 < (unsigned int)v12 )
          v15 = v12;
        v16 = 0;
        v22 = 0;
        if ( !v15 || (unsigned int)v15 <= 0xFFFFFFFF && (v16 = sub_10027EB3(v11, 0, v6, v15, v15), v22 = v16, v16) )
        {
          v18 = a2 - *(_DWORD *)v6;
          v19 = sub_100237D0((void *)v16, *(const void **)v6, a2 - *(_DWORD *)v6);
          v20 = sub_100156A0((char *)v19 + v18, a3, a4);
          sub_100237D0(v20, (const void *)a2, *(_DWORD *)(v6 + 4) - a2);
          v17 = *(_DWORD *)(v6 + 4) - *(_DWORD *)v6 + a4 - a3;
          if ( *(_DWORD *)v6 )
            sub_1002404A(*(LPVOID *)v6);
          *(_DWORD *)v6 = v22;
          *(_DWORD *)(v6 + 8) = v22 + v15;
          result = v22 + v17;
          *(_DWORD *)(v6 + 4) = v22 + v17;
          return result;
        }
      }
      sub_10021BC5();
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(loc_10015090);
    }
    sub_100156A0(v8, a3, a4);
    v21 = *(_DWORD *)(v6 + 4);
    result = v21 + v7;
    if ( a2 != v21 )
    {
      if ( v21 != result )
        result = sub_100156D0(a2, v21, v21 + v7);
    }
    *(_DWORD *)(v6 + 4) += v7;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10015280) --------------------------------------------------------
char __stdcall sub_10015280(int a1, int a2, int a3)
{
  unsigned int v3; // esi@1
  char result; // al@2
  int v5; // edx@2
  int v6; // ecx@2

  v3 = 0;
  do
  {
    result = sub_1000F490(a3, a3, v3, a2);
    if ( result )
    {
      if ( !*(_DWORD *)(a1 + 24) )
      {
        _EAX = sub_10027EB3(v5, v6, a3, a1, 32);
        if ( _EAX )
        {
          __asm
          {
            xorps   xmm0, xmm0
            movq    qword ptr [eax], xmm0
            movq    qword ptr [eax+8], xmm0
            movq    qword ptr [eax+10h], xmm0
            movq    qword ptr [eax+18h], xmm0
          }
        }
        else
        {
          _EAX = 0;
        }
        *(_DWORD *)(a1 + 24) = _EAX;
      }
      result = 1 << (v3 & 7);
      *(_BYTE *)(*(_DWORD *)(a1 + 24) + (v3 >> 3)) |= result;
    }
    ++v3;
  }
  while ( (signed int)v3 < 256 );
  return result;
}

//----- (10015300) --------------------------------------------------------
char __thiscall sub_10015300(int this, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // esi@1
  int v6; // eax@1
  void *v7; // ecx@1
  int v8; // eax@2
  int v9; // ecx@2
  void *v10; // ecx@2
  int *v11; // esi@2
  char v12; // cf@4
  int v13; // edx@6
  char v14; // cf@9
  char v15; // cf@11
  unsigned __int8 v16; // cf@13
  unsigned __int8 v17; // al@19
  int v18; // eax@20
  char v19; // zf@22
  bool v20; // eax@25
  char result; // al@28
  int v22; // edi@31
  void *v24; // [sp+10h] [bp-58h]@2
  unsigned int v25; // [sp+24h] [bp-44h]@28
  int v26; // [sp+28h] [bp-40h]@1
  int v27; // [sp+2Ch] [bp-3Ch]@4
  int v28; // [sp+30h] [bp-38h]@1
  char v29; // [sp+37h] [bp-31h]@28
  void *v30; // [sp+38h] [bp-30h]@1
  unsigned int v31; // [sp+48h] [bp-20h]@6
  unsigned int v32; // [sp+4Ch] [bp-1Ch]@2
  char v33; // [sp+53h] [bp-15h]@2
  unsigned int v34; // [sp+54h] [bp-14h]@1
  int v35; // [sp+64h] [bp-4h]@1
  int v36; // [sp+68h] [bp+0h]@1

  v34 = (unsigned int)&v36 ^ __security_cookie;
  v5 = this;
  v26 = this;
  v6 = *(_DWORD *)(this + 4);
  v7 = *(void **)(this + 12);
  v28 = v6;
  sub_10012560(v7, (int)&v30, a2, a3);
  v35 = 0;
  v4 = 0;
  do
  {
    v10 = *(void **)(v5 + 12);
    v33 = v4;
    v8 = sub_10015510(v10, (int)&v24, (int)&v33, (int)&v34);
    v9 = *(_DWORD *)(v8 + 16);
    v11 = (int *)&v30;
    if ( v32 >= 0x10 )
      v11 = (int *)v30;
    v12 = *(_DWORD *)(v8 + 20) < 0x10u;
    v27 = *(_DWORD *)(v8 + 16);
    if ( !v12 )
      v8 = *(_DWORD *)v8;
    v13 = v31;
    if ( v9 < v31 )
      v13 = v9;
    if ( !v13 )
      goto LABEL_24;
    v14 = (unsigned int)v13 < 4;
    v13 -= 4;
    if ( v14 )
    {
LABEL_12:
      if ( v13 == -4 )
        goto LABEL_21;
    }
    else
    {
      while ( 1 )
      {
        v9 = *(_DWORD *)v8;
        if ( *(_DWORD *)v8 != *v11 )
          break;
        v8 += 4;
        ++v11;
        v15 = (unsigned int)v13 < 4;
        v13 -= 4;
        if ( v15 )
          goto LABEL_12;
      }
    }
    LOBYTE(v9) = *(_BYTE *)v8;
    v16 = *(_BYTE *)v8 < *(_BYTE *)v11;
    if ( *(_BYTE *)v8 == *(_BYTE *)v11 )
    {
      if ( v13 == -3
        || (LOBYTE(v9) = *(_BYTE *)(v8 + 1), v16 = (_BYTE)v9 < *((_BYTE *)v11 + 1), (_BYTE)v9 == *((_BYTE *)v11 + 1))
        && (v13 == -2
         || (LOBYTE(v9) = *(_BYTE *)(v8 + 2), v16 = (_BYTE)v9 < *((_BYTE *)v11 + 2), (_BYTE)v9 == *((_BYTE *)v11 + 2))
         && (v13 == -1 || (v17 = *(_BYTE *)(v8 + 3), v16 = v17 < *((_BYTE *)v11 + 3), v17 == *((_BYTE *)v11 + 3)))) )
      {
LABEL_21:
        v18 = 0;
        goto LABEL_22;
      }
    }
    v18 = -v16 | 1;
LABEL_22:
    v19 = v18 == 0;
    if ( v18 )
      goto LABEL_28;
    v9 = v27;
LABEL_24:
    if ( v9 >= v31 )
      v20 = v9 != v31;
    else
      v20 = -1;
    v19 = v20 == 0;
LABEL_28:
    result = v19;
    v29 = v19;
    if ( v25 >= 0x10 )
    {
      sub_1002404A(v24);
      result = v29;
    }
    if ( result )
    {
      v22 = v28;
      if ( !*(_DWORD *)(v28 + 24) )
      {
        _EAX = sub_10027EB3(v13, v9, v4, v28, 32);
        if ( _EAX )
        {
          __asm
          {
            xorps   xmm0, xmm0
            movq    qword ptr [eax], xmm0
            movq    qword ptr [eax+8], xmm0
            movq    qword ptr [eax+10h], xmm0
            movq    qword ptr [eax+18h], xmm0
          }
        }
        else
        {
          _EAX = 0;
        }
        *(_DWORD *)(v22 + 24) = _EAX;
      }
      result = 1 << (v4 & 7);
      *(_BYTE *)(*(_DWORD *)(v22 + 24) + ((unsigned int)v4 >> 3)) |= result;
    }
    v5 = v26;
    ++v4;
  }
  while ( v4 < 256 );
  if ( v32 >= 0x10 )
    result = sub_1002404A(v30);
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (100154A0) --------------------------------------------------------
int __fastcall sub_100154A0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // ebx@1
  int v7; // esi@1
  int v8; // eax@2
  int v9; // eax@6

  v7 = a6;
  v6 = *(_DWORD *)a6;
  if ( !*(_DWORD *)a6 )
    goto LABEL_13;
  do
  {
    v8 = *(_DWORD *)v7;
    if ( (unsigned int)a5 >= **(_DWORD **)v7 )
      break;
    v7 = v8 + 16;
  }
  while ( *(_DWORD *)(v8 + 16) );
  v6 = *(_DWORD *)v7;
  if ( !*(_DWORD *)v7 || a5 != *(_DWORD *)v6 )
  {
LABEL_13:
    v9 = sub_10027EB3(a2, a1, v6, a5, 20);
    if ( v9 )
    {
      *(_DWORD *)v9 = a5;
      *(_DWORD *)(v9 + 4) = 0;
      *(_DWORD *)(v9 + 8) = 0;
      *(_DWORD *)(v9 + 12) = 0;
    }
    else
    {
      v9 = 0;
    }
    *(_DWORD *)v7 = v9;
    *(_DWORD *)(v9 + 16) = v6;
  }
  return loc_100157A0(*(_DWORD *)v7 + 4, a3, a4);
}

//----- (10015510) --------------------------------------------------------
int __thiscall sub_10015510(void *this, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@2
  int v6; // ecx@3
  int v7; // eax@3
  int v8; // eax@3
  int v9; // edx@3
  int v10; // eax@4
  int v11; // ecx@7
  int v12; // eax@7
  int v13; // eax@7
  int v14; // edx@7
  int v15; // eax@8
  int v16; // ebx@10
  void *v18; // [sp+14h] [bp-38h]@10
  unsigned int v19; // [sp+28h] [bp-24h]@14
  int v20; // [sp+2Ch] [bp-20h]@2
  int v21; // [sp+30h] [bp-1Ch]@2
  int v22; // [sp+34h] [bp-18h]@2
  int v23; // [sp+38h] [bp-14h]@1
  int v24; // [sp+48h] [bp-4h]@1
  int v25; // [sp+58h] [bp+Ch]@2

  v4 = (int)this;
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  v24 = 0;
  v23 = 1;
  if ( a3 != a4 )
  {
    v20 = 0;
    v21 = 0;
    v22 = 0;
    sub_10015800(&v20, a3, a4);
    v24 = 1;
    v5 = v20;
    v25 = v21 - v20;
    if ( !*(_DWORD *)(v4 + 4) )
    {
      v7 = sub_100100B0(v4, (int)&a4);
      LOBYTE(v24) = 2;
      v8 = sub_1000C9E0(v9, v4, v5, v7);
      LOBYTE(v24) = 1;
      v6 = a4;
      *(_DWORD *)(v4 + 4) = v8;
      if ( v6 )
      {
        v10 = (*(int (**)(void))(*(_DWORD *)v6 + 8))();
        if ( v10 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v10)(v10, 1);
      }
    }
    (*(void (__stdcall **)(int, int))(**(_DWORD **)(v4 + 4) + 12))(v5, v5 + v25);
    if ( !*(_DWORD *)v4 )
    {
      v12 = sub_100100B0(v4, (int)&a4);
      LOBYTE(v24) = 3;
      v13 = sub_10011270(v14, v4, v5, v12);
      LOBYTE(v24) = 1;
      v11 = a4;
      *(_DWORD *)v4 = v13;
      if ( v11 )
      {
        v15 = (*(int (**)(void))(*(_DWORD *)v11 + 8))();
        if ( v15 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v15)(v15, 1);
      }
    }
    v16 = sub_1000FE50(*(void **)v4, (int)&v18, v5, v5 + v25);
    if ( a2 != v16 )
    {
      if ( *(_DWORD *)(a2 + 20) >= 0x10u )
        sub_1002404A(*(LPVOID *)a2);
      *(_DWORD *)(a2 + 20) = 15;
      *(_DWORD *)(a2 + 16) = 0;
      *(_BYTE *)a2 = 0;
      sub_10002780((void *)a2, v16);
    }
    if ( v19 >= 0x10 )
      sub_1002404A(v18);
    if ( v5 )
      sub_1002404A((LPVOID)v5);
  }
  return a2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (100156A0) --------------------------------------------------------
void *__thiscall sub_100156A0(void *this, int a2, int a3)
{
  void *result; // eax@1
  int i; // ecx@1

  result = this;
  for ( i = a2; i != a3; result = (char *)result + 1 )
  {
    if ( result )
      *(_BYTE *)result = *(_BYTE *)i;
    ++i;
  }
  return result;
}

//----- (100156D0) --------------------------------------------------------
int __fastcall sub_100156D0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // edx@1
  int v5; // ecx@1
  signed int v6; // ebx@1
  int v7; // edi@1
  signed int v8; // esi@1
  int v9; // edi@1
  int v10; // edx@2
  int v11; // ebx@6
  int v12; // eax@7
  int v13; // edx@9
  int v14; // esi@9
  char v15; // dl@10
  int v16; // [sp+Ch] [bp-1Ch]@6
  int v17; // [sp+14h] [bp-14h]@1
  int v18; // [sp+18h] [bp-10h]@1
  int v19; // [sp+18h] [bp-10h]@6
  int v20; // [sp+1Ch] [bp-Ch]@1
  int v21; // [sp+20h] [bp-8h]@9
  int v22; // [sp+24h] [bp-4h]@1

  v9 = a2;
  v4 = a1;
  v5 = a3;
  v7 = v9 - v4;
  result = a3 - v4;
  v22 = v4;
  v17 = v7;
  v18 = a3 - v4;
  v6 = a3 - v4;
  v20 = a3 - v4;
  v8 = v7;
  if ( v7 )
  {
    do
    {
      v10 = v6 % v8;
      v6 = v8;
      v8 = v10;
    }
    while ( v10 );
    v4 = v22;
    result = v18;
    v20 = v6;
  }
  if ( v6 < result )
  {
    if ( v6 > 0 )
    {
      v16 = -v4;
      v19 = -v7;
      v11 = v4 + v6;
      do
      {
        v12 = v11 + v7;
        if ( v11 + v7 == v5 )
          v12 = v22;
        v13 = v11;
        v21 = v11;
        v14 = -v12;
        do
        {
          v15 = *(_BYTE *)v13;
          *(_BYTE *)v21 = *(_BYTE *)v12;
          v7 = v17;
          *(_BYTE *)v12 = v15;
          v13 = v12;
          v21 = v12;
          if ( v17 >= v14 + a3 )
          {
            v12 += v22 + v17 - a3;
            v14 += a3 + v19 + v16;
            v13 = v21;
          }
          else
          {
            v12 += v17;
            v14 += v19;
          }
        }
        while ( v12 != v11 );
        v5 = a3;
        result = v20 - 1;
        --v11;
        v20 = result;
      }
      while ( result > 0 );
    }
  }
  return result;
}

//----- (10015800) --------------------------------------------------------
int __thiscall sub_10015800(void *this, int a2, int a3)
{
  char v4; // [sp+0h] [bp-24h]@1
  void *v5; // [sp+10h] [bp-14h]@1
  char *v6; // [sp+14h] [bp-10h]@1
  int v7; // [sp+20h] [bp-4h]@1

  v6 = &v4;
  v7 = 0;
  v5 = this;
  return loc_10015870(*(_DWORD *)this);
}

//----- (100159A0) --------------------------------------------------------
int __thiscall sub_100159A0(void *this, int a2)
{
  int v2; // eax@1
  int v3; // ebx@2
  char *v4; // edi@2
  const char *v5; // edx@3
  unsigned int v6; // ecx@6
  char v7; // bl@13
  LPVOID v9[4]; // [sp+14h] [bp-40h]@5
  int v10; // [sp+24h] [bp-30h]@5
  unsigned int v11; // [sp+28h] [bp-2Ch]@5
  LPVOID v12[4]; // [sp+2Ch] [bp-28h]@2
  int v13; // [sp+3Ch] [bp-18h]@2
  unsigned int v14; // [sp+40h] [bp-14h]@2

  v2 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    v5 = *(const char **)(v2 + 24);
    if ( !v5 )
      v5 = (const char *)(v2 + 28);
    v11 = 15;
    v10 = 0;
    LOBYTE(v9[0]) = 0;
    if ( *v5 )
      v6 = strlen(v5);
    else
      v6 = 0;
    loc_10001BD0(v9, v5, v6);
    v4 = (char *)v9;
    LOBYTE(v3) = 2;
  }
  else
  {
    v14 = 15;
    v13 = v2;
    LOBYTE(v12[0]) = v2;
    v4 = (char *)v12;
    v3 = v2 + 1;
  }
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  if ( *((_DWORD *)v4 + 5) >= 0x10u )
  {
    *(_DWORD *)a2 = *(_DWORD *)v4;
    *(_DWORD *)v4 = 0;
  }
  else
  {
    if ( *((_DWORD *)v4 + 4) != -1 )
      sub_100237D0((void *)a2, v4, *((_DWORD *)v4 + 4) + 1);
  }
  *(_DWORD *)(a2 + 16) = *((_DWORD *)v4 + 4);
  v7 = v3 | 4;
  *(_DWORD *)(a2 + 20) = *((_DWORD *)v4 + 5);
  *((_DWORD *)v4 + 5) = 15;
  *((_DWORD *)v4 + 4) = 0;
  *v4 = 0;
  if ( v7 & 2 )
  {
    v7 &= 0xFDu;
    if ( v11 >= 0x10 )
      sub_1002404A(v9[0]);
    v11 = 15;
    v10 = 0;
    LOBYTE(v9[0]) = 0;
  }
  if ( v7 & 1 )
  {
    if ( v14 >= 0x10 )
      sub_1002404A(v12[0]);
  }
  return a2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10015B00) --------------------------------------------------------
int __userpurge sub_10015B00<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int *a4)
{
  int v4; // edi@1
  int v5; // ecx@3
  int v6; // edx@5
  int v7; // edx@6
  int v8; // esi@7
  char v10; // [sp-10h] [bp-CCh]@6
  int v11; // [sp-Ch] [bp-C8h]@6
  int v12; // [sp-8h] [bp-C4h]@6
  int v13; // [sp-4h] [bp-C0h]@6
  int (__stdcall **v14)(char); // [sp+Ch] [bp-B0h]@1
  int v15; // [sp+18h] [bp-A4h]@7
  int v16; // [sp+20h] [bp-9Ch]@7
  char v17; // [sp+24h] [bp-98h]@5
  int v18; // [sp+2Ch] [bp-90h]@1
  int v19; // [sp+30h] [bp-8Ch]@1
  char v20; // [sp+34h] [bp-88h]@1
  int v21; // [sp+38h] [bp-84h]@1
  int v22; // [sp+4Ch] [bp-70h]@1
  int v23; // [sp+5Ch] [bp-60h]@1
  int v24; // [sp+6Ch] [bp-50h]@5
  unsigned int v25; // [sp+70h] [bp-4Ch]@3
  int v26; // [sp+74h] [bp-48h]@1
  int v27; // [sp+78h] [bp-44h]@1
  int v28; // [sp+7Ch] [bp-40h]@1
  int v29; // [sp+80h] [bp-3Ch]@1
  int v30; // [sp+84h] [bp-38h]@1
  unsigned int v31; // [sp+A8h] [bp-14h]@1
  int v32; // [sp+B8h] [bp-4h]@1

  v31 = (unsigned int)&v14 ^ __security_cookie;
  v4 = a2;
  v21 = 0;
  v22 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  sub_10002AA0(a1, (int)&v20, a3, a2);
  v32 = 0;
  v18 &= 0xFFFFFE00u;
  v19 = 0;
  LOBYTE(v32) = 2;
  if ( &v23 != a4 )
    loc_10001D10(&v23, a4, 0, -1);
  v5 = (int)&v23;
  if ( v25 >= 0x10 )
    v5 = v23;
  if ( sub_10002BD0((int)&v20, v5, v5 + v24, (int)&v17, v5) )
  {
    sub_10004DA0((int)&v14, v6, (int)&v17);
    LOBYTE(v32) = 3;
    sub_10004DA0((int)&v10, v7, (int)&v14);
    sub_10018AC0(v4 + 84, a3, v10, v11, v12, v13);
    LOBYTE(v32) = 2;
    sub_10004F60((int)&v14, a3);
  }
  else
  {
    v8 = *(_DWORD *)(v4 + 80);
    v16 = (int)"Json parsing failed";
    sub_10023687((int)&v14, &v16);
    v14 = &off_1005D2BC;
    v15 = v8;
    LOBYTE(v32) = 4;
    sub_1001A230(v4, (int)&v14);
    sub_100236FB((int)&v14, a3);
  }
  LOBYTE(v32) = 0;
  sub_10004F60((int)&v17, a3);
  return sub_10004BD0((int)&v20);
}
// 1005D2BC: using guessed type int (__stdcall *off_1005D2BC)(char);
// 10067210: using guessed type int __security_cookie;

//----- (10015CB0) --------------------------------------------------------
int *__usercall sub_10015CB0<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // edx@7
  int v3; // ecx@7
  int v4; // ST00_4@7
  _UNKNOWN *v6; // [sp-4h] [bp-38h]@4
  int v7; // [sp-4h] [bp-38h]@7
  void **v8; // [sp+4h] [bp-30h]@1
  void (__userpurge *v9)(int<ecx>, int<ebx>, int); // [sp+8h] [bp-2Ch]@1
  int *v10; // [sp+Ch] [bp-28h]@1
  int *v11; // [sp+14h] [bp-20h]@1
  int v12; // [sp+1Ch] [bp-18h]@1
  int *v13; // [sp+20h] [bp-14h]@1
  int *v14; // [sp+24h] [bp-10h]@1
  int v15; // [sp+30h] [bp-4h]@1

  v14 = &dword_1006A110;
  dword_1006A124 = 15;
  dword_1006A120 = 0;
  LOBYTE(dword_1006A110) = 0;
  v15 = 0;
  dword_1006A13C = 15;
  dword_1006A138 = 0;
  LOBYTE(dword_1006A128) = 0;
  dword_1006A154 = 15;
  dword_1006A150 = 0;
  LOBYTE(dword_1006A140) = 0;
  __asm
  {
    movsd   xmm0, ds:qword_1005D390
    movsd   qword_1006A160, xmm0
  }
  dword_1006A17C = 15;
  dword_1006A178 = 0;
  LOBYTE(dword_1006A168) = 0;
  dword_1006A180 = 0;
  dword_1006A184 = 3600000;
  qword_1006A188 = -9223372036854775808i64;
  dword_1006A190 = 60;
  dword_1006A1A8 = 15;
  dword_1006A1A4 = 0;
  LOBYTE(dword_1006A194) = 0;
  dword_1006A1AC = 0;
  dword_1006A1B0 = 0;
  dword_1006A1B4 = 0;
  dword_1006A1B8 = 0;
  dword_1006A1BC = 60;
  dword_1006A1D4 = 15;
  dword_1006A1D0 = 0;
  LOBYTE(dword_1006A1C0) = 0;
  dword_1006A1D8 = 0;
  dword_1006A1DC = 0;
  dword_1006A1E0 = 0;
  dword_1006A1E4 = 0;
  dword_1006A1E8 = 0;
  v8 = &off_1005CD30;
  v9 = sub_10016470;
  v10 = &dword_1006A110;
  v11 = (int *)&v8;
  LOBYTE(v15) = 7;
  v13 = &dword_1006A1F0;
  sub_10018EB0((int)&dword_1006A1F0, a1);
  dword_1006A1F0 = (int)&off_1005D22C;
  v12 = (int)&unk_1006A2E8;
  LOBYTE(v15) = 9;
  if ( v11 )
  {
    if ( (void ***)v11 == &v8 )
      v6 = &unk_1006A2E8;
    else
      v6 = 0;
    dword_1006A2F8 = (*(int (__stdcall **)(int))*v11)(v7);
  }
  else
  {
    dword_1006A2F8 = 0;
  }
  LOBYTE(v15) = 10;
  sub_10018F80((int)&dword_1006A1F0, v4, v7);
  sub_10019020((int)&dword_1006A1F0);
  LOBYTE(v15) = 12;
  v3 = (int)v11;
  if ( v11 )
    (*(void (__stdcall **)(bool))(*v11 + 16))((void ***)v11 != &v8);
  dword_1006A300 = 0;
  LOBYTE(v15) = 13;
  dword_1006A304 = 0;
  dword_1006A308 = 0;
  sub_1001BFC0(v2, (int)&dword_1006A304, a2, v3);
  LOBYTE(v15) = 14;
  sub_10024232((int)&unk_1006A30C);
  return &dword_1006A110;
}
// 1005CD30: using guessed type void *off_1005CD30;
// 1005D22C: using guessed type int (__stdcall *off_1005D22C)(char);
// 1006A110: using guessed type int dword_1006A110;
// 1006A120: using guessed type int dword_1006A120;
// 1006A124: using guessed type int dword_1006A124;
// 1006A128: using guessed type int dword_1006A128;
// 1006A138: using guessed type int dword_1006A138;
// 1006A13C: using guessed type int dword_1006A13C;
// 1006A140: using guessed type int dword_1006A140;
// 1006A150: using guessed type int dword_1006A150;
// 1006A154: using guessed type int dword_1006A154;
// 1006A168: using guessed type int dword_1006A168;
// 1006A178: using guessed type int dword_1006A178;
// 1006A17C: using guessed type int dword_1006A17C;
// 1006A180: using guessed type int dword_1006A180;
// 1006A184: using guessed type int dword_1006A184;
// 1006A188: using guessed type __int64 qword_1006A188;
// 1006A190: using guessed type int dword_1006A190;
// 1006A194: using guessed type int dword_1006A194;
// 1006A1A4: using guessed type int dword_1006A1A4;
// 1006A1A8: using guessed type int dword_1006A1A8;
// 1006A1AC: using guessed type int dword_1006A1AC;
// 1006A1B0: using guessed type int dword_1006A1B0;
// 1006A1B4: using guessed type int dword_1006A1B4;
// 1006A1B8: using guessed type int dword_1006A1B8;
// 1006A1BC: using guessed type int dword_1006A1BC;
// 1006A1C0: using guessed type int dword_1006A1C0;
// 1006A1D0: using guessed type int dword_1006A1D0;
// 1006A1D4: using guessed type int dword_1006A1D4;
// 1006A1D8: using guessed type int dword_1006A1D8;
// 1006A1DC: using guessed type int dword_1006A1DC;
// 1006A1E0: using guessed type int dword_1006A1E0;
// 1006A1E4: using guessed type int dword_1006A1E4;
// 1006A1E8: using guessed type int dword_1006A1E8;
// 1006A1F0: using guessed type int dword_1006A1F0;
// 1006A2F8: using guessed type int dword_1006A2F8;
// 1006A300: using guessed type int dword_1006A300;
// 1006A304: using guessed type int dword_1006A304;
// 1006A308: using guessed type int dword_1006A308;

//----- (10015F20) --------------------------------------------------------
int __usercall sub_10015F20<eax>(int a1<ebx>)
{
  int v1; // ecx@4
  int v2; // esi@7
  int result; // eax@17
  char v18; // [sp+Ch] [bp-1Ch]@5
  int *v19; // [sp+18h] [bp-10h]@1
  int v20; // [sp+24h] [bp-4h]@1

  v19 = &dword_1006A110;
  v20 = 9;
  if ( dword_1006A300 )
  {
    (**(void (__stdcall ***)(_DWORD))dword_1006A300)(1);
    dword_1006A300 = 0;
  }
  if ( dword_1006A1E8 )
  {
    v1 = dword_1006A304;
    if ( !dword_1006A304 )
    {
      sub_10024934((int)&v18, (unsigned int)"wait() cannot be called on a default constructed task.");
      sub_1002D02B((int)&v18, (int)&unk_100614E0);
    }
    sub_10020140(v1, a1);
  }
  LOBYTE(v20) = 8;
  nullsub_2(&unk_1006A30C);
  LOBYTE(v20) = 7;
  v2 = dword_1006A308;
  if ( dword_1006A308 )
  {
    _EDI = -1;
    _ECX = dword_1006A308 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v2)(v2);
      _EAX = v2 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 4))(v2);
    }
  }
  LOBYTE(v20) = 6;
  if ( dword_1006A300 )
    (**(void (__stdcall ***)(_DWORD))dword_1006A300)(1);
  LOBYTE(v20) = 5;
  sub_100170C0((int)&dword_1006A1F0, a1);
  if ( dword_1006A1D8 )
  {
    sub_1002404A((LPVOID)dword_1006A1D8);
    dword_1006A1D8 = 0;
    dword_1006A1DC = 0;
    dword_1006A1E0 = 0;
  }
  if ( (unsigned int)dword_1006A1D4 >= 0x10 )
    sub_1002404A((LPVOID)dword_1006A1C0);
  result = dword_1006A1AC;
  dword_1006A1D4 = 15;
  dword_1006A1D0 = 0;
  LOBYTE(dword_1006A1C0) = 0;
  if ( dword_1006A1AC )
  {
    result = sub_1002404A((LPVOID)dword_1006A1AC);
    dword_1006A1AC = 0;
    dword_1006A1B0 = 0;
    dword_1006A1B4 = 0;
  }
  if ( (unsigned int)dword_1006A1A8 >= 0x10 )
    result = sub_1002404A((LPVOID)dword_1006A194);
  dword_1006A1A8 = 15;
  dword_1006A1A4 = 0;
  LOBYTE(dword_1006A194) = 0;
  if ( (unsigned int)dword_1006A17C >= 0x10 )
    result = sub_1002404A((LPVOID)dword_1006A168);
  dword_1006A17C = 15;
  dword_1006A178 = 0;
  LOBYTE(dword_1006A168) = 0;
  if ( (unsigned int)dword_1006A154 >= 0x10 )
    result = sub_1002404A((LPVOID)dword_1006A140);
  dword_1006A154 = 15;
  dword_1006A150 = 0;
  LOBYTE(dword_1006A140) = 0;
  if ( (unsigned int)dword_1006A13C >= 0x10 )
    result = sub_1002404A((LPVOID)dword_1006A128);
  dword_1006A13C = 15;
  dword_1006A138 = 0;
  LOBYTE(dword_1006A128) = 0;
  if ( (unsigned int)dword_1006A124 >= 0x10 )
    result = sub_1002404A((LPVOID)dword_1006A110);
  dword_1006A124 = 15;
  dword_1006A120 = 0;
  LOBYTE(dword_1006A110) = 0;
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10024CC5: using guessed type int __thiscall nullsub_2(_DWORD);
// 1006A110: using guessed type int dword_1006A110;
// 1006A120: using guessed type int dword_1006A120;
// 1006A124: using guessed type int dword_1006A124;
// 1006A128: using guessed type int dword_1006A128;
// 1006A138: using guessed type int dword_1006A138;
// 1006A13C: using guessed type int dword_1006A13C;
// 1006A140: using guessed type int dword_1006A140;
// 1006A150: using guessed type int dword_1006A150;
// 1006A154: using guessed type int dword_1006A154;
// 1006A168: using guessed type int dword_1006A168;
// 1006A178: using guessed type int dword_1006A178;
// 1006A17C: using guessed type int dword_1006A17C;
// 1006A194: using guessed type int dword_1006A194;
// 1006A1A4: using guessed type int dword_1006A1A4;
// 1006A1A8: using guessed type int dword_1006A1A8;
// 1006A1AC: using guessed type int dword_1006A1AC;
// 1006A1B0: using guessed type int dword_1006A1B0;
// 1006A1B4: using guessed type int dword_1006A1B4;
// 1006A1C0: using guessed type int dword_1006A1C0;
// 1006A1D0: using guessed type int dword_1006A1D0;
// 1006A1D4: using guessed type int dword_1006A1D4;
// 1006A1D8: using guessed type int dword_1006A1D8;
// 1006A1DC: using guessed type int dword_1006A1DC;
// 1006A1E0: using guessed type int dword_1006A1E0;
// 1006A1E8: using guessed type int dword_1006A1E8;
// 1006A1F0: using guessed type int dword_1006A1F0;
// 1006A300: using guessed type int dword_1006A300;
// 1006A304: using guessed type int dword_1006A304;
// 1006A308: using guessed type int dword_1006A308;

//----- (100161B0) --------------------------------------------------------
void __stdcall sub_100161B0(int a1, int a2, void *a3, int a4, int a5, int a6, unsigned int a7, signed int a8, void *a9, int a10, int a11, int a12, int a13, signed int a14, void *a15, int a16, int a17, int a18, unsigned int a19, unsigned int a20)
{
  int v20; // edx@1
  int ebp0; // ebp@0
  int v22; // edi@1
  unsigned int v23; // esi@1
  int v24; // ecx@3
  unsigned int v25; // eax@5
  char v26; // zf@7
  int v27; // eax@7
  bool v28; // eax@9
  int v29; // edx@13
  int v30; // edi@13
  unsigned int v31; // esi@13
  int v32; // ecx@15
  unsigned int v33; // eax@17
  char v34; // zf@19
  int v35; // eax@19
  bool v36; // eax@21
  unsigned int v37; // [sp-4h] [bp-40h]@1
  int v38; // [sp+Ch] [bp-30h]@30
  unsigned int v39; // [sp+2Ch] [bp-10h]@1
  int v40; // [sp+38h] [bp-4h]@1
  int v41; // [sp+3Ch] [bp+0h]@1

  v39 = (unsigned int)&v41 ^ __security_cookie;
  v37 = (unsigned int)&v41 ^ __security_cookie;
  v40 = 2;
  sub_1002426D(ebp0, (int)&unk_1006A30C);
  LOBYTE(v40) = 3;
  v23 = a19;
  v22 = dword_1006A120;
  v20 = (int)&a15;
  if ( a20 >= 0x10 )
    v20 = (int)a15;
  v24 = (int)&dword_1006A110;
  if ( (unsigned int)dword_1006A124 >= 0x10 )
    v24 = dword_1006A110;
  v25 = a19;
  if ( dword_1006A120 < a19 )
    v25 = dword_1006A120;
  v27 = sub_10002720(v24, v20, v25);
  v26 = v27 == 0;
  if ( !v27 )
  {
    if ( v22 >= v23 )
      v28 = v22 != v23;
    else
      v28 = -1;
    v26 = v28 == 0;
  }
  if ( !v26 )
    goto LABEL_39;
  v31 = a7;
  v30 = dword_1006A138;
  v29 = (int)&a3;
  if ( (unsigned int)a8 >= 0x10 )
    v29 = (int)a3;
  v32 = (int)&dword_1006A128;
  if ( (unsigned int)dword_1006A13C >= 0x10 )
    v32 = dword_1006A128;
  v33 = a7;
  if ( dword_1006A138 < a7 )
    v33 = dword_1006A138;
  v35 = sub_10002720(v32, v29, v33);
  v34 = v35 == 0;
  if ( !v35 )
  {
    if ( v30 >= v31 )
      v36 = v30 != v31;
    else
      v36 = -1;
    v34 = v36 == 0;
  }
  if ( v34
    && sub_100026D0((int)&dword_1006A140, (int)&a9)
    && dword_1006A158 == a1
    && dword_1006A15C == a2
    && dword_1006A180 & 1 )
  {
    LOBYTE(v40) = 2;
    sub_100242C1();
  }
  else
  {
LABEL_39:
    loc_10001D10(&dword_1006A110, &a15, 0, -1, v37);
    loc_10001D10(&dword_1006A128, &a3, 0, -1);
    loc_10001D10(&dword_1006A140, &a9, 0, -1);
    dword_1006A158 = a1;
    dword_1006A15C = a2;
    LOBYTE(v40) = 2;
    sub_100242C1();
    v38 = 1;
    sub_1001B980((int)&v38, (int)&dword_1006A1F0, a2);
  }
  if ( (unsigned int)a8 >= 0x10 )
    sub_1002404A(a3);
  a8 = 15;
  a7 = 0;
  LOBYTE(a3) = 0;
  if ( (unsigned int)a14 >= 0x10 )
    sub_1002404A(a9);
  a14 = 15;
  a13 = 0;
  LOBYTE(a9) = 0;
  if ( a20 >= 0x10 )
    sub_1002404A(a15);
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;
// 1006A110: using guessed type int dword_1006A110;
// 1006A120: using guessed type int dword_1006A120;
// 1006A124: using guessed type int dword_1006A124;
// 1006A128: using guessed type int dword_1006A128;
// 1006A138: using guessed type int dword_1006A138;
// 1006A13C: using guessed type int dword_1006A13C;
// 1006A140: using guessed type int dword_1006A140;
// 1006A158: using guessed type int dword_1006A158;
// 1006A15C: using guessed type int dword_1006A15C;
// 1006A180: using guessed type int dword_1006A180;
// 1006A1F0: using guessed type int dword_1006A1F0;

//----- (100163C0) --------------------------------------------------------
int __userpurge sub_100163C0<eax>(int a1<ebx>, char a2)
{
  int ebp0; // ebp@0
  int v3; // ecx@4
  char v5; // [sp+0h] [bp-38h]@5
  unsigned int v6; // [sp+28h] [bp-10h]@1
  int v7; // [sp+34h] [bp-4h]@4
  int v8; // [sp+38h] [bp+0h]@1

  v6 = (unsigned int)&v8 ^ __security_cookie;
  if ( !a2 && dword_1006A1E8 || dword_1006A1E8 == 1 )
  {
    sub_1002426D(ebp0, (int)&unk_1006A30C);
    v7 = 0;
    v3 = dword_1006A304;
    if ( !dword_1006A304 )
    {
      sub_10024934((int)&v5, (unsigned int)"wait() cannot be called on a default constructed task.");
      sub_1002D02B((int)&v5, (int)&unk_100614E0);
    }
    sub_10020140(v3, a1);
    v7 = -1;
    sub_100242C1();
  }
  return dword_1006A180;
}
// 10067210: using guessed type int __security_cookie;
// 1006A180: using guessed type int dword_1006A180;
// 1006A1E8: using guessed type int dword_1006A1E8;
// 1006A304: using guessed type int dword_1006A304;

//----- (10016470) --------------------------------------------------------
void __userpurge sub_10016470(int a1<ecx>, int a2<ebx>, int a3)
{
  int ebp0; // ebp@0
  int v4; // esi@1
  int v5; // ecx@2
  int v6; // eax@5
  int v7; // eax@5
  int v8; // edx@5
  int v10; // esi@7
  int v25; // esi@11
  int v39; // [sp+Ch] [bp-48h]@1
  char v40; // [sp+10h] [bp-44h]@3
  int v41; // [sp+14h] [bp-40h]@11
  char v42; // [sp+1Ch] [bp-38h]@5
  int v43; // [sp+20h] [bp-34h]@7
  unsigned int v44; // [sp+40h] [bp-14h]@1
  int v45; // [sp+50h] [bp-4h]@1

  v44 = (unsigned int)&v39 ^ __security_cookie;
  v4 = a1;
  sub_1002426D(ebp0, a1 + 508);
  v45 = 0;
  if ( *(_DWORD *)(v4 + 216) )
  {
    v5 = *(_DWORD *)(v4 + 500);
    if ( !v5 )
    {
      sub_10024934((int)&v40, (unsigned int)"wait() cannot be called on a default constructed task.");
      sub_1002D02B((int)&v40, (int)&unk_100614E0);
    }
    sub_10020140(v5, a2);
  }
  *(_DWORD *)(v4 + 216) = a3;
  v7 = sub_10016760((void *)v4, (int)&v40);
  LOBYTE(v45) = 1;
  v39 = v4;
  v6 = sub_1001A370(v7, v8, (int)&v42, (int)&v39);
  if ( v4 + 500 != v6 )
    sub_1001FFE0((void *)(v4 + 500), v6);
  v10 = v43;
  _EDI = -1;
  if ( v43 )
  {
    _EAX = v43 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v10)(v10);
      _EAX = v10 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v10 + 4))(v10, _EDX);
    }
  }
  LOBYTE(v45) = 0;
  v25 = v41;
  if ( v41 )
  {
    _EAX = v41 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v25)(v25);
      _EAX = v25 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v25 + 4))(v25);
    }
  }
  v45 = -1;
  sub_100242C1();
}
// 10067210: using guessed type int __security_cookie;

//----- (100165D0) --------------------------------------------------------
BOOL __userpurge sub_100165D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // eax@2
  int v9; // ST0C_4@2
  int v10; // edi@2
  int v11; // edx@2
  int v12; // ST08_4@2
  int v13; // ST0C_4@2
  int v14; // ST10_4@2
  int v15; // ecx@4
  int v16; // esi@4
  BOOL result; // eax@8
  int v18; // ecx@8
  int v19; // [sp+14h] [bp-14h]@1
  int v20; // [sp+18h] [bp-10h]@2
  int v21; // [sp+24h] [bp-4h]@1

  v7 = a2;
  v19 = a2;
  v4 = sub_10027EB3(a1, a2, a3, a2, 264);
  v6 = v4;
  v21 = 0;
  if ( v4 )
  {
    sub_100166D0(v4, v5);
    v8 = *(_DWORD *)v7;
    v9 = *(_DWORD *)(*(_DWORD *)v7 + 116);
    v20 = 2;
    v10 = v8 + 224;
    sub_10028CC1(v6, v9, 0);
    sub_10019660(v11, v6 + 16, v6);
    LOBYTE(v21) = 2;
    *(_DWORD *)v6 = &off_1005D068;
    *(_DWORD *)(v6 + 16) = &off_1005D010;
    sub_100195C0(v6, (int)&v20, v10, v12, v13, v14);
    v7 = v19;
  }
  else
  {
    v6 = 0;
  }
  v21 = -1;
  v16 = *(_DWORD *)v7;
  v15 = *(_DWORD *)(*(_DWORD *)v7 + 496);
  if ( v6 != v15 )
  {
    if ( v15 )
      (**(void (__stdcall ***)(_DWORD))v15)(1);
    *(_DWORD *)(v16 + 496) = v6;
  }
  v18 = *(_DWORD *)(*(_DWORD *)v7 + 496);
  result = *(_DWORD *)(v18 + 244);
  if ( !result || result == 2 )
  {
    *(_DWORD *)(v18 + 244) = 1;
    result = sub_10028D1F((char *)v18);
  }
  return result;
}
// 1005D010: using guessed type int (*off_1005D010)();
// 1005D068: using guessed type int (__stdcall *off_1005D068)(char);

//----- (100166D0) --------------------------------------------------------
void __thiscall sub_100166D0(int this, int a2)
{
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 88) = 0;
  *(_DWORD *)(this + 92) = 0;
  *(_DWORD *)(this + 100) = 0;
  *(_DWORD *)(this + 104) = 0;
  *(_DWORD *)(this + 136) = 0;
  *(_DWORD *)(this + 160) = 0;
  *(_DWORD *)(this + 184) = 0;
  *(_DWORD *)(this + 216) = 0;
  *(_DWORD *)(this + 220) = 0;
  *(_DWORD *)(this + 240) = 0;
  *(_DWORD *)(this + 256) = 0;
}

//----- (10016760) --------------------------------------------------------
int __thiscall sub_10016760(void *this, int a2)
{
  int *v2; // ecx@1
  int *v4; // ecx@3
  int v5; // eax@3
  int v6; // edx@3
  int v7; // edx@3
  int v8; // eax@5
  int v9; // edx@5
  int v10; // edx@5
  char v11; // cf@5
  int v12; // ecx@6
  int v13; // edx@8
  int v14; // ecx@8
  int v15; // eax@8
  int v16; // edx@8
  int v17; // edx@8
  char v18; // cf@8
  int v19; // edx@10
  int v20; // ecx@10
  int v21; // eax@10
  int v22; // edx@10
  int v23; // edx@10
  char v24; // cf@10
  __int64 v25; // qax@12
  int v26; // eax@12
  int v27; // edx@12
  int v28; // edx@12
  __int64 v29; // qax@12
  int v30; // eax@12
  int v31; // edx@12
  __int64 v32; // qax@12
  int v37; // edx@15
  int v38; // ecx@15
  char v39; // cf@15
  int v40; // edx@17
  int v41; // esi@18
  int v42; // eax@18
  int v43; // edx@18
  int v44; // edx@18
  int v45; // edx@18
  __int16 v61; // [sp-28h] [bp-90h]@18
  int v62; // [sp-24h] [bp-8Ch]@18
  int v63; // [sp-20h] [bp-88h]@18
  int v64; // [sp-1Ch] [bp-84h]@18
  int v65; // [sp-18h] [bp-80h]@18
  signed int v66; // [sp-14h] [bp-7Ch]@18
  char v67; // [sp-10h] [bp-78h]@18
  int v68; // [sp-Ch] [bp-74h]@3
  unsigned int v69; // [sp-4h] [bp-6Ch]@1
  int v70; // [sp+Ch] [bp-5Ch]@18
  DWORD v71; // [sp+14h] [bp-54h]@18
  int v72; // [sp+18h] [bp-50h]@18
  int v73; // [sp+1Ch] [bp-4Ch]@1
  char *v74; // [sp+20h] [bp-48h]@18
  int v75; // [sp+28h] [bp-40h]@1
  int v76; // [sp+2Ch] [bp-3Ch]@18
  int v77; // [sp+30h] [bp-38h]@18
  char v78; // [sp+34h] [bp-34h]@3
  int v79; // [sp+3Ch] [bp-2Ch]@1
  int v80; // [sp+40h] [bp-28h]@1
  __int64 v81; // [sp+44h] [bp-24h]@3
  int v82; // [sp+4Ch] [bp-1Ch]@3
  int v83; // [sp+50h] [bp-18h]@3
  unsigned int v84; // [sp+54h] [bp-14h]@1
  int v85; // [sp+64h] [bp-4h]@1
  int v86; // [sp+68h] [bp+0h]@1

  v84 = (unsigned int)&v86 ^ __security_cookie;
  v69 = (unsigned int)&v86 ^ __security_cookie;
  _ESI = (int)this;
  v75 = 0;
  v79 &= 0xFFFFFE00u;
  v73 = a2;
  v80 = 0;
  v85 = 2;
  v2 = &dword_10068E48;
  if ( (unsigned int)dword_10068E5C >= 0x10 )
    v2 = (int *)dword_10068E48;
  v82 = v82 & 0xFFFFFF04 | 0x104;
  v83 = 0;
  LODWORD(v81) = loc_10004C50(v2, dword_10068E58, v69);
  LOBYTE(v85) = 3;
  v5 = sub_10005A20((int)&v78, v6, (int)"name", v68);
  sub_10004FF0(v5, v7, (int)&v81);
  LOBYTE(v85) = 2;
  sub_10004F60((int)&v81, a2);
  v4 = &dword_10068E78;
  if ( (unsigned int)dword_10068E8C >= 0x10 )
    v4 = (int *)dword_10068E78;
  v82 = v82 & 0xFFFFFF04 | 0x104;
  v83 = 0;
  LODWORD(v81) = loc_10004C50(v4, dword_10068E88);
  LOBYTE(v85) = 4;
  v8 = sub_10005A20((int)&v78, v9, (int)"version", v68);
  sub_10004FF0(v8, v10, (int)&v81);
  LOBYTE(v85) = 2;
  sub_10004F60((int)&v81, a2);
  v11 = *(_DWORD *)(_ESI + 20) < 0x10u;
  v82 = v82 & 0xFFFFFF04 | 0x104;
  v83 = 0;
  if ( v11 )
    v12 = _ESI;
  else
    v12 = *(_DWORD *)_ESI;
  LODWORD(v81) = loc_10004C50(v12, *(_DWORD *)(_ESI + 16));
  LOBYTE(v85) = 5;
  v15 = sub_10005A20((int)&v78, v16, (int)"code", v68);
  sub_10004FF0(v15, v17, (int)&v81);
  LOBYTE(v85) = 2;
  sub_10004F60((int)&v81, a2);
  v13 = *(_DWORD *)(_ESI + 40);
  v14 = _ESI + 24;
  v18 = *(_DWORD *)(_ESI + 44) < 0x10u;
  v82 = v82 & 0xFFFFFF04 | 0x104;
  v83 = 0;
  if ( !v18 )
    v14 = *(_DWORD *)v14;
  LODWORD(v81) = loc_10004C50(v14, v13);
  LOBYTE(v85) = 6;
  v21 = sub_10005A20((int)&v78, v22, (int)"broker", v68);
  sub_10004FF0(v21, v23, (int)&v81);
  LOBYTE(v85) = 2;
  sub_10004F60((int)&v81, a2);
  v19 = *(_DWORD *)(_ESI + 64);
  v20 = _ESI + 48;
  v24 = *(_DWORD *)(_ESI + 68) < 0x10u;
  v82 = v82 & 0xFFFFFF04 | 0x104;
  v83 = 0;
  if ( !v24 )
    v20 = *(_DWORD *)v20;
  LODWORD(v81) = loc_10004C50(v20, v19);
  LOBYTE(v85) = 7;
  v26 = sub_10005A20((int)&v78, v27, (int)"server", v68);
  sub_10004FF0(v26, v28, (int)&v81);
  LOBYTE(v85) = 2;
  sub_10004F60((int)&v81, a2);
  v82 = v82 & 0xFFFFFF01 | 1;
  v29 = *(_DWORD *)(_ESI + 72);
  v83 = 0;
  v81 = v29;
  LOBYTE(v85) = 8;
  v30 = sub_10005A20((int)&v78, SHIDWORD(v29), (int)"account", v68);
  sub_10004FF0(v30, v31, (int)&v81);
  LOBYTE(v85) = 2;
  sub_10004F60((int)&v81, a2);
  v82 = v82 & 0xFFFFFF01 | 1;
  v32 = *(_DWORD *)(_ESI + 76);
  v83 = 0;
  v81 = v32;
  LOBYTE(v85) = 9;
  LODWORD(v25) = sub_10005A20((int)&v78, SHIDWORD(v32), (int)"type", v68);
  sub_10004FF0(v25, SHIDWORD(v25), (int)&v81);
  LOBYTE(v85) = 2;
  sub_10004F60((int)&v81, a2);
  __asm
  {
    movsd   xmm0, qword ptr [esi+50h]
    comisd  xmm0, ds:qword_1005D348
  }
  if ( !_CF )
  {
    v82 = v82 & 0xFFFFFF03 | 3;
    v83 = 0;
    __asm { movsd   [ebp+var_24], xmm0 }
    LOBYTE(v85) = 10;
    LODWORD(v25) = sub_10005A20((int)&v78, SHIDWORD(v25), (int)"balance", v68);
    sub_10004FF0(v25, SHIDWORD(v25), (int)&v81);
    LOBYTE(v85) = 2;
    sub_10004F60((int)&v81, a2);
  }
  if ( *(_DWORD *)(_ESI + 104) )
  {
    v37 = *(_DWORD *)(_ESI + 104);
    v38 = _ESI + 88;
    v39 = *(_DWORD *)(_ESI + 108) < 0x10u;
    v82 = v82 & 0xFFFFFF04 | 0x104;
    v83 = 0;
    if ( !v39 )
      v38 = *(_DWORD *)v38;
    LODWORD(v81) = loc_10004C50(v38, v37);
    LOBYTE(v85) = 11;
    LODWORD(v25) = sub_10005A20((int)&v78, v40, (int)"currency", v68);
    sub_10004FF0(v25, SHIDWORD(v25), (int)&v81);
    LOBYTE(v85) = 2;
    sub_10004F60((int)&v81, a2);
  }
  v82 &= 0xFFFFFE00u;
  v83 = 0;
  LOBYTE(v85) = 13;
  v42 = sub_10005A20((int)&v81, SHIDWORD(v25), (int)"data", v68);
  sub_10004FF0(v42, v43, (int)&v78);
  v74 = &v67;
  v76 = 0;
  v77 = 0;
  sub_10004DA0((int)&v67, v44, (int)&v81);
  LOBYTE(v85) = 14;
  v66 = 7;
  v65 = 0;
  v61 = 0;
  loc_10020810(&dword_10068E60, 0, -1);
  LOBYTE(v85) = 13;
  sub_1001A3B0(*(_DWORD *)&v61, v62, v63, v64, v65, v66, v67);
  LOBYTE(v85) = 15;
  v71 = sub_100225B6();
  v70 = _ESI;
  v72 = v45;
  sub_1001A490(v45, (int)&v76, a2, a2, (int)&v70);
  LOBYTE(v85) = 13;
  v41 = v77;
  v75 = 1;
  if ( v77 )
  {
    _EDI = -1;
    _ECX = v77 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v41)(v41);
      _EAX = v41 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v41 + 4))(v41);
    }
  }
  LOBYTE(v85) = 2;
  sub_10004F60((int)&v81, a2);
  LOBYTE(v85) = 0;
  sub_10004F60((int)&v78, a2);
  return a2;
}
// 1001A3B0: using guessed type _DWORD __cdecl sub_1001A3B0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);
// 10067210: using guessed type int __security_cookie;
// 10068E48: using guessed type int dword_10068E48;
// 10068E58: using guessed type int dword_10068E58;
// 10068E5C: using guessed type int dword_10068E5C;
// 10068E60: using guessed type int dword_10068E60;
// 10068E78: using guessed type int dword_10068E78;
// 10068E88: using guessed type int dword_10068E88;
// 10068E8C: using guessed type int dword_10068E8C;

//----- (10016C00) --------------------------------------------------------
int __thiscall sub_10016C00(void *this, char a2, int a3)
{
  __int64 v3; // qax@1
  int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // eax@1
  int v8; // edx@1
  int v9; // edx@1
  int v10; // eax@2
  __int64 v11; // ST08_8@2
  __int16 v12; // cx@2
  double v13; // ST08_8@2
  double v14; // st7@2
  __int64 v15; // qax@2
  __int64 v16; // ST08_8@2
  int v17; // edx@3
  int v18; // ecx@3
  int v19; // eax@3
  int v20; // eax@3
  int v21; // edx@5
  int v22; // ecx@5
  int v23; // eax@5
  int v24; // eax@5
  int v25; // eax@7
  int v26; // edx@7
  int v27; // ecx@8
  int v28; // eax@8
  int v29; // edx@8
  int v30; // esi@9
  int v31; // eax@9
  double v47; // [sp+8h] [bp-154h]@1
  void *v48; // [sp+64h] [bp-F8h]@3
  unsigned int v49; // [sp+78h] [bp-E4h]@3
  void *v50; // [sp+94h] [bp-C8h]@5
  unsigned int v51; // [sp+A8h] [bp-B4h]@5
  char v52; // [sp+DCh] [bp-80h]@1
  char v53; // [sp+ECh] [bp-70h]@1
  char v54; // [sp+F4h] [bp-68h]@1
  int v55; // [sp+F8h] [bp-64h]@1
  char v56; // [sp+FCh] [bp-60h]@7
  char v57; // [sp+104h] [bp-58h]@7
  int v58; // [sp+108h] [bp-54h]@7
  __int64 v59; // [sp+10Ch] [bp-50h]@1
  int v60; // [sp+114h] [bp-48h]@1
  int v61; // [sp+118h] [bp-44h]@1
  void *v62; // [sp+120h] [bp-3Ch]@1
  double v63; // [sp+124h] [bp-38h]@2
  int v64; // [sp+130h] [bp-2Ch]@1
  char v65; // [sp+134h] [bp-28h]@1
  int v66; // [sp+140h] [bp-1Ch]@1
  unsigned int v67; // [sp+148h] [bp-14h]@1
  double *v68; // [sp+14Ch] [bp-10h]@1
  int v69; // [sp+158h] [bp-4h]@1
  int v70; // [sp+15Ch] [bp+0h]@1

  v67 = (unsigned int)&v70 ^ __security_cookie;
  v68 = (double *)((char *)&v47 + 4);
  v5 = (int)this;
  v62 = this;
  v69 = 0;
  LOBYTE(v69) = 1;
  v64 = 0;
  v66 = 0;
  loc_10018880(&a2, &v65, (unsigned int)&v70 ^ __security_cookie);
  __asm { xorps   xmm0, xmm0 }
  v60 = v60 & 0xFFFFFF02 | 2;
  v61 = 0;
  __asm { movlpd  [ebp+var_50], xmm0 }
  LOBYTE(v69) = 3;
  v7 = sub_10005BD0((int)&v65, v8, (int)&v52, v4, (int)&v59);
  LOBYTE(v69) = 4;
  v6 = loc_10005190(v7);
  LOBYTE(v69) = 3;
  sub_10004F60((int)&v52, v5);
  LOBYTE(v69) = 2;
  sub_10004F60((int)&v59, v5);
  v64 = v6;
  v55 = 0;
  LODWORD(v3) = sub_10005A20((int)&v65, v9, (int)"utc", v4);
  sub_10004DA0((int)&v53, SHIDWORD(v3), v3);
  LOBYTE(v69) = 5;
  if ( v54 )
  {
    v10 = loc_10005190(&v53);
    v11 = 10000000i64;
    *(_QWORD *)&v63 = *(_QWORD *)(v5 + 8) - sub_100315D0((unsigned int)v10, v11);
    v12 = WORD2(v63);
    v63 = (double)*(signed __int64 *)&v63;
    __asm { movsd   xmm0, [ebp+var_38] }
    v63 = (double)9000000000i64;
    __asm
    {
      divsd   xmm0, [ebp+var_38]
      addsd   xmm0, ds:qword_1005D358
      movsd   [ebp+var_38], xmm0
    }
    v13 = v63;
    v14 = sub_1004F850(v12, v5, v13);
    LODWORD(v15) = sub_100446D6(v14);
    v16 = 9000000000i64;
    v3 = sub_100315D0(v15, v16);
    v4 = *(_DWORD *)v5;
    *(_DWORD *)(*(_DWORD *)v5 + 120) = v3;
    *(_DWORD *)(v4 + 124) = HIDWORD(v3);
  }
  v19 = sub_10005A20((int)&v65, SHIDWORD(v3), (int)"msg1", v4);
  v20 = loc_10005070(v19, &v48);
  LOBYTE(v69) = 6;
  sub_1000D4F0((void *)(*(_DWORD *)v5 + 128), v20);
  LOBYTE(v69) = 5;
  if ( v49 >= 0x10 )
    sub_1002404A(v48);
  v23 = sub_10005A20((int)&v65, v17, (int)"msg2", v18);
  v24 = loc_10005070(v23, &v50);
  LOBYTE(v69) = 7;
  sub_1000D4F0((void *)(*(_DWORD *)v5 + 172), v24);
  LOBYTE(v69) = 5;
  if ( v51 >= 0x10 )
    sub_1002404A(v50);
  v58 = 0;
  v25 = sub_10005A20((int)&v65, v21, (int)"auth_interval", v22);
  sub_10004DA0((int)&v56, v26, v25);
  LOBYTE(v69) = 8;
  if ( v57 )
  {
    v27 = loc_100054B0(&v56);
    v28 = *(_DWORD *)v5;
    HIDWORD(v63) = v29;
    *(_DWORD *)(v28 + 116) = v27;
  }
  LOBYTE(v69) = 5;
  sub_10004F60((int)&v56, v5);
  LOBYTE(v69) = 2;
  sub_10004F60((int)&v53, v5);
  LOBYTE(v69) = 1;
  sub_10004F60((int)&v65, v5);
  v31 = *(_DWORD *)v5;
  v69 = -1;
  *(_DWORD *)(v31 + 112) = v6;
  v30 = a3;
  if ( a3 )
  {
    _EBX = -1;
    _ECX = a3 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v30)(v30);
      _EDX = v30 + 8;
      __asm { lock xadd [edx], ebx }
      if ( _EBX == 1 )
        (*(void (**)(void))(*(_DWORD *)v30 + 4))();
    }
  }
  return v6;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (10016F35) --------------------------------------------------------
int (*__usercall sub_10016F35<eax>(int a1<ebp>))()
{
  int v2; // esi@1

  *(_DWORD *)(a1 - 44) |= 0x200000u;
  sub_100019D0(a1 - 176, (const char *)&unk_1005C72F);
  v2 = *(_DWORD *)(a1 - 60);
  *(_BYTE *)(a1 - 4) = 12;
  sub_1000D4F0((void *)(*(_DWORD *)v2 + 128), a1 - 176);
  *(_BYTE *)(a1 - 4) = 9;
  sub_10001A30(a1 - 176);
  sub_100019D0(a1 - 224, (const char *)&unk_1005C72F);
  *(_BYTE *)(a1 - 4) = 13;
  sub_1000D4F0((void *)(*(_DWORD *)v2 + 172), a1 - 224);
  sub_10001A30(a1 - 224);
  return loc_10016FAC;
}
// 10016FAC: using guessed type int loc_10016FAC();

//----- (10016FC3) --------------------------------------------------------
int (__stdcall *__usercall sub_10016FC3<eax>(int a1<ebp>))(char, int)
{
  int v2; // esi@1

  *(_DWORD *)(a1 - 44) |= 0x400000u;
  sub_100019D0(a1 - 272, (const char *)&unk_1005C72F);
  v2 = *(_DWORD *)(a1 - 60);
  *(_BYTE *)(a1 - 4) = 14;
  sub_1000D4F0((void *)(*(_DWORD *)v2 + 128), a1 - 272);
  *(_BYTE *)(a1 - 4) = 9;
  sub_10001A30(a1 - 272);
  sub_100019D0(a1 - 320, (const char *)&unk_1005C72F);
  *(_BYTE *)(a1 - 4) = 15;
  sub_1000D4F0((void *)(*(_DWORD *)v2 + 172), a1 - 320);
  sub_10001A30(a1 - 320);
  return loc_10016ED7;
}
// 10016ED7: using guessed type int __stdcall loc_10016ED7(char, int);

//----- (10017040) --------------------------------------------------------
int __thiscall sub_10017040(int this, char a2, int a3)
{
  int v3; // esi@1
  char v5; // [sp-8h] [bp-20h]@2
  int v6; // [sp-4h] [bp-1Ch]@2
  int v7; // [sp+14h] [bp-4h]@1

  v3 = this;
  v7 = 0;
  if ( *(_DWORD *)(this + 12) != 3 )
  {
    sub_10023441((int)&v5, (int)&a2);
    sub_10018CC0((void *)(v3 + 84), v5, v6);
  }
  v7 = -1;
  return sub_100234E2((int)&a2);
}
// 10023441: using guessed type int __cdecl sub_10023441(int, int);

//----- (100170C0) --------------------------------------------------------
int __usercall sub_100170C0<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // ecx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // eax@1
  int v6; // ecx@3

  v3 = a1;
  *(_DWORD *)a1 = &off_1005D22C;
  v5 = *(_DWORD *)(a1 + 96);
  *(_BYTE *)(a1 + 88) = 1;
  (*(void (**)(void))(v5 + 8))();
  (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 24))(v3);
  v4 = v3 + 248;
  v2 = *(_DWORD *)(v3 + 264);
  if ( v2 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v2 + 16))(v2 != v4);
    *(_DWORD *)(v3 + 264) = 0;
  }
  v6 = *(_DWORD *)(v3 + 264);
  if ( v6 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v6 + 16))(v6 != v4);
    *(_DWORD *)(v3 + 264) = 0;
  }
  return sub_10017430(v3, a2);
}
// 1005D22C: using guessed type int (__stdcall *off_1005D22C)(char);

//----- (10017170) --------------------------------------------------------
signed int __thiscall sub_10017170(void *this, int a2, int a3)
{
  int v3; // eax@1
  void *v4; // esi@1
  signed int result; // eax@2

  v4 = this;
  v3 = (*(int (__stdcall **)(_DWORD, void *))(*(_DWORD *)a3 + 16))(*(_DWORD *)(a2 + 4), this);
  if ( v3 )
  {
    (*(void (__thiscall **)(char *, int))*((void (__thiscall ***)(_DWORD, _DWORD))v4 + 24))((char *)v4 + 96, v3);
    result = 0;
  }
  else
  {
    result = 3;
  }
  return result;
}

//----- (100171B0) --------------------------------------------------------
signed int __thiscall sub_100171B0(void *this, int a2, int a3)
{
  int v3; // eax@1
  void *v4; // esi@1
  signed int result; // eax@2

  v4 = this;
  v3 = (*(int (__stdcall **)(_DWORD, void *))(*(_DWORD *)a3 + 16))(*(_DWORD *)(a2 + 4), this);
  if ( v3 )
  {
    (*(void (__thiscall **)(char *, int))(*((_DWORD *)v4 + 24) + 4))((char *)v4 + 96, v3);
    result = 0;
  }
  else
  {
    result = 3;
  }
  return result;
}

//----- (100171F0) --------------------------------------------------------
char __cdecl sub_100171F0()
{
  return 1;
}

//----- (10017230) --------------------------------------------------------
int __thiscall sub_10017230(int this)
{
  unsigned int v1; // eax@1
  int v2; // edx@1
  unsigned int v3; // ecx@1
  int v4; // esi@1
  int result; // eax@7
  char v6; // [sp+Ch] [bp-1Ch]@6
  int v7; // [sp+18h] [bp-10h]@1
  int v8; // [sp+24h] [bp-4h]@1

  v4 = this;
  v7 = this;
  *(_DWORD *)this = off_1005D208;
  v8 = 0;
  v3 = *(_DWORD *)(this + 12);
  v2 = 0;
  v1 = 0;
  if ( v3 )
  {
    do
    {
      if ( *(_DWORD *)(*(_DWORD *)(v4 + 8) + 4 * v1) )
        ++v2;
      ++v1;
    }
    while ( v1 < v3 );
    if ( v2 )
    {
      sub_10024934((int)&v6, (unsigned int)"Deleting link registry before removing all the links");
      sub_1002D02B((int)&v6, (int)&unk_100614E0);
    }
  }
  result = *(_DWORD *)(v4 + 8);
  if ( result )
  {
    result = sub_1002401B(*(LPVOID *)(v4 + 8));
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
  }
  return result;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1005D208: using guessed type int (__stdcall *off_1005D208[3])(int);

//----- (100172E0) --------------------------------------------------------
int __stdcall sub_100172E0(int a1)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
    JUMPOUT(loc_10018D70);
  return result;
}

//----- (10017300) --------------------------------------------------------
char __thiscall sub_10017300(int this, int a2)
{
  char result; // al@2

  if ( a2 )
    result = sub_10018E20(this, a2);
  else
    result = 0;
  return result;
}

//----- (10017320) --------------------------------------------------------
char __thiscall sub_10017320(void *this, int a2)
{
  bool v2; // eax@2

  if ( a2 )
    v2 = (unsigned int)(*(int (__stdcall **)(int))(*(_DWORD *)this + 32))(a2) < *((_DWORD *)this + 3);
  else
    LOBYTE(v2) = 0;
  return v2;
}

//----- (10017350) --------------------------------------------------------
int __thiscall sub_10017350(int this)
{
  int result; // eax@1
  int v2; // edx@1
  int v3; // ecx@2

  v2 = *(_DWORD *)(this + 12);
  result = 0;
  if ( v2 )
  {
    v3 = *(_DWORD *)(this + 8);
    do
    {
      if ( *(_DWORD *)v3 )
        ++result;
      v3 += 4;
      --v2;
    }
    while ( v2 );
  }
  return result;
}

//----- (10017370) --------------------------------------------------------
int __thiscall sub_10017370(void *this, int a2)
{
  *(_DWORD *)a2 = this;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  (*(void (__stdcall **)(int))(*(_DWORD *)this + 20))(a2 + 4);
  return a2;
}

//----- (100173A0) --------------------------------------------------------
int __thiscall sub_100173A0(int this, int a2)
{
  int v2; // edi@1
  unsigned int v3; // esi@1
  int result; // eax@2
  int v5; // ecx@2

  v2 = this;
  v3 = *(_DWORD *)(this + 12);
  if ( *(_DWORD *)a2 < v3 )
  {
    do
    {
      v5 = *(_DWORD *)a2;
      result = *(_DWORD *)(v2 + 8);
      if ( *(_DWORD *)(result + 4 * *(_DWORD *)a2) )
        break;
      result = v5 + 1;
      *(_DWORD *)a2 = v5 + 1;
    }
    while ( v5 + 1 < v3 );
  }
  return result;
}

//----- (100173D0) --------------------------------------------------------
int __thiscall sub_100173D0(int this, unsigned int a2)
{
  int result; // eax@2

  if ( a2 >= *(_DWORD *)(this + 12) )
    result = 0;
  else
    result = *(_DWORD *)(*(_DWORD *)(this + 8) + 4 * a2);
  return result;
}

//----- (100173F0) --------------------------------------------------------
unsigned int __thiscall sub_100173F0(int this, int a2)
{
  unsigned int result; // eax@1
  unsigned int v3; // edx@1
  int v4; // ecx@2

  v3 = *(_DWORD *)(this + 12);
  result = 0;
  if ( v3 )
  {
    v4 = *(_DWORD *)(this + 8);
    do
    {
      if ( *(_DWORD *)v4 == a2 )
        break;
      ++result;
      v4 += 4;
    }
    while ( result < v3 );
  }
  return result;
}

//----- (10017430) --------------------------------------------------------
int __usercall sub_10017430<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // edi@1
  int v3; // esi@1
  int v4; // ecx@2
  int v5; // ecx@4
  int v6; // ST0C_4@7
  int v7; // ST10_4@7
  int result; // eax@9

  v2 = a1;
  *(_DWORD *)a1 = &off_1005D17C;
  v3 = *(_DWORD *)(a1 + 84);
  if ( v3 )
  {
    v4 = *(_DWORD *)(v3 + 16);
    if ( v4 )
    {
      (*(void (__stdcall **)(bool))(*(_DWORD *)v4 + 16))(v4 != v3);
      *(_DWORD *)(v3 + 16) = 0;
    }
    v5 = *(_DWORD *)(v3 + 16);
    if ( v5 )
    {
      (*(void (__stdcall **)(bool))(*(_DWORD *)v5 + 16))(v5 != v3);
      *(_DWORD *)(v3 + 16) = 0;
    }
    sub_1002404A((LPVOID)v3);
  }
  sub_10028B89(a2, v2, 3, v2, (unsigned __int64)v2 >> 32, v6, v7);
  sub_100178D0((void *)(v2 + 96), a2);
  sub_10017230(v2 + 60);
  if ( *(_DWORD *)(v2 + 48) )
  {
    sub_1002401B(*(LPVOID *)(v2 + 48));
    *(_DWORD *)(v2 + 48) = 0;
    *(_DWORD *)(v2 + 52) = 0;
    *(_DWORD *)(v2 + 56) = 0;
  }
  result = nullsub_2(v2 + 4);
  *(_DWORD *)v2 = &off_1005D0EC;
  return result;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10024CC5: using guessed type int __thiscall nullsub_2(_DWORD);
// 1005D0EC: using guessed type int (__stdcall *off_1005D0EC)(char);
// 1005D17C: using guessed type int (__stdcall *off_1005D17C)(char);

//----- (100176B0) --------------------------------------------------------
signed int __stdcall sub_100176B0(int a1, int a2)
{
  return 1;
}

//----- (100176C0) --------------------------------------------------------
int __thiscall sub_100176C0(void *this, int a2)
{
  int v2; // ebx@1
  int ebp0; // ebp@0
  int v4; // esi@1
  char v6; // [sp+Ch] [bp-2Ch]@2
  unsigned int v7; // [sp+28h] [bp-10h]@1
  int v8; // [sp+34h] [bp-4h]@2
  int v9; // [sp+38h] [bp+0h]@1

  v7 = (unsigned int)&v9 ^ __security_cookie;
  v2 = (int)this;
  v4 = (int)((char *)this + 4);
  if ( a2 )
  {
    sub_100241EF(ebp0, (int)((char *)this + 4));
    v8 = 0;
    (**(void (__stdcall ***)(_DWORD))(v4 + 56))(a2);
    ++*(_DWORD *)(v4 + 40);
    v8 = -1;
    sub_100242BA(&v6);
    (*(void (__thiscall **)(int, _DWORD))(*(_DWORD *)a2 + 32))(a2, *(_DWORD *)(v2 + 80));
    sub_10019AE0(v2 + 4);
  }
  return sub_10028B89(v2, a2, 5, a2, (unsigned __int64)a2 >> 32, v2, (unsigned __int64)v2 >> 32);
}
// 10067210: using guessed type int __security_cookie;

//----- (10017770) --------------------------------------------------------
char __userpurge sub_10017770<al>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // edi@1

  v4 = a1;
  sub_10028B89(a2, a1, 6, a3, (unsigned __int64)a3 >> 32, a1, (unsigned __int64)a1 >> 32);
  return sub_10019160(v4 + 4, a3);
}

//----- (100177A0) --------------------------------------------------------
void __thiscall sub_100177A0(void *this)
{
  int v1; // eax@1
  void *v2; // edi@1
  void *v3; // ecx@2
  int v4; // esi@2
  int (__stdcall **v5)(char); // [sp+8h] [bp-2Ch]@1
  void *v6; // [sp+Ch] [bp-28h]@1
  unsigned int v7; // [sp+10h] [bp-24h]@2
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  unsigned int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+30h] [bp-4h]@1
  int v13; // [sp+34h] [bp+0h]@1

  v11 = (unsigned int)&v13 ^ __security_cookie;
  v2 = this;
  v6 = 0;
  v8 = 0;
  v10 = 0;
  sub_10019240((int)((char *)this + 4), (int)&v5);
  v12 = 0;
  v1 = v9;
  while ( 1 )
  {
    v3 = v6;
    v4 = (int)&v10;
    if ( v1 < v7 )
      v4 = (int)((char *)v6 + 4 * v1);
    if ( !*(_DWORD *)v4 )
      break;
    if ( v1 < v7 )
    {
      (*(void (__stdcall **)(void *))(**((_DWORD **)v6 + v1) + 8))(v2);
      v1 = v9++ + 1;
    }
    else
    {
      (*(void (__stdcall **)(void *))(*(_DWORD *)v10 + 8))(v2);
      v1 = v9++ + 1;
    }
  }
  v5 = &off_1005CE74;
  v12 = 1;
  if ( v8 )
  {
    sub_10019AE0(v8);
    v3 = v6;
  }
  if ( v3 )
    sub_1002401B(v3);
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1005CE74: using guessed type int (__stdcall *off_1005CE74)(char);
// 10067210: using guessed type int __security_cookie;

//----- (100178C0) --------------------------------------------------------
char __cdecl sub_100178C0()
{
  return 0;
}

//----- (100178D0) --------------------------------------------------------
void __usercall sub_100178D0(void *a1<ecx>, int a2<ebx>)
{
  int v2; // ecx@1
  int v3; // edi@1
  void *v4; // esi@1
  int v5; // ecx@3
  int v6; // ecx@5
  int v7; // edi@5
  int v8; // ecx@7
  int v9; // ecx@9
  int v10; // edi@9
  int v11; // ecx@11

  v4 = a1;
  *(_DWORD *)a1 = &off_1005D0D4;
  sub_10017BE0(a1);
  v3 = (int)((char *)v4 + 128);
  v2 = *((_DWORD *)v4 + 36);
  if ( v2 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v2 + 16))(v2 != v3);
    *((_DWORD *)v4 + 36) = 0;
  }
  v5 = *((_DWORD *)v4 + 36);
  if ( v5 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v5 + 16))(v5 != v3);
    *((_DWORD *)v4 + 36) = 0;
  }
  v7 = (int)((char *)v4 + 104);
  v6 = *((_DWORD *)v4 + 30);
  if ( v6 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v6 + 16))(v6 != v7);
    *((_DWORD *)v4 + 30) = 0;
  }
  v8 = *((_DWORD *)v4 + 30);
  if ( v8 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v8 + 16))(v8 != v7);
    *((_DWORD *)v4 + 30) = 0;
  }
  v10 = (int)((char *)v4 + 80);
  v9 = *((_DWORD *)v4 + 24);
  if ( v9 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v9 + 16))(v9 != v10);
    *((_DWORD *)v4 + 24) = 0;
  }
  v11 = *((_DWORD *)v4 + 24);
  if ( v11 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v11 + 16))(v11 != v10);
    *((_DWORD *)v4 + 24) = 0;
  }
  nullsub_2((char *)v4 + 24);
  sub_1001A2F0((int)((char *)v4 + 4), a2);
}
// 10024CC5: using guessed type int __thiscall nullsub_2(_DWORD);
// 1005D0D4: using guessed type void *off_1005D0D4;

//----- (10017A00) --------------------------------------------------------
void __thiscall sub_10017A00(int this, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // esi@1
  int v5; // ecx@2
  int v6; // ecx@4
  int v7; // ecx@11
  int v8; // ecx@13
  int v9; // eax@15
  int v10; // [sp-4h] [bp-10h]@7

  v3 = this;
  v4 = this + 104;
  if ( this + 104 != a2 )
  {
    v5 = *(_DWORD *)(this + 120);
    if ( v5 )
    {
      (*(void (__stdcall **)(bool))(*(_DWORD *)v5 + 16))(v5 != v4);
      *(_DWORD *)(v4 + 16) = 0;
    }
    v6 = *(_DWORD *)(a2 + 16);
    if ( v6 )
    {
      if ( v6 == a2 )
        v10 = v4;
      else
        v10 = 0;
      *(_DWORD *)(v4 + 16) = (**(int (__stdcall ***)(_DWORD))v6)(v10);
    }
    else
    {
      *(_DWORD *)(v4 + 16) = 0;
    }
  }
  if ( v3 + 128 != a3 )
  {
    v7 = *(_DWORD *)(v3 + 144);
    if ( v7 )
    {
      (*(void (__stdcall **)(bool))(*(_DWORD *)v7 + 16))(v7 != v3 + 128);
      *(_DWORD *)(v3 + 144) = 0;
    }
    v8 = *(_DWORD *)(a3 + 16);
    if ( v8 )
    {
      v9 = *(_DWORD *)v8;
      if ( v8 == a3 )
        *(_DWORD *)(v3 + 144) = (*(int (__stdcall **)(int))v9)(v3 + 128);
      else
        *(_DWORD *)(v3 + 144) = (*(int (__stdcall **)(_DWORD))v9)(0);
    }
    else
    {
      *(_DWORD *)(v3 + 144) = 0;
    }
  }
}

//----- (10017BE0) --------------------------------------------------------
void __thiscall sub_10017BE0(void *this)
{
  int ebp0; // ebp@0
  void *v2; // esi@1
  char v10; // zf@1
  char v11; // [sp+8h] [bp-44h]@1
  char v12; // [sp+Ch] [bp-40h]@2
  int v13; // [sp+14h] [bp-38h]@1
  int (__usercall *v14)<eax>(int<ebx>, int<ebp>, int<edi>); // [sp+18h] [bp-34h]@1
  unsigned int v15; // [sp+38h] [bp-14h]@1
  int v16; // [sp+48h] [bp-4h]@3

  v15 = (unsigned int)&v11 ^ __security_cookie;
  v2 = this;
  _EAX = (int)((char *)this + 68);
  _ECX = 1;
  __asm { lock xadd [eax], ecx }
  v10 = *((_DWORD *)v2 + 18) == 0;
  v13 = 0;
  v14 = sub_10028CB5;
  if ( !v10 )
  {
    do
      sub_1001FF20((int)&v12);
    while ( *((_DWORD *)v2 + 18) );
  }
  sub_100241AA(ebp0, (int)((char *)v2 + 24));
  v16 = 0;
  sub_100192C0(v2);
  v16 = -1;
  sub_100242C1();
}
// 10067210: using guessed type int __security_cookie;

//----- (10017CA0) --------------------------------------------------------
int __fastcall sub_10017CA0(int a1)
{
  int result; // eax@1
  int v2; // ebx@1
  __int64 v3; // qdi@1
  int v4; // ST10_4@1
  int v5; // ST14_4@1
  int v6; // eax@1
  int v7; // ST10_4@1

  v2 = a1;
  v3 = a1;
  sub_10028B89(a1, a1, 1, a1, (unsigned __int64)a1 >> 32, v4, v5);
  v6 = loc_100193C0(v2);
  sub_10028B89(v2, v3, 2, v3, SHIDWORD(v3), v6, v7);
  result = v2 + 72;
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  return result;
}

//----- (10017CE0) --------------------------------------------------------
int __stdcall sub_10017CE0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // ecx@1

  result = a1;
  v4 = a1 + 4 * (a2 + 2);
  if ( v4 )
  {
    result = *(_DWORD *)a3;
    *(_DWORD *)v4 = *(_DWORD *)a3;
  }
  return result;
}

//----- (10017D00) --------------------------------------------------------
int __stdcall sub_10017D00(int a1, int a2, int a3)
{
  int result; // eax@2

  if ( a1 )
  {
    result = *(_DWORD *)(a2 + 4 * a3 + 8);
    *(_DWORD *)a1 = result;
  }
  return result;
}

//----- (10017D60) --------------------------------------------------------
int __stdcall sub_10017D60(void *a1)
{
  return sub_1002404A(a1);
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10017D90) --------------------------------------------------------
void __usercall sub_10017D90(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // esi@1
  int v4; // ecx@3
  int v5; // ecx@3
  int v6; // [sp+10h] [bp-10h]@6
  int v7; // [sp+1Ch] [bp-4h]@1

  v3 = a1;
  *(_DWORD *)a1 = &off_1005D068;
  *(_DWORD *)(a1 + 16) = &off_1005D010;
  v7 = 1;
  if ( *(_DWORD *)(a1 + 244) == 1 )
    sub_10028D82(a1);
  (*(void (__thiscall **)(int))(*(_DWORD *)(v3 + 40) + 8))(v3 + 40);
  (*(void (__thiscall **)(int))(*(_DWORD *)(v3 + 16) + 12))(v3 + 16);
  sub_10019E80(v3 + 16, v5);
  v4 = *(_DWORD *)(v3 + 240);
  if ( v4 )
    (*(void (__stdcall **)(signed int))(*(_DWORD *)v4 + 4))(1);
  if ( *(_BYTE *)(v3 + 253) )
  {
    v6 = *(_DWORD *)(v3 + 256);
    sub_1002C311(&v6);
  }
  LOBYTE(v7) = 0;
  sub_10018130(v3 + 16, a2, a3);
  v7 = -1;
  sub_10028CE0(v3);
}
// 1005D010: using guessed type int (*off_1005D010)();
// 1005D068: using guessed type int (__stdcall *off_1005D068)(char);

//----- (10017E50) --------------------------------------------------------
int __thiscall sub_10017E50(int this, int a2)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 224);
  if ( result && a2 == *(_DWORD *)(result + 4) )
    *(_DWORD *)(this + 224) = 0;
  else
    result = 0;
  return result;
}

//----- (10017E80) --------------------------------------------------------
char __thiscall sub_10017E80(int this, int a2)
{
  int v2; // eax@1

  v2 = *(_DWORD *)(this + 224);
  return v2 && *(_DWORD *)(v2 + 4) == a2;
}

//----- (10017EB0) --------------------------------------------------------
int __thiscall sub_10017EB0(void *this)
{
  return (*(int (**)(void))(*(_DWORD *)this + 48))();
}

//----- (10017F10) --------------------------------------------------------
int __thiscall sub_10017F10(int this, int a2)
{
  int v2; // esi@1
  int result; // eax@2

  v2 = *(_DWORD *)(this + 224);
  if ( v2 )
    result = (*(int (__stdcall **)(int, int))(*(_DWORD *)a2 + 4))(v2, this != 16 ? this : 0);
  return result;
}

//----- (10017F40) --------------------------------------------------------
unsigned int __userpurge sub_10017F40<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  unsigned int result; // eax@1
  int v4; // esi@1
  int v5; // eax@2
  int v6; // eax@3
  int v7; // ecx@3
  int v8; // ST00_4@5
  int v9; // [sp+4h] [bp-10h]@2
  int v10; // [sp+8h] [bp-Ch]@2
  unsigned int i; // [sp+Ch] [bp-8h]@2
  unsigned int v12; // [sp+10h] [bp-4h]@1
  int v13; // [sp+14h] [bp+0h]@1

  result = (unsigned int)&v13 ^ __security_cookie;
  v12 = (unsigned int)&v13 ^ __security_cookie;
  v4 = a1;
  if ( !*(_DWORD *)(a1 + 224) )
  {
    *(_DWORD *)(a1 + 224) = sub_10019520(a1 - 16, a2);
    v5 = *(_DWORD *)(v4 + 12);
    v9 = 0;
    i = 0;
    (*(void (__stdcall **)(int *))(v5 + 16))(&v9);
    result = (*(int (__stdcall **)(int))(*(_DWORD *)v9 + 24))(v10);
    for ( i = result; result; i = result )
    {
      v6 = (*(int (__stdcall **)(int))(*(_DWORD *)v9 + 24))(v10);
      v7 = 0;
      if ( v4 != 16 )
        v7 = v4;
      v8 = *(_DWORD *)(v4 + 224);
      i = v6;
      (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v6 + 4))(v6, v8, v7);
      ++v10;
      (*(void (__stdcall **)(int *))(*(_DWORD *)v9 + 20))(&v10);
      result = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)v9 + 24))(v10);
    }
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;

//----- (10018000) --------------------------------------------------------
int __thiscall sub_10018000(int this)
{
  return (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)(this + 16) + 84))(this + 16, 0);
}

//----- (10018090) --------------------------------------------------------
char __thiscall sub_10018090(int this, int a2)
{
  char result; // al@3

  if ( a2 && *(_DWORD *)(this + 4) == a2 )
  {
    *(_DWORD *)(this + 4) = 0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100180C0) --------------------------------------------------------
char __thiscall sub_100180C0(int this, int a2)
{
  return a2 && *(_DWORD *)(this + 4) == a2;
}

//----- (100180E0) --------------------------------------------------------
bool __thiscall sub_100180E0(int this)
{
  return *(_DWORD *)(this + 4) != 0;
}

//----- (100180F0) --------------------------------------------------------
int __thiscall sub_100180F0(int this, int a2)
{
  int result; // eax@2

  if ( !*(_DWORD *)(this + 4) )
  {
    result = a2;
    ++*(_DWORD *)result;
  }
  return result;
}

//----- (10018110) --------------------------------------------------------
int __thiscall sub_10018110(int this, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = 0;
  else
    result = *(_DWORD *)(this + 4);
  return result;
}

//----- (10018130) --------------------------------------------------------
void __usercall sub_10018130(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // esi@1
  int v4; // ST0C_4@1
  int v5; // ST10_4@1
  char v6; // zf@1
  char v7; // [sp+8h] [bp-1Ch]@2
  int v8; // [sp+14h] [bp-10h]@1
  int v9; // [sp+20h] [bp-4h]@1

  v3 = a1;
  v8 = a1;
  *(_DWORD *)a1 = &off_1005CF90;
  v9 = 3;
  sub_10028B89(a2, a3, 3, a1, (unsigned __int64)a1 >> 32, v4, v5);
  nullsub_2(v3 + 176);
  sub_100178D0((void *)(v3 + 24), a2);
  LOBYTE(v9) = 0;
  v6 = *(_DWORD *)(v3 + 16) == 0;
  *(_DWORD *)(v3 + 12) = &off_1005CFF0;
  if ( !v6 )
  {
    sub_10024934((int)&v7, (unsigned int)"Deleting link registry before removing all the links");
    sub_1002D02B((int)&v7, (int)&unk_100614E0);
  }
  *(_DWORD *)v3 = &off_1005D1A8;
}
// 10024CC5: using guessed type int __thiscall nullsub_2(_DWORD);
// 1005CF90: using guessed type int (__stdcall *off_1005CF90)(char);
// 1005CFF0: using guessed type void *off_1005CFF0;
// 1005D1A8: using guessed type int (__stdcall *off_1005D1A8)(char);

//----- (100181E0) --------------------------------------------------------
void __thiscall sub_100181E0(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1
  int (__stdcall **v4)(char); // [sp+8h] [bp-3Ch]@2
  int v5; // [sp+14h] [bp-30h]@2
  char v6; // [sp+18h] [bp-2Ch]@3
  unsigned int v7; // [sp+34h] [bp-10h]@1
  int v8; // [sp+40h] [bp-4h]@1
  int v9; // [sp+44h] [bp+0h]@1

  v7 = (unsigned int)&v9 ^ __security_cookie;
  v3 = this;
  sub_100241EF(ebp0, (int)((char *)this + 176));
  v8 = 0;
  if ( !a2 )
  {
    v5 = (int)"_PTarget";
    sub_10023687((int)&v4, &v5);
    v4 = &off_100542CC;
    sub_1002D02B((int)&v4, (int)&unk_10061764);
  }
  (*(void (__thiscall **)(char *, int))*((void (__thiscall ***)(_DWORD, _DWORD))v3 + 3))((char *)v3 + 12, a2);
  (*(void (__thiscall **)(int, void *))(*(_DWORD *)a2 + 16))(a2, v3);
  (*(void (__thiscall **)(void *, int))(*(_DWORD *)v3 + 40))(v3, a2);
  v8 = -1;
  sub_100242BA(&v6);
}
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);
// 10067210: using guessed type int __security_cookie;

//----- (100182A0) --------------------------------------------------------
void __thiscall sub_100182A0(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v3; // edi@1
  unsigned int v4; // [sp-4h] [bp-48h]@1
  int (__stdcall **v5)(char); // [sp+8h] [bp-3Ch]@2
  int v6; // [sp+14h] [bp-30h]@2
  char v7; // [sp+18h] [bp-2Ch]@5
  unsigned int v8; // [sp+34h] [bp-10h]@1
  int v9; // [sp+40h] [bp-4h]@1
  int v10; // [sp+44h] [bp+0h]@1

  v8 = (unsigned int)&v10 ^ __security_cookie;
  v4 = (unsigned int)&v10 ^ __security_cookie;
  v3 = this;
  sub_100241EF(ebp0, (int)((char *)this + 176));
  v9 = 0;
  if ( !a2 )
  {
    v6 = (int)"_PTarget";
    sub_10023687((int)&v5, &v6);
    v5 = &off_100542CC;
    sub_1002D02B((int)&v5, (int)&unk_10061764);
  }
  if ( (unsigned __int8)(*(int (__thiscall **)(char *, int, unsigned int))(*((_DWORD *)v3 + 3) + 4))(
                          (char *)v3 + 12,
                          a2,
                          v4) )
    (*(void (__thiscall **)(int, void *))(*(_DWORD *)a2 + 20))(a2, v3);
  v9 = -1;
  sub_100242BA(&v7);
}
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);
// 10067210: using guessed type int __security_cookie;

//----- (10018360) --------------------------------------------------------
void __thiscall sub_10018360(void *this)
{
  int ebp0; // ebp@0
  void *v2; // esi@1
  unsigned int v3; // ST04_4@1
  int v4; // eax@1
  int v5; // eax@2
  int v6; // edx@2
  char v7; // [sp+4h] [bp-38h]@3
  int v8; // [sp+20h] [bp-1Ch]@1
  int v9; // [sp+24h] [bp-18h]@1
  int i; // [sp+28h] [bp-14h]@1
  unsigned int v11; // [sp+2Ch] [bp-10h]@1
  int v12; // [sp+38h] [bp-4h]@1
  int v13; // [sp+3Ch] [bp+0h]@1

  v11 = (unsigned int)&v13 ^ __security_cookie;
  v3 = (unsigned int)&v13 ^ __security_cookie;
  v2 = this;
  sub_100241EF(ebp0, (int)((char *)this + 176));
  v12 = 0;
  v4 = *((_DWORD *)v2 + 3);
  v8 = 0;
  i = 0;
  (*(void (__thiscall **)(char *, int *, unsigned int))(v4 + 16))((char *)v2 + 12, &v8, v3);
  for ( i = (*(int (__stdcall **)(int))(*(_DWORD *)v8 + 24))(v9);
        i;
        i = (*(int (__stdcall **)(int))(*(_DWORD *)v8 + 24))(v9) )
  {
    v5 = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)v8 + 24))(v9);
    v6 = *(_DWORD *)v2;
    i = v5;
    (*(void (__thiscall **)(void *, int))(v6 + 8))(v2, v5);
    ++v9;
    (*(void (__stdcall **)(int *))(*(_DWORD *)v8 + 20))(&v9);
  }
  v12 = -1;
  sub_100242BA(&v7);
}
// 10067210: using guessed type int __security_cookie;

//----- (10018490) --------------------------------------------------------
char __thiscall sub_10018490(void *this, int a2, int a3)
{
  int ebp0; // ebp@0
  void *v4; // esi@1
  void *v5; // ecx@4
  char v7; // al@6
  int (__stdcall **v8)(char); // [sp+Ch] [bp-3Ch]@2
  int v9; // [sp+18h] [bp-30h]@2
  char v10; // [sp+1Ch] [bp-2Ch]@4
  unsigned int v11; // [sp+38h] [bp-10h]@1
  int v12; // [sp+44h] [bp-4h]@1
  int v13; // [sp+48h] [bp+0h]@1

  v11 = (unsigned int)&v13 ^ __security_cookie;
  v4 = this;
  sub_100241EF(ebp0, (int)((char *)this + 176));
  v12 = 0;
  if ( !a3 )
  {
    v9 = (int)"_PTarget";
    sub_10023687((int)&v8, &v9);
    v8 = &off_100542CC;
    sub_1002D02B((int)&v8, (int)&unk_10061764);
  }
  if ( *((_DWORD *)v4 + 1) )
  {
    v12 = -1;
    v5 = &v10;
LABEL_5:
    sub_100242BA(v5);
    return 0;
  }
  v7 = (*(int (__thiscall **)(void *, int))(*(_DWORD *)v4 + 52))(v4, a2);
  v12 = -1;
  v5 = &v10;
  if ( !v7 )
    goto LABEL_5;
  *((_DWORD *)v4 + 1) = a3;
  *((_DWORD *)v4 + 2) = a2;
  sub_100242BA(&v10);
  return 1;
}
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);
// 10067210: using guessed type int __security_cookie;

//----- (10018570) --------------------------------------------------------
void __thiscall sub_10018570(void *this, int a2, int a3)
{
  int v3; // ecx@1
  int ebp0; // ebp@0
  void *v5; // esi@1
  int v6; // eax@3
  int v7; // edx@6
  int v8; // eax@8
  int v9; // esi@8
  int v10; // ecx@8
  int v11; // eax@12
  unsigned int v12; // [sp-4Ch] [bp-90h]@8
  void *v13; // [sp-48h] [bp-8Ch]@8
  int *v14; // [sp-8h] [bp-4Ch]@8
  unsigned int v15; // [sp-4h] [bp-48h]@1
  int (__stdcall **v16)(char); // [sp+8h] [bp-3Ch]@2
  int v17; // [sp+14h] [bp-30h]@2
  char v18; // [sp+18h] [bp-2Ch]@7
  unsigned int v19; // [sp+34h] [bp-10h]@1
  int v20; // [sp+40h] [bp-4h]@1
  int v21; // [sp+44h] [bp+0h]@1

  v19 = (unsigned int)&v21 ^ __security_cookie;
  v15 = (unsigned int)&v21 ^ __security_cookie;
  v5 = this;
  sub_100241EF(ebp0, (int)((char *)this + 176));
  v3 = a3;
  v20 = 0;
  if ( !a3 )
  {
    v17 = (int)"_PTarget";
    sub_10023687((int)&v16, &v17);
    v16 = &off_100542CC;
    sub_1002D02B((int)&v16, (int)&unk_10061764);
  }
  v6 = *((_DWORD *)v5 + 1);
  if ( v6 && v3 == v6 )
  {
    if ( (*(int (__thiscall **)(void *, int, unsigned int))(*(_DWORD *)v5 + 56))(v5, a2, v15) )
    {
      v7 = *(_DWORD *)v5;
      *((_DWORD *)v5 + 1) = 0;
      (*(void (__thiscall **)(void *))(v7 + 64))(v5);
    }
    v20 = -1;
    sub_100242BA(&v18);
  }
  else
  {
    sub_10024890((int)&v16);
    sub_1002D02B((int)&v16, (int)&unk_1006169C);
    __asm { int     3               ; Trap to Debugger }
    v14 = &v21;
    v19 = (unsigned int)&v21 ^ __security_cookie;
    v13 = v5;
    v12 = (unsigned int)&v21 ^ __security_cookie;
    v9 = v10;
    sub_100241EF((int)&v14, v10 + 176);
    v8 = a3;
    v20 = 0;
    if ( !a3 )
    {
      v17 = (int)"_PTarget";
      sub_10023687((int)&v16, &v17);
      v16 = &off_100542CC;
      sub_1002D02B((int)&v16, (int)&unk_10061764);
    }
    if ( v8 != *(_DWORD *)(v9 + 4) )
    {
      sub_10024890((int)&v16);
      sub_1002D02B((int)&v16, (int)&unk_1006169C);
    }
    (*(void (__thiscall **)(int, int, unsigned int, void *))(*(_DWORD *)v9 + 60))(v9, a2, v12, v13);
    v11 = *(_DWORD *)v9;
    *(_DWORD *)(v9 + 4) = 0;
    (*(void (__thiscall **)(int))(v11 + 64))(v9);
    v20 = -1;
    sub_100242BA(&v18);
  }
}
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);
// 10067210: using guessed type int __security_cookie;

//----- (10018720) --------------------------------------------------------
int __thiscall sub_10018720(void *this, int a2)
{
  int result; // eax@1

  _ECX = (int)((char *)this + 216);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (10018740) --------------------------------------------------------
int __thiscall sub_10018740(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1
  int result; // eax@3
  char v11; // [sp+8h] [bp-2Ch]@2
  unsigned int v12; // [sp+24h] [bp-10h]@1
  int v13; // [sp+30h] [bp-4h]@2
  int v14; // [sp+34h] [bp+0h]@1

  v12 = (unsigned int)&v14 ^ __security_cookie;
  v3 = this;
  if ( a2 )
  {
    sub_100241EF(ebp0, (int)((char *)this + 176));
    v13 = 0;
    (*(void (__thiscall **)(void *, int))(*(_DWORD *)v3 + 44))(v3, a2);
    v13 = -1;
    sub_100242BA(&v11);
  }
  result = (int)((char *)v3 + 216);
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  return result;
}
// 10067210: using guessed type int __security_cookie;

//----- (100187D0) --------------------------------------------------------
int __thiscall sub_100187D0(void *this, int a2)
{
  int result; // eax@2

  if ( !*((_DWORD *)this + 1) )
    result = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)this + 76))(0);
  return result;
}

//----- (100187E0) --------------------------------------------------------
int __thiscall sub_100187E0(void *this, int a2)
{
  int result; // eax@2

  if ( *((_DWORD *)this + 1) == a2 )
    result = (*(int (__stdcall **)(_DWORD, int))(*(_DWORD *)this + 28))(*((_DWORD *)this + 2), a2);
  return result;
}

//----- (10018860) --------------------------------------------------------
int __thiscall sub_10018860(int this)
{
  return (*(int (**)(void))(*(_DWORD *)(this + 24) + 4))();
}

//----- (10018870) --------------------------------------------------------
int __thiscall sub_10018870(int this)
{
  return (**(int (***)(void))(this + 24))();
}

//----- (100188F0) --------------------------------------------------------
void *__userpurge sub_100188F0<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_100170C0(a1, a2);
  if ( a3 & 1 )
    sub_1002404A(v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10018920) --------------------------------------------------------
void *__thiscall sub_10018920(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_10017230(this);
  if ( a2 & 1 )
    sub_1002404A(v2);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10018950) --------------------------------------------------------
void *__thiscall sub_10018950(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_1005D1A8;
  if ( a2 & 1 )
    sub_1002404A(this);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005D1A8: using guessed type int (__stdcall *off_1005D1A8)(char);

//----- (10018980) --------------------------------------------------------
void *__userpurge sub_10018980<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_10017430(a1, a2);
  if ( a3 & 1 )
    sub_1002404A(v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (100189B0) --------------------------------------------------------
void *__thiscall sub_100189B0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_1005D0EC;
  if ( a2 & 1 )
    sub_1002404A(this);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005D0EC: using guessed type int (__stdcall *off_1005D0EC)(char);

//----- (100189E0) --------------------------------------------------------
void *__userpurge sub_100189E0<eax>(void *a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = a1;
  sub_100178D0(a1, a2);
  if ( a3 & 1 )
    sub_1002404A(v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10018A10) --------------------------------------------------------
void *__userpurge sub_10018A10<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  void *v4; // esi@1

  v4 = (void *)a1;
  sub_10017D90(a1, a2, a3);
  if ( a4 & 1 )
    sub_1002404A(v4);
  return v4;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10018A90) --------------------------------------------------------
void *__userpurge sub_10018A90<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  void *v4; // esi@1

  v4 = (void *)a1;
  sub_10018130(a1, a2, a3);
  if ( a4 & 1 )
    sub_1002404A(v4);
  return v4;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10018AC0) --------------------------------------------------------
char __userpurge sub_10018AC0<al>(int a1<ecx>, int a2<ebx>, char a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int ebp0; // ebp@0
  int v8; // esi@1
  int v9; // edx@3
  int v10; // ecx@3
  int v11; // edi@3
  int v12; // ecx@5
  int v13; // eax@6
  int v14; // edx@8
  int v15; // esi@9
  int v16; // edi@10
  int v17; // ecx@10
  int v18; // edx@10
  int v19; // eax@15
  int v20; // esi@16
  char v36; // [sp+Ch] [bp-50h]@10
  int v37; // [sp+1Ch] [bp-40h]@3
  int v38; // [sp+20h] [bp-3Ch]@3
  int v39; // [sp+24h] [bp-38h]@3
  int v40; // [sp+28h] [bp-34h]@1
  char v41; // [sp+2Fh] [bp-2Dh]@3
  unsigned int v42; // [sp+4Ch] [bp-10h]@1
  int v43; // [sp+58h] [bp-4h]@1
  int v44; // [sp+5Ch] [bp+0h]@1

  v42 = (unsigned int)&v44 ^ __security_cookie;
  v8 = a1;
  v40 = a1;
  v43 = 0;
  v6 = *(_DWORD *)a1;
  if ( *(_BYTE *)(*(_DWORD *)a1 + 72) || *(_BYTE *)(v6 + 73) )
  {
    v41 = 0;
  }
  else
  {
    a2 = 0;
    v11 = 0;
    v37 = 0;
    v38 = 0;
    v39 = 0;
    v41 = 0;
    sub_1002426D(ebp0, v6 + 12);
    LOBYTE(v43) = 2;
    v10 = *(_DWORD *)v8;
    if ( !*(_BYTE *)(*(_DWORD *)v8 + 72) )
    {
      if ( !*(_BYTE *)(v10 + 73) )
      {
        sub_10004FF0(v10 + 48, v9, (int)&a3);
        *(_BYTE *)(*(_DWORD *)v8 + 72) = 1;
        v12 = *(_DWORD *)v8;
        if ( &v37 != *(int **)v8 )
        {
          v11 = *(_DWORD *)v12;
          *(_DWORD *)v12 = 0;
          a2 = *(_DWORD *)(v12 + 4);
          *(_DWORD *)(v12 + 4) = 0;
          v13 = *(_DWORD *)(v12 + 8);
          v37 = v11;
          v38 = a2;
          v39 = v13;
          *(_DWORD *)(v12 + 8) = 0;
        }
        v41 = 1;
      }
    }
    LOBYTE(v43) = 1;
    sub_100242C1();
    if ( v41 )
    {
      v15 = v11;
      if ( v11 != a2 )
      {
        do
        {
          sub_10004DA0((int)&v36, v14, *(_DWORD *)v40 + 48);
          v16 = *(_DWORD *)v15;
          v17 = *(_DWORD *)v15 + 152;
          LOBYTE(v43) = 4;
          sub_10004FF0(v17, v18, (int)&v36);
          sub_1002426D(ebp0, v16 + 100);
          LOBYTE(v43) = 4;
          if ( *(_DWORD *)(v16 + 84) == 4 )
          {
            sub_100242C1();
          }
          else
          {
            *(_DWORD *)(v16 + 84) = 3;
            sub_100242C1();
            sub_10025148(ebp0);
            sub_10001730(v16);
          }
          LOBYTE(v43) = 1;
          sub_10004F60((int)&v36, a2);
          v15 += 8;
        }
        while ( v15 != a2 );
        v11 = v37;
      }
      v19 = *(_DWORD *)v40;
      if ( *(_DWORD *)(*(_DWORD *)v40 + 64) )
      {
        v20 = *(_DWORD *)(v19 + 68);
        *(_DWORD *)(v19 + 68) = 0;
        *(_DWORD *)(v19 + 64) = 0;
        if ( v20 )
        {
          _ECX = v20 + 4;
          _EAX = -1;
          __asm { lock xadd [ecx], eax }
          if ( _ZF )
          {
            (**(void (__thiscall ***)(_DWORD))v20)(v20);
            _EAX = v20 + 8;
            _ECX = -1;
            __asm { lock xadd [eax], ecx }
            if ( _ZF )
              (*(void (__thiscall **)(int))(*(_DWORD *)v20 + 4))(v20);
          }
        }
      }
      v41 = 1;
    }
    else
    {
      v41 = 0;
    }
    if ( v11 )
    {
      sub_1001ACD0(v11, a2);
      sub_1002404A((LPVOID)v11);
    }
  }
  v43 = -1;
  sub_10004F60((int)&a3, a2);
  return v41;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (10018CC0) --------------------------------------------------------
char __thiscall sub_10018CC0(void *this, char a2, int a3)
{
  void *v3; // esi@1
  char v4; // bl@2
  char v6; // [sp-Ch] [bp-30h]@1
  int v7; // [sp-8h] [bp-2Ch]@1
  int v8; // [sp-4h] [bp-28h]@1
  char v9; // [sp+10h] [bp-14h]@1
  int v10; // [sp+20h] [bp-4h]@1

  v3 = this;
  v10 = 0;
  sub_10023441((int)&v9, (int)&a2);
  v8 = 0;
  LOBYTE(v10) = 1;
  sub_10023441((int)&v6, (int)&v9);
  if ( sub_1001ABD0(v3, v6, v7, v8) )
    v4 = sub_1001A500(v3);
  else
    v4 = 0;
  LOBYTE(v10) = 0;
  sub_100234E2((int)&v9);
  v10 = -1;
  sub_100234E2((int)&a2);
  return v4;
}
// 10023441: using guessed type int __cdecl sub_10023441(int, int);

//----- (10018E20) --------------------------------------------------------
char __thiscall sub_10018E20(int this, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // esi@1
  int v5; // ecx@2
  char result; // al@5
  int v7; // eax@6

  v4 = this;
  v2 = 0;
  v3 = *(_DWORD *)(this + 12);
  if ( v3 )
  {
    v5 = *(_DWORD *)(this + 8);
    while ( *(_DWORD *)v5 != a2 )
    {
      ++v2;
      v5 += 4;
      if ( v2 >= v3 )
        goto LABEL_5;
    }
    *(_DWORD *)(*(_DWORD *)(v4 + 8) + 4 * v2) = 0;
    v7 = *(_DWORD *)(v4 + 4);
    if ( v7 != -1 )
    {
      if ( v7 )
        *(_DWORD *)(v4 + 4) = 0;
    }
    result = 1;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (10018EB0) --------------------------------------------------------
int __usercall sub_10018EB0<eax>(int a1<ecx>, int a2<ebx>)
{
  int v3; // edi@1
  int v4; // edx@1

  v3 = a1;
  *(_DWORD *)a1 = &off_1005D17C;
  sub_10024193(a1 + 4);
  *(_DWORD *)(v3 + 44) = 0;
  *(_DWORD *)(v3 + 48) = 0;
  *(_DWORD *)(v3 + 52) = 0;
  *(_DWORD *)(v3 + 56) = 0;
  *(_DWORD *)(v3 + 60) = off_1005D208;
  *(_DWORD *)(v3 + 64) = -1;
  *(_DWORD *)(v3 + 68) = 0;
  *(_DWORD *)(v3 + 72) = 0;
  *(_DWORD *)(v3 + 76) = 0;
  *(_DWORD *)(v3 + 80) = 0;
  *(_DWORD *)(v3 + 84) = 0;
  *(_BYTE *)(v3 + 88) = 0;
  sub_10019BD0(v3 + 96, v4);
  sub_10028B89(a2, v3, 0, v3, (unsigned __int64)v3 >> 32, v3 + 96, (unsigned __int64)(v3 + 96) >> 32);
  return v3;
}
// 1005D17C: using guessed type int (__stdcall *off_1005D17C)(char);
// 1005D208: using guessed type int (__stdcall *off_1005D208[3])(int);

//----- (10018F80) --------------------------------------------------------
int __thiscall sub_10018F80(int this, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  void **v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int *v7; // [sp+1Ch] [bp-18h]@1
  int v8; // [sp+30h] [bp-4h]@1

  v4 = this;
  v5 = &off_1005CD14;
  v6 = this;
  v7 = (int *)&v5;
  v8 = 1;
  result = sub_10019C70(this + 96, 0, this, (int)&v5);
  v8 = -1;
  if ( v7 )
  {
    result = (*(int (__stdcall **)(bool))(*v7 + 16))((void ***)v7 != &v5);
    v7 = 0;
  }
  *(_DWORD *)(v4 + 80) = v4;
  return result;
}
// 1005CD14: using guessed type void *off_1005CD14;

//----- (10019020) --------------------------------------------------------
int __thiscall sub_10019020(int this)
{
  int result; // eax@1
  void **v2; // [sp+8h] [bp-40h]@1
  int v3; // [sp+Ch] [bp-3Ch]@1
  int *v4; // [sp+18h] [bp-30h]@1
  char v5; // [sp+20h] [bp-28h]@1
  int v6; // [sp+30h] [bp-18h]@1
  int v7; // [sp+44h] [bp-4h]@1

  v6 = 0;
  v7 = 0;
  v2 = &off_1005CCF8;
  v3 = this;
  v4 = (int *)&v2;
  LOBYTE(v7) = 2;
  result = (*(int (__stdcall **)(void ***, char *))(*(_DWORD *)(this + 96) + 20))(&v2, &v5);
  LOBYTE(v7) = 0;
  if ( v4 )
  {
    result = (*(int (__stdcall **)(bool))(*v4 + 16))((void ***)v4 != &v2);
    v4 = 0;
  }
  v7 = -1;
  if ( v6 )
    result = (*(int (__stdcall **)(bool))(*(_DWORD *)v6 + 16))(v6 != (_DWORD)&v5);
  return result;
}
// 1005CCF8: using guessed type void *off_1005CCF8;

//----- (100190E0) --------------------------------------------------------
int __thiscall sub_100190E0(void *this)
{
  void *v1; // esi@1

  v1 = this;
  sub_10017230((int)((char *)this + 56));
  if ( *((_DWORD *)v1 + 11) )
  {
    sub_1002401B(*((LPVOID *)v1 + 11));
    *((_DWORD *)v1 + 11) = 0;
    *((_DWORD *)v1 + 12) = 0;
    *((_DWORD *)v1 + 13) = 0;
  }
  return nullsub_2(v1);
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 10024CC5: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (10019160) --------------------------------------------------------
char __thiscall sub_10019160(int this, int a2)
{
  int ebp0; // ebp@0
  int v3; // edi@1
  int v4; // esi@1
  unsigned int v6; // eax@7
  int v7; // [sp+Ch] [bp-34h]@1
  char v8; // [sp+13h] [bp-2Dh]@2
  char v9; // [sp+14h] [bp-2Ch]@3
  unsigned int v10; // [sp+30h] [bp-10h]@1
  int v11; // [sp+3Ch] [bp-4h]@2
  int v12; // [sp+40h] [bp+0h]@1

  v10 = (unsigned int)&v12 ^ __security_cookie;
  v4 = this;
  v3 = 0;
  v7 = *(_DWORD *)(this + 76);
  if ( !a2 )
    return 0;
  sub_100241EF(ebp0, this);
  v11 = 0;
  v8 = (*(int (__stdcall **)(int))(*(_DWORD *)(v4 + 56) + 4))(a2);
  if ( !v8 )
  {
    v11 = -1;
    sub_100242BA(&v9);
    return 0;
  }
  if ( *(_DWORD *)(v4 + 40) )
  {
    v6 = *(_DWORD *)(v4 + 48);
    if ( v6 >= *(_DWORD *)(v4 + 52) )
      sub_1001A050(v4 + 44, 0, 2 * v6 + 2);
    *(_DWORD *)(*(_DWORD *)(v4 + 44) + 4 * *(_DWORD *)(v4 + 48)++) = a2;
  }
  else
  {
    v3 = a2;
  }
  v11 = -1;
  sub_100242BA(&v9);
  if ( v3 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 36))(v3, v7);
  return v8;
}
// 10067210: using guessed type int __security_cookie;

//----- (10019240) --------------------------------------------------------
int __thiscall sub_10019240(int this, int a2)
{
  *(_DWORD *)a2 = &off_1005CE74;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = this;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  sub_1001A0B0(this, a2 + 4);
  return a2;
}
// 1005CE74: using guessed type int (__stdcall *off_1005CE74)(char);

//----- (100192C0) --------------------------------------------------------
char __thiscall sub_100192C0(void *this)
{
  char result; // al@1
  int v2; // esi@1
  int v3; // [sp+4h] [bp-8h]@1
  unsigned int v4; // [sp+8h] [bp-4h]@1
  int v5; // [sp+Ch] [bp+0h]@1

  v4 = (unsigned int)&v5 ^ __security_cookie;
  v2 = (int)((char *)this + 4);
  v3 = 0;
  for ( result = sub_10022792((int)((char *)this + 4), (int)&v3); result; result = sub_10022792(v2, (int)&v3) )
  {
    if ( v3 )
      (*(void (__stdcall **)(signed int))(*(_DWORD *)v3 + 4))(1);
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;

//----- (10019320) --------------------------------------------------------
void __thiscall sub_10019320(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v3; // edi@1
  int v4; // ecx@2
  int v5; // eax@3

  v3 = this;
  sub_100241AA(ebp0, (int)((char *)this + 24));
  if ( *((_DWORD *)v3 + 17) )
  {
    if ( a2 )
      (*(void (__thiscall **)(int, signed int))(*(_DWORD *)a2 + 4))(a2, 1);
  }
  else
  {
    v4 = (int)((char *)v3 + 56);
    if ( *((_DWORD *)v3 + 14) > 0 )
    {
      v5 = *(_DWORD *)v4;
      *(_DWORD *)v4 = 0;
      loc_10019CF0(v3, v5);
    }
    loc_10019D80(v3, a2);
  }
  sub_100242C1();
}

//----- (10019510) --------------------------------------------------------
int __cdecl sub_10019510(int a1)
{
  return (*(int (**)(void))(*(_DWORD *)a1 + 12))();
}

//----- (10019520) --------------------------------------------------------
int __usercall sub_10019520<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // eax@1
  int v3; // edi@1
  int v4; // esi@1
  int result; // eax@2

  v3 = a1;
  v2 = sub_10028682(a2, a1, 0x14u);
  v4 = v2;
  if ( v2 )
  {
    *(_DWORD *)(v2 + 12) = 0;
    sub_10022A06(v2);
    *(_DWORD *)v4 = &off_1005CE78;
    *(_DWORD *)(v4 + 8) = *(_DWORD *)(v3 + 248);
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1005CE78: using guessed type int (*off_1005CE78)();

//----- (100195C0) --------------------------------------------------------
int __thiscall sub_100195C0(int this, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // ecx@1
  int v10; // [sp+Ch] [bp-8h]@1
  unsigned int v11; // [sp+10h] [bp-4h]@1
  int v12; // [sp+14h] [bp+0h]@1

  v11 = (unsigned int)&v12 ^ __security_cookie;
  v7 = this;
  v10 = 0;
  *(_DWORD *)(this + 240) = 0;
  *(_DWORD *)(this + 248) = *(_DWORD *)a2;
  *(_WORD *)(this + 252) = 0;
  *(_DWORD *)(this + 244) = 0;
  sub_10027E8B(this, a3, this, (int)&v10);
  v8 = v10;
  sub_1002C30A(&v10);
  *(_BYTE *)(v7 + 253) = 1;
  *(_DWORD *)(v7 + 256) = v8;
  result = sub_10019DF0(v7 + 16, v8, v9);
  if ( a3 )
    result = (*(int (__thiscall **)(int, int))(*(_DWORD *)(v7 + 16) + 4))(v7 + 16, a3);
  return result;
}
// 10067210: using guessed type int __security_cookie;

//----- (10019660) --------------------------------------------------------
int __usercall sub_10019660<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v4; // edi@1

  v4 = a2;
  *(_DWORD *)a2 = &off_1005CF90;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = -1;
  *(_DWORD *)(a2 + 12) = &off_1005CFF0;
  *(_DWORD *)(a2 + 16) = 0;
  sub_10019BD0(a2 + 24, a1);
  sub_10024193(v4 + 176);
  *(_DWORD *)(v4 + 216) = 0;
  sub_10028B89(a3, v4, 0, v4, (unsigned __int64)v4 >> 32, v4 + 24, (unsigned __int64)(v4 + 24) >> 32);
  return v4;
}
// 1005CF90: using guessed type int (__stdcall *off_1005CF90)(char);
// 1005CFF0: using guessed type void *off_1005CFF0;

//----- (10019710) --------------------------------------------------------
int __thiscall sub_10019710(int this)
{
  int v1; // ecx@1
  int v2; // esi@1
  int result; // eax@3

  v2 = this;
  *(_DWORD *)this = &off_1005CE74;
  v1 = *(_DWORD *)(this + 16);
  if ( v1 )
    sub_10019AE0(v1);
  result = *(_DWORD *)(v2 + 4);
  if ( result )
  {
    result = sub_1002401B(*(LPVOID *)(v2 + 4));
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
    *(_DWORD *)(v2 + 12) = 0;
  }
  return result;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1005CE74: using guessed type int (__stdcall *off_1005CE74)(char);

//----- (10019790) --------------------------------------------------------
int __usercall sub_10019790<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // eax@1
  int ebp0; // ebp@0
  int v4; // esi@1
  int v5; // ecx@2

  v4 = a1;
  *(_DWORD *)a1 = &off_1005CE6C;
  v2 = *(_DWORD *)(a1 + 140);
  if ( v2 )
  {
    sub_10027CF1(ebp0, v2);
    v5 = *(_DWORD *)(v4 + 140);
    _EDX = -1;
    _EAX = v5 + 4;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v5 + 4))();
    *(_DWORD *)(v4 + 140) = 0;
  }
  sub_10004F60(v4 + 152, a2);
  return sub_10020640(v4);
}
// 1005CE6C: using guessed type int (__stdcall *off_1005CE6C)(char);

//----- (10019830) --------------------------------------------------------
char __thiscall sub_10019830(void *this, char a2, char a3, int a4, int a5)
{
  char v5; // bl@1
  int ebp0; // ebp@0
  int v7; // esi@1
  int v8; // eax@7
  int v10; // ecx@14
  char v11; // [sp+10h] [bp-4Ch]@1
  void **v12; // [sp+14h] [bp-48h]@18
  int v13; // [sp+18h] [bp-44h]@18
  int *v14; // [sp+24h] [bp-38h]@18
  unsigned int v15; // [sp+48h] [bp-14h]@1
  int v16; // [sp+58h] [bp-4h]@1

  v15 = (unsigned int)&v11 ^ __security_cookie;
  v7 = (int)this;
  v5 = 0;
  sub_1002426D(ebp0, (int)((char *)this + 100));
  v16 = 0;
  if ( !a3 )
  {
    v8 = *(_DWORD *)(v7 + 84);
    if ( v8 != 3 && v8 != 4 )
    {
      if ( v8 != 2 )
        goto LABEL_4;
      if ( a2 )
      {
LABEL_13:
        *(_DWORD *)(v7 + 84) = 4;
        sub_10025148(ebp0);
        v5 = 1;
        goto LABEL_14;
      }
    }
LABEL_11:
    v16 = -1;
    sub_100242C1();
    return 0;
  }
  if ( *(_DWORD *)(v7 + 84) == 4 )
    goto LABEL_11;
  sub_100202F0((void *)(v7 + 92), a5);
LABEL_4:
  if ( a2 || !*(_DWORD *)(v7 + 84) )
    goto LABEL_13;
  *(_DWORD *)(v7 + 84) = 2;
LABEL_14:
  v10 = *(_DWORD *)(v7 + 144);
  if ( v10 )
    sub_10025F04(v10 + 8, v5, a5);
  v16 = -1;
  sub_100242C1();
  if ( v5 )
  {
    sub_10025148(ebp0);
    if ( *(_DWORD *)(v7 + 132) )
    {
      v12 = &off_1005CCDC;
      v13 = v7;
      v14 = (int *)&v12;
      v16 = 2;
      sub_100203A0((int)&v12, a5);
      sub_10001A60((int)&v12);
    }
  }
  return 1;
}
// 1005CCDC: using guessed type void *off_1005CCDC;
// 10067210: using guessed type int __security_cookie;

//----- (10019980) --------------------------------------------------------
int __fastcall sub_10019980(int a1, int a2, int a3)
{
  sub_10004DA0(a3, a2, a1 + 152);
  return a3;
}

//----- (100199B0) --------------------------------------------------------
int __userpurge sub_100199B0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  int v4; // esi@1

  v4 = a1;
  *(_DWORD *)a1 = &off_1005CE78;
  if ( a4 & 1 )
    sub_10028747(a2, a3, a1);
  return v4;
}
// 1005CE78: using guessed type int (*off_1005CE78)();

//----- (100199E0) --------------------------------------------------------
int __thiscall sub_100199E0(int this, char a2)
{
  int v2; // ecx@1
  int v3; // esi@1

  v3 = this;
  *(_DWORD *)this = &off_1005CE74;
  v2 = *(_DWORD *)(this + 16);
  if ( v2 )
    sub_10019AE0(v2);
  if ( *(_DWORD *)(v3 + 4) )
  {
    sub_1002401B(*(LPVOID *)(v3 + 4));
    *(_DWORD *)(v3 + 4) = 0;
    *(_DWORD *)(v3 + 8) = 0;
    *(_DWORD *)(v3 + 12) = 0;
  }
  if ( a2 & 1 )
    sub_1002404A((LPVOID)v3);
  return v3;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005CE74: using guessed type int (__stdcall *off_1005CE74)(char);

//----- (10019A70) --------------------------------------------------------
void *__userpurge sub_10019A70<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_10019790(a1, a2);
  if ( a3 & 1 )
    sub_1002404A(v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10019AA0) --------------------------------------------------------
int __thiscall sub_10019AA0(void *this)
{
  int v1; // ecx@1
  void *v2; // esi@1
  int result; // eax@2

  v2 = this;
  v1 = *(_DWORD *)this;
  if ( v1 )
  {
    sub_1001ACD0(v1, *((_DWORD *)v2 + 1));
    result = sub_1002404A(*(LPVOID *)v2);
    *(_DWORD *)v2 = 0;
    *((_DWORD *)v2 + 1) = 0;
    *((_DWORD *)v2 + 2) = 0;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10019AE0) --------------------------------------------------------
void __thiscall sub_10019AE0(int this)
{
  int ebp0; // ebp@0
  int v2; // esi@1
  int v3; // esi@3
  int v4; // ebx@4
  int v5; // edi@4
  int v6; // eax@4
  unsigned int v7; // esi@6
  int v8; // [sp+Ch] [bp-3Ch]@1
  int v9; // [sp+10h] [bp-38h]@1
  int v10; // [sp+14h] [bp-34h]@1
  int v11; // [sp+18h] [bp-30h]@1
  char v12; // [sp+1Ch] [bp-2Ch]@6
  unsigned int v13; // [sp+38h] [bp-10h]@1
  int v14; // [sp+44h] [bp-4h]@1
  int v15; // [sp+48h] [bp+0h]@1

  v13 = (unsigned int)&v15 ^ __security_cookie;
  v2 = this;
  v8 = *(_DWORD *)(this + 76);
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  sub_100241EF(ebp0, this);
  --*(_DWORD *)(v2 + 40);
  if ( *(_DWORD *)(v2 + 40) || !*(_DWORD *)(v2 + 48) || (v3 = v2 + 44, (int *)v3 == &v9) )
  {
    v4 = v10;
    v5 = v9;
  }
  else
  {
    v5 = *(_DWORD *)v3;
    v4 = *(_DWORD *)(v3 + 4);
    v6 = *(_DWORD *)(v3 + 8);
    *(_DWORD *)v3 = 0;
    *(_DWORD *)(v3 + 4) = 0;
    *(_DWORD *)(v3 + 8) = 0;
    v9 = v5;
    v10 = v4;
    v11 = v6;
  }
  sub_100242BA(&v12);
  v7 = 0;
  if ( v4 )
  {
    do
      (*(void (__stdcall **)(int))(**(_DWORD **)(v5 + 4 * v7++) + 36))(v8);
    while ( v7 < v4 );
  }
  if ( v5 )
    sub_1002401B((LPVOID)v5);
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (10019BD0) --------------------------------------------------------
int __fastcall sub_10019BD0(int a1, int a2)
{
  int v3; // edi@1

  v3 = a1;
  *(_DWORD *)a1 = &off_1005D0D4;
  sub_100225DD(a1 + 4, a2, 4u);
  *(_DWORD *)(v3 + 4) = off_1005CE54;
  sub_10024163(v3 + 24);
  *(_DWORD *)(v3 + 56) = 0;
  *(_DWORD *)(v3 + 60) = 0;
  *(_DWORD *)(v3 + 64) = 0;
  *(_DWORD *)(v3 + 68) = 1;
  *(_DWORD *)(v3 + 72) = 0;
  *(_DWORD *)(v3 + 96) = 0;
  *(_DWORD *)(v3 + 120) = 0;
  *(_DWORD *)(v3 + 144) = 0;
  return v3;
}
// 1005CE54: using guessed type int (__stdcall *off_1005CE54[3])(int, int, int);
// 1005D0D4: using guessed type void *off_1005D0D4;

//----- (10019C70) --------------------------------------------------------
int __thiscall sub_10019C70(int this, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@2
  int v8; // ecx@4
  int v9; // eax@6

  result = a2;
  v6 = this;
  v5 = this + 80;
  *(_DWORD *)(this + 60) = a2;
  *(_DWORD *)(this + 64) = 0;
  if ( this + 80 != a4 )
  {
    v7 = *(_DWORD *)(this + 96);
    if ( v7 )
    {
      result = (*(int (__stdcall **)(bool))(*(_DWORD *)v7 + 16))(v7 != v5);
      *(_DWORD *)(v5 + 16) = 0;
    }
    v8 = *(_DWORD *)(a4 + 16);
    if ( !v8 )
    {
      *(_DWORD *)(v5 + 16) = 0;
      *(_DWORD *)(v6 + 68) = 0;
      return result;
    }
    v9 = *(_DWORD *)v8;
    if ( v8 == a4 )
    {
      result = (*(int (__stdcall **)(int))v9)(v5);
      *(_DWORD *)(v5 + 16) = result;
      *(_DWORD *)(v6 + 68) = 0;
      return result;
    }
    result = (*(int (__stdcall **)(_DWORD))v9)(0);
    *(_DWORD *)(v5 + 16) = result;
  }
  *(_DWORD *)(v6 + 68) = 0;
  return result;
}

//----- (10019DF0) --------------------------------------------------------
int __thiscall sub_10019DF0(int this, int a2, int a3)
{
  int result; // eax@1
  void **v4; // [sp+4h] [bp-28h]@1
  int v5; // [sp+8h] [bp-24h]@1
  int *v6; // [sp+14h] [bp-18h]@1
  int v7; // [sp+28h] [bp-4h]@1

  v4 = &off_1005CCC0;
  v5 = this;
  v6 = (int *)&v4;
  v7 = 1;
  result = sub_10019C70(this + 24, a2, this, (int)&v4);
  v7 = -1;
  if ( v6 )
    result = (*(int (__stdcall **)(bool))(*v6 + 16))((void ***)v6 != &v4);
  return result;
}
// 1005CCC0: using guessed type void *off_1005CCC0;

//----- (10019E80) --------------------------------------------------------
char __thiscall sub_10019E80(int this, int a2)
{
  int v2; // eax@1
  int v3; // esi@1
  char v4; // zf@1
  char v5; // zf@3
  char v6; // zf@5
  DWORD v7; // eax@12
  char v9; // [sp+8h] [bp-18h]@1
  DWORD v10; // [sp+Ch] [bp-14h]@3
  int v11; // [sp+10h] [bp-10h]@4
  int v12; // [sp+14h] [bp-Ch]@1
  int (*v13)(void); // [sp+18h] [bp-8h]@1
  unsigned int v14; // [sp+1Ch] [bp-4h]@1

  v2 = (unsigned int)&v9 ^ __security_cookie;
  v14 = (unsigned int)&v9 ^ __security_cookie;
  v3 = this;
  v4 = *(_DWORD *)(this + 216) == 0;
  v12 = 0;
  v13 = sub_1002C66E;
  if ( !v4 )
  {
    do
    {
      v2 = v12;
      switch ( v12 )
      {
        case 1:
          __asm { pause                   ; jumptable 10019ECD case 1 }
          v5 = v10-- == 1;
          if ( v5 )
          {
            v2 = 3 - (v11 != 0);
            v12 = 3 - (v11 != 0);
          }
          break;
        case 2:
          v6 = v11-- == 1;
          if ( v6 )
            v2 = 3;
          v12 = v2;
          goto LABEL_8;
        case 4:
LABEL_8:
          LOBYTE(v2) = v13();
          break;
        case 3:
          v12 = 0;
          v2 = sub_100247A0();
          if ( v2 )
          {
            v10 = v2;
            v11 = 1;
            v12 = 1;
          }
          else
          {
            v12 = 4;
          }
          break;
        case 0:
          v12 = 0;
          v7 = sub_100247A0();
          if ( v7 )
          {
            v10 = v7;
            v11 = 1;
            v12 = 1;
          }
          else
          {
            v12 = 4;
          }
          LOBYTE(v2) = sub_1001FF20((int)&v10);
          break;
        default:
          break;
      }
    }
    while ( *(_DWORD *)(v3 + 216) );
  }
  return v2;
}
// 10067210: using guessed type int __security_cookie;

//----- (10019FA0) --------------------------------------------------------
int __userpurge sub_10019FA0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, char a4, int a5, int a6, int a7)
{
  int ebp0; // ebp@0
  int v8; // esi@1

  v8 = a2;
  sub_10004FF0(a2 + 152, a1, (int)&a4);
  sub_1002426D(ebp0, v8 + 100);
  if ( *(_DWORD *)(v8 + 84) == 4 )
  {
    sub_100242C1();
  }
  else
  {
    *(_DWORD *)(v8 + 84) = 3;
    sub_100242C1();
    sub_10025148(ebp0);
    sub_10001730(v8);
  }
  return sub_10004F60((int)&a4, a3);
}

//----- (1001A050) --------------------------------------------------------
int __userpurge sub_1001A050<eax>(int a1<ecx>, int a2<edi>, int a3)
{
  int result; // eax@1
  int v4; // edi@1
  int v5; // esi@1
  signed __int64 v7; // qax@1
  unsigned int v8; // ecx@2

  v5 = a1;
  _ECX = 0;
  v7 = 4i64 * (unsigned int)a3;
  __asm { seto    cl }
  result = sub_10021CF0(SHIDWORD(v7), v7 | -_ECX, a3, a2, v7 | -_ECX);
  v4 = result;
  if ( *(_DWORD *)v5 )
  {
    v8 = 0;
    if ( *(_DWORD *)(v5 + 8) )
    {
      do
      {
        ++v8;
        *(_DWORD *)(result + 4 * v8 - 4) = *(_DWORD *)(*(_DWORD *)v5 + 4 * v8 - 4);
      }
      while ( v8 < *(_DWORD *)(v5 + 8) );
    }
    result = sub_1002401B(*(LPVOID *)v5);
  }
  *(_DWORD *)v5 = v4;
  *(_DWORD *)(v5 + 8) = a3;
  return result;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (1001A0B0) --------------------------------------------------------
void __thiscall sub_1001A0B0(int this, int a2)
{
  int ebp0; // ebp@0
  unsigned int v3; // ST04_4@1
  int v4; // edi@1
  int v5; // eax@1
  int v6; // edi@2
  unsigned int v7; // eax@3
  int v8; // edx@3
  int v9; // ebx@4
  int v10; // edi@4
  __int64 v12; // qax@4
  unsigned int v13; // ecx@5
  int v14; // ecx@9
  char v15; // [sp+Ch] [bp-38h]@10
  int v16; // [sp+28h] [bp-1Ch]@1
  int v17; // [sp+2Ch] [bp-18h]@1
  int v18; // [sp+30h] [bp-14h]@1
  unsigned int v19; // [sp+34h] [bp-10h]@1
  int v20; // [sp+40h] [bp-4h]@1
  int v21; // [sp+44h] [bp+0h]@1

  v19 = (unsigned int)&v21 ^ __security_cookie;
  v3 = (unsigned int)&v21 ^ __security_cookie;
  v4 = this;
  sub_100241EF(ebp0, this);
  v20 = 0;
  ++*(_DWORD *)(v4 + 40);
  v5 = *(_DWORD *)(v4 + 56);
  v16 = 0;
  v18 = 0;
  (*(void (__thiscall **)(int, int *, unsigned int))(v5 + 16))(v4 + 56, &v16, v3);
  v18 = (*(int (__stdcall **)(int))(*(_DWORD *)v16 + 24))(v17);
  if ( v18 )
  {
    v6 = 4;
    do
    {
      v8 = (*(int (__stdcall **)(int))(*(_DWORD *)v16 + 24))(v17);
      v7 = *(_DWORD *)(a2 + 4);
      v18 = v8;
      if ( v7 >= *(_DWORD *)(a2 + 8) )
      {
        v9 = 2 * v7 + 2;
        _ECX = 0;
        v12 = v6 * (2 * v7 + 2);
        __asm { seto    cl }
        v10 = sub_10021CF0(SHIDWORD(v12), v12 | -_ECX, v9, v6, v12 | -_ECX);
        if ( *(_DWORD *)a2 )
        {
          v13 = 0;
          if ( *(_DWORD *)(a2 + 8) )
          {
            do
            {
              ++v13;
              *(_DWORD *)(v10 + 4 * v13 - 4) = *(_DWORD *)(*(_DWORD *)a2 + 4 * v13 - 4);
            }
            while ( v13 < *(_DWORD *)(a2 + 8) );
          }
          sub_1002401B(*(LPVOID *)a2);
        }
        v8 = v18;
        *(_DWORD *)a2 = v10;
        *(_DWORD *)(a2 + 8) = v9;
        v6 = 4;
      }
      *(_DWORD *)(*(_DWORD *)a2 + 4 * *(_DWORD *)(a2 + 4)) = v8;
      v14 = v16;
      ++*(_DWORD *)(a2 + 4);
      ++v17;
      (*(void (__stdcall **)(int *))(*(_DWORD *)v14 + 20))(&v17);
      v18 = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)v16 + 24))(v17);
    }
    while ( v18 );
  }
  v20 = -1;
  sub_100242BA(&v15);
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (1001A200) --------------------------------------------------------
void *__userpurge sub_1001A200<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_1001A2F0(a1, a2);
  if ( a3 & 1 )
    sub_1002404A(v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1001A230) --------------------------------------------------------
int __thiscall sub_1001A230(int this, int a2)
{
  int v3; // ebx@1
  char v4; // [sp-14h] [bp-44h]@1
  char v5; // [sp-Ch] [bp-3Ch]@1
  int v6; // [sp-8h] [bp-38h]@1
  unsigned int v7; // [sp-4h] [bp-34h]@1
  int v8; // [sp+14h] [bp-1Ch]@1
  int v9; // [sp+18h] [bp-18h]@1
  unsigned int v10; // [sp+1Ch] [bp-14h]@1
  int v11; // [sp+2Ch] [bp-4h]@1
  int v12; // [sp+30h] [bp+0h]@1

  v10 = (unsigned int)&v12 ^ __security_cookie;
  v7 = (unsigned int)&v12 ^ __security_cookie;
  v3 = this;
  v8 = 0;
  v9 = 0;
  sub_100236C7((int)&v4, this, a2);
  *(_DWORD *)&v4 = &off_1005D2BC;
  v6 = *(_DWORD *)(a2 + 12);
  sub_1001A830(&v8, v3, (unsigned int)&off_1005D2BC);
  v11 = 0;
  sub_10023441((int)&v5, (int)&v8);
  (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 24))(v3);
  v11 = -1;
  return sub_100234E2((int)&v8);
}
// 10023441: using guessed type int __cdecl sub_10023441(int, int);
// 1005D2BC: using guessed type int (__stdcall *off_1005D2BC)(char);
// 10067210: using guessed type int __security_cookie;

//----- (1001A2F0) --------------------------------------------------------
void __usercall sub_1001A2F0(int a1<ecx>, int a2<ebx>)
{
  int v2; // esi@1

  v2 = a1;
  *(_DWORD *)a1 = off_1005CE54;
  if ( !sub_1002272F(a1) )
  {
    while ( sub_10022792(v2, 0) && !sub_1002272F(v2) )
      ;
  }
  sub_10022752((void *)v2);
  sub_10022654(v2, a2);
}
// 1005CE54: using guessed type int (__stdcall *off_1005CE54[3])(int, int, int);

//----- (1001A370) --------------------------------------------------------
int __fastcall sub_1001A370(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // ST08_4@1
  int v6; // ST0C_4@1
  int v7; // ST10_4@1
  int v8; // ST14_4@1
  void *v9; // [sp+Ch] [bp+4h]@1

  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  sub_1001A890(a1, a2, a3, a4, v5, v6, v7, v8);
  result = a3;
  *(_DWORD *)(*(_DWORD *)a3 + 148) = v9;
  return result;
}

//----- (1001A3B0) --------------------------------------------------------
#error "1001A47F: positive sp value has been found (funcsize=61)"

//----- (1001A490) --------------------------------------------------------
int __userpurge sub_1001A490<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5)
{
  int result; // eax@1
  int v6; // ST08_4@1
  int v7; // ST0C_4@1
  int v8; // ST10_4@1
  int v9; // ST14_4@1
  void *v10; // [sp+Ch] [bp+4h]@1

  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_1001AAF0(a1, a2, a3, a4, a5, v6, v7, v8, v9);
  result = a4;
  *(_DWORD *)(*(_DWORD *)a4 + 148) = v10;
  return result;
}

//----- (1001A4D0) --------------------------------------------------------
int __userpurge sub_1001A4D0<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // edi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_1005D2BC;
  *(_DWORD *)(v4 + 12) = *(_DWORD *)(a3 + 12);
  return v4;
}
// 1005D2BC: using guessed type int (__stdcall *off_1005D2BC)(char);

//----- (1001A500) --------------------------------------------------------
char __thiscall sub_1001A500(void *this)
{
  int v1; // eax@1
  int ebp0; // ebp@0
  void *v3; // esi@1
  char result; // al@2
  int v5; // ebx@3
  int v6; // edi@3
  int v7; // ecx@4
  int v8; // eax@5
  char v9; // al@7
  int v10; // esi@8
  int v11; // ebx@9
  signed int v12; // [sp-10h] [bp-5Ch]@11
  signed int v13; // [sp-Ch] [bp-58h]@11
  int v14; // [sp-8h] [bp-54h]@11
  int v15; // [sp+Ch] [bp-40h]@3
  int v16; // [sp+10h] [bp-3Ch]@3
  int v17; // [sp+14h] [bp-38h]@3
  int v18; // [sp+18h] [bp-34h]@1
  char v19; // [sp+1Eh] [bp-2Eh]@7
  char v20; // [sp+1Fh] [bp-2Dh]@3
  unsigned int v21; // [sp+3Ch] [bp-10h]@1
  int v22; // [sp+48h] [bp-4h]@3
  int v23; // [sp+4Ch] [bp+0h]@1

  v21 = (unsigned int)&v23 ^ __security_cookie;
  v3 = this;
  v18 = (int)this;
  v1 = *(_DWORD *)this;
  if ( *(_BYTE *)(*(_DWORD *)this + 73) )
  {
    result = 0;
  }
  else
  {
    v5 = 0;
    v6 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v22 = 0;
    v20 = 0;
    sub_1002426D(ebp0, v1 + 12);
    if ( !*(_BYTE *)(*(_DWORD *)v3 + 73) )
    {
      *(_BYTE *)(*(_DWORD *)v3 + 73) = 1;
      v7 = *(_DWORD *)v3;
      if ( &v15 != *(int **)v3 )
      {
        v5 = *(_DWORD *)v7;
        *(_DWORD *)v7 = 0;
        v6 = *(_DWORD *)(v7 + 4);
        *(_DWORD *)(v7 + 4) = 0;
        v8 = *(_DWORD *)(v7 + 8);
        v15 = v5;
        v16 = v6;
        v17 = v8;
        *(_DWORD *)(v7 + 8) = 0;
      }
      v20 = 1;
    }
    LOBYTE(v22) = 0;
    sub_100242C1();
    v9 = *(_DWORD *)(*(_DWORD *)v3 + 64) != 0;
    v19 = *(_DWORD *)(*(_DWORD *)v3 + 64) != 0;
    if ( v20 )
    {
      v10 = v5;
      if ( v5 != v6 )
      {
        v11 = v18;
        do
        {
          if ( v9 )
          {
            v14 = *(_DWORD *)v11 + 64;
            v13 = 1;
            v12 = 1;
          }
          else
          {
            v14 = *(_DWORD *)v10 + 92;
            v13 = 0;
            v12 = 0;
          }
          (*(void (__stdcall **)(signed int, signed int, signed int, int))(**(_DWORD **)v10 + 4))(1, v12, v13, v14);
          v9 = v19;
          v10 += 8;
        }
        while ( v10 != v6 );
        v5 = v15;
      }
    }
    if ( v5 )
    {
      sub_1001ACD0(v5, v6);
      sub_1002404A((LPVOID)v5);
    }
    result = v20;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (1001A630) --------------------------------------------------------
char __thiscall sub_1001A630(void *this, char a2, char a3, int a4, int a5)
{
  char v5; // bl@1
  int ebp0; // ebp@0
  int v7; // esi@1
  int v8; // eax@7
  int v10; // ecx@14
  char v11; // [sp+10h] [bp-4Ch]@1
  void **v12; // [sp+14h] [bp-48h]@18
  int v13; // [sp+18h] [bp-44h]@18
  int *v14; // [sp+24h] [bp-38h]@18
  unsigned int v15; // [sp+48h] [bp-14h]@1
  int v16; // [sp+58h] [bp-4h]@1

  v15 = (unsigned int)&v11 ^ __security_cookie;
  v7 = (int)this;
  v5 = 0;
  sub_1002426D(ebp0, (int)((char *)this + 100));
  v16 = 0;
  if ( !a3 )
  {
    v8 = *(_DWORD *)(v7 + 84);
    if ( v8 != 3 && v8 != 4 )
    {
      if ( v8 != 2 )
        goto LABEL_4;
      if ( a2 )
      {
LABEL_13:
        *(_DWORD *)(v7 + 84) = 4;
        sub_10025148(ebp0);
        v5 = 1;
        goto LABEL_14;
      }
    }
LABEL_11:
    v16 = -1;
    sub_100242C1();
    return 0;
  }
  if ( *(_DWORD *)(v7 + 84) == 4 )
    goto LABEL_11;
  sub_100202F0((void *)(v7 + 92), a5);
LABEL_4:
  if ( a2 || !*(_DWORD *)(v7 + 84) )
    goto LABEL_13;
  *(_DWORD *)(v7 + 84) = 2;
LABEL_14:
  v10 = *(_DWORD *)(v7 + 144);
  if ( v10 )
    sub_10025F04(v10 + 8, v5, a5);
  v16 = -1;
  sub_100242C1();
  if ( v5 )
  {
    sub_10025148(ebp0);
    if ( *(_DWORD *)(v7 + 132) )
    {
      v12 = &off_1005CC94;
      v13 = v7;
      v14 = (int *)&v12;
      v16 = 2;
      sub_100203A0((int)&v12, a5);
      sub_10001A60((int)&v12);
    }
  }
  return 1;
}
// 1005CC94: using guessed type void *off_1005CC94;
// 10067210: using guessed type int __security_cookie;

//----- (1001A780) --------------------------------------------------------
int __thiscall sub_1001A780(int this, char a2)
{
  int v2; // eax@1
  int ebp0; // ebp@0
  int v4; // esi@1
  int v5; // ecx@2

  v4 = this;
  *(_DWORD *)this = &off_1005CE4C;
  v2 = *(_DWORD *)(this + 140);
  if ( v2 )
  {
    sub_10027CF1(ebp0, v2);
    v5 = *(_DWORD *)(v4 + 140);
    _EDX = -1;
    _EAX = v5 + 4;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v5 + 4))();
    *(_DWORD *)(v4 + 140) = 0;
  }
  sub_10020640(v4);
  if ( a2 & 1 )
    sub_1002404A((LPVOID)v4);
  return v4;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005CE4C: using guessed type int (__stdcall *off_1005CE4C)(char);

//----- (1001A830) --------------------------------------------------------
void *__usercall sub_1001A830<eax>(void *a1<ecx>, int a2<ebx>, char a3)
{
  void *v4; // esi@1

  v4 = a1;
  sub_1001FDA0(a1, (int)&unk_1006162C);
  sub_100236FB((int)&a3, a2);
  return v4;
}

//----- (1001A890) --------------------------------------------------------
int __fastcall sub_1001A890(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // edi@1
  int v9; // esi@1
  int v10; // eax@3
  int v11; // esi@3
  int v12; // eax@4
  int v14; // [sp-8h] [bp-38h]@4
  int v15; // [sp-4h] [bp-34h]@3
  char v16; // [sp+14h] [bp-1Ch]@2
  int v17; // [sp+20h] [bp-10h]@1
  int v18; // [sp+2Ch] [bp-4h]@1

  v8 = a1;
  v18 = 0;
  v17 = 0;
  v9 = *(_DWORD *)a1;
  if ( !*(_DWORD *)a1 )
  {
    sub_10024934((int)&v16, (unsigned int)"then() cannot be called on a default constructed task.");
    sub_1002D02B((int)&v16, (int)&unk_100614E0);
  }
  v11 = *(_DWORD *)(v9 + 136);
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  sub_1001BFC0(a2, a3, v8, a1);
  v18 = 0;
  v17 = 1;
  sub_1001FCE0(a3, v11);
  *(_BYTE *)(*(_DWORD *)a3 + 88) = *(_BYTE *)(*(_DWORD *)v8 + 88) != 0;
  *(_BYTE *)(*(_DWORD *)a3 + 89) = 0;
  *(_BYTE *)(*(_DWORD *)a3 + 90) = 0;
  v10 = sub_10028682(a3, v8, 0x34u);
  if ( v10 )
    v12 = sub_1001B210(v10, v8, a3, a4, v14, v15);
  else
    v12 = 0;
  sub_1001F940(*(void **)v8, v12);
  return a3;
}

//----- (1001A980) --------------------------------------------------------
int __usercall sub_1001A980<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, unsigned int a4, void *a5, int a6, int a7, int a8, int a9, signed int a10, char a11)
{
  int v11; // eax@1
  int v12; // ecx@1
  int v13; // edi@1
  int v14; // esi@2
  int v23; // esi@6
  int v24; // eax@6
  int v25; // edx@6
  int v47; // [sp-Ch] [bp-48h]@4
  int v48; // [sp-8h] [bp-44h]@4
  int v49; // [sp-4h] [bp-40h]@2
  char v50; // [sp+14h] [bp-28h]@6
  int v51; // [sp+18h] [bp-24h]@6
  int v52; // [sp+1Ch] [bp-20h]@1
  int v53; // [sp+20h] [bp-1Ch]@4
  int v54; // [sp+24h] [bp-18h]@1
  int v55; // [sp+28h] [bp-14h]@1
  int v56; // [sp+38h] [bp-4h]@1

  v13 = a2;
  v52 = a2;
  v54 = 0;
  v56 = 3;
  v11 = sub_10027EB3(a1, a2, a3, a2, 116);
  v55 = v11;
  LOBYTE(v56) = 4;
  if ( v11 )
  {
    *(_DWORD *)(v11 + 4) = 0;
    *(_DWORD *)(v11 + 8) = 0;
    *(_DWORD *)(v11 + 16) = 0;
    *(_DWORD *)(v11 + 20) = 0;
    *(_DWORD *)(v11 + 48) = 0;
    *(_DWORD *)(v11 + 52) = 0;
    v49 = (int)&a11;
    *(_DWORD *)(v11 + 84) = 0;
    *(_DWORD *)(v11 + 88) = 0;
    v14 = sub_1001B320(v11, v13, v49);
  }
  else
  {
    v14 = 0;
  }
  v49 = (int)&v53;
  LOBYTE(v56) = 3;
  v48 = v13;
  v47 = v12;
  v53 = v14;
  if ( a4 )
  {
    _EAX = a4 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v24 = sub_1001ADE0(v14, (int)&v50, (int)&a5, a4);
  LOBYTE(v56) = 5;
  sub_1001BAE0(v25, v24, (int)&v47, v48, v49);
  LOBYTE(v56) = 3;
  v23 = v51;
  _EBX = -1;
  v54 = 1;
  if ( v51 )
  {
    _EAX = v51 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v23)(v23);
      _EAX = v23 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v23 + 4))(v23, _EDX);
    }
  }
  if ( (unsigned int)a10 >= 8 )
    sub_1002404A(a5);
  a10 = 7;
  a9 = 0;
  LOWORD(a5) = 0;
  LOBYTE(v56) = 1;
  sub_10004F60((int)&a11, -1);
  LOBYTE(v56) = 0;
  if ( a4 )
  {
    _EDX = a4 + 4;
    __asm { lock xadd [edx], ebx }
    if ( _EBX == 1 )
      (*(void (**)(void))(*(_DWORD *)a4 + 4))();
  }
  return v13;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1001AAF0) --------------------------------------------------------
int __userpurge sub_1001AAF0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // edi@1
  int v10; // eax@3
  int v11; // eax@4
  int v13; // [sp-8h] [bp-30h]@4
  int v14; // [sp-4h] [bp-2Ch]@3
  char v15; // [sp+Ch] [bp-1Ch]@2
  int v16; // [sp+18h] [bp-10h]@1
  int v17; // [sp+24h] [bp-4h]@1

  v9 = a2;
  v17 = 0;
  v16 = 0;
  if ( !*(_DWORD *)a2 )
  {
    sub_10024934((int)&v15, (unsigned int)"then() cannot be called on a default constructed task.");
    sub_1002D02B((int)&v15, (int)&unk_100614E0);
  }
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_1001BFC0(a1, a4, v9, a2);
  v17 = 0;
  v16 = 1;
  sub_1001B150(a4, 2);
  *(_BYTE *)(*(_DWORD *)a4 + 88) = *(_BYTE *)(*(_DWORD *)v9 + 88) != 0;
  *(_BYTE *)(*(_DWORD *)a4 + 89) = 0;
  *(_BYTE *)(*(_DWORD *)a4 + 90) = 0;
  v10 = sub_10028682(a3, v9, 0x40u);
  if ( v10 )
    v11 = sub_1001B5E0(v10, v9, a4, a5, v13, v14);
  else
    v11 = 0;
  sub_1001F940(*(void **)v9, v11);
  return a4;
}

//----- (1001ABD0) --------------------------------------------------------
char __thiscall sub_1001ABD0(void *this, char a2, int a3, int a4)
{
  int v4; // eax@1
  int ebp0; // ebp@0
  int v6; // edi@1
  void *v7; // esi@1
  int v8; // esi@4
  int v9; // eax@4
  char v24; // bl@8
  char v26; // [sp-Ch] [bp-4Ch]@4
  unsigned int v27; // [sp-4h] [bp-44h]@1
  char v28; // [sp+Ch] [bp-34h]@4
  int v29; // [sp+10h] [bp-30h]@4
  unsigned int v30; // [sp+30h] [bp-10h]@1
  int v31; // [sp+3Ch] [bp-4h]@1
  int v32; // [sp+40h] [bp+0h]@1

  v30 = (unsigned int)&v32 ^ __security_cookie;
  v27 = (unsigned int)&v32 ^ __security_cookie;
  v7 = this;
  v6 = a4;
  v31 = 0;
  sub_1002426D(ebp0, *(_DWORD *)this + 12);
  LOBYTE(v31) = 1;
  v4 = *(_DWORD *)v7;
  if ( *(_BYTE *)(*(_DWORD *)v7 + 72) || *(_BYTE *)(v4 + 73) || *(_DWORD *)(v4 + 64) )
  {
    v24 = 0;
  }
  else
  {
    sub_10023441((int)&v26, (int)&a2);
    v9 = sub_1001B0D0(v6, (int)&v28, v6, v26);
    sub_100021F0((void *)(*(_DWORD *)v7 + 64), v9);
    v8 = v29;
    if ( v29 )
    {
      _EDI = -1;
      _ECX = v29 + 4;
      _EAX = -1;
      __asm { lock xadd [ecx], eax }
      if ( _ZF )
      {
        (**(void (__thiscall ***)(_DWORD))v8)(v8);
        _EAX = v8 + 8;
        __asm { lock xadd [eax], edi }
        if ( _EDI == 1 )
          (*(void (__thiscall **)(int))(*(_DWORD *)v8 + 4))(v8);
      }
    }
    v24 = 1;
  }
  LOBYTE(v31) = 0;
  sub_100242C1();
  v31 = -1;
  sub_100234E2((int)&a2);
  return v24;
}
// 10023441: using guessed type int __cdecl sub_10023441(int, int);
// 10067210: using guessed type int __security_cookie;

//----- (1001ACD0) --------------------------------------------------------
int __fastcall sub_1001ACD0(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // edi@2
  int v4; // esi@3
  int result; // eax@7

  v2 = a2;
  if ( a1 != a2 )
  {
    v3 = a1 + 4;
    do
    {
      v4 = *(_DWORD *)v3;
      if ( *(_DWORD *)v3 )
      {
        _EAX = v4 + 4;
        _ECX = -1;
        __asm { lock xadd [eax], ecx }
        if ( _ZF )
        {
          (**(void (__thiscall ***)(_DWORD))v4)(v4);
          _EAX = v4 + 8;
          _ECX = -1;
          __asm { lock xadd [eax], ecx }
          if ( _ZF )
            (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 4))(v4);
        }
      }
      v3 += 8;
      result = v3 - 4;
    }
    while ( v3 - 4 != v2 );
  }
  return result;
}

//----- (1001AD20) --------------------------------------------------------
int __thiscall sub_1001AD20(void *this, int a2, int a3, int a4)
{
  int v4; // ecx@1
  int v5; // edi@4

  v4 = *(_DWORD *)this;
  if ( v4 )
    (**(void (__stdcall ***)(_DWORD))v4)(1);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  if ( (int *)a2 == &a3 )
  {
    v5 = a4;
  }
  else
  {
    *(_DWORD *)(a2 + 4) = a4;
    v5 = 0;
    a4 = 0;
    *(_DWORD *)a2 = a3;
    a3 = 0;
  }
  if ( v5 )
  {
    _EBX = -1;
    _ECX = v5 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      _EDX = v5 + 8;
      __asm { lock xadd [edx], ebx }
      if ( _EBX == 1 )
        (*(void (**)(void))(*(_DWORD *)v5 + 4))();
    }
  }
  return a2;
}

//----- (1001ADE0) --------------------------------------------------------
int __thiscall sub_1001ADE0(int this, int a2, int a3, unsigned int a4)
{
  int v4; // eax@1
  int v13; // esi@5
  int v14; // eax@5
  int v15; // edx@5
  __int16 v37; // [sp-28h] [bp-68h]@3
  void *v38; // [sp-24h] [bp-64h]@5
  int v39; // [sp-20h] [bp-60h]@5
  int v40; // [sp-1Ch] [bp-5Ch]@5
  int v41; // [sp-18h] [bp-58h]@3
  int v42; // [sp-14h] [bp-54h]@3
  int v43; // [sp-Ch] [bp-4Ch]@3
  int v44; // [sp-8h] [bp-48h]@3
  int v45; // [sp-4h] [bp-44h]@1
  int v46; // [sp+10h] [bp-30h]@1
  int (__stdcall **v47)(char); // [sp+14h] [bp-2Ch]@2
  char v48; // [sp+18h] [bp-28h]@5
  int v49; // [sp+1Ch] [bp-24h]@5
  int v50; // [sp+24h] [bp-1Ch]@1
  int v51; // [sp+28h] [bp-18h]@2
  unsigned int v52; // [sp+2Ch] [bp-14h]@1
  int v53; // [sp+3Ch] [bp-4h]@1
  int v54; // [sp+40h] [bp+0h]@1

  v52 = (unsigned int)&v54 ^ __security_cookie;
  v45 = (unsigned int)&v54 ^ __security_cookie;
  v4 = a3;
  v46 = a2;
  v50 = 0;
  v53 = 1;
  if ( *(_DWORD *)(this + 12) )
  {
    v51 = (int)"Request is not ready";
    sub_10023687((int)&v47, &v51);
    v47 = &off_100542C0;
    sub_1002D02B((int)&v47, (int)&unk_100615F0);
  }
  v44 = (int)&v51;
  v43 = a2;
  v51 = this;
  v42 = 7;
  v41 = 0;
  v37 = 0;
  loc_10020810(v4, 0, -1, this);
  if ( a4 )
  {
    _EAX = a4 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v14 = sub_1001BC40((int)&v48, *(int *)&v37, v38, v39, v40, v41, v42, a4, v43);
  LOBYTE(v53) = 2;
  sub_1001BE60(v15, v14, a2, v44, v45);
  LOBYTE(v53) = 1;
  v13 = v49;
  _EDI = -1;
  v50 = 1;
  if ( v49 )
  {
    _EAX = v49 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v13)(v13);
      _EAX = v13 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v13 + 4))(v13, _EDX);
    }
  }
  LOBYTE(v53) = 0;
  if ( a4 )
  {
    _EAX = a4 + 4;
    __asm { lock xadd [eax], edi }
    if ( _EDI == 1 )
      (*(void (**)(void))(*(_DWORD *)a4 + 4))();
  }
  return a2;
}
// 100542C0: using guessed type int (__stdcall *off_100542C0)(char);
// 10067210: using guessed type int __security_cookie;

//----- (1001AF20) --------------------------------------------------------
int __thiscall sub_1001AF20(void *this, int a2)
{
  int v2; // edx@1
  void *v3; // esi@1
  int v4; // ecx@1
  int v12; // eax@3
  int v13; // ecx@4
  int v14; // edi@5
  char v30; // [sp-8h] [bp-2Ch]@1
  int v31; // [sp-4h] [bp-28h]@3
  char v32; // [sp+10h] [bp-14h]@3
  int v33; // [sp+14h] [bp-10h]@5
  int v34; // [sp+1Ch] [bp-8h]@1

  v3 = this;
  v4 = *(_DWORD *)this;
  v34 = 0;
  sub_10020F80(v4, (int)((char *)v3 + 4));
  sub_10001AA0((int)&v30, *(_DWORD *)v3 + 84);
  v2 = *((_DWORD *)v3 + 7);
  if ( v2 )
  {
    _EAX = v2 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v12 = sub_1001BB20((int)&v32, v2, v30, v31);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  if ( a2 != v12 )
  {
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(v12 + 4);
    *(_DWORD *)(v12 + 4) = 0;
    v13 = *(_DWORD *)a2;
    *(_DWORD *)a2 = *(_DWORD *)v12;
    *(_DWORD *)v12 = v13;
  }
  v14 = v33;
  if ( v33 )
  {
    _EBX = -1;
    _ECX = v33 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v14)(v14);
      _EDX = v14 + 8;
      __asm { lock xadd [edx], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v14 + 4))(v14);
    }
  }
  return a2;
}

//----- (1001AFD0) --------------------------------------------------------
int __thiscall sub_1001AFD0(void *this, int a2, int a3, int a4)
{
  int v4; // eax@1
  int ebp0; // ebp@0
  int v6; // edi@1
  void *v7; // eax@3
  int v8; // edi@9

  v6 = *(_DWORD *)this;
  v4 = *(_DWORD *)(*(_DWORD *)this + 12);
  if ( v4 == 1 || v4 == 2 )
  {
    v7 = *(void **)(v6 + 4);
    *(_DWORD *)(v6 + 12) = 3;
    if ( v7 )
    {
      WinHttpCloseHandle(v7);
      sub_10025249(ebp0, (int)WinHttpCloseHandle, v6, 1000);
      *(_DWORD *)(v6 + 4) = 0;
    }
    if ( *(_DWORD *)(v6 + 8) )
    {
      WinHttpCloseHandle(*(HINTERNET *)(v6 + 8));
      *(_DWORD *)(v6 + 8) = 0;
    }
    *(_DWORD *)(v6 + 12) = 4;
  }
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  if ( (int *)a2 == &a3 )
  {
    v8 = a4;
  }
  else
  {
    *(_DWORD *)(a2 + 4) = a4;
    v8 = 0;
    a4 = 0;
    *(_DWORD *)a2 = a3;
    a3 = 0;
  }
  if ( v8 )
  {
    _EBX = -1;
    _ECX = v8 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v8)(v8);
      _EDX = v8 + 8;
      __asm { lock xadd [edx], ebx }
      if ( _EBX == 1 )
        (*(void (**)(void))(*(_DWORD *)v8 + 4))();
    }
  }
  return a2;
}

//----- (1001B0D0) --------------------------------------------------------
int __usercall sub_1001B0D0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, char a4)
{
  int v5; // esi@1
  int v6; // [sp+8h] [bp-14h]@1
  unsigned int v7; // [sp+Ch] [bp-10h]@1
  int v8; // [sp+18h] [bp-4h]@1
  int v9; // [sp+1Ch] [bp+0h]@1

  v7 = (unsigned int)&v9 ^ __security_cookie;
  v6 = a1;
  v5 = a2;
  v8 = 0;
  sub_10002120((int)&a4, a2, a3, (int)&v6);
  v8 = -1;
  sub_100234E2((int)&a4);
  return v5;
}
// 10067210: using guessed type int __security_cookie;

//----- (1001B150) --------------------------------------------------------
int __thiscall sub_1001B150(int this, int a2)
{
  int result; // eax@1
  int v4; // ecx@1
  int v5; // ebx@1
  int v7; // esi@3
  int v19; // esi@7
  int v31; // esi@12
  char v32; // [sp+10h] [bp-14h]@1
  char v33; // [sp+18h] [bp-Ch]@1
  int v34; // [sp+1Ch] [bp-8h]@7

  v5 = this;
  result = sub_1001B8A0(a2, (int)&v33, this);
  v4 = 0;
  _EDX = 0;
  if ( &v32 != (char *)result )
  {
    _EDX = *(_DWORD *)(result + 4);
    *(_DWORD *)(result + 4) = 0;
    v4 = *(_DWORD *)result;
    *(_DWORD *)result = 0;
  }
  v7 = *(_DWORD *)(v5 + 4);
  _EDI = -1;
  *(_DWORD *)(v5 + 4) = _EDX;
  *(_DWORD *)v5 = v4;
  if ( v7 )
  {
    result = v7 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v7)(v7);
      result = v7 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v7 + 4))(v7, _EDX);
    }
  }
  v19 = v34;
  if ( v34 )
  {
    result = v34 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v19)(v19);
      result = v19 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v19 + 4))(v19);
    }
  }
  if ( a2 != 2 )
  {
    v31 = *(_DWORD *)v5;
    result = sub_10027DED(_EDX, *(_DWORD *)(*(_DWORD *)v5 + 136), v5, (int)sub_1001FCC0, *(_DWORD *)v5, 1);
    *(_DWORD *)(v31 + 140) = result;
  }
  return result;
}

//----- (1001B210) --------------------------------------------------------
int __thiscall sub_1001B210(int this, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // esi@1

  v7 = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_BYTE *)(this + 25) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = &off_1005CE04;
  sub_10001AA0(this + 32, a3);
  *(_DWORD *)(v7 + 4) = sub_1001C080;
  *(_BYTE *)(v7 + 16) = 1;
  *(_DWORD *)v7 = &off_1005CE0C;
  sub_10001AA0(v7 + 40, a2);
  *(_DWORD *)(v7 + 48) = *(_DWORD *)a4;
  *(_BYTE *)(v7 + 25) = 0;
  *(_DWORD *)(v7 + 28) = 0;
  return v7;
}
// 1005CE04: using guessed type int (__stdcall *off_1005CE04)(char);
// 1005CE0C: using guessed type int (__stdcall *off_1005CE0C)(char);

//----- (1001B280) --------------------------------------------------------
int __thiscall sub_1001B280(int this)
{
  int v2; // edi@1
  int v3; // esi@1
  int result; // eax@2
  int v17; // edi@5

  v3 = this;
  *(_DWORD *)this = &off_1005CE0C;
  v2 = *(_DWORD *)(this + 44);
  _EBX = -1;
  if ( v2 )
  {
    result = v2 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v2)(v2);
      result = v2 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v2 + 4))(v2, _EDX);
    }
  }
  *(_DWORD *)v3 = &off_1005CE04;
  v17 = *(_DWORD *)(v3 + 36);
  if ( v17 )
  {
    result = v17 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v17)(v17);
      result = v17 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v17 + 4))(v17);
    }
  }
  *(_DWORD *)v3 = &off_10055E44;
  return result;
}
// 10055E44: using guessed type int (__stdcall *off_10055E44)(char);
// 1005CE04: using guessed type int (__stdcall *off_1005CE04)(char);
// 1005CE0C: using guessed type int (__stdcall *off_1005CE0C)(char);

//----- (1001B300) --------------------------------------------------------
int __thiscall sub_1001B300(int this, int a2)
{
  sub_1001BEA0(a2, this + 32, this);
  return a2;
}

//----- (1001B320) --------------------------------------------------------
int __userpurge sub_1001B320<eax>(int a1<ecx>, int a2<edi>, int a3)
{
  int v3; // ebx@1
  LPVOID *v4; // edi@1
  int v5; // esi@1
  int v6; // edx@1
  void *v8; // [sp+10h] [bp-50h]@1
  unsigned int v9; // [sp+24h] [bp-3Ch]@5
  int v10; // [sp+28h] [bp-38h]@1
  int (__stdcall **v11)(char); // [sp+2Ch] [bp-34h]@1
  void *v12; // [sp+30h] [bp-30h]@1
  int v13; // [sp+40h] [bp-20h]@1
  unsigned int v14; // [sp+44h] [bp-1Ch]@1
  char v15; // [sp+48h] [bp-18h]@1
  unsigned int v16; // [sp+4Ch] [bp-14h]@1
  int v17; // [sp+5Ch] [bp-4h]@1
  int v18; // [sp+60h] [bp+0h]@1

  v16 = (unsigned int)&v18 ^ __security_cookie;
  v3 = a1;
  v10 = a1;
  *(_DWORD *)a1 = &off_1005D328;
  *(_DWORD *)(a1 + 12) = 0;
  sub_10024BDF(a1 + 16);
  *(_DWORD *)(v3 + 76) = 15;
  *(_DWORD *)(v3 + 72) = 0;
  *(_BYTE *)(v3 + 56) = 0;
  *(_DWORD *)v3 = &off_1005CDCC;
  sub_1001C0A0(v6, v3 + 84, v3, a2);
  v17 = 1;
  v4 = (LPVOID *)(v3 + 92);
  *(_DWORD *)v3 = &off_1005CDE8;
  *(_DWORD *)(v3 + 112) = 15;
  *(_DWORD *)(v3 + 108) = 0;
  *(_BYTE *)(v3 + 92) = 0;
  v11 = &off_1005C6C8;
  v14 = 15;
  v13 = 0;
  LOBYTE(v12) = 0;
  v15 = 0;
  LOBYTE(v17) = 3;
  v5 = sub_10006890(&v11, (int)&v8, a3);
  if ( v3 + 92 != v5 )
  {
    if ( *(_DWORD *)(v3 + 112) >= 0x10u )
      sub_1002404A(*v4);
    *(_DWORD *)(v3 + 112) = 15;
    *(_DWORD *)(v3 + 108) = 0;
    *(_BYTE *)v4 = 0;
    sub_10002780((void *)(v3 + 92), v5);
  }
  if ( v9 >= 0x10 )
    sub_1002404A(v8);
  v11 = &off_1005C6C8;
  if ( v14 >= 0x10 )
    sub_1002404A(v12);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005C6C8: using guessed type int (__stdcall *off_1005C6C8)(char);
// 1005CDCC: using guessed type int (__stdcall *off_1005CDCC)(char);
// 1005CDE8: using guessed type int (__stdcall *off_1005CDE8)(char);
// 1005D328: using guessed type int (__stdcall *off_1005D328)(char);
// 10067210: using guessed type int __security_cookie;

//----- (1001B460) --------------------------------------------------------
void __thiscall sub_1001B460(int this, LPCWSTR pwszObjectName)
{
  int v2; // edi@1
  const WCHAR *v3; // esi@1
  const WCHAR *v4; // eax@5
  DWORD v5; // eax@7
  DWORD v6; // eax@10
  char v7; // [sp+Ch] [bp-48h]@1
  int (__stdcall **v8)(char); // [sp+10h] [bp-44h]@2
  int v9; // [sp+24h] [bp-30h]@2
  LPCWSTR pwszVerb; // [sp+28h] [bp-2Ch]@3
  int v11; // [sp+38h] [bp-1Ch]@3
  unsigned int v12; // [sp+3Ch] [bp-18h]@3
  unsigned int v13; // [sp+40h] [bp-14h]@1
  int v14; // [sp+50h] [bp-4h]@3

  v13 = (unsigned int)&v7 ^ __security_cookie;
  v2 = this;
  v3 = pwszObjectName;
  if ( !*(_DWORD *)(this + 8) )
  {
    v9 = (int)"Invalid connection";
    sub_10023687((int)&v8, &v9);
    v8 = &off_100542C0;
    sub_1002D02B((int)&v8, (int)&unk_100615F0);
  }
  v12 = 7;
  v11 = 0;
  LOWORD(pwszVerb) = 0;
  v14 = 0;
  loc_10020AC0(&pwszVerb, L"POST", 4);
  if ( *((_DWORD *)pwszObjectName + 5) >= 8u )
    v3 = *(const WCHAR **)pwszObjectName;
  v4 = (const WCHAR *)&pwszVerb;
  if ( v12 >= 8 )
    v4 = pwszVerb;
  v5 = (DWORD)WinHttpOpenRequest(*(HINTERNET *)(v2 + 8), v4, v3, 0, 0, 0, 0);
  *(_DWORD *)(v2 + 4) = v5;
  if ( !v5 )
  {
    v5 = GetLastError();
    sub_10020BC0(&v8, 9, v5);
    sub_1002D02B((int)&v8, (int)&unk_100617A0);
  }
  if ( WinHttpSetStatusCallback((HINTERNET)v5, (WINHTTP_STATUS_CALLBACK)fnInternetCallback, 0xFFFFFFFFu, 0) == (WINHTTP_STATUS_CALLBACK)-1 )
  {
    v6 = GetLastError();
    sub_10020BC0(&v8, 10, v6);
    sub_1002D02B((int)&v8, (int)&unk_100617A0);
  }
  if ( v12 >= 8 )
    sub_1002404A((LPVOID)pwszVerb);
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 100542C0: using guessed type int (__stdcall *off_100542C0)(char);
// 1005D314: using guessed type wchar_t aPost[5];
// 10067210: using guessed type int __security_cookie;

//----- (1001B5C0) --------------------------------------------------------
void __thiscall sub_1001B5C0(DWORD_PTR this)
{
  void *v1; // eax@1

  v1 = (void *)(this + 92);
  if ( *(_DWORD *)(this + 112) >= 0x10u )
    v1 = *(void **)v1;
  sub_10021540(this, v1, *(_DWORD *)(this + 108), *(_DWORD *)(this + 108), L"Content-Type: application/json");
}

//----- (1001B5E0) --------------------------------------------------------
int __thiscall sub_1001B5E0(int this, int a2, int a3, int a4, int a5, int a6)
{
  _ESI = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_BYTE *)(this + 25) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = &off_1005CE04;
  sub_10001AA0(this + 32, a3);
  *(_DWORD *)(_ESI + 4) = sub_1001C090;
  *(_BYTE *)(_ESI + 16) = 1;
  *(_DWORD *)_ESI = &off_1005CE0C;
  sub_10001AA0(_ESI + 40, a2);
  _EAX = a4;
  __asm
  {
    movq    xmm0, qword ptr [eax]
    movq    qword ptr [esi+30h], xmm0
    movq    xmm0, qword ptr [eax+8]
    movq    qword ptr [esi+38h], xmm0
  }
  *(_BYTE *)(_ESI + 25) = 1;
  *(_DWORD *)(_ESI + 28) = 0;
  return _ESI;
}
// 1005CE04: using guessed type int (__stdcall *off_1005CE04)(char);
// 1005CE0C: using guessed type int (__stdcall *off_1005CE0C)(char);

//----- (1001B660) --------------------------------------------------------
int __thiscall sub_1001B660(int this)
{
  int v1; // ecx@1
  int v2; // esi@1
  int result; // eax@6

  v2 = this;
  v1 = *(_DWORD *)(this + 28);
  if ( v1 )
  {
    _EAX = v1 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v1 + 4))();
  }
  *(_DWORD *)(v2 + 28) = 0;
  if ( *(_DWORD *)(v2 + 24) >= 8u )
    sub_1002404A(*(LPVOID *)(v2 + 4));
  result = 0;
  *(_DWORD *)(v2 + 24) = 7;
  *(_DWORD *)(v2 + 20) = 0;
  *(_WORD *)(v2 + 4) = 0;
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1001B6F0) --------------------------------------------------------
int __userpurge sub_1001B6F0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  int v4; // esi@1

  v4 = a1;
  sub_1001B280(a1);
  if ( a4 & 1 )
    sub_10028747(a2, a3, v4);
  return v4;
}

//----- (1001B720) --------------------------------------------------------
int __userpurge sub_1001B720<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int v20; // [sp-4h] [bp-Ch]@2

  v4 = a1;
  *(_DWORD *)a1 = &off_1005CE04;
  v3 = *(_DWORD *)(a1 + 36);
  if ( v3 )
  {
    v20 = a2;
    _EBX = -1;
    _EDX = v3 + 4;
    _EAX = -1;
    __asm { lock xadd [edx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v3)(v3);
      _EAX = v3 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
    }
    a2 = v20;
  }
  *(_DWORD *)v4 = &off_10055E44;
  if ( a3 & 1 )
    sub_10028747(a2, v3, v4);
  return v4;
}
// 10055E44: using guessed type int (__stdcall *off_10055E44)(char);
// 1005CE04: using guessed type int (__stdcall *off_1005CE04)(char);

//----- (1001B780) --------------------------------------------------------
void *__userpurge sub_1001B780<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_1001B7F0(a1, a2);
  if ( a3 & 1 )
    sub_1002404A(v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1001B7F0) --------------------------------------------------------
int __usercall sub_1001B7F0<eax>(int a1<ecx>, int _EBX<ebx>)
{
  int v2; // esi@1
  int v3; // edi@3

  v2 = a1;
  if ( *(_DWORD *)(a1 + 112) >= 0x10u )
    sub_1002404A(*(LPVOID *)(a1 + 92));
  *(_DWORD *)(v2 + 112) = 15;
  *(_DWORD *)(v2 + 108) = 0;
  *(_BYTE *)(v2 + 92) = 0;
  v3 = *(_DWORD *)(v2 + 88);
  if ( v3 )
  {
    _EBX = -1;
    _ECX = v3 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v3)(v3);
      _EAX = v3 + 8;
      __asm { lock xadd [eax], ebx }
      _EBX = _EBX - 1;
      if ( !_EBX )
        (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
    }
  }
  return sub_10020EB0(v2, _EBX, v3);
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1001B8A0) --------------------------------------------------------
int __usercall sub_1001B8A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v4; // esi@1
  int v5; // [sp+8h] [bp-8h]@1
  unsigned int v6; // [sp+Ch] [bp-4h]@1
  int v7; // [sp+10h] [bp+0h]@1

  v6 = (unsigned int)&v7 ^ __security_cookie;
  v5 = a1;
  v4 = a2;
  sub_1001BF10((int)&v5, a2, a3);
  return v4;
}
// 10067210: using guessed type int __security_cookie;

//----- (1001B8E0) --------------------------------------------------------
int __userpurge sub_1001B8E0<eax>(int a1<ecx>, int _EBX<ebx>, char a3)
{
  int v3; // edi@1
  int v4; // esi@1

  v4 = a1;
  v3 = *(_DWORD *)(a1 + 88);
  if ( v3 )
  {
    _EBX = -1;
    _ECX = v3 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v3)(v3);
      _EAX = v3 + 8;
      __asm { lock xadd [eax], ebx }
      _EBX = _EBX - 1;
      if ( !_EBX )
        (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
    }
  }
  sub_10020EB0(v4, _EBX, v3);
  if ( a3 & 1 )
    sub_1002404A((LPVOID)v4);
  return v4;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1001B980) --------------------------------------------------------
char __usercall sub_1001B980<al>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v3; // edi@1
  int v4; // esi@1
  char v5; // bl@3
  int (__stdcall **v7)(int); // [sp+Ch] [bp-88h]@5
  int v8; // [sp+10h] [bp-84h]@5
  int v9; // [sp+14h] [bp-80h]@5
  int v10; // [sp+18h] [bp-7Ch]@5
  int v11; // [sp+34h] [bp-60h]@5
  int v12; // [sp+38h] [bp-5Ch]@5
  int v13; // [sp+3Ch] [bp-58h]@5
  char v14; // [sp+40h] [bp-54h]@5
  int v15; // [sp+58h] [bp-3Ch]@5
  int v16; // [sp+5Ch] [bp-38h]@5
  void **v17; // [sp+68h] [bp-2Ch]@5
  int v18; // [sp+6Ch] [bp-28h]@5
  int v19; // [sp+70h] [bp-24h]@5
  int (__stdcall **v20)(int); // [sp+78h] [bp-1Ch]@3
  int v21; // [sp+7Ch] [bp-18h]@3
  int v22; // [sp+80h] [bp-14h]@3
  unsigned int v23; // [sp+84h] [bp-10h]@1
  int v24; // [sp+90h] [bp-4h]@3
  int v25; // [sp+94h] [bp+0h]@1

  v23 = (unsigned int)&v25 ^ __security_cookie;
  v3 = a1;
  v4 = a2;
  if ( a2
    && (unsigned __int8)(*(int (__cdecl **)(unsigned int))(*(_DWORD *)a2 + 12))((unsigned int)&v25 ^ __security_cookie) )
  {
    v20 = &off_1005CDA4;
    v21 = 0;
    v22 = 0;
    v24 = 0;
    v5 = sub_1001C5C0((int)&v20, a3, v4, v3);
    v20 = &off_1005CDA4;
    v24 = 1;
    if ( v21 )
      (*(void (__stdcall **)(signed int))(*(_DWORD *)v21 + 4))(1);
  }
  else
  {
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v15 = 0;
    v16 = 0;
    v18 = 0;
    v24 = 2;
    v7 = &off_1005CD7C;
    v8 = 0;
    sub_10024BDF((int)&v9);
    LOBYTE(v24) = 3;
    v13 = 2;
    sub_10024193((int)&v14);
    v17 = &off_1005CFF0;
    v18 = 0;
    v19 = 0;
    v24 = 4;
    v5 = sub_1001CB60(&v7, v4, v3);
    v24 = -1;
    sub_1001C6A0(&v7);
  }
  return v5;
}
// 1005CD7C: using guessed type int (__stdcall *off_1005CD7C)(int);
// 1005CDA4: using guessed type int (__stdcall *off_1005CDA4)(int);
// 1005CFF0: using guessed type void *off_1005CFF0;
// 10067210: using guessed type int __security_cookie;

//----- (1001BAE0) --------------------------------------------------------
int __userpurge sub_1001BAE0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5)
{
  int result; // eax@1
  int v6; // ST08_4@1
  int v7; // ST0C_4@1
  int v8; // ST10_4@1
  int v9; // ST14_4@1
  void *v10; // [sp+Ch] [bp+4h]@1

  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_1001D630(a1, a2, a3, a4, a5, v6, v7, v8, v9);
  result = a4;
  *(_DWORD *)(*(_DWORD *)a4 + 148) = v10;
  return result;
}

//----- (1001BB20) --------------------------------------------------------
int __thiscall sub_1001BB20(int this, int a2, char a3, int a4)
{
  int v5; // edi@1
  int v6; // esi@1
  int v21; // eax@5
  int v22; // edi@7
  int v23; // eax@7
  char v45; // [sp-Ch] [bp-40h]@7
  int v46; // [sp-8h] [bp-3Ch]@7
  int v47; // [sp-4h] [bp-38h]@7
  int v48; // [sp+14h] [bp-20h]@1
  char v49; // [sp+18h] [bp-1Ch]@1
  int v50; // [sp+1Ch] [bp-18h]@1
  int v51; // [sp+30h] [bp-4h]@1
  void *v52; // [sp+38h] [bp+4h]@7

  v6 = this;
  v48 = this;
  v51 = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  LOBYTE(v51) = 2;
  sub_10001AA0((int)&v49, (int)&a3);
  v5 = v50;
  _EBX = -1;
  if ( v50 )
  {
    _EAX = v50 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      _EAX = v5 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v5 + 4))(v5, _EDX);
    }
  }
  v21 = a2;
  if ( !a2 )
    v21 = 2;
  sub_1001C120(v6, v21);
  v23 = *(_DWORD *)v6;
  v47 = 0;
  *(_DWORD *)(v23 + 148) = v52;
  sub_10001AA0((int)&v45, (int)&a3);
  sub_1001D710(*(int *)&v45, v46);
  sub_1001DD10((int *)&a3, -1, v6);
  LOBYTE(v51) = 0;
  v22 = a4;
  if ( a4 )
  {
    _EAX = a4 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v22)(v22);
      _EAX = v22 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v22 + 4))(v22, _EDX);
    }
  }
  v51 = -1;
  if ( a2 )
  {
    _EDX = a2 + 4;
    __asm { lock xadd [edx], ebx }
    if ( _EBX == 1 )
      (*(void (**)(void))(*(_DWORD *)a2 + 4))();
  }
  return v6;
}

//----- (1001BC40) --------------------------------------------------------
int __thiscall sub_1001BC40(int this, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  int v10; // esi@1
  int v26; // eax@8
  void *v27; // eax@8
  int v28; // ecx@10
  int v36; // ecx@13
  int v51; // eax@20
  int v52; // eax@20
  int v53; // eax@21
  int v54; // ecx@23
  void *v62; // [sp+1Ch] [bp-54h]@1
  int v63; // [sp+2Ch] [bp-44h]@1
  unsigned int v64; // [sp+30h] [bp-40h]@1
  int v65; // [sp+34h] [bp-3Ch]@3
  int v66; // [sp+38h] [bp-38h]@13
  void *v67; // [sp+3Ch] [bp-34h]@13
  int v68; // [sp+4Ch] [bp-24h]@13
  unsigned int v69; // [sp+50h] [bp-20h]@13
  int v70; // [sp+54h] [bp-1Ch]@15
  int v71; // [sp+5Ch] [bp-14h]@8
  int v72; // [sp+60h] [bp-10h]@20
  int v73; // [sp+6Ch] [bp-4h]@1
  void *v74; // [sp+74h] [bp+4h]@13

  v10 = this;
  v73 = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  LOBYTE(v73) = 1;
  LOWORD(v62) = 0;
  v64 = 7;
  v63 = 0;
  loc_10020810(&v62, &a3, 0, -1);
  v9 = a9;
  if ( a9 )
  {
    _EAX = a9 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v65 = v9;
  _EBX = -1;
  LOBYTE(v73) = 2;
  if ( v9 )
  {
    _EAX = v9 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (__thiscall **)(int))(*(_DWORD *)v9 + 4))(v9);
  }
  v65 = 0;
  if ( v64 >= 8 )
    sub_1002404A(v62);
  v27 = sub_10004CE0(&v71);
  LOBYTE(v73) = 3;
  v26 = *(_DWORD *)v27;
  if ( !v26 )
    v26 = 2;
  sub_1001C120(v10, v26);
  LOBYTE(v73) = 1;
  v28 = v71;
  if ( v71 )
  {
    _EAX = v71 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v28 + 4))();
  }
  *(_DWORD *)(*(_DWORD *)v10 + 148) = v74;
  v66 = a2;
  LOWORD(v67) = 0;
  v69 = 7;
  v68 = 0;
  loc_10020810(&v67, &a3, 0, -1);
  v36 = a9;
  if ( a9 )
  {
    _EAX = a9 + 4;
    _EDX = 1;
    __asm { lock xadd [eax], edx }
  }
  v70 = v36;
  LOBYTE(v73) = 4;
  if ( v36 )
  {
    _EAX = v36 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v36 + 4))();
  }
  LOBYTE(v73) = 1;
  v70 = 0;
  if ( v69 >= 8 )
    sub_1002404A(v67);
  LOWORD(v67) = 0;
  v52 = *(_DWORD *)v10;
  v69 = 7;
  v68 = 0;
  *(_BYTE *)(v52 + 88) = 0;
  *(_BYTE *)(*(_DWORD *)v10 + 90) = 1;
  v51 = sub_10028682(-1, v9, 0x3Cu);
  v72 = v51;
  LOBYTE(v73) = 5;
  if ( v51 )
    v53 = sub_1001E230(v51, v10, (int)&a2);
  else
    v53 = 0;
  LOBYTE(v73) = 1;
  sub_100016A0(*(_DWORD *)v10, -1, v9, v53, 0);
  v73 = 6;
  v54 = a9;
  if ( a9 )
  {
    _EAX = a9 + 4;
    __asm { lock xadd [eax], ebx }
    if ( _EBX == 1 )
      (*(void (**)(void))(*(_DWORD *)v54 + 4))();
  }
  a9 = 0;
  if ( a8 >= 8 )
    sub_1002404A(a3);
  return v10;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1001BE60) --------------------------------------------------------
int __userpurge sub_1001BE60<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5)
{
  int result; // eax@1
  int v6; // ST08_4@1
  int v7; // ST0C_4@1
  int v8; // ST10_4@1
  int v9; // ST14_4@1
  void *v10; // [sp+Ch] [bp+4h]@1

  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_1001D750(a1, a2, a3, a4, a5, v6, v7, v8, v9);
  result = a4;
  *(_DWORD *)(*(_DWORD *)a4 + 148) = v10;
  return result;
}

//----- (1001BEA0) --------------------------------------------------------
int __thiscall sub_1001BEA0(int this, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // esi@1
  int v12; // edi@3
  int v28; // [sp+14h] [bp+8h]@1

  v4 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  v3 = *(_DWORD *)(a2 + 4);
  v28 = *(_DWORD *)a2;
  if ( v3 )
  {
    _EAX = v3 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v12 = *(_DWORD *)(v4 + 4);
  if ( v12 )
  {
    _ECX = v12 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v12)(v12);
      _EAX = v12 + 8;
      _ECX = -1;
      __asm { lock xadd [eax], ecx }
      if ( _ZF )
        (*(void (__thiscall **)(int))(*(_DWORD *)v12 + 4))(v12);
    }
  }
  *(_DWORD *)v4 = v28;
  *(_DWORD *)(v4 + 4) = v3;
  return v4;
}

//----- (1001BF10) --------------------------------------------------------
int __usercall sub_1001BF10<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v3; // eax@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ebx@2
  int *v8; // [sp+20h] [bp-10h]@1

  v8 = (int *)a1;
  v4 = a2;
  v3 = sub_10027EB3(a1, a2, a3, a2, 168);
  v5 = v3;
  if ( v3 )
  {
    *(_DWORD *)(v3 + 4) = 1;
    *(_DWORD *)(v3 + 8) = 1;
    v6 = v3 + 12;
    *(_DWORD *)v3 = off_1005CD4C;
    if ( v3 != -12 )
    {
      sub_1001FB00((void *)(v3 + 12), *v8);
      *(_DWORD *)v6 = &off_1005CE4C;
    }
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)v4 = v5 + 12;
  *(_DWORD *)(v4 + 4) = v5;
  return v4;
}
// 1005CD4C: using guessed type int (*off_1005CD4C[2])();
// 1005CE4C: using guessed type int (__stdcall *off_1005CE4C)(char);

//----- (1001BFC0) --------------------------------------------------------
int __userpurge sub_1001BFC0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4)
{
  int result; // eax@1
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // edi@4
  char v20; // [sp+0h] [bp-20h]@1
  char *v21; // [sp+10h] [bp-10h]@1
  int v22; // [sp+1Ch] [bp-4h]@1

  v21 = &v20;
  v5 = a2;
  v22 = 0;
  result = sub_10027EB3(a1, a2, a2, a3, 16);
  v6 = result;
  if ( result )
  {
    *(_DWORD *)(result + 4) = 1;
    *(_DWORD *)(result + 8) = 1;
    *(_DWORD *)result = off_1005CD6C;
    *(_DWORD *)(result + 12) = 0;
  }
  else
  {
    v6 = 0;
  }
  v7 = *(_DWORD *)(v5 + 4);
  if ( v7 )
  {
    _ECX = v7 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v7)(v7);
      result = v7 + 8;
      _ECX = -1;
      __asm { lock xadd [eax], ecx }
      if ( _ZF )
        result = (*(int (**)(void))(*(_DWORD *)v7 + 4))();
    }
  }
  *(_DWORD *)(v5 + 4) = v6;
  *(_DWORD *)v5 = 0;
  return result;
}
// 1005CD6C: using guessed type int (*off_1005CD6C[2])();

//----- (1001C080) --------------------------------------------------------
void __cdecl sub_1001C080(int a2)
{
  sub_1001C1E0(a2);
}

//----- (1001C090) --------------------------------------------------------
void __cdecl sub_1001C090(int a2)
{
  sub_1001C2E0(a2);
}

//----- (1001C0A0) --------------------------------------------------------
int __usercall sub_1001C0A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // esi@1
  int v6; // eax@2

  v5 = a2;
  v4 = sub_10027EB3(a1, a2, a3, a4, 96);
  if ( v4 )
    v6 = sub_1001CD10(v4);
  else
    v6 = 0;
  *(_DWORD *)(v5 + 4) = v6;
  *(_DWORD *)v5 = v6 + 16;
  return v5;
}

//----- (1001C120) --------------------------------------------------------
int __thiscall sub_1001C120(int this, int a2)
{
  int result; // eax@1
  int v4; // ecx@1
  int v5; // ebx@1
  int v7; // esi@3
  int v19; // esi@7
  int v31; // esi@12
  char v32; // [sp+10h] [bp-14h]@1
  char v33; // [sp+18h] [bp-Ch]@1
  int v34; // [sp+1Ch] [bp-8h]@7

  v5 = this;
  result = sub_1001CFD0(a2, (int)&v33, this);
  v4 = 0;
  _EDX = 0;
  if ( &v32 != (char *)result )
  {
    _EDX = *(_DWORD *)(result + 4);
    *(_DWORD *)(result + 4) = 0;
    v4 = *(_DWORD *)result;
    *(_DWORD *)result = 0;
  }
  v7 = *(_DWORD *)(v5 + 4);
  _EDI = -1;
  *(_DWORD *)(v5 + 4) = _EDX;
  *(_DWORD *)v5 = v4;
  if ( v7 )
  {
    result = v7 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v7)(v7);
      result = v7 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v7 + 4))(v7, _EDX);
    }
  }
  v19 = v34;
  if ( v34 )
  {
    result = v34 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v19)(v19);
      result = v19 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v19 + 4))(v19);
    }
  }
  if ( a2 != 2 )
  {
    v31 = *(_DWORD *)v5;
    result = sub_10027DED(_EDX, *(_DWORD *)(*(_DWORD *)v5 + 136), v5, (int)sub_1001FCC0, *(_DWORD *)v5, 1);
    *(_DWORD *)(v31 + 140) = result;
  }
  return result;
}

//----- (1001C1E0) --------------------------------------------------------
void __thiscall sub_1001C1E0(int this)
{
  int ebp0; // ebp@0
  int v2; // esi@1
  unsigned int v3; // [sp-4h] [bp-54h]@1
  int v4; // [sp+14h] [bp-3Ch]@4
  int v5; // [sp+18h] [bp-38h]@4
  int v6; // [sp+1Ch] [bp-34h]@1
  unsigned int v7; // [sp+3Ch] [bp-14h]@1
  unsigned int *v8; // [sp+40h] [bp-10h]@1
  int v9; // [sp+4Ch] [bp-4h]@1
  int v10; // [sp+50h] [bp+0h]@1

  v7 = (unsigned int)&v10 ^ __security_cookie;
  v3 = (unsigned int)&v10 ^ __security_cookie;
  v8 = &v3;
  v2 = *(_DWORD *)(this + 32);
  v6 = this;
  sub_1002426D(ebp0, v2 + 100);
  v9 = -1;
  if ( *(_DWORD *)(v2 + 84) == 4 )
  {
    sub_100242C1();
  }
  else
  {
    *(_DWORD *)(v2 + 84) = 1;
    sub_100242C1();
    v9 = 1;
    LOBYTE(v4) = 0;
    LOBYTE(v5) = 0;
    sub_1001D130(v5, v4);
  }
}
// 1001D130: using guessed type _DWORD __stdcall sub_1001D130(_DWORD, _DWORD);
// 10067210: using guessed type int __security_cookie;

//----- (1001C2E0) --------------------------------------------------------
void __thiscall sub_1001C2E0(int this)
{
  int ebp0; // ebp@0
  int v2; // edi@1
  int v3; // esi@1
  int v4; // edx@4
  unsigned int v5; // [sp-4h] [bp-54h]@1
  int v6; // [sp+14h] [bp-3Ch]@4
  int v7; // [sp+18h] [bp-38h]@4
  int v8; // [sp+1Ch] [bp-34h]@1
  unsigned int v9; // [sp+3Ch] [bp-14h]@1
  unsigned int *v10; // [sp+40h] [bp-10h]@1
  int v11; // [sp+4Ch] [bp-4h]@1
  int v12; // [sp+50h] [bp+0h]@1

  v9 = (unsigned int)&v12 ^ __security_cookie;
  v5 = (unsigned int)&v12 ^ __security_cookie;
  v10 = &v5;
  v2 = this;
  v3 = *(_DWORD *)(this + 32);
  v8 = this;
  sub_1002426D(ebp0, v3 + 100);
  v11 = -1;
  if ( *(_DWORD *)(v3 + 84) == 4 )
  {
    sub_100242C1();
  }
  else
  {
    *(_DWORD *)(v3 + 84) = 1;
    sub_100242C1();
    v11 = 1;
    LOBYTE(v6) = 0;
    LOBYTE(v7) = 0;
    sub_1001D260(v4, v2, v2, v7, v6);
  }
}
// 10067210: using guessed type int __security_cookie;

//----- (1001C3E0) --------------------------------------------------------
int *__thiscall sub_1001C3E0(int this)
{
  int *result; // eax@1
  int v2; // ecx@1
  int v3; // esi@1
  int v4; // [sp+Ch] [bp-Ch]@1
  int v5; // [sp+14h] [bp-4h]@1

  result = &v4;
  v3 = this;
  *(_DWORD *)this = &off_1005CDA4;
  v5 = 0;
  v2 = *(_DWORD *)(this + 4);
  if ( v2 )
    result = (int *)(*(int (__stdcall **)(signed int))(*(_DWORD *)v2 + 4))(1);
  *(_DWORD *)v3 = &off_1005D1A8;
  return result;
}
// 1005CDA4: using guessed type int (__stdcall *off_1005CDA4)(int);
// 1005D1A8: using guessed type int (__stdcall *off_1005D1A8)(char);

//----- (1001C4A0) --------------------------------------------------------
int __thiscall sub_1001C4A0(int this, int a2, int a3)
{
  int result; // eax@2

  if ( a3 == *(_DWORD *)(this + 8) && (result = *(_DWORD *)(this + 4)) != 0 && *(_DWORD *)(result + 4) == a2 )
    *(_DWORD *)(this + 4) = 0;
  else
    result = 0;
  return result;
}

//----- (1001C5C0) --------------------------------------------------------
char __userpurge sub_1001C5C0<al>(int a1<ecx>, int a2<ebx>, int a3, int a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  int v8; // ecx@4

  v5 = a1;
  *(_DWORD *)(a1 + 8) = a3;
  v4 = sub_10028682(a2, a1, 0x14u);
  v6 = v4;
  if ( v4 )
  {
    *(_DWORD *)(v4 + 12) = 0;
    sub_10022A06(v4);
    *(_DWORD *)v6 = &off_1005CE78;
    *(_DWORD *)(v6 + 8) = *(_DWORD *)a4;
    *(_DWORD *)(v6 + 12) = 0;
    *(_DWORD *)(v6 + 16) = 0;
  }
  else
  {
    v6 = 0;
  }
  v8 = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(v5 + 4) = v6;
  return (*(int (__cdecl **)(int, int))(*(_DWORD *)v8 + 8))(v6, v5) == 0;
}
// 1005CE78: using guessed type int (*off_1005CE78)();

//----- (1001C6A0) --------------------------------------------------------
int __thiscall sub_1001C6A0(void *this)
{
  int v1; // ecx@1
  int ebp0; // ebp@0
  int v3; // esi@1
  char v4; // zf@3
  int result; // eax@5
  char v6; // [sp+8h] [bp-1Ch]@4
  void *v7; // [sp+14h] [bp-10h]@1
  int v8; // [sp+20h] [bp-4h]@1

  v3 = (int)this;
  v7 = this;
  *(_DWORD *)this = &off_1005CD7C;
  v8 = 3;
  sub_1001C810(this);
  sub_1001D010(v3);
  v1 = *(_DWORD *)(v3 + 4);
  if ( v1 )
    (*(void (__stdcall **)(signed int))(*(_DWORD *)v1 + 4))(1);
  LOBYTE(v8) = 2;
  v4 = *(_DWORD *)(v3 + 96) == 0;
  *(_DWORD *)(v3 + 92) = &off_1005CFF0;
  if ( !v4 )
  {
    sub_10024934((int)&v6, (unsigned int)"Deleting link registry before removing all the links");
    sub_1002D02B((int)&v6, (int)&unk_100614E0);
  }
  LOBYTE(v8) = 1;
  nullsub_2(v3 + 52);
  LOBYTE(v8) = 0;
  result = sub_10024C22(ebp0);
  *(_DWORD *)v3 = &off_1005D1A8;
  return result;
}
// 10024CC5: using guessed type int __thiscall nullsub_2(_DWORD);
// 1005CD7C: using guessed type int (__stdcall *off_1005CD7C)(int);
// 1005CFF0: using guessed type void *off_1005CFF0;
// 1005D1A8: using guessed type int (__stdcall *off_1005D1A8)(char);

//----- (1001C750) --------------------------------------------------------
void __thiscall sub_1001C750(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1
  unsigned int v4; // [sp-4h] [bp-48h]@1
  int (__stdcall **v5)(char); // [sp+8h] [bp-3Ch]@2
  int v6; // [sp+14h] [bp-30h]@2
  char v7; // [sp+18h] [bp-2Ch]@5
  unsigned int v8; // [sp+34h] [bp-10h]@1
  int v9; // [sp+40h] [bp-4h]@3
  int v10; // [sp+44h] [bp+0h]@1

  v8 = (unsigned int)&v10 ^ __security_cookie;
  v4 = (unsigned int)&v10 ^ __security_cookie;
  v3 = this;
  if ( !a2 )
  {
    v6 = (int)"_PTarget";
    sub_10023687((int)&v5, &v6);
    v5 = &off_100542CC;
    sub_1002D02B((int)&v5, (int)&unk_10061764);
  }
  sub_100241EF(ebp0, (int)((char *)v3 + 52));
  v9 = 0;
  if ( (unsigned __int8)(*(int (__stdcall **)(int, unsigned int))(*((_DWORD *)v3 + 23) + 4))(a2, v4) )
  {
    (*(void (__thiscall **)(int, void *))(*(_DWORD *)a2 + 20))(a2, v3);
    *((_DWORD *)v3 + 12) = 1;
    sub_10025148(ebp0);
  }
  v9 = -1;
  sub_100242BA(&v7);
}
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);
// 10067210: using guessed type int __security_cookie;

//----- (1001C810) --------------------------------------------------------
void __thiscall sub_1001C810(void *this)
{
  int ebp0; // ebp@0
  void *v2; // edi@1
  unsigned int v3; // ST04_4@1
  int v4; // eax@1
  int v5; // esi@2
  int (__thiscall *v6)(_DWORD, _DWORD); // eax@2
  char v7; // [sp+Ch] [bp-38h]@5
  int v8; // [sp+28h] [bp-1Ch]@1
  int v9; // [sp+2Ch] [bp-18h]@1
  int i; // [sp+30h] [bp-14h]@1
  unsigned int v11; // [sp+34h] [bp-10h]@1
  int v12; // [sp+40h] [bp-4h]@1
  int v13; // [sp+44h] [bp+0h]@1

  v11 = (unsigned int)&v13 ^ __security_cookie;
  v3 = (unsigned int)&v13 ^ __security_cookie;
  v2 = this;
  sub_100241EF(ebp0, (int)((char *)this + 52));
  v12 = 0;
  v4 = *((_DWORD *)v2 + 23);
  v8 = 0;
  i = 0;
  (*(void (__thiscall **)(char *, int *, unsigned int))(v4 + 16))((char *)v2 + 92, &v8, v3);
  for ( i = (*(int (__stdcall **)(int))(*(_DWORD *)v8 + 24))(v9);
        i;
        i = (*(int (__stdcall **)(int))(*(_DWORD *)v8 + 24))(v9) )
  {
    v5 = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)v8 + 24))(v9);
    v6 = *(int (__thiscall **)(_DWORD, _DWORD))(*((_DWORD *)v2 + 23) + 4);
    i = v5;
    if ( (unsigned __int8)v6((char *)v2 + 92, v5) )
      (*(void (__thiscall **)(int, void *))(*(_DWORD *)v5 + 20))(v5, v2);
    ++v9;
    (*(void (__stdcall **)(int *))(*(_DWORD *)v8 + 20))(&v9);
  }
  *((_DWORD *)v2 + 12) = 1;
  sub_10025148(ebp0);
  v12 = -1;
  sub_100242BA(&v7);
}
// 10067210: using guessed type int __security_cookie;

//----- (1001C910) --------------------------------------------------------
int __thiscall sub_1001C910(int this, int a2, int a3)
{
  int ebp0; // ebp@0
  int v4; // esi@1
  int result; // eax@2
  int v6; // edi@4

  v4 = this;
  if ( a3 && (unsigned __int8)(*(int (__thiscall **)(int, int))(*(_DWORD *)(this + 92) + 8))(this + 92, a3) )
  {
    v6 = *(_DWORD *)(v4 + 4);
    if ( v6 && *(_DWORD *)(v6 + 4) == a2 )
    {
      *(_DWORD *)(v4 + 4) = 0;
      *(_DWORD *)(v4 + 48) = 0;
      sub_10025148(ebp0);
      result = v6;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001CB40) --------------------------------------------------------
int __thiscall sub_1001CB40(void *this, int a2)
{
  int result; // eax@1

  _ECX = (int)((char *)this + 100);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (1001CB50) --------------------------------------------------------
int __thiscall sub_1001CB50(void *this, int a2)
{
  int result; // eax@1

  _ECX = (int)((char *)this + 100);
  _EAX = -1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (1001CB60) --------------------------------------------------------
bool __thiscall sub_1001CB60(void *this, int a2, int a3)
{
  int ebp0; // ebp@0
  int v4; // edi@1
  int v5; // eax@3
  int v6; // esi@3
  int v7; // esi@6
  unsigned int v9; // [sp-4h] [bp-4Ch]@1
  int (__stdcall **v10)(char); // [sp+Ch] [bp-3Ch]@2
  int v11; // [sp+18h] [bp-30h]@2
  char v12; // [sp+1Ch] [bp-2Ch]@6
  unsigned int v13; // [sp+38h] [bp-10h]@1
  int v14; // [sp+44h] [bp-4h]@3
  int v15; // [sp+48h] [bp+0h]@1

  v13 = (unsigned int)&v15 ^ __security_cookie;
  v9 = (unsigned int)&v15 ^ __security_cookie;
  v4 = (int)this;
  if ( !a2 )
  {
    v11 = (int)"_PTarget";
    sub_10023687((int)&v10, &v11);
    v10 = &off_100542CC;
    sub_1002D02B((int)&v10, (int)&unk_10061764);
  }
  v5 = sub_10028682(a2, v4, 0x14u);
  v6 = v5;
  v11 = v5;
  v14 = 0;
  if ( v5 )
  {
    *(_DWORD *)(v5 + 12) = 0;
    sub_10022A06(v5);
    *(_DWORD *)v6 = &off_1005CE78;
    *(_DWORD *)(v6 + 8) = *(_DWORD *)a3;
    *(_DWORD *)(v6 + 12) = 0;
    *(_DWORD *)(v6 + 16) = 0;
  }
  else
  {
    v6 = 0;
  }
  v14 = -1;
  sub_100241EF(ebp0, v4 + 52);
  v14 = 1;
  (*(void (__thiscall **)(int, int, unsigned int))(*(_DWORD *)v4 + 4))(v4, a2, v9);
  *(_DWORD *)(v4 + 4) = v6;
  v7 = (*(int (__thiscall **)(int, int, int))(*(_DWORD *)a2 + 8))(a2, v6, v4);
  v14 = -1;
  sub_100242BA(&v12);
  if ( v7 == 2 )
  {
    sub_10025249(ebp0, a2, v4, -1);
    v7 = *(_DWORD *)(v4 + 48);
  }
  return v7 == 0;
}
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);
// 1005CE78: using guessed type int (*off_1005CE78)();
// 10067210: using guessed type int __security_cookie;

//----- (1001CCF0) --------------------------------------------------------
int __thiscall sub_1001CCF0(int this)
{
  return (**(int (__thiscall ***)(_DWORD, _DWORD))(this + 12))(this + 12, 0);
}

//----- (1001CD00) --------------------------------------------------------
int __thiscall sub_1001CD00(int this)
{
  int v1; // ecx@1
  int result; // eax@2

  v1 = *(_DWORD *)(this + 12);
  if ( v1 )
    result = (**(int (__stdcall ***)(_DWORD))v1)(1);
  return result;
}

//----- (1001CD10) --------------------------------------------------------
int __thiscall sub_1001CD10(int this)
{
  int v1; // edi@1
  int v2; // esi@1

  v1 = this;
  *(_DWORD *)(this + 4) = 1;
  *(_DWORD *)(this + 8) = 1;
  v2 = this + 16;
  *(_DWORD *)this = &off_1005CD5C;
  if ( this != -16 )
  {
    *(_DWORD *)v2 = 0;
    *(_DWORD *)(this + 20) = 0;
    *(_DWORD *)(this + 24) = 0;
    sub_10024232(this + 28);
    *(_BYTE *)(v2 + 56) = 0;
    *(_DWORD *)(v2 + 56) &= 0xFFFFFEFFu;
    *(_DWORD *)(v2 + 60) = 0;
    *(_DWORD *)(v2 + 64) = 0;
    *(_DWORD *)(v2 + 68) = 0;
    *(_WORD *)(v2 + 72) = 0;
  }
  return v1;
}
// 1005CD5C: using guessed type int (__stdcall *off_1005CD5C)(int);

//----- (1001CDC0) --------------------------------------------------------
int __userpurge sub_1001CDC0<eax>(int a1<eax>, int a2<ecx>, int _EBX<ebx>, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@3
  int v20; // eax@7
  void *v21; // esi@9
  int v22; // eax@14
  void *v23; // esi@15
  int result; // eax@16
  char v25; // [sp-18h] [bp-18h]@10
  int v26; // [sp-14h] [bp-14h]@1
  int v27; // [sp-10h] [bp-10h]@1
  int (__cdecl *v28)(int, int); // [sp-Ch] [bp-Ch]@1
  signed int v29; // [sp-8h] [bp-8h]@1

  v28 = sub_10052529;
  v27 = a1;
  v4 = a2 + 16;
  v26 = a2 + 16;
  v29 = 3;
  v5 = *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 20) )
  {
    do
    {
      (*(void (__stdcall **)(signed int, _DWORD, _DWORD, int))(**(_DWORD **)v5 + 4))(1, 0, 0, *(_DWORD *)v5 + 92);
      v5 += 8;
    }
    while ( v5 != *(_DWORD *)(v4 + 4) );
  }
  LOBYTE(v29) = 2;
  v6 = *(_DWORD *)(v4 + 68);
  if ( v6 )
  {
    _EBX = -1;
    _ECX = v6 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v6)(v6);
      _EAX = v6 + 8;
      __asm { lock xadd [eax], ebx }
      _EBX = _EBX - 1;
      if ( !_EBX )
        (*(void (__thiscall **)(int))(*(_DWORD *)v6 + 4))(v6);
    }
  }
  LOBYTE(v29) = 1;
  v20 = *(_BYTE *)(v4 + 56);
  if ( v20 == 4 )
  {
    if ( *(_DWORD *)(v4 + 56) & 0x100 )
    {
      if ( *(_DWORD *)(v4 + 48) )
        sub_100282F6(_EBX, *(LPVOID *)(v4 + 48));
    }
  }
  else
  {
    if ( (unsigned int)(v20 - 6) <= 1 )
    {
      v21 = *(void **)(v4 + 48);
      if ( v21 )
      {
        sub_10007E80(v21, (int)&v25, **(_DWORD **)v21, *(_DWORD *)v21);
        sub_1002404A(*(LPVOID *)v21);
        sub_1002404A(v21);
      }
    }
  }
  v22 = *(_DWORD *)(v4 + 60);
  if ( v22 )
  {
    v23 = (void *)(v22 - 4);
    sub_10023E14(v22, 4, *(_DWORD *)(v22 - 4), (void (__thiscall *)(_DWORD))sub_10004CF0);
    sub_1002401B(v23);
  }
  LOBYTE(v29) = 0;
  result = nullsub_2(v4 + 12);
  if ( *(_DWORD *)v4 )
  {
    sub_1001ACD0(*(_DWORD *)v4, *(_DWORD *)(v4 + 4));
    result = sub_1002404A(*(LPVOID *)v4);
    *(_DWORD *)v4 = 0;
    *(_DWORD *)(v4 + 4) = 0;
    *(_DWORD *)(v4 + 8) = 0;
  }
  return result;
}
// 10004CF0: using guessed type int sub_10004CF0();
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10024CC5: using guessed type int __thiscall nullsub_2(_DWORD);
// 10052529: using guessed type int __cdecl sub_10052529(int, int);

//----- (1001CFD0) --------------------------------------------------------
int __usercall sub_1001CFD0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v4; // esi@1
  int v5; // [sp+8h] [bp-8h]@1
  unsigned int v6; // [sp+Ch] [bp-4h]@1
  int v7; // [sp+10h] [bp+0h]@1

  v6 = (unsigned int)&v7 ^ __security_cookie;
  v5 = a1;
  v4 = a2;
  sub_1001D830((int)&v5, a2, a3);
  return v4;
}
// 10067210: using guessed type int __security_cookie;

//----- (1001D010) --------------------------------------------------------
char __thiscall sub_1001D010(int this)
{
  int v1; // eax@1
  int v2; // esi@1
  char v3; // zf@1
  char v4; // zf@3
  char v5; // zf@5
  DWORD v6; // eax@12
  char v8; // [sp+8h] [bp-18h]@1
  DWORD v9; // [sp+Ch] [bp-14h]@3
  int v10; // [sp+10h] [bp-10h]@4
  int v11; // [sp+14h] [bp-Ch]@1
  int (*v12)(void); // [sp+18h] [bp-8h]@1
  unsigned int v13; // [sp+1Ch] [bp-4h]@1

  v1 = (unsigned int)&v8 ^ __security_cookie;
  v13 = (unsigned int)&v8 ^ __security_cookie;
  v2 = this;
  v3 = *(_DWORD *)(this + 100) == 0;
  v11 = 0;
  v12 = sub_1002C66E;
  if ( !v3 )
  {
    do
    {
      v1 = v11;
      switch ( v11 )
      {
        case 1:
          __asm { pause                   ; jumptable 1001D05D case 1 }
          v4 = v9-- == 1;
          if ( v4 )
          {
            v1 = 3 - (v10 != 0);
            v11 = 3 - (v10 != 0);
          }
          break;
        case 2:
          v5 = v10-- == 1;
          if ( v5 )
            v1 = 3;
          v11 = v1;
          goto LABEL_8;
        case 4:
LABEL_8:
          LOBYTE(v1) = v12();
          break;
        case 3:
          v11 = 0;
          v1 = sub_100247A0();
          if ( v1 )
          {
            v9 = v1;
            v10 = 1;
            v11 = 1;
          }
          else
          {
            v11 = 4;
          }
          break;
        case 0:
          v11 = 0;
          v6 = sub_100247A0();
          if ( v6 )
          {
            v9 = v6;
            v10 = 1;
            v11 = 1;
          }
          else
          {
            v11 = 4;
          }
          LOBYTE(v1) = sub_1001FF20((int)&v9);
          break;
        default:
          break;
      }
    }
    while ( *(_DWORD *)(v2 + 100) );
  }
  return v1;
}
// 10067210: using guessed type int __security_cookie;

//----- (1001D130) --------------------------------------------------------
#error "1001D24F: positive sp value has been found (funcsize=85)"

//----- (1001D260) --------------------------------------------------------
void __userpurge sub_1001D260(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // edx@1
  int ebp0; // ebp@0
  int v8; // edi@1
  int v9; // esi@1
  int v10; // ebx@1
  int v11; // eax@1
  int v28; // edi@10
  int v29; // eax@10
  int v30; // edx@14
  char v44; // [sp-20h] [bp-94h]@8
  int v45; // [sp-1Ch] [bp-90h]@10
  int v46; // [sp-18h] [bp-8Ch]@10
  int v47; // [sp-14h] [bp-88h]@10
  char v48; // [sp-8h] [bp-7Ch]@6
  int v49; // [sp-4h] [bp-78h]@6
  char v50; // [sp+10h] [bp-64h]@1
  int v51; // [sp+14h] [bp-60h]@1
  int v52; // [sp+18h] [bp-5Ch]@1
  char *v53; // [sp+1Ch] [bp-58h]@1
  int v54; // [sp+20h] [bp-54h]@1
  char *v55; // [sp+24h] [bp-50h]@1
  int v56; // [sp+28h] [bp-4Ch]@1
  char v57; // [sp+2Ch] [bp-48h]@10
  int v58; // [sp+3Ch] [bp-38h]@13
  unsigned int v59; // [sp+60h] [bp-14h]@1
  int v60; // [sp+70h] [bp-4h]@1

  v59 = (unsigned int)&v50 ^ __security_cookie;
  v10 = a2;
  v54 = a2;
  v51 = 0;
  v52 = 0;
  sub_1001BFC0(a1, (int)&v51, a3, a2);
  v60 = 0;
  v11 = sub_10001AA0((int)&v55, v10 + 40);
  v9 = *(_DWORD *)(v11 + 4);
  *(_DWORD *)(v11 + 4) = v52;
  v5 = *(_DWORD *)v11;
  *(_DWORD *)v11 = v51;
  v8 = v56;
  _EBX = -1;
  v52 = v9;
  v53 = (char *)v5;
  v51 = v5;
  if ( v56 )
  {
    _EAX = v56 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v8)(v8);
      _EAX = v8 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v8 + 4))(v8, _EDX);
      v5 = (int)v53;
    }
  }
  v53 = &v48;
  *(_DWORD *)&v48 = 0;
  v49 = 0;
  if ( (int *)&v48 != &v51 )
  {
    v49 = v9;
    v9 = 0;
    v52 = 0;
    *(_DWORD *)&v48 = v5;
    v51 = 0;
  }
  v55 = &v44;
  LOBYTE(v60) = 2;
  _EAX = (char *)sub_10027EB3(v5, (int)&v51, -1, (int)&v44, 32);
  if ( !_EAX )
    sub_10021BC5();
  _ECX = v54;
  *(_DWORD *)_EAX = off_1005CC54;
  __asm
  {
    movq    xmm0, qword ptr [ecx+30h]
    movq    qword ptr [eax+8], xmm0
    movq    xmm0, qword ptr [ecx+38h]
    movq    qword ptr [eax+10h], xmm0
  }
  LOBYTE(v60) = 1;
  v29 = sub_1001D500((int)&v57, v44, v45, v46, v47, _EAX);
  LOBYTE(v60) = 4;
  v28 = *(_DWORD *)(v54 + 32);
  *(_DWORD *)(v28 + 152) = sub_1001D590(v29, v48, v49);
  sub_1002426D(ebp0, v28 + 100);
  LOBYTE(v60) = 4;
  if ( *(_DWORD *)(v28 + 84) == 4 )
  {
    sub_100242C1();
  }
  else
  {
    *(_DWORD *)(v28 + 84) = 3;
    sub_100242C1();
    sub_10025148(ebp0);
    sub_10001730(v28);
  }
  LOBYTE(v60) = 0;
  if ( v58 )
  {
    v30 = *(_DWORD *)v58;
    v49 = v58 != (_DWORD)&v57;
    (*(void (__stdcall **)(int))(v30 + 16))(v49);
    v58 = 0;
  }
  v60 = -1;
  if ( v9 )
  {
    _EAX = v9 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v9)(v9);
      _EAX = v9 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (**)(void))(*(_DWORD *)v9 + 4))();
    }
  }
}
// 1005CC54: using guessed type int (__stdcall *off_1005CC54[3])(int);
// 10067210: using guessed type int __security_cookie;

//----- (1001D480) --------------------------------------------------------
int __thiscall sub_1001D480(int this, char a2, int a3, int a4, int a5, int a6)
{
  int v6; // edi@1

  v6 = this;
  sub_1001D8B0((int)&a2, this, this);
  if ( a6 )
    (*(void (__stdcall **)(bool))(*(_DWORD *)a6 + 16))(a6 != (_DWORD)&a2);
  return v6;
}

//----- (1001D500) --------------------------------------------------------
int __thiscall sub_1001D500(int this, char a2, int a3, int a4, int a5, char *a6)
{
  int v6; // edi@1
  char *v7; // esi@1
  int v9; // [sp-4h] [bp-24h]@4

  v6 = this;
  v7 = a6;
  if ( a6 )
  {
    if ( a6 == &a2 )
      v9 = this;
    else
      v9 = 0;
    v7 = a6;
    *(_DWORD *)(this + 16) = (**(int (__stdcall ***)(_DWORD))a6)(v9);
  }
  else
  {
    *(_DWORD *)(this + 16) = a6;
  }
  if ( v7 )
    (*(void (__thiscall **)(char *, bool))(*(_DWORD *)v7 + 16))(v7, v7 != &a2);
  return v6;
}

//----- (1001D590) --------------------------------------------------------
int __thiscall sub_1001D590(int this, char a2, int a3)
{
  int v3; // ecx@1
  int v4; // ebx@3
  int v5; // esi@3

  v3 = *(_DWORD *)(this + 16);
  if ( !v3 )
    sub_10021BF6();
  v5 = a3;
  v4 = (*(int (__stdcall **)(char *))(*(_DWORD *)v3 + 8))(&a2);
  if ( a3 )
  {
    _EDI = -1;
    _EDX = a3 + 4;
    _ECX = -1;
    __asm { lock xadd [edx], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      _EAX = v5 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (**)(void))(*(_DWORD *)v5 + 4))();
    }
  }
  return v4;
}

//----- (1001D630) --------------------------------------------------------
int __userpurge sub_1001D630<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // edi@1
  int v10; // eax@3
  int v11; // eax@4
  int v13; // [sp-8h] [bp-30h]@4
  int v14; // [sp-4h] [bp-2Ch]@3
  char v15; // [sp+Ch] [bp-1Ch]@2
  int v16; // [sp+18h] [bp-10h]@1
  int v17; // [sp+24h] [bp-4h]@1

  v9 = a2;
  v17 = 0;
  v16 = 0;
  if ( !*(_DWORD *)a2 )
  {
    sub_10024934((int)&v15, (unsigned int)"then() cannot be called on a default constructed task.");
    sub_1002D02B((int)&v15, (int)&unk_100614E0);
  }
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_1001BFC0(a1, a4, v9, a2);
  v17 = 0;
  v16 = 1;
  sub_1001C120(a4, 2);
  *(_BYTE *)(*(_DWORD *)a4 + 88) = *(_BYTE *)(*(_DWORD *)v9 + 88) != 0;
  *(_BYTE *)(*(_DWORD *)a4 + 89) = 0;
  *(_BYTE *)(*(_DWORD *)a4 + 90) = 1;
  v10 = sub_10028682(a3, v9, 0x34u);
  if ( v10 )
    v11 = sub_1001DA10(v10, v9, a4, a5, v13, v14);
  else
    v11 = 0;
  sub_1001F940(*(void **)v9, v11);
  return a4;
}

//----- (1001D710) --------------------------------------------------------
char __cdecl sub_1001D710(int a1, int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    _EDI = -1;
    _EDX = a2 + 4;
    _ECX = -1;
    __asm { lock xadd [edx], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))a2)(a2);
      _EAX = a2 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)a2 + 4))(a2);
      result = 0;
    }
  }
  return result;
}

//----- (1001D750) --------------------------------------------------------
int __userpurge sub_1001D750<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // edi@1
  int v10; // eax@3
  int v11; // eax@4
  int v13; // [sp-8h] [bp-30h]@4
  int v14; // [sp-4h] [bp-2Ch]@3
  char v15; // [sp+Ch] [bp-1Ch]@2
  int v16; // [sp+18h] [bp-10h]@1
  int v17; // [sp+24h] [bp-4h]@1

  v9 = a2;
  v17 = 0;
  v16 = 0;
  if ( !*(_DWORD *)a2 )
  {
    sub_10024934((int)&v15, (unsigned int)"then() cannot be called on a default constructed task.");
    sub_1002D02B((int)&v15, (int)&unk_100614E0);
  }
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_1001BFC0(a1, a4, v9, a2);
  v17 = 0;
  v16 = 1;
  sub_1001C120(a4, 2);
  *(_BYTE *)(*(_DWORD *)a4 + 88) = *(_BYTE *)(*(_DWORD *)v9 + 88) != 0;
  *(_BYTE *)(*(_DWORD *)a4 + 89) = 0;
  *(_BYTE *)(*(_DWORD *)a4 + 90) = 1;
  v10 = sub_10028682(a3, v9, 0x34u);
  if ( v10 )
    v11 = sub_1001DC90(v10, v9, a4, a5, v13, v14);
  else
    v11 = 0;
  sub_1001F940(*(void **)v9, v11);
  return a4;
}

//----- (1001D830) --------------------------------------------------------
int __usercall sub_1001D830<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v3; // eax@1
  int *v4; // edi@1
  int v5; // esi@1
  int v6; // eax@2

  v4 = (int *)a1;
  v5 = a2;
  v3 = sub_10027EB3(a1, a2, a3, a1, 184);
  if ( v3 )
    v6 = sub_1001DF40(v3, v4);
  else
    v6 = 0;
  *(_DWORD *)(v5 + 4) = v6;
  *(_DWORD *)v5 = v6 + 16;
  return v5;
}

//----- (1001D8B0) --------------------------------------------------------
int __usercall sub_1001D8B0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>)
{
  int v3; // ecx@1
  int v4; // esi@1
  char *v6; // [sp-4h] [bp-3Ch]@4
  char v7; // [sp+8h] [bp-30h]@1
  int v8; // [sp+18h] [bp-20h]@2
  char *v9; // [sp+20h] [bp-18h]@1
  int v10; // [sp+24h] [bp-14h]@1
  int v11; // [sp+28h] [bp-10h]@1
  int v12; // [sp+34h] [bp-4h]@1

  v4 = a2;
  v11 = a2;
  v10 = 0;
  v9 = &v7;
  v12 = 0;
  v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    if ( v3 == a1 )
    {
      a1 = (int)&v7;
      v6 = &v7;
    }
    else
    {
      v6 = 0;
    }
    v8 = (**(int (__fastcall ***)(int, int, char *))v3)(v3, a1, v6);
  }
  else
  {
    v8 = 0;
  }
  v12 = 2;
  sub_1001EC30(a1, v4, a3, (int)&v7, v3);
  v12 = -1;
  if ( v8 )
    (*(void (__stdcall **)(bool))(*(_DWORD *)v8 + 16))(v8 != (_DWORD)&v7);
  return v4;
}

//----- (1001D9A0) --------------------------------------------------------
int __thiscall sub_1001D9A0(int this, int a2)
{
  return (*(int (__thiscall **)(_DWORD, _DWORD))(this + 4))(*(_DWORD *)(this + 8), *(_DWORD *)a2);
}

//----- (1001D9C0) --------------------------------------------------------
int (__stdcall ***__cdecl sub_1001D9C0())(char)
{
  return &off_10068C90;
}
// 10068C90: using guessed type int (__stdcall **off_10068C90)(char);

//----- (1001D9D0) --------------------------------------------------------
int __thiscall sub_1001D9D0(void *this)
{
  return (int)((char *)this + 4);
}

//----- (1001D9E0) --------------------------------------------------------
int __thiscall sub_1001D9E0(void *this, char a2)
{
  int result; // eax@1
  void *v3; // esi@1

  v3 = this;
  result = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)this + 20))(0);
  if ( a2 )
    result = sub_1002404A(v3);
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1001DA10) --------------------------------------------------------
int __thiscall sub_1001DA10(int this, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // esi@1

  v7 = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_BYTE *)(this + 25) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = &off_1005CE04;
  sub_10001AA0(this + 32, a3);
  *(_DWORD *)(v7 + 4) = sub_1001DFE0;
  *(_BYTE *)(v7 + 16) = 1;
  *(_DWORD *)v7 = &off_1005CE0C;
  sub_10001AA0(v7 + 40, a2);
  *(_DWORD *)(v7 + 48) = *(_DWORD *)a4;
  *(_BYTE *)(v7 + 25) = 1;
  *(_DWORD *)(v7 + 28) = 0;
  return v7;
}
// 1005CE04: using guessed type int (__stdcall *off_1005CE04)(char);
// 1005CE0C: using guessed type int (__stdcall *off_1005CE0C)(char);

//----- (1001DAC0) --------------------------------------------------------
int __thiscall sub_1001DAC0(int this, int a2)
{
  return (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(this + 4) + 36))(*(_DWORD *)a2);
}

//----- (1001DAE0) --------------------------------------------------------
int (__stdcall ***__cdecl sub_1001DAE0())(char)
{
  return &off_10068C54;
}
// 10068C54: using guessed type int (__stdcall **off_10068C54)(char);

//----- (1001DB30) --------------------------------------------------------
int __thiscall sub_1001DB30(int this, int a2)
{
  return (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(this + 4) + 40))(*(_DWORD *)a2);
}

//----- (1001DB50) --------------------------------------------------------
int (__stdcall ***__cdecl sub_1001DB50())(char)
{
  return &off_10068C1C;
}
// 10068C1C: using guessed type int (__stdcall **off_10068C1C)(char);

//----- (1001DBA0) --------------------------------------------------------
int __thiscall sub_1001DBA0(int this)
{
  return sub_10001730(*(_DWORD *)(this + 4));
}

//----- (1001DBB0) --------------------------------------------------------
int (__stdcall ***__cdecl sub_1001DBB0())(char)
{
  return &off_10068BE4;
}
// 10068BE4: using guessed type int (__stdcall **off_10068BE4)(char);

//----- (1001DC00) --------------------------------------------------------
void __thiscall sub_1001DC00(int this, int a2)
{
  int ebp0; // ebp@0
  int v3; // edi@1
  int v4; // esi@1
  char v5; // [sp+8h] [bp-2Ch]@1
  unsigned int v6; // [sp+24h] [bp-10h]@1
  int v7; // [sp+30h] [bp-4h]@1
  int v8; // [sp+34h] [bp+0h]@1

  v6 = (unsigned int)&v8 ^ __security_cookie;
  v3 = *(_DWORD *)(this + 4);
  v4 = *(_DWORD *)a2;
  sub_100241EF(ebp0, v3 + 176);
  v7 = 0;
  (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 76))(v3, v4);
  v7 = -1;
  sub_100242BA(&v5);
}
// 10067210: using guessed type int __security_cookie;

//----- (1001DC80) --------------------------------------------------------
int (__stdcall ***__cdecl sub_1001DC80())(char)
{
  return &off_10068BAC;
}
// 10068BAC: using guessed type int (__stdcall **off_10068BAC)(char);

//----- (1001DC90) --------------------------------------------------------
int __thiscall sub_1001DC90(int this, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // esi@1

  v7 = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_BYTE *)(this + 25) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = &off_1005CE04;
  sub_10001AA0(this + 32, a3);
  *(_DWORD *)(v7 + 4) = sub_1001DFF0;
  *(_BYTE *)(v7 + 16) = 1;
  *(_DWORD *)v7 = &off_1005CE0C;
  sub_10001AA0(v7 + 40, a2);
  *(_DWORD *)(v7 + 48) = *(_DWORD *)a4;
  *(_BYTE *)(v7 + 25) = 1;
  *(_DWORD *)(v7 + 28) = 0;
  return v7;
}
// 1005CE04: using guessed type int (__stdcall *off_1005CE04)(char);
// 1005CE0C: using guessed type int (__stdcall *off_1005CE0C)(char);

//----- (1001DD00) --------------------------------------------------------
int __thiscall sub_1001DD00(int this)
{
  return (**(int (__thiscall ***)(_DWORD, _DWORD))(this + 16))(this + 16, 0);
}

//----- (1001DD10) --------------------------------------------------------
void __userpurge sub_1001DD10(int *a1<ecx>, int a2<ebx>, int a3)
{
  int v3; // eax@1
  int v4; // edx@1
  int ebp0; // ebp@0
  int *v6; // esi@1
  int v7; // edx@4
  char v8; // [sp-14h] [bp-4Ch]@4
  int v9; // [sp-10h] [bp-48h]@4
  int v10; // [sp-Ch] [bp-44h]@4
  int v11; // [sp-8h] [bp-40h]@4
  unsigned int v12; // [sp-4h] [bp-3Ch]@1
  unsigned int v13; // [sp+28h] [bp-10h]@1
  int v14; // [sp+34h] [bp-4h]@1
  int v15; // [sp+38h] [bp+0h]@1

  v13 = (unsigned int)&v15 ^ __security_cookie;
  v12 = (unsigned int)&v15 ^ __security_cookie;
  v6 = a1;
  sub_10025148(ebp0);
  sub_1002426D(ebp0, *v6 + 12);
  v14 = 0;
  v3 = *v6;
  if ( *(_DWORD *)(*v6 + 64) )
  {
    (*(void (__stdcall **)(signed int, signed int, signed int, int))(**(_DWORD **)a3 + 4))(1, 1, 1, v3 + 64);
  }
  else
  {
    if ( *(_BYTE *)(v3 + 72) )
    {
      sub_10004DA0((int)&v8, v4, v3 + 48);
      sub_10019FA0(v7, *(_DWORD *)a3, a2, v8, v9, v10, v11);
    }
    else
    {
      sub_1001DDD0(v3, a3);
    }
  }
  v14 = -1;
  sub_100242C1();
}
// 10067210: using guessed type int __security_cookie;

//----- (1001DDD0) --------------------------------------------------------
int __thiscall sub_1001DDD0(int this, int a2)
{
  int result; // eax@1
  int v3; // esi@1
  int v4; // edi@3
  int v5; // ecx@5
  int v6; // ecx@9

  v3 = this;
  result = *(_DWORD *)(this + 4);
  if ( a2 >= (unsigned int)result || (this = *(_DWORD *)this, *(_DWORD *)v3 > (unsigned int)a2) )
  {
    if ( result == *(_DWORD *)(v3 + 8) )
      result = loc_1001DE40(v3, this);
    v6 = *(_DWORD *)(v3 + 4);
    if ( v6 )
      result = sub_10001AA0(v6, a2);
  }
  else
  {
    v4 = (a2 - this) >> 3;
    if ( result == *(_DWORD *)(v3 + 8) )
      result = loc_1001DE40(v3, *(_DWORD *)v3);
    v5 = *(_DWORD *)(v3 + 4);
    if ( v5 )
    {
      result = sub_10001AA0(v5, *(_DWORD *)v3 + 8 * v4);
      *(_DWORD *)(v3 + 4) += 8;
      return result;
    }
  }
  *(_DWORD *)(v3 + 4) += 8;
  return result;
}

//----- (1001DF40) --------------------------------------------------------
int __thiscall sub_1001DF40(int this, int *a2)
{
  int v2; // edi@1
  int v3; // esi@1

  v3 = this;
  *(_DWORD *)(this + 4) = 1;
  *(_DWORD *)(this + 8) = 1;
  v2 = this + 16;
  *(_DWORD *)this = off_1005CCB0;
  if ( this != -16 )
  {
    sub_1001FB00((void *)(this + 16), *a2);
    *(_DWORD *)v2 = &off_1005CE6C;
    *(_BYTE *)(v2 + 160) = 0;
    *(_DWORD *)(v2 + 160) &= 0xFFFFFEFFu;
    *(_DWORD *)(v2 + 164) = 0;
  }
  return v3;
}
// 1005CCB0: using guessed type int (*off_1005CCB0[2])();
// 1005CE6C: using guessed type int (__stdcall *off_1005CE6C)(char);

//----- (1001DFE0) --------------------------------------------------------
void __cdecl sub_1001DFE0(int a1)
{
  JUMPOUT(*(unsigned int *)loc_1001E000);
}
// 1001E000: using guessed type int __cdecl loc_1001E000(int);

//----- (1001DFF0) --------------------------------------------------------
int __usercall sub_1001DFF0<eax>(int a1<eax>, int a2)
{
  int v2; // esi@1
  int v4; // edx@4
  unsigned int v5; // [sp-18h] [bp-50h]@1
  int v6; // [sp-14h] [bp-4Ch]@3
  int v7; // [sp-10h] [bp-48h]@3
  int v8; // [sp-Ch] [bp-44h]@3
  char v9; // [sp-8h] [bp-40h]@3
  int v10; // [sp+0h] [bp-38h]@4
  int v11; // [sp+4h] [bp-34h]@1
  unsigned int v12; // [sp+24h] [bp-14h]@1
  unsigned int *v13; // [sp+28h] [bp-10h]@1
  int v14; // [sp+2Ch] [bp-Ch]@1
  int (__cdecl *v15)(int, int); // [sp+30h] [bp-8h]@1
  int v16; // [sp+34h] [bp-4h]@1
  _DWORD *v17; // [sp+38h] [bp+0h]@1

  v17 = &v17;
  v16 = -1;
  v15 = sub_10052B00;
  v14 = a1;
  v12 = (unsigned int)&v17 ^ __security_cookie;
  v5 = (unsigned int)&v17 ^ __security_cookie;
  v13 = &v5;
  v2 = *(_DWORD *)(a2 + 32);
  v11 = a2;
  sub_1002426D((int)&v17, v2 + 100);
  v16 = -1;
  if ( *(_DWORD *)(v2 + 84) == 4 )
  {
    sub_100242C1();
  }
  else
  {
    *(_DWORD *)(v2 + 84) = 1;
    sub_100242C1();
    v16 = 1;
    LOBYTE(v10) = 0;
    sub_1001E610(v4, a2, a2, v10, v10);
  }
  return sub_10022B30(v8, v6, v7, (unsigned int)&v17 ^ v12, v9);
}
// 10052B00: using guessed type int __cdecl sub_10052B00(int, int);
// 10067210: using guessed type int __security_cookie;

//----- (1001E220) --------------------------------------------------------
int (__stdcall ***__cdecl sub_1001E220())(char)
{
  return &off_10068B74;
}
// 10068B74: using guessed type int (__stdcall **off_10068B74)(char);

//----- (1001E230) --------------------------------------------------------
int __thiscall sub_1001E230(int this, int a2, int a3)
{
  int v3; // edx@1
  int v4; // edi@1
  int result; // eax@3

  v4 = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)this = off_1005CC8C;
  sub_10001AA0(this + 20, a2);
  *(_DWORD *)(v4 + 4) = sub_1001E7D0;
  *(_BYTE *)(v4 + 16) = 1;
  *(_DWORD *)v4 = &off_1005CC90;
  *(_DWORD *)(v4 + 28) = *(_DWORD *)a3;
  *(_DWORD *)(v4 + 52) = 7;
  *(_DWORD *)(v4 + 48) = 0;
  *(_WORD *)(v4 + 32) = 0;
  loc_10020810(a3 + 4, 0, -1);
  v3 = *(_DWORD *)(a3 + 28);
  if ( v3 )
  {
    _EAX = v3 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  result = v4;
  *(_DWORD *)(v4 + 56) = v3;
  return result;
}
// 1005CC8C: using guessed type int (__stdcall *off_1005CC8C[2])(char);
// 1005CC90: using guessed type int (__stdcall *off_1005CC90)(char);

//----- (1001E2E0) --------------------------------------------------------
int __thiscall sub_1001E2E0(int this)
{
  int v1; // ecx@1
  int v3; // edi@1
  int v4; // esi@1
  int result; // eax@6
  int v13; // edi@6

  v4 = this;
  *(_DWORD *)this = &off_1005CC90;
  v3 = this + 28;
  v1 = *(_DWORD *)(this + 56);
  _EBX = -1;
  if ( v1 )
  {
    _EAX = v1 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v1 + 4))();
  }
  *(_DWORD *)(v3 + 28) = 0;
  if ( *(_DWORD *)(v3 + 24) >= 8u )
    sub_1002404A(*(LPVOID *)(v3 + 4));
  *(_DWORD *)(v3 + 24) = 7;
  *(_DWORD *)(v3 + 20) = 0;
  result = 0;
  *(_WORD *)(v3 + 4) = 0;
  *(_DWORD *)v4 = off_1005CC8C;
  v13 = *(_DWORD *)(v4 + 24);
  if ( v13 )
  {
    result = v13 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v13)(v13);
      result = v13 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        result = (*(int (**)(void))(*(_DWORD *)v13 + 4))();
    }
  }
  *(_DWORD *)v4 = &off_10055E44;
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10055E44: using guessed type int (__stdcall *off_10055E44)(char);
// 1005CC8C: using guessed type int (__stdcall *off_1005CC8C[2])(char);
// 1005CC90: using guessed type int (__stdcall *off_1005CC90)(char);

//----- (1001E410) --------------------------------------------------------
int __userpurge sub_1001E410<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  int v4; // esi@1

  v4 = a1;
  sub_1001E2E0(a1);
  if ( a4 & 1 )
    sub_10028747(a2, a3, v4);
  return v4;
}

//----- (1001E440) --------------------------------------------------------
int __userpurge sub_1001E440<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int v20; // [sp-4h] [bp-Ch]@2

  v4 = a1;
  *(_DWORD *)a1 = off_1005CC8C;
  v3 = *(_DWORD *)(a1 + 24);
  if ( v3 )
  {
    v20 = a2;
    _EBX = -1;
    _EDX = v3 + 4;
    _EAX = -1;
    __asm { lock xadd [edx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v3)(v3);
      _EAX = v3 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
    }
    a2 = v20;
  }
  *(_DWORD *)v4 = &off_10055E44;
  if ( a3 & 1 )
    sub_10028747(a2, v3, v4);
  return v4;
}
// 10055E44: using guessed type int (__stdcall *off_10055E44)(char);
// 1005CC8C: using guessed type int (__stdcall *off_1005CC8C[2])(char);

//----- (1001E4A0) --------------------------------------------------------
int __userpurge sub_1001E4A0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // edx@1
  int v6; // ebx@1
  int v8; // esi@1
  int v9; // ebx@1
  int v10; // eax@1
  int result; // eax@8
  int v26; // ebx@8
  int v27; // ebx@8
  int v28; // eax@8
  int v52; // [sp-8h] [bp-44h]@6
  int v53; // [sp-4h] [bp-40h]@6
  int v54; // [sp+14h] [bp-28h]@1
  int v55; // [sp+18h] [bp-24h]@1
  int v56; // [sp+1Ch] [bp-20h]@1
  int v57; // [sp+20h] [bp-1Ch]@1
  char v58; // [sp+24h] [bp-18h]@1
  int v59; // [sp+28h] [bp-14h]@1
  int v60; // [sp+38h] [bp-4h]@1

  v9 = a2;
  v55 = a2;
  v56 = 0;
  v57 = 0;
  sub_1001BFC0(a1, (int)&v56, a3, a2);
  v60 = 0;
  v10 = sub_10001AA0((int)&v58, v9 + 40);
  v8 = *(_DWORD *)(v10 + 4);
  *(_DWORD *)(v10 + 4) = v57;
  v5 = *(_DWORD *)v10;
  *(_DWORD *)v10 = v56;
  v6 = v59;
  _EDI = -1;
  v57 = v8;
  v54 = v5;
  v56 = v5;
  if ( v59 )
  {
    _EAX = v59 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v6)(v6);
      _EAX = v6 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v6 + 4))(v6, _EDX);
      v5 = v54;
    }
  }
  v52 = 0;
  v53 = 0;
  if ( &v52 != &v56 )
  {
    v53 = v8;
    v8 = 0;
    v57 = 0;
    v52 = v5;
    v56 = 0;
  }
  v27 = v55;
  v28 = sub_1001AD20((void *)(v55 + 48), (int)&v58, v52, v53);
  LOBYTE(v60) = 1;
  result = sub_1001E7E0(v28, v27 + 32, v27);
  LOBYTE(v60) = 0;
  v26 = v59;
  if ( v59 )
  {
    result = v59 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v26)(v26);
      result = v26 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v26 + 4))(v26, _EDX);
    }
  }
  v60 = -1;
  if ( v8 )
  {
    result = v8 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v8)(v8);
      result = v8 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (**)(void))(*(_DWORD *)v8 + 4))();
    }
  }
  return result;
}

//----- (1001E610) --------------------------------------------------------
int __userpurge sub_1001E610<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // edx@1
  int v6; // ebx@1
  int v8; // esi@1
  int v9; // ebx@1
  int v10; // eax@1
  int result; // eax@8
  int v26; // ebx@8
  int v27; // ebx@8
  int v28; // eax@8
  int v52; // [sp-8h] [bp-44h]@6
  int v53; // [sp-4h] [bp-40h]@6
  int v54; // [sp+14h] [bp-28h]@1
  int v55; // [sp+18h] [bp-24h]@1
  int v56; // [sp+1Ch] [bp-20h]@1
  int v57; // [sp+20h] [bp-1Ch]@1
  char v58; // [sp+24h] [bp-18h]@1
  int v59; // [sp+28h] [bp-14h]@1
  int v60; // [sp+38h] [bp-4h]@1

  v9 = a2;
  v55 = a2;
  v56 = 0;
  v57 = 0;
  sub_1001BFC0(a1, (int)&v56, a3, a2);
  v60 = 0;
  v10 = sub_10001AA0((int)&v58, v9 + 40);
  v8 = *(_DWORD *)(v10 + 4);
  *(_DWORD *)(v10 + 4) = v57;
  v5 = *(_DWORD *)v10;
  *(_DWORD *)v10 = v56;
  v6 = v59;
  _EDI = -1;
  v57 = v8;
  v54 = v5;
  v56 = v5;
  if ( v59 )
  {
    _EAX = v59 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v6)(v6);
      _EAX = v6 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v6 + 4))(v6, _EDX);
      v5 = v54;
    }
  }
  v52 = 0;
  v53 = 0;
  if ( &v52 != &v56 )
  {
    v53 = v8;
    v8 = 0;
    v57 = 0;
    v52 = v5;
    v56 = 0;
  }
  v27 = v55;
  v28 = sub_1001AFD0((void *)(v55 + 48), (int)&v58, v52, v53);
  LOBYTE(v60) = 1;
  result = sub_1001E7E0(v28, v27 + 32, v27);
  LOBYTE(v60) = 0;
  v26 = v59;
  if ( v59 )
  {
    result = v59 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v26)(v26);
      result = v26 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v26 + 4))(v26, _EDX);
    }
  }
  v60 = -1;
  if ( v8 )
  {
    result = v8 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v8)(v8);
      result = v8 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (**)(void))(*(_DWORD *)v8 + 4))();
    }
  }
  return result;
}

//----- (1001E780) --------------------------------------------------------
int __fastcall sub_1001E780(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // edi@1
  int i; // esi@1
  int v6; // edx@4

  result = a3;
  v4 = a2;
  for ( i = a1; i != v4; result += 8 )
  {
    if ( result )
    {
      *(_DWORD *)result = 0;
      *(_DWORD *)(result + 4) = 0;
      if ( result != i )
      {
        *(_DWORD *)(result + 4) = *(_DWORD *)(i + 4);
        *(_DWORD *)(i + 4) = 0;
        v6 = *(_DWORD *)result;
        *(_DWORD *)result = *(_DWORD *)i;
        *(_DWORD *)i = v6;
      }
    }
    i += 8;
  }
  return result;
}

//----- (1001E7D0) --------------------------------------------------------
void __usercall sub_1001E7D0(int a1<ecx>, int a2<ebx>, int a3)
{
  sub_1001E960(a3, a2);
}

//----- (1001E7E0) --------------------------------------------------------
int __usercall sub_1001E7E0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int result; // eax@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // edx@1
  int v8; // ST08_4@1
  int v9; // ST0C_4@1
  int v10; // ST10_4@1
  int v23; // esi@5
  char v35; // [sp+Ch] [bp-1Ch]@1
  int v36; // [sp+10h] [bp-18h]@1
  char v37; // [sp+14h] [bp-14h]@1
  int v38; // [sp+18h] [bp-10h]@5
  int v39; // [sp+24h] [bp-4h]@1

  v6 = a1;
  sub_10001AA0((int)&v37, a2);
  v39 = 0;
  result = sub_1001EAF0(v7, v6, a3, (int)&v35, (int)&v37, v8, v9, v10);
  v5 = v36;
  _EDI = -1;
  if ( v36 )
  {
    result = v36 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      result = v5 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v5 + 4))(v5, _EDX);
    }
  }
  v39 = -1;
  v23 = v38;
  if ( v38 )
  {
    result = v38 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v23)(v23);
      result = v23 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (**)(void))(*(_DWORD *)v23 + 4))();
    }
  }
  return result;
}

//----- (1001E8A0) --------------------------------------------------------
int __userpurge sub_1001E8A0<eax>(int a1<edx>, int *a2<ecx>, int a3<ebx>, int a4, int a5)
{
  int *v5; // esi@1
  int result; // eax@2
  int v7; // edx@2
  int v8; // ecx@3
  char v21; // [sp-10h] [bp-30h]@2
  int v22; // [sp-Ch] [bp-2Ch]@2
  int v23; // [sp-8h] [bp-28h]@2
  int v24; // [sp-4h] [bp-24h]@2
  int v25; // [sp+1Ch] [bp-4h]@1

  v5 = a2;
  v25 = 0;
  if ( *(_DWORD *)(a4 + 84) == 3 )
  {
    sub_10019980(a4, a1, (int)&v21);
    result = sub_10019FA0(v7, *v5, a3, v21, v22, v23, v24);
  }
  else
  {
    v8 = *a2;
    if ( *(_DWORD *)(a4 + 92) )
      result = (*(int (__stdcall **)(signed int, signed int, _DWORD, int))(*(_DWORD *)v8 + 4))(1, 1, 0, a4 + 92);
    else
      result = (*(int (__stdcall **)(signed int, _DWORD, _DWORD, int))(*(_DWORD *)v8 + 4))(1, 0, 0, v8 + 92);
  }
  v25 = -1;
  if ( a5 )
  {
    _EDI = -1;
    _ECX = a5 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))a5)(a5);
      result = a5 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (**)(void))(*(_DWORD *)a5 + 4))();
    }
  }
  return result;
}

//----- (1001E960) --------------------------------------------------------
void __usercall sub_1001E960(int a1<ecx>, int a2<ebx>)
{
  int ebp0; // ebp@0
  int v3; // edi@1
  int v4; // esi@1
  unsigned int v5; // [sp-4h] [bp-4Ch]@1
  int v6; // [sp+14h] [bp-34h]@1
  unsigned int v7; // [sp+34h] [bp-14h]@1
  unsigned int *v8; // [sp+38h] [bp-10h]@1
  int v9; // [sp+44h] [bp-4h]@1
  int v10; // [sp+48h] [bp+0h]@1

  v7 = (unsigned int)&v10 ^ __security_cookie;
  v5 = (unsigned int)&v10 ^ __security_cookie;
  v8 = &v5;
  v3 = a1;
  v4 = *(_DWORD *)(a1 + 20);
  v6 = a1;
  sub_1002426D(ebp0, v4 + 100);
  v9 = -1;
  if ( *(_DWORD *)(v4 + 84) == 4 )
  {
    sub_100242C1();
  }
  else
  {
    *(_DWORD *)(v4 + 84) = 1;
    sub_100242C1();
    v9 = 1;
    sub_1001EA50(v3, a2, v6);
  }
}
// 10067210: using guessed type int __security_cookie;

//----- (1001EA50) --------------------------------------------------------
int __userpurge sub_1001EA50<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // esi@1
  int v6; // eax@1
  char v19; // [sp+Ch] [bp-18h]@1
  int v20; // [sp+10h] [bp-14h]@1
  int v21; // [sp+20h] [bp-4h]@1

  v5 = a1;
  v6 = sub_1001AF20((void *)(a1 + 28), (int)&v19);
  v21 = 0;
  result = sub_1001E7E0(v6, v5 + 20, a2);
  v21 = -1;
  v4 = v20;
  if ( v20 )
  {
    _EDI = -1;
    _ECX = v20 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v4)(v4);
      result = v4 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (**)(void))(*(_DWORD *)v4 + 4))();
    }
  }
  return result;
}

//----- (1001EAF0) --------------------------------------------------------
int __userpurge sub_1001EAF0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8)
{
  int v9; // ST08_4@1
  int v10; // ST0C_4@1
  int v11; // ST10_4@1
  int v12; // ST14_4@1

  sub_1001ECD0(a1, a2, a3, a4, a5, v9, v10, v11, v12);
  return a4;
}

//----- (1001EB60) --------------------------------------------------------
BOOL __userpurge sub_1001EB60<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  return sub_100165D0(a1, a2 + 4, a3, a4);
}

//----- (1001EB70) --------------------------------------------------------
int (__stdcall ***__cdecl sub_1001EB70())(char)
{
  return &off_10068B3C;
}
// 10068B3C: using guessed type int (__stdcall **off_10068B3C)(char);

//----- (1001EB80) --------------------------------------------------------
int __userpurge sub_1001EB80<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int result; // eax@1
  int v7; // edi@4
  int v8; // ecx@4
  int v9; // ecx@5
  int v10; // [sp-14h] [bp-18h]@4
  int v11; // [sp-10h] [bp-14h]@4
  int v12; // [sp-Ch] [bp-10h]@4
  int v13; // [sp-8h] [bp-Ch]@4
  _DWORD *v14; // [sp+4h] [bp+0h]@4

  result = a5;
  _ESI = a2;
  if ( a5 || (result = sub_10027EB3(a1, a2, a3, a4, 32)) != 0 )
  {
    *(_DWORD *)result = off_1005CC54;
    __asm
    {
      movq    xmm0, qword ptr [esi+8]
      movq    qword ptr [eax+8], xmm0
      movq    xmm0, qword ptr [esi+10h]
      movq    qword ptr [eax+10h], xmm0
    }
  }
  else
  {
    sub_10021BC5();
    __asm { int     3               ; Trap to Debugger }
    v14 = &v14;
    v13 = _ESI;
    v12 = a4;
    v7 = v8;
    v10 = 0;
    v11 = 0;
    if ( &v10 != (int *)a5 )
    {
      v11 = *(_DWORD *)(a5 + 4);
      *(_DWORD *)(a5 + 4) = 0;
      v9 = v10;
      v10 = *(_DWORD *)a5;
      *(_DWORD *)a5 = v9;
    }
    result = sub_10016C00((void *)(v7 + 8), v10, v11);
  }
  return result;
}
// 1005CC54: using guessed type int (__stdcall *off_1005CC54[3])(int);

//----- (1001EC10) --------------------------------------------------------
int (__stdcall ***__cdecl sub_1001EC10())(char)
{
  return &off_10068B04;
}
// 10068B04: using guessed type int (__stdcall **off_10068B04)(char);

//----- (1001EC20) --------------------------------------------------------
int __thiscall sub_1001EC20(void *this)
{
  return (int)((char *)this + 8);
}

//----- (1001EC30) --------------------------------------------------------
int __userpurge sub_1001EC30<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // esi@1
  int v6; // ecx@3
  int result; // eax@9
  int v8; // [sp-4h] [bp-30h]@6
  int v9; // [sp+1Ch] [bp-10h]@1

  v9 = a2;
  v5 = sub_10027EB3(a1, a2, a4, a3, 40);
  if ( !v5 )
    sub_10021BC5();
  *(_DWORD *)v5 = off_1005CC38;
  v6 = *(_DWORD *)(a4 + 16);
  if ( v6 )
  {
    if ( v6 == a4 )
      v8 = v5 + 8;
    else
      v8 = 0;
    *(_DWORD *)(v5 + 24) = (**(int (__stdcall ***)(_DWORD))v6)(v8);
  }
  else
  {
    *(_DWORD *)(v5 + 24) = 0;
  }
  result = v9;
  *(_DWORD *)(v9 + 16) = v5;
  return result;
}
// 1005CC38: using guessed type int (__stdcall *off_1005CC38[2])(int);

//----- (1001ECD0) --------------------------------------------------------
int __userpurge sub_1001ECD0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // edi@1
  int v10; // eax@3
  int v11; // eax@4
  int v13; // [sp-8h] [bp-30h]@4
  int v14; // [sp-4h] [bp-2Ch]@3
  char v15; // [sp+Ch] [bp-1Ch]@2
  int v16; // [sp+18h] [bp-10h]@1
  int v17; // [sp+24h] [bp-4h]@1

  v9 = a2;
  v17 = 0;
  v16 = 0;
  if ( !*(_DWORD *)a2 )
  {
    sub_10024934((int)&v15, (unsigned int)"then() cannot be called on a default constructed task.");
    sub_1002D02B((int)&v15, (int)&unk_100614E0);
  }
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_1001BFC0(a1, a4, v9, a2);
  v17 = 0;
  v16 = 1;
  sub_1001FCE0(a4, 2);
  *(_BYTE *)(*(_DWORD *)a4 + 88) = *(_BYTE *)(*(_DWORD *)v9 + 88) != 0;
  *(_BYTE *)(*(_DWORD *)a4 + 89) = 0;
  *(_BYTE *)(*(_DWORD *)a4 + 90) = 0;
  v10 = sub_10028682(a3, v9, 0x38u);
  if ( v10 )
    v11 = sub_1001EE90(v10, v9, a4, a5, v13, v14);
  else
    v11 = 0;
  sub_1001F940(*(void **)v9, v11);
  return a4;
}

//----- (1001EDB0) --------------------------------------------------------
int __userpurge sub_1001EDB0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4)
{
  int v4; // ebx@1
  int v5; // esi@1
  int v6; // ecx@5
  int v7; // eax@8

  v4 = a2;
  v5 = a4;
  if ( !a4 )
  {
    v5 = sub_10027EB3(a1, a2, a2, a3, 40);
    if ( !v5 )
      sub_10021BC5();
  }
  if ( v5 )
  {
    *(_DWORD *)v5 = off_1005CC38;
    v6 = *(_DWORD *)(v4 + 24);
    if ( v6 )
    {
      if ( v6 == v4 + 8 )
        v7 = (**(int (__stdcall ***)(_DWORD))v6)(v5 + 8);
      else
        v7 = (**(int (__stdcall ***)(_DWORD))v6)(0);
      *(_DWORD *)(v5 + 24) = v7;
    }
    else
    {
      *(_DWORD *)(v5 + 24) = 0;
    }
  }
  return v5;
}
// 1005CC38: using guessed type int (__stdcall *off_1005CC38[2])(int);

//----- (1001EE80) --------------------------------------------------------
int (__stdcall ***__cdecl sub_1001EE80())(char)
{
  return &off_10068ACC;
}
// 10068ACC: using guessed type int (__stdcall **off_10068ACC)(char);

//----- (1001EE90) --------------------------------------------------------
int __thiscall sub_1001EE90(int this, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // esi@1

  v7 = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_BYTE *)(this + 25) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = &off_1005CE04;
  sub_10001AA0(this + 32, a3);
  *(_DWORD *)(v7 + 4) = sub_1001F040;
  *(_BYTE *)(v7 + 16) = 1;
  *(_DWORD *)v7 = &off_1005CC30;
  sub_10001AA0(v7 + 40, a2);
  sub_10001AA0(v7 + 48, a4);
  *(_BYTE *)(v7 + 25) = 1;
  *(_DWORD *)(v7 + 28) = 16;
  return v7;
}
// 1005CC30: using guessed type int (__stdcall *off_1005CC30)(char);
// 1005CE04: using guessed type int (__stdcall *off_1005CE04)(char);

//----- (1001EF00) --------------------------------------------------------
int __thiscall sub_1001EF00(int this)
{
  int v2; // edi@1
  int v3; // esi@1
  int result; // eax@2
  int v17; // edi@5
  int v30; // edi@9

  v3 = this;
  *(_DWORD *)this = &off_1005CC30;
  v2 = *(_DWORD *)(this + 52);
  _EBX = -1;
  if ( v2 )
  {
    result = v2 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v2)(v2);
      result = v2 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v2 + 4))(v2, _EDX);
    }
  }
  v17 = *(_DWORD *)(v3 + 44);
  if ( v17 )
  {
    result = v17 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v17)(v17);
      result = v17 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v17 + 4))(v17, _EDX);
    }
  }
  *(_DWORD *)v3 = &off_1005CE04;
  v30 = *(_DWORD *)(v3 + 36);
  if ( v30 )
  {
    result = v30 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v30)(v30);
      result = v30 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v30 + 4))(v30);
    }
  }
  *(_DWORD *)v3 = &off_10055E44;
  return result;
}
// 10055E44: using guessed type int (__stdcall *off_10055E44)(char);
// 1005CC30: using guessed type int (__stdcall *off_1005CC30)(char);
// 1005CE04: using guessed type int (__stdcall *off_1005CE04)(char);

//----- (1001EFA0) --------------------------------------------------------
void *__thiscall sub_1001EFA0(int this, char a2)
{
  int v2; // ecx@1
  int v3; // edi@1
  void *v4; // esi@1
  int v5; // ecx@3

  v4 = (void *)this;
  v3 = this + 8;
  *(_DWORD *)this = off_1005CC38;
  v2 = *(_DWORD *)(this + 24);
  if ( v2 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v2 + 16))(v2 != v3);
    *(_DWORD *)(v3 + 16) = 0;
  }
  v5 = *(_DWORD *)(v3 + 16);
  if ( v5 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v5 + 16))(v5 != v3);
    *(_DWORD *)(v3 + 16) = 0;
  }
  *(_DWORD *)v4 = off_1005C020;
  if ( a2 & 1 )
    sub_1002404A(v4);
  return v4;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005C020: using guessed type int (*off_1005C020[5])();
// 1005CC38: using guessed type int (__stdcall *off_1005CC38[2])(int);

//----- (1001F010) --------------------------------------------------------
int __userpurge sub_1001F010<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  int v4; // esi@1

  v4 = a1;
  sub_1001EF00(a1);
  if ( a4 & 1 )
    sub_10028747(a2, a3, v4);
  return v4;
}

//----- (1001F040) --------------------------------------------------------
int __usercall sub_1001F040<eax>(int a1<eax>, int a2)
{
  int v2; // esi@1
  int v4; // edx@4
  unsigned int v5; // [sp-18h] [bp-54h]@1
  int v6; // [sp-14h] [bp-50h]@3
  int v7; // [sp-10h] [bp-4Ch]@3
  int v8; // [sp-Ch] [bp-48h]@3
  char v9; // [sp-8h] [bp-44h]@3
  int v10; // [sp+0h] [bp-3Ch]@4
  int v11; // [sp+4h] [bp-38h]@4
  int v12; // [sp+8h] [bp-34h]@1
  unsigned int v13; // [sp+28h] [bp-14h]@1
  unsigned int *v14; // [sp+2Ch] [bp-10h]@1
  int v15; // [sp+30h] [bp-Ch]@1
  int (__cdecl *v16)(int, int); // [sp+34h] [bp-8h]@1
  int v17; // [sp+38h] [bp-4h]@1
  _DWORD *v18; // [sp+3Ch] [bp+0h]@1

  v18 = &v18;
  v17 = -1;
  v16 = sub_10052A40;
  v15 = a1;
  v13 = (unsigned int)&v18 ^ __security_cookie;
  v5 = (unsigned int)&v18 ^ __security_cookie;
  v14 = &v5;
  v2 = *(_DWORD *)(a2 + 32);
  v12 = a2;
  sub_1002426D((int)&v18, v2 + 100);
  v17 = -1;
  if ( *(_DWORD *)(v2 + 84) == 4 )
  {
    sub_100242C1();
  }
  else
  {
    *(_DWORD *)(v2 + 84) = 1;
    sub_100242C1();
    v17 = 1;
    LOBYTE(v10) = 0;
    LOBYTE(v11) = 0;
    sub_1001F150(v4, a2, a2, v11, v10);
  }
  return sub_10022B30(v8, v6, v7, (unsigned int)&v18 ^ v13, v9);
}
// 10052A40: using guessed type int __cdecl sub_10052A40(int, int);
// 10067210: using guessed type int __security_cookie;

//----- (1001F150) --------------------------------------------------------
void __userpurge sub_1001F150(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // edx@1
  int v6; // ebx@1
  int ebp0; // ebp@0
  int v9; // esi@1
  int v10; // ebx@1
  int v11; // eax@1
  int v26; // eax@9
  int v27; // ebx@11
  int v28; // eax@11
  int v29; // edx@15
  void **v43; // [sp-20h] [bp-94h]@9
  char v44; // [sp-1Ch] [bp-90h]@9
  int v45; // [sp-18h] [bp-8Ch]@11
  int v46; // [sp-14h] [bp-88h]@11
  char v47; // [sp-8h] [bp-7Ch]@6
  int v48; // [sp-4h] [bp-78h]@6
  char v49; // [sp+10h] [bp-64h]@1
  int v50; // [sp+14h] [bp-60h]@1
  int v51; // [sp+18h] [bp-5Ch]@1
  char *v52; // [sp+1Ch] [bp-58h]@1
  int v53; // [sp+20h] [bp-54h]@1
  char v54; // [sp+24h] [bp-50h]@1
  int v55; // [sp+28h] [bp-4Ch]@1
  char v56; // [sp+2Ch] [bp-48h]@11
  int v57; // [sp+3Ch] [bp-38h]@14
  unsigned int v58; // [sp+60h] [bp-14h]@1
  int v59; // [sp+70h] [bp-4h]@1

  v58 = (unsigned int)&v49 ^ __security_cookie;
  v10 = a2;
  v53 = a2;
  v50 = 0;
  v51 = 0;
  sub_1001BFC0(a1, (int)&v50, a3, a2);
  v59 = 0;
  v11 = sub_10001AA0((int)&v54, v10 + 40);
  v9 = *(_DWORD *)(v11 + 4);
  *(_DWORD *)(v11 + 4) = v51;
  v5 = *(_DWORD *)v11;
  *(_DWORD *)v11 = v50;
  v6 = v55;
  _EDI = -1;
  v51 = v9;
  v52 = (char *)v5;
  v50 = v5;
  if ( v55 )
  {
    _EAX = v55 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v6)(v6);
      _EAX = v6 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v6 + 4))(v6, _EDX);
      v5 = (int)v52;
    }
  }
  v52 = &v47;
  *(_DWORD *)&v47 = 0;
  v48 = 0;
  if ( (int *)&v47 != &v50 )
  {
    v48 = v9;
    v9 = 0;
    v51 = 0;
    *(_DWORD *)&v47 = v5;
    v50 = 0;
  }
  if ( &v47 )
  {
    v43 = &off_1005CC14;
    sub_10001AA0((int)&v44, v53 + 48);
    v26 = (int)&v43;
  }
  else
  {
    v26 = 0;
  }
  LOBYTE(v59) = 1;
  v28 = sub_1001F350((int)&v56, (char)v43, *(int *)&v44, v45, v46, v26);
  LOBYTE(v59) = 4;
  v27 = *(_DWORD *)(v53 + 32);
  *(_BYTE *)(v27 + 152) = sub_1001F3D0(v28, v47, v48);
  sub_1002426D(ebp0, v27 + 100);
  LOBYTE(v59) = 4;
  if ( *(_DWORD *)(v27 + 84) == 4 )
  {
    sub_100242C1();
  }
  else
  {
    *(_DWORD *)(v27 + 84) = 3;
    sub_100242C1();
    sub_10025148(ebp0);
    sub_10001730(v27);
  }
  LOBYTE(v59) = 0;
  if ( v57 )
  {
    v29 = *(_DWORD *)v57;
    v48 = v57 != (_DWORD)&v56;
    (*(void (__stdcall **)(int))(v29 + 16))(v48);
    v57 = 0;
  }
  v59 = -1;
  if ( v9 )
  {
    _EAX = v9 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v9)(v9);
      _EAX = v9 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (**)(void))(*(_DWORD *)v9 + 4))();
    }
  }
}
// 1005CC14: using guessed type void *off_1005CC14;
// 10067210: using guessed type int __security_cookie;

//----- (1001F350) --------------------------------------------------------
int __thiscall sub_1001F350(int this, char a2, int a3, int a4, int a5, int a6)
{
  int v6; // edi@1

  v6 = this;
  sub_1001F460((int)&a2, this, this);
  if ( a6 )
    (*(void (__stdcall **)(bool))(*(_DWORD *)a6 + 16))(a6 != (_DWORD)&a2);
  return v6;
}

//----- (1001F3D0) --------------------------------------------------------
char __thiscall sub_1001F3D0(int this, char a2, int a3)
{
  int v3; // ecx@1
  char v4; // bl@3
  int v5; // esi@3

  v3 = *(_DWORD *)(this + 16);
  if ( !v3 )
    sub_10021BF6();
  v5 = a3;
  v4 = (*(int (__stdcall **)(char *))(*(_DWORD *)v3 + 8))(&a2);
  if ( a3 )
  {
    _EDI = -1;
    _EDX = a3 + 4;
    _ECX = -1;
    __asm { lock xadd [edx], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      _EAX = v5 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (**)(void))(*(_DWORD *)v5 + 4))();
    }
  }
  return v4;
}

//----- (1001F460) --------------------------------------------------------
int __usercall sub_1001F460<eax>(int a1<edx>, int a2<ecx>, int a3<edi>)
{
  int v3; // ecx@1
  int v4; // esi@1
  char *v6; // [sp-4h] [bp-3Ch]@4
  char v7; // [sp+8h] [bp-30h]@1
  int v8; // [sp+18h] [bp-20h]@2
  char *v9; // [sp+20h] [bp-18h]@1
  int v10; // [sp+24h] [bp-14h]@1
  int v11; // [sp+28h] [bp-10h]@1
  int v12; // [sp+34h] [bp-4h]@1

  v4 = a2;
  v11 = a2;
  v10 = 0;
  v9 = &v7;
  v12 = 0;
  v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    if ( v3 == a1 )
    {
      a1 = (int)&v7;
      v6 = &v7;
    }
    else
    {
      v6 = 0;
    }
    v8 = (**(int (__fastcall ***)(int, int, char *))v3)(v3, a1, v6);
  }
  else
  {
    v8 = 0;
  }
  v12 = 2;
  sub_1001F6A0(a1, v4, a3, (int)&v7, v3);
  v12 = -1;
  if ( v8 )
    (*(void (__stdcall **)(bool))(*(_DWORD *)v8 + 16))(v8 != (_DWORD)&v7);
  return v4;
}

//----- (1001F510) --------------------------------------------------------
int __thiscall sub_1001F510(int this, char a2, int a3)
{
  int v3; // ecx@1
  int result; // eax@3
  int v5; // esi@3

  v3 = *(_DWORD *)(this + 16);
  if ( !v3 )
    sub_10021BF6();
  result = (*(int (__stdcall **)(char *))(*(_DWORD *)v3 + 8))(&a2);
  v5 = a3;
  if ( a3 )
  {
    _EDI = -1;
    _ECX = a3 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      result = v5 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (**)(void))(*(_DWORD *)v5 + 4))();
    }
  }
  return result;
}

//----- (1001F5E0) --------------------------------------------------------
int __userpurge sub_1001F5E0<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v3; // edi@1
  int v4; // ecx@2
  int v6; // [sp-8h] [bp-18h]@1
  int v7; // [sp-4h] [bp-14h]@1

  v3 = a1;
  v6 = 0;
  v7 = 0;
  if ( &v6 != (int *)a3 )
  {
    v7 = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(a3 + 4) = 0;
    v4 = v6;
    v6 = *(_DWORD *)a3;
    *(_DWORD *)a3 = v4;
  }
  return sub_1001E8A0((int)&v6, (int *)(v3 + 4), a2, v6, v7);
}

//----- (1001F630) --------------------------------------------------------
int (__stdcall ***__cdecl sub_1001F630())(char)
{
  return &off_10068A94;
}
// 10068A94: using guessed type int (__stdcall **off_10068A94)(char);

//----- (1001F640) --------------------------------------------------------
void *__thiscall sub_1001F640(int this, char a2)
{
  int v2; // edi@1
  void *v3; // esi@1

  v3 = (void *)this;
  *(_DWORD *)this = &off_1005CC14;
  v2 = *(_DWORD *)(this + 8);
  if ( v2 )
  {
    _EBX = -1;
    _EDX = v2 + 4;
    _EAX = -1;
    __asm { lock xadd [edx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v2)(v2);
      _EAX = v2 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 4))(v2);
    }
  }
  *(_DWORD *)v3 = off_1005C020;
  if ( a2 & 1 )
    sub_1002404A(v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005C020: using guessed type int (*off_1005C020[5])();
// 1005CC14: using guessed type void *off_1005CC14;

//----- (1001F6A0) --------------------------------------------------------
int __userpurge sub_1001F6A0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // esi@1
  int v6; // ecx@3
  int result; // eax@9
  int v8; // [sp-4h] [bp-30h]@6
  int v9; // [sp+1Ch] [bp-10h]@1

  v9 = a2;
  v5 = sub_10027EB3(a1, a2, a4, a3, 40);
  if ( !v5 )
    sub_10021BC5();
  *(_DWORD *)v5 = off_1005CBF8;
  v6 = *(_DWORD *)(a4 + 16);
  if ( v6 )
  {
    if ( v6 == a4 )
      v8 = v5 + 8;
    else
      v8 = 0;
    *(_DWORD *)(v5 + 24) = (**(int (__stdcall ***)(_DWORD))v6)(v8);
  }
  else
  {
    *(_DWORD *)(v5 + 24) = 0;
  }
  result = v9;
  *(_DWORD *)(v9 + 16) = v5;
  return result;
}
// 1005CBF8: using guessed type int (__stdcall *off_1005CBF8[2])(int);

//----- (1001F740) --------------------------------------------------------
int __userpurge sub_1001F740<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4)
{
  int v4; // ebx@1
  int v5; // esi@1
  int v6; // ecx@5
  int v7; // eax@8

  v4 = a2;
  v5 = a4;
  if ( !a4 )
  {
    v5 = sub_10027EB3(a1, a2, a2, a3, 40);
    if ( !v5 )
      sub_10021BC5();
  }
  if ( v5 )
  {
    *(_DWORD *)v5 = off_1005CBF8;
    v6 = *(_DWORD *)(v4 + 24);
    if ( v6 )
    {
      if ( v6 == v4 + 8 )
        v7 = (**(int (__stdcall ***)(_DWORD))v6)(v5 + 8);
      else
        v7 = (**(int (__stdcall ***)(_DWORD))v6)(0);
      *(_DWORD *)(v5 + 24) = v7;
    }
    else
    {
      *(_DWORD *)(v5 + 24) = 0;
    }
  }
  return v5;
}
// 1005CBF8: using guessed type int (__stdcall *off_1005CBF8[2])(int);

//----- (1001F7E0) --------------------------------------------------------
char __usercall sub_1001F7E0<al>(int a1<eax>, int a2<ecx>, int a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int v5; // eax@2
  char v21; // [sp-14h] [bp-28h]@3
  int v22; // [sp-10h] [bp-24h]@3
  unsigned int v23; // [sp-Ch] [bp-20h]@1
  int v24; // [sp+0h] [bp-14h]@1
  int v25; // [sp+4h] [bp-10h]@1
  int v26; // [sp+8h] [bp-Ch]@1
  int (__cdecl *v27)(int, int); // [sp+Ch] [bp-8h]@1
  int v28; // [sp+10h] [bp-4h]@1
  _DWORD *v29; // [sp+14h] [bp+0h]@1

  v29 = &v29;
  v28 = -1;
  v27 = sub_10051E68;
  v26 = a1;
  v23 = (unsigned int)&v29 ^ __security_cookie;
  v3 = a2 + 8;
  v4 = 0;
  v24 = 0;
  v25 = 0;
  if ( &v24 != (int *)a3 )
  {
    v4 = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(a3 + 4) = 0;
    v5 = *(_DWORD *)a3;
    v25 = v4;
    v24 = v5;
    *(_DWORD *)a3 = 0;
  }
  v28 = 0;
  sub_10001AA0((int)&v21, (int)&v24);
  sub_1001F510(v3, v21, v22);
  v28 = -1;
  if ( v4 )
  {
    _EDI = -1;
    _ECX = v4 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v4)(v4);
      _EAX = v4 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 4))(v4);
    }
  }
  return 0;
}
// 10051E68: using guessed type int __cdecl sub_10051E68(int, int);
// 10067210: using guessed type int __security_cookie;

//----- (1001F928) --------------------------------------------------------
void *__userpurge sub_1001F928<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  return sub_10018A10(a1 - 16, a2, a3, a4);
}

//----- (1001F930) --------------------------------------------------------
int __thiscall sub_1001F930(int this)
{
  return *(_DWORD *)(this + 4);
}

//----- (1001F940) --------------------------------------------------------
void __thiscall sub_1001F940(void *this, int a2)
{
  int v2; // eax@1
  signed int v3; // ebx@1
  int ebp0; // ebp@0
  void *v5; // esi@1
  int v6; // ebx@7
  int v7; // ebx@8
  int v8; // ebx@10
  int v9; // eax@10
  int v24; // ebx@15
  int v25; // eax@15
  int v40; // edi@20
  int *v41; // eax@20
  char v56; // [sp+10h] [bp-48h]@10
  int v57; // [sp+14h] [bp-44h]@10
  char v58; // [sp+18h] [bp-40h]@20
  int v59; // [sp+1Ch] [bp-3Ch]@20
  char v60; // [sp+20h] [bp-38h]@15
  int v61; // [sp+24h] [bp-34h]@15
  unsigned int v62; // [sp+44h] [bp-14h]@1
  int v63; // [sp+54h] [bp-4h]@10
  int v64; // [sp+58h] [bp+0h]@1

  v62 = (unsigned int)&v64 ^ __security_cookie;
  v5 = this;
  v3 = 0;
  sub_1002426D(ebp0, (int)((char *)this + 100));
  v2 = *((_DWORD *)v5 + 21);
  if ( v2 != 3 )
  {
    if ( v2 != 4 )
    {
      *(_DWORD *)(a2 + 20) = *((_DWORD *)v5 + 33);
      *((_DWORD *)v5 + 33) = a2;
      goto LABEL_7;
    }
    if ( !*(_BYTE *)(a2 + 25) )
    {
      v3 = 2;
      goto LABEL_7;
    }
  }
  v3 = 1;
LABEL_7:
  sub_100242C1();
  v6 = v3 - 1;
  if ( v6 )
  {
    v7 = v6 - 1;
    if ( v7 )
    {
      if ( v7 == 1 )
      {
        v9 = (*(int (__thiscall **)(int, char *))(*(_DWORD *)a2 + 4))(a2, &v56);
        v63 = 4;
        (*(void (__stdcall **)(signed int, signed int, signed int, char *))(**(_DWORD **)v9 + 4))(
          1,
          1,
          1,
          (char *)v5 + 92);
        v63 = -1;
        v8 = v57;
        if ( v57 )
        {
          _ESI = -1;
          _ECX = v57 + 4;
          _EAX = -1;
          __asm { lock xadd [ecx], eax }
          if ( _ZF )
          {
            (**(void (__thiscall ***)(_DWORD))v8)(v8);
            _EAX = v8 + 8;
            __asm { lock xadd [eax], esi }
            if ( _ESI == 1 )
              (*(void (__thiscall **)(int))(*(_DWORD *)v8 + 4))(v8);
          }
        }
        (**(void (__thiscall ***)(_DWORD, _DWORD))a2)(a2, 1);
      }
    }
    else
    {
      v25 = (*(int (__thiscall **)(int, char *))(*(_DWORD *)a2 + 4))(a2, &v60);
      v63 = 3;
      (*(void (__stdcall **)(signed int, _DWORD, _DWORD, int))(**(_DWORD **)v25 + 4))(1, 0, 0, *(_DWORD *)v25 + 92);
      v63 = -1;
      v24 = v61;
      if ( v61 )
      {
        _ESI = -1;
        _ECX = v61 + 4;
        _EAX = -1;
        __asm { lock xadd [ecx], eax }
        if ( _ZF )
        {
          (**(void (__thiscall ***)(_DWORD))v24)(v24);
          _EAX = v24 + 8;
          __asm { lock xadd [eax], esi }
          if ( _ESI == 1 )
            (*(void (__thiscall **)(int))(*(_DWORD *)v24 + 4))(v24);
        }
      }
      (**(void (__thiscall ***)(_DWORD, _DWORD))a2)(a2, 1);
    }
  }
  else
  {
    v41 = (int *)(*(int (__thiscall **)(_DWORD, char *))(*(_DWORD *)a2 + 4))(a2, &v58);
    v63 = 0;
    sub_100016A0(*v41, 0, a2, a2, *(_DWORD *)(a2 + 28));
    v63 = -1;
    v40 = v59;
    if ( v59 )
    {
      _ESI = -1;
      _ECX = v59 + 4;
      _EAX = -1;
      __asm { lock xadd [ecx], eax }
      if ( _ZF )
      {
        (**(void (__thiscall ***)(_DWORD))v40)(v40);
        _EAX = v40 + 8;
        __asm { lock xadd [eax], esi }
        if ( _ESI == 1 )
          (*(void (**)(void))(*(_DWORD *)v40 + 4))();
      }
    }
  }
}
// 10067210: using guessed type int __security_cookie;

//----- (1001FB00) --------------------------------------------------------
void *__thiscall sub_1001FB00(void *this, int a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_1005D2B4;
  sub_10024BDF((int)((char *)this + 4));
  sub_10024BDF((int)((char *)v2 + 44));
  *((_DWORD *)v2 + 21) = 0;
  *((_WORD *)v2 + 44) = 0;
  *((_BYTE *)v2 + 90) = 0;
  *((_DWORD *)v2 + 23) = 0;
  *((_DWORD *)v2 + 24) = 0;
  sub_10024232((int)((char *)v2 + 100));
  *((_DWORD *)v2 + 33) = 0;
  *((_DWORD *)v2 + 35) = 0;
  *((_DWORD *)v2 + 36) = 0;
  *((_DWORD *)v2 + 37) = 0;
  *((_DWORD *)v2 + 34) = a2;
  if ( a2 != 2 )
  {
    _EAX = a2 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  return v2;
}
// 1005D2B4: using guessed type int (__stdcall *off_1005D2B4)(char);

//----- (1001FBD0) --------------------------------------------------------
int __usercall sub_1001FBD0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v3; // eax@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ebx@2
  int *v8; // [sp+20h] [bp-10h]@1

  v8 = (int *)a1;
  v4 = a2;
  v3 = sub_10027EB3(a1, a2, a3, a2, 168);
  v5 = v3;
  if ( v3 )
  {
    *(_DWORD *)(v3 + 4) = 1;
    *(_DWORD *)(v3 + 8) = 1;
    v6 = v3 + 12;
    *(_DWORD *)v3 = off_1005CD4C;
    if ( v3 != -12 )
    {
      sub_1001FB00((void *)(v3 + 12), *v8);
      *(_DWORD *)v6 = &off_1005D2AC;
    }
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)v4 = v5 + 12;
  *(_DWORD *)(v4 + 4) = v5;
  return v4;
}
// 1005CD4C: using guessed type int (*off_1005CD4C[2])();
// 1005D2AC: using guessed type int (__stdcall *off_1005D2AC)(char);

//----- (1001FC80) --------------------------------------------------------
int __usercall sub_1001FC80<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v4; // esi@1
  int v5; // [sp+8h] [bp-8h]@1
  unsigned int v6; // [sp+Ch] [bp-4h]@1
  int v7; // [sp+10h] [bp+0h]@1

  v6 = (unsigned int)&v7 ^ __security_cookie;
  v5 = a1;
  v4 = a2;
  sub_1001FBD0((int)&v5, a2, a3);
  return v4;
}
// 10067210: using guessed type int __security_cookie;

//----- (1001FCC0) --------------------------------------------------------
int __cdecl sub_1001FCC0(int a1)
{
  return (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD, int))(*(_DWORD *)a1 + 4))(0, 0, 0, a1 + 92);
}

//----- (1001FCE0) --------------------------------------------------------
int __thiscall sub_1001FCE0(int this, int a2)
{
  int result; // eax@1
  int v4; // ecx@1
  int v5; // ebx@1
  int v7; // esi@3
  int v19; // esi@7
  int v31; // esi@12
  char v32; // [sp+10h] [bp-14h]@1
  char v33; // [sp+18h] [bp-Ch]@1
  int v34; // [sp+1Ch] [bp-8h]@7

  v5 = this;
  result = sub_1001FC80(a2, (int)&v33, this);
  v4 = 0;
  _EDX = 0;
  if ( &v32 != (char *)result )
  {
    _EDX = *(_DWORD *)(result + 4);
    *(_DWORD *)(result + 4) = 0;
    v4 = *(_DWORD *)result;
    *(_DWORD *)result = 0;
  }
  v7 = *(_DWORD *)(v5 + 4);
  _EDI = -1;
  *(_DWORD *)(v5 + 4) = _EDX;
  *(_DWORD *)v5 = v4;
  if ( v7 )
  {
    result = v7 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v7)(v7);
      result = v7 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v7 + 4))(v7, _EDX);
    }
  }
  v19 = v34;
  if ( v34 )
  {
    result = v34 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v19)(v19);
      result = v19 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v19 + 4))(v19);
    }
  }
  if ( a2 != 2 )
  {
    v31 = *(_DWORD *)v5;
    result = sub_10027DED(_EDX, *(_DWORD *)(*(_DWORD *)v5 + 136), v5, (int)sub_1001FCC0, *(_DWORD *)v5, 1);
    *(_DWORD *)(v31 + 140) = result;
  }
  return result;
}

//----- (1001FDA0) --------------------------------------------------------
int __thiscall sub_1001FDA0(void *this, int a2)
{
  int v2; // esi@1
  int v4; // [sp+14h] [bp-1Ch]@1
  int v5; // [sp+18h] [bp-18h]@1
  unsigned int v6; // [sp+1Ch] [bp-14h]@1
  int v7; // [sp+2Ch] [bp-4h]@1
  int v8; // [sp+30h] [bp+0h]@1

  v6 = (unsigned int)&v8 ^ __security_cookie;
  v2 = (int)this;
  v4 = 0;
  v5 = 0;
  sub_10023491((int)&v4);
  v7 = 0;
  if ( a2 )
  {
    sub_10023461(&v4);
    sub_10023441(v2, (int)&v4);
    v7 = -1;
    sub_100234E2((int)&v4);
  }
  else
  {
    sub_10023441(v2, (int)&v4);
    v7 = -1;
    sub_100234E2((int)&v4);
  }
  return v2;
}
// 10023441: using guessed type int __cdecl sub_10023441(int, int);
// 10067210: using guessed type int __security_cookie;

//----- (1001FE60) --------------------------------------------------------
int __userpurge sub_1001FE60<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_10055A70;
  return v4;
}
// 10055A70: using guessed type int (__stdcall *off_10055A70)(char);

//----- (1001FE80) --------------------------------------------------------
int __userpurge sub_1001FE80<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_10055678;
  return v4;
}
// 10055678: using guessed type int (__stdcall *off_10055678)(char);

//----- (1001FEB0) --------------------------------------------------------
int __userpurge sub_1001FEB0<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_10055690;
  return v4;
}
// 10055690: using guessed type int (__stdcall *off_10055690)(char);

//----- (1001FED0) --------------------------------------------------------
int __userpurge sub_1001FED0<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_10055684;
  return v4;
}
// 10055684: using guessed type int (__stdcall *off_10055684)(char);

//----- (1001FEF0) --------------------------------------------------------
DWORD __thiscall sub_1001FEF0(int this)
{
  DWORD result; // eax@1
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 8) = 0;
  result = sub_100247A0();
  if ( result )
  {
    *(_DWORD *)v2 = result;
    *(_DWORD *)(v2 + 4) = 1;
    *(_DWORD *)(v2 + 8) = 1;
  }
  else
  {
    *(_DWORD *)(v2 + 8) = 4;
  }
  return result;
}

//----- (1001FF20) --------------------------------------------------------
char __thiscall sub_1001FF20(int this)
{
  unsigned int v1; // eax@1
  int v2; // esi@1
  char result; // al@4
  char v4; // zf@5
  char v5; // zf@8

  v2 = this;
  v1 = *(_DWORD *)(this + 8);
  while ( 2 )
  {
    switch ( v1 )
    {
      case 0u:
        sub_1001FEF0(v2);
        v1 = *(_DWORD *)(v2 + 8);
        if ( v1 <= 4 )
          continue;
        result = 0;
        break;
      case 1u:
        __asm { pause                   ; jumptable 1001FF30 case 1 }
        v4 = *(_DWORD *)v2-- == 1;
        if ( v4 )
          *(_DWORD *)(v2 + 8) = 3 - (*(_DWORD *)(v2 + 4) != 0);
        result = 1;
        break;
      case 2u:
        v5 = *(_DWORD *)(v2 + 4)-- == 1;
        if ( v5 )
          *(_DWORD *)(v2 + 8) = 3;
        (*(void (**)(void))(v2 + 12))();
        result = 1;
        break;
      case 3u:
        sub_1001FEF0(v2);
        result = 0;
        break;
      case 4u:
        (*(void (**)(void))(v2 + 12))();
        goto LABEL_13;
      default:
LABEL_13:
        result = 0;
        break;
    }
    return result;
  }
}

//----- (1001FFA0) --------------------------------------------------------
int __userpurge sub_1001FFA0<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_100542CC;
  return v4;
}
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);

//----- (1001FFC0) --------------------------------------------------------
int __userpurge sub_1001FFC0<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_100542C0;
  return v4;
}
// 100542C0: using guessed type int (__stdcall *off_100542C0)(char);

//----- (1001FFE0) --------------------------------------------------------
void *__thiscall sub_1001FFE0(void *this, int a2)
{
  void *v2; // esi@1
  int v3; // edx@2
  int v4; // ecx@2
  int v5; // edi@4
  void *result; // eax@8
  char v21; // [sp+4h] [bp-8h]@2

  v2 = this;
  if ( this == (void *)a2 )
  {
    result = this;
  }
  else
  {
    v4 = 0;
    v3 = 0;
    if ( &v21 != (char *)a2 )
    {
      v3 = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a2 + 4) = 0;
      v4 = *(_DWORD *)a2;
      *(_DWORD *)a2 = 0;
    }
    v5 = *((_DWORD *)v2 + 1);
    *((_DWORD *)v2 + 1) = v3;
    *(_DWORD *)v2 = v4;
    if ( v5 )
    {
      _EBX = -1;
      _ECX = v5 + 4;
      _EAX = -1;
      __asm { lock xadd [ecx], eax }
      if ( _ZF )
      {
        (**(void (__thiscall ***)(_DWORD))v5)(v5);
        _EAX = v5 + 8;
        __asm { lock xadd [eax], ebx }
        if ( _EBX == 1 )
          (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
      }
      result = v2;
    }
    else
    {
      result = v2;
    }
  }
  return result;
}

//----- (10020060) --------------------------------------------------------
int __usercall sub_10020060<eax>(const void *a1<ecx>, int a2<edi>, char a3)
{
  sub_100234F1(a1, a2, (const void **)&a3);
  return sub_100234E2((int)&a3);
}

//----- (100200C0) --------------------------------------------------------
int __usercall sub_100200C0<eax>(int a1<ecx>, int a2<edi>)
{
  const void *v3; // ecx@3
  char v4; // [sp+4h] [bp-18h]@3
  int v5; // [sp+18h] [bp-4h]@3

  if ( !*(_DWORD *)a1 )
    *(_DWORD *)a1 = 1;
  sub_10023441((int)&v4, a1 + 4);
  v5 = 0;
  sub_100234F1(v3, a2, (const void **)&v4);
  v5 = -1;
  return sub_100234E2((int)&v4);
}
// 10023441: using guessed type int __cdecl sub_10023441(int, int);

//----- (10020140) --------------------------------------------------------
signed int __usercall sub_10020140<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // ebx@1
  int ebp0; // ebp@0
  int v4; // edi@1
  char *v5; // esi@3
  int v6; // ecx@5
  signed int result; // eax@7
  char v8; // [sp+0h] [bp-30h]@1
  char *v9; // [sp+18h] [bp-18h]@3
  int v10; // [sp+1Ch] [bp-14h]@1
  char *v11; // [sp+20h] [bp-10h]@1
  int v12; // [sp+2Ch] [bp-4h]@3

  v11 = &v8;
  v4 = a1;
  v10 = a1;
  sub_10025249(ebp0, a2, a1, -1);
  v2 = *(_DWORD *)(v4 + 144);
  if ( !v2
    || *(_BYTE *)(v4 + 88)
    || (v12 = 0,
        v5 = sub_10027C83(v2, ebp0, v4),
        v9 = v5,
        ++*(_DWORD *)v5,
        LOBYTE(v12) = 1,
        sub_10026494(v2, ebp0, v4, v2 + 8, 0),
        --*(_DWORD *)v5,
        v12 = -1,
        *(_BYTE *)(v4 + 90)) )
    sub_10025249(ebp0, v2, v4, -1);
  v6 = *(_DWORD *)(v4 + 92);
  if ( v6 )
  {
    sub_100200C0(v6, v4);
  }
  else
  {
    result = 2;
    if ( *(_DWORD *)(v4 + 84) == 4 )
      return result;
  }
  return 1;
}

//----- (10020240) --------------------------------------------------------
int __thiscall sub_10020240(int this, char a2)
{
  int v2; // eax@1
  int ebp0; // ebp@0
  int v4; // esi@1
  int v5; // ecx@2

  v4 = this;
  *(_DWORD *)this = &off_1005D2AC;
  v2 = *(_DWORD *)(this + 140);
  if ( v2 )
  {
    sub_10027CF1(ebp0, v2);
    v5 = *(_DWORD *)(v4 + 140);
    _EDX = -1;
    _EAX = v5 + 4;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v5 + 4))();
    *(_DWORD *)(v4 + 140) = 0;
  }
  sub_10020640(v4);
  if ( a2 & 1 )
    sub_1002404A((LPVOID)v4);
  return v4;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005D2AC: using guessed type int (__stdcall *off_1005D2AC)(char);

//----- (100202F0) --------------------------------------------------------
void *__thiscall sub_100202F0(void *this, int a2)
{
  int v2; // edi@1
  void *v3; // esi@1
  int v4; // eax@1
  int v5; // edx@1
  int v6; // edx@1
  char v22; // [sp+10h] [bp-Ch]@1
  int v23; // [sp+14h] [bp-8h]@1

  v3 = this;
  v4 = sub_10001AA0((int)&v22, a2);
  v5 = *(_DWORD *)(v4 + 4);
  *(_DWORD *)(v4 + 4) = *((_DWORD *)v3 + 1);
  *((_DWORD *)v3 + 1) = v5;
  v6 = *(_DWORD *)v4;
  *(_DWORD *)v4 = *(_DWORD *)v3;
  v2 = v23;
  *(_DWORD *)v3 = v6;
  if ( v2 )
  {
    _EBX = -1;
    _ECX = v2 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v2)(v2);
      _EAX = v2 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 4))(v2);
    }
  }
  return v3;
}

//----- (100203A0) --------------------------------------------------------
int __usercall sub_100203A0<eax>(int a1<ecx>, int a2<edi>)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // ebx@1
  int ebp0; // ebp@0
  char *v6; // esi@1
  int v7; // ecx@2
  int result; // eax@4
  int v9; // eax@5
  int v10; // ecx@5
  int v11; // edi@5
  int v12; // eax@8

  v4 = a1;
  v6 = sub_10027C83(a1, ebp0, a2);
  ++*(_DWORD *)v6;
  if ( *(_DWORD *)v6 > 0x10u )
  {
    v9 = sub_10027EB3(v2, v3, v4, a2, 24);
    v11 = v9;
    if ( v9 )
    {
      v10 = *(_DWORD *)(v4 + 16);
      if ( v10 )
      {
        v12 = *(_DWORD *)v10;
        if ( v10 == v4 )
          *(_DWORD *)(v11 + 16) = (*(int (__stdcall **)(int))v12)(v11);
        else
          *(_DWORD *)(v11 + 16) = (*(int (__stdcall **)(_DWORD))v12)(0);
      }
      else
      {
        *(_DWORD *)(v9 + 16) = 0;
      }
    }
    else
    {
      v11 = 0;
    }
    result = sub_10027E9C(v10, v4, v11, (int)&loc_10001530, v11);
    --*(_DWORD *)v6;
  }
  else
  {
    v7 = *(_DWORD *)(v4 + 16);
    if ( !v7 )
      sub_10021BF6();
    result = (*(int (**)(void))(*(_DWORD *)v7 + 8))();
    --*(_DWORD *)v6;
  }
  return result;
}

//----- (10020470) --------------------------------------------------------
void *__thiscall sub_10020470(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10055E44;
  if ( a2 & 1 )
    sub_1002404A(this);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10055E44: using guessed type int (__stdcall *off_10055E44)(char);

//----- (100204B0) --------------------------------------------------------
int (__stdcall ***__cdecl sub_100204B0())(char)
{
  return &off_10068DEC;
}
// 10068DEC: using guessed type int (__stdcall **off_10068DEC)(char);

//----- (100204C0) --------------------------------------------------------
char __thiscall sub_100204C0(void *this, char a2, char a3, int a4, int a5)
{
  char v5; // bl@1
  int ebp0; // ebp@0
  int v7; // esi@1
  int v8; // eax@7
  int v10; // ecx@14
  char v11; // [sp+10h] [bp-4Ch]@1
  void **v12; // [sp+14h] [bp-48h]@18
  int v13; // [sp+18h] [bp-44h]@18
  int *v14; // [sp+24h] [bp-38h]@18
  unsigned int v15; // [sp+48h] [bp-14h]@1
  int v16; // [sp+58h] [bp-4h]@1

  v15 = (unsigned int)&v11 ^ __security_cookie;
  v7 = (int)this;
  v5 = 0;
  sub_1002426D(ebp0, (int)((char *)this + 100));
  v16 = 0;
  if ( !a3 )
  {
    v8 = *(_DWORD *)(v7 + 84);
    if ( v8 != 3 && v8 != 4 )
    {
      if ( v8 != 2 )
        goto LABEL_4;
      if ( a2 )
      {
LABEL_13:
        *(_DWORD *)(v7 + 84) = 4;
        sub_10025148(ebp0);
        v5 = 1;
        goto LABEL_14;
      }
    }
LABEL_11:
    v16 = -1;
    sub_100242C1();
    return 0;
  }
  if ( *(_DWORD *)(v7 + 84) == 4 )
    goto LABEL_11;
  sub_100202F0((void *)(v7 + 92), a5);
LABEL_4:
  if ( a2 || !*(_DWORD *)(v7 + 84) )
    goto LABEL_13;
  *(_DWORD *)(v7 + 84) = 2;
LABEL_14:
  v10 = *(_DWORD *)(v7 + 144);
  if ( v10 )
    sub_10025F04(v10 + 8, v5, a5);
  v16 = -1;
  sub_100242C1();
  if ( v5 )
  {
    sub_10025148(ebp0);
    if ( *(_DWORD *)(v7 + 132) )
    {
      v12 = &off_1005D290;
      v13 = v7;
      v14 = (int *)&v12;
      v16 = 2;
      sub_100203A0((int)&v12, a5);
      sub_10001A60((int)&v12);
    }
  }
  return 1;
}
// 1005D290: using guessed type void *off_1005D290;
// 10067210: using guessed type int __security_cookie;

//----- (10020610) --------------------------------------------------------
void *__thiscall sub_10020610(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_10020640(this);
  if ( a2 & 1 )
    sub_1002404A(v2);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10020640) --------------------------------------------------------
int __thiscall sub_10020640(int this)
{
  int v1; // ecx@1
  int ebp0; // ebp@0
  int v4; // esi@1
  int v12; // ecx@4
  int v20; // edi@8

  v4 = this;
  *(_DWORD *)this = &off_1005D2B4;
  v1 = *(_DWORD *)(this + 136);
  _EBX = -1;
  if ( v1 != 2 )
  {
    _EAX = v1 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v1 + 4))();
  }
  v12 = *(_DWORD *)(v4 + 144);
  if ( v12 )
  {
    _EAX = v12 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v12 + 4))();
    *(_DWORD *)(v4 + 144) = 0;
  }
  nullsub_2(v4 + 100);
  v20 = *(_DWORD *)(v4 + 96);
  if ( v20 )
  {
    _EAX = v20 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v20)(v20);
      _EAX = v20 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v20 + 4))(v20);
    }
  }
  sub_10024C22(ebp0);
  return sub_10024C22(ebp0);
}
// 10024CC5: using guessed type int __thiscall nullsub_2(_DWORD);
// 1005D2B4: using guessed type int (__stdcall *off_1005D2B4)(char);

//----- (10020930) --------------------------------------------------------
int __userpurge sub_10020930<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, unsigned int a4)
{
  int v4; // ecx@1

  v4 = 0;
  if ( a4 )
  {
    if ( a4 > 0x7FFFFFFF || (v4 = sub_10027EB3(a1, 0, a2, a3, 2 * a4), !v4) )
    {
      sub_10021BC5();
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_10020960);
    }
  }
  return v4;
}

//----- (10020960) --------------------------------------------------------
int (__cdecl *__usercall sub_10020960<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<ebx>, int a5<edi>, int a6<esi>, int a7, int a8))(int, int)
{
  unsigned int v8; // edi@1
  int v9; // esi@1
  unsigned int v10; // ecx@3
  int v11; // eax@6
  int v12; // ecx@6
  int (__cdecl *result)(int, int); // eax@9
  int v14; // edx@9
  const void *v15; // edx@12
  int v16; // eax@18
  int v17; // [sp-10h] [bp-28h]@1
  int v18; // [sp-Ch] [bp-24h]@1
  int v19; // [sp-8h] [bp-20h]@1
  int v20; // [sp-4h] [bp-1Ch]@1
  int v21; // [sp+0h] [bp-18h]@1
  int v22; // [sp+4h] [bp-14h]@6
  void **v23; // [sp+8h] [bp-10h]@1
  int v24; // [sp+Ch] [bp-Ch]@1
  int (__cdecl *v25)(int, int); // [sp+10h] [bp-8h]@1
  int v26; // [sp+14h] [bp-4h]@1
  void *v27; // [sp+1Ch] [bp+4h]@9

  v26 = -1;
  v25 = sub_10053090;
  v24 = a1;
  v20 = a4;
  v19 = a6;
  v18 = a5;
  v17 = a1;
  v23 = (void **)&v17;
  v9 = a3;
  v21 = a3;
  v8 = a7 | 7;
  if ( (a7 | 7u) <= 0x7FFFFFFE )
  {
    a4 = *(_DWORD *)(a3 + 20);
    v10 = *(_DWORD *)(a3 + 20) >> 1;
    a2 = v8 / 3;
    if ( v10 > v8 / 3 )
    {
      v8 = v10 + a4;
      if ( a4 > 2147483646 - v10 )
        v8 = 2147483646;
    }
  }
  else
  {
    v8 = a7;
  }
  v11 = v8 + 1;
  v12 = 0;
  v26 = 0;
  v22 = 0;
  if ( v8 == -1 || (unsigned int)v11 <= 0x7FFFFFFF && (v12 = sub_10027EB3(a2, 0, a4, v8, 2 * v11), v22 = v12, v12) )
  {
    if ( a8 )
    {
      if ( *(_DWORD *)(v9 + 20) < 8u )
        v15 = (const void *)v9;
      else
        v15 = *(const void **)v9;
      if ( a8 )
        sub_1002C950((void *)v12, v15, 2 * a8);
    }
    if ( *(_DWORD *)(v9 + 20) >= 8u )
      sub_1002404A(*(LPVOID *)v9);
    v16 = v22;
    *(_DWORD *)v9 = v22;
    *(_DWORD *)(v9 + 20) = v8;
    *(_DWORD *)(v9 + 16) = a8;
    if ( v8 >= 8 )
      v9 = v16;
    result = 0;
    *(_WORD *)(v9 + 2 * a8) = 0;
  }
  else
  {
    sub_10021BC5();
    v22 = a7;
    v23 = &v27;
    LOBYTE(v26) = 2;
    sub_10020930(v14, a4, v8, a7 + 1);
    result = loc_10020A1E;
  }
  return result;
}
// 10020A1E: using guessed type int __cdecl loc_10020A1E(int, int);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10053090: using guessed type int __cdecl sub_10053090(int, int);

//----- (10020BC0) --------------------------------------------------------
int __thiscall sub_10020BC0(void *this, int a2, DWORD a3)
{
  int v3; // eax@1
  int v4; // esi@1
  char v5; // cf@3
  int v7; // [sp+10h] [bp-2Ch]@3
  void *v8; // [sp+14h] [bp-28h]@1
  unsigned int v9; // [sp+28h] [bp-14h]@3
  int v10; // [sp+38h] [bp-4h]@1

  v4 = (int)this;
  v3 = sub_10020C60((int)&v8, a3);
  v10 = 0;
  if ( *(_DWORD *)(v3 + 20) >= 0x10u )
    v3 = *(_DWORD *)v3;
  v7 = v3;
  sub_10023687(v4, &v7);
  v5 = v9 < 0x10;
  *(_DWORD *)v4 = &off_100542F0;
  if ( !v5 )
    sub_1002404A(v8);
  *(_DWORD *)(v4 + 12) = a2;
  *(_DWORD *)v4 = &off_1005D2BC;
  *(_DWORD *)(v4 + 16) = a3;
  return v4;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 100542F0: using guessed type int (__stdcall *off_100542F0)(char);
// 1005D2BC: using guessed type int (__stdcall *off_1005D2BC)(char);

//----- (10020C60) --------------------------------------------------------
int __fastcall sub_10020C60(int a1, DWORD a2)
{
  int v2; // esi@1
  unsigned int v3; // ecx@3
  void *v5; // [sp+Ch] [bp-30h]@2
  int v6; // [sp+1Ch] [bp-20h]@2
  unsigned int v7; // [sp+20h] [bp-1Ch]@2
  int v8; // [sp+24h] [bp-18h]@1
  CHAR hMem[4]; // [sp+28h] [bp-14h]@1
  unsigned int v10; // [sp+2Ch] [bp-10h]@1
  int v11; // [sp+38h] [bp-4h]@1
  int v12; // [sp+3Ch] [bp+0h]@1

  v10 = (unsigned int)&v12 ^ __security_cookie;
  v2 = a1;
  *(_DWORD *)(a1 + 20) = 15;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)a1 = 0;
  v11 = 0;
  v8 = 1;
  FormatMessageA(0x1300u, 0, a2, 0x400u, hMem, 0, 0);
  GetLastError();
  if ( *(_DWORD *)hMem )
  {
    v7 = 15;
    v6 = 0;
    LOBYTE(v5) = 0;
    if ( **(_BYTE **)hMem )
      v3 = strlen(*(const char **)hMem);
    else
      v3 = 0;
    loc_10001BD0(&v5, *(_DWORD *)hMem, v3);
    if ( (void **)v2 != &v5 )
    {
      if ( *(_DWORD *)(v2 + 20) >= 0x10u )
        sub_1002404A(*(LPVOID *)v2);
      *(_DWORD *)(v2 + 20) = 15;
      *(_DWORD *)(v2 + 16) = 0;
      *(_BYTE *)v2 = 0;
      sub_10002780((void *)v2, (int)&v5);
    }
    if ( v7 >= 0x10 )
      sub_1002404A(v5);
    LocalFree(*(HLOCAL *)hMem);
  }
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (10020D80) --------------------------------------------------------
HINTERNET __cdecl sub_10020D80()
{
  HINTERNET result; // eax@1
  int ebp0; // ebp@0
  const WCHAR *v2; // eax@6
  DWORD v3; // [sp-14h] [bp-54h]@7
  const WCHAR *v4; // [sp-10h] [bp-50h]@7
  int i; // [sp-Ch] [bp-4Ch]@4
  const WCHAR *v6; // [sp-Ch] [bp-4Ch]@7
  DWORD v7; // [sp-8h] [bp-48h]@4
  char v8; // [sp+0h] [bp-40h]@5
  unsigned int v9; // [sp+30h] [bp-10h]@1
  int v10; // [sp+3Ch] [bp-4h]@2
  int v11; // [sp+40h] [bp+0h]@1

  v9 = (unsigned int)&v11 ^ __security_cookie;
  result = hInternet;
  if ( !hInternet )
  {
    sub_1002426D(ebp0, (int)&unk_1006A344);
    v10 = 0;
    if ( !hInternet )
    {
      if ( WinHttpGetIEProxyConfigForCurrentUser(&pProxyConfig) )
        goto LABEL_6;
      v7 = GetLastError();
      for ( i = 12; ; i = 11 )
      {
        sub_10020BC0(&v8, i, v7);
        sub_1002D02B((int)&v8, (int)&unk_100617A0);
LABEL_6:
        v2 = (const WCHAR *)&pszAgentW;
        if ( pProxyConfig.lpszProxy )
        {
          v6 = pProxyConfig.lpszProxyBypass;
          v4 = pProxyConfig.lpszProxy;
          v3 = 3;
        }
        else
        {
          v6 = 0;
          v4 = 0;
          v3 = 0;
        }
        if ( (unsigned int)dword_10068EA4 >= 8 )
          v2 = pszAgentW;
        hInternet = WinHttpOpen(v2, v3, v4, v6, 0x10000000u);
        if ( hInternet )
          break;
        v7 = GetLastError();
      }
    }
    v10 = -1;
    sub_100242C1();
    result = hInternet;
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 10068EA4: using guessed type int dword_10068EA4;

//----- (10020E80) --------------------------------------------------------
void *__userpurge sub_10020E80<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  void *v4; // esi@1

  v4 = (void *)a1;
  sub_10020EB0(a1, a2, a3);
  if ( a4 & 1 )
    sub_1002404A(v4);
  return v4;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10020EB0) --------------------------------------------------------
int __usercall sub_10020EB0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // eax@1
  int ebp0; // ebp@0
  int v5; // esi@1
  void *v6; // eax@3

  v5 = a1;
  *(_DWORD *)a1 = &off_1005D328;
  v3 = *(_DWORD *)(a1 + 12);
  if ( v3 == 1 || v3 == 2 )
  {
    v6 = *(void **)(a1 + 4);
    *(_DWORD *)(a1 + 12) = 3;
    if ( v6 )
    {
      WinHttpCloseHandle(v6);
      sub_10025249(ebp0, a2, a3, 1000);
      *(_DWORD *)(v5 + 4) = 0;
    }
    if ( *(_DWORD *)(v5 + 8) )
    {
      WinHttpCloseHandle(*(HINTERNET *)(v5 + 8));
      *(_DWORD *)(v5 + 8) = 0;
    }
    *(_DWORD *)(v5 + 12) = 4;
  }
  if ( *(_DWORD *)(v5 + 76) >= 0x10u )
    sub_1002404A(*(LPVOID *)(v5 + 56));
  *(_DWORD *)(v5 + 76) = 15;
  *(_DWORD *)(v5 + 72) = 0;
  *(_BYTE *)(v5 + 56) = 0;
  return sub_10024C22(ebp0);
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005D328: using guessed type int (__stdcall *off_1005D328)(char);

//----- (10020F80) --------------------------------------------------------
int __thiscall sub_10020F80(int this, int a2)
{
  int v2; // esi@1
  char v3; // cf@3
  const WCHAR *v4; // eax@4
  DWORD v5; // eax@7
  int v7; // eax@12
  unsigned int v8; // [sp-4h] [bp-94h]@1
  void *v9; // [sp+Ch] [bp-84h]@10
  int v10; // [sp+1Ch] [bp-74h]@10
  unsigned int v11; // [sp+20h] [bp-70h]@10
  void *v12; // [sp+24h] [bp-6Ch]@8
  char v13; // [sp+28h] [bp-68h]@7
  int (__stdcall **v14)(char); // [sp+30h] [bp-60h]@2
  int v15; // [sp+34h] [bp-5Ch]@8
  unsigned int v16; // [sp+38h] [bp-58h]@8
  struct $BC2FB811D417144E831EE3AEA4A279C8 UrlComponents; // [sp+3Ch] [bp-54h]@3
  int v18; // [sp+78h] [bp-18h]@2
  unsigned int v19; // [sp+7Ch] [bp-14h]@1
  int v20; // [sp+8Ch] [bp-4h]@8
  int v21; // [sp+90h] [bp+0h]@1

  v19 = (unsigned int)&v21 ^ __security_cookie;
  v8 = (unsigned int)&v21 ^ __security_cookie;
  v2 = this;
  if ( *(_DWORD *)(this + 12) )
  {
    v18 = (int)"Request is not ready";
    sub_10023687((int)&v14, &v18);
    v14 = &off_100542C0;
    sub_1002D02B((int)&v14, (int)&unk_100615F0);
  }
  sub_10020D80();
  *(_DWORD *)(v2 + 12) = 1;
  UrlComponents.dwStructSize = 60;
  sub_10030CF0(&UrlComponents.lpszScheme, 0, 56);
  v3 = *(_DWORD *)(a2 + 20) < 8u;
  UrlComponents.dwSchemeLength = -1;
  UrlComponents.dwHostNameLength = -1;
  UrlComponents.dwUrlPathLength = -1;
  if ( v3 )
    v4 = (const WCHAR *)a2;
  else
    v4 = *(const WCHAR **)a2;
  if ( !WinHttpCrackUrl(v4, *(_DWORD *)(a2 + 16), 0, &UrlComponents) )
  {
    v5 = GetLastError();
    sub_10020BC0(&v13, 8, v5);
    sub_1002D02B((int)&v13, (int)&unk_100617A0);
  }
  v16 = 7;
  v15 = 0;
  LOWORD(v12) = 0;
  loc_10020AC0(&v12, UrlComponents.lpszHostName, UrlComponents.dwHostNameLength, v8);
  v20 = 0;
  (*(void (__thiscall **)(int, void **))(*(_DWORD *)v2 + 4))(v2, &v12);
  v20 = -1;
  if ( v16 >= 8 )
    sub_1002404A(v12);
  v11 = 7;
  v10 = 0;
  LOWORD(v9) = 0;
  loc_10020AC0(&v9, UrlComponents.lpszUrlPath, UrlComponents.dwUrlPathLength);
  v20 = 1;
  (*(void (__thiscall **)(int, void **))(*(_DWORD *)v2 + 8))(v2, &v9);
  v20 = -1;
  if ( v11 >= 8 )
    sub_1002404A(v9);
  LOWORD(v9) = 0;
  v7 = *(_DWORD *)v2;
  v11 = 7;
  v10 = 0;
  (*(void (__thiscall **)(int))(v7 + 16))(v2);
  return (*(int (__cdecl **)(int))(*(_DWORD *)v2 + 12))(a2);
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 100542C0: using guessed type int (__stdcall *off_100542C0)(char);
// 10067210: using guessed type int __security_cookie;

//----- (10021140) --------------------------------------------------------
int __thiscall sub_10021140(void *this, int a2)
{
  return loc_100214A0(a2, this);
}

//----- (10021150) --------------------------------------------------------
void __thiscall sub_10021150(int this, LPCWSTR pwszObjectName)
{
  int v2; // edi@1
  const WCHAR *v3; // esi@1
  const WCHAR *v4; // eax@5
  DWORD v5; // eax@7
  DWORD v6; // eax@10
  char v7; // [sp+Ch] [bp-48h]@1
  int (__stdcall **v8)(char); // [sp+10h] [bp-44h]@2
  int v9; // [sp+24h] [bp-30h]@2
  LPCWSTR pwszVerb; // [sp+28h] [bp-2Ch]@3
  int v11; // [sp+38h] [bp-1Ch]@3
  unsigned int v12; // [sp+3Ch] [bp-18h]@3
  unsigned int v13; // [sp+40h] [bp-14h]@1
  int v14; // [sp+50h] [bp-4h]@3

  v13 = (unsigned int)&v7 ^ __security_cookie;
  v2 = this;
  v3 = pwszObjectName;
  if ( !*(_DWORD *)(this + 8) )
  {
    v9 = (int)"Invalid connection";
    sub_10023687((int)&v8, &v9);
    v8 = &off_100542C0;
    sub_1002D02B((int)&v8, (int)&unk_100615F0);
  }
  v12 = 7;
  v11 = 0;
  LOWORD(pwszVerb) = 0;
  v14 = 0;
  loc_10020AC0(&pwszVerb, L"GET", 3);
  if ( *((_DWORD *)pwszObjectName + 5) >= 8u )
    v3 = *(const WCHAR **)pwszObjectName;
  v4 = (const WCHAR *)&pwszVerb;
  if ( v12 >= 8 )
    v4 = pwszVerb;
  v5 = (DWORD)WinHttpOpenRequest(*(HINTERNET *)(v2 + 8), v4, v3, 0, 0, 0, 0);
  *(_DWORD *)(v2 + 4) = v5;
  if ( !v5 )
  {
    v5 = GetLastError();
    sub_10020BC0(&v8, 9, v5);
    sub_1002D02B((int)&v8, (int)&unk_100617A0);
  }
  if ( WinHttpSetStatusCallback((HINTERNET)v5, (WINHTTP_STATUS_CALLBACK)fnInternetCallback, 0xFFFFFFFFu, 0) == (WINHTTP_STATUS_CALLBACK)-1 )
  {
    v6 = GetLastError();
    sub_10020BC0(&v8, 10, v6);
    sub_1002D02B((int)&v8, (int)&unk_100617A0);
  }
  if ( v12 >= 8 )
    sub_1002404A((LPVOID)pwszVerb);
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 100542C0: using guessed type int (__stdcall *off_100542C0)(char);
// 1005D320: using guessed type wchar_t aGet[4];
// 10067210: using guessed type int __security_cookie;

//----- (100212B0) --------------------------------------------------------
void __thiscall sub_100212B0(DWORD_PTR this)
{
  sub_10021540(this, 0, 0, 0, 0);
}

//----- (100213F0) --------------------------------------------------------
int __stdcall sub_100213F0(char a1, int a2)
{
  return sub_100234E2((int)&a1);
}

//----- (10021540) --------------------------------------------------------
void __thiscall sub_10021540(DWORD_PTR dwContext, LPVOID lpOptional, DWORD dwOptionalLength, DWORD dwTotalLength, LPCWSTR lpszHeaders)
{
  int v5; // eax@2
  DWORD v6; // eax@2
  int v7; // esi@2
  int v8; // [sp+Ch] [bp-40h]@4
  int (__stdcall **v9)(char); // [sp+10h] [bp-3Ch]@4
  int v10; // [sp+1Ch] [bp-30h]@6
  int v11; // [sp+20h] [bp-2Ch]@6
  void *v12; // [sp+24h] [bp-28h]@2
  int v13; // [sp+34h] [bp-18h]@6
  unsigned int v14; // [sp+38h] [bp-14h]@4
  int v15; // [sp+48h] [bp-4h]@2

  if ( !WinHttpSendRequest(
          *(HINTERNET *)(dwContext + 4),
          lpszHeaders,
          0xFFFFFFFFu,
          lpOptional,
          dwOptionalLength,
          dwTotalLength,
          dwContext) )
  {
    v6 = GetLastError();
    v7 = v6;
    v5 = sub_10020C60((int)&v12, v6);
    v15 = 0;
    if ( *(_DWORD *)(v5 + 20) >= 0x10u )
      v5 = *(_DWORD *)v5;
    v8 = v5;
    sub_10023687((int)&v9, &v8);
    v15 = -1;
    v9 = &off_100542F0;
    if ( v14 >= 0x10 )
      sub_1002404A(v12);
    v14 = 15;
    v13 = 0;
    LOBYTE(v12) = 0;
    v9 = &off_1005D2BC;
    v10 = 5;
    v11 = v7;
    sub_1002D02B((int)&v9, (int)&unk_100617A0);
  }
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 100542F0: using guessed type int (__stdcall *off_100542F0)(char);
// 1005D2BC: using guessed type int (__stdcall *off_1005D2BC)(char);

//----- (10021630) --------------------------------------------------------
void __userpurge fnInternetCallback(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, unsigned int a6, int a7, int a8)
{
  int ebp0; // ebp@0
  void *v9; // esi@9
  char *v10; // ecx@10
  DWORD v11; // eax@10
  int v12; // eax@10
  void *v13; // ST00_4@11
  DWORD v14; // eax@12
  int v15; // eax@12
  DWORD v16; // eax@14
  int v17; // eax@14
  DWORD v18; // eax@18
  int v19; // eax@18
  DWORD v20; // eax@22
  int v21; // eax@22
  int v22; // eax@23
  char v23; // [sp+10h] [bp-94h]@1
  char v24; // [sp+14h] [bp-90h]@14
  char v25; // [sp+28h] [bp-7Ch]@10
  char v26; // [sp+3Ch] [bp-68h]@23
  char v27; // [sp+50h] [bp-54h]@18
  char v28; // [sp+64h] [bp-40h]@12
  char v29; // [sp+78h] [bp-2Ch]@22
  LPVOID dwBufferLength; // [sp+8Ch] [bp-18h]@9
  unsigned int v31; // [sp+90h] [bp-14h]@1
  int v32; // [sp+A0h] [bp-4h]@10

  v31 = (unsigned int)&v23 ^ __security_cookie;
  if ( a5 )
  {
    if ( a6 > 0x80000 )
    {
      if ( a6 == 2097152 )
      {
        v22 = sub_10020BC0(&v26, *(_DWORD *)a7, *(_DWORD *)(a7 + 4));
        v32 = 5;
        sub_100218F0(a5, v22);
        v10 = &v26;
        goto LABEL_24;
      }
      if ( a6 == 4194304 && !WinHttpReceiveResponse(*(HINTERNET *)(a5 + 4), 0) )
      {
        v20 = GetLastError();
        v21 = sub_10020BC0(&v29, 1, v20);
        v32 = 0;
        sub_100218F0(a5, v21);
        v10 = &v29;
        goto LABEL_24;
      }
    }
    else
    {
      if ( a6 == 524288 )
      {
        if ( !a8 )
        {
LABEL_8:
          (*(void (__thiscall **)(int, int))(*(_DWORD *)a5 + 20))(a5, a5 + 56);
          *(_DWORD *)(a5 + 12) = 2;
          return;
        }
        loc_10009590(a5 + 56, a7, a8);
        sub_1002401B((LPVOID)a7);
        if ( !WinHttpQueryDataAvailable(*(HINTERNET *)(a5 + 4), 0) )
        {
          v18 = GetLastError();
          v19 = sub_10020BC0(&v27, 2, v18);
          v32 = 4;
          sub_100218F0(a5, v19);
          v10 = &v27;
          goto LABEL_24;
        }
      }
      else
      {
        if ( a6 == 2048 )
        {
          sub_10025148(ebp0);
          return;
        }
        if ( a6 == 131072 )
        {
          v13 = *(void **)(a5 + 4);
          dwBufferLength = (LPVOID)4;
          if ( !WinHttpQueryHeaders(v13, 0x20000013u, 0, (LPVOID)(a5 + 80), (LPDWORD)&dwBufferLength, 0) )
          {
            v14 = GetLastError();
            v15 = sub_10020BC0(&v28, 6, v14);
            v32 = 1;
            sub_100218F0(a5, v15);
            v32 = -1;
            sub_100236FB((int)&v28, a3);
          }
          if ( !WinHttpQueryDataAvailable(*(HINTERNET *)(a5 + 4), 0) )
          {
            v16 = GetLastError();
            v17 = sub_10020BC0(&v24, 2, v16);
            v32 = 2;
            sub_100218F0(a5, v17);
            v10 = &v24;
            goto LABEL_24;
          }
        }
        else
        {
          if ( a6 != 262144 )
            return;
          a3 = *(_DWORD *)a7;
          if ( !*(_DWORD *)a7 )
            goto LABEL_8;
          dwBufferLength = (LPVOID)sub_10021CF0(a1, a2, a3, a5, a3 + 1);
          sub_10030CF0(dwBufferLength, 0, a3 + 1);
          v9 = dwBufferLength;
          if ( !WinHttpReadData(*(HINTERNET *)(a5 + 4), dwBufferLength, a3, 0) )
          {
            sub_1002401B(v9);
            v11 = GetLastError();
            v12 = sub_10020BC0(&v25, 3, v11);
            v32 = 3;
            sub_100218F0(a5, v12);
            v10 = &v25;
LABEL_24:
            sub_100236FB((int)v10, a3);
            return;
          }
        }
      }
    }
  }
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 10067210: using guessed type int __security_cookie;

//----- (100218F0) --------------------------------------------------------
int __thiscall sub_100218F0(int this, int a2)
{
  int v3; // ebx@1
  char v4; // [sp-18h] [bp-48h]@1
  int v5; // [sp-Ch] [bp-3Ch]@1
  int v6; // [sp-8h] [bp-38h]@1
  unsigned int v7; // [sp-4h] [bp-34h]@1
  int v8; // [sp+14h] [bp-1Ch]@1
  int v9; // [sp+18h] [bp-18h]@1
  unsigned int v10; // [sp+1Ch] [bp-14h]@1
  int v11; // [sp+2Ch] [bp-4h]@1
  int v12; // [sp+30h] [bp+0h]@1

  v10 = (unsigned int)&v12 ^ __security_cookie;
  v7 = (unsigned int)&v12 ^ __security_cookie;
  v3 = this;
  v8 = 0;
  v9 = 0;
  sub_100236C7((int)&v4, this, a2);
  *(_DWORD *)&v4 = &off_1005D2BC;
  v5 = *(_DWORD *)(a2 + 12);
  v6 = *(_DWORD *)(a2 + 16);
  sub_100219B0(&v8, v3, (unsigned int)&off_1005D2BC);
  v11 = 0;
  sub_10023441((int)&v5, (int)&v8);
  (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 24))(v3);
  v11 = -1;
  return sub_100234E2((int)&v8);
}
// 10023441: using guessed type int __cdecl sub_10023441(int, int);
// 1005D2BC: using guessed type int (__stdcall *off_1005D2BC)(char);
// 10067210: using guessed type int __security_cookie;

//----- (100219B0) --------------------------------------------------------
void *__usercall sub_100219B0<eax>(void *a1<ecx>, int a2<ebx>, char a3)
{
  void *v4; // esi@1

  v4 = a1;
  sub_1001FDA0(a1, (int)&unk_100617A0);
  sub_100236FB((int)&a3, a2);
  return v4;
}

//----- (10021A10) --------------------------------------------------------
int __userpurge sub_10021A10<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_100542A4;
  return v4;
}
// 100542A4: using guessed type int (__stdcall *off_100542A4)(char);

//----- (10021A2B) --------------------------------------------------------
int __userpurge sub_10021A2B<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_100542FC;
  return v4;
}
// 100542FC: using guessed type int (__stdcall *off_100542FC)(char);

//----- (10021A46) --------------------------------------------------------
int __userpurge sub_10021A46<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_100542D8;
  return v4;
}
// 100542D8: using guessed type int (__stdcall *off_100542D8)(char);

//----- (10021A61) --------------------------------------------------------
int __userpurge sub_10021A61<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_100542E4;
  return v4;
}
// 100542E4: using guessed type int (__stdcall *off_100542E4)(char);

//----- (10021A7C) --------------------------------------------------------
int __userpurge sub_10021A7C<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // edi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_1005438C;
  *(_DWORD *)(v4 + 12) = *(_DWORD *)(a3 + 12);
  return v4;
}
// 1005438C: using guessed type int (__stdcall *off_1005438C)(char);

//----- (10021AA0) --------------------------------------------------------
int __thiscall sub_10021AA0(void *this, int a2)
{
  int v3; // esi@1
  int v4; // edi@1

  v3 = a2;
  v4 = (int)this;
  a2 = sub_10021B05(a2);
  sub_10023687(v4, &a2);
  *(_DWORD *)(v4 + 12) = v3;
  *(_DWORD *)v4 = &off_1005438C;
  return v4;
}
// 1005438C: using guessed type int (__stdcall *off_1005438C)(char);

//----- (10021AD0) --------------------------------------------------------
void __usercall sub_10021AD0(int a1<ecx>, int a2<ebx>)
{
  *(_DWORD *)a1 = &off_100542A4;
  sub_100236FB(a1, a2);
}
// 100542A4: using guessed type int (__stdcall *off_100542A4)(char);

//----- (10021AE0) --------------------------------------------------------
void *__userpurge sub_10021AE0<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  *(_DWORD *)a1 = &off_100542A4;
  sub_100236FB(a1, a2);
  if ( a3 & 1 )
    sub_1002404A(v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 100542A4: using guessed type int (__stdcall *off_100542A4)(char);

//----- (10021B05) --------------------------------------------------------
int __cdecl sub_10021B05(int a1)
{
  int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = (int)"regex_error(error_collate): The expression contained an invalid collating element name.";
      break;
    case 1:
      result = (int)"regex_error(error_ctype): The expression contained an invalid character class name.";
      break;
    case 2:
      result = (int)"regex_error(error_escape): The expression contained an invalid escaped character, or a trailing escape.";
      break;
    case 3:
      result = (int)"regex_error(error_backref): The expression contained an invalid back reference.";
      break;
    case 4:
      result = (int)"regex_error(error_brack): The expression contained mismatched [ and ].";
      break;
    case 5:
      result = (int)"regex_error(error_paren): The expression contained mismatched ( and ).";
      break;
    case 6:
      result = (int)"regex_error(error_brace): The expression contained mismatched { and }.";
      break;
    case 7:
      result = (int)"regex_error(error_badbrace): The expression contained an invalid range in a { expression }.";
      break;
    case 8:
      result = (int)"regex_error(error_range): The expression contained an invalid character range, such as [b-a] in most encodings.";
      break;
    case 9:
      result = (int)"regex_error(error_space): There was insufficient memory to convert the expression into a finite state machine.";
      break;
    case 10:
      result = (int)"regex_error(error_badrepeat): One of *?+{ was not preceded by a valid regular expression.";
      break;
    case 11:
      result = (int)"regex_error(error_complexity): The complexity of an attempted match against a regular expression exceeded a pre-set level.";
      break;
    case 12:
      result = (int)"regex_error(error_stack): There was insufficient memory to determine whether the regular expression could match the specified character sequence.";
      break;
    case 13:
      result = (int)"regex_error(error_parse)";
      break;
    case 14:
      result = (int)"regex_error(error_syntax)";
      break;
    default:
      result = (int)"regex_error";
      break;
  }
  return result;
}

//----- (10021BC5) --------------------------------------------------------
void __cdecl sub_10021BC5()
{
  int (__stdcall **v0)(char); // [sp+0h] [bp-10h]@1
  int v1; // [sp+Ch] [bp-4h]@1

  v1 = (int)"bad allocation";
  sub_100236AC((int)&v0, (int)&v1, 1);
  v0 = &off_100542A4;
  sub_1002D02B((int)&v0, (int)&unk_1005F828);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_10021BF6);
}
// 100542A4: using guessed type int (__stdcall *off_100542A4)(char);

//----- (10021BF6) --------------------------------------------------------
void __cdecl sub_10021BF6()
{
  int (__stdcall **v0)(char); // [sp+0h] [bp-Ch]@1

  sub_100236EA((int)&v0);
  v0 = &off_100542FC;
  sub_1002D02B((int)&v0, (int)&unk_1005F8D8);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_10021C1A);
}
// 100542FC: using guessed type int (__stdcall *off_100542FC)(char);

//----- (10021C1A) --------------------------------------------------------
void __cdecl sub_10021C1A(int a1)
{
  int (__stdcall **v1)(char); // [sp+0h] [bp-Ch]@1

  sub_10023687((int)&v1, &a1);
  v1 = &off_100542D8;
  sub_1002D02B((int)&v1, (int)&unk_1005F860);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_10021C48);
}
// 100542D8: using guessed type int (__stdcall *off_100542D8)(char);

//----- (10021C48) --------------------------------------------------------
void __cdecl sub_10021C48(int a1)
{
  int (__stdcall **v1)(char); // [sp+0h] [bp-Ch]@1

  sub_10023687((int)&v1, &a1);
  v1 = &off_100542E4;
  sub_1002D02B((int)&v1, (int)&unk_1005F89C);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_10021C76);
}
// 10021C76: using guessed type int __cdecl sub_10021C76(int);
// 100542E4: using guessed type int (__stdcall *off_100542E4)(char);

//----- (10021C76) --------------------------------------------------------
int __cdecl sub_10021C76(int a1)
{
  char v2; // [sp+0h] [bp-10h]@1

  sub_10021AA0(&v2, a1);
  sub_1002D02B((int)&v2, (int)&unk_1005F910);
  __asm { int     3               ; Trap to Debugger }
  return (int)"bad function call";
}
// 10021C76: using guessed type int __cdecl sub_10021C76(int);

//----- (10021C9C) --------------------------------------------------------
int __cdecl sub_10021C9C(int a1)
{
  _UNKNOWN *v1; // eax@1
  int result; // eax@4

  v1 = &unk_10054B28;
  if ( off_10054B2C )
  {
    while ( *(_DWORD *)v1 != a1 )
    {
      v1 = (char *)v1 + 8;
      if ( !*((_DWORD *)v1 + 1) )
        goto LABEL_4;
    }
    result = *((_DWORD *)v1 + 1);
  }
  else
  {
LABEL_4:
    result = 0;
  }
  return result;
}
// 10054B2C: using guessed type char *off_10054B2C;

//----- (10021CC6) --------------------------------------------------------
int __cdecl sub_10021CC6(int a1)
{
  _UNKNOWN *v1; // eax@1
  int result; // eax@4

  v1 = &unk_100548D0;
  if ( off_100548D4 )
  {
    while ( *(_DWORD *)v1 != a1 )
    {
      v1 = (char *)v1 + 8;
      if ( !*((_DWORD *)v1 + 1) )
        goto LABEL_4;
    }
    result = *((_DWORD *)v1 + 1);
  }
  else
  {
LABEL_4:
    result = 0;
  }
  return result;
}
// 100548D4: using guessed type char *off_100548D4;

//----- (10021CF0) --------------------------------------------------------
int __usercall sub_10021CF0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int dwBytes)
{
  return sub_10027EB3(a1, a2, a3, a4, dwBytes);
}

//----- (10021CF9) --------------------------------------------------------
int __cdecl sub_10021CF9(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)a1 = sub_10021D13;
  *(_DWORD *)(a1 + 12) = a3;
  return result;
}

//----- (10021D13) --------------------------------------------------------
int __cdecl sub_10021D13(int a1, int a2, int a3)
{
  int result; // eax@1

  *(_DWORD *)(a1 + 32) = a2;
  result = a3;
  *(_DWORD *)(a1 + 36) = a3;
  return result;
}

//----- (10021D27) --------------------------------------------------------
int __thiscall sub_10021D27(int this, int a2)
{
  int v2; // edi@1
  int i; // esi@1
  int result; // eax@2

  v2 = this;
  for ( i = *(_DWORD *)(this + 44); i; i = *(_DWORD *)i )
    result = (*(int (__cdecl **)(int, int, _DWORD))(i + 8))(a2, v2, *(_DWORD *)(i + 4));
  return result;
}

//----- (10021D4C) --------------------------------------------------------
char __cdecl sub_10021D4C(int a1)
{
  int v1; // eax@1
  char result; // al@2
  void *v3; // esi@3

  v1 = *(_DWORD *)(a1 + 8);
  if ( !v1 || (--byte_10068EF0[v1], result = byte_10068EF0[v1], result <= 0) )
  {
    result = (unsigned int)sub_10021D89(a1);
    v3 = *(void **)(a1 + 48);
    if ( v3 )
    {
      sub_1000CBE0(v3);
      result = sub_1002404A(v3);
    }
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10021D89) --------------------------------------------------------
void *__thiscall sub_10021D89(int this)
{
  void *v1; // eax@1
  int v2; // edi@1
  void *v3; // esi@2
  void *result; // eax@3
  void *v5; // esi@4

  v2 = this;
  sub_10021D27(this, 0);
  v1 = *(void **)(v2 + 40);
  if ( v1 )
  {
    do
    {
      v3 = *(void **)v1;
      sub_1002404A(v1);
      v1 = v3;
    }
    while ( v3 );
  }
  result = *(void **)(v2 + 44);
  *(_DWORD *)(v2 + 40) = 0;
  if ( result )
  {
    do
    {
      v5 = *(void **)result;
      sub_1002404A(result);
      result = v5;
    }
    while ( v5 );
  }
  *(_DWORD *)(v2 + 44) = 0;
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10021DD0) --------------------------------------------------------
void *__thiscall sub_10021DD0(void *this, char a2)
{
  void *v3; // esi@1
  int v4; // ecx@1

  v3 = this;
  v4 = (int)((char *)this + 24);
  *((_DWORD *)v3 + 1) = 1;
  *(_DWORD *)v3 = &off_10055644;
  *((_DWORD *)v3 + 2) = 0;
  *((_DWORD *)v3 + 3) = 0;
  *((_DWORD *)v3 + 4) = 0;
  *((_BYTE *)v3 + 20) = a2;
  *(_DWORD *)v4 = 0;
  *(_BYTE *)(v4 + 4) = 0;
  sub_10021E71(v4, 0, (int)&unk_10055650);
  return v3;
}
// 10055644: using guessed type int (__stdcall *off_10055644)(char);

//----- (10021E0D) --------------------------------------------------------
int __thiscall sub_10021E0D(int this)
{
  int result; // eax@1

  result = (*(int (**)(void))(**(_DWORD **)(this + 4) + 8))();
  if ( result )
    result = (**(int (__thiscall ***)(_DWORD, _DWORD))result)(result, 1);
  return result;
}

//----- (10021E46) --------------------------------------------------------
void __usercall sub_10021E46(int a1<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>)
{
  int v4; // esi@1

  v4 = a1;
  *(_DWORD *)a1 = &off_10055644;
  sub_10021F8E(a2, a3, a4);
  if ( *(_DWORD *)(v4 + 24) )
    sub_100282F6(a2, *(LPVOID *)(v4 + 24));
  *(_DWORD *)(v4 + 24) = 0;
  *(_DWORD *)v4 = &off_10055634;
}
// 10055634: using guessed type int (__stdcall *off_10055634)(char);
// 10055644: using guessed type int (__stdcall *off_10055644)(char);

//----- (10021E71) --------------------------------------------------------
int __fastcall sub_10021E71(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // ST0C_4@3
  int i; // esi@5
  int v6; // eax@7
  int v7; // esi@7

  v3 = a1;
  if ( *(_DWORD *)a1 != a3 )
  {
    if ( *(_DWORD *)a1 )
    {
      sub_100282F6(a1, *(LPVOID *)a1);
      a1 = v4;
    }
    *(_DWORD *)v3 = 0;
    if ( a3 )
    {
      for ( i = a3; *(_BYTE *)i; ++i )
        ;
      v7 = i - a3 + 1;
      v6 = sub_10028264(a2, a1, v3, a3, v7);
      *(_DWORD *)v3 = v6;
      if ( v6 )
        sub_1002C950((void *)v6, (const void *)a3, v7);
    }
  }
  return v3;
}

//----- (10021EC5) --------------------------------------------------------
void *__userpurge sub_10021EC5<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  int ebp0; // ebp@0
  void *v5; // esi@1

  v5 = (void *)a1;
  sub_10021E46(a1, a2, ebp0, a3);
  if ( a4 & 1 )
    sub_1002404A(v5);
  return v5;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10021EE4) --------------------------------------------------------
int __usercall sub_10021EE4<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int result; // eax@1

  result = sub_10027EB3(a1, a2, a3, a4, 8);
  if ( result )
  {
    *(_DWORD *)result = dword_10068F10;
    *(_DWORD *)(result + 4) = a5;
  }
  else
  {
    result = 0;
  }
  dword_10068F10 = result;
  return result;
}
// 10068F10: using guessed type int dword_10068F10;

//----- (10021F0C) --------------------------------------------------------
int __cdecl sub_10021F0C()
{
  return dword_10068F0C;
}
// 10068F0C: using guessed type int dword_10068F0C;

//----- (10021F12) --------------------------------------------------------
int __usercall sub_10021F12<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // esi@1
  int v6; // edx@2

  sub_1002D0B8();
  sub_1002210B(v3, a2 - 16, a1, a3, 0);
  v5 = dword_10068F0C;
  *(_DWORD *)(a2 - 4) = 0;
  if ( !v5 )
  {
    v5 = (int)sub_1002204C(v3, v4, a1, a3, 0);
    sub_1002206B(v5);
    *(_DWORD *)(v5 + 16) = 63;
    sub_10021E71(v5 + 24, v6, (int)&unk_10055654);
    dword_10068F08 = v5;
    (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
    dword_10068F28 = dword_10068F08;
  }
  if ( *(_BYTE *)(a2 + 8) )
    (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
  sub_10022167((void *)(a2 - 16));
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10068F08: using guessed type int dword_10068F08;
// 10068F0C: using guessed type int dword_10068F0C;
// 10068F28: using guessed type int dword_10068F28;

//----- (10021F8E) --------------------------------------------------------
int __usercall sub_10021F8E<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // edi@1
  int v4; // esi@1
  int v5; // edx@1
  int v6; // ecx@2
  int v7; // eax@3
  signed int v9; // [sp-8h] [bp-8h]@1
  signed int v10; // [sp-4h] [bp-4h]@1

  v10 = 4;
  sub_1002D0B8();
  sub_1002210B(v5, a2 - 16, a1, a3, 0);
  v3 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 - 4) = 0;
  v4 = *(_DWORD *)(v3 + 12);
  while ( v4 )
  {
    --v4;
    v6 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + 4 * v4);
    if ( v6 )
    {
      v7 = (*(int (__cdecl **)(signed int))(*(_DWORD *)v6 + 8))(v10);
      if ( v7 )
      {
        v9 = 1;
        (**(void (__thiscall ***)(_DWORD))v7)(v7);
      }
    }
  }
  sub_100282F6(a1, *(LPVOID *)(v3 + 8));
  sub_10022167((void *)(a2 - 16));
  return sub_1002D086(v9);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10021FE7) --------------------------------------------------------
int __cdecl sub_10021FE7(int a1, const CHAR *a2)
{
  int v2; // eax@1
  int v3; // edx@1
  int v4; // edx@3
  int v5; // eax@4

  sub_1002E2BB(0, 0);
  if ( !v2 )
    v2 = (int)&unk_1005C72F;
  sub_10021E71(a1 + 36, v3, v2);
  if ( !a2 || (sub_1002E2BB(0, a2), !v5) )
    v5 = (int)&unk_10055650;
  return sub_10021E71(a1 + 44, v4, v5);
}

//----- (10022032) --------------------------------------------------------
void __cdecl sub_10022032(int a1)
{
  if ( *(_DWORD *)(a1 + 36) )
    sub_1002E2BB(0, *(LPCSTR *)(a1 + 36));
}

//----- (1002204C) --------------------------------------------------------
void *__usercall sub_1002204C<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, char a5)
{
  int v5; // eax@1
  void *result; // eax@2

  v5 = sub_10027EB3(a1, a2, a3, a4, 32);
  if ( v5 )
    result = sub_10021DD0((void *)v5, a5);
  else
    result = 0;
  return result;
}

//----- (1002206B) --------------------------------------------------------
int __cdecl sub_1002206B(int a1)
{
  int result; // eax@3

  if ( !byte_10068F30 )
  {
    byte_10068F30 = 1;
    sub_10022A47(sub_100220B2);
  }
  result = a1;
  dword_10068F0C = a1;
  return result;
}
// 10068F0C: using guessed type int dword_10068F0C;
// 10068F30: using guessed type char byte_10068F30;

//----- (10022093) --------------------------------------------------------
int __cdecl sub_10022093(int a1)
{
  int result; // eax@1

  result = a1;
  if ( *(_DWORD *)a1 )
  {
    result = (*(int (**)(void))(**(_DWORD **)a1 + 8))();
    if ( result )
      result = (**(int (__thiscall ***)(_DWORD, _DWORD))result)(result, 1);
  }
  return result;
}

//----- (100220B2) --------------------------------------------------------
void __usercall sub_100220B2(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // [sp+0h] [bp-4h]@1

  v4 = a2;
  sub_1002210B(a1, (int)&v4, a3, a4, 0);
  sub_10022093((int)&dword_10068F0C);
  dword_10068F0C = 0;
  sub_10022167(&v4);
}
// 10068F0C: using guessed type int dword_10068F0C;

//----- (100220DC) --------------------------------------------------------
void *__thiscall sub_100220DC(void *this)
{
  void *v1; // edi@1
  struct _RTL_CRITICAL_SECTION *v2; // esi@2

  v1 = this;
  if ( !InterlockedIncrement(&Addend) )
  {
    v2 = &CriticalSection;
    do
    {
      sub_10022A83(v2);
      ++v2;
    }
    while ( (signed int)v2 < (signed int)&unk_10068FA0 );
  }
  return v1;
}

//----- (1002210B) --------------------------------------------------------
int __userpurge sub_1002210B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5)
{
  int v5; // esi@1

  v5 = a2;
  *(_DWORD *)a2 = a5;
  if ( a5 )
  {
    if ( a5 < 4 )
      sub_10022A9A(&CriticalSection + a5);
  }
  else
  {
    sub_1002E493(a1, a2, a3, a4, 12);
  }
  return v5;
}

//----- (10022167) --------------------------------------------------------
void __thiscall sub_10022167(void *this)
{
  signed int v1; // eax@1

  v1 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    if ( v1 < 4 )
      sub_10022AA8(&CriticalSection + v1);
  }
  else
  {
    sub_1002E5F7(12);
  }
}

//----- (1002218B) --------------------------------------------------------
int __usercall sub_1002218B<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  LPVOID v3; // eax@1
  int v4; // ecx@1
  int v5; // eax@2
  int v6; // eax@3
  int v7; // eax@4

  *(_DWORD *)a3 = sub_1002E97F(a1, a2);
  v3 = sub_1002EFE1(v4, a1, 0x100u, 2u);
  *(_DWORD *)(a3 + 4) = v3;
  if ( v3 )
  {
    v5 = sub_1002E60C(a1, a2);
    sub_1002C950(*(void **)(a3 + 4), (const void *)v5, 0x200u);
    *(_DWORD *)(a3 + 8) = 1;
  }
  else
  {
    v6 = sub_1002E60C(a1, a2);
    *(_DWORD *)(a3 + 8) = 0;
    *(_DWORD *)(a3 + 4) = v6;
  }
  v7 = *(_DWORD *)(sub_1002E9CB(a1, a2) + 4);
  *(_DWORD *)(a3 + 12) = v7;
  if ( v7 )
    *(_DWORD *)(a3 + 12) = sub_1002E92C(a1, v7);
  return a3;
}

//----- (100221F7) --------------------------------------------------------
int __usercall sub_100221F7<eax>(int a1<ebx>, int a2<edi>, int a3, int MultiByteStr)
{
  int v4; // esi@1
  int v5; // eax@2
  int v6; // edi@2
  int result; // eax@5
  unsigned int v8; // eax@13
  int v9; // edx@13
  int v10; // eax@13
  int v11; // eax@16
  unsigned int v12; // eax@18
  char v13; // zf@20
  UINT v14; // [sp+Ch] [bp-8h]@4
  WCHAR DestStr; // [sp+10h] [bp-4h]@18

  v4 = MultiByteStr;
  if ( MultiByteStr )
  {
    v6 = *(_DWORD *)(MultiByteStr + 12);
    v5 = *(_DWORD *)MultiByteStr;
  }
  else
  {
    v6 = *(_DWORD *)(sub_1002E9CB(a1, a2) + 8);
    v5 = sub_1002E97F(a1, v6);
  }
  v14 = v5;
  if ( !v6 )
  {
    result = a3;
    if ( (unsigned int)(a3 - 65) <= 0x19 )
      result = a3 + 32;
    return result;
  }
  if ( (unsigned int)a3 < 0x100 )
  {
    if ( !v4 )
    {
      if ( !sub_1002E8D4(a3, v6, a3) )
        return a3;
      goto LABEL_13;
    }
    if ( !(*(_BYTE *)(*(_DWORD *)(v4 + 4) + 2 * a3) & 1) )
      return a3;
  }
  if ( !v4 )
  {
LABEL_13:
    v10 = sub_1002E60C(a3, v6);
    v9 = a3 >> 8;
    v8 = *(_WORD *)(v10 + 2 * BYTE1(a3)) & 0x8000;
    goto LABEL_15;
  }
  v9 = a3 >> 8;
  v8 = ((unsigned int)*(_WORD *)(*(_DWORD *)(v4 + 4) + 2 * BYTE1(a3)) >> 15) & 1;
LABEL_15:
  if ( v8 )
  {
    LOBYTE(MultiByteStr) = v9;
    *(_WORD *)((char *)&MultiByteStr + 1) = (unsigned __int8)a3;
    v11 = 2;
  }
  else
  {
    LOWORD(MultiByteStr) = (unsigned __int8)a3;
    v11 = 1;
  }
  v12 = sub_1002EF9A(a3, v6, 0, v6, 0x100u, (LPCSTR)&MultiByteStr, v11, &DestStr, 3, v14, 1);
  if ( !v12 )
    return a3;
  v13 = v12 == 1;
  result = (unsigned __int8)DestStr;
  if ( !v13 )
    result = HIBYTE(DestStr) | ((unsigned __int8)DestStr << 8);
  return result;
}

//----- (100222F4) --------------------------------------------------------
int __usercall sub_100222F4<eax>(int a1<ebx>, int a2<edi>, int a3, int MultiByteStr)
{
  int v4; // esi@1
  int v5; // eax@2
  int v6; // edi@2
  int result; // eax@5
  unsigned int v8; // eax@13
  int v9; // edx@13
  int v10; // eax@13
  int v11; // eax@16
  unsigned int v12; // eax@18
  char v13; // zf@20
  UINT v14; // [sp+Ch] [bp-8h]@4
  WCHAR DestStr; // [sp+10h] [bp-4h]@18

  v4 = MultiByteStr;
  if ( MultiByteStr )
  {
    v6 = *(_DWORD *)(MultiByteStr + 12);
    v5 = *(_DWORD *)MultiByteStr;
  }
  else
  {
    v6 = *(_DWORD *)(sub_1002E9CB(a1, a2) + 8);
    v5 = sub_1002E97F(a1, v6);
  }
  v14 = v5;
  if ( !v6 )
  {
    result = a3;
    if ( (unsigned int)(a3 - 97) <= 0x19 )
      result = a3 - 32;
    return result;
  }
  if ( (unsigned int)a3 < 0x100 )
  {
    if ( !v4 )
    {
      if ( !sub_1002E87E(a3, v6, a3) )
        return a3;
      goto LABEL_13;
    }
    if ( !(*(_BYTE *)(*(_DWORD *)(v4 + 4) + 2 * a3) & 2) )
      return a3;
  }
  if ( !v4 )
  {
LABEL_13:
    v10 = sub_1002E60C(a3, v6);
    v9 = a3 >> 8;
    v8 = *(_WORD *)(v10 + 2 * BYTE1(a3)) & 0x8000;
    goto LABEL_15;
  }
  v9 = a3 >> 8;
  v8 = ((unsigned int)*(_WORD *)(*(_DWORD *)(v4 + 4) + 2 * BYTE1(a3)) >> 15) & 1;
LABEL_15:
  if ( v8 )
  {
    LOBYTE(MultiByteStr) = v9;
    *(_WORD *)((char *)&MultiByteStr + 1) = (unsigned __int8)a3;
    v11 = 2;
  }
  else
  {
    LOWORD(MultiByteStr) = (unsigned __int8)a3;
    v11 = 1;
  }
  v12 = sub_1002EF9A(a3, v6, 0, v6, 0x200u, (LPCSTR)&MultiByteStr, v11, &DestStr, 3, v14, 1);
  if ( !v12 )
    return a3;
  v13 = v12 == 1;
  result = (unsigned __int8)DestStr;
  if ( !v13 )
    result = HIBYTE(DestStr) | ((unsigned __int8)DestStr << 8);
  return result;
}

//----- (100223F1) --------------------------------------------------------
int __cdecl sub_100223F1(int a1)
{
  signed int v1; // ebx@1
  bool v2; // ecx@1

  v1 = 0;
  *(_DWORD *)a1 = 0;
  memset((void *)(a1 + 4), 0, 0x28u);
  *(_DWORD *)a1 = sub_1002E97F(0, a1 + 44);
  *(_DWORD *)(a1 + 4) = sub_1002E9F3(0, a1);
  v2 = *(_DWORD *)(sub_1002E9CB(0, a1) + 8) == 0;
  *(_DWORD *)(a1 + 8) = v2;
  if ( !v2 )
  {
    do
    {
      if ( sub_1002F1EE(v1, a1, v1) )
        *(_BYTE *)((v1 >> 3) + a1 + 12) |= 1 << (v1 & 7);
      ++v1;
    }
    while ( v1 < 256 );
  }
  return a1;
}

//----- (1002245A) --------------------------------------------------------
int __usercall sub_1002245A<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // esi@1

  v3 = sub_1002E9A5(a1, a2);
  v2 = sub_1002E9CB(a1, a2);
  if ( *(_DWORD *)(v2 + 4) )
    sub_1002E92C(a1, *(_DWORD *)(v2 + 4));
  return v3;
}

//----- (1002247B) --------------------------------------------------------
int __usercall sub_1002247B<eax>(int a1<ebx>, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // edi@1
  int v7; // esi@1
  int v8; // eax@2
  int v9; // ebx@2
  unsigned int v10; // eax@5
  int result; // eax@7
  int v12; // eax@10

  v7 = a3 - a2;
  v6 = a5 - a4;
  if ( a6 )
  {
    v9 = *(_DWORD *)(a6 + 4);
    v8 = *(_DWORD *)a6;
  }
  else
  {
    v9 = *(_DWORD *)(sub_1002E9CB(a1, v6) + 4);
    v8 = sub_1002E9A5(v9, v6);
  }
  if ( v9 )
  {
    v12 = sub_10030C07(v9, v6, 0, v9, 0x1000u, a2, v7, a4, v6, v8);
    if ( v12 )
    {
      result = v12 - 2;
    }
    else
    {
      *(_DWORD *)sub_1002F144(v9) = 22;
      result = 2147483647;
    }
  }
  else
  {
    v10 = a3 - a2;
    if ( v7 >= v6 )
      v10 = a5 - a4;
    result = sub_1002F204(a2, a4, v10);
    if ( !result )
    {
      if ( v7 != v6 )
      {
        LOBYTE(result) = v7 >= v6;
        result = 2 * result - 1;
      }
    }
  }
  return result;
}

//----- (10022510) --------------------------------------------------------
signed int __cdecl sub_10022510(LPWSTR lpDestStr, int a2, LPCSTR lpMultiByteStr, UINT CodePage, int a5)
{
  signed int v5; // ebx@1
  int v6; // edi@1
  unsigned int v7; // esi@1
  int v8; // eax@2
  int v9; // ecx@2
  int v10; // eax@9
  int v12; // [sp+18h] [bp+Ch]@2
  UINT v13; // [sp+20h] [bp+14h]@4

  v7 = CodePage - (_DWORD)lpMultiByteStr;
  v6 = a2 - (_DWORD)lpDestStr;
  v5 = -1;
  if ( a5 )
  {
    v9 = *(_DWORD *)(a5 + 4);
    v8 = *(_DWORD *)a5;
    v12 = *(_DWORD *)(a5 + 4);
  }
  else
  {
    v12 = *(_DWORD *)(sub_1002E9CB(-1, v6) + 4);
    v8 = sub_1002E9A5(-1, v6);
    v9 = v12;
  }
  v13 = v8;
  if ( v9 || v8 )
  {
    v10 = sub_1002EF9A(-1, v6, 0, v9, 0x400u, lpMultiByteStr, v7, 0, 0, v8, 1);
    if ( v10 )
    {
      v5 = v10;
      if ( v10 <= v6 )
        sub_1002EF9A(v10, v6, 0, v12, 0x400u, lpMultiByteStr, v7, lpDestStr, v6, v13, 1);
    }
  }
  else
  {
    if ( v7 <= v6 )
      sub_1002C950(lpDestStr, lpMultiByteStr, v7);
    v5 = v7;
  }
  return v5;
}

//----- (100225B6) --------------------------------------------------------
DWORD __cdecl sub_100225B6()
{
  struct _FILETIME SystemTimeAsFileTime; // [sp+0h] [bp-8h]@1

  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  return SystemTimeAsFileTime.dwLowDateTime + 717324288;
}

//----- (100225DD) --------------------------------------------------------
int __fastcall sub_100225DD(int a1, int a2, unsigned int a3)
{
  int v3; // edi@1
  int v4; // eax@3
  int v6; // eax@10
  signed int v7; // [sp-4h] [bp-10h]@2

  v3 = a1;
  *(_DWORD *)a1 = off_1005565C;
  if ( a3 <= 8 )
  {
    v7 = 32;
LABEL_8:
    v4 = v7;
    goto LABEL_10;
  }
  v4 = 16;
  if ( a3 > 0x10 )
  {
    if ( a3 > 0x20 )
    {
      if ( a3 > 0x40 )
      {
        v4 = 2 - (a3 > 0x80);
        goto LABEL_10;
      }
      v7 = 4;
    }
    else
    {
      v7 = 8;
    }
    goto LABEL_8;
  }
LABEL_10:
  *(_DWORD *)(a1 + 8) = v4;
  v6 = sub_10022AB6(a2, 320, a1, 1u, 320);
  *(_DWORD *)(v3 + 4) = v6;
  sub_10030CF0((void *)v6, 0, 320);
  *(_DWORD *)(v3 + 12) = a3;
  return v3;
}
// 1005565C: using guessed type int (*off_1005565C[3])();

//----- (1002264A) --------------------------------------------------------
int __thiscall sub_1002264A(int this)
{
  return sub_1002404A(*(LPVOID *)(this + 32));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10022654) --------------------------------------------------------
void __usercall sub_10022654(int a1<ecx>, int a2<ebx>)
{
  int v2; // ST00_4@1

  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = off_1005565C;
  sub_10022B1B(a2, v2);
}
// 1005565C: using guessed type int (*off_1005565C[3])();

//----- (10022664) --------------------------------------------------------
int __thiscall sub_10022664(int this)
{
  int v1; // edi@1
  int v2; // esi@1
  int v3; // ecx@2
  int result; // eax@5
  char v5; // [sp+8h] [bp-4h]@2

  v2 = this;
  v1 = *(_DWORD *)(this + 8);
  if ( v1 )
  {
    sub_1002C326(&v5, *(_DWORD *)(this + 4) + 16);
    v3 = *(_DWORD *)v1;
    **(_DWORD **)(v2 + 4) = *(_DWORD *)v1;
    if ( !v3 )
      *(_DWORD *)(*(_DWORD *)(v2 + 4) + 8) = 0;
    sub_1002C36C(&v5);
  }
  result = *(_DWORD *)(v2 + 4);
  *(_DWORD *)(result + 4) = *(_DWORD *)v2;
  if ( v1 )
    result = (*(int (__stdcall **)(int))(**(_DWORD **)(v2 + 12) + 20))(v1);
  return result;
}

//----- (100226C2) --------------------------------------------------------
int __thiscall sub_100226C2(int this, char a2)
{
  void *v2; // esi@1
  int result; // eax@4

  v2 = (void *)this;
  if ( a2 & 2 )
  {
    sub_10023E14(this, 36, *(_DWORD *)(this - 4), sub_1002264A);
    if ( a2 & 1 )
      sub_1002401B((char *)v2 - 4);
    result = (int)((char *)v2 - 4);
  }
  else
  {
    sub_1002404A(*(LPVOID *)(this + 32));
    if ( a2 & 1 )
      sub_1002404A(v2);
    result = (int)v2;
  }
  return result;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10022710) --------------------------------------------------------
void *__userpurge sub_10022710<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_10022654(a1, a2);
  if ( a3 & 1 )
    sub_1002404A(v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1002272F) --------------------------------------------------------
char __thiscall sub_1002272F(int this)
{
  int v1; // edx@1
  char result; // al@2

  v1 = *(_DWORD *)(*(_DWORD *)(this + 4) + 64);
  if ( v1 == *(_DWORD *)(*(_DWORD *)(this + 4) + 64) )
    result = v1 == **(_DWORD **)(this + 4);
  else
    result = 0;
  return result;
}

//----- (10022752) --------------------------------------------------------
int __thiscall sub_10022752(void *this)
{
  void *v1; // edi@1
  unsigned int v2; // esi@1
  int result; // eax@2
  int v4; // ecx@2

  v1 = this;
  v2 = 0;
  do
  {
    result = *((_DWORD *)v1 + 1);
    v4 = *(_DWORD *)(result + v2 + 136);
    if ( v4 )
    {
      if ( v4 != dword_10068FA4 )
        (*(void (__thiscall **)(void *, int))(*(_DWORD *)v1 + 20))(v1, v4);
      result = *((_DWORD *)v1 + 1);
      *(_DWORD *)(result + v2 + 136) = 0;
    }
    v2 += 20;
  }
  while ( v2 < 0xA0 );
  return result;
}
// 10068FA4: using guessed type int dword_10068FA4;

//----- (10022792) --------------------------------------------------------
char __thiscall sub_10022792(int this, int a2)
{
  int ebp0; // ebp@0
  int v3; // edi@1
  int v5; // eax@2

  v3 = this;
  _ESI = *(_DWORD *)(this + 4);
  while ( 2 )
  {
    v5 = *(_DWORD *)_ESI;
    do
    {
      if ( v5 == *(_DWORD *)(_ESI + 64) )
        return 0;
      _ECX = v5 + 1;
      __asm { lock cmpxchg [esi], ecx }
    }
    while ( v5 != v5 );
    if ( !(unsigned __int8)sub_10022813(ebp0, a2, v5, v3) )
      continue;
    break;
  }
  return 1;
}

//----- (100227DB) --------------------------------------------------------
int __thiscall sub_100227DB(int this, int a2)
{
  _EAX = *(_DWORD *)(this + 4) + 64;
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  return sub_100228C8(a2, _EDX, this, sub_100226BD);
}
// 100226BD: using guessed type int sub_100226BD();
// 100228C8: using guessed type _DWORD __stdcall sub_100228C8(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10022813) --------------------------------------------------------
int __userpurge sub_10022813<eax>(int a1<ebp>, int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ecx@1
  int v7; // esi@7
  int v8; // eax@7
  int v9; // edx@7
  int v10; // ecx@7
  int v11; // eax@7
  int v12; // ecx@7
  int v14; // [sp-10h] [bp-10h]@9

  sub_1002D0B8();
  v4 = v6;
  v5 = *(_DWORD *)(a1 + 12) & 0xFFFFFFF8;
  *(_DWORD *)(a1 - 40) = 0;
  *(_DWORD *)(a1 - 36) = sub_1002C66E;
  while ( *(_DWORD *)(v4 + 4) != v5 )
    sub_1001FF20(a1 - 48);
  *(_DWORD *)(a1 - 56) = 0;
  *(_DWORD *)(a1 - 52) = sub_1002C66E;
  while ( *(_DWORD *)(v4 + 12) == v5 )
    sub_1001FF20(a1 - 64);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)v4;
  v8 = *(_DWORD *)(*(_DWORD *)(a1 + 16) + 8) - 1;
  v9 = v8 & ((unsigned int)v5 >> 3);
  v10 = (v8 & ((unsigned int)v5 >> 3)) == v8 ? *(_DWORD *)(a1 + 12) : 0;
  v11 = v5 + 8;
  v7 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 - 16) = v9;
  *(_DWORD *)(a1 - 32) = v11;
  *(_DWORD *)(a1 - 28) = v4;
  *(_DWORD *)(a1 - 24) = v10;
  *(_DWORD *)(a1 - 20) = v7;
  v12 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 - 4) = 0;
  if ( (1 << v9) & *(_DWORD *)(v12 + 4) )
  {
    v14 = *(_DWORD *)(a1 + 8);
    (*(void (__thiscall **)(int))(*(_DWORD *)v7 + 8))(v7);
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_10022664(a1 - 32);
  return sub_1002D086(v14);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (100228C8) --------------------------------------------------------
#error "100229FE: call analysis failed (funcsize=86)"

//----- (10022A06) --------------------------------------------------------
int __thiscall sub_10022A06(int this)
{
  *(_DWORD *)this = &off_100556A8;
  _EAX = 2;
  _EDX = &unk_10068FA8;
  __asm { lock xadd [edx], eax }
  *(_DWORD *)(this + 4) = _EAX;
  return this;
}
// 100556A8: using guessed type int (*off_100556A8)();

//----- (10022A47) --------------------------------------------------------
PVOID __cdecl sub_10022A47(PVOID Ptr)
{
  PVOID result; // eax@1

  JUMPOUT(dword_10066258--, 0, loc_10030D9F);
  result = EncodePointer(Ptr);
  dword_10068FD0[dword_10066258] = (int)result;
  return result;
}
// 10066258: using guessed type int dword_10066258;
// 10068FD0: using guessed type int dword_10068FD0[];

//----- (10022A75) --------------------------------------------------------
void __cdecl sub_10022A75(LPCRITICAL_SECTION lpCriticalSection)
{
  DeleteCriticalSection(lpCriticalSection);
}

//----- (10022A83) --------------------------------------------------------
int __cdecl sub_10022A83(LPCRITICAL_SECTION lpCriticalSection)
{
  return sub_1003106C(lpCriticalSection, 0xFA0u, 0);
}

//----- (10022A9A) --------------------------------------------------------
void __cdecl sub_10022A9A(LPCRITICAL_SECTION lpCriticalSection)
{
  EnterCriticalSection(lpCriticalSection);
}

//----- (10022AA8) --------------------------------------------------------
void __cdecl sub_10022AA8(LPCRITICAL_SECTION lpCriticalSection)
{
  LeaveCriticalSection(lpCriticalSection);
}

//----- (10022AB6) --------------------------------------------------------
int __usercall sub_10022AB6<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, unsigned int a4, int a5)
{
  int v5; // eax@1
  int v6; // esi@2
  int v7; // eax@3
  int v8; // ecx@3
  int result; // eax@4
  int (__stdcall **v10)(char); // [sp+0h] [bp-Ch]@5

  v5 = a5 * a4;
  if ( a5 * a4 < a4
    || (v6 = dword_1006636C, dword_1006636C + v5 < (unsigned int)v5)
    || (v7 = sub_10028264(a1, dword_1006636C + v5, a2, a3, dword_1006636C + v5), v8 = v7, !v7) )
  {
    a4 = (unsigned int)"bad allocation";
    sub_100236AC((int)&v10, (int)&a4, 1);
    v10 = &off_100542A4;
    sub_1002D02B((int)&v10, (int)&unk_1005F828);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10022B1B);
  }
  result = -v6 & (v6 + v7);
  *(_DWORD *)(result - 4) = v8;
  return result;
}
// 100542A4: using guessed type int (__stdcall *off_100542A4)(char);
// 1006636C: using guessed type int dword_1006636C;

//----- (10022B1B) --------------------------------------------------------
void __usercall sub_10022B1B(int a1<ebx>, int a2)
{
  if ( a2 )
    sub_100282F6(a1, *(LPVOID *)(a2 - 4));
}

//----- (10022B30) --------------------------------------------------------
int __usercall sub_10022B30<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, int ecx0<ecx>, char a4)
{
  if ( ecx0 == __security_cookie )
    __asm { rep retn }
  return sub_10027FE6(a1, a2, a3, a4);
}
// 10067210: using guessed type int __security_cookie;

//----- (10022B3F) --------------------------------------------------------
int __userpurge sub_10022B3F<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4)
{
  int v4; // eax@1
  int v5; // esi@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // ecx@2

  sub_1002D121();
  v5 = v6;
  *(_DWORD *)(a2 - 4) = 0;
  v4 = sub_10027EB3(v7, v6, a1, a3, 16);
  if ( v4 )
  {
    *(_DWORD *)(v4 + 4) = 1;
    *(_DWORD *)(v4 + 8) = 1;
    v8 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)v4 = off_10055928;
    *(_DWORD *)(v4 + 12) = v8;
  }
  else
  {
    v8 = *(_DWORD *)(a2 + 8);
    v4 = 0;
  }
  sub_100232EF(v5, v8, v4);
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10055928: using guessed type int (*off_10055928[2])();

//----- (10022B8A) --------------------------------------------------------
void __usercall sub_10022B8A(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  void *v3; // esi@1

  v3 = *(void **)(a2 + 8);
  if ( v3 )
  {
    sub_10022DD9(*(_DWORD *)(a2 + 8), a1, a3);
    sub_1002404A(v3);
  }
  sub_1002D02B(0, 0);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_10022BA9);
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10022BA9) --------------------------------------------------------
int __userpurge sub_10022BA9<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4, int a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // esi@1
  int v8; // ecx@1
  unsigned int v9; // eax@1
  int v10; // edx@1
  int v11; // eax@2

  sub_1002D121();
  v7 = v8;
  *(_DWORD *)(a2 - 4) = 0;
  v9 = sub_100234FF(v10, a2 - 17, a1, 1u);
  v6 = *(_DWORD *)(a2 + 8);
  v5 = v9;
  if ( v9 )
  {
    v11 = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(v5 + 4) = 1;
    *(_DWORD *)(v5 + 8) = 1;
    *(_DWORD *)v5 = &off_1005593C;
    *(_DWORD *)(v5 + 12) = v6;
    *(_DWORD *)(v5 + 16) = v11;
  }
  sub_100232EF(v7, v6, v5);
  return sub_1002D086(8);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 1005593C: using guessed type int (*off_1005593C)();

//----- (10022BF6) --------------------------------------------------------
void __usercall sub_10022BF6(int a1<ebp>)
{
  (*(void (__cdecl **)(_DWORD))(a1 + 12))(*(_DWORD *)(a1 + 8));
  sub_1002D02B(0, 0);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_10022C07);
}

//----- (10022C07) --------------------------------------------------------
int __userpurge sub_10022C07<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  int result; // eax@1
  void *v5; // ecx@1
  int ebp0; // ebp@0
  int v7; // esi@1

  v7 = a1;
  sub_10022B3F(a2, ebp0, a3, a4);
  v5 = *(void **)(v7 + 4);
  *(_DWORD *)(v7 + 4) = 0;
  result = 0;
  *(_DWORD *)v7 = 0;
  if ( v5 )
    result = sub_10001490(v5);
  return result;
}

//----- (10022C3E) --------------------------------------------------------
int __userpurge sub_10022C3E<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5)
{
  int result; // eax@1
  void *v6; // ecx@1
  int ebp0; // ebp@0
  int v8; // esi@1

  v8 = a1;
  sub_10022BA9(a2, ebp0, a3, a4, a1);
  v6 = *(void **)(v8 + 4);
  *(_DWORD *)(v8 + 4) = 0;
  result = 0;
  *(_DWORD *)v8 = 0;
  if ( v6 )
    result = sub_10001490(v6);
  return result;
}

//----- (10022C7A) --------------------------------------------------------
int __thiscall sub_10022C7A(int this, int a2, char a3)
{
  int v3; // edx@1
  int v4; // ebx@1
  int ebp0; // ebp@0
  unsigned int v6; // edi@1
  int v7; // esi@1
  int v8; // eax@1
  int v9; // edx@2
  unsigned int v10; // eax@6
  int v11; // eax@10
  int v12; // edi@14
  int v13; // eax@16
  int v14; // edx@18
  int v15; // ecx@18
  PVOID v16; // eax@18
  char v17; // zf@18
  int v18; // eax@19
  int v20; // ecx@25
  int v21; // esi@25
  int v22; // [sp-4h] [bp-20h]@18
  int (__stdcall **v23)(char); // [sp+Ch] [bp-10h]@24
  int v24; // [sp+18h] [bp-4h]@25
  _DWORD *v25; // [sp+1Ch] [bp+0h]@25

  v3 = 0;
  v4 = a2;
  v7 = this;
  *(_BYTE *)(this + 80) = a3;
  *(_DWORD *)this = *(_DWORD *)a2;
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  v8 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(this + 16) = v8;
  v6 = 0;
  if ( v8 )
  {
    v9 = this + 20;
    do
    {
      if ( v6 >= 0xF )
        break;
      *(_DWORD *)v9 = *(_DWORD *)(a2 - this + v9);
      ++v6;
      v9 += 4;
    }
    while ( v6 < *(_DWORD *)(this + 16) );
    v4 = a2;
    v3 = 0;
  }
  v10 = *(_DWORD *)(this + 16);
  if ( v10 < 0xF )
    memset((void *)(this + 20 + 4 * v10), 0, 4 * (15 - v10));
  if ( *(_DWORD *)v4 != -529697949
    || *(_DWORD *)(v4 + 16) != 3
    || (v11 = *(_DWORD *)(v4 + 20), v11 != 429065504) && v11 != 429065505 && v11 != 429065506 && v11 != 26820608 )
    return v7;
  *(_DWORD *)(this + 24) = v3;
  v12 = *(_DWORD *)(v4 + 28);
  if ( *(_DWORD *)(v4 + 24) != v3 )
  {
    if ( v12 )
    {
      v13 = *(_DWORD *)(v12 + 12);
      if ( v13 )
      {
        if ( *(_DWORD *)v13 > v3 )
        {
          v16 = EncodePointer(*(PVOID *)(v4 + 28));
          v17 = a3 == 0;
          *(_DWORD *)(v7 + 28) = v16;
          a2 = *(_DWORD *)(*(_DWORD *)(v12 + 12) + 4);
          v22 = *(_DWORD *)(a2 + 20);
          if ( v17 )
            v18 = sub_1002F02B(v14, v15, v4, v22);
          else
            v18 = sub_10028264(v14, v15, v4, v12, v22);
          v12 = v18;
          if ( v18 )
          {
            sub_10022F59(ebp0, v18, *(_DWORD *)(v4 + 24), *(_DWORD *)(a2 + 20), a2);
            *(_DWORD *)(v7 + 24) = v12;
            return v7;
          }
          *(_DWORD *)&a3 = "bad allocation";
          sub_100236AC((int)&v23, (int)&a3, 1);
          v23 = &off_100542A4;
          sub_1002D02B((int)&v23, (int)&unk_1005F828);
        }
      }
    }
  }
  sub_10031DDC(v4, v12);
  __asm { int     3               ; Trap to Debugger }
  v25 = &v25;
  v24 = v7;
  v21 = v20;
  sub_100236C7(v20, v4, a2);
  *(_DWORD *)v21 = &off_100558C4;
  return v21;
}
// 100542A4: using guessed type int (__stdcall *off_100542A4)(char);
// 100558C4: using guessed type int (__stdcall *off_100558C4)(char);

//----- (10022DD9) --------------------------------------------------------
void __usercall sub_10022DD9(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // esi@1
  int v4; // eax@3
  PVOID v5; // eax@7
  PVOID v6; // edx@7
  int v7; // ecx@8
  int v8; // eax@9
  int v9; // ecx@12
  int v10; // ecx@16

  v3 = a1;
  if ( *(_DWORD *)a1 == -529697949 )
  {
    if ( *(_DWORD *)(a1 + 16) == 3 )
    {
      v4 = *(_DWORD *)(a1 + 20);
      if ( v4 == 429065504 || v4 == 429065505 || v4 == 429065506 || v4 == 26820608 )
      {
        v5 = DecodePointer(*(PVOID *)(a1 + 28));
        v6 = v5;
        if ( v5 )
        {
          v7 = *(_DWORD *)(v3 + 24);
          if ( v7 )
          {
            v8 = *(_DWORD *)(*((_DWORD *)v5 + 3) + 4);
            if ( *((_DWORD *)v6 + 1) )
            {
              sub_1002D2BC(v7, *((_DWORD *)v6 + 1));
            }
            else
            {
              if ( *(_BYTE *)v8 & 8 )
              {
                v9 = *(_DWORD *)v7;
                if ( v9 )
                  (*(void (__stdcall **)(int))(*(_DWORD *)v9 + 8))(v9);
              }
            }
          }
          sub_100282F6(a2, *(LPVOID *)(v3 + 24));
        }
        else
        {
          sub_10031DDC(a2, a3);
          __asm { int     3               ; Trap to Debugger }
          *(_DWORD *)v10 = &off_100558C4;
          sub_100236FB(v10, a2);
        }
      }
    }
  }
}
// 1002D2BC: using guessed type _DWORD __cdecl sub_1002D2BC(_DWORD, _DWORD);
// 100558C4: using guessed type int (__stdcall *off_100558C4)(char);

//----- (10022E63) --------------------------------------------------------
void *__thiscall sub_10022E63(void *this, int a2)
{
  void *v2; // ecx@1
  void *v3; // esi@1
  int v5; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v3 = this;
  sub_10022F07((int)&v5, a2);
  v2 = (void *)*((_DWORD *)v3 + 1);
  *((_DWORD *)v3 + 1) = v6;
  *(_DWORD *)v3 = v5;
  if ( v2 )
    sub_10001490(v2);
  return v3;
}

//----- (10022E9C) --------------------------------------------------------
void *__thiscall sub_10022E9C(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_100558D0;
  if ( a2 & 1 )
    sub_1002404A(this);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 100558D0: using guessed type int (*off_100558D0[2])();

//----- (10022EBC) --------------------------------------------------------
int __thiscall sub_10022EBC(int this, char a2)
{
  void *v2; // ecx@1
  int v3; // esi@1

  v3 = this;
  v2 = *(void **)(this + 4);
  if ( v2 )
    sub_10001490(v2);
  if ( a2 & 1 )
    sub_1002404A((LPVOID)v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10022EE2) --------------------------------------------------------
void *__userpurge sub_10022EE2<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  *(_DWORD *)a1 = &off_100558C4;
  sub_100236FB(a1, a2);
  if ( a3 & 1 )
    sub_1002404A(v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 100558C4: using guessed type int (__stdcall *off_100558C4)(char);

//----- (10022F07) --------------------------------------------------------
int __thiscall sub_10022F07(int this, int a2)
{
  int v2; // esi@1
  int result; // eax@2
  int v4; // edx@2
  int v5; // ecx@2

  v2 = this;
  if ( this != a2 )
  {
    v4 = *(_DWORD *)(this + 4);
    *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a2 + 4) = v4;
    result = *(_DWORD *)a2;
    v5 = *(_DWORD *)this;
    *(_DWORD *)v2 = *(_DWORD *)a2;
    *(_DWORD *)a2 = v5;
  }
  return result;
}

//----- (10022F2F) --------------------------------------------------------
int __cdecl sub_10022F2F(int a1)
{
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  sub_10023311(a1, dword_10069098, dword_1006909C);
  return a1;
}
// 10069098: using guessed type int dword_10069098;
// 1006909C: using guessed type int dword_1006909C;

//----- (10022F59) --------------------------------------------------------
int __userpurge sub_10022F59<eax>(int a1<ebp>, int a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  int v6; // edi@6
  int v8; // [sp-8h] [bp-8h]@4

  sub_1002D121();
  v5 = *(_DWORD *)(a1 + 20);
  if ( *(_BYTE *)v5 & 1 || !*(_DWORD *)(v5 + 24) )
  {
    v6 = *(_DWORD *)(a1 + 12);
    sub_1002C950(*(void **)(a1 + 8), *(const void **)(a1 + 12), *(_DWORD *)(a1 + 16));
    if ( *(_BYTE *)v5 & 8 )
    {
      if ( *(_DWORD *)v6 )
        (*(void (__cdecl **)(_DWORD, signed int))(**(_DWORD **)v6 + 4))(*(_DWORD *)v6, 4);
    }
  }
  else
  {
    *(_DWORD *)(a1 - 4) = 0;
    if ( *(_BYTE *)v5 & 4 )
    {
      v8 = 1;
      sub_1002DE20(*(_DWORD *)(a1 + 12), v5 + 8);
      sub_1002D2BC(*(_DWORD *)(a1 + 8), *(_DWORD *)(v5 + 24));
    }
    else
    {
      v8 = sub_1002DE20(*(_DWORD *)(a1 + 12), v5 + 8);
      sub_1002D2BC(*(_DWORD *)(a1 + 8), *(_DWORD *)(v5 + 24));
    }
  }
  return sub_1002D086(v8);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 1002D2BC: using guessed type _DWORD __cdecl sub_1002D2BC(_DWORD, _DWORD);

//----- (10022FE3) --------------------------------------------------------
int __usercall sub_10022FE3<eax>(int a1<ebp>)
{
  int v1; // eax@1
  int v2; // edx@1
  int v3; // ecx@1
  char v4; // zf@7
  int v5; // eax@8
  int v6; // eax@9
  int v7; // eax@12
  int v8; // ecx@12
  int v9; // eax@13
  void *v10; // ecx@16
  int v11; // esi@16

  sub_1002D121();
  v1 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 - 20) = 0;
  v3 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 - 4) = 1;
  *(_DWORD *)(a1 - 72) = -529697949;
  *(_DWORD *)(a1 - 68) = 1;
  *(_DWORD *)(a1 - 64) = 0;
  *(_DWORD *)(a1 - 60) = 0;
  *(_DWORD *)(a1 - 56) = 3;
  *(_DWORD *)(a1 - 52) = 429065504;
  *(_DWORD *)(a1 - 48) = v3;
  if ( v1 )
  {
    if ( *(_BYTE *)v1 & 0x10 )
      v1 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v3 - 4) + 24);
  }
  *(_DWORD *)(a1 - 44) = v1;
  if ( v1 )
  {
    if ( *(_BYTE *)v1 & 8 )
      *(_DWORD *)(a1 - 52) = 26820608;
  }
  *(_DWORD *)(a1 - 28) = 0;
  *(_DWORD *)(a1 - 24) = 0;
  v4 = *(_BYTE *)(a1 + 20) == 0;
  *(_BYTE *)(a1 - 4) = 2;
  if ( v4 )
  {
    v7 = sub_10023571(v2, a1 + 23, 1, 1);
    *(_DWORD *)(a1 + 20) = v7;
    *(_DWORD *)(a1 + 12) = v7;
    *(_BYTE *)(a1 - 4) = 4;
    if ( v7 )
      v9 = sub_10022C7A(v7, a1 - 72, 0);
    else
      v9 = 0;
    *(_BYTE *)(a1 - 4) = 2;
    sub_10022C3E(a1 - 28, 1, v9, (int)sub_10023220, v8);
  }
  else
  {
    v5 = sub_10027EB3(v2, v3, 1, 0, 84);
    *(_DWORD *)(a1 + 20) = v5;
    *(_BYTE *)(a1 - 4) = 3;
    if ( v5 )
      v6 = sub_10022C7A(v5, a1 - 72, 1);
    else
      v6 = 0;
    *(_BYTE *)(a1 - 4) = 2;
    sub_10022C07(a1 - 28, 1, 0, v6);
  }
  v11 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)v11 = 0;
  *(_DWORD *)(v11 + 4) = 0;
  sub_10022F07(v11, a1 - 28);
  v10 = *(void **)(a1 - 24);
  *(_DWORD *)(a1 - 20) = 1;
  *(_BYTE *)(a1 - 4) = 1;
  if ( v10 )
    sub_10001490(v10);
  return sub_1002D086(60);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (100230EE) --------------------------------------------------------
int (*__usercall sub_100230EE<eax>(int a1<ebx>, int a2<ebp>))()
{
  int v3; // ST00_4@1

  v3 = *(_DWORD *)(a2 + 8);
  *(_BYTE *)(a2 - 4) = 6;
  sub_10022F2F(v3);
  *(_DWORD *)(a2 - 40) = &off_100542A4;
  sub_100236FB(a2 - 40, a1);
  return loc_10023110;
}
// 10023110: using guessed type int loc_10023110();
// 100542A4: using guessed type int (__stdcall *off_100542A4)(char);

//----- (10023115) --------------------------------------------------------
void __usercall sub_10023115(int a1<ebx>, int a2<edi>)
{
  sub_10031DDC(a1, a2);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_1002311B);
}

//----- (1002311B) --------------------------------------------------------
int __usercall sub_1002311B<eax>(int a1<ebp>)
{
  int v1; // edx@4
  int v2; // ecx@4
  int v3; // esi@5
  int v4; // eax@6
  int v5; // eax@6
  void *v6; // ecx@8
  int v7; // esi@8
  int v8; // eax@11

  sub_1002D121();
  *(_DWORD *)(a1 - 20) = 0;
  *(_DWORD *)(a1 - 4) = 1;
  if ( !*(_DWORD *)(sub_10031BD7(1, 0) + 136)
    || *(_DWORD *)(sub_10031BD7(1, 0) + 144)
    || **(_DWORD **)(sub_10031BD7(1, 0) + 136) == -532459699
    || **(_DWORD **)(sub_10031BD7(1, 0) + 136) == -532462766 )
  {
    v8 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)v8 = 0;
    *(_DWORD *)(v8 + 4) = 0;
  }
  else
  {
    v3 = sub_10027EB3(v1, v2, 1, 0, 84);
    *(_DWORD *)(a1 - 24) = v3;
    *(_BYTE *)(a1 - 4) = 2;
    if ( v3 )
    {
      v5 = sub_10031BD7(1, 0);
      v4 = sub_10022C7A(v3, *(_DWORD *)(v5 + 136), 1);
    }
    else
    {
      v4 = 0;
    }
    *(_BYTE *)(a1 - 4) = 1;
    *(_DWORD *)(a1 - 28) = 0;
    *(_DWORD *)(a1 - 24) = 0;
    sub_10022B3F(1, a1, 0, v4);
    v7 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)v7 = 0;
    *(_DWORD *)(v7 + 4) = 0;
    sub_10022F07(v7, a1 - 28);
    v6 = *(void **)(a1 - 24);
    *(_DWORD *)(a1 - 20) = 1;
    if ( v6 )
      sub_10001490(v6);
  }
  return sub_1002D086(28);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10023220) --------------------------------------------------------
void __usercall sub_10023220(int a1<ebx>, int a2<edi>, LPVOID lpMem)
{
  sub_10022DD9((int)lpMem, a1, a2);
  sub_100282F6(a1, lpMem);
}

//----- (10023231) --------------------------------------------------------
int __thiscall sub_10023231(void *this)
{
  int result; // eax@2

  if ( this )
    result = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)this + 8))(1);
  return result;
}

//----- (1002323D) --------------------------------------------------------
void __usercall sub_1002323D(LPVOID lpMem<ecx>, int a2<ebx>)
{
  void *v2; // esi@1

  v2 = lpMem;
  (*(void (__stdcall **)(_DWORD))(*(_DWORD *)lpMem + 8))(0);
  sub_100282F6(a2, v2);
}

//----- (10023250) --------------------------------------------------------
int __usercall sub_10023250<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  void *v3; // esi@1
  int result; // eax@2

  v3 = *(void **)(a1 + 12);
  if ( v3 )
  {
    sub_10022DD9(*(_DWORD *)(a1 + 12), a2, a3);
    result = sub_1002404A(v3);
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10023268) --------------------------------------------------------
int __thiscall sub_10023268(int this)
{
  return (*(int (__cdecl **)(_DWORD))(this + 16))(*(_DWORD *)(this + 12));
}

//----- (10023270) --------------------------------------------------------
int __thiscall sub_10023270(void *this, void *a2)
{
  return sub_1002405D(a2, (int)&off_100664F8) != 0 ? (int)((char *)this + 16) : 0;
}
// 100664F8: using guessed type int (__stdcall **off_100664F8)(char);

//----- (10023294) --------------------------------------------------------
#error "100232E9: call analysis failed (funcsize=26)"

//----- (100232EF) --------------------------------------------------------
int __thiscall sub_100232EF(int this, int a2, int a3)
{
  void *v3; // ecx@1
  int v4; // esi@1
  int result; // eax@3

  v4 = this;
  v3 = *(void **)(this + 4);
  if ( v3 )
    sub_10001490(v3);
  *(_DWORD *)(v4 + 4) = a3;
  result = a2;
  *(_DWORD *)v4 = a2;
  return result;
}

//----- (10023311) --------------------------------------------------------
int __thiscall sub_10023311(int this, int a2, int a3)
{
  if ( a3 )
  {
    _EAX = a3 + 4;
    _EDX = 1;
    __asm { lock xadd [eax], edx }
  }
  return sub_100232EF(this, a2, a3);
}

//----- (10023334) --------------------------------------------------------
void __usercall sub_10023334(const void *a1<ecx>, int a2<edi>)
{
  int v2; // ebx@1
  int ebp0; // ebp@0
  signed int v4; // eax@2
  DWORD v5; // edx@2
  PVOID v6; // eax@8
  int v7; // ecx@10
  int v8; // esi@12
  char v9; // [sp+0h] [bp-70h]@12
  int (__stdcall **v10)(char); // [sp+Ch] [bp-64h]@16
  int v11; // [sp+18h] [bp-58h]@16
  DWORD dwExceptionCode; // [sp+1Ch] [bp-54h]@2
  DWORD dwExceptionFlags; // [sp+20h] [bp-50h]@15
  DWORD nNumberOfArguments; // [sp+2Ch] [bp-44h]@2
  ULONG_PTR Arguments; // [sp+30h] [bp-40h]@4
  int v16; // [sp+34h] [bp-3Ch]@8
  PVOID Ptr; // [sp+38h] [bp-38h]@8
  unsigned int v18; // [sp+6Ch] [bp-4h]@1
  int v19; // [sp+70h] [bp+0h]@1

  v18 = (unsigned int)&v19 ^ __security_cookie;
  v2 = (int)a1;
  if ( !a1 )
  {
    v11 = (int)"bad exception";
    sub_10023687((int)&v10, &v11);
    v10 = &off_100558C4;
    sub_1002D02B((int)&v10, (int)&unk_1005FC7C);
    goto LABEL_17;
  }
  memcpy(&dwExceptionCode, a1, 0x50u);
  a2 = (int)&v18;
  v5 = dwExceptionCode;
  v4 = nNumberOfArguments;
  if ( dwExceptionCode != -529697949 || nNumberOfArguments != 3 )
    goto LABEL_13;
  if ( Arguments == 429065504 || Arguments == 429065505 || Arguments == 429065506 || Arguments == 26820608 )
  {
    v6 = DecodePointer(Ptr);
    if ( v16 )
    {
      if ( v6 )
      {
        v7 = *((_DWORD *)v6 + 3);
        if ( v7 )
        {
          if ( *(_DWORD *)v7 > 0 )
          {
            Ptr = v6;
            v8 = *(_DWORD *)(*((_DWORD *)v6 + 3) + 4);
            sub_10031E40(*(_DWORD *)(v8 + 20), v7, v9);
            sub_10022F59(ebp0, (int)&v9, v16, *(_DWORD *)(v8 + 20), v8);
            v4 = nNumberOfArguments;
            v5 = dwExceptionCode;
            v16 = (int)&v9;
LABEL_13:
            if ( (unsigned int)v4 > 0xF )
            {
              v4 = 15;
              nNumberOfArguments = 15;
            }
            goto LABEL_15;
          }
        }
      }
    }
LABEL_17:
    sub_10031DDC(v2, a2);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10023441);
  }
LABEL_15:
  RaiseException(v5, dwExceptionFlags, v4, &Arguments);
}
// 10023441: using guessed type int __cdecl sub_10023441(int, int);
// 100558C4: using guessed type int (__stdcall *off_100558C4)(char);
// 10067210: using guessed type int __security_cookie;

//----- (10023441) --------------------------------------------------------
int __cdecl sub_10023441(int a1, int a2)
{
  int result; // eax@2

  if ( a1 )
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    result = sub_10023311(a1, *(_DWORD *)a2, *(_DWORD *)(a2 + 4));
  }
  return result;
}
// 10023441: using guessed type int __cdecl sub_10023441(int, int);

//----- (10023461) --------------------------------------------------------
void *__cdecl sub_10023461(void *a1)
{
  void *result; // eax@1
  int ebp0; // ebp@0
  int v3; // eax@1
  void *v4; // [sp+4h] [bp-4h]@1

  v3 = sub_10022FE3(ebp0);
  result = sub_10022E63(a1, v3);
  if ( v4 )
    result = (void *)sub_10001490(v4);
  return result;
}

//----- (10023491) --------------------------------------------------------
int __cdecl sub_10023491(int a1)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return result;
}

//----- (100234A4) --------------------------------------------------------
int __usercall sub_100234A4<eax>(int a1<ebp>)
{
  void *v1; // ecx@1

  sub_1002D0B8();
  sub_1002311B(a1);
  *(_DWORD *)(a1 - 4) = 0;
  sub_10023441(*(_DWORD *)(a1 + 8), a1 - 20);
  v1 = *(void **)(a1 - 16);
  *(_DWORD *)(a1 - 4) = -1;
  if ( v1 )
    sub_10001490(v1);
  return sub_1002D086(8);
}
// 10023441: using guessed type int __cdecl sub_10023441(int, int);
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (100234E2) --------------------------------------------------------
int __cdecl sub_100234E2(int a1)
{
  return sub_10022EBC(a1, 0);
}

//----- (100234F1) --------------------------------------------------------
void __usercall sub_100234F1(const void *a1<ecx>, int a2<edi>, const void **a3)
{
  sub_10023334(*a3, a2);
}

//----- (100234FF) --------------------------------------------------------
unsigned int __userpurge sub_100234FF<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, unsigned int a4)
{
  unsigned int result; // eax@1
  int v5; // [sp-4h] [bp-10h]@5
  int (__stdcall **v6)(char); // [sp+0h] [bp-Ch]@5

  result = a4;
  if ( a4 )
  {
    if ( a4 > 0xAAAAAAA )
    {
      a4 = (unsigned int)"_DebugMallocator<T>::allocate() - Integer overflow.";
      sub_10023687((int)&v6, (int *)&a4);
      v6 = &off_100542D8;
      v5 = (int)&unk_1005F860;
    }
    else
    {
      result = sub_1002F02B(a1, a2, a3, 24 * a4);
      if ( result )
        return result;
      a4 = (unsigned int)"bad allocation";
      sub_100236AC((int)&v6, (int)&a4, 1);
      v6 = &off_100542A4;
      v5 = (int)&unk_1005F828;
    }
    sub_1002D02B((int)&v6, v5);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10023571);
  }
  return result;
}
// 100542A4: using guessed type int (__stdcall *off_100542A4)(char);
// 100542D8: using guessed type int (__stdcall *off_100542D8)(char);

//----- (10023571) --------------------------------------------------------
int __userpurge sub_10023571<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int result; // eax@1
  int v5; // ecx@7
  int v6; // esi@7
  int v7; // [sp-4h] [bp-10h]@5
  int (__stdcall **v8)(char); // [sp+0h] [bp-Ch]@5

  result = a4;
  if ( a4 )
  {
    if ( (unsigned int)a4 > 0x30C30C3 )
    {
      a4 = (int)"_DebugMallocator<T>::allocate() - Integer overflow.";
      sub_10023687((int)&v8, &a4);
      v8 = &off_100542D8;
      v7 = (int)&unk_1005F860;
    }
    else
    {
      result = sub_1002F02B(a1, a2, a3, 84 * a4);
      if ( result )
        return result;
      a4 = (int)"bad allocation";
      sub_100236AC((int)&v8, (int)&a4, 1);
      v8 = &off_100542A4;
      v7 = (int)&unk_1005F828;
    }
    sub_1002D02B((int)&v8, v7);
    __asm { int     3               ; Trap to Debugger }
    v6 = v5;
    sub_10023650(v5, a3, a4);
    *(_DWORD *)v6 = &off_10055988;
    result = v6;
  }
  return result;
}
// 100542A4: using guessed type int (__stdcall *off_100542A4)(char);
// 100542D8: using guessed type int (__stdcall *off_100542D8)(char);
// 10055988: using guessed type int (__stdcall *off_10055988)(char);

//----- (100235FE) --------------------------------------------------------
int __thiscall sub_100235FE(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002366B(this, a2);
  *(_DWORD *)v3 = &off_10055988;
  return v3;
}
// 10055988: using guessed type int (__stdcall *off_10055988)(char);

//----- (10023619) --------------------------------------------------------
int __userpurge sub_10023619<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_10055970;
  return v4;
}
// 10055970: using guessed type int (__stdcall *off_10055970)(char);

//----- (10023634) --------------------------------------------------------
int __thiscall sub_10023634(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_10023687(this, (int *)&a2);
  *(_DWORD *)v3 = &off_10055970;
  return v3;
}
// 10055970: using guessed type int (__stdcall *off_10055970)(char);

//----- (10023650) --------------------------------------------------------
int __userpurge sub_10023650<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_1005597C;
  return v4;
}
// 1005597C: using guessed type int (__stdcall *off_1005597C)(char);

//----- (1002366B) --------------------------------------------------------
int __thiscall sub_1002366B(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_10023687(this, (int *)&a2);
  *(_DWORD *)v3 = &off_1005597C;
  return v3;
}
// 1005597C: using guessed type int (__stdcall *off_1005597C)(char);

//----- (10023687) --------------------------------------------------------
int __thiscall sub_10023687(int this, int *a2)
{
  int v3; // esi@1

  v3 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = &off_10055950;
  *(_BYTE *)(this + 8) = 0;
  sub_1002375E((void *)this, *a2);
  return v3;
}
// 10055950: using guessed type int (__stdcall *off_10055950)(char);

//----- (100236AC) --------------------------------------------------------
int __thiscall sub_100236AC(int this, int a2, int a3)
{
  *(_DWORD *)this = &off_10055950;
  *(_DWORD *)(this + 4) = *(_DWORD *)a2;
  *(_BYTE *)(this + 8) = 0;
  return this;
}
// 10055950: using guessed type int (__stdcall *off_10055950)(char);

//----- (100236C7) --------------------------------------------------------
int __userpurge sub_100236C7<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = &off_10055950;
  *(_BYTE *)(a1 + 8) = 0;
  sub_10023706(a1, a2, a3);
  return v4;
}
// 10055950: using guessed type int (__stdcall *off_10055950)(char);

//----- (100236EA) --------------------------------------------------------
int __thiscall sub_100236EA(int this)
{
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = &off_10055950;
  *(_BYTE *)(this + 8) = 0;
  return this;
}
// 10055950: using guessed type int (__stdcall *off_10055950)(char);

//----- (100236FB) --------------------------------------------------------
void __usercall sub_100236FB(int a1<ecx>, int a2<ebx>)
{
  *(_DWORD *)a1 = &off_10055950;
  sub_1002379C(a1, a2);
}
// 10055950: using guessed type int (__stdcall *off_10055950)(char);

//----- (10023706) --------------------------------------------------------
int __userpurge sub_10023706<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v3; // esi@1

  v3 = a1;
  if ( a1 != a3 )
  {
    sub_1002379C(a1, a2);
    if ( *(_BYTE *)(a3 + 8) )
      sub_1002375E((void *)v3, *(_DWORD *)(a3 + 4));
    else
      *(_DWORD *)(v3 + 4) = *(_DWORD *)(a3 + 4);
  }
  return v3;
}

//----- (10023739) --------------------------------------------------------
void *__userpurge sub_10023739<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  *(_DWORD *)a1 = &off_10055950;
  sub_1002379C(a1, a2);
  if ( a3 & 1 )
    sub_1002404A(v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10055950: using guessed type int (__stdcall *off_10055950)(char);

//----- (1002375E) --------------------------------------------------------
void __thiscall sub_1002375E(void *this, int a2)
{
  int v2; // ebx@1
  int v3; // eax@2
  int v4; // edi@2
  int v5; // eax@2
  int v6; // edx@2
  int v7; // ecx@2

  v2 = (int)this;
  if ( a2 )
  {
    v5 = sub_1002CFA0(a2);
    v4 = v5 + 1;
    v3 = sub_10028264(v6, v7, v2, v5 + 1, v5 + 1);
    *(_DWORD *)(v2 + 4) = v3;
    if ( v3 )
    {
      sub_10031E6C(v2, v4, v3, v4, a2);
      *(_BYTE *)(v2 + 8) = 1;
    }
  }
}

//----- (1002379C) --------------------------------------------------------
void __usercall sub_1002379C(int a1<ecx>, int a2<ebx>)
{
  int v2; // esi@1

  v2 = a1;
  if ( *(_BYTE *)(a1 + 8) )
    sub_100282F6(a2, *(LPVOID *)(a1 + 4));
  *(_DWORD *)(v2 + 4) = 0;
  *(_BYTE *)(v2 + 8) = 0;
}

//----- (100237B8) --------------------------------------------------------
int __thiscall sub_100237B8(int this)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 4);
  if ( !result )
    result = (int)"Unknown exception";
  return result;
}

//----- (100237D0) --------------------------------------------------------
void *__cdecl sub_100237D0(void *a1, const void *a2, unsigned int a3)
{
  int v38; // eax@29
  int v43; // edx@34
  unsigned int v44; // ecx@34
  void *result; // eax@48
  int v46; // edi@52
  int v47; // esi@52
  int v48; // edx@53
  unsigned int v49; // ecx@53
  int v50; // eax@64
  unsigned int k; // edx@65
  unsigned int v52; // edx@65
  int v53; // ecx@65
  unsigned int l; // edx@68
  int v55; // ecx@70
  char v56; // al@71
  unsigned int m; // ecx@71
  int n; // ecx@73
  unsigned int v59; // eax@76
  int i; // ecx@76
  unsigned int j; // eax@78
  int v62; // [sp-8h] [bp-10h]@76

  _ESI = (int)a2;
  _ECX = a3;
  _EDI = (int)a1;
  if ( a1 > a2 && a1 < (char *)a2 + a3 )
  {
    v47 = (int)(a2 + a3 - 4);
    v46 = (int)(a1 + a3 - 4);
    if ( v46 & 3 )
    {
      if ( a3 >= 4 )
        JUMPOUT(__CS__, *((_DWORD *)loc_10023BA4 + (v46 & 3) + 1));
      switch ( a3 )
      {
        case 0u:
LABEL_60:
          result = a1;
          break;
        case 1u:
LABEL_61:
          *(_BYTE *)(v46 + 3) = *(_BYTE *)(v47 + 3);
          result = a1;
          break;
        case 2u:
LABEL_62:
          *(_BYTE *)(v46 + 3) = *(_BYTE *)(v47 + 3);
          *(_BYTE *)(v46 + 2) = *(_BYTE *)(v47 + 2);
          result = a1;
          break;
        case 3u:
          goto LABEL_63;
      }
    }
    else
    {
      v49 = a3 >> 2;
      v48 = a3 & 3;
      if ( a3 >> 2 < 8 )
      {
        switch ( -v49 )
        {
          case 0:
            switch ( v48 )
            {
              case 0:
                goto LABEL_60;
              case 1:
                goto LABEL_61;
              case 2:
                goto LABEL_62;
              case 3:
                goto LABEL_63;
            }
        }
      }
      else
      {
        memcpy((void *)v46, (const void *)v47, 4 * v49);
        v47 += 4 * v49;
        v46 += 4 * v49;
        switch ( v48 )
        {
          case 0:
            goto LABEL_60;
          case 1:
            goto LABEL_61;
          case 2:
            goto LABEL_62;
          case 3:
            break;
        }
      }
LABEL_63:
      *(_BYTE *)(v46 + 3) = *(_BYTE *)(v47 + 3);
      *(_BYTE *)(v46 + 2) = *(_BYTE *)(v47 + 2);
      *(_BYTE *)(v46 + 1) = *(_BYTE *)(v47 + 1);
      result = a1;
    }
  }
  else
  {
    __asm { bt      dword_100695C4, 1 }
    if ( _CF )
    {
      memcpy(a1, a2, a3);
      return a1;
    }
    if ( a3 < 0x80 )
      goto LABEL_33;
    if ( ((unsigned int)a2 ^ (unsigned int)a1) & 0xF )
      goto LABEL_83;
    __asm { bt      dword_10067250, 1 }
    if ( !_CF )
    {
LABEL_83:
      __asm { bt      dword_100695C4, 0 }
      if ( _CF )
      {
        if ( !((_BYTE)a1 & 3) )
        {
          if ( !((_BYTE)a2 & 3) )
          {
            __asm { bt      edi, 2 }
            if ( _CF )
            {
              _ECX = a3 - 4;
              _ESI = (int)((char *)a2 + 4);
              *(_DWORD *)a1 = *(_DWORD *)a2;
              _EDI = (int)((char *)a1 + 4);
            }
            __asm { bt      edi, 3 }
            if ( _CF )
            {
              __asm { movq    xmm1, qword ptr [esi] }
              _ECX -= 8;
              _ESI += 8;
              __asm { movq    qword ptr [edi], xmm1 }
              _EDI += 8;
            }
            if ( _ESI & 7 )
            {
              __asm { bt      esi, 3 }
              if ( _CF )
              {
                __asm { movdqa  xmm1, xmmword ptr [esi-0Ch] }
                _ESI = _ESI - 12;
                do
                {
                  __asm { movdqa  xmm3, xmmword ptr [esi+10h] }
                  _ECX -= 48;
                  __asm
                  {
                    movdqa  xmm0, xmmword ptr [esi+20h]
                    movdqa  xmm5, xmmword ptr [esi+30h]
                  }
                  _ESI += 48;
                  __asm
                  {
                    movdqa  xmm2, xmm3
                    palignr xmm3, xmm1, 0Ch
                    movdqa  xmmword ptr [edi], xmm3
                    movdqa  xmm4, xmm0
                    palignr xmm0, xmm2, 0Ch
                    movdqa  xmmword ptr [edi+10h], xmm0
                    movdqa  xmm1, xmm5
                    palignr xmm5, xmm4, 0Ch
                    movdqa  xmmword ptr [edi+20h], xmm5
                  }
                  _EDI += 48;
                }
                while ( _ECX >= 48 );
                _ESI = _ESI + 12;
              }
              else
              {
                __asm { movdqa  xmm1, xmmword ptr [esi-4] }
                _ESI = _ESI - 4;
                do
                {
                  __asm { movdqa  xmm3, xmmword ptr [esi+10h] }
                  _ECX -= 48;
                  __asm
                  {
                    movdqa  xmm0, xmmword ptr [esi+20h]
                    movdqa  xmm5, xmmword ptr [esi+30h]
                  }
                  _ESI += 48;
                  __asm
                  {
                    movdqa  xmm2, xmm3
                    palignr xmm3, xmm1, 4
                    movdqa  xmmword ptr [edi], xmm3
                    movdqa  xmm4, xmm0
                    palignr xmm0, xmm2, 4
                    movdqa  xmmword ptr [edi+10h], xmm0
                    movdqa  xmm1, xmm5
                    palignr xmm5, xmm4, 4
                    movdqa  xmmword ptr [edi+20h], xmm5
                  }
                  _EDI += 48;
                }
                while ( _ECX >= 48 );
                _ESI = _ESI + 4;
              }
            }
            else
            {
              __asm { movdqa  xmm1, xmmword ptr [esi-8] }
              _ESI = _ESI - 8;
              do
              {
                __asm { movdqa  xmm3, xmmword ptr [esi+10h] }
                _ECX -= 48;
                __asm
                {
                  movdqa  xmm0, xmmword ptr [esi+20h]
                  movdqa  xmm5, xmmword ptr [esi+30h]
                }
                _ESI += 48;
                __asm
                {
                  movdqa  xmm2, xmm3
                  palignr xmm3, xmm1, 8
                  movdqa  xmmword ptr [edi], xmm3
                  movdqa  xmm4, xmm0
                  palignr xmm0, xmm2, 8
                  movdqa  xmmword ptr [edi+10h], xmm0
                  movdqa  xmm1, xmm5
                  palignr xmm5, xmm4, 8
                  movdqa  xmmword ptr [edi+20h], xmm5
                }
                _EDI += 48;
              }
              while ( _ECX >= 48 );
              _ESI = _ESI + 8;
            }
            while ( _ECX >= 16 )
            {
              __asm { movdqu  xmm1, xmmword ptr [esi] }
              _ECX -= 16;
              _ESI += 16;
              __asm { movdqa  xmmword ptr [edi], xmm1 }
              _EDI += 16;
            }
            __asm { bt      ecx, 2 }
            if ( _CF )
            {
              v38 = *(_DWORD *)_ESI;
              _ECX -= 4;
              _ESI += 4;
              *(_DWORD *)_EDI = v38;
              _EDI += 4;
            }
            __asm { bt      ecx, 3 }
            if ( _CF )
            {
              __asm { movq    xmm1, qword ptr [esi] }
              _ECX -= 8;
              __asm { movq    qword ptr [edi], xmm1 }
            }
            JUMPOUT(__CS__, *((_DWORD *)off_10023B08 + _ECX));
          }
          goto LABEL_34;
        }
        goto LABEL_36;
      }
LABEL_33:
      if ( !((_BYTE)a1 & 3) )
      {
LABEL_34:
        v44 = a3 >> 2;
        v43 = a3 & 3;
        if ( a3 >> 2 < 8 )
        {
          switch ( v44 )
          {
            case 0u:
              goto LABEL_47;
            case 1u:
              goto LABEL_46;
            case 2u:
              goto LABEL_45;
            case 3u:
              goto LABEL_44;
            case 4u:
              goto LABEL_43;
            case 5u:
              goto LABEL_42;
            case 6u:
              break;
            case 7u:
              *((_DWORD *)a1 + v44 - 7) = *((_DWORD *)a2 + v44 - 7);
              break;
          }
          *((_DWORD *)a1 + v44 - 6) = *((_DWORD *)a2 + v44 - 6);
LABEL_42:
          *((_DWORD *)a1 + v44 - 5) = *((_DWORD *)a2 + v44 - 5);
LABEL_43:
          *((_DWORD *)a1 + v44 - 4) = *((_DWORD *)a2 + v44 - 4);
LABEL_44:
          *((_DWORD *)a1 + v44 - 3) = *((_DWORD *)a2 + v44 - 3);
LABEL_45:
          *((_DWORD *)a1 + v44 - 2) = *((_DWORD *)a2 + v44 - 2);
LABEL_46:
          *((_DWORD *)a1 + v44 - 1) = *((_DWORD *)a2 + v44 - 1);
          _ESI = (int)((char *)a2 + 4 * v44);
          _EDI = (int)((char *)a1 + 4 * v44);
LABEL_47:
          switch ( v43 )
          {
            case 0:
              return a1;
            case 1:
LABEL_49:
              *(_BYTE *)_EDI = *(_BYTE *)_ESI;
              return a1;
            case 2:
LABEL_50:
              *(_BYTE *)_EDI = *(_BYTE *)_ESI;
              *(_BYTE *)(_EDI + 1) = *(_BYTE *)(_ESI + 1);
              return a1;
            case 3:
              break;
          }
        }
        else
        {
          memcpy(a1, a2, 4 * v44);
          _ESI = (int)((char *)a2 + 4 * v44);
          _EDI = (int)((char *)a1 + 4 * v44);
          switch ( v43 )
          {
            case 0:
              return a1;
            case 1:
              goto LABEL_49;
            case 2:
              goto LABEL_50;
            case 3:
              break;
          }
        }
        *(_BYTE *)_EDI = *(_BYTE *)_ESI;
        *(_BYTE *)(_EDI + 1) = *(_BYTE *)(_ESI + 1);
        *(_BYTE *)(_EDI + 2) = *(_BYTE *)(_ESI + 2);
        return a1;
      }
LABEL_36:
      if ( a3 >= 4 )
        JUMPOUT(__CS__, *((_DWORD *)loc_10023A18 + ((_BYTE)a1 & 3) + 1));
      JUMPOUT(__CS__, *((_DWORD *)loc_10023B18 + a3 - 4));
    }
    v50 = (_BYTE)a2 & 0xF;
    if ( (_BYTE)a2 & 0xF )
    {
      v62 = a3 - (16 - v50);
      v59 = 16 - v50;
      for ( i = v59 & 3; i; --i )
        *(_BYTE *)_EDI++ = *(_BYTE *)_ESI++;
      for ( j = v59 >> 2; j; --j )
      {
        *(_DWORD *)_EDI = *(_DWORD *)_ESI;
        _ESI += 4;
        _EDI += 4;
      }
      _ECX = v62;
    }
    v52 = _ECX;
    v53 = _ECX & 0x7F;
    for ( k = v52 >> 7; k; --k )
    {
      __asm
      {
        movdqa  xmm0, xmmword ptr [esi]
        movdqa  xmm1, xmmword ptr [esi+10h]
        movdqa  xmm2, xmmword ptr [esi+20h]
        movdqa  xmm3, xmmword ptr [esi+30h]
        movdqa  xmmword ptr [edi], xmm0
        movdqa  xmmword ptr [edi+10h], xmm1
        movdqa  xmmword ptr [edi+20h], xmm2
        movdqa  xmmword ptr [edi+30h], xmm3
        movdqa  xmm4, xmmword ptr [esi+40h]
        movdqa  xmm5, xmmword ptr [esi+50h]
        movdqa  xmm6, xmmword ptr [esi+60h]
        movdqa  xmm7, xmmword ptr [esi+70h]
        movdqa  xmmword ptr [edi+40h], xmm4
        movdqa  xmmword ptr [edi+50h], xmm5
        movdqa  xmmword ptr [edi+60h], xmm6
        movdqa  xmmword ptr [edi+70h], xmm7
      }
      _ESI += 128;
      _EDI += 128;
    }
    if ( v53 )
    {
      for ( l = (unsigned int)v53 >> 4; l; --l )
      {
        __asm
        {
          movdqa  xmm0, xmmword ptr [esi]
          movdqa  xmmword ptr [edi], xmm0
        }
        _ESI += 16;
        _EDI += 16;
      }
      v55 = v53 & 0xF;
      if ( v55 )
      {
        v56 = v55;
        for ( m = (unsigned int)v55 >> 2; m; --m )
        {
          *(_DWORD *)_EDI = *(_DWORD *)_ESI;
          _ESI += 4;
          _EDI += 4;
        }
        for ( n = v56 & 3; n; --n )
          *(_BYTE *)_EDI++ = *(_BYTE *)_ESI++;
      }
    }
    result = a1;
  }
  return result;
}
// 10023A18: using guessed type int __cdecl loc_10023A18(int, int, int);
// 10023B08: using guessed type int __cdecl off_10023B08(int, int, int);
// 10023B18: using guessed type int __cdecl loc_10023B18(int, int, int);
// 10023BA4: using guessed type int __cdecl loc_10023BA4(int, int, int);

//----- (10023E14) --------------------------------------------------------
signed int __stdcall sub_10023E14(int a1, int a2, int a3, void (__thiscall *a4)(_DWORD))
{
  int v4; // edi@1
  int i; // esi@1

  v4 = a3;
  for ( i = a3 * a2 + a1; ; a4(i) )
  {
    --v4;
    if ( v4 < 0 )
      break;
    i -= a2;
  }
  return 1;
}

//----- (10023E83) --------------------------------------------------------
int __stdcall sub_10023E83(int a1, int a2, int a3, int (*a4)(void))
{
  char v4; // sf@1
  int result; // eax@2

  while ( 1 )
  {
    v4 = a3-- - 1 < 0;
    if ( v4 )
      break;
    a1 -= a2;
    result = a4();
  }
  return result;
}

//----- (10023EE1) --------------------------------------------------------
signed int __usercall sub_10023EE1<eax>(int a1<ecx>, int a2<ebx>)
{
  void *v2; // esi@1
  signed int result; // eax@2

  v2 = sub_1002EFE1(a1, a2, 0x20u, 4u);
  Ptr = EncodePointer(v2);
  dword_1006B3A8 = Ptr;
  if ( v2 )
  {
    *(_DWORD *)v2 = 0;
    result = 0;
  }
  else
  {
    result = 24;
  }
  return result;
}

//----- (10023F10) --------------------------------------------------------
void __usercall sub_10023F10(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, PVOID Ptr)
{
  sub_10032493(a1, a2, a3, a4);
  sub_10023F50(Ptr);
  sub_1003249C();
}

//----- (10023F50) --------------------------------------------------------
PVOID __cdecl sub_10023F50(PVOID Ptr)
{
  int v1; // ebx@1
  int v2; // edi@2
  int v3; // edx@3
  int v4; // ecx@3
  SIZE_T v5; // esi@3
  signed int v6; // eax@4
  int v7; // eax@6
  int v8; // eax@7
  int v9; // ST04_4@7
  int v11; // [sp-4h] [bp-14h]@3
  PVOID v12; // [sp+Ch] [bp-4h]@1

  v12 = DecodePointer(::Ptr);
  v1 = (int)DecodePointer(dword_1006B3A8);
  if ( v1 >= (unsigned int)v12 )
  {
    v2 = v1 - (_DWORD)v12;
    if ( (unsigned int)(v1 - (_DWORD)v12 + 4) >= 4 )
    {
      v5 = sub_100325D4(v1, v2, v12);
      v4 = v11;
      if ( v5 >= v2 + 4 )
      {
LABEL_11:
        *(_DWORD *)v1 = EncodePointer(Ptr);
        dword_1006B3A8 = EncodePointer((PVOID)(v1 + 4));
        return Ptr;
      }
      v6 = 2048;
      if ( v5 < 0x800 )
        v6 = v5;
      v7 = v5 + v6;
      if ( v7 >= v5 && (v8 = sub_1002F074(v3, v11, (int)v12, v2, v12, v7), v4 = v9, v8)
        || v5 + 16 >= v5 && (v8 = sub_1002F074(v3, v4, (int)v12, v2, v12, v5 + 16)) != 0 )
      {
        v1 = v8 + 4 * (v2 >> 2);
        ::Ptr = EncodePointer((PVOID)v8);
        goto LABEL_11;
      }
    }
  }
  return 0;
}

//----- (10024006) --------------------------------------------------------
int __usercall sub_10024006<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, void *a5)
{
  int v6; // eax@1

  sub_10023F10(a1, a2, a3, a4, a5);
  return (v6 != 0) - 1;
}

//----- (10024020) --------------------------------------------------------
void __usercall sub_10024020(int a1<ebx>)
{
  void (*v1)(void); // eax@1

  v1 = (void (*)(void))DecodePointer(dword_10069C30);
  if ( v1 )
    v1();
  sub_10032662(a1, 25);
  sub_10030D80(0, 1);
  JUMPOUT(loc_10030D9F);
}

//----- (1002404F) --------------------------------------------------------
void __usercall sub_1002404F(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  *(_DWORD *)a2 = &off_10055994;
  sub_10032A01(a1, a2, a3, a4, a2);
}
// 10055994: using guessed type int (__stdcall *off_10055994)(char);

//----- (1002405D) --------------------------------------------------------
bool __thiscall sub_1002405D(void *this, int a2)
{
  return sub_10030DF0(a2 + 9, (int)((char *)this + 9)) == 0;
}

//----- (1002407B) --------------------------------------------------------
void *__userpurge sub_1002407B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, char a5)
{
  void *v5; // esi@1

  v5 = (void *)a2;
  sub_1002404F(a1, a2, a3, a4);
  if ( a5 & 1 )
    sub_1002404A(v5);
  return v5;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1002409A) --------------------------------------------------------
PVOID __thiscall sub_1002409A(PVOID Parameter, DWORD DueTime)
{
  int ebp0; // ebp@0
  HANDLE *v3; // edi@1
  PVOID v4; // esi@1
  int v5; // eax@3
  int *v6; // eax@4
  int v7; // eax@5
  int v9; // [sp-4h] [bp-30h]@4
  int (__stdcall **v10)(char); // [sp+Ch] [bp-20h]@6
  int (__stdcall **v11)(char); // [sp+18h] [bp-14h]@4
  int v12; // [sp+24h] [bp-8h]@6
  int v13; // [sp+28h] [bp-4h]@4

  v4 = Parameter;
  *((_DWORD *)Parameter + 1) = 0;
  v3 = (HANDLE *)((char *)Parameter + 12);
  *((_DWORD *)Parameter + 2) = 1;
  *((_DWORD *)Parameter + 3) = 0;
  *((_DWORD *)Parameter + 4) = 0;
  *((_DWORD *)Parameter + 5) = 0;
  *(_DWORD *)Parameter = sub_1002436D(0, ebp0, (int)((char *)Parameter + 12));
  if ( DueTime != -1 )
  {
    if ( sub_10034C33() < 3 )
    {
      v7 = sub_10024D61();
      if ( !CreateTimerQueueTimer(v3, (HANDLE)v7, (WAITORTIMERCALLBACK)Callback, v4, DueTime, 0, 0x20u) )
      {
        v12 = (int)"bad allocation";
        sub_100236AC((int)&v10, (int)&v12, 1);
        v10 = &off_100542A4;
        v9 = (int)&unk_1005F828;
        v6 = (int *)&v10;
        goto LABEL_8;
      }
    }
    else
    {
      v5 = sub_1002C512(DueTime, (int)sub_100243AD, (int)v4);
      *v3 = (HANDLE)v5;
      if ( !v5 )
      {
        v13 = (int)"bad allocation";
        sub_100236AC((int)&v11, (int)&v13, 1);
        v11 = &off_100542A4;
        v9 = (int)&unk_1005F828;
        v6 = (int *)&v11;
LABEL_8:
        sub_1002D02B((int)v6, v9);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_10024163);
      }
    }
  }
  return v4;
}
// 10034C33: using guessed type int sub_10034C33(void);
// 100542A4: using guessed type int (__stdcall *off_100542A4)(char);

//----- (10024163) --------------------------------------------------------
int __thiscall sub_10024163(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_10024232(this);
  return v2;
}

//----- (1002416F) --------------------------------------------------------
int __thiscall sub_1002416F(int this)
{
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  return this;
}

//----- (1002417F) --------------------------------------------------------
LPCRITICAL_SECTION __thiscall sub_1002417F(LPCRITICAL_SECTION lpCriticalSection)
{
  LPCRITICAL_SECTION v2; // esi@1

  v2 = lpCriticalSection;
  InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
  return v2;
}

//----- (10024193) --------------------------------------------------------
int __thiscall sub_10024193(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_10024232(this);
  *(_DWORD *)(v2 + 32) = 0;
  *(_DWORD *)(v2 + 36) = -1;
  return v2;
}

//----- (100241AA) --------------------------------------------------------
int __userpurge sub_100241AA<eax>(int a1<ebp>, int a2)
{
  int v2; // ecx@1
  int v3; // edi@1
  int *v4; // esi@1
  int v6; // ecx@3

  sub_1002D0B8();
  v4 = (int *)v2;
  *(_DWORD *)(a1 - 16) = v2;
  v3 = v2 + 4;
  *(_DWORD *)v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v2 + 4;
  *(_DWORD *)(a1 - 4) = 0;
  if ( v2 != -4 )
    sub_1002409A((PVOID)(v2 + 4), 0xFFFFFFFFu);
  v6 = *v4;
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002458C(v6, v3, 1);
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (100241EF) --------------------------------------------------------
int __userpurge sub_100241EF<eax>(int a1<ebp>, int a2)
{
  int v2; // ecx@1
  int v3; // edi@1
  void **v4; // esi@1
  void *v6; // ecx@3

  sub_1002D0B8();
  v4 = (void **)v2;
  *(_DWORD *)(a1 - 16) = v2;
  v3 = v2 + 4;
  *(_DWORD *)v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v2 + 4;
  *(_DWORD *)(a1 - 4) = 0;
  if ( v2 != -4 )
    sub_1002409A((PVOID)(v2 + 4), 0xFFFFFFFFu);
  v6 = *v4;
  *(_DWORD *)(a1 - 4) = -1;
  sub_100244F3(v6, v3);
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10024232) --------------------------------------------------------
int __thiscall sub_10024232(int this)
{
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 8) = 2;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  return this;
}

//----- (10024252) --------------------------------------------------------
int __userpurge sub_10024252<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_1005599C;
  return v4;
}
// 1005599C: using guessed type int (__stdcall *off_1005599C)(char);

//----- (1002426D) --------------------------------------------------------
int __userpurge sub_1002426D<eax>(int a1<ebp>, int a2)
{
  int v2; // ecx@1
  int *v3; // edi@1
  int v4; // esi@1
  int v6; // ecx@3

  sub_1002D0B8();
  v3 = (int *)v2;
  v4 = v2 + 4;
  *(_DWORD *)v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v2 + 4;
  *(_DWORD *)(a1 - 16) = v2 + 4;
  *(_DWORD *)(a1 - 4) = 0;
  if ( v2 != -4 )
    sub_1002409A((PVOID)(v2 + 4), 0xFFFFFFFFu);
  v6 = *v3;
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002458C(v6, v4, 1);
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (100242B2) --------------------------------------------------------
void __thiscall sub_100242B2(LPCRITICAL_SECTION lpCriticalSection)
{
  DeleteCriticalSection(lpCriticalSection);
}

//----- (100242BA) --------------------------------------------------------
void __thiscall sub_100242BA(void *this)
{
  int v1; // ecx@1
  char v2; // zf@1
  int v3; // ecx@4
  int v4; // edi@4
  int v7; // ebx@8

  v1 = *(_DWORD *)this;
  v2 = *(_DWORD *)(v1 + 32)-- == 1;
  if ( v2 )
  {
    *(_DWORD *)(v1 + 36) = -1;
    v4 = v1;
    v3 = *(_DWORD *)(v1 + 24);
    *(_DWORD *)v4 = 0;
    _ESI = *(_DWORD *)(v3 + 4);
    *(_DWORD *)(v4 + 24) = _ESI;
    if ( _ESI )
      goto LABEL_14;
    _EDX = v4 + 28;
    __asm { lock cmpxchg [edx], esi }
    if ( v3 != v3 )
    {
      _ESI = sub_100244C0(v3);
      *(_DWORD *)(v4 + 24) = _ESI;
      if ( _ESI )
      {
LABEL_14:
        do
        {
          if ( sub_1002444A((void *)_ESI) )
            break;
          v7 = _ESI;
          _ESI = *(_DWORD *)(_ESI + 4);
          *(_DWORD *)(v4 + 24) = _ESI;
          if ( !_ESI )
          {
            _EDX = 0;
            _ECX = v4 + 28;
            __asm { lock cmpxchg [ecx], edx }
            if ( v7 != v7 )
            {
              _ESI = sub_100244C0(v7);
              *(_DWORD *)(v4 + 24) = _ESI;
            }
          }
          sub_1002438F(v7);
        }
        while ( _ESI );
      }
    }
  }
}

//----- (100242C1) --------------------------------------------------------
void __cdecl sub_100242C1()
{
  JUMPOUT(*(unsigned int *)loc_1002480D);
}
// 1002480D: using guessed type int loc_1002480D();

//----- (100242C8) --------------------------------------------------------
void *__userpurge sub_100242C8<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_100236FB(a1, a2);
  if ( a3 & 1 )
    sub_1002404A(v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (100242E7) --------------------------------------------------------
int __userpurge sub_100242E7<eax>(void *this<ecx>, int ebx0<ebx>, unsigned int a2)
{
  int ebp0; // ebp@0
  unsigned int v4; // edi@1
  void *v5; // esi@1
  unsigned int v6; // edx@3
  char v8; // [sp+8h] [bp-10h]@6
  int v9; // [sp+10h] [bp-8h]@6
  BOOL (__cdecl *v10)(); // [sp+14h] [bp-4h]@6

  v5 = this;
  v4 = sub_10034C38();
  if ( !((*((_DWORD *)v5 + 2) >> 2) & 1) )
  {
    if ( (*((_DWORD *)v5 + 2) >> 1) & 1 )
      v6 = (*((_DWORD *)v5 + 2) >> 3) - (a2 >> 3);
    else
      v6 = 1;
    v4 += 2;
    if ( v6 <= v4 )
    {
      v9 = 0;
      v10 = sub_1002C66E;
      sub_100246A3((int)&v8, dwSpinCount + dwSpinCount * (v6 - 1) / v4);
      while ( *((_DWORD *)v5 + 2) & 1 && sub_100246C7(&v8) )
        ;
    }
  }
  return sub_10028CA4(ebx0, ebp0, v4);
}

//----- (1002436D) --------------------------------------------------------
LPVOID __usercall sub_1002436D<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  LPVOID result; // eax@2
  int v4; // edi@2
  int v5; // esi@2

  if ( !(dword_10066D24 & 0x80000000) || (result = TlsGetValue(dwTlsIndex), !result) )
  {
    v4 = sub_1002A28E(a2, a3);
    v5 = sub_1002982E((void *)v4, a1, 0);
    (*(void (__thiscall **)(_DWORD))(*(_DWORD *)v4 + 20))(v4);
    result = (LPVOID)v5;
  }
  return result;
}
// 10066D24: using guessed type int dword_10066D24;

//----- (1002438F) --------------------------------------------------------
int __thiscall sub_1002438F(int this)
{
  int result; // eax@2

  if ( *(_DWORD *)(this + 12) )
  {
    result = this + 20;
    _EDX = 1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      result = sub_1002404A((LPVOID)this);
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (100243AD) --------------------------------------------------------
int __stdcall sub_100243AD(int a1, int a2, int a3)
{
  _EDX = 2;
  _ECX = a2 + 16;
  __asm { lock cmpxchg [ecx], edx }
  (*(void (**)(void))(**(_DWORD **)a2 + 12))();
  return sub_1002C5AA(a1, a3);
}

//----- (100243E6) --------------------------------------------------------
int __stdcall Callback(int a1, int a2)
{
  void *v3; // ST04_4@1
  int v4; // eax@1

  v3 = *(void **)(a1 + 12);
  v4 = sub_10024D61();
  sub_10032B24((HANDLE)v4, v3, 0);
  _ECX = a1 + 16;
  _EDX = 2;
  __asm { lock cmpxchg [ecx], edx }
  return (*(int (**)(void))(**(_DWORD **)a1 + 12))();
}

//----- (10024425) --------------------------------------------------------
int __usercall sub_10024425<eax>(int this<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>)
{
  int v4; // esi@1
  int result; // eax@2
  int v6; // edx@2

  v4 = this;
  if ( *(_DWORD *)(this + 12) )
  {
    result = this + 16;
    v6 = *(_DWORD *)(this + 16);
    *(_DWORD *)(this + 16) = 1;
    if ( v6 == 2 )
    {
      sub_10028CA4(a2, a3, a4);
      result = sub_1002438F(v4);
    }
  }
  return result;
}

//----- (1002444A) --------------------------------------------------------
char __thiscall sub_1002444A(void *this)
{
  _ESI = 1;
  _EDX = (int)((char *)this + 16);
  __asm { lock cmpxchg [edx], esi }
  *((_DWORD *)this + 2) &= 0xFFFFFFFEu;
  (*(void (**)(void))(**(_DWORD **)this + 12))();
  return 1;
}

//----- (1002446D) --------------------------------------------------------
int __thiscall sub_1002446D(int this, int a2)
{
  int result; // eax@1
  int v3; // edi@1
  int v4; // esi@3

  v3 = this;
  result = *(_DWORD *)(this + 8) >> 1;
  if ( !(result & 1) )
  {
    result = *(_DWORD *)(a2 + 8) >> 1;
    if ( result & 1 )
    {
      result = *(_DWORD *)(a2 + 8);
      v4 = (*(_DWORD *)(a2 + 8) + 8) & 0xFFFFFFFA;
      if ( result & 1 )
      {
        result = *(_DWORD *)(a2 + 8) >> 2;
        if ( result & 1
          || !*(_DWORD *)(a2 + 12) && (result = (*(int (**)(void))(**(_DWORD **)a2 + 16))(), (_BYTE)result) )
          v4 |= 4u;
      }
      *(_DWORD *)(v3 + 8) |= v4;
    }
  }
  return result;
}

//----- (100244C0) --------------------------------------------------------
int __thiscall sub_100244C0(int this)
{
  int result; // eax@1
  int v2; // esi@1
  char v3; // [sp+4h] [bp-10h]@2
  int v4; // [sp+Ch] [bp-8h]@1
  BOOL (__cdecl *v5)(); // [sp+10h] [bp-4h]@1

  v2 = this;
  result = *(_DWORD *)(this + 4);
  v4 = 0;
  v5 = sub_1002C66E;
  while ( !result )
  {
    sub_1001FF20((int)&v3);
    result = *(_DWORD *)(v2 + 4);
  }
  return result;
}

//----- (100244EB) --------------------------------------------------------
void __thiscall sub_100244EB(LPCRITICAL_SECTION lpCriticalSection)
{
  EnterCriticalSection(lpCriticalSection);
}

//----- (100244F3) --------------------------------------------------------
DWORD __thiscall sub_100244F3(void *this, int a2)
{
  DWORD result; // eax@1
  DWORD v3; // edi@1
  int v4; // esi@1

  v4 = (int)this;
  result = GetCurrentThreadId();
  v3 = result;
  if ( *(_DWORD *)(v4 + 36) == result )
  {
    ++*(_DWORD *)(v4 + 32);
  }
  else
  {
    result = sub_1002458C(v4, a2, 1);
    *(_DWORD *)(v4 + 36) = v3;
    *(_DWORD *)(v4 + 32) = 1;
  }
  return result;
}

//----- (10024528) --------------------------------------------------------
int __thiscall sub_10024528(void *this)
{
  int v1; // edi@1
  int v3; // edx@4
  int result; // eax@5

  _ESI = this;
  v1 = (int)((char *)this + 4);
  while ( 1 )
  {
    if ( *(_DWORD *)v1 > 0 )
      sub_100247A6(v1, 0, -1);
    v3 = *(_DWORD *)_ESI;
    if ( *(_DWORD *)_ESI != -1 )
    {
      _ECX = v3 + 1;
      result = *(_DWORD *)_ESI;
      __asm { lock cmpxchg [esi], ecx }
      if ( v3 == v3 )
        break;
    }
  }
  return result;
}

//----- (10024558) --------------------------------------------------------
int __thiscall sub_10024558(void *this)
{
  int result; // eax@1

  _ESI = (int)this;
  _EAX = (int)((char *)this + 4);
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  _EDX = -1;
  result = 0;
  __asm { lock cmpxchg [esi], edx }
  while ( result )
  {
    sub_100247A6(_ESI, 0, -1);
    _ECX = -1;
    result = 0;
    __asm { lock cmpxchg [esi], ecx }
  }
  return result;
}

//----- (1002458C) --------------------------------------------------------
bool __thiscall sub_1002458C(int this, int a2, char a3)
{
  int ebp0; // ebp@0
  int v4; // edi@1
  int v5; // ebx@2
  char v7; // [sp+8h] [bp-Ch]@9

  v4 = this;
  if ( *(_DWORD *)a2 == *(_DWORD *)this )
  {
    sub_100248C6((int)&v7, (unsigned int)"Lock already taken");
    sub_1002D02B((int)&v7, (int)&unk_1005FD6C);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1002462B);
  }
  v5 = *(_DWORD *)(this + 28);
  *(_DWORD *)(this + 28) = a2;
  if ( v5 )
  {
    sub_1002446D(a2, v5);
    *(_DWORD *)(v5 + 4) = a2;
    sub_100242E7((void *)a2, v5, *(_DWORD *)(v4 + 8));
    if ( *(_DWORD *)(a2 + 16) != 2 )
      sub_1002446D(a2, v4);
  }
  else
  {
    *(_DWORD *)(this + 24) = a2;
    sub_1002446D(a2, this);
    *(_DWORD *)(a2 + 8) &= 0xFFFFFFFEu;
    sub_10024425(a2, 0, ebp0, v4);
  }
  if ( a3 )
  {
    *(_DWORD *)(v4 + 8) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(v4 + 4) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)v4 = *(_DWORD *)a2;
    *(_DWORD *)(v4 + 24) = a2;
  }
  return *(_DWORD *)(a2 + 16) != 2;
}

//----- (1002462B) --------------------------------------------------------
int __thiscall sub_1002462B(void *this)
{
  int v1; // ecx@1
  int result; // eax@2

  v1 = (int)((char *)this + 4);
  if ( *(_DWORD *)v1 > 0 )
    result = sub_100247A6(v1, 0, -1);
  return result;
}

//----- (10024641) --------------------------------------------------------
void __thiscall sub_10024641(int this)
{
  if ( *(_DWORD *)(this + 28) )
  {
    sub_100247DF((void *)this);
    JUMPOUT(*(unsigned int *)loc_1002480D);
  }
}
// 1002480D: using guessed type int loc_1002480D();

//----- (10024659) --------------------------------------------------------
int __cdecl sub_10024659()
{
  int result; // eax@1

  result = (unsigned int)sub_10034C38() > 1 ? 0xFA0 : 0;
  dwSpinCount = result;
  return result;
}

//----- (10024670) --------------------------------------------------------
void __thiscall sub_10024670(LPCRITICAL_SECTION lpCriticalSection)
{
  LeaveCriticalSection(lpCriticalSection);
}

//----- (1002468A) --------------------------------------------------------
int __cdecl sub_1002468A()
{
  int result; // eax@1

  _EAX = -1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (10024692) --------------------------------------------------------
int __thiscall sub_10024692(void *this)
{
  int result; // eax@1

  *(_DWORD *)this = 0;
  result = (int)((char *)this + 4);
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  return result;
}

//----- (100246A3) --------------------------------------------------------
int __thiscall sub_100246A3(int this, int a2)
{
  int result; // eax@1

  result = a2;
  if ( a2 )
  {
    *(_DWORD *)(this + 4) = 0;
    *(_DWORD *)this = a2;
    *(_DWORD *)(this + 8) = 1;
  }
  else
  {
    *(_DWORD *)(this + 8) = 4;
  }
  return result;
}

//----- (100246C7) --------------------------------------------------------
char __thiscall sub_100246C7(void *this)
{
  char v1; // bl@1
  int v2; // esi@1
  int v3; // eax@2
  int v4; // eax@4
  int v5; // eax@5
  int v6; // eax@6
  char result; // al@10
  char v8; // zf@11
  char v9; // zf@15

  v2 = (int)this;
  v1 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(v2 + 8);
    if ( v3 )
      break;
    *(_DWORD *)(v2 + 8) = 0;
    sub_100246A3(v2, dwSpinCount);
  }
  v4 = v3 - 1;
  if ( v4 )
  {
    v5 = v4 - 1;
    if ( v5 )
    {
      v6 = v5 - 1;
      if ( !v6 )
      {
        *(_DWORD *)(v2 + 8) = 0;
        sub_100246A3(v2, dwSpinCount);
        return 0;
      }
      if ( v6 != 1 )
        return 0;
    }
    else
    {
      v8 = *(_DWORD *)(v2 + 4)-- == 1;
      if ( v8 )
        *(_DWORD *)(v2 + 8) = 3;
      v1 = 1;
    }
    __asm { pause }
    result = v1;
  }
  else
  {
    __asm { pause }
    v9 = *(_DWORD *)v2-- == 1;
    if ( v9 )
      *(_DWORD *)(v2 + 8) = 3 - (*(_DWORD *)(v2 + 4) != 0);
    result = 1;
  }
  return result;
}

//----- (10024734) --------------------------------------------------------
int __thiscall sub_10024734(int this, int a2)
{
  int result; // eax@1
  int v3; // esi@1
  char v4; // zf@1

  v3 = this;
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  v4 = *(_DWORD *)(this + 4) == 0;
  result = *(_DWORD *)a2;
  *(_DWORD *)this = *(_DWORD *)a2;
  if ( v4 )
  {
    _EDX = this;
    _ECX = this + 28;
    result = a2;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 != a2 )
    {
      sub_100244C0(a2);
      *(_DWORD *)(v3 + 8) = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(v3 + 4) = *(_DWORD *)(a2 + 4);
      result = *(_DWORD *)a2;
      *(_DWORD *)v3 = *(_DWORD *)a2;
    }
  }
  *(_DWORD *)(v3 + 24) = v3;
  return result;
}

//----- (10024783) --------------------------------------------------------
char __thiscall sub_10024783(void *_ECX)
{
  _EDX = -1;
  __asm { lock cmpxchg [ecx], edx }
  _EDX = (int)((char *)_ECX + 4);
  _ECX = 1;
  __asm { lock xadd [edx], ecx }
  return 1;
}

//----- (100247A0) --------------------------------------------------------
DWORD __cdecl sub_100247A0()
{
  return dwSpinCount;
}

//----- (100247A6) --------------------------------------------------------
int __cdecl sub_100247A6(int a1, int a2, int a3)
{
  signed int v3; // esi@1
  DWORD v4; // ecx@2
  int result; // eax@8
  DWORD v6; // [sp-4h] [bp-Ch]@4

  v3 = 10;
LABEL_7:
  v4 = 0;
  while ( 1 )
  {
    result = a3 & *(_DWORD *)a1;
    if ( result == a2 )
      return result;
    __asm { pause }
    ++v4;
    if ( v4 >= dwSpinCount )
    {
      if ( v3 <= 0 )
      {
        v6 = 1;
      }
      else
      {
        --v3;
        v6 = 0;
      }
      Sleep(v6);
      goto LABEL_7;
    }
  }
}

//----- (100247DF) --------------------------------------------------------
int __thiscall sub_100247DF(void *this)
{
  int v2; // esi@1
  char Parameter; // [sp+4h] [bp-18h]@1

  v2 = (int)this;
  sub_1002409A(&Parameter, 0xFFFFFFFFu);
  sub_1002458C(v2, (int)&Parameter, 0);
  return sub_10024734(v2, (int)&Parameter);
}

//----- (1002487E) --------------------------------------------------------
int __thiscall sub_1002487E(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100236EA(this);
  *(_DWORD *)v2 = &off_100559BC;
  return v2;
}
// 100559BC: using guessed type int (__stdcall *off_100559BC)(char);

//----- (10024890) --------------------------------------------------------
int __thiscall sub_10024890(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100236EA(this);
  *(_DWORD *)v2 = &off_10055678;
  return v2;
}
// 10055678: using guessed type int (__stdcall *off_10055678)(char);

//----- (100248A2) --------------------------------------------------------
int __thiscall sub_100248A2(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100236EA(this);
  *(_DWORD *)v2 = &off_10055A10;
  return v2;
}
// 10055A10: using guessed type int (__stdcall *off_10055A10)(char);

//----- (100248B4) --------------------------------------------------------
int __thiscall sub_100248B4(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100236EA(this);
  *(_DWORD *)v2 = &off_10055A04;
  return v2;
}
// 10055A04: using guessed type int (__stdcall *off_10055A04)(char);

//----- (100248C6) --------------------------------------------------------
int __thiscall sub_100248C6(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_10023687(this, (int *)&a2);
  *(_DWORD *)v3 = &off_1005599C;
  return v3;
}
// 1005599C: using guessed type int (__stdcall *off_1005599C)(char);

//----- (100248E2) --------------------------------------------------------
int __thiscall sub_100248E2(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100236EA(this);
  *(_DWORD *)v2 = &off_100559EC;
  return v2;
}
// 100559EC: using guessed type int (__stdcall *off_100559EC)(char);

//----- (100248F4) --------------------------------------------------------
int __thiscall sub_100248F4(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100236EA(this);
  *(_DWORD *)v2 = &off_100559F8;
  return v2;
}
// 100559F8: using guessed type int (__stdcall *off_100559F8)(char);

//----- (10024906) --------------------------------------------------------
int __thiscall sub_10024906(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_10023687(this, (int *)&a2);
  *(_DWORD *)v3 = &off_10055690;
  return v3;
}
// 10055690: using guessed type int (__stdcall *off_10055690)(char);

//----- (10024922) --------------------------------------------------------
int __thiscall sub_10024922(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100236EA(this);
  *(_DWORD *)v2 = &off_10055A58;
  return v2;
}
// 10055A58: using guessed type int (__stdcall *off_10055A58)(char);

//----- (10024934) --------------------------------------------------------
int __thiscall sub_10024934(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_10023687(this, (int *)&a2);
  *(_DWORD *)v3 = &off_1005569C;
  return v3;
}
// 1005569C: using guessed type int (__stdcall *off_1005569C)(char);

//----- (10024950) --------------------------------------------------------
int __thiscall sub_10024950(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100236EA(this);
  *(_DWORD *)v2 = &off_1005569C;
  return v2;
}
// 1005569C: using guessed type int (__stdcall *off_1005569C)(char);

//----- (10024962) --------------------------------------------------------
int __thiscall sub_10024962(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100236EA(this);
  *(_DWORD *)v2 = &off_10055A64;
  return v2;
}
// 10055A64: using guessed type int (__stdcall *off_10055A64)(char);

//----- (10024974) --------------------------------------------------------
int __thiscall sub_10024974(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_10023687(this, (int *)&a2);
  *(_DWORD *)v3 = &off_10055A28;
  return v3;
}
// 10055A28: using guessed type int (__stdcall *off_10055A28)(char);

//----- (10024990) --------------------------------------------------------
int __thiscall sub_10024990(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100236EA(this);
  *(_DWORD *)v2 = &off_10055A40;
  return v2;
}
// 10055A40: using guessed type int (__stdcall *off_10055A40)(char);

//----- (100249A2) --------------------------------------------------------
int __thiscall sub_100249A2(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_10023687(this, (int *)&a2);
  *(_DWORD *)v3 = &off_10055A34;
  return v3;
}
// 10055A34: using guessed type int (__stdcall *off_10055A34)(char);

//----- (100249BE) --------------------------------------------------------
int __thiscall sub_100249BE(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100236EA(this);
  *(_DWORD *)v2 = &off_10055684;
  return v2;
}
// 10055684: using guessed type int (__stdcall *off_10055684)(char);

//----- (100249D0) --------------------------------------------------------
int __thiscall sub_100249D0(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100236EA(this);
  *(_DWORD *)v2 = &off_10055A1C;
  return v2;
}
// 10055A1C: using guessed type int (__stdcall *off_10055A1C)(char);

//----- (100249E2) --------------------------------------------------------
int __thiscall sub_100249E2(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100236EA(this);
  *(_DWORD *)v2 = &off_10055A4C;
  return v2;
}
// 10055A4C: using guessed type int (__stdcall *off_10055A4C)(char);

//----- (100249F4) --------------------------------------------------------
int __thiscall sub_100249F4(int this, int a2)
{
  int v3; // esi@1

  v3 = this;
  sub_100236EA(this);
  *(_DWORD *)(v3 + 12) = a2;
  *(_DWORD *)v3 = &off_100559C8;
  return v3;
}
// 100559C8: using guessed type int (__stdcall *off_100559C8)(char);

//----- (10024A12) --------------------------------------------------------
int __thiscall sub_10024A12(int this, int a2)
{
  int v3; // esi@1

  v3 = this;
  sub_100249F4(this, a2);
  *(_DWORD *)v3 = &off_100559D4;
  return v3;
}
// 100559D4: using guessed type int (__stdcall *off_100559D4)(char);

//----- (10024A2D) --------------------------------------------------------
int __thiscall sub_10024A2D(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100236EA(this);
  *(_DWORD *)v2 = &off_10055A70;
  return v2;
}
// 10055A70: using guessed type int (__stdcall *off_10055A70)(char);

//----- (10024A3F) --------------------------------------------------------
int __thiscall sub_10024A3F(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100236EA(this);
  *(_DWORD *)v2 = &off_100559E0;
  return v2;
}
// 100559E0: using guessed type int (__stdcall *off_100559E0)(char);

//----- (10024A51) --------------------------------------------------------
int __thiscall sub_10024A51(int this, int a2, char a3, char a4)
{
  signed int i; // ecx@1
  int v5; // edi@1
  int v6; // esi@1

  v5 = this;
  v6 = sub_10024BBF(this);
  for ( i = 3; i; --i )
    v6 += 4;
  *(_DWORD *)v5 = off_10055AAC;
  *(_DWORD *)(v5 + 12) = 0;
  *(_DWORD *)(v5 + 16) = 0;
  *(_DWORD *)(v5 + 20) = 0;
  *(_DWORD *)(v5 + 24) = a2 + (a4 != 0);
  *(_DWORD *)(v5 + 32) = 0;
  *(_BYTE *)(v5 + 40) = a3;
  *(_DWORD *)(v5 + 36) = 0;
  *(_BYTE *)(v5 + 41) = 0;
  return v5;
}
// 10055AAC: using guessed type int (*off_10055AAC[5])();

//----- (10024A9A) --------------------------------------------------------
#error "10024B3B: call analysis failed (funcsize=57)"

//----- (10024B43) --------------------------------------------------------
int __thiscall sub_10024B43(int this)
{
  signed int v1; // ecx@1
  int v2; // edi@1
  int v3; // esi@1
  int v4; // eax@1

  v2 = this;
  v4 = sub_10024BBF(this);
  v1 = 3;
  v3 = v4;
  while ( v1 )
  {
    v3 += 4;
    --v1;
  }
  *(_DWORD *)v2 = &off_10055A94;
  return v2;
}
// 10055A94: using guessed type int (__stdcall *off_10055A94)(int, int);

//----- (10024B5E) --------------------------------------------------------
int __thiscall sub_10024B5E(int this, int a2, char a3, char a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@1

  v5 = this;
  v7 = sub_10024A51(this, a2, a3, a4);
  v4 = 11;
  *(_DWORD *)v5 = &off_10055AC8;
  v6 = v7;
  *(_DWORD *)(v5 + 28) = a2;
  while ( v4 )
  {
    v6 += 4;
    --v4;
  }
  return v5;
}
// 10055AC8: using guessed type int (__stdcall *off_10055AC8)(int, int);

//----- (10024B8E) --------------------------------------------------------
int __thiscall sub_10024B8E(int this, int a2, char a3, char a4)
{
  signed int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // eax@1

  v5 = this;
  v7 = sub_10024A51(this, a2, a3, a4);
  v4 = 11;
  v6 = v7;
  while ( v4 )
  {
    v6 += 4;
    --v4;
  }
  *(_DWORD *)v5 = &off_10055AE4;
  *(_DWORD *)(v5 + 28) = 1;
  return v5;
}
// 10055AE4: using guessed type int (__stdcall *off_10055AE4)(int, int);

//----- (10024BBF) --------------------------------------------------------
int __thiscall sub_10024BBF(int this)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = off_10055A7C;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 4) = sub_10028CB0();
  return v2;
}
// 10028CB0: using guessed type int sub_10028CB0(void);
// 10055A7C: using guessed type int (*off_10055A7C[5])();

//----- (10024BDF) --------------------------------------------------------
int __thiscall sub_10024BDF(int this)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = 0;
  sub_10024232(this + 8);
  return v2;
}

//----- (10024C08) --------------------------------------------------------
unsigned int __thiscall sub_10024C08(void *this)
{
  void *i; // esi@1
  unsigned int result; // eax@3
  char v3; // cf@3

  for ( i = this; ; sub_10024DFF(*((_DWORD *)i + 4)) )
  {
    result = *((_DWORD *)i + 5);
    v3 = result < *((_DWORD *)i + 6);
    ++*((_DWORD *)i + 5);
    if ( !v3 )
      break;
  }
  return result;
}

//----- (10024C22) --------------------------------------------------------
int __usercall sub_10024C22<eax>(int a1<ebp>)
{
  int v1; // edi@1
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // ecx@3
  int v5; // ecx@6
  int v6; // esi@7
  int v8; // [sp-Ch] [bp-Ch]@8
  signed int v9; // [sp-4h] [bp-4h]@1

  v9 = 8;
  sub_1002D0B8();
  v1 = v3;
  *(_DWORD *)(a1 - 20) = v3;
  *(_DWORD *)(a1 - 4) = 0;
  sub_10024641(v3 + 8);
  v2 = *(_DWORD *)v1;
  if ( *(_DWORD *)v1 > 1u )
  {
    for ( ; v2; v2 = *(_DWORD *)(a1 - 16) )
    {
      v4 = *(_DWORD *)(v2 + 4);
      *(_DWORD *)(a1 - 16) = *(_DWORD *)v2;
      if ( (unsigned __int8)(**(int (__cdecl ***)(_DWORD, _DWORD, _DWORD))v4)(0, v2, v9) )
        (*(void (**)(void))(**(_DWORD **)(v2 + 4) + 8))();
    }
  }
  v5 = *(_DWORD *)(v1 + 4);
  if ( v5 )
  {
    do
    {
      v6 = *(_DWORD *)v5;
      (*(void (**)(void))(**(_DWORD **)(v5 + 4) + 8))();
      v5 = v6;
    }
    while ( v6 );
  }
  *(_DWORD *)(a1 - 4) = -1;
  nullsub_2(v1 + 8);
  return sub_1002D086(v8);
}
// 10024CC5: using guessed type int __thiscall nullsub_2(_DWORD);
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10024C97) --------------------------------------------------------
void *__userpurge sub_10024C97<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1
  int v4; // ST00_4@1

  v3 = (void *)a1;
  v4 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = &off_10055B00;
  sub_1002563B(a2, v4);
  if ( a3 & 1 )
    sub_1002404A(v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10055B00: using guessed type int (__stdcall *off_10055B00)(char);

//----- (10024CC6) --------------------------------------------------------
int __stdcall sub_10024CC6(int a1, int a2, int a3)
{
  char v3; // bl@1
  int v11; // ecx@2
  int result; // eax@4

  v3 = 0;
  _ECX = a2 + 20;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  if ( _EAX == 0 )
  {
    v11 = *(_DWORD *)(a2 + 4);
    v3 = 1;
    *(_BYTE *)(a2 + 41) = 1;
    if ( v11 )
    {
      *(_DWORD *)(a2 + 12) = 0;
      (*(void (**)(void))(*(_DWORD *)v11 + 12))();
    }
  }
  result = sub_10024DFF(a2);
  if ( v3 )
    result = sub_1002C5AA(a1, a3);
  return result;
}

//----- (10024D13) --------------------------------------------------------
int __stdcall sub_10024D13(int a1, int a2)
{
  int v9; // edi@2
  void *v10; // ST04_4@2
  int v11; // eax@2

  _ECX = a1 + 20;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  if ( _EAX == 0 )
  {
    v9 = *(_DWORD *)(a1 + 4);
    v10 = *(void **)(a1 + 16);
    v11 = sub_10024D61();
    sub_10032B24((HANDLE)v11, v10, 0);
    *(_BYTE *)(a1 + 41) = 1;
    if ( v9 )
    {
      *(_DWORD *)(a1 + 12) = 0;
      (*(void (__thiscall **)(int))(*(_DWORD *)v9 + 12))(v9);
    }
  }
  return sub_10024DFF(a1);
}

//----- (10024D61) --------------------------------------------------------
int __cdecl sub_10024D61()
{
  char v0; // zf@2
  int (__stdcall **v6)(char); // [sp+14h] [bp-10h]@9
  int v7; // [sp+20h] [bp-4h]@9

  if ( !dword_100690AC )
  {
    _ECX = 1;
    _EDI = &dword_100690A8;
    __asm { lock cmpxchg [edi], ecx }
    dword_100690AC = (int)CreateTimerQueue();
    v0 = dword_100690AC == 0;
    if ( !dword_100690AC )
    {
      dword_100690A8 = 0;
      v0 = dword_100690AC == 0;
    }
    if ( v0 )
    {
      v7 = (int)"bad allocation";
      sub_100236AC((int)&v6, (int)&v7, 1);
      v6 = &off_100542A4;
      sub_1002D02B((int)&v6, (int)&unk_1005F828);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_10024DFF);
    }
  }
  return dword_100690AC;
}
// 100542A4: using guessed type int (__stdcall *off_100542A4)(char);
// 100690A8: using guessed type int dword_100690A8;
// 100690AC: using guessed type int dword_100690AC;

//----- (10024DFF) --------------------------------------------------------
int __thiscall sub_10024DFF(int this)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = *(_DWORD *)(this + 24);
  _EAX = this + 36;
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  result = v2 + 1;
  if ( _EDX + 1 == v2 + 1 )
    result = sub_1002401B((LPVOID)this);
  return result;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (10024E1E) --------------------------------------------------------
char __thiscall sub_10024E1E(int this)
{
  int v1; // edx@1
  int v3; // edi@1
  int v4; // esi@1
  char result; // al@5

  v3 = this;
  v4 = *(_DWORD *)(this + 28);
  _EBX = this + 32;
  v1 = *(_DWORD *)(this + 32);
  if ( v1 == v4 )
    goto LABEL_9;
  do
  {
    _ECX = v1 - 1;
    __asm { lock cmpxchg [ebx], ecx }
  }
  while ( v1 != v1 && v1 != v4 );
  if ( v1 == v4 )
  {
LABEL_9:
    sub_10024DFF(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10024E57) --------------------------------------------------------
char __thiscall sub_10024E57(int this, int a2, int a3)
{
  if ( *(_DWORD *)(*(_DWORD *)(a3 + 4) + 8) == 2 )
  {
    if ( a2 )
      *(_DWORD *)a2 = *(_DWORD *)(this + 4);
    else
      (*(void (**)(void))(**(_DWORD **)(this + 4) + 12))();
  }
  else
  {
    _EDX = 1;
    _ECX = *(_DWORD *)(a3 + 4) + 8;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 )
      *(_DWORD *)a2 = 0;
  }
  return 0;
}

//----- (10024EA6) --------------------------------------------------------
char __thiscall sub_10024EA6(void *this, int a2, int a3)
{
  int v3; // esi@1
  char result; // al@4

  v3 = (int)this;
  if ( a2 )
    *(_DWORD *)a2 = 0;
  _EAX = (int)((char *)this + 32);
  _ECX = 1;
  __asm { lock xadd [eax], ecx }
  if ( _ECX + 1 == *(_DWORD *)(v3 + 28) )
  {
    (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v3 + 20))(v3, a2, a3);
    sub_10024DFF(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10024EE3) --------------------------------------------------------
char __thiscall sub_10024EE3(void *this, int a2, int a3)
{
  int v3; // esi@1

  v3 = (int)this;
  if ( a2 )
    *(_DWORD *)a2 = 0;
  _EAX = (int)((char *)this + 32);
  _ECX = 1;
  __asm { lock xadd [eax], ecx }
  if ( _ECX + 1 == *(_DWORD *)(v3 + 28) )
    (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v3 + 20))(v3, a2, a3);
  sub_10024DFF(v3);
  return 0;
}

//----- (10024F1C) --------------------------------------------------------
int __thiscall sub_10024F1C(void *this)
{
  int result; // eax@1
  unsigned int v2; // edi@1
  unsigned int v6; // esi@6

  _ESI = this;
  v2 = *(_DWORD *)this;
  _EDX = 1;
  result = *(_DWORD *)this;
  __asm { lock cmpxchg [esi], edx }
  while ( result != v2 )
  {
    v2 = result;
    _ECX = 1;
    __asm { lock cmpxchg [esi], ecx }
  }
  if ( v2 > 1 )
  {
    if ( v2 )
    {
      do
      {
        v6 = *(_DWORD *)v2;
        result = (*(int (**)(void))(**(_DWORD **)(v2 + 4) + 12))();
        v2 = v6;
      }
      while ( v6 );
    }
  }
  return result;
}

//----- (10024F56) --------------------------------------------------------
int __thiscall sub_10024F56(int this, int a2, int a3)
{
  int v3; // ebx@1
  int v5; // esi@1
  int result; // eax@2
  char v13; // zf@3
  void *v14; // ST04_4@6
  int v15; // eax@6

  v5 = this;
  v3 = *(_DWORD *)(this + 4);
  _EDI = 1;
  if ( !*(_BYTE *)(this + 40) )
    goto LABEL_17;
  result = this + 20;
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  if ( _EDX == 0 )
  {
LABEL_17:
    v13 = *(_DWORD *)(this + 16) == 0;
    *(_DWORD *)(this + 12) = a3;
    if ( !v13 )
    {
      if ( sub_10034C33() < 3 )
      {
        v14 = *(void **)(v5 + 16);
        v15 = sub_10024D61();
        sub_10032B24((HANDLE)v15, v14, (HANDLE)0xFFFFFFFF);
      }
      else
      {
        sub_1002C380(*(_DWORD *)(v5 + 16));
      }
      if ( *(_DWORD *)(v5 + 20) == 1 )
        sub_10024DFF(v5);
    }
    if ( *(_DWORD *)(*(_DWORD *)(a3 + 4) + 8) == 2 )
    {
      result = a2;
      if ( a2 )
        *(_DWORD *)a2 = v3;
      else
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 12))(v3);
    }
    else
    {
      _ECX = *(_DWORD *)(a3 + 4) + 8;
      __asm { lock cmpxchg [ecx], edi }
      result = a2;
      if ( a2 )
        *(_DWORD *)a2 = 0;
    }
  }
  return result;
}
// 10034C33: using guessed type int sub_10034C33(void);

//----- (10024FFA) --------------------------------------------------------
int __cdecl sub_10024FFA(int a1, char a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v4; // eax@2
  int v5; // ebx@2
  char v6; // al@3

  v3 = a1;
  v2 = 0;
  if ( a1 )
  {
    do
    {
      v5 = *(_DWORD *)v3;
      v4 = **(_DWORD **)(v3 + 4);
      if ( a2 )
        v6 = (*(int (**)(void))(v4 + 12))();
      else
        v6 = (*(int (**)(void))(v4 + 16))();
      if ( v6 )
      {
        *(_DWORD *)v3 = v2;
        v2 = v3;
      }
      v3 = v5;
    }
    while ( v5 );
  }
  return v2;
}

//----- (10025034) --------------------------------------------------------
char __thiscall sub_10025034(void *this)
{
  if ( *((_DWORD *)this + 8) >= *((_DWORD *)this + 7) )
  {
    (*(void (**)(void))(*(_DWORD *)this + 4))();
    return 0;
  }
  if ( *((_BYTE *)this + 41) )
  {
    (*(void (**)(void))(*(_DWORD *)this + 8))();
    return 0;
  }
  return 1;
}

//----- (10025054) --------------------------------------------------------
char __thiscall sub_10025054(int this)
{
  int v1; // esi@1
  char result; // al@4
  char v3; // [sp+4h] [bp-4h]@2

  v1 = this;
  if ( *(_BYTE *)(this + 41) )
  {
    if ( (unsigned __int8)(**(int (__stdcall ***)(char *, _DWORD))this)(&v3, 0) )
      (*(void (__thiscall **)(int))(*(_DWORD *)v1 + 8))(v1);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10025081) --------------------------------------------------------
char __thiscall sub_10025081(int this)
{
  char result; // al@3
  int v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  if ( *(_DWORD *)(this + 32) >= *(_DWORD *)(this + 28) || *(_BYTE *)(this + 41) )
  {
    (**(void (__stdcall ***)(int *, _DWORD, int))this)(&v2, 0, v2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (100250A5) --------------------------------------------------------
#error "10025142: call analysis failed (funcsize=57)"

//----- (10025148) --------------------------------------------------------
int __usercall sub_10025148<eax>(int a1<ebp>)
{
  int v1; // edx@1
  int j; // ebx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // ecx@1
  int *v6; // eax@1
  int i; // eax@2
  int v8; // ecx@2
  int v9; // ecx@4
  int v10; // eax@5
  int v11; // ecx@11
  int v12; // ecx@12
  int v13; // eax@13
  signed int v15; // [sp-4h] [bp-4h]@1

  v15 = 56;
  sub_1002D0EB();
  *(_DWORD *)(a1 - 20) = v5;
  j = 0;
  v4 = 0;
  *(_DWORD *)(a1 - 40) = &off_10055B00;
  *(_DWORD *)(a1 - 36) = 0;
  *(_DWORD *)(a1 - 32) = 0;
  *(_DWORD *)(a1 - 4) = 0;
  sub_1002426D(a1, v5 + 8);
  v6 = *(int **)(a1 - 20);
  *(_BYTE *)(a1 - 4) = 1;
  v3 = *v6;
  *v6 = 1;
  if ( (unsigned int)v3 > 1 )
  {
    v8 = 0;
    for ( i = v3; i; ++v8 )
      i = *(_DWORD *)i;
    v9 = 4 * v8 + 8;
    if ( (unsigned int)v9 > 0x400 )
    {
      v10 = sub_10028264(v1, v9, 0, v3, v9);
      if ( !v10 )
        goto LABEL_10;
      *(_DWORD *)v10 = 56797;
    }
    else
    {
      sub_10031E40(v9, v9, v15);
      v10 = (int)&v15;
      if ( !&v15 )
        goto LABEL_10;
      v15 = 52428;
    }
    v10 += 8;
LABEL_10:
    v4 = 0;
    for ( j = sub_100250A5(v10); v3; v3 = *(_DWORD *)(a1 - 24) )
    {
      v11 = *(_DWORD *)(v3 + 4);
      *(_DWORD *)(a1 - 24) = *(_DWORD *)v3;
      if ( (unsigned __int8)(**(int (__stdcall ***)(_DWORD, _DWORD))v11)(a1 - 28, v3) )
      {
        v12 = *(_DWORD *)(a1 - 20);
        *(_DWORD *)v3 = *(_DWORD *)(v12 + 4);
        *(_DWORD *)(v12 + 4) = v3;
      }
      v13 = *(_DWORD *)(a1 - 28);
      if ( v13 )
        *(_DWORD *)(j + 4 * v4++) = v13;
    }
  }
  *(_BYTE *)(a1 - 4) = 0;
  sub_100242C1();
  while ( v4 )
  {
    --v4;
    (*(void (**)(void))(**(_DWORD **)(j + 4 * v4) + 12))();
  }
  v15 = *(_DWORD *)(a1 - 36);
  sub_1002563B(j, v15);
  return sub_1002D09A(v15);
}
// 100250A5: using guessed type _DWORD __stdcall sub_100250A5(_DWORD);
// 1002D09A: using guessed type int __thiscall sub_1002D09A(_DWORD);
// 10055B00: using guessed type int (__stdcall *off_10055B00)(char);

//----- (10025249) --------------------------------------------------------
int __userpurge sub_10025249<eax>(int a1<ebp>, int ebx0<ebx>, int a3<edi>, int a2)
{
  int v4; // eax@1
  int *v5; // ecx@1
  int *v6; // esi@1

  sub_1002D0B8();
  v6 = v5;
  v4 = *(_DWORD *)(a1 + 8);
  if ( v4 == -1 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 - 44) = 0;
    *(_DWORD *)(a1 - 40) = sub_1002C66E;
    while ( *v6 != 1 )
    {
      if ( !sub_100246C7((void *)(a1 - 52)) )
      {
        sub_10024B43(a1 - 36);
        *(_DWORD *)(a1 - 20) = a1 - 36;
        sub_1002426D(a1, (int)(v6 + 2));
        *(_DWORD *)(a1 - 4) = 0;
        if ( *v6 == 1 )
        {
          *(_BYTE *)(a1 + 8) = 1;
        }
        else
        {
          *(_DWORD *)(a1 - 24) = sub_10024FFA(*v6, 1);
          *v6 = a1 - 24;
        }
        *(_DWORD *)(a1 - 4) = -1;
        sub_100242C1();
        if ( !*(_BYTE *)(a1 + 8) )
        {
          if ( *(_DWORD *)(a1 - 28) != 1 )
          {
            _ECX = 2;
            _EDX = a1 - 28;
            __asm { lock cmpxchg [edx], ecx }
            sub_10028CA4(ebx0, a1, a3);
          }
        }
        return sub_1002D086(68);
      }
    }
  }
  else
  {
    if ( v4 )
    {
      *(_DWORD *)(a1 - 16) = v5;
      sub_1002531E(a1);
    }
  }
  return sub_1002D086(68);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1002531E) --------------------------------------------------------
int __usercall sub_1002531E<eax>(int a1<ebp>)
{
  int v1; // edx@1
  int v2; // eax@2
  int v3; // ebx@4
  DWORD v4; // edi@6
  unsigned int v5; // eax@12
  int v6; // ecx@20
  int v7; // esi@20
  int v8; // eax@21
  int v9; // edx@21
  int v10; // eax@21
  int *v11; // eax@21
  int v12; // eax@22
  int v13; // edx@22
  int v14; // ecx@22
  int v15; // eax@24
  int v16; // ecx@24
  int v17; // eax@27
  int v18; // ecx@27
  int v19; // eax@32
  int v20; // edi@33
  int v21; // edx@34
  int v32; // eax@48
  int v33; // eax@50
  int v34; // [sp-14h] [bp-14h]@43
  int v35; // [sp-Ch] [bp-Ch]@22
  int v36; // [sp-8h] [bp-8h]@2
  signed int v37; // [sp-4h] [bp-4h]@1

  v37 = 156;
  sub_1002D0B8();
  v1 = *(_DWORD *)(a1 + 8);
  if ( !v1 )
  {
    *(_DWORD *)(a1 - 68) = "pEvents";
    sub_10023687(a1 - 128, (int *)(a1 - 68));
    *(_DWORD *)(a1 - 128) = &off_100542CC;
    v36 = (int)&unk_10061764;
    v2 = a1 - 128;
    goto LABEL_3;
  }
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 12);
    if ( !v3 )
      return sub_1002D086(v34);
    v4 = *(_DWORD *)(a1 + 20);
    if ( v3 == 1 && (!v4 || v4 == -1) )
    {
      if ( !*(_DWORD *)v1 )
      {
        *(_DWORD *)(a1 - 76) = "pEvents";
        sub_10023687(a1 - 92, (int *)(a1 - 76));
        *(_DWORD *)(a1 - 92) = &off_100542CC;
        v36 = (int)&unk_10061764;
        v2 = a1 - 92;
        goto LABEL_3;
      }
      sub_10025249(a1, v3, v4, *(_DWORD *)(a1 + 20));
      return sub_1002D086(v34);
    }
    v5 = 0;
    if ( v3 )
    {
      do
      {
        if ( !*(_DWORD *)(v1 + 4 * v5) )
        {
          *(_DWORD *)(a1 - 80) = "pEvents";
          sub_10023687(a1 - 116, (int *)(a1 - 80));
          *(_DWORD *)(a1 - 116) = &off_100542CC;
          v36 = (int)&unk_10061764;
          v2 = a1 - 116;
          goto LABEL_3;
        }
        ++v5;
      }
      while ( v5 < v3 );
    }
    LOBYTE(v5) = v4 && v4 != -1;
    sub_10024A9A(*(_DWORD *)(a1 + 16), v3, v4 != -1, v5);
    *(_DWORD *)(a1 - 4) = 0;
    v7 = *(_DWORD *)(a1 - 44);
    v6 = 0;
    *(_BYTE *)(a1 - 13) = 0;
    *(_DWORD *)(a1 - 20) = 0;
    if ( !v3 )
      goto LABEL_38;
    while ( 1 )
    {
      v10 = *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * v6);
      *(_DWORD *)(a1 - 28) = v10;
      sub_1002426D(a1, v10 + 8);
      v11 = *(int **)(a1 - 28);
      v9 = *(_DWORD *)(a1 - 60) + *(_DWORD *)(a1 - 48) + *(_DWORD *)(a1 - 20) * *(_DWORD *)(a1 - 56);
      ++*(_DWORD *)(a1 - 40);
      v8 = *v11;
      *(_BYTE *)(a1 - 4) = 1;
      *(_DWORD *)(a1 - 32) = v9;
      if ( v8 == 1 )
        break;
      v17 = sub_10024FFA(v8, 1);
      v18 = *(_DWORD *)(a1 - 32);
      *(_DWORD *)v18 = v17;
      **(_DWORD **)(a1 - 28) = v18;
LABEL_28:
      *(_BYTE *)(a1 - 4) = 0;
      sub_100242C1();
      v6 = *(_DWORD *)(a1 - 20) + 1;
      *(_DWORD *)(a1 - 20) = v6;
      if ( v6 >= (unsigned int)v3 )
        goto LABEL_37;
    }
    v14 = *(_DWORD *)(v9 + 4);
    v36 = v9;
    v12 = *(_DWORD *)v14;
    v13 = a1 - 24;
    v35 = a1 - 24;
    if ( *(_BYTE *)(a1 + 16) )
    {
      if ( (unsigned __int8)(*(int (__fastcall **)(int, int))v12)(v14, v13) )
      {
        v15 = sub_10024FFA(*(_DWORD *)(*(_DWORD *)(a1 - 28) + 4), 0);
        v16 = *(_DWORD *)(a1 - 32);
        *(_DWORD *)v16 = v15;
        *(_DWORD *)(*(_DWORD *)(a1 - 28) + 4) = v16;
      }
      if ( *(_DWORD *)(a1 - 24) )
        *(_BYTE *)(a1 - 13) = 1;
      goto LABEL_28;
    }
    (*(void (__fastcall **)(int, int))v12)(v14, v13);
    if ( *(_DWORD *)(a1 - 24) )
      *(_BYTE *)(a1 - 13) = 1;
    v19 = *(_DWORD *)(a1 - 20) + 1;
    *(_DWORD *)(a1 + 8) = v19;
    if ( v19 < (unsigned int)v3 )
    {
      v20 = v19;
      do
      {
        v21 = *(_DWORD *)(a1 - 60) + *(_DWORD *)(a1 - 48) + v20 * *(_DWORD *)(a1 - 56);
        ++*(_DWORD *)(a1 - 40);
        (***(void (__cdecl ****)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(v21 + 4))(a1 - 24, v21, v35, v36, v37);
        ++v20;
      }
      while ( v20 < (unsigned int)v3 );
      v4 = *(_DWORD *)(a1 + 20);
    }
    *(_BYTE *)(a1 - 4) = 0;
    sub_100242C1();
LABEL_37:
    if ( *(_BYTE *)(a1 - 13) )
    {
LABEL_42:
      sub_10024C08((void *)(a1 - 60));
      return sub_1002D086(v34);
    }
LABEL_38:
    _EDX = v7 + 8;
    if ( *(_DWORD *)(v7 + 8) == 1 )
      goto LABEL_42;
    _ECX = 2;
    __asm { lock cmpxchg [edx], ecx }
    if ( !v4 )
    {
      _EAX = v7 + 20;
      _ECX = 1;
      __asm { lock xadd [eax], ecx }
      if ( _ECX == 0 )
      {
        *(_DWORD *)(v7 + 12) &= v4;
        *(_BYTE *)(v7 + 41) = 1;
      }
      else
      {
        sub_10028CA4(1, a1, v4);
      }
      goto LABEL_42;
    }
    if ( v4 == -1 || *(_DWORD *)(v7 + 20) )
      goto LABEL_53;
    if ( sub_10034C33() >= 3 )
    {
      v32 = sub_1002C512(v4, (int)sub_10024CC6, v7);
      *(_DWORD *)(v7 + 16) = v32;
      if ( !v32 )
      {
        *(_DWORD *)(a1 - 64) = "bad allocation";
        sub_100236AC(a1 - 140, a1 - 64, 1);
        *(_DWORD *)(a1 - 140) = &off_100542A4;
        v2 = a1 - 140;
        goto LABEL_3;
      }
LABEL_52:
      ++*(_DWORD *)(a1 - 40);
LABEL_53:
      sub_10028CA4(-1, a1, v4);
      goto LABEL_42;
    }
    v33 = sub_10024D61();
    if ( CreateTimerQueueTimer(
           (PHANDLE)(v7 + 16),
           (HANDLE)v33,
           (WAITORTIMERCALLBACK)sub_10024D13,
           (PVOID)v7,
           v4,
           0,
           0x20u) )
      goto LABEL_52;
    *(_DWORD *)(a1 - 72) = "bad allocation";
    sub_100236AC(a1 - 104, a1 - 72, 1);
    *(_DWORD *)(a1 - 104) = &off_100542A4;
    v2 = a1 - 104;
LABEL_3:
    sub_1002D02B(v2, v36);
  }
}
// 10024A9A: using guessed type _DWORD __stdcall sub_10024A9A(_DWORD, _DWORD, _DWORD, _DWORD);
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10034C33: using guessed type int sub_10034C33(void);
// 100542A4: using guessed type int (__stdcall *off_100542A4)(char);
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);

//----- (1002563B) --------------------------------------------------------
void __usercall sub_1002563B(int a1<ebx>, int a2)
{
  if ( a2 )
  {
    if ( *(_DWORD *)(a2 - 8) == 56797 )
      sub_100282F6(a1, (LPVOID)(a2 - 8));
  }
}

//----- (10025659) --------------------------------------------------------
int __userpurge sub_10025659<eax>(int a1<ebp>, int a2)
{
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // ST00_4@1

  sub_1002D0B8();
  v4 = v3;
  *(_DWORD *)(a1 - 16) = v3;
  *(_DWORD *)v3 = &off_10055B10;
  *(_DWORD *)(v3 + 4) = 1;
  v5 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)v3 = &off_10055B1C;
  sub_100257BF(a1, v5);
  *(_DWORD *)(v4 + 144) = sub_1002607B;
  *(_DWORD *)(v4 + 148) = v4;
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10055B10: using guessed type int (__stdcall *off_10055B10)(char);
// 10055B1C: using guessed type int (__stdcall *off_10055B1C)(int);

//----- (100256A6) --------------------------------------------------------
int __userpurge sub_100256A6<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_100559BC;
  return v4;
}
// 100559BC: using guessed type int (__stdcall *off_100559BC)(char);

//----- (100256C1) --------------------------------------------------------
int __userpurge sub_100256C1<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // esi@4
  int v9; // esi@4
  LPVOID v10; // eax@4
  int v18; // eax@7
  int v19; // esi@7
  LPVOID v24; // esi@12
  int v26; // eax@14

  sub_1002D0B8();
  v5 = v7;
  *(_DWORD *)(a2 - 16) = v7;
  *(_DWORD *)(v5 + 4) |= 0xFFFFFFFu;
  v4 = 7;
  *(_DWORD *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 16) = 0;
  v6 = v5;
  while ( v4 )
  {
    v6 += 4;
    --v4;
  }
  *(_DWORD *)(v5 + 20) = -2147483648;
  *(_DWORD *)(v5 + 24) = 0;
  *(_DWORD *)(v5 + 56) = 0;
  sub_10024BDF(v5 + 60);
  v9 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(v5 + 100) = *(_DWORD *)(v9 + 100);
  *(_DWORD *)(v5 + 108) = 0;
  *(_DWORD *)(a2 - 4) = 0;
  *(_DWORD *)(v5 + 120) = 0;
  *(_DWORD *)(v5 + 132) = 0;
  *(_DWORD *)(v5 + 136) = 0;
  v10 = sub_1002436D(a1, a2, v5);
  *(_DWORD *)(v5 + 12) = v10;
  *(_DWORD *)v5 = *((_DWORD *)v10 + 13);
  v8 = *(_DWORD *)(v9 + 8);
  *(_DWORD *)(v5 + 8) = v8;
  if ( sub_100013B0(v8) )
  {
    _EAX = v8 + 4;
    _EDX = 1;
    __asm { lock xadd [eax], edx }
  }
  sub_100261DF(a2);
  sub_10025148(a2);
  if ( *(_BYTE *)(a2 + 12) )
  {
    _EDX = *(_DWORD *)(v5 + 100) + 104;
    _ECX = v5;
    v19 = *(_DWORD *)_EDX;
    *(_DWORD *)(v5 + 104) = *(_DWORD *)_EDX;
    v18 = v19;
    __asm { lock cmpxchg [edx], ecx }
    while ( v18 != v19 )
    {
      *(_DWORD *)(v5 + 104) = v18;
      v19 = v18;
      _EDX = v5;
      _ECX = *(_DWORD *)(v5 + 100) + 104;
      __asm { lock cmpxchg [ecx], edx }
    }
  }
  else
  {
    *(_DWORD *)(v5 + 120) |= 1u;
    *(_DWORD *)(v5 + 104) = 0;
  }
  v24 = sub_10029DCE();
  if ( !*((_DWORD *)v24 + 8) )
    sub_10026FFD(a1, a2);
  v26 = *(_DWORD *)(*((_DWORD *)v24 + 8) + 64);
  *(_DWORD *)(v5 + 4) &= 0xFFFFFFFu;
  *(_DWORD *)(v5 + 128) = v26;
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (100257BF) --------------------------------------------------------
int __userpurge sub_100257BF<eax>(int a1<ebp>, int a2)
{
  signed int v2; // ecx@1
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ecx@1
  LPVOID v14; // eax@6
  LPVOID v15; // esi@6
  int v17; // eax@8

  sub_1002D0B8();
  v4 = v6;
  *(_DWORD *)(a1 - 16) = v6;
  *(_DWORD *)(v4 + 4) |= 0xFFFFFFFu;
  v3 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(v6 + 16) = 0;
  *(_DWORD *)(v6 + 24) = 0;
  v2 = 7;
  *(_DWORD *)(v4 + 8) = v3;
  v5 = v4;
  while ( v2 )
  {
    v5 += 4;
    --v2;
  }
  *(_DWORD *)(v4 + 20) = -2147483648;
  *(_DWORD *)(v4 + 56) = 0;
  sub_10024BDF(v4 + 60);
  *(_DWORD *)(v4 + 104) = 0;
  *(_DWORD *)(v4 + 108) = 0;
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)(v4 + 120) = 0;
  *(_DWORD *)(v4 + 132) = 0;
  *(_DWORD *)(v4 + 136) = 0;
  if ( sub_100013B0(v3) )
  {
    _EAX = v3 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v14 = sub_1002436D(v3, a1, v4);
  *(_DWORD *)(v4 + 12) = v14;
  *(_DWORD *)v4 = *((_DWORD *)v14 + 13);
  sub_100261DF(a1);
  sub_10025148(a1);
  *(_DWORD *)(v4 + 100) = v4;
  v15 = sub_10029DCE();
  if ( !*((_DWORD *)v15 + 8) )
    sub_10026FFD(v3, a1);
  v17 = *(_DWORD *)(*((_DWORD *)v15 + 8) + 64);
  *(_DWORD *)(v4 + 4) &= 0xFFFFFFFu;
  *(_DWORD *)(v4 + 128) = v17;
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10025881) --------------------------------------------------------
int __userpurge sub_10025881<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_10055A58;
  return v4;
}
// 10055A58: using guessed type int (__stdcall *off_10055A58)(char);

//----- (1002589C) --------------------------------------------------------
int __userpurge sub_1002589C<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_10055A1C;
  return v4;
}
// 10055A1C: using guessed type int (__stdcall *off_10055A1C)(char);

//----- (100258C7) --------------------------------------------------------
int __thiscall sub_100258C7(int this)
{
  int result; // eax@2

  if ( *(_DWORD *)(this + 8) )
    result = sub_1002401B(*(LPVOID *)(this + 8));
  return result;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (100258E1) --------------------------------------------------------
int __usercall sub_100258E1<eax>(int a1<ebp>)
{
  char v1; // bl@1
  int v2; // edi@1
  int v3; // ecx@1
  int v4; // ecx@3
  int v5; // esi@4
  void *v6; // esi@5
  int v7; // esi@7

  sub_1002D0B8();
  v2 = v3;
  *(_DWORD *)(a1 - 16) = v3;
  v1 = 0;
  *(_DWORD *)(a1 - 4) = 0;
  if ( !sub_1002620F(v3) )
  {
    v1 = sub_1002698D(v2, v2, 0) == 0;
    if ( *(_DWORD *)(v2 + 100) == v2 )
    {
      v4 = *(_DWORD *)(v2 + 104);
      if ( v4 )
      {
        do
        {
          v5 = *(_DWORD *)(v4 + 104);
          sub_10026328(v4, a1);
          v4 = v5;
        }
        while ( v5 );
      }
    }
  }
  v6 = *(void **)(v2 + 108);
  if ( v6 )
  {
    sub_100258C7(*(_DWORD *)(v2 + 108));
    sub_1002404A(v6);
  }
  v7 = *(_DWORD *)(v2 + 24) & 0xFFFFFFFC;
  if ( *(_DWORD *)(v2 + 24) & 0xFFFFFFFC )
  {
    if ( v7 != 12 )
    {
      sub_100234E2(*(_DWORD *)(v2 + 24) & 0xFFFFFFFC);
      sub_1002404A((LPVOID)v7);
    }
  }
  if ( sub_100013B0(*(_DWORD *)(v2 + 8)) )
    sub_10001320(*(void **)(v2 + 8));
  if ( v1 )
  {
    sub_100249D0(a1 - 28);
    sub_1002D02B(a1 - 28, (int)&unk_1006008C);
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_10024C22(a1);
  return sub_1002D086(16);
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1002599B) --------------------------------------------------------
void *__userpurge sub_1002599B<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1
  int v4; // ST00_4@1

  v3 = (void *)a1;
  v4 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = &off_10055B28;
  sub_1002563B(a2, v4);
  if ( a3 & 1 )
    sub_1002404A(v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10055B28: using guessed type int (__stdcall *off_10055B28)(char);

//----- (100259C4) --------------------------------------------------------
int __userpurge sub_100259C4<eax>(int a1<ebp>, int a2)
{
  void *v2; // esi@1
  void *v3; // ecx@1
  char v4; // zf@1

  sub_1002D0B8();
  v2 = v3;
  *(_DWORD *)(a1 - 16) = v3;
  *(_DWORD *)(a1 - 4) = 0;
  sub_100258E1(a1);
  v4 = (*(_BYTE *)(a1 + 8) & 1) == 0;
  *(_DWORD *)v2 = &off_10055B10;
  if ( !v4 )
    sub_1002404A(v2);
  return sub_1002D086(4);
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10055B10: using guessed type int (__stdcall *off_10055B10)(char);

//----- (100259FE) --------------------------------------------------------
int __thiscall sub_100259FE(void *this, char a2, char a3)
{
  void *v4; // esi@1

  v4 = this;
  sub_1002784B(this);
  return sub_10025AF2((unsigned int *)v4 + 32, (int)&a2, (int)&a3);
}

//----- (10025A21) --------------------------------------------------------
int __thiscall sub_10025A21(unsigned int *this, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // eax@1

  v4 = (int)this;
  v5 = sub_1002A812(a2, *this);
  result = sub_1002AE75(v4, a2, v5);
  if ( result )
  {
    if ( a3 )
      *(_DWORD *)a3 = *(_DWORD *)(result + 8);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10025A57) --------------------------------------------------------
char __thiscall sub_10025A57(unsigned int *this, int a2, int a3)
{
  int v3; // eax@1
  int v4; // esi@1
  int v5; // eax@1
  char result; // al@4

  v4 = (int)this;
  v5 = sub_1002A812(a2, *this);
  v3 = sub_10025BC8(v4, a2, v5);
  if ( v3 )
  {
    if ( a3 )
      *(_DWORD *)a3 = *(_DWORD *)(v3 + 8);
    sub_1002404A((LPVOID)v3);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10025A96) --------------------------------------------------------
int __thiscall sub_10025A96(int this, char a2)
{
  int v2; // eax@1
  int ebp0; // ebp@0
  unsigned int *v4; // edi@1
  int v5; // esi@2
  int v7; // [sp+8h] [bp-4h]@6

  v4 = (unsigned int *)(this + 128);
  v2 = sub_10025A21((unsigned int *)(this + 128), (int)&a2, 0);
  if ( v2 )
    v5 = *(_DWORD *)(v2 + 8);
  else
    v5 = 0;
  if ( v5 )
  {
    if ( (*(_DWORD *)(v5 + 120) >> 1) & 1 )
    {
      v7 = *(_DWORD *)(v5 + 100);
      sub_10025A57(v4, (int)&v7, 0);
      sub_100258E1(ebp0);
      sub_1002404A((LPVOID)v5);
      v5 = 0;
    }
  }
  return v5;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10025AF2) --------------------------------------------------------
int __thiscall sub_10025AF2(unsigned int *this, int a2, int a3)
{
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@2
  int v8; // edx@2
  int result; // eax@5

  v6 = (int)this;
  v5 = sub_1002A812(a2, *this);
  if ( sub_1002AE75(v6, a2, v5) )
  {
    result = 0;
  }
  else
  {
    v7 = sub_10027EB3(v3, v4, v5, a2, 12);
    v8 = v7;
    if ( v7 )
    {
      *(_DWORD *)v7 = 0;
      *(_DWORD *)(v7 + 4) = *(_DWORD *)a2;
      *(_DWORD *)(v7 + 8) = *(_DWORD *)a3;
    }
    else
    {
      v8 = 0;
    }
    result = v8;
    *(_DWORD *)v8 = *(_DWORD *)(*(_DWORD *)(v6 + 8) + 4 * v5);
    *(_DWORD *)(*(_DWORD *)(v6 + 8) + 4 * v5) = v8;
    ++*(_DWORD *)(v6 + 4);
  }
  return result;
}

//----- (10025B56) --------------------------------------------------------
char __thiscall sub_10025B56(int this, int a2)
{
  int v2; // ebx@1
  int v4; // edi@4
  signed __int64 v6; // qax@4
  int v7; // esi@4
  void *v8; // ST00_4@4

  v2 = this;
  if ( *(_DWORD *)(this + 4) >= *(_DWORD *)this )
  {
    if ( *(_DWORD *)(this + 4) >= 1024 )
    {
      *(_BYTE *)(this + 12) = 1;
      return 0;
    }
    v4 = *(_DWORD *)this + 8;
    _ECX = 0;
    v6 = 4i64 * (unsigned int)v4;
    __asm { seto    cl }
    v7 = sub_10021CF0(SHIDWORD(v6), v6 | -_ECX, v2, v4, v6 | -_ECX);
    sub_1002C950((void *)v7, *(const void **)(v2 + 8), 4 * *(_DWORD *)v2);
    v8 = *(void **)(v2 + 8);
    *(_DWORD *)v2 = v4;
    sub_1002401B(v8);
    *(_DWORD *)(v2 + 8) = v7;
  }
  *(_DWORD *)(*(_DWORD *)(v2 + 8) + 4 * *(_DWORD *)(v2 + 4)++) = a2;
  return 1;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (10025BC8) --------------------------------------------------------
int __thiscall sub_10025BC8(int this, int a2, int a3)
{
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  int result; // eax@4

  v5 = this;
  v6 = 0;
  v4 = *(_DWORD *)(this + 8);
  v3 = *(_DWORD *)(v4 + 4 * a3);
  if ( v3 )
  {
    while ( *(_DWORD *)(v3 + 4) != *(_DWORD *)a2 )
    {
      v6 = v3;
      v3 = *(_DWORD *)v3;
      if ( !v3 )
        goto LABEL_4;
    }
    if ( v6 )
      *(_DWORD *)v6 = *(_DWORD *)v3;
    else
      *(_DWORD *)(v4 + 4 * a3) = *(_DWORD *)v3;
    --*(_DWORD *)(v5 + 4);
    result = v3;
  }
  else
  {
LABEL_4:
    result = 0;
  }
  return result;
}

//----- (10025C10) --------------------------------------------------------
int __thiscall sub_10025C10(int this, char a2)
{
  int v2; // ebx@1
  int ebp0; // ebp@0
  int v4; // esi@1
  int v5; // edi@2
  unsigned int v6; // eax@8
  int v7; // eax@9
  int v8; // eax@11
  int v9; // ecx@11
  int v10; // eax@13
  int result; // eax@25
  int v12; // [sp+Ch] [bp-Ch]@1
  int v13; // [sp+14h] [bp-4h]@1

  v4 = this;
  v2 = *(_DWORD *)(this + 108);
  v13 = (int)sub_10029DCE();
  v12 = *(_DWORD *)(v4 + 108);
  if ( sub_10026222(v4) )
    v5 = 0;
  else
    v5 = *(_DWORD *)(*(_DWORD *)(v4 + 100) + 104);
  if ( v2 && *(_BYTE *)(v2 + 12) )
  {
    sub_10025D3D((void *)v4, v13);
    *(_BYTE *)(v2 + 12) = 0;
  }
  else
  {
    while ( *(_DWORD *)(v4 + 132) > 0 )
    {
      v6 = *(_DWORD *)(v4 + 132);
      if ( v6 <= 2 )
      {
        v7 = *(_DWORD *)(v4 + 4 * v6 + 108);
      }
      else
      {
        --*(_DWORD *)(v2 + 4);
        v7 = *(_DWORD *)(*(_DWORD *)(v2 + 8) + 4 * *(_DWORD *)(v2 + 4));
      }
      --*(_DWORD *)(v4 + 132);
      v8 = sub_10027C3F(v13, v7);
      v9 = v8;
      if ( !v8 )
        break;
      if ( v8 != 1 )
      {
        v10 = *(_DWORD *)(v13 + 156);
        if ( *(_BYTE *)(v13 + 76) )
          ++*(_DWORD *)(v10 + 12);
        else
          ++*(_DWORD *)(v10 + 96);
        *(_DWORD *)(v9 + 8) = 0;
        sub_1002627F((void *)v4, v9);
      }
    }
  }
  LOBYTE(v2) = a2;
  while ( 1 )
  {
    if ( a2 || *(_DWORD *)(v4 + 16) > 0 || sub_1002620F(v4) || v5 )
      sub_10025E65(*(void **)(v4 + 100), v2, v5, 0, v5);
    sub_100260C0(ebp0, v5);
    result = sub_10026222(v4) ? 0 : *(_DWORD *)(*(_DWORD *)(v4 + 100) + 104);
    if ( v5 == result )
      break;
    v5 = result;
  }
  *(_DWORD *)(v4 + 132) = 0;
  if ( v12 )
    *(_DWORD *)(v12 + 4) = 0;
  if ( !a2 )
    result = sub_10026399((void *)v4, v5);
  return result;
}

//----- (10025D3D) --------------------------------------------------------
int __thiscall sub_10025D3D(void *this, int a2)
{
  int result; // eax@1
  LPVOID v3; // eax@2
  int v4; // ecx@2
  char v5; // zf@2
  void *v6; // [sp+0h] [bp-8h]@1
  int v7; // [sp+4h] [bp-4h]@1

  v7 = 0;
  v6 = this;
  result = sub_100278C7(
             (int (__cdecl *)(_DWORD, _DWORD))sub_10026066,
             (int)&v6,
             (int (__cdecl *)(_DWORD, _DWORD))sub_10026974);
  if ( v7 )
  {
    v3 = sub_10029DCE();
    v5 = *((_BYTE *)v3 + 76) == 0;
    v4 = *((_DWORD *)v3 + 39);
    result = v7;
    if ( v5 )
      *(_DWORD *)(v4 + 96) += v7;
    else
      *(_DWORD *)(v4 + 12) += v7;
  }
  return result;
}

//----- (10025D85) --------------------------------------------------------
int __usercall sub_10025D85<eax>(int a1<ebp>, int a2<ebx>, int a3<edi>)
{
  char v3; // bl@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ecx@1
  int v7; // eax@6
  int v8; // edx@8
  int v9; // ecx@8
  int v10; // eax@9

  sub_1002D0B8();
  v5 = v6;
  v4 = (int)sub_1002436D(a2, a1, a3);
  v3 = 0;
  if ( !*(_DWORD *)(v4 + 32) )
    sub_10026FFD(0, a1);
  if ( v4 != *(_DWORD *)(v5 + 12) || *(_DWORD *)(*(_DWORD *)(v4 + 32) + 64) != *(_DWORD *)(v5 + 128) )
  {
    v7 = sub_10027273(v4);
    if ( !v7 || *(_DWORD *)(v7 + 100) != v5 )
    {
      if ( !sub_10025A96(v4, v5) )
      {
        v10 = sub_10027EB3(v8, v9, 0, v4, 144);
        *(_DWORD *)(a1 - 16) = v10;
        *(_DWORD *)(a1 - 4) = 0;
        if ( v10 )
          v3 = sub_100256C1(0, a1, v5, 1);
        *(_DWORD *)(a1 - 4) = -1;
        sub_100259FE((void *)v4, v5, v3);
      }
    }
  }
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10025E11) --------------------------------------------------------
char __usercall sub_10025E11<al>(int a1<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>)
{
  int v4; // esi@1
  char result; // al@3
  int v6; // ecx@4
  int v14; // [sp-4h] [bp-8h]@5

  v4 = a1;
  if ( !*(_DWORD *)(a1 + 12) )
    *(_DWORD *)(a1 + 12) = sub_1002436D(a2, a3, a4);
  result = sub_1003720D(v4);
  if ( result )
  {
    v6 = *(_DWORD *)(v4 + 12);
    if ( 16 * *(_DWORD *)(v4 + 4) >> 4 < 0 )
    {
      _EAX = v6 + 120;
      _ECX = 1;
      __asm { lock xadd [eax], ecx }
      v14 = 2;
    }
    else
    {
      sub_10026DF4(v6, 16 * *(_DWORD *)(v4 + 4) >> 4);
      v14 = 3;
    }
    sub_100371BF(v4, v14);
    result = sub_10026E93(a3, v4);
  }
  return result;
}

//----- (10025E65) --------------------------------------------------------
char __userpurge sub_10025E65<al>(void *this<ecx>, int ebx0<ebx>, int edi0<edi>, int a2, int a3)
{
  char result; // al@1
  int ebp0; // ebp@0
  int v7; // edi@1
  int v8; // esi@1
  int v9; // edi@4
  int v11; // edi@6
  int v13; // [sp+8h] [bp-4h]@12

  v8 = (int)this;
  v7 = sub_10025D85(ebp0, ebx0, edi0);
  result = sub_1002693A(v8, 1);
  if ( result )
  {
    if ( sub_10026222(v7) || v7 == v8 )
    {
      _EBX = v8 + 56;
      do
      {
        while ( 1 )
        {
          v11 = *(_DWORD *)_EBX;
          if ( *(_DWORD *)_EBX != 1 )
          {
            if ( v11 != 5 )
              break;
          }
          v13 = *(_DWORD *)(v8 + 12);
          sub_10026DF4(v13, 16 * *(_DWORD *)(v8 + 4) >> 4);
          if ( v11 == 5 )
            sub_10025D3D((void *)v8, v13);
          *(_DWORD *)_EBX = 4;
        }
        _ECX = 3;
        __asm { lock cmpxchg [ebx], ecx }
      }
      while ( v11 );
      v9 = a2;
      sub_10025FD2(ebp0, a2, 1);
    }
    else
    {
      v9 = a2;
      sub_10025F31(v8, a2);
    }
    result = sub_10025F12(v9, a3);
  }
  return result;
}

//----- (10025F04) --------------------------------------------------------
char __usercall sub_10025F04<al>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  return sub_10025E65(*(void **)(a1 + 100), a2, a3, 0, *(_DWORD *)(a1 + 104));
}

//----- (10025F12) --------------------------------------------------------
int __stdcall sub_10025F12(int a1, int a2)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = a2; i; i = *(_DWORD *)(i + 104) )
    result = sub_10025F31(i, a1);
  return result;
}

//----- (10025F31) --------------------------------------------------------
int __thiscall sub_10025F31(int this, int a2)
{
  char v3; // bl@1
  int ebp0; // ebp@0
  int v5; // esi@1
  int result; // eax@2
  int v8; // [sp+Ch] [bp-10h]@12
  int v9; // [sp+10h] [bp-Ch]@1
  int v10; // [sp+14h] [bp-8h]@14
  int v11; // [sp+18h] [bp-4h]@1

  v3 = 0;
  v5 = *(_DWORD *)(this + 56);
  v11 = this;
  v9 = this + 56;
  _EDX = 0;
  do
  {
    result = v5;
    if ( v5 )
    {
      if ( v5 == 1 || (result = v5 - 5, v5 == 5) )
      {
        _EDX = 9;
        goto LABEL_8;
      }
    }
    else
    {
      _EDX = 3;
    }
    if ( !_EDX )
      return result;
LABEL_8:
    _ECX = v9;
    __asm { lock cmpxchg [ecx], edx }
    _EDX = v5;
  }
  while ( v5 != v5 );
  LOBYTE(v10) = 0;
  if ( v5 == 1 || v5 == 5 )
  {
    v3 = 1;
    LOBYTE(v10) = 1;
    v8 = *(_DWORD *)(v11 + 12);
    sub_10026DF4(v8, 16 * *(_DWORD *)(v11 + 4) >> 4);
    if ( v5 == 5 )
      sub_10025D3D((void *)v11, v8);
  }
  result = sub_10025FD2(ebp0, a2, v10);
  if ( v3 )
  {
    result = v9;
    *(_DWORD *)v9 = 4;
  }
  return result;
}

//----- (10025FD2) --------------------------------------------------------
int __userpurge sub_10025FD2<eax>(int a1<ebp>, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // esi@1
  void *v5; // ecx@1
  int v6; // edi@3
  char i; // zf@5

  sub_1002D0B8();
  v4 = (int)v5;
  v3 = (int)((char *)v5 + 28);
  *(_DWORD *)(a1 - 20) = (char *)v5 + 28;
  v5 = (char *)v5 + 32;
  *(_DWORD *)(a1 - 16) = v5;
  sub_10024528(v5);
  *(_DWORD *)(a1 - 4) = 0;
  if ( *(_BYTE *)(a1 + 12) )
  {
LABEL_4:
    sub_10026E93(a1, v4);
    goto LABEL_5;
  }
  if ( *(_DWORD *)(v4 + 48) > 0 )
  {
    v6 = *(_DWORD *)v3;
    if ( *(_DWORD *)v3 )
      goto LABEL_8;
    goto LABEL_4;
  }
LABEL_5:
  v6 = *(_DWORD *)v3;
  for ( i = *(_DWORD *)v3 == 0; ; i = v6 == *(_DWORD *)v3 )
  {
    if ( i )
      v6 = 0;
    else
LABEL_8:
      v6 = *(_DWORD *)(v6 + 4);
    if ( !v6 )
      break;
    *(_DWORD *)(v6 + 24) = 1;
    sub_10026DF4(v6 - 92, -999);
    sub_10026E93(a1, 0);
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002468A();
  return sub_1002D086(8);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1002605A) --------------------------------------------------------
char __usercall sub_1002605A<al>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  return sub_10025F04(a4, a2, a3);
}

//----- (10026066) --------------------------------------------------------
bool __cdecl sub_10026066(int a1, int a2)
{
  return *(_DWORD *)(a1 + 8) == *(_DWORD *)a2;
}

//----- (1002607B) --------------------------------------------------------
int __cdecl sub_1002607B(void *a2)
{
  return sub_10001320(a2);
}

//----- (10026087) --------------------------------------------------------
int __thiscall sub_10026087(int this)
{
  int v2; // esi@1
  int result; // eax@3

  v2 = this;
  _EDI = this + 20;
  if ( *(_DWORD *)(this + 20) <= -2147483647 )
    sub_1002618E(this);
  _EAX = 1;
  __asm { lock xadd [edi], eax }
  result = _EAX + 1;
  if ( !result )
    result = sub_10024F1C((void *)(v2 + 28));
  return result;
}

//----- (100260B5) --------------------------------------------------------
int __thiscall sub_100260B5(void *this)
{
  int result; // eax@2

  if ( this )
    result = (**(int (__stdcall ***)(_DWORD))this)(1);
  return result;
}

//----- (100260C0) --------------------------------------------------------
int __userpurge sub_100260C0<eax>(int a1<ebp>, int a2)
{
  int v2; // eax@1
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // esi@1
  unsigned int v8; // eax@4
  int v9; // eax@5
  int v10; // edx@10
  signed int v11; // ecx@10
  int v12; // esi@10
  int v13; // ecx@12
  signed int v15; // [sp-4h] [bp-4h]@1

  v15 = 16;
  sub_1002D0EB();
  v5 = v4;
  v6 = *(_DWORD *)(a1 + 8);
  v2 = v6;
  v7 = 0;
  if ( !v6 )
    goto LABEL_17;
  do
  {
    v2 = *(_DWORD *)(v2 + 104);
    ++v7;
  }
  while ( v2 );
  if ( v7 <= 0 )
  {
LABEL_17:
    sub_10025249(a1, v4, v6, -1);
    return sub_1002D09A(v13);
  }
  *(_DWORD *)(a1 - 28) = &off_10055B28;
  *(_DWORD *)(a1 - 24) = 0;
  *(_DWORD *)(a1 - 20) = 0;
  v8 = 4 * v7 + 12;
  *(_DWORD *)(a1 - 4) = 0;
  if ( v8 > 0x400 )
  {
    v9 = sub_10028264(v3, 0, v4, v6, 4 * v7 + 12);
    if ( v9 )
    {
      *(_DWORD *)v9 = 56797;
      goto LABEL_9;
    }
  }
  else
  {
    sub_10031E40(v8, 0, v15);
    v9 = (int)&v15;
    if ( &v15 )
    {
      v15 = 52428;
LABEL_9:
      v9 += 8;
      goto LABEL_10;
    }
  }
LABEL_10:
  v10 = sub_100250A5(v9);
  *(_DWORD *)v10 = *(_DWORD *)(v5 + 100) + 60;
  v11 = 1;
  v12 = v7 + 1;
  if ( v12 > 1 )
  {
    do
    {
      *(_DWORD *)(v10 + 4 * v11) = v6 + 60;
      v6 = *(_DWORD *)(v6 + 104);
      ++v11;
    }
    while ( v11 < v12 );
  }
  sub_1002531E(a1);
  sub_1002563B(v5, *(_DWORD *)(a1 - 24));
  return sub_1002D09A(v13);
}
// 100250A5: using guessed type _DWORD __stdcall sub_100250A5(_DWORD);
// 1002D09A: using guessed type int __thiscall sub_1002D09A(_DWORD);
// 10055B28: using guessed type int (__stdcall *off_10055B28)(char);

//----- (1002618A) --------------------------------------------------------
int __thiscall sub_1002618A(void *this)
{
  return (int)((char *)this + 28);
}

//----- (1002618E) --------------------------------------------------------
char __thiscall sub_1002618E(int this)
{
  int v3; // eax@3

  _ESI = this + 20;
  _EDX = -2147483647;
  __asm { lock cmpxchg [esi], edx }
  if ( this != -28 )
    *(_DWORD *)(this + 28) = 0;
  v3 = *(_DWORD *)_ESI;
  *(_DWORD *)_ESI = 0;
  return v3;
}

//----- (100261DF) --------------------------------------------------------
int __usercall sub_100261DF<eax>(int a1<ebp>)
{
  void *v1; // ecx@1
  int v2; // ecx@1
  char v3; // zf@1

  sub_1002D0B8();
  *(_DWORD *)(a1 - 16) = v2;
  *(_DWORD *)(v2 + 48) = 0;
  *(_DWORD *)(v2 + 52) = 0;
  *(_DWORD *)(v2 + 124) = 0;
  v3 = v2 == -28;
  v1 = (void *)(v2 + 28);
  *(_DWORD *)(a1 - 20) = v1;
  *(_DWORD *)(a1 - 4) = 0;
  if ( !v3 )
    sub_10028DDC(v1);
  return sub_1002D086(8);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1002620F) --------------------------------------------------------
bool __thiscall sub_1002620F(int this)
{
  return *(_DWORD *)(this + 100) != this && !(*(_DWORD *)(this + 120) & 1);
}

//----- (10026222) --------------------------------------------------------
bool __thiscall sub_10026222(int this)
{
  return *(_DWORD *)(this + 100) != this && *(_DWORD *)(this + 120) & 1;
}

//----- (10026235) --------------------------------------------------------
bool __thiscall sub_10026235(int this)
{
  return *(_DWORD *)(*(_DWORD *)(this + 100) + 52) != 0;
}

//----- (10026243) --------------------------------------------------------
int __thiscall sub_10026243(int this)
{
  return (*(_DWORD *)(this + 120) >> 1) & 1;
}

//----- (1002624C) --------------------------------------------------------
int __usercall sub_1002624C<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // eax@1
  int v4; // edx@1
  int v5; // ecx@1

  sub_1002D0B8();
  v3 = sub_10027EB3(v4, v5, a1, a3, 152);
  *(_DWORD *)(a2 - 16) = v3;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v3 )
    sub_10025659(a2, *(_DWORD *)(a2 + 8));
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1002627F) --------------------------------------------------------
int __thiscall sub_1002627F(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1
  int result; // eax@3
  int v5; // ebx@3
  int (__cdecl *v6)(_DWORD); // edi@3

  v3 = this;
  if ( *(_BYTE *)(a2 + 16) )
    sub_10036CEA(a2);
  v6 = (int (__cdecl *)(_DWORD))*((_DWORD *)v3 + 34);
  v5 = *((_DWORD *)v3 + 35);
  result = (int)((char *)v3 + 16);
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  if ( _ECX == 1 )
    result = sub_10025148(ebp0);
  if ( v6 )
    result = v6(v5);
  return result;
}

//----- (100262C8) --------------------------------------------------------
int __usercall sub_100262C8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>)
{
  int result; // eax@1

  result = a1 + 16;
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  if ( _EDX == 0 )
  {
    sub_10025249(a3, a2, a4, -1);
    JUMPOUT(*(unsigned int *)loc_100250E8);
  }
  return result;
}
// 100250E8: using guessed type int __stdcall loc_100250E8(int);

//----- (100262EE) --------------------------------------------------------
int __thiscall sub_100262EE(int this)
{
  return *(_DWORD *)(this + 100);
}

//----- (100262F2) --------------------------------------------------------
int __thiscall sub_100262F2(int this)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = this;
  sub_10037235(*(_DWORD *)(this + 100));
  _ECX = 1073741824;
  result = *(_DWORD *)(v2 + 100) + 52;
  __asm { lock or [eax], ecx }
  return result;
}

//----- (1002630D) --------------------------------------------------------
int __usercall sub_1002630D<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  int result; // eax@1
  int v4; // esi@1

  v4 = a1;
  sub_10037260(a2, a3);
  _ECX = -2147483648;
  result = *(_DWORD *)(v4 + 100) + 52;
  __asm { lock or [eax], ecx }
  return result;
}

//----- (10026328) --------------------------------------------------------
int __usercall sub_10026328<eax>(int a1<ecx>, int a2<ebp>)
{
  int v2; // ecx@1
  void *v4; // esi@1
  int result; // eax@2

  v4 = (void *)a1;
  _EDI = a1 + 120;
  v2 = *(_DWORD *)(a1 + 120);
  if ( v2 & 2 )
  {
LABEL_4:
    sub_100258E1(a2);
    result = sub_1002404A(v4);
  }
  else
  {
    while ( 1 )
    {
      _EDX = v2 | 2;
      result = v2;
      __asm { lock cmpxchg [edi], edx }
      if ( v2 == v2 )
        break;
      if ( v2 & 2 )
        goto LABEL_4;
    }
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1002635C) --------------------------------------------------------
int __usercall sub_1002635C<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@2
  int v3; // ST10_4@2

  if ( dword_100690B4 )
  {
    v2 = sub_1002C373(dword_100690B4);
    ((void (__thiscall *)(int))v2)(v3);
  }
  if ( IsProcessorFeaturePresent(0x17u) )
    __asm { int     29h             ; DOS 2+ internal - FAST PUTCHAR }
  sub_10036B2D(a1, a2, 1073741845, 3, 1073741845, 1);
  return sub_10031354(0x40000015u);
}
// 100690B4: using guessed type int dword_100690B4;

//----- (10026399) --------------------------------------------------------
int __thiscall sub_10026399(void *this, int a2)
{
  int ebp0; // ebp@0
  int v3; // edi@1
  int v4; // esi@1
  LPVOID v5; // eax@2
  int v6; // ecx@2
  int v8; // edx@3
  int result; // eax@14
  int v12; // ecx@23
  char v13; // [sp+Ch] [bp-24h]@25
  int v14; // [sp+14h] [bp-1Ch]@24
  BOOL (__cdecl *v15)(); // [sp+18h] [bp-18h]@24
  char v16; // [sp+1Ch] [bp-14h]@6
  int v17; // [sp+24h] [bp-Ch]@5
  BOOL (__cdecl *v18)(); // [sp+28h] [bp-8h]@5
  int v19; // [sp+2Ch] [bp-4h]@2
  int v20; // [sp+38h] [bp+8h]@2

  v3 = a2;
  v4 = (int)this;
  while ( 2 )
  {
    v5 = sub_10029DCE();
    v6 = *(_DWORD *)(v4 + 12);
    v20 = (int)v5;
    v19 = *(_DWORD *)(v4 + 12);
    _EBX = v4 + 56;
LABEL_3:
    v8 = *(_DWORD *)_EBX;
    while ( 1 )
    {
      if ( v8 == 9 )
      {
        v17 = 0;
        v18 = sub_1002C66E;
        if ( *(_DWORD *)_EBX == 9 )
        {
          do
            sub_1001FF20((int)&v16);
          while ( *(_DWORD *)_EBX == 9 );
          v5 = (LPVOID)v20;
          v6 = v19;
        }
        goto LABEL_3;
      }
      if ( v5 != (LPVOID)v6 )
      {
        _ECX = 0;
        __asm { lock cmpxchg [ebx], ecx }
        goto LABEL_13;
      }
      _ECX = 0;
      __asm { lock cmpxchg [ebx], ecx }
      if ( v8 == v8 )
        break;
      v6 = v19;
      v5 = (LPVOID)v20;
    }
    if ( v8 == 4 )
      sub_10026E61(v20, 16 * *(_DWORD *)(v4 + 4) >> 4);
    *(_DWORD *)(v4 + 4) |= 0xFFFFFFFu;
LABEL_13:
    if ( *(_DWORD *)(v4 + 100) == v4 )
    {
      while ( v3 )
      {
        if ( !((*(_DWORD *)(v3 + 120) >> 1) & 1) )
          sub_10026399(0);
        v3 = *(_DWORD *)(v3 + 104);
      }
      result = v4 + 52;
      v12 = *(_DWORD *)(v4 + 52);
      *(_DWORD *)(v4 + 52) = 0;
      if ( v12 < 0 )
      {
        v14 &= v3;
        v15 = sub_1002C66E;
        while ( *(_DWORD *)(v4 + 24) == 8 )
          sub_1001FF20((int)&v13);
        result = sub_100372CF(_EBX, ebp0);
      }
    }
    else
    {
      result = sub_1002620F(v4);
      if ( (_BYTE)result && v3 )
      {
        v4 = *(_DWORD *)(v4 + 100);
        continue;
      }
    }
    return result;
  }
}

//----- (10026494) --------------------------------------------------------
int __userpurge sub_10026494<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // edi@1
  int v8; // esi@1
  LPVOID v9; // eax@1
  int v10; // eax@1
  int v11; // edx@2
  int v12; // eax@4
  int v13; // eax@7
  int v16; // eax@15
  int i; // eax@17
  unsigned int v18; // ecx@22
  int v19; // eax@23
  int v20; // eax@23
  int v21; // eax@24
  int v22; // ecx@26
  int v23; // eax@27
  int v24; // eax@30
  int v27; // eax@34
  int v33; // [sp-8h] [bp-8h]@10

  sub_1002D121();
  v8 = sub_10025D85(a2, a1, a3);
  *(_DWORD *)(a2 - 24) = v8;
  v9 = sub_10029DCE();
  v6 = *(_DWORD *)(a2 + 8);
  v7 = (int)v9;
  v10 = *(_DWORD *)(v6 + 104);
  v5 = *(_DWORD *)(v7 + 52);
  *(_DWORD *)(a2 - 36) = v7;
  *(_DWORD *)(a2 - 28) = v10;
  *(_BYTE *)(a2 - 17) = 0;
  *(_DWORD *)v8 = v5;
  if ( v5 )
    v11 = (16 * *(_DWORD *)(v5 + 4) >> 4) + 1;
  else
    v11 = 0;
  *(_DWORD *)(v8 + 4) ^= (v11 ^ *(_DWORD *)(v8 + 4)) & 0xFFFFFFF;
  *(_DWORD *)(v7 + 52) = v8;
  v12 = *(_DWORD *)(v6 + 8);
  *(_DWORD *)(a2 - 32) = 0;
  if ( v12 )
  {
    if ( v12 != 2 )
    {
      if ( v12 != *(_DWORD *)(v7 + 56) )
      {
        v13 = sub_10027DED(v11, v12, 0, (int)sub_1002605A, v6, 1);
        v6 = *(_DWORD *)(a2 + 8);
        *(_DWORD *)(a2 - 32) = v13;
      }
    }
    sub_10027551(v7, *(_DWORD *)(v6 + 8), 16 * *(_DWORD *)(v8 + 4) >> 4);
  }
  *(_DWORD *)(a2 - 4) = 0;
  _EDX = 1;
  _ECX = v8 + 56;
  __asm { lock cmpxchg [ecx], edx }
  while ( *(_DWORD *)(a2 + 12) )
  {
    sub_100262C8(v8, 0, a2, v7);
    if ( !*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 8) + 100) + 52)
      && (*(_DWORD *)(v7 + 112) + *(_DWORD *)(v7 + 120) <= 0 || !sub_1002738C(v7, v8, 0)) )
    {
      (*(void (__cdecl **)(_DWORD))(*(_DWORD *)(a2 + 12) + 4))(*(_DWORD *)(a2 + 12));
      v16 = *(_DWORD *)(a2 + 12);
LABEL_16:
      *(_DWORD *)(v16 + 8) = 0;
      sub_1002627F((void *)v8, v16);
      *(_DWORD *)(a2 + 12) = 0;
      break;
    }
    sub_1002487E(a2 - 64);
    v33 = (int)&unk_100600FC;
    v21 = a2 - 64;
LABEL_10:
    sub_1002D02B(v21, v33);
  }
  for ( i = *(_DWORD *)(a2 + 8); ; *(_DWORD *)(a2 - 28) = *(_DWORD *)(i + 104) )
  {
    while ( 1 )
    {
      if ( *(_DWORD *)(v8 + 132) <= 0 )
        goto LABEL_30;
      if ( *(_DWORD *)(*(_DWORD *)(i + 100) + 52)
        || *(_DWORD *)(v7 + 112) + *(_DWORD *)(v7 + 120) > 0 && sub_1002738C(v7, v8, 0) )
      {
        sub_1002487E(a2 - 76);
        v33 = (int)&unk_100600FC;
        v21 = a2 - 76;
        goto LABEL_10;
      }
      v18 = *(_DWORD *)(v8 + 132);
      if ( v18 <= 2 )
      {
        v19 = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4 * v18 + 108);
      }
      else
      {
        v20 = *(_DWORD *)(v8 + 108);
        --*(_DWORD *)(v20 + 4);
        v19 = *(_DWORD *)(*(_DWORD *)(v20 + 8) + 4 * *(_DWORD *)(v20 + 4));
      }
      --*(_DWORD *)(v8 + 132);
      v22 = sub_10027C3F(v7, v19);
      *(_DWORD *)(a2 - 40) = v22;
      *(_DWORD *)(a2 + 12) = v22;
      if ( !v22 )
        break;
      i = *(_DWORD *)(a2 + 8);
      if ( v22 != 1 )
      {
        v27 = *(_DWORD *)(v7 + 156);
        if ( *(_BYTE *)(v7 + 76) )
          ++*(_DWORD *)(v27 + 12);
        else
          ++*(_DWORD *)(v27 + 96);
        (*(void (__cdecl **)(int))(v22 + 4))(v22);
        v16 = *(_DWORD *)(a2 - 40);
        goto LABEL_16;
      }
    }
    v23 = *(_DWORD *)(v8 + 108);
    if ( v23 )
      *(_DWORD *)(v23 + 4) = 0;
    *(_DWORD *)(v8 + 132) = 0;
LABEL_30:
    v24 = *(_DWORD *)(v8 + 108);
    if ( v24 )
    {
      if ( *(_BYTE *)(v24 + 12) )
      {
        *(_BYTE *)(a2 - 17) = 1;
        _EDX = 5;
        _ECX = v8 + 56;
        __asm { lock cmpxchg [ecx], edx }
      }
    }
    sub_100260C0(a2, *(_DWORD *)(a2 - 28));
    if ( *(_BYTE *)(a2 - 17) )
    {
      _EDX = 1;
      _ECX = v8 + 56;
      __asm { lock cmpxchg [ecx], edx }
    }
    i = *(_DWORD *)(a2 + 8);
    if ( *(_DWORD *)(a2 - 28) == *(_DWORD *)(i + 104) )
      break;
  }
  *(_DWORD *)(a2 - 4) = -1;
  if ( *(_DWORD *)(i + 8) )
  {
    sub_10027490(v7, *(_DWORD *)(i + 8));
    if ( *(_DWORD *)(a2 - 32) )
    {
      sub_10027CF1(a2, *(_DWORD *)(a2 - 32));
      sub_10001320(*(void **)(a2 - 32));
    }
  }
  *(_DWORD *)(v7 + 52) = *(_DWORD *)v8;
  if ( *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 8) + 100) + 52) )
  {
    sub_10025C10(v8, 0);
    if ( *(_DWORD *)(v7 + 112) + *(_DWORD *)(v7 + 120) > 0
      && sub_1002738C(v7, v8, *(_DWORD *)(*(_DWORD *)(a2 + 8) + 8) != 0) )
    {
      sub_1002487E(a2 - 100);
      v21 = a2 - 100;
      goto LABEL_10;
    }
  }
  else
  {
    sub_10026399((void *)v8, *(_DWORD *)(a2 - 28));
    if ( *(_DWORD *)(v7 + 112) + *(_DWORD *)(v7 + 120) > 0
      && sub_1002738C(v7, v8, *(_DWORD *)(*(_DWORD *)(a2 + 8) + 8) != 0) )
    {
      sub_1002487E(a2 - 112);
      v21 = a2 - 112;
      goto LABEL_10;
    }
  }
  return sub_1002D086(v33);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10026854) --------------------------------------------------------
int __userpurge sub_10026854<eax>(int a1<ebp>, int a2)
{
  int v2; // edi@1
  int v3; // edx@3
  int v4; // ecx@3
  int v5; // esi@3
  int v6; // edi@4
  int v7; // eax@5
  int v8; // eax@9
  int v9; // eax@9
  int v11; // eax@12

  sub_1002D121();
  v2 = *(_DWORD *)(a1 + 8);
  if ( *(_DWORD *)(v2 + 8) )
  {
    sub_10024922(a1 - 32);
    sub_1002D02B(a1 - 32, (int)&unk_100600C4);
  }
  *(_DWORD *)(a1 - 4) = 0;
  v5 = sub_10025D85(a1, 0, v2);
  *(_DWORD *)(v2 + 8) = v5;
  *(_DWORD *)(v2 + 12) = sub_10036EFA;
  v4 = *(_DWORD *)(v5 + 132);
  *(_DWORD *)(a1 - 20) = v4;
  *(_DWORD *)(v5 + 132) = v4 + 1;
  if ( (unsigned int)v4 < 2 )
  {
    sub_100262C8(v5, 0, a1, v2);
    v11 = (int)sub_10029DCE();
    *(_DWORD *)(v5 + 4 * *(_DWORD *)(a1 - 20) + 112) = sub_10027564(v11, 0, v2);
  }
  else
  {
    v6 = *(_DWORD *)(v5 + 108);
    if ( !v6 )
    {
      v7 = sub_10027EB3(v3, v4, 0, 0, 16);
      v6 = v7;
      if ( v7 )
      {
        *(_DWORD *)v7 = 0;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v7 + 8) = 0;
        *(_BYTE *)(v7 + 12) = 0;
      }
      else
      {
        v6 = 0;
      }
      *(_DWORD *)(v5 + 108) = v6;
    }
    sub_100262C8(v5, 0, a1, v6);
    v8 = (int)sub_10029DCE();
    v9 = sub_10027564(v8, 0, *(_DWORD *)(a1 + 8));
    if ( !sub_10025B56(v6, v9) )
      --*(_DWORD *)(v5 + 132);
  }
  return sub_1002D086(20);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10036EFA: using guessed type int sub_10036EFA();

//----- (10026921) --------------------------------------------------------
void __userpurge sub_10026921(int a1<ebp>, int a2)
{
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 8) + 16) )
    sub_10036CEA(*(_DWORD *)(a1 + 8));
  JUMPOUT(*(unsigned int *)loc_1002687B);
}
// 1002687B: using guessed type int __stdcall loc_1002687B(int);

//----- (1002693A) --------------------------------------------------------
char __thiscall sub_1002693A(int this, int a2)
{
  int v2; // edx@1
  char result; // al@4

  _ESI = this + 52;
  v2 = *(_DWORD *)(this + 52);
  if ( v2 & 0x3FFFFFFF )
  {
LABEL_4:
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      _ECX = a2 | v2 & 0xC0000000;
      __asm { lock cmpxchg [esi], ecx }
      if ( v2 == v2 )
        break;
      if ( v2 & 0x3FFFFFFF )
        goto LABEL_4;
    }
    result = 1;
  }
  return result;
}

//----- (10026974) --------------------------------------------------------
char __cdecl sub_10026974(int a1, int a2)
{
  void *v3; // ecx@1

  v3 = *(void **)(a1 + 8);
  ++*(_DWORD *)(a2 + 4);
  sub_1002627F(v3, a1);
  return 1;
}

//----- (1002698D) --------------------------------------------------------
bool __userpurge sub_1002698D<eax>(int a1<ecx>, int a2<edi>, char a3)
{
  char v3; // bl@1
  int v4; // esi@1
  int i; // eax@4

  v4 = a1;
  v3 = 0;
  if ( !sub_1002620F(a1) )
  {
    if ( sub_1002DE0F(0, a2) )
      goto LABEL_14;
    v3 = *(_DWORD *)(v4 + 16) > 0;
    if ( *(_DWORD *)(v4 + 100) == v4 )
    {
      for ( i = *(_DWORD *)(v4 + 104); i; i = *(_DWORD *)(i + 104) )
      {
        if ( *(_DWORD *)(i + 16) > 0 )
          v3 = 1;
      }
    }
    if ( v3 )
LABEL_14:
      sub_10025C10(v4, a3);
  }
  return v3 == 0;
}

//----- (100269E3) --------------------------------------------------------
int __usercall sub_100269E3<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v5; // esi@1

  v5 = a2;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = sub_10021CF0(a1, a2, a3, a4, 16);
  return v5;
}

//----- (100269FC) --------------------------------------------------------
#error "10026AB7: call analysis failed (funcsize=56)"

//----- (10026ABF) --------------------------------------------------------
int __thiscall sub_10026ABF(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002401B(*(LPVOID *)(this + 28));
  return sub_1002401B(*(LPVOID *)(v2 + 32));
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (10026AD6) --------------------------------------------------------
int __thiscall sub_10026AD6(int this)
{
  int v1; // ebx@1
  int v2; // edi@2
  int v3; // esi@3

  v1 = this;
  if ( *(_DWORD *)(this + 4) > 0 )
  {
    v2 = **(_DWORD **)(this + 8);
    if ( v2 )
    {
      do
      {
        v3 = *(_DWORD *)(v2 + 4);
        sub_1002401B(*(LPVOID *)v2);
        sub_1002404A((LPVOID)v2);
        v2 = v3;
      }
      while ( v3 );
    }
  }
  return sub_1002404A(*(LPVOID *)(v1 + 8));
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10026B16) --------------------------------------------------------
int __thiscall sub_10026B16(void *this)
{
  int result; // eax@1
  void *v2; // edi@1

  v2 = this;
  sub_10026AD6((int)((char *)this + 140));
  sub_1002C2C0((int)((char *)v2 + 128));
  result = sub_1002401B(*((LPVOID *)v2 + 34));
  *(_DWORD *)v2 = off_10055B30;
  return result;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 10055B30: using guessed type int (*off_10055B30[5])();

//----- (10026B55) --------------------------------------------------------
bool __thiscall sub_10026B55(int this, int a2)
{
  return !((*(_DWORD *)this ^ *(_DWORD *)a2) & 0xFFFFFFF) && *(_DWORD *)(this + 8) == *(_DWORD *)(a2 + 8);
}

//----- (10026B79) --------------------------------------------------------
int __thiscall sub_10026B79(int this, signed int a2)
{
  int v2; // eax@1
  signed int v3; // edx@1
  int v4; // eax@2
  int i; // edx@3

  v2 = *(_DWORD *)(this + 8);
  v3 = a2 >> 4;
  if ( a2 >> 4 >= 4 )
  {
    v4 = *(_DWORD *)(v2 + 12);
    for ( i = v3 - 3; i; --i )
      v4 = *(_DWORD *)(v4 + 4);
  }
  else
  {
    v4 = *(_DWORD *)(v2 + 4 * v3);
  }
  return *(_DWORD *)v4 + 8 * (a2 & 0xF);
}

//----- (10026BAD) --------------------------------------------------------
void *__thiscall sub_10026BAD(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_10055B30;
  if ( a2 & 1 )
    sub_1002404A(this);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10055B30: using guessed type int (*off_10055B30[5])();

//----- (10026BCD) --------------------------------------------------------
void *__thiscall sub_10026BCD(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_10026B16(this);
  if ( a2 & 1 )
    sub_1002404A(v2);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10026BEC) --------------------------------------------------------
int __thiscall sub_10026BEC(void *this, char a2)
{
  int v2; // esi@1

  v2 = (int)this;
  sub_10026ABF((int)((char *)this + 76));
  sub_1003A8E4(v2);
  if ( a2 & 1 )
    sub_1002404A((LPVOID)v2);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10026C15) --------------------------------------------------------
int __thiscall sub_10026C15(int this, int a2)
{
  signed int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // edx@3
  int v12; // ecx@11
  signed __int64 v15; // qax@11
  signed int v16; // ST0C_4@11
  int v17; // edx@11
  int v18; // ecx@11
  int v19; // eax@12
  int v28; // edx@17
  char v30; // [sp+Ch] [bp-20h]@22
  int v31; // [sp+14h] [bp-18h]@21
  BOOL (__cdecl *v32)(); // [sp+18h] [bp-14h]@21
  int v33; // [sp+1Ch] [bp-10h]@5
  int v34; // [sp+20h] [bp-Ch]@2
  int v35; // [sp+24h] [bp-8h]@1
  char v36; // [sp+2Bh] [bp-1h]@1

  v5 = this;
  v3 = *(_DWORD *)(this + 48);
  v36 = 0;
  v4 = 0;
  v35 = v3;
  v2 = 4;
  do
  {
    _EBX = v3 + 8;
    v34 = v3 + 8;
    if ( *(_DWORD *)(v3 + 8) >= -1 )
    {
      _EBX = *(_DWORD *)v3;
      v7 = 0;
      if ( *(_DWORD *)(v5 + 40) <= 0 )
      {
LABEL_7:
        _EBX = v34;
      }
      else
      {
        while ( *(_DWORD *)_EBX )
        {
          ++v7;
          _EBX += v2;
          if ( v7 >= *(_DWORD *)(v5 + 40) )
            goto LABEL_7;
        }
        _ECX = a2;
        *(_DWORD *)(a2 + 68) = v7 + v4;
        v33 = *(_DWORD *)(v5 + 64);
        __asm { lock cmpxchg [ebx], ecx }
        v4 += v7;
        v36 = 1;
        if ( v4 >= v33 )
        {
          _EAX = v5 + 64;
          _ECX = 1;
          __asm { lock xadd [eax], ecx }
        }
        _EBX = v34;
        _ECX = -1;
        __asm { lock cmpxchg [ebx], ecx }
      }
      v3 = v35;
    }
    if ( !v36 )
    {
      _ECX = -2;
      __asm { lock cmpxchg [ebx], ecx }
      v4 += *(_DWORD *)(v5 + 40);
      _EBX = v3 + 4;
      if ( !*(_DWORD *)(v3 + 4) )
      {
        _ECX = 1;
        __asm { lock cmpxchg [ebx], ecx }
        _ECX = 0;
        v15 = 4i64 * *(_DWORD *)(v5 + 40);
        __asm { seto    cl }
        v16 = 4 * *(_DWORD *)(v5 + 40);
        v33 = sub_10021CF0(SHIDWORD(v15), v15 | -_ECX, _EBX, v4, v15 | -_ECX);
        sub_10030CF0((void *)v33, 0, v16);
        v12 = sub_10027EB3(v17, v18, _EBX, v4, 12);
        if ( v12 )
        {
          v19 = v33;
          *(_DWORD *)(v12 + 4) = 0;
          *(_DWORD *)(v12 + 8) = -1;
          *(_DWORD *)v12 = v19;
        }
        else
        {
          v12 = 0;
        }
        v28 = *(_DWORD *)(v5 + 60);
        if ( v28 < *(_DWORD *)(v5 + 56) )
        {
          *(_DWORD *)(*(_DWORD *)(v5 + 52) + 4 * v28) = v12;
          ++*(_DWORD *)(v5 + 60);
        }
        *(_DWORD *)_EBX = v12;
        v3 = v35;
      }
      if ( *(_DWORD *)_EBX == 1 )
      {
        v31 = 0;
        v32 = sub_1002C66E;
        do
          sub_1001FF20((int)&v30);
        while ( *(_DWORD *)_EBX == 1 );
        v3 = v35;
      }
    }
    v3 = *(_DWORD *)(v3 + 4);
    v35 = v3;
    v2 = 4;
  }
  while ( !v36 );
  return v4;
}

//----- (10026D6E) --------------------------------------------------------
int __thiscall sub_10026D6E(void *this, int a2, char a3)
{
  int result; // eax@1
  void *v4; // edi@1

  v4 = this;
  result = sub_10026DCD((int)((char *)this + 80), a2 + 92);
  *(_BYTE *)(a2 + 77) = 1;
  if ( a3 )
  {
    result = (int)((char *)v4 + 100);
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
  }
  return result;
}

//----- (10026D9E) --------------------------------------------------------
int __thiscall sub_10026D9E(void *this, int a2)
{
  int result; // eax@1

  result = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(result + 4);
    *(_DWORD *)a2 = *(_DWORD *)this;
    **(_DWORD **)(*(_DWORD *)this + 4) = a2;
    result = *(_DWORD *)this;
    *(_DWORD *)(*(_DWORD *)this + 4) = a2;
  }
  else
  {
    *(_DWORD *)(a2 + 4) = a2;
    *(_DWORD *)a2 = a2;
  }
  *(_DWORD *)this = a2;
  return result;
}

//----- (10026DCD) --------------------------------------------------------
int __thiscall sub_10026DCD(int this, int a2)
{
  int v3; // edi@1

  v3 = this;
  sub_10024558((void *)(this + 4));
  sub_10026D9E((void *)v3, a2);
  return sub_10024692((void *)(v3 + 4));
}

//----- (10026DF4) --------------------------------------------------------
int __thiscall sub_10026DF4(int this, int a2)
{
  int result; // eax@1
  int v3; // edx@1
  int v5; // esi@1
  int v13; // eax@7
  int v14; // edx@10

  v5 = this;
  result = this + 112;
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  _EBX = this + 104;
  v3 = *(_DWORD *)(this + 104);
  while ( v3 == -1 || a2 <= v3 )
  {
    _ECX = a2;
    result = v3;
    __asm { lock cmpxchg [ebx], ecx }
    if ( v3 == v3 )
    {
      if ( *(_DWORD *)(v5 + 116) )
        v13 = -1;
      else
        v13 = a2;
      result = sub_1002720F(v5, v13);
      break;
    }
  }
  _ESI = v5 + 108;
  v14 = *(_DWORD *)_ESI;
  do
  {
    if ( v14 != -1 && a2 < v14 )
      break;
    _ECX = a2;
    result = v14;
    __asm { lock cmpxchg [esi], ecx }
  }
  while ( v14 != v14 );
  return result;
}

//----- (10026E61) --------------------------------------------------------
bool __thiscall sub_10026E61(int this, int a2)
{
  int v3; // edi@1

  v3 = this;
  _EBX = -1;
  _ESI = -1;
  _EDX = this + 104;
  __asm { lock cmpxchg [edx], esi }
  sub_100275E1(this);
  _EAX = v3 + 112;
  __asm { lock xadd [eax], ebx }
  return _EBX == 1;
}

//----- (10026E93) --------------------------------------------------------
int __userpurge sub_10026E93<eax>(int a1<ebp>, int a2)
{
  char i; // zf@1
  signed int v3; // edi@1
  int v4; // esi@1
  void *v5; // ecx@1
  int v6; // eax@3
  int v7; // edx@3
  int v8; // eax@5
  int v9; // ecx@7
  int v10; // ecx@9

  sub_1002D0B8();
  *(_DWORD *)(a1 - 16) = v5;
  v4 = (int)((char *)v5 + 80);
  *(_DWORD *)(a1 - 24) = (char *)v5 + 80;
  v5 = (char *)v5 + 84;
  *(_DWORD *)(a1 - 20) = v5;
  sub_10024528(v5);
  v3 = *(_DWORD *)v4;
  *(_DWORD *)(a1 - 4) = 0;
  for ( i = v3 == 0; ; i = v3 == *(_DWORD *)v4 )
  {
    v3 = i ? 0 : *(_DWORD *)(v3 + 4);
    if ( !v3 )
      break;
    if ( *(_DWORD *)(v3 + 24) )
      continue;
    v7 = *(_DWORD *)(v3 - 44);
    v6 = *(_DWORD *)(a1 + 8);
    if ( v7 == v6 )
    {
LABEL_11:
      *(_DWORD *)(v3 + 24) = 1;
      sub_10026DF4(v3 - 92, -999);
      sub_10026E93(0);
      continue;
    }
    if ( v6 )
    {
      v9 = 16 * *(_DWORD *)(v6 + 4) >> 4;
      if ( v9 == -1 )
        continue;
      v8 = 16 * *(_DWORD *)(v7 + 4) >> 4;
      if ( v8 <= v9 )
        continue;
    }
    else
    {
      v8 = 16 * *(_DWORD *)(v7 + 4) >> 4;
      if ( v8 == -1 )
        continue;
    }
    v10 = *(_DWORD *)(a1 - 16);
    if ( *(_DWORD *)(v10 + 60) == -1 || sub_100272A2(v10, v7, v8) )
      goto LABEL_11;
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002468A();
  return sub_1002D086(12);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10026F80) --------------------------------------------------------
bool __cdecl sub_10026F80(int a1)
{
  bool result; // eax@1

  result = sub_1002A7FD(*(_DWORD *)(a1 + 36));
  if ( !result )
  {
    sub_1002707C(*(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    *(_DWORD *)(a1 + 72) = 0;
  }
  return result;
}

//----- (10026F8C) --------------------------------------------------------
int __usercall sub_10026F8C<eax>(int a1<ecx>, int a2<ebp>)
{
  int v3; // esi@1
  int v4; // ST0C_4@1
  int v5; // eax@1

  v3 = a1;
  sub_10027673(a1, a2);
  v4 = *(_DWORD *)(v3 + 8);
  v5 = (*(int (**)(void))(**(_DWORD **)(v3 + 28) + 4))();
  return sub_10027BAF(2, 4, v5, v4);
}

//----- (10026FAD) --------------------------------------------------------
void __thiscall sub_10026FAD(void *this)
{
  int ebp0; // ebp@0
  int v2; // edi@1
  int v3; // esi@2
  int v4; // [sp+8h] [bp-4h]@1

  v4 = 0;
  v2 = (int)((char *)this + 128);
  while ( 1 )
  {
    v3 = sub_100273E8(v2, (int)&v4);
    if ( !v3 )
      break;
    do
    {
      sub_10026328(*(_DWORD *)(v3 + 8), ebp0);
      v3 = *(_DWORD *)v3;
    }
    while ( v3 );
    ++v4;
  }
  sub_1002C2C0(v2);
}

//----- (10026FEC) --------------------------------------------------------
BOOL __cdecl sub_10026FEC()
{
  return TlsSetValue(dwTlsIndex, 0);
}

//----- (10026FFD) --------------------------------------------------------
int __usercall sub_10026FFD<eax>(int a1<ebx>, int a2<ebp>)
{
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // eax@1
  PSINGLE_LIST_ENTRY v5; // eax@2
  int v6; // edx@2
  void *v7; // ecx@2
  int v8; // edi@2
  int v9; // eax@5

  sub_1002D0B8();
  v2 = v3;
  v4 = sub_1003839F(*(_DWORD *)(v3 + 24));
  *(_DWORD *)(v2 + 32) = v4;
  if ( !v4 )
  {
    v5 = InterlockedPopEntrySList((PSLIST_HEADER)(*(_DWORD *)(v2 + 24) + 88));
    v8 = 0;
    v7 = 0;
    if ( v5 )
      v7 = &v5[-6];
    *(_DWORD *)(v2 + 32) = v7;
    if ( v7 )
    {
      sub_100374E7(v7);
    }
    else
    {
      v9 = sub_10027EB3(v6, 0, a1, 0, 116);
      *(_DWORD *)(a2 - 16) = v9;
      *(_DWORD *)(a2 - 4) = 0;
      if ( v9 )
        v8 = sub_1003740B(a2);
      *(_DWORD *)(a2 - 4) = -1;
      *(_DWORD *)(v2 + 32) = v8;
    }
    sub_10026C15(*(_DWORD *)(v2 + 24) + 88, *(_DWORD *)(v2 + 32));
  }
  *(_DWORD *)(*(_DWORD *)(v2 + 32) + 72) = v2;
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1002707C) --------------------------------------------------------
int __stdcall sub_1002707C(int a1)
{
  int v1; // esi@1
  void *v2; // ecx@2
  int result; // eax@3

  v1 = a1;
  while ( v1 )
  {
    v2 = (void *)(v1 - 24);
    v1 = *(_DWORD *)v1;
    if ( v2 )
      result = sub_10026BEC(v2, 1);
  }
  return result;
}

//----- (100271BB) --------------------------------------------------------
void __cdecl sub_100271BB()
{
  JUMPOUT(*(int *)sub_100271C3);
}

//----- (100271C3) --------------------------------------------------------
int __usercall sub_100271C3<eax>(int a1<ebp>)
{
  return sub_10024692((void *)(*(_DWORD *)(a1 - 40) + 4));
}

//----- (100271CF) --------------------------------------------------------
void __usercall sub_100271CF(int a1<eax>, int a2<ebp>)
{
  LOBYTE(a1) = *(_BYTE *)(a2 - 26);
  *(_DWORD *)(a2 - 32) = a1;
  JUMPOUT(*(int *)sub_100271DA);
}

//----- (100271DA) --------------------------------------------------------
int __usercall sub_100271DA<eax>(int a1<ebp>, int a2<edi>)
{
  int result; // eax@2

  if ( *(_BYTE *)(a1 - 25) )
    result = sub_10024692((void *)(a2 + 84));
  return result;
}

//----- (100271E9) --------------------------------------------------------
int __thiscall sub_100271E9(int this)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 12) + 1;
  *(_DWORD *)(this + 12) = result;
  return result;
}

//----- (100271F1) --------------------------------------------------------
int __thiscall sub_100271F1(int this)
{
  int v1; // eax@1
  int result; // eax@1

  v1 = *(_DWORD *)(this + 16);
  ++*(_DWORD *)(this + 12);
  result = v1 + 1;
  *(_DWORD *)(this + 16) = result;
  return result;
}

//----- (100271FC) --------------------------------------------------------
int __thiscall sub_100271FC(int this)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 12) - 1;
  *(_DWORD *)(this + 12) = result;
  return result;
}

//----- (10027204) --------------------------------------------------------
int __thiscall sub_10027204(int this)
{
  int v1; // eax@1
  int result; // eax@1

  v1 = *(_DWORD *)(this + 16);
  --*(_DWORD *)(this + 12);
  result = v1 - 1;
  *(_DWORD *)(this + 16) = result;
  return result;
}

//----- (1002720F) --------------------------------------------------------
int __thiscall sub_1002720F(int this, int a2)
{
  int result; // eax@1
  int v3; // ebx@1
  signed int v4; // edi@1
  signed int i; // esi@1

  v3 = this;
  result = this + 140;
  v4 = *(_DWORD *)(this + 140);
  for ( i = 0; i < v4; result = v3 + 140 )
  {
    _ECX = sub_10026B79(result, i);
    if ( *(_DWORD *)(_ECX + 4) >= a2 )
    {
      if ( *(_DWORD *)(v3 + 60) == -1 || *(_DWORD *)(v3 + 60) <= a2 )
      {
        _EAX = 1;
        __asm { lock xadd [ecx], eax }
      }
    }
    ++i;
  }
  return result;
}

//----- (1002725B) --------------------------------------------------------
bool __thiscall sub_1002725B(int this)
{
  bool result; // eax@2

  if ( *(_DWORD *)(this + 16) )
    result = 2;
  else
    result = *(_DWORD *)(this + 12) > 0u;
  return result;
}

//----- (1002726F) --------------------------------------------------------
int __thiscall sub_1002726F(int this)
{
  return *(_DWORD *)(this + 8);
}

//----- (10027273) --------------------------------------------------------
int __thiscall sub_10027273(int this)
{
  return *(_DWORD *)(this + 124);
}

//----- (10027277) --------------------------------------------------------
int __thiscall sub_10027277(int this)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = *(_DWORD *)(this + 24);
  if ( v1 )
    result = *(_DWORD *)(v1 + 256);
  else
    result = 0;
  return result;
}

//----- (10027288) --------------------------------------------------------
int __thiscall sub_10027288(int this)
{
  int v1; // ecx@1
  int result; // eax@2

  v1 = *(_DWORD *)(this + 24);
  if ( v1 )
    result = (*(int (**)(void))(**(_DWORD **)(v1 + 256) + 4))();
  else
    result = -1;
  return result;
}

//----- (1002729E) --------------------------------------------------------
int __thiscall sub_1002729E(int this)
{
  return *(_DWORD *)(this + 28);
}

//----- (100272A2) --------------------------------------------------------
char __thiscall sub_100272A2(int this, int a2, int a3)
{
  int v3; // edi@1
  int v4; // eax@5
  int v5; // esi@5
  int v6; // ecx@7
  int v7; // ecx@8
  char v9; // al@16
  signed int v10; // eax@26

  v3 = this;
  if ( *(_DWORD *)(this + 112) <= 0 || *(_DWORD *)(this + 104) > a3 )
    return 0;
  if ( *(_DWORD *)(this + 60) == -1 || *(_DWORD *)(this + 104) >= *(_DWORD *)(this + 60) )
    return 1;
  v4 = *(_DWORD *)(this + 52);
  v5 = a2;
  if ( a2 != v4 || a3 != 16 * *(_DWORD *)(v4 + 4) >> 4 )
  {
    do
    {
      if ( v5 == *(_DWORD *)(v3 + 48) )
        break;
      if ( 16 * *(_DWORD *)(v5 + 4) >> 4 == a3 )
        break;
      v5 = sub_10027C8C(v5);
    }
    while ( v5 );
    while ( v5 )
    {
      if ( v5 == *(_DWORD *)(v3 + 48) || sub_100371E5(v5, 0) )
      {
        if ( v5 )
        {
          if ( v5 != *(_DWORD *)(v3 + 48) )
          {
            v10 = sub_100371E5(v5, 0);
            if ( v10 != 2 )
            {
              v7 = *(_DWORD *)(v10 + 8);
              return v7 != 0;
            }
          }
        }
        return 0;
      }
      v9 = (*(_DWORD *)(v5 + 4) >> 28) & 1;
      if ( v9 && *(_BYTE *)(v5 + 24) & 3 || !v9 && sub_10026235(v5) )
        return 1;
      v5 = sub_10027C8C(v5);
    }
    return 0;
  }
  v6 = *(_DWORD *)(this + 56);
  if ( v6 == 2 )
    return 0;
  v7 = *(_DWORD *)(v6 + 8);
  return v7 != 0;
}

//----- (1002738C) --------------------------------------------------------
char __thiscall sub_1002738C(int this, int a2, char a3)
{
  char v3; // bl@1
  int v4; // esi@1

  v4 = this;
  v3 = 0;
  if ( *(_DWORD *)(this + 112) > 0 && !sub_10027B62((void *)this, a2, a3)
    || *(_DWORD *)(v4 + 120) > 0 && sub_1003733F(a2) )
    v3 = 1;
  return v3;
}

//----- (100273C5) --------------------------------------------------------
int __thiscall sub_100273C5(int this, int a2)
{
  int v3; // edi@1

  v3 = this;
  sub_1002C615((void *)(this + 112));
  *(_DWORD *)(v3 + 72) = a2;
  return sub_1002C625((void *)(v3 + 112));
}

//----- (100273E8) --------------------------------------------------------
int __thiscall sub_100273E8(int this, int a2)
{
  int v2; // edx@1
  int v3; // eax@2
  int result; // eax@5

  v2 = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 >= *(_DWORD *)this )
  {
LABEL_5:
    result = 0;
  }
  else
  {
    v3 = *(_DWORD *)(this + 8) + 4 * v2;
    while ( !*(_DWORD *)v3 )
    {
      ++v2;
      v3 += 4;
      if ( v2 >= *(_DWORD *)this )
        goto LABEL_5;
    }
    *(_DWORD *)a2 = v2;
    result = *(_DWORD *)(*(_DWORD *)(this + 8) + 4 * v2);
  }
  return result;
}

//----- (10027419) --------------------------------------------------------
int __usercall sub_10027419<eax>(int a1<ecx>, int a2<ebp>)
{
  int v2; // edi@1
  int v3; // esi@2
  int v4; // ebx@3
  int result; // eax@6
  int v6; // ecx@9
  int v7; // ebx@9
  int v8; // edi@9
  int v9; // esi@9
  int v10; // ecx@9
  void *v11; // ecx@9
  int v12; // ecx@10
  int v13; // edx@10
  void *v14; // ecx@16

  v2 = a1 + 4;
  while ( 1 )
  {
    v3 = *(_DWORD *)v2-- - 1;
    if ( *(_DWORD *)a1 > v3 )
      break;
    v4 = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4 * (v3 & *(_DWORD *)(a1 + 8)));
    if ( v4 )
    {
      if ( !(v4 & 1) || (v4 &= 0xFFFFFFFEu, sub_1003AA40(*(_DWORD *)(a1 + 32) + 8 * (v3 & *(_DWORD *)(a1 + 8)), 0)) )
        result = v4;
      else
        result = 1;
      return result;
    }
  }
  *(_DWORD *)v2 = v3 + 1;
  sub_1002D0B8();
  v9 = v10;
  v11 = *(void **)(v10 + 16);
  *(_DWORD *)(a2 - 16) = v11;
  sub_1002C615(v11);
  v6 = 0;
  v8 = *(_DWORD *)(v9 + 4) - 1;
  *(_DWORD *)(a2 - 24) = 0;
  *(_DWORD *)(a2 - 20) = 0;
  *(_DWORD *)(v9 + 4) = v8;
  *(_DWORD *)(a2 - 4) = 0;
  LOBYTE(v7) = 0;
  if ( *(_DWORD *)v9 > v8 )
  {
    *(_DWORD *)(v9 + 4) = v8 + 1;
  }
  else
  {
    v12 = *(_DWORD *)(v9 + 32);
    v13 = v8 & *(_DWORD *)(v9 + 8);
    v7 = *(_DWORD *)(*(_DWORD *)(v9 + 28) + 4 * v13);
    *(_DWORD *)(a2 - 24) = *(_DWORD *)(v12 + 8 * v13);
    *(_DWORD *)(a2 - 20) = *(_DWORD *)(v12 + 8 * v13 + 4);
    v6 = 0;
  }
  if ( *(_DWORD *)v9 >= v8 )
  {
    *(_DWORD *)(v9 + 12) += *(_DWORD *)v9;
    *(_DWORD *)v9 = v6;
    *(_DWORD *)(v9 + 4) = v6;
    *(_DWORD *)(v9 + 24) = v6;
    *(_BYTE *)(v9 + 20) = v6;
  }
  if ( v7 & 1 )
    sub_1003AA40(a2 - 24, v6);
  v14 = *(void **)(a2 - 16);
  *(_DWORD *)(a2 - 4) = -1;
  sub_1002C625(v14);
  return sub_1002D086(12);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10027473) --------------------------------------------------------
int __thiscall sub_10027473(int this)
{
  int v2; // edi@1
  int v3; // esi@1

  v2 = this;
  v3 = *(_DWORD *)(this + 36);
  TlsSetValue(dwTlsIndex, *(LPVOID *)(this + 36));
  *(_DWORD *)(v2 + 36) = 0;
  return v3;
}

//----- (10027490) --------------------------------------------------------
int __thiscall sub_10027490(int this, int a2)
{
  int result; // eax@1
  int v3; // edi@1
  int v4; // esi@1

  v3 = this;
  result = sub_10027C8C(*(_DWORD *)(this + 52));
  v4 = result;
  if ( !result )
    goto LABEL_11;
  do
  {
    if ( v4 == *(_DWORD *)(v3 + 48) )
      break;
    result = sub_100371E5(v4, 0);
    if ( result )
      break;
    result = sub_10027C8C(v4);
    v4 = result;
  }
  while ( result );
  if ( v4 && v4 != *(_DWORD *)(v3 + 48) )
  {
    *(_DWORD *)(v3 + 56) = sub_100371E5(v4, 0);
    result = 16 * *(_DWORD *)(v4 + 4) >> 4;
    *(_DWORD *)(v3 + 60) = result;
  }
  else
  {
LABEL_11:
    *(_DWORD *)(v3 + 56) = 0;
    *(_DWORD *)(v3 + 60) = -1;
  }
  return result;
}

//----- (100274F1) --------------------------------------------------------
int __thiscall sub_100274F1(int this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int result; // eax@2

  v3 = *(_DWORD *)(this + 4);
  v2 = *(_DWORD *)(this + 8);
  if ( v3 >= v2 + *(_DWORD *)this )
  {
    result = sub_10027969((void *)this, a2, 0, 0);
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(this + 28) + 4 * (v3 & v2)) = a2;
    *(_DWORD *)(this + 4) = v3 + 1;
    result = v3 + *(_DWORD *)(this + 12);
  }
  return result;
}

//----- (10027537) --------------------------------------------------------
BOOL __thiscall sub_10027537(LPVOID lpTlsValue, int a2)
{
  *((_DWORD *)lpTlsValue + 9) = a2;
  return TlsSetValue(dwTlsIndex, lpTlsValue);
}

//----- (10027551) --------------------------------------------------------
int __thiscall sub_10027551(int this, int a2, int a3)
{
  int result; // eax@1

  *(_DWORD *)(this + 56) = a2;
  result = a3;
  *(_DWORD *)(this + 60) = a3;
  return result;
}

//----- (10027564) --------------------------------------------------------
int __userpurge sub_10027564<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int ebp0; // ebp@0
  int v4; // esi@1
  int v5; // edi@3
  int v6; // ST08_4@7

  v4 = a1;
  if ( !*(_DWORD *)(a1 + 32) )
    sub_10026FFD(a2, ebp0);
  v5 = sub_100274F1(*(_DWORD *)(v4 + 32) + 76, a3);
  if ( *(_BYTE *)(v4 + 76) )
    ++*(_DWORD *)(*(_DWORD *)(v4 + 156) + 8);
  else
    ++*(_DWORD *)(*(_DWORD *)(v4 + 156) + 92);
  if ( *(_DWORD *)(*(_DWORD *)(v4 + 28) + 428) - *(_DWORD *)(*(_DWORD *)(v4 + 28) + 432) > 0 )
    (*(void (__stdcall **)(_DWORD, _DWORD, int, _DWORD, _DWORD))(**(_DWORD **)(v4 + 28) + 56))(
      *(_DWORD *)(v4 + 24),
      0,
      v6,
      0,
      0);
  return v5;
}

//----- (100275E1) --------------------------------------------------------
char __thiscall sub_100275E1(int this)
{
  int v1; // ebx@1
  int v2; // edi@1
  int v3; // esi@1
  char v4; // al@3
  char result; // al@14
  int v9; // [sp+Ch] [bp-4h]@1

  v1 = this;
  v9 = this + 108;
  *(_DWORD *)(this + 108) = -1;
  v2 = *(_DWORD *)(this + 52);
  v3 = (*(_DWORD *)(this + 116) != 0 ? 0xFFFFFC1A : 0) - 1;
  while ( v2 && v2 != *(_DWORD *)(v1 + 48) )
  {
    v4 = (*(_DWORD *)(v2 + 4) >> 28) & 1;
    if ( v4 && *(_BYTE *)(v2 + 24) & 3 || !v4 && sub_10026235(v2) )
    {
      v3 = 16 * *(_DWORD *)(v2 + 4) >> 4;
      break;
    }
    v2 = sub_10027C8C(v2);
  }
  _EDI = v9;
  _ECX = v3;
  result = -1;
  __asm { lock cmpxchg [edi], ecx }
  return result;
}

//----- (10027668) --------------------------------------------------------
int __thiscall sub_10027668(void *this)
{
  int result; // eax@1

  _ECX = (int)((char *)this + 100);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (10027673) --------------------------------------------------------
int __usercall sub_10027673<eax>(int a1<ecx>, int a2<ebp>)
{
  int v2; // ecx@8
  int v4; // ST14_4@15
  int v5; // ST18_4@15
  int v6; // ST1C_4@15
  int v7; // ST20_4@15
  int v8; // ST24_4@15
  int v9; // ST28_4@15
  int v10; // ST2C_4@15
  int v11; // ST30_4@15
  int v12; // ST34_4@15
  int v13; // ST38_4@15
  int v14; // ST3C_4@15
  int v15; // ST40_4@15
  int v16; // ST44_4@15
  int v17; // ST48_4@15
  int v18; // ST4C_4@15
  int v19; // ST50_4@15
  int v20; // ST54_4@15
  int v21; // ST58_4@15
  int v22; // eax@16
  char v23; // al@18
  int v24; // esi@18
  int v25; // esi@19
  int v26; // eax@26
  bool v27; // eax@28
  int v28; // esi@29
  int v29; // edi@1
  int v30; // esi@1
  int v31; // edi@8
  int v32; // [sp+0h] [bp-8h]@8
  int v33; // [sp+4h] [bp-4h]@8

  v29 = a1;
  v30 = *(_DWORD *)(a1 + 32);
  if ( v30 )
  {
    *(_DWORD *)(a1 + 32) = 0;
    if ( *(_DWORD *)(v30 + 80) <= *(_DWORD *)(v30 + 76) )
    {
      if ( *(_DWORD *)(v30 + 112) )
        sub_100273C5(v30, 0);
      else
        *(_DWORD *)(v30 + 72) = 0;
      sub_100276F8((void *)(*(_DWORD *)(v29 + 24) + 88), v30, *(_DWORD *)(v30 + 68), 1);
    }
    else
    {
      sub_100273C5(v30, 0);
      sub_100382D7(*(_DWORD *)(v29 + 24), v30);
    }
  }
  _SEH_prolog4(&unk_100601A0, 44);
  v31 = v2;
  *(_DWORD *)(a2 - 44) = v2;
  if ( *(_DWORD *)(v2 + 100) )
  {
    *(_DWORD *)(a2 - 52) = 0;
    *(_DWORD *)(a2 - 48) = sub_1002C66E;
    do
      sub_100246C7((void *)(a2 - 60));
    while ( *(_DWORD *)(v31 + 100) );
  }
  if ( *(_DWORD *)(v31 + 132) > 0 )
    sub_10026FAD((void *)v31);
  if ( *(_DWORD *)(v31 + 80) )
  {
    LOBYTE(v22) = 0;
    *(_BYTE *)(a2 - 26) = 0;
    while ( !(_BYTE)v22 )
    {
      *(_BYTE *)(a2 - 25) = 1;
      sub_10024558((void *)(v31 + 84));
      *(_DWORD *)(a2 - 4) = 0;
      v23 = 1;
      *(_BYTE *)(a2 - 25) = 1;
      v24 = *(_DWORD *)(v31 + 80);
      if ( v24 )
        v25 = *(_DWORD *)(v24 + 4);
      else
        v25 = 0;
      while ( v25 && v23 )
      {
        if ( v25 == *(_DWORD *)(v31 + 80) )
          *(_DWORD *)(a2 - 32) = 0;
        else
          *(_DWORD *)(a2 - 32) = *(_DWORD *)(v25 + 4);
        *(_DWORD *)(a2 - 36) = v25 - 92;
        v26 = sub_1002618A(*(void **)(v25 - 92 + 48));
        *(_DWORD *)(a2 - 40) = v26;
        if ( !sub_10024783((void *)(v26 + 4)) )
        {
          sub_10024692((void *)(v31 + 84));
          *(_BYTE *)(a2 - 25) = 0;
          Sleep(1u);
          break;
        }
        *(_DWORD *)(a2 - 4) = 1;
        v28 = *(_DWORD *)(a2 - 36) + 92;
        sub_100276CA((void *)(v31 + 80), v28);
        *(_BYTE *)(*(_DWORD *)(a2 - 36) + 77) = 0;
        sub_10026D9E(*(void **)(a2 - 40), v28);
        *(_DWORD *)(a2 - 4) = 0;
        v25 = *(_DWORD *)(a2 - 32);
        sub_100271C3(a2);
        v23 = *(_BYTE *)(a2 - 25);
      }
      v27 = v25 == 0;
      *(_DWORD *)(a2 - 32) = v27;
      *(_BYTE *)(a2 - 26) = v27;
      *(_DWORD *)(a2 - 4) = -2;
      sub_100271DA(a2, v31);
      v22 = *(_DWORD *)(a2 - 32);
    }
  }
  else
  {
    sub_1002462B((void *)(v31 + 84));
  }
  return _SEH_epilog4(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v32, v33);
}
// 10032000: using guessed type _DWORD __cdecl _SEH_prolog4(_DWORD, _DWORD);
// 10032045: using guessed type int __stdcall _SEH_epilog4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (100276CA) --------------------------------------------------------
int __thiscall sub_100276CA(void *this, int a2)
{
  int result; // eax@1

  **(_DWORD **)(a2 + 4) = *(_DWORD *)a2;
  *(_DWORD *)(*(_DWORD *)a2 + 4) = *(_DWORD *)(a2 + 4);
  result = *(_DWORD *)this;
  if ( a2 == *(_DWORD *)this )
  {
    if ( result == *(_DWORD *)(result + 4) )
      result = 0;
    else
      result = *(_DWORD *)result;
    *(_DWORD *)this = result;
  }
  return result;
}

//----- (100276F8) --------------------------------------------------------
char __thiscall sub_100276F8(void *ListHead, int a2, signed int a3, char a4)
{
  signed int v4; // edx@1
  int v6; // esi@1
  char result; // al@2
  int v8; // eax@3
  int v9; // ecx@3
  int v10; // edx@4
  int v11; // edi@4
  int v12; // edx@5
  PSINGLE_LIST_ENTRY v18; // eax@14
  int v19; // ST08_4@14

  v6 = (int)ListHead;
  v4 = a3 >> *((_DWORD *)ListHead + 11);
  _EBX = a3 & (*((_DWORD *)ListHead + 10) - 1);
  if ( v4 < *((_DWORD *)ListHead + 15) )
  {
    v9 = *((_DWORD *)ListHead + 14);
    v8 = *(_DWORD *)(v6 + 52);
    if ( v4 < v9 )
    {
      v11 = *(_DWORD *)(v8 + 4 * v4);
    }
    else
    {
      v10 = v4 - v9;
      v11 = *(_DWORD *)(v8 + 4 * v9 - 4);
      if ( v10 >= 0 )
      {
        v12 = v10 + 1;
        do
        {
          v11 = *(_DWORD *)(v11 + 4);
          --v12;
        }
        while ( v12 );
      }
    }
    _ECX = *(_DWORD *)v11 + 4 * _EBX;
    _EDX = 0;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 == a2 )
    {
      _ECX = v11 + 8;
      __asm { lock cmpxchg [ecx], ebx }
      if ( a4 )
      {
        if ( (signed int)QueryDepthSList((PSLIST_HEADER)v6) <= *(_DWORD *)(v6 + 68) )
        {
          InterlockedPushEntrySList((PSLIST_HEADER)v6, (PSINGLE_LIST_ENTRY)(a2 + 24));
        }
        else
        {
          InterlockedPushEntrySList((PSLIST_HEADER)(v6 + 8), (PSINGLE_LIST_ENTRY)(a2 + 24));
          if ( (signed int)QueryDepthSList((PSLIST_HEADER)(v6 + 8)) > *(_DWORD *)(v6 + 68) )
          {
            if ( !sub_1002A7FD(*(_DWORD *)(v6 + 36)) )
            {
              _EDX = 1;
              _ECX = v6 + 72;
              __asm { lock cmpxchg [ecx], edx }
              v18 = InterlockedFlushSList((PSLIST_HEADER)(v6 + 8));
              v19 = *(_DWORD *)(v6 + 36);
              *(_DWORD *)(v6 + 16) = v18;
              sub_1002ADAD(v6 + 20, (int (__cdecl *)(_DWORD))sub_10026F80, v6, v19);
            }
          }
        }
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100277EE) --------------------------------------------------------
int __thiscall sub_100277EE(int this, int a2)
{
  int v3; // edi@1

  v3 = this;
  sub_10024558((void *)(this + 4));
  sub_100276CA((void *)v3, a2);
  return sub_10024692((void *)(v3 + 4));
}

//----- (10027815) --------------------------------------------------------
int __thiscall sub_10027815(void *this, int a2)
{
  return sub_100277EE((int)((char *)this + 80), a2 + 92);
}

//----- (1002782B) --------------------------------------------------------
BOOL __thiscall sub_1002782B(LPVOID lpTlsValue)
{
  return TlsSetValue(dwTlsIndex, lpTlsValue);
}

//----- (10027839) --------------------------------------------------------
int __thiscall sub_10027839(int this, int a2)
{
  int result; // eax@1

  result = a2;
  *(_DWORD *)(this + 124) = a2;
  return result;
}

//----- (1002784B) --------------------------------------------------------
char __thiscall sub_1002784B(void *this)
{
  int v1; // eax@1
  int v2; // ebx@1
  int ebp0; // ebp@0
  int v4; // edi@1
  int v5; // esi@2
  int v6; // edi@5
  int v8; // [sp+8h] [bp-8h]@5
  int v9; // [sp+Ch] [bp-4h]@1

  v9 = 0;
  v2 = (int)((char *)this + 128);
  v1 = sub_100273E8((int)((char *)this + 128), (int)&v9);
  v4 = v1;
  if ( v1 )
  {
    do
    {
      v5 = *(_DWORD *)v4;
      if ( !*(_DWORD *)v4 )
      {
        ++v9;
        v5 = sub_100273E8(v2, (int)&v9);
      }
      LOBYTE(v1) = sub_10026243(*(_DWORD *)(v4 + 8));
      if ( (_BYTE)v1 )
      {
        v6 = *(_DWORD *)(v4 + 8);
        v8 = sub_100262EE(v6);
        LOBYTE(v1) = sub_10025A57((unsigned int *)v2, (int)&v8, 0);
        if ( v6 )
        {
          sub_100258E1(ebp0);
          LOBYTE(v1) = sub_1002404A((LPVOID)v6);
        }
      }
      v4 = v5;
    }
    while ( v5 );
  }
  return v1;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (100278C7) --------------------------------------------------------
int __cdecl sub_100278C7(int (__cdecl *a1)(_DWORD, _DWORD), int a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  return sub_10037646(a1, a2, a3);
}

//----- (10027969) --------------------------------------------------------
int __thiscall sub_10027969(void *this, int a2, int a3, int a4)
{
  int v4; // eax@1
  int v5; // ebx@1
  int v6; // edi@1
  signed __int64 v8; // qax@1
  signed __int64 v10; // qax@1
  int v11; // edx@2
  int i; // ecx@2
  int v13; // edx@6
  int v14; // ebx@6
  void *v15; // esi@6
  int v16; // edx@7
  int v17; // ecx@8
  int v18; // edx@8
  int v19; // eax@8
  int v20; // ebx@12
  int v21; // edx@13
  int v22; // ecx@13
  int v23; // edx@13
  void *v25; // [sp+Ch] [bp-24h]@6
  void *v26; // [sp+10h] [bp-20h]@1
  int v27; // [sp+14h] [bp-1Ch]@1
  void *v28; // [sp+18h] [bp-18h]@6
  int v29; // [sp+1Ch] [bp-14h]@1
  int v30; // [sp+20h] [bp-10h]@1
  int v31; // [sp+24h] [bp-Ch]@6
  int v32; // [sp+28h] [bp-8h]@6
  int v33; // [sp+2Ch] [bp-4h]@1

  v6 = (int)this;
  _ECX = 0;
  v5 = 2 * (*(_DWORD *)(v6 + 8) + 1);
  v8 = 4i64 * (unsigned int)(2 * (*(_DWORD *)(v6 + 8) + 1));
  __asm { seto    cl }
  v29 = v6;
  v27 = v5;
  v30 = sub_10021CF0(SHIDWORD(v8), v8 | -_ECX, v5, v6, v8 | -_ECX);
  v26 = *(void **)(v6 + 28);
  _ECX = 0;
  v10 = 8i64 * (unsigned int)v5;
  __asm { seto    cl }
  v4 = sub_10021CF0(SHIDWORD(v10), v10 | -_ECX, v5, v6, v10 | -_ECX);
  v33 = v4;
  if ( v4 )
  {
    v11 = v5 - 1;
    for ( i = v4; v11 >= 0; --v11 )
    {
      *(_DWORD *)i = 0;
      *(_DWORD *)(i + 4) = 0;
      i += 8;
    }
  }
  else
  {
    v33 = 0;
  }
  v15 = *(void **)(v6 + 16);
  v25 = *(void **)(v6 + 32);
  v28 = *(void **)(v6 + 16);
  sub_1002C615(v15);
  v32 = 0;
  v13 = *(_DWORD *)(v6 + 4) - *(_DWORD *)v6;
  v14 = *(_DWORD *)(v6 + 8) & *(_DWORD *)v6;
  v31 = v13;
  *(_DWORD *)(v6 + 12) = *(_DWORD *)(v6 + 12) - v14 - v13 + *(_DWORD *)(v6 + 4);
  *(_DWORD *)v6 = v14;
  *(_DWORD *)(v6 + 4) = v14 + v13;
  if ( v13 > 0 )
  {
    v16 = 0;
    do
    {
      *(_DWORD *)(v30 + 4 * v16) = *(_DWORD *)(*(_DWORD *)(v6 + 28) + 4 * (*(_DWORD *)(v6 + 8) & v14));
      v17 = *(_DWORD *)(v6 + 32);
      v18 = *(_DWORD *)(v6 + 8) & v14;
      *(_DWORD *)(v33 + 8 * v32) = *(_DWORD *)(v17 + 8 * v18);
      v19 = *(_DWORD *)(v17 + 8 * v18 + 4);
      v6 = v29;
      v16 = v32 + 1;
      *(_DWORD *)(v33 + 8 * (v32 + 1) - 4) = v19;
      ++v14;
      v32 = v16;
    }
    while ( v16 < v31 );
    v15 = v28;
    v13 = v31;
  }
  *(_DWORD *)(v6 + 28) = v30;
  *(_DWORD *)(v6 + 32) = v33;
  *(_DWORD *)(v6 + 12) += *(_DWORD *)v6;
  if ( *(_BYTE *)(v6 + 20) )
    *(_DWORD *)(v6 + 24) -= *(_DWORD *)v6;
  *(_DWORD *)(v6 + 8) = v27 - 1;
  *(_DWORD *)v6 = 0;
  *(_DWORD *)(v6 + 4) = v13;
  v20 = *(_DWORD *)(v6 + 4);
  if ( a3 )
  {
    v22 = *(_DWORD *)(v6 + 32);
    v23 = *(_DWORD *)(v6 + 8) & v20;
    *(_DWORD *)(v22 + 8 * v23) = a3;
    *(_DWORD *)(v22 + 8 * v23 + 4) = a4;
    v21 = a2 | 1;
  }
  else
  {
    v21 = a2;
  }
  *(_DWORD *)(*(_DWORD *)(v6 + 28) + 4 * (*(_DWORD *)(v6 + 8) & v20)) = v21;
  *(_DWORD *)(v6 + 4) = v20 + 1;
  sub_1002C625(v15);
  sub_1002401B(v26);
  sub_1002401B(v25);
  return *(_DWORD *)(v6 + 12) - 1 + *(_DWORD *)(v6 + 4);
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (10027AF1) --------------------------------------------------------
int __cdecl sub_10027AF1(char a1, char a2, int a3, int a4)
{
  int v4; // ebx@1
  int result; // eax@2
  __int16 v6; // [sp+4h] [bp-40h]@2
  char v7; // [sp+6h] [bp-3Eh]@2
  char v8; // [sp+8h] [bp-3Ch]@2
  char v9; // [sp+9h] [bp-3Bh]@2
  int v10; // [sp+1Ch] [bp-28h]@2
  int v11; // [sp+20h] [bp-24h]@2
  int v12; // [sp+24h] [bp-20h]@2
  int v13; // [sp+28h] [bp-1Ch]@2
  int v14; // [sp+30h] [bp-14h]@2
  int v15; // [sp+38h] [bp-Ch]@2
  int v16; // [sp+3Ch] [bp-8h]@2

  v4 = dword_100693F8;
  if ( dword_100693F8 )
  {
    sub_10030CF0(&v7, 0, 62);
    v14 = 131072;
    v6 = 64;
    v8 = a1;
    v9 = a2;
    v10 = dword_1005BFC0[0];
    v11 = dword_1005BFC0[1];
    v12 = dword_1005BFC0[2];
    v13 = dword_1005BFC0[3];
    v15 = a3;
    v16 = a4;
    result = sub_10028A7A(v4, dword_100693F0, dword_100693F4, (int)&v6);
  }
  return result;
}
// 100693F0: using guessed type int dword_100693F0;
// 100693F4: using guessed type int dword_100693F4;
// 100693F8: using guessed type int dword_100693F8;

//----- (10027B62) --------------------------------------------------------
char __thiscall sub_10027B62(void *this, int a2, char a3)
{
  void *v3; // esi@1
  signed int v4; // eax@2
  char result; // al@4
  int v6; // eax@5
  int v7; // ecx@7

  v3 = this;
  if ( a3 )
  {
    v4 = sub_100371E5(a2, 0);
    if ( v4 == 2 || !*(_DWORD *)(v4 + 8) )
      return 1;
  }
  v6 = *((_DWORD *)v3 + 15);
  if ( *((_DWORD *)v3 + 27) >= v6 || v6 == -1 )
  {
    result = 0;
  }
  else
  {
    v7 = *((_DWORD *)v3 + 14);
    if ( v7 == 2 )
      return 1;
    result = *(_DWORD *)(v7 + 8) == 0;
  }
  return result;
}

//----- (10027BAF) --------------------------------------------------------
int __stdcall sub_10027BAF(char a1, char a2, int a3, int a4)
{
  int result; // eax@2

  if ( a2 <= (unsigned __int8)byte_100693EC )
  {
    result = dword_100693E8;
    if ( dword_100693E8 & 2 )
      result = sub_10027AF1(a1, a2, a3, a4);
  }
  return result;
}
// 100693E8: using guessed type int dword_100693E8;
// 100693EC: using guessed type char byte_100693EC;

//----- (10027BDC) --------------------------------------------------------
int __thiscall sub_10027BDC(int this, int a2)
{
  int ebp0; // ebp@0
  int v3; // esi@1
  int result; // eax@2
  int v5; // ebx@5
  int v6; // eax@5

  v3 = a2 - *(_DWORD *)(this + 12);
  if ( v3 == *(_DWORD *)(this + 4) - 1 )
  {
    result = sub_10027419(this, ebp0);
  }
  else
  {
    if ( v3 >= *(_DWORD *)(this + 4) || v3 < *(_DWORD *)this )
    {
      result = 0;
    }
    else
    {
      v6 = *(_DWORD *)(this + 28) + 4 * (v3 & *(_DWORD *)(this + 8));
      v5 = *(_DWORD *)v6;
      *(_DWORD *)v6 = 0;
      if ( !(v5 & 1) || (v5 &= 0xFFFFFFFEu, sub_1003AA40(*(_DWORD *)(this + 32) + 8 * (v3 & *(_DWORD *)(this + 8)), 0)) )
        result = v5;
      else
        result = 1;
    }
  }
  return result;
}

//----- (10027C3F) --------------------------------------------------------
int __thiscall sub_10027C3F(int this, int a2)
{
  return sub_10027BDC(*(_DWORD *)(this + 32) + 76, a2);
}

//----- (10027C4E) --------------------------------------------------------
int __thiscall sub_10027C4E(int this, int a2)
{
  int result; // eax@1

  *(_DWORD *)this ^= (*(_DWORD *)this ^ *(_DWORD *)a2) & 0xFFFFFFF;
  *(_DWORD *)this = *(_DWORD *)a2 ^ (*(_DWORD *)this ^ *(_DWORD *)a2) & 0xFFFFFFF;
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  result = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(this + 12) = result;
  return result;
}

//----- (10027C83) --------------------------------------------------------
char *__usercall sub_10027C83<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  return (char *)sub_1002436D(a1, a2, a3) + 64;
}

//----- (10027C8C) --------------------------------------------------------
int __thiscall sub_10027C8C(int this)
{
  int result; // eax@2

  if ( (*(_DWORD *)(this + 4) & 0xFFFFFFF) == 268435455 )
    result = 0;
  else
    result = *(_DWORD *)this;
  return result;
}

//----- (10027CA0) --------------------------------------------------------
int __thiscall sub_10027CA0(int this, int a2, int a3, int a4)
{
  int v5; // esi@1

  v5 = this;
  sub_10001380(this, a4);
  *(_DWORD *)(v5 + 28) = a2;
  *(_DWORD *)(v5 + 32) = a3;
  *(_DWORD *)v5 = &off_10055BA8;
  return v5;
}
// 10055BA8: using guessed type int (__stdcall *off_10055BA8)(char);

//----- (10027CD1) --------------------------------------------------------
void *__thiscall sub_10027CD1(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10055B10;
  if ( a2 & 1 )
    sub_1002404A(this);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10055B10: using guessed type int (__stdcall *off_10055B10)(char);

//----- (10027CF1) --------------------------------------------------------
int __userpurge sub_10027CF1<eax>(int a1<ebp>, int a2)
{
  char v2; // bl@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // ecx@1

  sub_1002D0B8();
  v3 = v5 + 52;
  v2 = 0;
  *(_DWORD *)(a1 - 16) = v5 + 52;
  sub_10024558((void *)(v5 + 56));
  v4 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  if ( *(_DWORD *)v3 )
  {
    sub_100276CA((void *)v3, v4 + 20);
    *(_DWORD *)(v4 + 8) = 2;
    sub_10001320((void *)v4);
  }
  else
  {
    v2 = 1;
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_10024692((void *)(v3 + 4));
  if ( v2 )
  {
    _EBX = v4 + 8;
    _ECX = 1;
    __asm { lock cmpxchg [ebx], ecx }
  }
  return sub_1002D086(44);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10027DA2) --------------------------------------------------------
int __thiscall sub_10027DA2(int this)
{
  return (*(int (__cdecl **)(_DWORD))(this + 28))(*(_DWORD *)(this + 32));
}

//----- (10027DAA) --------------------------------------------------------
int __usercall sub_10027DAA<eax>(void *this<ecx>, int a2<ebp>)
{
  void *v2; // esi@1
  DWORD v3; // edi@1

  v2 = this;
  v3 = GetCurrentThreadId();
  _EBX = (int)((char *)v2 + 8);
  _EDX = v3;
  __asm { lock cmpxchg [ebx], edx }
  (*(void (__thiscall **)(_DWORD))(*(_DWORD *)v2 + 8))(v2);
  _ECX = 3;
  __asm { lock cmpxchg [ebx], ecx }
  if ( v3 == 2 )
    sub_10025148(a2);
  return sub_10001320(v2);
}

//----- (10027DED) --------------------------------------------------------
int __userpurge sub_10027DED<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int v8; // esi@2

  v7 = a2;
  v6 = sub_10027EB3(a1, a2, a3, a2, 36);
  if ( v6 )
    v8 = sub_10027CA0(v6, a4, a5, a6);
  else
    v8 = 0;
  sub_10027E26(v7, v8);
  return v8;
}

//----- (10027E26) --------------------------------------------------------
int __thiscall sub_10027E26(int this, int a2)
{
  char v2; // bl@1
  int ebp0; // ebp@0
  int v4; // edi@1
  void *v5; // esi@1
  int result; // eax@4
  int v14; // [sp+14h] [bp+8h]@2

  v5 = (void *)a2;
  v2 = 1;
  *(_DWORD *)(a2 + 8) = 0;
  v4 = this;
  _EDX = a2 + 4;
  _EAX = 1;
  __asm { lock xadd [edx], eax }
  *(_DWORD *)(a2 + 16) = this;
  if ( *(_DWORD *)(this + 8) )
    goto LABEL_8;
  v14 = this + 52;
  sub_10024558((void *)(this + 56));
  if ( !*(_DWORD *)(v4 + 8) )
  {
    v2 = 0;
    sub_10026D9E((void *)v14, (int)((char *)v5 + 20));
  }
  result = sub_10024692((void *)(v14 + 4));
  if ( v2 )
LABEL_8:
    result = sub_10027DAA(v5, ebp0);
  return result;
}

//----- (10027E8B) --------------------------------------------------------
int __usercall sub_10027E8B<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  int ebp0; // ebp@0

  *(_DWORD *)a4 = sub_10029C73(a1, a2, ebp0, a3);
  return a4;
}

//----- (10027E9C) --------------------------------------------------------
int __usercall sub_10027E9C<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4, int a5)
{
  int ebp0; // ebp@0
  int v7; // eax@1

  v7 = sub_10029C73(a1, a2, ebp0, a3);
  return (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v7 + 44))(v7, a4, a5);
}

//----- (10027EB3) --------------------------------------------------------
int __usercall sub_10027EB3<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int dwBytes)
{
  bool v5; // eax@2
  int v6; // ST04_4@2
  int result; // eax@3
  int (__stdcall **v8)(char); // [sp+0h] [bp-10h]@5
  int v9; // [sp+Ch] [bp-4h]@5

  while ( 1 )
  {
    result = sub_10028264(a1, a2, a3, a4, dwBytes);
    if ( result )
      break;
    v5 = sub_10038C10(dwBytes);
    a2 = v6;
    if ( !v5 )
    {
      v9 = (int)"bad allocation";
      sub_100236AC((int)&v8, (int)&v9, 1);
      v8 = &off_100542A4;
      sub_1002D02B((int)&v8, (int)&unk_1005F828);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_10027F02);
    }
  }
  return result;
}
// 100542A4: using guessed type int (__stdcall *off_100542A4)(char);

//----- (10027F02) --------------------------------------------------------
signed int __usercall sub_10027F02<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6)
{
  int v6; // edx@1
  int v8; // esi@9
  int v9; // eax@11
  int v10; // ebx@14
  int v11; // edi@14
  char v12; // al@15
  char v13; // al@18
  char v14; // zf@23
  int v15; // [sp-8h] [bp-Ch]@14
  signed int v16; // [sp-4h] [bp-8h]@11
  int v17; // [sp-4h] [bp-8h]@14

  v6 = a6;
  if ( a6 )
  {
    if ( !a3 )
    {
LABEL_11:
      v9 = sub_1002F144(a1);
      v16 = 22;
LABEL_12:
      *(_DWORD *)v9 = v16;
      sub_10036C88(a1, a2);
      return v16;
    }
  }
  else
  {
    if ( !a3 )
    {
      if ( !a4 )
        return 0;
      goto LABEL_11;
    }
  }
  if ( !a4 )
    goto LABEL_11;
  if ( !a6 )
  {
    *(_BYTE *)a3 = 0;
    return 0;
  }
  v8 = a5;
  if ( !a5 )
  {
    *(_BYTE *)a3 = 0;
    goto LABEL_11;
  }
  v17 = a1;
  v15 = a2;
  v10 = a3;
  v11 = a4;
  if ( a6 == -1 )
  {
    do
    {
      v12 = *(_BYTE *)v8;
      *(_BYTE *)(a3 - a5 + v8) = *(_BYTE *)v8;
      ++v8;
      if ( !v12 )
        break;
      --v11;
    }
    while ( v11 );
  }
  else
  {
    do
    {
      v13 = *(_BYTE *)(a5 - a3 + v10);
      *(_BYTE *)v10++ = v13;
      if ( !v13 )
        break;
      --v11;
      if ( !v11 )
        break;
      --v6;
    }
    while ( v6 );
    if ( !v6 )
      *(_BYTE *)v10 = 0;
  }
  v14 = v11 == 0;
  a2 = v15;
  a1 = v17;
  if ( !v14 )
    return 0;
  if ( v6 != -1 )
  {
    *(_BYTE *)a3 = 0;
    v9 = sub_1002F144(v17);
    v16 = 34;
    goto LABEL_12;
  }
  *(_BYTE *)(a3 + a4 - 1) = 0;
  return 80;
}

//----- (10027FA6) --------------------------------------------------------
int __cdecl sub_10027FA6(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  dword_100693DC = IsDebuggerPresent();
  sub_10038C43();
  sub_10031369(ExceptionInfo);
  if ( !dword_100693DC )
    sub_10038C43();
  return sub_10031354(0xC0000409u);
}
// 100693DC: using guessed type int dword_100693DC;

//----- (10027FE6) --------------------------------------------------------
int __usercall sub_10027FE6<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, char a4)
{
  BOOL v8; // eax@1
  int v9; // edx@1
  signed int v10; // ecx@1
  int v12; // ST328_4@3
  int v13; // [sp-4h] [bp-328h]@1
  int v14; // [sp+328h] [bp+4h]@3

  v8 = IsProcessorFeaturePresent(0x17u);
  _OF = 0;
  _CF = 0;
  _ZF = v8 == 0;
  _SF = v8 < 0;
  if ( v8 )
  {
    v10 = 2;
    __asm { int     29h             ; DOS 2+ internal - FAST PUTCHAR }
  }
  dword_100691C0 = v8;
  dword_100691BC = v10;
  dword_100691B8 = v9;
  dword_100691B4 = a1;
  dword_100691B0 = a3;
  dword_100691AC = a2;
  word_100691D8 = __SS__;
  word_100691CC = __CS__;
  word_100691A8 = __DS__;
  word_100691A4 = __ES__;
  word_100691A0 = __FS__;
  word_1006919C = __GS__;
  __asm { pushf }
  dword_100691D0 = v13;
  dword_100691C4 = v12;
  dword_100691C8 = v14;
  dword_100691D4 = (int)&a4;
  dword_10069110 = 65537;
  dword_100690CC = dword_100691C8;
  dword_100690C0 = -1073740791;
  dword_100690C4 = 1;
  dword_100690D0 = 1;
  dword_100690D4 = 2;
  return sub_10027FA6(&ExceptionInfo);
}
// 100690C0: using guessed type int dword_100690C0;
// 100690C4: using guessed type int dword_100690C4;
// 100690CC: using guessed type int dword_100690CC;
// 100690D0: using guessed type int dword_100690D0;
// 100690D4: using guessed type int dword_100690D4;
// 10069110: using guessed type int dword_10069110;
// 1006919C: using guessed type __int16 word_1006919C;
// 100691A0: using guessed type __int16 word_100691A0;
// 100691A4: using guessed type __int16 word_100691A4;
// 100691A8: using guessed type __int16 word_100691A8;
// 100691AC: using guessed type int dword_100691AC;
// 100691B0: using guessed type int dword_100691B0;
// 100691B4: using guessed type int dword_100691B4;
// 100691B8: using guessed type int dword_100691B8;
// 100691BC: using guessed type int dword_100691BC;
// 100691C0: using guessed type int dword_100691C0;
// 100691C4: using guessed type int dword_100691C4;
// 100691C8: using guessed type int dword_100691C8;
// 100691CC: using guessed type __int16 word_100691CC;
// 100691D0: using guessed type int dword_100691D0;
// 100691D4: using guessed type int dword_100691D4;
// 100691D8: using guessed type __int16 word_100691D8;

//----- (100280DF) --------------------------------------------------------
int __usercall sub_100280DF<eax>(int a1<ebx>, int a2<edi>, int a3<esi>)
{
  return sub_100280EB(a1, a2, a3, 8);
}

//----- (100280EB) --------------------------------------------------------
int __usercall sub_100280EB<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, int a4)
{
  BOOL v8; // eax@1
  int v9; // edx@1
  int v10; // ecx@1
  int v12; // ST320_4@3
  int v13; // [sp-4h] [bp-320h]@1
  int v14; // [sp+320h] [bp+4h]@3

  v8 = IsProcessorFeaturePresent(0x17u);
  _OF = 0;
  _CF = 0;
  _ZF = v8 == 0;
  _SF = v8 < 0;
  if ( v8 )
  {
    v10 = a4;
    __asm { int     29h             ; DOS 2+ internal - FAST PUTCHAR }
  }
  dword_100691C0 = v8;
  dword_100691BC = v10;
  dword_100691B8 = v9;
  dword_100691B4 = a1;
  dword_100691B0 = a3;
  dword_100691AC = a2;
  word_100691D8 = __SS__;
  word_100691CC = __CS__;
  word_100691A8 = __DS__;
  word_100691A4 = __ES__;
  word_100691A0 = __FS__;
  word_1006919C = __GS__;
  __asm { pushf }
  dword_100691D0 = v13;
  dword_100691C4 = v12;
  dword_100691C8 = v14;
  dword_100691D4 = (int)&a4;
  dword_100690CC = dword_100691C8;
  dword_100690C0 = -1073740791;
  dword_100690C4 = 1;
  dword_100690D0 = 1;
  dword_100690D4 = a4;
  return sub_10027FA6(&ExceptionInfo);
}
// 100690C0: using guessed type int dword_100690C0;
// 100690C4: using guessed type int dword_100690C4;
// 100690CC: using guessed type int dword_100690CC;
// 100690D0: using guessed type int dword_100690D0;
// 100690D4: using guessed type int dword_100690D4;
// 1006919C: using guessed type __int16 word_1006919C;
// 100691A0: using guessed type __int16 word_100691A0;
// 100691A4: using guessed type __int16 word_100691A4;
// 100691A8: using guessed type __int16 word_100691A8;
// 100691AC: using guessed type int dword_100691AC;
// 100691B0: using guessed type int dword_100691B0;
// 100691B4: using guessed type int dword_100691B4;
// 100691B8: using guessed type int dword_100691B8;
// 100691BC: using guessed type int dword_100691BC;
// 100691C0: using guessed type int dword_100691C0;
// 100691C4: using guessed type int dword_100691C4;
// 100691C8: using guessed type int dword_100691C8;
// 100691CC: using guessed type __int16 word_100691CC;
// 100691D0: using guessed type int dword_100691D0;
// 100691D4: using guessed type int dword_100691D4;
// 100691D8: using guessed type __int16 word_100691D8;

//----- (100281B9) --------------------------------------------------------
int __usercall sub_100281B9<eax>(int a1<ebx>, int a2, int a3, char a4)
{
  return sub_100281D7(a1, sub_10038CED, a2, a3, 0, (int)&a4);
}

//----- (100281D7) --------------------------------------------------------
int __usercall sub_100281D7<eax>(int a1<ebx>, int (__cdecl *a2)(_DWORD, _DWORD, _DWORD, _DWORD), int a3, int a4, int a5, int a6)
{
  int result; // eax@2
  int v7; // eax@4
  int v8; // [sp+8h] [bp-20h]@1
  int v9; // [sp+Ch] [bp-1Ch]@1
  int v10; // [sp+10h] [bp-18h]@4
  int v11; // [sp+14h] [bp-14h]@4
  int v12; // [sp+28h] [bp+0h]@2

  v8 = 0;
  memset(&v9, 0, 0x1Cu);
  if ( a3 && a4 )
  {
    v7 = sub_1002CFA0(a3);
    v11 = 73;
    v10 = a3;
    v8 = a3;
    v9 = 2147483647;
    if ( (unsigned int)v7 <= 0x7FFFFFFF )
      v9 = v7;
    result = a2(&v8, a4, a5, a6);
  }
  else
  {
    *(_DWORD *)sub_1002F144(a1) = 22;
    sub_10036C88(a1, (int)&v12);
    result = -1;
  }
  return result;
}

//----- (10028248) --------------------------------------------------------
int __usercall sub_10028248<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned int a4, int a5, char a6)
{
  return sub_1003A01E(a1, a2, a3, a4, a5, 0, (int)&a6);
}

//----- (10028264) --------------------------------------------------------
int __usercall sub_10028264<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int dwBytes)
{
  HMODULE v5; // ecx@3
  SIZE_T v6; // ecx@6
  bool v7; // eax@10
  int v8; // ST08_4@10
  int result; // eax@14

  if ( (unsigned int)dwBytes > 0xFFFFFFE0 )
  {
    sub_10038C10(dwBytes);
    *(_DWORD *)sub_1002F144(a3) = 12;
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      if ( !hHeap )
      {
        sub_10032605(a1, a2, a3, a4);
        sub_10032662(a3, 30);
        sub_10032227(v5, 0xFFu);
      }
      v6 = dwBytes ? dwBytes : 1;
      a4 = (int)HeapAlloc(hHeap, 0, v6);
      if ( a4 )
        break;
      a3 = 12;
      if ( !dword_10069C90 )
      {
        *(_DWORD *)sub_1002F144(12) = 12;
LABEL_13:
        *(_DWORD *)sub_1002F144(12) = 12;
        break;
      }
      v7 = sub_10038C10(dwBytes);
      a2 = v8;
      if ( !v7 )
        goto LABEL_13;
    }
    result = a4;
  }
  return result;
}
// 10069C90: using guessed type int dword_10069C90;

//----- (100282F6) --------------------------------------------------------
void __usercall sub_100282F6(int a1<ebx>, LPVOID lpMem)
{
  int v2; // esi@3
  int v3; // eax@3

  if ( lpMem )
  {
    if ( !HeapFree(hHeap, 0, lpMem) )
    {
      v2 = sub_1002F144(a1);
      v3 = GetLastError();
      *(_DWORD *)v2 = sub_1002F157(v3);
    }
  }
}

//----- (1002832E) --------------------------------------------------------
signed int __stdcall sub_1002832E(int a1, int a2, int a3, void (__thiscall *a4)(_DWORD), int a5)
{
  int v5; // edi@1
  int v6; // esi@1

  v6 = 0;
  v5 = a1;
  while ( v6 < a3 )
  {
    a4(v5);
    v5 += a2;
    ++v6;
  }
  return 1;
}

//----- (100283A0) --------------------------------------------------------
int __cdecl sub_100283A0(int a1, unsigned __int8 a2)
{
  signed int v2; // eax@2
  int result; // eax@5
  int v14; // edx@8
  char v15; // cl@9
  int v16; // ebx@12
  int v17; // eax@13
  int v18; // esi@13
  int v19; // ecx@13
  int v20; // eax@14
  unsigned int v21; // eax@19
  unsigned int v22; // eax@23

  if ( (unsigned int)dword_100695C0 < 1 )
  {
    v14 = a1;
    if ( a1 & 3 )
    {
      while ( 1 )
      {
        v15 = *(_BYTE *)v14++;
        if ( v15 == a2 )
          break;
        if ( !v15 )
          return 0;
        if ( !(v14 & 3) )
          goto LABEL_12;
      }
      result = v14 - 1;
    }
    else
    {
LABEL_12:
      v16 = (a2 << 8) | a2 | (((a2 << 8) | a2) << 16);
      while ( 1 )
      {
        while ( 1 )
        {
          v19 = v16 ^ *(_DWORD *)v14;
          v18 = *(_DWORD *)v14 + 2130640639;
          v17 = (*(_DWORD *)v14 + 2130640639) ^ ~*(_DWORD *)v14;
          v14 += 4;
          if ( ((v19 + 2130640639) ^ ~v19) & 0x81010100 )
            break;
          v20 = v17 & 0x81010100;
          if ( v20 && (v20 & 0x1010100 || !(v18 & 0x80000000)) )
            return 0;
        }
        v21 = *(_DWORD *)(v14 - 4);
        if ( (_BYTE)v21 == (_BYTE)v16 )
          break;
        if ( !(_BYTE)v21 )
          return 0;
        if ( BYTE1(v21) == (_BYTE)v16 )
          return v14 - 3;
        if ( !BYTE1(v21) )
          return 0;
        v22 = v21 >> 16;
        if ( (_BYTE)v22 == (_BYTE)v16 )
          return v14 - 2;
        if ( !(_BYTE)v22 )
          return 0;
        if ( BYTE1(v22) == (_BYTE)v16 )
          return v14 - 1;
        if ( !BYTE1(v22) )
          return 0;
      }
      result = v14 - 4;
    }
  }
  else
  {
    _EDX = (a2 << 8) | a2;
    __asm
    {
      movd    xmm3, edx
      pshuflw xmm3, xmm3, 0
      movlhps xmm3, xmm3
    }
    v2 = -1 << (a1 & 0xF);
    for ( _EDX = a1 - (a1 & 0xF); ; _EDX += 16 )
    {
      __asm
      {
        movdqu  xmm1, xmmword ptr [edx]
        pxor    xmm2, xmm2
        pcmpeqb xmm2, xmm1
        pcmpeqb xmm1, xmm3
        por     xmm2, xmm1
        pmovmskb ecx, xmm2
      }
      _ECX = v2 & _ECX;
      if ( _ECX )
        break;
      v2 = -1;
    }
    __asm { bsf     eax, ecx }
    result = _EDX + _EAX;
    __asm { movd    edx, xmm3 }
    if ( (_BYTE)_EDX != *(_BYTE *)result )
      result = 0;
  }
  return result;
}
// 100695C0: using guessed type int dword_100695C0;

//----- (100284D0) --------------------------------------------------------
char __cdecl sub_100284D0(int a1, int a2)
{
  int v3; // edx@1
  int v8; // esi@4
  int v14; // [sp+0h] [bp-24h]@1

  _EAX = 0;
  v14 = 0;
  v3 = a2;
  while ( 1 )
  {
    LOBYTE(_EAX) = *(_BYTE *)v3;
    if ( !*(_BYTE *)v3 )
      break;
    ++v3;
    __asm { bts     [esp+24h+var_24], eax }
  }
  v8 = a1;
  while ( 1 )
  {
    LOBYTE(_EAX) = *(_BYTE *)v8;
    if ( !*(_BYTE *)v8 )
      break;
    ++v8;
    __asm { bt      [esp+24h+var_24], eax }
    if ( _CF )
      return v8 - 1;
  }
  return _EAX;
}

//----- (10028510) --------------------------------------------------------
void **__usercall sub_10028510<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1

  v2 = sub_10031BD7(a1, a2);
  if ( *(volatile LONG **)(v2 + 108) != off_10067514 )
  {
    if ( !(dword_100675D4 & *(_DWORD *)(v2 + 112)) )
      sub_1003A335(a1, a2);
  }
  return off_10066C60;
}
// 10066C60: using guessed type void **off_10066C60;
// 100675D4: using guessed type int dword_100675D4;

//----- (10028540) --------------------------------------------------------
signed int __cdecl sub_10028540(int a1, int a2)
{
  int v3; // edx@1
  signed int v8; // ecx@4
  int v9; // esi@4
  int v15; // [sp+0h] [bp-24h]@1

  _EAX = 0;
  v15 = 0;
  v3 = a2;
  while ( 1 )
  {
    LOBYTE(_EAX) = *(_BYTE *)v3;
    if ( !*(_BYTE *)v3 )
      break;
    ++v3;
    __asm { bts     [esp+24h+var_24], eax }
  }
  v9 = a1;
  v8 = -1;
  do
  {
    ++v8;
    LOBYTE(_EAX) = *(_BYTE *)v9;
    if ( !*(_BYTE *)v9 )
      break;
    ++v9;
    __asm { bt      [esp+24h+var_24], eax }
  }
  while ( !_CF );
  return v8;
}

//----- (10028586) --------------------------------------------------------
int __usercall sub_10028586<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, LPVOID lpMem, int dwBytes)
{
  signed int v7; // esi@3
  int v8; // esi@15
  int v9; // eax@15
  int v10; // esi@16
  int v11; // eax@16

  if ( !lpMem )
    return sub_10028264(a1, a2, a3, a4, dwBytes);
  v7 = dwBytes;
  if ( !dwBytes )
  {
    sub_100282F6(a3, lpMem);
    return 0;
  }
  while ( 1 )
  {
    if ( (unsigned int)v7 > 0xFFFFFFE0 )
    {
      sub_10038C10(v7);
      *(_DWORD *)sub_1002F144(a3) = 12;
      return 0;
    }
    if ( !v7 )
      v7 = 1;
    a3 = (int)HeapReAlloc(hHeap, 0, lpMem, v7);
    if ( a3 )
      return a3;
    if ( !dword_10069C90 )
      break;
    if ( !sub_10038C10(v7) )
    {
      v8 = sub_1002F144(a3);
      v9 = GetLastError();
      *(_DWORD *)v8 = sub_1002F157(v9);
      return 0;
    }
  }
  v10 = sub_1002F144(a3);
  v11 = GetLastError();
  *(_DWORD *)v10 = sub_1002F157(v11);
  return a3;
}
// 10069C90: using guessed type int dword_10069C90;

//----- (10028631) --------------------------------------------------------
int __thiscall sub_10028631(int this)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = sub_1002C373(0);
  return v2;
}

//----- (10028646) --------------------------------------------------------
void __thiscall sub_10028646(void *this)
{
  void *v1; // esi@1
  void *v2; // eax@2

  v1 = this;
  if ( *(_DWORD *)this )
  {
    do
    {
      v2 = (void *)sub_1002C373(*((_DWORD *)v1 + 1));
      *((_DWORD *)v1 + 1) = *(_DWORD *)v2;
      sub_1002401B(v2);
    }
    while ( *(_DWORD *)v1-- != 1 );
  }
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (10028669) --------------------------------------------------------
int __thiscall sub_10028669(int this)
{
  int result; // eax@1
  int v2; // esi@1
  int v3; // ecx@2

  v2 = this;
  result = sub_1002C373(*(_DWORD *)(this + 4));
  if ( result )
  {
    v3 = *(_DWORD *)result;
    --*(_DWORD *)v2;
    *(_DWORD *)(v2 + 4) = v3;
  }
  return result;
}

//----- (10028682) --------------------------------------------------------
int __usercall sub_10028682<eax>(int a1<ebx>, int a2<edi>, unsigned int a3)
{
  int ebp0; // ebp@0
  LPVOID v4; // eax@2
  int v6; // eax@3
  int v7; // edx@3
  int v8; // ecx@3
  int v9; // ebx@3
  int v10; // edi@3
  int v11; // esi@3
  int v12; // ecx@3
  int v13; // ST00_4@3
  int v14; // esi@4
  int (__stdcall **v15)(char); // [sp+0h] [bp-Ch]@3

  if ( a3 <= 0x7FFFFFFF )
  {
    v4 = sub_1002436D(a1, ebp0, a2);
    return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v4 + 40))(v4);
  }
  a3 = (unsigned int)"bad allocation";
  sub_100236AC((int)&v15, (int)&a3, 1);
  v15 = &off_100542A4;
  sub_1002D02B((int)&v15, (int)&unk_1005F828);
  __asm { int     3               ; Trap to Debugger }
  v11 = a3 + 4;
  v9 = v12;
  v6 = sub_10028798(a3 + 4);
  v10 = v6;
  v8 = v13;
  if ( v6 == -1 )
    goto LABEL_6;
  v14 = sub_10028669(v9 + 4 + 8 * v6);
  if ( !v14 )
  {
    v11 = dword_10055BC0[v10];
LABEL_6:
    v14 = sub_10021CF0(v7, v8, v9, v10, v11);
  }
  *(_DWORD *)v14 = sub_1002C373(v10);
  return v14 + 4;
}
// 100542A4: using guessed type int (__stdcall *off_100542A4)(char);
// 10055BC0: using guessed type int dword_10055BC0[];

//----- (1002871D) --------------------------------------------------------
char __thiscall sub_1002871D(int this, int a2)
{
  int v2; // esi@1
  char result; // al@2
  int v4; // eax@2

  v2 = this;
  if ( *(_DWORD *)this >= 32 )
  {
    result = 0;
  }
  else
  {
    *(_DWORD *)a2 = *(_DWORD *)(this + 4);
    v4 = sub_1002C373(a2);
    ++*(_DWORD *)v2;
    *(_DWORD *)(v2 + 4) = v4;
    result = 1;
  }
  return result;
}

//----- (10028747) --------------------------------------------------------
void __usercall sub_10028747(int a1<ebx>, int a2<edi>, int a3)
{
  int ebp0; // ebp@0
  LPVOID v4; // eax@2

  if ( a3 )
  {
    v4 = sub_1002436D(a1, ebp0, a2);
    (*(void (__thiscall **)(LPVOID, int))(*(_DWORD *)v4 + 44))(v4, a3);
  }
}

//----- (10028761) --------------------------------------------------------
char __thiscall sub_10028761(void *this, int a2)
{
  int v2; // eax@1
  void *v3; // edi@1
  int v4; // esi@1
  char result; // al@2

  v4 = a2 - 4;
  v3 = this;
  v2 = sub_1002C373(*(_DWORD *)(a2 - 4));
  if ( v2 == -1 || (result = sub_1002871D((int)(v3 + 8 * v2 + 4), v4), !result) )
    result = sub_1002401B((LPVOID)v4);
  return result;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (10028798) --------------------------------------------------------
int __cdecl sub_10028798(int a1)
{
  int v1; // edx@1
  int result; // eax@2
  signed int v3; // edx@3
  signed int v4; // ecx@5

  v1 = (a1 + 7) & 0xFFFFFFF8;
  if ( (unsigned int)v1 <= 0x1000 )
  {
    v3 = (unsigned int)v1 >> 3;
    if ( v3 > 32 )
    {
      v4 = 5;
      if ( (v3 & 0xFFFFFFE0) > 0 )
      {
        do
          ++v4;
        while ( v3 >> v4 > 0 );
      }
      result = ((~((1 << (v4 - 5)) - 1) & ((1 << (v4 - 5)) - 1 + v3)) >> (v4 - 5)) + 16 * (v4 - 5) - 1;
    }
    else
    {
      result = v3 - 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (100287ED) --------------------------------------------------------
int __usercall sub_100287ED<eax>(int a1<ebx>, int a2)
{
  int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // esi@3
  int v8; // [sp-4h] [bp-Ch]@1

  v5 = a2 + 4;
  v2 = sub_10028798(a2 + 4);
  v4 = v2;
  if ( v2 != -1 )
    v5 = dword_10055BC0[v2];
  v7 = sub_10021CF0(v3, v8, a1, v2, v5);
  *(_DWORD *)v7 = sub_1002C373(v4);
  return v7 + 4;
}
// 10055BC0: using guessed type int dword_10055BC0[];

//----- (10028826) --------------------------------------------------------
void *__thiscall sub_10028826(void *this)
{
  void *v1; // ebx@1
  HMODULE v2; // edi@1
  int v3; // eax@4
  int v4; // eax@4
  int v5; // eax@4
  int v6; // eax@4
  int v7; // eax@4
  int v8; // eax@4

  v1 = this;
  v2 = LoadLibraryExW(L"advapi32.dll", 0, 0x800u);
  if ( v2 || GetLastError() == 87 && (v2 = LoadLibraryW(L"advapi32.dll")) != 0 )
  {
    v3 = (int)GetProcAddress(v2, "RegisterTraceGuidsW");
    *(_DWORD *)v1 = sub_1002C373(v3);
    v4 = (int)GetProcAddress(v2, "UnregisterTraceGuids");
    *((_DWORD *)v1 + 1) = sub_1002C373(v4);
    v5 = (int)GetProcAddress(v2, "TraceEvent");
    *((_DWORD *)v1 + 2) = sub_1002C373(v5);
    v6 = (int)GetProcAddress(v2, "GetTraceLoggerHandle");
    *((_DWORD *)v1 + 3) = sub_1002C373(v6);
    v7 = (int)GetProcAddress(v2, "GetTraceEnableLevel");
    *((_DWORD *)v1 + 4) = sub_1002C373(v7);
    v8 = (int)GetProcAddress(v2, "GetTraceEnableFlags");
    *((_DWORD *)v1 + 5) = sub_1002C373(v8);
  }
  return v1;
}

//----- (100288E5) --------------------------------------------------------
signed int __stdcall sub_100288E5(int a1, int a2, int a3, int a4)
{
  signed int result; // eax@3
  int v5; // edx@5
  char v6; // bl@7
  int v7; // eax@10

  if ( a1 == 4 )
  {
    dword_100693F0 = sub_10028A10(dword_100693F8, a4);
    dword_100693F4 = v5;
    if ( dword_100693F0 == -1 )
      return GetLastError();
    SetLastError(0);
    v6 = sub_100289DD(dword_100693F8, dword_100693F0, dword_100693F4);
    if ( !v6 )
    {
      result = GetLastError();
      if ( result )
        return result;
      v6 = 4;
    }
    v7 = sub_100289AA(dword_100693F8, dword_100693F0, dword_100693F4);
    if ( !v7 )
    {
      result = GetLastError();
      if ( result )
        return result;
      v7 = -1;
    }
    dword_100693E8 = v7;
    byte_100693EC = v6;
  }
  else
  {
    if ( a1 != 5 )
      return 87;
    byte_100693EC = 0;
    dword_100693E8 = 0;
    dword_100693F0 = 0;
    dword_100693F4 = 0;
  }
  return 0;
}
// 100693E8: using guessed type int dword_100693E8;
// 100693EC: using guessed type char byte_100693EC;
// 100693F0: using guessed type int dword_100693F0;
// 100693F4: using guessed type int dword_100693F4;
// 100693F8: using guessed type int dword_100693F8;

//----- (100289AA) --------------------------------------------------------
int __thiscall sub_100289AA(int this, int a2, int a3)
{
  int v3; // esi@1
  int result; // eax@2
  int v5; // eax@2
  int v6; // ST04_4@2

  v3 = *(_DWORD *)(this + 20);
  if ( (PVOID)v3 == EncodePointer(0) )
  {
    SetLastError(0x7Fu);
    result = 0;
  }
  else
  {
    v5 = sub_1002C373(v3);
    result = ((int (__thiscall *)(int, int, int))v5)(v6, a2, a3);
  }
  return result;
}

//----- (100289DD) --------------------------------------------------------
char __thiscall sub_100289DD(int this, int a2, int a3)
{
  int v3; // esi@1
  char result; // al@2
  int v5; // eax@2
  int v6; // ST04_4@2

  v3 = *(_DWORD *)(this + 16);
  if ( (PVOID)v3 == EncodePointer(0) )
  {
    SetLastError(0x7Fu);
    result = 0;
  }
  else
  {
    v5 = sub_1002C373(v3);
    result = ((int (__thiscall *)(int, int, int))v5)(v6, a2, a3);
  }
  return result;
}

//----- (10028A10) --------------------------------------------------------
int __thiscall sub_10028A10(int this, int a2)
{
  int v2; // esi@1
  int result; // eax@2
  int v4; // eax@2
  int v5; // ST00_4@2

  v2 = *(_DWORD *)(this + 12);
  if ( (PVOID)v2 == EncodePointer(0) )
  {
    SetLastError(0x7Fu);
    result = -1;
  }
  else
  {
    v4 = sub_1002C373(v2);
    result = ((int (__thiscall *)(int, int))v4)(v5, a2);
  }
  return result;
}

//----- (10028A40) --------------------------------------------------------
int __thiscall sub_10028A40(void *this, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // esi@1
  int result; // eax@2
  int v8; // eax@2
  int v9; // ST1C_4@2

  v6 = *(_DWORD *)this;
  if ( *(PVOID *)this == EncodePointer(0) )
  {
    result = 127;
  }
  else
  {
    v8 = sub_1002C373(v6);
    result = ((int (__thiscall *)(int, int, _DWORD, int, int, int, _DWORD, _DWORD, int))v8)(
               v9,
               a2,
               0,
               a3,
               a4,
               a5,
               0,
               0,
               a6);
  }
  return result;
}

//----- (10028A7A) --------------------------------------------------------
int __thiscall sub_10028A7A(int this, int a2, int a3, int a4)
{
  int v4; // esi@1
  int result; // eax@2
  int v6; // eax@2
  int v7; // ST08_4@2

  v4 = *(_DWORD *)(this + 8);
  if ( (PVOID)v4 == EncodePointer(0) )
  {
    result = 127;
  }
  else
  {
    v6 = sub_1002C373(v4);
    result = ((int (__thiscall *)(int, int, int, int))v6)(v7, a2, a3, a4);
  }
  return result;
}

//----- (10028AA9) --------------------------------------------------------
int __thiscall sub_10028AA9(int this, int a2, int a3)
{
  int v3; // esi@1
  int result; // eax@2
  int v5; // eax@2
  int v6; // ST04_4@2

  v3 = *(_DWORD *)(this + 4);
  if ( (PVOID)v3 == EncodePointer(0) )
  {
    result = 127;
  }
  else
  {
    v5 = sub_1002C373(v3);
    result = ((int (__thiscall *)(int, int, int))v5)(v6, a2, a3);
  }
  return result;
}

//----- (10028AD5) --------------------------------------------------------
int __thiscall sub_10028AD5(void *this)
{
  int result; // eax@1
  void *v2; // esi@1
  char v3; // [sp+4h] [bp-10h]@3
  int v4; // [sp+Ch] [bp-8h]@2
  void (__cdecl *v5)(); // [sp+10h] [bp-4h]@2

  v2 = this;
  result = *(_DWORD *)this;
  *(_DWORD *)this = 1;
  if ( result )
  {
    v4 = 0;
    v5 = sub_1002C630;
    do
    {
      sub_1001FF20((int)&v3);
      result = *(_DWORD *)v2;
      *(_DWORD *)v2 = 1;
    }
    while ( result );
  }
  return result;
}

//----- (10028B06) --------------------------------------------------------
int *__usercall sub_10028B06<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  if ( !dword_100693F8 )
    sub_10028B1A(a1, a2, a3);
  return &dword_100693E8;
}
// 100693E8: using guessed type int dword_100693E8;
// 100693F8: using guessed type int dword_100693F8;

//----- (10028B1A) --------------------------------------------------------
int __usercall sub_10028B1A<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // eax@2
  void *v6; // eax@3

  sub_1002D0B8();
  *(_DWORD *)(a2 - 16) = &dword_10069CA8;
  sub_10028AD5(&dword_10069CA8);
  *(_DWORD *)(a2 - 4) = 0;
  if ( !dword_100693F8 )
  {
    v5 = sub_10027EB3(v3, v4, a1, a3, 24);
    if ( v5 )
      v6 = sub_10028826((void *)v5);
    else
      v6 = 0;
    dword_100693F8 = (int)v6;
    sub_10028A40(v6, (int)sub_100288E5, (int)&unk_1005BFF0, 7, (int)&off_10066CC0, (int)&dword_10069400);
  }
  dword_10069CA8 = 0;
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10066CC0: using guessed type void *off_10066CC0;
// 100693F8: using guessed type int dword_100693F8;
// 10069400: using guessed type int dword_10069400;
// 10069CA8: using guessed type int dword_10069CA8;

//----- (10028B89) --------------------------------------------------------
int __usercall sub_10028B89<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4, int a5, int a6, int a7)
{
  int result; // eax@1
  int ebp0; // ebp@0
  __int16 v9; // [sp+0h] [bp-7Ch]@3
  char v10; // [sp+2h] [bp-7Ah]@3
  char v11; // [sp+4h] [bp-78h]@3
  char v12; // [sp+5h] [bp-77h]@3
  int v13; // [sp+18h] [bp-64h]@3
  int v14; // [sp+1Ch] [bp-60h]@3
  int v15; // [sp+20h] [bp-5Ch]@3
  int v16; // [sp+24h] [bp-58h]@3
  int v17; // [sp+2Ch] [bp-50h]@3
  int v18; // [sp+30h] [bp-4Ch]@3
  int v19; // [sp+34h] [bp-48h]@3
  int v20; // [sp+38h] [bp-44h]@9
  int v21; // [sp+3Ch] [bp-40h]@11
  unsigned int v22; // [sp+78h] [bp-4h]@1
  int v23; // [sp+7Ch] [bp+0h]@1

  v22 = (unsigned int)&v23 ^ __security_cookie;
  result = (int)sub_10028B06(a1, ebp0, a2);
  if ( *(_BYTE *)(result + 4) >= 4u )
  {
    result = *(_DWORD *)result;
    if ( result & 0x20 )
    {
      sub_10030CF0(&v10, 0, 118);
      v17 = 131072;
      v9 = 120;
      v13 = dword_1005BFE0[0];
      v14 = dword_1005BFE0[1];
      v15 = dword_1005BFE0[2];
      v16 = dword_1005BFE0[3];
      v18 = a4;
      v11 = a3;
      v12 = 4;
      v19 = a5;
      if ( a3 )
      {
        if ( a3 == 2 )
        {
          v20 = a6;
        }
        else
        {
          if ( a3 > 4 )
          {
            if ( a3 > 6 )
            {
              if ( a3 == 7 )
              {
                if ( a6 )
                  sub_1003A3FC(a1, a2, (int)&v20, 32, a6, -1);
              }
              return sub_10028A7A(dword_100693F8, dword_100693F0, dword_100693F4, (int)&v9);
            }
            goto LABEL_11;
          }
        }
        return sub_10028A7A(dword_100693F8, dword_100693F0, dword_100693F4, (int)&v9);
      }
LABEL_11:
      v20 = a6;
      v21 = a7;
      return sub_10028A7A(dword_100693F8, dword_100693F0, dword_100693F4, (int)&v9);
    }
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 100693F0: using guessed type int dword_100693F0;
// 100693F4: using guessed type int dword_100693F4;
// 100693F8: using guessed type int dword_100693F8;

//----- (10028C64) --------------------------------------------------------
int __cdecl sub_10028C64()
{
  int result; // eax@2

  if ( dword_100693F8 )
  {
    byte_100693EC = 0;
    dword_100693E8 = 0;
    sub_10028AA9(dword_100693F8, dword_10069400, dword_10069404);
    result = sub_1002404A((LPVOID)dword_100693F8);
    dword_100693F8 = 0;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 100693E8: using guessed type int dword_100693E8;
// 100693EC: using guessed type char byte_100693EC;
// 100693F8: using guessed type int dword_100693F8;
// 10069400: using guessed type int dword_10069400;
// 10069404: using guessed type int dword_10069404;

//----- (10028CA4) --------------------------------------------------------
int __usercall sub_10028CA4<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  LPVOID v3; // eax@1

  v3 = sub_1002436D(a1, a2, a3);
  return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v3 + 24))(v3);
}

//----- (10028CB5) --------------------------------------------------------
int __usercall sub_10028CB5<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  LPVOID v3; // eax@1

  v3 = sub_1002436D(a1, a2, a3);
  return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v3 + 28))(v3);
}

//----- (10028CC1) --------------------------------------------------------
int __thiscall sub_10028CC1(int this, int a2, char a3)
{
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = a2;
  *(_BYTE *)(this + 12) = a3;
  *(_DWORD *)this = &off_10055DE0;
  return this;
}
// 10055DE0: using guessed type int (__stdcall *off_10055DE0)(char);

//----- (10028CE0) --------------------------------------------------------
void __thiscall sub_10028CE0(int this)
{
  char v1; // zf@1

  v1 = *(_DWORD *)(this + 4) == 0;
  *(_DWORD *)this = &off_10055DE0;
  JUMPOUT(!v1, *(unsigned int *)sub_10028D82);
}
// 10055DE0: using guessed type int (__stdcall *off_10055DE0)(char);

//----- (10028CF1) --------------------------------------------------------
void *__thiscall sub_10028CF1(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_10028CE0(this);
  if ( a2 & 1 )
    sub_1002404A(v2);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10028D10) --------------------------------------------------------
int __stdcall sub_10028D10(int a1, int a2)
{
  return (*(int (**)(void))(*(_DWORD *)a1 + 4))();
}

//----- (10028D1F) --------------------------------------------------------
BOOL __thiscall sub_10028D1F(char *Parameter)
{
  BOOL result; // eax@1
  HANDLE *v2; // esi@1
  DWORD v3; // ST14_4@4
  DWORD v4; // ST10_4@4
  void *v5; // ST0C_4@4
  int v6; // eax@4
  int (__stdcall **v7)(char); // [sp+4h] [bp-10h]@6
  int v8; // [sp+10h] [bp-4h]@6

  result = 0;
  v2 = (HANDLE *)(Parameter + 4);
  if ( !*((_DWORD *)Parameter + 1) )
  {
    if ( Parameter[12] )
      result = *((_DWORD *)Parameter + 2);
    v3 = result;
    v4 = *((_DWORD *)Parameter + 2);
    v5 = Parameter;
    v6 = sub_10024D61();
    result = CreateTimerQueueTimer(v2, (HANDLE)v6, (WAITORTIMERCALLBACK)sub_10028D10, v5, v4, v3, 0x20u);
    if ( !result )
    {
      v8 = (int)"bad allocation";
      sub_100236AC((int)&v7, (int)&v8, 1);
      v7 = &off_100542A4;
      sub_1002D02B((int)&v7, (int)&unk_1005F828);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_10028D82);
    }
  }
  return result;
}
// 100542A4: using guessed type int (__stdcall *off_100542A4)(char);

//----- (10028D82) --------------------------------------------------------
DWORD __thiscall sub_10028D82(int this)
{
  DWORD result; // eax@1
  int v2; // esi@1
  void *v3; // ST04_4@1
  int v4; // eax@1

  v2 = this;
  v3 = *(void **)(this + 4);
  v4 = sub_10024D61();
  result = sub_10032B24((HANDLE)v4, v3, (HANDLE)0xFFFFFFFF);
  *(_DWORD *)(v2 + 4) = 0;
  return result;
}

//----- (10028D9E) --------------------------------------------------------
int __userpurge sub_10028D9E<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned int a4)
{
  int v5; // esi@1
  signed __int64 v7; // qax@1
  int v8; // eax@1
  signed int v9; // ST08_4@1

  v5 = a1;
  _ECX = 0;
  *(_DWORD *)(v5 + 4) = 0;
  *(_DWORD *)v5 = a4;
  v7 = 4i64 * a4;
  __asm { seto    cl }
  v8 = sub_10021CF0(SHIDWORD(v7), v7 | -_ECX, a2, a3, v7 | -_ECX);
  v9 = 4 * *(_DWORD *)v5;
  *(_DWORD *)(v5 + 8) = v8;
  sub_10030CF0((void *)v8, 0, v9);
  return v5;
}

//----- (10028DDC) --------------------------------------------------------
void *__thiscall sub_10028DDC(void *this)
{
  void *v2; // esi@1
  int v3; // edx@1

  v2 = this;
  *(_DWORD *)this = 0;
  v3 = *(_DWORD *)sub_1002416F((int)((char *)this + 4));
  return v2;
}

//----- (10028DF3) --------------------------------------------------------
void *__thiscall sub_10028DF3(void *this, int a2, int a3, int a4)
{
  int ebp0; // ebp@0
  void *v6; // esi@1

  v6 = this;
  sub_100379B1(ebp0, a2, a3, a4);
  *(_DWORD *)v6 = &off_10055EB8;
  *((_DWORD *)v6 + 72) = 0;
  *((_DWORD *)v6 + 73) = (char *)v6 + 288;
  *((_DWORD *)v6 + 74) = 0;
  return v6;
}
// 10055EB8: using guessed type int (__stdcall *off_10055EB8)(char);

//----- (10028E2A) --------------------------------------------------------
void *__thiscall sub_10028E2A(void *this, int a2, int a3, int a4)
{
  int ebp0; // ebp@0
  void *v6; // esi@1

  v6 = this;
  sub_100379B1(ebp0, a2, a3, a4);
  *(_DWORD *)v6 = &off_10055EF8;
  *((_DWORD *)v6 + 72) = 0;
  *((_DWORD *)v6 + 73) = (char *)v6 + 288;
  *((_DWORD *)v6 + 74) = 0;
  return v6;
}
// 10055EF8: using guessed type int (__stdcall *off_10055EF8)(char);

//----- (10028E71) --------------------------------------------------------
int __userpurge sub_10028E71<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  int v5; // esi@1
  unsigned int v7; // eax@1
  int v8; // eax@1
  signed int v9; // ST08_4@1

  v5 = a1;
  _ECX = 0;
  *(_DWORD *)v5 = a4;
  v7 = 4 * ((unsigned int)(a4 + 31) >> 5);
  __asm { seto    cl }
  v8 = sub_10021CF0((a4 + 31) / 0x100u, v7 | -_ECX, a2, a3, v7 | -_ECX);
  v9 = 4 * ((unsigned int)(*(_DWORD *)v5 + 31) >> 5);
  *(_DWORD *)(v5 + 4) = v8;
  sub_10030CF0((void *)v8, 0, v9);
  return v5;
}

//----- (10028EB7) --------------------------------------------------------
int __userpurge sub_10028EB7<eax>(int a1<ebp>, int a2)
{
  int v2; // ebx@1
  int v3; // edi@1
  int v4; // ecx@1
  const void **v5; // ST18_4@1
  int v6; // edx@1
  int v7; // esi@1
  int v8; // eax@2
  DWORD v9; // eax@4
  int v10; // eax@5
  int i; // eax@7
  HANDLE v12; // eax@9
  int v13; // eax@10
  int v14; // eax@14
  int v15; // eax@18
  int v17; // [sp-8h] [bp-8h]@7

  sub_1002D0B8();
  v3 = v4;
  *(_DWORD *)(a1 - 16) = v4;
  v2 = *(_DWORD *)(a1 + 8);
  v5 = *(const void ***)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)v4 = &off_10055E54;
  sub_1003A4D8(v6, v4 + 4, v2, v4, v5);
  *(_DWORD *)(v3 + 48) = 0;
  *(_DWORD *)(v3 + 52) = 0;
  *(_DWORD *)(v3 + 56) = 0;
  *(_DWORD *)(v3 + 60) = 0;
  *(_DWORD *)(v3 + 64) = 0;
  *(_DWORD *)(v3 + 68) = 0;
  *(_DWORD *)(v3 + 72) = 0;
  *(_DWORD *)(v3 + 76) = 0;
  *(_DWORD *)(v3 + 80) = 0;
  *(_DWORD *)(v3 + 84) = 0;
  *(_DWORD *)(v3 + 88) = 0;
  *(_BYTE *)(a1 - 4) = 5;
  sub_100377ED((void *)(v3 + 96), 0, 256, 64);
  *(_DWORD *)(v3 + 180) = 0;
  *(_BYTE *)(a1 - 4) = 6;
  sub_10028DDC((void *)(v3 + 184));
  sub_100377ED((void *)(v3 + 200), 0, 256, 2147483647);
  *(_BYTE *)(a1 - 4) = 7;
  sub_1002417F((LPCRITICAL_SECTION)(v3 + 280));
  *(_BYTE *)(a1 - 4) = 8;
  sub_10028DDC((void *)(v3 + 304));
  *(_DWORD *)(v3 + 316) = 0;
  *(_DWORD *)(v3 + 320) = v3 + 316;
  *(_DWORD *)(v3 + 324) = 0;
  *(_DWORD *)(v3 + 328) = -1;
  *(_DWORD *)(v3 + 332) = -1;
  *(_DWORD *)(v3 + 336) = 0;
  *(_DWORD *)(v3 + 340) = 0;
  *(_DWORD *)(v3 + 344) = 0;
  sub_10028D9E(v3 + 348, v2, v3, 0x1001u);
  *(_BYTE *)(a1 - 4) = 9;
  sub_10028D9E(v3 + 360, v2, v3, 0x1001u);
  *(_DWORD *)(v3 + 372) = -1;
  *(_DWORD *)(v3 + 376) = 0;
  *(_DWORD *)(v3 + 384) = 0;
  *(_DWORD *)(v3 + 388) = 0;
  *(_DWORD *)(v3 + 392) = 1;
  *(_DWORD *)(v3 + 396) = 0;
  *(_DWORD *)(v3 + 400) = 0;
  *(_DWORD *)(v3 + 404) = 0;
  *(_BYTE *)(a1 - 4) = 10;
  *(_DWORD *)(v3 + 408) = 0;
  *(_DWORD *)(v3 + 412) = 0;
  *(_DWORD *)(v3 + 416) = 0;
  *(_DWORD *)(v3 + 424) = 0;
  *(_DWORD *)(v3 + 432) = 0;
  *(_DWORD *)(v3 + 436) = 0;
  *(_DWORD *)(v3 + 440) = 0;
  *(_DWORD *)(v3 + 444) = 0;
  *(_DWORD *)(v3 + 448) = 0;
  *(_DWORD *)(v3 + 456) = 0;
  *(_DWORD *)(v3 + 472) = 0;
  InitializeSListHead((PSLIST_HEADER)(v3 + 480));
  InitializeSListHead((PSLIST_HEADER)(v3 + 488));
  InitializeSListHead((PSLIST_HEADER)(v3 + 496));
  InitializeSListHead((PSLIST_HEADER)(v3 + 504));
  *(_DWORD *)(v3 + 132) = v3;
  *(_DWORD *)(v3 + 8) = sub_1003A576((void *)v2, 0);
  *(_WORD *)(v3 + 16) = sub_1003A576((void *)v2, 4u);
  *(_DWORD *)(v3 + 12) = sub_1003A576((void *)v2, 7u);
  v7 = sub_1003A576((void *)v2, 1u);
  if ( 4 * sub_10034C38() <= (unsigned int)v7 )
    v8 = sub_1003A576((void *)v2, 1u);
  else
    v8 = 4 * sub_10034C38();
  *(_DWORD *)(v3 + 452) = v8;
  v9 = TlsAlloc();
  *(_DWORD *)(v3 + 24) = v9;
  if ( v9 != -1 )
    goto LABEL_9;
  v10 = GetLastError();
  if ( v10 > 0 )
    v10 = (unsigned __int16)v10 | 0x80070000;
  sub_100249F4(a1 - 32, v10);
  v17 = (int)&unk_10060498;
  for ( i = a1 - 32; ; i = a1 - 80 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        sub_1002D02B(i, v17);
LABEL_9:
        v12 = CreateEventW(0, 0, 0, 0);
        *(_DWORD *)(v3 + 460) = v12;
        if ( v12 )
          break;
        v13 = GetLastError();
        if ( v13 > 0 )
          v13 = (unsigned __int16)v13 | 0x80070000;
        sub_100249F4(a1 - 48, v13);
        v17 = (int)&unk_10060498;
        i = a1 - 48;
      }
      if ( RegisterWaitForSingleObject(
             (PHANDLE)(v3 + 464),
             v12,
             (WAITORTIMERCALLBACK)sub_1002BF72,
             (PVOID)v3,
             0xFFFFFFFFu,
             0) )
        break;
      v14 = GetLastError();
      if ( v14 > 0 )
        v14 = (unsigned __int16)v14 | 0x80070000;
      sub_100249F4(a1 - 64, v14);
      v17 = (int)&unk_10060498;
      i = a1 - 64;
    }
    if ( CreateTimerQueueTimer(
           (PHANDLE)(v3 + 468),
           0,
           (WAITORTIMERCALLBACK)sub_1002BF63,
           (PVOID)v3,
           0x7FFFFFFFu,
           0x7FFFFFFFu,
           0) )
      break;
    v15 = GetLastError();
    if ( v15 > 0 )
      v15 = (unsigned __int16)v15 | 0x80070000;
    sub_100249F4(a1 - 80, v15);
    v17 = (int)&unk_10060498;
  }
  return sub_1002D086(68);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10055E54: using guessed type int (__stdcall *off_10055E54)(char);

//----- (100291C2) --------------------------------------------------------
void *__thiscall sub_100291C2(void *this)
{
  void *v2; // esi@1

  v2 = this;
  sub_1002832E((int)((char *)this + 4), 8, 96, sub_10028631, (int)sub_10028646);
  *((_BYTE *)v2 + 772) = 0;
  return v2;
}

//----- (100291E7) --------------------------------------------------------
int __userpurge sub_100291E7<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_100559EC;
  return v4;
}
// 100559EC: using guessed type int (__stdcall *off_100559EC)(char);

//----- (10029202) --------------------------------------------------------
int __userpurge sub_10029202<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_100559F8;
  return v4;
}
// 100559F8: using guessed type int (__stdcall *off_100559F8)(char);

//----- (1002921D) --------------------------------------------------------
int __userpurge sub_1002921D<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // edi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_100559C8;
  *(_DWORD *)(v4 + 12) = *(_DWORD *)(a3 + 12);
  return v4;
}
// 100559C8: using guessed type int (__stdcall *off_100559C8)(char);

//----- (10029254) --------------------------------------------------------
int __thiscall sub_10029254(PSLIST_HEADER ListHead)
{
  int v1; // ebx@1
  PSLIST_HEADER v2; // edi@1
  int v3; // eax@1
  int v4; // eax@1
  int i; // esi@2
  int v6; // ecx@3
  int v7; // esi@6

  v2 = ListHead;
  v3 = (int)InterlockedFlushSList(ListHead);
  sub_10029CD8(v3);
  v4 = (int)InterlockedFlushSList(v2 + 1);
  sub_10029CD8(v4);
  sub_10029CD8(LODWORD(v2[2].Alignment));
  v1 = LODWORD(v2[6].Alignment);
  if ( v1 )
  {
    do
    {
      for ( i = 0; i < LODWORD(v2[5].Alignment); ++i )
      {
        v6 = *(_DWORD *)(*(_DWORD *)v1 + 4 * i);
        if ( v6 )
          (*(void (__stdcall **)(signed int))(*(_DWORD *)v6 + 16))(1);
      }
      v7 = *(_DWORD *)(v1 + 4);
      sub_1002401B(*(LPVOID *)v1);
      sub_1002404A((LPVOID)v1);
      v1 = v7;
    }
    while ( v7 );
  }
  return sub_1002401B(HIDWORD(v2[6].Alignment));
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (100292CB) --------------------------------------------------------
int __thiscall sub_100292CB(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002401B(*(LPVOID *)(this + 12));
  return sub_1002401B(*(LPVOID *)(v2 + 4));
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (100292E2) --------------------------------------------------------
int __thiscall sub_100292E2(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002401B(*(LPVOID *)(this + 8));
  return sub_1002401B(*(LPVOID *)(v2 + 4));
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (10029307) --------------------------------------------------------
#error "100293AF: call analysis failed (funcsize=43)"

//----- (100293B5) --------------------------------------------------------
int __thiscall sub_100293B5(int this, char a2)
{
  void *v2; // esi@1
  int result; // eax@4

  v2 = (void *)this;
  if ( a2 & 2 )
  {
    sub_10023E14(this, 16, *(_DWORD *)(this - 4), sub_100292CB);
    if ( a2 & 1 )
      sub_1002401B((char *)v2 - 4);
    result = (int)((char *)v2 - 4);
  }
  else
  {
    sub_100292CB(this);
    if ( a2 & 1 )
      sub_1002404A(v2);
    result = (int)v2;
  }
  return result;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (100293FF) --------------------------------------------------------
void *__thiscall sub_100293FF(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10055E44;
  if ( a2 & 1 )
    sub_1002404A(this);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10055E44: using guessed type int (__stdcall *off_10055E44)(char);

//----- (1002941F) --------------------------------------------------------
void *__thiscall sub_1002941F(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10055E0C;
  if ( a2 & 1 )
    sub_1002404A(this);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10055E0C: using guessed type int (__stdcall *off_10055E0C)(char);

//----- (1002943F) --------------------------------------------------------
void *__thiscall sub_1002943F(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_10029307(this);
  if ( a2 & 1 )
    sub_1002404A(v2);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10029307: using guessed type _DWORD __thiscall sub_10029307(_DWORD ecx0);

//----- (1002945E) --------------------------------------------------------
void *__thiscall sub_1002945E(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_10023E14((int)((char *)this + 4), 8, 96, (void (__thiscall *)(_DWORD))sub_10028646);
  if ( a2 & 1 )
    sub_1002404A(v2);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1002948A) --------------------------------------------------------
int __thiscall sub_1002948A(int this, int a2)
{
  signed int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // edx@3
  int v12; // ecx@11
  signed __int64 v15; // qax@11
  signed int v16; // ST0C_4@11
  int v17; // edx@11
  int v18; // ecx@11
  int v19; // eax@12
  int v28; // edx@17
  char v30; // [sp+Ch] [bp-20h]@22
  int v31; // [sp+14h] [bp-18h]@21
  BOOL (__cdecl *v32)(); // [sp+18h] [bp-14h]@21
  int v33; // [sp+1Ch] [bp-10h]@5
  int v34; // [sp+20h] [bp-Ch]@2
  int v35; // [sp+24h] [bp-8h]@1
  char v36; // [sp+2Bh] [bp-1h]@1

  v5 = this;
  v3 = *(_DWORD *)(this + 48);
  v36 = 0;
  v4 = 0;
  v35 = v3;
  v2 = 4;
  do
  {
    _EBX = v3 + 8;
    v34 = v3 + 8;
    if ( *(_DWORD *)(v3 + 8) >= -1 )
    {
      _EBX = *(_DWORD *)v3;
      v7 = 0;
      if ( *(_DWORD *)(v5 + 40) <= 0 )
      {
LABEL_7:
        _EBX = v34;
      }
      else
      {
        while ( *(_DWORD *)_EBX )
        {
          ++v7;
          _EBX += v2;
          if ( v7 >= *(_DWORD *)(v5 + 40) )
            goto LABEL_7;
        }
        _ECX = a2;
        *(_DWORD *)(a2 + 24) = v7 + v4;
        v33 = *(_DWORD *)(v5 + 64);
        __asm { lock cmpxchg [ebx], ecx }
        v4 += v7;
        v36 = 1;
        if ( v4 >= v33 )
        {
          _EAX = v5 + 64;
          _ECX = 1;
          __asm { lock xadd [eax], ecx }
        }
        _EBX = v34;
        _ECX = -1;
        __asm { lock cmpxchg [ebx], ecx }
      }
      v3 = v35;
    }
    if ( !v36 )
    {
      _ECX = -2;
      __asm { lock cmpxchg [ebx], ecx }
      v4 += *(_DWORD *)(v5 + 40);
      _EBX = v3 + 4;
      if ( !*(_DWORD *)(v3 + 4) )
      {
        _ECX = 1;
        __asm { lock cmpxchg [ebx], ecx }
        _ECX = 0;
        v15 = 4i64 * *(_DWORD *)(v5 + 40);
        __asm { seto    cl }
        v16 = 4 * *(_DWORD *)(v5 + 40);
        v33 = sub_10021CF0(SHIDWORD(v15), v15 | -_ECX, _EBX, v4, v15 | -_ECX);
        sub_10030CF0((void *)v33, 0, v16);
        v12 = sub_10027EB3(v17, v18, _EBX, v4, 12);
        if ( v12 )
        {
          v19 = v33;
          *(_DWORD *)(v12 + 4) = 0;
          *(_DWORD *)(v12 + 8) = -1;
          *(_DWORD *)v12 = v19;
        }
        else
        {
          v12 = 0;
        }
        v28 = *(_DWORD *)(v5 + 60);
        if ( v28 < *(_DWORD *)(v5 + 56) )
        {
          *(_DWORD *)(*(_DWORD *)(v5 + 52) + 4 * v28) = v12;
          ++*(_DWORD *)(v5 + 60);
        }
        *(_DWORD *)_EBX = v12;
        v3 = v35;
      }
      if ( *(_DWORD *)_EBX == 1 )
      {
        v31 = 0;
        v32 = sub_1002C66E;
        do
          sub_1001FF20((int)&v30);
        while ( *(_DWORD *)_EBX == 1 );
        v3 = v35;
      }
    }
    v3 = *(_DWORD *)(v3 + 4);
    v35 = v3;
    v2 = 4;
  }
  while ( !v36 );
  return v4;
}

//----- (100295E3) --------------------------------------------------------
int __userpurge sub_100295E3<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // eax@1
  int v6; // esi@1

  v6 = a2;
  v5 = sub_10027EB3(a1, a2, a3, a4, 8);
  if ( v5 )
    *(_DWORD *)(v5 + 4) = a5;
  else
    v5 = 0;
  return sub_1002B27B((void *)(v6 + 180), v5);
}

//----- (10029610) --------------------------------------------------------
int __thiscall sub_10029610(void *this, int a2)
{
  int result; // eax@2

  if ( *(_DWORD *)this )
  {
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(*(_DWORD *)this + 4);
    *(_DWORD *)(a2 + 8) = *(_DWORD *)this;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)this + 4) + 8) = a2;
    result = *(_DWORD *)this;
    *(_DWORD *)(*(_DWORD *)this + 4) = a2;
  }
  else
  {
    *(_DWORD *)this = a2;
    *(_DWORD *)(a2 + 8) = a2;
    result = *(_DWORD *)this;
    *(_DWORD *)(result + 4) = result;
  }
  return result;
}

//----- (10029649) --------------------------------------------------------
int __thiscall sub_10029649(void *this, int a2)
{
  int result; // eax@1

  result = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    *(_DWORD *)a2 = *(_DWORD *)result;
    *(_DWORD *)(a2 + 4) = *(_DWORD *)this;
    *(_DWORD *)(**(_DWORD **)this + 4) = a2;
    result = *(_DWORD *)this;
    **(_DWORD **)this = a2;
  }
  else
  {
    *(_DWORD *)a2 = a2;
    *(_DWORD *)(a2 + 4) = a2;
  }
  *(_DWORD *)this = a2;
  return result;
}

//----- (10029676) --------------------------------------------------------
int __thiscall sub_10029676(int this, int a2)
{
  int v3; // edi@1

  v3 = this;
  sub_10024558((void *)(this + 4));
  sub_10029649((void *)v3, a2);
  return sub_10024692((void *)(v3 + 4));
}

//----- (1002969D) --------------------------------------------------------
int __thiscall sub_1002969D(void *this, int a2, unsigned int a3)
{
  int result; // eax@1
  void *v4; // edi@1
  unsigned int v5; // esi@2
  int *v6; // eax@3
  unsigned int v7; // ebx@4
  int v8; // eax@5
  int v9; // ecx@5
  int v17; // [sp-4h] [bp-34h]@3
  int (__stdcall **v18)(char); // [sp+Ch] [bp-24h]@3
  int (__stdcall **v19)(char); // [sp+18h] [bp-18h]@9
  int v20; // [sp+24h] [bp-Ch]@5
  int v21; // [sp+28h] [bp-8h]@5
  int v22; // [sp+2Ch] [bp-4h]@3

  result = a2;
  v4 = this;
  if ( !a2 )
  {
    a3 = (unsigned int)"ppVirtualProcessorRoots";
    sub_10023687((int)&v19, (int *)&a3);
    v19 = &off_100542CC;
    v17 = (int)&unk_10061764;
    v6 = (int *)&v19;
    goto LABEL_10;
  }
  v5 = a3;
  if ( a3 < 1 )
  {
    v22 = (int)"count";
    sub_10023687((int)&v18, &v22);
    v18 = &off_100542CC;
    v17 = (int)&unk_10061764;
    v6 = (int *)&v18;
LABEL_10:
    sub_1002D02B((int)v6, v17);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10029761);
  }
  v7 = 0;
  if ( a3 )
  {
    do
    {
      v20 = *(_DWORD *)(result + 4 * v7);
      v8 = (**(int (***)(void))v20)();
      v9 = *((_DWORD *)v4 + 9);
      v21 = v8;
      if ( !*(_DWORD *)(*(_DWORD *)(v9 + 4 * v8) + 188) )
      {
        sub_1003CE6F(*(_DWORD *)(*((_DWORD *)v4 + 9) + 4 * v8));
        v8 = v21;
      }
      sub_1003B6DA(*(void **)(*((_DWORD *)v4 + 8) + 4 * v8), v20, 0);
      _EAX = 1;
      _ECX = (int)((char *)v4 + 20);
      __asm { lock xadd [ecx], eax }
      result = a2;
      ++v7;
    }
    while ( v7 < v5 );
  }
  return result;
}
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);

//----- (10029761) --------------------------------------------------------
int __userpurge sub_10029761<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@1

  sub_1002D0B8();
  v6 = v7;
  v5 = sub_10027EB3(v8, v7, a1, a3, 304);
  *(_DWORD *)(a2 - 16) = v5;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v5 )
    sub_10028DF3((void *)v5, v6, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12));
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1002979C) --------------------------------------------------------
int __userpurge sub_1002979C<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // ecx@1
  int v7; // edx@1

  sub_1002D0B8();
  v5 = v6;
  *(_DWORD *)(a2 - 32) = 0;
  *(_DWORD *)(a2 - 24) = 0;
  *(_DWORD *)(a2 - 20) = 0;
  v4 = sub_10027EB3(v7, v6, a1, v6, 304);
  *(_DWORD *)(a2 - 16) = v4;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v4 )
    sub_10028E2A((void *)v4, v5, *(_DWORD *)(a2 + 8), a2 - 32);
  return sub_1002D086(20);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (100297E5) --------------------------------------------------------
char __cdecl sub_100297E5()
{
  return 1;
}

//----- (100297E8) --------------------------------------------------------
int __usercall sub_100297E8<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-Ch]@3

  v2 = a1;
  if ( sub_10029DDB() == a1 )
  {
    sub_100248E2((int)&v4);
    sub_1002D02B((int)&v4, (int)&unk_10060508);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1002982E);
  }
  sub_1002982E((void *)v2, a2, 1);
  return sub_1002C0BC(7, 4, *(_DWORD *)(v2 + 372));
}

//----- (1002982E) --------------------------------------------------------
int __userpurge sub_1002982E<eax>(void *a1<ecx>, int a2<ebx>, int a3)
{
  LPVOID v3; // eax@1
  int ebp0; // ebp@0
  int v5; // edi@1
  void *v6; // esi@1
  int v8; // esi@6
  char v9; // [sp+8h] [bp-Ch]@7

  v6 = a1;
  v3 = sub_10029DCE();
  v5 = (int)v3;
  if ( v3 )
  {
    if ( *((void **)v3 + 7) == v6 )
    {
      sub_100248E2((int)&v9);
      sub_1002D02B((int)&v9, (int)&unk_10060508);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_10029897);
    }
    if ( !*((_BYTE *)v3 + 76) )
      sub_1003C412((char *)v3 - 4);
    sub_10026FEC();
  }
  sub_1002B3B7(v6);
  v8 = sub_1002A31E(a2, ebp0, a3);
  sub_10027537((LPVOID)v8, v5);
  return v8;
}

//----- (10029897) --------------------------------------------------------
BOOL __thiscall sub_10029897(void *this)
{
  _ESI = -1073741824;
  _EDX = (char *)this + 404;
  __asm { lock cmpxchg [edx], esi }
  return sub_1002BDB4(this);
}

//----- (100298BA) --------------------------------------------------------
int __thiscall sub_100298BA(void *this)
{
  int result; // eax@1
  int i; // esi@1
  int v3; // esi@1
  int v4; // ecx@1

  v3 = (int)this;
  sub_10027846(this);
  sub_1002B571(v3);
  result = sub_10027846(v4);
  for ( i = *(_DWORD *)(v3 + 180); i; i = *(_DWORD *)i )
    result = (*(int (**)(void))(**(_DWORD **)(i + 4) + 24))();
  return result;
}
// 10027846: using guessed type _DWORD __thiscall sub_10027846(_DWORD ecx0);

//----- (10029942) --------------------------------------------------------
int __cdecl sub_10029942(int a1)
{
  int result; // eax@1

  result = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 404) & 0xA0000000;
  if ( result != -1610612736 )
  {
    sub_10029CBA(*(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    *(_DWORD *)(a1 + 72) = 0;
  }
  return result;
}

//----- (1002994E) --------------------------------------------------------
int __cdecl sub_1002994E(int a1)
{
  int result; // eax@1

  result = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 404) & 0xA0000000;
  if ( result != -1610612736 )
  {
    sub_10029CD8(*(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    *(_DWORD *)(a1 + 72) = 0;
  }
  return result;
}

//----- (1002995A) --------------------------------------------------------
int __cdecl sub_1002995A()
{
  int result; // eax@1

  _ESI = &dword_10066D24;
  _EAX = -1;
  __asm { lock xadd [esi], eax }
  result = _EAX - 1;
  if ( result == -2147483648 )
  {
    sub_1002AFAF();
    result = 2147483647;
    __asm { lock and [esi], eax }
  }
  return result;
}
// 10066D24: using guessed type int dword_10066D24;

//----- (1002997E) --------------------------------------------------------
int __usercall sub_1002997E<eax>(int a1<ebp>)
{
  int v1; // eax@1

  sub_1002D0B8();
  *(_DWORD *)(a1 - 16) = &dword_10069CAC;
  sub_10028AD5(&dword_10069CAC);
  v1 = dword_10069420;
  *(_DWORD *)(a1 - 4) = 0;
  dword_10069420 = v1 + 1;
  if ( dword_10069420 == 1 )
  {
    sub_1002BC18();
    _ESI = -2147483648;
    if ( !(dword_10066D24 & 0x80000000) )
    {
      sub_1002AF61();
      _EAX = &dword_10066D24;
      __asm { lock or [eax], esi }
    }
  }
  dword_10069CAC = 0;
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10066D24: using guessed type int dword_10066D24;
// 10069420: using guessed type int dword_10069420;
// 10069CAC: using guessed type int dword_10069CAC;

//----- (100299DA) --------------------------------------------------------
int __usercall sub_100299DA<eax>(int a1<ecx>, int a2<ebp>)
{
  int i; // edi@1
  int v3; // esi@1
  void *v4; // ebx@2
  int j; // edi@5
  void *v6; // ebx@6
  int v7; // ecx@9
  int v8; // ecx@11
  char v9; // zf@11
  PSINGLE_LIST_ENTRY v10; // eax@14

  v3 = a1;
  for ( i = 0; i < *(_DWORD *)(v3 + 44); ++i )
  {
    v4 = *(void **)(*(_DWORD *)(v3 + 32) + 4 * i);
    if ( v4 )
    {
      sub_1003B541(a2);
      sub_1002404A(v4);
    }
  }
  for ( j = 0; j < *(_DWORD *)(v3 + 44); ++j )
  {
    v6 = *(void **)(*(_DWORD *)(v3 + 36) + 4 * j);
    if ( v6 )
    {
      sub_1003CE3C(a2);
      sub_1002404A(v6);
    }
  }
  sub_1002401B(*(LPVOID *)(v3 + 92));
  sub_1002401B(*(LPVOID *)(v3 + 32));
  sub_1002401B(*(LPVOID *)(v3 + 36));
  v7 = *(_DWORD *)(v3 + 28);
  if ( v7 )
    sub_100293B5(v7, 3);
  TlsFree(*(_DWORD *)(v3 + 24));
  v8 = *(_DWORD *)(v3 + 416);
  *(_DWORD *)(v3 + 24) = 0;
  (*(void (**)(void))(*(_DWORD *)v8 + 4))();
  sub_1002D0B8();
  *(_DWORD *)(a2 - 16) = &dword_10069CAC;
  sub_10028AD5(&dword_10069CAC);
  *(_DWORD *)(a2 - 4) = 0;
  v9 = dword_10069420-- == 1;
  if ( v9 )
  {
    sub_10028C64();
    while ( 1 )
    {
      v10 = InterlockedPopEntrySList(&ListHead);
      if ( !v10 )
        break;
      sub_1002945E(v10, 1);
    }
  }
  dword_10069CAC = 0;
  return sub_1002D086(4);
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10069420: using guessed type int dword_10069420;
// 10069CAC: using guessed type int dword_10069CAC;

//----- (10029A72) --------------------------------------------------------
int __thiscall sub_10029A72(int this)
{
  signed int i; // eax@1
  void *v2; // ebx@1
  int v3; // edi@1
  int result; // eax@3
  unsigned int v5; // esi@3

  v3 = this;
  v2 = (void *)(this + 324);
  sub_1002C615((void *)(this + 324));
  for ( i = sub_1002C191(v3); ; i = sub_1002C149(v3, v5) )
  {
    v5 = i;
    result = sub_1002C625(v2);
    if ( !v5 )
      break;
    sub_10029AB5(v3, v5);
    sub_1002C615(v2);
  }
  return result;
}

//----- (10029AB5) --------------------------------------------------------
int __thiscall sub_10029AB5(int this, unsigned int a2)
{
  int v2; // eax@1
  int v3; // ebx@1
  int v4; // edi@1
  unsigned int v5; // eax@3
  int v6; // eax@5
  int v7; // esi@5
  int result; // eax@7
  int v9; // eax@8
  int v10; // [sp+8h] [bp-Ch]@1
  int *v11; // [sp+Ch] [bp-8h]@1
  int v12; // [sp+10h] [bp-4h]@1

  v10 = 0;
  v4 = this;
  v3 = this + 324;
  v11 = &v10;
  v12 = this + 324;
  sub_1002C615((void *)(this + 324));
  v2 = *(_DWORD *)(v4 + 316);
  if ( v2 )
  {
    do
    {
      if ( a2 )
      {
        v5 = *(_DWORD *)(v2 + 8);
        if ( v5 < *(_DWORD *)(v4 + 340) )
          break;
        if ( v5 > a2 )
          break;
      }
      v6 = sub_10029D17((void *)(v4 + 316));
      v7 = v6 + 12;
      *(_DWORD *)(v6 + 12) = 0;
      *v11 = v6;
      v2 = *(_DWORD *)(v4 + 316);
      v11 = (int *)v7;
    }
    while ( v2 );
    v3 = v12;
  }
  result = sub_1002C625((void *)v3);
  while ( v10 )
  {
    v9 = sub_10029D17(&v10);
    result = (*(int (__cdecl **)(_DWORD))v9)(*(_DWORD *)(v9 + 4));
  }
  return result;
}

//----- (10029B42) --------------------------------------------------------
signed int __thiscall sub_10029B42(int this)
{
  int v1; // ebx@1
  signed int v2; // edi@1
  int v3; // esi@1
  int v4; // eax@2
  signed int v5; // ecx@3
  int v6; // eax@4
  int v7; // eax@5
  signed int v8; // eax@6
  int v10; // [sp+Ch] [bp-10h]@2
  int v11; // [sp+10h] [bp-Ch]@1
  signed int v12; // [sp+14h] [bp-8h]@3
  char v13; // [sp+1Bh] [bp-1h]@1

  v1 = this;
  v3 = 0;
  v2 = 0;
  v13 = 0;
  v11 = 0;
  if ( *(_DWORD *)(this + 44) > 0 )
  {
    while ( 1 )
    {
      v4 = *(_DWORD *)(*(_DWORD *)(v1 + 32) + 4 * v3);
      v10 = v4;
      if ( v4 )
      {
        v5 = 0;
        v12 = 0;
        if ( *(_DWORD *)(v4 + 120) > 0 )
          break;
      }
LABEL_15:
      ++v3;
      v11 = v3;
      if ( v3 >= *(_DWORD *)(v1 + 44) )
        return v2;
    }
    v6 = v4 + 56;
    while ( 1 )
    {
      v7 = sub_10037C97(v6, v5);
      if ( v7 )
      {
        v8 = *(_DWORD *)(v7 + 180);
        if ( (unsigned int)v8 < *(_DWORD *)(v1 + 340) )
          v8 = -1;
        if ( !v13 )
        {
          v13 = 1;
LABEL_12:
          v2 = v8;
          goto LABEL_13;
        }
        if ( v2 > (unsigned int)v8 )
          goto LABEL_12;
      }
LABEL_13:
      v5 = v12 + 1;
      v12 = v5;
      v6 = v10 + 56;
      if ( v5 >= *(_DWORD *)(v10 + 120) )
      {
        v3 = v11;
        goto LABEL_15;
      }
    }
  }
  return v2;
}

//----- (10029BCB) --------------------------------------------------------
int __userpurge sub_10029BCB<eax>(int a1<ecx>, int a2<edi>, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  unsigned int v5; // edx@3
  unsigned int v6; // edi@3

  result = *(_DWORD *)a3;
  v4 = a1;
  if ( *(_DWORD *)a1 != *(_DWORD *)a3 )
    result = sub_1002B2FD(a1, a3, a2, *(_DWORD *)a3);
  v5 = (unsigned int)(*(_DWORD *)v4 + 31) >> 5;
  v6 = 0;
  if ( v5 )
  {
    do
    {
      result = *(_DWORD *)(*(_DWORD *)(a3 + 4) + 4 * v6);
      *(_DWORD *)(*(_DWORD *)(v4 + 4) + 4 * v6++) = result;
    }
    while ( v6 < v5 );
  }
  return result;
}

//----- (10029C28) --------------------------------------------------------
int __stdcall sub_10029C28(int a2)
{
  int v2; // ST00_4@1

  return sub_1002AC7E(v2, a2);
}

//----- (10029C31) --------------------------------------------------------
int __cdecl sub_10029C31()
{
  int ebp0; // ebp@0
  int v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+8h] [bp-8h]@1
  int v4; // [sp+Ch] [bp-4h]@1

  v2 = 0;
  v3 = 0;
  v4 = 0;
  return sub_1002AC7E(ebp0, (int)&v2);
}

//----- (10029C4D) --------------------------------------------------------
int __usercall sub_10029C4D<eax>(int a1<ebx>, int a2<edi>, void *a3)
{
  int v3; // eax@1
  int ebp0; // ebp@0
  int result; // eax@2

  sub_1003A7E3(a3);
  sub_1002997E(ebp0);
  v3 = sub_1003D765(a1, ebp0, a2);
  if ( v3 )
    result = v3 + 8;
  else
    result = 0;
  return result;
}

//----- (10029C73) --------------------------------------------------------
int __usercall sub_10029C73<eax>(int this<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>)
{
  int v4; // eax@1

  v4 = (int)sub_1002436D(a2, a3, a4);
  return sub_1002729E(v4);
}

//----- (10029C7F) --------------------------------------------------------
int __thiscall sub_10029C7F(int this)
{
  int result; // eax@1

  result = this + 392;
  _EDX = -1;
  __asm { lock xadd [eax], edx }
  if ( _EDX == 1 )
    result = sub_10029E0B(this);
  return result;
}

//----- (10029C9A) --------------------------------------------------------
BOOL __thiscall sub_10029C9A(int this)
{
  BOOL result; // eax@1

  _EDX = this + 472;
  _EAX = 1;
  __asm { lock xadd [edx], eax }
  result = _EAX + 1;
  if ( result == 1 )
    result = SetEvent(*(HANDLE *)(this + 460));
  return result;
}

//----- (10029CBA) --------------------------------------------------------
int __stdcall sub_10029CBA(int a1)
{
  int v1; // esi@1
  void *v2; // eax@2
  int result; // eax@2

  v1 = a1;
  while ( v1 )
  {
    v2 = (void *)(v1 - 4);
    v1 = *(_DWORD *)v1;
    result = sub_1002404A(v2);
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10029CD8) --------------------------------------------------------
int __stdcall sub_10029CD8(int a1)
{
  int v1; // esi@1
  int v2; // ecx@2
  int result; // eax@3

  v1 = a1;
  while ( v1 )
  {
    v2 = v1 - 52;
    v1 = *(_DWORD *)v1;
    if ( v2 )
      result = (*(int (__stdcall **)(signed int))(*(_DWORD *)v2 + 16))(1);
  }
  return result;
}

//----- (10029CFA) --------------------------------------------------------
int __thiscall sub_10029CFA(void *this)
{
  void *v1; // eax@1
  int v2; // edx@1
  int result; // eax@2
  int v4; // ecx@3

  v1 = this;
  v2 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    v4 = *(_DWORD *)(v2 + 232);
    *(_DWORD *)v1 = v4;
    if ( !v4 )
      *((_DWORD *)v1 + 1) = v1;
    result = v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10029D17) --------------------------------------------------------
int __thiscall sub_10029D17(void *this)
{
  void *v1; // eax@1
  int v2; // edx@1
  int result; // eax@2
  int v4; // ecx@3

  v1 = this;
  v2 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    v4 = *(_DWORD *)(v2 + 12);
    *(_DWORD *)v1 = v4;
    if ( !v4 )
      *((_DWORD *)v1 + 1) = v1;
    result = v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10029D54) --------------------------------------------------------
int __thiscall sub_10029D54(int this)
{
  int v2; // esi@1

  v2 = this;
  UnregisterWaitEx(*(HANDLE *)(this + 464), (HANDLE)0xFFFFFFFF);
  sub_10032B24(0, *(HANDLE *)(v2 + 468), (HANDLE)0xFFFFFFFF);
  CloseHandle(*(HANDLE *)(v2 + 460));
  return sub_10029C7F(v2);
}

//----- (10029D8B) --------------------------------------------------------
char __thiscall sub_10029D8B(void *this, int a2, char a3)
{
  int v3; // edi@1
  int v4; // esi@1
  char result; // al@3

  v4 = 0;
  v3 = (int)this;
  if ( a3 )
    v4 = sub_10027473(a2);
  sub_1002B494(v3, a2);
  result = sub_1002B4DB((void *)v3);
  if ( v4 )
  {
    result = *(_BYTE *)(v4 + 76);
    if ( !result )
      result = sub_1003C66C((void *)(v4 - 4));
  }
  return result;
}

//----- (10029DCE) --------------------------------------------------------
LPVOID __cdecl sub_10029DCE()
{
  return TlsGetValue(dwTlsIndex);
}

//----- (10029DDB) --------------------------------------------------------
int __cdecl sub_10029DDB()
{
  int v1; // eax@1
  int result; // eax@2

  v1 = (int)sub_10029DCE();
  if ( v1 )
    result = sub_1002729E(v1);
  else
    result = 0;
  return result;
}

//----- (10029DEE) --------------------------------------------------------
int __thiscall sub_10029DEE(int this)
{
  unsigned int v1; // edx@1
  unsigned int v2; // esi@1
  int result; // eax@2

  v1 = (unsigned int)(*(_DWORD *)this + 31) >> 5;
  v2 = 0;
  if ( v1 )
  {
    do
    {
      result = *(_DWORD *)(this + 4);
      *(_DWORD *)(result + 4 * v2++) = -1;
    }
    while ( v2 < v1 );
  }
  return result;
}

//----- (10029E0B) --------------------------------------------------------
int __thiscall sub_10029E0B(int this)
{
  int v1; // ecx@1
  int v2; // edi@1
  int v3; // esi@1
  int v4; // ecx@2
  int v5; // ebx@2
  int v6; // ST08_4@4
  int v7; // ecx@5
  int v8; // eax@5
  int v9; // esi@6
  int v10; // ecx@7
  PSINGLE_LIST_ENTRY v11; // eax@7
  int v12; // esi@8
  void *v13; // esi@10

  v2 = this;
  (*(void (**)(void))(**(_DWORD **)(this + 420) + 4))();
  CloseHandle(*(HANDLE *)(v2 + 380));
  v3 = *(_DWORD *)(v2 + 180);
  *(_DWORD *)(v2 + 180) = 0;
  if ( v3 )
  {
    do
    {
      v4 = *(_DWORD *)(v3 + 4);
      v5 = *(_DWORD *)v3;
      if ( v4 )
        (*(void (__stdcall **)(signed int))(*(_DWORD *)(v4 + 4) + 20))(1);
      sub_1002404A((LPVOID)v3);
      v1 = v6;
      v3 = v5;
    }
    while ( v5 );
  }
  v8 = ((int (__thiscall *)(int, int))InterlockedFlushSList)(v1, v2 + 488);
  v7 = v8 != 0 ? v8 - 4 : 0;
  if ( v7 )
  {
    do
    {
      v9 = *(_DWORD *)(v7 + 4) != 0 ? *(_DWORD *)(v7 + 4) - 4 : 0;
      (*(void (__stdcall **)(signed int))(*(_DWORD *)v7 + 20))(1);
      v7 = v9;
    }
    while ( v9 );
  }
  v11 = InterlockedFlushSList((PSLIST_HEADER)(v2 + 496));
  v10 = v11 != 0 ? (int)&v11[-3] : 0;
  if ( v10 )
  {
    do
    {
      v12 = *(_DWORD *)(v10 + 12) != 0 ? *(_DWORD *)(v10 + 12) - 12 : 0;
      (**(void (__stdcall ***)(_DWORD))v10)(1);
      v10 = v12;
    }
    while ( v12 );
  }
  sub_1002C0BC(2, 4, *(_DWORD *)(v2 + 372));
  while ( *(_DWORD *)(v2 + 184) )
  {
    v13 = sub_1002B856(v2 + 184);
    SetEvent(*((HANDLE *)v13 + 2));
    CloseHandle(*((HANDLE *)v13 + 2));
    sub_1002404A(v13);
  }
  return (**(int (__thiscall ***)(_DWORD, _DWORD))v2)(v2, 1);
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10029F04) --------------------------------------------------------
int __thiscall sub_10029F04(void *this)
{
  LPVOID v1; // eax@1
  int v2; // ebx@1
  LPVOID v3; // edi@1
  void *v4; // esi@1

  v4 = this;
  v2 = 0;
  v1 = sub_10029DCE();
  v3 = v1;
  if ( v1 )
  {
    if ( *((void **)v1 + 7) == v4 )
    {
      if ( !*((_BYTE *)v1 + 76) )
      {
        sub_1003AF6A();
        v2 = *(_DWORD *)(*((_DWORD *)v3 + 39) + 68);
        sub_1003AF6A();
      }
    }
  }
  return v2;
}

//----- (10029F3F) --------------------------------------------------------
int __thiscall sub_10029F3F(int this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v5; // [sp+8h] [bp-4h]@3

  v2 = this;
  v3 = 0;
  if ( (*(_DWORD *)a2 & 0xFFFFFFF) == 2 )
  {
    v3 = *(_DWORD *)(*(_DWORD *)(this + 32) + 4 * *(_DWORD *)(a2 + 8));
  }
  else
  {
    if ( (*(_DWORD *)a2 & 0xFFFFFFF) == 3 )
    {
      a2 = *(_DWORD *)(a2 + 8);
      if ( sub_10025A21((unsigned int *)(this + 348), (int)&a2, (int)&v5) )
        v3 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 4 * v5);
    }
  }
  return v3;
}

//----- (10029F93) --------------------------------------------------------
int __stdcall sub_10029F93(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // esi@1

  v5 = a1;
  for ( result = 0; v5 < a2 && !result; result = sub_10037C97(a4, v5++) )
    ;
  *(_DWORD *)a3 = v5 - 1;
  return result;
}

//----- (10029FBE) --------------------------------------------------------
int __thiscall sub_10029FBE(void *this, int a2, int a3, int a4)
{
  int result; // eax@1
  void *v5; // edi@1
  int v6; // esi@1

  v6 = a2;
  v5 = this;
  for ( result = 0; v6 < a3 && !result; result = sub_10037C97((int)((char *)v5 + 56), v6++) )
    ;
  *(_DWORD *)a4 = v6 - 1;
  return result;
}

//----- (10029FED) --------------------------------------------------------
char __thiscall sub_10029FED(int this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  char v7; // bl@1
  int v8; // esi@1
  int v9; // edi@3
  int v10; // eax@6
  unsigned int v11; // edi@6
  int v12; // edi@10
  int v13; // ecx@11
  char v15; // [sp-14h] [bp-28h]@4
  int v16; // [sp-10h] [bp-24h]@4
  int v17; // [sp-Ch] [bp-20h]@4
  int v18; // [sp-8h] [bp-1Ch]@4
  int v19; // [sp-4h] [bp-18h]@4
  int v20; // [sp+10h] [bp-4h]@6

  v7 = 1;
  v8 = this;
  if ( (a3 & 0xFFFFFFF) != 1 )
  {
    if ( (a3 & 0xFFFFFFFu) - 2 <= 1 )
    {
      v9 = sub_10029F3F(this, (int)&a3);
      if ( v9 )
      {
        v19 = a7;
        sub_10027C4E((int)&v15, (int)&a3);
        if ( sub_1003B85D((void *)v9, a2, *(int *)&v15, v16, v17, v18, v19) )
          return v7;
      }
    }
    goto LABEL_10;
  }
  v10 = *(_DWORD *)(this + 28) + 16 * a5;
  v11 = 0;
  v20 = *(_DWORD *)(this + 28) + 16 * a5;
  if ( *(_DWORD *)(this + 44) <= 0 )
  {
LABEL_10:
    v12 = 0;
    if ( *(_DWORD *)(v8 + 44) <= 0 )
    {
LABEL_15:
      v7 = 0;
    }
    else
    {
      while ( 1 )
      {
        v13 = *(_DWORD *)(*(_DWORD *)(v8 + 32) + 4 * v12);
        if ( v13 )
        {
          if ( *(_DWORD *)(v13 + 28) > 0 )
          {
            *(_DWORD *)&v15 &= 0xF0000000u;
            *(_DWORD *)&v15 &= 0xFFFFFFFu;
            if ( sub_1003B85D((void *)v13, a2, *(int *)&v15, v16, 0, 0, a7) )
              break;
          }
        }
        ++v12;
        if ( v12 >= *(_DWORD *)(v8 + 44) )
          goto LABEL_15;
      }
    }
    return v7;
  }
  while ( 1 )
  {
    if ( (1 << (v11 & 0x1F)) & *(_DWORD *)(*(_DWORD *)(v10 + 4) + 4 * (v11 >> 5)) )
    {
      v19 = a7;
      sub_10027C4E((int)&v15, (int)&a3);
      if ( sub_1003B85D(*(void **)(*(_DWORD *)(v8 + 32) + 4 * v11), a2, *(int *)&v15, v16, v17, v18, v19) )
        return v7;
    }
    v10 = v20;
    ++v11;
    if ( (signed int)v11 >= *(_DWORD *)(v8 + 44) )
      goto LABEL_10;
  }
}

//----- (1002A0EA) --------------------------------------------------------
char __thiscall sub_1002A0EA(int this)
{
  char v1; // dl@1
  int v2; // ecx@1

  v2 = *(_DWORD *)(this + 180);
  v1 = 0;
  while ( v2 )
  {
    if ( !*(_BYTE *)(*(_DWORD *)(v2 + 4) + 236) && *(_DWORD *)(*(_DWORD *)(v2 + 4) + 44) )
      return 1;
    v2 = *(_DWORD *)v2;
  }
  return v1;
}

//----- (1002A114) --------------------------------------------------------
char __thiscall sub_1002A114(void *this)
{
  void *v1; // eax@1
  int v2; // ecx@1
  char v3; // bl@1
  int v4; // esi@2
  signed int v5; // edi@3
  int v6; // eax@4
  signed int v7; // edi@12
  int v8; // eax@13
  void *v10; // [sp+4h] [bp-Ch]@1
  void *v11; // [sp+8h] [bp-8h]@4
  void *v12; // [sp+8h] [bp-8h]@13
  int i; // [sp+Ch] [bp-4h]@1

  v1 = this;
  v2 = 0;
  v3 = 0;
  v10 = v1;
  for ( i = 0; v2 < *((_DWORD *)v10 + 11); i = v2 )
  {
    v4 = *(_DWORD *)(*((_DWORD *)v1 + 9) + 4 * v2);
    if ( v4 )
    {
      v5 = 0;
      if ( *(_DWORD *)(v4 + 80) > 0 )
      {
        while ( 1 )
        {
          v6 = sub_10037C97(v4 + 16, v5);
          v11 = (void *)v6;
          if ( v6 )
          {
            if ( sub_10038491(v6) || sub_1003849A(v11) )
              break;
          }
          ++v5;
          if ( v5 >= *(_DWORD *)(v4 + 80) )
            goto LABEL_10;
        }
        v3 = 1;
LABEL_10:
        v2 = i;
      }
      if ( v3 )
        return v3;
      v7 = 0;
      if ( *(_DWORD *)(v4 + 160) > 0 )
      {
        while ( 1 )
        {
          v8 = sub_10037C97(v4 + 96, v7);
          v12 = (void *)v8;
          if ( v8 )
          {
            if ( sub_10038491(v8) || sub_1003849A(v12) )
              break;
          }
          ++v7;
          if ( v7 >= *(_DWORD *)(v4 + 160) )
            goto LABEL_19;
        }
        v3 = 1;
LABEL_19:
        v2 = i;
      }
    }
    v1 = v10;
    ++v2;
  }
  return v3;
}

//----- (1002A1DB) --------------------------------------------------------
int __thiscall sub_1002A1DB(int this)
{
  return *(_DWORD *)(sub_1002A552(this) + 8);
}

//----- (1002A1E4) --------------------------------------------------------
int __userpurge sub_1002A1E4<eax>(int a1<ebp>, int a2, int a3)
{
  int v3; // eax@1
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // eax@1
  int v9; // eax@2
  int v10; // eax@3
  int v11; // eax@6

  sub_1002D0B8();
  v5 = v7;
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)(a1 - 16) = 0;
  v8 = sub_10034C38();
  v6 = *(_DWORD *)(a1 + 8);
  sub_10028E71(*(_DWORD *)(a1 + 8), 0, v5, v8);
  v4 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 - 4) = 0;
  v3 = *(_DWORD *)v4 & 0xFFFFFFF;
  *(_DWORD *)(a1 - 16) = 1;
  if ( !v3 )
  {
    sub_10029DEE(v6);
    return sub_1002D086(4);
  }
  v9 = v3 - 1;
  if ( !v9 )
  {
    v11 = 16 * *(_DWORD *)(v4 + 8) + 8 + *(_DWORD *)(v5 + 28);
    goto LABEL_8;
  }
  v10 = v9 - 1;
  if ( !v10 )
  {
    v11 = *(_DWORD *)(*(_DWORD *)(v5 + 32) + 4 * *(_DWORD *)(v4 + 8)) + 8;
LABEL_8:
    sub_10029BCB(v6, v5, v11);
    return sub_1002D086(4);
  }
  if ( v10 == 1 )
  {
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(v4 + 8);
    sub_10025A21((unsigned int *)(v5 + 360), a1 + 8, a1 + 12);
    *(_DWORD *)(*(_DWORD *)(v6 + 4) + 4 * (*(_DWORD *)(a1 + 12) >> 5)) |= 1 << (*(_DWORD *)(a1 + 12) & 0x1F);
  }
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1002A28E) --------------------------------------------------------
int __usercall sub_1002A28E<eax>(int a1<ebp>, int a2<edi>)
{
  void *v2; // ecx@1
  const void **v3; // eax@3
  signed int v5; // [sp-4h] [bp-4h]@1

  v5 = 8;
  sub_1002D0B8();
  *(_DWORD *)(a1 - 20) = &dword_10069CB0;
  sub_10028AD5(&dword_10069CB0);
  v2 = (void *)dword_10069410;
  *(_DWORD *)(a1 - 4) = 0;
  if ( !v2 || !sub_1002BA81(v2) )
  {
    sub_1003A4BA(0, a1 - 16, 0, 8);
    v3 = (const void **)dword_10069414;
    *(_BYTE *)(a1 - 4) = 1;
    if ( v3 )
      sub_1003A558((void **)(a1 - 16), v3);
    dword_10069410 = sub_10029C4D(0, a2, (void *)(a1 - 16));
    sub_1002A845(dword_10069410);
    (*(void (**)(void))(*(_DWORD *)dword_10069410 + 16))();
    *(_BYTE *)(a1 - 4) = 0;
    sub_1003A54F((LPVOID *)(a1 - 16));
  }
  dword_10069CB0 = 0;
  return sub_1002D086(v5);
}
// 1002A845: using guessed type int __thiscall sub_1002A845(_DWORD);
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10069410: using guessed type int dword_10069410;
// 10069414: using guessed type int dword_10069414;
// 10069CB0: using guessed type int dword_10069CB0;

//----- (1002A31E) --------------------------------------------------------
int __userpurge sub_1002A31E<eax>(int a1<ebx>, int a2<ebp>, int a3)
{
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  PSINGLE_LIST_ENTRY v7; // eax@1
  int v8; // eax@2

  sub_1002D0B8();
  v5 = v4;
  v7 = InterlockedPopEntrySList((PSLIST_HEADER)(v4 + 488));
  v6 = v7 != 0 ? (int)&v7[-1] : 0;
  if ( v6 )
  {
    sub_1003D511(v6, *(_DWORD *)(a2 + 8));
  }
  else
  {
    v8 = sub_10027EB3(v3, v4, a1, v5, 176);
    *(_DWORD *)(a2 - 16) = v8;
    *(_DWORD *)(a2 - 4) = 0;
    if ( v8 )
      sub_1003D279(a1, a2, v5, *(_DWORD *)(a2 + 8));
  }
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1002A37E) --------------------------------------------------------
int __userpurge sub_1002A37E<eax>(int a1<ebp>, int a2)
{
  int v2; // ecx@1
  int v3; // edi@1
  int v5; // esi@4
  int v13; // esi@11
  PSINGLE_LIST_ENTRY v14; // eax@11
  int v15; // edx@12
  int v23; // [sp-8h] [bp-8h]@15
  signed int v24; // [sp-4h] [bp-4h]@1

  v24 = 8;
  sub_1002D121();
  v3 = v2;
  *(_DWORD *)(a1 - 20) = v2;
  if ( !*(_BYTE *)(a1 + 8) )
  {
    _EBX = 1;
LABEL_9:
    _EAX = v3 + 400;
    _ECX = _EBX;
    __asm { lock xadd [eax], ecx }
    if ( !*(_BYTE *)(a1 + 8) )
      *(_DWORD *)(v3 + 456) = GetTickCount();
    v14 = InterlockedPopEntrySList((PSLIST_HEADER)(v3 + 480));
    v13 = v14 != 0 ? (int)&v14[-2] : 0;
    *(_DWORD *)(a1 + 8) = v13;
    if ( !v13 )
    {
      v13 = (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 64))(v3);
      *(_DWORD *)(a1 + 8) = v13;
      sub_100295E3(v15, v3, _EBX, v3, v13);
      _ECX = v3 + 392;
      __asm { lock xadd [ecx], ebx }
    }
    sub_1003C6EE(v13);
    *(_DWORD *)(a1 - 4) = 0;
    *(_DWORD *)(v13 + 156) = 0;
    (*(void (__cdecl **)(int, signed int))(**(_DWORD **)(v3 + 420) + 8))(v13, v24);
    if ( v13 )
    {
      *(_DWORD *)(v13 + 16) = 0;
      *(_DWORD *)(v13 + 20) = 0;
    }
    return sub_1002D086(v23);
  }
  if ( !(unsigned __int8)(*(int (__cdecl **)(signed int))(*(_DWORD *)v2 + 88))(8) || !sub_1002A642(v3) )
  {
    _EBX = 1;
    v5 = sub_1002BFBA(v3, 1);
    if ( v5 )
    {
      if ( GetTickCount() - *(_DWORD *)(v3 + 456) < v5 )
        return sub_1002D086(v23);
      *(_BYTE *)(a1 + 8) = 0;
    }
    goto LABEL_9;
  }
  return sub_1002D086(v23);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1002A48B) --------------------------------------------------------
int __thiscall sub_1002A48B(void *this)
{
  _ECX = (int)((char *)this + 328);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return _EAX + 1;
}

//----- (1002A49A) --------------------------------------------------------
int __thiscall sub_1002A49A(void *this)
{
  _ECX = (int)((char *)this + 332);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return _EAX + 1;
}

//----- (1002A4A9) --------------------------------------------------------
int __cdecl sub_1002A4A9()
{
  _ECX = &unk_1006941C;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return _EAX + 1;
}

//----- (1002A4B7) --------------------------------------------------------
int __thiscall sub_1002A4B7(int this)
{
  int v1; // eax@1
  void *v2; // edi@1
  int v3; // esi@1
  int v4; // esi@1

  v4 = this;
  v2 = (void *)(this + 308);
  sub_10024558((void *)(this + 308));
  v1 = sub_1002B80A((void *)(v4 + 304));
  v3 = v1;
  if ( v1 )
    *(_DWORD *)(v1 + 12) = 1;
  sub_10024692(v2);
  return v3;
}

//----- (1002A4EC) --------------------------------------------------------
int __stdcall sub_1002A4EC(int a1, int a2, int a3)
{
  int v3; // edx@1
  int result; // eax@2

  v3 = *(_DWORD *)a1 + 1;
  if ( v3 <= a2 || (result = sub_10029F93(v3, *(_DWORD *)(a3 + 64), a1, a3), v3 = 0, !result) )
    result = sub_10029F93(v3, a2, a1, a3);
  return result;
}

//----- (1002A528) --------------------------------------------------------
int __thiscall sub_1002A528(int this, int a2, int a3)
{
  int v4; // esi@1
  int v5; // eax@1

  v4 = this;
  v5 = sub_1002A573(this, *(_DWORD *)(a3 + 184));
  return *(_DWORD *)(*(_DWORD *)(v4 + 36) + 4 * v5) != a2 ? *(_DWORD *)(*(_DWORD *)(v4 + 36) + 4 * v5) : 0;
}

//----- (1002A552) --------------------------------------------------------
int __thiscall sub_1002A552(int this)
{
  int v2; // edx@1
  int v3; // esi@1

  v2 = *(_DWORD *)(this + 376);
  v3 = *(_DWORD *)(*(_DWORD *)(this + 36) + 4 * v2);
  *(_DWORD *)(this + 376) = sub_1002A573(this, v2);
  return v3;
}

//----- (1002A573) --------------------------------------------------------
int __thiscall sub_1002A573(int this, int a2)
{
  int v2; // edx@1

  v2 = a2;
  do
    v2 = (v2 + 1) % *(_DWORD *)(this + 44);
  while ( !*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 36) + 4 * v2) + 188) );
  return v2;
}

//----- (1002A595) --------------------------------------------------------
int __thiscall sub_1002A595(int this, int a2, int a3)
{
  int v3; // edx@1
  void *v4; // edi@1
  int result; // eax@2

  v3 = *(_DWORD *)a2 + 1;
  v4 = (void *)this;
  if ( v3 <= a3 || (result = sub_10029FBE((void *)this, v3, *(_DWORD *)(this + 120), a2), v3 = 0, !result) )
    result = sub_10029FBE(v4, v3, a3, a2);
  return result;
}

//----- (1002A5CA) --------------------------------------------------------
int __thiscall sub_1002A5CA(int this)
{
  return *(_DWORD *)(this + 20);
}

//----- (1002A5CE) --------------------------------------------------------
int __userpurge sub_1002A5CE<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  sub_1003A4D8(a1, a5, a3, a4, (const void **)(a2 + 4));
  return a5;
}

//----- (1002A5E9) --------------------------------------------------------
int __userpurge sub_1002A5E9<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4, int a5)
{
  PSINGLE_LIST_ENTRY v5; // eax@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // eax@2

  v5 = InterlockedPopEntrySList((PSLIST_HEADER)(a1 + 496));
  v6 = v5 != 0 ? (int)&v5[-3] : 0;
  if ( v6 )
  {
    *(_DWORD *)(v5 != 0 ? (int)&v5[-3] + 4 : 4) = a4;
    *(_DWORD *)(v5 != 0 ? (int)&v5[-3] + 8 : 8) = a5;
    goto LABEL_6;
  }
  v8 = sub_10027EB3(0, v7, a2, a3, 16);
  v6 = v8;
  if ( v8 )
  {
    *(_DWORD *)(v8 + 4) = a4;
    *(_DWORD *)v8 = &off_10055E4C;
    *(_DWORD *)(v8 + 8) = a5;
LABEL_6:
    *(_DWORD *)(v6 + 12) = 0;
    return v6;
  }
  return 0;
}
// 10055E4C: using guessed type int (__stdcall *off_10055E4C)(char);

//----- (1002A642) --------------------------------------------------------
int __thiscall sub_1002A642(int this)
{
  PSINGLE_LIST_ENTRY v2; // eax@1

  v2 = InterlockedPopEntrySList((PSLIST_HEADER)(this + 504));
  return v2 != 0 ? (int)&v2[-2] : 0;
}

//----- (1002A659) --------------------------------------------------------
int __thiscall sub_1002A659(int this, char a2)
{
  int v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  sub_10025A21((unsigned int *)(this + 360), (int)&a2, (int)&v3);
  return v3;
}

//----- (1002A677) --------------------------------------------------------
int __thiscall sub_1002A677(void *this)
{
  void *v1; // edi@3
  void *v2; // esi@3
  int v3; // edi@3
  int v4; // ecx@1
  int result; // eax@2

  v4 = (int)((char *)this + 288);
  if ( *(_DWORD *)v4 )
  {
    v1 = (void *)v4;
    v2 = (void *)(v4 + 8);
    sub_1002C615((void *)(v4 + 8));
    v3 = sub_10029CFA(v1);
    sub_1002C625(v2);
    result = v3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002A68A) --------------------------------------------------------
int __usercall sub_1002A68A<eax>(int a1<ebp>, int a2<edi>)
{
  char v2; // bl@1
  void *v10; // eax@4
  int v11; // edx@4
  int v12; // ecx@4
  void *v13; // ecx@5
  int v14; // eax@5

  sub_1002D0B8();
  v2 = *(_BYTE *)(a1 + 8);
  if ( v2 )
  {
    if ( dword_10069424 >= 32 )
      return sub_1002D086(0);
    _ECX = &dword_10069424;
    _EAX = 1;
    __asm { lock xadd [ecx], eax }
  }
  v10 = InterlockedPopEntrySList(&ListHead);
  if ( !v10 )
  {
    v14 = sub_10027EB3(v11, v12, v2, a2, 776);
    v13 = (void *)v14;
    *(_DWORD *)(a1 + 8) = v14;
    v10 = 0;
    *(_DWORD *)(a1 - 4) = 0;
    if ( v13 )
      v10 = sub_100291C2(v13);
  }
  *((_BYTE *)v10 + 772) = v2;
  return sub_1002D086(0);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10069424: using guessed type int dword_10069424;

//----- (1002A6EB) --------------------------------------------------------
int __thiscall sub_1002A6EB(int this, int a2)
{
  int result; // eax@2

  if ( *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 36) + 4 * a2) + 188) )
    result = a2;
  else
    result = sub_1002A573(this, a2);
  return result;
}

//----- (1002A70E) --------------------------------------------------------
void __thiscall sub_1002A70E(void *this, int a2)
{
  int v2; // ebx@1
  void *v3; // esi@1
  int v4; // eax@2
  unsigned int v5; // edx@2
  unsigned int v6; // ecx@2
  int v7; // edi@2
  unsigned int v9; // eax@2
  int v10; // [sp+8h] [bp-4h]@2

  v2 = a2;
  v3 = this;
  if ( a2 != *(_DWORD *)this )
  {
    v7 = (unsigned int)(a2 + 31) >> 5;
    _ECX = 0;
    v9 = 4 * ((unsigned int)(a2 + 31) >> 5);
    __asm { seto    cl }
    v4 = sub_10021CF0((a2 + 31) / 0x100u, v9 | -_ECX, a2, v7, v9 | -_ECX);
    v6 = (unsigned int)(*(_DWORD *)v3 + 31) >> 5;
    v5 = 0;
    v10 = v4;
    if ( v6 )
    {
      do
      {
        *(_DWORD *)(v4 + 4 * v5) = *(_DWORD *)(*((_DWORD *)v3 + 1) + 4 * v5);
        ++v5;
      }
      while ( v5 < v6 );
      v2 = a2;
    }
    sub_10030CF0((void *)(v4 + 4 * v6), 0, 4 * (v7 - v6));
    sub_1002401B(*((LPVOID *)v3 + 1));
    *((_DWORD *)v3 + 1) = v10;
    *(_DWORD *)v3 = v2;
  }
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (1002A78D) --------------------------------------------------------
void __thiscall sub_1002A78D(void *this, int a2)
{
  int v2; // ebx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // edx@2
  unsigned int v6; // ecx@2
  signed __int64 v8; // qax@2
  int v9; // [sp+14h] [bp+8h]@2

  v4 = a2;
  v3 = (int)this;
  v2 = *(_DWORD *)this;
  if ( a2 != *(_DWORD *)this )
  {
    sub_1002A70E(this, a2);
    _ECX = 0;
    v8 = 4i64 * (unsigned int)a2;
    __asm { seto    cl }
    v5 = sub_10021CF0(SHIDWORD(v8), v8 | -_ECX, v2, v3, v8 | -_ECX);
    v6 = 0;
    v9 = v5;
    if ( v2 )
    {
      do
      {
        *(_DWORD *)(v5 + 4 * v6) = *(_DWORD *)(*(_DWORD *)(v3 + 8) + 4 * v6);
        ++v6;
      }
      while ( v6 < v2 );
    }
    sub_10030CF0((void *)(v5 + 4 * v2), 0, 4 * (v4 - v2));
    sub_1002401B(*(LPVOID *)(v3 + 8));
    *(_DWORD *)(v3 + 8) = v9;
  }
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (1002A7FD) --------------------------------------------------------
bool __thiscall sub_1002A7FD(int this)
{
  return (*(_DWORD *)(this + 404) & 0xA0000000) == -1610612736;
}

//----- (1002A812) --------------------------------------------------------
int __cdecl sub_1002A812(int a1, unsigned int a2)
{
  unsigned int v2; // edx@1
  unsigned int v3; // ecx@1

  v2 = -2128831035;
  v3 = 0;
  do
    v2 = 16777619 * (*(_BYTE *)(v3++ + a1) ^ v2);
  while ( v3 < 4 );
  return v2 % a2;
}

//----- (1002A83E) --------------------------------------------------------
int __thiscall sub_1002A83E(int this)
{
  return *(_DWORD *)(this + 372);
}

//----- (1002A845) --------------------------------------------------------
#error "1002AC6A: call analysis failed (funcsize=373)"

//----- (1002AC70) --------------------------------------------------------
int __thiscall sub_1002AC70(void *this)
{
  int result; // eax@1

  _ECX = (int)((char *)this + 392);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (1002AC7E) --------------------------------------------------------
int __userpurge sub_1002AC7E<eax>(int a1<ebp>, int a2)
{
  PSINGLE_LIST_ENTRY v2; // eax@1
  int v3; // edx@1
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v9; // [sp-8h] [bp-8h]@7

  sub_1002D0B8();
  v5 = v7;
  v4 = v7 + 96;
  v2 = InterlockedPopEntrySList((PSLIST_HEADER)(v7 + 96));
  v6 = 0;
  if ( v2 )
    v6 = (int)&v2[-13];
  if ( *(_DWORD *)(v5 + 12) )
  {
    *(_DWORD *)(a1 - 32) = 0;
    *(_DWORD *)(a1 - 24) = 0;
    *(_DWORD *)(a1 - 20) = 0;
    if ( !v6 )
    {
      v6 = sub_10027EB3(v3, 0, v4, v5, 60);
      *(_DWORD *)(a1 + 8) = v6;
      *(_DWORD *)(a1 - 4) = 1;
      if ( v6 )
      {
        sub_10037958(a1, v5, a1 - 32);
        *(_DWORD *)(v6 + 56) = 0;
        *(_DWORD *)v6 = &off_10055F0C;
        *(_BYTE *)(v6 + 48) = 2;
        goto LABEL_12;
      }
LABEL_11:
      v6 = 0;
      goto LABEL_12;
    }
    v9 = a1 - 32;
LABEL_14:
    sub_100384CF(v6, v9);
    goto LABEL_15;
  }
  if ( v6 )
  {
    v9 = *(_DWORD *)(a1 + 8);
    goto LABEL_14;
  }
  v6 = sub_10027EB3(v3, 0, v4, v5, 56);
  *(_DWORD *)(a1 - 16) = v6;
  *(_DWORD *)(a1 - 4) = 0;
  if ( !v6 )
    goto LABEL_11;
  sub_10037958(a1, v5, *(_DWORD *)(a1 + 8));
  *(_DWORD *)v6 = &off_10055ECC;
  *(_BYTE *)(v6 + 48) = 1;
LABEL_12:
  *(_DWORD *)(a1 - 4) = -1;
LABEL_15:
  sub_1002948A(v4, v6);
  return sub_1002D086(20);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10055ECC: using guessed type int (__stdcall *off_10055ECC)(int, int);
// 10055F0C: using guessed type int (__stdcall *off_10055F0C)(int, int);

//----- (1002AD41) --------------------------------------------------------
int __thiscall sub_1002AD41(void *this)
{
  int v1; // esi@1
  int v2; // edi@2
  int result; // eax@4

  v1 = (int)this;
  if ( *((_BYTE *)this + 48) & 4 )
  {
    result = 0;
  }
  else
  {
    _EAX = (int)((char *)this + 20);
    _EDI = -1;
    __asm { lock xadd [eax], edi }
    v2 = _EDI - 1;
    if ( !v2 )
    {
      (*(void (**)(void))(*(_DWORD *)this + 28))();
      sub_1002B8B5(*(_DWORD *)(v1 + 4), v1);
    }
    result = v2;
  }
  return result;
}

//----- (1002AD6F) --------------------------------------------------------
bool __thiscall sub_1002AD6F(int this, int a2)
{
  int v2; // edx@1
  unsigned int v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v4 = (unsigned int)(*(_DWORD *)this + 31) >> 5;
  v3 = 0;
  if ( v4 )
  {
    do
    {
      if ( v2 )
        break;
      v2 = *(_DWORD *)(*(_DWORD *)(this + 4) + 4 * v3) & *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * v3);
      ++v3;
    }
    while ( v3 < v4 );
  }
  return v2 != 0;
}

//----- (1002ADAD) --------------------------------------------------------
int __thiscall sub_1002ADAD(int this, int (__cdecl *a2)(_DWORD), int a3, int a4)
{
  int result; // eax@2

  if ( *(_DWORD *)(a4 + 404) & 0x20000000 )
  {
    result = a2(a3);
  }
  else
  {
    *(_DWORD *)this = a2;
    *(_DWORD *)(this + 4) = a3;
    result = sub_1002ADE0(a4, this);
  }
  return result;
}

//----- (1002ADE0) --------------------------------------------------------
int __thiscall sub_1002ADE0(int this, int a2)
{
  int v3; // ebx@1
  void *v4; // edi@1

  v3 = this;
  v4 = (void *)(this + 324);
  sub_1002C615((void *)(this + 324));
  *(_DWORD *)(a2 + 8) = sub_1002B263((void *)v3);
  *(_DWORD *)(a2 + 12) = 0;
  **(_DWORD **)(v3 + 320) = a2;
  *(_DWORD *)(v3 + 320) = a2 + 12;
  return sub_1002C625(v4);
}

//----- (1002AE24) --------------------------------------------------------
char __thiscall sub_1002AE24(int this)
{
  char v1; // dl@1

  v1 = 0;
  if ( *(_DWORD *)(this + 24)
    || *(_DWORD *)(this + 8) != *(_DWORD *)(this + 16)
    || *(_DWORD *)(this + 12) != *(_DWORD *)(this + 20) )
    v1 = 1;
  return v1;
}

//----- (1002AE41) --------------------------------------------------------
char __thiscall sub_1002AE41(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v4; // esi@1
  char v5; // bl@1
  char v6; // [sp+8h] [bp-8h]@1
  void *v7; // [sp+Ch] [bp-4h]@1

  v4 = this;
  sub_1002A1E4(ebp0, (int)&v6, a2);
  v5 = sub_1002AD6F((int)&v6, (int)((char *)v4 + 48));
  sub_1002401B(v7);
  return v5;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (1002AE75) --------------------------------------------------------
int __thiscall sub_1002AE75(int this, int a2, int a3)
{
  int v3; // ecx@1
  int result; // eax@4

  v3 = *(_DWORD *)(*(_DWORD *)(this + 8) + 4 * a3);
  if ( v3 )
  {
    while ( *(_DWORD *)(v3 + 4) != *(_DWORD *)a2 )
    {
      v3 = *(_DWORD *)v3;
      if ( !v3 )
        goto LABEL_4;
    }
    result = v3;
  }
  else
  {
LABEL_4:
    result = 0;
  }
  return result;
}

//----- (1002AE9F) --------------------------------------------------------
int __stdcall sub_1002AE9F(int a1, int a2, int a3, int a4)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (1002AEB0) --------------------------------------------------------
char __thiscall sub_1002AEB0(int this, int a2)
{
  char result; // al@2

  if ( *(_DWORD *)a2 == *(_DWORD *)(this + 336) )
  {
    result = 0;
  }
  else
  {
    *(_DWORD *)a2 = *(_DWORD *)(this + 336);
    result = 1;
  }
  return result;
}

//----- (1002AED2) --------------------------------------------------------
char __thiscall sub_1002AED2(int this, int a2)
{
  int v2; // esi@1
  int v3; // ST08_4@1
  char result; // al@6
  int v5; // [sp+8h] [bp-Ch]@1
  int v6; // [sp+Ch] [bp-8h]@5

  v5 = 0;
  v2 = this;
  if ( sub_10029FED(this, (int)&v5, 0, v3, 0, 0, 12) )
  {
    if ( v5 == 2 || v5 == 8 )
    {
      InterlockedPushEntrySList((PSLIST_HEADER)(v2 + 504), (PSINGLE_LIST_ENTRY)(a2 + 8));
      sub_1003ABAA(v6, v5, 0, 0);
    }
    else
    {
      sub_1003AC1E((int)&v5, a2);
    }
    result = 1;
  }
  else
  {
    InterlockedPushEntrySList((PSLIST_HEADER)(v2 + 504), (PSINGLE_LIST_ENTRY)(a2 + 8));
    result = 0;
  }
  return result;
}

//----- (1002AF61) --------------------------------------------------------
DWORD __cdecl sub_1002AF61()
{
  int v0; // eax@2
  char v2; // [sp+0h] [bp-10h]@5

  sub_10024659();
  dwTlsIndex = TlsAlloc();
  if ( dwTlsIndex == -1 )
  {
    v0 = GetLastError();
    if ( v0 > 0 )
      v0 = (unsigned __int16)v0 | 0x80070000;
    sub_100249F4((int)&v2, v0);
    sub_1002D02B((int)&v2, (int)&unk_10060498);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1002AFAF);
  }
  return sub_1003D85B();
}

//----- (1002AFAF) --------------------------------------------------------
BOOL __cdecl sub_1002AFAF()
{
  BOOL result; // eax@1

  sub_1003D89F();
  result = TlsFree(dwTlsIndex);
  dwTlsIndex = 0;
  return result;
}

//----- (1002AFC8) --------------------------------------------------------
int __thiscall sub_1002AFC8(void *this, int a2)
{
  void *v3; // edi@1
  int v4; // esi@2
  int v6; // esi@3
  int v7; // eax@4
  int v8; // ecx@4
  int v9; // ST04_4@4
  int v10; // esi@5
  int v11; // eax@11
  int v12; // esi@12
  int v13; // eax@18
  int v14; // esi@19
  char v16; // [sp+Ch] [bp-14h]@18
  int v17; // [sp+10h] [bp-10h]@4
  char v18; // [sp+14h] [bp-Ch]@4
  int v19; // [sp+18h] [bp-8h]@4
  int i; // [sp+1Ch] [bp-4h]@3

  v3 = this;
  _ECX = (int)((char *)this + 412);
  do
  {
    v4 = *(_DWORD *)_ECX;
    _EDX = a2;
    __asm { lock cmpxchg [ecx], edx }
  }
  while ( v4 != v4 );
  sub_10024558((char *)v3 + 308);
  v6 = 0;
  for ( i = 0; v6 < *((_DWORD *)v3 + 11); i = v6 )
  {
    v8 = *(_DWORD *)(*((_DWORD *)v3 + 9) + 4 * v6);
    v17 = *(_DWORD *)(*((_DWORD *)v3 + 8) + 4 * v6);
    v9 = *(_DWORD *)(v8 + 80);
    v19 = v8;
    v7 = sub_10029F93(0, v9, (int)&v18, v8 + 16);
    if ( v7 )
    {
      v10 = v19;
      do
      {
        if ( (unsigned int)(a2 - *(_DWORD *)(v7 + 264)) > 0x7D0 )
        {
          if ( *(_DWORD *)(v7 + 280) == 1 )
          {
            *(_DWORD *)(v7 + 280) = 2;
            sub_10029610((char *)v3 + 304, v7 + 268);
          }
        }
        v7 = sub_1002A4EC((int)&v18, 0, v10 + 16);
      }
      while ( v7 );
      v6 = i;
    }
    v11 = sub_10029F93(0, *(_DWORD *)(v19 + 160), (int)&v18, v19 + 96);
    if ( v11 )
    {
      v12 = v19;
      do
      {
        if ( (unsigned int)(a2 - *(_DWORD *)(v11 + 264)) > 0x7D0 )
        {
          if ( *(_DWORD *)(v11 + 280) == 1 )
          {
            *(_DWORD *)(v11 + 280) = 2;
            sub_10029610((char *)v3 + 304, v11 + 268);
          }
        }
        v11 = sub_1002A4EC((int)&v18, 0, v12 + 96);
      }
      while ( v11 );
      v6 = i;
    }
    v13 = sub_10029FBE((void *)v17, 0, *(_DWORD *)(v17 + 120), (int)&v16);
    if ( v13 )
    {
      v14 = v17;
      do
      {
        if ( (unsigned int)(a2 - *(_DWORD *)(v13 + 184)) > 0x7D0 )
        {
          if ( *(_DWORD *)(v13 + 204) == 1 )
          {
            *(_DWORD *)(v13 + 204) = 2;
            sub_10029610((char *)v3 + 304, v13 + 192);
          }
        }
        v13 = sub_1002A595(v14, (int)&v16, 0);
      }
      while ( v13 );
      v6 = i;
    }
    ++v6;
  }
  return sub_10024692((char *)v3 + 308);
}

//----- (1002B165) --------------------------------------------------------
int __thiscall sub_1002B165(int this)
{
  int v1; // esi@1
  int i; // eax@4
  int v3; // edx@4
  int v4; // ecx@4

  v1 = this;
  if ( dword_10069410 == this )
  {
    sub_10028AD5(&dword_10069CB0);
    dword_10069410 = dword_10069410 != v1 ? dword_10069410 : 0;
    dword_10069CB0 = 0;
  }
  if ( *(_DWORD *)(v1 + 392) > 1 )
  {
    _EDI = v1 + 404;
    v3 = *(_DWORD *)(v1 + 404);
    v4 = *(_DWORD *)(v1 + 404);
    for ( i = *(_DWORD *)(v1 + 404); ; v4 = i )
    {
      _ECX = v4 | 0x80000000;
      __asm { lock cmpxchg [edi], ecx }
      if ( i == v3 )
        break;
      v3 = i;
    }
    if ( !(v3 & 0x1FFFFFFF) )
      sub_10029897((void *)v1);
  }
  return sub_10029C7F(v1);
}
// 10069410: using guessed type int dword_10069410;
// 10069CB0: using guessed type int dword_10069CB0;

//----- (1002B1DB) --------------------------------------------------------
int __thiscall sub_1002B1DB(int this)
{
  int v1; // eax@1
  int v2; // esi@1
  char v3; // bl@4
  int v11; // eax@6
  int result; // eax@8

  v2 = this;
  v1 = (int)sub_10029DCE();
  if ( !v1 || *(_BYTE *)(v1 + 76) || sub_1002729E(v1) != v2 )
  {
    v3 = 1;
    _EAX = v2 + 392;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  else
  {
    v3 = 0;
  }
  sub_10029AB5(v2, 0);
  (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 84))(v2);
  _EDI = v2 + 404;
  v11 = *(_DWORD *)(v2 + 404);
  do
  {
    _ECX = v11 & 0xBFFFFFFF | 0x20000000;
    __asm { lock cmpxchg [edi], ecx }
  }
  while ( v11 != v11 );
  sub_1002B5BE(v2, v11 & 0x1FFFFFFF);
  result = (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 80))(v2);
  if ( v3 )
    result = sub_10029C7F(v2);
  return result;
}

//----- (1002B263) --------------------------------------------------------
int __thiscall sub_1002B263(void *this)
{
  int result; // eax@2

  _ECX = (int)((char *)this + 336);
  do
  {
    do
    {
      _EAX = 1;
      __asm { lock xadd [ecx], eax }
      result = _EAX + 1;
    }
    while ( !result );
  }
  while ( result == -1 );
  return result;
}

//----- (1002B27B) --------------------------------------------------------
int __thiscall sub_1002B27B(void *_ECX, int a2)
{
  int result; // eax@1
  int v3; // esi@1

  do
  {
    v3 = *(_DWORD *)_ECX;
    *(_DWORD *)a2 = *(_DWORD *)_ECX;
    _EDX = a2;
    result = v3;
    __asm { lock cmpxchg [ecx], edx }
  }
  while ( v3 != v3 );
  return result;
}

//----- (1002B299) --------------------------------------------------------
char __thiscall sub_1002B299(void *this, int a2, char a3, int a4, int a5, int a6)
{
  char v6; // bl@1
  void *v7; // edi@1
  int v8; // ecx@3
  int v9; // ecx@4
  char v11; // [sp-14h] [bp-2Ch]@4
  int v12; // [sp-10h] [bp-28h]@4
  int v13; // [sp-Ch] [bp-24h]@4
  int v14; // [sp-8h] [bp-20h]@4
  int v15; // [sp-4h] [bp-1Ch]@4
  int v16; // [sp+Ch] [bp-Ch]@4
  int v17; // [sp+14h] [bp-4h]@1

  v6 = 0;
  v17 = (int)this;
  v7 = (void *)(a2 + 4);
  if ( !a2 )
    v7 = 0;
  if ( sub_10029DCE() != v7 )
  {
    sub_10027846(v8);
    v15 = 5;
    v16 = 0;
    sub_10027C4E((int)&v11, (int)&a3);
    if ( sub_10029FED(v17, (int)&v16, *(int *)&v11, v12, v13, v14, v15) )
    {
      sub_1003AC1E((int)&v16, a2);
      v6 = 1;
    }
    sub_10027846(v9);
  }
  return v6;
}
// 10027846: using guessed type _DWORD __thiscall sub_10027846(_DWORD ecx0);

//----- (1002B2FD) --------------------------------------------------------
int __userpurge sub_1002B2FD<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  int result; // eax@1
  int v5; // esi@1
  unsigned int v7; // eax@1

  v5 = a1;
  sub_1002401B(*(LPVOID *)(a1 + 4));
  *(_DWORD *)v5 = a4;
  _ECX = 0;
  v7 = 4 * ((unsigned int)(a4 + 31) >> 5);
  __asm { seto    cl }
  result = sub_10021CF0((a4 + 31) / 0x100u, v7 | -_ECX, a2, a3, v7 | -_ECX);
  *(_DWORD *)(v5 + 4) = result;
  return result;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (1002B334) --------------------------------------------------------
int __thiscall sub_1002B334(int this)
{
  int v2; // ecx@2

  if ( *(_BYTE *)(this + 48) & 4 )
  {
    v2 = 0;
  }
  else
  {
    _EAX = this + 20;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
    v2 = _ECX + 1;
  }
  return v2;
}

//----- (1002B34C) --------------------------------------------------------
int __thiscall sub_1002B34C(int this)
{
  int v1; // edi@1
  void *v2; // esi@1
  int v10; // eax@3
  char v12; // [sp+8h] [bp-Ch]@9

  v2 = (void *)this;
  _EAX = this + 384;
  _EDI = 1;
  __asm { lock xadd [eax], edi }
  v1 = _EDI + 1;
  if ( v1 == 1 )
  {
    if ( *(_DWORD *)(this + 396) <= 0 )
    {
      *(_DWORD *)(this + 396) = 1;
    }
    else
    {
      v10 = (int)sub_10029DCE();
      if ( !v10 || *(_BYTE *)(v10 + 76) || (void *)sub_1002729E(v10) != v2 )
      {
        sub_100248F4((int)&v12);
        sub_1002D02B((int)&v12, (int)&unk_100604D0);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_1002B3B7);
      }
      sub_1002B9D1(v2);
    }
  }
  return v1;
}

//----- (1002B3B7) --------------------------------------------------------
int __thiscall sub_1002B3B7(void *this)
{
  _EAX = (int)((char *)this + 388);
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  return (*(int (**)(void))(*(_DWORD *)this + 16))();
}

//----- (1002B3C9) --------------------------------------------------------
int __userpurge sub_1002B3C9<eax>(int a1<ecx>, int a2<edi>, HANDLE hSourceHandle)
{
  int v3; // ebx@1
  int v4; // edx@3
  int v5; // ecx@3
  HANDLE v6; // ST08_4@3
  HANDLE v7; // ST04_4@3
  HANDLE v8; // eax@3
  int v9; // eax@4
  int v11; // eax@6
  int v12; // eax@7
  void *v13; // ecx@9
  int v14; // [sp-4h] [bp-1Ch]@7
  char v15; // [sp+4h] [bp-14h]@8
  int (__stdcall **v16)(char); // [sp+8h] [bp-10h]@7
  HANDLE TargetHandle; // [sp+14h] [bp-4h]@3

  v3 = a1;
  if ( hSourceHandle && hSourceHandle != (HANDLE)-1 )
  {
    TargetHandle = 0;
    v6 = GetCurrentProcess();
    v7 = hSourceHandle;
    v8 = GetCurrentProcess();
    if ( DuplicateHandle(v8, v7, v6, &TargetHandle, 0, 0, 2u) )
    {
      v11 = sub_10027EB3(v4, v5, v3, a2, 12);
      *(_DWORD *)(v11 + 8) = TargetHandle;
      return sub_10029676(v3 + 184, v11);
    }
    v9 = GetLastError();
    if ( v9 > 0 )
      v9 = (unsigned __int16)v9 | 0x80070000;
    sub_100249F4((int)&v15, v9);
    v14 = (int)&unk_10060498;
    v12 = (int)&v15;
  }
  else
  {
    hSourceHandle = "eventObject";
    sub_10023687((int)&v16, (int *)&hSourceHandle);
    v16 = &off_100542CC;
    v14 = (int)&unk_10061764;
    v12 = (int)&v16;
  }
  sub_1002D02B(v12, v14);
  __asm { int     3               ; Trap to Debugger }
  return sub_1002AD41(v13);
}
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);

//----- (1002B47A) --------------------------------------------------------
int __thiscall sub_1002B47A(int this)
{
  int v1; // esi@1

  _EDX = this + 384;
  _ESI = -1;
  __asm { lock xadd [edx], esi }
  v1 = _ESI - 1;
  if ( !v1 )
    sub_1002B165(this);
  return v1;
}

//----- (1002B494) --------------------------------------------------------
USHORT __thiscall sub_1002B494(int this, int a2)
{
  USHORT result; // ax@1
  int ebp0; // ebp@0
  union _SLIST_HEADER *v4; // edi@1
  int v5; // esi@1

  v5 = this;
  v4 = (union _SLIST_HEADER *)(this + 488);
  result = QueryDepthSList((PSLIST_HEADER)(this + 488));
  if ( (signed int)result >= *(_DWORD *)(v5 + 20) )
  {
    if ( a2 )
      result = (*(int (__stdcall **)(signed int))(*(_DWORD *)a2 + 20))(1);
  }
  else
  {
    sub_1003D5DE(a2, ebp0);
    result = (unsigned int)InterlockedPushEntrySList(v4, (PSINGLE_LIST_ENTRY)(a2 + 4));
  }
  return result;
}

//----- (1002B4DB) --------------------------------------------------------
int __thiscall sub_1002B4DB(void *this)
{
  _EAX = (int)((char *)this + 388);
  _EDX = -1;
  __asm { lock xadd [eax], edx }
  return (*(int (**)(void))(*(_DWORD *)this + 20))();
}

//----- (1002B4ED) --------------------------------------------------------
PSINGLE_LIST_ENTRY __thiscall sub_1002B4ED(int this, int a2, char a3)
{
  int v3; // esi@1

  v3 = this;
  if ( a3 )
    (*(void (__stdcall **)(int))(**(_DWORD **)(this + 420) + 12))(a2);
  _EAX = v3 + 400;
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  return InterlockedPushEntrySList((PSLIST_HEADER)(v3 + 480), (PSINGLE_LIST_ENTRY)(a2 + 8));
}

//----- (1002B52D) --------------------------------------------------------
int __thiscall sub_1002B52D(int this, int a2)
{
  int result; // eax@1
  union _SLIST_HEADER *v3; // edi@1
  int v4; // esi@1
  int v5; // edx@1

  v4 = this;
  v3 = (union _SLIST_HEADER *)(this + 496);
  v5 = QueryDepthSList((PSLIST_HEADER)(this + 496));
  result = 32 * *(_DWORD *)(v4 + 20);
  if ( v5 >= result )
  {
    if ( a2 )
      result = (**(int (__stdcall ***)(_DWORD))a2)(1);
  }
  else
  {
    result = (int)InterlockedPushEntrySList(v3, (PSINGLE_LIST_ENTRY)(a2 + 12));
  }
  return result;
}

//----- (1002B571) --------------------------------------------------------
PSINGLE_LIST_ENTRY __thiscall sub_1002B571(int this)
{
  PSINGLE_LIST_ENTRY result; // eax@1
  int v2; // edx@1
  union _SLIST_HEADER *v3; // ebx@1
  int v4; // edi@1
  int i; // esi@1
  PSINGLE_LIST_ENTRY v6; // eax@2
  PSINGLE_LIST_ENTRY v7; // esi@2

  v4 = this;
  v3 = (union _SLIST_HEADER *)(this + 504);
  result = InterlockedPopEntrySList((PSLIST_HEADER)(this + 504));
  v2 = (int)&result[-2];
  for ( i = result != 0 ? (int)&result[-2] : 0; i; i = v7 != 0 ? (int)result : 0 )
  {
    (*(void (__fastcall **)(_DWORD, _DWORD, _DWORD))(**(_DWORD **)(v4 + 420) + 12))(*(_DWORD *)(v4 + 420), v2, i);
    sub_1002B4ED(v4, i, 0);
    v6 = InterlockedPopEntrySList(v3);
    v7 = v6;
    result = v6 - 2;
  }
  return result;
}

//----- (1002B5BE) --------------------------------------------------------
BOOL __thiscall sub_1002B5BE(int this, LONG lReleaseCount)
{
  BOOL result; // eax@2

  if ( lReleaseCount > 0 )
    result = ReleaseSemaphore(*(HANDLE *)(this + 380), lReleaseCount, 0);
  return result;
}

//----- (1002B5DC) --------------------------------------------------------
int __thiscall sub_1002B5DC(void *this, int a2)
{
  int result; // eax@1

  *(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4) = *(_DWORD *)(a2 + 4);
  result = *(_DWORD *)this;
  if ( a2 == *(_DWORD *)this )
  {
    if ( result == *(_DWORD *)(result + 4) )
      result = 0;
    else
      result = *(_DWORD *)(result + 8);
    *(_DWORD *)this = result;
  }
  return result;
}

//----- (1002B60E) --------------------------------------------------------
char __thiscall sub_1002B60E(void *ListHead, int a2, signed int a3, char a4)
{
  signed int v4; // edx@1
  int v6; // esi@1
  char result; // al@2
  int v8; // eax@3
  int v9; // ecx@3
  int v10; // edx@4
  int v11; // edi@4
  int v12; // edx@5
  PSINGLE_LIST_ENTRY v18; // eax@14
  int v19; // ST08_4@14

  v6 = (int)ListHead;
  v4 = a3 >> *((_DWORD *)ListHead + 11);
  _EBX = a3 & (*((_DWORD *)ListHead + 10) - 1);
  if ( v4 < *((_DWORD *)ListHead + 15) )
  {
    v9 = *((_DWORD *)ListHead + 14);
    v8 = *(_DWORD *)(v6 + 52);
    if ( v4 < v9 )
    {
      v11 = *(_DWORD *)(v8 + 4 * v4);
    }
    else
    {
      v10 = v4 - v9;
      v11 = *(_DWORD *)(v8 + 4 * v9 - 4);
      if ( v10 >= 0 )
      {
        v12 = v10 + 1;
        do
        {
          v11 = *(_DWORD *)(v11 + 4);
          --v12;
        }
        while ( v12 );
      }
    }
    _ECX = *(_DWORD *)v11 + 4 * _EBX;
    _EDX = 0;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 == a2 )
    {
      _ECX = v11 + 8;
      __asm { lock cmpxchg [ecx], ebx }
      if ( a4 )
      {
        if ( (signed int)QueryDepthSList((PSLIST_HEADER)v6) <= *(_DWORD *)(v6 + 68) )
        {
          InterlockedPushEntrySList((PSLIST_HEADER)v6, (PSINGLE_LIST_ENTRY)(a2 + 4));
        }
        else
        {
          InterlockedPushEntrySList((PSLIST_HEADER)(v6 + 8), (PSINGLE_LIST_ENTRY)(a2 + 4));
          if ( (signed int)QueryDepthSList((PSLIST_HEADER)(v6 + 8)) > *(_DWORD *)(v6 + 68) )
          {
            if ( (*(_DWORD *)(*(_DWORD *)(v6 + 36) + 404) & 0xA0000000) != -1610612736 )
            {
              _EDX = 1;
              _ECX = v6 + 72;
              __asm { lock cmpxchg [ecx], edx }
              v18 = InterlockedFlushSList((PSLIST_HEADER)(v6 + 8));
              v19 = *(_DWORD *)(v6 + 36);
              *(_DWORD *)(v6 + 16) = v18;
              sub_1002ADAD(v6 + 20, sub_10029942, v6, v19);
            }
          }
        }
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002B70C) --------------------------------------------------------
char __thiscall sub_1002B70C(void *ListHead, int a2, signed int a3, char a4)
{
  signed int v4; // edx@1
  int v6; // esi@1
  char result; // al@2
  int v8; // eax@3
  int v9; // ecx@3
  int v10; // edx@4
  int v11; // edi@4
  int v12; // edx@5
  PSINGLE_LIST_ENTRY v18; // eax@14
  int v19; // ST08_4@14

  v6 = (int)ListHead;
  v4 = a3 >> *((_DWORD *)ListHead + 11);
  _EBX = a3 & (*((_DWORD *)ListHead + 10) - 1);
  if ( v4 < *((_DWORD *)ListHead + 15) )
  {
    v9 = *((_DWORD *)ListHead + 14);
    v8 = *(_DWORD *)(v6 + 52);
    if ( v4 < v9 )
    {
      v11 = *(_DWORD *)(v8 + 4 * v4);
    }
    else
    {
      v10 = v4 - v9;
      v11 = *(_DWORD *)(v8 + 4 * v9 - 4);
      if ( v10 >= 0 )
      {
        v12 = v10 + 1;
        do
        {
          v11 = *(_DWORD *)(v11 + 4);
          --v12;
        }
        while ( v12 );
      }
    }
    _ECX = *(_DWORD *)v11 + 4 * _EBX;
    _EDX = 0;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 == a2 )
    {
      _ECX = v11 + 8;
      __asm { lock cmpxchg [ecx], ebx }
      if ( a4 )
      {
        if ( (signed int)QueryDepthSList((PSLIST_HEADER)v6) <= *(_DWORD *)(v6 + 68) )
        {
          InterlockedPushEntrySList((PSLIST_HEADER)v6, (PSINGLE_LIST_ENTRY)(a2 + 52));
        }
        else
        {
          InterlockedPushEntrySList((PSLIST_HEADER)(v6 + 8), (PSINGLE_LIST_ENTRY)(a2 + 52));
          if ( (signed int)QueryDepthSList((PSLIST_HEADER)(v6 + 8)) > *(_DWORD *)(v6 + 68) )
          {
            if ( (*(_DWORD *)(*(_DWORD *)(v6 + 36) + 404) & 0xA0000000) != -1610612736 )
            {
              _EDX = 1;
              _ECX = v6 + 72;
              __asm { lock cmpxchg [ecx], edx }
              v18 = InterlockedFlushSList((PSLIST_HEADER)(v6 + 8));
              v19 = *(_DWORD *)(v6 + 36);
              *(_DWORD *)(v6 + 16) = v18;
              sub_1002ADAD(v6 + 20, sub_1002994E, v6, v19);
            }
          }
        }
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002B80A) --------------------------------------------------------
int __thiscall sub_1002B80A(void *this)
{
  int result; // eax@1
  int v2; // esi@3

  result = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    v2 = *(_DWORD *)(result + 4);
    if ( result == v2 )
    {
      *(_DWORD *)this = 0;
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)(v2 + 4) + 8) = result;
      *(_DWORD *)(*(_DWORD *)this + 4) = *(_DWORD *)(v2 + 4);
    }
    result = v2;
  }
  return result;
}

//----- (1002B832) --------------------------------------------------------
_DWORD *__thiscall sub_1002B832(void *this)
{
  _DWORD *result; // eax@1
  _DWORD *v2; // esi@3

  result = *(_DWORD **)this;
  if ( *(_DWORD *)this )
  {
    v2 = (_DWORD *)*result;
    if ( result == (_DWORD *)*result )
    {
      *(_DWORD *)this = 0;
    }
    else
    {
      *(_DWORD *)(*v2 + 4) = result;
      **(_DWORD **)this = *v2;
    }
    result = v2;
  }
  return result;
}

//----- (1002B856) --------------------------------------------------------
_DWORD *__thiscall sub_1002B856(int this)
{
  void *v2; // edi@1
  void *v3; // esi@1
  _DWORD *v4; // edi@1

  v2 = (void *)this;
  v3 = (void *)(this + 4);
  sub_10024558((void *)(this + 4));
  v4 = sub_1002B832(v2);
  sub_10024692(v3);
  return v4;
}

//----- (1002B879) --------------------------------------------------------
int __thiscall sub_1002B879(int this, int a2)
{
  int v2; // ebx@1
  void *v3; // edi@1

  v2 = this;
  v3 = (void *)(this + 308);
  sub_10024558((void *)(this + 308));
  if ( *(_DWORD *)(a2 + 12) == 2 )
    sub_1002B5DC((void *)(v2 + 304), a2);
  *(_DWORD *)(a2 + 12) = 0;
  return sub_10024692(v3);
}

//----- (1002B8B5) --------------------------------------------------------
char __thiscall sub_1002B8B5(int this, int a2)
{
  return sub_1002B70C((void *)(this + 96), a2, *(_DWORD *)(a2 + 24), 1);
}

//----- (1002B8CD) --------------------------------------------------------
char __thiscall sub_1002B8CD(int this)
{
  char result; // al@1
  int v2; // esi@1

  v2 = this;
  result = sub_10038833(this);
  *(_DWORD *)(v2 + 56) = 0;
  return result;
}

//----- (1002B8DB) --------------------------------------------------------
int __thiscall sub_1002B8DB(void *this, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // esi@2
  unsigned int v5; // edi@4
  int v6; // eax@5
  int v7; // ebx@5
  char v8; // al@5
  int v9; // eax@5
  int v10; // esi@6
  int v11; // eax@9
  char v12; // [sp+0h] [bp-14h]@8
  int (__stdcall **v13)(char); // [sp+4h] [bp-10h]@18
  int v14; // [sp+8h] [bp-Ch]@7
  BOOL (__cdecl *v15)(); // [sp+Ch] [bp-8h]@7
  int v16; // [sp+10h] [bp-4h]@1

  result = a2;
  v16 = (int)this;
  if ( !a2 )
  {
    a3 = (unsigned int)"ppVirtualProcessorRoots";
    goto LABEL_18;
  }
  v4 = a3;
  if ( a3 < 1 )
  {
    a3 = (unsigned int)"count";
LABEL_18:
    sub_10023687((int)&v13, (int *)&a3);
    v13 = &off_100542CC;
    sub_1002D02B((int)&v13, (int)&unk_10061764);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1002B9D1);
  }
  v5 = 0;
  if ( a3 )
  {
    do
    {
      v7 = *(_DWORD *)(result + 4 * v5);
      v8 = (*(int (__thiscall **)(int))(*(_DWORD *)v7 + 4))(v7);
      sub_1002A659(v16, v8);
      v9 = (**(int (__thiscall ***)(_DWORD))v7)(v7);
      v6 = sub_1003B7C3(*(_DWORD *)(*(_DWORD *)(v16 + 32) + 4 * v9), v7);
      if ( !v6 )
      {
        v10 = v16;
        do
        {
          v14 = 0;
          v15 = sub_1002C66E;
          while ( sub_1001FF20((int)&v12) )
            ;
          SwitchToThread();
          v11 = (**(int (__thiscall ***)(_DWORD))v7)(v7);
          v6 = sub_1003B7C3(*(_DWORD *)(*(_DWORD *)(v10 + 32) + 4 * v11), v7);
        }
        while ( !v6 );
        v4 = a3;
      }
      if ( *(_BYTE *)(v6 + 160) )
        v6 = sub_1003C1CC(*(_DWORD *)(v6 + 164), v6);
      if ( v6 )
        sub_1003AEA5(v6);
      result = a2;
      ++v5;
    }
    while ( v5 < v4 );
  }
  return result;
}
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);

//----- (1002B9D1) --------------------------------------------------------
int __thiscall sub_1002B9D1(void *this)
{
  int v1; // eax@1
  void *v3; // edi@1
  int result; // eax@3

  v3 = this;
  _EBX = (int)((char *)this + 404);
  v1 = sub_1002BB64((int)((char *)this + 404), -2147483648);
  _EDX = v1 & 0x7FFFFFFF;
  __asm { lock cmpxchg [ebx], edx }
  while ( v1 != v1 )
  {
    _ECX = v1 & 0x7FFFFFFF;
    __asm { lock cmpxchg [ebx], ecx }
  }
  result = (int)((char *)v3 + 392);
  _ECX = 1;
  __asm { lock xadd [eax], ecx }
  return result;
}

//----- (1002BA1E) --------------------------------------------------------
void *__cdecl sub_1002BA1E(void *ListEntry)
{
  void *result; // eax@4

  if ( *((_BYTE *)ListEntry + 772) )
  {
    _ECX = &dword_10069424;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
  }
  if ( QueryDepthSList(&ListHead) >= 0x10u )
    result = sub_1002945E(ListEntry, 1);
  else
    result = InterlockedPushEntrySList(&ListHead, (PSINGLE_LIST_ENTRY)ListEntry);
  return result;
}
// 10069424: using guessed type int dword_10069424;

//----- (1002BA65) --------------------------------------------------------
LPVOID __cdecl sub_1002BA65()
{
  LPVOID result; // eax@2

  if ( dword_10066D24 & 0x80000000 )
    result = TlsGetValue(dwTlsIndex);
  else
    result = 0;
  return result;
}
// 10066D24: using guessed type int dword_10066D24;

//----- (1002BA81) --------------------------------------------------------
char __thiscall sub_1002BA81(void *this)
{
  int v2; // edx@2

  _ESI = (int)((char *)this + 384);
  while ( 1 )
  {
    v2 = *(_DWORD *)_ESI;
    if ( !*(_DWORD *)_ESI )
      break;
    _ECX = v2 + 1;
    __asm { lock cmpxchg [esi], ecx }
    if ( v2 == v2 )
      return 1;
  }
  return 0;
}

//----- (1002BAA3) --------------------------------------------------------
int __thiscall sub_1002BAA3(void *this)
{
  int v1; // eax@1
  void *v2; // edi@1
  int v3; // esi@1
  int v4; // ecx@3

  v2 = this;
  v1 = (int)sub_10029DCE();
  v3 = v1;
  if ( v1 && (void *)sub_1002729E(v1) == v2 )
    v4 = sub_10027277(v3);
  else
    v4 = *((_DWORD *)v2 + 44);
  return (**(int (***)(void))v4)();
}

//----- (1002BAD8) --------------------------------------------------------
int __thiscall sub_1002BAD8(void *this, int a2, int a3, int a4)
{
  int v4; // eax@1
  void *v5; // edi@1
  int v6; // esi@1
  int v7; // eax@3

  v5 = this;
  v4 = (int)sub_10029DCE();
  v6 = v4;
  if ( v4 && (void *)sub_1002729E(v4) == v5 )
    v7 = sub_10027277(v6);
  else
    v7 = *((_DWORD *)v5 + 44);
  return sub_100388DB((void *)v7, a2, a3, a4);
}

//----- (1002BB0E) --------------------------------------------------------
void __thiscall sub_1002BB0E(int this, int a2)
{
  if ( *(_DWORD *)(this + 12) == 1 )
    *(_DWORD *)(this + 376) = sub_1002A573(this, *(_DWORD *)(a2 + 184));
}

//----- (1002BB33) --------------------------------------------------------
int __cdecl sub_1002BB33(int a1, int a2)
{
  int result; // eax@1
  char v3; // [sp+8h] [bp-10h]@3
  int v4; // [sp+10h] [bp-8h]@2
  void (__cdecl *v5)(); // [sp+14h] [bp-4h]@2

  result = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 & a2 )
  {
    v4 = 0;
    v5 = sub_1002C630;
    do
    {
      sub_1001FF20((int)&v3);
      result = *(_DWORD *)a1;
    }
    while ( *(_DWORD *)a1 & a2 );
  }
  return result;
}

//----- (1002BB64) --------------------------------------------------------
int __cdecl sub_1002BB64(int a1, int a2)
{
  int v2; // edx@1
  char v4; // [sp+4h] [bp-10h]@3
  int v5; // [sp+Ch] [bp-8h]@2
  void (__cdecl *v6)(); // [sp+10h] [bp-4h]@2

  v2 = *(_DWORD *)a1;
  if ( (a2 & *(_DWORD *)a1) != a2 )
  {
    v5 = 0;
    v6 = sub_1002C630;
    do
    {
      sub_1001FF20((int)&v4);
      v2 = *(_DWORD *)a1;
    }
    while ( (a2 & *(_DWORD *)a1) != a2 );
  }
  return v2;
}

//----- (1002BB9E) --------------------------------------------------------
char __thiscall sub_1002BB9E(void *this, int a2, char a3, int a4, int a5, int a6)
{
  void *v7; // esi@1
  char v8; // [sp-14h] [bp-1Ch]@1
  int v9; // [sp-10h] [bp-18h]@1
  int v10; // [sp-Ch] [bp-14h]@1
  int v11; // [sp-8h] [bp-10h]@1
  int v12; // [sp-4h] [bp-Ch]@1

  v12 = 3;
  v7 = this;
  sub_10027C4E((int)&v8, (int)&a3);
  return sub_1002BBC4(v7, a2, v8, v9, v10, v11, v12);
}

//----- (1002BBC4) --------------------------------------------------------
char __thiscall sub_1002BBC4(void *this, int a2, char a3, int a4, int a5, int a6, int a7)
{
  int v7; // ecx@1
  char v8; // bl@1
  int v9; // esi@1
  char v11; // [sp-14h] [bp-24h]@1
  int v12; // [sp-10h] [bp-20h]@1
  int v13; // [sp-Ch] [bp-1Ch]@1
  int v14; // [sp-8h] [bp-18h]@1
  int v15; // [sp-4h] [bp-14h]@1
  int v16; // [sp+8h] [bp-8h]@1
  int v17; // [sp+Ch] [bp-4h]@2

  v9 = (int)this;
  v8 = 0;
  sub_10027846(this);
  v15 = a7;
  v16 = 0;
  sub_10027C4E((int)&v11, (int)&a3);
  if ( sub_10029FED(v9, (int)&v16, *(int *)&v11, v12, v13, v14, v15) )
  {
    sub_1003ABAA(v17, v16, a2, 0);
    v16 = 0;
    v8 = 1;
  }
  sub_10027846(v7);
  return v8;
}
// 10027846: using guessed type _DWORD __thiscall sub_10027846(_DWORD ecx0);

//----- (1002BC18) --------------------------------------------------------
void __cdecl sub_1002BC18()
{
  JUMPOUT(dword_100693F8, 0, *(unsigned int *)sub_10028B1A);
}
// 100693F8: using guessed type int dword_100693F8;

//----- (1002BC7B) --------------------------------------------------------
int __thiscall sub_1002BC7B(void *this, int a2, int a3, int a4)
{
  int v4; // edi@1
  void *v5; // esi@1
  int v6; // ebx@2
  int v7; // eax@4
  signed int v8; // esi@4
  int v9; // eax@5
  int v10; // edx@6
  int v11; // eax@6
  int v12; // ecx@6
  int result; // eax@10
  signed int v14; // ebx@10
  int v15; // edx@10
  int v16; // ecx@10
  int v17; // eax@12
  int v18; // edi@12
  int v19; // eax@13
  int v20; // edx@13
  int v21; // ecx@13
  void *v22; // [sp+Ch] [bp-Ch]@1
  int v23; // [sp+10h] [bp-8h]@5
  int i; // [sp+14h] [bp-4h]@1

  v5 = this;
  v4 = 0;
  v22 = this;
  for ( i = 0; v4 < *((_DWORD *)v5 + 11); i = v4 )
  {
    v6 = *(_DWORD *)(*((_DWORD *)v5 + 8) + 4 * v4);
    if ( v6 )
    {
      if ( *(_DWORD *)(v6 + 120) > 0 )
      {
        v8 = 0;
        v7 = v6 + 56;
        do
        {
          v9 = sub_10037C97(v7, v8);
          v23 = v9;
          if ( v9 )
          {
            v10 = *(_DWORD *)(v9 + 92) - *(_DWORD *)(v9 + 100);
            *(_DWORD *)(v9 + 100) = *(_DWORD *)(v9 + 92);
            v11 = *(_DWORD *)(v9 + 96);
            v12 = v11 - *(_DWORD *)(v23 + 104);
            *(_DWORD *)(v23 + 104) = v11;
            *(_DWORD *)a3 += v10;
            *(_DWORD *)a2 += v12;
            *(_DWORD *)a4 += v10 - v12;
          }
          ++v8;
          v7 = v6 + 56;
        }
        while ( v8 < *(_DWORD *)(v6 + 120) );
        v5 = v22;
        v4 = i;
      }
    }
    ++v4;
  }
  v15 = *((_DWORD *)v5 + 109) - *((_DWORD *)v5 + 111);
  *((_DWORD *)v5 + 111) = *((_DWORD *)v5 + 109);
  v16 = *((_DWORD *)v5 + 110) - *((_DWORD *)v5 + 112);
  *((_DWORD *)v5 + 112) = *((_DWORD *)v5 + 110);
  v14 = 0;
  *(_DWORD *)a3 += v15;
  *(_DWORD *)a2 += v16;
  result = a4;
  *(_DWORD *)result += v15 - v16;
  if ( *((_DWORD *)v5 + 66) > 0 )
  {
    result = (int)((char *)v5 + 200);
    do
    {
      v17 = sub_10037C97(result, v14);
      v18 = v17;
      if ( v17 )
      {
        v19 = *(_DWORD *)(v17 + 12);
        v20 = *(_DWORD *)(v18 + 8) - *(_DWORD *)(v18 + 16);
        *(_DWORD *)(v18 + 16) = *(_DWORD *)(v18 + 8);
        v21 = v19 - *(_DWORD *)(v18 + 20);
        *(_DWORD *)(v18 + 20) = v19;
        *(_DWORD *)a3 += v20;
        *(_DWORD *)a2 += v21;
        *(_DWORD *)a4 += v20 - v21;
        if ( !sub_1002AE24(v18) )
        {
          sub_1002B60E((char *)v5 + 200, v18, *(_DWORD *)v18, 0);
          sub_1002404A((LPVOID)v18);
        }
      }
      ++v14;
      result = (int)((char *)v5 + 200);
    }
    while ( v14 < *((_DWORD *)v5 + 66) );
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1002BDB4) --------------------------------------------------------
BOOL __thiscall sub_1002BDB4(void *this)
{
  LPVOID v1; // eax@1
  int v2; // esi@1
  int v3; // eax@4
  BOOL result; // eax@5
  int v5; // eax@9
  char v8; // [sp+Fh] [bp-1h]@1

  v2 = (int)this;
  v1 = sub_10029DCE();
  v8 = 1;
  if ( v1 )
  {
    if ( !*((_BYTE *)v1 + 76) )
    {
      v8 = 0;
      sub_1003AF6A();
    }
  }
  v3 = (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 72))(v2);
  if ( v3 )
  {
    if ( v3 == 2 )
    {
      if ( !*(_DWORD *)(v2 + 408) )
        *(_DWORD *)(v2 + 408) = 1;
    }
    _EBX = v2 + 404;
    v5 = *(_DWORD *)(v2 + 404);
    do
    {
      _ECX = v5 & 0xBFFFFFFF;
      __asm { lock cmpxchg [ebx], ecx }
    }
    while ( v5 != v5 );
    result = sub_1002B5BE(v2, v5 & 0x1FFFFFFF);
  }
  else
  {
    result = sub_1002B1DB(v2);
  }
  if ( !v8 )
    result = sub_1003AF6A();
  return result;
}

//----- (1002BE3E) --------------------------------------------------------
char __thiscall sub_1002BE3E(int this)
{
  char result; // al@1
  int ebp0; // ebp@0
  int v4; // edi@1
  int i; // eax@2
  char v6; // dl@4
  char v7; // al@4
  char v8; // al@7
  int v9; // ecx@13
  int v16; // esi@16
  ULONG v17; // eax@18
  int v18; // esi@18
  DWORD v19; // eax@18
  char v20; // [sp-14h] [bp-38h]@16
  int v21; // [sp-10h] [bp-34h]@16
  int v22; // [sp-Ch] [bp-30h]@16
  int v23; // [sp-8h] [bp-2Ch]@16
  int v24; // [sp-4h] [bp-28h]@16
  int v25; // [sp+Ch] [bp-18h]@16
  int v26; // [sp+14h] [bp-10h]@16
  int v27; // [sp+18h] [bp-Ch]@16
  __int16 v28; // [sp+22h] [bp-2h]@2

  result = 0;
  v4 = this;
  _EBX = this + 472;
  if ( *(_DWORD *)(this + 472) > 0 )
  {
    v28 = 0;
    for ( i = sub_1002A37E(ebp0, 0); ; i = sub_1002A37E(ebp0, 0) )
    {
      if ( !i )
      {
        v6 = HIBYTE(v28);
        v8 = 1;
        LOBYTE(v28) = 1;
        goto LABEL_10;
      }
      v7 = sub_1002AED2(v4, i);
      v6 = v7 | HIBYTE(v28);
      HIBYTE(v28) |= v7;
      if ( *(_DWORD *)(v4 + 432) <= 0 )
        break;
      if ( sub_1002BFBA(v4, 1) )
      {
        v6 = HIBYTE(v28);
        break;
      }
    }
    v8 = v28;
LABEL_10:
    if ( !*(_DWORD *)(v4 + 408) && (v8 || *(_DWORD *)(v4 + 432) > 0) )
      goto LABEL_24;
    v9 = *(_DWORD *)_EBX;
    _EAX = -*(_DWORD *)_EBX;
    __asm { lock xadd [ebx], eax }
    result = _EAX != v9;
    if ( result )
    {
LABEL_18:
      v18 = sub_1002BFBA(v4, 1);
      v19 = GetTickCount();
      v17 = v19 - *(_DWORD *)(v4 + 456) < v18 ? v18 - (v19 - *(_DWORD *)(v4 + 456)) : 0;
      if ( (_BYTE)v28 )
      {
        if ( v17 < 0x1F4 )
          v17 = 500;
      }
      v24 = 2147483647;
      v23 = v17;
      v22 = *(_DWORD *)(v4 + 468);
      return ChangeTimerQueueTimer(0, (HANDLE)v22, v17, 0x7FFFFFFFu);
    }
    if ( *(_DWORD *)(v4 + 408) )
    {
      if ( !v6 )
      {
        v25 = 0;
        v26 = 0;
        v27 = 0;
        v16 = *(_DWORD *)(sub_1002A552(v4) + 8);
        v24 = 11;
        sub_10027C4E((int)&v20, (int)&v25);
        result = sub_1002BBC4((void *)v4, v16, v20, v21, v22, v23, v24);
        if ( !result )
        {
LABEL_24:
          *(_DWORD *)_EBX = 1;
          goto LABEL_18;
        }
      }
    }
  }
  return result;
}

//----- (1002BF63) --------------------------------------------------------
char __stdcall sub_1002BF63(int a1, int a2)
{
  return sub_1002BE3E(a1);
}

//----- (1002BF72) --------------------------------------------------------
char __stdcall sub_1002BF72(int a1, int a2)
{
  DWORD v2; // eax@1
  int v3; // esi@1
  char result; // al@2

  v3 = sub_1002BFBA(a1, 1);
  v2 = GetTickCount() - *(_DWORD *)(a1 + 456);
  if ( v2 >= v3 )
    result = sub_1002BE3E(a1);
  else
    result = ChangeTimerQueueTimer(0, *(HANDLE *)(a1 + 468), v3 - v2, 0x7FFFFFFFu);
  return result;
}

//----- (1002BFBA) --------------------------------------------------------
int __thiscall sub_1002BFBA(int this, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // ecx@1
  int result; // eax@2
  unsigned int v5; // eax@3
  int v6; // eax@4

  v2 = *(_DWORD *)(this + 400);
  v3 = *(_DWORD *)(this + 452);
  if ( v2 >= v3 )
  {
    v5 = v2 - v3;
    if ( v5 >= 0x64 )
    {
      if ( v5 >= 0x12C )
      {
        if ( v5 >= 0x258 )
        {
          if ( v5 >= 0x5DC )
          {
            if ( v5 >= 0x9C4 )
            {
              if ( v5 >= 0xFA0 )
                v6 = (v5 >> 1) + 8200;
              else
                v6 = v5 / 3 + 2500;
            }
            else
            {
              v6 = v5 / 3 + 555;
            }
          }
          else
          {
            v6 = (v5 >> 2) + 180;
          }
        }
        else
        {
          v6 = v5 / 5 + 60;
        }
      }
      else
      {
        v6 = (v5 >> 3) + 15;
      }
    }
    else
    {
      v6 = v5 / 0xA + 5;
    }
    result = a2 * v6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002C051) --------------------------------------------------------
int __cdecl sub_1002C051(char a1, char a2, int a3)
{
  int v3; // ebx@1
  int result; // eax@2
  __int16 v5; // [sp+4h] [bp-40h]@2
  char v6; // [sp+6h] [bp-3Eh]@2
  char v7; // [sp+8h] [bp-3Ch]@2
  char v8; // [sp+9h] [bp-3Bh]@2
  int v9; // [sp+1Ch] [bp-28h]@2
  int v10; // [sp+20h] [bp-24h]@2
  int v11; // [sp+24h] [bp-20h]@2
  int v12; // [sp+28h] [bp-1Ch]@2
  int v13; // [sp+30h] [bp-14h]@2
  int v14; // [sp+38h] [bp-Ch]@2

  v3 = dword_100693F8;
  if ( dword_100693F8 )
  {
    sub_10030CF0(&v6, 0, 62);
    v13 = 131072;
    v5 = 64;
    v7 = a1;
    v8 = a2;
    v9 = dword_1005BFA0[0];
    v10 = dword_1005BFA0[1];
    v11 = dword_1005BFA0[2];
    v12 = dword_1005BFA0[3];
    v14 = a3;
    result = sub_10028A7A(v3, dword_100693F0, dword_100693F4, (int)&v5);
  }
  return result;
}
// 100693F0: using guessed type int dword_100693F0;
// 100693F4: using guessed type int dword_100693F4;
// 100693F8: using guessed type int dword_100693F8;

//----- (1002C0BC) --------------------------------------------------------
int __stdcall sub_1002C0BC(char a1, char a2, int a3)
{
  int result; // eax@2

  if ( a2 <= (unsigned __int8)byte_100693EC )
  {
    result = dword_100693E8;
    if ( dword_100693E8 & 1 )
      result = sub_1002C051(a1, a2, a3);
  }
  return result;
}
// 100693E8: using guessed type int dword_100693E8;
// 100693EC: using guessed type char byte_100693EC;

//----- (1002C0E6) --------------------------------------------------------
int __thiscall sub_1002C0E6(int this, int a2)
{
  void *v2; // edi@1
  int v3; // esi@1

  v3 = this;
  v2 = (void *)(this + 324);
  sub_1002C615((void *)(this + 324));
  if ( *(_DWORD *)a2 != *(_DWORD *)(v3 + 336) )
    sub_1002B263((void *)v3);
  return sub_1002C625(v2);
}

//----- (1002C11B) --------------------------------------------------------
signed int __thiscall sub_1002C11B(int this)
{
  int v1; // esi@1
  signed int result; // eax@4

  v1 = this;
  if ( sub_1002A0EA(this) || sub_1002A114((void *)v1) )
  {
    result = 1;
  }
  else
  {
    if ( *(_DWORD *)(v1 + 472) <= 0 )
      result = 0;
    else
      result = 2;
  }
  return result;
}

//----- (1002C149) --------------------------------------------------------
int __thiscall sub_1002C149(int this, int a2)
{
  int v2; // esi@1
  int result; // eax@5

  v2 = this;
  if ( a2 == -1 )
  {
    *(_DWORD *)(this + 340) = 0;
    *(_DWORD *)(this + 344) = sub_10029B42(this);
  }
  else
  {
    *(_DWORD *)(this + 340) = a2;
  }
  if ( *(_DWORD *)(v2 + 340) == *(_DWORD *)(v2 + 344) )
    result = 0;
  else
    result = *(_DWORD *)(v2 + 344);
  return result;
}

//----- (1002C191) --------------------------------------------------------
signed int __thiscall sub_1002C191(int this)
{
  signed int v1; // ecx@1
  int v2; // esi@1
  signed int result; // eax@2

  v2 = this;
  v1 = sub_10029B42(this);
  if ( (unsigned int)v1 > *(_DWORD *)(v2 + 344) )
  {
    if ( *(_DWORD *)(v2 + 344) == *(_DWORD *)(v2 + 340) )
      result = v1;
    else
      result = 0;
    *(_DWORD *)(v2 + 344) = v1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002C1C3) --------------------------------------------------------
char __thiscall sub_1002C1C3(int this, int a2)
{
  void *v2; // esi@1
  int v3; // eax@2
  int v5; // edx@3
  char result; // al@8
  int v15; // edi@9

  v2 = (void *)this;
  if ( (_BYTE)a2 )
  {
    _EDI = this + 404;
    v3 = *(_DWORD *)(this + 404);
    while ( 1 )
    {
      v5 = v3;
      if ( v3 & 0x40000000 )
        v5 = sub_1002BB33((int)((char *)v2 + 404), 1073741824);
      if ( v5 & 0x20000000 )
        break;
      _ECX = v5 + 1;
      v3 = v5;
      __asm { lock cmpxchg [edi], ecx }
      if ( v5 == v5 )
      {
        _EAX = (int)((char *)v2 + 424);
        _ECX = 1;
        __asm { lock xadd [eax], ecx }
        (*(void (__thiscall **)(void *, int, int))(*(_DWORD *)v2 + 68))(v2, a2, _ECX + 1);
        goto LABEL_12;
      }
    }
    result = 0;
  }
  else
  {
    _EDI = -1;
    _EAX = this + 424;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    (*(void (__thiscall **)(void *, _DWORD, int))(*(_DWORD *)v2 + 68))(v2, 0, _ECX - 1);
    _EAX = (int)((char *)v2 + 404);
    __asm { lock xadd [eax], edi }
    v15 = _EDI - 1;
    if ( !(v15 & 0x1FFFFFFF) )
    {
      if ( v15 < 0 )
        sub_10029897(v2);
    }
LABEL_12:
    result = 1;
  }
  return result;
}

//----- (1002C264) --------------------------------------------------------
int __thiscall sub_1002C264(void *this, char a2)
{
  void *v3; // esi@1
  int v4; // ecx@2

  v3 = this;
  sub_10027846(this);
  _EAX = (int)((char *)v3 + 404);
  if ( a2 )
  {
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    v4 = _ECX - 1;
    if ( !(v4 & 0x1FFFFFFF) )
    {
      if ( v4 < 0 )
        sub_10029897(v3);
    }
  }
  else
  {
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
    v4 = _ECX + 1;
    if ( v4 & 0x40000000 )
      WaitForSingleObject(*((HANDLE *)v3 + 95), 0xFFFFFFFFu);
  }
  return sub_10027846(v4);
}
// 10027846: using guessed type _DWORD __thiscall sub_10027846(_DWORD ecx0);

//----- (1002C2C0) --------------------------------------------------------
void __thiscall sub_1002C2C0(int this)
{
  int v1; // edi@1
  int v2; // ebx@2
  void *v3; // eax@3
  void *v4; // esi@4
  int v5; // eax@6

  v1 = this;
  if ( *(_DWORD *)(this + 4) > 0 )
  {
    v2 = 0;
    if ( *(_DWORD *)this > 0 )
    {
      do
      {
        v3 = *(void **)(*(_DWORD *)(v1 + 8) + 4 * v2);
        if ( v3 )
        {
          do
          {
            v4 = *(void **)v3;
            sub_1002404A(v3);
            v3 = v4;
          }
          while ( v4 );
        }
        ++v2;
      }
      while ( v2 < *(_DWORD *)v1 );
    }
    v5 = *(_DWORD *)v1;
    *(_DWORD *)(v1 + 4) = 0;
    sub_10030CF0(*(void **)(v1 + 8), 0, 4 * v5);
  }
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1002C30A) --------------------------------------------------------
int __thiscall sub_1002C30A(void *this)
{
  return (*(int (**)(void))(**(_DWORD **)this + 16))();
}

//----- (1002C311) --------------------------------------------------------
int __thiscall sub_1002C311(void *this)
{
  return (*(int (**)(void))(**(_DWORD **)this + 20))();
}

//----- (1002C318) --------------------------------------------------------
void __cdecl sub_1002C318()
{
  JUMPOUT((unsigned int)hLibModule, 0, *(unsigned int *)sub_1002995A);
}

//----- (1002C326) --------------------------------------------------------
void *__thiscall sub_1002C326(void *this, int a2)
{
  _ESI = a2;
  _EDX = 1;
  *(_DWORD *)this = a2;
  __asm { lock cmpxchg [esi], edx }
  return this;
}

//----- (1002C36C) --------------------------------------------------------
_DWORD *__thiscall sub_1002C36C(void *this)
{
  _DWORD *result; // eax@1

  result = *(_DWORD **)this;
  **(_DWORD **)this = 0;
  return result;
}

//----- (1002C373) --------------------------------------------------------
int __cdecl sub_1002C373(int a1)
{
  return a1 ^ dword_10069CB8;
}
// 10069CB8: using guessed type int dword_10069CB8;

//----- (1002C380) --------------------------------------------------------
BOOL __cdecl sub_1002C380(int a1)
{
  BOOL result; // eax@1

  sub_10031317(a1, 0, 0, 0);
  sub_1003137F(a1, 1);
  sub_10030EF3(a1);
  sub_1002995A();
  result = (BOOL)hLibModule;
  if ( hLibModule )
    result = FreeLibrary(hLibModule);
  return result;
}

//----- (1002C3BC) --------------------------------------------------------
HMODULE __cdecl sub_1002C3BC(DWORD dwExitCode)
{
  HMODULE result; // eax@1

  _ECX = &unk_10069440;
  _EAX = -1;
  __asm { lock xadd [ecx], eax }
  if ( _ZF )
  {
    sub_1002995A();
    result = hLibModule;
    if ( hLibModule )
      FreeLibraryAndExitThread(hLibModule, dwExitCode);
  }
  return result;
}

//----- (1002C3E7) --------------------------------------------------------
unsigned int __cdecl sub_1002C3E7()
{
  unsigned int v0; // esi@1
  HANDLE v1; // eax@1
  struct _FILETIME CreationTime; // [sp+4h] [bp-10h]@1
  struct _FILETIME ExitTime; // [sp+Ch] [bp-8h]@1

  dword_10069C98 = 1;
  v0 = __security_cookie ^ (unsigned int)EncodePointer(&dword_10069CB8);
  v1 = GetCurrentThread();
  if ( GetThreadTimes(v1, &CreationTime, &ExitTime, &ExitTime, &ExitTime) )
    v0 ^= CreationTime.dwLowDateTime ^ CreationTime.dwHighDateTime;
  return v0;
}
// 10067210: using guessed type int __security_cookie;
// 10069C98: using guessed type int dword_10069C98;
// 10069CB8: using guessed type int dword_10069CB8;

//----- (1002C433) --------------------------------------------------------
HANDLE __cdecl sub_1002C433(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
{
  HANDLE v6; // edi@1

  v6 = CreateThread(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
  if ( v6 )
  {
    _ESI = 1;
    _EAX = &unk_10069440;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
    if ( _ECX == 0 )
    {
      sub_1002C47E();
      _EAX = &dword_10066D24;
      __asm { lock xadd [eax], esi }
    }
  }
  return v6;
}
// 10066D24: using guessed type int dword_10066D24;

//----- (1002C47E) --------------------------------------------------------
HMODULE __cdecl sub_1002C47E()
{
  HMODULE result; // eax@1
  DWORD v1; // eax@2
  int v2; // eax@6
  char v3; // [sp+4h] [bp-21Ch]@8
  WCHAR LibFileName; // [sp+14h] [bp-20Ch]@2
  unsigned int v5; // [sp+21Ch] [bp-4h]@1
  int v6; // [sp+220h] [bp+0h]@1

  v5 = (unsigned int)&v6 ^ __security_cookie;
  result = GetModuleHandleA(0);
  if ( result != (HMODULE)268435456 )
  {
    v1 = GetModuleFileNameW((HMODULE)0x10000000, &LibFileName, 0x104u);
    if ( !v1 || v1 == 260 )
    {
      v2 = GetLastError();
      if ( v2 > 0 )
        v2 = (unsigned __int16)v2 | 0x80070000;
      sub_100249F4((int)&v3, v2);
      sub_1002D02B((int)&v3, (int)&unk_10060498);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1002C512);
    }
    result = LoadLibraryExW(&LibFileName, 0, 0);
    hLibModule = result;
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;

//----- (1002C512) --------------------------------------------------------
int __cdecl sub_1002C512(unsigned int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  __int64 v12; // [sp+8h] [bp-8h]@2

  result = sub_10030F4A(a2, a3, 0);
  v4 = result;
  if ( result )
  {
    sub_1002C47E();
    _ECX = &dword_10066D24;
    _EAX = 1;
    __asm { lock xadd [ecx], eax }
    v12 = sub_100315D0(a1, -10000i64);
    sub_10031317(v4, (int)&v12, 0, 0);
    result = v4;
  }
  return result;
}
// 10066D24: using guessed type int dword_10066D24;

//----- (1002C56C) --------------------------------------------------------
int __cdecl sub_1002C56C(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_10030F6B(a2, a3, 0);
  v4 = result;
  if ( result )
  {
    sub_1002C47E();
    _ECX = &dword_10066D24;
    _EAX = 1;
    __asm { lock xadd [ecx], eax }
    sub_10031337(v4, a1, 0);
    result = v4;
  }
  return result;
}
// 10066D24: using guessed type int dword_10066D24;

//----- (1002C5AA) --------------------------------------------------------
int __cdecl sub_1002C5AA(int a1, int a2)
{
  int result; // eax@1

  sub_10031317(a2, 0, 0, 0);
  sub_10030EF3(a2);
  sub_1002995A();
  result = (int)hLibModule;
  if ( hLibModule )
    result = sub_1003101A(a1, (int)hLibModule);
  return result;
}

//----- (1002C5E0) --------------------------------------------------------
int __cdecl sub_1002C5E0(int a1, int a2)
{
  int result; // eax@1

  sub_10031337(a2, 0, 0);
  sub_10030F0A(a2);
  sub_1002995A();
  result = (int)hLibModule;
  if ( hLibModule )
    result = sub_1003101A(a1, (int)hLibModule);
  return result;
}

//----- (1002C615) --------------------------------------------------------
int __thiscall sub_1002C615(void *this)
{
  void *v2; // esi@1

  v2 = this;
  sub_10027846(this);
  return sub_10028AD5(v2);
}
// 10027846: using guessed type _DWORD __thiscall sub_10027846(_DWORD ecx0);

//----- (1002C625) --------------------------------------------------------
int __thiscall sub_1002C625(void *this)
{
  *(_DWORD *)this = 0;
  return sub_10027846(this);
}
// 10027846: using guessed type _DWORD __thiscall sub_10027846(_DWORD ecx0);

//----- (1002C630) --------------------------------------------------------
void __cdecl sub_1002C630()
{
  Sleep(0);
}

//----- (1002C639) --------------------------------------------------------
char __thiscall sub_1002C639(void *this)
{
  int v1; // ecx@1
  char v2; // bl@1
  void *v3; // esi@1

  v3 = this;
  sub_10027846(this);
  v2 = sub_1002C659(v3);
  if ( !v2 )
    sub_10027846(v1);
  return v2;
}
// 10027846: using guessed type _DWORD __thiscall sub_10027846(_DWORD ecx0);

//----- (1002C659) --------------------------------------------------------
char __thiscall sub_1002C659(void *this)
{
  char v1; // dl@2
  int v2; // eax@2

  if ( *(_DWORD *)this || (v1 = 1, v2 = *(_DWORD *)this, *(_DWORD *)this = 1, v2) )
    v1 = 0;
  return v1;
}

//----- (1002C66E) --------------------------------------------------------
BOOL __cdecl sub_1002C66E()
{
  LPVOID v0; // eax@1
  BOOL result; // eax@2

  v0 = sub_1002BA65();
  if ( v0 )
    result = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v0 + 32))(v0);
  else
    result = SwitchToThread();
  return result;
}

//----- (1002C684) --------------------------------------------------------
void __usercall sub_1002C684(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, int a7)
{
  int v7; // edx@6
  int v8; // ecx@6
  int v9; // eax@6
  int v10; // ecx@8
  int v11; // eax@9
  void *v12; // eax@25
  int v13; // esi@25
  int v14; // edx@26
  int v15; // [sp-4h] [bp-2Ch]@24
  int v16; // [sp-4h] [bp-2Ch]@26

  if ( a6 == 1 )
  {
    if ( sub_1003A093() )
    {
      if ( sub_10031D11(a3) )
      {
        sub_1003E4E1();
        dword_1006B434 = (int)GetCommandLineA();
        dword_10069454 = (LPVOID)sub_1003E456(a3);
        sub_1003DDAE(v7, v8, a3, a4);
        if ( v9 >= 0 )
        {
          if ( sub_1003E0AE(a3) >= 0 )
          {
            v11 = sub_1003E2DB(v10, a3);
            if ( v11 >= 0 )
            {
              if ( !sub_10032378(v11, a3, a4, 0) )
              {
                ++dword_10069450;
                return;
              }
            }
          }
          sub_1003E05C(a3);
        }
        sub_10031D87();
      }
      sub_1003A0A8();
    }
  }
  else
  {
    if ( a6 )
    {
      if ( a6 == 2 )
      {
        if ( !sub_10030FC9(dword_10067248) )
        {
          v12 = sub_1002EFE1(v15, a3, 1u, 0x3BCu);
          v13 = (int)v12;
          if ( v12 )
          {
            if ( sub_10030FE8(dword_10067248, v12) )
            {
              sub_10031C5E(v14, v16, a3, v13);
              *(_DWORD *)v13 = GetCurrentThreadId();
              *(_DWORD *)(v13 + 4) = -1;
            }
            else
            {
              sub_100282F6(a3, (LPVOID)v13);
            }
          }
        }
      }
      else
      {
        if ( a6 == 3 )
          sub_10031BA1(a3, a4, 0);
      }
    }
    else
    {
      if ( dword_10069450 > 0 )
      {
        --dword_10069450;
        if ( !dword_100695D0 )
          sub_10032369(a1, a2, a3, a4);
        sub_1003223D(a3);
        if ( !a7 )
        {
          sub_1003E05C(a3);
          sub_10031D87();
          sub_1003A0A8();
        }
        if ( !a7 )
        {
          if ( dword_10067248 != -1 )
            sub_10031D87();
        }
      }
    }
  }
}
// 10067248: using guessed type int dword_10067248;
// 10069450: using guessed type int dword_10069450;
// 100695D0: using guessed type int dword_100695D0;
// 1006B434: using guessed type int dword_1006B434;

//----- (1002C7F6) --------------------------------------------------------
BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
  int v4; // edx@3
  int v5; // ebx@3
  int v6; // edi@3

  if ( fdwReason == 1 )
    sub_1003E3BC();
  return sub_1002C819(v4, v5, v6, (int)hinstDLL, fdwReason, (int)lpReserved);
}

//----- (1002C819) --------------------------------------------------------
int __usercall sub_1002C819<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4, int a5, int a6)
{
  int v6; // eax@1
  int v7; // ecx@5
  int v8; // eax@8
  signed int v9; // eax@9
  int v10; // edx@9
  int v11; // ecx@9
  int v12; // edi@9
  int v13; // eax@15
  int result; // eax@18

  v6 = 1;
  if ( !a5 && !dword_10069450 )
    goto LABEL_22;
  if ( a5 != 1 && a5 != 2 )
    goto LABEL_23;
  v7 = (int)dword_10055F60;
  if ( dword_10055F60 )
    v6 = dword_10055F60(a4, a5, a6);
  if ( v6 && (sub_1002C684(a1, v7, a2, a3, a4, a5, a6), v8) )
  {
LABEL_23:
    v9 = sub_100019C0(a4, a5, a6);
    v12 = v9;
    if ( a5 == 1 )
    {
      if ( !v9 )
      {
        sub_100019C0(a4, 0, a6);
        sub_1002C684(v10, v11, a6, v12, a4, v12, a6);
        if ( dword_10055F60 )
          dword_10055F60(a4, v12, a6);
      }
    }
    if ( !a5 || a5 == 3 )
    {
      sub_1002C684(v10, v11, a6, v12, a4, a5, a6);
      v12 = v13 != 0 ? v12 : 0;
      if ( v12 )
      {
        if ( dword_10055F60 )
          v12 = dword_10055F60(a4, a5, a6);
      }
    }
    result = v12;
  }
  else
  {
LABEL_22:
    result = 0;
  }
  return result;
}
// 10055F60: using guessed type int (__stdcall *dword_10055F60)(_DWORD, _DWORD, _DWORD);
// 10069450: using guessed type int dword_10069450;

//----- (1002C927) --------------------------------------------------------
int __usercall sub_1002C927<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, int a7, int a8, int a9)
{
  if ( a6 == 1 )
    sub_1002C684(a1, a2, a3, a4, a5, 0, a7);
  return sub_1003DD90(a3, a8, a9);
}

//----- (1002C950) --------------------------------------------------------
void *__cdecl sub_1002C950(void *a1, const void *a2, unsigned int a3)
{
  int v38; // eax@29
  int v43; // edx@34
  unsigned int v44; // ecx@34
  void *result; // eax@48
  int v46; // edi@52
  int v47; // esi@52
  int v48; // edx@53
  unsigned int v49; // ecx@53
  int v50; // eax@64
  unsigned int k; // edx@65
  unsigned int v52; // edx@65
  int v53; // ecx@65
  unsigned int l; // edx@68
  int v55; // ecx@70
  char v56; // al@71
  unsigned int m; // ecx@71
  int n; // ecx@73
  unsigned int v59; // eax@76
  int i; // ecx@76
  unsigned int j; // eax@78
  int v62; // [sp-8h] [bp-10h]@76

  _ESI = (int)a2;
  _ECX = a3;
  _EDI = (int)a1;
  if ( a1 > a2 && a1 < (char *)a2 + a3 )
  {
    v47 = (int)(a2 + a3 - 4);
    v46 = (int)(a1 + a3 - 4);
    if ( v46 & 3 )
    {
      if ( a3 >= 4 )
        JUMPOUT(__CS__, *((_DWORD *)loc_1002CD24 + (v46 & 3) + 1));
      switch ( a3 )
      {
        case 0u:
LABEL_60:
          result = a1;
          break;
        case 1u:
LABEL_61:
          *(_BYTE *)(v46 + 3) = *(_BYTE *)(v47 + 3);
          result = a1;
          break;
        case 2u:
LABEL_62:
          *(_BYTE *)(v46 + 3) = *(_BYTE *)(v47 + 3);
          *(_BYTE *)(v46 + 2) = *(_BYTE *)(v47 + 2);
          result = a1;
          break;
        case 3u:
          goto LABEL_63;
      }
    }
    else
    {
      v49 = a3 >> 2;
      v48 = a3 & 3;
      if ( a3 >> 2 < 8 )
      {
        switch ( -v49 )
        {
          case 0:
            switch ( v48 )
            {
              case 0:
                goto LABEL_60;
              case 1:
                goto LABEL_61;
              case 2:
                goto LABEL_62;
              case 3:
                goto LABEL_63;
            }
        }
      }
      else
      {
        memcpy((void *)v46, (const void *)v47, 4 * v49);
        v47 += 4 * v49;
        v46 += 4 * v49;
        switch ( v48 )
        {
          case 0:
            goto LABEL_60;
          case 1:
            goto LABEL_61;
          case 2:
            goto LABEL_62;
          case 3:
            break;
        }
      }
LABEL_63:
      *(_BYTE *)(v46 + 3) = *(_BYTE *)(v47 + 3);
      *(_BYTE *)(v46 + 2) = *(_BYTE *)(v47 + 2);
      *(_BYTE *)(v46 + 1) = *(_BYTE *)(v47 + 1);
      result = a1;
    }
  }
  else
  {
    __asm { bt      dword_100695C4, 1 }
    if ( _CF )
    {
      memcpy(a1, a2, a3);
      return a1;
    }
    if ( a3 < 0x80 )
      goto LABEL_33;
    if ( ((unsigned int)a2 ^ (unsigned int)a1) & 0xF )
      goto LABEL_83;
    __asm { bt      dword_10067250, 1 }
    if ( !_CF )
    {
LABEL_83:
      __asm { bt      dword_100695C4, 0 }
      if ( _CF )
      {
        if ( !((_BYTE)a1 & 3) )
        {
          if ( !((_BYTE)a2 & 3) )
          {
            __asm { bt      edi, 2 }
            if ( _CF )
            {
              _ECX = a3 - 4;
              _ESI = (int)((char *)a2 + 4);
              *(_DWORD *)a1 = *(_DWORD *)a2;
              _EDI = (int)((char *)a1 + 4);
            }
            __asm { bt      edi, 3 }
            if ( _CF )
            {
              __asm { movq    xmm1, qword ptr [esi] }
              _ECX -= 8;
              _ESI += 8;
              __asm { movq    qword ptr [edi], xmm1 }
              _EDI += 8;
            }
            if ( _ESI & 7 )
            {
              __asm { bt      esi, 3 }
              if ( _CF )
              {
                __asm { movdqa  xmm1, xmmword ptr [esi-0Ch] }
                _ESI = _ESI - 12;
                do
                {
                  __asm { movdqa  xmm3, xmmword ptr [esi+10h] }
                  _ECX -= 48;
                  __asm
                  {
                    movdqa  xmm0, xmmword ptr [esi+20h]
                    movdqa  xmm5, xmmword ptr [esi+30h]
                  }
                  _ESI += 48;
                  __asm
                  {
                    movdqa  xmm2, xmm3
                    palignr xmm3, xmm1, 0Ch
                    movdqa  xmmword ptr [edi], xmm3
                    movdqa  xmm4, xmm0
                    palignr xmm0, xmm2, 0Ch
                    movdqa  xmmword ptr [edi+10h], xmm0
                    movdqa  xmm1, xmm5
                    palignr xmm5, xmm4, 0Ch
                    movdqa  xmmword ptr [edi+20h], xmm5
                  }
                  _EDI += 48;
                }
                while ( _ECX >= 48 );
                _ESI = _ESI + 12;
              }
              else
              {
                __asm { movdqa  xmm1, xmmword ptr [esi-4] }
                _ESI = _ESI - 4;
                do
                {
                  __asm { movdqa  xmm3, xmmword ptr [esi+10h] }
                  _ECX -= 48;
                  __asm
                  {
                    movdqa  xmm0, xmmword ptr [esi+20h]
                    movdqa  xmm5, xmmword ptr [esi+30h]
                  }
                  _ESI += 48;
                  __asm
                  {
                    movdqa  xmm2, xmm3
                    palignr xmm3, xmm1, 4
                    movdqa  xmmword ptr [edi], xmm3
                    movdqa  xmm4, xmm0
                    palignr xmm0, xmm2, 4
                    movdqa  xmmword ptr [edi+10h], xmm0
                    movdqa  xmm1, xmm5
                    palignr xmm5, xmm4, 4
                    movdqa  xmmword ptr [edi+20h], xmm5
                  }
                  _EDI += 48;
                }
                while ( _ECX >= 48 );
                _ESI = _ESI + 4;
              }
            }
            else
            {
              __asm { movdqa  xmm1, xmmword ptr [esi-8] }
              _ESI = _ESI - 8;
              do
              {
                __asm { movdqa  xmm3, xmmword ptr [esi+10h] }
                _ECX -= 48;
                __asm
                {
                  movdqa  xmm0, xmmword ptr [esi+20h]
                  movdqa  xmm5, xmmword ptr [esi+30h]
                }
                _ESI += 48;
                __asm
                {
                  movdqa  xmm2, xmm3
                  palignr xmm3, xmm1, 8
                  movdqa  xmmword ptr [edi], xmm3
                  movdqa  xmm4, xmm0
                  palignr xmm0, xmm2, 8
                  movdqa  xmmword ptr [edi+10h], xmm0
                  movdqa  xmm1, xmm5
                  palignr xmm5, xmm4, 8
                  movdqa  xmmword ptr [edi+20h], xmm5
                }
                _EDI += 48;
              }
              while ( _ECX >= 48 );
              _ESI = _ESI + 8;
            }
            while ( _ECX >= 16 )
            {
              __asm { movdqu  xmm1, xmmword ptr [esi] }
              _ECX -= 16;
              _ESI += 16;
              __asm { movdqa  xmmword ptr [edi], xmm1 }
              _EDI += 16;
            }
            __asm { bt      ecx, 2 }
            if ( _CF )
            {
              v38 = *(_DWORD *)_ESI;
              _ECX -= 4;
              _ESI += 4;
              *(_DWORD *)_EDI = v38;
              _EDI += 4;
            }
            __asm { bt      ecx, 3 }
            if ( _CF )
            {
              __asm { movq    xmm1, qword ptr [esi] }
              _ECX -= 8;
              __asm { movq    qword ptr [edi], xmm1 }
            }
            JUMPOUT(__CS__, *((_DWORD *)off_1002CC88 + _ECX));
          }
          goto LABEL_34;
        }
        goto LABEL_36;
      }
LABEL_33:
      if ( !((_BYTE)a1 & 3) )
      {
LABEL_34:
        v44 = a3 >> 2;
        v43 = a3 & 3;
        if ( a3 >> 2 < 8 )
        {
          switch ( v44 )
          {
            case 0u:
              goto LABEL_47;
            case 1u:
              goto LABEL_46;
            case 2u:
              goto LABEL_45;
            case 3u:
              goto LABEL_44;
            case 4u:
              goto LABEL_43;
            case 5u:
              goto LABEL_42;
            case 6u:
              break;
            case 7u:
              *((_DWORD *)a1 + v44 - 7) = *((_DWORD *)a2 + v44 - 7);
              break;
          }
          *((_DWORD *)a1 + v44 - 6) = *((_DWORD *)a2 + v44 - 6);
LABEL_42:
          *((_DWORD *)a1 + v44 - 5) = *((_DWORD *)a2 + v44 - 5);
LABEL_43:
          *((_DWORD *)a1 + v44 - 4) = *((_DWORD *)a2 + v44 - 4);
LABEL_44:
          *((_DWORD *)a1 + v44 - 3) = *((_DWORD *)a2 + v44 - 3);
LABEL_45:
          *((_DWORD *)a1 + v44 - 2) = *((_DWORD *)a2 + v44 - 2);
LABEL_46:
          *((_DWORD *)a1 + v44 - 1) = *((_DWORD *)a2 + v44 - 1);
          _ESI = (int)((char *)a2 + 4 * v44);
          _EDI = (int)((char *)a1 + 4 * v44);
LABEL_47:
          switch ( v43 )
          {
            case 0:
              return a1;
            case 1:
LABEL_49:
              *(_BYTE *)_EDI = *(_BYTE *)_ESI;
              return a1;
            case 2:
LABEL_50:
              *(_BYTE *)_EDI = *(_BYTE *)_ESI;
              *(_BYTE *)(_EDI + 1) = *(_BYTE *)(_ESI + 1);
              return a1;
            case 3:
              break;
          }
        }
        else
        {
          memcpy(a1, a2, 4 * v44);
          _ESI = (int)((char *)a2 + 4 * v44);
          _EDI = (int)((char *)a1 + 4 * v44);
          switch ( v43 )
          {
            case 0:
              return a1;
            case 1:
              goto LABEL_49;
            case 2:
              goto LABEL_50;
            case 3:
              break;
          }
        }
        *(_BYTE *)_EDI = *(_BYTE *)_ESI;
        *(_BYTE *)(_EDI + 1) = *(_BYTE *)(_ESI + 1);
        *(_BYTE *)(_EDI + 2) = *(_BYTE *)(_ESI + 2);
        return a1;
      }
LABEL_36:
      if ( a3 >= 4 )
        JUMPOUT(__CS__, *((_DWORD *)loc_1002CB98 + ((_BYTE)a1 & 3) + 1));
      JUMPOUT(__CS__, *((_DWORD *)loc_1002CC98 + a3 - 4));
    }
    v50 = (_BYTE)a2 & 0xF;
    if ( (_BYTE)a2 & 0xF )
    {
      v62 = a3 - (16 - v50);
      v59 = 16 - v50;
      for ( i = v59 & 3; i; --i )
        *(_BYTE *)_EDI++ = *(_BYTE *)_ESI++;
      for ( j = v59 >> 2; j; --j )
      {
        *(_DWORD *)_EDI = *(_DWORD *)_ESI;
        _ESI += 4;
        _EDI += 4;
      }
      _ECX = v62;
    }
    v52 = _ECX;
    v53 = _ECX & 0x7F;
    for ( k = v52 >> 7; k; --k )
    {
      __asm
      {
        movdqa  xmm0, xmmword ptr [esi]
        movdqa  xmm1, xmmword ptr [esi+10h]
        movdqa  xmm2, xmmword ptr [esi+20h]
        movdqa  xmm3, xmmword ptr [esi+30h]
        movdqa  xmmword ptr [edi], xmm0
        movdqa  xmmword ptr [edi+10h], xmm1
        movdqa  xmmword ptr [edi+20h], xmm2
        movdqa  xmmword ptr [edi+30h], xmm3
        movdqa  xmm4, xmmword ptr [esi+40h]
        movdqa  xmm5, xmmword ptr [esi+50h]
        movdqa  xmm6, xmmword ptr [esi+60h]
        movdqa  xmm7, xmmword ptr [esi+70h]
        movdqa  xmmword ptr [edi+40h], xmm4
        movdqa  xmmword ptr [edi+50h], xmm5
        movdqa  xmmword ptr [edi+60h], xmm6
        movdqa  xmmword ptr [edi+70h], xmm7
      }
      _ESI += 128;
      _EDI += 128;
    }
    if ( v53 )
    {
      for ( l = (unsigned int)v53 >> 4; l; --l )
      {
        __asm
        {
          movdqa  xmm0, xmmword ptr [esi]
          movdqa  xmmword ptr [edi], xmm0
        }
        _ESI += 16;
        _EDI += 16;
      }
      v55 = v53 & 0xF;
      if ( v55 )
      {
        v56 = v55;
        for ( m = (unsigned int)v55 >> 2; m; --m )
        {
          *(_DWORD *)_EDI = *(_DWORD *)_ESI;
          _ESI += 4;
          _EDI += 4;
        }
        for ( n = v56 & 3; n; --n )
          *(_BYTE *)_EDI++ = *(_BYTE *)_ESI++;
      }
    }
    result = a1;
  }
  return result;
}
// 1002CB98: using guessed type int __cdecl loc_1002CB98(int, int, int);
// 1002CC88: using guessed type int __cdecl off_1002CC88(int, int, int);
// 1002CC98: using guessed type int __cdecl loc_1002CC98(int, int, int);
// 1002CD24: using guessed type int __cdecl loc_1002CD24(int, int, int);

//----- (1002CFA0) --------------------------------------------------------
int __cdecl sub_1002CFA0(int a1)
{
  int v1; // ecx@1
  char v2; // al@2
  int v3; // eax@4
  int v4; // eax@5
  int result; // eax@10

  v1 = a1;
  if ( a1 & 3 )
  {
    while ( 1 )
    {
      v2 = *(_BYTE *)v1++;
      if ( !v2 )
        break;
      if ( !(v1 & 3) )
        goto LABEL_4;
    }
LABEL_10:
    result = v1 - 1 - a1;
  }
  else
  {
    while ( 1 )
    {
      do
      {
LABEL_4:
        v3 = (*(_DWORD *)v1 + 2130640639) ^ ~*(_DWORD *)v1;
        v1 += 4;
      }
      while ( !(v3 & 0x81010100) );
      v4 = *(_DWORD *)(v1 - 4);
      if ( !(_BYTE)v4 )
        break;
      if ( !BYTE1(v4) )
        return v1 - 3 - a1;
      if ( !(v4 & 0xFF0000) )
        return v1 - 2 - a1;
      if ( !(v4 & 0xFF000000) )
        goto LABEL_10;
    }
    result = v1 - 4 - a1;
  }
  return result;
}

//----- (1002D02B) --------------------------------------------------------
void __stdcall sub_1002D02B(int a1, int a2)
{
  int v2; // eax@1
  DWORD dwExceptionCode; // [sp+8h] [bp-20h]@1
  DWORD dwExceptionFlags; // [sp+Ch] [bp-1Ch]@7
  DWORD nNumberOfArguments; // [sp+18h] [bp-10h]@7
  ULONG_PTR Arguments; // [sp+1Ch] [bp-Ch]@6
  int v7; // [sp+20h] [bp-8h]@4
  int v8; // [sp+24h] [bp-4h]@4

  v2 = a2;
  memcpy(&dwExceptionCode, &unk_10055F64, 0x20u);
  if ( a2 )
  {
    if ( *(_BYTE *)a2 & 0x10 )
      v2 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 - 4) + 24);
  }
  v7 = a1;
  v8 = v2;
  if ( v2 )
  {
    if ( *(_BYTE *)v2 & 8 )
      Arguments = 26820608;
  }
  RaiseException(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, &Arguments);
}

//----- (1002D086) --------------------------------------------------------
#error "1002D091: positive sp value has been found (funcsize=3)"

//----- (1002D09A) --------------------------------------------------------
#error "1002D09F: call analysis failed (funcsize=4)"

//----- (1002D0A9) --------------------------------------------------------
#error "1002D0AE: call analysis failed (funcsize=4)"

//----- (1002D0B8) --------------------------------------------------------
char *__cdecl sub_1002D0B8()
{
  char v1; // [sp-8h] [bp-8h]@1

  return &v1;
}

//----- (1002D0EB) --------------------------------------------------------
char *__cdecl sub_1002D0EB()
{
  char v1; // [sp-8h] [bp-8h]@1

  return &v1;
}

//----- (1002D121) --------------------------------------------------------
char *__cdecl sub_1002D121()
{
  char v1; // [sp-8h] [bp-8h]@1

  return &v1;
}

//----- (1002D157) --------------------------------------------------------
char *__cdecl sub_1002D157()
{
  char v1; // [sp-8h] [bp-8h]@1

  return &v1;
}

//----- (1002D190) --------------------------------------------------------
int __usercall sub_1002D190<eax>(int a1<ebx>, int a2<edi>, PEXCEPTION_RECORD ExceptionRecord, int TargetFrame, int a5)
{
  char v6; // ST20_1@1

  sub_10022B30(a1, a2, TargetFrame, TargetFrame ^ *(_DWORD *)(TargetFrame + 8), v6);
  return sub_1002E17F(
           a1,
           a2,
           (int)ExceptionRecord,
           *(_DWORD *)(TargetFrame + 16),
           a5,
           0,
           *(_DWORD *)(TargetFrame + 12),
           *(_DWORD *)(TargetFrame + 20),
           (PVOID)TargetFrame,
           0);
}

//----- (1002D1C1) --------------------------------------------------------
int __usercall sub_1002D1C1<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4<esi>)
{
  char v4; // ST20_1@1
  int result; // eax@2

  sub_10022B30(a1, a3, a4, *(_DWORD *)(a2 + 12) ^ *(_DWORD *)(*(_DWORD *)(a2 + 12) + 8), v4);
  if ( *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4) & 0x66 )
  {
    *(_DWORD *)(*(_DWORD *)(a2 + 12) + 36) = 1;
    result = 1;
  }
  else
  {
    sub_1002E17F(
      a1,
      a3,
      *(_DWORD *)(a2 + 8),
      *(_DWORD *)(*(_DWORD *)(a2 + 12) + 16),
      *(_DWORD *)(a2 + 16),
      0,
      *(_DWORD *)(*(_DWORD *)(a2 + 12) + 12),
      *(_DWORD *)(*(_DWORD *)(a2 + 12) + 20),
      *(PVOID *)(*(_DWORD *)(a2 + 12) + 24),
      1);
    if ( !*(_DWORD *)(*(_DWORD *)(a2 + 12) + 36) )
      sub_1002D447(a3, a4, *(PVOID *)(a2 + 12), *(PEXCEPTION_RECORD *)(a2 + 8));
    sub_1002D2C3(a1, a3, 291, a2 - 4, 0, 0, 0, 0, 0);
    result = (*(int (**)(void))(a2 - 4))();
  }
  return result;
}

//----- (1002D25E) --------------------------------------------------------
void __usercall sub_1002D25E(int a1<edi>, int a2<esi>, int a3, int a4, int a5, int a6, int a7)
{
  int ebp0; // ebp@0
  int v8; // [sp+0h] [bp-18h]@1
  int (__usercall *v9)<eax>(int<ebx>, int<edi>, PEXCEPTION_RECORD, int, int); // [sp+4h] [bp-14h]@1
  unsigned int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v10 = (unsigned int)&v8 ^ __security_cookie;
  v11 = a4;
  v9 = sub_1002D190;
  v12 = a3;
  v13 = a6 + 1;
  v8 = a6 + 1;
  sub_1003E530(ebp0, a1, a2, a5, a3, a7);
}
// 10067210: using guessed type int __security_cookie;

//----- (1002D2BC) --------------------------------------------------------
#error "FFFFFFFF: positive sp value has been found (funcsize=0)"

//----- (1002D2C3) --------------------------------------------------------
signed int __usercall sub_1002D2C3<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  signed int result; // eax@2
  char v10; // [sp+0h] [bp-3Ch]@3
  int v11; // [sp+4h] [bp-38h]@3
  int (__usercall *v12)<eax>(int<ebx>, int<ebp>, int<edi>, int<esi>); // [sp+8h] [bp-34h]@3
  unsigned int v13; // [sp+Ch] [bp-30h]@3
  int v14; // [sp+10h] [bp-2Ch]@3
  int v15; // [sp+14h] [bp-28h]@3
  int v16; // [sp+18h] [bp-24h]@3
  int v17; // [sp+1Ch] [bp-20h]@3
  char *v18; // [sp+20h] [bp-1Ch]@3
  int *v19; // [sp+24h] [bp-18h]@3
  int v20; // [sp+28h] [bp-14h]@3
  int v21; // [sp+2Ch] [bp-10h]@3
  int v22; // [sp+30h] [bp-Ch]@3
  int v23; // [sp+34h] [bp-8h]@3
  int v24; // [sp+38h] [bp-4h]@3
  int v25; // [sp+3Ch] [bp+0h]@3

  if ( a3 == 291 )
  {
    *(_DWORD *)a4 = loc_1002D36C;
    result = 1;
  }
  else
  {
    v12 = sub_1002D1C1;
    v13 = (unsigned int)&v11 ^ __security_cookie;
    v14 = a7;
    v15 = a4;
    v16 = a8;
    v17 = a9;
    v20 = 0;
    v18 = &v10;
    v19 = &v25;
    v11 = a9;
    v24 = 1;
    v21 = a3;
    v22 = a5;
    v23 = *(_DWORD *)(sub_10031BD7(a1, a2) + 128);
    ((void (__cdecl *)(_DWORD, int *))v23)(*(_DWORD *)a3, &v21);
    v24 = 0;
    if ( v20 )
      *(_DWORD *)v11 = *(_DWORD *)a1;
    result = v24;
  }
  return result;
}
// 1002D36C: using guessed type int __cdecl loc_1002D36C(int, int, int, int, int, int, int);
// 10067210: using guessed type int __security_cookie;

//----- (1002D398) --------------------------------------------------------
int __cdecl sub_1002D398(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // edx@2
  int v10; // esi@10
  int v12; // [sp+Ch] [bp-8h]@1
  int v13; // [sp+10h] [bp-4h]@1

  v6 = a2;
  v5 = *(_DWORD *)(a1 + 16);
  v8 = *(_DWORD *)(a1 + 12);
  v12 = *(_DWORD *)(a1 + 16);
  v7 = *(_DWORD *)(a1 + 12);
  v13 = *(_DWORD *)(a1 + 12);
  if ( a2 >= 0 )
  {
    v9 = a3;
    do
    {
      if ( v8 == -1 )
      {
        sub_10031DA4(v6, v7);
        v5 = v12;
        v9 = a3;
      }
      --v8;
      if ( *(_DWORD *)(20 * v8 + v5 + 4) < v9 && v9 <= *(_DWORD *)(20 * v8 + v5 + 8) || v8 == -1 )
      {
        v7 = v13;
        --v6;
        v13 = v8;
      }
    }
    while ( v6 >= 0 );
  }
  v10 = v8 + 1;
  *(_DWORD *)a4 = v10;
  *(_DWORD *)a5 = v7;
  if ( (unsigned int)v7 > *(_DWORD *)(a1 + 12) || v10 > (unsigned int)v7 )
  {
    sub_10031DA4(v6, v7);
    v5 = v12;
  }
  return v5 + 20 * v10;
}

//----- (1002D417) --------------------------------------------------------
int __usercall sub_1002D417<eax>(int a1<ebp>, int a2, int a3)
{
  *(_DWORD *)(a1 - 4) = *(_DWORD *)(a1 + 12) + 12;
  return (*(int (**)(void))(a1 + 8))();
}

//----- (1002D447) --------------------------------------------------------
DWORD __userpurge sub_1002D447<eax>(int a1<edi>, int a2<esi>, PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord)
{
  DWORD result; // eax@1

  RtlUnwind(TargetFrame, loc_1002D471, ExceptionRecord, 0);
  result = ExceptionRecord->ExceptionFlags & 0xFFFFFFFD;
  ExceptionRecord->ExceptionFlags = result;
  *(_DWORD *)a2 = a1;
  return result;
}
// 1002D471: using guessed type int __stdcall loc_1002D471(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord);

//----- (1002D49A) --------------------------------------------------------
int __usercall sub_1002D49A<eax>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  *(_DWORD *)a3 = a4;
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(sub_10031BD7(a1, a2) + 152);
  *(_DWORD *)(sub_10031BD7(a1, a2) + 152) = a3;
  return a3;
}

//----- (1002D4C4) --------------------------------------------------------
void __usercall sub_1002D4C4(int a1<ebx>, int a2<edi>, int a3)
{
  int i; // ecx@4

  if ( a3 == *(_DWORD *)(sub_10031BD7(a1, a2) + 152) )
  {
    *(_DWORD *)(sub_10031BD7(a1, a2) + 152) = *(_DWORD *)(a3 + 4);
  }
  else
  {
    for ( i = *(_DWORD *)(sub_10031BD7(a1, a2) + 152); ; i = *(_DWORD *)(i + 4) )
    {
      if ( !*(_DWORD *)(i + 4) )
      {
        sub_10031DA4(a1, a2);
        return;
      }
      if ( a3 == *(_DWORD *)(i + 4) )
        break;
    }
    *(_DWORD *)(i + 4) = *(_DWORD *)(a3 + 4);
  }
}

//----- (1002D514) --------------------------------------------------------
signed int __usercall sub_1002D514<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // eax@1
  signed int result; // eax@4

  v3 = *(_DWORD *)(sub_10031BD7(a1, a2) + 152);
  if ( v3 )
  {
    while ( *(_DWORD *)v3 != a3 )
    {
      v3 = *(_DWORD *)(v3 + 4);
      if ( !v3 )
        goto LABEL_4;
    }
    result = 0;
  }
  else
  {
LABEL_4:
    result = 1;
  }
  return result;
}

//----- (1002D53D) --------------------------------------------------------
int __usercall sub_1002D53D<eax>(int a1<eax>, int a2<ebx>, int a3<edi>, int ExceptionRecord, int a5, int a6, int a7)
{
  return sub_1002E17F(a2, a3, ExceptionRecord, a5, a6, a7, a1, 0, 0, 0);
}

//----- (1002D573) --------------------------------------------------------
int __cdecl sub_1002D573(int a1)
{
  int result; // eax@1
  int v2; // ecx@7
  int v3; // edx@8

  result = a1;
  if ( a1 )
  {
    if ( *(_DWORD *)a1 == -529697949 )
    {
      if ( *(_DWORD *)(a1 + 16) == 3 )
      {
        if ( *(_DWORD *)(a1 + 20) == 429065504 || *(_DWORD *)(a1 + 20) == 429065505 || *(_DWORD *)(a1 + 20) == 429065506 )
        {
          v2 = *(_DWORD *)(a1 + 28);
          if ( v2 )
          {
            v3 = *(_DWORD *)(v2 + 4);
            if ( v3 )
            {
              result = sub_1002D2BC(*(_DWORD *)(a1 + 24), v3);
            }
            else
            {
              if ( *(_BYTE *)v2 & 0x10 )
              {
                result = *(_DWORD *)(a1 + 24);
                if ( *(_DWORD *)result )
                  result = (*(int (__stdcall **)(_DWORD))(**(_DWORD **)result + 8))(*(_DWORD *)result);
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 1002D2BC: using guessed type _DWORD __cdecl sub_1002D2BC(_DWORD, _DWORD);

//----- (1002D5FE) --------------------------------------------------------
int __cdecl sub_1002D5FE(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int result; // eax@1
  int v8; // eax@1
  int v9; // eax@1
  char v10; // [sp+10h] [bp-40h]@1
  int v11; // [sp+18h] [bp-38h]@1
  int v12; // [sp+1Ch] [bp-34h]@1
  int v13; // [sp+20h] [bp-30h]@1
  int v14; // [sp+24h] [bp-2Ch]@1
  int v15; // [sp+28h] [bp-28h]@1
  int v16; // [sp+34h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+38h] [bp-18h]@1

  v16 = a5;
  v11 = 0;
  v15 = *(_DWORD *)(a2 - 4);
  v14 = sub_1002D49A(0, a2, (int)&v10, *(_DWORD *)(a1 + 24));
  v13 = *(_DWORD *)(sub_10031BD7(0, a2) + 136);
  v12 = *(_DWORD *)(sub_10031BD7(0, a2) + 140);
  *(_DWORD *)(sub_10031BD7(0, a2) + 136) = a1;
  *(_DWORD *)(sub_10031BD7(0, a2) + 140) = a3;
  ms_exc.disabled = 1;
  sub_1002D25E(a2, a1, a2, a4, a5, a6, a7);
  v16 = v8;
  ms_exc.disabled = -2;
  *(_DWORD *)(a2 - 4) = v15;
  sub_1002D4C4(0, a2, v14);
  v9 = sub_10031BD7(0, a2);
  *(_DWORD *)(v9 + 136) = v13;
  result = sub_10031BD7(0, a2);
  *(_DWORD *)(result + 140) = v12;
  if ( *(_DWORD *)a1 == -529697949 )
  {
    if ( *(_DWORD *)(a1 + 16) == 3 )
    {
      if ( *(_DWORD *)(a1 + 20) == 429065504 || *(_DWORD *)(a1 + 20) == 429065505 || *(_DWORD *)(a1 + 20) == 429065506 )
      {
        if ( !v11 )
        {
          if ( v16 )
          {
            result = sub_1002D514(0, v16, *(_DWORD *)(a1 + 24));
            if ( result )
              result = sub_1002D573(a1);
          }
        }
      }
    }
  }
  return result;
}

//----- (1002D7CC) --------------------------------------------------------
void __usercall sub_1002D7CC(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  sub_1002D121();
  if ( *(_DWORD *)(sub_10031BD7(a1, a3) + 148) )
    sub_10031DA4(a1, a3);
  *(_DWORD *)(a2 - 4) = 0;
  sub_10031E10(a1, a3);
  *(_DWORD *)(sub_10031BD7(a1, a3) + 148) = *(_DWORD *)(a2 + 8);
  sub_1002D02B(0, 0);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_1002D80C);
}

//----- (1002D80C) --------------------------------------------------------
int __usercall sub_1002D80C<eax>(int a1<ebx>, int a2<esi>, PEXCEPTION_RECORD ExceptionRecord, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, PVOID TargetFrame)
{
  int ebp0; // ebp@0
  int result; // eax@6
  PVOID v14; // [sp-8h] [bp-Ch]@4

  if ( a9 )
    sub_1002DE45((int)ExceptionRecord, a4, a8, a9);
  if ( TargetFrame )
    v14 = TargetFrame;
  else
    v14 = (PVOID)a4;
  sub_1002D447(a4, a2, v14, ExceptionRecord);
  sub_1002E0A6(a1, a4, a4, a6, a7, *(_DWORD *)a10);
  *(_DWORD *)(a4 + 8) = *(_DWORD *)(a10 + 4) + 1;
  result = sub_1002D5FE((int)ExceptionRecord, a4, a5, a7, *(_DWORD *)(a8 + 12), a11, 256);
  if ( result )
    result = sub_1002D417(ebp0, result, a4);
  return result;
}

//----- (1002D887) --------------------------------------------------------
signed int __usercall sub_1002D887<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  _DWORD *v3; // eax@1
  signed int result; // eax@7

  v3 = *(_DWORD **)a3;
  if ( **(_DWORD **)a3 != -529697949
    || v3[4] != 3
    || v3[5] != 429065504 && v3[5] != 429065505 && v3[5] != 429065506
    || v3[7] )
  {
    result = 0;
  }
  else
  {
    *(_DWORD *)(sub_10031BD7(a1, a2) + 940) = 1;
    result = 1;
  }
  return result;
}

//----- (1002D8D4) --------------------------------------------------------
void __cdecl sub_1002D8D4(int ExceptionRecord, int a2, int a3, int a4, int a5, char a6, int a7, PVOID TargetFrame)
{
  int v8; // ebx@1
  int ebp0; // ebp@0
  int v10; // edi@1
  unsigned __int8 v11; // zf@1
  char v12; // sf@1
  unsigned __int8 v13; // of@1
  int v14; // eax@2
  int v15; // esi@7
  int v16; // ST28_4@24
  int v17; // eax@26
  int v18; // eax@30
  int v19; // eax@38
  unsigned int v20; // ecx@38
  int v21; // eax@39
  int v22; // edx@39
  int v23; // edi@42
  unsigned __int8 v24; // zf@42
  unsigned __int8 v25; // sf@42
  int v26; // ecx@43
  int v27; // eax@44
  int v28; // edx@44
  int *v29; // eax@44
  int v30; // ST28_4@45
  int v31; // eax@60
  char v32; // zf@60
  PEXCEPTION_RECORD v33; // ST2C_4@72
  PVOID v34; // [sp-4h] [bp-4Ch]@60
  int (__stdcall **v35)(char); // [sp+Ch] [bp-3Ch]@70
  int v36; // [sp+18h] [bp-30h]@45
  int v37; // [sp+1Ch] [bp-2Ch]@40
  unsigned int v38; // [sp+20h] [bp-28h]@38
  int v39; // [sp+24h] [bp-24h]@1
  int v40; // [sp+28h] [bp-20h]@42
  int v41; // [sp+2Ch] [bp-1Ch]@46
  int v42; // [sp+30h] [bp-18h]@46
  int v43; // [sp+34h] [bp-14h]@24
  unsigned int v44; // [sp+38h] [bp-10h]@38
  int v45; // [sp+3Ch] [bp-Ch]@42
  int v46; // [sp+40h] [bp-8h]@4
  char v47; // [sp+47h] [bp-1h]@1
  int v48; // [sp+50h] [bp+8h]@14

  v10 = a5;
  v8 = 0;
  v13 = __SETO__(*(_DWORD *)(a5 + 4), 128);
  v11 = *(_DWORD *)(a5 + 4) == 128;
  v12 = *(_DWORD *)(a5 + 4) - 128 < 0;
  LOBYTE(v39) = 0;
  v47 = 0;
  if ( (unsigned __int8)(v12 ^ v13) | v11 )
    v14 = *(_BYTE *)(a2 + 8);
  else
    v14 = *(_DWORD *)(a2 + 8);
  v46 = v14;
  if ( v14 < -1 || v14 >= *(_DWORD *)(a5 + 4) )
    sub_10031DA4(0, a5);
  v15 = ExceptionRecord;
  if ( *(_DWORD *)ExceptionRecord != -529697949 )
  {
    v18 = a3;
LABEL_63:
    if ( *(_DWORD *)(v10 + 12) > 0u )
    {
      if ( a6 )
        goto LABEL_69;
      sub_1002DC6F(0, (PEXCEPTION_RECORD)v15, a2, v18, a4, v10, v46, a7, TargetFrame);
    }
    goto LABEL_66;
  }
  if ( *(_DWORD *)(ExceptionRecord + 16) != 3
    || *(_DWORD *)(ExceptionRecord + 20) != 429065504
    && *(_DWORD *)(ExceptionRecord + 20) != 429065505
    && *(_DWORD *)(ExceptionRecord + 20) != 429065506
    || *(_DWORD *)(ExceptionRecord + 28) )
  {
    v18 = a3;
    v48 = a3;
  }
  else
  {
    if ( !*(_DWORD *)(sub_10031BD7(0, v10) + 136) )
      return;
    v15 = *(_DWORD *)(sub_10031BD7(0, v10) + 136);
    v48 = *(_DWORD *)(sub_10031BD7(0, v10) + 140);
    LOBYTE(v39) = 1;
    if ( !sub_1003E57C(v15) )
      sub_10031DA4(0, v10);
    if ( *(_DWORD *)v15 == -529697949 )
    {
      if ( *(_DWORD *)(v15 + 16) == 3 )
      {
        if ( *(_DWORD *)(v15 + 20) == 429065504
          || *(_DWORD *)(v15 + 20) == 429065505
          || *(_DWORD *)(v15 + 20) == 429065506 )
        {
          if ( !*(_DWORD *)(v15 + 28) )
            sub_10031DA4(0, v10);
        }
      }
    }
    if ( *(_DWORD *)(sub_10031BD7(0, v10) + 148) )
    {
      v43 = *(_DWORD *)(sub_10031BD7(0, v10) + 148);
      v16 = v43;
      *(_DWORD *)(sub_10031BD7(0, v10) + 148) = 0;
      if ( !sub_1002DD89(0, v10, v15, v16) )
      {
        v10 = v43;
        if ( *(_DWORD *)v43 > 0 )
        {
          v17 = 0;
          a5 = 0;
          while ( !sub_1002405D(*(void **)(v17 + *(_DWORD *)(v43 + 4) + 4), (int)&off_100664D8) )
          {
            ++v8;
            v17 = a5 + 16;
            a5 += 16;
            if ( v8 >= *(_DWORD *)v43 )
              goto LABEL_69;
          }
          goto LABEL_70;
        }
LABEL_69:
        sub_10031DDC(v8, v10);
LABEL_70:
        sub_1002D573(v15);
        a5 = (int)"bad exception";
        sub_10023687((int)&v35, &a5);
        v35 = &off_100558C4;
        sub_1002D02B((int)&v35, (int)&unk_1005FC7C);
LABEL_71:
        v34 = TargetFrame;
LABEL_72:
        sub_1002D447(v10, v15, v34, v33);
        sub_1002E0A6(v8, v10, a2, a4, v10, -1);
        sub_1002D7CC(v8, ebp0, v10);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_1002DC6F);
      }
    }
    v18 = v48;
  }
  if ( *(_DWORD *)v15 != -529697949
    || *(_DWORD *)(v15 + 16) != 3
    || *(_DWORD *)(v15 + 20) != 429065504 && *(_DWORD *)(v15 + 20) != 429065505 && *(_DWORD *)(v15 + 20) != 429065506 )
    goto LABEL_63;
  if ( *(_DWORD *)(v10 + 12) > 0u )
  {
    v19 = sub_1002D398(v10, a7, v46, (int)&v44, (int)&v38);
    v20 = v44;
    if ( v44 < v38 )
    {
      v22 = v19 + 16;
      v21 = v46;
      v43 = v22;
      do
      {
        v37 = v22 - 16;
        if ( *(_DWORD *)(v22 - 16) <= v21 )
        {
          if ( v21 <= *(_DWORD *)(v22 - 12) )
          {
            v45 = *(_DWORD *)v22;
            v23 = *(_DWORD *)(v22 - 4);
            v40 = v23;
            v24 = v23 == 0;
            v25 = v23 < 0;
            v10 = a5;
            if ( !(v25 | v24) )
            {
              v26 = v45;
              while ( 2 )
              {
                v29 = *(int **)(*(_DWORD *)(v15 + 28) + 12);
                v28 = (int)(v29 + 1);
                v27 = *v29;
                while ( 1 )
                {
                  v42 = v27;
                  v41 = v28;
                  if ( v27 <= 0 )
                    break;
                  v30 = *(_DWORD *)(v15 + 28);
                  v36 = *(_DWORD *)v28;
                  if ( sub_1002E25E(v26, v36, v30) )
                  {
                    v47 = 1;
                    sub_1002D80C(a2, v15, (PEXCEPTION_RECORD)v15, a2, v48, a4, v10, v45, v36, v37, a7, TargetFrame);
                    goto LABEL_51;
                  }
                  v26 = v45;
                  v27 = v42 - 1;
                  v28 = v41 + 4;
                }
                v26 += 16;
                --v40;
                v45 = v26;
                if ( v40 > 0 )
                  continue;
                break;
              }
LABEL_51:
              v22 = v43;
              v21 = v46;
              v20 = v44;
            }
          }
        }
        ++v20;
        v22 += 20;
        v44 = v20;
        v43 = v22;
      }
      while ( v20 < v38 );
      v8 = 0;
    }
  }
  if ( a6 )
    sub_1002D573(v15);
  if ( !v47
    && (*(_DWORD *)v10 & 0x1FFFFFFFu) >= 0x19930521
    && *(_DWORD *)(v10 + 28)
    && !sub_1002DD89(v8, v10, v15, *(_DWORD *)(v10 + 28)) )
  {
    sub_10031BD7(v8, v10);
    sub_10031BD7(v8, v10);
    *(_DWORD *)(sub_10031BD7(v8, v10) + 136) = v15;
    v31 = sub_10031BD7(v8, v10);
    v32 = TargetFrame == 0;
    *(_DWORD *)(v31 + 140) = v48;
    v34 = (PVOID)v15;
    if ( v32 )
      goto LABEL_72;
    goto LABEL_71;
  }
LABEL_66:
  if ( *(_DWORD *)(sub_10031BD7(v8, v10) + 148) != v8 )
    sub_10031DA4(v8, v10);
}
// 100558C4: using guessed type int (__stdcall *off_100558C4)(char);
// 100664D8: using guessed type int (__stdcall **off_100664D8)(char);

//----- (1002DC6F) --------------------------------------------------------
void __usercall sub_1002DC6F(int a1<ebx>, PEXCEPTION_RECORD ExceptionRecord, int a3, int a4, int a5, int a6, int a7, int a8, PVOID TargetFrame)
{
  int v9; // ebx@2
  int v10; // eax@2
  PVOID v11; // esi@3
  int v12; // eax@9
  int v13; // edx@9
  int v14; // ecx@9
  int v15; // eax@10
  int v16; // esi@10
  int v17; // eax@13
  int v18; // eax@15
  unsigned int v19; // [sp+4h] [bp-8h]@9
  unsigned int v20; // [sp+8h] [bp-4h]@9

  if ( ExceptionRecord->ExceptionCode != -2147483645 )
  {
    v10 = sub_10031BD7(a1, (int)ExceptionRecord);
    v9 = a6;
    if ( !*(_DWORD *)(v10 + 128)
      || (v11 = EncodePointer(0), *(PVOID *)(sub_10031BD7(a6, (int)ExceptionRecord) + 128) == v11)
      || ExceptionRecord->ExceptionCode == -532459699
      || ExceptionRecord->ExceptionCode == -532462766
      || !sub_1002D2C3(a6, (int)ExceptionRecord, (int)ExceptionRecord, a3, a4, a5, a6, a8, (int)TargetFrame) )
    {
      if ( !*(_DWORD *)(a6 + 12) )
        sub_10031DA4(a6, (int)ExceptionRecord);
      v12 = sub_1002D398(a6, a8, a7, (int)&v19, (int)&v20);
      v14 = v19;
      v13 = v20;
      if ( v19 < v20 )
      {
        v16 = v12 + 12;
        v15 = a7;
        do
        {
          if ( v15 >= *(_DWORD *)(v16 - 12) )
          {
            if ( v15 <= *(_DWORD *)(v16 - 8) )
            {
              v17 = 16 * *(_DWORD *)v16;
              if ( !*(_DWORD *)(*(_DWORD *)(v16 + 4) + v17 - 12)
                || (v13 = v20, v9 = a6, !*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v16 + 4) + v17 - 12) + 8)) )
              {
                v18 = *(_DWORD *)(v16 + 4) - 16 + v17;
                if ( !(*(_BYTE *)v18 & 0x40) )
                {
                  sub_1002D80C(v9, v16, ExceptionRecord, a3, a4, a5, v9, v18, 0, v16 - 12, a8, TargetFrame);
                  v13 = v20;
                  v14 = v19;
                }
              }
              v15 = a7;
            }
          }
          ++v14;
          v16 += 20;
          v19 = v14;
        }
        while ( v14 < (unsigned int)v13 );
      }
    }
  }
}

//----- (1002DD89) --------------------------------------------------------
char __usercall sub_1002DD89<al>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  int v4; // esi@1
  char v5; // bl@2
  int v6; // edi@2
  int v7; // ecx@3
  int v8; // edx@4
  int v9; // eax@4
  bool v10; // eax@5
  int v12; // [sp+Ch] [bp-8h]@4
  int v13; // [sp+10h] [bp-4h]@4
  int v14; // [sp+20h] [bp+Ch]@3

  v4 = a4;
  if ( !a4 )
  {
    sub_10031DA4(a1, a2);
    sub_10031DDC(a1, a2);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1002DE0F);
  }
  v5 = 0;
  v6 = 0;
  if ( *(_DWORD *)a4 > 0 )
  {
    v7 = 0;
    v14 = 0;
    do
    {
      v9 = *(_DWORD *)(*(_DWORD *)(a3 + 28) + 12);
      v8 = v9 + 4;
      v12 = v9 + 4;
      v13 = *(_DWORD *)v9;
      if ( *(_DWORD *)v9 > 0 )
      {
        while ( 1 )
        {
          v10 = sub_1002E25E(v7 + *(_DWORD *)(v4 + 4), *(_DWORD *)v8, *(_DWORD *)(a3 + 28));
          v7 = v14;
          if ( v10 )
            break;
          v8 = v12 + 4;
          --v13;
          v12 += 4;
          if ( v13 <= 0 )
            goto LABEL_9;
        }
        v5 = 1;
      }
LABEL_9:
      ++v6;
      v7 += 16;
      v14 = v7;
    }
    while ( v6 < *(_DWORD *)v4 );
  }
  return v5;
}

//----- (1002DE0F) --------------------------------------------------------
char __usercall sub_1002DE0F<al>(int a1<ebx>, int a2<edi>)
{
  return *(_DWORD *)(sub_10031BD7(a1, a2) + 144) != 0;
}

//----- (1002DE20) --------------------------------------------------------
int __cdecl sub_1002DE20(int a1, int a2)
{
  int result; // eax@1
  int v3; // esi@1

  v3 = *(_DWORD *)(a2 + 4);
  result = a1 + *(_DWORD *)a2;
  if ( v3 >= 0 )
    result += v3 + *(_DWORD *)(*(_DWORD *)(v3 + a1) + *(_DWORD *)(a2 + 8));
  return result;
}

//----- (1002DE45) --------------------------------------------------------
int __cdecl sub_1002DE45(int a1, int a2, int a3, int a4)
{
  int v4; // edi@2
  int v5; // eax@4
  int result; // eax@5

  _SEH_prolog4(stru_100605D0, 8);
  if ( *(_DWORD *)a3 & 0x80000000 )
    v4 = a2;
  else
    v4 = *(_DWORD *)(a3 + 8) + a2 + 12;
  v5 = sub_1002DED3(a1, a2, a3, a4) - 1;
  if ( v5 )
  {
    result = v5 - 1;
    if ( !result )
    {
      sub_1002DE20(*(_DWORD *)(a1 + 24), a4 + 8);
      result = sub_1002D2BC(v4, *(_DWORD *)(a4 + 24));
    }
  }
  else
  {
    sub_1002DE20(*(_DWORD *)(a1 + 24), a4 + 8);
    result = sub_1002D2BC(v4, *(_DWORD *)(a4 + 24));
  }
  return result;
}
// 1002D2BC: using guessed type _DWORD __cdecl sub_1002D2BC(_DWORD, _DWORD);
// 10032000: using guessed type _DWORD __cdecl _SEH_prolog4(_DWORD, _DWORD);
// 100605D0: using guessed type _EH4_SCOPETABLE stru_100605D0[1];

//----- (1002DED3) --------------------------------------------------------
int __cdecl sub_1002DED3(int a1, int a2, int a3, int a4)
{
  int v4; // ecx@1
  int v5; // ebx@1
  int v6; // ecx@3
  int v7; // edx@5
  int v8; // edi@5
  int v9; // ecx@10
  unsigned int v10; // ST08_4@21
  int v11; // eax@21
  int v13; // [sp-8h] [bp-34h]@10
  int v14; // [sp-8h] [bp-34h]@12
  int v15; // [sp-4h] [bp-30h]@10

  v5 = 0;
  v4 = *(_DWORD *)(a3 + 4);
  if ( v4 )
  {
    if ( *(_BYTE *)(v4 + 8) )
    {
      v6 = *(_DWORD *)(a3 + 8);
      if ( v6 || *(_DWORD *)a3 & 0x80000000 )
      {
        v7 = *(_DWORD *)a3;
        v8 = a2;
        if ( *(_DWORD *)a3 >= 0 )
          v8 = v6 + a2 + 12;
        if ( v7 & 8 )
        {
          if ( sub_1003E57C(*(_DWORD *)(a1 + 24)) && sub_1003E57C(v8) )
          {
            v9 = *(_DWORD *)(a1 + 24);
            *(_DWORD *)v8 = v9;
            v15 = a4 + 8;
            v13 = v9;
LABEL_11:
            *(_DWORD *)v8 = sub_1002DE20(v13, v15);
            return v5;
          }
        }
        else
        {
          v14 = *(_DWORD *)(a1 + 24);
          if ( *(_BYTE *)a4 & 1 )
          {
            if ( sub_1003E57C(v14) && sub_1003E57C(v8) )
            {
              sub_100237D0((void *)v8, *(const void **)(a1 + 24), *(_DWORD *)(a4 + 20));
              if ( *(_DWORD *)(a4 + 20) != 4 || !*(_DWORD *)v8 )
                return v5;
              v15 = a4 + 8;
              v13 = *(_DWORD *)v8;
              goto LABEL_11;
            }
          }
          else
          {
            if ( *(_DWORD *)(a4 + 24) )
            {
              if ( sub_1003E57C(v14) && sub_1003E57C(v8) && sub_1003E57C(*(_DWORD *)(a4 + 24)) )
                return ((*(_BYTE *)a4 & 4) != 0) + 1;
            }
            else
            {
              if ( sub_1003E57C(v14) && sub_1003E57C(v8) )
              {
                v10 = *(_DWORD *)(a4 + 20);
                v11 = sub_1002DE20(*(_DWORD *)(a1 + 24), a4 + 8);
                sub_100237D0((void *)v8, (const void *)v11, v10);
                return v5;
              }
            }
          }
        }
        sub_10031DA4(0, v8);
        return v5;
      }
    }
  }
  return 0;
}

//----- (1002E058) --------------------------------------------------------
void __usercall sub_1002E058(int a1<ebx>, int a2<edi>, int a3)
{
  _DWORD *v3; // eax@1
  int v4; // eax@6

  v3 = *(_DWORD **)a3;
  if ( **(_DWORD **)a3 == -532462766 || *v3 == -532459699 )
  {
    if ( *(_DWORD *)(sub_10031BD7(a1, a2) + 144) > 0 )
    {
      v4 = sub_10031BD7(a1, a2);
      --*(_DWORD *)(v4 + 144);
    }
  }
  else
  {
    if ( *v3 == -529697949 )
    {
      *(_DWORD *)(sub_10031BD7(a1, a2) + 144) = 0;
      sub_10031DDC(a1, a2);
    }
  }
}

//----- (1002E0A6) --------------------------------------------------------
int __usercall sub_1002E0A6<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6)
{
  int ebp0; // ebp@0
  int v7; // esi@2
  int v8; // eax@4
  int v9; // eax@9
  int result; // eax@12
  int v11; // [sp+10h] [bp-20h]@9

  if ( *(_DWORD *)(a5 + 4) > 128 )
    v7 = *(_DWORD *)(a3 + 8);
  else
    v7 = *(_BYTE *)(a3 + 8);
  v8 = sub_10031BD7(a1, a2);
  ++*(_DWORD *)(v8 + 144);
  while ( v7 != a6 )
  {
    if ( v7 <= -1 || v7 >= *(_DWORD *)(a5 + 4) )
      sub_10031DA4(a1, a2);
    v9 = *(_DWORD *)(a5 + 8);
    v11 = *(_DWORD *)(v9 + 8 * v7);
    if ( *(_DWORD *)(v9 + 8 * v7 + 4) )
    {
      *(_DWORD *)(a3 + 8) = *(_DWORD *)(v9 + 8 * v7);
      sub_1003E530(ebp0, a2, v7, *(_DWORD *)(*(_DWORD *)(a5 + 8) + 8 * v7 + 4), a3, 259);
    }
    v7 = v11;
  }
  result = sub_10031BD7(a1, a2);
  if ( *(_DWORD *)(result + 144) > 0 )
  {
    result = sub_10031BD7(a1, a2);
    --*(_DWORD *)(result + 144);
  }
  return result;
}

//----- (1002E17F) --------------------------------------------------------
int __usercall sub_1002E17F<eax>(int a1<ebx>, int a2<edi>, int ExceptionRecord, int a4, int a5, int a6, int a7, int a8, PVOID TargetFrame, char a10)
{
  int (__cdecl *v10)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // esi@16

  if ( *(_DWORD *)(sub_10031BD7(a1, a2) + 940)
    || *(_DWORD *)ExceptionRecord == -529697949
    || *(_DWORD *)ExceptionRecord == -2147483610
    || (*(_DWORD *)a7 & 0x1FFFFFFFu) < 0x19930522
    || !(*(_BYTE *)(a7 + 32) & 1) )
  {
    if ( *(_BYTE *)(ExceptionRecord + 4) & 0x66 )
    {
      if ( *(_DWORD *)(a7 + 4) )
      {
        if ( !a8 )
          sub_1002E0A6(-529697949, 429065506, a4, a6, a7, -1);
      }
    }
    else
    {
      if ( *(_DWORD *)(a7 + 12) || (*(_DWORD *)a7 & 0x1FFFFFFFu) >= 0x19930521 && *(_DWORD *)(a7 + 28) )
      {
        if ( *(_DWORD *)ExceptionRecord == -529697949 )
        {
          if ( *(_DWORD *)(ExceptionRecord + 16) >= 3u )
          {
            if ( *(_DWORD *)(ExceptionRecord + 20) > 0x19930522u )
            {
              v10 = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(ExceptionRecord + 28) + 8);
              if ( v10 )
                return v10(ExceptionRecord, a4, a5, a6, a7, a8, TargetFrame, (unsigned __int8)a10);
            }
          }
        }
        sub_1002D8D4(ExceptionRecord, a4, a5, a6, a7, a10, a8, TargetFrame);
      }
    }
  }
  return 1;
}

//----- (1002E25E) --------------------------------------------------------
bool __cdecl sub_1002E25E(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // edx@3

  v3 = *(_DWORD *)(a1 + 4);
  return !v3
      || !*(_BYTE *)(v3 + 8)
      || ((v4 = *(_DWORD *)(a2 + 4), v3 == v4) || !sub_10030DF0(v3 + 8, v4 + 8))
      && (!(*(_BYTE *)a2 & 2) || *(_BYTE *)a1 & 8)
      && (!(*(_BYTE *)a3 & 1) || *(_BYTE *)a1 & 1)
      && (!(*(_BYTE *)a3 & 2) || *(_BYTE *)a1 & 2);
}

//----- (1002E2BB) --------------------------------------------------------
void __cdecl sub_1002E2BB(unsigned int a1, LPCSTR lpWideCharStr)
{
  int v2; // ebx@1
  int v3; // edi@1
  const CHAR *v4; // esi@1
  int v5; // eax@2
  int v6; // ecx@2
  WCHAR *v7; // eax@6
  int v8; // eax@8
  int v9; // eax@13
  signed int v10; // eax@14
  int v11; // eax@14
  int v12; // edx@14
  int v13; // ecx@14
  int v14; // eax@19
  signed int v15; // eax@20
  int v16; // edx@20
  int v17; // ecx@20
  int v18; // edi@25
  int v19; // ecx@33
  int v20; // [sp+10h] [bp-30h]@14
  int v21; // [sp+14h] [bp-2Ch]@14
  int v22; // [sp+18h] [bp-28h]@20
  int v23; // [sp+1Ch] [bp-24h]@19
  int v24; // [sp+20h] [bp-20h]@14
  int cbMultiByte; // [sp+24h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+28h] [bp-18h]@25
  int v27; // [sp+4Ch] [bp+Ch]@13

  v2 = 0;
  cbMultiByte = 0;
  v3 = 0;
  v4 = lpWideCharStr;
  if ( !lpWideCharStr )
    goto LABEL_13;
  v5 = sub_1003F684((int)&cbMultiByte, 0, 0, lpWideCharStr, 2147483647);
  if ( !v5 || v5 != 22 && v5 != 34 )
    goto LABEL_6;
  while ( 1 )
  {
    sub_10036C98(v2, v3);
LABEL_6:
    v7 = (WCHAR *)sub_1002EFE1(v6, v2, cbMultiByte, 2u);
    v3 = (int)v7;
    if ( !v7 )
      break;
    v8 = sub_1003F684(v2, v7, cbMultiByte, v4, -1);
    if ( !v8 )
      goto LABEL_13;
    if ( v8 != 22 && v8 != 34 )
    {
      if ( v8 )
        goto LABEL_12;
LABEL_13:
      v4 = (const CHAR *)a1;
      sub_1003EB39(v3, a1, v3);
      v2 = v9;
      v27 = v9;
      sub_100282F6(v9, (LPVOID)v3);
      if ( !v2 )
        return;
      v11 = sub_10031BD7(v2, v3);
      v24 = v11;
      v20 = *(_DWORD *)(v11 + 108);
      v21 = *(_DWORD *)(v11 + 104);
      v3 = 0;
      cbMultiByte = 0;
      v10 = sub_1003F907(v2, (int)&cbMultiByte, 0, 0, v2, 0, (int)&v20);
      if ( !v10 )
        goto LABEL_19;
      if ( v10 != 22 && v10 != 34 )
      {
        if ( v10 )
          return;
LABEL_19:
        v14 = sub_1002F02B(v12, v13, v2, cbMultiByte + 4);
        v3 = v14;
        v23 = v14;
        if ( !v14 )
          return;
        v2 = v14 + 4;
        v22 = v14 + 4;
        v15 = sub_1003F907(v14 + 4, 0, (CHAR *)(v14 + 4), cbMultiByte, v27, -1, (int)&v20);
        if ( !v15 )
          goto LABEL_25;
        if ( v15 != 22 && v15 != 34 )
        {
          if ( v15 )
          {
LABEL_12:
            sub_100282F6(v2, (LPVOID)v3);
            return;
          }
LABEL_25:
          v18 = v20;
          sub_1002E493(v16, v17, v2, v20, 12);
          ms_exc.disabled = 0;
          if ( *(_DWORD *)(v18 + 16 * a1 + 24) )
          {
            if ( !InterlockedDecrement(*(volatile LONG **)(v18 + 16 * a1 + 24)) )
              sub_100282F6(v2, *(LPVOID *)(v18 + 16 * a1 + 24));
          }
          if ( !(*(_BYTE *)(v24 + 112) & 2) )
          {
            if ( !(dword_100675D4 & 1) )
            {
              if ( *(_DWORD *)(v18 + 16 * a1 + 24) )
              {
                if ( !InterlockedDecrement(*(volatile LONG **)(v18 + 16 * a1 + 24)) )
                  sub_100282F6(v2, *(LPVOID *)(v18 + 16 * a1 + 24));
              }
            }
          }
          v19 = v23;
          *(_DWORD *)v23 = *(_DWORD *)v18;
          *(_DWORD *)(v18 + 16 * a1 + 24) = v19;
          *(_DWORD *)(v18 + 16 * a1 + 16) = v2;
          sub_1002E5F7(12);
          return;
        }
      }
    }
  }
}
// 100675D4: using guessed type int dword_100675D4;

//----- (1002E493) --------------------------------------------------------
void __usercall sub_1002E493(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // edx@2
  int v6; // eax@2
  int v7; // [sp-4h] [bp-8h]@2

  if ( !*(&lpCriticalSection + 2 * a5) )
  {
    sub_1002E51B(a1, a2, a3, a4, a5);
    if ( !v6 )
      sub_1003234D(v5, v7, a3, a4, 17);
  }
  EnterCriticalSection(*(&lpCriticalSection + 2 * a5));
}

//----- (1002E51B) --------------------------------------------------------
void __usercall sub_1002E51B(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  HMODULE v5; // ecx@2
  int v6; // edx@5
  int v7; // esi@5
  int v8; // [sp-4h] [bp-2Ch]@5

  if ( !hHeap )
  {
    sub_10032605(a1, a2, a3, a4);
    sub_10032662(a3, 30);
    sub_10032227(v5, 0xFFu);
  }
  if ( !*(&lpCriticalSection + 2 * a5) )
  {
    v7 = sub_1002F02B(a1, a2, a3, 24);
    if ( v7 )
    {
      sub_1002E493(v6, v8, a3, a5, 10);
      if ( *(&lpCriticalSection + 2 * a5) )
      {
        sub_100282F6(a3, (LPVOID)v7);
      }
      else
      {
        InitializeCriticalSectionAndSpinCount((LPCRITICAL_SECTION)v7, 0xFA0u);
        *(&lpCriticalSection + 2 * a5) = (LPCRITICAL_SECTION)v7;
      }
      sub_1002E5F7(10);
    }
    else
    {
      *(_DWORD *)sub_1002F144(a3) = 12;
    }
  }
}

//----- (1002E5C2) --------------------------------------------------------
signed int __cdecl sub_1002E5C2()
{
  _UNKNOWN *v0; // edi@1
  signed int v1; // esi@1

  v1 = (signed int)&lpCriticalSection;
  v0 = &unk_10069460;
  do
  {
    if ( *(_DWORD *)(v1 + 4) == 1 )
    {
      *(_DWORD *)v1 = v0;
      v0 = (char *)v0 + 24;
      InitializeCriticalSectionAndSpinCount(*(LPCRITICAL_SECTION *)v1, 0xFA0u);
    }
    v1 += 8;
  }
  while ( v1 < (signed int)&off_10067090 );
  return 1;
}
// 10067090: using guessed type wchar_t *off_10067090;

//----- (1002E5F7) --------------------------------------------------------
void __cdecl sub_1002E5F7(int a1)
{
  LeaveCriticalSection(*(&lpCriticalSection + 2 * a1));
}

//----- (1002E60C) --------------------------------------------------------
int __usercall sub_1002E60C<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // eax@1
  int v4; // edx@1

  v3 = sub_10031BD7(a1, a2);
  v4 = v3;
  v2 = *(_DWORD *)(v3 + 108);
  if ( (volatile LONG *)v2 != off_10067514 )
  {
    if ( !(dword_100675D4 & *(_DWORD *)(v4 + 112)) )
      sub_1003A335(a1, a2);
  }
  return *(_DWORD *)(v2 + 144);
}
// 100675D4: using guessed type int dword_100675D4;

//----- (1002E635) --------------------------------------------------------
int __userpurge sub_1002E635<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  int v4; // esi@1
  int v5; // edx@2
  int v6; // eax@4
  int v7; // eax@7
  int v8; // eax@8
  int v9; // ecx@8

  v4 = a1;
  *(_BYTE *)(a1 + 12) = 0;
  if ( a4 )
  {
    *(_DWORD *)a1 = *(_DWORD *)a4;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a4 + 4);
  }
  else
  {
    v5 = sub_10031BD7(a2, a3);
    *(_DWORD *)(v4 + 8) = v5;
    *(_DWORD *)v4 = *(_DWORD *)(v5 + 108);
    *(_DWORD *)(v4 + 4) = *(_DWORD *)(v5 + 104);
    if ( *(volatile LONG **)v4 != off_10067514 )
    {
      if ( !(dword_100675D4 & *(_DWORD *)(v5 + 112)) )
      {
        sub_1003A335(a2, a3);
        *(_DWORD *)v4 = v6;
      }
    }
    if ( *(LPVOID *)(v4 + 4) != lpAddend )
    {
      if ( !(dword_100675D4 & *(_DWORD *)(*(_DWORD *)(v4 + 8) + 112)) )
      {
        sub_1003FC8B(a2, a3);
        *(_DWORD *)(v4 + 4) = v7;
      }
    }
    v9 = *(_DWORD *)(v4 + 8);
    v8 = *(_DWORD *)(v9 + 112);
    if ( !(v8 & 2) )
    {
      *(_DWORD *)(v9 + 112) = v8 | 2;
      *(_BYTE *)(v4 + 12) = 1;
    }
  }
  return v4;
}
// 100675D4: using guessed type int dword_100675D4;

//----- (1002E6BD) --------------------------------------------------------
int __usercall sub_1002E6BD<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4)
{
  int v4; // ecx@2
  __int16 v5; // cx@3
  int v7; // [sp+0h] [bp-10h]@1
  int v8; // [sp+8h] [bp-8h]@5
  char v9; // [sp+Ch] [bp-4h]@4

  sub_1002E635((int)&v7, a1, a2, a4);
  if ( *(_DWORD *)(v7 + 116) <= 1 )
  {
    v5 = *(_WORD *)(*(_DWORD *)(v7 + 144) + 2 * a3);
    v4 = v5 & 4;
  }
  else
  {
    v4 = sub_100400D3(a1, a2, a3, 4, (int)&v7);
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFDu;
  return v4;
}

//----- (1002E70D) --------------------------------------------------------
int __usercall sub_1002E70D<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4)
{
  int v4; // ecx@2
  __int16 v5; // cx@3
  int v7; // [sp+0h] [bp-10h]@1
  int v8; // [sp+8h] [bp-8h]@5
  char v9; // [sp+Ch] [bp-4h]@4

  sub_1002E635((int)&v7, a1, a2, a4);
  if ( *(_DWORD *)(v7 + 116) <= 1 )
  {
    v5 = *(_WORD *)(*(_DWORD *)(v7 + 144) + 2 * a3);
    v4 = v5 & 2;
  }
  else
  {
    v4 = sub_100400D3(a1, a2, a3, 2, (int)&v7);
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFDu;
  return v4;
}

//----- (1002E75D) --------------------------------------------------------
int __usercall sub_1002E75D<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4)
{
  int v4; // ecx@2
  __int16 v5; // cx@3
  int v7; // [sp+0h] [bp-10h]@1
  int v8; // [sp+8h] [bp-8h]@5
  char v9; // [sp+Ch] [bp-4h]@4

  sub_1002E635((int)&v7, a1, a2, a4);
  if ( *(_DWORD *)(v7 + 116) <= 1 )
  {
    v5 = *(_WORD *)(*(_DWORD *)(v7 + 144) + 2 * a3);
    v4 = v5 & 8;
  }
  else
  {
    v4 = sub_100400D3(a1, a2, a3, 8, (int)&v7);
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFDu;
  return v4;
}

//----- (1002E7AD) --------------------------------------------------------
int __usercall sub_1002E7AD<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4)
{
  int v4; // ecx@2
  __int16 v5; // cx@3
  int v7; // [sp+0h] [bp-10h]@1
  int v8; // [sp+8h] [bp-8h]@5
  char v9; // [sp+Ch] [bp-4h]@4

  sub_1002E635((int)&v7, a1, a2, a4);
  if ( *(_DWORD *)(v7 + 116) <= 1 )
  {
    v5 = *(_WORD *)(*(_DWORD *)(v7 + 144) + 2 * a3);
    v4 = v5 & 1;
  }
  else
  {
    v4 = sub_100400D3(a1, a2, a3, 1, (int)&v7);
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFDu;
  return v4;
}

//----- (1002E7FD) --------------------------------------------------------
int __usercall sub_1002E7FD<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4)
{
  int v4; // ecx@2
  __int16 v5; // cx@3
  int v7; // [sp+0h] [bp-10h]@1
  int v8; // [sp+8h] [bp-8h]@5
  char v9; // [sp+Ch] [bp-4h]@4

  sub_1002E635((int)&v7, a1, a2, a4);
  if ( *(_DWORD *)(v7 + 116) <= 1 )
  {
    v5 = *(_WORD *)(*(_DWORD *)(v7 + 144) + 2 * a3);
    v4 = v5 & 0x80;
  }
  else
  {
    v4 = sub_100400D3(a1, a2, a3, 128, (int)&v7);
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFDu;
  return v4;
}

//----- (1002E853) --------------------------------------------------------
int __usercall sub_1002E853<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  int result; // eax@2
  wchar_t v4; // ax@2

  if ( dword_10069EE8 )
  {
    result = sub_1002E6BD(a1, a2, a3, 0);
  }
  else
  {
    v4 = off_100675A8[a3];
    result = v4 & 4;
  }
  return result;
}
// 100675A8: using guessed type wchar_t *off_100675A8;
// 10069EE8: using guessed type int dword_10069EE8;

//----- (1002E87E) --------------------------------------------------------
int __usercall sub_1002E87E<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  int result; // eax@2
  wchar_t v4; // ax@2

  if ( dword_10069EE8 )
  {
    result = sub_1002E70D(a1, a2, a3, 0);
  }
  else
  {
    v4 = off_100675A8[a3];
    result = v4 & 2;
  }
  return result;
}
// 100675A8: using guessed type wchar_t *off_100675A8;
// 10069EE8: using guessed type int dword_10069EE8;

//----- (1002E8A9) --------------------------------------------------------
int __usercall sub_1002E8A9<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  int result; // eax@2
  wchar_t v4; // ax@2

  if ( dword_10069EE8 )
  {
    result = sub_1002E75D(a1, a2, a3, 0);
  }
  else
  {
    v4 = off_100675A8[a3];
    result = v4 & 8;
  }
  return result;
}
// 100675A8: using guessed type wchar_t *off_100675A8;
// 10069EE8: using guessed type int dword_10069EE8;

//----- (1002E8D4) --------------------------------------------------------
int __usercall sub_1002E8D4<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  int result; // eax@2
  wchar_t v4; // ax@2

  if ( dword_10069EE8 )
  {
    result = sub_1002E7AD(a1, a2, a3, 0);
  }
  else
  {
    v4 = off_100675A8[a3];
    result = v4 & 1;
  }
  return result;
}
// 100675A8: using guessed type wchar_t *off_100675A8;
// 10069EE8: using guessed type int dword_10069EE8;

//----- (1002E8FF) --------------------------------------------------------
int __usercall sub_1002E8FF<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  int result; // eax@2
  wchar_t v4; // ax@2

  if ( dword_10069EE8 )
  {
    result = sub_1002E7FD(a1, a2, a3, 0);
  }
  else
  {
    v4 = off_100675A8[a3];
    result = v4 & 0x80;
  }
  return result;
}
// 100675A8: using guessed type wchar_t *off_100675A8;
// 10069EE8: using guessed type int dword_10069EE8;

//----- (1002E92C) --------------------------------------------------------
int __usercall sub_1002E92C<eax>(int a1<ebx>, int a2)
{
  int result; // eax@2
  int v3; // eax@3
  int v4; // edx@3
  int v5; // ecx@3
  int v6; // ebx@3
  int v7; // edi@3
  int v8; // eax@3

  if ( a2 )
  {
    v8 = sub_10031399(a2);
    v7 = v8 + 1;
    v3 = (int)sub_10040182((void *)v5, a1, v8 + 1, 2u);
    v6 = v3;
    if ( v3 )
    {
      if ( sub_100401C0(v4, v5, v3, v7, v3, v7, a2) )
      {
        sub_10036C98(v6, v7);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_1002E97F);
      }
      result = v6;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002E97F) --------------------------------------------------------
int __usercall sub_1002E97F<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // eax@1
  int v4; // edx@1

  v3 = sub_10031BD7(a1, a2);
  v4 = v3;
  v2 = *(_DWORD *)(v3 + 108);
  if ( (volatile LONG *)v2 != off_10067514 )
  {
    if ( !(dword_100675D4 & *(_DWORD *)(v4 + 112)) )
      sub_1003A335(a1, a2);
  }
  return *(_DWORD *)(v2 + 4);
}
// 100675D4: using guessed type int dword_100675D4;

//----- (1002E9A5) --------------------------------------------------------
int __usercall sub_1002E9A5<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // eax@1
  int v4; // edx@1

  v3 = sub_10031BD7(a1, a2);
  v4 = v3;
  v2 = *(_DWORD *)(v3 + 108);
  if ( (volatile LONG *)v2 != off_10067514 )
  {
    if ( !(dword_100675D4 & *(_DWORD *)(v4 + 112)) )
      sub_1003A335(a1, a2);
  }
  return *(_DWORD *)(v2 + 8);
}
// 100675D4: using guessed type int dword_100675D4;

//----- (1002E9CB) --------------------------------------------------------
int __usercall sub_1002E9CB<eax>(int a1<ebx>, int a2<edi>)
{
  volatile LONG *v2; // eax@1
  int v3; // eax@1
  int v4; // edx@1

  v3 = sub_10031BD7(a1, a2);
  v4 = v3;
  v2 = *(volatile LONG **)(v3 + 108);
  if ( v2 != off_10067514 )
  {
    if ( !(dword_100675D4 & *(_DWORD *)(v4 + 112)) )
      sub_1003A335(a1, a2);
  }
  return (int)(v2 + 40);
}
// 100675D4: using guessed type int dword_100675D4;

//----- (1002E9F3) --------------------------------------------------------
int __usercall sub_1002E9F3<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // eax@1
  int v4; // edx@1

  v3 = sub_10031BD7(a1, a2);
  v4 = v3;
  v2 = *(_DWORD *)(v3 + 108);
  if ( (volatile LONG *)v2 != off_10067514 )
  {
    if ( !(dword_100675D4 & *(_DWORD *)(v4 + 112)) )
      sub_1003A335(a1, a2);
  }
  return *(_DWORD *)(v2 + 116);
}
// 100675D4: using guessed type int dword_100675D4;

//----- (1002EA19) --------------------------------------------------------
int __fastcall sub_1002EA19(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // ebx@1
  int v5; // edi@2
  LPVOID v6; // ecx@4
  int v7; // ecx@4
  int v8; // ecx@4
  int v9; // ecx@4
  int v10; // ecx@4
  signed int v11; // eax@9
  UINT v12; // ST1C_4@13
  int v13; // ST04_4@13
  char *v14; // ecx@17
  int v15; // edi@17
  int v16; // eax@18
  int v17; // edx@19
  int v18; // edi@25
  int v19; // eax@25
  int v20; // ecx@25
  unsigned __int8 v21; // zf@25
  char v22; // sf@25
  unsigned __int8 v23; // of@25
  char *v24; // ecx@27
  signed int v25; // edx@29
  int v26; // edi@30
  LPVOID v27; // eax@37
  int result; // eax@39
  int v29; // [sp+8h] [bp-44h]@1
  int v30; // [sp+Ch] [bp-40h]@1
  int v31; // [sp+10h] [bp-3Ch]@25
  int v32; // [sp+14h] [bp-38h]@25
  LPCSTR lpMultiByteStr; // [sp+18h] [bp-34h]@13
  int v34; // [sp+1Ch] [bp-30h]@13
  LPVOID lpMem; // [sp+20h] [bp-2Ch]@1
  int v36; // [sp+24h] [bp-28h]@1
  LPVOID v37; // [sp+28h] [bp-24h]@1
  LPVOID v38; // [sp+2Ch] [bp-20h]@1
  LPVOID v39; // [sp+30h] [bp-1Ch]@1
  struct _cpinfo CPInfo; // [sp+34h] [bp-18h]@11
  unsigned int v41; // [sp+48h] [bp-4h]@1
  int v42; // [sp+4Ch] [bp+0h]@1

  v41 = (unsigned int)&v42 ^ __security_cookie;
  v4 = 0;
  lpMem = 0;
  v3 = *(_DWORD *)(a3 + 168);
  v38 = 0;
  v37 = 0;
  v39 = 0;
  v36 = 0;
  v29 = a3;
  v30 = 0;
  if ( v3 )
  {
    v5 = a3 + 4;
    if ( !*(_DWORD *)(a3 + 4) && sub_1003281D((int)&v29, 0, v3, 0x1004u, (LPVOID *)(a3 + 4)) )
      goto LABEL_45;
    lpMem = (LPVOID)sub_1002F02B(a2, a1, 0, 4);
    v38 = sub_1002EFE1(v7, 0, 0x180u, 2u);
    v37 = sub_1002EFE1(v8, 0, 0x180u, 1u);
    v39 = sub_1002EFE1(v9, 0, 0x180u, 1u);
    v6 = sub_1002EFE1(v10, 0, 0x101u, 1u);
    v36 = (int)v6;
    if ( !lpMem )
      goto LABEL_45;
    if ( !v38 )
      goto LABEL_45;
    if ( !v6 )
      goto LABEL_45;
    if ( !v37 )
      goto LABEL_45;
    if ( !v39 )
      goto LABEL_45;
    *(_DWORD *)lpMem = 0;
    v11 = 0;
    do
    {
      *((_BYTE *)v6 + v11) = v11;
      ++v11;
    }
    while ( v11 < 256 );
    if ( !GetCPInfo(*(_DWORD *)v5, &CPInfo) )
      goto LABEL_45;
    if ( (_DWORD)CPInfo.MaxCharSize > 5u )
      goto LABEL_45;
    v12 = *(_DWORD *)v5;
    v34 = (unsigned __int16)CPInfo.MaxCharSize;
    v13 = *(_DWORD *)(a3 + 168);
    lpMultiByteStr = (LPCSTR)(v36 + 1);
    if ( !sub_1002EF9A(0, v5, 0, v13, 0x100u, (LPCSTR)(v36 + 1), 255, (LPWSTR)((char *)v37 + 129), 255, v12, 0) )
      goto LABEL_45;
    if ( !sub_1002EF9A(
            0,
            v5,
            0,
            *(_DWORD *)(a3 + 168),
            0x200u,
            lpMultiByteStr,
            255,
            (LPWSTR)((char *)v39 + 129),
            255,
            *(_DWORD *)v5,
            0) )
      goto LABEL_45;
    if ( v34 > 1 )
    {
      if ( CPInfo.LeadByte[0] )
      {
        v15 = v36;
        v14 = (char *)&CPInfo.LeadByte[1];
        do
        {
          LOBYTE(v16) = *v14;
          if ( !*v14 )
            break;
          v17 = (unsigned __int8)*(v14 - 1);
          v16 = (unsigned __int8)v16;
          while ( v17 <= v16 )
          {
            *(_BYTE *)(v17 + v15) = 32;
            v16 = (unsigned __int8)*v14;
            ++v17;
          }
          v14 += 2;
        }
        while ( *(v14 - 1) );
        v5 = a3 + 4;
      }
    }
    if ( sub_10040308(0, v5, 0, 1u, (LPCSTR)v36, 256, (LPWORD)v38 + 128, *(_DWORD *)v5, 0) )
    {
      v18 = (int)v38;
      v19 = (int)v39;
      *((_WORD *)v38 + 127) = 0;
      v20 = (int)((char *)v37 + 128);
      *((_BYTE *)v37 + 127) = 0;
      *(_BYTE *)(v19 + 127) = 0;
      v23 = __SETO__(v34, 1);
      v21 = v34 == 1;
      v22 = v34 - 1 < 0;
      *(_BYTE *)v20 = 0;
      v31 = v20;
      v32 = v19 + 128;
      *(_BYTE *)(v19 + 128) = 0;
      if ( !((unsigned __int8)(v22 ^ v23) | v21) )
      {
        if ( CPInfo.LeadByte[0] )
        {
          v24 = (char *)&CPInfo.LeadByte[1];
          do
          {
            if ( !*v24 )
              break;
            v25 = (unsigned __int8)*(v24 - 1);
            if ( v25 <= (unsigned __int8)*v24 )
            {
              lpMultiByteStr = (LPCSTR)(v18 + 256 + 2 * v25);
              v26 = v18 + 256 + 2 * v25;
              do
              {
                *(_WORD *)v26 = -32768;
                ++v25;
                v26 += 2;
              }
              while ( v25 <= (unsigned __int8)*v24 );
              v18 = (int)v38;
            }
            v24 += 2;
          }
          while ( *(v24 - 1) );
        }
      }
      sub_1002C950((void *)v18, (const void *)(v18 + 512), 0xFEu);
      sub_1002C950(v37, (char *)v37 + 256, 0x7Fu);
      sub_1002C950(v39, (char *)v39 + 256, 0x7Fu);
      if ( *(_DWORD *)(a3 + 136) )
      {
        if ( !InterlockedDecrement(*(volatile LONG **)(a3 + 136)) )
        {
          sub_100282F6(0, (LPVOID)(*(_DWORD *)(a3 + 140) - 254));
          sub_100282F6(0, (LPVOID)(*(_DWORD *)(a3 + 148) - 128));
          sub_100282F6(0, (LPVOID)(*(_DWORD *)(a3 + 152) - 128));
          sub_100282F6(0, *(LPVOID *)(a3 + 136));
        }
      }
      v27 = lpMem;
      *(_DWORD *)lpMem = 1;
      *(_DWORD *)(a3 + 136) = v27;
      *(_DWORD *)(a3 + 144) = v18 + 256;
      *(_DWORD *)(a3 + 140) = v18 + 254;
      *(_DWORD *)(a3 + 148) = v31;
      *(_DWORD *)(a3 + 152) = v32;
      *(_DWORD *)(a3 + 116) = v34;
    }
    else
    {
LABEL_45:
      sub_100282F6(0, lpMem);
      sub_100282F6(0, v38);
      sub_100282F6(0, v37);
      sub_100282F6(0, v39);
      v4 = 1;
    }
    sub_100282F6(v4, (LPVOID)v36);
    result = v4;
  }
  else
  {
    if ( *(_DWORD *)(a3 + 136) )
      InterlockedDecrement(*(volatile LONG **)(a3 + 136));
    *(_DWORD *)(a3 + 136) = 0;
    *(_DWORD *)(a3 + 140) = 0;
    *(_DWORD *)(a3 + 144) = L"         (((((                  H";
    *(_DWORD *)(a3 + 148) = &unk_10056510;
    *(_DWORD *)(a3 + 152) = &unk_10056690;
    *(_DWORD *)(a3 + 116) = 1;
    result = 0;
  }
  return result;
}
// 10056088: using guessed type wchar_t asc_10056088[33];
// 10067210: using guessed type int __security_cookie;

//----- (1002EDB1) --------------------------------------------------------
unsigned int __usercall sub_1002EDB1<eax>(int a1<ebx>, int a2, int a3, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpDestStr, int cchDest, UINT CodePage, int a10)
{
  int v10; // esi@1
  LPCSTR v11; // eax@2
  signed int v12; // ecx@2
  UINT v13; // ecx@8
  unsigned int v14; // edi@8
  unsigned int v15; // eax@10
  int v16; // ecx@10
  int v18; // ecx@14
  int v19; // ebx@15
  int v20; // eax@17
  unsigned int v21; // eax@24
  int v22; // esi@24
  unsigned int v23; // eax@31
  char *v24; // esi@32
  int v25; // eax@34
  int v26; // esi@36
  CHAR *v27; // [sp-10h] [bp-24h]@41
  int v28; // [sp-Ch] [bp-20h]@41
  char v29; // [sp+0h] [bp-14h]@15
  int cchSrc; // [sp+Ch] [bp-8h]@10
  unsigned int v31; // [sp+10h] [bp-4h]@1
  int v32; // [sp+14h] [bp+0h]@1

  v31 = (unsigned int)&v32 ^ __security_cookie;
  v10 = cbMultiByte;
  if ( cbMultiByte > 0 )
  {
    v11 = lpMultiByteStr;
    v12 = cbMultiByte;
    while ( 1 )
    {
      --v12;
      if ( !*v11 )
        break;
      ++v11;
      if ( !v12 )
      {
        v12 = -1;
        break;
      }
    }
    v10 = cbMultiByte - v12;
    if ( cbMultiByte - v12 - 1 >= cbMultiByte )
      v10 = cbMultiByte - v12 - 1;
  }
  v13 = CodePage;
  v14 = 0;
  if ( !CodePage )
  {
    CodePage = *(_DWORD *)(*(_DWORD *)a2 + 4);
    v13 = *(_DWORD *)(*(_DWORD *)a2 + 4);
  }
  v15 = MultiByteToWideChar(v13, 8 * (a10 != 0) + 1, lpMultiByteStr, v10, 0, 0);
  v16 = v15;
  cchSrc = v15;
  if ( !v15 )
    return 0;
  if ( (signed int)v15 > 0 && 0xFFFFFFE0 / v15 >= 2 )
  {
    v18 = 2 * v15 + 8;
    if ( (unsigned int)v18 > 0x400 )
    {
      v20 = sub_10028264(0xFFFFFFE0 % v15, v18, a1, 0, v18);
      v19 = v20;
      if ( v20 )
      {
        *(_DWORD *)v20 = 56797;
        goto LABEL_19;
      }
    }
    else
    {
      sub_10031E40(v18, v18, v29);
      v19 = (int)&v29;
      if ( &v29 )
      {
        *(_DWORD *)&v29 = 52428;
LABEL_19:
        v19 += 8;
        goto LABEL_20;
      }
    }
LABEL_20:
    v16 = cchSrc;
    goto LABEL_22;
  }
  v19 = 0;
LABEL_22:
  if ( !v19 )
    return 0;
  if ( MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, v10, (LPWSTR)v19, v16) )
  {
    v22 = cchSrc;
    v21 = sub_100318C3(a3, dwMapFlags, (LPCWSTR)v19, cchSrc, 0, 0);
    v14 = v21;
    if ( v21 )
    {
      if ( dwMapFlags & 0x400 )
      {
        if ( cchDest )
        {
          if ( (signed int)v21 <= cchDest )
            sub_100318C3(a3, dwMapFlags, (LPCWSTR)v19, v22, lpDestStr, cchDest);
        }
        goto LABEL_45;
      }
      if ( (signed int)v21 <= 0 || 0xFFFFFFE0 / v21 < 2 )
      {
        v26 = 0;
LABEL_38:
        if ( v26 )
        {
          if ( sub_100318C3(a3, dwMapFlags, (LPCWSTR)v19, cchSrc, (LPWSTR)v26, v14) )
          {
            if ( cchDest )
            {
              v28 = cchDest;
              v27 = (CHAR *)lpDestStr;
            }
            else
            {
              v28 = 0;
              v27 = 0;
            }
            v14 = WideCharToMultiByte(CodePage, 0, (LPCWSTR)v26, v14, v27, v28, 0, 0);
          }
          sub_1002563B(v19, v26);
        }
        goto LABEL_45;
      }
      v23 = 2 * v21 + 8;
      if ( v23 > 0x400 )
      {
        v25 = sub_10028264(0xFFFFFFE0 % v14, 1024, v19, v14, 2 * v14 + 8);
        v24 = (char *)v25;
        if ( v25 )
        {
          *(_DWORD *)v25 = 56797;
          goto LABEL_36;
        }
      }
      else
      {
        sub_10031E40(v23, 1024, v29);
        v24 = &v29;
        if ( &v29 )
        {
          *(_DWORD *)&v29 = 52428;
LABEL_36:
          v26 = (int)(v24 + 8);
          goto LABEL_38;
        }
      }
    }
  }
LABEL_45:
  sub_1002563B(v19, v19);
  return v14;
}
// 10067210: using guessed type int __security_cookie;

//----- (1002EF9A) --------------------------------------------------------
unsigned int __usercall sub_1002EF9A<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpDestStr, int cchDest, UINT CodePage, int a11)
{
  unsigned int result; // eax@1
  int v12; // [sp+0h] [bp-10h]@1
  int v13; // [sp+8h] [bp-8h]@2
  char v14; // [sp+Ch] [bp-4h]@1

  sub_1002E635((int)&v12, a1, a2, a3);
  result = sub_1002EDB1(a1, (int)&v12, a4, dwMapFlags, lpMultiByteStr, cbMultiByte, lpDestStr, cchDest, CodePage, a11);
  if ( v14 )
    *(_DWORD *)(v13 + 112) &= 0xFFFFFFFDu;
  return result;
}

//----- (1002EFE1) --------------------------------------------------------
LPVOID __usercall sub_1002EFE1<eax>(int this<ecx>, int ebx0<ebx>, unsigned int a2, unsigned int a3)
{
  int v4; // esi@1
  LPVOID v5; // edi@2

  v4 = 0;
  do
  {
    v5 = sub_100403AF((void *)this, ebx0, a2, a3, 0);
    if ( v5 )
      break;
    if ( (unsigned int)dword_100695B0 <= 0 )
      break;
    Sleep(v4);
    this = v4 + 1000;
    v4 = this;
    if ( this > (unsigned int)dword_100695B0 )
      v4 = -1;
  }
  while ( v4 != -1 );
  return v5;
}
// 100695B0: using guessed type int dword_100695B0;

//----- (1002F02B) --------------------------------------------------------
int __usercall sub_1002F02B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int dwBytes)
{
  int v4; // edi@1
  DWORD v5; // esi@1

  v4 = dword_100695B0;
  v5 = 0;
  do
  {
    a3 = sub_10028264(a1, a2, a3, v4, dwBytes);
    if ( a3 )
      break;
    if ( !v4 )
      break;
    Sleep(v5);
    v4 = dword_100695B0;
    a2 = v5 + 1000;
    v5 = a2;
    if ( a2 > (unsigned int)dword_100695B0 )
      v5 = -1;
  }
  while ( v5 != -1 );
  return a3;
}
// 100695B0: using guessed type int dword_100695B0;

//----- (1002F074) --------------------------------------------------------
int __usercall sub_1002F074<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, LPVOID lpMem, int dwBytes)
{
  DWORD v6; // esi@1
  int v7; // eax@2

  v6 = 0;
  do
  {
    v7 = sub_10028586(a1, a2, a3, a4, lpMem, dwBytes);
    a4 = v7;
    if ( v7 )
      break;
    if ( !dwBytes )
      break;
    if ( dword_100695B0 <= (unsigned int)v7 )
      break;
    Sleep(v6);
    v6 += 1000;
    if ( v6 > dword_100695B0 )
      v6 = -1;
  }
  while ( v6 != -1 );
  return a4;
}
// 100695B0: using guessed type int dword_100695B0;

//----- (1002F0C0) --------------------------------------------------------
int __usercall sub_1002F0C0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, const void *lpMem, unsigned int a5, unsigned int a6)
{
  DWORD v6; // esi@1
  int v7; // eax@2
  int v8; // edi@2

  v6 = 0;
  do
  {
    v7 = sub_10040346(a1, a2, a3, lpMem, a5, a6);
    v8 = v7;
    if ( v7 )
      break;
    if ( !a6 )
      break;
    if ( dword_100695B0 <= (unsigned int)v7 )
      break;
    Sleep(v6);
    v6 += 1000;
    if ( v6 > dword_100695B0 )
      v6 = -1;
  }
  while ( v6 != -1 );
  return v8;
}
// 100695B0: using guessed type int dword_100695B0;

//----- (1002F110) --------------------------------------------------------
int __usercall sub_1002F110<eax>(int a1<ebx>)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10031BEF(a1);
  if ( v1 )
    result = v1 + 12;
  else
    result = (int)&unk_10067204;
  return result;
}

//----- (1002F123) --------------------------------------------------------
int __usercall sub_1002F123<eax>(int a1<ebx>, int a2)
{
  int result; // eax@1
  signed int v3; // esi@1

  *(_DWORD *)sub_1002F110(a1) = a2;
  v3 = sub_1002F157(a2);
  result = sub_1002F144(a1);
  *(_DWORD *)result = v3;
  return result;
}

//----- (1002F144) --------------------------------------------------------
int __usercall sub_1002F144<eax>(int a1<ebx>)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10031BEF(a1);
  if ( v1 )
    result = v1 + 8;
  else
    result = (int)&unk_10067200;
  return result;
}

//----- (1002F157) --------------------------------------------------------
signed int __cdecl sub_1002F157(int a1)
{
  unsigned int v1; // eax@1
  signed int result; // eax@5

  v1 = 0;
  do
  {
    if ( a1 == dword_10067098[2 * v1] )
      return dword_1006709C[2 * v1];
    ++v1;
  }
  while ( v1 < 0x2D );
  if ( (unsigned int)(a1 - 19) > 0x11 )
    result = (unsigned int)(a1 - 188) > 0xE ? 22 : 8;
  else
    result = 13;
  return result;
}
// 10067098: using guessed type int dword_10067098[];
// 1006709C: using guessed type int dword_1006709C[];

//----- (1002F198) --------------------------------------------------------
signed int __usercall sub_1002F198<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned __int8 a4, int a5, unsigned __int8 a6)
{
  signed int v6; // edx@2
  int v7; // eax@3
  int v9; // [sp+4h] [bp-10h]@1
  int v10; // [sp+8h] [bp-Ch]@1
  int v11; // [sp+Ch] [bp-8h]@8
  char v12; // [sp+10h] [bp-4h]@7

  sub_1002E635((int)&v9, a1, a2, a3);
  if ( a6 & *(_BYTE *)(v10 + a4 + 25)
    || ((v6 = 0, !a5) ? (v7 = 0) : (v7 = (unsigned __int16)(a5 & *(_WORD *)(*(_DWORD *)(v9 + 144) + 2 * a4))), v7) )
    v6 = 1;
  if ( v12 )
    *(_DWORD *)(v11 + 112) &= 0xFFFFFFFDu;
  return v6;
}

//----- (1002F1EE) --------------------------------------------------------
signed int __usercall sub_1002F1EE<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3)
{
  return sub_1002F198(a1, a2, 0, a3, 0, 4u);
}

//----- (1002F204) --------------------------------------------------------
int __cdecl sub_1002F204(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // ebx@1
  int v4; // edx@5
  int v5; // esi@6
  int v6; // eax@7
  int v7; // edi@8
  int v8; // ecx@9
  bool v9; // ecx@9
  int v10; // edi@10
  bool v11; // ecx@11
  int v12; // edi@12
  bool v13; // ecx@13
  int v14; // eax@18
  int v15; // edi@21
  bool v16; // ecx@22
  int v17; // edi@23
  bool v18; // ecx@24
  int v19; // eax@29
  int v20; // edi@32
  bool v21; // ecx@33
  int v22; // edi@34
  bool v23; // ecx@35
  int v24; // eax@40
  int v25; // edi@43
  bool v26; // ecx@44
  int v27; // edi@45
  bool v28; // ecx@46
  int v29; // edi@54
  bool v30; // ecx@55
  int v31; // edi@56
  bool v32; // ecx@57
  int v33; // eax@62
  int v34; // edi@65
  bool v35; // ecx@66
  int v36; // edi@67
  bool v37; // ecx@68
  int v38; // eax@73
  int v39; // edi@76
  bool v40; // ecx@77
  int v41; // edi@78
  bool v42; // ecx@79
  int v43; // eax@84
  int v44; // edi@87
  bool v45; // ecx@88
  int v46; // edi@89
  bool v47; // ecx@90
  int v48; // edx@96
  int v49; // esi@96
  int v50; // eax@97
  int v51; // edi@98
  bool v52; // ecx@99
  int v53; // edi@100
  bool v54; // ecx@101
  int v55; // edi@102
  bool v56; // ecx@103
  int v57; // eax@108
  int v58; // edi@109
  bool v59; // ecx@110
  int v60; // edi@111
  bool v61; // ecx@112
  int v62; // edi@113
  bool v63; // ecx@114
  int v64; // eax@119
  int v65; // edi@120
  bool v66; // ecx@121
  int v67; // edi@122
  bool v68; // ecx@123
  int v69; // edi@124
  bool v70; // ecx@125
  int v71; // eax@130
  int v72; // edi@131
  bool v73; // ecx@132
  int v74; // edi@133
  bool v75; // ecx@134
  int v76; // edi@135
  bool v77; // ecx@136
  int v78; // edi@142
  bool v79; // ecx@143
  int v80; // edi@144
  bool v81; // ecx@145
  int v82; // edi@146
  bool v83; // ecx@147
  int v84; // eax@152
  int v85; // edi@153
  bool v86; // ecx@154
  int v87; // edi@155
  bool v88; // ecx@156
  int v89; // edi@157
  bool v90; // ecx@158
  int v91; // eax@163
  int v92; // edi@164
  bool v93; // ecx@165
  int v94; // edi@166
  bool v95; // ecx@167
  int v96; // edi@168
  bool v97; // ecx@169
  int result; // eax@175
  int v99; // eax@176
  int v100; // edi@177
  bool v101; // ecx@178
  int v102; // edi@179
  bool v103; // ecx@180
  int v104; // edi@181
  bool v105; // ecx@182
  int v106; // eax@187
  int v107; // edi@188
  bool v108; // ecx@189
  int v109; // edi@190
  bool v110; // ecx@191
  int v111; // edi@192
  bool v112; // ecx@193
  int v113; // eax@198
  int v114; // edi@199
  bool v115; // ecx@200
  int v116; // edi@201
  bool v117; // ecx@202
  int v118; // edi@203
  bool v119; // ecx@204
  int v120; // eax@209
  int v121; // edi@210
  bool v122; // ecx@211
  int v123; // edi@212
  bool v124; // ecx@213
  int v125; // edi@214
  bool v126; // ecx@215
  int v127; // eax@220
  int v128; // edi@221
  bool v129; // ecx@222
  int v130; // edi@223
  bool v131; // ecx@224
  int v132; // edi@225
  bool v133; // ecx@226
  int v134; // edi@232
  bool v135; // ecx@233
  int v136; // edi@234
  bool v137; // ecx@235
  int v138; // edi@236
  bool v139; // ecx@237
  int v140; // eax@242
  int v141; // edi@243
  bool v142; // ecx@244
  int v143; // edi@245
  bool v144; // ecx@246
  int v145; // edi@247
  bool v146; // ecx@248
  int v147; // eax@255
  int v148; // edi@256
  bool v149; // ecx@257
  int v150; // edi@258
  bool v151; // ecx@259
  int v152; // edi@260
  bool v153; // ecx@261
  int v154; // eax@266
  int v155; // edi@267
  bool v156; // ecx@268
  int v157; // edi@269
  bool v158; // ecx@270
  int v159; // edi@271
  bool v160; // ecx@272
  int v161; // eax@277
  int v162; // edi@278
  bool v163; // ecx@279
  int v164; // edi@280
  bool v165; // ecx@281
  int v166; // edi@282
  bool v167; // ecx@283
  int v168; // eax@288
  int v169; // edi@289
  bool v170; // ecx@290
  int v171; // edi@291
  bool v172; // ecx@292
  int v173; // edi@293
  bool v174; // ecx@294
  int v175; // eax@299
  int v176; // edi@300
  bool v177; // ecx@301
  int v178; // edi@302
  bool v179; // ecx@303
  int v180; // edi@304
  bool v181; // ecx@305
  int v182; // edi@311
  bool v183; // ecx@312
  int v184; // edi@313
  bool v185; // ecx@314
  int v186; // edi@315
  bool v187; // ecx@316
  int v188; // eax@321
  int v189; // edi@322
  bool v190; // ecx@323
  int v191; // edi@324
  bool v192; // ecx@325
  int v193; // edi@326
  bool v194; // ecx@327
  int v195; // eax@334
  int v196; // edi@335
  bool v197; // ecx@336
  int v198; // edi@337
  bool v199; // ecx@338
  int v200; // edi@339
  bool v201; // ecx@340
  int v202; // eax@345
  int v203; // edi@346
  bool v204; // ecx@347
  int v205; // edi@348
  bool v206; // ecx@349
  int v207; // edi@350
  bool v208; // ecx@351
  int v209; // eax@356
  int v210; // edi@357
  bool v211; // ecx@358
  int v212; // edi@359
  bool v213; // ecx@360
  int v214; // edi@361
  bool v215; // ecx@362
  int v216; // eax@367
  int v217; // edi@368
  bool v218; // ecx@369
  int v219; // edi@370
  bool v220; // ecx@371
  int v221; // edi@372
  bool v222; // ecx@373
  int v223; // edi@379
  bool v224; // ecx@380
  int v225; // edi@381
  bool v226; // ecx@382
  int v227; // edi@383
  bool v228; // ecx@384
  int v229; // eax@389
  int v230; // edi@390
  bool v231; // ecx@391
  int v232; // edi@392
  bool v233; // ecx@393
  int v234; // edi@394
  bool v235; // ecx@395
  int v236; // eax@400
  int v237; // edi@401
  bool v238; // ecx@402
  int v239; // edi@403
  bool v240; // ecx@404
  int v241; // edi@405
  bool v242; // ecx@406
  int v243; // edi@411
  bool v244; // ecx@412
  int v245; // edi@413
  bool v246; // ecx@414
  int v247; // esi@415
  bool v248; // eax@416
  int v249; // esi@417
  bool v250; // eax@418
  int v251; // esi@419
  bool v252; // eax@420
  int v253; // eax@421
  int v254; // ecx@421
  int v255; // ecx@422
  int v256; // ecx@425
  bool v257; // eax@426
  int v258; // ecx@427
  bool v259; // eax@428
  int v260; // ecx@430
  bool v261; // eax@431

  v3 = a3;
  if ( !a3 )
    return 0;
  if ( a3 == 1 )
  {
    v254 = *(_BYTE *)a1;
    v253 = *(_BYTE *)a2;
    goto LABEL_422;
  }
  if ( a3 == 2 )
  {
    v260 = *(_BYTE *)a1 - *(_BYTE *)a2;
    if ( *(_BYTE *)a1 != *(_BYTE *)a2 )
    {
      v261 = v260 < 0;
      LOBYTE(v261) = v260 > 0;
      result = 2 * v261 - 1;
      if ( result )
        return result;
    }
    v254 = *(_BYTE *)(a1 + 1);
    v253 = *(_BYTE *)(a2 + 1);
LABEL_422:
    v255 = v254 - v253;
    if ( v255 )
      v255 = 2 * (v255 > 0) - 1;
    return v255;
  }
  if ( a3 == 3 )
  {
    v256 = *(_BYTE *)a1 - *(_BYTE *)a2;
    if ( *(_BYTE *)a1 != *(_BYTE *)a2 && (v257 = v256 < 0, LOBYTE(v257) = v256 > 0, (result = 2 * v257 - 1) != 0)
      || (v258 = *(_BYTE *)(a1 + 1) - *(_BYTE *)(a2 + 1), *(_BYTE *)(a1 + 1) != *(_BYTE *)(a2 + 1))
      && (v259 = v258 < 0, LOBYTE(v259) = v258 > 0, (result = 2 * v259 - 1) != 0) )
      return result;
    v254 = *(_BYTE *)(a1 + 2);
    v253 = *(_BYTE *)(a2 + 2);
    goto LABEL_422;
  }
  v4 = a2;
  if ( a3 == 4 )
  {
    v247 = *(_BYTE *)a1 - *(_BYTE *)a2;
    if ( *(_BYTE *)a1 != *(_BYTE *)a2 && (v248 = v247 < 0, LOBYTE(v248) = v247 > 0, (result = 2 * v248 - 1) != 0)
      || (v249 = *(_BYTE *)(a1 + 1) - *(_BYTE *)(a2 + 1), *(_BYTE *)(a1 + 1) != *(_BYTE *)(a2 + 1))
      && (v250 = v249 < 0, LOBYTE(v250) = v249 > 0, (result = 2 * v250 - 1) != 0)
      || (v251 = *(_BYTE *)(a1 + 2) - *(_BYTE *)(a2 + 2), *(_BYTE *)(a1 + 2) != *(_BYTE *)(a2 + 2))
      && (v252 = v251 < 0, LOBYTE(v252) = v251 > 0, (result = 2 * v252 - 1) != 0) )
      return result;
    v254 = *(_BYTE *)(a1 + 3);
    v253 = *(_BYTE *)(a2 + 3);
    goto LABEL_422;
  }
  v5 = a1;
  if ( a3 >= 0x20 )
  {
    do
    {
      v6 = *(_DWORD *)v5;
      if ( *(_DWORD *)v5 == *(_DWORD *)v4 )
      {
        v8 = 0;
      }
      else
      {
        v7 = (unsigned __int8)v6 - *(_BYTE *)v4;
        if ( (unsigned __int8)v6 != *(_BYTE *)v4 && (v9 = v7 < 0, LOBYTE(v9) = v7 > 0, (v8 = 2 * v9 - 1) != 0)
          || (v10 = *(_BYTE *)(v5 + 1) - *(_BYTE *)(v4 + 1), *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1))
          && (v11 = v10 < 0, LOBYTE(v11) = v10 > 0, (v8 = 2 * v11 - 1) != 0)
          || (v12 = *(_BYTE *)(v5 + 2) - *(_BYTE *)(v4 + 2), *(_BYTE *)(v5 + 2) != *(_BYTE *)(v4 + 2))
          && (v13 = v12 < 0, LOBYTE(v13) = v12 > 0, (v8 = 2 * v13 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 3) - *(_BYTE *)(v4 + 3);
        if ( *(_BYTE *)(v5 + 3) != *(_BYTE *)(v4 + 3) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v14 = *(_DWORD *)(v5 + 4);
      if ( v14 == *(_DWORD *)(v4 + 4) )
      {
        v8 = 0;
      }
      else
      {
        if ( (unsigned __int8)v14 != *(_BYTE *)(v4 + 4)
          && (LOBYTE(v8) = (unsigned __int8)v14 - *(_BYTE *)(v4 + 4) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v15 = *(_BYTE *)(v5 + 5) - *(_BYTE *)(v4 + 5), *(_BYTE *)(v5 + 5) != *(_BYTE *)(v4 + 5))
          && (v16 = v15 < 0, LOBYTE(v16) = v15 > 0, (v8 = 2 * v16 - 1) != 0)
          || (v17 = *(_BYTE *)(v5 + 6) - *(_BYTE *)(v4 + 6), *(_BYTE *)(v5 + 6) != *(_BYTE *)(v4 + 6))
          && (v18 = v17 < 0, LOBYTE(v18) = v17 > 0, (v8 = 2 * v18 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 7) - *(_BYTE *)(v4 + 7);
        if ( *(_BYTE *)(v5 + 7) != *(_BYTE *)(v4 + 7) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v19 = *(_DWORD *)(v5 + 8);
      if ( v19 == *(_DWORD *)(v4 + 8) )
      {
        v8 = 0;
      }
      else
      {
        if ( (unsigned __int8)v19 != *(_BYTE *)(v4 + 8)
          && (LOBYTE(v8) = (unsigned __int8)v19 - *(_BYTE *)(v4 + 8) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v20 = *(_BYTE *)(v5 + 9) - *(_BYTE *)(v4 + 9), *(_BYTE *)(v5 + 9) != *(_BYTE *)(v4 + 9))
          && (v21 = v20 < 0, LOBYTE(v21) = v20 > 0, (v8 = 2 * v21 - 1) != 0)
          || (v22 = *(_BYTE *)(v5 + 10) - *(_BYTE *)(v4 + 10), *(_BYTE *)(v5 + 10) != *(_BYTE *)(v4 + 10))
          && (v23 = v22 < 0, LOBYTE(v23) = v22 > 0, (v8 = 2 * v23 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 11) - *(_BYTE *)(v4 + 11);
        if ( *(_BYTE *)(v5 + 11) != *(_BYTE *)(v4 + 11) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v24 = *(_DWORD *)(v5 + 12);
      if ( v24 == *(_DWORD *)(v4 + 12) )
      {
        v8 = 0;
      }
      else
      {
        if ( (unsigned __int8)v24 != *(_BYTE *)(v4 + 12)
          && (LOBYTE(v8) = (unsigned __int8)v24 - *(_BYTE *)(v4 + 12) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v25 = *(_BYTE *)(v5 + 13) - *(_BYTE *)(v4 + 13), *(_BYTE *)(v5 + 13) != *(_BYTE *)(v4 + 13))
          && (v26 = v25 < 0, LOBYTE(v26) = v25 > 0, (v8 = 2 * v26 - 1) != 0)
          || (v27 = *(_BYTE *)(v5 + 14) - *(_BYTE *)(v4 + 14), *(_BYTE *)(v5 + 14) != *(_BYTE *)(v4 + 14))
          && (v28 = v27 < 0, LOBYTE(v28) = v27 > 0, (v8 = 2 * v28 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 15) - *(_BYTE *)(v4 + 15);
        if ( *(_BYTE *)(v5 + 15) != *(_BYTE *)(v4 + 15) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      if ( *(_DWORD *)(v5 + 16) == *(_DWORD *)(v4 + 16) )
      {
        v8 = 0;
      }
      else
      {
        if ( *(_BYTE *)(v5 + 16) != *(_BYTE *)(v4 + 16)
          && (LOBYTE(v8) = *(_BYTE *)(v5 + 16) - *(_BYTE *)(v4 + 16) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v29 = *(_BYTE *)(v5 + 17) - *(_BYTE *)(v4 + 17), *(_BYTE *)(v5 + 17) != *(_BYTE *)(v4 + 17))
          && (v30 = v29 < 0, LOBYTE(v30) = v29 > 0, (v8 = 2 * v30 - 1) != 0)
          || (v31 = *(_BYTE *)(v5 + 18) - *(_BYTE *)(v4 + 18), *(_BYTE *)(v5 + 18) != *(_BYTE *)(v4 + 18))
          && (v32 = v31 < 0, LOBYTE(v32) = v31 > 0, (v8 = 2 * v32 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 19) - *(_BYTE *)(v4 + 19);
        if ( *(_BYTE *)(v5 + 19) != *(_BYTE *)(v4 + 19) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v33 = *(_DWORD *)(v5 + 20);
      if ( v33 == *(_DWORD *)(v4 + 20) )
      {
        v8 = 0;
      }
      else
      {
        if ( (unsigned __int8)v33 != *(_BYTE *)(v4 + 20)
          && (LOBYTE(v8) = (unsigned __int8)v33 - *(_BYTE *)(v4 + 20) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v34 = *(_BYTE *)(v5 + 21) - *(_BYTE *)(v4 + 21), *(_BYTE *)(v5 + 21) != *(_BYTE *)(v4 + 21))
          && (v35 = v34 < 0, LOBYTE(v35) = v34 > 0, (v8 = 2 * v35 - 1) != 0)
          || (v36 = *(_BYTE *)(v5 + 22) - *(_BYTE *)(v4 + 22), *(_BYTE *)(v5 + 22) != *(_BYTE *)(v4 + 22))
          && (v37 = v36 < 0, LOBYTE(v37) = v36 > 0, (v8 = 2 * v37 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 23) - *(_BYTE *)(v4 + 23);
        if ( *(_BYTE *)(v5 + 23) != *(_BYTE *)(v4 + 23) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v38 = *(_DWORD *)(v5 + 24);
      if ( v38 == *(_DWORD *)(v4 + 24) )
      {
        v8 = 0;
      }
      else
      {
        if ( (unsigned __int8)v38 != *(_BYTE *)(v4 + 24)
          && (LOBYTE(v8) = (unsigned __int8)v38 - *(_BYTE *)(v4 + 24) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v39 = *(_BYTE *)(v5 + 25) - *(_BYTE *)(v4 + 25), *(_BYTE *)(v5 + 25) != *(_BYTE *)(v4 + 25))
          && (v40 = v39 < 0, LOBYTE(v40) = v39 > 0, (v8 = 2 * v40 - 1) != 0)
          || (v41 = *(_BYTE *)(v5 + 26) - *(_BYTE *)(v4 + 26), *(_BYTE *)(v5 + 26) != *(_BYTE *)(v4 + 26))
          && (v42 = v41 < 0, LOBYTE(v42) = v41 > 0, (v8 = 2 * v42 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 27) - *(_BYTE *)(v4 + 27);
        if ( *(_BYTE *)(v5 + 27) != *(_BYTE *)(v4 + 27) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v43 = *(_DWORD *)(v5 + 28);
      if ( v43 == *(_DWORD *)(v4 + 28) )
      {
        v8 = 0;
      }
      else
      {
        if ( (unsigned __int8)v43 != *(_BYTE *)(v4 + 28)
          && (LOBYTE(v8) = (unsigned __int8)v43 - *(_BYTE *)(v4 + 28) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v44 = *(_BYTE *)(v5 + 29) - *(_BYTE *)(v4 + 29), *(_BYTE *)(v5 + 29) != *(_BYTE *)(v4 + 29))
          && (v45 = v44 < 0, LOBYTE(v45) = v44 > 0, (v8 = 2 * v45 - 1) != 0)
          || (v46 = *(_BYTE *)(v5 + 30) - *(_BYTE *)(v4 + 30), *(_BYTE *)(v5 + 30) != *(_BYTE *)(v4 + 30))
          && (v47 = v46 < 0, LOBYTE(v47) = v46 > 0, (v8 = 2 * v47 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 31) - *(_BYTE *)(v4 + 31);
        if ( *(_BYTE *)(v5 + 31) != *(_BYTE *)(v4 + 31) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v3 -= 32;
      v5 += 32;
      v4 += 32;
    }
    while ( v3 >= 0x20 );
  }
  v49 = v3 + v5;
  v48 = v3 + v4;
  switch ( v3 )
  {
    case 0x1Cu:
      v50 = *(_DWORD *)(v49 - 28);
      if ( v50 == *(_DWORD *)(v48 - 28) )
      {
        v8 = 0;
      }
      else
      {
        v51 = (unsigned __int8)v50 - *(_BYTE *)(v48 - 28);
        if ( (unsigned __int8)v50 != *(_BYTE *)(v48 - 28)
          && (v52 = v51 < 0, LOBYTE(v52) = v51 > 0, (v8 = 2 * v52 - 1) != 0)
          || (v53 = *(_BYTE *)(v49 - 27) - *(_BYTE *)(v48 - 27), *(_BYTE *)(v49 - 27) != *(_BYTE *)(v48 - 27))
          && (v54 = v53 < 0, LOBYTE(v54) = v53 > 0, (v8 = 2 * v54 - 1) != 0)
          || (v55 = *(_BYTE *)(v49 - 26) - *(_BYTE *)(v48 - 26), *(_BYTE *)(v49 - 26) != *(_BYTE *)(v48 - 26))
          && (v56 = v55 < 0, LOBYTE(v56) = v55 > 0, (v8 = 2 * v56 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 25) - *(_BYTE *)(v48 - 25);
        if ( *(_BYTE *)(v49 - 25) != *(_BYTE *)(v48 - 25) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        goto LABEL_108;
      return v8;
    case 0x18u:
LABEL_108:
      v57 = *(_DWORD *)(v49 - 24);
      if ( v57 == *(_DWORD *)(v48 - 24) )
      {
        v8 = 0;
      }
      else
      {
        v58 = (unsigned __int8)v57 - *(_BYTE *)(v48 - 24);
        if ( (unsigned __int8)v57 != *(_BYTE *)(v48 - 24)
          && (v59 = v58 < 0, LOBYTE(v59) = v58 > 0, (v8 = 2 * v59 - 1) != 0)
          || (v60 = *(_BYTE *)(v49 - 23) - *(_BYTE *)(v48 - 23), *(_BYTE *)(v49 - 23) != *(_BYTE *)(v48 - 23))
          && (v61 = v60 < 0, LOBYTE(v61) = v60 > 0, (v8 = 2 * v61 - 1) != 0)
          || (v62 = *(_BYTE *)(v49 - 22) - *(_BYTE *)(v48 - 22), *(_BYTE *)(v49 - 22) != *(_BYTE *)(v48 - 22))
          && (v63 = v62 < 0, LOBYTE(v63) = v62 > 0, (v8 = 2 * v63 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 21) - *(_BYTE *)(v48 - 21);
        if ( *(_BYTE *)(v49 - 21) != *(_BYTE *)(v48 - 21) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        goto LABEL_119;
      return v8;
    case 0x14u:
LABEL_119:
      v64 = *(_DWORD *)(v49 - 20);
      if ( v64 == *(_DWORD *)(v48 - 20) )
      {
        v8 = 0;
      }
      else
      {
        v65 = (unsigned __int8)v64 - *(_BYTE *)(v48 - 20);
        if ( (unsigned __int8)v64 != *(_BYTE *)(v48 - 20)
          && (v66 = v65 < 0, LOBYTE(v66) = v65 > 0, (v8 = 2 * v66 - 1) != 0)
          || (v67 = *(_BYTE *)(v49 - 19) - *(_BYTE *)(v48 - 19), *(_BYTE *)(v49 - 19) != *(_BYTE *)(v48 - 19))
          && (v68 = v67 < 0, LOBYTE(v68) = v67 > 0, (v8 = 2 * v68 - 1) != 0)
          || (v69 = *(_BYTE *)(v49 - 18) - *(_BYTE *)(v48 - 18), *(_BYTE *)(v49 - 18) != *(_BYTE *)(v48 - 18))
          && (v70 = v69 < 0, LOBYTE(v70) = v69 > 0, (v8 = 2 * v70 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 17) - *(_BYTE *)(v48 - 17);
        if ( *(_BYTE *)(v49 - 17) != *(_BYTE *)(v48 - 17) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        goto LABEL_130;
      return v8;
    case 0x10u:
LABEL_130:
      v71 = *(_DWORD *)(v49 - 16);
      if ( v71 == *(_DWORD *)(v48 - 16) )
      {
        v8 = 0;
      }
      else
      {
        v72 = (unsigned __int8)v71 - *(_BYTE *)(v48 - 16);
        if ( (unsigned __int8)v71 != *(_BYTE *)(v48 - 16)
          && (v73 = v72 < 0, LOBYTE(v73) = v72 > 0, (v8 = 2 * v73 - 1) != 0)
          || (v74 = *(_BYTE *)(v49 - 15) - *(_BYTE *)(v48 - 15), *(_BYTE *)(v49 - 15) != *(_BYTE *)(v48 - 15))
          && (v75 = v74 < 0, LOBYTE(v75) = v74 > 0, (v8 = 2 * v75 - 1) != 0)
          || (v76 = *(_BYTE *)(v49 - 14) - *(_BYTE *)(v48 - 14), *(_BYTE *)(v49 - 14) != *(_BYTE *)(v48 - 14))
          && (v77 = v76 < 0, LOBYTE(v77) = v76 > 0, (v8 = 2 * v77 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 13) - *(_BYTE *)(v48 - 13);
        if ( *(_BYTE *)(v49 - 13) != *(_BYTE *)(v48 - 13) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        goto LABEL_141;
      return v8;
    case 0xCu:
LABEL_141:
      if ( *(_DWORD *)(v49 - 12) == *(_DWORD *)(v48 - 12) )
      {
        v8 = 0;
      }
      else
      {
        v78 = *(_BYTE *)(v49 - 12) - *(_BYTE *)(v48 - 12);
        if ( *(_BYTE *)(v49 - 12) != *(_BYTE *)(v48 - 12)
          && (v79 = v78 < 0, LOBYTE(v79) = v78 > 0, (v8 = 2 * v79 - 1) != 0)
          || (v80 = *(_BYTE *)(v49 - 11) - *(_BYTE *)(v48 - 11), *(_BYTE *)(v49 - 11) != *(_BYTE *)(v48 - 11))
          && (v81 = v80 < 0, LOBYTE(v81) = v80 > 0, (v8 = 2 * v81 - 1) != 0)
          || (v82 = *(_BYTE *)(v49 - 10) - *(_BYTE *)(v48 - 10), *(_BYTE *)(v49 - 10) != *(_BYTE *)(v48 - 10))
          && (v83 = v82 < 0, LOBYTE(v83) = v82 > 0, (v8 = 2 * v83 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 9) - *(_BYTE *)(v48 - 9);
        if ( *(_BYTE *)(v49 - 9) != *(_BYTE *)(v48 - 9) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        goto LABEL_152;
      return v8;
    case 8u:
LABEL_152:
      v84 = *(_DWORD *)(v49 - 8);
      if ( v84 == *(_DWORD *)(v48 - 8) )
      {
        v8 = 0;
      }
      else
      {
        v85 = (unsigned __int8)v84 - *(_BYTE *)(v48 - 8);
        if ( (unsigned __int8)v84 != *(_BYTE *)(v48 - 8)
          && (v86 = v85 < 0, LOBYTE(v86) = v85 > 0, (v8 = 2 * v86 - 1) != 0)
          || (v87 = *(_BYTE *)(v49 - 7) - *(_BYTE *)(v48 - 7), *(_BYTE *)(v49 - 7) != *(_BYTE *)(v48 - 7))
          && (v88 = v87 < 0, LOBYTE(v88) = v87 > 0, (v8 = 2 * v88 - 1) != 0)
          || (v89 = *(_BYTE *)(v49 - 6) - *(_BYTE *)(v48 - 6), *(_BYTE *)(v49 - 6) != *(_BYTE *)(v48 - 6))
          && (v90 = v89 < 0, LOBYTE(v90) = v89 > 0, (v8 = 2 * v90 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 5) - *(_BYTE *)(v48 - 5);
        if ( *(_BYTE *)(v49 - 5) != *(_BYTE *)(v48 - 5) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        goto LABEL_163;
      return v8;
    case 4u:
LABEL_163:
      v91 = *(_DWORD *)(v49 - 4);
      if ( v91 == *(_DWORD *)(v48 - 4) )
      {
        v8 = 0;
      }
      else
      {
        v92 = (unsigned __int8)v91 - *(_BYTE *)(v48 - 4);
        if ( (unsigned __int8)v91 != *(_BYTE *)(v48 - 4)
          && (v93 = v92 < 0, LOBYTE(v93) = v92 > 0, (v8 = 2 * v93 - 1) != 0)
          || (v94 = *(_BYTE *)(v49 - 3) - *(_BYTE *)(v48 - 3), *(_BYTE *)(v49 - 3) != *(_BYTE *)(v48 - 3))
          && (v95 = v94 < 0, LOBYTE(v95) = v94 > 0, (v8 = 2 * v95 - 1) != 0)
          || (v96 = *(_BYTE *)(v49 - 2) - *(_BYTE *)(v48 - 2), *(_BYTE *)(v49 - 2) != *(_BYTE *)(v48 - 2))
          && (v97 = v96 < 0, LOBYTE(v97) = v96 > 0, (v8 = 2 * v97 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 1) - *(_BYTE *)(v48 - 1);
        if ( *(_BYTE *)(v49 - 1) != *(_BYTE *)(v48 - 1) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        return 0;
      return v8;
    default:
      return 0;
    case 0x1Du:
      v99 = *(_DWORD *)(v49 - 29);
      if ( v99 == *(_DWORD *)(v48 - 29) )
      {
        v8 = 0;
      }
      else
      {
        v100 = (unsigned __int8)v99 - *(_BYTE *)(v48 - 29);
        if ( (unsigned __int8)v99 != *(_BYTE *)(v48 - 29)
          && (v101 = v100 < 0, LOBYTE(v101) = v100 > 0, (v8 = 2 * v101 - 1) != 0)
          || (v102 = *(_BYTE *)(v49 - 28) - *(_BYTE *)(v48 - 28), *(_BYTE *)(v49 - 28) != *(_BYTE *)(v48 - 28))
          && (v103 = v102 < 0, LOBYTE(v103) = v102 > 0, (v8 = 2 * v103 - 1) != 0)
          || (v104 = *(_BYTE *)(v49 - 27) - *(_BYTE *)(v48 - 27), *(_BYTE *)(v49 - 27) != *(_BYTE *)(v48 - 27))
          && (v105 = v104 < 0, LOBYTE(v105) = v104 > 0, (v8 = 2 * v105 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 26) - *(_BYTE *)(v48 - 26);
        if ( *(_BYTE *)(v49 - 26) != *(_BYTE *)(v48 - 26) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_187:
      v106 = *(_DWORD *)(v49 - 25);
      if ( v106 == *(_DWORD *)(v48 - 25) )
      {
        v8 = 0;
      }
      else
      {
        v107 = (unsigned __int8)v106 - *(_BYTE *)(v48 - 25);
        if ( (unsigned __int8)v106 != *(_BYTE *)(v48 - 25)
          && (v108 = v107 < 0, LOBYTE(v108) = v107 > 0, (v8 = 2 * v108 - 1) != 0)
          || (v109 = *(_BYTE *)(v49 - 24) - *(_BYTE *)(v48 - 24), *(_BYTE *)(v49 - 24) != *(_BYTE *)(v48 - 24))
          && (v110 = v109 < 0, LOBYTE(v110) = v109 > 0, (v8 = 2 * v110 - 1) != 0)
          || (v111 = *(_BYTE *)(v49 - 23) - *(_BYTE *)(v48 - 23), *(_BYTE *)(v49 - 23) != *(_BYTE *)(v48 - 23))
          && (v112 = v111 < 0, LOBYTE(v112) = v111 > 0, (v8 = 2 * v112 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 22) - *(_BYTE *)(v48 - 22);
        if ( *(_BYTE *)(v49 - 22) != *(_BYTE *)(v48 - 22) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_198:
      v113 = *(_DWORD *)(v49 - 21);
      if ( v113 == *(_DWORD *)(v48 - 21) )
      {
        v8 = 0;
      }
      else
      {
        v114 = (unsigned __int8)v113 - *(_BYTE *)(v48 - 21);
        if ( (unsigned __int8)v113 != *(_BYTE *)(v48 - 21)
          && (v115 = v114 < 0, LOBYTE(v115) = v114 > 0, (v8 = 2 * v115 - 1) != 0)
          || (v116 = *(_BYTE *)(v49 - 20) - *(_BYTE *)(v48 - 20), *(_BYTE *)(v49 - 20) != *(_BYTE *)(v48 - 20))
          && (v117 = v116 < 0, LOBYTE(v117) = v116 > 0, (v8 = 2 * v117 - 1) != 0)
          || (v118 = *(_BYTE *)(v49 - 19) - *(_BYTE *)(v48 - 19), *(_BYTE *)(v49 - 19) != *(_BYTE *)(v48 - 19))
          && (v119 = v118 < 0, LOBYTE(v119) = v118 > 0, (v8 = 2 * v119 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 18) - *(_BYTE *)(v48 - 18);
        if ( *(_BYTE *)(v49 - 18) != *(_BYTE *)(v48 - 18) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_209:
      v120 = *(_DWORD *)(v49 - 17);
      if ( v120 == *(_DWORD *)(v48 - 17) )
      {
        v8 = 0;
      }
      else
      {
        v121 = (unsigned __int8)v120 - *(_BYTE *)(v48 - 17);
        if ( (unsigned __int8)v120 != *(_BYTE *)(v48 - 17)
          && (v122 = v121 < 0, LOBYTE(v122) = v121 > 0, (v8 = 2 * v122 - 1) != 0)
          || (v123 = *(_BYTE *)(v49 - 16) - *(_BYTE *)(v48 - 16), *(_BYTE *)(v49 - 16) != *(_BYTE *)(v48 - 16))
          && (v124 = v123 < 0, LOBYTE(v124) = v123 > 0, (v8 = 2 * v124 - 1) != 0)
          || (v125 = *(_BYTE *)(v49 - 15) - *(_BYTE *)(v48 - 15), *(_BYTE *)(v49 - 15) != *(_BYTE *)(v48 - 15))
          && (v126 = v125 < 0, LOBYTE(v126) = v125 > 0, (v8 = 2 * v126 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 14) - *(_BYTE *)(v48 - 14);
        if ( *(_BYTE *)(v49 - 14) != *(_BYTE *)(v48 - 14) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_220:
      v127 = *(_DWORD *)(v49 - 13);
      if ( v127 == *(_DWORD *)(v48 - 13) )
      {
        v8 = 0;
      }
      else
      {
        v128 = (unsigned __int8)v127 - *(_BYTE *)(v48 - 13);
        if ( (unsigned __int8)v127 != *(_BYTE *)(v48 - 13)
          && (v129 = v128 < 0, LOBYTE(v129) = v128 > 0, (v8 = 2 * v129 - 1) != 0)
          || (v130 = *(_BYTE *)(v49 - 12) - *(_BYTE *)(v48 - 12), *(_BYTE *)(v49 - 12) != *(_BYTE *)(v48 - 12))
          && (v131 = v130 < 0, LOBYTE(v131) = v130 > 0, (v8 = 2 * v131 - 1) != 0)
          || (v132 = *(_BYTE *)(v49 - 11) - *(_BYTE *)(v48 - 11), *(_BYTE *)(v49 - 11) != *(_BYTE *)(v48 - 11))
          && (v133 = v132 < 0, LOBYTE(v133) = v132 > 0, (v8 = 2 * v133 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 10) - *(_BYTE *)(v48 - 10);
        if ( *(_BYTE *)(v49 - 10) != *(_BYTE *)(v48 - 10) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_231:
      if ( *(_DWORD *)(v49 - 9) == *(_DWORD *)(v48 - 9) )
      {
        v8 = 0;
      }
      else
      {
        v134 = *(_BYTE *)(v49 - 9) - *(_BYTE *)(v48 - 9);
        if ( *(_BYTE *)(v49 - 9) != *(_BYTE *)(v48 - 9)
          && (v135 = v134 < 0, LOBYTE(v135) = v134 > 0, (v8 = 2 * v135 - 1) != 0)
          || (v136 = *(_BYTE *)(v49 - 8) - *(_BYTE *)(v48 - 8), *(_BYTE *)(v49 - 8) != *(_BYTE *)(v48 - 8))
          && (v137 = v136 < 0, LOBYTE(v137) = v136 > 0, (v8 = 2 * v137 - 1) != 0)
          || (v138 = *(_BYTE *)(v49 - 7) - *(_BYTE *)(v48 - 7), *(_BYTE *)(v49 - 7) != *(_BYTE *)(v48 - 7))
          && (v139 = v138 < 0, LOBYTE(v139) = v138 > 0, (v8 = 2 * v139 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 6) - *(_BYTE *)(v48 - 6);
        if ( *(_BYTE *)(v49 - 6) != *(_BYTE *)(v48 - 6) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_242:
      v140 = *(_DWORD *)(v49 - 5);
      if ( v140 == *(_DWORD *)(v48 - 5) )
      {
        v8 = 0;
        goto LABEL_252;
      }
      v141 = (unsigned __int8)v140 - *(_BYTE *)(v48 - 5);
      if ( (unsigned __int8)v140 == *(_BYTE *)(v48 - 5)
        || (v142 = v141 < 0, LOBYTE(v142) = v141 > 0, v8 = 2 * v142 - 1, !v8) )
      {
        v143 = *(_BYTE *)(v49 - 4) - *(_BYTE *)(v48 - 4);
        if ( *(_BYTE *)(v49 - 4) == *(_BYTE *)(v48 - 4)
          || (v144 = v143 < 0, LOBYTE(v144) = v143 > 0, v8 = 2 * v144 - 1, !v8) )
        {
          v145 = *(_BYTE *)(v49 - 3) - *(_BYTE *)(v48 - 3);
          if ( *(_BYTE *)(v49 - 3) == *(_BYTE *)(v48 - 3)
            || (v146 = v145 < 0, LOBYTE(v146) = v145 > 0, v8 = 2 * v146 - 1, !v8) )
          {
            v8 = *(_BYTE *)(v49 - 2) - *(_BYTE *)(v48 - 2);
            if ( *(_BYTE *)(v49 - 2) != *(_BYTE *)(v48 - 2) )
              v8 = 2 * (v8 > 0) - 1;
            goto LABEL_252;
          }
        }
      }
      return v8;
    case 0x19u:
      goto LABEL_187;
    case 0x15u:
      goto LABEL_198;
    case 0x11u:
      goto LABEL_209;
    case 0xDu:
      goto LABEL_220;
    case 9u:
      goto LABEL_231;
    case 5u:
      goto LABEL_242;
    case 1u:
      goto LABEL_253;
    case 0x1Eu:
      v147 = *(_DWORD *)(v49 - 30);
      if ( v147 == *(_DWORD *)(v48 - 30) )
      {
        v8 = 0;
      }
      else
      {
        v148 = (unsigned __int8)v147 - *(_BYTE *)(v48 - 30);
        if ( (unsigned __int8)v147 != *(_BYTE *)(v48 - 30)
          && (v149 = v148 < 0, LOBYTE(v149) = v148 > 0, (v8 = 2 * v149 - 1) != 0)
          || (v150 = *(_BYTE *)(v49 - 29) - *(_BYTE *)(v48 - 29), *(_BYTE *)(v49 - 29) != *(_BYTE *)(v48 - 29))
          && (v151 = v150 < 0, LOBYTE(v151) = v150 > 0, (v8 = 2 * v151 - 1) != 0)
          || (v152 = *(_BYTE *)(v49 - 28) - *(_BYTE *)(v48 - 28), *(_BYTE *)(v49 - 28) != *(_BYTE *)(v48 - 28))
          && (v153 = v152 < 0, LOBYTE(v153) = v152 > 0, (v8 = 2 * v153 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 27) - *(_BYTE *)(v48 - 27);
        if ( *(_BYTE *)(v49 - 27) != *(_BYTE *)(v48 - 27) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_266:
      v154 = *(_DWORD *)(v49 - 26);
      if ( v154 == *(_DWORD *)(v48 - 26) )
      {
        v8 = 0;
      }
      else
      {
        v155 = (unsigned __int8)v154 - *(_BYTE *)(v48 - 26);
        if ( (unsigned __int8)v154 != *(_BYTE *)(v48 - 26)
          && (v156 = v155 < 0, LOBYTE(v156) = v155 > 0, (v8 = 2 * v156 - 1) != 0)
          || (v157 = *(_BYTE *)(v49 - 25) - *(_BYTE *)(v48 - 25), *(_BYTE *)(v49 - 25) != *(_BYTE *)(v48 - 25))
          && (v158 = v157 < 0, LOBYTE(v158) = v157 > 0, (v8 = 2 * v158 - 1) != 0)
          || (v159 = *(_BYTE *)(v49 - 24) - *(_BYTE *)(v48 - 24), *(_BYTE *)(v49 - 24) != *(_BYTE *)(v48 - 24))
          && (v160 = v159 < 0, LOBYTE(v160) = v159 > 0, (v8 = 2 * v160 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 23) - *(_BYTE *)(v48 - 23);
        if ( *(_BYTE *)(v49 - 23) != *(_BYTE *)(v48 - 23) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_277:
      v161 = *(_DWORD *)(v49 - 22);
      if ( v161 == *(_DWORD *)(v48 - 22) )
      {
        v8 = 0;
      }
      else
      {
        v162 = (unsigned __int8)v161 - *(_BYTE *)(v48 - 22);
        if ( (unsigned __int8)v161 != *(_BYTE *)(v48 - 22)
          && (v163 = v162 < 0, LOBYTE(v163) = v162 > 0, (v8 = 2 * v163 - 1) != 0)
          || (v164 = *(_BYTE *)(v49 - 21) - *(_BYTE *)(v48 - 21), *(_BYTE *)(v49 - 21) != *(_BYTE *)(v48 - 21))
          && (v165 = v164 < 0, LOBYTE(v165) = v164 > 0, (v8 = 2 * v165 - 1) != 0)
          || (v166 = *(_BYTE *)(v49 - 20) - *(_BYTE *)(v48 - 20), *(_BYTE *)(v49 - 20) != *(_BYTE *)(v48 - 20))
          && (v167 = v166 < 0, LOBYTE(v167) = v166 > 0, (v8 = 2 * v167 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 19) - *(_BYTE *)(v48 - 19);
        if ( *(_BYTE *)(v49 - 19) != *(_BYTE *)(v48 - 19) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_288:
      v168 = *(_DWORD *)(v49 - 18);
      if ( v168 == *(_DWORD *)(v48 - 18) )
      {
        v8 = 0;
      }
      else
      {
        v169 = (unsigned __int8)v168 - *(_BYTE *)(v48 - 18);
        if ( (unsigned __int8)v168 != *(_BYTE *)(v48 - 18)
          && (v170 = v169 < 0, LOBYTE(v170) = v169 > 0, (v8 = 2 * v170 - 1) != 0)
          || (v171 = *(_BYTE *)(v49 - 17) - *(_BYTE *)(v48 - 17), *(_BYTE *)(v49 - 17) != *(_BYTE *)(v48 - 17))
          && (v172 = v171 < 0, LOBYTE(v172) = v171 > 0, (v8 = 2 * v172 - 1) != 0)
          || (v173 = *(_BYTE *)(v49 - 16) - *(_BYTE *)(v48 - 16), *(_BYTE *)(v49 - 16) != *(_BYTE *)(v48 - 16))
          && (v174 = v173 < 0, LOBYTE(v174) = v173 > 0, (v8 = 2 * v174 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 15) - *(_BYTE *)(v48 - 15);
        if ( *(_BYTE *)(v49 - 15) != *(_BYTE *)(v48 - 15) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_299:
      v175 = *(_DWORD *)(v49 - 14);
      if ( v175 == *(_DWORD *)(v48 - 14) )
      {
        v8 = 0;
      }
      else
      {
        v176 = (unsigned __int8)v175 - *(_BYTE *)(v48 - 14);
        if ( (unsigned __int8)v175 != *(_BYTE *)(v48 - 14)
          && (v177 = v176 < 0, LOBYTE(v177) = v176 > 0, (v8 = 2 * v177 - 1) != 0)
          || (v178 = *(_BYTE *)(v49 - 13) - *(_BYTE *)(v48 - 13), *(_BYTE *)(v49 - 13) != *(_BYTE *)(v48 - 13))
          && (v179 = v178 < 0, LOBYTE(v179) = v178 > 0, (v8 = 2 * v179 - 1) != 0)
          || (v180 = *(_BYTE *)(v49 - 12) - *(_BYTE *)(v48 - 12), *(_BYTE *)(v49 - 12) != *(_BYTE *)(v48 - 12))
          && (v181 = v180 < 0, LOBYTE(v181) = v180 > 0, (v8 = 2 * v181 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 11) - *(_BYTE *)(v48 - 11);
        if ( *(_BYTE *)(v49 - 11) != *(_BYTE *)(v48 - 11) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_310:
      if ( *(_DWORD *)(v49 - 10) == *(_DWORD *)(v48 - 10) )
      {
        v8 = 0;
      }
      else
      {
        v182 = *(_BYTE *)(v49 - 10) - *(_BYTE *)(v48 - 10);
        if ( *(_BYTE *)(v49 - 10) != *(_BYTE *)(v48 - 10)
          && (v183 = v182 < 0, LOBYTE(v183) = v182 > 0, (v8 = 2 * v183 - 1) != 0)
          || (v184 = *(_BYTE *)(v49 - 9) - *(_BYTE *)(v48 - 9), *(_BYTE *)(v49 - 9) != *(_BYTE *)(v48 - 9))
          && (v185 = v184 < 0, LOBYTE(v185) = v184 > 0, (v8 = 2 * v185 - 1) != 0)
          || (v186 = *(_BYTE *)(v49 - 8) - *(_BYTE *)(v48 - 8), *(_BYTE *)(v49 - 8) != *(_BYTE *)(v48 - 8))
          && (v187 = v186 < 0, LOBYTE(v187) = v186 > 0, (v8 = 2 * v187 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 7) - *(_BYTE *)(v48 - 7);
        if ( *(_BYTE *)(v49 - 7) != *(_BYTE *)(v48 - 7) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_321:
      v188 = *(_DWORD *)(v49 - 6);
      if ( v188 == *(_DWORD *)(v48 - 6) )
      {
        v8 = 0;
      }
      else
      {
        v189 = (unsigned __int8)v188 - *(_BYTE *)(v48 - 6);
        if ( (unsigned __int8)v188 != *(_BYTE *)(v48 - 6)
          && (v190 = v189 < 0, LOBYTE(v190) = v189 > 0, (v8 = 2 * v190 - 1) != 0)
          || (v191 = *(_BYTE *)(v49 - 5) - *(_BYTE *)(v48 - 5), *(_BYTE *)(v49 - 5) != *(_BYTE *)(v48 - 5))
          && (v192 = v191 < 0, LOBYTE(v192) = v191 > 0, (v8 = 2 * v192 - 1) != 0)
          || (v193 = *(_BYTE *)(v49 - 4) - *(_BYTE *)(v48 - 4), *(_BYTE *)(v49 - 4) != *(_BYTE *)(v48 - 4))
          && (v194 = v193 < 0, LOBYTE(v194) = v193 > 0, (v8 = 2 * v194 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 3) - *(_BYTE *)(v48 - 3);
        if ( *(_BYTE *)(v49 - 3) != *(_BYTE *)(v48 - 3) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_332:
      if ( *(_WORD *)(v49 - 2) == *(_WORD *)(v48 - 2) )
        return 0;
      goto LABEL_413;
    case 0x1Au:
      goto LABEL_266;
    case 0x16u:
      goto LABEL_277;
    case 0x12u:
      goto LABEL_288;
    case 0xEu:
      goto LABEL_299;
    case 0xAu:
      goto LABEL_310;
    case 6u:
      goto LABEL_321;
    case 2u:
      goto LABEL_332;
    case 0x1Fu:
      v195 = *(_DWORD *)(v49 - 31);
      if ( v195 == *(_DWORD *)(v48 - 31) )
      {
        v8 = 0;
      }
      else
      {
        v196 = (unsigned __int8)v195 - *(_BYTE *)(v48 - 31);
        if ( (unsigned __int8)v195 != *(_BYTE *)(v48 - 31)
          && (v197 = v196 < 0, LOBYTE(v197) = v196 > 0, (v8 = 2 * v197 - 1) != 0)
          || (v198 = *(_BYTE *)(v49 - 30) - *(_BYTE *)(v48 - 30), *(_BYTE *)(v49 - 30) != *(_BYTE *)(v48 - 30))
          && (v199 = v198 < 0, LOBYTE(v199) = v198 > 0, (v8 = 2 * v199 - 1) != 0)
          || (v200 = *(_BYTE *)(v49 - 29) - *(_BYTE *)(v48 - 29), *(_BYTE *)(v49 - 29) != *(_BYTE *)(v48 - 29))
          && (v201 = v200 < 0, LOBYTE(v201) = v200 > 0, (v8 = 2 * v201 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 28) - *(_BYTE *)(v48 - 28);
        if ( *(_BYTE *)(v49 - 28) != *(_BYTE *)(v48 - 28) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_345:
      v202 = *(_DWORD *)(v49 - 27);
      if ( v202 == *(_DWORD *)(v48 - 27) )
      {
        v8 = 0;
      }
      else
      {
        v203 = (unsigned __int8)v202 - *(_BYTE *)(v48 - 27);
        if ( (unsigned __int8)v202 != *(_BYTE *)(v48 - 27)
          && (v204 = v203 < 0, LOBYTE(v204) = v203 > 0, (v8 = 2 * v204 - 1) != 0)
          || (v205 = *(_BYTE *)(v49 - 26) - *(_BYTE *)(v48 - 26), *(_BYTE *)(v49 - 26) != *(_BYTE *)(v48 - 26))
          && (v206 = v205 < 0, LOBYTE(v206) = v205 > 0, (v8 = 2 * v206 - 1) != 0)
          || (v207 = *(_BYTE *)(v49 - 25) - *(_BYTE *)(v48 - 25), *(_BYTE *)(v49 - 25) != *(_BYTE *)(v48 - 25))
          && (v208 = v207 < 0, LOBYTE(v208) = v207 > 0, (v8 = 2 * v208 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 24) - *(_BYTE *)(v48 - 24);
        if ( *(_BYTE *)(v49 - 24) != *(_BYTE *)(v48 - 24) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_356:
      v209 = *(_DWORD *)(v49 - 23);
      if ( v209 == *(_DWORD *)(v48 - 23) )
      {
        v8 = 0;
      }
      else
      {
        v210 = (unsigned __int8)v209 - *(_BYTE *)(v48 - 23);
        if ( (unsigned __int8)v209 != *(_BYTE *)(v48 - 23)
          && (v211 = v210 < 0, LOBYTE(v211) = v210 > 0, (v8 = 2 * v211 - 1) != 0)
          || (v212 = *(_BYTE *)(v49 - 22) - *(_BYTE *)(v48 - 22), *(_BYTE *)(v49 - 22) != *(_BYTE *)(v48 - 22))
          && (v213 = v212 < 0, LOBYTE(v213) = v212 > 0, (v8 = 2 * v213 - 1) != 0)
          || (v214 = *(_BYTE *)(v49 - 21) - *(_BYTE *)(v48 - 21), *(_BYTE *)(v49 - 21) != *(_BYTE *)(v48 - 21))
          && (v215 = v214 < 0, LOBYTE(v215) = v214 > 0, (v8 = 2 * v215 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 20) - *(_BYTE *)(v48 - 20);
        if ( *(_BYTE *)(v49 - 20) != *(_BYTE *)(v48 - 20) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_367:
      v216 = *(_DWORD *)(v49 - 19);
      if ( v216 == *(_DWORD *)(v48 - 19) )
      {
        v8 = 0;
      }
      else
      {
        v217 = (unsigned __int8)v216 - *(_BYTE *)(v48 - 19);
        if ( (unsigned __int8)v216 != *(_BYTE *)(v48 - 19)
          && (v218 = v217 < 0, LOBYTE(v218) = v217 > 0, (v8 = 2 * v218 - 1) != 0)
          || (v219 = *(_BYTE *)(v49 - 18) - *(_BYTE *)(v48 - 18), *(_BYTE *)(v49 - 18) != *(_BYTE *)(v48 - 18))
          && (v220 = v219 < 0, LOBYTE(v220) = v219 > 0, (v8 = 2 * v220 - 1) != 0)
          || (v221 = *(_BYTE *)(v49 - 17) - *(_BYTE *)(v48 - 17), *(_BYTE *)(v49 - 17) != *(_BYTE *)(v48 - 17))
          && (v222 = v221 < 0, LOBYTE(v222) = v221 > 0, (v8 = 2 * v222 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 16) - *(_BYTE *)(v48 - 16);
        if ( *(_BYTE *)(v49 - 16) != *(_BYTE *)(v48 - 16) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_378:
      if ( *(_DWORD *)(v49 - 15) == *(_DWORD *)(v48 - 15) )
      {
        v8 = 0;
      }
      else
      {
        v223 = *(_BYTE *)(v49 - 15) - *(_BYTE *)(v48 - 15);
        if ( *(_BYTE *)(v49 - 15) != *(_BYTE *)(v48 - 15)
          && (v224 = v223 < 0, LOBYTE(v224) = v223 > 0, (v8 = 2 * v224 - 1) != 0)
          || (v225 = *(_BYTE *)(v49 - 14) - *(_BYTE *)(v48 - 14), *(_BYTE *)(v49 - 14) != *(_BYTE *)(v48 - 14))
          && (v226 = v225 < 0, LOBYTE(v226) = v225 > 0, (v8 = 2 * v226 - 1) != 0)
          || (v227 = *(_BYTE *)(v49 - 13) - *(_BYTE *)(v48 - 13), *(_BYTE *)(v49 - 13) != *(_BYTE *)(v48 - 13))
          && (v228 = v227 < 0, LOBYTE(v228) = v227 > 0, (v8 = 2 * v228 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 12) - *(_BYTE *)(v48 - 12);
        if ( *(_BYTE *)(v49 - 12) != *(_BYTE *)(v48 - 12) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_389:
      v229 = *(_DWORD *)(v49 - 11);
      if ( v229 == *(_DWORD *)(v48 - 11) )
      {
        v8 = 0;
      }
      else
      {
        v230 = (unsigned __int8)v229 - *(_BYTE *)(v48 - 11);
        if ( (unsigned __int8)v229 != *(_BYTE *)(v48 - 11)
          && (v231 = v230 < 0, LOBYTE(v231) = v230 > 0, (v8 = 2 * v231 - 1) != 0)
          || (v232 = *(_BYTE *)(v49 - 10) - *(_BYTE *)(v48 - 10), *(_BYTE *)(v49 - 10) != *(_BYTE *)(v48 - 10))
          && (v233 = v232 < 0, LOBYTE(v233) = v232 > 0, (v8 = 2 * v233 - 1) != 0)
          || (v234 = *(_BYTE *)(v49 - 9) - *(_BYTE *)(v48 - 9), *(_BYTE *)(v49 - 9) != *(_BYTE *)(v48 - 9))
          && (v235 = v234 < 0, LOBYTE(v235) = v234 > 0, (v8 = 2 * v235 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 8) - *(_BYTE *)(v48 - 8);
        if ( *(_BYTE *)(v49 - 8) != *(_BYTE *)(v48 - 8) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_400:
      v236 = *(_DWORD *)(v49 - 7);
      if ( v236 == *(_DWORD *)(v48 - 7) )
      {
        v8 = 0;
      }
      else
      {
        v237 = (unsigned __int8)v236 - *(_BYTE *)(v48 - 7);
        if ( (unsigned __int8)v236 != *(_BYTE *)(v48 - 7)
          && (v238 = v237 < 0, LOBYTE(v238) = v237 > 0, (v8 = 2 * v238 - 1) != 0)
          || (v239 = *(_BYTE *)(v49 - 6) - *(_BYTE *)(v48 - 6), *(_BYTE *)(v49 - 6) != *(_BYTE *)(v48 - 6))
          && (v240 = v239 < 0, LOBYTE(v240) = v239 > 0, (v8 = 2 * v240 - 1) != 0)
          || (v241 = *(_BYTE *)(v49 - 5) - *(_BYTE *)(v48 - 5), *(_BYTE *)(v49 - 5) != *(_BYTE *)(v48 - 5))
          && (v242 = v241 < 0, LOBYTE(v242) = v241 > 0, (v8 = 2 * v242 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 4) - *(_BYTE *)(v48 - 4);
        if ( *(_BYTE *)(v49 - 4) != *(_BYTE *)(v48 - 4) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
      {
LABEL_411:
        v243 = *(_BYTE *)(v49 - 3) - *(_BYTE *)(v48 - 3);
        if ( *(_BYTE *)(v49 - 3) == *(_BYTE *)(v48 - 3)
          || (v244 = v243 < 0, LOBYTE(v244) = v243 > 0, v8 = 2 * v244 - 1, !v8) )
        {
LABEL_413:
          v245 = *(_BYTE *)(v49 - 2) - *(_BYTE *)(v48 - 2);
          if ( *(_BYTE *)(v49 - 2) == *(_BYTE *)(v48 - 2) )
            goto LABEL_253;
          v246 = v245 < 0;
          LOBYTE(v246) = v245 > 0;
          v8 = 2 * v246 - 1;
LABEL_252:
          if ( !v8 )
          {
LABEL_253:
            v8 = *(_BYTE *)(v49 - 1) - *(_BYTE *)(v48 - 1);
            if ( *(_BYTE *)(v49 - 1) != *(_BYTE *)(v48 - 1) )
              v8 = 2 * (v8 > 0) - 1;
          }
        }
      }
      break;
    case 0x1Bu:
      goto LABEL_345;
    case 0x17u:
      goto LABEL_356;
    case 0x13u:
      goto LABEL_367;
    case 0xFu:
      goto LABEL_378;
    case 0xBu:
      goto LABEL_389;
    case 7u:
      goto LABEL_400;
    case 3u:
      goto LABEL_411;
  }
  return v8;
}

//----- (1003097C) --------------------------------------------------------
int __cdecl sub_1003097C(int a1, int a2, DWORD dwCmpFlags, int a4, int a5, int a6, int a7, UINT CodePage)
{
  int v8; // ecx@1
  int v9; // esi@1
  int v10; // eax@2
  signed int v11; // edi@3
  UINT v13; // eax@8
  int v14; // ebx@8
  char *v15; // eax@22
  unsigned __int8 v16; // cl@23
  char *v17; // eax@30
  unsigned __int8 v18; // cl@31
  unsigned int v19; // eax@36
  int v20; // ecx@36
  int v21; // ecx@39
  int v22; // eax@42
  int v23; // eax@48
  int v24; // ecx@48
  int v25; // ecx@51
  int v26; // esi@52
  int v27; // eax@54
  char v29; // [sp+0h] [bp-38h]@40
  int v30; // [sp+Ch] [bp-2Ch]@1
  int v31; // [sp+10h] [bp-28h]@8
  const CHAR *v32; // [sp+14h] [bp-24h]@1
  int cchCount1; // [sp+18h] [bp-20h]@1
  LPCSTR cchWideChar; // [sp+1Ch] [bp-1Ch]@1
  struct _cpinfo CPInfo; // [sp+20h] [bp-18h]@19
  unsigned int v36; // [sp+34h] [bp-4h]@1
  int v37; // [sp+38h] [bp+0h]@1

  v36 = (unsigned int)&v37 ^ __security_cookie;
  v8 = a6;
  cchCount1 = a1;
  v9 = a5;
  v30 = a2;
  cchWideChar = (LPCSTR)a4;
  v32 = (const CHAR *)a6;
  if ( a5 <= 0 )
  {
    if ( a5 < -1 )
      return 0;
  }
  else
  {
    v10 = sub_10030BE7(a4, a5);
    v8 = (int)v32;
    v9 = v10;
  }
  v11 = a7;
  if ( a7 <= 0 )
  {
    if ( a7 < -1 )
      return 0;
  }
  else
  {
    v11 = sub_10030BE7(v8, a7);
  }
  v13 = CodePage;
  v14 = 0;
  v31 = 0;
  if ( !CodePage )
  {
    v13 = *(_DWORD *)(*(_DWORD *)cchCount1 + 4);
    CodePage = *(_DWORD *)(*(_DWORD *)cchCount1 + 4);
  }
  if ( v9 && v11 )
    goto LABEL_36;
  if ( v9 == v11 )
    return 2;
  if ( v11 > 1 )
    return 1;
  if ( v9 > 1 )
    return 3;
  if ( !GetCPInfo(v13, &CPInfo) )
    return 0;
  if ( v9 > 0 )
  {
    if ( (_DWORD)CPInfo.MaxCharSize >= 2u )
    {
      v15 = (char *)CPInfo.LeadByte;
      if ( CPInfo.LeadByte[0] )
      {
        while ( 1 )
        {
          v16 = v15[1];
          if ( !v16 )
            break;
          if ( *cchWideChar >= (unsigned __int8)*v15 && *cchWideChar <= v16 )
            return 2;
          v15 += 2;
          if ( !*v15 )
            return 3;
        }
      }
    }
    return 3;
  }
  if ( v11 > 0 )
  {
    if ( (_DWORD)CPInfo.MaxCharSize >= 2u )
    {
      v17 = (char *)CPInfo.LeadByte;
      if ( CPInfo.LeadByte[0] )
      {
        do
        {
          v18 = v17[1];
          if ( !v18 )
            break;
          if ( *v32 >= (unsigned __int8)*v17 && *v32 <= v18 )
            return 2;
          v17 += 2;
        }
        while ( *v17 );
      }
    }
    return 1;
  }
LABEL_36:
  v19 = MultiByteToWideChar(CodePage, 9u, cchWideChar, v9, 0, 0);
  v20 = v19;
  cchCount1 = v19;
  if ( !v19 )
    return 0;
  if ( (signed int)v19 > 0 && 0xFFFFFFE0 / v19 >= 2 )
  {
    v21 = 2 * v19 + 8;
    if ( (unsigned int)v21 > 0x400 )
    {
      v22 = sub_10028264(0xFFFFFFE0 % v19, v21, 0, v11, v21);
      v14 = v22;
      if ( v22 )
      {
        *(_DWORD *)v22 = 56797;
        goto LABEL_44;
      }
    }
    else
    {
      sub_10031E40(v21, v21, v29);
      v14 = (int)&v29;
      if ( &v29 )
      {
        *(_DWORD *)&v29 = 52428;
LABEL_44:
        v14 += 8;
        goto LABEL_45;
      }
    }
LABEL_45:
    v20 = cchCount1;
  }
  if ( !v14 )
    return 0;
  if ( !MultiByteToWideChar(CodePage, 1u, cchWideChar, v9, (LPWSTR)v14, v20)
    || (v23 = MultiByteToWideChar(CodePage, 9u, v32, v11, 0, 0), v24 = v23, cchWideChar = (LPCSTR)v23, !v23) )
    goto LABEL_63;
  if ( v23 > 0 && 0xFFFFFFE0u / v23 >= 2 )
  {
    v25 = 2 * v23 + 8;
    if ( (unsigned int)v25 > 0x400 )
    {
      v27 = sub_10028264(0xFFFFFFE0u % v23, v25, v14, v11, v25);
      v26 = v27;
      if ( v27 )
      {
        *(_DWORD *)v27 = 56797;
        goto LABEL_56;
      }
    }
    else
    {
      sub_10031E40(v25, v25, v29);
      v26 = (int)&v29;
      if ( &v29 )
      {
        *(_DWORD *)&v29 = 52428;
LABEL_56:
        v26 += 8;
        goto LABEL_57;
      }
    }
LABEL_57:
    v24 = (int)cchWideChar;
    goto LABEL_59;
  }
  v26 = 0;
LABEL_59:
  if ( v26 )
  {
    if ( MultiByteToWideChar(CodePage, 1u, v32, v11, (LPWSTR)v26, v24) )
      v31 = sub_100316FB(v30, dwCmpFlags, (PCNZWCH)v14, cchCount1, (PCNZWCH)v26, (int)cchWideChar);
    sub_1002563B(v14, v26);
  }
LABEL_63:
  sub_1002563B(v14, v14);
  return v31;
}
// 10067210: using guessed type int __security_cookie;

//----- (10030BE7) --------------------------------------------------------
int __cdecl sub_10030BE7(int a1, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1

  v2 = a1;
  v3 = a2;
  if ( a2 )
  {
    while ( 1 )
    {
      --v3;
      if ( !*(_BYTE *)v2 )
        break;
      ++v2;
      if ( !v3 )
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    --v3;
  }
  return a2 - v3 - 1;
}

//----- (10030C07) --------------------------------------------------------
int __usercall sub_10030C07<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, DWORD dwCmpFlags, int a6, int a7, int a8, int a9, UINT CodePage)
{
  int result; // eax@1
  int v11; // [sp+0h] [bp-10h]@1
  int v12; // [sp+8h] [bp-8h]@2
  char v13; // [sp+Ch] [bp-4h]@1

  sub_1002E635((int)&v11, a1, a2, a3);
  result = sub_1003097C((int)&v11, a4, dwCmpFlags, a6, a7, a8, a9, CodePage);
  if ( v13 )
    *(_DWORD *)(v12 + 112) &= 0xFFFFFFFDu;
  return result;
}

//----- (10030C50) --------------------------------------------------------
int __stdcall sub_10030C50(unsigned __int64 a1, __int64 a2)
{
  int v2; // esi@2
  unsigned __int64 v3; // qtt@2
  unsigned __int64 v4; // qax@3
  unsigned int v5; // ecx@3
  unsigned int v6; // ebx@3
  char v7; // cf@4
  char v8; // cf@4
  int v9; // eax@5
  unsigned __int64 v10; // qax@5
  int v11; // ecx@5
  char v12; // cf@5

  if ( HIDWORD(a2) )
  {
    v5 = HIDWORD(a2);
    v6 = a2;
    v4 = a1;
    do
    {
      v7 = v5 & 1;
      v5 >>= 1;
      v6 = __RCR__(v6, v7);
      v8 = BYTE4(v4) & 1;
      HIDWORD(v4) >>= 1;
      LODWORD(v4) = __RCR__(v4, v8);
    }
    while ( v5 );
    v9 = v4 / v6;
    v2 = v9;
    v11 = HIDWORD(a2) * v9;
    v10 = v9 * (unsigned int)a2;
    v12 = v11 >= (unsigned int)-HIDWORD(v10);
    HIDWORD(v10) += v11;
    if ( v12 || HIDWORD(v10) > HIDWORD(a1) || v10 > a1 )
      --v2;
  }
  else
  {
    LODWORD(v3) = a1;
    HIDWORD(v3) = HIDWORD(a1) % (_DWORD)a2;
    v2 = v3 / (unsigned int)a2;
  }
  return v2;
}

//----- (10030CF0) --------------------------------------------------------
void *__cdecl sub_10030CF0(void *a1, unsigned __int8 a2, signed int a3)
{
  signed int v9; // ecx@3
  void *v10; // edi@3
  int v11; // edx@7
  void *v16; // edi@9
  int v17; // ecx@10
  unsigned int v18; // ecx@13
  unsigned int v19; // ecx@13
  void *result; // eax@16
  int v21; // edx@22
  unsigned int k; // ebx@22
  unsigned int v23; // ebx@22
  unsigned int l; // ebx@25
  int v25; // edx@27
  unsigned int m; // edx@28
  char v27; // bl@28
  int n; // ebx@30
  int i; // edx@33
  unsigned int v30; // ebx@33
  unsigned int j; // ebx@35
  int v32; // [sp-Ch] [bp-Ch]@33

  _ECX = a1;
  if ( a3 )
  {
    _EAX = a2;
    __asm { bt      dword_100695C4, 1 }
    if ( _CF )
    {
      v9 = a3;
      v10 = a1;
      while ( v9 )
      {
        *(_BYTE *)v10 = _EAX;
        v10 = (char *)v10 + 1;
        --v9;
      }
      return a1;
    }
    v11 = a3;
    if ( a3 < 128 )
      goto LABEL_40;
    __asm { bt      dword_10067250, 1 }
    if ( !_CF )
    {
LABEL_40:
      v16 = a1;
      if ( (unsigned int)a3 < 4 )
        goto LABEL_41;
      v17 = -(signed int)a1 & 3;
      if ( v17 )
      {
        v11 = a3 - v17;
        do
        {
          *(_BYTE *)v16 = _EAX;
          v16 = (char *)v16 + 1;
          --v17;
        }
        while ( v17 );
      }
      _EAX = 16843009 * a2;
      v19 = v11;
      v11 &= 3u;
      v18 = v19 >> 2;
      if ( !v18 || (memset(v16, _EAX, 4 * v18), v16 = (char *)v16 + 4 * v18, v11) )
      {
LABEL_41:
        do
        {
          *(_BYTE *)v16 = _EAX;
          v16 = (char *)v16 + 1;
          --v11;
        }
        while ( v11 );
      }
      return a1;
    }
    if ( a2 )
    {
      __asm
      {
        movd    xmm0, eax
        punpcklbw xmm0, xmm0
        punpcklwd xmm0, xmm0
        pshufd  xmm0, xmm0, 0
      }
    }
    else
    {
      __asm { pxor    xmm0, xmm0 }
    }
    if ( (_BYTE)a1 & 0xF )
    {
      v30 = 16 - ((_BYTE)a1 & 0xF);
      v32 = a3 - v30;
      for ( i = v30 & 3; i; --i )
      {
        *(_BYTE *)_ECX = _EAX;
        _ECX = (char *)_ECX + 1;
      }
      for ( j = v30 >> 2; j; --j )
      {
        __asm { movd    dword ptr [ecx], xmm0 }
        _ECX = (char *)_ECX + 4;
      }
      v11 = v32;
    }
    v23 = v11;
    v21 = v11 & 0x7F;
    for ( k = v23 >> 7; k; --k )
    {
      __asm
      {
        movdqa  xmmword ptr [ecx], xmm0
        movdqa  xmmword ptr [ecx+10h], xmm0
        movdqa  xmmword ptr [ecx+20h], xmm0
        movdqa  xmmword ptr [ecx+30h], xmm0
        movdqa  xmmword ptr [ecx+40h], xmm0
        movdqa  xmmword ptr [ecx+50h], xmm0
        movdqa  xmmword ptr [ecx+60h], xmm0
        movdqa  xmmword ptr [ecx+70h], xmm0
      }
      _ECX = (char *)_ECX + 128;
    }
    if ( v21 )
    {
      for ( l = (unsigned int)v21 >> 4; l; --l )
      {
        __asm { movdqa  xmmword ptr [ecx], xmm0 }
        _ECX = (char *)_ECX + 16;
      }
      v25 = v21 & 0xF;
      if ( v25 )
      {
        v27 = v25;
        for ( m = (unsigned int)v25 >> 2; m; --m )
        {
          __asm { movd    dword ptr [ecx], xmm0 }
          _ECX = (char *)_ECX + 4;
        }
        for ( n = v27 & 3; n; --n )
        {
          *(_BYTE *)_ECX = _EAX;
          _ECX = (char *)_ECX + 1;
        }
      }
    }
    result = a1;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10030D80) --------------------------------------------------------
int __cdecl sub_10030D80(int a1, int a2)
{
  int result; // eax@1

  result = dword_10067220;
  dword_10067220 = a2 & a1 | dword_10067220 & ~a2;
  return result;
}
// 10067220: using guessed type int dword_10067220;

//----- (10030DF0) --------------------------------------------------------
int __cdecl sub_10030DF0(int a1, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  unsigned __int8 v4; // cf@2
  unsigned int v5; // eax@2
  unsigned int v6; // eax@6
  __int16 v8; // ax@16

  v2 = a1;
  v3 = a2;
  if ( !(a1 & 3) )
  {
LABEL_2:
    while ( 1 )
    {
      v5 = *(_DWORD *)v2;
      v4 = (unsigned __int8)*(_DWORD *)v2 < *(_BYTE *)v3;
      if ( (unsigned __int8)*(_DWORD *)v2 != *(_BYTE *)v3 )
        break;
      if ( !(_BYTE)v5 )
        return 0;
      v4 = BYTE1(v5) < *(_BYTE *)(v3 + 1);
      if ( BYTE1(v5) != *(_BYTE *)(v3 + 1) )
        break;
      if ( !BYTE1(v5) )
        return 0;
      v6 = v5 >> 16;
      v4 = (_BYTE)v6 < *(_BYTE *)(v3 + 2);
      if ( (_BYTE)v6 != *(_BYTE *)(v3 + 2) )
        break;
      if ( !(_BYTE)v6 )
        return 0;
      v4 = BYTE1(v6) < *(_BYTE *)(v3 + 3);
      if ( BYTE1(v6) != *(_BYTE *)(v3 + 3) )
        break;
      v3 += 4;
      v2 += 4;
      if ( !BYTE1(v6) )
        return 0;
    }
    return -v4 | 1;
  }
  if ( a1 & 1 )
  {
    v2 = a1 + 1;
    v4 = *(_BYTE *)a1 < *(_BYTE *)a2;
    if ( *(_BYTE *)a1 != *(_BYTE *)a2 )
      return -v4 | 1;
    v3 = a2 + 1;
    if ( !*(_BYTE *)a1 )
      return 0;
    if ( !(v2 & 2) )
      goto LABEL_2;
  }
  v8 = *(_WORD *)v2;
  v2 += 2;
  v4 = (_BYTE)v8 < *(_BYTE *)v3;
  if ( (_BYTE)v8 != *(_BYTE *)v3 )
    return -v4 | 1;
  if ( !(_BYTE)v8 )
    return 0;
  v4 = HIBYTE(v8) < *(_BYTE *)(v3 + 1);
  if ( HIBYTE(v8) == *(_BYTE *)(v3 + 1) )
  {
    if ( HIBYTE(v8) )
    {
      v3 += 2;
      goto LABEL_2;
    }
    return 0;
  }
  return -v4 | 1;
}

//----- (10030E7C) --------------------------------------------------------
signed int (__usercall *__usercall sub_10030E7C<eax>(int a1<ebx>, int a2<edi>, int a3))<eax>(int<edi>, int, int, unsigned int, int, int, int)
{
  signed int (__usercall *result)<eax>(int<edi>, int, int, unsigned int, int, int, int); // eax@1

  result = sub_10030E93();
  if ( a3 )
    result = (signed int (__usercall *)<eax>(int<edi>, int, int, unsigned int, int, int, int))sub_10041B95(a1, a2);
  __asm { fnclex }
  return result;
}

//----- (10030E93) --------------------------------------------------------
signed int (__usercall *__cdecl sub_10030E93())<eax>(int<edi>, int, int, unsigned int, int, int, int)
{
  signed int (__usercall *result)<eax>(int<edi>, int, int, unsigned int, int, int, int); // eax@1

  result = sub_10041109;
  off_100680A4[0] = (int (*)())sub_10041109;
  off_100680A8[0] = (int (*)())sub_100419E9;
  off_100680AC[0] = (int (*)())sub_10041A78;
  off_100680B0[0] = (int (*)())sub_10041AD0;
  off_100680B4[0] = (int (*)())sub_10041B53;
  off_100680B8[0] = (int (*)())sub_10041109;
  off_100680BC = sub_1004112A;
  off_100680C0 = sub_10041A90;
  off_100680C4 = sub_100419FA;
  off_100680C8 = sub_10041AE1;
  return result;
}
// 100680A4: using guessed type int (*off_100680A4[10])();
// 100680A8: using guessed type int (*off_100680A8[9])();
// 100680AC: using guessed type int (*off_100680AC[8])();
// 100680B0: using guessed type int (*off_100680B0[7])();
// 100680B4: using guessed type int (*off_100680B4[6])();
// 100680B8: using guessed type int (*off_100680B8[5])();

//----- (10030EF3) --------------------------------------------------------
int __cdecl sub_10030EF3(int a1)
{
  int result; // eax@1

  result = __security_cookie ^ dword_1006B3E8;
  if ( __security_cookie != dword_1006B3E8 )
    result = ((int (__stdcall *)(int))result)(a1);
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B3E8: using guessed type int dword_1006B3E8;

//----- (10030F0A) --------------------------------------------------------
int __cdecl sub_10030F0A(int a1)
{
  int result; // eax@1

  result = __security_cookie ^ dword_1006B3F4;
  if ( __security_cookie != dword_1006B3F4 )
    result = ((int (__stdcall *)(int))result)(a1);
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B3F4: using guessed type int dword_1006B3F4;

//----- (10030F21) --------------------------------------------------------
HANDLE __stdcall sub_10030F21(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, int a5, int a6)
{
  HANDLE result; // eax@2

  if ( __security_cookie == dword_1006B3D4 )
    result = CreateSemaphoreW(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
  else
    result = (HANDLE)((int (__stdcall *)(LPSECURITY_ATTRIBUTES, LONG, LONG, LPCWSTR, int, int))(__security_cookie ^ dword_1006B3D4))(
                       lpSemaphoreAttributes,
                       lInitialCount,
                       lMaximumCount,
                       lpName,
                       a5,
                       a6);
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B3D4: using guessed type int dword_1006B3D4;

//----- (10030F4A) --------------------------------------------------------
int __cdecl sub_10030F4A(int a1, int a2, int a3)
{
  int result; // eax@2

  if ( __security_cookie == dword_1006B3DC )
    result = 0;
  else
    result = ((int (__stdcall *)(int, int, int))(__security_cookie ^ dword_1006B3DC))(a1, a2, a3);
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B3DC: using guessed type int dword_1006B3DC;

//----- (10030F6B) --------------------------------------------------------
int __cdecl sub_10030F6B(int a1, int a2, int a3)
{
  int result; // eax@2

  if ( __security_cookie == dword_1006B3EC )
    result = 0;
  else
    result = ((int (__stdcall *)(int, int, int))(__security_cookie ^ dword_1006B3EC))(a1, a2, a3);
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B3EC: using guessed type int dword_1006B3EC;

//----- (10030F8C) --------------------------------------------------------
DWORD __cdecl sub_10030F8C(int a1)
{
  DWORD result; // eax@2

  if ( __security_cookie == dword_1006B3C0 )
    result = TlsAlloc();
  else
    result = ((int (__stdcall *)(int))(__security_cookie ^ dword_1006B3C0))(a1);
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B3C0: using guessed type int dword_1006B3C0;

//----- (10030FAA) --------------------------------------------------------
BOOL __cdecl sub_10030FAA(DWORD a1)
{
  BOOL result; // eax@2

  if ( __security_cookie == dword_1006B3C4 )
    result = TlsFree(a1);
  else
    result = ((int (__stdcall *)(_DWORD))(__security_cookie ^ dword_1006B3C4))(a1);
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B3C4: using guessed type int dword_1006B3C4;

//----- (10030FC9) --------------------------------------------------------
LPVOID __cdecl sub_10030FC9(DWORD a1)
{
  LPVOID result; // eax@2

  if ( __security_cookie == dword_1006B3C8 )
    result = TlsGetValue(a1);
  else
    result = (LPVOID)((int (__stdcall *)(_DWORD))(__security_cookie ^ dword_1006B3C8))(a1);
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B3C8: using guessed type int dword_1006B3C8;

//----- (10030FE8) --------------------------------------------------------
BOOL __cdecl sub_10030FE8(DWORD a1, void *a2)
{
  BOOL result; // eax@2

  if ( __security_cookie == dword_1006B3CC )
    result = TlsSetValue(a1, a2);
  else
    result = ((int (__stdcall *)(_DWORD, _DWORD))(__security_cookie ^ dword_1006B3CC))(a1, a2);
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B3CC: using guessed type int dword_1006B3CC;

//----- (1003100A) --------------------------------------------------------
int __cdecl sub_1003100A()
{
  int result; // eax@1

  result = __security_cookie ^ dword_1006B3F8;
  if ( __security_cookie != dword_1006B3F8 )
    result = ((int (*)(void))result)();
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B3F8: using guessed type int dword_1006B3F8;

//----- (1003101A) --------------------------------------------------------
int __cdecl sub_1003101A(int a1, int a2)
{
  int result; // eax@1

  result = __security_cookie ^ dword_1006B3FC;
  if ( __security_cookie != dword_1006B3FC )
    result = ((int (__stdcall *)(int, int))result)(a1, a2);
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B3FC: using guessed type int dword_1006B3FC;

//----- (10031034) --------------------------------------------------------
int __cdecl sub_10031034()
{
  int result; // eax@2

  if ( __security_cookie == dword_1006B400 )
    result = 0;
  else
    result = ((int (*)(void))(__security_cookie ^ dword_1006B400))();
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B400: using guessed type int dword_1006B400;

//----- (10031046) --------------------------------------------------------
int __cdecl sub_10031046(int a1, int a2)
{
  int result; // eax@2

  if ( __security_cookie == dword_1006B404 )
  {
    SetLastError(0x78u);
    result = 0;
  }
  else
  {
    result = ((int (__stdcall *)(int, int))(__security_cookie ^ dword_1006B404))(a1, a2);
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B404: using guessed type int dword_1006B404;

//----- (1003106C) --------------------------------------------------------
int __cdecl sub_1003106C(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, int a3)
{
  int result; // eax@2

  if ( __security_cookie == dword_1006B3D0 )
  {
    InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
    result = 1;
  }
  else
  {
    result = ((int (__stdcall *)(LPCRITICAL_SECTION, DWORD, int))(__security_cookie ^ dword_1006B3D0))(
               lpCriticalSection,
               dwSpinCount,
               a3);
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B3D0: using guessed type int dword_1006B3D0;

//----- (1003109A) --------------------------------------------------------
char __cdecl sub_1003109A()
{
  signed int v0; // esi@1
  int v2; // [sp+4h] [bp-4h]@2

  v0 = dword_10067238;
  if ( dword_10067238 < 0 )
  {
    v0 = 0;
    v2 = 0;
    if ( __security_cookie != dword_1006B430 )
    {
      if ( ((int (__stdcall *)(int *, _DWORD))(__security_cookie ^ dword_1006B430))(&v2, 0) == 122 )
        v0 = 1;
    }
    dword_10067238 = v0;
  }
  return v0 > 0;
}
// 10067210: using guessed type int __security_cookie;
// 10067238: using guessed type int dword_10067238;
// 1006B430: using guessed type int dword_1006B430;

//----- (10031317) --------------------------------------------------------
int __cdecl sub_10031317(int a1, int a2, int a3, int a4)
{
  int result; // eax@1

  result = __security_cookie ^ dword_1006B3E0;
  if ( __security_cookie != dword_1006B3E0 )
    result = ((int (__stdcall *)(int, int, int, int))result)(a1, a2, a3, a4);
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B3E0: using guessed type int dword_1006B3E0;

//----- (10031337) --------------------------------------------------------
int __cdecl sub_10031337(int a1, int a2, int a3)
{
  int result; // eax@1

  result = __security_cookie ^ dword_1006B3F0;
  if ( __security_cookie != dword_1006B3F0 )
    result = ((int (__stdcall *)(int, int, int))result)(a1, a2, a3);
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B3F0: using guessed type int dword_1006B3F0;

//----- (10031354) --------------------------------------------------------
BOOL __cdecl sub_10031354(UINT uExitCode)
{
  HANDLE v2; // eax@1

  v2 = GetCurrentProcess();
  return TerminateProcess(v2, uExitCode);
}

//----- (10031369) --------------------------------------------------------
LONG __cdecl sub_10031369(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  SetUnhandledExceptionFilter(0);
  return UnhandledExceptionFilter(ExceptionInfo);
}

//----- (1003137F) --------------------------------------------------------
int __cdecl sub_1003137F(int a1, int a2)
{
  int result; // eax@1

  result = __security_cookie ^ dword_1006B3E4;
  if ( __security_cookie != dword_1006B3E4 )
    result = ((int (__stdcall *)(int, int))result)(a1, a2);
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B3E4: using guessed type int dword_1006B3E4;

//----- (10031399) --------------------------------------------------------
int __cdecl sub_10031399(int a1)
{
  int v1; // eax@1
  __int16 v2; // cx@2

  v1 = a1;
  do
  {
    v2 = *(_WORD *)v1;
    v1 += 2;
  }
  while ( v2 );
  return ((v1 - a1) >> 1) - 1;
}

//----- (100313B2) --------------------------------------------------------
int __usercall sub_100313B2<eax>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // ecx@2
  int v6; // eax@3
  __int16 v7; // ax@4
  int v8; // ecx@6
  int result; // eax@8
  int v10; // ecx@14
  unsigned int v11; // eax@16
  int v12; // edx@22
  int v13; // [sp+8h] [bp-18h]@1
  int v14; // [sp+10h] [bp-10h]@7
  char v15; // [sp+14h] [bp-Ch]@6
  WCHAR DestStr; // [sp+18h] [bp-8h]@16
  const CHAR MultiByteStr; // [sp+1Ch] [bp-4h]@14
  char v18; // [sp+1Dh] [bp-3h]@14
  char v19; // [sp+1Eh] [bp-2h]@14
  int v20; // [sp+28h] [bp+8h]@13

  sub_1002E635((int)&v13, a1, a2, a4);
  v4 = a3;
  if ( (unsigned int)a3 < 0x100 )
  {
    v5 = v13;
    if ( *(_DWORD *)(v13 + 116) <= 1 )
    {
      v7 = *(_WORD *)(*(_DWORD *)(v13 + 144) + 2 * a3);
      v6 = v7 & 1;
    }
    else
    {
      v6 = sub_100400D3(a3, 256, a3, 1, (int)&v13);
      v5 = v13;
    }
    if ( v6 )
    {
      v8 = *(_BYTE *)(*(_DWORD *)(v5 + 148) + a3);
      if ( v15 )
        *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
      return v8;
    }
    if ( v15 )
      *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
    return v4;
  }
  if ( *(_DWORD *)(v13 + 116) > 1 && (v20 = a3 >> 8, sub_10041D47(v4, 256, BYTE1(v4), (int)&v13)) )
  {
    MultiByteStr = v20;
    v18 = v4;
    v19 = 0;
    v10 = 2;
  }
  else
  {
    *(_DWORD *)sub_1002F144(v4) = 42;
    MultiByteStr = v4;
    v18 = 0;
    v10 = 1;
  }
  v11 = sub_1002EF9A(
          v4,
          256,
          (int)&v13,
          *(_DWORD *)(v13 + 168),
          0x100u,
          &MultiByteStr,
          v10,
          &DestStr,
          3,
          *(_DWORD *)(v13 + 4),
          1);
  if ( !v11 )
  {
    if ( v15 )
      *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
    return v4;
  }
  if ( v11 == 1 )
  {
    result = (unsigned __int8)DestStr;
    if ( v15 )
      *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
  }
  else
  {
    v12 = HIBYTE(DestStr) | ((unsigned __int8)DestStr << 8);
    if ( v15 )
      *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
    result = v12;
  }
  return result;
}

//----- (100314F3) --------------------------------------------------------
int __usercall sub_100314F3<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // ecx@2
  int result; // eax@4

  if ( dword_10069EE8 )
  {
    result = sub_100313B2(a1, a2, a3, 0);
  }
  else
  {
    v3 = a3;
    if ( (unsigned int)(a3 - 65) <= 0x19 )
      v3 = a3 + 32;
    result = v3;
  }
  return result;
}
// 10069EE8: using guessed type int dword_10069EE8;

//----- (100315D0) --------------------------------------------------------
__int64 __stdcall sub_100315D0(__int64 a1, __int64 a2)
{
  __int64 result; // qax@2

  if ( HIDWORD(a1) | HIDWORD(a2) )
    result = a2 * a1;
  else
    result = (unsigned int)a2 * (unsigned int)a1;
  return result;
}

//----- (10031610) --------------------------------------------------------
__int64 __stdcall sub_10031610(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  __int64 result; // qax@2
  unsigned __int64 v4; // qtt@2
  unsigned __int64 v5; // qax@3
  unsigned int v6; // ecx@3
  unsigned int v7; // ebx@3
  char v8; // cf@4
  char v9; // cf@4
  unsigned int v10; // eax@5
  unsigned __int64 v11; // qax@5
  unsigned int v12; // esi@5
  int v13; // ecx@5
  char v14; // cf@5

  if ( a3 )
  {
    v6 = a3;
    v7 = a2;
    v5 = a1;
    do
    {
      v8 = v6 & 1;
      v6 >>= 1;
      v7 = __RCR__(v7, v8);
      v9 = BYTE4(v5) & 1;
      HIDWORD(v5) >>= 1;
      LODWORD(v5) = __RCR__(v5, v9);
    }
    while ( v6 );
    v10 = v5 / v7;
    v12 = v10;
    v13 = a3 * v10;
    v11 = v10 * a2;
    v14 = v13 >= (unsigned int)-HIDWORD(v11);
    HIDWORD(v11) += v13;
    if ( v14 || HIDWORD(v11) > HIDWORD(a1) || v11 > a1 )
      --v12;
    result = v12;
  }
  else
  {
    LODWORD(v4) = a1;
    HIDWORD(v4) = HIDWORD(a1) % a2;
    LODWORD(result) = v4 / a2;
    HIDWORD(result) = HIDWORD(a1) / a2;
  }
  return result;
}

//----- (10031678) --------------------------------------------------------
int __cdecl sub_10031678(int a1)
{
  int v1; // ecx@1
  int v2; // esi@1
  int result; // eax@2

  v1 = 0;
  v2 = 227;
  while ( 1 )
  {
    result = (v2 + v1) / 2;
    if ( a1 == dword_10056A18[2 * result] )
      break;
    if ( a1 - dword_10056A18[2 * result] >= 0 )
      v1 = result + 1;
    else
      v2 = result - 1;
    if ( v1 > v2 )
      return -1;
  }
  return result;
}
// 10056A18: using guessed type int dword_10056A18[];

//----- (100316AD) --------------------------------------------------------
int __cdecl sub_100316AD(int a1)
{
  int v1; // ebx@1
  int v2; // edi@1
  int v3; // eax@2
  int v4; // esi@2

  v2 = 0;
  v1 = 227;
  while ( 1 )
  {
    v4 = (v1 + v2) / 2;
    v3 = sub_1003190F(a1, (unsigned __int16 *)*(&off_10057138 + 2 * (v1 + v2) / 2), 85);
    if ( !v3 )
      break;
    if ( v3 >= 0 )
      v2 = v4 + 1;
    else
      v1 = v4 - 1;
    if ( v2 > v1 )
      return -1;
  }
  return dword_1005713C[2 * v4];
}
// 10057138: using guessed type void *off_10057138;
// 1005713C: using guessed type int dword_1005713C[];

//----- (100316FB) --------------------------------------------------------
int __cdecl sub_100316FB(int a1, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2)
{
  int result; // eax@2
  int v7; // eax@3

  if ( __security_cookie == dword_1006B410 )
  {
    v7 = sub_100317C3(a1);
    result = CompareStringW(v7, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
  }
  else
  {
    result = ((int (__stdcall *)(int, DWORD, PCNZWCH, int, PCNZWCH, int, _DWORD, _DWORD, _DWORD))(__security_cookie ^ dword_1006B410))(
               a1,
               dwCmpFlags,
               lpString1,
               cchCount1,
               lpString2,
               cchCount2,
               0,
               0,
               0);
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B410: using guessed type int dword_1006B410;

//----- (10031747) --------------------------------------------------------
int __cdecl sub_10031747(int a1, int a2, int a3)
{
  int v3; // eax@7
  int v4; // eax@8
  int v5; // edx@8
  int v6; // ebx@8
  int v7; // edi@8
  int v9; // [sp-4h] [bp-10h]@8

  if ( a1 )
  {
    if ( a1 != 1024 )
    {
      if ( a1 != 2048 )
      {
        if ( a2 || a3 <= 0 )
        {
          if ( a3 >= 0 )
          {
            v3 = sub_10031678(a1);
            if ( v3 >= 0 )
            {
              v6 = off_10056A1C[2 * v3];
              v4 = sub_10041D8E(off_10056A1C[2 * v3], 0x55u);
              v7 = v4;
              if ( a3 <= 0 )
                return v7 + 1;
              if ( v4 < a3 )
              {
                if ( sub_100401C0(v5, v9, v6, v4, a2, a3, v6) )
                {
                  sub_10036C98(v6, v7);
                  __asm { int     3               ; Trap to Debugger }
                  JUMPOUT(*(int *)sub_100317C3);
                }
                return v7 + 1;
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

//----- (100317C3) --------------------------------------------------------
int __cdecl sub_100317C3(int a1)
{
  int v1; // eax@2
  int result; // eax@4

  if ( a1 && (v1 = sub_100316AD(a1), v1 >= 0) && (unsigned int)v1 < 0xE4 )
    result = dword_10056A18[2 * v1];
  else
    result = 0;
  return result;
}
// 10056A18: using guessed type int dword_10056A18[];

//----- (100317ED) --------------------------------------------------------
int __stdcall LocaleEnumProc(int a1)
{
  return dword_100695B8(a1, 0, 0);
}
// 100695B8: using guessed type int (__stdcall *dword_100695B8)(_DWORD, _DWORD, _DWORD);

//----- (10031801) --------------------------------------------------------
BOOL __cdecl sub_10031801(int (__stdcall *a1)(_DWORD, _DWORD, _DWORD), int a2, int a3)
{
  BOOL result; // eax@2

  if ( __security_cookie == dword_1006B414 )
  {
    dword_100695B8 = a1;
    result = EnumSystemLocalesW((LOCALE_ENUMPROCW)LocaleEnumProc, 1u);
    dword_100695B8 = 0;
  }
  else
  {
    result = ((int (__stdcall *)(int (__stdcall *)(_DWORD, _DWORD, _DWORD), int, int, _DWORD))(__security_cookie ^ dword_1006B414))(
               a1,
               a2,
               a3,
               0);
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 100695B8: using guessed type int (__stdcall *dword_100695B8)(_DWORD, _DWORD, _DWORD);
// 1006B414: using guessed type int dword_1006B414;

//----- (1003183E) --------------------------------------------------------
int __cdecl sub_1003183E(int a1, LCTYPE a2, WCHAR *a3, int a4)
{
  int result; // eax@2
  int v5; // eax@3

  if ( __security_cookie == dword_1006B41C )
  {
    v5 = sub_100317C3(a1);
    result = GetLocaleInfoW(v5, a2, a3, a4);
  }
  else
  {
    result = ((int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))(__security_cookie ^ dword_1006B41C))(a1, a2, a3, a4);
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B41C: using guessed type int dword_1006B41C;

//----- (1003186D) --------------------------------------------------------
int __cdecl sub_1003186D(int a1, int a2)
{
  int result; // eax@2
  int v3; // eax@3

  if ( __security_cookie == dword_1006B424 )
  {
    v3 = GetUserDefaultLCID();
    result = sub_10031747(v3, a1, a2);
  }
  else
  {
    result = ((int (__stdcall *)(_DWORD, _DWORD))(__security_cookie ^ dword_1006B424))(a1, a2);
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B424: using guessed type int dword_1006B424;

//----- (10031898) --------------------------------------------------------
BOOL __cdecl sub_10031898(int a1)
{
  BOOL result; // eax@2
  int v2; // eax@3

  if ( __security_cookie == dword_1006B428 )
  {
    v2 = sub_100317C3(a1);
    result = IsValidLocale(v2, 1u);
  }
  else
  {
    result = ((int (__stdcall *)(_DWORD))(__security_cookie ^ dword_1006B428))(a1);
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B428: using guessed type int dword_1006B428;

//----- (100318C3) --------------------------------------------------------
int __cdecl sub_100318C3(int a1, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
{
  int result; // eax@2
  int v7; // eax@3

  if ( __security_cookie == dword_1006B42C )
  {
    v7 = sub_100317C3(a1);
    result = LCMapStringW(v7, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
  }
  else
  {
    result = ((int (__stdcall *)(int, DWORD, LPCWSTR, int, LPWSTR, int, _DWORD, _DWORD, _DWORD))(__security_cookie ^ dword_1006B42C))(
               a1,
               dwMapFlags,
               lpSrcStr,
               cchSrc,
               lpDestStr,
               cchDest,
               0,
               0,
               0);
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B42C: using guessed type int dword_1006B42C;

//----- (1003190F) --------------------------------------------------------
int __cdecl sub_1003190F(int a1, unsigned __int16 *a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  signed __int16 v5; // dx@2
  unsigned __int16 *v6; // ecx@2
  unsigned __int16 v7; // ax@4
  unsigned __int16 v8; // dx@6
  unsigned __int16 v9; // ax@8
  signed int v10; // [sp+14h] [bp+10h]@2

  v4 = a3;
  result = 0;
  if ( a3 )
  {
    v6 = a2;
    v5 = 90;
    v10 = 90;
    while ( 1 )
    {
      v7 = *(unsigned __int16 *)((char *)v6 + a1 - (_DWORD)a2);
      if ( v7 < 0x41u || v7 > v5 )
        v8 = *(unsigned __int16 *)((char *)v6 + a1 - (_DWORD)a2);
      else
        v8 = v7 + 32;
      v9 = *v6;
      if ( *v6 >= 0x41u )
      {
        if ( v9 <= (_WORD)v10 )
          v9 += 32;
      }
      ++v6;
      --v4;
      if ( !v4 )
        break;
      if ( !v8 || v8 != v9 )
        break;
      v5 = 90;
    }
    result = v8 - v9;
  }
  return result;
}

//----- (1003197D) --------------------------------------------------------
int __cdecl sub_1003197D(int a1, DWORD dwMapFlags, LPCWSTR lpSrcStr, unsigned int cchSrc, LPWSTR lpDestStr, int cchDest)
{
  int v6; // eax@1

  v6 = cchSrc;
  if ( (signed int)cchSrc > 0 )
    v6 = sub_10041D8E((int)lpSrcStr, cchSrc);
  return sub_100318C3(a1, dwMapFlags, lpSrcStr, v6, lpDestStr, cchDest);
}

//----- (100319B0) --------------------------------------------------------
void __usercall sub_100319B0(unsigned __int64 a1<st0>)
{
  int v1; // ST00_4@1
  int v2; // ST04_4@1

  sub_10042068(a1, a1 >> 32);
  sub_100319CD(v1, v2);
}
// 100319CD: using guessed type double __cdecl sub_100319CD(_DWORD, _DWORD);

//----- (100319CD) --------------------------------------------------------
#error "10031A63: call analysis failed (funcsize=60)"

//----- (10031A6A) --------------------------------------------------------
void __userpurge sub_10031A6A(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, LPVOID lpMem)
{
  int v5; // ST04_4@3
  int v6; // ST04_4@5
  int v7; // ST04_4@7
  int v8; // ST04_4@9
  int v9; // ST04_4@11
  int v10; // ST04_4@13
  int v11; // ST04_4@15
  int v12; // ST04_4@17
  void *v13; // edi@18

  if ( lpMem )
  {
    if ( *((_DWORD *)lpMem + 9) )
    {
      sub_100282F6(a3, *((LPVOID *)lpMem + 9));
      a2 = v5;
    }
    if ( *((_DWORD *)lpMem + 11) )
    {
      sub_100282F6(a3, *((LPVOID *)lpMem + 11));
      a2 = v6;
    }
    if ( *((_DWORD *)lpMem + 13) )
    {
      sub_100282F6(a3, *((LPVOID *)lpMem + 13));
      a2 = v7;
    }
    if ( *((_DWORD *)lpMem + 15) )
    {
      sub_100282F6(a3, *((LPVOID *)lpMem + 15));
      a2 = v8;
    }
    if ( *((_DWORD *)lpMem + 16) )
    {
      sub_100282F6(a3, *((LPVOID *)lpMem + 16));
      a2 = v9;
    }
    if ( *((_DWORD *)lpMem + 17) )
    {
      sub_100282F6(a3, *((LPVOID *)lpMem + 17));
      a2 = v10;
    }
    if ( *((_DWORD *)lpMem + 18) )
    {
      sub_100282F6(a3, *((LPVOID *)lpMem + 18));
      a2 = v11;
    }
    if ( *((_UNKNOWN **)lpMem + 23) != &unk_10059D40 )
    {
      sub_100282F6(a3, *((LPVOID *)lpMem + 23));
      a2 = v12;
    }
    sub_1002E493(a1, a2, a3, a4, 13);
    v13 = (void *)*((_DWORD *)lpMem + 26);
    if ( v13 )
    {
      if ( !InterlockedDecrement(*((volatile LONG **)lpMem + 26)) )
      {
        if ( v13 != &unk_10067D58 )
          sub_100282F6(a3, v13);
      }
    }
    sub_1002E5F7(13);
  }
}

//----- (10031BA1) --------------------------------------------------------
void __usercall sub_10031BA1(int a1<ebx>, int a2<edi>, LPVOID lpMem)
{
  DWORD v3; // eax@1
  void *v4; // esi@2
  int v5; // edx@4
  int v6; // ST04_4@4

  v3 = dword_10067248;
  if ( dword_10067248 != -1 )
  {
    v4 = lpMem;
    if ( !lpMem )
    {
      v4 = sub_10030FC9(dword_10067248);
      v3 = dword_10067248;
    }
    sub_10030FE8(v3, 0);
    sub_10031A6A(v5, v6, a1, a2, v4);
  }
}
// 10067248: using guessed type int dword_10067248;

//----- (10031BD7) --------------------------------------------------------
int __usercall sub_10031BD7<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // esi@1

  v4 = sub_10031BEF(a1);
  if ( !v4 )
    sub_1003234D(v2, v3, a1, a2, 16);
  return v4;
}

//----- (10031BEF) --------------------------------------------------------
int __usercall sub_10031BEF<eax>(int a1<ebx>)
{
  DWORD v1; // edi@1
  int v2; // esi@1
  void *v3; // eax@2
  int v4; // edx@3
  DWORD v5; // eax@4
  int v7; // [sp-4h] [bp-Ch]@1
  int v8; // [sp-4h] [bp-Ch]@3

  v1 = GetLastError();
  v2 = (int)sub_10030FC9(dword_10067248);
  if ( !v2 )
  {
    v3 = sub_1002EFE1(v7, a1, 1u, 0x3BCu);
    v2 = (int)v3;
    if ( v3 )
    {
      if ( sub_10030FE8(dword_10067248, v3) )
      {
        sub_10031C5E(v4, v8, a1, v2);
        v5 = GetCurrentThreadId();
        *(_DWORD *)(v2 + 4) = -1;
        *(_DWORD *)v2 = v5;
      }
      else
      {
        sub_100282F6(a1, (LPVOID)v2);
        v2 = 0;
      }
    }
  }
  SetLastError(v1);
  return v2;
}
// 10067248: using guessed type int dword_10067248;

//----- (10031C5E) --------------------------------------------------------
void __usercall sub_10031C5E(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  *(_DWORD *)(a4 + 92) = &unk_10059D40;
  *(_DWORD *)(a4 + 8) = 0;
  *(_DWORD *)(a4 + 20) = 1;
  *(_DWORD *)(a4 + 112) = 1;
  *(_WORD *)(a4 + 184) = 67;
  *(_WORD *)(a4 + 446) = 67;
  *(_DWORD *)(a4 + 104) = &unk_10067D58;
  *(_DWORD *)(a4 + 952) = 0;
  sub_1002E493(a1, a2, a3, 1, 13);
  InterlockedIncrement(*(volatile LONG **)(a4 + 104));
  sub_1002E5F7(13);
}

//----- (10031D11) --------------------------------------------------------
signed int __usercall sub_10031D11<eax>(int a1<ebx>)
{
  signed int result; // eax@2
  void *v2; // eax@4
  int v3; // esi@4
  int v4; // edx@5
  DWORD v5; // eax@6
  int v6; // [sp-8h] [bp-8h]@5
  int v7; // [sp-4h] [bp-4h]@3

  sub_1003241D();
  if ( sub_1002E5C2() && (dword_10067248 = sub_10030F8C((int)sub_10031A6A), dword_10067248 != -1) )
  {
    v2 = sub_1002EFE1(v7, a1, 1u, 0x3BCu);
    v3 = (int)v2;
    if ( v2 && sub_10030FE8(dword_10067248, v2) )
    {
      sub_10031C5E(v4, v6, a1, v3);
      v5 = GetCurrentThreadId();
      *(_DWORD *)(v3 + 4) = -1;
      *(_DWORD *)v3 = v5;
      result = 1;
    }
    else
    {
      sub_10031D87();
      result = 0;
    }
  }
  else
  {
    sub_10031D87();
    result = 0;
  }
  return result;
}
// 10067248: using guessed type int dword_10067248;

//----- (10031D87) --------------------------------------------------------
void __cdecl sub_10031D87()
{
  signed int v0; // edi@3
  signed int v1; // esi@3
  LPCRITICAL_SECTION v2; // ebx@4

  if ( dword_10067248 != -1 )
  {
    sub_10030FAA(dword_10067248);
    dword_10067248 = -1;
  }
  v1 = (signed int)&lpCriticalSection;
  v0 = (signed int)&lpCriticalSection;
  do
  {
    v2 = *(LPCRITICAL_SECTION *)v0;
    if ( *(_DWORD *)v0 )
    {
      if ( *(_DWORD *)(v0 + 4) != 1 )
      {
        DeleteCriticalSection(*(LPCRITICAL_SECTION *)v0);
        sub_100282F6((int)v2, v2);
        *(_DWORD *)v0 = 0;
      }
    }
    v0 += 8;
  }
  while ( v0 < (signed int)&off_10067090 );
  do
  {
    if ( *(_DWORD *)v1 )
    {
      if ( *(_DWORD *)(v1 + 4) == 1 )
        DeleteCriticalSection(*(LPCRITICAL_SECTION *)v1);
    }
    v1 += 8;
  }
  while ( v1 < (signed int)&off_10067090 );
}
// 10067090: using guessed type wchar_t *off_10067090;
// 10067248: using guessed type int dword_10067248;

//----- (10031DA4) --------------------------------------------------------
void __usercall sub_10031DA4(int a1<ebx>, int a2<edi>)
{
  void (*v2)(void); // eax@1

  v2 = (void (*)(void))DecodePointer(dword_100695BC);
  if ( v2 )
    v2();
  sub_10031DDC(a1, a2);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_10031DDC);
}

//----- (10031DDC) --------------------------------------------------------
void __usercall sub_10031DDC(int a1<ebx>, int a2<edi>)
{
  void (*v2)(void); // eax@1

  v2 = *(void (**)(void))(sub_10031BD7(a1, a2) + 120);
  if ( v2 )
    v2();
  loc_10030D9F();
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_10031E10);
}

//----- (10031E10) --------------------------------------------------------
void __usercall sub_10031E10(int a1<ebx>, int a2<edi>)
{
  void (*v2)(void); // eax@1

  v2 = *(void (**)(void))(sub_10031BD7(a1, a2) + 124);
  if ( v2 )
    v2();
  sub_10031DDC(a1, a2);
}

//----- (10031E23) --------------------------------------------------------
PVOID __cdecl sub_10031E23()
{
  PVOID result; // eax@1

  result = EncodePointer(sub_10031DDC);
  dword_100695BC = result;
  return result;
}

//----- (10031E40) --------------------------------------------------------
int __usercall sub_10031E40<eax>(unsigned int a1<eax>, int a2<ecx>, char a3)
{
  return sub_10042170(-(((unsigned int)(&a3 - a1) & 0xF) >= -a1) | (((unsigned int)(&a3 - a1) & 0xF) + a1), a2);
}

//----- (10031E6C) --------------------------------------------------------
signed int __usercall sub_10031E6C<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  int v5; // edx@2
  int v6; // ecx@3
  int v7; // eax@5
  char v9; // al@8
  signed int v10; // [sp-4h] [bp-8h]@5

  if ( !a3 || (v5 = a4, !a4) )
    goto LABEL_5;
  v6 = a5;
  if ( !a5 )
  {
    *(_BYTE *)a3 = a5;
LABEL_5:
    v7 = sub_1002F144(a1);
    v10 = 22;
LABEL_6:
    *(_DWORD *)v7 = v10;
    sub_10036C88(a1, a2);
    return v10;
  }
  do
  {
    v9 = *(_BYTE *)v6;
    *(_BYTE *)(a3 - a5 + v6) = *(_BYTE *)v6;
    ++v6;
    if ( !v9 )
      break;
    --v5;
  }
  while ( v5 );
  if ( !v5 )
  {
    *(_BYTE *)a3 = 0;
    v7 = sub_1002F144(a1);
    v10 = 34;
    goto LABEL_6;
  }
  return 0;
}

//----- (10031EC1) --------------------------------------------------------
int __cdecl sub_10031EC1()
{
  int v1; // esi@2
  int v6; // ST18_4@2

  dword_100695C0 = 0;
  dword_10067250 |= 1u;
  if ( IsProcessorFeaturePresent(0xAu) )
  {
    _EAX = 1;
    dword_100695C0 = 1;
    __asm { cpuid }
    v1 = dword_10067250 | 2;
    v6 = _ECX;
    dword_10067250 |= 2u;
    if ( v6 & 0x100000 )
    {
      v1 |= 4u;
      dword_100695C0 = 2;
      dword_10067250 = v1;
    }
    if ( _ECX & 0x10000000 )
    {
      dword_100695C0 = 3;
      dword_10067250 = v1 | 8;
    }
    _EAX = 7;
    __asm { cpuid }
    _EAX = 0;
    __asm { cpuid }
  }
  return 0;
}
// 10067250: using guessed type int dword_10067250;
// 100695C0: using guessed type int dword_100695C0;

//----- (10032060) --------------------------------------------------------
int __cdecl sub_10032060(PEXCEPTION_RECORD ExceptionRecord, int TargetFrame, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // eax@4
  void *v7; // ecx@5
  int v8; // eax@5
  int v9; // eax@6
  char v10; // cl@6
  int v11; // eax@12
  char v13; // [sp+0h] [bp-24h]@3
  char v14; // [sp+0h] [bp-24h]@3
  PEXCEPTION_RECORD v15; // [sp+Ch] [bp-18h]@4
  int v16; // [sp+10h] [bp-14h]@4
  int v17; // [sp+14h] [bp-10h]@5
  int v18; // [sp+18h] [bp-Ch]@1
  unsigned int v19; // [sp+1Ch] [bp-8h]@4
  char v20; // [sp+23h] [bp-1h]@1

  v3 = TargetFrame;
  v4 = __security_cookie ^ *(_DWORD *)(TargetFrame + 8);
  v20 = 0;
  v18 = 1;
  v5 = TargetFrame + 16;
  if ( *(_DWORD *)v4 != -2 )
    sub_10022B30(TargetFrame, v4, v5, *(_DWORD *)(*(_DWORD *)v4 + v5) ^ (v5 + *(_DWORD *)(v4 + 4)), v13);
  sub_10022B30(TargetFrame, v4, v5, *(_DWORD *)(*(_DWORD *)(v4 + 8) + v5) ^ (v5 + *(_DWORD *)(v4 + 12)), v13);
  if ( ExceptionRecord->ExceptionFlags & 0x66 )
  {
    if ( *(_DWORD *)(TargetFrame + 12) == -2 )
      return v18;
    sub_1004242B(TargetFrame, 0xFFFFFFFEu, v5, (int)&__security_cookie);
  }
  else
  {
    v15 = ExceptionRecord;
    v16 = a3;
    *(_DWORD *)(TargetFrame - 4) = &v15;
    v6 = *(_DWORD *)(TargetFrame + 12);
    v19 = v6;
    if ( v6 == -2 )
      return v18;
    do
    {
      v8 = 3 * v6 + 4;
      v7 = *(void **)(v4 + 4 * v8 + 4);
      v3 = *(_DWORD *)(v4 + 4 * v8);
      v17 = v4 + 4 * v8;
      if ( v7 )
      {
        v9 = sub_100423E2(v7);
        v10 = 1;
        v20 = 1;
        if ( v9 < 0 )
        {
          v18 = 0;
          goto LABEL_23;
        }
        if ( v9 > 0 )
        {
          if ( ExceptionRecord->ExceptionCode == -529697949 )
          {
            if ( off_10055F84 )
            {
              if ( sub_100421F0((int)ExceptionRecord, (int)&off_10055F84) )
                off_10055F84(ExceptionRecord, 1);
            }
          }
          sub_10042412((PVOID)TargetFrame, ExceptionRecord);
          v11 = TargetFrame;
          if ( *(_DWORD *)(TargetFrame + 12) != v19 )
          {
            sub_1004242B(TargetFrame, v19, v5, (int)&__security_cookie);
            v11 = TargetFrame;
          }
          *(_DWORD *)(v11 + 12) = v3;
          if ( *(_DWORD *)v4 != -2 )
            sub_10022B30(v3, v4, v5, *(_DWORD *)(*(_DWORD *)v4 + v5) ^ (v5 + *(_DWORD *)(v4 + 4)), v14);
          sub_10022B30(v3, v4, v5, *(_DWORD *)(*(_DWORD *)(v4 + 8) + v5) ^ (v5 + *(_DWORD *)(v4 + 12)), v14);
          sub_100423F9(*(_DWORD *)(v17 + 8), v5);
          __asm { int     3               ; Trap to Debugger }
          JUMPOUT(*(int *)sub_100321F5);
        }
      }
      else
      {
        v10 = v20;
      }
      v6 = v3;
      v19 = v3;
    }
    while ( v3 != -2 );
    if ( !v10 )
      return v18;
  }
LABEL_23:
  if ( *(_DWORD *)v4 != -2 )
    sub_10022B30(v3, v4, v5, *(_DWORD *)(*(_DWORD *)v4 + v5) ^ (v5 + *(_DWORD *)(v4 + 4)), v14);
  sub_10022B30(v3, v4, v5, *(_DWORD *)(*(_DWORD *)(v4 + 8) + v5) ^ (v5 + *(_DWORD *)(v4 + 12)), v14);
  return v18;
}
// 10055F84: using guessed type int (__cdecl *off_10055F84)(_DWORD, _DWORD);
// 10067210: using guessed type int __security_cookie;

//----- (100321F5) --------------------------------------------------------
int (__stdcall *__thiscall sub_100321F5(HMODULE this, int a2))()
{
  int (__stdcall *result)(); // eax@1
  HMODULE hModule; // [sp+0h] [bp-4h]@1

  hModule = this;
  result = (int (__stdcall *)())GetModuleHandleExW(0, L"mscoree.dll", &hModule);
  if ( result )
  {
    result = GetProcAddress(hModule, "CorExitProcess");
    if ( result )
      result = (int (__stdcall *)())((int (__stdcall *)(int))result)(a2);
  }
  return result;
}

//----- (10032227) --------------------------------------------------------
void __thiscall sub_10032227(HMODULE this, UINT uExitCode)
{
  sub_100321F5(this, uExitCode);
  ExitProcess(uExitCode);
}

//----- (1003223D) --------------------------------------------------------
void __usercall sub_1003223D(int a1<ebx>)
{
  PVOID v1; // edi@1
  LPVOID v2; // esi@1
  char v3; // zf@3
  LPVOID v4; // esi@5
  char v5; // zf@7

  v2 = lpMem;
  v1 = DecodePointer(Ptr);
  if ( lpMem )
  {
    do
    {
      if ( !*(_DWORD *)v2 )
        break;
      sub_100282F6(a1, *(LPVOID *)v2);
      v3 = (char *)v2 + 4 == 0;
      v2 = (char *)v2 + 4;
    }
    while ( !v3 );
    v2 = lpMem;
  }
  sub_100282F6(a1, v2);
  v4 = dword_100695EC;
  lpMem = 0;
  if ( dword_100695EC )
  {
    do
    {
      if ( !*(_DWORD *)v4 )
        break;
      sub_100282F6(0, *(LPVOID *)v4);
      v5 = (char *)v4 + 4 == 0;
      v4 = (char *)v4 + 4;
    }
    while ( !v5 );
    v4 = dword_100695EC;
  }
  sub_100282F6(0, v4);
  dword_100695EC = 0;
  sub_100282F6(0, dword_100695E8);
  sub_100282F6(0, dword_100695E4);
  dword_100695E8 = 0;
  dword_100695E4 = 0;
  if ( v1 != (PVOID)-1 )
  {
    if ( Ptr )
      sub_100282F6(0, v1);
  }
  Ptr = EncodePointer((PVOID)0xFFFFFFFF);
  if ( dword_10069FE0 )
  {
    sub_100282F6(0, dword_10069FE0);
    dword_10069FE0 = 0;
  }
  if ( dword_10069FE4 )
  {
    sub_100282F6(0, dword_10069FE4);
    dword_10069FE4 = 0;
  }
  if ( !InterlockedDecrement((volatile LONG *)lpAddend) )
  {
    if ( lpAddend != &unk_10067D58 )
    {
      sub_100282F6(a1, lpAddend);
      lpAddend = &unk_10067D58;
    }
  }
}

//----- (1003234D) --------------------------------------------------------
void __usercall sub_1003234D(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // edx@1
  int v6; // ST00_4@1

  sub_10032605(a1, a2, a3, a4);
  sub_10032662(a3, a5);
  sub_10032409(v5, v6, a3, a4, 0xFFu);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_10032369);
}

//----- (10032369) --------------------------------------------------------
void __usercall sub_10032369(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  sub_100324A5(a1, a2, a3, a4, 0, 0, 1);
}

//----- (10032378) --------------------------------------------------------
int __usercall sub_10032378<eax>(int a1<eax>, int a2<ebx>, int a3<edi>, int a4)
{
  int result; // eax@4
  int v5; // edx@4
  int v6; // eax@5
  unsigned int i; // esi@5
  int v8; // [sp-4h] [bp-4h]@4
  int v9; // [sp-4h] [bp-4h]@11

  if ( off_10056790 )
  {
    if ( sub_100421F0(a1, (int)&off_10056790) )
      off_10056790(a4);
  }
  sub_10041BBC();
  result = sub_10032471((unsigned int)&unk_10054260, (unsigned int)&unk_10054278);
  if ( !result )
  {
    v6 = sub_10024006(v5, v8, a2, a3, sub_1003E501);
    for ( i = (unsigned int)&unk_100541F8; i < (unsigned int)&unk_1005425C; i += 4 )
    {
      v6 = *(_DWORD *)i;
      if ( *(_DWORD *)i )
        v6 = ((int (*)(void))v6)();
    }
    if ( dword_1006B3A4 )
    {
      if ( sub_100421F0(v6, (int)&dword_1006B3A4) )
        dword_1006B3A4(v9, 0, 2, 0);
    }
    result = 0;
  }
  return result;
}
// 10056790: using guessed type int (__cdecl *off_10056790)(_DWORD);
// 1006B3A4: using guessed type int (__thiscall *dword_1006B3A4)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10032409) --------------------------------------------------------
void __usercall sub_10032409(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, UINT uExitCode)
{
  sub_100324A5(a1, a2, a3, a4, uExitCode, 1, 0);
}

//----- (1003241D) --------------------------------------------------------
unsigned int __cdecl sub_1003241D()
{
  HMODULE v0; // edi@1
  unsigned int result; // eax@1
  PVOID v2; // esi@1

  v2 = EncodePointer(0);
  sub_10038C36(v2);
  sub_10036C50(v2);
  sub_100329F4(v2);
  sub_10042442((int)v2);
  sub_100404FE((int)v2);
  sub_10031E23();
  v0 = GetModuleHandleW(L"kernel32.dll");
  dword_1006B3C0 = __security_cookie ^ (int)GetProcAddress(v0, "FlsAlloc");
  dword_1006B3C4 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "FlsFree");
  dword_1006B3C8 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "FlsGetValue");
  dword_1006B3CC = __security_cookie ^ (unsigned int)GetProcAddress(v0, "FlsSetValue");
  dword_1006B3D0 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "InitializeCriticalSectionEx");
  dword_1006B3D4 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CreateSemaphoreExW");
  dword_1006B3D8 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "SetThreadStackGuarantee");
  dword_1006B3DC = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CreateThreadpoolTimer");
  dword_1006B3E0 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "SetThreadpoolTimer");
  dword_1006B3E4 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "WaitForThreadpoolTimerCallbacks");
  dword_1006B3E8 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CloseThreadpoolTimer");
  dword_1006B3EC = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CreateThreadpoolWait");
  dword_1006B3F0 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "SetThreadpoolWait");
  dword_1006B3F4 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CloseThreadpoolWait");
  dword_1006B3F8 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "FlushProcessWriteBuffers");
  dword_1006B3FC = __security_cookie ^ (unsigned int)GetProcAddress(v0, "FreeLibraryWhenCallbackReturns");
  dword_1006B400 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetCurrentProcessorNumber");
  dword_1006B404 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetLogicalProcessorInformation");
  dword_1006B408 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CreateSymbolicLinkW");
  dword_1006B40C = __security_cookie ^ (unsigned int)GetProcAddress(v0, "SetDefaultDllDirectories");
  dword_1006B414 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "EnumSystemLocalesEx");
  dword_1006B410 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CompareStringEx");
  dword_1006B418 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetDateFormatEx");
  dword_1006B41C = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetLocaleInfoEx");
  dword_1006B420 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetTimeFormatEx");
  dword_1006B424 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetUserDefaultLocaleName");
  dword_1006B428 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "IsValidLocaleName");
  dword_1006B42C = __security_cookie ^ (unsigned int)GetProcAddress(v0, "LCMapStringEx");
  result = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetCurrentPackageId");
  dword_1006B430 = result;
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 1006B3C0: using guessed type int dword_1006B3C0;
// 1006B3C4: using guessed type int dword_1006B3C4;
// 1006B3C8: using guessed type int dword_1006B3C8;
// 1006B3CC: using guessed type int dword_1006B3CC;
// 1006B3D0: using guessed type int dword_1006B3D0;
// 1006B3D4: using guessed type int dword_1006B3D4;
// 1006B3D8: using guessed type int dword_1006B3D8;
// 1006B3DC: using guessed type int dword_1006B3DC;
// 1006B3E0: using guessed type int dword_1006B3E0;
// 1006B3E4: using guessed type int dword_1006B3E4;
// 1006B3E8: using guessed type int dword_1006B3E8;
// 1006B3EC: using guessed type int dword_1006B3EC;
// 1006B3F0: using guessed type int dword_1006B3F0;
// 1006B3F4: using guessed type int dword_1006B3F4;
// 1006B3F8: using guessed type int dword_1006B3F8;
// 1006B3FC: using guessed type int dword_1006B3FC;
// 1006B400: using guessed type int dword_1006B400;
// 1006B404: using guessed type int dword_1006B404;
// 1006B408: using guessed type int dword_1006B408;
// 1006B40C: using guessed type int dword_1006B40C;
// 1006B410: using guessed type int dword_1006B410;
// 1006B414: using guessed type int dword_1006B414;
// 1006B418: using guessed type int dword_1006B418;
// 1006B41C: using guessed type int dword_1006B41C;
// 1006B420: using guessed type int dword_1006B420;
// 1006B424: using guessed type int dword_1006B424;
// 1006B428: using guessed type int dword_1006B428;
// 1006B42C: using guessed type int dword_1006B42C;
// 1006B430: using guessed type int dword_1006B430;

//----- (10032455) --------------------------------------------------------
void __cdecl sub_10032455(unsigned int a1, unsigned int a2)
{
  unsigned int i; // esi@1

  for ( i = a1; i < a2; i += 4 )
  {
    if ( *(_DWORD *)i )
      (*(void (**)(void))i)();
  }
}

//----- (10032471) --------------------------------------------------------
int __cdecl sub_10032471(unsigned int a1, unsigned int a2)
{
  int result; // eax@1
  unsigned int v3; // esi@1

  v3 = a1;
  result = 0;
  while ( v3 < a2 && !result )
  {
    if ( *(_DWORD *)v3 )
      result = (*(int (**)(void))v3)();
    v3 += 4;
  }
  return result;
}

//----- (10032493) --------------------------------------------------------
void __usercall sub_10032493(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  sub_1002E493(a1, a2, a3, a4, 8);
}

//----- (1003249C) --------------------------------------------------------
void __cdecl sub_1003249C()
{
  sub_1002E5F7(8);
}

//----- (100324A5) --------------------------------------------------------
void __usercall sub_100324A5(int a1<edx>, int ecx0<ecx>, int ebx0<ebx>, int a4<edi>, UINT uExitCode, int a2, int a3)
{
  PVOID v7; // ebx@3
  PVOID (__stdcall *v8)(PVOID); // esi@3
  PVOID v9; // edi@4
  PVOID v10; // eax@8
  void (*v11)(void); // esi@8
  PVOID v12; // [sp+14h] [bp-28h]@8
  PVOID v13; // [sp+1Ch] [bp-20h]@4
  PVOID v14; // [sp+20h] [bp-1Ch]@4

  sub_1002E493(a1, ecx0, ebx0, a4, 8);
  if ( dword_100695DC != 1 )
  {
    dword_100695D0 = 1;
    byte_100695CC = a3;
    if ( !a2 )
    {
      v8 = DecodePointer;
      v7 = DecodePointer(Ptr);
      if ( v7 )
      {
        v9 = DecodePointer(dword_1006B3A8);
        v14 = v7;
        v13 = v9;
        while ( 1 )
        {
          v9 = (char *)v9 - 4;
          if ( v9 < v7 )
            break;
          if ( *(PVOID *)v9 != EncodePointer(0) )
          {
            if ( v9 < v7 )
              break;
            v11 = (void (*)(void))v8(*(PVOID *)v9);
            *(_DWORD *)v9 = EncodePointer(0);
            v11();
            v8 = DecodePointer;
            v12 = DecodePointer(Ptr);
            v10 = DecodePointer(dword_1006B3A8);
            if ( v14 != v12 || v13 != v10 )
            {
              v14 = v12;
              v7 = v12;
              v13 = v10;
              v9 = v10;
            }
          }
        }
      }
      sub_10032455((unsigned int)&unk_1005427C, (unsigned int)&unk_10054290);
    }
    sub_10032455((unsigned int)&unk_10054294, (unsigned int)&unk_10054298);
  }
  if ( a3 )
    sub_1002E5F7(8);
}
// 100695CC: using guessed type char byte_100695CC;
// 100695D0: using guessed type int dword_100695D0;
// 100695DC: using guessed type int dword_100695DC;

//----- (100325D4) --------------------------------------------------------
SIZE_T __usercall sub_100325D4<eax>(int a1<ebx>, int a2<edi>, LPCVOID lpMem)
{
  SIZE_T result; // eax@2

  if ( lpMem )
  {
    result = HeapSize(hHeap, 0, lpMem);
  }
  else
  {
    *(_DWORD *)sub_1002F144(a1) = 22;
    sub_10036C88(a1, a2);
    result = -1;
  }
  return result;
}

//----- (10032605) --------------------------------------------------------
void *__usercall sub_10032605<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // edx@1
  void *result; // eax@2
  int v6; // [sp-4h] [bp-4h]@1

  if ( sub_100424BB(a1, a2, a3, a4, 3) == 1
    || (result = (void *)sub_100424BB(v4, v6, a3, a4, 3), !result) && dword_10069600 == 1 )
  {
    sub_10032662(a3, 252);
    result = sub_10032662(a3, 255);
  }
  return result;
}
// 10069600: using guessed type int dword_10069600;

//----- (1003263E) --------------------------------------------------------
wchar_t *__cdecl sub_1003263E(int a1)
{
  unsigned int v1; // eax@1

  v1 = 0;
  while ( a1 != dword_10059378[2 * v1] )
  {
    ++v1;
    if ( v1 >= 0x17 )
      return 0;
  }
  return (wchar_t *)off_1005937C[2 * v1];
}
// 10059378: using guessed type int dword_10059378[];

//----- (10032662) --------------------------------------------------------
void *__usercall sub_10032662<eax>(int a1<ebx>, int a2)
{
  void *result; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // edx@2
  int v6; // edx@3
  int v7; // edx@7
  int v8; // ecx@7
  int v9; // edx@9
  int v10; // ecx@9
  int v11; // eax@9
  int v12; // ST10_4@9
  int v13; // eax@10
  int v14; // edx@11
  int v15; // ecx@11
  void *v16; // esi@14
  unsigned int v17; // ecx@16
  int v18; // eax@19
  int v19; // [sp-8h] [bp-20Ch]@2
  int v20; // [sp-8h] [bp-20Ch]@3
  int v21; // [sp-4h] [bp-208h]@1
  DWORD NumberOfBytesWritten; // [sp+8h] [bp-1FCh]@19
  char Buffer[499]; // [sp+Ch] [bp-1F8h]@17
  char v24; // [sp+1FFh] [bp-5h]@19
  unsigned int v25; // [sp+200h] [bp-4h]@1
  int v26; // [sp+204h] [bp+0h]@1

  v25 = (unsigned int)&v26 ^ __security_cookie;
  result = sub_1003263E(a2);
  v4 = (int)result;
  if ( result )
  {
    if ( sub_100424BB(v3, v21, a1, (int)result, 3) != 1
      && ((result = (void *)sub_100424BB(v5, v19, a1, v4, 3)) != 0 || dword_10069600 != 1) )
    {
      if ( a2 != 252 )
      {
        if ( sub_100401C0(v6, v20, a1, v4, (int)&unk_10069608, 788, (int)L"Runtime Error!\n\nProgram: ")
          || (word_10069842 = 0, !GetModuleFileNameW(0, &Filename, 0x104u))
          && sub_100401C0(v7, v8, 0, v4, (int)&Filename, 763, (int)L"<program name unknown>")
          || (v11 = sub_10031399((int)&Filename), v10 = v12, (unsigned int)(v11 + 1) > 0x3C)
          && (v13 = sub_10031399((int)&Filename),
              sub_1003A3FC(
                0,
                v4,
                (int)((char *)&dword_100695C4 + 2 * v13),
                763 - ((signed int)((char *)&dword_100695C4 + 2 * v13 - (char *)&Filename) >> 1),
                (int)L"...",
                3))
          || sub_1004244F(v9, v10, 0, (int)&unk_10069608, 788, (int)L"\n\n")
          || sub_1004244F(v14, v15, 0, (int)&unk_10069608, 788, v4) )
        {
          sub_10036C98(0, v4);
          __asm { int     3               ; Trap to Debugger }
          JUMPOUT(*(int *)sub_1003281D);
        }
        result = (void *)sub_100424FB((const WCHAR *)&unk_10069608, (int)L"Microsoft Visual C++ Runtime Library", 73744);
      }
    }
    else
    {
      result = GetStdHandle(0xFFFFFFF4u);
      v16 = result;
      if ( result )
      {
        if ( result != (void *)-1 )
        {
          v17 = 0;
          do
          {
            Buffer[v17] = *(_BYTE *)(v4 + 2 * v17);
            if ( !*(_WORD *)(v4 + 2 * v17) )
              break;
            ++v17;
          }
          while ( v17 < 0x1F4 );
          v24 = 0;
          v18 = sub_1002CFA0((int)Buffer);
          result = (void *)WriteFile(v16, Buffer, v18, &NumberOfBytesWritten, 0);
        }
      }
    }
  }
  return result;
}
// 1005948C: using guessed type wchar_t aRuntimeErrorPr[26];
// 100594C0: using guessed type wchar_t aProgramNameUnk[23];
// 100594F0: using guessed type wchar_t a___[4];
// 100594F8: using guessed type wchar_t asc_100594F8[3];
// 10059500: using guessed type wchar_t aMicrosoftVisua[37];
// 10067210: using guessed type int __security_cookie;
// 100695C4: using guessed type int dword_100695C4;
// 10069600: using guessed type int dword_10069600;
// 10069842: using guessed type __int16 word_10069842;
// 10032662: using guessed type char Buffer[499];

//----- (1003281D) --------------------------------------------------------
signed int __cdecl sub_1003281D(int a1, int a2, int a3, LCTYPE a4, LPVOID *a5)
{
  int v5; // eax@2
  int v6; // ecx@2
  void *v7; // ebx@2
  int v8; // eax@4
  int v9; // ecx@4
  CHAR *v10; // eax@5
  int v11; // edx@7
  int v13; // eax@17
  int v14; // ecx@17
  int v15; // ebx@17
  WCHAR *v16; // eax@18
  signed int v17; // [sp+10h] [bp-90h]@2
  int cbMultiByte; // [sp+18h] [bp-88h]@2
  char Mem; // [sp+1Ch] [bp-84h]@2
  unsigned int v20; // [sp+9Ch] [bp-4h]@1
  int v21; // [sp+A0h] [bp+0h]@1

  v20 = (unsigned int)&v21 ^ __security_cookie;
  if ( a2 == 1 )
  {
    v7 = &Mem;
    v17 = 0;
    v5 = sub_100427B5((int)&Mem, (int)a5, a1, a3, a4, &Mem, 128);
    cbMultiByte = v5;
    if ( !v5 )
    {
      if ( GetLastError() != 122
        || (v8 = sub_100427B5((int)&Mem, (int)a5, a1, a3, a4, 0, 0), cbMultiByte = v8, !v8)
        || (v10 = (CHAR *)sub_1002EFE1(v9, (int)&Mem, v8, 1u), v7 = v10, !v10) )
        return -1;
      v17 = 1;
      v5 = sub_100427B5((int)v10, (int)a5, a1, a3, a4, v10, cbMultiByte);
      cbMultiByte = v5;
      if ( !v5 )
        goto LABEL_9;
    }
    v11 = (int)sub_1002EFE1(v6, (int)v7, v5, 1u);
    *a5 = (LPVOID)v11;
    if ( !v11 )
    {
      if ( !v17 )
        return -1;
LABEL_9:
      sub_100282F6((int)v7, v7);
      return -1;
    }
    if ( sub_10027F02((int)v7, (int)a5, v11, cbMultiByte, (int)v7, cbMultiByte - 1) )
    {
      sub_10036C98((int)v7, (int)a5);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_100329F4);
    }
    if ( v17 )
      sub_100282F6((int)v7, v7);
  }
  else
  {
    if ( a2 == 2 )
    {
      *a5 = 0;
      v13 = sub_1003183E(a3, a4, 0, 0);
      v15 = v13;
      if ( !v13 || (v16 = (WCHAR *)sub_1002EFE1(v14, v13, v13, 2u), *a5 = v16, !v16) || !sub_1003183E(a3, a4, v16, v15) )
      {
        sub_100282F6(v15, *a5);
        *a5 = 0;
        return -1;
      }
    }
    else
    {
      if ( a2 || (cbMultiByte = 0, !sub_1003183E(a3, a4 | 0x20000000, (WCHAR *)&cbMultiByte, 2)) )
        return -1;
      *(_BYTE *)a5 = cbMultiByte;
    }
  }
  return 0;
}
// 10067210: using guessed type int __security_cookie;

//----- (100329F4) --------------------------------------------------------
void *__cdecl sub_100329F4(void *a1)
{
  void *result; // eax@1

  result = a1;
  dword_10069C30 = a1;
  return result;
}

//----- (10032A01) --------------------------------------------------------
void __usercall sub_10032A01(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // eax@1
  LPVOID v6; // edx@2
  void *v7; // ecx@2

  sub_1002E493(a1, a2, a3, a4, 14);
  v5 = *(_DWORD *)(a5 + 4);
  if ( v5 )
  {
    v7 = dword_10069C38;
    v6 = &unk_10069C34;
    while ( dword_10069C38 )
    {
      if ( *(_DWORD *)dword_10069C38 == v5 )
      {
        *((_DWORD *)v6 + 1) = *((_DWORD *)dword_10069C38 + 1);
        sub_100282F6(a3, v7);
        break;
      }
      v6 = dword_10069C38;
    }
    sub_100282F6(a3, *(LPVOID *)(a5 + 4));
    *(_DWORD *)(a5 + 4) = 0;
  }
  sub_1002E5F7(14);
}

//----- (10032A72) --------------------------------------------------------
int __cdecl sub_10032A72()
{
  int v0; // esi@1
  HMODULE v1; // esi@1
  int v2; // eax@3
  HMODULE v3; // eax@3
  int v4; // eax@4
  int result; // eax@6
  char v6; // [sp+8h] [bp-14h]@9
  int v7; // [sp+18h] [bp-4h]@1

  v1 = GetModuleHandleW(L"kernel32.dll");
  v7 = (int)GetProcAddress(v1, "SetThreadGroupAffinity");
  v0 = (int)GetProcAddress(v1, "GetThreadGroupAffinity");
  if ( !v7 || !v0 )
  {
    v4 = GetLastError();
    if ( v4 > 0 )
LABEL_8:
      v4 = (unsigned __int16)v4 | 0x80070000;
LABEL_9:
    sub_100249F4((int)&v6, v4);
    sub_1002D02B((int)&v6, (int)&unk_10060498);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10032B24);
  }
  dword_10069C40 = sub_1002C373(v7);
  dword_10069C44 = sub_1002C373(v0);
  v3 = GetModuleHandleW(L"kernel32.dll");
  v2 = (int)GetProcAddress(v3, "GetCurrentProcessorNumberEx");
  if ( !v2 )
  {
    v4 = GetLastError();
    if ( v4 > 0 )
      goto LABEL_8;
    goto LABEL_9;
  }
  result = sub_1002C373(v2);
  dword_10069C3C = result;
  return result;
}
// 10069C3C: using guessed type int dword_10069C3C;
// 10069C40: using guessed type int dword_10069C40;
// 10069C44: using guessed type int dword_10069C44;

//----- (10032B24) --------------------------------------------------------
DWORD __cdecl sub_10032B24(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent)
{
  DWORD result; // eax@2

  do
  {
    result = DeleteTimerQueueTimer(TimerQueue, Timer, CompletionEvent);
    if ( result )
      break;
    result = GetLastError();
  }
  while ( result != 997 );
  return result;
}

//----- (10032B4B) --------------------------------------------------------
int __cdecl sub_10032B4B(int a1)
{
  int v2; // eax@1
  int v3; // ST00_4@1

  v2 = sub_1002C373(dword_10069C3C);
  return ((int (__thiscall *)(int, int))v2)(v3, a1);
}
// 10069C3C: using guessed type int dword_10069C3C;

//----- (10032B61) --------------------------------------------------------
int __usercall sub_10032B61<eax>(int a1<ebx>, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // ST04_4@1
  int v5; // eax@2
  int v6; // eax@4
  int v7; // ebx@4
  int v8; // eax@5
  int v10; // [sp-4h] [bp-24h]@5
  char v11; // [sp+Ch] [bp-14h]@11
  int (__stdcall **v12)(char); // [sp+10h] [bp-10h]@5
  int v13; // [sp+1Ch] [bp-4h]@5

  sub_10031046(0, a2);
  if ( ((int (__thiscall *)(int))GetLastError)(v4) != 122 )
  {
    v5 = GetLastError();
    if ( v5 > 0 )
LABEL_10:
      v5 = (unsigned __int16)v5 | 0x80070000;
LABEL_11:
    sub_100249F4((int)&v11, v5);
    v10 = (int)&unk_10060498;
    v8 = (int)&v11;
    goto LABEL_12;
  }
  v6 = sub_10028264(v2, v3, a1, a2, *(_DWORD *)a2);
  v7 = v6;
  if ( !v6 )
  {
    v13 = (int)"bad allocation";
    sub_100236AC((int)&v12, (int)&v13, 1);
    v12 = &off_100542A4;
    v10 = (int)&unk_1005F828;
    v8 = (int)&v12;
LABEL_12:
    sub_1002D02B(v8, v10);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10032BFC);
  }
  if ( !sub_10031046(v6, a2) )
  {
    v5 = GetLastError();
    if ( v5 > 0 )
      goto LABEL_10;
    goto LABEL_11;
  }
  return v7;
}
// 10032BFC: using guessed type int __cdecl sub_10032BFC(int, int);
// 100542A4: using guessed type int (__stdcall *off_100542A4)(char);

//----- (10032BFC) --------------------------------------------------------
int __cdecl sub_10032BFC(int a1, int a2)
{
  FARPROC v2; // eax@1
  int v3; // edi@1
  HMODULE v4; // eax@1
  int v5; // eax@2
  int v6; // edx@4
  int v7; // ecx@4
  int v8; // ebx@7
  int v9; // eax@8
  int v11; // [sp-10h] [bp-30h]@7
  int v12; // [sp-4h] [bp-24h]@4
  char v13; // [sp+Ch] [bp-14h]@12
  int (__stdcall **v14)(char); // [sp+10h] [bp-10h]@8
  int v15; // [sp+1Ch] [bp-4h]@8

  v4 = GetModuleHandleW(L"kernel32.dll");
  v2 = GetProcAddress(v4, "GetLogicalProcessorInformationEx");
  v3 = (int)v2;
  if ( !v2 )
  {
    v5 = GetLastError();
    if ( v5 > 0 )
LABEL_11:
      v5 = (unsigned __int16)v5 | 0x80070000;
LABEL_12:
    sub_100249F4((int)&v13, v5);
    v12 = (int)&unk_10060498;
    v9 = (int)&v13;
    goto LABEL_13;
  }
  v12 = a2;
  ((void (__cdecl *)(int, _DWORD))v2)(a1, 0);
  if ( GetLastError() != 122 )
    goto LABEL_17;
  v8 = sub_10028264(v6, v7, a2, v3, *(_DWORD *)a2);
  if ( !v8 )
  {
    v15 = (int)"bad allocation";
    sub_100236AC((int)&v14, (int)&v15, 1);
    v14 = &off_100542A4;
    v9 = (int)&v14;
LABEL_13:
    sub_1002D02B(v9, v12);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10032CB6);
  }
  if ( !((int (__thiscall *)(int))v3)(v11) )
  {
LABEL_17:
    v5 = GetLastError();
    if ( v5 > 0 )
      goto LABEL_11;
    goto LABEL_12;
  }
  return v8;
}
// 10032BFC: using guessed type int __cdecl sub_10032BFC(int, int);
// 100542A4: using guessed type int (__stdcall *off_100542A4)(char);

//----- (10032CB6) --------------------------------------------------------
signed int __cdecl sub_10032CB6(int a1, int a2)
{
  int v2; // eax@2
  int v3; // ST08_4@2
  HANDLE v4; // eax@3
  ULONG_PTR SystemAffinityMask; // [sp+0h] [bp-8h]@3
  ULONG_PTR ProcessAffinityMask; // [sp+4h] [bp-4h]@3

  if ( sub_10034C33() < 4 )
  {
    v4 = GetCurrentProcess();
    GetProcessAffinityMask(v4, &ProcessAffinityMask, &SystemAffinityMask);
    *(_WORD *)(a2 + 4) = 0;
    *(_DWORD *)a2 = ProcessAffinityMask;
  }
  else
  {
    v2 = sub_1002C373(dword_10069C44);
    ((void (__thiscall *)(int, int, int))v2)(v3, a1, a2);
  }
  return 1;
}
// 10034C33: using guessed type int sub_10034C33(void);
// 10069C44: using guessed type int dword_10069C44;

//----- (10032D03) --------------------------------------------------------
signed int __cdecl sub_10032D03(HANDLE hThread, DWORD_PTR *a2)
{
  int v2; // eax@2
  int v3; // ST08_4@2

  if ( sub_10034C33() < 4 )
  {
    SetThreadAffinityMask(hThread, *a2);
  }
  else
  {
    v2 = sub_1002C373(dword_10069C40);
    ((void (__thiscall *)(int, HANDLE, DWORD_PTR *, _DWORD))v2)(v3, hThread, a2, 0);
  }
  return 1;
}
// 10034C33: using guessed type int sub_10034C33(void);
// 10069C40: using guessed type int dword_10069C40;

//----- (10032D3B) --------------------------------------------------------
int __thiscall sub_10032D3B(int this, int a2)
{
  int v3; // esi@1

  v3 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  sub_10032CB6(a2, this);
  return v3;
}

//----- (10032D5C) --------------------------------------------------------
#error "10032E50: call analysis failed (funcsize=78)"

//----- (10032E56) --------------------------------------------------------
int __userpurge sub_10032E56<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_100559E0;
  return v4;
}
// 100559E0: using guessed type int (__stdcall *off_100559E0)(char);

//----- (10032E7B) --------------------------------------------------------
int __usercall sub_10032E7B<eax>(int a1<ebp>)
{
  unsigned int v1; // edi@1
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // ebx@2
  int v5; // ecx@3
  int v6; // ecx@6
  void *v7; // eax@8
  int v8; // ecx@8
  int v9; // ST08_4@8

  sub_1002D0B8();
  v2 = v3;
  *(_DWORD *)(a1 - 16) = v3;
  *(_DWORD *)v3 = off_100595E4;
  v1 = 0;
  *(_DWORD *)(a1 - 4) = 1;
  if ( *(_DWORD *)(v3 + 24) )
  {
    v4 = 0;
    do
    {
      v5 = *(_DWORD *)(v4 + *(_DWORD *)(v2 + 72) + 32);
      if ( v5 )
        sub_100226C2(v5, 3);
      ++v1;
      v4 += 40;
    }
    while ( v1 < *(_DWORD *)(v2 + 24) );
  }
  v6 = *(_DWORD *)(v2 + 72);
  if ( v6 )
    sub_10032F42(v6, 3);
  sub_1002401B(*(LPVOID *)(v2 + 68));
  v7 = *(void **)(v2 + 140);
  v8 = v9;
  if ( v7 )
    VirtualFree(v7, 0, 0x8000u);
  ((void (__thiscall *)(int, _DWORD))CloseHandle)(v8, *(_DWORD *)(v2 + 80));
  sub_1002401B(*(LPVOID *)(v2 + 84));
  if ( *(_DWORD *)(v2 + 76) )
  {
    CloseHandle(*(HANDLE *)(v2 + 76));
    sub_1002401B(*(LPVOID *)(v2 + 88));
    sub_1002401B(*(LPVOID *)(v2 + 92));
  }
  *(_BYTE *)(a1 - 4) = 0;
  sub_10044341(a1);
  *(_DWORD *)(a1 - 4) = -1;
  sub_100242B2((LPCRITICAL_SECTION)(v2 + 44));
  return sub_1002D086(4);
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 100595E4: using guessed type int (*off_100595E4[2])();

//----- (10032F42) --------------------------------------------------------
int __thiscall sub_10032F42(int this, char a2)
{
  void *v2; // esi@1
  int result; // eax@4

  v2 = (void *)this;
  if ( a2 & 2 )
  {
    sub_10023E14(this, 40, *(_DWORD *)(this - 4), (void (__thiscall *)(_DWORD))sub_10032E71);
    if ( a2 & 1 )
      sub_1002401B((char *)v2 - 4);
    result = (int)((char *)v2 - 4);
  }
  else
  {
    sub_1002404A(*(LPVOID *)(this + 36));
    if ( a2 & 1 )
      sub_1002404A(v2);
    result = (int)v2;
  }
  return result;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10032E71: using guessed type int sub_10032E71();

//----- (10032F90) --------------------------------------------------------
int __thiscall sub_10032F90(int this, int a2)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 4);
  if ( result )
  {
    *(_DWORD *)(a2 + 24) = *(_DWORD *)(result + 24);
    *(_DWORD *)(a2 + 28) = *(_DWORD *)(this + 4);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 4) + 24) + 28) = a2;
    result = *(_DWORD *)(this + 4);
    *(_DWORD *)(result + 24) = a2;
  }
  else
  {
    *(_DWORD *)(a2 + 24) = a2;
    *(_DWORD *)(a2 + 28) = a2;
  }
  *(_DWORD *)(this + 4) = a2;
  ++*(_DWORD *)this;
  return result;
}

//----- (10032FCA) --------------------------------------------------------
unsigned int __thiscall sub_10032FCA(int this, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  unsigned int v6; // esi@5
  int v7; // edx@6
  unsigned int v8; // esi@10
  int v9; // edx@11

  v4 = a3;
  v5 = a2;
  if ( a2 >= a3 )
  {
    v8 = 0;
    if ( a4 )
    {
      do
      {
        v9 = *(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v8++);
        *(_DWORD *)(v9 + 4) = *(_DWORD *)(v9 + 36) - *(_DWORD *)(*(_DWORD *)(v9 + 16) + 160);
      }
      while ( v8 < a4 );
      v4 = a3;
    }
    v5 = v4;
  }
  else
  {
    if ( a4 == 1 )
    {
      *(_DWORD *)(**(_DWORD **)(this + 92) + 4) = a2;
    }
    else
    {
      if ( a4 )
      {
        v6 = 0;
        do
        {
          v7 = *(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v6++);
          *(double *)(v7 + 8) = (double)(unsigned int)(*(_DWORD *)(v7 + 36) - *(_DWORD *)(*(_DWORD *)(v7 + 16) + 160))
                              * (double)a2
                              / (double)a3;
        }
        while ( v6 < a4 );
        v5 = a2;
      }
      sub_100364F2(*(_DWORD *)(this + 92), a4);
    }
  }
  return v5;
}

//----- (1003309A) --------------------------------------------------------
int __thiscall sub_1003309A(int this, int a2)
{
  int result; // eax@1

  result = sub_10034982(this, *(_WORD *)(a2 + 4));
  if ( result )
  {
    result = *(_DWORD *)result;
    *(_DWORD *)a2 &= result;
  }
  else
  {
    *(_DWORD *)a2 = 0;
  }
  return result;
}

//----- (100330BD) --------------------------------------------------------
int __cdecl sub_100330BD(int a1)
{
  int result; // eax@1
  int v2; // [sp+4h] [bp-Ch]@1
  int v3; // [sp+8h] [bp-8h]@1
  int v4; // [sp+Ch] [bp-4h]@1

  v3 = 0;
  v4 = 0;
  LOWORD(v3) = 0;
  v2 = *(_DWORD *)a1;
  sub_100330EC((int)&v2);
  result = v2;
  *(_DWORD *)a1 = v2;
  return result;
}

//----- (100330EC) --------------------------------------------------------
int __cdecl sub_100330EC(int a1)
{
  int result; // eax@1
  int v2; // ecx@2

  result = a1;
  if ( *(_DWORD *)a1 )
  {
    v2 = dword_10069C5C;
    if ( dword_10069C5C || (v2 = dword_10069C58, dword_10069C58) )
      result = sub_1003309A(v2, a1);
  }
  return result;
}
// 10069C58: using guessed type int dword_10069C58;
// 10069C5C: using guessed type int dword_10069C5C;

//----- (10033113) --------------------------------------------------------
signed int __thiscall sub_10033113(DWORD_PTR *this, HANDLE hThread)
{
  return sub_10032D03(hThread, this);
}

//----- (10033125) --------------------------------------------------------
int __usercall sub_10033125<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1
  HANDLE v5; // eax@1
  int v6; // eax@2
  int v7; // eax@7
  int v8; // edx@7
  int v9; // ecx@7
  int v10; // esi@7
  int v11; // ecx@7
  int v12; // ST08_4@7
  int v13; // eax@10
  int v14; // ST08_4@10
  int v15; // edx@14
  int v16; // esi@14
  int v17; // eax@15
  int v18; // edx@15
  int v19; // ST08_4@15
  int v21; // [sp-8h] [bp-8h]@14

  sub_1002D0EB();
  v5 = GetCurrentProcess();
  if ( !GetProcessAffinityMask(v5, &ProcessAffinityMask, &SystemAffinityMask) )
  {
    v6 = GetLastError();
    if ( v6 > 0 )
      v6 = (unsigned __int16)v6 | 0x80070000;
    sub_100249F4(a2 - 48, v6);
    sub_1002D02B(a2 - 48, (int)&unk_10060498);
  }
  if ( ProcessAffinityMask != SystemAffinityMask )
  {
    if ( dword_10069C70 < 4 )
    {
      v16 = sub_10027EB3(v3, v4, a1, a3, 8);
      v4 = v21;
      *(_DWORD *)(a2 - 32) = v16;
      *(_DWORD *)(a2 - 4) = 0;
      if ( v16 )
      {
        v17 = sub_10027EB3(v15, v21, a1, a3, 12);
        v18 = v17;
        v4 = v19;
        if ( v17 )
        {
          v4 = ProcessAffinityMask;
          *(_DWORD *)v17 = 0;
          *(_DWORD *)(v17 + 4) = 0;
          *(_DWORD *)(v17 + 8) = 0;
          *(_WORD *)(v17 + 4) = 0;
          *(_DWORD *)v17 = v4;
        }
        else
        {
          v18 = 0;
        }
        *(_WORD *)v16 = 1;
        *(_DWORD *)(v16 + 4) = v18;
      }
      else
      {
        v16 = 0;
      }
      dword_10069C5C = v16;
    }
    else
    {
      v7 = (int)GetCurrentThread();
      sub_10032D3B(a2 - 28, v7);
      v10 = sub_10027EB3(v8, v11, a1, a3, 12);
      v9 = v12;
      if ( v10 )
      {
        v9 = *(_WORD *)(a2 - 24);
        v8 = ProcessAffinityMask;
        *(_DWORD *)v10 = 0;
        *(_DWORD *)(v10 + 4) = 0;
        *(_DWORD *)(v10 + 8) = 0;
        a3 = v10 + 12;
        *(_WORD *)(v10 + 4) = v9;
        *(_DWORD *)v10 = v8;
      }
      else
      {
        v10 = 0;
      }
      v13 = sub_10027EB3(v8, v9, a1, a3, 8);
      v4 = v14;
      if ( v13 )
      {
        v4 = 1;
        *(_WORD *)v13 = 1;
        *(_DWORD *)(v13 + 4) = v10;
      }
      else
      {
        v13 = 0;
      }
      dword_10069C5C = v13;
    }
  }
  return sub_1002D09A(v4);
}
// 1002D09A: using guessed type int __thiscall sub_1002D09A(_DWORD);
// 10069C5C: using guessed type int dword_10069C5C;
// 10069C70: using guessed type int dword_10069C70;

//----- (1003323C) --------------------------------------------------------
void __usercall sub_1003323C(int a1<ebx>)
{
  sub_100282F6(a1, dword_10069C78);
  dword_10069C78 = 0;
  dword_10069C74 = 0;
}
// 10069C74: using guessed type int dword_10069C74;

//----- (10033257) --------------------------------------------------------
int __thiscall sub_10033257(void *this, int a2)
{
  int result; // eax@1
  unsigned int v3; // ecx@1
  void *v4; // ebx@1
  int ebp0; // ebp@0
  int v6; // esi@2
  int v7; // edi@3
  int v8; // ecx@4
  signed int v9; // edx@5
  int v10; // eax@6
  int v11; // edx@7
  int v12; // ecx@7
  char v13; // zf@12
  int v14; // eax@22
  int v15; // [sp+4h] [bp-18h]@2
  unsigned int v16; // [sp+8h] [bp-14h]@1
  signed int v17; // [sp+Ch] [bp-10h]@5
  int v18; // [sp+10h] [bp-Ch]@5
  signed int v19; // [sp+14h] [bp-8h]@5
  int v20; // [sp+24h] [bp+8h]@4

  result = *(_DWORD *)(a2 + 16);
  v4 = this;
  v3 = 0;
  v16 = 0;
  if ( *((_DWORD *)v4 + 6) )
  {
    v6 = result + 4;
    v15 = -4 - result;
    do
    {
      v7 = 0;
      if ( *(_DWORD *)v6 )
      {
        v8 = 0;
        v20 = 0;
        do
        {
          v17 = 0;
          v9 = 1;
          result = v8 + *(_DWORD *)(v6 + 44);
          v18 = v8 + *(_DWORD *)(v6 + 44);
          v19 = 1;
          if ( *((_DWORD *)v4 + 2) > 1u )
          {
            do
            {
              v10 = *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v4 + 21) + 4 * v9) + 16);
              if ( *(_DWORD *)(v10 + 108) )
              {
                v12 = *(_DWORD *)(v10 + 16) + v6 + v15;
                v11 = v20 + *(_DWORD *)(v12 + 48);
                if ( *(_DWORD *)v11 == 5 )
                {
                  if ( *(_DWORD *)v18 != 4 )
                  {
                    ++**(_DWORD **)(v11 + 20);
                    v14 = *(_DWORD *)(v12 + 48);
                    v8 = v20;
                    *(_DWORD *)(v20 + v14) = 4;
                    goto LABEL_16;
                  }
                  if ( *(_DWORD *)(v18 + 24) || *(_BYTE *)(v11 + 48) || v17 )
                  {
                    sub_10043F22(ebp0, v12, v7);
                  }
                  else
                  {
                    ++**(_DWORD **)(v11 + 20);
                    v13 = *(_BYTE *)(v11 + 49) == 0;
                    *(_DWORD *)v11 = 4;
                    if ( v13 )
                      sub_10044106(v10, v12, v7);
                    v17 = 1;
                  }
                }
                v8 = v20;
              }
LABEL_16:
              result = v19 + 1;
              v19 = result;
              v9 = result;
            }
            while ( (unsigned int)result < *((_DWORD *)v4 + 2) );
          }
          ++v7;
          v8 += 52;
          v20 = v8;
        }
        while ( (unsigned int)v7 < *(_DWORD *)v6 );
        v3 = v16;
      }
      ++v3;
      v6 += 52;
      v16 = v3;
    }
    while ( v3 < *((_DWORD *)v4 + 6) );
  }
  return result;
}

//----- (10033364) --------------------------------------------------------
int __thiscall sub_10033364(int this)
{
  int v1; // edi@1
  int v2; // esi@1

  v1 = this;
  v2 = *(_DWORD *)(this + 188);
  if ( v2 >= (unsigned int)(sub_100336B7(this) + 1) )
    v2 = sub_100336B7(v1) + 1;
  return v2;
}

//----- (10033387) --------------------------------------------------------
int __thiscall sub_10033387(int this)
{
  int v1; // edx@1
  int v2; // edi@1
  int v3; // esi@1
  int v4; // eax@1

  v3 = this;
  v2 = *(_DWORD *)(this + 184);
  v4 = sub_10035370(this);
  v1 = *(_DWORD *)(v3 + 188);
  if ( v1 >= (unsigned int)(v2 + v4 + 1) )
    v1 = sub_10035370(v3) + v2 + 1;
  return v1;
}

//----- (100333B4) --------------------------------------------------------
int __usercall sub_100333B4<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // ebx@1
  int v4; // esi@1
  unsigned int v5; // eax@1
  signed __int64 v7; // qax@1
  int v8; // ecx@2
  int v9; // edx@3
  signed int v10; // edi@3
  unsigned int v11; // esi@3
  const void *v12; // eax@3
  signed __int64 v14; // qax@3
  int v15; // eax@4
  int v16; // ecx@5
  signed int v17; // ST0C_4@9
  int v18; // edx@10
  int v19; // ecx@10
  int v20; // edi@11
  int v21; // esi@11
  int v23; // [sp+Ch] [bp-1Ch]@1
  int v24; // [sp+10h] [bp-18h]@1
  int v25; // [sp+14h] [bp-14h]@2
  unsigned int v26; // [sp+18h] [bp-10h]@1
  int v27; // [sp+1Ch] [bp-Ch]@10
  unsigned int v28; // [sp+20h] [bp-8h]@9
  const void *v29; // [sp+24h] [bp-4h]@3

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 24);
  _ECX = 0;
  v7 = 52i64 * v5;
  __asm { seto    cl }
  v24 = v4;
  v3 = sub_10021CF0(SHIDWORD(v7), v7 | -_ECX, a2, a3, v7 | -_ECX);
  v23 = v3;
  sub_10030CF0((void *)v3, 0, 52 * *(_DWORD *)(v4 + 24));
  v26 = 0;
  if ( *(_DWORD *)(v4 + 24) > 0u )
  {
    v8 = 0;
    v25 = 0;
    do
    {
      v12 = (const void *)(v8 + *(_DWORD *)(v4 + 72));
      memcpy((void *)v3, v12, 0x18u);
      v11 = *(_DWORD *)(v3 + 4);
      v29 = v12;
      _ECX = 0;
      v10 = 52;
      v14 = 52i64 * v11;
      __asm { seto    cl }
      v9 = sub_10021CF0(SHIDWORD(v14), v14 | -_ECX, v3, 52, v14 | -_ECX);
      if ( v9 )
      {
        v15 = v11 - 1;
        if ( (signed int)(v11 - 1) >= 0 )
        {
          v16 = v9 + 12;
          do
          {
            *(_DWORD *)v16 = 0;
            *(_DWORD *)(v16 + 4) = 0;
            v16 += 52;
            --v15;
          }
          while ( v15 >= 0 );
        }
      }
      else
      {
        v9 = 0;
      }
      v17 = 52 * *(_DWORD *)(v3 + 4);
      *(_DWORD *)(v3 + 48) = v9;
      sub_10030CF0((void *)v9, 0, v17);
      v28 = 0;
      if ( *(_DWORD *)(v3 + 4) )
      {
        v18 = 0;
        v19 = 0;
        v27 = 0;
        do
        {
          v20 = v18 + *(_DWORD *)(v3 + 48);
          v21 = v19 + *((_DWORD *)v29 + 8);
          *(_DWORD *)v20 = *(_DWORD *)v21;
          v21 += 4;
          v20 += 4;
          *(_DWORD *)v20 = *(_DWORD *)v21;
          *(_DWORD *)(v20 + 4) = *(_DWORD *)(v21 + 4);
          *(_DWORD *)(v18 + *(_DWORD *)(v3 + 48)) = 1;
          v10 = 52;
          *(_DWORD *)(v18 + *(_DWORD *)(v3 + 48) + 20) = *((_DWORD *)v29 + 8) + 16 + v19;
          v19 = v27 + 36;
          v18 += 52;
          ++v28;
          v27 += 36;
        }
        while ( v28 < *(_DWORD *)(v3 + 4) );
      }
      v4 = v24;
      v8 = v25 + 40;
      v3 += v10;
      ++v26;
      v25 += 40;
    }
    while ( v26 < *(_DWORD *)(v24 + 24) );
    v3 = v23;
  }
  return v3;
}

//----- (100334E1) --------------------------------------------------------
void __thiscall sub_100334E1(LPVOID lpParameter)
{
  HANDLE v1; // eax@1
  LPVOID v2; // esi@1
  int v3; // eax@2
  char v4; // [sp+4h] [bp-10h]@9

  v2 = lpParameter;
  v1 = sub_1002C433(0, 0x10000u, (LPTHREAD_START_ROUTINE)StartAddress, lpParameter, 0, 0);
  *((_DWORD *)v2 + 19) = v1;
  if ( !v1 )
  {
    v3 = GetLastError();
    if ( v3 > 0 )
LABEL_8:
      v3 = (unsigned __int16)v3 | 0x80070000;
LABEL_9:
    sub_100249F4((int)&v4, v3);
    sub_1002D02B((int)&v4, (int)&unk_10060498);
    __asm { int     3               ; Trap to Debugger }
    return;
  }
  if ( !SetThreadPriority(v1, 15) )
  {
    v3 = GetLastError();
    if ( v3 > 0 )
      goto LABEL_8;
    goto LABEL_9;
  }
}

//----- (10033559) --------------------------------------------------------
#error "100335AD: call analysis failed (funcsize=32)"

//----- (100335B5) --------------------------------------------------------
int __usercall sub_100335B5<eax>(int a1<ebp>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // eax@2
  int v6; // edx@3
  int v7; // ecx@3
  int v8; // esi@3
  int v9; // esi@6
  int v10; // eax@8

  sub_1002D0B8();
  *(_DWORD *)(a1 - 16) = &dword_10069CB4;
  sub_10028AD5(&dword_10069CB4);
  v2 = dword_10069C4C;
  *(_DWORD *)(a1 - 4) = 0;
  if ( v2 )
  {
    v8 = sub_1002C373(v2);
    if ( sub_100366B1((void *)v8) )
      goto LABEL_9;
    v5 = sub_10027EB3(v6, v7, 0, a2, 144);
    *(_DWORD *)(a1 - 20) = v5;
    *(_BYTE *)(a1 - 4) = 2;
  }
  else
  {
    v5 = sub_10027EB3(v3, v4, 0, a2, 144);
    *(_DWORD *)(a1 - 20) = v5;
    *(_BYTE *)(a1 - 4) = 1;
  }
  if ( v5 )
    v9 = sub_10032D5C(v5);
  else
    v9 = 0;
  v10 = *(_DWORD *)v9;
  *(_BYTE *)(a1 - 4) = 0;
  (*(void (__thiscall **)(int))v10)(v9);
  dword_10069C4C = sub_1002C373(v9);
LABEL_9:
  dword_10069CB4 = 0;
  return sub_1002D086(8);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10032D5C: using guessed type int __thiscall sub_10032D5C(_DWORD);
// 10069C4C: using guessed type int dword_10069C4C;
// 10069CB4: using guessed type int dword_10069CB4;

//----- (1003364A) --------------------------------------------------------
int __thiscall sub_1003364A(int this, int a2, int a3)
{
  int v3; // ecx@1
  int v4; // ebx@1
  struct _RTL_CRITICAL_SECTION *v5; // esi@1
  int v6; // edi@1
  int v7; // ecx@2
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v6 = this;
  v10 = this;
  v5 = (struct _RTL_CRITICAL_SECTION *)(this + 44);
  v4 = 0;
  v9 = this + 44;
  sub_100244EB((LPCRITICAL_SECTION)(this + 44));
  v3 = *(_DWORD *)(v6 + 100);
  if ( v3 )
    v7 = *(_DWORD *)(v3 + 24);
  else
    v7 = 0;
  if ( v7 )
  {
    do
    {
      v4 += *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 16) + 52 * a2 + 48) + 52 * a3 + 24);
      if ( v7 == *(_DWORD *)(v10 + 100) )
        v7 = 0;
      else
        v7 = *(_DWORD *)(v7 + 24);
    }
    while ( v7 );
    v5 = (struct _RTL_CRITICAL_SECTION *)v9;
  }
  sub_10024670(v5);
  return v4;
}

//----- (100336B7) --------------------------------------------------------
int __thiscall sub_100336B7(int this)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 188);
  if ( result >= (unsigned int)(*(_DWORD *)(this + 128) + *(_DWORD *)(this + 184)) )
    result = *(_DWORD *)(this + 128) + *(_DWORD *)(this + 184);
  return result;
}

//----- (100336D0) --------------------------------------------------------
int __thiscall sub_100336D0(int this, int a2)
{
  void *v2; // ebx@1
  unsigned int v3; // esi@1
  int v4; // ebx@2
  LPVOID *v5; // edi@2

  v2 = (void *)a2;
  v3 = 0;
  if ( *(_DWORD *)(this + 24) )
  {
    v5 = (LPVOID *)(a2 + 48);
    v4 = this;
    do
    {
      sub_1002401B(*v5);
      ++v3;
      v5 += 13;
    }
    while ( v3 < *(_DWORD *)(v4 + 24) );
    v2 = (void *)a2;
  }
  return sub_1002401B(v2);
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (1003370A) --------------------------------------------------------
void __usercall sub_1003370A(int a1<ecx>, int a2<ebx>)
{
  int v2; // eax@1
  __int64 v3; // qcx@1
  int v4; // edi@1
  int v5; // esi@1
  signed __int64 v7; // qax@1
  int v8; // eax@1
  signed int v9; // ST10_4@1
  signed __int64 v11; // qax@1
  void *v12; // ecx@2
  int v13; // edx@4
  signed int v14; // ST14_4@4
  int v15; // edx@5
  int v16; // eax@10
  int v17; // edx@10
  int v18; // esi@10
  int v19; // eax@13
  unsigned __int8 v20; // sf@13
  unsigned __int8 v21; // of@13
  int v22; // esi@17
  int v23; // esi@18
  int v24; // edx@19
  LPVOID v25; // esi@23
  ULONG_PTR v26; // esi@25
  int v27; // edx@28
  int v28; // eax@31
  int v29; // eax@39
  unsigned int v30; // ebx@43
  int v31; // edx@44
  unsigned int v32; // ecx@45
  int v33; // esi@46
  int v34; // [sp+Ch] [bp-14h]@10
  void *v35; // [sp+Ch] [bp-14h]@38
  int v36; // [sp+10h] [bp-10h]@6
  int v37; // [sp+10h] [bp-10h]@29
  int v38; // [sp+14h] [bp-Ch]@10
  int v39; // [sp+14h] [bp-Ch]@28
  int v40; // [sp+18h] [bp-8h]@5
  int v41; // [sp+1Ch] [bp-4h]@5
  int v42; // [sp+1Ch] [bp-4h]@28

  v4 = a1;
  _ECX = 0;
  *(_DWORD *)(v4 + 20) = dword_10069C6C;
  *(_DWORD *)(v4 + 24) = dword_10069C68;
  *(_DWORD *)(v4 + 28) = dword_10069C60;
  v7 = 12i64 * *(_DWORD *)(v4 + 20);
  __asm { seto    cl }
  v8 = sub_10021CF0(SHIDWORD(v7), v7 | -_ECX, a2, v4, v7 | -_ECX);
  v9 = 12 * *(_DWORD *)(v4 + 20);
  *(_DWORD *)(v4 + 68) = v8;
  sub_10030CF0((void *)v8, 0, v9);
  v5 = *(_DWORD *)(v4 + 24);
  _ECX = 0;
  v11 = 40i64 * *(_DWORD *)(v4 + 24);
  __asm { seto    cl }
  v3 = (_DWORD)v11 | (unsigned int)-_ECX;
  v2 = sub_10021CF0(SHIDWORD(v11), v3 + 4, SHIDWORD(v3), v4, (v3 + 4) | -((_DWORD)v3 >= 0xFFFFFFFCu));
  if ( v2 )
  {
    *(_DWORD *)v2 = v5;
    v12 = (void *)(v2 + 4);
  }
  else
  {
    v12 = 0;
  }
  v14 = 40 * *(_DWORD *)(v4 + 24);
  *(_DWORD *)(v4 + 72) = v12;
  sub_10030CF0(v12, 0, v14);
  if ( dword_10069C70 >= 4 )
  {
    LODWORD(v3) = 0;
    v15 = 0;
    HIDWORD(v3) = dword_10069C78;
    v40 = 0;
    v41 = 0;
    if ( dword_10069C74 )
    {
      v36 = 0;
      while ( 1 )
      {
        if ( *HIDWORD(v3) == 1 )
        {
          if ( !byte_10069C64 )
          {
            if ( *(_DWORD *)(HIDWORD(v3) + 32) )
            {
              v22 = 40 * v3;
              sub_10034F56(
                v15,
                40 * v3 + *(_DWORD *)(v4 + 72),
                SHIDWORD(v3),
                v4,
                v4,
                v3,
                *(_WORD *)(HIDWORD(v3) + 36),
                *(void **)(HIDWORD(v3) + 32),
                0,
                0);
              ++v41;
              v15 = v40;
              *(_DWORD *)(v22 + *(_DWORD *)(v4 + 72) + 20) = *(_DWORD *)(HIDWORD(v3) + 8);
            }
          }
          v23 = *(_DWORD *)(HIDWORD(v3) + 32);
          if ( !v23 )
            goto LABEL_21;
          v24 = v36 + *(_DWORD *)(v4 + 68);
          LODWORD(v3) = *(_WORD *)(HIDWORD(v3) + 36);
          v36 += 12;
          *(_DWORD *)(v24 + 8) = *(_DWORD *)(HIDWORD(v3) + 8);
          *(_DWORD *)(v24 + 4) = v3;
          *(_DWORD *)v24 = v23;
        }
        else
        {
          if ( *HIDWORD(v3) != 3 || !byte_10069C64 )
            goto LABEL_21;
          v17 = 0;
          v16 = HIDWORD(v3) + 32;
          v18 = 40 * v3;
          v34 = 0;
          v38 = HIDWORD(v3) + 32;
          do
          {
            if ( *(_DWORD *)v16 )
            {
              sub_10034F56(
                v17,
                v18 + *(_DWORD *)(v4 + 72),
                SHIDWORD(v3),
                v4,
                v4,
                v3,
                *(_WORD *)(v16 + 4),
                *(void **)v16,
                0,
                0);
              v16 = v38;
              v17 = v34;
              LODWORD(v3) = v41++ + 1;
              v18 += 40;
            }
            v38 = v16 + 12;
            v19 = *(_WORD *)(HIDWORD(v3) + 30);
            ++v17;
            v21 = __SETO__(v17, v19);
            v20 = v17 - v19 < 0;
            v16 = v38;
            v34 = v17;
          }
          while ( v20 ^ v21 );
        }
        v15 = v40;
LABEL_21:
        v15 += *(_DWORD *)(HIDWORD(v3) + 4);
        HIDWORD(v3) += *(_DWORD *)(HIDWORD(v3) + 4);
        LODWORD(v3) = v41;
        v40 = v15;
        if ( v15 >= (unsigned int)dword_10069C74 )
          goto LABEL_41;
      }
    }
    goto LABEL_41;
  }
  v25 = dword_10069C78;
  if ( dword_10069C78 )
  {
    LOWORD(v3) = 0;
    v27 = 0;
    v39 = 0;
    v42 = 0;
    if ( (unsigned int)dword_10069C74 <= 0 )
    {
LABEL_41:
      sub_1003323C(SHIDWORD(v3));
      goto LABEL_42;
    }
    v37 = 0;
    while ( 1 )
    {
      if ( *((_DWORD *)v25 + 1) == 1 )
      {
        if ( byte_10069C64 )
          goto LABEL_38;
        if ( *(_DWORD *)v25 )
        {
          sub_10034F56(v27, HIDWORD(v3) + *(_DWORD *)(v4 + 72), SHIDWORD(v3), v4, v4, v3, 0, *(void **)v25, 0, 0);
          v27 = v39;
          *(_DWORD *)(HIDWORD(v3) + *(_DWORD *)(v4 + 72) + 20) = *((_DWORD *)v25 + 2);
          ++v42;
          LODWORD(v3) = v42;
          v3 += 171798691840i64;
LABEL_38:
          v35 = *(void **)v25;
          if ( *(_DWORD *)v25 )
          {
            LODWORD(v3) = v37 + *(_DWORD *)(v4 + 68);
            v29 = *((_DWORD *)v25 + 2);
            *(_DWORD *)(v3 + 4) = 0;
            v37 += 12;
            *(_DWORD *)(v3 + 8) = v29;
            *(_DWORD *)v3 = v35;
            LOWORD(v3) = v42;
          }
          goto LABEL_40;
        }
      }
      else
      {
        v28 = *((_DWORD *)v25 + 1) - 3;
        if ( *((_DWORD *)v25 + 1) == 3 )
        {
          if ( byte_10069C64 )
          {
            if ( *(_DWORD *)v25 != v28 )
            {
              sub_10034F56(
                v27,
                HIDWORD(v3) + *(_DWORD *)(v4 + 72),
                SHIDWORD(v3),
                v4,
                v4,
                v3,
                v28,
                *(void **)v25,
                v28,
                v28);
              v27 = v39;
              ++v42;
              LODWORD(v3) = v42;
              v3 += 171798691840i64;
            }
          }
        }
      }
LABEL_40:
      v27 += 24;
      v25 = (char *)v25 + 24;
      v39 = v27;
      if ( v27 >= (unsigned int)dword_10069C74 )
        goto LABEL_41;
    }
  }
  if ( dword_10069C58 )
    v26 = *(_DWORD *)sub_10034982(dword_10069C58, 0);
  else
    v26 = ProcessAffinityMask;
  sub_10034F56(v13, *(_DWORD *)(v4 + 72), SHIDWORD(v3), v4, v4, 0, 0, (void *)v26, 0, 0);
  **(_DWORD **)(v4 + 68) = v26;
LABEL_42:
  if ( byte_10069C64 )
  {
    v30 = 0;
    if ( *(_DWORD *)(v4 + 24) )
    {
      v31 = 0;
      do
      {
        v32 = 0;
        if ( *(_DWORD *)(v4 + 20) )
        {
          v33 = *(_DWORD *)(v4 + 68);
          while ( *(_DWORD *)(v31 + *(_DWORD *)(v4 + 72) + 12) != *(_DWORD *)(v33 + 4)
               || !(*(_DWORD *)(v31 + *(_DWORD *)(v4 + 72)) & *(_DWORD *)v33) )
          {
            ++v32;
            v33 += 12;
            if ( v32 >= *(_DWORD *)(v4 + 20) )
              goto LABEL_52;
          }
          *(_DWORD *)(v31 + *(_DWORD *)(v4 + 72) + 20) = *(_DWORD *)(12 * v32 + *(_DWORD *)(v4 + 68) + 8);
        }
LABEL_52:
        ++v30;
        v31 += 40;
      }
      while ( v30 < *(_DWORD *)(v4 + 24) );
    }
  }
}
// 10069C58: using guessed type int dword_10069C58;
// 10069C60: using guessed type int dword_10069C60;
// 10069C64: using guessed type char byte_10069C64;
// 10069C68: using guessed type int dword_10069C68;
// 10069C6C: using guessed type int dword_10069C6C;
// 10069C70: using guessed type int dword_10069C70;
// 10069C74: using guessed type int dword_10069C74;

//----- (10033A22) --------------------------------------------------------
int __thiscall sub_10033A22(int this)
{
  char i; // zf@1
  int v2; // edi@1
  signed int v3; // esi@1
  int v4; // eax@2
  int result; // eax@2
  int v6; // ecx@2
  int v7; // [sp+8h] [bp-Ch]@2
  int v8; // [sp+Ch] [bp-8h]@2
  int v9; // [sp+10h] [bp-4h]@2

  v2 = this;
  v3 = *(_DWORD *)(this + 100);
  for ( i = v3 == 0; ; i = v3 == *(_DWORD *)(v2 + 100) )
  {
    v3 = i ? 0 : *(_DWORD *)(v3 + 24);
    if ( !v3 )
      break;
    v4 = *(_DWORD *)(v3 + 120);
    v6 = *(_DWORD *)(v3 + 8);
    v7 = 0;
    v8 = 0;
    v9 = v4;
    (*(void (__stdcall **)(int *, int *, int *))(*(_DWORD *)v6 + 4))(&v7, &v8, &v9);
    result = v9;
    *(_DWORD *)(v3 + 120) = v9;
  }
  return result;
}

//----- (10033A6F) --------------------------------------------------------
char __thiscall sub_10033A6F(int this)
{
  int v1; // ebx@1
  int v2; // esi@2
  int v3; // esi@3
  char v4; // dl@7
  unsigned int v5; // ecx@7
  unsigned int v6; // edi@7
  int v7; // eax@7
  int v8; // edx@9
  int v9; // ecx@10
  int v10; // esi@10
  char v11; // zf@14
  int v12; // edi@16
  int v13; // ecx@17
  int v14; // ebx@17
  int v15; // eax@18
  char result; // al@29
  int v17; // [sp+4h] [bp-2Ch]@9
  unsigned int v18; // [sp+Ch] [bp-24h]@7
  int v19; // [sp+10h] [bp-20h]@1
  int v20; // [sp+14h] [bp-1Ch]@5
  unsigned int v21; // [sp+18h] [bp-18h]@7
  int v22; // [sp+1Ch] [bp-14h]@7
  int v23; // [sp+20h] [bp-10h]@14
  int v24; // [sp+20h] [bp-10h]@17
  int v25; // [sp+24h] [bp-Ch]@7
  int v26; // [sp+28h] [bp-8h]@7
  char v27; // [sp+2Fh] [bp-1h]@8

  v1 = this;
  v19 = this;
  if ( *(_DWORD *)(this + 100) )
  {
    v2 = *(_DWORD *)(this + 100);
    if ( v2 )
      v3 = *(_DWORD *)(v2 + 24);
    else
      v3 = 0;
    v20 = v3;
    if ( *(_DWORD *)(v3 + 160) < (unsigned int)sub_100336B7(v3) || *(_DWORD *)(v3 + 168) )
    {
      v7 = sub_100336B7(v3);
      v25 = sub_10043555((void *)v3, v7) - *(_DWORD *)(v3 + 160);
      v22 = *(_DWORD *)(v3 + 16);
      v26 = *(_DWORD *)(v3 + 20);
      v6 = *(_DWORD *)(v1 + 24);
      v4 = sub_100336B7(v3) != *(_DWORD *)(v1 + 28);
      v5 = 0;
      v21 = 0;
      v18 = v6;
      if ( v6 )
      {
        while ( 1 )
        {
          v27 = v25 != 0 & v4;
          if ( v27 )
          {
            v8 = v5 + 1;
            v17 = *(_DWORD *)(v26 + 4 * v5);
            if ( v5 + 1 < v6 )
            {
              v10 = v5;
              v9 = v22 + 52 * v17;
              do
              {
                if ( *(_DWORD *)(v22 + 52 * *(_DWORD *)(v26 + 4 * v8) + 28) > *(_DWORD *)(v9 + 28) )
                {
                  v10 = v8;
                  v9 = v22 + 52 * *(_DWORD *)(v26 + 4 * v8);
                }
                ++v8;
              }
              while ( v8 < v18 );
              v5 = v21;
              v1 = v19;
              v23 = v10;
              v11 = v21 == v10;
              v3 = v20;
              if ( !v11 )
              {
                *(_DWORD *)(v26 + 4 * v21) = *(_DWORD *)(v26 + 4 * v23);
                *(_DWORD *)(v26 + 4 * v23) = v17;
              }
            }
          }
          v12 = v22 + 52 * *(_DWORD *)(v26 + 4 * v5);
          if ( *(_DWORD *)(v12 + 4) )
            break;
LABEL_26:
          v6 = *(_DWORD *)(v1 + 24);
          v4 = v27;
          ++v5;
          v21 = v5;
          v18 = v6;
          if ( v5 >= v6 )
            goto LABEL_27;
        }
        v14 = 0;
        v13 = 0;
        v24 = 0;
        while ( 1 )
        {
          v15 = *(_DWORD *)(v12 + 48);
          if ( *(_DWORD *)(v15 + v13) == 1 )
          {
            if ( v25 )
            {
              ++**(_DWORD **)(v15 + v13 + 20);
              sub_10043369(v3, v12, v14, 0);
              --v25;
LABEL_23:
              v13 = v24;
              goto LABEL_24;
            }
          }
          else
          {
            if ( *(_BYTE *)(v15 + v13 + 49) )
            {
              sub_10044106(v3, v12, v14);
              goto LABEL_23;
            }
          }
LABEL_24:
          ++v14;
          v13 += 52;
          v24 = v13;
          if ( (unsigned int)v14 >= *(_DWORD *)(v12 + 4) )
          {
            v1 = v19;
            v5 = v21;
            goto LABEL_26;
          }
        }
      }
    }
LABEL_27:
    if ( *(_DWORD *)(v3 + 132) == *(_DWORD *)(v3 + 128) )
      sub_100366D0((void *)v1, 0);
    result = *(_DWORD *)(v3 + 160) == sub_100336B7(v3);
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (10033C1C) --------------------------------------------------------
void __thiscall sub_10033C1C(int this, int a2, char a3, char a4, int a5, unsigned int a6)
{
  int v6; // ebx@1
  int v7; // esi@1
  unsigned int v8; // edi@2
  int v9; // ecx@3
  int v10; // edx@10
  int v11; // edi@11
  int v12; // edx@12
  int v13; // ebx@12
  int v14; // eax@14
  int v15; // ecx@18
  int v16; // eax@24
  unsigned int v17; // edi@25
  int v18; // eax@26
  int v19; // eax@27
  int v20; // [sp+Ch] [bp-10h]@11
  int v21; // [sp+10h] [bp-Ch]@10
  int v22; // [sp+14h] [bp-8h]@12
  int v23; // [sp+18h] [bp-4h]@1
  int v24; // [sp+24h] [bp+8h]@26

  v6 = a2;
  v7 = a5;
  v23 = this;
  do
  {
    v8 = 0;
    BYTE3(a5) = 0;
    if ( !v7 )
      break;
    do
    {
      v9 = *(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v8);
      if ( *(_DWORD *)(v9 + 4) )
      {
        if ( *(_DWORD *)(v9 + 40) > *(_DWORD *)(v9 + 44) )
        {
          BYTE3(a5) = 1;
          if ( sub_10034878((void *)v23, (int)&a3, (int)&a4, v9, a6) )
            --v6;
        }
      }
      this = v23;
      ++v8;
    }
    while ( v8 < v7 );
    a2 = v6;
  }
  while ( BYTE3(a5) );
  if ( v6 )
  {
    v10 = 0;
    v21 = 0;
    if ( v7 )
    {
      while ( 1 )
      {
        a5 = v10;
        v20 = v10 + 1;
        v11 = v10 + 1;
        if ( v10 + 1 < (unsigned int)v7 )
        {
          v22 = *(_DWORD *)(this + 92);
          v13 = 4 * v10;
          v12 = *(_DWORD *)(this + 92);
          do
          {
            if ( *(_DWORD *)(*(_DWORD *)(v12 + 4 * v11) + 4) <= *(_DWORD *)(*(_DWORD *)(v13 + v12) + 4) )
            {
              v14 = a5;
            }
            else
            {
              v14 = v11;
              a5 = v11;
              v13 = 4 * v11;
            }
            ++v11;
          }
          while ( v11 < (unsigned int)v7 );
          v10 = v21;
          v6 = a2;
          if ( v21 != v14 )
          {
            v15 = *(_DWORD *)(v22 + 4 * v21);
            *(_DWORD *)(v22 + 4 * v21) = *(_DWORD *)(v22 + 4 * v14);
            *(_DWORD *)(*(_DWORD *)(v23 + 92) + 4 * a5) = v15;
          }
          this = v23;
        }
        if ( !*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v10) + 4) )
          break;
        v10 = v20;
        v21 = v20;
        if ( v20 >= (unsigned int)v7 )
          goto LABEL_24;
      }
      v7 = v10;
    }
LABEL_24:
    v16 = v7;
    a5 = v7;
    do
    {
      v17 = 0;
      if ( v16 )
      {
        do
        {
          v18 = *(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v17);
          v24 = v18;
          if ( *(_DWORD *)(v18 + 4) )
          {
            v19 = sub_10034427(this, (int *)&a3, (unsigned int *)&a4, v18, v7, a6);
            this = v23;
            v6 -= v19;
            if ( !*(_DWORD *)(v24 + 4) )
              --v7;
          }
          v16 = a5;
          ++v17;
        }
        while ( v17 < a5 );
      }
    }
    while ( v6 );
  }
}

//----- (10033D56) --------------------------------------------------------
void __thiscall sub_10033D56(int this, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // esi@1
  int v5; // edi@2
  int v6; // edi@4
  unsigned int v7; // edx@5
  int v8; // ecx@6
  int v9; // edx@14
  int v10; // edi@15
  int v11; // ebx@16
  int v12; // eax@18
  int v13; // ecx@22
  int v14; // eax@28
  unsigned int v15; // edi@29
  int v16; // eax@31
  int v17; // eax@32
  int v18; // [sp+Ch] [bp-10h]@15
  int v19; // [sp+10h] [bp-Ch]@6
  int v20; // [sp+10h] [bp-Ch]@14
  int v21; // [sp+14h] [bp-8h]@2
  int v22; // [sp+14h] [bp-8h]@16
  int v23; // [sp+18h] [bp-4h]@1
  int v24; // [sp+24h] [bp+8h]@6
  int v25; // [sp+24h] [bp+8h]@31
  int v26; // [sp+28h] [bp+Ch]@15
  int v27; // [sp+28h] [bp+Ch]@28
  char v28; // [sp+2Bh] [bp+Fh]@2

  v3 = a2;
  v4 = a3;
  v23 = this;
  do
  {
    v5 = 0;
    v28 = 0;
    v21 = 0;
    if ( !v4 )
      break;
    do
    {
      if ( !v3 )
        break;
      v6 = *(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v5);
      if ( *(_DWORD *)(v6 + 4) )
      {
        v7 = *(_DWORD *)(v6 + 44);
        if ( *(_DWORD *)(v6 + 40) > v7 )
        {
          v8 = *(_DWORD *)(v6 + 16);
          v28 = 1;
          v24 = *(_DWORD *)(*(_DWORD *)(v8 + 20) + 4 * v7);
          v19 = *(_DWORD *)(v8 + 16) + 52 * v24;
          this = v23;
          if ( *(_DWORD *)(40 * v24 + *(_DWORD *)(v23 + 72) + 28) )
          {
            sub_10034139(v23, *(_DWORD *)(v6 + 16), v24, 1, 1);
            if ( *(_DWORD *)(v19 + 28) == *(_DWORD *)(v19 + 4) )
              ++*(_DWORD *)(v6 + 44);
            --*(_DWORD *)(v6 + 4);
            this = v23;
            --v3;
          }
          else
          {
            ++*(_DWORD *)(v6 + 44);
          }
        }
      }
      v5 = v21 + 1;
      v21 = v5;
    }
    while ( v5 < (unsigned int)v4 );
    a2 = v3;
  }
  while ( v28 );
  if ( v3 )
  {
    v9 = 0;
    v20 = 0;
    if ( v4 )
    {
      while ( 1 )
      {
        v26 = v9;
        v18 = v9 + 1;
        v10 = v9 + 1;
        if ( v9 + 1 < (unsigned int)v4 )
        {
          v22 = *(_DWORD *)(this + 92);
          v11 = 4 * v9;
          do
          {
            if ( *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v10) + 4) <= *(_DWORD *)(*(_DWORD *)(v11 + *(_DWORD *)(this + 92))
                                                                                             + 4) )
            {
              v12 = v26;
            }
            else
            {
              v12 = v10;
              v26 = v10;
              v11 = 4 * v10;
            }
            ++v10;
          }
          while ( v10 < (unsigned int)v4 );
          v9 = v20;
          v3 = a2;
          if ( v20 != v12 )
          {
            v13 = *(_DWORD *)(v22 + 4 * v20);
            *(_DWORD *)(v22 + 4 * v20) = *(_DWORD *)(v22 + 4 * v12);
            *(_DWORD *)(*(_DWORD *)(v23 + 92) + 4 * v26) = v13;
          }
          this = v23;
        }
        if ( !*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v9) + 4) )
          break;
        v9 = v18;
        v20 = v18;
        if ( v18 >= (unsigned int)v4 )
          goto LABEL_28;
      }
      v4 = v9;
    }
LABEL_28:
    v14 = v4;
    v27 = v4;
    while ( 1 )
    {
      v15 = 0;
      if ( v14 )
        break;
LABEL_35:
      if ( !v3 )
        return;
    }
    while ( v3 )
    {
      v16 = *(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v15);
      v25 = v16;
      if ( *(_DWORD *)(v16 + 4) )
      {
        v17 = sub_1003476C((void *)this, v3, v16, v4);
        this = v23;
        v3 -= v17;
        if ( !*(_DWORD *)(v25 + 4) )
          --v4;
      }
      v14 = v27;
      ++v15;
      if ( v15 >= v27 )
        goto LABEL_35;
    }
  }
}

//----- (10033ED7) --------------------------------------------------------
int __thiscall sub_10033ED7(int this)
{
  unsigned int v1; // ecx@1
  unsigned int v2; // ebx@1
  int v3; // edi@1
  int v4; // edx@2
  int v5; // ecx@3
  int v6; // esi@3
  int v7; // esi@4
  int v8; // ecx@7
  int v9; // eax@9
  int v10; // eax@9
  unsigned int v11; // edx@11
  int v12; // ecx@11
  int v13; // esi@12
  int v14; // eax@13
  unsigned int v15; // edx@14
  int v16; // ebx@14
  int v17; // ecx@15
  int v18; // esi@15
  int v19; // esi@23
  unsigned int v20; // edx@29
  unsigned int v21; // ecx@29
  unsigned int v22; // ebx@29
  int v23; // esi@30
  int v24; // edx@35
  int v25; // ecx@35
  int v26; // esi@35
  int v27; // esi@44
  int v28; // eax@44
  int v30; // [sp+Ch] [bp-18h]@35
  unsigned int v31; // [sp+10h] [bp-14h]@1
  int v32; // [sp+14h] [bp-10h]@6
  unsigned int v33; // [sp+14h] [bp-10h]@11
  unsigned int v34; // [sp+14h] [bp-10h]@29
  unsigned int v35; // [sp+18h] [bp-Ch]@1
  int v36; // [sp+1Ch] [bp-8h]@6
  int v37; // [sp+1Ch] [bp-8h]@12
  unsigned int v38; // [sp+1Ch] [bp-8h]@23
  int v39; // [sp+20h] [bp-4h]@11

  v3 = this;
  sub_100355A5(this);
  sub_100356B5(v3);
  v35 = 0;
  v1 = 0;
  v2 = 0;
  v31 = 0;
  if ( *(_DWORD *)(v3 + 8) )
  {
    do
    {
      v4 = *(_DWORD *)(*(_DWORD *)(v3 + 84) + 4 * v2);
      if ( *(_DWORD *)(*(_DWORD *)(v4 + 16) + 160) > *(_DWORD *)(v4 + 36) )
      {
        *(_DWORD *)(*(_DWORD *)(v3 + 88) + 4 * v1) = v4;
        v31 = v1 + 1;
        v5 = *(_DWORD *)(v4 + 16);
        v6 = *(_DWORD *)(v5 + 160);
        v35 += *(_DWORD *)(v5 + 160) - *(_DWORD *)(v4 + 36);
        if ( *(_DWORD *)(v4 + 24) >= (unsigned int)(v6 - *(_DWORD *)(v4 + 36)) )
          v7 = v6 - *(_DWORD *)(v4 + 36);
        else
          v7 = *(_DWORD *)(v4 + 24);
        *(_DWORD *)(v4 + 40) = v7;
        v36 = *(_DWORD *)(v5 + 160);
        v32 = *(_DWORD *)(v5 + 168);
        if ( v32 - *(_DWORD *)(v4 + 24) >= (unsigned int)(v36 - *(_DWORD *)(v4 + 36) - v7) )
          v8 = v36 - *(_DWORD *)(v4 + 36) - v7;
        else
          v8 = v32 - *(_DWORD *)(v4 + 24);
        v9 = *(_DWORD *)(v4 + 16);
        *(_DWORD *)(v4 + 44) = v8;
        v10 = *(_DWORD *)(v9 + 160) - *(_DWORD *)(v4 + 36) - v8;
        v1 = v31;
        *(_DWORD *)(v4 + 48) = v10 - v7;
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)(v3 + 8) );
  }
  v12 = 0;
  *(_DWORD *)(v3 + 32) = 0;
  v11 = 0;
  v39 = 0;
  v33 = 0;
  if ( *(_DWORD *)(v3 + 24) )
  {
    v13 = 0;
    v37 = 0;
    do
    {
      v14 = v13 + *(_DWORD *)(v3 + 72);
      if ( *(_DWORD *)(v14 + 4) )
      {
        v15 = 0;
        v16 = 0;
        do
        {
          v17 = v16 + *(_DWORD *)(v14 + 32);
          v18 = *(_DWORD *)(v17 + 16);
          if ( v18 )
          {
            if ( v18 == *(_DWORD *)(v17 + 28) )
            {
              *(_DWORD *)v17 = 6;
              ++*(_DWORD *)(v14 + 28);
              ++*(_DWORD *)(v3 + 32);
            }
            v12 = v39;
          }
          else
          {
            *(_DWORD *)v17 = 2;
            ++*(_DWORD *)(v14 + 8);
            v12 = v39++ + 1;
          }
          ++v15;
          v16 += 36;
        }
        while ( v15 < *(_DWORD *)(v14 + 4) );
        v11 = v33;
        v13 = v37;
      }
      ++v11;
      v13 += 40;
      v33 = v11;
      v37 = v13;
    }
    while ( v11 < *(_DWORD *)(v3 + 24) );
  }
  v19 = v12 + v35;
  *(_DWORD *)(v3 + 36) = 0;
  v38 = v12 + v35;
  while ( (v19 || *(_DWORD *)(v3 + 32) > 0u) && *(_DWORD *)(v3 + 36) < 2u )
  {
    if ( *(_DWORD *)(v3 + 36) == 1 )
      sub_10034EE7(v3);
    v21 = 0;
    v22 = 0;
    v20 = 0;
    v34 = 0;
    if ( *(_DWORD *)(v3 + 8) )
    {
      do
      {
        v23 = *(_DWORD *)(*(_DWORD *)(v3 + 84) + 4 * v20);
        if ( *(_DWORD *)(*(_DWORD *)(v23 + 16) + 160) < *(_DWORD *)(v23 + 36) )
        {
          *(_DWORD *)(*(_DWORD *)(v3 + 92) + 4 * v21) = v23;
          v34 = v21 + 1;
          v22 += *(_DWORD *)(v23 + 36) - *(_DWORD *)(*(_DWORD *)(v23 + 16) + 160);
          ++v21;
        }
        ++v20;
      }
      while ( v20 < *(_DWORD *)(v3 + 8) );
      v19 = v38;
      if ( v21 )
      {
        if ( v38 )
        {
          v26 = sub_10032FCA(v3, v38, v22, v21);
          v30 = sub_100357B5((void *)v3, v34);
          LOBYTE(v25) = 0;
          v24 = v39;
          if ( v39 >= (unsigned int)v26 )
            v24 = v26;
          v39 -= v24;
          if ( v24 < (unsigned int)v26 )
          {
            v25 = v26 - v24;
            if ( v26 - v24 >= v35 )
              v25 = v35;
            v35 -= v25;
          }
          sub_10033C1C(v3, v26, v24, v25, v30, v31);
          v38 -= v26;
          v21 = v34;
          v22 -= v26;
          v19 = v38;
        }
        if ( v22 )
        {
          if ( *(_DWORD *)(v3 + 32) )
          {
            v27 = sub_10032FCA(v3, *(_DWORD *)(v3 + 32), v22, v21);
            v28 = sub_100357B5((void *)v3, v34);
            sub_10033D56(v3, v27, v28);
            *(_DWORD *)(v3 + 32) -= v27;
            v19 = v38;
          }
        }
      }
    }
    ++*(_DWORD *)(v3 + 36);
  }
  return sub_100363B3(v3);
}

//----- (10034139) --------------------------------------------------------
char *__thiscall sub_10034139(int this, int a2, int a3, int a4, char a5)
{
  int i; // ecx@1
  int v6; // edi@1
  int v7; // esi@1
  int v8; // eax@2
  char *result; // eax@9
  char v10; // zf@9
  int v11; // [sp+Ch] [bp-4h]@2

  v7 = *(_DWORD *)(this + 72) + 40 * a3;
  v6 = 0;
  for ( i = 0; ; i += 36 )
  {
    v8 = i + *(_DWORD *)(v7 + 32);
    v11 = i;
    if ( *(_DWORD *)v8 == 2 )
    {
      if ( !a5 )
        break;
    }
    if ( *(_DWORD *)v8 == 6 && a5 )
      break;
LABEL_11:
    ++v6;
  }
  ++*(_DWORD *)(v8 + 16);
  *(_DWORD *)v8 = 0;
  if ( a5 )
    --*(_DWORD *)(v7 + 28);
  else
    --*(_DWORD *)(v7 + 8);
  result = sub_10043369(a2, *(_DWORD *)(a2 + 16) + 52 * a3, v6, a5);
  v10 = a4-- == 1;
  if ( !v10 )
  {
    i = v11;
    goto LABEL_11;
  }
  return result;
}

//----- (100341A5) --------------------------------------------------------
char *__thiscall sub_100341A5(void *this, int a2, int a3, int a4, unsigned int a5)
{
  int v5; // eax@1
  int v6; // edx@1
  unsigned int v7; // ecx@1
  int ebp0; // ebp@0
  unsigned int v9; // esi@2
  int v10; // edi@4
  int v11; // edx@6
  int v12; // esi@6
  int v13; // eax@8
  int v14; // ecx@8
  int v15; // esi@8
  int v16; // ebx@9
  char v17; // al@11
  char v18; // cl@22
  char *result; // eax@29
  char v20; // zf@29
  char v21; // [sp+14h] [bp-24h]@24
  int v22; // [sp+18h] [bp-20h]@1
  int v23; // [sp+1Ch] [bp-1Ch]@8
  int v24; // [sp+20h] [bp-18h]@8
  int v25; // [sp+24h] [bp-14h]@6
  int v26; // [sp+28h] [bp-10h]@1
  unsigned int v27; // [sp+2Ch] [bp-Ch]@2
  int v28; // [sp+30h] [bp-8h]@9
  char v29; // [sp+37h] [bp-1h]@11

  v22 = (int)this;
  v5 = *(_DWORD *)(a2 + 16);
  v6 = 52 * a4 + *(_DWORD *)(v5 + 16);
  v7 = *(_DWORD *)(v6 + 44);
  v26 = 52 * a4 + *(_DWORD *)(v5 + 16);
  if ( a5 >= v7 )
  {
    v9 = *(_DWORD *)(v6 + 44);
    v27 = *(_DWORD *)(v6 + 44);
  }
  else
  {
    v9 = a5;
    v27 = a5;
  }
  v10 = a5 - v9;
  if ( a5 - v9 >= *(_DWORD *)(v6 + 32) - v7 )
    v10 = *(_DWORD *)(v6 + 32) - v7;
  v12 = a5 - v10 - v27;
  v11 = *(_DWORD *)(v6 + 40) - v7;
  v25 = v11;
  if ( v12 < (unsigned int)v11 )
  {
    v11 = a5 - v10 - v27;
    v25 = a5 - v10 - v27;
  }
  v14 = 52 * a4 + *(_DWORD *)(v5 + 16);
  v13 = 0;
  v23 = 0;
  v15 = v12 - v11;
  v24 = 0;
  while ( 1 )
  {
    v16 = v24 + *(_DWORD *)(v14 + 48);
    v28 = v13;
    if ( *(_DWORD *)v16 == 4 )
    {
      if ( !*(_DWORD *)(v16 + 40) )
        break;
    }
LABEL_32:
    v24 += 52;
    ++v13;
    v23 += 36;
  }
  v17 = *(_BYTE *)(v16 + 48);
  v29 = *(_BYTE *)(v16 + 48);
  if ( *(_BYTE *)(v16 + 49) )
  {
    if ( v17 && v27 )
    {
      --v27;
      goto LABEL_22;
    }
    if ( v10 )
    {
      --v10;
      goto LABEL_22;
    }
LABEL_31:
    v13 = v28;
    goto LABEL_32;
  }
  if ( v17 && v11 )
  {
    v25 = v11 - 1;
  }
  else
  {
    if ( !v15 )
      goto LABEL_31;
    --v15;
  }
LABEL_22:
  v18 = *(_BYTE *)(v16 + 48);
  if ( v29 )
  {
    sub_10036A77(
      v22,
      v26,
      v16,
      40 * a4 + *(_DWORD *)(v22 + 72),
      v23 + *(_DWORD *)(40 * a4 + *(_DWORD *)(v22 + 72) + 32),
      a2);
    v18 = v29;
  }
  v21 = 0;
  if ( *(_BYTE *)(v16 + 49) )
  {
    v21 = 1;
    if ( v18 )
      --*(_DWORD *)(a2 + 40);
    else
      --*(_DWORD *)(a2 + 44);
  }
  else
  {
    --*(_DWORD *)(a2 + 48);
  }
  sub_10043F22(ebp0, v26, v28);
  result = sub_10043369(a3, 52 * a4 + *(_DWORD *)(a3 + 16), v28, v21);
  v20 = a5-- == 1;
  if ( !v20 )
  {
    v11 = v25;
    v14 = v26;
    goto LABEL_31;
  }
  return result;
}

//----- (1003430D) --------------------------------------------------------
int __stdcall StartAddress(int a1)
{
  int ebp0; // ebp@0

  sub_10034326(ebp0);
  sub_1002C3BC(0);
  return 0;
}

//----- (10034326) --------------------------------------------------------
int __usercall sub_10034326<eax>(int a1<ebp>)
{
  DWORD v1; // ebx@1
  int v2; // edi@1
  int v3; // ecx@1
  DWORD v4; // eax@1
  char v5; // zf@1
  struct _RTL_CRITICAL_SECTION *v6; // esi@2
  int v7; // eax@3
  DWORD v8; // eax@8
  int v9; // esi@9
  struct _RTL_CRITICAL_SECTION *v10; // ecx@20
  signed int v12; // [sp-4h] [bp-4h]@1

  v12 = 12;
  sub_1002D0B8();
  v2 = v3;
  v1 = 100;
  v4 = GetTickCount();
  v5 = *(_DWORD *)(v2 + 40) == 2;
  *(_DWORD *)(a1 - 16) = v4 - 500;
  if ( !v5 )
  {
    v6 = (struct _RTL_CRITICAL_SECTION *)(v2 + 44);
    for ( *(_DWORD *)(a1 - 20) = v2 + 44; ; v6 = *(struct _RTL_CRITICAL_SECTION **)(a1 - 20) )
    {
      *(_DWORD *)(a1 - 24) = WaitForSingleObject(*(HANDLE *)(v2 + 80), v1);
      sub_100244EB(v6);
      v7 = *(_DWORD *)(v2 + 40);
      *(_DWORD *)(a1 - 4) = 0;
      if ( v7 )
      {
        if ( v7 != 1 )
          goto LABEL_20;
        if ( *(_DWORD *)(a1 - 24) == 258 )
        {
          sub_10033ED7(v2);
          if ( *(_DWORD *)(v2 + 16) > 0u )
            sub_100366D0((void *)v2, 0);
          v8 = GetTickCount();
LABEL_15:
          *(_DWORD *)(a1 - 16) = v8;
          v1 = 100;
          goto LABEL_20;
        }
        v9 = ((int (__cdecl *)(signed int))GetTickCount)(v12) - *(_DWORD *)(a1 - 16);
        if ( (unsigned int)v9 > 0x64 )
        {
          if ( (unsigned int)v9 <= 0x82 )
          {
            if ( *(_DWORD *)(v2 + 16) )
              sub_100366D0((void *)v2, 0);
          }
          else
          {
            sub_10033A22(v2);
          }
          v8 = GetTickCount();
          goto LABEL_15;
        }
        if ( *(_DWORD *)(v2 + 16) )
          sub_100366D0((void *)v2, 0);
        v1 = 100 - v9;
      }
      else
      {
        v1 = (unsigned __int8)sub_10033A6F(v2) != 0 ? -1 : 100;
      }
LABEL_20:
      v10 = *(struct _RTL_CRITICAL_SECTION **)(a1 - 20);
      *(_DWORD *)(a1 - 4) = -1;
      sub_10024670(v10);
      if ( *(_DWORD *)(v2 + 40) == 2 )
        return sub_1002D086(v12);
    }
  }
  return sub_1002D086(v12);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10034427) --------------------------------------------------------
int __thiscall sub_10034427(int this, int *a2, unsigned int *a3, int a4, int a5, unsigned int a6)
{
  int v6; // edx@1
  unsigned int v7; // ebx@1
  int v8; // esi@1
  int v9; // eax@1
  int v10; // eax@4
  int v11; // eax@5
  int v12; // ecx@5
  int v13; // edi@5
  int v14; // esi@8
  int v15; // eax@9
  unsigned int *v16; // eax@13
  int v17; // ecx@13
  int v18; // ebx@15
  int v19; // ecx@17
  int v20; // eax@18
  unsigned int v21; // esi@19
  int v22; // edx@21
  int v23; // edx@21
  int v24; // ecx@23
  int v25; // ecx@25
  int v26; // ecx@25
  char v27; // zf@25
  int v28; // eax@26
  char v29; // cf@30
  int v30; // eax@32
  char v31; // zf@33
  signed int v32; // ecx@39
  unsigned int v33; // eax@44
  int v34; // ecx@44
  int v35; // esi@46
  int v36; // eax@47
  int v37; // ecx@48
  unsigned int *v38; // eax@56
  unsigned int v39; // esi@58
  int v40; // eax@60
  int v41; // edx@63
  int v42; // edx@63
  int v43; // ecx@65
  int v44; // eax@67
  unsigned int v45; // ecx@68
  int v46; // edx@77
  int v47; // ecx@77
  int v49; // [sp+Ch] [bp-48h]@1
  int v50; // [sp+Ch] [bp-48h]@59
  int v51; // [sp+Ch] [bp-48h]@63
  unsigned int v52; // [sp+10h] [bp-44h]@4
  int v53; // [sp+14h] [bp-40h]@21
  int v54; // [sp+18h] [bp-3Ch]@4
  int v55; // [sp+1Ch] [bp-38h]@5
  unsigned int v56; // [sp+1Ch] [bp-38h]@19
  unsigned int v57; // [sp+1Ch] [bp-38h]@61
  int v58; // [sp+20h] [bp-34h]@17
  int v59; // [sp+24h] [bp-30h]@4
  int v60; // [sp+28h] [bp-2Ch]@4
  unsigned int v61; // [sp+2Ch] [bp-28h]@6
  unsigned int v62; // [sp+30h] [bp-24h]@8
  unsigned int v63; // [sp+34h] [bp-20h]@14
  int v64; // [sp+38h] [bp-1Ch]@1
  int v65; // [sp+3Ch] [bp-18h]@4
  int v66; // [sp+40h] [bp-14h]@1
  int v67; // [sp+44h] [bp-10h]@1
  int v68; // [sp+48h] [bp-Ch]@13
  signed int v69; // [sp+4Ch] [bp-8h]@8
  signed int v70; // [sp+50h] [bp-4h]@4
  int v71; // [sp+5Ch] [bp+8h]@59
  int v72; // [sp+68h] [bp+14h]@44
  char v73; // [sp+6Bh] [bp+17h]@2

  v6 = a4;
  v9 = *(_DWORD *)(a4 + 16);
  v8 = *(_DWORD *)(v9 + 20);
  v64 = *(_DWORD *)(v9 + 16);
  v7 = 0;
  v67 = this;
  v49 = *(_DWORD *)(a4 + 16);
  v66 = *(_DWORD *)(v9 + 20);
  if ( a5 == 1 )
    v73 = 0;
  else
    v73 = *(_BYTE *)(a4 + 32);
  v10 = *(_DWORD *)(a4 + 44);
  v54 = 0;
  v70 = -1;
  v65 = 0;
  v60 = 0;
  v59 = v10;
  v52 = *(_DWORD *)(this + 24);
  if ( v10 >= v52 )
    goto LABEL_78;
  do
  {
    v12 = *(_DWORD *)(v8 + 4 * v10);
    v11 = 52 * *(_DWORD *)(v8 + 4 * v10);
    v55 = v11;
    v13 = v65;
    if ( *(_DWORD *)(v11 + v64 + 28) == v7 )
    {
      v61 = *(_DWORD *)(v6 + 4);
      if ( v61 >= *(_DWORD *)(v11 + v64 + 4) )
        v61 = *(_DWORD *)(v11 + v64 + 4);
      v13 = v65;
      v14 = v7;
      v62 = v7;
      v69 = v7;
      if ( *a2 )
      {
        v15 = *(_DWORD *)(40 * v12 + *(_DWORD *)(v67 + 72) + 8);
        if ( v15 )
        {
          if ( *a2 < (unsigned int)v15 )
            v15 = *a2;
          v14 = 1;
          v62 = v15;
          v69 = 1;
        }
      }
      v16 = a3;
      v17 = v7;
      v68 = v7;
      if ( *a3 )
      {
        v63 = v7;
        if ( a6 )
        {
          v18 = v55;
          do
          {
            if ( v17 >= *v16 )
              break;
            v58 = *(_DWORD *)(*(_DWORD *)(v67 + 88) + 4 * v63);
            v19 = *(_DWORD *)(v58 + 16);
            if ( *(_DWORD *)(v19 + 160) <= *(_DWORD *)(v58 + 36) )
              goto LABEL_82;
            v20 = *(_DWORD *)(v19 + 16);
            if ( *(_DWORD *)(v18 + v20 + 28) == *(_DWORD *)(v18 + v20 + 36) )
              goto LABEL_82;
            v21 = *(_DWORD *)(v18 + v20 + 44);
            v56 = *(_DWORD *)(v58 + 40);
            if ( v21 < v56 )
              v56 = *(_DWORD *)(v18 + v20 + 44);
            v23 = *(_DWORD *)(v18 + v20 + 32);
            v53 = v23;
            v22 = v23 - v21;
            if ( (unsigned int)v22 >= *(_DWORD *)(v58 + 44) )
              v22 = *(_DWORD *)(v58 + 44);
            v24 = *(_DWORD *)(v18 + v20 + 28) - *(_DWORD *)(v18 + v20 + 36) - v53;
            if ( (unsigned int)v24 >= *(_DWORD *)(v58 + 48) )
              v24 = *(_DWORD *)(v58 + 48);
            v26 = v22 + v24;
            v27 = v56 + v26 == 0;
            v25 = v56 + v26;
            if ( v27 )
            {
LABEL_82:
              v14 = v69;
              v17 = v68;
            }
            else
            {
              v28 = *a3 - v68;
              if ( v28 >= (unsigned int)v25 )
                v28 = v25;
              v17 = v28 + v68;
              v14 = v69 + 1;
              v68 += v28;
              ++v69;
            }
            v29 = v63++ + 1 < a6;
            v16 = a3;
          }
          while ( v29 );
          v13 = v65;
          v6 = a4;
          v7 = 0;
        }
      }
      v30 = v17 + v62;
      if ( v73 )
      {
        v31 = v30 == v61;
      }
      else
      {
        if ( v13 < v61 && v30 > (unsigned int)v13 )
        {
LABEL_39:
          v32 = v59;
          v13 = v30;
          v60 = v14;
          v8 = v66;
          v70 = v59;
          v65 = v30;
          goto LABEL_42;
        }
        v31 = v30 == v13;
      }
      if ( v31 && v14 > (unsigned int)v60 )
        goto LABEL_39;
      v8 = v66;
    }
    v32 = v70;
LABEL_42:
    v10 = v59 + 1;
    v59 = v10;
  }
  while ( v10 < v52 );
  if ( v32 == -1 )
  {
LABEL_78:
    *(_BYTE *)(v6 + 32) = v7;
    return v54;
  }
  v33 = *(_DWORD *)(v6 + 4);
  v34 = *(_DWORD *)(v8 + 4 * v32);
  v72 = v34;
  if ( v33 < v13 )
    v13 = *(_DWORD *)(v6 + 4);
  *(_DWORD *)(v6 + 4) = v33 - v13;
  v54 = v13;
  v35 = *a2;
  if ( *a2 )
  {
    v36 = *(_DWORD *)(40 * v34 + *(_DWORD *)(v67 + 72) + 8);
    if ( v36 )
    {
      v37 = *a2;
      if ( v35 >= (unsigned int)v36 )
        v37 = v36;
      if ( v37 >= (unsigned int)v13 )
      {
        v35 = v13;
      }
      else
      {
        if ( v35 >= (unsigned int)v36 )
          v35 = v36;
      }
      sub_10034139(v67, v49, v72, v35, v7);
      *a2 -= v35;
      v13 -= v35;
    }
  }
  if ( v13 )
  {
    v38 = a3;
    if ( *a3 > v7 )
    {
      do
      {
        if ( v7 >= a6 )
          break;
        v39 = *v38;
        if ( !*v38 )
          break;
        v71 = *(_DWORD *)(*(_DWORD *)(v67 + 88) + 4 * v7++);
        v50 = *(_DWORD *)(v71 + 16);
        if ( *(_DWORD *)(v50 + 160) <= *(_DWORD *)(v71 + 36) )
          goto LABEL_83;
        v40 = *(_DWORD *)(v50 + 16) + 52 * v72;
        if ( *(_DWORD *)(v40 + 28) == *(_DWORD *)(v40 + 36) )
          goto LABEL_83;
        v57 = *(_DWORD *)(v71 + 40);
        if ( *(_DWORD *)(v40 + 44) < v57 )
          v57 = *(_DWORD *)(v40 + 44);
        v42 = *(_DWORD *)(v40 + 32);
        v51 = v42;
        v41 = v42 - *(_DWORD *)(v40 + 44);
        if ( (unsigned int)v41 >= *(_DWORD *)(v71 + 44) )
          v41 = *(_DWORD *)(v71 + 44);
        v43 = *(_DWORD *)(v40 + 28) - *(_DWORD *)(v40 + 36) - v51;
        if ( (unsigned int)v43 >= *(_DWORD *)(v71 + 48) )
          v43 = *(_DWORD *)(v71 + 48);
        v44 = v57 + v43 + v41;
        if ( v57 + v43 + v41 )
        {
          v45 = v39;
          if ( v39 >= v44 )
            v45 = v44;
          if ( v45 >= v13 )
          {
            v39 = v13;
          }
          else
          {
            if ( v39 >= v44 )
              v39 = v44;
          }
          sub_100341A5((void *)v67, v71, *(_DWORD *)(a4 + 16), v72, v39);
          v38 = a3;
          *v38 -= v39;
          v13 -= v39;
        }
        else
        {
LABEL_83:
          v38 = a3;
        }
      }
      while ( v13 );
    }
  }
  v46 = *(_DWORD *)(a4 + 44);
  v47 = *(_DWORD *)(v66 + 4 * v46);
  *(_DWORD *)(v66 + 4 * v46) = *(_DWORD *)(v66 + 4 * v70);
  *(_DWORD *)(v66 + 4 * v70) = v47;
  ++*(_DWORD *)(a4 + 44);
  *(_BYTE *)(a4 + 32) = 1;
  return v54;
}

//----- (1003476C) --------------------------------------------------------
int __thiscall sub_1003476C(void *this, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // eax@1
  signed int v8; // edx@4
  int v9; // ecx@4
  int v10; // eax@5
  int v11; // eax@5
  unsigned int v12; // eax@8
  signed int v13; // eax@14
  int v14; // edx@19
  int v15; // ecx@19
  unsigned int v17; // [sp+Ch] [bp-1Ch]@4
  int v18; // [sp+10h] [bp-18h]@1
  unsigned int v19; // [sp+14h] [bp-14h]@6
  int v20; // [sp+18h] [bp-10h]@1
  int v21; // [sp+1Ch] [bp-Ch]@5
  int v22; // [sp+1Ch] [bp-Ch]@8
  unsigned int v23; // [sp+20h] [bp-8h]@4
  signed int v24; // [sp+24h] [bp-4h]@4
  char v25; // [sp+3Bh] [bp+13h]@2

  v6 = a3;
  v20 = (int)this;
  v7 = *(_DWORD *)(a3 + 16);
  v4 = 0;
  v5 = *(_DWORD *)(v7 + 20);
  v18 = *(_DWORD *)(v7 + 16);
  if ( a4 == 1 )
    v25 = 0;
  else
    v25 = *(_BYTE *)(a3 + 32);
  v8 = *(_DWORD *)(a3 + 44);
  v24 = -1;
  v9 = 0;
  v23 = 0;
  v17 = *(_DWORD *)(v20 + 24);
  if ( v8 >= v17 )
    goto LABEL_27;
  while ( 1 )
  {
    v11 = *(_DWORD *)(v5 + 4 * v8);
    v21 = v11;
    v10 = v18 + 52 * v11;
    if ( !*(_DWORD *)(v10 + 28) )
      break;
LABEL_14:
    v13 = v24;
LABEL_15:
    ++v8;
    if ( v8 >= v17 )
      goto LABEL_16;
  }
  v19 = *(_DWORD *)(v6 + 4);
  if ( v19 >= *(_DWORD *)(v10 + 4) )
    v19 = *(_DWORD *)(v10 + 4);
  v22 = 40 * v21;
  v9 = 0;
  v12 = *(_DWORD *)(v22 + *(_DWORD *)(v20 + 72) + 28);
  v6 = a3;
  if ( v12 )
  {
    v9 = a2;
    if ( a2 >= v12 )
      v9 = *(_DWORD *)(v22 + *(_DWORD *)(v20 + 72) + 28);
  }
  if ( v25 )
  {
    if ( v9 == v19 )
      goto LABEL_21;
    goto LABEL_13;
  }
  if ( v9 <= v23 )
  {
LABEL_13:
    v9 = v23;
    goto LABEL_14;
  }
LABEL_21:
  v13 = v8;
  v24 = v8;
  v23 = v9;
  if ( !v25 )
    goto LABEL_15;
LABEL_16:
  if ( v13 == -1 )
  {
LABEL_27:
    *(_BYTE *)(v6 + 32) = 0;
    return v4;
  }
  v4 = *(_DWORD *)(v6 + 4);
  if ( v4 >= (unsigned int)v9 )
    v4 = v9;
  sub_10034139(v20, *(_DWORD *)(v6 + 16), *(_DWORD *)(v5 + 4 * v13), v4, 1);
  *(_DWORD *)(v6 + 4) -= v4;
  v14 = *(_DWORD *)(v6 + 44);
  v15 = *(_DWORD *)(v5 + 4 * v14);
  *(_DWORD *)(v5 + 4 * v14) = *(_DWORD *)(v5 + 4 * v24);
  *(_DWORD *)(v5 + 4 * v24) = v15;
  ++*(_DWORD *)(v6 + 44);
  *(_BYTE *)(v6 + 32) = 1;
  return v4;
}

//----- (10034878) --------------------------------------------------------
char __thiscall sub_10034878(void *this, int a2, int a3, int a4, unsigned int a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  char v7; // bl@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // eax@1
  int v11; // ecx@5
  int v12; // ecx@7
  int v13; // edx@8
  int v15; // [sp+Ch] [bp-8h]@1
  int v16; // [sp+10h] [bp-4h]@1
  int v17; // [sp+1Ch] [bp+8h]@5
  int v18; // [sp+24h] [bp+10h]@1

  v9 = a4;
  v16 = (int)this;
  v10 = *(_DWORD *)(a4 + 16);
  v15 = *(_DWORD *)(v10 + 16);
  v6 = *(_DWORD *)(*(_DWORD *)(v10 + 20) + 4 * *(_DWORD *)(a4 + 44));
  v5 = v16;
  v7 = 0;
  v8 = 52 * v6;
  v18 = *(_DWORD *)(*(_DWORD *)(v10 + 20) + 4 * *(_DWORD *)(a4 + 44));
  if ( *(_DWORD *)a2 && *(_DWORD *)(40 * v6 + *(_DWORD *)(v16 + 72) + 8) )
  {
    v7 = 1;
    sub_10034139(v16, *(_DWORD *)(v9 + 16), v18, 1, 0);
    --*(_DWORD *)a2;
  }
  else
  {
    if ( !*(_DWORD *)a3 || (v11 = 0, v17 = 0, !a5) )
    {
LABEL_20:
      ++*(_DWORD *)(v9 + 44);
      return v7;
    }
    while ( !v7 )
    {
      v12 = *(_DWORD *)(*(_DWORD *)(v5 + 88) + 4 * v11);
      if ( *(_DWORD *)(*(_DWORD *)(v12 + 16) + 160) > *(_DWORD *)(v12 + 36) )
      {
        v13 = *(_DWORD *)(*(_DWORD *)(v12 + 16) + 16);
        if ( *(_DWORD *)(v8 + v13 + 44)
          || *(_DWORD *)(v8 + v13 + 32) != *(_DWORD *)(v8 + v13 + 44) && *(_DWORD *)(v12 + 44)
          || *(_DWORD *)(v8 + v13 + 28) != *(_DWORD *)(v8 + v13 + 36) && *(_DWORD *)(v12 + 48) )
        {
          v7 = 1;
          sub_100341A5((void *)v16, v12, *(_DWORD *)(v9 + 16), v18, 1u);
          --*(_DWORD *)a3;
        }
        v5 = v16;
      }
      v11 = v17 + 1;
      v17 = v11;
      if ( v11 >= a5 )
      {
        if ( !v7 )
          goto LABEL_20;
        break;
      }
    }
  }
  if ( *(_DWORD *)(v8 + v15 + 28) == *(_DWORD *)(v8 + v15 + 4) )
    ++*(_DWORD *)(v9 + 44);
  --*(_DWORD *)(v9 + 4);
  return v7;
}

//----- (10034982) --------------------------------------------------------
int __thiscall sub_10034982(int this, __int16 a2)
{
  int v2; // eax@1
  signed int v3; // esi@1
  int v4; // edx@2
  int v5; // ecx@2
  int result; // eax@5

  v3 = *(_WORD *)this;
  v2 = 0;
  if ( v3 <= 0 )
  {
LABEL_5:
    result = 0;
  }
  else
  {
    v5 = *(_DWORD *)(this + 4);
    v4 = 0;
    while ( *(_WORD *)(12 * v4 + v5 + 4) != a2 )
    {
      ++v2;
      v4 = (unsigned __int16)v2;
      if ( (unsigned __int16)v2 >= v3 )
        goto LABEL_5;
    }
    result = v5 + 12 * (unsigned __int16)v2;
  }
  return result;
}

//----- (100349BD) --------------------------------------------------------
BOOL __thiscall sub_100349BD(DWORD this)
{
  BOOL result; // eax@2
  DWORD flOldProtect; // [sp+0h] [bp-4h]@1

  flOldProtect = this;
  if ( dword_10069C70 < 3 )
  {
    result = *(_DWORD *)(this + 140);
    if ( *(_BYTE *)result == 1 )
      result = VirtualProtect((LPVOID)result, 1u, 2u, &flOldProtect);
  }
  else
  {
    result = sub_1003100A();
  }
  return result;
}
// 10069C70: using guessed type int dword_10069C70;

//----- (100349ED) --------------------------------------------------------
int __thiscall sub_100349ED(int this)
{
  return *(_DWORD *)(this + 24);
}

//----- (100349F1) --------------------------------------------------------
int __usercall sub_100349F1<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4<esi>)
{
  int v4; // eax@2

  sub_1002D0B8();
  if ( !dword_10069C60 )
  {
    *(_DWORD *)(a2 - 16) = &dword_10069CB4;
    sub_10028AD5(&dword_10069CB4);
    v4 = dword_10069C60;
    *(_DWORD *)(a2 - 4) = 0;
    if ( !v4 )
      sub_10035131(a1, a3, a4, 0);
    dword_10069CB4 = 0;
  }
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10069C60: using guessed type int dword_10069C60;
// 10069CB4: using guessed type int dword_10069CB4;

//----- (10034A3C) --------------------------------------------------------
int __userpurge sub_10034A3C<eax>(int a1<ecx>, int a2<esi>, int a3)
{
  int v3; // ebx@1
  int ebp0; // ebp@0
  signed int v5; // eax@2
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // esi@2
  unsigned int v9; // edx@5
  int v10; // edi@6
  int result; // eax@14
  signed int v12; // eax@21
  int v13; // eax@21
  int v14; // edx@21
  int v15; // ecx@21
  int v16; // ecx@21
  unsigned int v17; // esi@23
  int v18; // edi@24
  int v19; // ecx@33
  char v20; // [sp+Ch] [bp-18h]@33
  int v21; // [sp+18h] [bp-Ch]@2
  int v22; // [sp+1Ch] [bp-8h]@2
  unsigned __int16 v23; // [sp+20h] [bp-4h]@2
  unsigned __int8 v24; // [sp+22h] [bp-2h]@2

  v3 = a1;
  if ( sub_10036AE4(ebp0, a2) < 4 )
  {
    if ( sub_10036AE4(ebp0, a2) != 2 && sub_10036AE4(ebp0, a2) != 3 )
    {
      if ( dword_10069C70 == 1 )
      {
        if ( a3 )
          *(_DWORD *)a3 = 0;
        result = 0;
      }
      else
      {
        sub_10024A3F((int)&v20);
        sub_1002D02B((int)&v20, (int)&unk_1006091C);
        __asm { int     3               ; Trap to Debugger }
        result = *(_DWORD *)(*(_DWORD *)(v19 + 4) + 4);
      }
      return result;
    }
    v13 = sub_10031034();
    v16 = v13;
    v12 = 1 << v13;
    v21 = v16;
    v15 = *(_DWORD *)(v3 + 72);
    v14 = 0;
    v22 = v12;
    while ( 1 )
    {
      if ( v12 & *(_DWORD *)v15 )
      {
        v17 = 0;
        if ( *(_DWORD *)(v15 + 4) )
        {
          v18 = *(_DWORD *)(v15 + 32) + 8;
          do
          {
            if ( *(_BYTE *)v18 == v21 )
            {
              if ( a3 )
                *(_DWORD *)a3 = v17;
              return v14;
            }
            ++v17;
            v18 += 36;
          }
          while ( v17 < *(_DWORD *)(v15 + 4) );
          v12 = v22;
        }
      }
      ++v14;
      v15 += 40;
    }
  }
  sub_10032B4B((int)&v23);
  v6 = v23;
  v5 = 1 << v24;
  v22 = v24;
  v7 = *(_DWORD *)(v3 + 72);
  v8 = 0;
  v21 = 1 << v24;
  while ( *(_DWORD *)(v7 + 12) != v6 || !(v5 & *(_DWORD *)v7) )
  {
LABEL_11:
    ++v8;
    v7 += 40;
  }
  v9 = 0;
  if ( !*(_DWORD *)(v7 + 4) )
  {
LABEL_10:
    v6 = v23;
    goto LABEL_11;
  }
  v10 = *(_DWORD *)(v7 + 32) + 8;
  while ( *(_BYTE *)v10 != v22 )
  {
    ++v9;
    v10 += 36;
    if ( v9 >= *(_DWORD *)(v7 + 4) )
    {
      v5 = v21;
      goto LABEL_10;
    }
  }
  if ( a3 )
    *(_DWORD *)a3 = v9;
  return v8;
}
// 10069C70: using guessed type int dword_10069C70;

//----- (10034B51) --------------------------------------------------------
int __thiscall sub_10034B51(int this)
{
  return *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 4) + 32) + 32);
}

//----- (10034B5B) --------------------------------------------------------
int __thiscall sub_10034B5B(int this)
{
  return *(_DWORD *)(*(_DWORD *)(this + 72) + 36);
}

//----- (10034B62) --------------------------------------------------------
int __thiscall sub_10034B62(int this)
{
  return *(_DWORD *)(*(_DWORD *)(this + 4) + 16);
}

//----- (10034B69) --------------------------------------------------------
int __thiscall sub_10034B69(int this)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10034B97(*(_DWORD *)(*(_DWORD *)(this + 4) + 12), *(_DWORD *)(this + 4));
  if ( v1 )
    result = *(_DWORD *)(v1 + 32);
  else
    result = 0;
  return result;
}

//----- (10034B80) --------------------------------------------------------
int __thiscall sub_10034B80(int this)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10034BBC(*(_DWORD *)(*(_DWORD *)(this + 4) + 24), *(_DWORD *)(this + 4));
  if ( v1 )
    result = *(_DWORD *)(v1 + 36);
  else
    result = 0;
  return result;
}

//----- (10034B97) --------------------------------------------------------
int __thiscall sub_10034B97(int this, int a2)
{
  int v2; // eax@1
  int result; // eax@2

  v2 = (a2 - *(_DWORD *)(this + 32)) / 36 + 1;
  if ( (unsigned int)v2 >= *(_DWORD *)(this + 4) )
    result = 0;
  else
    result = *(_DWORD *)(this + 32) + 36 * v2;
  return result;
}

//----- (10034BBC) --------------------------------------------------------
int __thiscall sub_10034BBC(int this, int a2)
{
  int v2; // eax@1
  int result; // eax@2

  v2 = (a2 - *(_DWORD *)(this + 72)) / 40 + 1;
  if ( (unsigned int)v2 >= *(_DWORD *)(this + 24) )
    result = 0;
  else
    result = *(_DWORD *)(this + 72) + 40 * v2;
  return result;
}

//----- (10034BE1) --------------------------------------------------------
int __usercall sub_10034BE1<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4<esi>)
{
  int v4; // eax@2

  sub_1002D0B8();
  if ( !dword_10069C68 )
  {
    *(_DWORD *)(a2 - 16) = &dword_10069CB4;
    sub_10028AD5(&dword_10069CB4);
    v4 = dword_10069C68;
    *(_DWORD *)(a2 - 4) = 0;
    if ( !v4 )
      sub_10035131(a1, a3, a4, 0);
    dword_10069CB4 = 0;
  }
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10069C68: using guessed type int dword_10069C68;
// 10069CB4: using guessed type int dword_10069CB4;

//----- (10034C2C) --------------------------------------------------------
int __thiscall sub_10034C2C(int this)
{
  return *(_DWORD *)(*(_DWORD *)(this + 4) + 20);
}

//----- (10034C42) --------------------------------------------------------
int __cdecl sub_10034C42()
{
  _ECX = &unk_10067260;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return _EAX + 1;
}

//----- (10034C50) --------------------------------------------------------
int __usercall sub_10034C50<eax>(int a1<ebx>, int a2)
{
  int result; // eax@2

  if ( dword_10069C70 < 4 )
    result = sub_10032B61(a1, (int)&dword_10069C74);
  else
    result = sub_10032BFC(a2, (int)&dword_10069C74);
  dword_10069C78 = (LPVOID)result;
  return result;
}
// 10032BFC: using guessed type int __cdecl sub_10032BFC(int, int);
// 10069C70: using guessed type int dword_10069C70;
// 10069C74: using guessed type int dword_10069C74;

//----- (10034C79) --------------------------------------------------------
unsigned int __thiscall sub_10034C79(int this, int a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // edx@1
  int ebp0; // ebp@0
  int v6; // ecx@2
  int v7; // esi@2
  int v8; // ebx@4
  int v9; // eax@5
  int v10; // edi@6
  int v11; // eax@8
  int v12; // ecx@8
  unsigned int v13; // [sp+Ch] [bp-14h]@1
  int v14; // [sp+10h] [bp-10h]@5
  int v15; // [sp+14h] [bp-Ch]@5
  int v16; // [sp+18h] [bp-8h]@1
  int v17; // [sp+1Ch] [bp-4h]@2

  v4 = this;
  result = 0;
  v16 = this;
  v13 = 0;
  if ( *(_DWORD *)(this + 24) )
  {
    v6 = 0;
    v17 = 0;
    v7 = *(_DWORD *)(a2 + 16) + 44;
    do
    {
      if ( *(_DWORD *)(v7 - 12) )
      {
        v8 = 0;
        if ( *(_DWORD *)(v7 - 40) )
        {
          v15 = 0;
          v9 = 0;
          v14 = 0;
          do
          {
            v10 = v9 + *(_DWORD *)(v7 + 4);
            if ( *(_DWORD *)v10 == 4 )
            {
              if ( *(_BYTE *)(v10 + 49) )
              {
                v11 = v15 + *(_DWORD *)(v6 + *(_DWORD *)(v4 + 72) + 32);
                v12 = *(_DWORD *)(v11 + 16);
                if ( v12 == 1 )
                {
                  sub_10044106(a2, v7 - 44, v8);
                  v4 = v16;
                  v6 = v17;
                  if ( *(_BYTE *)(v10 + 48) )
                  {
                    --*(_DWORD *)v7;
                    --*(_DWORD *)(a3 + 24);
                  }
                }
                else
                {
                  if ( v12 - *(_DWORD *)(v11 + 28) > (unsigned int)(*(_BYTE *)(v10 + 48) == 0) )
                  {
                    *(_DWORD *)(v11 + 16) = v12 - 1;
                    if ( *(_BYTE *)(v10 + 48) )
                      sub_10036A77(v4, v7 - 44, v10, v17 + *(_DWORD *)(v4 + 72), v11, a3);
                    sub_10043F22(ebp0, v7 - 44, v8);
                    v4 = v16;
                  }
                  v6 = v17;
                }
              }
            }
            v14 += 52;
            v15 += 36;
            v9 = v14;
            ++v8;
          }
          while ( (unsigned int)v8 < *(_DWORD *)(v7 - 40) );
          result = v13;
        }
      }
      ++result;
      v6 += 40;
      v7 += 52;
      v13 = result;
      v17 = v6;
    }
    while ( result < *(_DWORD *)(v4 + 24) );
  }
  return result;
}

//----- (10034D92) --------------------------------------------------------
int __thiscall sub_10034D92(void *this, int a2, int a3)
{
  int ebp0; // ebp@0
  int v4; // edi@1
  int v5; // esi@1
  int result; // eax@2
  int v7; // esi@2
  unsigned int v8; // edx@4
  int v9; // edi@5
  int v10; // ecx@8
  int v11; // edx@9
  int v12; // ecx@11
  unsigned int v13; // eax@14
  int v14; // eax@14
  unsigned int v15; // [sp+Ch] [bp-1Ch]@4
  int v16; // [sp+10h] [bp-18h]@14
  int v17; // [sp+14h] [bp-14h]@5
  int v18; // [sp+18h] [bp-10h]@9
  int v19; // [sp+1Ch] [bp-Ch]@8
  int v20; // [sp+20h] [bp-8h]@1
  int v21; // [sp+24h] [bp-4h]@9

  v5 = *(_DWORD *)(a2 + 160);
  v20 = (int)this;
  v4 = v5 - *(_DWORD *)(a2 + 168);
  if ( v5 - *(_DWORD *)(a3 + 24) - *(_DWORD *)(a3 + 36) >= (unsigned int)(v5
                                                                        - *(_DWORD *)(a2 + 168)
                                                                        - (*(_DWORD *)(a2 + 184)
                                                                         + sub_10035370(a2))) )
  {
    result = *(_DWORD *)(a2 + 184) + sub_10035370(a2);
    v7 = v4 - result;
  }
  else
  {
    result = a3;
    v7 = v5 - *(_DWORD *)(a3 + 24) - *(_DWORD *)(a3 + 36);
  }
  v8 = 0;
  v15 = 0;
  if ( v7 )
  {
    v17 = 0;
    v9 = *(_DWORD *)(a2 + 16) + 36;
    do
    {
      result = v20;
      if ( v8 >= *(_DWORD *)(v20 + 24) )
        break;
      result = *(_DWORD *)(v9 - 8) - *(_DWORD *)v9;
      if ( *(_DWORD *)(v9 - 8) != *(_DWORD *)v9 )
      {
        v10 = 0;
        v19 = 0;
        if ( v7 )
        {
          v21 = 0;
          result = 0;
          v11 = 0;
          v18 = 0;
          do
          {
            if ( (unsigned int)v10 >= *(_DWORD *)(v9 - 32) )
              break;
            v12 = v11 + *(_DWORD *)(v9 + 12);
            if ( *(_DWORD *)v12 == 4 )
            {
              if ( !*(_DWORD *)(v12 + 40) )
              {
                if ( !*(_BYTE *)(v12 + 49) )
                {
                  v14 = v21 + *(_DWORD *)(*(_DWORD *)(v20 + 72) + v17 + 32);
                  v16 = v14;
                  v13 = *(_DWORD *)(v14 + 16);
                  if ( v13 > 1 )
                  {
                    *(_DWORD *)(v16 + 16) = v13 - 1;
                    if ( *(_BYTE *)(v12 + 48) )
                      sub_10036A77(v20, v9 - 36, v12, v17 + *(_DWORD *)(v20 + 72), v16, a3);
                    sub_10043F22(ebp0, v9 - 36, v19);
                    --v7;
                  }
                  v11 = v18;
                }
                result = v21;
              }
            }
            v10 = v19 + 1;
            v11 += 52;
            result += 36;
            ++v19;
            v18 = v11;
            v21 = result;
          }
          while ( v7 );
          v8 = v15;
        }
      }
      v17 += 40;
      ++v8;
      v9 += 52;
      v15 = v8;
    }
    while ( v7 );
  }
  return result;
}

//----- (10034EE7) --------------------------------------------------------
void __thiscall sub_10034EE7(int this)
{
  int v1; // edi@1
  unsigned int v2; // esi@1
  int v3; // ebx@2
  int v4; // eax@3

  v1 = this;
  v2 = 0;
  if ( *(_DWORD *)(this + 8) )
  {
    do
    {
      v3 = *(_DWORD *)(*(_DWORD *)(v1 + 84) + 4 * v2);
      if ( *(_BYTE *)(v3 + 33) == 1 )
      {
        v4 = sub_100336B7(*(_DWORD *)(v3 + 16));
        *(_DWORD *)(v3 + 36) = sub_10043555(*(void **)(v3 + 16), v4);
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)(v1 + 8) );
  }
}

//----- (10034F1D) --------------------------------------------------------
char __userpurge sub_10034F1D<al>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, char a7)
{
  int v7; // eax@1
  int v8; // esi@1
  char result; // al@4

  v8 = a2;
  v7 = sub_10027EB3(a1, a2, a3, a4, 8);
  if ( v7 )
  {
    *(_DWORD *)v7 = &off_100595C0;
    *(_DWORD *)(v7 + 4) = v8;
  }
  else
  {
    v7 = 0;
  }
  *(_DWORD *)(v8 + 32) = v7;
  *(_DWORD *)(v8 + 12) = a5;
  *(_DWORD *)(v8 + 4) = a6;
  result = a7;
  *(_BYTE *)(v8 + 8) = a7;
  return result;
}
// 100595C0: using guessed type int (*off_100595C0)();

//----- (10034F56) --------------------------------------------------------
void *__userpurge sub_10034F56<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, unsigned __int16 a6, unsigned __int16 a7, void *a8, int a9, char a10)
{
  int v10; // eax@1
  int v11; // esi@1
  int i; // edx@5
  void *v13; // ecx@5
  int v14; // eax@9
  __int64 v15; // qcx@9
  int v16; // edi@9
  signed __int64 v18; // qax@9
  void *v19; // ecx@10
  void *result; // eax@12
  int v21; // edx@12
  signed int v22; // ST08_4@12
  int v23; // edi@13
  int v24; // eax@16
  int v25; // edx@16
  char v26; // [sp-4h] [bp-10h]@16
  int v27; // [sp+1Ch] [bp+10h]@16

  v11 = a2;
  v10 = sub_10027EB3(a1, a2, a3, a4, 8);
  if ( v10 )
  {
    *(_DWORD *)v10 = off_100595CC;
    *(_DWORD *)(v10 + 4) = v11;
  }
  else
  {
    v10 = 0;
  }
  *(_DWORD *)(v11 + 36) = v10;
  *(_DWORD *)(v11 + 24) = a5;
  *(_DWORD *)(v11 + 16) = a6;
  *(_DWORD *)(v11 + 12) = a7;
  *(_DWORD *)v11 = a8;
  if ( a9 )
  {
    *(_DWORD *)(v11 + 4) = a9;
  }
  else
  {
    v13 = a8;
    for ( i = 0; v13; v13 = (void *)((unsigned int)((char *)v13 - 1) & (unsigned int)v13) )
      ++i;
    *(_DWORD *)(v11 + 4) = (unsigned __int16)i;
  }
  v16 = *(_DWORD *)(v11 + 4);
  _ECX = 0;
  v18 = 36i64 * *(_DWORD *)(v11 + 4);
  __asm { seto    cl }
  *(_DWORD *)(v11 + 8) = 0;
  v15 = (_DWORD)v18 | (unsigned int)-_ECX;
  v14 = sub_10021CF0(SHIDWORD(v18), v15 + 4, SHIDWORD(v15), v16, (v15 + 4) | -((_DWORD)v15 >= 0xFFFFFFFCu));
  if ( v14 )
  {
    *(_DWORD *)v14 = v16;
    v19 = (void *)(v14 + 4);
  }
  else
  {
    v19 = 0;
  }
  v22 = 36 * *(_DWORD *)(v11 + 4);
  *(_DWORD *)(v11 + 32) = v19;
  result = sub_10030CF0(v19, 0, v22);
  v21 = 0;
  if ( *(_DWORD *)(v11 + 4) > 0u )
  {
    result = a8;
    LODWORD(v15) = a9;
    v23 = 0;
    while ( !(_DWORD)v15 )
    {
      if ( (_BYTE)result & 1 )
      {
        v24 = *(_DWORD *)(v11 + 12);
        LODWORD(v15) = v23 + *(_DWORD *)(v11 + 32);
        v25 = v21 + 1;
        v27 = v25;
        v26 = BYTE4(v15);
LABEL_18:
        v23 += 36;
        sub_10034F1D(v25, v15, SHIDWORD(v15), v23, v11, HIDWORD(v15) + (v24 << 8), v26);
        LODWORD(v15) = a9;
        v21 = v27;
        result = a8;
      }
      result = (void *)((unsigned int)result >> 1);
      v15 += 4294967296i64;
      a8 = result;
      if ( (unsigned int)v21 >= *(_DWORD *)(v11 + 4) )
        return result;
    }
    LODWORD(v15) = v23 + *(_DWORD *)(v11 + 32);
    v26 = BYTE4(v15) + a10;
    v27 = v21 + 1;
    v25 = a6;
    v24 = a6 + (*(_DWORD *)(v11 + 12) << 8);
    goto LABEL_18;
  }
  return result;
}
// 100595CC: using guessed type int (*off_100595CC[3])();

//----- (1003506F) --------------------------------------------------------
void *__thiscall sub_1003506F(int this)
{
  unsigned int v1; // eax@1
  int v2; // esi@1
  void *v3; // ST10_4@3
  signed __int64 v5; // qax@3
  signed __int64 v7; // qax@4
  signed __int64 v9; // qax@4
  void *result; // eax@5

  v2 = this;
  v1 = *(_DWORD *)(this + 12);
  if ( v1 < *(_DWORD *)(this + 8) )
  {
    do
      v1 *= 2;
    while ( v1 < *(_DWORD *)(this + 8) );
    v3 = *(void **)(this + 84);
    *(_DWORD *)(this + 12) = v1;
    sub_1002401B(v3);
    sub_1002401B(*(LPVOID *)(v2 + 88));
    sub_1002401B(*(LPVOID *)(v2 + 92));
    _ECX = 0;
    v5 = 4i64 * *(_DWORD *)(v2 + 12);
    __asm { seto    cl }
    *(_DWORD *)(v2 + 84) = sub_10021CF0(SHIDWORD(v5), v5 | -_ECX, 4, 0, v5 | -_ECX);
    if ( *(_DWORD *)(v2 + 88) )
    {
      _ECX = 0;
      v7 = 4i64 * *(_DWORD *)(v2 + 12);
      __asm { seto    cl }
      *(_DWORD *)(v2 + 88) = sub_10021CF0(SHIDWORD(v7), v7 | -_ECX, 4, 0, v7 | -_ECX);
      _ECX = 0;
      v9 = 4i64 * *(_DWORD *)(v2 + 12);
      __asm { seto    cl }
      *(_DWORD *)(v2 + 92) = sub_10021CF0(SHIDWORD(v9), v9 | -_ECX, 4, 0, v9 | -_ECX);
    }
  }
  result = sub_10030CF0(*(void **)(v2 + 84), 0, 4 * *(_DWORD *)(v2 + 8));
  if ( *(_DWORD *)(v2 + 88) )
  {
    sub_10030CF0(*(void **)(v2 + 88), 0, 4 * *(_DWORD *)(v2 + 8));
    result = sub_10030CF0(*(void **)(v2 + 92), 0, 4 * *(_DWORD *)(v2 + 8));
  }
  return result;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (10035131) --------------------------------------------------------
void __usercall sub_10035131(int a1<ebx>, int a2<edi>, int a3<esi>, char a4)
{
  signed int v4; // eax@1
  int ebp0; // ebp@0
  int v6; // ecx@3
  int v7; // edx@6
  unsigned int v8; // ecx@6
  int v9; // ebx@6
  LPVOID v10; // edi@6
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // ecx@9
  int v14; // edx@10
  unsigned int v15; // eax@24
  int v16; // ecx@24
  int v17; // edi@24
  int v18; // esi@24
  int v19; // ecx@26
  int v20; // edx@27
  ULONG_PTR v21; // ecx@42
  int i; // edx@44
  void *v23; // esi@47
  int v24; // [sp+0h] [bp-10h]@6
  int v25; // [sp+4h] [bp-Ch]@6
  int v26; // [sp+4h] [bp-Ch]@24
  int v27; // [sp+8h] [bp-8h]@6
  signed int v28; // [sp+8h] [bp-8h]@8
  unsigned int v29; // [sp+Ch] [bp-4h]@6
  unsigned int v30; // [sp+Ch] [bp-4h]@24

  v4 = dword_10069C70;
  if ( !dword_10069C70 )
  {
    sub_1003640A(a3);
    v4 = dword_10069C70;
  }
  v6 = dword_10069C58;
  if ( !dword_10069C58 )
  {
    sub_10033125(a1, ebp0, a2);
    v4 = dword_10069C70;
    v6 = dword_10069C58;
  }
  if ( v4 >= 4 )
  {
    sub_10034C50(a1, 65535);
    v10 = dword_10069C78;
    v8 = 0;
    v11 = 0;
    v7 = 0;
    v9 = 0;
    v29 = 0;
    v27 = 0;
    v25 = 0;
    v24 = 0;
    if ( dword_10069C74 )
    {
      do
      {
        if ( *(_DWORD *)v10 == 3 )
        {
          v28 = 0;
          v12 = (int)((char *)v10 + 32);
          do
          {
            sub_100330EC(v12);
            v13 = *(_DWORD *)v12;
            if ( *(_DWORD *)v12 )
            {
              ++v11;
              v14 = 0;
              do
              {
                ++v14;
                v13 &= v13 - 1;
              }
              while ( v13 );
              v25 += (unsigned __int16)v14;
            }
            v12 += 12;
            ++v28;
          }
          while ( v28 < *((_WORD *)v10 + 15) );
          v9 = v24;
          v8 = v29;
          v27 = v11;
        }
        if ( *(_DWORD *)v10 == 1 )
        {
          sub_100330EC((int)((char *)v10 + 32));
          v11 = v27;
          v8 = v29;
          if ( *((_DWORD *)v10 + 8) )
          {
            ++v9;
            v24 = v9;
          }
        }
        v8 += *((_DWORD *)v10 + 1);
        v10 = (char *)v10 + *((_DWORD *)v10 + 1);
        v29 = v8;
      }
      while ( v8 < dword_10069C74 );
      v7 = v25;
    }
    byte_10069C64 = v11 > (unsigned int)v9;
    dword_10069C68 = v11;
    if ( v11 <= (unsigned int)v9 )
      dword_10069C68 = v9;
    dword_10069C60 = v7;
    dword_10069C6C = v9;
LABEL_39:
    if ( !a4 )
      sub_1003323C(v9);
    goto LABEL_47;
  }
  if ( v4 == 3 )
  {
    sub_10034C50(a1, 65535);
    v18 = (int)dword_10069C78;
    v15 = 0;
    v16 = 0;
    v9 = 0;
    v17 = 0;
    v30 = 0;
    v26 = 0;
    if ( dword_10069C74 )
    {
      do
      {
        if ( *(_DWORD *)(v18 + 4) == 3 )
        {
          sub_100330BD(v18);
          v19 = *(_DWORD *)v18;
          if ( *(_DWORD *)v18 )
          {
            ++v9;
            v20 = 0;
            do
            {
              ++v20;
              v19 &= v19 - 1;
            }
            while ( v19 );
            v26 += (unsigned __int16)v20;
          }
          v15 = v30;
        }
        if ( *(_DWORD *)(v18 + 4) == 1 )
        {
          sub_100330BD(v18);
          v15 = v30;
          if ( *(_DWORD *)v18 )
            ++v17;
        }
        v15 += 24;
        v18 += 24;
        v30 = v15;
      }
      while ( v15 < dword_10069C74 );
      v16 = v26;
    }
    byte_10069C64 = v9 > (unsigned int)v17;
    dword_10069C68 = v9;
    if ( v9 <= (unsigned int)v17 )
      dword_10069C68 = v17;
    dword_10069C60 = v16;
    dword_10069C6C = v17;
    goto LABEL_39;
  }
  byte_10069C64 = 0;
  dword_10069C68 = 1;
  if ( v6 )
  {
    sub_10033125(a1, ebp0, a2);
    v21 = *(_DWORD *)sub_10034982(dword_10069C58, 0) & ProcessAffinityMask;
  }
  else
  {
    v21 = ProcessAffinityMask;
  }
  for ( i = 0; v21; v21 &= v21 - 1 )
    ++i;
  dword_10069C60 = (unsigned __int16)i;
  dword_10069C6C = 1;
LABEL_47:
  v23 = (void *)dword_10069C5C;
  if ( dword_10069C5C )
  {
    sub_1002404A(*(LPVOID *)(dword_10069C5C + 4));
    sub_1002404A(v23);
  }
  dword_10069C5C = 0;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10069C58: using guessed type int dword_10069C58;
// 10069C5C: using guessed type int dword_10069C5C;
// 10069C60: using guessed type int dword_10069C60;
// 10069C64: using guessed type char byte_10069C64;
// 10069C68: using guessed type int dword_10069C68;
// 10069C6C: using guessed type int dword_10069C6C;
// 10069C70: using guessed type int dword_10069C70;
// 10069C74: using guessed type int dword_10069C74;

//----- (10035370) --------------------------------------------------------
int __thiscall sub_10035370(int this)
{
  int result; // eax@1
  int v2; // ecx@1

  result = *(_DWORD *)(this + 172) - *(_DWORD *)(this + 184);
  v2 = *(_DWORD *)(this + 132);
  if ( result <= (unsigned int)v2 )
    result = v2;
  return result;
}

//----- (10035389) --------------------------------------------------------
int __userpurge sub_10035389<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, char a5)
{
  int v5; // edi@1
  int v6; // esi@1
  unsigned int v7; // ebx@3
  int v8; // ecx@4
  bool v9; // eax@5
  int v10; // eax@6
  int v11; // ebx@18
  unsigned int v13; // [sp+Ch] [bp-10h]@3
  int v14; // [sp+10h] [bp-Ch]@4
  unsigned int v15; // [sp+14h] [bp-8h]@7
  bool v16; // [sp+18h] [bp-4h]@4
  char v17; // [sp+27h] [bp+Bh]@9

  v6 = a3;
  v5 = a1;
  if ( (_BYTE)a4 )
    *(_DWORD *)(a3 + 16) = sub_100333B4(a1, a2, a1);
  v7 = 0;
  v13 = *(_DWORD *)(a3 + 160);
  if ( a5 )
  {
    v14 = sub_10033387(a3);
    v8 = sub_10033364(a3);
    v16 = v8;
    if ( (_BYTE)a4 )
    {
      v9 = v14;
    }
    else
    {
      v10 = sub_10035370(a3);
      v8 = (unsigned int)(*(_DWORD *)(a3 + 184) + v10) < *(_DWORD *)(v5 + 28);
      v16 = (unsigned int)(*(_DWORD *)(a3 + 184) + v10) < *(_DWORD *)(v5 + 28);
      v9 = v13 < v14;
    }
    v15 = v9;
  }
  else
  {
    v14 = *(_DWORD *)(a3 + 184) + sub_10035370(a3);
    v15 = v14;
    v8 = sub_100336B7(a3);
    v16 = v8;
  }
  v17 = 0;
  if ( v8 )
  {
    sub_1003689F(v5, v6, a5);
    sub_10035786(v5);
    v7 = sub_100361E1(v5, v6, v16, 0);
    if ( v7 < v16 )
    {
      if ( (_BYTE)a4 || v15 )
      {
        v17 = 1;
        v7 += sub_10035EAD(v5, v6, v16 - v7, -2);
        if ( v7 < v16 )
        {
          v7 += sub_100359E4(v5, v6, v7 + v13, v14, v13 + v16);
          if ( v7 < v15 )
          {
            v7 += sub_10035EAD(v5, v6, v15 - v7, -1);
            if ( v7 < v15 )
              v7 += sub_100361AD(v5, v6, v15 - v7);
          }
        }
      }
    }
    sub_100363B3(v5);
  }
  v11 = sub_10043AAA(v6, v7, a4, a5);
  if ( v17 )
    sub_10033257((void *)v5, v6);
  return v11;
}

//----- (100354DF) --------------------------------------------------------
int __thiscall sub_100354DF(int this, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  unsigned int v7; // edx@2
  unsigned int v8; // ebx@2
  int v9; // esi@3
  unsigned int v10; // ecx@6
  int v11; // edx@7
  char v12; // zf@7
  int v13; // [sp+8h] [bp-Ch]@3
  unsigned int v14; // [sp+Ch] [bp-8h]@2
  int v15; // [sp+10h] [bp-4h]@1
  unsigned int v16; // [sp+1Ch] [bp+8h]@6
  unsigned int v17; // [sp+20h] [bp+Ch]@6
  unsigned int v18; // [sp+24h] [bp+10h]@5

  v5 = a4;
  v15 = this;
  *(_DWORD *)a4 = a2;
  *(double *)(a4 + 8) = 0.0;
  result = a3;
  *(_DWORD *)(a4 + 16) = a3;
  v6 = *(_DWORD *)(a3 + 16);
  if ( v6 )
  {
    v7 = 0;
    v8 = 0;
    v14 = 0;
    if ( *(_DWORD *)(this + 24) )
    {
      result = 0;
      v13 = 0;
      v9 = v6 + 44;
      do
      {
        *(_DWORD *)(v9 - 4) = v7;
        *(_DWORD *)v9 = v7;
        if ( *(_DWORD *)(v9 - 16) > v7 )
        {
          v18 = v7;
          if ( *(_DWORD *)(v9 - 40) > v7 )
          {
            v17 = v7;
            v16 = v7;
            v10 = v7;
            do
            {
              v11 = v16 + *(_DWORD *)(v9 + 4);
              v12 = *(_DWORD *)v11 == 4;
              *(_BYTE *)(v11 + 48) = 0;
              if ( v12 )
              {
                if ( !*(_DWORD *)(v11 + 24) )
                {
                  sub_10036A77(
                    v15,
                    v9 - 44,
                    v11,
                    result + *(_DWORD *)(v15 + 72),
                    v17 + *(_DWORD *)(result + *(_DWORD *)(v15 + 72) + 32),
                    v5);
                  result = v13;
                  v10 = v18;
                }
              }
              v16 += 52;
              v17 += 36;
              ++v10;
              v18 = v10;
            }
            while ( v10 < *(_DWORD *)(v9 - 40) );
            v8 = v14;
            this = v15;
            v7 = 0;
          }
        }
        ++v8;
        result += 40;
        v9 += 52;
        v14 = v8;
        v13 = result;
      }
      while ( v8 < *(_DWORD *)(this + 24) );
    }
  }
  return result;
}

//----- (100355A5) --------------------------------------------------------
void *__thiscall sub_100355A5(int this)
{
  void *result; // eax@1
  int v2; // edi@1
  int v3; // esi@1
  int v4; // edi@2
  int v5; // eax@6
  int v6; // eax@6
  int v7; // ecx@6
  int v8; // esi@6
  unsigned int v9; // esi@10
  char v10; // al@12
  int v11; // ecx@13
  int v12; // [sp+8h] [bp-14h]@1
  unsigned int v13; // [sp+Ch] [bp-10h]@6
  int v14; // [sp+10h] [bp-Ch]@6
  int v15; // [sp+14h] [bp-8h]@1
  int v16; // [sp+18h] [bp-4h]@6

  v15 = 0;
  v3 = this;
  v12 = this;
  result = sub_1003506F(this);
  v2 = *(_DWORD *)(v3 + 100);
  if ( v2 )
    v4 = *(_DWORD *)(v2 + 24);
  else
    v4 = 0;
  while ( v4 )
  {
    sub_10030CF0((void *)(v4 + 64), 0, 56);
    sub_100354DF(v3, v15, v4, v4 + 64);
    if ( *(_BYTE *)(v4 + 204) )
    {
      v6 = *(_DWORD *)(v4 + 120);
      v7 = *(_DWORD *)(v4 + 8);
      v13 = 0;
      v14 = 0;
      v8 = *(_DWORD *)(v4 + 160);
      v16 = v6;
      (*(void (__stdcall **)(unsigned int *, int *, int *))(*(_DWORD *)v7 + 4))(&v13, &v14, &v16);
      v5 = sub_10042EBF(*(_DWORD *)(v4 + 56), v8, v13, v14, v16);
      *(_DWORD *)(v4 + 100) = v5;
      if ( (unsigned int)v5 > *(_DWORD *)(v4 + 160) )
        *(_DWORD *)(v4 + 100) = sub_10043555((void *)v4, v5);
      *(_DWORD *)(v4 + 120) = v16;
    }
    else
    {
      *(_DWORD *)(v4 + 100) = *(_DWORD *)(v4 + 160);
    }
    v9 = *(_DWORD *)(v4 + 160);
    if ( v9 )
    {
      if ( *(_DWORD *)(v4 + 84) )
        goto LABEL_12;
    }
    else
    {
      if ( !*(_DWORD *)(v4 + 196) )
        goto LABEL_12;
    }
    if ( v9 <= *(_DWORD *)(v4 + 100) && v9 < sub_100336B7(v4) )
    {
      v10 = 1;
      goto LABEL_13;
    }
LABEL_12:
    v10 = 0;
LABEL_13:
    v3 = v12;
    v11 = v15;
    *(_BYTE *)(v4 + 97) = v10;
    result = *(void **)(v12 + 84);
    *((_DWORD *)result + v11) = v4 + 64;
    v15 = v11 + 1;
    if ( v4 == *(_DWORD *)(v12 + 100) )
      v4 = 0;
    else
      v4 = *(_DWORD *)(v4 + 24);
  }
  return result;
}

//----- (100356B5) --------------------------------------------------------
void __fastcall sub_100356B5(int a1)
{
  unsigned int v1; // ebx@1
  int v2; // eax@2
  int v3; // edi@2
  int v4; // esi@2
  int v5; // edx@7
  unsigned int v6; // eax@14
  int v7; // [sp+4h] [bp-8h]@5
  unsigned int v8; // [sp+4h] [bp-8h]@10
  int v9; // [sp+8h] [bp-4h]@1

  v1 = 0;
  v9 = a1;
  if ( *(_DWORD *)(a1 + 8) )
  {
    do
    {
      v2 = *(_DWORD *)(a1 + 84);
      v3 = *(_DWORD *)(v2 + 4 * v1);
      v4 = *(_DWORD *)(v3 + 16);
      if ( *(_DWORD *)(v4 + 168) )
        sub_10034C79(a1, v4, *(_DWORD *)(v2 + 4 * v1));
      if ( *(_DWORD *)(v3 + 20) )
      {
        v7 = *(_DWORD *)(v4 + 160);
        if ( *(_DWORD *)(v3 + 36) > (unsigned int)(v7 - *(_DWORD *)(v3 + 20)) )
        {
          if ( *(_DWORD *)(v4 + 184) + sub_10035370(v4) <= (unsigned int)(v7 - *(_DWORD *)(v3 + 20)) )
            v5 = v7 - *(_DWORD *)(v3 + 20);
          else
            v5 = *(_DWORD *)(v4 + 184) + sub_10035370(v4);
          *(_DWORD *)(v3 + 36) = v5;
        }
      }
      v8 = *(_DWORD *)(v4 + 160);
      if ( *(_DWORD *)(v3 + 36) < v8 )
      {
        if ( v8 - *(_DWORD *)(v4 + 168) > *(_DWORD *)(v4 + 184) + sub_10035370(v4) )
          sub_10034D92((void *)v9, v4, v3);
      }
      if ( !*(_BYTE *)(v4 + 204) )
      {
        v6 = *(_DWORD *)(v4 + 160);
        if ( *(_DWORD *)(v3 + 36) > v6 )
          *(_DWORD *)(v3 + 36) = v6;
      }
      a1 = v9;
      ++v1;
    }
    while ( v1 < *(_DWORD *)(v9 + 8) );
  }
}

//----- (10035786) --------------------------------------------------------
unsigned int __thiscall sub_10035786(int this)
{
  int v1; // edi@1
  unsigned int v2; // esi@1
  unsigned int result; // eax@2
  int v4; // ecx@2

  v1 = this;
  v2 = 0;
  if ( *(_DWORD *)(this + 8) )
  {
    do
    {
      result = *(_DWORD *)(*(_DWORD *)(v1 + 84) + 4 * v2);
      v4 = *(_DWORD *)(result + 16);
      if ( *(_DWORD *)(v4 + 168) )
        result = sub_10034C79(v1, v4, *(_DWORD *)(*(_DWORD *)(v1 + 84) + 4 * v2));
      ++v2;
    }
    while ( v2 < *(_DWORD *)(v1 + 8) );
  }
  return result;
}

//----- (100357B5) --------------------------------------------------------
unsigned int __thiscall sub_100357B5(void *this, unsigned int a2)
{
  unsigned int v2; // edx@1
  unsigned int v3; // ecx@1
  void *v4; // esi@1
  int v5; // ebx@3
  int v6; // edi@3
  int v7; // eax@6
  unsigned int v8; // ecx@7
  int v9; // eax@9
  unsigned int v10; // ebx@10
  int v11; // edi@11
  int v12; // eax@14
  int v13; // ebx@16
  int v14; // edi@16
  int v15; // edi@21
  int v16; // ebx@22
  int v17; // ecx@23
  int v18; // esi@23
  char v19; // zf@28
  int v20; // ecx@29
  int v21; // eax@30
  int v22; // ebx@30
  int v23; // ecx@30
  int v24; // eax@30
  int v25; // ebx@30
  int v26; // edx@31
  int v27; // eax@32
  int v28; // ecx@32
  int v29; // edi@32
  unsigned int v30; // edi@32
  char v31; // cf@32
  unsigned int v32; // ebx@33
  int v33; // edi@33
  int v34; // eax@34
  unsigned int v35; // edx@34
  unsigned int v36; // eax@36
  int v37; // eax@39
  unsigned int v39; // [sp+Ch] [bp-30h]@7
  int v40; // [sp+10h] [bp-2Ch]@22
  int v41; // [sp+14h] [bp-28h]@32
  unsigned int v42; // [sp+18h] [bp-24h]@32
  int v43; // [sp+18h] [bp-24h]@34
  int v44; // [sp+20h] [bp-1Ch]@30
  int v45; // [sp+24h] [bp-18h]@23
  int v46; // [sp+24h] [bp-18h]@30
  int v47; // [sp+28h] [bp-14h]@23
  int v48; // [sp+28h] [bp-14h]@32
  void *v49; // [sp+2Ch] [bp-10h]@1
  int v50; // [sp+30h] [bp-Ch]@28
  int v51; // [sp+30h] [bp-Ch]@30
  int v52; // [sp+34h] [bp-8h]@21
  int v53; // [sp+38h] [bp-4h]@23
  int v54; // [sp+38h] [bp-4h]@32

  v2 = a2;
  v4 = this;
  v3 = 0;
  v49 = v4;
  if ( a2 )
  {
    if ( a2 <= 0 )
      goto LABEL_6;
    do
    {
      do
      {
        v6 = *((_DWORD *)v4 + 23);
        v5 = *(_DWORD *)(v6 + 4 * v3);
        if ( *(_DWORD *)(v5 + 4) )
          break;
        --v2;
        *(_DWORD *)(v6 + 4 * v3) = *(_DWORD *)(v6 + 4 * v2);
        *(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v2) = v5;
      }
      while ( v3 < v2 );
      a2 = v2;
LABEL_6:
      *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v3) + 40) = 0;
      *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v3) + 44) = 0;
      v7 = *(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v3++);
      *(_BYTE *)(v7 + 32) = 1;
    }
    while ( v3 < v2 );
  }
  v8 = 0;
  v39 = v2;
  if ( v2 )
  {
    if ( v2 <= 0 )
      goto LABEL_20;
    do
    {
      do
      {
        v9 = *(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v8);
        if ( *(_DWORD *)(v9 + 40) )
          break;
        v10 = 0;
        if ( *((_DWORD *)v4 + 6) )
        {
          v11 = *(_DWORD *)(*(_DWORD *)(v9 + 16) + 16) + 28;
          do
          {
            if ( *(_DWORD *)v11 )
            {
              if ( *(_DWORD *)v11 < *(_DWORD *)(v11 - 24) )
              {
                v12 = *(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v8);
                ++*(_DWORD *)(v12 + 40);
              }
            }
            ++v10;
            v11 += 52;
          }
          while ( v10 < *((_DWORD *)v4 + 6) );
        }
        v14 = *((_DWORD *)v4 + 23);
        v13 = *(_DWORD *)(v14 + 4 * v8);
        if ( !*(_DWORD *)(v13 + 40) )
        {
          --v2;
          *(_DWORD *)(v14 + 4 * v8) = *(_DWORD *)(v14 + 4 * v2);
          *(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v2) = v13;
        }
      }
      while ( v8 < v2 );
      a2 = v2;
LABEL_20:
      ++v8;
    }
    while ( v8 < v2 );
  }
  v15 = 0;
  v52 = 0;
  if ( v2 )
  {
    do
    {
      v40 = v15 + 1;
      v16 = v15 + 1;
      if ( v15 + 1 < v2 )
      {
        v53 = *((_DWORD *)v4 + 23);
        v17 = 4 * v15;
        v18 = v15;
        v45 = 4 * v15;
        v47 = 4 * v15;
        do
        {
          if ( *(_DWORD *)(*(_DWORD *)(v53 + 4 * v16) + 40) >= *(_DWORD *)(*(_DWORD *)(v17 + v53) + 40) )
          {
            v17 = v47;
          }
          else
          {
            v17 = 4 * v16;
            v18 = v16;
            v47 = 4 * v16;
          }
          ++v16;
        }
        while ( v16 < v2 );
        v15 = v52;
        v50 = v18;
        v19 = v52 == v18;
        v4 = v49;
        if ( !v19 )
        {
          v20 = *(_DWORD *)(v45 + v53);
          *(_DWORD *)(v45 + v53) = *(_DWORD *)(v53 + 4 * v50);
          v4 = v49;
          v15 = v52;
          *(_DWORD *)(*((_DWORD *)v49 + 23) + 4 * v50) = v20;
        }
      }
      v23 = *(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v15);
      v24 = *(_DWORD *)(v23 + 16);
      v25 = *(_DWORD *)(v24 + 16);
      v21 = *(_DWORD *)(v24 + 20);
      v46 = v25;
      v22 = 0;
      v51 = v21;
      v44 = 0;
      if ( *(_DWORD *)(v23 + 40) )
      {
        v26 = v21;
        do
        {
          v30 = *((_DWORD *)v4 + 6);
          v28 = v46 + 52 * *(_DWORD *)(v26 + 4 * v22);
          v41 = *(_DWORD *)(v26 + 4 * v22);
          v27 = v22 + 1;
          v42 = v30;
          v31 = v22 + 1 < v30;
          v29 = v52;
          v54 = v22;
          v48 = v22 + 1;
          if ( v31 )
          {
            v32 = v42;
            v33 = v27;
            do
            {
              v34 = v46 + 52 * *(_DWORD *)(v51 + 4 * v33);
              v43 = v34;
              v35 = *(_DWORD *)(v34 + 28);
              if ( !v35
                || v35 >= *(_DWORD *)(v34 + 4)
                || (v36 = *(_DWORD *)(v28 + 28)) != 0 && v36 < *(_DWORD *)(v28 + 4) && v35 <= v36 )
              {
                v37 = v54;
              }
              else
              {
                v28 = v43;
                v37 = v33;
                v54 = v33;
              }
              ++v33;
            }
            while ( v33 < v32 );
            v4 = v49;
            v29 = v52;
            v26 = v51;
            if ( v44 != v37 )
            {
              *(_DWORD *)(v51 + 4 * v44) = *(_DWORD *)(v51 + 4 * v37);
              *(_DWORD *)(v51 + 4 * v54) = v41;
            }
            v27 = v48;
          }
          v22 = v27;
          v44 = v27;
        }
        while ( (unsigned int)v27 < *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v29) + 40) );
        v2 = a2;
      }
      v15 = v40;
      v52 = v40;
    }
    while ( v40 < v2 );
  }
  return v39;
}

//----- (100359E4) --------------------------------------------------------
unsigned int __thiscall sub_100359E4(int this, int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  int v5; // eax@1
  unsigned int v6; // ecx@1
  unsigned int v7; // ebx@2
  int v8; // edi@2
  unsigned int v9; // esi@2
  int v10; // ecx@3
  int v11; // ST40_4@3
  int v12; // eax@3
  int v13; // eax@4
  signed int v15; // ebx@7
  int v16; // eax@9
  int v18; // edi@9
  double v19; // st7@9
  signed __int64 v20; // qax@9
  int v21; // ecx@9
  signed int v22; // edi@10
  int v23; // esi@10
  double v24; // st6@16
  unsigned int v25; // ecx@17
  double v26; // st7@17
  int v27; // eax@18
  char v28; // dl@19
  signed int v29; // ecx@19
  unsigned int v30; // edi@20
  unsigned __int8 v31; // cf@20
  unsigned __int8 v32; // zf@20
  double v33; // st7@21
  double v34; // st6@21
  int v35; // eax@25
  char v36; // dl@27
  double v37; // st7@27
  double v38; // st6@27
  int v39; // eax@31
  int v40; // eax@32
  int v41; // eax@32
  char v42; // cl@33
  double v43; // st7@33
  double v44; // st7@33
  double v45; // st6@33
  unsigned int v46; // ecx@37
  int v47; // eax@39
  int v48; // edx@39
  double v50; // [sp+4h] [bp-3Ch]@17
  double v51; // [sp+Ch] [bp-34h]@16
  double v52; // [sp+14h] [bp-2Ch]@9
  int v53; // [sp+20h] [bp-20h]@26
  unsigned int v54; // [sp+24h] [bp-1Ch]@1
  int v55; // [sp+2Ch] [bp-14h]@3
  unsigned int v56; // [sp+2Ch] [bp-14h]@20
  int v57; // [sp+2Ch] [bp-14h]@26
  int v58; // [sp+2Ch] [bp-14h]@31
  int v59; // [sp+30h] [bp-10h]@9
  int v60; // [sp+34h] [bp-Ch]@2
  unsigned int v61; // [sp+34h] [bp-Ch]@7
  int v62; // [sp+34h] [bp-Ch]@25
  int v63; // [sp+34h] [bp-Ch]@32
  int v64; // [sp+38h] [bp-8h]@1
  unsigned int v65; // [sp+3Ch] [bp-4h]@2
  int v66; // [sp+50h] [bp+10h]@3
  unsigned int v67; // [sp+50h] [bp+10h]@7
  signed int v68; // [sp+50h] [bp+10h]@9
  int v69; // [sp+50h] [bp+10h]@11
  int v70; // [sp+50h] [bp+10h]@20
  char v71; // [sp+53h] [bp+13h]@19
  int v72; // [sp+54h] [bp+14h]@20
  unsigned int v73; // [sp+54h] [bp+14h]@26
  int v74; // [sp+54h] [bp+14h]@32

  v54 = 0;
  v5 = this;
  v6 = *(_DWORD *)(this + 8);
  v64 = v5;
  if ( v6 > 1 )
  {
    v8 = *(_DWORD *)(v5 + 84) + 4;
    v9 = 1;
    v7 = a4;
    v65 = a3;
    v60 = v6 - 1;
    do
    {
      v11 = *(_DWORD *)(*(_DWORD *)v8 + 16);
      v66 = *(_DWORD *)(v11 + 184);
      v12 = sub_10035370(*(_DWORD *)(*(_DWORD *)v8 + 16));
      v10 = v11;
      v55 = *(_DWORD *)(v11 + 160) - *(_DWORD *)(v11 + 168);
      if ( v55 <= (unsigned int)(v66 + v12) )
      {
        v13 = v65;
      }
      else
      {
        ++v9;
        v7 += v66 + sub_10035370(v10);
        v13 = v55 + v65;
        v65 += v55;
      }
      v8 += 4;
    }
    while ( v60-- != 1 );
    v67 = v7;
    v15 = 1;
    v61 = v9;
    if ( v9 > 1 )
    {
      if ( v67 <= v13 )
      {
        _ECX = 0;
        v20 = 4i64 * v9;
        __asm { seto    cl }
        v16 = sub_10021CF0(SHIDWORD(v20), v20 | -_ECX, 1, v8, v20 | -_ECX);
        v18 = v16;
        v21 = **(_DWORD **)(v64 + 84);
        v59 = v16;
        *(_DWORD *)v16 = v21;
        *(double *)(v21 + 32) = (double)a5;
        v68 = 1;
        v19 = *(double *)(*(_DWORD *)v16 + 32) + 0.0;
        v52 = v19;
        if ( *(_DWORD *)(v64 + 8) > 1u )
        {
          v23 = v16 + 4;
          v22 = v68;
          do
          {
            v69 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v64 + 84) + 4 * v22) + 16);
            if ( *(_DWORD *)(v69 + 160) - *(_DWORD *)(v69 + 168) <= (unsigned int)(*(_DWORD *)(v69 + 184)
                                                                                 + sub_10035370(v69)) )
            {
              v19 = v52;
            }
            else
            {
              *(_DWORD *)v23 = v69 + 64;
              v23 += 4;
              v19 = *(double *)(v69 + 96) + v52;
              v52 = v19;
            }
            ++v22;
          }
          while ( (unsigned int)v22 < *(_DWORD *)(v64 + 8) );
          v9 = v61;
          v18 = v59;
          v15 = 1;
        }
        v24 = (double)v65;
        v51 = v24;
        while ( 1 )
        {
          v26 = v24 / v19;
          v25 = 0;
          v50 = v26;
          if ( v9 )
          {
            do
            {
              v27 = *(_DWORD *)(v18 + 4 * v25++);
              *(double *)(v27 + 8) = *(double *)(v27 + 32) * v26;
            }
            while ( v25 < v9 );
          }
          sub_100364F2(v18, v9);
          v28 = 0;
          v71 = 0;
          v29 = v15;
          if ( v9 <= v15 )
            goto LABEL_48;
          do
          {
            v70 = *(_DWORD *)(v18 + 4 * v29);
            v72 = *(_DWORD *)(*(_DWORD *)(v70 + 16) + 160) - *(_DWORD *)(*(_DWORD *)(v70 + 16) + 168);
            v30 = *(_DWORD *)(v70 + 4);
            v56 = v30;
            v31 = v30 < v72;
            v32 = v30 == v72;
            v18 = v59;
            if ( v31 | v32 )
            {
              v19 = v52;
            }
            else
            {
              v33 = (double)(unsigned int)v72 / (double)v56;
              v28 = v15;
              v52 = v52 - (1.0 - v33) * *(double *)(v70 + 32);
              v34 = v33 * *(double *)(v70 + 32);
              v19 = v52;
              *(_QWORD *)(v70 + 32) = *(_QWORD *)&v34;
            }
            ++v29;
          }
          while ( v29 < v9 );
          v24 = v51;
          v71 = v28;
          if ( !v28 )
          {
LABEL_48:
            v35 = 0;
            v62 = 0;
            if ( !v9 )
              goto LABEL_49;
            do
            {
              v53 = *(_DWORD *)(v18 + 4 * v35);
              v57 = *(_DWORD *)(v53 + 16);
              v73 = *(_DWORD *)(v53 + 4);
              if ( v73 <= sub_100336B7(v57) )
              {
                v19 = v52;
                v36 = v71;
              }
              else
              {
                v37 = (double)(unsigned int)sub_100336B7(v57) / (double)v73;
                v36 = v15;
                v71 = v15;
                v52 = v52 - (1.0 - v37) * *(double *)(v53 + 32);
                v38 = v37 * *(double *)(v53 + 32);
                v19 = v52;
                *(_QWORD *)(v53 + 32) = *(_QWORD *)&v38;
              }
              v35 = v62 + 1;
              v62 = v35;
            }
            while ( v35 < v9 );
            v24 = v51;
            if ( !v36 )
            {
LABEL_49:
              v39 = 0;
              v58 = 0;
              if ( !v9 )
                break;
              do
              {
                v40 = *(_DWORD *)(v18 + 4 * v39);
                v63 = v40;
                v41 = *(_DWORD *)(v40 + 16);
                v74 = *(_DWORD *)(v41 + 184);
                if ( (unsigned int)(v74 + sub_10035370(v41)) <= *(_DWORD *)(v63 + 4) )
                {
                  v19 = v52;
                  v42 = v71;
                }
                else
                {
                  v43 = (double)(unsigned int)(v74 + sub_10035370(*(_DWORD *)(v63 + 16)));
                  v42 = v15;
                  v44 = v43 / v50;
                  v71 = v15;
                  v52 = v44 - *(double *)(v63 + 32) + v52;
                  v45 = v44;
                  v19 = v52;
                  *(_QWORD *)(v63 + 32) = *(_QWORD *)&v45;
                }
                v39 = v58 + 1;
                v58 = v39;
              }
              while ( v39 < v9 );
              v24 = v51;
              if ( !v42 )
                break;
            }
          }
        }
        v46 = a3;
        if ( *(_DWORD *)(*(_DWORD *)v18 + 4) > a3 )
        {
          if ( v9 > v15 )
          {
            do
            {
              v47 = *(_DWORD *)(v18 + 4 * v15);
              v48 = *(_DWORD *)(v47 + 16);
              if ( *(_DWORD *)(v48 + 160) - *(_DWORD *)(v47 + 4) != *(_DWORD *)(v48 + 168) )
                sub_10035F02(v64, a2, v48, *(_DWORD *)(v48 + 160) - *(_DWORD *)(v47 + 4) - *(_DWORD *)(v48 + 168));
              ++v15;
            }
            while ( v15 < v9 );
            v46 = a3;
          }
          v54 = sub_100361E1(v64, a2, *(_DWORD *)(*(_DWORD *)v18 + 4) - v46, 0);
        }
        sub_1002401B((LPVOID)v18);
      }
    }
  }
  return v54;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (10035DB7) --------------------------------------------------------
int __thiscall sub_10035DB7(void *this)
{
  _ECX = (int)((char *)this + 4);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return _EAX + 1;
}

//----- (10035DC3) --------------------------------------------------------
int __stdcall sub_10035DC3(int a1, int a2)
{
  int (__stdcall **v3)(char); // [sp+0h] [bp-Ch]@6

  if ( !a1 )
  {
    a1 = (int)"pScheduler";
    goto LABEL_6;
  }
  if ( a2 != 65536 )
  {
    a1 = (int)"version";
LABEL_6:
    sub_10023687((int)&v3, &a1);
    v3 = &off_100542CC;
    sub_1002D02B((int)&v3, (int)&unk_10061764);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10035E16);
  }
  return sub_10033559(a1);
}
// 10033559: using guessed type _DWORD __stdcall sub_10033559(_DWORD);
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);

//----- (10035E16) --------------------------------------------------------
int __usercall sub_10035E16<eax>(int a1<ebp>)
{
  int v1; // edi@1
  int v2; // ecx@1
  int v10; // ST04_4@2

  sub_1002D0B8();
  v1 = v2;
  _EAX = v2 + 4;
  _EBX = -1;
  __asm { lock xadd [eax], ebx }
  if ( _EBX == 1 )
  {
    *(_DWORD *)(a1 - 16) = &dword_10069CB4;
    sub_10028AD5(&dword_10069CB4);
    v10 = dword_10069C4C;
    *(_DWORD *)(a1 - 4) = 0;
    dword_10069C4C = v1 != sub_1002C373(v10) ? dword_10069C4C : 0;
    *(_DWORD *)(a1 - 4) = -1;
    dword_10069CB4 = 0;
    if ( *(_DWORD *)(v1 + 76) )
    {
      sub_100244EB((LPCRITICAL_SECTION)(v1 + 44));
      *(_DWORD *)(v1 + 40) = 2;
      sub_10024670((LPCRITICAL_SECTION)(v1 + 44));
      SetEvent(*(HANDLE *)(v1 + 80));
      WaitForSingleObject(*(HANDLE *)(v1 + 76), 0xFFFFFFFFu);
    }
    sub_10032E7B(a1);
    sub_1002404A((LPVOID)v1);
  }
  return sub_1002D086(4);
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10069C4C: using guessed type int dword_10069C4C;
// 10069CB4: using guessed type int dword_10069CB4;

//----- (10035EAD) --------------------------------------------------------
unsigned int __thiscall sub_10035EAD(int this, int a2, unsigned int a3, int a4)
{
  unsigned int v4; // ebx@1
  signed int v5; // edi@1
  int v6; // esi@1
  char v7; // zf@5

  v6 = this;
  v5 = 1;
  v4 = 0;
  if ( *(_DWORD *)(this + 8) > 1u )
  {
    do
    {
      if ( sub_10035F02(v6, a2, *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 84) + 4 * v5) + 16), a4) )
        LOBYTE(v4) = 1;
      ++v5;
    }
    while ( (unsigned int)v5 < *(_DWORD *)(v6 + 8) );
    v7 = (_BYTE)v4 == 0;
    v4 = 0;
    if ( !v7 )
      v4 = sub_100361E1(v6, a2, a3, 0);
  }
  return v4;
}

//----- (10035F02) --------------------------------------------------------
char __thiscall sub_10035F02(int this, int a2, int a3, int a4)
{
  int v4; // edx@1
  int v5; // esi@1
  int v6; // eax@2
  int v7; // ebx@6
  int v8; // eax@7
  int v9; // edi@7
  int v10; // ecx@8
  unsigned int v11; // eax@9
  int v12; // edi@11
  int v14; // [sp+Ch] [bp-Ch]@7
  int v15; // [sp+10h] [bp-8h]@7
  int v16; // [sp+14h] [bp-4h]@1
  int v17; // [sp+20h] [bp+8h]@7
  unsigned int v18; // [sp+24h] [bp+Ch]@9
  int v19; // [sp+28h] [bp+10h]@10

  v4 = a4;
  v5 = a3;
  v16 = this;
  if ( a4 == -2 )
  {
    v6 = *(_DWORD *)(a3 + 168);
    v4 = *(_DWORD *)(a3 + 168);
  }
  else
  {
    if ( a4 == -1 )
    {
      v4 = *(_DWORD *)(a3 + 168)
         + *(_DWORD *)(a3 + 160)
         - *(_DWORD *)(a3 + 108)
         - *(_DWORD *)(a3 + 168)
         - (*(_DWORD *)(a3 + 184)
          + sub_10035370(a3));
      this = v16;
    }
    v6 = 0;
  }
  v7 = v4 - v6;
  if ( !v4
    || (v9 = *(_DWORD *)(a3 + 16),
        v15 = *(_DWORD *)(a2 + 20),
        v8 = 0,
        v14 = *(_DWORD *)(a3 + 16),
        v17 = 0,
        !*(_DWORD *)(this + 24)) )
    return 0;
  while ( 1 )
  {
    v10 = v9 + 52 * *(_DWORD *)(v15 + 4 * v8);
    if ( *(_DWORD *)(v10 + 28) != *(_DWORD *)(v10 + 36) )
    {
      v11 = 0;
      v18 = 0;
      if ( *(_DWORD *)(v10 + 4) )
        break;
    }
LABEL_21:
    v8 = v17 + 1;
    v17 = v8;
    if ( (unsigned int)v8 >= *(_DWORD *)(v16 + 24) )
      return 0;
  }
  v19 = 0;
  while ( 1 )
  {
    v12 = v19 + *(_DWORD *)(v10 + 48);
    if ( *(_DWORD *)v12 != 4 || *(_DWORD *)(v12 + 40) )
      goto LABEL_19;
    if ( *(_BYTE *)(v12 + 49) || v7 )
    {
      *(_DWORD *)v12 = 5;
      ++*(_DWORD *)(v5 + 108);
      --**(_DWORD **)(v12 + 20);
      if ( !*(_BYTE *)(v12 + 49) )
        --v7;
      --v4;
      if ( !v4 )
        return 1;
    }
    v11 = v18;
LABEL_19:
    v19 += 52;
    ++v11;
    v18 = v11;
    if ( v11 >= *(_DWORD *)(v10 + 4) )
    {
      v9 = v14;
      goto LABEL_21;
    }
  }
}

//----- (10035FF8) --------------------------------------------------------
int __thiscall sub_10035FF8(int this, int a2)
{
  int result; // eax@1

  --*(_DWORD *)this;
  *(_DWORD *)(*(_DWORD *)(a2 + 24) + 28) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(*(_DWORD *)(a2 + 28) + 24) = *(_DWORD *)(a2 + 24);
  result = *(_DWORD *)(this + 4);
  if ( a2 == result )
  {
    if ( result == *(_DWORD *)(result + 24) )
      result = 0;
    else
      result = *(_DWORD *)(result + 28);
    *(_DWORD *)(this + 4) = result;
  }
  return result;
}

//----- (1003602E) --------------------------------------------------------
int __userpurge sub_1003602E<eax>(int a1<ebp>, int a2)
{
  int v2; // ebx@1
  struct _RTL_CRITICAL_SECTION *v3; // esi@1
  int v4; // ecx@1
  int v5; // ecx@1
  int v6; // edi@1

  sub_1002D0B8();
  v2 = v4;
  *(_DWORD *)(a1 - 16) = 0;
  v3 = (struct _RTL_CRITICAL_SECTION *)(v4 + 44);
  *(_DWORD *)(a1 - 20) = v4 + 44;
  sub_100244EB((LPCRITICAL_SECTION)(v4 + 44));
  v5 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  v6 = *(_DWORD *)(v5 + 20);
  sub_100428C5(v5);
  if ( *(_DWORD *)(v6 + 160) < (unsigned int)sub_100336B7(v6) )
  {
    if ( *(_DWORD *)(v2 + 8) == 1 )
    {
      if ( !sub_10033A6F(v2) )
        *(_BYTE *)(a1 - 16) = 1;
    }
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_10024670(v3);
  if ( *(_BYTE *)(a1 - 16) )
    SetEvent(*(HANDLE *)(v2 + 80));
  return sub_1002D086(8);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (100360A2) --------------------------------------------------------
int __userpurge sub_100360A2<eax>(int a1<ebp>, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  struct _RTL_CRITICAL_SECTION *v5; // esi@1
  int v6; // ecx@1
  char v7; // zf@1
  int v8; // eax@2
  int v9; // eax@6
  char v10; // bl@12
  int v12; // ebx@13
  signed __int64 v13; // qax@13
  signed __int64 v15; // qax@13

  sub_1002D0B8();
  v4 = v6;
  v5 = (struct _RTL_CRITICAL_SECTION *)(v6 + 44);
  *(_DWORD *)(a1 - 16) = 0;
  *(_BYTE *)(a1 - 20) = 0;
  *(_DWORD *)(a1 - 24) = v6 + 44;
  sub_100244EB((LPCRITICAL_SECTION)(v6 + 44));
  v7 = *(_BYTE *)(a1 + 12) == 0;
  *(_DWORD *)(a1 - 4) = 0;
  v3 = *(_DWORD *)(a1 + 8);
  if ( !v7 )
  {
    v8 = sub_10043E66(*(_DWORD *)(a1 + 8), a1);
    *(_DWORD *)(a1 - 16) = v8;
    if ( !v8 )
      *(_BYTE *)(a1 - 20) = 1;
  }
  if ( *(_DWORD *)(v3 + 132) == *(_DWORD *)(v3 + 128) )
    ++*(_DWORD *)(v4 + 16);
  ++*(_DWORD *)(v4 + 8);
  sub_10032F90(v4 + 96, v3);
  v9 = sub_10035389(v4, v3, v3, 1, *(_DWORD *)(a1 - 20));
  if ( !*(_DWORD *)(a1 - 16) )
    *(_DWORD *)(a1 - 16) = v9;
  if ( *(_DWORD *)(v3 + 132) == *(_DWORD *)(v3 + 128) )
    sub_100366D0((void *)v4, v3);
  if ( *(_DWORD *)(v4 + 8) == 2 )
  {
    v10 = 0;
    *(_DWORD *)(v4 + 40) = 1;
    if ( !*(_DWORD *)(v4 + 76) )
    {
      *(_DWORD *)(v4 + 76) = 1;
      _ECX = 0;
      v12 = 4;
      v13 = 4i64 * *(_DWORD *)(v4 + 12);
      __asm { seto    cl }
      *(_DWORD *)(v4 + 88) = sub_10021CF0(SHIDWORD(v13), v13 | -_ECX, 4, v4, v13 | -_ECX);
      _ECX = 0;
      v15 = 4i64 * *(_DWORD *)(v4 + 12);
      __asm { seto    cl }
      *(_DWORD *)(v4 + 92) = sub_10021CF0(SHIDWORD(v15), v15 | -_ECX, v12, v4, v15 | -_ECX);
      v10 = 1;
    }
    *(_DWORD *)(a1 - 4) = -1;
    sub_10024670(v5);
    SetEvent(*(HANDLE *)(v4 + 80));
    if ( v10 )
      sub_100334E1((LPVOID)v4);
  }
  else
  {
    *(_DWORD *)(a1 - 4) = -1;
    sub_10024670(v5);
  }
  return sub_1002D086(12);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (100361AD) --------------------------------------------------------
unsigned int __thiscall sub_100361AD(int this, int a2, unsigned int a3)
{
  int v3; // edi@1
  unsigned int v4; // esi@1
  unsigned int v5; // eax@2
  int v7; // [sp+8h] [bp-4h]@1

  v3 = 0;
  v4 = 0;
  v7 = this;
  if ( a3 )
  {
    do
    {
      ++v3;
      v5 = sub_100361E1(this, a2, a3 - v4, v3);
      this = v7;
      v4 += v5;
    }
    while ( v4 < a3 );
  }
  return v4;
}

//----- (100361E1) --------------------------------------------------------
unsigned int __thiscall sub_100361E1(int this, int a2, unsigned int a3, int a4)
{
  int v4; // ebx@1
  char v5; // dl@3
  int v6; // ecx@3
  unsigned int v7; // esi@3
  int v8; // ecx@4
  unsigned int v9; // eax@5
  int v10; // edi@6
  int v11; // edx@7
  unsigned int result; // eax@14
  int v13; // edi@15
  int v14; // eax@16
  int v15; // edx@17
  int v16; // ebx@17
  int v17; // esi@17
  int v18; // esi@20
  int v19; // eax@21
  char v20; // zf@23
  int v21; // ST10_4@23
  int v22; // ecx@23
  char v23; // cf@23
  int v24; // ebx@33
  unsigned int v25; // edi@33
  int v26; // eax@34
  int v27; // ecx@45
  unsigned int v28; // [sp+10h] [bp-1Ch]@3
  int v29; // [sp+10h] [bp-1Ch]@15
  int v30; // [sp+14h] [bp-18h]@1
  int v31; // [sp+18h] [bp-14h]@1
  unsigned int v32; // [sp+1Ch] [bp-10h]@5
  int v33; // [sp+1Ch] [bp-10h]@17
  int v34; // [sp+20h] [bp-Ch]@3
  int v35; // [sp+24h] [bp-8h]@3
  char v36; // [sp+2Bh] [bp-1h]@3
  unsigned int v37; // [sp+3Ch] [bp+10h]@14

  v30 = -1;
  v4 = this;
  v31 = this;
  if ( *(_BYTE *)(a2 + 104) )
    v30 = sub_10034A3C(this, a2, 0);
  v6 = *(_DWORD *)(a2 + 20);
  v7 = 0;
  v5 = 0;
  v34 = *(_DWORD *)(a2 + 16);
  v35 = *(_DWORD *)(a2 + 20);
  v36 = 0;
  v28 = 0;
  if ( *(_DWORD *)(v4 + 24) )
  {
    v8 = *(_DWORD *)(a2 + 16) + 8;
    do
    {
      v9 = 0;
      v32 = 0;
      if ( *(_DWORD *)(v8 - 4) )
      {
        v10 = 0;
        do
        {
          v11 = v10 + *(_DWORD *)(v8 + 40);
          if ( *(_DWORD *)v11 == 1 )
          {
            v9 = v32;
            if ( a4 == **(_DWORD **)(v11 + 20) )
            {
              *(_DWORD *)v11 = 2;
              ++*(_DWORD *)v8;
              v36 = 1;
            }
          }
          ++v9;
          v10 += 52;
          v32 = v9;
        }
        while ( v9 < *(_DWORD *)(v8 - 4) );
        v7 = v28;
        v4 = v31;
      }
      ++v7;
      v8 += 52;
      v28 = v7;
    }
    while ( v7 < *(_DWORD *)(v4 + 24) );
    v6 = v35;
    v5 = v36;
  }
  result = 0;
  v37 = 0;
  if ( v5 )
  {
    v13 = 0;
    v29 = 0;
    if ( *(_DWORD *)(v4 + 24) > 0u )
    {
      v14 = v31;
      do
      {
        v15 = v34 + 52 * *(_DWORD *)(v6 + 4 * v13);
        v17 = v13;
        v33 = v13;
        v16 = a3 - v37;
        if ( a3 != v37 )
        {
          if ( *(_DWORD *)(v15 + 8) > (unsigned int)v16 )
            *(_DWORD *)(v15 + 8) = v16;
          v18 = v13 + 1;
          if ( (unsigned int)(v13 + 1) < *(_DWORD *)(v14 + 24) )
          {
            do
            {
              v19 = v34 + 52 * *(_DWORD *)(v6 + 4 * v18);
              if ( *(_DWORD *)(v19 + 8) > (unsigned int)v16 )
                *(_DWORD *)(v19 + 8) = v16;
              v21 = *(_DWORD *)(v19 + 24) + *(_DWORD *)(v19 + 28) + *(_DWORD *)(v19 + 8);
              v22 = *(_DWORD *)(v15 + 8) + *(_DWORD *)(v15 + 24) + *(_DWORD *)(v15 + 28);
              v23 = v22 < (unsigned int)v21;
              v20 = v22 == v21;
              v6 = v35;
              if ( v23 || v20 && *(_BYTE *)(a2 + 104) && *(_DWORD *)(v35 + 4 * v18) == v30 )
              {
                v15 = v34 + 52 * *(_DWORD *)(v35 + 4 * v18);
                v33 = v18;
              }
              ++v18;
            }
            while ( (unsigned int)v18 < *(_DWORD *)(v31 + 24) );
            v13 = v29;
          }
          v17 = v33;
        }
        if ( *(_DWORD *)(v15 + 8) )
        {
          if ( *(_DWORD *)(v15 + 4) )
          {
            v25 = 0;
            v24 = 0;
            do
            {
              v26 = v24 + *(_DWORD *)(v15 + 48);
              if ( *(_DWORD *)v26 == 2 )
              {
                v6 = v35;
                if ( v37 >= a3 )
                {
                  *(_DWORD *)v26 = 1;
                }
                else
                {
                  *(_DWORD *)v26 = 3;
                  ++**(_DWORD **)(v26 + 20);
                  ++*(_DWORD *)(v15 + 24);
                  if ( *(_BYTE *)(a2 + 104) )
                  {
                    if ( *(_DWORD *)(v35 + 4 * v17) == v30 )
                      *(_BYTE *)(a2 + 104) = 0;
                  }
                  ++v37;
                }
              }
              ++v25;
              v24 += 52;
            }
            while ( v25 < *(_DWORD *)(v15 + 4) );
            v13 = v29;
          }
          *(_DWORD *)(v15 + 8) = 0;
        }
        if ( v13 != v17 )
        {
          v27 = *(_DWORD *)(v6 + 4 * v13);
          *(_DWORD *)(v35 + 4 * v13) = *(_DWORD *)(v35 + 4 * v17);
          *(_DWORD *)(v35 + 4 * v17) = v27;
        }
        v14 = v31;
        v6 = v35;
        ++v13;
        v29 = v13;
      }
      while ( (unsigned int)v13 < *(_DWORD *)(v31 + 24) );
      result = v37;
    }
  }
  return result;
}

//----- (100363B3) --------------------------------------------------------
int __thiscall sub_100363B3(int this)
{
  __int64 v1; // qax@1
  int v2; // esi@1
  int v3; // edi@2
  int v4; // ecx@3
  int v5; // ebx@4
  unsigned int v6; // esi@4
  int v7; // eax@5
  int v9; // [sp+4h] [bp-8h]@1

  v2 = this;
  v1 = 0i64;
  v9 = this;
  if ( *(_DWORD *)(this + 24) )
  {
    v3 = 0;
    do
    {
      v4 = v3 + *(_DWORD *)(v2 + 72);
      *(_DWORD *)(v4 + 8) = v1;
      *(_DWORD *)(v4 + 28) = v1;
      if ( *(_DWORD *)(v4 + 4) > (_DWORD)v1 )
      {
        v5 = v1;
        v6 = v1;
        do
        {
          v7 = v5 + *(_DWORD *)(v4 + 32);
          v5 += 36;
          *(_DWORD *)v7 = 0;
          *(_DWORD *)(v7 + 28) = 0;
          ++v6;
        }
        while ( v6 < *(_DWORD *)(v4 + 4) );
        v2 = v9;
        LODWORD(v1) = 0;
      }
      v1 += 4294967296i64;
      v3 += 40;
    }
    while ( HIDWORD(v1) < *(_DWORD *)(v2 + 24) );
  }
  return v1;
}

//----- (1003640A) --------------------------------------------------------
DWORD __usercall sub_1003640A<eax>(int a1<esi>)
{
  DWORD result; // eax@5
  char v2; // [sp+0h] [bp-124h]@20
  struct _OSVERSIONINFOW VersionInformation; // [sp+Ch] [bp-118h]@1
  unsigned int v4; // [sp+120h] [bp-4h]@1
  int v5; // [sp+124h] [bp+0h]@1

  v4 = (unsigned int)&v5 ^ __security_cookie;
  VersionInformation.dwOSVersionInfoSize = 276;
  if ( !GetVersionExW(&VersionInformation) )
  {
LABEL_20:
    sub_10024A3F((int)&v2);
    sub_1002D02B((int)&v2, (int)&unk_1006091C);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_100364F2);
  }
  if ( VersionInformation.dwMajorVersion != 5 )
  {
    if ( VersionInformation.dwMajorVersion != 6 )
      goto LABEL_24;
    result = VersionInformation.dwMinorVersion;
    if ( !VersionInformation.dwMinorVersion )
    {
      dword_10069C70 = 3;
      return result;
    }
    if ( VersionInformation.dwMinorVersion != 1 )
LABEL_24:
      dword_10069C70 = 6;
    else
      dword_10069C70 = 4;
LABEL_17:
    result = sub_10032A72();
    if ( dword_10069C70 >= 6 )
      result = sub_10044181(a1);
    return result;
  }
  if ( !VersionInformation.dwMinorVersion )
  {
    dword_10069C70 = 0;
    goto LABEL_20;
  }
  if ( VersionInformation.dwMinorVersion == 1 )
  {
    result = 1;
    dword_10069C70 = 1;
  }
  else
  {
    result = VersionInformation.dwMinorVersion - 2;
    if ( VersionInformation.dwMinorVersion == 2 )
    {
      dword_10069C70 = 2;
      return result;
    }
    result = dword_10069C70;
  }
  if ( (signed int)result >= 4 )
    goto LABEL_17;
  return result;
}
// 1003640A: could not find valid save-restore pair for esi
// 10067210: using guessed type int __security_cookie;
// 10069C70: using guessed type int dword_10069C70;

//----- (100364F2) --------------------------------------------------------
void __cdecl sub_100364F2(int a1, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // edi@1
  int v4; // esi@1
  double v5; // st6@1
  int v6; // ecx@2
  int v7; // esi@4
  double v8; // st5@4
  int v9; // eax@5
  int v10; // edx@5
  int v11; // esi@6
  int v12; // eax@8
  int v13; // ecx@12
  int v14; // ecx@16
  unsigned int v15; // esi@16
  double v16; // st4@17
  double v17; // qt0@18
  double v18; // st4@18
  double v19; // qt1@18
  double v20; // qt2@19
  double v21; // st4@19
  double v22; // st6@19
  double v23; // st4@20
  double v24; // st5@20
  double v25; // qtt@20
  double v26; // qt0@21
  double v27; // st4@24
  double v28; // st5@24
  double v29; // qt1@24
  int v30; // eax@25
  int v31; // eax@28
  int v32; // esi@28
  int v33; // edx@29
  int v34; // eax@31
  double v35; // qt0@32
  int v36; // eax@33
  double v37; // qt1@33
  double v38; // st4@33
  double v39; // qt2@33
  int v40; // ecx@40
  int v41; // [sp+Ch] [bp-10h]@1
  int v42; // [sp+14h] [bp-8h]@4
  int v43; // [sp+14h] [bp-8h]@28
  int v44; // [sp+18h] [bp-4h]@1
  int v45; // [sp+18h] [bp-4h]@5
  int v46; // [sp+28h] [bp+Ch]@5
  int v47; // [sp+28h] [bp+Ch]@28

  v5 = 0.0;
  v2 = 0;
  v3 = a2;
  v4 = 0;
  v41 = 0;
  v44 = 0;
  if ( a2 )
  {
    do
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 4 * v4) + 4) = sub_100446D6(0.0);
      v6 = *(_DWORD *)(a1 + 4 * v44);
      v4 = v44 + 1;
      v44 = v4;
      *(double *)(v6 + 8) = *(double *)(v6 + 8) - (double)*(unsigned int *)(v6 + 4);
    }
    while ( v4 < a2 );
    v2 = 0;
  }
  v8 = 0.0000001;
  v7 = v2;
  v42 = v2;
  if ( a2 )
  {
    do
    {
      v9 = v7 + 1;
      v46 = v7;
      v45 = v7 + 1;
      v10 = v7 + 1;
      if ( v7 + 1 < v3 )
      {
        v11 = 4 * v7;
        do
        {
          if ( *(double *)(*(_DWORD *)(v11 + a1) + 8) + 0.0000001 >= *(double *)(*(_DWORD *)(a1 + 4 * v10) + 8) )
          {
            v12 = v46;
          }
          else
          {
            v12 = v10;
            v46 = v10;
            v11 = 4 * v10;
          }
          ++v10;
        }
        while ( v10 < v3 );
        if ( v42 != v12 )
        {
          v13 = *(_DWORD *)(a1 + 4 * v42);
          *(_DWORD *)(a1 + 4 * v42) = *(_DWORD *)(a1 + 4 * v12);
          *(_DWORD *)(a1 + 4 * v46) = v13;
        }
        v9 = v45;
      }
      v7 = v9;
      v42 = v9;
    }
    while ( v9 < v3 );
    v2 = 0;
  }
  v15 = v2;
  v14 = v3 - 1;
  if ( v3 )
  {
    v16 = 1.0;
    while ( 1 )
    {
      v20 = v16;
      v21 = v5;
      v22 = v20;
      while ( v21 > v8 )
      {
        v25 = v21;
        v23 = v8;
        v24 = v25;
        if ( v23 < *(double *)(*(_DWORD *)(a1 + 4 * v14) + 8) )
        {
          while ( 1 )
          {
            v36 = *(_DWORD *)(a1 + 4 * v14);
            v37 = v23;
            v38 = v24;
            v8 = v37;
            --v14;
            v39 = v38 - *(double *)(v36 + 8);
            *(double *)(v36 + 8) = 0.0;
            v21 = v39;
            if ( v39 <= v37 )
              break;
            v35 = v21;
            v23 = v8;
            v24 = v35;
          }
        }
        else
        {
          --v14;
          v26 = v23;
          v21 = v24;
          v8 = v26;
        }
      }
      if ( v15 > v14 )
        break;
      v29 = v21;
      v27 = v8;
      v28 = v29;
      if ( v27 < *(double *)(*(_DWORD *)(a1 + 4 * v15) + 8) )
      {
        v30 = *(_DWORD *)(a1 + 4 * v15);
        v28 = v28 + v22 - *(double *)(v30 + 8);
        *(double *)(v30 + 8) = 0.0;
        ++*(_DWORD *)(*(_DWORD *)(a1 + 4 * v15) + 4);
      }
      ++v15;
      if ( v15 >= v3 )
        break;
      v17 = v27;
      v18 = v28;
      v8 = v17;
      v19 = v18;
      v16 = v22;
      v5 = v19;
    }
  }
  if ( v3 )
  {
    do
    {
      v31 = v2 + 1;
      v47 = v2;
      v43 = v2 + 1;
      v32 = v2 + 1;
      if ( v2 + 1 < v3 )
      {
        v33 = 4 * v2;
        do
        {
          if ( **(_DWORD **)(a1 + 4 * v32) >= **(_DWORD **)(v33 + a1) )
          {
            v34 = v47;
          }
          else
          {
            v34 = v32;
            v47 = v32;
            v33 = 4 * v32;
          }
          ++v32;
        }
        while ( v32 < v3 );
        if ( v41 != v34 )
        {
          v40 = *(_DWORD *)(a1 + 4 * v41);
          *(_DWORD *)(a1 + 4 * v41) = *(_DWORD *)(a1 + 4 * v34);
          *(_DWORD *)(a1 + 4 * v47) = v40;
        }
        v31 = v43;
      }
      v2 = v31;
      v41 = v31;
    }
    while ( v31 < v3 );
  }
}

//----- (100366B1) --------------------------------------------------------
char __thiscall sub_100366B1(void *this)
{
  int v2; // edx@2

  _ESI = (int)((char *)this + 4);
  while ( 1 )
  {
    v2 = *(_DWORD *)_ESI;
    if ( !*(_DWORD *)_ESI )
      break;
    _ECX = v2 + 1;
    __asm { lock cmpxchg [esi], ecx }
    if ( v2 == v2 )
      return 1;
  }
  return 0;
}

//----- (100366D0) --------------------------------------------------------
int __thiscall sub_100366D0(void *this, int a2)
{
  int result; // eax@1
  unsigned int v3; // ecx@1
  int v4; // ebx@1
  void *v5; // edi@1
  signed int v6; // edx@2
  int v7; // esi@2
  int v8; // edx@4
  int v9; // ecx@4
  int v10; // edx@5
  int v11; // ebx@5
  int v12; // eax@5
  int v13; // edx@6
  int v14; // ecx@9
  int v15; // eax@9
  int v16; // ecx@17
  unsigned int v17; // edx@19
  int v18; // ecx@20
  int v19; // eax@21
  int v20; // esi@21
  int v21; // esi@22
  int v22; // eax@27
  char v23; // zf@32
  signed int v24; // [sp-4h] [bp-30h]@30
  unsigned int v25; // [sp+Ch] [bp-20h]@21
  int v26; // [sp+10h] [bp-1Ch]@2
  unsigned int v27; // [sp+10h] [bp-1Ch]@19
  unsigned int v28; // [sp+14h] [bp-18h]@1
  int v29; // [sp+14h] [bp-18h]@20
  int v30; // [sp+18h] [bp-14h]@4
  int v31; // [sp+18h] [bp-14h]@17
  signed int v32; // [sp+1Ch] [bp-10h]@1
  signed int v33; // [sp+20h] [bp-Ch]@2
  int v34; // [sp+20h] [bp-Ch]@20
  int v35; // [sp+24h] [bp-8h]@4
  int v36; // [sp+24h] [bp-8h]@18
  int v37; // [sp+28h] [bp-4h]@3
  unsigned int v38; // [sp+28h] [bp-4h]@25

  v5 = this;
  v4 = 0;
  v3 = 0;
  result = 48;
  v28 = 0;
  v32 = 48;
  if ( *((_DWORD *)v5 + 6) )
  {
    v7 = 0;
    v26 = 0;
    v6 = 48;
    v33 = 48;
    do
    {
      result = v7 + *((_DWORD *)v5 + 18);
      v37 = v4;
      if ( *(_DWORD *)(result + 4) > (unsigned int)v4 )
      {
        v8 = v4;
        v35 = v4;
        v30 = v4;
        v9 = v4;
        do
        {
          v11 = v8 + *(_DWORD *)(result + 32);
          v12 = *(_DWORD *)(v11 + 20);
          *(_DWORD *)(v11 + 20) = 0;
          *(_DWORD *)(v11 + 24) = v12;
          v10 = *((_DWORD *)v5 + 25);
          if ( v10 )
            v13 = *(_DWORD *)(v10 + 24);
          else
            v13 = 0;
          if ( v13 )
          {
            do
            {
              v14 = v35 + *(_DWORD *)(v33 + *(_DWORD *)(v13 + 16));
              *(_DWORD *)(v14 + 32) = *(_DWORD *)(v14 + 28);
              v15 = *(_DWORD *)(v14 + 24);
              *(_DWORD *)(v14 + 28) = v15;
              *(_DWORD *)(v11 + 20) += v15;
              if ( v13 == *((_DWORD *)v5 + 25) )
                v13 = 0;
              else
                v13 = *(_DWORD *)(v13 + 24);
            }
            while ( v13 );
            v7 = v26;
            v9 = v37;
          }
          v35 += 52;
          ++v9;
          result = v7 + *((_DWORD *)v5 + 18);
          v8 = v30 + 36;
          v37 = v9;
          v30 += 36;
        }
        while ( (unsigned int)v9 < *(_DWORD *)(result + 4) );
        v3 = v28;
        v6 = v33;
        v4 = 0;
      }
      ++v3;
      v7 += 40;
      v6 += 52;
      v28 = v3;
      v26 = v7;
      v33 = v6;
    }
    while ( v3 < *((_DWORD *)v5 + 6) );
  }
  v16 = v4;
  v31 = v4;
  if ( *((_DWORD *)v5 + 6) <= (unsigned int)v4 )
    return result;
  v36 = v4;
  do
  {
    v17 = 0;
    result = v4 + *((_DWORD *)v5 + 18);
    v27 = 0;
    if ( !*(_DWORD *)(result + 4) )
      goto LABEL_46;
    v34 = 0;
    v18 = 0;
    v29 = 0;
    do
    {
      v19 = *(_DWORD *)(result + 32);
      v25 = *(_DWORD *)(v19 + v18 + 24);
      v20 = *((_DWORD *)v5 + 25);
      if ( v20 )
        v21 = *(_DWORD *)(v20 + 24);
      else
        v21 = 0;
      if ( v21 )
      {
        v38 = *(_DWORD *)(v19 + v18 + 20);
        while ( 1 )
        {
          if ( *(_DWORD *)(v21 + 132) != *(_DWORD *)(v21 + 128)
            || (v22 = v34 + *(_DWORD *)(v32 + *(_DWORD *)(v21 + 16)), !*(_DWORD *)(v22 + 36)) )
            goto LABEL_39;
          if ( v21 == a2 )
          {
            if ( v38 <= *(_DWORD *)(v22 + 28) )
              goto LABEL_37;
            v24 = 1;
          }
          else
          {
            if ( v25 != *(_DWORD *)(v22 + 32) )
            {
              v23 = v38 == *(_DWORD *)(v22 + 28);
LABEL_35:
              if ( !v23 || v25 <= *(_DWORD *)(v22 + 32) )
                goto LABEL_39;
LABEL_37:
              v24 = 0;
              goto LABEL_38;
            }
            v23 = v38 == *(_DWORD *)(v22 + 28);
            if ( v38 <= *(_DWORD *)(v22 + 28) )
              goto LABEL_35;
            v24 = 1;
          }
LABEL_38:
          sub_1004402D(v22, v24);
LABEL_39:
          if ( v21 == *((_DWORD *)v5 + 25) )
            v21 = 0;
          else
            v21 = *(_DWORD *)(v21 + 24);
          if ( !v21 )
          {
            v4 = v36;
            v17 = v27;
            v18 = v29;
            break;
          }
        }
      }
      v34 += 52;
      ++v17;
      result = v4 + *((_DWORD *)v5 + 18);
      v18 += 36;
      v27 = v17;
      v29 = v18;
    }
    while ( v17 < *(_DWORD *)(result + 4) );
    v16 = v31;
LABEL_46:
    v32 += 52;
    ++v16;
    v4 += 40;
    v31 = v16;
    v36 = v4;
  }
  while ( (unsigned int)v16 < *((_DWORD *)v5 + 6) );
  return result;
}
// 1004402D: using guessed type _DWORD __stdcall sub_1004402D(_DWORD, _DWORD);

//----- (1003689F) --------------------------------------------------------
int __thiscall sub_1003689F(int this, int a2, char a3)
{
  int result; // eax@1
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // edi@2
  int v7; // [sp+1Ch] [bp+Ch]@1

  v4 = this;
  sub_1003506F(this);
  sub_10030CF0((void *)(a2 + 64), 0, 48);
  sub_100354DF(v4, 0, a2, a2 + 64);
  *(double *)(a2 + 96) = (double)(unsigned int)sub_100336B7(a2);
  *(_BYTE *)(a2 + 104) = a3;
  result = *(_DWORD *)(v4 + 84);
  v7 = 1;
  *(_DWORD *)result = a2 + 64;
  v5 = *(_DWORD *)(v4 + 100);
  if ( v5 )
    v6 = *(_DWORD *)(v5 + 24);
  else
    v6 = 0;
  if ( v6 )
  {
    result = a2;
    do
    {
      if ( v6 != result )
      {
        sub_10030CF0((void *)(v6 + 64), 0, 48);
        sub_100354DF(v4, v7, v6, v6 + 64);
        *(double *)(v6 + 96) = (double)(unsigned int)sub_100336B7(v6);
        *(_DWORD *)(*(_DWORD *)(v4 + 84) + 4 * v7) = v6 + 64;
        result = a2;
        ++v7;
      }
      if ( v6 == *(_DWORD *)(v4 + 100) )
        v6 = 0;
      else
        v6 = *(_DWORD *)(v6 + 24);
    }
    while ( v6 );
  }
  return result;
}

//----- (1003696D) --------------------------------------------------------
int __thiscall sub_1003696D(int this, int a2)
{
  unsigned int v2; // eax@1
  int v3; // ecx@1
  char v4; // bl@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // edx@2
  unsigned int v8; // eax@4
  int v9; // esi@5
  int v10; // ecx@6
  unsigned int v12; // [sp+Ch] [bp-8h]@4
  unsigned int v13; // [sp+10h] [bp-4h]@1

  v5 = this;
  v4 = 0;
  v6 = this + 44;
  sub_100244EB((LPCRITICAL_SECTION)(this + 44));
  sub_10035FF8(v5 + 96, a2);
  v3 = a2;
  v2 = 0;
  v13 = 0;
  if ( *(_DWORD *)(v5 + 24) > 0u )
  {
    v7 = *(_DWORD *)(a2 + 16) + 4;
    do
    {
      if ( *(_DWORD *)(v7 + 24) > 0u )
      {
        v8 = 0;
        v12 = 0;
        if ( *(_DWORD *)v7 > 0u )
        {
          v9 = 0;
          do
          {
            v10 = *(_DWORD *)(v7 + 44);
            if ( *(_DWORD *)(v9 + v10) == 4 )
            {
              --**(_DWORD **)(v9 + v10 + 20);
              v8 = v12;
            }
            ++v8;
            v9 += 52;
            v12 = v8;
          }
          while ( v8 < *(_DWORD *)v7 );
        }
        v2 = v13;
      }
      ++v2;
      v7 += 52;
      v13 = v2;
    }
    while ( v2 < *(_DWORD *)(v5 + 24) );
    v3 = a2;
    v6 = v5 + 44;
  }
  if ( *(_DWORD *)(v3 + 132) == *(_DWORD *)(v3 + 128) )
    --*(_DWORD *)(v5 + 16);
  --*(_DWORD *)(v5 + 8);
  if ( *(_DWORD *)(v5 + 8) == 1 )
  {
    *(_DWORD *)(v5 + 40) = 0;
    v4 = 1;
  }
  sub_10024670((LPCRITICAL_SECTION)v6);
  if ( v4 )
    SetEvent(*(HANDLE *)(v5 + 80));
  return (*(int (**)(void))(*(_DWORD *)a2 + 32))();
}

//----- (10036A26) --------------------------------------------------------
int __userpurge sub_10036A26<eax>(int a1<ebp>, int a2)
{
  int v2; // ebx@1
  struct _RTL_CRITICAL_SECTION *v3; // esi@1
  int v4; // ecx@1
  int v5; // ecx@1

  sub_1002D0B8();
  v2 = v4;
  v3 = (struct _RTL_CRITICAL_SECTION *)(v4 + 44);
  *(_DWORD *)(a1 - 16) = v4 + 44;
  sub_100244EB((LPCRITICAL_SECTION)(v4 + 44));
  v5 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  if ( !sub_10043E66(v5, a1) )
    sub_10035389(v2, v2, *(_DWORD *)(a1 + 8), 0, 1);
  *(_DWORD *)(a1 - 4) = -1;
  sub_10024670(v3);
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10036A77) --------------------------------------------------------
int __thiscall sub_10036A77(int this, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@2

  if ( *(_BYTE *)(a3 + 48) )
  {
    result = a6;
    *(_BYTE *)(a3 + 48) = 0;
    --*(_DWORD *)(result + 20);
    --*(_DWORD *)(a2 + 40);
    if ( *(_BYTE *)(a3 + 49) )
    {
      --*(_DWORD *)(a6 + 24);
      --*(_DWORD *)(a2 + 44);
    }
    if ( *(_DWORD *)a5 == 6 )
    {
      result = a4;
      *(_DWORD *)a5 = 0;
      --*(_DWORD *)(result + 28);
      --*(_DWORD *)(this + 32);
    }
    --*(_DWORD *)(a5 + 28);
  }
  else
  {
    *(_BYTE *)(a3 + 48) = 1;
    ++*(_DWORD *)(a6 + 20);
    ++*(_DWORD *)(a2 + 40);
    if ( *(_BYTE *)(a3 + 49) )
    {
      ++*(_DWORD *)(a6 + 24);
      ++*(_DWORD *)(a2 + 44);
    }
    result = a5;
    ++*(_DWORD *)(result + 28);
  }
  return result;
}

//----- (10036AE4) --------------------------------------------------------
int __usercall sub_10036AE4<eax>(int a1<ebp>, int a2<esi>)
{
  int v2; // eax@2

  sub_1002D0B8();
  if ( !dword_10069C70 )
  {
    *(_DWORD *)(a1 - 16) = &dword_10069CB4;
    sub_10028AD5(&dword_10069CB4);
    v2 = dword_10069C70;
    *(_DWORD *)(a1 - 4) = 0;
    if ( !v2 )
      sub_1003640A(a2);
    dword_10069CB4 = 0;
  }
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10069C70: using guessed type int dword_10069C70;
// 10069CB4: using guessed type int dword_10069CB4;

//----- (10036B2D) --------------------------------------------------------
void __usercall sub_10036B2D(int a1<ebx>, int a2<edi>, int a3<esi>, int a4, int a5, int a6)
{
  BOOL v6; // edi@3
  int v11; // ecx@3
  int v12; // edx@3
  int v13; // ST08_4@3
  char v14; // [sp-Ch] [bp-338h]@3
  char v15; // [sp+0h] [bp-32Ch]@3
  struct _EXCEPTION_POINTERS ExceptionInfo; // [sp+4h] [bp-328h]@3
  int v17; // [sp+Ch] [bp-320h]@3
  int v18; // [sp+10h] [bp-31Ch]@3
  void *v19; // [sp+18h] [bp-314h]@3
  int v20; // [sp+5Ch] [bp-2D0h]@3
  __int16 v21; // [sp+E8h] [bp-244h]@3
  __int16 v22; // [sp+ECh] [bp-240h]@3
  __int16 v23; // [sp+F0h] [bp-23Ch]@3
  __int16 v24; // [sp+F4h] [bp-238h]@3
  int v25; // [sp+F8h] [bp-234h]@3
  int v26; // [sp+FCh] [bp-230h]@3
  int v27; // [sp+100h] [bp-22Ch]@3
  int v28; // [sp+104h] [bp-228h]@3
  int v29; // [sp+108h] [bp-224h]@3
  int *v30; // [sp+10Ch] [bp-220h]@3
  int v31; // [sp+110h] [bp-21Ch]@3
  void *v32; // [sp+114h] [bp-218h]@3
  __int16 v33; // [sp+118h] [bp-214h]@3
  int v34; // [sp+11Ch] [bp-210h]@3
  void **v35; // [sp+120h] [bp-20Ch]@3
  __int16 v36; // [sp+124h] [bp-208h]@3
  unsigned int v37; // [sp+328h] [bp-4h]@1
  int v38; // [sp+32Ch] [bp+0h]@1
  int v39; // [sp+330h] [bp+4h]@3

  v37 = (unsigned int)&v38 ^ __security_cookie;
  if ( a4 != -1 )
    sub_10038C43();
  sub_10030CF0(&v18, 0, 76);
  ExceptionInfo.ExceptionRecord = (PEXCEPTION_RECORD)&v17;
  _CF = (unsigned int)&v14 >= 0xFFFFFFF4;
  _OF = __SETO__(&v14, -12);
  _ZF = &v15 == 0;
  _SF = (signed int)&v15 < 0;
  ExceptionInfo.ContextRecord = (PCONTEXT)&v20;
  v30 = &v20;
  v29 = v11;
  v28 = v12;
  v27 = a1;
  v26 = a3;
  v25 = a2;
  v36 = __SS__;
  v33 = __CS__;
  v24 = __DS__;
  v23 = __ES__;
  v22 = __FS__;
  v21 = __GS__;
  __asm { pushf }
  v34 = v13;
  v32 = (void *)v39;
  v35 = (void **)&v39;
  v20 = 65537;
  v31 = v38;
  v17 = a5;
  v18 = a6;
  v19 = (void *)v39;
  v6 = IsDebuggerPresent();
  if ( !sub_10031369(&ExceptionInfo) )
  {
    if ( !v6 )
    {
      if ( a4 != -1 )
        sub_10038C43();
    }
  }
}
// 10067210: using guessed type int __security_cookie;

//----- (10036C50) --------------------------------------------------------
void *__cdecl sub_10036C50(void *a1)
{
  void *result; // eax@1

  result = a1;
  dword_10069C80 = a1;
  return result;
}

//----- (10036C5D) --------------------------------------------------------
int __usercall sub_10036C5D<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6, int a7)
{
  int (*v7)(void); // eax@1

  v7 = (int (*)(void))DecodePointer(dword_10069C80);
  if ( !v7 )
  {
    sub_10036C98(a1, a2);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10036C88);
  }
  return v7();
}

//----- (10036C88) --------------------------------------------------------
int __usercall sub_10036C88<eax>(int a1<ebx>, int a2<edi>)
{
  return sub_10036C5D(a1, a2, 0, 0, 0, 0, 0);
}

//----- (10036C98) --------------------------------------------------------
int __usercall sub_10036C98<eax>(int a1<ebx>, int a2<edi>)
{
  if ( IsProcessorFeaturePresent(0x17u) )
    __asm { int     29h             ; DOS 2+ internal - FAST PUTCHAR }
  sub_10036B2D(a1, a2, -1073740777, 2, -1073740777, 1);
  return sub_10031354(0xC0000417u);
}

//----- (10036CC3) --------------------------------------------------------
int __cdecl sub_10036CC3(int a1)
{
  int ebp0; // ebp@0

  *(_DWORD *)(a1 + 116) = 1;
  sub_10026DF4(a1, -999);
  return sub_10026E93(ebp0, 0);
}

//----- (10036CEA) --------------------------------------------------------
int __cdecl sub_10036CEA(int a1)
{
  return (**(int (__stdcall ***)(_DWORD))a1)(1);
}

//----- (10036CF8) --------------------------------------------------------
void __thiscall sub_10036CF8(int this, int a2)
{
  int v2; // edx@5
  int v3; // eax@8
  int v4; // edx@8
  void *v5; // ecx@8
  int v6; // eax@11
  int v7; // ebx@14
  int v8; // edi@14
  void *v9; // edx@14
  _DWORD *v10; // [sp+0h] [bp+0h]@4
  void *v11; // [sp+8h] [bp+8h]@14

  if ( *(int (**)())(this + 12) == sub_10036DB8 )
  {
    v10 = &v10;
    if ( a2 )
      v2 = a2 - 4;
    else
      v2 = 0;
    if ( !*(_DWORD *)(v2 + 52) )
    {
      v3 = *(_DWORD *)(this + 8);
      v4 = v2 + 4;
      v5 = *(void **)(v3 + 12);
      *(_DWORD *)(v4 + 48) = v3;
      *(_DWORD *)(v4 + 52) = v3;
      sub_10026D6E(v5, v4, 0);
    }
  }
  else
  {
    v10 = &v10;
    if ( a2 )
      v6 = a2 - 4;
    else
      v6 = 0;
    if ( !*(_DWORD *)(v6 + 52) )
    {
      v8 = *(_DWORD *)(this + 8);
      v7 = v6 + 4;
      v9 = *(void **)(v8 + 12);
      *(_DWORD *)(v6 + 52) = v8;
      *(_DWORD *)(v6 + 56) = v8;
      v11 = v9;
      if ( *(_BYTE *)(this + 17) )
      {
        *(_BYTE *)(v6 + 81) = 0;
        sub_10026DCD(v8 + 28, v6 + 96);
      }
      else
      {
        sub_10024558((void *)(v8 + 32));
        ++*(_DWORD *)(v8 + 48);
        sub_10024692((void *)(v8 + 32));
        sub_10026D6E(v11, v7, 1);
      }
    }
  }
}
// 10036DB8: using guessed type int sub_10036DB8();

//----- (10036DAB) --------------------------------------------------------
char __thiscall sub_10036DAB(int this, char a2)
{
  char result; // al@1

  result = a2;
  *(_BYTE *)(this + 17) = a2;
  return result;
}

//----- (10036DB8) --------------------------------------------------------
#error "10036EF4: call analysis failed (funcsize=85)"

//----- (10037024) --------------------------------------------------------
void (__usercall *__usercall sub_10037024<eax>(int a1<ebp>, int a2<edi>))(int<ebp>)
{
  int v2; // eax@1

  v2 = *(_DWORD *)(a1 - 172);
  if ( *(_DWORD *)(v2 + 116) > 0 )
  {
    if ( !*(_DWORD *)(v2 + 120) )
      sub_10025F04(*(_DWORD *)(a1 - 168), 0, a2);
  }
  return sub_10037047;
}

//----- (10037047) --------------------------------------------------------
void __usercall sub_10037047(int a1<ebp>)
{
  int v1; // edi@1

  v1 = *(_DWORD *)(a1 - 168);
  *(_DWORD *)(a1 - 4) = 1;
  sub_10026494(0, a1, v1, a1 - 164, 0);
  *(_BYTE *)(a1 - 4) = 0;
  sub_100258E1(a1);
  *(_DWORD *)(a1 - 4) = -1;
  JUMPOUT(*(unsigned int *)loc_100370CE);
}
// 100370CE: using guessed type int loc_100370CE();

//----- (1003707D) --------------------------------------------------------
void (__usercall *__usercall sub_1003707D<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>))(int<ebp>)
{
  sub_1002630D(*(_DWORD *)(a2 - 168), a1, a2);
  sub_10025F04(*(_DWORD *)(a2 - 168), a1, a3);
  return sub_10037047;
}

//----- (10037099) --------------------------------------------------------
int (__usercall *__usercall sub_10037099<eax>(int a1<ebp>, int a2<edi>))<eax>(int<ebp>)
{
  int v2; // eax@1

  v2 = *(_DWORD *)(a1 - 172);
  if ( *(_DWORD *)(v2 + 116) > 0 )
  {
    if ( !*(_DWORD *)(v2 + 120) )
      sub_10025F04(*(_DWORD *)(a1 - 168), 0, a2);
  }
  return sub_100370BC;
}

//----- (100370BC) --------------------------------------------------------
int __usercall sub_100370BC<eax>(int a1<ebp>)
{
  int v1; // edi@1
  int v2; // esi@1
  int v3; // eax@2
  void *v4; // ecx@5
  void *v5; // esi@7
  int v7; // esi@9
  int v8; // eax@9

  *(_DWORD *)(a1 - 4) = -1;
  v1 = *(_DWORD *)(a1 - 168);
  v2 = *(_DWORD *)(a1 - 172);
  *(_DWORD *)(a1 - 172) = v2 + 4;
  sub_10027839(v2 + 4, 0);
  if ( *(_BYTE *)(*(_DWORD *)(a1 - 176) + 17) )
  {
    sub_100277EE(*(_DWORD *)(a1 - 184), v2 + 96);
  }
  else
  {
    v3 = *(_DWORD *)(a1 - 184);
    *(_DWORD *)(a1 - 168) = v3 + 4;
    sub_10024558((void *)(v3 + 4));
    if ( *(_BYTE *)(v2 + 81) )
      sub_10027815(*(void **)(a1 - 196), *(_DWORD *)(a1 - 172));
    else
      sub_100276CA(*(void **)(a1 - 184), v2 + 96);
    v4 = *(void **)(a1 - 168);
    --*(_DWORD *)(v1 + 48);
    sub_10024692(v4);
  }
  v5 = *(void **)(a1 - 192);
  if ( v5 )
  {
    sub_10027CF1(a1, *(_DWORD *)(a1 - 192));
    sub_10001320(v5);
  }
  v7 = *(_DWORD *)(a1 - 172);
  *(_DWORD *)(v7 + 104) = -1;
  *(_DWORD *)(v7 + 108) = -1;
  *(_DWORD *)(v7 + 112) = 0;
  *(_DWORD *)(v7 + 116) = 0;
  sub_10026FAD((void *)v7);
  v8 = *(_DWORD *)(a1 - 176);
  *(_DWORD *)(v7 + 48) = 0;
  *(_DWORD *)(v7 + 52) = 0;
  *(_DWORD *)(v8 + 8) = 0;
  sub_1002627F((void *)v1, v8);
  return sub_1002D0A9();
}
// 1002D0A9: using guessed type int sub_1002D0A9(void);

//----- (100371BF) --------------------------------------------------------
int __thiscall sub_100371BF(int this, int a2)
{
  int result; // eax@1
  int v3; // edx@1
  int v4; // ecx@1

  _ESI = this + 24;
  v3 = *(_DWORD *)(this + 24);
  v4 = v3;
  for ( result = v3; ; v4 = result )
  {
    _ECX = a2 | v4 & 0xFFFFFFFC;
    __asm { lock cmpxchg [esi], ecx }
    if ( result == v3 )
      break;
    v3 = result;
  }
  return result;
}

//----- (100371E5) --------------------------------------------------------
signed int __thiscall sub_100371E5(int this, int a2)
{
  signed int result; // eax@1
  int v3; // ecx@1

  result = *(_DWORD *)(this + 8);
  v3 = 0;
  if ( result & 1 )
  {
    v3 = result & 0xFFFFFFFE;
    if ( result & 0xFFFFFFFE )
      result = *(_DWORD *)((result & 0xFFFFFFFE) + 0x10);
    else
      result = 2;
  }
  if ( a2 )
    *(_DWORD *)a2 = v3;
  return result;
}

//----- (1003720D) --------------------------------------------------------
char __thiscall sub_1003720D(int this)
{
  int v1; // edx@1
  char result; // al@4

  _ESI = this + 24;
  v1 = *(_DWORD *)(this + 24);
  if ( v1 & 3 )
  {
LABEL_4:
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      _ECX = v1 | 1;
      __asm { lock cmpxchg [esi], ecx }
      if ( v1 == v1 )
        break;
      if ( v1 & 3 )
        goto LABEL_4;
    }
    result = 1;
  }
  return result;
}

//----- (10037235) --------------------------------------------------------
int __thiscall sub_10037235(int this)
{
  int v1; // edx@1
  int result; // eax@2

  _ESI = this + 24;
  v1 = *(_DWORD *)(this + 24);
  if ( !(v1 & 0xFFFFFFFC) )
  {
    do
    {
      _ECX = v1 & 3 | 0xC;
      result = v1;
      __asm { lock cmpxchg [esi], ecx }
    }
    while ( v1 != v1 && !(v1 & 0xFFFFFFFC) );
  }
  return result;
}

//----- (10037260) --------------------------------------------------------
int __usercall sub_10037260<eax>(int a1<ebx>, int a2<ebp>)
{
  int v2; // edx@1
  int v4; // ecx@1
  int v6; // eax@6
  int v7; // esi@6
  int i; // eax@8
  int v9; // edx@8
  int v10; // ecx@8

  sub_1002D0B8();
  _EDI = v4 + 24;
  v2 = *(_DWORD *)(v4 + 24);
  while ( !(v2 & 0xFFFFFFFC) || (v2 & 0xFFFFFFFC) == 12 )
  {
    _ECX = v2 & 3 | 8;
    __asm { lock cmpxchg [edi], ecx }
    if ( v2 == v2 )
    {
      v6 = sub_10027EB3(v2, _ECX, a1, _EDI, 8);
      *(_DWORD *)(a2 - 16) = v6;
      v7 = 0;
      *(_DWORD *)(a2 - 4) = 0;
      if ( v6 )
        v7 = sub_10001090(v6);
      v9 = *(_DWORD *)_EDI;
      v10 = *(_DWORD *)_EDI;
      for ( i = *(_DWORD *)_EDI; ; LOBYTE(v10) = i )
      {
        _ECX = v7 | v10 & 3;
        __asm { lock cmpxchg [edi], ecx }
        if ( i == v9 )
          break;
        v9 = i;
      }
      return sub_1002D086(4);
    }
  }
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (100372CF) --------------------------------------------------------
int __usercall sub_100372CF<eax>(int a1<ebx>, int a2<ebp>)
{
  int v2; // ecx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // ecx@3
  const void *v6; // ST04_4@4
  int v8; // [sp-Ch] [bp-Ch]@4
  int v9; // [sp-8h] [bp-8h]@4
  signed int v10; // [sp-4h] [bp-4h]@1

  v10 = 12;
  sub_1002D0B8();
  v3 = v2;
  v4 = *(_DWORD *)(v2 + 24) & 0xFFFFFFFC;
  if ( *(_DWORD *)(v2 + 24) & 0xFFFFFFFC )
  {
    if ( v4 != 12 )
    {
      sub_10023441(a2 - 24, *(_DWORD *)(v2 + 24) & 0xFFFFFFFC);
      *(_DWORD *)(a2 - 4) = 0;
      sub_100234E2(v4);
      sub_1002404A((LPVOID)v4);
      *(_DWORD *)(v3 + 24) = 0;
      if ( !sub_1002DE0F(a1, v3) )
      {
        v9 = v5;
        v8 = v5;
        sub_10023441((int)&v8, a2 - 24);
        sub_10020060(v6, v3, v8);
      }
      *(_DWORD *)(a2 - 4) = -1;
      sub_100234E2(a2 - 24);
    }
  }
  return sub_1002D086(v10);
}
// 10023441: using guessed type int __cdecl sub_10023441(int, int);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1003733F) --------------------------------------------------------
char __thiscall sub_1003733F(int this)
{
  int v1; // edi@1
  signed int v2; // esi@1
  int v3; // esi@1
  char v4; // al@3

  v3 = this;
  v1 = sub_10027C8C(this);
  v2 = sub_100371E5(v3, 0);
  while ( 1 )
  {
    if ( !v1 )
      return 0;
    if ( v2 )
      break;
    v4 = (*(_DWORD *)(v1 + 4) >> 28) & 1;
    if ( v4 && *(_BYTE *)(v1 + 24) & 3 || !v4 && sub_10026235(v1) )
      return 1;
    v2 = sub_100371E5(v1, 0);
    v1 = sub_10027C8C(v1);
  }
  if ( v2 == 2 )
    return 0;
  return *(_DWORD *)(v2 + 8) != 0;
}

//----- (100373AC) --------------------------------------------------------
int __fastcall sub_100373AC(int a1, int a2, int a3)
{
  int v3; // eax@1
  signed int v4; // edi@1
  int v5; // esi@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // ecx@2

  v5 = a1;
  *(_DWORD *)(a1 + 16) = a3;
  v4 = 63;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 8) = 63;
  *(_DWORD *)(a1 + 28) = sub_10021CF0(a2, a1, 0, 63, 256);
  v3 = sub_10021CF0(v6, v7, 0, 63, 512);
  if ( v3 )
  {
    v8 = v3;
    do
    {
      --v4;
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      v8 += 8;
    }
    while ( v4 >= 0 );
  }
  else
  {
    v3 = 0;
  }
  *(_DWORD *)(v5 + 32) = v3;
  return v5;
}

//----- (1003740B) --------------------------------------------------------
int __usercall sub_1003740B<eax>(int a1<ebp>)
{
  int v2; // ecx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // edx@1
  int v6; // edx@1

  sub_1002D0B8();
  v3 = v2;
  *(_DWORD *)(a1 - 16) = v2;
  v4 = v2 + 112;
  sub_1003A82C(v2, v5, v2 + 112);
  *(_DWORD *)(v3 + 56) = 0;
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)(v3 + 72) = 0;
  sub_100373AC(v3 + 76, v6, v4);
  *(_DWORD *)v4 = 0;
  *(_BYTE *)(a1 - 4) = 1;
  *(_DWORD *)(v3 + 44) = 0;
  *(_DWORD *)(v3 + 52) = v3;
  *(_DWORD *)(v3 + 64) = sub_1002A4A9();
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10037457) --------------------------------------------------------
char __thiscall sub_10037457(void *this)
{
  LPVOID v1; // eax@1
  void *v2; // edi@1
  int v3; // esi@2
  char v4; // bl@5

  v2 = this;
  v1 = sub_10029DCE();
  if ( v1 )
    v3 = (int)((char *)v1 - 4);
  else
    v3 = 0;
  if ( !sub_1002AD6F(**(_DWORD **)v2 + 60, *(_DWORD *)v2 + 4)
    || (v4 = 1,
        (1 << (*(_DWORD *)(*(_DWORD *)(v3 + 160) + 132) & 0x1F)) & *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v2 + 8)
                                                                             + 4
                                                                             * (*(_DWORD *)(*(_DWORD *)(v3 + 160) + 132) >> 5))) )
    v4 = 0;
  return v4;
}

//----- (100374AD) --------------------------------------------------------
bool __thiscall sub_100374AD(int this)
{
  return *(_DWORD *)(this + 4) <= *(_DWORD *)this && *(_DWORD *)(this + 80) <= *(_DWORD *)(this + 76);
}

//----- (100374C3) --------------------------------------------------------
int __thiscall sub_100374C3(int this, int a2)
{
  *(_DWORD *)(this + 60) = a2;
  return sub_1002ADAD(this + 28, sub_10037545, this, *(_DWORD *)(*(_DWORD *)(a2 + 256) + 4));
}

//----- (100374E7) --------------------------------------------------------
int __thiscall sub_100374E7(void *this)
{
  void *v2; // edi@1

  v2 = this;
  sub_1002C615((char *)this + 112);
  *((_DWORD *)v2 + 16) = sub_1002A4A9();
  *(_DWORD *)v2 = 0;
  *((_DWORD *)v2 + 1) = 0;
  *((_DWORD *)v2 + 19) = 0;
  *((_DWORD *)v2 + 20) = 0;
  *((_WORD *)v2 + 48) = 0;
  *((_DWORD *)v2 + 22) = 0;
  *((_DWORD *)v2 + 14) = 0;
  *((_DWORD *)v2 + 18) = 0;
  return sub_1002C625((char *)v2 + 112);
}

//----- (10037521) --------------------------------------------------------
int __thiscall sub_10037521(int this, int a2)
{
  *(_DWORD *)(this + 60) = a2;
  return sub_1002ADAD(this + 28, sub_10037556, this, *(_DWORD *)(*(_DWORD *)(a2 + 256) + 4));
}

//----- (10037545) --------------------------------------------------------
int __cdecl sub_10037545(int a1)
{
  return sub_100386DB(*(void **)(a1 + 60), a1);
}

//----- (10037556) --------------------------------------------------------
int __cdecl sub_10037556(int a1)
{
  return sub_10038872(*(_DWORD *)(a1 + 60), a1);
}

//----- (10037567) --------------------------------------------------------
int __userpurge sub_10037567<eax>(int a1<ebp>, int a2)
{
  int v3; // ecx@1
  int v4; // edi@1
  void *v5; // esi@1
  int v6; // ST00_4@1

  sub_1002D0B8();
  v4 = v3;
  v5 = (void *)(v3 + 112);
  *(_DWORD *)(a1 - 16) = v3 + 112;
  sub_1002C615((void *)(v3 + 112));
  v6 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  sub_10037746(v4, v6);
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002C625(v5);
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10037646) --------------------------------------------------------
int __cdecl sub_10037646(int (__cdecl *a1)(_DWORD, _DWORD), int a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int v3; // ecx@1
  int v4; // edx@2
  int v5; // eax@3
  char v6; // al@5
  int v8; // eax@1
  int v9; // ebx@1
  int v10; // edi@1
  int v11; // esi@1
  void *v12; // [sp+0h] [bp-1Ch]@1
  int v13; // [sp+8h] [bp-14h]@3
  int v14; // [sp+Ch] [bp-10h]@2

  sub_1002D0B8();
  v9 = v3;
  v12 = *(void **)(v3 + 16);
  sub_1002C615(v12);
  v8 = v9 + 4;
  v10 = *(_DWORD *)(v9 + 4);
  v11 = *(_DWORD *)(v9 + 4) - 1;
  if ( v11 >= *(_DWORD *)v9 )
  {
    v14 = *(_DWORD *)(v9 + 4);
    v4 = *(_DWORD *)(v9 + 4);
    do
    {
      v5 = *(_DWORD *)(*(_DWORD *)(v9 + 28) + 4 * (*(_DWORD *)(v9 + 8) & v11));
      v13 = v5;
      if ( v5 )
      {
        if ( (unsigned __int8)a1(v5, a2) )
        {
          v6 = a3(v13, a2);
          v4 = v14;
          if ( v6 )
          {
            if ( v14 == v10 )
              --v10;
            else
              *(_DWORD *)(*(_DWORD *)(v9 + 28) + 4 * (*(_DWORD *)(v9 + 8) & v11)) = 0;
          }
        }
        else
        {
          v4 = v14;
        }
      }
      --v11;
      --v4;
      v14 = v4;
    }
    while ( v11 >= *(_DWORD *)v9 );
    v8 = v9 + 4;
  }
  *(_DWORD *)v8 = v10;
  sub_1002C625(v12);
  return sub_1002D086(16);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10037652) --------------------------------------------------------
int __thiscall sub_10037652(int this, char a2, int a3)
{
  int v3; // esi@1
  int result; // eax@2

  v3 = this;
  if ( sub_1002C639((void *)(this + 112)) )
  {
    sub_10037746(v3, a2);
    result = sub_1002C625((void *)(v3 + 112));
  }
  else
  {
    *(_BYTE *)a3 = 0;
    result = 0;
  }
  return result;
}

//----- (100376B8) --------------------------------------------------------
int __thiscall sub_100376B8(void *this, char a2, int a3)
{
  void *v3; // esi@1
  int v4; // ecx@2
  int v5; // ebx@8
  int v6; // eax@8
  int v7; // edi@12

  v3 = this;
LABEL_11:
  v5 = 0;
  while ( 1 )
  {
    v7 = *(_DWORD *)v3++;
    if ( v7 >= *((_DWORD *)v3 + 1) )
    {
      *(_DWORD *)v3 = v7;
      return v5;
    }
    v4 = v7 & *((_DWORD *)v3 + 2);
    if ( *(_BYTE *)(*((_DWORD *)v3 + 7) + 4 * v4) & 1 )
    {
      if ( !a2 && sub_10037457((void *)(*((_DWORD *)v3 + 8) + 8 * v4)) )
        break;
    }
    if ( *((_BYTE *)v3 + 20) )
    {
      if ( *(_DWORD *)v3 >= *((_DWORD *)v3 + 6) )
        *((_BYTE *)v3 + 20) = 0;
    }
    v6 = *((_DWORD *)v3 + 7) + 4 * (v7 & *((_DWORD *)v3 + 2));
    v5 = *(_DWORD *)v6;
    *(_DWORD *)v6 = 0;
    if ( v5 )
    {
      if ( !(v5 & 1) || (v5 &= 0xFFFFFFFEu, sub_1003AA40(*((_DWORD *)v3 + 8) + 8 * (v7 & *((_DWORD *)v3 + 2)), 0)) )
        return v5;
      goto LABEL_11;
    }
  }
  *(_DWORD *)v3 = v7;
  return 0;
}

//----- (10037746) --------------------------------------------------------
int __thiscall sub_10037746(int this, char a2)
{
  int v2; // ebx@1
  int result; // eax@2
  int v4; // ecx@3
  int v5; // edi@3
  int v6; // esi@3
  LPVOID v7; // eax@8
  int v8; // eax@12
  void *v9; // ecx@13
  char v10; // [sp-Ch] [bp-10h]@15

  v2 = this;
  if ( sub_100374AD(this) )
    return 0;
  v4 = *(_DWORD *)(v2 + 72);
  v5 = 0;
  v6 = 0;
  if ( v4 && *(_DWORD *)(v4 + 112) > 0 && !(unsigned __int8)(*(int (**)(void))(*(_DWORD *)v4 + 16))() )
  {
    if ( !*(_BYTE *)(v2 + 96) || (v6 = sub_100376B8((void *)(v2 + 76), a2, 1), !v6) )
    {
      v7 = sub_10029DCE();
      if ( v7 )
        v5 = (int)((char *)v7 - 4);
      *(_BYTE *)(v5 + 179) |= 2u;
      return v6;
    }
    goto LABEL_16;
  }
  result = sub_1003B931((void *)v2, a2);
  if ( result )
    return result;
  v8 = sub_100376B8((void *)(v2 + 76), a2, 0);
  v6 = v8;
  if ( v8 )
  {
    v9 = *(void **)(v2 + 72);
    if ( v9 && *(void **)(*(_DWORD *)(v8 + 8) + 12) == v9 )
    {
      sub_10027668(v9);
      v10 = 0;
LABEL_17:
      sub_10036DAB(v6, v10);
      return v6;
    }
LABEL_16:
    v10 = 1;
    goto LABEL_17;
  }
  return v6;
}

//----- (100377ED) --------------------------------------------------------
int __thiscall sub_100377ED(void *ListHead, int a2, signed int a3, int a4)
{
  int v4; // edx@1
  int v5; // edi@1
  int v6; // edx@2
  int v7; // edx@2
  int v8; // eax@3
  int v10; // esi@3
  signed __int64 v12; // qax@3
  int v13; // edx@3
  signed int v14; // ecx@6
  signed __int64 v15; // qax@6
  int v16; // eax@6
  int v17; // ecx@6
  int v18; // eax@7

  v4 = a3;
  v5 = (int)ListHead;
  *((_DWORD *)ListHead + 9) = a2;
  *((_DWORD *)ListHead + 17) = a4;
  *((_DWORD *)ListHead + 4) = 0;
  *((_DWORD *)ListHead + 11) = 0;
  *((_DWORD *)ListHead + 12) = 0;
  *((_DWORD *)ListHead + 14) = 512;
  *((_DWORD *)ListHead + 15) = 1;
  *((_DWORD *)ListHead + 16) = 0;
  *((_DWORD *)ListHead + 18) = 0;
  if ( (v4 - 1) & v4 )
  {
    v6 = (((a3 >> 1) | a3) >> 2) | (a3 >> 1) | a3;
    v7 = (((v6 >> 4) | v6) >> 8) | (v6 >> 4) | v6;
    v4 = ((v7 >> 16) | v7) + 1;
  }
  *((_DWORD *)ListHead + 10) = v4;
  _ECX = 0;
  v12 = 4i64 * (unsigned int)v4;
  __asm { seto    cl }
  _QCX = (_DWORD)v12 | (unsigned int)-_ECX;
  v10 = sub_10021CF0(SHIDWORD(v12), _QCX, SHIDWORD(_QCX), v5, _QCX);
  sub_10030CF0((void *)v10, 0, 4 * *(_DWORD *)(v5 + 40));
  v8 = sub_10027EB3(v13, _QCX, SHIDWORD(_QCX), v5, 12);
  if ( v8 )
  {
    *(_DWORD *)(v8 + 8) = -1;
    *(_DWORD *)v8 = v10;
    *(_DWORD *)(v8 + 4) = 0;
  }
  else
  {
    v8 = 0;
  }
  *(_DWORD *)(v5 + 48) = v8;
  LODWORD(_QCX) = 0;
  v15 = 4i64 * *(_DWORD *)(v5 + 56);
  __asm { seto    cl }
  v16 = sub_10021CF0(SHIDWORD(v15), v15 | -(_DWORD)_QCX, SHIDWORD(_QCX), v5, v15 | -(_DWORD)_QCX);
  v17 = *(_DWORD *)(v5 + 48);
  *(_DWORD *)(v5 + 52) = v16;
  *(_DWORD *)v16 = v17;
  InitializeSListHead((PSLIST_HEADER)v5);
  InitializeSListHead((PSLIST_HEADER)(v5 + 8));
  v14 = *(_DWORD *)(v5 + 40) >> 1;
  if ( v14 )
  {
    v18 = *(_DWORD *)(v5 + 44);
    do
    {
      ++v18;
      v14 >>= 1;
    }
    while ( v14 );
    *(_DWORD *)(v5 + 44) = v18;
  }
  return v5;
}

//----- (100378DE) --------------------------------------------------------
int __userpurge sub_100378DE<eax>(int a1<ebp>, int a2, int a3, int a4, int a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // ebx@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // eax@2

  sub_1002D0B8();
  v9 = v6;
  *(_DWORD *)(a1 - 16) = v6;
  v7 = v6 + 4;
  v8 = 0;
  *(_DWORD *)v6 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(v6 + 4) = 0;
  *(_DWORD *)(v6 + 8) = 0;
  *(_DWORD *)(v6 + 12) = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(v6 + 16) = 0;
  *(_DWORD *)(v6 + 20) = 0;
  *(_DWORD *)(v6 + 24) = 0;
  *(_DWORD *)(v6 + 28) = 0;
  *(_DWORD *)(v6 + 32) = 0;
  *(_DWORD *)(a1 - 4) = 0;
  sub_100384A6(v6, 0, v6 + 4);
  if ( !*(_BYTE *)(a1 + 16) )
  {
    v10 = sub_10027EB3(v5, v6, v7, 0, 44);
    *(_DWORD *)(a1 + 16) = v10;
    *(_BYTE *)(a1 - 4) = 1;
    if ( v10 )
      v8 = sub_10037A6A(*(_DWORD *)v9, v7, *(_DWORD *)(a1 + 20), 0);
    *(_DWORD *)(v9 + 16) = v8;
    *(_DWORD *)(v9 + 20) = v8;
  }
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10037A6A: using guessed type _DWORD __stdcall sub_10037A6A(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10037958) --------------------------------------------------------
int __userpurge sub_10037958<eax>(int a1<ebp>, int a2, int a3)
{
  int v4; // ecx@1
  int v5; // esi@1
  int v6; // eax@1
  int v7; // ST00_4@1

  sub_1002D0B8();
  v5 = v4;
  *(_DWORD *)(a1 - 16) = v4;
  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)v4 = &off_10059630;
  *(_DWORD *)(v4 + 4) = v6;
  *(_DWORD *)(v4 + 8) = 0;
  *(_DWORD *)(v4 + 12) = 0;
  *(_DWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 20) = 0;
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)(v4 + 32) = 0;
  *(_DWORD *)(v4 + 40) = 0;
  *(_DWORD *)(v4 + 44) = 0;
  sub_100384CF(v4, v7);
  *(_DWORD *)(v5 + 28) = sub_1002A49A(*(void **)(v5 + 4));
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10059630: using guessed type int (__stdcall *off_10059630)(int, int);

//----- (100379B1) --------------------------------------------------------
int __userpurge sub_100379B1<eax>(int a1<ebp>, int a2, int a3, int a4)
{
  int v5; // ecx@1
  int v6; // edi@1
  int v7; // esi@1
  int v8; // eax@1
  int v9; // ST00_4@1
  void *v10; // ST0C_4@1
  int v11; // ST04_4@1
  int v12; // ST0C_4@1
  int v13; // ST08_4@1

  sub_1002D0B8();
  v6 = v5;
  *(_DWORD *)(a1 - 16) = v5;
  *(_DWORD *)v5 = &off_1005961C;
  *(_DWORD *)(v5 + 12) = 0;
  *(_DWORD *)(v5 + 20) = 0;
  *(_DWORD *)(v5 + 24) = 0;
  *(_DWORD *)(v5 + 28) = 0;
  *(_DWORD *)(v5 + 32) = 0;
  v7 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(v5 + 40) = 0;
  *(_DWORD *)(v5 + 44) = v5 + 40;
  *(_DWORD *)(v5 + 48) = 0;
  *(_DWORD *)(a1 - 4) = 0;
  v8 = sub_1002A1E4(a1, a1 - 24, v5 + 12);
  v9 = *(_DWORD *)(v7 + 4);
  *(_BYTE *)(a1 - 4) = 1;
  sub_100378DE(a1, v9, v8, 0, 64);
  v10 = *(void **)(a1 - 20);
  *(_BYTE *)(a1 - 4) = 3;
  sub_1002401B(v10);
  sub_100377ED((void *)(v6 + 88), *(_DWORD *)(v7 + 4), 256, 64);
  v11 = *(_DWORD *)(v7 + 4);
  *(_BYTE *)(a1 - 4) = 4;
  sub_100377ED((void *)(v6 + 168), v11, 256, 2147483647);
  v12 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(v6 + 264) = 0;
  v13 = *(_DWORD *)(a1 + 12);
  *(_BYTE *)(a1 - 4) = 5;
  sub_100384E2(v6, v7, v13, v12);
  return sub_1002D086(12);
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 1005961C: using guessed type int (__stdcall *off_1005961C)(char);

//----- (10037A6A) --------------------------------------------------------
#error "10037ACE: call analysis failed (funcsize=39)"

//----- (10037AD6) --------------------------------------------------------
int __thiscall sub_10037AD6(PSLIST_HEADER ListHead)
{
  int v1; // ebx@1
  PSLIST_HEADER v2; // edi@1
  int v3; // eax@1
  int v4; // eax@1
  int i; // esi@2
  int v6; // esi@4

  v2 = ListHead;
  v3 = (int)InterlockedFlushSList(ListHead);
  sub_10029CBA(v3);
  v4 = (int)InterlockedFlushSList(v2 + 1);
  sub_10029CBA(v4);
  sub_10029CBA(LODWORD(v2[2].Alignment));
  v1 = LODWORD(v2[6].Alignment);
  if ( v1 )
  {
    do
    {
      for ( i = 0; i < LODWORD(v2[5].Alignment); ++i )
        sub_1002404A(*(LPVOID *)(*(_DWORD *)v1 + 4 * i));
      v6 = *(_DWORD *)(v1 + 4);
      sub_1002401B(*(LPVOID *)v1);
      sub_1002404A((LPVOID)v1);
      v1 = v6;
    }
    while ( v6 );
  }
  return sub_1002401B(HIDWORD(v2[6].Alignment));
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10037B48) --------------------------------------------------------
int __thiscall sub_10037B48(PSLIST_HEADER ListHead)
{
  int v1; // ebx@1
  PSLIST_HEADER v2; // edi@1
  int v3; // eax@1
  int v4; // eax@1
  int i; // esi@2
  void *v6; // ecx@3
  int v7; // esi@6

  v2 = ListHead;
  v3 = (int)InterlockedFlushSList(ListHead);
  sub_1002707C(v3);
  v4 = (int)InterlockedFlushSList(v2 + 1);
  sub_1002707C(v4);
  sub_1002707C(LODWORD(v2[2].Alignment));
  v1 = LODWORD(v2[6].Alignment);
  if ( v1 )
  {
    do
    {
      for ( i = 0; i < LODWORD(v2[5].Alignment); ++i )
      {
        v6 = *(void **)(*(_DWORD *)v1 + 4 * i);
        if ( v6 )
          sub_10026BEC(v6, 1);
      }
      v7 = *(_DWORD *)(v1 + 4);
      sub_1002401B(*(LPVOID *)v1);
      sub_1002404A((LPVOID)v1);
      v1 = v7;
    }
    while ( v7 );
  }
  return sub_1002401B(HIDWORD(v2[6].Alignment));
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10037BBF) --------------------------------------------------------
int __usercall sub_10037BBF<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // edi@2
  int v6; // [sp-8h] [bp-8h]@3

  sub_1002D0B8();
  v2 = v3;
  *(_DWORD *)(a1 - 16) = v3;
  v1 = *(_DWORD *)(v3 + 20);
  *(_DWORD *)(a1 - 4) = 0;
  if ( v1 )
  {
    do
    {
      v4 = *(_DWORD *)(v1 + 24);
      if ( v1 == *(_DWORD *)(v2 + 16) )
        v6 = *(_DWORD *)(v2 + 28) - *(_DWORD *)(v1 + 16);
      else
        v6 = *(_DWORD *)(v2 + 12);
      sub_10038A3B(v1, v6);
      v1 = v4;
    }
    while ( v4 );
  }
  sub_1002401B(*(LPVOID *)(v2 + 8));
  return sub_1002D086(4);
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10037C09) --------------------------------------------------------
int __usercall sub_10037C09<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int v2; // esi@1
  int v3; // eax@1

  sub_1002D0B8();
  v2 = v1;
  *(_DWORD *)(a1 - 16) = v1;
  *(_DWORD *)v1 = &off_1005961C;
  v3 = *(_DWORD *)(v1 + 12);
  *(_DWORD *)(a1 - 4) = 0;
  if ( (v3 & 0xFFFFFFF) == 3 )
    sub_100380BF(*(_DWORD *)(*(_DWORD *)(v1 + 256) + 4), *(_DWORD *)(v1 + 36), v1);
  sub_10037AD6((PSLIST_HEADER)(v2 + 168));
  sub_10037B48((PSLIST_HEADER)(v2 + 88));
  sub_10037BBF(a1);
  sub_1002401B(*(LPVOID *)(v2 + 32));
  return sub_1002D086(4);
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 1005961C: using guessed type int (__stdcall *off_1005961C)(char);

//----- (10037C6D) --------------------------------------------------------
int __thiscall sub_10037C6D(int this, int a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002401B(*(LPVOID *)(this + 4));
  *(_DWORD *)v3 = *(_DWORD *)a2;
  *(_DWORD *)(v3 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  return v3;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (10037C97) --------------------------------------------------------
int __thiscall sub_10037C97(int this, signed int a2)
{
  signed int v2; // edx@1
  int v3; // esi@1
  int result; // eax@2
  int v5; // eax@3
  int v6; // ecx@3
  int v7; // eax@4
  int v8; // edx@4
  int v9; // edx@5

  v3 = this;
  v2 = a2 >> *(_DWORD *)(this + 44);
  if ( v2 < *(_DWORD *)(this + 60) )
  {
    v6 = *(_DWORD *)(this + 56);
    v5 = *(_DWORD *)(v3 + 52);
    if ( v2 < v6 )
    {
      v7 = *(_DWORD *)(v5 + 4 * v2);
    }
    else
    {
      v8 = v2 - v6;
      v7 = *(_DWORD *)(v5 + 4 * v6 - 4);
      if ( v8 >= 0 )
      {
        v9 = v8 + 1;
        do
        {
          v7 = *(_DWORD *)(v7 + 4);
          --v9;
        }
        while ( v9 );
      }
    }
    result = *(_DWORD *)(*(_DWORD *)v7 + 4 * (a2 & (*(_DWORD *)(v3 + 40) - 1)));
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10037CDD) --------------------------------------------------------
void *__thiscall sub_10037CDD(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_10055DF4;
  if ( a2 & 1 )
    sub_1002404A(this);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10055DF4: using guessed type int (*off_10055DF4[4])();

//----- (10037CFD) --------------------------------------------------------
void *__thiscall sub_10037CFD(void *this, char a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1

  v3 = this;
  sub_10037C09(ebp0);
  if ( a2 & 1 )
    sub_1002404A(v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10037D1C) --------------------------------------------------------
int __thiscall sub_10037D1C(int this, int a2)
{
  signed int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // edx@3
  int v12; // ecx@11
  signed __int64 v15; // qax@11
  signed int v16; // ST0C_4@11
  int v17; // edx@11
  int v18; // ecx@11
  int v19; // eax@12
  int v28; // edx@17
  char v30; // [sp+Ch] [bp-20h]@22
  int v31; // [sp+14h] [bp-18h]@21
  BOOL (__cdecl *v32)(); // [sp+18h] [bp-14h]@21
  int v33; // [sp+1Ch] [bp-10h]@5
  int v34; // [sp+20h] [bp-Ch]@2
  int v35; // [sp+24h] [bp-8h]@1
  char v36; // [sp+2Bh] [bp-1h]@1

  v5 = this;
  v3 = *(_DWORD *)(this + 48);
  v36 = 0;
  v4 = 0;
  v35 = v3;
  v2 = 4;
  do
  {
    _EBX = v3 + 8;
    v34 = v3 + 8;
    if ( *(_DWORD *)(v3 + 8) >= -1 )
    {
      _EBX = *(_DWORD *)v3;
      v7 = 0;
      if ( *(_DWORD *)(v5 + 40) <= 0 )
      {
LABEL_7:
        _EBX = v34;
      }
      else
      {
        while ( *(_DWORD *)_EBX )
        {
          ++v7;
          _EBX += v2;
          if ( v7 >= *(_DWORD *)(v5 + 40) )
            goto LABEL_7;
        }
        _ECX = a2;
        *(_DWORD *)a2 = v7 + v4;
        v33 = *(_DWORD *)(v5 + 64);
        __asm { lock cmpxchg [ebx], ecx }
        v4 += v7;
        v36 = 1;
        if ( v4 >= v33 )
        {
          _EAX = v5 + 64;
          _ECX = 1;
          __asm { lock xadd [eax], ecx }
        }
        _EBX = v34;
        _ECX = -1;
        __asm { lock cmpxchg [ebx], ecx }
      }
      v3 = v35;
    }
    if ( !v36 )
    {
      _ECX = -2;
      __asm { lock cmpxchg [ebx], ecx }
      v4 += *(_DWORD *)(v5 + 40);
      _EBX = v3 + 4;
      if ( !*(_DWORD *)(v3 + 4) )
      {
        _ECX = 1;
        __asm { lock cmpxchg [ebx], ecx }
        _ECX = 0;
        v15 = 4i64 * *(_DWORD *)(v5 + 40);
        __asm { seto    cl }
        v16 = 4 * *(_DWORD *)(v5 + 40);
        v33 = sub_10021CF0(SHIDWORD(v15), v15 | -_ECX, _EBX, v4, v15 | -_ECX);
        sub_10030CF0((void *)v33, 0, v16);
        v12 = sub_10027EB3(v17, v18, _EBX, v4, 12);
        if ( v12 )
        {
          v19 = v33;
          *(_DWORD *)(v12 + 4) = 0;
          *(_DWORD *)(v12 + 8) = -1;
          *(_DWORD *)v12 = v19;
        }
        else
        {
          v12 = 0;
        }
        v28 = *(_DWORD *)(v5 + 60);
        if ( v28 < *(_DWORD *)(v5 + 56) )
        {
          *(_DWORD *)(*(_DWORD *)(v5 + 52) + 4 * v28) = v12;
          ++*(_DWORD *)(v5 + 60);
        }
        *(_DWORD *)_EBX = v12;
        v3 = v35;
      }
      if ( *(_DWORD *)_EBX == 1 )
      {
        v31 = 0;
        v32 = sub_1002C66E;
        do
          sub_1001FF20((int)&v30);
        while ( *(_DWORD *)_EBX == 1 );
        v3 = v35;
      }
    }
    v3 = *(_DWORD *)(v3 + 4);
    v35 = v3;
    v2 = 4;
  }
  while ( !v36 );
  return v4;
}

//----- (10037E74) --------------------------------------------------------
int __thiscall sub_10037E74(int this, int a2)
{
  signed int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // edx@3
  int v12; // ecx@11
  signed __int64 v15; // qax@11
  signed int v16; // ST0C_4@11
  int v17; // edx@11
  int v18; // ecx@11
  int v19; // eax@12
  int v28; // edx@17
  char v30; // [sp+Ch] [bp-20h]@22
  int v31; // [sp+14h] [bp-18h]@21
  BOOL (__cdecl *v32)(); // [sp+18h] [bp-14h]@21
  int v33; // [sp+1Ch] [bp-10h]@5
  int v34; // [sp+20h] [bp-Ch]@2
  int v35; // [sp+24h] [bp-8h]@1
  char v36; // [sp+2Bh] [bp-1h]@1

  v5 = this;
  v3 = *(_DWORD *)(this + 48);
  v36 = 0;
  v4 = 0;
  v35 = v3;
  v2 = 4;
  do
  {
    _EBX = v3 + 8;
    v34 = v3 + 8;
    if ( *(_DWORD *)(v3 + 8) >= -1 )
    {
      _EBX = *(_DWORD *)v3;
      v7 = 0;
      if ( *(_DWORD *)(v5 + 40) <= 0 )
      {
LABEL_7:
        _EBX = v34;
      }
      else
      {
        while ( *(_DWORD *)_EBX )
        {
          ++v7;
          _EBX += v2;
          if ( v7 >= *(_DWORD *)(v5 + 40) )
            goto LABEL_7;
        }
        _ECX = a2;
        *(_DWORD *)(a2 + 248) = v7 + v4;
        v33 = *(_DWORD *)(v5 + 64);
        __asm { lock cmpxchg [ebx], ecx }
        v4 += v7;
        v36 = 1;
        if ( v4 >= v33 )
        {
          _EAX = v5 + 64;
          _ECX = 1;
          __asm { lock xadd [eax], ecx }
        }
        _EBX = v34;
        _ECX = -1;
        __asm { lock cmpxchg [ebx], ecx }
      }
      v3 = v35;
    }
    if ( !v36 )
    {
      _ECX = -2;
      __asm { lock cmpxchg [ebx], ecx }
      v4 += *(_DWORD *)(v5 + 40);
      _EBX = v3 + 4;
      if ( !*(_DWORD *)(v3 + 4) )
      {
        _ECX = 1;
        __asm { lock cmpxchg [ebx], ecx }
        _ECX = 0;
        v15 = 4i64 * *(_DWORD *)(v5 + 40);
        __asm { seto    cl }
        v16 = 4 * *(_DWORD *)(v5 + 40);
        v33 = sub_10021CF0(SHIDWORD(v15), v15 | -_ECX, _EBX, v4, v15 | -_ECX);
        sub_10030CF0((void *)v33, 0, v16);
        v12 = sub_10027EB3(v17, v18, _EBX, v4, 12);
        if ( v12 )
        {
          v19 = v33;
          *(_DWORD *)(v12 + 4) = 0;
          *(_DWORD *)(v12 + 8) = -1;
          *(_DWORD *)v12 = v19;
        }
        else
        {
          v12 = 0;
        }
        v28 = *(_DWORD *)(v5 + 60);
        if ( v28 < *(_DWORD *)(v5 + 56) )
        {
          *(_DWORD *)(*(_DWORD *)(v5 + 52) + 4 * v28) = v12;
          ++*(_DWORD *)(v5 + 60);
        }
        *(_DWORD *)_EBX = v12;
        v3 = v35;
      }
      if ( *(_DWORD *)_EBX == 1 )
      {
        v31 = 0;
        v32 = sub_1002C66E;
        do
          sub_1001FF20((int)&v30);
        while ( *(_DWORD *)_EBX == 1 );
        v3 = v35;
      }
    }
    v3 = *(_DWORD *)(v3 + 4);
    v35 = v3;
    v2 = 4;
  }
  while ( !v36 );
  return v4;
}

//----- (10037FD0) --------------------------------------------------------
char __thiscall sub_10037FD0(void *this, int a2, char a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int v7; // esi@1
  int v8; // ebx@4
  int v9; // eax@5
  int v10; // eax@6
  char v12; // [sp-14h] [bp-30h]@10
  char v13; // [sp-10h] [bp-2Ch]@5
  int v14; // [sp-Ch] [bp-28h]@5
  int v15; // [sp-8h] [bp-24h]@5
  int v16; // [sp-4h] [bp-20h]@5
  char v17; // [sp+Ch] [bp-10h]@10

  v7 = (int)this;
  v6 = (int)sub_10029DCE();
  if ( !v6 || sub_100349ED(v6) != v7 )
    *(_DWORD *)(a2 + 228) = 1;
  v8 = *(_DWORD *)(*(_DWORD *)(v7 + 256) + 4);
  if ( *(_DWORD *)(v8 + 432) <= 0
    || (sub_10027C4E((int)&v13, (int)&a3),
        LOBYTE(v9) = (*(int (__thiscall **)(int, int, _DWORD, int, int, int))(*(_DWORD *)v8 + 60))(
                       v8,
                       a2,
                       *(_DWORD *)&v13,
                       v14,
                       v15,
                       v16),
        !(_BYTE)v9) )
  {
    v10 = *(_DWORD *)v7;
    v16 = a2;
    (*(void (__thiscall **)(int, int))(v10 + 8))(v7, a2);
    v9 = v7 + 12;
    if ( *(_DWORD *)(v7 + 12) & 0xFFFFFFF )
    {
      LOBYTE(v9) = sub_10026B55((int)&a3, v7 + 12);
      if ( (_BYTE)v9 )
        LOBYTE(v9) = (*(int (__thiscall **)(int))(*(_DWORD *)v7 + 4))(v7);
    }
    if ( *(_DWORD *)(v8 + 428) > 0 )
    {
      sub_10027C4E((int)&v17, (int)&a3);
      v16 = 11;
      sub_10027C4E((int)&v12, (int)&v17);
      LOBYTE(v9) = sub_1002BBC4((void *)v8, v7, v12, *(int *)&v13, v14, v15, v16);
    }
  }
  *(_DWORD *)(a2 + 228) = 0;
  return v9;
}

//----- (100380B3) --------------------------------------------------------
bool __cdecl sub_100380B3(int a1)
{
  bool result; // eax@1

  result = sub_1002A7FD(*(_DWORD *)(a1 + 36));
  if ( !result )
  {
    sub_10029CBA(*(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    *(_DWORD *)(a1 + 72) = 0;
  }
  return result;
}

//----- (100380BF) --------------------------------------------------------
int __thiscall sub_100380BF(int this, int a2, int a3)
{
  int result; // eax@1

  result = a3;
  if ( *(_DWORD *)((a2 << 7) + *(_DWORD *)(this + 92)) == a3 )
  {
    _EDX = 0;
    _ECX = (a2 << 7) + *(_DWORD *)(this + 92);
    __asm { lock cmpxchg [ecx], edx }
  }
  return result;
}

//----- (100380E4) --------------------------------------------------------
int __thiscall sub_100380E4(void *this, int a2, int a3)
{
  int v3; // ecx@1
  int v4; // ebx@1
  int v5; // eax@3
  PSINGLE_LIST_ENTRY v6; // eax@5
  int v7; // esi@6
  int v8; // ecx@11
  int v10; // [sp+Ch] [bp-4h]@3

  v4 = (int)this;
  v3 = (int)((char *)this + 16);
  if ( *(_DWORD *)a2 & 0xFFFFFFF )
    v3 = v4 + 12;
  v10 = v3;
  v5 = a3 + 96;
  if ( *(_DWORD *)a2 & 0xFFFFFFF )
    v5 = a3 + 16;
  v6 = InterlockedPopEntrySList((PSLIST_HEADER)v5);
  if ( v6 && (v7 = (int)&v6[-71], v6 != (PSINGLE_LIST_ENTRY)284) )
    sub_100384E2((int)&v6[-71], v4, a3, a2);
  else
    v7 = (*(int (__thiscall **)(_DWORD, _DWORD, _DWORD))(*(_DWORD *)v4 + 32))(v4, a3, a2);
  *(_DWORD *)(v7 + 260) = *(_DWORD *)v10;
  *(_DWORD *)v10 = v7;
  if ( !*(_DWORD *)(a3 + 188) )
    sub_1003CE6F(a3);
  v8 = a3 + 96;
  if ( *(_DWORD *)a2 & 0xFFFFFFF )
    v8 = a3 + 16;
  sub_10037E74(v8, v7);
  return v7;
}

//----- (1003817C) --------------------------------------------------------
int __usercall sub_1003817C<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int v3; // esi@1
  int v5; // eax@2
  int v6; // eax@3

  sub_1002D0B8();
  v3 = v1;
  _EDI = v1 + 16;
  if ( !*(_DWORD *)(v1 + 16) )
  {
    _EDX = 1;
    __asm { lock cmpxchg [edi], edx }
    v5 = sub_10027EB3(1, v1, 0, _EDI, 44);
    *(_DWORD *)(a1 - 16) = v5;
    *(_DWORD *)(a1 - 4) = 0;
    if ( v5 )
      v6 = sub_10037A6A(*(_DWORD *)v3, v3 + 4, *(_DWORD *)(v3 + 12), 0);
    else
      v6 = 0;
    *(_DWORD *)(a1 - 4) = -1;
    *(_DWORD *)_EDI = v6;
    *(_DWORD *)(v3 + 20) = v6;
  }
  if ( !*(_DWORD *)(v3 + 20) )
  {
    *(_DWORD *)(a1 - 24) = 0;
    *(_DWORD *)(a1 - 20) = sub_1002C630;
    do
      sub_1001FF20(a1 - 32);
    while ( !*(_DWORD *)(v3 + 20) );
  }
  return sub_1002D086(20);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10037A6A: using guessed type _DWORD __stdcall sub_10037A6A(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (100381F2) --------------------------------------------------------
char __userpurge sub_100381F2<al>(int a1<ecx>, int i<edi>, int a3)
{
  int v4; // ebx@1
  unsigned int v5; // esi@2
  int v7; // eax@6
  int v8; // ecx@6
  int v9; // edx@7
  int v10; // eax@11
  int v13; // esi@16
  char v14; // al@16
  int v16; // [sp+Ch] [bp-18h]@16
  int v17; // [sp+10h] [bp-14h]@16
  int v18; // [sp+14h] [bp-10h]@1
  int v19; // [sp+18h] [bp-Ch]@6
  int v20; // [sp+1Ch] [bp-8h]@11
  int v21; // [sp+20h] [bp-4h]@6

  v4 = a1;
  v18 = a1;
  _EDX = a1 + 24;
LABEL_2:
  v5 = *(_DWORD *)_EDX;
  while ( v5 != *(_DWORD *)(v4 + 28) )
  {
    _ECX = v5 + 1;
    __asm { lock cmpxchg [edx], ecx }
    if ( v5 == v5 )
    {
      v8 = sub_10038564(v4, v4, i, v5, 0);
      v7 = v4 + 20;
      v21 = v8;
      v19 = v4 + 20;
      if ( v8 != *(_DWORD *)(v4 + 20) )
      {
        v9 = *(_DWORD *)v7;
        for ( i = *(_DWORD *)v7; ; i = v9 )
        {
          while ( !(*(_DWORD *)(v4 + 12) + *(_DWORD *)(i + 20)) )
            i = *(_DWORD *)(i + 24);
          if ( *(_DWORD *)(i + 16) <= *(_DWORD *)(v9 + 16) )
            break;
          _EBX = v19;
          _ECX = i;
          v10 = v9;
          __asm { lock cmpxchg [ebx], ecx }
          v4 = v18;
          v20 = v9;
          if ( v9 == v9 )
          {
            while ( v10 != i )
            {
              sub_10038A3B(v10, *(_DWORD *)(v4 + 12));
              v10 = *(_DWORD *)(v20 + 24);
              v20 = *(_DWORD *)(v20 + 24);
            }
            break;
          }
        }
        v8 = v21;
      }
      v13 = v5 - *(_DWORD *)(v8 + 16);
      v16 = v8;
      v17 = v13;
      v14 = sub_1003AA40((int)&v16, a3);
      _EDX = v4 + 24;
      if ( v14 )
        return 1;
      goto LABEL_2;
    }
  }
  return 0;
}

//----- (100382D7) --------------------------------------------------------
int __thiscall sub_100382D7(int this, int a2)
{
  int v2; // eax@1
  int v3; // ebx@1

  v3 = this;
  v2 = *(_DWORD *)(this + 256);
  if ( !(*(_BYTE *)(v2 + 48) & 4) )
  {
    _EAX = v2 + 20;
    _EDX = 1;
    __asm { lock xadd [eax], edx }
  }
  sub_100386BA((void *)(a2 + 76));
  *(_DWORD *)(a2 + 56) = 1;
  return sub_10037D1C(v3 + 168, a2 + 44);
}

//----- (1003831D) --------------------------------------------------------
int __thiscall sub_1003831D(int this, int a2)
{
  int v3; // ebx@1

  v3 = this;
  sub_1002C615((void *)(this + 8));
  *(_DWORD *)(a2 + 12) = 0;
  **(_DWORD **)(v3 + 4) = a2;
  *(_DWORD *)(v3 + 4) = a2 + 12;
  return sub_1002C625((void *)(v3 + 8));
}

//----- (1003834D) --------------------------------------------------------
int __thiscall sub_1003834D(void *this, int a2, int a3)
{
  int v3; // esi@1
  int v4; // esi@3
  char v6; // [sp+Ch] [bp-10h]@3

  v3 = (int)((char *)this + 16);
  if ( *(_DWORD *)a2 & 0xFFFFFFF )
    v3 = (int)((char *)this + 12);
  v4 = *(_DWORD *)v3;
  sub_1003B8CD(*(void **)(a3 + 4), (int)&v6);
  while ( v4 && (!sub_10026B55(v4 + 12, a2) || *(_DWORD *)(v4 + 8) != a3) )
    v4 = *(_DWORD *)(v4 + 260);
  return v4;
}

//----- (1003839F) --------------------------------------------------------
int __thiscall sub_1003839F(int this)
{
  signed int v1; // ebx@1
  int v2; // edi@1
  signed int v3; // esi@1
  int v4; // eax@2
  int result; // eax@5
  int v6; // esi@7
  int v7; // [sp+Ch] [bp-4h]@2

  v2 = this;
  v3 = 0;
  v1 = *(_DWORD *)(this + 232);
  if ( v1 <= 0 )
  {
LABEL_5:
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      v4 = sub_10037C97(v2 + 168, v3);
      v7 = v4;
      if ( v4 )
      {
        if ( sub_1003871A((void *)(v2 + 168), v4, v3, 0) )
          break;
      }
      ++v3;
      if ( v3 >= v1 )
        goto LABEL_5;
    }
    v6 = *(_DWORD *)(v7 + 8);
    *(_DWORD *)(v6 + 56) = 0;
    sub_1002AD41(*(void **)(v2 + 256));
    result = v6;
  }
  return result;
}

//----- (10038404) --------------------------------------------------------
int __thiscall sub_10038404(void *this, int a2, char a3)
{
  int v3; // eax@1
  int ebp0; // ebp@0
  int v5; // edi@1
  int v6; // esi@1

  v5 = (int)this;
  v3 = sub_1002A37E(ebp0, 1);
  v6 = v3;
  if ( v3 )
    sub_1003C55C(v3, v5, a2, a3);
  return v6;
}

//----- (10038437) --------------------------------------------------------
int __thiscall sub_10038437(void *this)
{
  void *v1; // edi@3
  void *v2; // esi@3
  int v3; // edi@3
  int v4; // ecx@1
  int result; // eax@2

  v4 = (int)((char *)this + 40);
  if ( *(_DWORD *)v4 )
  {
    v1 = (void *)v4;
    v2 = (void *)(v4 + 8);
    sub_1002C615((void *)(v4 + 8));
    v3 = sub_10029D17(v1);
    sub_1002C625(v2);
    result = v3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10038447) --------------------------------------------------------
int __userpurge sub_10038447<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // eax@1
  int v9; // edx@1
  int v10; // ecx@1

  sub_1002D0B8();
  v6 = v7;
  v8 = sub_10027EB3(v9, v7, a1, a3, 44);
  v10 = v8;
  *(_DWORD *)(a2 - 16) = v8;
  v5 = *(_DWORD *)(a2 + 8);
  v4 = 0;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v10 )
    v4 = sub_10037A6A(*(_DWORD *)v6, v6 + 4, *(_DWORD *)(v6 + 12), *(_DWORD *)(v6 + 12) + *(_DWORD *)(v5 + 16));
  *(_DWORD *)(v6 + 16) = v4;
  *(_DWORD *)(v5 + 24) = v4;
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10037A6A: using guessed type _DWORD __stdcall sub_10037A6A(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10038491) --------------------------------------------------------
bool __thiscall sub_10038491(int this)
{
  return *(_DWORD *)(this + 40) != 0;
}

//----- (1003849A) --------------------------------------------------------
bool __thiscall sub_1003849A(void *this)
{
  return sub_10038667(this) != 0;
}

//----- (100384A6) --------------------------------------------------------
int __userpurge sub_100384A6<eax>(int a1<ecx>, int a2<edi>, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  v4 = a1;
  result = sub_10029BCB(a1 + 4, a2, a3);
  if ( *(_DWORD *)(v4 + 20) )
    result = sub_10029BCB(*(_DWORD *)(v4 + 20) + 4, a2, a3);
  return result;
}

//----- (100384CF) --------------------------------------------------------
int __thiscall sub_100384CF(int this, int a2)
{
  *(_DWORD *)(this + 20) = 1;
  return sub_10027C4E(this + 32, a2);
}

//----- (100384E2) --------------------------------------------------------
int __thiscall sub_100384E2(int this, int a2, int a3, int a4)
{
  int ebp0; // ebp@0
  int v5; // esi@1
  int v6; // eax@1
  char v8; // [sp+Ch] [bp-8h]@1
  void *v9; // [sp+10h] [bp-4h]@1

  v5 = this;
  *(_DWORD *)(this + 256) = a2;
  *(_DWORD *)(this + 8) = a3;
  sub_10027C4E(this + 12, a4);
  *(_DWORD *)(v5 + 268) = 0;
  *(_DWORD *)(v5 + 280) = 1;
  v6 = sub_1002A1E4(ebp0, (int)&v8, a4);
  sub_10037C6D(v5 + 28, v6);
  sub_1002401B(v9);
  if ( (*(_DWORD *)a4 & 0xFFFFFFF) == 3 )
    *(_DWORD *)(v5 + 36) = sub_1002A659(*(_DWORD *)(a2 + 4), *(_DWORD *)(a4 + 8));
  return sub_100384A6(v5 + 52, a4, v5 + 28);
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (10038564) --------------------------------------------------------
int __userpurge sub_10038564<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned int a4, char a5)
{
  int ebp0; // ebp@0
  int v6; // esi@1
  int v7; // ecx@4
  int v8; // edx@6

  v6 = a1;
  if ( !*(_DWORD *)(a1 + 20) )
    sub_1003817C(ebp0);
  if ( a5 )
    v7 = *(_DWORD *)(v6 + 16);
  else
    v7 = *(_DWORD *)(v6 + 20);
  v8 = v7;
  do
  {
    if ( a4 < *(_DWORD *)(v6 + 12) + *(_DWORD *)(v7 + 16) )
      break;
    v7 = *(_DWORD *)(v7 + 24);
    if ( !v7 )
      v7 = sub_10038447(a2, ebp0, a3, v8);
    v8 = v7;
  }
  while ( v7 );
  return v7;
}

//----- (100385AE) --------------------------------------------------------
int __thiscall sub_100385AE(int this, int a2, char a3)
{
  int v3; // eax@1
  int v4; // esi@1
  int v5; // edi@2
  int v6; // ebx@4
  int v7; // eax@5
  int v8; // eax@5
  int result; // eax@8
  char v10; // [sp+Ch] [bp-34h]@5
  char v11; // [sp+1Ch] [bp-24h]@4
  int v12; // [sp+2Ch] [bp-14h]@4
  int v13; // [sp+34h] [bp-Ch]@4
  int v14; // [sp+38h] [bp-8h]@4
  int v15; // [sp+3Ch] [bp-4h]@4

  v4 = this;
  v3 = sub_10029F04(*(void **)(this + 4));
  if ( v3 )
    v5 = *(_DWORD *)(v3 + 4);
  else
    v5 = sub_1002A552(*(_DWORD *)(v4 + 4));
  sub_1003B8CD(*(void **)(v5 + 4), (int)&v11);
  v6 = a2;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = v5;
  while ( !sub_1004479B((int)&v11, v6) )
  {
    v7 = sub_1002A528(*(_DWORD *)(v4 + 4), 0, v5);
    v5 = v7;
    v8 = sub_1003B8CD(*(void **)(v7 + 4), (int)&v10);
    sub_10027C4E((int)&v11, v8);
    if ( v5 == v15 )
      v6 = (int)&v12;
  }
  result = (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v4 + 36))(v4, v6, v5);
  if ( !result )
  {
    if ( a3 )
    {
      sub_10028AD5((void *)(v4 + 8));
      result = (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v4 + 36))(v4, v6, v5);
      if ( !result )
        result = sub_100380E4((void *)v4, v6, v5);
      *(_DWORD *)(v4 + 8) = 0;
    }
  }
  return result;
}

//----- (10038667) --------------------------------------------------------
bool __thiscall sub_10038667(void *this)
{
  signed int i; // edi@1
  int v2; // esi@1
  bool result; // eax@2

  v2 = (int)this;
  for ( i = 0; i < *(_DWORD *)(v2 + 152); ++i )
  {
    result = sub_10037C97(v2 + 88, i);
    if ( result )
    {
      if ( *(_DWORD *)(result + 4) > *(_DWORD *)result || *(_DWORD *)(result + 80) > *(_DWORD *)(result + 76) )
        return result;
      if ( *(_DWORD *)(result + 56) == 1 )
        sub_10038899(v2, result);
    }
  }
  return *(_DWORD *)(v2 + 76) != *(_DWORD *)(v2 + 80);
}

//----- (100386BA) --------------------------------------------------------
int __thiscall sub_100386BA(void *this)
{
  void *v2; // edi@1
  void *v3; // esi@1
  int v4; // eax@1

  v2 = this;
  v3 = (void *)*((_DWORD *)this + 4);
  sub_1002C615(*((void **)this + 4));
  v4 = *((_DWORD *)v2 + 1);
  *((_BYTE *)v2 + 20) = 1;
  *((_DWORD *)v2 + 6) = v4;
  return sub_1002C625(v3);
}

//----- (100386DB) --------------------------------------------------------
int __thiscall sub_100386DB(void *this, int a2)
{
  return sub_10037D1C((int)((char *)this + 168), a2 + 44);
}

//----- (100386F4) --------------------------------------------------------
PSINGLE_LIST_ENTRY __thiscall sub_100386F4(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v4; // esi@1

  v4 = this;
  sub_1003C68B(a2, ebp0);
  return sub_1002B4ED(*(_DWORD *)(*((_DWORD *)v4 + 64) + 4), a2, 0);
}

//----- (1003871A) --------------------------------------------------------
char __thiscall sub_1003871A(void *ListHead, int a2, signed int a3, char a4)
{
  signed int v4; // edx@1
  int v6; // esi@1
  char result; // al@2
  int v8; // eax@3
  int v9; // ecx@3
  int v10; // edx@4
  int v11; // edi@4
  int v12; // edx@5
  PSINGLE_LIST_ENTRY v18; // eax@14
  int v19; // ST08_4@14

  v6 = (int)ListHead;
  v4 = a3 >> *((_DWORD *)ListHead + 11);
  _EBX = a3 & (*((_DWORD *)ListHead + 10) - 1);
  if ( v4 < *((_DWORD *)ListHead + 15) )
  {
    v9 = *((_DWORD *)ListHead + 14);
    v8 = *(_DWORD *)(v6 + 52);
    if ( v4 < v9 )
    {
      v11 = *(_DWORD *)(v8 + 4 * v4);
    }
    else
    {
      v10 = v4 - v9;
      v11 = *(_DWORD *)(v8 + 4 * v9 - 4);
      if ( v10 >= 0 )
      {
        v12 = v10 + 1;
        do
        {
          v11 = *(_DWORD *)(v11 + 4);
          --v12;
        }
        while ( v12 );
      }
    }
    _ECX = *(_DWORD *)v11 + 4 * _EBX;
    _EDX = 0;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 == a2 )
    {
      _ECX = v11 + 8;
      __asm { lock cmpxchg [ecx], ebx }
      if ( a4 )
      {
        if ( (signed int)QueryDepthSList((PSLIST_HEADER)v6) <= *(_DWORD *)(v6 + 68) )
        {
          InterlockedPushEntrySList((PSLIST_HEADER)v6, (PSINGLE_LIST_ENTRY)(a2 + 4));
        }
        else
        {
          InterlockedPushEntrySList((PSLIST_HEADER)(v6 + 8), (PSINGLE_LIST_ENTRY)(a2 + 4));
          if ( (signed int)QueryDepthSList((PSLIST_HEADER)(v6 + 8)) > *(_DWORD *)(v6 + 68) )
          {
            if ( !sub_1002A7FD(*(_DWORD *)(v6 + 36)) )
            {
              _EDX = 1;
              _ECX = v6 + 72;
              __asm { lock cmpxchg [ecx], edx }
              v18 = InterlockedFlushSList((PSLIST_HEADER)(v6 + 8));
              v19 = *(_DWORD *)(v6 + 36);
              *(_DWORD *)(v6 + 16) = v18;
              sub_1002ADAD(v6 + 20, (int (__cdecl *)(_DWORD))sub_100380B3, v6, v19);
            }
          }
        }
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10038810) --------------------------------------------------------
char __thiscall sub_10038810(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002B879(*(_DWORD *)(*(_DWORD *)(this + 256) + 4), this + 268);
  return sub_1003CFCC(*(void **)(v2 + 8), v2);
}

//----- (10038833) --------------------------------------------------------
char __thiscall sub_10038833(int this)
{
  int v1; // ecx@1
  int v2; // edi@1
  char result; // al@2
  int v4; // esi@2
  int v5; // ecx@3
  int v6; // esi@4

  v2 = this;
  v1 = *(_DWORD *)(this + 16);
  if ( v1 )
  {
    do
    {
      v4 = *(_DWORD *)(v1 + 260);
      result = sub_10038810(v1);
      v1 = v4;
    }
    while ( v4 );
  }
  v5 = *(_DWORD *)(v2 + 12);
  if ( v5 )
  {
    do
    {
      v6 = *(_DWORD *)(v5 + 260);
      result = sub_10038810(v5);
      v5 = v6;
    }
    while ( v6 );
  }
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)(v2 + 12) = 0;
  return result;
}

//----- (10038872) --------------------------------------------------------
int __thiscall sub_10038872(int this, int a2)
{
  int v3; // esi@1

  v3 = this;
  sub_100276F8((void *)(this + 88), a2, *(_DWORD *)(a2 + 68), 1);
  return sub_1002AD41(*(void **)(v3 + 256));
}

//----- (10038899) --------------------------------------------------------
char __thiscall sub_10038899(int this, int a2)
{
  int v2; // edi@1

  v2 = this;
  if ( sub_1003871A((void *)(this + 168), a2 + 44, *(_DWORD *)(a2 + 44), 0) )
  {
    if ( *(_DWORD *)(a2 + 80) <= *(_DWORD *)(a2 + 76) )
    {
      sub_10037521(a2, v2);
      return 1;
    }
    sub_100374C3(a2, v2);
  }
  return 0;
}

//----- (100388DB) --------------------------------------------------------
int __thiscall sub_100388DB(void *this, int a2, int a3, int a4)
{
  int v5; // eax@1

  v5 = (*(int (__stdcall **)(int, signed int))(*(_DWORD *)this + 20))(a4, 1);
  return sub_1003890F(v5, a2, a3);
}

//----- (100388F9) --------------------------------------------------------
int __thiscall sub_100388F9(void *this, int a2, int a3)
{
  int v4; // eax@1

  v4 = (*(int (__cdecl **)(_DWORD, _DWORD))(*(_DWORD *)this + 20))((char *)this + 32, 1);
  return sub_1003890F(v4, a2, a3);
}

//----- (1003890F) --------------------------------------------------------
int __thiscall sub_1003890F(int this, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // eax@2
  int v5; // eax@2
  int v6; // ecx@2
  int v7; // edi@2
  int v15; // eax@4
  int v16; // esi@4
  int v17; // eax@6
  int v18; // edx@9
  int v19; // ecx@9
  void *v20; // esi@9
  int result; // eax@17
  char v22; // [sp-10h] [bp-28h]@18
  int v23; // [sp-4h] [bp-1Ch]@2
  int (__stdcall **v24)(char); // [sp+Ch] [bp-Ch]@20

  v3 = this;
  if ( !a2 )
  {
    a2 = (int)"proc";
    sub_10023687((int)&v24, &a2);
    v24 = &off_100542CC;
    sub_1002D02B((int)&v24, (int)&unk_10061764);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10038A3B);
  }
  v5 = *(_DWORD *)(this + 256);
  v23 = a3;
  v7 = *(_DWORD *)(v5 + 4);
  v4 = sub_1002A5E9(v7, this, v7, a2, a3);
  v6 = *(_DWORD *)(v3 + 256);
  if ( !(*(_BYTE *)(v6 + 48) & 4) )
  {
    _ECX = v6 + 20;
    _EDX = 1;
    __asm { lock xadd [ecx], edx }
  }
  sub_1003831D(v3 + 40, v4);
  v15 = (int)sub_10029DCE();
  v16 = v15;
  if ( v15 && sub_1002729E(v15) == v7 )
  {
    v17 = *(_DWORD *)(v16 + 156);
    if ( *(_BYTE *)(v16 + 76) )
      ++*(_DWORD *)(v17 + 8);
    else
      ++*(_DWORD *)(v17 + 92);
  }
  else
  {
    v20 = TlsGetValue(*(_DWORD *)(v7 + 24));
    if ( !v20 )
    {
      v20 = (void *)sub_10027EB3(v18, v19, v3, v7, 28);
      if ( v20 )
      {
        *((_DWORD *)v20 + 2) = 0;
        *((_DWORD *)v20 + 3) = 0;
        *((_DWORD *)v20 + 4) = 0;
        *((_DWORD *)v20 + 5) = 0;
        *((_DWORD *)v20 + 6) = 1;
      }
      else
      {
        v20 = 0;
      }
      sub_10037D1C(v7 + 200, (int)v20);
      TlsSetValue(*(_DWORD *)(v7 + 24), v20);
    }
    ++*((_DWORD *)v20 + 2);
  }
  if ( *(_DWORD *)(v3 + 12) & 0xFFFFFFF )
    (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
  result = *(_DWORD *)(v7 + 432);
  if ( *(_DWORD *)(v7 + 428) - result > 0 )
  {
    sub_10027C4E((int)&v22, v3 + 12);
    result = (*(int (__thiscall **)(int))(*(_DWORD *)v7 + 56))(v7);
  }
  return result;
}
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);

//----- (10038A3B) --------------------------------------------------------
int __thiscall sub_10038A3B(int this, int a2)
{
  int result; // eax@1

  _EDX = a2;
  result = this + 20;
  __asm { lock xadd [eax], edx }
  if ( !(a2 + _EDX) )
    result = sub_1002ADAD(this + 28, sub_1003B312, this, *(_DWORD *)this);
  return result;
}

//----- (10038A61) --------------------------------------------------------
int __userpurge sub_10038A61<eax>(int a1<ecx>, int a2<edi>, char a3)
{
  signed int v3; // ebx@1
  int ebp0; // ebp@0
  int v5; // esi@1
  int v6; // ecx@1
  signed int v7; // eax@2
  int v8; // eax@3
  int result; // eax@5
  int v10; // eax@7
  int v11; // eax@8
  int v12; // ecx@8
  char v13; // al@12
  int v14; // ecx@17
  int v15; // ecx@20
  int v16; // eax@21
  char v17; // al@26
  int v18; // eax@35
  int v19; // [sp+Ch] [bp-5Ch]@1
  int v20; // [sp+10h] [bp-58h]@9
  int v21; // [sp+14h] [bp-54h]@5
  int v22; // [sp+18h] [bp-50h]@2
  int v23; // [sp+1Ch] [bp-4Ch]@2
  char v24; // [sp+22h] [bp-46h]@2
  char v25; // [sp+23h] [bp-45h]@1
  int v26[16]; // [sp+24h] [bp-44h]@8
  unsigned int v27; // [sp+64h] [bp-4h]@1
  int v28; // [sp+68h] [bp+0h]@1

  v27 = (unsigned int)&v28 ^ __security_cookie;
  v5 = a1;
  v3 = 0;
  v6 = *(_DWORD *)(a1 + 152);
  LOBYTE(v20) = a3;
  v25 = 0;
  v19 = v6;
  if ( v6 > 0 )
  {
    v7 = 0;
    v22 = 0;
    v24 = 0;
    v23 = 0;
    while ( 1 )
    {
      v8 = sub_10037C97(v5 + 88, v7);
      a2 = v8;
      if ( v8 )
      {
        if ( sub_100374AD(v8) )
        {
          v13 = *(_DWORD *)(a2 + 56) == 1;
        }
        else
        {
          result = sub_10037652(a2, a3, (int)&v24);
          v21 = result;
          if ( result )
            return result;
          if ( !v24 )
          {
            v10 = v22;
            if ( v22 < 15 )
            {
              v12 = v23;
              v26[v22] = v23;
              v11 = v10 + 1;
              v22 = v11;
              goto LABEL_17;
            }
            result = sub_10037567(ebp0, v20);
            v21 = result;
            if ( result )
              return result;
          }
          v13 = *(_DWORD *)(a2 + 56) == 1 && sub_100374AD(a2);
        }
        v25 |= v13;
      }
      v11 = v22;
      v12 = v23;
LABEL_17:
      v14 = v12 + 1;
      v23 = v14;
      if ( v14 >= v19 )
      {
        if ( v11 > 0 )
        {
          v15 = 0;
          v23 = 0;
          while ( 1 )
          {
            v16 = sub_10037C97(v5 + 88, v26[v15]);
            a2 = v16;
            if ( v16 )
            {
              if ( !sub_100374AD(v16) )
              {
                result = sub_10037567(ebp0, v20);
                v21 = result;
                if ( result )
                  return result;
              }
              v17 = *(_DWORD *)(a2 + 56) == 1 && sub_100374AD(a2);
              v25 |= v17;
            }
            v15 = v23 + 1;
            v23 = v15;
            if ( v15 >= v22 )
              goto LABEL_30;
          }
        }
        break;
      }
      v7 = v14;
    }
  }
LABEL_30:
  if ( sub_100381F2(v5 + 52, a2, (int)&v21) )
  {
    sub_10036DAB(v21, 1);
    result = v21;
  }
  else
  {
    if ( *(_DWORD *)(v5 + 232) > 0 )
    {
      if ( v25 )
      {
        if ( *(_DWORD *)(v5 + 152) > 0 )
        {
          do
          {
            v18 = sub_10037C97(v5 + 88, v3);
            if ( v18 )
            {
              if ( *(_DWORD *)(v18 + 56) == 1 )
              {
                if ( *(_DWORD *)(v18 + 80) <= *(_DWORD *)(v18 + 76) )
                  sub_10038899(v5, v18);
              }
            }
            ++v3;
          }
          while ( v3 < *(_DWORD *)(v5 + 152) );
        }
      }
    }
    result = 0;
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 10038A61: using guessed type int var_44[16];

//----- (10038C10) --------------------------------------------------------
bool __cdecl sub_10038C10(int a1)
{
  PVOID v1; // eax@1

  v1 = DecodePointer(dword_10069C8C);
  return v1 && ((int (__cdecl *)(int))v1)(a1);
}

//----- (10038C36) --------------------------------------------------------
void *__cdecl sub_10038C36(void *a1)
{
  void *result; // eax@1

  result = a1;
  dword_10069C8C = a1;
  return result;
}

//----- (10038C43) --------------------------------------------------------
void __cdecl sub_10038C43()
{
  dword_1006B3A0 = 0;
}
// 1006B3A0: using guessed type int dword_1006B3A0;

//----- (10038C4B) --------------------------------------------------------
signed int __usercall sub_10038C4B<eax>(int a1<edx>, int a2<ebx>, int a3, unsigned int *a4, void **a5, const void *a6, int a7)
{
  unsigned int v7; // eax@2
  const void *v8; // ecx@2
  LPVOID v9; // eax@3
  int v11; // eax@6

  if ( a3 == *a4 )
  {
    v8 = *a5;
    v7 = *a4;
    if ( *a5 == a6 )
    {
      v9 = sub_1002EFE1((int)v8, a2, v7, 2u);
      *a5 = v9;
      if ( !v9 )
        return 0;
      *(_DWORD *)a7 = 1;
      sub_1002C950(*a5, a6, *a4);
    }
    else
    {
      v11 = sub_1002F0C0(a1, (int)v8, a2, v8, v7, 2u);
      if ( !v11 )
        return 0;
      *a5 = (void *)v11;
    }
    *a4 *= 2;
  }
  return 1;
}

//----- (10038CAA) --------------------------------------------------------
int __usercall sub_10038CAA<eax>(int a1<edi>, unsigned __int8 a2)
{
  int result; // eax@1
  char v3; // zf@1

  v3 = sub_1002E853(a2, a1, a2) == 0;
  result = (char)a2;
  if ( v3 )
    result = ((char)a2 & 0xFFFFFFDF) - 7;
  return result;
}

//----- (10038CCB) --------------------------------------------------------
signed int __usercall sub_10038CCB<eax>(int a1<edx>, int a2<ebx>, int a3)
{
  char v3; // sf@1
  signed int v4; // edx@2

  v3 = *(_DWORD *)(a3 + 4)-- - 1 < 0;
  if ( v3 )
    v4 = sub_1004482A(a1, a3, a2, a3);
  else
    v4 = *(_BYTE *)*(_DWORD *)a3++;
  return v4;
}

//----- (10038CED) --------------------------------------------------------
signed int __cdecl sub_10038CED(int a1, int a2, int a3, int a4)
{
  signed int v4; // ebx@1
  int v5; // edi@1
  signed int result; // eax@2
  signed int v7; // eax@5
  int v8; // edx@7
  int v9; // ecx@12
  unsigned __int8 v10; // al@16
  int v11; // ecx@16
  int v12; // esi@16
  int v13; // edx@18
  int v14; // eax@19
  int v15; // edx@19
  int v16; // esi@19
  int v17; // edi@25
  int v18; // esi@25
  char v19; // al@28
  char v20; // cl@29
  int v21; // esi@31
  int v22; // edx@32
  char v23; // al@40
  int v24; // edx@67
  char v25; // al@68
  signed int v26; // edi@71
  signed int v27; // eax@74
  int v28; // eax@78
  int v29; // ecx@78
  int v30; // eax@88
  int v31; // esi@91
  int v32; // edi@94
  int i; // eax@98
  int v34; // edx@98
  int v35; // ecx@99
  int v36; // eax@100
  int v38; // eax@102
  int v39; // eax@104
  int v40; // edx@105
  int j; // eax@106
  int v42; // eax@107
  int v44; // eax@109
  int v45; // eax@114
  int v46; // edx@115
  int v47; // eax@116
  int v48; // edx@116
  int v49; // eax@120
  int k; // eax@123
  int v51; // eax@124
  int v53; // eax@126
  int v54; // ecx@132
  LPVOID v55; // ST10_4@132
  int v56; // ST0C_4@132
  int v57; // ST08_4@132
  PVOID v58; // eax@132
  int v59; // ecx@137
  int v60; // esi@137
  int v61; // eax@141
  signed int v62; // eax@142
  int v63; // ecx@142
  int v64; // ST14_4@142
  int v65; // edx@152
  int v66; // edx@154
  char v67; // al@161
  int v68; // edx@165
  char v69; // ah@168
  int v70; // edx@170
  char v71; // cl@172
  char v72; // al@174
  char v73; // al@182
  int v74; // eax@194
  int v75; // edx@194
  char v76; // zf@198
  int v77; // eax@209
  char v78; // al@226
  int v79; // edx@234
  int v80; // ecx@234
  int v81; // eax@234
  int v82; // ST14_4@234
  int v83; // ecx@237
  __int64 v84; // qt0@237
  __int64 v85; // ST08_8@238
  __int64 v86; // qax@238
  int v87; // eax@239
  int v88; // ST14_4@239
  __int64 v89; // qt0@240
  __int64 v90; // qax@241
  int v91; // ecx@241
  unsigned __int8 v92; // cf@241
  char v93; // zf@242
  int v94; // ecx@248
  int v95; // edx@252
  int v96; // ecx@252
  int v97; // eax@252
  int v98; // ST14_4@252
  int v99; // eax@255
  int v100; // eax@257
  int v101; // ST14_4@257
  int v102; // eax@259
  char v103; // zf@260
  int v104; // eax@271
  int v105; // eax@280
  int v106; // ST14_4@280
  int v108; // eax@282
  int v109; // esi@289
  int v110; // ST14_4@290
  int v111; // [sp-8h] [bp-20Ch]@19
  int v112; // [sp-8h] [bp-20Ch]@106
  int v113; // [sp-8h] [bp-20Ch]@123
  int v114; // [sp-8h] [bp-20Ch]@194
  signed int v115; // [sp-8h] [bp-20Ch]@200
  int v116; // [sp-8h] [bp-20Ch]@292
  int v117; // [sp+8h] [bp-1FCh]@16
  int v118; // [sp+10h] [bp-1F4h]@303
  char v119; // [sp+14h] [bp-1F0h]@302
  int v120; // [sp+18h] [bp-1ECh]@17
  int v121; // [sp+1Ch] [bp-1E8h]@17
  int v122; // [sp+20h] [bp-1E4h]@1
  WCHAR WideCharStr[2]; // [sp+24h] [bp-1E0h]@1
  const CHAR MultiByteStr; // [sp+28h] [bp-1DCh]@152
  char v125; // [sp+29h] [bp-1DBh]@153
  int v126; // [sp+2Ch] [bp-1D8h]@1
  int v127; // [sp+30h] [bp-1D4h]@25
  char v128; // [sp+37h] [bp-1CDh]@25
  int v129; // [sp+38h] [bp-1CCh]@1
  int v130; // [sp+3Ch] [bp-1C8h]@16
  int v131; // [sp+40h] [bp-1C4h]@25
  int v132; // [sp+44h] [bp-1C0h]@25
  int v133; // [sp+48h] [bp-1BCh]@17
  int v134; // [sp+4Ch] [bp-1B8h]@26
  int v135; // [sp+50h] [bp-1B4h]@25
  LPVOID lpMem; // [sp+54h] [bp-1B0h]@1
  int v137; // [sp+58h] [bp-1ACh]@17
  __int16 v138; // [sp+5Eh] [bp-1A6h]@25
  int v139; // [sp+60h] [bp-1A4h]@1
  int v140; // [sp+64h] [bp-1A0h]@1
  int v141; // [sp+68h] [bp-19Ch]@16
  char v142; // [sp+6Eh] [bp-196h]@25
  char v143; // [sp+6Fh] [bp-195h]@31
  int v144; // [sp+70h] [bp-194h]@16
  int v145; // [sp+74h] [bp-190h]@1
  int v146; // [sp+78h] [bp-18Ch]@31
  char v147; // [sp+7Ch] [bp-188h]@67
  char v148; // [sp+7Dh] [bp-187h]@16
  char v149; // [sp+7Eh] [bp-186h]@25
  char v150; // [sp+7Fh] [bp-185h]@25
  char v151; // [sp+80h] [bp-184h]@1
  char v152[11]; // [sp+1E0h] [bp-24h]@149
  char v153; // [sp+1EBh] [bp-19h]@168
  unsigned int v154; // [sp+200h] [bp-4h]@1
  int v155; // [sp+204h] [bp+0h]@1

  v154 = (unsigned int)&v155 ^ __security_cookie;
  v129 = 0;
  *(_DWORD *)WideCharStr = 0;
  v5 = a2;
  v122 = a4;
  v4 = 0;
  v145 = a1;
  v139 = a2;
  lpMem = &v151;
  v126 = 350;
  v140 = 0;
  if ( !a2 || !a1 )
  {
    *(_DWORD *)sub_1002F144(0) = 22;
    sub_10036C88(0, a2);
    return -1;
  }
  if ( !(*(_BYTE *)(a1 + 12) & 0x40) )
  {
    v7 = sub_1004494B(0, a2, a1);
    if ( v7 == -1 || v7 == -2 )
      v8 = (int)&unk_10067A10;
    else
      v8 = dword_10069CE0[v7 >> 5] + ((v7 & 0x1F) << 6);
    if ( *(_BYTE *)(v8 + 36) & 0x7F
      || (v7 == -1 || v7 == -2 ? (v9 = (int)&unk_10067A10) : (v9 = dword_10069CE0[v7 >> 5] + ((v7 & 0x1F) << 6)),
          *(_BYTE *)(v9 + 36) & 0x80) )
    {
      *(_DWORD *)sub_1002F144(0) = 22;
      sub_10036C88(0, a2);
      return -1;
    }
  }
  sub_1002E635((int)&v117, 0, a2, a3);
  v10 = *(_BYTE *)a2;
  v12 = 0;
  v11 = 0;
  v148 = 0;
  v144 = 0;
  v141 = 0;
  v130 = 0;
  if ( !v10 )
    goto LABEL_301;
  v137 = v121;
  v133 = v120;
  while ( 1 )
  {
    if ( sub_1002E8A9(v4, v5, v10) )
    {
      v141 = v12 - 1;
      v16 = v145;
      v14 = sub_10039DDB(v13, v4, v5, (int)&v141, v145);
      if ( v14 != -1 )
        sub_1004496F(v15, v111, v4, v14, v16);
      do
        ++v5;
      while ( sub_1002E8A9(v4, v5, *(_BYTE *)v5) );
      v12 = v141;
      v139 = v5;
      v144 = v141;
      goto LABEL_287;
    }
    if ( *(_BYTE *)v5 != 37 )
      goto LABEL_280;
    if ( *(_BYTE *)(v5 + 1) != 37 )
      break;
    if ( *(_BYTE *)v5 == 37 )
    {
      if ( *(_BYTE *)(v5 + 1) == 37 )
        ++v5;
    }
LABEL_280:
    ++v12;
    v144 = v12;
    v141 = v12;
    v4 = sub_10038CCB(v13, v4, v145);
    v105 = *(_BYTE *)v5++;
    v29 = v106;
    v140 = v4;
    v139 = v5;
    if ( v105 != v4 )
      goto LABEL_293;
    if ( !sub_10041D7D(v4, v5, v4) )
      goto LABEL_284;
    v108 = sub_10038CCB(v24, v4, v145);
    v29 = *(_BYTE *)v5++;
    v139 = v5;
    if ( v29 != v108 )
    {
      v109 = v145;
      if ( v108 != -1 )
      {
        sub_1004496F(v24, v29, v4, v108, v145);
        v29 = v110;
      }
      if ( v4 == -1 )
        goto LABEL_296;
      v116 = v109;
LABEL_295:
      sub_1004496F(v24, v29, v4, v4, v116);
      goto LABEL_296;
    }
    v144 = v12;
    v141 = v12;
LABEL_284:
    if ( v4 == -1 && (*(_BYTE *)v5 != 37 || *(_BYTE *)(v5 + 1) != 110) )
      goto LABEL_296;
LABEL_287:
    v10 = *(_BYTE *)v5;
    if ( !*(_BYTE *)v5 )
      goto LABEL_296;
  }
  v18 = v139;
  v131 = 0;
  v128 = 0;
  v135 = 0;
  v132 = 0;
  v17 = 0;
  v138 = 0;
  v149 = 0;
  v142 = 0;
  v150 = 0;
  v127 = 0;
  LOWORD(v4) = 256;
  do
  {
    ++v18;
    v134 = *(_BYTE *)v18;
    if ( sub_1002E853(v4, v17, (unsigned __int8)v134) )
    {
      ++v132;
      v17 = v134 + 10 * v17 - 48;
      goto LABEL_28;
    }
    if ( v134 > 78 )
    {
      if ( v134 == 104 )
      {
        --BYTE1(v4);
        v20 = v150 - 1;
      }
      else
      {
        if ( v134 == 108 )
        {
          if ( *(_BYTE *)(v18 + 1) == 108 )
          {
            ++v18;
            goto LABEL_43;
          }
          LOWORD(v4) = v4 + 256;
        }
        else
        {
          if ( v134 != 119 )
            goto LABEL_57;
        }
        v20 = v150 + 1;
      }
      v150 = v20;
    }
    else
    {
      if ( v134 == 78 )
        goto LABEL_28;
      if ( v134 == 42 )
      {
        v19 = v149++ + 1;
        goto LABEL_29;
      }
      if ( v134 == 70 )
        goto LABEL_28;
      if ( v134 != 73 )
      {
        if ( v134 == 76 )
        {
          LOWORD(v4) = v4 + 256;
          goto LABEL_28;
        }
        goto LABEL_57;
      }
      v23 = *(_BYTE *)(v18 + 1);
      if ( v23 == 54 && *(_BYTE *)(v18 + 2) == 52 )
      {
        v18 += 2;
LABEL_43:
        ++v127;
        v133 = 0;
        v137 = 0;
        goto LABEL_28;
      }
      if ( v23 == 51 && *(_BYTE *)(v18 + 2) == 50 )
      {
        v18 += 2;
        goto LABEL_28;
      }
      if ( v23 == 100 )
        goto LABEL_28;
      if ( v23 != 105 )
      {
        if ( v23 == 111 || v23 == 120 || v23 == 88 )
        {
LABEL_28:
          v19 = v149;
LABEL_29:
          v20 = v150;
          continue;
        }
LABEL_57:
        LOBYTE(v4) = v4 + 1;
        goto LABEL_28;
      }
      v20 = v150;
    }
    v19 = v149;
  }
  while ( !(_BYTE)v4 );
  v143 = BYTE1(v4);
  v4 = v140;
  v139 = v18;
  v21 = v144;
  v146 = v17;
  if ( v19 )
  {
    v134 = 0;
  }
  else
  {
    v121 = v122;
    v22 = *(_DWORD *)v122;
    v122 += 4;
    v134 = v22;
  }
  v24 = v139;
  v147 = 0;
  if ( !v20 )
  {
    v25 = *(_BYTE *)v139;
    if ( *(_BYTE *)v139 == 83 || (v150 = -1, v25 == 67) )
      v150 = 1;
  }
  v26 = *(_BYTE *)v139 | 0x20;
  if ( v26 == 110 )
  {
LABEL_78:
    v28 = v132;
    v29 = v146;
    if ( v132 && !v146 )
    {
LABEL_293:
      if ( v4 == -1 )
        goto LABEL_296;
      v116 = v145;
      goto LABEL_295;
    }
    if ( v26 <= 111 )
    {
      if ( v26 == 111 )
        goto LABEL_221;
      if ( v26 != 99 )
      {
        if ( v26 != 100 )
        {
          if ( v26 <= 100 )
            goto LABEL_160;
          if ( v26 > 103 )
          {
            if ( v26 != 105 )
            {
              if ( v26 == 110 )
              {
                v30 = v21;
                if ( v149 )
                {
LABEL_275:
                  v67 = v148;
LABEL_276:
                  v12 = v144;
                  v5 = v139 + 1;
                  v148 = v67 + 1;
                  ++v139;
                  goto LABEL_284;
                }
LABEL_270:
                if ( v127 )
                {
                  v104 = v134;
                  *(_DWORD *)v134 = v133;
                  *(_DWORD *)(v104 + 4) = v137;
                }
                else
                {
                  if ( v143 )
                    *(_DWORD *)v134 = v30;
                  else
                    *(_WORD *)v134 = v30;
                }
                goto LABEL_275;
              }
LABEL_160:
              if ( *(_BYTE *)v24 != v4 )
                goto LABEL_293;
              v67 = v148 - 1;
              if ( !v149 )
                v122 = v121;
              goto LABEL_276;
            }
            v26 = 100;
LABEL_186:
            if ( v4 == 45 )
            {
              LOBYTE(v138) = 1;
            }
            else
            {
              if ( v4 != 43 )
              {
LABEL_193:
                if ( v4 != 48 )
                {
LABEL_229:
                  v78 = v147;
                  goto LABEL_230;
                }
                ++v21;
                v144 = v21;
                v141 = v21;
                v74 = sub_10038CCB(v24, 48, v145);
                v4 = v74;
                v140 = v74;
                if ( (_BYTE)v74 == 120 || (_BYTE)v74 == 88 )
                {
                  ++v21;
                  v144 = v21;
                  v141 = v21;
                  v4 = sub_10038CCB(v75, v74, v145);
                  v140 = v4;
                  if ( v132 )
                  {
                    v146 -= 2;
                    if ( v146 < 1 )
                      ++v147;
                  }
                  v115 = 120;
                  goto LABEL_201;
                }
                v135 = 1;
                if ( v26 != 120 )
                {
                  if ( v132 )
                  {
                    v76 = v146-- == 1;
                    if ( v76 )
                      ++v147;
                  }
                  v115 = 111;
LABEL_201:
                  v26 = v115;
                  goto LABEL_229;
                }
                --v21;
                v144 = v21;
                v141 = v21;
                if ( v74 != -1 )
                  sub_1004496F(v75, v114, v74, v74, v145);
                v4 = 48;
LABEL_228:
                v140 = v4;
                goto LABEL_229;
              }
            }
            --v146;
            if ( v146 || !v28 )
            {
              ++v21;
              v144 = v21;
              v141 = v21;
              v4 = sub_10038CCB(v24, v4, v145);
              v140 = v4;
            }
            else
            {
              v147 = 1;
            }
            goto LABEL_193;
          }
          v31 = 0;
          if ( v4 == 45 )
          {
            v31 = 1;
            *(_BYTE *)lpMem = 45;
          }
          else
          {
            if ( v4 != 43 )
            {
              v32 = v144;
              goto LABEL_96;
            }
          }
          v146 = v29 - 1;
          v32 = v144 + 1;
          v4 = sub_10038CCB(v24, v4, v145);
          v28 = v132;
          v140 = v4;
LABEL_96:
          if ( !v28 )
            v146 = -1;
          for ( i = sub_1002E853(v4, v32, (unsigned __int8)v4); ; i = sub_1002E853(v38, v32, (unsigned __int8)v38) )
          {
            v35 = v146;
            if ( !i )
              break;
            v36 = v146;
            v35 = v146-- - 1;
            if ( !v36 )
              break;
            ++v135;
            *((_BYTE *)lpMem + v31++) = v4;
            if ( !sub_10038C4B(v34, v4, v31, (unsigned int *)&v126, &lpMem, &v151, (int)&v129) )
              goto LABEL_296;
            ++v32;
            v38 = sub_10038CCB(v34, v4, v145);
            v4 = v38;
            v140 = v38;
          }
          HIBYTE(v138) = ***(_BYTE ***)(v117 + 132);
          if ( HIBYTE(v138) == (_BYTE)v4 )
          {
            v39 = v35--;
            v146 = v35;
            if ( v39 )
            {
              ++v32;
              v4 = sub_10038CCB(v34, v4, v145);
              *((_BYTE *)lpMem + v31++) = HIBYTE(v138);
              v140 = v4;
              if ( !sub_10038C4B(v40, v4, v31, (unsigned int *)&v126, &lpMem, &v151, (int)&v129) )
                goto LABEL_296;
              for ( j = sub_1002E853(v4, v32, (unsigned __int8)v4); ; j = sub_1002E853(v44, v32, (unsigned __int8)v44) )
              {
                v35 = v112;
                if ( !j )
                  break;
                v42 = v146;
                v35 = v146-- - 1;
                if ( !v42 )
                  break;
                ++v135;
                *((_BYTE *)lpMem + v31++) = v4;
                if ( !sub_10038C4B(v34, v4, v31, (unsigned int *)&v126, &lpMem, &v151, (int)&v129) )
                  goto LABEL_296;
                ++v32;
                v44 = sub_10038CCB(v34, v4, v145);
                v4 = v44;
                v140 = v44;
              }
            }
          }
          if ( !v135 || v4 != 101 && v4 != 69 || (v45 = v146, v35 = v146 - 1, --v146, !v45) )
            goto LABEL_128;
          *((_BYTE *)lpMem + v31++) = 101;
          if ( !sub_10038C4B(v34, v4, v31, (unsigned int *)&v126, &lpMem, &v151, (int)&v129) )
            goto LABEL_296;
          ++v32;
          v47 = sub_10038CCB(v46, v4, v145);
          v4 = v47;
          v140 = v47;
          if ( v47 == 45 )
          {
            *((_BYTE *)lpMem + v31++) = 45;
            if ( !sub_10038C4B(v48, v47, v31, (unsigned int *)&v126, &lpMem, &v151, (int)&v129) )
              goto LABEL_296;
          }
          else
          {
            if ( v47 != 43 )
              goto LABEL_123;
          }
          v49 = v146--;
          if ( v49 )
          {
            ++v32;
            v4 = sub_10038CCB(v48, v4, v145);
            v140 = v4;
          }
          else
          {
            v146 = 0;
          }
LABEL_123:
          for ( k = sub_1002E853(v4, v32, (unsigned __int8)v4); ; k = sub_1002E853(v53, v32, (unsigned __int8)v53) )
          {
            v35 = v113;
            if ( !k )
              break;
            v51 = v146;
            v35 = v146-- - 1;
            if ( !v51 )
              break;
            ++v135;
            *((_BYTE *)lpMem + v31++) = v4;
            if ( !sub_10038C4B(v34, v4, v31, (unsigned int *)&v126, &lpMem, &v151, (int)&v129) )
              goto LABEL_296;
            ++v32;
            v53 = sub_10038CCB(v34, v4, v145);
            v4 = v53;
            v140 = v53;
          }
LABEL_128:
          v144 = v32 - 1;
          v141 = v32 - 1;
          if ( v4 != -1 )
            sub_1004496F(v34, v35, v4, v4, v145);
          if ( !v135 )
            goto LABEL_296;
          if ( !v149 )
          {
            ++v130;
            v54 = v134;
            v55 = lpMem;
            *((_BYTE *)lpMem + v31) = 0;
            v56 = v54;
            v57 = v143 - 1;
            v58 = DecodePointer(off_100680C0);
            ((void (__cdecl *)(int, int, LPVOID, int *))v58)(v57, v56, v55, &v117);
          }
          goto LABEL_275;
        }
LABEL_221:
        if ( v4 == 45 )
        {
          LOBYTE(v138) = 1;
        }
        else
        {
          if ( v4 != 43 )
            goto LABEL_229;
        }
        --v146;
        if ( !v146 && v28 )
        {
          v78 = 1;
LABEL_230:
          if ( v127 )
          {
            if ( !v78 )
            {
              while ( 1 )
              {
                if ( v26 == 120 || v26 == 112 )
                {
                  v87 = sub_1002E8FF(v4, v26, (unsigned __int8)v4);
                  v80 = v88;
                  if ( !v87 )
                  {
LABEL_244:
                    v144 = v21 - 1;
                    v141 = v21 - 1;
                    if ( v4 != -1 )
                      sub_1004496F(v79, v80, v4, v4, v145);
                    break;
                  }
                  HIDWORD(v89) = v137;
                  LODWORD(v89) = v133;
                  v137 = (unsigned __int64)(16 * v89) >> 32;
                  v133 *= 16;
                  v4 = sub_10038CAA(v26, v4);
                  v83 = v133;
                  v140 = v4;
                }
                else
                {
                  v81 = sub_1002E853(v4, v26, (unsigned __int8)v4);
                  v80 = v82;
                  if ( !v81 )
                    goto LABEL_244;
                  if ( v26 == 111 )
                  {
                    if ( v4 >= 56 )
                      goto LABEL_244;
                    HIDWORD(v84) = v137;
                    LODWORD(v84) = v133;
                    v137 = (unsigned __int64)(8 * v84) >> 32;
                    v83 = 8 * v133;
                  }
                  else
                  {
                    HIDWORD(v85) = v137;
                    LODWORD(v85) = v133;
                    v86 = sub_100315D0(v85, 10i64);
                    v83 = v86;
                    v137 = HIDWORD(v86);
                  }
                }
                ++v135;
                v90 = v4 - 48;
                v92 = (_DWORD)v90 >= (unsigned int)-v83;
                v91 = v90 + v83;
                LODWORD(v90) = HIDWORD(v90) + v92 + v137;
                v133 = v91;
                v137 += HIDWORD(v90) + v92;
                if ( v132 )
                {
                  v93 = v146-- == 1;
                  if ( v93 )
                    goto LABEL_247;
                }
                ++v21;
                v144 = v21;
                v141 = v21;
                v4 = sub_10038CCB(SHIDWORD(v90), v4, v145);
                v140 = v4;
              }
            }
            v91 = v133;
            LODWORD(v90) = v137;
LABEL_247:
            if ( (_BYTE)v138 )
            {
              v94 = -v91;
              v133 = v94;
              v137 = (unsigned __int64)-__PAIR__(v90, v94) >> 32;
            }
          }
          else
          {
            if ( !v78 )
            {
              while ( 1 )
              {
                if ( v26 == 120 || v26 == 112 )
                {
                  v100 = sub_1002E8FF(v4, v26, (unsigned __int8)v4);
                  v96 = v101;
                  if ( !v100 )
                  {
LABEL_262:
                    v144 = v21 - 1;
                    v141 = v21 - 1;
                    if ( v4 != -1 )
                      sub_1004496F(v95, v96, v4, v4, v145);
                    break;
                  }
                  v131 *= 16;
                  v4 = sub_10038CAA(v26, v4);
                  v99 = v131;
                  v140 = v4;
                }
                else
                {
                  v97 = sub_1002E853(v4, v26, (unsigned __int8)v4);
                  v96 = v98;
                  if ( !v97 )
                    goto LABEL_262;
                  if ( v26 == 111 )
                  {
                    if ( v4 >= 56 )
                      goto LABEL_262;
                    v99 = 8 * v131;
                  }
                  else
                  {
                    v99 = 10 * v131;
                  }
                }
                ++v135;
                v102 = v4 + v99 - 48;
                v131 = v102;
                if ( v132 )
                {
                  v103 = v146-- == 1;
                  if ( v103 )
                    goto LABEL_265;
                }
                ++v21;
                v144 = v21;
                v141 = v21;
                v4 = sub_10038CCB(v95, v4, v145);
                v140 = v4;
              }
            }
            v102 = v131;
LABEL_265:
            if ( (_BYTE)v138 )
              v131 = -v102;
          }
          if ( !(v26 != 70 ? v135 : 0) )
            goto LABEL_296;
          if ( v149 )
            goto LABEL_275;
          ++v130;
          v30 = v131;
          goto LABEL_270;
        }
        ++v21;
        v144 = v21;
        v141 = v21;
        v4 = sub_10038CCB(v24, v4, v145);
        goto LABEL_228;
      }
      if ( !v132 )
      {
        v132 = 1;
        ++v146;
      }
      goto LABEL_135;
    }
    if ( v26 == 112 )
    {
      v143 = 1;
    }
    else
    {
      if ( v26 == 115 )
      {
LABEL_135:
        if ( v150 > 0 )
          v142 = 1;
        goto LABEL_137;
      }
      if ( v26 != 117 )
      {
        if ( v26 == 120 )
        {
          v28 = v132;
          goto LABEL_186;
        }
        if ( v26 != 123 )
          goto LABEL_160;
        if ( v150 > 0 )
          v142 = 1;
        v68 = v24 + 1;
        v139 = v68;
        if ( *(_BYTE *)v68 == 94 )
        {
          v139 = v68 + 1;
          HIBYTE(v138) = -1;
        }
        sub_10030CF0(v152, 0, 32);
        v24 = v139;
        if ( *(_BYTE *)v139 == 93 )
        {
          v69 = 93;
          v24 = v139 + 1;
          v153 = 32;
        }
        else
        {
          v69 = v128;
        }
        while ( 1 )
        {
          v73 = *(_BYTE *)v24;
          if ( *(_BYTE *)v24 == 93 )
            break;
          v70 = v24 + 1;
          v139 = v70;
          if ( v73 == 45 && v69 && (v71 = *(_BYTE *)v70, *(_BYTE *)v70 != 93) )
          {
            v139 = v70 + 1;
            if ( v69 >= (unsigned __int8)v71 )
            {
              v72 = v69;
              v69 = v71;
            }
            else
            {
              v72 = v71;
            }
            while ( (unsigned __int8)v69 < (signed int)(unsigned __int8)v72 )
            {
              v152[(unsigned int)(unsigned __int8)v69 >> 3] |= 1 << (v69 & 7);
              ++v69;
            }
            v152[(unsigned int)(unsigned __int8)v72 >> 3] |= 1 << (v72 & 7);
            v69 = 0;
          }
          else
          {
            v69 = v73;
            v152[(unsigned int)(unsigned __int8)v73 >> 3] |= 1 << (v73 & 7);
          }
          v24 = v139;
        }
        if ( !v73 )
          goto LABEL_296;
        v139 = v24;
LABEL_137:
        v60 = v134;
        v59 = v144 - 1;
        v144 = v59;
        v141 = v59;
        if ( v4 != -1 )
        {
          sub_1004496F(v24, v59, v4, v4, v145);
          goto LABEL_139;
        }
        while ( 1 )
        {
          if ( v132 )
          {
            v61 = v146;
            v24 = v146-- - 1;
            if ( !v61 )
              break;
          }
          v144 = v59 + 1;
          v141 = v59 + 1;
          v62 = sub_10038CCB(v24, v4, v145);
          v4 = v62;
          v63 = v64;
          v140 = v62;
          if ( v62 == -1 )
            goto LABEL_211;
          if ( v26 != 99 )
          {
            if ( v26 != 115 )
              goto LABEL_306;
            if ( v62 >= 9 && v62 <= 13 )
            {
LABEL_211:
              --v144;
              v141 = v144;
              if ( v62 != -1 )
                sub_1004496F(v24, v63, v62, v62, v145);
              break;
            }
            if ( v62 == 32 )
            {
LABEL_306:
              if ( v26 != 123 || (v24 = 1 << (v62 & 7), v63 = SHIBYTE(v138) ^ v152[v62 >> 3], !(v24 & v63)) )
                goto LABEL_211;
            }
          }
          if ( v149 )
          {
            ++v60;
          }
          else
          {
            if ( v142 )
            {
              MultiByteStr = v62;
              if ( sub_10041D7D(v62, v26, v62) )
              {
                ++v144;
                v141 = v144;
                v125 = sub_10038CCB(v65, v4, v145);
              }
              *(_DWORD *)WideCharStr = 63;
              sub_10044A4F(v26, WideCharStr, &MultiByteStr, *(_DWORD *)(v117 + 116), (int)&v117);
              v66 = v134;
              *(_WORD *)v134 = WideCharStr[0];
              v24 = v66 + 2;
              v134 = v24;
            }
            else
            {
              v77 = v134;
              *(_BYTE *)v134 = v4;
              v134 = v77 + 1;
            }
          }
LABEL_139:
          v59 = v144;
        }
        if ( v60 == v134 )
          goto LABEL_296;
        if ( !v149 )
        {
          ++v130;
          if ( v26 != 99 )
          {
            if ( v142 )
              *(_WORD *)v134 = 0;
            else
              *(_BYTE *)v134 = 0;
          }
        }
        goto LABEL_275;
      }
    }
    v28 = v132;
    goto LABEL_221;
  }
  if ( v26 == 99 || v26 == 123 )
  {
    v21 = v144 + 1;
    v144 = v21;
    v141 = v21;
    v27 = sub_10038CCB(v139, v140, v145);
  }
  else
  {
    v27 = sub_10039DDB(v139, v140, v26, (int)&v141, v145);
    v21 = v141;
    v144 = v141;
  }
  v4 = v27;
  v140 = v27;
  if ( v27 != -1 )
  {
    v24 = v139;
    goto LABEL_78;
  }
LABEL_296:
  if ( v129 == 1 )
    sub_100282F6(v4, lpMem);
  v11 = v130;
  result = -1;
  if ( v4 != -1 || v130 || v148 )
LABEL_301:
    result = v11;
  if ( v119 )
    *(_DWORD *)(v118 + 112) &= 0xFFFFFFFDu;
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 10069CE0: using guessed type int dword_10069CE0[];
// 10038CED: using guessed type char var_24[11];

//----- (10039DDB) --------------------------------------------------------
int __usercall sub_10039DDB<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4, int a5)
{
  int v5; // eax@1

  do
  {
    ++*(_DWORD *)a4;
    v5 = sub_10038CCB(a1, a2, a5);
    a2 = v5;
  }
  while ( v5 != -1 && sub_1002E8A9(v5, a3, (unsigned __int8)v5) );
  return a2;
}

//----- (10039E09) --------------------------------------------------------
signed int __usercall sub_10039E09<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3, int a4)
{
  int v4; // edx@1
  int v5; // ecx@1
  int v6; // edi@1
  int v7; // esi@1
  signed int v8; // eax@1
  int v10; // ebx@6
  int v11; // eax@9
  int v12; // eax@12
  int v13; // ST0C_4@12
  int v14; // ST0C_4@13
  int v15; // edx@15
  int v16; // ecx@15
  void *v17; // ecx@15
  int v18; // eax@15
  int v19; // eax@16
  int v20; // ecx@20
  int v21; // eax@23
  int v22; // edx@23
  int v23; // eax@25

  v7 = a4;
  v8 = sub_1004494B(a1, a2, a4);
  v5 = *(_DWORD *)(v7 + 12);
  v6 = v8;
  if ( !(v5 & 0x82) )
  {
    *(_DWORD *)sub_1002F144(a1) = 9;
LABEL_3:
    *(_DWORD *)(v7 + 12) |= 0x20u;
    return -1;
  }
  if ( v5 & 0x40 )
  {
    *(_DWORD *)sub_1002F144(a1) = 34;
    goto LABEL_3;
  }
  v10 = 0;
  if ( v5 & 1 )
  {
    *(_DWORD *)(v7 + 4) = 0;
    if ( !(v5 & 0x10) )
    {
      *(_DWORD *)(v7 + 12) = v5 | 0x20;
      return -1;
    }
    v5 &= 0xFFFFFFFEu;
    *(_DWORD *)v7 = *(_DWORD *)(v7 + 8);
    *(_DWORD *)(v7 + 12) = v5;
  }
  v11 = *(_DWORD *)(v7 + 12) & 0xFFFFFFEF | 2;
  *(_DWORD *)(v7 + 12) = v11;
  *(_DWORD *)(v7 + 4) = 0;
  if ( !(v11 & 0x10C) )
  {
    if ( (void **)v7 != sub_1003D94D() + 8 && (void **)v7 != sub_1003D94D() + 16
      || (v12 = sub_10044B5A(0, v6, v6), v5 = v13, !v12) )
    {
      sub_10045627(v4, v5, 0, v7);
      v5 = v14;
    }
  }
  if ( *(_DWORD *)(v7 + 12) & 0x108 )
  {
    v15 = *(_DWORD *)(v7 + 8);
    v17 = *(void **)v7;
    *(_DWORD *)v7 = v15 + 1;
    v16 = (int)((char *)v17 - v15);
    v18 = *(_DWORD *)(v7 + 24) - 1;
    a4 = v16;
    *(_DWORD *)(v7 + 4) = v18;
    if ( v16 <= 0 )
    {
      if ( v6 == -1 || v6 == -2 )
        v20 = (int)&unk_10067A10;
      else
        v20 = dword_10069CE0[v6 >> 5] + ((v6 & 0x1F) << 6);
      if ( *(_BYTE *)(v20 + 4) & 0x20 )
      {
        sub_100454BA(v15, v20, 0, v6, 0i64, 2u);
        if ( (v22 & v21) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      sub_10044BAE(v15, v16, 0, v6, v6, (const void *)v15, v16);
      v10 = v19;
    }
    **(_BYTE **)(v7 + 8) = a3;
  }
  else
  {
    a4 = 1;
    sub_10044BAE(v4, v5, 0, v6, v6, &a3, 1);
    v10 = v23;
  }
  if ( v10 != a4 )
  {
LABEL_27:
    *(_DWORD *)(v7 + 12) |= 0x20u;
    return -1;
  }
  return a3;
}
// 10069CE0: using guessed type int dword_10069CE0[];

//----- (10039F56) --------------------------------------------------------
int __usercall sub_10039F56<eax>(int a1<ebx>, int (__cdecl *a2)(_DWORD, _DWORD, _DWORD, _DWORD), int a3, unsigned int a4, int a5, int a6, int a7)
{
  int result; // eax@2
  int v8; // ebx@8
  char v9; // sf@10
  char v10; // sf@14
  int v11; // [sp+4h] [bp-20h]@1
  unsigned int v12; // [sp+8h] [bp-1Ch]@1
  int v13; // [sp+Ch] [bp-18h]@8
  int v14; // [sp+10h] [bp-14h]@8
  int v15; // [sp+24h] [bp+0h]@2

  v11 = 0;
  memset(&v12, 0, 0x1Cu);
  if ( !a5 )
  {
    *(_DWORD *)sub_1002F144(a1) = 22;
    sub_10036C88(a1, (int)&v15);
    return -1;
  }
  if ( a4 && !a3 )
  {
    *(_DWORD *)sub_1002F144(a1) = 22;
    sub_10036C88(a1, 0);
    return -1;
  }
  v12 = 2147483647;
  if ( a4 <= 0x7FFFFFFF )
    v12 = a4;
  v14 = 66;
  v13 = a3;
  v11 = a3;
  result = a2(&v11, a5, a6, a7);
  v8 = result;
  if ( a3 )
  {
    if ( result >= 0 )
    {
      v9 = (signed int)(v12-- - 1) < 0;
      if ( !v9 )
      {
        *(_BYTE *)v11 = 0;
        return v8;
      }
      if ( sub_10039E09(result, a3, 0, (int)&v11) != -1 )
        return v8;
    }
    v10 = (signed int)v12 < 0;
    *(_BYTE *)(a3 + a4 - 1) = 0;
    result = !v10 - 2;
  }
  return result;
}

//----- (1003A01E) --------------------------------------------------------
int __usercall sub_1003A01E<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned int a4, int a5, int a6, int a7)
{
  int result; // eax@2

  if ( !a5 )
  {
    *(_DWORD *)sub_1002F144(a1) = 22;
    sub_10036C88(a1, a2);
    return -1;
  }
  if ( !a3 || !a4 )
  {
    *(_DWORD *)sub_1002F144(a1) = 22;
    goto LABEL_10;
  }
  result = sub_10039F56(a1, sub_1004566D, a3, a4, a5, a6, a7);
  if ( result < 0 )
    *(_BYTE *)a3 = 0;
  if ( result == -2 )
  {
    *(_DWORD *)sub_1002F144(a1) = 34;
LABEL_10:
    sub_10036C88(a1, a2);
    result = -1;
  }
  return result;
}

//----- (1003A093) --------------------------------------------------------
bool __cdecl sub_1003A093()
{
  hHeap = GetProcessHeap();
  return hHeap != 0;
}

//----- (1003A0A8) --------------------------------------------------------
void __cdecl sub_1003A0A8()
{
  hHeap = 0;
}

//----- (1003A0B0) --------------------------------------------------------
LONG __cdecl sub_1003A0B0(volatile LONG *lpAddend)
{
  volatile LONG *v1; // edi@1
  signed int v2; // eax@9
  volatile LONG **v3; // ebx@9
  signed int v5; // [sp+14h] [bp+8h]@9

  v1 = lpAddend;
  InterlockedIncrement(lpAddend);
  if ( lpAddend[30] )
    InterlockedIncrement((volatile LONG *)lpAddend[30]);
  if ( lpAddend[32] )
    InterlockedIncrement((volatile LONG *)lpAddend[32]);
  if ( lpAddend[31] )
    InterlockedIncrement((volatile LONG *)lpAddend[31]);
  if ( lpAddend[34] )
    InterlockedIncrement((volatile LONG *)lpAddend[34]);
  v2 = 6;
  v3 = (volatile LONG **)(lpAddend + 7);
  v5 = 6;
  do
  {
    if ( (_UNKNOWN *)*(v3 - 2) != &unk_100673AC )
    {
      if ( *v3 )
      {
        InterlockedIncrement(*v3);
        v2 = v5;
      }
    }
    if ( *(v3 - 3) )
    {
      if ( *(v3 - 1) )
      {
        InterlockedIncrement(*(v3 - 1));
        v2 = v5;
      }
    }
    v3 += 4;
    --v2;
    v5 = v2;
  }
  while ( v2 );
  return InterlockedIncrement((volatile LONG *)(v1[39] + 176));
}

//----- (1003A140) --------------------------------------------------------
void __cdecl sub_1003A140(LPVOID lpMem)
{
  void **v1; // eax@1
  void *v2; // esi@1
  int v3; // eax@3
  int v4; // eax@5
  int v5; // eax@8
  int v6; // eax@12
  int v7; // eax@15
  signed int v8; // eax@18
  int v9; // ebx@18
  LPVOID *v10; // edi@18
  int v11; // eax@25
  signed int v12; // [sp+14h] [bp+8h]@18

  v2 = lpMem;
  v1 = (void **)*((_DWORD *)lpMem + 33);
  if ( v1 )
  {
    if ( v1 != &off_10066C68 )
    {
      v3 = *((_DWORD *)lpMem + 30);
      if ( v3 )
      {
        if ( !*(_DWORD *)v3 )
        {
          v4 = *((_DWORD *)lpMem + 32);
          if ( v4 )
          {
            if ( !*(_DWORD *)v4 )
            {
              sub_100282F6(0, *((LPVOID *)lpMem + 32));
              sub_10046411(0, *((_DWORD *)lpMem + 33));
            }
          }
          v5 = *((_DWORD *)lpMem + 31);
          if ( v5 )
          {
            if ( !*(_DWORD *)v5 )
            {
              sub_100282F6(0, *((LPVOID *)lpMem + 31));
              sub_100468AF(0, *((_DWORD *)lpMem + 33));
            }
          }
          sub_100282F6(0, *((LPVOID *)lpMem + 30));
          sub_100282F6(0, *((LPVOID *)lpMem + 33));
        }
      }
    }
  }
  v6 = *((_DWORD *)lpMem + 34);
  if ( v6 )
  {
    if ( !*(_DWORD *)v6 )
    {
      sub_100282F6(0, (LPVOID)(*((_DWORD *)lpMem + 35) - 254));
      sub_100282F6(0, (LPVOID)(*((_DWORD *)lpMem + 37) - 128));
      sub_100282F6(0, (LPVOID)(*((_DWORD *)lpMem + 38) - 128));
      sub_100282F6(0, *((LPVOID *)lpMem + 34));
    }
  }
  v7 = *((_DWORD *)lpMem + 39);
  if ( (void **)v7 != &off_100673B0 )
  {
    if ( !*(_DWORD *)(v7 + 176) )
    {
      sub_10046B1E(0, *((_DWORD *)lpMem + 39));
      sub_100282F6(0, *((LPVOID *)lpMem + 39));
    }
  }
  v8 = 6;
  v9 = (int)((char *)lpMem + 160);
  v10 = (LPVOID *)((char *)lpMem + 28);
  v12 = 6;
  do
  {
    if ( *(v10 - 2) != &unk_100673AC )
    {
      if ( *v10 )
      {
        if ( !*(_DWORD *)*v10 )
        {
          sub_100282F6(v9, *v10);
          sub_100282F6(v9, *(LPVOID *)v9);
        }
      }
      v8 = v12;
    }
    if ( *(v10 - 3) )
    {
      v11 = (int)*(v10 - 1);
      if ( v11 )
      {
        if ( !*(_DWORD *)v11 )
          sub_100282F6(v9, *(v10 - 1));
      }
      v8 = v12;
    }
    v9 += 4;
    v10 += 4;
    --v8;
    v12 = v8;
  }
  while ( v8 );
  sub_100282F6(v9, v2);
}
// 10066C68: using guessed type void *off_10066C68;
// 100673B0: using guessed type void *off_100673B0;

//----- (1003A29A) --------------------------------------------------------
volatile LONG *__cdecl sub_1003A29A(volatile LONG *lpAddend)
{
  volatile LONG *v1; // esi@1
  signed int v2; // eax@10
  volatile LONG **v3; // ebx@10
  signed int v5; // [sp+Ch] [bp+8h]@10

  v1 = lpAddend;
  if ( lpAddend )
  {
    InterlockedDecrement(lpAddend);
    if ( lpAddend[30] )
      InterlockedDecrement((volatile LONG *)lpAddend[30]);
    if ( lpAddend[32] )
      InterlockedDecrement((volatile LONG *)lpAddend[32]);
    if ( lpAddend[31] )
      InterlockedDecrement((volatile LONG *)lpAddend[31]);
    if ( lpAddend[34] )
      InterlockedDecrement((volatile LONG *)lpAddend[34]);
    v2 = 6;
    v3 = (volatile LONG **)(lpAddend + 7);
    v5 = 6;
    do
    {
      if ( (_UNKNOWN *)*(v3 - 2) != &unk_100673AC )
      {
        if ( *v3 )
        {
          InterlockedDecrement(*v3);
          v2 = v5;
        }
      }
      if ( *(v3 - 3) )
      {
        if ( *(v3 - 1) )
        {
          InterlockedDecrement(*(v3 - 1));
          v2 = v5;
        }
      }
      v3 += 4;
      --v2;
      v5 = v2;
    }
    while ( v2 );
    InterlockedDecrement((volatile LONG *)(v1[39] + 176));
  }
  return v1;
}

//----- (1003A335) --------------------------------------------------------
void __usercall sub_1003A335(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // edx@1
  int v4; // esi@1
  int v5; // edx@3
  int v6; // ecx@3

  v2 = sub_10031BD7(a1, a2);
  v4 = v2;
  if ( dword_100675D4 & *(_DWORD *)(v2 + 112) && *(_DWORD *)(v2 + 108) )
  {
    if ( !*(_DWORD *)(sub_10031BD7(a1, a2) + 108) )
      sub_1003234D(v5, v6, a1, a2, 32);
  }
  else
  {
    sub_1002E493(v3, dword_100675D4, a1, a2, 12);
    sub_1003A3B1((volatile LONG **)(v4 + 108), off_10067514);
    sub_1002E5F7(12);
  }
}
// 100675D4: using guessed type int dword_100675D4;

//----- (1003A3B1) --------------------------------------------------------
volatile LONG *__cdecl sub_1003A3B1(volatile LONG **a1, volatile LONG *lpAddend)
{
  volatile LONG *v2; // esi@3
  volatile LONG *result; // eax@8

  if ( lpAddend && a1 )
  {
    v2 = *a1;
    if ( *a1 != lpAddend )
    {
      *a1 = lpAddend;
      sub_1003A0B0(lpAddend);
      if ( v2 )
      {
        sub_1003A29A(v2);
        if ( !*v2 )
        {
          if ( v2 != &dword_10067518 )
            sub_1003A140(v2);
        }
      }
    }
    result = lpAddend;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003A3FC) --------------------------------------------------------
signed int __usercall sub_1003A3FC<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6)
{
  int v6; // edx@1
  int v8; // esi@9
  int v9; // eax@11
  int v10; // ebx@14
  int v11; // edi@14
  __int16 v12; // ax@15
  __int16 v13; // ax@18
  char v14; // zf@23
  int v15; // [sp-8h] [bp-Ch]@14
  signed int v16; // [sp-4h] [bp-8h]@11
  int v17; // [sp-4h] [bp-8h]@14

  v6 = a6;
  if ( a6 )
  {
    if ( !a3 )
    {
LABEL_11:
      v9 = sub_1002F144(a1);
      v16 = 22;
LABEL_12:
      *(_DWORD *)v9 = v16;
      sub_10036C88(a1, a2);
      return v16;
    }
  }
  else
  {
    if ( !a3 )
    {
      if ( !a4 )
        return 0;
      goto LABEL_11;
    }
  }
  if ( !a4 )
    goto LABEL_11;
  if ( !a6 )
  {
    *(_WORD *)a3 = 0;
    return 0;
  }
  v8 = a5;
  if ( !a5 )
  {
    *(_WORD *)a3 = 0;
    goto LABEL_11;
  }
  v17 = a1;
  v15 = a2;
  v10 = a3;
  v11 = a4;
  if ( a6 == -1 )
  {
    do
    {
      v12 = *(_WORD *)v8;
      *(_WORD *)(a3 - a5 + v8) = *(_WORD *)v8;
      v8 += 2;
      if ( !v12 )
        break;
      --v11;
    }
    while ( v11 );
  }
  else
  {
    do
    {
      v13 = *(_WORD *)(a5 - a3 + v10);
      *(_WORD *)v10 = v13;
      v10 += 2;
      if ( !v13 )
        break;
      --v11;
      if ( !v11 )
        break;
      --v6;
    }
    while ( v6 );
    if ( !v6 )
      *(_WORD *)v10 = 0;
  }
  v14 = v11 == 0;
  a2 = v15;
  a1 = v17;
  if ( !v14 )
    return 0;
  if ( v6 != -1 )
  {
    *(_WORD *)a3 = 0;
    v9 = sub_1002F144(v17);
    v16 = 34;
    goto LABEL_12;
  }
  *(_WORD *)(a3 + 2 * a4 - 2) = 0;
  return 80;
}

//----- (1003A4BA) --------------------------------------------------------
int __usercall sub_1003A4BA<eax>(int a1<ebx>, int a2, int a3, char a4)
{
  int ebp0; // ebp@0
  char *v6; // [sp+0h] [bp-4h]@1

  v6 = &a4;
  sub_1003A5E8(a1, ebp0, a3, (int)&v6);
  return a2;
}

//----- (1003A4D8) --------------------------------------------------------
int __userpurge sub_1003A4D8<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, const void **a5)
{
  int v6; // esi@1
  int v7; // eax@1

  v6 = a2;
  v7 = sub_10027EB3(a1, a2, a3, a4, 40);
  *(_DWORD *)v6 = v7;
  sub_1002C950((void *)v7, *a5, 0x28u);
  return v6;
}

//----- (1003A4FE) --------------------------------------------------------
int __userpurge sub_1003A4FE<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_10055A28;
  return v4;
}
// 10055A28: using guessed type int (__stdcall *off_10055A28)(char);

//----- (1003A519) --------------------------------------------------------
int __userpurge sub_1003A519<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_10055A40;
  return v4;
}
// 10055A40: using guessed type int (__stdcall *off_10055A40)(char);

//----- (1003A534) --------------------------------------------------------
int __userpurge sub_1003A534<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_10055A34;
  return v4;
}
// 10055A34: using guessed type int (__stdcall *off_10055A34)(char);

//----- (1003A54F) --------------------------------------------------------
int __thiscall sub_1003A54F(LPVOID *this)
{
  return sub_1002404A(*this);
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1003A558) --------------------------------------------------------
void **__thiscall sub_1003A558(void **this, const void **a2)
{
  void **v3; // esi@1

  v3 = this;
  sub_1002C950(*this, *a2, 0x28u);
  return v3;
}

//----- (1003A576) --------------------------------------------------------
int __thiscall sub_1003A576(void *this, unsigned int a2)
{
  char v3; // al@3
  char v4; // [sp+0h] [bp-Ch]@3

  if ( a2 > 9 )
  {
    v3 = (unsigned int)sub_1003A710(a2);
    sub_10024974((int)&v4, v3);
    sub_1002D02B((int)&v4, (int)&unk_10060CF4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003A5AC);
  }
  return *(_DWORD *)(*(_DWORD *)this + 4 * a2);
}

//----- (1003A5AC) --------------------------------------------------------
char __thiscall sub_1003A5AC(void *this)
{
  void *v2; // esi@1
  int v3; // ST04_4@1
  int v4; // eax@1

  v2 = this;
  v3 = sub_1003A576(this, 1u);
  v4 = sub_1003A576(v2, 2u);
  return sub_1003A5CA(v4, v3);
}

//----- (1003A5CA) --------------------------------------------------------
char __cdecl sub_1003A5CA(unsigned int a1, unsigned int a2)
{
  return a2 == -1 || a1 == -1 || a2 >= a1;
}

//----- (1003A5E8) --------------------------------------------------------
int __userpurge sub_1003A5E8<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4)
{
  int v4; // ebx@1
  unsigned int v5; // esi@1
  int v6; // ecx@1
  int v7; // edi@1
  int v8; // edx@1
  int v9; // eax@3
  int v10; // ecx@3
  unsigned int v11; // edi@3
  int v12; // eax@3
  int i; // eax@4
  char v14; // al@4
  char v15; // al@7
  int v17; // [sp-8h] [bp-8h]@4

  sub_1002D121();
  v7 = v6;
  *(_DWORD *)(a2 - 24) = v6;
  v4 = sub_10027EB3(v8, v6, a1, v6, 40);
  v5 = 0;
  *(_DWORD *)(a2 - 28) = v4;
  *(_DWORD *)v7 = v4;
  *(_DWORD *)(a2 - 4) = 0;
  sub_1002C950((void *)v4, &unk_100675D8, 0x28u);
  while ( 1 )
  {
    if ( v5 < *(_DWORD *)(a2 + 8) )
    {
      v10 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)v10 += 4;
      v12 = *(_DWORD *)v10 + 4;
      v11 = *(_DWORD *)(*(_DWORD *)v10 - 4);
      *(_DWORD *)v10 = v12;
      v9 = *(_DWORD *)(v12 - 4);
      *(_DWORD *)(a2 - 20) = v9;
      if ( v11 > 9 )
      {
        v14 = (unsigned int)sub_1003A710(v11);
        sub_10024974(a2 - 40, v14);
        v17 = (int)&unk_10060CF4;
        i = a2 - 40;
        goto LABEL_5;
      }
      goto LABEL_6;
    }
    v11 = *(_DWORD *)(a2 - 24);
    if ( sub_1003A5AC(*(void **)(a2 - 24)) )
      break;
    sub_10024990(a2 - 64);
    v17 = (int)&unk_10060D64;
LABEL_5:
    for ( i = a2 - 64; ; i = a2 - 52 )
    {
      sub_1002D02B(v9, v17);
LABEL_6:
      if ( sub_1003A727(v11, v9) )
        break;
      v15 = (unsigned int)sub_1003A710(v11);
      sub_100249A2(a2 - 52, v15);
      v17 = (int)&unk_10060D2C;
    }
    *(_DWORD *)(v4 + 4 * v11) = *(_DWORD *)(a2 - 20);
    ++v5;
  }
  sub_1003A6C8((void *)v11);
  return sub_1002D086(52);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1003A6B9) --------------------------------------------------------
void __userpurge sub_1003A6B9(int a1<ebp>, int a2, int a3)
{
  sub_1002404A(*(LPVOID *)(a1 - 28));
  JUMPOUT(*(unsigned int *)loc_1003A655);
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1003A655: using guessed type int __stdcall loc_1003A655(int, int);

//----- (1003A6C8) --------------------------------------------------------
int __thiscall sub_1003A6C8(void *this)
{
  int result; // eax@1
  int v2; // edx@1
  void *v3; // edi@1
  int v4; // esi@1
  int v5; // ecx@2

  v3 = this;
  **(_DWORD **)this = 0;
  v2 = sub_10034C38();
  result = *(_DWORD *)v3;
  v4 = *(_DWORD *)(*(_DWORD *)v3 + 8);
  if ( v4 == -1 )
  {
    v5 = *(_DWORD *)(result + 4);
    if ( v5 == -1 )
    {
      *(_DWORD *)(result + 4) = v2;
      result = *(_DWORD *)v3;
      *(_DWORD *)(*(_DWORD *)v3 + 8) = v2;
    }
    else
    {
      if ( v5 >= (unsigned int)v2 )
        v5 = v2;
      *(_DWORD *)(result + 8) = v5;
    }
  }
  else
  {
    if ( *(_DWORD *)(result + 4) == -1 )
    {
      if ( v4 <= (unsigned int)v2 )
        v4 = v2;
      *(_DWORD *)(result + 4) = v4;
    }
  }
  return result;
}

//----- (1003A710) --------------------------------------------------------
char *__cdecl sub_1003A710(unsigned int a1)
{
  signed int v1; // eax@1

  v1 = a1;
  if ( a1 > 0xA )
    v1 = 10;
  return off_10067600[v1];
}
// 10067600: using guessed type char *off_10067600[11];

//----- (1003A727) --------------------------------------------------------
char __cdecl sub_1003A727(int a1, signed int a2)
{
  char v2; // cl@1
  char v3; // zf@2

  v2 = 1;
  switch ( a1 )
  {
    case 0:
      goto LABEL_2;
    case 1:
      if ( a2 && (unsigned int)a2 <= 0x7FFFFFFF )
        return v2;
      v3 = a2 == -1;
      goto LABEL_3;
    case 2:
      if ( (unsigned int)a2 <= 0x7FFFFFFF )
        return v2;
      v3 = a2 == -1;
      goto LABEL_3;
    case 3:
      if ( a2 )
        goto LABEL_17;
      goto LABEL_4;
    case 4:
    case 5:
LABEL_17:
      if ( (unsigned int)a2 > 0x7FFFFFFF )
        goto LABEL_4;
      return v2;
    case 6:
      if ( a2 >= -7 && a2 < 7 || a2 == 15 || a2 == -15 )
        return v2;
      v3 = a2 == 61440;
      goto LABEL_3;
    case 7:
      if ( !a2 )
        return v2;
      v3 = a2 == 1;
      goto LABEL_3;
    case 8:
      if ( a2 != 1 )
      {
LABEL_2:
        v3 = a2 == 0;
LABEL_3:
        if ( !v3 )
LABEL_4:
          v2 = 0;
      }
      break;
    case 9:
      if ( a2 )
        v2 = ((a2 != 1) - 1) & 1;
      break;
  }
  return v2;
}

//----- (1003A7E3) --------------------------------------------------------
int __thiscall sub_1003A7E3(void *this)
{
  void *v1; // esi@1
  int result; // eax@2
  char v3; // [sp-4h] [bp-14h]@2
  char v4; // [sp+4h] [bp-Ch]@6

  v1 = this;
  if ( !sub_1003A576(this, 2u) )
  {
    v3 = LOBYTE(off_10067608[0]);
LABEL_6:
    sub_100249A2((int)&v4, v3);
    sub_1002D02B((int)&v4, (int)&unk_10060D2C);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003A82C);
  }
  result = sub_1003A576(v1, 8u);
  if ( !result )
    goto LABEL_6;
  return result;
}
// 10067608: using guessed type char *off_10067608[9];

//----- (1003A82C) --------------------------------------------------------
int __fastcall sub_1003A82C(int a1, int a2, int a3)
{
  int v3; // eax@1
  signed int v4; // edi@1
  int v5; // esi@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // ecx@2
  void *v10; // ST00_4@6

  v5 = a1;
  v4 = 63;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 20) = a3;
  *(_DWORD *)(a1 + 8) = 63;
  *(_DWORD *)(a1 + 12) = sub_10021CF0(a2, a1, 0, 63, 256);
  v3 = sub_10021CF0(v6, v7, 0, 63, 512);
  if ( v3 )
  {
    v8 = v3;
    do
    {
      --v4;
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      v8 += 8;
    }
    while ( v4 >= 0 );
  }
  else
  {
    v3 = 0;
  }
  v10 = *(void **)(v5 + 12);
  *(_DWORD *)(v5 + 16) = v3;
  sub_10030CF0(v10, 0, 256);
  return v5;
}

//----- (1003A893) --------------------------------------------------------
int __fastcall sub_1003A893(int a1, int a2)
{
  int v3; // edi@1
  int v4; // esi@1

  v3 = a1;
  v4 = a1 + 120;
  *(_DWORD *)a1 = &off_10059B08;
  sub_1003A82C(a1 + 12, a2, a1 + 120);
  *(_DWORD *)(v3 + 36) = 0;
  *(_DWORD *)(v3 + 40) = 0;
  *(_DWORD *)(v3 + 60) = 0;
  *(_DWORD *)(v3 + 64) = 0;
  *(_DWORD *)v4 = 0;
  *(_DWORD *)(v3 + 136) = 0;
  *(_DWORD *)(v3 + 144) = 0;
  *(_DWORD *)(v3 + 148) = 0;
  *(_DWORD *)(v3 + 152) = 0;
  *(_DWORD *)(v3 + 156) = 0;
  *(_DWORD *)(v3 + 180) = 0;
  return v3;
}
// 10059B08: using guessed type int (__stdcall *off_10059B08)(char);

//----- (1003A8E4) --------------------------------------------------------
int __thiscall sub_1003A8E4(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002401B(*(LPVOID *)(this + 12));
  return sub_1002401B(*(LPVOID *)(v2 + 16));
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (1003A8FB) --------------------------------------------------------
int __thiscall sub_1003A8FB(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002401B(*(LPVOID *)(this + 12));
  return sub_1002401B(*(LPVOID *)(v2 + 8));
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (1003A912) --------------------------------------------------------
int __usercall sub_1003A912<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int v2; // esi@1
  char v3; // zf@1

  sub_1002D0B8();
  v2 = v1;
  *(_DWORD *)(a1 - 16) = v1;
  *(_DWORD *)v1 = &off_10059B08;
  v3 = *(_DWORD *)(v1 + 80) == 0;
  *(_DWORD *)(a1 - 4) = 1;
  if ( !v3 )
  {
    sub_1002BA1E(*(void **)(v1 + 80));
    *(_DWORD *)(v2 + 80) = 0;
  }
  sub_1002401B(*(LPVOID *)(v2 + 156));
  sub_1003A8E4(v2 + 12);
  return sub_1002D086(4);
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10059B08: using guessed type int (__stdcall *off_10059B08)(char);

//----- (1003A95D) --------------------------------------------------------
void *__thiscall sub_1003A95D(void *this, char a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1

  v3 = this;
  sub_1003A912(ebp0);
  if ( a2 & 1 )
    sub_1002404A(v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1003A97C) --------------------------------------------------------
char __thiscall sub_1003A97C(int this, unsigned int a2)
{
  char result; // al@1
  signed int v3; // edx@1
  int v4; // edi@1

  v3 = 1 << (a2 & 0x1F);
  v4 = 4 * (a2 >> 5);
  result = (v3 & *(_DWORD *)(v4 + *(_DWORD *)(this + 88))) != 0;
  if ( result )
  {
    _EDX = ~v3;
    _ECX = v4 + *(_DWORD *)(this + 88);
    __asm { lock and [ecx], edx }
  }
  return result;
}

//----- (1003A9B3) --------------------------------------------------------
int __thiscall sub_1003A9B3(void *this, int a2)
{
  void *v2; // edi@1
  int result; // eax@2

  v2 = this;
  if ( a2 )
  {
    sub_1003C6EE(a2);
    result = (*(int (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)a2 + 28))(a2, v2);
  }
  *((_DWORD *)v2 + 28) = a2;
  if ( a2 )
  {
    if ( *(_BYTE *)(a2 + 179) & 1 )
    {
      ++*((_DWORD *)v2 + 24);
      *(_BYTE *)(a2 + 179) &= 0xFEu;
    }
  }
  return result;
}

//----- (1003A9F0) --------------------------------------------------------
char __thiscall sub_1003A9F0(int this)
{
  char result; // al@2

  if ( *(_BYTE *)(this + 86) )
  {
    *(_BYTE *)(this + 86) = 0;
    result = 1;
  }
  else
  {
    result = sub_1003A97C(**(_DWORD **)(this + 68), *(_DWORD *)(this + 132));
  }
  return result;
}

//----- (1003AA34) --------------------------------------------------------
bool __cdecl sub_1003AA34(int a1)
{
  bool result; // eax@1

  result = sub_1002A7FD(*(_DWORD *)(a1 + 36));
  if ( !result )
  {
    sub_1003AB5D(*(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    *(_DWORD *)(a1 + 72) = 0;
  }
  return result;
}

//----- (1003AA40) --------------------------------------------------------
char __thiscall sub_1003AA40(int this, int a2)
{
  int v2; // edi@1
  int v3; // eax@2
  int v4; // edx@2
  char result; // al@5

  v2 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)this + 12) + 4 * *(_DWORD *)(this + 4));
  if ( v2 == 1
    || (v3 = *(_DWORD *)(*(_DWORD *)this + 12) + 4 * *(_DWORD *)(this + 4),
        v4 = *(_DWORD *)v3,
        *(_DWORD *)v3 = 1,
        v4 != v2) )
  {
    sub_1003AB81(*(_DWORD *)this);
    result = 0;
  }
  else
  {
    if ( a2 )
      *(_DWORD *)a2 = v2;
    result = 1;
  }
  return result;
}

//----- (1003AA87) --------------------------------------------------------
char __thiscall sub_1003AA87(int this, int a2, int a3, char a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  char v7; // al@3
  int v8; // edx@3
  char result; // al@6

  v6 = this;
  v4 = this + 4;
  v5 = *(_DWORD *)(this + 4);
  if ( !(v5 & a3) )
    goto LABEL_6;
  if ( a3 == 15 )
  {
    v8 = *(_DWORD *)v4;
    *(_DWORD *)v4 = 0;
    v7 = v8 != 0;
  }
  else
  {
    while ( 1 )
    {
      _ECX = 0;
      _EDX = v6 + 4;
      __asm { lock cmpxchg [edx], ecx }
      v8 = v5;
      if ( v5 == v5 )
        break;
      if ( !(v5 & a3) )
        goto LABEL_6;
    }
    v7 = 1;
  }
  if ( v7 )
  {
    if ( a4 )
    {
      _EDI = -1;
      _ECX = **(_DWORD **)(v6 + 68) + 428;
      _EAX = -1;
      __asm { lock xadd [ecx], eax }
      _ECX = *(_DWORD *)(v6 + 68) + 28;
      _EAX = -1;
      __asm { lock xadd [ecx], eax }
      if ( v8 == 4 || v8 == 8 )
      {
        _ECX = **(_DWORD **)(v6 + 68) + 432;
        _EAX = -1;
        __asm { lock xadd [ecx], eax }
        _ECX = *(_DWORD *)(v6 + 68) + 32;
        __asm { lock xadd [ecx], edi }
      }
    }
    result = 1;
    *(_DWORD *)a2 = v8;
    *(_DWORD *)(a2 + 4) = v6;
    *(_DWORD *)(v6 + 8) = v8;
  }
  else
  {
LABEL_6:
    result = 0;
  }
  return result;
}

//----- (1003AB2C) --------------------------------------------------------
signed int __thiscall sub_1003AB2C(int this, int a2)
{
  signed int result; // eax@1

  result = 1;
  if ( *(_DWORD *)((a2 << 7) + *(_DWORD *)(this + 92)) == 1 )
  {
    _EDX = 0;
    _ECX = (a2 << 7) + *(_DWORD *)(this + 92);
    __asm { lock cmpxchg [ecx], edx }
  }
  return result;
}

//----- (1003AB51) --------------------------------------------------------
int __thiscall sub_1003AB51(int this)
{
  return (*(int (**)(void))(**(_DWORD **)(this + 76) + 24))();
}

//----- (1003AB5D) --------------------------------------------------------
int __stdcall sub_1003AB5D(int a1)
{
  int v1; // esi@1
  int v2; // ecx@2
  int result; // eax@3

  v1 = a1;
  while ( v1 )
  {
    v2 = v1 - 176;
    v1 = *(_DWORD *)v1;
    if ( v2 )
      result = (**(int (__stdcall ***)(_DWORD))v2)(1);
  }
  return result;
}

//----- (1003AB81) --------------------------------------------------------
int __thiscall sub_1003AB81(int this)
{
  int result; // eax@1

  result = this + 20;
  _EDX = -1;
  __asm { lock xadd [eax], edx }
  if ( _ZF )
    result = sub_1002ADAD(this + 28, sub_1003B312, this, *(_DWORD *)this);
  return result;
}

//----- (1003AB9E) --------------------------------------------------------
int __thiscall sub_1003AB9E(int this)
{
  return (*(int (**)(void))(**(_DWORD **)(this + 76) + 28))();
}

//----- (1003ABAA) --------------------------------------------------------
char __thiscall sub_1003ABAA(int this, int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  char result; // al@3
  int v7; // eax@8

  v5 = this;
  v4 = **(_DWORD **)(this + 68);
  if ( a2 == 1 || a2 == 4 )
  {
    if ( sub_1002C1C3(v4, 1) )
    {
      v7 = a3;
      if ( !a3 )
        v7 = sub_1002A1DB(v4);
      result = (*(int (__thiscall **)(_DWORD, _DWORD, _DWORD))(*(_DWORD *)v5 + 28))(v5, v7, a4);
    }
    else
    {
      if ( a4 )
        sub_1002B4ED(v4, a4, 1);
      sub_1003AE27(v5, a2, 0);
      result = 0;
    }
  }
  else
  {
    (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(this + 76) + 20))(*(_DWORD *)(this + 116));
    result = 1;
  }
  return result;
}

//----- (1003AC1E) --------------------------------------------------------
char __thiscall sub_1003AC1E(int this, int a2)
{
  char result; // al@1
  int v3; // esi@1

  v3 = this;
  result = 0;
  if ( *(_DWORD *)this )
  {
    result = sub_1003ABAA(
               *(_DWORD *)(this + 4),
               *(_DWORD *)this,
               *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 4) + 68) + 4) + 8),
               a2);
    *(_DWORD *)v3 = 0;
  }
  return result;
}

//----- (1003AC49) --------------------------------------------------------
int __usercall sub_1003AC49<eax>(int a1<ecx>, int a2<ebp>, int a3<edi>)
{
  int v3; // esi@1

  v3 = a1;
  if ( !*(_DWORD *)(a1 + 80) )
    *(_DWORD *)(a1 + 80) = sub_1002A68A(a2, a3);
  return *(_DWORD *)(v3 + 80);
}

//----- (1003AC62) --------------------------------------------------------
int __thiscall sub_1003AC62(int this, int a2, int a3)
{
  int v3; // ebx@1
  int *v4; // eax@1
  int v5; // edi@1
  int v6; // eax@1
  int v7; // eax@1
  int v9; // eax@4
  int v10; // eax@4
  int v11; // esi@4
  int v12; // ST0C_4@4
  int v13; // eax@4
  int v14; // [sp-4h] [bp-20h]@2
  char v15; // [sp+Ch] [bp-10h]@4
  int v16; // [sp+24h] [bp+8h]@1

  v3 = this;
  *(_DWORD *)(this + 184) = 0;
  *(_DWORD *)(this + 108) = 0;
  *(_DWORD *)(this + 68) = a2;
  *(_DWORD *)(this + 204) = 1;
  *(_DWORD *)(this + 192) = 1;
  *(_DWORD *)(this + 72) = *(_DWORD *)(a2 + 4);
  v4 = *(int **)(this + 68);
  *(_WORD *)(this + 160) = 0;
  *(_DWORD *)(this + 76) = a3;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 92) = 0;
  *(_DWORD *)(this + 96) = 0;
  *(_DWORD *)(this + 100) = 0;
  *(_DWORD *)(this + 104) = 0;
  *(_DWORD *)(this + 112) = 0;
  *(_DWORD *)(this + 164) = 0;
  *(_DWORD *)(this + 180) = 0;
  *(_DWORD *)(this + 80) = 0;
  *(_WORD *)(this + 84) = 0;
  *(_BYTE *)(this + 86) = 1;
  v5 = *v4;
  v16 = *v4;
  *(_DWORD *)(this + 124) = (*(int (__thiscall **)(int))(*(_DWORD *)a3 + 16))(a3);
  v6 = (*(int (__thiscall **)(int))(*(_DWORD *)a3 + 4))(a3);
  *(_DWORD *)(v3 + 128) = v6;
  *(_DWORD *)(v3 + 132) = sub_1002A659(v5, v6);
  v7 = sub_10034C38();
  sub_1002A70E((void *)(v3 + 152), v7);
  sub_1003B431(v3 + 152);
  *(_DWORD *)(*(_DWORD *)(v3 + 156) + 4 * (*(_DWORD *)(v3 + 132) >> 5)) |= 1 << (*(_DWORD *)(v3 + 132) & 0x1F);
  if ( *(_DWORD *)(v16 + 12) )
    v14 = 2;
  else
    v14 = 1;
  sub_10047D39(v3 + 36, v3, v14);
  v9 = (*(int (**)(void))(***(_DWORD ***)(v3 + 68) + 4))();
  v10 = sub_1004474B((int)&v15, 3, *(_DWORD *)(v3 + 128), v9, v3);
  sub_10027C4E(v3 + 136, v10);
  v11 = *(_DWORD *)(v3 + 132);
  sub_1003ADE1(v16 + 72, *(_DWORD *)(v3 + 132));
  sub_1003AB2C(v16, v11);
  v12 = *(_DWORD *)(v3 + 124);
  v13 = (*(int (**)(void))(***(_DWORD ***)(v3 + 68) + 4))();
  return sub_1003B3A6(1, 4, v13, v12);
}

//----- (1003AD9F) --------------------------------------------------------
int __thiscall sub_1003AD9F(int this, unsigned int a2)
{
  int v2; // ebx@1
  int v3; // esi@1

  v2 = this;
  _ESI = -1;
  _EAX = *(_DWORD *)(this + 8) + 4 * a2;
  __asm { lock xadd [eax], esi }
  v3 = _ESI - 1;
  if ( !v3 )
  {
    sub_1003B241(this, a2);
    _EDX = ~(1 << (a2 & 0x1F));
    _ECX = *(_DWORD *)(v2 + 4) + 4 * (a2 >> 5);
    __asm { lock and [ecx], edx }
  }
  return v3;
}

//----- (1003ADE1) --------------------------------------------------------
int __thiscall sub_1003ADE1(int this, unsigned int a2)
{
  int v2; // esi@1
  int v13; // [sp+Ch] [bp-4h]@1

  v13 = this;
  _EAX = *(_DWORD *)(this + 8) + 4 * a2;
  _ESI = 1;
  __asm { lock xadd [eax], esi }
  v2 = _ESI + 1;
  if ( v2 == 1 )
  {
    sub_1003B1F9(this, a2);
    _EDI = 1 << (a2 & 0x1F);
    _ECX = *(_DWORD *)(v13 + 4) + 4 * (a2 >> 5);
    __asm { lock or [ecx], edi }
  }
  return v2;
}

//----- (1003AE27) --------------------------------------------------------
int __thiscall sub_1003AE27(int this, int a2, char a3)
{
  int v4; // edi@1
  int result; // eax@8

  v4 = this;
  _EBX = 1;
  *(_DWORD *)(this + 116) = *(_DWORD *)(this + 112);
  if ( a3 )
  {
    if ( a2 == 1 || a2 == 4 )
      sub_1002C1C3(**(_DWORD **)(this + 68), 0);
  }
  _ECX = **(_DWORD **)(v4 + 68) + 428;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  _ECX = *(_DWORD *)(v4 + 68) + 28;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  if ( a2 == 4 || a2 == 8 )
  {
    _ECX = **(_DWORD **)(v4 + 68) + 432;
    _EAX = 1;
    __asm { lock xadd [ecx], eax }
    _EAX = *(_DWORD *)(v4 + 68) + 32;
    __asm { lock xadd [eax], ebx }
  }
  result = v4 + 4;
  *(_DWORD *)(v4 + 4) = a2;
  return result;
}

//----- (1003AEA5) --------------------------------------------------------
char __thiscall sub_1003AEA5(int this)
{
  char result; // al@1
  int v2; // esi@1
  int v3; // ecx@5
  int v4; // ST00_4@5
  int v5; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@5

  v5 = 0;
  v2 = this;
  result = sub_1003AA87(this, (int)&v5, 15, 1);
  if ( result )
  {
    if ( v5 == 2 || v5 == 8 )
    {
      v3 = v6;
      v4 = v5;
      *(_BYTE *)(v2 + 161) = 1;
      result = sub_1003ABAA(v3, v4, 0, 0);
    }
    else
    {
      result = (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 12))(v2);
    }
  }
  else
  {
    *(_BYTE *)(v2 + 161) = 1;
  }
  return result;
}

//----- (1003AEF9) --------------------------------------------------------
int __thiscall sub_1003AEF9(int this)
{
  int v2; // esi@1
  int v3; // eax@1

  v2 = this;
  v3 = (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(**(_DWORD **)(this + 68) + 420) + 20))(*(_DWORD *)(this + 76));
  return sub_1003B6DA(*(void **)(v2 + 68), v3, 1);
}

//----- (1003AF1C) --------------------------------------------------------
signed int __thiscall sub_1003AF1C(int this)
{
  signed int v1; // ebx@1
  int v2; // edi@1
  int v3; // eax@1
  int v4; // edx@1
  int v5; // eax@1
  signed int result; // eax@5

  v3 = *(_DWORD *)(this + 12);
  v2 = *(_DWORD *)(this + 4) - 1;
  v4 = v2 & *(_DWORD *)(this + 8);
  *(_DWORD *)(this + 4) = v2;
  v5 = v3 + 4 * v4;
  v1 = *(_DWORD *)v5;
  *(_DWORD *)v5 = 0;
  if ( !v1 )
    *(_DWORD *)(this + 4) = v2 + 1;
  if ( !(v1 & 1) || (v1 &= 0xFFFFFFFEu, sub_1003AA40(*(_DWORD *)(this + 16) + 8 * (v2 & *(_DWORD *)(this + 8)), 0)) )
    result = v1;
  else
    result = 1;
  return result;
}

//----- (1003AF6A) --------------------------------------------------------
int __cdecl sub_1003AF6A()
{
  return 0;
}

//----- (1003AF6D) --------------------------------------------------------
char __thiscall sub_1003AF6D(void *ListHead, int a2, signed int a3, char a4)
{
  signed int v4; // edx@1
  int v6; // esi@1
  char result; // al@2
  int v8; // eax@3
  int v9; // ecx@3
  int v10; // edx@4
  int v11; // edi@4
  int v12; // edx@5
  PSINGLE_LIST_ENTRY v18; // eax@14
  int v19; // ST08_4@14

  v6 = (int)ListHead;
  v4 = a3 >> *((_DWORD *)ListHead + 11);
  _EBX = a3 & (*((_DWORD *)ListHead + 10) - 1);
  if ( v4 < *((_DWORD *)ListHead + 15) )
  {
    v9 = *((_DWORD *)ListHead + 14);
    v8 = *(_DWORD *)(v6 + 52);
    if ( v4 < v9 )
    {
      v11 = *(_DWORD *)(v8 + 4 * v4);
    }
    else
    {
      v10 = v4 - v9;
      v11 = *(_DWORD *)(v8 + 4 * v9 - 4);
      if ( v10 >= 0 )
      {
        v12 = v10 + 1;
        do
        {
          v11 = *(_DWORD *)(v11 + 4);
          --v12;
        }
        while ( v12 );
      }
    }
    _ECX = *(_DWORD *)v11 + 4 * _EBX;
    _EDX = 0;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 == a2 )
    {
      _ECX = v11 + 8;
      __asm { lock cmpxchg [ecx], ebx }
      if ( a4 )
      {
        if ( (signed int)QueryDepthSList((PSLIST_HEADER)v6) <= *(_DWORD *)(v6 + 68) )
        {
          InterlockedPushEntrySList((PSLIST_HEADER)v6, (PSINGLE_LIST_ENTRY)(a2 + 176));
        }
        else
        {
          InterlockedPushEntrySList((PSLIST_HEADER)(v6 + 8), (PSINGLE_LIST_ENTRY)(a2 + 176));
          if ( (signed int)QueryDepthSList((PSLIST_HEADER)(v6 + 8)) > *(_DWORD *)(v6 + 68) )
          {
            if ( !sub_1002A7FD(*(_DWORD *)(v6 + 36)) )
            {
              _EDX = 1;
              _ECX = v6 + 72;
              __asm { lock cmpxchg [ecx], edx }
              v18 = InterlockedFlushSList((PSLIST_HEADER)(v6 + 8));
              v19 = *(_DWORD *)(v6 + 36);
              *(_DWORD *)(v6 + 16) = v18;
              sub_1002ADAD(v6 + 20, (int (__cdecl *)(_DWORD))sub_1003AA34, v6, v19);
            }
          }
        }
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003B068) --------------------------------------------------------
char __thiscall sub_1003B068(int this)
{
  int v2; // edi@1
  int v16; // ecx@5
  int v17; // ebx@6
  int v18; // edi@9
  int v19; // esi@10
  int v20; // esi@15
  int v21; // eax@15
  int v22; // ecx@15
  int v23; // eax@15
  int v24; // ecx@15
  int v25; // eax@15
  int v27; // ecx@17
  char v28; // [sp-10h] [bp-24h]@10
  int v29; // [sp-Ch] [bp-20h]@10
  int v30; // [sp-8h] [bp-1Ch]@10
  int v31; // [sp-4h] [bp-18h]@10
  int v32; // [sp+Ch] [bp-8h]@1
  int v33; // [sp+10h] [bp-4h]@5

  v2 = this;
  v32 = this;
  sub_1002B879(**(_DWORD **)(this + 68), this + 192);
  sub_1003AD9F(**(_DWORD **)(v2 + 68) + 48, *(_DWORD *)(v2 + 132));
  _EDX = -1;
  _ECX = *(_DWORD *)(v2 + 68) + 36;
  _EAX = -1;
  __asm { lock xadd [ecx], eax }
  if ( !*(_BYTE *)(v2 + 160) )
  {
    _EAX = **(_DWORD **)(v2 + 68) + 20;
    __asm { lock xadd [eax], edx }
  }
  sub_1003B1BF(**(void ***)(v2 + 68), v2);
  if ( !*(_BYTE *)(v2 + 84) )
    sub_1003AD9F(**(_DWORD **)(v2 + 68) + 72, *(_DWORD *)(v2 + 132));
  *(_DWORD *)(v2 + 112) = 0;
  v16 = *(_DWORD *)(v2 + 16) - *(_DWORD *)(v2 + 12);
  v33 = v2 + 12;
  if ( v16 <= 0 )
    v17 = 0;
  else
    v17 = sub_1003AF1C(v2 + 12);
  if ( v17 )
  {
    v18 = v33;
    do
    {
      v19 = sub_100349ED(v17 + 4);
      sub_10027C4E((int)&v28, v19 + 12);
      sub_10037FD0((void *)v19, v17, v28, v29, v30, v31);
      if ( *(_DWORD *)(v18 + 4) - *(_DWORD *)v18 <= 0 )
        v17 = 0;
      else
        v17 = sub_1003AF1C(v18);
    }
    while ( v17 );
    v2 = v32;
  }
  v20 = **(_DWORD **)(v2 + 76);
  v21 = (*(int (**)(void))(***(_DWORD ***)(v2 + 68) + 52))();
  v22 = *(_DWORD *)(v2 + 76);
  v31 = v21;
  (*(void (__thiscall **)(int))(v20 + 8))(v22);
  v23 = *(_DWORD *)(v2 + 68);
  *(_DWORD *)(v2 + 76) = 0;
  v24 = *(_DWORD *)v23;
  v30 = *(_DWORD *)(v2 + 124);
  v25 = (*(int (__stdcall **)(int))(*(_DWORD *)v24 + 4))(v30);
  sub_1003B3A6(2, 4, v25, v31);
  if ( *(_DWORD *)(v2 + 80) )
  {
    v31 = *(_DWORD *)(v2 + 80);
    sub_1002BA1E((void *)v31);
    *(_DWORD *)(v2 + 80) = 0;
  }
  v27 = *(_DWORD *)(v2 + 68);
  v31 = 1;
  v30 = *(_DWORD *)(v2 + 88);
  return sub_1003AF6D((void *)(v27 + 56), v2, v30, 1);
}

//----- (1003B1AB) --------------------------------------------------------
char __thiscall sub_1003B1AB(int this)
{
  return sub_1002AEB0(**(_DWORD **)(this + 68), this + 180);
}

//----- (1003B1BF) --------------------------------------------------------
int __thiscall sub_1003B1BF(void *this, int a2)
{
  int result; // eax@1
  int v3; // esi@1
  void *v5; // edi@1

  v3 = a2;
  _EDX = *(_DWORD *)(a2 + 92) - *(_DWORD *)(a2 + 100);
  v5 = this;
  *(_DWORD *)(a2 + 100) = *(_DWORD *)(a2 + 92);
  _EAX = (int)((char *)this + 436);
  __asm { lock xadd [eax], edx }
  _ECX = *(_DWORD *)(v3 + 96) - *(_DWORD *)(v3 + 104);
  *(_DWORD *)(v3 + 104) = *(_DWORD *)(v3 + 96);
  result = (int)((char *)v5 + 440);
  __asm { lock xadd [eax], ecx }
  return result;
}

//----- (1003B1F9) --------------------------------------------------------
int __thiscall sub_1003B1F9(int this, unsigned int a2)
{
  int result; // eax@1
  int v3; // ebx@1
  signed int v4; // edi@1
  char v5; // [sp+Ch] [bp-10h]@3
  int v6; // [sp+14h] [bp-8h]@2
  void (__cdecl *v7)(); // [sp+18h] [bp-4h]@2

  v3 = *(_DWORD *)(this + 4);
  v4 = 1 << (a2 & 0x1F);
  result = *(_DWORD *)(v3 + 4 * (a2 >> 5));
  if ( result & v4 )
  {
    v6 = 0;
    v7 = sub_1002C630;
    while ( 1 )
    {
      result = *(_DWORD *)(v3 + 4 * (a2 >> 5));
      if ( !(result & v4) )
        break;
      sub_1001FF20((int)&v5);
    }
  }
  return result;
}

//----- (1003B241) --------------------------------------------------------
int __thiscall sub_1003B241(int this, unsigned int a2)
{
  int result; // eax@1
  int v3; // ebx@1
  signed int v4; // edi@1
  char v5; // [sp+Ch] [bp-10h]@3
  int v6; // [sp+14h] [bp-8h]@2
  void (__cdecl *v7)(); // [sp+18h] [bp-4h]@2

  v3 = *(_DWORD *)(this + 4);
  v4 = 1 << (a2 & 0x1F);
  result = *(_DWORD *)(v3 + 4 * (a2 >> 5));
  if ( !(result & v4) )
  {
    v6 = 0;
    v7 = sub_1002C630;
    while ( 1 )
    {
      result = *(_DWORD *)(v3 + 4 * (a2 >> 5));
      if ( result & v4 )
        break;
      sub_1001FF20((int)&v5);
    }
  }
  return result;
}

//----- (1003B289) --------------------------------------------------------
char __thiscall sub_1003B289(int this, int a2, int a3)
{
  int v3; // esi@1
  int v4; // edi@4
  char result; // al@9
  char v6; // [sp+Ch] [bp-10h]@3
  int v7; // [sp+14h] [bp-8h]@2
  void (__cdecl *v8)(); // [sp+18h] [bp-4h]@2

  v3 = this;
  if ( *(_DWORD *)(this + 112) )
  {
    v7 = 0;
    v8 = sub_1002C630;
    do
      sub_1001FF20((int)&v6);
    while ( *(_DWORD *)(v3 + 112) );
  }
  v4 = a3;
  if ( a3 )
  {
    if ( !*(_DWORD *)(a3 + 28) )
      sub_1003C55C(a3, a2, 0, 0);
  }
  else
  {
    v4 = sub_10038404((void *)a2, 0, 0);
  }
  if ( v4 )
  {
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 16))(v3, v4);
    (*(void (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(v3 + 76) + 20))(*(_DWORD *)(v3 + 76), *(_DWORD *)(v3 + 112));
    result = 1;
  }
  else
  {
    sub_1003AE27(v3, 4, 1);
    sub_10029C9A(**(_DWORD **)(v3 + 68));
    result = 0;
  }
  return result;
}

//----- (1003B312) --------------------------------------------------------
int __cdecl sub_1003B312(int a1)
{
  int result; // eax@2

  if ( a1 )
  {
    sub_1003A8FB(a1);
    result = sub_1002404A((LPVOID)a1);
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1003B32B) --------------------------------------------------------
int __cdecl sub_1003B32B(char a1, char a2, int a3, int a4)
{
  int v4; // ebx@1
  int result; // eax@2
  __int16 v6; // [sp+4h] [bp-40h]@2
  char v7; // [sp+6h] [bp-3Eh]@2
  char v8; // [sp+8h] [bp-3Ch]@2
  char v9; // [sp+9h] [bp-3Bh]@2
  int v10; // [sp+1Ch] [bp-28h]@2
  int v11; // [sp+20h] [bp-24h]@2
  int v12; // [sp+24h] [bp-20h]@2
  int v13; // [sp+28h] [bp-1Ch]@2
  int v14; // [sp+30h] [bp-14h]@2
  int v15; // [sp+34h] [bp-10h]@2
  int v16; // [sp+38h] [bp-Ch]@2

  v4 = dword_100693F8;
  if ( dword_100693F8 )
  {
    sub_10030CF0(&v7, 0, 62);
    v14 = 131072;
    v6 = 64;
    v8 = a1;
    v9 = a2;
    v10 = dword_1005BFB0[0];
    v11 = dword_1005BFB0[1];
    v12 = dword_1005BFB0[2];
    v13 = dword_1005BFB0[3];
    v16 = a3;
    v15 = a4;
    result = sub_10028A7A(v4, dword_100693F0, dword_100693F4, (int)&v6);
  }
  return result;
}
// 100693F0: using guessed type int dword_100693F0;
// 100693F4: using guessed type int dword_100693F4;
// 100693F8: using guessed type int dword_100693F8;

//----- (1003B39C) --------------------------------------------------------
int __stdcall sub_1003B39C(int a1)
{
  return a1;
}

//----- (1003B3A6) --------------------------------------------------------
int __stdcall sub_1003B3A6(char a1, char a2, int a3, int a4)
{
  int result; // eax@2

  if ( a2 <= (unsigned __int8)byte_100693EC )
  {
    result = dword_100693E8;
    if ( dword_100693E8 & 4 )
      result = sub_1003B32B(a1, a2, a3, a4);
  }
  return result;
}
// 100693E8: using guessed type int dword_100693E8;
// 100693EC: using guessed type char byte_100693EC;

//----- (1003B3D3) --------------------------------------------------------
char __thiscall sub_1003B3D3(int this, char a2, char a3)
{
  int v3; // eax@1
  int v4; // edi@1
  int v5; // esi@3
  unsigned int v6; // ST00_4@3
  char result; // al@6
  int v8; // [sp+8h] [bp-4h]@1

  v4 = this;
  v3 = **(_DWORD **)(this + 68);
  v8 = **(_DWORD **)(this + 68);
  if ( *(_BYTE *)(this + 84) )
  {
    if ( !a2 )
    {
      v5 = *(_DWORD *)(this + 132);
      v6 = *(_DWORD *)(this + 132);
      *(_BYTE *)(this + 86) = 1;
      sub_1003ADE1(v3 + 72, v6);
      sub_1003AB2C(v8, v5);
    }
  }
  else
  {
    if ( a2 )
      sub_1003AD9F(v3 + 72, *(_DWORD *)(this + 132));
  }
  result = a3;
  *(_BYTE *)(v4 + 84) = a2;
  *(_BYTE *)(v4 + 85) = a3;
  return result;
}

//----- (1003B431) --------------------------------------------------------
int __thiscall sub_1003B431(int this)
{
  unsigned int v1; // edx@1
  unsigned int v2; // esi@1
  int result; // eax@2

  v1 = (unsigned int)(*(_DWORD *)this + 31) >> 5;
  v2 = 0;
  if ( v1 )
  {
    do
    {
      result = *(_DWORD *)(this + 4);
      *(_DWORD *)(result + 4 * v2++) = 0;
    }
    while ( v2 < v1 );
  }
  return result;
}

//----- (1003B44E) --------------------------------------------------------
int __userpurge sub_1003B44E<eax>(int a1<ebp>, int a2, int a3, int a4)
{
  int v5; // ecx@1
  int v6; // edi@1
  int *v7; // esi@1
  int v8; // ST08_4@1
  int v9; // eax@1
  int v10; // ST00_4@1
  int v11; // ecx@1

  sub_1002D0B8();
  v6 = v5;
  *(_DWORD *)(a1 - 16) = v5;
  v7 = *(int **)(a1 + 16);
  v8 = *(_DWORD *)(a1 + 8);
  v5 += 8;
  *(_DWORD *)(v6 + 4) = v7;
  *(_DWORD *)v5 = 0;
  *(_DWORD *)(v5 + 4) = 0;
  sub_10029BCB(v5, v6, v8);
  *(_DWORD *)(a1 - 4) = 0;
  sub_10028D9E(v6 + 16, 0, v6, 0x1001u);
  v9 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(v6 + 28) = 0;
  *(_DWORD *)(v6 + 32) = 0;
  *(_DWORD *)(v6 + 36) = 0;
  *(_DWORD *)(v6 + 40) = 0;
  *(_DWORD *)(v6 + 44) = v9;
  v10 = *v7;
  *(_BYTE *)(a1 - 4) = 1;
  sub_100377ED((void *)(v6 + 56), v10, 256, 2147483647);
  v11 = *(_DWORD *)(v6 + 4);
  *(_DWORD *)v6 = *(_DWORD *)v11;
  *(_DWORD *)(v6 + 48) = *(_DWORD *)(v11 + 184);
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1003B4CB) --------------------------------------------------------
int __thiscall sub_1003B4CB(PSLIST_HEADER ListHead)
{
  int v1; // ebx@1
  PSLIST_HEADER v2; // edi@1
  int v3; // eax@1
  int v4; // eax@1
  int i; // esi@2
  int v6; // ecx@3
  int v7; // esi@6

  v2 = ListHead;
  v3 = (int)InterlockedFlushSList(ListHead);
  sub_1003AB5D(v3);
  v4 = (int)InterlockedFlushSList(v2 + 1);
  sub_1003AB5D(v4);
  sub_1003AB5D(LODWORD(v2[2].Alignment));
  v1 = LODWORD(v2[6].Alignment);
  if ( v1 )
  {
    do
    {
      for ( i = 0; i < LODWORD(v2[5].Alignment); ++i )
      {
        v6 = *(_DWORD *)(*(_DWORD *)v1 + 4 * i);
        if ( v6 )
          (**(void (__stdcall ***)(_DWORD))v6)(1);
      }
      v7 = *(_DWORD *)(v1 + 4);
      sub_1002401B(*(LPVOID *)v1);
      sub_1002404A((LPVOID)v1);
      v1 = v7;
    }
    while ( v7 );
  }
  return sub_1002401B(HIDWORD(v2[6].Alignment));
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1003B541) --------------------------------------------------------
int __usercall sub_1003B541<eax>(int a1<ebp>)
{
  int v2; // ecx@1
  int v3; // edi@1

  sub_1002D0B8();
  v3 = v2;
  *(_DWORD *)(a1 - 16) = v2;
  *(_DWORD *)(a1 - 4) = 1;
  sub_1003B4CB((PSLIST_HEADER)(v2 + 56));
  sub_1002C2C0(v3 + 16);
  sub_1002401B(*(LPVOID *)(v3 + 24));
  sub_1002401B(*(LPVOID *)(v3 + 12));
  return sub_1002D086(4);
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1003B581) --------------------------------------------------------
int __thiscall sub_1003B581(int this, int a2)
{
  signed int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // edx@3
  int v12; // ecx@11
  signed __int64 v15; // qax@11
  signed int v16; // ST0C_4@11
  int v17; // edx@11
  int v18; // ecx@11
  int v19; // eax@12
  int v28; // edx@17
  char v30; // [sp+Ch] [bp-20h]@22
  int v31; // [sp+14h] [bp-18h]@21
  BOOL (__cdecl *v32)(); // [sp+18h] [bp-14h]@21
  int v33; // [sp+1Ch] [bp-10h]@5
  int v34; // [sp+20h] [bp-Ch]@2
  int v35; // [sp+24h] [bp-8h]@1
  char v36; // [sp+2Bh] [bp-1h]@1

  v5 = this;
  v3 = *(_DWORD *)(this + 48);
  v36 = 0;
  v4 = 0;
  v35 = v3;
  v2 = 4;
  do
  {
    _EBX = v3 + 8;
    v34 = v3 + 8;
    if ( *(_DWORD *)(v3 + 8) >= -1 )
    {
      _EBX = *(_DWORD *)v3;
      v7 = 0;
      if ( *(_DWORD *)(v5 + 40) <= 0 )
      {
LABEL_7:
        _EBX = v34;
      }
      else
      {
        while ( *(_DWORD *)_EBX )
        {
          ++v7;
          _EBX += v2;
          if ( v7 >= *(_DWORD *)(v5 + 40) )
            goto LABEL_7;
        }
        _ECX = a2;
        *(_DWORD *)(a2 + 88) = v7 + v4;
        v33 = *(_DWORD *)(v5 + 64);
        __asm { lock cmpxchg [ebx], ecx }
        v4 += v7;
        v36 = 1;
        if ( v4 >= v33 )
        {
          _EAX = v5 + 64;
          _ECX = 1;
          __asm { lock xadd [eax], ecx }
        }
        _EBX = v34;
        _ECX = -1;
        __asm { lock cmpxchg [ebx], ecx }
      }
      v3 = v35;
    }
    if ( !v36 )
    {
      _ECX = -2;
      __asm { lock cmpxchg [ebx], ecx }
      v4 += *(_DWORD *)(v5 + 40);
      _EBX = v3 + 4;
      if ( !*(_DWORD *)(v3 + 4) )
      {
        _ECX = 1;
        __asm { lock cmpxchg [ebx], ecx }
        _ECX = 0;
        v15 = 4i64 * *(_DWORD *)(v5 + 40);
        __asm { seto    cl }
        v16 = 4 * *(_DWORD *)(v5 + 40);
        v33 = sub_10021CF0(SHIDWORD(v15), v15 | -_ECX, _EBX, v4, v15 | -_ECX);
        sub_10030CF0((void *)v33, 0, v16);
        v12 = sub_10027EB3(v17, v18, _EBX, v4, 12);
        if ( v12 )
        {
          v19 = v33;
          *(_DWORD *)(v12 + 4) = 0;
          *(_DWORD *)(v12 + 8) = -1;
          *(_DWORD *)v12 = v19;
        }
        else
        {
          v12 = 0;
        }
        v28 = *(_DWORD *)(v5 + 60);
        if ( v28 < *(_DWORD *)(v5 + 56) )
        {
          *(_DWORD *)(*(_DWORD *)(v5 + 52) + 4 * v28) = v12;
          ++*(_DWORD *)(v5 + 60);
        }
        *(_DWORD *)_EBX = v12;
        v3 = v35;
      }
      if ( *(_DWORD *)_EBX == 1 )
      {
        v31 = 0;
        v32 = sub_1002C66E;
        do
          sub_1001FF20((int)&v30);
        while ( *(_DWORD *)_EBX == 1 );
        v3 = v35;
      }
    }
    v3 = *(_DWORD *)(v3 + 4);
    v35 = v3;
    v2 = 4;
  }
  while ( !v36 );
  return v4;
}

//----- (1003B6DA) --------------------------------------------------------
int __thiscall sub_1003B6DA(void *this, int a2, char a3)
{
  PSINGLE_LIST_ENTRY v3; // eax@1
  int v4; // ebx@1
  int *v5; // edi@1
  int v6; // esi@2
  int v14; // ecx@11

  v5 = (int *)this;
  v4 = (int)sub_10029DCE();
  v3 = InterlockedPopEntrySList((PSLIST_HEADER)v5 + 7);
  if ( v3 && (v6 = (int)&v3[-44], v3 != (PSINGLE_LIST_ENTRY)176) )
    (*(void (__thiscall **)(int, int *, int))(*(_DWORD *)v6 + 24))(v6, v5, a2);
  else
    v6 = (*(int (__stdcall **)(int *, int))(*(_DWORD *)*v5 + 92))(v5, a2);
  if ( a3 )
  {
    *(_BYTE *)(v6 + 160) = 1;
    *(_DWORD *)(v6 + 164) = v4 - 4;
    *(_DWORD *)(v4 - 4 + 164) = v6;
  }
  _EAX = (int)(v5 + 9);
  _ECX = 1;
  __asm { lock xadd [eax], ecx }
  sub_1003ADE1(*v5 + 48, *(_DWORD *)(v6 + 132));
  if ( *(_DWORD *)(*v5 + 428) != *(_DWORD *)(*v5 + 432) || *(_DWORD *)(*v5 + 20) <= 0 )
  {
    sub_1003B581((int)(v5 + 14), v6);
    sub_1003AE27(v6, 1, 0);
  }
  else
  {
    sub_1003B581((int)(v5 + 14), v6);
    if ( sub_1002C1C3(*v5, 1) )
    {
      if ( v4 )
        v14 = sub_100349ED(v4);
      else
        v14 = *(_DWORD *)(v5[1] + 8);
      (*(void (__thiscall **)(int, int, _DWORD))(*(_DWORD *)v6 + 28))(v6, v14, 0);
    }
  }
  return v6;
}

//----- (1003B7C3) --------------------------------------------------------
int __thiscall sub_1003B7C3(int this, int a2)
{
  signed int v2; // edi@1
  signed int v3; // esi@1
  int v4; // eax@2
  int result; // eax@3
  int i; // [sp+Ch] [bp-4h]@2

  v2 = *(_DWORD *)(this + 120);
  v3 = 0;
  if ( v2 <= 0 )
  {
LABEL_7:
    result = 0;
  }
  else
  {
    v4 = this + 56;
    for ( i = this + 56; ; v4 = i )
    {
      result = sub_10037C97(v4, v3);
      if ( result )
      {
        if ( *(_DWORD *)(result + 76) == a2 )
          break;
      }
      ++v3;
      if ( v3 >= v2 )
        goto LABEL_7;
    }
  }
  return result;
}

//----- (1003B800) --------------------------------------------------------
int __thiscall sub_1003B800(void *this, int a2)
{
  void *v2; // ebx@1
  int result; // eax@2
  signed int v4; // esi@5

  v2 = this;
  if ( (*(_DWORD *)a2 & 0xFFFFFFF) == 3 )
  {
    if ( *(_DWORD *)(a2 + 4) == *(_DWORD *)(*(_DWORD *)this + 372) )
    {
      result = *(_DWORD *)(a2 + 12);
    }
    else
    {
      v4 = 0;
      if ( *((_DWORD *)this + 30) <= 0 )
      {
LABEL_9:
        result = 0;
      }
      else
      {
        while ( 1 )
        {
          result = sub_10037C97((int)((char *)v2 + 56), v4);
          if ( result )
          {
            if ( *(_DWORD *)(result + 128) == *(_DWORD *)(a2 + 8) )
              break;
          }
          ++v4;
          if ( v4 >= *((_DWORD *)v2 + 30) )
            goto LABEL_9;
        }
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003B85D) --------------------------------------------------------
char __thiscall sub_1003B85D(void *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  char v7; // bl@1
  void *v8; // esi@1
  int v9; // eax@2
  signed int v10; // edi@4
  int v11; // eax@5

  v7 = 1;
  v8 = this;
  if ( (a3 & 0xFFFFFFF) != 3 || (v9 = sub_1003B800(this, (int)&a3), !v9) || !sub_1003AA87(v9, a2, a7, 1) )
  {
    v10 = 0;
    if ( *((_DWORD *)v8 + 30) <= 0 )
    {
LABEL_8:
      v7 = 0;
    }
    else
    {
      while ( 1 )
      {
        v11 = sub_10037C97((int)((char *)v8 + 56), v10);
        if ( v11 )
        {
          if ( sub_1003AA87(v11, a2, a7, 1) )
            break;
        }
        ++v10;
        if ( v10 >= *((_DWORD *)v8 + 30) )
          goto LABEL_8;
      }
    }
  }
  return v7;
}

//----- (1003B8CD) --------------------------------------------------------
int __thiscall sub_1003B8CD(void *this, int a2)
{
  void *v3; // esi@1
  int v4; // ST0C_4@1
  int v5; // eax@1

  v3 = this;
  v4 = (int)this;
  v5 = (*(int (**)(void))(**(_DWORD **)this + 4))();
  sub_1004474B(a2, 2, *((_DWORD *)v3 + 12), v5, v4);
  return a2;
}

//----- (1003B8F1) --------------------------------------------------------
int __userpurge sub_1003B8F1<eax>(int a1<ebp>, int a2)
{
  int v3; // ecx@1
  void *v4; // edi@1
  void *v5; // esi@1
  int v6; // ST00_4@1

  sub_1002D0B8();
  v4 = (void *)v3;
  v5 = *(void **)(v3 + 20);
  *(_DWORD *)(a1 - 16) = v5;
  sub_1002C615(v5);
  v6 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  sub_1003B931(v4, v6);
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002C625(v5);
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1003B931) --------------------------------------------------------
int __thiscall sub_1003B931(void *this, char a2)
{
  void *i; // esi@1
  int v3; // ecx@2
  int v4; // edi@2
  int v5; // ebx@5
  int v6; // eax@5

  for ( i = this; ; *(_DWORD *)i = v4 + 1 )
  {
    if ( *(_DWORD *)i >= *((_DWORD *)i + 1)
      || (v4 = *(_DWORD *)i, v3 = *(_DWORD *)i & *((_DWORD *)i + 2), *(_BYTE *)(*((_DWORD *)i + 3) + 4 * v3) & 1)
      && !a2
      && sub_10037457((void *)(*((_DWORD *)i + 4) + 8 * v3)) )
      return 0;
    v6 = *((_DWORD *)i + 3) + 4 * (*((_DWORD *)i + 2) & v4);
    v5 = *(_DWORD *)v6;
    *(_DWORD *)v6 = 0;
    if ( v5 & 1 )
    {
      v5 &= 0xFFFFFFFEu;
      if ( !sub_1003AA40(*((_DWORD *)i + 4) + 8 * (*((_DWORD *)i + 2) & v4), 0) )
        continue;
    }
    break;
  }
  if ( v5 )
    *(_DWORD *)i = v4 + 1;
  return v5;
}

//----- (1003B9AF) --------------------------------------------------------
void *__thiscall sub_1003B9AF(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v4; // edi@1

  v4 = this;
  *(_DWORD *)this = off_10059B30;
  sub_100269FC(0, ebp0, a2, 0);
  *((_BYTE *)v4 + 179) &= 0xFCu;
  *(_DWORD *)v4 = off_10059B48;
  *((_DWORD *)v4 + 1) = off_10059B74;
  *((_DWORD *)v4 + 39) = 0;
  *((_DWORD *)v4 + 40) = 0;
  *((_DWORD *)v4 + 41) = 0;
  *((_DWORD *)v4 + 42) = 0;
  *((_DWORD *)v4 + 43) = 0;
  *((_BYTE *)v4 + 176) = 0;
  *((_BYTE *)v4 + 178) = 0;
  *((_DWORD *)v4 + 57) = 0;
  *((_DWORD *)v4 + 7) = 0;
  *((_BYTE *)v4 + 236) = 1;
  return v4;
}
// 10059B30: using guessed type int (*off_10059B30[5])();
// 10059B48: using guessed type int (*off_10059B48[3])();
// 10059B74: using guessed type int (*off_10059B74[5])();

//----- (1003BA22) --------------------------------------------------------
int __userpurge sub_1003BA22<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_10055A10;
  return v4;
}
// 10055A10: using guessed type int (__stdcall *off_10055A10)(char);

//----- (1003BA3D) --------------------------------------------------------
int __userpurge sub_1003BA3D<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_10055A04;
  return v4;
}
// 10055A04: using guessed type int (__stdcall *off_10055A04)(char);

//----- (1003BA58) --------------------------------------------------------
int __userpurge sub_1003BA58<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_10055A64;
  return v4;
}
// 10055A64: using guessed type int (__stdcall *off_10055A64)(char);

//----- (1003BA73) --------------------------------------------------------
int __userpurge sub_1003BA73<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_100236C7(a1, a2, a3);
  *(_DWORD *)v4 = &off_10055A4C;
  return v4;
}
// 10055A4C: using guessed type int (__stdcall *off_10055A4C)(char);

//----- (1003BA8E) --------------------------------------------------------
int __usercall sub_1003BA8E<eax>(int a1<ebp>)
{
  int v2; // ecx@1
  void *v3; // esi@1

  sub_1002D0B8();
  *(_DWORD *)(a1 - 16) = v2;
  v3 = (void *)(v2 + 4);
  *(_DWORD *)v2 = off_10059B48;
  *(_DWORD *)(v2 + 4) = off_10059B74;
  *(_DWORD *)(a1 - 4) = 0;
  sub_1003BE50(v2, a1);
  sub_10026B16(v3);
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10059B48: using guessed type int (*off_10059B48[3])();
// 10059B74: using guessed type int (*off_10059B74[5])();

//----- (1003BAC9) --------------------------------------------------------
void *__thiscall sub_1003BAC9(void *this, char a2)
{
  void *v2; // esi@1
  char v4; // [sp-4h] [bp-4h]@1

  v2 = (char *)this - 4;
  sub_1003BA8E((int)&v4);
  if ( a2 & 1 )
    sub_1002404A(v2);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1003BAF0) --------------------------------------------------------
char __thiscall sub_1003BAF0(void *this, char a2, int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // edi@1
  char result; // al@2
  int v8; // esi@9
  int v9; // ebx@12
  void *v10; // esi@12
  char v11; // [sp-14h] [bp-3Ch]@12
  char v12; // [sp-10h] [bp-38h]@2
  int v13; // [sp-Ch] [bp-34h]@2
  int v14; // [sp-8h] [bp-30h]@2
  int v15; // [sp-4h] [bp-2Ch]@2
  char v16; // [sp+Ch] [bp-1Ch]@12
  int v17; // [sp+20h] [bp-8h]@6
  int v18; // [sp+24h] [bp-4h]@9

  v6 = (int)this;
  v5 = (int)sub_10029DCE();
  if ( *(_DWORD *)(*(_DWORD *)(v6 + 32) + 432) <= 0
    || (sub_10027C4E((int)&v12, (int)&a2),
        result = (*(int (__stdcall **)(int, _DWORD, int, int, int))(**(_DWORD **)(v6 + 32) + 60))(
                   v6,
                   *(_DWORD *)&v12,
                   v13,
                   v14,
                   v15),
        !result) )
  {
    if ( v5 && !*(_BYTE *)(v5 + 76) && *(_DWORD *)(v6 + 32) == sub_1002729E(v5) )
    {
      v17 = v5;
      sub_1003AF6A();
      if ( !(*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v6 + 28) + 256) + 48) & 2)
        && (1 << (*(_DWORD *)(*(_DWORD *)(v5 + 156) + 132) & 0x1F)) & *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 28) + 32)
                                                                                + 4
                                                                                * (*(_DWORD *)(*(_DWORD *)(v5 + 156)
                                                                                             + 132) >> 5))
        && *(_DWORD *)(*(_DWORD *)(v5 + 156) + 16) - *(_DWORD *)(*(_DWORD *)(v5 + 156) + 12) < *(_WORD *)(*(_DWORD *)(v6 + 32) + 16) )
      {
        v8 = *(_DWORD *)(*(_DWORD *)(v6 + 28) + 256);
        v18 = *(_DWORD *)(v6 + 28);
        if ( sub_10027277(v5) != v8 )
          *(_DWORD *)(v6 + 228) = 1;
        sub_1003C5DC(*(_DWORD *)(v5 + 156) + 12, v6);
        if ( *(_DWORD *)(*(_DWORD *)(v6 + 32) + 428) <= 0 )
        {
          v9 = v18;
        }
        else
        {
          sub_10027C4E((int)&v16, (int)&a2);
          v10 = *(void **)(v6 + 32);
          v15 = 11;
          sub_10027C4E((int)&v11, (int)&v16);
          v9 = v18;
          sub_1002BBC4(v10, v18, v11, *(int *)&v12, v13, v14, v15);
        }
        if ( sub_10027277(v17) != *(_DWORD *)(v9 + 256) )
          *(_DWORD *)(v6 + 228) = 0;
        return sub_1003AF6A();
      }
      sub_1003AF6A();
    }
    sub_10027C4E((int)&v12, (int)&a2);
    result = sub_10037FD0(*(void **)(v6 + 28), v6, v12, v13, v14, v15);
  }
  return result;
}

//----- (1003BC69) --------------------------------------------------------
int __userpurge sub_1003BC69<eax>(int a1<ebp>, int a2)
{
  int v3; // ecx@1
  int v4; // esi@1
  int v5; // edi@1
  int v6; // ecx@1
  int v7; // ST00_4@1

  sub_1002D0B8();
  v4 = v3;
  v5 = v3 != 4 ? v3 : 0;
  *(_DWORD *)(a1 - 16) = v5;
  sub_1003AF6A();
  v6 = *(_DWORD *)(v4 + 156);
  *(_DWORD *)(a1 - 4) = 0;
  sub_1003AC49(v6, a1, v5);
  loc_100286CD(*(_DWORD *)(a1 + 8));
  *(_DWORD *)(a1 - 4) = -1;
  sub_1003AF6A();
  return sub_1002D086(v7);
}
// 100286CD: using guessed type _DWORD __cdecl loc_100286CD(_DWORD);
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1003BCBA) --------------------------------------------------------
int __thiscall sub_1003BCBA(void *this)
{
  void *v2; // edi@1
  int v3; // ecx@1
  int v4; // eax@1
  int v18; // ebx@7
  int v22; // [sp-4h] [bp-18h]@1
  char v23; // [sp+12h] [bp-2h]@7
  char v24; // [sp+13h] [bp-1h]@7

  v2 = this;
  sub_1003AF6A();
  v3 = *((_DWORD *)v2 + 7);
  v22 = *((_DWORD *)v2 + 2);
  v4 = (*(int (**)(void))(*(_DWORD *)v3 + 4))();
  sub_10027BAF(3, 4, v4, v22);
  _EAX = 1;
  if ( *(_BYTE *)(*((_DWORD *)v2 + 39) + 161) )
  {
    _EDX = (int)((char *)v2 + 44);
    __asm { lock xadd [edx], eax }
    if ( _EAX == 0 )
    {
      _ECX = 2;
      __asm { lock cmpxchg [edx], ecx }
      v22 = 1;
    }
    else
    {
      v22 = 2;
    }
    sub_1003C827((int)((char *)v2 - 4), v22);
  }
  else
  {
    _ECX = (int)((char *)v2 + 44);
    __asm { lock xadd [ecx], eax }
    if ( _EAX == 0 )
    {
      v24 = 0;
      v23 = 0;
      v18 = sub_1003C09E((int)((char *)v2 - 4), (int)&v24, (int)&v23);
      _ECX = 2;
      _EDX = (int)((char *)v2 + 44);
      __asm { lock cmpxchg [edx], ecx }
      if ( v24 )
        sub_1003C55C(v18, *((_DWORD *)v2 + 6), 0, 0);
      sub_1003C913((int)((char *)v2 - 4), v18, 1);
    }
  }
  return sub_1003AF6A();
}

//----- (1003BDDE) --------------------------------------------------------
char __thiscall sub_1003BDDE(int this)
{
  int ebp0; // ebp@0
  int v2; // edi@1
  LPVOID v3; // eax@2
  int v4; // ecx@2
  int v5; // esi@4
  int v7; // [sp+8h] [bp-8h]@2
  int v8; // [sp+Ch] [bp-4h]@3

  v2 = this;
  if ( *(_DWORD *)(this + 160) )
  {
    *(_BYTE *)(this + 176) = 1;
    v4 = *(_DWORD *)(this + 160);
    v7 = 0;
    LOBYTE(v3) = sub_1003AA87(v4, (int)&v7, 15, 1);
    if ( (_BYTE)v3 )
      LOBYTE(v3) = sub_1003ABAA(v8, v7, 0, 0);
  }
  else
  {
    v5 = this + 4;
    v3 = sub_10029DCE();
    if ( v3 == (LPVOID)v5 )
    {
      *(_BYTE *)(v2 + 176) = 1;
    }
    else
    {
      sub_1003C6EE(v2);
      sub_1003BE50(v2, ebp0);
      LOBYTE(v3) = sub_10029C7F(*(_DWORD *)(v2 + 32));
    }
  }
  return (char)v3;
}

//----- (1003BE50) --------------------------------------------------------
void __usercall sub_1003BE50(int a1<ecx>, int a2<ebp>)
{
  int v2; // esi@1

  v2 = a1;
  sub_10026F8C(a1 + 4, a2);
  sub_1003C7D6(v2, 0, 0);
}

//----- (1003BE68) --------------------------------------------------------
int __usercall sub_1003BE68<eax>(int this<ecx>, int a2<ebp>)
{
  int v3; // esi@1

  v3 = this;
  sub_1003AF6A();
  sub_1003BE50(v3, a2);
  return sub_10029C7F(*(_DWORD *)(v3 + 32));
}

//----- (1003BE83) --------------------------------------------------------
int __userpurge sub_1003BE83<eax>(int a1<ebp>, int a2)
{
  char v2; // bh@1
  int v3; // esi@1
  int v4; // ecx@1
  void *v5; // eax@1
  char v6; // bl@3
  char v7; // bl@7
  int v9; // [sp-8h] [bp-8h]@1

  sub_1002D0B8();
  v3 = v4;
  *(_DWORD *)(a1 - 16) = 0;
  v2 = 0;
  *(_DWORD *)(v4 + 72) = GetCurrentThreadId();
  sub_1002782B((LPVOID)(v3 + 4));
  v5 = (void *)(*(int (__cdecl **)(int, signed int))(**(_DWORD **)(v3 + 32) + 12))(a1 - 20, 32);
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)(a1 - 16) = 1;
  v6 = !sub_1003A576(v5, 9u) && sub_10034C33() == 6;
  *(_DWORD *)(a1 - 4) = -1;
  sub_1003A54F((LPVOID *)(a1 - 20));
  if ( v6 )
  {
    v2 = 1;
    loc_10044230(1);
  }
  sub_1003AF6A();
  *(_DWORD *)(v3 + 172) = 0;
  v7 = 0;
  if ( !sub_1003C034(v3, a1) )
    goto LABEL_9;
LABEL_8:
  v7 = sub_1003C3B4(v3, a1);
  while ( !v7 )
  {
LABEL_9:
    *(_BYTE *)(v3 + 179) &= 0xFDu;
    *(_DWORD *)(a1 - 32) = 0;
    *(_DWORD *)(a1 - 24) = 0;
    if ( !*(_DWORD *)(v3 + 160) )
    {
      sub_1003AF6A();
      sub_100249E2(a1 - 44);
      sub_1002D02B(a1 - 44, (int)&unk_10060F30);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1003BFF7);
    }
    if ( !*(_BYTE *)(v3 + 178) )
    {
      if ( sub_1003B1AB(*(_DWORD *)(v3 + 160)) )
      {
        sub_1003AF6A();
        sub_10029A72(*(_DWORD *)(v3 + 32));
        sub_1003AF6A();
      }
    }
    if ( sub_1003CB9E(v3, a1 - 32) )
    {
      if ( *(_DWORD *)(a1 - 32) != 1 )
      {
        sub_1003BFF7(v3, a1 - 32);
        goto LABEL_8;
      }
      sub_1003C913(v3, *(_DWORD *)(a1 - 24), 0);
      break;
    }
    if ( sub_1003C3B4(v3, a1) )
      break;
    sub_1003CAAE(v3);
    if ( *(_BYTE *)(v3 + 176) )
    {
      sub_1003BE68(v3, a1);
      v7 = 1;
    }
  }
  if ( v2 )
    sub_10044246();
  sub_10026FEC();
  return sub_1002D086(v9);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10034C33: using guessed type int sub_10034C33(void);
// 10044230: using guessed type _DWORD __cdecl loc_10044230(_DWORD);

//----- (1003BFF7) --------------------------------------------------------
int __thiscall sub_1003BFF7(int this, int a2)
{
  int ebp0; // ebp@0
  int v4; // esi@1

  v4 = this;
  sub_10048B85((void *)a2, this);
  ++*(_DWORD *)(*(_DWORD *)(v4 + 160) + 96);
  sub_1003AF6A();
  sub_10047BDA(a2);
  sub_1003AF6A();
  return sub_10027673(v4 + 4, ebp0);
}

//----- (1003C034) --------------------------------------------------------
char __usercall sub_1003C034<al>(int a1<ecx>, int a2<ebp>)
{
  int v2; // edi@1
  int v3; // esi@4
  int v4; // ecx@4
  char result; // al@5

  v2 = a1;
  if ( *(_DWORD *)(a1 + 168) )
  {
    sub_1003AF6A();
    if ( *(_BYTE *)(v2 + 177) )
    {
      (*(void (__cdecl **)(_DWORD))(*(_DWORD *)(v2 + 168) + 12))(*(_DWORD *)(v2 + 168));
      *(_DWORD *)(v2 + 168) = 0;
    }
    else
    {
      v3 = *(_DWORD *)(v2 + 168);
      sub_10048BDA(*(_DWORD *)(v2 + 168));
      v4 = *(_DWORD *)(v2 + 32);
      *(_DWORD *)(v2 + 168) = 0;
      sub_1002B52D(v4, v3);
    }
    sub_1003AF6A();
    sub_10027673(v2 + 4, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003C09E) --------------------------------------------------------
int __thiscall sub_1003C09E(int this, int a2, int a3)
{
  int v3; // ebx@1
  int ebp0; // ebp@0
  int v5; // edx@1
  int v6; // eax@1
  int v7; // edi@3
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+10h] [bp-4h]@1

  v3 = this;
  v5 = *(_DWORD *)(this + 28);
  v6 = *(_DWORD *)(this + 160);
  v9 = 0;
  v10 = 0;
  if ( !(unsigned __int8)(*(int (__thiscall **)(int, int *, int, _DWORD, signed int))(v6 + 60))(v6 + 36, &v9, v5, 0, 25) )
  {
    v7 = sub_1002A37E(ebp0, 1);
    *(_BYTE *)a2 = v7 != 0;
    return v7;
  }
  if ( v9 == 1 )
    return v10;
  sub_1003AF6A();
  v7 = sub_1002A37E(ebp0, 1);
  sub_1003AF6A();
  if ( !v7 )
  {
    if ( !(unsigned __int8)(*(int (__thiscall **)(int, int *, _DWORD, _DWORD, signed int))(*(_DWORD *)(v3 + 160) + 60))(
                             *(_DWORD *)(v3 + 160) + 36,
                             &v9,
                             *(_DWORD *)(v3 + 28),
                             0,
                             1) )
      return v7;
    return sub_10047782((int)&v9, v7);
  }
  if ( !sub_10047D8D((int)&v9, v7) )
  {
    if ( !(unsigned __int8)(*(int (__thiscall **)(int, int *, _DWORD, _DWORD, signed int))(*(_DWORD *)(v3 + 160) + 60))(
                             *(_DWORD *)(v3 + 160) + 36,
                             &v9,
                             *(_DWORD *)(v3 + 28),
                             0,
                             7) )
    {
      *(_BYTE *)a2 = 1;
      return v7;
    }
    if ( v9 == 1 )
    {
      sub_1002B4ED(*(_DWORD *)(v3 + 32), v7, 1);
      return sub_10047782((int)&v9, v7);
    }
  }
  *(_BYTE *)a3 = v9 == 4;
  sub_100477CB((int)&v9, v7);
  return v7;
}

//----- (1003C1A0) --------------------------------------------------------
int __userpurge sub_1003C1A0<eax>(int a1<ecx>, int a2<edi>, int a3)
{
  int ebp0; // ebp@0
  int v5; // esi@1
  int v6; // eax@1

  v5 = a1;
  sub_1003AF6A();
  v6 = sub_1003AC49(*(_DWORD *)(v5 + 156), ebp0, a2);
  sub_10028761((void *)v6, a3);
  return sub_1003AF6A();
}

//----- (1003C1CC) --------------------------------------------------------
int __thiscall sub_1003C1CC(int this, int a2)
{
  int v2; // esi@1

  v2 = 0;
  if ( a2 )
  {
    _EDI = this + 164;
    if ( a2 == *(_DWORD *)(this + 164) )
    {
      _ECX = 0;
      __asm { lock cmpxchg [edi], ecx }
      if ( a2 == a2 )
        v2 = a2;
    }
  }
  return v2;
}

//----- (1003C1FA) --------------------------------------------------------
int __thiscall sub_1003C1FA(int this)
{
  return *(_DWORD *)(this + 12);
}

//----- (1003C1FE) --------------------------------------------------------
int __thiscall sub_1003C1FE(int this)
{
  return sub_1003C1FA(this - 4);
}

//----- (1003C206) --------------------------------------------------------
int __thiscall sub_1003C206(int this)
{
  return *(_DWORD *)(this + 156);
}

//----- (1003C20D) --------------------------------------------------------
int __thiscall sub_1003C20D(int this)
{
  return (*(int (**)(void))(**(_DWORD **)(this + 32) + 52))();
}

//----- (1003C215) --------------------------------------------------------
signed int __thiscall sub_1003C215(void *this)
{
  void *v1; // esi@1
  signed int v2; // edi@2

  v1 = this;
  sub_1003AF6A();
  if ( *((_DWORD *)v1 + 39) )
    v2 = *(_DWORD *)(*((_DWORD *)v1 + 39) + 124);
  else
    v2 = -1;
  sub_1003AF6A();
  return v2;
}

//----- (1003C241) --------------------------------------------------------
int __thiscall sub_1003C241(void *this, int a2, int a3, int a4)
{
  int v4; // eax@1
  int v5; // ebx@1
  int v6; // edi@1
  signed __int64 v8; // qax@1
  signed __int64 v10; // qax@1
  int v11; // edx@2
  int i; // ecx@2
  int v13; // eax@6
  int v14; // edx@6
  int v15; // ebx@6
  void *v16; // esi@6
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edx@10
  int v20; // ecx@10
  int v21; // edx@10
  void *v23; // [sp+Ch] [bp-24h]@6
  void *v24; // [sp+10h] [bp-20h]@1
  void *v25; // [sp+14h] [bp-1Ch]@6
  int v26; // [sp+18h] [bp-18h]@1
  int v27; // [sp+1Ch] [bp-14h]@1
  int v28; // [sp+20h] [bp-10h]@1
  int v29; // [sp+24h] [bp-Ch]@1
  int v30; // [sp+28h] [bp-8h]@6
  int v31; // [sp+2Ch] [bp-4h]@6

  v6 = (int)this;
  _ECX = 0;
  v5 = 2 * *(_DWORD *)(v6 + 8) + 2;
  v8 = 4i64 * (unsigned int)(2 * *(_DWORD *)(v6 + 8) + 2);
  __asm { seto    cl }
  v26 = v6;
  v27 = v5;
  v29 = sub_10021CF0(SHIDWORD(v8), v8 | -_ECX, v5, v6, v8 | -_ECX);
  v24 = *(void **)(v6 + 12);
  _ECX = 0;
  v10 = 8i64 * (unsigned int)v5;
  __asm { seto    cl }
  v4 = sub_10021CF0(SHIDWORD(v10), v10 | -_ECX, v5, v6, v10 | -_ECX);
  v28 = v4;
  if ( v4 )
  {
    v11 = v5 - 1;
    for ( i = v4; v11 >= 0; --v11 )
    {
      *(_DWORD *)i = 0;
      *(_DWORD *)(i + 4) = 0;
      i += 8;
    }
  }
  else
  {
    v28 = 0;
  }
  v16 = *(void **)(v6 + 20);
  v23 = *(void **)(v6 + 16);
  v25 = *(void **)(v6 + 20);
  sub_1002C615(v16);
  v13 = *(_DWORD *)v6;
  v15 = *(_DWORD *)(v6 + 4) - *(_DWORD *)v6;
  v14 = 0;
  v30 = *(_DWORD *)v6;
  v31 = 0;
  if ( v15 > 0 )
  {
    do
    {
      *(_DWORD *)(v29 + 4 * v14) = *(_DWORD *)(*(_DWORD *)(v6 + 12) + 4 * (*(_DWORD *)(v6 + 8) & v13));
      v17 = *(_DWORD *)(v6 + 16);
      v18 = *(_DWORD *)(v6 + 8) & v30;
      *(_DWORD *)(v28 + 8 * v31) = *(_DWORD *)(v17 + 8 * v18);
      v6 = v26;
      *(_DWORD *)(v28 + 8 * v31 + 4) = *(_DWORD *)(v17 + 8 * v18 + 4);
      v14 = v31 + 1;
      v13 = v30 + 1;
      v31 = v14;
      ++v30;
    }
    while ( v14 < v15 );
    v16 = v25;
  }
  sub_10030CF0((void *)(v29 + 4 * v15), 0, 4 * (v27 - v15));
  *(_DWORD *)(v6 + 12) = v29;
  *(_DWORD *)(v6 + 16) = v28;
  *(_DWORD *)v6 = 0;
  *(_DWORD *)(v6 + 8) = v27 - 1;
  if ( a3 )
  {
    v20 = *(_DWORD *)(v6 + 16);
    v21 = v15 & (v27 - 1);
    *(_DWORD *)(v20 + 8 * v21) = a3;
    *(_DWORD *)(v20 + 8 * v21 + 4) = a4;
    v19 = a2 | 1;
  }
  else
  {
    v19 = a2;
  }
  *(_DWORD *)(*(_DWORD *)(v6 + 12) + 4 * (*(_DWORD *)(v6 + 8) & v15)) = v19;
  *(_DWORD *)(v6 + 4) = v15 + 1;
  sub_1002C625(v16);
  sub_1002401B(v24);
  return sub_1002401B(v23);
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (1003C3A8) --------------------------------------------------------
bool __thiscall sub_1003C3A8(int this)
{
  return *(_DWORD *)(this + 44) == 2;
}

//----- (1003C3B4) --------------------------------------------------------
char __usercall sub_1003C3B4<al>(int a1<ecx>, int a2<ebp>)
{
  int v2; // esi@1
  char result; // al@7

  v2 = a1;
  if ( *(_BYTE *)(a1 + 178) || !*(_BYTE *)(*(_DWORD *)(a1 + 160) + 161) )
  {
    result = 0;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 172) )
      sub_1003AD9F(*(_DWORD *)(a1 + 32) + 60, *(_DWORD *)(*(_DWORD *)(a1 + 160) + 132));
    *(_DWORD *)(v2 + 172) = 0;
    if ( sub_1003C827(v2, 0) )
      sub_1003BE68(v2, a2);
    result = 1;
  }
  return result;
}

//----- (1003C412) --------------------------------------------------------
int __thiscall sub_1003C412(void *this)
{
  int v1; // eax@1
  int v2; // esi@1
  int v3; // eax@3
  int v4; // edi@3
  int v6; // [sp+Ch] [bp-14h]@3
  int v7; // [sp+10h] [bp-10h]@3
  int v8; // [sp+14h] [bp-Ch]@1
  int v9; // [sp+18h] [bp-8h]@3
  char v10; // [sp+1Eh] [bp-2h]@1
  char v11; // [sp+1Fh] [bp-1h]@1

  v2 = (int)this;
  sub_1003AF6A();
  v11 = 0;
  v10 = 0;
  v1 = sub_1003C09E(v2, (int)&v11, (int)&v10);
  v8 = v1;
  if ( v11 )
    sub_1003C55C(v1, *(_DWORD *)(v2 + 28), 0, 0);
  sub_1003AF6A();
  v3 = *(_DWORD *)(v2 + 160);
  v6 = *(_DWORD *)(v2 + 32);
  *(_DWORD *)(v2 + 160) = 0;
  v4 = *(_DWORD *)(v2 + 156);
  v9 = v3;
  v7 = v8;
  if ( !v8 )
  {
    v7 = (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
    v3 = v9;
  }
  *(_DWORD *)(v2 + 44) = 1;
  (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 16))(v3, v8);
  if ( v7 )
  {
    (*(void (__thiscall **)(int, int, signed int))(*(_DWORD *)v4 + 4))(v4, v7, 2);
  }
  else
  {
    sub_1003AE27(v9, 4, 1);
    sub_10029C9A(v6);
    (*(void (__thiscall **)(int, signed int))(*(_DWORD *)v4 + 8))(v4, 2);
  }
  sub_1003AF6A();
  return sub_1003AF6A();
}

//----- (1003C4E8) --------------------------------------------------------
void __thiscall sub_1003C4E8(int this, char a2)
{
  int v2; // esi@1
  int v3; // eax@4
  int v4; // eax@5
  int v5; // eax@6
  char v6; // [sp+4h] [bp-Ch]@9

  v2 = this;
  if ( a2 )
  {
    ++*(_DWORD *)(this + 20);
    if ( *(_DWORD *)(this + 20) == 1 )
    {
      sub_1003AF6A();
      (*(void (**)(void))(**(_DWORD **)(v2 + 156) + 32))();
      sub_1003AF6A();
    }
  }
  else
  {
    v3 = *(_DWORD *)(this + 20);
    if ( !v3 )
    {
      sub_10024962((int)&v6);
      sub_1002D02B((int)&v6, (int)&unk_10060EF8);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1003C55C);
    }
    v4 = v3 - 1;
    *(_DWORD *)(this + 20) = v4;
    if ( !v4 )
    {
      v5 = sub_1003C1CC(this - 4, *(_DWORD *)(this + 160));
      if ( v5 )
        sub_1003AEA5(v5);
    }
  }
}

//----- (1003C55C) --------------------------------------------------------
int __thiscall sub_1003C55C(int this, int a2, int a3, char a4)
{
  int result; // eax@1
  int v5; // edx@1

  result = a2;
  v5 = this;
  *(_BYTE *)(this + 236) = 0;
  *(_DWORD *)(this + 28) = a2;
  if ( a3 )
  {
    if ( a4 )
    {
      result = *(_DWORD *)(a2 + 256);
      if ( !(*(_BYTE *)(result + 48) & 4) )
      {
        result += 20;
        _ECX = 1;
        __asm { lock xadd [eax], ecx }
      }
      *(_BYTE *)(v5 + 177) = 1;
    }
    else
    {
      *(_BYTE *)(this + 177) = 0;
    }
    *(_DWORD *)(v5 + 168) = a3;
  }
  else
  {
    result = *(_DWORD *)(a2 + 256);
    if ( !(*(_BYTE *)(result + 48) & 4) )
    {
      result += 20;
      _ECX = 1;
      __asm { lock xadd [eax], ecx }
    }
  }
  return result;
}

//----- (1003C5C5) --------------------------------------------------------
int __thiscall sub_1003C5C5(int this, int a2)
{
  int result; // eax@1

  *(_DWORD *)(this + 160) = a2;
  result = this + 44;
  *(_DWORD *)(this + 44) = 0;
  return result;
}

//----- (1003C5DC) --------------------------------------------------------
int __thiscall sub_1003C5DC(int this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int result; // eax@2

  v2 = *(_DWORD *)(this + 4);
  v3 = *(_DWORD *)(this + 8);
  if ( v2 >= v3 + *(_DWORD *)this )
  {
    result = sub_1003C241((void *)this, a2, 0, 0);
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(this + 12) + 4 * (v2 & v3)) = a2;
    result = v2 + 1;
    *(_DWORD *)(this + 4) = v2 + 1;
  }
  return result;
}

//----- (1003C61D) --------------------------------------------------------
void __thiscall sub_1003C61D(int this)
{
  int v1; // esi@1
  int v2; // ecx@2
  int v3; // [sp+4h] [bp-8h]@2

  v1 = this;
  if ( *(_BYTE *)(this + 178) )
  {
    v2 = *(_DWORD *)(this + 160);
    v3 = 0;
    if ( !sub_1003AA87(v2, (int)&v3, 15, 1) )
    {
      while ( !(unsigned __int8)sub_1003AB51(*(_DWORD *)(v1 + 160)) )
        (*(void (__thiscall **)(int))(*(_DWORD *)v1 + 32))(v1);
    }
    *(_BYTE *)(v1 + 178) = 0;
  }
}

//----- (1003C66C) --------------------------------------------------------
int __thiscall sub_1003C66C(void *this)
{
  int v2; // esi@1

  v2 = (int)this;
  sub_1003AF6A();
  sub_1003C827(v2, 3);
  return sub_1003AF6A();
}

//----- (1003C68B) --------------------------------------------------------
void __usercall sub_1003C68B(int a1<ecx>, int a2<ebp>)
{
  int v2; // esi@1

  v2 = a1;
  sub_10027673(a1 + 4, a2);
  sub_1003C7D6(v2, 0, 0);
  *(_DWORD *)(v2 + 72) = 0;
  *(_BYTE *)(v2 + 236) = 1;
}

//----- (1003C6AE) --------------------------------------------------------
int __thiscall sub_1003C6AE(int this, int a2)
{
  int result; // eax@1
  int (__stdcall **v3)(char); // [sp+0h] [bp-Ch]@3

  result = a2;
  if ( !a2 )
  {
    a2 = (int)"pThreadProxy";
    sub_10023687((int)&v3, &a2);
    v3 = &off_100542CC;
    sub_1002D02B((int)&v3, (int)&unk_10061764);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003C6EE);
  }
  *(_DWORD *)(this + 156) = a2;
  return result;
}
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);

//----- (1003C6EE) --------------------------------------------------------
char __thiscall sub_1003C6EE(int this)
{
  int v1; // esi@1
  char result; // al@3
  char v3; // [sp+4h] [bp-10h]@3
  int v4; // [sp+Ch] [bp-8h]@2
  void (__cdecl *v5)(); // [sp+10h] [bp-4h]@2

  v1 = this;
  if ( !*(_DWORD *)(this + 44) )
  {
    v4 = 0;
    v5 = sub_1002C630;
    do
      result = sub_1001FF20((int)&v3);
    while ( !*(_DWORD *)(v1 + 44) );
  }
  return result;
}

//----- (1003C719) --------------------------------------------------------
char __cdecl sub_1003C719(int a1, int a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-10h]@3
  int v4; // [sp+10h] [bp-8h]@2
  void (__cdecl *v5)(); // [sp+14h] [bp-4h]@2

  if ( *(_DWORD *)a1 != a2 )
  {
    v4 = 0;
    v5 = sub_1002C630;
    do
      result = sub_1001FF20((int)&v3);
    while ( *(_DWORD *)a1 != a2 );
  }
  return result;
}

//----- (1003C746) --------------------------------------------------------
int __thiscall sub_1003C746(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  int v3; // ST0C_4@1
  int v4; // eax@1
  int v5; // eax@3
  int v6; // ST04_4@3
  int result; // eax@6
  int v8; // [sp+8h] [bp-Ch]@3
  int v9; // [sp+10h] [bp-4h]@3

  v2 = this;
  v1 = 0;
  sub_1003AF6A();
  v3 = *((_DWORD *)v2 + 2);
  v4 = (*(int (**)(void))(**((_DWORD **)v2 + 7) + 4))();
  sub_10027BAF(5, 4, v4, v3);
  if ( *(_BYTE *)(*((_DWORD *)v2 + 39) + 161) )
  {
    sub_1003C827((int)((char *)v2 - 4), 2);
  }
  else
  {
    v5 = *((_DWORD *)v2 + 39);
    v6 = *((_DWORD *)v2 + 6);
    v8 = 0;
    v9 = 0;
    if ( (unsigned __int8)(*(int (__thiscall **)(int, int *, int, _DWORD, signed int))(v5 + 60))(v5 + 36, &v8, v6, 0, 1) )
      sub_1003C913((int)((char *)v2 - 4), v9, 2);
    else
      v1 = 1;
  }
  result = sub_1003AF6A();
  if ( v1 )
    result = (*(int (**)(void))(**((_DWORD **)v2 + 38) + 12))();
  return result;
}

//----- (1003C7D6) --------------------------------------------------------
void __thiscall sub_1003C7D6(int this, int a2, char a3)
{
  int v3; // esi@1
  int v4; // eax@3

  v3 = this;
  if ( *(_DWORD *)(this + 28) )
  {
    sub_1003C719(this + 228, 0);
    sub_1002AD41(*(void **)(*(_DWORD *)(v3 + 28) + 256));
    if ( a3 )
    {
      v4 = *(_DWORD *)(a2 + 256);
      if ( !(*(_BYTE *)(v4 + 48) & 4) )
      {
        _EAX = v4 + 20;
        _ECX = 1;
        __asm { lock xadd [eax], ecx }
      }
    }
    *(_DWORD *)(v3 + 28) = a2;
  }
}

//----- (1003C827) --------------------------------------------------------
char __thiscall sub_1003C827(int this, int a2)
{
  char v2; // bl@1
  int v3; // esi@1
  int v4; // ecx@4
  int v5; // eax@4
  char v7; // [sp-10h] [bp-24h]@9
  int v8; // [sp-Ch] [bp-20h]@9
  int v9; // [sp-8h] [bp-1Ch]@9
  int v10; // [sp-4h] [bp-18h]@4
  int v11; // [sp+Ch] [bp-8h]@1
  int v12; // [sp+10h] [bp-4h]@2

  v3 = this;
  v2 = 0;
  v11 = *(_DWORD *)(this + 156);
  if ( *(_DWORD *)(this + 160) )
  {
    sub_1003C61D(this);
    v12 = *(_DWORD *)(*(_DWORD *)(v3 + 160) + 180);
    sub_1003AF6A();
    (*(void (**)(void))(**(_DWORD **)(v3 + 160) + 12))();
    *(_DWORD *)(v3 + 160) = 0;
    if ( a2 )
    {
      sub_1003AF6A();
      *(_DWORD *)(v3 + 44) = 1;
    }
    else
    {
      v4 = *(_DWORD *)(v3 + 32);
      v10 = *(_DWORD *)(v3 + 12);
      v5 = (*(int (**)(void))(*(_DWORD *)v4 + 4))();
      sub_10027BAF(6, 4, v5, v10);
      sub_100386F4(*(void **)(v3 + 28), v3);
    }
    sub_1002C0E6(*(_DWORD *)(v3 + 32), (int)&v12);
    sub_1002C1C3(*(_DWORD *)(v3 + 32), 0);
    v2 = *(_BYTE *)(v3 + 176);
    if ( !a2 )
      *(_DWORD *)(v3 + 44) = 1;
  }
  if ( a2 == 2 || a2 == 3 )
  {
    sub_10027C4E((int)&v7, *(_DWORD *)(v3 + 28) + 12);
    sub_10037FD0(*(void **)(v3 + 28), v3, v7, v8, v9, v10);
  }
  if ( a2 )
  {
    v10 = 1;
    (*(void (__thiscall **)(int, signed int))(*(_DWORD *)v11 + 8))(v11, 1);
  }
  return v2;
}

//----- (1003C913) --------------------------------------------------------
int __thiscall sub_1003C913(int this, int a2, int a3)
{
  signed int v3; // edi@1
  int v4; // esi@1
  int v5; // ecx@7
  int v6; // eax@7
  int v7; // eax@8
  int v8; // ebx@8
  int v9; // edx@10
  int result; // eax@11
  int v11; // eax@11
  int v12; // eax@12
  char v13; // [sp-10h] [bp-28h]@6
  int v14; // [sp-Ch] [bp-24h]@6
  int v15; // [sp-8h] [bp-20h]@6
  int v16; // [sp-4h] [bp-1Ch]@6
  int v17; // [sp+Ch] [bp-Ch]@8
  int v18; // [sp+10h] [bp-8h]@8
  int v19; // [sp+14h] [bp-4h]@8

  v3 = 1;
  v4 = this;
  if ( a3 )
  {
    if ( a3 != 1 )
    {
      if ( a3 == 2 )
      {
        sub_10027C4E((int)&v13, *(_DWORD *)(this + 28) + 12);
        sub_10037FD0(*(void **)(v4 + 28), v4, v13, v14, v15, v16);
      }
      else
      {
        if ( a3 == 3 )
          v3 = 2;
      }
    }
  }
  else
  {
    v5 = *(_DWORD *)(this + 32);
    v16 = *(_DWORD *)(v4 + 12);
    v6 = (*(int (**)(void))(*(_DWORD *)v5 + 4))();
    sub_10027BAF(6, 4, v6, v16);
    sub_100386F4(*(void **)(v4 + 28), v4);
    v3 = 0;
  }
  sub_1003AF6A();
  v7 = *(_DWORD *)(v4 + 160);
  v17 = *(_DWORD *)(v4 + 32);
  *(_DWORD *)(v4 + 160) = 0;
  v8 = *(_DWORD *)(v4 + 156);
  v19 = v7;
  v18 = a2;
  if ( !a2 )
  {
    v18 = (*(int (__thiscall **)(int))(*(_DWORD *)v7 + 4))(v19);
    v7 = v19;
  }
  *(_DWORD *)(v4 + 44) = 1;
  v9 = *(_DWORD *)v7;
  v16 = a2;
  (*(void (__thiscall **)(int, int))(v9 + 16))(v7, a2);
  if ( v18 )
  {
    v12 = *(_DWORD *)v8;
    v16 = v3;
    v15 = v18;
    result = (*(int (__thiscall **)(int, int, signed int))(v12 + 4))(v8, v18, v3);
  }
  else
  {
    sub_1003AE27(v19, 4, 1);
    sub_10029C9A(v17);
    v11 = *(_DWORD *)v8;
    v16 = v3;
    result = (*(int (__thiscall **)(int, signed int))(v11 + 8))(v8, v3);
  }
  if ( a3 )
    result = sub_1003AF6A();
  return result;
}

//----- (1003CA0A) --------------------------------------------------------
int __fastcall sub_1003CA0A(int a1)
{
  int v1; // edi@1
  int v3; // esi@2
  int v10; // ecx@2
  int v11; // eax@2
  int result; // eax@3
  char *v13; // eax@6
  char v14; // [sp-10h] [bp-38h]@3
  int v15; // [sp-4h] [bp-2Ch]@2
  char v16; // [sp+Ch] [bp-1Ch]@7
  char v17; // [sp+18h] [bp-10h]@6

  v1 = a1;
  if ( (LPVOID)(a1 != 4 ? a1 : 0) == sub_10029DCE() )
  {
    sub_100248A2((int)&v16);
    v15 = (int)&unk_10060EC0;
    v13 = &v16;
    goto LABEL_8;
  }
  _EBX = v1 + 44;
  _ESI = -1;
  __asm { lock xadd [ebx], esi }
  v3 = _ESI - 1;
  v10 = *(_DWORD *)(v1 + 28);
  v15 = *(_DWORD *)(v1 + 8);
  v11 = (*(int (**)(void))(*(_DWORD *)v10 + 4))();
  sub_10027BAF(4, 4, v11, v15);
  if ( v3 == 1 )
  {
    *(_DWORD *)_EBX = 0;
    sub_1003C6EE(v1 - 4);
    sub_10027C4E((int)&v14, *(_DWORD *)(v1 + 24) + 12);
    return (*(int (__thiscall **)(int))(*(_DWORD *)(v1 - 4) + 20))(v1 - 4);
  }
  result = v3 + 1;
  if ( (unsigned int)(v3 + 1) > 1 )
  {
    sub_100248B4((int)&v17);
    v15 = (int)&unk_10060E88;
    v13 = &v17;
LABEL_8:
    sub_1002D02B((int)v13, v15);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003CAAE);
  }
  return result;
}

//----- (1003CAAE) --------------------------------------------------------
int __thiscall sub_1003CAAE(int this)
{
  int v1; // ebx@1
  int v2; // esi@2
  int v3; // edi@2
  unsigned int v4; // eax@3
  int result; // eax@4
  int v6; // ecx@6
  int v7; // ecx@8
  char v8; // zf@12

  v1 = this;
  ++*(_DWORD *)(v1 + 172);
  if ( *(_DWORD *)(this + 172) == 1 )
  {
    v2 = *(_DWORD *)(*(_DWORD *)(this + 160) + 132);
    v3 = *(_DWORD *)(this + 32);
    sub_1003ADE1(v3 + 60, *(_DWORD *)(*(_DWORD *)(this + 160) + 132));
    sub_1003AB2C(v3, v2);
  }
  v4 = *(_DWORD *)(v1 + 172);
  if ( v4 >= 0x100 )
  {
    if ( v4 == 256 )
    {
      v6 = *(_DWORD *)(v1 + 160);
      *(_BYTE *)(v1 + 178) = 1;
      sub_1003AE27(v6, 2, 1);
      result = sub_1003AB9E(*(_DWORD *)(v1 + 160));
    }
    else
    {
      if ( *(_BYTE *)(v1 + 179) & 2 )
      {
        v7 = *(_DWORD *)(v1 + 156);
        *(_DWORD *)(v1 + 172) = v4 - 1;
        result = (*(int (**)(void))(*(_DWORD *)v7 + 12))();
      }
      else
      {
        sub_1002C264(*(void **)(v1 + 32), 1);
        while ( !(unsigned __int8)sub_1003AB51(*(_DWORD *)(v1 + 160)) )
          (*(void (__thiscall **)(int))(*(_DWORD *)v1 + 32))(v1);
        result = sub_1002C264(*(void **)(v1 + 32), 0);
        v8 = *(_DWORD *)(v1 + 172) == 0;
        *(_BYTE *)(v1 + 178) = 0;
        if ( !v8 )
          result = sub_1003AD9F(*(_DWORD *)(v1 + 32) + 60, *(_DWORD *)(*(_DWORD *)(v1 + 160) + 132));
        *(_DWORD *)(v1 + 172) = 0;
      }
    }
  }
  else
  {
    result = (*(int (**)(void))(**(_DWORD **)(v1 + 156) + 12))();
  }
  return result;
}

//----- (1003CB9E) --------------------------------------------------------
char __thiscall sub_1003CB9E(int this, int a2)
{
  int v2; // esi@1
  char v3; // ST14_1@1
  char result; // al@4

  v2 = this;
  v3 = *(_BYTE *)(this + 178);
  if ( (unsigned __int8)(*(int (__thiscall **)(int, int, _DWORD))(*(_DWORD *)(this + 160) + 60))(
                          *(_DWORD *)(this + 160) + 36,
                          a2,
                          *(_DWORD *)(this + 28)) )
  {
    sub_1003C61D(v2);
    if ( *(_DWORD *)(v2 + 172) )
      sub_1003AD9F(*(_DWORD *)(v2 + 32) + 60, *(_DWORD *)(*(_DWORD *)(v2 + 160) + 132));
    *(_DWORD *)(v2 + 172) = 0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003CC05) --------------------------------------------------------
int __thiscall sub_1003CC05(void *this)
{
  char v1; // bl@1
  int ebp0; // ebp@0
  void *v3; // esi@1
  int v4; // ST10_4@1
  int v5; // eax@1
  int v6; // eax@3
  int v7; // ST04_4@3
  int v8; // edi@5
  int result; // eax@18
  int v10; // [sp+8h] [bp-Ch]@3
  int v11; // [sp+10h] [bp-4h]@3

  v3 = this;
  v1 = 0;
  sub_1003AF6A();
  v4 = *((_DWORD *)v3 + 2);
  v5 = (*(int (**)(void))(**((_DWORD **)v3 + 7) + 4))();
  sub_10027BAF(5, 4, v5, v4);
  if ( *(_BYTE *)(*((_DWORD *)v3 + 39) + 161) )
  {
    sub_1003C827((int)((char *)v3 - 4), 2);
    goto LABEL_18;
  }
  v6 = *((_DWORD *)v3 + 39);
  v7 = *((_DWORD *)v3 + 6);
  v10 = 0;
  v11 = 0;
  if ( !(unsigned __int8)(*(int (__thiscall **)(int, int *, int, _DWORD, signed int))(v6 + 64))(v6 + 36, &v10, v7, 0, 9) )
    goto LABEL_17;
  if ( v10 == 1 )
  {
LABEL_11:
    v8 = v11;
    goto LABEL_12;
  }
  sub_1003AF6A();
  v8 = sub_1002A37E(ebp0, 1);
  sub_1003AF6A();
  if ( v8 )
  {
    if ( sub_10047D8D((int)&v10, v8) )
    {
LABEL_7:
      sub_100477CB((int)&v10, v8);
      goto LABEL_12;
    }
    if ( (unsigned __int8)(*(int (__thiscall **)(int, int *, _DWORD, _DWORD, signed int))(*((_DWORD *)v3 + 39) + 64))(
                            *((_DWORD *)v3 + 39) + 36,
                            &v10,
                            *((_DWORD *)v3 + 6),
                            0,
                            3) )
    {
      if ( v10 != 1 )
        goto LABEL_7;
      sub_1002B4ED(*((_DWORD *)v3 + 7), v8, 1);
      goto LABEL_11;
    }
    sub_1002B4ED(*((_DWORD *)v3 + 7), v8, 1);
    v8 = 0;
  }
  else
  {
    if ( !(unsigned __int8)(*(int (__thiscall **)(int, int *, _DWORD, _DWORD, signed int))(*((_DWORD *)v3 + 39) + 64))(
                             *((_DWORD *)v3 + 39) + 36,
                             &v10,
                             *((_DWORD *)v3 + 6),
                             0,
                             1) )
      goto LABEL_17;
    v8 = sub_10047782((int)&v10, v8);
  }
LABEL_12:
  if ( v8 )
  {
    sub_1003C913((int)((char *)v3 - 4), v8, 2);
    goto LABEL_18;
  }
LABEL_17:
  v1 = 1;
LABEL_18:
  result = sub_1003AF6A();
  if ( v1 )
    result = (*(int (**)(void))(**((_DWORD **)v3 + 38) + 12))();
  return result;
}

//----- (1003CD40) --------------------------------------------------------
int __userpurge sub_1003CD40<eax>(int a1<ebp>, int a2, int a3)
{
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  void *v7; // ecx@1

  sub_1002D0B8();
  v5 = v4;
  *(_DWORD *)(a1 - 16) = v4;
  v6 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(v4 + 4) = 0;
  *(_DWORD *)(v4 + 8) = 0;
  *(_DWORD *)v4 = v6;
  sub_100377ED((void *)(v4 + 16), v6, 256, 64);
  *(_DWORD *)(a1 - 4) = 0;
  sub_100377ED((void *)(v5 + 96), v6, 256, 64);
  *(_DWORD *)(v5 + 184) = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(v5 + 176) = 0;
  *(_DWORD *)(v5 + 180) = 0;
  *(_DWORD *)(v5 + 188) = 0;
  *(_DWORD *)(a1 - 32) = 0;
  *(_DWORD *)(a1 - 24) = 0;
  *(_DWORD *)(a1 - 20) = 0;
  v7 = *(void **)(v6 + 176);
  *(_BYTE *)(a1 - 4) = 1;
  *(_DWORD *)(v5 + 8) = sub_100380E4(v7, a1 - 32, v5);
  return sub_1002D086(20);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1003CDC6) --------------------------------------------------------
int __thiscall sub_1003CDC6(PSLIST_HEADER ListHead)
{
  int v1; // ebx@1
  PSLIST_HEADER v2; // edi@1
  int v3; // eax@1
  int v4; // eax@1
  int i; // esi@2
  int v6; // ecx@3
  int v7; // esi@6

  v2 = ListHead;
  v3 = (int)InterlockedFlushSList(ListHead);
  sub_1003CEAD(v3);
  v4 = (int)InterlockedFlushSList(v2 + 1);
  sub_1003CEAD(v4);
  sub_1003CEAD(LODWORD(v2[2].Alignment));
  v1 = LODWORD(v2[6].Alignment);
  if ( v1 )
  {
    do
    {
      for ( i = 0; i < LODWORD(v2[5].Alignment); ++i )
      {
        v6 = *(_DWORD *)(*(_DWORD *)v1 + 4 * i);
        if ( v6 )
          (**(void (__stdcall ***)(_DWORD))v6)(1);
      }
      v7 = *(_DWORD *)(v1 + 4);
      sub_1002401B(*(LPVOID *)v1);
      sub_1002404A((LPVOID)v1);
      v1 = v7;
    }
    while ( v7 );
  }
  return sub_1002401B(HIDWORD(v2[6].Alignment));
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1003CE3C) --------------------------------------------------------
int __usercall sub_1003CE3C<eax>(int a1<ebp>)
{
  int v2; // ecx@1
  int v3; // esi@1

  sub_1002D0B8();
  v3 = v2;
  *(_DWORD *)(a1 - 16) = v2;
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  sub_1003CDC6((PSLIST_HEADER)(v2 + 96));
  *(_DWORD *)(a1 - 4) = -1;
  sub_1003CDC6((PSLIST_HEADER)(v3 + 16));
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1003CE6F) --------------------------------------------------------
int __thiscall sub_1003CE6F(int this)
{
  int result; // eax@1

  result = this + 188;
  *(_DWORD *)(this + 188) = 1;
  return result;
}

//----- (1003CEA1) --------------------------------------------------------
bool __cdecl sub_1003CEA1(int a1)
{
  bool result; // eax@1

  result = sub_1002A7FD(*(_DWORD *)(a1 + 36));
  if ( !result )
  {
    sub_1003CEAD(*(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    *(_DWORD *)(a1 + 72) = 0;
  }
  return result;
}

//----- (1003CEAD) --------------------------------------------------------
int __stdcall sub_1003CEAD(int a1)
{
  int v1; // esi@1
  int v2; // ecx@2
  int result; // eax@3

  v1 = a1;
  while ( v1 )
  {
    v2 = v1 - 284;
    v1 = *(_DWORD *)v1;
    if ( v2 )
      result = (**(int (__stdcall ***)(_DWORD))v2)(1);
  }
  return result;
}

//----- (1003CED1) --------------------------------------------------------
char __thiscall sub_1003CED1(void *ListHead, int a2, signed int a3, char a4)
{
  signed int v4; // edx@1
  int v6; // esi@1
  char result; // al@2
  int v8; // eax@3
  int v9; // ecx@3
  int v10; // edx@4
  int v11; // edi@4
  int v12; // edx@5
  PSINGLE_LIST_ENTRY v18; // eax@14
  int v19; // ST08_4@14

  v6 = (int)ListHead;
  v4 = a3 >> *((_DWORD *)ListHead + 11);
  _EBX = a3 & (*((_DWORD *)ListHead + 10) - 1);
  if ( v4 < *((_DWORD *)ListHead + 15) )
  {
    v9 = *((_DWORD *)ListHead + 14);
    v8 = *(_DWORD *)(v6 + 52);
    if ( v4 < v9 )
    {
      v11 = *(_DWORD *)(v8 + 4 * v4);
    }
    else
    {
      v10 = v4 - v9;
      v11 = *(_DWORD *)(v8 + 4 * v9 - 4);
      if ( v10 >= 0 )
      {
        v12 = v10 + 1;
        do
        {
          v11 = *(_DWORD *)(v11 + 4);
          --v12;
        }
        while ( v12 );
      }
    }
    _ECX = *(_DWORD *)v11 + 4 * _EBX;
    _EDX = 0;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 == a2 )
    {
      _ECX = v11 + 8;
      __asm { lock cmpxchg [ecx], ebx }
      if ( a4 )
      {
        if ( (signed int)QueryDepthSList((PSLIST_HEADER)v6) <= *(_DWORD *)(v6 + 68) )
        {
          InterlockedPushEntrySList((PSLIST_HEADER)v6, (PSINGLE_LIST_ENTRY)(a2 + 284));
        }
        else
        {
          InterlockedPushEntrySList((PSLIST_HEADER)(v6 + 8), (PSINGLE_LIST_ENTRY)(a2 + 284));
          if ( (signed int)QueryDepthSList((PSLIST_HEADER)(v6 + 8)) > *(_DWORD *)(v6 + 68) )
          {
            if ( !sub_1002A7FD(*(_DWORD *)(v6 + 36)) )
            {
              _EDX = 1;
              _ECX = v6 + 72;
              __asm { lock cmpxchg [ecx], edx }
              v18 = InterlockedFlushSList((PSLIST_HEADER)(v6 + 8));
              v19 = *(_DWORD *)(v6 + 36);
              *(_DWORD *)(v6 + 16) = v18;
              sub_1002ADAD(v6 + 20, (int (__cdecl *)(_DWORD))sub_1003CEA1, v6, v19);
            }
          }
        }
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003CFCC) --------------------------------------------------------
char __thiscall sub_1003CFCC(void *this, int a2)
{
  int v2; // ecx@2

  if ( *(_DWORD *)(a2 + 12) & 0xFFFFFFF )
    v2 = (int)((char *)this + 16);
  else
    v2 = (int)((char *)this + 96);
  return sub_1003CED1((void *)v2, a2, *(_DWORD *)(a2 + 248), 1);
}

//----- (1003CFF5) --------------------------------------------------------
int __thiscall sub_1003CFF5(int *this, int a2, int a3)
{
  unsigned int v3; // edi@1
  unsigned int v4; // esi@1
  int *v5; // esi@1
  int *v7; // [sp+10h] [bp-4h]@1

  v5 = this;
  v3 = 0;
  v7 = this;
  sub_10028E71(a2, a2, 0, *this);
  v4 = (unsigned int)(*v5 + 31) >> 5;
  if ( v4 )
  {
    do
    {
      *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * v3) = *(_DWORD *)(v7[1] + 4 * v3) & *(_DWORD *)(*(_DWORD *)(a3 + 4) + 4 * v3);
      ++v3;
    }
    while ( v3 < v4 );
  }
  return a2;
}

//----- (1003D045) --------------------------------------------------------
int __userpurge sub_1003D045<eax>(int a1<ecx>, int a2<edi>, int a3, int a4)
{
  int result; // eax@1
  int v5; // esi@1
  int v6; // ST14_4@1
  int v8; // eax@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // edx@1

  v5 = a1;
  v6 = a1 + 32;
  sub_10028AD5((void *)(a1 + 32));
  _EBX = v5 + 28;
  v8 = sub_10038564(v5, v5 + 28, a2, *(_DWORD *)(v5 + 28), 1);
  v9 = v8;
  v10 = *(_DWORD *)_EBX - *(_DWORD *)(v8 + 16);
  v11 = *(_DWORD *)(v8 + 12);
  _EAX = 1;
  *(_DWORD *)(v11 + 4 * v10) = a4;
  __asm { lock xadd [ebx], eax }
  *(_DWORD *)v6 = 0;
  result = a3;
  *(_DWORD *)(a3 + 4) = v10;
  *(_DWORD *)a3 = v9;
  return result;
}

//----- (1003D098) --------------------------------------------------------
int __thiscall sub_1003D098(int this, int a2)
{
  int v3; // ebx@1

  v3 = this;
  sub_1002C615((void *)(this + 8));
  *(_DWORD *)(a2 + 232) = 0;
  **(_DWORD **)(v3 + 4) = a2;
  *(_DWORD *)(v3 + 4) = a2 + 232;
  return sub_1002C625((void *)(v3 + 8));
}

//----- (1003D0CB) --------------------------------------------------------
int __thiscall sub_1003D0CB(int this, int a2)
{
  unsigned int v2; // edi@1
  unsigned int v3; // esi@1
  int result; // eax@2

  v3 = (unsigned int)(*(_DWORD *)this + 31) >> 5;
  v2 = 0;
  if ( v3 )
  {
    do
    {
      _EDX = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * v2);
      result = 4 * v2 + *(_DWORD *)(this + 4);
      __asm { lock or [eax], edx }
      ++v2;
    }
    while ( v2 < v3 );
  }
  return result;
}

//----- (1003D103) --------------------------------------------------------
int __userpurge sub_1003D103<eax>(int a1<ecx>, int a2<edi>, int a3, int a4, int a5, int a6)
{
  int v7; // eax@1

  v7 = (*(int (__stdcall **)(int, signed int))(*(_DWORD *)a1 + 20))(a5, 1);
  *(_DWORD *)a6 = v7;
  sub_1003D129(v7, a2, a3, a4);
  return a3;
}

//----- (1003D129) --------------------------------------------------------
int __userpurge sub_1003D129<eax>(int a1<ecx>, int a2<edi>, int a3, int a4)
{
  sub_1003D045(a1 + 52, a2, a3, a4);
  return a3;
}

//----- (1003D141) --------------------------------------------------------
int __thiscall sub_1003D141(int this)
{
  int result; // eax@1
  int v2; // edi@1
  int v3; // esi@1

  v3 = this;
  v2 = *(_DWORD *)(*(_DWORD *)(this + 256) + 4);
  sub_1003D174(*(void **)(*(_DWORD *)(this + 256) + 4), this + 28);
  result = *(_DWORD *)(v3 + 12) & 0xFFFFFFF;
  if ( result == 3 )
    result = sub_1003D1B2(v2, *(_DWORD *)(v3 + 36), v3);
  return result;
}

//----- (1003D174) --------------------------------------------------------
bool __thiscall sub_1003D174(void *this, int a2)
{
  bool result; // eax@1
  void *v3; // esi@1
  int v4; // eax@2
  char v5; // [sp+8h] [bp-8h]@2
  void *v6; // [sp+Ch] [bp-4h]@2

  v3 = this;
  result = sub_1002AD6F(a2, (int)((char *)this + 72));
  if ( result )
  {
    v4 = sub_1003CFF5((int *)a2, (int)&v5, (int)((char *)v3 + 72));
    sub_1003D0CB((int)((char *)v3 + 84), v4);
    result = sub_1002401B(v6);
  }
  return result;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (1003D1B2) --------------------------------------------------------
int __thiscall sub_1003D1B2(int this, int a2, int a3)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 92);
  if ( !*(_DWORD *)((a2 << 7) + result) )
  {
    _EDX = a3;
    _ECX = (a2 << 7) + *(_DWORD *)(this + 92);
    result = 0;
    __asm { lock cmpxchg [ecx], edx }
  }
  return result;
}

//----- (1003D1D8) --------------------------------------------------------
int __thiscall sub_1003D1D8(int this, int a2)
{
  return sub_1003D098(this + 288, a2);
}

//----- (1003D1E7) --------------------------------------------------------
int __thiscall sub_1003D1E7(int this, int a2, int a3)
{
  char v3; // zf@1
  int result; // eax@2
  int v5; // [sp+0h] [bp-10h]@1
  int v6; // [sp+8h] [bp-8h]@1
  int v7; // [sp+Ch] [bp-4h]@1

  v3 = (*(_BYTE *)(this + 48) & 4) == 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  if ( v3 )
    result = *(_DWORD *)(this + 56);
  else
    result = sub_1003834D((void *)this, (int)&v5, a3);
  return result;
}

//----- (1003D213) --------------------------------------------------------
int __thiscall sub_1003D213(int this, int a2, char a3)
{
  int v3; // esi@1
  char v4; // zf@1
  int result; // eax@2
  int v6; // eax@6
  int v7; // [sp+8h] [bp-10h]@1
  int v8; // [sp+10h] [bp-8h]@1
  int v9; // [sp+14h] [bp-4h]@1

  v3 = this;
  v7 = 0;
  v4 = (*(_BYTE *)(this + 48) & 4) == 0;
  v8 = 0;
  v9 = 0;
  if ( v4 )
  {
    result = *(_DWORD *)(this + 56);
    if ( a3 )
    {
      if ( !result )
      {
        sub_10028AD5((void *)(this + 8));
        result = *(_DWORD *)(v3 + 56);
        if ( !result )
        {
          v6 = sub_1002A552(*(_DWORD *)(v3 + 4));
          result = sub_100380E4((void *)v3, (int)&v7, v6);
          *(_DWORD *)(v3 + 56) = result;
        }
        *(_DWORD *)(v3 + 8) = 0;
      }
    }
  }
  else
  {
    result = sub_100385AE(this, (int)&v7, a3);
  }
  return result;
}

//----- (1003D279) --------------------------------------------------------
int __userpurge sub_1003D279<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4)
{
  int v4; // esi@1
  int v5; // ecx@1
  HANDLE v6; // eax@1
  int v7; // eax@2
  int v8; // eax@5
  int v9; // edx@5
  int v10; // ecx@5
  int v12; // ecx@8

  sub_1002D0B8();
  v4 = v5;
  *(_DWORD *)(a2 - 16) = v5;
  sub_100269FC(a1, a2, *(_DWORD *)(a2 + 8), 1);
  *(_DWORD *)(a2 - 4) = 0;
  *(_DWORD *)v4 = off_10059BD4;
  *(_DWORD *)(v4 + 160) = 0;
  *(_DWORD *)(v4 + 164) = 0;
  v6 = CreateEventW(0, 0, 0, 0);
  *(_DWORD *)(v4 + 168) = v6;
  if ( !v6 )
  {
    v7 = GetLastError();
    if ( v7 > 0 )
      v7 = (unsigned __int16)v7 | 0x80070000;
    sub_100249F4(a2 - 32, v7);
    sub_1002D02B(a2 - 32, (int)&unk_10060498);
  }
  *(_DWORD *)(v4 + 24) = sub_1002A1DB(*(_DWORD *)(v4 + 28));
  v8 = sub_10027EB3(v9, v10, a1, 0, 28);
  if ( v8 )
  {
    *(_DWORD *)(v8 + 8) = 0;
    *(_DWORD *)(v8 + 12) = 0;
    *(_DWORD *)(v8 + 16) = 0;
    *(_DWORD *)(v8 + 20) = 0;
    *(_DWORD *)(v8 + 24) = 1;
  }
  else
  {
    v8 = 0;
  }
  v12 = *(_DWORD *)(v4 + 28);
  *(_DWORD *)(v4 + 156) = v8;
  sub_10037D1C(v12 + 200, v8);
  sub_1003D511(v4, *(_DWORD *)(a2 + 12));
  return sub_1002D086(20);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10059BD4: using guessed type int (*off_10059BD4[5])();

//----- (1003D33F) --------------------------------------------------------
int __usercall sub_1003D33F<eax>(int a1<ebp>)
{
  int v2; // ecx@1
  void *v3; // esi@1

  sub_1002D0B8();
  v3 = (void *)v2;
  *(_DWORD *)(a1 - 16) = v2;
  *(_DWORD *)v2 = off_10059BD4;
  *(_DWORD *)(a1 - 4) = 0;
  sub_1003D3E6(v2, a1);
  sub_10026B16(v3);
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 10059BD4: using guessed type int (*off_10059BD4[5])();

//----- (1003D36C) --------------------------------------------------------
void *__thiscall sub_1003D36C(void *this, char a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1

  v3 = this;
  sub_1003D33F(ebp0);
  if ( a2 & 1 )
    sub_1002404A(v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1003D38B) --------------------------------------------------------
int __userpurge sub_1003D38B<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  int ebp0; // ebp@0

  if ( sub_1003D463(a1, ebp0, a3) )
    JUMPOUT(*(unsigned int *)loc_100286CD);
  return sub_100287ED(a2, a4);
}
// 100286CD: using guessed type _DWORD __cdecl loc_100286CD(_DWORD);

//----- (1003D3AC) --------------------------------------------------------
DWORD __thiscall sub_1003D3AC(int this)
{
  DWORD result; // eax@1
  int v2; // esi@1
  int v3; // ST0C_4@1
  int v4; // eax@1

  v2 = this;
  v3 = *(_DWORD *)(this + 8);
  v4 = (*(int (**)(void))(**(_DWORD **)(this + 28) + 4))();
  sub_10027BAF(3, 4, v4, v3);
  _ECX = v2 + 44;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  result = _EAX + 1;
  if ( result == 1 )
    result = WaitForSingleObject(*(HANDLE *)(v2 + 168), 0xFFFFFFFFu);
  return result;
}

//----- (1003D3E6) --------------------------------------------------------
int __usercall sub_1003D3E6<eax>(int a1<ecx>, int a2<ebp>)
{
  int v2; // esi@1
  int result; // eax@7

  v2 = a1;
  sub_10026F8C(a1, a2);
  if ( *(_DWORD *)(v2 + 164) )
  {
    CloseHandle(*(HANDLE *)(v2 + 164));
    *(_DWORD *)(v2 + 164) = 0;
  }
  if ( *(_DWORD *)(v2 + 168) )
    CloseHandle(*(HANDLE *)(v2 + 168));
  if ( *(_DWORD *)(v2 + 160) )
    sub_1002BA1E(*(void **)(v2 + 160));
  result = *(_DWORD *)(v2 + 156);
  *(_DWORD *)(v2 + 156) = 0;
  *(_DWORD *)(result + 24) = 0;
  return result;
}

//----- (1003D43E) --------------------------------------------------------
char __userpurge sub_1003D43E<al>(void *this<ecx>, int edi0<edi>, int a2)
{
  int v3; // eax@1
  int ebp0; // ebp@0
  char result; // al@2

  v3 = sub_1003D463((int)this, ebp0, edi0);
  if ( v3 )
    result = sub_10028761((void *)v3, a2);
  else
    result = sub_1002401B((LPVOID)(a2 - 4));
  return result;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (1003D463) --------------------------------------------------------
int __usercall sub_1003D463<eax>(int a1<ecx>, int a2<ebp>, int a3<edi>)
{
  int v3; // esi@1

  v3 = a1;
  if ( !*(_DWORD *)(a1 + 160) )
    *(_DWORD *)(a1 + 160) = sub_1002A68A(a2, a3);
  return *(_DWORD *)(v3 + 160);
}

//----- (1003D485) --------------------------------------------------------
signed int __cdecl sub_1003D485()
{
  return -1;
}

//----- (1003D489) --------------------------------------------------------
int __stdcall sub_1003D489(int a1, int a2, int a3, int a4)
{
  sub_10029D8B(*(void **)(a2 + 28), a2, 0);
  return sub_1002C5E0(a1, a3);
}

//----- (1003D4AB) --------------------------------------------------------
char __stdcall sub_1003D4AB(int a1, int a2)
{
  UnregisterWait(*(HANDLE *)(a1 + 172));
  return sub_10029D8B(*(void **)(a1 + 28), a1, 0);
}

//----- (1003D4CE) --------------------------------------------------------
bool __thiscall sub_1003D4CE(int this)
{
  return *(_DWORD *)(this + 44) == 1;
}

//----- (1003D4DA) --------------------------------------------------------
void __thiscall sub_1003D4DA(int this, char a2)
{
  int v2; // eax@3
  char v3; // [sp+0h] [bp-Ch]@6

  if ( a2 )
  {
    ++*(_DWORD *)(this + 20);
  }
  else
  {
    v2 = *(_DWORD *)(this + 20);
    if ( !v2 )
    {
      sub_10024962((int)&v3);
      sub_1002D02B((int)&v3, (int)&unk_10060EF8);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1003D511);
    }
    *(_DWORD *)(this + 20) = v2 - 1;
  }
}

//----- (1003D511) --------------------------------------------------------
DWORD __thiscall sub_1003D511(int Context, char a2)
{
  DWORD result; // eax@1
  int v3; // edi@1
  HANDLE *v4; // ebx@2
  HANDLE v5; // ST08_4@2
  HANDLE v6; // ST04_4@2
  HANDLE v7; // eax@2
  int v8; // eax@3
  char v9; // [sp+8h] [bp-10h]@13

  v3 = Context;
  *(_BYTE *)(Context + 152) = a2;
  result = GetCurrentThreadId();
  *(_DWORD *)(v3 + 68) = result;
  if ( !a2 )
  {
    v4 = (HANDLE *)(v3 + 164);
    v5 = GetCurrentProcess();
    v6 = GetCurrentThread();
    v7 = GetCurrentProcess();
    if ( !DuplicateHandle(v7, v6, v5, (LPHANDLE)(v3 + 164), 0, 0, 2u) )
    {
      v8 = GetLastError();
      if ( v8 > 0 )
LABEL_12:
        v8 = (unsigned __int16)v8 | 0x80070000;
LABEL_13:
      sub_100249F4((int)&v9, v8);
      sub_1002D02B((int)&v9, (int)&unk_10060498);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1003D5DE);
    }
    if ( sub_10034C33() < 3 )
    {
      result = RegisterWaitForSingleObject(
                 (PHANDLE)(v3 + 172),
                 *v4,
                 (WAITORTIMERCALLBACK)sub_1003D4AB,
                 (PVOID)v3,
                 0xFFFFFFFFu,
                 0xCu);
    }
    else
    {
      result = sub_1002C56C((int)*v4, (int)sub_1003D489, v3);
      *(_DWORD *)(v3 + 172) = result;
    }
    if ( !result )
    {
      v8 = GetLastError();
      if ( v8 > 0 )
        goto LABEL_12;
      goto LABEL_13;
    }
  }
  return result;
}
// 10034C33: using guessed type int sub_10034C33(void);

//----- (1003D5DE) --------------------------------------------------------
BOOL __usercall sub_1003D5DE<eax>(int a1<ecx>, int a2<ebp>)
{
  BOOL result; // eax@1
  int v3; // esi@1

  v3 = a1;
  sub_10027673(a1, a2);
  result = *(_DWORD *)(v3 + 164);
  if ( result )
  {
    result = CloseHandle(*(HANDLE *)(v3 + 164));
    *(_DWORD *)(v3 + 164) = 0;
  }
  return result;
}

//----- (1003D600) --------------------------------------------------------
int __thiscall sub_1003D600(void *this)
{
  return (*(int (**)(void))(*(_DWORD *)this + 28))();
}

//----- (1003D605) --------------------------------------------------------
int __thiscall sub_1003D605(void *this)
{
  void *v1; // esi@1
  int v2; // ecx@2
  int v3; // ST0C_4@2
  int v4; // eax@2
  int result; // eax@3
  int v13; // ecx@8
  int v14; // eax@8
  int v15; // ST10_4@8
  int v16; // [sp-4h] [bp-14h]@6
  char v17; // [sp+4h] [bp-Ch]@6
  int v18; // [sp+8h] [bp-8h]@8
  int v19; // [sp+Ch] [bp-4h]@8

  v1 = this;
  if ( this == sub_10029DCE() )
  {
    sub_100248A2((int)&v17);
    v16 = (int)&unk_10060EC0;
    goto LABEL_8;
  }
  v3 = *((_DWORD *)v1 + 2);
  v4 = (*(int (**)(void))(**((_DWORD **)v1 + 7) + 4))();
  sub_10027BAF(4, 4, v4, v3);
  _EAX = (int)((char *)v1 + 44);
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  v2 = _ECX - 1;
  if ( !v2 )
    return SetEvent(*((HANDLE *)v1 + 42));
  result = v2 + 1;
  if ( (unsigned int)(v2 + 1) > 1 )
  {
    sub_100248B4((int)&v17);
    v16 = (int)&unk_10060E88;
LABEL_8:
    sub_1002D02B((int)&v17, v16);
    __asm { int     3               ; Trap to Debugger }
    v14 = (*(int (__stdcall **)(_DWORD, void *, int, _DWORD, int))(**(_DWORD **)(v13 + 28) + 4))(
            *(_DWORD *)(v13 + 8),
            v1,
            v15,
            *(_DWORD *)&v17,
            v18);
    sub_10027BAF(5, 4, v14, v19);
    result = SwitchToThread();
  }
  return result;
}

//----- (1003D69B) --------------------------------------------------------
void *__thiscall sub_1003D69B(void *this, int a2)
{
  void *v3; // esi@1

  v3 = this;
  sub_1003B9AF(this, a2);
  *(_DWORD *)v3 = off_10059C40;
  *((_DWORD *)v3 + 1) = off_10059C6C;
  return v3;
}
// 10059C40: using guessed type int (*off_10059C40[3])();
// 10059C6C: using guessed type int (*off_10059C6C[5])();

//----- (1003D6BD) --------------------------------------------------------
void *__thiscall sub_1003D6BD(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v4; // edi@1

  v4 = this;
  *(_DWORD *)this = off_10059C20;
  sub_10028EB7(ebp0, a2);
  *(_DWORD *)v4 = off_10059CB8;
  *((_DWORD *)v4 + 2) = &off_10059CDC;
  return v4;
}
// 10059C20: using guessed type int (*off_10059C20[7])();
// 10059CB8: using guessed type int (*off_10059CB8[2])();
// 10059CDC: using guessed type int (__stdcall *off_10059CDC)(int);

//----- (1003D6EA) --------------------------------------------------------
int __thiscall sub_1003D6EA(int this)
{
  *(_DWORD *)this = off_10059CB8;
  *(_DWORD *)(this + 8) = &off_10059CDC;
  return sub_10029307(this);
}
// 10029307: using guessed type _DWORD __thiscall sub_10029307(_DWORD ecx0);
// 10059CB8: using guessed type int (*off_10059CB8[2])();
// 10059CDC: using guessed type int (__stdcall *off_10059CDC)(int);

//----- (1003D6FE) --------------------------------------------------------
void __stdcall sub_1003D6FE(int a1)
{
  JUMPOUT(*(unsigned int *)loc_1003D70E);
}
// 1003D70E: using guessed type int __stdcall loc_1003D70E(int);

//----- (1003D706) --------------------------------------------------------
void *__thiscall sub_1003D706(void *this, char a2)
{
  void *v2; // esi@1

  v2 = (char *)this - 8;
  sub_1003D6EA((int)((char *)this - 8));
  if ( a2 & 1 )
    sub_1002404A(v2);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1003D759) --------------------------------------------------------
int __thiscall sub_1003D759(void *this, int a2, unsigned int a3)
{
  return sub_1002969D((char *)this + 8, a2, a3);
}

//----- (1003D765) --------------------------------------------------------
int __usercall sub_1003D765<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // ecx@1
  int v4; // edx@1
  int v5; // ecx@1

  sub_1002D0B8();
  v3 = sub_10027EB3(v4, v5, a1, a3, 520);
  *(_DWORD *)(a2 - 16) = v3;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v3 )
    sub_1003D6BD((void *)v3, *(_DWORD *)(a2 + 8));
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1003D798) --------------------------------------------------------
int __usercall sub_1003D798<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // edx@1
  int v4; // esi@1
  int v5; // ecx@1
  int v6; // edx@1

  sub_1002D0B8();
  v4 = v5;
  v3 = sub_10027EB3(v6, v5, a1, a3, 240);
  *(_DWORD *)(a2 - 16) = v3;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v3 )
    sub_1003D69B((void *)v3, v4 != 8 ? v4 : 0);
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1003D7D6) --------------------------------------------------------
int __userpurge sub_1003D7D6<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5)
{
  int v5; // eax@1
  int v6; // edx@1
  int v7; // ecx@1

  sub_1002D0B8();
  v5 = sub_10027EB3(v6, v7, a1, a3, 208);
  *(_DWORD *)(a2 - 16) = v5;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v5 )
    sub_10048BE2(a2, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12));
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1003D80E) --------------------------------------------------------
signed int __cdecl sub_1003D80E()
{
  return 1;
}

//----- (1003D812) --------------------------------------------------------
int __thiscall sub_1003D812(void *this)
{
  return (int)((char *)this - 8);
}

//----- (1003D816) --------------------------------------------------------
int __thiscall sub_1003D816(int this)
{
  return (*(int (**)(void))(*(_DWORD *)(this + 8) + 4))();
}

//----- (1003D81E) --------------------------------------------------------
int __userpurge sub_1003D81E<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  sub_1002A5CE(a1, a2 + 8, a3, a4, a5);
  return a5;
}

//----- (1003D838) --------------------------------------------------------
int __userpurge sub_1003D838<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  return sub_1003D81E(a1, a2 - 8, a3, a4, a5);
}

//----- (1003D843) --------------------------------------------------------
int __thiscall sub_1003D843(void *this, int a2, unsigned int a3)
{
  return sub_1002B8DB((char *)this + 8, a2, a3);
}

//----- (1003D84F) --------------------------------------------------------
int __thiscall sub_1003D84F(void *this, int a2, int a3, int a4)
{
  return sub_1002BC7B((char *)this + 8, a2, a3, a4);
}

//----- (1003D85B) --------------------------------------------------------
DWORD __cdecl sub_1003D85B()
{
  DWORD result; // eax@1
  int v1; // eax@2
  char v2; // [sp+0h] [bp-10h]@5

  result = TlsAlloc();
  dword_10069CD0 = result;
  if ( result == -1 )
  {
    v1 = GetLastError();
    if ( v1 > 0 )
      v1 = (unsigned __int16)v1 | 0x80070000;
    sub_100249F4((int)&v2, v1);
    sub_1002D02B((int)&v2, (int)&unk_10060498);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003D89F);
  }
  return result;
}

//----- (1003D89F) --------------------------------------------------------
BOOL __cdecl sub_1003D89F()
{
  BOOL result; // eax@1

  result = TlsFree(dword_10069CD0);
  dword_10069CD0 = 0;
  return result;
}

//----- (1003D8B3) --------------------------------------------------------
signed int __usercall sub_1003D8B3<eax>(int a1<ecx>, int a2<ebx>)
{
  unsigned int v2; // eax@1
  void *v3; // eax@6
  signed int result; // eax@8
  int v5; // edx@9
  signed int v6; // ecx@9
  int v7; // [sp-4h] [bp-8h]@6

  v2 = dword_1006A39C;
  if ( !dword_1006A39C )
  {
    v2 = 512;
LABEL_5:
    dword_1006A39C = v2;
    goto LABEL_6;
  }
  if ( dword_1006A39C < 20 )
  {
    v2 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v3 = sub_1002EFE1(a1, a2, v2, 4u);
  dword_1006A398 = v3;
  if ( v3 || (dword_1006A39C = 20, v3 = sub_1002EFE1(v7, a2, 0x14u, 4u), dword_1006A398 = v3, v3) )
  {
    v5 = 0;
    v6 = (signed int)&off_10067790;
    while ( 1 )
    {
      *(_DWORD *)((char *)v3 + v5) = v6;
      v6 += 32;
      v5 += 4;
      if ( v6 >= (signed int)&unk_10067A10 )
        break;
      v3 = dword_1006A398;
    }
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 10067790: using guessed type void *off_10067790;
// 1006A39C: using guessed type int dword_1006A39C;

//----- (1003D926) --------------------------------------------------------
void __usercall sub_1003D926(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v3; // edx@1
  int v4; // ecx@1

  sub_1003DAD3(a1, a2, a3);
  if ( byte_100695CC )
    sub_10048C3E(v3, v4, a3);
  sub_100282F6(a3, dword_1006A398);
  dword_1006A398 = 0;
}
// 100695CC: using guessed type char byte_100695CC;

//----- (1003D94D) --------------------------------------------------------
void **__cdecl sub_1003D94D()
{
  return &off_10067790;
}
// 10067790: using guessed type void *off_10067790;

//----- (1003D953) --------------------------------------------------------
void __usercall sub_1003D953(int a1<edx>, int a2<ebx>, int a3<edi>, unsigned int a4)
{
  if ( a4 < (unsigned int)&off_10067790 || a4 > (unsigned int)&unk_100679F0 )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(a4 + 32));
  }
  else
  {
    sub_1002E493(a1, (int)&off_10067790, a2, a3, ((signed int)(a4 - (_DWORD)&off_10067790) >> 5) + 16);
    *(_DWORD *)(a4 + 12) |= 0x8000u;
  }
}
// 10067790: using guessed type void *off_10067790;

//----- (1003D992) --------------------------------------------------------
void __usercall sub_1003D992(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5, int a6)
{
  if ( a5 >= 20 )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(a6 + 32));
  }
  else
  {
    sub_1002E493(a1, a2, a3, a4, a5 + 16);
    *(_DWORD *)(a6 + 12) |= 0x8000u;
  }
}

//----- (1003D9C2) --------------------------------------------------------
void __cdecl sub_1003D9C2(unsigned int a1)
{
  if ( a1 < (unsigned int)&off_10067790 || a1 > (unsigned int)&unk_100679F0 )
  {
    LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 32));
  }
  else
  {
    *(_DWORD *)(a1 + 12) &= 0xFFFF7FFFu;
    sub_1002E5F7(((signed int)(a1 - (_DWORD)&off_10067790) >> 5) + 16);
  }
}
// 10067790: using guessed type void *off_10067790;

//----- (1003D9FC) --------------------------------------------------------
void __cdecl sub_1003D9FC(signed int a1, int a2)
{
  if ( a1 >= 20 )
  {
    LeaveCriticalSection((LPCRITICAL_SECTION)(a2 + 32));
  }
  else
  {
    *(_DWORD *)(a2 + 12) &= 0xFFFF7FFFu;
    sub_1002E5F7(a1 + 16);
  }
}

//----- (1003DA29) --------------------------------------------------------
void __usercall sub_1003DA29(int a1<ebx>, int a2<edi>, int edx0<edx>, int a4<ecx>, int a3)
{
  int v5; // eax@6
  int v6; // edx@6
  int v7; // ecx@6

  if ( a3 )
  {
    if ( !sub_1003DA6F(a3) )
    {
      if ( *(_DWORD *)(a3 + 12) & 0x4000 )
      {
        v5 = sub_1004494B(a1, a2, a3);
        sub_10048CDB(v6, v7, a1, v5);
      }
    }
  }
  else
  {
    sub_1003DADC(edx0, a4, a1, 0);
  }
}

//----- (1003DA6F) --------------------------------------------------------
signed int __cdecl sub_1003DA6F(int a1)
{
  signed int v1; // ebx@1
  int v2; // edi@3
  int v3; // ST08_4@4
  const void *v4; // ST04_4@4
  int v5; // eax@4
  int v6; // edx@4
  int v7; // ST00_4@4
  int v8; // eax@4
  int v9; // eax@5
  int v11; // ecx@8

  v1 = 0;
  if ( (*(_DWORD *)(a1 + 12) & 3) == 2 )
  {
    if ( *(_DWORD *)(a1 + 12) & 0x108 )
    {
      v2 = *(_DWORD *)a1 - *(_DWORD *)(a1 + 8);
      if ( *(_DWORD *)a1 - *(_DWORD *)(a1 + 8) > 0 )
      {
        v3 = *(_DWORD *)a1 - *(_DWORD *)(a1 + 8);
        v4 = *(const void **)(a1 + 8);
        v5 = sub_1004494B(0, v2, a1);
        sub_10044BAE(v6, v7, 0, v2, v5, v4, v3);
        if ( v8 == v2 )
        {
          v9 = *(_DWORD *)(a1 + 12);
          if ( (_BYTE)v9 < 0 )
            *(_DWORD *)(a1 + 12) = v9 & 0xFFFFFFFD;
        }
        else
        {
          *(_DWORD *)(a1 + 12) |= 0x20u;
          v1 = -1;
        }
      }
    }
  }
  v11 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = v11;
  return v1;
}

//----- (1003DAD3) --------------------------------------------------------
void __usercall sub_1003DAD3(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  sub_1003DADC(a1, a2, a3, 1);
}

//----- (1003DADC) --------------------------------------------------------
void __usercall sub_1003DADC(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // edx@1
  signed int i; // esi@1
  int v6; // eax@3
  int v7; // eax@5
  int v8; // edx@5
  int v9; // eax@7
  int v10; // [sp-4h] [bp-38h]@1
  int v11; // [sp-4h] [bp-38h]@5

  sub_1002E493(a1, a2, a3, 0, 1);
  for ( i = 0; ; ++i )
  {
    if ( i >= dword_1006A39C )
    {
      sub_1002E5F7(1);
      return;
    }
    v6 = *((_DWORD *)dword_1006A398 + i);
    if ( v6 )
    {
      if ( *(_BYTE *)(v6 + 12) & 0x83 )
        break;
    }
  }
  sub_1003D992(v4, v10, a4, 0, i, *((_DWORD *)dword_1006A398 + i));
  v7 = *((_DWORD *)dword_1006A398 + i);
  if ( *(_BYTE *)(v7 + 12) & 0x83 )
  {
    if ( a4 == 1 )
    {
      sub_1003DA29(1, 0, v8, v11, *((_DWORD *)dword_1006A398 + i));
      v9 == -1;
    }
    else
    {
      if ( !a4 )
      {
        if ( *(_BYTE *)(v7 + 12) & 2 )
          sub_1003DA29(a4, 0, v8, v11, *((_DWORD *)dword_1006A398 + i));
      }
    }
  }
  sub_1003D9FC(i, *((_DWORD *)dword_1006A398 + i));
}
// 1006A39C: using guessed type int dword_1006A39C;

//----- (1003DC35) --------------------------------------------------------
int __usercall sub_1003DC35<eax>(int a1<ebx>, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // edx@2
  unsigned int v6; // ecx@2
  void (__cdecl *v7)(_DWORD); // edx@9
  int v8; // ebx@14
  signed int v9; // edi@15
  int v10; // edi@17
  int v11; // ST04_4@36

  result = sub_10031BEF(a1);
  v4 = result;
  if ( result )
  {
    v5 = *(_DWORD *)(result + 92);
    v6 = *(_DWORD *)(result + 92);
    do
    {
      if ( *(_DWORD *)v6 == a2 )
        break;
      v6 += 12;
    }
    while ( v6 < v5 + 144 );
    if ( v6 >= v5 + 144 || *(_DWORD *)v6 != a2 )
      v6 = 0;
    if ( v6 && (v7 = *(void (__cdecl **)(_DWORD))(v6 + 8)) != 0 )
    {
      if ( v7 == (void (__cdecl *)(_DWORD))5 )
      {
        *(_DWORD *)(v6 + 8) = 0;
        result = 1;
      }
      else
      {
        if ( v7 == (void (__cdecl *)(_DWORD))1 )
        {
          result = -1;
        }
        else
        {
          v8 = *(_DWORD *)(result + 96);
          *(_DWORD *)(result + 96) = a3;
          if ( *(_DWORD *)(v6 + 4) == 8 )
          {
            v9 = 36;
            do
            {
              v9 += 12;
              *(_DWORD *)(v9 + *(_DWORD *)(result + 92) - 4) = 0;
            }
            while ( v9 < 144 );
            v10 = *(_DWORD *)(result + 100);
            switch ( *(_DWORD *)v6 )
            {
              case 0xC000008E:
                *(_DWORD *)(result + 100) = 131;
                break;
              case 0xC0000090:
                *(_DWORD *)(result + 100) = 129;
                break;
              case 0xC0000091:
                *(_DWORD *)(result + 100) = 132;
                break;
              case 0xC0000093:
                *(_DWORD *)(result + 100) = 133;
                break;
              case 0xC000008D:
                *(_DWORD *)(result + 100) = 130;
                break;
              case 0xC000008F:
                *(_DWORD *)(result + 100) = 134;
                break;
              case 0xC0000092:
                *(_DWORD *)(result + 100) = 138;
                break;
              case 0xC00002B5:
                *(_DWORD *)(result + 100) = 141;
                break;
              case 0xC00002B4:
                *(_DWORD *)(result + 100) = 142;
                break;
            }
            v7(8);
            *(_DWORD *)(v4 + 100) = v10;
          }
          else
          {
            v11 = *(_DWORD *)(v6 + 4);
            *(_DWORD *)(v6 + 8) = 0;
            v7(v11);
          }
          *(_DWORD *)(v4 + 96) = v8;
          result = -1;
        }
      }
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (1003DD90) --------------------------------------------------------
int __usercall sub_1003DD90<eax>(int a1<ebx>, int a2, int a3)
{
  int result; // eax@2

  if ( a2 == -529697949 )
    result = sub_1003DC35(a1, -529697949, a3);
  else
    result = 0;
  return result;
}

//----- (1003DDAE) --------------------------------------------------------
void __usercall sub_1003DDAE(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int ebp0; // ebp@0
  int v5; // eax@1
  unsigned int v6; // ecx@1
  signed int v7; // ebx@1
  int v8; // ST08_4@1
  int v9; // ecx@8
  signed int v10; // esi@10
  int v11; // eax@12
  unsigned int v12; // ecx@12
  int v13; // eax@14
  HANDLE *v14; // edx@14
  signed int v15; // edi@14
  char v16; // al@18
  DWORD v17; // eax@20
  int v18; // esi@21
  int v19; // esi@29
  DWORD v20; // eax@33
  HANDLE v21; // eax@35
  HANDLE v22; // edi@35
  DWORD v23; // eax@37
  int v24; // eax@38
  char v25; // al@39
  struct _STARTUPINFOW StartupInfo; // [sp+10h] [bp-74h]@6
  int v27; // [sp+54h] [bp-30h]@10
  int v28; // [sp+58h] [bp-2Ch]@14
  LPBYTE v29; // [sp+5Ch] [bp-28h]@8
  unsigned int v30; // [sp+60h] [bp-24h]@1
  BYTE *v31; // [sp+64h] [bp-20h]@8
  int v32; // [sp+68h] [bp-1Ch]@8
  CPPEH_RECORD ms_exc; // [sp+6Ch] [bp-18h]@1

  sub_1002E493(a1, a2, a3, a4, 11);
  v7 = 0;
  ms_exc.disabled = 0;
  v5 = (int)sub_1002EFE1(v8, 0, 0x20u, 0x40u);
  v6 = v5;
  v30 = v5;
  if ( !v5 )
  {
    sub_100422F0(ebp0, (int)&__security_cookie, (int)&ms_exc.prev_er, 0xFFFFFFFEu);
    return;
  }
  dword_10069CE0[0] = v5;
  dword_1006A394 = 32;
  while ( v6 < v5 + 2048 )
  {
    *(_WORD *)(v6 + 4) = 2560;
    *(_DWORD *)v6 = -1;
    *(_DWORD *)(v6 + 8) = 0;
    *(_BYTE *)(v6 + 36) &= 0x80u;
    *(_BYTE *)(v6 + 36) &= 0x7Fu;
    *(_WORD *)(v6 + 37) = 2570;
    *(_WORD *)(v6 + 52) = 0;
    v6 += 64;
    v30 = v6;
    v5 = dword_10069CE0[0];
  }
  GetStartupInfoW(&StartupInfo);
  if ( StartupInfo.cbReserved2 && StartupInfo.lpReserved2 )
  {
    v9 = *(_DWORD *)StartupInfo.lpReserved2;
    v32 = v9;
    v29 = StartupInfo.lpReserved2 + 4;
    v31 = &StartupInfo.lpReserved2[v9 + 4];
    if ( v9 >= 2048 )
    {
      v9 = 2048;
      v32 = 2048;
    }
    v10 = 1;
    v27 = 1;
    while ( 1 )
    {
      if ( dword_1006A394 >= v9 )
        goto LABEL_14;
      v11 = (int)sub_1002EFE1(v9, 0, 0x20u, 0x40u);
      v12 = v11;
      v30 = v11;
      if ( !v11 )
      {
        v9 = dword_1006A394;
        v32 = dword_1006A394;
LABEL_14:
        v15 = 0;
        v28 = 0;
        v13 = (int)v29;
        v14 = (HANDLE *)v31;
        while ( v15 < v9 )
        {
          if ( *v14 != (HANDLE)-1 )
          {
            if ( *v14 != (HANDLE)-2 )
            {
              v16 = *(_BYTE *)v13;
              if ( v16 & 1 )
              {
                if ( v16 & 8 || (v17 = GetFileType(*v14), v14 = (HANDLE *)v31, v17) )
                {
                  v18 = dword_10069CE0[v15 >> 5] + ((v15 & 0x1F) << 6);
                  v30 = v18;
                  *(_DWORD *)v18 = *v14;
                  *(_BYTE *)(v18 + 4) = *v29;
                  InitializeCriticalSectionAndSpinCount((LPCRITICAL_SECTION)(v18 + 12), 0xFA0u);
                  ++*(_DWORD *)(v18 + 8);
                  v14 = (HANDLE *)v31;
                }
                v9 = v32;
              }
            }
          }
          ++v15;
          v28 = v15;
          v13 = (int)(v29++ + 1);
          ++v14;
          v31 = (BYTE *)v14;
        }
        break;
      }
      dword_10069CE0[v10] = v11;
      dword_1006A394 += 32;
      while ( v12 < dword_10069CE0[v10] + 2048 )
      {
        *(_WORD *)(v12 + 4) = 2560;
        *(_DWORD *)v12 = -1;
        *(_DWORD *)(v12 + 8) = 0;
        *(_BYTE *)(v12 + 36) &= 0x80u;
        *(_WORD *)(v12 + 37) = 2570;
        *(_WORD *)(v12 + 52) = 0;
        v12 += 64;
        v30 = v12;
      }
      ++v10;
      v27 = v10;
      v9 = v32;
    }
  }
  while ( 1 )
  {
    v28 = v7;
    if ( v7 >= 3 )
      break;
    v19 = dword_10069CE0[0] + (v7 << 6);
    v30 = v19;
    if ( *(_DWORD *)v19 != -1 && *(_DWORD *)v19 != -2 )
    {
      *(_BYTE *)(v19 + 4) |= 0x80u;
      goto LABEL_46;
    }
    *(_BYTE *)(v19 + 4) = -127;
    if ( v7 )
      v20 = -(v7 != 1) - 11;
    else
      v20 = -10;
    v21 = GetStdHandle(v20);
    v22 = v21;
    if ( v21 != (HANDLE)-1 )
    {
      if ( v21 )
      {
        v23 = GetFileType(v21);
        if ( v23 )
        {
          *(_DWORD *)v19 = v22;
          v24 = (unsigned __int8)v23;
          if ( v24 == 2 )
          {
            v25 = *(_BYTE *)(v19 + 4) | 0x40;
            goto LABEL_42;
          }
          if ( v24 == 3 )
          {
            v25 = *(_BYTE *)(v19 + 4) | 8;
LABEL_42:
            *(_BYTE *)(v19 + 4) = v25;
          }
          InitializeCriticalSectionAndSpinCount((LPCRITICAL_SECTION)(v19 + 12), 0xFA0u);
          ++*(_DWORD *)(v19 + 8);
          goto LABEL_46;
        }
      }
    }
    *(_BYTE *)(v19 + 4) |= 0x40u;
    *(_DWORD *)v19 = -2;
    if ( dword_1006A398 )
      *(_DWORD *)(*((_DWORD *)dword_1006A398 + v7) + 16) = -2;
LABEL_46:
    ++v7;
  }
  ms_exc.disabled = -2;
  sub_1002E5F7(11);
}
// 10067210: using guessed type int __security_cookie;
// 10069CE0: using guessed type int dword_10069CE0[];
// 1006A394: using guessed type int dword_1006A394;

//----- (1003E05C) --------------------------------------------------------
void __usercall sub_1003E05C(int a1<ebx>)
{
  LPVOID *v1; // esi@1
  LPVOID v2; // edi@2
  struct _RTL_CRITICAL_SECTION *v3; // edi@4

  v1 = (LPVOID *)dword_10069CE0;
  do
  {
    v2 = *v1;
    if ( *v1 )
    {
      if ( v2 < (char *)v2 + 2048 )
      {
        v3 = (struct _RTL_CRITICAL_SECTION *)((char *)v2 + 12);
        do
        {
          if ( *((_DWORD *)v3 - 1) )
            DeleteCriticalSection(v3);
          v3 = (struct _RTL_CRITICAL_SECTION *)((char *)v3 + 64);
        }
        while ( (char *)((char *)v3 - 12) < (char *)*v1 + 2048 );
      }
      sub_100282F6(a1, *v1);
      *v1 = 0;
    }
    ++v1;
  }
  while ( (signed int)v1 < (signed int)byte_10069DE0 );
}
// 10069CE0: using guessed type int dword_10069CE0[];

//----- (1003E0AE) --------------------------------------------------------
signed int __usercall sub_1003E0AE<eax>(int a1<ebx>)
{
  int v1; // esi@3
  int v2; // ebx@6
  int v3; // edx@8
  int v4; // edi@9
  signed int result; // eax@10
  int v6; // [sp+0h] [bp-8h]@6
  int v7; // [sp+4h] [bp-4h]@6

  if ( !dword_1006B3B0 )
    sub_1003F9D0(a1);
  byte_10069EE4 = 0;
  GetModuleFileNameA(0, byte_10069DE0, 0x104u);
  v1 = dword_1006B434;
  dword_100695F4 = (int)byte_10069DE0;
  if ( !dword_1006B434 || !*(_BYTE *)dword_1006B434 )
    v1 = (int)byte_10069DE0;
  sub_1003E15F(v1, 0, 0, (int)&v7, (int)&v6);
  v2 = v7;
  if ( (unsigned int)v7 < 0x3FFFFFFF
    && (unsigned int)v6 < 0xFFFFFFFF
    && (v3 = v6 + 4 * v7, v3 >= (unsigned int)v6)
    && (v4 = sub_1002F02B(v3, v6, v7, v6 + 4 * v7)) != 0 )
  {
    sub_1003E15F(v1, v4, v4 + 4 * v2, (int)&v7, (int)&v6);
    dword_100695E0 = v7 - 1;
    dword_100695E4 = (LPVOID)v4;
    result = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 100695E0: using guessed type int dword_100695E0;
// 100695F4: using guessed type int dword_100695F4;
// 10069EE4: using guessed type char byte_10069EE4;
// 1006B3B0: using guessed type int dword_1006B3B0;
// 1006B434: using guessed type int dword_1006B434;

//----- (1003E15F) --------------------------------------------------------
int __cdecl sub_1003E15F(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // esi@1
  bool v8; // ecx@3
  char v9; // al@5
  unsigned __int8 v10; // ST00_1@8
  signed int v11; // edx@29
  unsigned int v12; // ecx@29
  unsigned __int8 v13; // al@43
  signed int v14; // eax@48
  int result; // eax@61
  bool v16; // [sp+14h] [bp+8h]@3
  bool v17; // [sp+24h] [bp+18h]@20
  char v18; // [sp+27h] [bp+1Bh]@8

  v5 = a5;
  *(_DWORD *)a5 = 0;
  v7 = a1;
  *(_DWORD *)a4 = 1;
  v6 = a3;
  if ( a2 )
  {
    *(_DWORD *)a2 = a3;
    a2 += 4;
  }
  v8 = 0;
  v16 = 0;
  do
  {
    if ( *(_BYTE *)v7 == 34 )
    {
      ++v7;
      v8 = v8 == 0;
      v16 = v8;
      v9 = 34;
    }
    else
    {
      ++*(_DWORD *)v5;
      if ( v6 )
        *(_BYTE *)v6++ = *(_BYTE *)v7;
      v18 = *(_BYTE *)v7;
      v10 = *(_BYTE *)v7++;
      if ( sub_1002F1EE(v5, v6, v10) )
      {
        ++*(_DWORD *)v5;
        if ( v6 )
          *(_BYTE *)v6++ = *(_BYTE *)v7;
        ++v7;
      }
      v9 = v18;
      if ( !v18 )
      {
        --v7;
        goto LABEL_20;
      }
      v8 = v16;
    }
  }
  while ( v8 || v9 != 32 && v9 != 9 );
  if ( v6 )
    *(_BYTE *)(v6 - 1) = 0;
LABEL_20:
  v17 = 0;
  while ( *(_BYTE *)v7 )
  {
    while ( *(_BYTE *)v7 == 32 || *(_BYTE *)v7 == 9 )
      ++v7;
    if ( !*(_BYTE *)v7 )
      break;
    if ( a2 )
    {
      *(_DWORD *)a2 = v6;
      a2 += 4;
    }
    ++*(_DWORD *)a4;
    while ( 1 )
    {
      v11 = 1;
      v12 = 0;
      while ( *(_BYTE *)v7 == 92 )
      {
        ++v7;
        ++v12;
      }
      if ( *(_BYTE *)v7 == 34 )
      {
        if ( !(v12 & 1) )
        {
          if ( v17 && *(_BYTE *)(v7 + 1) == 34 )
          {
            ++v7;
          }
          else
          {
            v11 = 0;
            v17 = v17 == 0;
          }
        }
        v12 >>= 1;
      }
      while ( v12 )
      {
        --v12;
        if ( v6 )
          *(_BYTE *)v6++ = 92;
        ++*(_DWORD *)v5;
      }
      v13 = *(_BYTE *)v7;
      if ( !*(_BYTE *)v7 )
        break;
      if ( v17 == v12 && (v13 == 32 || v13 == 9) )
        break;
      if ( v11 )
      {
        v14 = sub_1002F1EE(v5, v6, v13);
        if ( v6 )
        {
          if ( v14 )
          {
            *(_BYTE *)v6++ = *(_BYTE *)v7++;
            ++*(_DWORD *)v5;
          }
          *(_BYTE *)v6++ = *(_BYTE *)v7;
        }
        else
        {
          if ( v14 )
          {
            ++v7;
            ++*(_DWORD *)v5;
          }
        }
        ++*(_DWORD *)v5;
      }
      ++v7;
    }
    if ( v6 )
      *(_BYTE *)v6++ = 0;
    ++*(_DWORD *)v5;
  }
  if ( a2 )
    *(_DWORD *)a2 = 0;
  result = a4;
  ++*(_DWORD *)result;
  return result;
}

//----- (1003E2DB) --------------------------------------------------------
signed int __usercall sub_1003E2DB<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // edi@3
  int v3; // esi@3
  int v5; // eax@7
  int v6; // ST14_4@7
  void *v7; // edi@9
  void *v8; // esi@10
  int v9; // eax@11
  int v10; // eax@12
  int v11; // [sp-10h] [bp-10h]@11

  if ( !dword_1006B3B0 )
    sub_1003F9D0(a2);
  v3 = (int)dword_10069454;
  v2 = 0;
  if ( !dword_10069454 )
    return -1;
  while ( *(_BYTE *)v3 )
  {
    if ( *(_BYTE *)v3 != 61 )
      ++v2;
    v5 = sub_1002CFA0(v3);
    a1 = v6;
    v3 += v5 + 1;
  }
  v7 = sub_1002EFE1(a1, a2, v2 + 1, 4u);
  dword_100695EC = v7;
  if ( !v7 )
    return -1;
  v8 = dword_10069454;
  if ( !*(_BYTE *)dword_10069454 )
  {
LABEL_17:
    sub_100282F6(a2, v8);
    dword_10069454 = 0;
    *(_DWORD *)v7 = 0;
    dword_1006B3B4 = 1;
    return 0;
  }
  while ( 1 )
  {
    v9 = sub_1002CFA0((int)v8);
    a2 = v9 + 1;
    if ( *(_BYTE *)v8 != 61 )
      break;
LABEL_15:
    v8 = (char *)v8 + a2;
    if ( !*(_BYTE *)v8 )
    {
      v8 = dword_10069454;
      goto LABEL_17;
    }
  }
  v10 = (int)sub_1002EFE1(v11, a2, v9 + 1, 1u);
  *(_DWORD *)v7 = v10;
  if ( v10 )
  {
    if ( sub_10031E6C(a2, (int)v7, v10, a2, (int)v8) )
    {
      sub_10036C98(a2, (int)v7);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1003E3BC);
    }
    v7 = (char *)v7 + 4;
    goto LABEL_15;
  }
  sub_100282F6(a2, dword_100695EC);
  dword_100695EC = 0;
  return -1;
}
// 1006B3B0: using guessed type int dword_1006B3B0;
// 1006B3B4: using guessed type int dword_1006B3B4;

//----- (1003E3BC) --------------------------------------------------------
signed int __cdecl sub_1003E3BC()
{
  signed int result; // eax@3
  DWORD v1; // ecx@4
  LARGE_INTEGER PerformanceCount; // [sp+8h] [bp-14h]@4
  struct _FILETIME SystemTimeAsFileTime; // [sp+10h] [bp-Ch]@1
  DWORD v4; // [sp+18h] [bp-4h]@4

  SystemTimeAsFileTime.dwLowDateTime = 0;
  SystemTimeAsFileTime.dwHighDateTime = 0;
  if ( __security_cookie != -1153374642 && __security_cookie & 0xFFFF0000 )
  {
    result = ~__security_cookie;
    dword_10067214 = ~__security_cookie;
  }
  else
  {
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v4 = SystemTimeAsFileTime.dwLowDateTime ^ SystemTimeAsFileTime.dwHighDateTime;
    v4 = GetCurrentThreadId() ^ SystemTimeAsFileTime.dwLowDateTime ^ SystemTimeAsFileTime.dwHighDateTime;
    v4 ^= GetCurrentProcessId();
    QueryPerformanceCounter(&PerformanceCount);
    result = (signed int)&v4;
    v1 = (unsigned int)&v4 ^ v4 ^ PerformanceCount.LowPart ^ PerformanceCount.HighPart;
    if ( v1 == -1153374642 )
    {
      v1 = -1153374641;
    }
    else
    {
      if ( !(v1 & 0xFFFF0000) )
      {
        result = (v1 | 0x4711) << 16;
        v1 |= result;
      }
    }
    __security_cookie = v1;
    dword_10067214 = ~v1;
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 10067214: using guessed type int dword_10067214;

//----- (1003E456) --------------------------------------------------------
int __usercall sub_1003E456<eax>(int a1<ebx>)
{
  int result; // eax@1
  const WCHAR *v2; // edi@1
  const WCHAR *i; // esi@2
  int v4; // eax@5
  int v5; // edx@5
  int v6; // ecx@5
  int v7; // esi@5
  int v8; // ebx@6
  int v9; // [sp+4h] [bp-4h]@5

  v2 = GetEnvironmentStringsW();
  result = 0;
  if ( v2 )
  {
    for ( i = v2; *i; ++i )
    {
      do
        ++i;
      while ( *i );
    }
    v7 = ((signed int)((char *)i - (char *)v2) >> 1) + 1;
    v4 = WideCharToMultiByte(0, 0, v2, v7, 0, 0, 0, 0);
    v9 = v4;
    if ( v4 && (v8 = sub_1002F02B(v5, v6, a1, v4)) != 0 )
    {
      if ( !WideCharToMultiByte(0, 0, v2, v7, (LPSTR)v8, v9, 0, 0) )
      {
        sub_100282F6(v8, (LPVOID)v8);
        v8 = 0;
      }
      FreeEnvironmentStringsW((LPWCH)v2);
      result = v8;
    }
    else
    {
      FreeEnvironmentStringsW((LPWCH)v2);
      result = 0;
    }
  }
  return result;
}

//----- (1003E4E1) --------------------------------------------------------
void __cdecl sub_1003E4E1()
{
  unsigned int i; // esi@1

  for ( i = (unsigned int)&unk_1005F818; i < (unsigned int)&unk_1005F818; i += 4 )
  {
    if ( *(_DWORD *)i )
      (*(void (**)(void))i)();
  }
}

//----- (1003E501) --------------------------------------------------------
void __cdecl sub_1003E501()
{
  unsigned int i; // esi@1

  for ( i = (unsigned int)&unk_1005F820; i < (unsigned int)&unk_1005F820; i += 4 )
  {
    if ( *(_DWORD *)i )
      (*(void (**)(void))i)();
  }
}

//----- (1003E530) --------------------------------------------------------
void __userpurge sub_1003E530(int a1<ebp>, int a2<edi>, int a3<esi>, int a4, int a5, int a6)
{
  void (__stdcall *v6)(_DWORD, _DWORD); // eax@1

  *(_DWORD *)(a1 - 4) = *(_DWORD *)(a1 + 12) + 12;
  sub_10048EDC();
  v6(a2, a3);
  sub_10048EDC();
}

//----- (1003E57C) --------------------------------------------------------
int __cdecl sub_1003E57C(int a1)
{
  return a1 != 0 ? 1 : 0;
}

//----- (1003E58B) --------------------------------------------------------
void __usercall sub_1003E58B(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  if ( off_10067514 != &dword_10067518 )
  {
    sub_1002E493(a1, a2, a3, a4, 12);
    off_10067514 = sub_1003A3B1(&off_10067514, &dword_10067518);
    sub_1002E5F7(12);
  }
}

//----- (1003E5DD) --------------------------------------------------------
int __cdecl sub_1003E5DD(int a1)
{
  int result; // eax@2
  int v2; // edx@3
  int v3; // ebx@3
  int v4; // edi@5
  int v5; // [sp-8h] [bp-8h]@3

  if ( a1 )
  {
    v3 = sub_10041D8E(a1, 0x55u);
    if ( (unsigned int)v3 < 0x55 )
    {
      result = sub_1002F02B(v2, v5, v3, 2 * v3 + 2);
      v4 = result;
      if ( result )
      {
        if ( sub_1003A3FC(v3, result, result, v3 + 1, a1, v3 + 1) )
        {
          sub_10036C98(v3, v4);
          __asm { int     3               ; Trap to Debugger }
          JUMPOUT(*(int *)sub_1003E641);
        }
        result = v4;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003E641) --------------------------------------------------------
void __usercall sub_1003E641(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6)
{
  int v6; // edx@1
  int v7; // ecx@1

  if ( sub_100401C0(a1, a2, a3, a6, a4, a5, a6) )
  {
    sub_10036C98(a3, a6);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003E6AF);
  }
  if ( *(_WORD *)(a6 + 128) )
    sub_1003EAFA(v7, v6, a4, a5, 2);
  if ( *(_WORD *)(a6 + 256) )
    sub_1003EAFA(v7, v6, a4, a5, 2);
}
// 1003E6AF: using guessed type int __cdecl sub_1003E6AF(int, int);

//----- (1003E6AF) --------------------------------------------------------
signed int __cdecl sub_1003E6AF(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // esi@1
  int v5; // eax@8
  int v6; // eax@16
  int v7; // [sp-10h] [bp-20h]@12
  int v8; // [sp-Ch] [bp-1Ch]@12
  int v9; // [sp-8h] [bp-18h]@12
  int v10; // [sp-4h] [bp-14h]@12
  int v11; // [sp+Ch] [bp-4h]@9
  int i; // [sp+1Ch] [bp+Ch]@7

  v2 = 0;
  sub_10030CF0((void *)a1, 0, 458);
  v3 = a2;
  if ( !*(_WORD *)a2 )
    return 0;
  if ( *(_WORD *)a2 == 46 && *(_WORD *)(a2 + 2) )
  {
    if ( sub_1003A3FC(0, a1, a1 + 256, 16, a2 + 2, 15) )
    {
LABEL_30:
      sub_10036C98(v2, a1);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1003E7D9);
    }
    *(_WORD *)(a1 + 286) = 0;
    return 0;
  }
  for ( i = 0; ; ++i )
  {
    v5 = sub_10048F45(v3, (int)L"_.,");
    if ( !v5 )
      break;
    v11 = v3 + 2 * v5;
    v2 = *(_WORD *)v11;
    if ( i )
    {
      if ( i == 1 )
      {
        if ( (unsigned int)v5 >= 0x40 || v2 == 95 )
          return -1;
        v10 = v5;
        v9 = v3;
        v8 = 64;
        v6 = a1 + 128;
      }
      else
      {
        if ( i != 2 || (unsigned int)v5 >= 0x10 || (_WORD)v2 && (_WORD)v2 != 44 )
          return -1;
        v10 = v5;
        v9 = v3;
        v8 = 16;
        v6 = a1 + 256;
      }
      v7 = v6;
    }
    else
    {
      if ( (unsigned int)v5 >= 0x40 || (_WORD)v2 == 46 )
        return -1;
      v10 = v5;
      v9 = v3;
      v8 = 64;
      v7 = a1;
    }
    if ( sub_1003A3FC(v2, a1, v7, v8, v9, v10) )
      goto LABEL_30;
    if ( (_WORD)v2 == 44 || !(_WORD)v2 )
      return 0;
    v3 = v11 + 2;
  }
  return -1;
}
// 1003E6AF: using guessed type int __cdecl sub_1003E6AF(int, int);
// 10059F3C: using guessed type wchar_t a__[4];

//----- (1003E7D9) --------------------------------------------------------
void __cdecl sub_1003E7D9(void *lpAddend, const void *a2)
{
  if ( a2 )
  {
    if ( lpAddend )
    {
      if ( lpAddend != a2 )
      {
        memcpy(lpAddend, a2, 0xB8u);
        *(_DWORD *)lpAddend = 0;
        sub_1003A0B0((volatile LONG *)lpAddend);
      }
    }
  }
}

//----- (1003E805) --------------------------------------------------------
int __cdecl sub_1003E805(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int v7; // ebx@1
  int v8; // edi@1
  signed int v10; // eax@4
  int v11; // edx@4
  int v12; // ecx@4
  signed int v13; // eax@7
  int v14; // edx@12
  int v15; // ecx@12
  int v16; // eax@12
  int v17; // ST10_4@12
  int v18; // eax@13
  int v19; // ST10_4@13
  int v20; // edi@14
  char v21; // zf@15
  signed int v22; // eax@16
  int v24; // ecx@16
  int v25; // eax@20
  UINT v26; // eax@25
  int v27; // eax@41
  int v28; // [sp+14h] [bp-1E8h]@4
  int v29; // [sp+18h] [bp-1E4h]@11
  int v30; // [sp+1Ch] [bp-1E0h]@1
  UINT v31; // [sp+20h] [bp-1DCh]@1
  int v32; // [sp+24h] [bp-1D8h]@1
  int v33; // [sp+28h] [bp-1D4h]@1
  char v34; // [sp+2Ch] [bp-1D0h]@14
  char v35; // [sp+14Ch] [bp-B0h]@20
  unsigned int v36; // [sp+1F8h] [bp-4h]@1
  int v37; // [sp+1FCh] [bp+0h]@1

  v36 = (unsigned int)&v37 ^ __security_cookie;
  v7 = a4;
  v8 = a6;
  v6 = sub_10031BD7(a4, a6);
  v32 = v6 + 180;
  v30 = v6 + 184;
  v33 = v6 + 446;
  v31 = 0;
  if ( !a1 )
    return 0;
  v28 = v6 + 748;
  v10 = sub_1003A3FC(a4, a6, a4, a5, v6 + 748, 85);
  if ( v10 )
    goto LABEL_43;
  if ( *(_WORD *)a1 != 67 || *(_WORD *)(a1 + 2) != (_WORD)v10 )
  {
    v29 = sub_10031399(a1);
    if ( (unsigned int)v29 < 0x83 )
    {
      v16 = sub_10048F07(v33, a1);
      v15 = v17;
      if ( !v16 || (v18 = sub_10048F07(v30, a1), v15 = v19, !v18) )
      {
LABEL_37:
        if ( v8 )
          sub_1002C950((void *)v8, (const void *)v32, 4u);
        v7 = v33;
        if ( !sub_100401C0(v14, v15, v33, v8, a2, a3, v33) )
          return v7;
LABEL_43:
        sub_10036C98(v7, v8);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_1003EAFA);
      }
    }
    v20 = __security_cookie == dword_1006B414 ? 1 : 0;
    if ( sub_1003E6AF((int)&v34, a1) )
    {
      v8 = v32;
    }
    else
    {
      v21 = v20 == 0;
      v8 = v32;
      if ( v21 )
        v22 = sub_10049521(a4, v32, (int)&v34, v32, (int)&v34);
      else
        v22 = sub_10049D6D(a4, v32, (int)&v34, v32, (int)&v34);
      if ( v22 )
      {
        v8 = 131;
        sub_1003E641(v14, v24, a4, v33, 131, (int)&v34);
        if ( a4 )
        {
          v25 = sub_10031399((int)&v35);
          if ( sub_1003A3FC(a4, 131, a4, a5, (int)&v35, v25 + 1) )
            goto LABEL_43;
        }
LABEL_31:
        v7 = 0;
        if ( *(_WORD *)a1 && v29 < (unsigned int)v8 )
        {
          if ( sub_1003A3FC(0, v8, v30, v8, a1, v29 + 1) )
            goto LABEL_43;
        }
        else
        {
          v15 = 0;
          *(_WORD *)v30 = 0;
        }
        v8 = a6;
        goto LABEL_37;
      }
    }
    if ( !sub_10031898(a1) )
    {
      v27 = sub_10031399(a4);
      if ( !sub_1003A3FC(a4, v8, v28, 85, a4, v27 + 1) )
        return 0;
      goto LABEL_43;
    }
    if ( !sub_1003183E(a1, 0x20001004u, (WCHAR *)&v31, 2) || (LOWORD(v26) = v31, !v31) )
    {
      v26 = GetACP();
      v31 = v26;
    }
    *(_DWORD *)v8 = (unsigned __int16)v26;
    v8 = v29 + 1;
    if ( sub_1003A3FC(a4, v29 + 1, v33, 131, a1, v29 + 1)
      || sub_1003A3FC(a4, v8, a4, a5, a1, v8)
      || sub_1003A3FC(a4, v8, v28, 85, a1, v8) )
      goto LABEL_43;
    v8 = 131;
    goto LABEL_31;
  }
  v13 = sub_100401C0(v11, v12, a4, a6, a2, a3, (int)L"C");
  if ( v13 )
    goto LABEL_43;
  if ( a6 )
    *(_DWORD *)a6 = v13;
  return a2;
}
// 1003E6AF: using guessed type int __cdecl sub_1003E6AF(int, int);
// 10059F38: using guessed type wchar_t aC[2];
// 10067210: using guessed type int __security_cookie;
// 1006B414: using guessed type int dword_1006B414;

//----- (1003EAFA) --------------------------------------------------------
void __fastcall sub_1003EAFA(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  int *v6; // edi@2

  v5 = 0;
  if ( a5 > 0 )
  {
    v6 = &a5;
    do
    {
      ++v6;
      if ( sub_1004244F(a2, a1, 0, a3, a4, *v6) )
      {
        sub_10036C98(0, (int)v6);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_1003EB39);
      }
      ++v5;
    }
    while ( v5 < a5 );
  }
}

//----- (1003EB39) --------------------------------------------------------
void __usercall sub_1003EB39(int a1<edi>, unsigned int a2, int a3)
{
  int v3; // eax@3
  int v4; // edx@3
  void *v5; // edi@3
  int v6; // esi@3
  int v7; // ecx@3
  int v8; // [sp-4h] [bp-38h]@3

  if ( a2 <= 5 )
  {
    v6 = sub_10031BD7(0, a1);
    sub_1003A335(0, a1);
    *(_DWORD *)(v6 + 112) |= 0x10u;
    v3 = (int)sub_1002EFE1(v7, 0, 0xB8u, 1u);
    v5 = (void *)v3;
    if ( v3 )
    {
      sub_1002E493(v4, v8, 0, v3, 12);
      sub_1003E7D9(v5, *(const void **)(v6 + 108));
      sub_1002E5F7(12);
    }
    else
    {
      *(_DWORD *)(v6 + 112) &= 0xFFFFFFEFu;
    }
  }
  else
  {
    *(_DWORD *)sub_1002F144(0) = 22;
    sub_10036C88(0, a1);
  }
}

//----- (1003ECB6) --------------------------------------------------------
int __usercall sub_1003ECB6<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int result; // eax@1
  int v5; // edx@1
  int v6; // ebx@1
  int v7; // edx@2
  int v8; // ecx@2
  int v9; // esi@2
  int v10; // [sp-4h] [bp-18h]@1
  int v11; // [sp+8h] [bp-Ch]@2
  signed int v12; // [sp+Ch] [bp-8h]@1
  signed int v13; // [sp+10h] [bp-4h]@2

  v12 = 1;
  v6 = sub_1002F02B(a1, a2, a3, 1702);
  result = 0;
  if ( v6 )
  {
    v9 = v6 + 4;
    *(_WORD *)(v6 + 4) = 0;
    *(_DWORD *)v6 = 1;
    sub_1003EAFA(v10, v5, v6 + 4, 849, 3);
    v13 = (signed int)&off_10059DEC;
    v11 = a4 + 36;
    do
    {
      if ( sub_1004244F(v7, v8, v6, v9, 849, (int)L";") )
      {
        sub_10036C98(v6, a4);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_1003EE2A);
      }
      v12 = sub_10048F07(*(_DWORD *)v11, *(_DWORD *)(v11 + 16)) == 0 ? v12 : 0;
      v9 = v6 + 4;
      v11 += 16;
      v13 += 12;
      sub_1003EAFA(v11, v7, v6 + 4, 849, 3);
    }
    while ( v13 < (signed int)&off_10059E1C );
    if ( v12 )
    {
      sub_100282F6(v6, (LPVOID)v6);
      if ( *(_DWORD *)(a4 + 28) )
      {
        if ( !InterlockedDecrement(*(volatile LONG **)(a4 + 28)) )
          sub_100282F6(v6, *(LPVOID *)(a4 + 28));
      }
      if ( *(_DWORD *)(a4 + 24) )
      {
        if ( !InterlockedDecrement(*(volatile LONG **)(a4 + 24)) )
          sub_100282F6(v6, *(LPVOID *)(a4 + 24));
      }
      result = *(_DWORD *)(a4 + 52);
      *(_DWORD *)(a4 + 24) = 0;
      *(_DWORD *)(a4 + 16) = 0;
      *(_DWORD *)(a4 + 28) = 0;
      *(_DWORD *)(a4 + 20) = 0;
    }
    else
    {
      if ( *(_DWORD *)(a4 + 28) )
      {
        if ( !InterlockedDecrement(*(volatile LONG **)(a4 + 28)) )
          sub_100282F6(v6, *(LPVOID *)(a4 + 28));
      }
      if ( *(_DWORD *)(a4 + 24) )
      {
        if ( !InterlockedDecrement(*(volatile LONG **)(a4 + 24)) )
          sub_100282F6(v6, *(LPVOID *)(a4 + 24));
      }
      *(_DWORD *)(a4 + 24) = 0;
      *(_DWORD *)(a4 + 16) = 0;
      *(_DWORD *)(a4 + 28) = v6;
      *(_DWORD *)(a4 + 20) = v9;
      result = v6 + 4;
    }
  }
  return result;
}
// 10059DEC: using guessed type wchar_t *off_10059DEC;
// 10059E1C: using guessed type wchar_t *off_10059E1C;
// 10059F30: using guessed type wchar_t asc_10059F30[2];

//----- (1003EE2A) --------------------------------------------------------
int __fastcall sub_1003EE2A(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // edi@1
  int v6; // esi@1
  int result; // eax@3
  int v8; // ebx@5
  int v9; // eax@9
  int *v10; // ebx@12
  int v11; // eax@16
  int v12; // esi@16
  int v13; // ST14_4@16
  char v14; // zf@21
  int v15; // esi@23
  int *v16; // eax@29
  int v17; // esi@29
  char v18; // zf@32
  int v19; // [sp+10h] [bp-1C8h]@9
  int v20; // [sp+14h] [bp-1C4h]@5
  signed int v21; // [sp+18h] [bp-1C0h]@5
  int v22; // [sp+18h] [bp-1C0h]@12
  int v23; // [sp+1Ch] [bp-1BCh]@12
  int v24; // [sp+1Ch] [bp-1BCh]@16
  int v25; // [sp+1Ch] [bp-1BCh]@29
  char v26; // [sp+20h] [bp-1B8h]@28
  __int16 v27[132]; // [sp+CCh] [bp-10Ch]@19
  unsigned int v28; // [sp+1D4h] [bp-4h]@1
  int v29; // [sp+1D8h] [bp+0h]@1

  v28 = (unsigned int)&v29 ^ __security_cookie;
  v6 = a5;
  v5 = a3;
  if ( !a4 )
  {
    v8 = 0;
    v21 = 1;
    v20 = 0;
    if ( !a5 )
      return sub_1003ECB6(a2, a1, v8, v5);
    if ( *(_WORD *)a5 == 76 && *(_WORD *)(a5 + 2) == 67 && *(_WORD *)(a5 + 4) == 95 )
    {
      while ( 1 )
      {
        v9 = sub_10048FCA(v6, (int)L"=;");
        v19 = v9;
        if ( !v9 )
          return 0;
        if ( !((v9 - v6) >> 1) )
          return 0;
        if ( *(_WORD *)v9 == 59 )
          return 0;
        v23 = (v9 - v6) >> 1;
        v22 = 1;
        v10 = (int *)&off_10059DEC;
        do
        {
          if ( !sub_10048F94(*v10, v6, v23) && v23 == sub_10031399(*v10) )
            break;
          ++v22;
          v10 += 3;
        }
        while ( (signed int)v10 <= (signed int)&off_10059E1C );
        v12 = v19 + 2;
        v11 = sub_10048F45(v19 + 2, (int)L";");
        v5 = a3;
        v8 = v20;
        a1 = v13;
        v24 = v11;
        if ( !v11 )
        {
          a1 = 59;
          if ( *(_WORD *)v12 != 59 )
            return 0;
        }
        if ( v22 <= 5 )
        {
          if ( sub_1003A3FC(v20, a3, (int)v27, 131, v12, v11) )
            goto LABEL_43;
          if ( (unsigned int)(2 * v24) >= 0x106 )
          {
            sub_100280DF(v20, a3, v12);
LABEL_43:
            sub_10036C98(v20, a3);
            __asm { int     3               ; Trap to Debugger }
            JUMPOUT(*(int *)sub_1003F0B1);
          }
          v27[v24] = 0;
          v14 = sub_1003F0B1(a3, v22, (int)v27) == 0;
          v11 = v24;
          if ( !v14 )
            v8 = v20++ + 1;
        }
        v15 = v12 + 2 * v11;
        result = 0;
        if ( *(_WORD *)v15 )
        {
          v6 = v15 + 2;
          if ( *(_WORD *)v6 )
            continue;
        }
        if ( v8 )
          return sub_1003ECB6(a2, a1, v8, v5);
        return result;
      }
    }
    result = sub_1003E805(a5, (int)v27, 131, (int)&v26, 85, 0);
    if ( !result )
      return result;
    v16 = (int *)(a3 + 20);
    v17 = 0;
    v25 = a3 + 20;
    while ( 1 )
    {
      if ( !v17 )
        goto LABEL_36;
      if ( !sub_10048F07((int)v27, *v16) )
      {
        v16 = (int *)v25;
LABEL_35:
        ++v8;
LABEL_36:
        a1 = v21;
        goto LABEL_37;
      }
      v18 = sub_1003F0B1(a3, v17, (int)v27) == 0;
      v16 = (int *)v25;
      if ( !v18 )
        goto LABEL_35;
      a1 = 0;
      v21 = 0;
LABEL_37:
      ++v17;
      v16 += 4;
      v25 = (int)v16;
      if ( v17 > 5 )
      {
        if ( a1 || v8 )
          return sub_1003ECB6(a2, a1, v8, v5);
        return 0;
      }
    }
  }
  if ( a5 )
    result = sub_1003F0B1(a3, a4, a5);
  else
    result = *(_DWORD *)(a3 + 16 * a4 + 20);
  return result;
}
// 10059DEC: using guessed type wchar_t *off_10059DEC;
// 10059E1C: using guessed type wchar_t *off_10059E1C;
// 10059F28: using guessed type wchar_t asc_10059F28[3];
// 10059F30: using guessed type wchar_t asc_10059F30[2];
// 10067210: using guessed type int __security_cookie;
// 1003EE2A: using guessed type __int16 var_10C[132];

//----- (1003F0B1) --------------------------------------------------------
int __cdecl sub_1003F0B1(int a1, int a2, int a3)
{
  int v4; // ebx@4
  int v5; // eax@6
  int v6; // edx@6
  int v7; // esi@6
  int v8; // eax@6
  char v9; // zf@8
  int v10; // edx@12
  int v11; // ecx@13
  int v12; // edx@15
  int v13; // eax@15
  int v14; // ecx@15
  int v15; // ebx@15
  int v16; // eax@16
  int v17; // ecx@16
  unsigned int v18; // eax@19
  int v19; // eax@21
  int v20; // ebx@32
  int v21; // eax@35
  LPVOID v22; // [sp+Ch] [bp-2ECh]@7
  int v23; // [sp+10h] [bp-2E8h]@7
  _UNKNOWN *v24; // [sp+18h] [bp-2E0h]@7
  void *v25; // [sp+1Ch] [bp-2DCh]@6
  int v26; // [sp+20h] [bp-2D8h]@13
  int v27; // [sp+24h] [bp-2D4h]@1
  int v28; // [sp+28h] [bp-2D0h]@7
  int v29; // [sp+2Ch] [bp-2CCh]@1
  int v30; // [sp+30h] [bp-2C8h]@13
  int v31; // [sp+34h] [bp-2C4h]@7
  int v32; // [sp+38h] [bp-2C0h]@1
  int v33; // [sp+3Ch] [bp-2BCh]@13
  char v34; // [sp+40h] [bp-2B8h]@1
  WORD CharType[128]; // [sp+ECh] [bp-20Ch]@18
  __int16 v36; // [sp+1ECh] [bp-10Ch]@1
  __int16 v37; // [sp+1EEh] [bp-10Ah]@9
  unsigned int v38; // [sp+2F4h] [bp-4h]@1
  int v39; // [sp+2F8h] [bp+0h]@1

  v38 = (unsigned int)&v39 ^ __security_cookie;
  v29 = a2;
  v32 = sub_10031BD7(a2, a1) + 708;
  if ( !sub_1003E805(a3, (int)&v36, 131, (int)&v34, 85, (int)&v27) )
    return 0;
  v4 = 16 * a2;
  if ( sub_10048F07((int)&v36, *(_DWORD *)(16 * a2 + a1 + 20)) )
  {
    v8 = sub_10031399((int)&v36);
    v7 = v8 + 1;
    v5 = sub_1002F02B(v6, 2 * (v8 + 1) + 4, v4, 2 * (v8 + 1) + 4);
    v25 = (void *)v5;
    if ( v5 )
    {
      v24 = *(_UNKNOWN **)(v4 + a1 + 20);
      v28 = v5 + 4;
      v31 = a1 + 4 * (v29 + 40);
      v22 = *(LPVOID *)v31;
      v23 = *(_DWORD *)(a1 + 4);
      if ( sub_100401C0(v6, v28, v4, a1, v28, v7, (int)&v36) )
      {
        sub_10036C98(v4, a1);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_1003F449);
      }
      v9 = v36 == 67;
      *(_DWORD *)(v4 + a1 + 20) = v28;
      if ( !v9 || v37 )
        *(_DWORD *)v31 = sub_1003E5DD((int)&v34);
      else
        *(_DWORD *)v31 = 0;
      v10 = v29;
      switch ( v29 )
      {
        case 2:
          *(_DWORD *)(a1 + 4) = v27;
          v30 = v32;
          v26 = *(_DWORD *)(v32 + 32);
          v28 = *(_DWORD *)(v32 + 36);
          v11 = 0;
          v33 = 0;
          while ( 1 )
          {
            v10 = v29;
            if ( *(_DWORD *)(a1 + 4) == *(_DWORD *)v30 )
              break;
            v12 = v30;
            v13 = *(_DWORD *)v30;
            v14 = *(_DWORD *)(v30 + 4);
            v30 += 8;
            *(_DWORD *)v12 = v26;
            v15 = v28;
            v28 = v14;
            v11 = v33 + 1;
            *(_DWORD *)(v12 + 4) = v15;
            v4 = 16 * a2;
            v10 = v29;
            v26 = v13;
            v33 = v11;
            if ( v11 >= 5 )
              goto LABEL_16;
          }
          if ( !v11 )
          {
LABEL_16:
            v16 = v33;
            v17 = v32;
            goto LABEL_17;
          }
          v17 = v32;
          *(_DWORD *)v32 = *(_DWORD *)(v32 + 8 * v33);
          *(_DWORD *)(v17 + 4) = *(_DWORD *)(v17 + 8 * v33 + 4);
          v16 = v33;
          *(_DWORD *)(v17 + 8 * v33) = v26;
          *(_DWORD *)(v17 + 8 * v16 + 4) = v28;
          v4 = 16 * a2;
LABEL_17:
          if ( v16 == 5 )
          {
            if ( sub_10040308(v4, a1, 0, 1u, &MultiByteStr, 127, CharType, *(_DWORD *)(a1 + 4), 1) )
            {
              v18 = 0;
              do
                CharType[v18++] &= 0x1FFu;
              while ( v18 < 0x7F );
              v19 = sub_1002F204((int)CharType, (int)off_10067A50, 0xFEu);
              v17 = v32;
              *(_DWORD *)(v32 + 4) = v19 == 0;
            }
            else
            {
              v17 = v32;
              *(_DWORD *)(v32 + 4) = 0;
            }
            v10 = v29;
            *(_DWORD *)v17 = *(_DWORD *)(a1 + 4);
          }
          *(_DWORD *)(a1 + 112) = *(_DWORD *)(v17 + 4);
          break;
        case 1:
          *(_DWORD *)(a1 + 8) = v27;
          break;
        case 5:
          *(_DWORD *)(a1 + 12) = v27;
          break;
      }
      if ( !((int (__cdecl *)(int))*(&off_10059DE8 + 3 * v10))(a1) )
      {
        if ( v24 != &unk_100673AC )
        {
          if ( !InterlockedDecrement(*(volatile LONG **)(v4 + a1 + 28)) )
          {
            sub_100282F6(v4, *(LPVOID *)(v4 + a1 + 28));
            sub_100282F6(v4, *(LPVOID *)(v4 + a1 + 24));
            sub_100282F6(v4, *(LPVOID *)v31);
            v21 = v31;
            *(_DWORD *)(v4 + a1 + 20) = 0;
            *(_DWORD *)v21 = 0;
          }
        }
        *(_DWORD *)v25 = 1;
        *(_DWORD *)(v4 + a1 + 28) = v25;
        return *(_DWORD *)(v4 + a1 + 20);
      }
      *(_DWORD *)(v4 + a1 + 20) = v24;
      v20 = v31;
      sub_100282F6(v31, *(LPVOID *)v31);
      *(_DWORD *)v20 = v22;
      sub_100282F6(v20, v25);
      *(_DWORD *)(a1 + 4) = v23;
    }
    return 0;
  }
  return *(_DWORD *)(v4 + a1 + 20);
}
// 10059DE8: using guessed type int (*off_10059DE8)();
// 10067210: using guessed type int __security_cookie;
// 10067A50: using guessed type wchar_t *off_10067A50;
// 1003F0B1: using guessed type WORD CharType[128];

//----- (1003F449) --------------------------------------------------------
signed int __cdecl sub_1003F449(LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int cchWideChar, int a4)
{
  signed int result; // eax@1
  LPWSTR v5; // edi@1
  int v6; // esi@1
  int v7; // eax@12
  unsigned __int8 *i; // eax@14
  int v9; // ecx@14
  int v10; // eax@16
  char v11; // zf@16
  int v12; // eax@20
  int v13; // [sp+8h] [bp-14h]@6
  int v14; // [sp+10h] [bp-Ch]@29
  char v15; // [sp+14h] [bp-8h]@28
  int v16; // [sp+18h] [bp-4h]@15
  int v17; // [sp+24h] [bp+8h]@19

  result = cchWideChar;
  v5 = lpWideCharStr;
  v6 = 0;
  if ( lpWideCharStr )
  {
    if ( !cchWideChar )
      return result;
    *lpWideCharStr = 0;
  }
  if ( !lpMultiByteStr )
  {
    *(_DWORD *)sub_1002F144(0) = 22;
    sub_10036C88(0, (int)lpWideCharStr);
    return -1;
  }
  sub_1002E635((int)&v13, (int)lpMultiByteStr, (int)lpWideCharStr, a4);
  if ( !lpWideCharStr )
  {
    if ( !*(_DWORD *)(v13 + 168) )
    {
      v12 = sub_1002CFA0((int)lpMultiByteStr);
LABEL_24:
      v6 = v12;
      goto LABEL_28;
    }
    v6 = -1;
    v7 = MultiByteToWideChar(*(_DWORD *)(v13 + 4), 9u, lpMultiByteStr, -1, 0, 0);
    if ( !v7 )
    {
      *(_DWORD *)sub_1002F144((int)lpMultiByteStr) = 42;
      goto LABEL_28;
    }
LABEL_27:
    v6 = v7 - 1;
    goto LABEL_28;
  }
  if ( !*(_DWORD *)(v13 + 168) )
  {
    if ( (unsigned int)cchWideChar > 0 )
    {
      do
      {
        *v5 = (unsigned __int8)lpMultiByteStr[v6];
        if ( !lpMultiByteStr[v6] )
          break;
        ++v6;
        ++v5;
      }
      while ( v6 < (unsigned int)cchWideChar );
    }
    goto LABEL_28;
  }
  v6 = -1;
  v7 = MultiByteToWideChar(*(_DWORD *)(v13 + 4), 9u, lpMultiByteStr, -1, lpWideCharStr, cchWideChar);
  if ( v7 )
    goto LABEL_27;
  if ( GetLastError() == 122 )
  {
    v9 = cchWideChar;
    for ( i = (unsigned __int8 *)lpMultiByteStr; ; i = (unsigned __int8 *)(v10 + 1) )
    {
      v17 = (int)i;
      if ( !v9 )
        break;
      v16 = v9 - 1;
      if ( !*i )
        break;
      v11 = sub_10041D47((int)lpMultiByteStr, (int)v5, *i, (int)&v13) == 0;
      v10 = v17;
      if ( !v11 )
      {
        v10 = v17 + 1;
        if ( !*(_BYTE *)(v17 + 1) )
          goto LABEL_21;
      }
      v9 = v16;
    }
    v12 = MultiByteToWideChar(
            *(_DWORD *)(v13 + 4),
            1u,
            lpMultiByteStr,
            i - (unsigned __int8 *)lpMultiByteStr,
            v5,
            cchWideChar);
    if ( v12 )
      goto LABEL_24;
  }
LABEL_21:
  *(_DWORD *)sub_1002F144((int)lpMultiByteStr) = 42;
  *v5 = 0;
LABEL_28:
  if ( v15 )
    *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
  return v6;
}

//----- (1003F5A8) --------------------------------------------------------
signed int __cdecl sub_1003F5A8(int a1, LPWSTR lpWideCharStr, int cchWideChar, LPCSTR lpMultiByteStr, int a5, int a6)
{
  signed int v6; // esi@1
  int v7; // eax@9
  int v8; // eax@12
  int v9; // eax@13
  int v10; // eax@17
  signed int v12; // [sp-4h] [bp-20h]@12
  int v13; // [sp+Ch] [bp-10h]@9
  int v14; // [sp+14h] [bp-8h]@27
  char v15; // [sp+18h] [bp-4h]@26

  v6 = 0;
  if ( lpWideCharStr )
  {
    if ( !cchWideChar )
    {
LABEL_5:
      v6 = 22;
      *(_DWORD *)sub_1002F144(cchWideChar) = 22;
      sub_10036C88(cchWideChar, (int)lpWideCharStr);
      return v6;
    }
    *lpWideCharStr = 0;
  }
  else
  {
    if ( cchWideChar )
      goto LABEL_5;
  }
  if ( a1 )
    *(_DWORD *)a1 = 0;
  sub_1002E635((int)&v13, cchWideChar, (int)lpWideCharStr, a6);
  v7 = cchWideChar;
  if ( a5 <= (unsigned int)cchWideChar )
    v7 = a5;
  if ( (unsigned int)v7 <= 0x7FFFFFFF )
  {
    v9 = sub_1003F449(lpWideCharStr, lpMultiByteStr, v7, (int)&v13);
    if ( v9 == -1 )
    {
      if ( lpWideCharStr )
        *lpWideCharStr = 0;
      v6 = *(_DWORD *)sub_1002F144(cchWideChar);
      goto LABEL_26;
    }
    v10 = v9 + 1;
    if ( lpWideCharStr )
    {
      if ( v10 > (unsigned int)cchWideChar )
      {
        if ( a5 != -1 )
        {
          *lpWideCharStr = 0;
          v8 = sub_1002F144(cchWideChar);
          v12 = 34;
          goto LABEL_21;
        }
        v10 = cchWideChar;
        v6 = 80;
      }
      lpWideCharStr[v10 - 1] = 0;
    }
    if ( a1 )
      *(_DWORD *)a1 = v10;
    goto LABEL_26;
  }
  v8 = sub_1002F144(cchWideChar);
  v12 = 22;
LABEL_21:
  v6 = v12;
  *(_DWORD *)v8 = v12;
  sub_10036C88(cchWideChar, (int)lpWideCharStr);
LABEL_26:
  if ( v15 )
    *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
  return v6;
}

//----- (1003F684) --------------------------------------------------------
int __cdecl sub_1003F684(int a1, LPWSTR lpWideCharStr, int cchWideChar, LPCSTR lpMultiByteStr, int a5)
{
  return sub_1003F5A8(a1, lpWideCharStr, cchWideChar, lpMultiByteStr, a5, 0);
}

//----- (1003F6A2) --------------------------------------------------------
signed int __cdecl sub_1003F6A2(CHAR *a1, int lpWideCharStr, int cbMultiByte, int a4)
{
  int v4; // ebx@1
  LPCWSTR v5; // edi@1
  int v6; // esi@1
  int v8; // eax@6
  LPSTR v9; // ecx@6
  const WCHAR v10; // ax@10
  LPCWSTR v11; // eax@15
  int v12; // edx@15
  int v13; // eax@26
  int v14; // edi@26
  int v15; // eax@32
  int v16; // eax@33
  int v17; // edx@33
  int v18; // eax@38
  LPSTR v19; // ecx@39
  CHAR v20; // al@40
  const WCHAR v21; // ax@46
  int v22; // eax@50
  int v23; // [sp+Ch] [bp-2Ch]@6
  int v24; // [sp+14h] [bp-24h]@55
  char v25; // [sp+18h] [bp-20h]@54
  int v26; // [sp+1Ch] [bp-1Ch]@38
  LPSTR lpMultiByteStr; // [sp+20h] [bp-18h]@1
  LPCWSTR v28; // [sp+24h] [bp-14h]@1
  BOOL UsedDefaultChar; // [sp+28h] [bp-10h]@1
  CHAR MultiByteStr[8]; // [sp+2Ch] [bp-Ch]@33
  unsigned int v31; // [sp+34h] [bp-4h]@1
  int v32; // [sp+38h] [bp+0h]@1

  v31 = (unsigned int)&v32 ^ __security_cookie;
  v4 = cbMultiByte;
  v5 = (LPCWSTR)lpWideCharStr;
  v6 = 0;
  lpMultiByteStr = a1;
  v28 = (LPCWSTR)lpWideCharStr;
  UsedDefaultChar = 0;
  if ( a1 && !cbMultiByte )
    return 0;
  if ( !lpWideCharStr )
  {
    *(_DWORD *)sub_1002F144(cbMultiByte) = 22;
    sub_10036C88(cbMultiByte, 0);
    return -1;
  }
  sub_1002E635((int)&v23, cbMultiByte, lpWideCharStr, a4);
  v9 = lpMultiByteStr;
  v8 = v23;
  if ( !lpMultiByteStr )
  {
    if ( *(_DWORD *)(v23 + 168) )
    {
      v22 = WideCharToMultiByte(*(_DWORD *)(v23 + 4), 0, (LPCWSTR)lpWideCharStr, -1, 0, 0, 0, &UsedDefaultChar);
      if ( v22 && !UsedDefaultChar )
      {
        v14 = v22 - 1;
        goto LABEL_54;
      }
    }
    else
    {
      v21 = *(_WORD *)lpWideCharStr;
      if ( !*(_WORD *)lpWideCharStr )
        goto LABEL_49;
      while ( v21 <= 0xFFu )
      {
        ++v5;
        ++v6;
        v21 = *v5;
        if ( !*v5 )
          goto LABEL_49;
      }
    }
LABEL_53:
    *(_DWORD *)sub_1002F144(cbMultiByte) = 42;
    v14 = -1;
    goto LABEL_54;
  }
  if ( !*(_DWORD *)(v23 + 168) )
  {
    if ( cbMultiByte )
    {
      while ( *v5 <= 0xFFu )
      {
        v9[v6] = *(_BYTE *)v5;
        v10 = *v5;
        ++v5;
        if ( v10 )
        {
          ++v6;
          if ( v6 < (unsigned int)cbMultiByte )
            continue;
        }
        goto LABEL_49;
      }
      goto LABEL_44;
    }
LABEL_49:
    v14 = v6;
    goto LABEL_54;
  }
  if ( *(_DWORD *)(v23 + 116) == 1 )
  {
    if ( cbMultiByte )
    {
      v11 = (LPCWSTR)lpWideCharStr;
      v12 = cbMultiByte;
      do
      {
        if ( !*v11 )
          break;
        ++v11;
        --v12;
      }
      while ( v12 );
      if ( v12 )
      {
        if ( !*v11 )
          v4 = ((signed int)((char *)v11 - lpWideCharStr) >> 1) + 1;
      }
      v8 = v23;
    }
    v6 = WideCharToMultiByte(
           *(_DWORD *)(v8 + 4),
           0,
           (LPCWSTR)lpWideCharStr,
           v4,
           lpMultiByteStr,
           v4,
           0,
           &UsedDefaultChar);
    if ( v6 && !UsedDefaultChar )
    {
      if ( !lpMultiByteStr[v6 - 1] )
        --v6;
      goto LABEL_49;
    }
    goto LABEL_44;
  }
  v13 = WideCharToMultiByte(
          *(_DWORD *)(v23 + 4),
          0,
          (LPCWSTR)lpWideCharStr,
          -1,
          lpMultiByteStr,
          cbMultiByte,
          0,
          &UsedDefaultChar);
  v14 = v13;
  if ( v13 )
  {
    if ( !UsedDefaultChar )
    {
      v6 = v13 - 1;
      goto LABEL_49;
    }
LABEL_44:
    *(_DWORD *)sub_1002F144(v4) = 42;
    v6 = -1;
    goto LABEL_49;
  }
  if ( UsedDefaultChar || GetLastError() != 122 )
    goto LABEL_44;
  if ( cbMultiByte )
  {
    v15 = (int)v28;
    do
    {
      v16 = WideCharToMultiByte(
              *(_DWORD *)(v23 + 4),
              0,
              (LPCWSTR)v15,
              1,
              MultiByteStr,
              *(_DWORD *)(v23 + 116),
              0,
              &UsedDefaultChar);
      v17 = v16;
      if ( !v16 )
        goto LABEL_53;
      if ( UsedDefaultChar || v16 < 0 || (unsigned int)v16 > 5 )
        goto LABEL_53;
      if ( v16 + v14 > (unsigned int)cbMultiByte )
        break;
      v18 = 0;
      v26 = 0;
      if ( v17 > 0 )
      {
        v19 = lpMultiByteStr;
        do
        {
          v20 = MultiByteStr[v18];
          v19[v14] = v20;
          if ( !v20 )
            goto LABEL_54;
          v18 = v26 + 1;
          ++v14;
          v26 = v18;
        }
        while ( v18 < v17 );
      }
      v15 = (int)(v28 + 1);
      ++v28;
    }
    while ( v14 < (unsigned int)cbMultiByte );
  }
LABEL_54:
  if ( v25 )
    *(_DWORD *)(v24 + 112) &= 0xFFFFFFFDu;
  return v14;
}
// 10067210: using guessed type int __security_cookie;
// 1003F6A2: using guessed type CHAR MultiByteStr[8];

//----- (1003F907) --------------------------------------------------------
signed int __usercall sub_1003F907<eax>(int a1<ebx>, int a2, CHAR *a3, int cbMultiByte, int lpWideCharStr, int a6, int a7)
{
  int v7; // eax@7
  int v8; // eax@10
  signed int result; // eax@12
  signed int v10; // eax@13
  int v11; // eax@17
  signed int v12; // ecx@23
  signed int v13; // [sp-8h] [bp-14h]@10

  if ( a3 )
  {
    if ( cbMultiByte )
      goto LABEL_3;
LABEL_12:
    *(_DWORD *)sub_1002F144(a1) = 22;
    sub_10036C88(a1, cbMultiByte);
    return 22;
  }
  if ( cbMultiByte )
    goto LABEL_12;
LABEL_3:
  if ( a3 )
    *a3 = 0;
  if ( a2 )
    *(_DWORD *)a2 = 0;
  v7 = cbMultiByte;
  if ( a6 <= (unsigned int)cbMultiByte )
    v7 = a6;
  if ( (unsigned int)v7 > 0x7FFFFFFF )
  {
    v8 = sub_1002F144(a2);
    v13 = 22;
LABEL_22:
    *(_DWORD *)v8 = v13;
    sub_10036C88(a2, cbMultiByte);
    return v13;
  }
  v10 = sub_1003F6A2(a3, lpWideCharStr, v7, a7);
  if ( v10 == -1 )
  {
    if ( a3 )
      *a3 = 0;
    result = *(_DWORD *)sub_1002F144(a2);
  }
  else
  {
    v11 = v10 + 1;
    if ( a3 )
    {
      if ( v11 <= (unsigned int)cbMultiByte )
      {
        v12 = 0;
      }
      else
      {
        if ( a6 != -1 )
        {
          *a3 = 0;
          if ( cbMultiByte <= (unsigned int)v11 )
          {
            v8 = sub_1002F144(a2);
            v13 = 34;
            goto LABEL_22;
          }
        }
        v11 = cbMultiByte;
        v12 = 80;
      }
      a3[v11 - 1] = 0;
    }
    else
    {
      v12 = 0;
    }
    if ( a2 )
      *(_DWORD *)a2 = v11;
    result = v12;
  }
  return result;
}

//----- (1003F9D0) --------------------------------------------------------
int __usercall sub_1003F9D0<eax>(int a1<ebx>)
{
  if ( !dword_1006B3B0 )
  {
    sub_1003FD30(a1, 0xFFFFFFFDu);
    dword_1006B3B0 = 1;
  }
  return 0;
}
// 1006B3B0: using guessed type int dword_1006B3B0;

//----- (1003F9EE) --------------------------------------------------------
wchar_t *__cdecl sub_1003F9EE(int a1)
{
  wchar_t *result; // eax@5

  switch ( a1 )
  {
    case 932:
      result = off_10059F4C[0];
      break;
    case 936:
      result = off_10059F50[0];
      break;
    case 949:
      result = off_10059F54[0];
      break;
    case 950:
      result = off_10059F58;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 10059F4C: using guessed type wchar_t *off_10059F4C[4];
// 10059F50: using guessed type wchar_t *off_10059F50[3];
// 10059F54: using guessed type wchar_t *off_10059F54[2];
// 10059F58: using guessed type wchar_t *off_10059F58;

//----- (1003FA28) --------------------------------------------------------
UINT __usercall sub_1003FA28<eax>(int a1<ebx>, int a2<edi>, UINT a3)
{
  UINT result; // eax@1
  int v4; // [sp+0h] [bp-10h]@1
  int v5; // [sp+8h] [bp-8h]@8
  char v6; // [sp+Ch] [bp-4h]@7

  sub_1002E635((int)&v4, a1, a2, 0);
  result = a3;
  dword_10069F04 = 0;
  switch ( a3 )
  {
    case 0xFFFFFFFEu:
      dword_10069F04 = 1;
      result = GetOEMCP();
      break;
    case 0xFFFFFFFDu:
      dword_10069F04 = 1;
      result = GetACP();
      break;
    case 0xFFFFFFFCu:
      dword_10069F04 = 1;
      result = *(_DWORD *)(v4 + 4);
      break;
  }
  if ( v6 )
    *(_DWORD *)(v5 + 112) &= 0xFFFFFFFDu;
  return result;
}
// 10069F04: using guessed type int dword_10069F04;

//----- (1003FA94) --------------------------------------------------------
int __cdecl sub_1003FA94(int a1)
{
  int result; // eax@1
  signed int v2; // ecx@1
  char *v3; // edi@1
  int v4; // esi@1
  signed int v5; // edx@3
  int v6; // ecx@3

  v4 = a1 + 24;
  sub_10030CF0((void *)(a1 + 24), 0, 257);
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 540) = 0;
  result = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  v3 = (char *)&unk_10067D58 - a1;
  v2 = 257;
  do
  {
    *(_BYTE *)v4 = v3[v4];
    ++v4;
    --v2;
  }
  while ( v2 );
  v6 = a1 + 281;
  v5 = 256;
  do
  {
    LOBYTE(result) = v3[v6];
    *(_BYTE *)v6++ = result;
    --v5;
  }
  while ( v5 );
  return result;
}

//----- (1003FAFD) --------------------------------------------------------
char __cdecl sub_1003FAFD(int a1)
{
  unsigned int v1; // eax@2
  unsigned int i; // eax@4
  char *v3; // ecx@4
  unsigned int v4; // edx@5
  unsigned int v5; // ecx@11
  int v6; // eax@12
  int v7; // edx@20
  unsigned int v8; // ecx@20
  int v9; // edx@21
  int v10; // eax@22
  struct _cpinfo CPInfo; // [sp+14h] [bp-518h]@1
  WORD CharType[256]; // [sp+28h] [bp-504h]@11
  char v14[256]; // [sp+228h] [bp-304h]@11
  _BYTE DestStr[256]; // [sp+328h] [bp-204h]@11
  const CHAR MultiByteStr[256]; // [sp+428h] [bp-104h]@3
  unsigned int v17; // [sp+528h] [bp-4h]@1
  int v18; // [sp+52Ch] [bp+0h]@1

  v17 = (unsigned int)&v18 ^ __security_cookie;
  if ( GetCPInfo(*(_DWORD *)(a1 + 4), &CPInfo) )
  {
    v1 = 0;
    do
    {
      MultiByteStr[v1] = v1;
      ++v1;
    }
    while ( v1 < 0x100 );
    LOBYTE(i) = CPInfo.LeadByte[0];
    MultiByteStr[0] = 32;
    v3 = (char *)CPInfo.LeadByte;
    while ( (_BYTE)i )
    {
      v4 = (unsigned __int8)v3[1];
      for ( i = (unsigned __int8)i; i <= v4 && i < 0x100; ++i )
        MultiByteStr[i] = 32;
      v3 += 2;
      LOBYTE(i) = *v3;
    }
    sub_10040308(0, 256, 0, 1u, MultiByteStr, 256, CharType, *(_DWORD *)(a1 + 4), 0);
    sub_1002EF9A(
      0,
      256,
      0,
      *(_DWORD *)(a1 + 540),
      0x100u,
      MultiByteStr,
      256,
      (LPWSTR)DestStr,
      256,
      *(_DWORD *)(a1 + 4),
      0);
    sub_1002EF9A(0, 256, 0, *(_DWORD *)(a1 + 540), 0x200u, MultiByteStr, 256, (LPWSTR)v14, 256, *(_DWORD *)(a1 + 4), 0);
    v5 = 0;
    while ( 1 )
    {
      LOWORD(v6) = CharType[v5];
      if ( v6 & 1 )
      {
        *(_BYTE *)(a1 + v5 + 25) |= 0x10u;
        LOBYTE(v6) = DestStr[v5];
      }
      else
      {
        if ( !(v6 & 2) )
        {
          *(_BYTE *)(a1 + v5 + 281) = 0;
          goto LABEL_18;
        }
        *(_BYTE *)(a1 + v5 + 25) |= 0x20u;
        LOBYTE(v6) = v14[v5];
      }
      *(_BYTE *)(a1 + v5 + 281) = v6;
LABEL_18:
      ++v5;
      if ( v5 >= 0x100 )
        return v6;
    }
  }
  v7 = a1 + 281;
  v6 = -97 - (a1 + 281);
  v8 = 0;
  do
  {
    v9 = v8 + v7;
    if ( (unsigned int)(v9 + v6 + 32) <= 0x19 )
    {
      *(_BYTE *)(a1 + v8 + 25) |= 0x10u;
      v10 = v8 + 32;
LABEL_25:
      *(_BYTE *)v9 = v10;
      goto LABEL_27;
    }
    if ( (unsigned int)(v9 + v6) <= 0x19 )
    {
      *(_BYTE *)(a1 + v8 + 25) |= 0x20u;
      v10 = v8 - 32;
      goto LABEL_25;
    }
    *(_BYTE *)v9 = 0;
LABEL_27:
    v6 = -97 - (a1 + 281);
    ++v8;
    v7 = a1 + 281;
  }
  while ( v8 < 0x100 );
  return v6;
}
// 10067210: using guessed type int __security_cookie;
// 1003FAFD: using guessed type const CHAR MultiByteStr[256];
// 1003FAFD: using guessed type WORD CharType[256];
// 1003FAFD: using guessed type char var_304[256];

//----- (1003FC8B) --------------------------------------------------------
void __usercall sub_1003FC8B(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  void *v5; // esi@6

  v2 = sub_10031BD7(a1, a2);
  v4 = v2;
  if ( dword_100675D4 & *(_DWORD *)(v2 + 112) && *(_DWORD *)(v2 + 108) )
  {
    if ( !*(_DWORD *)(v2 + 104) )
      sub_1003234D(v3, dword_100675D4, a1, v2, 32);
  }
  else
  {
    sub_1002E493(v3, dword_100675D4, a1, v2, 13);
    v5 = *(void **)(v4 + 104);
    if ( v5 != lpAddend )
    {
      if ( v5 )
      {
        if ( !InterlockedDecrement((volatile LONG *)v5) )
        {
          if ( v5 != &unk_10067D58 )
            sub_100282F6(a1, v5);
        }
      }
      *(_DWORD *)(v4 + 104) = lpAddend;
      InterlockedIncrement((volatile LONG *)lpAddend);
    }
    sub_1002E5F7(13);
  }
}
// 100675D4: using guessed type int dword_100675D4;

//----- (1003FD30) --------------------------------------------------------
void __usercall sub_1003FD30(int a1<ebx>, UINT a2)
{
  int v2; // edx@1
  int v3; // ebx@1
  int v4; // esi@1
  int v5; // eax@2
  int v6; // ebx@2
  signed int v7; // eax@3
  int v8; // edi@3
  signed int v9; // esi@3
  int v10; // eax@4
  char v11; // zf@4
  int v12; // edx@7
  int v13; // ecx@7
  signed int i; // ecx@9
  signed int j; // ecx@12
  int v16; // [sp-4h] [bp-34h]@1
  int v17; // [sp+14h] [bp-1Ch]@1
  UINT v18; // [sp+38h] [bp+8h]@1

  v3 = sub_10031BD7(a1, -1);
  v17 = v3;
  sub_1003FC8B(v3, -1);
  v4 = *(_DWORD *)(v3 + 104);
  v18 = sub_1003FA28(v3, -1, a2);
  if ( v18 != *(_DWORD *)(v4 + 4) )
  {
    v5 = sub_1002F02B(v2, v16, v3, 544);
    v6 = v5;
    if ( v5 )
    {
      memcpy((void *)v5, *(const void **)(v17 + 104), 0x220u);
      v9 = 0;
      *(_DWORD *)v5 = 0;
      v7 = sub_1003FEDE(v5, v5 + 544, v18, v5);
      v8 = v7;
      if ( v7 )
      {
        if ( v7 == -1 )
        {
          if ( (_UNKNOWN *)v6 != &unk_10067D58 )
            sub_100282F6(v6, (LPVOID)v6);
          *(_DWORD *)sub_1002F144(v6) = 22;
        }
      }
      else
      {
        v11 = InterlockedDecrement(*(volatile LONG **)(v17 + 104)) == 0;
        v10 = v17;
        if ( v11 )
        {
          if ( *(_UNKNOWN **)(v17 + 104) != &unk_10067D58 )
          {
            sub_100282F6(v6, *(LPVOID *)(v17 + 104));
            v10 = v17;
          }
        }
        *(_DWORD *)(v10 + 104) = v6;
        InterlockedIncrement((volatile LONG *)v6);
        if ( !(*(_BYTE *)(v17 + 112) & 2) )
        {
          if ( !(dword_100675D4 & 1) )
          {
            sub_1002E493(v12, v13, v6, v8, 13);
            dword_10069EF0 = *(_DWORD *)(v6 + 4);
            dword_10069EF4 = *(_DWORD *)(v6 + 8);
            dword_10069EEC = *(_DWORD *)(v6 + 540);
            for ( i = 0; i < 5; ++i )
              word_10069EF8[i] = *(_WORD *)(v6 + 2 * i + 12);
            for ( j = 0; j < 257; ++j )
              byte_10067B50[j] = *(_BYTE *)(j + v6 + 24);
            while ( v9 < 256 )
            {
              byte_10067C58[v9] = *(_BYTE *)(v9 + v6 + 281);
              ++v9;
            }
            if ( !InterlockedDecrement((volatile LONG *)lpAddend) )
            {
              if ( lpAddend != &unk_10067D58 )
                sub_100282F6(v6, lpAddend);
            }
            lpAddend = (LPVOID)v6;
            InterlockedIncrement((volatile LONG *)v6);
            sub_1002E5F7(13);
          }
        }
      }
    }
  }
}
// 100675D4: using guessed type int dword_100675D4;
// 10069EEC: using guessed type int dword_10069EEC;
// 10069EF0: using guessed type int dword_10069EF0;
// 10069EF4: using guessed type int dword_10069EF4;
// 10069EF8: using guessed type __int16 word_10069EF8[];

//----- (1003FEDE) --------------------------------------------------------
signed int __usercall sub_1003FEDE<eax>(int a1<ebx>, int a2<edi>, UINT a3, int a4)
{
  UINT v4; // ebx@1
  signed int result; // eax@2
  unsigned int v6; // eax@3
  int v7; // ecx@3
  unsigned int v8; // edi@3
  char *v9; // eax@11
  unsigned int v10; // edx@12
  unsigned int v11; // ecx@13
  int v12; // eax@17
  signed int v13; // ecx@17
  char *v14; // eax@25
  char *v15; // ecx@26
  unsigned int v16; // eax@27
  unsigned int v17; // ebx@28
  char *v18; // edx@35
  int v19; // ecx@35
  signed int v20; // edi@35
  int v21; // edx@35
  int v22; // [sp+8h] [bp-20h]@1
  int v23; // [sp+Ch] [bp-1Ch]@3
  char *v24; // [sp+Ch] [bp-1Ch]@25
  struct _cpinfo CPInfo; // [sp+10h] [bp-18h]@9
  unsigned int v26; // [sp+24h] [bp-4h]@1
  int v27; // [sp+28h] [bp+0h]@1

  v26 = (unsigned int)&v27 ^ __security_cookie;
  v4 = sub_1003FA28(a1, a2, a3);
  v22 = v4;
  if ( v4 )
  {
    v8 = 0;
    v7 = 0;
    v23 = 0;
    v6 = 0;
    while ( *(int *)((char *)&dword_10067A60 + v6) != v4 )
    {
      ++v7;
      v6 += 48;
      v23 = v7;
      if ( v6 >= 0xF0 )
      {
        if ( v4 == 65000 || v4 == 65001 || !IsValidCodePage((unsigned __int16)v4) )
          return -1;
        if ( GetCPInfo(v4, &CPInfo) )
        {
          sub_10030CF0((void *)(a4 + 24), 0, 257);
          *(_DWORD *)(a4 + 4) = v4;
          *(_DWORD *)(a4 + 540) = 0;
          if ( (_DWORD)CPInfo.MaxCharSize <= 1u )
          {
            *(_DWORD *)(a4 + 8) = 0;
          }
          else
          {
            v9 = (char *)CPInfo.LeadByte;
            if ( CPInfo.LeadByte[0] )
            {
              do
              {
                LOBYTE(v10) = v9[1];
                if ( !(_BYTE)v10 )
                  break;
                v11 = (unsigned __int8)*v9;
                v10 = (unsigned __int8)v10;
                while ( v11 <= v10 )
                  *(_BYTE *)(a4 + v11++ + 25) |= 4u;
                v9 += 2;
              }
              while ( *v9 );
            }
            v12 = a4 + 26;
            v13 = 254;
            do
            {
              *(_BYTE *)v12++ |= 8u;
              --v13;
            }
            while ( v13 );
            *(_DWORD *)(a4 + 540) = sub_1003F9EE(*(_DWORD *)(a4 + 4));
            *(_DWORD *)(a4 + 8) = 1;
          }
          *(_DWORD *)(a4 + 12) = 0;
          *(_DWORD *)(a4 + 16) = 0;
          *(_DWORD *)(a4 + 20) = 0;
          goto LABEL_37;
        }
        if ( !dword_10069F04 )
          return -1;
        sub_1003FA94(a4);
        goto LABEL_38;
      }
    }
    sub_10030CF0((void *)(a4 + 24), 0, 257);
    v14 = &aJ[48 * v23];
    v24 = &aJ[48 * v23];
    do
    {
      v15 = v14;
      if ( *v14 )
      {
        do
        {
          LOBYTE(v16) = v15[1];
          if ( !(_BYTE)v16 )
            break;
          v17 = (unsigned __int8)*v15;
          v16 = (unsigned __int8)v16;
          while ( v17 <= v16 && v17 < 0x100 )
          {
            *(_BYTE *)(a4 + v17 + 25) |= byte_10067A5C[v8];
            v16 = (unsigned __int8)v15[1];
            ++v17;
          }
          v15 += 2;
        }
        while ( *v15 );
        v14 = v24;
      }
      ++v8;
      v14 += 8;
      v24 = v14;
    }
    while ( v8 < 4 );
    *(_DWORD *)(a4 + 4) = v22;
    *(_DWORD *)(a4 + 8) = 1;
    *(_DWORD *)(a4 + 540) = sub_1003F9EE(v22);
    v19 = a4 + 12;
    v18 = &aVyv[v21];
    v20 = 6;
    do
    {
      *(_WORD *)v19 = *(_WORD *)v18;
      v18 += 2;
      v19 += 2;
      --v20;
    }
    while ( v20 );
LABEL_37:
    sub_1003FAFD(a4);
LABEL_38:
    result = 0;
  }
  else
  {
    sub_1003FA94(a4);
    result = 0;
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;
// 10067A60: using guessed type int dword_10067A60;
// 10069F04: using guessed type int dword_10069F04;

//----- (100400D3) --------------------------------------------------------
int __usercall sub_100400D3<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // eax@2
  int v7; // ecx@4
  int result; // eax@9
  int v9; // [sp+4h] [bp-18h]@1
  int v10; // [sp+Ch] [bp-10h]@8
  char v11; // [sp+10h] [bp-Ch]@7
  const CHAR MultiByteStr; // [sp+14h] [bp-8h]@4
  char v13; // [sp+15h] [bp-7h]@4
  char v14; // [sp+16h] [bp-6h]@4
  WORD CharType; // [sp+18h] [bp-4h]@6
  signed int v16; // [sp+24h] [bp+8h]@3

  sub_1002E635((int)&v9, a1, a2, a5);
  v5 = a3;
  if ( (unsigned int)(a3 + 1) <= 0x100 )
  {
    v6 = *(_WORD *)(*(_DWORD *)(v9 + 144) + 2 * a3);
    goto LABEL_11;
  }
  v16 = a3 >> 8;
  if ( sub_10041D47(v5, a2, BYTE1(v5), (int)&v9) )
  {
    MultiByteStr = v16;
    v13 = v5;
    v14 = 0;
    v7 = 2;
  }
  else
  {
    MultiByteStr = v5;
    v13 = 0;
    v7 = 1;
  }
  if ( sub_10040308(v5, a2, (int)&v9, 1u, &MultiByteStr, v7, &CharType, *(_DWORD *)(v9 + 4), 1) )
  {
    v6 = CharType;
LABEL_11:
    result = a4 & v6;
    if ( v11 )
      *(_DWORD *)(v10 + 112) &= 0xFFFFFFFDu;
    return result;
  }
  if ( v11 )
    *(_DWORD *)(v10 + 112) &= 0xFFFFFFFDu;
  return 0;
}

//----- (10040182) --------------------------------------------------------
LPVOID __usercall sub_10040182<eax>(void *a1<ecx>, int a2<ebx>, unsigned int a3, unsigned int a4)
{
  LPVOID v4; // esi@1
  int v5; // eax@4
  int v7; // [sp+4h] [bp-4h]@1

  v7 = 0;
  v4 = sub_100403AF(a1, a2, a3, a4, (int)&v7);
  if ( !v4 )
  {
    if ( v7 )
    {
      if ( sub_1002F144(a2) )
      {
        v5 = sub_1002F144(a2);
        *(_DWORD *)v5 = v7;
      }
    }
  }
  return v4;
}

//----- (100401C0) --------------------------------------------------------
signed int __usercall sub_100401C0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, int a7)
{
  int v7; // edx@2
  int v8; // ecx@3
  int v9; // eax@5
  signed int result; // eax@6
  __int16 v11; // ax@8
  signed int v12; // [sp-4h] [bp-8h]@5

  if ( !a5 || (v7 = a6, !a6) )
    goto LABEL_5;
  v8 = a7;
  if ( !a7 )
  {
    *(_WORD *)a5 = 0;
LABEL_5:
    v9 = sub_1002F144(a3);
    v12 = 22;
LABEL_6:
    *(_DWORD *)v9 = v12;
    sub_10036C88(a3, a4);
    return v12;
  }
  do
  {
    v11 = *(_WORD *)v8;
    *(_WORD *)(a5 - a7 + v8) = *(_WORD *)v8;
    v8 += 2;
    if ( !v11 )
      break;
    --v7;
  }
  while ( v7 );
  result = 0;
  if ( !v7 )
  {
    *(_WORD *)a5 = 0;
    v9 = sub_1002F144(a3);
    v12 = 34;
    goto LABEL_6;
  }
  return result;
}

//----- (1004021C) --------------------------------------------------------
BOOL __cdecl sub_1004021C(int a1, DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, int a7)
{
  UINT v7; // ecx@1
  BOOL v8; // edi@1
  int v9; // eax@3
  int v10; // edx@3
  int v11; // ecx@3
  int v12; // ebx@3
  unsigned int v14; // eax@7
  char *v15; // esi@8
  int v16; // eax@10
  int v17; // esi@12
  int v18; // eax@15
  char v19; // [sp+0h] [bp-10h]@8
  unsigned int v20; // [sp+Ch] [bp-4h]@1
  int v21; // [sp+10h] [bp+0h]@1

  v20 = (unsigned int)&v21 ^ __security_cookie;
  v7 = CodePage;
  v8 = 0;
  if ( !CodePage )
  {
    CodePage = *(_DWORD *)(*(_DWORD *)a1 + 4);
    v7 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  }
  v9 = MultiByteToWideChar(v7, 8 * (a7 != 0) + 1, lpMultiByteStr, cbMultiByte, 0, 0);
  v12 = v9;
  if ( !v9 )
    return 0;
  if ( v9 > 0 && (unsigned int)v9 <= 0x7FFFFFF0 )
  {
    v14 = 2 * v9 + 8;
    if ( v14 > 0x400 )
    {
      v16 = sub_10028264(v10, v11, v12, 0, 2 * v12 + 8);
      v15 = (char *)v16;
      if ( v16 )
      {
        *(_DWORD *)v16 = 56797;
        goto LABEL_12;
      }
    }
    else
    {
      sub_10031E40(v14, v11, v19);
      v15 = &v19;
      if ( &v19 )
      {
        *(_DWORD *)&v19 = 52428;
LABEL_12:
        v17 = (int)(v15 + 8);
        goto LABEL_14;
      }
    }
    return 0;
  }
  v17 = 0;
LABEL_14:
  if ( !v17 )
    return 0;
  sub_10030CF0((void *)v17, 0, 2 * v12);
  v18 = MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, cbMultiByte, (LPWSTR)v17, v12);
  if ( v18 )
    v8 = GetStringTypeW(dwInfoType, (LPCWSTR)v17, v18, lpCharType);
  sub_1002563B(v12, v17);
  return v8;
}
// 10067210: using guessed type int __security_cookie;

//----- (10040308) --------------------------------------------------------
int __usercall sub_10040308<eax>(int a1<ebx>, int a2<edi>, int a3, DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, int a9)
{
  int result; // eax@1
  int v10; // [sp+0h] [bp-10h]@1
  int v11; // [sp+8h] [bp-8h]@2
  char v12; // [sp+Ch] [bp-4h]@1

  sub_1002E635((int)&v10, a1, a2, a3);
  result = sub_1004021C((int)&v10, dwInfoType, lpMultiByteStr, cbMultiByte, lpCharType, CodePage, a9);
  if ( v12 )
    *(_DWORD *)(v11 + 112) &= 0xFFFFFFFDu;
  return result;
}

//----- (10040346) --------------------------------------------------------
int __usercall sub_10040346<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, const void *lpMem, unsigned int a5, unsigned int a6)
{
  int v6; // edi@1
  int result; // eax@3
  int v8; // esi@4
  SIZE_T v9; // eax@5
  int v10; // ST08_4@5
  int v11; // ebx@6

  v6 = 0;
  if ( a5 && (a1 = 0xFFFFFFE0 % a5, 0xFFFFFFE0 / a5 < a6) )
  {
    *(_DWORD *)sub_1002F144(a3) = 12;
    result = 0;
  }
  else
  {
    v8 = a6 * a5;
    if ( lpMem )
    {
      v9 = sub_100325D4((int)lpMem, 0, lpMem);
      a2 = v10;
      v6 = v9;
    }
    v11 = sub_10028586(a1, a2, (int)lpMem, v6, (LPVOID)lpMem, v8);
    if ( v11 )
    {
      if ( v6 < (unsigned int)v8 )
        sub_10030CF0((void *)(v6 + v11), 0, v8 - v6);
    }
    result = v11;
  }
  return result;
}

//----- (100403AF) --------------------------------------------------------
LPVOID __usercall sub_100403AF<eax>(void *this<ecx>, int ebx0<ebx>, unsigned int a2, unsigned int a3, int a4)
{
  int v5; // eax@3
  unsigned int v7; // esi@6
  LPVOID v8; // ecx@8

  if ( a2 && 0xFFFFFFE0 / a2 < a3 )
  {
    v5 = sub_1002F144(ebx0);
  }
  else
  {
    v7 = a3 * a2;
    if ( !(a3 * a2) )
      v7 = 1;
    do
    {
      v8 = 0;
      if ( v7 <= 0xFFFFFFE0 )
      {
        v8 = HeapAlloc(hHeap, 8u, v7);
        if ( v8 )
          return v8;
      }
      if ( !dword_10069C90 )
      {
        if ( a4 )
          *(_DWORD *)a4 = 12;
        return v8;
      }
    }
    while ( sub_10038C10(v7) );
    v5 = a4;
    if ( !a4 )
      return 0;
  }
  *(_DWORD *)v5 = 12;
  return 0;
}
// 10069C90: using guessed type int dword_10069C90;

//----- (100404F1) --------------------------------------------------------
PVOID __cdecl sub_100404F1()
{
  return DecodePointer(dword_10069F10);
}

//----- (100404FE) --------------------------------------------------------
int __cdecl sub_100404FE(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10069F08 = (PVOID)a1;
  dword_10069F0C = a1;
  dword_10069F10 = (PVOID)a1;
  dword_10069F14 = a1;
  return result;
}
// 10069F0C: using guessed type int dword_10069F0C;
// 10069F14: using guessed type int dword_10069F14;

//----- (1004051A) --------------------------------------------------------
void __cdecl sub_1004051A(int a1)
{
  int v1; // ebx@1
  int v2; // edi@1
  int v3; // eax@7
  PVOID v4; // eax@9
  PVOID v5; // eax@10
  int v6; // edx@10
  int v7; // ecx@10
  unsigned int v8; // eax@10
  int v9; // ST08_4@10
  int v10; // edx@30
  int v11; // ecx@30
  int *v12; // [sp+28h] [bp-1Ch]@9

  v1 = 0;
  v2 = 0;
  if ( a1 > 11 )
  {
    if ( a1 == 15 )
    {
      v12 = &dword_10069F14;
      v4 = (PVOID)dword_10069F14;
      goto LABEL_18;
    }
    if ( a1 == 21 )
    {
      v12 = &dword_10069F0C;
      v4 = (PVOID)dword_10069F0C;
      goto LABEL_18;
    }
    if ( a1 != 22 )
      goto LABEL_14;
    goto LABEL_15;
  }
  if ( a1 != 11 )
  {
    if ( a1 == 2 )
    {
      v12 = (int *)&dword_10069F08;
      v4 = dword_10069F08;
LABEL_18:
      v1 = 1;
      v5 = DecodePointer(v4);
      goto LABEL_19;
    }
    if ( a1 != 4 )
    {
      if ( a1 != 6 )
      {
        if ( a1 == 8 )
          goto LABEL_7;
LABEL_14:
        *(_DWORD *)sub_1002F144(0) = 22;
        sub_10036C88(0, 0);
        return;
      }
LABEL_15:
      v12 = (int *)&dword_10069F10;
      v4 = dword_10069F10;
      goto LABEL_18;
    }
  }
LABEL_7:
  v3 = sub_10031BEF(0);
  v2 = v3;
  if ( !v3 )
    return;
  v8 = sub_100406CF(a1, *(_DWORD *)(v3 + 92));
  v7 = v9;
  v12 = (int *)(v8 + 8);
  v5 = *(PVOID *)(v8 + 8);
LABEL_19:
  if ( v5 == (PVOID)1 )
    return;
  if ( !v5 )
    sub_10032409(v6, v7, v1, v2, 3u);
  if ( v1 )
    sub_1002E493(v6, v7, v1, v2, 0);
  if ( a1 == 8 || a1 == 11 || a1 == 4 )
  {
    *(_DWORD *)(v2 + 96) = 0;
    if ( a1 != 8 )
      goto LABEL_33;
    *(_DWORD *)(v2 + 100) = 140;
  }
  if ( a1 == 8 )
  {
    v11 = dword_10059DD8;
    v10 = dword_10059DD8;
    while ( v10 < v11 + dword_10059DDC )
    {
      *(_DWORD *)(12 * v10++ + *(_DWORD *)(v2 + 92) + 8) = 0;
      v11 = dword_10059DD8;
    }
    goto LABEL_34;
  }
LABEL_33:
  *v12 = (int)EncodePointer(0);
LABEL_34:
  if ( v1 )
    sub_1002E5F7(0);
}
// 10059DD8: using guessed type int dword_10059DD8;
// 10059DDC: using guessed type int dword_10059DDC;
// 10069F0C: using guessed type int dword_10069F0C;
// 10069F14: using guessed type int dword_10069F14;

//----- (100406CF) --------------------------------------------------------
unsigned int __cdecl sub_100406CF(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  unsigned int result; // eax@6

  v2 = a2;
  do
  {
    if ( *(_DWORD *)(v2 + 4) == a1 )
      break;
    v2 += 12;
  }
  while ( v2 < a2 + 12 * dword_10059DD0 );
  if ( v2 >= a2 + 12 * dword_10059DD0 || *(_DWORD *)(v2 + 4) != a1 )
    result = 0;
  else
    result = v2;
  return result;
}
// 10059DD0: using guessed type int dword_10059DD0;

//----- (1004070B) --------------------------------------------------------
signed int __cdecl sub_1004070B(double a1)
{
  int v1; // eax@2
  int v2; // eax@3
  signed int result; // eax@5
  int v4; // ecx@10
  signed int v5; // [sp+4h] [bp-4h]@6

  if ( (WORD3(a1) & 0x7FF0) == 32752 )
  {
    v1 = sub_100408A4(SLODWORD(a1), SHIDWORD(a1)) - 1;
    if ( v1 )
    {
      v2 = v1 - 1;
      if ( v2 )
      {
        if ( v2 != 1 )
          return 1;
        v5 = 2;
      }
      else
      {
        v5 = 4;
      }
      result = v5;
    }
    else
    {
      result = 512;
    }
  }
  else
  {
    v4 = WORD3(a1) & 0x8000;
    if ( !(WORD3(a1) & 0x7FF0) && (HIDWORD(a1) & 0xFFFFF || LODWORD(a1)) )
    {
      result = v4 != 0 ? 16 : 128;
    }
    else
    {
      if ( 0.0 == a1 )
        result = v4 != 0 ? 32 : 64;
      else
        result = v4 != 0 ? 8 : 256;
    }
  }
  return result;
}

//----- (100407A7) --------------------------------------------------------
#error "FFFFFFFF: variables would overlap: edx/4 and edx/8 (funcsize=79)"

//----- (10040879) --------------------------------------------------------
double __cdecl sub_10040879(double a1, __int16 a2)
{
  double v3; // ST00_8@1

  v3 = a1;
  WORD3(v3) = WORD3(a1) & 0x800F | 16 * (a2 + 1022);
  return v3;
}

//----- (100408A4) --------------------------------------------------------
signed int __cdecl sub_100408A4(int a1, int a2)
{
  if ( a2 == 2146435072 )
  {
    if ( !a1 )
      return 1;
  }
  else
  {
    if ( a2 == -1048576 && !a1 )
      return 2;
  }
  if ( (HIWORD(a2) & 0x7FF8) == 32760 )
    return 3;
  if ( (HIWORD(a2) & 0x7FF8) == 32752 && (a2 & 0x7FFFF || a1) )
    return 4;
  return 0;
}

//----- (10040900) --------------------------------------------------------
int __cdecl sub_10040900(char a1)
{
  if ( a1 & 0x20 )
    return 5;
  if ( a1 & 8 )
    return 1;
  if ( a1 & 4 )
    return 2;
  if ( a1 & 1 )
    return 3;
  return 2 * (a1 & 2);
}

//----- (10040932) --------------------------------------------------------
int __usercall sub_10040932<eax>(int a1<ebp>, int a2<edi>, signed int a3, int a4, int a5, int a6, double a7, int a8)
{
  double v8; // ST1C_8@1
  int v9; // eax@3
  __int16 v10; // cx@6
  int v12; // ST24_4@7
  char v13; // ST28_1@7
  char v14; // [sp+2Ch] [bp-8Ch]@2
  int v15; // [sp+6Ch] [bp-4Ch]@2
  unsigned int v16; // [sp+A8h] [bp-10h]@1
  int v17; // [sp+ACh] [bp-Ch]@1
  void *v18; // [sp+B0h] [bp-8h]@1
  char v19; // [sp+B4h] [bp-4h]@5
  int v20; // [sp+B8h] [bp+0h]@1

  v17 = a1;
  v18 = (void *)v20;
  v16 = (unsigned int)&v17 ^ __security_cookie;
  HIDWORD(v8) = a8;
  LODWORD(v8) = &a7;
  if ( !sub_100409FA(a3, v8) )
  {
    v15 &= 0xFFFFFFFEu;
    sub_10040C47((ULONG_PTR)&v14, (int)&a8, a3, a4, (int)&a5, (int)&a7, 0);
  }
  v9 = sub_10040900(a3);
  if ( dword_10068400 || !v9 )
  {
    sub_10040F2C((int)&v19, v9);
    sub_1004107C(v10);
  }
  else
  {
    sub_10040F59((int)&v19, v9, a4, a5, a6, COERCE_UNSIGNED_INT64(0.0), COERCE_UNSIGNED_INT64(0.0) >> 32, a7);
  }
  return sub_10022B30((int)&v19, a2, v12, (unsigned int)&v17 ^ v16, v13);
}
// 10040932: could not find valid save-restore pair for ebp
// 10067210: using guessed type int __security_cookie;
// 10068400: using guessed type int dword_10068400;

//----- (100409FA) --------------------------------------------------------
bool __cdecl sub_100409FA(signed int a1, double a2)
{
  char v2; // bl@1
  int v3; // esi@1
  int v4; // eax@9
  int v5; // ecx@13
  double v6; // st7@13
  signed int v7; // edi@27
  double v8; // st7@30
  double v9; // st7@31
  signed int v10; // edx@32
  unsigned int v11; // eax@35
  int v12; // ecx@35
  double v14; // [sp+18h] [bp-Ch]@30

  v2 = a1;
  v3 = a1 & 0x1F;
  if ( a1 & 8 && BYTE4(a2) & 1 )
  {
    sub_100410A5();
    v3 &= 0xFFFFFFF7u;
    goto LABEL_49;
  }
  if ( a1 & 4 && BYTE4(a2) & 4 )
  {
    sub_100410A5();
    v3 &= 0xFFFFFFFBu;
    goto LABEL_49;
  }
  if ( a1 & 1 && BYTE4(a2) & 8 )
  {
    sub_100410A5();
    v4 = WORD2(a2) & 0xC00;
    if ( WORD2(a2) & 0xC00 )
    {
      if ( v4 != 1024 )
      {
        if ( v4 != 2048 )
        {
          if ( v4 != 3072 )
          {
LABEL_24:
            v3 &= 0xFFFFFFFEu;
            goto LABEL_49;
          }
          v5 = LODWORD(a2);
          v6 = dbl_10067F88;
          if ( *LODWORD(a2) <= 0.0 )
            goto LABEL_22;
LABEL_23:
          *(_QWORD *)v5 = *(_QWORD *)&v6;
          goto LABEL_24;
        }
        v5 = LODWORD(a2);
        if ( *LODWORD(a2) <= 0.0 )
        {
          v6 = dbl_10067F88;
LABEL_22:
          v6 = -v6;
          goto LABEL_23;
        }
LABEL_20:
        v6 = dbl_10067F78;
        goto LABEL_23;
      }
      v5 = LODWORD(a2);
      if ( *LODWORD(a2) > 0.0 )
      {
        v6 = dbl_10067F88;
        goto LABEL_23;
      }
    }
    else
    {
      v5 = LODWORD(a2);
      if ( *LODWORD(a2) > 0.0 )
        goto LABEL_20;
    }
    v6 = dbl_10067F78;
    goto LABEL_22;
  }
  if ( a1 & 2 )
  {
    if ( BYTE4(a2) & 0x10 )
    {
      v7 = 0;
      if ( a1 & 0x10 )
        v7 = 1;
      if ( 0.0 == *LODWORD(a2) )
      {
        v7 = 1;
      }
      else
      {
        v8 = *LODWORD(a2);
        sub_100407A7(v8, (int)&a1);
        v14 = v8;
        a1 -= 1536;
        if ( a1 >= -1074 )
        {
          v10 = 0;
          if ( v8 < 0.0 )
            v10 = 1;
          WORD3(v14) = BYTE6(v14) & 0xF | 0x10;
          if ( a1 < -1021 )
          {
            v12 = -1021 - a1;
            v11 = LODWORD(v14);
            do
            {
              if ( LOBYTE(v14) & 1 )
              {
                if ( !v7 )
                  v7 = 1;
              }
              v11 >>= 1;
              LODWORD(v14) = v11;
              if ( BYTE4(v14) & 1 )
              {
                v11 |= 0x80000000u;
                LODWORD(v14) = v11;
              }
              HIDWORD(v14) >>= 1;
              --v12;
            }
            while ( v12 );
          }
          v9 = v14;
          if ( v10 )
            v9 = -v14;
        }
        else
        {
          v9 = v8 * 0.0;
          v7 = 1;
        }
        *LODWORD(a2) = *(_QWORD *)&v9;
      }
      if ( v7 )
        sub_100410A5();
      v3 &= 0xFFFFFFFDu;
    }
  }
LABEL_49:
  if ( v2 & 0x10 )
  {
    if ( BYTE4(a2) & 0x20 )
    {
      sub_100410A5();
      v3 &= 0xFFFFFFEFu;
    }
  }
  return v3 == 0;
}
// 10067F78: using guessed type double dbl_10067F78;
// 10067F88: using guessed type double dbl_10067F88;

//----- (10040BD6) --------------------------------------------------------
double __usercall sub_10040BD6<st0>(__int16 a1<cx>, int a2<ebx>, int a3, double a4)
{
  double result; // st7@2

  if ( dword_10068400 )
  {
    *(_DWORD *)sub_1002F144(a2) = 33;
    sub_1004107C(a1);
    result = a4;
  }
  else
  {
    result = sub_10040F59(
               a2,
               1,
               a3,
               SLODWORD(a4),
               SHIDWORD(a4),
               COERCE_UNSIGNED_INT64(0.0),
               COERCE_UNSIGNED_INT64(0.0) >> 32,
               a4);
  }
  return result;
}
// 10068400: using guessed type int dword_10068400;

//----- (10040C26) --------------------------------------------------------
int __cdecl sub_10040C26(ULONG_PTR Arguments, int a2, char a3, int a4, int a5, int a6)
{
  return sub_10040C47(Arguments, a2, a3, a4, a5, a6, 0);
}

//----- (10040C47) --------------------------------------------------------
int __cdecl sub_10040C47(ULONG_PTR Arguments, int a2, char a3, int a4, int a5, int a6, int a7)
{
  char v7; // cl@1
  DWORD v8; // edi@2
  char v9; // al@12
  int v10; // esi@12
  ULONG_PTR v11; // ecx@12
  int v12; // eax@22
  int v13; // eax@27
  ULONG_PTR v14; // ecx@27
  int v15; // eax@31
  int v16; // eax@35
  ULONG_PTR v17; // ecx@35
  int v18; // ecx@38
  int v19; // ecx@38
  int v20; // ebx@39
  ULONG_PTR v21; // ecx@41
  int v22; // eax@51
  int v23; // eax@52
  int v24; // eax@53
  int v25; // eax@56
  int v26; // eax@60
  int v27; // eax@61
  int result; // eax@62

  *(_DWORD *)(Arguments + 4) = 0;
  *(_DWORD *)(Arguments + 8) = 0;
  *(_DWORD *)(Arguments + 12) = 0;
  v7 = a3;
  if ( a3 & 0x10 )
  {
    v8 = -1073741681;
    *(_DWORD *)(Arguments + 4) |= 1u;
  }
  else
  {
    v8 = Arguments;
  }
  if ( v7 & 2 )
  {
    v8 = -1073741677;
    *(_DWORD *)(Arguments + 4) |= 2u;
  }
  if ( v7 & 1 )
  {
    v8 = -1073741679;
    *(_DWORD *)(Arguments + 4) |= 4u;
  }
  if ( v7 & 4 )
  {
    v8 = -1073741682;
    *(_DWORD *)(Arguments + 4) |= 8u;
  }
  if ( v7 & 8 )
  {
    v8 = -1073741680;
    *(_DWORD *)(Arguments + 4) |= 0x10u;
  }
  v10 = a2;
  *(_DWORD *)(Arguments + 8) ^= (*(_DWORD *)(Arguments + 8) ^ ~(16 * *(_DWORD *)a2)) & 0x10;
  *(_DWORD *)(Arguments + 8) ^= (*(_DWORD *)(Arguments + 8) ^ ~(2 * *(_DWORD *)v10)) & 8;
  *(_DWORD *)(Arguments + 8) ^= (*(_DWORD *)(Arguments + 8) ^ ~(*(_DWORD *)v10 >> 1)) & 4;
  *(_DWORD *)(Arguments + 8) ^= (*(_DWORD *)(Arguments + 8) ^ ~(*(_DWORD *)v10 >> 3)) & 2;
  v11 = Arguments;
  *(_DWORD *)(v11 + 8) ^= (*(_DWORD *)(Arguments + 8) ^ ~(*(_DWORD *)v10 >> 5)) & 1;
  v9 = sub_100410FB((int (*)(void))v11);
  if ( v9 & 1 )
    *(_DWORD *)(Arguments + 12) |= 0x10u;
  if ( v9 & 4 )
    *(_DWORD *)(Arguments + 12) |= 8u;
  if ( v9 & 8 )
    *(_DWORD *)(Arguments + 12) |= 4u;
  if ( v9 & 0x10 )
    *(_DWORD *)(Arguments + 12) |= 2u;
  if ( v9 & 0x20 )
    *(_DWORD *)(Arguments + 12) |= 1u;
  v12 = *(_DWORD *)v10 & 0xC00;
  if ( !(*(_DWORD *)v10 & 0xC00) )
  {
    *(_DWORD *)Arguments &= 0xFFFFFFFCu;
    goto LABEL_31;
  }
  if ( v12 == 1024 )
  {
    v14 = Arguments;
    v13 = *(_DWORD *)Arguments & 0xFFFFFFFD | 1;
    goto LABEL_28;
  }
  if ( v12 == 2048 )
  {
    v14 = Arguments;
    v13 = *(_DWORD *)Arguments & 0xFFFFFFFE | 2;
LABEL_28:
    *(_DWORD *)v14 = v13;
    goto LABEL_31;
  }
  if ( v12 == 3072 )
    *(_DWORD *)Arguments |= 3u;
LABEL_31:
  v15 = *(_DWORD *)v10 & 0x300;
  if ( !(*(_DWORD *)v10 & 0x300) )
  {
    v17 = Arguments;
    v16 = *(_DWORD *)Arguments & 0xFFFFFFEB | 8;
    goto LABEL_37;
  }
  if ( v15 == 512 )
  {
    v17 = Arguments;
    v16 = *(_DWORD *)Arguments & 0xFFFFFFE7 | 4;
LABEL_37:
    *(_DWORD *)v17 = v16;
    goto LABEL_38;
  }
  if ( v15 == 768 )
    *(_DWORD *)Arguments &= 0xFFFFFFE3u;
LABEL_38:
  v19 = *(_DWORD *)Arguments ^ 32 * a4;
  v18 = v19 & 0x1FFE0;
  *(_DWORD *)Arguments ^= v18;
  *(_DWORD *)(Arguments + 32) |= 1u;
  if ( a7 )
  {
    *(_DWORD *)(Arguments + 32) &= 0xFFFFFFE1u;
    *(float *)(Arguments + 16) = *(float *)a5;
    *(_DWORD *)(Arguments + 96) |= 1u;
    v20 = a6;
    *(_DWORD *)(Arguments + 96) &= 0xFFFFFFE1u;
    *(float *)(Arguments + 80) = *(float *)v20;
  }
  else
  {
    *(_DWORD *)(Arguments + 32) = *(_DWORD *)(Arguments + 32) & 0xFFFFFFE3 | 2;
    *(double *)(Arguments + 16) = *(double *)a5;
    *(_DWORD *)(Arguments + 96) |= 1u;
    v18 = Arguments;
    v20 = a6;
    *(_DWORD *)(Arguments + 96) = *(_DWORD *)(Arguments + 96) & 0xFFFFFFE3 | 2;
    *(double *)(Arguments + 80) = *(double *)v20;
  }
  sub_1004106D((int (*)(void))v18);
  RaiseException(v8, 0, 1u, &Arguments);
  v21 = Arguments;
  if ( *(_BYTE *)(Arguments + 8) & 0x10 )
    *(_DWORD *)v10 &= 0xFFFFFFFEu;
  if ( *(_BYTE *)(v21 + 8) & 8 )
    *(_DWORD *)v10 &= 0xFFFFFFFBu;
  if ( *(_BYTE *)(v21 + 8) & 4 )
    *(_DWORD *)v10 &= 0xFFFFFFF7u;
  if ( *(_BYTE *)(v21 + 8) & 2 )
    *(_DWORD *)v10 &= 0xFFFFFFEFu;
  if ( *(_BYTE *)(v21 + 8) & 1 )
    *(_DWORD *)v10 &= 0xFFFFFFDFu;
  v22 = *(_DWORD *)v21 & 3;
  if ( !v22 )
  {
    *(_DWORD *)v10 &= 0xFFFFF3FFu;
    goto LABEL_60;
  }
  v23 = v22 - 1;
  if ( !v23 )
  {
    v25 = *(_DWORD *)v10 & 0xFFFFF7FF | 0x400;
    goto LABEL_57;
  }
  v24 = v23 - 1;
  if ( !v24 )
  {
    v25 = *(_DWORD *)v10 & 0xFFFFFBFF | 0x800;
LABEL_57:
    *(_DWORD *)v10 = v25;
    goto LABEL_60;
  }
  if ( v24 == 1 )
    *(_DWORD *)v10 |= 0xC00u;
LABEL_60:
  v26 = (*(_DWORD *)v21 >> 2) & 7;
  if ( !v26 )
  {
    result = *(_DWORD *)v10 & 0xFFFFF3FF | 0x300;
    goto LABEL_66;
  }
  v27 = v26 - 1;
  if ( !v27 )
  {
    result = *(_DWORD *)v10 & 0xFFFFF3FF | 0x200;
LABEL_66:
    *(_DWORD *)v10 = result;
    goto LABEL_67;
  }
  result = v27 - 1;
  if ( !result )
    *(_DWORD *)v10 &= 0xFFFFF3FFu;
LABEL_67:
  if ( a7 )
    *(float *)v20 = *(float *)(v21 + 80);
  else
    *(double *)v20 = *(double *)(v21 + 80);
  return result;
}

//----- (10040F2C) --------------------------------------------------------
int __usercall sub_10040F2C<eax>(int a1<ebx>, int a2)
{
  int result; // eax@2

  if ( a2 == 1 )
  {
    result = sub_1002F144(a1);
    *(_DWORD *)result = 33;
  }
  else
  {
    result = a2 - 2;
    if ( (unsigned int)(a2 - 2) <= 1 )
    {
      result = sub_1002F144(a1);
      *(_DWORD *)result = 34;
    }
  }
  return result;
}

//----- (10040F59) --------------------------------------------------------
double __usercall sub_10040F59<st0>(int a1<ebx>, int a2, int a3, int a4, int a5, int a6, int a7, double a8)
{
  signed int v8; // eax@1
  int v9; // ecx@1
  double result; // st7@9
  int v11; // [sp+0h] [bp-20h]@7
  int v12; // [sp+4h] [bp-1Ch]@6
  int v13; // [sp+8h] [bp-18h]@7
  int v14; // [sp+Ch] [bp-14h]@7
  int v15; // [sp+10h] [bp-10h]@7
  int v16; // [sp+14h] [bp-Ch]@7
  double v17; // [sp+18h] [bp-8h]@7

  v9 = 0;
  v8 = 0;
  while ( dword_10067FA0[2 * v8] != a3 )
  {
    ++v8;
    if ( v8 >= 29 )
      goto LABEL_6;
  }
  v9 = (int)*(&off_10067FA4 + 2 * v8);
LABEL_6:
  v12 = v9;
  if ( v9 )
  {
    v13 = a4;
    v14 = a5;
    v15 = a6;
    v16 = a7;
    v17 = a8;
    v11 = a2;
    sub_1004107C(v9);
    if ( !sub_1003AF6A() )
      sub_10040F2C(a1, a2);
    result = v17;
  }
  else
  {
    sub_1004107C(0);
    sub_10040F2C(a1, a2);
    result = a8;
  }
  return result;
}
// 10067FA0: using guessed type int dword_10067FA0[];
// 10067FA4: using guessed type void *off_10067FA4;

//----- (10040FF7) --------------------------------------------------------
int __cdecl sub_10040FF7(int a1)
{
  int result; // eax@2
  int v2; // [sp+30h] [bp+8h]@5

  if ( dword_100695C0 >= 1 )
  {
    result = a1;
    if ( a1 & 0x40 && dword_100680A0 )
    {
      __asm { ldmxcsr [ebp+arg_0] }
    }
    else
    {
      result = a1 & 0xFFFFFFBF;
      v2 = a1 & 0xFFFFFFBF;
      __asm { ldmxcsr [ebp+arg_0] }
    }
  }
  return result;
}
// 100680A0: using guessed type int dword_100680A0;
// 100695C0: using guessed type int dword_100695C0;

//----- (1004106D) --------------------------------------------------------
int __thiscall sub_1004106D(int (*this)(void))
{
  __asm { fnclex }
  return this();
}

//----- (1004107C) --------------------------------------------------------
int __fastcall sub_1004107C(__int16 a1)
{
  return a1;
}

//----- (100410A5) --------------------------------------------------------
void __cdecl sub_100410A5()
{
  ;
}

//----- (100410FB) --------------------------------------------------------
int __thiscall sub_100410FB(int (*this)(void))
{
  return this();
}

//----- (10041109) --------------------------------------------------------
signed int __usercall sub_10041109<eax>(int a1<edi>, int a2, int a3, unsigned int a4, int a5, int a6, int a7)
{
  return sub_1004112A(a1, a2, a3, a4, a5, a6, a7, 0);
}

//----- (1004112A) --------------------------------------------------------
signed int __usercall sub_1004112A<eax>(int a1<edi>, int a2, int a3, unsigned int a4, int a5, int a6, int a7, int a8)
{
  signed int result; // eax@4

  switch ( a5 )
  {
    case 101:
    case 69:
      result = sub_10041677(a2, a3, a4, a6, a7, a8);
      break;
    case 102:
      result = sub_1004182D(a2, a3, a4, a6, a8);
      break;
    case 97:
    case 65:
      result = sub_100411B0(a1, a2, a3, a4, a6, a7, a8);
      break;
    default:
      result = sub_100418EC(a2, a3, a4, a6, a7, a8);
      break;
  }
  return result;
}

//----- (100411B0) --------------------------------------------------------
signed int __usercall sub_100411B0<eax>(int a1<edi>, int a2, int a3, unsigned int a4, int a5, int a6, int a7)
{
  int v7; // edi@1
  int v8; // esi@3
  int v9; // eax@5
  signed int v10; // edi@8
  int v11; // edx@9
  unsigned int v12; // ebx@9
  unsigned int v13; // eax@10
  void *v14; // ecx@12
  int v15; // eax@16
  char v16; // zf@21
  int v17; // esi@22
  int v18; // eax@22
  int v19; // ecx@26
  int v20; // esi@26
  int v21; // eax@29
  int v22; // eax@31
  signed int v23; // ecx@31
  unsigned int v24; // eax@33
  unsigned __int64 v25; // qax@33
  unsigned __int64 v26; // qt0@35
  unsigned __int64 v27; // qax@37
  int i; // eax@38
  signed int v29; // eax@51
  unsigned __int64 v30; // qcx@51
  unsigned int v31; // ecx@51
  unsigned __int8 v32; // cf@51
  int v33; // esi@52
  int v34; // edi@54
  int v35; // edx@57
  __int64 v36; // ST0C_8@61
  int v37; // edx@61
  __int64 v38; // ST0C_8@66
  int v40; // [sp-4h] [bp-3Ch]@5
  int v41; // [sp+Ch] [bp-2Ch]@1
  int v42; // [sp+14h] [bp-24h]@69
  char v43; // [sp+18h] [bp-20h]@68
  int v44; // [sp+20h] [bp-18h]@29
  int v45; // [sp+24h] [bp-14h]@9
  int v46; // [sp+28h] [bp-10h]@21
  int v47; // [sp+2Ch] [bp-Ch]@26
  unsigned int v48; // [sp+30h] [bp-8h]@1
  int v49; // [sp+34h] [bp-4h]@1
  unsigned int v50; // [sp+44h] [bp+Ch]@31
  int v51; // [sp+4Ch] [bp+14h]@31

  v49 = 48;
  v48 = 1023;
  sub_1002E635((int)&v41, 0, a1, a7);
  v7 = a5;
  if ( a5 < 0 )
    v7 = 0;
  v8 = a3;
  if ( !a3 || !a4 )
  {
    v9 = sub_1002F144(0);
    v40 = 22;
LABEL_8:
    v10 = v40;
    *(_DWORD *)v9 = v40;
    sub_10036C88(0, v40);
    goto LABEL_68;
  }
  *(_BYTE *)a3 = 0;
  if ( a4 <= v7 + 11 )
  {
    v9 = sub_1002F144(0);
    v40 = 34;
    goto LABEL_8;
  }
  v11 = a2;
  v12 = *(_DWORD *)(a2 + 4);
  v45 = *(_DWORD *)a2;
  if ( ((v12 >> 20) & 0x7FF) == 2047 )
  {
    v13 = -1;
    if ( a4 != -1 )
      v13 = a4 - 2;
    v10 = sub_1004150A(a2, a3 + 2, v13, v7, 0);
    if ( v10 )
    {
      *(_BYTE *)a3 = 0;
    }
    else
    {
      if ( *(_BYTE *)(a3 + 2) == 45 )
      {
        *(_BYTE *)a3 = 45;
        v8 = a3 + 1;
      }
      *(_BYTE *)v8 = 48;
      *(_BYTE *)(v8 + 1) = (((a6 == 0) - 1) & 0xE0) + 120;
      v15 = sub_10049F90(v14, v8 + 2, 0x65u);
      if ( v15 )
      {
        *(_BYTE *)v15 = (((a6 == 0) - 1) & 0xE0) + 112;
        *(_BYTE *)(v15 + 3) = 0;
      }
      v10 = 0;
    }
  }
  else
  {
    if ( v12 & 0x80000000 )
    {
      *(_BYTE *)a3 = 45;
      v8 = a3 + 1;
    }
    *(_BYTE *)v8 = 48;
    *(_BYTE *)(v8 + 1) = (((a6 == 0) - 1) & 0xE0) + 120;
    v16 = (*(_DWORD *)(a2 + 4) & 0x7FF00000) == 0;
    v46 = a6 != 0 ? 7 : 39;
    if ( v16 )
    {
      *(_BYTE *)(v8 + 2) = 48;
      v18 = *(_DWORD *)(a2 + 4);
      v17 = v8 + 3;
      if ( v18 & 0xFFFFF | *(_DWORD *)a2 )
        v48 = 1022;
      else
        v48 = 0;
    }
    else
    {
      *(_BYTE *)(v8 + 2) = 49;
      v17 = v8 + 3;
    }
    v19 = v17;
    v20 = v17 + 1;
    v47 = v19;
    if ( v7 )
      *(_BYTE *)v19 = ***(_BYTE ***)(v41 + 132);
    else
      *(_BYTE *)v19 = 0;
    v21 = *(_DWORD *)(a2 + 4);
    v44 = v21 & 0xFFFFF;
    if ( v21 & 0xFFFFF || *(_DWORD *)a2 )
    {
      v51 = 0;
      LOWORD(v22) = v49;
      v23 = 983040;
      v50 = 983040;
      do
      {
        if ( v7 <= 0 )
          break;
        LODWORD(v25) = v51 & *(_DWORD *)v11;
        HIDWORD(v25) = v23 & *(_DWORD *)(v11 + 4);
        HIDWORD(v25) &= 0xFFFFFu;
        v24 = (unsigned __int16)(sub_1004A4D0(v25, v49) + 48);
        if ( v24 > 0x39 )
          v24 += a6 != 0 ? 7 : 39;
        v11 = a2;
        *(_BYTE *)v20 = v24;
        LODWORD(v26) = v51;
        HIDWORD(v26) = v50;
        v51 = v26 >> 4;
        v23 = v50 >> 4;
        v22 = v49 - 4;
        ++v20;
        --v7;
        v50 >>= 4;
        v49 = v22;
      }
      while ( (_WORD)v22 >= 0 );
      if ( (_WORD)v22 >= 0 )
      {
        LODWORD(v27) = v51 & *(_DWORD *)v11;
        HIDWORD(v27) = v23 & *(_DWORD *)(v11 + 4);
        HIDWORD(v27) &= 0xFFFFFu;
        if ( (unsigned __int16)sub_1004A4D0(v27, v49) > 8u )
        {
          for ( i = v20 - 1; *(_BYTE *)i == 102 || *(_BYTE *)i == 70; --i )
            *(_BYTE *)i = 48;
          if ( i == v47 )
          {
            ++*(_BYTE *)(i - 1);
          }
          else
          {
            if ( *(_BYTE *)i == 57 )
              *(_BYTE *)i = v46 + 58;
            else
              ++*(_BYTE *)i;
          }
        }
      }
    }
    if ( v7 > 0 )
    {
      sub_10030CF0((void *)v20, 0x30u, v7);
      v20 += v7;
    }
    if ( !*(_BYTE *)v47 )
      v20 = v47;
    *(_BYTE *)v20 = (((a6 == 0) - 1) & 0xE0) + 112;
    LOWORD(v31) = sub_1004A4D0(*(_QWORD *)a2, 0x34u);
    v29 = 0;
    v31 &= 0x7FFu;
    v32 = v31 < v48;
    LODWORD(v30) = v31 - v48;
    HIDWORD(v30) = -v32;
    if ( (signed int)v32 > 0 )
    {
      *(_BYTE *)(v20 + 1) = 45;
      v33 = v20 + 2;
      v30 = -v30;
    }
    else
    {
      *(_BYTE *)(v20 + 1) = 43;
      v33 = v20 + 2;
    }
    v34 = v33;
    *(_BYTE *)v33 = 48;
    if ( HIDWORD(v30) >= 0 )
    {
      if ( (HIDWORD(v30) > 0 || (_DWORD)v30 >= 0x3E8u)
        && (*(_BYTE *)v33 = sub_1004A3F0(v30, 1000i64) + 48, ++v33, v29 = 0, v44 = v35, v33 != v34)
        || HIDWORD(v30) >= v29 && (HIDWORD(v30) > v29 || (_DWORD)v30 >= 0x64u) )
      {
        HIDWORD(v36) = v29;
        LODWORD(v36) = 100;
        *(_BYTE *)v33++ = sub_1004A3F0(v30, v36) + 48;
        v44 = v37;
        v29 = 0;
      }
    }
    if ( v33 != v34 || HIDWORD(v30) >= v29 && (HIDWORD(v30) > v29 || (_DWORD)v30 >= 0xAu) )
    {
      HIDWORD(v38) = v29;
      LODWORD(v38) = 10;
      *(_BYTE *)v33++ = sub_1004A3F0(v30, v38) + 48;
      v44 = HIDWORD(v30);
      v29 = 0;
    }
    *(_BYTE *)v33 = v30 + 48;
    *(_BYTE *)(v33 + 1) = v29;
    v10 = v29;
  }
LABEL_68:
  if ( v43 )
    *(_DWORD *)(v42 + 112) &= 0xFFFFFFFDu;
  return v10;
}

//----- (1004150A) --------------------------------------------------------
signed int __cdecl sub_1004150A(int a1, int a2, unsigned int a3, int a4, int a5)
{
  return sub_10041677(a1, a2, a3, a4, a5, 0);
}

//----- (10041528) --------------------------------------------------------
int __usercall sub_10041528<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned int a4, int a5, int a6, int a7, char a8, int a9)
{
  int v9; // eax@3
  int v10; // eax@4
  int v11; // edx@4
  int v12; // edi@4
  int v13; // esi@11
  int v14; // eax@15
  int v15; // esi@15
  int v16; // edx@21
  signed __int64 v17; // qax@24
  signed __int64 v18; // qtt@24
  signed __int64 v19; // qax@26
  signed __int64 v20; // qtt@26
  int v22; // [sp-4h] [bp-1Ch]@3
  int v23; // [sp+8h] [bp-10h]@1
  int v24; // [sp+10h] [bp-8h]@32
  char v25; // [sp+14h] [bp-4h]@31

  sub_1002E635((int)&v23, a1, a2, a9);
  if ( !a3 || !a4 )
  {
    v9 = sub_1002F144(a3);
    v22 = 22;
LABEL_8:
    v12 = v22;
    *(_DWORD *)v9 = v22;
    sub_10036C88(a3, v22);
    goto LABEL_31;
  }
  v11 = a5;
  v12 = 0;
  v10 = a5;
  if ( a5 <= 0 )
    v10 = 0;
  if ( a4 <= v10 + 9 )
  {
    v9 = sub_1002F144(a3);
    v22 = 34;
    goto LABEL_8;
  }
  if ( a8 )
  {
    sub_10041B6D(a3 + (*(_DWORD *)a7 == 45), a5 > 0);
    v11 = a5;
  }
  v13 = a3;
  if ( *(_DWORD *)a7 == 45 )
  {
    *(_BYTE *)a3 = 45;
    v13 = a3 + 1;
  }
  if ( v11 > 0 )
  {
    *(_BYTE *)v13 = *(_BYTE *)(v13 + 1);
    ++v13;
    *(_BYTE *)v13 = ***(_BYTE ***)(v23 + 132);
  }
  v15 = v11 + (a8 == 0) + v13;
  v14 = -1;
  if ( a4 != -1 )
    v14 = a4 + a3 - v15;
  if ( sub_10031E6C(a3, 0, v15, v14, (int)"e+000") )
  {
    sub_10036C98(a3, 0);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10041677);
  }
  if ( a6 )
    *(_BYTE *)v15 = 69;
  if ( **(_BYTE **)(a7 + 12) != 48 )
  {
    v16 = *(_DWORD *)(a7 + 4) - 1;
    if ( v16 < 0 )
    {
      v16 = -v16;
      *(_BYTE *)(v15 + 1) = 45;
    }
    if ( v16 >= 100 )
    {
      v17 = v16;
      v18 = v17;
      LODWORD(v17) = v17 / 100;
      v16 = v18 % 100;
      *(_BYTE *)(v15 + 2) += v17;
    }
    if ( v16 >= 10 )
    {
      v19 = v16;
      v20 = v19;
      LODWORD(v19) = v19 / 10;
      v16 = v20 % 10;
      *(_BYTE *)(v15 + 3) += v19;
    }
    *(_BYTE *)(v15 + 4) += v16;
  }
  if ( byte_1006A070 & 1 )
  {
    if ( *(_BYTE *)(v15 + 2) == 48 )
      sub_100237D0((void *)(v15 + 2), (const void *)(v15 + 3), 3u);
  }
LABEL_31:
  if ( v25 )
    *(_DWORD *)(v24 + 112) &= 0xFFFFFFFDu;
  return v12;
}
// 1006A070: using guessed type char byte_1006A070;

//----- (10041677) --------------------------------------------------------
signed int __cdecl sub_10041677(int a1, int a2, unsigned int a3, int a4, int a5, int a6)
{
  signed int v6; // esi@1
  int v7; // eax@2
  signed int result; // eax@3
  unsigned int v9; // ecx@6
  int v10; // [sp+Ch] [bp-2Ch]@1
  char v11; // [sp+1Ch] [bp-1Ch]@1
  unsigned int v12; // [sp+34h] [bp-4h]@1
  int v13; // [sp+38h] [bp+0h]@1

  v12 = (unsigned int)&v13 ^ __security_cookie;
  v6 = 22;
  loc_1004A355(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), &v10, &v11, 22);
  if ( !a2 )
  {
    v7 = sub_1002F144(a4);
LABEL_3:
    *(_DWORD *)v7 = v6;
    sub_10036C88(a4, a2);
    return v6;
  }
  if ( !a3 )
  {
    v7 = sub_1002F144(a4);
    v6 = 22;
    goto LABEL_3;
  }
  v9 = -1;
  if ( a3 != -1 )
    v9 = a3 - (v10 == 45) - (a4 > 0);
  result = sub_1004A0C7(a4, a2 + (v10 == 45) + (a4 > 0), v9, a4 + 1, (int)&v10);
  if ( result )
    *(_BYTE *)a2 = 0;
  else
    result = sub_10041528(a4, a2, a2, a3, a4, a5, (int)&v10, 0, a6);
  return result;
}
// 10067210: using guessed type int __security_cookie;

//----- (10041743) --------------------------------------------------------
signed int __usercall sub_10041743<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6, char a7, int a8)
{
  int v8; // esi@1
  int v9; // eax@3
  signed int v10; // ebx@3
  int v11; // edi@4
  int v12; // eax@9
  int v13; // esi@10
  int v14; // eax@13
  int v15; // esi@13
  int v16; // eax@16
  int v18; // [sp+8h] [bp-14h]@1
  int v19; // [sp+10h] [bp-Ch]@20
  char v20; // [sp+14h] [bp-8h]@19
  int v21; // [sp+18h] [bp-4h]@1

  v21 = *(_DWORD *)(a6 + 4) - 1;
  sub_1002E635((int)&v18, a1, a2, a8);
  v8 = a3;
  if ( a3 && a4 )
  {
    v10 = 0;
    v11 = a5;
    if ( a7 )
    {
      if ( v21 == a5 )
        *(_WORD *)(v21 + (*(_DWORD *)a6 == 45) + a3) = 48;
    }
    if ( *(_DWORD *)a6 == 45 )
    {
      *(_BYTE *)a3 = 45;
      v8 = a3 + 1;
    }
    v12 = *(_DWORD *)(a6 + 4);
    if ( v12 > 0 )
    {
      v13 = v12 + v8;
    }
    else
    {
      sub_10041B6D(v8, 1);
      *(_BYTE *)v8 = 48;
      v13 = v8 + 1;
    }
    if ( a5 > 0 )
    {
      sub_10041B6D(v13, 1);
      *(_BYTE *)v13 = ***(_BYTE ***)(v18 + 132);
      v15 = v13 + 1;
      v14 = *(_DWORD *)(a6 + 4);
      if ( v14 < 0 )
      {
        if ( a7 )
        {
          v11 = -v14;
        }
        else
        {
          v16 = -v14;
          if ( a5 >= v16 )
            v11 = v16;
        }
        sub_10041B6D(v15, v11);
        sub_10030CF0((void *)v15, 0x30u, v11);
      }
    }
  }
  else
  {
    v9 = sub_1002F144(a1);
    v10 = 22;
    *(_DWORD *)v9 = 22;
    sub_10036C88(22, a2);
  }
  if ( v20 )
    *(_DWORD *)(v19 + 112) &= 0xFFFFFFFDu;
  return v10;
}

//----- (1004182D) --------------------------------------------------------
signed int __cdecl sub_1004182D(int a1, int a2, int a3, int a4, int a5)
{
  signed int result; // eax@2
  unsigned int v6; // ecx@5
  int v7; // [sp+8h] [bp-2Ch]@1
  int v8; // [sp+Ch] [bp-28h]@7
  char v9; // [sp+18h] [bp-1Ch]@1
  unsigned int v10; // [sp+30h] [bp-4h]@1
  int v11; // [sp+34h] [bp+0h]@1

  v10 = (unsigned int)&v11 ^ __security_cookie;
  loc_1004A355(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), &v7, &v9, 22);
  if ( a2 )
  {
    if ( a3 )
    {
      v6 = -1;
      if ( a3 != -1 )
        v6 = a3 - (v7 == 45);
      result = sub_1004A0C7(a4, a2 + (v7 == 45), v6, a4 + v8, (int)&v7);
      if ( result )
        *(_BYTE *)a2 = 0;
      else
        result = sub_10041743(a4, a2, a2, a3, a4, (int)&v7, 0, a5);
    }
    else
    {
      *(_DWORD *)sub_1002F144(22) = 22;
      sub_10036C88(22, a2);
      result = 22;
    }
  }
  else
  {
    *(_DWORD *)sub_1002F144(22) = 22;
    sub_10036C88(22, 0);
    result = 22;
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;

//----- (100418EC) --------------------------------------------------------
signed int __cdecl sub_100418EC(int a1, int a2, unsigned int a3, int a4, int a5, int a6)
{
  signed int result; // eax@2
  unsigned int v7; // eax@5
  bool v8; // ecx@5
  int v9; // ebx@5
  char v10; // al@12
  int v11; // [sp+8h] [bp-30h]@1
  int v12; // [sp+Ch] [bp-2Ch]@5
  int v13; // [sp+18h] [bp-20h]@5
  char v14; // [sp+1Ch] [bp-1Ch]@1
  unsigned int v15; // [sp+34h] [bp-4h]@1
  int v16; // [sp+38h] [bp+0h]@1

  v15 = (unsigned int)&v16 ^ __security_cookie;
  loc_1004A355(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), &v11, &v14, 22);
  if ( a2 )
  {
    if ( a3 )
    {
      v13 = v12 - 1;
      v8 = v11 == 45;
      v7 = -1;
      v9 = v8 + a2;
      if ( a3 != -1 )
        v7 = a3 - v8;
      result = sub_1004A0C7(v9, v9, v7, a4, (int)&v11);
      if ( result )
      {
        *(_BYTE *)a2 = 0;
      }
      else
      {
        if ( v12 - 1 < -4 || v12 - 1 >= a4 )
        {
          result = sub_10041528(v9, a2, a2, a3, a4, a5, (int)&v11, 1, a6);
        }
        else
        {
          if ( v13 < v12 - 1 )
          {
            do
              v10 = *(_BYTE *)v9++;
            while ( v10 );
            *(_BYTE *)(v9 - 2) = 0;
          }
          result = sub_10041743(v9, a2, a2, a3, a4, (int)&v11, 1, a6);
        }
      }
    }
    else
    {
      *(_DWORD *)sub_1002F144(22) = 22;
      sub_10036C88(22, a2);
      result = 22;
    }
  }
  else
  {
    *(_DWORD *)sub_1002F144(22) = 22;
    sub_10036C88(22, 0);
    result = 22;
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;

//----- (100419E9) --------------------------------------------------------
char __usercall sub_100419E9<al>(int a1<ebx>, int a2<edi>, int a3)
{
  return sub_100419FA(a1, a2, a3, 0);
}

//----- (100419FA) --------------------------------------------------------
char __usercall sub_100419FA<al>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  int v4; // edx@1
  char i; // cl@1
  int v6; // eax@4
  int v7; // edx@4
  char v8; // al@9
  int v9; // esi@10
  int v11; // [sp+4h] [bp-10h]@1
  int v12; // [sp+Ch] [bp-8h]@16
  char v13; // [sp+10h] [bp-4h]@15

  sub_1002E635((int)&v11, a1, a2, a4);
  v4 = a3;
  for ( i = *(_BYTE *)a3; *(_BYTE *)v4; i = *(_BYTE *)v4 )
  {
    if ( i == ***(_BYTE ***)(v11 + 132) )
      break;
    ++v4;
  }
  LOBYTE(v6) = *(_BYTE *)v4;
  v7 = v4 + 1;
  if ( (_BYTE)v6 )
  {
    while ( 1 )
    {
      v8 = *(_BYTE *)v7;
      if ( !*(_BYTE *)v7 )
        break;
      if ( v8 == 101 || v8 == 69 )
        break;
      ++v7;
    }
    v9 = v7;
    do
      --v7;
    while ( *(_BYTE *)v7 == 48 );
    if ( *(_BYTE *)v7 == ***(_BYTE ***)(v11 + 132) )
      --v7;
    do
    {
      LOBYTE(v6) = *(_BYTE *)v9;
      ++v7;
      ++v9;
      *(_BYTE *)v7 = v6;
    }
    while ( (_BYTE)v6 );
  }
  if ( v13 )
  {
    v6 = v12;
    *(_DWORD *)(v6 + 112) &= 0xFFFFFFFDu;
  }
  return v6;
}

//----- (10041A78) --------------------------------------------------------
int __usercall sub_10041A78<eax>(int a1<ebx>, int a2, int a3, int a4)
{
  return sub_10041A90(a1, a2, a3, a4, 0);
}

//----- (10041A90) --------------------------------------------------------
int __usercall sub_10041A90<eax>(int a1<ebx>, int a2, int a3, int a4, int a5)
{
  int result; // eax@2
  int v6; // ecx@2
  int v7; // [sp+0h] [bp-8h]@2
  int v8; // [sp+4h] [bp-4h]@2

  if ( a2 )
  {
    sub_1004A177(a1, (int)&v7, a4, a5);
    v6 = a3;
    *(_DWORD *)a3 = v7;
    result = v8;
    *(_DWORD *)(v6 + 4) = v8;
  }
  else
  {
    sub_1004A203(a1, (int)&a2, a4, a5);
    result = a2;
    *(_DWORD *)a3 = a2;
  }
  return result;
}

//----- (10041AD0) --------------------------------------------------------
char __usercall sub_10041AD0<al>(int a1<ebx>, int a2<edi>, int *a3)
{
  return sub_10041AE1(a1, a2, a3, 0);
}

//----- (10041AE1) --------------------------------------------------------
char __usercall sub_10041AE1<al>(int a1<ebx>, int a2<edi>, int *a3, int a4)
{
  char i; // zf@1
  signed int *v5; // esi@1
  char v6; // cl@6
  int v7; // esi@6
  int v8; // eax@7
  int v10; // [sp+4h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-8h]@9
  char v12; // [sp+10h] [bp-4h]@8

  sub_1002E635((int)&v10, a1, a2, a4);
  v5 = a3;
  for ( i = sub_100314F3(a1, a2, *(_BYTE *)a3) == 101; !i; i = sub_1002E853(a1, a2, *(_BYTE *)v5) == 0 )
    v5 = (signed int *)((char *)v5 + 1);
  if ( sub_100314F3(a1, a2, *(_BYTE *)v5) == 120 )
    v5 = (signed int *)((char *)v5 + 2);
  v6 = *(_BYTE *)v5;
  *(_BYTE *)v5 = ***(_BYTE ***)(v10 + 132);
  v7 = (int)((char *)v5 + 1);
  do
  {
    LOBYTE(v8) = *(_BYTE *)v7;
    *(_BYTE *)v7 = v6;
    v6 = v8;
    LOBYTE(v8) = *(_BYTE *)v7++;
  }
  while ( (_BYTE)v8 );
  if ( v12 )
  {
    v8 = v11;
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFDu;
  }
  return v8;
}

//----- (10041B53) --------------------------------------------------------
bool __cdecl sub_10041B53(int a1)
{
  return *(double *)a1 >= 0.0;
}

//----- (10041B6D) --------------------------------------------------------
void __cdecl sub_10041B6D(int a1, int a2)
{
  int v2; // eax@2

  if ( a2 )
  {
    v2 = sub_1002CFA0(a1);
    sub_100237D0((void *)(a1 + a2), (const void *)a1, v2 + 1);
  }
}

//----- (10041B95) --------------------------------------------------------
signed int __usercall sub_10041B95<eax>(int a1<ebx>, int a2<edi>)
{
  signed int result; // eax@1

  result = sub_1004A4EF(a1, a2, 0, 65536, 196608);
  if ( result )
  {
    sub_10036C98(a1, a2);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10041BBC);
  }
  return result;
}

//----- (10041BBC) --------------------------------------------------------
int (*__cdecl sub_10041BBC())()
{
  unsigned int v0; // esi@1
  int (*result)(); // eax@2

  v0 = 0;
  do
  {
    result = (int (*)())EncodePointer(*(int (**)())((char *)off_100680A4 + v0));
    *(int (**)())((char *)off_100680A4 + v0) = result;
    v0 += 4;
  }
  while ( v0 < 0x28 );
  return result;
}
// 100680A4: using guessed type int (*off_100680A4[10])();

//----- (10041BDB) --------------------------------------------------------
int __usercall sub_10041BDB<eax>(int a1<ebx>, int a2<edi>, int a3, const WCHAR *a4)
{
  int result; // eax@3
  const WCHAR *v5; // ecx@4
  int v6; // edx@5
  unsigned __int16 v7; // ax@6
  unsigned __int16 v8; // si@8
  const WCHAR v9; // ax@10

  if ( dword_10069EE8 )
  {
    result = sub_10041C6E(a1, a2, a3, a4, 0);
  }
  else
  {
    if ( a3 && (v5 = a4, a4) )
    {
      v6 = a3 - (_DWORD)a4;
      do
      {
        v7 = *(const WCHAR *)((char *)v5 + v6);
        if ( v7 < 0x41u || v7 > 0x5Au )
          v8 = *(const WCHAR *)((char *)v5 + v6);
        else
          v8 = v7 + 32;
        v9 = *v5;
        if ( *v5 >= 0x41u )
        {
          if ( v9 <= 0x5Au )
            v9 += 32;
        }
        ++v5;
      }
      while ( v8 && v8 == v9 );
      result = v8 - v9;
    }
    else
    {
      *(_DWORD *)sub_1002F144(a1) = 22;
      sub_10036C88(a1, a2);
      result = 2147483647;
    }
  }
  return result;
}
// 10069EE8: using guessed type int dword_10069EE8;

//----- (10041C6E) --------------------------------------------------------
int __usercall sub_10041C6E<eax>(int a1<ebx>, int a2<edi>, int a3, const WCHAR *a4, int a5)
{
  int v5; // ebx@1
  const WCHAR *v6; // esi@2
  int v7; // edx@3
  int v8; // ebx@5
  unsigned __int16 v9; // ax@6
  WCHAR v10; // ax@10
  int v12; // [sp+8h] [bp-10h]@1
  int v13; // [sp+10h] [bp-8h]@20
  char v14; // [sp+14h] [bp-4h]@19

  sub_1002E635((int)&v12, a1, a2, a5);
  v5 = a3;
  if ( a3 && (v6 = a4, a4) )
  {
    if ( *(_DWORD *)(v12 + 168) )
    {
      do
      {
        a2 = sub_1004A555(v5, a2, *(_WORD *)v5, (int)&v12);
        v5 += 2;
        v10 = sub_1004A555(v5, a2, *v6, (int)&v12);
        ++v6;
      }
      while ( (_WORD)a2 && (_WORD)a2 == v10 );
    }
    else
    {
      v8 = a3 - (_DWORD)a4;
      do
      {
        v9 = *(const WCHAR *)((char *)v6 + v8);
        if ( v9 < 0x41u || v9 > 0x5Au )
          LOWORD(a2) = *(const WCHAR *)((char *)v6 + v8);
        else
          LOWORD(a2) = v9 + 32;
        v10 = *v6;
        if ( *v6 >= 0x41u )
        {
          if ( v10 <= 0x5Au )
            v10 += 32;
        }
        ++v6;
      }
      while ( (_WORD)a2 && (_WORD)a2 == v10 );
    }
    v7 = (unsigned __int16)a2 - v10;
  }
  else
  {
    *(_DWORD *)sub_1002F144(a3) = 22;
    sub_10036C88(a3, a2);
    v7 = 2147483647;
  }
  if ( v14 )
    *(_DWORD *)(v13 + 112) &= 0xFFFFFFFDu;
  return v7;
}

//----- (10041D47) --------------------------------------------------------
int __usercall sub_10041D47<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3, int a4)
{
  int result; // eax@1
  int v5; // [sp+0h] [bp-10h]@1
  int v6; // [sp+8h] [bp-8h]@2
  char v7; // [sp+Ch] [bp-4h]@1

  sub_1002E635((int)&v5, a1, a2, a4);
  result = *(_WORD *)(*(_DWORD *)(v5 + 144) + 2 * a3) & 0x8000;
  if ( v7 )
    *(_DWORD *)(v6 + 112) &= 0xFFFFFFFDu;
  return result;
}

//----- (10041D7D) --------------------------------------------------------
int __usercall sub_10041D7D<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3)
{
  return sub_10041D47(a1, a2, a3, 0);
}

//----- (10041D8E) --------------------------------------------------------
unsigned int __cdecl sub_10041D8E(int a1, unsigned int a2)
{
  unsigned int result; // eax@1
  int v3; // ecx@2

  result = 0;
  if ( a2 )
  {
    v3 = a1;
    do
    {
      if ( !*(_WORD *)v3 )
        break;
      ++result;
      v3 += 2;
    }
    while ( result < a2 );
  }
  return result;
}

//----- (10041DB0) --------------------------------------------------------
int __usercall sub_10041DB0<eax>(int a1<edx>, __int16 a2<cx>, int a3<ebp>, __int16 a4<fpstat>, double _ST7<st0>, char a6, char a7, char a8)
{
  signed __int16 v8; // bx@2

  if ( *(_BYTE *)(a1 + 14) == 5 )
  {
    HIBYTE(v8) = ((unsigned __int8)(*(_WORD *)(a3 - 164) >> 8) | 2) & 0xFE;
    LOBYTE(v8) = 63;
  }
  else
  {
    v8 = 4927;
  }
  *(_WORD *)(a3 - 162) = v8;
  _EBX = &unk_1005A08C;
  __asm { fxam }
  *(_DWORD *)(a3 - 148) = a1;
  *(_WORD *)(a3 - 160) = a4;
  *(_BYTE *)(a3 - 144) = 0;
  LOBYTE(a2) = __ROL__((char)(2 * *(_BYTE *)(a3 - 159)) >> 1, 1);
  _AL = a2 & 0xF;
  __asm { xlat }
  return (*(int (__thiscall **)(int))(_AL + a1 + 16))(a2 & 0x404);
}

//----- (10041E17) --------------------------------------------------------
int __usercall sub_10041E17<eax>(int a1<edx>, int a2<ebp>, __int16 a3<fpstat>, double _ST6<st1>, double a5<st0>, char a6, char a7, char a8)
{
  signed __int16 v8; // bx@2
  __int16 v11; // fps@4
  char v13; // cl@4
  __int16 v14; // cx@4
  char v17; // ah@4

  if ( *(_BYTE *)(a1 + 14) == 5 )
  {
    HIBYTE(v8) = ((unsigned __int8)(*(_WORD *)(a2 - 164) >> 8) | 2) & 0xFE;
    LOBYTE(v8) = 63;
  }
  else
  {
    v8 = 4927;
  }
  *(_WORD *)(a2 - 162) = v8;
  _EBX = &unk_1005A08C;
  __asm { fxam }
  *(_DWORD *)(a2 - 148) = a1;
  *(_WORD *)(a2 - 160) = a3;
  *(_BYTE *)(a2 - 144) = 0;
  UNDEF(v11);
  _ST6 = a5;
  v13 = *(_BYTE *)(a2 - 159);
  __asm { fxam }
  *(_WORD *)(a2 - 160) = v11;
  HIBYTE(v14) = __ROL__((char)(2 * *(_BYTE *)(a2 - 159)) >> 1, 1);
  _AL = HIBYTE(v14) & 0xF;
  __asm { xlat }
  v17 = _AL;
  LOBYTE(v14) = __ROL__((char)(2 * v13) >> 1, 1);
  _AL = v14 & 0xF;
  __asm { xlat }
  return (*(int (__thiscall **)(int))((char)(4 * v17 | _AL) + a1 + 16))(v14 & 0x404);
}

//----- (10041EBD) --------------------------------------------------------
double __cdecl sub_10041EBD()
{
  return 1.0;
}

//----- (10041EC2) --------------------------------------------------------
double __usercall sub_10041EC2<st0>(int a1<ebp>, double a2<st0>)
{
  double result; // st7@1

  *(_QWORD *)(a1 - 158) = *(_QWORD *)&a2;
  result = *(double *)(a1 - 158);
  if ( *(_BYTE *)(a1 - 151) & 0x40 )
  {
    *(_BYTE *)(a1 - 144) = 7;
  }
  else
  {
    *(_BYTE *)(a1 - 144) = 1;
    result = result + 1.0;
  }
  return result;
}

//----- (10041F69) --------------------------------------------------------
void __usercall sub_10041F69(int a1<ebp>)
{
  *(_BYTE *)(a1 - 144) = 1;
}

//----- (10041F80) --------------------------------------------------------
void __cdecl sub_10041F80()
{
  JUMPOUT(*(unsigned int *)loc_10041FA0);
}
// 10041FA0: using guessed type int __cdecl loc_10041FA0(__int16, int, int, int);

//----- (10041F97) --------------------------------------------------------
double __usercall sub_10041F97<st0>(int a1<eax>, int a2<edx>, int a3<ecx>, double a4<st0>, __int16 a5, int a6, int a7, int a8)
{
  int ebp0; // ebp@0
  int v10; // [sp+0h] [bp-20h]@1
  int v11; // [sp+4h] [bp-1Ch]@1
  int v12; // [sp+8h] [bp-18h]@1
  int v13; // [sp+Ch] [bp-14h]@1
  double v14; // [sp+18h] [bp-8h]@1

  v10 = a1;
  v14 = a4;
  v11 = a3;
  v12 = a7;
  v13 = a8;
  sub_1004A659(ebp0, a2, (int)&v10, (int)&a5);
  return v14;
}

//----- (10041FF5) --------------------------------------------------------
void __cdecl sub_10041FF5()
{
  ;
}

//----- (1004200C) --------------------------------------------------------
double __usercall sub_1004200C<st0>(int a1<eax>, double result<st0>)
{
  if ( !(a1 & 0x80000) )
    result = result + 1.0;
  return result;
}

//----- (10042025) --------------------------------------------------------
double __fastcall sub_10042025(int a1, int a2)
{
  double result; // st7@2

  if ( (*(_DWORD *)(a2 + 4) & 0x7FF00000) == 2146435072 )
    result = COERCE_DOUBLE(*(_QWORD *)a2 << 11);
  else
    result = *(double *)a2;
  return result;
}

//----- (10042068) --------------------------------------------------------
int __cdecl sub_10042068(int a1, int a2)
{
  int result; // eax@1

  result = a2 & 0x7FF00000;
  if ( (a2 & 0x7FF00000) == 2146435072 )
    result = a2;
  return result;
}

//----- (10042170) --------------------------------------------------------
int __usercall sub_10042170<eax>(unsigned int a1<eax>, int a2<ecx>)
{
  unsigned int i; // eax@1
  int v3; // ecx@1
  int v5; // [sp-4h] [bp-4h]@1
  void *v6; // [sp+0h] [bp+0h]@1
  int v7; // [sp+0h] [bp+0h]@3

  v5 = a2;
  v3 = (unsigned int)&v6 >= a1 ? (int)((char *)&v6 - a1) : 0;
  for ( i = (unsigned int)&v5 & 0xFFFFF000; v3 < i; i -= 4096 )
    ;
  return v7;
}

//----- (100421A0) --------------------------------------------------------
int __cdecl sub_100421A0(int a1, unsigned int a2)
{
  int result; // eax@1
  unsigned int v3; // edx@1
  int v4; // ecx@1
  unsigned int v5; // esi@2

  v4 = a1 + *(_DWORD *)(a1 + 60);
  v3 = 0;
  result = v4 + *(_WORD *)(v4 + 20) + 24;
  if ( *(_WORD *)(v4 + 6) )
  {
    while ( 1 )
    {
      v5 = *(_DWORD *)(result + 12);
      if ( a2 >= v5 )
      {
        if ( a2 < v5 + *(_DWORD *)(result + 8) )
          break;
      }
      ++v3;
      result += 40;
      if ( v3 >= *(_WORD *)(v4 + 6) )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (100421F0) --------------------------------------------------------
unsigned int __usercall sub_100421F0<eax>(int a1<eax>, int a2)
{
  int v2; // eax@1
  int v3; // eax@2
  unsigned int result; // eax@3
  unsigned int v5; // [sp-10h] [bp-28h]@1
  unsigned int *v6; // [sp+0h] [bp-18h]@1
  int v7; // [sp+8h] [bp-10h]@1
  int (__cdecl *v8)(PEXCEPTION_RECORD, int, int); // [sp+Ch] [bp-Ch]@1
  unsigned int v9; // [sp+10h] [bp-8h]@1
  int v10; // [sp+14h] [bp-4h]@1
  int v11; // [sp+18h] [bp+0h]@1

  v8 = sub_10032060;
  v7 = a1;
  v9 = __security_cookie ^ (unsigned int)&unk_10061140;
  v5 = (unsigned int)&v11 ^ __security_cookie;
  v6 = &v5;
  v10 = 0;
  LOBYTE(v2) = sub_100422B0(268435456);
  if ( v2 && (v3 = sub_100421A0(268435456, a2 - 268435456)) != 0 )
  {
    result = ~(unsigned __int8)(*(_DWORD *)(v3 + 36) >> 31) & 1;
    v10 = -2;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;

//----- (100422B0) --------------------------------------------------------
char __cdecl sub_100422B0(int a1)
{
  char result; // al@2
  int v2; // ecx@3

  if ( *(_WORD *)a1 == 23117 )
  {
    v2 = a1 + *(_DWORD *)(a1 + 60);
    result = 0;
    if ( *(_DWORD *)v2 == 17744 )
      result = *(_WORD *)(v2 + 24) == 267;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100422F0) --------------------------------------------------------
int __usercall sub_100422F0<eax>(int a1<ebp>, int a2, int a3, unsigned int a4)
{
  int result; // eax@2
  unsigned int v5; // esi@2
  int v6; // ebx@5
  char v7; // [sp-8h] [bp-28h]@1
  int (__cdecl *v8)(int, int, int, int); // [sp-4h] [bp-24h]@1
  unsigned int v9; // [sp+0h] [bp-20h]@1
  unsigned int v10; // [sp+4h] [bp-1Ch]@1
  int v11; // [sp+8h] [bp-18h]@1
  int v12; // [sp+Ch] [bp-14h]@1

  v12 = a2;
  v11 = a3;
  v10 = a4;
  v8 = loc_10042380;
  v9 = (unsigned int)&v7 ^ __security_cookie;
  while ( 1 )
  {
    result = a3;
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 == -2 )
      break;
    if ( a4 != -2 && v5 <= a4 )
      break;
    v6 = (*(_DWORD *)a2 ^ *(_DWORD *)(a3 + 8)) + 12 * v5 + 16;
    *(_DWORD *)(a3 + 12) = *(_DWORD *)((*(_DWORD *)a2 ^ *(_DWORD *)(a3 + 8)) + 12 * v5 + 0x10);
    if ( !*(_DWORD *)(v6 + 4) )
    {
      sub_10048EE5(*(_DWORD *)(v6 + 8), a1, 257);
      sub_10048F04(*(int (**)(void))(v6 + 8));
    }
  }
  return result;
}
// 10042380: using guessed type int __cdecl loc_10042380(int, int, int, int);
// 10067210: using guessed type int __security_cookie;

//----- (100423E2) --------------------------------------------------------
int __thiscall sub_100423E2(void *this)
{
  return ((int (__fastcall *)(_DWORD, _DWORD))this)(this, 0);
}

//----- (100423F9) --------------------------------------------------------
int __fastcall sub_100423F9(int a1, int a2)
{
  int v3; // esi@1

  v3 = a1;
  sub_10048EE5(a1, a2, 1);
  return ((int (__fastcall *)(_DWORD, _DWORD))v3)(0, 0);
}

//----- (10042412) --------------------------------------------------------
void __fastcall sub_10042412(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord)
{
  RtlUnwind(TargetFrame, loc_10042426, ExceptionRecord, 0);
}
// 10042426: using guessed type int __fastcall loc_10042426(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord);

//----- (1004242B) --------------------------------------------------------
int __fastcall sub_1004242B(int a1, unsigned int a2, int a3, int a4)
{
  return sub_100422F0(a3, a4, a1, a2);
}

//----- (10042442) --------------------------------------------------------
int __cdecl sub_10042442(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10069FDC = a1;
  return result;
}
// 10069FDC: using guessed type int dword_10069FDC;

//----- (1004244F) --------------------------------------------------------
signed int __usercall sub_1004244F<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6)
{
  int v6; // ecx@2
  int v7; // edx@3
  int v8; // eax@5
  signed int result; // eax@6
  int v10; // esi@8
  int v11; // esi@12
  __int16 v12; // ax@13
  signed int v13; // [sp-4h] [bp-Ch]@5

  if ( !a4 || (v6 = a5, !a5) )
    goto LABEL_5;
  v7 = a6;
  if ( !a6 )
    goto LABEL_19;
  v10 = a4;
  do
  {
    if ( !*(_WORD *)v10 )
      break;
    v10 += 2;
    --v6;
  }
  while ( v6 );
  if ( !v6 )
  {
LABEL_19:
    *(_WORD *)a4 = 0;
LABEL_5:
    v8 = sub_1002F144(a3);
    v13 = 22;
LABEL_6:
    *(_DWORD *)v8 = v13;
    sub_10036C88(a3, a4);
    return v13;
  }
  v11 = v10 - a6;
  do
  {
    v12 = *(_WORD *)v7;
    *(_WORD *)(v11 + v7) = *(_WORD *)v7;
    v7 += 2;
    if ( !v12 )
      break;
    --v6;
  }
  while ( v6 );
  result = 0;
  if ( !v6 )
  {
    *(_WORD *)a4 = 0;
    v8 = sub_1002F144(a3);
    v13 = 34;
    goto LABEL_6;
  }
  return result;
}

//----- (100424BB) --------------------------------------------------------
signed int __usercall sub_100424BB<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5)
{
  int v5; // ecx@4

  if ( a5 >= 0 )
  {
    if ( a5 <= 2 )
    {
      v5 = dword_10069FE8;
      dword_10069FE8 = a5;
      return v5;
    }
    if ( a5 == 3 )
      return dword_10069FE8;
  }
  *(_DWORD *)sub_1002F144(a3) = 22;
  sub_10036C88(a3, a4);
  return -1;
}
// 10069FE8: using guessed type int dword_10069FE8;

//----- (100424FB) --------------------------------------------------------
int __cdecl sub_100424FB(const WCHAR *a1, int a2, int a3)
{
  int v3; // edi@1
  PVOID v4; // esi@1
  int v5; // eax@1
  HMODULE v6; // esi@2
  FARPROC v7; // eax@5
  FARPROC v8; // eax@6
  FARPROC v9; // eax@6
  FARPROC v10; // eax@6
  FARPROC v11; // eax@7
  PVOID v13; // eax@19
  int v14; // eax@21
  int v15; // esi@24
  int (*v16)(void); // eax@26
  PVOID v17; // eax@29
  PVOID v18; // eax@32
  char v20; // [sp+Ch] [bp-24h]@22
  int v21; // [sp+10h] [bp-20h]@1
  LPCWSTR lpOutputString; // [sp+14h] [bp-1Ch]@1
  PVOID v23; // [sp+18h] [bp-18h]@1
  int (*v24)(void); // [sp+1Ch] [bp-14h]@1
  char v25; // [sp+20h] [bp-10h]@22
  char v26; // [sp+28h] [bp-8h]@23
  unsigned int v27; // [sp+2Ch] [bp-4h]@1
  int v28; // [sp+30h] [bp+0h]@1

  v27 = (unsigned int)&v28 ^ __security_cookie;
  lpOutputString = a1;
  v3 = 0;
  v21 = a2;
  v4 = EncodePointer(0);
  v23 = v4;
  LOBYTE(v5) = sub_1003109A();
  v24 = (int (*)(void))v5;
  if ( !dword_10069FEC )
  {
    v6 = LoadLibraryExW(L"USER32.DLL", 0, 0x800u);
    if ( !v6 && (GetLastError() != 87 || (v6 = LoadLibraryW(L"USER32.DLL"), !v6))
      || (v7 = GetProcAddress(v6, "MessageBoxW"), !v7) )
      return 0;
    dword_10069FEC = EncodePointer(v7);
    v8 = GetProcAddress(v6, "GetActiveWindow");
    dword_10069FF0 = EncodePointer(v8);
    v9 = GetProcAddress(v6, "GetLastActivePopup");
    dword_10069FF4 = EncodePointer(v9);
    v10 = GetProcAddress(v6, "GetUserObjectInformationW");
    dword_10069FFC = EncodePointer(v10);
    if ( dword_10069FFC )
    {
      v11 = GetProcAddress(v6, "GetProcessWindowStation");
      dword_10069FF8 = EncodePointer(v11);
    }
    v4 = v23;
  }
  if ( IsDebuggerPresent() )
  {
    if ( lpOutputString )
      OutputDebugStringW(lpOutputString);
    if ( v24 )
      return 4;
  }
  else
  {
    if ( v24 )
    {
      DecodePointer(dword_10069FEC);
      return 3;
    }
  }
  if ( dword_10069FF8 == v4
    || dword_10069FFC == v4
    || (v24 = (int (*)(void))DecodePointer(dword_10069FF8), v13 = DecodePointer(dword_10069FFC), v23 = v13, !v24)
    || !v13
    || (v14 = v24()) != 0
    && ((int (__stdcall *)(int, signed int, char *, signed int, char *))v23)(v14, 1, &v25, 12, &v20)
    && v26 & 1 )
  {
    if ( dword_10069FF0 != v4 )
    {
      v16 = (int (*)(void))DecodePointer(dword_10069FF0);
      if ( v16 )
      {
        v3 = v16();
        if ( v3 )
        {
          if ( dword_10069FF4 != v4 )
          {
            v17 = DecodePointer(dword_10069FF4);
            if ( v17 )
              v3 = ((int (__stdcall *)(int))v17)(v3);
          }
        }
      }
    }
    v15 = a3;
  }
  else
  {
    v15 = a3 | 0x200000;
  }
  v18 = DecodePointer(dword_10069FEC);
  if ( v18 )
    return ((int (__stdcall *)(int, LPCWSTR, int, int))v18)(v3, lpOutputString, v21, v15);
  return 0;
}
// 10067210: using guessed type int __security_cookie;

//----- (100426DD) --------------------------------------------------------
int __usercall sub_100426DD<eax>(int a1<edi>, int a2, int a3, LCTYPE a4, LPSTR lpMultiByteStr, int cbMultiByte)
{
  int v6; // eax@1
  int v7; // ecx@1
  int v8; // ebx@1
  int v9; // esi@1
  unsigned int v11; // eax@5
  char *v12; // edi@6
  int v13; // eax@8
  int v14; // edi@10
  CHAR *v15; // [sp-10h] [bp-24h]@15
  int v16; // [sp-Ch] [bp-20h]@15
  char v17; // [sp+0h] [bp-14h]@6
  UINT CodePage; // [sp+Ch] [bp-8h]@1
  unsigned int v19; // [sp+10h] [bp-4h]@1
  int v20; // [sp+14h] [bp+0h]@1

  v19 = (unsigned int)&v20 ^ __security_cookie;
  v9 = 0;
  CodePage = *(_DWORD *)(*(_DWORD *)a2 + 4);
  v6 = sub_1003183E(a3, a4, 0, 0);
  v8 = v6;
  if ( !v6 )
    return 0;
  if ( v6 > 0 && 0xFFFFFFE0u / v6 >= 2 )
  {
    v11 = 2 * v6 + 8;
    if ( v11 > 0x400 )
    {
      v13 = sub_10028264(0xFFFFFFE0u % v8, v7, v8, a1, 2 * v8 + 8);
      v12 = (char *)v13;
      if ( v13 )
      {
        *(_DWORD *)v13 = 56797;
        goto LABEL_10;
      }
    }
    else
    {
      sub_10031E40(v11, v7, v17);
      v12 = &v17;
      if ( &v17 )
      {
        *(_DWORD *)&v17 = 52428;
LABEL_10:
        v14 = (int)(v12 + 8);
        goto LABEL_12;
      }
    }
    return 0;
  }
  v14 = 0;
LABEL_12:
  if ( !v14 )
    return 0;
  if ( sub_1003183E(a3, a4, (WCHAR *)v14, v8) )
  {
    if ( cbMultiByte )
    {
      v16 = cbMultiByte;
      v15 = lpMultiByteStr;
    }
    else
    {
      v16 = 0;
      v15 = 0;
    }
    v9 = WideCharToMultiByte(CodePage, 0, (LPCWSTR)v14, -1, v15, v16, 0, 0);
  }
  sub_1002563B(v8, v14);
  return v9;
}
// 10067210: using guessed type int __security_cookie;

//----- (100427B5) --------------------------------------------------------
int __usercall sub_100427B5<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, LCTYPE a5, LPSTR lpMultiByteStr, int cbMultiByte)
{
  int result; // eax@1
  int v8; // [sp+0h] [bp-10h]@1
  int v9; // [sp+8h] [bp-8h]@2
  char v10; // [sp+Ch] [bp-4h]@1

  sub_1002E635((int)&v8, a1, a2, a3);
  result = sub_100426DD(a2, (int)&v8, a4, a5, lpMultiByteStr, cbMultiByte);
  if ( v10 )
    *(_DWORD *)(v9 + 112) &= 0xFFFFFFFDu;
  return result;
}

//----- (100427ED) --------------------------------------------------------
int __thiscall sub_100427ED(int this, int a2, int a3, int a4)
{
  int v5; // eax@1

  *(_DWORD *)this = off_1005A88C;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_WORD *)(this + 12) = 0;
  *(_DWORD *)(this + 20) = a2;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  v5 = *(_DWORD *)(a3 + 16);
  *(_DWORD *)(this + 40) = a4;
  *(_DWORD *)(this + 36) = v5;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 44) = (*(_DWORD *)(a3 + 12) << 8) + *(_BYTE *)(*(_DWORD *)(a3 + 48) + 52 * a4 + 8);
  return this;
}
// 1005A88C: using guessed type int (*off_1005A88C[2])();

//----- (10042854) --------------------------------------------------------
int __thiscall sub_10042854(int this, int a2, int a3)
{
  int v4; // ebx@1
  int v5; // eax@1

  v4 = this;
  *(_DWORD *)this = off_1005A88C;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_WORD *)(this + 12) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 20) = a2;
  *(_DWORD *)(this + 24) = a3;
  *(_DWORD *)(this + 36) = (**(int (__thiscall ***)(_DWORD))a3)(a3);
  v5 = *(_DWORD *)(a3 + 40);
  *(_DWORD *)(v4 + 48) = 0;
  *(_DWORD *)(v4 + 40) = v5;
  *(_DWORD *)(v4 + 44) = (*(int (__thiscall **)(int))(*(_DWORD *)a3 + 4))(a3);
  return v4;
}
// 1005A88C: using guessed type int (*off_1005A88C[2])();

//----- (100428B3) --------------------------------------------------------
int __thiscall sub_100428B3(int this)
{
  return sub_1003364A(*(_DWORD *)(*(_DWORD *)(this + 20) + 12), *(_DWORD *)(this + 36), *(_DWORD *)(this + 40));
}

//----- (100428C5) --------------------------------------------------------
void __thiscall sub_100428C5(int this)
{
  int v1; // esi@1
  char v2; // zf@1
  char v3; // bl@2
  HANDLE v4; // eax@4

  v1 = this;
  v2 = *(_DWORD *)(this + 48) == 1;
  --*(_DWORD *)(v1 + 48);
  if ( v2 )
  {
    v3 = *(_DWORD *)(this + 28) != 0;
    sub_10042A70(this);
    if ( *(_DWORD *)(v1 + 24) )
    {
      sub_100428C5();
      sub_10043FF1(*(void **)(v1 + 20), (void *)v1);
    }
    else
    {
      sub_10043867(*(_DWORD *)(v1 + 20), *(_DWORD *)(v1 + 36), *(_DWORD *)(v1 + 40), v3 == 0);
      if ( !v3 )
      {
        v4 = GetCurrentThread();
        sub_10033113((DWORD_PTR *)(v1 + 8), v4);
        sub_1004380F(*(_DWORD *)(v1 + 20), v1);
        sub_100438F7(*(_DWORD *)(v1 + 20), v1);
      }
    }
  }
}

//----- (10042930) --------------------------------------------------------
int __thiscall sub_10042930(int this)
{
  return *(_DWORD *)(this + 44);
}

//----- (10042934) --------------------------------------------------------
int __thiscall sub_10042934(int this)
{
  return *(_DWORD *)(this + 36);
}

//----- (10042938) --------------------------------------------------------
BOOL __thiscall sub_10042938(int lpTlsValue)
{
  BOOL result; // eax@1
  int v2; // ebx@1
  int v3; // ecx@1
  int v4; // ecx@2
  int v5; // eax@4
  void *v6; // esi@4
  int v7; // eax@4
  int v8; // ecx@4
  int v9; // eax@4
  int v10; // edx@4
  char v11; // [sp+7h] [bp-1Dh]@2
  char v12; // [sp+8h] [bp-1Ch]@4
  int v13; // [sp+14h] [bp-10h]@4
  _DWORD v14[2]; // [sp+18h] [bp-Ch]@4
  int v15; // [sp+1Ch] [bp-8h]@4
  unsigned int v16; // [sp+20h] [bp-4h]@1
  int v17; // [sp+24h] [bp+0h]@1

  v16 = (unsigned int)&v17 ^ __security_cookie;
  v2 = lpTlsValue;
  v3 = *(_DWORD *)(lpTlsValue + 48);
  result = v3 + 1;
  *(_DWORD *)(v2 + 48) = v3 + 1;
  if ( !v3 )
  {
    v4 = *(_DWORD *)(v2 + 20);
    v11 = *(_DWORD *)(v2 + 28) != 0;
    if ( *(_DWORD *)(v2 + 24) )
    {
      sub_100434B2(v4, v2);
    }
    else
    {
      sub_10043DE4(v4, *(_DWORD *)(v2 + 36), *(_DWORD *)(v2 + 40), (*(_DWORD *)(v2 + 28) != 0) == 0);
      if ( !v11 )
      {
        v5 = (int)GetCurrentThread();
        v6 = (void *)v5;
        v7 = sub_10032D3B((int)&v12, v5);
        *(_WORD *)(v2 + 12) = *(_WORD *)(v7 + 4);
        *(_DWORD *)(v2 + 8) = *(_DWORD *)v7;
        v8 = 52 * *(_DWORD *)(v2 + 36);
        v9 = *(_DWORD *)(*(_DWORD *)(v2 + 20) + 16);
        v10 = *(_DWORD *)(v8 + v9);
        LOWORD(v8) = *(_WORD *)(v8 + v9 + 12);
        v14[0] = 0;
        v15 = 0;
        LOWORD(v14[0]) = v8;
        v13 = v10;
        sub_10033113((DWORD_PTR *)&v13, v6);
        sub_10043D88(*(_DWORD *)(v2 + 20), v2);
        sub_10043421(v2);
      }
    }
    result = sub_10042A8B((LPVOID)v2);
  }
  return result;
}
// 10043421: using guessed type _DWORD __stdcall sub_10043421(_DWORD);
// 10067210: using guessed type int __security_cookie;

//----- (10042A04) --------------------------------------------------------
int __thiscall sub_10042A04(int this, int a2)
{
  int ebp0; // ebp@0
  int v3; // edi@1
  int v4; // esi@1
  int v6; // [sp-4h] [bp-18h]@3
  int (__stdcall **v7)(char); // [sp+8h] [bp-Ch]@3

  v3 = a2;
  v4 = this;
  if ( !a2 )
  {
    a2 = (int)"pScheduler";
    sub_10023687((int)&v7, &a2);
    v7 = &off_100542CC;
    v6 = (int)&unk_10061764;
    goto LABEL_7;
  }
  if ( sub_100439FF(*(_DWORD *)(this + 20)) != (LPVOID)this || *(_DWORD *)(*(_DWORD *)(v4 + 20) + 8) != v3 )
  {
    sub_10024950((int)&v7);
    v6 = (int)&unk_100614E0;
LABEL_7:
    sub_1002D02B((int)&v7, v6);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10042A70);
  }
  return sub_1003602E(ebp0, v4);
}
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);

//----- (10042A70) --------------------------------------------------------
BOOL __thiscall sub_10042A70(int this)
{
  BOOL result; // eax@1
  int v2; // esi@1

  v2 = this;
  result = TlsSetValue(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 20) + 12) + 112), *(LPVOID *)(this + 32));
  *(_DWORD *)(v2 + 32) = 0;
  return result;
}

//----- (10042A8B) --------------------------------------------------------
BOOL __thiscall sub_10042A8B(LPVOID lpTlsValue)
{
  void *v2; // edi@1
  DWORD v3; // esi@1

  v2 = lpTlsValue;
  v3 = *(_DWORD *)(*(_DWORD *)(*((_DWORD *)lpTlsValue + 5) + 12) + 112);
  *((_DWORD *)lpTlsValue + 8) = TlsGetValue(v3);
  return TlsSetValue(v3, v2);
}

//----- (10042AAD) --------------------------------------------------------
unsigned int __cdecl sub_10042AAD(unsigned int a1)
{
  unsigned int result; // eax@1

  result = a1;
  if ( a1 )
    result = (a1 > 0 ? 2 : 0) - 1;
  return result;
}

//----- (10042AC5) --------------------------------------------------------
double __cdecl sub_10042AC5(double a1)
{
  double result; // st7@2
  signed int v2; // [sp+Ch] [bp+Ch]@4

  if ( 0.0 == a1 )
  {
    result = 0.0;
  }
  else
  {
    if ( a1 <= 0.0 )
      v2 = -1;
    else
      v2 = 1;
    result = (double)v2;
  }
  return result;
}

//----- (10042AFB) --------------------------------------------------------
int __thiscall sub_10042AFB(int this, int a2, unsigned int a3, int a4)
{
  int v4; // eax@1
  signed int v5; // edx@1

  v5 = 63;
  v4 = this + 8;
  do
  {
    *(double *)(v4 - 8) = 0.0;
    *(_DWORD *)(v4 + 8) = 0;
    *(double *)v4 = 0.0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    v4 += 32;
    --v5;
  }
  while ( v5 >= 0 );
  *(_DWORD *)(this + 2048) = a4;
  *(_DWORD *)(this + 2076) = a2;
  *(_DWORD *)(this + 2068) = 0;
  *(_DWORD *)(this + 2072) = 0;
  *(_DWORD *)(this + 2080) = 0;
  *(_DWORD *)(this + 2084) = 0;
  *(_DWORD *)(this + 2088) = 0;
  *(_DWORD *)(this + 2092) = 0;
  *(_DWORD *)(this + 2096) = 0;
  *(_BYTE *)(this + 2100) = 1;
  *(_DWORD *)(this + 2064) = a3;
  *(double *)(this + 2056) = (double)a3;
  return this;
}

//----- (10042B85) --------------------------------------------------------
int __thiscall sub_10042B85(int this, double a2, int a3)
{
  int result; // eax@1
  double v4; // st7@1

  v4 = *(double *)this;
  result = a3;
  ++*(_DWORD *)(this + 16);
  *(_DWORD *)(this + 24) = a3;
  *(double *)this = v4 + a2;
  *(double *)(this + 8) = a2 * a2 + *(double *)(this + 8);
  return result;
}

//----- (10042BA8) --------------------------------------------------------
double __stdcall sub_10042BA8(unsigned int a1, unsigned int a2, int a3, int a4)
{
  return (double)a2 * 10.0 / (double)a1;
}

//----- (10042BE3) --------------------------------------------------------
double __thiscall sub_10042BE3(void *this, int a2, int a3)
{
  int v3; // edi@1
  long double v4; // st7@1
  void *v5; // edi@1
  int v6; // esi@1
  double v7; // ST28_8@1
  double v8; // ST28_8@2
  double v9; // ST20_8@2
  double v10; // st7@2
  double v12; // [sp+Ch] [bp-20h]@1
  double v13; // [sp+14h] [bp-18h]@1

  v5 = this;
  v6 = sub_10042D5B(this, a2);
  v3 = sub_10042D5B(v5, a3);
  v7 = sub_10042DCF(v6);
  v13 = sub_10042DCF(v3) - v7;
  v12 = v13 / v7 / ((double)(a3 - a2) / (double)a2) - 0.15;
  v4 = 0.0;
  if ( fabs(v13) > 0.0 )
  {
    v8 = (double)*(signed int *)(v3 + 16);
    v9 = sub_1004307E(v3) / v8;
    v10 = sub_1004307E(v3) / v8 + v9;
    sub_100319B0();
    v4 = fabs(v10 / v13);
  }
  sub_1004A7AC();
  return -v4 * v12;
}
// 100319B0: using guessed type double sub_100319B0(void);
// 1004A7AC: using guessed type double sub_1004A7AC(void);

//----- (10042C9B) --------------------------------------------------------
double __thiscall sub_10042C9B(int this)
{
  int v2; // esi@1
  double v3; // st7@1
  double v4; // ST04_8@1
  double v5; // st7@1

  v2 = this;
  sub_1004307E(this);
  sub_100319B0();
  v4 = v3;
  v5 = (double)*(signed int *)(v2 + 16);
  sub_100319B0();
  return v4 / v5 / sub_10042DCF(v2);
}
// 100319B0: using guessed type double sub_100319B0(void);

//----- (10042CD2) --------------------------------------------------------
int __thiscall sub_10042CD2(int this, int a2)
{
  int result; // eax@1
  int v3; // ecx@1
  int v4; // esi@1
  int v5; // eax@2

  result = a2;
  v4 = this;
  v3 = *(_DWORD *)(this + 2068);
  if ( a2 != v3 )
  {
    *(_DWORD *)(v4 + 2072) = v3;
    *(_DWORD *)(v4 + 2068) = a2;
    v5 = sub_10042D5B((void *)v4, a2);
    *(double *)v5 = 0.0;
    *(_DWORD *)(v5 + 16) = 0;
    *(double *)(v5 + 8) = 0.0;
    *(_DWORD *)(v5 + 20) = 0;
    *(_DWORD *)(v5 + 24) = 0;
    result = sub_10042D17(v4);
  }
  return result;
}

//----- (10042D17) --------------------------------------------------------
__int64 __fastcall sub_10042D17(int a1)
{
  __int64 result; // qax@1
  signed int v2; // esi@1

  HIDWORD(result) = a1 + 20;
  v2 = 64;
  do
  {
    LODWORD(result) = *HIDWORD(result);
    if ( *HIDWORD(result) != *(_DWORD *)(a1 + 2068) )
    {
      if ( (_DWORD)result != *(_DWORD *)(a1 + 2072) )
      {
        LODWORD(result) = *(_DWORD *)(a1 + 2084) - *(_DWORD *)(HIDWORD(result) + 4);
        if ( (_DWORD)result > 0x32u )
        {
          *(_DWORD *)(HIDWORD(result) - 4) = 0;
          *(double *)(HIDWORD(result) - 20) = 0.0;
          *HIDWORD(result) = 0;
          *(double *)(HIDWORD(result) - 12) = 0.0;
          *(_DWORD *)(HIDWORD(result) + 4) = 0;
        }
      }
    }
    result += 137438953472i64;
    --v2;
  }
  while ( v2 );
  return result;
}

//----- (10042D5B) --------------------------------------------------------
int __thiscall sub_10042D5B(void *this, int a2)
{
  int result; // eax@1

  result = (int)((char *)this + 32 * (a2 & 0x3F));
  if ( *(_DWORD *)(result + 20) != a2 )
  {
    *(_DWORD *)(result + 16) = 0;
    *(_DWORD *)(result + 24) = 0;
    *(double *)result = 0.0;
    *(double *)(result + 8) = 0.0;
    *(_DWORD *)(result + 20) = a2;
  }
  return result;
}

//----- (10042D86) --------------------------------------------------------
bool __thiscall sub_10042D86(int this)
{
  bool result; // eax@1
  char v2; // dl@1

  v2 = *(_BYTE *)(this + 2100);
  result = v2 != 0;
  *(_BYTE *)(this + 2100) = v2 == 0;
  return result;
}

//----- (10042D9F) --------------------------------------------------------
char __stdcall sub_10042D9F(int a1)
{
  return *(_DWORD *)(a1 + 16) > 5u || *(_DWORD *)(a1 + 16) >= 3u && fabs(sub_10042C9B(a1)) <= 0.004;
}

//----- (10042DCF) --------------------------------------------------------
double __fastcall sub_10042DCF(int a1)
{
  double result; // st7@2
  signed int v2; // [sp+4h] [bp-4h]@1

  v2 = *(_DWORD *)(a1 + 16);
  if ( v2 )
    result = *(double *)a1 / (double)v2;
  else
    result = 0.0;
  return result;
}

//----- (10042DEF) --------------------------------------------------------
int __thiscall sub_10042DEF(int this, unsigned int a2)
{
  int v2; // eax@1
  unsigned int v3; // ecx@1
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // esi@1
  int v10; // [sp+Ch] [bp-4h]@1

  v7 = this;
  v10 = this;
  v8 = *(_DWORD *)(this + 2048);
  v4 = *(_DWORD *)(v8 + 184) + sub_10035370(*(_DWORD *)(this + 2048));
  v2 = sub_100336B7(v8);
  v5 = *(_DWORD *)(v7 + 2068);
  v3 = *(_DWORD *)(v10 + 2064);
  v6 = a2;
  if ( v3 + v5 < a2 )
    v6 = v3 + v5;
  if ( v5 > v3 )
  {
    if ( v5 - v3 > v6 )
      v6 = v5 - v3;
  }
  if ( v6 == v5 )
  {
    if ( v6 <= (unsigned int)v4 )
      ++v6;
    else
      --v6;
  }
  if ( v4 > (unsigned int)v6 )
    v6 = v4;
  if ( v2 < (unsigned int)v6 )
    v6 = v2;
  if ( v6 != v5 && sub_10042AAD(v6 - v5) == -1 )
  {
    while ( 1 )
    {
      --v5;
      if ( v5 != v6 )
      {
        if ( sub_10042AAD(v6 - v5) != -1 )
          break;
      }
      if ( *(_DWORD *)(sub_10042D5B((void *)v10, v5) + 16) > 0
        && sub_10042BE3((void *)v10, *(_DWORD *)(v10 + 2068), v5) * -1.0 <= 0.0 )
        return v5 + 1;
    }
  }
  return v6;
}

//----- (10042EBF) --------------------------------------------------------
int __thiscall sub_10042EBF(int this, int a2, unsigned int a3, int a4, int a5)
{
  int v5; // ebx@1
  int result; // eax@2
  int v7; // edx@3
  unsigned int v8; // ecx@3
  int v9; // edi@3
  unsigned int v10; // esi@8
  int v11; // esi@12
  int v12; // edi@12
  int v13; // edi@14
  unsigned int v14; // eax@14
  int v15; // esi@14
  int v16; // esi@16
  unsigned int v17; // eax@19
  double v18; // st7@19
  int v19; // esi@19
  double v20; // st7@20
  double v21; // [sp+18h] [bp-8h]@14
  double v22; // [sp+18h] [bp-8h]@19
  int v23; // [sp+34h] [bp+14h]@16

  v5 = this;
  if ( !a2 )
    return 0;
  ++*(_DWORD *)(this + 2084);
  sub_10042CD2(this, a2);
  v9 = *(_DWORD *)(v5 + 2088);
  v8 = a3;
  v7 = a4;
  if ( v9 )
  {
    v8 = *(_DWORD *)(v5 + 2092) + a3;
    v7 = *(_DWORD *)(v5 + 2096) + a4;
  }
  if ( v8 < a2 )
  {
    if ( v8 < a5 )
    {
      v7 += a2 - v8;
      v8 = a2;
    }
  }
  v10 = *(_DWORD *)(v5 + 2080);
  if ( v10 < 1 || v8 >= 1 || (unsigned int)v7 >= 1 || a5 )
  {
    v14 = v9 + 1;
    v15 = v10 + 1;
    *(_DWORD *)(v5 + 2092) = 0;
    *(_DWORD *)(v5 + 2096) = 0;
    *(_DWORD *)(v5 + 2088) = 0;
    v13 = *(_DWORD *)(v5 + 2068);
    *(_DWORD *)(v5 + 2080) = v15;
    v21 = sub_10042BA8(v14, v8, v7, a5);
    if ( (unsigned int)v15 <= 1 )
    {
      *(_DWORD *)(v5 + 2072) = v13;
      return v13;
    }
    v16 = sub_10042D5B((void *)v5, v13);
    v23 = sub_10042D5B((void *)v5, *(_DWORD *)(v5 + 2072));
    sub_10042B85(v16, v21, *(_DWORD *)(v5 + 2084));
    if ( *(_DWORD *)(v23 + 16) && v16 != v23 )
    {
      if ( !sub_10042D9F(v16) )
        return v13;
      v18 = sub_10042BE3((void *)v5, *(_DWORD *)(v5 + 2072), *(_DWORD *)(v5 + 2068)) * *(double *)(v5 + 2056);
      v19 = *(_DWORD *)(v5 + 2068);
      v22 = (double)*(unsigned int *)(v5 + 2068);
      sub_100446D6(v18);
      if ( v17 == v19 )
      {
        v20 = sub_10042AC5(v18);
        sub_100446D6(v20 + v22);
      }
    }
    else
    {
      if ( !sub_10042D9F(v16) )
        return v13;
      v17 = *(_DWORD *)(v5 + 2068) + sub_10042D86(v5);
    }
    return sub_10042DEF(v5, v17);
  }
  v11 = *(_DWORD *)(v5 + 2048);
  *(_DWORD *)(v5 + 2092) = v8;
  v12 = v9 + 1;
  *(_DWORD *)(v5 + 2088) = v12;
  *(_DWORD *)(v5 + 2096) = v7;
  result = *(_DWORD *)(v11 + 184) + sub_10035370(v11);
  if ( (unsigned int)v12 < 3 )
    result = *(_DWORD *)(v5 + 2068);
  return result;
}
// 100446D6: using guessed type double __usercall sub_100446D6<st0>(double<st0>);

//----- (1004307E) --------------------------------------------------------
double __fastcall sub_1004307E(int a1)
{
  signed int v1; // eax@1
  double v2; // st6@1
  double result; // st7@1

  v1 = *(_DWORD *)(a1 + 16);
  result = 0.0;
  v2 = 0.0;
  if ( v1 >= 2 )
    v2 = (*(double *)(a1 + 8) - *(double *)a1 * *(double *)a1 / (double)v1) / (double)(v1 - 1);
  if ( fabs(v2) > 0.0001 )
    result = v2;
  return result;
}

//----- (100430CA) --------------------------------------------------------
#error "10043318: call analysis failed (funcsize=178)"

//----- (10043320) --------------------------------------------------------
#error "10043363: call analysis failed (funcsize=21)"

//----- (10043369) --------------------------------------------------------
char *__thiscall sub_10043369(int this, int a2, int a3, char a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // eax@4
  void *v8; // ebx@7
  signed __int64 v10; // qax@8
  char *result; // eax@11
  char v12; // [sp+Ch] [bp-4h]@7
  unsigned int v13; // [sp+20h] [bp+10h]@9

  v6 = this;
  v4 = *(_DWORD *)(this + 164);
  v5 = *(_DWORD *)(this + 144);
  if ( v4 )
    *(_DWORD *)(this + 164) = v4 - 1;
  else
    --v5;
  ++*(_DWORD *)(a2 + 28);
  ++*(_DWORD *)(this + 160);
  v7 = *(_DWORD *)(a2 + 48) + 52 * a3;
  *(_DWORD *)v7 = 4;
  *(_DWORD *)(v7 + 36) = v5;
  *(_DWORD *)(this + 176) += v5;
  if ( a4 )
    sub_10044106(this, a2, a3);
  if ( v5 == 1 )
  {
    v8 = &v12;
  }
  else
  {
    _ECX = 0;
    v10 = 4i64 * (unsigned int)v5;
    __asm { seto    cl }
    v8 = (void *)sub_10021CF0(SHIDWORD(v10), v10 | -_ECX, 4, v5, v10 | -_ECX);
  }
  v13 = 0;
  if ( v5 )
  {
    do
      *((_DWORD *)v8 + v13++) = (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v6 + 24))(v6, a2, a3);
    while ( v13 < v5 );
  }
  sub_100434C1(v8, v5);
  result = &v12;
  if ( v8 != &v12 )
    result = (char *)sub_1002401B(v8);
  return result;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 100434C1: using guessed type _DWORD __stdcall sub_100434C1(_DWORD, _DWORD);

//----- (10043421) --------------------------------------------------------
#error "10043471: call analysis failed (funcsize=28)"

//----- (10043479) --------------------------------------------------------
int __thiscall sub_10043479(int this, int a2)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 4);
  if ( result )
  {
    *(_DWORD *)(a2 + 56) = *(_DWORD *)(result + 56);
    *(_DWORD *)(a2 + 52) = *(_DWORD *)(this + 4);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 4) + 56) + 52) = a2;
    result = *(_DWORD *)(this + 4);
    *(_DWORD *)(result + 56) = a2;
  }
  else
  {
    *(_DWORD *)(a2 + 56) = a2;
    *(_DWORD *)(a2 + 52) = a2;
  }
  *(_DWORD *)(this + 4) = a2;
  ++*(_DWORD *)this;
  return result;
}

//----- (100434B2) --------------------------------------------------------
int __thiscall sub_100434B2(int this, int a2)
{
  return sub_10043479(this + 196, a2);
}

//----- (100434C1) --------------------------------------------------------
#error "1004354D: call analysis failed (funcsize=51)"

//----- (10043555) --------------------------------------------------------
int __thiscall sub_10043555(void *this, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // ecx@1
  int v5; // edi@1
  unsigned __int64 v6; // qax@2
  int v7; // ebx@2
  unsigned int v8; // esi@2
  int v9; // esi@5

  v5 = (int)this;
  v4 = 0;
  v2 = *(_DWORD *)(v5 + 140);
  v3 = *(_DWORD *)(v5 + 156);
  if ( v2 > v3 )
  {
    v8 = *(_DWORD *)(v5 + 144);
    v7 = *(_DWORD *)(v5 + 164);
    v6 = v2 - v3;
    if ( v7 * v8 < (_DWORD)v6 )
    {
      LODWORD(v6) = v6 - v7 * v8;
      v4 = v7 + v6 / (v8 - 1);
    }
    else
    {
      v4 = (_DWORD)v6 / v8;
    }
  }
  v9 = v4 + *(_DWORD *)(v5 + 160);
  if ( v9 >= (unsigned int)sub_100336B7(v5) )
    v9 = sub_100336B7(v5);
  if ( v9 >= (unsigned int)a2 )
    v9 = a2;
  return v9;
}

//----- (100435C5) --------------------------------------------------------
int __thiscall sub_100435C5(void *this, int a2)
{
  void *v2; // edi@1
  int result; // eax@2
  int (__stdcall **v4)(char); // [sp+8h] [bp-Ch]@5

  v2 = this;
  if ( !a2 )
  {
    a2 = (int)"pContext";
    sub_10023687((int)&v4, &a2);
    v4 = &off_100542CC;
    sub_1002D02B((int)&v4, (int)&unk_10061764);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10043618);
  }
  result = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)a2 + 8))(a2);
  if ( !result )
    result = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v2 + 28))(v2);
  return result;
}
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);

//----- (10043618) --------------------------------------------------------
int __thiscall sub_10043618(void *this)
{
  unsigned int v1; // ecx@1
  void *v2; // ebx@1
  int v3; // edx@2
  unsigned int v4; // esi@3
  int v5; // ecx@4
  int v6; // ebx@4
  int v7; // edi@5
  int v8; // edi@6
  int v9; // esi@9
  int v10; // esi@12
  void *v12; // [sp+4h] [bp-18h]@1
  int v13; // [sp+Ch] [bp-10h]@2
  unsigned int v14; // [sp+10h] [bp-Ch]@1
  unsigned int v15; // [sp+14h] [bp-8h]@3
  int v16; // [sp+18h] [bp-4h]@4

  v2 = this;
  v1 = 0;
  v12 = v2;
  v14 = 0;
  if ( *((_DWORD *)v2 + 48) )
  {
    v3 = 0;
    v13 = 0;
    do
    {
      v4 = 0;
      v15 = 0;
      if ( *(_DWORD *)(v3 + *((_DWORD *)v2 + 4) + 4) )
      {
        v5 = 0;
        v16 = 0;
        v6 = v3 + *((_DWORD *)v2 + 4);
        do
        {
          v7 = *(_DWORD *)(*(_DWORD *)(v6 + 48) + v5 + 16);
          if ( v7 )
            v8 = *(_DWORD *)(v7 + 56);
          else
            v8 = 0;
          if ( v8 )
          {
            do
            {
              v9 = v8;
              if ( v8 == *(_DWORD *)(*(_DWORD *)(v6 + 48) + v5 + 16) )
                v8 = 0;
              else
                v8 = *(_DWORD *)(v8 + 56);
              v10 = *(_DWORD *)(v9 + 28);
              sub_1004A8E1(v10);
              (*(void (__thiscall **)(int))(*(_DWORD *)v10 + 36))(v10);
              v5 = v16;
            }
            while ( v8 );
            v4 = v15;
          }
          ++v4;
          v5 += 52;
          v15 = v4;
          v16 = v5;
        }
        while ( v4 < *(_DWORD *)(v6 + 4) );
        v2 = v12;
        v1 = v14;
        v3 = v13;
      }
      ++v1;
      v3 += 52;
      v14 = v1;
      v13 = v3;
    }
    while ( v1 < *((_DWORD *)v2 + 48) );
  }
  return sub_1002404A(*((LPVOID *)v2 + 14));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (100436D4) --------------------------------------------------------
int __userpurge sub_100436D4<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@1

  sub_1002D0B8();
  v5 = v7;
  v4 = sub_10027EB3(v8, v7, a1, v7, 60);
  *(_DWORD *)(a2 - 16) = v4;
  v6 = 0;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v4 )
    v6 = sub_100427ED(v4, v5, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12));
  *(_DWORD *)(a2 - 4) = -1;
  sub_10042938(v6);
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1004371B) --------------------------------------------------------
#error "100437CF: call analysis failed (funcsize=61)"

//----- (100437D7) --------------------------------------------------------
int __userpurge sub_100437D7<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@1

  sub_1002D0B8();
  v6 = v7;
  v5 = sub_10027EB3(v8, v7, a1, a3, 88);
  *(_DWORD *)(a2 - 16) = v5;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v5 )
    sub_1004A913(v5, v6, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12));
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1004380F) --------------------------------------------------------
int __thiscall sub_1004380F(int this, int a2)
{
  int result; // eax@1
  int v3; // edi@1
  int v10; // ecx@2

  v3 = this;
  result = 52 * *(_DWORD *)(a2 + 40)
         + 24
         + *(_DWORD *)(52 * (**(int (__thiscall ***)(_DWORD))a2)(a2) + *(_DWORD *)(this + 16) + 48);
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  if ( _ZF )
  {
    v10 = *(_DWORD *)(v3 + 12);
    result = *(_DWORD *)(v3 + 132) == *(_DWORD *)(v3 + 128);
    if ( *(_DWORD *)(v10 + 16) > (unsigned int)result )
      result = SetEvent(*(HANDLE *)(v10 + 80));
  }
  return result;
}

//----- (10043867) --------------------------------------------------------
int __thiscall sub_10043867(int this, int a2, int a3, char a4)
{
  int result; // eax@1
  int v5; // ecx@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // esi@1
  char v9; // zf@3
  int v10; // [sp+14h] [bp+8h]@1

  v6 = 52 * a2;
  v8 = this;
  result = *(_DWORD *)(this + 16);
  v5 = 52 * a3;
  v7 = 52 * a3 + *(_DWORD *)(result + 52 * a2 + 48);
  v10 = 52 * a3;
  if ( a4 )
  {
    --*(_DWORD *)(v7 + 44);
    --*(_DWORD *)(v8 + 180);
  }
  v9 = *(_DWORD *)(v7 + 40)-- == 1;
  if ( v9 )
  {
    result = v6 + *(_DWORD *)(v8 + 16);
    --*(_DWORD *)(v8 + 172);
    --*(_DWORD *)(result + 36);
    if ( *(_BYTE *)(v7 + 50) )
    {
      result = sub_10044106(v8, result, a3);
      v5 = v10;
      *(_BYTE *)(v7 + 50) = 0;
    }
    if ( a4 )
    {
      result = *(_DWORD *)(*(_DWORD *)(v8 + 16) + v6 + 48);
      if ( !*(_DWORD *)(result + v5 + 36) )
        --*(_DWORD *)(v8 + 184);
    }
  }
  return result;
}

//----- (100438E2) --------------------------------------------------------
int __thiscall sub_100438E2(void *this)
{
  void *v1; // esi@1
  int result; // eax@2

  v1 = this;
  if ( this )
  {
    sub_10043320();
    result = sub_1002404A(v1);
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10043320: using guessed type int sub_10043320(void);

//----- (100438F7) --------------------------------------------------------
int __thiscall sub_100438F7(int this, int a2)
{
  int v2; // edx@1
  int v3; // ebx@1
  int v4; // esi@1
  int v5; // esi@2
  int v7; // [sp+Ch] [bp-4h]@1

  v4 = this;
  v7 = this;
  v2 = *(_DWORD *)(this + 16) + 52 * (**(int (__thiscall ***)(_DWORD))a2)(a2);
  v3 = *(_DWORD *)(v2 + 48) + 52 * *(_DWORD *)(a2 + 40);
  if ( !(*(_DWORD *)(v3 + 36) + *(_DWORD *)(v3 + 44)) )
  {
    --*(_DWORD *)(v2 + 28);
    *(_DWORD *)v3 = 1;
    --*(_DWORD *)(v4 + 160);
    v5 = *(_DWORD *)(40 * (**(int (__thiscall ***)(_DWORD))a2)(a2) + *(_DWORD *)(*(_DWORD *)(v7 + 12) + 72) + 32)
       + 36 * *(_DWORD *)(a2 + 40);
    --*(_DWORD *)(v5 + 16);
    v4 = v7;
  }
  sub_100244EB((LPCRITICAL_SECTION)(v4 + 32));
  sub_10043EEC(v3 + 12, a2);
  sub_10024670((LPCRITICAL_SECTION)(v4 + 32));
  *(_DWORD *)a2 = off_1005A88C;
  return sub_1002404A((LPVOID)a2);
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005A88C: using guessed type int (*off_1005A88C[2])();

//----- (10043983) --------------------------------------------------------
#error "100439E7: call analysis failed (funcsize=35)"

//----- (100439EF) --------------------------------------------------------
int __thiscall sub_100439EF(void *this)
{
  void *v2; // esi@1

  v2 = this;
  sub_10043618(this);
  return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v2 + 36))(v2);
}

//----- (100439FF) --------------------------------------------------------
LPVOID __thiscall sub_100439FF(int this)
{
  LPVOID v1; // eax@1
  LPVOID v2; // esi@1

  v2 = 0;
  v1 = TlsGetValue(*(_DWORD *)(*(_DWORD *)(this + 12) + 112));
  if ( v1 )
  {
    if ( !((_BYTE)v1 & 3) )
      v2 = v1;
  }
  return v2;
}

//----- (10043A1C) --------------------------------------------------------
int __userpurge sub_10043A1C<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int ebp0; // ebp@0
  int v4; // esi@1
  int v6; // esi@3

  v4 = a1;
  if ( !*(_DWORD *)(a1 + 4) )
    *(_DWORD *)(a1 + 4) = sub_1004442A(a2, ebp0);
  v6 = (***(int (__stdcall ****)(_DWORD, _DWORD))(v4 + 4))(*(_DWORD *)(v4 + 148), *(_DWORD *)(v4 + 152));
  sub_1004ACC5(v6, a3);
  return v6;
}

//----- (10043A5C) --------------------------------------------------------
int __userpurge sub_10043A5C<eax>(int a1<ebp>, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@2
  int v7; // esi@2

  sub_1002D0B8();
  v4 = v3;
  v5 = *(_DWORD *)(a1 + 8);
  if ( *(_DWORD *)(v5 + 20) != v3 )
  {
    v6 = sub_10027EB3(v2, v3, v3, v5, 60);
    *(_DWORD *)(a1 + 8) = v6;
    v7 = 0;
    *(_DWORD *)(a1 - 4) = 0;
    if ( v6 )
      v7 = sub_10042854(v6, v4, v5);
    *(_DWORD *)(a1 - 4) = -1;
    sub_10042938(v7);
  }
  return sub_1002D086(0);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10043AAA) --------------------------------------------------------
int __thiscall sub_10043AAA(int this, unsigned int a2, int a3, char a4)
{
  __int64 v4; // qcx@1
  int ebp0; // ebp@0
  int v6; // esi@1
  int v7; // eax@2
  unsigned int v8; // edx@2
  bool v9; // ecx@2
  int v10; // edi@4
  unsigned int v11; // eax@14
  int v12; // edx@15
  signed __int64 v14; // qax@18
  unsigned int v15; // eax@20
  int v16; // edx@20
  char v17; // cl@20
  unsigned int v18; // edi@20
  int v19; // edx@26
  int v20; // edi@30
  char v21; // al@34
  char v22; // dl@35
  int v23; // eax@41
  int v24; // edi@41
  int v25; // eax@53
  int v27; // [sp+Ch] [bp-40h]@30
  int i; // [sp+10h] [bp-3Ch]@20
  int v29; // [sp+14h] [bp-38h]@10
  unsigned int v30; // [sp+18h] [bp-34h]@24
  int v31; // [sp+1Ch] [bp-30h]@20
  bool v32; // [sp+20h] [bp-2Ch]@4
  int v33; // [sp+24h] [bp-28h]@18
  int v34; // [sp+28h] [bp-24h]@13
  int j; // [sp+2Ch] [bp-20h]@26
  int v36; // [sp+30h] [bp-1Ch]@27
  int v37; // [sp+34h] [bp-18h]@11
  unsigned int v38; // [sp+38h] [bp-14h]@1
  int v39; // [sp+3Ch] [bp-10h]@10
  int v40; // [sp+40h] [bp-Ch]@10
  unsigned int v41; // [sp+44h] [bp-8h]@21
  char v42; // [sp+49h] [bp-3h]@5
  char v43; // [sp+4Ah] [bp-2h]@8
  char v44; // [sp+4Bh] [bp-1h]@20

  HIDWORD(v4) = 0;
  v6 = this;
  v38 = 0;
  if ( a4 )
  {
    v7 = sub_10035370(this);
    v8 = a2;
    v9 = *(_DWORD *)(v6 + 184) + v7 < a2 + *(_DWORD *)(v6 + 160);
  }
  else
  {
    v8 = a2;
    v9 = 0;
  }
  v10 = v9 < v8 ? v8 - v9 : 0;
  v32 = v9;
  if ( !v9 || (v42 = 1, v8) )
    v42 = 0;
  if ( !a4 || (v43 = 1, v9) )
    v43 = 0;
  v29 = -1;
  v39 = -1;
  v40 = 0;
  if ( a4 )
    v37 = sub_10034A3C(*(_DWORD *)(v6 + 12), v6, 0);
  else
    v37 = -1;
  v34 = 0;
  if ( v10
    && ((v11 = *(_DWORD *)(v6 + 164), v10 > v11) ? (v12 = *(_DWORD *)(v6 + 164) * *(_DWORD *)(v6 + 144)
                                                        + (*(_DWORD *)(v6 + 144) - 1) * (v10 - v11)) : (v12 = v10 * *(_DWORD *)(v6 + 144)),
        v34 = v12,
        v12) )
  {
    _ECX = 0;
    v14 = 4i64 * (unsigned int)v12;
    __asm { seto    cl }
    v4 = (_DWORD)v14 | (unsigned int)-_ECX;
    v33 = sub_10021CF0(SHIDWORD(v14), v4, SHIDWORD(v4), v10, v4);
  }
  else
  {
    v33 = 0;
  }
  v15 = a2;
  v17 = a4 == 0;
  v31 = 0;
  v44 = a4 == 0;
  v18 = 0;
  v16 = 0;
  for ( i = 0; ; i = v16 )
  {
    v41 = v18;
    if ( v38 >= v15 )
    {
      if ( v17 )
        break;
    }
    if ( v18 >= *(_DWORD *)(v6 + 192) )
      break;
    LODWORD(v4) = v16 + *(_DWORD *)(v6 + 16);
    v30 = v4;
    if ( *(_DWORD *)(v4 + 24) > HIDWORD(v4) || *(_DWORD *)(v4 + 28) > HIDWORD(v4) )
    {
      v19 = HIDWORD(v4);
      for ( j = HIDWORD(v4); ; j += 52 )
      {
        v36 = v19;
        if ( v38 >= v15 && v44 || (unsigned int)v19 >= *(_DWORD *)(v4 + 4) )
        {
          v16 = i;
          *(_DWORD *)(v4 + 24) = HIDWORD(v4);
          goto LABEL_64;
        }
        v20 = j + *(_DWORD *)(v4 + 48);
        v27 = v20;
        if ( *(_DWORD *)v20 == 3 )
          break;
        if ( *(_DWORD *)v20 != 4 )
          goto LABEL_49;
        if ( v43 )
        {
          v25 = *(_DWORD *)(v20 + 36) + *(_DWORD *)(v20 + 44);
          if ( v25 < (unsigned int)v29 || v25 == v29 && v41 == v37 )
          {
            v29 = *(_DWORD *)(v20 + 36) + *(_DWORD *)(v20 + 44);
            v40 = v4;
            v39 = v19;
          }
          goto LABEL_48;
        }
        if ( !v42 || *(_DWORD *)(v20 + 40) > HIDWORD(v4) )
          goto LABEL_49;
        v18 = v41;
        if ( !v40 || v41 == v37 )
        {
          v15 = a2;
          v40 = v4;
          v39 = v19;
          if ( v41 == v37 )
            v44 = 1;
        }
LABEL_50:
        ++v19;
      }
      if ( v44 || v38 != v15 - 1 && v37 != v41 )
      {
        v21 = BYTE4(v4);
      }
      else
      {
        v21 = 1;
        if ( v32 )
        {
          v22 = BYTE4(v4);
LABEL_38:
          *(_DWORD *)v20 = 4;
          ++*(_DWORD *)(v4 + 28);
          ++*(_DWORD *)(v6 + 160);
          if ( v21 )
          {
            v40 = v4;
            v39 = v36;
            v44 = 1;
          }
          if ( v22 )
          {
            v23 = *(_DWORD *)(v6 + 164);
            v24 = *(_DWORD *)(v6 + 144);
            if ( v23 )
              *(_DWORD *)(v6 + 164) = v23 - 1;
            else
              --v24;
            *(_DWORD *)(v27 + 36) += v24;
            *(_DWORD *)(v6 + 176) += v24;
            if ( v24 )
            {
              do
              {
                *(_DWORD *)(v33 + 4 * v31++) = (*(int (__thiscall **)(int, unsigned int, int))(*(_DWORD *)v6 + 24))(
                                                 v6,
                                                 v30,
                                                 v36);
                --v24;
              }
              while ( v24 );
              v4 = v30;
            }
          }
          ++v38;
          v19 = v36;
LABEL_48:
          v15 = a2;
LABEL_49:
          v18 = v41;
          goto LABEL_50;
        }
      }
      v22 = 1;
      goto LABEL_38;
    }
LABEL_64:
    v17 = v44;
    ++v18;
    v16 += 52;
  }
  if ( v34 )
  {
    sub_100434C1(v33, v34);
    sub_1002401B((LPVOID)v33);
  }
  if ( a4 )
  {
    if ( !v43 )
    {
      if ( v42 )
      {
        sub_10043F22(ebp0, v40, v39);
        *(_DWORD *)(52 * v39 + *(_DWORD *)(v40 + 48)) = 4;
        ++*(_DWORD *)(v40 + 28);
        ++*(_DWORD *)(v6 + 160);
      }
    }
    HIDWORD(v4) = sub_100436D4(v40, ebp0, v40, v39);
  }
  return HIDWORD(v4);
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);
// 100434C1: using guessed type _DWORD __stdcall sub_100434C1(_DWORD, _DWORD);

//----- (10043D88) --------------------------------------------------------
int __thiscall sub_10043D88(int this, int a2)
{
  int result; // eax@1
  int v3; // edi@1
  int v11; // ecx@2

  v3 = this;
  _ECX = *(_DWORD *)(52 * (**(int (__thiscall ***)(_DWORD))a2)(a2) + *(_DWORD *)(this + 16) + 48)
       + 52 * *(_DWORD *)(a2 + 40)
       + 24;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  result = _EAX + 1;
  if ( result == 1 )
  {
    v11 = *(_DWORD *)(v3 + 12);
    result = *(_DWORD *)(v3 + 132) == *(_DWORD *)(v3 + 128);
    if ( *(_DWORD *)(v11 + 16) > (unsigned int)result )
      result = SetEvent(*(HANDLE *)(v11 + 80));
  }
  return result;
}

//----- (10043DE4) --------------------------------------------------------
int __thiscall sub_10043DE4(int this, int a2, int a3, char a4)
{
  int result; // eax@1
  int v5; // edx@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // ecx@1
  int v10; // [sp+14h] [bp+8h]@1

  v5 = 52 * a3;
  v6 = 52 * a2;
  v8 = this;
  v10 = 52 * a3;
  v7 = 52 * a3 + *(_DWORD *)(*(_DWORD *)(this + 16) + v6 + 48);
  v9 = *(_DWORD *)(v7 + 40);
  result = v9 + 1;
  *(_DWORD *)(v7 + 40) = v9 + 1;
  if ( v9 )
    goto LABEL_7;
  result = v6 + *(_DWORD *)(v8 + 16);
  ++*(_DWORD *)(result + 36);
  ++*(_DWORD *)(v8 + 172);
  if ( *(_BYTE *)(v7 + 49) )
  {
    *(_BYTE *)(v7 + 50) = 1;
    result = sub_10044106(v8, result, a3);
    v5 = v10;
  }
  if ( a4 )
  {
    result = *(_DWORD *)(*(_DWORD *)(v8 + 16) + v6 + 48);
    if ( !*(_DWORD *)(result + v5 + 36) )
      ++*(_DWORD *)(v8 + 184);
LABEL_7:
    if ( a4 )
    {
      ++*(_DWORD *)(v8 + 180);
      ++*(_DWORD *)(v7 + 44);
    }
  }
  return result;
}

//----- (10043E66) --------------------------------------------------------
int __usercall sub_10043E66<eax>(int a1<ecx>, int a2<ebp>)
{
  LPVOID v2; // eax@1
  int v3; // esi@1
  int v4; // eax@2
  int v5; // eax@4
  int v6; // eax@7
  int v7; // edi@7
  int v8; // esi@7
  int v9; // esi@7

  v2 = TlsGetValue(*(_DWORD *)(*(_DWORD *)(a1 + 12) + 112));
  v3 = (int)v2;
  if ( !v2 )
    return 0;
  v4 = (_BYTE)v2 & 3;
  if ( !v4 )
  {
LABEL_6:
    sub_10042938(v3);
    goto LABEL_12;
  }
  if ( v4 == 1 )
  {
    v3 = *(_DWORD *)((v3 & 0xFFFFFFFE) + 0x10) + 8;
    v5 = *(_DWORD *)(v3 + 28);
    if ( v5 && *(_BYTE *)(v5 + 68) )
      return 0;
    goto LABEL_6;
  }
  v8 = v3 & 0xFFFFFFFD;
  v7 = v8 + 4;
  (*(void (__thiscall **)(int))(*(_DWORD *)(v8 + 4) + 16))(v8 + 4);
  v9 = *(_DWORD *)(v8 + 32);
  v6 = *(_DWORD *)(v9 + 44);
  v3 = v9 + 16;
  if ( v6 && *(_BYTE *)(v6 + 68) )
    v3 = 0;
  else
    sub_10042938(v3);
  (*(void (__thiscall **)(int))(*(_DWORD *)v7 + 20))(v7);
LABEL_12:
  if ( v3 )
    return sub_10043A5C(a2, v3);
  return 0;
}

//----- (10043EEC) --------------------------------------------------------
int __thiscall sub_10043EEC(int this, int a2)
{
  int result; // eax@1

  --*(_DWORD *)this;
  *(_DWORD *)(*(_DWORD *)(a2 + 56) + 52) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(*(_DWORD *)(a2 + 52) + 56) = *(_DWORD *)(a2 + 56);
  result = *(_DWORD *)(this + 4);
  if ( a2 == result )
  {
    if ( result == *(_DWORD *)(result + 56) )
      result = 0;
    else
      result = *(_DWORD *)(result + 52);
    *(_DWORD *)(this + 4) = result;
  }
  return result;
}

//----- (10043F22) --------------------------------------------------------
int __userpurge sub_10043F22<eax>(int a1<ebp>, int a2, int a3)
{
  int v3; // ecx@1
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // ecx@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // eax@5
  int v10; // eax@6
  int v11; // ecx@12
  int v13; // [sp-Ch] [bp-Ch]@16
  signed int v14; // [sp-4h] [bp-4h]@1

  v14 = 4;
  sub_1002D0B8();
  v4 = v6;
  v3 = *(_DWORD *)(a1 + 8);
  v7 = 52 * *(_DWORD *)(a1 + 12);
  --*(_DWORD *)(v3 + 28);
  --*(_DWORD *)(v4 + 160);
  v5 = *(_DWORD *)(v3 + 48) + v7;
  v8 = *(_DWORD *)(v5 + 36);
  *(_DWORD *)v5 = 1;
  if ( v8 == *(_DWORD *)(v4 + 144) )
    ++*(_DWORD *)(v4 + 164);
  *(_DWORD *)(v4 + 176) -= *(_DWORD *)(v5 + 36);
  *(_DWORD *)(v5 + 36) = 0;
  if ( *(_BYTE *)(v5 + 49) )
    sub_10044106(v4, v3, *(_DWORD *)(a1 + 12));
  *(_BYTE *)(v5 + 48) = 0;
  *(_DWORD *)(a1 - 16) = v4 + 32;
  sub_100244EB((LPCRITICAL_SECTION)(v4 + 32));
  v9 = *(_DWORD *)(v5 + 16);
  *(_DWORD *)(a1 - 4) = 0;
  if ( v9 )
    v10 = *(_DWORD *)(v9 + 56);
  else
    v10 = 0;
  for ( ; v10; v10 = *(_DWORD *)(a1 + 12) )
  {
    if ( v10 == *(_DWORD *)(v5 + 16) )
      *(_DWORD *)(a1 + 12) = 0;
    else
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(v10 + 56);
    v11 = *(_DWORD *)(v10 + 28);
    if ( v11 )
    {
      if ( !*(_BYTE *)(v11 + 68) )
      {
        *(_BYTE *)(v11 + 68) = 1;
        *(_DWORD *)(a1 + 8) = v11;
        (*(void (__cdecl **)(int, signed int, signed int))(**(_DWORD **)(v4 + 8) + 16))(a1 + 8, 1, v14);
      }
    }
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_10024670((LPCRITICAL_SECTION)(v4 + 32));
  return sub_1002D086(v13);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10043FF1) --------------------------------------------------------
int __thiscall sub_10043FF1(void *this, void *a2)
{
  int result; // eax@1

  result = sub_10043EEC((int)((char *)this + 196), (int)a2);
  if ( a2 )
  {
    *(_DWORD *)a2 = off_1005A88C;
    result = sub_1002404A(a2);
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005A88C: using guessed type int (*off_1005A88C[2])();

//----- (1004401A) --------------------------------------------------------
int __thiscall sub_1004401A(int this, int a2)
{
  int ebp0; // ebp@0

  return sub_100360A2(ebp0, this, a2);
}

//----- (1004402D) --------------------------------------------------------
#error "100440EA: call analysis failed (funcsize=77)"

//----- (100440F2) --------------------------------------------------------
int __thiscall sub_100440F2(int this)
{
  return sub_1003696D(*(_DWORD *)(this + 12), this);
}

//----- (100440FC) --------------------------------------------------------
int __usercall sub_100440FC<eax>(int a1<ecx>, int a2<ebp>)
{
  return sub_10036A26(a2, a1);
}

//----- (10044106) --------------------------------------------------------
int __thiscall sub_10044106(int this, int a2, int a3)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 + 48) + 52 * a3;
  if ( *(_BYTE *)(result + 49) )
  {
    --*(_DWORD *)(this + 168);
    --*(_DWORD *)(a2 + 32);
    *(_BYTE *)(result + 49) = 0;
  }
  else
  {
    ++*(_DWORD *)(this + 168);
    ++*(_DWORD *)(a2 + 32);
    *(_BYTE *)(result + 49) = 1;
  }
  return result;
}

//----- (1004413B) --------------------------------------------------------
int __stdcall sub_1004413B(int a1)
{
  int v2; // eax@2
  int (__stdcall **v3)(char); // [sp+0h] [bp-Ch]@3

  if ( !a1 )
  {
    a1 = (int)"pContext";
    sub_10023687((int)&v3, &a1);
    v3 = &off_100542CC;
    sub_1002D02B((int)&v3, (int)&unk_10061764);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10044181);
  }
  v2 = (*(int (**)(void))(*(_DWORD *)a1 + 8))();
  return sub_1004AD54(v2);
}
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);

//----- (10044181) --------------------------------------------------------
int __cdecl sub_10044181(int a1)
{
  int v1; // eax@2
  int v2; // eax@4
  HMODULE v3; // eax@4
  int v4; // eax@7
  HMODULE v5; // eax@7
  int result; // eax@8
  int v7; // eax@10
  int v8; // ST04_4@10
  int *v9; // [sp+0h] [bp-18h]@10
  int v10; // [sp+4h] [bp-14h]@10
  char v11; // [sp+8h] [bp-10h]@10
  int v12; // [sp+Ch] [bp-Ch]@10
  int v13; // [sp+10h] [bp-8h]@10
  int v14; // [sp+14h] [bp-4h]@10
  int v15; // [sp+18h] [bp+0h]@10

  dword_1006A04C = (int)LoadLibraryExW(L"combase.dll", 0, 0x800u);
  if ( dword_1006A04C )
  {
    v3 = GetModuleHandleW(L"combase.dll");
    v2 = (int)GetProcAddress(v3, "RoInitialize");
    if ( v2 )
    {
      dword_1006A044 = sub_1002C373(v2);
      v5 = GetModuleHandleW(L"combase.dll");
      v4 = (int)GetProcAddress(v5, "RoUninitialize");
      if ( v4 )
      {
        dword_1006A048 = sub_1002C373(v4);
        result = unk_1006A050;
        unk_1006A050 = 1;
        return result;
      }
    }
    v1 = GetLastError();
    if ( v1 > 0 )
      goto LABEL_9;
  }
  else
  {
    v1 = GetLastError();
    if ( v1 > 0 )
    {
LABEL_9:
      v1 = (unsigned __int16)v1 | 0x80070000;
      goto LABEL_10;
    }
  }
LABEL_10:
  sub_100249F4((int)&v11, v1);
  sub_1002D02B((int)&v11, (int)&unk_10060498);
  __asm { int     3               ; Trap to Debugger }
  v9 = &v15;
  v7 = sub_1002C373(dword_1006A044);
  return ((int (__thiscall *)(int, int, int *, int, _DWORD, int, int, int))v7)(
           v8,
           a1,
           v9,
           v10,
           *(_DWORD *)&v11,
           v12,
           v13,
           v14);
}
// 1006A044: using guessed type int dword_1006A044;
// 1006A048: using guessed type int dword_1006A048;
// 1006A04C: using guessed type int dword_1006A04C;

//----- (10044246) --------------------------------------------------------
int __cdecl sub_10044246()
{
  int v1; // eax@1
  int v2; // ST00_4@1

  v1 = sub_1002C373(dword_1006A048);
  return ((int (__thiscall *)(int))v1)(v2);
}
// 1006A048: using guessed type int dword_1006A048;

//----- (10044254) --------------------------------------------------------
int __thiscall sub_10044254(int this, int a2)
{
  signed int v2; // ebx@1
  int v3; // edi@1
  union _SLIST_HEADER *v4; // esi@1

  v3 = this;
  *(_DWORD *)this = &off_1005A988;
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 8);
  v4 = (union _SLIST_HEADER *)(this + 8);
  v2 = 3;
  do
  {
    InitializeSListHead(v4);
    ++v4;
    --v2;
  }
  while ( v2 >= 0 );
  return v3;
}
// 1005A988: using guessed type int (__stdcall *off_1005A988)(int, int);

//----- (10044287) --------------------------------------------------------
void *__thiscall sub_10044287(void *this, int a2, int a3)
{
  void *v4; // esi@1

  v4 = this;
  sub_1004B29B(this, a2, a3);
  *(_DWORD *)v4 = &off_1005A940;
  *((_DWORD *)v4 + 12) = 0;
  *((_DWORD *)v4 + 13) = 0;
  *((_DWORD *)v4 + 14) = 0;
  *((_DWORD *)v4 + 12) = 0;
  *((_WORD *)v4 + 26) = 0;
  return v4;
}
// 1005A940: using guessed type int (*off_1005A940)();

//----- (100442B8) --------------------------------------------------------
int __thiscall sub_100442B8(int this, int a2)
{
  int v3; // esi@1

  v3 = this;
  sub_10044254(this, a2);
  *(_DWORD *)v3 = &off_1005A9B4;
  *(_DWORD *)(v3 + 40) = 1;
  *(_BYTE *)(v3 + 44) = 0;
  return v3;
}
// 1005A9B4: using guessed type int (__stdcall *off_1005A9B4)(int, int);

//----- (100442DE) --------------------------------------------------------
int __usercall sub_100442DE<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int v2; // esi@1
  DWORD v3; // eax@1
  int v4; // eax@2

  sub_1002D0B8();
  v2 = v1;
  *(_DWORD *)(a1 - 16) = v1;
  *(_DWORD *)v1 = 0;
  *(_DWORD *)(v1 + 4) = 0;
  sub_1002417F((LPCRITICAL_SECTION)(v1 + 12));
  *(_DWORD *)(a1 - 4) = 0;
  v3 = TlsAlloc();
  *(_DWORD *)(v2 + 8) = v3;
  if ( v3 == -1 )
  {
    v4 = GetLastError();
    if ( v4 > 0 )
      v4 = (unsigned __int16)v4 | 0x80070000;
    sub_100249F4(a1 - 32, v4);
    sub_1002D02B(a1 - 32, (int)&unk_10060498);
  }
  return sub_1002D086(20);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10044341) --------------------------------------------------------
int __usercall sub_10044341<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // ecx@3
  signed int v6; // [sp-4h] [bp-4h]@1

  v6 = 4;
  sub_1002D0B8();
  v2 = v3;
  *(_DWORD *)(a1 - 16) = v3;
  v1 = *(_DWORD *)v3;
  *(_DWORD *)(a1 - 4) = 0;
  if ( v1 )
    (*(void (__cdecl **)(signed int))(*(_DWORD *)v1 + 24))(4);
  v4 = *(_DWORD *)(v2 + 4);
  if ( v4 )
    (*(void (__cdecl **)(signed int))(*(_DWORD *)v4 + 24))(v6);
  TlsFree(*(_DWORD *)(v2 + 8));
  *(_DWORD *)(a1 - 4) = -1;
  sub_100242B2((LPCRITICAL_SECTION)(v2 + 12));
  return sub_1002D086(v6);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10044388) --------------------------------------------------------
void *__thiscall sub_10044388(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_1005A940;
  sub_1004B39B((int)this);
  if ( a2 & 1 )
    sub_1002404A(v2);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005A940: using guessed type int (*off_1005A940)();

//----- (100443AD) --------------------------------------------------------
void *__thiscall sub_100443AD(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_1005A95C;
  if ( a2 & 1 )
    sub_1002404A(this);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005A95C: using guessed type int (*off_1005A95C[5])();

//----- (100443CD) --------------------------------------------------------
int __userpurge sub_100443CD<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4)
{
  int v4; // ecx@1
  int v5; // esi@1
  int v6; // ecx@1
  int v7; // edx@1

  sub_1002D0B8();
  v5 = v6;
  v4 = sub_10027EB3(v7, v6, a1, a3, 68);
  *(_DWORD *)(a2 - 16) = v4;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v4 )
    sub_10044287((void *)v4, v5, *(_DWORD *)(a2 + 8));
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (10044402) --------------------------------------------------------
int __usercall sub_10044402<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // eax@1
  int v4; // edx@1
  int v5; // ecx@1
  int result; // eax@2

  sub_10044681();
  v3 = sub_10027EB3(v4, v5, a1, a2, 48);
  if ( v3 )
    result = sub_100442B8(v3, a3);
  else
    result = 0;
  return result;
}

//----- (10044426) --------------------------------------------------------
int __thiscall sub_10044426(int this)
{
  return *(_DWORD *)(this + 4);
}

//----- (1004442A) --------------------------------------------------------
int __usercall sub_1004442A<eax>(int a1<ebx>, int a2<ebp>)
{
  int v2; // ecx@1
  int v3; // edi@1

  sub_1002D0B8();
  v3 = v2;
  if ( !*(_DWORD *)v2 )
  {
    *(_DWORD *)(a2 - 16) = v2 + 12;
    sub_100244EB((LPCRITICAL_SECTION)(v2 + 12));
    *(_DWORD *)(a2 - 4) = 0;
    if ( !*(_DWORD *)v3 )
      *(_DWORD *)v3 = sub_10044402(a1, v3, v3);
    *(_DWORD *)(a2 - 4) = -1;
    sub_10024670((LPCRITICAL_SECTION)(v3 + 12));
  }
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);

//----- (1004446F) --------------------------------------------------------
BOOL __stdcall sub_1004446F(int a1, int nPriority)
{
  BOOL result; // eax@1

  result = nPriority;
  if ( *(_DWORD *)(a1 + 24) != nPriority )
    result = sub_1004B3FD(a1, nPriority);
  return result;
}

//----- (10044487) --------------------------------------------------------
__int16 __thiscall sub_10044487(void *this, int a2)
{
  signed int v2; // eax@1
  void *v3; // edi@1
  int v4; // esi@1
  union _SLIST_HEADER *v5; // ebx@5

  v4 = a2;
  v3 = this;
  v2 = 0;
  while ( *(_DWORD *)(a2 + 20) != dword_1005A974[v2] )
  {
    ++v2;
    if ( v2 >= 4 )
      goto LABEL_7;
  }
  v5 = (union _SLIST_HEADER *)(this + 8 * v2 + 8);
  LOWORD(v2) = QueryDepthSList((PSLIST_HEADER)this + v2 + 1);
  if ( (unsigned __int16)v2 < dword_1006A058 )
  {
    LOWORD(v2) = (unsigned int)InterlockedPushEntrySList(v5, (PSINGLE_LIST_ENTRY)(a2 + 60));
    v4 = 0;
  }
LABEL_7:
  if ( v4 )
    LOWORD(v2) = (*(int (__thiscall **)(void *, int))(*(_DWORD *)v3 + 32))(v3, v4);
  return v2;
}
// 1005A974: using guessed type int dword_1005A974[];
// 1006A058: using guessed type int dword_1006A058;

//----- (100444E0) --------------------------------------------------------
void __thiscall sub_100444E0(int this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  signed int v4; // eax@2
  union _SLIST_HEADER *v5; // ebx@6
  int v6; // edx@8
  PSINGLE_LIST_ENTRY v7; // eax@8
  int v8; // esi@9

  v3 = a2;
  v2 = this;
  if ( !*(_BYTE *)(this + 44) )
  {
    v4 = 0;
    while ( *(_DWORD *)(a2 + 20) != dword_1005A974[v4] )
    {
      ++v4;
      if ( v4 >= 4 )
        goto LABEL_11;
    }
    v5 = (union _SLIST_HEADER *)(this + 8 + 8 * v4);
    if ( QueryDepthSList((PSLIST_HEADER)(this + 8 + 8 * v4)) < dword_1006A058 )
    {
      InterlockedPushEntrySList(v5, (PSINGLE_LIST_ENTRY)(a2 + 60));
      if ( *(_BYTE *)(v2 + 44) )
      {
        v7 = InterlockedFlushSList(v5);
        v6 = v7 != 0 ? (int)&v7[-15] : 0;
        if ( v7 != 0 ? (int)&v7[-15] : 0 )
        {
          do
          {
            v8 = *(_DWORD *)(v6 + 60);
            (*(void (__thiscall **)(int, int))(*(_DWORD *)v2 + 32))(v2, v6);
            v6 = v8 != 0 ? v8 - 60 : 0;
          }
          while ( v8 != 0 ? v8 - 60 : 0 );
        }
      }
      v3 = 0;
    }
  }
LABEL_11:
  if ( v3 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v2 + 32))(v2, v3);
}
// 1005A974: using guessed type int dword_1005A974[];
// 1006A058: using guessed type int dword_1006A058;

//----- (10044571) --------------------------------------------------------
int __thiscall sub_10044571(void *this)
{
  _ECX = (int)((char *)this + 40);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return _EAX + 1;
}

//----- (1004459A) --------------------------------------------------------
int __thiscall sub_1004459A(void *this, unsigned int a2, int a3)
{
  union _SLIST_HEADER *v3; // eax@1
  unsigned int v4; // ecx@1
  signed int v5; // ebx@1
  void *v6; // edi@1
  int v7; // esi@1
  PSINGLE_LIST_ENTRY v8; // eax@3
  int v10; // [sp+Ch] [bp-4h]@1

  v6 = this;
  v4 = a2;
  v3 = (union _SLIST_HEADER *)((char *)v6 + 8);
  v7 = 0;
  v5 = (signed int)dword_1005A974;
  v10 = (int)((char *)v6 + 8);
  do
  {
    if ( v4 <= *(_DWORD *)v5 )
    {
      v8 = InterlockedPopEntrySList(v3);
      v7 = v8 != 0 ? (int)&v8[-15] : 0;
      if ( v7 )
        goto LABEL_8;
      v3 = (union _SLIST_HEADER *)v10;
      v4 = a2;
    }
    v5 += 4;
    ++v3;
    v10 = (int)v3;
  }
  while ( v5 < (signed int)&off_1005A984 );
  if ( v7 || (v7 = (*(int (__thiscall **)(void *, unsigned int))(*(_DWORD *)v6 + 28))(v6, v4)) != 0 )
LABEL_8:
    (*(void (__thiscall **)(void *, int, int))(*(_DWORD *)v6 + 36))(v6, v7, a3);
  return v7;
}
// 1005A974: using guessed type int dword_1005A974[];
// 1005A984: using guessed type void *off_1005A984;

//----- (10044608) --------------------------------------------------------
BOOL __stdcall sub_10044608(int a1)
{
  return sub_1004B3DE(a1);
}

//----- (10044617) --------------------------------------------------------
PSINGLE_LIST_ENTRY __thiscall sub_10044617(void *this)
{
  signed int v1; // ebx@1
  union _SLIST_HEADER *v2; // edi@1
  PSINGLE_LIST_ENTRY result; // eax@2
  int v4; // edx@2
  int v5; // esi@3
  void *v6; // [sp+Ch] [bp-8h]@1
  signed int v7; // [sp+10h] [bp-4h]@1

  v1 = 4;
  v6 = this;
  v2 = (union _SLIST_HEADER *)((char *)this + 8);
  v7 = 4;
  do
  {
    result = InterlockedFlushSList(v2);
    v4 = result != 0 ? (int)&result[-15] : 0;
    if ( result != 0 ? (int)&result[-15] : 0 )
    {
      do
      {
        v5 = *(_DWORD *)(v4 + 60);
        (*(void (__thiscall **)(void *, int))(*(_DWORD *)v6 + 32))(v6, v4);
        result = (PSINGLE_LIST_ENTRY)(v5 - 60);
        v4 = v5 != 0 ? v5 - 60 : 0;
      }
      while ( v5 != 0 ? v5 - 60 : 0 );
      v1 = v7;
    }
    ++v2;
    --v1;
    v7 = v1;
  }
  while ( v1 );
  return result;
}

//----- (1004466D) --------------------------------------------------------
int __thiscall sub_1004466D(int this)
{
  int v2; // esi@1

  v2 = this;
  *(_BYTE *)(this + 44) = 1;
  sub_10044617((void *)this);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 12))(v2);
}

//----- (10044681) --------------------------------------------------------
void __cdecl sub_10044681()
{
  if ( !dword_1006A058 )
    dword_1006A058 = 4 * sub_10034C38();
}
// 1006A058: using guessed type int dword_1006A058;

//----- (100446D6) --------------------------------------------------------
int __usercall sub_100446D6<eax>(double a1<st0>)
{
  int result; // eax@1
  float v2; // edx@1
  float v3; // ST18_4@1
  double v4; // st7@2
  float v5; // ST00_4@3
  float v6; // ST00_4@4
  signed __int64 v7; // [sp+10h] [bp-10h]@1

  v3 = a1;
  v7 = (signed __int64)a1;
  v2 = v3;
  result = (signed __int64)a1;
  if ( result || (LODWORD(v2) = HIDWORD(v7), HIDWORD(v7) & 0x7FFFFFFF) )
  {
    v4 = a1 - (double)(signed __int64)a1;
    if ( LODWORD(v2) >= 0 )
    {
      v6 = v4;
      result -= LODWORD(v6) >= 0x80000001u;
    }
    else
    {
      v5 = v4;
      result += (LODWORD(v5) ^ 0x80000000u) >= 0x80000001;
    }
  }
  return result;
}

//----- (1004474B) --------------------------------------------------------
int __thiscall sub_1004474B(int this, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)this = a2 & 0xFFFFFFF;
  *(_DWORD *)(this + 4) = a4;
  *(_DWORD *)(this + 12) = a5;
  *(_DWORD *)(this + 8) = a3;
  return this;
}

//----- (10044770) --------------------------------------------------------
bool __thiscall sub_10044770(int this, char a2)
{
  int v3; // esi@1
  int v4; // eax@1

  v3 = this + 16;
  v4 = sub_1002A812((int)&a2, *(_DWORD *)(this + 16));
  return sub_1002AE75(v3, (int)&a2, v4) != 0;
}

//----- (1004479B) --------------------------------------------------------
char __thiscall sub_1004479B(int this, int a2)
{
  int v2; // eax@1
  int v3; // eax@2
  int v4; // eax@3
  char result; // al@5
  int v6; // eax@7

  v2 = *(_DWORD *)a2 & 0xFFFFFFF;
  if ( !v2 )
    return 1;
  v3 = v2 - 1;
  if ( !v3 )
  {
    v6 = *(_DWORD *)(*(_DWORD *)(this + 12) + 44);
    return v6 == *(_DWORD *)(a2 + 8);
  }
  v4 = v3 - 1;
  if ( !v4 )
  {
    v6 = *(_DWORD *)(this + 8);
    return v6 == *(_DWORD *)(a2 + 8);
  }
  if ( v4 == 1 )
    result = sub_10044770(*(_DWORD *)(this + 12), *(_DWORD *)(a2 + 8));
  else
    result = 0;
  return result;
}

//----- (100447E2) --------------------------------------------------------
char __thiscall sub_100447E2(int this, int a2)
{
  int v2; // eax@1
  int v3; // eax@2
  int v4; // eax@3
  char result; // al@5
  int v6; // eax@6

  v2 = *(_DWORD *)a2 & 0xFFFFFFF;
  if ( v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      v4 = v3 - 1;
      if ( v4 )
      {
        if ( v4 != 1 )
          return 0;
        v6 = *(_DWORD *)(this + 8);
      }
      else
      {
        v6 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 12) + 68) + 48);
      }
    }
    else
    {
      v6 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 12) + 68) + 44);
    }
    result = v6 == *(_DWORD *)(a2 + 8);
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1004482A) --------------------------------------------------------
signed int __usercall sub_1004482A<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // eax@3
  int v5; // eax@7
  signed int v6; // eax@10
  signed int v7; // ST08_4@10
  const CHAR *v8; // ST04_4@10
  int v9; // edx@10
  int v10; // ST00_4@10
  int v11; // eax@15
  signed int v12; // esi@15
  signed int result; // eax@23
  signed int *v14; // ecx@23

  if ( !a4 )
  {
    *(_DWORD *)sub_1002F144(a3) = 22;
    sub_10036C88(a3, 0);
    return -1;
  }
  v4 = *(_DWORD *)(a4 + 12);
  if ( !(v4 & 0x83) || v4 & 0x40 )
    return -1;
  if ( v4 & 2 )
  {
    *(_DWORD *)(a4 + 12) = v4 | 0x20;
    return -1;
  }
  v5 = v4 | 1;
  *(_DWORD *)(a4 + 12) = v5;
  if ( v5 & 0x10C )
    *(_DWORD *)a4 = *(_DWORD *)(a4 + 8);
  else
    sub_10045627(a1, a2, a3, a4);
  v7 = *(_DWORD *)(a4 + 24);
  v8 = *(const CHAR **)(a4 + 8);
  v6 = sub_1004494B(a3, a4, a4);
  sub_1004B4C4(v9, v10, a3, a4, v6, v8, v7);
  *(_DWORD *)(a4 + 4) = v6;
  if ( !v6 || v6 == -1 )
  {
    *(_DWORD *)(a4 + 12) |= v6 != 0 ? 32 : 16;
    *(_DWORD *)(a4 + 4) = 0;
    return -1;
  }
  if ( !(*(_BYTE *)(a4 + 12) & 0x82) )
  {
    if ( sub_1004494B(a3, a4, a4) == -1 || sub_1004494B(a3, a4, a4) == -2 )
    {
      v11 = (int)&unk_10067A10;
    }
    else
    {
      v12 = sub_1004494B(a3, a4, a4) >> 5;
      v11 = dword_10069CE0[v12] + ((sub_1004494B(a3, a4, a4) & 0x1F) << 6);
    }
    if ( (*(_BYTE *)(v11 + 4) & 0x82) == -126 )
      *(_DWORD *)(a4 + 12) |= 0x2000u;
  }
  if ( *(_DWORD *)(a4 + 24) == 512 )
  {
    if ( *(_BYTE *)(a4 + 12) & 8 )
    {
      if ( !(*(_DWORD *)(a4 + 12) & 0x400) )
        *(_DWORD *)(a4 + 24) = 4096;
    }
  }
  v14 = *(signed int **)a4;
  --*(_DWORD *)(a4 + 4);
  result = *(_BYTE *)v14;
  *(_DWORD *)a4 = (char *)v14 + 1;
  return result;
}
// 10069CE0: using guessed type int dword_10069CE0[];

//----- (1004494B) --------------------------------------------------------
signed int __usercall sub_1004494B<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  signed int result; // eax@2

  if ( a3 )
  {
    result = *(_DWORD *)(a3 + 16);
  }
  else
  {
    *(_DWORD *)sub_1002F144(a1) = 22;
    sub_10036C88(a1, a2);
    result = -1;
  }
  return result;
}

//----- (1004496F) --------------------------------------------------------
signed int __usercall sub_1004496F<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5)
{
  signed int v5; // eax@2
  int v7; // eax@24
  int v8; // eax@28

  if ( !(*(_BYTE *)(a5 + 12) & 0x40) )
  {
    v5 = sub_1004494B(a3, -1, a5);
    if ( v5 == -1 || v5 == -2 )
      a1 = (int)&unk_10067A10;
    else
      a1 = dword_10069CE0[v5 >> 5] + ((v5 & 0x1F) << 6);
    if ( *(_BYTE *)(a1 + 36) & 0x7F
      || (v5 == -1 || v5 == -2 ? (a2 = (int)&unk_10067A10) : (a2 = dword_10069CE0[v5 >> 5] + ((v5 & 0x1F) << 6)),
          *(_BYTE *)(a2 + 36) & 0x80) )
    {
      *(_DWORD *)sub_1002F144((int)&unk_10067A10) = 22;
      sub_10036C88((int)&unk_10067A10, -1);
      return -1;
    }
  }
  if ( a4 == -1 || !(*(_BYTE *)(a5 + 12) & 1) && (!(*(_BYTE *)(a5 + 12) & 0x80) || *(_BYTE *)(a5 + 12) & 2) )
    return -1;
  if ( !*(_DWORD *)(a5 + 8) )
    sub_10045627(a1, a2, a4, a5);
  if ( *(_DWORD *)a5 == *(_DWORD *)(a5 + 8) )
  {
    if ( *(_DWORD *)(a5 + 4) )
      return -1;
    ++*(_DWORD *)a5;
  }
  --*(_DWORD *)a5;
  v7 = *(_DWORD *)a5;
  if ( *(_BYTE *)(a5 + 12) & 0x40 )
  {
    if ( *(_BYTE *)v7 != (_BYTE)a4 )
    {
      *(_DWORD *)a5 = v7 + 1;
      return -1;
    }
  }
  else
  {
    *(_BYTE *)v7 = a4;
  }
  v8 = *(_DWORD *)(a5 + 12);
  ++*(_DWORD *)(a5 + 4);
  *(_DWORD *)(a5 + 12) = v8 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a4;
}
// 10069CE0: using guessed type int dword_10069CE0[];

//----- (10044A4F) --------------------------------------------------------
signed int __usercall sub_10044A4F<eax>(int a1<edi>, LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int a4, int a5)
{
  signed int v6; // edi@11
  int v7; // edi@13
  char v8; // cf@14
  int v9; // [sp+8h] [bp-10h]@8
  int v10; // [sp+10h] [bp-8h]@23
  char v11; // [sp+14h] [bp-4h]@22

  if ( !lpMultiByteStr || !a4 )
    return 0;
  if ( !*lpMultiByteStr )
  {
    if ( lpWideCharStr )
      *lpWideCharStr = 0;
    return 0;
  }
  sub_1002E635((int)&v9, a4, a1, a5);
  if ( !*(_DWORD *)(v9 + 168) )
  {
    if ( lpWideCharStr )
      *lpWideCharStr = (unsigned __int8)*lpMultiByteStr;
    v6 = 1;
    goto LABEL_22;
  }
  if ( !sub_10041D47(a4, a1, *lpMultiByteStr, (int)&v9) )
  {
    v6 = 1;
    if ( MultiByteToWideChar(*(_DWORD *)(v9 + 4), 9u, lpMultiByteStr, 1, lpWideCharStr, lpWideCharStr != 0) )
      goto LABEL_22;
    goto LABEL_21;
  }
  v7 = v9;
  if ( *(_DWORD *)(v9 + 116) <= 1 )
    goto LABEL_27;
  v8 = (unsigned int)a4 < *(_DWORD *)(v9 + 116);
  if ( a4 < *(_DWORD *)(v9 + 116) )
  {
LABEL_17:
    if ( !v8 && lpMultiByteStr[1] )
      goto LABEL_19;
LABEL_21:
    v6 = -1;
    *(_DWORD *)sub_1002F144(a4) = 42;
    goto LABEL_22;
  }
  v7 = v9;
  if ( !MultiByteToWideChar(
          *(_DWORD *)(v9 + 4),
          9u,
          lpMultiByteStr,
          *(_DWORD *)(v9 + 116),
          lpWideCharStr,
          lpWideCharStr != 0) )
  {
LABEL_27:
    v8 = (unsigned int)a4 < *(_DWORD *)(v7 + 116);
    goto LABEL_17;
  }
LABEL_19:
  v6 = *(_DWORD *)(v7 + 116);
LABEL_22:
  if ( v11 )
    *(_DWORD *)(v10 + 112) &= 0xFFFFFFFDu;
  return v6;
}

//----- (10044B42) --------------------------------------------------------
signed int __usercall sub_10044B42<eax>(int a1<edi>, LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int a4)
{
  return sub_10044A4F(a1, lpWideCharStr, lpMultiByteStr, a4, 0);
}

//----- (10044B5A) --------------------------------------------------------
int __usercall sub_10044B5A<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  if ( a3 == -2 )
  {
    *(_DWORD *)sub_1002F144(a1) = 9;
  }
  else
  {
    if ( a3 >= 0 && a3 < (unsigned int)dword_1006A394 )
      return *(_BYTE *)(dword_10069CE0[a3 >> 5] + ((a3 & 0x1F) << 6) + 4) & 0x40;
    *(_DWORD *)sub_1002F144(a1) = 9;
    sub_10036C88(a1, a2);
  }
  return 0;
}
// 10069CE0: using guessed type int dword_10069CE0[];
// 1006A394: using guessed type int dword_1006A394;

//----- (10044BAE) --------------------------------------------------------
void __usercall sub_10044BAE(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, const void *a6, int nNumberOfBytesToWrite)
{
  int v7; // [sp-4h] [bp-34h]@6

  if ( a5 == -2 )
  {
    *(_DWORD *)sub_1002F110(a3) = 0;
    *(_DWORD *)sub_1002F144(a3) = 9;
  }
  else
  {
    if ( a5 >= 0
      && a5 < (unsigned int)dword_1006A394
      && (a3 = a5 >> 5, a4 = (a5 & 0x1F) << 6, *(_BYTE *)(dword_10069CE0[a5 >> 5] + a4 + 4) & 1) )
    {
      sub_1004BD5B(a1, a2, a3, a5);
      if ( *(_BYTE *)(dword_10069CE0[a3] + a4 + 4) & 1 )
      {
        sub_10044C90(v7, a3, a4, a5, a5, a6, nNumberOfBytesToWrite);
      }
      else
      {
        *(_DWORD *)sub_1002F144(a3) = 9;
        *(_DWORD *)sub_1002F110(a3) = 0;
      }
      sub_1004BED4(a5);
    }
    else
    {
      *(_DWORD *)sub_1002F110(a3) = 0;
      *(_DWORD *)sub_1002F144(a3) = 9;
      sub_10036C88(a3, a4);
    }
  }
}
// 10069CE0: using guessed type int dword_10069CE0[];
// 1006A394: using guessed type int dword_1006A394;

//----- (10044C90) --------------------------------------------------------
int __usercall sub_10044C90<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<esi>, signed int a5, const void *a6, int nNumberOfBytesToWrite)
{
  signed int v7; // eax@1
  int v8; // edi@1
  int v10; // ecx@5
  int v11; // esi@5
  unsigned __int8 v12; // zf@14
  UINT v13; // eax@17
  LPCVOID v14; // edx@17
  const CHAR *v15; // ecx@17
  int v16; // eax@18
  int v17; // edx@20
  unsigned __int8 v18; // cl@20
  LPCSTR v19; // eax@25
  int v20; // eax@29
  unsigned __int8 v21; // zf@38
  signed __int16 v22; // ax@41
  signed __int16 v23; // ax@43
  int v24; // esi@49
  int v25; // eax@51
  LPCVOID v26; // eax@53
  int v27; // eax@54
  char *v28; // edx@54
  char *v29; // ebx@54
  char v30; // cl@56
  int v31; // ecx@56
  char v32; // zf@56
  DWORD v33; // ecx@63
  int v34; // eax@65
  unsigned int v35; // edx@65
  char *v36; // ebx@65
  int v37; // edi@65
  __int16 v38; // si@67
  char *v39; // eax@75
  unsigned int v40; // edx@75
  int v41; // ecx@75
  DWORD v42; // esi@75
  __int16 v43; // di@77
  const CHAR *v44; // eax@80
  int v45; // ecx@81
  DWORD v46; // eax@85
  UINT v47; // [sp+0h] [bp-1AF0h]@17
  int v48; // [sp+4h] [bp-1AECh]@5
  DWORD Mode; // [sp+Ch] [bp-1AE4h]@14
  char v50; // [sp+13h] [bp-1ADDh]@56
  DWORD NumberOfBytesWritten; // [sp+14h] [bp-1ADCh]@17
  int v52; // [sp+18h] [bp-1AD8h]@59
  int v53; // [sp+1Ch] [bp-1AD4h]@1
  int v54; // [sp+20h] [bp-1AD0h]@5
  LPCSTR lpMultiByteStr; // [sp+24h] [bp-1ACCh]@17
  int v56; // [sp+28h] [bp-1AC8h]@18
  const WCHAR WideCharStr[2]; // [sp+2Ch] [bp-1AC4h]@1
  const void *v58; // [sp+30h] [bp-1AC0h]@1
  LPCVOID lpBuffer; // [sp+34h] [bp-1ABCh]@1
  char v60; // [sp+38h] [bp-1AB8h]@54
  CHAR MultiByteStr[3416]; // [sp+6E0h] [bp-1410h]@80
  char v62; // [sp+1438h] [bp-6B8h]@75
  void *v63; // [sp+1AD0h] [bp-20h]@30
  char *v64; // [sp+1AD4h] [bp-1Ch]@30
  LPCSTR v65[3]; // [sp+1AD8h] [bp-18h]@14
  signed int v66; // [sp+1AE0h] [bp-10h]@14
  int Buffer; // [sp+1AE4h] [bp-Ch]@5
  int v68; // [sp+1AE8h] [bp-8h]@5
  int v69; // [sp+1AECh] [bp-4h]@1

  sub_10042170(0x1AF0u, a1);
  v7 = a5;
  v69 = a3;
  v8 = 0;
  v58 = (const void *)a5;
  lpBuffer = a6;
  *(_DWORD *)WideCharStr = 0;
  v53 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a6 )
  {
    *(_DWORD *)sub_1002F110(a2) = 0;
    *(_DWORD *)sub_1002F144(a2) = 22;
    sub_10036C88(a2, 0);
    return -1;
  }
  v68 = a2;
  Buffer = a4;
  v11 = (a5 & 0x1F) << 6;
  v54 = a5 >> 5;
  v10 = dword_10069CE0[a5 >> 5];
  v48 = v11;
  LOBYTE(a2) = (char)(2 * *(_BYTE *)(v11 + v10 + 36)) >> 1;
  if ( (_BYTE)a2 == 2 || (_BYTE)a2 == 1 )
  {
    if ( !(~(_BYTE)nNumberOfBytesToWrite & 1) )
    {
      *(_DWORD *)sub_1002F110(a2) = 0;
      *(_DWORD *)sub_1002F144(a2) = 22;
      sub_10036C88(a2, 0);
      return -1;
    }
    v7 = (signed int)v58;
  }
  if ( *(_BYTE *)(v11 + v10 + 4) & 0x20 )
    sub_100455B6(a2, 0, v7, 0i64, 2u);
  if ( !sub_10044B5A(a2, 0, (signed int)v58)
    || !(*(_BYTE *)(v11 + dword_10069CE0[v54] + 4) & 0x80)
    || (v12 = *(_DWORD *)(*(_DWORD *)(sub_10031BD7(a2, 0) + 108) + 168) == 0,
        v66 = (signed int)&Mode,
        v65[1] = *(LPCSTR *)(v11 + dword_10069CE0[v54]),
        v58 = (const void *)v12,
        !GetConsoleMode((HANDLE)v65[1], &Mode))
    || v58 && !(_BYTE)a2 )
  {
    v25 = dword_10069CE0[v54];
    if ( *(_BYTE *)(v11 + v25 + 4) & 0x80 )
    {
      v14 = lpBuffer;
      v24 = 0;
      v56 = 0;
      if ( (_BYTE)a2 )
      {
        v33 = (DWORD)lpBuffer;
        if ( (_BYTE)a2 == 2 )
        {
          v58 = lpBuffer;
          if ( (unsigned int)nNumberOfBytesToWrite <= 0 )
            goto LABEL_98;
          while ( 1 )
          {
            Mode = 0;
            v37 = v53;
            v34 = v33 - (_DWORD)v14;
            v35 = 0;
            v36 = &v60;
            do
            {
              if ( v34 >= (unsigned int)nNumberOfBytesToWrite )
                break;
              v38 = *(_WORD *)v33;
              v33 += 2;
              v34 += 2;
              v58 = (const void *)v33;
              if ( v38 == 10 )
              {
                *(_WORD *)v36 = 13;
                v33 = (DWORD)v58;
                v37 += 2;
                v36 += 2;
                v35 += 2;
              }
              *(_WORD *)v36 = v38;
              v35 += 2;
              v36 += 2;
            }
            while ( v35 < 0x13FE );
            a2 = v36 - &v60;
            v66 = 0;
            v65[1] = (LPCSTR)&v52;
            v65[0] = (LPCSTR)a2;
            v64 = &v60;
            v53 = v37;
            v63 = *(void **)(v48 + dword_10069CE0[v54]);
            v24 = v56;
            v8 = *(_DWORD *)WideCharStr;
            if ( !WriteFile(v63, &v60, a2, (LPDWORD)&v52, 0) )
              break;
            v8 = v52 + *(_DWORD *)WideCharStr;
            v14 = lpBuffer;
            *(_DWORD *)WideCharStr += v52;
            if ( v52 >= a2 )
            {
              v33 = (DWORD)v58;
              if ( v58 - lpBuffer < nNumberOfBytesToWrite )
                continue;
            }
            goto LABEL_93;
          }
        }
        else
        {
          a2 = nNumberOfBytesToWrite;
          NumberOfBytesWritten = (DWORD)lpBuffer;
          if ( !nNumberOfBytesToWrite )
            goto LABEL_98;
          while ( 1 )
          {
            Mode = 0;
            v42 = NumberOfBytesWritten;
            v41 = v33 - (_DWORD)v14;
            v40 = 0;
            v39 = &v62;
            do
            {
              if ( v41 >= (unsigned int)nNumberOfBytesToWrite )
                break;
              v43 = *(_WORD *)v42;
              v42 += 2;
              v41 += 2;
              NumberOfBytesWritten = v42;
              if ( v43 == 10 )
              {
                *(_WORD *)v39 = 13;
                v42 = NumberOfBytesWritten;
                v39 += 2;
                v40 += 2;
              }
              *(_WORD *)v39 = v43;
              v40 += 2;
              v39 += 2;
            }
            while ( v40 < 0x6A8 );
            v44 = (const CHAR *)WideCharToMultiByte(
                                  0xFDE9u,
                                  0,
                                  (LPCWSTR)&v62,
                                  (signed int)(v39 - &v62) / 2,
                                  MultiByteStr,
                                  3413,
                                  0,
                                  0);
            v24 = v56;
            v8 = *(_DWORD *)WideCharStr;
            lpMultiByteStr = v44;
            if ( !v44 )
              break;
            v45 = 0;
            v58 = 0;
            while ( 1 )
            {
              v66 = 0;
              v65[1] = (LPCSTR)&v52;
              v65[0] = &v44[-v45];
              v64 = &MultiByteStr[v45];
              v63 = *(void **)(v48 + dword_10069CE0[v54]);
              if ( !WriteFile(v63, &MultiByteStr[v45], (DWORD)&v44[-v45], (LPDWORD)&v52, 0) )
                break;
              v45 = (int)((char *)v58 + v52);
              v44 = lpMultiByteStr;
              v58 = (const void *)v45;
              if ( (signed int)lpMultiByteStr <= v45 )
                goto LABEL_86;
            }
            v46 = GetLastError();
            v45 = (int)v58;
            v24 = v46;
            v44 = lpMultiByteStr;
            v56 = v24;
LABEL_86:
            if ( (signed int)v44 > v45 )
              goto LABEL_92;
            v33 = NumberOfBytesWritten;
            v14 = lpBuffer;
            v8 = NumberOfBytesWritten - (_DWORD)lpBuffer;
            *(_DWORD *)WideCharStr = NumberOfBytesWritten - (_DWORD)lpBuffer;
            if ( NumberOfBytesWritten - (_DWORD)lpBuffer >= nNumberOfBytesToWrite )
              goto LABEL_93;
          }
        }
      }
      else
      {
        v26 = lpBuffer;
        *(_DWORD *)WideCharStr = lpBuffer;
        if ( (unsigned int)nNumberOfBytesToWrite <= 0 )
          goto LABEL_98;
        while ( 1 )
        {
          v27 = v26 - v14;
          v28 = *(char **)WideCharStr;
          v29 = &v60;
          v58 = 0;
          do
          {
            if ( v27 >= (unsigned int)nNumberOfBytesToWrite )
              break;
            v30 = *v28;
            ++v27;
            v50 = v30;
            v32 = v30 == 10;
            v31 = (int)v58;
            *(_DWORD *)WideCharStr = v28 + 1;
            if ( v32 )
            {
              ++v53;
              *v29++ = 13;
              ++v31;
            }
            *v29 = v50;
            v28 = *(char **)WideCharStr;
            ++v29;
            v58 = (const void *)(v31 + 1);
          }
          while ( (unsigned int)(v31 + 1) < 0x13FF );
          a2 = v29 - &v60;
          v66 = 0;
          v65[1] = (LPCSTR)&v52;
          v65[0] = (LPCSTR)a2;
          v64 = &v60;
          v63 = *(void **)(v48 + dword_10069CE0[v54]);
          if ( !WriteFile(v63, &v60, a2, (LPDWORD)&v52, 0) )
            break;
          v8 += v52;
          v14 = lpBuffer;
          if ( v52 >= a2 )
          {
            v26 = *(LPCVOID *)WideCharStr;
            if ( *(_DWORD *)WideCharStr - (_DWORD)lpBuffer < (unsigned int)nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_93;
        }
      }
    }
    else
    {
      v66 = 0;
      v65[1] = (LPCSTR)&v52;
      v65[0] = (LPCSTR)nNumberOfBytesToWrite;
      v64 = (char *)lpBuffer;
      v63 = *(void **)(v11 + v25);
      if ( WriteFile(v63, lpBuffer, nNumberOfBytesToWrite, (LPDWORD)&v52, 0) )
      {
        v8 = v52;
        v24 = 0;
        goto LABEL_92;
      }
    }
LABEL_91:
    v24 = GetLastError();
    goto LABEL_92;
  }
  v13 = GetConsoleCP();
  v14 = lpBuffer;
  NumberOfBytesWritten = 0;
  v15 = (const CHAR *)lpBuffer;
  v47 = v13;
  lpMultiByteStr = (LPCSTR)lpBuffer;
  if ( (unsigned int)nNumberOfBytesToWrite <= 0 )
  {
    v24 = (int)v58;
    goto LABEL_94;
  }
  v16 = 0;
  v56 = 0;
  while ( (_BYTE)a2 )
  {
    if ( (_BYTE)a2 == 1 || (_BYTE)a2 == 2 )
    {
      v21 = *(_WORD *)v15 == 10;
      *(_DWORD *)WideCharStr = *(_WORD *)v15;
      v15 += 2;
      v16 = v56 + 2;
      lpMultiByteStr = v15;
      v56 += 2;
      v58 = (const void *)v21;
    }
    if ( (_BYTE)a2 != 1 && (_BYTE)a2 != 2 )
      goto LABEL_46;
    v22 = sub_1004BEFA((DWORD)v15, WideCharStr[0]);
    if ( v22 != WideCharStr[0] )
      goto LABEL_91;
    v8 += 2;
    if ( v58 )
    {
      *(_DWORD *)WideCharStr = 13;
      v23 = sub_1004BEFA(v66, 13);
      if ( v23 != WideCharStr[0] )
        goto LABEL_91;
      ++v8;
      ++v53;
    }
LABEL_45:
    v16 = v56;
    v15 = lpMultiByteStr;
LABEL_46:
    if ( v16 >= (unsigned int)nNumberOfBytesToWrite )
      goto LABEL_49;
  }
  v18 = *v15;
  v58 = (const void *)(v18 == 10);
  v17 = dword_10069CE0[v54];
  if ( *(_DWORD *)(v11 + v17 + 56) )
  {
    LOBYTE(Buffer) = *(_BYTE *)(v11 + v17 + 52);
    v66 = 2;
    BYTE1(Buffer) = v18;
    *(_DWORD *)(v11 + v17 + 56) = 0;
    v65[1] = (LPCSTR)&Buffer;
LABEL_27:
    if ( sub_10044B42(v8, (LPWSTR)WideCharStr, v65[1], v66) == -1 )
      goto LABEL_49;
    v19 = lpMultiByteStr;
LABEL_29:
    ++v56;
    lpMultiByteStr = v19 + 1;
    v20 = WideCharToMultiByte(v47, 0, WideCharStr, 1, (LPSTR)&Buffer, 5, 0, 0);
    Mode = v20;
    if ( !v20 )
      goto LABEL_49;
    v66 = 0;
    v65[1] = (LPCSTR)&NumberOfBytesWritten;
    v65[0] = (LPCSTR)v20;
    v64 = (char *)&Buffer;
    v63 = *(void **)(v11 + dword_10069CE0[v54]);
    if ( !WriteFile(v63, &Buffer, v20, &NumberOfBytesWritten, 0) )
      goto LABEL_91;
    v8 = v53 + v56;
    if ( (signed int)NumberOfBytesWritten < (signed int)Mode )
      goto LABEL_49;
    if ( v58 )
    {
      v66 = 0;
      v65[1] = (LPCSTR)&NumberOfBytesWritten;
      v65[0] = (LPCSTR)1;
      v64 = (char *)&Buffer;
      LOBYTE(Buffer) = 13;
      v63 = *(void **)(v11 + dword_10069CE0[v54]);
      if ( !WriteFile(v63, &Buffer, 1u, &NumberOfBytesWritten, 0) )
        goto LABEL_91;
      if ( (signed int)NumberOfBytesWritten < 1 )
        goto LABEL_49;
      ++v53;
      ++v8;
    }
    goto LABEL_45;
  }
  if ( !sub_10041D7D(a2, v8, v18) )
  {
    v66 = 1;
    v65[1] = lpMultiByteStr;
    goto LABEL_27;
  }
  if ( nNumberOfBytesToWrite + lpBuffer - lpMultiByteStr > 1 )
  {
    if ( sub_10044B42(v8, (LPWSTR)WideCharStr, lpMultiByteStr, 2) == -1 )
      goto LABEL_49;
    v19 = lpMultiByteStr + 1;
    ++v56;
    goto LABEL_29;
  }
  a2 = v54;
  ++v8;
  *(_BYTE *)(v11 + dword_10069CE0[v54] + 52) = *lpMultiByteStr;
  *(_DWORD *)(v11 + dword_10069CE0[a2] + 56) = 1;
LABEL_49:
  v24 = (int)v58;
LABEL_92:
  v14 = lpBuffer;
LABEL_93:
  if ( v8 )
    return v8 - v53;
LABEL_94:
  if ( v24 )
  {
    if ( v24 == 5 )
    {
      *(_DWORD *)sub_1002F144(5) = 9;
      *(_DWORD *)sub_1002F110(5) = 5;
    }
    else
    {
      sub_1002F123(5, v24);
    }
    return -1;
  }
LABEL_98:
  if ( !(*(_BYTE *)(v48 + dword_10069CE0[v54] + 4) & 0x40) || *(_BYTE *)v14 != 26 )
  {
    *(_DWORD *)sub_1002F144(a2) = 28;
    *(_DWORD *)sub_1002F110(a2) = 0;
    return -1;
  }
  return 0;
}
// 10069CE0: using guessed type int dword_10069CE0[];
// 10044C90: using guessed type CHAR MultiByteStr[3416];

//----- (100454BA) --------------------------------------------------------
void __usercall sub_100454BA(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, LARGE_INTEGER liDistanceToMove, DWORD dwMoveMethod)
{
  if ( a4 == -2 )
  {
    *(_DWORD *)sub_1002F110(a3) = 0;
    *(_DWORD *)sub_1002F144(a3) = 9;
  }
  else
  {
    if ( a4 >= 0
      && a4 < (unsigned int)dword_1006A394
      && (a3 = (a4 & 0x1F) << 6, *(_BYTE *)(dword_10069CE0[a4 >> 5] + a3 + 4) & 1) )
    {
      sub_1004BD5B(a1, a2, a3, a4);
      if ( *(_BYTE *)(dword_10069CE0[a4 >> 5] + a3 + 4) & 1 )
      {
        sub_100455B6(a3, a4, a4, liDistanceToMove, dwMoveMethod);
      }
      else
      {
        *(_DWORD *)sub_1002F144(a3) = 9;
        *(_DWORD *)sub_1002F110(a3) = 0;
      }
      sub_1004BED4(a4);
    }
    else
    {
      *(_DWORD *)sub_1002F110(a3) = 0;
      *(_DWORD *)sub_1002F144(a3) = 9;
      sub_10036C88(a3, a4);
    }
  }
}
// 10069CE0: using guessed type int dword_10069CE0[];
// 1006A394: using guessed type int dword_1006A394;

//----- (100455B6) --------------------------------------------------------
LARGE_INTEGER __usercall sub_100455B6<edx:eax>(int a1<ebx>, int a2<edi>, signed int a3, LARGE_INTEGER liDistanceToMove, DWORD dwMoveMethod)
{
  void *v5; // eax@1
  int v7; // eax@5
  LARGE_INTEGER NewFilePointer; // [sp+8h] [bp-8h]@4

  v5 = (void *)sub_1004BE6D(a1, a2, a3);
  if ( v5 == (void *)-1 )
  {
    *(_DWORD *)sub_1002F144(a1) = 9;
    return (LARGE_INTEGER)-1i64;
  }
  if ( !SetFilePointerEx(v5, liDistanceToMove, &NewFilePointer, dwMoveMethod) )
  {
    v7 = GetLastError();
    sub_1002F123(a1, v7);
    return (LARGE_INTEGER)-1i64;
  }
  *(_BYTE *)(dword_10069CE0[a3 >> 5] + ((a3 & 0x1F) << 6) + 4) &= 0xFDu;
  return NewFilePointer;
}
// 10069CE0: using guessed type int dword_10069CE0[];

//----- (10045627) --------------------------------------------------------
int __usercall sub_10045627<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // eax@1
  int result; // eax@4

  ++dword_10069CD8;
  v4 = sub_1002F02B(a1, a2, a3, 4096);
  *(_DWORD *)(a4 + 8) = v4;
  if ( v4 )
  {
    *(_DWORD *)(a4 + 12) |= 8u;
    *(_DWORD *)(a4 + 24) = 4096;
  }
  else
  {
    *(_DWORD *)(a4 + 12) |= 4u;
    *(_DWORD *)(a4 + 8) = a4 + 20;
    *(_DWORD *)(a4 + 24) = 2;
  }
  result = *(_DWORD *)(a4 + 8);
  *(_DWORD *)(a4 + 4) = 0;
  *(_DWORD *)a4 = result;
  return result;
}
// 10069CD8: using guessed type int dword_10069CD8;

//----- (1004566D) --------------------------------------------------------
signed int __cdecl sub_1004566D(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@1
  signed int v6; // eax@3
  signed int v7; // ecx@3
  int v8; // edx@5
  int v9; // ecx@10
  int v10; // edx@13
  signed int result; // eax@14
  int v12; // ecx@14
  int v13; // esi@15
  int v14; // eax@18
  unsigned int v15; // eax@20
  int v16; // eax@35
  int v17; // eax@40
  char v18; // al@52
  int v19; // eax@64
  signed int v20; // eax@78
  int i; // eax@89
  signed int v22; // eax@92
  int v23; // eax@102
  int v24; // ST1C_4@108
  int v25; // esi@127
  int v26; // eax@134
  int v27; // edi@134
  int v28; // eax@138
  int v29; // edi@138
  int v30; // ST18_4@138
  int v31; // ST14_4@138
  int v32; // ST10_4@138
  int v33; // ST0C_4@138
  PVOID v34; // eax@138
  PVOID v35; // eax@140
  PVOID v36; // eax@143
  int v37; // edi@154
  int v38; // eax@156
  signed int v39; // edx@169
  char *k; // esi@175
  int v41; // ecx@178
  unsigned __int64 v42; // ST10_8@178
  int v43; // eax@178
  int v44; // ecx@178
  int v45; // edx@178
  int v46; // eax@181
  int j; // eax@187
  int v48; // eax@202
  int v49; // eax@207
  const WCHAR v50; // ST1C_2@210
  signed int v51; // eax@214
  signed int v52; // [sp-4h] [bp-290h]@147
  int v53; // [sp+Ch] [bp-280h]@138
  int v54; // [sp+10h] [bp-27Ch]@138
  char v55; // [sp+14h] [bp-278h]@1
  int v56; // [sp+1Ch] [bp-270h]@228
  char v57; // [sp+20h] [bp-26Ch]@227
  int v58; // [sp+28h] [bp-264h]@15
  int v59; // [sp+2Ch] [bp-260h]@22
  int v60; // [sp+30h] [bp-25Ch]@210
  int v61; // [sp+34h] [bp-258h]@1
  int v62; // [sp+38h] [bp-254h]@1
  LPVOID lpMem; // [sp+3Ch] [bp-250h]@14
  int v64; // [sp+40h] [bp-24Ch]@14
  int v65; // [sp+44h] [bp-248h]@1
  int v66; // [sp+48h] [bp-244h]@1
  int v67; // [sp+4Ch] [bp-240h]@78
  unsigned int v68; // [sp+50h] [bp-23Ch]@14
  int v69; // [sp+54h] [bp-238h]@1
  int v70; // [sp+58h] [bp-234h]@1
  int v71; // [sp+5Ch] [bp-230h]@1
  int v72; // [sp+60h] [bp-22Ch]@1
  char v73; // [sp+64h] [bp-228h]@153
  char v74; // [sp+65h] [bp-227h]@153
  int v75; // [sp+68h] [bp-224h]@14
  int v76; // [sp+6Ch] [bp-220h]@1
  int v77; // [sp+70h] [bp-21Ch]@14
  int v78; // [sp+74h] [bp-218h]@1
  int v79; // [sp+78h] [bp-214h]@1
  char v80; // [sp+7Fh] [bp-20Dh]@14
  CHAR UsedDefaultChar; // [sp+80h] [bp-20Ch]@78
  char v82; // [sp+27Fh] [bp-Dh]@175
  char v83; // [sp+280h] [bp-Ch]@210
  unsigned int v84; // [sp+288h] [bp-4h]@1
  int v85; // [sp+28Ch] [bp+0h]@1

  v84 = (unsigned int)&v85 ^ __security_cookie;
  v5 = a4;
  v70 = a2;
  v4 = 0;
  v72 = a1;
  v78 = a4;
  v62 = 0;
  v79 = 0;
  v69 = 0;
  v76 = 0;
  v71 = 0;
  v65 = 0;
  v66 = 0;
  sub_1002E635((int)&v55, 0, a4, a3);
  v61 = sub_1002F144(0);
  if ( !a1
    || !(*(_BYTE *)(a1 + 12) & 0x40)
    && ((v7 = sub_1004494B(0, a4, a1), v6 = -1, v7 == -1) || v7 == -2 ? (v8 = (int)&unk_10067A10) : (v8 = dword_10069CE0[v7 >> 5] + ((v7 & 0x1F) << 6), v6 = -1),
        *(_BYTE *)(v8 + 36) & 0x7F
     || (v7 == v6 || v7 == -2 ? (v9 = (int)&unk_10067A10) : (v9 = dword_10069CE0[v7 >> 5] + ((v7 & 0x1F) << 6)),
         *(_BYTE *)(v9 + 36) & 0x80))
    || (v10 = v70, !v70) )
    goto LABEL_226;
  result = 0;
  v77 = 0;
  v68 = 0;
  lpMem = 0;
  v12 = *(_BYTE *)v70;
  v75 = 0;
  v80 = v12;
  LOBYTE(v64) = v12;
  if ( (_BYTE)v12 )
  {
    v13 = v58;
    while ( 1 )
    {
      ++v10;
      v70 = v10;
      if ( result < 0 )
        break;
      if ( (unsigned __int8)(v12 - 32) > 0x58u )
        v14 = 0;
      else
        v14 = *((_BYTE *)&off_1005A9C0 + (char)v12) & 0xF;
      v15 = (unsigned int)(unsigned __int8)*(&byte_1005A9E0[9 * v14] + v68) >> 4;
      v5 = v78;
      v68 = v15;
      if ( v15 == 8 )
        goto LABEL_226;
      switch ( v15 )
      {
        case 1u:
          v76 = -1;
          v4 = 0;
          v59 = 0;
          v65 = 0;
          v69 = 0;
          v71 = 0;
          v79 = 0;
          v66 = 0;
          goto LABEL_223;
        case 2u:
          switch ( (char)v12 )
          {
            case 32:
              v4 |= 2u;
              break;
            case 35:
              v4 |= 0x80u;
              break;
            case 43:
              v4 |= 1u;
              break;
            case 45:
              v4 |= 4u;
              break;
            default:
              if ( (char)v12 != 48 )
                goto LABEL_223;
              v4 |= 8u;
              break;
          }
          goto LABEL_33;
        case 3u:
          if ( (_BYTE)v12 == 42 )
          {
            v16 = *(_DWORD *)v78;
            v5 = v78 + 4;
            v78 += 4;
            v69 = v16;
            if ( v16 < 0 )
            {
              v4 |= 4u;
              v79 = v4;
              v69 = -v16;
            }
          }
          else
          {
            v69 *= 10;
            v12 = (char)v12 + v69 - 48;
            v69 = v12;
          }
          goto LABEL_223;
        case 4u:
          v76 = 0;
          goto LABEL_223;
        case 5u:
          if ( (_BYTE)v12 != 42 )
          {
            v76 = (char)v12 + 10 * v76 - 48;
            goto LABEL_222;
          }
          v17 = *(_DWORD *)v78;
          v5 = v78 + 4;
          v78 += 4;
          v76 = v17;
          if ( v17 < 0 )
            v76 = -1;
          goto LABEL_223;
        case 6u:
          if ( (_BYTE)v12 == 73 )
          {
            v18 = *(_BYTE *)v10;
            if ( *(_BYTE *)v10 == 54 && *(_BYTE *)(v10 + 1) == 52 )
            {
              v10 += 2;
              v4 |= 0x8000u;
              goto LABEL_33;
            }
            if ( v18 == 51 && *(_BYTE *)(v10 + 1) == 50 )
            {
              v10 += 2;
              v4 &= 0xFFFF7FFFu;
              goto LABEL_33;
            }
            if ( v18 != 100 && v18 != 105 && v18 != 111 && v18 != 117 && v18 != 120 && v18 != 88 )
            {
              v19 = 0;
              v68 = 0;
LABEL_66:
              v66 = v19;
              if ( sub_10041D47(v4, v78, v12, (int)&v55) )
              {
                sub_100461D5(v4, v5, v64, v72, (int)&v75);
                LOBYTE(v64) = *(_BYTE *)v70++;
                if ( !(_BYTE)v64 )
                  goto LABEL_226;
              }
              sub_100461D5(v4, v5, v64, v72, (int)&v75);
              goto LABEL_222;
            }
          }
          else
          {
            if ( (_BYTE)v12 == 104 )
            {
              v4 |= 0x20u;
              goto LABEL_33;
            }
            if ( (_BYTE)v12 == 108 )
            {
              if ( *(_BYTE *)v10 == 108 )
              {
                ++v10;
                v4 |= 0x1000u;
              }
              else
              {
                v4 |= 0x10u;
              }
              goto LABEL_33;
            }
            if ( (_BYTE)v12 == 119 )
            {
              v4 |= 0x800u;
LABEL_33:
              v79 = v4;
              goto LABEL_223;
            }
          }
          goto LABEL_223;
        case 0u:
          v19 = 0;
          goto LABEL_66;
        case 7u:
          if ( (char)v12 <= 100 )
          {
            if ( (char)v12 == 100 )
            {
LABEL_123:
              v4 |= 0x40u;
              v79 = v4;
              goto LABEL_124;
            }
            if ( (char)v12 <= 83 )
            {
              if ( (char)v12 == 83 )
              {
                if ( !(v4 & 0x830) )
                {
                  v4 |= 0x800u;
                  v79 = v4;
                }
                goto LABEL_84;
              }
              if ( (char)v12 != 65 )
              {
                if ( (char)v12 != 67 )
                {
                  if ( (char)v12 != 69 && (char)v12 != 71 )
                    goto LABEL_193;
                  goto LABEL_77;
                }
                if ( !(v4 & 0x830) )
                {
                  v4 |= 0x800u;
                  v79 = v4;
                }
LABEL_97:
                v5 = v78 + 4;
                v78 += 4;
                if ( v4 & 0x810 )
                {
                  if ( sub_100463F6((int)&v77, &UsedDefaultChar, 512, *(_WORD *)(v5 - 4)) )
                    v65 = 1;
                }
                else
                {
                  UsedDefaultChar = *(_BYTE *)(v5 - 4);
                  v77 = 1;
                }
                v13 = (int)&UsedDefaultChar;
                goto LABEL_193;
              }
LABEL_77:
              LOBYTE(v12) = v12 + 32;
              v59 = 1;
              v80 = v12;
              goto LABEL_78;
            }
            if ( (char)v12 == 88 )
              goto LABEL_147;
            if ( (char)v12 == 90 )
            {
              v23 = *(_DWORD *)v78;
              v5 = v78 + 4;
              v78 += 4;
              if ( v23 )
              {
                v13 = *(_DWORD *)(v23 + 4);
                if ( v13 )
                {
                  v22 = *(_WORD *)v23;
                  if ( v4 & 0x800 )
                  {
                    v22 /= 2;
                    v66 = 1;
                  }
                  else
                  {
                    v12 = 0;
                    v66 = 0;
                  }
                  goto LABEL_192;
                }
              }
              v13 = (int)off_100673A4;
            }
            else
            {
              if ( (char)v12 != 97 )
              {
                if ( (char)v12 != 99 )
                  goto LABEL_193;
                goto LABEL_97;
              }
LABEL_78:
              v20 = v76;
              v4 |= 0x40u;
              v79 = v4;
              v13 = (int)&UsedDefaultChar;
              v67 = 512;
              if ( v76 >= 0 )
              {
                if ( v76 )
                {
                  if ( v76 > 512 )
                  {
                    v20 = 512;
                    v76 = 512;
                  }
                  if ( v20 > 163 )
                  {
                    v27 = v20 + 349;
                    v26 = sub_1002F02B(512, v12, v4, v20 + 349);
                    LOBYTE(v12) = v80;
                    lpMem = (LPVOID)v26;
                    if ( v26 )
                    {
                      v13 = v26;
                      v67 = v27;
                    }
                    else
                    {
                      v76 = 163;
                    }
                    v5 = v78;
                  }
                }
                else
                {
                  if ( (_BYTE)v12 == 103 )
                    v76 = 1;
                }
              }
              else
              {
                v76 = 6;
              }
              v28 = *(_DWORD *)v5;
              v29 = v5 + 8;
              v53 = v28;
              v54 = *(_DWORD *)(v29 - 4);
              v30 = v59;
              v31 = v76;
              v78 = v29;
              v32 = (char)v12;
              v33 = v67;
              v34 = DecodePointer(off_100680BC);
              ((void (__cdecl *)(int *, int, int, int, int, int, char *))v34)(&v53, v13, v33, v32, v31, v30, &v55);
              v5 = v4 & 0x80;
              if ( v4 & 0x80 )
              {
                if ( !v76 )
                {
                  v35 = DecodePointer(off_100680C8);
                  ((void (__cdecl *)(int, char *))v35)(v13, &v55);
                }
              }
              if ( v80 == 103 )
              {
                if ( !(v4 & 0x80) )
                {
                  v36 = DecodePointer(off_100680C4);
                  ((void (__cdecl *)(int, char *))v36)(v13, &v55);
                }
              }
              if ( *(_BYTE *)v13 == 45 )
              {
                v4 |= 0x100u;
                v79 = v4;
                ++v13;
              }
            }
            v22 = sub_1002CFA0(v13);
            v12 = v24;
            goto LABEL_192;
          }
          if ( (char)v12 > 112 )
          {
            if ( (char)v12 != 115 )
            {
              if ( (char)v12 != 117 )
              {
                if ( (char)v12 != 120 )
                  goto LABEL_193;
                v52 = 39;
                goto LABEL_152;
              }
LABEL_124:
              v77 = 10;
              goto LABEL_125;
            }
LABEL_84:
            v12 = 2147483647;
            if ( v76 != -1 )
              v12 = v76;
            v13 = *(_DWORD *)v78;
            v5 = v78 + 4;
            v78 += 4;
            if ( v4 & 0x810 )
            {
              if ( !v13 )
                v13 = (int)off_100673A8;
              v66 = 1;
              for ( i = v13; v12; i += 2 )
              {
                --v12;
                if ( !*(_WORD *)i )
                  break;
              }
              v22 = (i - v13) >> 1;
            }
            else
            {
              if ( !v13 )
                v13 = (int)off_100673A4;
              for ( j = v13; ; ++j )
              {
                if ( v12 )
                {
                  --v12;
                  if ( *(_BYTE *)j )
                    continue;
                }
                break;
              }
              v22 = j - v13;
            }
LABEL_192:
            v77 = v22;
            goto LABEL_193;
          }
          if ( (char)v12 == 112 )
          {
            v76 = 8;
LABEL_147:
            v52 = 7;
LABEL_152:
            v62 = v52;
            v77 = 16;
            if ( (_BYTE)v4 < 0 )
            {
              v73 = 48;
              v74 = v52 + 81;
              v71 = 2;
            }
            goto LABEL_125;
          }
          if ( (char)v12 < 101 )
            goto LABEL_193;
          if ( (char)v12 <= 103 )
            goto LABEL_78;
          if ( (char)v12 == 105 )
            goto LABEL_123;
          if ( (char)v12 != 110 )
          {
            if ( (char)v12 == 111 )
            {
              v77 = 8;
              if ( (_BYTE)v4 < 0 )
              {
                v4 |= 0x200u;
                v79 = v4;
              }
LABEL_125:
              if ( (unsigned __int16)(v4 & 0x8000) || v4 & 0x1000 )
              {
                v12 = *(_DWORD *)v78;
                v78 += 8;
                v5 = *(_DWORD *)(v5 + 4);
                v25 = 0;
                goto LABEL_162;
              }
              v37 = v78 + 4;
              v25 = 0;
              v78 += 4;
              if ( v4 & 0x20 )
              {
                if ( v4 & 0x40 )
                  v38 = *(_WORD *)(v37 - 4);
                else
                  v38 = *(_WORD *)(v37 - 4);
LABEL_160:
                v12 = v38;
                v5 = (unsigned __int64)v38 >> 32;
              }
              else
              {
                if ( v4 & 0x40 )
                {
                  v38 = *(_DWORD *)(v37 - 4);
                  goto LABEL_160;
                }
                v12 = *(_DWORD *)(v37 - 4);
                v5 = 0;
              }
LABEL_162:
              if ( v4 & 0x40 )
              {
                if ( v5 <= v25 )
                {
                  if ( v5 < v25 || v12 < (unsigned int)v25 )
                  {
                    v12 = -v12;
                    v5 = -(v25 + (v12 != 0) + v5);
                    v4 |= 0x100u;
                    v79 = v4;
                  }
                }
              }
              if ( !(v4 & 0x9000) )
                v5 = v25;
              v39 = v76;
              if ( v76 >= 0 )
              {
                v4 &= 0xFFFFFFF7u;
                v79 = v4;
                if ( v76 > 512 )
                  v39 = 512;
              }
              else
              {
                v39 = 1;
              }
              if ( !(v5 | v12) )
                v71 = v25;
              for ( k = &v82; ; --k )
              {
                v76 = v39 - 1;
                if ( v39 <= 0 )
                {
                  if ( !(v5 | v12) )
                    break;
                }
                HIDWORD(v42) = v5;
                LODWORD(v42) = v12;
                v43 = sub_10030C50(v42, v77);
                v41 = v44 + 48;
                v58 = v4;
                v67 = v43;
                v5 = v45;
                if ( v41 > 57 )
                  v41 += v62;
                v39 = v76;
                *k = v41;
                v12 = v67;
              }
              v4 = v79;
              v46 = &v82 - k;
              v13 = (int)(k + 1);
              v77 = v46;
              if ( v79 & 0x200 )
              {
                if ( !v46 || *(_BYTE *)v13 != 48 )
                {
                  --v13;
                  ++v77;
                  *(_BYTE *)v13 = 48;
                }
              }
            }
LABEL_193:
            if ( v65 )
              goto LABEL_220;
            if ( v4 & 0x40 )
            {
              if ( v4 & 0x100 )
              {
                v73 = 45;
                goto LABEL_201;
              }
              if ( v4 & 1 )
              {
                v73 = 43;
                goto LABEL_201;
              }
              if ( v4 & 2 )
              {
                v73 = 32;
LABEL_201:
                v71 = 1;
              }
            }
            v48 = v71;
            v5 = v69 - v77 - v71;
            if ( !(v4 & 0xC) )
            {
              sub_1004621B(v4, 0x20u, v69 - v77 - v71, v72, (int)&v75);
              v48 = v71;
            }
            sub_10046247((unsigned __int8 *)&v73, v48, v72, (int)&v75, (int *)v61);
            if ( v4 & 8 )
            {
              if ( !(v4 & 4) )
                sub_1004621B(v4, 0x30u, v5, v72, (int)&v75);
            }
            v49 = v77;
            if ( v66 && v77 > 0 )
            {
              v12 = v13;
              while ( 1 )
              {
                v67 = v49 - 1;
                v50 = *(_WORD *)v12;
                v58 = v12 + 2;
                if ( sub_100463F6((int)&v60, &v83, 6, v50) )
                  break;
                if ( !v60 )
                  break;
                sub_10046247((unsigned __int8 *)&v83, v60, v72, (int)&v75, (int *)v61);
                v49 = v67;
                v12 = v58;
                if ( !v67 )
                  goto LABEL_216;
              }
              v51 = -1;
              v75 = -1;
            }
            else
            {
              sub_10046247((unsigned __int8 *)v13, v77, v72, (int)&v75, (int *)v61);
LABEL_216:
              v51 = v75;
            }
            if ( v51 >= 0 )
            {
              if ( v4 & 4 )
                sub_1004621B(v4, 0x20u, v5, v72, (int)&v75);
            }
            goto LABEL_220;
          }
          v78 += 4;
          v5 = *(_DWORD *)v5;
          if ( !sub_100462BF() )
            goto LABEL_226;
          if ( v4 & 0x20 )
            *(_WORD *)v5 = v75;
          else
            *(_DWORD *)v5 = v75;
          v65 = 1;
LABEL_220:
          if ( lpMem )
          {
            sub_100282F6(v4, lpMem);
            v12 = 0;
            lpMem = 0;
          }
LABEL_222:
          v10 = v70;
LABEL_223:
          LOBYTE(v12) = *(_BYTE *)v10;
          result = v75;
          v80 = v12;
          LOBYTE(v64) = v12;
          if ( !(_BYTE)v12 )
            goto LABEL_224;
          break;
        default:
          goto LABEL_223;
      }
    }
LABEL_224:
    if ( v68 && v68 != 7 )
    {
LABEL_226:
      *(_DWORD *)sub_1002F144(v4) = 22;
      sub_10036C88(v4, v5);
      result = -1;
    }
  }
  if ( v57 )
    *(_DWORD *)(v56 + 112) &= 0xFFFFFFFDu;
  return result;
}
// 1005A9C0: using guessed type void *off_1005A9C0;
// 10067210: using guessed type int __security_cookie;
// 100673A4: using guessed type char *off_100673A4;
// 100673A8: using guessed type wchar_t *off_100673A8;
// 10069CE0: using guessed type int dword_10069CE0[];

//----- (100461D5) --------------------------------------------------------
int __usercall sub_100461D5<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3, int a4, int a5)
{
  char v5; // sf@3
  signed int v6; // eax@4
  int result; // eax@7

  if ( *(_BYTE *)(a4 + 12) & 0x40 && !*(_DWORD *)(a4 + 8)
    || ((v5 = *(_DWORD *)(a4 + 4) - 1 < 0, --*(_DWORD *)(a4 + 4), v5) ? (v6 = sub_10039E09(a1, a2, a3, a4)) : (**(_BYTE **)a4 = a3, ++*(_DWORD *)a4, v6 = a3),
        v6 != -1) )
  {
    result = a5;
    ++*(_DWORD *)result;
  }
  else
  {
    result = a5;
    *(_DWORD *)a5 = -1;
  }
  return result;
}

//----- (1004621B) --------------------------------------------------------
int __usercall sub_1004621B<eax>(int a1<ebx>, unsigned __int8 a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  int result; // eax@2

  v5 = a3;
  if ( a3 > 0 )
  {
    do
    {
      --v5;
      result = sub_100461D5(a1, a5, a2, a4, a5);
    }
    while ( *(_DWORD *)a5 != -1 && v5 > 0 );
  }
  return result;
}

//----- (10046247) --------------------------------------------------------
int __cdecl sub_10046247(unsigned __int8 *a1, int a2, int a3, int a4, int *a5)
{
  int result; // eax@1
  int *v6; // esi@1
  int v7; // ebx@4
  int v8; // [sp+20h] [bp+18h]@1

  v6 = a5;
  result = *a5;
  v8 = *a5;
  if ( *(_BYTE *)(a3 + 12) & 0x40 && !*(_DWORD *)(a3 + 8) )
  {
    result = a2;
    *(_DWORD *)a4 += a2;
    return result;
  }
  *v6 = 0;
  v7 = a2;
  if ( a2 <= 0 )
    goto LABEL_12;
  result = a4;
  do
  {
    --v7;
    sub_100461D5(v7, a3, *a1, a3, result);
    result = a4;
    ++a1;
    if ( *(_DWORD *)a4 == -1 )
    {
      if ( *v6 != 42 )
        break;
      sub_100461D5(v7, a3, 0x3Fu, a3, a4);
      result = a4;
    }
  }
  while ( v7 > 0 );
  if ( !*v6 )
  {
    result = v8;
LABEL_12:
    *v6 = result;
  }
  return result;
}

//----- (100462BF) --------------------------------------------------------
bool __cdecl sub_100462BF()
{
  return dword_1006A060 == (__security_cookie | 1);
}
// 10067210: using guessed type int __security_cookie;
// 1006A060: using guessed type int dword_1006A060;

//----- (100462D4) --------------------------------------------------------
signed int __cdecl sub_100462D4(int a1, LPSTR UsedDefaultChar, int cbMultiByte, const WCHAR WideCharStr, int a5)
{
  CHAR *v5; // ebx@1
  int v6; // edi@1
  signed int v8; // esi@9
  int v9; // ecx@25
  int v10; // [sp+8h] [bp-10h]@10
  int v11; // [sp+10h] [bp-8h]@17
  char v12; // [sp+14h] [bp-4h]@16

  v5 = UsedDefaultChar;
  v6 = cbMultiByte;
  if ( UsedDefaultChar || !cbMultiByte )
  {
    if ( a1 )
      *(_DWORD *)a1 = -1;
    if ( (unsigned int)v6 > 0x7FFFFFFF )
    {
      v8 = 22;
      *(_DWORD *)sub_1002F144((int)v5) = 22;
      sub_10036C88((int)v5, v6);
      return v8;
    }
    sub_1002E635((int)&v10, (int)v5, v6, a5);
    v8 = 0;
    if ( *(_DWORD *)(v10 + 168) )
    {
      UsedDefaultChar = 0;
      v9 = WideCharToMultiByte(*(_DWORD *)(v10 + 4), 0, &WideCharStr, 1, v5, v6, 0, (LPBOOL)&UsedDefaultChar);
      if ( v9 )
      {
        if ( !UsedDefaultChar )
        {
          if ( a1 )
            *(_DWORD *)a1 = v9;
          goto LABEL_16;
        }
        goto LABEL_15;
      }
      if ( GetLastError() != 122 )
      {
LABEL_15:
        *(_DWORD *)sub_1002F144((int)v5) = 42;
        v8 = *(_DWORD *)sub_1002F144((int)v5);
        goto LABEL_16;
      }
      if ( v5 )
      {
        if ( v6 )
          sub_10030CF0(v5, 0, v6);
      }
    }
    else
    {
      if ( WideCharStr > 0xFFu )
      {
        if ( v5 )
        {
          if ( v6 )
            sub_10030CF0(v5, 0, v6);
        }
        goto LABEL_15;
      }
      if ( !v5 )
      {
LABEL_23:
        if ( a1 )
          *(_DWORD *)a1 = 1;
        goto LABEL_16;
      }
      if ( v6 )
      {
        *v5 = WideCharStr;
        goto LABEL_23;
      }
    }
    v8 = 34;
    *(_DWORD *)sub_1002F144((int)v5) = 34;
    sub_10036C88((int)v5, v6);
LABEL_16:
    if ( v12 )
      *(_DWORD *)(v11 + 112) &= 0xFFFFFFFDu;
    return v8;
  }
  if ( a1 )
    *(_DWORD *)a1 = 0;
  return 0;
}

//----- (100463F6) --------------------------------------------------------
int __cdecl sub_100463F6(int a1, LPSTR UsedDefaultChar, int cbMultiByte, const WCHAR WideCharStr)
{
  return sub_100462D4(a1, UsedDefaultChar, cbMultiByte, WideCharStr, 0);
}

//----- (10046411) --------------------------------------------------------
void __usercall sub_10046411(int a1<ebx>, int a2)
{
  if ( a2 )
  {
    if ( *(void **)(a2 + 12) != off_10066C74 )
      sub_100282F6(a1, *(LPVOID *)(a2 + 12));
    if ( *(void **)(a2 + 16) != off_10066C78 )
      sub_100282F6(a1, *(LPVOID *)(a2 + 16));
    if ( *(void **)(a2 + 20) != off_10066C7C )
      sub_100282F6(a1, *(LPVOID *)(a2 + 20));
    if ( *(void **)(a2 + 24) != off_10066C80 )
      sub_100282F6(a1, *(LPVOID *)(a2 + 24));
    if ( *(void **)(a2 + 28) != off_10066C84 )
      sub_100282F6(a1, *(LPVOID *)(a2 + 28));
    if ( *(void **)(a2 + 32) != off_10066C88 )
      sub_100282F6(a1, *(LPVOID *)(a2 + 32));
    if ( *(void **)(a2 + 36) != off_10066C8C )
      sub_100282F6(a1, *(LPVOID *)(a2 + 36));
    if ( *(void **)(a2 + 56) != off_10066CA0 )
      sub_100282F6(a1, *(LPVOID *)(a2 + 56));
    if ( *(void **)(a2 + 60) != off_10066CA4 )
      sub_100282F6(a1, *(LPVOID *)(a2 + 60));
    if ( *(void **)(a2 + 64) != off_10066CA8 )
      sub_100282F6(a1, *(LPVOID *)(a2 + 64));
    if ( *(void **)(a2 + 68) != off_10066CAC )
      sub_100282F6(a1, *(LPVOID *)(a2 + 68));
    if ( *(void **)(a2 + 72) != off_10066CB0 )
      sub_100282F6(a1, *(LPVOID *)(a2 + 72));
    if ( *(void **)(a2 + 76) != off_10066CB4 )
      sub_100282F6(a1, *(LPVOID *)(a2 + 76));
  }
}
// 10066C74: using guessed type void *off_10066C74;
// 10066C78: using guessed type void *off_10066C78;
// 10066C7C: using guessed type void *off_10066C7C;
// 10066C80: using guessed type void *off_10066C80;
// 10066C84: using guessed type void *off_10066C84;
// 10066C88: using guessed type void *off_10066C88;
// 10066C8C: using guessed type void *off_10066C8C;
// 10066CA0: using guessed type void *off_10066CA0;
// 10066CA4: using guessed type void *off_10066CA4;
// 10066CA8: using guessed type void *off_10066CA8;
// 10066CAC: using guessed type void *off_10066CAC;
// 10066CB0: using guessed type void *off_10066CB0;
// 10066CB4: using guessed type void *off_10066CB4;

//----- (1004650D) --------------------------------------------------------
signed int __cdecl sub_1004650D(int lpMem)
{
  int v1; // ebx@1
  int v2; // edi@3
  void **v3; // esi@3
  int v4; // edx@4
  LPVOID v5; // esi@4
  int v7; // eax@6
  int v8; // edx@6
  void *v9; // edi@6
  int v10; // eax@10
  int v11; // edi@12
  signed int v12; // esi@12
  int v13; // esi@12
  int v14; // esi@12
  int v15; // esi@12
  int v16; // esi@12
  int v17; // esi@12
  int v18; // esi@12
  int v19; // esi@12
  int v20; // esi@12
  int v21; // esi@12
  int v22; // esi@12
  int v23; // esi@12
  int v24; // esi@12
  int v25; // esi@12
  int v26; // esi@12
  int v27; // esi@12
  int v28; // esi@12
  int v29; // esi@12
  int v30; // esi@12
  int v31; // esi@12
  int v32; // edx@14
  char v33; // al@15
  int v34; // esi@22
  int v35; // [sp-4h] [bp-24h]@4
  int v36; // [sp-4h] [bp-24h]@6
  LPVOID v37; // [sp+Ch] [bp-14h]@1
  int v38; // [sp+10h] [bp-10h]@1
  int v39; // [sp+14h] [bp-Ch]@12
  void *v40; // [sp+18h] [bp-8h]@1
  void *v41; // [sp+1Ch] [bp-4h]@3
  int v42; // [sp+28h] [bp+8h]@4

  v1 = lpMem;
  v40 = 0;
  v37 = (LPVOID)lpMem;
  v38 = 0;
  if ( *(_DWORD *)(lpMem + 172) || *(_DWORD *)(lpMem + 176) )
  {
    v5 = sub_1002EFE1(0, lpMem, 1u, 0x50u);
    v42 = (int)v5;
    if ( !v5 )
      return 1;
    v7 = sub_1002F02B(v4, v35, v1, 4);
    v9 = (void *)v7;
    v41 = (void *)v7;
    if ( !v7 )
    {
      sub_100282F6(v1, v5);
      return 1;
    }
    *(_DWORD *)v7 = 0;
    if ( !*(_DWORD *)(v1 + 172) )
    {
      memcpy((void *)v42, &off_10066C68, 0x50u);
LABEL_26:
      v3 = (void **)v42;
      *(_DWORD *)v42 = **(_DWORD **)(v1 + 132);
      v2 = (int)v40;
      *(_DWORD *)(v42 + 4) = *(_DWORD *)(*(_DWORD *)(v1 + 132) + 4);
      *(_DWORD *)(v42 + 8) = *(_DWORD *)(*(_DWORD *)(v1 + 132) + 8);
      *(_DWORD *)(v42 + 48) = *(_DWORD *)(*(_DWORD *)(v1 + 132) + 48);
      *(_DWORD *)(v42 + 52) = *(_DWORD *)(*(_DWORD *)(v1 + 132) + 52);
      *(_DWORD *)v41 = 1;
      if ( v2 )
        *(_DWORD *)v2 = 1;
      goto LABEL_28;
    }
    v10 = sub_1002F02B(v8, v36, v1, 4);
    v40 = (void *)v10;
    if ( !v10 )
    {
      sub_100282F6(v1, v5);
      sub_100282F6(v1, v9);
      return 1;
    }
    *(_DWORD *)v10 = 0;
    v11 = *(_DWORD *)(v1 + 172);
    v12 = sub_1003281D((int)&v37, 1, *(_DWORD *)(v1 + 172), 0x15u, (LPVOID *)v5 + 3);
    v13 = sub_1003281D((int)&v37, 1, v11, 0x14u, (LPVOID *)(v42 + 16)) | v12;
    v14 = sub_1003281D((int)&v37, 1, v11, 0x16u, (LPVOID *)(v42 + 20)) | v13;
    v15 = sub_1003281D((int)&v37, 1, v11, 0x17u, (LPVOID *)(v42 + 24)) | v14;
    v39 = v42 + 28;
    v16 = sub_1003281D((int)&v37, 1, v11, 0x18u, (LPVOID *)(v42 + 28)) | v15;
    v17 = sub_1003281D((int)&v37, 1, v11, 0x50u, (LPVOID *)(v42 + 32)) | v16;
    v18 = sub_1003281D((int)&v37, 1, v11, 0x51u, (LPVOID *)(v42 + 36)) | v17;
    v19 = sub_1003281D((int)&v37, 0, v11, 0x1Au, (LPVOID *)(v42 + 40)) | v18;
    v20 = sub_1003281D((int)&v37, 0, v11, 0x19u, (LPVOID *)(v42 + 41)) | v19;
    v21 = sub_1003281D((int)&v37, 0, v11, 0x54u, (LPVOID *)(v42 + 42)) | v20;
    v22 = sub_1003281D((int)&v37, 0, v11, 0x55u, (LPVOID *)(v42 + 43)) | v21;
    v23 = sub_1003281D((int)&v37, 0, v11, 0x56u, (LPVOID *)(v42 + 44)) | v22;
    v24 = sub_1003281D((int)&v37, 0, v11, 0x57u, (LPVOID *)(v42 + 45)) | v23;
    v25 = sub_1003281D((int)&v37, 0, v11, 0x52u, (LPVOID *)(v42 + 46)) | v24;
    v26 = sub_1003281D((int)&v37, 0, v11, 0x53u, (LPVOID *)(v42 + 47)) | v25;
    v27 = sub_1003281D((int)&v37, 2, v11, 0x15u, (LPVOID *)(v42 + 56)) | v26;
    v28 = sub_1003281D((int)&v37, 2, v11, 0x14u, (LPVOID *)(v42 + 60)) | v27;
    v29 = sub_1003281D((int)&v37, 2, v11, 0x16u, (LPVOID *)(v42 + 64)) | v28;
    v30 = sub_1003281D((int)&v37, 2, v11, 0x17u, (LPVOID *)(v42 + 68)) | v29;
    v31 = sub_1003281D((int)&v37, 2, v11, 0x50u, (LPVOID *)(v42 + 72)) | v30;
    if ( v31 | sub_1003281D((int)&v37, 2, v11, 0x51u, (LPVOID *)(v42 + 76)) )
    {
      sub_10046411(v42, v42);
      sub_100282F6(v42, (LPVOID)v42);
      sub_100282F6(v42, v41);
      sub_100282F6(v42, v40);
      return 1;
    }
    v32 = *(_DWORD *)v39;
    while ( 1 )
    {
      if ( !*(_BYTE *)v32 )
        goto LABEL_26;
      v33 = *(_BYTE *)v32;
      if ( *(_BYTE *)v32 >= 48 )
      {
        if ( v33 <= 57 )
          break;
      }
      if ( v33 == 59 )
      {
        v34 = v32;
        do
        {
          *(_BYTE *)v34 = *(_BYTE *)(v34 + 1);
          ++v34;
        }
        while ( *(_BYTE *)v34 );
      }
      else
      {
LABEL_18:
        ++v32;
      }
    }
    *(_BYTE *)v32 = v33 - 48;
    goto LABEL_18;
  }
  v2 = 0;
  v41 = 0;
  v3 = &off_10066C68;
LABEL_28:
  if ( *(_DWORD *)(v1 + 128) )
    InterlockedDecrement(*(volatile LONG **)(v1 + 128));
  if ( *(_DWORD *)(v1 + 120) )
  {
    if ( !InterlockedDecrement(*(volatile LONG **)(v1 + 120)) )
    {
      sub_100282F6(v1, *(LPVOID *)(v1 + 132));
      sub_100282F6(v1, *(LPVOID *)(v1 + 120));
    }
  }
  *(_DWORD *)(v1 + 120) = v41;
  *(_DWORD *)(v1 + 128) = v2;
  *(_DWORD *)(v1 + 132) = v3;
  return 0;
}
// 10066C68: using guessed type void *off_10066C68;

//----- (100468AF) --------------------------------------------------------
void __usercall sub_100468AF(int a1<ebx>, int a2)
{
  if ( a2 )
  {
    if ( *(void **)a2 != off_10066C68 )
      sub_100282F6(a1, *(LPVOID *)a2);
    if ( *(void **)(a2 + 4) != off_10066C6C )
      sub_100282F6(a1, *(LPVOID *)(a2 + 4));
    if ( *(void **)(a2 + 8) != off_10066C70 )
      sub_100282F6(a1, *(LPVOID *)(a2 + 8));
    if ( *(void **)(a2 + 48) != off_10066C98 )
      sub_100282F6(a1, *(LPVOID *)(a2 + 48));
    if ( *(void **)(a2 + 52) != off_10066C9C )
      sub_100282F6(a1, *(LPVOID *)(a2 + 52));
  }
}
// 10066C68: using guessed type void *off_10066C68;
// 10066C6C: using guessed type void *off_10066C6C;
// 10066C70: using guessed type void *off_10066C70;
// 10066C98: using guessed type void *off_10066C98;
// 10066C9C: using guessed type void *off_10066C9C;

//----- (10046916) --------------------------------------------------------
int __thiscall sub_10046916(int this, int lpMem)
{
  int v2; // ebx@1
  int v3; // edi@3
  void **v4; // esi@3
  void *v5; // eax@4
  int v6; // edx@4
  int v8; // eax@6
  int v9; // edx@6
  int v10; // eax@9
  int v11; // edi@10
  signed int v12; // esi@10
  int v13; // esi@10
  int v14; // esi@10
  int v15; // esi@10
  int v16; // edx@13
  char v17; // al@14
  int v18; // esi@30
  int v19; // [sp-4h] [bp-24h]@6
  LPVOID v20; // [sp+Ch] [bp-14h]@1
  int v21; // [sp+10h] [bp-10h]@1
  int v22; // [sp+14h] [bp-Ch]@9
  int v23; // [sp+18h] [bp-8h]@4
  void *v24; // [sp+1Ch] [bp-4h]@3
  int v25; // [sp+28h] [bp+8h]@4

  v2 = lpMem;
  v20 = (LPVOID)lpMem;
  v21 = 0;
  if ( !*(_DWORD *)(lpMem + 176) && !*(_DWORD *)(lpMem + 172) )
  {
    v3 = 0;
    v24 = 0;
    v4 = &off_10066C68;
    goto LABEL_22;
  }
  v23 = 1;
  v5 = sub_1002EFE1(this, lpMem, 1u, 0x50u);
  v25 = (int)v5;
  if ( !v5 )
    return 1;
  memcpy(v5, *(const void **)(v2 + 132), 0x50u);
  v8 = sub_1002F02B(v6, 0, v2, 4);
  v24 = (void *)v8;
  if ( !v8 )
  {
    sub_100282F6(v2, (LPVOID)v25);
    return 1;
  }
  v3 = 0;
  *(_DWORD *)v8 = 0;
  if ( !*(_DWORD *)(v2 + 176) )
  {
    v4 = (void **)v25;
    *(_DWORD *)v25 = off_10066C68;
    *(_DWORD *)(v25 + 4) = off_10066C6C;
    *(_DWORD *)(v25 + 8) = off_10066C70;
    *(_DWORD *)(v25 + 48) = off_10066C98;
    *(_DWORD *)(v25 + 52) = off_10066C9C;
    goto LABEL_20;
  }
  v10 = sub_1002F02B(v9, v19, v2, 4);
  v22 = v10;
  if ( !v10 )
    goto LABEL_12;
  *(_DWORD *)v10 = 0;
  v11 = *(_DWORD *)(v2 + 176);
  v12 = sub_1003281D((int)&v20, 1, *(_DWORD *)(v2 + 176), 0xEu, (LPVOID *)v25);
  v13 = sub_1003281D((int)&v20, 1, v11, 0xFu, (LPVOID *)(v25 + 4)) | v12;
  v23 = v25 + 8;
  v14 = sub_1003281D((int)&v20, 1, v11, 0x10u, (LPVOID *)(v25 + 8)) | v13;
  v15 = sub_1003281D((int)&v20, 2, v11, 0xEu, (LPVOID *)(v25 + 48)) | v14;
  if ( v15 | sub_1003281D((int)&v20, 2, v11, 0xFu, (LPVOID *)(v25 + 52)) )
  {
    sub_100468AF(v2, v25);
    v23 = -1;
LABEL_12:
    sub_100282F6(v2, (LPVOID)v25);
    sub_100282F6(v2, v24);
    return v23;
  }
  v16 = *(_DWORD *)v23;
  while ( *(_BYTE *)v16 )
  {
    v17 = *(_BYTE *)v16;
    if ( *(_BYTE *)v16 >= 48 && v17 <= 57 )
    {
      *(_BYTE *)v16 = v17 - 48;
      goto LABEL_17;
    }
    if ( v17 == 59 )
    {
      v18 = v16;
      do
      {
        *(_BYTE *)v18 = *(_BYTE *)(v18 + 1);
        ++v18;
      }
      while ( *(_BYTE *)v18 );
    }
    else
    {
LABEL_17:
      ++v16;
    }
  }
  v3 = v22;
  v4 = (void **)v25;
LABEL_20:
  *(_DWORD *)v24 = 1;
  if ( v3 )
    *(_DWORD *)v3 = 1;
LABEL_22:
  if ( *(_DWORD *)(v2 + 124) )
    InterlockedDecrement(*(volatile LONG **)(v2 + 124));
  if ( *(_DWORD *)(v2 + 120) )
  {
    if ( !InterlockedDecrement(*(volatile LONG **)(v2 + 120)) )
    {
      sub_100282F6(v2, *(LPVOID *)(v2 + 120));
      sub_100282F6(v2, *(LPVOID *)(v2 + 132));
    }
  }
  *(_DWORD *)(v2 + 120) = v24;
  *(_DWORD *)(v2 + 124) = v3;
  *(_DWORD *)(v2 + 132) = v4;
  return 0;
}
// 10066C68: using guessed type void *off_10066C68;
// 10066C6C: using guessed type void *off_10066C6C;
// 10066C70: using guessed type void *off_10066C70;
// 10066C98: using guessed type void *off_10066C98;
// 10066C9C: using guessed type void *off_10066C9C;

//----- (10046B1E) --------------------------------------------------------
void __usercall sub_10046B1E(int a1<ebx>, int a2)
{
  if ( a2 )
  {
    sub_100282F6(a1, *(LPVOID *)(a2 + 4));
    sub_100282F6(a1, *(LPVOID *)(a2 + 8));
    sub_100282F6(a1, *(LPVOID *)(a2 + 12));
    sub_100282F6(a1, *(LPVOID *)(a2 + 16));
    sub_100282F6(a1, *(LPVOID *)(a2 + 20));
    sub_100282F6(a1, *(LPVOID *)(a2 + 24));
    sub_100282F6(a1, *(LPVOID *)a2);
    sub_100282F6(a1, *(LPVOID *)(a2 + 32));
    sub_100282F6(a1, *(LPVOID *)(a2 + 36));
    sub_100282F6(a1, *(LPVOID *)(a2 + 40));
    sub_100282F6(a1, *(LPVOID *)(a2 + 44));
    sub_100282F6(a1, *(LPVOID *)(a2 + 48));
    sub_100282F6(a1, *(LPVOID *)(a2 + 52));
    sub_100282F6(a1, *(LPVOID *)(a2 + 28));
    sub_100282F6(a1, *(LPVOID *)(a2 + 56));
    sub_100282F6(a1, *(LPVOID *)(a2 + 60));
    sub_100282F6(a1, *(LPVOID *)(a2 + 64));
    sub_100282F6(a1, *(LPVOID *)(a2 + 68));
    sub_100282F6(a1, *(LPVOID *)(a2 + 72));
    sub_100282F6(a1, *(LPVOID *)(a2 + 76));
    sub_100282F6(a1, *(LPVOID *)(a2 + 80));
    sub_100282F6(a1, *(LPVOID *)(a2 + 84));
    sub_100282F6(a1, *(LPVOID *)(a2 + 88));
    sub_100282F6(a1, *(LPVOID *)(a2 + 92));
    sub_100282F6(a1, *(LPVOID *)(a2 + 96));
    sub_100282F6(a1, *(LPVOID *)(a2 + 100));
    sub_100282F6(a1, *(LPVOID *)(a2 + 104));
    sub_100282F6(a1, *(LPVOID *)(a2 + 108));
    sub_100282F6(a1, *(LPVOID *)(a2 + 112));
    sub_100282F6(a1, *(LPVOID *)(a2 + 116));
    sub_100282F6(a1, *(LPVOID *)(a2 + 120));
    sub_100282F6(a1, *(LPVOID *)(a2 + 124));
    sub_100282F6(a1, *(LPVOID *)(a2 + 128));
    sub_100282F6(a1, *(LPVOID *)(a2 + 132));
    sub_100282F6(a1, *(LPVOID *)(a2 + 136));
    sub_100282F6(a1, *(LPVOID *)(a2 + 140));
    sub_100282F6(a1, *(LPVOID *)(a2 + 144));
    sub_100282F6(a1, *(LPVOID *)(a2 + 148));
    sub_100282F6(a1, *(LPVOID *)(a2 + 152));
    sub_100282F6(a1, *(LPVOID *)(a2 + 156));
    sub_100282F6(a1, *(LPVOID *)(a2 + 160));
    sub_100282F6(a1, *(LPVOID *)(a2 + 164));
    sub_100282F6(a1, *(LPVOID *)(a2 + 168));
    sub_100282F6(a1, *(LPVOID *)(a2 + 184));
    sub_100282F6(a1, *(LPVOID *)(a2 + 188));
    sub_100282F6(a1, *(LPVOID *)(a2 + 192));
    sub_100282F6(a1, *(LPVOID *)(a2 + 196));
    sub_100282F6(a1, *(LPVOID *)(a2 + 200));
    sub_100282F6(a1, *(LPVOID *)(a2 + 204));
    sub_100282F6(a1, *(LPVOID *)(a2 + 180));
    sub_100282F6(a1, *(LPVOID *)(a2 + 212));
    sub_100282F6(a1, *(LPVOID *)(a2 + 216));
    sub_100282F6(a1, *(LPVOID *)(a2 + 220));
    sub_100282F6(a1, *(LPVOID *)(a2 + 224));
    sub_100282F6(a1, *(LPVOID *)(a2 + 228));
    sub_100282F6(a1, *(LPVOID *)(a2 + 232));
    sub_100282F6(a1, *(LPVOID *)(a2 + 208));
    sub_100282F6(a1, *(LPVOID *)(a2 + 236));
    sub_100282F6(a1, *(LPVOID *)(a2 + 240));
    sub_100282F6(a1, *(LPVOID *)(a2 + 244));
    sub_100282F6(a1, *(LPVOID *)(a2 + 248));
    sub_100282F6(a1, *(LPVOID *)(a2 + 252));
    sub_100282F6(a1, *(LPVOID *)(a2 + 256));
    sub_100282F6(a1, *(LPVOID *)(a2 + 260));
    sub_100282F6(a1, *(LPVOID *)(a2 + 264));
    sub_100282F6(a1, *(LPVOID *)(a2 + 268));
    sub_100282F6(a1, *(LPVOID *)(a2 + 272));
    sub_100282F6(a1, *(LPVOID *)(a2 + 276));
    sub_100282F6(a1, *(LPVOID *)(a2 + 280));
    sub_100282F6(a1, *(LPVOID *)(a2 + 284));
    sub_100282F6(a1, *(LPVOID *)(a2 + 288));
    sub_100282F6(a1, *(LPVOID *)(a2 + 292));
    sub_100282F6(a1, *(LPVOID *)(a2 + 296));
    sub_100282F6(a1, *(LPVOID *)(a2 + 300));
    sub_100282F6(a1, *(LPVOID *)(a2 + 304));
    sub_100282F6(a1, *(LPVOID *)(a2 + 308));
    sub_100282F6(a1, *(LPVOID *)(a2 + 312));
    sub_100282F6(a1, *(LPVOID *)(a2 + 316));
    sub_100282F6(a1, *(LPVOID *)(a2 + 320));
    sub_100282F6(a1, *(LPVOID *)(a2 + 324));
    sub_100282F6(a1, *(LPVOID *)(a2 + 328));
    sub_100282F6(a1, *(LPVOID *)(a2 + 332));
    sub_100282F6(a1, *(LPVOID *)(a2 + 336));
    sub_100282F6(a1, *(LPVOID *)(a2 + 340));
    sub_100282F6(a1, *(LPVOID *)(a2 + 344));
    sub_100282F6(a1, *(LPVOID *)(a2 + 348));
    sub_100282F6(a1, *(LPVOID *)(a2 + 352));
  }
}

//----- (10046E9E) --------------------------------------------------------
signed int __thiscall sub_10046E9E(int this, int a2)
{
  int v2; // eax@2
  int v3; // esi@2
  int v5; // eax@8

  if ( *(_DWORD *)(a2 + 180) )
  {
    v2 = (int)sub_1002EFE1(this, 1, 1u, 0x164u);
    v3 = v2;
    if ( !v2 )
      return 1;
    if ( sub_10046F1A(v2, a2) )
    {
      sub_10046B1E(1, v3);
      sub_100282F6(1, (LPVOID)v3);
      return 1;
    }
    *(_DWORD *)(v3 + 176) = 1;
  }
  else
  {
    v3 = (int)&off_100673B0;
  }
  v5 = *(_DWORD *)(a2 + 156);
  if ( (void **)v5 != &off_100673B0 )
    InterlockedDecrement((volatile LONG *)(v5 + 176));
  *(_DWORD *)(a2 + 156) = v3;
  return 0;
}
// 100673B0: using guessed type void *off_100673B0;

//----- (10046F1A) --------------------------------------------------------
int __cdecl sub_10046F1A(int a1, int a2)
{
  int v2; // ebx@1
  int result; // eax@2
  int v4; // eax@3
  signed int v5; // esi@3
  int v6; // esi@3
  int v7; // esi@3
  int v8; // esi@3
  int v9; // esi@3
  int v10; // esi@3
  int v11; // esi@3
  int v12; // esi@3
  int v13; // esi@3
  int v14; // esi@3
  int v15; // esi@3
  int v16; // esi@3
  int v17; // esi@3
  int v18; // esi@3
  int v19; // esi@3
  int v20; // esi@3
  int v21; // esi@3
  int v22; // esi@3
  int v23; // esi@3
  int v24; // esi@3
  int v25; // esi@3
  int v26; // esi@3
  int v27; // esi@3
  int v28; // esi@3
  int v29; // esi@3
  int v30; // esi@3
  int v31; // esi@3
  int v32; // esi@3
  int v33; // esi@3
  int v34; // esi@3
  int v35; // esi@3
  int v36; // esi@3
  int v37; // esi@3
  int v38; // esi@3
  int v39; // esi@3
  int v40; // esi@3
  int v41; // esi@3
  int v42; // esi@3
  int v43; // esi@3
  int v44; // esi@3
  int v45; // esi@3
  int v46; // esi@3
  int v47; // esi@3
  int v48; // esi@3
  int v49; // esi@3
  int v50; // esi@3
  int v51; // esi@3
  int v52; // esi@3
  int v53; // esi@3
  int v54; // esi@3
  int v55; // esi@3
  int v56; // esi@3
  int v57; // esi@3
  int v58; // esi@3
  int v59; // esi@3
  int v60; // esi@3
  int v61; // esi@3
  int v62; // esi@3
  int v63; // esi@3
  int v64; // esi@3
  int v65; // esi@3
  int v66; // esi@3
  int v67; // esi@3
  int v68; // esi@3
  int v69; // esi@3
  int v70; // esi@3
  int v71; // esi@3
  int v72; // esi@3
  int v73; // esi@3
  int v74; // esi@3
  int v75; // esi@3
  int v76; // esi@3
  int v77; // esi@3
  int v78; // esi@3
  int v79; // esi@3
  int v80; // esi@3
  int v81; // esi@3
  int v82; // esi@3
  int v83; // esi@3
  int v84; // esi@3
  int v85; // esi@3
  int v86; // esi@3
  int v87; // esi@3
  int v88; // esi@3
  int v89; // esi@3
  int v90; // esi@3
  int v91; // [sp+Ch] [bp-8h]@3
  int v92; // [sp+10h] [bp-4h]@3

  v2 = *(_DWORD *)(a2 + 180);
  if ( a1 )
  {
    v4 = sub_1003E5DD(*(_DWORD *)(a2 + 180));
    v92 = 0;
    *(_DWORD *)(a1 + 352) = v4;
    v91 = a2;
    v5 = sub_1003281D((int)&v91, 1, v2, 0x31u, (LPVOID *)(a1 + 4));
    v6 = sub_1003281D((int)&v91, 1, v2, 0x32u, (LPVOID *)(a1 + 8)) | v5;
    v7 = sub_1003281D((int)&v91, 1, v2, 0x33u, (LPVOID *)(a1 + 12)) | v6;
    v8 = sub_1003281D((int)&v91, 1, v2, 0x34u, (LPVOID *)(a1 + 16)) | v7;
    v9 = sub_1003281D((int)&v91, 1, v2, 0x35u, (LPVOID *)(a1 + 20)) | v8;
    v10 = sub_1003281D((int)&v91, 1, v2, 0x36u, (LPVOID *)(a1 + 24)) | v9;
    v11 = sub_1003281D((int)&v91, 1, v2, 0x37u, (LPVOID *)a1) | v10;
    v12 = sub_1003281D((int)&v91, 1, v2, 0x2Au, (LPVOID *)(a1 + 32)) | v11;
    v13 = sub_1003281D((int)&v91, 1, v2, 0x2Bu, (LPVOID *)(a1 + 36)) | v12;
    v14 = sub_1003281D((int)&v91, 1, v2, 0x2Cu, (LPVOID *)(a1 + 40)) | v13;
    v15 = sub_1003281D((int)&v91, 1, v2, 0x2Du, (LPVOID *)(a1 + 44)) | v14;
    v16 = sub_1003281D((int)&v91, 1, v2, 0x2Eu, (LPVOID *)(a1 + 48)) | v15;
    v17 = sub_1003281D((int)&v91, 1, v2, 0x2Fu, (LPVOID *)(a1 + 52)) | v16;
    v18 = sub_1003281D((int)&v91, 1, v2, 0x30u, (LPVOID *)(a1 + 28)) | v17;
    v19 = sub_1003281D((int)&v91, 1, v2, 0x44u, (LPVOID *)(a1 + 56)) | v18;
    v20 = sub_1003281D((int)&v91, 1, v2, 0x45u, (LPVOID *)(a1 + 60)) | v19;
    v21 = sub_1003281D((int)&v91, 1, v2, 0x46u, (LPVOID *)(a1 + 64)) | v20;
    v22 = sub_1003281D((int)&v91, 1, v2, 0x47u, (LPVOID *)(a1 + 68)) | v21;
    v23 = sub_1003281D((int)&v91, 1, v2, 0x48u, (LPVOID *)(a1 + 72)) | v22;
    v24 = sub_1003281D((int)&v91, 1, v2, 0x49u, (LPVOID *)(a1 + 76)) | v23;
    v25 = sub_1003281D((int)&v91, 1, v2, 0x4Au, (LPVOID *)(a1 + 80)) | v24;
    v26 = sub_1003281D((int)&v91, 1, v2, 0x4Bu, (LPVOID *)(a1 + 84)) | v25;
    v27 = sub_1003281D((int)&v91, 1, v2, 0x4Cu, (LPVOID *)(a1 + 88)) | v26;
    v28 = sub_1003281D((int)&v91, 1, v2, 0x4Du, (LPVOID *)(a1 + 92)) | v27;
    v29 = sub_1003281D((int)&v91, 1, v2, 0x4Eu, (LPVOID *)(a1 + 96)) | v28;
    v30 = sub_1003281D((int)&v91, 1, v2, 0x4Fu, (LPVOID *)(a1 + 100)) | v29;
    v31 = sub_1003281D((int)&v91, 1, v2, 0x38u, (LPVOID *)(a1 + 104)) | v30;
    v32 = sub_1003281D((int)&v91, 1, v2, 0x39u, (LPVOID *)(a1 + 108)) | v31;
    v33 = sub_1003281D((int)&v91, 1, v2, 0x3Au, (LPVOID *)(a1 + 112)) | v32;
    v34 = sub_1003281D((int)&v91, 1, v2, 0x3Bu, (LPVOID *)(a1 + 116)) | v33;
    v35 = sub_1003281D((int)&v91, 1, v2, 0x3Cu, (LPVOID *)(a1 + 120)) | v34;
    v36 = sub_1003281D((int)&v91, 1, v2, 0x3Du, (LPVOID *)(a1 + 124)) | v35;
    v37 = sub_1003281D((int)&v91, 1, v2, 0x3Eu, (LPVOID *)(a1 + 128)) | v36;
    v38 = sub_1003281D((int)&v91, 1, v2, 0x3Fu, (LPVOID *)(a1 + 132)) | v37;
    v39 = sub_1003281D((int)&v91, 1, v2, 0x40u, (LPVOID *)(a1 + 136)) | v38;
    v40 = sub_1003281D((int)&v91, 1, v2, 0x41u, (LPVOID *)(a1 + 140)) | v39;
    v41 = sub_1003281D((int)&v91, 1, v2, 0x42u, (LPVOID *)(a1 + 144)) | v40;
    v42 = sub_1003281D((int)&v91, 1, v2, 0x43u, (LPVOID *)(a1 + 148)) | v41;
    v43 = sub_1003281D((int)&v91, 1, v2, 0x28u, (LPVOID *)(a1 + 152)) | v42;
    v44 = sub_1003281D((int)&v91, 1, v2, 0x29u, (LPVOID *)(a1 + 156)) | v43;
    v45 = sub_1003281D((int)&v91, 1, v2, 0x1Fu, (LPVOID *)(a1 + 160)) | v44;
    v46 = sub_1003281D((int)&v91, 1, v2, 0x20u, (LPVOID *)(a1 + 164)) | v45;
    v47 = sub_1003281D((int)&v91, 1, v2, 0x1003u, (LPVOID *)(a1 + 168)) | v46;
    v48 = sub_1003281D((int)&v91, 0, v2, 0x1009u, (LPVOID *)(a1 + 172)) | v47;
    v49 = sub_1003281D((int)&v91, 2, v2, 0x31u, (LPVOID *)(a1 + 184)) | v48;
    v50 = sub_1003281D((int)&v91, 2, v2, 0x32u, (LPVOID *)(a1 + 188)) | v49;
    v51 = sub_1003281D((int)&v91, 2, v2, 0x33u, (LPVOID *)(a1 + 192)) | v50;
    v52 = sub_1003281D((int)&v91, 2, v2, 0x34u, (LPVOID *)(a1 + 196)) | v51;
    v53 = sub_1003281D((int)&v91, 2, v2, 0x35u, (LPVOID *)(a1 + 200)) | v52;
    v54 = sub_1003281D((int)&v91, 2, v2, 0x36u, (LPVOID *)(a1 + 204)) | v53;
    v55 = sub_1003281D((int)&v91, 2, v2, 0x37u, (LPVOID *)(a1 + 180)) | v54;
    v56 = sub_1003281D((int)&v91, 2, v2, 0x2Au, (LPVOID *)(a1 + 212)) | v55;
    v57 = sub_1003281D((int)&v91, 2, v2, 0x2Bu, (LPVOID *)(a1 + 216)) | v56;
    v58 = sub_1003281D((int)&v91, 2, v2, 0x2Cu, (LPVOID *)(a1 + 220)) | v57;
    v59 = sub_1003281D((int)&v91, 2, v2, 0x2Du, (LPVOID *)(a1 + 224)) | v58;
    v60 = sub_1003281D((int)&v91, 2, v2, 0x2Eu, (LPVOID *)(a1 + 228)) | v59;
    v61 = sub_1003281D((int)&v91, 2, v2, 0x2Fu, (LPVOID *)(a1 + 232)) | v60;
    v62 = sub_1003281D((int)&v91, 2, v2, 0x30u, (LPVOID *)(a1 + 208)) | v61;
    v63 = sub_1003281D((int)&v91, 2, v2, 0x44u, (LPVOID *)(a1 + 236)) | v62;
    v64 = sub_1003281D((int)&v91, 2, v2, 0x45u, (LPVOID *)(a1 + 240)) | v63;
    v65 = sub_1003281D((int)&v91, 2, v2, 0x46u, (LPVOID *)(a1 + 244)) | v64;
    v66 = sub_1003281D((int)&v91, 2, v2, 0x47u, (LPVOID *)(a1 + 248)) | v65;
    v67 = sub_1003281D((int)&v91, 2, v2, 0x48u, (LPVOID *)(a1 + 252)) | v66;
    v68 = sub_1003281D((int)&v91, 2, v2, 0x49u, (LPVOID *)(a1 + 256)) | v67;
    v69 = sub_1003281D((int)&v91, 2, v2, 0x4Au, (LPVOID *)(a1 + 260)) | v68;
    v70 = sub_1003281D((int)&v91, 2, v2, 0x4Bu, (LPVOID *)(a1 + 264)) | v69;
    v71 = sub_1003281D((int)&v91, 2, v2, 0x4Cu, (LPVOID *)(a1 + 268)) | v70;
    v72 = sub_1003281D((int)&v91, 2, v2, 0x4Du, (LPVOID *)(a1 + 272)) | v71;
    v73 = sub_1003281D((int)&v91, 2, v2, 0x4Eu, (LPVOID *)(a1 + 276)) | v72;
    v74 = sub_1003281D((int)&v91, 2, v2, 0x4Fu, (LPVOID *)(a1 + 280)) | v73;
    v75 = sub_1003281D((int)&v91, 2, v2, 0x38u, (LPVOID *)(a1 + 284)) | v74;
    v76 = sub_1003281D((int)&v91, 2, v2, 0x39u, (LPVOID *)(a1 + 288)) | v75;
    v77 = sub_1003281D((int)&v91, 2, v2, 0x3Au, (LPVOID *)(a1 + 292)) | v76;
    v78 = sub_1003281D((int)&v91, 2, v2, 0x3Bu, (LPVOID *)(a1 + 296)) | v77;
    v79 = sub_1003281D((int)&v91, 2, v2, 0x3Cu, (LPVOID *)(a1 + 300)) | v78;
    v80 = sub_1003281D((int)&v91, 2, v2, 0x3Du, (LPVOID *)(a1 + 304)) | v79;
    v81 = sub_1003281D((int)&v91, 2, v2, 0x3Eu, (LPVOID *)(a1 + 308)) | v80;
    v82 = sub_1003281D((int)&v91, 2, v2, 0x3Fu, (LPVOID *)(a1 + 312)) | v81;
    v83 = sub_1003281D((int)&v91, 2, v2, 0x40u, (LPVOID *)(a1 + 316)) | v82;
    v84 = sub_1003281D((int)&v91, 2, v2, 0x41u, (LPVOID *)(a1 + 320)) | v83;
    v85 = sub_1003281D((int)&v91, 2, v2, 0x42u, (LPVOID *)(a1 + 324)) | v84;
    v86 = sub_1003281D((int)&v91, 2, v2, 0x43u, (LPVOID *)(a1 + 328)) | v85;
    v87 = sub_1003281D((int)&v91, 2, v2, 0x28u, (LPVOID *)(a1 + 332)) | v86;
    v88 = sub_1003281D((int)&v91, 2, v2, 0x29u, (LPVOID *)(a1 + 336)) | v87;
    v89 = sub_1003281D((int)&v91, 2, v2, 0x1Fu, (LPVOID *)(a1 + 340)) | v88;
    v90 = sub_1003281D((int)&v91, 2, v2, 0x20u, (LPVOID *)(a1 + 344)) | v89;
    result = v90 | sub_1003281D((int)&v91, 2, v2, 0x1003u, (LPVOID *)(a1 + 348));
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1004770B) --------------------------------------------------------
int __thiscall sub_1004770B(int this, int a2)
{
  int v3; // edi@1

  v3 = this;
  *(_DWORD *)this = 1;
  *(_DWORD *)(this + 4) = sub_100349ED(a2 + 4);
  *(_DWORD *)(v3 + 8) = a2;
  return v3;
}

//----- (10047731) --------------------------------------------------------
unsigned int __thiscall sub_10047731(int this, int a2)
{
  unsigned int result; // eax@3
  unsigned int v3; // edx@4
  _DWORD *v6; // [sp+0h] [bp+0h]@4

  if ( *(_DWORD *)((a2 << 7) + *(_DWORD *)(this + 92)) <= 1u )
  {
    result = 0;
  }
  else
  {
    v6 = &v6;
    v3 = *(_DWORD *)((a2 << 7) + *(_DWORD *)(this + 92));
    _EDI = 1;
    if ( v3 <= 1 )
      goto LABEL_10;
    _ECX = (a2 << 7) + *(_DWORD *)(this + 92);
    __asm { lock cmpxchg [ecx], edi }
    if ( v3 != v3 )
LABEL_10:
      result = 0;
    else
      result = v3;
  }
  return result;
}

//----- (10047782) --------------------------------------------------------
int __usercall sub_10047782<eax>(int a1<ecx>, int a2<edi>)
{
  int v2; // esi@1
  int v4; // eax@8
  char v5; // [sp-4h] [bp-8h]@6

  v2 = a1;
  if ( *(_BYTE *)a1 & 0x18 && !sub_10047D8D(a1, a2) )
    return 0;
  if ( *(_DWORD *)v2 == 2 )
  {
    v5 = 0;
LABEL_8:
    v4 = sub_10038404(*(void **)(v2 + 4), *(_DWORD *)(v2 + 8), v5);
    *(_DWORD *)(v2 + 8) = v4;
    if ( v4 )
    {
      *(_BYTE *)(v4 + 179) |= 1u;
      *(_DWORD *)v2 = 1;
    }
    return *(_DWORD *)(v2 + 8);
  }
  if ( *(_DWORD *)v2 == 4 )
  {
    v5 = 1;
    goto LABEL_8;
  }
  return *(_DWORD *)(v2 + 8);
}

//----- (100477CB) --------------------------------------------------------
int __thiscall sub_100477CB(int this, int a2)
{
  int v2; // esi@1
  int result; // eax@2
  char v4; // [sp-4h] [bp-Ch]@3

  v2 = this;
  if ( *(_DWORD *)this == 2 )
  {
    v4 = 0;
    goto LABEL_5;
  }
  result = *(_DWORD *)this - 4;
  if ( *(_DWORD *)this == 4 )
  {
    v4 = 1;
LABEL_5:
    result = sub_1003C55C(a2, *(_DWORD *)(this + 4), *(_DWORD *)(this + 8), v4);
  }
  *(_DWORD *)(v2 + 8) = a2;
  *(_DWORD *)v2 = 1;
  return result;
}

//----- (10047801) --------------------------------------------------------
char __thiscall sub_10047801(int this, int a2)
{
  char result; // al@1

  result = (unsigned int)(a2 - *(_DWORD *)(this + 20)) > 0x3E8;
  if ( result )
    *(_DWORD *)(this + 20) = a2;
  return result;
}

//----- (1004781F) --------------------------------------------------------
char __thiscall sub_1004781F(int this, int a2, int a3, char a4)
{
  int v4; // ebx@1
  int ebp0; // ebp@0
  int v6; // eax@3
  int v7; // eax@6
  int v9; // eax@10
  int v10; // eax@15
  char v11; // [sp+Ch] [bp-18h]@15
  char v12; // [sp+18h] [bp-Ch]@6

  v4 = this;
  if ( !a4 )
  {
    if ( *(_DWORD *)(this + 12) < 0x65u )
    {
      if ( *(_DWORD *)(a3 + 16) - *(_DWORD *)(a3 + 12) <= 0 )
        v9 = 0;
      else
        v9 = sub_1003AF1C(a3 + 12);
    }
    else
    {
      if ( *(_DWORD *)(this + 12) >= 0x7Fu )
      {
LABEL_16:
        *(_DWORD *)(v4 + 12) = 0;
        return 0;
      }
      v9 = sub_10048B6E(a3, ebp0);
    }
    if ( v9 )
    {
      v10 = sub_1004770B((int)&v11, v9);
      *(_DWORD *)a2 = *(_DWORD *)v10;
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(v10 + 4);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v10 + 8);
      ++*(_DWORD *)(v4 + 12);
      return 1;
    }
    goto LABEL_16;
  }
  if ( *(_DWORD *)(a3 + 16) - *(_DWORD *)(a3 + 12) <= 0 )
    v6 = 0;
  else
    v6 = sub_1003AF1C(a3 + 12);
  if ( v6 )
  {
    v7 = sub_1004770B((int)&v12, v6);
    *(_DWORD *)a2 = *(_DWORD *)v7;
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(v7 + 4);
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(v7 + 8);
    return 1;
  }
  return 0;
}

//----- (100478B6) --------------------------------------------------------
int __thiscall sub_100478B6(int this, int a2, int a3)
{
  signed int v3; // edi@1
  signed int i; // esi@1
  int v5; // edx@2
  int result; // eax@3

  v3 = *(_DWORD *)(this + 44);
  for ( i = 0; i < v3; ++i )
  {
    v5 = (i + *(_DWORD *)a2 + (a3 != -1)) % v3;
    if ( v5 == a3 )
      break;
    result = *(_DWORD *)(*(_DWORD *)(this + 32) + 4 * v5);
    if ( result )
    {
      *(_DWORD *)a2 = v5;
      return result;
    }
  }
  return 0;
}

//----- (10047903) --------------------------------------------------------
int __thiscall sub_10047903(int this, int a2)
{
  int result; // eax@1
  int v3; // ebx@1
  int v4; // edi@1

  v4 = *(_DWORD *)(this + 176);
  v3 = this + 16;
  result = sub_10029F93(*(_DWORD *)(this + 176), *(_DWORD *)(this + 80), a2, this + 16);
  if ( !result )
  {
    if ( v4 )
      result = sub_10029F93(result, v4, a2, v3);
  }
  return result;
}

//----- (1004793E) --------------------------------------------------------
int __thiscall sub_1004793E(int this, int a2)
{
  int result; // eax@1
  int v3; // ebx@1
  int v4; // edi@1

  v4 = *(_DWORD *)(this + 180);
  v3 = this + 96;
  result = sub_10029F93(*(_DWORD *)(this + 180), *(_DWORD *)(this + 160), a2, this + 96);
  if ( !result )
  {
    if ( v4 )
      result = sub_10029F93(result, v4, a2, v3);
  }
  return result;
}

//----- (1004797C) --------------------------------------------------------
char __stdcall sub_1004797C(int a1, int a2, char a3)
{
  int v3; // eax@2
  signed int v5; // [sp+8h] [bp-Ch]@3
  int v6; // [sp+10h] [bp-4h]@4

  if ( a3 )
  {
    v3 = sub_10038437((void *)a2);
    if ( v3 )
    {
      v5 = 2;
      v6 = v3;
LABEL_4:
      *(_DWORD *)a1 = v5;
      *(_DWORD *)(a1 + 4) = a2;
      *(_DWORD *)(a1 + 8) = v6;
      return 1;
    }
  }
  else
  {
    if ( sub_10038491(a2) )
    {
      v5 = 8;
      goto LABEL_4;
    }
  }
  return 0;
}

//----- (100479CC) --------------------------------------------------------
char __thiscall sub_100479CC(void *this, int a2, int a3, char a4, int a5, char a6)
{
  void *v6; // edi@1
  int v7; // esi@1
  char result; // al@3
  int v9; // esi@5

  v7 = *(_DWORD *)(a3 + 256);
  v6 = this;
  if ( sub_10048A38(this, a3, 0, a5, a6) || !sub_1004797C(a2, a3, a4) )
  {
    if ( a5 )
      v9 = *(_DWORD *)(v7 + 12);
    else
      v9 = *(_DWORD *)(v7 + 16);
    while ( v9 )
    {
      if ( !sub_10048A38(v6, v9, a3, a5, a6) && sub_1004797C(a2, v9, a4) )
        goto LABEL_3;
      v9 = *(_DWORD *)(v9 + 260);
    }
    result = 0;
  }
  else
  {
LABEL_3:
    result = 1;
  }
  return result;
}

//----- (10047A4D) --------------------------------------------------------
char __stdcall sub_10047A4D(int a1, int a2)
{
  int v2; // eax@1
  char result; // al@2
  int v4; // eax@2
  char v5; // [sp+0h] [bp-Ch]@2

  v2 = (*(int (**)(void))(*(_DWORD *)a2 + 12))();
  if ( v2 )
  {
    v4 = sub_1004770B((int)&v5, v2);
    *(_DWORD *)a1 = *(_DWORD *)v4;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(v4 + 4);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(v4 + 8);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10047A7E) --------------------------------------------------------
char __thiscall sub_10047A7E(void *this, int a2, int a3, int a4, char a5)
{
  void *v5; // edi@1
  int v6; // esi@1
  char result; // al@3
  int v8; // esi@5

  v6 = *(_DWORD *)(a3 + 256);
  v5 = this;
  if ( sub_10048A38(this, a3, 0, a4, a5) || !sub_10047A4D(a2, a3) )
  {
    if ( a4 )
      v8 = *(_DWORD *)(v6 + 12);
    else
      v8 = *(_DWORD *)(v6 + 16);
    while ( v8 )
    {
      if ( !sub_10048A38(v5, v8, a3, a4, a5) && sub_10047A4D(a2, v8) )
        goto LABEL_3;
      v8 = *(_DWORD *)(v8 + 260);
    }
    result = 0;
  }
  else
  {
LABEL_3:
    result = 1;
  }
  return result;
}

//----- (10047AF9) --------------------------------------------------------
char __userpurge sub_10047AF9<al>(int a1<edi>, int a2, int a3, char a4, char a5)
{
  int v5; // eax@2
  signed int v7; // [sp+8h] [bp-Ch]@3

  if ( a5 )
  {
    v5 = sub_10038A61(a3, a1, a4);
    if ( v5 )
    {
      v7 = 4;
LABEL_4:
      *(_DWORD *)a2 = v7;
      *(_DWORD *)(a2 + 4) = a3;
      *(_DWORD *)(a2 + 8) = v5;
      return 1;
    }
  }
  else
  {
    v5 = sub_10038667((void *)a3);
    if ( v5 )
    {
      v7 = 16;
      goto LABEL_4;
    }
  }
  return 0;
}

//----- (10047B4C) --------------------------------------------------------
char __thiscall sub_10047B4C(void *this, int a2, int a3, char a4, int a5, char a6)
{
  int v6; // edi@1
  char result; // al@3
  int v8; // esi@5
  int v9; // [sp+8h] [bp-4h]@1

  v6 = (int)this;
  v9 = *(_DWORD *)(a3 + 256);
  if ( sub_10048A38(this, a3, 0, a5, a6) || !sub_10047AF9(v6, a2, a3, a6, a4) )
  {
    if ( a5 )
      v8 = *(_DWORD *)(v9 + 12);
    else
      v8 = *(_DWORD *)(v9 + 16);
    while ( v8 )
    {
      if ( !sub_10048A38((void *)v6, v8, a3, a5, a6) && sub_10047AF9(v6, a2, v8, a6, a4) )
        goto LABEL_3;
      v8 = *(_DWORD *)(v8 + 260);
    }
    result = 0;
  }
  else
  {
LABEL_3:
    result = 1;
  }
  return result;
}

//----- (10047BDA) --------------------------------------------------------
int __thiscall sub_10047BDA(int this)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = this;
  if ( *(_DWORD *)this == 2 )
  {
    sub_10048BDA(*(_DWORD *)(this + 8));
    result = sub_1002B52D(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 4) + 256) + 4), *(_DWORD *)(v1 + 8));
  }
  else
  {
    result = *(_DWORD *)this - 4;
    if ( *(_DWORD *)this == 4 )
      result = (*(int (__cdecl **)(_DWORD))(*(_DWORD *)(this + 8) + 12))(*(_DWORD *)(this + 8));
  }
  return result;
}

//----- (10047C0F) --------------------------------------------------------
int __thiscall sub_10047C0F(void *this, int a2)
{
  int result; // eax@1

  result = a2 - *((_DWORD *)this + 103);
  if ( (unsigned int)result > 0x7D0 )
    result = sub_1002AFC8(this, a2);
  return result;
}

//----- (10047C2E) --------------------------------------------------------
char __thiscall sub_10047C2E(void *this, int a2)
{
  int v2; // eax@1
  char result; // al@2
  int v4; // eax@2
  char v5; // [sp+0h] [bp-Ch]@2

  v2 = (*(int (**)(void))(**(_DWORD **)this + 8))();
  if ( v2 )
  {
    v4 = sub_1004770B((int)&v5, v2);
    *(_DWORD *)a2 = *(_DWORD *)v4;
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(v4 + 4);
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(v4 + 8);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10047C5E) --------------------------------------------------------
char __userpurge sub_10047C5E<al>(int a1<edi>, int a2, int a3, char a4, unsigned int a5)
{
  return a5 & 1 && sub_10047A4D(a3, a2)
      || a5 & 0xA && sub_1004797C(a3, a2, (a5 >> 1) & 1)
      || a5 & 0x14 && sub_10047AF9(a1, a3, a2, a4, (a5 >> 2) & 1);
}

//----- (10047CCB) --------------------------------------------------------
char __userpurge sub_10047CCB<al>(int a1<edi>, int a2, int a3, char a4, unsigned int a5)
{
  return a5 & 0x14 && sub_10047AF9(a1, a3, a2, a4, (a5 >> 2) & 1)
      || a5 & 0xA && sub_1004797C(a3, a2, (a5 >> 1) & 1)
      || a5 & 1 && sub_10047A4D(a3, a2);
}

//----- (10047D39) --------------------------------------------------------
DWORD __thiscall sub_10047D39(int this, int a2, int a3)
{
  DWORD result; // eax@1
  int v4; // esi@1

  v4 = this;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)this = a2;
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 132);
  *(_DWORD *)(this + 4) = **(_DWORD **)(a2 + 68);
  result = GetTickCount();
  *(_DWORD *)(v4 + 20) = result;
  *(_DWORD *)(v4 + 16) = result;
  if ( a3 == 1 )
  {
    *(_DWORD *)(v4 + 24) = sub_10047E0B;
    *(_DWORD *)(v4 + 28) = sub_100480C9;
  }
  else
  {
    *(_DWORD *)(v4 + 24) = sub_10048643;
    *(_DWORD *)(v4 + 28) = sub_10048756;
  }
  return result;
}

//----- (10047D8D) --------------------------------------------------------
bool __usercall sub_10047D8D<eax>(int a1<ecx>, int a2<edi>)
{
  int ebp0; // ebp@0
  int v3; // esi@1
  char v4; // al@4
  int v5; // edi@4
  int v6; // eax@6
  int v8; // [sp+8h] [bp-4h]@4

  v3 = a1;
  if ( *(_DWORD *)a1 == 8 )
  {
    v6 = sub_10038437(*(void **)(a1 + 4));
    if ( !v6 )
      return (*(_BYTE *)v3 & 0x18) == 0;
    *(_DWORD *)v3 = 2;
    goto LABEL_10;
  }
  if ( *(_DWORD *)a1 != 16 )
    return (*(_BYTE *)v3 & 0x18) == 0;
  if ( *(_DWORD *)(a1 + 8) != 1 )
  {
    v6 = sub_10037567(ebp0, 0);
    if ( !v6 )
      return (*(_BYTE *)v3 & 0x18) == 0;
    *(_DWORD *)v3 = 4;
LABEL_10:
    *(_DWORD *)(v3 + 8) = v6;
    return (*(_BYTE *)v3 & 0x18) == 0;
  }
  v4 = sub_100381F2(*(_DWORD *)(a1 + 4) + 52, a2, (int)&v8);
  v5 = (unsigned __int8)v4 != 0 ? v8 : 0;
  if ( (unsigned __int8)v4 != 0 ? v8 : 0 )
  {
    sub_10036DAB((unsigned __int8)v4 != 0 ? v8 : 0, 1);
    *(_DWORD *)(v3 + 8) = v5;
    *(_DWORD *)v3 = 4;
  }
  return (*(_BYTE *)v3 & 0x18) == 0;
}

//----- (10047E0B) --------------------------------------------------------
char __thiscall sub_10047E0B(void *this, int a2, int a3, char a4, unsigned int a5)
{
  int v5; // ebx@1
  int ebp0; // ebp@0
  int v7; // edi@1
  char result; // al@2
  int v9; // eax@3
  void *v10; // ecx@3
  int v11; // ecx@4
  int v12; // eax@10
  int v13; // eax@12
  int v14; // eax@14
  int v15; // ecx@17
  char v16; // zf@18
  bool v17; // esi@21
  int v18; // eax@26
  int v19; // edi@44
  int v20; // esi@44
  int v21; // esi@44
  int v22; // [sp+10h] [bp-28h]@25
  int v23; // [sp+14h] [bp-24h]@17
  int v24; // [sp+18h] [bp-20h]@25
  int v25; // [sp+1Fh] [bp-19h]@32
  char v26; // [sp+1Fh] [bp-19h]@44
  char v27; // [sp+23h] [bp-15h]@1
  char v28; // [sp+24h] [bp-14h]@45
  int v29; // [sp+28h] [bp-10h]@14
  int v30; // [sp+2Ch] [bp-Ch]@18
  int v31; // [sp+30h] [bp-8h]@18
  unsigned int v32; // [sp+34h] [bp-4h]@1
  int v33; // [sp+38h] [bp+0h]@1

  v32 = (unsigned int)&v33 ^ __security_cookie;
  v7 = a2;
  v5 = (int)this;
  v27 = 0;
  if ( sub_10047C2E(this, a2) )
  {
    result = 1;
  }
  else
  {
    v9 = GetTickCount();
    v10 = *(void **)(v5 + 4);
    *(_DWORD *)(v5 + 16) = v9;
    sub_10047C0F(v10, v9);
    if ( sub_10047801(v5, *(_DWORD *)(v5 + 16)) )
    {
      v11 = *(_DWORD *)(v5 + 4);
      if ( *(_DWORD *)(v11 + 304) )
      {
        while ( 1 )
        {
          v13 = sub_1002A4B7(v11);
          if ( !v13 )
            break;
          if ( *(_DWORD *)v13 )
          {
            if ( a5 & 1 )
            {
              v12 = sub_10048B6E(v13 - 192, ebp0);
              if ( v12 )
              {
                v14 = sub_1004770B((int)&v29, v12);
                *(_DWORD *)a2 = *(_DWORD *)v14;
                *(_DWORD *)(a2 + 4) = *(_DWORD *)(v14 + 4);
                *(_DWORD *)(a2 + 8) = *(_DWORD *)(v14 + 8);
                v7 = a2;
LABEL_15:
                v27 = 1;
                break;
              }
            }
          }
          else
          {
            if ( sub_10047C5E(a2, v13 - 268, a2, a4, a5) )
              goto LABEL_15;
          }
          v11 = *(_DWORD *)(v5 + 4);
        }
      }
      *(_BYTE *)(*(_DWORD *)v5 + 86) = 1;
    }
    v15 = *(_DWORD *)v5;
    v23 = *(_DWORD *)(*(_DWORD *)v5 + 72);
    if ( v27 )
      goto LABEL_52;
    v17 = (v30 = 0, v16 = *(_BYTE *)(v15 + 84) == 0, v29 = 1, v31 = 2, v16) && !sub_1003A9F0(v15) && !a4;
    result = v27;
    LOBYTE(v25) = 1;
    do
    {
      if ( v17 > 2 )
        break;
      v22 = a3;
      v24 = v23;
      if ( v23 )
      {
        while ( 1 )
        {
          v18 = sub_10047731(*(_DWORD *)(v5 + 4), *(_DWORD *)(v5 + 8));
          if ( v18 )
          {
            if ( sub_10047C5E(v7, v18, v7, a4, a5) )
              break;
          }
          if ( (_BYTE)v25 && a5 & 1 && sub_1004781F(v5, v7, *(_DWORD *)v5, 0)
            || a5 & 1 && sub_10048441((void *)v5, v7, v24, v22, v25, *(&v29 + v17), a5, a4)
            || a5 & 0xA && sub_10048348((void *)v5, v7, v24, v22, (a5 >> 1) & 1, *(&v29 + v17), a5, a4)
            || a5 & 0x14 && sub_10048547((void *)v5, v7, v24, v22, (a5 >> 2) & 1, *(&v29 + v17), a5, a4)
            || a5 & 1 && v17 == 2 && sub_10048B02((void *)v5, v7, *(_DWORD *)(v24 + 4), *(_DWORD *)v5) )
            break;
          v22 = 0;
          LOBYTE(v25) = 0;
          v24 = sub_1002A528(*(_DWORD *)(v5 + 4), v23, v24);
          if ( !v24 )
          {
            result = v27;
            goto LABEL_42;
          }
        }
        result = 1;
        v27 = 1;
      }
LABEL_42:
      ++v17;
    }
    while ( !result );
    if ( result )
    {
LABEL_52:
      v21 = *(_DWORD *)(v7 + 4);
      v19 = *(_DWORD *)(v21 + 8);
      sub_100489FE(v21, *(_DWORD *)(v5 + 16));
      v20 = v21 + 12;
      v26 = 0;
      if ( *(_DWORD *)v20 & 0xFFFFFFF )
      {
        sub_10027C4E((int)&v28, *(_DWORD *)v5 + 136);
        if ( sub_100447E2((int)&v28, v20) )
          v26 = 1;
      }
      sub_1003B3D3(*(_DWORD *)v5, v26, v19 == v23);
      result = v27;
    }
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;

//----- (100480C9) --------------------------------------------------------
char __thiscall sub_100480C9(void *this, int a2, int a3, char a4, unsigned int a5)
{
  int v5; // ebx@1
  int ebp0; // ebp@0
  int v7; // edi@1
  char result; // al@2
  int v9; // eax@3
  void *v10; // ecx@3
  int v11; // ecx@4
  int v12; // eax@10
  int v13; // eax@12
  int v14; // eax@14
  int v15; // ecx@17
  char v16; // zf@18
  bool v17; // esi@21
  int v18; // edx@25
  int v19; // ecx@25
  int i; // eax@26
  int v21; // eax@32
  int v22; // ecx@48
  int v23; // esi@48
  int v24; // [sp+10h] [bp-28h]@33
  int v25; // [sp+18h] [bp-20h]@17
  int v26; // [sp+1Ch] [bp-1Ch]@25
  int v27; // [sp+20h] [bp-18h]@25
  char v28; // [sp+27h] [bp-11h]@1
  int v29; // [sp+28h] [bp-10h]@14
  int v30; // [sp+2Ch] [bp-Ch]@18
  int v31; // [sp+30h] [bp-8h]@18
  unsigned int v32; // [sp+34h] [bp-4h]@1
  int v33; // [sp+38h] [bp+0h]@1

  v32 = (unsigned int)&v33 ^ __security_cookie;
  v7 = a2;
  v5 = (int)this;
  v28 = 0;
  if ( sub_10047C2E(this, a2) )
  {
    result = 1;
  }
  else
  {
    v9 = GetTickCount();
    v10 = *(void **)(v5 + 4);
    *(_DWORD *)(v5 + 16) = v9;
    sub_10047C0F(v10, v9);
    if ( sub_10047801(v5, *(_DWORD *)(v5 + 16)) )
    {
      v11 = *(_DWORD *)(v5 + 4);
      if ( *(_DWORD *)(v11 + 304) )
      {
        while ( 1 )
        {
          v13 = sub_1002A4B7(v11);
          if ( !v13 )
            break;
          if ( *(_DWORD *)v13 )
          {
            if ( a5 & 1 )
            {
              v12 = sub_10048B6E(v13 - 192, ebp0);
              if ( v12 )
              {
                v14 = sub_1004770B((int)&v29, v12);
                *(_DWORD *)a2 = *(_DWORD *)v14;
                *(_DWORD *)(a2 + 4) = *(_DWORD *)(v14 + 4);
                *(_DWORD *)(a2 + 8) = *(_DWORD *)(v14 + 8);
                v7 = a2;
LABEL_15:
                v28 = 1;
                break;
              }
            }
          }
          else
          {
            if ( sub_10047CCB(a2, v13 - 268, a2, a4, a5) )
              goto LABEL_15;
          }
          v11 = *(_DWORD *)(v5 + 4);
        }
      }
      *(_BYTE *)(*(_DWORD *)v5 + 86) = 1;
    }
    v15 = *(_DWORD *)v5;
    v25 = *(_DWORD *)(*(_DWORD *)v5 + 72);
    if ( v28 )
      goto LABEL_51;
    v17 = (v30 = 0, v16 = *(_BYTE *)(v15 + 84) == 0, v29 = 1, v31 = 2, v16) && !sub_1003A9F0(v15) && !a4;
    result = v28;
    LOBYTE(v24) = 1;
    do
    {
      if ( v17 > 2 )
        break;
      v19 = v25;
      v18 = a3;
      v26 = a3;
      v27 = v25;
      if ( v25 )
      {
        for ( i = a5 & 0x14; ; i = a5 & 0x14 )
        {
          if ( i )
          {
            if ( sub_10048547((void *)v5, v7, v19, v18, (a5 >> 2) & 1, *(&v29 + v17), a5, a4) )
              goto LABEL_44;
            v19 = v27;
            v18 = v26;
          }
          if ( a5 & 0xA && sub_10048348((void *)v5, v7, v19, v18, (a5 >> 1) & 1, *(&v29 + v17), a5, a4) )
            goto LABEL_44;
          v21 = a5 & 1;
          if ( a5 & 1 )
          {
            if ( sub_10048441((void *)v5, v7, v27, v26, v24, *(&v29 + v17), a5, a4) )
              goto LABEL_44;
            v21 = a5 & 1;
          }
          if ( v21 && v17 == 2 )
          {
            if ( sub_10048B02((void *)v5, v7, *(_DWORD *)(v27 + 4), *(_DWORD *)v5) )
              goto LABEL_44;
            v21 = a5 & 1;
          }
          if ( (_BYTE)v24 && v21 && sub_1004781F(v5, v7, *(_DWORD *)v5, 1) )
          {
LABEL_44:
            result = 1;
            v28 = 1;
            goto LABEL_46;
          }
          LOBYTE(v24) = 0;
          v26 = 0;
          v19 = sub_1002A528(*(_DWORD *)(v5 + 4), v25, v27);
          v27 = v19;
          if ( !v19 )
            break;
          v18 = 0;
        }
        result = v28;
      }
LABEL_46:
      ++v17;
    }
    while ( !result );
    if ( result )
    {
LABEL_51:
      v22 = *(_DWORD *)(v7 + 4);
      v23 = *(_DWORD *)(v22 + 8);
      sub_100489FE(v22, *(_DWORD *)(v5 + 16));
      sub_1003B3D3(*(_DWORD *)v5, (*(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) & 0xFFFFFFF) == 0, v23 == v25);
      result = v28;
    }
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;

//----- (10048348) --------------------------------------------------------
char __thiscall sub_10048348(void *this, int a2, int a3, int a4, char a5, int a6, unsigned int a7, char a8)
{
  int v8; // edi@1
  char result; // al@3
  int v10; // esi@4
  int v11; // eax@5
  int v12; // ebx@7
  int v13; // eax@8
  int v14; // eax@12
  void *v15; // [sp+4h] [bp-4h]@1
  int i; // [sp+14h] [bp+Ch]@7

  v8 = a6;
  v15 = this;
  if ( a4 && sub_100479CC(this, a2, a4, a5, a6, a8) )
  {
    result = 1;
  }
  else
  {
    v10 = a3;
    if ( v8 )
      v11 = sub_10047903(a3, (int)&a6);
    else
      v11 = sub_1004793E(a3, (int)&a6);
    v12 = v11;
    for ( i = a6; ; v12 = sub_1002A4EC((int)&a6, i, v14) )
    {
      if ( !v12 )
        return 0;
      v13 = sub_10047731(*((_DWORD *)v15 + 1), *((_DWORD *)v15 + 2));
      if ( v13 )
      {
        if ( sub_10047C5E(v8, v13, a2, a8, a7) )
          break;
      }
      if ( !sub_10048A38(v15, v12, a4, v8, a8) && sub_1004797C(a2, v12, a5) )
      {
        if ( v8 )
          *(_DWORD *)(v10 + 176) = (a6 + 1) % *(_DWORD *)(v10 + 80);
        else
          *(_DWORD *)(v10 + 180) = (a6 + 1) % *(_DWORD *)(v10 + 160);
        break;
      }
      v14 = v10 + 96;
      if ( v8 )
        v14 = v10 + 16;
    }
    result = 1;
  }
  return result;
}

//----- (10048441) --------------------------------------------------------
char __thiscall sub_10048441(void *this, int a2, int a3, int a4, int a5, int i, unsigned int a7, char a8)
{
  int v8; // ebx@1
  int v9; // edi@1
  char result; // al@3
  int v11; // esi@6
  int v12; // eax@7
  int v13; // eax@10
  int v14; // eax@14
  int v15; // [sp+14h] [bp+Ch]@17

  v8 = i;
  v9 = (int)this;
  if ( a4 && sub_10047A7E(this, a2, a4, i, a8)
    || (_BYTE)a5 && sub_10048B02((void *)v9, a2, *(_DWORD *)(*(_DWORD *)v9 + 68), *(_DWORD *)v9) )
  {
    result = 1;
  }
  else
  {
    v11 = a3;
    if ( v8 )
      v12 = sub_10047903(a3, (int)&a5);
    else
      v12 = sub_1004793E(a3, (int)&a5);
    for ( i = a5; ; v12 = sub_1002A4EC((int)&a5, i, v14) )
    {
      v15 = v12;
      if ( !v12 )
        return 0;
      v13 = sub_10047731(*(_DWORD *)(v9 + 4), *(_DWORD *)(v9 + 8));
      if ( v13 )
      {
        if ( sub_10047C5E(v9, v13, a2, a8, a7) )
          break;
      }
      if ( !sub_10048A38((void *)v9, v15, a4, v8, a8) && sub_10047A4D(a2, v15) )
      {
        if ( v8 )
          *(_DWORD *)(v11 + 176) = (a5 + 1) % *(_DWORD *)(v11 + 80);
        else
          *(_DWORD *)(v11 + 180) = (a5 + 1) % *(_DWORD *)(v11 + 160);
        break;
      }
      v14 = v11 + 96;
      if ( v8 )
        v14 = v11 + 16;
    }
    result = 1;
  }
  return result;
}

//----- (10048547) --------------------------------------------------------
char __thiscall sub_10048547(void *this, int a2, int a3, int a4, char a5, int a6, unsigned int a7, char a8)
{
  int v8; // edi@1
  char result; // al@3
  int v10; // esi@4
  int v11; // eax@5
  int v12; // ebx@7
  int v13; // eax@8
  int v14; // eax@12
  void *v15; // [sp+4h] [bp-4h]@1
  int i; // [sp+14h] [bp+Ch]@7

  v8 = a6;
  v15 = this;
  if ( a4 && sub_10047B4C(this, a2, a4, a5, a6, a8) )
  {
    result = 1;
  }
  else
  {
    v10 = a3;
    if ( v8 )
      v11 = sub_10047903(a3, (int)&a6);
    else
      v11 = sub_1004793E(a3, (int)&a6);
    v12 = v11;
    for ( i = a6; ; v12 = sub_1002A4EC((int)&a6, i, v14) )
    {
      if ( !v12 )
        return 0;
      v13 = sub_10047731(*((_DWORD *)v15 + 1), *((_DWORD *)v15 + 2));
      if ( v13 )
      {
        if ( sub_10047C5E(v8, v13, a2, a8, a7) )
          break;
      }
      if ( !sub_10048A38(v15, v12, a4, v8, a8) && sub_10047AF9(v8, a2, v12, a8, a5) )
      {
        if ( v8 )
          *(_DWORD *)(v10 + 176) = (a6 + 1) % *(_DWORD *)(v10 + 80);
        else
          *(_DWORD *)(v10 + 180) = (a6 + 1) % *(_DWORD *)(v10 + 160);
        break;
      }
      v14 = v10 + 96;
      if ( v8 )
        v14 = v10 + 16;
    }
    result = 1;
  }
  return result;
}

//----- (10048643) --------------------------------------------------------
char __thiscall sub_10048643(void *this, int a2, int a3, int a4, unsigned int a5)
{
  char v5; // bl@1
  void *v6; // esi@1
  unsigned int v8; // eax@3
  int v9; // edi@3
  int v10; // eax@4
  int v11; // ecx@5
  char v12; // al@5
  int v13; // ecx@10
  int v14; // eax@11
  char v15; // al@12
  int v16; // ecx@16
  int v17; // eax@17
  char v18; // al@18
  int v19; // [sp-8h] [bp-18h]@5
  char v20; // [sp+8h] [bp-8h]@11
  int v21; // [sp+Ch] [bp-4h]@4
  int v22; // [sp+Ch] [bp-4h]@10
  int v23; // [sp+Ch] [bp-4h]@16
  int v24; // [sp+24h] [bp+14h]@17

  v6 = this;
  v5 = 0;
  if ( sub_10047C2E(this, a2) )
    return 1;
  v9 = sub_1002A552(*((_DWORD *)v6 + 1));
  v8 = a5;
  if ( !(a5 & 1) )
  {
LABEL_9:
    if ( v8 & 0xA && (v13 = v9, v22 = v9, v9) )
    {
      v14 = v8 >> 1;
      v20 = v14;
      while ( 1 )
      {
        v15 = sub_10048864(a2, v13, v14 & 1);
        v11 = *((_DWORD *)v6 + 1);
        v19 = v22;
        v5 = v15;
        if ( v15 )
          break;
        v14 = sub_1002A528(v11, v9, v22);
        v13 = v14;
        v22 = v14;
        LOBYTE(v14) = v20;
        if ( !v13 )
        {
          v8 = a5;
          goto LABEL_15;
        }
      }
    }
    else
    {
LABEL_15:
      if ( !(v8 & 0x14) || (v16 = v9, v23 = v9, !v9) )
        return v5;
      v17 = v8 >> 2;
      v24 = v17;
      while ( 1 )
      {
        v18 = sub_10048966(a2, v16, v17 & 1);
        v11 = *((_DWORD *)v6 + 1);
        v19 = v23;
        v5 = v18;
        if ( v18 )
          break;
        v17 = sub_1002A528(v11, v9, v23);
        v16 = v17;
        v23 = v17;
        LOBYTE(v17) = v24;
        if ( !v16 )
          return v5;
      }
    }
    goto LABEL_21;
  }
  v10 = v9;
  v21 = v9;
  if ( v9 )
  {
    while ( 1 )
    {
      v12 = sub_100488F8(a2, v10);
      v19 = v21;
      v11 = *((_DWORD *)v6 + 1);
      v5 = v12;
      if ( v12 )
        break;
      v10 = sub_1002A528(v11, v9, v21);
      v21 = v10;
      if ( !v10 )
        goto LABEL_7;
    }
LABEL_21:
    sub_1002BB0E(v11, v19);
    return v5;
  }
LABEL_7:
  v5 = sub_10048AC0(v6, a2, *(_DWORD *)(*(_DWORD *)v6 + 68));
  if ( !v5 )
  {
    v8 = a5;
    goto LABEL_9;
  }
  return v5;
}

//----- (10048756) --------------------------------------------------------
char __thiscall sub_10048756(void *this, int a2, int a3, int a4, unsigned int a5)
{
  char v5; // bl@1
  void *v6; // esi@1
  int v8; // eax@3
  int v9; // edi@3
  int v10; // ecx@4
  unsigned int v11; // eax@5
  int v12; // ecx@6
  char v13; // al@6
  int v14; // eax@7
  int v15; // ecx@9
  unsigned int v16; // eax@10
  char v17; // al@11
  int v18; // eax@12
  int v19; // eax@14
  char v20; // al@15
  int v21; // [sp-8h] [bp-18h]@6
  int v22; // [sp+Ch] [bp-4h]@4
  int v23; // [sp+Ch] [bp-4h]@9
  int v24; // [sp+24h] [bp+14h]@14

  v6 = this;
  v5 = 0;
  if ( sub_10047C2E(this, a2) )
    return 1;
  v8 = sub_1002A552(*((_DWORD *)v6 + 1));
  v9 = v8;
  if ( a5 & 0x14 )
  {
    v10 = v8;
    v22 = v8;
    if ( v8 )
    {
      v11 = a5 >> 2;
      do
      {
        v13 = sub_10048966(a2, v10, v11 & 1);
        v12 = *((_DWORD *)v6 + 1);
        v21 = v22;
        v5 = v13;
        if ( v13 )
          goto LABEL_20;
        v14 = sub_1002A528(v12, v9, v22);
        v10 = v14;
        v22 = v14;
        v11 = a5 >> 2;
      }
      while ( v10 );
    }
  }
  if ( a5 & 0xA )
  {
    v15 = v9;
    v23 = v9;
    if ( v9 )
    {
      v16 = a5 >> 1;
      do
      {
        v17 = sub_10048864(a2, v15, v16 & 1);
        v12 = *((_DWORD *)v6 + 1);
        v21 = v23;
        v5 = v17;
        if ( v17 )
          goto LABEL_20;
        v18 = sub_1002A528(v12, v9, v23);
        v15 = v18;
        v23 = v18;
        v16 = a5 >> 1;
      }
      while ( v15 );
    }
  }
  if ( a5 & 1 )
  {
    v19 = v9;
    v24 = v9;
    if ( v9 )
    {
      while ( 1 )
      {
        v20 = sub_100488F8(a2, v19);
        v21 = v24;
        v12 = *((_DWORD *)v6 + 1);
        v5 = v20;
        if ( v20 )
          break;
        v19 = sub_1002A528(v12, v9, v24);
        v24 = v19;
        if ( !v19 )
          goto LABEL_17;
      }
LABEL_20:
      sub_1002BB0E(v12, v21);
      return v5;
    }
LABEL_17:
    v5 = sub_10048AC0(v6, a2, *(_DWORD *)(*(_DWORD *)v6 + 68));
  }
  return v5;
}

//----- (10048864) --------------------------------------------------------
char __stdcall sub_10048864(int a1, int a2, char a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int v5; // eax@3
  char result; // al@5
  signed int v7; // [sp+Ch] [bp-10h]@4
  int v8; // [sp+14h] [bp-8h]@5
  int v9; // [sp+18h] [bp-4h]@1
  int v10; // [sp+28h] [bp+Ch]@1

  v3 = a2;
  v4 = sub_1004793E(a2, (int)&v9);
  v10 = v9;
  while ( v4 )
  {
    if ( a3 )
    {
      v5 = sub_10038437((void *)v4);
      if ( v5 )
      {
        v7 = 2;
        v8 = v5;
LABEL_5:
        result = 1;
        *(_DWORD *)(v3 + 180) = (v9 + 1) % *(_DWORD *)(v3 + 160);
        *(_DWORD *)a1 = v7;
        *(_DWORD *)(a1 + 4) = v4;
        *(_DWORD *)(a1 + 8) = v8;
        return result;
      }
    }
    else
    {
      if ( sub_10038491(v4) )
      {
        v7 = 8;
        goto LABEL_5;
      }
    }
    v4 = sub_1002A4EC((int)&v9, v10, v3 + 96);
  }
  return 0;
}

//----- (100488F8) --------------------------------------------------------
char __stdcall sub_100488F8(int a1, int a2)
{
  int v2; // eax@1
  int i; // ebx@1
  int v4; // edi@2
  int v6; // eax@7
  char v7; // [sp+Ch] [bp-10h]@7
  int v8; // [sp+18h] [bp-4h]@1

  v2 = sub_1004793E(a2, (int)&v8);
  for ( i = v8; ; v2 = sub_1002A4EC((int)&v8, i, a2 + 96) )
  {
    if ( !v2 )
      return 0;
    v4 = (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 12))(v2);
    if ( v4 )
      break;
  }
  *(_DWORD *)(a2 + 180) = (v8 + 1) % *(_DWORD *)(a2 + 160);
  v6 = sub_1004770B((int)&v7, v4);
  *(_DWORD *)a1 = *(_DWORD *)v6;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(v6 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(v6 + 8);
  return 1;
}

//----- (10048966) --------------------------------------------------------
char __stdcall sub_10048966(int a1, int a2, char a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int v5; // ebx@3
  char result; // al@5
  signed int v7; // [sp+Ch] [bp-10h]@4
  int v8; // [sp+18h] [bp-4h]@1
  int v9; // [sp+28h] [bp+Ch]@1

  v3 = a2;
  v4 = sub_1004793E(a2, (int)&v8);
  v9 = v8;
  while ( v4 )
  {
    if ( a3 )
    {
      v5 = sub_10038A61(v4, v3, 0);
      if ( v5 )
      {
        v7 = 4;
LABEL_5:
        result = 1;
        *(_DWORD *)(v3 + 180) = (v8 + 1) % *(_DWORD *)(v3 + 160);
        *(_DWORD *)a1 = v7;
        *(_DWORD *)(a1 + 4) = v4;
        *(_DWORD *)(a1 + 8) = v5;
        return result;
      }
    }
    else
    {
      v5 = sub_10038667((void *)v4);
      if ( v5 )
      {
        v7 = 16;
        goto LABEL_5;
      }
    }
    v4 = sub_1002A4EC((int)&v8, v9, v3 + 96);
  }
  return 0;
}

//----- (100489FE) --------------------------------------------------------
int __thiscall sub_100489FE(int this, int a2)
{
  int result; // eax@1

  result = a2 - *(_DWORD *)(this + 264);
  if ( (unsigned int)result > 0x64 )
    *(_DWORD *)(this + 264) = a2;
  return result;
}

//----- (10048A1B) --------------------------------------------------------
int __thiscall sub_10048A1B(int this, int a2)
{
  int result; // eax@1

  result = a2 - *(_DWORD *)(this + 184);
  if ( (unsigned int)result > 0x64 )
    *(_DWORD *)(this + 184) = a2;
  return result;
}

//----- (10048A38) --------------------------------------------------------
char __thiscall sub_10048A38(void *this, int a2, int a3, int a4, char a5)
{
  void *v5; // edi@1
  int v7; // edx@3
  char v8; // bl@3
  char v9; // zf@9

  v5 = this;
  if ( a2 == a3 )
    return 1;
  v8 = 0;
  v7 = a2 + 12;
  if ( !a4 )
    return (*(_DWORD *)v7 & 0xFFFFFFF) != 0;
  if ( a4 == 1 )
  {
    if ( !(*(_DWORD *)v7 & 0xFFFFFFF) )
      return 1;
    v9 = sub_100447E2(*(_DWORD *)this + 136, a2 + 12) == 0;
  }
  else
  {
    if ( a4 != 2 )
      return v8;
    if ( !(*(_DWORD *)v7 & 0xFFFFFFF) || sub_100447E2(*(_DWORD *)this + 136, a2 + 12) )
      return 1;
    if ( !sub_1002AD6F(*((_DWORD *)v5 + 1) + 60, a2 + 28) )
      return v8;
    v9 = a5 == 0;
  }
  if ( v9 )
    return 1;
  return v8;
}

//----- (10048AC0) --------------------------------------------------------
char __thiscall sub_10048AC0(void *this, int a2, int a3)
{
  void *v3; // esi@1
  int v4; // eax@5
  int i; // [sp-4h] [bp-Ch]@1
  int v7; // [sp+4h] [bp-4h]@1

  v7 = 0;
  v3 = this;
  for ( i = -1; ; i = 0 )
  {
    v4 = sub_100478B6(*((_DWORD *)v3 + 1), (int)&v7, i);
    if ( !v4 )
      return 0;
    if ( v4 != a3 && sub_10048B02(v3, a2, v4, 0) )
      break;
  }
  return 1;
}

//----- (10048B02) --------------------------------------------------------
char __thiscall sub_10048B02(void *this, int a2, int a3, int a4)
{
  int i; // eax@1
  void *v5; // ebx@1
  int ebp0; // ebp@0
  int v7; // edi@1
  int v8; // eax@3
  int v9; // esi@5
  int v11; // eax@8
  char v12; // [sp+Ch] [bp-Ch]@8

  v7 = a3;
  v5 = this;
  for ( i = sub_10029FBE((void *)a3, 0, *(_DWORD *)(a3 + 120), (int)&a3); ; i = sub_1002A595(v7, (int)&a3, 0) )
  {
    v9 = i;
    if ( !i )
      return 0;
    if ( i != a4 )
    {
      sub_10048A1B(i, *((_DWORD *)v5 + 4));
      v8 = sub_10048B6E(v9, ebp0);
      if ( v8 )
        break;
    }
  }
  v11 = sub_1004770B((int)&v12, v8);
  *(_DWORD *)a2 = *(_DWORD *)v11;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(v11 + 4);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(v11 + 8);
  return 1;
}

//----- (10048B6E) --------------------------------------------------------
int __usercall sub_10048B6E<eax>(int a1<ecx>, int a2<ebp>)
{
  int v2; // edx@1

  v2 = 0;
  if ( *(_DWORD *)(a1 + 16) > *(_DWORD *)(a1 + 12) )
    v2 = sub_1003B8F1(a2, 0);
  return v2;
}

//----- (10048B85) --------------------------------------------------------
void __thiscall sub_10048B85(void *this, int a2)
{
  int v2; // eax@1
  void *v3; // edi@1
  void *v4; // ecx@2
  int v5; // [sp-8h] [bp-10h]@3
  char v6; // [sp-4h] [bp-Ch]@3

  v3 = this;
  v2 = sub_100349ED(a2 + 4);
  if ( *(_DWORD *)v3 == 2 )
  {
    v4 = *(void **)(v2 + 256);
    if ( v4 == *(void **)(*((_DWORD *)v3 + 1) + 256) )
    {
      sub_1002AD41(v4);
      return;
    }
    v6 = 0;
    v5 = *((_DWORD *)v3 + 1);
  }
  else
  {
    if ( *(_DWORD *)(v2 + 256) == *(_DWORD *)(*((_DWORD *)v3 + 1) + 256) )
      return;
    v6 = 1;
    v5 = *((_DWORD *)v3 + 1);
  }
  sub_1003C7D6(a2, v5, v6);
}

//----- (10048BDA) --------------------------------------------------------
int __thiscall sub_10048BDA(int this)
{
  return (*(int (__cdecl **)(_DWORD))(this + 4))(*(_DWORD *)(this + 8));
}

//----- (10048BE2) --------------------------------------------------------
int __userpurge sub_10048BE2<eax>(int a1<ebp>, int a2, int a3)
{
  int v4; // ecx@1
  int v5; // esi@1
  int v6; // edx@1
  int v7; // ST04_4@1
  int v8; // ST00_4@1

  sub_1002D0B8();
  v5 = v4;
  *(_DWORD *)(a1 - 16) = v4;
  sub_1003A893(v4, v6);
  v7 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 - 4) = 0;
  v8 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)v5 = &off_1005AA40;
  sub_1003AC62(v5, v8, v7);
  return sub_1002D086(4);
}
// 1002D086: using guessed type int __cdecl sub_1002D086(_DWORD);
// 1005AA40: using guessed type int (__stdcall *off_1005AA40)(char);

//----- (10048C19) --------------------------------------------------------
void *__thiscall sub_10048C19(void *this, char a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1

  v3 = this;
  *(_DWORD *)this = &off_1005AA40;
  sub_1003A912(ebp0);
  if ( a2 & 1 )
    sub_1002404A(v3);
  return v3;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005AA40: using guessed type int (__stdcall *off_1005AA40)(char);

//----- (10048C3E) --------------------------------------------------------
void __usercall sub_10048C3E(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v3; // edx@1
  int v4; // edi@1
  signed int i; // esi@1
  int v6; // eax@3
  int v7; // eax@5

  v4 = 0;
  sub_1002E493(a1, a2, a3, 0, 1);
  for ( i = 3; i < dword_1006A39C; ++i )
  {
    v6 = *((_DWORD *)dword_1006A398 + i);
    if ( v6 )
    {
      if ( *(_BYTE *)(v6 + 12) & 0x83 )
      {
        sub_1004BFA7(v3, a3, *((_DWORD *)dword_1006A398 + i));
        if ( v7 != -1 )
          ++v4;
      }
      if ( i >= 20 )
      {
        DeleteCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)dword_1006A398 + i) + 32));
        sub_100282F6(a3, *((LPVOID *)dword_1006A398 + i));
        *((_DWORD *)dword_1006A398 + i) = 0;
      }
    }
  }
  sub_1002E5F7(1);
}
// 1006A39C: using guessed type int dword_1006A39C;

//----- (10048CDB) --------------------------------------------------------
void __usercall sub_10048CDB(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  DWORD v4; // esi@6
  void *v5; // eax@7

  if ( a4 == -2 )
  {
    *(_DWORD *)sub_1002F144(a3) = 9;
    return;
  }
  if ( a4 >= 0 )
  {
    if ( a4 < (unsigned int)dword_1006A394 )
    {
      a3 = (a4 & 0x1F) << 6;
      if ( *(_BYTE *)(a3 + dword_10069CE0[a4 >> 5] + 4) & 1 )
      {
        sub_1004BD5B(a1, a2, a3, a4);
        v4 = 0;
        if ( *(_BYTE *)(a3 + dword_10069CE0[a4 >> 5] + 4) & 1 )
        {
          v5 = (void *)sub_1004BE6D(a3, a4, a4);
          if ( !FlushFileBuffers(v5) )
            v4 = GetLastError();
          if ( !v4 )
            goto LABEL_12;
          *(_DWORD *)sub_1002F110(a3) = v4;
        }
        *(_DWORD *)sub_1002F144(a3) = 9;
LABEL_12:
        sub_1004BED4(a4);
        return;
      }
    }
  }
  *(_DWORD *)sub_1002F144(a3) = 9;
  sub_10036C88(a3, a4);
}
// 10069CE0: using guessed type int dword_10069CE0[];
// 1006A394: using guessed type int dword_1006A394;

//----- (10048DF0) --------------------------------------------------------
#error "10048E0B: call analysis failed (funcsize=22)"

//----- (10048E35) --------------------------------------------------------
int __usercall sub_10048E35<eax>(int a1<ebp>, int a2, unsigned int a3)
{
  int result; // eax@2
  int v4; // ebx@2
  unsigned int v5; // esi@2
  int v6; // esi@5
  int (__cdecl *v7)(int, int, int, int, int); // [sp+4h] [bp-1Ch]@1
  int v8; // [sp+8h] [bp-18h]@1
  int v9; // [sp+Ch] [bp-14h]@1

  v9 = a2;
  v8 = -2;
  v7 = sub_10048DF0;
  while ( 1 )
  {
    result = a2;
    v4 = *(_DWORD *)(a2 + 8);
    v5 = *(_DWORD *)(a2 + 12);
    if ( v5 == -1 )
      break;
    if ( a3 != -1 && v5 <= a3 )
      break;
    v6 = 3 * v5;
    v8 = *(_DWORD *)(v4 + 4 * v6);
    *(_DWORD *)(a2 + 12) = v8;
    if ( !*(_DWORD *)(v4 + 4 * v6 + 4) )
    {
      sub_10048EE5(*(_DWORD *)(v4 + 4 * v6 + 8), a1, 257);
      sub_10048F04(*(int (**)(void))(v4 + 4 * v6 + 8));
    }
  }
  return result;
}
// 10048DF0: using guessed type int __cdecl sub_10048DF0(int, int, int, int, int);

//----- (10048EDC) --------------------------------------------------------
void __cdecl sub_10048EDC()
{
  JUMPOUT(*(unsigned int *)loc_10048EF0);
}
// 10048EF0: using guessed type int __stdcall loc_10048EF0(int);

//----- (10048EE5) --------------------------------------------------------
int __userpurge sub_10048EE5<eax>(int result<eax>, int a2<ebp>, int a3)
{
  dword_100683F0[2] = a3;
  dword_100683F0[1] = result;
  dword_100683F0[3] = a2;
  return result;
}

//----- (10048F04) --------------------------------------------------------
int __usercall sub_10048F04<eax>(int (*a1)(void)<eax>)
{
  return a1();
}

//----- (10048F07) --------------------------------------------------------
int __cdecl sub_10048F07(int a1, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // esi@2

  v2 = a2;
  v4 = *(_WORD *)a2;
  v3 = *(_WORD *)a1 - v4;
  if ( *(_WORD *)a1 == v4 )
  {
    v5 = a1 - a2;
    do
    {
      if ( !(_WORD)v4 )
        break;
      v2 += 2;
      v4 = *(_WORD *)v2;
      v3 = *(_WORD *)(v5 + v2) - v4;
    }
    while ( *(_WORD *)(v5 + v2) == v4 );
  }
  if ( v3 >= 0 )
  {
    if ( v3 > 0 )
      v3 = 1;
  }
  else
  {
    v3 = -1;
  }
  return v3;
}

//----- (10048F45) --------------------------------------------------------
int __cdecl sub_10048F45(int a1, int a2)
{
  int v2; // eax@1
  __int16 v3; // dx@1
  int v4; // ecx@1
  int v5; // esi@2
  __int16 v6; // dx@3

  v4 = a1;
  v3 = 0;
  v2 = a1;
  if ( *(_WORD *)a1 )
  {
    while ( 1 )
    {
      v5 = a2;
      if ( *(_WORD *)a2 )
        break;
LABEL_7:
      v2 += 2;
      if ( *(_WORD *)v2 == v3 )
        return (v2 - v4) >> 1;
    }
    v4 = a1;
    v6 = *(_WORD *)a2;
    while ( v6 != *(_WORD *)v2 )
    {
      v5 += 2;
      v6 = *(_WORD *)v5;
      if ( !*(_WORD *)v5 )
      {
        v3 = 0;
        goto LABEL_7;
      }
    }
  }
  return (v2 - v4) >> 1;
}

//----- (10048F94) --------------------------------------------------------
int __cdecl sub_10048F94(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // edx@3
  int v5; // ecx@3

  result = a3;
  if ( a3 )
  {
    v5 = a2;
    v4 = a1;
    while ( 1 )
    {
      --result;
      if ( !result )
        break;
      if ( !*(_WORD *)v4 || *(_WORD *)v4 != *(_WORD *)v5 )
        break;
      v4 += 2;
      v5 += 2;
    }
    result = *(_WORD *)v4 - *(_WORD *)v5;
  }
  return result;
}

//----- (10048FCA) --------------------------------------------------------
int __cdecl sub_10048FCA(int a1, int a2)
{
  int result; // eax@1
  __int16 v3; // cx@1
  int v4; // esi@2
  __int16 v5; // dx@3

  result = a1;
  v3 = *(_WORD *)a1;
  if ( *(_WORD *)a1 )
  {
    while ( 1 )
    {
      v4 = a2;
      if ( *(_WORD *)a2 )
        break;
LABEL_6:
      result += 2;
      v3 = *(_WORD *)result;
      if ( !*(_WORD *)result )
        goto LABEL_7;
    }
    v5 = *(_WORD *)a2;
    while ( v5 != v3 )
    {
      v4 += 2;
      v5 = *(_WORD *)v4;
      if ( !*(_WORD *)v4 )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_7:
    result = 0;
  }
  return result;
}

//----- (1004900C) --------------------------------------------------------
int __usercall sub_1004900C<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  char v5; // [sp+4h] [bp-B0h]@1
  unsigned int v6; // [sp+B0h] [bp-4h]@1
  int v7; // [sp+B4h] [bp+0h]@1

  v6 = (unsigned int)&v7 ^ __security_cookie;
  *(_DWORD *)(a3 + 8) |= 0x104u;
  result = sub_1003186D((int)&v5, 85);
  if ( result > 1 )
  {
    v4 = sub_10031399((int)&v5);
    result = sub_1003A3FC(a1, a2, a3 + 592, 85, (int)&v5, v4 + 1);
    if ( result )
    {
      sub_10036C98(a1, a2);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_10049083);
    }
  }
  return result;
}
// 10049083: using guessed type int __cdecl sub_10049083(int);
// 10067210: using guessed type int __security_cookie;

//----- (10049083) --------------------------------------------------------
BOOL __cdecl sub_10049083(int a1)
{
  int v1; // ST04_4@1
  int v2; // eax@1
  char v3; // zf@1
  int v4; // eax@2
  BOOL result; // eax@4

  v1 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 16) = sub_10031399(*(_DWORD *)a1) == 3;
  v2 = sub_10031399(v1);
  v3 = *(_DWORD *)(a1 + 16) == 0;
  *(_DWORD *)(a1 + 20) = v2 == 3;
  if ( v3 )
    v4 = sub_10049141(*(unsigned __int16 **)a1);
  else
    v4 = 2;
  *(_DWORD *)(a1 + 12) = v4;
  result = sub_10031801((int (__stdcall *)(_DWORD, _DWORD, _DWORD))sub_10049173, 3, 0);
  if ( !(*(_DWORD *)(a1 + 8) & 0x100) || !(*(_DWORD *)(a1 + 8) & 0x200) || !(*(_BYTE *)(a1 + 8) & 7) )
    *(_DWORD *)(a1 + 8) = 0;
  return result;
}
// 10049083: using guessed type int __cdecl sub_10049083(int);

//----- (100490F7) --------------------------------------------------------
BOOL __cdecl sub_100490F7(int a1)
{
  bool v1; // eax@1
  int v2; // eax@2
  BOOL result; // eax@4

  v1 = sub_10031399(*(_DWORD *)a1) == 3;
  *(_DWORD *)(a1 + 16) = v1;
  if ( v1 )
    v2 = 2;
  else
    v2 = sub_10049141(*(unsigned __int16 **)a1);
  *(_DWORD *)(a1 + 12) = v2;
  result = sub_10031801((int (__stdcall *)(_DWORD, _DWORD, _DWORD))sub_10049391, 3, 0);
  if ( !(*(_BYTE *)(a1 + 8) & 4) )
    *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (10049141) --------------------------------------------------------
int __cdecl sub_10049141(unsigned __int16 *a1)
{
  int v1; // edx@1
  unsigned __int16 *v2; // ecx@1
  int result; // eax@2
  unsigned __int16 v4; // ax@3

  v2 = a1;
  v1 = 0;
  if ( a1 )
  {
    while ( 1 )
    {
      v4 = *v2;
      ++v2;
      if ( v4 < 0x41u || v4 > 0x5Au )
      {
        if ( (unsigned __int16)(v4 - 97) > 0x19u )
          break;
      }
      ++v1;
    }
    result = v1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10049173) --------------------------------------------------------
unsigned int __userpurge sub_10049173<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@1
  int v9; // eax@7
  int v10; // edi@8
  int v11; // eax@22
  int v12; // esi@28
  const WCHAR v13[64]; // [sp+Ch] [bp-84h]@1
  unsigned int v14; // [sp+8Ch] [bp-4h]@1
  int v15; // [sp+90h] [bp+0h]@1

  v14 = (unsigned int)&v15 ^ __security_cookie;
  v6 = a3;
  v7 = sub_10031BD7(a1, a2);
  v5 = v7 + 156;
  if ( !sub_1003183E(a3, *(_DWORD *)(v7 + 176) != 0 ? 7 : 4098, (WCHAR *)v13, 64) )
  {
    *(_DWORD *)(v5 + 8) = 0;
    return 1;
  }
  if ( !sub_10041BDB(v5, a2, *(_DWORD *)(v5 + 4), v13) )
  {
    if ( !sub_1003183E(a3, *(_DWORD *)(v5 + 16) != 0 ? 3 : 4097, (WCHAR *)v13, 64) )
    {
LABEL_18:
      *(_DWORD *)(v5 + 8) = 0;
      return 1;
    }
    if ( !sub_10041BDB(v5, -4094, *(_DWORD *)v5, v13) )
    {
      *(_DWORD *)(v5 + 8) |= 0x304u;
      goto LABEL_7;
    }
    if ( !(*(_BYTE *)(v5 + 8) & 2) )
    {
      if ( *(_DWORD *)(v5 + 12) && !sub_1004C3F0(v5, -4094, *(_DWORD *)v5, (int)v13, *(_DWORD *)(v5 + 12)) )
      {
        *(_DWORD *)(v5 + 8) |= 2u;
        goto LABEL_7;
      }
      if ( !(*(_BYTE *)(v5 + 8) & 1) && sub_100494D7(a3) )
      {
        *(_DWORD *)(v5 + 8) |= 1u;
LABEL_7:
        v9 = sub_10031399(a3);
        if ( sub_1003A3FC(v5, -4094, v5 + 592, 85, a3, v9 + 1) )
        {
          v10 = 0;
          goto LABEL_30;
        }
        goto LABEL_16;
      }
    }
  }
LABEL_16:
  if ( (*(_DWORD *)(v5 + 8) & 0x300) != 768 )
  {
    if ( !sub_1003183E(a3, *(_DWORD *)(v5 + 16) != 0 ? 3 : 4097, (WCHAR *)v13, 128) )
      goto LABEL_18;
    if ( !sub_10041BDB(v5, -4094, *(_DWORD *)v5, v13) )
    {
      *(_DWORD *)(v5 + 8) |= 0x200u;
      v10 = 0;
      if ( *(_DWORD *)(v5 + 16)
        || !*(_DWORD *)(v5 + 12)
        || sub_10031399(*(_DWORD *)v5) != *(_DWORD *)(v5 + 12)
        || sub_100494D7(a3) )
      {
LABEL_21:
        *(_DWORD *)(v5 + 8) |= 0x100u;
        if ( !*(_WORD *)(v5 + 592) )
        {
          v11 = sub_10031399(v6);
          if ( sub_1003A3FC(v5, 0, v5 + 592, 85, v6, v11 + 1) )
          {
LABEL_30:
            sub_10036C98(v5, v10);
            __asm { int     3               ; Trap to Debugger }
            JUMPOUT(*(int *)sub_10049391);
          }
        }
        return ~(unsigned __int8)(*(_DWORD *)(v5 + 8) >> 2) & 1;
      }
      v12 = sub_10049141(*(unsigned __int16 **)v5);
      if ( v12 != sub_10031399(*(_DWORD *)v5) )
      {
        v6 = a3;
        goto LABEL_21;
      }
    }
  }
  return ~(unsigned __int8)(*(_DWORD *)(v5 + 8) >> 2) & 1;
}
// 10067210: using guessed type int __security_cookie;

//----- (10049391) --------------------------------------------------------
unsigned int __userpurge sub_10049391<eax>(int a1<ebx>, int a2, int a3, int a4)
{
  int v4; // esi@1
  int v5; // eax@1
  unsigned int result; // eax@2
  int v7; // eax@4
  const WCHAR v8[120]; // [sp+8h] [bp-F4h]@1
  unsigned int v9; // [sp+F8h] [bp-4h]@1
  int v10; // [sp+FCh] [bp+0h]@1

  v9 = (unsigned int)&v10 ^ __security_cookie;
  v5 = sub_10031BD7(a1, a2);
  v4 = v5 + 156;
  if ( sub_1003183E(a2, *(_DWORD *)(v5 + 172) != 0 ? 3 : 4097, (WCHAR *)v8, 120) )
  {
    if ( !sub_10041BDB(a1, a2, *(_DWORD *)v4, v8) )
    {
      v7 = sub_10031399(a2);
      if ( sub_1003A3FC(a1, a2, v4 + 592, 85, a2, v7 + 1) )
      {
        sub_10036C98(a1, a2);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_10049442);
      }
      *(_DWORD *)(v4 + 8) |= 4u;
    }
    result = ~(unsigned __int8)(*(_DWORD *)(v4 + 8) >> 2) & 1;
  }
  else
  {
    *(_DWORD *)(v4 + 8) = 0;
    result = 1;
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;

//----- (10049442) --------------------------------------------------------
int __usercall sub_10049442<eax>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  int v4; // esi@1
  int result; // eax@6

  v4 = a3;
  if ( a3 && *(_WORD *)a3 && sub_10048F07(a3, (int)L"ACP") )
  {
    if ( sub_10048F07(v4, (int)L"OCP") )
      return sub_1004C32E(a1, a2, v4);
    if ( sub_1003183E(a4 + 592, 0x2000000Bu, (WCHAR *)&a3, 2) )
      return a3;
    return 0;
  }
  if ( !sub_1003183E(a4 + 592, 0x20001004u, (WCHAR *)&a3, 2) )
    return 0;
  result = a3;
  if ( !a3 )
    result = GetACP();
  return result;
}
// 1005B7F4: using guessed type wchar_t aAcp[4];
// 1005B7FC: using guessed type wchar_t aOcp[4];

//----- (100494D7) --------------------------------------------------------
int __cdecl sub_100494D7(int a1)
{
  int result; // eax@1
  char v2; // [sp+4h] [bp-18h]@1
  unsigned int v3; // [sp+18h] [bp-4h]@1
  int v4; // [sp+1Ch] [bp+0h]@1

  v3 = (unsigned int)&v4 ^ __security_cookie;
  result = sub_1003183E(a1, 0x59u, (WCHAR *)&v2, 9);
  if ( result )
    result = sub_10048F94((int)&v2, a1, 9) == 0;
  return result;
}
// 10067210: using guessed type int __security_cookie;

//----- (10049521) --------------------------------------------------------
signed int __usercall sub_10049521<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  int v5; // eax@1
  __int16 v6; // cx@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // eax@14
  unsigned int v10; // esi@14
  int v11; // eax@21
  int v13; // [sp+Ch] [bp-4h]@1

  v5 = sub_10031BD7(a1, a2);
  v8 = v5 + 156;
  v6 = 0;
  v13 = v5 + 748;
  *(_WORD *)(v5 + 748) = 0;
  v7 = v5 + 160;
  *(_DWORD *)(v5 + 164) = 0;
  *(_DWORD *)(v5 + 156) = a3;
  *(_DWORD *)(v5 + 160) = a3 + 128;
  if ( *(_WORD *)(a3 + 128) )
  {
    sub_10049D01((int)&off_1005B518, 22, (int *)(v5 + 160));
    v6 = 0;
  }
  if ( **(_WORD **)v8 == v6 )
  {
    sub_1004900C(a3, v7, v8);
  }
  else
  {
    if ( **(_WORD **)v7 == v6 )
      sub_100490F7(v8);
    else
      sub_10049083(v8);
    if ( !*(_DWORD *)(v8 + 8) )
    {
      if ( sub_10049D01((int)&off_1005AA68, 64, (int *)v8) )
      {
        if ( **(_WORD **)v7 )
          sub_10049083(v8);
        else
          sub_100490F7(v8);
      }
    }
  }
  if ( *(_DWORD *)(v8 + 8) )
  {
    v9 = sub_10049442(a3, 0, a3 + 256, v8);
    v10 = v9;
    if ( v9 )
    {
      if ( v9 != 65000 && v9 != 65001 && IsValidCodePage((unsigned __int16)v9) )
      {
        if ( a4 )
          *(_DWORD *)a4 = v10;
        if ( !a5 )
          return 1;
        *(_WORD *)(a5 + 288) = 0;
        v11 = sub_10031399(v13);
        if ( sub_1003A3FC(a5 + 288, a5, a5 + 288, 85, v13, v11 + 1) )
        {
          sub_10036C98(a5 + 288, a5);
          __asm { int     3               ; Trap to Debugger }
          JUMPOUT(*(int *)sub_100496E3);
        }
        if ( sub_1003183E(a5 + 288, 0x1001u, (WCHAR *)a5, 64)
          && sub_1003183E(a5 + 288, 0x1002u, (WCHAR *)(a5 + 128), 64)
          && (!sub_1004C342(a5 + 128, 0x5Fu) && !sub_1004C342(a5 + 128, 0x2Eu)
           || sub_1003183E(a5 + 288, 7u, (WCHAR *)(a5 + 128), 64)) )
        {
          sub_1004C212(a5 + 128, a5, v10, a5 + 256, 0x10u, 0xAu);
          return 1;
        }
      }
    }
  }
  return 0;
}
// 10049083: using guessed type int __cdecl sub_10049083(int);
// 1005AA68: using guessed type wchar_t *off_1005AA68;
// 1005B518: using guessed type wchar_t *off_1005B518;

//----- (100496E3) --------------------------------------------------------
unsigned int __userpurge sub_100496E3<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  unsigned int result; // eax@2
  WCHAR LCData; // [sp+Ch] [bp-F4h]@1
  unsigned int v8; // [sp+FCh] [bp-4h]@1
  int v9; // [sp+100h] [bp+0h]@1

  v8 = (unsigned int)&v9 ^ __security_cookie;
  v3 = sub_10031BD7(a1, a2);
  v4 = *(_DWORD *)(sub_10031BD7(v3, a2) + 952);
  v5 = sub_10049B9D(a3);
  if ( GetLocaleInfoW(v5, *(_DWORD *)(v3 + 176) != 0 ? 7 : 4098, &LCData, 240) )
  {
    if ( !sub_10041BDB(v3, v4, *(_DWORD *)(v3 + 160), &LCData) )
    {
      if ( sub_10049C77(v5) )
      {
        *(_DWORD *)v4 |= 4u;
        *(_DWORD *)(v4 + 8) = v5;
        *(_DWORD *)(v4 + 4) = v5;
      }
    }
    result = ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
  }
  else
  {
    *(_DWORD *)v4 = 0;
    result = 1;
  }
  return result;
}
// 10067210: using guessed type int __security_cookie;

//----- (10049791) --------------------------------------------------------
int __usercall sub_10049791<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int result; // eax@1
  int v4; // eax@1

  v4 = sub_10031BD7(a1, a2);
  *(_DWORD *)(v4 + 176) = sub_10031399(*(_DWORD *)(v4 + 160)) == 3;
  EnumSystemLocalesW((LOCALE_ENUMPROCW)sub_100496E3, 1u);
  result = a3;
  if ( !(*(_BYTE *)a3 & 4) )
    *(_DWORD *)a3 = 0;
  return result;
}

//----- (100497D1) --------------------------------------------------------
BOOL __usercall sub_100497D1<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // esi@1
  int v4; // eax@1
  int v5; // ST00_4@1
  int v6; // eax@2
  BOOL result; // eax@4

  v4 = sub_10031BD7(a1, a2);
  v3 = v4 + 156;
  v5 = *(_DWORD *)(v4 + 160);
  *(_DWORD *)(v4 + 172) = sub_10031399(*(_DWORD *)(v4 + 156)) == 3;
  *(_DWORD *)(v3 + 20) = sub_10031399(v5) == 3;
  *(_DWORD *)(a3 + 4) = 0;
  if ( *(_DWORD *)(v3 + 16) )
    v6 = 2;
  else
    v6 = sub_100498A7(*(unsigned __int16 **)v3);
  *(_DWORD *)(v3 + 12) = v6;
  result = EnumSystemLocalesW((LOCALE_ENUMPROCW)sub_100498D1, 1u);
  if ( !(*(_DWORD *)a3 & 0x100) || !(*(_DWORD *)a3 & 0x200) || !(*(_BYTE *)a3 & 7) )
    *(_DWORD *)a3 = 0;
  return result;
}

//----- (1004984E) --------------------------------------------------------
int __usercall sub_1004984E<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // esi@1
  int v4; // eax@1
  bool v5; // eax@1
  int v6; // eax@2
  int result; // eax@4

  v4 = sub_10031BD7(a1, a2);
  v3 = v4;
  v5 = sub_10031399(*(_DWORD *)(v4 + 156)) == 3;
  *(_DWORD *)(v3 + 172) = v5;
  if ( v5 )
    v6 = 2;
  else
    v6 = sub_100498A7(*(unsigned __int16 **)(v3 + 156));
  *(_DWORD *)(v3 + 168) = v6;
  EnumSystemLocalesW((LOCALE_ENUMPROCW)sub_10049AC4, 1u);
  result = a3;
  if ( !(*(_BYTE *)a3 & 4) )
    *(_DWORD *)a3 = 0;
  return result;
}

//----- (100498A7) --------------------------------------------------------
int __cdecl sub_100498A7(unsigned __int16 *a1)
{
  int i; // edx@1
  unsigned __int16 *v2; // ecx@1
  unsigned __int16 v3; // ax@2

  v2 = a1;
  for ( i = 0; ; ++i )
  {
    v3 = *v2;
    ++v2;
    if ( v3 < 0x41u || v3 > 0x5Au )
    {
      if ( (unsigned __int16)(v3 - 97) > 0x19u )
        break;
    }
  }
  return i;
}

//----- (100498D1) --------------------------------------------------------
signed int __userpurge sub_100498D1<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // edx@13
  int v8; // eax@18
  int v9; // [sp-8h] [bp-108h]@22
  WCHAR LCData; // [sp+Ch] [bp-F4h]@1
  unsigned int v11; // [sp+FCh] [bp-4h]@1
  int v12; // [sp+100h] [bp+0h]@1

  v11 = (unsigned int)&v12 ^ __security_cookie;
  v3 = sub_10031BD7(a1, a2) + 156;
  v4 = *(_DWORD *)(sub_10031BD7(v3, a2) + 952);
  v5 = sub_10049B9D(a3);
  if ( !GetLocaleInfoW(v5, *(_DWORD *)(v3 + 20) != 0 ? 7 : 4098, &LCData, 240) )
    goto LABEL_2;
  if ( !sub_10041BDB(v3, v4, *(_DWORD *)(v3 + 4), &LCData) )
  {
    if ( !GetLocaleInfoW(v5, *(_DWORD *)(v3 + 16) != 0 ? 3 : 4097, &LCData, 240) )
      goto LABEL_2;
    if ( !sub_10041BDB(v3, v4, *(_DWORD *)v3, &LCData) )
    {
      *(_DWORD *)v4 |= 0x304u;
      *(_DWORD *)(v4 + 4) = v5;
LABEL_15:
      *(_DWORD *)(v4 + 8) = v5;
      goto LABEL_16;
    }
    if ( *(_BYTE *)v4 & 2 )
      goto LABEL_16;
    if ( !*(_DWORD *)(v3 + 12) || sub_1004C3F0(v3, v4, *(_DWORD *)v3, (int)&LCData, *(_DWORD *)(v3 + 12)) )
    {
      if ( !(*(_DWORD *)v4 & 1) && sub_10049C77(v5) )
      {
        *(_DWORD *)v4 = v7 | 1;
        goto LABEL_15;
      }
    }
    else
    {
      *(_DWORD *)v4 |= 2u;
      *(_DWORD *)(v4 + 8) = v5;
      if ( sub_10031399(*(_DWORD *)v3) == *(_DWORD *)(v3 + 12) )
        *(_DWORD *)(v4 + 4) = v5;
    }
  }
LABEL_16:
  if ( (*(_DWORD *)v4 & 0x300) == 768 )
    return ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
  if ( !GetLocaleInfoW(v5, *(_DWORD *)(v3 + 16) != 0 ? 3 : 4097, &LCData, 240) )
  {
LABEL_2:
    *(_DWORD *)v4 = 0;
    return 1;
  }
  v8 = sub_10041BDB(v3, v4, *(_DWORD *)v3, &LCData);
  if ( v8 )
  {
    if ( *(_DWORD *)(v3 + 16) || !*(_DWORD *)(v3 + 12) || sub_10041BDB(v3, v4, *(_DWORD *)v3, &LCData) )
      return ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
    v9 = 0;
  }
  else
  {
    *(_DWORD *)v4 |= 0x200u;
    if ( *(_DWORD *)(v3 + 16) || *(_DWORD *)(v3 + 12) == v8 || sub_10031399(*(_DWORD *)v3) != *(_DWORD *)(v3 + 12) )
      goto LABEL_28;
    v9 = 1;
  }
  if ( sub_10049C99(v3, v4, v5, v9) )
  {
LABEL_28:
    *(_DWORD *)v4 |= 0x100u;
    if ( !*(_DWORD *)(v4 + 4) )
      *(_DWORD *)(v4 + 4) = v5;
  }
  return ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
}
// 10067210: using guessed type int __security_cookie;

//----- (10049AC4) --------------------------------------------------------
signed int __userpurge sub_10049AC4<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // [sp-8h] [bp-108h]@5
  WCHAR LCData; // [sp+Ch] [bp-F4h]@1
  unsigned int v9; // [sp+FCh] [bp-4h]@1
  int v10; // [sp+100h] [bp+0h]@1

  v9 = (unsigned int)&v10 ^ __security_cookie;
  v3 = sub_10031BD7(a1, a2) + 156;
  v4 = *(_DWORD *)(sub_10031BD7(v3, a2) + 952);
  v5 = sub_10049B9D(a3);
  if ( !GetLocaleInfoW(v5, *(_DWORD *)(v3 + 16) != 0 ? 3 : 4097, &LCData, 240) )
  {
    *(_DWORD *)v4 = 0;
    return 1;
  }
  if ( sub_10041BDB(v3, v4, *(_DWORD *)v3, &LCData) )
  {
    if ( *(_DWORD *)(v3 + 16) || !*(_DWORD *)(v3 + 12) || sub_10041BDB(v3, v4, *(_DWORD *)v3, &LCData) )
      return ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
    v7 = 0;
  }
  else
  {
    if ( *(_DWORD *)(v3 + 16) )
    {
LABEL_11:
      *(_DWORD *)v4 |= 4u;
      *(_DWORD *)(v4 + 4) = v5;
      *(_DWORD *)(v4 + 8) = v5;
      return ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
    }
    v7 = 1;
  }
  if ( sub_10049C99(v3, v4, v5, v7) )
    goto LABEL_11;
  return ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
}
// 10067210: using guessed type int __security_cookie;

//----- (10049B9D) --------------------------------------------------------
int __cdecl sub_10049B9D(int a1)
{
  int v1; // edx@1
  int v2; // ecx@1
  int i; // esi@1

  v1 = a1;
  v2 = *(_WORD *)a1;
  for ( i = 0; (_WORD)v2; v2 = *(_WORD *)v1 )
  {
    v1 += 2;
    if ( (unsigned __int16)(v2 - 97) > 5u )
    {
      if ( (unsigned __int16)(v2 - 65) <= 5u )
        v2 += 65529;
    }
    else
    {
      v2 += 65497;
    }
    i = (unsigned __int16)v2 - 48 + 16 * i;
  }
  return i;
}

//----- (10049BEC) --------------------------------------------------------
int __usercall sub_10049BEC<eax>(int a1<ebx>, int a2<edi>, int LCData, int a4)
{
  int v4; // esi@1
  int result; // eax@6

  v4 = LCData;
  if ( LCData && *(_WORD *)LCData && sub_10048F07(LCData, (int)L"ACP") )
  {
    if ( sub_10048F07(v4, (int)L"OCP") )
      return sub_1004C32E(a1, a2, v4);
    if ( GetLocaleInfoW(*(_DWORD *)(a4 + 8), 0x2000000Bu, (LPWSTR)&LCData, 2) )
      return LCData;
    return 0;
  }
  if ( !GetLocaleInfoW(*(_DWORD *)(a4 + 8), 0x20001004u, (LPWSTR)&LCData, 2) )
    return 0;
  result = LCData;
  if ( !LCData )
    result = GetACP();
  return result;
}
// 1005B7F4: using guessed type wchar_t aAcp[4];
// 1005B7FC: using guessed type wchar_t aOcp[4];

//----- (10049C77) --------------------------------------------------------
signed int __cdecl sub_10049C77(__int16 a1)
{
  unsigned int v1; // eax@1

  v1 = 0;
  while ( a1 != *(__int16 *)((char *)&word_1005B804 + v1) )
  {
    v1 += 2;
    if ( v1 >= 0x14 )
      return 1;
  }
  return 0;
}
// 1005B804: using guessed type __int16 word_1005B804;

//----- (10049C99) --------------------------------------------------------
bool __usercall sub_10049C99<eax>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  int v4; // edi@1
  int v6; // esi@5
  WCHAR LCData[2]; // [sp+8h] [bp-4h]@1

  v4 = sub_10031BD7(a1, a2);
  return GetLocaleInfoW(a3 & 0x3FF | 0x400, 0x20000001u, LCData, 2)
      && (a3 == *(_DWORD *)LCData
       || !a4
       || (v6 = sub_100498A7(*(unsigned __int16 **)(v4 + 156)), v6 != sub_10031399(*(_DWORD *)(v4 + 156))));
}

//----- (10049D01) --------------------------------------------------------
bool __cdecl sub_10049D01(int a1, int a2, int *a3)
{
  signed int v3; // edx@1
  int i; // edi@1
  int v5; // esi@1
  int v6; // eax@3
  int v7; // ebx@3
  int v9; // [sp+14h] [bp+Ch]@3

  v5 = a2;
  v3 = 1;
  for ( i = 0; i <= v5; v6 ? (v6 >= 0 ? (i = v7 + 1) : (v5 = v7 - 1)) : (*a3 = v9 + 4 + a1) )
  {
    if ( !v3 )
      break;
    v7 = (i + v5) / 2;
    v9 = 12 * (i + v5) / 2;
    v6 = sub_10041BDB(v7, i, *a3, *(const WCHAR **)(v9 + a1));
    v3 = v6;
  }
  return v3 == 0;
}

//----- (10049D6D) --------------------------------------------------------
signed int __usercall sub_10049D6D<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // ecx@3
  int v7; // eax@25
  unsigned int v8; // esi@25
  int v10; // [sp+14h] [bp-10h]@1
  LCID Locale; // [sp+18h] [bp-Ch]@23
  LCID v12; // [sp+1Ch] [bp-8h]@23
  unsigned int v13; // [sp+20h] [bp-4h]@1
  int v14; // [sp+24h] [bp+0h]@1

  v13 = (unsigned int)&v14 ^ __security_cookie;
  v5 = sub_10031BD7(a1, a2) + 156;
  sub_10030CF0(&v10, 0, 12);
  *(_DWORD *)(sub_10031BD7(v5, a2) + 952) = &v10;
  if ( !a3 )
  {
    v10 |= 0x104u;
LABEL_23:
    Locale = GetUserDefaultLCID();
    v12 = Locale;
    goto LABEL_24;
  }
  a2 = v5 + 4;
  v6 = 0;
  *(_DWORD *)v5 = a3;
  *(_DWORD *)(v5 + 4) = a3 + 128;
  if ( a3 != -128 )
  {
    if ( *(_WORD *)(a3 + 128) )
    {
      sub_10049D01((int)&off_1005B518, dword_1005B7F0 - 1, (int *)(v5 + 4));
      v6 = 0;
    }
  }
  v10 = v6;
  if ( !*(_DWORD *)v5 || **(_WORD **)v5 == (_WORD)v6 )
  {
    if ( !*(_DWORD *)a2 || **(_WORD **)a2 == (_WORD)v6 )
    {
      v10 = 260;
      goto LABEL_23;
    }
    sub_10049791(v5, a2, (int)&v10);
LABEL_24:
    if ( !v10 )
      return 0;
    goto LABEL_25;
  }
  if ( *(_DWORD *)a2 && **(_WORD **)a2 != (_WORD)v6 )
    sub_100497D1(v5, a2, (int)&v10);
  else
    sub_1004984E(v5, a2, (int)&v10);
  if ( !v10 )
  {
    if ( sub_10049D01((int)&off_1005AA68, dword_1005B7EC - 1, (int *)v5) )
    {
      if ( *(_DWORD *)a2 && **(_WORD **)a2 )
        sub_100497D1(v5, a2, (int)&v10);
      else
        sub_1004984E(v5, a2, (int)&v10);
    }
    goto LABEL_24;
  }
LABEL_25:
  v7 = sub_10049BEC(v5, a2, a3 != 0 ? a3 + 256 : 0, (int)&v10);
  v8 = v7;
  if ( v7 && v7 != 65000 && v7 != 65001 && IsValidCodePage((unsigned __int16)v7) && IsValidLocale(Locale, 1u) )
  {
    if ( a4 )
      *(_DWORD *)a4 = v8;
    sub_10031747(Locale, v5 + 592, 85);
    if ( !a5 )
      return 1;
    sub_10031747(Locale, a5 + 288, 85);
    if ( GetLocaleInfoW(Locale, 4097u, (LPWSTR)a5, 64) && GetLocaleInfoW(v12, 0x1002u, (LPWSTR)(a5 + 128), 64) )
    {
      sub_1004C212(a5, (int)GetLocaleInfoW, v8, a5 + 256, 0x10u, 0xAu);
      return 1;
    }
  }
  return 0;
}
// 1005AA68: using guessed type wchar_t *off_1005AA68;
// 1005B518: using guessed type wchar_t *off_1005B518;
// 1005B7EC: using guessed type int dword_1005B7EC;
// 1005B7F0: using guessed type int dword_1005B7F0;
// 10067210: using guessed type int __security_cookie;

//----- (10049F90) --------------------------------------------------------
int __thiscall sub_10049F90(void *this, unsigned int a2, unsigned __int8 a3)
{
  signed int v4; // eax@3
  int v5; // edx@3
  int v8; // ecx@4
  int v10; // eax@5
  int result; // eax@8
  char v27; // cf@18
  char v28; // zf@18
  signed int v31; // edx@22
  signed int v38; // ecx@25
  unsigned int v39; // edi@25
  char v40; // zf@27
  int v41; // ecx@29
  int v42; // edi@29
  char v43; // zf@31
  int v44; // edi@33

  if ( (unsigned int)dword_100695C0 < 1 )
  {
    v39 = a2;
    v38 = -1;
    do
    {
      if ( !v38 )
        break;
      v40 = *(_BYTE *)v39++ == 0;
      --v38;
    }
    while ( !v40 );
    v41 = -(v38 + 1);
    v42 = v39 - 1;
    do
    {
      if ( !v41 )
        break;
      v43 = *(_BYTE *)v42++ == a3;
      --v41;
    }
    while ( !v43 );
    v44 = v42 + 1;
    if ( *(_BYTE *)v44 == a3 )
      result = v44;
    else
      result = 0;
  }
  else
  {
    _EDI = a2;
    if ( (unsigned int)dword_100695C0 > 1 )
    {
      _EDX = a3;
      if ( a3 )
      {
        result = 0;
        if ( a2 & 0xF )
        {
          while ( 1 )
          {
            this = (void *)*(_BYTE *)_EDI;
            if ( this == (void *)a3 )
              result = _EDI;
            if ( !*(_BYTE *)_EDI )
              break;
            ++_EDI;
            if ( !(_EDI & 0xF) )
              goto LABEL_17;
          }
        }
        else
        {
LABEL_17:
          __asm { movd    xmm0, edx }
          do
          {
            v27 = _EDI >= 0xFFFFFFF0;
            v28 = _EDI == -16;
            _EDI += 16;
            __asm { pcmpistri xmm0, xmmword ptr [edi-10h], 40h }
            this += _EDI - 16;
            if ( v27 )
              result = (int)this;
          }
          while ( !v28 );
        }
      }
      else
      {
        _EAX = a2 & 0xFFFFFFF0;
        __asm
        {
          pxor    xmm0, xmm0
          pcmpeqb xmm0, xmmword ptr [eax]
        }
        v31 = -1 << (a2 & 0xF);
        __asm { pmovmskb edi, xmm0 }
        _EDI = v31 & _EDI;
        while ( !_EDI )
        {
          __asm
          {
            pxor    xmm0, xmm0
            pcmpeqb xmm0, xmmword ptr [eax+10h]
          }
          _EAX += 16;
          __asm { pmovmskb edi, xmm0 }
        }
        __asm { bsf     edx, edi }
        result = _EDX + _EAX;
      }
    }
    else
    {
      _EDX = a3 | (a3 << 8);
      __asm
      {
        movd    xmm3, edx
        pshuflw xmm3, xmm3, 0
        movlhps xmm3, xmm3
      }
      v4 = -1 << (a2 & 0xF);
      _EDI = a2 - (a2 & 0xF);
      v5 = 0;
      while ( 1 )
      {
        __asm
        {
          movdqu  xmm1, xmmword ptr [edi]
          pxor    xmm2, xmm2
          pcmpeqb xmm2, xmm1
          pcmpeqb xmm1, xmm3
          pmovmskb ecx, xmm2
        }
        v8 = v4 & _ECX;
        if ( v8 )
          break;
        __asm { pmovmskb ecx, xmm1 }
        _ECX = v4 & _ECX;
        __asm { bsr     eax, ecx }
        v10 = _EDI + _EAX;
        if ( _ECX )
          v5 = v10;
        v4 = -1;
        _EDI += 16;
      }
      __asm { pmovmskb ebx, xmm1 }
      _ECX = v4 & _EBX & ((-2 * v8 & 2 * v8) - 1);
      __asm { bsr     eax, ecx }
      result = _EDI + _EAX;
      if ( !_ECX )
        result = v5;
    }
  }
  return result;
}
// 100695C0: using guessed type int dword_100695C0;

//----- (1004A0C7) --------------------------------------------------------
signed int __usercall sub_1004A0C7<eax>(int a1<ebx>, int a2, unsigned int a3, int a4, int a5)
{
  int v5; // edx@1
  int v6; // edi@1
  int v7; // eax@2
  int v9; // ecx@5
  int v10; // eax@6
  int v11; // eax@10
  char v12; // dl@11
  int v13; // eax@24
  signed int v14; // [sp-4h] [bp-Ch]@2

  v5 = a5;
  v6 = *(_DWORD *)(a5 + 12);
  if ( !a2 || !a3 )
  {
    v7 = sub_1002F144(a1);
    v14 = 22;
LABEL_3:
    *(_DWORD *)v7 = v14;
    sub_10036C88(a1, v6);
    return v14;
  }
  v9 = a4;
  *(_BYTE *)a2 = 0;
  if ( a4 <= 0 )
    v10 = 0;
  else
    v10 = a4;
  if ( a3 <= v10 + 1 )
  {
    v7 = sub_1002F144(a1);
    v14 = 34;
    goto LABEL_3;
  }
  *(_BYTE *)a2 = 48;
  v11 = a2 + 1;
  if ( a4 > 0 )
  {
    do
    {
      v12 = *(_BYTE *)v6;
      if ( *(_BYTE *)v6 )
        ++v6;
      else
        v12 = 48;
      *(_BYTE *)v11++ = v12;
      --v9;
    }
    while ( v9 > 0 );
    v5 = a5;
  }
  *(_BYTE *)v11 = 0;
  if ( v9 >= 0 )
  {
    if ( *(_BYTE *)v6 >= 53 )
    {
      while ( 1 )
      {
        --v11;
        if ( *(_BYTE *)v11 != 57 )
          break;
        *(_BYTE *)v11 = 48;
      }
      ++*(_BYTE *)v11;
    }
  }
  if ( *(_BYTE *)a2 == 49 )
  {
    ++*(_DWORD *)(v5 + 4);
  }
  else
  {
    v13 = sub_1002CFA0(a2 + 1);
    sub_100237D0((void *)a2, (const void *)(a2 + 1), v13 + 1);
  }
  return 0;
}

//----- (1004A177) --------------------------------------------------------
signed int __usercall sub_1004A177<eax>(int a1<ebx>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  signed int v5; // ebx@1
  signed int v7; // [sp-4h] [bp-38h]@4
  char v8; // [sp+Ch] [bp-28h]@1
  int v9; // [sp+14h] [bp-20h]@10
  char v10; // [sp+18h] [bp-1Ch]@9
  char v11; // [sp+1Ch] [bp-18h]@1
  int v12; // [sp+20h] [bp-14h]@1
  char v13; // [sp+24h] [bp-10h]@1
  unsigned int v14; // [sp+30h] [bp-4h]@1
  int v15; // [sp+34h] [bp+0h]@1

  v14 = (unsigned int)&v15 ^ __security_cookie;
  sub_1002E635((int)&v8, a1, a2, a4);
  v5 = 0;
  v12 = sub_1004D07B((int)&v13, (int)&v11, a3, 0, 0, 0, 0, (int)&v8);
  v4 = sub_1004C59B((int)&v13, a2);
  if ( !(v12 & 3) )
  {
    if ( v4 != 1 )
    {
      if ( v4 != 2 )
        goto LABEL_9;
      goto LABEL_4;
    }
LABEL_7:
    v7 = 3;
    goto LABEL_8;
  }
  if ( !(v12 & 1) )
  {
    if ( !(v12 & 2) )
      goto LABEL_9;
    goto LABEL_7;
  }
LABEL_4:
  v7 = 4;
LABEL_8:
  v5 = v7;
LABEL_9:
  if ( v10 )
    *(_DWORD *)(v9 + 112) &= 0xFFFFFFFDu;
  return v5;
}
// 10067210: using guessed type int __security_cookie;

//----- (1004A203) --------------------------------------------------------
signed int __usercall sub_1004A203<eax>(int a1<ebx>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  signed int v5; // ebx@1
  signed int v7; // [sp-4h] [bp-38h]@4
  char v8; // [sp+Ch] [bp-28h]@1
  int v9; // [sp+14h] [bp-20h]@10
  char v10; // [sp+18h] [bp-1Ch]@9
  char v11; // [sp+1Ch] [bp-18h]@1
  int v12; // [sp+20h] [bp-14h]@1
  char v13; // [sp+24h] [bp-10h]@1
  unsigned int v14; // [sp+30h] [bp-4h]@1
  int v15; // [sp+34h] [bp+0h]@1

  v14 = (unsigned int)&v15 ^ __security_cookie;
  sub_1002E635((int)&v8, a1, a2, a4);
  v5 = 0;
  v12 = sub_1004D07B((int)&v13, (int)&v11, a3, 0, 0, 0, 0, (int)&v8);
  v4 = sub_1004CB0B((int)&v13, a2);
  if ( !(v12 & 3) )
  {
    if ( v4 != 1 )
    {
      if ( v4 != 2 )
        goto LABEL_9;
      goto LABEL_4;
    }
LABEL_7:
    v7 = 3;
    goto LABEL_8;
  }
  if ( !(v12 & 1) )
  {
    if ( !(v12 & 2) )
      goto LABEL_9;
    goto LABEL_7;
  }
LABEL_4:
  v7 = 4;
LABEL_8:
  v5 = v7;
LABEL_9:
  if ( v10 )
    *(_DWORD *)(v9 + 112) &= 0xFFFFFFFDu;
  return v5;
}
// 10067210: using guessed type int __security_cookie;

//----- (1004A28F) --------------------------------------------------------
__int16 __cdecl sub_1004A28F(int a1, int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  signed int v4; // ebx@1
  __int16 v5; // di@1
  unsigned int v6; // esi@1
  int v7; // edx@1
  int v8; // eax@3
  int v9; // esi@10
  int v10; // edi@11
  __int16 v12; // [sp+Ch] [bp-8h]@1
  unsigned int v13; // [sp+10h] [bp-4h]@1
  int v14; // [sp+20h] [bp+Ch]@13

  v7 = *(_DWORD *)(a2 + 4);
  v3 = ((unsigned int)*(_WORD *)(a2 + 6) >> 4) & 0x7FF;
  v5 = *(_WORD *)(a2 + 6) & 0x8000;
  v6 = ((unsigned int)*(_WORD *)(a2 + 6) >> 4) & 0x7FF;
  v2 = v7 & 0xFFFFF;
  v4 = -2147483648;
  v12 = *(_WORD *)(a2 + 6) & 0x8000;
  v13 = *(_DWORD *)a2;
  if ( !v6 )
  {
    if ( !v2 && !*(_DWORD *)a2 )
    {
      v8 = a1;
      *(_DWORD *)(v8 + 4) &= v2;
      *(_DWORD *)v8 &= v2;
      *(_WORD *)(a1 + 8) = v5;
      return v8;
    }
    v8 = v3 + 15361;
    v4 = 0;
    goto LABEL_9;
  }
  if ( v6 != 2047 )
  {
    v8 = v3 + 15360;
LABEL_9:
    v8 = (unsigned __int16)v8;
    goto LABEL_10;
  }
  v8 = 32767;
LABEL_10:
  v9 = v4 | (v2 << 11) | (v13 >> 21);
  *(_DWORD *)(a1 + 4) = v9;
  *(_DWORD *)a1 = v13 << 11;
  if ( v9 >= 0 )
  {
    v10 = v8;
    do
    {
      v10 += 65535;
      v9 = (*(_DWORD *)a1 >> 31) | 2 * v9;
      *(_DWORD *)a1 *= 2;
    }
    while ( v9 >= 0 );
    v14 = v10;
    v5 = v12;
    LOWORD(v8) = v14;
    *(_DWORD *)(a1 + 4) = v9;
  }
  *(_WORD *)(a1 + 8) = v8 | v5;
  return v8;
}

//----- (1004A3F0) --------------------------------------------------------
int __stdcall sub_1004A3F0(unsigned __int64 a1, __int64 a2)
{
  signed int v2; // edi@1
  int v3; // eax@3
  int v4; // esi@6
  unsigned __int64 v5; // qtt@6
  unsigned __int64 v6; // qax@7
  unsigned int v7; // ecx@7
  unsigned int v8; // ebx@7
  char v9; // cf@8
  char v10; // cf@8
  int v11; // eax@9
  unsigned __int64 v12; // qax@9
  int v13; // ecx@9
  char v14; // cf@9
  int result; // eax@13

  v2 = 0;
  if ( HIDWORD(a1) < 0 )
  {
    v2 = 1;
    HIDWORD(a1) = -HIDWORD(a1) - ((_DWORD)a1 != 0);
    LODWORD(a1) = -(_DWORD)a1;
  }
  v3 = HIDWORD(a2);
  if ( HIDWORD(a2) < 0 )
  {
    ++v2;
    v3 = -HIDWORD(a2) - ((_DWORD)a2 != 0);
    HIDWORD(a2) = -HIDWORD(a2) - ((_DWORD)a2 != 0);
    LODWORD(a2) = -(_DWORD)a2;
  }
  if ( v3 )
  {
    v8 = v3;
    v7 = a2;
    v6 = a1;
    do
    {
      v9 = v8 & 1;
      v8 >>= 1;
      v7 = __RCR__(v7, v9);
      v10 = BYTE4(v6) & 1;
      HIDWORD(v6) >>= 1;
      LODWORD(v6) = __RCR__(v6, v10);
    }
    while ( v8 );
    v11 = v6 / v7;
    v4 = v11;
    v13 = HIDWORD(a2) * v11;
    v12 = v11 * (unsigned int)a2;
    v14 = v13 >= (unsigned int)-HIDWORD(v12);
    HIDWORD(v12) += v13;
    if ( v14 || HIDWORD(v12) > HIDWORD(a1) || v12 > a1 )
      --v4;
  }
  else
  {
    LODWORD(v5) = a1;
    HIDWORD(v5) = HIDWORD(a1) % (_DWORD)a2;
    v4 = v5 / (unsigned int)a2;
  }
  result = v4;
  if ( v2 == 1 )
    result = -v4;
  return result;
}

//----- (1004A4D0) --------------------------------------------------------
unsigned __int64 __usercall sub_1004A4D0<edx:eax>(unsigned __int64 a1<edx:eax>, unsigned __int8 a2<cl>)
{
  unsigned __int64 result; // qax@2

  if ( a2 >= 0x40u )
    result = 0i64;
  else
    result = a1 >> a2;
  return result;
}

//----- (1004A4EF) --------------------------------------------------------
signed int __usercall sub_1004A4EF<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  signed int result; // eax@4
  int v6; // [sp-4h] [bp-8h]@5

  if ( a5 & 0xFFF7FFFF & a4 & 0xFCF0FCE0 )
  {
    if ( a3 )
      *(_DWORD *)a3 = sub_1004E264(0, 0);
    *(_DWORD *)sub_1002F144(a1) = 22;
    sub_10036C88(a1, a2);
    result = 22;
  }
  else
  {
    v6 = a5 & 0xFFF7FFFF;
    if ( a3 )
      *(_DWORD *)a3 = sub_1004E264(a4, v6);
    else
      sub_1004E264(a4, v6);
    result = 0;
  }
  return result;
}

//----- (1004A54C) --------------------------------------------------------
void __usercall sub_1004A54C(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  sub_1003234D(a1, a2, a3, a4, 2);
}

//----- (1004A555) --------------------------------------------------------
WCHAR __usercall sub_1004A555<ax>(int a1<ebx>, int a2<edi>, const WCHAR SrcStr, int a4)
{
  WCHAR result; // ax@1
  int v5; // eax@2
  void *v6; // ecx@2
  int v7; // esi@2
  WCHAR v8; // cx@3
  int v9; // [sp+0h] [bp-14h]@2
  int v10; // [sp+8h] [bp-Ch]@17
  char v11; // [sp+Ch] [bp-8h]@16
  WCHAR DestStr; // [sp+10h] [bp-4h]@12

  result = -1;
  if ( SrcStr != -1 )
  {
    sub_1002E635((int)&v9, a1, a2, a4);
    v7 = v9;
    v5 = *(_DWORD *)(v9 + 168);
    if ( v5 )
    {
      if ( SrcStr >= 0x100u )
      {
        if ( sub_1003197D(v5, 0x100u, &SrcStr, 1u, &DestStr, 1) )
          result = DestStr;
        else
          result = SrcStr;
      }
      else
      {
        if ( sub_1004A607(v6, SrcStr, 1) )
          result = *(_BYTE *)(*(_DWORD *)(v7 + 148) + SrcStr);
        else
          result = SrcStr;
      }
    }
    else
    {
      v8 = SrcStr;
      if ( (unsigned __int16)(SrcStr - 65) <= 0x19u )
        v8 = SrcStr + 32;
      result = v8;
    }
    if ( v11 )
      *(_DWORD *)(v10 + 112) &= 0xFFFFFFFDu;
  }
  return result;
}

//----- (1004A607) --------------------------------------------------------
int __thiscall sub_1004A607(void *this, const WCHAR SrcStr, __int16 a3)
{
  int result; // eax@2
  int v4; // eax@4
  BOOL v5; // eax@5
  WORD CharType[2]; // [sp+0h] [bp-4h]@1

  *(_DWORD *)CharType = this;
  if ( SrcStr == -1 )
  {
    result = 0;
  }
  else
  {
    if ( SrcStr >= 0x100u )
    {
      v5 = GetStringTypeW(1u, &SrcStr, 1, CharType);
      v4 = v5 != 0 ? *(_DWORD *)CharType : 0;
    }
    else
    {
      LOWORD(v4) = *((_WORD *)off_10067094 + SrcStr);
    }
    result = (unsigned __int16)(a3 & v4);
  }
  return result;
}
// 10067094: using guessed type void *off_10067094;

//----- (1004A659) --------------------------------------------------------
int __usercall sub_1004A659<eax>(int a1<ebp>, int a2, int a3, int a4)
{
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // eax@1
  int v7; // eax@2
  int v8; // eax@3
  int v9; // eax@4
  int v10; // eax@5
  int v11; // eax@6
  signed int v12; // edi@14
  double v13; // ST10_8@14
  int v15; // ST18_4@26
  int v16; // ST1C_4@26
  char v17; // ST20_1@26
  signed int v18; // [sp-98h] [bp-A0h]@8
  int v19; // [sp-88h] [bp-90h]@1
  char v20; // [sp-84h] [bp-8Ch]@20
  double v21; // [sp-54h] [bp-5Ch]@19
  int v22; // [sp-44h] [bp-4Ch]@18
  unsigned int v23; // [sp-8h] [bp-10h]@1
  int v24; // [sp-4h] [bp-Ch]@1
  void *v25; // [sp+0h] [bp-8h]@1
  char v26; // [sp+4h] [bp-4h]@25
  int v27; // [sp+8h] [bp+0h]@1

  v24 = a1;
  v25 = (void *)v27;
  v23 = (unsigned int)&v24 ^ __security_cookie;
  v5 = *(_WORD *)a4;
  v6 = *(_DWORD *)a3;
  v19 = *(_WORD *)a4;
  v4 = v6 - 1;
  if ( !v4 )
    goto LABEL_29;
  v7 = v4 - 1;
  if ( !v7 )
  {
    v18 = 4;
    goto LABEL_14;
  }
  v8 = v7 - 1;
  if ( !v8 )
  {
    v18 = 17;
    goto LABEL_14;
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
    v18 = 18;
    goto LABEL_14;
  }
  v10 = v9 - 1;
  if ( !v10 )
  {
LABEL_29:
    v18 = 8;
    goto LABEL_14;
  }
  v11 = v10 - 2;
  if ( !v11 )
  {
    *(_DWORD *)a3 = 1;
    goto LABEL_22;
  }
  if ( v11 == 1 )
  {
    v18 = 16;
LABEL_14:
    v12 = v18;
    HIDWORD(v13) = v5;
    LODWORD(v13) = a3 + 24;
    if ( !sub_100409FA(v12, v13) )
    {
      if ( a2 == 16 || a2 == 22 || a2 == 29 )
      {
        v21 = *(double *)(a3 + 16);
        v22 = v22 & 0xFFFFFFE3 | 3;
      }
      else
      {
        v22 &= 0xFFFFFFFEu;
      }
      sub_10040C26((ULONG_PTR)&v20, (int)&v19, v12, a2, a3 + 8, a3 + 24);
    }
    LOWORD(v5) = v19;
  }
LABEL_22:
  sub_1004107C(v5);
  if ( *(_DWORD *)a3 == 8 || dword_10068400 || !sub_1003AF6A() )
    sub_10040F2C((int)&v26, *(_DWORD *)a3);
  return sub_10022B30((int)&v26, v15, v16, (unsigned int)&v24 ^ v23, v17);
}
// 1004A659: could not find valid save-restore pair for ebp
// 10067210: using guessed type int __security_cookie;
// 10068400: using guessed type int dword_10068400;

//----- (1004A7AC) --------------------------------------------------------
void __usercall sub_1004A7AC(int a1<ebx>, __int64 a2<st0>, int edx0<edx>, __int16 a4<cx>, __int16 a3<fpstat>, char c0_0, char c2_0, char a8, char a5, char a6, char a7)
{
  char v11; // zf@2
  int v12; // ST04_4@2
  int v13; // eax@2
  char v14; // ST00_1@3

  if ( !dword_1006A390 )
    goto LABEL_9;
  __asm { stmxcsr [esp+8+var_4] }
  v13 = v12 & 0x7F80;
  v11 = v13 == 8064;
  if ( v13 == 8064 )
    v11 = (v14 & 0x7F) == 127;
  if ( v11 )
    sub_1004E610(a1, a2);
  else
LABEL_9:
    sub_1004EB0E((int)&unk_1005BE2A, a4, a3, *(double *)&a2, a5, a6, a7);
}
// 1006A390: using guessed type int dword_1006A390;

//----- (1004A7FB) --------------------------------------------------------
int __thiscall sub_1004A7FB(int this, int a2, int a3, int a4)
{
  int v5; // edi@1

  v5 = this;
  *(_DWORD *)this = off_1005B81C;
  *(_DWORD *)(this + 4) = 0;
  sub_100427ED(this + 8, a2, a3, a4);
  *(_WORD *)(v5 + 68) = 0;
  *(_DWORD *)(v5 + 76) = 0;
  _ECX = &unk_1006A074;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  *(_DWORD *)(v5 + 72) = _EAX + 1;
  *(_DWORD *)(v5 + 36) = v5;
  return v5;
}
// 1005B81C: using guessed type int (*off_1005B81C[2])();

//----- (1004A842) --------------------------------------------------------
int __thiscall sub_1004A842(int this, char a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_1005B81C;
  *(_DWORD *)(this + 8) = off_1005A88C;
  if ( a2 & 1 )
    sub_1002404A((LPVOID)this);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005A88C: using guessed type int (*off_1005A88C[2])();
// 1005B81C: using guessed type int (*off_1005B81C[2])();

//----- (1004A869) --------------------------------------------------------
int __thiscall sub_1004A869(int this)
{
  return (*(int (**)(void))(*(_DWORD *)(this + 8) + 12))();
}

//----- (1004A871) --------------------------------------------------------
int __thiscall sub_1004A871(int this)
{
  return *(_DWORD *)(this + 72);
}

//----- (1004A875) --------------------------------------------------------
int __thiscall sub_1004A875(int this)
{
  return (**(int (***)(void))(this + 8))();
}

//----- (1004A87C) --------------------------------------------------------
int __thiscall sub_1004A87C(int this, int a2)
{
  int v2; // esi@1
  int v4; // [sp-4h] [bp-14h]@3
  int (__stdcall **v5)(char); // [sp+4h] [bp-Ch]@3

  v2 = this;
  if ( !a2 )
  {
    a2 = (int)"pScheduler";
    sub_10023687((int)&v5, &a2);
    v5 = &off_100542CC;
    v4 = (int)&unk_10061764;
    goto LABEL_6;
  }
  if ( *(_DWORD *)(*(_DWORD *)(this + 28) + 8) != a2 )
  {
    sub_10024950((int)&v5);
    v4 = (int)&unk_100614E0;
LABEL_6:
    sub_1002D02B((int)&v5, v4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1004A8E1);
  }
  sub_1004A8E1(this);
  return sub_10043983(v2);
}
// 10043983: using guessed type _DWORD __stdcall sub_10043983(_DWORD);
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);

//----- (1004A8E1) --------------------------------------------------------
int __thiscall sub_1004A8E1(int this)
{
  int result; // eax@1

  result = this + 76;
  _EDX = -1;
  __asm { lock xadd [eax], edx }
  if ( _EDX == 1 )
    result = sub_1004A906(this);
  return result;
}

//----- (1004A8F9) --------------------------------------------------------
int __thiscall sub_1004A8F9(int this)
{
  return sub_10043D88(*(_DWORD *)(this + 28), this + 8);
}

//----- (1004A906) --------------------------------------------------------
int __thiscall sub_1004A906(int this)
{
  return sub_1004380F(*(_DWORD *)(this + 28), this + 8);
}

//----- (1004A913) --------------------------------------------------------
int __thiscall sub_1004A913(int this, int a2, int a3, int a4)
{
  int v5; // esi@1

  v5 = this;
  sub_1004A7FB(this, a2, a3, a4);
  *(_DWORD *)v5 = off_1005B848;
  *(_DWORD *)(v5 + 80) = 0;
  *(_DWORD *)(v5 + 84) = 0;
  return v5;
}
// 1005B848: using guessed type int (*off_1005B848[2])();

//----- (1004A942) --------------------------------------------------------
bool __thiscall sub_1004A942(int this, int a2)
{
  return *(_WORD *)(a2 + 4) == *(_WORD *)(this + 4) && *(_DWORD *)a2 == *(_DWORD *)this;
}

//----- (1004A963) --------------------------------------------------------
int __thiscall sub_1004A963(void *this)
{
  void *v1; // esi@1
  int result; // eax@4
  char v3; // [sp+8h] [bp-10h]@2
  int v4; // [sp+10h] [bp-8h]@1
  void (__cdecl *v5)(); // [sp+14h] [bp-4h]@1

  v1 = this;
  v4 = 0;
  v5 = sub_1002C630;
  while ( !*((_DWORD *)v1 + 1) )
    sub_1001FF20((int)&v3);
  result = *((_DWORD *)v1 + 1);
  *((_DWORD *)v1 + 1) = 0;
  return result;
}

//----- (1004A992) --------------------------------------------------------
BOOL __thiscall sub_1004A992(void *this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v4; // ebx@2
  BOOL result; // eax@5
  int v13; // eax@8
  int v14; // [sp-4h] [bp-28h]@12
  char v15; // [sp+Ch] [bp-18h]@8
  int (__stdcall **v16)(char); // [sp+18h] [bp-Ch]@11

  v2 = a2;
  v3 = (int)this;
  if ( !a2 )
  {
    a2 = (int)"pContext";
    sub_10023687((int)&v16, &a2);
    v16 = &off_100542CC;
    v14 = (int)&unk_10061764;
    v13 = (int)&v16;
    goto LABEL_12;
  }
  v4 = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 8))(a2);
  if ( !v4 )
  {
    v14 = v2;
    v4 = (*(int (**)(void))(**(_DWORD **)(v3 + 28) + 28))();
  }
  _EAX = v3 + 76;
  _ECX = 1;
  __asm { lock xadd [eax], ecx }
  if ( _ECX == 1 )
  {
    result = v3 + 4;
    *(_DWORD *)(v3 + 4) = v2;
    return result;
  }
  sub_1004AC97((void *)v3);
  if ( *(_DWORD *)(v3 + 80) && v4 != *(_DWORD *)(v3 + 80) )
  {
    sub_10024950((int)&v15);
    v13 = (int)&v15;
LABEL_12:
    sub_1002D02B(v13, v14);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1004AA44);
  }
  *(_DWORD *)(v3 + 84) = 0;
  sub_1004A8F9(v3);
  sub_1004AA44((void *)v3, v4);
  return sub_1004B3F3(v4);
}
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);

//----- (1004AA44) --------------------------------------------------------
int __thiscall sub_1004AA44(void *this, int a2)
{
  void *v3; // esi@1
  int v4; // ebx@1
  int v5; // eax@1

  v3 = this;
  sub_1004B447(a2);
  *((_DWORD *)v3 + 20) = a2;
  *(_DWORD *)(a2 + 16) = v3;
  v4 = *((_DWORD *)v3 + 7);
  v5 = (**(int (__thiscall ***)(void *))v3)(v3);
  return sub_1004AC61(
           (void *)a2,
           *(_DWORD *)(52 * v5 + *(_DWORD *)(v4 + 16)),
           *(_WORD *)(52 * v5 + *(_DWORD *)(v4 + 16) + 12),
           0);
}

//----- (1004AAA1) --------------------------------------------------------
char __thiscall sub_1004AAA1(int this, int a2)
{
  int v2; // esi@1
  char *v3; // eax@3
  int v4; // edi@4
  LPVOID v13; // eax@11
  int v14; // esi@11
  int v15; // ecx@11
  int v16; // eax@13
  int v17; // [sp-4h] [bp-30h]@3
  int v18; // [sp-4h] [bp-30h]@11
  char v19; // [sp+8h] [bp-24h]@5
  char v20; // [sp+14h] [bp-18h]@3
  int (__stdcall **v21)(char); // [sp+20h] [bp-Ch]@10

  v2 = this;
  if ( !a2 )
  {
    a2 = (int)"pContext";
    sub_10023687((int)&v21, &a2);
    v21 = &off_100542CC;
    v17 = (int)&unk_10061764;
    v3 = (char *)&v21;
LABEL_11:
    sub_1002D02B((int)v3, v17);
    __asm { int     3               ; Trap to Debugger }
    v18 = v2;
    v14 = v15;
    v13 = TlsGetValue(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v15 + 28) + 12) + 112));
    if ( v13 && ((_BYTE)v13 & 3) == 1 && (v16 = (unsigned int)v13 & 0xFFFFFFFE) != 0 && v16 == *(_DWORD *)(v14 + 80) )
      *(_DWORD *)(v16 + 16) = 0;
    else
      sub_1004AC97((void *)v14);
    return (*(int (__thiscall **)(int, signed int, int))(*(_DWORD *)v14 + 32))(v14, 1, v18);
  }
  if ( !*(_DWORD *)(this + 80) )
  {
    sub_10024950((int)&v20);
    v17 = (int)&unk_100614E0;
    v3 = &v20;
    goto LABEL_11;
  }
  v4 = (*(int (**)(void))(*(_DWORD *)a2 + 8))();
  if ( *(_DWORD *)(v2 + 80) != v4 )
  {
    sub_10024950((int)&v19);
    v17 = (int)&unk_100614E0;
    v3 = &v19;
    goto LABEL_11;
  }
  _EAX = v2 + 76;
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  if ( _ECX == 1 )
  {
    *(_DWORD *)(v2 + 84) = *(_DWORD *)(v2 + 80);
    sub_1004A906(v2);
    sub_1004B472(v4);
  }
  else
  {
    sub_1004A963((void *)v2);
  }
  return 1;
}
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);

//----- (1004AB87) --------------------------------------------------------
BOOL __thiscall sub_1004AB87(int this, int a2)
{
  int v2; // esi@1
  char *v3; // eax@3
  int v5; // [sp-4h] [bp-2Ch]@3
  char v6; // [sp+4h] [bp-24h]@5
  char v7; // [sp+10h] [bp-18h]@3
  int (__stdcall **v8)(char); // [sp+1Ch] [bp-Ch]@7

  v2 = this;
  if ( !a2 )
  {
    a2 = (int)"pContext";
    sub_10023687((int)&v8, &a2);
    v8 = &off_100542CC;
    v5 = (int)&unk_10061764;
    v3 = (char *)&v8;
    goto LABEL_8;
  }
  if ( !*(_DWORD *)(this + 80) )
  {
    sub_10024950((int)&v7);
    v5 = (int)&unk_100614E0;
    v3 = &v7;
LABEL_8:
    sub_1002D02B((int)v3, v5);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1004AC04);
  }
  if ( *(_DWORD *)(this + 80) != (*(int (**)(void))(*(_DWORD *)a2 + 8))() )
  {
    sub_10024950((int)&v6);
    v5 = (int)&unk_100614E0;
    v3 = &v6;
    goto LABEL_8;
  }
  return sub_100349BD(*(_DWORD *)(*(_DWORD *)(v2 + 28) + 12));
}
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);

//----- (1004AC04) --------------------------------------------------------
int __thiscall sub_1004AC04(int this, int a2)
{
  int result; // eax@1
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // esi@1
  int v12; // esi@6
  int v13; // eax@6

  v5 = this;
  v4 = *(_DWORD *)(this + 80);
  result = this + 76;
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  v3 = _ECX - 1;
  if ( v3 > 0 )
  {
    v13 = sub_1004A963((void *)v5);
    v12 = v13;
    result = (*(int (__thiscall **)(int))(*(_DWORD *)v13 + 8))(v13);
    if ( v4 != result )
      result = (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v4 + 4))(v4, v12, a2);
  }
  else
  {
    if ( !v3 )
      result = sub_1004A906(v5);
    *(_DWORD *)(v5 + 80) = 0;
    if ( a2 == 1 )
      result = sub_1004B472(v4);
  }
  return result;
}

//----- (1004AC61) --------------------------------------------------------
int __thiscall sub_1004AC61(void *this, int a2, __int16 a3, int a4)
{
  void *v4; // edi@1
  int result; // eax@3

  v4 = this;
  if ( !sub_1004A942((int)((char *)this + 48), (int)&a2) )
    sub_10033113((DWORD_PTR *)&a2, *((HANDLE *)v4 + 2));
  *((_WORD *)v4 + 26) = a3;
  result = a2;
  *((_DWORD *)v4 + 12) = a2;
  return result;
}

//----- (1004AC97) --------------------------------------------------------
char __thiscall sub_1004AC97(void *this)
{
  void *v1; // esi@1
  char result; // al@3
  char v3; // [sp+8h] [bp-10h]@3
  int v4; // [sp+10h] [bp-8h]@1
  void (__cdecl *v5)(); // [sp+14h] [bp-4h]@1

  v1 = this;
  v4 = 0;
  v5 = sub_1002C630;
  while ( *((_DWORD *)v1 + 20) && !*((_DWORD *)v1 + 21) )
    result = sub_1001FF20((int)&v3);
  return result;
}

//----- (1004ACC5) --------------------------------------------------------
int __thiscall sub_1004ACC5(int this, int a2)
{
  *(_DWORD *)(this + 64) = a2;
  return (*(int (__stdcall **)(int))(*(_DWORD *)a2 + 12))(this);
}

//----- (1004ACDA) --------------------------------------------------------
void __fastcall sub_1004ACDA(int a1)
{
  int v1; // esi@1
  DWORD v2; // eax@2
  int v3; // edi@3
  int v4; // [sp+8h] [bp-8h]@1
  int v5; // [sp+Ch] [bp-4h]@1

  v1 = a1;
  v4 = 8;
  v5 = 0;
  if ( !*(_DWORD *)(a1 + 36) )
  {
    v2 = (*(int (**)(void))(**(_DWORD **)(a1 + 4) + 16))();
    TlsSetValue(v2, (LPVOID)(v1 | 1));
    while ( !*(_DWORD *)(v1 + 36) )
    {
      (*(void (__stdcall **)(int))(**(_DWORD **)(v1 + 64) + 12))(v1);
      (*(void (__stdcall **)(int *))(**(_DWORD **)(v1 + 64) + 16))(&v4);
      v3 = *(_DWORD *)(v1 + 16);
      *(_DWORD *)(v1 + 64) = 0;
      *(_DWORD *)(v1 + 16) = 0;
      sub_1004AD54(v1);
      if ( v3 )
        sub_1004AC04(v3, 1);
      else
        sub_1004B472(v1);
    }
  }
}

//----- (1004AD54) --------------------------------------------------------
int __thiscall sub_1004AD54(int this)
{
  int v2; // edx@1
  int v3; // ecx@1

  v2 = this;
  v3 = *(_DWORD *)(this + 4);
  *(_DWORD *)(v2 + 64) = 0;
  return (*(int (__stdcall **)(int))(*(_DWORD *)v3 + 4))(v2);
}

//----- (1004AD64) --------------------------------------------------------
int __thiscall sub_1004AD64(int this, int a2)
{
  int v2; // eax@1
  int v3; // edx@2
  int (__stdcall **v5)(char); // [sp+0h] [bp-Ch]@10

  v2 = a2;
  if ( !a2 )
    goto LABEL_14;
  v3 = *(_DWORD *)(this + 16);
  if ( v3 )
    goto LABEL_5;
  if ( a2 != 1 )
  {
LABEL_14:
    a2 = (int)"switchState";
    sub_10023687((int)&v5, &a2);
    v5 = &off_100542CC;
    sub_1002D02B((int)&v5, (int)&unk_10061764);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1004ADC6);
  }
  if ( !v3 )
    return sub_1004B472(this);
LABEL_5:
  if ( a2 == 2 )
    *(_DWORD *)(this + 16) = 0;
  return sub_1004AC04(v3, v2);
}
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);

//----- (1004ADC6) --------------------------------------------------------
BOOL __thiscall sub_1004ADC6(void *this, int a2, int a3)
{
  int v3; // ebx@1
  void *v4; // edi@1
  int v5; // esi@2
  void *v6; // ecx@4
  int v7; // ebx@4
  BOOL result; // eax@8
  int (__stdcall **v9)(char); // [sp+Ch] [bp-Ch]@11

  v3 = a2;
  v4 = this;
  if ( !a2 )
  {
    a2 = (int)"pContext";
    sub_10023687((int)&v9, &a2);
    v9 = &off_100542CC;
    sub_1002D02B((int)&v9, (int)&unk_10061764);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1004AE68);
  }
  v5 = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 8))(a2);
  if ( !v5 )
    v5 = (*(int (__cdecl **)(int))(**(_DWORD **)(*((_DWORD *)v4 + 4) + 28) + 28))(v3);
  v6 = (void *)*((_DWORD *)v4 + 4);
  v7 = a3;
  *((_DWORD *)v4 + 4) = 0;
  if ( v7 == 1 )
    *((_DWORD *)v4 + 8) = 1;
  sub_1004AA44(v6, v5);
  if ( v7 && v7 == 1 )
  {
    SignalObjectAndWait(*(HANDLE *)(v5 + 12), *((HANDLE *)v4 + 3), 0xFFFFFFFFu, 1);
    result = (BOOL)((char *)v4 + 32);
    *((_DWORD *)v4 + 8) = 0;
  }
  else
  {
    result = sub_1004B3F3(v5);
  }
  return result;
}
// 100542CC: using guessed type int (__stdcall *off_100542CC)(char);

//----- (1004AE68) --------------------------------------------------------
int __cdecl sub_1004AE68(int a1)
{
  int result; // eax@1
  int v2; // ecx@1

  v2 = *(_DWORD *)(*(_DWORD *)a1 - 4);
  result = a1 - *(_DWORD *)(v2 + 4);
  if ( *(_DWORD *)(v2 + 8) )
    result -= *(_DWORD *)(a1 - *(_DWORD *)(v2 + 8));
  return result;
}

//----- (1004AE85) --------------------------------------------------------
int __cdecl sub_1004AE85(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // edx@1
  signed int v6; // ecx@1
  signed int v7; // ebx@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // eax@1
  int v11; // edi@2
  int v13; // ebx@19
  int v14; // [sp+Ch] [bp-10h]@1
  unsigned int v15; // [sp+10h] [bp-Ch]@1
  unsigned int v16; // [sp+14h] [bp-8h]@1
  int v17; // [sp+18h] [bp-4h]@1
  signed int v18; // [sp+28h] [bp+Ch]@1

  v10 = *(_DWORD *)(a2 + 16);
  v9 = 0;
  v8 = *(_DWORD *)(v10 + 12);
  v6 = -1;
  v5 = 0;
  v17 = 0;
  v14 = *(_DWORD *)(v10 + 12);
  v15 = *(_DWORD *)(v10 + 8);
  v16 = 0;
  v18 = -1;
  v7 = 0;
  if ( !v15 )
    return 0;
  while ( 1 )
  {
    v11 = *(_DWORD *)(v8 + 4 * v7);
    if ( v7 - v6 <= v16 )
      goto LABEL_8;
    if ( *(_DWORD *)v11 != a5 )
    {
      if ( sub_10030DF0(*(_DWORD *)v11 + 8, a5 + 8) )
        goto LABEL_8;
      v5 = v17;
    }
    if ( v5 )
    {
      if ( !(*(_BYTE *)(v11 + 20) & 3) && !(*(_BYTE *)(v5 + 20) & 1) )
        return v11;
      return 0;
    }
    v9 = v11;
    v18 = v7;
    v16 = *(_DWORD *)(v11 + 4);
LABEL_8:
    if ( *(_DWORD *)v11 == a3 )
      goto LABEL_29;
    if ( !sub_10030DF0(*(_DWORD *)v11 + 8, a3 + 8) )
    {
LABEL_29:
      if ( sub_1004B19B(a1, v11 + 8) == a4 )
        break;
    }
    v5 = v17;
LABEL_14:
    ++v7;
    if ( v7 >= v15 )
      return 0;
    v6 = v18;
    v8 = v14;
  }
  if ( !v9 )
  {
    v5 = v11;
    v17 = v11;
    goto LABEL_14;
  }
  v13 = v7 - v18;
  if ( v13 > v16 )
  {
    if ( !(*(_BYTE *)(v9 + 20) & 3) )
      goto LABEL_22;
    return 0;
  }
  if ( !(*(_BYTE *)(v9 + 20) & 0x40) )
  {
    if ( !v18 )
    {
LABEL_22:
      if ( *(_BYTE *)(v11 + 20) & 1 )
        return 0;
    }
    return v9;
  }
  return (*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v9 + 24) + 12) + 4 * v13) + 20) & 1) == 0 ? v9 : 0;
}

//----- (1004AF98) --------------------------------------------------------
int __cdecl sub_1004AF98(int a1, int a2, int a3)
{
  int v3; // edx@1
  unsigned int v4; // edi@1
  unsigned int v5; // esi@1
  int v6; // eax@1
  int v7; // eax@3
  int i; // esi@7
  int v10; // eax@8
  int v11; // [sp+Ch] [bp-4h]@2
  int v12; // [sp+18h] [bp+8h]@1

  v6 = *(_DWORD *)(a1 + 16);
  v3 = *(_DWORD *)(v6 + 12);
  v4 = *(_DWORD *)(v6 + 8);
  v5 = 0;
  v12 = *(_DWORD *)(v6 + 12);
  if ( v4 )
  {
    while ( 1 )
    {
      v11 = *(_DWORD *)(v3 + 4 * v5);
      if ( *(_DWORD *)v11 == a3 )
        break;
      v7 = sub_10030DF0(*(_DWORD *)v11 + 8, a3 + 8);
      v3 = v12;
      if ( !v7 )
        break;
      ++v5;
      if ( v5 >= v4 )
        return 0;
    }
    for ( i = v5 + 1; i < v4; ++i )
    {
      v10 = *(_DWORD *)(v3 + 4 * i);
      if ( *(_BYTE *)(v10 + 20) & 4 )
        break;
      if ( *(_DWORD *)v10 == a2 || !sub_10030DF0(*(_DWORD *)v10 + 8, a2 + 8) )
        return v11;
      v3 = v12;
    }
  }
  return 0;
}

//----- (1004B01E) --------------------------------------------------------
int __cdecl sub_1004B01E(int a1, int a2, int a3, int a4, int a5)
{
  signed int v5; // ecx@1
  signed int v6; // ebx@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // eax@1
  int v10; // esi@2
  char v11; // dl@11
  char v12; // cl@16
  int v13; // esi@16
  int v14; // eax@17
  int v15; // eax@20
  int v16; // eax@24
  int result; // eax@31
  int v18; // [sp+Ch] [bp-20h]@1
  unsigned int v19; // [sp+10h] [bp-1Ch]@1
  int v20; // [sp+14h] [bp-18h]@1
  signed int v21; // [sp+18h] [bp-14h]@1
  unsigned int v22; // [sp+1Ch] [bp-10h]@1
  signed int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1
  char v26; // [sp+3Bh] [bp+Fh]@1

  v9 = *(_DWORD *)(a2 + 16);
  v8 = *(_DWORD *)(v9 + 12);
  v5 = -1;
  v7 = 0;
  v25 = 0;
  v20 = 0;
  v24 = 0;
  v18 = *(_DWORD *)(v9 + 12);
  v19 = *(_DWORD *)(v9 + 8);
  v22 = 0;
  v23 = -1;
  v26 = 1;
  v21 = -1;
  v6 = 0;
  if ( !v19 )
    goto LABEL_34;
  while ( 1 )
  {
    v10 = *(_DWORD *)(v8 + 4 * v6);
    if ( v6 - v5 > v22 )
    {
      if ( *(_DWORD *)v10 == a5 || !sub_10030DF0(*(_DWORD *)v10 + 8, a5 + 8) )
      {
        if ( !(*(_BYTE *)(v10 + 20) & 3) )
          v20 = v10;
        v24 = v10;
        v23 = v6;
        v22 = *(_DWORD *)(v10 + 4);
      }
    }
    if ( *(_DWORD *)v10 != a3 && sub_10030DF0(*(_DWORD *)v10 + 8, a3 + 8) || sub_1004B19B(a1, v10 + 8) != a4 )
      goto LABEL_23;
    v11 = v26;
    if ( v6 - v23 <= v22 )
    {
      if ( v26 )
      {
        if ( *(_BYTE *)(v24 + 20) & 0x40 )
        {
          v13 = v24;
          v14 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v24 + 24) + 12) + 4 * (v6 - v23));
          v11 = (*(_DWORD *)(v14 + 20) & 1) == 0 ? v26 : 0;
          v26 = (*(_DWORD *)(v14 + 20) & 1) == 0 ? v26 : 0;
          v12 = ~(unsigned __int8)(*(_DWORD *)(v14 + 20) >> 2) & 1;
        }
        else
        {
          if ( !v23 )
          {
            v11 = (*(_BYTE *)(v10 + 20) & 1) == 0 ? v26 : 0;
            v26 = (*(_BYTE *)(v10 + 20) & 1) == 0 ? v26 : 0;
          }
          v13 = v24;
          v12 = 1;
        }
        if ( v11 && v12 )
        {
          v15 = sub_1004B19B(a1, v13 + 8);
          if ( v7 && v21 != v15 )
            goto LABEL_34;
          v7 = v13;
          v21 = v15;
LABEL_23:
          v11 = v26;
        }
      }
LABEL_24:
      v16 = v25;
      goto LABEL_25;
    }
    if ( *(_BYTE *)(v10 + 20) & 5 )
      goto LABEL_24;
    v16 = v10;
    v25 = v10;
LABEL_25:
    ++v6;
    if ( v6 >= v19 )
      break;
    v5 = v23;
    v8 = v18;
  }
  if ( v11 && v7 )
    return v7;
  if ( !v16 || (result = v20, !v20) )
LABEL_34:
    result = 0;
  return result;
}

//----- (1004B19B) --------------------------------------------------------
int __cdecl sub_1004B19B(int a1, int a2)
{
  int v2; // edx@1

  v2 = 0;
  if ( *(_DWORD *)(a2 + 4) >= 0 )
    v2 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 4) + a1) + *(_DWORD *)(a2 + 8)) + *(_DWORD *)(a2 + 4);
  return v2 + *(_DWORD *)a2;
}

//----- (1004B1BF) --------------------------------------------------------
bool __cdecl sub_1004B1BF(int a1, int a2, int a3, int a4, int a5)
{
  bool result; // eax@2
  int v6; // eax@4
  int v7; // ecx@4
  int v8; // ebx@4
  int v9; // edi@4
  int v10; // esi@4
  int v11; // eax@5
  int v12; // eax@10
  char v13; // [sp+10h] [bp-28h]@13
  int v14; // [sp+1Ch] [bp-1Ch]@10
  CPPEH_RECORD ms_exc; // [sp+20h] [bp-18h]@4

  if ( a1 )
  {
    v10 = 0;
    ms_exc.disabled = 0;
    v8 = sub_1004AE68(a1);
    v6 = *(_DWORD *)(*(_DWORD *)a1 - 4);
    v9 = a1 - a2 - v8;
    v7 = *(_DWORD *)(*(_DWORD *)(v6 + 16) + 4);
    if ( v7 & 1 )
    {
      if ( v7 & 2 )
        v11 = sub_1004B01E(v8, v6, a3, v9, a4);
      else
        v11 = sub_1004AE85(v8, v6, a3, v9, a4);
    }
    else
    {
      v11 = sub_1004AF98(v6, a3, a4);
    }
    if ( v11 )
    {
      v12 = sub_1004B19B(v8, v11 + 8);
      v10 = v8 + v12;
      v14 = v8 + v12;
    }
    else
    {
      v14 = 0;
      if ( a5 )
      {
        sub_10023634((int)&v13, (unsigned int)"Bad dynamic_cast!");
        sub_1002D02B((int)&v13, (int)&unk_10061540);
        return ms_exc.exc_ptr->ExceptionRecord->ExceptionCode == -1073741819;
      }
    }
    ms_exc.disabled = -2;
    result = v10;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004B29B) --------------------------------------------------------
LPVOID __thiscall sub_1004B29B(LPVOID lpParameter, int a2, int a3)
{
  LPVOID v3; // edi@1
  int v4; // ecx@1
  HANDLE v12; // eax@1
  int v13; // eax@2
  HANDLE v14; // eax@4
  int v15; // eax@5
  char *v16; // eax@7
  int v18; // ecx@10
  int v19; // esi@10
  int v20; // [sp-4h] [bp-30h]@7
  char v21; // [sp+Ch] [bp-20h]@7
  char v22; // [sp+1Ch] [bp-10h]@9

  v3 = lpParameter;
  *((_DWORD *)lpParameter + 1) = a2;
  v4 = *((_DWORD *)lpParameter + 1);
  *(_DWORD *)v3 = off_1005B8B8;
  *((_DWORD *)v3 + 5) = a3;
  *((_DWORD *)v3 + 6) = 0;
  *((_BYTE *)v3 + 28) = 0;
  _ESI = 1;
  *((_DWORD *)v3 + 8) = 1;
  *((_DWORD *)v3 + 9) = 0;
  (*(void (**)(void))(*(_DWORD *)v4 + 8))();
  _EAX = &unk_10067268;
  __asm { lock xadd [eax], esi }
  *((_DWORD *)v3 + 10) = _ESI + 1;
  v12 = CreateEventW(0, 0, 0, 0);
  *((_DWORD *)v3 + 3) = v12;
  if ( v12 )
  {
    v14 = sub_1002C433(
            0,
            *((_DWORD *)v3 + 5) << 10,
            (LPTHREAD_START_ROUTINE)sub_1004B48C,
            v3,
            0x10000u,
            (LPDWORD)v3 + 11);
    *((_DWORD *)v3 + 2) = v14;
    if ( v14 )
      return v3;
    CloseHandle(*((HANDLE *)v3 + 3));
    (*(void (**)(void))(**((_DWORD **)v3 + 1) + 12))();
    v15 = GetLastError();
    if ( v15 > 0 )
      v15 = (unsigned __int16)v15 | 0x80070000;
    sub_10024A12((int)&v21, v15);
    v20 = (int)&unk_1006140C;
    v16 = &v21;
  }
  else
  {
    v13 = GetLastError();
    if ( v13 > 0 )
      v13 = (unsigned __int16)v13 | 0x80070000;
    sub_100249F4((int)&v22, v13);
    v20 = (int)&unk_10060498;
    v16 = &v22;
  }
  sub_1002D02B((int)v16, v20);
  __asm { int     3               ; Trap to Debugger }
  v19 = v18;
  sub_1002921D(v18, 0, a2);
  *(_DWORD *)v19 = &off_100559D4;
  return (LPVOID)v19;
}
// 100559D4: using guessed type int (__stdcall *off_100559D4)(char);
// 1005B8B8: using guessed type int (*off_1005B8B8[4])();

//----- (1004B39B) --------------------------------------------------------
int __thiscall sub_1004B39B(int this)
{
  int v2; // edi@1
  void *v3; // ST00_4@1

  v2 = this;
  v3 = *(void **)(this + 12);
  *(_DWORD *)this = off_1005B8B8;
  CloseHandle(v3);
  CloseHandle(*(HANDLE *)(v2 + 8));
  return (*(int (**)(void))(**(_DWORD **)(v2 + 4) + 12))();
}
// 1005B8B8: using guessed type int (*off_1005B8B8[4])();

//----- (1004B3BF) --------------------------------------------------------
void *__thiscall sub_1004B3BF(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_1004B39B(this);
  if ( a2 & 1 )
    sub_1002404A(v2);
  return v2;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1004B3DE) --------------------------------------------------------
BOOL __thiscall sub_1004B3DE(int this)
{
  void *v2; // ST00_4@1

  v2 = *(void **)(this + 12);
  *(_DWORD *)(this + 36) = 1;
  return SetEvent(v2);
}

//----- (1004B3EF) --------------------------------------------------------
int __thiscall sub_1004B3EF(int this)
{
  return *(_DWORD *)(this + 40);
}

//----- (1004B3F3) --------------------------------------------------------
BOOL __thiscall sub_1004B3F3(int this)
{
  return SetEvent(*(HANDLE *)(this + 12));
}

//----- (1004B3FD) --------------------------------------------------------
BOOL __thiscall sub_1004B3FD(int this, int nPriority)
{
  BOOL result; // eax@1
  int v3; // eax@2
  char v4; // [sp+0h] [bp-10h]@5

  *(_DWORD *)(this + 24) = nPriority;
  result = SetThreadPriority(*(HANDLE *)(this + 8), nPriority);
  if ( !result )
  {
    v3 = GetLastError();
    if ( v3 > 0 )
      v3 = (unsigned __int16)v3 | 0x80070000;
    sub_100249F4((int)&v4, v3);
    sub_1002D02B((int)&v4, (int)&unk_10060498);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1004B447);
  }
  return result;
}

//----- (1004B447) --------------------------------------------------------
char __thiscall sub_1004B447(int this)
{
  int v1; // esi@1
  char result; // al@3
  char v3; // [sp+4h] [bp-10h]@3
  int v4; // [sp+Ch] [bp-8h]@2
  void (__cdecl *v5)(); // [sp+10h] [bp-4h]@2

  v1 = this;
  if ( !*(_DWORD *)(this + 32) )
  {
    v4 = 0;
    v5 = sub_1002C630;
    do
      result = sub_1001FF20((int)&v3);
    while ( !*(_DWORD *)(v1 + 32) );
  }
  return result;
}

//----- (1004B472) --------------------------------------------------------
int __thiscall sub_1004B472(int this)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = this + 32;
  *(_DWORD *)(this + 32) = 1;
  WaitForSingleObject(*(HANDLE *)(this + 12), 0xFFFFFFFFu);
  result = *(_DWORD *)v2;
  *(_DWORD *)v2 = 0;
  return result;
}

//----- (1004B48C) --------------------------------------------------------
int __stdcall sub_1004B48C(int a1)
{
  int v2; // esi@1

  v2 = a1;
  WaitForSingleObject(*(HANDLE *)(a1 + 12), 0xFFFFFFFFu);
  *(_DWORD *)(a1 + 32) = 0;
  (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 20))(v2);
  (*(void (__thiscall **)(int, signed int))(*(_DWORD *)v2 + 16))(v2, 1);
  sub_1002C3BC(0);
  return 0;
}

//----- (1004B4C4) --------------------------------------------------------
void __usercall sub_1004B4C4(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5, const CHAR *lpWideCharStr, signed int nNumberOfBytesToRead)
{
  if ( a5 == -2 )
  {
    *(_DWORD *)sub_1002F110(a3) = 0;
    *(_DWORD *)sub_1002F144(a3) = 9;
    return;
  }
  if ( a5 < 0
    || a5 >= (unsigned int)dword_1006A394
    || (a3 = a5 >> 5, a4 = (a5 & 0x1F) << 6, !(*(_BYTE *)(dword_10069CE0[a5 >> 5] + a4 + 4) & 1)) )
  {
    *(_DWORD *)sub_1002F110(a3) = 0;
    *(_DWORD *)sub_1002F144(a3) = 9;
    goto LABEL_13;
  }
  if ( (unsigned int)nNumberOfBytesToRead > 0x7FFFFFFF )
  {
    *(_DWORD *)sub_1002F110(a3) = 0;
    *(_DWORD *)sub_1002F144(a3) = 22;
LABEL_13:
    sub_10036C88(a3, a4);
    return;
  }
  sub_1004BD5B(a1, a2, a3, a5);
  if ( *(_BYTE *)(dword_10069CE0[a3] + a4 + 4) & 1 )
  {
    sub_1004B5CC(a3, a5, lpWideCharStr, nNumberOfBytesToRead);
  }
  else
  {
    *(_DWORD *)sub_1002F144(a3) = 9;
    *(_DWORD *)sub_1002F110(a3) = 0;
  }
  sub_1004BED4(a5);
}
// 10069CE0: using guessed type int dword_10069CE0[];
// 1006A394: using guessed type int dword_1006A394;

//----- (1004B5CC) --------------------------------------------------------
signed int __usercall sub_1004B5CC<eax>(int a1<ebx>, unsigned int a2, const CHAR *lpWideCharStr, signed int nNumberOfBytesToRead)
{
  signed int v4; // edi@1
  unsigned int v5; // esi@1
  char v6; // al@5
  int v7; // edx@5
  int v8; // ecx@5
  int v9; // eax@13
  char v10; // al@13
  void *v11; // eax@17
  LARGE_INTEGER v12; // qax@23
  int v13; // ecx@23
  int v14; // edx@24
  int v15; // ecx@24
  char v16; // zf@24
  char v17; // dl@25
  void *v18; // edx@27
  int v19; // eax@27
  char v20; // al@28
  int v21; // edx@30
  int v22; // eax@30
  char v23; // al@31
  int v24; // eax@33
  int v25; // eax@34
  char v26; // zf@34
  int v27; // ecx@35
  int v28; // eax@39
  int v29; // ebx@41
  LPCSTR v30; // eax@42
  DWORD v31; // ecx@43
  char v32; // al@48
  int v33; // edx@48
  int v34; // esi@48
  char v35; // al@52
  LPCSTR v36; // esi@54
  char v37; // cl@55
  int v38; // edi@55
  const CHAR v39; // al@56
  char v40; // al@81
  int v41; // ecx@81
  int v42; // esi@86
  signed int v43; // edx@88
  int v44; // ecx@97
  char v45; // al@98
  int v46; // eax@98
  int v47; // esi@98
  int v48; // esi@104
  bool v49; // ecx@105
  unsigned int v51; // edx@114
  LPCSTR v52; // ecx@114
  LPCSTR v53; // esi@114
  signed __int16 v54; // di@115
  __int16 v55; // ax@116
  signed __int16 v56; // ax@120
  char v57; // al@129
  LPCSTR v58; // esi@131
  signed __int16 v59; // cx@132
  int v60; // edi@132
  __int16 v61; // ax@133
  char v62; // al@159
  int v63; // ecx@159
  char v64; // [sp-4h] [bp-38h]@67
  signed __int16 v65; // [sp-4h] [bp-38h]@145
  unsigned int v66; // [sp+Ch] [bp-28h]@1
  DWORD Mode; // [sp+14h] [bp-20h]@1
  LPVOID lpBuffer; // [sp+18h] [bp-1Ch]@24
  int v69; // [sp+1Ch] [bp-18h]@1
  DWORD NumberOfBytesRead; // [sp+20h] [bp-14h]@38
  LPCSTR lpMem; // [sp+24h] [bp-10h]@17
  int v72; // [sp+28h] [bp-Ch]@5
  __int16 v73; // [sp+2Ch] [bp-8h]@141
  char Buffer; // [sp+33h] [bp-1h]@63
  signed int v75; // [sp+44h] [bp+10h]@115
  signed int v76; // [sp+44h] [bp+10h]@132
  char v77; // [sp+47h] [bp+13h]@13

  v5 = nNumberOfBytesToRead;
  v4 = 0;
  Mode = 0;
  v69 = -2;
  v66 = nNumberOfBytesToRead;
  if ( a2 == -2 )
  {
    *(_DWORD *)sub_1002F110(a1) = 0;
    *(_DWORD *)sub_1002F144(a1) = 9;
    return -1;
  }
  if ( (signed int)a2 < 0
    || a2 >= dword_1006A394
    || (v8 = (signed int)a2 >> 5,
        v7 = dword_10069CE0[(signed int)a2 >> 5],
        a1 = (a2 & 0x1F) << 6,
        v72 = (signed int)a2 >> 5,
        v6 = *(_BYTE *)(v7 + a1 + 4),
        !(v6 & 1)) )
  {
    *(_DWORD *)sub_1002F110(a1) = 0;
    *(_DWORD *)sub_1002F144(a1) = 9;
    goto LABEL_169;
  }
  if ( (unsigned int)nNumberOfBytesToRead > 0x7FFFFFFF )
  {
    *(_DWORD *)sub_1002F110(a1) = 0;
LABEL_8:
    *(_DWORD *)sub_1002F144(a1) = 22;
LABEL_169:
    sub_10036C88(a1, 0);
    return -1;
  }
  if ( !nNumberOfBytesToRead || v6 & 2 )
    return 0;
  if ( !lpWideCharStr )
  {
LABEL_12:
    *(_DWORD *)sub_1002F110(a1) = 0;
    goto LABEL_8;
  }
  v10 = (char)(2 * *(_BYTE *)(v7 + a1 + 36)) >> 1;
  v77 = v10;
  v9 = v10 - 1;
  if ( v9 )
  {
    if ( v9 == 1 )
    {
      if ( !(~(_BYTE)v5 & 1) )
        goto LABEL_12;
      v5 &= 0xFFFFFFFEu;
    }
    v11 = (void *)lpWideCharStr;
    lpMem = lpWideCharStr;
  }
  else
  {
    if ( !(~(_BYTE)v5 & 1) )
      goto LABEL_12;
    v5 >>= 1;
    if ( v5 < 4 )
      v5 = 4;
    lpMem = (LPCSTR)sub_1002F02B(v7, v8, a1, v5);
    if ( !lpMem )
    {
      *(_DWORD *)sub_1002F144(a1) = 12;
      *(_DWORD *)sub_1002F110(a1) = 8;
      return -1;
    }
    v12 = sub_100455B6(a1, 0, a2, 0i64, 1u);
    v13 = dword_10069CE0[v72];
    *(_DWORD *)(v13 + a1 + 40) = v12.LowPart;
    v11 = (void *)lpMem;
    *(_DWORD *)(v13 + a1 + 44) = v12.HighPart;
    v8 = v72;
  }
  v14 = dword_10069CE0[v8];
  v15 = v72;
  v16 = (*(_BYTE *)(v14 + a1 + 4) & 0x48) == 0;
  lpBuffer = v11;
  if ( !v16 )
  {
    v17 = *(_BYTE *)(v14 + a1 + 5);
    if ( v17 != 10 )
    {
      if ( v5 )
      {
        *(_BYTE *)v11 = v17;
        v18 = (char *)v11 + 1;
        v19 = dword_10069CE0[v15];
        v4 = 1;
        --v5;
        lpBuffer = v18;
        *(_BYTE *)(v19 + a1 + 5) = 10;
        if ( v77 )
        {
          v20 = *(_BYTE *)(dword_10069CE0[v15] + a1 + 37);
          if ( v20 != 10 )
          {
            if ( v5 )
            {
              *(_BYTE *)v18 = v20;
              v22 = dword_10069CE0[v15];
              v21 = (int)((char *)v18 + 1);
              --v5;
              lpBuffer = (LPVOID)v21;
              v4 = 2;
              *(_BYTE *)(v22 + a1 + 37) = 10;
              if ( v77 == 1 )
              {
                v23 = *(_BYTE *)(dword_10069CE0[v15] + a1 + 38);
                if ( v23 != 10 )
                {
                  if ( v5 )
                  {
                    v4 = 3;
                    *(_BYTE *)v21 = v23;
                    v24 = dword_10069CE0[v15];
                    lpBuffer = (LPVOID)(v21 + 1);
                    --v5;
                    *(_BYTE *)(v24 + a1 + 38) = 10;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  v26 = sub_10044B5A(a1, v4, a2) == 0;
  v25 = v72;
  if ( v26 || (v27 = dword_10069CE0[v72], !(*(_BYTE *)(v27 + a1 + 4) & 0x80)) )
  {
LABEL_45:
    if ( !ReadFile(*(HANDLE *)(dword_10069CE0[v25] + a1), lpBuffer, v5, &NumberOfBytesRead, 0)
      || (v31 = NumberOfBytesRead, (signed int)NumberOfBytesRead < 0)
      || NumberOfBytesRead > v5 )
    {
      v28 = GetLastError();
      if ( v28 == 5 )
      {
        *(_DWORD *)sub_1002F144(a1) = 9;
        *(_DWORD *)sub_1002F110(a1) = 5;
        goto LABEL_41;
      }
      if ( v28 == 109 )
      {
        v29 = 0;
        goto LABEL_42;
      }
      goto LABEL_40;
    }
    goto LABEL_48;
  }
  Mode = GetConsoleMode(*(HANDLE *)(v27 + a1), &Mode);
  if ( !Mode || v77 != 2 )
  {
    v25 = v72;
    goto LABEL_45;
  }
  if ( ReadConsoleW(*(HANDLE *)(dword_10069CE0[v72] + a1), lpBuffer, v5 >> 1, &NumberOfBytesRead, 0) )
  {
    v31 = 2 * NumberOfBytesRead;
    NumberOfBytesRead *= 2;
LABEL_48:
    v33 = v72;
    v4 += v31;
    v34 = dword_10069CE0[v72];
    v32 = *(_BYTE *)(v34 + a1 + 4);
    if ( v32 >= 0 )
      goto LABEL_106;
    if ( v77 != 2 )
    {
      if ( v31 && *lpMem == 10 )
        v35 = v32 | 4;
      else
        v35 = v32 & 0xFB;
      *(_BYTE *)(v34 + a1 + 4) = v35;
      v36 = lpMem;
      Mode = (DWORD)lpMem;
      lpBuffer = (LPVOID)&lpMem[v4];
      if ( lpMem < &lpMem[v4] )
      {
        v37 = 13;
        v38 = (int)lpMem;
        do
        {
          v39 = *(_BYTE *)v38;
          if ( *(_BYTE *)v38 == 26 )
          {
            v41 = dword_10069CE0[v33];
            v40 = *(_BYTE *)(v41 + a1 + 4);
            if ( v40 & 0x40 )
              *v36++ = *(_BYTE *)v38;
            else
              *(_BYTE *)(v41 + a1 + 4) = v40 | 2;
            break;
          }
          if ( v39 == v37 )
          {
            if ( v38 >= (unsigned int)((char *)lpBuffer - 1) )
            {
              ++v38;
              if ( !ReadFile(*(HANDLE *)(dword_10069CE0[v33] + a1), &Buffer, 1u, &NumberOfBytesRead, 0)
                && GetLastError()
                || !NumberOfBytesRead )
              {
                v33 = v72;
                v37 = 13;
                *v36++ = 13;
                continue;
              }
              v33 = v72;
              if ( *(_BYTE *)(dword_10069CE0[v72] + a1 + 4) & 0x48 )
              {
                v64 = 13;
                if ( Buffer == 10 )
                {
                  *v36++ = 10;
                }
                else
                {
                  *v36++ = 13;
                  *(_BYTE *)(dword_10069CE0[v33] + a1 + 5) = Buffer;
                }
              }
              else
              {
                if ( v36 != lpMem || Buffer != 10 )
                {
                  sub_100455B6(a1, v38, a2, (LARGE_INTEGER)-1i64, 1u);
                  v33 = v72;
                  if ( Buffer != 10 )
                  {
                    v37 = 13;
                    *v36 = 13;
                    goto LABEL_79;
                  }
                }
                else
                {
                  *v36++ = 10;
                }
                v64 = 13;
              }
              v37 = v64;
            }
            else
            {
              if ( *(_BYTE *)(v38 + 1) == 10 )
              {
                v38 += 2;
                *v36 = 10;
LABEL_79:
                ++v36;
                continue;
              }
              *v36++ = v37;
              ++v38;
            }
          }
          else
          {
            *v36++ = v39;
            ++v38;
          }
        }
        while ( v38 < (unsigned int)lpBuffer );
      }
      v30 = lpMem;
      v4 = v36 - lpMem;
      if ( v77 != 1 || v36 == lpMem )
      {
LABEL_107:
        v29 = v69;
        goto LABEL_108;
      }
      v42 = (int)(v36 - 1);
      if ( *(_BYTE *)v42 < 0 )
      {
        v43 = 1;
        if ( !byte_10068528[*(_BYTE *)v42] )
        {
          do
          {
            if ( v43 > 4 )
              break;
            if ( v42 < (unsigned int)lpMem )
              break;
            --v42;
            ++v43;
          }
          while ( !byte_10068528[*(_BYTE *)v42] );
          a1 = (a2 & 0x1F) << 6;
        }
        if ( !byte_10068528[*(_BYTE *)v42] )
        {
          *(_DWORD *)sub_1002F144(a1) = 42;
          goto LABEL_41;
        }
        if ( byte_10068528[*(_BYTE *)v42] + 1 == v43 )
        {
          v42 += v43;
        }
        else
        {
          v44 = dword_10069CE0[v72];
          if ( *(_BYTE *)(v44 + a1 + 4) & 0x48 )
          {
            v45 = *(_BYTE *)v42;
            v47 = v42 + 1;
            *(_BYTE *)(v44 + a1 + 5) = v45;
            v46 = v72;
            if ( v43 >= 2 )
            {
              *(_BYTE *)(dword_10069CE0[v72] + a1 + 37) = *(_BYTE *)v47;
              v46 = v72;
              ++v47;
            }
            if ( v43 == 3 )
              *(_BYTE *)(dword_10069CE0[v46] + a1 + 38) = *(_BYTE *)v47++;
            v42 = v47 - v43;
          }
          else
          {
            sub_100455B6(a1, v4, a2, (LARGE_INTEGER)-v43, 1u);
          }
        }
      }
      else
      {
        ++v42;
      }
      v48 = v42 - (_DWORD)lpMem;
      v4 = MultiByteToWideChar(0xFDE9u, 0, lpMem, v48, (LPWSTR)lpWideCharStr, v66 >> 1);
      if ( !v4 )
        goto LABEL_39;
      v49 = v4 != v48;
      v4 *= 2;
      *(_DWORD *)(dword_10069CE0[v72] + a1 + 48) = v49;
LABEL_106:
      v30 = lpMem;
      goto LABEL_107;
    }
    if ( Mode )
    {
      v53 = lpMem;
      v52 = lpMem;
      v51 = (unsigned int)&lpMem[2 * v4 / 2];
      if ( (unsigned int)lpMem < v51 )
      {
        v75 = 26;
        v54 = 13;
        while ( 1 )
        {
          v55 = *(_WORD *)v52;
          if ( *(_WORD *)v52 == (_WORD)v75 )
            break;
          if ( v55 == v54 )
          {
            if ( (unsigned int)v52 < v51 - 2 )
            {
              v52 += 2;
              v56 = 10;
              if ( *(_WORD *)v52 != 10 )
              {
                v56 = 13;
                v54 = 13;
              }
              *(_WORD *)v53 = v56;
              v53 += 2;
            }
          }
          else
          {
            *(_WORD *)v53 = v55;
            v53 += 2;
            v52 += 2;
          }
          if ( (unsigned int)v52 >= v51 )
            goto LABEL_126;
        }
        *(_BYTE *)(dword_10069CE0[v72] + a1 + 4) |= 2u;
      }
LABEL_126:
      v30 = lpMem;
      v4 = (v53 - lpMem) & 0xFFFFFFFE;
      goto LABEL_107;
    }
    if ( v31 && (v33 = v72, *(_WORD *)lpMem == 10) )
      v57 = v32 | 4;
    else
      v57 = v32 & 0xFB;
    *(_BYTE *)(v34 + a1 + 4) = v57;
    v58 = lpMem;
    Mode = (DWORD)&lpMem[v4];
    if ( lpMem >= &lpMem[v4] )
    {
LABEL_162:
      v30 = lpMem;
      v4 = v58 - lpMem;
      goto LABEL_107;
    }
    v59 = 13;
    v76 = 26;
    v60 = (int)lpMem;
    while ( 1 )
    {
      v61 = *(_WORD *)v60;
      if ( *(_WORD *)v60 == (_WORD)v76 )
      {
        v63 = dword_10069CE0[v33];
        v62 = *(_BYTE *)(v63 + a1 + 4);
        if ( v62 & 0x40 )
        {
          *(_WORD *)v58 = *(_WORD *)v60;
          v58 += 2;
        }
        else
        {
          *(_BYTE *)(v63 + a1 + 4) = v62 | 2;
        }
        goto LABEL_162;
      }
      if ( v61 == v59 )
      {
        if ( v60 >= Mode - 2 )
        {
          v60 += 2;
          if ( !ReadFile(*(HANDLE *)(dword_10069CE0[v33] + a1), &v73, 2u, &NumberOfBytesRead, 0) && GetLastError()
            || !NumberOfBytesRead )
          {
            v33 = v72;
            v59 = 13;
            *(_WORD *)v58 = 13;
            v58 += 2;
            goto LABEL_150;
          }
          v33 = v72;
          if ( *(_BYTE *)(dword_10069CE0[v72] + a1 + 4) & 0x48 )
          {
            v65 = 13;
            if ( v73 == 10 )
            {
              *(_WORD *)v58 = 10;
              v58 += 2;
LABEL_149:
              v59 = v65;
              goto LABEL_150;
            }
            *(_WORD *)v58 = 13;
            *(_BYTE *)(dword_10069CE0[v33] + a1 + 5) = v73;
            *(_BYTE *)(dword_10069CE0[v33] + a1 + 37) = HIBYTE(v73);
            v58 += 2;
            *(_BYTE *)(dword_10069CE0[v33] + a1 + 38) = 10;
          }
          else
          {
            if ( v58 != lpMem || v73 != 10 )
            {
              sub_100455B6(a1, v60, a2, (LARGE_INTEGER)-2i64, 1u);
              v33 = v72;
              if ( v73 != 10 )
              {
                v59 = 13;
                *(_WORD *)v58 = 13;
                goto LABEL_157;
              }
            }
            else
            {
              *(_WORD *)v58 = 10;
              v58 += 2;
            }
          }
          v65 = 13;
          goto LABEL_149;
        }
        v33 = v72;
        if ( *(_WORD *)(v60 + 2) == 10 )
        {
          v60 += 4;
          *(_WORD *)v58 = 10;
LABEL_157:
          v58 += 2;
          goto LABEL_150;
        }
        *(_WORD *)v58 = v59;
      }
      else
      {
        *(_WORD *)v58 = v61;
      }
      v58 += 2;
      v60 += 2;
LABEL_150:
      if ( v60 >= Mode )
        goto LABEL_162;
    }
  }
LABEL_39:
  v28 = GetLastError();
LABEL_40:
  sub_1002F123(a1, v28);
LABEL_41:
  v29 = -1;
LABEL_42:
  v30 = lpMem;
LABEL_108:
  if ( v30 != lpWideCharStr )
    sub_100282F6(v29, (LPVOID)v30);
  if ( v29 != -2 )
    v4 = v29;
  return v4;
}
// 10069CE0: using guessed type int dword_10069CE0[];
// 1006A394: using guessed type int dword_1006A394;

//----- (1004BD5B) --------------------------------------------------------
void __usercall sub_1004BD5B(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // esi@1

  v4 = dword_10069CE0[a4 >> 5] + ((a4 & 0x1F) << 6);
  if ( *(_DWORD *)(v4 + 8) )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(((a4 & 0x1F) << 6) + dword_10069CE0[a4 >> 5] + 12));
  }
  else
  {
    sub_1002E493(a1, a2, a3, a4, 10);
    if ( !*(_DWORD *)(v4 + 8) )
    {
      InitializeCriticalSectionAndSpinCount((LPCRITICAL_SECTION)(v4 + 12), 0xFA0u);
      ++*(_DWORD *)(v4 + 8);
    }
    sub_1002E5F7(10);
  }
}
// 10069CE0: using guessed type int dword_10069CE0[];

//----- (1004BDE7) --------------------------------------------------------
signed int __usercall sub_1004BDE7<eax>(int a1<ebx>, signed int a2)
{
  int v2; // ecx@3
  int v3; // esi@3
  DWORD v5; // [sp-8h] [bp-10h]@9
  void *v6; // [sp-4h] [bp-Ch]@9

  if ( a2 >= 0 )
  {
    if ( a2 < (unsigned int)dword_1006A394 )
    {
      v2 = dword_10069CE0[a2 >> 5];
      v3 = (a2 & 0x1F) << 6;
      if ( *(_BYTE *)(v3 + v2 + 4) & 1 )
      {
        if ( *(_DWORD *)(v3 + v2) != -1 )
        {
          if ( dword_10069600 == 1 )
          {
            if ( !a2 )
            {
              v6 = 0;
              v5 = -10;
              goto LABEL_12;
            }
            if ( a2 == 1 )
            {
              v6 = 0;
              v5 = -11;
              goto LABEL_12;
            }
            if ( a2 == 2 )
            {
              v6 = 0;
              v5 = -12;
LABEL_12:
              SetStdHandle(v5, v6);
              goto LABEL_13;
            }
          }
LABEL_13:
          *(_DWORD *)(v3 + dword_10069CE0[a2 >> 5]) = -1;
          return 0;
        }
      }
    }
  }
  *(_DWORD *)sub_1002F144(a1) = 9;
  *(_DWORD *)sub_1002F110(a1) = 0;
  return -1;
}
// 10069600: using guessed type int dword_10069600;
// 10069CE0: using guessed type int dword_10069CE0[];
// 1006A394: using guessed type int dword_1006A394;

//----- (1004BE6D) --------------------------------------------------------
signed int __usercall sub_1004BE6D<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  int v3; // eax@5
  int v4; // ecx@5

  if ( a3 == -2 )
  {
    *(_DWORD *)sub_1002F110(a1) = 0;
    *(_DWORD *)sub_1002F144(a1) = 9;
  }
  else
  {
    if ( a3 >= 0 )
    {
      if ( a3 < (unsigned int)dword_1006A394 )
      {
        v3 = dword_10069CE0[a3 >> 5];
        v4 = (a3 & 0x1F) << 6;
        if ( *(_BYTE *)(v3 + v4 + 4) & 1 )
          return *(_DWORD *)(v3 + v4);
      }
    }
    *(_DWORD *)sub_1002F110(a1) = 0;
    *(_DWORD *)sub_1002F144(a1) = 9;
    sub_10036C88(a1, a2);
  }
  return -1;
}
// 10069CE0: using guessed type int dword_10069CE0[];
// 1006A394: using guessed type int dword_1006A394;

//----- (1004BED4) --------------------------------------------------------
void __cdecl sub_1004BED4(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(((a1 & 0x1F) << 6) + 12 + dword_10069CE0[a1 >> 5]));
}
// 10069CE0: using guessed type int dword_10069CE0[];

//----- (1004BEFA) --------------------------------------------------------
signed __int16 __thiscall sub_1004BEFA(DWORD this, __int16 Buffer)
{
  HANDLE v2; // eax@1
  signed __int16 result; // ax@4
  DWORD NumberOfCharsWritten; // [sp+0h] [bp-4h]@1

  NumberOfCharsWritten = this;
  v2 = hConsoleOutput;
  if ( hConsoleOutput == (HANDLE)-2 )
  {
    sub_1004ED60();
    v2 = hConsoleOutput;
  }
  if ( v2 != (HANDLE)-1 && WriteConsoleW(v2, &Buffer, 1u, &NumberOfCharsWritten, 0) )
    result = Buffer;
  else
    result = -1;
  return result;
}

//----- (1004BF3B) --------------------------------------------------------
signed int __usercall sub_1004BF3B<eax>(int a1<ebx>, int a2)
{
  int v2; // edi@1
  signed int result; // eax@2
  int v4; // eax@4
  int v5; // edx@4
  int v6; // ecx@4
  int v7; // eax@4

  v2 = -1;
  if ( a2 )
  {
    if ( *(_BYTE *)(a2 + 12) & 0x83 )
    {
      v2 = sub_1003DA6F(a2);
      sub_1004EEE3(a1, a2);
      v4 = sub_1004494B(a1, v2, a2);
      sub_1004ED7F(v5, v6, a1, v2, v4);
      if ( v7 >= 0 )
      {
        if ( *(_DWORD *)(a2 + 28) )
        {
          sub_100282F6(a1, *(LPVOID *)(a2 + 28));
          *(_DWORD *)(a2 + 28) = 0;
        }
      }
      else
      {
        v2 = -1;
      }
    }
    *(_DWORD *)(a2 + 12) = 0;
    result = v2;
  }
  else
  {
    *(_DWORD *)sub_1002F144(a1) = 22;
    sub_10036C88(a1, -1);
    result = -1;
  }
  return result;
}

//----- (1004BFA7) --------------------------------------------------------
void __usercall sub_1004BFA7(int a1<edx>, int a2<ebx>, unsigned int a3)
{
  if ( a3 != 0 )
  {
    if ( *(_BYTE *)(a3 + 12) & 0x40 )
    {
      *(_DWORD *)(a3 + 12) = 0;
    }
    else
    {
      sub_1003D953(a1, a2, -1, a3);
      sub_1004BF3B(a2, a3);
      sub_1003D9C2(a3);
    }
  }
  else
  {
    *(_DWORD *)sub_1002F144(a2) = 22;
    sub_10036C88(a2, -1);
  }
}

//----- (1004C01E) --------------------------------------------------------
int __usercall sub_1004C01E<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, unsigned int a5, int a6)
{
  void *v6; // ecx@1
  int v8; // ebx@8
  const WCHAR v9; // di@8
  int i; // esi@8
  int v11; // eax@10
  void *v12; // ST04_4@10
  int v13; // eax@11
  signed int v14; // eax@15
  int v15; // edx@28
  unsigned __int16 v16; // cx@31
  int v17; // eax@32
  int v18; // edi@33
  int v19; // esi@34
  int v20; // edx@39
  int v21; // eax@43
  unsigned int v22; // [sp+4h] [bp-8h]@27
  int v23; // [sp+8h] [bp-4h]@15

  v6 = (void *)a3;
  if ( a4 )
    *(_DWORD *)a4 = a3;
  if ( !a3 || a5 && ((signed int)a5 < 2 || (signed int)a5 > 36) )
  {
    *(_DWORD *)sub_1002F144(a1) = 22;
    sub_10036C88(a1, a2);
    return 0;
  }
  v9 = *(_WORD *)a3;
  v8 = 0;
  for ( i = a3 + 2; ; i += 2 )
  {
    v11 = sub_1004A607(v6, v9, 8);
    v6 = v12;
    if ( !v11 )
      break;
    v9 = *(_WORD *)i;
  }
  v13 = a6;
  if ( v9 == 45 )
  {
    v13 = a6 | 2;
  }
  else
  {
    if ( v9 != 43 )
      goto LABEL_15;
  }
  v9 = *(_WORD *)i;
  i += 2;
LABEL_15:
  v23 = v13;
  v14 = a5;
  if ( a5 )
    goto LABEL_22;
  if ( !sub_1004EF13(v9) )
  {
    if ( *(_WORD *)i != 120 && *(_WORD *)i != 88 )
    {
      a5 = 8;
      goto LABEL_27;
    }
    v14 = 16;
    a5 = 16;
LABEL_22:
    if ( v14 == 16 )
    {
      if ( !sub_1004EF13(v9) )
      {
        if ( *(_WORD *)i == 120 || *(_WORD *)i == 88 )
        {
          v9 = *(_WORD *)(i + 2);
          i += 4;
        }
      }
    }
    goto LABEL_27;
  }
  a5 = 10;
LABEL_27:
  v22 = 0xFFFFFFFF / a5;
  while ( 1 )
  {
    v15 = sub_1004EF13(v9);
    if ( v15 != -1 )
      goto LABEL_42;
    if ( v9 >= 0x41u && v9 <= 0x5Au )
    {
      v16 = 25;
      goto LABEL_39;
    }
    v16 = 25;
    if ( (unsigned __int16)(v9 - 97) > 0x19u )
      break;
LABEL_39:
    v20 = v9;
    if ( (unsigned __int16)(v9 - 97) <= v16 )
      v20 = v9 - 32;
    v15 = v20 - 55;
LABEL_42:
    LOBYTE(v17) = v23;
    if ( v15 >= a5 )
      goto LABEL_33;
    v21 = v23 | 8;
    v23 |= 8u;
    if ( v8 < v22 || v8 == v22 && v15 <= 0xFFFFFFFF % a5 )
    {
      v8 = v15 + a5 * v8;
    }
    else
    {
      v18 = a4;
      v17 = v21 | 4;
      v23 = v17;
      if ( !a4 )
        goto LABEL_34;
    }
    v9 = *(_WORD *)i;
    i += 2;
  }
  LOBYTE(v17) = v23;
LABEL_33:
  v18 = a4;
LABEL_34:
  v19 = i - 2;
  if ( v17 & 8 )
  {
    if ( v17 & 4
      || !(v17 & 1) && (v17 & 2 && (unsigned int)v8 > 0x80000000 || !(v17 & 2) && (unsigned int)v8 > 0x7FFFFFFF) )
    {
      *(_DWORD *)sub_1002F144(v8) = 34;
      LOBYTE(v17) = v23;
      if ( v23 & 1 )
        v8 = -1;
      else
        v8 = ((v23 & 2) != 0) + 2147483647;
    }
  }
  else
  {
    if ( v18 )
      v19 = a3;
    v8 = 0;
  }
  if ( v18 )
    *(_DWORD *)v18 = v19;
  if ( v17 & 2 )
    v8 = -v8;
  return v8;
}

//----- (1004C1FA) --------------------------------------------------------
int __usercall sub_1004C1FA<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, unsigned int a5)
{
  return sub_1004C01E(a1, a2, a3, a4, a5, 0);
}

//----- (1004C212) --------------------------------------------------------
signed int __usercall sub_1004C212<eax>(int a1<ebx>, int a2<edi>, unsigned int a3, int a4, unsigned int a5, unsigned int a6)
{
  unsigned int v7; // [sp-8h] [bp-8h]@3
  int v8; // [sp-4h] [bp-4h]@3

  if ( a6 != 10 || (signed int)a3 >= 0 )
  {
    v8 = 0;
    v7 = a6;
  }
  else
  {
    v8 = 1;
    v7 = 10;
  }
  return sub_1004C23B(a1, a2, a3, a4, a5, v7, v8);
}

//----- (1004C23B) --------------------------------------------------------
signed int __userpurge sub_1004C23B<eax>(int a1<ebx>, int a2<edi>, unsigned int a3, int a4, unsigned int a5, unsigned int a6, int a7)
{
  int v8; // eax@4
  signed int v9; // esi@5
  unsigned int v10; // edx@9
  char v11; // zf@9
  signed int v12; // ecx@11
  int v13; // eax@12
  unsigned int v14; // ett@12
  int v15; // eax@13
  int v16; // edi@20
  __int16 v17; // cx@21
  signed int v18; // [sp-Ch] [bp-10h]@4
  signed int v19; // [sp+1Ch] [bp+18h]@9

  if ( !a4 )
  {
    *(_DWORD *)sub_1002F144(a1) = 22;
    sub_10036C88(a1, a2);
    return 22;
  }
  if ( !a5 )
    goto LABEL_25;
  *(_WORD *)a4 = 0;
  if ( a5 <= (unsigned int)(a7 != 0) + 1 )
  {
    v8 = sub_1002F144(a1);
    v18 = 34;
    goto LABEL_5;
  }
  v9 = 34;
  if ( a6 - 2 > 0x22 )
  {
LABEL_25:
    v8 = sub_1002F144(a1);
    v18 = 22;
LABEL_5:
    v9 = v18;
LABEL_19:
    *(_DWORD *)v8 = v9;
    sub_10036C88(a1, a2);
    return v9;
  }
  v11 = a7 == 0;
  v10 = a3;
  v19 = 0;
  a2 = a4;
  if ( !v11 )
  {
    *(_WORD *)a4 = 45;
    a2 = a4 + 2;
    v19 = 1;
    v10 = -a3;
  }
  v12 = v19;
  a1 = a2;
  do
  {
    v14 = v10;
    v10 /= a6;
    v13 = v14 % a6;
    if ( v14 % a6 <= 9 )
      v15 = v13 + 48;
    else
      v15 = v13 + 87;
    *(_WORD *)a2 = v15;
    a2 += 2;
    ++v12;
  }
  while ( v10 && v12 < a5 );
  if ( v12 >= a5 )
  {
    *(_WORD *)a4 = 0;
    v8 = sub_1002F144(a1);
    goto LABEL_19;
  }
  *(_WORD *)a2 = 0;
  v16 = a2 - 2;
  do
  {
    v17 = *(_WORD *)v16;
    *(_WORD *)v16 = *(_WORD *)a1;
    *(_WORD *)a1 = v17;
    v16 -= 2;
    a1 += 2;
  }
  while ( a1 < (unsigned int)v16 );
  return 0;
}

//----- (1004C32E) --------------------------------------------------------
int __usercall sub_1004C32E<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  return sub_1004C1FA(a1, a2, a3, 0, 0xAu);
}

//----- (1004C342) --------------------------------------------------------
int __cdecl sub_1004C342(int a1, unsigned __int16 a2)
{
  int result; // eax@9

  _ECX = a1;
  if ( dword_100695C0 < 1 )
  {
    while ( *(_WORD *)_ECX && *(_WORD *)_ECX != a2 )
      _ECX += 2;
LABEL_9:
    result = _ECX & ((*(_WORD *)_ECX != a2) - 1);
  }
  else
  {
    _EAX = a2;
    __asm
    {
      movd    xmm0, eax
      pshuflw xmm0, xmm0, 0
      pshufd  xmm2, xmm0, 0
    }
    while ( 1 )
    {
      while ( (_ECX & 0xFFFu) <= 0xFF0 )
      {
        __asm
        {
          movdqu  xmm0, xmmword ptr [ecx]
          pxor    xmm1, xmm1
          pcmpeqw xmm1, xmm0
          pcmpeqw xmm0, xmm2
          por     xmm1, xmm0
          pmovmskb eax, xmm1
        }
        if ( _EAX )
        {
          __asm { bsf     eax, eax }
          _ECX += _EAX;
          goto LABEL_9;
        }
        _ECX += 16;
      }
      if ( *(_WORD *)_ECX == a2 )
        break;
      if ( !*(_WORD *)_ECX )
        return 0;
      _ECX += 2;
    }
    result = _ECX;
  }
  return result;
}
// 1004C342: could not find valid save-restore pair for ebp
// 100695C0: using guessed type int dword_100695C0;

//----- (1004C3F0) --------------------------------------------------------
signed int __usercall sub_1004C3F0<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  signed int result; // eax@2
  int v6; // edi@2
  int v7; // ecx@5
  int v8; // edx@6
  signed __int16 v9; // si@6
  unsigned __int16 v10; // ax@8
  unsigned __int16 v11; // si@10
  unsigned __int16 v12; // ax@12

  if ( dword_10069EE8 )
  {
    result = sub_1004C4A4(a2, a3, a4, a5, 0);
  }
  else
  {
    v6 = a5;
    result = 0;
    if ( a5 )
    {
      if ( a3 && (v7 = a4, a4) )
      {
        v9 = 90;
        v8 = a3 - a4;
        while ( 1 )
        {
          v10 = *(_WORD *)(v8 + v7);
          if ( v10 < 0x41u || v10 > v9 )
            v11 = *(_WORD *)(v8 + v7);
          else
            v11 = v10 + 32;
          v12 = *(_WORD *)v7;
          if ( *(_WORD *)v7 >= 0x41u )
          {
            if ( v12 <= 0x5Au )
              v12 += 32;
          }
          v7 += 2;
          --v6;
          if ( !v6 )
            break;
          if ( !v11 || v11 != v12 )
            break;
          v9 = 90;
        }
        result = v11 - v12;
      }
      else
      {
        *(_DWORD *)sub_1002F144(a1) = 22;
        sub_10036C88(a1, a5);
        result = 2147483647;
      }
    }
  }
  return result;
}
// 10069EE8: using guessed type int dword_10069EE8;

//----- (1004C4A4) --------------------------------------------------------
signed int __usercall sub_1004C4A4<eax>(int a1<edi>, int a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  int v6; // ebx@2
  int v8; // ecx@6
  int v9; // ebx@6
  signed __int16 v10; // si@6
  unsigned __int16 v11; // ax@8
  WCHAR v12; // si@10
  WCHAR v13; // ax@12
  char v14; // zf@19
  int v15; // [sp+Ch] [bp-14h]@5
  int v16; // [sp+14h] [bp-Ch]@23
  char v17; // [sp+18h] [bp-8h]@22
  int v18; // [sp+1Ch] [bp-4h]@6

  v5 = 0;
  if ( a4 )
  {
    v6 = a2;
    if ( !a2 || (a1 = a3, !a3) )
    {
      *(_DWORD *)sub_1002F144(a2) = 22;
      sub_10036C88(a2, a1);
      return 2147483647;
    }
    sub_1002E635((int)&v15, a2, a3, a5);
    if ( *(_DWORD *)(v15 + 168) )
    {
      do
      {
        v12 = sub_1004A555(v6, a1, *(_WORD *)v6, (int)&v15);
        v13 = sub_1004A555(v6, a1, *(_WORD *)a1, (int)&v15);
        v14 = a4-- == 1;
        v6 += 2;
        a1 += 2;
      }
      while ( !v14 && v12 && v12 == v13 );
    }
    else
    {
      v8 = a4;
      v10 = 90;
      v9 = a2 - a3;
      v18 = 90;
      while ( 1 )
      {
        v11 = *(_WORD *)(v9 + a1);
        if ( v11 < 0x41u || v11 > v10 )
          v12 = *(_WORD *)(v9 + a1);
        else
          v12 = v11 + 32;
        v13 = *(_WORD *)a1;
        if ( *(_WORD *)a1 >= 0x41u )
        {
          if ( v13 <= (_WORD)v18 )
            v13 += 32;
        }
        a1 += 2;
        --v8;
        if ( !v8 )
          break;
        if ( !v12 || v12 != v13 )
          break;
        v10 = 90;
      }
    }
    v5 = v12 - v13;
    if ( v17 )
      *(_DWORD *)(v16 + 112) &= 0xFFFFFFFDu;
  }
  return v5;
}

//----- (1004C59B) --------------------------------------------------------
signed int __cdecl sub_1004C59B(int a1, int a2)
{
  int v2; // edx@1
  signed int v3; // ebx@1
  int v4; // edi@1
  __int16 v5; // dx@1
  signed int v6; // eax@2
  int v7; // esi@2
  int v8; // edx@8
  int v9; // ecx@8
  signed int v10; // edi@8
  char i; // zf@9
  int v12; // eax@14
  signed int v13; // ecx@14
  unsigned int v14; // eax@14
  char v15; // cf@14
  int v16; // edx@17
  int v17; // eax@19
  unsigned int v18; // eax@19
  char v19; // cf@19
  int v20; // ecx@28
  char v21; // di@34
  int v22; // eax@34
  int v23; // eax@35
  unsigned int v24; // edx@35
  int v25; // eax@36
  int *v26; // edx@36
  signed int v27; // ecx@36
  signed int v28; // edi@36
  int v29; // edx@41
  int v30; // ecx@41
  int v31; // ecx@41
  char j; // zf@42
  int v33; // eax@47
  signed int v34; // ecx@47
  unsigned int v35; // eax@47
  signed int v36; // edi@47
  int v37; // edi@47
  char v38; // cf@47
  int v39; // edx@50
  int v40; // eax@52
  unsigned int v41; // eax@52
  char v42; // cf@52
  int v43; // edx@59
  int v44; // eax@61
  char v45; // bl@61
  signed int v46; // edi@61
  int v47; // ecx@61
  unsigned int v48; // edx@62
  int *v49; // edx@63
  signed int v50; // ecx@63
  int v51; // ecx@70
  signed int v52; // edi@70
  int v53; // eax@71
  unsigned int v54; // edx@71
  int *v55; // edx@72
  signed int v56; // ecx@72
  char v57; // bl@78
  signed int v58; // edi@78
  signed int v59; // esi@78
  int v60; // eax@79
  unsigned int v61; // edx@79
  int *v62; // edx@80
  signed int v63; // ecx@80
  int v64; // esi@86
  int v65; // eax@87
  int v67; // [sp+Ch] [bp-44h]@1
  int v68; // [sp+14h] [bp-3Ch]@8
  int v69; // [sp+14h] [bp-3Ch]@34
  signed int v70; // [sp+18h] [bp-38h]@14
  int v71; // [sp+18h] [bp-38h]@34
  int v72; // [sp+18h] [bp-38h]@70
  int v73; // [sp+18h] [bp-38h]@78
  signed int v74; // [sp+1Ch] [bp-34h]@8
  int v75; // [sp+1Ch] [bp-34h]@61
  int v76; // [sp+1Ch] [bp-34h]@70
  char v77; // [sp+20h] [bp-30h]@8
  int v78; // [sp+20h] [bp-30h]@41
  signed int v79; // [sp+24h] [bp-2Ch]@8
  signed int v80; // [sp+28h] [bp-28h]@34
  int v81; // [sp+28h] [bp-28h]@61
  int v82; // [sp+28h] [bp-28h]@70
  int v83; // [sp+28h] [bp-28h]@78
  int v84; // [sp+2Ch] [bp-24h]@8
  signed int v85; // [sp+2Ch] [bp-24h]@47
  int v86; // [sp+2Ch] [bp-24h]@61
  int v87; // [sp+2Ch] [bp-24h]@78
  int v88; // [sp+30h] [bp-20h]@1
  int v89; // [sp+30h] [bp-20h]@34
  int v90; // [sp+30h] [bp-20h]@61
  int v91; // [sp+30h] [bp-20h]@70
  int v92; // [sp+30h] [bp-20h]@78
  int v93; // [sp+34h] [bp-1Ch]@8
  int v94; // [sp+38h] [bp-18h]@8
  int v95; // [sp+3Ch] [bp-14h]@8
  int v96; // [sp+40h] [bp-10h]@1
  int v97; // [sp+44h] [bp-Ch]@1
  int v98; // [sp+48h] [bp-8h]@1
  unsigned int v99; // [sp+4Ch] [bp-4h]@1
  int v100; // [sp+50h] [bp+0h]@1

  v99 = (unsigned int)&v100 ^ __security_cookie;
  v5 = *(_WORD *)(a1 + 10);
  v67 = *(_WORD *)(a1 + 10) & 0x8000;
  v96 = *(_DWORD *)(a1 + 6);
  v97 = *(_DWORD *)(a1 + 2);
  v2 = (v5 & 0x7FFF) - 16383;
  v4 = a2;
  v3 = 0;
  v88 = v2;
  v98 = *(_WORD *)a1 << 16;
  if ( v2 == -16383 )
  {
    v7 = 0;
    v6 = 0;
    while ( !*(&v96 + v6) )
    {
      ++v6;
      if ( v6 >= 3 )
        goto LABEL_86;
    }
    v96 = 0;
    v97 = 0;
    v98 = 0;
  }
  else
  {
    v93 = v96;
    v94 = v97;
    v84 = v2;
    v74 = dword_10068630 - 1;
    v95 = v98;
    v8 = dword_10068630 / 32;
    v79 = 0;
    v68 = dword_10068630 / 32;
    v9 = 31 - dword_10068630 % 32;
    v10 = -1;
    v77 = v9;
    if ( (1 << v9) & *(&v96 + dword_10068630 / 32) )
    {
      for ( i = (~(-1 << v9) & *(&v96 + v8)) == 0; i; i = *(&v96 + v8) == 0 )
      {
        ++v8;
        if ( v8 >= 3 )
          goto LABEL_25;
      }
      v79 = 0;
      v10 = -1;
      v70 = 1 << (31 - v74 % 32);
      v14 = *(&v96 + v74 / 32);
      v15 = v14 + v70 < v14;
      v12 = v14 + v70;
      v13 = 0;
      if ( v15 || v12 < (unsigned int)v70 )
      {
        v13 = 1;
        v79 = 1;
      }
      v16 = v74 / 32 - 1;
      *(&v97 + v16) = v12;
      if ( v16 >= 0 )
      {
        do
        {
          if ( !v13 )
            break;
          v18 = *(&v96 + v16);
          v13 = 0;
          v19 = v18 + 1 < v18;
          v79 = 0;
          v17 = v18 + 1;
          if ( v19 || (unsigned int)v17 < 1 )
          {
            v13 = 1;
            v79 = 1;
          }
          --v16;
          *(&v97 + v16) = v17;
        }
        while ( v16 >= 0 );
        v10 = -1;
      }
      LOBYTE(v9) = v77;
LABEL_25:
      v8 = v68;
    }
    *(&v96 + v8) &= v10 << v9;
    if ( v8 + 1 < 3 )
    {
      memset(&v96 + v8 + 1, 0, 4 * (3 - (v8 + 1)));
      v10 = -1;
    }
    v20 = v88;
    if ( v79 )
      v20 = v88 + 1;
    if ( v20 >= dword_1006862C - dword_10068630 )
    {
      if ( v20 > dword_1006862C )
      {
        if ( v20 < dword_10068628 )
        {
          v96 &= 0x7FFFFFFFu;
          v73 = v20 + dword_1006863C;
          v83 = dword_10068634 / 32;
          v92 = 0;
          v59 = 0;
          v57 = dword_10068634 % 32;
          v58 = ~(v10 << dword_10068634 % 32);
          v87 = 32 - dword_10068634 % 32;
          do
          {
            v60 = (v58 & *(&v96 + v59)) << v87;
            v61 = v92 | ((unsigned int)*(&v96 + v59++) >> v57);
            *(&v95 + v59) = v61;
            v92 = v60;
          }
          while ( v59 < 3 );
          v7 = v73;
          v62 = &v98 - v83;
          v63 = 2;
          v3 = 0;
          do
          {
            if ( v63 < v83 )
              *(&v96 + v63) = 0;
            else
              *(&v96 + v63) = *v62;
            --v62;
            --v63;
          }
          while ( v63 >= 0 );
        }
        else
        {
          v97 = 0;
          v98 = 0;
          v96 = -2147483648;
          v76 = dword_10068634 / 32;
          v51 = dword_10068634 % 32;
          v72 = dword_10068634 % 32;
          v52 = ~(-1 << dword_10068634 % 32);
          v91 = 0;
          v82 = 32 - dword_10068634 % 32;
          do
          {
            v53 = (v52 & *(&v96 + v3)) << v82;
            v54 = v91 | ((unsigned int)*(&v96 + v3) >> v51);
            LOBYTE(v51) = v72;
            *(&v96 + v3++) = v54;
            v91 = v53;
          }
          while ( v3 < 3 );
          v55 = &v98 - v76;
          v56 = 2;
          do
          {
            if ( v56 < v76 )
              *(&v96 + v56) = 0;
            else
              *(&v96 + v56) = *v55;
            --v55;
            --v56;
          }
          while ( v56 >= 0 );
          v7 = dword_10068628 + dword_1006863C;
          v3 = 1;
        }
        goto LABEL_85;
      }
      v96 = v93;
      v97 = v94;
      v69 = (dword_1006862C - v84) / 32;
      v98 = v95;
      v22 = (dword_1006862C - v84) % 32;
      v21 = (dword_1006862C - v84) % 32;
      v89 = 0;
      v80 = ~(-1 << v22);
      v71 = 32 - v22;
      do
      {
        v23 = (v80 & *(&v96 + v3)) << v71;
        v24 = v89 | ((unsigned int)*(&v96 + v3++) >> v21);
        *(&v95 + v3) = v24;
        v89 = v23;
      }
      while ( v3 < 3 );
      v26 = &v98 - v69;
      v25 = v69;
      v27 = 2;
      v28 = -1;
      do
      {
        if ( v27 < v25 )
        {
          *(&v96 + v27) = 0;
        }
        else
        {
          *(&v96 + v27) = *v26;
          v25 = v69;
        }
        --v26;
        --v27;
      }
      while ( v27 >= 0 );
      v29 = (v74 + 1) / 32;
      v31 = (v74 + 1) % 32;
      v78 = 31 - v31;
      v30 = 31 - v31;
      if ( (1 << v30) & *(&v96 + v29) )
      {
        for ( j = (~(-1 << v30) & *(&v96 + v29)) == 0; j; j = *(&v96 + v29) == 0 )
        {
          ++v29;
          if ( v29 >= 3 )
            goto LABEL_58;
        }
        v35 = *(&v96 + v74 / 32);
        v36 = 1 << (31 - v74 % 32);
        v34 = 0;
        v85 = v36;
        v37 = v35 + v36;
        v38 = v37 < v35;
        v33 = v37;
        v28 = -1;
        if ( v38 || v33 < (unsigned int)v85 )
          v34 = 1;
        v39 = v74 / 32 - 1;
        *(&v97 + v39) = v33;
        if ( v39 >= 0 )
        {
          do
          {
            if ( !v34 )
              break;
            v41 = *(&v96 + v39);
            v34 = 0;
            v42 = v41 + 1 < v41;
            v40 = v41 + 1;
            if ( v42 || (unsigned int)v40 < 1 )
              v34 = 1;
            --v39;
            *(&v97 + v39) = v40;
          }
          while ( v39 >= 0 );
          v28 = -1;
        }
        LOBYTE(v30) = v78;
LABEL_58:
        v29 = (v74 + 1) / 32;
      }
      *(&v96 + v29) &= v28 << v30;
      v43 = v29 + 1;
      if ( v43 < 3 )
      {
        memset(&v96 + v43, 0, 4 * (3 - v43));
        v28 = -1;
      }
      v81 = (dword_10068634 + 1) / 32;
      v47 = (dword_10068634 + 1) % 32;
      v44 = 0;
      v90 = 0;
      v45 = (dword_10068634 + 1) % 32;
      v46 = ~(v28 << v47);
      v75 = 0;
      v86 = 32 - v47;
      do
      {
        v48 = *(&v96 + v44);
        *(&v96 + v75) = v90 | (v48 >> v45);
        v90 = (v46 & v48) << v86;
        v44 = v75 + 1;
        v75 = v44;
      }
      while ( v44 < 3 );
      v49 = &v98 - v81;
      v50 = 2;
      v3 = 0;
      do
      {
        if ( v50 < v81 )
          *(&v96 + v50) = 0;
        else
          *(&v96 + v50) = *v49;
        --v49;
        --v50;
      }
      while ( v50 >= 0 );
    }
    else
    {
      v96 = 0;
      v97 = 0;
      v98 = 0;
    }
    v7 = v3;
  }
  v3 = 2;
LABEL_85:
  v4 = a2;
LABEL_86:
  v64 = v96 | (v67 != 0 ? 0x80000000 : 0) | (v7 << (31 - dword_10068634));
  if ( dword_10068638 == 64 )
  {
    v65 = v97;
    *(_DWORD *)(v4 + 4) = v64;
    *(_DWORD *)v4 = v65;
  }
  else
  {
    if ( dword_10068638 == 32 )
      *(_DWORD *)v4 = v64;
  }
  return v3;
}
// 10067210: using guessed type int __security_cookie;
// 10068628: using guessed type int dword_10068628;
// 1006862C: using guessed type int dword_1006862C;
// 10068630: using guessed type int dword_10068630;
// 10068634: using guessed type int dword_10068634;
// 10068638: using guessed type int dword_10068638;
// 1006863C: using guessed type int dword_1006863C;

//----- (1004CB0B) --------------------------------------------------------
signed int __cdecl sub_1004CB0B(int a1, int a2)
{
  int v2; // edx@1
  signed int v3; // ebx@1
  int v4; // edi@1
  __int16 v5; // dx@1
  signed int v6; // eax@2
  int v7; // esi@2
  int v8; // edx@8
  int v9; // ecx@8
  signed int v10; // edi@8
  char i; // zf@9
  int v12; // eax@14
  signed int v13; // ecx@14
  unsigned int v14; // eax@14
  char v15; // cf@14
  int v16; // edx@17
  int v17; // eax@19
  unsigned int v18; // eax@19
  char v19; // cf@19
  int v20; // ecx@28
  char v21; // di@34
  int v22; // eax@34
  int v23; // eax@35
  unsigned int v24; // edx@35
  int v25; // eax@36
  int *v26; // edx@36
  signed int v27; // ecx@36
  signed int v28; // edi@36
  int v29; // edx@41
  int v30; // ecx@41
  int v31; // ecx@41
  char j; // zf@42
  int v33; // eax@47
  signed int v34; // ecx@47
  unsigned int v35; // eax@47
  signed int v36; // edi@47
  int v37; // edi@47
  char v38; // cf@47
  int v39; // edx@50
  int v40; // eax@52
  unsigned int v41; // eax@52
  char v42; // cf@52
  int v43; // edx@59
  int v44; // eax@61
  char v45; // bl@61
  signed int v46; // edi@61
  int v47; // ecx@61
  unsigned int v48; // edx@62
  int *v49; // edx@63
  signed int v50; // ecx@63
  int v51; // ecx@70
  signed int v52; // edi@70
  int v53; // eax@71
  unsigned int v54; // edx@71
  int *v55; // edx@72
  signed int v56; // ecx@72
  char v57; // bl@78
  signed int v58; // edi@78
  signed int v59; // esi@78
  int v60; // eax@79
  unsigned int v61; // edx@79
  int *v62; // edx@80
  signed int v63; // ecx@80
  int v64; // esi@86
  int v65; // eax@87
  int v67; // [sp+Ch] [bp-44h]@1
  int v68; // [sp+14h] [bp-3Ch]@8
  int v69; // [sp+14h] [bp-3Ch]@34
  signed int v70; // [sp+18h] [bp-38h]@14
  int v71; // [sp+18h] [bp-38h]@34
  int v72; // [sp+18h] [bp-38h]@70
  int v73; // [sp+18h] [bp-38h]@78
  signed int v74; // [sp+1Ch] [bp-34h]@8
  int v75; // [sp+1Ch] [bp-34h]@61
  int v76; // [sp+1Ch] [bp-34h]@70
  char v77; // [sp+20h] [bp-30h]@8
  int v78; // [sp+20h] [bp-30h]@41
  signed int v79; // [sp+24h] [bp-2Ch]@8
  signed int v80; // [sp+28h] [bp-28h]@34
  int v81; // [sp+28h] [bp-28h]@61
  int v82; // [sp+28h] [bp-28h]@70
  int v83; // [sp+28h] [bp-28h]@78
  int v84; // [sp+2Ch] [bp-24h]@8
  signed int v85; // [sp+2Ch] [bp-24h]@47
  int v86; // [sp+2Ch] [bp-24h]@61
  int v87; // [sp+2Ch] [bp-24h]@78
  int v88; // [sp+30h] [bp-20h]@1
  int v89; // [sp+30h] [bp-20h]@34
  int v90; // [sp+30h] [bp-20h]@61
  int v91; // [sp+30h] [bp-20h]@70
  int v92; // [sp+30h] [bp-20h]@78
  int v93; // [sp+34h] [bp-1Ch]@8
  int v94; // [sp+38h] [bp-18h]@8
  int v95; // [sp+3Ch] [bp-14h]@8
  int v96; // [sp+40h] [bp-10h]@1
  int v97; // [sp+44h] [bp-Ch]@1
  int v98; // [sp+48h] [bp-8h]@1
  unsigned int v99; // [sp+4Ch] [bp-4h]@1
  int v100; // [sp+50h] [bp+0h]@1

  v99 = (unsigned int)&v100 ^ __security_cookie;
  v5 = *(_WORD *)(a1 + 10);
  v67 = *(_WORD *)(a1 + 10) & 0x8000;
  v96 = *(_DWORD *)(a1 + 6);
  v97 = *(_DWORD *)(a1 + 2);
  v2 = (v5 & 0x7FFF) - 16383;
  v4 = a2;
  v3 = 0;
  v88 = v2;
  v98 = *(_WORD *)a1 << 16;
  if ( v2 == -16383 )
  {
    v7 = 0;
    v6 = 0;
    while ( !*(&v96 + v6) )
    {
      ++v6;
      if ( v6 >= 3 )
        goto LABEL_86;
    }
    v96 = 0;
    v97 = 0;
    v98 = 0;
  }
  else
  {
    v93 = v96;
    v94 = v97;
    v84 = v2;
    v74 = dword_10068648 - 1;
    v95 = v98;
    v8 = dword_10068648 / 32;
    v79 = 0;
    v68 = dword_10068648 / 32;
    v9 = 31 - dword_10068648 % 32;
    v10 = -1;
    v77 = v9;
    if ( (1 << v9) & *(&v96 + dword_10068648 / 32) )
    {
      for ( i = (~(-1 << v9) & *(&v96 + v8)) == 0; i; i = *(&v96 + v8) == 0 )
      {
        ++v8;
        if ( v8 >= 3 )
          goto LABEL_25;
      }
      v79 = 0;
      v10 = -1;
      v70 = 1 << (31 - v74 % 32);
      v14 = *(&v96 + v74 / 32);
      v15 = v14 + v70 < v14;
      v12 = v14 + v70;
      v13 = 0;
      if ( v15 || v12 < (unsigned int)v70 )
      {
        v13 = 1;
        v79 = 1;
      }
      v16 = v74 / 32 - 1;
      *(&v97 + v16) = v12;
      if ( v16 >= 0 )
      {
        do
        {
          if ( !v13 )
            break;
          v18 = *(&v96 + v16);
          v13 = 0;
          v19 = v18 + 1 < v18;
          v79 = 0;
          v17 = v18 + 1;
          if ( v19 || (unsigned int)v17 < 1 )
          {
            v13 = 1;
            v79 = 1;
          }
          --v16;
          *(&v97 + v16) = v17;
        }
        while ( v16 >= 0 );
        v10 = -1;
      }
      LOBYTE(v9) = v77;
LABEL_25:
      v8 = v68;
    }
    *(&v96 + v8) &= v10 << v9;
    if ( v8 + 1 < 3 )
    {
      memset(&v96 + v8 + 1, 0, 4 * (3 - (v8 + 1)));
      v10 = -1;
    }
    v20 = v88;
    if ( v79 )
      v20 = v88 + 1;
    if ( v20 >= dword_10068644 - dword_10068648 )
    {
      if ( v20 > dword_10068644 )
      {
        if ( v20 < dword_10068640 )
        {
          v96 &= 0x7FFFFFFFu;
          v73 = v20 + dword_10068654;
          v83 = dword_1006864C / 32;
          v92 = 0;
          v59 = 0;
          v57 = dword_1006864C % 32;
          v58 = ~(v10 << dword_1006864C % 32);
          v87 = 32 - dword_1006864C % 32;
          do
          {
            v60 = (v58 & *(&v96 + v59)) << v87;
            v61 = v92 | ((unsigned int)*(&v96 + v59++) >> v57);
            *(&v95 + v59) = v61;
            v92 = v60;
          }
          while ( v59 < 3 );
          v7 = v73;
          v62 = &v98 - v83;
          v63 = 2;
          v3 = 0;
          do
          {
            if ( v63 < v83 )
              *(&v96 + v63) = 0;
            else
              *(&v96 + v63) = *v62;
            --v62;
            --v63;
          }
          while ( v63 >= 0 );
        }
        else
        {
          v97 = 0;
          v98 = 0;
          v96 = -2147483648;
          v76 = dword_1006864C / 32;
          v51 = dword_1006864C % 32;
          v72 = dword_1006864C % 32;
          v52 = ~(-1 << dword_1006864C % 32);
          v91 = 0;
          v82 = 32 - dword_1006864C % 32;
          do
          {
            v53 = (v52 & *(&v96 + v3)) << v82;
            v54 = v91 | ((unsigned int)*(&v96 + v3) >> v51);
            LOBYTE(v51) = v72;
            *(&v96 + v3++) = v54;
            v91 = v53;
          }
          while ( v3 < 3 );
          v55 = &v98 - v76;
          v56 = 2;
          do
          {
            if ( v56 < v76 )
              *(&v96 + v56) = 0;
            else
              *(&v96 + v56) = *v55;
            --v55;
            --v56;
          }
          while ( v56 >= 0 );
          v7 = dword_10068640 + dword_10068654;
          v3 = 1;
        }
        goto LABEL_85;
      }
      v96 = v93;
      v97 = v94;
      v69 = (dword_10068644 - v84) / 32;
      v98 = v95;
      v22 = (dword_10068644 - v84) % 32;
      v21 = (dword_10068644 - v84) % 32;
      v89 = 0;
      v80 = ~(-1 << v22);
      v71 = 32 - v22;
      do
      {
        v23 = (v80 & *(&v96 + v3)) << v71;
        v24 = v89 | ((unsigned int)*(&v96 + v3++) >> v21);
        *(&v95 + v3) = v24;
        v89 = v23;
      }
      while ( v3 < 3 );
      v26 = &v98 - v69;
      v25 = v69;
      v27 = 2;
      v28 = -1;
      do
      {
        if ( v27 < v25 )
        {
          *(&v96 + v27) = 0;
        }
        else
        {
          *(&v96 + v27) = *v26;
          v25 = v69;
        }
        --v26;
        --v27;
      }
      while ( v27 >= 0 );
      v29 = (v74 + 1) / 32;
      v31 = (v74 + 1) % 32;
      v78 = 31 - v31;
      v30 = 31 - v31;
      if ( (1 << v30) & *(&v96 + v29) )
      {
        for ( j = (~(-1 << v30) & *(&v96 + v29)) == 0; j; j = *(&v96 + v29) == 0 )
        {
          ++v29;
          if ( v29 >= 3 )
            goto LABEL_58;
        }
        v35 = *(&v96 + v74 / 32);
        v36 = 1 << (31 - v74 % 32);
        v34 = 0;
        v85 = v36;
        v37 = v35 + v36;
        v38 = v37 < v35;
        v33 = v37;
        v28 = -1;
        if ( v38 || v33 < (unsigned int)v85 )
          v34 = 1;
        v39 = v74 / 32 - 1;
        *(&v97 + v39) = v33;
        if ( v39 >= 0 )
        {
          do
          {
            if ( !v34 )
              break;
            v41 = *(&v96 + v39);
            v34 = 0;
            v42 = v41 + 1 < v41;
            v40 = v41 + 1;
            if ( v42 || (unsigned int)v40 < 1 )
              v34 = 1;
            --v39;
            *(&v97 + v39) = v40;
          }
          while ( v39 >= 0 );
          v28 = -1;
        }
        LOBYTE(v30) = v78;
LABEL_58:
        v29 = (v74 + 1) / 32;
      }
      *(&v96 + v29) &= v28 << v30;
      v43 = v29 + 1;
      if ( v43 < 3 )
      {
        memset(&v96 + v43, 0, 4 * (3 - v43));
        v28 = -1;
      }
      v81 = (dword_1006864C + 1) / 32;
      v47 = (dword_1006864C + 1) % 32;
      v44 = 0;
      v90 = 0;
      v45 = (dword_1006864C + 1) % 32;
      v46 = ~(v28 << v47);
      v75 = 0;
      v86 = 32 - v47;
      do
      {
        v48 = *(&v96 + v44);
        *(&v96 + v75) = v90 | (v48 >> v45);
        v90 = (v46 & v48) << v86;
        v44 = v75 + 1;
        v75 = v44;
      }
      while ( v44 < 3 );
      v49 = &v98 - v81;
      v50 = 2;
      v3 = 0;
      do
      {
        if ( v50 < v81 )
          *(&v96 + v50) = 0;
        else
          *(&v96 + v50) = *v49;
        --v49;
        --v50;
      }
      while ( v50 >= 0 );
    }
    else
    {
      v96 = 0;
      v97 = 0;
      v98 = 0;
    }
    v7 = v3;
  }
  v3 = 2;
LABEL_85:
  v4 = a2;
LABEL_86:
  v64 = v96 | (v67 != 0 ? 0x80000000 : 0) | (v7 << (31 - dword_1006864C));
  if ( dword_10068650 == 64 )
  {
    v65 = v97;
    *(_DWORD *)(v4 + 4) = v64;
    *(_DWORD *)v4 = v65;
  }
  else
  {
    if ( dword_10068650 == 32 )
      *(_DWORD *)v4 = v64;
  }
  return v3;
}
// 10067210: using guessed type int __security_cookie;
// 10068640: using guessed type int dword_10068640;
// 10068644: using guessed type int dword_10068644;
// 10068648: using guessed type int dword_10068648;
// 1006864C: using guessed type int dword_1006864C;
// 10068650: using guessed type int dword_10068650;
// 10068654: using guessed type int dword_10068654;

//----- (1004D07B) --------------------------------------------------------
signed int __cdecl sub_1004D07B(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  signed int v8; // eax@1
  signed int v9; // ebx@1
  char *v10; // edi@1
  int v11; // esi@1
  int v13; // ecx@3
  char v14; // dl@4
  char v15; // dl@9
  unsigned int v16; // eax@38
  int v17; // esi@38
  int v18; // eax@49
  unsigned __int8 v19; // sf@50
  unsigned __int8 v20; // of@50
  int v21; // eax@51
  int v22; // esi@56
  char v23; // zf@74
  int v24; // ecx@109
  int v25; // edi@112
  signed int v26; // esi@117
  char *v27; // eax@123
  char v28; // cl@128
  int v29; // ecx@128
  int v30; // ecx@129
  int v31; // esi@130
  unsigned __int16 v32; // di@131
  int v33; // esi@131
  signed int v34; // eax@145
  char *v35; // edx@145
  signed int v36; // edi@145
  int v37; // eax@147
  signed int v38; // ecx@147
  char *v39; // esi@147
  int v40; // edi@148
  int v41; // edi@148
  signed int v42; // eax@150
  int v43; // edx@157
  int v44; // edi@157
  int v45; // esi@157
  unsigned int v46; // eax@159
  int v47; // eax@165
  char v48; // zf@165
  char v49; // zf@166
  unsigned __int16 v50; // ax@167
  int v51; // ecx@177
  unsigned int v52; // eax@186
  int v53; // edx@186
  __int16 v54; // cx@186
  signed int v55; // esi@186
  signed int v56; // [sp-4h] [bp-8Ch]@11
  signed int v57; // [sp-4h] [bp-8Ch]@14
  signed int v58; // [sp-4h] [bp-8Ch]@188
  signed int v59; // [sp+18h] [bp-70h]@145
  signed __int16 v60; // [sp+1Ch] [bp-6Ch]@1
  signed int v61; // [sp+20h] [bp-68h]@145
  int v62; // [sp+20h] [bp-68h]@162
  signed int v63; // [sp+24h] [bp-64h]@1
  int v64; // [sp+24h] [bp-64h]@147
  signed int v65; // [sp+28h] [bp-60h]@1
  __int16 v66; // [sp+28h] [bp-60h]@131
  signed int v67; // [sp+2Ch] [bp-5Ch]@1
  int v68; // [sp+2Ch] [bp-5Ch]@131
  signed int v69; // [sp+30h] [bp-58h]@1
  int v70; // [sp+30h] [bp-58h]@148
  int v71; // [sp+34h] [bp-54h]@1
  signed int v72; // [sp+34h] [bp-54h]@128
  int v73; // [sp+38h] [bp-50h]@3
  __int64 *v74; // [sp+38h] [bp-50h]@129
  int v75; // [sp+38h] [bp-50h]@157
  unsigned int v76; // [sp+3Ch] [bp-4Ch]@1
  char *v77; // [sp+3Ch] [bp-4Ch]@128
  __int64 v78; // [sp+40h] [bp-48h]@130
  int v79; // [sp+48h] [bp-40h]@130
  int v80; // [sp+4Ch] [bp-3Ch]@115
  int v81; // [sp+50h] [bp-38h]@138
  unsigned int v82; // [sp+54h] [bp-34h]@135
  int v83; // [sp+56h] [bp-32h]@131
  __int64 v84; // [sp+5Ah] [bp-2Eh]@131
  signed int v85; // [sp+62h] [bp-26h]@172
  int v86; // [sp+64h] [bp-24h]@131
  char v87; // [sp+68h] [bp-20h]@1
  char v88; // [sp+7Fh] [bp-9h]@107
  unsigned int v89; // [sp+84h] [bp-4h]@1
  int v90; // [sp+88h] [bp+0h]@1

  v89 = (unsigned int)&v90 ^ __security_cookie;
  v9 = 0;
  v65 = 1;
  v8 = 0;
  v10 = &v87;
  v60 = 0;
  v76 = 0;
  v63 = 0;
  v69 = 0;
  v67 = 0;
  v11 = 0;
  v71 = 0;
  if ( !a8 )
  {
    *(_DWORD *)sub_1002F144(0) = 22;
    sub_10036C88(0, (int)&v87);
    return 0;
  }
  v13 = a3;
  v73 = a3;
  while ( 1 )
  {
    v14 = *(_BYTE *)v13;
    if ( *(_BYTE *)v13 != 32 )
    {
      if ( v14 != 9 && v14 != 10 && v14 != 13 )
        break;
    }
    ++v13;
  }
  while ( 2 )
  {
    v15 = *(_BYTE *)v13++;
    switch ( v8 )
    {
      case 0:
        if ( (unsigned __int8)(v15 - 49) <= 8u )
          goto LABEL_11;
        if ( v15 == ***(_BYTE ***)(*(_DWORD *)a8 + 132) )
          goto LABEL_14;
        if ( v15 == 43 )
        {
          v8 = 2;
          v60 = 0;
          continue;
        }
        if ( v15 == 45 )
        {
          v8 = 2;
          v60 = -32768;
          continue;
        }
        if ( v15 != 48 )
          goto LABEL_103;
        goto LABEL_19;
      case 1:
        v63 = 1;
        if ( (unsigned __int8)(v15 - 49) <= 8u )
          goto LABEL_11;
        if ( v15 == ***(_BYTE ***)(*(_DWORD *)a8 + 132) )
          goto LABEL_24;
        if ( v15 == 43 || v15 == 45 )
          goto LABEL_32;
        if ( v15 != 48 )
          goto LABEL_28;
        goto LABEL_19;
      case 2:
        if ( (unsigned __int8)(v15 - 49) <= 8u )
        {
LABEL_11:
          v56 = 3;
          goto LABEL_12;
        }
        if ( v15 == ***(_BYTE ***)(*(_DWORD *)a8 + 132) )
        {
LABEL_14:
          v57 = 5;
          goto LABEL_15;
        }
        if ( v15 != 48 )
          goto LABEL_36;
LABEL_19:
        v8 = 1;
        continue;
      case 3:
        v63 = 1;
        if ( v15 >= 48 )
        {
          v16 = v76;
          v17 = v71;
          do
          {
            if ( v15 > 57 )
              break;
            if ( v16 >= 0x19 )
            {
              ++v17;
            }
            else
            {
              ++v16;
              *v10++ = v15 - 48;
            }
            v15 = *(_BYTE *)v13++;
          }
          while ( v15 >= 48 );
          v71 = v17;
          v76 = v16;
          v11 = 0;
        }
        if ( v15 == ***(_BYTE ***)(*(_DWORD *)a8 + 132) )
        {
LABEL_24:
          v57 = 4;
        }
        else
        {
          if ( v15 == 43 || v15 == 45 )
          {
LABEL_32:
            --v13;
            v57 = 11;
          }
          else
          {
LABEL_28:
            if ( v15 <= 67 || v15 > 69 && (unsigned __int8)(v15 - 100) > 1u )
            {
LABEL_103:
              --v13;
              goto LABEL_104;
            }
LABEL_31:
            v57 = 6;
          }
        }
        goto LABEL_15;
      case 4:
        v63 = 1;
        v69 = 1;
        v18 = v76;
        if ( v76 )
          goto LABEL_54;
        v20 = __SETO__(v15, 48);
        v19 = (char)(v15 - 48) < 0;
        if ( v15 == 48 )
        {
          v21 = v71;
          do
          {
            v15 = *(_BYTE *)v13;
            --v21;
            ++v13;
          }
          while ( v15 == 48 );
          v71 = v21;
          v18 = v76;
LABEL_54:
          v20 = __SETO__(v15, 48);
          v19 = (char)(v15 - 48) < 0;
        }
        if ( !(v19 ^ v20) )
        {
          v22 = v71;
          do
          {
            if ( v15 > 57 )
              break;
            if ( (unsigned int)v18 < 0x19 )
            {
              ++v18;
              *v10++ = v15 - 48;
              --v22;
            }
            v15 = *(_BYTE *)v13++;
          }
          while ( v15 >= 48 );
          v71 = v22;
          v76 = v18;
          v11 = 0;
        }
        if ( v15 == 43 || v15 == 45 )
          goto LABEL_32;
        if ( v15 > 67 && (v15 <= 69 || (unsigned __int8)(v15 - 100) <= 1u) )
          goto LABEL_31;
        --v13;
        goto LABEL_105;
      case 5:
        v69 = 1;
        if ( (unsigned __int8)(v15 - 48) > 9u )
          goto LABEL_36;
        v56 = 4;
        goto LABEL_12;
      case 6:
        v73 = v13 - 2;
        if ( (unsigned __int8)(v15 - 49) <= 8u )
          goto LABEL_71;
        if ( v15 == 43 )
          goto LABEL_78;
        if ( v15 != 45 )
        {
          v23 = v15 == 48;
          goto LABEL_75;
        }
        v8 = 7;
        v65 = -1;
        continue;
      case 8:
        v67 = 1;
        while ( v15 == 48 )
          v15 = *(_BYTE *)v13++;
        if ( (unsigned __int8)(v15 - 49) <= 8u )
          goto LABEL_71;
        goto LABEL_103;
      case 7:
        if ( (unsigned __int8)(v15 - 49) <= 8u )
        {
LABEL_71:
          v56 = 9;
LABEL_12:
          v8 = v56;
          --v13;
          continue;
        }
        v23 = v15 == 48;
LABEL_75:
        if ( !v23 )
          goto LABEL_36;
        v57 = 8;
        goto LABEL_15;
      case 11:
        if ( !a7 )
        {
          v8 = 10;
          --v13;
LABEL_91:
          if ( v8 == 10 )
            goto LABEL_104;
          continue;
        }
        v73 = v13 - 1;
        if ( v15 == 43 )
        {
LABEL_78:
          v57 = 7;
LABEL_15:
          v8 = v57;
          continue;
        }
        if ( v15 == 45 )
        {
          v65 = -1;
          v8 = 7;
          continue;
        }
LABEL_36:
        v13 = v73;
LABEL_104:
        v18 = v76;
LABEL_105:
        *(_DWORD *)a2 = v13;
        if ( !v63 )
        {
          LOWORD(v52) = 0;
          v55 = 0;
          v58 = 4;
          goto LABEL_191;
        }
        if ( (unsigned int)v18 <= 0x18 )
        {
          v24 = v71;
        }
        else
        {
          if ( v88 >= 5 )
            ++v88;
          --v10;
          v24 = v71 + 1;
          v18 = 24;
          ++v71;
        }
        if ( !v18 )
        {
          v54 = 0;
          LOWORD(v52) = 0;
          v55 = 0;
          v53 = 0;
          goto LABEL_192;
        }
        v25 = (int)(v10 - 1);
        if ( !*(_BYTE *)v25 )
        {
          do
          {
            --v18;
            ++v24;
            --v25;
          }
          while ( !*(_BYTE *)v25 );
          v71 = v24;
        }
        sub_1004F0B2((unsigned int *)&v87, v18, (int)&v80);
        if ( v65 < 0 )
          v11 = -v11;
        v26 = v71 + v11;
        if ( !v67 )
          v26 += a5;
        if ( !v69 )
          v26 -= a6;
        if ( v26 > 5200 )
        {
          LOWORD(v52) = 32767;
          v55 = -2147483648;
          v58 = 2;
LABEL_191:
          v54 = 0;
          v53 = 0;
          v9 = v58;
          goto LABEL_192;
        }
        if ( v26 < -5200 )
        {
          v54 = 0;
          LOWORD(v52) = 0;
          v55 = 0;
          v53 = 0;
          v9 = 1;
        }
        else
        {
          v27 = (char *)&unk_10068668 - 96;
          if ( v26 )
          {
            if ( v26 < 0 )
            {
              v26 = -v26;
              v27 = (char *)&unk_100687C8 - 96;
            }
            if ( !a4 )
              LOWORD(v80) = 0;
            do
            {
LABEL_185:
              if ( !v26 )
                goto LABEL_186;
              v28 = v26;
              v27 += 84;
              v26 >>= 3;
              v77 = v27;
              v72 = v26;
              v29 = v28 & 7;
            }
            while ( !v29 );
            v30 = (int)&v27[12 * v29];
            v74 = (__int64 *)v30;
            if ( *(_WORD *)v30 >= 0x8000u )
            {
              v78 = *(_QWORD *)v30;
              v31 = v30 + 8;
              v30 = (int)&v78;
              v79 = *(_DWORD *)v31;
              --*(_DWORD *)((char *)&v78 + 2);
              v74 = &v78;
            }
            v66 = (v83 ^ *(_WORD *)(v30 + 10)) & 0x8000;
            v32 = *(_WORD *)(v30 + 10) & 0x7FFF;
            v33 = (unsigned __int16)(v32 + (v83 & 0x7FFF));
            *(_DWORD *)((char *)&v84 + 2) = v9;
            *(_DWORD *)((char *)&v84 + 6) = v9;
            v86 = v9;
            v68 = (unsigned __int16)(v32 + (v83 & 0x7FFF));
            if ( (v83 & 0x7FFFu) >= 0x7FFF || v32 >= 0x7FFFu || (_WORD)v33 > 0xBFFDu )
              goto LABEL_182;
            if ( (_WORD)v33 <= 0x3FBFu )
              goto LABEL_135;
            if ( !(v83 & 0x7FFF) )
            {
              ++v33;
              v68 = v33;
              if ( !(v82 & 0x7FFFFFFF) )
              {
                if ( !v81 && !v80 )
                {
                  LOWORD(v83) = 0;
LABEL_184:
                  v27 = v77;
                  v26 = v72;
                  goto LABEL_185;
                }
              }
            }
            if ( v32
              || (v68 = v33 + 1, *(_DWORD *)(v30 + 8) & 0x7FFFFFFF)
              || *(_DWORD *)(v30 + 4) != v9
              || *(_DWORD *)v30 != v9 )
            {
              v34 = v9;
              v36 = 5;
              v59 = v9;
              v35 = (char *)&v84 + 6;
              v61 = 5;
              do
              {
                if ( v36 > 0 )
                {
                  v39 = (char *)&v80 + 2 * v34;
                  v37 = v30 + 8;
                  v64 = v30 + 8;
                  v38 = v36;
                  do
                  {
                    v41 = *(_WORD *)v39 * *(_WORD *)v37;
                    v70 = v41;
                    v40 = *((_DWORD *)v35 - 1) + v41;
                    if ( (unsigned int)v40 >= *((_DWORD *)v35 - 1) && v40 >= (unsigned int)v70 )
                      v42 = v9;
                    else
                      v42 = 1;
                    *((_DWORD *)v35 - 1) = v40;
                    if ( v42 )
                      ++*(_WORD *)v35;
                    v37 = v64 - 2;
                    v39 += 2;
                    --v38;
                    v64 -= 2;
                  }
                  while ( v38 > 0 );
                  v30 = (int)v74;
                  v36 = v61;
                  v34 = v59;
                }
                v35 += 2;
                ++v34;
                --v36;
                v59 = v34;
                v61 = v36;
              }
              while ( v36 > 0 );
              v43 = v86;
              v44 = *(_DWORD *)((char *)&v84 + 2);
              v45 = v68 + 49154;
              v75 = v86;
              if ( (signed __int16)(v68 - 16382) > 0 )
              {
                do
                {
                  if ( v43 < 0 )
                    break;
                  v46 = *(_DWORD *)((char *)&v84 + 6);
                  *(_DWORD *)((char *)&v84 + 6) = ((unsigned int)v44 >> 31) | 2 * *(_DWORD *)((char *)&v84 + 6);
                  v43 = (v46 >> 31) | 2 * v75;
                  v44 *= 2;
                  v45 += 65535;
                  *(_DWORD *)((char *)&v84 + 2) = v44;
                  v75 = v43;
                  v86 = v43;
                }
                while ( (_WORD)v45 > 0 );
                if ( (_WORD)v45 > 0 )
                  goto LABEL_195;
              }
              v45 += 65535;
              if ( (_WORD)v45 >= 0 )
                goto LABEL_195;
              v62 = (unsigned __int16)-(_WORD)v45;
              v45 += v62;
              do
              {
                if ( BYTE2(v84) & 1 )
                  ++v9;
                v47 = (v43 << 31) | (*(_DWORD *)((char *)&v84 + 6) >> 1);
                v43 = (unsigned int)v43 >> 1;
                v44 = (*(_DWORD *)((char *)&v84 + 6) << 31) | ((unsigned int)v44 >> 1);
                v48 = v62-- == 1;
                v86 = v43;
                *(_DWORD *)((char *)&v84 + 6) = v47;
                *(_DWORD *)((char *)&v84 + 2) = v44;
              }
              while ( !v48 );
              v49 = v9 == 0;
              v75 = v43;
              v9 = 0;
              if ( v49 )
              {
LABEL_195:
                v50 = WORD1(v84);
              }
              else
              {
                v50 = v44 | 1;
                WORD1(v84) = v44 | 1;
                v44 = *(_DWORD *)((char *)&v84 + 2);
              }
              if ( v50 > 0x8000u || (v44 & 0x1FFFF) == 98304 )
              {
                if ( HIDWORD(v84) == -1 )
                {
                  HIDWORD(v84) = v9;
                  if ( v85 == -1 )
                  {
                    v85 = v9;
                    if ( HIWORD(v86) == -1 )
                    {
                      HIWORD(v86) = -32768;
                      ++v45;
                    }
                    else
                    {
                      v86 += 65536;
                    }
                  }
                  else
                  {
                    *(__int64 *)((char *)&v84 + 4) += 4294967296i64;
                  }
                  v51 = v86;
                  goto LABEL_180;
                }
                v84 += 4294967296i64;
              }
              v51 = v75;
LABEL_180:
              if ( (_WORD)v45 < 0x7FFFu )
              {
                LOWORD(v80) = WORD2(v84);
                *(int *)((char *)&v80 + 2) = *(_DWORD *)((char *)&v84 + 6);
                *(int *)((char *)&v81 + 2) = v51;
                LOWORD(v83) = v66 | v45;
                goto LABEL_184;
              }
LABEL_182:
              v82 = (((v66 == 0) - 1) & 0x80000000) + 2147450880;
            }
            else
            {
LABEL_135:
              v82 = v9;
            }
            v80 = v9;
            v81 = v9;
            goto LABEL_184;
          }
LABEL_186:
          v54 = v80;
          v53 = *(int *)((char *)&v80 + 2);
          v55 = *(int *)((char *)&v81 + 2);
          v52 = v82 >> 16;
        }
LABEL_192:
        *(_WORD *)a1 = v54;
        *(_WORD *)(a1 + 10) = v60 | v52;
        *(_DWORD *)(a1 + 2) = v53;
        *(_DWORD *)(a1 + 6) = v55;
        return v9;
      default:
        goto LABEL_91;
      case 9:
        v67 = 1;
        v11 = 0;
        while ( 2 )
        {
          if ( v15 >= 48 && v15 <= 57 )
          {
            v11 = v15 + 10 * v11 - 48;
            if ( v11 <= 5200 )
            {
              v15 = *(_BYTE *)v13++;
              continue;
            }
            v11 = 5201;
          }
          break;
        }
        while ( v15 >= 48 && v15 <= 57 )
          v15 = *(_BYTE *)v13++;
        goto LABEL_103;
    }
  }
}
// 10067210: using guessed type int __security_cookie;

//----- (1004D7F7) --------------------------------------------------------
signed int __cdecl sub_1004D7F7(__int64 a1, __int16 a2, int a3, char a4, int a5)
{
  __int16 v5; // dx@1
  unsigned __int16 v6; // si@1
  signed int result; // eax@6
  char v8; // zf@25
  char *v9; // eax@25
  int v10; // ecx@25
  int v11; // ebx@25
  int v12; // ecx@25
  int v13; // edx@29
  int v14; // esi@29
  int v15; // ecx@30
  int v16; // ecx@31
  int v17; // esi@32
  int v18; // edi@33
  unsigned __int16 v19; // di@33
  int v20; // eax@47
  char *v21; // edx@47
  signed int v22; // esi@47
  int v23; // eax@49
  signed int v24; // ecx@49
  int v25; // esi@49
  int v26; // eax@50
  int v27; // edi@50
  unsigned int v28; // eax@50
  char v29; // cf@50
  signed int v30; // esi@52
  int v31; // eax@59
  int v32; // edi@59
  int v33; // esi@59
  unsigned int v34; // eax@61
  unsigned int v35; // ebx@64
  int v36; // edi@64
  int v37; // eax@64
  int v38; // eax@67
  char v39; // zf@67
  char v40; // zf@68
  unsigned __int16 v41; // ax@69
  int v42; // ecx@79
  int v43; // eax@91
  int v44; // edi@92
  signed int v45; // eax@106
  int v46; // edx@106
  char *v47; // ecx@106
  signed int v48; // esi@107
  int v49; // eax@108
  int v50; // edi@108
  int v51; // edx@109
  int v52; // edi@109
  unsigned int v53; // eax@109
  signed int v54; // eax@111
  int v55; // edi@118
  int v56; // esi@118
  unsigned int v57; // ebx@119
  unsigned int v58; // eax@121
  int v59; // edx@122
  unsigned __int16 v60; // cx@123
  int v61; // edi@132
  int v62; // eax@132
  int v63; // ebx@135
  char v64; // zf@135
  char v65; // zf@136
  int v66; // ecx@146
  int v67; // edi@146
  int v68; // ebx@153
  signed int v69; // edi@153
  unsigned int v70; // eax@154
  int v71; // edi@156
  unsigned int v72; // ebx@157
  unsigned int v73; // eax@158
  int v74; // ecx@160
  int v75; // edi@160
  int v76; // esi@160
  unsigned int v77; // edx@161
  unsigned int v78; // ecx@161
  int v79; // esi@161
  int v80; // esi@161
  int v81; // ecx@161
  signed int v82; // ecx@163
  char v83; // zf@166
  unsigned int v84; // edi@168
  char v85; // al@174
  int v86; // ecx@174
  char v87; // cl@182
  int v88; // [sp-4h] [bp-98h]@11
  int v89; // [sp-4h] [bp-98h]@15
  int *v90; // [sp+Ch] [bp-88h]@31
  int v91; // [sp+10h] [bp-84h]@49
  int v92; // [sp+14h] [bp-80h]@47
  int v93; // [sp+18h] [bp-7Ch]@92
  __int16 v94; // [sp+1Ch] [bp-78h]@1
  int v95; // [sp+20h] [bp-74h]@33
  unsigned __int16 v96; // [sp+20h] [bp-74h]@92
  int *v97; // [sp+28h] [bp-6Ch]@108
  int v98; // [sp+2Ch] [bp-68h]@153
  __int16 v99; // [sp+30h] [bp-64h]@33
  unsigned __int16 v100; // [sp+34h] [bp-60h]@33
  signed int v101; // [sp+34h] [bp-60h]@48
  signed int v102; // [sp+38h] [bp-5Ch]@25
  int v103; // [sp+38h] [bp-5Ch]@132
  int v104; // [sp+38h] [bp-5Ch]@160
  char *v105; // [sp+3Ch] [bp-58h]@108
  int v106; // [sp+3Ch] [bp-58h]@160
  char *v107; // [sp+40h] [bp-54h]@30
  __int16 v108; // [sp+40h] [bp-54h]@92
  signed int v109; // [sp+44h] [bp-50h]@47
  int v110; // [sp+44h] [bp-50h]@64
  int v111; // [sp+44h] [bp-50h]@106
  int v112; // [sp+48h] [bp-4Ch]@33
  int v113; // [sp+48h] [bp-4Ch]@64
  int v114; // [sp+48h] [bp-4Ch]@92
  int v115; // [sp+48h] [bp-4Ch]@132
  int v116; // [sp+4Ch] [bp-48h]@25
  signed int v117; // [sp+4Ch] [bp-48h]@147
  unsigned int v118; // [sp+4Ch] [bp-48h]@161
  signed int v119; // [sp+50h] [bp-44h]@25
  unsigned int v120; // [sp+50h] [bp-44h]@155
  int v121; // [sp+54h] [bp-40h]@29
  int v122; // [sp+54h] [bp-40h]@49
  int v123; // [sp+54h] [bp-40h]@59
  unsigned int v124; // [sp+54h] [bp-40h]@155
  int v125; // [sp+58h] [bp-3Ch]@32
  __int64 v126; // [sp+5Ch] [bp-38h]@32
  int v127; // [sp+64h] [bp-30h]@1
  int v128; // [sp+68h] [bp-2Ch]@1
  int v129; // [sp+6Ch] [bp-28h]@1
  _TBYTE v130; // [sp+74h] [bp-20h]@25
  __int16 v131; // [sp+7Eh] [bp-16h]@25
  __int64 v132; // [sp+82h] [bp-12h]@33
  int v133; // [sp+8Ah] [bp-Ah]@74
  int v134; // [sp+8Ch] [bp-8h]@33
  unsigned int v135; // [sp+90h] [bp-4h]@1
  int v136; // [sp+94h] [bp+0h]@1

  v135 = (unsigned int)&v136 ^ __security_cookie;
  v5 = a2 & 0x8000;
  v6 = a2 & 0x7FFF;
  v127 = -858993460;
  v128 = -858993460;
  v129 = 1073466572;
  v94 = a2 & 0x8000;
  if ( a2 & 0x8000 )
    *(_BYTE *)(a5 + 2) = 45;
  else
    *(_BYTE *)(a5 + 2) = 32;
  if ( v6 )
  {
    if ( v6 != 32767 )
      goto LABEL_25;
    *(_WORD *)a5 = 1;
    if ( (HIDWORD(a1) != -2147483648 || (_DWORD)a1) && !(HIDWORD(a1) & 0x40000000) )
    {
      v88 = (int)"1#SNAN";
      goto LABEL_22;
    }
    if ( v5 && HIDWORD(a1) == -1073741824 )
    {
      if ( !(_DWORD)a1 )
      {
        v89 = (int)"1#IND";
        goto LABEL_19;
      }
    }
    else
    {
      if ( HIDWORD(a1) == -2147483648 && !(_DWORD)a1 )
      {
        v89 = (int)"1#INF";
LABEL_19:
        if ( !sub_10031E6C(a5, SHIDWORD(a1), a5 + 4, 22, v89) )
        {
          *(_BYTE *)(a5 + 3) = 5;
          return 0;
        }
LABEL_189:
        sub_10036C98(0, SHIDWORD(a1));
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_1004E1BB);
      }
    }
    v88 = (int)"1#QNAN";
LABEL_22:
    if ( !sub_10031E6C(a5, SHIDWORD(a1), a5 + 4, 22, v88) )
    {
      *(_BYTE *)(a5 + 3) = 6;
      return 0;
    }
    goto LABEL_189;
  }
  if ( !a1 )
  {
    *(_WORD *)a5 = 0;
    *(_BYTE *)(a5 + 2) = (((v5 != -32768) - 1) & 0xD) + 32;
    *(_BYTE *)(a5 + 3) = 1;
    *(_WORD *)(a5 + 4) = 48;
    return 1;
  }
LABEL_25:
  v12 = (unsigned __int16)((signed int)(19728 * v6 - 323162868 + 77
                                                               * (((unsigned int)v6 >> 8) + 2 * (HIDWORD(a1) >> 24))) >> 16);
  *(_QWORD *)((char *)&v130 + 2) = a1;
  v116 = v12;
  LOWORD(v130) = 0;
  v10 = -(signed __int16)v12;
  v9 = (char *)&unk_10068668 - 96;
  v11 = 0;
  v131 = a2 & 0x7FFF;
  v119 = v10;
  v102 = 5;
  v8 = v10 == 0;
  if ( v10 )
  {
    if ( v10 < 0 )
    {
      v10 = -v10;
      v9 = (char *)&unk_100687C8 - 96;
      v119 = v10;
      v8 = v10 == 0;
    }
    if ( !v8 )
    {
      v14 = LODWORD(v130);
      v13 = DWORD1(v130);
      v121 = LODWORD(v130);
      while ( 1 )
      {
        v119 >>= 3;
        v9 += 84;
        v107 = v9;
        v15 = v10 & 7;
        if ( v15 )
          break;
LABEL_88:
        LOBYTE(v10) = v119;
        if ( !v119 )
          goto LABEL_91;
      }
      v16 = (int)&v9[12 * v15];
      v90 = (int *)v16;
      if ( *(_WORD *)v16 >= 0x8000u )
      {
        v125 = *(_DWORD *)v16;
        LODWORD(v126) = *(_DWORD *)(v16 + 4);
        v17 = v16 + 8;
        v16 = (int)&v125;
        HIDWORD(v126) = *(_DWORD *)v17;
        --*(int *)((char *)&v125 + 2);
        v90 = &v125;
      }
      v19 = *(_WORD *)(v16 + 10) & 0x7FFF;
      v99 = (v131 ^ *(_WORD *)(v16 + 10)) & 0x8000;
      v100 = v19;
      v18 = (unsigned __int16)(v19 + (v131 & 0x7FFF));
      v95 = v11;
      *(_DWORD *)((char *)&v132 + 2) = v11;
      *(_DWORD *)((char *)&v132 + 6) = v11;
      v134 = v11;
      v112 = v18;
      if ( (v131 & 0x7FFFu) >= 0x7FFF || (v14 = v121, v100 >= 0x7FFFu) || (_WORD)v18 > 0xBFFDu )
      {
LABEL_84:
        *((_DWORD *)&v130 + 2) = (((v99 == 0) - 1) & 0x80000000) + 2147450880;
        goto LABEL_85;
      }
      if ( (_WORD)v18 <= 0x3FBFu )
        goto LABEL_193;
      if ( !(v131 & 0x7FFF) )
      {
        ++v18;
        v112 = v18;
        if ( !(*((_DWORD *)&v130 + 2) & 0x7FFFFFFF) )
        {
          if ( !v13 && !v121 )
          {
            v131 = 0;
LABEL_87:
            v9 = v107;
            goto LABEL_88;
          }
        }
      }
      if ( !v100 )
      {
        v112 = v18 + 1;
        if ( !(*(_DWORD *)(v16 + 8) & 0x7FFFFFFF) )
        {
          if ( *(_DWORD *)(v16 + 4) == v11 && *(_DWORD *)v16 == v11 )
          {
LABEL_193:
            *((_DWORD *)&v130 + 2) = v11;
LABEL_85:
            v14 = v11;
            v13 = v11;
            LODWORD(v130) = v11;
            DWORD1(v130) = v11;
            goto LABEL_86;
          }
        }
      }
      v20 = v11;
      v22 = 5;
      v92 = v11;
      v21 = (char *)&v132 + 6;
      v109 = 5;
      do
      {
        v101 = v22;
        if ( v22 > 0 )
        {
          v23 = (int)((char *)&v130 + 2 * v20);
          v25 = v16 + 8;
          v24 = v101;
          v122 = v23;
          v91 = v25;
          do
          {
            v27 = *(_WORD *)v25 * *(_WORD *)v23;
            v28 = *((_DWORD *)v21 - 1);
            v29 = v28 + v27 < v28;
            v26 = v28 + v27;
            if ( v29 || v26 < (unsigned int)v27 )
              v30 = 1;
            else
              v30 = v11;
            *((_DWORD *)v21 - 1) = v26;
            if ( v30 )
              ++*(_WORD *)v21;
            v23 = v122 + 2;
            v25 = v91 - 2;
            --v24;
            v122 += 2;
            v91 -= 2;
          }
          while ( v24 > 0 );
          v16 = (int)v90;
          v22 = v109;
          v20 = v92;
        }
        v21 += 2;
        ++v20;
        --v22;
        v92 = v20;
        v109 = v22;
      }
      while ( v22 > 0 );
      v31 = v134;
      v33 = *(_DWORD *)((char *)&v132 + 2);
      v32 = v112 + 49154;
      v123 = v134;
      if ( (signed __int16)(v112 - 16382) > 0 )
      {
        do
        {
          if ( v31 < 0 )
            break;
          v34 = *(_DWORD *)((char *)&v132 + 6);
          *(_DWORD *)((char *)&v132 + 6) = ((unsigned int)v33 >> 31) | 2 * *(_DWORD *)((char *)&v132 + 6);
          v31 = (v34 >> 31) | 2 * v123;
          v33 *= 2;
          v32 += 65535;
          *(_DWORD *)((char *)&v132 + 2) = v33;
          v123 = v31;
          v134 = v31;
        }
        while ( (_WORD)v32 > 0 );
        if ( (_WORD)v32 > 0 )
          goto LABEL_194;
      }
      v32 += 65535;
      if ( (_WORD)v32 >= 0 )
        goto LABEL_194;
      v35 = v123;
      v37 = (unsigned __int16)-(_WORD)v32;
      v113 = v37 + v32;
      v36 = v95;
      v110 = v37;
      do
      {
        if ( BYTE2(v132) & 1 )
          ++v36;
        v38 = (v35 << 31) | (*(_DWORD *)((char *)&v132 + 6) >> 1);
        v35 >>= 1;
        v33 = (*(_DWORD *)((char *)&v132 + 6) << 31) | ((unsigned int)v33 >> 1);
        v39 = v110-- == 1;
        v134 = v35;
        *(_DWORD *)((char *)&v132 + 6) = v38;
        *(_DWORD *)((char *)&v132 + 2) = v33;
      }
      while ( !v39 );
      v123 = v35;
      v40 = v36 == 0;
      v32 = v113;
      v11 = 0;
      if ( v40 )
      {
LABEL_194:
        v41 = WORD1(v132);
      }
      else
      {
        v41 = v33 | 1;
        WORD1(v132) = v33 | 1;
        v33 = *(_DWORD *)((char *)&v132 + 2);
      }
      if ( v41 > 0x8000u || (v33 & 0x1FFFF) == 98304 )
      {
        if ( HIDWORD(v132) == -1 )
        {
          HIDWORD(v132) = v11;
          if ( v133 == -1 )
          {
            v133 = v11;
            if ( HIWORD(v134) == -1 )
            {
              HIWORD(v134) = -32768;
              ++v32;
            }
            else
            {
              v134 += 65536;
            }
          }
          else
          {
            *(__int64 *)((char *)&v132 + 4) += 4294967296i64;
          }
          v42 = v134;
LABEL_82:
          if ( (_WORD)v32 < 0x7FFFu )
          {
            LOWORD(v130) = WORD2(v132);
            *(_DWORD *)((char *)&v130 + 2) = *(_DWORD *)((char *)&v132 + 6);
            v14 = LODWORD(v130);
            *(_DWORD *)((char *)&v130 + 6) = v42;
            v13 = DWORD1(v130);
            v131 = v99 | v32;
LABEL_86:
            v121 = v14;
            goto LABEL_87;
          }
          goto LABEL_84;
        }
        v132 += 4294967296i64;
      }
      v42 = v123;
      goto LABEL_82;
    }
  }
  v13 = DWORD1(v130);
  v14 = LODWORD(v130);
LABEL_91:
  v43 = *((_DWORD *)&v130 + 2) >> 16;
  if ( (unsigned __int16)(*((_DWORD *)&v130 + 2) >> 16) >= 0x3FFFu )
  {
    ++v116;
    v108 = (v43 ^ HIWORD(v129)) & 0x8000;
    v96 = HIWORD(v129) & 0x7FFF;
    v44 = (unsigned __int16)((v43 & 0x7FFF) + (HIWORD(v129) & 0x7FFF));
    v93 = v11;
    *(_DWORD *)((char *)&v132 + 2) = v11;
    *(_DWORD *)((char *)&v132 + 6) = v11;
    v134 = v11;
    v114 = (unsigned __int16)((v43 & 0x7FFF) + (HIWORD(v129) & 0x7FFF));
    if ( (v43 & 0x7FFFu) >= 0x7FFF || v96 >= 0x7FFFu || (_WORD)v44 > 0xBFFDu )
    {
LABEL_144:
      *((_DWORD *)&v130 + 2) = (((v108 == 0) - 1) & 0x80000000) + 2147450880;
      goto LABEL_145;
    }
    if ( (_WORD)v44 <= 0x3FBFu )
      goto LABEL_195;
    if ( !(v43 & 0x7FFF) )
    {
      ++v44;
      v114 = v44;
      if ( !(*((_DWORD *)&v130 + 2) & 0x7FFFFFFF) )
      {
        if ( !v13 && !v14 )
        {
          v131 = 0;
          goto LABEL_146;
        }
      }
    }
    if ( !v96 )
    {
      v114 = v44 + 1;
      if ( !(v129 & 0x7FFFFFFF) )
      {
        if ( !v128 && !v127 )
        {
LABEL_195:
          *((_DWORD *)&v130 + 2) = v11;
LABEL_145:
          v14 = v11;
          v13 = v11;
          goto LABEL_146;
        }
      }
    }
    v46 = v11;
    v111 = v11;
    v47 = (char *)&v132 + 6;
    v45 = 5;
    do
    {
      v48 = v45;
      if ( v45 > 0 )
      {
        v49 = (int)&v129;
        v50 = (int)((char *)&v130 + 2 * v46);
        v97 = &v129;
        v105 = (char *)&v130 + 2 * v46;
        do
        {
          v51 = *(_WORD *)v50 * *(_WORD *)v49;
          v53 = *((_DWORD *)v47 - 1);
          v52 = v53 + v51;
          if ( v53 + v51 >= v53 && v52 >= (unsigned int)v51 )
            v54 = v11;
          else
            v54 = 1;
          *((_DWORD *)v47 - 1) = v52;
          if ( v54 )
            ++*(_WORD *)v47;
          v50 = (int)(v105 + 2);
          v49 = (int)((char *)v97 - 2);
          --v48;
          v105 += 2;
          v97 = (int *)((char *)v97 - 2);
        }
        while ( v48 > 0 );
        v46 = v111;
        v45 = v102;
      }
      v47 += 2;
      ++v46;
      --v45;
      v111 = v46;
      v102 = v45;
    }
    while ( v45 > 0 );
    v56 = v134;
    v55 = v114 + 49154;
    if ( (signed __int16)(v114 - 16382) <= 0 )
    {
      v59 = *(_DWORD *)((char *)&v132 + 2);
    }
    else
    {
      v57 = *(_DWORD *)((char *)&v132 + 2);
      do
      {
        if ( v56 < 0 )
          break;
        v58 = *(_DWORD *)((char *)&v132 + 6);
        *(_DWORD *)((char *)&v132 + 6) = (v57 >> 31) | 2 * *(_DWORD *)((char *)&v132 + 6);
        v57 *= 2;
        v56 = (v58 >> 31) | 2 * v56;
        v55 += 65535;
        *(_DWORD *)((char *)&v132 + 2) = v57;
        v134 = v56;
      }
      while ( (_WORD)v55 > 0 );
      v59 = v57;
      v11 = 0;
      if ( (_WORD)v55 > 0 )
        goto LABEL_123;
    }
    v55 += 65535;
    if ( (_WORD)v55 < 0 )
    {
      v62 = (unsigned __int16)-(_WORD)v55;
      v115 = v62 + v55;
      v61 = v93;
      v103 = v62;
      do
      {
        if ( BYTE2(v132) & 1 )
          ++v61;
        v63 = (v56 << 31) | (*(_DWORD *)((char *)&v132 + 6) >> 1);
        v59 = (*(_DWORD *)((char *)&v132 + 6) << 31) | ((unsigned int)v59 >> 1);
        v56 = (unsigned int)v56 >> 1;
        v64 = v103-- == 1;
        *(_DWORD *)((char *)&v132 + 6) = v63;
        *(_DWORD *)((char *)&v132 + 2) = v59;
      }
      while ( !v64 );
      v65 = v61 == 0;
      v55 = v115;
      v134 = v56;
      v11 = 0;
      if ( !v65 )
      {
        v60 = v59 | 1;
        WORD1(v132) = v59 | 1;
        v59 = *(_DWORD *)((char *)&v132 + 2);
        goto LABEL_124;
      }
    }
LABEL_123:
    v60 = WORD1(v132);
LABEL_124:
    if ( v60 > 0x8000u || (v59 & 0x1FFFF) == 98304 )
    {
      if ( HIDWORD(v132) == -1 )
      {
        HIDWORD(v132) = v11;
        if ( v133 == -1 )
        {
          v133 = v11;
          if ( HIWORD(v134) == -1 )
          {
            HIWORD(v134) = -32768;
            ++v55;
          }
          else
          {
            v134 += 65536;
          }
        }
        else
        {
          ++v133;
        }
        v56 = v134;
      }
      else
      {
        v132 += 4294967296i64;
      }
    }
    if ( (_WORD)v55 < 0x7FFFu )
    {
      LOWORD(v130) = WORD2(v132);
      *(_DWORD *)((char *)&v130 + 2) = *(_DWORD *)((char *)&v132 + 6);
      *(_DWORD *)((char *)&v130 + 6) = v56;
      v13 = DWORD1(v130);
      v14 = LODWORD(v130);
      v131 = v108 | v55;
      goto LABEL_146;
    }
    goto LABEL_144;
  }
LABEL_146:
  v66 = a5;
  v67 = a3;
  *(_WORD *)a5 = v116;
  if ( a4 & 1 )
  {
    v67 = (signed __int16)v116 + a3;
    v117 = v67;
    if ( v67 <= 0 )
    {
      *(_WORD *)a5 = 0;
      *(_BYTE *)(a5 + 2) = (((v94 != -32768) - 1) & 0xD) + 32;
      result = 1;
      *(_BYTE *)(a5 + 3) = 1;
      *(_BYTE *)(a5 + 4) = 48;
LABEL_149:
      *(_BYTE *)(v66 + 5) = v11;
      return result;
    }
  }
  else
  {
    v117 = a3;
  }
  if ( v67 > 21 )
    v117 = 21;
  v98 = (*((_DWORD *)&v130 + 2) >> 16) - 16382;
  v131 = 0;
  v68 = *((_DWORD *)&v130 + 2);
  v69 = 8;
  do
  {
    v70 = (unsigned int)v14 >> 31;
    v14 *= 2;
    v68 = ((unsigned int)v13 >> 31) | 2 * v68;
    v13 = v70 | 2 * v13;
    LODWORD(v130) = v14;
    *((_DWORD *)&v130 + 2) = v68;
    --v69;
  }
  while ( v69 );
  v120 = v68;
  DWORD1(v130) = v13;
  v124 = v14;
  v11 = 0;
  if ( v98 < 0 )
  {
    v71 = -v98 & 0xFF;
    if ( v71 > 0 )
    {
      v72 = v120;
      do
      {
        v73 = v72 << 31;
        v72 >>= 1;
        v14 = (v13 << 31) | ((unsigned int)v14 >> 1);
        v13 = v73 | ((unsigned int)v13 >> 1);
        --v71;
        *((_DWORD *)&v130 + 2) = v72;
        LODWORD(v130) = v14;
      }
      while ( v71 > 0 );
      v120 = v72;
      DWORD1(v130) = v13;
      v124 = v14;
      v11 = 0;
    }
  }
  v76 = a5;
  v75 = a5 + 4;
  v74 = a5 + 4;
  v104 = a5 + 4;
  v106 = v117 + 1;
  if ( v117 + 1 > 0 )
  {
    while ( 1 )
    {
      v125 = LODWORD(v130);
      v126 = *(_QWORD *)((char *)&v130 + 4);
      v80 = ((unsigned int)v13 >> 31) | 2 * v120;
      v81 = (v124 >> 31) | 2 * v13;
      v77 = (2 * v124 >> 31) | 2 * v81;
      v79 = ((unsigned int)v81 >> 31) | 2 * v80;
      v78 = LODWORD(v130) + 4 * v124;
      v118 = v78;
      if ( v78 < 4 * v124 || v78 < LODWORD(v130) )
      {
        v82 = v11;
        if ( v77 + 1 < v77 || v77 + 1 < 1 )
          v82 = 1;
        v83 = v82 == 0;
        v78 = v118;
        ++v77;
        if ( !v83 )
          ++v79;
      }
      v84 = v126 + v77;
      if ( (_DWORD)v126 + v77 < v77 || v84 < (_DWORD)v126 )
        ++v79;
      v124 = 2 * v118;
      LODWORD(v130) = 2 * v118;
      v13 = (v78 >> 31) | 2 * v84;
      *((_DWORD *)&v130 + 2) = (v84 >> 31) | 2 * (HIDWORD(v126) + v79);
      *(_BYTE *)v104 = (*((_DWORD *)&v130 + 2) >> 24) + 48;
      v74 = v104 + 1;
      DWORD1(v130) = v13;
      ++v104;
      HIBYTE(v131) = v11;
      --v106;
      if ( v106 <= 0 )
        break;
      v120 = *((_DWORD *)&v130 + 2);
    }
    v76 = a5;
    v75 = a5 + 4;
  }
  v85 = *(_BYTE *)(v74 - 1);
  v86 = v74 - 2;
  if ( v85 < 53 )
  {
    while ( v86 >= (unsigned int)v75 && *(_BYTE *)v86 == 48 )
      --v86;
    if ( v86 < (unsigned int)v75 )
    {
      v66 = a5;
      *(_WORD *)a5 = 0;
      *(_BYTE *)(a5 + 2) = (((v94 != -32768) - 1) & 0xD) + 32;
      result = 1;
      *(_BYTE *)(a5 + 3) = 1;
      *(_BYTE *)v75 = 48;
      goto LABEL_149;
    }
  }
  else
  {
    while ( v86 >= (unsigned int)v75 && *(_BYTE *)v86 == 57 )
      *(_BYTE *)v86-- = 48;
    if ( v86 < (unsigned int)v75 )
    {
      ++v86;
      ++*(_WORD *)v76;
    }
    ++*(_BYTE *)v86;
  }
  v87 = v86 - (_BYTE)a5 - 3;
  *(_BYTE *)(a5 + 3) = v87;
  *(_BYTE *)(v87 + a5 + 4) = v11;
  return 1;
}
// 10067210: using guessed type int __security_cookie;

//----- (1004E1BB) --------------------------------------------------------
signed int __cdecl sub_1004E1BB(int a1)
{
  signed int result; // eax@1
  int v2; // ecx@1
  int v3; // edx@13
  int v4; // ecx@20

  v2 = a1;
  result = 0;
  if ( a1 & 0x10 )
    result = 128;
  if ( a1 & 8 )
    result |= 0x200u;
  if ( a1 & 4 )
    result |= 0x400u;
  if ( a1 & 2 )
    result |= 0x800u;
  if ( a1 & 1 )
    result |= 0x1000u;
  if ( v2 & 0x80000 )
    result |= 0x100u;
  v3 = a1 & 0x300;
  if ( a1 & 0x300 )
  {
    switch ( v3 )
    {
      case 256:
        result |= 0x2000u;
        break;
      case 512:
        result |= 0x4000u;
        break;
      case 768:
        result |= 0x6000u;
        break;
    }
  }
  v4 = a1 & 0x3000000;
  if ( (a1 & 0x3000000) == 16777216 )
  {
    result |= 0x8040u;
  }
  else
  {
    if ( v4 == 33554432 )
    {
      result |= 0x40u;
    }
    else
    {
      if ( v4 == 50331648 )
        result |= 0x8000u;
    }
  }
  return result;
}

//----- (1004E264) --------------------------------------------------------
int __cdecl sub_1004E264(int a1, int a2)
{
  signed int v2; // ecx@1
  char v3; // ST1C_1@1
  char v4; // ST1C_1@3
  char v5; // ST1C_1@5
  char v6; // ST1C_1@7
  char v7; // ST1C_1@9
  char v8; // ST1C_1@11
  int v9; // edx@13
  __int16 v10; // ST1C_2@13
  __int16 v11; // ST1C_2@20
  __int16 v12; // ST1C_2@21
  signed int v13; // edx@24
  __int16 v14; // ST1C_2@24
  int v15; // esi@26
  __int16 v16; // ax@27
  int v17; // ecx@39
  signed int v18; // ecx@53
  int v19; // edx@65
  int v20; // eax@78
  int v21; // eax@79
  int v22; // edx@91
  int v23; // ecx@104
  int v24; // eax@104
  int result; // eax@106
  int v26; // [sp+0h] [bp-Ch]@53
  int v27; // [sp+18h] [bp+Ch]@79

  v2 = 0;
  if ( v3 & 1 )
    v2 = 16;
  if ( v4 & 4 )
    v2 |= 8u;
  if ( v5 & 8 )
    v2 |= 4u;
  if ( v6 & 0x10 )
    v2 |= 2u;
  if ( v7 & 0x20 )
    v2 |= 1u;
  if ( v8 & 2 )
    v2 |= 0x80000u;
  v9 = v10 & 0xC00;
  if ( v10 & 0xC00 )
  {
    switch ( v9 )
    {
      case 1024:
        v2 |= 0x100u;
        break;
      case 2048:
        v2 |= 0x200u;
        break;
      case 3072:
        v2 |= 0x300u;
        break;
    }
  }
  if ( v11 & 0x300 )
  {
    if ( (v12 & 0x300) == 512 )
      v2 |= 0x10000u;
  }
  else
  {
    v2 |= 0x20000u;
  }
  v13 = 4096;
  if ( v14 & 0x1000 )
    v2 |= 0x40000u;
  v15 = a2 & a1 | v2 & ~a2;
  if ( v15 != v2 )
  {
    v16 = sub_1004E564(a2 & a1 | v2 & ~a2);
    v15 = 0;
    if ( v16 & 1 )
      v15 = 16;
    if ( v16 & 4 )
      v15 |= 8u;
    if ( v16 & 8 )
      v15 |= 4u;
    if ( v16 & 0x10 )
      v15 |= 2u;
    if ( v16 & 0x20 )
      v15 |= 1u;
    if ( v16 & 2 )
      v15 |= 0x80000u;
    v17 = v16 & 0xC00;
    if ( v16 & 0xC00 )
    {
      switch ( v17 )
      {
        case 1024:
          v15 |= 0x100u;
          break;
        case 2048:
          v15 |= 0x200u;
          break;
        case 3072:
          v15 |= 0x300u;
          break;
      }
    }
    if ( v16 & 0x300 )
    {
      if ( (v16 & 0x300) == 512 )
        v15 |= 0x10000u;
    }
    else
    {
      v15 |= 0x20000u;
    }
    v13 = 4096;
    if ( v16 & 0x1000 )
      v15 |= 0x40000u;
  }
  if ( dword_100695C0 < 1 )
  {
    result = v15;
  }
  else
  {
    __asm { stmxcsr [ebp+var_C] }
    v18 = 0;
    if ( (_BYTE)v26 < 0 )
      v18 = 16;
    if ( v26 & 0x200 )
      v18 |= 8u;
    if ( v26 & 0x400 )
      v18 |= 4u;
    if ( v26 & 0x800 )
      v18 |= 2u;
    if ( v26 & v13 )
      v18 |= 1u;
    if ( v26 & 0x100 )
      v18 |= 0x80000u;
    v19 = v26 & 0x6000;
    if ( v26 & 0x6000 )
    {
      switch ( v19 )
      {
        case 8192:
          v18 |= 0x100u;
          break;
        case 16384:
          v18 |= 0x200u;
          break;
        case 24576:
          v18 |= 0x300u;
          break;
      }
    }
    switch ( v26 & 0x8040 )
    {
      case 0x40:
        v18 |= 0x2000000u;
        break;
      case 0x8000:
        v18 |= 0x3000000u;
        break;
      case 0x8040:
        v18 |= 0x1000000u;
        break;
    }
    v20 = a1 & a2 & 0x308031F | v18 & ~(a2 & 0x308031F);
    if ( v20 != v18 )
    {
      v21 = sub_1004E1BB(v20);
      sub_10040FF7(v21);
      __asm { stmxcsr [ebp+arg_4] }
      v18 = 0;
      if ( (_BYTE)v27 < 0 )
        v18 = 16;
      if ( v27 & 0x200 )
        v18 |= 8u;
      if ( v27 & 0x400 )
        v18 |= 4u;
      if ( v27 & 0x800 )
        v18 |= 2u;
      if ( v27 & 0x1000 )
        v18 |= 1u;
      if ( v27 & 0x100 )
        v18 |= 0x80000u;
      v22 = v27 & 0x6000;
      if ( v27 & 0x6000 )
      {
        switch ( v22 )
        {
          case 8192:
            v18 |= 0x100u;
            break;
          case 16384:
            v18 |= 0x200u;
            break;
          case 24576:
            v18 |= 0x300u;
            break;
        }
      }
      switch ( v27 & 0x8040 )
      {
        case 0x40:
          v18 |= 0x2000000u;
          break;
        case 0x8000:
          v18 |= 0x3000000u;
          break;
        case 0x8040:
          v18 |= 0x1000000u;
          break;
      }
    }
    v24 = v15 ^ v18;
    v23 = v15 | v18;
    if ( v24 & 0x8031F )
      v23 |= 0x80000000u;
    result = v23;
  }
  return result;
}
// 100695C0: using guessed type int dword_100695C0;

//----- (1004E564) --------------------------------------------------------
signed int __cdecl sub_1004E564(int a1)
{
  signed int result; // eax@1
  int v2; // ecx@1
  int v3; // edx@13
  int v4; // edx@20
  int v5; // edx@20

  v2 = a1;
  result = 0;
  if ( a1 & 0x10 )
    result = 1;
  if ( a1 & 8 )
    result |= 4u;
  if ( a1 & 4 )
    result |= 8u;
  if ( a1 & 2 )
    result |= 0x10u;
  if ( a1 & 1 )
    result |= 0x20u;
  if ( v2 & 0x80000 )
    result |= 2u;
  v3 = a1 & 0x300;
  if ( a1 & 0x300 )
  {
    switch ( v3 )
    {
      case 256:
        result |= 0x400u;
        break;
      case 512:
        result |= 0x800u;
        break;
      case 768:
        result |= 0xC00u;
        break;
    }
  }
  v5 = a1;
  v4 = v5 & 0x30000;
  if ( v4 )
  {
    if ( v4 == 65536 )
      result |= 0x200u;
  }
  else
  {
    result |= 0x300u;
  }
  if ( v2 & 0x40000 )
    result |= 0x1000u;
  return result;
}

//----- (1004E5FB) --------------------------------------------------------
int __cdecl sub_1004E5FB()
{
  dword_1006A390 = IsProcessorFeaturePresent(0xAu);
  return 0;
}
// 1006A390: using guessed type int dword_1006A390;

//----- (1004E610) --------------------------------------------------------
void __usercall sub_1004E610(int a1<ebx>, __int64 a2<st0>)
{
  double v2; // ST00_8@1

  v2 = *(double *)&a2;
  __asm { movq    xmm0, [esp+8+var_8] }
  sub_1004E62E(a1, a2);
}

//----- (1004E62E) --------------------------------------------------------
double __usercall sub_1004E62E<st0>(int a1<ebx>, __int64 a2)
{
  signed int v3; // eax@2
  double result; // st7@3
  int v7; // ecx@4
  signed int v8; // edx@4
  double v11; // ST0A_8@4
  double v12; // st7@4
  double v13; // st7@4
  double v14; // ST0A_8@4
  double v15; // ST0A_8@4
  signed int v17; // edx@7
  int v18; // eax@21
  _BYTE v19[14]; // [sp+Ah] [bp-12h]@3

  __asm
  {
    unpcklpd xmm0, xmm0
    movapd  xmm1, ds:xmmword_1005B950
    movapd  xmm6, ds:xmmword_1005B930
    movapd  xmm2, ds:xmmword_1005B960
    movapd  xmm3, ds:xmmword_1005B970
    pextrw  eax, xmm0, 3
  }
  if ( (((_EAX & 0x7FFF) - 15504) | (16527 - (_EAX & 0x7FFFu))) < 0x80000000 )
  {
    __asm
    {
      mulpd   xmm1, xmm0
      addpd   xmm1, xmm6
      movapd  xmm7, xmm1
      subpd   xmm1, xmm6
      mulpd   xmm2, xmm1
      movapd  xmm4, ds:xmmword_1005B980
      mulpd   xmm3, xmm1
      movapd  xmm5, ds:xmmword_1005B990
      subpd   xmm0, xmm2
      movd    eax, xmm7
    }
    _ECX = 16 * (_EAX & 0x3F);
    v3 = _EAX >> 6;
    __asm
    {
      subpd   xmm0, xmm3
      movapd  xmm2, ds:xmmword_1005B9A0[ecx]
      mulpd   xmm4, xmm0
      movapd  xmm1, xmm0
      mulpd   xmm0, xmm0
      addpd   xmm5, xmm4
      mulsd   xmm0, xmm0
      addsd   xmm1, xmm2
      unpckhpd xmm2, xmm2
      movdqa  xmm6, ds:xmmword_1005B910
      pand    xmm7, xmm6
      movdqa  xmm6, ds:xmmword_1005B920
      paddq   xmm7, xmm6
      psllq   xmm7, 2Eh
      mulpd   xmm0, xmm5
      addsd   xmm1, xmm0
      orpd    xmm2, xmm7
      unpckhpd xmm0, xmm0
      addsd   xmm0, xmm1
    }
    if ( (unsigned int)(v3 + 894) <= 0x77C )
    {
      __asm
      {
        mulsd   xmm0, xmm2
        addsd   xmm0, xmm2
        movlpd  [esp+10h+var_12+6], xmm0
      }
      return *(double *)&v19[6];
    }
    v8 = v3;
    _EAX = v3 >> 1;
    _EDX = v8 - _EAX;
    __asm
    {
      movdqa  xmm6, ds:xmmword_1005B900
      pandn   xmm6, xmm2
    }
    _EAX += 1023;
    __asm
    {
      movd    xmm3, eax
      psllq   xmm3, 34h
      orpd    xmm6, xmm3
    }
    _EDX += 1023;
    __asm
    {
      movd    xmm4, edx
      psllq   xmm4, 34h
      movlpd  [esp+12h+var_12], xmm0
    }
    v12 = v11;
    __asm { movlpd  [esp+12h+var_A], xmm6 }
    v13 = v12 * *(double *)&v19[8] + *(double *)&v19[8];
    __asm { movlpd  [esp+12h+var_12], xmm4 }
    v15 = v13 * v14;
    __asm
    {
      movlpd  xmm0, [esp+12h+var_12]
      pextrw  ecx, xmm0, 3
    }
    v7 = _ECX & 0x7FF0;
    if ( (unsigned int)v7 >= 0x7FF0 )
    {
      v17 = 14;
    }
    else
    {
      if ( v7 )
        goto LABEL_10;
      v17 = 15;
    }
LABEL_9:
    __asm { movlpd  [esp+1Ch+var_12+6], xmm0 }
    sub_1004F294(a1, (int)&a2, (int)&a2, (int)&v19[6], v17);
    __asm { movlpd  xmm0, [esp+1Ch+var_12+6] }
LABEL_10:
    __asm { movlpd  [esp+10h+var_12+6], xmm0 }
    return *(double *)&v19[6];
  }
  v18 = HIDWORD(a2) & 0x7FFFFFFF;
  if ( (HIDWORD(a2) & 0x7FFFFFFFu) >= 0x40900000 )
  {
    if ( (unsigned int)v18 < 0x7FF00000 )
    {
      if ( HIDWORD(a2) >= 0x80000000u )
      {
        __asm
        {
          movlpd  xmm0, ds:qword_1005BDD8
          mulsd   xmm0, xmm0
        }
        v17 = 15;
      }
      else
      {
        __asm
        {
          movlpd  xmm0, ds:qword_1005BDD0
          mulsd   xmm0, xmm0
        }
        v17 = 14;
      }
      goto LABEL_9;
    }
    if ( (unsigned int)v18 > 0x7FF00000 || (_DWORD)a2 )
    {
      v17 = 1002;
      goto LABEL_9;
    }
    if ( HIDWORD(a2) == 2146435072 )
      result = 1.797693134862316e308;
    else
      result = 0.0;
  }
  else
  {
    __asm
    {
      movlpd  xmm0, [esp+arg_0]
      addsd   xmm0, ds:qword_1005BDA0
      movlpd  [esp+10h+var_12+6], xmm0
    }
    result = *(double *)&v19[6];
  }
  return result;
}

//----- (1004E8E1) --------------------------------------------------------
double __usercall sub_1004E8E1<st0>(int a1<ebp>, double result<st0>)
{
  char v2; // ch@1

  *(_BYTE *)(a1 - 144) = -2;
  sub_1004EA1E();
  if ( v2 )
    result = -result;
  return result;
}
// 1004EA1E: using guessed type int sub_1004EA1E(void);

//----- (1004EA11) --------------------------------------------------------
double __fastcall sub_1004EA11(char a1)
{
  if ( a1 )
    JUMPOUT(*(unsigned int *)loc_10041EB6);
  return 1.189731495357232e4932;
}
// 10041EB6: using guessed type int loc_10041EB6();

//----- (1004EA1E) --------------------------------------------------------
#error "FFFFFFFF: positive sp value has been found (funcsize=0)"

//----- (1004EA61) --------------------------------------------------------
double __usercall sub_1004EA61<st0>(double result<st0>)
{
  double v3; // st6@2

  _ST6 = result;
  __asm { frndint }
  if ( _ST6 == result )
  {
    v3 = result * 0.5;
    _ST5 = result * 0.5;
    __asm { frndint }
    _ST5 == v3;
  }
  return result;
}

//----- (1004EB0E) --------------------------------------------------------
void __usercall sub_1004EB0E(int a1<edx>, __int16 a2<cx>, __int16 a3<fpstat>, double a4<st0>, char a5, char a6, char a7)
{
  int ebp0; // ebp@0
  char v8; // ST00_1@2
  char v9; // ST04_1@2
  char v10; // ST08_1@2

  if ( !dword_10068400 )
    UNDEF(a3);
  sub_10041DB0(a1, a2, ebp0, a3, a4, v8, v9, v10);
  sub_1004EB93(ebp0, a4);
}
// 10068400: using guessed type int dword_10068400;

//----- (1004EB93) --------------------------------------------------------
double __usercall sub_1004EB93<st0>(int a1<ebp>, double result<st0>)
{
  char v2; // al@2
  __int16 v3; // fps@2
  __int16 v7; // ax@11
  int v8; // ebx@20

  if ( dword_100695B4 )
    return result;
  UNDEF(v3);
  *(_QWORD *)(a1 - 720) = *(_QWORD *)&result;
  v2 = *(_BYTE *)(a1 - 144);
  if ( v2 )
  {
    if ( v2 == -1 )
    {
      if ( (*(_WORD *)(a1 - 714) & 0x7FF0) != 32752 )
        goto LABEL_7;
    }
    else
    {
      if ( v2 != -2 )
      {
        if ( !v2 )
          return result;
        *(_DWORD *)(a1 - 142) = v2;
        goto LABEL_20;
      }
      v7 = *(_WORD *)(a1 - 714) & 0x7FF0;
      if ( !v7 )
      {
        *(_DWORD *)(a1 - 142) = 4;
        if ( fabs(result) < 2.225073858507201e-308 )
          result = result * 0.0;
        goto LABEL_20;
      }
      if ( v7 != 32752 )
        goto LABEL_7;
    }
    *(_DWORD *)(a1 - 142) = 3;
    if ( fabs(result) > 1.797693134862316e308 )
      result = result * 1.797693134862316e308;
    goto LABEL_20;
  }
LABEL_7:
  if ( !(*(_WORD *)(a1 - 164) & 0x20) && v3 & 0x20 )
  {
    *(_DWORD *)(a1 - 142) = 8;
LABEL_20:
    v8 = *(_DWORD *)(a1 - 148) + 1;
    *(_DWORD *)(a1 - 138) = v8;
    if ( !(*(_BYTE *)(a1 - 712) & 1) )
    {
      *(_DWORD *)(a1 - 134) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 - 134 + 4) = *(_DWORD *)(a1 + 12);
      if ( *(_BYTE *)(v8 + 12) != 1 )
      {
        *(_DWORD *)(a1 - 126) = *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 - 126 + 4) = *(_DWORD *)(a1 + 20);
      }
    }
    *(_QWORD *)(a1 - 118) = *(_QWORD *)&result;
    sub_1004A659(a1, *(_BYTE *)(*(_DWORD *)(a1 - 148) + 14), a1 - 142, a1 - 164);
    result = *(double *)(a1 - 118);
  }
  return result;
}
// 100695B4: using guessed type int dword_100695B4;

//----- (1004ECDA) --------------------------------------------------------
int __usercall sub_1004ECDA<eax>(__int16 a1<fpstat>, char a2, char a3, char a4, double a5)
{
  int ebp0; // ebp@0
  double v7; // st7@1
  int v8; // edx@1
  __int16 v9; // cx@1
  char v10; // ST08_1@1
  char v11; // ST0C_1@1
  char v12; // ST10_1@1

  v7 = sub_1004ED0D(a5);
  sub_10041DB0(v8, v9, ebp0, a1, v7, v10, v11, v12);
  return sub_1004EB8C();
}
// 1004EB8C: using guessed type int sub_1004EB8C(void);

//----- (1004ED0D) --------------------------------------------------------
double __cdecl sub_1004ED0D(double a1)
{
  double result; // st7@2
  double v2; // ST06_8@2

  if ( (WORD3(a1) & 0x7FF0) == 32752 )
  {
    HIDWORD(v2) = *(_QWORD *)&a1 << 11 >> 32;
    LODWORD(v2) = LODWORD(a1);
    result = v2;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (1004ED49) --------------------------------------------------------
BOOL __cdecl sub_1004ED49()
{
  BOOL result; // eax@1

  result = (BOOL)hConsoleOutput;
  if ( hConsoleOutput != (HANDLE)-1 )
  {
    if ( hConsoleOutput != (HANDLE)-2 )
      result = CloseHandle(hConsoleOutput);
  }
  return result;
}

//----- (1004ED60) --------------------------------------------------------
HANDLE __cdecl sub_1004ED60()
{
  HANDLE result; // eax@1

  result = CreateFileW(L"CONOUT$", 0x40000000u, 3u, 0, 3u, 0, 0);
  hConsoleOutput = result;
  return result;
}

//----- (1004ED7F) --------------------------------------------------------
void __usercall sub_1004ED7F(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  if ( a5 == -2 )
  {
    *(_DWORD *)sub_1002F110(a3) = 0;
    *(_DWORD *)sub_1002F144(a3) = 9;
  }
  else
  {
    if ( a5 >= 0
      && a5 < (unsigned int)dword_1006A394
      && (a3 = a5 >> 5, a4 = (a5 & 0x1F) << 6, *(_BYTE *)(dword_10069CE0[a5 >> 5] + a4 + 4) & 1) )
    {
      sub_1004BD5B(a1, a2, a3, a5);
      if ( *(_BYTE *)(dword_10069CE0[a3] + a4 + 4) & 1 )
        sub_1004EE49(a3, a5);
      else
        *(_DWORD *)sub_1002F144(a3) = 9;
      sub_1004BED4(a5);
    }
    else
    {
      *(_DWORD *)sub_1002F110(a3) = 0;
      *(_DWORD *)sub_1002F144(a3) = 9;
      sub_10036C88(a3, a4);
    }
  }
}
// 10069CE0: using guessed type int dword_10069CE0[];
// 1006A394: using guessed type int dword_1006A394;

//----- (1004EE49) --------------------------------------------------------
signed int __usercall sub_1004EE49<eax>(int a1<ebx>, int a2)
{
  signed int v2; // esi@6
  void *v3; // eax@7
  int v4; // esi@8
  signed int result; // eax@11

  if ( sub_1004BE6D(a1, a2, a2) == -1
    || (a2 == 1 && *(_BYTE *)(dword_10069CE0[0] + 132) & 1 || a2 == 2 && *(_BYTE *)(dword_10069CE0[0] + 68) & 1)
    && (v2 = sub_1004BE6D(a1, a2, 2), sub_1004BE6D(a1, a2, 1) == v2)
    || (v3 = (void *)sub_1004BE6D(a1, a2, a2), CloseHandle(v3)) )
    v4 = 0;
  else
    v4 = GetLastError();
  sub_1004BDE7(a1, a2);
  *(_BYTE *)(dword_10069CE0[a2 >> 5] + ((a2 & 0x1F) << 6) + 4) = 0;
  if ( v4 )
  {
    sub_1002F123(a1, v4);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10069CE0: using guessed type int dword_10069CE0[];

//----- (1004EEE3) --------------------------------------------------------
int __usercall sub_1004EEE3<eax>(int a1<ebx>, int a2)
{
  int result; // eax@3

  if ( *(_BYTE *)(a2 + 12) & 0x83 )
  {
    if ( *(_BYTE *)(a2 + 12) & 8 )
    {
      sub_100282F6(a1, *(LPVOID *)(a2 + 8));
      *(_DWORD *)(a2 + 12) &= 0xFFFFFBF7u;
      result = 0;
      *(_DWORD *)a2 = 0;
      *(_DWORD *)(a2 + 8) = 0;
      *(_DWORD *)(a2 + 4) = 0;
    }
  }
  return result;
}

//----- (1004EF13) --------------------------------------------------------
int __cdecl sub_1004EF13(unsigned __int16 a1)
{
  signed int v2; // edx@4
  unsigned __int16 v3; // cx@37

  if ( a1 < 0x30u )
    return -1;
  if ( a1 < 0x3Au )
    return a1 - 48;
  v2 = 65296;
  if ( a1 >= 0xFF10u )
  {
    v3 = -230;
LABEL_39:
    if ( a1 < v3 )
      return a1 - v2;
    return -1;
  }
  v2 = 1632;
  if ( a1 >= 0x660u )
  {
    if ( a1 < 0x66Au )
      return a1 - v2;
    v2 = 1776;
    if ( a1 >= 0x6F0u )
    {
      if ( a1 < 0x6FAu )
        return a1 - v2;
      v2 = 2406;
      if ( a1 >= 0x966u )
      {
        if ( a1 < 0x970u )
          return a1 - v2;
        v2 = 2534;
        if ( a1 >= 0x9E6u )
        {
          if ( a1 < 0x9F0u )
            return a1 - v2;
          v2 = 2662;
          if ( a1 >= 0xA66u )
          {
            if ( a1 < 0xA70u )
              return a1 - v2;
            v2 = 2790;
            if ( a1 >= 0xAE6u )
            {
              if ( a1 < 0xAF0u )
                return a1 - v2;
              v2 = 2918;
              if ( a1 >= 0xB66u )
              {
                if ( a1 < 0xB70u )
                  return a1 - v2;
                v2 = 3174;
                if ( a1 >= 0xC66u )
                {
                  if ( a1 < 0xC70u )
                    return a1 - v2;
                  v2 = 3302;
                  if ( a1 >= 0xCE6u )
                  {
                    if ( a1 < 0xCF0u )
                      return a1 - v2;
                    v2 = 3430;
                    if ( a1 >= 0xD66u )
                    {
                      if ( a1 < 0xD70u )
                        return a1 - v2;
                      v2 = 3664;
                      if ( a1 >= 0xE50u )
                      {
                        if ( a1 < 0xE5Au )
                          return a1 - v2;
                        v2 = 3792;
                        if ( a1 >= 0xED0u )
                        {
                          if ( a1 < 0xEDAu )
                            return a1 - v2;
                          v2 = 3872;
                          if ( a1 >= 0xF20u )
                          {
                            if ( a1 < 0xF2Au )
                              return a1 - v2;
                            v2 = 4160;
                            if ( a1 >= 0x1040u )
                            {
                              if ( a1 < 0x104Au )
                                return a1 - v2;
                              v2 = 6112;
                              if ( a1 >= 0x17E0u )
                              {
                                if ( a1 < 0x17EAu )
                                  return a1 - v2;
                                v2 = 6160;
                                if ( a1 >= 0x1810u )
                                {
                                  v3 = 6170;
                                  goto LABEL_39;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return -1;
}

//----- (1004F0B2) --------------------------------------------------------
int __cdecl sub_1004F0B2(unsigned int *a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // edx@1
  int v5; // ebx@1
  unsigned int v6; // ecx@2
  int v7; // eax@3
  signed int v8; // ecx@3
  int v9; // edi@3
  unsigned int v10; // esi@3
  int v11; // esi@3
  unsigned int v12; // ecx@3
  int v13; // edx@3
  unsigned int v14; // eax@7
  signed int v15; // ecx@7
  signed int v16; // eax@12
  unsigned int v17; // ecx@12
  int v18; // eax@17
  unsigned int v19; // edi@17
  int v20; // esi@17
  int v21; // edx@17
  bool v22; // edx@19
  signed int v23; // edx@22
  int v24; // ecx@22
  int v25; // edx@30
  unsigned int v26; // esi@31
  unsigned int v27; // esi@31
  int v28; // edx@33
  unsigned int v29; // edi@34
  int v30; // esi@34
  unsigned int v31; // ecx@35
  unsigned int v32; // [sp+Ch] [bp-1Ch]@3
  int v33; // [sp+10h] [bp-18h]@3
  int v34; // [sp+14h] [bp-14h]@3
  int v35; // [sp+1Ch] [bp-Ch]@2
  int v36; // [sp+1Ch] [bp-Ch]@12
  int v37; // [sp+20h] [bp-8h]@2
  signed int v38; // [sp+24h] [bp-4h]@1
  int v39; // [sp+38h] [bp+10h]@2
  unsigned int v40; // [sp+38h] [bp+10h]@3

  v5 = a3;
  v4 = 0;
  result = 16462;
  v38 = 16462;
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 8) = 0;
  if ( a2 )
  {
    v6 = 0;
    v39 = 0;
    v37 = 0;
    v35 = 0;
    do
    {
      v32 = *(_DWORD *)v5;
      v33 = *(_DWORD *)(v5 + 4);
      v34 = *(_DWORD *)(v5 + 8);
      v11 = (v6 >> 31) | 2 * v37;
      v12 = v11;
      v10 = ((unsigned int)(2 * v39) >> 31) | 2 * v11;
      v13 = 4 * v39;
      v9 = (v12 >> 31) | 2 * (((unsigned int)v37 >> 31) | 2 * v35);
      v7 = 4 * v39 + *(_DWORD *)v5;
      v8 = 0;
      *(_DWORD *)v5 = 4 * v39;
      *(_DWORD *)(v5 + 4) = v10;
      *(_DWORD *)(v5 + 8) = v9;
      v40 = v7;
      if ( v7 < (unsigned int)v13 || v7 < v32 )
        v8 = 1;
      *(_DWORD *)v5 = v7;
      if ( v8 )
      {
        v14 = v10;
        v15 = 0;
        ++v10;
        if ( v10 < v14 || v10 < 1 )
          v15 = 1;
        *(_DWORD *)(v5 + 4) = v10;
        if ( v15 )
        {
          ++v9;
          *(_DWORD *)(v5 + 8) = v9;
        }
      }
      v16 = 0;
      v17 = v10 + v33;
      v36 = v10 + v33;
      if ( v10 + v33 < v10 || v17 < v33 )
        v16 = 1;
      *(_DWORD *)(v5 + 4) = v17;
      if ( v16 )
      {
        ++v9;
        *(_DWORD *)(v5 + 8) = v9;
      }
      v20 = (v40 >> 31) | 2 * v36;
      v18 = (v17 >> 31) | 2 * (v34 + v9);
      v21 = 2 * v40;
      *(_DWORD *)v5 = 2 * v40;
      *(_DWORD *)(v5 + 4) = v20;
      *(_DWORD *)(v5 + 8) = v18;
      v19 = *(_BYTE *)a1;
      v37 = (v40 >> 31) | 2 * v36;
      v6 = 2 * v40 + v19;
      v35 = v18;
      v39 = 2 * v40 + v19;
      v22 = v21 + v19 < v21 || v6 < v19;
      *(_DWORD *)v5 = v6;
      if ( v22 )
      {
        v24 = v20 + 1;
        v23 = 0;
        if ( v20 + 1 < (unsigned int)v20 || (unsigned int)v24 < 1 )
          v23 = 1;
        ++v20;
        *(_DWORD *)(v5 + 4) = v24;
        v6 = v39;
        v37 = v20;
        if ( v23 )
        {
          ++v18;
          v35 = v18;
          *(_DWORD *)(v5 + 8) = v18;
        }
      }
      *(_DWORD *)(v5 + 8) = v18;
      a1 = (unsigned int *)((char *)a1 + 1);
      *(_DWORD *)(v5 + 4) = v20;
      --a2;
    }
    while ( a2 );
    result = 16462;
    v4 = 0;
  }
  if ( *(_DWORD *)(v5 + 8) == v4 )
  {
    v25 = *(_DWORD *)(v5 + 4);
    do
    {
      v27 = v25;
      v25 = (*(_DWORD *)v5 >> 16) | (v25 << 16);
      v26 = v27 >> 16;
      result = v38 + 65520;
      *(_DWORD *)v5 <<= 16;
      v38 += 65520;
    }
    while ( !v26 );
    *(_DWORD *)(v5 + 4) = v25;
    *(_DWORD *)(v5 + 8) = v26;
  }
  v28 = *(_DWORD *)(v5 + 8);
  if ( !(v28 & 0x8000) )
  {
    v29 = *(_DWORD *)v5;
    v30 = *(_DWORD *)(v5 + 4);
    do
    {
      v31 = v30;
      v30 = (v29 >> 31) | 2 * v30;
      v28 = (v31 >> 31) | 2 * v28;
      result = v38 + 65535;
      v29 *= 2;
      v38 += 65535;
    }
    while ( !(v28 & 0x8000) );
    *(_DWORD *)v5 = v29;
    *(_DWORD *)(v5 + 4) = v30;
    *(_DWORD *)(v5 + 8) = v28;
  }
  *(_WORD *)(v5 + 10) = result;
  return result;
}

//----- (1004F294) --------------------------------------------------------
int __usercall sub_1004F294<eax>(int a1<ebx>, int a2, int a3, int a4, signed int a5)
{
  void *v5; // ecx@2
  int result; // eax@4
  int v7; // esi@17
  int v8; // eax@37
  double v9; // st7@51
  int v10; // [sp+0h] [bp-28h]@15
  char v11[4]; // [sp+4h] [bp-24h]@16
  double v12; // [sp+8h] [bp-20h]@17
  double v13; // [sp+10h] [bp-18h]@17
  double v14; // [sp+18h] [bp-10h]@17
  double v15; // [sp+20h] [bp-8h]@1

  *(_QWORD *)&v15 = 0i64;
  if ( dword_1006A0D8 )
    v5 = DecodePointer(dword_1006A38C);
  else
    v5 = sub_1003AF6A;
  result = a5;
  if ( a5 <= 166 )
  {
    if ( a5 == 166 )
    {
      v10 = 3;
      *(_DWORD *)v11 = "exp10";
      goto LABEL_17;
    }
    if ( a5 > 25 )
    {
      if ( a5 == 26 )
      {
        result = a4;
        *(double *)a4 = 1.0;
        return result;
      }
      if ( a5 == 27 )
      {
        v10 = 2;
LABEL_16:
        *(_DWORD *)v11 = &unk_10059F60;
        goto LABEL_17;
      }
      if ( a5 == 28 )
      {
LABEL_38:
        *(_DWORD *)v11 = &unk_10059F60;
      }
      else
      {
        if ( a5 == 29 )
        {
          *(_DWORD *)v11 = &unk_10059F60;
LABEL_37:
          v8 = a2;
          v7 = a4;
          *(double *)a4 = *(double *)a2;
LABEL_56:
          v12 = *(double *)v8;
          v13 = *(double *)a3;
          v9 = *(double *)v7;
LABEL_57:
          v14 = v9;
          v10 = 1;
          result = ((int (__cdecl *)(int *))v5)(&v10);
          if ( !result )
          {
            result = sub_1002F144(a1);
            *(_DWORD *)result = 33;
          }
          goto LABEL_59;
        }
        if ( a5 == 49 )
        {
LABEL_54:
          *(_DWORD *)v11 = "sqrt";
        }
        else
        {
          if ( a5 == 58 )
          {
LABEL_35:
            *(_DWORD *)v11 = "acos";
          }
          else
          {
            result = a5 - 61;
            if ( a5 != 61 )
              return result;
LABEL_34:
            *(_DWORD *)v11 = "asin";
          }
        }
      }
    }
    else
    {
      if ( a5 == 25 )
      {
        *(_DWORD *)v11 = &unk_10059F60;
        goto LABEL_20;
      }
      if ( a5 == 2 )
      {
        v10 = 2;
        *(_DWORD *)v11 = &unk_10059F64;
        goto LABEL_17;
      }
      if ( a5 == 3 )
      {
        *(_DWORD *)v11 = &unk_10059F64;
      }
      else
      {
        if ( a5 == 8 )
        {
          v10 = 2;
          *(_DWORD *)v11 = "log10";
          goto LABEL_17;
        }
        if ( a5 != 9 )
        {
          if ( a5 != 14 )
          {
            if ( a5 != 15 )
            {
              result = a5 - 24;
              if ( a5 != 24 )
                return result;
              v10 = 3;
              goto LABEL_16;
            }
            *(_DWORD *)v11 = &unk_10059F5C;
LABEL_20:
            v7 = a4;
            v12 = *(double *)a2;
            v10 = 4;
            v13 = *(double *)a3;
            v14 = *(double *)a4;
            result = ((int (__cdecl *)(int *))v5)(&v10);
LABEL_59:
            *(_QWORD *)v7 = *(_QWORD *)&v14;
            return result;
          }
          v10 = 3;
          *(_DWORD *)v11 = &unk_10059F5C;
LABEL_17:
          v7 = a4;
          v12 = *(double *)a2;
          v13 = *(double *)a3;
          v14 = *(double *)a4;
          result = ((int (__cdecl *)(_DWORD))v5)(&v10);
          if ( !result )
          {
            result = sub_1002F144(a1);
            *(_DWORD *)result = 34;
          }
          goto LABEL_59;
        }
        *(_DWORD *)v11 = "log10";
      }
    }
    v8 = a2;
    v7 = a4;
    goto LABEL_56;
  }
  switch ( a5 )
  {
    case 1009:
      goto LABEL_34;
    case 1008:
      goto LABEL_35;
    case 1006:
      goto LABEL_38;
    case 1000:
      *(_DWORD *)v11 = &unk_10059F64;
      goto LABEL_37;
    case 1001:
      *(_DWORD *)v11 = "log10";
      goto LABEL_37;
    case 1002:
      *(_DWORD *)v11 = &unk_10059F5C;
      goto LABEL_37;
    case 1003:
      *(_DWORD *)v11 = "atan";
      goto LABEL_37;
    case 1004:
      *(_DWORD *)v11 = "ceil";
      goto LABEL_37;
    case 1005:
      *(_DWORD *)v11 = "floor";
      goto LABEL_37;
    case 1007:
      *(_DWORD *)v11 = "modf";
      goto LABEL_37;
    case 1010:
      *(_DWORD *)v11 = "sin";
      goto LABEL_51;
    case 1011:
      *(_DWORD *)v11 = "cos";
      goto LABEL_51;
    case 1012:
      *(_DWORD *)v11 = "tan";
LABEL_51:
      v7 = a4;
      v9 = *(double *)a2 * v15;
      *(_QWORD *)a4 = *(_QWORD *)&v9;
      v12 = *(double *)a2;
      v13 = *(double *)a3;
      goto LABEL_57;
    case 1013:
      goto LABEL_54;
    default:
      return result;
  }
  return result;
}
// 1006A0D8: using guessed type int dword_1006A0D8;

//----- (1004F57C) --------------------------------------------------------
signed int __cdecl sub_1004F57C(double a1)
{
  signed int result; // eax@4

  if ( sub_1004070B(a1) & 0x90 || a1 != sub_1004F718(a1) )
  {
    result = 0;
  }
  else
  {
    if ( a1 * 0.5 == sub_1004F718(a1 * 0.5) )
      result = 2;
    else
      result = 1;
  }
  return result;
}

//----- (1004F5E2) --------------------------------------------------------
signed int __cdecl sub_1004F5E2(long double a1, double a2, int a3)
{
  int v3; // esi@1
  long double v4; // st7@1
  double v5; // st7@4
  int v6; // eax@5
  unsigned __int8 v7; // c0@5
  unsigned __int8 v8; // c3@5
  int v9; // ecx@21

  v4 = fabs(a1);
  v3 = 0;
  if ( HIDWORD(a2) == 2146435072 )
  {
    if ( !LODWORD(a2) )
    {
      if ( v4 <= 1.0 )
      {
        v7 = 1.0 < v4;
        v8 = 1.0 == v4;
        v5 = 1.0;
        v6 = a3;
        if ( !(v7 | v8) )
          v5 = 0.0;
        goto LABEL_28;
      }
      goto LABEL_4;
    }
  }
  else
  {
    if ( HIDWORD(a2) == -1048576 && !LODWORD(a2) )
    {
      if ( v4 > 1.0 )
      {
        v5 = 0.0;
        goto LABEL_27;
      }
      v6 = a3;
      if ( v4 < 1.0 )
      {
        v5 = dbl_10067F78;
LABEL_28:
        *(_QWORD *)v6 = *(_QWORD *)&v5;
        return v3;
      }
      *(_QWORD *)a3 = *(_QWORD *)&dbl_10067F80;
      return 1;
    }
  }
  if ( HIDWORD(a1) == 2146435072 )
  {
    if ( !LODWORD(a1) )
    {
      v5 = 0.0;
      if ( a2 <= 0.0 )
      {
        v6 = a3;
        if ( a2 >= 0.0 )
          v5 = 1.0;
        goto LABEL_28;
      }
LABEL_4:
      v5 = dbl_10067F78;
LABEL_27:
      v6 = a3;
      goto LABEL_28;
    }
  }
  else
  {
    if ( HIDWORD(a1) == -1048576 && !LODWORD(a1) )
    {
      v5 = 0.0;
      v9 = sub_1004F57C(a2);
      if ( a2 <= 0.0 )
      {
        if ( a2 >= 0.0 )
        {
          *(double *)a3 = 1.0;
          return v3;
        }
        if ( v9 == 1 )
          v5 = dbl_10067F98;
      }
      else
      {
        v5 = dbl_10067F78;
        if ( v9 == 1 )
          v5 = -dbl_10067F78;
      }
      goto LABEL_27;
    }
  }
  return v3;
}
// 10067F78: using guessed type double dbl_10067F78;
// 10067F80: using guessed type double dbl_10067F80;
// 10067F98: using guessed type double dbl_10067F98;

//----- (1004F718) --------------------------------------------------------
double __cdecl sub_1004F718(double a1)
{
  double result; // st7@1

  _ST7 = a1;
  __asm { frndint }
  return result;
}

//----- (1004F7A0) --------------------------------------------------------
int __stdcall sub_1004F7A0(unsigned __int64 a1, unsigned int a2, int a3)
{
  signed int v3; // edi@1
  int v4; // eax@3
  int result; // eax@6
  unsigned __int64 v6; // qtt@6
  unsigned __int64 v7; // qax@7
  unsigned int v8; // ecx@7
  unsigned int v9; // ebx@7
  char v10; // cf@8
  char v11; // cf@8
  int v12; // eax@9
  unsigned __int64 v13; // qax@9
  int v14; // esi@9
  int v15; // ecx@9
  char v16; // cf@9

  v3 = 0;
  if ( HIDWORD(a1) < 0 )
  {
    v3 = 1;
    HIDWORD(a1) = -HIDWORD(a1) - ((_DWORD)a1 != 0);
    LODWORD(a1) = -(_DWORD)a1;
  }
  v4 = a3;
  if ( a3 < 0 )
  {
    ++v3;
    v4 = -a3 - (a2 != 0);
    a3 = -a3 - (a2 != 0);
    a2 = -a2;
  }
  if ( v4 )
  {
    v9 = v4;
    v8 = a2;
    v7 = a1;
    do
    {
      v10 = v9 & 1;
      v9 >>= 1;
      v8 = __RCR__(v8, v10);
      v11 = BYTE4(v7) & 1;
      HIDWORD(v7) >>= 1;
      LODWORD(v7) = __RCR__(v7, v11);
    }
    while ( v9 );
    v12 = v7 / v8;
    v14 = v12;
    v15 = a3 * v12;
    v13 = v12 * a2;
    v16 = v15 >= (unsigned int)-HIDWORD(v13);
    HIDWORD(v13) += v15;
    if ( v16 || HIDWORD(v13) > HIDWORD(a1) || v13 > a1 )
      --v14;
    result = v14;
  }
  else
  {
    LODWORD(v6) = a1;
    HIDWORD(v6) = HIDWORD(a1) % a2;
    result = v6 / a2;
  }
  if ( v3 == 1 )
    result = -result;
  return result;
}

//----- (1004F850) --------------------------------------------------------
double __usercall sub_1004F850<st0>(__int16 a1<cx>, int a2<ebx>, double a3)
{
  char v3; // zf@2
  int v4; // ST2C_4@2
  int v5; // eax@2
  char v6; // ST28_1@3
  unsigned __int8 v8; // pf@7
  double result; // st7@8
  int v14; // ebx@17
  signed int v15; // eax@18
  __int16 v16; // cx@24
  char v17; // [sp-8h] [bp-30h]@23
  signed int v18; // [sp-4h] [bp-2Ch]@23
  __int64 v19; // [sp+0h] [bp-28h]@23
  __int16 v20; // [sp+10h] [bp-18h]@18

  if ( !dword_1006A390 )
    goto LABEL_31;
  __asm { stmxcsr [esp+8+var_4] }
  v5 = v4 & 0x7F80;
  v3 = v5 == 8064;
  if ( v5 == 8064 )
    v3 = (v6 & 0x7F) == 127;
  if ( v3 )
  {
    __asm
    {
      movq    xmm0, [esp+arg_0]
      movapd  xmm2, ds:xmmword_1005D3C0
      movapd  xmm1, xmm0
      movapd  xmm7, xmm0
      psrlq   xmm0, 34h
      movd    eax, xmm0
      andpd   xmm0, ds:xmmword_1005D3F0
      psubd   xmm2, xmm0
      psrlq   xmm1, xmm2
    }
    if ( _EAX & 0x800 )
    {
      __asm
      {
        movq    xmm0, [esp+arg_0]
        psllq   xmm1, xmm2
        movapd  xmm3, xmm0
        cmpltpd xmm0, xmm1
      }
      if ( _EAX < 3071 )
      {
        __asm
        {
          cmpltpd xmm3, ds:xmmword_1005D3E0
          orpd    xmm3, ds:xmmword_1005D3E0
          andpd   xmm3, ds:xmmword_1005D3D0
          movq    [esp+arg_0], xmm3
        }
        return a3;
      }
      v8 = __SETP__(_EAX - 3122, 0);
      if ( _EAX <= 3122 )
      {
        __asm
        {
          andpd   xmm0, ds:xmmword_1005D3B0
          subsd   xmm1, xmm0
          movq    [esp+arg_0], xmm1
        }
        return a3;
      }
    }
    else
    {
      if ( _EAX < 1023 )
        return 0.0;
      __asm { psllq   xmm1, xmm2 }
      v8 = __SETP__(_EAX - 1074, 0);
      if ( _EAX <= 1074 )
      {
        __asm { movq    [esp+arg_0], xmm1 }
        return a3;
      }
    }
    __asm { ucomisd xmm7, xmm7 }
    if ( v8 )
      sub_1004F294(a2, (int)&a3, (int)&a3, (int)&a3, 1005);
    result = a3;
  }
  else
  {
LABEL_31:
    v14 = sub_1004107C(a1);
    if ( (WORD3(a3) & 0x7FF0) == 32752 )
    {
      v15 = sub_100408A4(SLODWORD(a3), SHIDWORD(a3));
      if ( v15 > 0 )
      {
        if ( v15 <= 2 )
        {
          sub_1004107C(v20);
          return a3;
        }
        if ( v15 == 3 )
          return sub_10040BD6(v20, v14, 11, a3);
      }
      *(double *)&v19 = a3;
      v18 = 11;
      v17 = 8;
    }
    else
    {
      result = sub_1004F718(a3);
      if ( a3 == result || v14 & 0x20 )
      {
        sub_1004107C(v16);
        return result;
      }
      *(double *)&v19 = a3;
      v18 = 11;
      v17 = 16;
    }
    result = sub_10040932(v17, v18, v19);
  }
  return result;
}
// 1004F850: could not find valid save-restore pair for ebp
// 10040932: using guessed type double __cdecl sub_10040932(char, _DWORD, _DWORD);
// 1006A390: using guessed type int dword_1006A390;

//----- (1004FA50) --------------------------------------------------------
void __usercall sub_1004FA50(void *this<ecx>, int a2<ebp>)
{
  sub_10022167((void *)(a2 - 16));
}

//----- (1004FA58) --------------------------------------------------------
#error "1004FA64: call analysis failed (funcsize=7)"

//----- (1004FA73) --------------------------------------------------------
int __usercall sub_1004FA73<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10022664(a2 - 32);
}

//----- (1004FA7B) --------------------------------------------------------
#error "1004FA87: call analysis failed (funcsize=7)"

//----- (1004FA96) --------------------------------------------------------
int __usercall sub_1004FA96<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 40 + 4);
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 - 40);
  return result;
}

//----- (1004FA9E) --------------------------------------------------------
_DWORD *__usercall sub_1004FA9E<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_1002C36C((void *)(a2 - 32));
}

//----- (1004FAA6) --------------------------------------------------------
#error "1004FAB2: call analysis failed (funcsize=7)"

//----- (1004FAC1) --------------------------------------------------------
#error "1004FACD: call analysis failed (funcsize=7)"

//----- (1004FADC) --------------------------------------------------------
#error "1004FAE8: call analysis failed (funcsize=7)"

//----- (1004FAF7) --------------------------------------------------------
#error "1004FB03: call analysis failed (funcsize=7)"

//----- (1004FB12) --------------------------------------------------------
void __cdecl sub_1004FB12()
{
  JUMPOUT(*(unsigned int *)loc_10022DCD);
}
// 10022DCD: using guessed type int loc_10022DCD();

//----- (1004FB1A) --------------------------------------------------------
int __usercall sub_1004FB1A<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 + 20));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1004FB24) --------------------------------------------------------
int __thiscall sub_1004FB24(void *this)
{
  return nullsub_3(this);
}
// 100010B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1004FB32) --------------------------------------------------------
int __usercall sub_1004FB32<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 20) & 1;
  if ( *(_DWORD *)(a1 - 20) & 1 )
  {
    *(_DWORD *)(a1 - 20) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_10022DCD);
  }
  return result;
}
// 10022DCD: using guessed type int loc_10022DCD();

//----- (1004FB4B) --------------------------------------------------------
void __usercall sub_1004FB4B(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_10021AD0(a3 - 40, a2);
}

//----- (1004FB53) --------------------------------------------------------
#error "1004FB5F: call analysis failed (funcsize=7)"

//----- (1004FB6E) --------------------------------------------------------
int __usercall sub_1004FB6E<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 24));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1004FB78) --------------------------------------------------------
void __usercall sub_1004FB78(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_10021AD0(a3 - 40, a2);
}

//----- (1004FB80) --------------------------------------------------------
int __usercall sub_1004FB80<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 20) & 1;
  if ( *(_DWORD *)(a1 - 20) & 1 )
  {
    *(_DWORD *)(a1 - 20) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_10022DCD);
  }
  return result;
}
// 10022DCD: using guessed type int loc_10022DCD();

//----- (1004FB99) --------------------------------------------------------
#error "1004FBA5: call analysis failed (funcsize=7)"

//----- (1004FBB4) --------------------------------------------------------
void __usercall sub_1004FBB4(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_10021AD0(a3 - 32, a2);
}

//----- (1004FBBC) --------------------------------------------------------
#error "1004FBC8: call analysis failed (funcsize=7)"

//----- (1004FBD7) --------------------------------------------------------
void __usercall sub_1004FBD7(int a1<ebp>)
{
  JUMPOUT(*(_DWORD *)(a1 - 20 + 4), 0, *(unsigned int *)sub_10001490);
}

//----- (1004FBDF) --------------------------------------------------------
#error "1004FBEB: call analysis failed (funcsize=7)"

//----- (1004FBFA) --------------------------------------------------------
int __thiscall sub_1004FBFA(void *this)
{
  return nullsub_3(this);
}
// 100010B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1004FC0C) --------------------------------------------------------
#error "1004FC18: call analysis failed (funcsize=7)"

//----- (1004FC27) --------------------------------------------------------
int __thiscall sub_1004FC27(void *this)
{
  return nullsub_3(this);
}
// 100010B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1004FC35) --------------------------------------------------------
#error "1004FC41: call analysis failed (funcsize=7)"

//----- (1004FC50) --------------------------------------------------------
int __thiscall sub_1004FC50(void *this)
{
  return nullsub_3(this);
}
// 100010B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1004FC61) --------------------------------------------------------
int __thiscall sub_1004FC61(void *this)
{
  return nullsub_3(this);
}
// 100010B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1004FC72) --------------------------------------------------------
#error "1004FC7E: call analysis failed (funcsize=7)"

//----- (1004FC8D) --------------------------------------------------------
int __usercall sub_1004FC8D<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 20) + 8);
}
// 10024CC5: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1004FC98) --------------------------------------------------------
#error "1004FCA4: call analysis failed (funcsize=7)"

//----- (1004FCB3) --------------------------------------------------------
void __cdecl sub_1004FCB3()
{
  sub_100242C1();
}

//----- (1004FCBB) --------------------------------------------------------
#error "1004FCC7: call analysis failed (funcsize=7)"

//----- (1004FCD6) --------------------------------------------------------
void __usercall sub_1004FCD6(int a1<ebx>, int a2<ebp>)
{
  int v2; // ST00_4@1

  v2 = *(_DWORD *)(a2 - 40 + 4);
  *(_DWORD *)(a2 - 40) = &off_10055B00;
  sub_1002563B(a1, v2);
}
// 10055B00: using guessed type int (__stdcall *off_10055B00)(char);

//----- (1004FCDE) --------------------------------------------------------
void __cdecl sub_1004FCDE()
{
  sub_100242C1();
}

//----- (1004FCE6) --------------------------------------------------------
#error "1004FCF2: call analysis failed (funcsize=10)"

//----- (1004FD0B) --------------------------------------------------------
void __cdecl sub_1004FD0B()
{
  sub_100242C1();
}

//----- (1004FD13) --------------------------------------------------------
#error "1004FD1F: call analysis failed (funcsize=7)"

//----- (1004FD2E) --------------------------------------------------------
unsigned int __usercall sub_1004FD2E<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10024C08((void *)(a2 - 60));
}

//----- (1004FD36) --------------------------------------------------------
void __cdecl sub_1004FD36()
{
  sub_100242C1();
}

//----- (1004FD41) --------------------------------------------------------
#error "1004FD50: call analysis failed (funcsize=7)"

//----- (1004FD5F) --------------------------------------------------------
int __usercall sub_1004FD5F<eax>(int a1<ebp>)
{
  return sub_10024C22(a1);
}

//----- (1004FD6A) --------------------------------------------------------
#error "1004FD76: call analysis failed (funcsize=7)"

//----- (1004FD85) --------------------------------------------------------
int __usercall sub_1004FD85<eax>(int a1<ebp>)
{
  return sub_10024C22(a1);
}

//----- (1004FD90) --------------------------------------------------------
#error "1004FD9C: call analysis failed (funcsize=7)"

//----- (1004FDAB) --------------------------------------------------------
void __usercall sub_1004FDAB(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = &off_10055B10;
}
// 10055B10: using guessed type int (__stdcall *off_10055B10)(char);

//----- (1004FDB3) --------------------------------------------------------
#error "1004FDBF: call analysis failed (funcsize=7)"

//----- (1004FDCE) --------------------------------------------------------
int __cdecl sub_1004FDCE()
{
  return sub_1002468A();
}

//----- (1004FDD6) --------------------------------------------------------
#error "1004FDE2: call analysis failed (funcsize=7)"

//----- (1004FDF1) --------------------------------------------------------
void __usercall sub_1004FDF1(int a1<ebx>, int a2<ebp>)
{
  int v2; // ST00_4@1

  v2 = *(_DWORD *)(a2 - 28 + 4);
  *(_DWORD *)(a2 - 28) = &off_10055B28;
  sub_1002563B(a1, v2);
}
// 10055B28: using guessed type int (__stdcall *off_10055B28)(char);

//----- (1004FDF9) --------------------------------------------------------
#error "1004FE05: call analysis failed (funcsize=10)"

//----- (1004FE1E) --------------------------------------------------------
int __thiscall sub_1004FE1E(void *this)
{
  return nullsub_3(this);
}
// 100010B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1004FE30) --------------------------------------------------------
#error "1004FE3C: call analysis failed (funcsize=7)"

//----- (1004FE4B) --------------------------------------------------------
#error "1004FE5A: call analysis failed (funcsize=7)"

//----- (1004FE69) --------------------------------------------------------
#error "1004FE75: call analysis failed (funcsize=7)"

//----- (1004FE84) --------------------------------------------------------
void __usercall sub_1004FE84(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = off_10055B30;
}
// 10055B30: using guessed type int (*off_10055B30[5])();

//----- (1004FE8C) --------------------------------------------------------
int __usercall sub_1004FE8C<eax>(int a1<ebp>)
{
  int v1; // esi@1

  v1 = *(_DWORD *)(a1 - 16) + 128;
  sub_1002C2C0(v1);
  return sub_1002401B(*(LPVOID *)(v1 + 8));
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (1004FE9A) --------------------------------------------------------
int __usercall sub_1004FE9A<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10026AD6(*(_DWORD *)(a2 - 16) + 140);
}

//----- (1004FEA8) --------------------------------------------------------
#error "1004FEB4: call analysis failed (funcsize=7)"

//----- (1004FEC3) --------------------------------------------------------
void __cdecl sub_1004FEC3()
{
  JUMPOUT(*(unsigned int *)loc_100258D7);
}
// 100258D7: using guessed type int loc_100258D7();

//----- (1004FECB) --------------------------------------------------------
#error "1004FED7: call analysis failed (funcsize=7)"

//----- (1004FEE6) --------------------------------------------------------
int __usercall sub_1004FEE6<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_1002C625(*(void **)(a2 - 16));
}

//----- (1004FEEE) --------------------------------------------------------
#error "1004FEFA: call analysis failed (funcsize=7)"

//----- (1004FF09) --------------------------------------------------------
int __usercall sub_1004FF09<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10024692((void *)(*(_DWORD *)(a2 - 16) + 4));
}

//----- (1004FF11) --------------------------------------------------------
int __usercall sub_1004FF11<eax>(int a1<ebp>)
{
  return sub_10024C22(a1);
}

//----- (1004FF19) --------------------------------------------------------
#error "1004FF25: call analysis failed (funcsize=7)"

//----- (1004FF34) --------------------------------------------------------
int __usercall sub_1004FF34<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 16);
  **(_DWORD **)(a1 - 16) = 0;
  return result;
}

//----- (1004FF3C) --------------------------------------------------------
#error "1004FF48: call analysis failed (funcsize=7)"

//----- (1004FF57) --------------------------------------------------------
void __usercall sub_1004FF57(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = &off_10055E0C;
}
// 10055E0C: using guessed type int (__stdcall *off_10055E0C)(char);

//----- (1004FF5F) --------------------------------------------------------
int __usercall sub_1004FF5F<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_1003A54F((LPVOID *)(*(_DWORD *)(a2 - 16) + 4));
}

//----- (1004FF6A) --------------------------------------------------------
int __usercall sub_1004FF6A<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_100292E2(*(_DWORD *)(a2 - 16) + 48);
}

//----- (1004FF75) --------------------------------------------------------
int __usercall sub_1004FF75<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_100292E2(*(_DWORD *)(a2 - 16) + 60);
}

//----- (1004FF80) --------------------------------------------------------
int __usercall sub_1004FF80<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_100292E2(*(_DWORD *)(a2 - 16) + 72);
}

//----- (1004FF8B) --------------------------------------------------------
int __usercall sub_1004FF8B<eax>(int a1<ebp>)
{
  return sub_1002401B(*(LPVOID *)(*(_DWORD *)(a1 - 16) + 88));
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (1004FF96) --------------------------------------------------------
int __usercall sub_1004FF96<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_10029254((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 96));
}

//----- (1004FFA1) --------------------------------------------------------
int __usercall sub_1004FFA1<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_10037AD6((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 200));
}

//----- (1004FFAF) --------------------------------------------------------
void __usercall sub_1004FFAF(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_100242B2((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 280));
}

//----- (1004FFBD) --------------------------------------------------------
void __cdecl sub_1004FFBD()
{
  JUMPOUT(*(unsigned int *)loc_10029241);
}
// 10029241: using guessed type int loc_10029241();

//----- (1004FFCB) --------------------------------------------------------
void __cdecl sub_1004FFCB()
{
  JUMPOUT(*(unsigned int *)loc_10029241);
}
// 10029241: using guessed type int loc_10029241();

//----- (1004FFD9) --------------------------------------------------------
#error "1004FFE5: call analysis failed (funcsize=7)"

//----- (1004FFF4) --------------------------------------------------------
void __cdecl sub_1004FFF4()
{
  JUMPOUT(*(unsigned int *)loc_10029300);
}
// 10029300: using guessed type int loc_10029300();

//----- (1004FFFC) --------------------------------------------------------
int __usercall sub_1004FFFC<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_1003A54F((LPVOID *)(*(_DWORD *)(a2 - 16) + 4));
}

//----- (10050007) --------------------------------------------------------
int __usercall sub_10050007<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_100292E2(*(_DWORD *)(a2 - 16) + 48);
}

//----- (10050012) --------------------------------------------------------
int __usercall sub_10050012<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_100292E2(*(_DWORD *)(a2 - 16) + 60);
}

//----- (1005001D) --------------------------------------------------------
int __usercall sub_1005001D<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_100292E2(*(_DWORD *)(a2 - 16) + 72);
}

//----- (10050028) --------------------------------------------------------
void __cdecl sub_10050028()
{
  JUMPOUT(*(unsigned int *)loc_10026B44);
}
// 10026B44: using guessed type int loc_10026B44();

//----- (10050033) --------------------------------------------------------
int __usercall sub_10050033<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_10029254((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 96));
}

//----- (1005003E) --------------------------------------------------------
int __usercall sub_1005003E<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_10037AD6((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 200));
}

//----- (1005004C) --------------------------------------------------------
void __usercall sub_1005004C(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_100242B2((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 280));
}

//----- (1005005A) --------------------------------------------------------
void __cdecl sub_1005005A()
{
  JUMPOUT(*(unsigned int *)loc_10029241);
}
// 10029241: using guessed type int loc_10029241();

//----- (10050068) --------------------------------------------------------
void __cdecl sub_10050068()
{
  JUMPOUT(*(unsigned int *)loc_10029241);
}
// 10029241: using guessed type int loc_10029241();

//----- (10050076) --------------------------------------------------------
#error "10050082: call analysis failed (funcsize=7)"

//----- (10050091) --------------------------------------------------------
int __usercall sub_10050091<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 16) & 1;
  if ( *(_DWORD *)(a1 - 16) & 1 )
  {
    *(_DWORD *)(a1 - 16) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_10026B44);
  }
  return result;
}
// 10026B44: using guessed type int loc_10026B44();

//----- (100500AA) --------------------------------------------------------
#error "100500B6: call analysis failed (funcsize=7)"

//----- (100500C5) --------------------------------------------------------
void __cdecl sub_100500C5()
{
  JUMPOUT(*(unsigned int *)loc_100288DC);
}
// 100288DC: using guessed type int loc_100288DC();

//----- (100500CD) --------------------------------------------------------
int __usercall sub_100500CD<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_1003A54F((LPVOID *)(a2 - 16));
}

//----- (100500D5) --------------------------------------------------------
#error "100500E1: call analysis failed (funcsize=7)"

//----- (100500F0) --------------------------------------------------------
#error "100500FC: call analysis failed (funcsize=7)"

//----- (1005010B) --------------------------------------------------------
int __usercall sub_1005010B<eax>(int a1<ebp>)
{
  return sub_1002401B(*(LPVOID *)(a1 - 60));
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (10050115) --------------------------------------------------------
void __cdecl sub_10050115()
{
  JUMPOUT(*(unsigned int *)loc_10026B44);
}
// 10026B44: using guessed type int loc_10026B44();

//----- (1005011D) --------------------------------------------------------
int __usercall sub_1005011D<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 48));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10050127) --------------------------------------------------------
int __usercall sub_10050127<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 48));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10050131) --------------------------------------------------------
#error "1005013D: call analysis failed (funcsize=7)"

//----- (1005014C) --------------------------------------------------------
int __usercall sub_1005014C<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 16));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10050156) --------------------------------------------------------
int __usercall sub_10050156<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 + 8));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10050160) --------------------------------------------------------
#error "1005016C: call analysis failed (funcsize=7)"

//----- (1005017B) --------------------------------------------------------
#error "10050187: call analysis failed (funcsize=7)"

//----- (10050196) --------------------------------------------------------
void __usercall sub_10050196(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_100242B2((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 20) + 44));
}

//----- (100501A1) --------------------------------------------------------
int __usercall sub_100501A1<eax>(int a1<ebp>)
{
  return sub_10044341(a1);
}

//----- (100501AC) --------------------------------------------------------
#error "100501B8: call analysis failed (funcsize=7)"

//----- (100501C7) --------------------------------------------------------
void __usercall sub_100501C7(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_100242B2((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 44));
}

//----- (100501D2) --------------------------------------------------------
int __usercall sub_100501D2<eax>(int a1<ebp>)
{
  return sub_10044341(a1);
}

//----- (100501DD) --------------------------------------------------------
#error "100501E9: call analysis failed (funcsize=7)"

//----- (100501F8) --------------------------------------------------------
int __usercall sub_100501F8<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 32));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10050202) --------------------------------------------------------
#error "1005020E: call analysis failed (funcsize=10)"

//----- (10050227) --------------------------------------------------------
int __usercall sub_10050227<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_1003A54F((LPVOID *)(a2 + 8));
}

//----- (1005022F) --------------------------------------------------------
int __usercall sub_1005022F<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 16));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10050239) --------------------------------------------------------
#error "10050245: call analysis failed (funcsize=7)"

//----- (10050254) --------------------------------------------------------
void __cdecl sub_10050254()
{
  JUMPOUT(*(unsigned int *)loc_100288DC);
}
// 100288DC: using guessed type int loc_100288DC();

//----- (1005025C) --------------------------------------------------------
int __usercall sub_1005025C<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 20));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10050266) --------------------------------------------------------
int __usercall sub_10050266<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 20));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10050270) --------------------------------------------------------
#error "1005027C: call analysis failed (funcsize=7)"

//----- (1005028B) --------------------------------------------------------
void __cdecl sub_1005028B()
{
  JUMPOUT(*(unsigned int *)loc_10032F3B);
}
// 10032F3B: using guessed type int loc_10032F3B();

//----- (10050293) --------------------------------------------------------
#error "1005029F: call analysis failed (funcsize=7)"

//----- (100502AE) --------------------------------------------------------
void __usercall sub_100502AE(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_10024670(*(LPCRITICAL_SECTION *)(a2 - 20));
}

//----- (100502B6) --------------------------------------------------------
#error "100502C2: call analysis failed (funcsize=7)"

//----- (100502D1) --------------------------------------------------------
void __cdecl sub_100502D1()
{
  JUMPOUT(*(unsigned int *)loc_10032F3B);
}
// 10032F3B: using guessed type int loc_10032F3B();

//----- (100502D9) --------------------------------------------------------
#error "100502E5: call analysis failed (funcsize=7)"

//----- (100502F4) --------------------------------------------------------
#error "10050300: call analysis failed (funcsize=7)"

//----- (1005030F) --------------------------------------------------------
int __usercall sub_1005030F<eax>(int a1<ebp>)
{
  return sub_100258E1(a1);
}

//----- (1005031A) --------------------------------------------------------
#error "10050329: call analysis failed (funcsize=10)"

//----- (10050342) --------------------------------------------------------
int __usercall sub_10050342<eax>(int a1<ebp>)
{
  return sub_100234E2(a1 - 24);
}

//----- (1005034A) --------------------------------------------------------
#error "10050356: call analysis failed (funcsize=7)"

//----- (10050365) --------------------------------------------------------
int __usercall sub_10050365<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_1003A8E4(*(_DWORD *)(a2 - 16));
}

//----- (1005036D) --------------------------------------------------------
int __usercall sub_1005036D<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10026ABF(*(_DWORD *)(a2 - 16) + 76);
}

//----- (10050378) --------------------------------------------------------
#error "10050384: call analysis failed (funcsize=7)"

//----- (10050393) --------------------------------------------------------
void __cdecl sub_10050393()
{
  JUMPOUT(*(unsigned int *)loc_10026B4E);
}
// 10026B4E: using guessed type int loc_10026B4E();

//----- (1005039B) --------------------------------------------------------
#error "100503A7: call analysis failed (funcsize=7)"

//----- (100503B6) --------------------------------------------------------
void __cdecl sub_100503B6()
{
  JUMPOUT(*(unsigned int *)loc_10026B4E);
}
// 10026B4E: using guessed type int loc_10026B4E();

//----- (100503BE) --------------------------------------------------------
#error "100503CA: call analysis failed (funcsize=7)"

//----- (100503D9) --------------------------------------------------------
void __cdecl sub_100503D9()
{
  JUMPOUT(*(unsigned int *)loc_10026B44);
}
// 10026B44: using guessed type int loc_10026B44();

//----- (100503E4) --------------------------------------------------------
int __usercall sub_100503E4<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 + 16));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (100503EE) --------------------------------------------------------
#error "100503FA: call analysis failed (funcsize=7)"

//----- (10050409) --------------------------------------------------------
void __usercall sub_10050409(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = off_10055DF4;
}
// 10055DF4: using guessed type int (*off_10055DF4[4])();

//----- (10050411) --------------------------------------------------------
#error "1005041D: call analysis failed (funcsize=7)"

//----- (1005042C) --------------------------------------------------------
void __cdecl sub_1005042C()
{
  JUMPOUT(*(unsigned int *)loc_10026B44);
}
// 10026B44: using guessed type int loc_10026B44();

//----- (10050437) --------------------------------------------------------
void __cdecl sub_10050437()
{
  JUMPOUT(*(unsigned int *)loc_10026B44);
}
// 10026B44: using guessed type int loc_10026B44();

//----- (1005043F) --------------------------------------------------------
int __usercall sub_1005043F<eax>(int a1<ebp>)
{
  return sub_10037BBF(a1);
}

//----- (1005044A) --------------------------------------------------------
int __usercall sub_1005044A<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_10037B48((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 88));
}

//----- (10050455) --------------------------------------------------------
int __usercall sub_10050455<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_10037AD6((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 168));
}

//----- (10050463) --------------------------------------------------------
#error "1005046F: call analysis failed (funcsize=7)"

//----- (1005047E) --------------------------------------------------------
void __cdecl sub_1005047E()
{
  JUMPOUT(*(unsigned int *)loc_10026B44);
}
// 10026B44: using guessed type int loc_10026B44();

//----- (10050489) --------------------------------------------------------
#error "10050495: call analysis failed (funcsize=7)"

//----- (100504A4) --------------------------------------------------------
void __cdecl sub_100504A4()
{
  JUMPOUT(*(unsigned int *)loc_10026B44);
}
// 10026B44: using guessed type int loc_10026B44();

//----- (100504AF) --------------------------------------------------------
#error "100504BB: call analysis failed (funcsize=7)"

//----- (100504CA) --------------------------------------------------------
int __usercall sub_100504CA<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 16));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (100504D4) --------------------------------------------------------
#error "100504E0: call analysis failed (funcsize=7)"

//----- (100504EF) --------------------------------------------------------
#error "100504FB: call analysis failed (funcsize=7)"

//----- (1005050A) --------------------------------------------------------
int __usercall sub_1005050A<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_1003A8E4(*(_DWORD *)(a2 - 16) + 12);
}

//----- (10050515) --------------------------------------------------------
void __cdecl sub_10050515()
{
  JUMPOUT(*(unsigned int *)loc_10026B44);
}
// 10026B44: using guessed type int loc_10026B44();

//----- (10050523) --------------------------------------------------------
#error "1005052F: call analysis failed (funcsize=7)"

//----- (1005053E) --------------------------------------------------------
void __cdecl sub_1005053E()
{
  JUMPOUT(*(unsigned int *)loc_10026B44);
}
// 10026B44: using guessed type int loc_10026B44();

//----- (10050549) --------------------------------------------------------
void __cdecl sub_10050549()
{
  JUMPOUT(*(unsigned int *)loc_10029241);
}
// 10029241: using guessed type int loc_10029241();

//----- (10050554) --------------------------------------------------------
#error "10050560: call analysis failed (funcsize=7)"

//----- (1005056F) --------------------------------------------------------
int __usercall sub_1005056F<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10026B16((void *)(*(_DWORD *)(a2 - 16) + 4));
}

//----- (1005057A) --------------------------------------------------------
#error "10050586: call analysis failed (funcsize=7)"

//----- (10050595) --------------------------------------------------------
int __cdecl sub_10050595()
{
  return sub_1003AF6A();
}

//----- (1005059D) --------------------------------------------------------
#error "100505A9: call analysis failed (funcsize=7)"

//----- (100505B8) --------------------------------------------------------
int __usercall sub_100505B8<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 16) & 1;
  if ( *(_DWORD *)(a2 - 16) & 1 )
  {
    *(_DWORD *)(a2 - 16) &= 0xFFFFFFFEu;
    result = sub_1003A54F((LPVOID *)(a2 - 20));
  }
  return result;
}

//----- (100505D1) --------------------------------------------------------
#error "100505DD: call analysis failed (funcsize=7)"

//----- (100505EC) --------------------------------------------------------
int __usercall sub_100505EC<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_1003CDC6((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 16));
}

//----- (100505F7) --------------------------------------------------------
int __usercall sub_100505F7<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_1003CDC6((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 96));
}

//----- (10050602) --------------------------------------------------------
#error "1005060E: call analysis failed (funcsize=7)"

//----- (1005061D) --------------------------------------------------------
int __usercall sub_1005061D<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_1003CDC6((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 16));
}

//----- (10050628) --------------------------------------------------------
#error "10050634: call analysis failed (funcsize=7)"

//----- (10050643) --------------------------------------------------------
int __usercall sub_10050643<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10026B16(*(void **)(a2 - 16));
}

//----- (1005064B) --------------------------------------------------------
#error "10050657: call analysis failed (funcsize=7)"

//----- (10050666) --------------------------------------------------------
int __usercall sub_10050666<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10026B16(*(void **)(a2 - 16));
}

//----- (1005066E) --------------------------------------------------------
#error "1005067A: call analysis failed (funcsize=7)"

//----- (10050689) --------------------------------------------------------
void __usercall sub_10050689(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_100242B2((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 32));
}

//----- (10050694) --------------------------------------------------------
int __usercall sub_10050694<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 + 12));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1005069E) --------------------------------------------------------
#error "100506AA: call analysis failed (funcsize=7)"

//----- (100506B9) --------------------------------------------------------
void __usercall sub_100506B9(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_100242B2((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 32));
}

//----- (100506C4) --------------------------------------------------------
#error "100506D0: call analysis failed (funcsize=7)"

//----- (100506DF) --------------------------------------------------------
void __cdecl sub_100506DF()
{
  JUMPOUT(*(unsigned int *)loc_10032F3B);
}
// 10032F3B: using guessed type int loc_10032F3B();

//----- (100506E7) --------------------------------------------------------
#error "100506F3: call analysis failed (funcsize=7)"

//----- (10050702) --------------------------------------------------------
int __usercall sub_10050702<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 + 8));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1005070C) --------------------------------------------------------
#error "10050718: call analysis failed (funcsize=7)"

//----- (10050727) --------------------------------------------------------
void __cdecl sub_10050727()
{
  JUMPOUT(*(unsigned int *)loc_10032F3B);
}
// 10032F3B: using guessed type int loc_10032F3B();

//----- (1005072F) --------------------------------------------------------
#error "1005073B: call analysis failed (funcsize=7)"

//----- (1005074A) --------------------------------------------------------
void __cdecl sub_1005074A()
{
  JUMPOUT(*(unsigned int *)loc_10032F3B);
}
// 10032F3B: using guessed type int loc_10032F3B();

//----- (10050752) --------------------------------------------------------
#error "1005075E: call analysis failed (funcsize=7)"

//----- (1005076D) --------------------------------------------------------
void __usercall sub_1005076D(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_100242B2((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 12));
}

//----- (10050778) --------------------------------------------------------
#error "10050784: call analysis failed (funcsize=7)"

//----- (10050793) --------------------------------------------------------
void __usercall sub_10050793(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_100242B2((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 12));
}

//----- (1005079E) --------------------------------------------------------
#error "100507AA: call analysis failed (funcsize=7)"

//----- (100507B9) --------------------------------------------------------
int __usercall sub_100507B9<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 16));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (100507C3) --------------------------------------------------------
#error "100507CF: call analysis failed (funcsize=7)"

//----- (100507DE) --------------------------------------------------------
int __usercall sub_100507DE<eax>(int a1<ebp>)
{
  return sub_1003A912(a1);
}

//----- (100507E6) --------------------------------------------------------
#error "100507F2: call analysis failed (funcsize=7)"

//----- (10050810) --------------------------------------------------------
void __cdecl sub_10050810()
{
  JUMPOUT(*(unsigned int *)loc_10001000);
}
// 10001000: using guessed type int loc_10001000();

//----- (1005081B) --------------------------------------------------------
#error "10050827: call analysis failed (funcsize=7)"

//----- (10050840) --------------------------------------------------------
void __cdecl sub_10050840()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10050848) --------------------------------------------------------
#error "10050854: call analysis failed (funcsize=7)"

//----- (10050870) --------------------------------------------------------
#error "1005087C: call analysis failed (funcsize=7)"

//----- (10050890) --------------------------------------------------------
int __usercall sub_10050890<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 16) & 1;
  if ( *(_DWORD *)(a1 - 16) & 1 )
  {
    *(_DWORD *)(a1 - 16) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_10001000);
  }
  return result;
}
// 10001000: using guessed type int loc_10001000();

//----- (100508A9) --------------------------------------------------------
#error "100508B5: call analysis failed (funcsize=7)"

//----- (100508D0) --------------------------------------------------------
int __usercall sub_100508D0<eax>(int a1<ebp>)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = *(_DWORD *)(a1 - 28 + 4);
  if ( v1 )
  {
    _EDI = -1;
    _ECX = v1 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v1)(v1);
      result = v1 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v1 + 4))(v1);
    }
  }
  return result;
}

//----- (100508D8) --------------------------------------------------------
#error "100508E4: call analysis failed (funcsize=11)"

//----- (10050900) --------------------------------------------------------
#error "1005090C: call analysis failed (funcsize=7)"

//----- (10050920) --------------------------------------------------------
int __usercall sub_10050920<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 + 12);
  --*(_DWORD *)result;
  return result;
}

//----- (10050928) --------------------------------------------------------
#error "10050934: call analysis failed (funcsize=7)"

//----- (10050950) --------------------------------------------------------
int __usercall sub_10050950<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 16) & 1;
  if ( *(_DWORD *)(a2 - 16) & 1 )
  {
    *(_DWORD *)(a2 - 16) &= 0xFFFFFFFEu;
    result = sub_10001A30(a2 - 64);
  }
  return result;
}

//----- (10050969) --------------------------------------------------------
#error "10050975: call analysis failed (funcsize=7)"

//----- (10050990) --------------------------------------------------------
void __cdecl sub_10050990()
{
  JUMPOUT(*(unsigned int *)loc_1000CC20);
}
// 1000CC20: using guessed type int loc_1000CC20();

//----- (10050998) --------------------------------------------------------
void __cdecl sub_10050998()
{
  JUMPOUT(*(unsigned int *)loc_1000CCE0);
}
// 1000CCE0: using guessed type int loc_1000CCE0();

//----- (100509A0) --------------------------------------------------------
#error "100509AC: call analysis failed (funcsize=7)"

//----- (100509C0) --------------------------------------------------------
int __thiscall sub_100509C0(void *this)
{
  return nullsub_3(this);
}
// 100010B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (100509D1) --------------------------------------------------------
void __cdecl sub_100509D1()
{
  JUMPOUT(*(unsigned int *)loc_10004D80);
}
// 10004D80: using guessed type int loc_10004D80();

//----- (100509D9) --------------------------------------------------------
#error "100509E5: call analysis failed (funcsize=7)"

//----- (10050A00) --------------------------------------------------------
#error "10050A0C: call analysis failed (funcsize=7)"

//----- (10050A20) --------------------------------------------------------
void __cdecl sub_10050A20()
{
  JUMPOUT(*(unsigned int *)loc_10004D80);
}
// 10004D80: using guessed type int loc_10004D80();

//----- (10050A28) --------------------------------------------------------
#error "10050A34: call analysis failed (funcsize=7)"

//----- (10050A50) --------------------------------------------------------
#error "10050A5C: call analysis failed (funcsize=7)"

//----- (10050A70) --------------------------------------------------------
void __usercall sub_10050A70(int a1<ebx>, int a2<ebp>)
{
  int v2; // ecx@1

  v2 = *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)v2 )
  {
    if ( *(_DWORD *)(v2 + 4) == 1 )
      sub_100282F6(a1, *(LPVOID *)v2);
  }
}

//----- (10050A78) --------------------------------------------------------
#error "10050A84: call analysis failed (funcsize=7)"

//----- (10050AAA) --------------------------------------------------------
#error "10050AB6: call analysis failed (funcsize=10)"

//----- (10050AD0) --------------------------------------------------------
void __usercall sub_10050AD0(void *this<ecx>, int a2<ebp>)
{
  sub_10022167((void *)(a2 - 24));
}

//----- (10050AD8) --------------------------------------------------------
#error "10050AE4: call analysis failed (funcsize=10)"

//----- (10050B00) --------------------------------------------------------
int __usercall sub_10050B00<eax>(int a1<ebp>)
{
  return sub_1002404A(**(LPVOID **)(a1 - 24));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10050B08) --------------------------------------------------------
#error "10050B14: call analysis failed (funcsize=7)"

//----- (10050B30) --------------------------------------------------------
char __usercall sub_10050B30<al>(int a1<ebp>)
{
  int v1; // eax@1
  int v2; // ecx@2

  v1 = *(_DWORD *)(a1 - 16) & 1;
  if ( *(_DWORD *)(a1 - 16) & 1 )
  {
    *(_DWORD *)(a1 - 16) &= 0xFFFFFFFEu;
    v2 = *(_DWORD *)(a1 - 20) + 80;
    *(_DWORD *)v2 = &off_1005C6EC;
    LOBYTE(v1) = sub_10021D4C(v2);
  }
  return v1;
}
// 1005C6EC: using guessed type int (__stdcall *off_1005C6EC)(char);

//----- (10050B4C) --------------------------------------------------------
int __usercall sub_10050B4C<eax>(int a1<ebp>)
{
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@1

  v3 = *(_DWORD *)(a1 - 20) + 8;
  *(_DWORD *)(*(_DWORD *)(**(_DWORD **)(a1 - 20) + 4) + *(_DWORD *)(a1 - 20) + 8 - 8) = off_1005C658;
  v1 = *(_DWORD *)(*(_DWORD *)(v3 - 8) + 4);
  result = v1 - 8;
  *(_DWORD *)(v1 + v3 - 12) = v1 - 8;
  return result;
}
// 1005C658: using guessed type int (*off_1005C658[3])();

//----- (10050B57) --------------------------------------------------------
void __usercall sub_10050B57(int a1<ebp>)
{
  int v1; // eax@3
  int v2; // ecx@1
  void *v3; // esi@1

  v2 = *(_DWORD *)(a1 - 24);
  v3 = *(void **)(v2 + 52);
  *(_DWORD *)v2 = &off_1005C5D4;
  if ( v3 )
  {
    if ( *(_DWORD *)v3 )
    {
      v1 = (*(int (**)(void))(**(_DWORD **)v3 + 8))();
      if ( v1 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v1)(v1, 1);
    }
    sub_1002404A(v3);
  }
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005C5D4: using guessed type int (__stdcall *off_1005C5D4)(char);

//----- (10050B5F) --------------------------------------------------------
#error "10050B6B: call analysis failed (funcsize=7)"

//----- (10050B80) --------------------------------------------------------
int __usercall sub_10050B80<eax>(int a1<ebp>)
{
  int v1; // esi@1
  int result; // eax@1

  v1 = *(_DWORD *)(a1 - 16);
  sub_100082E0(v1);
  result = sub_1002404A(*(LPVOID *)v1);
  *(_DWORD *)v1 = 0;
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10050B88) --------------------------------------------------------
#error "10050B94: call analysis failed (funcsize=7)"

//----- (10050BB0) --------------------------------------------------------
int __usercall sub_10050BB0<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 24));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10050BBB) --------------------------------------------------------
int __usercall sub_10050BBB<eax>(int a1<ebp>)
{
  return sub_1002401B(*(LPVOID *)(a1 - 24));
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (10050BC6) --------------------------------------------------------
#error "10050BD2: call analysis failed (funcsize=10)"

//----- (10050BF0) --------------------------------------------------------
void __usercall sub_10050BF0(void *this<ecx>, int a2<ebp>)
{
  sub_10022167(*(void **)(a2 - 24));
}

//----- (10050BF8) --------------------------------------------------------
void __usercall sub_10050BF8(int a1<ebx>, int a2<ebp>)
{
  LPVOID *v2; // ecx@1
  LPVOID *v3; // esi@1

  v2 = (LPVOID *)(*(_DWORD *)(a2 - 24) + 4);
  v3 = v2;
  if ( *v2 )
    sub_100282F6(a1, *v2);
  *v3 = 0;
}

//----- (10050C03) --------------------------------------------------------
void __cdecl sub_10050C03()
{
  JUMPOUT(*(unsigned int *)loc_1000C850);
}
// 1000C850: using guessed type int loc_1000C850();

//----- (10050C0E) --------------------------------------------------------
void __cdecl sub_10050C0E()
{
  JUMPOUT(*(unsigned int *)loc_1000C850);
}
// 1000C850: using guessed type int loc_1000C850();

//----- (10050C19) --------------------------------------------------------
void __cdecl sub_10050C19()
{
  JUMPOUT(*(unsigned int *)loc_1000C850);
}
// 1000C850: using guessed type int loc_1000C850();

//----- (10050C24) --------------------------------------------------------
void __cdecl sub_10050C24()
{
  JUMPOUT(*(unsigned int *)loc_1000C850);
}
// 1000C850: using guessed type int loc_1000C850();

//----- (10050C2F) --------------------------------------------------------
void __cdecl sub_10050C2F()
{
  JUMPOUT(*(unsigned int *)loc_1000C850);
}
// 1000C850: using guessed type int loc_1000C850();

//----- (10050C3A) --------------------------------------------------------
#error "10050C46: call analysis failed (funcsize=10)"

//----- (10050C60) --------------------------------------------------------
int __usercall sub_10050C60<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 36);
}

//----- (10050C68) --------------------------------------------------------
#error "10050C74: call analysis failed (funcsize=7)"

//----- (10050C90) --------------------------------------------------------
int __usercall sub_10050C90<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // ecx@1
  int v3; // ecx@1

  v3 = **(_DWORD **)(a1 - 16);
  result = *(_DWORD *)(*(_DWORD *)v3 + 4);
  v2 = *(_DWORD *)(result + v3 + 56);
  if ( v2 )
    result = (*(int (**)(void))(*(_DWORD *)v2 + 8))();
  return result;
}

//----- (10050C98) --------------------------------------------------------
#error "10050CA4: call analysis failed (funcsize=7)"

//----- (10050CC0) --------------------------------------------------------
void __cdecl sub_10050CC0()
{
  JUMPOUT(*(unsigned int *)loc_10004D80);
}
// 10004D80: using guessed type int loc_10004D80();

//----- (10050CC8) --------------------------------------------------------
#error "10050CD4: call analysis failed (funcsize=7)"

//----- (10050CF0) --------------------------------------------------------
void __cdecl sub_10050CF0()
{
  JUMPOUT(*(unsigned int *)loc_1000CC20);
}
// 1000CC20: using guessed type int loc_1000CC20();

//----- (10050CF8) --------------------------------------------------------
void __cdecl sub_10050CF8()
{
  JUMPOUT(*(unsigned int *)loc_1000CCE0);
}
// 1000CCE0: using guessed type int loc_1000CCE0();

//----- (10050D00) --------------------------------------------------------
void __usercall sub_10050D00(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 - 28));
}

//----- (10050D08) --------------------------------------------------------
#error "10050D14: call analysis failed (funcsize=7)"

//----- (10050D30) --------------------------------------------------------
int __usercall sub_10050D30<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 48));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10050D3B) --------------------------------------------------------
int __usercall sub_10050D3B<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 68, a2);
}

//----- (10050D43) --------------------------------------------------------
void __cdecl sub_10050D43()
{
  JUMPOUT(*(unsigned int *)loc_10004D80);
}
// 10004D80: using guessed type int loc_10004D80();

//----- (10050D4B) --------------------------------------------------------
void __cdecl sub_10050D4B()
{
  JUMPOUT(*(unsigned int *)loc_10004D80);
}
// 10004D80: using guessed type int loc_10004D80();

//----- (10050D53) --------------------------------------------------------
void __usercall sub_10050D53(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_100059C0(a3 - 44, a2);
}

//----- (10050D5B) --------------------------------------------------------
void __cdecl sub_10050D5B()
{
  JUMPOUT(*(unsigned int *)loc_10004D80);
}
// 10004D80: using guessed type int loc_10004D80();

//----- (10050D63) --------------------------------------------------------
#error "10050D6F: call analysis failed (funcsize=10)"

//----- (10050D90) --------------------------------------------------------
void __cdecl sub_10050D90()
{
  JUMPOUT(*(unsigned int *)loc_10004D80);
}
// 10004D80: using guessed type int loc_10004D80();

//----- (10050D98) --------------------------------------------------------
#error "10050DA4: call analysis failed (funcsize=7)"

//----- (10050DC0) --------------------------------------------------------
void __cdecl sub_10050DC0()
{
  JUMPOUT(*(unsigned int *)loc_10004D80);
}
// 10004D80: using guessed type int loc_10004D80();

//----- (10050DC8) --------------------------------------------------------
#error "10050DD4: call analysis failed (funcsize=7)"

//----- (10050DF0) --------------------------------------------------------
void __usercall sub_10050DF0(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 - 96));
}

//----- (10050DF8) --------------------------------------------------------
int __usercall sub_10050DF8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 68);
}

//----- (10050E00) --------------------------------------------------------
void __usercall sub_10050E00(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 - 96));
}

//----- (10050E08) --------------------------------------------------------
int __usercall sub_10050E08<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 44);
}

//----- (10050E10) --------------------------------------------------------
#error "10050E1C: call analysis failed (funcsize=11)"

//----- (10050E40) --------------------------------------------------------
int __usercall sub_10050E40<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 + 8));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10050E4B) --------------------------------------------------------
#error "10050E57: call analysis failed (funcsize=7)"

//----- (10050E70) --------------------------------------------------------
int __usercall sub_10050E70<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 + 8));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10050E7B) --------------------------------------------------------
#error "10050E87: call analysis failed (funcsize=7)"

//----- (10050EA0) --------------------------------------------------------
int __usercall sub_10050EA0<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 + 8));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10050EAB) --------------------------------------------------------
void __usercall sub_10050EAB(void *this<ecx>, int a2<ebx>, int a3<ebp>)
{
  if ( *(_DWORD *)(a3 - 16) & 1 )
  {
    *(_DWORD *)(a3 - 16) &= 0xFFFFFFFEu;
    sub_1000C870((void *)(a3 - 68), a2);
  }
}

//----- (10050EC4) --------------------------------------------------------
void __usercall sub_10050EC4(int a1<ebp>)
{
  **(_DWORD **)(a1 + 8) = &off_10055634;
}
// 10055634: using guessed type int (__stdcall *off_10055634)(char);

//----- (10050ECC) --------------------------------------------------------
#error "10050ED8: call analysis failed (funcsize=7)"

//----- (10050EF0) --------------------------------------------------------
#error "10050EFC: call analysis failed (funcsize=7)"

//----- (10050F10) --------------------------------------------------------
void __usercall sub_10050F10(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 - 76));
}

//----- (10050F18) --------------------------------------------------------
int __usercall sub_10050F18<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 68);
}

//----- (10050F20) --------------------------------------------------------
void __usercall sub_10050F20(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 - 92));
}

//----- (10050F28) --------------------------------------------------------
int __usercall sub_10050F28<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 44);
}

//----- (10050F30) --------------------------------------------------------
#error "10050F3C: call analysis failed (funcsize=11)"

//----- (10050F60) --------------------------------------------------------
#error "10050F6C: call analysis failed (funcsize=7)"

//----- (10050F80) --------------------------------------------------------
int __usercall sub_10050F80<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 40);
}

//----- (10050F88) --------------------------------------------------------
int __usercall sub_10050F88<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 64);
}

//----- (10050F90) --------------------------------------------------------
#error "10050F9C: call analysis failed (funcsize=7)"

//----- (10050FB0) --------------------------------------------------------
int __usercall sub_10050FB0<eax>(int a1<ebp>)
{
  int result; // eax@2
  int v2; // esi@1

  v2 = a1 - 60;
  if ( *(_DWORD *)(a1 - 60 + 32) >= 0x10u )
    result = sub_1002404A(*(LPVOID *)(a1 - 60 + 12));
  *(_DWORD *)(v2 + 32) = 15;
  *(_DWORD *)(v2 + 28) = 0;
  *(_BYTE *)(v2 + 12) = 0;
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10050FB8) --------------------------------------------------------
#error "10050FC4: call analysis failed (funcsize=10)"

//----- (10050FE0) --------------------------------------------------------
int __usercall sub_10050FE0<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 16) & 1;
  if ( *(_DWORD *)(a2 - 16) & 1 )
  {
    *(_DWORD *)(a2 - 16) &= 0xFFFFFFFEu;
    result = sub_10001A30(*(_DWORD *)(a2 - 20));
  }
  return result;
}

//----- (10050FF9) --------------------------------------------------------
#error "10051005: call analysis failed (funcsize=7)"

//----- (10051020) --------------------------------------------------------
int __usercall sub_10051020<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 84);
}

//----- (10051028) --------------------------------------------------------
int __usercall sub_10051028<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 48);
}

//----- (10051030) --------------------------------------------------------
int __usercall sub_10051030<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 116);
}

//----- (10051038) --------------------------------------------------------
int __usercall sub_10051038<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 76, a2);
}

//----- (10051040) --------------------------------------------------------
#error "1005104F: call analysis failed (funcsize=10)"

//----- (10051070) --------------------------------------------------------
int __usercall sub_10051070<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 100, a2);
}

//----- (10051078) --------------------------------------------------------
int __usercall sub_10051078<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 108);
}

//----- (10051080) --------------------------------------------------------
int __usercall sub_10051080<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 60);
}

//----- (10051088) --------------------------------------------------------
int __usercall sub_10051088<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 84);
}

//----- (10051090) --------------------------------------------------------
int __usercall sub_10051090<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 100, a2);
}

//----- (10051098) --------------------------------------------------------
int __usercall sub_10051098<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 100, a2);
}

//----- (100510A0) --------------------------------------------------------
#error "100510AC: call analysis failed (funcsize=7)"

//----- (100510C0) --------------------------------------------------------
int __usercall sub_100510C0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 44);
}

//----- (100510C8) --------------------------------------------------------
int __usercall sub_100510C8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 60, a2);
}

//----- (100510D0) --------------------------------------------------------
#error "100510DC: call analysis failed (funcsize=10)"

//----- (10051100) --------------------------------------------------------
int __usercall sub_10051100<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 84);
}

//----- (10051108) --------------------------------------------------------
int __usercall sub_10051108<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 60);
}

//----- (10051110) --------------------------------------------------------
int __usercall sub_10051110<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 60);
}

//----- (10051118) --------------------------------------------------------
#error "10051124: call analysis failed (funcsize=7)"

//----- (10051140) --------------------------------------------------------
int __usercall sub_10051140<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 40);
}

//----- (10051148) --------------------------------------------------------
int __usercall sub_10051148<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 64);
}

//----- (10051150) --------------------------------------------------------
#error "1005115C: call analysis failed (funcsize=7)"

//----- (10051170) --------------------------------------------------------
void __usercall sub_10051170(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 - 76));
}

//----- (10051178) --------------------------------------------------------
int __usercall sub_10051178<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 44);
}

//----- (10051180) --------------------------------------------------------
#error "1005118C: call analysis failed (funcsize=11)"

//----- (100511B0) --------------------------------------------------------
void __cdecl sub_100511B0()
{
  JUMPOUT(*(unsigned int *)loc_10004D80);
}
// 10004D80: using guessed type int loc_10004D80();

//----- (100511B8) --------------------------------------------------------
#error "100511C4: call analysis failed (funcsize=7)"

//----- (100511EF) --------------------------------------------------------
#error "100511FB: call analysis failed (funcsize=10)"

//----- (10051220) --------------------------------------------------------
int __usercall sub_10051220<eax>(int a1<ebp>)
{
  int result; // eax@3
  int v2; // ecx@3
  void **v3; // esi@1

  v3 = (void **)(a1 - 28);
  if ( !(unsigned __int8)sub_10021DCB() )
    sub_1000CC40(*v3);
  result = *(_DWORD *)(*(_DWORD *)*v3 + 4);
  v2 = *(_DWORD *)(*v3 + result + 56);
  if ( v2 )
    result = (*(int (**)(void))(*(_DWORD *)v2 + 8))();
  return result;
}
// 10021DCB: using guessed type int sub_10021DCB(void);

//----- (10051228) --------------------------------------------------------
#error "10051234: call analysis failed (funcsize=11)"

//----- (10051250) --------------------------------------------------------
void __cdecl sub_10051250()
{
  JUMPOUT(*(unsigned int *)loc_1000D2C0);
}
// 1000D2C0: using guessed type int loc_1000D2C0();

//----- (10051258) --------------------------------------------------------
int __usercall sub_10051258<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 60);
}

//----- (10051260) --------------------------------------------------------
#error "1005126C: call analysis failed (funcsize=7)"

//----- (10051280) --------------------------------------------------------
void __usercall sub_10051280(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 + 8));
}

//----- (10051288) --------------------------------------------------------
#error "10051294: call analysis failed (funcsize=7)"

//----- (100512B0) --------------------------------------------------------
int __usercall sub_100512B0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 64);
}

//----- (100512B8) --------------------------------------------------------
#error "100512C4: call analysis failed (funcsize=10)"

//----- (100512E0) --------------------------------------------------------
int __thiscall sub_100512E0(void *this)
{
  return nullsub_3(this);
}
// 100010B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (100512F1) --------------------------------------------------------
#error "100512FD: call analysis failed (funcsize=7)"

//----- (10051310) --------------------------------------------------------
int __usercall sub_10051310<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 20));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1005131B) --------------------------------------------------------
int __usercall sub_1005131B<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 60, a2);
}

//----- (10051323) --------------------------------------------------------
int __usercall sub_10051323<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 84);
}

//----- (1005132B) --------------------------------------------------------
#error "10051337: call analysis failed (funcsize=7)"

//----- (10051350) --------------------------------------------------------
int __usercall sub_10051350<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 44);
}

//----- (10051358) --------------------------------------------------------
int __usercall sub_10051358<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 72));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10051363) --------------------------------------------------------
int __usercall sub_10051363<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 60, a2);
}

//----- (1005136B) --------------------------------------------------------
int __usercall sub_1005136B<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 68);
}

//----- (10051373) --------------------------------------------------------
int __usercall sub_10051373<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 68);
}

//----- (1005137B) --------------------------------------------------------
int __usercall sub_1005137B<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 68);
}

//----- (10051383) --------------------------------------------------------
#error "1005138F: call analysis failed (funcsize=10)"

//----- (100513B0) --------------------------------------------------------
int __usercall sub_100513B0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 56, a2);
}

//----- (100513B8) --------------------------------------------------------
int __usercall sub_100513B8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 56, a2);
}

//----- (100513C0) --------------------------------------------------------
int __usercall sub_100513C0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 56, a2);
}

//----- (100513C8) --------------------------------------------------------
int __usercall sub_100513C8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 80);
}

//----- (100513D0) --------------------------------------------------------
#error "100513DC: call analysis failed (funcsize=7)"

//----- (100513F5) --------------------------------------------------------
#error "10051401: call analysis failed (funcsize=10)"

//----- (10051420) --------------------------------------------------------
int __usercall sub_10051420<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 48));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1005142B) --------------------------------------------------------
int __usercall sub_1005142B<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 72, a2);
}

//----- (10051433) --------------------------------------------------------
void __cdecl sub_10051433()
{
  JUMPOUT(*(unsigned int *)loc_10004D80);
}
// 10004D80: using guessed type int loc_10004D80();

//----- (1005143B) --------------------------------------------------------
void __cdecl sub_1005143B()
{
  JUMPOUT(*(unsigned int *)loc_10004D80);
}
// 10004D80: using guessed type int loc_10004D80();

//----- (10051443) --------------------------------------------------------
void __usercall sub_10051443(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_100059C0(a3 - 40, a2);
}

//----- (1005144B) --------------------------------------------------------
void __cdecl sub_1005144B()
{
  JUMPOUT(*(unsigned int *)loc_10004D80);
}
// 10004D80: using guessed type int loc_10004D80();

//----- (10051453) --------------------------------------------------------
#error "1005145F: call analysis failed (funcsize=10)"

//----- (10051480) --------------------------------------------------------
int __usercall sub_10051480<eax>(int a1<ebp>)
{
  return sub_1002401B(*(LPVOID *)(a1 + 8));
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (1005148B) --------------------------------------------------------
#error "10051497: call analysis failed (funcsize=7)"

//----- (100514B0) --------------------------------------------------------
int __usercall sub_100514B0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 240);
}

//----- (100514BB) --------------------------------------------------------
int __usercall sub_100514BB<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 216);
}

//----- (100514C6) --------------------------------------------------------
int __usercall sub_100514C6<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 40);
}

//----- (100514CE) --------------------------------------------------------
char __usercall sub_100514CE<al>(int a1<ebp>)
{
  int v1; // esi@1
  int v3; // ecx@1

  v3 = a1 - 192;
  v1 = a1 - 192 + 80;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v3 + 4) + v3 + 80 - 80) = off_1005C64C;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v3 + 4) + v3 + 80 - 84) = *(_DWORD *)(*(_DWORD *)v3 + 4) - 80;
  sub_10007620(a1 - 192 + 4);
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 - 192) + 4) + a1 - 192 + 80 - 80) = off_1005C658;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 - 192) + 4) + a1 - 192 + 80 - 84) = *(_DWORD *)(*(_DWORD *)(a1 - 192) + 4) - 8;
  *(_DWORD *)v1 = &off_1005C6EC;
  return sub_10021D4C(v1);
}
// 1005C64C: using guessed type int (*off_1005C64C[6])();
// 1005C658: using guessed type int (*off_1005C658[3])();
// 1005C6EC: using guessed type int (__stdcall *off_1005C6EC)(char);

//----- (100514D9) --------------------------------------------------------
int __usercall sub_100514D9<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 216);
}

//----- (100514E4) --------------------------------------------------------
#error "100514F3: call analysis failed (funcsize=10)"

//----- (10051510) --------------------------------------------------------
int __usercall sub_10051510<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 136);
}

//----- (1005151B) --------------------------------------------------------
int __usercall sub_1005151B<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 64);
}

//----- (10051523) --------------------------------------------------------
int __usercall sub_10051523<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 112);
}

//----- (1005152B) --------------------------------------------------------
int __usercall sub_1005152B<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 88);
}

//----- (10051533) --------------------------------------------------------
int __usercall sub_10051533<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 40);
}

//----- (1005153B) --------------------------------------------------------
int __usercall sub_1005153B<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = a1 - 188;
  result = *(_DWORD *)(a1 - 188);
  if ( *(_DWORD *)(a1 - 188) )
  {
    sub_1000D280(result, *(_DWORD *)(a1 - 188 + 4));
    result = sub_1002404A(*(LPVOID *)v2);
    *(_DWORD *)v2 = 0;
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10051546) --------------------------------------------------------
int __usercall sub_10051546<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 160);
}

//----- (10051551) --------------------------------------------------------
#error "10051563: call analysis failed (funcsize=7)"

//----- (10051580) --------------------------------------------------------
void __usercall sub_10051580(int a1<ebp>)
{
  int v1; // eax@2
  int v2; // ecx@1

  v2 = *(_DWORD *)(*(_DWORD *)(a1 - 16) + 12);
  if ( v2 )
  {
    v1 = (*(int (**)(void))(*(_DWORD *)v2 + 8))();
    if ( v1 )
      (**(void (__thiscall ***)(_DWORD, _DWORD))v1)(v1, 1);
  }
}

//----- (1005158B) --------------------------------------------------------
#error "10051597: call analysis failed (funcsize=7)"

//----- (100515B0) --------------------------------------------------------
void __usercall sub_100515B0(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 - 92));
}

//----- (100515B8) --------------------------------------------------------
void __usercall sub_100515B8(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 - 96));
}

//----- (100515C0) --------------------------------------------------------
#error "100515CC: call analysis failed (funcsize=10)"

//----- (100515F0) --------------------------------------------------------
#error "100515FC: call analysis failed (funcsize=7)"

//----- (10051610) --------------------------------------------------------
#error "1005161C: call analysis failed (funcsize=7)"

//----- (10051630) --------------------------------------------------------
int __usercall sub_10051630<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 44);
}

//----- (10051638) --------------------------------------------------------
int __usercall sub_10051638<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 68);
}

//----- (10051640) --------------------------------------------------------
#error "1005164C: call analysis failed (funcsize=10)"

//----- (10051670) --------------------------------------------------------
int __usercall sub_10051670<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_1000E6A0(a2 - 144);
}

//----- (1005167B) --------------------------------------------------------
#error "1005168A: call analysis failed (funcsize=10)"

//----- (100516B0) --------------------------------------------------------
int __usercall sub_100516B0<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = a1 - 104;
  *(_DWORD *)(a1 - 104 + 32) = 0;
  result = *(_DWORD *)(a1 - 104 + 20);
  if ( result )
  {
    result = sub_1002404A(*(LPVOID *)(a1 - 104 + 20));
    *(_DWORD *)(v2 + 20) = 0;
    *(_DWORD *)(v2 + 24) = 0;
    *(_DWORD *)(v2 + 28) = 0;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (100516B8) --------------------------------------------------------
#error "100516C4: call analysis failed (funcsize=10)"

//----- (100516E0) --------------------------------------------------------
int __usercall sub_100516E0<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 20) & 1;
  if ( *(_DWORD *)(a2 - 20) & 1 )
  {
    *(_DWORD *)(a2 - 20) &= 0xFFFFFFFEu;
    result = sub_10001A30(*(_DWORD *)(a2 + 8));
  }
  return result;
}

//----- (100516F9) --------------------------------------------------------
LPVOID __usercall sub_100516F9<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_1000E8E0((LPVOID *)(a2 - 32));
}

//----- (10051701) --------------------------------------------------------
void __usercall sub_10051701(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 + 16));
}

//----- (10051709) --------------------------------------------------------
void __usercall sub_10051709(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 + 16));
}

//----- (10051711) --------------------------------------------------------
#error "1005171D: call analysis failed (funcsize=7)"

//----- (10051730) --------------------------------------------------------
int __usercall sub_10051730<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 40) & 1;
  if ( *(_DWORD *)(a2 - 40) & 1 )
  {
    *(_DWORD *)(a2 - 40) &= 0xFFFFFFFEu;
    result = sub_10001A30(*(_DWORD *)(a2 - 44));
  }
  return result;
}

//----- (10051749) --------------------------------------------------------
LPVOID __usercall sub_10051749<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_1000E8E0((LPVOID *)(a2 - 36));
}

//----- (10051751) --------------------------------------------------------
void __usercall sub_10051751(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 - 20));
}

//----- (10051759) --------------------------------------------------------
void __usercall sub_10051759(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 - 20));
}

//----- (10051761) --------------------------------------------------------
#error "1005176D: call analysis failed (funcsize=7)"

//----- (10051780) --------------------------------------------------------
void __cdecl sub_10051780()
{
  JUMPOUT(*(unsigned int *)loc_1000E810);
}
// 1000E810: using guessed type int loc_1000E810();

//----- (10051788) --------------------------------------------------------
void __cdecl sub_10051788()
{
  JUMPOUT(*(unsigned int *)loc_1000E810);
}
// 1000E810: using guessed type int loc_1000E810();

//----- (10051793) --------------------------------------------------------
LPVOID __usercall sub_10051793<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_1000E8E0((LPVOID *)(*(_DWORD *)(a2 - 20) + 64));
}

//----- (1005179E) --------------------------------------------------------
#error "100517AA: call analysis failed (funcsize=7)"

//----- (100517C0) --------------------------------------------------------
LPVOID __usercall sub_100517C0<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_1000E8E0(*(LPVOID **)(a2 - 24));
}

//----- (100517C8) --------------------------------------------------------
LPVOID __usercall sub_100517C8<eax>(int a1<ebp>)
{
  LPVOID result; // eax@1
  LPVOID *v2; // ecx@1
  LPVOID *v3; // esi@1

  v2 = (LPVOID *)(*(_DWORD *)(a1 - 20) + 20);
  v3 = v2;
  *(_DWORD *)(*(_DWORD *)(a1 - 20) + 32) = 0;
  result = *v2;
  if ( *v2 )
  {
    result = (LPVOID)sub_1002404A(*v2);
    *v3 = 0;
    v3[1] = 0;
    v3[2] = 0;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (100517D3) --------------------------------------------------------
#error "100517DF: call analysis failed (funcsize=7)"

//----- (100517F0) --------------------------------------------------------
int __usercall sub_100517F0<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = *(_DWORD *)(a1 - 16) + 16;
  result = *(_DWORD *)(*(_DWORD *)(a1 - 16) + 24);
  if ( result )
  {
    result = sub_1002404A(*(LPVOID *)(*(_DWORD *)(a1 - 16) + 24));
    *(_DWORD *)(v2 + 8) = 0;
    *(_DWORD *)(v2 + 12) = 0;
    *(_DWORD *)(v2 + 16) = 0;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (100517FB) --------------------------------------------------------
#error "10051807: call analysis failed (funcsize=7)"

//----- (10051820) --------------------------------------------------------
int __usercall sub_10051820<eax>(int a1<ebp>)
{
  int v1; // esi@4
  int result; // eax@1
  int v3; // ecx@2

  result = *(_DWORD *)(a1 - 16) & 1;
  if ( *(_DWORD *)(a1 - 16) & 1 )
  {
    *(_DWORD *)(a1 - 16) &= 0xFFFFFFFEu;
    v3 = *(_DWORD *)(a1 + 8);
    v1 = *(_DWORD *)(a1 + 8);
    result = *(_DWORD *)(v3 + 24);
    if ( result )
    {
      result = sub_1002404A(*(LPVOID *)(v3 + 24));
      *(_DWORD *)(v1 + 24) = 0;
      *(_DWORD *)(v1 + 28) = 0;
      *(_DWORD *)(v1 + 32) = 0;
    }
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10051839) --------------------------------------------------------
#error "10051845: call analysis failed (funcsize=7)"

//----- (10051860) --------------------------------------------------------
void __usercall sub_10051860(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 - 16));
}

//----- (10051868) --------------------------------------------------------
void __usercall sub_10051868(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 + 8));
}

//----- (10051870) --------------------------------------------------------
#error "1005187C: call analysis failed (funcsize=7)"

//----- (10051890) --------------------------------------------------------
int __usercall sub_10051890<eax>(int a1<ebp>)
{
  char v1; // zf@2
  int v2; // ecx@4
  int result; // eax@1
  int v4; // esi@1

  v4 = a1 - 36;
  result = *(_DWORD *)(a1 - 36);
  if ( *(_DWORD *)(a1 - 36) )
  {
    v1 = *(_DWORD *)(result + 32)-- == 1;
    if ( v1 )
      result = sub_1000D350(*(_DWORD *)(a1 - 36), 0);
  }
  *(_DWORD *)v4 = 0;
  v2 = *(_DWORD *)(v4 + 12);
  if ( v2 )
  {
    result = (*(int (**)(void))(*(_DWORD *)v2 + 8))();
    if ( result )
      result = (**(int (__thiscall ***)(_DWORD, _DWORD))result)(result, 1);
  }
  return result;
}

//----- (10051898) --------------------------------------------------------
void __cdecl sub_10051898()
{
  JUMPOUT(*(unsigned int *)loc_1000DAD0);
}
// 1000DAD0: using guessed type int loc_1000DAD0();

//----- (100518A3) --------------------------------------------------------
void __cdecl sub_100518A3()
{
  JUMPOUT(*(unsigned int *)loc_1000DAD0);
}
// 1000DAD0: using guessed type int loc_1000DAD0();

//----- (100518AE) --------------------------------------------------------
int __usercall sub_100518AE<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 60);
}

//----- (100518B6) --------------------------------------------------------
#error "100518C5: call analysis failed (funcsize=10)"

//----- (100518E0) --------------------------------------------------------
void __usercall sub_100518E0(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 - 16));
}

//----- (100518E8) --------------------------------------------------------
#error "100518F4: call analysis failed (funcsize=7)"

//----- (10051910) --------------------------------------------------------
void __usercall sub_10051910(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 - 16));
}

//----- (10051918) --------------------------------------------------------
#error "10051924: call analysis failed (funcsize=7)"

//----- (10051940) --------------------------------------------------------
int __usercall sub_10051940<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 48);
}

//----- (10051948) --------------------------------------------------------
#error "10051954: call analysis failed (funcsize=10)"

//----- (10051970) --------------------------------------------------------
void __usercall sub_10051970(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 - 16));
}

//----- (10051978) --------------------------------------------------------
void __usercall sub_10051978(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 - 20));
}

//----- (10051980) --------------------------------------------------------
#error "1005198C: call analysis failed (funcsize=7)"

//----- (100519A0) --------------------------------------------------------
#error "100519AC: call analysis failed (funcsize=7)"

//----- (100519C0) --------------------------------------------------------
#error "100519CC: call analysis failed (funcsize=7)"

//----- (100519E0) --------------------------------------------------------
void __usercall sub_100519E0(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 - 28));
}

//----- (100519E8) --------------------------------------------------------
#error "100519F4: call analysis failed (funcsize=10)"

//----- (10051A10) --------------------------------------------------------
void __cdecl sub_10051A10()
{
  JUMPOUT(*(unsigned int *)loc_1000E870);
}
// 1000E870: using guessed type int loc_1000E870();

//----- (10051A18) --------------------------------------------------------
void __cdecl sub_10051A18()
{
  JUMPOUT(*(unsigned int *)loc_1000E810);
}
// 1000E810: using guessed type int loc_1000E810();

//----- (10051A20) --------------------------------------------------------
void __cdecl sub_10051A20()
{
  JUMPOUT(*(unsigned int *)loc_1000E870);
}
// 1000E870: using guessed type int loc_1000E870();

//----- (10051A28) --------------------------------------------------------
void __cdecl sub_10051A28()
{
  JUMPOUT(*(unsigned int *)loc_1000E810);
}
// 1000E810: using guessed type int loc_1000E810();

//----- (10051A30) --------------------------------------------------------
#error "10051A3C: call analysis failed (funcsize=10)"

//----- (10051A60) --------------------------------------------------------
int __usercall sub_10051A60<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = a1 - 80;
  *(_DWORD *)(a1 - 80 + 16) = 0;
  result = *(_DWORD *)(a1 - 80 + 4);
  if ( result )
  {
    result = sub_1002404A(*(LPVOID *)(a1 - 80 + 4));
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
    *(_DWORD *)(v2 + 12) = 0;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10051A68) --------------------------------------------------------
int __usercall sub_10051A68<eax>(int a1<ebp>)
{
  int result; // eax@3
  int v2; // esi@1

  v2 = a1 - 80;
  if ( *(_DWORD *)(a1 - 80 + 20) )
  {
    sub_1002404A(*(LPVOID *)(a1 - 80 + 20));
    *(_DWORD *)(v2 + 20) = 0;
    *(_DWORD *)(v2 + 24) = 0;
    *(_DWORD *)(v2 + 28) = 0;
  }
  *(_DWORD *)(v2 + 16) = 0;
  result = *(_DWORD *)(v2 + 4);
  if ( result )
  {
    result = sub_1002404A(*(LPVOID *)(v2 + 4));
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
    *(_DWORD *)(v2 + 12) = 0;
  }
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10051A70) --------------------------------------------------------
void __cdecl sub_10051A70()
{
  JUMPOUT(*(unsigned int *)loc_1000E870);
}
// 1000E870: using guessed type int loc_1000E870();

//----- (10051A78) --------------------------------------------------------
void __cdecl sub_10051A78()
{
  JUMPOUT(*(unsigned int *)loc_1000E810);
}
// 1000E810: using guessed type int loc_1000E810();

//----- (10051A80) --------------------------------------------------------
#error "10051A8C: call analysis failed (funcsize=10)"

//----- (10051AB0) --------------------------------------------------------
void __cdecl sub_10051AB0()
{
  JUMPOUT(*(unsigned int *)loc_1000E870);
}
// 1000E870: using guessed type int loc_1000E870();

//----- (10051AB8) --------------------------------------------------------
void __cdecl sub_10051AB8()
{
  JUMPOUT(*(unsigned int *)loc_1000E810);
}
// 1000E810: using guessed type int loc_1000E810();

//----- (10051AC0) --------------------------------------------------------
#error "10051ACC: call analysis failed (funcsize=10)"

//----- (10051AF0) --------------------------------------------------------
int __usercall sub_10051AF0<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 96));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10051AFB) --------------------------------------------------------
int __usercall sub_10051AFB<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 100) & 1;
  if ( *(_DWORD *)(a2 - 100) & 1 )
  {
    *(_DWORD *)(a2 - 100) &= 0xFFFFFFFEu;
    result = sub_10001A30(a2 - 92);
  }
  return result;
}

//----- (10051B14) --------------------------------------------------------
#error "10051B20: call analysis failed (funcsize=7)"

//----- (10051B30) --------------------------------------------------------
void __usercall sub_10051B30(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 - 16));
}

//----- (10051B38) --------------------------------------------------------
#error "10051B44: call analysis failed (funcsize=7)"

//----- (10051B60) --------------------------------------------------------
void __cdecl sub_10051B60()
{
  JUMPOUT(*(unsigned int *)loc_1000E870);
}
// 1000E870: using guessed type int loc_1000E870();

//----- (10051B68) --------------------------------------------------------
#error "10051B74: call analysis failed (funcsize=11)"

//----- (10051B90) --------------------------------------------------------
int __usercall sub_10051B90<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 64);
}

//----- (10051B98) --------------------------------------------------------
#error "10051BA4: call analysis failed (funcsize=7)"

//----- (10051BC0) --------------------------------------------------------
int __usercall sub_10051BC0<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 16) & 1;
  if ( *(_DWORD *)(a2 - 16) & 1 )
  {
    *(_DWORD *)(a2 - 16) &= 0xFFFFFFFEu;
    result = sub_10001A30(*(_DWORD *)(a2 + 8));
  }
  return result;
}

//----- (10051BD9) --------------------------------------------------------
#error "10051BE5: call analysis failed (funcsize=7)"

//----- (10051C00) --------------------------------------------------------
void __usercall sub_10051C00(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 + 12));
}

//----- (10051C08) --------------------------------------------------------
#error "10051C14: call analysis failed (funcsize=7)"

//----- (10051C30) --------------------------------------------------------
int __usercall sub_10051C30<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 68) & 1;
  if ( *(_DWORD *)(a2 - 68) & 1 )
  {
    *(_DWORD *)(a2 - 68) &= 0xFFFFFFFEu;
    result = sub_10001A30(a2 - 40);
  }
  return result;
}

//----- (10051C49) --------------------------------------------------------
#error "10051C55: call analysis failed (funcsize=7)"

//----- (10051C70) --------------------------------------------------------
void __usercall sub_10051C70(void *this<ecx>, int a2<ebp>)
{
  sub_1000CBE0((void *)(a2 - 48));
}

//----- (10051C78) --------------------------------------------------------
#error "10051C84: call analysis failed (funcsize=10)"

//----- (10051CA0) --------------------------------------------------------
void __cdecl sub_10051CA0()
{
  JUMPOUT(*(unsigned int *)loc_10001480);
}
// 10001480: using guessed type int loc_10001480();

//----- (10051CA8) --------------------------------------------------------
int __thiscall sub_10051CA8(void *this)
{
  return nullsub_3(this);
}
// 100010B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (10051CBC) --------------------------------------------------------
int __usercall sub_10051CBC<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10020640(*(_DWORD *)(a2 - 20));
}

//----- (10051CC4) --------------------------------------------------------
#error "10051CD0: call analysis failed (funcsize=7)"

//----- (10051CE0) --------------------------------------------------------
int __usercall sub_10051CE0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_1001B660(a2 + 8);
}

//----- (10051CE8) --------------------------------------------------------
void __cdecl sub_10051CE8()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10051CF0) --------------------------------------------------------
void __cdecl sub_10051CF0()
{
  JUMPOUT(*(unsigned int *)loc_10020730);
}
// 10020730: using guessed type int loc_10020730();

//----- (10051CF8) --------------------------------------------------------
int __usercall sub_10051CF8<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10001500((void *)(a2 - 20));
}

//----- (10051D00) --------------------------------------------------------
void __cdecl sub_10051D00()
{
  JUMPOUT(*(unsigned int *)loc_10020730);
}
// 10020730: using guessed type int loc_10020730();

//----- (10051D08) --------------------------------------------------------
int __usercall sub_10051D08<eax>(int a1<ebp>)
{
  return sub_100204A0(*(_DWORD *)(a1 - 16));
}
// 100204A0: using guessed type _DWORD __cdecl sub_100204A0(_DWORD);

//----- (10051D13) --------------------------------------------------------
void __cdecl sub_10051D13()
{
  JUMPOUT(*(unsigned int *)loc_10020730);
}
// 10020730: using guessed type int loc_10020730();

//----- (10051D1B) --------------------------------------------------------
#error "10051D27: call analysis failed (funcsize=7)"

//----- (10051D40) --------------------------------------------------------
int __usercall sub_10051D40<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10001500((void *)(a2 + 8));
}

//----- (10051D48) --------------------------------------------------------
void __cdecl sub_10051D48()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10051D50) --------------------------------------------------------
void __cdecl sub_10051D50()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10051D58) --------------------------------------------------------
#error "10051D64: call analysis failed (funcsize=7)"

//----- (10051D80) --------------------------------------------------------
void __cdecl sub_10051D80()
{
  JUMPOUT(*(unsigned int *)loc_10001000);
}
// 10001000: using guessed type int loc_10001000();

//----- (10051D88) --------------------------------------------------------
#error "10051D94: call analysis failed (funcsize=10)"

//----- (10051DB0) --------------------------------------------------------
int __usercall sub_10051DB0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 + 32, a2);
}

//----- (10051DB8) --------------------------------------------------------
void __cdecl sub_10051DB8()
{
  JUMPOUT(*(unsigned int *)loc_10020730);
}
// 10020730: using guessed type int loc_10020730();

//----- (10051DC0) --------------------------------------------------------
int __usercall sub_10051DC0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(*(_DWORD *)(a3 - 28), a2);
}

//----- (10051DC8) --------------------------------------------------------
int __usercall sub_10051DC8<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 20) & 1;
  if ( *(_DWORD *)(a1 - 20) & 1 )
  {
    *(_DWORD *)(a1 - 20) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_10001870);
  }
  return result;
}
// 10001870: using guessed type int loc_10001870();

//----- (10051DE1) --------------------------------------------------------
#error "10051DED: call analysis failed (funcsize=7)"

//----- (10051E00) --------------------------------------------------------
int __usercall sub_10051E00<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10001500((void *)(a2 + 8));
}

//----- (10051E08) --------------------------------------------------------
int __usercall sub_10051E08<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 + 36, a2);
}

//----- (10051E10) --------------------------------------------------------
void __cdecl sub_10051E10()
{
  JUMPOUT(*(unsigned int *)loc_10020730);
}
// 10020730: using guessed type int loc_10020730();

//----- (10051E18) --------------------------------------------------------
int __usercall sub_10051E18<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 20));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10051E23) --------------------------------------------------------
void __cdecl sub_10051E23()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10051E2B) --------------------------------------------------------
int __usercall sub_10051E2B<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 24) & 1;
  if ( *(_DWORD *)(a1 - 24) & 1 )
  {
    *(_DWORD *)(a1 - 24) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_10001870);
  }
  return result;
}
// 10001870: using guessed type int loc_10001870();

//----- (10051E44) --------------------------------------------------------
#error "10051E50: call analysis failed (funcsize=7)"

//----- (10051E60) --------------------------------------------------------
void __cdecl sub_10051E60()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10051E68) --------------------------------------------------------
#error "10051E74: call analysis failed (funcsize=7)"

//----- (10051E90) --------------------------------------------------------
void __cdecl sub_10051E90()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10051E98) --------------------------------------------------------
#error "10051EA4: call analysis failed (funcsize=7)"

//----- (10051EC0) --------------------------------------------------------
int __thiscall sub_10051EC0(void *this)
{
  return nullsub_3(this);
}
// 100010B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (10051ED1) --------------------------------------------------------
void __usercall sub_10051ED1(int a1<ebp>)
{
  **(_DWORD **)(a1 - 24) = off_1005C020;
}
// 1005C020: using guessed type int (*off_1005C020[5])();

//----- (10051ED9) --------------------------------------------------------
void __cdecl sub_10051ED9()
{
  JUMPOUT(*(unsigned int *)loc_10001B70);
}
// 10001B70: using guessed type int loc_10001B70();

//----- (10051EE1) --------------------------------------------------------
#error "10051EED: call analysis failed (funcsize=7)"

//----- (10051F00) --------------------------------------------------------
void __cdecl sub_10051F00()
{
  JUMPOUT(*(unsigned int *)loc_10001B70);
}
// 10001B70: using guessed type int loc_10001B70();

//----- (10051F08) --------------------------------------------------------
int __usercall sub_10051F08<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A60(a2 - 48);
}

//----- (10051F10) --------------------------------------------------------
void __cdecl sub_10051F10()
{
  JUMPOUT(*(unsigned int *)loc_10001B70);
}
// 10001B70: using guessed type int loc_10001B70();

//----- (10051F18) --------------------------------------------------------
#error "10051F24: call analysis failed (funcsize=7)"

//----- (10051F40) --------------------------------------------------------
#error "10051F4C: call analysis failed (funcsize=7)"

//----- (10051F60) --------------------------------------------------------
void __cdecl sub_10051F60()
{
  JUMPOUT(*(unsigned int *)loc_10001000);
}
// 10001000: using guessed type int loc_10001000();

//----- (10051F68) --------------------------------------------------------
void __cdecl sub_10051F68()
{
  sub_100242C1();
}

//----- (10051F70) --------------------------------------------------------
#error "10051F7C: call analysis failed (funcsize=10)"

//----- (10051FA0) --------------------------------------------------------
int __usercall sub_10051FA0<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 16) & 1;
  if ( *(_DWORD *)(a1 - 16) & 1 )
  {
    *(_DWORD *)(a1 - 16) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_10001870);
  }
  return result;
}
// 10001870: using guessed type int loc_10001870();

//----- (10051FB9) --------------------------------------------------------
#error "10051FC5: call analysis failed (funcsize=7)"

//----- (10051FE0) --------------------------------------------------------
int __usercall sub_10051FE0<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 16) & 1;
  if ( *(_DWORD *)(a1 - 16) & 1 )
  {
    *(_DWORD *)(a1 - 16) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_10001870);
  }
  return result;
}
// 10001870: using guessed type int loc_10001870();

//----- (10051FF9) --------------------------------------------------------
#error "10052005: call analysis failed (funcsize=7)"

//----- (10052020) --------------------------------------------------------
int *__usercall sub_10052020<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_1001C3E0(a2 - 28);
}

//----- (10052028) --------------------------------------------------------
void __cdecl sub_10052028()
{
  JUMPOUT(*(unsigned int *)loc_10017420);
}
// 10017420: using guessed type int loc_10017420();

//----- (10052030) --------------------------------------------------------
void __cdecl sub_10052030()
{
  JUMPOUT(*(unsigned int *)loc_10017420);
}
// 10017420: using guessed type int loc_10017420();

//----- (1005203B) --------------------------------------------------------
int __usercall sub_1005203B<eax>(int a1<ebp>)
{
  return sub_10024C22(a1);
}

//----- (10052043) --------------------------------------------------------
int __usercall sub_10052043<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_1001C6A0((void *)(a2 - 136));
}

//----- (1005204E) --------------------------------------------------------
#error "1005205D: call analysis failed (funcsize=10)"

//----- (10052080) --------------------------------------------------------
int __usercall sub_10052080<eax>(int a1<ebp>)
{
  return sub_10001B10(a1 + 8);
}
// 10001B10: using guessed type int __thiscall sub_10001B10(_DWORD);

//----- (10052088) --------------------------------------------------------
#error "10052094: call analysis failed (funcsize=7)"

//----- (100520B0) --------------------------------------------------------
int __usercall sub_100520B0<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 24));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (100520BB) --------------------------------------------------------
int __usercall sub_100520BB<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 20) & 1;
  if ( *(_DWORD *)(a1 - 20) & 1 )
  {
    *(_DWORD *)(a1 - 20) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_10001870);
  }
  return result;
}
// 10001870: using guessed type int loc_10001870();

//----- (100520D4) --------------------------------------------------------
#error "100520E0: call analysis failed (funcsize=7)"

//----- (100520F0) --------------------------------------------------------
int __usercall sub_100520F0<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 28));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (100520FB) --------------------------------------------------------
void __usercall sub_100520FB(int a1<ebp>)
{
  **(_DWORD **)(a1 - 28) = off_100558D0;
}
// 100558D0: using guessed type int (*off_100558D0[2])();

//----- (10052103) --------------------------------------------------------
int __thiscall sub_10052103(void *this)
{
  return nullsub_3(this);
}
// 100010B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (10052117) --------------------------------------------------------
int __usercall sub_10052117<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 24) & 1;
  if ( *(_DWORD *)(a1 - 24) & 1 )
  {
    *(_DWORD *)(a1 - 24) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_10001870);
  }
  return result;
}
// 10001870: using guessed type int loc_10001870();

//----- (10052130) --------------------------------------------------------
#error "1005213C: call analysis failed (funcsize=7)"

//----- (10052150) --------------------------------------------------------
int __usercall sub_10052150<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 24));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1005215B) --------------------------------------------------------
int __usercall sub_1005215B<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 20) & 1;
  if ( *(_DWORD *)(a1 - 20) & 1 )
  {
    *(_DWORD *)(a1 - 20) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_10001870);
  }
  return result;
}
// 10001870: using guessed type int loc_10001870();

//----- (10052174) --------------------------------------------------------
#error "10052180: call analysis failed (funcsize=7)"

//----- (10052190) --------------------------------------------------------
int __usercall sub_10052190<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>)
{
  return sub_10020EB0(*(_DWORD *)(a4 - 56), a2, a3);
}

//----- (10052198) --------------------------------------------------------
int __usercall sub_10052198<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>)
{
  int v19; // ST08_4@6
  int v20; // ebx@1
  int v21; // esi@1
  int v22; // [sp-Ch] [bp-Ch]@2

  v20 = *(_DWORD *)(a4 - 56);
  v21 = *(_DWORD *)(v20 + 88);
  if ( v21 )
  {
    v22 = a3;
    _EDI = -1;
    _EDX = v21 + 4;
    _EAX = -1;
    __asm { lock xadd [edx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v21)(v21);
      _EAX = v21 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v21 + 4))(v21);
    }
    a3 = v22;
  }
  return sub_10020EB0(v20, v19, a3);
}

//----- (100521A0) --------------------------------------------------------
int __usercall sub_100521A0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(*(_DWORD *)(a2 - 56) + 92);
}

//----- (100521AB) --------------------------------------------------------
int __usercall sub_100521AB<eax>(int a1<ebp>)
{
  int result; // eax@2
  int v2; // esi@1

  v2 = a1 - 52;
  *(_DWORD *)(a1 - 52) = &off_1005C6C8;
  if ( *(_DWORD *)(a1 - 52 + 24) >= 0x10u )
    result = sub_1002404A(*(LPVOID *)(a1 - 52 + 4));
  *(_DWORD *)(v2 + 24) = 15;
  *(_DWORD *)(v2 + 20) = 0;
  *(_BYTE *)(v2 + 4) = 0;
  *(_DWORD *)v2 = &off_1005C6D0;
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 1005C6C8: using guessed type int (__stdcall *off_1005C6C8)(char);
// 1005C6D0: using guessed type int (__stdcall *off_1005C6D0)(char);

//----- (100521B3) --------------------------------------------------------
#error "100521BF: call analysis failed (funcsize=10)"

//----- (100521E0) --------------------------------------------------------
void __cdecl sub_100521E0()
{
  JUMPOUT(*(unsigned int *)loc_1001E3C0);
}
// 1001E3C0: using guessed type int loc_1001E3C0();

//----- (100521E8) --------------------------------------------------------
#error "100521F4: call analysis failed (funcsize=7)"

//----- (10052210) --------------------------------------------------------
void __cdecl sub_10052210()
{
  JUMPOUT(*(unsigned int *)loc_10001480);
}
// 10001480: using guessed type int loc_10001480();

//----- (10052218) --------------------------------------------------------
int __thiscall sub_10052218(void *this)
{
  return nullsub_3(this);
}
// 100010B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005222C) --------------------------------------------------------
int __usercall sub_1005222C<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10019AA0(*(void **)(a2 - 20));
}

//----- (10052234) --------------------------------------------------------
int __usercall sub_10052234<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 20) + 12);
}
// 10024CC5: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005223F) --------------------------------------------------------
#error "1005224B: call analysis failed (funcsize=7)"

//----- (10052260) --------------------------------------------------------
void __usercall sub_10052260(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_1001A2F0(*(_DWORD *)(a3 - 16) + 4, a2);
}

//----- (1005226B) --------------------------------------------------------
#error "10052277: call analysis failed (funcsize=7)"

//----- (10052290) --------------------------------------------------------
void __cdecl sub_10052290()
{
  JUMPOUT(*(unsigned int *)loc_10017420);
}
// 10017420: using guessed type int loc_10017420();

//----- (10052298) --------------------------------------------------------
void __cdecl sub_10052298()
{
  JUMPOUT(loc_10018010);
}

//----- (100522A3) --------------------------------------------------------
void __usercall sub_100522A3(void *a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_100178D0((void *)(*(_DWORD *)(a3 - 16) + 24), a2);
}

//----- (100522AE) --------------------------------------------------------
int __usercall sub_100522AE<eax>(int a1<ebp>)
{
  return j_nullsub_2(*(_DWORD *)(a1 - 16) + 176);
}
// 1001FEA0: using guessed type int __thiscall j_nullsub_2(_DWORD);

//----- (100522BC) --------------------------------------------------------
#error "100522C8: call analysis failed (funcsize=7)"

//----- (100522E0) --------------------------------------------------------
void __usercall sub_100522E0(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = &off_1005D0EC;
}
// 1005D0EC: using guessed type int (__stdcall *off_1005D0EC)(char);

//----- (100522E8) --------------------------------------------------------
int __usercall sub_100522E8<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100190E0((void *)(*(_DWORD *)(a2 - 16) + 4));
}

//----- (100522F3) --------------------------------------------------------
void __usercall sub_100522F3(void *a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_100178D0((void *)(*(_DWORD *)(a3 - 16) + 96), a2);
}

//----- (100522FE) --------------------------------------------------------
#error "1005230A: call analysis failed (funcsize=7)"

//----- (10052320) --------------------------------------------------------
int __usercall sub_10052320<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(*(_DWORD *)(a2 - 16));
}

//----- (10052328) --------------------------------------------------------
int __usercall sub_10052328<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(*(_DWORD *)(a2 - 16) + 24);
}

//----- (10052333) --------------------------------------------------------
int __usercall sub_10052333<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(*(_DWORD *)(a2 - 16) + 48);
}

//----- (1005233E) --------------------------------------------------------
int __usercall sub_1005233E<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(*(_DWORD *)(a2 - 16) + 88);
}

//----- (10052349) --------------------------------------------------------
void __cdecl sub_10052349()
{
  JUMPOUT(*(unsigned int *)loc_1000D4A0);
}
// 1000D4A0: using guessed type int loc_1000D4A0();

//----- (10052357) --------------------------------------------------------
void __cdecl sub_10052357()
{
  JUMPOUT(*(unsigned int *)loc_1000D4A0);
}
// 1000D4A0: using guessed type int loc_1000D4A0();

//----- (10052365) --------------------------------------------------------
void __cdecl sub_10052365()
{
  JUMPOUT(*(unsigned int *)loc_10001B70);
}
// 10001B70: using guessed type int loc_10001B70();

//----- (1005236D) --------------------------------------------------------
int __usercall sub_1005236D<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A60(a2 - 48);
}

//----- (10052375) --------------------------------------------------------
int __usercall sub_10052375<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10017430(*(_DWORD *)(a3 - 20), a2);
}

//----- (1005237D) --------------------------------------------------------
void __cdecl sub_1005237D()
{
  JUMPOUT(*(unsigned int *)loc_10001B70);
}
// 10001B70: using guessed type int loc_10001B70();

//----- (10052385) --------------------------------------------------------
int __usercall sub_10052385<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A60(*(_DWORD *)(a2 - 20) + 248);
}

//----- (10052393) --------------------------------------------------------
int __usercall sub_10052393<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100170C0(*(_DWORD *)(a3 - 16) + 224, a2);
}

//----- (100523A1) --------------------------------------------------------
void __cdecl sub_100523A1()
{
  JUMPOUT(*(unsigned int *)loc_10017D80);
}
// 10017D80: using guessed type int loc_10017D80();

//----- (100523AF) --------------------------------------------------------
void __cdecl sub_100523AF()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (100523BD) --------------------------------------------------------
#error "100523C9: call analysis failed (funcsize=7)"

//----- (100523E0) --------------------------------------------------------
int __usercall sub_100523E0<eax>(int a1<ebp>)
{
  return sub_10024C22(a1);
}

//----- (100523EB) --------------------------------------------------------
int __usercall sub_100523EB<eax>(int a1<ebp>)
{
  return sub_10024C22(a1);
}

//----- (100523F6) --------------------------------------------------------
void __cdecl sub_100523F6()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10052401) --------------------------------------------------------
#error "1005240D: call analysis failed (funcsize=7)"

//----- (10052420) --------------------------------------------------------
void __cdecl sub_10052420()
{
  JUMPOUT(*(unsigned int *)loc_10020730);
}
// 10020730: using guessed type int loc_10020730();

//----- (1005242B) --------------------------------------------------------
#error "10052437: call analysis failed (funcsize=7)"

//----- (10052450) --------------------------------------------------------
int __usercall sub_10052450<eax>(int a1<ebp>)
{
  int result; // eax@2
  int v14; // ecx@1
  int v15; // edi@1
  int v16; // esi@1

  v14 = *(_DWORD *)(a1 - 16);
  v16 = v14;
  *(_DWORD *)v14 = off_1005CC8C;
  v15 = *(_DWORD *)(v14 + 24);
  if ( v15 )
  {
    _EBX = -1;
    _EDX = v15 + 4;
    _EAX = -1;
    __asm { lock xadd [edx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v15)(v15);
      result = v15 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v15 + 4))(v15);
    }
    *(_DWORD *)v16 = &off_10055E44;
  }
  else
  {
    *(_DWORD *)v14 = &off_10055E44;
  }
  return result;
}
// 10055E44: using guessed type int (__stdcall *off_10055E44)(char);
// 1005CC8C: using guessed type int (__stdcall *off_1005CC8C[2])(char);

//----- (10052458) --------------------------------------------------------
int __usercall sub_10052458<eax>(int a1<ebp>)
{
  int result; // eax@3
  int v2; // esi@1

  v2 = *(_DWORD *)(a1 - 20) + 4;
  if ( *(_DWORD *)(*(_DWORD *)(a1 - 20) + 24) >= 8u )
    sub_1002404A(*(LPVOID *)(*(_DWORD *)(a1 - 20) + 4));
  *(_DWORD *)(v2 + 20) = 7;
  *(_DWORD *)(v2 + 16) = 0;
  result = 0;
  *(_WORD *)v2 = 0;
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10052463) --------------------------------------------------------
#error "1005246F: call analysis failed (funcsize=7)"

//----- (10052480) --------------------------------------------------------
void __cdecl sub_10052480()
{
  JUMPOUT(*(unsigned int *)loc_10018E80);
}
// 10018E80: using guessed type int loc_10018E80();

//----- (1005248B) --------------------------------------------------------
#error "10052497: call analysis failed (funcsize=7)"

//----- (100524B0) --------------------------------------------------------
void __cdecl sub_100524B0()
{
  JUMPOUT(*(unsigned int *)loc_10017420);
}
// 10017420: using guessed type int loc_10017420();

//----- (100524B8) --------------------------------------------------------
int __usercall sub_100524B8<eax>(int a1<ebp>)
{
  return sub_10024C22(a1);
}

//----- (100524C3) --------------------------------------------------------
int __usercall sub_100524C3<eax>(int a1<ebp>)
{
  return j_nullsub_2(*(_DWORD *)(a1 - 16) + 52);
}
// 1001FEA0: using guessed type int __thiscall j_nullsub_2(_DWORD);

//----- (100524CE) --------------------------------------------------------
void __cdecl sub_100524CE()
{
  JUMPOUT(loc_10018010);
}

//----- (100524D9) --------------------------------------------------------
#error "100524E5: call analysis failed (funcsize=7)"

//----- (10052500) --------------------------------------------------------
int __usercall sub_10052500<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10019AA0(*(void **)(a2 - 16));
}

//----- (10052508) --------------------------------------------------------
int __usercall sub_10052508<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 16) + 12);
}
// 10024CC5: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (10052513) --------------------------------------------------------
int __usercall sub_10052513<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(*(_DWORD *)(a3 - 16) + 48, a2);
}

//----- (1005251E) --------------------------------------------------------
void __cdecl sub_1005251E()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10052529) --------------------------------------------------------
#error "10052535: call analysis failed (funcsize=7)"

//----- (10052550) --------------------------------------------------------
int __usercall sub_10052550<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10020640(*(_DWORD *)(a2 - 16));
}

//----- (10052558) --------------------------------------------------------
int __usercall sub_10052558<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(*(_DWORD *)(a3 - 16) + 152, a2);
}

//----- (10052566) --------------------------------------------------------
#error "10052572: call analysis failed (funcsize=7)"

//----- (10052590) --------------------------------------------------------
int __usercall sub_10052590<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10017430(*(_DWORD *)(a3 - 16), a2);
}

//----- (10052598) --------------------------------------------------------
int __usercall sub_10052598<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A60(*(_DWORD *)(a2 - 16) + 248);
}

//----- (100525A6) --------------------------------------------------------
#error "100525B2: call analysis failed (funcsize=7)"

//----- (100525D0) --------------------------------------------------------
void __usercall sub_100525D0(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_10022654(*(_DWORD *)(a3 - 16), a2);
}

//----- (100525D8) --------------------------------------------------------
#error "100525E4: call analysis failed (funcsize=7)"

//----- (10052600) --------------------------------------------------------
void __cdecl sub_10052600()
{
  JUMPOUT(*(unsigned int *)loc_10018E80);
}
// 10018E80: using guessed type int loc_10018E80();

//----- (1005260B) --------------------------------------------------------
#error "10052617: call analysis failed (funcsize=7)"

//----- (10052630) --------------------------------------------------------
void __usercall sub_10052630(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_1001A2F0(*(_DWORD *)(a3 - 16) + 4, a2);
}

//----- (1005263B) --------------------------------------------------------
int __usercall sub_1005263B<eax>(int a1<ebp>)
{
  return j_nullsub_2(*(_DWORD *)(a1 - 16) + 24);
}
// 1001FEA0: using guessed type int __thiscall j_nullsub_2(_DWORD);

//----- (10052646) --------------------------------------------------------
int __usercall sub_10052646<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A60(*(_DWORD *)(a2 - 16) + 80);
}

//----- (10052651) --------------------------------------------------------
int __usercall sub_10052651<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A60(*(_DWORD *)(a2 - 16) + 104);
}

//----- (1005265C) --------------------------------------------------------
int __usercall sub_1005265C<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A60(*(_DWORD *)(a2 - 16) + 128);
}

//----- (1005266A) --------------------------------------------------------
#error "10052676: call analysis failed (funcsize=7)"

//----- (10052690) --------------------------------------------------------
void __cdecl sub_10052690()
{
  JUMPOUT(*(unsigned int *)loc_10017420);
}
// 10017420: using guessed type int loc_10017420();

//----- (10052698) --------------------------------------------------------
void __cdecl sub_10052698()
{
  JUMPOUT(loc_10018010);
}

//----- (100526A3) --------------------------------------------------------
void __usercall sub_100526A3(void *a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_100178D0((void *)(*(_DWORD *)(a3 - 16) + 24), a2);
}

//----- (100526AE) --------------------------------------------------------
int __usercall sub_100526AE<eax>(int a1<ebp>)
{
  return j_nullsub_2(*(_DWORD *)(a1 - 16) + 176);
}
// 1001FEA0: using guessed type int __thiscall j_nullsub_2(_DWORD);

//----- (100526BC) --------------------------------------------------------
#error "100526C8: call analysis failed (funcsize=7)"

//----- (100526E0) --------------------------------------------------------
int __usercall sub_100526E0<eax>(int a1<ebp>)
{
  return j_nullsub_2(*(_DWORD *)(a1 - 16));
}
// 1001FEA0: using guessed type int __thiscall j_nullsub_2(_DWORD);

//----- (100526E8) --------------------------------------------------------
void __cdecl sub_100526E8()
{
  JUMPOUT(*(unsigned int *)loc_10018E80);
}
// 10018E80: using guessed type int loc_10018E80();

//----- (100526F3) --------------------------------------------------------
#error "100526FF: call analysis failed (funcsize=7)"

//----- (10052710) --------------------------------------------------------
void __cdecl sub_10052710()
{
  JUMPOUT(*(unsigned int *)loc_100178B0);
}
// 100178B0: using guessed type int loc_100178B0();

//----- (10052718) --------------------------------------------------------
int __usercall sub_10052718<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100190E0((void *)(*(_DWORD *)(a2 - 16) + 4));
}

//----- (10052723) --------------------------------------------------------
void __usercall sub_10052723(void *a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_100178D0((void *)(*(_DWORD *)(a3 - 16) + 96), a2);
}

//----- (1005272E) --------------------------------------------------------
int __usercall sub_1005272E<eax>(int a1<ebp>)
{
  return j_nullsub_2(*(_DWORD *)(a1 - 20));
}
// 1001FEA0: using guessed type int __thiscall j_nullsub_2(_DWORD);

//----- (10052736) --------------------------------------------------------
void __cdecl sub_10052736()
{
  JUMPOUT(*(unsigned int *)loc_10018E80);
}
// 10018E80: using guessed type int loc_10018E80();

//----- (10052741) --------------------------------------------------------
#error "1005274D: call analysis failed (funcsize=7)"

//----- (10052760) --------------------------------------------------------
void __usercall sub_10052760(int this<ecx>, int a2<ebp>)
{
  sub_10028CE0(*(_DWORD *)(a2 - 20));
}

//----- (10052768) --------------------------------------------------------
void __usercall sub_10052768(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>)
{
  sub_10018130(*(_DWORD *)(a4 - 20) + 16, a2, a3);
}

//----- (10052773) --------------------------------------------------------
#error "1005277F: call analysis failed (funcsize=7)"

//----- (10052790) --------------------------------------------------------
int __usercall sub_10052790<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(*(_DWORD *)(a2 - 16));
}

//----- (10052798) --------------------------------------------------------
int __usercall sub_10052798<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(*(_DWORD *)(a2 - 16) + 24);
}

//----- (100527A3) --------------------------------------------------------
int __usercall sub_100527A3<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(*(_DWORD *)(a2 - 16) + 48);
}

//----- (100527AE) --------------------------------------------------------
int __usercall sub_100527AE<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(*(_DWORD *)(a2 - 16) + 88);
}

//----- (100527B9) --------------------------------------------------------
int __usercall sub_100527B9<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = *(_DWORD *)(a1 - 16) + 128;
  result = *(_DWORD *)(*(_DWORD *)(a1 - 16) + 156);
  if ( result )
  {
    result = sub_1002404A(*(LPVOID *)(*(_DWORD *)(a1 - 16) + 156));
    *(_DWORD *)(v2 + 28) = 0;
    *(_DWORD *)(v2 + 32) = 0;
    *(_DWORD *)(v2 + 36) = 0;
  }
  if ( *(_DWORD *)(v2 + 24) >= 0x10u )
    result = sub_1002404A(*(LPVOID *)(v2 + 4));
  *(_DWORD *)(v2 + 24) = 15;
  *(_DWORD *)(v2 + 20) = 0;
  *(_BYTE *)(v2 + 4) = 0;
  return result;
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (100527C7) --------------------------------------------------------
void __cdecl sub_100527C7()
{
  JUMPOUT(*(unsigned int *)loc_1000D4A0);
}
// 1000D4A0: using guessed type int loc_1000D4A0();

//----- (100527D5) --------------------------------------------------------
int __usercall sub_100527D5<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100170C0(*(_DWORD *)(a3 - 16) + 224, a2);
}

//----- (100527E3) --------------------------------------------------------
int __usercall sub_100527E3<eax>(int a1<ebp>)
{
  int result; // eax@2
  int v2; // ecx@1

  v2 = *(_DWORD *)(*(_DWORD *)(a1 - 16) + 496);
  if ( v2 )
    result = (**(int (__stdcall ***)(_DWORD))v2)(1);
  return result;
}

//----- (100527F1) --------------------------------------------------------
void __cdecl sub_100527F1()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (100527FF) --------------------------------------------------------
int __usercall sub_100527FF<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 16) + 508);
}
// 10024CC5: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005280D) --------------------------------------------------------
#error "10052819: call analysis failed (funcsize=7)"

//----- (10052830) --------------------------------------------------------
int __usercall sub_10052830<eax>(int a1<ebp>)
{
  return sub_10024C22(a1);
}

//----- (1005283B) --------------------------------------------------------
int __usercall sub_1005283B<eax>(int a1<ebp>)
{
  return sub_10024C22(a1);
}

//----- (10052846) --------------------------------------------------------
void __cdecl sub_10052846()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10052851) --------------------------------------------------------
int __usercall sub_10052851<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 16) + 100);
}
// 10024CC5: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005285C) --------------------------------------------------------
#error "10052868: call analysis failed (funcsize=7)"

//----- (10052880) --------------------------------------------------------
int __usercall sub_10052880<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 24));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (1005288B) --------------------------------------------------------
void __usercall sub_1005288B(int this<ecx>, int a2<ebp>)
{
  sub_10028CE0(*(_DWORD *)(a2 - 24));
}

//----- (10052893) --------------------------------------------------------
void __usercall sub_10052893(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>)
{
  sub_10018130(*(_DWORD *)(a4 - 24) + 16, a2, a3);
}

//----- (1005289E) --------------------------------------------------------
#error "100528AA: call analysis failed (funcsize=7)"

//----- (100528C0) --------------------------------------------------------
void __cdecl sub_100528C0()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (100528C8) --------------------------------------------------------
#error "100528D4: call analysis failed (funcsize=7)"

//----- (100528F0) --------------------------------------------------------
void __cdecl sub_100528F0()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (100528F8) --------------------------------------------------------
int __usercall sub_100528F8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 40, a2);
}

//----- (10052900) --------------------------------------------------------
int __usercall sub_10052900<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 80, a2);
}

//----- (10052908) --------------------------------------------------------
int __usercall sub_10052908<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 128, a2);
}

//----- (10052910) --------------------------------------------------------
int __usercall sub_10052910<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 112, a2);
}

//----- (10052918) --------------------------------------------------------
int __usercall sub_10052918<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 248);
}

//----- (10052923) --------------------------------------------------------
int __usercall sub_10052923<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 200);
}

//----- (1005292E) --------------------------------------------------------
int __usercall sub_1005292E<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 96, a2);
}

//----- (10052936) --------------------------------------------------------
int __usercall sub_10052936<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 296);
}

//----- (10052941) --------------------------------------------------------
int __usercall sub_10052941<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 152);
}

//----- (1005294C) --------------------------------------------------------
int __usercall sub_1005294C<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 176);
}

//----- (10052957) --------------------------------------------------------
int __usercall sub_10052957<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 224);
}

//----- (10052962) --------------------------------------------------------
int __usercall sub_10052962<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 272);
}

//----- (1005296D) --------------------------------------------------------
int __usercall sub_1005296D<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 320);
}

//----- (10052978) --------------------------------------------------------
#error "10052987: call analysis failed (funcsize=10)"

//----- (100529A0) --------------------------------------------------------
void __cdecl sub_100529A0()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (100529A8) --------------------------------------------------------
#error "100529B4: call analysis failed (funcsize=7)"

//----- (100529D0) --------------------------------------------------------
void __cdecl sub_100529D0()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (100529D8) --------------------------------------------------------
#error "100529E4: call analysis failed (funcsize=7)"

//----- (10052A00) --------------------------------------------------------
void __cdecl sub_10052A00()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10052A08) --------------------------------------------------------
#error "10052A14: call analysis failed (funcsize=7)"

//----- (10052A30) --------------------------------------------------------
void __cdecl sub_10052A30()
{
  sub_100242C1();
}

//----- (10052A38) --------------------------------------------------------
void __cdecl sub_10052A38()
{
  JUMPOUT(*(unsigned int *)loc_10001000);
}
// 10001000: using guessed type int loc_10001000();

//----- (10052A40) --------------------------------------------------------
#error "10052A4C: call analysis failed (funcsize=10)"

//----- (10052A70) --------------------------------------------------------
void __cdecl sub_10052A70()
{
  sub_100242C1();
}

//----- (10052A78) --------------------------------------------------------
void __cdecl sub_10052A78()
{
  JUMPOUT(*(unsigned int *)loc_10001000);
}
// 10001000: using guessed type int loc_10001000();

//----- (10052A80) --------------------------------------------------------
#error "10052A8C: call analysis failed (funcsize=10)"

//----- (10052AB0) --------------------------------------------------------
void __cdecl sub_10052AB0()
{
  sub_100242C1();
}

//----- (10052AB8) --------------------------------------------------------
void __cdecl sub_10052AB8()
{
  JUMPOUT(*(unsigned int *)loc_10001000);
}
// 10001000: using guessed type int loc_10001000();

//----- (10052AC0) --------------------------------------------------------
#error "10052ACC: call analysis failed (funcsize=10)"

//----- (10052AF0) --------------------------------------------------------
void __cdecl sub_10052AF0()
{
  sub_100242C1();
}

//----- (10052AF8) --------------------------------------------------------
void __cdecl sub_10052AF8()
{
  JUMPOUT(*(unsigned int *)loc_10001000);
}
// 10001000: using guessed type int loc_10001000();

//----- (10052B00) --------------------------------------------------------
#error "10052B0C: call analysis failed (funcsize=10)"

//----- (10052B30) --------------------------------------------------------
void __cdecl sub_10052B30()
{
  sub_100242C1();
}

//----- (10052B38) --------------------------------------------------------
void __cdecl sub_10052B38()
{
  JUMPOUT(*(unsigned int *)loc_10001000);
}
// 10001000: using guessed type int loc_10001000();

//----- (10052B40) --------------------------------------------------------
#error "10052B4C: call analysis failed (funcsize=10)"

//----- (10052B70) --------------------------------------------------------
void __cdecl sub_10052B70()
{
  sub_100242C1();
}

//----- (10052B78) --------------------------------------------------------
void __cdecl sub_10052B78()
{
  JUMPOUT(*(unsigned int *)loc_10001000);
}
// 10001000: using guessed type int loc_10001000();

//----- (10052B80) --------------------------------------------------------
#error "10052B8C: call analysis failed (funcsize=10)"

//----- (10052BB0) --------------------------------------------------------
int __usercall sub_10052BB0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>)
{
  return sub_10020EB0(*(_DWORD *)(a4 - 16), a2, a3);
}

//----- (10052BB8) --------------------------------------------------------
#error "10052BC4: call analysis failed (funcsize=7)"

//----- (10052BE0) --------------------------------------------------------
void __usercall sub_10052BE0(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = &off_1005D1A8;
}
// 1005D1A8: using guessed type int (__stdcall *off_1005D1A8)(char);

//----- (10052BE8) --------------------------------------------------------
#error "10052BF4: call analysis failed (funcsize=7)"

//----- (10052C10) --------------------------------------------------------
int __usercall sub_10052C10<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10020640(*(_DWORD *)(a2 - 16));
}

//----- (10052C18) --------------------------------------------------------
#error "10052C24: call analysis failed (funcsize=7)"

//----- (10052C40) --------------------------------------------------------
int __usercall sub_10052C40<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10001500((void *)(a2 + 16));
}

//----- (10052C48) --------------------------------------------------------
void __cdecl sub_10052C48()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10052C50) --------------------------------------------------------
int __usercall sub_10052C50<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 28) & 1;
  if ( *(_DWORD *)(a1 - 28) & 1 )
  {
    *(_DWORD *)(a1 - 28) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_10001870);
  }
  return result;
}
// 10001870: using guessed type int loc_10001870();

//----- (10052C69) --------------------------------------------------------
#error "10052C75: call analysis failed (funcsize=10)"

//----- (10052C90) --------------------------------------------------------
int __usercall sub_10052C90<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 + 64);
}

//----- (10052C98) --------------------------------------------------------
int __usercall sub_10052C98<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 + 40);
}

//----- (10052CA0) --------------------------------------------------------
int __usercall sub_10052CA0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 + 16);
}

//----- (10052CA8) --------------------------------------------------------
void __cdecl sub_10052CA8()
{
  sub_100242C1();
}

//----- (10052CB0) --------------------------------------------------------
#error "10052CBC: call analysis failed (funcsize=10)"

//----- (10052CE0) --------------------------------------------------------
void __cdecl sub_10052CE0()
{
  JUMPOUT(*(unsigned int *)loc_10001000);
}
// 10001000: using guessed type int loc_10001000();

//----- (10052CE8) --------------------------------------------------------
#error "10052CF4: call analysis failed (funcsize=7)"

//----- (10052D10) --------------------------------------------------------
void __cdecl sub_10052D10()
{
  JUMPOUT(*(unsigned int *)loc_10020730);
}
// 10020730: using guessed type int loc_10020730();

//----- (10052D18) --------------------------------------------------------
#error "10052D24: call analysis failed (funcsize=11)"

//----- (10052D40) --------------------------------------------------------
int __usercall sub_10052D40<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10004BD0(a2 - 136);
}

//----- (10052D4B) --------------------------------------------------------
int __usercall sub_10052D4B<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 152, a2);
}

//----- (10052D56) --------------------------------------------------------
int __usercall sub_10052D56<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 176, a2);
}

//----- (10052D61) --------------------------------------------------------
int __usercall sub_10052D61<eax>(int a1<ebp>)
{
  return sub_10001B10(a1 - 176);
}
// 10001B10: using guessed type int __thiscall sub_10001B10(_DWORD);

//----- (10052D6C) --------------------------------------------------------
#error "10052D7E: call analysis failed (funcsize=11)"

//----- (10052DA0) --------------------------------------------------------
int __usercall sub_10052DA0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 52, a2);
}

//----- (10052DA8) --------------------------------------------------------
int __usercall sub_10052DA8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 36, a2);
}

//----- (10052DB0) --------------------------------------------------------
int __usercall sub_10052DB0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 36, a2);
}

//----- (10052DB8) --------------------------------------------------------
int __usercall sub_10052DB8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 36, a2);
}

//----- (10052DC0) --------------------------------------------------------
int __usercall sub_10052DC0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 36, a2);
}

//----- (10052DC8) --------------------------------------------------------
int __usercall sub_10052DC8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 36, a2);
}

//----- (10052DD0) --------------------------------------------------------
int __usercall sub_10052DD0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 36, a2);
}

//----- (10052DD8) --------------------------------------------------------
int __usercall sub_10052DD8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 36, a2);
}

//----- (10052DE0) --------------------------------------------------------
int __usercall sub_10052DE0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 36, a2);
}

//----- (10052DE8) --------------------------------------------------------
int __usercall sub_10052DE8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 36, a2);
}

//----- (10052DF0) --------------------------------------------------------
int __usercall sub_10052DF0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 36, a2);
}

//----- (10052DF8) --------------------------------------------------------
int __usercall sub_10052DF8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(*(_DWORD *)(a3 - 72), a2);
}

//----- (10052E00) --------------------------------------------------------
void __cdecl sub_10052E00()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10052E08) --------------------------------------------------------
int __usercall sub_10052E08<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 64) & 1;
  if ( *(_DWORD *)(a1 - 64) & 1 )
  {
    *(_DWORD *)(a1 - 64) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_10001870);
  }
  return result;
}
// 10001870: using guessed type int loc_10001870();

//----- (10052E21) --------------------------------------------------------
#error "10052E2D: call analysis failed (funcsize=10)"

//----- (10052E50) --------------------------------------------------------
void __cdecl sub_10052E50()
{
  sub_100242C1();
}

//----- (10052E58) --------------------------------------------------------
void __cdecl sub_10052E58()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10052E60) --------------------------------------------------------
#error "10052E6C: call analysis failed (funcsize=11)"

//----- (10052E90) --------------------------------------------------------
void __cdecl sub_10052E90()
{
  sub_100242C1();
}

//----- (10052E98) --------------------------------------------------------
#error "10052EA4: call analysis failed (funcsize=10)"

//----- (10052EC0) --------------------------------------------------------
void __cdecl sub_10052EC0()
{
  sub_100242C1();
}

//----- (10052EC8) --------------------------------------------------------
void __cdecl sub_10052EC8()
{
  JUMPOUT(*(unsigned int *)loc_10001B70);
}
// 10001B70: using guessed type int loc_10001B70();

//----- (10052ED0) --------------------------------------------------------
int __usercall sub_10052ED0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A60(a2 - 72);
}

//----- (10052ED8) --------------------------------------------------------
#error "10052EE4: call analysis failed (funcsize=11)"

//----- (10052F00) --------------------------------------------------------
int __usercall sub_10052F00<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10019AA0((void *)(a2 - 64));
}

//----- (10052F08) --------------------------------------------------------
void __cdecl sub_10052F08()
{
  sub_100242C1();
}

//----- (10052F10) --------------------------------------------------------
#error "10052F1C: call analysis failed (funcsize=10)"

//----- (10052F40) --------------------------------------------------------
void __cdecl sub_10052F40()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10052F48) --------------------------------------------------------
void __cdecl sub_10052F48()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10052F50) --------------------------------------------------------
#error "10052F5C: call analysis failed (funcsize=7)"

//----- (10052F70) --------------------------------------------------------
void __cdecl sub_10052F70()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10052F78) --------------------------------------------------------
void __cdecl sub_10052F78()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10052F80) --------------------------------------------------------
void __cdecl sub_10052F80()
{
  JUMPOUT(*(unsigned int *)loc_10001B70);
}
// 10001B70: using guessed type int loc_10001B70();

//----- (10052F88) --------------------------------------------------------
int __usercall sub_10052F88<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A60(a2 - 72);
}

//----- (10052F90) --------------------------------------------------------
void __cdecl sub_10052F90()
{
  sub_100242C1();
}

//----- (10052F98) --------------------------------------------------------
#error "10052FA4: call analysis failed (funcsize=11)"

//----- (10052FC0) --------------------------------------------------------
void __cdecl sub_10052FC0()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10052FC8) --------------------------------------------------------
void __cdecl sub_10052FC8()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10052FD0) --------------------------------------------------------
void __cdecl sub_10052FD0()
{
  JUMPOUT(*(unsigned int *)loc_10001B70);
}
// 10001B70: using guessed type int loc_10001B70();

//----- (10052FD8) --------------------------------------------------------
int __usercall sub_10052FD8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A60(a2 - 72);
}

//----- (10052FE0) --------------------------------------------------------
void __cdecl sub_10052FE0()
{
  sub_100242C1();
}

//----- (10052FE8) --------------------------------------------------------
#error "10052FF4: call analysis failed (funcsize=11)"

//----- (10053010) --------------------------------------------------------
void __cdecl sub_10053010()
{
  JUMPOUT(*(unsigned int *)loc_10001B70);
}
// 10001B70: using guessed type int loc_10001B70();

//----- (10053018) --------------------------------------------------------
int __usercall sub_10053018<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A60(a2 - 80);
}

//----- (10053020) --------------------------------------------------------
void __cdecl sub_10053020()
{
  sub_100242C1();
}

//----- (10053028) --------------------------------------------------------
#error "10053034: call analysis failed (funcsize=11)"

//----- (10053050) --------------------------------------------------------
int __thiscall sub_10053050(void *this)
{
  return nullsub_3(this);
}
// 100010B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (10053061) --------------------------------------------------------
void __cdecl sub_10053061()
{
  JUMPOUT(*(unsigned int *)loc_1001D620);
}
// 1001D620: using guessed type int loc_1001D620();

//----- (10053069) --------------------------------------------------------
void __cdecl sub_10053069()
{
  JUMPOUT(*(unsigned int *)loc_10001B70);
}
// 10001B70: using guessed type int loc_10001B70();

//----- (10053071) --------------------------------------------------------
#error "1005307D: call analysis failed (funcsize=7)"

//----- (10053090) --------------------------------------------------------
#error "1005309C: call analysis failed (funcsize=7)"

//----- (100530B0) --------------------------------------------------------
int __usercall sub_100530B0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 + 8, a2);
}

//----- (100530B8) --------------------------------------------------------
void __cdecl sub_100530B8()
{
  sub_100242C1();
}

//----- (100530C0) --------------------------------------------------------
#error "100530CC: call analysis failed (funcsize=10)"

//----- (100530F0) --------------------------------------------------------
void __cdecl sub_100530F0()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (100530F8) --------------------------------------------------------
#error "10053104: call analysis failed (funcsize=7)"

//----- (10053120) --------------------------------------------------------
int __usercall sub_10053120<eax>(int a1<ebp>)
{
  return sub_100204A0(*(_DWORD *)(a1 - 16));
}
// 100204A0: using guessed type _DWORD __cdecl sub_100204A0(_DWORD);

//----- (1005312B) --------------------------------------------------------
#error "10053137: call analysis failed (funcsize=7)"

//----- (10053150) --------------------------------------------------------
int __usercall sub_10053150<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A60(a2 + 8);
}

//----- (10053158) --------------------------------------------------------
void __cdecl sub_10053158()
{
  JUMPOUT(*(unsigned int *)loc_10001B70);
}
// 10001B70: using guessed type int loc_10001B70();

//----- (10053160) --------------------------------------------------------
#error "1005316C: call analysis failed (funcsize=7)"

//----- (10053180) --------------------------------------------------------
int __usercall sub_10053180<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A60(a2 + 8);
}

//----- (10053188) --------------------------------------------------------
#error "10053194: call analysis failed (funcsize=7)"

//----- (100531B0) --------------------------------------------------------
void __cdecl sub_100531B0()
{
  sub_100242C1();
}

//----- (100531B8) --------------------------------------------------------
#error "100531C4: call analysis failed (funcsize=10)"

//----- (100531E0) --------------------------------------------------------
void __cdecl sub_100531E0()
{
  JUMPOUT(*(unsigned int *)loc_10001000);
}
// 10001000: using guessed type int loc_10001000();

//----- (100531E8) --------------------------------------------------------
#error "100531F4: call analysis failed (funcsize=7)"

//----- (10053210) --------------------------------------------------------
void __cdecl sub_10053210()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10053218) --------------------------------------------------------
void __cdecl sub_10053218()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10053220) --------------------------------------------------------
void __cdecl sub_10053220()
{
  JUMPOUT(*(unsigned int *)loc_10001870);
}
// 10001870: using guessed type int loc_10001870();

//----- (10053228) --------------------------------------------------------
#error "10053234: call analysis failed (funcsize=10)"

//----- (10053250) --------------------------------------------------------
void __cdecl sub_10053250()
{
  JUMPOUT(*(unsigned int *)loc_100013D0);
}
// 100013D0: using guessed type int loc_100013D0();

//----- (10053258) --------------------------------------------------------
int __usercall sub_10053258<eax>(int a1<ebp>)
{
  return sub_1002404A(*(LPVOID *)(a1 - 20));
}
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);

//----- (10053263) --------------------------------------------------------
int __usercall sub_10053263<eax>(int a1<ebp>)
{
  int result; // eax@2
  int v2; // ecx@1
  int v3; // ecx@1
  int v4; // esi@1

  v3 = *(_DWORD *)(a1 - 24);
  v4 = v3;
  v2 = *(_DWORD *)(v3 + 16);
  if ( v2 )
  {
    result = (*(int (__stdcall **)(bool))(*(_DWORD *)v2 + 16))(v2 != v4);
    *(_DWORD *)(v4 + 16) = 0;
  }
  return result;
}

//----- (1005326B) --------------------------------------------------------
#error "10053277: call analysis failed (funcsize=7)"

//----- (10053290) --------------------------------------------------------
void __cdecl sub_10053290()
{
  sub_100242C1();
}

//----- (10053298) --------------------------------------------------------
#error "100532A4: call analysis failed (funcsize=10)"

//----- (100532C0) --------------------------------------------------------
void __cdecl sub_100532C0()
{
  JUMPOUT(*(unsigned int *)loc_10001000);
}
// 10001000: using guessed type int loc_10001000();

//----- (100532C8) --------------------------------------------------------
#error "100532D4: call analysis failed (funcsize=10)"

//----- (100532F0) --------------------------------------------------------
void __usercall sub_100532F0(void *this<ecx>, int a2<ebp>)
{
  sub_100242BA((void *)(a2 - 56));
}

//----- (100532F8) --------------------------------------------------------
#error "10053304: call analysis failed (funcsize=10)"

//----- (10053320) --------------------------------------------------------
void __cdecl sub_10053320()
{
  JUMPOUT(*(unsigned int *)loc_100013D0);
}
// 100013D0: using guessed type int loc_100013D0();

//----- (10053328) --------------------------------------------------------
void __cdecl sub_10053328()
{
  JUMPOUT(*(unsigned int *)loc_10001000);
}
// 10001000: using guessed type int loc_10001000();

//----- (10053330) --------------------------------------------------------
#error "1005333C: call analysis failed (funcsize=7)"

//----- (10053350) --------------------------------------------------------
int __usercall sub_10053350<eax>(int a1<ebp>)
{
  return sub_100204A0(*(_DWORD *)(a1 + 8));
}
// 100204A0: using guessed type _DWORD __cdecl sub_100204A0(_DWORD);

//----- (1005335B) --------------------------------------------------------
#error "10053367: call analysis failed (funcsize=7)"

//----- (10053380) --------------------------------------------------------
int __usercall sub_10053380<eax>(int a1<ebp>)
{
  return sub_100204A0(*(_DWORD *)(a1 - 48));
}
// 100204A0: using guessed type _DWORD __cdecl sub_100204A0(_DWORD);

//----- (1005338B) --------------------------------------------------------
void __usercall sub_1005338B(void *this<ecx>, int a2<ebp>)
{
  sub_100242BA((void *)(a2 - 44));
}

//----- (10053393) --------------------------------------------------------
#error "1005339F: call analysis failed (funcsize=10)"

//----- (100533C0) --------------------------------------------------------
void __cdecl sub_100533C0()
{
  JUMPOUT(*(unsigned int *)loc_10018E80);
}
// 10018E80: using guessed type int loc_10018E80();

//----- (100533CB) --------------------------------------------------------
#error "100533D7: call analysis failed (funcsize=7)"

//----- (100533F0) --------------------------------------------------------
void __usercall sub_100533F0(void *this<ecx>, int a2<ebp>)
{
  sub_100242BA((void *)(a2 - 44));
}

//----- (100533F8) --------------------------------------------------------
#error "10053404: call analysis failed (funcsize=10)"

//----- (10053420) --------------------------------------------------------
int __usercall sub_10053420<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A60(a2 - 40);
}

//----- (10053428) --------------------------------------------------------
void __cdecl sub_10053428()
{
  JUMPOUT(*(unsigned int *)loc_10001B70);
}
// 10001B70: using guessed type int loc_10001B70();

//----- (10053430) --------------------------------------------------------
int __usercall sub_10053430<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A60(a2 - 64);
}

//----- (10053438) --------------------------------------------------------
#error "10053444: call analysis failed (funcsize=7)"

//----- (10053460) --------------------------------------------------------
void __cdecl sub_10053460()
{
  JUMPOUT(*(unsigned int *)loc_10001B70);
}
// 10001B70: using guessed type int loc_10001B70();

//----- (10053468) --------------------------------------------------------
int __usercall sub_10053468<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A60(a2 - 40);
}

//----- (10053470) --------------------------------------------------------
#error "1005347C: call analysis failed (funcsize=7)"

//----- (10053490) --------------------------------------------------------
void __cdecl sub_10053490()
{
  JUMPOUT(*(unsigned int *)loc_10001B70);
}
// 10001B70: using guessed type int loc_10001B70();

//----- (10053498) --------------------------------------------------------
int __usercall sub_10053498<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A60(a2 - 40);
}

//----- (100534A0) --------------------------------------------------------
#error "100534AC: call analysis failed (funcsize=7)"

//----- (100534C0) --------------------------------------------------------
void __usercall sub_100534C0(void *this<ecx>, int a2<ebp>)
{
  sub_100242BA((void *)(a2 - 44));
}

//----- (100534C8) --------------------------------------------------------
#error "100534D4: call analysis failed (funcsize=10)"

//----- (100534F0) --------------------------------------------------------
void __usercall sub_100534F0(void *this<ecx>, int a2<ebp>)
{
  sub_100242BA((void *)(a2 - 44));
}

//----- (100534F8) --------------------------------------------------------
#error "10053504: call analysis failed (funcsize=10)"

//----- (10053520) --------------------------------------------------------
int __usercall sub_10053520<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = a1 - 56;
  result = *(_DWORD *)(a1 - 56);
  if ( *(_DWORD *)(a1 - 56) )
  {
    result = sub_1002401B(*(LPVOID *)(a1 - 56));
    *(_DWORD *)v2 = 0;
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
  }
  return result;
}
// 1002401B: using guessed type _DWORD __cdecl sub_1002401B(LPVOID lpMem);

//----- (10053528) --------------------------------------------------------
#error "10053534: call analysis failed (funcsize=10)"

//----- (10053550) --------------------------------------------------------
void __usercall sub_10053550(void *this<ecx>, int a2<ebp>)
{
  sub_100242BA((void *)(a2 - 44));
}

//----- (10053558) --------------------------------------------------------
#error "10053564: call analysis failed (funcsize=10)"

//----- (10053580) --------------------------------------------------------
void __usercall sub_10053580(void *this<ecx>, int a2<ebp>)
{
  sub_100242BA((void *)(a2 - 44));
}

//----- (10053588) --------------------------------------------------------
#error "10053594: call analysis failed (funcsize=10)"

//----- (100535B0) --------------------------------------------------------
void __cdecl sub_100535B0()
{
  JUMPOUT(*(unsigned int *)loc_10001000);
}
// 10001000: using guessed type int loc_10001000();

//----- (100535B8) --------------------------------------------------------
#error "100535C4: call analysis failed (funcsize=7)"

//----- (100535E0) --------------------------------------------------------
int __usercall sub_100535E0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 + 8, a2);
}

//----- (100535E8) --------------------------------------------------------
int __usercall sub_100535E8<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10019AA0((void *)(a2 - 64));
}

//----- (100535F0) --------------------------------------------------------
void __cdecl sub_100535F0()
{
  sub_100242C1();
}

//----- (100535F8) --------------------------------------------------------
int __usercall sub_100535F8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10004F60(a3 - 80, a2);
}

//----- (10053600) --------------------------------------------------------
void __cdecl sub_10053600()
{
  sub_100242C1();
}

//----- (10053608) --------------------------------------------------------
#error "10053614: call analysis failed (funcsize=10)"

//----- (10053630) --------------------------------------------------------
void __cdecl sub_10053630()
{
  JUMPOUT(*(unsigned int *)loc_10001000);
}
// 10001000: using guessed type int loc_10001000();

//----- (10053638) --------------------------------------------------------
void __cdecl sub_10053638()
{
  JUMPOUT(*(unsigned int *)loc_10001000);
}
// 10001000: using guessed type int loc_10001000();

//----- (10053640) --------------------------------------------------------
#error "1005364C: call analysis failed (funcsize=7)"

//----- (10053660) --------------------------------------------------------
int __usercall sub_10053660<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10019710(a2 - 44);
}

//----- (10053668) --------------------------------------------------------
void __cdecl sub_10053668()
{
  JUMPOUT(*(unsigned int *)loc_10018E80);
}
// 10018E80: using guessed type int loc_10018E80();

//----- (10053670) --------------------------------------------------------
#error "1005367C: call analysis failed (funcsize=10)"

//----- (100536A0) --------------------------------------------------------
void __usercall sub_100536A0(void *this<ecx>, int a2<ebp>)
{
  sub_100242BA((void *)(a2 - 56));
}

//----- (100536A8) --------------------------------------------------------
#error "100536B4: call analysis failed (funcsize=10)"

//----- (100536D0) --------------------------------------------------------
void __cdecl sub_100536D0()
{
  sub_100242C1();
}

//----- (100536D8) --------------------------------------------------------
#error "100536E4: call analysis failed (funcsize=11)"

//----- (10053700) --------------------------------------------------------
int __usercall sub_10053700<eax>(int a1<ebp>)
{
  return sub_10001B10(a1 + 8);
}
// 10001B10: using guessed type int __thiscall sub_10001B10(_DWORD);

//----- (10053708) --------------------------------------------------------
#error "10053714: call analysis failed (funcsize=7)"

//----- (10053730) --------------------------------------------------------
int __usercall sub_10053730<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 40);
}

//----- (10053738) --------------------------------------------------------
#error "10053744: call analysis failed (funcsize=7)"

//----- (10053760) --------------------------------------------------------
int __usercall sub_10053760<eax>(int a1<ebp>)
{
  return sub_10024C22(a1);
}

//----- (1005376B) --------------------------------------------------------
int __usercall sub_1005376B<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(*(_DWORD *)(a2 - 16) + 56);
}

//----- (10053776) --------------------------------------------------------
#error "10053782: call analysis failed (funcsize=7)"

//----- (100537A0) --------------------------------------------------------
void __cdecl sub_100537A0()
{
  JUMPOUT(*(unsigned int *)loc_10020730);
}
// 10020730: using guessed type int loc_10020730();

//----- (100537A8) --------------------------------------------------------
void __cdecl sub_100537A8()
{
  JUMPOUT(*(unsigned int *)loc_10020730);
}
// 10020730: using guessed type int loc_10020730();

//----- (100537B3) --------------------------------------------------------
#error "100537C2: call analysis failed (funcsize=10)"

//----- (100537E0) --------------------------------------------------------
int __usercall sub_100537E0<eax>(int a1<ebp>)
{
  return sub_10001B10(a1 - 124);
}
// 10001B10: using guessed type int __thiscall sub_10001B10(_DWORD);

//----- (100537E8) --------------------------------------------------------
int __usercall sub_100537E8<eax>(int a1<ebp>)
{
  return sub_10001B10(a1 - 64);
}
// 10001B10: using guessed type int __thiscall sub_10001B10(_DWORD);

//----- (100537F0) --------------------------------------------------------
int __usercall sub_100537F0<eax>(int a1<ebp>)
{
  return sub_10001B10(a1 - 144);
}
// 10001B10: using guessed type int __thiscall sub_10001B10(_DWORD);

//----- (100537FB) --------------------------------------------------------
int __usercall sub_100537FB<eax>(int a1<ebp>)
{
  return sub_10001B10(a1 - 84);
}
// 10001B10: using guessed type int __thiscall sub_10001B10(_DWORD);

//----- (10053803) --------------------------------------------------------
int __usercall sub_10053803<eax>(int a1<ebp>)
{
  return sub_10001B10(a1 - 44);
}
// 10001B10: using guessed type int __thiscall sub_10001B10(_DWORD);

//----- (1005380B) --------------------------------------------------------
int __usercall sub_1005380B<eax>(int a1<ebp>)
{
  return sub_10001B10(a1 - 104);
}
// 10001B10: using guessed type int __thiscall sub_10001B10(_DWORD);

//----- (10053813) --------------------------------------------------------
#error "10053825: call analysis failed (funcsize=11)"

//----- (10053850) --------------------------------------------------------
int __usercall sub_10053850<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 24) & 1;
  if ( *(_DWORD *)(a2 - 24) & 1 )
  {
    *(_DWORD *)(a2 - 24) &= 0xFFFFFFFEu;
    result = sub_10001A30(*(_DWORD *)(a2 - 52));
  }
  return result;
}

//----- (10053869) --------------------------------------------------------
#error "10053875: call analysis failed (funcsize=10)"

//----- (10053890) --------------------------------------------------------
void __cdecl sub_10053890()
{
  sub_100242C1();
}

//----- (10053898) --------------------------------------------------------
#error "100538A4: call analysis failed (funcsize=10)"

//----- (100538C0) --------------------------------------------------------
int __usercall sub_100538C0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001A30(a2 - 40);
}

//----- (100538C8) --------------------------------------------------------
#error "100538D4: call analysis failed (funcsize=7)"

//----- (100538F0) --------------------------------------------------------
int __usercall sub_100538F0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v4; // edx@1
  int v5; // ecx@1

  sub_100018B0(a1, a1);
  sub_10015CB0(a2, a3);
  return sub_10024006(v4, v5, a2, a3, sub_10053B00);
}
// 10053B00: using guessed type int sub_10053B00();

//----- (10053910) --------------------------------------------------------
int __usercall sub_10053910<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  return sub_10024006(a1, a2, a3, a4, sub_10053B30);
}
// 10053B30: using guessed type int sub_10053B30();

//----- (10053920) --------------------------------------------------------
int __usercall sub_10053920<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  return sub_10024006(a1, a2, a3, a4, sub_10053B20);
}
// 10053B20: using guessed type int sub_10053B20();

//----- (10053930) --------------------------------------------------------
int __usercall sub_10053930<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  return sub_10024006(a1, a2, a3, a4, sub_10053B10);
}

//----- (10053940) --------------------------------------------------------
int __usercall sub_10053940<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  dword_1006A338 &= 0xFFFFFE00u;
  return sub_10024006(a1, a2, a3, a4, sub_10053B40);
}
// 10053B40: using guessed type int sub_10053B40();
// 1006A338: using guessed type int dword_1006A338;

//----- (10053960) --------------------------------------------------------
int __usercall sub_10053960<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  loc_10001BD0(&dword_10068E30, "\\[(b|i|url)\\](.+?)\\[/\\1\\]", 25);
  return sub_10024006(v3, v4, a1, a2, sub_10053B50);
}
// 10068E30: using guessed type int dword_10068E30;

//----- (10053980) --------------------------------------------------------
int __usercall sub_10053980<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  loc_10001BD0(&dword_10068E48, "Ycombination", 12);
  return sub_10024006(v3, v4, a1, a2, sub_10053BB0);
}
// 10068E48: using guessed type int dword_10068E48;

//----- (100539A0) --------------------------------------------------------
int __usercall sub_100539A0<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  loc_10001BD0(&dword_10068E78, "1.00", 4);
  return sub_10024006(v3, v4, a1, a2, sub_10053C10);
}
// 10068E78: using guessed type int dword_10068E78;

//----- (100539C0) --------------------------------------------------------
int __usercall sub_100539C0<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  loc_10020AC0(&dword_10068E60, L"http://forexsensation.com/access", 32);
  return sub_10024006(v3, v4, a1, a2, sub_10053C70);
}
// 1005C928: using guessed type wchar_t aHttpForexsensa[33];
// 10068E60: using guessed type int dword_10068E60;

//----- (100539E0) --------------------------------------------------------
int __usercall sub_100539E0<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  loc_10020AC0(&pszAgentW, L"Client", 6);
  return sub_10024006(v3, v4, a1, a2, sub_10053CD0);
}
// 1005D2C4: using guessed type wchar_t aClient[7];

//----- (10053A00) --------------------------------------------------------
int __usercall sub_10053A00<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  dword_1006A35C = 0;
  dword_1006A360 = 0;
  hInternet = 0;
  sub_10024232((int)&unk_1006A344);
  __asm
  {
    xorps   xmm0, xmm0
    movq    qword ptr pProxyConfig.fAutoDetect, xmm0
    movq    qword ptr pProxyConfig.lpszProxy, xmm0
  }
  return sub_10024006(v3, v4, a1, a2, sub_10053D30);
}
// 1006A35C: using guessed type int dword_1006A35C;
// 1006A360: using guessed type int dword_1006A360;

//----- (10053A47) --------------------------------------------------------
int __usercall sub_10053A47<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  return sub_10024006(a1, a2, a3, a4, sub_10053D80);
}
// 10053D80: using guessed type int sub_10053D80();

//----- (10053A53) --------------------------------------------------------
int __usercall sub_10053A53<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  return sub_10024006(a1, a2, a3, a4, sub_10053D8A);
}
// 10053D8A: using guessed type int sub_10053D8A();

//----- (10053A5F) --------------------------------------------------------
int __usercall sub_10053A5F<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  sub_100220DC(&unk_10068F38);
  return sub_10024006(v3, v4, a1, a2, sub_10053D94);
}
// 10053D94: using guessed type int sub_10053D94();

//----- (10053A75) --------------------------------------------------------
int __usercall sub_10053A75<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  return sub_10024006(a1, a2, a3, a4, sub_10053D9E);
}
// 10053D9E: using guessed type int sub_10053D9E();

//----- (10053A81) --------------------------------------------------------
int __usercall sub_10053A81<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  sub_100220DC(&unk_10068FF8);
  return sub_10024006(v3, v4, a1, a2, sub_10053DA8);
}
// 10053DA8: using guessed type int sub_10053DA8();

//----- (10053A97) --------------------------------------------------------
int __usercall sub_10053A97<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  sub_10023294(&dword_10069098);
  return sub_10024006(v3, v4, a1, a2, sub_10053DB2);
}
// 10023294: using guessed type int __cdecl sub_10023294(_DWORD);
// 10053DB2: using guessed type int sub_10053DB2();
// 10069098: using guessed type int dword_10069098;

//----- (10053AAF) --------------------------------------------------------
void **__cdecl sub_10053AAF()
{
  void **result; // eax@1

  result = sub_1003D94D() + 16;
  dword_1006944C = (int)result;
  return result;
}
// 1006944C: using guessed type int dword_1006944C;

//----- (10053ABD) --------------------------------------------------------
unsigned int __cdecl sub_10053ABD()
{
  unsigned int result; // eax@1

  result = sub_1002C3E7();
  dword_10069CB8 = result;
  return result;
}
// 10069CB8: using guessed type int dword_10069CB8;

//----- (10053AC8) --------------------------------------------------------
void __cdecl sub_10053AC8()
{
  dword_10069CB0 = 0;
}
// 10069CB0: using guessed type int dword_10069CB0;

//----- (10053AD3) --------------------------------------------------------
void __cdecl sub_10053AD3()
{
  dword_10069CA8 = 0;
}
// 10069CA8: using guessed type int dword_10069CA8;

//----- (10053ADE) --------------------------------------------------------
void __cdecl sub_10053ADE()
{
  dword_10069CB4 = 0;
}
// 10069CB4: using guessed type int dword_10069CB4;

//----- (10053AE9) --------------------------------------------------------
void __cdecl sub_10053AE9()
{
  dword_10069CAC = 0;
}
// 10069CAC: using guessed type int dword_10069CAC;

//----- (10053AF4) --------------------------------------------------------
void __cdecl sub_10053AF4()
{
  InitializeSListHead(&ListHead);
}

//----- (10053B10) --------------------------------------------------------
void __cdecl sub_10053B10()
{
  off_10068E24[0] = (int (__stdcall *)(char))&off_1005431C;
}
// 1005431C: using guessed type int (__stdcall *off_1005431C)(char);
// 10068E24: using guessed type int (__stdcall *off_10068E24[3])(char);

//----- (10053B50) --------------------------------------------------------
int __cdecl sub_10053B50()
{
  int result; // eax@2
  void *v1; // esi@2
  char v2; // [sp+1h] [bp-1h]@2

  if ( (unsigned int)dword_10068E44 >= 0x10 )
  {
    v1 = (void *)dword_10068E30;
    sub_10001D00(&v2);
    nullsub_1(&dword_10068E30);
    sub_10001D00(&v2);
    result = sub_1002404A(v1);
  }
  dword_10068E44 = 15;
  dword_10068E40 = 0;
  LOBYTE(dword_10068E30) = 0;
  return result;
}
// 100021E0: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10068E30: using guessed type int dword_10068E30;
// 10068E40: using guessed type int dword_10068E40;
// 10068E44: using guessed type int dword_10068E44;

//----- (10053BB0) --------------------------------------------------------
int __cdecl sub_10053BB0()
{
  int result; // eax@2
  void *v1; // esi@2
  char v2; // [sp+1h] [bp-1h]@2

  if ( (unsigned int)dword_10068E5C >= 0x10 )
  {
    v1 = (void *)dword_10068E48;
    sub_10001D00(&v2);
    nullsub_1(&dword_10068E48);
    sub_10001D00(&v2);
    result = sub_1002404A(v1);
  }
  dword_10068E5C = 15;
  dword_10068E58 = 0;
  LOBYTE(dword_10068E48) = 0;
  return result;
}
// 100021E0: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10068E48: using guessed type int dword_10068E48;
// 10068E58: using guessed type int dword_10068E58;
// 10068E5C: using guessed type int dword_10068E5C;

//----- (10053C10) --------------------------------------------------------
int __cdecl sub_10053C10()
{
  int result; // eax@2
  void *v1; // esi@2
  char v2; // [sp+1h] [bp-1h]@2

  if ( (unsigned int)dword_10068E8C >= 0x10 )
  {
    v1 = (void *)dword_10068E78;
    sub_10001D00(&v2);
    nullsub_1(&dword_10068E78);
    sub_10001D00(&v2);
    result = sub_1002404A(v1);
  }
  dword_10068E8C = 15;
  dword_10068E88 = 0;
  LOBYTE(dword_10068E78) = 0;
  return result;
}
// 100021E0: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10068E78: using guessed type int dword_10068E78;
// 10068E88: using guessed type int dword_10068E88;
// 10068E8C: using guessed type int dword_10068E8C;

//----- (10053C70) --------------------------------------------------------
int __cdecl sub_10053C70()
{
  void *v0; // esi@2
  int result; // eax@3
  char v2; // [sp+1h] [bp-1h]@2

  if ( (unsigned int)dword_10068E74 >= 8 )
  {
    v0 = (void *)dword_10068E60;
    sub_10001D00(&v2);
    nullsub_1(&dword_10068E60);
    sub_10001D00(&v2);
    sub_1002404A(v0);
  }
  result = 0;
  dword_10068E74 = 7;
  dword_10068E70 = 0;
  LOWORD(dword_10068E60) = 0;
  return result;
}
// 100021E0: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10068E60: using guessed type int dword_10068E60;
// 10068E70: using guessed type int dword_10068E70;
// 10068E74: using guessed type int dword_10068E74;

//----- (10053CD0) --------------------------------------------------------
int __cdecl sub_10053CD0()
{
  LPCWSTR v0; // esi@2
  int result; // eax@3
  char v2; // [sp+1h] [bp-1h]@2

  if ( (unsigned int)dword_10068EA4 >= 8 )
  {
    v0 = pszAgentW;
    sub_10001D00(&v2);
    nullsub_1(&pszAgentW);
    sub_10001D00(&v2);
    sub_1002404A((LPVOID)v0);
  }
  result = 0;
  dword_10068EA4 = 7;
  dword_10068EA0 = 0;
  LOWORD(pszAgentW) = 0;
  return result;
}
// 100021E0: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 1002404A: using guessed type _DWORD __cdecl sub_1002404A(LPVOID lpMem);
// 10068EA0: using guessed type int dword_10068EA0;
// 10068EA4: using guessed type int dword_10068EA4;

//----- (10053D30) --------------------------------------------------------
int __cdecl sub_10053D30()
{
  if ( hInternet )
  {
    WinHttpCloseHandle(hInternet);
    hInternet = 0;
  }
  if ( pProxyConfig.lpszAutoConfigUrl )
    GlobalFree(pProxyConfig.lpszAutoConfigUrl);
  if ( pProxyConfig.lpszProxy )
    GlobalFree(pProxyConfig.lpszProxy);
  if ( pProxyConfig.lpszProxyBypass )
    GlobalFree(pProxyConfig.lpszProxyBypass);
  return nullsub_2(&unk_1006A344);
}
// 10024CC5: using guessed type int __thiscall nullsub_2(_DWORD);

#error "There were 316 decompilation failure(s) on 3074 function(s)"
