/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2009 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Data declarations

extern _UNKNOWN loc_10002BC0; // weak
extern _UNKNOWN loc_10002E20; // weak
extern _UNKNOWN loc_10002ED0; // weak
extern _UNKNOWN loc_10007010; // weak
extern _UNKNOWN loc_10009CC0; // weak
extern _UNKNOWN loc_1000A1F0; // weak
extern _UNKNOWN loc_1000AB40; // weak
extern _UNKNOWN loc_1000AC70; // weak
extern _UNKNOWN loc_1000ADF0; // weak
extern _UNKNOWN loc_1000AEB0; // weak
extern _UNKNOWN loc_1000F6D0; // weak
extern _UNKNOWN loc_1000FED0; // weak
extern _UNKNOWN loc_1000FF70; // weak
extern _UNKNOWN loc_100102E0; // weak
extern _UNKNOWN loc_10010400; // weak
extern _UNKNOWN loc_100105E0; // weak
extern _UNKNOWN loc_10010720; // weak
extern _UNKNOWN loc_10010890; // weak
extern _UNKNOWN loc_10012540; // weak
extern _UNKNOWN loc_10012FA0; // weak
extern _UNKNOWN loc_100134C0; // weak
extern _UNKNOWN loc_100138D0; // weak
extern _UNKNOWN loc_10013A40; // weak
extern _UNKNOWN loc_10013AE0; // weak
extern _UNKNOWN loc_10014600; // weak
extern _UNKNOWN loc_10014700; // weak
extern _UNKNOWN loc_10015E50; // weak
extern _UNKNOWN loc_100166D0; // weak
extern _UNKNOWN loc_10016BE0; // weak
extern _UNKNOWN loc_10017FD0; // weak
extern _UNKNOWN loc_10018220; // weak
extern _UNKNOWN loc_10019280; // weak
extern _UNKNOWN loc_10019490; // weak
extern _UNKNOWN loc_10019C80; // weak
extern _UNKNOWN loc_10019DC0; // weak
extern _UNKNOWN loc_1001AE80; // weak
extern _UNKNOWN loc_1001B1E0; // weak
extern _UNKNOWN loc_1001B2C0; // weak
extern _UNKNOWN loc_1001B3B0; // weak
extern _UNKNOWN loc_1001B560; // weak
extern _UNKNOWN loc_1001B950; // weak
extern _UNKNOWN loc_1001DA50; // weak
extern _UNKNOWN loc_1001EF00; // weak
extern _UNKNOWN loc_10020130; // weak
extern _UNKNOWN loc_100202A0; // weak
extern _UNKNOWN loc_10020840; // weak
extern _UNKNOWN loc_10020910; // weak
extern _UNKNOWN loc_10024010; // weak
extern _UNKNOWN loc_10024A90; // weak
extern _UNKNOWN loc_10024B50; // weak
extern _UNKNOWN loc_10024C20; // weak
extern _UNKNOWN loc_10025270; // weak
extern _UNKNOWN loc_10025A70; // weak
extern _UNKNOWN loc_10025B00; // weak
extern _UNKNOWN sub_10027730; // weak
extern _UNKNOWN loc_10028430; // weak
extern _UNKNOWN loc_10028E10; // weak
extern _UNKNOWN loc_1002B04E; // weak
extern _UNKNOWN loc_1002B17E; // weak
extern _UNKNOWN loc_10030A32; // weak
extern _UNKNOWN loc_10034D0D; // weak
extern _UNKNOWN loc_10035CFD; // weak
extern _UNKNOWN loc_10036715; // weak
extern _UNKNOWN loc_10036A3A; // weak
extern _UNKNOWN loc_10036B69; // weak
extern _UNKNOWN loc_100392BF; // weak
extern _UNKNOWN loc_1003A4FE; // weak
extern _UNKNOWN loc_1003A544; // weak
extern _UNKNOWN loc_1003A9C3; // weak
extern _UNKNOWN loc_1003AA65; // weak
extern _UNKNOWN loc_1003B205; // weak
extern _UNKNOWN loc_1003FA20; // weak
extern _UNKNOWN loc_10040417; // weak
extern _UNKNOWN loc_10041A11; // weak
extern _UNKNOWN loc_10041A1D; // weak
extern _UNKNOWN loc_10041B84; // weak
extern _UNKNOWN loc_10041B8D; // weak
extern _UNKNOWN loc_10041F21; // weak
extern _UNKNOWN loc_100422CC; // weak
extern _UNKNOWN loc_1004244D; // weak
extern _UNKNOWN loc_100427B7; // weak
extern _UNKNOWN loc_10042E52; // weak
extern _UNKNOWN loc_10042E61; // weak
extern _UNKNOWN loc_10042E94; // weak
extern _UNKNOWN loc_100480FB; // weak
extern _UNKNOWN loc_1004812E; // weak
extern _UNKNOWN loc_100485D3; // weak
extern _UNKNOWN loc_100495A5; // weak
extern _UNKNOWN sub_1004C2B0; // weak
extern _UNKNOWN loc_1004FFA1; // weak
extern _UNKNOWN loc_100508C6; // weak
extern _UNKNOWN loc_10052D12; // weak
extern _UNKNOWN loc_10052DE0; // weak
extern _UNKNOWN loc_10053315; // weak
extern _UNKNOWN loc_10054C3C; // weak
extern _UNKNOWN loc_10055477; // weak
extern _UNKNOWN loc_100556AF; // weak
extern _UNKNOWN loc_100584F0; // weak
extern _UNKNOWN sub_10059228; // weak
extern _UNKNOWN sub_1005924B; // weak
extern _UNKNOWN sub_10059276; // weak
extern _UNKNOWN sub_100592A1; // weak
extern _UNKNOWN sub_100592CE; // weak
extern _UNKNOWN sub_100592F7; // weak
extern _UNKNOWN sub_10059334; // weak
extern _UNKNOWN sub_1005935A; // weak
extern _UNKNOWN sub_1005937D; // weak
extern _UNKNOWN sub_100593A8; // weak
extern _UNKNOWN sub_100593D5; // weak
extern _UNKNOWN sub_10059403; // weak
extern _UNKNOWN sub_10059429; // weak
extern _UNKNOWN sub_1005944F; // weak
extern _UNKNOWN sub_10059475; // weak
extern _UNKNOWN sub_10059498; // weak
extern _UNKNOWN sub_100594BB; // weak
extern _UNKNOWN sub_100594F2; // weak
extern _UNKNOWN sub_1005950D; // weak
extern _UNKNOWN sub_1005952B; // weak
extern _UNKNOWN sub_1005956A; // weak
extern _UNKNOWN sub_1005958D; // weak
extern _UNKNOWN sub_100595B0; // weak
extern _UNKNOWN sub_100595CB; // weak
extern _UNKNOWN sub_100595E6; // weak
extern _UNKNOWN sub_10059601; // weak
extern _UNKNOWN sub_1005965D; // weak
extern _UNKNOWN sub_100596A3; // weak
extern _UNKNOWN sub_100596C6; // weak
extern _UNKNOWN sub_100596E9; // weak
extern _UNKNOWN sub_10059786; // weak
extern _UNKNOWN sub_10059823; // weak
extern _UNKNOWN sub_10059857; // weak
extern _UNKNOWN sub_10059882; // weak
extern _UNKNOWN sub_1005989D; // weak
extern _UNKNOWN sub_100598DE; // weak
extern _UNKNOWN sub_1005990D; // weak
extern _UNKNOWN sub_10059928; // weak
extern _UNKNOWN sub_10059959; // weak
extern _UNKNOWN sub_1005998A; // weak
extern _UNKNOWN sub_100599AF; // weak
extern _UNKNOWN sub_100599E6; // weak
extern _UNKNOWN sub_10059A1D; // weak
extern _UNKNOWN sub_10059A40; // weak
extern _UNKNOWN sub_10059A63; // weak
extern _UNKNOWN sub_10059A86; // weak
extern _UNKNOWN sub_10059AA9; // weak
extern _UNKNOWN sub_10059AC4; // weak
extern _UNKNOWN sub_10059AEA; // weak
extern _UNKNOWN sub_10059B1A; // weak
extern _UNKNOWN sub_10059B48; // weak
extern _UNKNOWN sub_10059B6B; // weak
extern _UNKNOWN sub_10059B8E; // weak
extern _UNKNOWN sub_10059BBE; // weak
extern _UNKNOWN sub_10059BE1; // weak
extern _UNKNOWN sub_10059C33; // weak
extern _UNKNOWN sub_10059C59; // weak
extern _UNKNOWN sub_10059C7F; // weak
extern _UNKNOWN sub_10059CA4; // weak
extern _UNKNOWN sub_10059CBF; // weak
extern _UNKNOWN sub_10059CF3; // weak
extern _UNKNOWN sub_10059D24; // weak
extern _UNKNOWN sub_10059D4A; // weak
extern _UNKNOWN sub_10059D6D; // weak
extern _UNKNOWN sub_10059DA1; // weak
extern _UNKNOWN sub_10059DD2; // weak
extern _UNKNOWN sub_10059DF8; // weak
extern _UNKNOWN sub_10059E1B; // weak
extern _UNKNOWN sub_10059E3E; // weak
extern _UNKNOWN sub_10059E6E; // weak
extern _UNKNOWN sub_10059E94; // weak
extern _UNKNOWN sub_10059EB7; // weak
extern _UNKNOWN sub_10059EDA; // weak
extern _UNKNOWN sub_10059EFF; // weak
extern _UNKNOWN sub_10059F24; // weak
extern _UNKNOWN sub_10059F47; // weak
extern _UNKNOWN sub_10059F6D; // weak
extern _UNKNOWN sub_10059F93; // weak
extern _UNKNOWN sub_10059FB6; // weak
extern _UNKNOWN sub_1005A004; // weak
extern _UNKNOWN sub_1005A05B; // weak
extern _UNKNOWN sub_1005A098; // weak
extern _UNKNOWN sub_1005A0C8; // weak
extern _UNKNOWN sub_1005A121; // weak
extern _UNKNOWN sub_1005A184; // weak
extern _UNKNOWN sub_1005A1A8; // weak
extern _UNKNOWN sub_1005A1D8; // weak
extern _UNKNOWN sub_1005A221; // weak
extern _UNKNOWN sub_1005A240; // weak
extern _UNKNOWN sub_1005A268; // weak
extern _UNKNOWN sub_1005A2A8; // weak
extern _UNKNOWN sub_1005A2D8; // weak
extern _UNKNOWN sub_1005A308; // weak
extern _UNKNOWN sub_1005A330; // weak
extern _UNKNOWN sub_1005A360; // weak
extern _UNKNOWN sub_1005A3B0; // weak
extern _UNKNOWN sub_1005A3F1; // weak
extern _UNKNOWN sub_1005A418; // weak
extern _UNKNOWN sub_1005A450; // weak
extern _UNKNOWN sub_1005A488; // weak
extern _UNKNOWN sub_1005A4D4; // weak
extern _UNKNOWN sub_1005A514; // weak
extern _UNKNOWN sub_1005A538; // weak
extern _UNKNOWN sub_1005A583; // weak
extern _UNKNOWN sub_1005A5B8; // weak
extern _UNKNOWN sub_1005A60F; // weak
extern _UNKNOWN sub_1005A65E; // weak
extern _UNKNOWN sub_1005A6A1; // weak
extern _UNKNOWN sub_1005A6CB; // weak
extern _UNKNOWN sub_1005A6F8; // weak
extern _UNKNOWN sub_1005A733; // weak
extern _UNKNOWN sub_1005A7B6; // weak
extern _UNKNOWN sub_1005A7FE; // weak
extern _UNKNOWN sub_1005A82B; // weak
extern _UNKNOWN sub_1005A87C; // weak
extern _UNKNOWN sub_1005A8D6; // weak
extern _UNKNOWN sub_1005A908; // weak
extern _UNKNOWN sub_1005A938; // weak
extern _UNKNOWN sub_1005A968; // weak
extern _UNKNOWN sub_1005A998; // weak
extern _UNKNOWN sub_1005A9D0; // weak
extern _UNKNOWN sub_1005AA50; // weak
extern _UNKNOWN sub_1005AAD0; // weak
extern _UNKNOWN sub_1005AB08; // weak
extern _UNKNOWN sub_1005AB5A; // weak
extern _UNKNOWN sub_1005ABA9; // weak
extern _UNKNOWN sub_1005AC21; // weak
extern _UNKNOWN sub_1005AC58; // weak
extern _UNKNOWN sub_1005ACAC; // weak
extern _UNKNOWN sub_1005ACF8; // weak
extern _UNKNOWN sub_1005AD30; // weak
extern _UNKNOWN sub_1005AD68; // weak
extern _UNKNOWN sub_1005ADA0; // weak
extern _UNKNOWN sub_1005ADE8; // weak
extern _UNKNOWN sub_1005AE31; // weak
extern _UNKNOWN sub_1005AEA9; // weak
extern _UNKNOWN sub_1005AEE0; // weak
extern _UNKNOWN sub_1005AF18; // weak
extern _UNKNOWN sub_1005AF48; // weak
extern _UNKNOWN sub_1005AF78; // weak
extern _UNKNOWN sub_1005AFA8; // weak
extern _UNKNOWN sub_1005AFD8; // weak
extern _UNKNOWN sub_1005B018; // weak
extern _UNKNOWN sub_1005B05B; // weak
extern _UNKNOWN sub_1005B080; // weak
extern _UNKNOWN sub_1005B0A8; // weak
extern _UNKNOWN sub_1005B0D8; // weak
extern _UNKNOWN sub_1005B110; // weak
extern _UNKNOWN sub_1005B152; // weak
extern _UNKNOWN sub_1005B178; // weak
extern _UNKNOWN sub_1005B1C8; // weak
extern _UNKNOWN sub_1005B200; // weak
extern _UNKNOWN sub_1005B230; // weak
extern _UNKNOWN sub_1005B258; // weak
extern _UNKNOWN sub_1005B28A; // weak
extern _UNKNOWN sub_1005B2D1; // weak
extern _UNKNOWN sub_1005B319; // weak
extern _UNKNOWN sub_1005B350; // weak
extern _UNKNOWN sub_1005B389; // weak
extern _UNKNOWN sub_1005B3B0; // weak
extern _UNKNOWN sub_1005B3D8; // weak
extern _UNKNOWN sub_1005B400; // weak
extern _UNKNOWN sub_1005B428; // weak
extern _UNKNOWN sub_1005B45A; // weak
extern _UNKNOWN sub_1005B488; // weak
extern _UNKNOWN sub_1005B4B8; // weak
extern _UNKNOWN sub_1005B50F; // weak
extern _UNKNOWN sub_1005B538; // weak
extern _UNKNOWN sub_1005B576; // weak
extern _UNKNOWN sub_1005B5EA; // weak
extern _UNKNOWN sub_1005B618; // weak
extern _UNKNOWN sub_1005B648; // weak
extern _UNKNOWN sub_1005B678; // weak
extern _UNKNOWN sub_1005B6B8; // weak
extern _UNKNOWN sub_1005B713; // weak
extern _UNKNOWN sub_1005B748; // weak
extern _UNKNOWN sub_1005B778; // weak
extern _UNKNOWN sub_1005B7C0; // weak
extern _UNKNOWN sub_1005B7FB; // weak
extern _UNKNOWN sub_1005B82B; // weak
extern _UNKNOWN sub_1005B87C; // weak
extern _UNKNOWN sub_1005B8A0; // weak
extern _UNKNOWN sub_1005B8E0; // weak
extern _UNKNOWN sub_1005B910; // weak
extern _UNKNOWN sub_1005B940; // weak
extern _UNKNOWN sub_1005B968; // weak
extern _UNKNOWN sub_1005B9A9; // weak
extern _UNKNOWN sub_1005B9F0; // weak
extern _UNKNOWN sub_1005BA50; // weak
extern _UNKNOWN sub_1005BA80; // weak
extern _UNKNOWN sub_1005BAC8; // weak
extern _UNKNOWN sub_1005BB00; // weak
extern _UNKNOWN sub_1005BB30; // weak
extern _UNKNOWN sub_1005BB68; // weak
extern _UNKNOWN sub_1005BB9F; // weak
extern _UNKNOWN sub_1005BBD8; // weak
extern _UNKNOWN sub_1005BC10; // weak
extern _UNKNOWN sub_1005BC38; // weak
extern _UNKNOWN sub_1005BC68; // weak
extern _UNKNOWN sub_1005BCA1; // weak
extern _UNKNOWN sub_1005BCDB; // weak
extern _UNKNOWN sub_1005BD33; // weak
extern _UNKNOWN sub_1005BD80; // weak
extern _UNKNOWN sub_1005BDA5; // weak
extern _UNKNOWN sub_1005BE03; // weak
extern _UNKNOWN sub_1005BE3B; // weak
extern _UNKNOWN sub_1005BE94; // weak
extern _UNKNOWN sub_1005BF01; // weak
extern _UNKNOWN sub_1005BF3B; // weak
extern _UNKNOWN sub_1005BF70; // weak
extern _UNKNOWN sub_1005BFA0; // weak
extern _UNKNOWN sub_1005BFC0; // weak
extern _UNKNOWN sub_1005BFF0; // weak
extern _UNKNOWN sub_1005C02B; // weak
extern _UNKNOWN sub_1005C068; // weak
extern _UNKNOWN sub_1005C0C1; // weak
extern _UNKNOWN sub_1005C111; // weak
extern _UNKNOWN sub_1005C14E; // weak
extern _UNKNOWN sub_1005C183; // weak
extern _UNKNOWN sub_1005C1AB; // weak
extern _UNKNOWN sub_1005C1E9; // weak
extern _UNKNOWN sub_1005C220; // weak
extern _UNKNOWN sub_1005C266; // weak
extern _UNKNOWN sub_1005C298; // weak
extern _UNKNOWN sub_1005C2C8; // weak
extern _UNKNOWN sub_1005C2F8; // weak
extern _UNKNOWN sub_1005C330; // weak
extern _UNKNOWN sub_1005C350; // weak
extern _UNKNOWN sub_1005C370; // weak
extern _UNKNOWN sub_1005C398; // weak
extern _UNKNOWN sub_1005C3E0; // weak
extern _UNKNOWN sub_1005C430; // weak
extern _UNKNOWN sub_1005C470; // weak
extern _UNKNOWN sub_1005C4C4; // weak
extern _UNKNOWN sub_1005C4E8; // weak
extern _UNKNOWN sub_1005C518; // weak
extern _UNKNOWN sub_1005C548; // weak
extern _UNKNOWN sub_1005C589; // weak
extern _UNKNOWN sub_1005C5B8; // weak
extern _UNKNOWN sub_1005C5F9; // weak
extern _UNKNOWN sub_1005C628; // weak
extern _UNKNOWN sub_1005C660; // weak
extern _UNKNOWN sub_1005C68A; // weak
extern _UNKNOWN sub_1005C6CB; // weak
extern _UNKNOWN sub_1005C6FA; // weak
extern _UNKNOWN sub_1005C73B; // weak
extern _UNKNOWN sub_1005C760; // weak
extern _UNKNOWN sub_1005C799; // weak
extern _UNKNOWN sub_1005C7D9; // weak
extern _UNKNOWN sub_1005C82E; // weak
extern _UNKNOWN sub_1005C8A0; // weak
extern _UNKNOWN sub_1005C8CB; // weak
extern _UNKNOWN sub_1005C91C; // weak
extern _UNKNOWN sub_1005C95E; // weak
extern _UNKNOWN sub_1005CA55; // weak
extern _UNKNOWN sub_1005CA7B; // weak
extern _UNKNOWN sub_1005CAC9; // weak
extern _UNKNOWN sub_1005CB06; // weak
extern _UNKNOWN sub_1005CB38; // weak
extern _UNKNOWN sub_1005CB6B; // weak
extern _UNKNOWN sub_1005CBCA; // weak
extern _UNKNOWN sub_1005CC1C; // weak
extern _UNKNOWN sub_1005CC53; // weak
extern _UNKNOWN sub_1005CCA1; // weak
extern _UNKNOWN sub_1005CCD3; // weak
extern _UNKNOWN sub_1005CDA5; // weak
extern _UNKNOWN sub_1005CDC8; // weak
extern _UNKNOWN sub_1005CE7B; // weak
extern _UNKNOWN sub_1005CECE; // weak
extern _UNKNOWN sub_1005CF00; // weak
extern _UNKNOWN sub_1005CF78; // weak
extern _UNKNOWN sub_1005CFB0; // weak
extern _UNKNOWN sub_1005CFF0; // weak
extern _UNKNOWN sub_1005D06C; // weak
extern _UNKNOWN sub_1005D0C0; // weak
extern _UNKNOWN sub_1005D171; // weak
extern _UNKNOWN sub_1005D1B0; // weak
extern _UNKNOWN sub_1005D208; // weak
extern _UNKNOWN sub_1005D248; // weak
extern _UNKNOWN sub_1005D278; // weak
extern _UNKNOWN sub_1005D2AB; // weak
extern _UNKNOWN sub_1005D2E0; // weak
extern _UNKNOWN sub_1005D308; // weak
extern _UNKNOWN sub_1005D338; // weak
extern _UNKNOWN sub_1005D36B; // weak
extern _UNKNOWN sub_1005D3A3; // weak
extern _UNKNOWN sub_1005D3DB; // weak
extern _UNKNOWN sub_1005D418; // weak
extern _UNKNOWN sub_1005D450; // weak
extern _UNKNOWN sub_1005D480; // weak
extern _UNKNOWN sub_1005D4A8; // weak
extern _UNKNOWN sub_1005D4D8; // weak
extern _UNKNOWN sub_1005D508; // weak
extern _UNKNOWN sub_1005D538; // weak
extern _UNKNOWN sub_1005D568; // weak
extern _UNKNOWN sub_1005D5A0; // weak
extern _UNKNOWN sub_1005D5D8; // weak
extern _UNKNOWN sub_1005D608; // weak
extern _UNKNOWN sub_1005D638; // weak
extern _UNKNOWN sub_1005D668; // weak
extern _UNKNOWN sub_1005D698; // weak
extern _UNKNOWN sub_1005D6D6; // weak
extern _UNKNOWN sub_1005D713; // weak
extern _UNKNOWN sub_1005D773; // weak
extern _UNKNOWN sub_1005D7C9; // weak
extern _UNKNOWN sub_1005D7F8; // weak
extern _UNKNOWN sub_1005D828; // weak
extern _UNKNOWN sub_1005D858; // weak
extern _UNKNOWN unk_10060200; // weak
extern _UNKNOWN unk_10060284; // weak
extern _UNKNOWN unk_10060288; // weak
extern _UNKNOWN unk_100602A0; // weak
extern _UNKNOWN unk_100602A4; // weak
extern _UNKNOWN unk_100602B8; // weak
extern _UNKNOWN unk_100602BC; // weak
extern _UNKNOWN unk_100602C0; // weak
extern int (__stdcall *off_100602D4)(char); // weak
extern char aBadAllocation[15]; // weak
extern int (__stdcall *off_100602F0)(char); // weak
extern int (__stdcall *off_100602FC)(char); // weak
extern int (__stdcall *off_10060308)(char); // weak
extern int (__stdcall *off_10060314)(char); // weak
extern int (__stdcall *off_10060320)(char); // weak
extern int (__stdcall *off_1006032C)(char); // weak
extern char aBadFunctionCal[18]; // weak
extern int (__stdcall *off_1006034C)(char); // weak
extern int (__stdcall *off_100603BC)(char); // weak
extern char aRegex_errorErr[88]; // weak
extern char aRegex_errorE_0[84]; // weak
extern char aRegex_errorE_1[104]; // weak
extern char aRegex_errorE_2[80]; // weak
extern char aRegex_errorE_3[71]; // weak
extern char aRegex_errorE_4[71]; // weak
extern char aRegex_errorE_5[71]; // weak
extern char aRegex_errorE_6[92]; // weak
extern char aRegex_errorE_7[112]; // weak
extern char aRegex_errorE_8[111]; // weak
extern char aRegex_errorE_9[90]; // weak
extern char aRegex_error_10[123]; // weak
extern char aRegex_error_11[146]; // weak
extern char aRegex_error_12[25]; // weak
extern char aRegex_error_13[26]; // weak
extern char aRegex_error[12]; // weak
extern _UNKNOWN unk_10060900; // weak
extern char *off_10060904; // weak
extern _UNKNOWN unk_10060B58; // weak
extern char *off_10060B5C; // weak
extern int dword_10061658; // weak
extern int dword_1006165C; // weak
extern int (__stdcall *off_10061664)(char); // weak
extern int (__stdcall *off_10061674)(char); // weak
extern _UNKNOWN unk_10061680; // weak
extern _UNKNOWN unk_10061684; // weak
extern int (*off_1006168C[3])(); // weak
extern int (__stdcall *off_100616A8)(char); // weak
extern int (__stdcall *off_100616B4)(char); // weak
extern int (__stdcall *off_100616C0)(char); // weak
extern int (__stdcall *off_100616CC)(char); // weak
extern int (*off_100616D8)(); // weak
extern int (__stdcall *off_100616E0)(char); // weak
extern int (__stdcall *off_10061710)(char); // weak
extern int (__stdcall *off_10061740)(char); // weak
extern int (__stdcall *off_1006176C)(char); // weak
extern int (__stdcall *off_100618EC)(char); // weak
extern char aUnknownExcepti[18]; // weak
extern int (__stdcall *off_1006190C)(char); // weak
extern int (__stdcall *off_10061918)(char); // weak
extern int (__stdcall *off_10061924)(char); // weak
extern int (__stdcall *off_10061930)(char); // weak
extern int (__stdcall *off_1006193C)(char); // weak
extern int (__stdcall *off_1006194C)(char); // weak
extern int (__stdcall *off_1006195C)(char); // weak
extern char aLockAlreadyTak[19]; // weak
extern char aLockAlreadyT_0[31]; // weak
extern int (*off_1006199C[5])(); // weak
extern int (__stdcall *off_100619B4)(int, int); // weak
extern int (*off_100619CC[5])(); // weak
extern int (__stdcall *off_100619E8)(int, int); // weak
extern int (__stdcall *off_10061A04)(int, int); // weak
extern int (__stdcall *off_10061A20)(char); // weak
extern char aPevents[8]; // weak
extern int (__stdcall *off_10061A30)(char); // weak
extern int dword_10061A38[]; // weak
extern int (__stdcall *off_10061BC4)(char); // weak
extern int (__stdcall *off_10061BD0)(char); // weak
extern int (__stdcall *off_10061BDC)(char); // weak
extern int (__stdcall *off_10061BE8)(int); // weak
extern int (__stdcall *off_10061BF4)(char); // weak
extern int (*off_10061BFC[5])(); // weak
extern int (*off_10061C1C[5])(); // weak
extern int (__stdcall *off_10061C68)(char); // weak
extern int (*off_10061C74[2])(); // weak
extern char aBadException[14]; // weak
extern char a_debugmallocat[52]; // weak
extern int (*off_10061CCC[2])(); // weak
extern int (*off_10061CE0)(); // weak
extern int (__stdcall *off_10061CF4)(char); // weak
extern int (__stdcall *off_10061D00)(char); // weak
extern int (__stdcall *off_10061D0C)(char); // weak
extern int (__stdcall *off_10061D18)(char); // weak
extern int (__stdcall *off_10061D24)(char); // weak
extern int (__stdcall *off_10061D30)(char); // weak
extern int (__stdcall *off_10061D3C)(char); // weak
extern int (__stdcall *off_10061D48)(char); // weak
extern int (__stdcall *off_10061D54)(char); // weak
extern int (__stdcall *off_10061D60)(char); // weak
extern int (__stdcall *off_10061D6C)(char); // weak
extern int (__stdcall *off_10061D78)(char); // weak
extern int (__stdcall *off_10061D84)(char); // weak
extern struct _EXCEPTION_POINTERS ExceptionInfo; // idb
extern const WCHAR LibFileName[]; // idb
extern char ProcName[]; // idb
extern char aUnregistertrac[21]; // weak
extern char aTraceevent[11]; // weak
extern char aGettracelogger[21]; // weak
extern char aGettraceenable[20]; // weak
extern char aGettraceenab_0[20]; // weak
extern int (__stdcall *off_10061E2C)(char); // weak
extern int (*off_10061E40[4])(); // weak
extern int (__stdcall *off_10061E58)(char); // weak
extern int (__stdcall *off_10061E90)(char); // weak
extern int (__stdcall *off_10061E98)(char); // weak
extern int (__stdcall *off_10061EA4)(char); // weak
extern int (__stdcall *off_10061F08)(char); // weak
extern int (__stdcall *off_10061F1C)(int, int); // weak
extern int (__stdcall *off_10061F48)(char); // weak
extern int (__stdcall *off_10061F5C)(int, int); // weak
extern char aEventobject[12]; // weak
extern char aPpvirtualproce[24]; // weak
extern char aCount[6]; // weak
extern int (__stdcall *dword_10061FB0)(_DWORD, _DWORD, _DWORD); // weak
extern _UNKNOWN unk_10061FB4; // weak
extern int (__cdecl *off_10061FD4)(_DWORD, _DWORD); // weak
extern wchar_t asc_100620D8[33]; // weak
extern _UNKNOWN unk_10062560; // weak
extern _UNKNOWN unk_100626E0; // weak
extern int (__cdecl *off_100627E0)(_DWORD); // weak
extern const WCHAR ModuleName[]; // idb
extern char aFlsalloc[]; // idb
extern char aFlsfree[]; // idb
extern char aFlsgetvalue[]; // idb
extern char aFlssetvalue[]; // idb
extern char aInitializecrit[]; // idb
extern char aCreatesemaphor[]; // idb
extern char aSetthreadstack[]; // idb
extern char aCreatethreadpo[]; // idb
extern char aSetthreadpoolt[]; // idb
extern char aWaitforthreadp[]; // idb
extern char aClosethreadpoo[]; // idb
extern char aCreatethread_0[]; // idb
extern char aSetthreadpoolw[]; // idb
extern char aClosethreadp_0[]; // idb
extern char aFlushprocesswr[]; // idb
extern char aFreelibrarywhe[]; // idb
extern char aGetcurrentpr_0[]; // idb
extern char aGetlogicalpr_0[]; // idb
extern char aCreatesymbolic[]; // idb
extern char aSetdefaultdlld[]; // idb
extern char aEnumsystemloca[]; // idb
extern char aComparestringe[]; // idb
extern char aGetdateformate[]; // idb
extern char aGetlocaleinfoe[]; // idb
extern char aGettimeformate[]; // idb
extern char aGetuserdefault[]; // idb
extern char aIsvalidlocalen[]; // idb
extern char aLcmapstringex[]; // idb
extern char aGetcurrentpack[]; // idb
extern int dword_10062A68[]; // weak
extern _DWORD off_10062A6C[2]; // idb
extern void *off_10063188; // weak
extern int dword_1006318C[]; // weak
extern char aTz[3]; // weak
extern const WCHAR aMscoree_dll[]; // idb
extern char aCorexitprocess[]; // idb
extern char aSetthreadgroup[]; // idb
extern char aGetthreadgroup[]; // idb
extern char aGetcurrentproc[]; // idb
extern char aGetlogicalproc[]; // idb
extern int (*off_10064BF8[2])(); // weak
extern int (*off_10064C04[4])(); // weak
extern int (*off_10064C1C[2])(); // weak
extern char aPscheduler[11]; // weak
extern int dword_100654D8[]; // weak
extern _DWORD off_100654DC[2]; // idb
extern wchar_t aRuntimeErrorPr[26]; // weak
extern wchar_t aProgramNameUnk[23]; // weak
extern wchar_t a___[4]; // weak
extern wchar_t asc_10065658[3]; // weak
extern wchar_t aMicrosoftVisua[37]; // weak
extern int (__stdcall *off_100656B0)(char); // weak
extern int (__stdcall *off_100656C4)(int, int); // weak
extern char aProc[5]; // weak
extern wchar_t *off_100656F4[4]; // weak
extern wchar_t *off_100656F8[3]; // weak
extern wchar_t *off_100656FC[2]; // weak
extern wchar_t *off_10065700; // weak
extern int (*off_10065A60)(); // weak
extern wchar_t *off_10065A64; // weak
extern wchar_t *off_10065A94; // weak
extern const CHAR MultiByteStr; // idb
extern wchar_t asc_10065BA0[3]; // weak
extern wchar_t asc_10065BA8[2]; // weak
extern wchar_t aC[2]; // weak
extern wchar_t a__[4]; // weak
extern int (__stdcall *off_10065D20)(char); // weak
extern int (*off_10065D48[5])(); // weak
extern int (*off_10065D60[3])(); // weak
extern int (*off_10065D8C[5])(); // weak
extern char aPthreadproxy[13]; // weak
extern int (*off_10065DEC[5])(); // weak
extern int (*off_10065E38[7])(); // weak
extern int (*off_10065E58[3])(); // weak
extern int (*off_10065E84[5])(); // weak
extern int (*off_10065ED0[2])(); // weak
extern int (__stdcall *off_10065EF4)(int); // weak
extern _UNKNOWN unk_10065F58; // weak
extern int dword_10065FE8; // weak
extern int dword_10065FF0; // weak
extern int dword_10065FF4; // weak
extern _UNKNOWN unk_10065FF8; // weak
extern _UNKNOWN unk_10065FFC; // weak
extern _UNKNOWN unk_10066000; // weak
extern char aLog10[6]; // weak
extern char aAsin[5]; // weak
extern char aAcos[5]; // weak
extern char aAtan[5]; // weak
extern char aSqrt_0[5]; // weak
extern char aSin[4]; // weak
extern char aCos[4]; // weak
extern char aTan[4]; // weak
extern char aCeil[5]; // weak
extern char aFloor[6]; // weak
extern char aModf[5]; // weak
extern char aE000[6]; // weak
extern _UNKNOWN unk_100660EC; // weak
extern int (*off_10066148[2])(); // weak
extern char aPcontext[9]; // weak
extern const WCHAR aCombase_dll[]; // idb
extern char aRoinitialize[]; // idb
extern char aRouninitialize[15]; // weak
extern int (*off_100661F0)(); // weak
extern int (*off_1006620C[5])(); // weak
extern int dword_10066224[]; // weak
extern void *off_10066234; // weak
extern int (__stdcall *off_10066238)(int, int); // weak
extern int (__stdcall *off_10066264)(int, int); // weak
extern const WCHAR aUser32_dll[]; // idb
extern char aMessageboxw[]; // idb
extern char aGetactivewindo[]; // idb
extern char aGetlastactivep[]; // idb
extern char aGetuserobjecti[]; // idb
extern char aGetprocesswind[]; // idb
extern wchar_t *off_10066A30; // weak
extern wchar_t *off_100674E0; // weak
extern int dword_100677B4; // weak
extern int dword_100677B8; // weak
extern wchar_t aAcp[4]; // weak
extern wchar_t aOcp[4]; // weak
extern __int16 word_100677CC; // weak
extern char byte_100677E0[]; // weak
extern int (__stdcall *off_10067840)(char); // weak
extern int (*off_10067868[2])(); // weak
extern int (*off_10067894[2])(); // weak
extern char aSwitchstate[12]; // weak
extern char aBadDynamic_cas[18]; // weak
extern int (*off_10067904[4])(); // weak
extern char a1Snan[7]; // weak
extern char a1Ind[6]; // weak
extern char a1Inf[6]; // weak
extern char a1Qnan[7]; // weak
extern _UNKNOWN unk_10067E7A; // weak
extern const WCHAR FileName[]; // idb
extern char aExp10[6]; // weak
extern char aJsonParsingFai[20]; // weak
extern char byte_10067F64; // weak
extern char byte_10067F6C; // weak
extern char aSymbol[7]; // weak
extern char aStart[6]; // weak
extern char aEnd[4]; // weak
extern char aData[5]; // weak
extern char aClass[6]; // weak
extern char aComment[8]; // weak
extern char aRequestIsNotRe[21]; // weak
extern const WCHAR szHeaders[]; // idb
extern void *off_10067FF8; // weak
extern int (__stdcall *off_10068014)(char); // weak
extern int (__stdcall *off_1006801C[2])(int); // weak
extern void *off_10068038; // weak
extern int (__stdcall *off_10068054[2])(char); // weak
extern int (__stdcall *off_10068058)(char); // weak
extern int (*off_1006805C)(); // weak
extern int (*off_1006806C)(); // weak
extern void *off_1006807C; // weak
extern int (*off_10068098[5])(); // weak
extern int (__stdcall *off_100680B4[4])(int); // weak
extern int (__stdcall *off_100680C4)(char); // weak
extern int (__stdcall *off_100680E0)(char); // weak
extern int (__stdcall *off_100680E8)(char); // weak
extern int (__stdcall *off_100680F0)(char); // weak
extern int (__stdcall *off_100680F8)(char); // weak
extern char aThenCannotBeCa[55]; // weak
extern int (__stdcall *off_1006814C)(char); // weak
extern char aVectorTTooLong[19]; // weak
extern char aWaitCannotBeCa[55]; // weak
extern int (*off_100681D8)(); // weak
extern void *off_100681E8; // weak
extern int (__stdcall *off_10068204)(char); // weak
extern int (__stdcall *off_1006820C)(char); // weak
extern _UNKNOWN unk_1006823C; // weak
extern int (__stdcall *off_10068240)(char); // weak
extern char a__[23]; // weak
extern int (__stdcall *off_1006827C)(char); // weak
extern char aGeneric[8]; // weak
extern char aUnknownError[14]; // weak
extern char aIostream[9]; // weak
extern char aIostreamStream[22]; // weak
extern char aSystem[7]; // weak
extern _DWORD dword_100682E4[4]; // idb
extern _DWORD dword_100682F4[4]; // idb
extern _DWORD dword_10068304[4]; // idb
extern _DWORD dword_10068324[4]; // idb
extern _UNKNOWN unk_10068334; // weak
extern int (__stdcall *off_100683AC)(char); // weak
extern int (__stdcall *off_100683B4)(char); // weak
extern _UNKNOWN unk_100683BC; // weak
extern int (__stdcall *off_100683C4)(char); // weak
extern int (__stdcall *off_100683D0)(char); // weak
extern char aFalse[6]; // weak
extern char aTrue[5]; // weak
extern char aAValidJsonDocu[66]; // weak
extern char aSyntaxErrorVal[47]; // weak
extern char byte_1006845C[]; // weak
extern char byte_10068460[]; // weak
extern char byte_10068468[]; // weak
extern _UNKNOWN unk_1006846C; // weak
extern char aMissingAfterOb[37]; // weak
extern char aMissingOrInObj[41]; // weak
extern char aMissingOrObjec[34]; // weak
extern char aMissingOrInArr[40]; // weak
extern char aIsNotANumber_[19]; // weak
extern char asc_10068524[2]; // weak
extern char aLf[4]; // weak
extern char aAdditionalSixC[68]; // weak
extern char aExpectingAnoth[80]; // weak
extern char aBadUnicodeEsca[61]; // weak
extern char aBadUnicodeEs_0[67]; // weak
extern char aCommentsMustSt[27]; // weak
extern char a_16g[7]; // weak
extern _UNKNOWN unk_100688B8; // weak
extern _UNKNOWN unk_100688C0; // weak
extern _UNKNOWN unk_100688C4; // weak
extern _UNKNOWN unk_100688C8; // weak
extern _UNKNOWN unk_100688CC; // weak
extern _UNKNOWN unk_100688D0; // weak
extern _UNKNOWN unk_100688D4; // weak
extern _UNKNOWN unk_100688D8; // weak
extern _UNKNOWN unk_100688DC; // weak
extern char aNull[5]; // weak
extern char asc_100688EC[2]; // weak
extern char asc_100688F0[2]; // weak
extern char asc_100688F4[2]; // weak
extern char asc_100688F8[2]; // weak
extern char asc_100688FC[3]; // weak
extern char asc_10068900[2]; // weak
extern char asc_10068904[2]; // weak
extern char aInvalidMapSetT[28]; // weak
extern char aMapSetTTooLong[20]; // weak
extern char aPp[3]; // weak
extern char aEe[3]; // weak
extern char aP[3]; // weak
extern char aLu[3]; // weak
extern char aLd[3]; // weak
extern char aLu_0[3]; // weak
extern char aLd_0[3]; // weak
extern int (__stdcall *off_1006896C)(char); // weak
extern int (__stdcall *off_100689A8)(char); // weak
extern int (*off_100689E4[6])(); // weak
extern int (*off_100689F0[3])(); // weak
extern char aBadLocaleName[16]; // weak
extern char aBadCast[9]; // weak
extern char aBIUrl__1[26]; // weak
extern char aB[2]; // weak
extern char aI[2]; // weak
extern char aUrl[4]; // weak
extern int (__stdcall *off_10068B08[5])(char); // weak
extern int (__stdcall *off_10068B0C[4])(char); // weak
extern int (__stdcall *off_10068B10[3])(char); // weak
extern int (__stdcall *off_10068B14[2])(char); // weak
extern int (__stdcall *off_10068B18)(char); // weak
extern char *off_10068B20; // weak
extern int dword_10068B24; // weak
extern __int16 word_10068B28[]; // weak
extern char aForexsensati_0[23]; // weak
extern char a1_01[5]; // weak
extern wchar_t aHttpForexsensa[33]; // weak
extern wchar_t aHttpForexsen_0[45]; // weak
extern char aName[5]; // weak
extern char aVersion[8]; // weak
extern char aCode[5]; // weak
extern char aBroker[7]; // weak
extern char aServer[7]; // weak
extern char aAccount[8]; // weak
extern char aType[5]; // weak
extern char aBalance[8]; // weak
extern char aCurrency[9]; // weak
extern char aFlags[6]; // weak
extern char aUtc_0[4]; // weak
extern char aMsg1[5]; // weak
extern char aMsg2[5]; // weak
extern char aAuth_interval[14]; // weak
extern int (__stdcall *off_10068ED0[2])(int); // weak
extern int (__stdcall *off_10068EEC[3])(int); // weak
extern void *off_10068F24; // weak
extern void *off_10068F40; // weak
extern void *off_10068F5C; // weak
extern void *off_10068F78; // weak
extern void *off_10068F94; // weak
extern int (*off_10068FB0)(); // weak
extern int (__stdcall *off_10068FC0)(char); // weak
extern int (__stdcall *off_10068FE8)(char); // weak
extern int (*off_10069010)(); // weak
extern int (__stdcall *off_10069020)(char); // weak
extern int (__stdcall *off_10069028[3])(int, int, int); // weak
extern int (__stdcall *off_10069040)(char); // weak
extern int (*off_10069044)(); // weak
extern char a_ptarget[9]; // weak
extern int (__stdcall *off_10069128)(char); // weak
extern void *off_10069188; // weak
extern int (*off_100691A8)(); // weak
extern int (__stdcall *off_10069200)(char); // weak
extern void *off_1006926C; // weak
extern int (__stdcall *off_10069284)(char); // weak
extern int (__stdcall *off_10069314)(char); // weak
extern int (__stdcall *off_10069340)(char); // weak
extern char aDeletingLinkRe[53]; // weak
extern int (__stdcall *off_100693A0[3])(int); // weak
extern int (__stdcall *off_100693C4)(char); // weak
extern wchar_t aClient[7]; // weak
extern char aInvalidConnect[19]; // weak
extern wchar_t aPost[5]; // weak
extern wchar_t aGet[4]; // weak
extern int (__stdcall *off_10069454)(char); // weak
extern _UNKNOWN unk_1006BAA0; // weak
extern _UNKNOWN unk_1006BAA8; // weak
extern _UNKNOWN unk_1006BAB0; // weak
extern _UNKNOWN unk_1006BAE8; // weak
extern _UNKNOWN unk_1006BB24; // weak
extern _UNKNOWN unk_1006BB60; // weak
extern _UNKNOWN unk_1006BB98; // weak
extern _UNKNOWN unk_1006BD80; // weak
extern _UNKNOWN unk_1006C0A0; // weak
extern _UNKNOWN unk_1006C0D8; // weak
extern _UNKNOWN unk_1006C110; // weak
extern _UNKNOWN unk_1006C1B0; // weak
extern _UNKNOWN unk_1006C474; // weak
extern _UNKNOWN unk_1006C6F4; // weak
extern _UNKNOWN unk_1006C72C; // weak
extern _UNKNOWN unk_1006C764; // weak
extern _EH4_SCOPETABLE stru_1006C830[1]; // weak
extern _UNKNOWN unk_1006CB98; // weak
extern _UNKNOWN unk_1006D074; // weak
extern _UNKNOWN unk_1006D0AC; // weak
extern _UNKNOWN unk_1006D0E4; // weak
extern _UNKNOWN unk_1006D208; // weak
extern _UNKNOWN unk_1006D240; // weak
extern _UNKNOWN unk_1006D278; // weak
extern _UNKNOWN unk_1006D2B0; // weak
extern _UNKNOWN unk_1006D428; // weak
extern _UNKNOWN unk_1006D6F4; // weak
extern _UNKNOWN unk_1006D7B8; // weak
extern _UNKNOWN unk_1006D810; // weak
extern _UNKNOWN unk_1006D8B8; // weak
extern _UNKNOWN unk_1006D8F4; // weak
extern _UNKNOWN unk_1006D96C; // weak
extern _UNKNOWN unk_1006D9A4; // weak
extern _UNKNOWN unk_1006D9DC; // weak
extern _UNKNOWN unk_1006DA88; // weak
extern volatile LONG Addend; // idb
extern int dword_10073258; // weak
extern int dword_1007336C; // weak
extern DWORD dwSpinCount; // idb
extern int (__stdcall **off_100738A4)(char); // weak
extern int (__stdcall **off_100738C4)(char); // weak
extern void **off_10073C50; // weak
extern void *off_10073C58; // weak
extern void *off_10073C5C; // weak
extern void *off_10073C60; // weak
extern void *off_10073C64; // weak
extern void *off_10073C68; // weak
extern void *off_10073C6C; // weak
extern void *off_10073C70; // weak
extern void *off_10073C74; // weak
extern void *off_10073C78; // weak
extern void *off_10073C7C; // weak
extern void *off_10073C88; // weak
extern void *off_10073C8C; // weak
extern void *off_10073C90; // weak
extern void *off_10073C94; // weak
extern void *off_10073C98; // weak
extern void *off_10073C9C; // weak
extern void *off_10073CA0; // weak
extern void *off_10073CA4; // weak
extern void *off_10073CB0; // weak
extern int dword_10073D14; // weak
extern LPCRITICAL_SECTION lpCriticalSection; // idb
extern wchar_t *off_10074080; // weak
extern void *off_10074084; // weak
extern int dword_10074088[]; // weak
extern int dword_1007408C[]; // weak
extern _UNKNOWN unk_100741F0; // weak
extern _UNKNOWN unk_100741F4; // weak
extern int __security_cookie; // weak
extern int dword_10074204; // weak
extern int dword_10074210; // weak
extern int dword_10074228; // weak
extern int dword_10074238; // weak
extern int dword_10074240; // weak
extern int dword_10074244; // weak
extern int dword_10074248; // weak
extern void *off_100742D0; // weak
extern int dword_100742D8; // weak
extern int dword_100742DC; // weak
extern int dword_100742E0; // weak
extern int dword_100742E4; // weak
extern int dword_100742E8; // weak
extern int dword_100742EC; // weak
extern int dword_100742F0[]; // weak
extern int dword_10074324; // weak
extern _UNKNOWN unk_10074360; // weak
extern _UNKNOWN unk_10074368; // weak
extern int dword_100744B0; // weak
extern LPVOID lpAddend; // idb
extern char byte_100744BC[]; // weak
extern int dword_100744C0; // weak
extern char aVyv[6]; // weak
extern char aJ[3]; // weak
extern char byte_100745B0[]; // weak
extern char byte_100746B8[]; // weak
extern _UNKNOWN unk_100747B8; // weak
extern _UNKNOWN unk_100749D8; // weak
extern void *off_100749E0; // weak
extern volatile LONG *off_10074B44; // idb
extern volatile LONG dword_10074B48; // idb
extern wchar_t *off_10074BD8; // weak
extern int *off_10074C00; // weak
extern int dword_10074C0C; // weak
extern wchar_t *off_10074C10; // weak
extern char *off_10074C14; // weak
extern wchar_t *off_10074C18; // weak
extern _UNKNOWN unk_10074C1C; // weak
extern char *off_10074C44[11]; // weak
extern char *off_10074C4C[9]; // weak
extern void *off_10074DD8; // weak
extern _UNKNOWN unk_10075038; // weak
extern _UNKNOWN unk_10075058; // weak
extern _UNKNOWN unk_10075060; // weak
extern double dbl_100750A0; // weak
extern double dbl_100750A8; // weak
extern double dbl_100750B0; // weak
extern double dbl_100750C0; // weak
extern int dword_100750C8[]; // weak
extern void *off_100750CC; // weak
extern int dword_100751C8; // weak
extern int (*off_100751CC[10])(); // weak
extern int (*off_100751D0[9])(); // weak
extern int (*off_100751D4[8])(); // weak
extern int (*off_100751D8[7])(); // weak
extern int (*off_100751DC[6])(); // weak
extern int (*off_100751E0[5])(); // weak
extern PVOID off_100751E4; // idb
extern PVOID off_100751E8; // idb
extern PVOID off_100751EC; // idb
extern PVOID off_100751F0; // idb
extern _DWORD dword_10075470[4]; // idb
extern int dword_10075480; // weak
extern char byte_10075538[]; // weak
extern int dword_10075638; // weak
extern int dword_1007563C; // weak
extern int dword_10075640; // weak
extern int dword_10075644; // weak
extern int dword_10075648; // weak
extern int dword_1007564C; // weak
extern int dword_10075650; // weak
extern int dword_10075654; // weak
extern int dword_10075658; // weak
extern int dword_1007565C; // weak
extern int dword_10075660; // weak
extern int dword_10075664; // weak
extern HANDLE hConsoleOutput; // idb
extern _UNKNOWN unk_10075678; // weak
extern _UNKNOWN unk_100757D8; // weak
extern int (__stdcall **off_10075940)(char); // weak
extern int (__stdcall **off_10075978)(char); // weak
extern int (__stdcall **off_100759B0)(char); // weak
extern int (__stdcall **off_100759E8)(char); // weak
extern int (__stdcall **off_10075B58)(char); // weak
extern int (__stdcall **off_10075C14)(char); // weak
extern int (__stdcall **off_10075C4C)(char); // weak
extern int (__stdcall **off_10075C84)(char); // weak
extern int (__stdcall **off_10075CBC)(char); // weak
extern int (__stdcall **off_10075CF4)(char); // weak
extern int (__stdcall **off_10075D2C)(char); // weak
extern int (__stdcall **off_10075D64)(char); // weak
extern int (__stdcall **off_10075DA0)(char); // weak
extern __int64 qword_10075E70; // weak
extern __int16 word_10075E78; // weak
extern _UNKNOWN unk_10075E80; // weak
extern int dword_10075EB8; // weak
extern int dword_10075ED8; // weak
extern int dword_10075EDC; // weak
extern char byte_10075EE8; // weak
extern char byte_10075F10; // weak
extern int dword_10075F20; // weak
extern int dword_10075F24; // weak
extern int dword_10075F48; // weak
extern int dword_10075F68; // weak
extern int dword_10075F6C; // weak
extern char byte_10075F78; // weak
extern int dword_10075FA0; // weak
extern int dword_10075FB0; // weak
extern int dword_10075FB4; // weak
extern _UNKNOWN unk_10075FB8; // weak
extern int dword_10075FF0; // weak
extern char byte_10076008; // weak
extern int dword_10076018; // weak
extern int dword_1007601C; // weak
extern int dword_10076040; // weak
extern __int16 word_10076058; // weak
extern __int16 word_1007605C; // weak
extern _UNKNOWN unk_10076060; // weak
extern int dword_10076098; // weak
extern char byte_100760A0; // weak
extern char byte_100760B0; // weak
extern int dword_100760C0; // weak
extern int dword_100760C4; // weak
extern int dword_100760E8; // weak
extern char byte_100760F0; // weak
extern int dword_10076100; // weak
extern int dword_10076110; // weak
extern int dword_10076114; // weak
extern int dword_10076118; // weak
extern int dword_10076128; // weak
extern int dword_1007612C; // weak
extern int dword_10076130; // weak
extern int dword_10076140; // weak
extern int dword_10076144; // weak
extern int dword_10076148; // weak
extern int dword_10076158; // weak
extern int dword_1007615C; // weak
extern LPCWSTR pszAgentW; // idb
extern int dword_10076170; // weak
extern int dword_10076174; // weak
extern int (__stdcall *off_10076178[3])(char); // weak
extern int (__stdcall *off_1007617C[2])(char); // weak
extern char byte_100761D0[]; // weak
extern int dword_100761E4; // weak
extern int dword_100761E8; // weak
extern int dword_100761EC; // weak
extern int dword_100761F0; // weak
extern int dword_100761F4; // weak
extern int dword_10076208; // weak
extern char byte_10076210; // weak
extern _UNKNOWN unk_10076218; // weak
extern struct _RTL_CRITICAL_SECTION CriticalSection; // idb
extern _UNKNOWN unk_10076280; // weak
extern int dword_10076284; // weak
extern _UNKNOWN unk_10076288; // weak
extern _UNKNOWN dword_100762B0; // weak
extern _UNKNOWN unk_100762D8; // weak
extern int dword_1007637C; // weak
extern int dword_10076380; // weak
extern int dword_10076388; // weak
extern int dword_10076390; // weak
extern int dword_10076394; // weak
extern int dword_100763A0; // weak
extern int dword_100763A4; // weak
extern int dword_100763AC; // weak
extern int dword_100763B0; // weak
extern int dword_100763B4; // weak
extern int dword_100763F0; // weak
extern __int16 word_1007647C; // weak
extern __int16 word_10076480; // weak
extern __int16 word_10076484; // weak
extern __int16 word_10076488; // weak
extern int dword_1007648C; // weak
extern int dword_10076490; // weak
extern int dword_10076494; // weak
extern int dword_10076498; // weak
extern int dword_1007649C; // weak
extern int dword_100764A0; // weak
extern int dword_100764A4; // weak
extern int dword_100764A8; // weak
extern __int16 word_100764AC; // weak
extern int dword_100764B0; // weak
extern int dword_100764B4; // weak
extern __int16 word_100764B8; // weak
extern int dword_100766BC; // weak
extern int dword_100766C8; // weak
extern char byte_100766CC; // weak
extern int dword_100766D0; // weak
extern int dword_100766D4; // weak
extern int dword_100766D8; // weak
extern int dword_100766E0; // weak
extern int dword_100766E4; // weak
extern int dword_100766F0; // weak
extern int dword_100766F4; // weak
extern DWORD dwTlsIndex; // idb
extern _UNKNOWN unk_100766FC; // weak
extern int dword_10076700; // weak
extern int dword_10076704; // weak
extern _UNKNOWN unk_10076720; // weak
extern HMODULE hLibModule; // idb
extern int dword_1007672C; // weak
extern int dword_10076730; // weak
extern LPVOID dword_10076734; // idb
extern _UNKNOWN unk_10076740; // weak
extern int dword_10076890; // weak
extern int dword_10076894; // weak
extern int (__stdcall *dword_10076898)(_DWORD, _DWORD, _DWORD); // weak
extern int dword_1007689C; // weak
extern PVOID dword_100768A4; // idb
extern LPVOID lpMem; // idb
extern int dword_100768AC; // weak
extern int dword_100768B0; // weak
extern struct _TIME_ZONE_INFORMATION TimeZoneInformation; // idb
extern PVOID dword_10076964; // idb
extern char byte_1007696C; // weak
extern int dword_10076970; // weak
extern int dword_10076978; // weak
extern int dword_1007697C; // weak
extern int dword_10076980; // weak
extern LPVOID dword_10076984; // idb
extern LPVOID dword_10076988; // idb
extern LPVOID dword_1007698C; // idb
extern LPVOID dword_10076990; // idb
extern int dword_10076994; // weak
extern PVOID dword_1007699C; // idb
extern int dword_100769A0; // weak
extern int dword_100769A4; // weak
extern int dword_100769A8; // weak
extern _UNKNOWN unk_100769AC; // weak
extern int dword_100769B0; // weak
extern ULONG_PTR ProcessAffinityMask; // idb
extern ULONG_PTR SystemAffinityMask; // idb
extern int dword_100769BC; // weak
extern int dword_100769C0; // weak
extern int dword_100769C4; // weak
extern char byte_100769C8; // weak
extern int dword_100769CC; // weak
extern int dword_100769D0; // weak
extern int dword_100769D4; // weak
extern int dword_100769D8; // weak
extern LPVOID dword_100769DC; // idb
extern int dword_100769E8; // weak
extern _UNKNOWN unk_100769F0; // weak
extern WCHAR Filename; // idb
extern __int16 word_10076C2A; // weak
extern PVOID dword_10077018; // idb
extern _UNKNOWN unk_1007701C; // weak
extern LPVOID dword_10077020; // idb
extern int dword_1007702C; // weak
extern int dword_10077030; // weak
extern int dword_10077034; // weak
extern __int16 word_10077038[]; // weak
extern int dword_10077044; // weak
extern int dword_10077048; // weak
extern int dword_1007704C; // weak
extern HANDLE hHeap; // idb
extern int dword_10077058; // weak
extern union _SLIST_HEADER ListHead; // idb
extern int dword_10077068; // weak
extern int dword_1007706C; // weak
extern int dword_10077070; // weak
extern int dword_10077074; // weak
extern int dword_10077078; // weak
extern DWORD dword_10077090; // idb
extern int dword_10077098; // weak
extern int dword_100770A0[]; // weak
extern char byte_100771A0[260]; // idb
extern char byte_100772A4; // weak
extern PVOID dword_100772A8; // idb
extern int dword_100772AC; // weak
extern PVOID dword_100772B0; // idb
extern int dword_100772B4; // weak
extern int dword_100772BC; // weak
extern LPVOID dword_100772C0; // idb
extern LPVOID dword_100772C4; // idb
extern int dword_100772D0; // weak
extern int dword_100772D4; // weak
extern int dword_100772D8; // weak
extern _UNKNOWN unk_100772DC; // weak
extern int dword_100772E4; // weak
extern int dword_100772E8; // weak
extern PVOID dword_100772EC; // idb
extern PVOID dword_100772F0; // idb
extern PVOID dword_100772F4; // idb
extern PVOID dword_100772F8; // idb
extern PVOID dword_100772FC; // idb
extern int dword_10077340; // weak
extern char byte_10077350; // weak
extern _UNKNOWN unk_10077354; // weak
extern int dword_100773B8; // weak
extern int dword_100773C0; // weak
extern int dword_100773C4; // weak
extern int dword_100773C8; // weak
extern int dword_100773CC; // weak
extern int dword_100773D0; // weak
extern int dword_100773D4; // weak
extern int dword_100773D8; // weak
extern __int64 qword_100773E0; // weak
extern int dword_100773E8; // weak
extern int dword_100773EC; // weak
extern int dword_100773F0; // weak
extern char byte_100773F4; // weak
extern int dword_10077404; // weak
extern int dword_10077408; // weak
extern __int64 qword_10077410; // weak
extern int dword_10077418; // weak
extern int dword_1007741C; // weak
extern int dword_10077420; // weak
extern char byte_10077424; // weak
extern int dword_10077434; // weak
extern int dword_10077438; // weak
extern __int64 qword_10077440; // weak
extern int dword_10077448; // weak
extern int dword_1007744C; // weak
extern int dword_10077450; // weak
extern char byte_10077454; // weak
extern int dword_10077464; // weak
extern int dword_10077468; // weak
extern __int64 qword_10077470; // weak
extern int dword_10077478; // weak
extern int dword_1007747C; // weak
extern int dword_10077480; // weak
extern char byte_10077484; // weak
extern int dword_10077494; // weak
extern int dword_10077498; // weak
extern __int64 qword_100774A0; // weak
extern int dword_100774A8; // weak
extern int dword_100774AC; // weak
extern int dword_100774B0; // weak
extern char byte_100774B4; // weak
extern int dword_100774C4; // weak
extern int dword_100774C8; // weak
extern __int64 qword_100774D0; // weak
extern int dword_100774D8; // weak
extern int dword_100774DC; // weak
extern int dword_100774E0; // weak
extern char byte_100774E4; // weak
extern int dword_100774F4; // weak
extern int dword_100774F8; // weak
extern __int64 qword_10077500; // weak
extern int dword_10077508; // weak
extern int dword_1007750C; // weak
extern int dword_10077510; // weak
extern char byte_10077514; // weak
extern int dword_10077524; // weak
extern int dword_10077528; // weak
extern __int64 qword_10077530; // weak
extern int dword_10077538; // weak
extern int dword_1007753C; // weak
extern int dword_10077540; // weak
extern char byte_10077544; // weak
extern int dword_10077554; // weak
extern int dword_10077558; // weak
extern __int64 qword_10077560; // weak
extern int dword_10077568; // weak
extern int dword_1007756C; // weak
extern int dword_10077570; // weak
extern char byte_10077574; // weak
extern int dword_10077584; // weak
extern int dword_10077588; // weak
extern __int64 qword_10077590; // weak
extern int dword_10077598; // weak
extern int dword_1007759C; // weak
extern int dword_100775A0; // weak
extern char byte_100775A4; // weak
extern int dword_100775B4; // weak
extern int dword_100775B8; // weak
extern __int64 qword_100775C0; // weak
extern int dword_100775C8; // weak
extern int dword_100775CC; // weak
extern int dword_100775D0; // weak
extern char byte_100775D4; // weak
extern int dword_100775E4; // weak
extern int dword_100775E8; // weak
extern __int64 qword_100775F0; // weak
extern int dword_100775F8; // weak
extern int dword_100775FC; // weak
extern int dword_10077600; // weak
extern char byte_10077604; // weak
extern int dword_10077614; // weak
extern int dword_10077618; // weak
extern __int64 qword_10077620; // weak
extern int dword_10077628; // weak
extern int dword_1007762C; // weak
extern int dword_10077630; // weak
extern char byte_10077634; // weak
extern int dword_10077644; // weak
extern int dword_10077648; // weak
extern __int64 qword_10077650; // weak
extern __int64 qword_10077658; // weak
extern int dword_10077660; // weak
extern char byte_10077664; // weak
extern int dword_10077674; // weak
extern int dword_10077678; // weak
extern __int64 qword_10077680; // weak
extern int dword_10077688; // weak
extern int dword_1007768C; // weak
extern int dword_10077690; // weak
extern char byte_10077694; // weak
extern int dword_100776A4; // weak
extern int dword_100776A8; // weak
extern __int64 qword_100776B0; // weak
extern int dword_100776B8; // weak
extern int dword_100776BC; // weak
extern int dword_100776C0; // weak
extern char byte_100776C4; // weak
extern int dword_100776D4; // weak
extern int dword_100776D8; // weak
extern __int64 qword_100776E0; // weak
extern int dword_100776E8; // weak
extern int dword_100776EC; // weak
extern int dword_100776F0; // weak
extern char byte_100776F4; // weak
extern int dword_10077704; // weak
extern int dword_10077708; // weak
extern char byte_10077710; // weak
extern int dword_10077720; // weak
extern int dword_10077724; // weak
extern int dword_10077728; // weak
extern int dword_1007772C; // weak
extern char byte_10077730; // weak
extern int dword_10077740; // weak
extern int dword_10077744; // weak
extern int dword_10077748; // weak
extern int dword_1007774C; // weak
extern _UNKNOWN unk_10077750; // weak
extern int dword_10077758; // weak
extern int dword_10077768; // weak
extern int dword_1007776C; // weak
extern int dword_10077770; // weak
extern int dword_10077780; // weak
extern int dword_10077784; // weak
extern int dword_10077788; // weak
extern int dword_10077798; // weak
extern int dword_1007779C; // weak
extern int dword_100777A0; // weak
extern int dword_100777A4; // weak
extern int dword_100777B0; // weak
extern int dword_100777C0; // weak
extern int dword_100777C4; // weak
extern int dword_100777C8; // weak
extern int dword_100777CC; // weak
extern int dword_100777D0; // weak
extern __int64 qword_100777D8; // weak
extern int dword_100777E0; // weak
extern int dword_100777E4; // weak
extern int dword_100777F4; // weak
extern int dword_100777F8; // weak
extern int dword_100777FC; // weak
extern int dword_10077800; // weak
extern int dword_10077804; // weak
extern int dword_10077808; // weak
extern int dword_1007780C; // weak
extern int dword_10077810; // weak
extern int dword_10077820; // weak
extern int dword_10077824; // weak
extern int dword_10077828; // weak
extern int dword_1007782C; // weak
extern int dword_10077830; // weak
extern int dword_10077834; // weak
extern int dword_10077838; // weak
extern int dword_1007783C; // weak
extern int dword_10077840; // weak
extern int dword_10077844; // weak
extern int dword_10077848; // weak
extern int dword_1007784C; // weak
extern int dword_10077850; // weak
extern int dword_10077858; // weak
extern _UNKNOWN unk_10077950; // weak
extern int dword_10077960; // weak
extern int dword_10077968; // weak
extern int dword_1007796C; // weak
extern int dword_10077970; // weak
extern _UNKNOWN unk_10077974; // weak
extern int dword_1007798C; // weak
extern int dword_10077990; // weak
extern int dword_10077994; // weak
extern _UNKNOWN unk_1007799C; // weak
extern int dword_100779B4; // weak
extern int dword_100779B8; // weak
extern _UNKNOWN unk_100779BC; // weak
extern int dword_100779D4; // weak
extern int dword_100779D8; // weak
extern __int64 qword_100779E0; // weak
extern int dword_100779E8; // weak
extern int dword_100779EC; // weak
extern __int64 qword_100779F0; // weak
extern int dword_100779F8; // weak
extern int dword_100779FC; // weak
extern __int64 qword_10077A00; // weak
extern int dword_10077A08; // weak
extern int dword_10077A0C; // weak
extern __int64 qword_10077A10; // weak
extern int dword_10077A18; // weak
extern int dword_10077A1C; // weak
extern __int64 qword_10077A20; // weak
extern int dword_10077A28; // weak
extern int dword_10077A2C; // weak
extern _UNKNOWN unk_10077A30; // weak
extern int dword_10077A38; // weak
extern _UNKNOWN unk_10077A44; // weak
extern int dword_10077A5C; // weak
extern int dword_10077A60; // weak
extern HINTERNET hInternet; // idb
extern WINHTTP_CURRENT_USER_IE_PROXY_CONFIG pProxyConfig; // idb
extern int dword_10077A84; // weak
extern int dword_10077A88; // weak
extern int dword_10077A8C; // weak
extern PVOID dword_10077A90; // idb
extern int dword_10077A94; // weak
extern int dword_10077A98; // weak
extern LPVOID dword_10077A9C; // idb
extern int dword_10077AA0; // weak
extern int dword_10078AC0; // weak
extern int (__thiscall *dword_10078AC4)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
extern PVOID dword_10078AC8; // idb
extern PVOID Ptr; // idb
extern int dword_10078AD0; // weak
extern int dword_10078AD4; // weak
extern int dword_10078AE0; // weak
extern int dword_10078AE4; // weak
extern int dword_10078AE8; // weak
extern int dword_10078AEC; // weak
extern int dword_10078AF0; // weak
extern int dword_10078AF4; // weak
extern int dword_10078AF8; // weak
extern int dword_10078AFC; // weak
extern int dword_10078B00; // weak
extern int dword_10078B04; // weak
extern int dword_10078B08; // weak
extern int dword_10078B0C; // weak
extern int dword_10078B10; // weak
extern int dword_10078B14; // weak
extern int dword_10078B18; // weak
extern int dword_10078B1C; // weak
extern int dword_10078B20; // weak
extern int dword_10078B24; // weak
extern int dword_10078B28; // weak
extern int dword_10078B2C; // weak
extern int dword_10078B30; // weak
extern int dword_10078B34; // weak
extern int dword_10078B38; // weak
extern int dword_10078B3C; // weak
extern int dword_10078B40; // weak
extern int dword_10078B44; // weak
extern int dword_10078B48; // weak
extern int dword_10078B4C; // weak
extern int dword_10078B50; // weak
extern int dword_10078B54; // weak

//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// char __userpurge S2_SetIndicators<al>(int a1<ebx>, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, int a10, int a11, __int64 a12, unsigned int a13);
// bool __userpurge S2_OpenLong<eax>(int a1<ebx>, unsigned int a2, unsigned int a3);
// bool __userpurge S2_OpenShort<eax>(int a1<ebx>, unsigned int a2, unsigned int a3);
// signed int __userpurge S2_CloseLong<eax>(int a1<ebx>, unsigned int a2, __int64 a3);
// signed int __userpurge S2_CloseShort<eax>(int a1<ebx>, unsigned int a2, __int64 a3);
// char __userpurge S3_SetIndicators<al>(int a1<ebx>, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
// char __userpurge S3_OpenLong<al>(int a1<ebx>, unsigned int a2);
// char __userpurge S3_OpenShort<al>(int a1<ebx>, unsigned int a2);
int __thiscall sub_100016C0(int this, int a2);
char __cdecl sub_10001750(int a1, int a2);
bool __fastcall sub_10001780(int a1, int a2);
int __thiscall sub_100017B0(void *this, int a2);
int __thiscall sub_10001810(int this, int a2);
int __thiscall sub_10001880(int this);
int __thiscall nullsub_3(_DWORD); // weak
_DWORD __stdcall nullsub_1(_DWORD); // weak
void *__thiscall sub_100018D0(void *this);
int __thiscall sub_100018E0(int this, int a2);
// void *__userpurge sub_10001910<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __thiscall sub_10001940(_DWORD); // weak
// int __userpurge sub_10001950<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int *a4);
int __thiscall sub_10001B00(int this);
int loc_10001BA0(); // weak
// int __userpurge sub_10001BD0<eax>(int a1<ecx>, int a2<edi>, void *a3, int a4, int a5, int a6, int a7, unsigned int a8, __int64 a9, __int64 a10);
// signed int __usercall sub_10001EA0<eax>(int a1<ecx>, int a2<ebx>);
char __thiscall sub_10001FA0(int this, void *a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, __int64 a8, __int64 a9);
char __thiscall sub_10002040(int this, int a2, __int64 a3);
int __thiscall sub_100020F0(int this, int a2);
int __thiscall sub_10002130(int this, int a2);
int __thiscall sub_100023C0(int this, char a2, int a3);
// int (*__usercall sub_10002953<eax>(int a1<ebp>))();
int loc_10002965(); // weak
// int (*__usercall sub_1000297B<eax>(int a1<ebp>))();
int loc_1000298D(); // weak
int loc_100029B0(); // weak
int __thiscall sub_100029F0(void *this);
int __thiscall sub_10002A30(int this, unsigned int a2);
int __thiscall sub_10002B40(int this, char a2, int a3);
int __thiscall sub_10002C30(int this, unsigned __int8 *a2, int a3, unsigned int a4);
int __thiscall sub_10002D20(int this);
int __thiscall sub_10002D80(int this);
// char __userpurge sub_10002F80<al>(int a1<ecx>, int a2<ebx>, char a3, int a4, int a5, int a6);
char __thiscall sub_10003180(void *this, char a2, int a3);
// int __usercall sub_10003230<eax>(int a1<ecx>, int a2<ebx>);
char __thiscall sub_100032D0(void *this, char a2, char a3, int a4, int a5);
int __fastcall sub_10003420(int a1, int a2, int a3);
// void *__userpurge sub_10003450<eax>(int a1<ecx>, int a2<ebx>, char a3);
void *__thiscall sub_10003480(void *this, int a2);
int __thiscall sub_10003490(int this, int a2);
int __thiscall sub_100034E0(void *this);
// int __userpurge sub_10003520<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, char a4, int a5, int a6, int a7);
int __stdcall sub_100035D0(int a1);
int __thiscall sub_100035E0(int this, int a2);
char __fastcall sub_100036A0(int a1, int a2);
_DWORD __cdecl sub_100036F0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char); // weak
int __thiscall sub_100037D0(void *this, int a2, int a3);
// int __userpurge sub_10003960<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5);
// int __userpurge sub_100039A0<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_100039D0(int this, int a2, int a3, int a4);
char __thiscall sub_10003A60(void *this);
int __thiscall sub_10003B90(int this, unsigned int a2);
// void *__usercall sub_10003C50<eax>(void *a1<ecx>, int a2<ebx>, char a3);
int __fastcall sub_10003CB0(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8);
// int __usercall sub_10003D00<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, unsigned int a4, void *a5, int a6, int a7, int a8, int a9, signed int a10, char a11);
int __thiscall sub_10003E70(int this, unsigned int a2, int a3);
// int __userpurge sub_10004130<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9);
char __thiscall sub_10004210(void *this, char a2, int a3, int a4);
int __fastcall sub_10004310(int a1, int a2);
int __fastcall sub_10004350(int a1, int a2);
int __thiscall sub_100043A0(void *this, int a2, int a3, int a4);
int __thiscall sub_10004460(int this, int a2, int a3, unsigned int a4);
int __thiscall sub_100045A0(void *this, int a2);
int __thiscall sub_10004650(void *this, int a2, int a3, int a4);
// int __usercall sub_10004750<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, char a4);
// int __userpurge sub_100047D0<eax>(int a1<ecx>, int a2<edi>, int a3);
void __thiscall sub_10004910(int this, LPCWSTR pwszObjectName);
void __thiscall sub_10004A70(DWORD_PTR this);
int __thiscall sub_10004A90(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10004B00(int this);
int __thiscall sub_10004B80(int this, int a2);
int __thiscall sub_10004BA0(int this);
// void *__userpurge sub_10004C30<eax>(int a1<ecx>, int a2<ebx>, char a3);
// int __userpurge sub_10004CA0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
// int __userpurge sub_10004CD0<eax>(int a1<ecx>, int a2<ebx>, char a3);
// int __usercall sub_10004D30<eax>(int a1<ecx>, int _EBX<ebx>);
int __thiscall sub_10004DE0(int this, int a2);
// int __userpurge sub_10004E50<eax>(int a1<ecx>, int _EBX<ebx>, char a3);
int __thiscall sub_10004EF0(int this, int a2, int a3, int a4, int a5);
// int __userpurge sub_100050F0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5);
int __fastcall sub_10005130(int a1, int a2, signed int a3, int a4);
int __fastcall sub_10005280(int a1, int a2, int a3, int a4, int a5, int a6, int (__cdecl *a7)(_DWORD, _DWORD));
int __fastcall sub_10005410(int a1, int a2, int a3);
int __stdcall sub_10005450(int a1);
int __fastcall sub_10005480(int a1, int a2, int a3);
void __fastcall sub_100054F0(int a1, int a2);
int __thiscall sub_10005540(int this, int a2, char a3, int a4);
int __thiscall sub_10005660(int this, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
// int __userpurge sub_10005880<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5);
void __cdecl sub_100058C0(int a2);
// int __usercall sub_100058D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
int __thiscall sub_10005980(int this, int a2);
void __thiscall sub_10005A40(int this);
int __thiscall sub_10005B40(int this);
// int __userpurge sub_10005BF0<eax>(int a1<eax>, int a2<ecx>, int _EBX<ebx>, int a4);
// int __usercall sub_10005DA0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
// void __userpurge sub_10005DE0(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
int __thiscall sub_10005FD0(int this, char a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10006050(int this);
char __thiscall sub_10006090(int this, char a2, int a3);
int loc_10006120(); // weak
int loc_10006150(); // weak
void *__thiscall sub_10006160(void *this, char a2);
// int __userpurge sub_10006190<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall sub_10006270(int a1, int a2, unsigned int a3, int (__cdecl *a4)(_DWORD, _DWORD));
int __fastcall sub_10006900(int a1, int a2, int (__cdecl *a3)(_DWORD, _DWORD));
char __cdecl sub_10006970(int a1, int a2);
// int __userpurge sub_100069B0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9);
// int __usercall sub_10006A90<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
// int __usercall sub_10006B10<eax>(int a1<edx>, int a2<ecx>, int a3<edi>);
// int __userpurge sub_10006BC0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4);
int __thiscall sub_10006C80(int this, char a2, int a3);
int __thiscall sub_10006D10(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10006DC0(int this);
int (__stdcall ***__cdecl sub_10006DD0())(char);
int __thiscall sub_10006DE0(void *this);
int __thiscall sub_10006DF0(void *this, char a2);
int __thiscall sub_10006E20(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10006E90(int this);
int __thiscall sub_10006EA0(int this);
void *__thiscall sub_10006EB0(void *this, char a2);
// void __userpurge sub_10006EE0(int *a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_10006FA0(int this, int a2);
int __fastcall sub_10007110(int a1, int a2, int a3, int (__cdecl *a4)(_DWORD, _DWORD));
int __fastcall sub_100072E0(int a1, int a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __fastcall sub_10007420(int a1, int a2, int a3);
int __thiscall sub_10007630(int this, int *a2);
int __thiscall sub_100076D0(int this, int a2, int a3);
void __cdecl sub_10007740(int a1);
// int __usercall sub_10007750<eax>(int a1<eax>, int a2);
int __cdecl loc_10007760(int); // weak
int __thiscall sub_10007940(int this, int a2, int a3);
int __thiscall sub_100079F0(int this);
int loc_10007AD0(); // weak
// int __userpurge sub_10007B20<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
// int __userpurge sub_10007B50<eax>(int a1<ecx>, int a2<ebx>, char a3);
// int __userpurge sub_10007BB0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
// int __userpurge sub_10007D20<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
int __fastcall sub_10007E90(int a1, int a2, int a3);
int __fastcall sub_10007F60(int a1, int a2, int a3);
int *__fastcall sub_10008190(int a1, int a2);
int __fastcall sub_10008260(int a1, int a2, int a3, int a4, int (__cdecl *a5)(_DWORD, _DWORD));
int __fastcall sub_10008350(int a1, int a2, int a3);
// void __usercall sub_100083A0(int a1<ecx>, int a2<ebx>, int a3);
// int __usercall sub_100083B0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
// int __userpurge sub_10008470<eax>(int a1<edx>, int *a2<ecx>, int a3<ebx>, int a4, int a5);
// void __usercall sub_10008530(int a1<ecx>, int a2<ebx>);
// int __userpurge sub_10008620<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __fastcall sub_100086C0(int a1, int a2, int a3, int a4, int (__cdecl *a5)(_DWORD, _DWORD));
int __fastcall sub_10008790(int a1, int a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __fastcall sub_10008860(int a1, int a2, int a3);
// int __userpurge sub_100088D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8);
int __thiscall sub_10008940(void *this, int a2);
int (__stdcall ***__cdecl sub_10008990())(char);
// int __userpurge sub_100089A0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
// int __userpurge sub_10008A40<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9);
// int __userpurge sub_10008B20<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4);
char __thiscall sub_10008BC0(void *this, int a2);
int (__stdcall ***__cdecl sub_10008BD0())(char);
int __thiscall sub_10008BE0(void *this);
int __thiscall sub_10008BF0(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10008C60(int this);
void *__thiscall sub_10008D00(int this, char a2);
// int __userpurge sub_10008D70<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
char __thiscall sub_10008DA0(void *this, int a2);
// int __usercall sub_10008E60<eax>(int a1<eax>, int a2);
// void __userpurge sub_10008F70(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
// int __userpurge sub_100091B0<eax>(int a1<ecx>, int a2<ebx>, int a3);
int (__stdcall ***__cdecl sub_10009200())(char);
void *__thiscall sub_10009210(int this, char a2);
int __thiscall sub_10009270(int this, char a2);
// int __usercall sub_10009300<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4);
void *__thiscall sub_100093C0(void *this, int a2);
void __thiscall sub_10009430(void *this, int a2);
int __thiscall sub_100095F0(int this);
void *__thiscall sub_10009600(void *this, int a2);
// int __usercall sub_100096D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
// int __usercall sub_10009780<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
char __cdecl sub_100097C0(int a1);
int __cdecl sub_100097E0(int a1);
int __thiscall sub_10009800(int this, int a2);
int __thiscall sub_100098C0(void *this, int a2);
// int __userpurge sub_10009980<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_100099A0(void *this);
void *__thiscall sub_100099D0(void *this);
int __fastcall sub_100099E0(int a1, int a2, unsigned int a3);
// int __userpurge sub_10009A40<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10009A60<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10009B30<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, unsigned int a4);
// int (__cdecl *__usercall sub_10009B60<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<ebx>, int a5<edi>, int a6<esi>, int a7, int a8))(int, int);
int __cdecl loc_10009C1E(int, int); // weak
int loc_10009DE0(); // weak
// int __userpurge sub_10009E10<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __usercall sub_10009E30<eax>(const void *a1<ecx>, int a2<edi>, char a3);
// int __usercall sub_10009E90<eax>(int a1<ecx>, int a2<edi>);
// signed int __usercall sub_10009F10<eax>(int a1<ecx>, int a2<ebx>);
void *__thiscall sub_1000A010(void *this, int a2);
int __thiscall sub_1000A090(int this, char a2);
void *__thiscall sub_1000A140(void *this, int a2);
int __fastcall sub_1000A250(int a1, int a2);
// int __usercall sub_1000A320<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
// int __usercall sub_1000A380<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
int loc_1000A390(); // weak
int __stdcall sub_1000A3A0(int a1);
// char __userpurge sub_1000A3B0<al>(int a1<ecx>, int a2<edi>, int a3);
int __cdecl sub_1000A460(int a1);
int __cdecl sub_1000A4E0(int a1);
int loc_1000A500(); // weak
int loc_1000A510(); // weak
int __thiscall sub_1000A520(int this, int a2, int a3);
// int __userpurge sub_1000A5C0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4, int a5);
int __stdcall loc_1000A61C(int, int); // weak
int (__stdcall *__cdecl sub_1000A642())(int, int);
void *__thiscall sub_1000A650(void *this, char a2);
_DWORD __cdecl sub_1000A680(_DWORD); // weak
int __thiscall sub_1000A690(int this);
int (__stdcall ***__cdecl sub_1000A7D0())(char);
char __thiscall sub_1000A7E0(void *this, char a2, char a3, int a4, int a5);
void *__thiscall sub_1000A930(int this, char a2);
int __thiscall sub_1000A960(int this);
int __thiscall sub_1000AA50(void *this);
int __thiscall sub_1000AA70(void *this);
// int (__cdecl *__usercall sub_1000ACA0<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<ebx>, int a5<edi>, int a6<esi>, int a7, unsigned int a8))(int, int);
int __cdecl loc_1000AD55(int, int); // weak
int __thiscall sub_1000AFB0(int this, const char *a2);
int __thiscall sub_1000B010(int this, __int16 a2, char a3, void *a4, int a5, int a6, int a7, int a8, unsigned int a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, int a15, int a16);
void *__thiscall sub_1000B2B0(int this, char a2);
int __thiscall sub_1000B2E0(int this);
char __thiscall sub_1000B410(int this, __int64 a2, __int64 a3, __int64 a4);
int __cdecl sub_1000B970(double a1, __int64 a2, __int64 a3);
int __thiscall sub_1000BA00(void *this, int a2, char a3, int a4, int a5);
void *__thiscall sub_1000BAA0(void *this, char a2);
int __fastcall sub_1000BAD0(int a1, char a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9, int a10);
void __thiscall sub_1000BC10(int this, int a2);
char __thiscall sub_1000BC60(int _ECX);
char __thiscall sub_1000BD30(int _ECX);
char __thiscall sub_1000BE10(int _ECX);
char __thiscall sub_1000BEA0(int this, __int64 a2);
char __thiscall sub_1000C000(int this, __int64 a2);
char __thiscall sub_1000C160(int this, __int64 a2, __int64 a3);
char __fastcall sub_1000C2A0(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8);
void *__thiscall sub_1000C3E0(void *this, int a2);
int __fastcall sub_1000C450(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8);
void *__thiscall sub_1000C4A0(void *this, char a2);
int __thiscall sub_1000C4D0(void *this, int a2, int a3);
char __thiscall sub_1000C4F0(void *this, int a2, int a3);
char __thiscall sub_1000C530(void *this, int a2, int a3);
int __cdecl sub_1000C550();
int __stdcall sub_1000C560(int a1, int a2);
int __cdecl sub_1000C5D0();
int __stdcall sub_1000C5E0(int a1, int a2);
int __cdecl sub_1000C630();
int __stdcall sub_1000C640(int a1, int a2);
int __stdcall sub_1000C6B0(int a1, int a2);
int __thiscall sub_1000C700(void *this);
void *__thiscall sub_1000C710(void *this, char a2);
int __thiscall sub_1000C740(int this, int a2);
void __thiscall sub_1000C770(int this, int a2);
void __thiscall sub_1000C870(int this, int a2);
signed int __stdcall sub_1000C8F0(int a1, int a2, int a3);
void *__thiscall sub_1000C900(void *this, char a2);
// __int16 __userpurge sub_1000C940<ax>(int a1<ecx>, int a2<edi>, __int64 a3);
char __stdcall sub_1000CA40(int a1);
// int __userpurge sub_1000CA90<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __fastcall sub_1000CAB0(int a1, const char *a2);
// void __userpurge SetBalance(int a1<ebx>, unsigned int a2, __int64 a3, const char *a4);
// char __userpurge SetMarket<al>(int a1<ebx>, unsigned int a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7);
// char __userpurge SetMaxSpread<al>(int a1<ebx>, unsigned int a2, __int64 a3);
// char __userpurge S1_SetIndicators<al>(int a1<ebx>, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10);
// char __userpurge S1_OpenLong1<al>(int a1<ebx>, unsigned int a2, __int64 a3);
// char __userpurge S1_OpenShort1<al>(int a1<ebx>, unsigned int a2, __int64 a3);
// signed int __userpurge S1_OpenLong2<eax>(int a1<ebx>, unsigned int a2, __int64 a3);
// char __userpurge S1_OpenShort2<al>(int a1<ebx>, unsigned int a2, __int64 a3);
// signed int __userpurge S1_OpenLong22<eax>(int a1<ebx>, unsigned int a2, signed int a3, __int64 a4, __int64 a5);
// signed int __userpurge S1_OpenShort22<eax>(int a1<ebx>, unsigned int a2, signed int a3, __int64 a4, __int64 a5);
// char __userpurge S1_CloseLong<al>(int a1<ebx>, unsigned int a2, __int64 a3, __int64 a4, unsigned int a5);
// char __userpurge S1_CloseShort<al>(int a1<ebx>, unsigned int a2, __int64 a3, __int64 a4, unsigned int a5);
// char __userpurge S1_CloseDa<al>(int a1<ebx>, unsigned int a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
bool __stdcall CheckVersion(const char *a1);
void __stdcall Initialize(const char *a1, const char *a2, int a3, int a4, const char *a5);
int __cdecl Status();
int __cdecl ErrorCode();
int __cdecl Utc();
// int __userpurge Msg<eax>(int a1<ebx>, int a2, unsigned int a3, int a4);
// signed int __userpurge GetMsg<eax>(int a1<ebx>, int a2, unsigned int a3, int a4, int a5, int a6);
int __fastcall StartExpert(int a1, int a2, int a3, int a4, const char *a5, __int64 a6, unsigned int a7);
char __stdcall StopExpert(unsigned int a1);
int __fastcall sub_1000DBA0(int a1, unsigned int a2);
char __fastcall sub_1000DDD0(unsigned int a1, unsigned int a2);
// int __usercall sub_1000DDF0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
char __thiscall sub_1000DF00(int this, int a2, int a3, int a4, int a5);
char __thiscall sub_1000E050(int this);
char __thiscall sub_1000E2C0(int this, int a2);
char __thiscall sub_1000E530(int this, int a2);
char __thiscall sub_1000E800(int this);
// int __userpurge sub_1000E8B0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5, int a6);
bool __thiscall sub_1000E9A0(int this);
void __thiscall sub_1000E9F0(int this);
bool __thiscall sub_1000EA30(int this);
// char __userpurge sub_1000EA70<al>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// char __userpurge sub_1000EDD0<al>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
char __thiscall sub_1000F050(void *this, int a2);
char __thiscall sub_1000F380(void *this, int a2);
// char __userpurge sub_1000F5C0<al>(int a1<ecx>, int a2<ebx>, int a3);
char __thiscall sub_1000FA50(void *this, int a2, int *a3, int a4, int a5);
char __thiscall sub_1000FBC0(void *this, int a2, int *a3, int a4, int a5);
char __thiscall sub_1000FD10(void *this, int *a2, int a3, int a4);
char __thiscall sub_1000FDD0(int this, int a2);
char __thiscall sub_1000FE20(void *this, int *a2, int a3, int a4);
int __thiscall sub_1000FE80(int this);
int sub_1000FF60(); // weak
int loc_1000FFF0(); // weak
int __fastcall sub_10010010(int a1, int a2, int a3);
// int __usercall sub_100101D0<eax>(int a1<ecx>, int a2<ebx>);
int __fastcall sub_10010260(int a1, int a2, int a3);
char __thiscall sub_100109A0(void *_ECX);
int __thiscall sub_10010A20(void *this);
// int __userpurge sub_10010A90<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4);
// void __usercall sub_10010C30(int a1<ecx>, int a2<ebx>);
int __fastcall sub_10010C90(int a1, int a2, int a3, int a4);
int __fastcall sub_10010E40(int a1, int a2, int a3, int a4, int a5);
int __thiscall sub_10010EA0(void *this, int a2);
// int __userpurge sub_10011140<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
void *__thiscall sub_100111E0(void *this, int a2, unsigned int a3);
void *__thiscall sub_100112C0(void *this, int a2, int a3);
// int __usercall sub_10011360<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
int __fastcall sub_100114C0(int a1, char a2);
int __fastcall sub_10011530(int a1, int a2);
void __thiscall sub_10011A40(int this, int a2);
void *__thiscall sub_10011AD0(void *this, char a2);
int __thiscall sub_10011B00(void *this, int a2, int a3);
// int __userpurge sub_10011B70<eax>(int a1<ecx>, int a2<edi>, int a3);
int __stdcall sub_10011FE0(const char *a1);
int __thiscall sub_10012020(int this, int a2);
_DWORD __stdcall sub_10012050(_DWORD); // weak
int __thiscall sub_10012200(void *this, int a2, int a3);
int __thiscall sub_100124C0(void *this, int a2, int a3);
int __fastcall sub_100126C0(int a1, int a2, int a3);
// int __userpurge sub_100127A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5);
int __thiscall sub_10012870(void *this, int a2);
int __thiscall sub_10012890(int this);
signed int __thiscall sub_10012B20(int this, signed int a2);
signed int __thiscall sub_10012B80(int this);
int __thiscall sub_10012BE0(int this, int a2, __int64 a3, int a4, char a5);
int __thiscall sub_10012DB0(int this, int a2, __int64 a3, __int64 a4, int a5, int a6, char a7);
void *__thiscall sub_10012F00(void *this, char a2);
void *__thiscall sub_10012F70(int this, char a2);
// void *__userpurge sub_10013050<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6);
int __thiscall sub_100130F0(void *this, int a2, int a3, int a4);
void *__thiscall sub_100131B0(void *this, int a2);
int __thiscall sub_10013250(void *this, int a2);
int __thiscall sub_100132D0(void *this, int a2);
int __thiscall sub_10013330(void *this, int a2);
char __stdcall sub_10013390(int a1, int a2);
int __fastcall sub_100133F0(int a1);
void *__thiscall sub_10013410(void *this);
void *__thiscall sub_10013460(void *this);
int __thiscall sub_10013550(int this, int a2);
int __thiscall sub_10013580(int this, int a2);
// int __userpurge sub_100135B0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int **a5, int a6, int a7, int **a8, int a9, int a10);
int __thiscall sub_10013B80(int this, int a2);
// int __userpurge sub_10013CE0<eax>(int a1<ecx>, int a2<edi>, int a3, int a4, int a5, int a6, char a7, unsigned __int8 a8);
int __thiscall sub_10013ED0(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7);
int __thiscall sub_10013F50(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7);
int __thiscall sub_10013FE0(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7, int a8);
int __thiscall sub_10014060(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7, int a8);
// int __userpurge sub_100140E0<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6, unsigned __int8 a7, __int64 a8);
// int __userpurge sub_10014320<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6, unsigned __int8 a7, __int64 a8);
int __thiscall sub_100144D0(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7);
int __fastcall sub_10014540(int a1, int a2, int a3, int a4);
void *__thiscall sub_100145D0(void *this, char a2);
// int __usercall sub_10014830<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<ebp>, int a5<edi>);
// int __userpurge sub_10014A40<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7);
int __cdecl sub_10014AA0(int a1, int a2, char a3, __int16 a4);
int __cdecl sub_10014B60(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8, int a9, int a10, unsigned int a11);
int __cdecl sub_10014FE0(int a1, int a2, int a3, __int16 a4);
int __cdecl sub_10015070(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8);
int __cdecl sub_10015410(int a1, int a2, int a3, int a4, unsigned __int8 *a5, int a6);
int __cdecl sub_10015490(int a1, int a2, int a3, int a4, unsigned __int8 a5, int a6);
int __fastcall sub_10015510(int a1, int a2, int a3, int a4);
// int __usercall sub_100155A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
int __fastcall sub_100155D0(int a1, int a2, int a3);
int __fastcall sub_10015660(int a1, int a2, const char *a3);
int __thiscall sub_10015700(_DWORD); // weak
// int __usercall sub_100159B0<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4);
int __thiscall sub_10015AE0(void *this, int a2, int a3);
// int __usercall sub_10015B60<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int **a4, int a5, int a6, int **a7, int a8, int a9, int **a10, int a11, int a12);
// int __usercall sub_10015C80<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int **a4, int a5, int a6, int **a7, int a8, int a9, int **a10, int a11, int a12);
signed int __fastcall sub_10015DA0(int a1, int a2, int a3, int a4);
int __stdcall sub_100160E0(int a1);
// void __usercall sub_1001618B(int a1<ebp>);
int __thiscall sub_100161A0(int this, int a2, int a3, int a4, int a5);
void __thiscall sub_100163A0(int this);
int __thiscall sub_100163C0(void *this, int a2, int a3, int a4);
// int __usercall sub_10016480<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12);
// int __usercall sub_10016570<eax>(int a1<ecx>, int a2<edi>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
// int __userpurge sub_10016660<eax>(int a1<ebx>, int a2);
// int __userpurge sub_10016710<eax>(int a1<ecx>, int a2<ebx>, int a3, char a4, int a5, int a6, int a7);
int __thiscall sub_10016980(void *this, int a2, int a3, int a4, int a5);
int __fastcall sub_10016B40(int a1, int a2, int a3);
int __thiscall sub_10016BC4(void *this);
void *__thiscall sub_10016BCF(void *this, char a2);
int __thiscall sub_10016CF0(void *this, int a2);
int __thiscall sub_10016D10(void *this, int a2);
int __thiscall sub_10016D30(void *this, int a2);
int __thiscall sub_10016D50(int this, int a2);
int __thiscall sub_10016DD0(int this, char a2);
char __thiscall sub_10016E20(int this);
char __thiscall sub_10016E30(int this);
int __thiscall sub_10016E40(int this, int a2);
int __thiscall sub_10016EA0(int this, int a2);
int __thiscall sub_10016F00(int this, int a2);
int __thiscall sub_10016F60(int this);
// int __userpurge sub_10016F80<eax>(int a1<ecx>, int a2<edi>, int a3, char a4);
signed int __fastcall sub_100170E0(int a1, int a2, int a3, int a4);
// int __usercall sub_100171B0<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4);
int __thiscall sub_100172E0(int this, char a2);
signed int __stdcall sub_10017330(int a1);
__int64 __cdecl sub_10017340();
__int64 __thiscall sub_10017350(int this);
signed int __cdecl sub_10017370();
int __thiscall sub_10017380(void *this);
int __thiscall sub_100173B0(int this, void *a2, unsigned int a3, int a4);
__int64 __thiscall sub_100174C0(int this);
int __thiscall sub_100174E0(int this, const void *a2, unsigned int a3, int a4);
int __stdcall sub_100175F0(int a1, int a2, int a3, int a4, int a5);
int __stdcall sub_10017620(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
void *__thiscall sub_10017650(void *this, int a2, int a3, int a4);
void *__thiscall sub_100176B0(void *this, char a2);
void *__thiscall sub_100176F9(void *this, char a2);
int __thiscall sub_10017701(void *this);
// int __usercall sub_10017710<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<ebp>, int a5<edi>);
// int __userpurge sub_100177A0<eax>(int a1<ecx>, int a2<ebx>, char a3);
int *__thiscall sub_10017800(void *this, int *a2, int a3);
// int __userpurge sub_10017830<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned __int8 a4);
int *__thiscall sub_10017850(void *this, int *a2, int a3);
// int __userpurge sub_10017880<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned __int8 a4);
int __stdcall sub_100178A0(const void *a1, int a2, void *a3);
int __stdcall sub_100178C0(const void *a1, int a2, int a3, void *a4);
char __stdcall sub_100178E0(char a1, int a2);
// int __userpurge sub_100178F0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
int loc_100179C0(); // weak
// void __usercall sub_100179E0(void *this<ecx>, int a2<ebx>);
signed int __fastcall sub_10017A80(int a1, int a2, int a3, int a4);
// int __usercall sub_10017B50<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4);
char __stdcall sub_10017C80(char a1);
// int __userpurge sub_10017C90<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6);
void __thiscall sub_10017D50(void *this);
int __thiscall sub_10017D70(int this, int a2);
int loc_10017D90(); // weak
int __thiscall sub_10017DB0(void *this);
int loc_10017E2C(); // weak
int (*__cdecl sub_10017E3E())();
int loc_10017E50(); // weak
int __cdecl sub_10017E80();
int __thiscall sub_10017E90(void *this, const char *a2, int a3);
// int __userpurge sub_10017F60<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10017F90<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_10018060(int this);
void *__thiscall sub_10018150(void *this, int a2);
char __thiscall sub_100181E0(int this, int a2, signed int a3, unsigned __int8 a4);
void *__thiscall sub_100182F0(void *this, char a2);
int __thiscall sub_10018340(void *this);
void *__thiscall sub_10018350(void *this);
int __stdcall sub_10018370(int a1, int a2);
int loc_100183B0(); // weak
int __fastcall sub_100183F0(int a1, int a2);
void *__thiscall sub_10018420(int this, char a2);
int __fastcall sub_10018470(int a1);
void *__thiscall sub_100184D0(int this, char a2);
int __thiscall sub_10018500(int this, int a2);
int loc_10018540(); // weak
char __thiscall sub_10018590(void *this, int a2);
int loc_10018B70(); // weak
void __thiscall sub_10018BD0(void *this, __int64 a2, int a3);
void __thiscall sub_10018DA0(void *this, int a2, int a3, int a4);
void __thiscall sub_10018E10(int this, unsigned int a2);
int __thiscall sub_10018EE0(int this);
int __thiscall sub_10018F50(int this, int a2, int a3, int a4, int a5);
int __thiscall sub_10019030(int this, int a2, int a3);
int __thiscall sub_100190D0(int this, int a2);
int __thiscall sub_10019200(int this, int a2);
int __thiscall sub_10019310(int this);
int __thiscall sub_10019410(int this, int a2);
// int __userpurge sub_10019500<eax>(int a1<ecx>, int a2<edi>, int a3, int a4);
char __fastcall sub_100195A0(int a1, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10019740(int this);
void __thiscall sub_10019810(int this, int a2);
int loc_100198B0(); // weak
int loc_10019910(); // weak
LPVOID __thiscall sub_10019980(LPVOID *this);
signed int __thiscall sub_100199B0(void *this, int a2);
int __thiscall sub_10019A90(int this, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __thiscall sub_10019BE0(int this, unsigned int a2);
int __thiscall sub_10019D80(void *this, int a2, int a3);
// void *__userpurge sub_10019E30<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6);
int __thiscall sub_10019F10(int this, int a2, int a3, int a4, int a5);
char __thiscall sub_1001A270(int this, int a2, int a3);
void *__thiscall sub_1001A420(void *this, int a2);
// char __userpurge sub_1001A460<al>(int a1<ecx>, int a2<ebx>, int a3<edi>, __int16 a4);
// bool __userpurge sub_1001A530<eax>(int a1<ecx>, char a2<bl>, unsigned __int8 a3, int a4);
void __thiscall sub_1001A620(int this, int a2, int a3);
int __thiscall sub_1001A6E0(void *this, int a2, unsigned int a3);
void *__thiscall sub_1001A740(void *this, int a2);
int __thiscall sub_1001A830(int this, unsigned int a2);
int __thiscall sub_1001A8D0(int this);
void *__thiscall sub_1001A970(int this, char a2);
// int __usercall sub_1001A9A0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
int __thiscall sub_1001AA20(int this, int a2);
int __thiscall sub_1001AA80(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_1001ABB0(void *this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_1001ACB0(int this, int a2);
int __thiscall sub_1001ADC0(int this, unsigned int a2);
int __thiscall sub_1001AEF0(void *this, int a2, int a3, int a4);
// bool __userpurge sub_1001AF20<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6);
int __thiscall sub_1001AF60(void *this, int a2, const CHAR *a3, UINT a4);
int __stdcall sub_1001B070(int a1, int a2);
int __thiscall sub_1001B0B0(int this, int a2, int a3);
// void *__userpurge sub_1001B110<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __thiscall sub_1001B150(int this, int a2);
int __thiscall sub_1001B170(int this, int a2, int a3, int a4);
int __thiscall sub_1001B330(int this, int a2, int a3, int a4);
int __thiscall sub_1001B450(int this, unsigned int a2, int a3);
int __thiscall sub_1001B4D0(void *this, int a2, void *a3, const void *a4);
int __thiscall sub_1001B770(int this, int a2);
// int __userpurge sub_1001B7B0<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6);
int __thiscall sub_1001B890(_DWORD); // weak
int __fastcall sub_1001BE80(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, char a8);
int __fastcall sub_1001BF10(int a1, int a2, int a3, int a4);
char __fastcall sub_1001BFA0(unsigned __int8 a1, int a2, void *a3);
int __fastcall sub_1001C250(int a1, int a2, int a3);
void *__thiscall sub_1001C280(void *this, int a2, int a3);
void __fastcall sub_1001C2C0(int _ECX, int a2);
int __fastcall sub_1001C2E0(int a1, int a2, int a3);
// int __usercall sub_1001C310<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4);
signed int __fastcall sub_1001C440(int a1, int a2, int a3, void *a4);
int __thiscall sub_1001C530(int this, int a2);
char __thiscall sub_1001C5A0(void *this);
int __thiscall sub_1001C750(int this);
// int __userpurge sub_1001C870<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6);
int __fastcall sub_1001C8F0(int a1, int a2, int a3);
// int __userpurge sub_1001C990<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// int __usercall sub_1001CA00<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
char __thiscall sub_1001CA70(void *this, int a2);
char __thiscall sub_1001CC80(void *this, int a2, char a3, signed int a4);
char __thiscall sub_1001CEF0(int this, int a2);
char __thiscall sub_1001D0F0(int this);
// int __usercall sub_1001D220<eax>(char a1<dl>, int a2<ecx>, __int16 a3<bx>, int a4, int a5, int a6, int a7, __int16 a8, char a9);
int __fastcall sub_1001D2B0(int a1, int a2, int a3, int a4, int a5, int a6, char a7);
int __fastcall sub_1001D4B0(int a1, int a2, int a3, int *a4, int a5, char a6, char a7);
int __fastcall sub_1001D560(int a1, int a2, int a3, int a4, int a5, int a6, char a7);
int __thiscall sub_1001D600(void *this, int a2, int a3, int a4);
int __fastcall sub_1001D7A0(int a1, int a2, int a3);
void __fastcall sub_1001D7D0(int a1, int a2);
// signed int __usercall sub_1001D7F0<eax>(signed int result<eax>, int a2<ecx>, int a3, unsigned int a4, int a5, int a6);
void __fastcall sub_1001D840(int a1, int a2);
int __thiscall sub_1001D860(int this, int a2);
// char __userpurge sub_1001D8D0<al>(int a1<ecx>, char a2<bl>, int a3, int a4);
char __thiscall sub_1001D9C0(int this);
char __thiscall sub_1001DA00(void *this);
char __thiscall sub_1001DE90(int this);
// int __usercall sub_1001DED0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __userpurge sub_1001DF40<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
int __fastcall sub_1001E000(int a1, int a2, int a3, int a4);
char __thiscall sub_1001E0A0(void *this, int a2, char a3);
// int __usercall sub_1001E340<eax>(char a1<dl>, int a2<ecx>, __int16 a3<bx>, int a4, int a5, int a6, int a7, int a8);
int __fastcall sub_1001E540(int a1, char a2, int a3, int *a4, int a5, int a6, char a7);
int __fastcall sub_1001E5F0(int a1, char a2, int a3, int a4, int a5, int a6);
void *__thiscall sub_1001E690(void *this, int a2, int a3, unsigned int a4, int a5, int a6, int a7, unsigned int a8);
void *__thiscall sub_1001E710(void *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
// int __usercall sub_1001E800<eax>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>);
// int __usercall sub_1001EB70<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_1001EBD0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_1001EC30<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __userpurge sub_1001EC90<eax>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>, int a5);
int __thiscall sub_1001EDA0(int this, int a2, int a3);
void *__thiscall sub_1001EE10(void *this, int a2, int a3);
char __thiscall sub_1001EE40(int this);
// char __userpurge sub_1001EE60<al>(int a1<ecx>, char a2<bl>, char a3);
// signed int __usercall sub_1001F1E0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>);
// int __userpurge sub_1001F270<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, char a4);
// int __usercall sub_1001F2A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __userpurge sub_1001F330<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// int __userpurge sub_1001F3A0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5, char a6);
// int __usercall sub_1001F4E0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
void *__thiscall sub_1001F560(void *this, int a2, int a3);
// void *__userpurge sub_1001F590<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __thiscall sub_1001F5C0(int this, int a2, int a3);
int __thiscall sub_1001F6A0(int this);
char __thiscall sub_1001F930(int this, char a2);
int __thiscall sub_1001F9B0(void *this, int a2, int a3, char a4);
// int __userpurge sub_1001FA70<eax>(int a1<edx>, int a2<ecx>, __int16 a3<bx>, int a4, int a5);
// int __userpurge sub_1001FCD0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, char a4);
// char __userpurge sub_1001FDE0<al>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>, int a5);
// int __userpurge sub_1001FED0<eax>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>, int a5);
int __thiscall sub_1001FFE0(int this, int a2, int a3, int a4, int a5);
char __stdcall sub_10020320(int a1, int a2, int a3);
char __thiscall sub_100203A0(int this, int a2, int a3, int a4);
int __fastcall sub_10020540(int a1, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_100205B0(void *this, int a2, int a3, int a4);
void *__thiscall sub_10020740(void *this, int a2, int a3);
int __fastcall sub_10020770(int a1, int a2, int a3);
int __thiscall sub_100208A0(void *this, int a2, int a3);
int __thiscall sub_10020A40(void *this, int a2);
int __thiscall sub_10020BA0(void *this, int a2, char a3, int a4, int a5);
int __fastcall sub_10020C70(int a1, char a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9, int a10);
int __thiscall sub_10020D90(int _ECX, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6, int a7, __int64 a8, int a9, int a10);
char __fastcall sub_10020ED0(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8);
void *__thiscall sub_10021010(void *this, void *a2);
int __fastcall sub_10021080(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8);
int __thiscall sub_100210D0(void *this, int a2, char a3, int a4, int a5);
int __fastcall sub_10021170(int a1, char a2, char a3, void *a4, int a5, int a6, int a7, int a8, unsigned int a9, int a10, int a11);
char __thiscall sub_100212A0(int _ECX);
char __thiscall sub_10021330(int _ECX);
char __fastcall sub_100213C0(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8);
// int *__usercall sub_10021500<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_100217D0<eax>(int a1<ebx>);
void __stdcall sub_10021A90(int a1, int a2, void *a3, int a4, int a5, int a6, unsigned int a7, signed int a8, void *a9, int a10, int a11, int a12, int a13, signed int a14, void *a15, int a16, int a17, int a18, unsigned int a19, unsigned int a20);
void __thiscall sub_10021CA0(void *this, void *a2, int a3, int a4, int a5, int a6, unsigned int a7);
// int __userpurge sub_10021D60<eax>(int a1<ebx>, char a2);
// int __userpurge sub_10021E10<eax>(int a1<ebx>, unsigned int a2);
int __stdcall sub_10021EA0(int a1);
// void __userpurge sub_10021F90(int a1<ecx>, int a2<ebx>, int a3);
// BOOL __userpurge sub_100220F0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
void __thiscall sub_100221F0(int this, int a2);
int __thiscall sub_10022280(void *this, int a2);
int __thiscall sub_10022720(void *this, char a2, int a3);
int __stdcall loc_10022A17(char, int); // weak
// int (*__usercall sub_10022A7D<eax>(int a1<ebp>))();
int loc_10022B00(); // weak
// int (__stdcall *__usercall sub_10022B17<eax>(int a1<ebp>))(char, int);
// int __userpurge sub_10022BA0<eax>(int a1<ecx>, int a2<edi>, int a3, void *a4, int a5, int a6, int a7, int a8, unsigned int a9, __int64 a10, __int64 a11);
int __thiscall sub_10022F30(int this, int *a2);
int __thiscall sub_10022FB0(_DWORD); // weak
int __thiscall sub_10022FC0(int this, unsigned int a2);
int __thiscall sub_100230B0(_DWORD); // weak
// int __usercall sub_100230C0<eax>(int a1<ecx>, int a2<ebx>);
signed int __thiscall sub_10023170(void *this, int a2, int a3);
signed int __thiscall sub_100231B0(void *this, int a2, int a3);
char __cdecl sub_100231F0();
int __thiscall sub_10023230(int this);
int __stdcall sub_100232E0(int a1);
char __thiscall sub_10023300(int this, int a2);
char __thiscall sub_10023320(void *this, int a2);
int __thiscall sub_10023350(int this);
int __thiscall sub_10023370(void *this, int a2);
int __thiscall sub_100233A0(int this, int a2);
int __thiscall sub_100233D0(int this, unsigned int a2);
unsigned int __thiscall sub_100233F0(int this, int a2);
int loc_10023420(); // weak
// int __usercall sub_10023430<eax>(int a1<ecx>, int a2<ebx>);
signed int __stdcall sub_100236B0(int a1, int a2);
int __thiscall sub_100236C0(void *this, int a2);
// char __userpurge sub_10023770<al>(int a1<ecx>, int a2<ebx>, int a3);
void __thiscall sub_100237A0(void *this);
int loc_100238B0(); // weak
char __cdecl sub_100238C0();
// void __usercall sub_100238D0(void *a1<ecx>, int a2<ebx>);
void __thiscall sub_10023A00(int this, int a2, int a3);
void __thiscall sub_10023BE0(void *this);
int __fastcall sub_10023CA0(int a1);
int __stdcall sub_10023CE0(int a1, int a2, int a3);
int __stdcall sub_10023D00(int a1, int a2, int a3);
int __stdcall sub_10023D60(void *a1);
int loc_10023D80(); // weak
// void __usercall sub_10023D90(int a1<ecx>, int a2<ebx>, int a3<edi>);
int __thiscall sub_10023E50(int this, int a2);
char __thiscall sub_10023E80(int this, int a2);
int __thiscall sub_10023EB0(void *this);
int __thiscall sub_10023F10(int this, int a2);
// unsigned int __userpurge sub_10023F40<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_10024000(int this);
char __thiscall sub_10024090(int this, int a2);
char __thiscall sub_100240C0(int this, int a2);
bool __thiscall sub_100240E0(int this);
int __thiscall sub_100240F0(int this, int a2);
int __thiscall sub_10024110(int this, int a2);
// void __usercall sub_10024130(int a1<ecx>, int a2<ebx>, int a3<edi>);
void __thiscall sub_100241E0(void *this, int a2);
void __thiscall sub_100242A0(void *this, int a2);
void __thiscall sub_10024360(void *this);
char __thiscall sub_10024490(void *this, int a2, int a3);
void __thiscall sub_10024570(void *this, int a2, int a3);
int __thiscall sub_10024720(void *this, int a2);
int __thiscall sub_10024740(void *this, int a2);
int __thiscall sub_100247D0(void *this, int a2);
int __thiscall sub_100247E0(void *this, int a2);
int __thiscall sub_10024860(int this);
int __thiscall sub_10024870(int this);
int __thiscall sub_100248A0(int this, int a2);
// void *__userpurge sub_100248C0<eax>(int a1<ecx>, int a2<ebx>, char a3);
void *__thiscall sub_100248F0(int this, char a2);
void *__thiscall sub_10024920(void *this, char a2);
// void *__userpurge sub_10024950<eax>(int a1<ecx>, int a2<ebx>, char a3);
void *__thiscall sub_10024980(void *this, char a2);
// void *__userpurge sub_100249B0<eax>(void *a1<ecx>, int a2<ebx>, char a3);
// void *__userpurge sub_100249E0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
// void *__userpurge sub_10024A60<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
int __thiscall sub_10024B00(int this);
int __thiscall sub_10024BC0(int this);
char __thiscall sub_10024CD0(int this, int a2);
int loc_10024D30(); // weak
// int __usercall sub_10024D60<eax>(int a1<ecx>, int a2<ebx>);
int __thiscall sub_10024E30(int this, int a2, int a3);
int __thiscall sub_10024ED0(int this);
int __thiscall sub_10024F90(void *this);
char __thiscall sub_10025010(int this, int a2);
int __thiscall sub_100250F0(int this, int a2);
char __thiscall sub_10025170(void *this);
void __thiscall sub_100251D0(void *this, int a2);
int __cdecl sub_100253C0(int a1);
// int __usercall sub_100253D0<eax>(int a1<ecx>, int a2<ebx>);
int __thiscall sub_10025470(int this, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_10025510<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
int __thiscall sub_100255C0(int this);
// int __userpurge sub_10025640<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
int __thiscall sub_10025670(int this, char a2);
int __fastcall sub_100257B0(int a1, int a2, unsigned int a3);
void __thiscall sub_10025860(int this);
int __fastcall sub_10025950(int a1, int a2);
int __thiscall sub_100259F0(int this, int a2, int a3, int a4);
int __thiscall sub_10025B70(int this, int a2, int a3);
char __thiscall sub_10025C00(int this, int a2);
// int __userpurge sub_10025D20<eax>(int a1<ecx>, int a2<edi>, int a3);
void __thiscall sub_10025D80(int this, int a2);
// void *__userpurge sub_10025ED0<eax>(int a1<ecx>, int a2<ebx>, char a3);
// void __usercall sub_10025F00(int a1<ecx>, int a2<ebx>);
int __fastcall sub_10025F80(int a1, int a2, int a3, int a4);
// int __userpurge sub_10025FC0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5);
int __thiscall sub_10026000(int this, int a2, int a3);
char __thiscall sub_10026060(void *this, char a2, char a3, int a4, int a5);
int __thiscall sub_100261B0(int this, char a2);
int __fastcall sub_10026260(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
// int __userpurge sub_10026350<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9);
// int __userpurge sub_10026430<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
int __thiscall sub_10026500(int this, int a2);
int __thiscall sub_100265C0(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10026630(int this, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_100266B0<eax>(int a1<ecx>, int a2<ebx>);
// int __usercall sub_100266D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
int __thiscall sub_10026710(int this, int a2, int a3);
// char __usercall sub_10026770<al>(int a1<edx>, int a2<ecx>, int a3<ebx>);
int __fastcall sub_100268D0(int a1, int a2, int a3);
int __fastcall sub_10026900(int a1, int a2, int a3);
// int __usercall sub_10026980<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
void __cdecl sub_10026A30(int a1);
// int __usercall sub_10026A40<eax>(int a1<eax>, int a2);
int __cdecl loc_10026A50(int); // weak
int *__thiscall sub_10026C50(int this);
int __thiscall sub_10026D10(int this, int a2, int a3);
// char __userpurge sub_10026E30<al>(int a1<ecx>, int a2<ebx>, int a3, int a4);
int __thiscall sub_10026F10(void *this);
void __thiscall sub_10026FD0(void *this, int a2);
void __thiscall sub_10027090(void *this);
int __thiscall sub_10027190(int this, int a2, int a3);
int __thiscall sub_100273C0(void *this, int a2);
int __thiscall sub_100273D0(void *this, int a2);
bool __thiscall sub_100273E0(void *this, int a2, int a3);
void *__thiscall sub_10027570(int this, char a2);
void *__thiscall sub_100275E0(void *this, char a2);
char __thiscall sub_10027610(int this);
// void __userpurge sub_10027860(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
int __thiscall sub_10027A80(int this, char a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10027B00(int this, char a2, int a3, int a4, int a5, char *a6);
int __thiscall sub_10027B90(int this, char a2, int a3);
// int __usercall sub_10027C20<eax>(int a1<edx>, int a2<ecx>, int a3<edi>);
int __thiscall sub_10027D10(int this, int a2);
int (__stdcall ***__cdecl sub_10027D30())(char);
int __thiscall sub_10027D80(int this, int a2);
int (__stdcall ***__cdecl sub_10027DA0())(char);
int __thiscall sub_10027DF0(int this, int a2);
int (__stdcall ***__cdecl sub_10027E10())(char);
void __thiscall sub_10027E60(int this, int a2);
int (__stdcall ***__cdecl sub_10027EE0())(char);
int (__stdcall ***__cdecl sub_10027F30())(char);
// BOOL __userpurge sub_10027F80<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
int (__stdcall ***__cdecl sub_10027F90())(char);
// int __userpurge sub_10027FA0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
int (__stdcall ***__cdecl sub_10028030())(char);
// int __userpurge sub_10028040<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
// int __userpurge sub_100280E0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4);
int (__stdcall ***__cdecl sub_100281B0())(char);
void *__thiscall sub_100281C0(int this, char a2);
// void *__userpurge sub_10028225<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
int __thiscall sub_10028230(int this);
// int __userpurge sub_10028240<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall j_nullsub_2(_DWORD); // weak
// int __userpurge sub_10028270<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10028290<eax>(int a1<ecx>, int a2<ebx>, int a3);
DWORD __thiscall sub_100282B0(int this);
char __thiscall sub_100282E0(int this);
// int __usercall sub_10028360<eax>(int a1<ecx>, int a2<edi>);
int __thiscall sub_10028530(void *this, int a2, DWORD a3);
int __fastcall sub_100285D0(int a1, DWORD a2);
HINTERNET __cdecl sub_100286F0();
// void *__userpurge sub_100287F0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
// int __usercall sub_10028820<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
int __thiscall sub_100288F0(int this, int a2);
int __thiscall sub_10028AB0(void *this, int a2);
void __thiscall sub_10028AC0(int this, LPCWSTR pwszObjectName);
void __thiscall sub_10028C20(DWORD_PTR this);
int __stdcall sub_10028D60(char a1, int a2);
void __thiscall sub_10028EB0(DWORD_PTR dwContext, LPVOID lpOptional, DWORD dwOptionalLength, DWORD dwTotalLength, LPCWSTR lpszHeaders);
// void __userpurge fnInternetCallback(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, unsigned int a6, int a7, int a8);
int __thiscall sub_10029260(int this, int a2);
// void *__usercall sub_10029320<eax>(void *a1<ecx>, int a2<ebx>, char a3);
// int __userpurge sub_10029380<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1002939B<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_100293B6<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_100293D1<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_100293EC<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_10029410(void *this, int a2);
// void __usercall sub_10029440(int a1<ecx>, int a2<ebx>);
// void *__userpurge sub_1002944B<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __cdecl sub_10029470(int a1);
void __cdecl sub_10029530();
void __cdecl sub_10029561();
void __cdecl sub_10029585(int a1);
void __cdecl sub_100295B3(int a1);
int __cdecl sub_100295E1(int); // weak
int __cdecl sub_10029607(int a1);
int __cdecl sub_10029631(int a1);
// int __usercall sub_1002965B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int dwBytes);
int __cdecl sub_10029664(int a1, int a2, int a3);
int __cdecl sub_1002967E(int a1, int a2, int a3);
int __thiscall sub_10029692(int this, int a2);
char __cdecl sub_100296B7(int a1);
void *__thiscall sub_100296F4(int this);
int sub_10029736(void); // weak
void *__thiscall sub_1002973B(void *this, char a2);
int __thiscall sub_10029778(int this);
// void __usercall sub_100297B1(int a1<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>);
int __fastcall sub_100297DC(int a1, int a2, int a3);
// void *__userpurge sub_10029830<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
// int __usercall sub_1002984F<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
int __cdecl sub_10029877();
// int __usercall sub_1002987D<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __usercall sub_100298F9<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
int __cdecl sub_10029952(int a1, const CHAR *a2);
void __cdecl sub_1002999D(int a1);
// void *__usercall sub_100299B7<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, char a5);
int __cdecl sub_100299D6(int a1);
int __cdecl sub_100299FE(int a1);
// void __usercall sub_10029A1D(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
void *__thiscall sub_10029A47(void *this);
// int __userpurge sub_10029A76<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5);
void __thiscall sub_10029AD2(void *this);
// int __usercall sub_10029AF6<eax>(int a1<ebx>, int a2<edi>, int a3);
// int __usercall sub_10029B62<eax>(int a1<ebx>, int a2<edi>, int a3, int MultiByteStr);
// int __usercall sub_10029C5F<eax>(int a1<ebx>, int a2<edi>, int a3, int MultiByteStr);
int __cdecl sub_10029D5C(int a1);
// int __usercall sub_10029DC5<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_10029DE6<eax>(int a1<ebx>, int a2, int a3, int a4, int a5, int a6);
signed int __cdecl sub_10029E7B(LPWSTR lpDestStr, int a2, LPCSTR lpMultiByteStr, UINT CodePage, int a5);
DWORD __cdecl sub_10029F21();
int __fastcall sub_10029F48(int a1, int a2, unsigned int a3);
int __thiscall sub_10029FB5(int this);
// void __usercall sub_10029FBF(int a1<ecx>, int a2<ebx>);
int __thiscall sub_10029FCF(int this);
int sub_1002A028(); // weak
int __thiscall sub_1002A02D(int this, char a2);
// void *__userpurge sub_1002A07B<eax>(int a1<ecx>, int a2<ebx>, char a3);
char __thiscall sub_1002A09A(int this);
int __thiscall sub_1002A0BD(void *this);
char __thiscall sub_1002A0FD(int this, int a2);
int __thiscall sub_1002A146(int this, int a2);
// int __userpurge sub_1002A17E<eax>(int a1<ebp>, int a2, int a3, int a4);
_DWORD __stdcall sub_1002A233(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __thiscall sub_1002A371(int this);
PVOID __cdecl sub_1002A3B2(PVOID Ptr);
void __cdecl sub_1002A3E0(LPCRITICAL_SECTION lpCriticalSection);
int __cdecl sub_1002A3EE(LPCRITICAL_SECTION lpCriticalSection); // idb
void __cdecl sub_1002A405(LPCRITICAL_SECTION lpCriticalSection);
void __cdecl sub_1002A413(LPCRITICAL_SECTION lpCriticalSection);
// int __usercall sub_1002A421<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, unsigned int a4, int a5);
// void __usercall sub_1002A486(int a1<ebx>, int a2);
// int __usercall sub_1002A49B<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, int ecx0<ecx>, char a4);
_DWORD __cdecl sub_1002A4AA(LPVOID lpMem); // weak
void *__cdecl sub_1002A4B0(void *a1, const void *a2, unsigned int a3);
int __cdecl loc_1002A6F8(int, int, int); // weak
int __cdecl off_1002A7E8(int, int, int); // weak
int __cdecl loc_1002A7F8(int, int, int); // weak
int __cdecl loc_1002A884(int, int, int); // weak
// __int64 __usercall sub_1002AAF4<edx:eax>(int a1<ebx>, int a2, int a3);
// __int64 __usercall sub_1002ADA0<edx:eax>(int a1<ebx>, int a2);
// int __usercall sub_1002ADB1<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int dwBytes);
int __thiscall sub_1002AE1B(int this, char a2);
// int __userpurge sub_1002AE36<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_1002AE51(int this, char a2);
// int __userpurge sub_1002AE6D<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_1002AE88(int this, char a2);
int __thiscall sub_1002AEA4(int this, int *a2);
int __thiscall sub_1002AEC9(int this, int a2, int a3);
// int __userpurge sub_1002AEE4<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_1002AF07(int this);
// void __usercall sub_1002AF18(int a1<ecx>, int a2<ebx>);
// int __userpurge sub_1002AF23<eax>(int a1<ecx>, int a2<ebx>, int a3);
// void *__userpurge sub_1002AF56<eax>(int a1<ecx>, int a2<ebx>, char a3);
void __thiscall sub_1002AF7B(void *this, int a2);
// void __usercall sub_1002AFB9(int a1<ecx>, int a2<ebx>);
int __thiscall sub_1002AFD5(int this);
// signed int __usercall sub_1002AFE5<eax>(int a1<ecx>, int a2<ebx>);
// void __usercall sub_1002B014(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, PVOID Ptr);
PVOID __cdecl sub_1002B054(PVOID Ptr);
// int __usercall sub_1002B10A<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, void *a5);
signed int __stdcall sub_1002B11F(int a1, int a2, int a3, void (__thiscall *a4)(_DWORD));
int __stdcall sub_1002B18E(int a1, int a2, int a3, int (*a4)(void));
int __thiscall sub_1002B1EC(int this, int a2, int a3, int a4);
void *__thiscall sub_1002B21D(void *this, char a2);
int __thiscall sub_1002B23D(void *this, int a2);
int __thiscall sub_1002B26C(void *this, int a2);
// int __userpurge sub_1002B29A<eax>(int a1<ebp>, int a2);
int __thiscall sub_1002B34B(int this);
// int __usercall sub_1002B353<eax>(void *this<ecx>, int a2<ebp>);
// int __userpurge sub_1002B396<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6);
int __thiscall sub_1002B3CF(int this, int a2);
PVOID __thiscall sub_1002B434(PVOID Parameter, DWORD DueTime);
int __thiscall sub_1002B4FD(int this);
int __thiscall sub_1002B509(int this);
LPCRITICAL_SECTION __thiscall sub_1002B519(LPCRITICAL_SECTION lpCriticalSection);
int __thiscall sub_1002B52D(int this);
// int __userpurge sub_1002B544<eax>(int a1<ebp>, int a2);
// int __userpurge sub_1002B589<eax>(int a1<ebp>, int a2);
int __thiscall sub_1002B5CC(int this);
// int __userpurge sub_1002B5EC<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_1002B607(int this);
// int __userpurge sub_1002B62D<eax>(int a1<ebp>, int a2);
// int __userpurge sub_1002B672<eax>(int a1<ebp>, int a2);
// int __userpurge sub_1002B6B7<eax>(int a1<ecx>, int a2<ebx>, int a3);
void __thiscall sub_1002B6CE(LPCRITICAL_SECTION lpCriticalSection);
void __cdecl sub_1002B6D6();
void __thiscall sub_1002B6DD(void *this);
int __thiscall nullsub_2(_DWORD); // weak
char __thiscall sub_1002B6E5(void *this);
// int __userpurge sub_1002B6EC<eax>(void *this<ecx>, int ebx0<ebx>, unsigned int a2);
// LPVOID __usercall sub_1002B772<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
int __thiscall sub_1002B794(int this);
int __stdcall sub_1002B7B2(int a1, int a2, int a3);
int __stdcall Callback(int a1, int a2);
// int __usercall sub_1002B82A<eax>(int this<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>);
char __thiscall sub_1002B84F(void *this);
int __thiscall sub_1002B872(void *this, int a2);
int __thiscall sub_1002B8A0(int this, int a2);
int __thiscall sub_1002B8F3(int this);
void __thiscall sub_1002B91E(LPCRITICAL_SECTION lpCriticalSection);
DWORD __thiscall sub_1002B926(void *this, int a2);
int __thiscall sub_1002B95B(void *this);
int __thiscall sub_1002B98B(void *this);
bool __thiscall sub_1002B9BF(int this, int a2, char a3);
char __thiscall sub_1002BA5E(int this, int a2, char a3);
int __thiscall sub_1002BAEE(void *this);
void __thiscall sub_1002BB04(int this);
int __thiscall sub_1002BB1C(void *this);
int __cdecl sub_1002BB3C();
void __thiscall sub_1002BB53(LPCRITICAL_SECTION lpCriticalSection);
int __cdecl sub_1002BB6D();
int __thiscall sub_1002BB75(void *this);
char __thiscall sub_1002BB86(void *this, int a2);
int __thiscall sub_1002BBBF(int this, int a2);
char __thiscall sub_1002BBE3(int this, int a2);
char __thiscall sub_1002BC26(void *this);
int __thiscall sub_1002BC93(int this, int a2);
char __thiscall sub_1002BCE2(void *_ECX);
DWORD __cdecl sub_1002BD66();
int __cdecl sub_1002BD6C(int a1, int a2, int a3);
int __thiscall sub_1002BDA5(void *this);
// char __usercall sub_1002BDD3<al>(int a1<ecx>, int a2<ebx>);
int loc_1002BE77(); // weak
int __thiscall sub_1002BEFE(int this, int a2, char a3, char a4);
_DWORD __stdcall sub_1002BF47(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __thiscall sub_1002BFF0(int this);
int __thiscall sub_1002C00B(int this, int a2, char a3, char a4);
int __thiscall sub_1002C03B(int this, int a2, char a3, char a4);
int __thiscall sub_1002C06C(int this);
int __thiscall sub_1002C08C(int this);
unsigned int __thiscall sub_1002C0B5(void *this);
// int __usercall sub_1002C0CF<eax>(int a1<ebp>);
// void *__userpurge sub_1002C144<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __stdcall sub_1002C173(int a1, int a2, int a3);
int __stdcall sub_1002C1C0(int a1, int a2);
int __cdecl sub_1002C20E();
int __thiscall sub_1002C2AC(int this);
char __thiscall sub_1002C2CB(int this);
char __thiscall sub_1002C304(int this, int a2, int a3);
char __thiscall sub_1002C353(void *this, int a2, int a3);
char __thiscall sub_1002C390(void *this, int a2, int a3);
int __thiscall sub_1002C3C9(void *this);
int __thiscall sub_1002C403(int this, int a2, int a3);
int __cdecl sub_1002C4A7(int a1, char a2);
char __thiscall sub_1002C4E0(void *this);
char __cdecl sub_1002C500();
char __thiscall sub_1002C503(int this);
char __thiscall sub_1002C530(int this);
// int __usercall sub_1002C5B4<eax>(int a1<ebp>);
// int __userpurge sub_1002C6B5<eax>(int a1<ebp>, int ebx0<ebx>, int a3<edi>, int a2);
// int __usercall sub_1002C78A<eax>(int a1<ebp>);
// void __usercall sub_1002CAA7(int a1<ebx>, int a2);
// void __usercall sub_1002CAC5(int a1<ebx>);
// void __usercall sub_1002CAEF(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
bool __thiscall sub_1002CAFD(void *this, int a2);
// void *__userpurge sub_1002CB1B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, char a5);
int sub_1002CB3A(); // weak
int sub_1002CB4F(); // weak
int __thiscall sub_1002CB72(int this);
// int __usercall sub_1002CB8B<eax>(int a1<ebx>, int a2<edi>, unsigned int a3);
_DWORD __cdecl loc_1002CBD6(_DWORD); // weak
char __thiscall sub_1002CC26(int this, int a2);
// void __usercall sub_1002CC50(int a1<ebx>, int a2<edi>, int a3);
char __thiscall sub_1002CC6A(void *this, int a2);
int __cdecl sub_1002CCA1(int a1);
// int __usercall sub_1002CCF6<eax>(int a1<ebx>, int a2);
// int __userpurge sub_1002CD2F<eax>(int a1<ebp>, int a2);
// int __userpurge sub_1002CD7C<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1002CD97<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4);
// int __userpurge sub_1002CE95<eax>(int a1<ebp>, int a2);
// int __userpurge sub_1002CF57<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1002CF72<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_1002CF9D(int this);
int loc_1002CFAD(); // weak
// int __usercall sub_1002CFB7<eax>(int a1<ebp>);
// void *__userpurge sub_1002D071<eax>(int a1<ecx>, int a2<ebx>, char a3);
// int __userpurge sub_1002D09A<eax>(int a1<ebp>, int a2);
// void *__userpurge sub_1002D0D4<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __thiscall sub_1002D0F3(void *this, char a2, char a3);
char __thiscall sub_1002D116(unsigned int *this, int a2, int a3);
int __thiscall sub_1002D155(int this, char a2);
int __thiscall sub_1002D1B1(unsigned int *this, int a2, int a3);
int __thiscall sub_1002D215(int this, int a2, int a3);
char __thiscall sub_1002D23F(int this, int a2);
int __thiscall sub_1002D2B1(int this, int a2, int a3);
int __thiscall sub_1002D2F9(int this, char a2);
int __thiscall sub_1002D426(void *this, int a2);
// int __usercall sub_1002D46E<eax>(int a1<ebp>, int a2<ebx>, int a3<edi>);
// char __usercall sub_1002D4FA<al>(int a1<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>);
// char __userpurge sub_1002D54E<al>(void *this<ecx>, int ebx0<ebx>, int edi0<edi>, int a2, int a3);
// char __usercall sub_1002D5ED<al>(int a1<ecx>, int a2<ebx>, int a3<edi>);
int __stdcall sub_1002D5FB(int a1, int a2);
int __thiscall sub_1002D61A(int this, int a2);
// int __userpurge sub_1002D6BB<eax>(int a1<ebp>, int a2, int a3);
// char __usercall sub_1002D743<al>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
bool __cdecl sub_1002D74F(int a1, int a2);
int __cdecl sub_1002D764(void *a2);
int __thiscall sub_1002D770(int this);
int __thiscall sub_1002D79E(void *this);
// int __userpurge sub_1002D7A9<eax>(int a1<ebp>, int a2);
int __thiscall sub_1002D873(void *this);
int __thiscall sub_1002D877(int this, int a2);
char __thiscall sub_1002D8BA(int this);
// int __usercall sub_1002D90B<eax>(int a1<ebp>);
bool __thiscall sub_1002D93B(int this);
bool __thiscall sub_1002D94E(int this);
bool __thiscall sub_1002D961(int this);
int __thiscall sub_1002D96F(int this);
// int __usercall sub_1002D978<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
int __thiscall sub_1002D9AB(void *this, int a2);
int __thiscall sub_1002D9F4(_DWORD); // weak
int __thiscall sub_1002DA1A(int this);
int __thiscall sub_1002DA1E(int this);
// int __usercall sub_1002DA39<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1002DA54<eax>(int a1<ecx>, int a2<ebp>);
// int __usercall sub_1002DA88<eax>(int a1<ebx>, int a2<edi>);
int __thiscall sub_1002DAC5(void *this, int a2);
// int __userpurge sub_1002DBC0<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5);
// int __userpurge sub_1002DF80<eax>(int a1<ebp>, int a2);
int __stdcall loc_1002DFA7(int); // weak
// void __userpurge sub_1002E04D(int a1<ebp>, int a2);
char __thiscall sub_1002E066(int this, int a2);
char __cdecl sub_1002E0A0(int a1, int a2);
// bool __userpurge sub_1002E0B9<eax>(int a1<ecx>, int a2<edi>, char a3);
// int __userpurge sub_1002E10F<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned int a4);
// int __usercall sub_1002E14D<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __userpurge sub_1002E166<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4);
int __thiscall sub_1002E229(int this);
int __thiscall sub_1002E240(int this);
int __thiscall sub_1002E280(void *this);
int loc_1002E2AE(); // weak
int __thiscall sub_1002E2B8(int this);
bool __thiscall sub_1002E2CF(int this, int a2);
int __thiscall sub_1002E2F3(int this, signed int a2);
void *__thiscall sub_1002E327(void *this, char a2);
void *__thiscall sub_1002E347(void *this, char a2);
int __thiscall sub_1002E366(void *this, char a2);
int __thiscall sub_1002E38F(int this, int a2);
int __thiscall sub_1002E4E8(void *this, int a2, char a3);
int __thiscall sub_1002E518(int this, int a2);
int __thiscall sub_1002E53F(int this, int a2);
bool __thiscall sub_1002E5AC(int this, int a2);
// int __userpurge sub_1002E5DE<eax>(int a1<ebp>, int a2);
bool __cdecl sub_1002E6CB(int a1);
char __thiscall sub_1002E6D7(int this, int a2);
// int __usercall sub_1002E71E<eax>(int a1<ecx>, int a2<ebp>);
void __thiscall sub_1002E73F(void *this);
BOOL __cdecl sub_1002E77E();
// int __usercall sub_1002E78D<eax>(int a1<ebx>, int a2<ebp>);
int __stdcall sub_1002E80C(int a1);
int __thiscall sub_1002E82E(int this);
void __cdecl sub_1002E968();
// int __usercall sub_1002E970<eax>(int a1<ebp>);
// void __usercall sub_1002E97C(int a1<eax>, int a2<ebp>);
// int __usercall sub_1002E987<eax>(int a1<ebp>, int a2<edi>);
int __thiscall sub_1002E996(int this);
int __cdecl sub_1002E99E();
int __thiscall sub_1002E9A1(int this);
int __thiscall sub_1002E9AC(int this);
int __thiscall sub_1002E9B4(int this);
int __thiscall sub_1002E9BF(int this, int a2);
bool __thiscall sub_1002EA0B(int this);
int __thiscall sub_1002EA1F(int this);
int __thiscall sub_1002EA23(int this);
int __thiscall sub_1002EA27(int this);
int __thiscall sub_1002EA38(int this);
char __thiscall sub_1002EA4E(int this, int a2, int a3);
char __thiscall sub_1002EB38(int this, int a2, char a3);
int __thiscall sub_1002EB71(int this, int a2);
int __thiscall sub_1002EB94(int this, int a2);
// int __usercall sub_1002EBC5<eax>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_1002EC1F(int this);
int __thiscall sub_1002EC3C(int this, int a2);
int __thiscall sub_1002EC9D(int this, int a2);
int __thiscall sub_1002ECE3(LPVOID lpTlsValue, int); // idb
int __thiscall sub_1002ECFD(int this, int a2, int a3);
// int __userpurge sub_1002ED10<eax>(int a1<ecx>, int a2<ebx>, int a3);
char __thiscall sub_1002ED8D(int this);
int __thiscall sub_1002EE14(void *this);
// int __usercall sub_1002EE1F<eax>(int a1<ecx>, int a2<ebp>);
char __thiscall sub_1002EE76(void *ListHead, int a2, signed int a3, char a4);
int __thiscall sub_1002EF6C(int this, int a2);
int __thiscall sub_1002EF93(void *this, int a2);
BOOL __thiscall sub_1002EFA9(LPVOID lpTlsValue);
int __thiscall sub_1002EFB7(int this, int a2);
int __cdecl sub_1002EFC4(int a1);
_DWORD __thiscall sub_1002EFDD(_DWORD ecx0); // weak
char __thiscall sub_1002EFE2(void *this);
int __cdecl sub_1002F05E(int (__cdecl *a1)(_DWORD, _DWORD), int a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __thiscall sub_1002F100(void *this, int a2, int a3, int a4);
int __cdecl sub_1002F288(char a1, char a2, int a3, int a4);
char __thiscall sub_1002F2F9(void *this, int a2, char a3);
int __stdcall sub_1002F346(char a1, char a2, int a3, int a4);
int __thiscall sub_1002F373(int this, int a2);
int __thiscall sub_1002F3D6(int this, int a2);
int __thiscall sub_1002F3E5(int this, int a2);
// char *__usercall sub_1002F41A<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
int __thiscall sub_1002F423(int this);
// int __userpurge sub_1002F437<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4);
// void __usercall sub_1002F482(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __userpurge sub_1002F4A1<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4, int a5);
// void __usercall sub_1002F4EE(int a1<ebp>);
// int __userpurge sub_1002F4FF<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
// int __userpurge sub_1002F536<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5);
int __thiscall sub_1002F572(int this, int a2, char a3);
int loc_1002F6C5(); // weak
// void __usercall sub_1002F6D1(int a1<ecx>, int a2<ebx>, int a3<edi>);
void *__thiscall sub_1002F75B(void *this, int a2);
void *__thiscall sub_1002F794(void *this, char a2);
int __thiscall sub_1002F7B4(int this, char a2);
// void *__userpurge sub_1002F7DA<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __thiscall sub_1002F7FF(int this, int a2);
int __cdecl sub_1002F827(int a1);
// int __userpurge sub_1002F851<eax>(int a1<ebp>, int a2, int a3, int a4, int a5);
// int __usercall sub_1002F8DB<eax>(int a1<ebp>);
// int (*__usercall sub_1002F9E6<eax>(int a1<ebx>, int a2<ebp>))();
int loc_1002FA08(); // weak
// void __usercall sub_1002FA0D(int a1<ebx>, int a2<edi>);
// int __usercall sub_1002FA13<eax>(int a1<ebp>);
// void __usercall sub_1002FB18(int a1<ebx>, int a2<edi>, LPVOID lpMem);
int __thiscall sub_1002FB29(void *this);
// void __usercall sub_1002FB35(LPVOID lpMem<ecx>, int a2<ebx>);
// int __usercall sub_1002FB48<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
int __thiscall sub_1002FB60(int this);
int __thiscall sub_1002FB68(void *this, void *a2);
int __cdecl sub_1002FB8C(_DWORD); // weak
int __thiscall sub_1002FBE7(int this, int a2, int a3);
int __thiscall sub_1002FC09(int this, int a2, int a3);
// void __usercall sub_1002FC2C(const void *a1<ecx>, int a2<edi>);
int __cdecl sub_1002FD39(int, int); // weak
void *__cdecl sub_1002FD59(void *a1);
int __cdecl sub_1002FD89(int a1);
// int __usercall sub_1002FD9C<eax>(int a1<ebp>);
int __cdecl sub_1002FDDA(int a1);
// void __usercall sub_1002FDE9(const void *a1<ecx>, int a2<edi>, const void **a3);
// unsigned int __userpurge sub_1002FDF7<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, unsigned int a4);
// unsigned int __userpurge sub_1002FE69<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, unsigned int a4);
// int __usercall sub_1002FEDB<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
// int __usercall sub_1002FEEC<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4, int a5);
int __thiscall sub_1002FF03(int this);
int __thiscall sub_1002FF15(int this);
int __thiscall sub_1002FF27(int this);
int __thiscall sub_1002FF39(int this);
int __thiscall sub_1002FF4B(int this, char a2);
int __thiscall sub_1002FF67(int this);
int __thiscall sub_1002FF79(int this);
int __thiscall sub_1002FF8B(int this, char a2);
int __thiscall sub_1002FFA7(int this);
int __thiscall sub_1002FFB9(int this, char a2);
int __thiscall sub_1002FFD5(int this);
int __thiscall sub_1002FFE7(int this);
int __thiscall sub_1002FFF9(int this, char a2);
int __thiscall sub_10030015(int this);
int __thiscall sub_10030027(int this, char a2);
int __thiscall sub_10030043(int this);
int __thiscall sub_10030055(int this);
int __thiscall sub_10030067(int this);
int __thiscall sub_10030079(int this, int a2);
int __thiscall sub_10030097(int this, int a2);
int __thiscall sub_100300B2(int this);
int __thiscall sub_100300C4(int this);
int __cdecl sub_100300E0(int a1, unsigned __int8 a2, int a3);
// int __userpurge sub_1003018D<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
// int __usercall sub_10030215<eax>(int a1<ebx>, int a2<edi>, int a3, int a4);
// int __usercall sub_10030357<eax>(int a1<ebx>, int a2<edi>, int a3);
_DWORD __cdecl sub_10030383(LPVOID lpMem); // weak
// signed int __usercall sub_10030388<eax>(int a1<ebx>, int a2<edi>, int a3, int a4);
// signed int __usercall sub_100305B1<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_10030655(struct _EXCEPTION_POINTERS *ExceptionInfo); // idb
// int __usercall sub_10030692<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, char a4);
// int __usercall sub_1003078B<eax>(int a1<ebx>, int a2<edi>, int a3<esi>);
// int __usercall sub_10030797<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, int a4);
// int __usercall sub_10030865<eax>(int a1<ebx>, int a2, int a3, char a4);
// int __usercall sub_10030883<eax>(int a1<ebx>, int (__cdecl *a2)(_DWORD, _DWORD, _DWORD, _DWORD), int a3, int a4, int a5, int a6);
// int __usercall sub_100308F4<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned int a4, int a5, char a6);
// int __usercall sub_10030910<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int dwBytes);
// void __usercall sub_100309A2(int a1<ebx>, LPVOID lpMem);
signed int __stdcall sub_100309DA(int a1, int a2, int a3, void (__thiscall *a4)(_DWORD), int a5);
int __cdecl sub_10030A50(int a1, unsigned __int8 a2);
char __cdecl sub_10030B80(int a1, int a2);
// void **__usercall sub_10030BC0<eax>(int a1<ebx>, int a2<edi>);
signed int __cdecl sub_10030BF0(int a1, int a2);
// int __usercall sub_10030C36<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, LPVOID lpMem, int dwBytes);
void *__thiscall sub_10030CE1(void *this);
int loc_10030D97(); // weak
signed int __stdcall sub_10030DA0(int a1, int a2, int a3, int a4);
int __thiscall sub_10030E65(int this, int a2, int a3);
char __thiscall sub_10030E98(int this, int a2, int a3);
int __thiscall sub_10030ECB(int this, int a2);
int __thiscall sub_10030EFB(void *this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10030F35(int this, int a2, int a3, int a4);
int __thiscall sub_10030F64(int this, int a2, int a3);
int __thiscall sub_10030F90(void *this);
// int *__usercall sub_10030FC1<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __usercall sub_10030FD5<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __usercall sub_10031044<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4, int a5, int a6, int a7);
int __cdecl sub_1003111F();
// int __usercall sub_1003115F<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
int sub_1003116B(void); // weak
// int __usercall sub_10031170<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
int __thiscall sub_1003117C(int this, int a2, char a3);
void __thiscall sub_1003119B(int this);
void *__thiscall sub_100311AC(int this, char a2);
int __stdcall sub_100311CB(int a1, int a2);
BOOL __thiscall sub_100311DA(char *Parameter);
DWORD __thiscall sub_1003123D(int this);
int __thiscall sub_10031259(void *ListHead, int a2, signed int a3, int a4);
void *__thiscall sub_1003134A(void *this);
void *__thiscall sub_10031361(void *this, int a2, int a3, int a4);
void *__thiscall sub_10031398(void *this, int a2, int a3, int a4);
// int __userpurge sub_100313DF<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
// int __userpurge sub_10031425<eax>(int a1<ebp>, int a2);
void *__thiscall sub_10031730(void *this);
// int __userpurge sub_10031755<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10031770<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1003178B<eax>(int a1<ecx>, int a2<ebx>, int a3);
int loc_100317AF(); // weak
int __thiscall sub_100317C2(PSLIST_HEADER ListHead);
int __thiscall sub_10031839(int this);
int __thiscall sub_10031850(int this);
int loc_1003186E(); // weak
_DWORD __thiscall sub_10031875(_DWORD ecx0); // weak
int loc_10031923(); // weak
int __thiscall sub_1003192A(int this, char a2);
void *__thiscall sub_10031974(void *this, char a2);
void *__thiscall sub_10031993(void *this, char a2);
void *__thiscall sub_100319B3(void *this, char a2);
void *__thiscall sub_100319D3(void *this, char a2);
void *__thiscall sub_100319F3(void *this, char a2);
void *__thiscall sub_10031A12(void *this, char a2);
int __thiscall sub_10031A3E(int this, int a2);
// int __userpurge sub_10031B97<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
int __thiscall sub_10031BC4(void *this, int a2);
int __thiscall sub_10031BFD(void *this, int a2);
int __thiscall sub_10031C2A(int this, int a2);
int __thiscall sub_10031C51(void *this, int a2, unsigned int a3);
// int __userpurge sub_10031D15<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5);
// int __userpurge sub_10031D50<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4);
// int __usercall sub_10031D99<eax>(int a1<ecx>, int a2<ebx>);
// int __userpurge sub_10031DDF<eax>(void *a1<ecx>, int a2<ebx>, int a3);
BOOL __thiscall sub_10031E48(void *this);
int __thiscall sub_10031E6B(void *this);
int __cdecl sub_10031EF3(int a1);
int __cdecl sub_10031EFF(int a1);
int __cdecl sub_10031F0B();
// int __usercall sub_10031F2F<eax>(int a1<ebp>);
// int __usercall sub_10031F8B<eax>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_10032023(int this);
int __thiscall sub_10032066(int this, unsigned int a2);
signed int __thiscall sub_100320F3(int this);
// int __userpurge sub_1003217C<eax>(int a1<ecx>, int a2<edi>, int a3);
int __stdcall sub_100321D9(int a2);
int __cdecl sub_100321E2();
// int __usercall sub_100321FE<eax>(int a1<ebx>, int a2<edi>, void *a3);
// int __usercall sub_10032224<eax>(int this<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>);
int __thiscall sub_10032230(int this);
BOOL __thiscall sub_1003224B(int this);
int __stdcall sub_1003226B(int a1);
int __stdcall sub_10032289(int a1);
int __thiscall sub_100322AB(void *this);
int __thiscall sub_100322EB(int this);
char __thiscall sub_10032322(void *this, int a2, char a3);
LPVOID __cdecl sub_10032365();
int __cdecl sub_10032372();
int __thiscall sub_10032385(int this);
int __thiscall sub_100323A2(int this);
int __thiscall sub_1003249B(unsigned int *this, int a2, int a3);
int __thiscall sub_100324D1(void *this);
int __thiscall sub_1003250C(int this, int a2);
int __stdcall sub_10032560(int a1, int a2, int a3, int a4);
int __thiscall sub_1003258B(void *this, int a2, int a3, int a4);
char __thiscall sub_100325BA(int this, int a2, int a3, int a4, int a5, int a6, int a7);
char __thiscall sub_100326B7(int this);
char __thiscall sub_100326E1(void *this);
int __thiscall sub_100327A8(int this);
// int __userpurge sub_100327B1<eax>(int a1<ebp>, int a2, int a3);
// int __usercall sub_1003285B<eax>(int a1<ebp>, int a2<edi>);
// int __userpurge sub_100328EB<eax>(int a1<ebx>, int a2<ebp>, int a3);
// int __userpurge sub_1003294B<eax>(int a1<ebp>, int a2);
int __thiscall sub_10032A58(void *this);
int __thiscall sub_10032A67(void *this);
int __cdecl sub_10032A76();
int __thiscall sub_10032A84(int this);
int __stdcall sub_10032AB9(int a1, int a2, int a3);
int __thiscall sub_10032AF5(int this, int a2, int a3);
int __thiscall sub_10032B1F(int this);
int __thiscall sub_10032B40(int this, int a2);
int __thiscall sub_10032B62(int this, int a2, int a3);
int __thiscall sub_10032B97(int this);
// int __userpurge sub_10032B9B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// int __userpurge sub_10032BB6<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4, int a5);
int __thiscall sub_10032C0F(int this);
int __thiscall sub_10032C26(int this, char a2);
int __thiscall sub_10032C44(void *this);
// int __usercall sub_10032C57<eax>(int a1<ebp>, int a2<edi>);
int __thiscall sub_10032CB8(int this, int a2);
void __thiscall sub_10032CDB(void *this, int a2);
void __thiscall sub_10032D5A(void *this, int a2);
bool __thiscall sub_10032DCA(int this);
int __cdecl sub_10032DDF(int a1, unsigned int a2);
int __thiscall sub_10032E0B(int this);
int __thiscall sub_10032E0F(int this);
int __thiscall sub_10032E16(_DWORD); // weak
int __thiscall sub_10033241(void *this);
// int __userpurge sub_1003324F<eax>(int a1<ebp>, int a2);
int __thiscall sub_10033312(void *this);
bool __thiscall sub_10033340(int this, int a2);
int __thiscall sub_1003337E(int this, int (__cdecl *a2)(_DWORD), int a3, int a4);
int __thiscall sub_100333B1(int this, int a2);
char __thiscall sub_100333F5(int this);
char __thiscall sub_10033412(void *this, int a2);
int __stdcall sub_10033446(int a1, int a2, int a3, int a4);
char __thiscall sub_10033457(int this, int a2);
char __thiscall sub_10033479(int this, int a2);
DWORD __cdecl sub_10033508();
BOOL __cdecl sub_10033556();
int __thiscall sub_1003356F(void *this, int a2);
int __thiscall sub_1003370C(int this);
int __thiscall sub_10033782(int this);
int __thiscall sub_1003380A(void *this);
int __thiscall sub_10033822(void *_ECX, int a2);
char __thiscall sub_10033840(void *this, int a2, char a3, int a4, int a5, int a6);
// int __userpurge sub_100338A4<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
int __thiscall sub_100338DB(int this);
int __thiscall sub_100338F3(int this);
int __thiscall sub_1003395E(void *this);
// int __userpurge sub_10033970<eax>(int a1<ecx>, int a2<edi>, HANDLE hSourceHandle);
int __thiscall sub_10033A21(int this);
USHORT __thiscall sub_10033A3B(int this, int a2);
int __thiscall sub_10033A82(void *this);
PSINGLE_LIST_ENTRY __thiscall sub_10033A94(int this, int a2, char a3);
int __thiscall sub_10033AD4(int this, int a2);
PSINGLE_LIST_ENTRY __thiscall sub_10033B18(int this);
BOOL __thiscall sub_10033B65(int this, LONG lReleaseCount);
int __thiscall sub_10033B83(void *this, int a2);
char __thiscall sub_10033BB5(void *ListHead, int a2, signed int a3, char a4);
char __thiscall sub_10033CB3(void *ListHead, int a2, signed int a3, char a4);
int __thiscall sub_10033DB1(void *this);
_DWORD *__thiscall sub_10033DD9(void *this);
_DWORD *__thiscall sub_10033DFD(int this);
int __thiscall sub_10033E20(int this, int a2);
char __thiscall sub_10033E5C(int this, int a2);
char __thiscall sub_10033E74(int this);
int __thiscall sub_10033E82(void *this, int a2, unsigned int a3);
int __thiscall sub_10033F78(void *this);
void *__cdecl sub_10033FC5(void *ListEntry);
LPVOID __cdecl sub_1003400C();
char __thiscall sub_10034028(void *this);
int __thiscall sub_1003404A(void *this);
int __thiscall sub_1003407F(void *this, int a2, int a3, int a4);
void __thiscall sub_100340B5(int this, int a2);
int __cdecl sub_100340DA(int a1, int a2);
int __cdecl sub_1003410B(int a1, int a2);
char __thiscall sub_10034145(void *this, int a2, char a3, int a4, int a5, int a6);
char __thiscall sub_1003416B(void *this, int a2, char a3, int a4, int a5, int a6, int a7);
void __cdecl sub_100341BF();
int __thiscall sub_10034222(void *this, int a2, int a3, int a4);
BOOL __thiscall sub_1003435B(void *this);
char __thiscall sub_100343E5(int this);
char __stdcall sub_1003450A(int a1, int a2);
char __stdcall sub_10034519(int a1, int a2);
int __thiscall sub_10034561(int this, int a2);
int __cdecl sub_100345F8(char a1, char a2, int a3);
int __stdcall sub_10034663(char a1, char a2, int a3);
int __thiscall sub_1003468D(int this, int a2);
signed int __thiscall sub_100346C2(int this);
int __thiscall sub_100346F0(int this, int a2);
signed int __thiscall sub_10034738(int this);
char __thiscall sub_1003476A(int this, int a2);
int __thiscall sub_1003480B(void *this, char a2);
void __thiscall sub_10034867(int this);
int __thiscall sub_100348B1(void *this);
int __thiscall sub_100348B8(void *this);
void __cdecl sub_100348BF();
void *__thiscall sub_100348CD(void *this, int a2);
_DWORD *__thiscall sub_10034913(void *this);
int __cdecl sub_1003491A(int a1);
BOOL __cdecl sub_10034927(int a1);
HMODULE __cdecl sub_10034963(DWORD dwExitCode);
unsigned int __cdecl sub_1003498E();
HANDLE __cdecl sub_100349DA(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
HMODULE __cdecl sub_10034A25();
int __cdecl sub_10034AB9(unsigned int a1, int a2, int a3);
int __cdecl sub_10034B13(int a1, int a2, int a3);
int __cdecl sub_10034B51(int a1, int a2);
int __cdecl sub_10034B87(int a1, int a2);
int __thiscall sub_10034BBC(void *this);
int __thiscall sub_10034BCC(void *this);
void __cdecl sub_10034BD7();
char __thiscall sub_10034BE0(void *this);
char __thiscall sub_10034C00(void *this);
BOOL __cdecl sub_10034C15();
// void __usercall sub_10034C2B(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, int a7);
BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);
// int __usercall sub_10034DC0<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4, int a5, int a6);
// int __usercall sub_10034ECE<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, int a7, int a8, int a9);
void *__cdecl sub_10034F00(void *a1, const void *a2, unsigned int a3);
int __cdecl loc_10035148(int, int, int); // weak
int __cdecl off_10035238(int, int, int); // weak
int __cdecl loc_10035248(int, int, int); // weak
int __cdecl loc_100352D4(int, int, int); // weak
int __cdecl sub_10035550(int a1);
void __stdcall sub_100355DB(int a1, int a2);
int __cdecl sub_10035636(_DWORD); // weak
int __thiscall sub_1003564A(_DWORD); // weak
int sub_10035659(void); // weak
char *__cdecl sub_10035668();
char *__cdecl sub_1003569B();
char *__cdecl sub_100356D1();
char *__cdecl sub_10035707();
// int __usercall sub_10035740<eax>(int a1<ebx>, int a2<edi>, PEXCEPTION_RECORD ExceptionRecord, int TargetFrame, int a5);
// int __usercall sub_10035771<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4<esi>);
// void __usercall sub_1003580E(int a1<edi>, int a2<esi>, int a3, int a4, int a5, int a6, int a7);
_DWORD __cdecl sub_1003586C(_DWORD, _DWORD); // weak
// signed int __usercall sub_10035873<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __cdecl loc_1003591C(int, int, int, int, int, int, int); // weak
int __cdecl sub_10035948(int a1, int a2, int a3, int a4, int a5);
// int __usercall sub_100359C7<eax>(int a1<ebp>, int a2, int a3);
// DWORD __userpurge sub_100359F7<eax>(int a1<edi>, int a2<esi>, PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord);
int __stdcall loc_10035A21(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord); // weak
// int __usercall sub_10035A4A<eax>(int a1<ebx>, int a2<edi>, int a3, int a4);
// void __usercall sub_10035A74(int a1<ebx>, int a2<edi>, int a3);
// signed int __usercall sub_10035AC4<eax>(int a1<ebx>, int a2<edi>, int a3);
// int __usercall sub_10035AED<eax>(int a1<eax>, int a2<ebx>, int a3<edi>, int ExceptionRecord, int a5, int a6, int a7);
int __cdecl sub_10035B23(int a1);
int __cdecl sub_10035BAE(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
// void __usercall sub_10035D7C(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __usercall sub_10035DBC<eax>(int a1<ebx>, int a2<esi>, PEXCEPTION_RECORD ExceptionRecord, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, PVOID TargetFrame);
// signed int __usercall sub_10035E37<eax>(int a1<ebx>, int a2<edi>, int a3);
void __cdecl sub_10035E84(int ExceptionRecord, int a2, int a3, int a4, int a5, char a6, int a7, PVOID TargetFrame);
// void __usercall sub_1003621F(int a1<ebx>, PEXCEPTION_RECORD ExceptionRecord, int a3, int a4, int a5, int a6, int a7, int a8, PVOID TargetFrame);
// char __usercall sub_10036339<al>(int a1<ebx>, int a2<edi>, int a3, int a4);
// char __usercall sub_100363BF<al>(int a1<ebx>, int a2<edi>);
int __cdecl sub_100363D0(int a1, int a2);
int __cdecl sub_100363F5(int a1, int a2, int a3, int a4);
int __cdecl sub_10036483(int a1, int a2, int a3, int a4);
// void __usercall sub_10036608(int a1<ebx>, int a2<edi>, int a3);
// int __usercall sub_10036656<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6);
// int __usercall sub_1003672F<eax>(int a1<ebx>, int a2<edi>, int ExceptionRecord, int a4, int a5, int a6, int a7, int a8, PVOID TargetFrame, char a10);
bool __cdecl sub_1003680E(int a1, int a2, int a3);
void __cdecl sub_1003686B(unsigned int a1, LPCSTR lpWideCharStr);
// void __usercall sub_10036A43(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// void __usercall sub_10036ACB(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
signed int __cdecl sub_10036B72();
void __cdecl sub_10036BA7(int a1);
// int __usercall sub_10036BBC<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_10036BE5<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4);
// int __usercall sub_10036C35<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4);
// int __usercall sub_10036C85<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4);
// int __usercall sub_10036CD5<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4);
// int __usercall sub_10036D25<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4);
// int __usercall sub_10036D7B<eax>(int a1<ebx>, int a2<edi>, signed int a3);
// int __usercall sub_10036DA6<eax>(int a1<ebx>, int a2<edi>, signed int a3);
// int __usercall sub_10036DD1<eax>(int a1<ebx>, int a2<edi>, signed int a3);
// int __usercall sub_10036DFC<eax>(int a1<ebx>, int a2<edi>, signed int a3);
// int __usercall sub_10036E27<eax>(int a1<ebx>, int a2<edi>, signed int a3);
// int __usercall sub_10036E54<eax>(int a1<ebx>, int a2);
// int __usercall sub_10036EA7<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_10036ECD<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_10036EF3<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_10036F1B<eax>(int a1<ebx>, int a2<edi>);
int __fastcall sub_10036F41(int a1, int a2, int a3);
// unsigned int __usercall sub_100372D9<eax>(int a1<ebx>, int a2, int a3, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpDestStr, int cchDest, UINT CodePage, int a10);
// unsigned int __usercall sub_100374C2<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpDestStr, int cchDest, UINT CodePage, int a11);
// LPVOID __usercall sub_10037506<eax>(int this<ecx>, int ebx0<ebx>, unsigned int a2, unsigned int a3);
// int __usercall sub_10037550<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int dwBytes);
// int __usercall sub_10037599<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, LPVOID lpMem, int dwBytes);
// int __usercall sub_100375E5<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, const void *lpMem, unsigned int a5, unsigned int a6);
// int __usercall sub_10037635<eax>(int a1<ebx>);
// int __usercall sub_10037648<eax>(int a1<ebx>, int a2);
// int __usercall sub_10037669<eax>(int a1<ebx>);
signed int __cdecl sub_1003767C(int a1);
// signed int __usercall sub_100376BD<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned __int8 a4, int a5, unsigned __int8 a6);
// signed int __usercall sub_10037713<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3);
int __cdecl sub_10037729(int a1, int a2, unsigned int a3);
int __cdecl sub_10038EA1(int, int, DWORD dwCmpFlags, int, int, int, int, UINT CodePage); // idb
int __cdecl sub_1003910C(int a1, int a2);
// int __usercall sub_1003912C<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, DWORD dwCmpFlags, int a6, int a7, int a8, int a9, UINT CodePage);
int __stdcall sub_10039170(unsigned __int64 a1, __int64 a2);
void *__cdecl sub_10039210(void *a1, unsigned __int8 a2, signed int a3);
int __cdecl sub_100392A0(int a1, int a2);
int __cdecl sub_10039310(int a1, int a2);
// signed int (__usercall *__usercall sub_1003939C<eax>(int a1<ebx>, int a2<edi>, int a3))<eax>(int<edi>, int, int, unsigned int, int, int, int);
signed int (__usercall *__cdecl sub_100393B3())<eax>(int<edi>, int, int, unsigned int, int, int, int);
int __cdecl sub_10039413(int a1);
int __cdecl sub_1003942A(int a1);
HANDLE __stdcall sub_10039441(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, int a5, int a6);
int __cdecl sub_1003946A(int a1, int a2, int a3);
int __cdecl sub_1003948B(int a1, int a2, int a3);
DWORD __cdecl sub_100394AC(int a1);
BOOL __cdecl sub_100394CA(DWORD a1);
LPVOID __cdecl sub_100394E9(DWORD a1);
BOOL __cdecl sub_10039508(DWORD a1, void *a2);
int __cdecl sub_1003952A();
int __cdecl sub_1003953A(int a1, int a2);
int __cdecl sub_10039554();
int __cdecl sub_10039566(int a1, int a2);
int __cdecl sub_1003958C(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, int); // idb
char __cdecl sub_100395BA();
int __cdecl sub_10039837(int a1, int a2, int a3, int a4);
int __cdecl sub_10039857(int a1, int a2, int a3);
int __cdecl sub_10039874(UINT uExitCode); // idb
LONG __cdecl sub_10039889(struct _EXCEPTION_POINTERS *ExceptionInfo);
int __cdecl sub_1003989F(int a1, int a2);
int __cdecl sub_100398B9(int a1);
// int __usercall sub_100398D2<eax>(int a1<ebx>, int a2<edi>, int a3, int a4);
// int __usercall sub_10039A13<eax>(int a1<ebx>, int a2<edi>, int a3);
__int64 __stdcall sub_10039A40(__int64 a1, __int64 a2);
__int64 __stdcall sub_10039A80(unsigned __int64 a1, unsigned int a2, unsigned int a3);
int __cdecl sub_10039AE8(int a1);
int __cdecl sub_10039B1D(int a1);
int __cdecl sub_10039B6B(int, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2); // idb
int __cdecl sub_10039BB7(int a1, int a2, int a3);
int __cdecl sub_10039C33(int a1);
int __stdcall LocaleEnumProc(int a1);
BOOL __cdecl sub_10039C71(int (__stdcall *a1)(_DWORD, _DWORD, _DWORD), int a2, int a3);
int __cdecl sub_10039CAE(int a1, LCTYPE a2, WCHAR *a3, int a4);
int __cdecl sub_10039CDD(int a1, int a2);
BOOL __cdecl sub_10039D08(int a1);
int __cdecl sub_10039D33(int, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest); // idb
int __cdecl sub_10039D7F(int a1, unsigned __int16 *a2, int a3);
int __cdecl sub_10039DED(int a1, DWORD dwMapFlags, LPCWSTR lpSrcStr, unsigned int cchSrc, LPWSTR lpDestStr, int cchDest);
double sub_10039E20(void); // weak
double __cdecl sub_10039E3D(_DWORD, _DWORD); // weak
int __cdecl sub_10039EDA();
// void __usercall sub_1003A013(int a1<ebx>, int a2<edi>, int a3<esi>, int a4, int a5, int a6);
void *__cdecl sub_1003A136(void *a1);
// int __usercall sub_1003A143<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6, int a7);
// int __usercall sub_1003A16E<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1003A17E<eax>(int a1<ebx>, int a2<edi>);
int *__cdecl sub_1003A1A9();
int *__cdecl sub_1003A1AF();
int *__cdecl sub_1003A1B5();
void **__cdecl sub_1003A1BB();
// signed int __usercall sub_1003A1C1<eax>(int a1<ebx>, int a2<edi>, int a3);
// signed int __usercall sub_1003A1EB<eax>(int a1<ebx>, int a2<edi>, int a3);
// signed int __usercall sub_1003A215<eax>(int a1<ebx>, int a2<edi>, int a3);
signed int __cdecl sub_1003A23F(int a1, int a2);
// void __usercall sub_1003A4B7(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// void __usercall sub_1003A507(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// char __usercall sub_1003A54D<al>(int a1<edi>, int a2);
// void __usercall sub_1003A731(int a1<edx>, int a2<ecx>, int a3<edi>);
int __stdcall sub_1003AC50(unsigned __int64 a1, unsigned int a2, int a3);
int __stdcall sub_1003AD00(unsigned __int64 a1, __int64 a2);
bool __cdecl sub_1003ADB2(int a1);
void *__cdecl sub_1003ADD8(void *a1);
// signed int __usercall sub_1003ADE5<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
int (__stdcall *__thiscall sub_1003AE3A(HMODULE this, int a2))();
void __thiscall sub_1003AE6C(HMODULE this, UINT uExitCode);
// void __usercall sub_1003AE82(int a1<ebx>);
// void __usercall sub_1003AF92(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// void __usercall sub_1003AFAE(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_1003AFBE<eax>(int a1<eax>, int a2<ebx>, int a3<edi>, int a4);
// void __usercall sub_1003B04F(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, UINT uExitCode);
unsigned int __cdecl sub_1003B063();
void __cdecl sub_1003B09B(unsigned int a1, unsigned int a2);
int __cdecl sub_1003B0B7(unsigned int a1, unsigned int a2);
// void __usercall sub_1003B0D9(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
void __cdecl sub_1003B0E2();
// void __usercall sub_1003B0EB(int a1<edx>, int ecx0<ecx>, int ebx0<ebx>, int a4<edi>, UINT uExitCode, int a2, int a3);
// SIZE_T __usercall sub_1003B21A<eax>(int a1<ebx>, int a2<edi>, LPCVOID lpMem);
// _DWORD __cdecl _SEH_prolog4(_DWORD, _DWORD); weak
// int __stdcall _SEH_epilog4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_1003B2B0(PEXCEPTION_RECORD ExceptionRecord, int TargetFrame, int a3);
// void __usercall sub_1003B445(int a1<ebx>, int a2<edi>);
// void __usercall sub_1003B47D(int a1<ebx>, int a2<edi>);
// void __usercall sub_1003B4B1(int a1<ebx>, int a2<edi>);
PVOID __cdecl sub_1003B4C4();
int __cdecl sub_1003B4D5();
DWORD __cdecl sub_1003B587(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent);
int __cdecl sub_1003B5AE(int a1);
// int __usercall sub_1003B5C4<eax>(int a1<ebx>, int a2);
int __cdecl sub_1003B65F(int, int); // weak
signed int __cdecl sub_1003B719(int a1, int a2);
signed int __cdecl sub_1003B766(HANDLE hThread, DWORD_PTR *a2);
int __thiscall sub_1003B79E(int this, int a2);
int __thiscall sub_1003B7BF(_DWORD); // weak
// int __userpurge sub_1003B8B9<eax>(int a1<ecx>, int a2<ebx>, int a3);
int sub_1003B8D4(); // weak
// int __usercall sub_1003B8DE<eax>(int a1<ebp>);
int loc_1003B99E(); // weak
int __thiscall sub_1003B9A5(int this, char a2);
int __thiscall sub_1003B9F3(int this, int a2);
unsigned int __thiscall sub_1003BA2C(int this, unsigned int a2, unsigned int a3, unsigned int a4);
int __thiscall sub_1003BAFC(int this, int a2);
int __cdecl sub_1003BB1F(int a1);
int __cdecl sub_1003BB4E(int a1);
signed int __thiscall sub_1003BB75(DWORD_PTR *this, HANDLE hThread);
// int __usercall sub_1003BB87<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
// void __usercall sub_1003BC9E(int a1<ebx>);
int __thiscall sub_1003BCB9(void *this, int a2);
int __thiscall sub_1003BDC6(int this);
int __thiscall sub_1003BDE9(int this);
// int __usercall sub_1003BE16<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
void __thiscall sub_1003BF43(LPVOID lpParameter);
int __cdecl sub_1003BFB6(_DWORD); // weak
_DWORD __stdcall sub_1003BFBB(_DWORD); // weak
// int __usercall sub_1003C017<eax>(int a1<ebp>, int a2<edi>);
int __thiscall sub_1003C0AC(int this, int a2, int a3);
int __thiscall sub_1003C119(int this);
int __thiscall sub_1003C132(int this, int a2);
// void __usercall sub_1003C16C(int a1<ecx>, int a2<ebx>);
int __thiscall sub_1003C484(int this);
char __thiscall sub_1003C4D1(int this);
void __thiscall sub_1003C67E(int this, int a2, char a3, char a4, int a5, unsigned int a6);
void __thiscall sub_1003C7B8(int this, int a2, int a3);
int __thiscall sub_1003C939(int this);
char *__thiscall sub_1003CB9B(int this, int a2, int a3, int a4, char a5);
char *__thiscall sub_1003CC07(void *this, int a2, int a3, int a4, unsigned int a5);
int __stdcall StartAddress(int a1);
// int __usercall sub_1003CD88<eax>(int a1<ebp>);
int __thiscall sub_1003CE89(int this, int *a2, unsigned int *a3, int a4, int a5, unsigned int a6);
int __thiscall sub_1003D1CE(void *this, int a2, int a3, int a4);
char __thiscall sub_1003D2DA(void *this, int a2, int a3, int a4, unsigned int a5);
int __thiscall sub_1003D3E4(int this, __int16 a2);
BOOL __thiscall sub_1003D41F(DWORD this);
int __thiscall sub_1003D44F(int this);
// int __usercall sub_1003D453<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4<esi>);
// int __userpurge sub_1003D49E<eax>(int a1<ecx>, int a2<esi>, int a3);
int __thiscall sub_1003D5B6(int this);
int __thiscall sub_1003D5BD(int this);
int __thiscall sub_1003D5C4(int this);
int __thiscall sub_1003D5CB(int this);
int __thiscall sub_1003D5E2(int this);
int __thiscall sub_1003D5F9(int this, int a2);
int __thiscall sub_1003D61E(int this, int a2);
// int __usercall sub_1003D643<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4<esi>);
int __thiscall sub_1003D68E(int this);
int sub_1003D695(void); // weak
int __cdecl sub_1003D69A();
int sub_1003D69F(void); // weak
int __cdecl sub_1003D6A4();
// int __usercall sub_1003D6B2<eax>(int a1<ebx>, int a2);
unsigned int __thiscall sub_1003D6DB(int this, int a2, int a3);
int __thiscall sub_1003D7F4(void *this, int a2, int a3);
void __thiscall sub_1003D949(int this);
// char __userpurge sub_1003D97F<al>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, char a7);
// void *__userpurge sub_1003D9B8<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, unsigned __int16 a6, unsigned __int16 a7, void *a8, int a9, char a10);
void *__thiscall sub_1003DAD1(int this);
// void __usercall sub_1003DB93(int a1<ebx>, int a2<edi>, int a3<esi>, char a4);
int __thiscall sub_1003DDD2(int this);
// int __userpurge sub_1003DDEB<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, char a5);
int __thiscall sub_1003DF41(int this, int a2, int a3, int a4);
void *__thiscall sub_1003E007(int this);
void __fastcall sub_1003E117(int a1);
unsigned int __thiscall sub_1003E1E8(int this);
unsigned int __thiscall sub_1003E217(void *this, unsigned int a2);
unsigned int __thiscall sub_1003E446(int this, int a2, unsigned int a3, unsigned int a4, unsigned int a5);
int __thiscall sub_1003E819(void *this);
int __stdcall sub_1003E825(int a1, int a2);
// int __usercall sub_1003E878<eax>(int a1<ebp>);
unsigned int __thiscall sub_1003E90F(int this, int a2, unsigned int a3, int a4);
char __thiscall sub_1003E964(int this, int a2, int a3, int a4);
int __thiscall sub_1003EA5A(int this, int a2);
// int __userpurge sub_1003EA90<eax>(int a1<ebp>, int a2);
// int __userpurge sub_1003EB04<eax>(int a1<ebp>, int a2, int a3);
unsigned int __thiscall sub_1003EC0F(int this, int a2, unsigned int a3);
unsigned int __thiscall sub_1003EC43(int this, int a2, unsigned int a3, int a4);
int __thiscall sub_1003EE15(int this);
// DWORD __usercall sub_1003EE6C<eax>(int a1<esi>);
void __cdecl sub_1003EF54(int a1, unsigned int a2);
char __thiscall sub_1003F113(void *this);
int __thiscall sub_1003F132(void *this, int a2);
int __thiscall sub_1003F301(int this, int a2, char a3);
int __thiscall sub_1003F3CF(int this, int a2);
// int __userpurge sub_1003F488<eax>(int a1<ebp>, int a2);
int __thiscall sub_1003F4D9(int this, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_1003F546<eax>(int a1<ebp>, int a2<esi>);
// int __usercall sub_1003F590<eax>(unsigned int a1<eax>, int a2<ecx>, char a3);
// void *__usercall sub_1003F5BC<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
wchar_t *__cdecl sub_1003F5F5(int a1);
// void *__usercall sub_1003F619<eax>(int a1<ebx>, int a2);
signed int __cdecl sub_1003F7D4(int a1, int a2, int a3, LCTYPE a4, LPVOID *a5);
void *__cdecl sub_1003F9AB(void *a1);
// void __usercall sub_1003F9B8(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
int __cdecl sub_1003FA29(int a1);
int __cdecl sub_1003FA50(int a1);
void __thiscall sub_1003FA5E(int this, int a2);
_DWORD __stdcall loc_1003FA76(_DWORD); // weak
char __thiscall sub_1003FB11(int this, char a2);
int sub_1003FB1E(); // weak
int sub_1003FC60(); // weak
// void (__usercall *__usercall sub_1003FD8A<eax>(int a1<ebp>, int a2<edi>))(int<ebp>);
// void __usercall sub_1003FDAD(int a1<ebp>);
// void (__usercall *__usercall sub_1003FDE3<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>))(int<ebp>);
// int (__usercall *__usercall sub_1003FDFF<eax>(int a1<ebp>, int a2<edi>))<eax>(int<ebp>);
// int __usercall sub_1003FE22<eax>(int a1<ebp>);
int loc_1003FE34(); // weak
int __thiscall sub_1003FF25(int this, int a2);
signed int __thiscall sub_1003FF4B(int this, int a2);
char __thiscall sub_1003FF73(int this);
int __thiscall sub_1003FF9B(int this);
// int __usercall sub_1003FFC6<eax>(int a1<ebx>, int a2<ebp>);
// int __usercall sub_10040035<eax>(int a1<ebx>, int a2<ebp>);
char __thiscall sub_100400A5(int this);
int __fastcall sub_10040112(int a1, int a2, int a3);
int __fastcall sub_10040179(int a1, int a2, int a3);
// int __usercall sub_100401D8<eax>(int a1<ebp>);
bool __thiscall sub_10040224(int this);
int __thiscall sub_1004023A(int this, int a2);
int __thiscall sub_1004025E(void *this);
int __thiscall sub_10040298(int this, int a2);
int __cdecl sub_100402BC(int a1);
int __cdecl sub_100402CD(int a1);
// int __userpurge sub_100402DE<eax>(int a1<ebp>, int a2);
int __cdecl sub_100403BD(int (__cdecl *a1)(_DWORD, _DWORD), int a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __thiscall sub_100403C9(int this, char a2, int a3);
int __thiscall sub_1004042F(void *this, char a2);
int __thiscall sub_100404AD(void *this, char a2, int a3);
int __thiscall sub_1004053B(int this, char a2);
// int __userpurge sub_100405E2<eax>(int a1<ebp>, int a2, int a3, int a4, int a5);
// int __userpurge sub_1004065C<eax>(int a1<ebp>, int a2, int a3);
// int __userpurge sub_100406B5<eax>(int a1<ebp>, int a2, int a3, int a4);
_DWORD __stdcall sub_1004076E(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __thiscall sub_100407DA(PSLIST_HEADER ListHead);
int __thiscall sub_1004084C(PSLIST_HEADER ListHead);
// int __usercall sub_100408C3<eax>(int a1<ebp>);
// int __usercall sub_1004090D<eax>(int a1<ebp>);
int __thiscall sub_10040971(int this, int a2);
int __thiscall sub_1004099B(int this, signed int a2);
int __thiscall sub_100409E1(int this, int a2);
int __thiscall sub_10040B39(int this, int a2);
char __thiscall sub_10040C95(void *this, int a2, char a3, int a4, int a5, int a6);
bool __cdecl sub_10040D78(int a1);
int __thiscall sub_10040D84(int this, int a2, int a3);
int __thiscall sub_10040DA9(void *this, int a2, int a3);
// int __usercall sub_10040E41<eax>(int a1<ebp>);
// char __userpurge sub_10040EB7<al>(int a1<ecx>, int i<edi>, int a3);
int __thiscall sub_10040F79(void *this);
int __thiscall sub_10040FB6(int this, int a2);
int __thiscall sub_10040FFC(int this, int a2);
int __thiscall sub_1004102C(void *this, int a2, int a3);
int __thiscall sub_1004107E(int this);
int __thiscall sub_100410E3(void *this, int a2, char a3);
int __thiscall sub_10041116(void *this);
// int __userpurge sub_10041126<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4);
bool __thiscall sub_10041170(int this);
bool __thiscall sub_10041179(void *this);
// int __userpurge sub_10041185<eax>(int a1<ecx>, int a2<edi>, int a3);
int __thiscall sub_100411AE(int this, int a2);
int __thiscall sub_100411C1(int this, int a2, int a3, int a4);
// int __userpurge sub_10041243<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned int a4, char a5);
int __thiscall sub_1004128D(int this, int a2, char a3);
bool __thiscall sub_10041346(void *this);
int __thiscall sub_10041399(void *this);
int __thiscall sub_100413BA(void *this, int a2);
PSINGLE_LIST_ENTRY __thiscall sub_100413D3(void *this, int a2);
char __thiscall sub_100413F9(void *ListHead, int a2, signed int a3, char a4);
char __thiscall sub_100414EF(int this);
char __thiscall sub_10041512(int this);
int __thiscall sub_10041551(int this, int a2);
char __thiscall sub_10041578(int this, int a2);
int __thiscall sub_100415BA(void *this, int a2, int a3, int a4);
int __thiscall sub_100415D8(void *this, int a2, int a3);
int __thiscall sub_100415EE(int this, int a2, int a3);
int __thiscall sub_1004171A(int this, int a2);
// int __userpurge sub_10041740<eax>(int a1<ecx>, int a2<edi>, char a3);
// void __userpurge sub_100418EF(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, LPVOID lpMem);
// void __usercall sub_10041A26(int a1<ebx>, int a2<edi>, LPVOID lpMem);
// int __usercall sub_10041A5C<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_10041A74<eax>(int a1<ebx>);
// void __usercall sub_10041AE3(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
// signed int __usercall sub_10041B96<eax>(int a1<ebx>);
void __cdecl sub_10041C0C();
LONG __cdecl sub_10041C29(volatile LONG *lpAddend);
void __cdecl sub_10041CB9(LPVOID lpMem);
volatile LONG *__cdecl sub_10041E13(volatile LONG *lpAddend);
// void __usercall sub_10041EAE(int a1<ebx>, int a2<edi>);
volatile LONG *__cdecl sub_10041F2A(volatile LONG **a1, volatile LONG *lpAddend);
// int __usercall sub_10041F75<eax>(int a1<ebx>);
wchar_t *__cdecl sub_10041F93(int a1);
// UINT __usercall sub_10041FCD<eax>(int a1<ebx>, int a2<edi>, UINT a3);
int __cdecl sub_10042039(int a1);
char __cdecl sub_100420A2(int a1);
// void __usercall sub_10042230(int a1<ebx>, int a2<edi>);
// void __usercall sub_100422D5(int a1<ebx>, UINT a2);
// signed int __usercall sub_10042483<eax>(int a1<ebx>, int a2<edi>, UINT a3, int a4);
// int __usercall sub_10042678<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4, int a5);
// int __usercall sub_10042727<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3, int a4);
// int __usercall sub_1004275D<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3);
// void __usercall sub_1004276E(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
int __cdecl sub_100427C0(int a1);
// void __usercall sub_10042824(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6);
int __cdecl sub_10042892(int, int); // weak
void __cdecl sub_100429BC(void *lpAddend, const void *a2);
int __cdecl sub_100429E8(int a1, int a2, int a3, int a4, int a5, int a6);
void __fastcall sub_10042CDD(int a1, int a2, int a3, int a4, int a5);
// void __usercall sub_10042D1C(int a1<edi>, unsigned int a2, int a3);
// int __usercall sub_10042E99<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
int __fastcall sub_1004300D(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_10043294(int a1, int a2, int a3);
void __cdecl sub_1004362C();
// signed int __usercall sub_10043634<eax>(int a1<edx>, int a2<ebx>, int a3, unsigned int *a4, void **a5, const void *a6, int a7);
// int __usercall sub_10043693<eax>(int a1<edi>, unsigned __int8 a2);
// signed int __usercall sub_100436B4<eax>(int a1<edx>, int a2<ebx>, int a3);
signed int __cdecl sub_100436D6(int a1, int a2, int a3, int a4);
// int __usercall sub_100447C4<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4, int a5);
// signed int __usercall sub_100447F2<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3, int a4);
// int __usercall sub_1004493F<eax>(int a1<ebx>, int (__cdecl *a2)(_DWORD, _DWORD, _DWORD, _DWORD), int a3, unsigned int a4, int a5, int a6, int a7);
// int __usercall sub_10044A07<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned int a4, int a5, int a6, int a7);
bool __cdecl sub_10044A7C();
void __cdecl sub_10044A91();
// signed int __usercall sub_10044A99<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6);
// int __usercall sub_10044B57<eax>(int a1<ebx>, int a2, int a3, char a4);
// int __userpurge sub_10044B75<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, const void **a5);
// int __userpurge sub_10044B9B<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10044BB6<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10044BD1<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_10044BEC(LPVOID *this);
void **__thiscall sub_10044BF5(void **this, const void **a2);
int __thiscall sub_10044C13(void *this, unsigned int a2);
char __thiscall sub_10044C49(void *this);
char __cdecl sub_10044C67(unsigned int a1, unsigned int a2);
// int __userpurge sub_10044C85<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4);
int __stdcall loc_10044CF2(int, int); // weak
// void __userpurge sub_10044D56(int a1<ebp>, int a2, int a3);
int __thiscall sub_10044D65(void *this);
char *__cdecl sub_10044DAD(unsigned int a1);
char __cdecl sub_10044DC4(int a1, signed int a2);
int __thiscall sub_10044E80(void *this);
_DWORD loc_10044EC9(); // weak
int __thiscall sub_10044F1A(int this);
// int __usercall sub_10044F31<eax>(int a1<ebp>);
void *__thiscall sub_10044F7C(void *this, char a2);
char __thiscall sub_10044F9B(int this, unsigned int a2);
int __thiscall sub_10044FD2(void *this, int a2);
char __thiscall sub_1004500F(int this);
bool __cdecl sub_10045053(int a1);
char __thiscall sub_1004505F(int this, int a2, int a3, char a4);
signed int __thiscall sub_10045104(int this, int a2);
int __thiscall sub_10045129(int this);
int __stdcall sub_10045135(int a1);
int __thiscall sub_10045159(int this);
char __thiscall sub_10045165(int this, int a2, int a3, int a4);
char __thiscall sub_100451D9(int this, int a2);
// int __usercall sub_10045204<eax>(int a1<ecx>, int a2<ebp>, int a3<edi>);
int __thiscall sub_1004521D(int this, int a2, int a3);
int __thiscall sub_1004535A(int this, unsigned int a2);
int __thiscall sub_1004539C(int this, unsigned int a2);
int __thiscall sub_100453E2(int this, int a2, char a3);
char __thiscall sub_10045460(int this);
int __thiscall sub_100454B4(int this);
signed int __thiscall sub_100454D7(int this);
char __thiscall sub_10045525(void *ListHead, int a2, signed int a3, char a4);
char __thiscall sub_10045620(int this);
char __thiscall sub_10045763(int this);
int __thiscall sub_10045777(void *this, int a2);
int __thiscall sub_100457B1(int this, unsigned int a2);
int __thiscall sub_100457F9(int this, unsigned int a2);
char __thiscall sub_10045841(int this, int a2, int a3);
int __cdecl sub_100458CA(char a1, char a2, int a3, int a4);
int __stdcall sub_1004593B(int a1);
int __stdcall sub_10045945(char a1, char a2, int a3, int a4);
char __thiscall sub_10045972(int this, char a2, char a3);
int __thiscall sub_100459D0(int this);
// int __userpurge sub_100459ED<eax>(int a1<ebp>, int a2, int a3, int a4);
int __thiscall sub_10045A6A(PSLIST_HEADER ListHead);
// int __usercall sub_10045AE0<eax>(int a1<ebp>);
int __thiscall sub_10045B20(int this, int a2);
int __thiscall sub_10045C79(void *this, int a2, char a3);
char __thiscall sub_10045D62(void *this);
int __thiscall sub_10045DB8(int this, int a2);
int __thiscall sub_10045DF5(void *this, int a2);
char __thiscall sub_10045E52(void *this, int a2, int a3, int a4, int a5, int a6, int a7);
int __thiscall sub_10045EC2(void *this, int a2);
// int __userpurge sub_10045EE6<eax>(int a1<ebp>, int a2);
void *__thiscall sub_10045F26(void *this, int a2);
// int __userpurge sub_10045F99<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10045FB4<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10045FCF<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10045FEA<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __usercall sub_10046005<eax>(int a1<ebp>);
void *__thiscall sub_10046040(void *this, char a2);
char __thiscall sub_10046067(void *this, char a2, int a3, int a4, int a5);
// int __userpurge sub_100461E0<eax>(int a1<ebp>, int a2);
int __thiscall sub_10046231(void *this);
char __thiscall sub_10046355(int this);
// void __usercall sub_100463C7(int a1<ecx>, int a2<ebp>);
// int __usercall sub_100463DF<eax>(int this<ecx>, int a2<ebp>);
// int __userpurge sub_100463FA<eax>(int a1<ebp>, int a2);
int __thiscall sub_1004656E(int this, int a2);
// char __usercall sub_100465AB<al>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_10046615(int this, int a2, int a3);
// int __userpurge sub_10046717<eax>(int a1<ecx>, int a2<edi>, int a3);
int __thiscall sub_10046743(int this, int a2);
int __thiscall sub_10046771(int this);
int __thiscall sub_10046775(int this);
int __thiscall sub_1004677D(int this);
int __thiscall sub_10046784(int this);
signed int __thiscall sub_1004678C(void *this);
int __thiscall sub_100467B8(void *this, int a2, int a3, int a4);
bool __thiscall sub_1004691F(int this);
// char __usercall sub_1004692B<al>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_10046989(void *this);
void __thiscall sub_10046A5F(int this, char a2);
int __thiscall sub_10046AD3(int this, int a2, int a3, char a4);
int __thiscall sub_10046B3C(int this, int a2);
int __thiscall sub_10046B53(int this, int a2);
void __thiscall sub_10046B94(int this);
int __thiscall sub_10046BE3(void *this);
// void __usercall sub_10046C02(int a1<ecx>, int a2<ebp>);
int __thiscall sub_10046C25(int this, int a2);
char __thiscall sub_10046C65(int this);
char __cdecl sub_10046C90(int a1, int a2);
int __thiscall sub_10046CBD(void *this);
void __thiscall sub_10046D4D(int this, int a2, char a3);
char __thiscall sub_10046D9E(int this, int a2);
int __thiscall sub_10046E8A(int this, int a2, int a3);
int __fastcall sub_10046F81(int a1);
int __thiscall sub_10047025(int this);
char __thiscall sub_10047115(int this, int a2);
int __thiscall sub_1004717C(void *this);
// int __userpurge sub_100472B7<eax>(int a1<ebp>, int a2, int a3);
int __thiscall sub_1004733D(PSLIST_HEADER ListHead);
// int __usercall sub_100473B3<eax>(int a1<ebp>);
int __thiscall sub_100473E6(int this);
bool __cdecl sub_10047418(int a1);
int __stdcall sub_10047424(int a1);
char __thiscall sub_10047448(void *ListHead, int a2, signed int a3, char a4);
char __thiscall sub_10047543(void *this, int a2);
int __thiscall sub_1004756C(int *this, int a2, int a3);
// int __userpurge sub_100475BC<eax>(int a1<ecx>, int a2<edi>, int a3, int a4);
int __thiscall sub_1004760F(int this, int a2);
int __thiscall sub_10047642(int this, int a2);
// int __userpurge sub_1004767A<eax>(int a1<ecx>, int a2<edi>, int a3, int a4, int a5, int a6);
// int __userpurge sub_100476A0<eax>(int a1<ecx>, int a2<edi>, int a3, int a4);
int __thiscall sub_100476B8(int this);
bool __thiscall sub_100476EB(void *this, int a2);
int __thiscall sub_10047729(int this, int a2, int a3);
int __thiscall sub_1004774F(int this, int a2);
int __thiscall sub_1004775E(int this, int a2, int a3);
int __thiscall sub_1004778A(int this, int a2, char a3);
// int __userpurge sub_100477F0<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4);
// int __usercall sub_100478B6<eax>(int a1<ebp>);
void *__thiscall sub_100478E3(void *this, char a2);
// int __userpurge sub_10047902<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
DWORD __thiscall sub_10047923(int this);
// int __usercall sub_1004795D<eax>(int a1<ecx>, int a2<ebp>);
// char __userpurge sub_100479B5<al>(void *this<ecx>, int edi0<edi>, int a2);
// int __usercall sub_100479DA<eax>(int a1<ecx>, int a2<ebp>, int a3<edi>);
signed int __cdecl sub_100479FC();
int __stdcall sub_10047A00(int a1, int a2, int a3, int a4);
char __stdcall sub_10047A22(int a1, int a2);
bool __thiscall sub_10047A45(int this);
void __thiscall sub_10047A51(int this, char a2);
DWORD __thiscall sub_10047A88(int Context, char a2);
// BOOL __usercall sub_10047B55<eax>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_10047B77(void *this);
int __thiscall sub_10047B7C(void *this);
void *__thiscall sub_10047C12(void *this, int a2);
void *__thiscall sub_10047C34(void *this, int a2);
int __thiscall sub_10047C61(int this);
void __stdcall sub_10047C75(int a1);
void *__thiscall sub_10047C7D(void *this, char a2);
int __stdcall loc_10047C85(int); // weak
int __thiscall sub_10047CD0(void *this, int a2, unsigned int a3);
// int __usercall sub_10047CDC<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __usercall sub_10047D0F<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __userpurge sub_10047D4D<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5);
signed int __cdecl sub_10047D85();
int __thiscall sub_10047D89(void *this);
int __thiscall sub_10047D8D(int this);
// int __userpurge sub_10047D95<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// int __userpurge sub_10047DAF<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
int __thiscall sub_10047DBA(void *this, int a2, unsigned int a3);
int __thiscall sub_10047DC6(void *this, int a2, int a3, int a4);
DWORD __cdecl sub_10047DD2();
BOOL __cdecl sub_10047E16();
// signed int __usercall sub_10047E2A<eax>(int a1<ecx>, int a2<ebx>);
// void __usercall sub_10047E9D(int a1<edx>, int a2<ecx>, int a3<ebx>);
void **__cdecl sub_10047EC4();
// void __usercall sub_10047ECA(int a1<edx>, int a2<ebx>, int a3<edi>, unsigned int a4);
// void __usercall sub_10047F09(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5, int a6);
void __cdecl sub_10047F39(unsigned int a1);
void __cdecl sub_10047F73(signed int a1, int a2);
// void __usercall sub_10047FA0(int a1<ebx>, int a2<edi>, int edx0<edx>, int a4<ecx>, int a3);
signed int __cdecl sub_10047FE6(int a1);
// void __usercall sub_1004804A(int a1<edx>, int a2<ecx>, int a3<ebx>);
// void __usercall sub_10048053(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
// int __usercall sub_100481B5<eax>(int a1<ebx>, int a2, int a3);
// int __usercall sub_10048310<eax>(int a1<ebx>, int a2, int a3);
// void __usercall sub_1004832E(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// void __usercall sub_100485DC(int a1<ebx>);
// signed int __usercall sub_1004862E<eax>(int a1<ebx>);
int __cdecl sub_100486DF(int a1, int a2, int a3, int a4, int a5);
// signed int __usercall sub_1004885B<eax>(int a1<ecx>, int a2<ebx>);
signed int __cdecl sub_1004893C();
// int __usercall sub_100489D6<eax>(int a1<ebx>);
void __cdecl sub_10048A61();
void __cdecl sub_10048A81();
// void __userpurge sub_10048AB0(int a1<ebp>, int a2<edi>, int a3<esi>, int a4, int a5, int a6);
int __cdecl sub_10048AFC(int a1);
int __cdecl sub_10048B0B(LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int cchWideChar, int); // idb
int __cdecl sub_10048C6A(int, LPWSTR lpWideCharStr, int cchWideChar, LPCSTR lpMultiByteStr, int, int); // idb
int __cdecl sub_10048D46(int, LPWSTR lpWideCharStr, int cchWideChar, LPCSTR lpMultiByteStr, int); // idb
signed int __cdecl sub_10048D64(CHAR *a1, int lpWideCharStr, int cbMultiByte, int a4);
// signed int __usercall sub_10048FC9<eax>(int a1<ebx>, int a2, CHAR *a3, int cbMultiByte, int lpWideCharStr, int a6, int a7);
// LPVOID __usercall sub_10049092<eax>(void *a1<ecx>, int a2<ebx>, unsigned int a3, unsigned int a4);
// signed int __usercall sub_100490D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, int a7);
int __cdecl sub_1004912C(int, DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, int); // idb
// int __usercall sub_10049218<eax>(int a1<ebx>, int a2<edi>, int a3, DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, int a9);
// int __usercall sub_10049256<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, const void *lpMem, unsigned int a5, unsigned int a6);
// LPVOID __usercall sub_100492BF<eax>(void *this<ecx>, int ebx0<ebx>, unsigned int a2, unsigned int a3, int a4);
PVOID __cdecl sub_10049401();
int __cdecl sub_1004940E(int a1);
void __cdecl sub_1004942A(int a1);
unsigned int __cdecl sub_100495DF(int a1, unsigned int a2);
int __cdecl sub_1004961B(double); // idb
int __cdecl sub_100496B7(double, int); // idb
double __cdecl sub_10049789(double a1, __int16 a2);
signed int __cdecl sub_100497B4(int a1, int a2);
int __cdecl sub_10049810(char a1);
double __cdecl sub_10049842(char, _DWORD, _DWORD); // weak
bool __cdecl sub_1004990A(signed int a1, double a2);
// double __usercall sub_10049AE6<st0>(__int16 a1<cx>, int a2<ebx>, int a3, double a4);
int __cdecl sub_10049B36(ULONG_PTR Arguments, int a2, char a3, int a4, int a5, int a6);
int __cdecl sub_10049B57(ULONG_PTR Arguments, int a2, char a3, int a4, int a5, int a6, int a7);
// int __usercall sub_10049E3C<eax>(int a1<ebx>, int a2);
// double __usercall sub_10049E69<st0>(int a1<ebx>, int a2, int a3, int a4, int a5, int a6, int a7, double a8);
int __cdecl sub_10049F07(int a1);
int __thiscall sub_10049F7D(int (*this)(void));
int __fastcall sub_10049F8C(__int16 a1);
void __cdecl sub_10049FB5();
int __thiscall sub_1004A00B(int (*this)(void));
// signed int __usercall sub_1004A019<eax>(int a1<edi>, int a2, int a3, unsigned int a4, int a5, int a6, int a7);
// signed int __usercall sub_1004A03A<eax>(int a1<edi>, int a2, int a3, unsigned int a4, int a5, int a6, int a7, int a8);
// signed int __usercall sub_1004A0C0<eax>(int a1<edi>, int a2, int a3, unsigned int a4, int a5, int a6, int a7);
signed int __cdecl sub_1004A41A(int a1, int a2, unsigned int a3, int a4, int a5);
// int __usercall sub_1004A438<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned int a4, int a5, int a6, int a7, char a8, int a9);
signed int __cdecl sub_1004A587(int a1, int a2, unsigned int a3, int a4, int a5, int a6);
// signed int __usercall sub_1004A653<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6, char a7, int a8);
signed int __cdecl sub_1004A73D(int a1, int a2, int a3, int a4, int a5);
signed int __cdecl sub_1004A7FC(int a1, int a2, unsigned int a3, int a4, int a5, int a6);
// char __usercall sub_1004A8F9<al>(int a1<ebx>, int a2<edi>, int a3);
// char __usercall sub_1004A90A<al>(int a1<ebx>, int a2<edi>, int a3, int a4);
// int __usercall sub_1004A988<eax>(int a1<ebx>, int a2, int a3, int a4);
// int __usercall sub_1004A9A0<eax>(int a1<ebx>, int a2, int a3, int a4, int a5);
// char __usercall sub_1004A9E0<al>(int a1<ebx>, int a2<edi>, int *a3);
// char __usercall sub_1004A9F1<al>(int a1<ebx>, int a2<edi>, int *a3, int a4);
bool __cdecl sub_1004AA63(int a1);
void __cdecl sub_1004AA7D(int a1, int a2);
// signed int __usercall sub_1004AAA5<eax>(int a1<ebx>, int a2<edi>);
int (*__cdecl sub_1004AACC())();
// int __usercall sub_1004AAEB<eax>(int a1<ebx>, int a2<edi>, int a3, const WCHAR *a4);
// int __usercall sub_1004AB7E<eax>(int a1<ebx>, int a2<edi>, int a3, const WCHAR *a4, int a5);
unsigned int __cdecl sub_1004AC57(int a1, unsigned int a2);
// int __usercall sub_1004AC80<eax>(int a1<edx>, __int16 a2<cx>, int a3<ebp>, __int16 a4<fpstat>, double _ST7<st0>, char a6, char a7, char a8);
// int __usercall sub_1004ACE7<eax>(int a1<edx>, int a2<ebp>, __int16 a3<fpstat>, double _ST6<st1>, double a5<st0>, char a6, char a7, char a8);
int loc_1004AD86(); // weak
double __cdecl sub_1004AD8D();
// double __usercall sub_1004AD92<st0>(int a1<ebp>, double a2<st0>);
// void __usercall sub_1004AE39(int a1<ebp>);
void __cdecl sub_1004AE50();
// double __usercall sub_1004AE67<st0>(int a1<eax>, int a2<edx>, int a3<ecx>, double a4<st0>, __int16 a5, int a6, int a7, int a8);
int __cdecl loc_1004AE70(__int16, int, int, int); // weak
double __cdecl sub_1004AEC5(_DWORD); // weak
// double __usercall sub_1004AEDC<st0>(int a1<eax>, double result<st0>);
double __fastcall sub_1004AEF5(int a1, int a2);
int __cdecl sub_1004AF38(int a1, int a2);
// int __usercall sub_1004B03C<eax>(int a1<ebx>, int a2<edi>, int a3);
// int __usercall sub_1004B050<eax>(int a1<ebx>, int a2);
int __cdecl sub_1004B0E0(int a1, unsigned int a2);
// unsigned int __usercall sub_1004B130<eax>(int a1<eax>, int a2);
char __cdecl sub_1004B1F0(int a1);
int __cdecl sub_1004B221(int a1);
// int __usercall sub_1004B230<eax>(int a1<ebp>, int a2, int a3, unsigned int a4);
int __cdecl loc_1004B2C0(int, int, int, int); // weak
int __thiscall sub_1004B322(void *this);
int __fastcall sub_1004B339(int a1, int a2);
void __fastcall sub_1004B352(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord);
int __fastcall loc_1004B366(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord); // weak
int __fastcall sub_1004B36B(int a1, unsigned int a2, int a3, int a4);
int __thiscall sub_1004B382(int this, int a2, int a3, int a4);
int __thiscall sub_1004B3E9(int this, int a2, int a3);
int __thiscall sub_1004B448(int this);
void __thiscall sub_1004B45A(int this);
int __thiscall sub_1004B4C5(int this);
int __thiscall sub_1004B4C9(int this);
BOOL __thiscall sub_1004B4CD(int lpTlsValue);
int __thiscall sub_1004B599(int this, int a2);
BOOL __thiscall sub_1004B605(int this);
BOOL __thiscall sub_1004B620(LPVOID lpTlsValue);
unsigned int __cdecl sub_1004B642(unsigned int a1);
double __cdecl sub_1004B65A(double a1);
int __thiscall sub_1004B690(int this, int a2, unsigned int a3, int a4);
int __thiscall sub_1004B71A(int this, double a2, int a3);
double __stdcall sub_1004B73D(unsigned int a1, unsigned int a2, int a3, int a4);
double __thiscall sub_1004B778(void *this, int a2, int a3);
double __thiscall sub_1004B830(int this);
int __thiscall sub_1004B867(int this, int a2);
__int64 __fastcall sub_1004B8AC(int a1);
int __thiscall sub_1004B8F0(void *this, int a2);
bool __thiscall sub_1004B91B(int this);
char __stdcall sub_1004B934(int a1);
double __fastcall sub_1004B964(int a1);
int __thiscall sub_1004B984(int this, unsigned int a2);
int __thiscall sub_1004BA54(int this, int a2, unsigned int a3, int a4, int a5);
double __fastcall sub_1004BC13(int a1);
_DWORD __stdcall sub_1004BC5F(_DWORD, _DWORD, _DWORD); // weak
int sub_1004BEB5(void); // weak
char *__thiscall sub_1004BEFE(int this, int a2, int a3, char a4);
_DWORD __stdcall sub_1004BFB6(_DWORD); // weak
int __thiscall sub_1004C00E(int this, int a2);
int __thiscall sub_1004C047(int this, int a2);
_DWORD __stdcall sub_1004C056(_DWORD, _DWORD); // weak
int __thiscall sub_1004C0EA(void *this, int a2);
int __thiscall sub_1004C15A(void *this, int a2);
int __thiscall sub_1004C1AD(void *this);
// int __userpurge sub_1004C269<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4);
// int __userpurge sub_1004C36C<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5);
int __thiscall sub_1004C3A4(int this, int a2);
int __thiscall sub_1004C3FC(int this, int a2, int a3, char a4);
int __thiscall sub_1004C477(void *this);
int __thiscall sub_1004C48C(int this, int a2);
_DWORD __stdcall sub_1004C518(_DWORD); // weak
int __thiscall sub_1004C584(void *this);
LPVOID __thiscall sub_1004C594(int this);
// int __userpurge sub_1004C5B1<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1004C5F1<eax>(int a1<ebp>, int a2);
int __thiscall sub_1004C63F(int this, unsigned int a2, int a3, char a4);
int __thiscall sub_1004C91D(int this, int a2);
int __thiscall sub_1004C979(int this, int a2, int a3, char a4);
// int __usercall sub_1004C9FB<eax>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_1004CA81(int this, int a2);
// int __userpurge sub_1004CAB7<eax>(int a1<ebp>, int a2, int a3);
int __thiscall sub_1004CB86(void *this, void *a2);
int __thiscall sub_1004CBAF(int this, int a2);
_DWORD __stdcall sub_1004CBC2(_DWORD, _DWORD); // weak
int __thiscall sub_1004CC87(int this);
// int __usercall sub_1004CC91<eax>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_1004CC9B(int this, int a2, int a3);
int __stdcall sub_1004CCD0(int a1);
int __cdecl sub_1004CD16(int a1);
_DWORD __cdecl loc_1004CDC5(_DWORD); // weak
int __cdecl sub_1004CDDB();
int __thiscall sub_1004CDE9(int this, int a2);
void *__thiscall sub_1004CE1C(void *this, int a2, int a3);
int __thiscall sub_1004CE4D(int this, int a2);
// int __usercall sub_1004CE73<eax>(int a1<ebp>);
// int __usercall sub_1004CED6<eax>(int a1<ebp>);
void *__thiscall sub_1004CF1D(void *this, char a2);
void *__thiscall sub_1004CF3D(void *this, char a2);
// int __userpurge sub_1004CF62<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4);
// int __usercall sub_1004CF97<eax>(int a1<ebx>, int a2<edi>, int a3);
int __thiscall sub_1004CFBB(int this);
// int __usercall sub_1004CFBF<eax>(int a1<ebx>, int a2<ebp>);
int __stdcall sub_1004D004(int, int nPriority); // idb
__int16 __thiscall sub_1004D01C(void *this, int a2);
void __thiscall sub_1004D075(int this, int a2);
int __thiscall sub_1004D106(void *this);
int __thiscall sub_1004D112(void *this);
int __thiscall sub_1004D12F(void *this, unsigned int a2, int a3);
BOOL __stdcall sub_1004D19D(int a1);
PSINGLE_LIST_ENTRY __thiscall sub_1004D1AC(void *this);
int __thiscall sub_1004D202(int this);
void __cdecl sub_1004D216();
// double __usercall sub_1004D276<st0>(double<st0>); weak
// int __usercall sub_1004D2F0<eax>(unsigned int a1<eax>, int a2<ecx>);
// signed int __usercall sub_1004D31B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6);
// signed int __usercall sub_1004D387<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5);
int __cdecl sub_1004D3C7(const WCHAR *a1, int a2, int a3);
// int __usercall sub_1004D5A9<eax>(int a1<edi>, int a2, int a3, LCTYPE a4, LPSTR lpMultiByteStr, int cbMultiByte);
// int __usercall sub_1004D681<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, LCTYPE a5, LPSTR lpMultiByteStr, int cbMultiByte);
int __thiscall sub_1004D6B9(int this, int a2, int a3, int a4, int a5);
bool __thiscall sub_1004D6DE(int this, char a2);
char __thiscall sub_1004D709(int this, int a2);
char __thiscall sub_1004D750(int this, int a2);
// void __usercall sub_1004D798(int a1<ebx>, int a2);
signed int __cdecl sub_1004D894(int lpMem);
// void __usercall sub_1004DC36(int a1<ebx>, int a2);
int __thiscall sub_1004DC9D(int this, int lpMem);
// void __usercall sub_1004DEA5(int a1<ebx>, int a2);
signed int __thiscall sub_1004E225(int this, int a2);
int __cdecl sub_1004E2A1(int a1, int a2);
int __thiscall sub_1004EA92(void *this, const WCHAR SrcStr, __int16 a3);
int __cdecl sub_1004EAE4(int a1, int a2);
int __cdecl sub_1004EB22(int a1, int a2);
int __cdecl sub_1004EB71(int a1, int a2, int a3);
int __cdecl sub_1004EBA7(int a1, int a2);
// int __usercall sub_1004EBE9<eax>(int a1<ebx>, int a2<edi>, int a3);
int __cdecl sub_1004EC60(int); // weak
BOOL __cdecl sub_1004ECD4(int a1);
int __cdecl sub_1004ED1E(unsigned __int16 *a1);
// unsigned int __userpurge sub_1004ED50<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
// unsigned int __userpurge sub_1004EF6E<eax>(int a1<ebx>, int a2, int a3, int a4);
// int __usercall sub_1004F01F<eax>(int a1<ebx>, int a2<edi>, int a3, int a4);
int __cdecl sub_1004F0B4(int a1);
// signed int __usercall sub_1004F0FE<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
// unsigned int __userpurge sub_1004F2C0<eax>(int a1<ebx>, int a2<edi>, int a3);
// int __usercall sub_1004F36E<eax>(int a1<ebx>, int a2<edi>, int a3);
// BOOL __usercall sub_1004F3AE<eax>(int a1<ebx>, int a2<edi>, int a3);
// int __usercall sub_1004F42B<eax>(int a1<ebx>, int a2<edi>, int a3);
int __cdecl sub_1004F484(unsigned __int16 *a1);
// signed int __userpurge sub_1004F4AE<eax>(int a1<ebx>, int a2<edi>, int a3);
// signed int __userpurge sub_1004F6A1<eax>(int a1<ebx>, int a2<edi>, int a3);
int __cdecl sub_1004F77A(int a1);
// int __usercall sub_1004F7C9<eax>(int a1<ebx>, int a2<edi>, int LCData, int a4);
signed int __cdecl sub_1004F854(__int16 a1);
// bool __usercall sub_1004F876<eax>(int a1<ebx>, int a2<edi>, int a3, int a4);
bool __cdecl sub_1004F8DE(int a1, int a2, int *a3);
// signed int __usercall sub_1004F94A<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
// signed int __usercall sub_1004FB64<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
// signed int __usercall sub_1004FC85<eax>(int a1<ebx>, int a2<edi>, int a3);
// signed int __usercall sub_1004FCA9<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5);
// signed int __usercall sub_1004FD89<eax>(int a1<edi>, LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int a4, int a5);
// signed int __usercall sub_1004FE7C<eax>(int a1<edi>, LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int a4);
// int __usercall sub_1004FE94<eax>(int a1<ebx>, int a2<edi>, signed int a3);
// void __usercall sub_1004FEE8(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, const void *a6, int nNumberOfBytesToWrite);
// int __usercall sub_1004FFCA<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<esi>, signed int a5, const void *a6, int nNumberOfBytesToWrite);
// void __usercall sub_100507F4(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, LARGE_INTEGER liDistanceToMove, DWORD dwMoveMethod);
// LARGE_INTEGER __usercall sub_100508F0<edx:eax>(int a1<ebx>, int a2<edi>, signed int a3, LARGE_INTEGER liDistanceToMove, DWORD dwMoveMethod);
// int __usercall sub_10050961<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
signed int __cdecl sub_100509A7(int a1, int a2, int a3, int a4);
// int __usercall sub_1005150F<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3, int a4, int a5);
// int __usercall sub_10051555<eax>(int a1<ebx>, unsigned __int8 a2, int a3, int a4, int a5);
int __cdecl sub_10051581(unsigned __int8 *a1, int a2, int a3, int a4, int *a5);
bool __cdecl sub_100515F9();
int __cdecl sub_1005160E(int, LPSTR UsedDefaultChar, int cbMultiByte, const WCHAR WideCharStr, int); // idb
int __cdecl sub_10051730(int a1, LPSTR UsedDefaultChar, int cbMultiByte, const WCHAR WideCharStr);
int __thiscall sub_1005174B(int this, int a2);
unsigned int __thiscall sub_10051771(int this, int a2);
// int __usercall sub_100517C2<eax>(int a1<ecx>, int a2<edi>);
int __thiscall sub_1005180B(int this, int a2);
char __thiscall sub_10051841(int this, int a2);
char __thiscall sub_1005185F(int this, int a2, int a3, char a4);
int __thiscall sub_100518F6(int this, int a2, int a3);
int __thiscall sub_10051943(int this, int a2);
int __thiscall sub_1005197E(int this, int a2);
char __stdcall sub_100519BC(int a1, int a2, char a3);
char __thiscall sub_10051A0C(void *this, int a2, int a3, char a4, int a5, char a6);
char __stdcall sub_10051A8D(int a1, int a2);
char __thiscall sub_10051ABE(void *this, int a2, int a3, int a4, char a5);
// char __userpurge sub_10051B39<al>(int a1<edi>, int a2, int a3, char a4, char a5);
char __thiscall sub_10051B8C(void *this, int a2, int a3, char a4, int a5, char a6);
int __thiscall sub_10051C1A(int this);
int __thiscall sub_10051C4F(void *this, int a2);
char __thiscall sub_10051C6E(void *this, int a2);
// char __userpurge sub_10051C9E<al>(int a1<edi>, int a2, int a3, char a4, unsigned int a5);
// char __userpurge sub_10051D0B<al>(int a1<edi>, int a2, int a3, char a4, unsigned int a5);
DWORD __thiscall sub_10051D79(int this, int a2, int a3);
// bool __usercall sub_10051DCD<eax>(int a1<ecx>, int a2<edi>);
char __thiscall sub_10051E4B(void *this, int a2, int a3, char a4, unsigned int a5);
char __thiscall sub_10052109(void *this, int a2, int a3, char a4, unsigned int a5);
char __thiscall sub_10052388(void *this, int a2, int a3, int a4, char a5, int a6, unsigned int a7, char a8);
char __thiscall sub_10052481(void *this, int a2, int a3, int a4, int a5, int i, unsigned int a7, char a8);
char __thiscall sub_10052587(void *this, int a2, int a3, int a4, char a5, int a6, unsigned int a7, char a8);
char __thiscall sub_10052683(void *this, int a2, int a3, int a4, unsigned int a5);
char __thiscall sub_10052796(void *this, int a2, int a3, int a4, unsigned int a5);
char __stdcall sub_100528A4(int a1, int a2, char a3);
char __stdcall sub_10052938(int a1, int a2);
char __stdcall sub_100529A6(int a1, int a2, char a3);
int __thiscall sub_10052A3E(int this, int a2);
int __thiscall sub_10052A5B(int this, int a2);
char __thiscall sub_10052A78(void *this, int a2, int a3, int a4, char a5);
char __thiscall sub_10052B00(void *this, int a2, int a3);
char __thiscall sub_10052B42(void *this, int a2, int a3, int a4);
// int __usercall sub_10052BAE<eax>(int a1<ecx>, int a2<ebp>);
void __thiscall sub_10052BC5(void *this, int a2);
int __thiscall sub_10052C1A(int this);
// int __userpurge sub_10052C22<eax>(int a1<ebp>, int a2, int a3);
void *__thiscall sub_10052C59(void *this, char a2);
// void __usercall sub_10052C7E(int a1<edx>, int a2<ecx>, int a3<ebx>);
// void __usercall sub_10052D1B(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
int __cdecl sub_10052E30(int, int, int, int, int); // weak
// int __usercall sub_10052E75<eax>(int a1<ebp>, int a2, unsigned int a3);
void __cdecl sub_10052F1C();
// int __userpurge sub_10052F25<eax>(int result<eax>, int a2<ebp>, int a3);
int __stdcall loc_10052F30(int); // weak
// int __usercall sub_10052F44<eax>(int (*a1)(void)<eax>);
int __thiscall sub_10052F50(void *this, unsigned int a2, unsigned __int8 a3);
// signed int __usercall sub_10053087<eax>(int a1<ebx>, int a2, unsigned int a3, int a4, int a5);
// signed int __usercall sub_10053137<eax>(int a1<ebx>, int a2, int a3, int a4);
// signed int __usercall sub_100531C3<eax>(int a1<ebx>, int a2, int a3, int a4);
__int16 __cdecl sub_1005324F(int a1, int a2);
int __stdcall sub_100533B0(unsigned __int64 a1, __int64 a2);
// unsigned __int64 __usercall sub_10053490<edx:eax>(unsigned __int64 a1<edx:eax>, unsigned __int8 a2<cl>);
// signed int __usercall sub_100534AF<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
// void __usercall sub_1005350C(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// WCHAR __usercall sub_10053515<ax>(int a1<ebx>, int a2<edi>, const WCHAR SrcStr, int a4);
// int __usercall sub_100535C7<eax>(int a1<ebp>, int a2, int a3, int a4);
// int __usercall sub_100536D0<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, signed int a6, int a7);
// int __usercall sub_100538F4<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, signed int a5);
// const WCHAR *__usercall sub_1005391E<eax>(int a1<ebx>);
// signed int __usercall sub_100539AB<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
// signed int __usercall sub_100539C3<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6);
double sub_10053ABC(void); // weak
int __thiscall sub_10053B0B(int this, int a2, int a3, int a4);
int __thiscall sub_10053B52(int this);
int __thiscall sub_10053B5A(int this);
int __thiscall sub_10053B5E(int this);
int __thiscall sub_10053B65(int this, int a2);
int __thiscall sub_10053BCA(int this);
int __thiscall sub_10053BE2(int this);
int __thiscall sub_10053BEF(int this);
int __thiscall sub_10053BFC(int this, int a2, int a3, int a4);
bool __thiscall sub_10053C2B(int this, int a2);
int __thiscall sub_10053C4C(int this, char a2);
int __thiscall sub_10053C73(void *this);
BOOL __thiscall sub_10053CA2(void *this, int a2);
int __thiscall sub_10053D54(void *this, int a2);
char __thiscall sub_10053DB1(int this, int a2);
BOOL __thiscall sub_10053E97(int this, int a2);
int __thiscall sub_10053F14(int this, int a2);
int __thiscall sub_10053F71(void *this, int a2, __int16 a3, int a4);
char __thiscall sub_10053FA7(void *this);
int __thiscall sub_10053FD5(int this, int a2);
void __fastcall sub_10053FEA(int a1);
int __thiscall sub_10054064(int this);
int __thiscall sub_10054074(int this, int a2);
BOOL __thiscall sub_100540D6(void *this, int a2, int a3);
int __cdecl sub_10054178(int a1);
int __cdecl sub_10054195(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_100542A8(int a1, int a2, int a3);
int __cdecl sub_1005432E(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_100544AB(int a1, int a2);
bool __cdecl sub_100544CF(int a1, int a2, int a3, int a4, int a5);
LPVOID __thiscall sub_100545AB(LPVOID lpParameter, int a2, int a3);
int __thiscall sub_100546AB(int this);
void *__thiscall sub_100546CF(int this, char a2);
BOOL __thiscall sub_100546EE(int this);
int __thiscall sub_100546FF(int this);
BOOL __thiscall sub_10054703(int this);
BOOL __thiscall sub_1005470D(int this, int nPriority);
char __thiscall sub_10054757(int this);
int __thiscall sub_10054782(int this);
int __stdcall sub_1005479C(int a1);
// signed int __usercall sub_100547D4<eax>(int a1<ebx>, int a2<edi>, unsigned int a3, int a4, unsigned int a5, unsigned int a6);
// signed int __userpurge sub_100547FD<eax>(int a1<ebx>, int a2<edi>, unsigned int a3, int a4, unsigned int a5, unsigned int a6, int a7);
// int __usercall sub_100548F0<eax>(int a1<ebx>, int a2<edi>, int a3);
int __cdecl sub_10054904(int a1, unsigned __int16 a2);
// signed int __usercall sub_100549B2<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
// signed int __usercall sub_10054A66<eax>(int a1<edi>, int a2, int a3, int a4, int a5);
// void __usercall sub_10054B5D(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5, const CHAR *lpWideCharStr, signed int nNumberOfBytesToRead);
// signed int __usercall sub_10054C65<eax>(int a1<ebx>, unsigned int a2, const CHAR *lpWideCharStr, signed int nNumberOfBytesToRead);
// void __usercall sub_100553F4(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
// signed int __usercall sub_10055480<eax>(int a1<ebx>, signed int a2);
// signed int __usercall sub_10055506<eax>(int a1<ebx>, int a2<edi>, signed int a3);
void __cdecl sub_1005556D(signed int a1);
signed __int16 __thiscall sub_10055593(DWORD this, __int16 Buffer);
// signed int __usercall sub_100555D4<eax>(int a1<ebx>, int a2);
// void __usercall sub_10055640(int a1<edx>, int a2<ebx>, unsigned int a3);
// int __usercall sub_100556B7<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, unsigned int a5, int a6);
// int __usercall sub_10055893<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, unsigned int a5);
signed int __cdecl sub_100558AB(int a1, int a2);
signed int __cdecl sub_10055E1B(int a1, int a2);
signed int __cdecl sub_1005638B(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
signed int __cdecl sub_10056B07(__int64 a1, __int16 a2, int a3, char a4, int a5);
signed int __cdecl sub_100574CB(int a1);
int __cdecl sub_10057574(int a1, int a2);
signed int __cdecl sub_10057874(int a1);
// signed int __usercall sub_1005790B<eax>(int a1<ebx>, int a2<edi>, int a3, int a4);
// int __usercall sub_10057B51<eax>(int a1<ebx>, int *a2);
// int __usercall sub_10057BB1<eax>(int a1<ebx>, int a2, int a3);
// signed int __usercall sub_10057C0C<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_10057CCF();
// void __usercall sub_10057CE0(int a1<ebx>, __int64 a2<st0>);
// double __usercall sub_10057CFE<st0>(int a1<ebx>, __int64 a2);
// double __usercall sub_10057FB1<st0>(int a1<ebp>, double result<st0>);
double __fastcall sub_100580E1(char a1);
int sub_100580EE(void); // weak
// double __usercall sub_10058131<st0>(double result<st0>);
// void __usercall sub_100581DE(int a1<edx>, __int16 a2<cx>, __int16 a3<fpstat>, double a4<st0>, char a5, char a6, char a7);
int sub_1005825C(void); // weak
// double __usercall sub_10058263<st0>(int a1<ebp>, double result<st0>);
// int __usercall sub_100583AA<eax>(__int16 a1<fpstat>, char a2, char a3, char a4, double a5);
double __cdecl sub_100583DD(double a1);
BOOL __cdecl sub_10058419();
HANDLE __cdecl sub_10058430();
// void __usercall sub_1005844F(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// signed int __usercall sub_10058519<eax>(int a1<ebx>, int a2);
// int __usercall sub_100585B3<eax>(int a1<ebx>, int a2);
int __cdecl sub_100585E3(unsigned __int16 a1);
int __cdecl sub_10058782(unsigned int *a1, int a2, int a3);
// int __usercall sub_10058964<eax>(int a1<ebx>, int a2);
// int __usercall sub_100589B4<eax>(int a1<ebx>, int a2<edi>, int a3, int a4);
// int __usercall sub_100589C9<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
// signed int __usercall sub_10058A64<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned __int8 *a4, signed int a5, int a6);
// int __usercall sub_10058B13<eax>(int a1<ebx>, int a2, int a3, int a4, signed int a5);
int __cdecl sub_10058DFB(double); // idb
signed int __cdecl sub_10058E61(long double a1, double a2, int a3);
signed int __cdecl sub_10058FA0(unsigned __int8 *a1, unsigned __int8 *a2, signed int a3);
double __cdecl sub_10059001(double a1);
// BOOL __stdcall IsProcessorFeaturePresent(DWORD ProcessorFeature);
// void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
// double __usercall sub_10059020<st0>(__int16 a1<cx>, int a2<ebx>, double a3);
// void __usercall sub_10059220(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10059243<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10059266<eax>(int a1<ebp>);
// _DWORD *__usercall sub_1005926E<eax>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10059291<eax>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10059299<eax>(int a1<ebp>);
int __thiscall sub_100592BC(void *this);
int __thiscall sub_100592E9(void *this);
int __thiscall sub_10059312(void *this);
int __thiscall sub_10059323(void *this);
// int __usercall sub_1005934F<eax>(int a1<ebp>);
void __cdecl sub_10059375();
// void __usercall sub_10059398(int a1<ebx>, int a2<ebp>);
void __cdecl sub_100593A0();
void __cdecl sub_100593CD();
// unsigned int __usercall sub_100593F0<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_100593F8();
// void __usercall sub_10059421(int a1<ebp>);
// int __usercall sub_10059444<eax>(int a1<ebp>);
// int __usercall sub_1005946A<eax>(int a1<ebp>);
int __cdecl sub_10059490();
// void __usercall sub_100594B3(int a1<ebx>, int a2<ebp>);
int __thiscall sub_100594E0(void *this);
// void __usercall sub_10059546(int a1<ebp>);
// int __usercall sub_1005954E<eax>(int a1<ebp>);
// int __usercall sub_1005955C<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10059585();
// int __usercall sub_100595A8<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005961C();
// int __usercall sub_10059624<eax>(int a1<ebp>);
int __thiscall sub_1005962E(void *this);
// int __usercall sub_1005963C<eax>(int a1<ebp>);
// void __usercall sub_10059655(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10059678<eax>(int a1<ebp>);
// void __usercall sub_10059682(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005968A<eax>(int a1<ebp>);
// void __usercall sub_100596BE(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// void __usercall sub_100596E1(int a1<ebp>);
// void __usercall sub_10059704(int a1<ebp>);
// int __usercall sub_1005970C<eax>(LPVOID *this<ecx>, int a2<ebp>);
// int __usercall sub_10059717<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10059722<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005972D<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10059738<eax>(int a1<ebp>);
// int __usercall sub_10059743<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// int __usercall sub_1005974E<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// void __usercall sub_1005975C(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
void __cdecl sub_1005976A();
void __cdecl sub_10059778();
void __cdecl sub_100597A1();
// int __usercall sub_100597A9<eax>(LPVOID *this<ecx>, int a2<ebp>);
// int __usercall sub_100597B4<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_100597BF<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_100597CA<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_100597D5();
// int __usercall sub_100597E0<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// int __usercall sub_100597EB<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// void __usercall sub_100597F9(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
void __cdecl sub_10059807();
void __cdecl sub_10059815();
// int __usercall sub_1005983E<eax>(int a1<ebp>);
// int __usercall sub_10059872<eax>(int a1<ebp>);
// int __usercall sub_1005987A<eax>(LPVOID *this<ecx>, int a2<ebp>);
// int __usercall sub_100598B8<eax>(int a1<ebp>);
void __cdecl sub_100598C2();
// int __usercall sub_100598CA<eax>(int a1<ebp>);
// int __usercall sub_100598D4<eax>(int a1<ebp>);
// int __usercall sub_100598F9<eax>(int a1<ebp>);
// int __usercall sub_10059903<eax>(int a1<ebp>);
// void __usercall sub_10059943(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
// int __usercall sub_1005994E<eax>(int a1<ebp>);
// void __usercall sub_10059974(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
// int __usercall sub_1005997F<eax>(int a1<ebp>);
// int __usercall sub_100599A5<eax>(int a1<ebp>);
// int __usercall sub_100599D4<eax>(LPVOID *this<ecx>, int a2<ebp>);
// int __usercall sub_100599DC<eax>(int a1<ebp>);
void __cdecl sub_10059A01();
// int __usercall sub_10059A09<eax>(int a1<ebp>);
// int __usercall sub_10059A13<eax>(int a1<ebp>);
void __cdecl sub_10059A38();
void __cdecl sub_10059A5B();
// void __usercall sub_10059A7E(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
void __cdecl sub_10059AA1();
// int __usercall sub_10059ADF<eax>(int a1<ebp>);
// int __usercall sub_10059B12<eax>(int a1<ebp>);
// int __usercall sub_10059B35<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10059B3D<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10059B63();
void __cdecl sub_10059B86();
void __cdecl sub_10059BA9();
// int __usercall sub_10059BB4<eax>(int a1<ebp>);
// void __usercall sub_10059BD9(int a1<ebp>);
void __cdecl sub_10059BFC();
void __cdecl sub_10059C07();
// int __usercall sub_10059C0F<eax>(int a1<ebp>);
// int __usercall sub_10059C1A<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// int __usercall sub_10059C25<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
void __cdecl sub_10059C4E();
void __cdecl sub_10059C74();
// int __usercall sub_10059C9A<eax>(int a1<ebp>);
// int __usercall sub_10059CDA<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10059CE5();
void __cdecl sub_10059D0E();
void __cdecl sub_10059D19();
// int __usercall sub_10059D3F<eax>(void *this<ecx>, int a2<ebp>);
int __cdecl sub_10059D65();
// int __usercall sub_10059D88<eax>(LPVOID *this<ecx>, int a2<ebp>);
// int __usercall sub_10059DBC<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// int __usercall sub_10059DC7<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// int __usercall sub_10059DED<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// int __usercall sub_10059E13<eax>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10059E36<eax>(void *this<ecx>, int a2<ebp>);
// void __usercall sub_10059E59(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
// int __usercall sub_10059E64<eax>(int a1<ebp>);
// void __usercall sub_10059E89(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
void __cdecl sub_10059EAF();
void __cdecl sub_10059ED2();
// int __usercall sub_10059EF5<eax>(int a1<ebp>);
// int __usercall sub_10059F1A<eax>(int a1<ebp>);
void __cdecl sub_10059F3F();
// void __usercall sub_10059F62(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
// void __usercall sub_10059F88(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
// int __usercall sub_10059FAE<eax>(int a1<ebp>);
// void __usercall sub_10059FE0(int a1<ebp>);
int __thiscall sub_10059FE8(void *this);
// int __usercall sub_10059FFC<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005A020<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005A028();
void __cdecl sub_1005A030();
// int __usercall sub_1005A038<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005A040();
// int __usercall sub_1005A048<eax>(int a1<ebp>);
void __cdecl sub_1005A053();
// int __usercall sub_1005A080<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005A088();
void __cdecl sub_1005A090();
void __cdecl sub_1005A0C0();
// int __usercall sub_1005A0F0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005A0F8();
// int __usercall sub_1005A100<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005A108<eax>(int a1<ebp>);
// int __usercall sub_1005A140<eax>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005A148<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005A150();
// int __usercall sub_1005A158<eax>(int a1<ebp>);
void __cdecl sub_1005A163();
// int __usercall sub_1005A16B<eax>(int a1<ebp>);
void __cdecl sub_1005A1A0();
void __cdecl sub_1005A1D0();
int __thiscall sub_1005A200(void *this);
void __cdecl sub_1005A211();
void __cdecl sub_1005A219();
void __cdecl sub_1005A260();
void __cdecl sub_1005A290();
// int __usercall sub_1005A298<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005A2A0();
void __cdecl sub_1005A2D0();
// int __usercall sub_1005A300<eax>(int a1<ebp>);
void __cdecl sub_1005A350();
void __cdecl sub_1005A358();
void __cdecl sub_1005A390();
void __cdecl sub_1005A398();
void __cdecl sub_1005A3A0();
void __cdecl sub_1005A3A8();
int __thiscall sub_1005A3E0(void *this);
// int __usercall sub_1005A410<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005A440();
void __cdecl sub_1005A448();
// int __usercall sub_1005A480<eax>(int a1<ebp>);
// int __usercall sub_1005A4B0<eax>(int a1<ebp>);
// int __usercall sub_1005A4BB<eax>(int a1<ebp>);
// int __usercall sub_1005A4F0<eax>(int a1<ebp>);
// int __usercall sub_1005A4FB<eax>(int a1<ebp>);
void __cdecl sub_1005A530();
// int __usercall sub_1005A560<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>);
// int __usercall sub_1005A568<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>);
// int __usercall sub_1005A570<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005A57B<eax>(int a1<ebp>);
void __cdecl sub_1005A5B0();
void __cdecl sub_1005A5E0();
int __thiscall sub_1005A5E8(void *this);
// int __usercall sub_1005A5FC<eax>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005A604<eax>(int a1<ebp>);
// int __usercall sub_1005A630<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005A638<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005A640<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005A64B();
// int __usercall sub_1005A656<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005A680<eax>(int a1<ebp>);
// int __usercall sub_1005A68B<eax>(int a1<ebp>);
void __cdecl sub_1005A696();
void __cdecl sub_1005A6C0();
// int __usercall sub_1005A6F0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>);
// int __usercall sub_1005A720<eax>(int a1<ebp>);
// int __usercall sub_1005A728<eax>(int a1<ebp>);
// int __usercall sub_1005A750<eax>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005A758<eax>(int a1<ebp>);
// int __usercall sub_1005A763<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005A76E();
int __cdecl sub_1005A779(int, int); // weak
// int __usercall sub_1005A7A0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005A7A8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005A7E0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005A7E8<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005A7F3();
void __cdecl sub_1005A820();
// int __usercall sub_1005A850<eax>(int a1<ebp>);
// int __usercall sub_1005A85B<eax>(int a1<ebp>);
// int __usercall sub_1005A866<eax>(int a1<ebp>);
// int __usercall sub_1005A871<eax>(int a1<ebp>);
void __cdecl sub_1005A8A0();
// int __usercall sub_1005A8A8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005A8B0<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005A8B8();
// int __usercall sub_1005A8C0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005A8CB<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005A900();
void __cdecl sub_1005A930();
void __cdecl sub_1005A960();
void __cdecl sub_1005A990();
void __cdecl sub_1005A9C0();
void __cdecl sub_1005A9C8();
void __cdecl sub_1005AA00();
void __cdecl sub_1005AA08();
int __cdecl sub_1005AA10(int, int); // weak
void __cdecl sub_1005AA40();
void __cdecl sub_1005AA48();
void __cdecl sub_1005AA80();
void __cdecl sub_1005AA88();
int __cdecl sub_1005AA90(int, int); // weak
void __cdecl sub_1005AAC0();
void __cdecl sub_1005AAC8();
// int __usercall sub_1005AB00<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005AB30<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005AB38<eax>(int this<ecx>, int a2<ebp>);
int __cdecl sub_1005AB40();
// int __usercall sub_1005AB4A<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005AB52<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005AB80<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005AB88();
// int __usercall sub_1005AB90<eax>(int a1<ebp>);
// int __usercall sub_1005ABD0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005ABD8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005ABE0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005ABE8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005ABF0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005ABF8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005AC00();
// int __usercall sub_1005AC08<eax>(int a1<ebp>);
void __cdecl sub_1005AC50();
// int __usercall sub_1005AC80<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005AC8B<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005AC96<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005ACA1<eax>(int a1<ebp>);
void __cdecl sub_1005ACE0();
// int __usercall sub_1005ACE8<eax>(int a1<ebp>);
// int __usercall sub_1005ACF0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005AD20<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005AD28();
void __cdecl sub_1005AD60();
void __cdecl sub_1005AD90();
void __cdecl sub_1005AD98();
void __cdecl sub_1005ADC0();
void __cdecl sub_1005ADC8();
void __cdecl sub_1005ADD0();
// int __usercall sub_1005ADD8<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005ADE0();
int __thiscall sub_1005AE10(void *this);
// void __usercall sub_1005AE21(int a1<ebp>);
void __cdecl sub_1005AE29();
int __cdecl sub_1005AE50(int, int); // weak
int __cdecl sub_1005AE70(int, int); // weak
// int __usercall sub_1005AE90<eax>(int a1<ebp>);
// int __usercall sub_1005AED0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005AED8();
void __cdecl sub_1005AF10();
// int __usercall sub_1005AF40<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005AF70();
void __cdecl sub_1005AFA0();
void __cdecl sub_1005AFD0();
void __cdecl sub_1005B000();
void __cdecl sub_1005B008();
void __cdecl sub_1005B010();
void __cdecl sub_1005B040();
// int __usercall sub_1005B048<eax>(int a1<ebp>);
void __cdecl sub_1005B053();
// int __usercall sub_1005B0A0<eax>(int a1<ebp>);
void __cdecl sub_1005B0D0();
void __cdecl sub_1005B100();
void __cdecl sub_1005B108();
int __thiscall sub_1005B130(void *this);
int __thiscall sub_1005B141(void *this);
void __cdecl sub_1005B170();
// int __usercall sub_1005B1A0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005B1A8<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005B1B0();
// int __usercall sub_1005B1B8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005B1C0();
void __cdecl sub_1005B1F0();
void __cdecl sub_1005B1F8();
// int __usercall sub_1005B220<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005B228(int a1<ebp>);
// int __usercall sub_1005B250<eax>(int this<ecx>, int a2<ebp>);
int __cdecl sub_1005B280();
// int __usercall sub_1005B2B0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B2B8<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B2C3<eax>(int a1<ebp>);
// int __usercall sub_1005B300<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005B340();
void __cdecl sub_1005B348();
int __thiscall sub_1005B370(void *this);
void __cdecl sub_1005B381();
void __cdecl sub_1005B3D0();
// void __usercall sub_1005B420(int a1<ebx>, int a2<ebp>);
// void __usercall sub_1005B480(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005B4B0<eax>(int a1<ebp>);
// char __usercall sub_1005B4E0<al>(int a1<ebp>);
// int __usercall sub_1005B4FC<eax>(int a1<ebp>);
// void __usercall sub_1005B507(int a1<ebp>);
// int __usercall sub_1005B530<eax>(int a1<ebp>);
// int __usercall sub_1005B560<eax>(int a1<ebp>);
// int __usercall sub_1005B56B<eax>(int a1<ebp>);
// void __usercall sub_1005B5A0(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005B5A8(int a1<ebx>, int a2<ebp>);
void __cdecl sub_1005B5B3();
void __cdecl sub_1005B5BE();
void __cdecl sub_1005B5C9();
void __cdecl sub_1005B5D4();
void __cdecl sub_1005B5DF();
// int __usercall sub_1005B610<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B640<eax>(int a1<ebp>);
void __cdecl sub_1005B670();
void __cdecl sub_1005B6A0();
void __cdecl sub_1005B6A8();
// void __usercall sub_1005B6B0(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005B6E0<eax>(int a1<ebp>);
// int __usercall sub_1005B6EB<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005B6F3();
void __cdecl sub_1005B6FB();
// void __usercall sub_1005B703(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005B70B();
void __cdecl sub_1005B740();
void __cdecl sub_1005B770();
// void __usercall sub_1005B7A0(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005B7A8<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005B7B0(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005B7B8<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B7F0<eax>(int a1<ebp>);
// int __usercall sub_1005B820<eax>(int a1<ebp>);
// int __usercall sub_1005B850<eax>(int a1<ebp>);
// void __usercall sub_1005B85B(void *this<ecx>, int a2<ebx>, int a3<ebp>);
// void __usercall sub_1005B874(int a1<ebp>);
// void __usercall sub_1005B8C0(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005B8C8<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005B8D0(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005B8D8<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B930<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B938<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B960<eax>(int a1<ebp>);
// int __usercall sub_1005B990<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B9D0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B9D8<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B9E0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B9E8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005BA20<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005BA28<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BA30<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BA38<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BA40<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005BA48<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005BA70<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BA78<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005BAB0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BAB8<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BAC0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BAF0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BAF8<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005BB20(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005BB28<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005BB60();
// int __usercall sub_1005BBD0<eax>(int a1<ebp>);
void __cdecl sub_1005BC00();
// int __usercall sub_1005BC08<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005BC30(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005BC60<eax>(int this<ecx>, int a2<ebp>);
int __thiscall sub_1005BC90(void *this);
// int __usercall sub_1005BCC0<eax>(int a1<ebp>);
// int __usercall sub_1005BCCB<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005BCD3<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BD00<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BD08<eax>(int a1<ebp>);
// int __usercall sub_1005BD13<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005BD1B<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BD23<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BD2B<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BD60<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005BD68<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005BD70<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005BD78<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BDD0<eax>(int a1<ebp>);
// int __usercall sub_1005BDDB<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005BDE3();
void __cdecl sub_1005BDEB();
// void __usercall sub_1005BDF3(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005BDFB();
// int __usercall sub_1005BE30<eax>(int a1<ebp>);
// int __usercall sub_1005BE60<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BE6B<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BE76<eax>(int this<ecx>, int a2<ebp>);
// char __usercall sub_1005BE7E<al>(int a1<ebp>);
// int __usercall sub_1005BE89<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BEC0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BECB<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BED3<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BEDB<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BEE3<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BEEB<eax>(int a1<ebp>);
// int __usercall sub_1005BEF6<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005BF30(int a1<ebp>);
// void __usercall sub_1005BF60(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005BF68(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005BFE0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BFE8<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C020<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C060<eax>(int a1<ebp>);
// int __usercall sub_1005C090<eax>(int this<ecx>, int a2<ebp>);
// LPVOID __usercall sub_1005C0A9<eax>(LPVOID *this<ecx>, int a2<ebp>);
// void __usercall sub_1005C0B1(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005C0B9(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005C0E0<eax>(int this<ecx>, int a2<ebp>);
// LPVOID __usercall sub_1005C0F9<eax>(LPVOID *this<ecx>, int a2<ebp>);
// void __usercall sub_1005C101(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005C109(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005C130();
void __cdecl sub_1005C138();
// LPVOID __usercall sub_1005C143<eax>(LPVOID *this<ecx>, int a2<ebp>);
// LPVOID __usercall sub_1005C170<eax>(LPVOID *this<ecx>, int a2<ebp>);
// LPVOID __usercall sub_1005C178<eax>(int a1<ebp>);
// int __usercall sub_1005C1A0<eax>(int a1<ebp>);
// int __usercall sub_1005C1D0<eax>(int a1<ebp>);
// void __usercall sub_1005C210(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005C218(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005C240<eax>(int a1<ebp>);
void __cdecl sub_1005C248();
void __cdecl sub_1005C253();
// int __usercall sub_1005C25E<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005C290(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005C2C0(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005C2F0<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005C320(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005C328(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005C390(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005C3C0();
void __cdecl sub_1005C3C8();
void __cdecl sub_1005C3D0();
void __cdecl sub_1005C3D8();
// int __usercall sub_1005C410<eax>(int a1<ebp>);
// int __usercall sub_1005C418<eax>(int a1<ebp>);
void __cdecl sub_1005C420();
void __cdecl sub_1005C428();
void __cdecl sub_1005C460();
void __cdecl sub_1005C468();
// int __usercall sub_1005C4A0<eax>(int a1<ebp>);
// int __usercall sub_1005C4AB<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005C4E0(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005C510();
// int __usercall sub_1005C540<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C570<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005C5B0(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005C5E0<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005C620(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005C650<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C658<eax>(int this<ecx>, int a2<ebp>);
int __cdecl sub_1005C680();
// int __usercall sub_1005C6B0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C6B8<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C6C0<eax>(int a1<ebp>);
int __cdecl sub_1005C6F0();
// int __usercall sub_1005C720<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C728<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C730<eax>(int a1<ebp>);
// int __usercall sub_1005C780<eax>(int a1<ebp>);
// int __usercall sub_1005C7C0<eax>(int a1<ebp>);
// int *__usercall sub_1005C800<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005C808();
void __cdecl sub_1005C810();
// int __usercall sub_1005C81B<eax>(int a1<ebp>);
// int __usercall sub_1005C823<eax>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005C860<eax>(int a1<ebp>);
void __cdecl sub_1005C86B();
int __thiscall sub_1005C873(void *this);
// int __usercall sub_1005C887<eax>(int a1<ebp>);
// void __usercall sub_1005C8C0(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005C8F0();
void __cdecl sub_1005C8F8();
// void __usercall sub_1005C903(void *a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005C90E<eax>(int a1<ebp>);
// void __usercall sub_1005C940(int a1<ebp>);
// int __usercall sub_1005C948<eax>(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005C953(void *a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005C980<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C988<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C993<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C99E<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005C9A9();
void __cdecl sub_1005C9B7();
// int __usercall sub_1005C9C5<eax>(int a1<ebp>);
// int __usercall sub_1005C9D3<eax>(int a1<ebp>);
void __cdecl sub_1005C9E1();
// int __usercall sub_1005C9E9<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C9F1<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005C9F9();
// int __usercall sub_1005CA01<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CA0F<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005CA1D();
void __cdecl sub_1005CA2B();
// int __usercall sub_1005CA39<eax>(int a1<ebp>);
// int __usercall sub_1005CA47<eax>(int a1<ebp>);
void __cdecl sub_1005CA70();
void __cdecl sub_1005CAA0();
// int __usercall sub_1005CAA8<eax>(int a1<ebp>);
// int __usercall sub_1005CAB3<eax>(int a1<ebp>);
void __cdecl sub_1005CABE();
// int __usercall sub_1005CAF0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005CAF8<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005CB30(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005CB60();
// void __usercall sub_1005CB90(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005CB9B<eax>(int a1<ebp>);
// int __usercall sub_1005CBA6<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CBB1<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CBBC<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005CBF0();
void __cdecl sub_1005CBF8();
// void __usercall sub_1005CC03(void *a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005CC0E<eax>(int a1<ebp>);
// int __usercall sub_1005CC40<eax>(int a1<ebp>);
void __cdecl sub_1005CC48();
void __cdecl sub_1005CC70();
// int __usercall sub_1005CC78<eax>(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005CC83(void *a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005CC8E<eax>(int a1<ebp>);
void __cdecl sub_1005CC96();
// void __usercall sub_1005CCC0(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005CCC8(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>);
// int __usercall sub_1005CCF0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CCF8<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CD03<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CD0E<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CD19<eax>(int a1<ebp>);
void __cdecl sub_1005CD27();
// int __usercall sub_1005CD35<eax>(int a1<ebp>);
// int __usercall sub_1005CD43<eax>(int a1<ebp>);
// int __usercall sub_1005CD51<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005CD5F();
void __cdecl sub_1005CD6D();
// int __usercall sub_1005CD7B<eax>(int a1<ebp>);
// int __usercall sub_1005CD89<eax>(int a1<ebp>);
// int __usercall sub_1005CD97<eax>(int a1<ebp>);
// char __usercall sub_1005CDC0<al>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005CDF0();
// int __usercall sub_1005CDF8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005CE00<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005CE08<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005CE13<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005CE1B<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CE26<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CE31<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005CE39<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CE44<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CE4F<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CE5A<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CE65<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CE70<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CEB0<eax>(int a1<ebp>);
// void __usercall sub_1005CEBB(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005CEC3(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>);
void __cdecl sub_1005CEF0();
void __cdecl sub_1005CEF8();
void __cdecl sub_1005CF30();
void __cdecl sub_1005CF38();
int __cdecl sub_1005CF40(int, int); // weak
// void __usercall sub_1005CF70(int a1<ebp>);
// int __usercall sub_1005CFA0<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005CFA8();
// char __usercall sub_1005CFE0<al>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005CFE8<eax>(int a1<ebp>);
// int __usercall sub_1005D020<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005D028();
void __cdecl sub_1005D030();
// int __usercall sub_1005D038<eax>(int a1<ebp>);
// int __usercall sub_1005D043<eax>(int a1<ebp>);
void __cdecl sub_1005D05C();
// int __usercall sub_1005D064<eax>(int a1<ebp>);
// int __usercall sub_1005D0A0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005D0A8<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005D0B0<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005D0B8();
// int __usercall sub_1005D0F0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D0F8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D100<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D108<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D110<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D118<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D120<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D128<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D130<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D138<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D140<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D148<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005D150();
// int __usercall sub_1005D158<eax>(int a1<ebp>);
void __cdecl sub_1005D1A0();
void __cdecl sub_1005D1A8();
void __cdecl sub_1005D1E0();
void __cdecl sub_1005D1E8();
void __cdecl sub_1005D1F0();
// int __usercall sub_1005D1F8<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005D200();
void __cdecl sub_1005D230();
// int __usercall sub_1005D238<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005D240();
// void __usercall sub_1005D270(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005D2A0<eax>(int a1<ebp>);
// int __usercall sub_1005D2D0<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005D2D8();
void __cdecl sub_1005D300();
void __cdecl sub_1005D330();
// int __usercall sub_1005D360<eax>(int a1<ebp>);
// int __usercall sub_1005D390<eax>(int a1<ebp>);
// void __usercall sub_1005D39B(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005D3D0();
// int __usercall sub_1005D400<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005D408();
// int __usercall sub_1005D410<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005D440();
// int __usercall sub_1005D448<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005D470();
// int __usercall sub_1005D478<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005D4A0(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005D4D0(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005D500<eax>(int a1<ebp>);
// void __usercall sub_1005D530(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005D560(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005D590<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005D598();
// void __usercall sub_1005D5D0(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005D600(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005D630();
// int __usercall sub_1005D660<eax>(int a1<ebp>);
// int __usercall sub_1005D690<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005D6C0<eax>(int a1<ebp>);
// int __usercall sub_1005D6CB<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005D700();
void __cdecl sub_1005D708();
// int __usercall sub_1005D740<eax>(int a1<ebp>);
// int __usercall sub_1005D748<eax>(int a1<ebp>);
// int __usercall sub_1005D750<eax>(int a1<ebp>);
// int __usercall sub_1005D75B<eax>(int a1<ebp>);
// int __usercall sub_1005D763<eax>(int a1<ebp>);
// int __usercall sub_1005D76B<eax>(int a1<ebp>);
// int __usercall sub_1005D7B0<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005D7F0();
void __cdecl sub_1005D820();
// int __usercall sub_1005D850<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005D880<eax>(int a1<ebx>);
// int __usercall sub_1005E180<eax>(int a1<ebx>);
// int __usercall sub_1005E470<eax>(int a1<ebx>);
// int __usercall sub_1005E7F0<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005EA40<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
// int __usercall sub_1005EA60<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_1005EA70<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_1005EA80<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// __int64 __usercall sub_1005EA90<edx:eax>(int a1<ebx>);
// int __usercall sub_1005EF20<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_1005EF40<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005EF60<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005F0D0<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005F230<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005F250<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005F270<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005F290<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005F2B0<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005F2D0<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005F317<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_1005F323<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_1005F32F<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005F345<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_1005F351<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005F367<eax>(int a1<ebx>, int a2<edi>);
void **__cdecl sub_1005F37F();
unsigned int __cdecl sub_1005F38D();
void __cdecl sub_1005F398();
void __cdecl sub_1005F3A3();
void __cdecl sub_1005F3AE();
void __cdecl sub_1005F3B9();
void __cdecl sub_1005F3C4();
signed int __cdecl sub_1005F3D0();
signed int __cdecl sub_1005F3F0();
signed int __cdecl sub_1005F410();
signed int __cdecl sub_1005F430();
int sub_1005F450(); // weak
void __cdecl sub_1005F460();
int sub_1005F470(); // weak
int sub_1005F480(); // weak
int sub_1005F490(); // weak
int __cdecl sub_1005F4A0();
signed int __cdecl sub_1005F500();
signed int __cdecl sub_1005F520();
int __cdecl sub_1005F540();
int __cdecl sub_1005F5A0();
int __cdecl sub_1005F600();
int __cdecl sub_1005F660();
int __cdecl sub_1005F6C0();
int __cdecl sub_1005F720();
int sub_1005F770(); // weak
int sub_1005F77A(); // weak
int sub_1005F784(); // weak
int sub_1005F78E(); // weak
int sub_1005F798(); // weak
int sub_1005F7A2(); // weak
// HANDLE __stdcall CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// BOOL __stdcall SetEnvironmentVariableA(LPCSTR lpName, LPCSTR lpValue);
// BOOL __stdcall WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// BOOL __stdcall ReadConsoleW(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable);
// BOOL __stdcall FlushFileBuffers(HANDLE hFile);
// BOOL __stdcall SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// int __stdcall GetThreadPriority(HANDLE hThread);
// DWORD __stdcall FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments);
// DWORD __stdcall GetLastError();
// HGLOBAL __stdcall GlobalFree(HGLOBAL hMem);
// HLOCAL __stdcall LocalFree(HLOCAL hMem);
// LONG __stdcall InterlockedIncrement(volatile LONG *lpAddend);
// LONG __stdcall InterlockedDecrement(volatile LONG *lpAddend);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);
// PVOID __stdcall EncodePointer(PVOID Ptr);
// PVOID __stdcall DecodePointer(PVOID Ptr);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall Sleep(DWORD dwMilliseconds);
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// BOOL __stdcall GetStringTypeW(DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
// DWORD __stdcall GetCurrentThreadId();
// BOOL __stdcall InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// BOOL __stdcall CreateTimerQueueTimer(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags);
// HANDLE __stdcall CreateTimerQueue();
// PSINGLE_LIST_ENTRY __stdcall InterlockedPopEntrySList(PSLIST_HEADER ListHead);
// PSINGLE_LIST_ENTRY __stdcall InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSINGLE_LIST_ENTRY ListEntry);
// PSINGLE_LIST_ENTRY __stdcall InterlockedFlushSList(PSLIST_HEADER ListHead);
// USHORT __stdcall QueryDepthSList(PSLIST_HEADER ListHead);
// BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);
// void __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments);
// BOOL __stdcall IsDebuggerPresent();
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// void __stdcall SetLastError(DWORD dwErrCode);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// HMODULE __stdcall LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// HMODULE __stdcall LoadLibraryW(LPCWSTR lpLibFileName);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
// BOOL __stdcall SetEvent(HANDLE hEvent);
// BOOL __stdcall ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// HANDLE __stdcall CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
// void __stdcall InitializeSListHead(PSLIST_HEADER ListHead);
// HANDLE __stdcall GetCurrentProcess();
// BOOL __stdcall SwitchToThread();
// DWORD __stdcall TlsAlloc();
// BOOL __stdcall TlsFree(DWORD dwTlsIndex);
// DWORD __stdcall GetTickCount();
// BOOL __stdcall UnregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent);
// BOOL __stdcall ChangeTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period);
// BOOL __stdcall GetNumaHighestNodeNumber(PULONG HighestNodeNumber);
// BOOL __stdcall RegisterWaitForSingleObject(PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags);
// void __stdcall OutputDebugStringW(LPCWSTR lpOutputString);
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// HANDLE __stdcall GetCurrentThread();
// BOOL __stdcall GetThreadTimes(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// void __stdcall FreeLibraryAndExitThread(HMODULE hLibModule, DWORD dwExitCode);
// DWORD __stdcall GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// LPSTR __stdcall GetCommandLineA();
// void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
// BOOL __stdcall GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo);
// LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// void __stdcall GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo);
// HMODULE __stdcall GetModuleHandleW(LPCWSTR lpModuleName);
// HANDLE __stdcall CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName);
// int __stdcall CompareStringW(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2);
// int __stdcall LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
// int __stdcall GetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData);
// BOOL __stdcall IsValidLocale(LCID Locale, DWORD dwFlags);
// LCID __stdcall GetUserDefaultLCID();
// BOOL __stdcall EnumSystemLocalesW(LOCALE_ENUMPROCW lpLocaleEnumProc, DWORD dwFlags);
// DWORD __stdcall GetTimeZoneInformation(LPTIME_ZONE_INFORMATION lpTimeZoneInformation);
// void __stdcall ExitProcess(UINT uExitCode);
// BOOL __stdcall GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule);
// SIZE_T __stdcall HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
// BOOL __stdcall DeleteTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent);
// BOOL __stdcall GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask);
// DWORD_PTR __stdcall SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask);
// BOOL __stdcall SetThreadPriority(HANDLE hThread, int nPriority);
// BOOL __stdcall GetVersionExW(LPOSVERSIONINFOW lpVersionInformation);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// HANDLE __stdcall GetStdHandle(DWORD nStdHandle);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall IsValidCodePage(UINT CodePage);
// UINT __stdcall GetACP();
// UINT __stdcall GetOEMCP();
// HANDLE __stdcall GetProcessHeap();
// BOOL __stdcall UnregisterWait(HANDLE WaitHandle);
// DWORD __stdcall GetFileType(HANDLE hFile);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
// DWORD __stdcall GetCurrentProcessId();
// LPWCH __stdcall GetEnvironmentStringsW();
// BOOL __stdcall FreeEnvironmentStringsW(LPWCH);
// BOOL __stdcall WinHttpReadData(HINTERNET hRequest, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead);
// BOOL __stdcall WinHttpCrackUrl(LPCWSTR pwszUrl, DWORD dwUrlLength, DWORD dwFlags, LPURL_COMPONENTS lpUrlComponents);
// HINTERNET __stdcall WinHttpOpenRequest(HINTERNET hConnect, LPCWSTR pwszVerb, LPCWSTR pwszObjectName, LPCWSTR pwszVersion, LPCWSTR pwszReferrer, LPCWSTR *ppwszAcceptTypes, DWORD dwFlags);
// HINTERNET __stdcall WinHttpOpen(LPCWSTR pszAgentW, DWORD dwAccessType, LPCWSTR pszProxyW, LPCWSTR pszProxyBypassW, DWORD dwFlags);
// BOOL __stdcall WinHttpQueryDataAvailable(HINTERNET hRequest, LPDWORD lpdwNumberOfBytesAvailable);
// WINHTTP_STATUS_CALLBACK __stdcall WinHttpSetStatusCallback(HINTERNET hInternet, WINHTTP_STATUS_CALLBACK lpfnInternetCallback, DWORD dwNotificationFlags, DWORD_PTR dwReserved);
// BOOL __stdcall WinHttpQueryHeaders(HINTERNET hRequest, DWORD dwInfoLevel, LPCWSTR pwszName, LPVOID lpBuffer, LPDWORD lpdwBufferLength, LPDWORD lpdwIndex);
// BOOL __stdcall WinHttpCloseHandle(HINTERNET hInternet);
// BOOL __stdcall WinHttpSendRequest(HINTERNET hRequest, LPCWSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength, DWORD dwTotalLength, DWORD_PTR dwContext);
// BOOL __stdcall WinHttpGetIEProxyConfigForCurrentUser(WINHTTP_CURRENT_USER_IE_PROXY_CONFIG *pProxyConfig);
// BOOL __stdcall WinHttpReceiveResponse(HINTERNET hRequest, LPVOID lpReserved);


//----- (10001000) --------------------------------------------------------
char __userpurge S2_SetIndicators<al>(int a1<ebx>, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, int a10, int a11, __int64 a12, unsigned int a13)
{
  __int16 v13; // ax@3
  int v14; // esi@3
  signed __int64 v15; // ST30_8@5
  int v16; // ecx@5
  __int64 v18; // ST28_8@5
  __int64 v20; // ST18_8@5
  __int64 v22; // ST10_8@5
  __int64 v24; // ST08_8@5
  __int64 v26; // ST00_8@5
  int v27; // ST20_4@5
  int v28; // ST24_4@5
  char v30; // [sp+3Ch] [bp-3Ch]@1
  char v31; // [sp+70h] [bp-8h]@1
  unsigned int v32; // [sp+74h] [bp-4h]@1

  v32 = (unsigned int)&v30 ^ __security_cookie;
  sub_1002B6B7((int)&v31, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    LOBYTE(v13) = sub_1002B6E5(&v31);
  }
  else
  {
    v14 = *(_DWORD *)(dword_10077838 + 4 * a2);
    LOBYTE(v13) = sub_1002B6E5(&v31);
    if ( v14 )
    {
      v13 = *(_WORD *)(v14 + 56);
      if ( v13 == word_10076058 )
      {
        __asm
        {
          movsd   xmm0, [ebp+arg_44]
          movsd   xmm3, [ebp+arg_14]
          movsd   xmm2, [ebp+arg_C]
          movsd   xmm1, [ebp+arg_4]
        }
        v15 = 10000000i64 * a13;
        v16 = v14;
        __asm
        {
          movsd   [esp+78h+var_50], xmm0
          movsd   xmm0, [ebp+arg_34]
          movsd   [esp+78h+var_60], xmm0
          movsd   xmm0, [ebp+arg_2C]
          movsd   [esp+78h+var_68], xmm0
          movsd   xmm0, [ebp+arg_24]
          movsd   [esp+78h+var_70], xmm0
          movsd   xmm0, [ebp+arg_1C]
          movsd   [esp+78h+var_78], xmm0
        }
        LOBYTE(v13) = sub_10020D90(v16, v26, v24, v22, v20, v27, v28, v18, v15, SHIDWORD(v15));
      }
    }
  }
  return v13;
}
// 10074200: using guessed type int __security_cookie;
// 10076058: using guessed type __int16 word_10076058;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (100010F0) --------------------------------------------------------
bool __userpurge S2_OpenLong<eax>(int a1<ebx>, unsigned int a2, unsigned int a3)
{
  int v3; // esi@3
  signed __int64 v4; // qax@5
  int v5; // ecx@5
  char v7; // [sp+4h] [bp-Ch]@1
  char v8; // [sp+8h] [bp-8h]@1
  unsigned int v9; // [sp+Ch] [bp-4h]@1

  v9 = (unsigned int)&v7 ^ __security_cookie;
  sub_1002B6B7((int)&v8, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    sub_1002B6E5(&v8);
    return 0;
  }
  v3 = *(_DWORD *)(dword_10077838 + 4 * a2);
  sub_1002B6E5(&v8);
  if ( !v3 || *(_WORD *)(v3 + 56) != word_10076058 )
    return 0;
  v4 = 10000000i64 * a3;
  v5 = *(_DWORD *)(v3 + 8);
  return v5
      && *(_BYTE *)(v5 + 112) & 4
      && *(_DWORD *)(v3 + 348) == 2
      && *(_DWORD *)(v3 + 344) == 1
      && *(_DWORD *)(v3 + 352) == (_DWORD)v4
      && *(_DWORD *)(v3 + 356) == HIDWORD(v4);
}
// 10074200: using guessed type int __security_cookie;
// 10076058: using guessed type __int16 word_10076058;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (100011E0) --------------------------------------------------------
bool __userpurge S2_OpenShort<eax>(int a1<ebx>, unsigned int a2, unsigned int a3)
{
  int v3; // esi@3
  signed __int64 v4; // qax@5
  int v5; // ecx@5
  char v7; // [sp+4h] [bp-Ch]@1
  char v8; // [sp+8h] [bp-8h]@1
  unsigned int v9; // [sp+Ch] [bp-4h]@1

  v9 = (unsigned int)&v7 ^ __security_cookie;
  sub_1002B6B7((int)&v8, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    sub_1002B6E5(&v8);
    return 0;
  }
  v3 = *(_DWORD *)(dword_10077838 + 4 * a2);
  sub_1002B6E5(&v8);
  if ( !v3 || *(_WORD *)(v3 + 56) != word_10076058 )
    return 0;
  v4 = 10000000i64 * a3;
  v5 = *(_DWORD *)(v3 + 8);
  return v5
      && *(_BYTE *)(v5 + 112) & 4
      && *(_DWORD *)(v3 + 348) == 1
      && *(_DWORD *)(v3 + 344) == 2
      && *(_DWORD *)(v3 + 352) == (_DWORD)v4
      && *(_DWORD *)(v3 + 356) == HIDWORD(v4);
}
// 10074200: using guessed type int __security_cookie;
// 10076058: using guessed type __int16 word_10076058;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (100012D0) --------------------------------------------------------
signed int __userpurge S2_CloseLong<eax>(int a1<ebx>, unsigned int a2, __int64 a3)
{
  signed int result; // eax@7
  char v13; // [sp+4h] [bp-8h]@1
  unsigned int v14; // [sp+8h] [bp-4h]@1
  int v15; // [sp+Ch] [bp+0h]@1

  v14 = (unsigned int)&v15 ^ __security_cookie;
  sub_1002B6B7((int)&v13, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    sub_1002B6E5(&v13);
    return 0;
  }
  _ESI = *(_DWORD *)(dword_10077838 + 4 * a2);
  sub_1002B6E5(&v13);
  if ( !_ESI || *(_WORD *)(_ESI + 56) != word_10076058 )
    return 0;
  __asm
  {
    movsd   xmm0, qword ptr [esi+138h]
    mulsd   xmm0, qword ptr [esi+88h]
    movsd   xmm1, qword ptr [esi+148h]
    subsd   xmm1, qword ptr [esi+150h]
    mulsd   xmm0, qword ptr [esi+80h]
    mulsd   xmm0, ds:qword_10069498
    comisd  xmm1, xmm0
  }
  if ( _CF )
    goto LABEL_13;
  __asm
  {
    movsd   xmm0, [ebp+arg_4]
    comisd  xmm0, ds:qword_10069470
  }
  if ( _CF | _ZF )
LABEL_13:
    result = 0;
  else
    result = 1;
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10076058: using guessed type __int16 word_10076058;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (100013C0) --------------------------------------------------------
signed int __userpurge S2_CloseShort<eax>(int a1<ebx>, unsigned int a2, __int64 a3)
{
  signed int result; // eax@7
  char v13; // [sp+4h] [bp-8h]@1
  unsigned int v14; // [sp+8h] [bp-4h]@1
  int v15; // [sp+Ch] [bp+0h]@1

  v14 = (unsigned int)&v15 ^ __security_cookie;
  sub_1002B6B7((int)&v13, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    sub_1002B6E5(&v13);
    return 0;
  }
  _ESI = *(_DWORD *)(dword_10077838 + 4 * a2);
  sub_1002B6E5(&v13);
  if ( !_ESI || *(_WORD *)(_ESI + 56) != word_10076058 )
    return 0;
  __asm
  {
    movsd   xmm0, qword ptr [esi+138h]
    mulsd   xmm0, qword ptr [esi+88h]
    movsd   xmm1, qword ptr [esi+150h]
    subsd   xmm1, qword ptr [esi+148h]
    mulsd   xmm0, qword ptr [esi+80h]
    mulsd   xmm0, ds:qword_10069498
    comisd  xmm1, xmm0
  }
  if ( _CF )
    goto LABEL_13;
  __asm
  {
    movsd   xmm0, [ebp+arg_4]
    comisd  xmm0, ds:qword_10069470
  }
  if ( _CF | _ZF )
LABEL_13:
    result = 0;
  else
    result = 1;
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10076058: using guessed type __int16 word_10076058;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (100014B0) --------------------------------------------------------
char __userpurge S3_SetIndicators<al>(int a1<ebx>, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9)
{
  __int16 v9; // ax@3
  char v12; // [sp+4h] [bp-Ch]@1
  char v13; // [sp+8h] [bp-8h]@1
  unsigned int v14; // [sp+Ch] [bp-4h]@1

  v14 = (unsigned int)&v12 ^ __security_cookie;
  sub_1002B6B7((int)&v13, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    LOBYTE(v9) = sub_1002B6E5(&v13);
  }
  else
  {
    _ESI = *(_DWORD *)(dword_10077838 + 4 * a2);
    LOBYTE(v9) = sub_1002B6E5(&v13);
    if ( _ESI )
    {
      v9 = *(_WORD *)(_ESI + 56);
      if ( v9 == word_1007605C )
      {
        __asm
        {
          movsd   xmm0, [ebp+arg_4]
          movsd   qword ptr [esi+148h], xmm0
          movsd   xmm0, [ebp+arg_C]
          movsd   qword ptr [esi+150h], xmm0
          movsd   xmm0, [ebp+arg_14]
          movsd   qword ptr [esi+158h], xmm0
          movsd   xmm0, [ebp+arg_1C]
          movsd   qword ptr [esi+160h], xmm0
          movsd   xmm0, [ebp+arg_24]
          movsd   qword ptr [esi+168h], xmm0
          movsd   xmm0, [ebp+arg_2C]
          movsd   qword ptr [esi+170h], xmm0
          movsd   xmm0, [ebp+arg_34]
          movsd   qword ptr [esi+178h], xmm0
        }
      }
    }
  }
  return v9;
}
// 10074200: using guessed type int __security_cookie;
// 1007605C: using guessed type __int16 word_1007605C;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (100015A0) --------------------------------------------------------
char __userpurge S3_OpenLong<al>(int a1<ebx>, unsigned int a2)
{
  int v2; // esi@3
  int v3; // eax@5
  char v5; // [sp+4h] [bp-8h]@1
  unsigned int v6; // [sp+8h] [bp-4h]@1
  int v7; // [sp+Ch] [bp+0h]@1

  v6 = (unsigned int)&v7 ^ __security_cookie;
  sub_1002B6B7((int)&v5, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    sub_1002B6E5(&v5);
LABEL_7:
    LOBYTE(v3) = 0;
    return v3;
  }
  v2 = *(_DWORD *)(dword_10077838 + 4 * a2);
  sub_1002B6E5(&v5);
  if ( !v2 || *(_WORD *)(v2 + 56) != word_1007605C )
    goto LABEL_7;
  return sub_100212A0(v2);
}
// 10074200: using guessed type int __security_cookie;
// 1007605C: using guessed type __int16 word_1007605C;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (10001630) --------------------------------------------------------
char __userpurge S3_OpenShort<al>(int a1<ebx>, unsigned int a2)
{
  int v2; // esi@3
  int v3; // eax@5
  char v5; // [sp+4h] [bp-8h]@1
  unsigned int v6; // [sp+8h] [bp-4h]@1
  int v7; // [sp+Ch] [bp+0h]@1

  v6 = (unsigned int)&v7 ^ __security_cookie;
  sub_1002B6B7((int)&v5, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    sub_1002B6E5(&v5);
LABEL_7:
    LOBYTE(v3) = 0;
    return v3;
  }
  v2 = *(_DWORD *)(dword_10077838 + 4 * a2);
  sub_1002B6E5(&v5);
  if ( !v2 || *(_WORD *)(v2 + 56) != word_1007605C )
    goto LABEL_7;
  return sub_10021330(v2);
}
// 10074200: using guessed type int __security_cookie;
// 1007605C: using guessed type __int16 word_1007605C;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (100016C0) --------------------------------------------------------
int __thiscall sub_100016C0(int this, int a2)
{
  int v2; // ebx@1
  int v3; // edi@1
  int v4; // esi@1

  v2 = this;
  *(_DWORD *)this = *(_DWORD *)a2;
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(this + 12) = *(_DWORD *)(a2 + 12);
  v3 = this + 20;
  *(_DWORD *)(this + 16) = *(_DWORD *)(a2 + 16);
  v4 = a2 + 20;
  *(_DWORD *)(this + 40) = 15;
  *(_DWORD *)(this + 36) = 0;
  *(_BYTE *)(this + 20) = 0;
  if ( *(_DWORD *)(a2 + 40) >= 0x10u )
  {
    *(_DWORD *)v3 = *(_DWORD *)v4;
    *(_DWORD *)v4 = 0;
  }
  else
  {
    if ( *(_DWORD *)(a2 + 36) != -1 )
      sub_1002A4B0((void *)(this + 20), (const void *)(a2 + 20), *(_DWORD *)(a2 + 36) + 1);
  }
  *(_DWORD *)(v3 + 16) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(v3 + 20) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a2 + 40) = 15;
  *(_DWORD *)(a2 + 36) = 0;
  *(_BYTE *)v4 = 0;
  return v2;
}

//----- (10001750) --------------------------------------------------------
char __cdecl sub_10001750(int a1, int a2)
{
  return *(_QWORD *)a1 < *(_QWORD *)a2;
}

//----- (10001780) --------------------------------------------------------
bool __fastcall sub_10001780(int a1, int a2)
{
  int v2; // eax@1

  v2 = *(_DWORD *)(a2 + 4);
  return v2 > *(_DWORD *)(a1 + 4) || v2 >= *(_DWORD *)(a1 + 4) && *(_DWORD *)a2 >= *(_DWORD *)a1;
}

//----- (100017B0) --------------------------------------------------------
int __thiscall sub_100017B0(void *this, int a2)
{
  void *v2; // edi@1
  int result; // eax@7

  v2 = this;
  if ( *(_DWORD *)(a2 + 20) >= 0x10u )
  {
    if ( this )
      *(_DWORD *)this = *(_DWORD *)a2;
    *(_DWORD *)a2 = 0;
  }
  else
  {
    if ( *(_DWORD *)(a2 + 16) != -1 )
      sub_1002A4B0(this, (const void *)a2, *(_DWORD *)(a2 + 16) + 1);
  }
  *((_DWORD *)v2 + 4) = *(_DWORD *)(a2 + 16);
  result = *(_DWORD *)(a2 + 20);
  *((_DWORD *)v2 + 5) = result;
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  return result;
}

//----- (10001810) --------------------------------------------------------
int __thiscall sub_10001810(int this, int a2)
{
  int v2; // edi@1
  int result; // eax@5

  v2 = this;
  *(_DWORD *)(this + 20) = 15;
  *(_DWORD *)(this + 16) = 0;
  *(_BYTE *)this = 0;
  if ( *(_DWORD *)(a2 + 20) >= 0x10u )
  {
    *(_DWORD *)this = *(_DWORD *)a2;
    *(_DWORD *)a2 = 0;
  }
  else
  {
    if ( *(_DWORD *)(a2 + 16) != -1 )
      sub_1002A4B0((void *)this, (const void *)a2, *(_DWORD *)(a2 + 16) + 1);
  }
  *(_DWORD *)(v2 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(v2 + 20) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  result = v2;
  *(_BYTE *)a2 = 0;
  return result;
}

//----- (10001880) --------------------------------------------------------
int __thiscall sub_10001880(int this)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = this;
  if ( *(_DWORD *)(this + 20) >= 0x10u )
    result = sub_1002A4AA(*(LPVOID *)this);
  *(_DWORD *)(v1 + 20) = 15;
  *(_DWORD *)(v1 + 16) = 0;
  *(_BYTE *)v1 = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100018D0) --------------------------------------------------------
void *__thiscall sub_100018D0(void *this)
{
  return this;
}

//----- (100018E0) --------------------------------------------------------
int __thiscall sub_100018E0(int this, int a2)
{
  char v2; // cf@1
  int result; // eax@2

  v2 = *(_DWORD *)(this + 20) < 0x10u;
  *(_DWORD *)(this + 16) = a2;
  if ( v2 )
  {
    *(_BYTE *)(this + a2) = 0;
  }
  else
  {
    result = *(_DWORD *)this;
    *(_BYTE *)(*(_DWORD *)this + a2) = 0;
  }
  return result;
}

//----- (10001910) --------------------------------------------------------
void *__userpurge sub_10001910<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_1002AF18(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10001950) --------------------------------------------------------
int __userpurge sub_10001950<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int *a4)
{
  int v4; // edi@1
  int v5; // ecx@3
  int v6; // edx@5
  int v7; // edx@6
  int v8; // esi@7
  char v10; // [sp-10h] [bp-CCh]@6
  int v11; // [sp-Ch] [bp-C8h]@6
  int v12; // [sp-8h] [bp-C4h]@6
  int v13; // [sp-4h] [bp-C0h]@6
  int (__stdcall **v14)(char); // [sp+Ch] [bp-B0h]@1
  int v15; // [sp+18h] [bp-A4h]@7
  int v16; // [sp+20h] [bp-9Ch]@7
  char v17; // [sp+24h] [bp-98h]@5
  int v18; // [sp+2Ch] [bp-90h]@1
  int v19; // [sp+30h] [bp-8Ch]@1
  char v20; // [sp+34h] [bp-88h]@1
  int v21; // [sp+38h] [bp-84h]@1
  int v22; // [sp+4Ch] [bp-70h]@1
  int v23; // [sp+5Ch] [bp-60h]@1
  int v24; // [sp+6Ch] [bp-50h]@5
  unsigned int v25; // [sp+70h] [bp-4Ch]@3
  int v26; // [sp+74h] [bp-48h]@1
  int v27; // [sp+78h] [bp-44h]@1
  int v28; // [sp+7Ch] [bp-40h]@1
  int v29; // [sp+80h] [bp-3Ch]@1
  int v30; // [sp+84h] [bp-38h]@1
  unsigned int v31; // [sp+A8h] [bp-14h]@1
  int v32; // [sp+B8h] [bp-4h]@1

  v31 = (unsigned int)&v14 ^ __security_cookie;
  v4 = a2;
  v21 = 0;
  v22 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  sub_1000DDF0(a1, (int)&v20, a3, a2);
  v32 = 0;
  v18 &= 0xFFFFFE00u;
  v19 = 0;
  LOBYTE(v32) = 2;
  if ( &v23 != a4 )
    loc_1000AB40(&v23, a4, 0, -1);
  v5 = (int)&v23;
  if ( v25 >= 0x10 )
    v5 = v23;
  if ( sub_1000DF00((int)&v20, v5, v5 + v24, (int)&v17, v5) )
  {
    sub_10010010((int)&v14, v6, (int)&v17);
    LOBYTE(v32) = 3;
    sub_10010010((int)&v10, v7, (int)&v14);
    sub_10002F80(v4 + 84, a3, v10, v11, v12, v13);
    LOBYTE(v32) = 2;
    sub_100101D0((int)&v14, a3);
  }
  else
  {
    v8 = *(_DWORD *)(v4 + 80);
    v16 = (int)"Json parsing failed";
    sub_1002AEA4((int)&v14, &v16);
    v14 = &off_100683AC;
    v15 = v8;
    LOBYTE(v32) = 4;
    sub_100035E0(v4, (int)&v14);
    sub_1002AF18((int)&v14, a3);
  }
  LOBYTE(v32) = 0;
  sub_100101D0((int)&v17, a3);
  return sub_10001B00((int)&v20);
}
// 100683AC: using guessed type int (__stdcall *off_100683AC)(char);
// 10074200: using guessed type int __security_cookie;

//----- (10001B00) --------------------------------------------------------
int __thiscall sub_10001B00(int this)
{
  int v1; // edi@1
  int result; // eax@5

  v1 = this;
  if ( *(_DWORD *)(this + 104) >= 0x10u )
    sub_1002A4AA(*(LPVOID *)(this + 84));
  *(_DWORD *)(v1 + 104) = 15;
  *(_DWORD *)(v1 + 100) = 0;
  *(_BYTE *)(v1 + 84) = 0;
  if ( *(_DWORD *)(v1 + 60) >= 0x10u )
    sub_1002A4AA(*(LPVOID *)(v1 + 40));
  *(_DWORD *)(v1 + 60) = 15;
  *(_DWORD *)(v1 + 56) = 0;
  *(_BYTE *)(v1 + 40) = 0;
  sub_10002D80(v1 + 20);
  sub_1002A4AA(*(LPVOID *)(v1 + 20));
  *(_DWORD *)(v1 + 20) = 0;
  sub_10002D20(v1);
  result = sub_1002A4AA(*(LPVOID *)v1);
  *(_DWORD *)v1 = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10001BD0) --------------------------------------------------------
int __userpurge sub_10001BD0<eax>(int a1<ecx>, int a2<edi>, void *a3, int a4, int a5, int a6, int a7, unsigned int a8, __int64 a9, __int64 a10)
{
  int v10; // ebx@1
  int v11; // esi@1
  int v12; // ecx@1
  int v13; // edx@1
  int v14; // eax@1
  unsigned int v16; // eax@4
  int v17; // ecx@4
  int v18; // ebx@7
  signed int v19; // ecx@8
  signed int v20; // edx@8
  signed int v21; // ecx@14
  int v22; // esi@14
  signed int v23; // edx@14
  int v24; // ecx@20
  int v25; // eax@20
  int v26; // eax@21
  int v27; // eax@23
  int v28; // esi@25
  char v43; // [sp-30h] [bp-80h]@1
  int v44; // [sp-2Ch] [bp-7Ch]@1
  int v45; // [sp-28h] [bp-78h]@1
  int v46; // [sp-24h] [bp-74h]@1
  void *v47; // [sp-18h] [bp-68h]@1
  int v48; // [sp-14h] [bp-64h]@1
  int v49; // [sp-10h] [bp-60h]@1
  int v50; // [sp-Ch] [bp-5Ch]@1
  int v51; // [sp-8h] [bp-58h]@1
  signed int v52; // [sp-4h] [bp-54h]@1
  void *v53; // [sp+10h] [bp-40h]@1
  int v54; // [sp+20h] [bp-30h]@1
  unsigned int v55; // [sp+24h] [bp-2Ch]@1
  char v56; // [sp+2Ch] [bp-24h]@23
  int v57; // [sp+30h] [bp-20h]@4
  int v58; // [sp+34h] [bp-1Ch]@7
  int v59; // [sp+38h] [bp-18h]@1
  int v60; // [sp+3Ch] [bp-14h]@1
  int v61; // [sp+40h] [bp-10h]@1
  int v62; // [sp+4Ch] [bp-4h]@1

  v11 = a1;
  v61 = a1;
  v59 = a1;
  v52 = -1;
  v62 = 0;
  v51 = 0;
  *(_DWORD *)(a1 + 20) = 15;
  *(_DWORD *)(a1 + 16) = 0;
  v50 = (int)&a3;
  *(_BYTE *)a1 = 0;
  loc_1000AB40(v50, v51, v52);
  *(_QWORD *)(v11 + 24) = a9;
  *(_QWORD *)(v11 + 32) = a10;
  v60 = v11 + 40;
  *(_DWORD *)(v11 + 40) = 0;
  *(_DWORD *)(v11 + 44) = 0;
  *(_DWORD *)(v11 + 48) = 0;
  *(_DWORD *)(v11 + 52) = 0;
  v49 = v12;
  *(_DWORD *)(v11 + 56) = 0;
  *(_DWORD *)(v11 + 60) = 0;
  sub_10006BC0(v13, v11 + 56, a2, v49);
  v49 = -1;
  LOBYTE(v62) = 3;
  v48 = 0;
  v47 = &a3;
  v55 = 15;
  v54 = 0;
  LOBYTE(v53) = 0;
  loc_1000AB40(&v53);
  LOBYTE(v62) = 4;
  v43 = 0;
  loc_1000AB40(&v53, 0, -1, *(_DWORD *)&v43, v44, v45, v46, 0, 15);
  v14 = sub_10003CB0((int)&byte_10077710, (int)&unk_10077750, v47, v48, v49, v50, v51, v52);
  LOBYTE(v62) = 3;
  v10 = v14;
  if ( v55 >= 0x10 )
    sub_1002A4AA(v53);
  _EDI = -1;
  v55 = 15;
  v54 = 0;
  LOBYTE(v53) = 0;
  if ( (_UNKNOWN *)v10 != &unk_10077750 )
  {
    v17 = *(_DWORD *)(v10 + 28);
    v16 = *(_DWORD *)(v17 - 40);
    v57 = *(_DWORD *)(v10 + 28);
    if ( HIDWORD(a9) <= *(_DWORD *)(v17 - 36) )
    {
      if ( HIDWORD(a9) < *(_DWORD *)(v17 - 36) || (_DWORD)a9 < v16 )
      {
        v18 = *(_DWORD *)(v10 + 24);
        v58 = v18;
        if ( a10 >= *(_QWORD *)v18 )
        {
          v20 = (signed int)((unsigned __int64)(715827883i64 * (v17 - v18)) >> 32) >> 3;
          v19 = v20 + ((unsigned int)v20 >> 31);
          if ( v19 > 0 )
          {
            do
            {
              if ( *(_QWORD *)(v18 + 48 * v19 / 2 + 8) >= a9 )
              {
                v19 /= 2;
              }
              else
              {
                v18 += 48 * v19 / 2 + 48;
                v19 += -1 - v19 / 2;
              }
            }
            while ( v19 > 0 );
            v58 = v18;
          }
          v23 = (signed int)((unsigned __int64)(715827883i64 * (v57 - v18)) >> 32) >> 3;
          v21 = v23 + ((unsigned int)v23 >> 31);
          v22 = v18;
          if ( v21 > 0 )
          {
            do
            {
              if ( *(_QWORD *)(v22 + 48 * v21 / 2 + 8) >= a10 )
              {
                v21 /= 2;
              }
              else
              {
                v22 += 48 * v21 / 2 + 48;
                v21 += -1 - v21 / 2;
              }
            }
            while ( v21 > 0 );
            v18 = v58;
          }
          v52 = v59;
          v51 = v21;
          sub_10004310(*(_DWORD *)v60, *(_DWORD *)(v60 + 4));
          v24 = v60;
          v25 = *(_DWORD *)v60;
          v52 = v59;
          *(_DWORD *)(v60 + 4) = v25;
          sub_10004EF0(v24, v25, v18, v22, v52);
          v11 = v61;
        }
      }
    }
  }
  v26 = *(_DWORD *)(v11 + 52);
  if ( !v26 || v26 == 3 )
  {
    v27 = sub_10002130(v11, (int)&v56);
    if ( v11 + 56 != v27 )
      sub_1000A010((void *)(v11 + 56), v27);
    v28 = v57;
    if ( v57 )
    {
      _EAX = v57 + 4;
      _ECX = -1;
      __asm { lock xadd [eax], ecx }
      if ( _ZF )
      {
        (**(void (__thiscall ***)(_DWORD))v28)(v28);
        _EAX = v28 + 8;
        __asm { lock xadd [eax], edi }
        if ( _EDI == 1 )
          (*(void (__thiscall **)(int))(*(_DWORD *)v28 + 4))(v28);
      }
    }
    v11 = v61;
  }
  if ( a8 >= 0x10 )
    sub_1002A4AA(a3);
  return v11;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10077710: using guessed type char byte_10077710;

//----- (10001EA0) --------------------------------------------------------
signed int __usercall sub_10001EA0<eax>(int a1<ecx>, int a2<ebx>)
{
  signed int result; // eax@1
  int v3; // esi@1
  int v4; // ecx@2
  int v5; // edi@5
  int v18; // ecx@9
  char v19; // [sp+14h] [bp-1Ch]@3
  int v20; // [sp+20h] [bp-10h]@1
  int v21; // [sp+24h] [bp-Ch]@1
  int v22; // [sp+2Ch] [bp-4h]@1

  result = (signed int)&v21;
  v3 = a1;
  v20 = a1;
  v22 = 2;
  if ( *(_DWORD *)(a1 + 52) == 1 )
  {
    v4 = *(_DWORD *)(a1 + 56);
    if ( !v4 )
    {
      sub_1002FFB9((int)&v19, (unsigned int)"wait() cannot be called on a default constructed task.");
      sub_100355DB((int)&v19, (int)&unk_1006D8B8);
    }
    result = sub_10009F10(v4, a2);
  }
  LOBYTE(v22) = 1;
  v5 = *(_DWORD *)(v3 + 60);
  if ( v5 )
  {
    _EBX = -1;
    _ECX = v5 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      result = v5 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
    }
  }
  v18 = *(_DWORD *)(v3 + 40);
  if ( v18 )
  {
    sub_10004310(v18, *(_DWORD *)(v3 + 44));
    result = sub_1002A4AA(*(LPVOID *)(v3 + 40));
    *(_DWORD *)(v3 + 40) = 0;
    *(_DWORD *)(v3 + 44) = 0;
    *(_DWORD *)(v3 + 48) = 0;
  }
  if ( *(_DWORD *)(v3 + 20) >= 0x10u )
    result = sub_1002A4AA(*(LPVOID *)v3);
  *(_DWORD *)(v3 + 20) = 15;
  *(_DWORD *)(v3 + 16) = 0;
  *(_BYTE *)v3 = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10001FA0) --------------------------------------------------------
char __thiscall sub_10001FA0(int this, void *a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, __int64 a8, __int64 a9)
{
  unsigned int v9; // edi@1
  int v10; // esi@1
  int v11; // edx@2
  int v12; // ecx@4
  unsigned int v13; // ebx@4
  unsigned int v14; // eax@6
  int v15; // eax@8
  int v16; // eax@11
  int v17; // eax@14
  char v18; // bl@17

  v10 = this;
  v9 = *(_DWORD *)(this + 16);
  if ( *(_DWORD *)(this + 20) < 0x10u )
    v11 = this;
  else
    v11 = *(_DWORD *)this;
  v13 = a6;
  v12 = (int)&a2;
  if ( a7 >= 0x10 )
    v12 = (int)a2;
  v14 = v9;
  if ( a6 < v9 )
    v14 = a6;
  v15 = sub_100099E0(v12, v11, v14);
  v18 = !v15
     && v13 >= v9
     && (LOBYTE(v15) = v13 != v9, !v15)
     && (v16 = (unsigned __int64)(a8 + qword_10075E70) >> 32, v16 >= *(_DWORD *)(v10 + 28))
     && (v16 > *(_DWORD *)(v10 + 28) || (unsigned int)(a8 + (_DWORD)qword_10075E70) >= *(_DWORD *)(v10 + 24))
     && (v17 = (unsigned __int64)(a9 - qword_10075E70) >> 32, *(_DWORD *)(v10 + 36) >= v17)
     && (*(_DWORD *)(v10 + 36) > v17 || *(_DWORD *)(v10 + 32) >= (unsigned int)(a9 - (_DWORD)qword_10075E70));
  if ( a7 >= 0x10 )
    sub_1002A4AA(a2);
  return v18;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10075E70: using guessed type __int64 qword_10075E70;

//----- (10002040) --------------------------------------------------------
char __thiscall sub_10002040(int this, int a2, __int64 a3)
{
  int v3; // esi@2
  int v4; // ebx@3
  signed int v5; // ecx@6
  signed int v6; // edx@6
  int v7; // eax@7
  char result; // al@12

  if ( *(_DWORD *)(this + 52) != 2 )
    goto LABEL_16;
  v3 = *(_DWORD *)(this + 40);
  if ( v3 == *(_DWORD *)(this + 44) )
    goto LABEL_16;
  v4 = *(_DWORD *)(this + 44);
  if ( *(_DWORD *)(v4 - 36) < HIDWORD(a3) )
    goto LABEL_16;
  if ( *(_DWORD *)(v4 - 36) <= HIDWORD(a3) && *(_DWORD *)(v4 - 40) < (_DWORD)a3 )
    goto LABEL_16;
  v6 = (signed int)((unsigned __int64)(715827883i64 * (v4 - v3)) >> 32) >> 3;
  v5 = v6 + ((unsigned int)v6 >> 31);
  while ( v5 > 0 )
  {
    v7 = v3 + 48 * v5 / 2;
    if ( *(_QWORD *)(v7 + 8) >= a3 )
    {
      v5 /= 2;
    }
    else
    {
      v3 = v7 + 48;
      v5 += -1 - v5 / 2;
    }
  }
  if ( v3 == v4 )
  {
LABEL_16:
    result = 0;
  }
  else
  {
    sub_100020F0(a2, v3);
    result = 1;
  }
  return result;
}

//----- (100020F0) --------------------------------------------------------
int __thiscall sub_100020F0(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = *(_DWORD *)a2;
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(this + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(this + 16) = *(_DWORD *)(a2 + 16);
  if ( this + 20 != a2 + 20 )
    loc_1000AB40(a2 + 20, 0, -1);
  return v2;
}

//----- (10002130) --------------------------------------------------------
int __thiscall sub_10002130(int this, int a2)
{
  int v2; // esi@1
  char v3; // cf@1
  int v4; // esi@3
  int v5; // eax@3
  int v6; // edx@3
  int v7; // edx@3
  int v8; // edx@3
  int v9; // eax@3
  int v10; // edx@3
  int v11; // edx@3
  int v12; // eax@3
  int v13; // edx@3
  int v14; // eax@3
  int v15; // edx@3
  int v16; // edx@3
  int v17; // edx@3
  int v18; // edx@3
  __int16 v34; // [sp-1Ch] [bp-74h]@3
  int v35; // [sp-18h] [bp-70h]@3
  int v36; // [sp-14h] [bp-6Ch]@3
  char v37; // [sp-10h] [bp-68h]@3
  int v38; // [sp-Ch] [bp-64h]@3
  signed int v39; // [sp-8h] [bp-60h]@3
  unsigned int v40; // [sp-4h] [bp-5Ch]@1
  int v41; // [sp+0h] [bp-58h]@3
  int v42; // [sp+4h] [bp-54h]@3
  int v43; // [sp+8h] [bp-50h]@3
  int v44; // [sp+Ch] [bp-4Ch]@1
  int v45; // [sp+14h] [bp-44h]@1
  unsigned int *v46; // [sp+18h] [bp-40h]@3
  char v47; // [sp+1Ch] [bp-3Ch]@3
  int v48; // [sp+24h] [bp-34h]@1
  int v49; // [sp+28h] [bp-30h]@1
  int v50; // [sp+2Ch] [bp-2Ch]@3
  int v51; // [sp+30h] [bp-28h]@3
  int v52; // [sp+34h] [bp-24h]@3
  int v53; // [sp+38h] [bp-20h]@3
  int v54; // [sp+3Ch] [bp-1Ch]@1
  int v55; // [sp+40h] [bp-18h]@1
  unsigned int v56; // [sp+44h] [bp-14h]@1
  int v57; // [sp+54h] [bp-4h]@1
  int v58; // [sp+58h] [bp+0h]@1

  v56 = (unsigned int)&v58 ^ __security_cookie;
  v40 = (unsigned int)&v58 ^ __security_cookie;
  v2 = this;
  v45 = 0;
  v48 &= 0xFFFFFE00u;
  v44 = a2;
  *(_DWORD *)(this + 52) = 1;
  v49 = 0;
  v57 = 2;
  v3 = *(_DWORD *)(this + 20) < 0x10u;
  v54 = v54 & 0xFFFFFF04 | 0x104;
  v55 = 0;
  if ( !v3 )
    this = *(_DWORD *)this;
  v52 = loc_1000FED0(this, *(_DWORD *)(v2 + 16), v40, v41, v42, v43);
  LOBYTE(v57) = 3;
  v5 = sub_10010C90((int)&v47, v6, (int)"symbol", v41);
  sub_10010260(v5, v7, (int)&v52);
  LOBYTE(v57) = 2;
  sub_100101D0((int)&v52, a2);
  *(_QWORD *)&v40 = *(_QWORD *)(v2 + 24) + 5000000i64;
  v54 = v54 & 0xFFFFFF01 | 1;
  v55 = 0;
  v52 = sub_1003AC50(*(unsigned __int64 *)&v40, 0x989680u, 0);
  v53 = v8;
  LOBYTE(v57) = 4;
  v9 = sub_10010C90((int)&v47, v8, (int)"start", v41);
  sub_10010260(v9, v10, (int)&v52);
  LOBYTE(v57) = 2;
  sub_100101D0((int)&v52, a2);
  *(_QWORD *)&v40 = *(_QWORD *)(v2 + 32) + 5000000i64;
  v54 = v54 & 0xFFFFFF01 | 1;
  v55 = 0;
  v52 = sub_1003AC50(*(unsigned __int64 *)&v40, 0x989680u, 0);
  v53 = v11;
  LOBYTE(v57) = 5;
  v12 = sub_10010C90((int)&v47, v11, (int)"end", v41);
  sub_10010260(v12, v13, (int)&v52);
  LOBYTE(v57) = 2;
  sub_100101D0((int)&v52, a2);
  v54 &= 0xFFFFFE00u;
  v55 = 0;
  LOBYTE(v57) = 7;
  v14 = sub_10010C90((int)&v52, v15, (int)"data", v41);
  sub_10010260(v14, v16, (int)&v47);
  v46 = &v40;
  v50 = 0;
  v51 = 0;
  sub_10010010((int)&v40, v17, (int)&v52);
  LOBYTE(v57) = 8;
  v39 = 7;
  v38 = 0;
  v34 = 0;
  loc_10009CC0();
  LOBYTE(v57) = 7;
  sub_100036F0(&dword_10076148, 0, -1, *(_DWORD *)&v34, v35, v36, v37);
  LOBYTE(v57) = 9;
  v46 = (unsigned int *)v2;
  sub_10003960(v18, (int)&v50, a2, a2, (int)&v46);
  LOBYTE(v57) = 7;
  v4 = v51;
  v45 = 1;
  if ( v51 )
  {
    _EDI = -1;
    _ECX = v51 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v4)(v4);
      _EAX = v4 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 4))(v4);
    }
  }
  LOBYTE(v57) = 2;
  sub_100101D0((int)&v52, a2);
  LOBYTE(v57) = 0;
  sub_100101D0((int)&v47, a2);
  return a2;
}
// 100036F0: using guessed type _DWORD __cdecl sub_100036F0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);
// 10074200: using guessed type int __security_cookie;
// 10076148: using guessed type int dword_10076148;

//----- (100023C0) --------------------------------------------------------
int __thiscall sub_100023C0(int this, char a2, int a3)
{
  int v3; // eax@1
  int v4; // edx@1
  int v5; // ecx@1
  int v6; // edi@1
  int v7; // esi@7
  int v8; // ebx@9
  int v9; // eax@12
  __int64 v10; // qax@17
  int v11; // ecx@17
  int v12; // ebx@17
  int v13; // eax@17
  int v14; // eax@17
  __int64 v15; // ST08_8@17
  __int64 v16; // qax@17
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  __int64 v20; // qax@17
  LPVOID v21; // edi@19
  void *v22; // edi@25
  void *v23; // edi@28
  void *v24; // edi@34
  int v25; // edi@35
  int v26; // eax@35
  int v27; // eax@49
  int j; // eax@50
  int i; // eax@53
  int v30; // ebx@57
  int v31; // esi@57
  signed int v32; // edx@57
  signed int v33; // ebx@57
  int v34; // ebx@61
  int v35; // esi@61
  int v36; // esi@63
  void *v37; // esi@70
  int result; // eax@75
  void *v39; // esi@76
  int v40; // esi@77
  char v53; // [sp-4h] [bp-C8h]@1
  void *v54; // [sp+Ch] [bp-B8h]@35
  unsigned int v55; // [sp+20h] [bp-A4h]@43
  LPVOID lpMem; // [sp+24h] [bp-A0h]@17
  int v57; // [sp+2Ch] [bp-98h]@17
  int v58; // [sp+30h] [bp-94h]@24
  char v59; // [sp+38h] [bp-8Ch]@29
  void *v60; // [sp+3Ch] [bp-88h]@17
  int v61; // [sp+40h] [bp-84h]@17
  int v62; // [sp+44h] [bp-80h]@9
  int v63; // [sp+48h] [bp-7Ch]@17
  void *v64; // [sp+4Ch] [bp-78h]@1
  int v65; // [sp+54h] [bp-70h]@5
  int v66; // [sp+58h] [bp-6Ch]@1
  int v67; // [sp+60h] [bp-64h]@20
  int v68; // [sp+64h] [bp-60h]@1
  int v69; // [sp+68h] [bp-5Ch]@1
  int v70; // [sp+6Ch] [bp-58h]@1
  int v71; // [sp+70h] [bp-54h]@1
  int v72; // [sp+74h] [bp-50h]@1
  char v73; // [sp+7Bh] [bp-49h]@9
  __int64 v74; // [sp+7Ch] [bp-48h]@17
  __int64 v75; // [sp+84h] [bp-40h]@17
  int v76; // [sp+8Ch] [bp-38h]@17
  void *v77; // [sp+90h] [bp-34h]@17
  int v78; // [sp+A0h] [bp-24h]@17
  unsigned int v79; // [sp+A4h] [bp-20h]@17
  unsigned int v80; // [sp+B0h] [bp-14h]@1
  char *v81; // [sp+B4h] [bp-10h]@1
  int v82; // [sp+C0h] [bp-4h]@1
  int v83; // [sp+C4h] [bp+0h]@1

  v80 = (unsigned int)&v83 ^ __security_cookie;
  v81 = &v53;
  v68 = this;
  v72 = this;
  v82 = 0;
  LOBYTE(v82) = 1;
  v66 = 0;
  loc_10002BC0(&a2, &v64, (unsigned int)&v83 ^ __security_cookie);
  v6 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  LOBYTE(v82) = 3;
  v3 = sub_10010A20(&v64);
  if ( v3 )
  {
    if ( (unsigned int)v3 > 0x5555555 )
      sub_10029585((int)"vector<T> too long");
    loc_10002E20(&v69, v3);
    v6 = v69;
  }
  if ( (unsigned int)((char)v65 - 6) <= 1 && v64 )
  {
    LOBYTE(v4) = 0;
    v7 = **(_DWORD **)v64;
  }
  else
  {
    v7 = 0;
    LOBYTE(v4) = 1;
  }
  v8 = v62;
  v73 = v4;
  while ( 1 )
  {
    if ( (unsigned int)((char)v65 - 6) <= 1 && v64 )
    {
      v9 = *(_DWORD *)v64;
      LOBYTE(v5) = 0;
    }
    else
    {
      v9 = 0;
      LOBYTE(v5) = 1;
    }
    if ( !(_BYTE)v4 )
      LOBYTE(v5) = v7 == v9;
    if ( (_BYTE)v5 )
      break;
    __asm
    {
      xorps   xmm0, xmm0
      movlpd  [ebp+var_48], xmm0
      movlpd  [ebp+var_40], xmm0
    }
    v79 = 15;
    v78 = 0;
    LOBYTE(v77) = v5;
    LOBYTE(v82) = 4;
    v13 = sub_10010C90(v7 + 24, v4, (int)"start", v5);
    v14 = loc_10010400(v13);
    *(_DWORD *)&v53 = 0;
    LODWORD(v15) = 10000000;
    v16 = sub_10039A40((unsigned int)v14, v15);
    v74 = v16;
    v17 = sub_10010C90(v7 + 24, SHIDWORD(v16), (int)"end", v18);
    v19 = loc_10010400(v17);
    *(_DWORD *)&v53 = 0;
    LODWORD(v15) = 10000000;
    v20 = sub_10039A40((unsigned int)v19, v15);
    v12 = v8 & 0xFFFFFF01 | 1;
    v75 = v20;
    v62 = v12;
    v63 = 0;
    v60 = (void *)1;
    v61 = 0;
    LOBYTE(v82) = 5;
    LODWORD(v10) = sub_10010E40(v7 + 24, SHIDWORD(v20), (int)&lpMem, (int)"class", (int)&v60);
    LOBYTE(v82) = 6;
    v76 = loc_10010400(v10);
    LOBYTE(v82) = 5;
    v11 = (char)v57;
    if ( (char)v57 == 4 )
    {
      if ( v57 & 0x100 )
      {
        if ( lpMem )
          sub_100309A2(v12, lpMem);
      }
    }
    else
    {
      if ( (unsigned int)((char)v57 - 6) <= 1 )
      {
        v21 = lpMem;
        if ( lpMem )
        {
          *(_DWORD *)&v53 = *(_DWORD *)lpMem;
          sub_100130F0(lpMem, (int)&v67, **(_DWORD **)&v53, *(int *)&v53);
          *(_DWORD *)&v53 = *(_DWORD *)v21;
          sub_1002A4AA(*(LPVOID *)&v53);
          sub_1002A4AA(v21);
        }
      }
    }
    if ( v58 )
    {
      *(_DWORD *)&v53 = sub_1000FF60;
      v22 = (void *)(v58 - 4);
      sub_1002B11F(v58, 4, *(_DWORD *)(v58 - 4), (void (__thiscall *)(_DWORD))sub_1000FF60);
      sub_10030383(v22);
    }
    LOBYTE(v82) = 4;
    v8 = v62;
    if ( (char)v62 == 4 )
    {
      if ( v62 & 0x100 )
      {
        if ( v60 )
          sub_100309A2(v62, v60);
      }
    }
    else
    {
      if ( (unsigned int)((char)v62 - 6) <= 1 )
      {
        v23 = v60;
        if ( v60 )
        {
          *(_DWORD *)&v53 = *(_DWORD *)v60;
          sub_100130F0(v60, (int)&v59, **(_DWORD **)&v53, *(int *)&v53);
          *(_DWORD *)&v53 = *(_DWORD *)v23;
          sub_1002A4AA(*(LPVOID *)&v53);
          sub_1002A4AA(v23);
        }
      }
    }
    if ( v63 )
    {
      *(_DWORD *)&v53 = sub_1000FF60;
      v24 = (void *)(v63 - 4);
      sub_1002B11F(v63, 4, *(_DWORD *)(v63 - 4), (void (__thiscall *)(_DWORD))sub_1000FF60);
      sub_10030383(v24);
    }
    v26 = sub_10010C90(v7 + 24, SHIDWORD(v10), (int)"comment", v11);
    v25 = loc_100102E0(v26, &v54);
    if ( &v77 != (void **)v25 )
    {
      if ( v79 >= 0x10 )
        sub_1002A4AA(v77);
      v79 = 15;
      v78 = 0;
      LOBYTE(v77) = 0;
      if ( *(_DWORD *)(v25 + 20) >= 0x10u )
      {
        v77 = *(void **)v25;
        *(_DWORD *)v25 = 0;
      }
      else
      {
        if ( *(_DWORD *)(v25 + 16) != -1 )
          sub_1002A4B0(&v77, (const void *)v25, *(_DWORD *)(v25 + 16) + 1);
      }
      v78 = *(_DWORD *)(v25 + 16);
      v79 = *(_DWORD *)(v25 + 20);
      *(_DWORD *)(v25 + 20) = 15;
      *(_DWORD *)(v25 + 16) = 0;
      *(_BYTE *)v25 = 0;
    }
    if ( v55 >= 0x10 )
      sub_1002A4AA(v54);
    sub_10002A30((int)&v69, (unsigned int)&v74);
    LOBYTE(v82) = 3;
    if ( v79 >= 0x10 )
      sub_1002A4AA(v77);
    if ( *(_BYTE *)(v7 + 13) )
    {
      v6 = v69;
      LOBYTE(v4) = v73;
    }
    else
    {
      v27 = *(_DWORD *)(v7 + 8);
      if ( *(_BYTE *)(v27 + 13) )
      {
        for ( i = *(_DWORD *)(v7 + 4); !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 4) )
        {
          if ( v7 != *(_DWORD *)(i + 8) )
            break;
          v7 = i;
        }
        v6 = v69;
        LOBYTE(v4) = v73;
        v7 = i;
      }
      else
      {
        v7 = *(_DWORD *)(v7 + 8);
        for ( j = *(_DWORD *)v27; !*(_BYTE *)(j + 13); j = *(_DWORD *)j )
          v7 = j;
        v6 = v69;
        LOBYTE(v4) = v73;
      }
    }
  }
  v32 = (signed int)((unsigned __int64)(715827883i64 * (v70 - v6)) >> 32) >> 3;
  v33 = v32 + ((unsigned int)v32 >> 31);
  sub_10005130(v6, v70, v33, (int)sub_10001750);
  v67 = *(_DWORD *)v68 + 40;
  v31 = v33 + (*(_DWORD *)(v67 + 4) - *(_DWORD *)v67) / 48;
  v30 = v67;
  if ( (*(_DWORD *)(v30 + 8) - *(_DWORD *)v30) / 48 < (unsigned int)v31 )
  {
    if ( (unsigned int)v31 > 0x5555555 )
      sub_10029585((int)"vector<T> too long");
    loc_10002E20(v30, v31);
  }
  v34 = v68;
  v35 = v70;
  sub_100037D0((void *)(*(_DWORD *)v68 + 40), v6, v70);
  *(_DWORD *)(*(_DWORD *)v34 + 52) = 2;
  if ( v6 )
  {
    if ( v6 != v35 )
    {
      v36 = v6 + 40;
      do
      {
        if ( *(_DWORD *)v36 >= 0x10u )
        {
          *(_DWORD *)&v53 = *(_DWORD *)(v36 - 20);
          sub_1002A4AA(*(LPVOID *)&v53);
        }
        *(_DWORD *)v36 = 15;
        *(_DWORD *)(v36 - 4) = 0;
        *(_BYTE *)(v36 - 20) = 0;
        v36 += 48;
      }
      while ( v36 - 40 != v70 );
    }
    sub_1002A4AA((LPVOID)v6);
  }
  LOBYTE(v82) = 1;
  if ( (char)v65 == 4 )
  {
    if ( v65 & 0x100 )
    {
      if ( v64 )
        sub_100309A2(v34, v64);
    }
  }
  else
  {
    if ( (unsigned int)((char)v65 - 6) <= 1 )
    {
      v37 = v64;
      if ( v64 )
      {
        *(_DWORD *)&v53 = *(_DWORD *)v64;
        sub_100130F0(v64, (int)&v59, **(_DWORD **)&v53, *(int *)&v53);
        *(_DWORD *)&v53 = *(_DWORD *)v37;
        sub_1002A4AA(*(LPVOID *)&v53);
        sub_1002A4AA(v37);
      }
    }
  }
  result = v66;
  if ( v66 )
  {
    *(_DWORD *)&v53 = sub_1000FF60;
    v39 = (void *)(v66 - 4);
    sub_1002B11F(v66, 4, *(_DWORD *)(v66 - 4), (void (__thiscall *)(_DWORD))sub_1000FF60);
    result = sub_10030383(v39);
  }
  v82 = -1;
  v40 = a3;
  if ( a3 )
  {
    _EDI = -1;
    _ECX = a3 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v40)(v40);
      result = v40 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (**)(void))(*(_DWORD *)v40 + 4))();
    }
  }
  return result;
}
// 1000FF60: using guessed type int sub_1000FF60();
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10002953) --------------------------------------------------------
int (*__usercall sub_10002953<eax>(int a1<ebp>))()
{
  *(_DWORD *)(**(_DWORD **)(a1 - 80) + 52) = 3;
  return loc_10002965;
}
// 10002965: using guessed type int loc_10002965();

//----- (1000297B) --------------------------------------------------------
int (*__usercall sub_1000297B<eax>(int a1<ebp>))()
{
  *(_DWORD *)(**(_DWORD **)(a1 - 80) + 52) = 3;
  return loc_1000298D;
}
// 1000298D: using guessed type int loc_1000298D();

//----- (100029F0) --------------------------------------------------------
int __thiscall sub_100029F0(void *this)
{
  int v1; // ecx@1
  void *v2; // esi@1
  int result; // eax@2

  v2 = this;
  v1 = *(_DWORD *)this;
  if ( v1 )
  {
    sub_10004310(v1, *((_DWORD *)v2 + 1));
    result = sub_1002A4AA(*(LPVOID *)v2);
    *(_DWORD *)v2 = 0;
    *((_DWORD *)v2 + 1) = 0;
    *((_DWORD *)v2 + 2) = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10002A30) --------------------------------------------------------
int __thiscall sub_10002A30(int this, unsigned int a2)
{
  signed __int64 v2; // qax@1
  unsigned int v3; // ecx@1
  int v4; // esi@1
  int v5; // edi@3
  int v6; // edx@5
  int v7; // ecx@5
  int v8; // eax@6
  int v9; // ecx@11
  int v11; // [sp+10h] [bp-Ch]@1
  int v12; // [sp+18h] [bp-4h]@5

  LODWORD(v2) = &v11;
  v4 = this;
  v3 = *(_DWORD *)(this + 4);
  if ( a2 >= v3 || (LODWORD(v2) = *(_DWORD *)v4, *(_DWORD *)v4 > a2) )
  {
    if ( v3 == *(_DWORD *)(v4 + 8) )
      LODWORD(v2) = loc_10002ED0(v4, 1);
    v7 = *(_DWORD *)(v4 + 4);
    v12 = 1;
    if ( v7 )
    {
      *(_DWORD *)v7 = *(_DWORD *)a2;
      *(_DWORD *)(v7 + 4) = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(v7 + 8) = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(v7 + 12) = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(v7 + 16) = *(_DWORD *)(a2 + 16);
      v8 = a2 + 20;
      goto LABEL_11;
    }
  }
  else
  {
    v2 = 715827883i64 * (signed int)(a2 - v2);
    v5 = (HIDWORD(v2) >> 3) + (HIDWORD(v2) >> 31);
    if ( v3 == *(_DWORD *)(v4 + 8) )
      LODWORD(v2) = loc_10002ED0(v4, 1);
    v7 = *(_DWORD *)(v4 + 4);
    v6 = *(_DWORD *)v4 + 48 * v5;
    v12 = 0;
    if ( v7 )
    {
      *(_DWORD *)v7 = *(_DWORD *)v6;
      *(_DWORD *)(v7 + 4) = *(_DWORD *)(v6 + 4);
      *(_DWORD *)(v7 + 8) = *(_DWORD *)(v6 + 8);
      *(_DWORD *)(v7 + 12) = *(_DWORD *)(v6 + 12);
      *(_DWORD *)(v7 + 16) = *(_DWORD *)(v6 + 16);
      v8 = v6 + 20;
LABEL_11:
      v9 = v7 + 20;
      *(_DWORD *)(v9 + 20) = 15;
      *(_DWORD *)(v9 + 16) = 0;
      *(_BYTE *)v9 = 0;
      LODWORD(v2) = loc_1000AB40(v8, 0, -1);
      goto LABEL_12;
    }
  }
LABEL_12:
  *(_DWORD *)(v4 + 4) += 48;
  return v2;
}

//----- (10002B40) --------------------------------------------------------
int __thiscall sub_10002B40(int this, char a2, int a3)
{
  int v3; // esi@1
  char v5; // [sp-8h] [bp-20h]@2
  int v6; // [sp-4h] [bp-1Ch]@2
  int v7; // [sp+14h] [bp-4h]@1

  v3 = this;
  v7 = 0;
  if ( *(_DWORD *)(this + 12) != 3 )
  {
    sub_1002FD39((int)&v5, (int)&a2);
    sub_10003180((void *)(v3 + 84), v5, v6);
  }
  v7 = -1;
  return sub_1002FDDA((int)&a2);
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);

//----- (10002C30) --------------------------------------------------------
int __thiscall sub_10002C30(int this, unsigned __int8 *a2, int a3, unsigned int a4)
{
  int result; // eax@2
  unsigned int v5; // edi@3
  int v6; // edi@5
  int v7; // eax@8
  int v8; // ebx@8
  unsigned __int8 *v9; // esi@8
  int v10; // edx@9
  int v11; // ecx@9
  char v12; // cf@11
  int v13; // eax@21
  int v14; // [sp+0h] [bp-8h]@1
  int v15; // [sp+4h] [bp-4h]@7

  v14 = this;
  if ( a4 )
  {
    v5 = *(_DWORD *)(this + 16);
    if ( v5 && a4 <= v5 )
    {
      v6 = 1 - a4 + v5;
      if ( *(_DWORD *)(this + 20) >= 0x10u )
        this = *(_DWORD *)this;
      while ( 1 )
      {
        v15 = this;
        if ( !v6 )
          break;
        v9 = a2;
        v7 = sub_100300E0(this, *a2, v6);
        v8 = v7;
        if ( !v7 )
          break;
        v10 = v7;
        v11 = a4 - 4;
        if ( a4 < 4 )
        {
LABEL_12:
          if ( v11 == -4 )
            goto LABEL_21;
        }
        else
        {
          while ( *(_DWORD *)v10 == *(_DWORD *)v9 )
          {
            v10 += 4;
            v9 += 4;
            v12 = (unsigned int)v11 < 4;
            v11 -= 4;
            if ( v12 )
              goto LABEL_12;
          }
        }
        if ( *(_BYTE *)v10 == *v9
          && (v11 == -3
           || *(_BYTE *)(v10 + 1) == v9[1]
           && (v11 == -2 || *(_BYTE *)(v10 + 2) == v9[2] && (v11 == -1 || *(_BYTE *)(v10 + 3) == v9[3]))) )
        {
LABEL_21:
          v13 = v14;
          if ( *(_DWORD *)(v14 + 20) >= 0x10u )
            v13 = *(_DWORD *)v14;
          return v8 - v13;
        }
        v6 += v15 - v7 - 1;
        this = v7 + 1;
      }
    }
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10002D20) --------------------------------------------------------
int __thiscall sub_10002D20(int this)
{
  int v1; // eax@1
  int v2; // esi@1
  int v3; // edi@6
  int result; // eax@10

  v2 = this;
  v1 = *(_DWORD *)(this + 16);
  if ( v1 )
  {
    do
    {
      --v1;
      if ( !v1 )
        *(_DWORD *)(this + 12) = 0;
    }
    while ( v1 );
    *(_DWORD *)(this + 16) = 0;
  }
  v3 = *(_DWORD *)(this + 8);
  while ( v3 )
  {
    --v3;
    if ( *(_DWORD *)(*(_DWORD *)(v2 + 4) + 4 * v3) )
      sub_1002A4AA(*(LPVOID *)(*(_DWORD *)(v2 + 4) + 4 * v3));
  }
  result = *(_DWORD *)(v2 + 4);
  if ( result )
    result = sub_1002A4AA(*(LPVOID *)(v2 + 4));
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10002D80) --------------------------------------------------------
int __thiscall sub_10002D80(int this)
{
  int v1; // ecx@1
  int v2; // esi@1
  int v3; // edi@2
  char v4; // zf@4
  int v5; // edi@7
  int result; // eax@11

  v2 = this;
  v1 = *(_DWORD *)(this + 16);
  while ( v1 )
  {
    v3 = *(_DWORD *)(*(_DWORD *)(v2 + 4) + 4 * ((v1 + *(_DWORD *)(v2 + 12) - 1) & (*(_DWORD *)(v2 + 8) - 1)));
    if ( *(_DWORD *)(v3 + 32) >= 0x10u )
      sub_1002A4AA(*(LPVOID *)(v3 + 12));
    *(_DWORD *)(v3 + 32) = 15;
    *(_DWORD *)(v3 + 28) = 0;
    *(_BYTE *)(v3 + 12) = 0;
    v4 = *(_DWORD *)(v2 + 16)-- == 1;
    v1 = *(_DWORD *)(v2 + 16);
    if ( v4 )
      *(_DWORD *)(v2 + 12) = 0;
  }
  v5 = *(_DWORD *)(v2 + 8);
  while ( v5 )
  {
    --v5;
    if ( *(_DWORD *)(*(_DWORD *)(v2 + 4) + 4 * v5) )
      sub_1002A4AA(*(LPVOID *)(*(_DWORD *)(v2 + 4) + 4 * v5));
  }
  result = *(_DWORD *)(v2 + 4);
  if ( result )
    result = sub_1002A4AA(*(LPVOID *)(v2 + 4));
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10002F80) --------------------------------------------------------
char __userpurge sub_10002F80<al>(int a1<ecx>, int a2<ebx>, char a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int ebp0; // ebp@0
  int v8; // esi@1
  int v9; // edx@3
  int v10; // ecx@3
  int v11; // edi@3
  int v12; // ecx@5
  int v13; // eax@6
  int v14; // edx@8
  int v15; // esi@9
  int v16; // edi@10
  int v17; // ecx@10
  int v18; // edx@10
  int v19; // eax@15
  int v20; // esi@16
  char v36; // [sp+Ch] [bp-50h]@10
  int v37; // [sp+1Ch] [bp-40h]@3
  int v38; // [sp+20h] [bp-3Ch]@3
  int v39; // [sp+24h] [bp-38h]@3
  int v40; // [sp+28h] [bp-34h]@1
  char v41; // [sp+2Fh] [bp-2Dh]@3
  unsigned int v42; // [sp+4Ch] [bp-10h]@1
  int v43; // [sp+58h] [bp-4h]@1
  int v44; // [sp+5Ch] [bp+0h]@1

  v42 = (unsigned int)&v44 ^ __security_cookie;
  v8 = a1;
  v40 = a1;
  v43 = 0;
  v6 = *(_DWORD *)a1;
  if ( *(_BYTE *)(*(_DWORD *)a1 + 72) || *(_BYTE *)(v6 + 73) )
  {
    v41 = 0;
  }
  else
  {
    a2 = 0;
    v11 = 0;
    v37 = 0;
    v38 = 0;
    v39 = 0;
    v41 = 0;
    sub_1002B62D(ebp0, v6 + 12);
    LOBYTE(v43) = 2;
    v10 = *(_DWORD *)v8;
    if ( !*(_BYTE *)(*(_DWORD *)v8 + 72) )
    {
      if ( !*(_BYTE *)(v10 + 73) )
      {
        sub_10010260(v10 + 48, v9, (int)&a3);
        *(_BYTE *)(*(_DWORD *)v8 + 72) = 1;
        v12 = *(_DWORD *)v8;
        if ( &v37 != *(int **)v8 )
        {
          v11 = *(_DWORD *)v12;
          *(_DWORD *)v12 = 0;
          a2 = *(_DWORD *)(v12 + 4);
          *(_DWORD *)(v12 + 4) = 0;
          v13 = *(_DWORD *)(v12 + 8);
          v37 = v11;
          v38 = a2;
          v39 = v13;
          *(_DWORD *)(v12 + 8) = 0;
        }
        v41 = 1;
      }
    }
    LOBYTE(v43) = 1;
    sub_1002B6D6();
    if ( v41 )
    {
      v15 = v11;
      if ( v11 != a2 )
      {
        do
        {
          sub_10010010((int)&v36, v14, *(_DWORD *)v40 + 48);
          v16 = *(_DWORD *)v15;
          v17 = *(_DWORD *)v15 + 152;
          LOBYTE(v43) = 4;
          sub_10010260(v17, v18, (int)&v36);
          sub_1002B62D(ebp0, v16 + 100);
          LOBYTE(v43) = 4;
          if ( *(_DWORD *)(v16 + 84) == 4 )
          {
            sub_1002B6D6();
          }
          else
          {
            *(_DWORD *)(v16 + 84) = 3;
            sub_1002B6D6();
            sub_1002C5B4(ebp0);
            sub_1000A690(v16);
          }
          LOBYTE(v43) = 1;
          sub_100101D0((int)&v36, a2);
          v15 += 8;
        }
        while ( v15 != a2 );
        v11 = v37;
      }
      v19 = *(_DWORD *)v40;
      if ( *(_DWORD *)(*(_DWORD *)v40 + 64) )
      {
        v20 = *(_DWORD *)(v19 + 68);
        *(_DWORD *)(v19 + 68) = 0;
        *(_DWORD *)(v19 + 64) = 0;
        if ( v20 )
        {
          _ECX = v20 + 4;
          _EAX = -1;
          __asm { lock xadd [ecx], eax }
          if ( _ZF )
          {
            (**(void (__thiscall ***)(_DWORD))v20)(v20);
            _EAX = v20 + 8;
            _ECX = -1;
            __asm { lock xadd [eax], ecx }
            if ( _ZF )
              (*(void (__thiscall **)(int))(*(_DWORD *)v20 + 4))(v20);
          }
        }
      }
      v41 = 1;
    }
    else
    {
      v41 = 0;
    }
    if ( v11 )
    {
      sub_10004350(v11, a2);
      sub_1002A4AA((LPVOID)v11);
    }
  }
  v43 = -1;
  sub_100101D0((int)&a3, a2);
  return v41;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10003180) --------------------------------------------------------
char __thiscall sub_10003180(void *this, char a2, int a3)
{
  void *v3; // esi@1
  char v4; // bl@2
  char v6; // [sp-Ch] [bp-30h]@1
  int v7; // [sp-8h] [bp-2Ch]@1
  int v8; // [sp-4h] [bp-28h]@1
  char v9; // [sp+10h] [bp-14h]@1
  int v10; // [sp+20h] [bp-4h]@1

  v3 = this;
  v10 = 0;
  sub_1002FD39((int)&v9, (int)&a2);
  v8 = 0;
  LOBYTE(v10) = 1;
  sub_1002FD39((int)&v6, (int)&v9);
  if ( sub_10004210(v3, v6, v7, v8) )
    v4 = sub_10003A60(v3);
  else
    v4 = 0;
  LOBYTE(v10) = 0;
  sub_1002FDDA((int)&v9);
  v10 = -1;
  sub_1002FDDA((int)&a2);
  return v4;
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);

//----- (10003230) --------------------------------------------------------
int __usercall sub_10003230<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // eax@1
  int ebp0; // ebp@0
  int v4; // esi@1
  int v5; // ecx@2

  v4 = a1;
  *(_DWORD *)a1 = &off_1006814C;
  v2 = *(_DWORD *)(a1 + 140);
  if ( v2 )
  {
    sub_1002B29A(ebp0, v2);
    v5 = *(_DWORD *)(v4 + 140);
    _EDX = -1;
    _EAX = v5 + 4;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v5 + 4))();
    *(_DWORD *)(v4 + 140) = 0;
  }
  sub_100101D0(v4 + 152, a2);
  return sub_1000A960(v4);
}
// 1006814C: using guessed type int (__stdcall *off_1006814C)(char);

//----- (100032D0) --------------------------------------------------------
char __thiscall sub_100032D0(void *this, char a2, char a3, int a4, int a5)
{
  char v5; // bl@1
  int ebp0; // ebp@0
  int v7; // esi@1
  int v8; // eax@7
  int v10; // ecx@14
  char v11; // [sp+10h] [bp-4Ch]@1
  void **v12; // [sp+14h] [bp-48h]@18
  int v13; // [sp+18h] [bp-44h]@18
  int *v14; // [sp+24h] [bp-38h]@18
  unsigned int v15; // [sp+48h] [bp-14h]@1
  int v16; // [sp+58h] [bp-4h]@1

  v15 = (unsigned int)&v11 ^ __security_cookie;
  v7 = (int)this;
  v5 = 0;
  sub_1002B62D(ebp0, (int)((char *)this + 100));
  v16 = 0;
  if ( !a3 )
  {
    v8 = *(_DWORD *)(v7 + 84);
    if ( v8 != 3 && v8 != 4 )
    {
      if ( v8 != 2 )
        goto LABEL_4;
      if ( a2 )
      {
LABEL_13:
        *(_DWORD *)(v7 + 84) = 4;
        sub_1002C5B4(ebp0);
        v5 = 1;
        goto LABEL_14;
      }
    }
LABEL_11:
    v16 = -1;
    sub_1002B6D6();
    return 0;
  }
  if ( *(_DWORD *)(v7 + 84) == 4 )
    goto LABEL_11;
  sub_1000A140((void *)(v7 + 92), a5);
LABEL_4:
  if ( a2 || !*(_DWORD *)(v7 + 84) )
    goto LABEL_13;
  *(_DWORD *)(v7 + 84) = 2;
LABEL_14:
  v10 = *(_DWORD *)(v7 + 144);
  if ( v10 )
    sub_1002D5ED(v10 + 8, v5, a5);
  v16 = -1;
  sub_1002B6D6();
  if ( v5 )
  {
    sub_1002C5B4(ebp0);
    if ( *(_DWORD *)(v7 + 132) )
    {
      v12 = &off_1006807C;
      v13 = v7;
      v14 = (int *)&v12;
      v16 = 2;
      sub_1000A250((int)&v12, 16);
      sub_10006050((int)&v12);
    }
  }
  return 1;
}
// 1006807C: using guessed type void *off_1006807C;
// 10074200: using guessed type int __security_cookie;

//----- (10003420) --------------------------------------------------------
int __fastcall sub_10003420(int a1, int a2, int a3)
{
  sub_10010010(a3, a2, a1 + 152);
  return a3;
}

//----- (10003450) --------------------------------------------------------
void *__userpurge sub_10003450<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_10003230(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10003480) --------------------------------------------------------
void *__thiscall sub_10003480(void *this, int a2)
{
  return this;
}

//----- (10003490) --------------------------------------------------------
int __thiscall sub_10003490(int this, int a2)
{
  unsigned int v2; // ecx@1
  int v3; // esi@1
  int v4; // esi@2
  int result; // eax@4
  int v6; // esi@5

  v3 = (*(_DWORD *)(this + 8) - *(_DWORD *)this) / 48;
  v2 = (unsigned int)((*(_DWORD *)(this + 8) - *(_DWORD *)this) / 48) >> 1;
  if ( 89478485 - v2 >= v3 )
  {
    v6 = v2 + v3;
    if ( v6 < (unsigned int)a2 )
      v6 = a2;
    result = v6;
  }
  else
  {
    v4 = 0;
    if ( (unsigned int)a2 > 0 )
      v4 = a2;
    result = v4;
  }
  return result;
}

//----- (100034E0) --------------------------------------------------------
int __thiscall sub_100034E0(void *this)
{
  int v1; // ecx@1
  void *v2; // esi@1
  int result; // eax@2

  v2 = this;
  v1 = *(_DWORD *)this;
  if ( v1 )
  {
    sub_10004350(v1, *((_DWORD *)v2 + 1));
    result = sub_1002A4AA(*(LPVOID *)v2);
    *(_DWORD *)v2 = 0;
    *((_DWORD *)v2 + 1) = 0;
    *((_DWORD *)v2 + 2) = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10003520) --------------------------------------------------------
int __userpurge sub_10003520<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, char a4, int a5, int a6, int a7)
{
  int ebp0; // ebp@0
  int v8; // esi@1

  v8 = a2;
  sub_10010260(a2 + 152, a1, (int)&a4);
  sub_1002B62D(ebp0, v8 + 100);
  if ( *(_DWORD *)(v8 + 84) == 4 )
  {
    sub_1002B6D6();
  }
  else
  {
    *(_DWORD *)(v8 + 84) = 3;
    sub_1002B6D6();
    sub_1002C5B4(ebp0);
    sub_1000A690(v8);
  }
  return sub_100101D0((int)&a4, a3);
}

//----- (100035D0) --------------------------------------------------------
int __stdcall sub_100035D0(int a1)
{
  return a1;
}

//----- (100035E0) --------------------------------------------------------
int __thiscall sub_100035E0(int this, int a2)
{
  int v3; // ebx@1
  char v4; // [sp-14h] [bp-44h]@1
  char v5; // [sp-Ch] [bp-3Ch]@1
  int v6; // [sp-8h] [bp-38h]@1
  unsigned int v7; // [sp-4h] [bp-34h]@1
  int v8; // [sp+14h] [bp-1Ch]@1
  int v9; // [sp+18h] [bp-18h]@1
  unsigned int v10; // [sp+1Ch] [bp-14h]@1
  int v11; // [sp+2Ch] [bp-4h]@1
  int v12; // [sp+30h] [bp+0h]@1

  v10 = (unsigned int)&v12 ^ __security_cookie;
  v7 = (unsigned int)&v12 ^ __security_cookie;
  v3 = this;
  v8 = 0;
  v9 = 0;
  sub_1002AEE4((int)&v4, this, a2);
  *(_DWORD *)&v4 = &off_100683AC;
  v6 = *(_DWORD *)(a2 + 12);
  sub_10003C50(&v8, v3, (unsigned int)&off_100683AC);
  v11 = 0;
  sub_1002FD39((int)&v5, (int)&v8);
  (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 24))(v3);
  v11 = -1;
  return sub_1002FDDA((int)&v8);
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);
// 100683AC: using guessed type int (__stdcall *off_100683AC)(char);
// 10074200: using guessed type int __security_cookie;

//----- (100036A0) --------------------------------------------------------
char __fastcall sub_100036A0(int a1, int a2)
{
  unsigned int v2; // edi@1
  unsigned int v3; // esi@3
  unsigned int v4; // eax@5
  int v5; // ecx@7

  v2 = *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 20) >= 0x10u )
    a2 = *(_DWORD *)a2;
  v3 = *(_DWORD *)(a1 + 16);
  if ( *(_DWORD *)(a1 + 20) >= 0x10u )
    a1 = *(_DWORD *)a1;
  v4 = v2;
  if ( v3 < v2 )
    v4 = v3;
  v5 = sub_100099E0(a1, a2, v4);
  if ( !v5 )
  {
    if ( v3 < v2 )
      return 0;
    v5 = v3 != v2;
  }
  return v5 == 0;
}

//----- (100036F0) --------------------------------------------------------
#error "100037BF: positive sp value has been found (funcsize=61)"

//----- (100037D0) --------------------------------------------------------
int __thiscall sub_100037D0(void *this, int a2, int a3)
{
  int result; // eax@1
  unsigned int v4; // ecx@1
  int v5; // esi@1
  signed int v6; // ebx@2
  int v7; // edi@2
  signed int v8; // edx@2
  int v9; // ecx@3
  int v10; // ebx@11
  int v11; // ebx@12
  int v12; // edi@12
  int v13; // esi@12
  int v14; // [sp+Ch] [bp-30h]@12
  int v15; // [sp+10h] [bp-2Ch]@12
  int v16; // [sp+14h] [bp-28h]@12
  int v17; // [sp+18h] [bp-24h]@3
  unsigned int v18; // [sp+1Ch] [bp-20h]@3
  int v19; // [sp+20h] [bp-1Ch]@1
  int v20; // [sp+24h] [bp-18h]@2
  int v21; // [sp+28h] [bp-14h]@2
  unsigned int v22; // [sp+2Ch] [bp-10h]@1
  int v23; // [sp+38h] [bp-4h]@12
  int v24; // [sp+3Ch] [bp+0h]@1

  v22 = (unsigned int)&v24 ^ __security_cookie;
  result = (int)this;
  v19 = (int)this;
  v4 = a2;
  v5 = a3;
  if ( a2 != a3 )
  {
    v7 = *(_DWORD *)(result + 4);
    v20 = *(_DWORD *)result;
    v8 = (signed int)((unsigned __int64)(715827883i64 * (v7 - v20)) >> 32) >> 3;
    v6 = v8 + ((unsigned int)v8 >> 31);
    v21 = v7;
    if ( v6 > 0 )
    {
      v18 = *(_DWORD *)a2;
      v9 = v20;
      v17 = *(_DWORD *)(a2 + 4);
      do
      {
        if ( v17 < *(_DWORD *)(v9 + 48 * v6 / 2 + 4)
          || v17 <= *(_DWORD *)(v9 + 48 * v6 / 2 + 4) && v18 < *(_DWORD *)(v9 + 48 * v6 / 2) )
        {
          v6 /= 2;
        }
        else
        {
          v9 += 48 * v6 / 2 + 48;
          v6 += -1 - v6 / 2;
        }
      }
      while ( v6 > 0 );
      v5 = a3;
      v7 = v21;
      v20 = v9;
      v4 = a2;
    }
    v10 = v20;
    if ( v20 == v7 )
    {
      result = sub_10003E70(v19, v4, v5);
    }
    else
    {
      v14 = 0;
      v15 = 0;
      v16 = 0;
      sub_10003B90((int)&v14, (v7 - v20) / 48 + (signed int)(v5 - v4) / 48);
      v13 = v19;
      v23 = 0;
      v12 = v14;
      sub_10005280((int)&v21, v10, *(_DWORD *)(v19 + 4), a2, a3, v14, (int (__cdecl *)(_DWORD, _DWORD))sub_10001750);
      sub_100039D0(v13, (int)&v21, v10, *(_DWORD *)(v13 + 4));
      v11 = v15;
      result = sub_10003E70(v13, v12, v15);
      if ( v12 )
      {
        sub_10004310(v12, v11);
        result = sub_1002A4AA((LPVOID)v12);
      }
    }
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10003960) --------------------------------------------------------
int __userpurge sub_10003960<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5)
{
  int result; // eax@1
  int v6; // ST08_4@1
  int v7; // ST0C_4@1
  int v8; // ST10_4@1
  int v9; // ST14_4@1
  void *v10; // [sp+Ch] [bp+4h]@1

  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_10004130(a1, a2, a3, a4, a5, v6, v7, v8, v9);
  result = a4;
  *(_DWORD *)(*(_DWORD *)a4 + 148) = v10;
  return result;
}

//----- (100039A0) --------------------------------------------------------
int __userpurge sub_100039A0<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // edi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_100683AC;
  *(_DWORD *)(v4 + 12) = *(_DWORD *)(a3 + 12);
  return v4;
}
// 100683AC: using guessed type int (__stdcall *off_100683AC)(char);

//----- (100039D0) --------------------------------------------------------
int __thiscall sub_100039D0(int this, int a2, int a3, int a4)
{
  int v4; // eax@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // esi@5

  v4 = a3;
  v5 = this;
  if ( a3 != *(_DWORD *)this || (v6 = *(_DWORD *)(this + 4), a4 != v6) )
  {
    if ( a3 != a4 )
    {
      v7 = sub_10005480(a4, *(_DWORD *)(this + 4), a3);
      sub_10004310(v7, *(_DWORD *)(v5 + 4));
      v4 = a3;
      *(_DWORD *)(v5 + 4) = v7;
    }
    *(_DWORD *)a2 = v4;
  }
  else
  {
    sub_10004310(*(_DWORD *)this, v6);
    *(_DWORD *)(v5 + 4) = *(_DWORD *)v5;
    *(_DWORD *)a2 = a3;
  }
  return a2;
}

//----- (10003A60) --------------------------------------------------------
char __thiscall sub_10003A60(void *this)
{
  int v1; // eax@1
  int ebp0; // ebp@0
  void *v3; // esi@1
  char result; // al@2
  int v5; // ebx@3
  int v6; // edi@3
  int v7; // ecx@4
  int v8; // eax@5
  char v9; // al@7
  int v10; // esi@8
  int v11; // ebx@9
  signed int v12; // [sp-10h] [bp-5Ch]@11
  signed int v13; // [sp-Ch] [bp-58h]@11
  int v14; // [sp-8h] [bp-54h]@11
  int v15; // [sp+Ch] [bp-40h]@3
  int v16; // [sp+10h] [bp-3Ch]@3
  int v17; // [sp+14h] [bp-38h]@3
  int v18; // [sp+18h] [bp-34h]@1
  char v19; // [sp+1Eh] [bp-2Eh]@7
  char v20; // [sp+1Fh] [bp-2Dh]@3
  unsigned int v21; // [sp+3Ch] [bp-10h]@1
  int v22; // [sp+48h] [bp-4h]@3
  int v23; // [sp+4Ch] [bp+0h]@1

  v21 = (unsigned int)&v23 ^ __security_cookie;
  v3 = this;
  v18 = (int)this;
  v1 = *(_DWORD *)this;
  if ( *(_BYTE *)(*(_DWORD *)this + 73) )
  {
    result = 0;
  }
  else
  {
    v5 = 0;
    v6 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v22 = 0;
    v20 = 0;
    sub_1002B62D(ebp0, v1 + 12);
    if ( !*(_BYTE *)(*(_DWORD *)v3 + 73) )
    {
      *(_BYTE *)(*(_DWORD *)v3 + 73) = 1;
      v7 = *(_DWORD *)v3;
      if ( &v15 != *(int **)v3 )
      {
        v5 = *(_DWORD *)v7;
        *(_DWORD *)v7 = 0;
        v6 = *(_DWORD *)(v7 + 4);
        *(_DWORD *)(v7 + 4) = 0;
        v8 = *(_DWORD *)(v7 + 8);
        v15 = v5;
        v16 = v6;
        v17 = v8;
        *(_DWORD *)(v7 + 8) = 0;
      }
      v20 = 1;
    }
    LOBYTE(v22) = 0;
    sub_1002B6D6();
    v9 = *(_DWORD *)(*(_DWORD *)v3 + 64) != 0;
    v19 = *(_DWORD *)(*(_DWORD *)v3 + 64) != 0;
    if ( v20 )
    {
      v10 = v5;
      if ( v5 != v6 )
      {
        v11 = v18;
        do
        {
          if ( v9 )
          {
            v14 = *(_DWORD *)v11 + 64;
            v13 = 1;
            v12 = 1;
          }
          else
          {
            v14 = *(_DWORD *)v10 + 92;
            v13 = 0;
            v12 = 0;
          }
          (*(void (__stdcall **)(signed int, signed int, signed int, int))(**(_DWORD **)v10 + 4))(1, v12, v13, v14);
          v9 = v19;
          v10 += 8;
        }
        while ( v10 != v6 );
        v5 = v15;
      }
    }
    if ( v5 )
    {
      sub_10004350(v5, v6);
      sub_1002A4AA((LPVOID)v5);
    }
    result = v20;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10003B90) --------------------------------------------------------
int __thiscall sub_10003B90(int this, unsigned int a2)
{
  signed __int64 v2; // qax@1
  int v3; // ecx@1
  unsigned int v4; // ebx@1
  int v5; // edi@1
  int v6; // esi@1
  int v8; // [sp+Ch] [bp-4h]@1

  v4 = a2;
  v5 = this;
  v6 = *(_DWORD *)(this + 4);
  v8 = this;
  v2 = 715827883i64 * (*(_DWORD *)(this + 4) - *(_DWORD *)this);
  v3 = (HIDWORD(v2) >> 3) + (HIDWORD(v2) >> 31);
  if ( v3 <= a2 )
  {
    if ( v3 < a2 )
    {
      loc_10002ED0(v5, a2 - v3);
      sub_100054F0(*(_DWORD *)(v5 + 4), v4 - (*(_DWORD *)(v5 + 4) - *(_DWORD *)v8) / 48);
      LODWORD(v2) = 48 * (v4 - (*(_DWORD *)(v8 + 4) - *(_DWORD *)v8) / 48);
      *(_DWORD *)(v8 + 4) += v2;
    }
  }
  else
  {
    LODWORD(v2) = sub_100039D0(v5, (int)&a2, *(_DWORD *)v5 + 48 * a2, v6);
  }
  return v2;
}

//----- (10003C50) --------------------------------------------------------
void *__usercall sub_10003C50<eax>(void *a1<ecx>, int a2<ebx>, char a3)
{
  void *v4; // esi@1

  v4 = a1;
  sub_100098C0(a1, (int)&unk_1006D810);
  sub_1002AF18((int)&a3, a2);
  return v4;
}

//----- (10003CB0) --------------------------------------------------------
int __fastcall sub_10003CB0(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8)
{
  int v8; // edi@1
  int i; // esi@1
  unsigned __int8 *v10; // eax@3

  v8 = a2;
  for ( i = a1; i != v8; i += 32 )
  {
    if ( *(_DWORD *)(i + 20) < 0x10u )
      v10 = (unsigned __int8 *)i;
    else
      v10 = *(unsigned __int8 **)i;
    if ( sub_10002C30((int)&a3, v10, a1, *(_DWORD *)(i + 16)) != -1 )
      break;
  }
  if ( a8 >= 0x10 )
    sub_1002A4AA(a3);
  return i;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10003D00) --------------------------------------------------------
int __usercall sub_10003D00<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, unsigned int a4, void *a5, int a6, int a7, int a8, int a9, signed int a10, char a11)
{
  int v11; // eax@1
  int v12; // ecx@1
  int v13; // edi@1
  int v14; // esi@2
  int v23; // esi@6
  int v24; // eax@6
  int v25; // edx@6
  int v47; // [sp-Ch] [bp-48h]@4
  int v48; // [sp-8h] [bp-44h]@4
  int v49; // [sp-4h] [bp-40h]@2
  char v50; // [sp+14h] [bp-28h]@6
  int v51; // [sp+18h] [bp-24h]@6
  int v52; // [sp+1Ch] [bp-20h]@1
  int v53; // [sp+20h] [bp-1Ch]@4
  int v54; // [sp+24h] [bp-18h]@1
  int v55; // [sp+28h] [bp-14h]@1
  int v56; // [sp+38h] [bp-4h]@1

  v13 = a2;
  v52 = a2;
  v54 = 0;
  v56 = 3;
  v11 = sub_1002ADB1(a1, a2, a3, a2, 116);
  v55 = v11;
  LOBYTE(v56) = 4;
  if ( v11 )
  {
    *(_DWORD *)(v11 + 4) = 0;
    *(_DWORD *)(v11 + 8) = 0;
    *(_DWORD *)(v11 + 16) = 0;
    *(_DWORD *)(v11 + 20) = 0;
    *(_DWORD *)(v11 + 48) = 0;
    *(_DWORD *)(v11 + 52) = 0;
    v49 = (int)&a11;
    *(_DWORD *)(v11 + 84) = 0;
    *(_DWORD *)(v11 + 88) = 0;
    v14 = sub_100047D0(v11, v13, v49);
  }
  else
  {
    v14 = 0;
  }
  v49 = (int)&v53;
  LOBYTE(v56) = 3;
  v48 = v13;
  v47 = v12;
  v53 = v14;
  if ( a4 )
  {
    _EAX = a4 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v24 = sub_10004460(v14, (int)&v50, (int)&a5, a4);
  LOBYTE(v56) = 5;
  sub_100050F0(v25, v24, (int)&v47, v48, v49);
  LOBYTE(v56) = 3;
  v23 = v51;
  _EBX = -1;
  v54 = 1;
  if ( v51 )
  {
    _EAX = v51 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v23)(v23);
      _EAX = v23 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v23 + 4))(v23, _EDX);
    }
  }
  if ( (unsigned int)a10 >= 8 )
    sub_1002A4AA(a5);
  a10 = 7;
  a9 = 0;
  LOWORD(a5) = 0;
  LOBYTE(v56) = 1;
  sub_100101D0((int)&a11, -1);
  LOBYTE(v56) = 0;
  if ( a4 )
  {
    _EDX = a4 + 4;
    __asm { lock xadd [edx], ebx }
    if ( _EBX == 1 )
      (*(void (**)(void))(*(_DWORD *)a4 + 4))();
  }
  return v13;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10003E70) --------------------------------------------------------
int __thiscall sub_10003E70(int this, unsigned int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  unsigned int v5; // ST08_4@2
  unsigned int i; // ecx@3
  int v7; // edx@4
  int v8; // edx@8
  int v9; // edi@8
  int v10; // edx@11
  int v11; // edx@12
  int v12; // edi@12
  int v13; // ecx@16
  int v14; // eax@18
  int v15; // edx@21
  int v16; // eax@22
  int v17; // ecx@22
  unsigned int v18; // edi@22
  int v19; // [sp+Ch] [bp-70h]@18
  int v20; // [sp+10h] [bp-6Ch]@18
  int v21; // [sp+14h] [bp-68h]@18
  int v22; // [sp+18h] [bp-64h]@18
  int v23; // [sp+1Ch] [bp-60h]@18
  void *v24; // [sp+20h] [bp-5Ch]@18
  int v25; // [sp+30h] [bp-4Ch]@18
  unsigned int v26; // [sp+34h] [bp-48h]@18
  int v27; // [sp+3Ch] [bp-40h]@22
  int v28; // [sp+40h] [bp-3Ch]@22
  unsigned int v29; // [sp+44h] [bp-38h]@22
  int v30; // [sp+48h] [bp-34h]@22
  int v31; // [sp+4Ch] [bp-30h]@22
  void *v32; // [sp+50h] [bp-2Ch]@22
  int v33; // [sp+60h] [bp-1Ch]@22
  unsigned int v34; // [sp+64h] [bp-18h]@22
  unsigned int v35; // [sp+6Ch] [bp-10h]@1
  int v36; // [sp+78h] [bp-4h]@18
  int v37; // [sp+7Ch] [bp+0h]@1

  v35 = (unsigned int)&v37 ^ __security_cookie;
  v4 = this;
  result = *(_DWORD *)this;
  if ( *(_DWORD *)this == *(_DWORD *)(this + 4) )
  {
    v5 = a2;
    a2 += 48;
    result = sub_10002A30(this, v5);
  }
  for ( i = a2; i != a3; a2 = i )
  {
    result = *(_DWORD *)(v4 + 4);
    v7 = *(_DWORD *)(i + 4);
    if ( v7 < *(_DWORD *)(result - 36) || v7 <= *(_DWORD *)(result - 36) && *(_DWORD *)i < *(_DWORD *)(result - 40) )
    {
      v8 = *(_DWORD *)(result - 36);
      v9 = *(_DWORD *)(i + 8);
      if ( v8 > *(_DWORD *)(i + 12) || v8 >= *(_DWORD *)(i + 12) && *(_DWORD *)(result - 40) >= (unsigned int)v9 )
      {
        v15 = *(_DWORD *)(result - 32);
        if ( v15 < *(_DWORD *)(i + 16) )
        {
          v27 = *(_DWORD *)(result - 48);
          v28 = *(_DWORD *)(result - 44);
          v29 = *(_DWORD *)(result - 40);
          v30 = *(_DWORD *)(result - 36);
          v31 = v15;
          v34 = 15;
          v33 = 0;
          LOBYTE(v32) = 0;
          loc_1000AB40(&v32, result - 28, 0, -1);
          v36 = 1;
          v16 = *(_DWORD *)(v4 + 4);
          v17 = *(_DWORD *)(v16 - 44);
          v18 = *(_DWORD *)a2;
          if ( v17 > *(_DWORD *)(a2 + 4) || v17 >= *(_DWORD *)(a2 + 4) && *(_DWORD *)(v16 - 48) >= v18 )
          {
            *(_DWORD *)(v16 - 48) = v18;
            *(_DWORD *)(v16 - 44) = *(_DWORD *)(a2 + 4);
            *(_DWORD *)(v16 - 40) = *(_DWORD *)(a2 + 8);
            *(_DWORD *)(v16 - 36) = *(_DWORD *)(a2 + 12);
            *(_DWORD *)(v16 - 32) = *(_DWORD *)(a2 + 16);
            if ( v16 - 28 != a2 + 20 )
              loc_1000AB40(v16 - 28, a2 + 20, 0, -1);
          }
          else
          {
            *(_DWORD *)(v16 - 40) = v18;
            *(_DWORD *)(v16 - 36) = *(_DWORD *)(a2 + 4);
            sub_10002A30(v4, a2);
          }
          i = a2;
          result = *(_DWORD *)(a2 + 12);
          if ( result <= v30 )
          {
            if ( result < v30 || *(_DWORD *)(a2 + 8) < v29 )
            {
              v27 = *(_DWORD *)(a2 + 8);
              v28 = *(_DWORD *)(a2 + 12);
              result = sub_10002A30(v4, (unsigned int)&v27);
              i = a2;
            }
          }
          v36 = -1;
          if ( v34 >= 0x10 )
          {
            result = sub_1002A4AA(v32);
            i = a2;
          }
          v34 = 15;
          v33 = 0;
          LOBYTE(v32) = 0;
        }
        goto LABEL_35;
      }
      v10 = *(_DWORD *)(i + 16);
      if ( *(_DWORD *)(result - 32) > v10 )
      {
        v19 = *(_DWORD *)i;
        v20 = *(_DWORD *)(i + 4);
        v21 = v9;
        v22 = *(_DWORD *)(i + 12);
        v23 = v10;
        v26 = 15;
        v25 = 0;
        LOBYTE(v24) = 0;
        loc_1000AB40(&v24, i + 20, 0, -1);
        v36 = 0;
        v14 = *(_DWORD *)(v4 + 4);
        v19 = *(_DWORD *)(v14 - 40);
        v20 = *(_DWORD *)(v14 - 36);
        result = sub_10002A30(v4, (unsigned int)&v19);
        v36 = -1;
        if ( v26 >= 0x10 )
          result = sub_1002A4AA(v24);
LABEL_20:
        i = a2;
        goto LABEL_35;
      }
      v11 = *(_DWORD *)(result - 44);
      v12 = *(_DWORD *)i;
      if ( v11 > *(_DWORD *)(i + 4) || v11 >= *(_DWORD *)(i + 4) && *(_DWORD *)(result - 48) >= (unsigned int)v12 )
      {
        *(_DWORD *)(result - 48) = v12;
        *(_DWORD *)(result - 44) = *(_DWORD *)(i + 4);
        *(_DWORD *)(result - 40) = *(_DWORD *)(i + 8);
        *(_DWORD *)(result - 36) = *(_DWORD *)(i + 12);
        *(_DWORD *)(result - 32) = *(_DWORD *)(i + 16);
        v13 = i + 20;
        result -= 28;
        if ( result == v13 )
          goto LABEL_20;
        result = loc_1000AB40(result, v13, 0, -1);
        i = a2;
      }
      else
      {
        *(_DWORD *)(result - 40) = v12;
        *(_DWORD *)(result - 36) = *(_DWORD *)(i + 4);
        result = sub_10002A30(v4, a2);
        i = a2;
      }
    }
    else
    {
      result = sub_10002A30(v4, i);
      i = a2;
    }
LABEL_35:
    i += 48;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10004130) --------------------------------------------------------
int __userpurge sub_10004130<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // edi@1
  int v10; // eax@3
  int v11; // eax@4
  int v13; // [sp-8h] [bp-30h]@4
  int v14; // [sp-4h] [bp-2Ch]@3
  char v15; // [sp+Ch] [bp-1Ch]@2
  int v16; // [sp+18h] [bp-10h]@1
  int v17; // [sp+24h] [bp-4h]@1

  v9 = a2;
  v17 = 0;
  v16 = 0;
  if ( !*(_DWORD *)a2 )
  {
    sub_1002FFB9((int)&v15, (unsigned int)"then() cannot be called on a default constructed task.");
    sub_100355DB((int)&v15, (int)&unk_1006D8B8);
  }
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_10006BC0(a1, a4, v9, a2);
  v17 = 0;
  v16 = 1;
  sub_10009800(a4, 2);
  *(_BYTE *)(*(_DWORD *)a4 + 88) = *(_BYTE *)(*(_DWORD *)v9 + 88) != 0;
  *(_BYTE *)(*(_DWORD *)a4 + 89) = 0;
  *(_BYTE *)(*(_DWORD *)a4 + 90) = 0;
  v10 = sub_1002CB8B(a3, v9, 0x34u);
  if ( v10 )
    v11 = sub_10004A90(v10, v9, a4, a5, v13, v14);
  else
    v11 = 0;
  sub_10009430(*(void **)v9, v11);
  return a4;
}

//----- (10004210) --------------------------------------------------------
char __thiscall sub_10004210(void *this, char a2, int a3, int a4)
{
  int v4; // eax@1
  int ebp0; // ebp@0
  int v6; // edi@1
  void *v7; // esi@1
  int v8; // esi@4
  int v9; // eax@4
  char v24; // bl@8
  char v26; // [sp-Ch] [bp-4Ch]@4
  unsigned int v27; // [sp-4h] [bp-44h]@1
  char v28; // [sp+Ch] [bp-34h]@4
  int v29; // [sp+10h] [bp-30h]@4
  unsigned int v30; // [sp+30h] [bp-10h]@1
  int v31; // [sp+3Ch] [bp-4h]@1
  int v32; // [sp+40h] [bp+0h]@1

  v30 = (unsigned int)&v32 ^ __security_cookie;
  v27 = (unsigned int)&v32 ^ __security_cookie;
  v7 = this;
  v6 = a4;
  v31 = 0;
  sub_1002B62D(ebp0, *(_DWORD *)this + 12);
  LOBYTE(v31) = 1;
  v4 = *(_DWORD *)v7;
  if ( *(_BYTE *)(*(_DWORD *)v7 + 72) || *(_BYTE *)(v4 + 73) || *(_DWORD *)(v4 + 64) )
  {
    v24 = 0;
  }
  else
  {
    sub_1002FD39((int)&v26, (int)&a2);
    v9 = sub_10004750(v6, (int)&v28, v6, v26);
    sub_100093C0((void *)(*(_DWORD *)v7 + 64), v9);
    v8 = v29;
    if ( v29 )
    {
      _EDI = -1;
      _ECX = v29 + 4;
      _EAX = -1;
      __asm { lock xadd [ecx], eax }
      if ( _ZF )
      {
        (**(void (__thiscall ***)(_DWORD))v8)(v8);
        _EAX = v8 + 8;
        __asm { lock xadd [eax], edi }
        if ( _EDI == 1 )
          (*(void (__thiscall **)(int))(*(_DWORD *)v8 + 4))(v8);
      }
    }
    v24 = 1;
  }
  LOBYTE(v31) = 0;
  sub_1002B6D6();
  v31 = -1;
  sub_1002FDDA((int)&a2);
  return v24;
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);
// 10074200: using guessed type int __security_cookie;

//----- (10004310) --------------------------------------------------------
int __fastcall sub_10004310(int a1, int a2)
{
  int v2; // edi@1
  int v3; // esi@2
  int result; // eax@5

  v2 = a2;
  if ( a1 != a2 )
  {
    v3 = a1 + 40;
    do
    {
      if ( *(_DWORD *)v3 >= 0x10u )
        sub_1002A4AA(*(LPVOID *)(v3 - 20));
      *(_DWORD *)v3 = 15;
      *(_DWORD *)(v3 - 4) = 0;
      *(_BYTE *)(v3 - 20) = 0;
      v3 += 48;
      result = v3 - 40;
    }
    while ( v3 - 40 != v2 );
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10004350) --------------------------------------------------------
int __fastcall sub_10004350(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // edi@2
  int v4; // esi@3
  int result; // eax@7

  v2 = a2;
  if ( a1 != a2 )
  {
    v3 = a1 + 4;
    do
    {
      v4 = *(_DWORD *)v3;
      if ( *(_DWORD *)v3 )
      {
        _EAX = v4 + 4;
        _ECX = -1;
        __asm { lock xadd [eax], ecx }
        if ( _ZF )
        {
          (**(void (__thiscall ***)(_DWORD))v4)(v4);
          _EAX = v4 + 8;
          _ECX = -1;
          __asm { lock xadd [eax], ecx }
          if ( _ZF )
            (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 4))(v4);
        }
      }
      v3 += 8;
      result = v3 - 4;
    }
    while ( v3 - 4 != v2 );
  }
  return result;
}

//----- (100043A0) --------------------------------------------------------
int __thiscall sub_100043A0(void *this, int a2, int a3, int a4)
{
  int v4; // ecx@1
  int v5; // edi@4

  v4 = *(_DWORD *)this;
  if ( v4 )
    (**(void (__stdcall ***)(_DWORD))v4)(1);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  if ( (int *)a2 == &a3 )
  {
    v5 = a4;
  }
  else
  {
    *(_DWORD *)(a2 + 4) = a4;
    v5 = 0;
    a4 = 0;
    *(_DWORD *)a2 = a3;
    a3 = 0;
  }
  if ( v5 )
  {
    _EBX = -1;
    _ECX = v5 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      _EDX = v5 + 8;
      __asm { lock xadd [edx], ebx }
      if ( _EBX == 1 )
        (*(void (**)(void))(*(_DWORD *)v5 + 4))();
    }
  }
  return a2;
}

//----- (10004460) --------------------------------------------------------
int __thiscall sub_10004460(int this, int a2, int a3, unsigned int a4)
{
  int v4; // eax@1
  int v13; // esi@5
  int v14; // eax@5
  int v15; // edx@5
  __int16 v37; // [sp-28h] [bp-68h]@3
  void *v38; // [sp-24h] [bp-64h]@5
  int v39; // [sp-20h] [bp-60h]@5
  int v40; // [sp-1Ch] [bp-5Ch]@5
  int v41; // [sp-18h] [bp-58h]@3
  int v42; // [sp-14h] [bp-54h]@3
  int v43; // [sp-Ch] [bp-4Ch]@3
  int v44; // [sp-8h] [bp-48h]@3
  int v45; // [sp-4h] [bp-44h]@1
  int v46; // [sp+10h] [bp-30h]@1
  int (__stdcall **v47)(char); // [sp+14h] [bp-2Ch]@2
  char v48; // [sp+18h] [bp-28h]@5
  int v49; // [sp+1Ch] [bp-24h]@5
  int v50; // [sp+24h] [bp-1Ch]@1
  int v51; // [sp+28h] [bp-18h]@2
  unsigned int v52; // [sp+2Ch] [bp-14h]@1
  int v53; // [sp+3Ch] [bp-4h]@1
  int v54; // [sp+40h] [bp+0h]@1

  v52 = (unsigned int)&v54 ^ __security_cookie;
  v45 = (unsigned int)&v54 ^ __security_cookie;
  v4 = a3;
  v46 = a2;
  v50 = 0;
  v53 = 1;
  if ( *(_DWORD *)(this + 12) )
  {
    v51 = (int)"Request is not ready";
    sub_1002AEA4((int)&v47, &v51);
    v47 = &off_100602F0;
    sub_100355DB((int)&v47, (int)&unk_1006D7B8);
  }
  v44 = (int)&v51;
  v43 = a2;
  v51 = this;
  v42 = 7;
  v41 = 0;
  v37 = 0;
  loc_10009CC0(v4, 0, -1, this);
  if ( a4 )
  {
    _EAX = a4 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v14 = sub_10005660((int)&v48, *(int *)&v37, v38, v39, v40, v41, v42, a4, v43);
  LOBYTE(v53) = 2;
  sub_10005880(v15, v14, a2, v44, v45);
  LOBYTE(v53) = 1;
  v13 = v49;
  _EDI = -1;
  v50 = 1;
  if ( v49 )
  {
    _EAX = v49 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v13)(v13);
      _EAX = v13 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v13 + 4))(v13, _EDX);
    }
  }
  LOBYTE(v53) = 0;
  if ( a4 )
  {
    _EAX = a4 + 4;
    __asm { lock xadd [eax], edi }
    if ( _EDI == 1 )
      (*(void (**)(void))(*(_DWORD *)a4 + 4))();
  }
  return a2;
}
// 100602F0: using guessed type int (__stdcall *off_100602F0)(char);
// 10074200: using guessed type int __security_cookie;

//----- (100045A0) --------------------------------------------------------
int __thiscall sub_100045A0(void *this, int a2)
{
  int v2; // edx@1
  void *v3; // esi@1
  int v4; // ecx@1
  int v12; // eax@3
  int v13; // ecx@4
  int v14; // edi@5
  char v30; // [sp-8h] [bp-2Ch]@1
  int v31; // [sp-4h] [bp-28h]@3
  char v32; // [sp+10h] [bp-14h]@3
  int v33; // [sp+14h] [bp-10h]@5
  int v34; // [sp+1Ch] [bp-8h]@1

  v3 = this;
  v4 = *(_DWORD *)this;
  v34 = 0;
  sub_100288F0(v4, (int)((char *)v3 + 4));
  sub_10004DE0((int)&v30, *(_DWORD *)v3 + 84);
  v2 = *((_DWORD *)v3 + 7);
  if ( v2 )
  {
    _EAX = v2 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v12 = sub_10005540((int)&v32, v2, v30, v31);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  if ( a2 != v12 )
  {
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(v12 + 4);
    *(_DWORD *)(v12 + 4) = 0;
    v13 = *(_DWORD *)a2;
    *(_DWORD *)a2 = *(_DWORD *)v12;
    *(_DWORD *)v12 = v13;
  }
  v14 = v33;
  if ( v33 )
  {
    _EBX = -1;
    _ECX = v33 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v14)(v14);
      _EDX = v14 + 8;
      __asm { lock xadd [edx], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v14 + 4))(v14);
    }
  }
  return a2;
}

//----- (10004650) --------------------------------------------------------
int __thiscall sub_10004650(void *this, int a2, int a3, int a4)
{
  int v4; // eax@1
  int ebp0; // ebp@0
  int v6; // edi@1
  void *v7; // eax@3
  int v8; // edi@9

  v6 = *(_DWORD *)this;
  v4 = *(_DWORD *)(*(_DWORD *)this + 12);
  if ( v4 == 1 || v4 == 2 )
  {
    v7 = *(void **)(v6 + 4);
    *(_DWORD *)(v6 + 12) = 3;
    if ( v7 )
    {
      WinHttpCloseHandle(v7);
      sub_1002C6B5(ebp0, (int)WinHttpCloseHandle, v6, 1000);
      *(_DWORD *)(v6 + 4) = 0;
    }
    if ( *(_DWORD *)(v6 + 8) )
    {
      WinHttpCloseHandle(*(HINTERNET *)(v6 + 8));
      *(_DWORD *)(v6 + 8) = 0;
    }
    *(_DWORD *)(v6 + 12) = 4;
  }
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  if ( (int *)a2 == &a3 )
  {
    v8 = a4;
  }
  else
  {
    *(_DWORD *)(a2 + 4) = a4;
    v8 = 0;
    a4 = 0;
    *(_DWORD *)a2 = a3;
    a3 = 0;
  }
  if ( v8 )
  {
    _EBX = -1;
    _ECX = v8 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v8)(v8);
      _EDX = v8 + 8;
      __asm { lock xadd [edx], ebx }
      if ( _EBX == 1 )
        (*(void (**)(void))(*(_DWORD *)v8 + 4))();
    }
  }
  return a2;
}

//----- (10004750) --------------------------------------------------------
int __usercall sub_10004750<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, char a4)
{
  int v5; // esi@1
  int v6; // [sp+8h] [bp-14h]@1
  unsigned int v7; // [sp+Ch] [bp-10h]@1
  int v8; // [sp+18h] [bp-4h]@1
  int v9; // [sp+1Ch] [bp+0h]@1

  v7 = (unsigned int)&v9 ^ __security_cookie;
  v6 = a1;
  v5 = a2;
  v8 = 0;
  sub_10009300((int)&a4, a2, a3, (int)&v6);
  v8 = -1;
  sub_1002FDDA((int)&a4);
  return v5;
}
// 10074200: using guessed type int __security_cookie;

//----- (100047D0) --------------------------------------------------------
int __userpurge sub_100047D0<eax>(int a1<ecx>, int a2<edi>, int a3)
{
  int v3; // ebx@1
  LPVOID *v4; // edi@1
  int v5; // esi@1
  int v6; // edx@1
  void *v8; // [sp+10h] [bp-50h]@1
  unsigned int v9; // [sp+24h] [bp-3Ch]@5
  int v10; // [sp+28h] [bp-38h]@1
  int (__stdcall **v11)(char); // [sp+2Ch] [bp-34h]@1
  void *v12; // [sp+30h] [bp-30h]@1
  int v13; // [sp+40h] [bp-20h]@1
  unsigned int v14; // [sp+44h] [bp-1Ch]@1
  char v15; // [sp+48h] [bp-18h]@1
  unsigned int v16; // [sp+4Ch] [bp-14h]@1
  int v17; // [sp+5Ch] [bp-4h]@1
  int v18; // [sp+60h] [bp+0h]@1

  v16 = (unsigned int)&v18 ^ __security_cookie;
  v3 = a1;
  v10 = a1;
  *(_DWORD *)a1 = &off_10069454;
  *(_DWORD *)(a1 + 12) = 0;
  sub_1002C08C(a1 + 16);
  *(_DWORD *)(v3 + 76) = 15;
  *(_DWORD *)(v3 + 72) = 0;
  *(_BYTE *)(v3 + 56) = 0;
  *(_DWORD *)v3 = &off_100680C4;
  sub_100058D0(v6, v3 + 84, v3, a2);
  v17 = 1;
  v4 = (LPVOID *)(v3 + 92);
  *(_DWORD *)v3 = &off_100680F8;
  *(_DWORD *)(v3 + 112) = 15;
  *(_DWORD *)(v3 + 108) = 0;
  *(_BYTE *)(v3 + 92) = 0;
  v11 = &off_100680F0;
  v14 = 15;
  v13 = 0;
  LOBYTE(v12) = 0;
  v15 = 0;
  LOBYTE(v17) = 3;
  v5 = sub_10011B00(&v11, (int)&v8, a3);
  if ( v3 + 92 != v5 )
  {
    if ( *(_DWORD *)(v3 + 112) >= 0x10u )
      sub_1002A4AA(*v4);
    *(_DWORD *)(v3 + 112) = 15;
    *(_DWORD *)(v3 + 108) = 0;
    *(_BYTE *)v4 = 0;
    sub_100017B0((void *)(v3 + 92), v5);
  }
  if ( v9 >= 0x10 )
    sub_1002A4AA(v8);
  v11 = &off_100680F0;
  if ( v14 >= 0x10 )
    sub_1002A4AA(v12);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100680C4: using guessed type int (__stdcall *off_100680C4)(char);
// 100680F0: using guessed type int (__stdcall *off_100680F0)(char);
// 100680F8: using guessed type int (__stdcall *off_100680F8)(char);
// 10069454: using guessed type int (__stdcall *off_10069454)(char);
// 10074200: using guessed type int __security_cookie;

//----- (10004910) --------------------------------------------------------
void __thiscall sub_10004910(int this, LPCWSTR pwszObjectName)
{
  int v2; // edi@1
  const WCHAR *v3; // esi@1
  const WCHAR *v4; // eax@5
  DWORD v5; // eax@7
  DWORD v6; // eax@10
  char v7; // [sp+Ch] [bp-48h]@1
  int (__stdcall **v8)(char); // [sp+10h] [bp-44h]@2
  int v9; // [sp+24h] [bp-30h]@2
  LPCWSTR pwszVerb; // [sp+28h] [bp-2Ch]@3
  int v11; // [sp+38h] [bp-1Ch]@3
  unsigned int v12; // [sp+3Ch] [bp-18h]@3
  unsigned int v13; // [sp+40h] [bp-14h]@1
  int v14; // [sp+50h] [bp-4h]@3

  v13 = (unsigned int)&v7 ^ __security_cookie;
  v2 = this;
  v3 = pwszObjectName;
  if ( !*(_DWORD *)(this + 8) )
  {
    v9 = (int)"Invalid connection";
    sub_1002AEA4((int)&v8, &v9);
    v8 = &off_100602F0;
    sub_100355DB((int)&v8, (int)&unk_1006D7B8);
  }
  v12 = 7;
  v11 = 0;
  LOWORD(pwszVerb) = 0;
  v14 = 0;
  loc_10028430(&pwszVerb, L"POST", 4);
  if ( *((_DWORD *)pwszObjectName + 5) >= 8u )
    v3 = *(const WCHAR **)pwszObjectName;
  v4 = (const WCHAR *)&pwszVerb;
  if ( v12 >= 8 )
    v4 = pwszVerb;
  v5 = (DWORD)WinHttpOpenRequest(*(HINTERNET *)(v2 + 8), v4, v3, 0, 0, 0, 0);
  *(_DWORD *)(v2 + 4) = v5;
  if ( !v5 )
  {
    v5 = GetLastError();
    sub_10028530(&v8, 9, v5);
    sub_100355DB((int)&v8, (int)&unk_1006DA88);
  }
  if ( WinHttpSetStatusCallback((HINTERNET)v5, (WINHTTP_STATUS_CALLBACK)fnInternetCallback, 0xFFFFFFFFu, 0) == (WINHTTP_STATUS_CALLBACK)-1 )
  {
    v6 = GetLastError();
    sub_10028530(&v8, 10, v6);
    sub_100355DB((int)&v8, (int)&unk_1006DA88);
  }
  if ( v12 >= 8 )
    sub_1002A4AA((LPVOID)pwszVerb);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100602F0: using guessed type int (__stdcall *off_100602F0)(char);
// 10069440: using guessed type wchar_t aPost[5];
// 10074200: using guessed type int __security_cookie;

//----- (10004A70) --------------------------------------------------------
void __thiscall sub_10004A70(DWORD_PTR this)
{
  void *v1; // eax@1

  v1 = (void *)(this + 92);
  if ( *(_DWORD *)(this + 112) >= 0x10u )
    v1 = *(void **)v1;
  sub_10028EB0(this, v1, *(_DWORD *)(this + 108), *(_DWORD *)(this + 108), L"Content-Type: application/json");
}

//----- (10004A90) --------------------------------------------------------
int __thiscall sub_10004A90(int this, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // esi@1

  v7 = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_BYTE *)(this + 25) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = &off_100680E0;
  sub_10004DE0(this + 32, a3);
  *(_DWORD *)(v7 + 4) = sub_100058C0;
  *(_BYTE *)(v7 + 16) = 1;
  *(_DWORD *)v7 = &off_100680E8;
  sub_10004DE0(v7 + 40, a2);
  *(_DWORD *)(v7 + 48) = *(_DWORD *)a4;
  *(_BYTE *)(v7 + 25) = 1;
  *(_DWORD *)(v7 + 28) = 0;
  return v7;
}
// 100680E0: using guessed type int (__stdcall *off_100680E0)(char);
// 100680E8: using guessed type int (__stdcall *off_100680E8)(char);

//----- (10004B00) --------------------------------------------------------
int __thiscall sub_10004B00(int this)
{
  int v2; // edi@1
  int v3; // esi@1
  int result; // eax@2
  int v17; // edi@5

  v3 = this;
  *(_DWORD *)this = &off_100680E8;
  v2 = *(_DWORD *)(this + 44);
  _EBX = -1;
  if ( v2 )
  {
    result = v2 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v2)(v2);
      result = v2 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v2 + 4))(v2, _EDX);
    }
  }
  *(_DWORD *)v3 = &off_100680E0;
  v17 = *(_DWORD *)(v3 + 36);
  if ( v17 )
  {
    result = v17 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v17)(v17);
      result = v17 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v17 + 4))(v17);
    }
  }
  *(_DWORD *)v3 = &off_10061E90;
  return result;
}
// 10061E90: using guessed type int (__stdcall *off_10061E90)(char);
// 100680E0: using guessed type int (__stdcall *off_100680E0)(char);
// 100680E8: using guessed type int (__stdcall *off_100680E8)(char);

//----- (10004B80) --------------------------------------------------------
int __thiscall sub_10004B80(int this, int a2)
{
  sub_100076D0(a2, this + 32, this);
  return a2;
}

//----- (10004BA0) --------------------------------------------------------
int __thiscall sub_10004BA0(int this)
{
  int v1; // ecx@1
  int v2; // esi@1
  int result; // eax@6

  v2 = this;
  v1 = *(_DWORD *)(this + 28);
  if ( v1 )
  {
    _EAX = v1 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v1 + 4))();
  }
  *(_DWORD *)(v2 + 28) = 0;
  if ( *(_DWORD *)(v2 + 24) >= 8u )
    sub_1002A4AA(*(LPVOID *)(v2 + 4));
  result = 0;
  *(_DWORD *)(v2 + 24) = 7;
  *(_DWORD *)(v2 + 20) = 0;
  *(_WORD *)(v2 + 4) = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10004C30) --------------------------------------------------------
void *__userpurge sub_10004C30<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_10004D30(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10004CA0) --------------------------------------------------------
int __userpurge sub_10004CA0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  int v4; // esi@1

  v4 = a1;
  sub_10004B00(a1);
  if ( a4 & 1 )
    sub_1002CC50(a2, a3, v4);
  return v4;
}

//----- (10004CD0) --------------------------------------------------------
int __userpurge sub_10004CD0<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int v20; // [sp-4h] [bp-Ch]@2

  v4 = a1;
  *(_DWORD *)a1 = &off_100680E0;
  v3 = *(_DWORD *)(a1 + 36);
  if ( v3 )
  {
    v20 = a2;
    _EBX = -1;
    _EDX = v3 + 4;
    _EAX = -1;
    __asm { lock xadd [edx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v3)(v3);
      _EAX = v3 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
    }
    a2 = v20;
  }
  *(_DWORD *)v4 = &off_10061E90;
  if ( a3 & 1 )
    sub_1002CC50(a2, v3, v4);
  return v4;
}
// 10061E90: using guessed type int (__stdcall *off_10061E90)(char);
// 100680E0: using guessed type int (__stdcall *off_100680E0)(char);

//----- (10004D30) --------------------------------------------------------
int __usercall sub_10004D30<eax>(int a1<ecx>, int _EBX<ebx>)
{
  int v2; // esi@1
  int v3; // edi@3

  v2 = a1;
  if ( *(_DWORD *)(a1 + 112) >= 0x10u )
    sub_1002A4AA(*(LPVOID *)(a1 + 92));
  *(_DWORD *)(v2 + 112) = 15;
  *(_DWORD *)(v2 + 108) = 0;
  *(_BYTE *)(v2 + 92) = 0;
  v3 = *(_DWORD *)(v2 + 88);
  if ( v3 )
  {
    _EBX = -1;
    _ECX = v3 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v3)(v3);
      _EAX = v3 + 8;
      __asm { lock xadd [eax], ebx }
      _EBX = _EBX - 1;
      if ( !_EBX )
        (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
    }
  }
  return sub_10028820(v2, _EBX, v3);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10004DE0) --------------------------------------------------------
int __thiscall sub_10004DE0(int this, int a2)
{
  int v2; // ebx@1
  int v3; // esi@1
  int v11; // edi@3
  int v27; // [sp+14h] [bp+8h]@1

  v3 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  v2 = *(_DWORD *)(a2 + 4);
  v27 = *(_DWORD *)a2;
  if ( v2 )
  {
    _EAX = v2 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v11 = *(_DWORD *)(v3 + 4);
  if ( v11 )
  {
    _ECX = v11 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v11)(v11);
      _EAX = v11 + 8;
      _ECX = -1;
      __asm { lock xadd [eax], ecx }
      if ( _ZF )
        (*(void (__thiscall **)(int))(*(_DWORD *)v11 + 4))(v11);
    }
  }
  *(_DWORD *)v3 = v27;
  *(_DWORD *)(v3 + 4) = v2;
  return v3;
}

//----- (10004E50) --------------------------------------------------------
int __userpurge sub_10004E50<eax>(int a1<ecx>, int _EBX<ebx>, char a3)
{
  int v3; // edi@1
  int v4; // esi@1

  v4 = a1;
  v3 = *(_DWORD *)(a1 + 88);
  if ( v3 )
  {
    _EBX = -1;
    _ECX = v3 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v3)(v3);
      _EAX = v3 + 8;
      __asm { lock xadd [eax], ebx }
      _EBX = _EBX - 1;
      if ( !_EBX )
        (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
    }
  }
  sub_10028820(v4, _EBX, v3);
  if ( a3 & 1 )
    sub_1002A4AA((LPVOID)v4);
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10004EF0) --------------------------------------------------------
int __thiscall sub_10004EF0(int this, int a2, int a3, int a4, int a5)
{
  int result; // eax@1
  unsigned int v6; // ebx@1
  int v7; // esi@1
  int v8; // edi@2
  int v9; // ecx@3
  int v10; // eax@5
  int v11; // edx@5
  int v12; // ecx@5
  int v13; // edi@5
  int v14; // ebx@9
  int v15; // ecx@9
  int v16; // eax@9
  int v17; // eax@9
  int v18; // edx@9
  int v19; // eax@11
  int v20; // edx@12
  char v21; // [sp+0h] [bp-38h]@1
  int v22; // [sp+14h] [bp-24h]@5
  int v23; // [sp+18h] [bp-20h]@1
  int v24; // [sp+1Ch] [bp-1Ch]@1
  int v25; // [sp+20h] [bp-18h]@9
  int v26; // [sp+24h] [bp-14h]@5
  char *v27; // [sp+28h] [bp-10h]@1
  int v28; // [sp+34h] [bp-4h]@9

  v27 = &v21;
  v7 = this;
  v23 = a3;
  result = 715827883 * (a4 - a3);
  v24 = a4;
  v6 = (a4 - a3) / 48;
  if ( v6 )
  {
    v8 = *(_DWORD *)(this + 4);
    if ( (*(_DWORD *)(this + 8) - v8) / 48 >= v6 )
    {
      sub_10007E90(v23, v24, v8);
      v20 = *(_DWORD *)(v7 + 4);
      result = 48 * v6 + v20;
      if ( a2 != v20 )
      {
        if ( v20 != result )
          result = sub_10007F60(a2, v20, 48 * v6 + v20);
      }
      *(_DWORD *)(v7 + 4) += 48 * v6;
    }
    else
    {
      v9 = (v8 - *(_DWORD *)this) / 48;
      if ( 89478485 - v9 < v6 )
        sub_10029585((int)"vector<T> too long");
      v10 = sub_10003490(v7, v9 + v6);
      v13 = 0;
      v26 = v10;
      v22 = 0;
      if ( v10 )
      {
        if ( (unsigned int)v10 > 0x5555555 || (v13 = sub_1002ADB1(v11, v12, v6, 0, 48 * v10), v22 = v13, !v13) )
          sub_10029530();
      }
      v28 = 0;
      v15 = *(_DWORD *)v7;
      v25 = v13;
      v16 = sub_10005410(v15, a2, v13);
      v25 = v16;
      v17 = sub_10007E90(v23, v24, v16);
      v18 = *(_DWORD *)(v7 + 4);
      v25 = v17;
      sub_10005410(a2, v18, v17);
      v14 = (*(_DWORD *)(v7 + 4) - *(_DWORD *)v7) / 48 + v6;
      if ( *(_DWORD *)v7 )
      {
        sub_10004310(*(_DWORD *)v7, *(_DWORD *)(v7 + 4));
        sub_1002A4AA(*(LPVOID *)v7);
      }
      v19 = v26;
      *(_DWORD *)v7 = v13;
      *(_DWORD *)(v7 + 8) = v13 + 48 * v19;
      result = v13 + 48 * v14;
      *(_DWORD *)(v7 + 4) = result;
    }
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100050F0) --------------------------------------------------------
int __userpurge sub_100050F0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5)
{
  int result; // eax@1
  int v6; // ST08_4@1
  int v7; // ST0C_4@1
  int v8; // ST10_4@1
  int v9; // ST14_4@1
  void *v10; // [sp+Ch] [bp+4h]@1

  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_10006190(a1, a2, a3, a4, a5, v6, v7, v8, v9);
  result = a4;
  *(_DWORD *)(*(_DWORD *)a4 + 148) = v10;
  return result;
}

//----- (10005130) --------------------------------------------------------
int __fastcall sub_10005130(int a1, int a2, signed int a3, int a4)
{
  int result; // eax@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // esi@1
  signed int v8; // esi@2
  int v9; // eax@4
  int v10; // ecx@4
  int v11; // esi@4
  int v12; // eax@4
  unsigned __int8 v13; // sf@4
  unsigned __int8 v14; // of@4
  char v15; // [sp+Ch] [bp-14h]@4
  int v16; // [sp+14h] [bp-Ch]@4
  int v17; // [sp+18h] [bp-8h]@4
  int v18; // [sp+1Ch] [bp-4h]@1
  int v19; // [sp+28h] [bp+8h]@4

  v7 = a4;
  v5 = a2;
  v6 = a1;
  result = (a2 - a1) / 48;
  v18 = a4;
  if ( result <= 32 )
  {
LABEL_9:
    if ( result > 1 )
    {
      if ( v6 != v5 )
        result = sub_10007420(v6, v5, v7);
    }
  }
  else
  {
    v8 = a3;
    while ( v8 > 0 )
    {
      v9 = sub_10006270((int)&v15, v6, v5, (int (__cdecl *)(_DWORD, _DWORD))v18);
      v10 = *(_DWORD *)v9;
      v17 = *(_DWORD *)(v9 + 4);
      v16 = v10;
      v19 = v8 / 2 / 2 + v8 / 2;
      v11 = (v10 - v6) / 48;
      v12 = (v5 - v17) / 48;
      v14 = __SETO__(v11, v12);
      v13 = v11 - v12 < 0;
      v8 = v19;
      if ( v13 ^ v14 )
      {
        sub_10005130(v19, v18);
        v6 = v17;
      }
      else
      {
        sub_10005130(v19, v18);
        v5 = v16;
      }
      result = (v5 - v6) / 48;
      if ( result <= 32 )
        goto LABEL_8;
    }
    if ( result <= 32 )
    {
LABEL_8:
      v7 = v18;
      goto LABEL_9;
    }
    if ( (v5 - v6) / 48 > 1 )
      sub_100072E0(v6, v5, (int (__cdecl *)(_DWORD, _DWORD))v18);
    result = sub_10006900(v6, v5, (int (__cdecl *)(_DWORD, _DWORD))v18);
  }
  return result;
}

//----- (10005280) --------------------------------------------------------
int __fastcall sub_10005280(int a1, int a2, int a3, int a4, int a5, int a6, int (__cdecl *a7)(_DWORD, _DWORD))
{
  int (__cdecl *v7)(_DWORD, _DWORD); // edx@1
  int v8; // ecx@1
  int v9; // ebx@1
  int v10; // edi@1
  int v11; // esi@1
  int v12; // ebx@13
  int v13; // edi@13
  int v14; // ecx@19
  int v15; // ebx@19
  int v16; // edi@19
  int result; // eax@23
  int v18; // [sp+10h] [bp-10h]@2
  int v19; // [sp+14h] [bp-Ch]@1
  int v20; // [sp+18h] [bp-8h]@2
  int v21; // [sp+1Ch] [bp-4h]@1
  int v22; // [sp+1Ch] [bp-4h]@19

  v9 = a4;
  v11 = a6;
  v10 = a2;
  v7 = a7;
  v19 = a1;
  v8 = a3;
  v21 = a4;
  if ( v10 != a3 )
  {
    v20 = v10 + 20;
    v18 = a4 + 20;
    do
    {
      if ( v9 == a5 )
        break;
      if ( (unsigned __int8)v7(v9, v10) )
      {
        *(_DWORD *)a6 = *(_DWORD *)v9;
        *(_DWORD *)(a6 + 4) = *(_DWORD *)(v9 + 4);
        *(_DWORD *)(a6 + 8) = *(_DWORD *)(v18 - 12);
        *(_DWORD *)(a6 + 12) = *(_DWORD *)(v18 - 8);
        *(_DWORD *)(a6 + 16) = *(_DWORD *)(v18 - 4);
        if ( a6 + 20 != v18 )
          loc_1000AB40(v18, 0, -1);
        v9 += 48;
        v21 = v9;
        v18 += 48;
      }
      else
      {
        *(_DWORD *)a6 = *(_DWORD *)v10;
        *(_DWORD *)(a6 + 4) = *(_DWORD *)(v10 + 4);
        *(_DWORD *)(a6 + 8) = *(_DWORD *)(v20 - 12);
        *(_DWORD *)(a6 + 12) = *(_DWORD *)(v20 - 8);
        *(_DWORD *)(a6 + 16) = *(_DWORD *)(v20 - 4);
        if ( a6 + 20 != v20 )
          loc_1000AB40(v20, 0, -1);
        v10 += 48;
        v20 += 48;
      }
      v8 = a3;
      v7 = a7;
      v11 = a6 + 48;
      a6 += 48;
    }
    while ( v10 != a3 );
    if ( v10 != v8 )
    {
      v12 = v11 + 20;
      v13 = v10 + 20;
      do
      {
        *(_DWORD *)v11 = *(_DWORD *)(v13 - 20);
        *(_DWORD *)(v11 + 4) = *(_DWORD *)(v13 - 16);
        *(_DWORD *)(v12 - 12) = *(_DWORD *)(v13 - 12);
        *(_DWORD *)(v12 - 8) = *(_DWORD *)(v13 - 8);
        *(_DWORD *)(v12 - 4) = *(_DWORD *)(v13 - 4);
        if ( v12 != v13 )
        {
          loc_1000AB40(v12, v13, 0, -1);
          v8 = a3;
        }
        v13 += 48;
        v11 += 48;
        v12 += 48;
      }
      while ( v13 - 20 != v8 );
      v9 = v21;
    }
  }
  if ( v9 != a5 )
  {
    v14 = v21 - v11;
    v16 = v9 + 20;
    v15 = v11 + 8;
    v22 = v21 - v11;
    do
    {
      *(_DWORD *)v11 = *(_DWORD *)(v16 - 20);
      *(_DWORD *)(v11 + 4) = *(_DWORD *)(v16 - 16);
      *(_DWORD *)v15 = *(_DWORD *)(v14 + v15);
      *(_DWORD *)(v15 + 4) = *(_DWORD *)(v14 + v15 + 4);
      *(_DWORD *)(v15 + 8) = *(_DWORD *)(v16 - 4);
      if ( v15 + 12 != v16 )
        loc_1000AB40(v15 + 12, v16, 0, -1);
      v16 += 48;
      v11 += 48;
      v15 += 48;
      v14 = v22;
    }
    while ( v16 - 20 != a5 );
  }
  result = v19;
  *(_DWORD *)v19 = v11;
  return result;
}

//----- (10005410) --------------------------------------------------------
int __fastcall sub_10005410(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@2
  int result; // eax@6

  v3 = a2;
  v4 = a1;
  if ( a1 == a2 )
  {
    result = a3;
  }
  else
  {
    v5 = a3;
    do
    {
      if ( v5 )
        sub_100016C0(v5, v4);
      v4 += 48;
      v5 += 48;
    }
    while ( v4 != v3 );
    result = v5;
  }
  return result;
}

//----- (10005450) --------------------------------------------------------
int __stdcall sub_10005450(int a1)
{
  int result; // eax@2

  if ( *(_DWORD *)(a1 + 40) >= 0x10u )
    result = sub_1002A4AA(*(LPVOID *)(a1 + 20));
  *(_DWORD *)(a1 + 40) = 15;
  *(_DWORD *)(a1 + 36) = 0;
  *(_BYTE *)(a1 + 20) = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10005480) --------------------------------------------------------
int __fastcall sub_10005480(int a1, int a2, int a3)
{
  int v3; // ebx@2
  int v4; // edi@2
  int v5; // esi@2
  int result; // eax@6
  int v7; // [sp+0h] [bp-4h]@1

  v7 = a2;
  if ( a1 == a2 )
  {
    result = a3;
  }
  else
  {
    v3 = a3;
    v4 = a3 + 20;
    v5 = a1 + 20;
    do
    {
      *(_DWORD *)v3 = *(_DWORD *)(v5 - 20);
      *(_DWORD *)(v3 + 4) = *(_DWORD *)(v5 - 16);
      *(_DWORD *)(v4 - 12) = *(_DWORD *)(v5 - 12);
      *(_DWORD *)(v4 - 8) = *(_DWORD *)(v5 - 8);
      *(_DWORD *)(v4 - 4) = *(_DWORD *)(v5 - 4);
      if ( v4 != v5 )
        loc_1000AB40(v4, v5, 0, -1);
      v5 += 48;
      v3 += 48;
      v4 += 48;
    }
    while ( v5 - 20 != v7 );
    result = v3;
  }
  return result;
}

//----- (100054F0) --------------------------------------------------------
void __fastcall sub_100054F0(int a1, int a2)
{
  int v2; // eax@2

  if ( a2 )
  {
    v2 = a1 + 36;
    do
    {
      if ( v2 != 36 )
      {
        *(_DWORD *)(v2 - 36) = 0;
        *(_DWORD *)(v2 - 32) = 0;
        *(_DWORD *)(v2 - 28) = 0;
        *(_DWORD *)(v2 - 24) = 0;
        *(_DWORD *)(v2 + 4) = 15;
        *(_DWORD *)v2 = 0;
        *(_BYTE *)(v2 - 16) = 0;
      }
      v2 += 48;
      --a2;
    }
    while ( a2 );
  }
}

//----- (10005540) --------------------------------------------------------
int __thiscall sub_10005540(int this, int a2, char a3, int a4)
{
  int v5; // edi@1
  int v6; // esi@1
  int v21; // eax@5
  int v22; // edi@7
  int v23; // eax@7
  char v45; // [sp-Ch] [bp-40h]@7
  int v46; // [sp-8h] [bp-3Ch]@7
  int v47; // [sp-4h] [bp-38h]@7
  int v48; // [sp+14h] [bp-20h]@1
  char v49; // [sp+18h] [bp-1Ch]@1
  int v50; // [sp+1Ch] [bp-18h]@1
  int v51; // [sp+30h] [bp-4h]@1
  void *v52; // [sp+38h] [bp+4h]@7

  v6 = this;
  v48 = this;
  v51 = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  LOBYTE(v51) = 2;
  sub_10004DE0((int)&v49, (int)&a3);
  v5 = v50;
  _EBX = -1;
  if ( v50 )
  {
    _EAX = v50 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      _EAX = v5 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v5 + 4))(v5, _EDX);
    }
  }
  v21 = a2;
  if ( !a2 )
    v21 = 2;
  sub_10005980(v6, v21);
  v23 = *(_DWORD *)v6;
  v47 = 0;
  *(_DWORD *)(v23 + 148) = v52;
  sub_10004DE0((int)&v45, (int)&a3);
  sub_10006970(*(int *)&v45, v46);
  sub_10006EE0((int *)&a3, -1, v6);
  LOBYTE(v51) = 0;
  v22 = a4;
  if ( a4 )
  {
    _EAX = a4 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v22)(v22);
      _EAX = v22 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v22 + 4))(v22, _EDX);
    }
  }
  v51 = -1;
  if ( a2 )
  {
    _EDX = a2 + 4;
    __asm { lock xadd [edx], ebx }
    if ( _EBX == 1 )
      (*(void (**)(void))(*(_DWORD *)a2 + 4))();
  }
  return v6;
}

//----- (10005660) --------------------------------------------------------
int __thiscall sub_10005660(int this, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  int v10; // esi@1
  int v26; // eax@8
  void *v27; // eax@8
  int v28; // ecx@10
  int v36; // ecx@13
  int v51; // eax@20
  int v52; // eax@20
  int v53; // eax@21
  int v54; // ecx@23
  void *v62; // [sp+1Ch] [bp-54h]@1
  int v63; // [sp+2Ch] [bp-44h]@1
  unsigned int v64; // [sp+30h] [bp-40h]@1
  int v65; // [sp+34h] [bp-3Ch]@3
  int v66; // [sp+38h] [bp-38h]@13
  void *v67; // [sp+3Ch] [bp-34h]@13
  int v68; // [sp+4Ch] [bp-24h]@13
  unsigned int v69; // [sp+50h] [bp-20h]@13
  int v70; // [sp+54h] [bp-1Ch]@15
  int v71; // [sp+5Ch] [bp-14h]@8
  int v72; // [sp+60h] [bp-10h]@20
  int v73; // [sp+6Ch] [bp-4h]@1
  void *v74; // [sp+74h] [bp+4h]@13

  v10 = this;
  v73 = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  LOBYTE(v73) = 1;
  LOWORD(v62) = 0;
  v64 = 7;
  v63 = 0;
  loc_10009CC0(&v62, &a3, 0, -1);
  v9 = a9;
  if ( a9 )
  {
    _EAX = a9 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v65 = v9;
  _EBX = -1;
  LOBYTE(v73) = 2;
  if ( v9 )
  {
    _EAX = v9 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (__thiscall **)(int))(*(_DWORD *)v9 + 4))(v9);
  }
  v65 = 0;
  if ( v64 >= 8 )
    sub_1002A4AA(v62);
  v27 = sub_100099D0(&v71);
  LOBYTE(v73) = 3;
  v26 = *(_DWORD *)v27;
  if ( !v26 )
    v26 = 2;
  sub_10005980(v10, v26);
  LOBYTE(v73) = 1;
  v28 = v71;
  if ( v71 )
  {
    _EAX = v71 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v28 + 4))();
  }
  *(_DWORD *)(*(_DWORD *)v10 + 148) = v74;
  v66 = a2;
  LOWORD(v67) = 0;
  v69 = 7;
  v68 = 0;
  loc_10009CC0(&v67, &a3, 0, -1);
  v36 = a9;
  if ( a9 )
  {
    _EAX = a9 + 4;
    _EDX = 1;
    __asm { lock xadd [eax], edx }
  }
  v70 = v36;
  LOBYTE(v73) = 4;
  if ( v36 )
  {
    _EAX = v36 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v36 + 4))();
  }
  LOBYTE(v73) = 1;
  v70 = 0;
  if ( v69 >= 8 )
    sub_1002A4AA(v67);
  LOWORD(v67) = 0;
  v52 = *(_DWORD *)v10;
  v69 = 7;
  v68 = 0;
  *(_BYTE *)(v52 + 88) = 0;
  *(_BYTE *)(*(_DWORD *)v10 + 90) = 1;
  v51 = sub_1002CB8B(-1, v9, 0x3Cu);
  v72 = v51;
  LOBYTE(v73) = 5;
  if ( v51 )
    v53 = sub_10007940(v51, v10, (int)&a2);
  else
    v53 = 0;
  LOBYTE(v73) = 1;
  sub_1000A5C0(*(_DWORD *)v10, -1, v9, v53, 0);
  v73 = 6;
  v54 = a9;
  if ( a9 )
  {
    _EAX = a9 + 4;
    __asm { lock xadd [eax], ebx }
    if ( _EBX == 1 )
      (*(void (**)(void))(*(_DWORD *)v54 + 4))();
  }
  a9 = 0;
  if ( a8 >= 8 )
    sub_1002A4AA(a3);
  return v10;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10005880) --------------------------------------------------------
int __userpurge sub_10005880<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5)
{
  int result; // eax@1
  int v6; // ST08_4@1
  int v7; // ST0C_4@1
  int v8; // ST10_4@1
  int v9; // ST14_4@1
  void *v10; // [sp+Ch] [bp+4h]@1

  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_100069B0(a1, a2, a3, a4, a5, v6, v7, v8, v9);
  result = a4;
  *(_DWORD *)(*(_DWORD *)a4 + 148) = v10;
  return result;
}

//----- (100058C0) --------------------------------------------------------
void __cdecl sub_100058C0(int a2)
{
  sub_10005A40(a2);
}

//----- (100058D0) --------------------------------------------------------
int __usercall sub_100058D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // esi@1
  int v6; // eax@2

  v5 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a4, 96);
  if ( v4 )
    v6 = sub_10005B40(v4);
  else
    v6 = 0;
  *(_DWORD *)(v5 + 4) = v6;
  *(_DWORD *)v5 = v6 + 16;
  return v5;
}

//----- (10005980) --------------------------------------------------------
int __thiscall sub_10005980(int this, int a2)
{
  int result; // eax@1
  int v4; // ecx@1
  int v5; // ebx@1
  int v7; // esi@3
  int v19; // esi@7
  int v31; // esi@12
  char v32; // [sp+10h] [bp-14h]@1
  char v33; // [sp+18h] [bp-Ch]@1
  int v34; // [sp+1Ch] [bp-8h]@7

  v5 = this;
  result = sub_10005DA0(a2, (int)&v33, this);
  v4 = 0;
  _EDX = 0;
  if ( &v32 != (char *)result )
  {
    _EDX = *(_DWORD *)(result + 4);
    *(_DWORD *)(result + 4) = 0;
    v4 = *(_DWORD *)result;
    *(_DWORD *)result = 0;
  }
  v7 = *(_DWORD *)(v5 + 4);
  _EDI = -1;
  *(_DWORD *)(v5 + 4) = _EDX;
  *(_DWORD *)v5 = v4;
  if ( v7 )
  {
    result = v7 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v7)(v7);
      result = v7 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v7 + 4))(v7, _EDX);
    }
  }
  v19 = v34;
  if ( v34 )
  {
    result = v34 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v19)(v19);
      result = v19 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v19 + 4))(v19);
    }
  }
  if ( a2 != 2 )
  {
    v31 = *(_DWORD *)v5;
    result = sub_1002B396(_EDX, *(_DWORD *)(*(_DWORD *)v5 + 136), v5, (int)sub_100097E0, *(_DWORD *)v5, 1);
    *(_DWORD *)(v31 + 140) = result;
  }
  return result;
}

//----- (10005A40) --------------------------------------------------------
void __thiscall sub_10005A40(int this)
{
  int ebp0; // ebp@0
  int v2; // edi@1
  int v3; // esi@1
  int v4; // edx@4
  unsigned int v5; // [sp-4h] [bp-54h]@1
  int v6; // [sp+14h] [bp-3Ch]@4
  int v7; // [sp+18h] [bp-38h]@4
  int v8; // [sp+1Ch] [bp-34h]@1
  unsigned int v9; // [sp+3Ch] [bp-14h]@1
  unsigned int *v10; // [sp+40h] [bp-10h]@1
  int v11; // [sp+4Ch] [bp-4h]@1
  int v12; // [sp+50h] [bp+0h]@1

  v9 = (unsigned int)&v12 ^ __security_cookie;
  v5 = (unsigned int)&v12 ^ __security_cookie;
  v10 = &v5;
  v2 = this;
  v3 = *(_DWORD *)(this + 32);
  v8 = this;
  sub_1002B62D(ebp0, v3 + 100);
  v11 = -1;
  if ( *(_DWORD *)(v3 + 84) == 4 )
  {
    sub_1002B6D6();
  }
  else
  {
    *(_DWORD *)(v3 + 84) = 1;
    sub_1002B6D6();
    v11 = 1;
    LOBYTE(v6) = 0;
    LOBYTE(v7) = 0;
    sub_10005DE0(v4, v2, v2, v7, v6);
  }
}
// 10074200: using guessed type int __security_cookie;

//----- (10005B40) --------------------------------------------------------
int __thiscall sub_10005B40(int this)
{
  int v1; // edi@1
  int v2; // esi@1

  v1 = this;
  *(_DWORD *)(this + 4) = 1;
  *(_DWORD *)(this + 8) = 1;
  v2 = this + 16;
  *(_DWORD *)this = off_100680B4;
  if ( this != -16 )
  {
    *(_DWORD *)v2 = 0;
    *(_DWORD *)(this + 20) = 0;
    *(_DWORD *)(this + 24) = 0;
    sub_1002B5CC(this + 28);
    *(_BYTE *)(v2 + 56) = 0;
    *(_DWORD *)(v2 + 56) &= 0xFFFFFEFFu;
    *(_DWORD *)(v2 + 60) = 0;
    *(_DWORD *)(v2 + 64) = 0;
    *(_DWORD *)(v2 + 68) = 0;
    *(_WORD *)(v2 + 72) = 0;
  }
  return v1;
}
// 100680B4: using guessed type int (__stdcall *off_100680B4[4])(int);

//----- (10005BF0) --------------------------------------------------------
int __userpurge sub_10005BF0<eax>(int a1<eax>, int a2<ecx>, int _EBX<ebx>, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@3
  int v20; // eax@7
  void *v21; // esi@9
  int v22; // eax@14
  void *v23; // esi@15
  int result; // eax@16
  char v25; // [sp-18h] [bp-18h]@10
  int v26; // [sp-14h] [bp-14h]@1
  int v27; // [sp-10h] [bp-10h]@1
  int (__cdecl *v28)(int, int); // [sp-Ch] [bp-Ch]@1
  signed int v29; // [sp-8h] [bp-8h]@1

  v28 = sub_1005A779;
  v27 = a1;
  v4 = a2 + 16;
  v26 = a2 + 16;
  v29 = 3;
  v5 = *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 20) )
  {
    do
    {
      (*(void (__stdcall **)(signed int, _DWORD, _DWORD, int))(**(_DWORD **)v5 + 4))(1, 0, 0, *(_DWORD *)v5 + 92);
      v5 += 8;
    }
    while ( v5 != *(_DWORD *)(v4 + 4) );
  }
  LOBYTE(v29) = 2;
  v6 = *(_DWORD *)(v4 + 68);
  if ( v6 )
  {
    _EBX = -1;
    _ECX = v6 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v6)(v6);
      _EAX = v6 + 8;
      __asm { lock xadd [eax], ebx }
      _EBX = _EBX - 1;
      if ( !_EBX )
        (*(void (__thiscall **)(int))(*(_DWORD *)v6 + 4))(v6);
    }
  }
  LOBYTE(v29) = 1;
  v20 = *(_BYTE *)(v4 + 56);
  if ( v20 == 4 )
  {
    if ( *(_DWORD *)(v4 + 56) & 0x100 )
    {
      if ( *(_DWORD *)(v4 + 48) )
        sub_100309A2(_EBX, *(LPVOID *)(v4 + 48));
    }
  }
  else
  {
    if ( (unsigned int)(v20 - 6) <= 1 )
    {
      v21 = *(void **)(v4 + 48);
      if ( v21 )
      {
        sub_100130F0(v21, (int)&v25, **(_DWORD **)v21, *(_DWORD *)v21);
        sub_1002A4AA(*(LPVOID *)v21);
        sub_1002A4AA(v21);
      }
    }
  }
  v22 = *(_DWORD *)(v4 + 60);
  if ( v22 )
  {
    v23 = (void *)(v22 - 4);
    sub_1002B11F(v22, 4, *(_DWORD *)(v22 - 4), (void (__thiscall *)(_DWORD))sub_1000FF60);
    sub_10030383(v23);
  }
  LOBYTE(v29) = 0;
  result = nullsub_2(v4 + 12);
  if ( *(_DWORD *)v4 )
  {
    sub_10004350(*(_DWORD *)v4, *(_DWORD *)(v4 + 4));
    result = sub_1002A4AA(*(LPVOID *)v4);
    *(_DWORD *)v4 = 0;
    *(_DWORD *)(v4 + 4) = 0;
    *(_DWORD *)(v4 + 8) = 0;
  }
  return result;
}
// 1000FF60: using guessed type int sub_1000FF60();
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1002B6E4: using guessed type int __thiscall nullsub_2(_DWORD);
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 1005A779: using guessed type int __cdecl sub_1005A779(int, int);

//----- (10005DA0) --------------------------------------------------------
int __usercall sub_10005DA0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v4; // esi@1
  int v5; // [sp+8h] [bp-8h]@1
  unsigned int v6; // [sp+Ch] [bp-4h]@1
  int v7; // [sp+10h] [bp+0h]@1

  v6 = (unsigned int)&v7 ^ __security_cookie;
  v5 = a1;
  v4 = a2;
  sub_10006A90((int)&v5, a2, a3);
  return v4;
}
// 10074200: using guessed type int __security_cookie;

//----- (10005DE0) --------------------------------------------------------
void __userpurge sub_10005DE0(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // edx@1
  int v6; // ebx@1
  int ebp0; // ebp@0
  int v9; // esi@1
  int v10; // ebx@1
  int v11; // eax@1
  int v26; // ebx@8
  int v27; // eax@9
  int v28; // ebx@11
  int v29; // eax@11
  int v30; // edx@15
  void **v44; // [sp-20h] [bp-94h]@9
  int v45; // [sp-1Ch] [bp-90h]@9
  int v46; // [sp-18h] [bp-8Ch]@11
  int v47; // [sp-14h] [bp-88h]@11
  char v48; // [sp-8h] [bp-7Ch]@6
  int v49; // [sp-4h] [bp-78h]@6
  char v50; // [sp+10h] [bp-64h]@1
  int v51; // [sp+14h] [bp-60h]@1
  int v52; // [sp+18h] [bp-5Ch]@1
  char *v53; // [sp+1Ch] [bp-58h]@1
  int v54; // [sp+20h] [bp-54h]@1
  char v55; // [sp+24h] [bp-50h]@1
  int v56; // [sp+28h] [bp-4Ch]@1
  char v57; // [sp+2Ch] [bp-48h]@11
  int v58; // [sp+3Ch] [bp-38h]@14
  unsigned int v59; // [sp+60h] [bp-14h]@1
  int v60; // [sp+70h] [bp-4h]@1

  v59 = (unsigned int)&v50 ^ __security_cookie;
  v10 = a2;
  v54 = a2;
  v51 = 0;
  v52 = 0;
  sub_10006BC0(a1, (int)&v51, a3, a2);
  v60 = 0;
  v11 = sub_10004DE0((int)&v55, v10 + 40);
  v9 = *(_DWORD *)(v11 + 4);
  *(_DWORD *)(v11 + 4) = v52;
  v5 = *(_DWORD *)v11;
  *(_DWORD *)v11 = v51;
  v6 = v56;
  _EDI = -1;
  v52 = v9;
  v53 = (char *)v5;
  v51 = v5;
  if ( v56 )
  {
    _EAX = v56 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v6)(v6);
      _EAX = v6 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v6 + 4))(v6, _EDX);
      v5 = (int)v53;
    }
  }
  v53 = &v48;
  *(_DWORD *)&v48 = 0;
  v49 = 0;
  if ( (int *)&v48 != &v51 )
  {
    v49 = v9;
    v9 = 0;
    v52 = 0;
    *(_DWORD *)&v48 = v5;
    v51 = 0;
  }
  v26 = v54;
  if ( &v48 )
  {
    v44 = &off_10068038;
    v45 = *(_DWORD *)(v54 + 48);
    v27 = (int)&v44;
  }
  else
  {
    v27 = 0;
  }
  LOBYTE(v60) = 1;
  v29 = sub_10005FD0((int)&v57, (char)v44, v45, v46, v47, v27);
  LOBYTE(v60) = 4;
  v28 = *(_DWORD *)(v26 + 32);
  *(_BYTE *)(v28 + 152) = sub_10006090(v29, v48, v49);
  sub_1002B62D(ebp0, v28 + 100);
  LOBYTE(v60) = 4;
  if ( *(_DWORD *)(v28 + 84) == 4 )
  {
    sub_1002B6D6();
  }
  else
  {
    *(_DWORD *)(v28 + 84) = 3;
    sub_1002B6D6();
    sub_1002C5B4(ebp0);
    sub_1000A690(v28);
  }
  LOBYTE(v60) = 0;
  if ( v58 )
  {
    v30 = *(_DWORD *)v58;
    v49 = v58 != (_DWORD)&v57;
    (*(void (__stdcall **)(int))(v30 + 16))(v49);
    v58 = 0;
  }
  v60 = -1;
  if ( v9 )
  {
    _EAX = v9 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v9)(v9);
      _EAX = v9 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (**)(void))(*(_DWORD *)v9 + 4))();
    }
  }
}
// 10068038: using guessed type void *off_10068038;
// 10074200: using guessed type int __security_cookie;

//----- (10005FD0) --------------------------------------------------------
int __thiscall sub_10005FD0(int this, char a2, int a3, int a4, int a5, int a6)
{
  int v6; // edi@1

  v6 = this;
  sub_10006B10((int)&a2, this, this);
  if ( a6 )
    (*(void (__stdcall **)(bool))(*(_DWORD *)a6 + 16))(a6 != (_DWORD)&a2);
  return v6;
}

//----- (10006050) --------------------------------------------------------
int __thiscall sub_10006050(int this)
{
  int v1; // ecx@1
  int v2; // esi@1
  int result; // eax@2
  int v4; // ecx@3

  v2 = this;
  v1 = *(_DWORD *)(this + 16);
  if ( v1 )
  {
    result = (*(int (__stdcall **)(bool))(*(_DWORD *)v1 + 16))(v1 != v2);
    *(_DWORD *)(v2 + 16) = 0;
  }
  v4 = *(_DWORD *)(v2 + 16);
  if ( v4 )
  {
    result = (*(int (__stdcall **)(bool))(*(_DWORD *)v4 + 16))(v4 != v2);
    *(_DWORD *)(v2 + 16) = 0;
  }
  return result;
}

//----- (10006090) --------------------------------------------------------
char __thiscall sub_10006090(int this, char a2, int a3)
{
  int v3; // ecx@1
  char v4; // bl@3
  int v5; // esi@3

  v3 = *(_DWORD *)(this + 16);
  if ( !v3 )
    sub_10029561();
  v5 = a3;
  v4 = (*(int (__stdcall **)(char *))(*(_DWORD *)v3 + 8))(&a2);
  if ( a3 )
  {
    _EDI = -1;
    _EDX = a3 + 4;
    _ECX = -1;
    __asm { lock xadd [edx], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      _EAX = v5 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (**)(void))(*(_DWORD *)v5 + 4))();
    }
  }
  return v4;
}

//----- (10006160) --------------------------------------------------------
void *__thiscall sub_10006160(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_10068098;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10068098: using guessed type int (*off_10068098[5])();

//----- (10006190) --------------------------------------------------------
int __userpurge sub_10006190<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // edi@1
  int v10; // eax@3
  int v11; // eax@4
  int v13; // [sp-8h] [bp-30h]@4
  int v14; // [sp-4h] [bp-2Ch]@3
  char v15; // [sp+Ch] [bp-1Ch]@2
  int v16; // [sp+18h] [bp-10h]@1
  int v17; // [sp+24h] [bp-4h]@1

  v9 = a2;
  v17 = 0;
  v16 = 0;
  if ( !*(_DWORD *)a2 )
  {
    sub_1002FFB9((int)&v15, (unsigned int)"then() cannot be called on a default constructed task.");
    sub_100355DB((int)&v15, (int)&unk_1006D8B8);
  }
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_10006BC0(a1, a4, v9, a2);
  v17 = 0;
  v16 = 1;
  sub_10005980(a4, 2);
  *(_BYTE *)(*(_DWORD *)a4 + 88) = *(_BYTE *)(*(_DWORD *)v9 + 88) != 0;
  *(_BYTE *)(*(_DWORD *)a4 + 89) = 0;
  *(_BYTE *)(*(_DWORD *)a4 + 90) = 1;
  v10 = sub_1002CB8B(a3, v9, 0x34u);
  if ( v10 )
    v11 = sub_10006D10(v10, v9, a4, a5, v13, v14);
  else
    v11 = 0;
  sub_10009430(*(void **)v9, v11);
  return a4;
}

//----- (10006270) --------------------------------------------------------
int __fastcall sub_10006270(int a1, int a2, unsigned int a3, int (__cdecl *a4)(_DWORD, _DWORD))
{
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ecx@1
  signed int v7; // edx@1
  unsigned int v8; // ecx@6
  char v9; // al@8
  int v10; // eax@13
  int v11; // ebx@13
  int *v12; // edi@16
  int v13; // edx@19
  int v14; // ecx@19
  char v15; // cf@19
  char v16; // zf@31
  int *v17; // ebx@32
  int v18; // edi@32
  int v19; // eax@35
  char v20; // cf@35
  int v21; // ecx@39
  unsigned int v22; // ecx@45
  char v23; // cf@52
  int v24; // ecx@52
  int *v25; // edx@56
  int v26; // edx@62
  int v27; // ecx@62
  int v28; // edi@62
  int v29; // eax@62
  char v30; // cf@62
  int *v31; // ecx@66
  int v32; // eax@73
  int result; // eax@78
  int v34; // [sp+10h] [bp-94h]@1
  int v35; // [sp+14h] [bp-90h]@62
  int v36; // [sp+14h] [bp-90h]@66
  int v37; // [sp+1Ch] [bp-88h]@19
  int v38; // [sp+1Ch] [bp-88h]@62
  unsigned int v39; // [sp+20h] [bp-84h]@1
  int v40; // [sp+24h] [bp-80h]@1
  int v41; // [sp+28h] [bp-7Ch]@13
  int v42; // [sp+2Ch] [bp-78h]@2
  int v43; // [sp+2Ch] [bp-78h]@14
  int v44; // [sp+2Ch] [bp-78h]@19
  int v45; // [sp+34h] [bp-70h]@62
  int v46; // [sp+38h] [bp-6Ch]@62
  int v47; // [sp+3Ch] [bp-68h]@62
  int v48; // [sp+40h] [bp-64h]@62
  int v49; // [sp+44h] [bp-60h]@62
  void *v50; // [sp+48h] [bp-5Ch]@62
  int v51; // [sp+58h] [bp-4Ch]@62
  unsigned int v52; // [sp+5Ch] [bp-48h]@62
  int v53; // [sp+64h] [bp-40h]@19
  int v54; // [sp+68h] [bp-3Ch]@19
  int v55; // [sp+6Ch] [bp-38h]@19
  int v56; // [sp+70h] [bp-34h]@19
  int v57; // [sp+74h] [bp-30h]@19
  void *v58; // [sp+78h] [bp-2Ch]@19
  int v59; // [sp+88h] [bp-1Ch]@19
  unsigned int v60; // [sp+8Ch] [bp-18h]@19
  unsigned int v61; // [sp+94h] [bp-10h]@1
  int v62; // [sp+A0h] [bp-4h]@23
  int v63; // [sp+A4h] [bp+0h]@1

  v61 = (unsigned int)&v63 ^ __security_cookie;
  v39 = a2;
  v34 = a1;
  v6 = a2;
  v7 = (signed int)((unsigned __int64)(715827883i64 * (signed int)(a3 - a2)) >> 32) >> 3;
  v5 = v39 + 48 * (signed int)(v7 + ((unsigned int)v7 >> 31)) / 2;
  sub_10007110(v6, v5, a3 - 48, a4);
  v4 = v5 + 48;
  v40 = v5 + 48;
  if ( v39 < v5 )
  {
    do
    {
      v42 = v5 - 48;
      if ( (unsigned __int8)a4(v5 - 48, v5) )
        break;
      if ( (unsigned __int8)a4(v5, v42) )
        break;
      v5 -= 48;
    }
    while ( v39 < v42 );
    v4 = v40;
  }
  v8 = a3;
  if ( v4 < a3 )
  {
    while ( !(unsigned __int8)a4(v4, v5) )
    {
      v9 = a4(v5, v4);
      v8 = a3;
      if ( !v9 )
      {
        v4 += 48;
        if ( v4 < a3 )
          continue;
      }
      goto LABEL_12;
    }
    v8 = a3;
LABEL_12:
    v40 = v4;
  }
  v10 = v5;
  v11 = v4;
  v41 = v5;
  while ( 2 )
  {
    v43 = v11;
LABEL_15:
    if ( v11 < v8 )
    {
      v12 = (int *)(v11 + 20);
      do
      {
        if ( !(unsigned __int8)a4(v5, v11) )
        {
          if ( (unsigned __int8)a4(v11, v5) )
            break;
          v13 = v40;
          v15 = *(_DWORD *)(v40 + 40) < 0x10u;
          v40 += 48;
          v53 = *(_DWORD *)v13;
          v54 = *(_DWORD *)(v13 + 4);
          v55 = *(_DWORD *)(v13 + 8);
          v14 = v13 + 20;
          v56 = *(_DWORD *)(v13 + 12);
          v44 = v13;
          v57 = *(_DWORD *)(v13 + 16);
          v37 = v13 + 20;
          v60 = 15;
          v59 = 0;
          LOBYTE(v58) = 0;
          if ( v15 )
          {
            if ( *(_DWORD *)(v13 + 36) != -1 )
            {
              sub_1002A4B0(&v58, (const void *)(v13 + 20), *(_DWORD *)(v13 + 36) + 1);
              v14 = v37;
              v13 = v44;
            }
          }
          else
          {
            v58 = *(void **)v14;
            *(_DWORD *)v14 = 0;
          }
          v59 = *(_DWORD *)(v14 + 16);
          v60 = *(_DWORD *)(v14 + 20);
          *(_DWORD *)(v14 + 20) = 15;
          *(_DWORD *)(v14 + 16) = 0;
          *(_BYTE *)v14 = 0;
          v62 = 0;
          *(_DWORD *)v13 = *(_DWORD *)v11;
          *(_DWORD *)(v13 + 4) = *(_DWORD *)(v11 + 4);
          *(_DWORD *)(v13 + 8) = *(v12 - 3);
          *(_DWORD *)(v13 + 12) = *(v12 - 2);
          *(_DWORD *)(v13 + 16) = *(v12 - 1);
          if ( (int *)v14 != v12 )
            loc_1000AB40(v12, 0, -1);
          *(_DWORD *)v11 = v53;
          *(_DWORD *)(v11 + 4) = v54;
          *(v12 - 3) = v55;
          *(v12 - 2) = v56;
          *(v12 - 1) = v57;
          if ( (void **)v12 != &v58 )
            loc_1000AB40(v12, &v58, 0, -1);
          v62 = -1;
          if ( v60 >= 0x10 )
            sub_1002A4AA(v58);
        }
        v11 += 48;
        v12 += 12;
      }
      while ( v11 < a3 );
      v10 = v41;
      v43 = v11;
    }
    v16 = v10 == v39;
    if ( v10 <= v39 )
      goto LABEL_49;
    v17 = (int *)(v10 - 28);
    v18 = v5 + 36;
    while ( (unsigned __int8)a4(v17 - 5, v5) )
    {
LABEL_45:
      v22 = v39;
      v10 = v41 - 48;
      v17 -= 12;
      v41 = v10;
      if ( v39 >= v10 )
        goto LABEL_48;
    }
    if ( !(unsigned __int8)a4(v5, v17 - 5) )
    {
      v19 = *(_DWORD *)(v5 - 48);
      v5 -= 48;
      v53 = v19;
      v18 -= 48;
      v54 = *(_DWORD *)(v5 + 4);
      v20 = *(_DWORD *)(v18 + 4) < 0x10u;
      v55 = *(_DWORD *)(v18 - 28);
      v56 = *(_DWORD *)(v18 - 24);
      v57 = *(_DWORD *)(v18 - 20);
      v60 = 15;
      v59 = 0;
      LOBYTE(v58) = 0;
      if ( v20 )
      {
        if ( *(_DWORD *)v18 != -1 )
          sub_1002A4B0(&v58, (const void *)(v18 - 16), *(_DWORD *)v18 + 1);
      }
      else
      {
        v58 = *(void **)(v18 - 16);
        *(_DWORD *)(v18 - 16) = 0;
      }
      v59 = *(_DWORD *)v18;
      v60 = *(_DWORD *)(v18 + 4);
      *(_DWORD *)(v18 + 4) = 15;
      *(_DWORD *)v18 = 0;
      *(_BYTE *)(v18 - 16) = 0;
      v62 = 1;
      v21 = (int)(v17 - 5);
      *(_DWORD *)v5 = *(v17 - 5);
      *(_DWORD *)(v5 + 4) = *(int *)((char *)v17 - 1);
      *(_DWORD *)(v18 - 28) = *(v17 - 3);
      *(_DWORD *)(v18 - 24) = *(v17 - 2);
      *(_DWORD *)(v18 - 20) = *(v17 - 1);
      if ( (int *)(v18 - 16) != v17 )
      {
        loc_1000AB40(v18 - 16, v17, 0, -1);
        v21 = (int)(v17 - 5);
      }
      *(_DWORD *)v21 = v53;
      *(_DWORD *)(v21 + 4) = v54;
      *(v17 - 3) = v55;
      *(v17 - 2) = v56;
      *(v17 - 1) = v57;
      if ( (void **)v17 != &v58 )
        loc_1000AB40(v17, &v58, 0, -1);
      v62 = -1;
      if ( v60 >= 0x10 )
        sub_1002A4AA(v58);
      goto LABEL_45;
    }
    v10 = v41;
    v22 = v39;
LABEL_48:
    v11 = v43;
    v16 = v10 == v22;
LABEL_49:
    if ( !v16 )
    {
      v32 = v10 - 48;
      v41 = v32;
      if ( v11 != a3 )
      {
        sub_10008190(v11, v32);
        v10 = v41;
        v8 = a3;
        v11 += 48;
        continue;
      }
      v5 -= 48;
      if ( v32 != v5 )
        sub_10008190(v32, v5);
      v40 -= 48;
      sub_10008190(v5, v40);
      v10 = v41;
      v8 = a3;
      goto LABEL_15;
    }
    break;
  }
  if ( v11 != a3 )
  {
    if ( v40 != v11 )
    {
      v23 = *(_DWORD *)(v5 + 40) < 0x10u;
      v53 = *(_DWORD *)v5;
      v54 = *(_DWORD *)(v5 + 4);
      v55 = *(_DWORD *)(v5 + 8);
      v24 = v5 + 20;
      v56 = *(_DWORD *)(v5 + 12);
      v57 = *(_DWORD *)(v5 + 16);
      v60 = 15;
      v59 = 0;
      LOBYTE(v58) = 0;
      if ( v23 )
      {
        if ( *(_DWORD *)(v5 + 36) != -1 )
        {
          sub_1002A4B0(&v58, (const void *)(v5 + 20), *(_DWORD *)(v5 + 36) + 1);
          v24 = v5 + 20;
        }
      }
      else
      {
        v58 = *(void **)v24;
        *(_DWORD *)v24 = 0;
      }
      v59 = *(_DWORD *)(v24 + 16);
      v60 = *(_DWORD *)(v24 + 20);
      *(_DWORD *)(v24 + 20) = 15;
      *(_DWORD *)(v24 + 16) = 0;
      *(_BYTE *)v24 = 0;
      v62 = 2;
      *(_DWORD *)v5 = *(_DWORD *)v40;
      *(_DWORD *)(v5 + 4) = *(_DWORD *)(v40 + 4);
      *(_DWORD *)(v5 + 8) = *(_DWORD *)(v40 + 8);
      *(_DWORD *)(v5 + 12) = *(_DWORD *)(v40 + 12);
      v25 = (int *)(v40 + 20);
      *(_DWORD *)(v5 + 16) = *(_DWORD *)(v40 + 16);
      if ( v24 != v40 + 20 )
      {
        loc_1000AB40(v40 + 20, 0, -1);
        v25 = (int *)(v40 + 20);
      }
      *(_DWORD *)v40 = v53;
      *(_DWORD *)(v40 + 4) = v54;
      *(_DWORD *)(v40 + 8) = v55;
      *(_DWORD *)(v40 + 12) = v56;
      *(_DWORD *)(v40 + 16) = v57;
      if ( (void **)v25 != &v58 )
        loc_1000AB40(v25, &v58, 0, -1);
      if ( v60 >= 0x10 )
        sub_1002A4AA(v58);
    }
    v27 = v5;
    v45 = *(_DWORD *)v5;
    v46 = *(_DWORD *)(v5 + 4);
    v47 = *(_DWORD *)(v5 + 8);
    v40 += 48;
    v26 = v11;
    v28 = v5 + 20;
    v11 += 48;
    v48 = *(_DWORD *)(v5 + 12);
    v29 = *(_DWORD *)(v5 + 16);
    v5 += 48;
    v30 = *(_DWORD *)(v28 + 20) < 0x10u;
    v38 = v26;
    v35 = v27;
    v43 = v11;
    v49 = v29;
    v52 = 15;
    v51 = 0;
    LOBYTE(v50) = 0;
    if ( v30 )
    {
      if ( *(_DWORD *)(v28 + 16) != -1 )
      {
        sub_1002A4B0(&v50, (const void *)v28, *(_DWORD *)(v28 + 16) + 1);
        v27 = v35;
        v26 = v38;
      }
    }
    else
    {
      v50 = *(void **)v28;
      *(_DWORD *)v28 = 0;
    }
    v51 = *(_DWORD *)(v28 + 16);
    v52 = *(_DWORD *)(v28 + 20);
    *(_DWORD *)(v28 + 20) = 15;
    *(_DWORD *)(v28 + 16) = 0;
    *(_BYTE *)v28 = 0;
    v62 = 3;
    *(_DWORD *)v27 = *(_DWORD *)v26;
    *(_DWORD *)(v27 + 4) = *(_DWORD *)(v26 + 4);
    *(_DWORD *)(v27 + 8) = *(_DWORD *)(v26 + 8);
    *(_DWORD *)(v27 + 12) = *(_DWORD *)(v26 + 12);
    *(_DWORD *)(v27 + 16) = *(_DWORD *)(v26 + 16);
    v31 = (int *)(v26 + 20);
    v36 = v26 + 20;
    if ( v28 != v26 + 20 )
    {
      loc_1000AB40(v28, v26 + 20, 0, -1);
      v26 = v38;
      v31 = (int *)v36;
    }
    *(_DWORD *)v26 = v45;
    *(_DWORD *)(v26 + 4) = v46;
    *(_DWORD *)(v26 + 8) = v47;
    *(_DWORD *)(v26 + 12) = v48;
    *(_DWORD *)(v26 + 16) = v49;
    if ( (void **)v31 != &v50 )
      loc_1000AB40(&v50, 0, -1);
    v62 = -1;
    if ( v52 >= 0x10 )
      sub_1002A4AA(v50);
    v10 = v41;
    v8 = a3;
    v52 = 15;
    v51 = 0;
    LOBYTE(v50) = 0;
    goto LABEL_15;
  }
  result = v34;
  *(_DWORD *)v34 = v5;
  *(_DWORD *)(v34 + 4) = v40;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10006900) --------------------------------------------------------
int __fastcall sub_10006900(int a1, int a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax@1
  int v4; // edi@1
  signed int v5; // esi@1
  signed int v6; // edx@1
  int v7; // [sp+10h] [bp-4h]@1

  v4 = a2;
  v5 = a2 - a1;
  v6 = (signed int)((unsigned __int64)(715827883i64 * (a2 - a1)) >> 32) >> 3;
  result = v6 + ((unsigned int)v6 >> 31);
  v7 = a1;
  if ( result > 1 )
  {
    do
    {
      sub_10008790(a1, v4, a3);
      a1 = v7;
      v5 -= 48;
      result = v5 / 48;
      v4 -= 48;
    }
    while ( v5 / 48 > 1 );
  }
  return result;
}

//----- (10006970) --------------------------------------------------------
char __cdecl sub_10006970(int a1, int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    _EDI = -1;
    _EDX = a2 + 4;
    _ECX = -1;
    __asm { lock xadd [edx], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))a2)(a2);
      _EAX = a2 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)a2 + 4))(a2);
      result = 0;
    }
  }
  return result;
}

//----- (100069B0) --------------------------------------------------------
int __userpurge sub_100069B0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // edi@1
  int v10; // eax@3
  int v11; // eax@4
  int v13; // [sp-8h] [bp-30h]@4
  int v14; // [sp-4h] [bp-2Ch]@3
  char v15; // [sp+Ch] [bp-1Ch]@2
  int v16; // [sp+18h] [bp-10h]@1
  int v17; // [sp+24h] [bp-4h]@1

  v9 = a2;
  v17 = 0;
  v16 = 0;
  if ( !*(_DWORD *)a2 )
  {
    sub_1002FFB9((int)&v15, (unsigned int)"then() cannot be called on a default constructed task.");
    sub_100355DB((int)&v15, (int)&unk_1006D8B8);
  }
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_10006BC0(a1, a4, v9, a2);
  v17 = 0;
  v16 = 1;
  sub_10005980(a4, 2);
  *(_BYTE *)(*(_DWORD *)a4 + 88) = *(_BYTE *)(*(_DWORD *)v9 + 88) != 0;
  *(_BYTE *)(*(_DWORD *)a4 + 89) = 0;
  *(_BYTE *)(*(_DWORD *)a4 + 90) = 1;
  v10 = sub_1002CB8B(a3, v9, 0x34u);
  if ( v10 )
    v11 = sub_10006E20(v10, v9, a4, a5, v13, v14);
  else
    v11 = 0;
  sub_10009430(*(void **)v9, v11);
  return a4;
}

//----- (10006A90) --------------------------------------------------------
int __usercall sub_10006A90<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v3; // eax@1
  int *v4; // edi@1
  int v5; // esi@1
  int v6; // eax@2

  v4 = (int *)a1;
  v5 = a2;
  v3 = sub_1002ADB1(a1, a2, a3, a1, 184);
  if ( v3 )
    v6 = sub_10007630(v3, v4);
  else
    v6 = 0;
  *(_DWORD *)(v5 + 4) = v6;
  *(_DWORD *)v5 = v6 + 16;
  return v5;
}

//----- (10006B10) --------------------------------------------------------
int __usercall sub_10006B10<eax>(int a1<edx>, int a2<ecx>, int a3<edi>)
{
  int v3; // ecx@1
  int v4; // esi@1
  char *v6; // [sp-4h] [bp-3Ch]@4
  char v7; // [sp+8h] [bp-30h]@1
  int v8; // [sp+18h] [bp-20h]@2
  char *v9; // [sp+20h] [bp-18h]@1
  int v10; // [sp+24h] [bp-14h]@1
  int v11; // [sp+28h] [bp-10h]@1
  int v12; // [sp+34h] [bp-4h]@1

  v4 = a2;
  v11 = a2;
  v10 = 0;
  v9 = &v7;
  v12 = 0;
  v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    if ( v3 == a1 )
    {
      a1 = (int)&v7;
      v6 = &v7;
    }
    else
    {
      v6 = 0;
    }
    v8 = (**(int (__fastcall ***)(int, int, char *))v3)(v3, a1, v6);
  }
  else
  {
    v8 = 0;
  }
  v12 = 2;
  sub_100089A0(a1, v4, a3, (int)&v7, v3);
  v12 = -1;
  if ( v8 )
    (*(void (__stdcall **)(bool))(*(_DWORD *)v8 + 16))(v8 != (_DWORD)&v7);
  return v4;
}

//----- (10006BC0) --------------------------------------------------------
int __userpurge sub_10006BC0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4)
{
  int result; // eax@1
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // edi@4
  char v20; // [sp+0h] [bp-20h]@1
  char *v21; // [sp+10h] [bp-10h]@1
  int v22; // [sp+1Ch] [bp-4h]@1

  v21 = &v20;
  v5 = a2;
  v22 = 0;
  result = sub_1002ADB1(a1, a2, a2, a3, 16);
  v6 = result;
  if ( result )
  {
    *(_DWORD *)(result + 4) = 1;
    *(_DWORD *)(result + 8) = 1;
    *(_DWORD *)result = &off_1006806C;
    *(_DWORD *)(result + 12) = 0;
  }
  else
  {
    v6 = 0;
  }
  v7 = *(_DWORD *)(v5 + 4);
  if ( v7 )
  {
    _ECX = v7 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v7)(v7);
      result = v7 + 8;
      _ECX = -1;
      __asm { lock xadd [eax], ecx }
      if ( _ZF )
        result = (*(int (**)(void))(*(_DWORD *)v7 + 4))();
    }
  }
  *(_DWORD *)(v5 + 4) = v6;
  *(_DWORD *)v5 = 0;
  return result;
}
// 1006806C: using guessed type int (*off_1006806C)();

//----- (10006C80) --------------------------------------------------------
int __thiscall sub_10006C80(int this, char a2, int a3)
{
  int v3; // ecx@1
  int result; // eax@3
  int v5; // esi@3

  v3 = *(_DWORD *)(this + 16);
  if ( !v3 )
    sub_10029561();
  result = (*(int (__stdcall **)(char *))(*(_DWORD *)v3 + 8))(&a2);
  v5 = a3;
  if ( a3 )
  {
    _EDI = -1;
    _ECX = a3 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      result = v5 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (**)(void))(*(_DWORD *)v5 + 4))();
    }
  }
  return result;
}

//----- (10006D10) --------------------------------------------------------
int __thiscall sub_10006D10(int this, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // esi@1

  v7 = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_BYTE *)(this + 25) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = &off_100680E0;
  sub_10004DE0(this + 32, a3);
  *(_DWORD *)(v7 + 4) = sub_10007740;
  *(_BYTE *)(v7 + 16) = 1;
  *(_DWORD *)v7 = &off_100680E8;
  sub_10004DE0(v7 + 40, a2);
  *(_DWORD *)(v7 + 48) = *(_DWORD *)a4;
  *(_BYTE *)(v7 + 25) = 1;
  *(_DWORD *)(v7 + 28) = 0;
  return v7;
}
// 100680E0: using guessed type int (__stdcall *off_100680E0)(char);
// 100680E8: using guessed type int (__stdcall *off_100680E8)(char);

//----- (10006DC0) --------------------------------------------------------
int __thiscall sub_10006DC0(int this)
{
  return sub_1000A690(*(_DWORD *)(this + 4));
}

//----- (10006DD0) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10006DD0())(char)
{
  return &off_100759E8;
}
// 100759E8: using guessed type int (__stdcall **off_100759E8)(char);

//----- (10006DE0) --------------------------------------------------------
int __thiscall sub_10006DE0(void *this)
{
  return (int)((char *)this + 4);
}

//----- (10006DF0) --------------------------------------------------------
int __thiscall sub_10006DF0(void *this, char a2)
{
  int result; // eax@1
  void *v3; // esi@1

  v3 = this;
  result = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)this + 20))(0);
  if ( a2 )
    result = sub_1002A4AA(v3);
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10006E20) --------------------------------------------------------
int __thiscall sub_10006E20(int this, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // esi@1

  v7 = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_BYTE *)(this + 25) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = &off_100680E0;
  sub_10004DE0(this + 32, a3);
  *(_DWORD *)(v7 + 4) = sub_10007750;
  *(_BYTE *)(v7 + 16) = 1;
  *(_DWORD *)v7 = &off_100680E8;
  sub_10004DE0(v7 + 40, a2);
  *(_DWORD *)(v7 + 48) = *(_DWORD *)a4;
  *(_BYTE *)(v7 + 25) = 1;
  *(_DWORD *)(v7 + 28) = 0;
  return v7;
}
// 100680E0: using guessed type int (__stdcall *off_100680E0)(char);
// 100680E8: using guessed type int (__stdcall *off_100680E8)(char);

//----- (10006E90) --------------------------------------------------------
int __thiscall sub_10006E90(int this)
{
  return (**(int (__thiscall ***)(_DWORD, _DWORD))(this + 16))(this + 16, 0);
}

//----- (10006EA0) --------------------------------------------------------
int __thiscall sub_10006EA0(int this)
{
  int v1; // ecx@1
  int result; // eax@2

  v1 = *(_DWORD *)(this + 12);
  if ( v1 )
    result = (**(int (__stdcall ***)(_DWORD))v1)(1);
  return result;
}

//----- (10006EB0) --------------------------------------------------------
void *__thiscall sub_10006EB0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_10068098;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10068098: using guessed type int (*off_10068098[5])();

//----- (10006EE0) --------------------------------------------------------
void __userpurge sub_10006EE0(int *a1<ecx>, int a2<ebx>, int a3)
{
  int v3; // eax@1
  int v4; // edx@1
  int ebp0; // ebp@0
  int *v6; // esi@1
  int v7; // edx@4
  char v8; // [sp-14h] [bp-4Ch]@4
  int v9; // [sp-10h] [bp-48h]@4
  int v10; // [sp-Ch] [bp-44h]@4
  int v11; // [sp-8h] [bp-40h]@4
  unsigned int v12; // [sp-4h] [bp-3Ch]@1
  unsigned int v13; // [sp+28h] [bp-10h]@1
  int v14; // [sp+34h] [bp-4h]@1
  int v15; // [sp+38h] [bp+0h]@1

  v13 = (unsigned int)&v15 ^ __security_cookie;
  v12 = (unsigned int)&v15 ^ __security_cookie;
  v6 = a1;
  sub_1002C5B4(ebp0);
  sub_1002B62D(ebp0, *v6 + 12);
  v14 = 0;
  v3 = *v6;
  if ( *(_DWORD *)(*v6 + 64) )
  {
    (*(void (__stdcall **)(signed int, signed int, signed int, int))(**(_DWORD **)a3 + 4))(1, 1, 1, v3 + 64);
  }
  else
  {
    if ( *(_BYTE *)(v3 + 72) )
    {
      sub_10010010((int)&v8, v4, v3 + 48);
      sub_10003520(v7, *(_DWORD *)a3, a2, v8, v9, v10, v11);
    }
    else
    {
      sub_10006FA0(v3, a3);
    }
  }
  v14 = -1;
  sub_1002B6D6();
}
// 10074200: using guessed type int __security_cookie;

//----- (10006FA0) --------------------------------------------------------
int __thiscall sub_10006FA0(int this, int a2)
{
  int result; // eax@1
  int v3; // esi@1
  int v4; // edi@3
  int v5; // ecx@5
  int v6; // ecx@9

  v3 = this;
  result = *(_DWORD *)(this + 4);
  if ( a2 >= (unsigned int)result || (this = *(_DWORD *)this, *(_DWORD *)v3 > (unsigned int)a2) )
  {
    if ( result == *(_DWORD *)(v3 + 8) )
      result = loc_10007010(v3, this);
    v6 = *(_DWORD *)(v3 + 4);
    if ( v6 )
      result = sub_10004DE0(v6, a2);
  }
  else
  {
    v4 = (a2 - this) >> 3;
    if ( result == *(_DWORD *)(v3 + 8) )
      result = loc_10007010(v3, *(_DWORD *)v3);
    v5 = *(_DWORD *)(v3 + 4);
    if ( v5 )
    {
      result = sub_10004DE0(v5, *(_DWORD *)v3 + 8 * v4);
      *(_DWORD *)(v3 + 4) += 8;
      return result;
    }
  }
  *(_DWORD *)(v3 + 4) += 8;
  return result;
}

//----- (10007110) --------------------------------------------------------
int __fastcall sub_10007110(int a1, int a2, int a3, int (__cdecl *a4)(_DWORD, _DWORD))
{
  int v4; // eax@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // eax@2
  int v8; // esi@7
  int v9; // esi@12
  int result; // eax@19
  int v11; // [sp+10h] [bp-10h]@2
  int v12; // [sp+14h] [bp-Ch]@1
  int v13; // [sp+14h] [bp-Ch]@7
  int v14; // [sp+18h] [bp-8h]@2
  int v15; // [sp+18h] [bp-8h]@12
  int v16; // [sp+1Ch] [bp-4h]@2

  v5 = a1;
  v6 = a2;
  v4 = (a3 - a1) / 48;
  v12 = a1;
  if ( v4 <= 40 )
  {
    if ( (unsigned __int8)a4(a2, a1) )
      sub_10008190(v6, v5);
    result = a4(a3, v6);
    if ( (_BYTE)result )
    {
      sub_10008190(a3, v6);
      result = a4(v6, v5);
      if ( (_BYTE)result )
        result = (int)sub_10008190(v6, v5);
    }
  }
  else
  {
    v7 = (v4 + 1) / 8;
    v11 = 48 * v7;
    v14 = 96 * v7;
    v16 = a1 + 48 * v7;
    if ( (unsigned __int8)a4(a1 + 48 * v7, a1) )
      sub_10008190(v16, v12);
    if ( (unsigned __int8)a4(v12 + v14, v16) )
    {
      sub_10008190(v14 + v12, v16);
      if ( (unsigned __int8)a4(v16, v12) )
        sub_10008190(v16, v12);
    }
    v8 = v6 - v11;
    v13 = v11 + v6;
    if ( (unsigned __int8)a4(v6, v6 - v11) )
      sub_10008190(v6, v8);
    if ( (unsigned __int8)a4(v13, v6) )
    {
      sub_10008190(v13, v6);
      if ( (unsigned __int8)a4(v6, v8) )
        sub_10008190(v6, v8);
    }
    v9 = a3 - v11;
    v15 = a3 - v14;
    if ( (unsigned __int8)a4(a3 - v11, v15) )
      sub_10008190(v9, v15);
    if ( (unsigned __int8)a4(a3, v9) )
    {
      sub_10008190(a3, v9);
      if ( (unsigned __int8)a4(v9, v15) )
        sub_10008190(v9, v15);
    }
    if ( (unsigned __int8)a4(v6, v16) )
      sub_10008190(v6, v16);
    result = a4(v9, v6);
    if ( (_BYTE)result )
    {
      sub_10008190(v9, v6);
      result = a4(v6, v16);
      if ( (_BYTE)result )
        result = (int)sub_10008190(v6, v16);
    }
  }
  return result;
}

//----- (100072E0) --------------------------------------------------------
int __fastcall sub_100072E0(int a1, int a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax@1
  int v4; // ebx@1
  int v5; // edi@1
  signed int v6; // edx@1
  int v7; // esi@2
  int v8; // eax@3
  char v9; // cf@3
  int v10; // [sp+10h] [bp-48h]@1
  int v11; // [sp+14h] [bp-44h]@3
  int v12; // [sp+18h] [bp-40h]@3
  int v13; // [sp+1Ch] [bp-3Ch]@3
  int v14; // [sp+20h] [bp-38h]@3
  int v15; // [sp+24h] [bp-34h]@3
  void *v16; // [sp+28h] [bp-30h]@3
  int v17; // [sp+38h] [bp-20h]@3
  unsigned int v18; // [sp+3Ch] [bp-1Ch]@3
  unsigned int v19; // [sp+44h] [bp-14h]@1
  int v20; // [sp+54h] [bp-4h]@7
  int v21; // [sp+58h] [bp+0h]@1

  v19 = (unsigned int)&v21 ^ __security_cookie;
  v4 = a1;
  v6 = (signed int)((unsigned __int64)(715827883i64 * (a2 - a1)) >> 32) >> 3;
  v10 = v6 + ((unsigned int)v6 >> 31);
  result = v10 - ((unsigned __int64)v10 >> 32);
  v5 = v10 / 2;
  if ( v10 / 2 > 0 )
  {
    v7 = 48 * v5 + a1 + 36;
    do
    {
      v8 = *(_DWORD *)(v7 - 84);
      v7 -= 48;
      v11 = v8;
      v12 = *(_DWORD *)(v7 - 32);
      v13 = *(_DWORD *)(v7 - 28);
      v14 = *(_DWORD *)(v7 - 24);
      --v5;
      v9 = *(_DWORD *)(v7 + 4) < 0x10u;
      v15 = *(_DWORD *)(v7 - 20);
      v18 = 15;
      v17 = 0;
      LOBYTE(v16) = 0;
      if ( v9 )
      {
        if ( *(_DWORD *)v7 != -1 )
          sub_1002A4B0(&v16, (const void *)(v7 - 16), *(_DWORD *)v7 + 1);
      }
      else
      {
        v16 = *(void **)(v7 - 16);
        *(_DWORD *)(v7 - 16) = 0;
      }
      v17 = *(_DWORD *)v7;
      v18 = *(_DWORD *)(v7 + 4);
      *(_DWORD *)(v7 + 4) = 15;
      *(_DWORD *)v7 = 0;
      *(_BYTE *)(v7 - 16) = 0;
      v20 = 0;
      result = sub_10008260(v4, v5, v10, (int)&v11, a3);
      v20 = -1;
      if ( v18 >= 0x10 )
        result = sub_1002A4AA(v16);
    }
    while ( v5 > 0 );
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10007420) --------------------------------------------------------
int __fastcall sub_10007420(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // edi@2
  char v6; // cf@3
  int v7; // ebx@3
  int v8; // esi@10
  int v9; // edi@11
  int v10; // [sp+10h] [bp-58h]@1
  int v11; // [sp+14h] [bp-54h]@2
  int v12; // [sp+1Ch] [bp-4Ch]@1
  int v13; // [sp+20h] [bp-48h]@1
  int v14; // [sp+24h] [bp-44h]@3
  int v15; // [sp+28h] [bp-40h]@3
  int v16; // [sp+2Ch] [bp-3Ch]@3
  int v17; // [sp+30h] [bp-38h]@3
  int v18; // [sp+34h] [bp-34h]@3
  void *v19; // [sp+38h] [bp-30h]@3
  int v20; // [sp+48h] [bp-20h]@3
  unsigned int v21; // [sp+4Ch] [bp-1Ch]@3
  unsigned int v22; // [sp+54h] [bp-14h]@1
  int v23; // [sp+64h] [bp-4h]@7
  int v24; // [sp+68h] [bp+0h]@1

  v22 = (unsigned int)&v24 ^ __security_cookie;
  v10 = a2;
  v13 = a1;
  result = a3;
  v4 = a1 + 48;
  v12 = a1 + 48;
  if ( a1 + 48 != a2 )
  {
    v5 = a1 + 84;
    v11 = a1 + 84;
    do
    {
      v6 = *(_DWORD *)(v5 + 4) < 0x10u;
      v14 = *(_DWORD *)v4;
      v15 = *(_DWORD *)(v4 + 4);
      v16 = *(_DWORD *)(v5 - 28);
      v17 = *(_DWORD *)(v5 - 24);
      v7 = v4;
      v18 = *(_DWORD *)(v5 - 20);
      v21 = 15;
      v20 = 0;
      LOBYTE(v19) = 0;
      if ( v6 )
      {
        if ( *(_DWORD *)v5 != -1 )
        {
          sub_1002A4B0(&v19, (const void *)(v5 - 16), *(_DWORD *)v5 + 1);
          a1 = v13;
        }
      }
      else
      {
        v19 = *(void **)(v5 - 16);
        *(_DWORD *)(v5 - 16) = 0;
      }
      v20 = *(_DWORD *)v5;
      v21 = *(_DWORD *)(v5 + 4);
      *(_DWORD *)(v5 + 4) = 15;
      *(_DWORD *)v5 = 0;
      *(_BYTE *)(v5 - 16) = 0;
      v23 = 0;
      if ( (unsigned __int8)((int (__cdecl *)(int *, int))a3)(&v14, a1) )
      {
        sub_10008860(v13, v4, v5 + 12);
        *(_DWORD *)v13 = v14;
        *(_DWORD *)(v13 + 4) = v15;
        *(_DWORD *)(v13 + 8) = v16;
        *(_DWORD *)(v13 + 12) = v17;
        *(_DWORD *)(v13 + 16) = v18;
        result = (int)&v19;
        if ( (void **)(v13 + 20) != &v19 )
          result = loc_1000AB40(v13 + 20, &v19, 0, -1);
      }
      else
      {
        v8 = v5 - 84;
        if ( (unsigned __int8)((int (__cdecl *)(int *, int))a3)(&v14, v5 - 84) )
        {
          v9 = v5 - 64;
          do
          {
            *(_DWORD *)v7 = *(_DWORD *)v8;
            *(_DWORD *)(v7 + 4) = *(_DWORD *)(v8 + 4);
            *(_DWORD *)(v7 + 8) = *(_DWORD *)(v9 - 12);
            *(_DWORD *)(v7 + 12) = *(_DWORD *)(v9 - 8);
            *(_DWORD *)(v7 + 16) = *(_DWORD *)(v9 - 4);
            if ( v7 + 20 != v9 )
              loc_1000AB40(v7 + 20, v9, 0, -1);
            v7 = v8;
            v8 -= 48;
            v9 -= 48;
          }
          while ( (unsigned __int8)((int (__cdecl *)(int *, int))a3)(&v14, v8) );
          v5 = v11;
        }
        *(_DWORD *)v7 = v14;
        *(_DWORD *)(v7 + 4) = v15;
        *(_DWORD *)(v7 + 8) = v16;
        *(_DWORD *)(v7 + 12) = v17;
        *(_DWORD *)(v7 + 16) = v18;
        result = (int)&v19;
        if ( (void **)(v7 + 20) != &v19 )
          result = loc_1000AB40(v7 + 20, &v19, 0, -1);
        v4 = v12;
      }
      v23 = -1;
      if ( v21 >= 0x10 )
        result = sub_1002A4AA(v19);
      a1 = v13;
      v4 += 48;
      v5 += 48;
      v12 = v4;
      v11 = v5;
    }
    while ( v4 != v10 );
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10007630) --------------------------------------------------------
int __thiscall sub_10007630(int this, int *a2)
{
  int v2; // edi@1
  int v3; // esi@1

  v3 = this;
  *(_DWORD *)(this + 4) = 1;
  *(_DWORD *)(this + 8) = 1;
  v2 = this + 16;
  *(_DWORD *)this = &off_1006805C;
  if ( this != -16 )
  {
    sub_10009600((void *)(this + 16), *a2);
    *(_DWORD *)v2 = &off_1006814C;
    *(_BYTE *)(v2 + 160) = 0;
    *(_DWORD *)(v2 + 160) &= 0xFFFFFEFFu;
    *(_DWORD *)(v2 + 164) = 0;
  }
  return v3;
}
// 1006805C: using guessed type int (*off_1006805C)();
// 1006814C: using guessed type int (__stdcall *off_1006814C)(char);

//----- (100076D0) --------------------------------------------------------
int __thiscall sub_100076D0(int this, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // esi@1
  int v12; // edi@3
  int v28; // [sp+14h] [bp+8h]@1

  v4 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  v3 = *(_DWORD *)(a2 + 4);
  v28 = *(_DWORD *)a2;
  if ( v3 )
  {
    _EAX = v3 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v12 = *(_DWORD *)(v4 + 4);
  if ( v12 )
  {
    _ECX = v12 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v12)(v12);
      _EAX = v12 + 8;
      _ECX = -1;
      __asm { lock xadd [eax], ecx }
      if ( _ZF )
        (*(void (__thiscall **)(int))(*(_DWORD *)v12 + 4))(v12);
    }
  }
  *(_DWORD *)v4 = v28;
  *(_DWORD *)(v4 + 4) = v3;
  return v4;
}

//----- (10007740) --------------------------------------------------------
void __cdecl sub_10007740(int a1)
{
  JUMPOUT(*(unsigned int *)loc_10007760);
}
// 10007760: using guessed type int __cdecl loc_10007760(int);

//----- (10007750) --------------------------------------------------------
int __usercall sub_10007750<eax>(int a1<eax>, int a2)
{
  int v2; // esi@1
  int v4; // edx@4
  unsigned int v5; // [sp-18h] [bp-50h]@1
  int v6; // [sp-14h] [bp-4Ch]@3
  int v7; // [sp-10h] [bp-48h]@3
  int v8; // [sp-Ch] [bp-44h]@3
  char v9; // [sp-8h] [bp-40h]@3
  int v10; // [sp+0h] [bp-38h]@4
  int v11; // [sp+4h] [bp-34h]@1
  unsigned int v12; // [sp+24h] [bp-14h]@1
  unsigned int *v13; // [sp+28h] [bp-10h]@1
  int v14; // [sp+2Ch] [bp-Ch]@1
  int (__cdecl *v15)(int, int); // [sp+30h] [bp-8h]@1
  int v16; // [sp+34h] [bp-4h]@1
  _DWORD *v17; // [sp+38h] [bp+0h]@1

  v17 = &v17;
  v16 = -1;
  v15 = sub_1005AA90;
  v14 = a1;
  v12 = (unsigned int)&v17 ^ __security_cookie;
  v5 = (unsigned int)&v17 ^ __security_cookie;
  v13 = &v5;
  v2 = *(_DWORD *)(a2 + 32);
  v11 = a2;
  sub_1002B62D((int)&v17, v2 + 100);
  v16 = -1;
  if ( *(_DWORD *)(v2 + 84) == 4 )
  {
    sub_1002B6D6();
  }
  else
  {
    *(_DWORD *)(v2 + 84) = 1;
    sub_1002B6D6();
    v16 = 1;
    LOBYTE(v10) = 0;
    sub_10007D20(v4, a2, a2, v10, v10);
  }
  return sub_1002A49B(v8, v6, v7, (unsigned int)&v17 ^ v12, v9);
}
// 1005AA90: using guessed type int __cdecl sub_1005AA90(int, int);
// 10074200: using guessed type int __security_cookie;

//----- (10007940) --------------------------------------------------------
int __thiscall sub_10007940(int this, int a2, int a3)
{
  int v3; // edx@1
  int v4; // edi@1
  int result; // eax@3

  v4 = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)this = off_10068054;
  sub_10004DE0(this + 20, a2);
  *(_DWORD *)(v4 + 4) = sub_100083A0;
  *(_BYTE *)(v4 + 16) = 1;
  *(_DWORD *)v4 = &off_10068058;
  *(_DWORD *)(v4 + 28) = *(_DWORD *)a3;
  *(_DWORD *)(v4 + 52) = 7;
  *(_DWORD *)(v4 + 48) = 0;
  *(_WORD *)(v4 + 32) = 0;
  loc_10009CC0(a3 + 4, 0, -1);
  v3 = *(_DWORD *)(a3 + 28);
  if ( v3 )
  {
    _EAX = v3 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  result = v4;
  *(_DWORD *)(v4 + 56) = v3;
  return result;
}
// 10068054: using guessed type int (__stdcall *off_10068054[2])(char);
// 10068058: using guessed type int (__stdcall *off_10068058)(char);

//----- (100079F0) --------------------------------------------------------
int __thiscall sub_100079F0(int this)
{
  int v1; // ecx@1
  int v3; // edi@1
  int v4; // esi@1
  int result; // eax@6
  int v13; // edi@6

  v4 = this;
  *(_DWORD *)this = &off_10068058;
  v3 = this + 28;
  v1 = *(_DWORD *)(this + 56);
  _EBX = -1;
  if ( v1 )
  {
    _EAX = v1 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v1 + 4))();
  }
  *(_DWORD *)(v3 + 28) = 0;
  if ( *(_DWORD *)(v3 + 24) >= 8u )
    sub_1002A4AA(*(LPVOID *)(v3 + 4));
  *(_DWORD *)(v3 + 24) = 7;
  *(_DWORD *)(v3 + 20) = 0;
  result = 0;
  *(_WORD *)(v3 + 4) = 0;
  *(_DWORD *)v4 = off_10068054;
  v13 = *(_DWORD *)(v4 + 24);
  if ( v13 )
  {
    result = v13 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v13)(v13);
      result = v13 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        result = (*(int (**)(void))(*(_DWORD *)v13 + 4))();
    }
  }
  *(_DWORD *)v4 = &off_10061E90;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10061E90: using guessed type int (__stdcall *off_10061E90)(char);
// 10068054: using guessed type int (__stdcall *off_10068054[2])(char);
// 10068058: using guessed type int (__stdcall *off_10068058)(char);

//----- (10007B20) --------------------------------------------------------
int __userpurge sub_10007B20<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  int v4; // esi@1

  v4 = a1;
  sub_100079F0(a1);
  if ( a4 & 1 )
    sub_1002CC50(a2, a3, v4);
  return v4;
}

//----- (10007B50) --------------------------------------------------------
int __userpurge sub_10007B50<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int v20; // [sp-4h] [bp-Ch]@2

  v4 = a1;
  *(_DWORD *)a1 = off_10068054;
  v3 = *(_DWORD *)(a1 + 24);
  if ( v3 )
  {
    v20 = a2;
    _EBX = -1;
    _EDX = v3 + 4;
    _EAX = -1;
    __asm { lock xadd [edx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v3)(v3);
      _EAX = v3 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
    }
    a2 = v20;
  }
  *(_DWORD *)v4 = &off_10061E90;
  if ( a3 & 1 )
    sub_1002CC50(a2, v3, v4);
  return v4;
}
// 10061E90: using guessed type int (__stdcall *off_10061E90)(char);
// 10068054: using guessed type int (__stdcall *off_10068054[2])(char);

//----- (10007BB0) --------------------------------------------------------
int __userpurge sub_10007BB0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // edx@1
  int v6; // ebx@1
  int v8; // esi@1
  int v9; // ebx@1
  int v10; // eax@1
  int result; // eax@8
  int v26; // ebx@8
  int v27; // ebx@8
  int v28; // eax@8
  int v52; // [sp-8h] [bp-44h]@6
  int v53; // [sp-4h] [bp-40h]@6
  int v54; // [sp+14h] [bp-28h]@1
  int v55; // [sp+18h] [bp-24h]@1
  int v56; // [sp+1Ch] [bp-20h]@1
  int v57; // [sp+20h] [bp-1Ch]@1
  char v58; // [sp+24h] [bp-18h]@1
  int v59; // [sp+28h] [bp-14h]@1
  int v60; // [sp+38h] [bp-4h]@1

  v9 = a2;
  v55 = a2;
  v56 = 0;
  v57 = 0;
  sub_10006BC0(a1, (int)&v56, a3, a2);
  v60 = 0;
  v10 = sub_10004DE0((int)&v58, v9 + 40);
  v8 = *(_DWORD *)(v10 + 4);
  *(_DWORD *)(v10 + 4) = v57;
  v5 = *(_DWORD *)v10;
  *(_DWORD *)v10 = v56;
  v6 = v59;
  _EDI = -1;
  v57 = v8;
  v54 = v5;
  v56 = v5;
  if ( v59 )
  {
    _EAX = v59 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v6)(v6);
      _EAX = v6 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v6 + 4))(v6, _EDX);
      v5 = v54;
    }
  }
  v52 = 0;
  v53 = 0;
  if ( &v52 != &v56 )
  {
    v53 = v8;
    v8 = 0;
    v57 = 0;
    v52 = v5;
    v56 = 0;
  }
  v27 = v55;
  v28 = sub_100043A0((void *)(v55 + 48), (int)&v58, v52, v53);
  LOBYTE(v60) = 1;
  result = sub_100083B0(v28, v27 + 32, v27);
  LOBYTE(v60) = 0;
  v26 = v59;
  if ( v59 )
  {
    result = v59 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v26)(v26);
      result = v26 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v26 + 4))(v26, _EDX);
    }
  }
  v60 = -1;
  if ( v8 )
  {
    result = v8 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v8)(v8);
      result = v8 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (**)(void))(*(_DWORD *)v8 + 4))();
    }
  }
  return result;
}

//----- (10007D20) --------------------------------------------------------
int __userpurge sub_10007D20<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // edx@1
  int v6; // ebx@1
  int v8; // esi@1
  int v9; // ebx@1
  int v10; // eax@1
  int result; // eax@8
  int v26; // ebx@8
  int v27; // ebx@8
  int v28; // eax@8
  int v52; // [sp-8h] [bp-44h]@6
  int v53; // [sp-4h] [bp-40h]@6
  int v54; // [sp+14h] [bp-28h]@1
  int v55; // [sp+18h] [bp-24h]@1
  int v56; // [sp+1Ch] [bp-20h]@1
  int v57; // [sp+20h] [bp-1Ch]@1
  char v58; // [sp+24h] [bp-18h]@1
  int v59; // [sp+28h] [bp-14h]@1
  int v60; // [sp+38h] [bp-4h]@1

  v9 = a2;
  v55 = a2;
  v56 = 0;
  v57 = 0;
  sub_10006BC0(a1, (int)&v56, a3, a2);
  v60 = 0;
  v10 = sub_10004DE0((int)&v58, v9 + 40);
  v8 = *(_DWORD *)(v10 + 4);
  *(_DWORD *)(v10 + 4) = v57;
  v5 = *(_DWORD *)v10;
  *(_DWORD *)v10 = v56;
  v6 = v59;
  _EDI = -1;
  v57 = v8;
  v54 = v5;
  v56 = v5;
  if ( v59 )
  {
    _EAX = v59 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v6)(v6);
      _EAX = v6 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v6 + 4))(v6, _EDX);
      v5 = v54;
    }
  }
  v52 = 0;
  v53 = 0;
  if ( &v52 != &v56 )
  {
    v53 = v8;
    v8 = 0;
    v57 = 0;
    v52 = v5;
    v56 = 0;
  }
  v27 = v55;
  v28 = sub_10004650((void *)(v55 + 48), (int)&v58, v52, v53);
  LOBYTE(v60) = 1;
  result = sub_100083B0(v28, v27 + 32, v27);
  LOBYTE(v60) = 0;
  v26 = v59;
  if ( v59 )
  {
    result = v59 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v26)(v26);
      result = v26 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v26 + 4))(v26, _EDX);
    }
  }
  v60 = -1;
  if ( v8 )
  {
    result = v8 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v8)(v8);
      result = v8 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (**)(void))(*(_DWORD *)v8 + 4))();
    }
  }
  return result;
}

//----- (10007E90) --------------------------------------------------------
int __fastcall sub_10007E90(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  char v7; // [sp+0h] [bp-28h]@1
  int v8; // [sp+10h] [bp-18h]@3
  int v9; // [sp+14h] [bp-14h]@1
  char *v10; // [sp+18h] [bp-10h]@1
  int v11; // [sp+24h] [bp-4h]@1

  v10 = &v7;
  v3 = a2;
  v4 = a1;
  v5 = a3;
  v9 = a3;
  v11 = 0;
  while ( v4 != v3 )
  {
    v8 = v5;
    LOBYTE(v11) = 1;
    if ( v5 )
    {
      *(_DWORD *)v5 = *(_DWORD *)v4;
      *(_DWORD *)(v5 + 4) = *(_DWORD *)(v4 + 4);
      *(_DWORD *)(v5 + 8) = *(_DWORD *)(v4 + 8);
      *(_DWORD *)(v5 + 12) = *(_DWORD *)(v4 + 12);
      *(_DWORD *)(v5 + 16) = *(_DWORD *)(v4 + 16);
      *(_DWORD *)(v5 + 40) = 15;
      *(_DWORD *)(v5 + 36) = 0;
      *(_BYTE *)(v5 + 20) = 0;
      loc_1000AB40(v4 + 20, 0, -1);
    }
    v5 += 48;
    LOBYTE(v11) = 0;
    v4 += 48;
  }
  return v5;
}

//----- (10007F60) --------------------------------------------------------
int __fastcall sub_10007F60(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // edx@1
  signed int v5; // ecx@1
  int v6; // edi@1
  int v7; // esi@1
  signed int v8; // edx@1
  signed int v9; // edi@2
  int v10; // edx@3
  int v11; // eax@7
  int v12; // edx@7
  int v13; // ecx@7
  int v14; // ebx@8
  int v15; // esi@8
  char v16; // cf@10
  int v17; // edi@10
  int v18; // ecx@20
  signed int v19; // edx@20
  int v20; // eax@22
  int v21; // edx@24
  unsigned __int8 v22; // zf@24
  unsigned __int8 v23; // sf@24
  int v24; // [sp+10h] [bp-58h]@7
  int v25; // [sp+14h] [bp-54h]@7
  int v26; // [sp+18h] [bp-50h]@1
  int v27; // [sp+1Ch] [bp-4Ch]@1
  int v28; // [sp+20h] [bp-48h]@1
  int v29; // [sp+24h] [bp-44h]@10
  int v30; // [sp+28h] [bp-40h]@10
  int v31; // [sp+2Ch] [bp-3Ch]@10
  int v32; // [sp+30h] [bp-38h]@10
  int v33; // [sp+34h] [bp-34h]@10
  void *v34; // [sp+38h] [bp-30h]@10
  int v35; // [sp+48h] [bp-20h]@10
  unsigned int v36; // [sp+4Ch] [bp-1Ch]@10
  unsigned int v37; // [sp+54h] [bp-14h]@1
  int v38; // [sp+64h] [bp-4h]@14
  int v39; // [sp+68h] [bp+0h]@1

  v37 = (unsigned int)&v39 ^ __security_cookie;
  v27 = a1;
  v8 = (signed int)((unsigned __int64)(715827883i64 * (a2 - a1)) >> 32) >> 3;
  v6 = v8 + ((unsigned int)v8 >> 31);
  result = 715827883 * (a3 - a1);
  v7 = (a3 - a1) / 48;
  v4 = (a3 - a1) / 48;
  v26 = v6;
  v28 = (a3 - a1) / 48;
  v5 = v6;
  if ( v6 )
  {
    v9 = v4;
    do
    {
      result = v9 / v5;
      v10 = v9 % v5;
      v9 = v5;
      v5 = v10;
    }
    while ( v10 );
    v28 = v9;
    v6 = v26;
    v4 = v28;
  }
  if ( v4 < v7 )
  {
    if ( v4 > 0 )
    {
      v11 = 3 * v4;
      v12 = v27;
      v13 = 48 * v6;
      result = v27 + 16 * v11;
      v24 = 48 * v6;
      v25 = result;
      do
      {
        v15 = v13 + result;
        v14 = result;
        if ( v13 + result == a3 )
          v15 = v12;
        do
        {
          v16 = *(_DWORD *)(v14 + 40) < 0x10u;
          v29 = *(_DWORD *)v14;
          v30 = *(_DWORD *)(v14 + 4);
          v31 = *(_DWORD *)(v14 + 8);
          v17 = v14 + 20;
          v32 = *(_DWORD *)(v14 + 12);
          v33 = *(_DWORD *)(v14 + 16);
          v36 = 15;
          v35 = 0;
          LOBYTE(v34) = 0;
          if ( v16 )
          {
            if ( *(_DWORD *)(v14 + 36) != -1 )
              sub_1002A4B0(&v34, (const void *)(v14 + 20), *(_DWORD *)(v14 + 36) + 1);
          }
          else
          {
            v34 = *(void **)v17;
            *(_DWORD *)v17 = 0;
          }
          v35 = *(_DWORD *)(v14 + 36);
          v36 = *(_DWORD *)(v14 + 40);
          *(_DWORD *)(v14 + 40) = 15;
          *(_DWORD *)(v14 + 36) = 0;
          *(_BYTE *)v17 = 0;
          v38 = 0;
          *(_DWORD *)v14 = *(_DWORD *)v15;
          *(_DWORD *)(v14 + 4) = *(_DWORD *)(v15 + 4);
          *(_DWORD *)(v14 + 8) = *(_DWORD *)(v15 + 8);
          *(_DWORD *)(v14 + 12) = *(_DWORD *)(v15 + 12);
          *(_DWORD *)(v14 + 16) = *(_DWORD *)(v15 + 16);
          if ( v17 != v15 + 20 )
            loc_1000AB40(v17, v15 + 20, 0, -1);
          *(_DWORD *)v15 = v29;
          *(_DWORD *)(v15 + 4) = v30;
          *(_DWORD *)(v15 + 8) = v31;
          *(_DWORD *)(v15 + 12) = v32;
          *(_DWORD *)(v15 + 16) = v33;
          if ( (void **)(v15 + 20) != &v34 )
            loc_1000AB40(v15 + 20, &v34, 0, -1);
          v38 = -1;
          if ( v36 >= 0x10 )
            sub_1002A4AA(v34);
          v19 = (signed int)((unsigned __int64)(715827883i64 * (a3 - v15)) >> 32) >> 3;
          v18 = v19 + ((unsigned int)v19 >> 31);
          v14 = v15;
          if ( v26 >= v18 )
          {
            v20 = v26 - v18;
            v13 = v24;
            v15 = v27 + 48 * v20;
          }
          else
          {
            v13 = v24;
            v15 += v24;
          }
        }
        while ( v15 != v25 );
        v21 = v28 - 1;
        result = v25 - 48;
        v28 = v21;
        v22 = v21 == 0;
        v23 = v21 < 0;
        v12 = v27;
        v25 -= 48;
      }
      while ( !(v23 | v22) );
    }
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10008190) --------------------------------------------------------
int *__fastcall sub_10008190(int a1, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int *result; // eax@3
  int v5; // [sp+Ch] [bp-40h]@1
  int v6; // [sp+10h] [bp-3Ch]@3
  int v7; // [sp+14h] [bp-38h]@3
  int v8; // [sp+18h] [bp-34h]@3
  int v9; // [sp+1Ch] [bp-30h]@3
  void *v10; // [sp+20h] [bp-2Ch]@3
  unsigned int v11; // [sp+34h] [bp-18h]@5
  unsigned int v12; // [sp+3Ch] [bp-10h]@1
  int v13; // [sp+48h] [bp-4h]@1
  int v14; // [sp+4Ch] [bp+0h]@1

  v12 = (unsigned int)&v14 ^ __security_cookie;
  v2 = a2;
  v3 = a1;
  sub_100016C0((int)&v5, a1);
  v13 = 0;
  *(_DWORD *)v3 = *(_DWORD *)v2;
  *(_DWORD *)(v3 + 4) = *(_DWORD *)(v2 + 4);
  *(_DWORD *)(v3 + 8) = *(_DWORD *)(v2 + 8);
  *(_DWORD *)(v3 + 12) = *(_DWORD *)(v2 + 12);
  *(_DWORD *)(v3 + 16) = *(_DWORD *)(v2 + 16);
  if ( v3 + 20 != v2 + 20 )
    loc_1000AB40(v3 + 20, v2 + 20, 0, -1);
  *(_DWORD *)v2 = v5;
  *(_DWORD *)(v2 + 4) = v6;
  *(_DWORD *)(v2 + 8) = v7;
  *(_DWORD *)(v2 + 12) = v8;
  *(_DWORD *)(v2 + 16) = v9;
  result = (int *)&v10;
  if ( (void **)(v2 + 20) != &v10 )
    result = (int *)loc_1000AB40(v2 + 20, &v10, 0, -1);
  if ( v11 >= 0x10 )
    result = (int *)sub_1002A4AA(v10);
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10008260) --------------------------------------------------------
int __fastcall sub_10008260(int a1, int a2, int a3, int a4, int (__cdecl *a5)(_DWORD, _DWORD))
{
  char i; // zf@1
  int v6; // edi@1
  int v7; // esi@1
  int v8; // edx@4
  int v9; // edx@4
  int v10; // ecx@4
  int v11; // edx@8
  int v12; // edx@8
  int v13; // ecx@8
  int v15; // [sp+Ch] [bp-8h]@1
  int v16; // [sp+10h] [bp-4h]@1

  v6 = a2;
  v16 = a1;
  v7 = 2 * a2 + 2;
  v15 = a2;
  for ( i = v7 == a3; v7 < a3; i = v7 == a3 )
  {
    if ( (unsigned __int8)a5(48 * v7 + a1, 48 * v7 + a1 - 48) )
      --v7;
    v9 = v16 + 48 * v7;
    v10 = 48 * v6 + v16;
    *(_DWORD *)v10 = *(_DWORD *)v9;
    *(_DWORD *)(v10 + 4) = *(_DWORD *)(v9 + 4);
    *(_DWORD *)(v10 + 8) = *(_DWORD *)(v9 + 8);
    *(_DWORD *)(v10 + 12) = *(_DWORD *)(v9 + 12);
    *(_DWORD *)(v10 + 16) = *(_DWORD *)(v9 + 16);
    v8 = v9 + 20;
    if ( v10 + 20 != v8 )
      loc_1000AB40(v8, 0, -1);
    a1 = v16;
    v6 = v7;
    v7 = 2 * v7 + 2;
  }
  if ( i )
  {
    v12 = a1 + 48 * a3;
    v13 = 48 * v6 + a1;
    *(_DWORD *)v13 = *(_DWORD *)(v12 - 48);
    *(_DWORD *)(v13 + 4) = *(_DWORD *)(v12 - 44);
    *(_DWORD *)(v13 + 8) = *(_DWORD *)(v12 - 40);
    *(_DWORD *)(v13 + 12) = *(_DWORD *)(v12 - 36);
    *(_DWORD *)(v13 + 16) = *(_DWORD *)(v12 - 32);
    v11 = v12 - 28;
    if ( v13 + 20 != v11 )
      loc_1000AB40(v11, 0, -1);
    v6 = a3 - 1;
  }
  return sub_100086C0(v16, v6, v15, a4, a5);
}

//----- (10008350) --------------------------------------------------------
int __fastcall sub_10008350(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // edi@1
  int i; // esi@1
  int v6; // edx@4

  result = a3;
  v4 = a2;
  for ( i = a1; i != v4; result += 8 )
  {
    if ( result )
    {
      *(_DWORD *)result = 0;
      *(_DWORD *)(result + 4) = 0;
      if ( result != i )
      {
        *(_DWORD *)(result + 4) = *(_DWORD *)(i + 4);
        *(_DWORD *)(i + 4) = 0;
        v6 = *(_DWORD *)result;
        *(_DWORD *)result = *(_DWORD *)i;
        *(_DWORD *)i = v6;
      }
    }
    i += 8;
  }
  return result;
}

//----- (100083A0) --------------------------------------------------------
void __usercall sub_100083A0(int a1<ecx>, int a2<ebx>, int a3)
{
  sub_10008530(a3, a2);
}

//----- (100083B0) --------------------------------------------------------
int __usercall sub_100083B0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int result; // eax@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // edx@1
  int v8; // ST08_4@1
  int v9; // ST0C_4@1
  int v10; // ST10_4@1
  int v23; // esi@5
  char v35; // [sp+Ch] [bp-1Ch]@1
  int v36; // [sp+10h] [bp-18h]@1
  char v37; // [sp+14h] [bp-14h]@1
  int v38; // [sp+18h] [bp-10h]@5
  int v39; // [sp+24h] [bp-4h]@1

  v6 = a1;
  sub_10004DE0((int)&v37, a2);
  v39 = 0;
  result = sub_100088D0(v7, v6, a3, (int)&v35, (int)&v37, v8, v9, v10);
  v5 = v36;
  _EDI = -1;
  if ( v36 )
  {
    result = v36 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      result = v5 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v5 + 4))(v5, _EDX);
    }
  }
  v39 = -1;
  v23 = v38;
  if ( v38 )
  {
    result = v38 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v23)(v23);
      result = v23 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (**)(void))(*(_DWORD *)v23 + 4))();
    }
  }
  return result;
}

//----- (10008470) --------------------------------------------------------
int __userpurge sub_10008470<eax>(int a1<edx>, int *a2<ecx>, int a3<ebx>, int a4, int a5)
{
  int *v5; // esi@1
  int result; // eax@2
  int v7; // edx@2
  int v8; // ecx@3
  char v21; // [sp-10h] [bp-30h]@2
  int v22; // [sp-Ch] [bp-2Ch]@2
  int v23; // [sp-8h] [bp-28h]@2
  int v24; // [sp-4h] [bp-24h]@2
  int v25; // [sp+1Ch] [bp-4h]@1

  v5 = a2;
  v25 = 0;
  if ( *(_DWORD *)(a4 + 84) == 3 )
  {
    sub_10003420(a4, a1, (int)&v21);
    result = sub_10003520(v7, *v5, a3, v21, v22, v23, v24);
  }
  else
  {
    v8 = *a2;
    if ( *(_DWORD *)(a4 + 92) )
      result = (*(int (__stdcall **)(signed int, signed int, _DWORD, int))(*(_DWORD *)v8 + 4))(1, 1, 0, a4 + 92);
    else
      result = (*(int (__stdcall **)(signed int, _DWORD, _DWORD, int))(*(_DWORD *)v8 + 4))(1, 0, 0, v8 + 92);
  }
  v25 = -1;
  if ( a5 )
  {
    _EDI = -1;
    _ECX = a5 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))a5)(a5);
      result = a5 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (**)(void))(*(_DWORD *)a5 + 4))();
    }
  }
  return result;
}

//----- (10008530) --------------------------------------------------------
void __usercall sub_10008530(int a1<ecx>, int a2<ebx>)
{
  int ebp0; // ebp@0
  int v3; // edi@1
  int v4; // esi@1
  unsigned int v5; // [sp-4h] [bp-4Ch]@1
  int v6; // [sp+14h] [bp-34h]@1
  unsigned int v7; // [sp+34h] [bp-14h]@1
  unsigned int *v8; // [sp+38h] [bp-10h]@1
  int v9; // [sp+44h] [bp-4h]@1
  int v10; // [sp+48h] [bp+0h]@1

  v7 = (unsigned int)&v10 ^ __security_cookie;
  v5 = (unsigned int)&v10 ^ __security_cookie;
  v8 = &v5;
  v3 = a1;
  v4 = *(_DWORD *)(a1 + 20);
  v6 = a1;
  sub_1002B62D(ebp0, v4 + 100);
  v9 = -1;
  if ( *(_DWORD *)(v4 + 84) == 4 )
  {
    sub_1002B6D6();
  }
  else
  {
    *(_DWORD *)(v4 + 84) = 1;
    sub_1002B6D6();
    v9 = 1;
    sub_10008620(v3, a2, v6);
  }
}
// 10074200: using guessed type int __security_cookie;

//----- (10008620) --------------------------------------------------------
int __userpurge sub_10008620<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // esi@1
  int v6; // eax@1
  char v19; // [sp+Ch] [bp-18h]@1
  int v20; // [sp+10h] [bp-14h]@1
  int v21; // [sp+20h] [bp-4h]@1

  v5 = a1;
  v6 = sub_100045A0((void *)(a1 + 28), (int)&v19);
  v21 = 0;
  result = sub_100083B0(v6, v5 + 20, a2);
  v21 = -1;
  v4 = v20;
  if ( v20 )
  {
    _EDI = -1;
    _ECX = v20 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v4)(v4);
      result = v4 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (**)(void))(*(_DWORD *)v4 + 4))();
    }
  }
  return result;
}

//----- (100086C0) --------------------------------------------------------
int __fastcall sub_100086C0(int a1, int a2, int a3, int a4, int (__cdecl *a5)(_DWORD, _DWORD))
{
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // edi@2
  int v8; // edi@3
  int v9; // ecx@3
  int result; // eax@7
  int v11; // ecx@7
  int v12; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = (a2 - 1) / 2;
  v12 = a1;
  if ( a3 < a2 )
  {
    do
    {
      v7 = a1 + 48 * v6;
      if ( !(unsigned __int8)a5(a1 + 48 * v6, a4) )
        break;
      v9 = 48 * v5 + v12;
      *(_DWORD *)v9 = *(_DWORD *)v7;
      *(_DWORD *)(v9 + 4) = *(_DWORD *)(v7 + 4);
      *(_DWORD *)(v9 + 8) = *(_DWORD *)(v7 + 8);
      *(_DWORD *)(v9 + 12) = *(_DWORD *)(v7 + 12);
      *(_DWORD *)(v9 + 16) = *(_DWORD *)(v7 + 16);
      v8 = v7 + 20;
      if ( v9 + 20 != v8 )
        loc_1000AB40(v8, 0, -1);
      a1 = v12;
      v5 = v6;
      v6 = (v6 - 1) / 2;
    }
    while ( a3 < v5 );
    a1 = v12;
  }
  v11 = 48 * v5 + a1;
  *(_DWORD *)v11 = *(_DWORD *)a4;
  *(_DWORD *)(v11 + 4) = *(_DWORD *)(a4 + 4);
  *(_DWORD *)(v11 + 8) = *(_DWORD *)(a4 + 8);
  *(_DWORD *)(v11 + 12) = *(_DWORD *)(a4 + 12);
  result = *(_DWORD *)(a4 + 16);
  *(_DWORD *)(v11 + 16) = result;
  if ( v11 + 20 != a4 + 20 )
    result = loc_1000AB40(a4 + 20, 0, -1);
  return result;
}

//----- (10008790) --------------------------------------------------------
int __fastcall sub_10008790(int a1, int a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  int result; // eax@3
  char v7; // [sp+14h] [bp-40h]@1
  void *v8; // [sp+28h] [bp-2Ch]@4
  unsigned int v9; // [sp+3Ch] [bp-18h]@3
  unsigned int v10; // [sp+44h] [bp-10h]@1
  int v11; // [sp+50h] [bp-4h]@1
  int v12; // [sp+54h] [bp+0h]@1

  v10 = (unsigned int)&v12 ^ __security_cookie;
  v4 = a2;
  v3 = a1;
  v5 = a2 - 48;
  sub_100016C0((int)&v7, a2 - 48);
  v11 = 0;
  *(_DWORD *)v5 = *(_DWORD *)v3;
  *(_DWORD *)(v5 + 4) = *(_DWORD *)(v3 + 4);
  *(_DWORD *)(v5 + 8) = *(_DWORD *)(v3 + 8);
  *(_DWORD *)(v5 + 12) = *(_DWORD *)(v3 + 12);
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v3 + 16);
  if ( v5 + 20 != v3 + 20 )
    loc_1000AB40(v5 + 20, v3 + 20, 0, -1);
  result = sub_10008260(v3, 0, (v4 - v3 - 48) / 48, (int)&v7, a3);
  if ( v9 >= 0x10 )
    result = sub_1002A4AA(v8);
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10008860) --------------------------------------------------------
int __fastcall sub_10008860(int a1, int a2, int a3)
{
  int v3; // ebx@2
  int v4; // edi@2
  int v5; // esi@2
  int v6; // eax@3
  int result; // eax@6
  int v8; // [sp+0h] [bp-4h]@1

  v8 = a1;
  if ( a1 == a2 )
  {
    result = a3;
  }
  else
  {
    v3 = a3;
    v4 = a3 + 20;
    v5 = a2 + 20;
    do
    {
      v6 = *(_DWORD *)(v5 - 68);
      v5 -= 48;
      v3 -= 48;
      v4 -= 48;
      *(_DWORD *)v3 = v6;
      *(_DWORD *)(v3 + 4) = *(_DWORD *)(v5 - 16);
      *(_DWORD *)(v4 - 12) = *(_DWORD *)(v5 - 12);
      *(_DWORD *)(v4 - 8) = *(_DWORD *)(v5 - 8);
      *(_DWORD *)(v4 - 4) = *(_DWORD *)(v5 - 4);
      if ( v4 != v5 )
        loc_1000AB40(v4, v5, 0, -1);
    }
    while ( v5 - 20 != v8 );
    result = v3;
  }
  return result;
}

//----- (100088D0) --------------------------------------------------------
int __userpurge sub_100088D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8)
{
  int v9; // ST08_4@1
  int v10; // ST0C_4@1
  int v11; // ST10_4@1
  int v12; // ST14_4@1

  sub_10008A40(a1, a2, a3, a4, a5, v9, v10, v11, v12);
  return a4;
}

//----- (10008940) --------------------------------------------------------
int __thiscall sub_10008940(void *this, int a2)
{
  void *v2; // edi@1
  int v3; // ecx@2
  int v5; // [sp-8h] [bp-18h]@1
  int v6; // [sp-4h] [bp-14h]@1

  v2 = this;
  v5 = 0;
  v6 = 0;
  if ( &v5 != (int *)a2 )
  {
    v6 = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a2 + 4) = 0;
    v3 = v5;
    v5 = *(_DWORD *)a2;
    *(_DWORD *)a2 = v3;
  }
  return sub_100023C0((int)((char *)v2 + 4), v5, v6);
}

//----- (10008990) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10008990())(char)
{
  return &off_100759B0;
}
// 100759B0: using guessed type int (__stdcall **off_100759B0)(char);

//----- (100089A0) --------------------------------------------------------
int __userpurge sub_100089A0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // esi@1
  int v6; // ecx@3
  int result; // eax@9
  int v8; // [sp-4h] [bp-30h]@6
  int v9; // [sp+1Ch] [bp-10h]@1

  v9 = a2;
  v5 = sub_1002ADB1(a1, a2, a4, a3, 40);
  if ( !v5 )
    sub_10029530();
  *(_DWORD *)v5 = off_1006801C;
  v6 = *(_DWORD *)(a4 + 16);
  if ( v6 )
  {
    if ( v6 == a4 )
      v8 = v5 + 8;
    else
      v8 = 0;
    *(_DWORD *)(v5 + 24) = (**(int (__stdcall ***)(_DWORD))v6)(v8);
  }
  else
  {
    *(_DWORD *)(v5 + 24) = 0;
  }
  result = v9;
  *(_DWORD *)(v9 + 16) = v5;
  return result;
}
// 1006801C: using guessed type int (__stdcall *off_1006801C[2])(int);

//----- (10008A40) --------------------------------------------------------
int __userpurge sub_10008A40<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // edi@1
  int v10; // eax@3
  int v11; // eax@4
  int v13; // [sp-8h] [bp-30h]@4
  int v14; // [sp-4h] [bp-2Ch]@3
  char v15; // [sp+Ch] [bp-1Ch]@2
  int v16; // [sp+18h] [bp-10h]@1
  int v17; // [sp+24h] [bp-4h]@1

  v9 = a2;
  v17 = 0;
  v16 = 0;
  if ( !*(_DWORD *)a2 )
  {
    sub_1002FFB9((int)&v15, (unsigned int)"then() cannot be called on a default constructed task.");
    sub_100355DB((int)&v15, (int)&unk_1006D8B8);
  }
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_10006BC0(a1, a4, v9, a2);
  v17 = 0;
  v16 = 1;
  sub_10009800(a4, 2);
  *(_BYTE *)(*(_DWORD *)a4 + 88) = *(_BYTE *)(*(_DWORD *)v9 + 88) != 0;
  *(_BYTE *)(*(_DWORD *)a4 + 89) = 0;
  *(_BYTE *)(*(_DWORD *)a4 + 90) = 0;
  v10 = sub_1002CB8B(a3, v9, 0x38u);
  if ( v10 )
    v11 = sub_10008BF0(v10, v9, a4, a5, v13, v14);
  else
    v11 = 0;
  sub_10009430(*(void **)v9, v11);
  return a4;
}

//----- (10008B20) --------------------------------------------------------
int __userpurge sub_10008B20<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4)
{
  int v4; // ebx@1
  int v5; // esi@1
  int v6; // ecx@5
  int v7; // eax@8

  v4 = a2;
  v5 = a4;
  if ( !a4 )
  {
    v5 = sub_1002ADB1(a1, a2, a2, a3, 40);
    if ( !v5 )
      sub_10029530();
  }
  if ( v5 )
  {
    *(_DWORD *)v5 = off_1006801C;
    v6 = *(_DWORD *)(v4 + 24);
    if ( v6 )
    {
      if ( v6 == v4 + 8 )
        v7 = (**(int (__stdcall ***)(_DWORD))v6)(v5 + 8);
      else
        v7 = (**(int (__stdcall ***)(_DWORD))v6)(0);
      *(_DWORD *)(v5 + 24) = v7;
    }
    else
    {
      *(_DWORD *)(v5 + 24) = 0;
    }
  }
  return v5;
}
// 1006801C: using guessed type int (__stdcall *off_1006801C[2])(int);

//----- (10008BC0) --------------------------------------------------------
char __thiscall sub_10008BC0(void *this, int a2)
{
  return sub_10008DA0((char *)this + 8, a2);
}

//----- (10008BD0) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10008BD0())(char)
{
  return &off_10075978;
}
// 10075978: using guessed type int (__stdcall **off_10075978)(char);

//----- (10008BE0) --------------------------------------------------------
int __thiscall sub_10008BE0(void *this)
{
  return (int)((char *)this + 8);
}

//----- (10008BF0) --------------------------------------------------------
int __thiscall sub_10008BF0(int this, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // esi@1

  v7 = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_BYTE *)(this + 25) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = &off_100680E0;
  sub_10004DE0(this + 32, a3);
  *(_DWORD *)(v7 + 4) = sub_10008E60;
  *(_BYTE *)(v7 + 16) = 1;
  *(_DWORD *)v7 = &off_10068014;
  sub_10004DE0(v7 + 40, a2);
  sub_10004DE0(v7 + 48, a4);
  *(_BYTE *)(v7 + 25) = 1;
  *(_DWORD *)(v7 + 28) = 16;
  return v7;
}
// 10068014: using guessed type int (__stdcall *off_10068014)(char);
// 100680E0: using guessed type int (__stdcall *off_100680E0)(char);

//----- (10008C60) --------------------------------------------------------
int __thiscall sub_10008C60(int this)
{
  int v2; // edi@1
  int v3; // esi@1
  int result; // eax@2
  int v17; // edi@5
  int v30; // edi@9

  v3 = this;
  *(_DWORD *)this = &off_10068014;
  v2 = *(_DWORD *)(this + 52);
  _EBX = -1;
  if ( v2 )
  {
    result = v2 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v2)(v2);
      result = v2 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v2 + 4))(v2, _EDX);
    }
  }
  v17 = *(_DWORD *)(v3 + 44);
  if ( v17 )
  {
    result = v17 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v17)(v17);
      result = v17 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v17 + 4))(v17, _EDX);
    }
  }
  *(_DWORD *)v3 = &off_100680E0;
  v30 = *(_DWORD *)(v3 + 36);
  if ( v30 )
  {
    result = v30 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v30)(v30);
      result = v30 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v30 + 4))(v30);
    }
  }
  *(_DWORD *)v3 = &off_10061E90;
  return result;
}
// 10061E90: using guessed type int (__stdcall *off_10061E90)(char);
// 10068014: using guessed type int (__stdcall *off_10068014)(char);
// 100680E0: using guessed type int (__stdcall *off_100680E0)(char);

//----- (10008D00) --------------------------------------------------------
void *__thiscall sub_10008D00(int this, char a2)
{
  int v2; // ecx@1
  int v3; // edi@1
  void *v4; // esi@1
  int v5; // ecx@3

  v4 = (void *)this;
  v3 = this + 8;
  *(_DWORD *)this = off_1006801C;
  v2 = *(_DWORD *)(this + 24);
  if ( v2 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v2 + 16))(v2 != v3);
    *(_DWORD *)(v3 + 16) = 0;
  }
  v5 = *(_DWORD *)(v3 + 16);
  if ( v5 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v5 + 16))(v5 != v3);
    *(_DWORD *)(v3 + 16) = 0;
  }
  *(_DWORD *)v4 = off_10068098;
  if ( a2 & 1 )
    sub_1002A4AA(v4);
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1006801C: using guessed type int (__stdcall *off_1006801C[2])(int);
// 10068098: using guessed type int (*off_10068098[5])();

//----- (10008D70) --------------------------------------------------------
int __userpurge sub_10008D70<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  int v4; // esi@1

  v4 = a1;
  sub_10008C60(a1);
  if ( a4 & 1 )
    sub_1002CC50(a2, a3, v4);
  return v4;
}

//----- (10008DA0) --------------------------------------------------------
char __thiscall sub_10008DA0(void *this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v4; // eax@2
  char v20; // [sp-8h] [bp-28h]@3
  int v21; // [sp-4h] [bp-24h]@3
  int v22; // [sp+Ch] [bp-14h]@1
  int v23; // [sp+10h] [bp-10h]@1
  int v24; // [sp+1Ch] [bp-4h]@3

  v2 = (int)this;
  v3 = 0;
  v22 = 0;
  v23 = 0;
  if ( &v22 != (int *)a2 )
  {
    v3 = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a2 + 4) = 0;
    v4 = *(_DWORD *)a2;
    v23 = v3;
    v22 = v4;
    *(_DWORD *)a2 = 0;
  }
  v24 = 0;
  sub_10004DE0((int)&v20, (int)&v22);
  sub_10006C80(v2, v20, v21);
  v24 = -1;
  if ( v3 )
  {
    _EDI = -1;
    _ECX = v3 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v3)(v3);
      _EAX = v3 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
    }
  }
  return 0;
}

//----- (10008E60) --------------------------------------------------------
int __usercall sub_10008E60<eax>(int a1<eax>, int a2)
{
  int v2; // esi@1
  int v4; // edx@4
  unsigned int v5; // [sp-18h] [bp-54h]@1
  int v6; // [sp-14h] [bp-50h]@3
  int v7; // [sp-10h] [bp-4Ch]@3
  int v8; // [sp-Ch] [bp-48h]@3
  char v9; // [sp-8h] [bp-44h]@3
  int v10; // [sp+0h] [bp-3Ch]@4
  int v11; // [sp+4h] [bp-38h]@4
  int v12; // [sp+8h] [bp-34h]@1
  unsigned int v13; // [sp+28h] [bp-14h]@1
  unsigned int *v14; // [sp+2Ch] [bp-10h]@1
  int v15; // [sp+30h] [bp-Ch]@1
  int (__cdecl *v16)(int, int); // [sp+34h] [bp-8h]@1
  int v17; // [sp+38h] [bp-4h]@1
  _DWORD *v18; // [sp+3Ch] [bp+0h]@1

  v18 = &v18;
  v17 = -1;
  v16 = sub_1005AA10;
  v15 = a1;
  v13 = (unsigned int)&v18 ^ __security_cookie;
  v5 = (unsigned int)&v18 ^ __security_cookie;
  v14 = &v5;
  v2 = *(_DWORD *)(a2 + 32);
  v12 = a2;
  sub_1002B62D((int)&v18, v2 + 100);
  v17 = -1;
  if ( *(_DWORD *)(v2 + 84) == 4 )
  {
    sub_1002B6D6();
  }
  else
  {
    *(_DWORD *)(v2 + 84) = 1;
    sub_1002B6D6();
    v17 = 1;
    LOBYTE(v10) = 0;
    LOBYTE(v11) = 0;
    sub_10008F70(v4, a2, a2, v11, v10);
  }
  return sub_1002A49B(v8, v6, v7, (unsigned int)&v18 ^ v13, v9);
}
// 1005AA10: using guessed type int __cdecl sub_1005AA10(int, int);
// 10074200: using guessed type int __security_cookie;

//----- (10008F70) --------------------------------------------------------
void __userpurge sub_10008F70(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // edx@1
  int v6; // ebx@1
  int ebp0; // ebp@0
  int v9; // esi@1
  int v10; // ebx@1
  int v11; // eax@1
  int v26; // eax@9
  int v27; // ebx@11
  int v28; // eax@11
  int v29; // edx@15
  void **v43; // [sp-20h] [bp-94h]@9
  char v44; // [sp-1Ch] [bp-90h]@9
  int v45; // [sp-18h] [bp-8Ch]@11
  int v46; // [sp-14h] [bp-88h]@11
  char v47; // [sp-8h] [bp-7Ch]@6
  int v48; // [sp-4h] [bp-78h]@6
  char v49; // [sp+10h] [bp-64h]@1
  int v50; // [sp+14h] [bp-60h]@1
  int v51; // [sp+18h] [bp-5Ch]@1
  char *v52; // [sp+1Ch] [bp-58h]@1
  int v53; // [sp+20h] [bp-54h]@1
  char v54; // [sp+24h] [bp-50h]@1
  int v55; // [sp+28h] [bp-4Ch]@1
  char v56; // [sp+2Ch] [bp-48h]@11
  int v57; // [sp+3Ch] [bp-38h]@14
  unsigned int v58; // [sp+60h] [bp-14h]@1
  int v59; // [sp+70h] [bp-4h]@1

  v58 = (unsigned int)&v49 ^ __security_cookie;
  v10 = a2;
  v53 = a2;
  v50 = 0;
  v51 = 0;
  sub_10006BC0(a1, (int)&v50, a3, a2);
  v59 = 0;
  v11 = sub_10004DE0((int)&v54, v10 + 40);
  v9 = *(_DWORD *)(v11 + 4);
  *(_DWORD *)(v11 + 4) = v51;
  v5 = *(_DWORD *)v11;
  *(_DWORD *)v11 = v50;
  v6 = v55;
  _EDI = -1;
  v51 = v9;
  v52 = (char *)v5;
  v50 = v5;
  if ( v55 )
  {
    _EAX = v55 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v6)(v6);
      _EAX = v6 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v6 + 4))(v6, _EDX);
      v5 = (int)v52;
    }
  }
  v52 = &v47;
  *(_DWORD *)&v47 = 0;
  v48 = 0;
  if ( (int *)&v47 != &v50 )
  {
    v48 = v9;
    v9 = 0;
    v51 = 0;
    *(_DWORD *)&v47 = v5;
    v50 = 0;
  }
  if ( &v47 )
  {
    v43 = &off_10067FF8;
    sub_10004DE0((int)&v44, v53 + 48);
    v26 = (int)&v43;
  }
  else
  {
    v26 = 0;
  }
  LOBYTE(v59) = 1;
  v28 = sub_10005FD0((int)&v56, (char)v43, *(int *)&v44, v45, v46, v26);
  LOBYTE(v59) = 4;
  v27 = *(_DWORD *)(v53 + 32);
  *(_BYTE *)(v27 + 152) = sub_10006090(v28, v47, v48);
  sub_1002B62D(ebp0, v27 + 100);
  LOBYTE(v59) = 4;
  if ( *(_DWORD *)(v27 + 84) == 4 )
  {
    sub_1002B6D6();
  }
  else
  {
    *(_DWORD *)(v27 + 84) = 3;
    sub_1002B6D6();
    sub_1002C5B4(ebp0);
    sub_1000A690(v27);
  }
  LOBYTE(v59) = 0;
  if ( v57 )
  {
    v29 = *(_DWORD *)v57;
    v48 = v57 != (_DWORD)&v56;
    (*(void (__stdcall **)(int))(v29 + 16))(v48);
    v57 = 0;
  }
  v59 = -1;
  if ( v9 )
  {
    _EAX = v9 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v9)(v9);
      _EAX = v9 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (**)(void))(*(_DWORD *)v9 + 4))();
    }
  }
}
// 10067FF8: using guessed type void *off_10067FF8;
// 10074200: using guessed type int __security_cookie;

//----- (100091B0) --------------------------------------------------------
int __userpurge sub_100091B0<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v3; // edi@1
  int v4; // ecx@2
  int v6; // [sp-8h] [bp-18h]@1
  int v7; // [sp-4h] [bp-14h]@1

  v3 = a1;
  v6 = 0;
  v7 = 0;
  if ( &v6 != (int *)a3 )
  {
    v7 = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(a3 + 4) = 0;
    v4 = v6;
    v6 = *(_DWORD *)a3;
    *(_DWORD *)a3 = v4;
  }
  return sub_10008470((int)&v6, (int *)(v3 + 4), a2, v6, v7);
}

//----- (10009200) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10009200())(char)
{
  return &off_10075940;
}
// 10075940: using guessed type int (__stdcall **off_10075940)(char);

//----- (10009210) --------------------------------------------------------
void *__thiscall sub_10009210(int this, char a2)
{
  int v2; // edi@1
  void *v3; // esi@1

  v3 = (void *)this;
  *(_DWORD *)this = &off_10067FF8;
  v2 = *(_DWORD *)(this + 8);
  if ( v2 )
  {
    _EBX = -1;
    _EDX = v2 + 4;
    _EAX = -1;
    __asm { lock xadd [edx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v2)(v2);
      _EAX = v2 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 4))(v2);
    }
  }
  *(_DWORD *)v3 = off_10068098;
  if ( a2 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067FF8: using guessed type void *off_10067FF8;
// 10068098: using guessed type int (*off_10068098[5])();

//----- (10009270) --------------------------------------------------------
int __thiscall sub_10009270(int this, char a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_100680F0;
  if ( *(_DWORD *)(this + 24) >= 0x10u )
    sub_1002A4AA(*(LPVOID *)(this + 4));
  *(_DWORD *)(v2 + 24) = 15;
  *(_DWORD *)(v2 + 20) = 0;
  *(_BYTE *)(v2 + 4) = 0;
  *(_DWORD *)v2 = &off_100683B4;
  if ( a2 & 1 )
    sub_1002A4AA((LPVOID)v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100680F0: using guessed type int (__stdcall *off_100680F0)(char);
// 100683B4: using guessed type int (__stdcall *off_100683B4)(char);

//----- (10009300) --------------------------------------------------------
int __usercall sub_10009300<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4)
{
  int v4; // eax@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // esi@3
  int v9; // [sp+20h] [bp-10h]@1

  v9 = a1;
  v5 = a2;
  v4 = sub_1002ADB1(a1, a2, a2, a3, 28);
  v6 = v4;
  if ( v4 )
  {
    *(_DWORD *)(v4 + 4) = 1;
    *(_DWORD *)(v4 + 8) = 1;
    *(_DWORD *)v4 = &off_100681D8;
    if ( v4 != -12 )
    {
      v7 = *(_DWORD *)a4;
      *(_DWORD *)(v4 + 12) = 0;
      sub_1002FD39(v4 + 16, v9);
      *(_DWORD *)(v6 + 24) = v7;
    }
  }
  else
  {
    v6 = 0;
  }
  *(_DWORD *)v5 = v6 + 12;
  *(_DWORD *)(v5 + 4) = v6;
  return v5;
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);
// 100681D8: using guessed type int (*off_100681D8)();

//----- (100093C0) --------------------------------------------------------
void *__thiscall sub_100093C0(void *this, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  void *v4; // esi@1
  int v5; // edi@3
  void *result; // eax@7
  char v21; // [sp+8h] [bp-8h]@1

  v2 = 0;
  v4 = this;
  v3 = 0;
  if ( &v21 != (char *)a2 )
  {
    v2 = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a2 + 4) = 0;
    v3 = *(_DWORD *)a2;
    *(_DWORD *)a2 = 0;
  }
  v5 = *((_DWORD *)v4 + 1);
  *((_DWORD *)v4 + 1) = v2;
  *(_DWORD *)v4 = v3;
  if ( v5 )
  {
    _EBX = -1;
    _ECX = v5 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      _EAX = v5 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
    }
    result = v4;
  }
  else
  {
    result = v4;
  }
  return result;
}

//----- (10009430) --------------------------------------------------------
void __thiscall sub_10009430(void *this, int a2)
{
  int v2; // eax@1
  signed int v3; // ebx@1
  int ebp0; // ebp@0
  void *v5; // esi@1
  int v6; // ebx@7
  int v7; // ebx@8
  int v8; // ebx@10
  int v9; // eax@10
  int v24; // ebx@15
  int v25; // eax@15
  int v40; // edi@20
  int *v41; // eax@20
  char v56; // [sp+10h] [bp-48h]@10
  int v57; // [sp+14h] [bp-44h]@10
  char v58; // [sp+18h] [bp-40h]@20
  int v59; // [sp+1Ch] [bp-3Ch]@20
  char v60; // [sp+20h] [bp-38h]@15
  int v61; // [sp+24h] [bp-34h]@15
  unsigned int v62; // [sp+44h] [bp-14h]@1
  int v63; // [sp+54h] [bp-4h]@10
  int v64; // [sp+58h] [bp+0h]@1

  v62 = (unsigned int)&v64 ^ __security_cookie;
  v5 = this;
  v3 = 0;
  sub_1002B62D(ebp0, (int)((char *)this + 100));
  v2 = *((_DWORD *)v5 + 21);
  if ( v2 != 3 )
  {
    if ( v2 != 4 )
    {
      *(_DWORD *)(a2 + 20) = *((_DWORD *)v5 + 33);
      *((_DWORD *)v5 + 33) = a2;
      goto LABEL_7;
    }
    if ( !*(_BYTE *)(a2 + 25) )
    {
      v3 = 2;
      goto LABEL_7;
    }
  }
  v3 = 1;
LABEL_7:
  sub_1002B6D6();
  v6 = v3 - 1;
  if ( v6 )
  {
    v7 = v6 - 1;
    if ( v7 )
    {
      if ( v7 == 1 )
      {
        v9 = (*(int (__thiscall **)(int, char *))(*(_DWORD *)a2 + 4))(a2, &v56);
        v63 = 4;
        (*(void (__stdcall **)(signed int, signed int, signed int, char *))(**(_DWORD **)v9 + 4))(
          1,
          1,
          1,
          (char *)v5 + 92);
        v63 = -1;
        v8 = v57;
        if ( v57 )
        {
          _ESI = -1;
          _ECX = v57 + 4;
          _EAX = -1;
          __asm { lock xadd [ecx], eax }
          if ( _ZF )
          {
            (**(void (__thiscall ***)(_DWORD))v8)(v8);
            _EAX = v8 + 8;
            __asm { lock xadd [eax], esi }
            if ( _ESI == 1 )
              (*(void (__thiscall **)(int))(*(_DWORD *)v8 + 4))(v8);
          }
        }
        (**(void (__thiscall ***)(_DWORD, _DWORD))a2)(a2, 1);
      }
    }
    else
    {
      v25 = (*(int (__thiscall **)(int, char *))(*(_DWORD *)a2 + 4))(a2, &v60);
      v63 = 3;
      (*(void (__stdcall **)(signed int, _DWORD, _DWORD, int))(**(_DWORD **)v25 + 4))(1, 0, 0, *(_DWORD *)v25 + 92);
      v63 = -1;
      v24 = v61;
      if ( v61 )
      {
        _ESI = -1;
        _ECX = v61 + 4;
        _EAX = -1;
        __asm { lock xadd [ecx], eax }
        if ( _ZF )
        {
          (**(void (__thiscall ***)(_DWORD))v24)(v24);
          _EAX = v24 + 8;
          __asm { lock xadd [eax], esi }
          if ( _ESI == 1 )
            (*(void (__thiscall **)(int))(*(_DWORD *)v24 + 4))(v24);
        }
      }
      (**(void (__thiscall ***)(_DWORD, _DWORD))a2)(a2, 1);
    }
  }
  else
  {
    v41 = (int *)(*(int (__thiscall **)(_DWORD, char *))(*(_DWORD *)a2 + 4))(a2, &v58);
    v63 = 0;
    sub_1000A5C0(*v41, 0, a2, a2, *(_DWORD *)(a2 + 28));
    v63 = -1;
    v40 = v59;
    if ( v59 )
    {
      _ESI = -1;
      _ECX = v59 + 4;
      _EAX = -1;
      __asm { lock xadd [ecx], eax }
      if ( _ZF )
      {
        (**(void (__thiscall ***)(_DWORD))v40)(v40);
        _EAX = v40 + 8;
        __asm { lock xadd [eax], esi }
        if ( _ESI == 1 )
          (*(void (**)(void))(*(_DWORD *)v40 + 4))();
      }
    }
  }
}
// 10074200: using guessed type int __security_cookie;

//----- (100095F0) --------------------------------------------------------
int __thiscall sub_100095F0(int this)
{
  return (**(int (__thiscall ***)(_DWORD, _DWORD))(this + 12))(this + 12, 0);
}

//----- (10009600) --------------------------------------------------------
void *__thiscall sub_10009600(void *this, int a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_1006820C;
  sub_1002C08C((int)((char *)this + 4));
  sub_1002C08C((int)((char *)v2 + 44));
  *((_DWORD *)v2 + 21) = 0;
  *((_WORD *)v2 + 44) = 0;
  *((_BYTE *)v2 + 90) = 0;
  *((_DWORD *)v2 + 23) = 0;
  *((_DWORD *)v2 + 24) = 0;
  sub_1002B5CC((int)((char *)v2 + 100));
  *((_DWORD *)v2 + 33) = 0;
  *((_DWORD *)v2 + 35) = 0;
  *((_DWORD *)v2 + 36) = 0;
  *((_DWORD *)v2 + 37) = 0;
  *((_DWORD *)v2 + 34) = a2;
  if ( a2 != 2 )
  {
    _EAX = a2 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  return v2;
}
// 1006820C: using guessed type int (__stdcall *off_1006820C)(char);

//----- (100096D0) --------------------------------------------------------
int __usercall sub_100096D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v3; // eax@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ebx@2
  int *v8; // [sp+20h] [bp-10h]@1

  v8 = (int *)a1;
  v4 = a2;
  v3 = sub_1002ADB1(a1, a2, a3, a2, 168);
  v5 = v3;
  if ( v3 )
  {
    *(_DWORD *)(v3 + 4) = 1;
    *(_DWORD *)(v3 + 8) = 1;
    v6 = v3 + 12;
    *(_DWORD *)v3 = &off_10068FB0;
    if ( v3 != -12 )
    {
      sub_10009600((void *)(v3 + 12), *v8);
      *(_DWORD *)v6 = &off_10068204;
    }
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)v4 = v5 + 12;
  *(_DWORD *)(v4 + 4) = v5;
  return v4;
}
// 10068204: using guessed type int (__stdcall *off_10068204)(char);
// 10068FB0: using guessed type int (*off_10068FB0)();

//----- (10009780) --------------------------------------------------------
int __usercall sub_10009780<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v4; // esi@1
  int v5; // [sp+8h] [bp-8h]@1
  unsigned int v6; // [sp+Ch] [bp-4h]@1
  int v7; // [sp+10h] [bp+0h]@1

  v6 = (unsigned int)&v7 ^ __security_cookie;
  v5 = a1;
  v4 = a2;
  sub_100096D0((int)&v5, a2, a3);
  return v4;
}
// 10074200: using guessed type int __security_cookie;

//----- (100097C0) --------------------------------------------------------
char __cdecl sub_100097C0(int a1)
{
  return a1 && a1 != 2;
}

//----- (100097E0) --------------------------------------------------------
int __cdecl sub_100097E0(int a1)
{
  return (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD, int))(*(_DWORD *)a1 + 4))(0, 0, 0, a1 + 92);
}

//----- (10009800) --------------------------------------------------------
int __thiscall sub_10009800(int this, int a2)
{
  int result; // eax@1
  int v4; // ecx@1
  int v5; // ebx@1
  int v7; // esi@3
  int v19; // esi@7
  int v31; // esi@12
  char v32; // [sp+10h] [bp-14h]@1
  char v33; // [sp+18h] [bp-Ch]@1
  int v34; // [sp+1Ch] [bp-8h]@7

  v5 = this;
  result = sub_10009780(a2, (int)&v33, this);
  v4 = 0;
  _EDX = 0;
  if ( &v32 != (char *)result )
  {
    _EDX = *(_DWORD *)(result + 4);
    *(_DWORD *)(result + 4) = 0;
    v4 = *(_DWORD *)result;
    *(_DWORD *)result = 0;
  }
  v7 = *(_DWORD *)(v5 + 4);
  _EDI = -1;
  *(_DWORD *)(v5 + 4) = _EDX;
  *(_DWORD *)v5 = v4;
  if ( v7 )
  {
    result = v7 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v7)(v7);
      result = v7 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v7 + 4))(v7, _EDX);
    }
  }
  v19 = v34;
  if ( v34 )
  {
    result = v34 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v19)(v19);
      result = v19 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v19 + 4))(v19);
    }
  }
  if ( a2 != 2 )
  {
    v31 = *(_DWORD *)v5;
    result = sub_1002B396(_EDX, *(_DWORD *)(*(_DWORD *)v5 + 136), v5, (int)sub_100097E0, *(_DWORD *)v5, 1);
    *(_DWORD *)(v31 + 140) = result;
  }
  return result;
}

//----- (100098C0) --------------------------------------------------------
int __thiscall sub_100098C0(void *this, int a2)
{
  int v2; // esi@1
  int v4; // [sp+14h] [bp-1Ch]@1
  int v5; // [sp+18h] [bp-18h]@1
  unsigned int v6; // [sp+1Ch] [bp-14h]@1
  int v7; // [sp+2Ch] [bp-4h]@1
  int v8; // [sp+30h] [bp+0h]@1

  v6 = (unsigned int)&v8 ^ __security_cookie;
  v2 = (int)this;
  v4 = 0;
  v5 = 0;
  sub_1002FD89((int)&v4);
  v7 = 0;
  if ( a2 )
  {
    sub_1002FD59(&v4);
    sub_1002FD39(v2, (int)&v4);
    v7 = -1;
    sub_1002FDDA((int)&v4);
  }
  else
  {
    sub_1002FD39(v2, (int)&v4);
    v7 = -1;
    sub_1002FDDA((int)&v4);
  }
  return v2;
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);
// 10074200: using guessed type int __security_cookie;

//----- (10009980) --------------------------------------------------------
int __userpurge sub_10009980<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10060320;
  return v4;
}
// 10060320: using guessed type int (__stdcall *off_10060320)(char);

//----- (100099A0) --------------------------------------------------------
int __thiscall sub_100099A0(void *this)
{
  int v1; // ecx@1
  void *v2; // esi@1
  int result; // eax@2

  v2 = this;
  v1 = *(_DWORD *)this;
  if ( v1 )
  {
    result = v1 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      result = (*(int (**)(void))(*(_DWORD *)v1 + 4))();
  }
  *(_DWORD *)v2 = 0;
  return result;
}

//----- (100099D0) --------------------------------------------------------
void *__thiscall sub_100099D0(void *this)
{
  *(_DWORD *)this = 0;
  return this;
}

//----- (100099E0) --------------------------------------------------------
int __fastcall sub_100099E0(int a1, int a2, unsigned int a3)
{
  int v3; // esi@2
  char v4; // cf@4
  unsigned __int8 v5; // cf@6
  unsigned __int8 v6; // al@8
  unsigned __int8 v7; // al@10
  unsigned __int8 v8; // al@12

  if ( !a3 )
    return 0;
  v3 = a3 - 4;
  if ( a3 < 4 )
  {
LABEL_5:
    if ( v3 == -4 )
      return 0;
  }
  else
  {
    while ( *(_DWORD *)a1 == *(_DWORD *)a2 )
    {
      a1 += 4;
      a2 += 4;
      v4 = (unsigned int)v3 < 4;
      v3 -= 4;
      if ( v4 )
        goto LABEL_5;
    }
  }
  v5 = *(_BYTE *)a1 < *(_BYTE *)a2;
  if ( *(_BYTE *)a1 != *(_BYTE *)a2
    || v3 != -3
    && ((v6 = *(_BYTE *)(a1 + 1), v5 = v6 < *(_BYTE *)(a2 + 1), v6 != *(_BYTE *)(a2 + 1))
     || v3 != -2
     && ((v7 = *(_BYTE *)(a1 + 2), v5 = v7 < *(_BYTE *)(a2 + 2), v7 != *(_BYTE *)(a2 + 2))
      || v3 != -1 && (v8 = *(_BYTE *)(a1 + 3), v5 = v8 < *(_BYTE *)(a2 + 3), v8 != *(_BYTE *)(a2 + 3)))) )
    return -v5 | 1;
  return 0;
}

//----- (10009A40) --------------------------------------------------------
int __userpurge sub_10009A40<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10061D84;
  return v4;
}
// 10061D84: using guessed type int (__stdcall *off_10061D84)(char);

//----- (10009A60) --------------------------------------------------------
int __userpurge sub_10009A60<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_100602F0;
  return v4;
}
// 100602F0: using guessed type int (__stdcall *off_100602F0)(char);

//----- (10009B30) --------------------------------------------------------
int __userpurge sub_10009B30<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, unsigned int a4)
{
  int v4; // ecx@1

  v4 = 0;
  if ( a4 )
  {
    if ( a4 > 0x7FFFFFFF || (v4 = sub_1002ADB1(a1, 0, a2, a3, 2 * a4), !v4) )
    {
      sub_10029530();
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_10009B60);
    }
  }
  return v4;
}

//----- (10009B60) --------------------------------------------------------
int (__cdecl *__usercall sub_10009B60<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<ebx>, int a5<edi>, int a6<esi>, int a7, int a8))(int, int)
{
  unsigned int v8; // edi@1
  int v9; // esi@1
  unsigned int v10; // ecx@3
  int v11; // eax@6
  int v12; // ecx@6
  int (__cdecl *result)(int, int); // eax@9
  int v14; // edx@9
  const void *v15; // edx@12
  int v16; // eax@18
  int v17; // [sp-10h] [bp-28h]@1
  int v18; // [sp-Ch] [bp-24h]@1
  int v19; // [sp-8h] [bp-20h]@1
  int v20; // [sp-4h] [bp-1Ch]@1
  int v21; // [sp+0h] [bp-18h]@1
  int v22; // [sp+4h] [bp-14h]@6
  void **v23; // [sp+8h] [bp-10h]@1
  int v24; // [sp+Ch] [bp-Ch]@1
  int (__cdecl *v25)(int, int); // [sp+10h] [bp-8h]@1
  int v26; // [sp+14h] [bp-4h]@1
  void *v27; // [sp+1Ch] [bp+4h]@9

  v26 = -1;
  v25 = sub_1005AE70;
  v24 = a1;
  v20 = a4;
  v19 = a6;
  v18 = a5;
  v17 = a1;
  v23 = (void **)&v17;
  v9 = a3;
  v21 = a3;
  v8 = a7 | 7;
  if ( (a7 | 7u) <= 0x7FFFFFFE )
  {
    a4 = *(_DWORD *)(a3 + 20);
    v10 = *(_DWORD *)(a3 + 20) >> 1;
    a2 = v8 / 3;
    if ( v10 > v8 / 3 )
    {
      v8 = v10 + a4;
      if ( a4 > 2147483646 - v10 )
        v8 = 2147483646;
    }
  }
  else
  {
    v8 = a7;
  }
  v11 = v8 + 1;
  v12 = 0;
  v26 = 0;
  v22 = 0;
  if ( v8 == -1 || (unsigned int)v11 <= 0x7FFFFFFF && (v12 = sub_1002ADB1(a2, 0, a4, v8, 2 * v11), v22 = v12, v12) )
  {
    if ( a8 )
    {
      if ( *(_DWORD *)(v9 + 20) < 8u )
        v15 = (const void *)v9;
      else
        v15 = *(const void **)v9;
      if ( a8 )
        sub_10034F00((void *)v12, v15, 2 * a8);
    }
    if ( *(_DWORD *)(v9 + 20) >= 8u )
      sub_1002A4AA(*(LPVOID *)v9);
    v16 = v22;
    *(_DWORD *)v9 = v22;
    *(_DWORD *)(v9 + 20) = v8;
    *(_DWORD *)(v9 + 16) = a8;
    if ( v8 >= 8 )
      v9 = v16;
    result = 0;
    *(_WORD *)(v9 + 2 * a8) = 0;
  }
  else
  {
    sub_10029530();
    v22 = a7;
    v23 = &v27;
    LOBYTE(v26) = 2;
    sub_10009B30(v14, a4, v8, a7 + 1);
    result = loc_10009C1E;
  }
  return result;
}
// 10009C1E: using guessed type int __cdecl loc_10009C1E(int, int);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1005AE70: using guessed type int __cdecl sub_1005AE70(int, int);

//----- (10009E10) --------------------------------------------------------
int __userpurge sub_10009E10<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_100616CC;
  return v4;
}
// 100616CC: using guessed type int (__stdcall *off_100616CC)(char);

//----- (10009E30) --------------------------------------------------------
int __usercall sub_10009E30<eax>(const void *a1<ecx>, int a2<edi>, char a3)
{
  sub_1002FDE9(a1, a2, (const void **)&a3);
  return sub_1002FDDA((int)&a3);
}

//----- (10009E90) --------------------------------------------------------
int __usercall sub_10009E90<eax>(int a1<ecx>, int a2<edi>)
{
  const void *v3; // ecx@3
  char v4; // [sp+4h] [bp-18h]@3
  int v5; // [sp+18h] [bp-4h]@3

  if ( !*(_DWORD *)a1 )
    *(_DWORD *)a1 = 1;
  sub_1002FD39((int)&v4, a1 + 4);
  v5 = 0;
  sub_1002FDE9(v3, a2, (const void **)&v4);
  v5 = -1;
  return sub_1002FDDA((int)&v4);
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);

//----- (10009F10) --------------------------------------------------------
signed int __usercall sub_10009F10<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // ebx@1
  int ebp0; // ebp@0
  int v4; // edi@1
  char *v5; // esi@3
  int v6; // ecx@5
  signed int result; // eax@7
  char v8; // [sp+0h] [bp-30h]@1
  char *v9; // [sp+18h] [bp-18h]@3
  int v10; // [sp+1Ch] [bp-14h]@1
  char *v11; // [sp+20h] [bp-10h]@1
  int v12; // [sp+2Ch] [bp-4h]@3

  v11 = &v8;
  v4 = a1;
  v10 = a1;
  sub_1002C6B5(ebp0, a2, a1, -1);
  v2 = *(_DWORD *)(v4 + 144);
  if ( !v2
    || *(_BYTE *)(v4 + 88)
    || (v12 = 0,
        v5 = sub_1002F41A(v2, ebp0, v4),
        v9 = v5,
        ++*(_DWORD *)v5,
        LOBYTE(v12) = 1,
        sub_1002DBC0(v2, ebp0, v4, v2 + 8, 0),
        --*(_DWORD *)v5,
        v12 = -1,
        *(_BYTE *)(v4 + 90)) )
    sub_1002C6B5(ebp0, v2, v4, -1);
  v6 = *(_DWORD *)(v4 + 92);
  if ( v6 )
  {
    sub_10009E90(v6, v4);
  }
  else
  {
    result = 2;
    if ( *(_DWORD *)(v4 + 84) == 4 )
      return result;
  }
  return 1;
}

//----- (1000A010) --------------------------------------------------------
void *__thiscall sub_1000A010(void *this, int a2)
{
  void *v2; // esi@1
  int v3; // edx@2
  int v4; // ecx@2
  int v5; // edi@4
  void *result; // eax@8
  char v21; // [sp+4h] [bp-8h]@2

  v2 = this;
  if ( this == (void *)a2 )
  {
    result = this;
  }
  else
  {
    v4 = 0;
    v3 = 0;
    if ( &v21 != (char *)a2 )
    {
      v3 = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a2 + 4) = 0;
      v4 = *(_DWORD *)a2;
      *(_DWORD *)a2 = 0;
    }
    v5 = *((_DWORD *)v2 + 1);
    *((_DWORD *)v2 + 1) = v3;
    *(_DWORD *)v2 = v4;
    if ( v5 )
    {
      _EBX = -1;
      _ECX = v5 + 4;
      _EAX = -1;
      __asm { lock xadd [ecx], eax }
      if ( _ZF )
      {
        (**(void (__thiscall ***)(_DWORD))v5)(v5);
        _EAX = v5 + 8;
        __asm { lock xadd [eax], ebx }
        if ( _EBX == 1 )
          (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
      }
      result = v2;
    }
    else
    {
      result = v2;
    }
  }
  return result;
}

//----- (1000A090) --------------------------------------------------------
int __thiscall sub_1000A090(int this, char a2)
{
  int v2; // eax@1
  int ebp0; // ebp@0
  int v4; // esi@1
  int v5; // ecx@2

  v4 = this;
  *(_DWORD *)this = &off_10068204;
  v2 = *(_DWORD *)(this + 140);
  if ( v2 )
  {
    sub_1002B29A(ebp0, v2);
    v5 = *(_DWORD *)(v4 + 140);
    _EDX = -1;
    _EAX = v5 + 4;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v5 + 4))();
    *(_DWORD *)(v4 + 140) = 0;
  }
  sub_1000A960(v4);
  if ( a2 & 1 )
    sub_1002A4AA((LPVOID)v4);
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10068204: using guessed type int (__stdcall *off_10068204)(char);

//----- (1000A140) --------------------------------------------------------
void *__thiscall sub_1000A140(void *this, int a2)
{
  int v2; // edi@1
  void *v3; // esi@1
  int v4; // eax@1
  int v5; // edx@1
  int v6; // edx@1
  char v22; // [sp+10h] [bp-Ch]@1
  int v23; // [sp+14h] [bp-8h]@1

  v3 = this;
  v4 = sub_10004DE0((int)&v22, a2);
  v5 = *(_DWORD *)(v4 + 4);
  *(_DWORD *)(v4 + 4) = *((_DWORD *)v3 + 1);
  *((_DWORD *)v3 + 1) = v5;
  v6 = *(_DWORD *)v4;
  *(_DWORD *)v4 = *(_DWORD *)v3;
  v2 = v23;
  *(_DWORD *)v3 = v6;
  if ( v2 )
  {
    _EBX = -1;
    _ECX = v2 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v2)(v2);
      _EAX = v2 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 4))(v2);
    }
  }
  return v3;
}

//----- (1000A250) --------------------------------------------------------
int __fastcall sub_1000A250(int a1, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // ebx@1
  int ebp0; // ebp@0
  int v6; // edi@1
  char *v7; // esi@1
  int v8; // ecx@2
  int result; // eax@4
  int v10; // eax@5
  int v11; // ecx@5
  int v12; // edi@5
  int v13; // eax@8

  v6 = a2;
  v4 = a1;
  v7 = sub_1002F41A(a1, ebp0, a2);
  ++*(_DWORD *)v7;
  if ( *(_DWORD *)v7 > (unsigned int)v6 )
  {
    v10 = sub_1002ADB1(v2, v3, v4, v6, 24);
    v12 = v10;
    if ( v10 )
    {
      v11 = *(_DWORD *)(v4 + 16);
      if ( v11 )
      {
        v13 = *(_DWORD *)v11;
        if ( v11 == v4 )
          *(_DWORD *)(v12 + 16) = (*(int (__stdcall **)(int))v13)(v12);
        else
          *(_DWORD *)(v12 + 16) = (*(int (__stdcall **)(_DWORD))v13)(0);
      }
      else
      {
        *(_DWORD *)(v10 + 16) = 0;
      }
    }
    else
    {
      v12 = 0;
    }
    result = sub_1002FEEC(v11, v4, v12, (int)&loc_1000A1F0, v12);
    --*(_DWORD *)v7;
  }
  else
  {
    v8 = *(_DWORD *)(v4 + 16);
    if ( !v8 )
      sub_10029561();
    result = (*(int (**)(void))(*(_DWORD *)v8 + 8))();
    --*(_DWORD *)v7;
  }
  return result;
}

//----- (1000A320) --------------------------------------------------------
int __usercall sub_1000A320<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // esi@1

  v3 = a1;
  if ( !*(_DWORD *)a1 )
    sub_1002DA88(a2, a3);
  return sub_1002FDDA(v3 + 4);
}

//----- (1000A380) --------------------------------------------------------
int __usercall sub_1000A380<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  return sub_1000A320(a1 + 12, a2, a3);
}

//----- (1000A3A0) --------------------------------------------------------
int __stdcall sub_1000A3A0(int a1)
{
  return 0;
}

//----- (1000A3B0) --------------------------------------------------------
char __userpurge sub_1000A3B0<al>(int a1<ecx>, int a2<edi>, int a3)
{
  char v3; // bl@1
  int v4; // esi@1
  int v5; // esi@1
  int v6; // eax@1
  char v7; // al@1
  char v23; // [sp+10h] [bp-1Ch]@1
  int v24; // [sp+14h] [bp-18h]@1
  int v25; // [sp+18h] [bp-14h]@1
  int v26; // [sp+28h] [bp-4h]@1

  v5 = a1;
  v25 = *(_DWORD *)(a1 + 148);
  v6 = sub_10009300(a3, (int)&v23, a2, (int)&v25);
  v26 = 0;
  v7 = (*(int (__thiscall **)(int, signed int, signed int, _DWORD, int))(*(_DWORD *)v5 + 4))(v5, 1, 1, 0, v6);
  v26 = -1;
  v4 = v24;
  v3 = v7;
  if ( v24 )
  {
    _EDI = -1;
    _EDX = v24 + 4;
    _ECX = -1;
    __asm { lock xadd [edx], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v4)(v4);
      _EAX = v4 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (**)(void))(*(_DWORD *)v4 + 4))();
    }
  }
  return v3;
}

//----- (1000A460) --------------------------------------------------------
int __cdecl sub_1000A460(int a1)
{
  int ebp0; // ebp@0

  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  sub_1002FD89(a1);
  sub_1002FD9C(ebp0);
  return a1;
}

//----- (1000A4E0) --------------------------------------------------------
int __cdecl sub_1000A4E0(int a1)
{
  sub_1000A460(a1);
  return a1;
}

//----- (1000A520) --------------------------------------------------------
int __thiscall sub_1000A520(int this, int a2, int a3)
{
  int ebp0; // ebp@0
  int v4; // edi@1
  int result; // eax@2
  char *v13; // esi@3

  v4 = this;
  _EAX = this + 4;
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  if ( a3 )
  {
    v13 = sub_1002F41A(a3, ebp0, this);
    ++*(_DWORD *)v13;
    if ( *(_DWORD *)v13 > (unsigned int)a3 )
    {
      sub_1002DF80(ebp0, a2);
      result = 0;
    }
    else
    {
      result = sub_1002DBC0(a3, ebp0, v4, v4 + 8, a2);
    }
    --*(_DWORD *)v13;
  }
  else
  {
    sub_1002DF80(ebp0, a2);
    result = 0;
  }
  return result;
}

//----- (1000A5C0) --------------------------------------------------------
int __userpurge sub_1000A5C0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4, int a5)
{
  int ebp0; // ebp@0
  int v7; // esi@1
  int v8; // eax@1
  char v9; // [sp+0h] [bp-24h]@1
  int v10; // [sp+10h] [bp-14h]@1
  char *v11; // [sp+14h] [bp-10h]@1
  int v12; // [sp+20h] [bp-4h]@1

  v11 = &v9;
  v7 = a1;
  v10 = a1;
  v8 = sub_1002D978(a2, ebp0, a3);
  *(_DWORD *)(v7 + 144) = v8;
  v12 = 0;
  sub_1000A520(v8, a4, a5);
  v12 = -1;
  return sub_1002C5B4(ebp0);
}

//----- (1000A642) --------------------------------------------------------
int (__stdcall *__cdecl sub_1000A642())(int, int)
{
  return loc_1000A61C;
}
// 1000A61C: using guessed type int __stdcall loc_1000A61C(int, int);

//----- (1000A650) --------------------------------------------------------
void *__thiscall sub_1000A650(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10061E90;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10061E90: using guessed type int (__stdcall *off_10061E90)(char);

//----- (1000A690) --------------------------------------------------------
int __thiscall sub_1000A690(int this)
{
  int result; // eax@1
  int v2; // ebx@1
  int v3; // esi@1
  int (__thiscall **v4)(_DWORD, _DWORD); // eax@2
  int v5; // edi@2
  int v6; // esi@7
  int v19; // [sp+14h] [bp-1Ch]@1
  int v20; // [sp+18h] [bp-18h]@2
  unsigned int v21; // [sp+1Ch] [bp-14h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+2Ch] [bp-4h]@2

  v21 = (unsigned int)&v19 ^ __security_cookie;
  result = (int)&v22;
  v2 = this;
  v3 = *(_DWORD *)(this + 132);
  *(_DWORD *)(this + 132) = 0;
  if ( v3 )
  {
    do
    {
      v4 = *(int (__thiscall ***)(_DWORD, _DWORD))v3;
      v5 = *(_DWORD *)(v3 + 20);
      v19 = 0;
      v20 = 0;
      ((int (__thiscall **)(int, int *))v4)[1](v3, &v19);
      v23 = 0;
      if ( *(_DWORD *)(v2 + 84) != 4 || *(_BYTE *)(v3 + 25) )
      {
        if ( *(_DWORD *)(v19 + 84) != 4 )
        {
          result = sub_1000A5C0(v19, v2, v5, v3, *(_DWORD *)(v3 + 28));
          goto LABEL_7;
        }
      }
      else
      {
        if ( *(_DWORD *)(v2 + 92) )
          (*(void (__stdcall **)(signed int, signed int, signed int, int))(*(_DWORD *)v19 + 4))(1, 1, 1, v2 + 92);
        else
          (*(void (__stdcall **)(signed int, _DWORD, _DWORD, int))(*(_DWORD *)v19 + 4))(1, 0, 0, v19 + 92);
      }
      result = (**(int (__thiscall ***)(_DWORD, _DWORD))v3)(v3, 1);
LABEL_7:
      v23 = -1;
      v6 = v20;
      if ( v20 )
      {
        _ECX = -1;
        result = v20 + 4;
        __asm { lock xadd [eax], ecx }
        if ( _ZF )
        {
          (**(void (__thiscall ***)(_DWORD))v6)(v6);
          _EDX = -1;
          result = v6 + 8;
          __asm { lock xadd [eax], edx }
          if ( _ZF )
            result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v6 + 4))(v6, _EDX);
        }
      }
      v3 = v5;
    }
    while ( v5 );
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;

//----- (1000A7D0) --------------------------------------------------------
int (__stdcall ***__cdecl sub_1000A7D0())(char)
{
  return &off_10075B58;
}
// 10075B58: using guessed type int (__stdcall **off_10075B58)(char);

//----- (1000A7E0) --------------------------------------------------------
char __thiscall sub_1000A7E0(void *this, char a2, char a3, int a4, int a5)
{
  char v5; // bl@1
  int ebp0; // ebp@0
  int v7; // esi@1
  int v8; // eax@7
  int v10; // ecx@14
  char v11; // [sp+10h] [bp-4Ch]@1
  void **v12; // [sp+14h] [bp-48h]@18
  int v13; // [sp+18h] [bp-44h]@18
  int *v14; // [sp+24h] [bp-38h]@18
  unsigned int v15; // [sp+48h] [bp-14h]@1
  int v16; // [sp+58h] [bp-4h]@1

  v15 = (unsigned int)&v11 ^ __security_cookie;
  v7 = (int)this;
  v5 = 0;
  sub_1002B62D(ebp0, (int)((char *)this + 100));
  v16 = 0;
  if ( !a3 )
  {
    v8 = *(_DWORD *)(v7 + 84);
    if ( v8 != 3 && v8 != 4 )
    {
      if ( v8 != 2 )
        goto LABEL_4;
      if ( a2 )
      {
LABEL_13:
        *(_DWORD *)(v7 + 84) = 4;
        sub_1002C5B4(ebp0);
        v5 = 1;
        goto LABEL_14;
      }
    }
LABEL_11:
    v16 = -1;
    sub_1002B6D6();
    return 0;
  }
  if ( *(_DWORD *)(v7 + 84) == 4 )
    goto LABEL_11;
  sub_1000A140((void *)(v7 + 92), a5);
LABEL_4:
  if ( a2 || !*(_DWORD *)(v7 + 84) )
    goto LABEL_13;
  *(_DWORD *)(v7 + 84) = 2;
LABEL_14:
  v10 = *(_DWORD *)(v7 + 144);
  if ( v10 )
    sub_1002D5ED(v10 + 8, v5, a5);
  v16 = -1;
  sub_1002B6D6();
  if ( v5 )
  {
    sub_1002C5B4(ebp0);
    if ( *(_DWORD *)(v7 + 132) )
    {
      v12 = &off_100681E8;
      v13 = v7;
      v14 = (int *)&v12;
      v16 = 2;
      sub_1000A250((int)&v12, 16);
      sub_10006050((int)&v12);
    }
  }
  return 1;
}
// 100681E8: using guessed type void *off_100681E8;
// 10074200: using guessed type int __security_cookie;

//----- (1000A930) --------------------------------------------------------
void *__thiscall sub_1000A930(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_1000A960(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1000A960) --------------------------------------------------------
int __thiscall sub_1000A960(int this)
{
  int v1; // ecx@1
  int ebp0; // ebp@0
  int v4; // esi@1
  int v12; // ecx@4
  int v20; // edi@8

  v4 = this;
  *(_DWORD *)this = &off_1006820C;
  v1 = *(_DWORD *)(this + 136);
  _EBX = -1;
  if ( v1 != 2 )
  {
    _EAX = v1 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v1 + 4))();
  }
  v12 = *(_DWORD *)(v4 + 144);
  if ( v12 )
  {
    _EAX = v12 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v12 + 4))();
    *(_DWORD *)(v4 + 144) = 0;
  }
  nullsub_2(v4 + 100);
  v20 = *(_DWORD *)(v4 + 96);
  if ( v20 )
  {
    _EAX = v20 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v20)(v20);
      _EAX = v20 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v20 + 4))(v20);
    }
  }
  sub_1002C0CF(ebp0);
  return sub_1002C0CF(ebp0);
}
// 1002B6E4: using guessed type int __thiscall nullsub_2(_DWORD);
// 1006820C: using guessed type int (__stdcall *off_1006820C)(char);

//----- (1000AA50) --------------------------------------------------------
int __thiscall sub_1000AA50(void *this)
{
  int v1; // esi@1

  _EDX = (int)((char *)this + 4);
  _ESI = -1;
  __asm { lock xadd [edx], esi }
  v1 = _ESI - 1;
  if ( !v1 )
    (*(void (**)(void))(*(_DWORD *)this + 4))();
  return v1;
}

//----- (1000AA70) --------------------------------------------------------
int __thiscall sub_1000AA70(void *this)
{
  int result; // eax@1
  void *v3; // esi@1

  v3 = this;
  _EDI = -1;
  _EDX = (int)((char *)this + 4);
  _EAX = -1;
  __asm { lock xadd [edx], eax }
  if ( _ZF )
  {
    (**(void (***)(void))this)();
    result = (int)((char *)v3 + 8);
    __asm { lock xadd [eax], edi }
    if ( _EDI == 1 )
      result = (*(int (__thiscall **)(void *))(*(_DWORD *)v3 + 4))(v3);
  }
  return result;
}

//----- (1000ACA0) --------------------------------------------------------
int (__cdecl *__usercall sub_1000ACA0<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<ebx>, int a5<edi>, int a6<esi>, int a7, unsigned int a8))(int, int)
{
  unsigned int v8; // edi@1
  int (__cdecl *v9)(int, int); // esi@1
  unsigned int v10; // ecx@3
  int v11; // eax@6
  int v12; // ecx@6
  int (__cdecl *result)(int, int); // eax@9
  unsigned int v14; // ebx@10
  const void *v15; // ecx@12
  int v16; // [sp-10h] [bp-28h]@1
  int v17; // [sp-Ch] [bp-24h]@1
  int v18; // [sp-8h] [bp-20h]@1
  int v19; // [sp-4h] [bp-1Ch]@1
  int v20; // [sp+0h] [bp-18h]@1
  int v21; // [sp+4h] [bp-14h]@6
  void **v22; // [sp+8h] [bp-10h]@1
  int v23; // [sp+Ch] [bp-Ch]@1
  int (__cdecl *v24)(int, int); // [sp+10h] [bp-8h]@1
  int v25; // [sp+14h] [bp-4h]@1
  void *v26; // [sp+1Ch] [bp+4h]@9

  v25 = -1;
  v24 = sub_1005AE50;
  v23 = a1;
  v19 = a4;
  v18 = a6;
  v17 = a5;
  v16 = a1;
  v22 = (void **)&v16;
  v9 = (int (__cdecl *)(int, int))a3;
  v20 = a3;
  v8 = a7 | 0xF;
  if ( (a7 | 0xFu) <= 0xFFFFFFFE )
  {
    a4 = *(_DWORD *)(a3 + 20);
    v10 = *(_DWORD *)(a3 + 20) >> 1;
    a2 = v8 / 3;
    if ( v10 > v8 / 3 )
    {
      v8 = v10 + a4;
      if ( a4 > -2 - v10 )
        v8 = -2;
    }
  }
  else
  {
    v8 = a7;
  }
  v12 = v8 + 1;
  v11 = 0;
  v25 = 0;
  v21 = 0;
  if ( v8 == -1 || (unsigned int)v12 <= 0xFFFFFFFF && (v11 = sub_1002ADB1(a2, v12, a4, v8, v8 + 1), v21 = v11, v11) )
  {
    v14 = a8;
    if ( a8 )
    {
      if ( *((_DWORD *)v9 + 5) < 0x10u )
        v15 = v9;
      else
        v15 = *(const void **)v9;
      if ( a8 )
        sub_10034F00((void *)v11, v15, a8);
    }
    if ( *((_DWORD *)v9 + 5) >= 0x10u )
      sub_1002A4AA(*(LPVOID *)v9);
    result = (int (__cdecl *)(int, int))v21;
    *(_BYTE *)v9 = 0;
    *(_DWORD *)v9 = result;
    *((_DWORD *)v9 + 5) = v8;
    *((_DWORD *)v9 + 4) = v14;
    if ( v8 >= 0x10 )
      v9 = result;
    *((_BYTE *)v9 + v14) = 0;
  }
  else
  {
    sub_10029530();
    v21 = a7;
    v22 = &v26;
    LOBYTE(v25) = 2;
    loc_1000AC70((char *)&a7 + 3, a7 + 1);
    result = loc_1000AD55;
  }
  return result;
}
// 1000AD55: using guessed type int __cdecl loc_1000AD55(int, int);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1005AE50: using guessed type int __cdecl sub_1005AE50(int, int);

//----- (1000AFB0) --------------------------------------------------------
int __thiscall sub_1000AFB0(int this, const char *a2)
{
  int v2; // esi@1
  int result; // eax@2

  v2 = this;
  *(_DWORD *)(this + 20) = 15;
  *(_DWORD *)(this + 16) = 0;
  *(_BYTE *)this = 0;
  if ( *a2 )
  {
    loc_1000AEB0(this, a2, strlen(a2));
    result = v2;
  }
  else
  {
    loc_1000AEB0(this, a2, 0);
    result = v2;
  }
  return result;
}

//----- (1000B010) --------------------------------------------------------
int __thiscall sub_1000B010(int this, __int16 a2, char a3, void *a4, int a5, int a6, int a7, int a8, unsigned int a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, int a15, int a16)
{
  int v17; // ecx@1
  __int64 v18; // qax@5
  char v19; // cf@5
  signed int v21; // [sp+10h] [bp-10h]@1
  signed int v22; // [sp+10h] [bp-10h]@3

  _ESI = this;
  *(_DWORD *)(this + 16) = a15;
  *(_DWORD *)(this + 20) = a16;
  *(_DWORD *)(this + 8) = 0;
  *(_BYTE *)(this + 12) = a3;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_WORD *)(this + 40) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 52) = 0;
  *(_WORD *)(this + 56) = a2;
  v17 = this + 64;
  *(_DWORD *)_ESI = &off_10068240;
  *(_DWORD *)(v17 + 20) = 15;
  *(_DWORD *)(v17 + 16) = 0;
  *(_BYTE *)v17 = 0;
  loc_1000AB40(&a4, 0, -1);
  __asm
  {
    movq    xmm0, [ebp+arg_20]
    movq    qword ptr [esi+58h], xmm0
    movq    xmm0, [ebp+arg_28]
    movq    qword ptr [esi+60h], xmm0
    movq    xmm0, [ebp+arg_30]
    movq    qword ptr [esi+68h], xmm0
    movq    xmm0, [ebp+arg_38]
    movq    qword ptr [esi+70h], xmm0
    movq    xmm0, [ebp+arg_40]
    movq    qword ptr [esi+78h], xmm0
    movsd   xmm0, ds:qword_100694A8
    movsd   qword ptr [esi+80h], xmm0
    movsd   xmm0, ds:qword_10069480
    movsd   qword ptr [esi+88h], xmm0
  }
  *(_DWORD *)(_ESI + 160) = 0;
  *(_DWORD *)(_ESI + 164) = 0;
  *(_DWORD *)(_ESI + 168) = 0;
  *(_DWORD *)(_ESI + 172) = 0;
  *(_DWORD *)(_ESI + 176) = 0;
  *(_DWORD *)(_ESI + 180) = 0;
  *(_DWORD *)(_ESI + 184) = 0;
  *(_DWORD *)(_ESI + 188) = 0;
  *(_DWORD *)(_ESI + 192) = 0;
  *(_DWORD *)(_ESI + 196) = 0;
  *(_DWORD *)(_ESI + 200) = 0;
  *(_DWORD *)(_ESI + 204) = 0;
  *(_DWORD *)(_ESI + 208) = 0;
  *(_DWORD *)(_ESI + 212) = 0;
  *(_DWORD *)(_ESI + 240) = 15;
  *(_DWORD *)(_ESI + 236) = 0;
  *(_BYTE *)(_ESI + 220) = 0;
  *(_DWORD *)(_ESI + 248) = 60;
  *(_DWORD *)(_ESI + 272) = 15;
  *(_DWORD *)(_ESI + 268) = 0;
  *(_BYTE *)(_ESI + 252) = 0;
  *(_DWORD *)(_ESI + 276) = 0;
  *(_DWORD *)(_ESI + 280) = 0;
  *(_DWORD *)(_ESI + 284) = 0;
  *(_DWORD *)(_ESI + 288) = 0;
  *(_DWORD *)(_ESI + 296) = 0;
  *(_DWORD *)(_ESI + 300) = 0;
  *(_DWORD *)(_ESI + 304) = 0;
  *(_DWORD *)(_ESI + 308) = 0;
  v21 = 8760;
  if ( !a3 )
    v21 = 3;
  *(_QWORD *)(_ESI + 296) = sub_10039A40(v21, 36000000000i64);
  v22 = 14400;
  if ( !a3 )
    v22 = 10;
  v18 = sub_10039A40(v22, 600000000i64);
  v19 = a9 < 0x10;
  *(_QWORD *)(_ESI + 304) = v18;
  if ( !v19 )
    sub_1002A4AA(a4);
  return _ESI;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10068240: using guessed type int (__stdcall *off_10068240)(char);

//----- (1000B2B0) --------------------------------------------------------
void *__thiscall sub_1000B2B0(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_1000B2E0(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1000B2E0) --------------------------------------------------------
int __thiscall sub_1000B2E0(int this)
{
  int result; // eax@1
  int v2; // esi@1
  int v4; // edi@7
  int v17; // edi@11

  v2 = this;
  *(_DWORD *)this = &off_10068240;
  result = *(_DWORD *)(this + 276);
  if ( result )
  {
    result = sub_1002A4AA(*(LPVOID *)(this + 276));
    *(_DWORD *)(v2 + 276) = 0;
    *(_DWORD *)(v2 + 280) = 0;
    *(_DWORD *)(v2 + 284) = 0;
  }
  if ( *(_DWORD *)(v2 + 272) >= 0x10u )
    result = sub_1002A4AA(*(LPVOID *)(v2 + 252));
  *(_DWORD *)(v2 + 272) = 15;
  *(_DWORD *)(v2 + 268) = 0;
  *(_BYTE *)(v2 + 252) = 0;
  if ( *(_DWORD *)(v2 + 240) >= 0x10u )
    result = sub_1002A4AA(*(LPVOID *)(v2 + 220));
  *(_DWORD *)(v2 + 240) = 15;
  *(_DWORD *)(v2 + 236) = 0;
  *(_BYTE *)(v2 + 220) = 0;
  v4 = *(_DWORD *)(v2 + 196);
  _EBX = -1;
  if ( v4 )
  {
    result = v4 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v4)(v4);
      result = v4 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v4 + 4))(v4, _EDX);
    }
  }
  v17 = *(_DWORD *)(v2 + 188);
  if ( v17 )
  {
    result = v17 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v17)(v17);
      result = v17 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v17 + 4))(v17);
    }
  }
  if ( *(_DWORD *)(v2 + 84) >= 0x10u )
    result = sub_1002A4AA(*(LPVOID *)(v2 + 64));
  *(_DWORD *)(v2 + 84) = 15;
  *(_DWORD *)(v2 + 80) = 0;
  *(_BYTE *)(v2 + 64) = 0;
  *(_DWORD *)v2 = off_10068B14;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10068240: using guessed type int (__stdcall *off_10068240)(char);
// 10068B14: using guessed type int (__stdcall *off_10068B14[2])(char);

//----- (1000B410) --------------------------------------------------------
char __thiscall sub_1000B410(int this, __int64 a2, __int64 a3, __int64 a4)
{
  char v5; // al@1
  int v6; // eax@5
  int v7; // esi@5
  int v8; // ecx@5
  int v9; // edx@5
  double v10; // st7@5
  __int64 v11; // qax@5
  int v12; // esi@5
  unsigned __int8 v17; // cf@6
  __int64 v19; // qax@7
  int v20; // esi@7
  char v21; // zf@7
  int v22; // ecx@8
  int v23; // eax@9
  int v24; // eax@13
  unsigned int v25; // esi@13
  int v26; // esi@16
  __int64 v27; // qax@19
  int v28; // ecx@19
  unsigned __int8 v29; // cf@19
  int v30; // ecx@19
  int v31; // eax@19
  __int64 v32; // qax@19
  int v33; // eax@23
  int v34; // edx@23
  int v35; // ecx@23
  int v36; // esi@25
  int v51; // esi@29
  int v66; // eax@33
  int v67; // eax@34
  unsigned int v68; // ecx@34
  int v69; // esi@37
  int v70; // ecx@37
  int v71; // ecx@37
  int v85; // eax@41
  int v86; // ecx@42
  int v87; // ecx@45
  int v88; // eax@46
  int v89; // eax@51
  int v90; // eax@54
  char result; // al@57
  int v92; // eax@61
  int v93; // eax@63
  unsigned int v94; // edx@63
  int v95; // eax@66
  char v104; // [sp-2Ch] [bp-98h]@23
  int v105; // [sp-28h] [bp-94h]@23
  int v106; // [sp-24h] [bp-90h]@23
  int v107; // [sp-20h] [bp-8Ch]@23
  signed __int64 v108; // [sp-1Ch] [bp-88h]@23
  int v109; // [sp-14h] [bp-80h]@19
  int v110; // [sp-10h] [bp-7Ch]@19
  unsigned int v111; // [sp-Ch] [bp-78h]@19
  int v112; // [sp-8h] [bp-74h]@19
  unsigned int v113; // [sp-4h] [bp-70h]@1
  char v114; // [sp+Ch] [bp-60h]@23
  void *v115; // [sp+14h] [bp-58h]@59
  int v116; // [sp+24h] [bp-48h]@59
  unsigned int v117; // [sp+28h] [bp-44h]@59
  double v119; // [sp+34h] [bp-38h]@5
  double v120; // [sp+3Ch] [bp-30h]@5
  int v121; // [sp+44h] [bp-28h]@29
  __int64 v122; // [sp+4Ch] [bp-20h]@5
  __int64 v123; // [sp+54h] [bp-18h]@1
  unsigned int v124; // [sp+5Ch] [bp-10h]@1
  int v125; // [sp+68h] [bp-4h]@59
  int v126; // [sp+6Ch] [bp+0h]@1

  v124 = (unsigned int)&v126 ^ __security_cookie;
  v113 = (unsigned int)&v126 ^ __security_cookie;
  __asm
  {
    movsd   [ebp+var_40], xmm3
    movsd   [ebp+var_18], xmm2
  }
  _EDI = this;
  sub_1000C940(this, this, a2);
  __asm { movsd   xmm0, [ebp+var_18] }
  v5 = *(_BYTE *)(_EDI + 12);
  __asm
  {
    movsd   qword ptr [edi+88h], xmm0
    movsd   xmm0, [ebp+var_40]
    movsd   qword ptr [edi+80h], xmm0
    movsd   xmm0, [ebp+arg_8]
    movsd   qword ptr [edi+90h], xmm0
    movsd   xmm0, [ebp+arg_10]
    movsd   qword ptr [edi+98h], xmm0
  }
  if ( v5 || !sub_1000CA40(_EDI + 24) )
    __asm { xorps   xmm0, xmm0 }
  else
    __asm { movsd   xmm0, ds:qword_10069560 }
  __asm { movsd   [ebp+var_18], xmm0 }
  v122 = v123;
  __asm
  {
    movsd   xmm1, [ebp+var_20]
    movaps  xmm0, xmm1
    addsd   xmm0, qword ptr [edi+60h]
    movsd   [ebp+var_18], xmm0
    movsd   xmm0, qword ptr [edi+58h]
    addsd   xmm0, xmm1
    movsd   [ebp+var_30], xmm0
    mulsd   xmm0, ds:qword_10069530
    movsd   [ebp+var_38], xmm0
  }
  v6 = sub_1004D276(v119);
  __asm
  {
    movsd   xmm0, [ebp+var_18]
    mulsd   xmm0, ds:qword_10069530
  }
  v7 = *(_DWORD *)(_EDI + 32);
  v8 = *(_DWORD *)(_EDI + 36);
  __asm { movsd   [ebp+var_38], xmm0 }
  v10 = v119;
  *(_DWORD *)(_EDI + 160) = v6 + v7;
  *(_DWORD *)(_EDI + 164) = v9 + (v6 >= (unsigned int)-v7) + v8;
  LODWORD(v11) = sub_1004D276(v10);
  __asm { movsd   xmm0, [ebp+var_30] }
  v12 = (unsigned __int64)(v11 + *(_QWORD *)(_EDI + 32)) >> 32;
  __asm { comisd  xmm0, [ebp+var_18] }
  *(_DWORD *)(_EDI + 168) = v11 + *(_DWORD *)(_EDI + 32);
  *(_DWORD *)(_EDI + 172) = v12;
  if ( !_CF )
  {
    v17 = *(_DWORD *)(_EDI + 160) >= 0x61C46800u;
    *(_DWORD *)(_EDI + 160) -= 1640261632;
    *(_DWORD *)(_EDI + 164) = v17 + *(_DWORD *)(_EDI + 164) - 9;
  }
  __asm
  {
    movsd   xmm0, qword ptr [edi+68h]
    addsd   xmm0, [ebp+var_20]
    mulsd   xmm0, ds:qword_10069530
    movsd   [ebp+var_30], xmm0
  }
  LODWORD(v19) = sub_1004D276(v120);
  v20 = (unsigned __int64)(v19 + *(_QWORD *)(_EDI + 32)) >> 32;
  _EBX = -1;
  v21 = *(_DWORD *)(_EDI + 192) == 0;
  *(_DWORD *)(_EDI + 176) = v19 + *(_DWORD *)(_EDI + 32);
  *(_DWORD *)(_EDI + 180) = v20;
  if ( v21 )
  {
    v22 = *(_DWORD *)(_EDI + 184);
    if ( !v22 )
      goto LABEL_18;
    v23 = (*(_QWORD *)(v22 + 32) - *(_QWORD *)(_EDI + 304)) >> 32;
    if ( v23 <= *(_DWORD *)(_EDI + 28)
      && (v23 < *(_DWORD *)(_EDI + 28)
       || (unsigned int)(*(_DWORD *)(v22 + 32) - *(_DWORD *)(_EDI + 304)) < *(_DWORD *)(_EDI + 24)) )
    {
      if ( v22 )
      {
        v25 = *(_DWORD *)(_EDI + 24);
        LODWORD(v123) = *(_DWORD *)(v22 + 32);
        v24 = *(_DWORD *)(v22 + 36);
        HIDWORD(v123) = v24;
        if ( v24 > *(_DWORD *)(_EDI + 28) || v24 >= *(_DWORD *)(_EDI + 28) && *(_DWORD *)(v22 + 32) >= v25 )
          v26 = _EDI + 24;
        else
          v26 = _EDI + 24;
        goto LABEL_19;
      }
LABEL_18:
      v26 = _EDI + 24;
LABEL_19:
      v112 = *(_DWORD *)(_EDI + 300);
      v29 = *(_DWORD *)(_EDI + 296) >= (unsigned int)-*(_DWORD *)v26;
      v30 = *(_DWORD *)(_EDI + 296) + *(_DWORD *)v26;
      v31 = *(_DWORD *)(v26 + 4);
      v111 = *(_DWORD *)(_EDI + 296);
      v110 = *(_DWORD *)(_EDI + 300) + v29 + v31;
      v109 = v30;
      LODWORD(v32) = sub_1003AC50(*(unsigned __int64 *)&v109, v111, v112);
      v27 = sub_10039A40(*(_QWORD *)(_EDI + 296), v32);
      _EBX = -1;
      v28 = (unsigned __int64)(v27 - *(_QWORD *)v26) >> 32;
      HIDWORD(v122) = v27 - *(_DWORD *)v26;
      if ( v28 <= *(_DWORD *)(_EDI + 308) )
      {
        if ( v28 < *(_DWORD *)(_EDI + 308) || HIDWORD(v122) < *(_DWORD *)(_EDI + 304) )
          v27 += *(_QWORD *)(_EDI + 296);
      }
      *(_QWORD *)&v111 = v27;
      *(_QWORD *)&v109 = *(_QWORD *)v26;
      v108 = 64424509440i64;
      v104 = 0;
      loc_1000AB40(_EDI + 64, 0, -1);
      v33 = sub_10022BA0(
              *(_DWORD *)(_EDI + 8),
              _EDI,
              (int)((char *)&v120 + 4),
              *(void **)&v104,
              v105,
              v106,
              v107,
              v108,
              HIDWORD(v108),
              *(__int64 *)&v109,
              *(__int64 *)&v111);
      v35 = 0;
      v34 = 0;
      if ( &v114 != (char *)v33 )
      {
        v34 = *(_DWORD *)(v33 + 4);
        *(_DWORD *)(v33 + 4) = 0;
        v35 = *(_DWORD *)v33;
        *(_DWORD *)v33 = 0;
      }
      v36 = *(_DWORD *)(_EDI + 196);
      *(_DWORD *)(_EDI + 196) = v34;
      *(_DWORD *)(_EDI + 192) = v35;
      if ( v36 )
      {
        _EAX = v36 + 4;
        _ECX = -1;
        __asm { lock xadd [eax], ecx }
        if ( _ZF )
        {
          (**(void (__thiscall ***)(_DWORD))v36)(v36);
          _EAX = v36 + 8;
          _EDX = -1;
          __asm { lock xadd [eax], edx }
          if ( _ZF )
            (*(void (__fastcall **)(int, int))(*(_DWORD *)v36 + 4))(v36, _EDX);
        }
      }
      v51 = v121;
      if ( v121 )
      {
        _EAX = v121 + 4;
        _ECX = -1;
        __asm { lock xadd [eax], ecx }
        if ( _ZF )
        {
          (**(void (__thiscall ***)(_DWORD))v51)(v51);
          _EAX = v51 + 8;
          _EDX = -1;
          __asm { lock xadd [eax], edx }
          if ( _ZF )
            (*(void (__fastcall **)(int, int))(*(_DWORD *)v51 + 4))(v51, _EDX);
        }
      }
      goto LABEL_33;
    }
  }
LABEL_33:
  v66 = *(_DWORD *)(_EDI + 192);
  if ( v66 )
  {
    v68 = *(_DWORD *)(v66 + 24);
    v67 = *(_DWORD *)(v66 + 28);
    if ( v67 <= *(_DWORD *)(_EDI + 28) )
    {
      if ( v67 < *(_DWORD *)(_EDI + 28) || v68 < *(_DWORD *)(_EDI + 24) )
      {
        v70 = *(_DWORD *)(_EDI + 188);
        *(_DWORD *)(_EDI + 188) = *(_DWORD *)(_EDI + 196);
        *(_DWORD *)(_EDI + 196) = v70;
        v71 = *(_DWORD *)(_EDI + 184);
        *(_DWORD *)(_EDI + 184) = *(_DWORD *)(_EDI + 192);
        *(_DWORD *)(_EDI + 192) = v71;
        v69 = *(_DWORD *)(_EDI + 196);
        *(_DWORD *)(_EDI + 196) = 0;
        *(_DWORD *)(_EDI + 192) = 0;
        if ( v69 )
        {
          _EAX = v69 + 4;
          _ECX = _EBX;
          __asm { lock xadd [eax], ecx }
          if ( _ZF )
          {
            (**(void (__thiscall ***)(_DWORD))v69)(v69);
            _EAX = v69 + 8;
            __asm { lock xadd [eax], ebx }
            _EBX = _EBX - 1;
            if ( !_EBX )
              (*(void (__thiscall **)(int))(*(_DWORD *)v69 + 4))(v69);
          }
        }
        v85 = *(_DWORD *)(_EDI + 184);
        if ( *(_DWORD *)(v85 + 52) == 1 )
        {
          v86 = *(_DWORD *)(v85 + 56);
          if ( !v86 )
          {
            sub_1002FFB9((int)&v120, (unsigned int)"wait() cannot be called on a default constructed task.");
            sub_100355DB((int)&v120, (int)&unk_1006D8B8);
          }
          sub_10009F10(v86, _EBX);
        }
      }
    }
  }
  v87 = *(_DWORD *)(_EDI + 184);
  if ( !v87 )
    goto LABEL_77;
  v88 = *(_DWORD *)(_EDI + 212);
  if ( v88 <= *(_DWORD *)(_EDI + 28) )
  {
    if ( v88 < *(_DWORD *)(_EDI + 28) || *(_DWORD *)(_EDI + 208) < *(_DWORD *)(_EDI + 24) )
    {
      *(_QWORD *)&v111 = *(_QWORD *)(_EDI + 24);
      sub_10002040(v87, _EDI + 200, *(__int64 *)&v111);
    }
  }
  if ( (*(_DWORD *)(_EDI + 120) & *(_DWORD *)(_EDI + 216)) == *(_DWORD *)(_EDI + 120)
    && (v89 = *(_DWORD *)(_EDI + 28), v89 >= *(_DWORD *)(_EDI + 204))
    && (v89 > *(_DWORD *)(_EDI + 204) || *(_DWORD *)(_EDI + 24) >= *(_DWORD *)(_EDI + 200))
    && (v90 = *(_DWORD *)(_EDI + 212), v90 >= *(_DWORD *)(_EDI + 28))
    && (v90 > *(_DWORD *)(_EDI + 28) || *(_DWORD *)(_EDI + 208) >= *(_DWORD *)(_EDI + 24)) )
  {
    sub_10018590((void *)(_EDI + 248), _EDI + 220);
    result = 0;
  }
  else
  {
LABEL_77:
    if ( *(_DWORD *)(_EDI + 276) != *(_DWORD *)(_EDI + 280) )
    {
      v117 = 15;
      v116 = 0;
      LOBYTE(v115) = 0;
      loc_1000AEB0(&v115, &unk_1006823C, 0);
      v125 = 0;
      sub_10018590((void *)(_EDI + 248), (int)&v115);
      if ( v117 >= 0x10 )
        sub_1002A4AA(v115);
    }
    v92 = *(_DWORD *)(_EDI + 8);
    if ( !v92 )
      goto LABEL_78;
    if ( !(*(_BYTE *)(v92 + 112) & 4) )
      goto LABEL_78;
    v93 = *(_DWORD *)(_EDI + 164);
    v94 = *(_DWORD *)(_EDI + 24);
    if ( v93 > *(_DWORD *)(_EDI + 28) )
      goto LABEL_78;
    if ( v93 >= *(_DWORD *)(_EDI + 28) && *(_DWORD *)(_EDI + 160) >= v94 )
      goto LABEL_78;
    v95 = *(_DWORD *)(_EDI + 172);
    if ( v95 < *(_DWORD *)(_EDI + 28) )
      goto LABEL_78;
    if ( v95 <= *(_DWORD *)(_EDI + 28) && *(_DWORD *)(_EDI + 168) < v94 )
      goto LABEL_78;
    if ( *(_WORD *)(_EDI + 40) == 5 && !sub_10001780(_EDI + 24, _EDI + 176) )
      goto LABEL_78;
    __asm
    {
      movsd   xmm0, qword ptr [edi+70h]
      xorps   xmm1, xmm1
      comisd  xmm1, xmm0
    }
    if ( !_CF )
      goto LABEL_79;
    __asm
    {
      mulsd   xmm0, [ebp+var_40]
      comisd  xmm0, [ebp+arg_8]
    }
    if ( !(_CF | _ZF) )
LABEL_79:
      result = 1;
    else
LABEL_78:
      result = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (1000B970) --------------------------------------------------------
int __cdecl sub_1000B970(double a1, __int64 a2, __int64 a3)
{
  int result; // eax@1
  int v4; // edx@5
  int v5; // esi@5
  double v6; // [sp+18h] [bp+8h]@5
  signed __int64 v7; // [sp+28h] [bp+18h]@5
  double v8; // [sp+28h] [bp+18h]@5

  result = a3;
  __asm
  {
    movapd  xmm1, xmm2
    movapd  xmm2, xmm0
  }
  if ( *(_QWORD *)&a1 < a3 )
  {
    if ( a3 < a2 )
    {
      result = a3 - LODWORD(a1);
      v4 = a2 - LODWORD(a1);
      v5 = (unsigned __int64)(a2 - *(_QWORD *)&a1) >> 32;
      v6 = (double)(a3 - *(_QWORD *)&a1);
      __asm { movsd   xmm0, [ebp+arg_0] }
      HIDWORD(v7) = v5;
      LODWORD(v7) = v4;
      __asm { subsd   xmm1, xmm2 }
      v8 = (double)v7;
      __asm
      {
        divsd   xmm0, [ebp+arg_10]
        mulsd   xmm0, xmm1
        addsd   xmm0, xmm2
      }
    }
    else
    {
      __asm { movapd  xmm0, xmm1 }
    }
  }
  else
  {
    __asm { movapd  xmm0, xmm2 }
  }
  return result;
}

//----- (1000BA00) --------------------------------------------------------
int __thiscall sub_1000BA00(void *this, int a2, char a3, int a4, int a5)
{
  int v7; // ebx@1
  char v9; // [sp-48h] [bp-58h]@1
  int v10; // [sp-44h] [bp-54h]@1
  int v11; // [sp-40h] [bp-50h]@1
  int v12; // [sp-3Ch] [bp-4Ch]@1
  int v13; // [sp-38h] [bp-48h]@1
  unsigned int v14; // [sp-34h] [bp-44h]@1
  char v15; // [sp-30h] [bp-40h]@1
  __int64 v16; // [sp-28h] [bp-38h]@1
  __int64 v17; // [sp-20h] [bp-30h]@1
  __int64 v18; // [sp-18h] [bp-28h]@1
  __int64 v19; // [sp-10h] [bp-20h]@1
  int v20; // [sp-8h] [bp-18h]@1
  int v21; // [sp-4h] [bp-14h]@1

  _ESI = a2;
  v21 = a5;
  __asm { movq    xmm0, qword ptr [esi+18h] }
  v20 = a4;
  v7 = (int)this;
  _EAX = &v15;
  __asm
  {
    movq    qword ptr [eax], xmm0
    movq    xmm0, qword ptr [esi+20h]
    movq    qword ptr [eax+8], xmm0
    movq    xmm0, qword ptr [esi+28h]
    movq    qword ptr [eax+10h], xmm0
    movq    xmm0, qword ptr [esi+30h]
    movq    qword ptr [eax+18h], xmm0
    movq    xmm0, qword ptr [esi+38h]
  }
  v14 = 15;
  v13 = 0;
  __asm { movq    qword ptr [eax+20h], xmm0 }
  v9 = 0;
  loc_1000AB40(a2, 0, -1);
  sub_1000B010(
    v7,
    word_10075E78,
    a3,
    *(void **)&v9,
    v10,
    v11,
    v12,
    v13,
    v14,
    *(__int64 *)&v15,
    v16,
    v17,
    v18,
    v19,
    v20,
    v21);
  *(_DWORD *)v7 = &off_1006827C;
  memcpy((void *)(v7 + 312), (const void *)(a2 + 64), 0x50u);
  return v7;
}
// 1006827C: using guessed type int (__stdcall *off_1006827C)(char);
// 10075E78: using guessed type __int16 word_10075E78;

//----- (1000BAA0) --------------------------------------------------------
void *__thiscall sub_1000BAA0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_1006827C;
  sub_1000B2E0((int)this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1006827C: using guessed type int (__stdcall *off_1006827C)(char);

//----- (1000BAD0) --------------------------------------------------------
int __fastcall sub_1000BAD0(int a1, char a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9, int a10)
{
  int v10; // edx@1
  char v11; // bl@1
  int v12; // edi@1
  int v13; // ecx@1
  signed int v14; // eax@2
  int v15; // eax@4
  int v16; // ecx@4
  void *v17; // esi@4
  int v18; // esi@5
  char v20; // [sp-1Ch] [bp-D0h]@1
  void *v21; // [sp-18h] [bp-CCh]@1
  int v22; // [sp-14h] [bp-C8h]@1
  int v23; // [sp-10h] [bp-C4h]@1
  int v24; // [sp-Ch] [bp-C0h]@1
  int v25; // [sp-8h] [bp-BCh]@1
  unsigned int v26; // [sp-4h] [bp-B8h]@1
  int v27; // [sp+10h] [bp-A4h]@4
  void *v28; // [sp+14h] [bp-A0h]@1
  int v29; // [sp+24h] [bp-90h]@1
  unsigned int v30; // [sp+28h] [bp-8Ch]@1
  int v31; // [sp+4Ch] [bp-68h]@2
  unsigned int v32; // [sp+A4h] [bp-10h]@1
  int v33; // [sp+B0h] [bp-4h]@1
  int v34; // [sp+B4h] [bp+0h]@1

  v32 = (unsigned int)&v34 ^ __security_cookie;
  v26 = (unsigned int)&v34 ^ __security_cookie;
  v11 = a2;
  v12 = a1;
  v33 = 0;
  v30 = 15;
  v29 = 0;
  LOBYTE(v28) = 0;
  LOBYTE(v33) = 1;
  v25 = 15;
  v24 = 0;
  v20 = 0;
  loc_1000AB40(&a3, 0, -1, *(_DWORD *)&v20);
  if ( !sub_1000C2A0(v13, (int)&v28, v21, v22, v23, v24, v25, v26) )
    goto LABEL_14;
  v14 = v31;
  if ( !v11 )
    v14 = 15;
  v31 = v14;
  v15 = sub_1002ADB1(v10, 15, v11, v12, 456);
  v17 = (void *)v15;
  v27 = v15;
  LOBYTE(v33) = 2;
  if ( v15 )
  {
    sub_1000BC10(v15, v16);
    v18 = sub_1000BA00(v17, (int)&v28, v12, a9, a10);
  }
  else
  {
LABEL_14:
    v18 = 0;
  }
  if ( v30 >= 0x10 )
    sub_1002A4AA(v28);
  v30 = 15;
  v29 = 0;
  LOBYTE(v28) = 0;
  if ( a8 >= 0x10 )
    sub_1002A4AA(a3);
  return v18;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (1000BC10) --------------------------------------------------------
void __thiscall sub_1000BC10(int this, int a2)
{
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 184) = 0;
  *(_DWORD *)(this + 188) = 0;
  *(_DWORD *)(this + 192) = 0;
  *(_DWORD *)(this + 196) = 0;
  *(_DWORD *)(this + 276) = 0;
  *(_DWORD *)(this + 280) = 0;
  *(_DWORD *)(this + 284) = 0;
}

//----- (1000BC60) --------------------------------------------------------
char __thiscall sub_1000BC60(int _ECX)
{
  char result; // al@4
  int v14; // eax@5

  __asm
  {
    movsd   xmm0, ds:qword_10069570
    comisd  xmm0, qword ptr [ecx+1A8h]
    movapd  xmm4, xmm1
  }
  if ( !(_CF | _ZF) )
    goto LABEL_14;
  __asm
  {
    movsd   xmm0, ds:qword_10069578
    comisd  xmm0, qword ptr [ecx+1B0h]
  }
  if ( _CF | _ZF )
    goto LABEL_15;
  __asm { comisd  xmm0, qword ptr [ecx+1B8h] }
  if ( _CF | _ZF )
  {
LABEL_15:
    result = 0;
  }
  else
  {
LABEL_14:
    __asm { movsd   xmm2, qword ptr [ecx+190h] }
    v14 = *(_DWORD *)(_ECX + 8);
    __asm
    {
      movsd   xmm3, ds:qword_100695A0
      movapd  xmm1, xmm2
      subsd   xmm1, qword ptr [ecx+188h]
      mulsd   xmm1, ds:qword_10069488
      andpd   xmm1, xmm3
    }
    if ( !v14 )
      goto LABEL_16;
    if ( !(*(_BYTE *)(v14 + 112) & 4) )
      goto LABEL_16;
    __asm
    {
      xorpd   xmm1, ds:xmmword_100695B0
      movaps  xmm0, xmm2
      subsd   xmm0, xmm4
      comisd  xmm1, xmm0
    }
    if ( _CF )
      goto LABEL_16;
    __asm
    {
      movsd   xmm0, qword ptr [ecx+140h]
      comisd  xmm0, qword ptr [ecx+1A0h]
    }
    if ( _CF | _ZF )
      goto LABEL_16;
    __asm
    {
      movsd   xmm1, qword ptr [ecx+198h]
      movsd   xmm0, qword ptr [ecx+1C0h]
      subsd   xmm0, xmm1
      subsd   xmm2, xmm1
      andpd   xmm0, xmm3
      comisd  xmm2, xmm0
    }
    if ( _CF | _ZF )
LABEL_16:
      result = 0;
    else
      result = 1;
  }
  return result;
}

//----- (1000BD30) --------------------------------------------------------
char __thiscall sub_1000BD30(int _ECX)
{
  char result; // al@4
  int v14; // eax@5

  __asm
  {
    movsd   xmm0, qword ptr [ecx+1A8h]
    comisd  xmm0, ds:qword_10069568
    movapd  xmm5, xmm1
  }
  if ( !(_CF | _ZF) )
    goto LABEL_14;
  __asm
  {
    movsd   xmm0, qword ptr [ecx+1B0h]
    movsd   xmm2, ds:qword_10069518
    comisd  xmm0, xmm2
  }
  if ( _CF | _ZF )
    goto LABEL_15;
  __asm
  {
    movsd   xmm0, qword ptr [ecx+1B8h]
    comisd  xmm0, xmm2
  }
  if ( _CF | _ZF )
  {
LABEL_15:
    result = 0;
  }
  else
  {
LABEL_14:
    __asm { movsd   xmm3, qword ptr [ecx+190h] }
    v14 = *(_DWORD *)(_ECX + 8);
    __asm
    {
      movsd   xmm4, ds:qword_100695A0
      movapd  xmm1, xmm3
      subsd   xmm1, qword ptr [ecx+188h]
      mulsd   xmm1, ds:qword_10069488
      andpd   xmm1, xmm4
    }
    if ( !v14 )
      goto LABEL_16;
    if ( !(*(_BYTE *)(v14 + 112) & 4) )
      goto LABEL_16;
    __asm
    {
      movaps  xmm0, xmm3
      subsd   xmm0, xmm5
      comisd  xmm0, xmm1
    }
    if ( _CF )
      goto LABEL_16;
    __asm
    {
      movsd   xmm1, ds:qword_10069510
      subsd   xmm1, qword ptr [ecx+140h]
      movsd   xmm0, qword ptr [ecx+1A0h]
      comisd  xmm0, xmm1
    }
    if ( _CF | _ZF )
      goto LABEL_16;
    __asm
    {
      movsd   xmm1, qword ptr [ecx+198h]
      movsd   xmm0, qword ptr [ecx+1C0h]
      movapd  xmm2, xmm1
      subsd   xmm0, xmm1
      subsd   xmm2, xmm3
      andpd   xmm0, xmm4
      comisd  xmm2, xmm0
    }
    if ( _CF | _ZF )
LABEL_16:
      result = 0;
    else
      result = 1;
  }
  return result;
}

//----- (1000BE10) --------------------------------------------------------
char __thiscall sub_1000BE10(int _ECX)
{
  char result; // al@4
  int v14; // eax@5

  __asm
  {
    movsd   xmm0, qword ptr [ecx+1A8h]
    comisd  xmm0, ds:qword_10069568
  }
  if ( !(_CF | _ZF) )
    goto LABEL_13;
  __asm
  {
    movsd   xmm0, qword ptr [ecx+1B0h]
    movsd   xmm2, ds:qword_10069518
    comisd  xmm0, xmm2
  }
  if ( _CF | _ZF )
    goto LABEL_14;
  __asm
  {
    movsd   xmm0, qword ptr [ecx+1B8h]
    comisd  xmm0, xmm2
  }
  if ( _CF | _ZF )
  {
LABEL_14:
    result = 0;
  }
  else
  {
LABEL_13:
    v14 = *(_DWORD *)(_ECX + 8);
    if ( !v14 )
      goto LABEL_15;
    if ( !(*(_BYTE *)(v14 + 112) & 4) )
      goto LABEL_15;
    __asm
    {
      movsd   xmm0, qword ptr [ecx+190h]
      subsd   xmm0, xmm1
      comisd  xmm0, ds:qword_10069470
    }
    if ( _CF )
      goto LABEL_15;
    __asm
    {
      movsd   xmm1, ds:qword_10069510
      subsd   xmm1, qword ptr [ecx+148h]
      movsd   xmm0, qword ptr [ecx+1A0h]
      comisd  xmm0, xmm1
    }
    if ( _CF | _ZF )
LABEL_15:
      result = 0;
    else
      result = 1;
  }
  return result;
}

//----- (1000BEA0) --------------------------------------------------------
char __thiscall sub_1000BEA0(int this, __int64 a2)
{
  unsigned int v5; // ebx@2
  unsigned int v6; // edi@2
  double v8; // ST30_8@2
  __int64 v9; // qax@2
  double v10; // ST30_8@2
  __int64 v11; // qax@2
  double v12; // ST20_8@12
  double v13; // ST30_8@12
  char result; // al@14
  unsigned int v21; // [sp+2Ch] [bp-14h]@2
  unsigned int v22; // [sp+34h] [bp-Ch]@2

  _ESI = this;
  __asm
  {
    movsd   [ebp+var_30], xmm2
    movsd   [ebp+var_28], xmm1
  }
  if ( !*(_BYTE *)(this + 352) )
    goto LABEL_18;
  __asm
  {
    movsd   xmm0, qword ptr [esi+178h]
    mulsd   xmm0, ds:qword_10069580
    movsd   [ebp+var_10], xmm0
  }
  LODWORD(v9) = sub_1004D276(v8);
  __asm
  {
    movsd   xmm0, qword ptr [esi+180h]
    mulsd   xmm0, ds:qword_10069580
  }
  v6 = a2 - v9;
  __asm { movsd   [ebp+var_10], xmm0 }
  v21 = (unsigned __int64)(a2 - v9) >> 32;
  LODWORD(v11) = sub_1004D276(v10);
  v22 = (unsigned __int64)(a2 - v11) >> 32;
  v5 = a2 - v11;
  if ( (signed int)v21 > *(_DWORD *)(_ESI + 52) )
    goto LABEL_18;
  if ( (signed int)v21 >= *(_DWORD *)(_ESI + 52) && v6 >= *(_DWORD *)(_ESI + 48) )
    goto LABEL_18;
  __asm
  {
    movsd   xmm0, qword ptr [esi+80h]
    movsd   xmm1, qword ptr [esi+168h]
    movsd   xmm2, qword ptr [esi+170h]
    mulsd   xmm1, xmm0
    mulsd   xmm2, xmm0
  }
  if ( (signed int)v21 < *(_DWORD *)(_ESI + 52)
    || (signed int)v21 <= *(_DWORD *)(_ESI + 52) && v6 < *(_DWORD *)(_ESI + 48) )
  {
    if ( *(_DWORD *)(_ESI + 52) < (signed int)v22
      || *(_DWORD *)(_ESI + 52) <= (signed int)v22 && *(_DWORD *)(_ESI + 48) < v5 )
    {
      v12 = (double)(signed __int64)(*(_QWORD *)(_ESI + 48) - __PAIR__(v21, v6));
      __asm
      {
        movsd   xmm0, [ebp+var_20]
        subsd   xmm2, xmm1
      }
      v13 = (double)(signed __int64)(__PAIR__(v22, v5) - __PAIR__(v21, v6));
      __asm
      {
        divsd   xmm0, [ebp+var_10]
        mulsd   xmm0, xmm2
        addsd   xmm0, xmm1
        movaps  xmm1, xmm0
      }
    }
    else
    {
      __asm { movaps  xmm1, xmm2 }
    }
  }
  __asm
  {
    movsd   xmm0, [ebp+var_28]
    subsd   xmm0, [ebp+var_30]
    divsd   xmm0, qword ptr [esi+88h]
    comisd  xmm0, xmm1
  }
  if ( _CF )
LABEL_18:
    result = 0;
  else
    result = 1;
  return result;
}

//----- (1000C000) --------------------------------------------------------
char __thiscall sub_1000C000(int this, __int64 a2)
{
  unsigned int v5; // ebx@2
  unsigned int v6; // edi@2
  double v8; // ST30_8@2
  __int64 v9; // qax@2
  double v10; // ST30_8@2
  __int64 v11; // qax@2
  double v12; // ST20_8@12
  double v13; // ST30_8@12
  char result; // al@14
  unsigned int v21; // [sp+2Ch] [bp-14h]@2
  unsigned int v22; // [sp+34h] [bp-Ch]@2

  _ESI = this;
  __asm
  {
    movsd   [ebp+var_28], xmm2
    movsd   [ebp+var_30], xmm1
  }
  if ( !*(_BYTE *)(this + 352) )
    goto LABEL_18;
  __asm
  {
    movsd   xmm0, qword ptr [esi+178h]
    mulsd   xmm0, ds:qword_10069580
    movsd   [ebp+var_10], xmm0
  }
  LODWORD(v9) = sub_1004D276(v8);
  __asm
  {
    movsd   xmm0, qword ptr [esi+180h]
    mulsd   xmm0, ds:qword_10069580
  }
  v6 = a2 - v9;
  __asm { movsd   [ebp+var_10], xmm0 }
  v21 = (unsigned __int64)(a2 - v9) >> 32;
  LODWORD(v11) = sub_1004D276(v10);
  v22 = (unsigned __int64)(a2 - v11) >> 32;
  v5 = a2 - v11;
  if ( (signed int)v21 > *(_DWORD *)(_ESI + 52) )
    goto LABEL_18;
  if ( (signed int)v21 >= *(_DWORD *)(_ESI + 52) && v6 >= *(_DWORD *)(_ESI + 48) )
    goto LABEL_18;
  __asm
  {
    movsd   xmm0, qword ptr [esi+80h]
    movsd   xmm1, qword ptr [esi+168h]
    movsd   xmm2, qword ptr [esi+170h]
    mulsd   xmm1, xmm0
    mulsd   xmm2, xmm0
  }
  if ( (signed int)v21 < *(_DWORD *)(_ESI + 52)
    || (signed int)v21 <= *(_DWORD *)(_ESI + 52) && v6 < *(_DWORD *)(_ESI + 48) )
  {
    if ( *(_DWORD *)(_ESI + 52) < (signed int)v22
      || *(_DWORD *)(_ESI + 52) <= (signed int)v22 && *(_DWORD *)(_ESI + 48) < v5 )
    {
      v12 = (double)(signed __int64)(*(_QWORD *)(_ESI + 48) - __PAIR__(v21, v6));
      __asm
      {
        movsd   xmm0, [ebp+var_20]
        subsd   xmm2, xmm1
      }
      v13 = (double)(signed __int64)(__PAIR__(v22, v5) - __PAIR__(v21, v6));
      __asm
      {
        divsd   xmm0, [ebp+var_10]
        mulsd   xmm0, xmm2
        addsd   xmm0, xmm1
        movaps  xmm1, xmm0
      }
    }
    else
    {
      __asm { movaps  xmm1, xmm2 }
    }
  }
  __asm
  {
    movsd   xmm0, [ebp+var_28]
    subsd   xmm0, [ebp+var_30]
    divsd   xmm0, qword ptr [esi+88h]
    comisd  xmm0, xmm1
  }
  if ( _CF )
LABEL_18:
    result = 0;
  else
    result = 1;
  return result;
}

//----- (1000C160) --------------------------------------------------------
char __thiscall sub_1000C160(int this, __int64 a2, __int64 a3)
{
  int v11; // eax@3
  unsigned int v12; // ebx@3
  unsigned int v13; // edi@3
  __int64 v14; // kr00_8@3
  double v16; // ST40_8@3
  __int64 v17; // qax@3
  double v18; // ST40_8@3
  __int64 v19; // qax@3
  __int64 v20; // ST10_8@4
  __int64 v21; // ST08_8@4
  double v22; // ST00_8@4
  char result; // al@6

  _ESI = this;
  __asm
  {
    movsd   xmm1, qword ptr [esi+158h]
    comisd  xmm1, ds:qword_10069470
    movsd   [ebp+var_28], xmm3
    movsd   [ebp+var_20], xmm2
  }
  if ( _CF )
  {
    result = 0;
  }
  else
  {
    __asm
    {
      movsd   xmm0, qword ptr [esi+80h]
      mulsd   xmm0, xmm1
      movsd   [ebp+var_18], xmm0
    }
    if ( *(_BYTE *)(this + 352) )
    {
      __asm
      {
        movsd   xmm0, qword ptr [esi+178h]
        mulsd   xmm0, ds:qword_10069580
        movsd   [ebp+var_10], xmm0
      }
      LODWORD(v17) = sub_1004D276(v16);
      __asm
      {
        movsd   xmm0, qword ptr [esi+180h]
        mulsd   xmm0, ds:qword_10069580
      }
      v13 = a2 - v17;
      __asm { movsd   [ebp+var_10], xmm0 }
      v12 = (unsigned __int64)(a2 - v17) >> 32;
      LODWORD(v19) = sub_1004D276(v18);
      v14 = a2 - v19;
      v11 = (unsigned __int64)(a2 - v19) >> 32;
      if ( (signed __int64)__PAIR__(v12, v13) >= *(_QWORD *)(_ESI + 48) )
      {
        __asm { movsd   xmm0, [ebp+var_18] }
      }
      else
      {
        __asm { movsd   xmm2, qword ptr [esi+80h] }
        HIDWORD(v20) = *(_DWORD *)(_ESI + 52);
        __asm { movsd   xmm1, qword ptr [esi+170h] }
        LODWORD(v20) = *(_DWORD *)(_ESI + 48);
        __asm
        {
          movsd   xmm0, qword ptr [esi+168h]
          mulsd   xmm1, xmm2
        }
        HIDWORD(v21) = v11;
        LODWORD(v21) = v14;
        __asm { mulsd   xmm0, xmm2 }
        HIDWORD(v22) = v12;
        LODWORD(v22) = v13;
        __asm { movaps  xmm2, xmm1 }
        sub_1000B970(v22, v21, v20);
      }
    }
    __asm
    {
      mulsd   xmm0, [ebp+arg_8]
      movsd   xmm1, [ebp+var_20]
      addsd   xmm1, [ebp+var_28]
      mulsd   xmm0, qword ptr [esi+98h]
      comisd  xmm1, xmm0
    }
    result = !_CF;
  }
  return result;
}

//----- (1000C2A0) --------------------------------------------------------
char __fastcall sub_1000C2A0(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8)
{
  char *v8; // ecx@1
  char *v9; // eax@3
  int v10; // edi@5
  int v11; // esi@5
  int v12; // ebx@8
  int v13; // esi@10
  int v14; // eax@10
  void *v15; // ST00_4@10
  int v16; // ST04_4@10
  int v17; // ST08_4@10
  char v18; // bl@13
  char v20; // [sp-Ch] [bp-48h]@10
  int v21; // [sp-8h] [bp-44h]@10
  unsigned int v22; // [sp-4h] [bp-40h]@10
  int v23; // [sp+0h] [bp-3Ch]@10
  int v24; // [sp+4h] [bp-38h]@10
  signed int v25; // [sp+8h] [bp-34h]@10
  void *v26; // [sp+10h] [bp-2Ch]@10
  int v27; // [sp+20h] [bp-1Ch]@10
  unsigned int v28; // [sp+24h] [bp-18h]@10
  void *v29; // [sp+28h] [bp-14h]@1
  int v30; // [sp+38h] [bp-4h]@1

  v29 = (void *)a2;
  v30 = 0;
  v8 = (char *)&a3;
  if ( a8 >= 0x10 )
    v8 = (char *)a3;
  v9 = (char *)&a3;
  if ( a8 >= 0x10 )
    v9 = (char *)a3;
  v11 = (int)&v8[a7];
  v10 = (int)&a3;
  if ( a8 >= 0x10 )
    v10 = (int)a3;
  if ( v10 != v11 )
  {
    v12 = (int)&v9[-v10];
    do
    {
      *(_BYTE *)(v12 + v10) = sub_10030357(v12, v10, *(_BYTE *)v10);
      ++v10;
    }
    while ( v10 != v11 );
  }
  v28 = 15;
  v27 = 0;
  LOBYTE(v26) = 0;
  loc_1000AB40(&v26, &a3, 0, -1, v23, v24, v25);
  LOBYTE(v30) = 1;
  v25 = 15;
  v24 = 0;
  v20 = 0;
  loc_1000AB40(&v26, 0, -1, *(_DWORD *)&v20);
  v14 = sub_1000C450((int)&unk_10075E80, (int)&dword_10075FA0, v15, v16, v17, *(int *)&v20, v21, v22);
  LOBYTE(v30) = 0;
  v13 = v14;
  if ( v28 >= 0x10 )
    sub_1002A4AA(v26);
  v28 = 15;
  v27 = 0;
  LOBYTE(v26) = 0;
  if ( (int *)v13 == &dword_10075FA0 )
  {
    v18 = 0;
  }
  else
  {
    sub_1000C3E0(v29, v13);
    v18 = 1;
  }
  if ( a8 >= 0x10 )
    sub_1002A4AA(a3);
  return v18;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10075FA0: using guessed type int dword_10075FA0;

//----- (1000C3E0) --------------------------------------------------------
void *__thiscall sub_1000C3E0(void *this, int a2)
{
  _ESI = a2;
  _EBX = this;
  if ( this != (void *)a2 )
    loc_1000AB40(a2, 0, -1);
  __asm
  {
    movq    xmm0, qword ptr [esi+18h]
    movq    qword ptr [ebx+18h], xmm0
    movq    xmm0, qword ptr [esi+20h]
    movq    qword ptr [ebx+20h], xmm0
    movq    xmm0, qword ptr [esi+28h]
    movq    qword ptr [ebx+28h], xmm0
    movq    xmm0, qword ptr [esi+30h]
    movq    qword ptr [ebx+30h], xmm0
    movq    xmm0, qword ptr [esi+38h]
    movq    qword ptr [ebx+38h], xmm0
  }
  memcpy((char *)_EBX + 64, (const void *)(a2 + 64), 0x50u);
  return _EBX;
}

//----- (1000C450) --------------------------------------------------------
int __fastcall sub_1000C450(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8)
{
  int v8; // edi@1
  int i; // esi@1
  unsigned __int8 *v10; // eax@3

  v8 = a2;
  for ( i = a1; i != v8; i += 144 )
  {
    if ( *(_DWORD *)(i + 20) < 0x10u )
      v10 = (unsigned __int8 *)i;
    else
      v10 = *(unsigned __int8 **)i;
    if ( sub_10002C30((int)&a3, v10, a1, *(_DWORD *)(i + 16)) != -1 )
      break;
  }
  if ( a8 >= 0x10 )
    sub_1002A4AA(a3);
  return i;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1000C4A0) --------------------------------------------------------
void *__thiscall sub_1000C4A0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_1006034C;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1006034C: using guessed type int (__stdcall *off_1006034C)(char);

//----- (1000C4D0) --------------------------------------------------------
int __thiscall sub_1000C4D0(void *this, int a2, int a3)
{
  int result; // eax@1

  result = a2;
  *(_DWORD *)a2 = a3;
  *(_DWORD *)(a2 + 4) = this;
  return result;
}

//----- (1000C4F0) --------------------------------------------------------
char __thiscall sub_1000C4F0(void *this, int a2, int a3)
{
  int v3; // eax@1
  char v5; // [sp+0h] [bp-8h]@1

  v3 = (*(int (__stdcall **)(char *, int))(*(_DWORD *)this + 12))(&v5, a2);
  return *(_DWORD *)(v3 + 4) == *(_DWORD *)(a3 + 4) && *(_DWORD *)v3 == *(_DWORD *)a3;
}

//----- (1000C530) --------------------------------------------------------
char __thiscall sub_1000C530(void *this, int a2, int a3)
{
  return this == *(void **)(a2 + 4) && *(_DWORD *)a2 == a3;
}

//----- (1000C550) --------------------------------------------------------
int __cdecl sub_1000C550()
{
  return (int)"generic";
}

//----- (1000C560) --------------------------------------------------------
int __stdcall sub_1000C560(int a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edx@1
  int result; // eax@4

  v2 = sub_10029607(a2);
  v3 = "unknown error";
  if ( v2 )
    v3 = (const char *)v2;
  *(_DWORD *)(a1 + 20) = 15;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)a1 = 0;
  if ( *v3 )
  {
    loc_1000AEB0(a1, v3, strlen(v3));
    result = a1;
  }
  else
  {
    loc_1000AEB0(a1, v3, 0);
    result = a1;
  }
  return result;
}

//----- (1000C5D0) --------------------------------------------------------
int __cdecl sub_1000C5D0()
{
  return (int)"iostream";
}

//----- (1000C5E0) --------------------------------------------------------
int __stdcall sub_1000C5E0(int a1, int a2)
{
  int result; // eax@2

  if ( a2 == 1 )
  {
    *(_DWORD *)(a1 + 20) = 15;
    *(_DWORD *)(a1 + 16) = 0;
    *(_BYTE *)a1 = 0;
    loc_1000AEB0(a1, "iostream stream error", 21);
    result = a1;
  }
  else
  {
    sub_1000C560(a1, a2);
    result = a1;
  }
  return result;
}

//----- (1000C630) --------------------------------------------------------
int __cdecl sub_1000C630()
{
  return (int)"system";
}

//----- (1000C640) --------------------------------------------------------
int __stdcall sub_1000C640(int a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edx@1
  int result; // eax@4

  v2 = sub_10029631(a2);
  v3 = "unknown error";
  if ( v2 )
    v3 = (const char *)v2;
  *(_DWORD *)(a1 + 20) = 15;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)a1 = 0;
  if ( *v3 )
  {
    loc_1000AEB0(a1, v3, strlen(v3));
    result = a1;
  }
  else
  {
    loc_1000AEB0(a1, v3, 0);
    result = a1;
  }
  return result;
}

//----- (1000C6B0) --------------------------------------------------------
int __stdcall sub_1000C6B0(int a1, int a2)
{
  int result; // eax@1
  char v3; // zf@1

  v3 = sub_10029607(a2) == 0;
  result = a1;
  *(_DWORD *)a1 = a2;
  if ( v3 )
    *(_DWORD *)(a1 + 4) = off_10076178;
  else
    *(_DWORD *)(a1 + 4) = off_1007617C;
  return result;
}
// 10076178: using guessed type int (__stdcall *off_10076178[3])(char);
// 1007617C: using guessed type int (__stdcall *off_1007617C[2])(char);

//----- (1000C700) --------------------------------------------------------
int __thiscall sub_1000C700(void *this)
{
  int result; // eax@2

  if ( this )
    result = (**(int (__stdcall ***)(_DWORD))this)(1);
  return result;
}

//----- (1000C710) --------------------------------------------------------
void *__thiscall sub_1000C710(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10061930;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10061930: using guessed type int (__stdcall *off_10061930)(char);

//----- (1000C740) --------------------------------------------------------
int __thiscall sub_1000C740(int this, int a2)
{
  *(_DWORD *)this = &off_10061930;
  *(_DWORD *)(this + 4) = a2;
  *(_DWORD *)this = &off_1006193C;
  *(_DWORD *)(this + 8) = 3;
  *(_DWORD *)(this + 16) = 0;
  return this;
}
// 10061930: using guessed type int (__stdcall *off_10061930)(char);
// 1006193C: using guessed type int (__stdcall *off_1006193C)(char);

//----- (1000C770) --------------------------------------------------------
void __thiscall sub_1000C770(int this, int a2)
{
  dword_100777FC = 0;
  dword_10077800 = 0;
  dword_10077804 = 0;
  dword_10077828 = 0;
  dword_1007782C = 0;
  dword_10077830 = 0;
  dword_10077838 = 0;
  dword_1007783C = 0;
  dword_10077840 = 0;
  dword_10077844 = 0;
  dword_10077848 = 0;
  dword_1007784C = 0;
  sub_1000C870((int)&dword_10077858, this);
  dword_10077960 = 0;
  dword_10077968 = 0;
  dword_1007796C = 0;
  dword_10077970 = 0;
  dword_1007798C = 0;
  dword_10077990 = 0;
  dword_10077994 = 0;
  dword_100779B4 = 0;
  dword_100779B8 = 0;
  dword_100779D4 = 0;
  dword_100779D8 = 0;
}
// 100777FC: using guessed type int dword_100777FC;
// 10077800: using guessed type int dword_10077800;
// 10077804: using guessed type int dword_10077804;
// 10077828: using guessed type int dword_10077828;
// 1007782C: using guessed type int dword_1007782C;
// 10077830: using guessed type int dword_10077830;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;
// 10077840: using guessed type int dword_10077840;
// 10077844: using guessed type int dword_10077844;
// 10077848: using guessed type int dword_10077848;
// 1007784C: using guessed type int dword_1007784C;
// 10077858: using guessed type int dword_10077858;
// 10077960: using guessed type int dword_10077960;
// 10077968: using guessed type int dword_10077968;
// 1007796C: using guessed type int dword_1007796C;
// 10077970: using guessed type int dword_10077970;
// 1007798C: using guessed type int dword_1007798C;
// 10077990: using guessed type int dword_10077990;
// 10077994: using guessed type int dword_10077994;
// 100779B4: using guessed type int dword_100779B4;
// 100779B8: using guessed type int dword_100779B8;
// 100779D4: using guessed type int dword_100779D4;
// 100779D8: using guessed type int dword_100779D8;

//----- (1000C870) --------------------------------------------------------
void __thiscall sub_1000C870(int this, int a2)
{
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 68) = 0;
  *(_DWORD *)(this + 80) = 0;
  *(_DWORD *)(this + 84) = 0;
  *(_DWORD *)(this + 104) = 0;
  *(_DWORD *)(this + 144) = 0;
  *(_DWORD *)(this + 148) = 0;
  *(_DWORD *)(this + 156) = 0;
  *(_DWORD *)(this + 160) = 0;
  *(_DWORD *)(this + 192) = 0;
  *(_DWORD *)(this + 216) = 0;
  *(_DWORD *)(this + 240) = 0;
}

//----- (1000C8F0) --------------------------------------------------------
signed int __stdcall sub_1000C8F0(int a1, int a2, int a3)
{
  return 1;
}

//----- (1000C900) --------------------------------------------------------
void *__thiscall sub_1000C900(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_10068B14;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10068B14: using guessed type int (__stdcall *off_10068B14[2])(char);

//----- (1000C940) --------------------------------------------------------
__int16 __userpurge sub_1000C940<ax>(int a1<ecx>, int a2<edi>, __int64 a3)
{
  int v3; // ebx@1
  char v4; // zf@1
  int v5; // esi@2
  __int64 v6; // qax@6
  __int64 v7; // qax@6
  __int16 result; // ax@9
  unsigned __int64 v9; // ST00_8@9
  __int64 v10; // qax@9
  __int64 v11; // qax@9
  int v12; // [sp+Ch] [bp-34h]@9
  int v13; // [sp+10h] [bp-30h]@9
  int v14; // [sp+14h] [bp-2Ch]@9
  __int16 v15; // [sp+24h] [bp-1Ch]@9
  __int64 v16; // [sp+30h] [bp-10h]@9
  unsigned int v17; // [sp+3Ch] [bp-4h]@1
  int v18; // [sp+40h] [bp+0h]@1

  v17 = (unsigned int)&v18 ^ __security_cookie;
  v3 = a1;
  v4 = *(_BYTE *)(a1 + 12) == 0;
  *(_QWORD *)(a1 + 48) = a3;
  if ( v4 && (v5 = *(_DWORD *)(a1 + 8)) != 0 )
  {
    if ( *(_DWORD *)(v5 + 132) >= -2147483648 && (*(_DWORD *)(v5 + 132) > -2147483648 || *(_DWORD *)(v5 + 128)) )
    {
      LODWORD(v7) = sub_10029F21();
      v6 = v7 - *(_QWORD *)(v5 + 128);
      *(_DWORD *)(v3 + 28) = HIDWORD(v6);
    }
    else
    {
      LODWORD(v6) = sub_10029F21();
      *(_DWORD *)(v3 + 28) = HIDWORD(v6);
    }
  }
  else
  {
    LODWORD(v6) = a3 - *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 28) = (unsigned __int64)(a3 - *(_QWORD *)(a1 + 16)) >> 32;
  }
  *(_DWORD *)(v3 + 24) = v6;
  HIDWORD(v9) = ((_DWORD)v6 >= 0xFFB3B4C0u) + *(_DWORD *)(v3 + 28);
  LODWORD(v9) = v6 + 5000000;
  LODWORD(v10) = sub_1003AC50(v9, 0x989680u, 0);
  v16 = v10;
  sub_10030388(v3, a2, (int)&v12, (int)&v16);
  v11 = sub_10039A40(v16 - 3600 * v14 - 60 * v13 - v12, 10000000i64);
  *(_DWORD *)(v3 + 32) = v11;
  result = v15;
  *(_DWORD *)(v3 + 36) = HIDWORD(v11);
  *(_WORD *)(v3 + 40) = result;
  return result;
}
// 10074200: using guessed type int __security_cookie;

//----- (1000CA40) --------------------------------------------------------
char __stdcall sub_1000CA40(int a1)
{
  int *v1; // eax@1
  int v2; // ebx@1
  unsigned int v3; // edi@1

  v3 = *(_DWORD *)a1;
  v2 = *(_DWORD *)(a1 + 4);
  v1 = &dword_100779E0;
  while ( v2 < v1[1] || v2 <= v1[1] && v3 < *v1 || v2 >= v1[3] && (v2 > v1[3] || v3 >= v1[2]) )
  {
    v1 += 4;
    if ( (_UNKNOWN *)v1 == &unk_10077A30 )
      return 0;
  }
  return 1;
}
// 100779E0: using guessed type int dword_100779E0;

//----- (1000CA90) --------------------------------------------------------
int __userpurge sub_1000CA90<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_100602FC;
  return v4;
}
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);

//----- (1000CAB0) --------------------------------------------------------
int __fastcall sub_1000CAB0(int a1, const char *a2)
{
  int v2; // esi@1
  char v3; // bl@2
  int *v4; // edi@2
  char v5; // zf@3
  unsigned int v6; // ecx@4
  char v7; // bl@11
  void *v9; // [sp+10h] [bp-40h]@2
  int v10; // [sp+20h] [bp-30h]@2
  unsigned int v11; // [sp+24h] [bp-2Ch]@2
  void *v12; // [sp+28h] [bp-28h]@3
  int v13; // [sp+38h] [bp-18h]@3
  unsigned int v14; // [sp+3Ch] [bp-14h]@3
  int v15; // [sp+40h] [bp-10h]@1

  v2 = a1;
  v15 = 0;
  if ( a2 )
  {
    v5 = *a2 == 0;
    v14 = 15;
    v13 = 0;
    LOBYTE(v12) = 0;
    if ( v5 )
      v6 = 0;
    else
      v6 = strlen(a2);
    loc_1000AEB0(&v12, a2, v6);
    v4 = (int *)&v12;
    v3 = 2;
  }
  else
  {
    v11 = 15;
    v10 = 0;
    LOBYTE(v9) = 0;
    v4 = (int *)&v9;
    v3 = 1;
  }
  *(_DWORD *)(v2 + 20) = 15;
  *(_DWORD *)(v2 + 16) = 0;
  *(_BYTE *)v2 = 0;
  if ( (unsigned int)v4[5] >= 0x10 )
  {
    *(_DWORD *)v2 = *v4;
    *v4 = 0;
  }
  else
  {
    if ( v4[4] != -1 )
      sub_1002A4B0((void *)v2, v4, v4[4] + 1);
  }
  *(_DWORD *)(v2 + 16) = v4[4];
  v7 = v3 | 4;
  *(_DWORD *)(v2 + 20) = v4[5];
  v4[5] = 15;
  v4[4] = 0;
  *(_BYTE *)v4 = 0;
  if ( v7 & 2 )
  {
    v7 &= 0xFDu;
    if ( v14 >= 0x10 )
      sub_1002A4AA(v12);
    v14 = 15;
    v13 = 0;
    LOBYTE(v12) = 0;
  }
  if ( v7 & 1 )
  {
    if ( v11 >= 0x10 )
      sub_1002A4AA(v9);
  }
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1000CBF0) --------------------------------------------------------
void __userpurge SetBalance(int a1<ebx>, unsigned int a2, __int64 a3, const char *a4)
{
  int v4; // esi@3
  char v5; // [sp-18h] [bp-48h]@6
  int v6; // [sp-14h] [bp-44h]@6
  int v7; // [sp-10h] [bp-40h]@6
  int v8; // [sp-Ch] [bp-3Ch]@6
  int v9; // [sp-8h] [bp-38h]@6
  unsigned int v10; // [sp-4h] [bp-34h]@6
  char v11; // [sp+8h] [bp-28h]@1
  char v12; // [sp+10h] [bp-20h]@4
  unsigned int v13; // [sp+24h] [bp-Ch]@7
  char v14; // [sp+28h] [bp-8h]@1
  unsigned int v15; // [sp+2Ch] [bp-4h]@1

  v15 = (unsigned int)&v11 ^ __security_cookie;
  sub_1002B6B7((int)&v14, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    sub_1002B6E5(&v14);
  }
  else
  {
    v4 = *(_DWORD *)(dword_10077838 + 4 * a2);
    sub_1002B6E5(&v14);
    if ( v4 )
    {
      sub_1000CAB0((int)&v12, a4);
      if ( !*(_BYTE *)(v4 + 12) )
      {
        if ( *(_DWORD *)(v4 + 8) )
        {
          v10 = 15;
          v9 = 0;
          v5 = 0;
          loc_1000AB40(&v12, 0, -1);
          __asm { movsd   xmm1, [ebp+arg_4] }
          sub_10021CA0(*(void **)(v4 + 8), *(void **)&v5, v6, v7, v8, v9, v10);
        }
      }
      if ( v13 >= 0x10 )
        sub_1002A4AA(*(LPVOID *)&v12);
    }
  }
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (1000CCD0) --------------------------------------------------------
char __userpurge SetMarket<al>(int a1<ebx>, unsigned int a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  int v7; // esi@3
  int v8; // eax@5
  int v9; // ecx@5
  __int64 v10; // ST10_8@5
  __int64 v12; // ST08_8@5
  char v15; // [sp+14h] [bp-3Ch]@1
  char v16; // [sp+48h] [bp-8h]@1
  unsigned int v17; // [sp+4Ch] [bp-4h]@1

  v17 = (unsigned int)&v15 ^ __security_cookie;
  sub_1002B6B7((int)&v16, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    sub_1002B6E5(&v16);
LABEL_7:
    LOBYTE(v8) = 0;
    return v8;
  }
  v7 = *(_DWORD *)(dword_10077838 + 4 * a2);
  sub_1002B6E5(&v16);
  if ( !v7 || !(*(_BYTE *)(v7 + 56) & 1) )
    goto LABEL_7;
  __asm
  {
    movsd   xmm0, [ebp+arg_20]
    movsd   xmm3, [ebp+arg_10]
    movsd   xmm2, [ebp+arg_8]
  }
  v9 = v7;
  __asm
  {
    movsd   [esp+50h+var_48], xmm0
    movsd   xmm0, [ebp+arg_18]
    movsd   [esp+50h+var_50], xmm0
  }
  return sub_1000B410(v9, 10000000i64 * a3, v12, v10);
}
// 10074200: using guessed type int __security_cookie;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (1000CD90) --------------------------------------------------------
char __userpurge SetMaxSpread<al>(int a1<ebx>, unsigned int a2, __int64 a3)
{
  char result; // al@3
  char v5; // [sp+4h] [bp-8h]@1
  unsigned int v6; // [sp+8h] [bp-4h]@1
  int v7; // [sp+Ch] [bp+0h]@1

  v6 = (unsigned int)&v7 ^ __security_cookie;
  sub_1002B6B7((int)&v5, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    result = sub_1002B6E5(&v5);
  }
  else
  {
    _ESI = *(_DWORD *)(dword_10077838 + 4 * a2);
    result = sub_1002B6E5(&v5);
    if ( _ESI )
    {
      if ( *(_BYTE *)(_ESI + 56) & 1 )
      {
        __asm
        {
          movsd   xmm0, [ebp+arg_4]
          movsd   qword ptr [esi+70h], xmm0
        }
      }
    }
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (1000CE20) --------------------------------------------------------
char __userpurge S1_SetIndicators<al>(int a1<ebx>, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10)
{
  __int16 v10; // ax@3
  char v13; // [sp+4h] [bp-Ch]@1
  char v14; // [sp+8h] [bp-8h]@1
  unsigned int v15; // [sp+Ch] [bp-4h]@1

  v15 = (unsigned int)&v13 ^ __security_cookie;
  sub_1002B6B7((int)&v14, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    LOBYTE(v10) = sub_1002B6E5(&v14);
  }
  else
  {
    _ESI = *(_DWORD *)(dword_10077838 + 4 * a2);
    LOBYTE(v10) = sub_1002B6E5(&v14);
    if ( _ESI )
    {
      v10 = *(_WORD *)(_ESI + 56);
      if ( v10 == word_10075E78 )
      {
        __asm
        {
          movsd   xmm0, [ebp+arg_4]
          movsd   qword ptr [esi+188h], xmm0
          movsd   xmm0, [ebp+arg_C]
          movsd   qword ptr [esi+190h], xmm0
          movsd   xmm0, [ebp+arg_14]
          movsd   qword ptr [esi+198h], xmm0
          movsd   xmm0, [ebp+arg_1C]
          movsd   qword ptr [esi+1A0h], xmm0
          movsd   xmm0, [ebp+arg_24]
          movsd   qword ptr [esi+1A8h], xmm0
          movsd   xmm0, [ebp+arg_2C]
          movsd   qword ptr [esi+1B0h], xmm0
          movsd   xmm0, [ebp+arg_34]
          movsd   qword ptr [esi+1B8h], xmm0
          movsd   xmm0, [ebp+arg_3C]
          movsd   qword ptr [esi+1C0h], xmm0
        }
      }
    }
  }
  return v10;
}
// 10074200: using guessed type int __security_cookie;
// 10075E78: using guessed type __int16 word_10075E78;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (1000CF20) --------------------------------------------------------
char __userpurge S1_OpenLong1<al>(int a1<ebx>, unsigned int a2, __int64 a3)
{
  int v3; // esi@3
  int v4; // eax@5
  char v6; // [sp+4h] [bp-Ch]@1
  char v7; // [sp+8h] [bp-8h]@1
  unsigned int v8; // [sp+Ch] [bp-4h]@1

  v8 = (unsigned int)&v6 ^ __security_cookie;
  sub_1002B6B7((int)&v7, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    sub_1002B6E5(&v7);
LABEL_7:
    LOBYTE(v4) = 0;
    return v4;
  }
  v3 = *(_DWORD *)(dword_10077838 + 4 * a2);
  sub_1002B6E5(&v7);
  if ( !v3 || *(_WORD *)(v3 + 56) != word_10075E78 )
    goto LABEL_7;
  __asm { movsd   xmm1, [ebp+arg_4] }
  return sub_1000BC60(v3);
}
// 10074200: using guessed type int __security_cookie;
// 10075E78: using guessed type __int16 word_10075E78;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (1000CFC0) --------------------------------------------------------
char __userpurge S1_OpenShort1<al>(int a1<ebx>, unsigned int a2, __int64 a3)
{
  int v3; // esi@3
  int v4; // eax@5
  char v6; // [sp+4h] [bp-Ch]@1
  char v7; // [sp+8h] [bp-8h]@1
  unsigned int v8; // [sp+Ch] [bp-4h]@1

  v8 = (unsigned int)&v6 ^ __security_cookie;
  sub_1002B6B7((int)&v7, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    sub_1002B6E5(&v7);
LABEL_7:
    LOBYTE(v4) = 0;
    return v4;
  }
  v3 = *(_DWORD *)(dword_10077838 + 4 * a2);
  sub_1002B6E5(&v7);
  if ( !v3 || *(_WORD *)(v3 + 56) != word_10075E78 )
    goto LABEL_7;
  __asm { movsd   xmm1, [ebp+arg_4] }
  return sub_1000BD30(v3);
}
// 10074200: using guessed type int __security_cookie;
// 10075E78: using guessed type __int16 word_10075E78;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (1000D060) --------------------------------------------------------
signed int __userpurge S1_OpenLong2<eax>(int a1<ebx>, unsigned int a2, __int64 a3)
{
  int v16; // eax@8
  signed int result; // eax@12
  char v26; // [sp+4h] [bp-8h]@1
  unsigned int v27; // [sp+8h] [bp-4h]@1
  int v28; // [sp+Ch] [bp+0h]@1

  v27 = (unsigned int)&v28 ^ __security_cookie;
  sub_1002B6B7((int)&v26, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    sub_1002B6E5(&v26);
    return 0;
  }
  _ESI = *(_DWORD *)(dword_10077838 + 4 * a2);
  sub_1002B6E5(&v26);
  if ( !_ESI || *(_WORD *)(_ESI + 56) != word_10075E78 )
    return 0;
  __asm
  {
    movsd   xmm0, ds:qword_10069570
    comisd  xmm0, qword ptr [esi+1A8h]
  }
  if ( _CF | _ZF )
  {
    __asm
    {
      movsd   xmm0, ds:qword_10069578
      comisd  xmm0, qword ptr [esi+1B0h]
    }
    if ( _CF | _ZF )
      goto LABEL_18;
    __asm { comisd  xmm0, qword ptr [esi+1B8h] }
    if ( _CF | _ZF )
      goto LABEL_18;
  }
  v16 = *(_DWORD *)(_ESI + 8);
  if ( !v16 )
    goto LABEL_18;
  if ( !(*(_BYTE *)(v16 + 112) & 4) )
    goto LABEL_18;
  __asm
  {
    movsd   xmm1, qword ptr [esi+190h]
    subsd   xmm1, [ebp+arg_4]
    xorps   xmm0, xmm0
    comisd  xmm0, xmm1
  }
  if ( _CF )
    goto LABEL_18;
  __asm
  {
    movsd   xmm0, qword ptr [esi+148h]
    comisd  xmm0, qword ptr [esi+1A0h]
  }
  if ( _CF | _ZF )
LABEL_18:
    result = 0;
  else
    result = 1;
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10075E78: using guessed type __int16 word_10075E78;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (1000D170) --------------------------------------------------------
char __userpurge S1_OpenShort2<al>(int a1<ebx>, unsigned int a2, __int64 a3)
{
  int v3; // esi@3
  int v4; // eax@5
  char v6; // [sp+4h] [bp-8h]@1
  unsigned int v7; // [sp+8h] [bp-4h]@1
  int v8; // [sp+Ch] [bp+0h]@1

  v7 = (unsigned int)&v8 ^ __security_cookie;
  sub_1002B6B7((int)&v6, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    sub_1002B6E5(&v6);
LABEL_7:
    LOBYTE(v4) = 0;
    return v4;
  }
  v3 = *(_DWORD *)(dword_10077838 + 4 * a2);
  sub_1002B6E5(&v6);
  if ( !v3 || *(_WORD *)(v3 + 56) != word_10075E78 )
    goto LABEL_7;
  __asm { movsd   xmm1, [ebp+arg_4] }
  return sub_1000BE10(v3);
}
// 10074200: using guessed type int __security_cookie;
// 10075E78: using guessed type __int16 word_10075E78;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (1000D200) --------------------------------------------------------
signed int __userpurge S1_OpenLong22<eax>(int a1<ebx>, unsigned int a2, signed int a3, __int64 a4, __int64 a5)
{
  signed int result; // eax@10
  char v23; // [sp+4h] [bp-Ch]@1
  char v24; // [sp+8h] [bp-8h]@1
  unsigned int v25; // [sp+Ch] [bp-4h]@1

  v25 = (unsigned int)&v23 ^ __security_cookie;
  sub_1002B6B7((int)&v24, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    sub_1002B6E5(&v24);
    return 0;
  }
  _ESI = *(_DWORD *)(dword_10077838 + 4 * a2);
  sub_1002B6E5(&v24);
  if ( !_ESI || *(_WORD *)(_ESI + 56) != word_10075E78 )
    return 0;
  if ( a3 > 20 )
    goto LABEL_16;
  __asm
  {
    movd    xmm0, dword ptr [esi+154h]
    movsd   xmm3, qword ptr [esi+88h]
    movsd   xmm2, [ebp+arg_8]
    movsd   xmm4, qword ptr [esi+80h]
    cvtdq2pd xmm0, xmm0
    movapd  xmm1, xmm2
    subsd   xmm1, [ebp+arg_10]
    mulsd   xmm0, xmm3
    mulsd   xmm0, xmm4
    comisd  xmm0, xmm1
  }
  if ( _CF )
    goto LABEL_16;
  __asm
  {
    movd    xmm0, dword ptr [esi+150h]
    cvtdq2pd xmm0, xmm0
    mulsd   xmm0, xmm3
    mulsd   xmm0, xmm4
    comisd  xmm1, xmm0
  }
  if ( _CF )
    goto LABEL_16;
  __asm
  {
    subsd   xmm2, qword ptr [esi+190h]
    movapd  xmm0, xmm1
    mulsd   xmm0, ds:qword_100694A0
    comisd  xmm0, xmm2
  }
  if ( _CF | _ZF )
    goto LABEL_16;
  __asm
  {
    mulsd   xmm1, ds:qword_10069490
    comisd  xmm2, xmm1
  }
  if ( _CF | _ZF )
LABEL_16:
    result = 0;
  else
    result = 1;
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10075E78: using guessed type __int16 word_10075E78;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (1000D340) --------------------------------------------------------
signed int __userpurge S1_OpenShort22<eax>(int a1<ebx>, unsigned int a2, signed int a3, __int64 a4, __int64 a5)
{
  signed int result; // eax@10
  char v23; // [sp+4h] [bp-Ch]@1
  char v24; // [sp+8h] [bp-8h]@1
  unsigned int v25; // [sp+Ch] [bp-4h]@1

  v25 = (unsigned int)&v23 ^ __security_cookie;
  sub_1002B6B7((int)&v24, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    sub_1002B6E5(&v24);
    return 0;
  }
  _ESI = *(_DWORD *)(dword_10077838 + 4 * a2);
  sub_1002B6E5(&v24);
  if ( !_ESI || *(_WORD *)(_ESI + 56) != word_10075E78 )
    return 0;
  if ( a3 > 20 )
    goto LABEL_16;
  __asm
  {
    movd    xmm0, dword ptr [esi+154h]
    movsd   xmm2, qword ptr [esi+88h]
    movsd   xmm1, [ebp+arg_10]
    movsd   xmm3, [ebp+arg_8]
    movsd   xmm4, qword ptr [esi+80h]
    cvtdq2pd xmm0, xmm0
    subsd   xmm1, xmm3
    mulsd   xmm0, xmm2
    mulsd   xmm0, xmm4
    comisd  xmm0, xmm1
  }
  if ( _CF )
    goto LABEL_16;
  __asm
  {
    movd    xmm0, dword ptr [esi+150h]
    cvtdq2pd xmm0, xmm0
    mulsd   xmm0, xmm2
    mulsd   xmm0, xmm4
    comisd  xmm1, xmm0
  }
  if ( _CF )
    goto LABEL_16;
  __asm
  {
    movsd   xmm2, qword ptr [esi+190h]
    movaps  xmm0, xmm1
    mulsd   xmm0, ds:qword_100694A0
    subsd   xmm2, xmm3
    comisd  xmm0, xmm2
  }
  if ( _CF | _ZF )
    goto LABEL_16;
  __asm
  {
    mulsd   xmm1, ds:qword_10069490
    comisd  xmm2, xmm1
  }
  if ( _CF | _ZF )
LABEL_16:
    result = 0;
  else
    result = 1;
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10075E78: using guessed type __int16 word_10075E78;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (1000D480) --------------------------------------------------------
char __userpurge S1_CloseLong<al>(int a1<ebx>, unsigned int a2, __int64 a3, __int64 a4, unsigned int a5)
{
  int v5; // esi@3
  int v6; // eax@5
  char v8; // [sp+4h] [bp-Ch]@1
  char v9; // [sp+8h] [bp-8h]@1
  unsigned int v10; // [sp+Ch] [bp-4h]@1

  v10 = (unsigned int)&v8 ^ __security_cookie;
  sub_1002B6B7((int)&v9, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    sub_1002B6E5(&v9);
LABEL_7:
    LOBYTE(v6) = 0;
    return v6;
  }
  v5 = *(_DWORD *)(dword_10077838 + 4 * a2);
  sub_1002B6E5(&v9);
  if ( !v5 || *(_WORD *)(v5 + 56) != word_10075E78 )
    goto LABEL_7;
  __asm
  {
    movsd   xmm2, [ebp+arg_C]
    movsd   xmm1, [ebp+arg_4]
  }
  return sub_1000BEA0(v5, 10000000i64 * a5);
}
// 10074200: using guessed type int __security_cookie;
// 10075E78: using guessed type __int16 word_10075E78;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (1000D530) --------------------------------------------------------
char __userpurge S1_CloseShort<al>(int a1<ebx>, unsigned int a2, __int64 a3, __int64 a4, unsigned int a5)
{
  int v5; // esi@3
  int v6; // eax@5
  char v8; // [sp+4h] [bp-Ch]@1
  char v9; // [sp+8h] [bp-8h]@1
  unsigned int v10; // [sp+Ch] [bp-4h]@1

  v10 = (unsigned int)&v8 ^ __security_cookie;
  sub_1002B6B7((int)&v9, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    sub_1002B6E5(&v9);
LABEL_7:
    LOBYTE(v6) = 0;
    return v6;
  }
  v5 = *(_DWORD *)(dword_10077838 + 4 * a2);
  sub_1002B6E5(&v9);
  if ( !v5 || *(_WORD *)(v5 + 56) != word_10075E78 )
    goto LABEL_7;
  __asm
  {
    movsd   xmm2, [ebp+arg_C]
    movsd   xmm1, [ebp+arg_4]
  }
  return sub_1000C000(v5, 10000000i64 * a5);
}
// 10074200: using guessed type int __security_cookie;
// 10075E78: using guessed type __int16 word_10075E78;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (1000D5E0) --------------------------------------------------------
char __userpurge S1_CloseDa<al>(int a1<ebx>, unsigned int a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v6; // esi@3
  int v7; // eax@5
  int v8; // ecx@5
  __int64 v9; // ST08_8@5
  char v12; // [sp+Ch] [bp-3Ch]@1
  char v13; // [sp+40h] [bp-8h]@1
  unsigned int v14; // [sp+44h] [bp-4h]@1

  v14 = (unsigned int)&v12 ^ __security_cookie;
  sub_1002B6B7((int)&v13, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
  {
    sub_1002B6E5(&v13);
LABEL_7:
    LOBYTE(v7) = 0;
    return v7;
  }
  v6 = *(_DWORD *)(dword_10077838 + 4 * a2);
  sub_1002B6E5(&v13);
  if ( !v6 || *(_WORD *)(v6 + 56) != word_10075E78 )
    goto LABEL_7;
  __asm
  {
    movsd   xmm0, [ebp+arg_18]
    movsd   xmm3, [ebp+arg_10]
    movsd   xmm2, [ebp+arg_8]
  }
  v8 = v6;
  __asm { movsd   [esp+48h+var_48], xmm0 }
  return sub_1000C160(v8, 10000000i64 * a3, v9);
}
// 10074200: using guessed type int __security_cookie;
// 10075E78: using guessed type __int16 word_10075E78;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (1000D6A0) --------------------------------------------------------
bool __stdcall CheckVersion(const char *a1)
{
  int v1; // eax@1
  int v2; // edx@1
  int v3; // ecx@1
  unsigned int v4; // edi@3
  unsigned int v5; // eax@5
  int v6; // esi@5
  signed int v7; // eax@7
  bool v8; // ebx@11
  void *v10; // [sp+10h] [bp-18h]@1
  unsigned int v11; // [sp+24h] [bp-4h]@11

  v1 = sub_1000CAB0((int)&v10, a1);
  v3 = v1;
  v2 = (int)&dword_10076130;
  if ( (unsigned int)dword_10076144 >= 0x10 )
    v2 = dword_10076130;
  v4 = *(_DWORD *)(v1 + 16);
  if ( *(_DWORD *)(v1 + 20) >= 0x10u )
    v3 = *(_DWORD *)v1;
  v6 = dword_10076140;
  v5 = dword_10076140;
  if ( v4 < dword_10076140 )
    v5 = v4;
  v7 = sub_100099E0(v3, v2, v5);
  if ( !v7 )
  {
    if ( v4 >= v6 )
      v7 = v4 != v6;
    else
      v7 = -1;
  }
  v8 = v7 == 0;
  if ( v11 >= 0x10 )
    sub_1002A4AA(v10);
  return v8;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10076130: using guessed type int dword_10076130;
// 10076140: using guessed type int dword_10076140;
// 10076144: using guessed type int dword_10076144;

//----- (1000D730) --------------------------------------------------------
void __stdcall Initialize(const char *a1, const char *a2, int a3, int a4, const char *a5)
{
  char v5; // [sp-48h] [bp-50h]@1
  int v6; // [sp-44h] [bp-4Ch]@1
  int v7; // [sp-40h] [bp-48h]@1
  int v8; // [sp-3Ch] [bp-44h]@1
  unsigned int v9; // [sp-38h] [bp-40h]@1
  signed int v10; // [sp-34h] [bp-3Ch]@1
  char v11; // [sp-30h] [bp-38h]@1
  int v12; // [sp-2Ch] [bp-34h]@1
  int v13; // [sp-28h] [bp-30h]@1
  int v14; // [sp-24h] [bp-2Ch]@1
  int v15; // [sp-20h] [bp-28h]@1
  signed int v16; // [sp-1Ch] [bp-24h]@1
  char v17; // [sp-18h] [bp-20h]@1
  int v18; // [sp-14h] [bp-1Ch]@1
  int v19; // [sp-10h] [bp-18h]@1
  int v20; // [sp-Ch] [bp-14h]@1
  unsigned int v21; // [sp-8h] [bp-10h]@1
  unsigned int v22; // [sp-4h] [bp-Ch]@1

  sub_1000CAB0((int)&v17, a5);
  sub_1000CAB0((int)&v11, a2);
  sub_1000CAB0((int)&v5, a1);
  sub_10021A90(
    a3,
    a4,
    *(void **)&v5,
    v6,
    v7,
    v8,
    v9,
    v10,
    *(void **)&v11,
    v12,
    v13,
    v14,
    v15,
    v16,
    *(void **)&v17,
    v18,
    v19,
    v20,
    v21,
    v22);
}

//----- (1000D7F0) --------------------------------------------------------
int __cdecl Status()
{
  return dword_100777C8;
}
// 100777C8: using guessed type int dword_100777C8;

//----- (1000D800) --------------------------------------------------------
int __cdecl ErrorCode()
{
  return dword_100777CC;
}
// 100777CC: using guessed type int dword_100777CC;

//----- (1000D810) --------------------------------------------------------
int __cdecl Utc()
{
  __int64 v0; // qax@4
  __int64 v1; // qax@4

  if ( HIDWORD(qword_100777D8) >= -2147483648 && (HIDWORD(qword_100777D8) > -2147483648 || (_DWORD)qword_100777D8) )
  {
    LODWORD(v1) = sub_10029F21();
    v0 = v1 - qword_100777D8;
  }
  else
  {
    LODWORD(v0) = sub_10029F21();
  }
  return sub_1003AC50(v0 + 5000000, 0x989680u, 0);
}
// 100777D8: using guessed type __int64 qword_100777D8;

//----- (1000D860) --------------------------------------------------------
int __userpurge Msg<eax>(int a1<ebx>, int a2, unsigned int a3, int a4)
{
  int v4; // eax@4
  int *v5; // edx@6

  if ( a2 == 1 )
  {
    v5 = &dword_100777E0;
  }
  else
  {
    if ( a2 == 2 )
    {
      v5 = &dword_1007780C;
    }
    else
    {
      if ( a2 != 3
        || (v4 = sub_10021E10(a1, a3), !v4)
        || !(*(_BYTE *)(v4 + 56) & 1)
        || (v5 = (int *)(v4 + 248), v4 == -248) )
        return 0;
    }
  }
  *(_DWORD *)a4 = v5[10];
  return (v5[8] - v5[7]) / 12;
}
// 100777E0: using guessed type int dword_100777E0;
// 1007780C: using guessed type int dword_1007780C;

//----- (1000D8C0) --------------------------------------------------------
signed int __userpurge GetMsg<eax>(int a1<ebx>, int a2, unsigned int a3, int a4, int a5, int a6)
{
  int v6; // eax@4
  int v7; // esi@6
  int *v9; // eax@11
  int v10; // ebx@13
  int v11; // eax@14
  int v12; // ecx@14
  int v13; // edi@14
  int v14; // eax@16
  int v15; // esi@16
  char v16; // cf@18
  int v17; // [sp+Ch] [bp-2Ch]@1
  int v18; // [sp+10h] [bp-28h]@6
  int v19; // [sp+14h] [bp-24h]@13
  int v20; // [sp+18h] [bp-20h]@1
  void *v21; // [sp+1Ch] [bp-1Ch]@16
  unsigned int v22; // [sp+30h] [bp-8h]@16
  unsigned int v23; // [sp+34h] [bp-4h]@1

  v23 = (unsigned int)&v17 ^ __security_cookie;
  v20 = a5;
  if ( a2 == 1 )
  {
    v7 = (int)&dword_100777E0;
    goto LABEL_10;
  }
  if ( a2 == 2 )
  {
    v7 = (int)&dword_1007780C;
LABEL_10:
    v18 = v7;
    goto LABEL_11;
  }
  if ( a2 != 3
    || (v6 = sub_10021E10(a1, a3), !v6)
    || !(*(_BYTE *)(v6 + 56) & 1)
    || (v7 = v6 + 248, v18 = v6 + 248, v6 == -248) )
    return 0;
LABEL_11:
  sub_10021D60(a1, 0);
  v9 = &v17;
  if ( (*(_DWORD *)(v7 + 32) - *(_DWORD *)(v7 + 28)) / 12 >= a6 )
    v9 = &a6;
  v17 = (*(_DWORD *)(v7 + 32) - *(_DWORD *)(v7 + 28)) / 12;
  v10 = 0;
  v19 = *v9;
  if ( v19 > 0 )
  {
    v12 = v19;
    v11 = 0;
    v17 = 0;
    v13 = a4 + 4;
    do
    {
      if ( *(_DWORD *)v13 )
      {
        v15 = v11 + *(_DWORD *)(v7 + 28);
        sub_10018500(v15, (int)&v21);
        v14 = (int)&v21;
        if ( v22 >= 0x10 )
          v14 = (int)v21;
        sub_100305B1(v10, v13, *(_DWORD *)v13, 60, v14, -1);
        v16 = v22 < 0x10;
        *(_DWORD *)(v20 + 4 * v10) = *(_DWORD *)(v15 + 8);
        if ( !v16 )
          sub_1002A4AA(v21);
        v12 = v19;
        v7 = v18;
        v11 = v17;
      }
      ++v10;
      v11 += 12;
      v13 += 8;
      v17 = v11;
    }
    while ( v10 < v12 );
  }
  return 1;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;
// 100777E0: using guessed type int dword_100777E0;
// 1007780C: using guessed type int dword_1007780C;

//----- (1000DA10) --------------------------------------------------------
int __fastcall StartExpert(int a1, int a2, int a3, int a4, const char *a5, __int64 a6, unsigned int a7)
{
  int v7; // eax@5
  int v8; // ecx@5
  int v9; // ecx@6
  int v10; // ecx@7
  char v12; // [sp-20h] [bp-38h]@5
  int v13; // [sp-1Ch] [bp-34h]@5
  int v14; // [sp-18h] [bp-30h]@5
  int v15; // [sp-14h] [bp-2Ch]@5
  int v16; // [sp-10h] [bp-28h]@5
  unsigned int v17; // [sp-Ch] [bp-24h]@5
  int v18; // [sp-8h] [bp-20h]@5
  int v19; // [sp-4h] [bp-1Ch]@5
  double v20; // [sp+10h] [bp-8h]@5

  if ( !a5 )
    return -1;
  if ( a3 == 1 )
  {
    __asm
    {
      movsd   xmm0, [ebp+arg_C]
      mulsd   xmm0, ds:qword_10069530
      movsd   [esp+18h+var_8], xmm0
    }
    v19 = a2;
    v18 = sub_1004D276(v20);
    sub_1000AFB0((int)&v12, a5);
    LOBYTE(v10) = a4 != 0;
    v7 = sub_1000BAD0(v10, ~(unsigned __int8)(a7 >> 4) & 1, *(void **)&v12, v13, v14, v15, v16, v17, v18, v19);
  }
  else
  {
    if ( a3 == 2 )
    {
      __asm
      {
        movsd   xmm0, [ebp+arg_C]
        mulsd   xmm0, ds:qword_10069530
        movsd   [esp+18h+var_8], xmm0
      }
      v19 = a2;
      v18 = sub_1004D276(v20);
      sub_1000AFB0((int)&v12, a5);
      LOBYTE(v9) = a4 != 0;
      v7 = sub_10020C70(v9, ~(unsigned __int8)(a7 >> 4) & 1, *(void **)&v12, v13, v14, v15, v16, v17, v18, v19);
    }
    else
    {
      if ( a3 != 3 )
        return -1;
      __asm
      {
        movsd   xmm0, [ebp+arg_C]
        mulsd   xmm0, ds:qword_10069530
        movsd   [esp+18h+var_8], xmm0
      }
      v19 = a2;
      v18 = sub_1004D276(v20);
      sub_1000AFB0((int)&v12, a5);
      LOBYTE(v8) = a4 != 0;
      v7 = sub_10021170(
             v8,
             ~(unsigned __int8)(a7 >> 4) & 1,
             (a7 >> 20) & 1,
             *(void **)&v12,
             v13,
             v14,
             v15,
             v16,
             v17,
             v18,
             v19);
    }
  }
  if ( v7 )
    return sub_10021EA0(v7);
  return -1;
}

//----- (1000DB30) --------------------------------------------------------
char __stdcall StopExpert(unsigned int a1)
{
  int ebp0; // ebp@0
  int v2; // esi@3
  char v4; // [sp+0h] [bp-20h]@5
  unsigned int v5; // [sp+1Ch] [bp-4h]@1
  int v6; // [sp+20h] [bp+0h]@1

  v5 = (unsigned int)&v6 ^ __security_cookie;
  sub_1002B672(ebp0, (int)&unk_10077974);
  if ( (signed int)a1 >= 0 )
  {
    if ( a1 < (dword_1007783C - dword_10077838) >> 2 )
    {
      v2 = dword_10077838 + 4 * a1;
      if ( *(_DWORD *)v2 )
      {
        (***(void (__stdcall ****)(_DWORD))v2)(1);
        *(_DWORD *)v2 = 0;
      }
    }
  }
  return sub_1002B6E5(&v4);
}
// 10074200: using guessed type int __security_cookie;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (1000DBA0) --------------------------------------------------------
int __fastcall sub_1000DBA0(int a1, unsigned int a2)
{
  unsigned int v2; // ebx@1
  int v3; // esi@1
  unsigned int v4; // ecx@2
  char v5; // cf@3
  int v6; // eax@8
  unsigned int v7; // ecx@11
  char v8; // cf@12
  int v9; // ecx@17
  unsigned int v10; // ecx@23
  char v11; // cf@24
  int v12; // ecx@29
  int v13; // ecx@32
  int v14; // ecx@39
  int v15; // ecx@42
  int v16; // ecx@45

  v2 = a2;
  v3 = a1;
  *(_DWORD *)(a1 + 20) = 15;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)a1 = 0;
  if ( a2 <= 0x7F )
  {
    v4 = *(_DWORD *)(a1 + 16);
    if ( v4 < 1 )
    {
      loc_10012FA0(v3, 1 - v4, 0);
    }
    else
    {
      v5 = *(_DWORD *)(v3 + 20) < 0x10u;
      *(_DWORD *)(v3 + 16) = 1;
      if ( v5 )
        *(_BYTE *)(v3 + 1) = 0;
      else
        *(_BYTE *)(*(_DWORD *)v3 + 1) = 0;
    }
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v6 = v3;
    else
      v6 = *(_DWORD *)v3;
LABEL_51:
    *(_BYTE *)v6 = v2;
    return v3;
  }
  if ( a2 <= 0x7FF )
  {
    v7 = *(_DWORD *)(a1 + 16);
    if ( v7 < 2 )
    {
      loc_10012FA0(v3, 2 - v7, 0);
    }
    else
    {
      v8 = *(_DWORD *)(v3 + 20) < 0x10u;
      *(_DWORD *)(v3 + 16) = 2;
      if ( v8 )
        *(_BYTE *)(v3 + 2) = 0;
      else
        *(_BYTE *)(*(_DWORD *)v3 + 2) = 0;
    }
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v9 = v3;
    else
      v9 = *(_DWORD *)v3;
    *(_BYTE *)(v9 + 1) = v2 & 0x3F | 0x80;
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
    {
      v6 = v3;
      LOBYTE(v2) = (v2 >> 6) & 0x1F | 0xC0;
    }
    else
    {
      v6 = *(_DWORD *)v3;
      LOBYTE(v2) = (v2 >> 6) & 0x1F | 0xC0;
    }
    goto LABEL_51;
  }
  if ( a2 <= 0xFFFF )
  {
    v10 = *(_DWORD *)(a1 + 16);
    if ( v10 < 3 )
    {
      loc_10012FA0(v3, 3 - v10, 0);
    }
    else
    {
      v11 = *(_DWORD *)(v3 + 20) < 0x10u;
      *(_DWORD *)(v3 + 16) = 3;
      if ( v11 )
        *(_BYTE *)(v3 + 3) = 0;
      else
        *(_BYTE *)(*(_DWORD *)v3 + 3) = 0;
    }
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v12 = v3;
    else
      v12 = *(_DWORD *)v3;
    *(_BYTE *)(v12 + 2) = v2 & 0x3F | 0x80;
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v13 = v3;
    else
      v13 = *(_DWORD *)v3;
    *(_BYTE *)(v13 + 1) = (v2 >> 6) & 0x3F | 0x80;
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
    {
      v6 = v3;
      LOBYTE(v2) = (v2 >> 12) & 0xF | 0xE0;
    }
    else
    {
      v6 = *(_DWORD *)v3;
      LOBYTE(v2) = (v2 >> 12) & 0xF | 0xE0;
    }
    goto LABEL_51;
  }
  if ( a2 <= 0x10FFFF )
  {
    sub_10012020(a1, 4);
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v14 = v3;
    else
      v14 = *(_DWORD *)v3;
    *(_BYTE *)(v14 + 3) = v2 & 0x3F | 0x80;
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v15 = v3;
    else
      v15 = *(_DWORD *)v3;
    *(_BYTE *)(v15 + 2) = (v2 >> 6) & 0x3F | 0x80;
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v16 = v3;
    else
      v16 = *(_DWORD *)v3;
    *(_BYTE *)(v16 + 1) = (v2 >> 12) & 0x3F | 0x80;
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v6 = v3;
    else
      v6 = *(_DWORD *)v3;
    LOBYTE(v2) = (v2 >> 18) & 7 | 0xF0;
    goto LABEL_51;
  }
  return v3;
}

//----- (1000DDD0) --------------------------------------------------------
char __fastcall sub_1000DDD0(unsigned int a1, unsigned int a2)
{
  char result; // al@5

  if ( a1 >= a2 )
  {
LABEL_5:
    result = 0;
  }
  else
  {
    while ( *(_BYTE *)a1 != 10 && *(_BYTE *)a1 != 13 )
    {
      ++a1;
      if ( a1 >= a2 )
        goto LABEL_5;
    }
    result = 1;
  }
  return result;
}

//----- (1000DDF0) --------------------------------------------------------
int __usercall sub_1000DDF0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // esi@1
  int v8; // eax@3
  int v9; // edi@3

  v7 = a2;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  v4 = sub_1002ADB1(a1, a2, a3, a4, 8);
  if ( !v4 )
    sub_10029530();
  *(_DWORD *)v7 = v4;
  *(_DWORD *)v4 = 0;
  *(_DWORD *)(v4 + 4) = 0;
  **(_DWORD **)v7 = v7;
  v9 = v7 + 20;
  *(_DWORD *)(v7 + 20) = 0;
  *(_DWORD *)(v7 + 24) = 0;
  *(_DWORD *)(v7 + 28) = 0;
  *(_DWORD *)(v7 + 32) = 0;
  *(_DWORD *)(v7 + 36) = 0;
  v8 = sub_1002ADB1(v5, v6, a3, v7 + 20, 8);
  if ( !v8 )
    sub_10029530();
  *(_DWORD *)v9 = v8;
  *(_DWORD *)v8 = 0;
  *(_DWORD *)(v8 + 4) = 0;
  **(_DWORD **)v9 = v9;
  *(_DWORD *)(v7 + 60) = 15;
  *(_DWORD *)(v7 + 56) = 0;
  *(_BYTE *)(v7 + 40) = 0;
  *(_DWORD *)(v7 + 104) = 15;
  *(_DWORD *)(v7 + 100) = 0;
  *(_BYTE *)(v7 + 84) = 0;
  *(_WORD *)(v7 + 108) = 1;
  return v7;
}

//----- (1000DF00) --------------------------------------------------------
char __thiscall sub_1000DF00(int this, int a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  unsigned int v6; // ST08_4@1
  int v7; // eax@2
  int v8; // edx@7
  char v9; // bl@7
  char v10; // al@11
  char result; // al@16
  void *v12; // [sp+Ch] [bp-40h]@14
  unsigned int v13; // [sp+20h] [bp-2Ch]@14
  int v14; // [sp+24h] [bp-28h]@7
  int v15; // [sp+28h] [bp-24h]@14
  int v16; // [sp+2Ch] [bp-20h]@14
  int v17; // [sp+30h] [bp-1Ch]@1
  int v18; // [sp+34h] [bp-18h]@1
  int v19; // [sp+38h] [bp-14h]@1
  unsigned int v20; // [sp+3Ch] [bp-10h]@1
  int v21; // [sp+48h] [bp-4h]@14
  int v22; // [sp+4Ch] [bp+0h]@1

  v20 = (unsigned int)&v22 ^ __security_cookie;
  v6 = (unsigned int)&v22 ^ __security_cookie;
  v5 = this;
  v18 = a3;
  *(_DWORD *)(this + 68) = a3;
  v17 = a2;
  v19 = a4;
  *(_DWORD *)(this + 64) = a2;
  *(_BYTE *)(this + 110) = 0;
  *(_DWORD *)(this + 72) = a2;
  *(_DWORD *)(this + 76) = 0;
  *(_DWORD *)(this + 80) = 0;
  loc_1000AEB0(this + 84, &unk_1006823C, 0, v6);
  sub_10002D80(v5 + 20);
  if ( *(_DWORD *)(v5 + 16) )
  {
    v7 = *(_DWORD *)(v5 + 16);
    while ( v7 )
    {
      --v7;
      if ( !v7 )
        *(_DWORD *)(v5 + 12) = 0;
    }
    *(_DWORD *)(v5 + 16) = v7;
  }
  loc_100134C0(v5, &v19);
  v9 = sub_1000E050(v5);
  sub_1000E2C0(v5, (int)&v14);
  if ( *(_BYTE *)(v5 + 110) )
  {
    if ( *(_DWORD *)(v5 + 100) )
      sub_10011140(v8, a4, a4, v5 + 84, 2);
  }
  if ( *(_BYTE *)(v5 + 109) && (v10 = *(_BYTE *)(a4 + 8)) != 0 && v10 != 6 && v10 != 7 )
  {
    v15 = v17;
    v14 = 13;
    v16 = v18;
    sub_1000AFB0((int)&v12, "A valid JSON document must be either an array or an object value.");
    v21 = 0;
    sub_1000FD10((void *)v5, (int *)&v12, (int)&v14, 0);
    if ( v13 >= 0x10 )
      sub_1002A4AA(v12);
    result = 0;
  }
  else
  {
    result = v9;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (1000E050) --------------------------------------------------------
char __thiscall sub_1000E050(int this)
{
  int v1; // edx@1
  int v2; // ecx@1
  char v3; // bl@1
  int v4; // edi@1
  int v5; // eax@3
  int v6; // esi@3
  int v7; // ST08_4@3
  int v8; // eax@3
  int v9; // edx@3
  int v10; // ecx@7
  int v11; // eax@14
  int v12; // edx@14
  int v13; // eax@16
  int v14; // esi@16
  int v15; // ST08_4@16
  int v16; // eax@16
  int v17; // edx@16
  char result; // al@18
  int v19; // [sp+10h] [bp-5Ch]@1
  LPVOID v20[4]; // [sp+1Ch] [bp-50h]@3
  int v21; // [sp+2Ch] [bp-40h]@19
  unsigned int v22; // [sp+30h] [bp-3Ch]@19
  int v23; // [sp+34h] [bp-38h]@3
  int v24; // [sp+3Ch] [bp-30h]@11
  int v25; // [sp+40h] [bp-2Ch]@11
  char v26; // [sp+44h] [bp-28h]@16
  char v27; // [sp+50h] [bp-1Ch]@16
  int v28; // [sp+68h] [bp-4h]@11

  v4 = this;
  sub_1000E2C0(this, (int)&v19);
  v3 = 1;
  if ( *(_BYTE *)(v4 + 110) )
  {
    if ( *(_DWORD *)(v4 + 100) )
    {
      v7 = v2;
      v8 = sub_10013580(v4, (int)&v23);
      v5 = sub_10015510(v8, v9, (int)v20, v7);
      v6 = *(_DWORD *)v5;
      if ( *(_DWORD *)v5 )
        v6 = *(_DWORD *)v6;
      sub_10011140(
        *(_DWORD *)(v5 + 8) & 3,
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 4 * ((*(_DWORD *)(v5 + 8) >> 2) & (*(_DWORD *)(v6 + 8) - 1)))
                  + 4 * (*(_DWORD *)(v5 + 8) & 3)),
        v4,
        v4 + 84,
        0);
      loc_1000AEB0(v4 + 84, &unk_1006823C, 0);
    }
  }
  switch ( v19 )
  {
    case 1:
      v3 = sub_1000EA70(v1, v4, 1, v4, v2);
      goto LABEL_15;
    case 3:
      v3 = sub_1000EDD0(v1, v4, 1, v4, v2);
      goto LABEL_15;
    case 6:
      v3 = sub_1000F050((void *)v4, (int)&v19);
      goto LABEL_15;
    case 5:
      v3 = sub_1000F5C0(v4, 1, (int)&v19);
      goto LABEL_15;
    case 7:
      v24 = v24 & 0xFFFFFF05 | 5;
      v25 = 0;
      LOBYTE(v23) = 1;
      v28 = 0;
      goto LABEL_14;
    case 8:
      v24 = v24 & 0xFFFFFF05 | 5;
      v25 = 0;
      LOBYTE(v23) = 0;
      v28 = 1;
      goto LABEL_14;
    case 9:
      v24 &= 0xFFFFFE00u;
      v25 = 0;
      v28 = 3;
LABEL_14:
      v11 = sub_1000FE80(v4);
      sub_10010260(v11, v12, (int)&v23);
      v28 = -1;
      sub_100101D0((int)&v23, 1);
LABEL_15:
      if ( !*(_BYTE *)(v4 + 110) )
        goto LABEL_21;
      *(_DWORD *)(v4 + 76) = *(_DWORD *)(v4 + 72);
      v15 = v10;
      v16 = sub_10013580(v4, (int)&v27);
      v13 = sub_10015510(v16, v17, (int)&v26, v15);
      v14 = *(_DWORD *)v13;
      if ( *(_DWORD *)v13 )
        v14 = *(_DWORD *)v14;
      *(_DWORD *)(v4 + 80) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v14 + 4)
                                                   + 4 * ((*(_DWORD *)(v14 + 8) - 1) & (*(_DWORD *)(v13 + 8) >> 2)))
                                       + 4 * (*(_DWORD *)(v13 + 8) & 3));
      result = v3;
      break;
    default:
      v22 = 15;
      v21 = 0;
      LOBYTE(v20[0]) = 0;
      loc_1000AEB0(v20, "Syntax error: value, object or array expected.", 46);
      v28 = 4;
      v3 = sub_1000FD10((void *)v4, (int *)v20, (int)&v19, 0);
      if ( v22 >= 0x10 )
        sub_1002A4AA(v20[0]);
LABEL_21:
      result = v3;
      break;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1000E2C0) --------------------------------------------------------
char __thiscall sub_1000E2C0(int this, int a2)
{
  int v2; // esi@1
  int v3; // edx@2
  char v4; // al@3
  int v5; // ecx@3
  int v6; // eax@8
  char v7; // cl@9
  char v8; // al@16
  char v9; // zf@20
  int v10; // eax@20
  int v11; // edx@23
  signed int v12; // ecx@24
  char v13; // al@25
  int v14; // edx@28
  signed int v15; // ecx@29
  char v16; // al@30
  int v17; // edx@33
  signed int v18; // ecx@34
  char v19; // al@35

  v2 = this;
  if ( *(_BYTE *)(this + 108) )
  {
    do
    {
      v3 = *(_DWORD *)(v2 + 68);
      if ( *(_DWORD *)(v2 + 72) != v3 )
      {
        do
        {
          v5 = *(_DWORD *)(v2 + 72);
          v4 = *(_BYTE *)v5;
          if ( *(_BYTE *)v5 != 32 && v4 != 9 && v4 != 13 && v4 != 10 )
            break;
          *(_DWORD *)(v2 + 72) = v5 + 1;
        }
        while ( v5 + 1 != v3 );
      }
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(v2 + 72);
      v6 = *(_DWORD *)(v2 + 72);
      if ( v6 == *(_DWORD *)(v2 + 68) )
      {
        v7 = 0;
      }
      else
      {
        v7 = *(_BYTE *)v6;
        *(_DWORD *)(v2 + 72) = v6 + 1;
      }
      switch ( v7 )
      {
        case 123:
          *(_DWORD *)a2 = 1;
          goto LABEL_20;
        case 125:
          *(_DWORD *)a2 = 2;
          goto LABEL_20;
        case 91:
          *(_DWORD *)a2 = 3;
          goto LABEL_20;
        case 93:
          *(_DWORD *)a2 = 4;
          goto LABEL_20;
        case 34:
          *(_DWORD *)a2 = 5;
          v8 = sub_1000EA30(v2);
          goto LABEL_18;
        case 47:
          *(_DWORD *)a2 = 12;
          v8 = sub_1000E800(v2);
LABEL_18:
          if ( !v8 )
            goto LABEL_19;
          goto LABEL_20;
        default:
          goto LABEL_19;
        case 45:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          *(_DWORD *)a2 = 6;
          sub_1000E9F0(v2);
          goto LABEL_20;
        case 116:
          *(_DWORD *)a2 = 7;
          v11 = *(_DWORD *)(v2 + 72);
          if ( *(_DWORD *)(v2 + 68) - v11 < 3 )
            goto LABEL_19;
          v12 = 3;
          while ( 1 )
          {
            v13 = *(_BYTE *)(v11 + v12-- - 1);
            if ( v13 != byte_1006845C[v12] )
              goto LABEL_19;
            if ( !v12 )
            {
              *(_DWORD *)(v2 + 72) = v11 + 3;
              goto LABEL_20;
            }
          }
        case 102:
          *(_DWORD *)a2 = 8;
          v14 = *(_DWORD *)(v2 + 72);
          if ( *(_DWORD *)(v2 + 68) - v14 < 4 )
            goto LABEL_19;
          v15 = 4;
          while ( 1 )
          {
            v16 = *(_BYTE *)(v14 + v15-- - 1);
            if ( v16 != byte_10068460[v15] )
              goto LABEL_19;
            if ( !v15 )
            {
              *(_DWORD *)(v2 + 72) = v14 + 4;
              goto LABEL_20;
            }
          }
        case 110:
          *(_DWORD *)a2 = 9;
          v17 = *(_DWORD *)(v2 + 72);
          if ( *(_DWORD *)(v2 + 68) - v17 < 3 )
            goto LABEL_19;
          v18 = 3;
          break;
        case 44:
          *(_DWORD *)a2 = 10;
          goto LABEL_20;
        case 58:
          *(_DWORD *)a2 = 11;
          goto LABEL_20;
        case 0:
          *(_DWORD *)a2 = 0;
          goto LABEL_20;
      }
      do
      {
        v19 = *(_BYTE *)(v17 + v18-- - 1);
        if ( v19 != byte_10068468[v18] )
        {
LABEL_19:
          *(_DWORD *)a2 = 13;
          goto LABEL_20;
        }
      }
      while ( v18 );
      *(_DWORD *)(v2 + 72) = v17 + 3;
LABEL_20:
      v9 = *(_DWORD *)a2 == 12;
      v10 = *(_DWORD *)(v2 + 72);
      *(_DWORD *)(a2 + 8) = v10;
    }
    while ( v9 );
  }
  else
  {
    LOBYTE(v10) = sub_1000E530(this, a2);
  }
  return v10;
}

//----- (1000E530) --------------------------------------------------------
char __thiscall sub_1000E530(int this, int a2)
{
  int v2; // edx@1
  int v3; // esi@1
  char v4; // al@2
  int v5; // ecx@2
  int v6; // eax@7
  char v7; // cl@8
  char v9; // al@15
  int v10; // edx@21
  signed int v11; // ecx@22
  char v12; // al@23
  int v13; // edx@26
  signed int v14; // ecx@27
  char v15; // al@28
  int v16; // edx@31
  signed int v17; // ecx@32
  char v18; // al@33

  v3 = this;
  v2 = *(_DWORD *)(this + 68);
  if ( *(_DWORD *)(this + 72) != v2 )
  {
    do
    {
      v5 = *(_DWORD *)(v3 + 72);
      v4 = *(_BYTE *)v5;
      if ( *(_BYTE *)v5 != 32 && v4 != 9 && v4 != 13 && v4 != 10 )
        break;
      *(_DWORD *)(v3 + 72) = v5 + 1;
    }
    while ( v5 + 1 != v2 );
  }
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(v3 + 72);
  v6 = *(_DWORD *)(v3 + 72);
  if ( v6 == *(_DWORD *)(v3 + 68) )
  {
    v7 = 0;
  }
  else
  {
    v7 = *(_BYTE *)v6;
    *(_DWORD *)(v3 + 72) = v6 + 1;
  }
  switch ( v7 )
  {
    case 123:
      *(_DWORD *)a2 = 1;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 125:
      *(_DWORD *)a2 = 2;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 91:
      *(_DWORD *)a2 = 3;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 93:
      *(_DWORD *)a2 = 4;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 34:
      *(_DWORD *)a2 = 5;
      v9 = sub_1000EA30(v3);
      goto LABEL_17;
    case 47:
      *(_DWORD *)a2 = 12;
      v9 = sub_1000E800(v3);
LABEL_17:
      if ( !v9 )
        goto LABEL_18;
      goto LABEL_19;
    default:
      goto LABEL_18;
    case 45:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      *(_DWORD *)a2 = 6;
      sub_1000E9F0(v3);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 116:
      *(_DWORD *)a2 = 7;
      v10 = *(_DWORD *)(v3 + 72);
      if ( *(_DWORD *)(v3 + 68) - v10 < 3 )
        goto LABEL_18;
      v11 = 3;
      while ( 1 )
      {
        v12 = *(_BYTE *)(v10 + v11-- - 1);
        if ( v12 != byte_1006845C[v11] )
          break;
        if ( !v11 )
        {
          *(_DWORD *)(v3 + 72) = v10 + 3;
          *(_DWORD *)(a2 + 8) = v10 + 3;
          return 1;
        }
      }
      goto LABEL_18;
    case 102:
      *(_DWORD *)a2 = 8;
      v13 = *(_DWORD *)(v3 + 72);
      if ( *(_DWORD *)(v3 + 68) - v13 < 4 )
        goto LABEL_18;
      v14 = 4;
      while ( 1 )
      {
        v15 = *(_BYTE *)(v13 + v14-- - 1);
        if ( v15 != byte_10068460[v14] )
          break;
        if ( !v14 )
        {
          *(_DWORD *)(v3 + 72) = v13 + 4;
          *(_DWORD *)(a2 + 8) = v13 + 4;
          return 1;
        }
      }
      goto LABEL_18;
    case 110:
      *(_DWORD *)a2 = 9;
      v16 = *(_DWORD *)(v3 + 72);
      if ( *(_DWORD *)(v3 + 68) - v16 < 3 )
        goto LABEL_18;
      v17 = 3;
      break;
    case 44:
      *(_DWORD *)a2 = 10;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 58:
      *(_DWORD *)a2 = 11;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 0:
      *(_DWORD *)a2 = 0;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
  }
  while ( 1 )
  {
    v18 = *(_BYTE *)(v16 + v17-- - 1);
    if ( v18 != byte_10068468[v17] )
      break;
    if ( !v17 )
    {
      *(_DWORD *)(v3 + 72) = v16 + 3;
      *(_DWORD *)(a2 + 8) = v16 + 3;
      return 1;
    }
  }
LABEL_18:
  *(_DWORD *)a2 = 13;
LABEL_19:
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
  return 1;
}

//----- (1000E800) --------------------------------------------------------
char __thiscall sub_1000E800(int this)
{
  int v1; // eax@1
  int v2; // edx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // eax@2
  char v6; // ch@2
  char v8; // cl@7
  unsigned int v9; // eax@13
  int v10; // ebx@13
  char v11; // [sp+Fh] [bp-1h]@2

  v4 = this;
  v1 = *(_DWORD *)(this + 72);
  v2 = *(_DWORD *)(this + 68);
  v3 = v1 - 1;
  if ( v1 == v2 )
    return 0;
  v6 = *(_BYTE *)v1;
  v5 = v1 + 1;
  v11 = v6;
  *(_DWORD *)(v4 + 72) = v5;
  if ( v6 == 42 )
  {
    if ( !sub_1000E9A0(v4) )
      return 0;
    v6 = v11;
  }
  else
  {
    if ( v6 != 47 )
      return 0;
    if ( v5 != v2 )
    {
      do
      {
        v8 = *(_BYTE *)v5++;
        *(_DWORD *)(v4 + 72) = v5;
      }
      while ( v8 != 13 && v8 != 10 && v5 != v2 );
    }
  }
  if ( *(_BYTE *)(v4 + 110) )
  {
    v9 = *(_DWORD *)(v4 + 76);
    v10 = 0;
    if ( v9 )
    {
      if ( v9 >= v3 )
      {
LABEL_18:
        if ( v6 != 42 || !sub_1000DDD0(v3, *(_DWORD *)(v4 + 72)) )
          v10 = 1;
      }
      else
      {
        while ( *(_BYTE *)v9 != 10 && *(_BYTE *)v9 != 13 )
        {
          ++v9;
          if ( v9 >= v3 )
            goto LABEL_18;
        }
      }
    }
    sub_1000E8B0(v2, v4, v3, v3, *(_DWORD *)(v4 + 72), v10);
  }
  return 1;
}

//----- (1000E8B0) --------------------------------------------------------
int __userpurge sub_1000E8B0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5, int a6)
{
  int v6; // esi@1
  int result; // eax@4
  int v8; // [sp-4h] [bp-50h]@5
  int v9; // [sp+Ch] [bp-40h]@8
  int v10; // [sp+1Ch] [bp-30h]@8
  unsigned int v11; // [sp+20h] [bp-2Ch]@8
  int v12; // [sp+24h] [bp-28h]@2
  int v13; // [sp+34h] [bp-18h]@2
  unsigned int v14; // [sp+38h] [bp-14h]@2
  int v15; // [sp+48h] [bp-4h]@4

  v6 = a2;
  if ( a6 == 1 )
  {
    v14 = 15;
    v13 = 0;
    LOBYTE(v12) = 0;
    if ( a4 != a5 )
      loc_1000AEB0(&v12, a4, a5 - a4);
    v15 = 0;
    result = sub_10011140(a1, *(_DWORD *)(v6 + 80), a3, (int)&v12, 1);
    if ( v14 >= 0x10 )
    {
      v8 = v12;
      return sub_1002A4AA((LPVOID)v8);
    }
  }
  else
  {
    if ( *(_DWORD *)(a2 + 100) )
      loc_10014700(a2 + 84, &unk_1006846C, 1);
    v11 = 15;
    v10 = 0;
    LOBYTE(v9) = 0;
    if ( a4 != a5 )
      loc_1000AEB0(&v9, a4, a5 - a4);
    v15 = 1;
    result = loc_10014600(v6 + 84, &v9, 0, -1);
    if ( v11 >= 0x10 )
    {
      v8 = v9;
      return sub_1002A4AA((LPVOID)v8);
    }
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1000E9A0) --------------------------------------------------------
bool __thiscall sub_1000E9A0(int this)
{
  int v1; // eax@1
  int v2; // edx@1
  int v3; // esi@1
  char v4; // cl@2
  int v5; // eax@5
  bool result; // eax@6
  char v7; // cl@7

  v3 = this;
  v1 = *(_DWORD *)(this + 72);
  v2 = *(_DWORD *)(this + 68);
  if ( v1 != v2 )
  {
    do
    {
      v4 = *(_BYTE *)v1++;
      *(_DWORD *)(v3 + 72) = v1;
    }
    while ( (v4 != 42 || *(_BYTE *)v1 != 47) && v1 != v2 );
  }
  v5 = *(_DWORD *)(v3 + 72);
  if ( v5 == v2 )
  {
    result = 0;
  }
  else
  {
    v7 = *(_BYTE *)v5;
    *(_DWORD *)(v3 + 72) = v5 + 1;
    result = v7 == 47;
  }
  return result;
}

//----- (1000E9F0) --------------------------------------------------------
void __thiscall sub_1000E9F0(int this)
{
  int v1; // esi@1
  char v2; // al@2
  int v3; // edx@2

  v1 = *(_DWORD *)(this + 68);
  if ( *(_DWORD *)(this + 72) != v1 )
  {
    do
    {
      v3 = *(_DWORD *)(this + 72);
      v2 = *(_BYTE *)v3;
      if ( (*(_BYTE *)v3 < 48 || v2 > 57) && v2 != 46 && v2 != 101 && v2 != 69 && v2 != 43 && v2 != 45 )
        break;
      *(_DWORD *)(this + 72) = v3 + 1;
    }
    while ( v3 + 1 != v1 );
  }
}

//----- (1000EA30) --------------------------------------------------------
bool __thiscall sub_1000EA30(int this)
{
  int v1; // eax@1
  char i; // dl@1
  int v3; // esi@1
  int v4; // eax@2

  v1 = *(_DWORD *)(this + 72);
  v3 = *(_DWORD *)(this + 68);
  for ( i = 0; v1 != v3; v1 = *(_DWORD *)(this + 72) )
  {
    i = *(_BYTE *)v1;
    v4 = v1 + 1;
    *(_DWORD *)(this + 72) = v4;
    if ( i == 92 )
    {
      if ( v4 != v3 )
        *(_DWORD *)(this + 72) = v4 + 1;
    }
    else
    {
      if ( i == 34 )
        return i == 34;
    }
  }
  return i == 34;
}

//----- (1000EA70) --------------------------------------------------------
char __userpurge sub_1000EA70<al>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // eax@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // eax@4
  int v11; // edi@4
  int v12; // ST08_4@4
  int v13; // eax@4
  int v14; // edx@4
  int v15; // eax@7
  char v16; // cl@7
  int v17; // ecx@13
  char v18; // al@13
  int v19; // ecx@14
  int v20; // eax@16
  int v21; // ST08_4@16
  int v22; // eax@16
  int v23; // edx@16
  int v24; // edi@17
  int v25; // eax@19
  int v26; // edx@19
  int v27; // ecx@19
  char v28; // al@21
  int v29; // ecx@21
  int v30; // ecx@22
  int v31; // eax@26
  char i; // cl@29
  char v33; // bl@34
  int *v35; // eax@40
  char v36; // [sp+10h] [bp-78h]@16
  int v37; // [sp+1Ch] [bp-6Ch]@4
  int v38; // [sp+28h] [bp-60h]@4
  int v39; // [sp+34h] [bp-54h]@6
  int v40; // [sp+40h] [bp-48h]@1
  void *v41; // [sp+44h] [bp-44h]@34
  int v42; // [sp+4Ch] [bp-3Ch]@4
  char v43; // [sp+50h] [bp-38h]@16
  int v44; // [sp+54h] [bp-34h]@1
  unsigned int v45; // [sp+58h] [bp-30h]@1
  void *v46; // [sp+5Ch] [bp-2Ch]@1
  int v47; // [sp+6Ch] [bp-1Ch]@1
  unsigned int v48; // [sp+70h] [bp-18h]@1
  unsigned int v49; // [sp+74h] [bp-14h]@1
  int v50; // [sp+84h] [bp-4h]@1
  int v51; // [sp+88h] [bp+0h]@1

  v49 = (unsigned int)&v51 ^ __security_cookie;
  v9 = a2;
  v48 = 15;
  v47 = 0;
  LOBYTE(v46) = 0;
  v50 = 0;
  v44 = v44 & 0xFFFFFE07 | 7;
  v45 = 0;
  v5 = sub_1002ADB1(a1, a2, a3, a4, 8);
  v8 = v5;
  v40 = v5;
  LOBYTE(v50) = 1;
  if ( v5 )
  {
    *(_DWORD *)v5 = 0;
    *(_DWORD *)(v5 + 4) = 0;
    *(_DWORD *)v5 = sub_100155A0(v6, v7, a3, v5);
  }
  else
  {
    v8 = 0;
  }
  v42 = v8;
  v12 = v7;
  LOBYTE(v50) = 2;
  v13 = sub_10013580(v9, (int)&v38);
  v10 = sub_10015510(v13, v14, (int)&v37, v12);
  v11 = *(_DWORD *)v10;
  if ( *(_DWORD *)v10 )
    v11 = *(_DWORD *)v11;
  sub_10010260(
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v11 + 4) + 4 * ((*(_DWORD *)(v10 + 8) >> 2) & (*(_DWORD *)(v11 + 8) - 1)))
              + 4 * (*(_DWORD *)(v10 + 8) & 3)),
    *(_DWORD *)(v10 + 8) & 3,
    (int)&v42);
  LOBYTE(v50) = 0;
  sub_100101D0((int)&v42, a3);
  if ( sub_1000E530(v9, (int)&v39) )
  {
    while ( 1 )
    {
      v15 = v39;
      v16 = 1;
      if ( v39 == 12 )
      {
        while ( v16 )
        {
          v16 = sub_1000E530(v9, (int)&v39);
          v15 = v39;
          if ( v39 != 12 )
          {
            if ( !v16 )
              goto LABEL_34;
            goto LABEL_11;
          }
        }
        goto LABEL_34;
      }
LABEL_11:
      if ( v15 == 2 )
        break;
      if ( v15 != 5 )
        goto LABEL_34;
      loc_1000AEB0(&v46, &unk_1006823C, 0);
      v18 = loc_1000F6D0(v9, &v39, &v46);
      v17 = v9;
      if ( !v18 )
      {
LABEL_44:
        v33 = sub_1000FDD0(v17, 2);
        goto LABEL_37;
      }
      if ( !sub_1000E530(v9, (int)&v37) || v37 != 11 )
      {
        sub_1000AFB0((int)&v41, "Missing ':' after object member name");
        LOBYTE(v50) = 3;
        v35 = &v37;
LABEL_42:
        v33 = sub_1000FE20((void *)v9, (int *)&v41, (int)v35, 2);
        if ( v45 >= 0x10 )
          sub_1002A4AA(v41);
        goto LABEL_37;
      }
      v21 = v19;
      v22 = sub_10013580(v9, (int)&v43);
      v20 = sub_10015510(v22, v23, (int)&v36, v21);
      if ( *(_DWORD *)v20 )
        v24 = **(_DWORD **)v20;
      else
        v24 = 0;
      v26 = *(_DWORD *)(v20 + 8) & 3;
      v27 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v24 + 4) + 4
                                                         * ((*(_DWORD *)(v20 + 8) >> 2) & (*(_DWORD *)(v24 + 8) - 1)))
                      + 4 * v26);
      v25 = (int)&v46;
      if ( v48 >= 0x10 )
        v25 = (int)v46;
      v40 = sub_10010C90(v27, v26, v25, v27);
      loc_100134C0(v9, &v40);
      v28 = sub_1000E050(v9);
      v29 = *(_DWORD *)(v9 + 16);
      if ( v29 )
      {
        v30 = v29 - 1;
        *(_DWORD *)(v9 + 16) = v30;
        if ( !v30 )
          *(_DWORD *)(v9 + 12) = 0;
      }
      v17 = v9;
      if ( !v28 )
        goto LABEL_44;
      if ( !sub_1000E530(v9, (int)&v38) || (v31 = v38, v38 != 2) && v38 != 10 && v38 != 12 )
      {
        sub_1000AFB0((int)&v41, "Missing ',' or '}' in object declaration");
        LOBYTE(v50) = 4;
        v35 = &v38;
        goto LABEL_42;
      }
      for ( i = 1; v38 == 12; v31 = v38 )
      {
        if ( !i )
          break;
        i = sub_1000E530(v9, (int)&v38);
      }
      if ( v31 == 2 )
        goto LABEL_46;
      if ( !sub_1000E530(v9, (int)&v39) )
        goto LABEL_34;
    }
    if ( v47 )
      goto LABEL_34;
LABEL_46:
    v33 = 1;
  }
  else
  {
LABEL_34:
    v45 = 15;
    v44 = 0;
    LOBYTE(v41) = 0;
    loc_1000AEB0(&v41, "Missing '}' or object member name", 33);
    LOBYTE(v50) = 5;
    v33 = sub_1000FE20((void *)v9, (int *)&v41, (int)&v39, 2);
    if ( v45 >= 0x10 )
      sub_1002A4AA(v41);
    v45 = 15;
    v44 = 0;
    LOBYTE(v41) = 0;
  }
LABEL_37:
  if ( v48 >= 0x10 )
    sub_1002A4AA(v46);
  return v33;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (1000EDD0) --------------------------------------------------------
char __userpurge sub_1000EDD0<al>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // eax@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // eax@4
  int v11; // edi@4
  int v12; // ST08_4@4
  int v13; // eax@4
  int v14; // edx@4
  int v15; // edx@6
  int i; // ecx@6
  char v17; // al@7
  char result; // al@13
  int v19; // ebx@14
  int v20; // eax@15
  int v21; // ST08_4@15
  int v22; // eax@15
  int v23; // edx@15
  int v24; // edi@16
  char v25; // al@18
  int v26; // ecx@18
  int v27; // ecx@19
  char v28; // al@22
  char v29; // dl@27
  char v30; // bl@33
  void *v31; // [sp+10h] [bp-54h]@33
  int v32; // [sp+20h] [bp-44h]@33
  unsigned int v33; // [sp+24h] [bp-40h]@33
  int v34; // [sp+28h] [bp-3Ch]@4
  char v35; // [sp+2Ch] [bp-38h]@15
  int v36; // [sp+30h] [bp-34h]@1
  int v37; // [sp+34h] [bp-30h]@1
  char v38; // [sp+38h] [bp-2Ch]@4
  int v39; // [sp+44h] [bp-20h]@4
  int v40; // [sp+50h] [bp-14h]@1
  int v41; // [sp+60h] [bp-4h]@1

  v9 = a2;
  v36 = v36 & 0xFFFFFE06 | 6;
  v37 = 0;
  v5 = sub_1002ADB1(a1, a2, a3, a4, 8);
  v8 = v5;
  v40 = v5;
  v41 = 0;
  if ( v5 )
  {
    *(_DWORD *)v5 = 0;
    *(_DWORD *)(v5 + 4) = 0;
    *(_DWORD *)v5 = sub_100155A0(v6, v7, a3, v5);
  }
  else
  {
    v8 = 0;
  }
  v34 = v8;
  v12 = v7;
  v41 = 1;
  v13 = sub_10013580(v9, (int)&v38);
  v10 = sub_10015510(v13, v14, (int)&v39, v12);
  v11 = *(_DWORD *)v10;
  if ( *(_DWORD *)v10 )
    v11 = *(_DWORD *)v11;
  sub_10010260(
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v11 + 4) + 4 * ((*(_DWORD *)(v10 + 8) >> 2) & (*(_DWORD *)(v11 + 8) - 1)))
              + 4 * (*(_DWORD *)(v10 + 8) & 3)),
    *(_DWORD *)(v10 + 8) & 3,
    (int)&v34);
  v41 = -1;
  sub_100101D0((int)&v34, a3);
  v15 = *(_DWORD *)(v9 + 68);
  if ( *(_DWORD *)(v9 + 72) != v15 )
  {
    do
    {
      i = *(_DWORD *)(v9 + 72);
      v17 = *(_BYTE *)i;
      if ( *(_BYTE *)i != 32 && v17 != 9 && v17 != 13 && v17 != 10 )
        break;
      *(_DWORD *)(v9 + 72) = i + 1;
    }
    while ( i + 1 != v15 );
  }
  if ( **(_BYTE **)(v9 + 72) == 93 )
  {
    sub_1000E530(v9, (int)&v38);
    result = 1;
  }
  else
  {
    v19 = 0;
    while ( 1 )
    {
      v21 = i;
      v22 = sub_10013580(v9, (int)&v35);
      v20 = sub_10015510(v22, v23, (int)&v38, v21);
      if ( *(_DWORD *)v20 )
        v24 = **(_DWORD **)v20;
      else
        v24 = 0;
      v40 = sub_10010A90(
              *(_DWORD *)(v20 + 8) & 3,
              *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v24 + 4)
                                    + 4 * ((*(_DWORD *)(v20 + 8) >> 2) & (*(_DWORD *)(v24 + 8) - 1)))
                        + 4 * (*(_DWORD *)(v20 + 8) & 3)),
              v24,
              v19++);
      loc_100134C0(v9, &v40);
      v25 = sub_1000E050(v9);
      v26 = *(_DWORD *)(v9 + 16);
      if ( v26 )
      {
        v27 = v26 - 1;
        *(_DWORD *)(v9 + 16) = v27;
        if ( !v27 )
          *(_DWORD *)(v9 + 12) = 0;
      }
      if ( !v25 )
        return sub_1000FDD0(v9, 4);
      v28 = sub_1000E530(v9, (int)&v39);
      for ( i = v39; v39 == 12; i = v39 )
      {
        if ( !v28 )
          break;
        v28 = sub_1000E530(v9, (int)&v39);
      }
      v29 = i == 10 || i == 4 ? 0 : 1;
      if ( !v28 || v29 )
        break;
      if ( i == 4 )
        return 1;
    }
    v33 = 15;
    v32 = 0;
    LOBYTE(v31) = 0;
    loc_1000AEB0(&v31, "Missing ',' or ']' in array declaration", 39);
    v41 = 2;
    v30 = sub_1000FE20((void *)v9, (int *)&v31, (int)&v39, 4);
    if ( v33 >= 0x10 )
      sub_1002A4AA(v31);
    result = v30;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1000F050) --------------------------------------------------------
char __thiscall sub_1000F050(void *this, int a2)
{
  char v2; // al@1
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // ebx@1
  void *v6; // esi@1
  char v7; // al@3
  char result; // al@13
  int v9; // esi@14
  signed int v10; // eax@15
  signed int v11; // edi@15
  int v12; // edx@17
  int v13; // ecx@17
  unsigned int v14; // edi@17
  unsigned __int64 v15; // ST00_8@17
  __int64 v16; // qax@17
  char v17; // al@18
  int v18; // eax@20
  __int64 v19; // qt0@25
  unsigned __int8 v20; // cf@25
  int v21; // edx@25
  unsigned __int8 v22; // cf@25
  int v23; // eax@27
  int v24; // esi@27
  int v25; // edx@27
  int v26; // ST0C_4@27
  int v27; // eax@27
  int v28; // edx@27
  int v29; // eax@30
  char v30; // bl@32
  int v31; // eax@32
  int v32; // eax@32
  int v33; // edx@40
  int v34; // ecx@40
  int v35; // [sp-4h] [bp-80h]@40
  void *v36; // [sp+10h] [bp-6Ch]@30
  int v37; // [sp+18h] [bp-64h]@27
  int v38; // [sp+1Ch] [bp-60h]@27
  int v39; // [sp+20h] [bp-5Ch]@27
  unsigned int v40; // [sp+24h] [bp-58h]@27
  void *v41; // [sp+28h] [bp-54h]@32
  char v42; // [sp+34h] [bp-48h]@27
  int v43; // [sp+38h] [bp-44h]@34
  unsigned int v44; // [sp+3Ch] [bp-40h]@32
  void *v45; // [sp+40h] [bp-3Ch]@32
  char v46; // [sp+4Ch] [bp-30h]@27
  __int64 v47; // [sp+50h] [bp-2Ch]@17
  unsigned int v48; // [sp+58h] [bp-24h]@17
  unsigned int v49; // [sp+5Ch] [bp-20h]@17
  unsigned int v50; // [sp+60h] [bp-1Ch]@17
  void *v51; // [sp+64h] [bp-18h]@1
  char v52; // [sp+6Bh] [bp-11h]@14
  int v53; // [sp+78h] [bp-4h]@27

  v6 = this;
  v51 = this;
  v2 = 0;
  v4 = *(_DWORD *)(a2 + 4);
  v5 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)(a2 + 4);
  if ( v3 == v5 )
    goto LABEL_49;
  do
  {
    v2 = v2 || (v7 = *(_BYTE *)v3, *(_BYTE *)v3 == 46) || v7 == 101 || v7 == 69 || v7 == 43 || v7 == 45 && v3 != v4;
    ++v3;
  }
  while ( v3 != v5 );
  if ( v2 )
  {
    result = sub_1000F380(v6, a2);
  }
  else
  {
LABEL_49:
    v9 = *(_DWORD *)(a2 + 4);
    v52 = *(_BYTE *)v4 == 45;
    if ( v52 )
    {
      v9 = v4 + 1;
      v11 = 0;
      v10 = -2147483648;
    }
    else
    {
      v11 = -1;
      v10 = -1;
    }
    HIDWORD(v15) = v10;
    LODWORD(v15) = v11;
    v16 = sub_10039A80(v15, 0xAu, 0);
    v13 = 10 * v16;
    __asm
    {
      xorps   xmm0, xmm0
      movlpd  [ebp+var_2C], xmm0
    }
    v50 = HIDWORD(v16);
    v12 = v47;
    v48 = v11 - 10 * v16;
    v14 = HIDWORD(v47);
    v49 = v16;
    if ( v9 >= (unsigned int)v5 )
    {
LABEL_26:
      if ( v52 )
      {
        v25 = -v12;
        v39 = v39 & 0xFFFFFF01 | 1;
        v40 = 0;
        v37 = v25;
        v38 = (unsigned __int64)-__PAIR__(v14, v25) >> 32;
        v26 = v13;
        v53 = 3;
        v27 = sub_10013580((int)v51, (int)&v42);
        v23 = sub_10015510(v27, v28, (int)&v46, v26);
        v24 = *(_DWORD *)v23;
        if ( *(_DWORD *)v23 )
          v24 = *(_DWORD *)v24;
        v33 = *(_DWORD *)(v23 + 8) & 3;
        v35 = (int)&v37;
        v34 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v24 + 4)
                                    + 4 * ((*(_DWORD *)(v23 + 8) >> 2) & (*(_DWORD *)(v24 + 8) - 1)))
                        + 4 * v33);
      }
      else
      {
        if ( v14 || (unsigned int)v12 > 0x7FFFFFFF )
        {
          v39 = v39 & 0xFFFFFF02 | 2;
          v40 = 0;
          v37 = v12;
          v38 = v14;
          v53 = 5;
        }
        else
        {
          v39 = v39 & 0xFFFFFF01 | 1;
          v40 = 0;
          v37 = v12;
          v38 = v14;
          v53 = 4;
        }
        v35 = (int)&v37;
        v34 = sub_1000FE80((int)v51);
      }
      sub_10010260(v34, v33, v35);
      v53 = -1;
      sub_100101D0((int)&v37, v5);
      result = 1;
    }
    else
    {
      while ( 1 )
      {
        v17 = *(_BYTE *)v9++;
        if ( v17 < 48 )
          break;
        if ( v17 > 57 )
          break;
        v18 = v17 - 48;
        HIDWORD(v47) = v18;
        if ( v14 >= v50 && (v14 > v50 || v12 >= v49) && (v9 != v5 || v18 > v48) )
          return sub_1000F380(v51, a2);
        HIDWORD(v19) = v14;
        LODWORD(v19) = v12;
        v13 = (unsigned __int64)(4 * v19) >> 32;
        v20 = 4 * v12 >= (unsigned int)-v12;
        v21 = 5 * v12;
        HIDWORD(v19) = v13 + v20 + v14;
        LODWORD(v19) = v21;
        v21 *= 2;
        v22 = HIDWORD(v47) >= (unsigned int)-v21;
        v12 = HIDWORD(v47) + v21;
        v14 = v22 + ((unsigned __int64)(2 * v19) >> 32);
        if ( v9 >= (unsigned int)v5 )
          goto LABEL_26;
      }
      v40 = 15;
      v29 = *(_DWORD *)(a2 + 4);
      v39 = 0;
      LOBYTE(v36) = 0;
      if ( v29 != v5 )
        loc_1000AEB0(&v36, v29, v5 - v29);
      v53 = 0;
      v31 = sub_100155D0((int)&v45, (int)"'", (int)&v36);
      LOBYTE(v53) = 1;
      v32 = sub_10015660((int)&v41, v31, "' is not a number.");
      LOBYTE(v53) = 2;
      v30 = sub_1000FD10(v51, (int *)v32, a2, 0);
      if ( v44 >= 0x10 )
        sub_1002A4AA(v41);
      v44 = 15;
      v43 = 0;
      LOBYTE(v41) = 0;
      if ( HIDWORD(v47) >= 0x10u )
        sub_1002A4AA(v45);
      v47 = 64424509440i64;
      LOBYTE(v45) = 0;
      if ( v40 >= 0x10 )
        sub_1002A4AA(v36);
      result = v30;
    }
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1000F380) --------------------------------------------------------
char __thiscall sub_1000F380(void *this, int a2)
{
  int v2; // eax@1
  int v3; // ecx@1
  int v4; // ebx@1
  int v5; // esi@1
  int v6; // ecx@3
  int v7; // esi@3
  int v8; // eax@6
  int v9; // eax@11
  int v10; // ecx@11
  char v11; // bl@13
  int v12; // eax@13
  int v13; // eax@13
  char result; // al@19
  int v15; // eax@20
  int v16; // esi@20
  int v17; // ST08_4@20
  int v18; // eax@20
  int v19; // edx@20
  char v20; // [sp+Ch] [bp-8Ch]@20
  char v21; // [sp+18h] [bp-80h]@20
  void *v22; // [sp+24h] [bp-74h]@13
  int v23; // [sp+34h] [bp-64h]@15
  unsigned int v24; // [sp+38h] [bp-60h]@13
  __int64 v25; // [sp+3Ch] [bp-5Ch]@1
  void *v26; // [sp+44h] [bp-54h]@5
  __int64 v27; // [sp+4Ch] [bp-4Ch]@20
  int v28; // [sp+54h] [bp-44h]@5
  unsigned int v29; // [sp+58h] [bp-40h]@5
  char v30[8]; // [sp+60h] [bp-38h]@2
  void *v31; // [sp+68h] [bp-30h]@13
  int v32; // [sp+78h] [bp-20h]@17
  unsigned int v33; // [sp+7Ch] [bp-1Ch]@15
  unsigned int v34; // [sp+84h] [bp-14h]@1
  int v35; // [sp+94h] [bp-4h]@13
  int v36; // [sp+98h] [bp+0h]@1

  v34 = (unsigned int)&v36 ^ __security_cookie;
  v4 = (int)this;
  __asm { xorps   xmm0, xmm0 }
  v3 = *(_DWORD *)(a2 + 8);
  v2 = *(_DWORD *)(a2 + 4);
  v5 = *(_DWORD *)(a2 + 8) - v2;
  __asm { movsd   [ebp+var_5C], xmm0 }
  if ( v5 <= 32 )
  {
    sub_10034F00(v30, (const void *)v2, v5);
    if ( (unsigned int)v5 < 0x21 )
    {
      v30[v5] = 0;
      v7 = sub_10030865(v4, (int)v30, (int)"%lf", (unsigned int)&v25);
      goto LABEL_10;
    }
    v2 = sub_1003078B(v4, a2, v5);
  }
  v29 = 15;
  v28 = 0;
  LOBYTE(v26) = 0;
  if ( v2 == v3 || (loc_1000AEB0(&v26, v2, v3 - v2), v8 = (int)v26, v29 < 0x10) )
    v8 = (int)&v26;
  v7 = sub_10030865(v4, v8, (int)"%lf", (unsigned int)&v25);
  if ( v29 >= 0x10 )
    sub_1002A4AA(v26);
LABEL_10:
  if ( v7 == 1 )
  {
    __asm { movsd   xmm0, [ebp+var_5C] }
    v28 = v28 & 0xFFFFFF03 | 3;
    v29 = 0;
    __asm { movsd   [ebp+var_4C], xmm0 }
    v17 = v6;
    v35 = 3;
    v18 = sub_10013580(v4, (int)&v21);
    v15 = sub_10015510(v18, v19, (int)&v20, v17);
    v16 = *(_DWORD *)v15;
    if ( *(_DWORD *)v15 )
      v16 = *(_DWORD *)v16;
    sub_10010260(
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v16 + 4) + 4 * ((*(_DWORD *)(v15 + 8) >> 2) & (*(_DWORD *)(v16 + 8) - 1)))
                + 4 * (*(_DWORD *)(v15 + 8) & 3)),
      *(_DWORD *)(v15 + 8) & 3,
      (int)&v27);
    v35 = -1;
    sub_100101D0((int)&v27, v4);
    result = 1;
  }
  else
  {
    v9 = *(_DWORD *)(a2 + 8);
    v10 = *(_DWORD *)(a2 + 4);
    v29 = 15;
    v28 = 0;
    LOBYTE(v26) = 0;
    if ( v10 != v9 )
      loc_1000AEB0(&v26, v10, v9 - v10);
    v35 = 0;
    v12 = sub_100155D0((int)&v31, (int)"'", (int)&v26);
    LOBYTE(v35) = 1;
    v13 = sub_10015660((int)&v22, v12, "' is not a number.");
    LOBYTE(v35) = 2;
    v11 = sub_1000FD10((void *)v4, (int *)v13, a2, 0);
    if ( v24 >= 0x10 )
      sub_1002A4AA(v22);
    v24 = 15;
    v23 = 0;
    LOBYTE(v22) = 0;
    if ( v33 >= 0x10 )
      sub_1002A4AA(v31);
    v33 = 15;
    v32 = 0;
    LOBYTE(v31) = 0;
    if ( v29 >= 0x10 )
      sub_1002A4AA(v26);
    result = v11;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;
// 1000F380: using guessed type char var_38[8];

//----- (1000F5C0) --------------------------------------------------------
char __userpurge sub_1000F5C0<al>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v3; // esi@1
  char v4; // bl@2
  int *v5; // ecx@3
  int v6; // eax@5
  int v7; // esi@5
  int v8; // ecx@5
  int v9; // ST08_4@5
  int v10; // eax@5
  int v11; // edx@5
  char v13; // [sp+Ch] [bp-54h]@5
  char v14; // [sp+18h] [bp-48h]@5
  int v15; // [sp+24h] [bp-3Ch]@5
  int v16; // [sp+2Ch] [bp-34h]@5
  int v17; // [sp+30h] [bp-30h]@5
  void *v18; // [sp+34h] [bp-2Ch]@1
  int v19; // [sp+44h] [bp-1Ch]@1
  unsigned int v20; // [sp+48h] [bp-18h]@1
  unsigned int v21; // [sp+4Ch] [bp-14h]@1
  int v22; // [sp+5Ch] [bp-4h]@1
  int v23; // [sp+60h] [bp+0h]@1

  v21 = (unsigned int)&v23 ^ __security_cookie;
  v3 = a1;
  v20 = 15;
  v19 = 0;
  LOBYTE(v18) = 0;
  v22 = 0;
  if ( (unsigned __int8)loc_1000F6D0(a3, &v18, (unsigned int)&v23 ^ __security_cookie) )
  {
    v5 = (int *)&v18;
    if ( v20 >= 0x10 )
      v5 = (int *)v18;
    v16 = v16 & 0xFFFFFF04 | 0x104;
    v17 = 0;
    v15 = loc_1000FED0(v5, v19);
    v9 = v8;
    LOBYTE(v22) = 1;
    v10 = sub_10013580(v3, (int)&v14);
    v6 = sub_10015510(v10, v11, (int)&v13, v9);
    v7 = *(_DWORD *)v6;
    if ( *(_DWORD *)v6 )
      v7 = *(_DWORD *)v7;
    sub_10010260(
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 4) + 4 * ((*(_DWORD *)(v6 + 8) >> 2) & (*(_DWORD *)(v7 + 8) - 1)))
                + 4 * (*(_DWORD *)(v6 + 8) & 3)),
      *(_DWORD *)(v6 + 8) & 3,
      (int)&v15);
    LOBYTE(v22) = 0;
    sub_100101D0((int)&v15, a2);
    v4 = 1;
  }
  else
  {
    v4 = 0;
  }
  if ( v20 >= 0x10 )
    sub_1002A4AA(v18);
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (1000FA50) --------------------------------------------------------
char __thiscall sub_1000FA50(void *this, int a2, int *a3, int a4, int a5)
{
  int v5; // edi@1
  int v7; // ecx@5
  char v8; // bl@6
  char v9; // al@7
  int v10; // edx@7
  char v11; // cl@8
  char v12; // bl@12
  char v13; // [sp+10h] [bp-40h]@12
  char v14; // [sp+28h] [bp-28h]@6
  void *v15; // [sp+40h] [bp-10h]@1
  int v16; // [sp+4Ch] [bp-4h]@6

  v15 = this;
  v5 = a5;
  if ( !sub_1000FBC0(this, a2, a3, a4, a5) )
    return 0;
  if ( *(_DWORD *)v5 < 0xD800u || *(_DWORD *)v5 > 0xDBFFu )
    return 1;
  v7 = *a3;
  if ( a4 - *a3 < 6 )
  {
    sub_1000AFB0((int)&v14, "additional six characters expected to parse unicode surrogate pair.");
    v16 = 0;
    v8 = sub_1000FD10(v15, (int *)&v14, a2, *a3);
    sub_10001880((int)&v14);
    return v8;
  }
  v9 = *(_BYTE *)v7;
  v10 = v7 + 1;
  *a3 = v7 + 1;
  if ( v9 == 92 )
  {
    v11 = *(_BYTE *)v10;
    *a3 = v10 + 1;
    if ( v11 == 117 )
    {
      if ( !sub_1000FBC0(v15, a2, a3, a4, (int)&a5) )
        return 0;
      *(_DWORD *)v5 = (a5 & 0x3FF) + (((*(_DWORD *)v5 & 0x3FF) + 64) << 10);
      return 1;
    }
  }
  sub_1000AFB0((int)&v13, "expecting another \\u token to begin the second half of a unicode surrogate pair");
  v16 = 1;
  v12 = sub_1000FD10(v15, (int *)&v13, a2, *a3);
  sub_10001880((int)&v13);
  return v12;
}

//----- (1000FBC0) --------------------------------------------------------
char __thiscall sub_1000FBC0(void *this, int a2, int *a3, int a4, int a5)
{
  void *v5; // esi@1
  char v6; // bl@2
  signed int v7; // edi@4
  int v8; // edx@5
  char v9; // cl@5
  int v10; // eax@6
  int v12; // [sp-4h] [bp-54h]@3
  int v13; // [sp+10h] [bp-40h]@13
  int v14; // [sp+20h] [bp-30h]@13
  unsigned int v15; // [sp+24h] [bp-2Ch]@13
  int v16; // [sp+28h] [bp-28h]@2
  int v17; // [sp+38h] [bp-18h]@2
  unsigned int v18; // [sp+3Ch] [bp-14h]@2
  void *v19; // [sp+40h] [bp-10h]@1
  int v20; // [sp+4Ch] [bp-4h]@2

  v5 = this;
  v19 = this;
  if ( a4 - *a3 < 4 )
  {
    v18 = 15;
    v17 = 0;
    LOBYTE(v16) = 0;
    loc_1000AEB0(&v16, "Bad unicode escape sequence in string: four digits expected.", 60);
    v20 = 0;
    v6 = sub_1000FD10(v5, &v16, a2, *a3);
    if ( v18 >= 0x10 )
    {
      v12 = v16;
      goto LABEL_15;
    }
    return v6;
  }
  v7 = 0;
  *(_DWORD *)a5 = 0;
  while ( 1 )
  {
    v9 = *(_BYTE *)*a3++;
    v8 = 16 * *(_DWORD *)a5;
    *(_DWORD *)a5 = v8;
    if ( (unsigned __int8)(v9 - 48) > 9u )
      break;
    v10 = v9 - 48;
LABEL_11:
    ++v7;
    *(_DWORD *)a5 = v8 + v10;
    if ( v7 >= 4 )
      return 1;
  }
  if ( (unsigned __int8)(v9 - 97) <= 5u )
  {
    v10 = v9 - 87;
    goto LABEL_11;
  }
  if ( (unsigned __int8)(v9 - 65) <= 5u )
  {
    v10 = v9 - 55;
    goto LABEL_11;
  }
  v15 = 15;
  v14 = 0;
  LOBYTE(v13) = 0;
  loc_1000AEB0(&v13, "Bad unicode escape sequence in string: hexadecimal digit expected.", 66);
  v20 = 1;
  v6 = sub_1000FD10(v19, &v13, a2, *a3);
  if ( v15 >= 0x10 )
  {
    v12 = v13;
LABEL_15:
    sub_1002A4AA((LPVOID)v12);
  }
  return v6;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1000FD10) --------------------------------------------------------
char __thiscall sub_1000FD10(void *this, int *a2, int a3, int a4)
{
  int v4; // edx@1
  void *v5; // esi@1
  __int64 v8; // [sp+Ch] [bp-3Ch]@1
  int v9; // [sp+14h] [bp-34h]@1
  void *v10; // [sp+18h] [bp-30h]@1
  int v11; // [sp+28h] [bp-20h]@1
  unsigned int v12; // [sp+2Ch] [bp-1Ch]@1
  int v13; // [sp+30h] [bp-18h]@1
  unsigned int v14; // [sp+34h] [bp-14h]@1
  int v15; // [sp+44h] [bp-4h]@1
  int v16; // [sp+48h] [bp+0h]@1

  v14 = (unsigned int)&v16 ^ __security_cookie;
  v5 = this;
  v4 = (int)a2;
  _EAX = a3;
  v13 = 0;
  v12 = 15;
  v11 = 0;
  LOBYTE(v10) = 0;
  v15 = 0;
  __asm { movq    xmm0, qword ptr [eax] }
  v9 = *(_DWORD *)(a3 + 8);
  __asm { movq    [ebp+var_3C], xmm0 }
  if ( &v10 != (void **)a2 )
    loc_1000AB40(&v10, a2, 0, -1);
  v13 = a4;
  sub_100126C0((int)((char *)v5 + 20), v4, (int)&v8);
  if ( v12 >= 0x10 )
    sub_1002A4AA(v10);
  return 0;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (1000FDD0) --------------------------------------------------------
char __thiscall sub_1000FDD0(int this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v5; // [sp+10h] [bp-Ch]@2

  v3 = this;
  v2 = *(_DWORD *)(this + 36);
  do
  {
    if ( !sub_1000E530(v3, (int)&v5) )
      loc_10012540(v3 + 20, v2);
  }
  while ( v5 != a2 && v5 );
  loc_10012540(v3 + 20, v2);
  return 0;
}

//----- (1000FE20) --------------------------------------------------------
char __thiscall sub_1000FE20(void *this, int *a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  int v7; // [sp+10h] [bp-Ch]@2

  v5 = (int)this;
  sub_1000FD10(this, a2, a3, 0);
  v4 = *(_DWORD *)(v5 + 36);
  do
  {
    if ( !sub_1000E530(v5, (int)&v7) )
      loc_10012540(v5 + 20, v4);
  }
  while ( v7 != a4 && v7 );
  loc_10012540(v5 + 20, v4);
  return 0;
}

//----- (1000FE80) --------------------------------------------------------
int __thiscall sub_1000FE80(int this)
{
  int v1; // eax@1
  int v2; // esi@1
  int v3; // ST08_4@1
  int v4; // eax@1
  int v5; // eax@1
  int v6; // edx@1
  char v8; // [sp+4h] [bp-18h]@1
  char v9; // [sp+10h] [bp-Ch]@1

  v3 = this;
  v4 = sub_10013580(this, (int)&v8);
  v5 = sub_10015510(v4, v6, (int)&v9, v3);
  v2 = v5;
  v1 = *(_DWORD *)v5;
  if ( v1 )
    v1 = *(_DWORD *)v1;
  return *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 4) + 4 * ((*(_DWORD *)(v1 + 8) - 1) & (*(_DWORD *)(v2 + 8) >> 2)))
                   + 4 * (*(_DWORD *)(v2 + 8) & 3));
}

//----- (10010010) --------------------------------------------------------
int __fastcall sub_10010010(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  char v5; // al@1
  int v6; // eax@4
  int v7; // eax@6
  int v8; // esi@6
  int v9; // eax@11
  int v10; // esi@12
  signed int v11; // esi@14
  int v12; // edi@15
  void *v13; // eax@16
  int v14; // eax@16
  int (__stdcall **v16)(char); // [sp+Ch] [bp-24h]@23
  int v17; // [sp+18h] [bp-18h]@6
  int v18; // [sp+1Ch] [bp-14h]@1
  unsigned int v19; // [sp+20h] [bp-10h]@1
  int v20; // [sp+2Ch] [bp-4h]@6
  int v21; // [sp+30h] [bp+0h]@1

  v19 = (unsigned int)&v21 ^ __security_cookie;
  v3 = a1;
  v4 = a3;
  v18 = a3;
  v5 = *(_BYTE *)(a3 + 8);
  *(_BYTE *)(a1 + 8) = v5;
  *(_DWORD *)(a1 + 12) = 0;
  switch ( v5 )
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 5:
      *(_DWORD *)a1 = *(_DWORD *)a3;
      *(_DWORD *)(a1 + 4) = *(_DWORD *)(a3 + 4);
      break;
    case 4:
      a1 = *(_DWORD *)a3;
      if ( *(_DWORD *)a3 )
      {
        v6 = loc_1000FED0(a1, -1);
        *(_DWORD *)(v3 + 8) |= 0x100u;
        *(_DWORD *)v3 = v6;
      }
      else
      {
        *(_DWORD *)v3 = 0;
      }
      break;
    case 6:
    case 7:
      v7 = sub_1002ADB1(a2, a1, a1, a3, 8);
      v8 = v7;
      v17 = v7;
      v20 = 0;
      if ( v7 )
      {
        *(_DWORD *)v7 = 0;
        sub_10013050(a2, v7, v3, a3, *(_DWORD *)a3, a1);
      }
      else
      {
        v8 = 0;
      }
      v20 = -1;
      *(_DWORD *)v3 = v8;
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a3 + 12) )
  {
    v9 = sub_1002965B(a2, a1, v3, a3, 16);
    v17 = v9;
    v20 = 1;
    if ( v9 )
    {
      v10 = v9 + 4;
      *(_DWORD *)v9 = 3;
      sub_100309DA(v9 + 4, 4, 3, (void (__thiscall *)(_DWORD))sub_100099D0, (int)sub_1000FF60);
    }
    else
    {
      v10 = 0;
    }
    v20 = -1;
    *(_DWORD *)(v3 + 12) = v10;
    v11 = 0;
    while ( 1 )
    {
      v12 = *(_DWORD *)(*(_DWORD *)(v4 + 12) + v11);
      if ( v12 )
      {
        v14 = v11 + *(_DWORD *)(v3 + 12);
        v17 = v14;
        v13 = *(void **)v14;
        if ( v13 )
          sub_100309A2(v3, v13);
        if ( *(_BYTE *)v12 && *(_BYTE *)v12 != 47 )
        {
          v18 = (int)"Comments must start with /";
          sub_1002AEA4((int)&v16, &v18);
          v16 = &off_10060320;
          sub_100355DB((int)&v16, (int)&unk_1006D96C);
          return v3;
        }
        *(_DWORD *)v17 = loc_1000FED0(v12, -1);
      }
      v11 += 4;
      if ( v11 >= 12 )
        return v3;
      v4 = v18;
    }
  }
  return v3;
}
// 1000FF60: using guessed type int sub_1000FF60();
// 10060320: using guessed type int (__stdcall *off_10060320)(char);
// 10074200: using guessed type int __security_cookie;

//----- (100101D0) --------------------------------------------------------
int __usercall sub_100101D0<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // eax@1
  int v3; // esi@1
  void *v4; // edi@3
  int result; // eax@8
  void *v6; // esi@9
  char v7; // [sp+8h] [bp-4h]@4

  v3 = a1;
  v2 = *(_BYTE *)(a1 + 8);
  if ( v2 == 4 )
  {
    if ( *(_DWORD *)(a1 + 8) & 0x100 )
    {
      if ( *(_DWORD *)a1 )
        sub_100309A2(a2, *(LPVOID *)a1);
    }
  }
  else
  {
    if ( (unsigned int)(v2 - 6) <= 1 )
    {
      v4 = *(void **)a1;
      if ( *(_DWORD *)a1 )
      {
        sub_100130F0(v4, (int)&v7, **(_DWORD **)v4, *(_DWORD *)v4);
        sub_1002A4AA(*(LPVOID *)v4);
        sub_1002A4AA(v4);
      }
    }
  }
  result = *(_DWORD *)(v3 + 12);
  if ( result )
  {
    v6 = (void *)(result - 4);
    sub_1002B11F(result, 4, *(_DWORD *)(result - 4), (void (__thiscall *)(_DWORD))sub_1000FF60);
    result = sub_10030383(v6);
  }
  return result;
}
// 1000FF60: using guessed type int sub_1000FF60();
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (10010260) --------------------------------------------------------
int __fastcall sub_10010260(int a1, int a2, int a3)
{
  int v4; // esi@1
  int v5; // ebx@1
  unsigned __int8 v6; // al@1
  int v7; // ecx@1
  int v8; // edx@1
  int v9; // ebx@1
  int v10; // eax@1
  int v11; // ebx@1
  int v12; // [sp+8h] [bp-14h]@1
  int v13; // [sp+Ch] [bp-10h]@1
  int v14; // [sp+10h] [bp-Ch]@1
  int v15; // [sp+14h] [bp-8h]@1

  v4 = a1;
  v15 = 0;
  sub_10010010((int)&v12, a2, a3);
  v5 = v14;
  v6 = v14 ^ *(_BYTE *)(v4 + 8);
  *(_BYTE *)(v4 + 8) = v14;
  v7 = *(_DWORD *)v4;
  v8 = *(_DWORD *)(v4 + 4);
  v9 = v6 ^ v5;
  *(_DWORD *)v4 = v12;
  *(_DWORD *)(v4 + 4) = v13;
  v13 = v8;
  v12 = v7;
  v10 = *(_DWORD *)(v4 + 8) ^ ((_WORD)v9 ^ (unsigned __int16)*(_DWORD *)(v4 + 8)) & 0x100;
  v11 = ((_WORD)v9 ^ (unsigned __int16)((unsigned __int16)(*(_DWORD *)(v4 + 8) << 23 >> 31) << 8)) & 0x100 ^ v9;
  *(_DWORD *)(v4 + 8) = v10;
  v14 = v11;
  sub_100101D0((int)&v12, v11);
  return v4;
}

//----- (100109A0) --------------------------------------------------------
char __thiscall sub_100109A0(void *_ECX)
{
  char result; // al@3

  switch ( *((_BYTE *)_ECX + 8) )
  {
    case 1:
    case 2:
      if ( *(_QWORD *)_ECX )
        goto LABEL_5;
      goto LABEL_3;
    case 3:
      __asm
      {
        movsd   xmm0, qword ptr [ecx]; jumptable 100109A9 case 3
        ucomisd xmm0, ds:qword_10069470
        lahf
      }
      if ( !__SETP__(_AH & 0x44, 0) )
        goto LABEL_3;
LABEL_5:
      result = 1;
      break;
    case 5:
      result = *(_BYTE *)_ECX;
      break;
    case 4:
      if ( *(_DWORD *)_ECX && **(_BYTE **)_ECX )
        result = 1;
      else
LABEL_3:
        result = 0;
      break;
    case 6:
    case 7:
      result = *(_DWORD *)(*(_DWORD *)_ECX + 4) != 0;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (10010A20) --------------------------------------------------------
int __thiscall sub_10010A20(void *this)
{
  int result; // eax@3
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  switch ( *((_BYTE *)this + 8) )
  {
    case 6:
      if ( !*(_DWORD *)(*(_DWORD *)this + 4) )
        goto LABEL_5;
      v2 = (void *)**(_DWORD **)this;
      sub_10013460(&v2);
      result = *((_DWORD *)v2 + 5) + 1;
      break;
    case 7:
      result = *(_DWORD *)(*(_DWORD *)this + 4);
      break;
    default:
LABEL_5:
      result = 0;
      break;
  }
  return result;
}

//----- (10010A90) --------------------------------------------------------
int __userpurge sub_10010A90<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4)
{
  void **v4; // ebx@1
  int v5; // eax@2
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // esi@2
  int v9; // eax@6
  int v10; // edx@6
  int v11; // esi@6
  void *v12; // edi@6
  int v13; // eax@7
  int v14; // ecx@8
  unsigned __int8 v15; // cf@9
  char v16; // zf@13
  int result; // eax@17
  int v18; // esi@18
  void *v19; // edi@18
  int v20; // eax@18
  int v21; // [sp+Ch] [bp-44h]@5
  int v22; // [sp+14h] [bp-3Ch]@2
  int v23; // [sp+18h] [bp-38h]@2
  int v24; // [sp+20h] [bp-30h]@2
  LPVOID lpMem; // [sp+24h] [bp-2Ch]@18
  int v26; // [sp+28h] [bp-28h]@18
  char v27; // [sp+2Ch] [bp-24h]@18
  unsigned int v28; // [sp+3Ch] [bp-14h]@1
  int v29; // [sp+4Ch] [bp-4h]@2
  int v30; // [sp+50h] [bp+0h]@1

  v28 = (unsigned int)&v30 ^ __security_cookie;
  v4 = (void **)a2;
  if ( !*(_BYTE *)(a2 + 8) )
  {
    v22 = v22 & 0xFFFFFE06 | 6;
    v23 = 0;
    v5 = sub_1002ADB1(a1, a2, a2, a3, 8);
    v8 = v5;
    v24 = v5;
    v29 = 0;
    if ( v5 )
    {
      *(_DWORD *)v5 = 0;
      *(_DWORD *)(v5 + 4) = 0;
      *(_DWORD *)v5 = sub_100155A0(v6, v7, (int)v4, a3);
    }
    else
    {
      v8 = 0;
    }
    v21 = v8;
    v29 = 1;
    sub_10010260((int)v4, v6, (int)&v21);
    v29 = -1;
    sub_100101D0((int)&v21, (int)v4);
  }
  v22 = 0;
  v23 = a4;
  v29 = 2;
  v12 = *v4;
  v9 = sub_10013250(*v4, (int)&v22);
  v11 = v9;
  if ( v9 == *(_DWORD *)v12 )
    goto LABEL_24;
  v13 = *(_DWORD *)(v9 + 16);
  if ( v13 )
  {
    v14 = 0;
    while ( 1 )
    {
      LOBYTE(v10) = *(_BYTE *)v13;
      v15 = *(_BYTE *)v13 < *(_BYTE *)v14;
      if ( *(_BYTE *)v13 != *(_BYTE *)v14 )
        break;
      if ( !(_BYTE)v10 )
        goto LABEL_13;
      LOBYTE(v10) = *(_BYTE *)(v13 + 1);
      v15 = (_BYTE)v10 < *(_BYTE *)(v14 + 1);
      if ( (_BYTE)v10 != *(_BYTE *)(v14 + 1) )
        break;
      v13 += 2;
      v14 += 2;
      if ( !(_BYTE)v10 )
      {
LABEL_13:
        v16 = 1;
        goto LABEL_16;
      }
    }
    v16 = (-v15 | 1) == 0;
  }
  else
  {
    v16 = *(_DWORD *)(v11 + 20) == a4;
  }
LABEL_16:
  if ( v16 )
  {
    result = v11 + 24;
  }
  else
  {
LABEL_24:
    lpMem = 0;
    v26 = a4;
    LOBYTE(v29) = 3;
    sub_10010010((int)&v27, v10, (int)&unk_10077A30);
    LOBYTE(v29) = 4;
    v19 = *v4;
    v20 = sub_100160E0((int)&lpMem);
    sub_100161A0((int)v19, (int)&v24, v11, v20 + 16, v20);
    v18 = v24 + 24;
    LOBYTE(v29) = 5;
    sub_100101D0((int)&v27, (int)v4);
    if ( lpMem )
    {
      if ( v26 == 1 )
        sub_100309A2((int)v4, lpMem);
    }
    result = v18;
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;

//----- (10010C30) --------------------------------------------------------
void __usercall sub_10010C30(int a1<ecx>, int a2<ebx>)
{
  int v2; // esi@1

  v2 = a1;
  sub_100101D0(a1 + 8, a2);
  if ( *(_DWORD *)v2 )
  {
    if ( *(_DWORD *)(v2 + 4) == 1 )
      sub_100309A2(a2, *(LPVOID *)v2);
  }
}

//----- (10010C90) --------------------------------------------------------
int __fastcall sub_10010C90(int a1, int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // eax@2
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // esi@2
  int v9; // eax@6
  int v10; // edx@6
  int v11; // esi@6
  void *v12; // edi@6
  int v13; // eax@7
  int v14; // ecx@8
  unsigned __int8 v15; // cf@9
  char v16; // zf@13
  int result; // eax@17
  void *v18; // eax@19
  int v19; // ebx@21
  int v20; // esi@21
  int v21; // edi@21
  int v22; // eax@21
  int v23; // [sp+Ch] [bp-48h]@5
  int v24; // [sp+14h] [bp-40h]@2
  int v25; // [sp+18h] [bp-3Ch]@2
  int v26; // [sp+20h] [bp-34h]@6
  int v27; // [sp+24h] [bp-30h]@2
  int v28; // [sp+28h] [bp-2Ch]@1
  LPVOID lpMem; // [sp+2Ch] [bp-28h]@21
  int v30; // [sp+30h] [bp-24h]@21
  char v31; // [sp+34h] [bp-20h]@21
  unsigned int v32; // [sp+44h] [bp-10h]@1
  int v33; // [sp+50h] [bp-4h]@2
  int v34; // [sp+54h] [bp+0h]@1

  v32 = (unsigned int)&v34 ^ __security_cookie;
  v4 = a1;
  v28 = a1;
  if ( !*(_BYTE *)(a1 + 8) )
  {
    v24 = v24 & 0xFFFFFE07 | 7;
    v25 = 0;
    v5 = sub_1002ADB1(a2, a1, a3, a1, 8);
    v8 = v5;
    v27 = v5;
    v33 = 0;
    if ( v5 )
    {
      *(_DWORD *)v5 = 0;
      *(_DWORD *)(v5 + 4) = 0;
      *(_DWORD *)v5 = sub_100155A0(v6, v7, a3, v4);
    }
    else
    {
      v8 = 0;
    }
    v23 = v8;
    v33 = 1;
    sub_10010260(v4, v6, (int)&v23);
    v33 = -1;
    sub_100101D0((int)&v23, a3);
  }
  v26 = a3;
  v27 = 2;
  v33 = 2;
  v12 = *(void **)v4;
  v9 = sub_10013250(v12, (int)&v26);
  v11 = v9;
  if ( v9 == *(_DWORD *)v12 )
    goto LABEL_27;
  v13 = *(_DWORD *)(v9 + 16);
  if ( v13 )
  {
    v14 = a3;
    while ( 1 )
    {
      LOBYTE(v10) = *(_BYTE *)v13;
      v15 = *(_BYTE *)v13 < *(_BYTE *)v14;
      if ( *(_BYTE *)v13 != *(_BYTE *)v14 )
        break;
      if ( !(_BYTE)v10 )
        goto LABEL_13;
      LOBYTE(v10) = *(_BYTE *)(v13 + 1);
      v15 = (_BYTE)v10 < *(_BYTE *)(v14 + 1);
      if ( (_BYTE)v10 != *(_BYTE *)(v14 + 1) )
        break;
      v13 += 2;
      v14 += 2;
      if ( !(_BYTE)v10 )
      {
LABEL_13:
        v16 = 1;
        goto LABEL_16;
      }
    }
    v16 = (-v15 | 1) == 0;
  }
  else
  {
    v16 = *(_DWORD *)(v11 + 20) == 2;
  }
LABEL_16:
  if ( v16 )
  {
    result = v11 + 24;
  }
  else
  {
LABEL_27:
    if ( a3 )
      v18 = (void *)loc_1000FED0(a3, -1);
    else
      v18 = 0;
    v19 = 2 - (a3 != 0);
    lpMem = v18;
    v30 = 2 - (a3 != 0);
    LOBYTE(v33) = 3;
    sub_10010010((int)&v31, v10, (int)&unk_10077A30);
    LOBYTE(v33) = 4;
    v21 = *(_DWORD *)v28;
    v22 = sub_100160E0((int)&lpMem);
    sub_100161A0(v21, (int)&v28, v11, v22 + 16, v22);
    v20 = v28 + 24;
    LOBYTE(v33) = 5;
    sub_100101D0((int)&v31, v19);
    if ( lpMem )
    {
      if ( v30 == 1 )
        sub_100309A2(v19, lpMem);
    }
    result = v20;
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;

//----- (10010E40) --------------------------------------------------------
int __fastcall sub_10010E40(int a1, int a2, int a3, int a4, int a5)
{
  char v5; // zf@1
  int v6; // eax@2
  int v7; // eax@3
  void *v8; // esi@3
  int v10; // [sp+4h] [bp-10h]@3
  int v11; // [sp+8h] [bp-Ch]@3
  int v12; // [sp+Ch] [bp-8h]@1

  v5 = *(_BYTE *)(a1 + 8) == 0;
  v12 = 0;
  if ( v5
    || (v8 = *(void **)a1, v10 = a4, v11 = 0, v7 = *(_DWORD *)sub_100124C0(v8, (int)&a4, (int)&v10), v7 == *(_DWORD *)v8) )
    v6 = (int)&unk_10077A30;
  else
    v6 = v7 + 24;
  if ( (_UNKNOWN *)v6 == &unk_10077A30 )
    v6 = a5;
  sub_10010010(a3, a2, v6);
  return a3;
}

//----- (10010EA0) --------------------------------------------------------
int __thiscall sub_10010EA0(void *this, int a2)
{
  void *v2; // edi@1
  char v3; // zf@1
  int result; // eax@2
  unsigned int v5; // eax@3
  unsigned int v6; // ebx@3
  int v7; // edi@7
  int v8; // esi@7
  int v9; // edx@8
  int v10; // ecx@9
  int v11; // ecx@10
  char v12; // al@11
  int *v13; // ecx@13
  int v14; // eax@15
  int v15; // ecx@17
  int v16; // eax@17
  int v17; // eax@34
  int j; // eax@35
  int i; // eax@38
  int v20; // ecx@43
  void *v21; // [sp+10h] [bp-3Ch]@8
  int v22; // [sp+20h] [bp-2Ch]@8
  unsigned int v23; // [sp+24h] [bp-28h]@8
  unsigned int v24; // [sp+28h] [bp-24h]@3
  unsigned int v25; // [sp+2Ch] [bp-20h]@3
  int v26; // [sp+30h] [bp-1Ch]@3
  int v27; // [sp+34h] [bp-18h]@1
  int v28; // [sp+38h] [bp-14h]@10
  int v29; // [sp+48h] [bp-4h]@3

  v2 = this;
  v3 = *((_BYTE *)this + 8) == 0;
  v27 = 0;
  if ( v3 )
  {
    result = a2;
    *(_DWORD *)a2 = 0;
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)(a2 + 8) = 0;
  }
  else
  {
    v6 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v29 = 0;
    v5 = *(_DWORD *)(*(_DWORD *)this + 4);
    if ( v5 )
    {
      if ( v5 > 0xAAAAAAA )
        sub_10029585((int)"vector<T> too long");
      loc_10013A40(&v24, v5);
      v6 = v25;
    }
    v7 = **(_DWORD **)v2;
    v8 = *(_DWORD *)v7;
    while ( v8 != v7 )
    {
      v9 = *(_DWORD *)(v8 + 16);
      v23 = 15;
      v22 = 0;
      LOBYTE(v21) = 0;
      if ( *(_BYTE *)v9 )
      {
        v11 = v9;
        v28 = v9 + 1;
        do
          v12 = *(_BYTE *)v11++;
        while ( v12 );
        v10 = v11 - v28;
      }
      else
      {
        v10 = 0;
      }
      loc_1000AEB0(&v21, v9, v10);
      LOBYTE(v29) = 1;
      if ( (unsigned int)&v21 >= v6 || (v13 = (int *)&v21, v24 > (unsigned int)&v21) )
      {
        if ( v6 == v26 )
        {
          loc_10013AE0(&v24, v13);
          v6 = v25;
        }
        if ( v6 )
        {
          *(_DWORD *)(v6 + 20) = 15;
          *(_DWORD *)(v6 + 16) = 0;
          *(_BYTE *)v6 = 0;
          if ( v23 >= 0x10 )
          {
            *(_DWORD *)v6 = v21;
            v21 = 0;
          }
          else
          {
            if ( v22 != -1 )
              sub_1002A4B0((void *)v6, &v21, v22 + 1);
          }
          *(_DWORD *)(v6 + 16) = v22;
          *(_DWORD *)(v6 + 20) = v23;
          v23 = 15;
          v22 = 0;
          LOBYTE(v21) = 0;
        }
      }
      else
      {
        v14 = (signed int)((char *)&v21 - v24) / 24;
        v28 = (signed int)((char *)&v21 - v24) / 24;
        if ( v6 == v26 )
        {
          loc_10013AE0(
            &v24,
            (signed int)((unsigned __int64)(715827883i64 * (signed int)((char *)&v21 - v24)) >> 32) >> 2,
            (char *)&v21 - v24);
          v6 = v25;
          v14 = v28;
        }
        v16 = 3 * v14;
        v15 = v24 + 8 * v16;
        v28 = v24 + 8 * v16;
        if ( v6 )
        {
          *(_DWORD *)(v6 + 20) = 15;
          *(_DWORD *)(v6 + 16) = 0;
          *(_BYTE *)v6 = 0;
          if ( *(_DWORD *)(v15 + 20) >= 0x10u )
          {
            *(_DWORD *)v6 = *(_DWORD *)v15;
            *(_DWORD *)v15 = 0;
          }
          else
          {
            if ( *(_DWORD *)(v15 + 16) != -1 )
            {
              sub_1002A4B0((void *)v6, (const void *)v15, *(_DWORD *)(v15 + 16) + 1);
              v15 = v28;
            }
          }
          *(_DWORD *)(v6 + 16) = *(_DWORD *)(v15 + 16);
          *(_DWORD *)(v6 + 20) = *(_DWORD *)(v15 + 20);
          *(_DWORD *)(v15 + 20) = 15;
          *(_DWORD *)(v15 + 16) = 0;
          *(_BYTE *)v15 = 0;
        }
      }
      v6 += 24;
      LOBYTE(v29) = 0;
      v25 = v6;
      if ( v23 >= 0x10 )
        sub_1002A4AA(v21);
      if ( !*(_BYTE *)(v8 + 13) )
      {
        v17 = *(_DWORD *)(v8 + 8);
        if ( *(_BYTE *)(v17 + 13) )
        {
          for ( i = *(_DWORD *)(v8 + 4); !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 4) )
          {
            if ( v8 != *(_DWORD *)(i + 8) )
              break;
            v8 = i;
          }
          v8 = i;
        }
        else
        {
          v8 = *(_DWORD *)(v8 + 8);
          for ( j = *(_DWORD *)v17; !*(_BYTE *)(j + 13); j = *(_DWORD *)j )
            v8 = j;
        }
      }
    }
    result = a2;
    *(_DWORD *)a2 = v24;
    v20 = v26;
    *(_DWORD *)(a2 + 4) = v6;
    *(_DWORD *)(a2 + 8) = v20;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10011140) --------------------------------------------------------
int __userpurge sub_10011140<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@4
  int v8; // edi@5

  v5 = a2;
  v6 = a4;
  if ( *(_DWORD *)(a4 + 20) >= 0x10u )
    v6 = *(_DWORD *)a4;
  if ( !*(_DWORD *)(a2 + 12) )
  {
    v7 = sub_1002965B(a1, a2, a2, a3, 16);
    if ( v7 )
    {
      v8 = v7 + 4;
      *(_DWORD *)v7 = 3;
      sub_100309DA(v7 + 4, 4, 3, (void (__thiscall *)(_DWORD))sub_100099D0, (int)sub_1000FF60);
    }
    else
    {
      v8 = 0;
    }
    *(_DWORD *)(v5 + 12) = v8;
  }
  return loc_1000FF70(v6);
}
// 1000FF60: using guessed type int sub_1000FF60();

//----- (100111E0) --------------------------------------------------------
void *__thiscall sub_100111E0(void *this, int a2, unsigned int a3)
{
  int v3; // edx@1
  int v4; // edi@1
  char *v5; // esi@6
  char v6; // al@7
  unsigned __int64 v7; // ST00_8@7
  __int64 v8; // qax@7
  unsigned int v9; // eax@11
  void *v11; // [sp+10h] [bp-2Ch]@1
  int v12; // [sp+14h] [bp-28h]@1
  char v13; // [sp+1Bh] [bp-21h]@4
  char v14; // [sp+34h] [bp-8h]@6
  unsigned int v15; // [sp+38h] [bp-4h]@1
  int v16; // [sp+3Ch] [bp+0h]@1

  v15 = (unsigned int)&v16 ^ __security_cookie;
  v3 = a2;
  v4 = a3;
  v11 = this;
  LOBYTE(v12) = a2;
  if ( (signed int)a3 <= 0 && (signed int)a3 < 0 )
  {
    v3 = -a2;
    v13 = 1;
    v12 = -a2;
    v4 = (unsigned __int64)-__PAIR__(a3, -a2) >> 32;
  }
  else
  {
    v13 = 0;
  }
  v5 = &v14;
  v14 = 0;
  do
  {
    HIDWORD(v7) = v4;
    LODWORD(v7) = v3;
    --v5;
    v8 = sub_10039A80(v7, 0xAu, 0);
    v4 = HIDWORD(v8);
    *v5 = (_BYTE)v12 - 10 * v8 + 48;
    v3 = v8;
    v6 = v4 | v8;
    LOBYTE(v12) = v3;
  }
  while ( v4 | v3 );
  if ( v13 != v6 )
  {
    --v5;
    *v5 = 45;
  }
  *((_DWORD *)v11 + 5) = 15;
  *((_DWORD *)v11 + 4) = 0;
  *(_BYTE *)v11 = 0;
  if ( *v5 )
    v9 = strlen(v5);
  else
    v9 = 0;
  loc_1000AEB0(v11, v5, v9);
  return v11;
}
// 10074200: using guessed type int __security_cookie;

//----- (100112C0) --------------------------------------------------------
void *__thiscall sub_100112C0(void *this, int a2, int a3)
{
  int v3; // edx@1
  int v4; // edi@1
  char *v5; // esi@1
  unsigned int v6; // eax@2
  unsigned __int64 v7; // ST00_8@2
  __int64 v8; // qax@2
  void *v10; // [sp+10h] [bp-28h]@1
  char v11; // [sp+14h] [bp-24h]@1
  char v12; // [sp+30h] [bp-8h]@1
  unsigned int v13; // [sp+34h] [bp-4h]@1
  int v14; // [sp+38h] [bp+0h]@1

  v13 = (unsigned int)&v14 ^ __security_cookie;
  v3 = a2;
  v4 = a3;
  v10 = this;
  v11 = a2;
  v5 = &v12;
  v12 = 0;
  do
  {
    HIDWORD(v7) = v4;
    LODWORD(v7) = v3;
    --v5;
    v8 = sub_10039A80(v7, 0xAu, 0);
    v4 = HIDWORD(v8);
    *v5 = v11 - 10 * v8 + 48;
    v3 = v8;
    v6 = v4 | v8;
    v11 = v3;
  }
  while ( v4 | v3 );
  *((_DWORD *)v10 + 5) = 15;
  *((_DWORD *)v10 + 4) = v6;
  *(_BYTE *)v10 = v6;
  if ( *v5 != (_BYTE)v6 )
    v6 = strlen(v5);
  loc_1000AEB0(v10, v5, v6);
  return v10;
}
// 10074200: using guessed type int __security_cookie;

//----- (10011360) --------------------------------------------------------
int __usercall sub_10011360<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  char *v3; // ecx@1
  int v4; // esi@1
  __int64 v6; // ST0C_8@1
  char v7; // al@2
  char *v8; // eax@3
  char *v9; // edx@5
  char *v10; // ecx@5
  char v11; // al@6
  char *v12; // edx@11
  int v13; // ecx@16
  char v14; // al@19
  char v15; // al@23
  char v16; // al@26
  int v18; // [sp+10h] [bp-28h]@3
  char v19; // [sp+14h] [bp-24h]@1
  char v20; // [sp+15h] [bp-23h]@3
  unsigned int v21; // [sp+34h] [bp-4h]@1
  int v22; // [sp+38h] [bp+0h]@1

  v21 = (unsigned int)&v22 ^ __security_cookie;
  __asm
  {
    movapd  xmm0, xmm1
    movsd   [esp+38h+var_38], xmm0
  }
  v4 = a1;
  sub_100308F4(a2, a3, (int)&v19, 0x20u, (int)"%#.16g", v6);
  v3 = &v19;
  do
    v7 = *v3++;
  while ( v7 );
  v8 = (char *)&v18 + v3 - &v20 + 3;
  if ( *v8 == 48 )
  {
    for ( ; v8 > &v19; --v8 )
    {
      if ( *v8 != 48 )
        break;
    }
    v12 = v8;
    if ( v8 >= &v19 )
    {
      while ( *v8 != 46 )
      {
        if ( (unsigned __int8)(*v8 - 48) > 9u )
        {
          *(_DWORD *)(v4 + 20) = 15;
          *(_DWORD *)(v4 + 16) = 0;
          *(_BYTE *)v4 = 0;
          if ( !v19 )
            goto LABEL_16;
          v10 = &v19;
          v9 = &v20;
          do
            v14 = *v10++;
          while ( v14 );
          goto LABEL_27;
        }
        --v8;
        if ( v8 < &v19 )
          goto LABEL_15;
      }
      v12[2] = 0;
      *(_DWORD *)(v4 + 20) = 15;
      *(_DWORD *)(v4 + 16) = 0;
      *(_BYTE *)v4 = 0;
      if ( !v19 )
        goto LABEL_16;
      v10 = &v19;
      v9 = &v20;
      do
        v15 = *v10++;
      while ( v15 );
      goto LABEL_27;
    }
LABEL_15:
    *(_DWORD *)(v4 + 20) = 15;
    *(_DWORD *)(v4 + 16) = 0;
    *(_BYTE *)v4 = 0;
    if ( v19 )
    {
      v10 = &v19;
      v9 = &v20;
      do
        v16 = *v10++;
      while ( v16 );
      goto LABEL_27;
    }
  }
  else
  {
    *(_DWORD *)(v4 + 20) = 15;
    *(_DWORD *)(v4 + 16) = 0;
    *(_BYTE *)v4 = 0;
    if ( v19 )
    {
      v10 = &v19;
      v9 = &v20;
      do
        v11 = *v10++;
      while ( v11 );
LABEL_27:
      v13 = v10 - v9;
      goto LABEL_28;
    }
  }
LABEL_16:
  v13 = 0;
LABEL_28:
  loc_1000AEB0(v4, &v19, v13);
  return v4;
}
// 10074200: using guessed type int __security_cookie;

//----- (100114C0) --------------------------------------------------------
int __fastcall sub_100114C0(int a1, char a2)
{
  const char *v2; // edi@1
  int v3; // esi@1
  int result; // eax@4

  v3 = a1;
  v2 = "true";
  if ( !a2 )
    v2 = "false";
  *(_DWORD *)(a1 + 20) = 15;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)a1 = 0;
  if ( *v2 )
  {
    loc_1000AEB0(a1, v2, strlen(v2));
    result = v3;
  }
  else
  {
    loc_1000AEB0(v2, 0);
    result = v3;
  }
  return result;
}

//----- (10011530) --------------------------------------------------------
int __fastcall sub_10011530(int a1, int a2)
{
  int v2; // ebx@1
  const char *v3; // edi@1
  int v4; // eax@1
  const char *v5; // ecx@2
  char v6; // cf@3
  int v7; // eax@5
  unsigned int v8; // ecx@9
  int *v9; // eax@11
  int v10; // ecx@14
  int v11; // esi@24
  int v12; // edx@24
  int v13; // ST08_4@24
  int v14; // ecx@25
  int v15; // eax@28
  int v16; // eax@30
  int v17; // eax@30
  int v18; // ecx@35
  int v20; // [sp-8h] [bp-10Ch]@14
  unsigned int v21; // [sp-4h] [bp-108h]@1
  void *v22; // [sp+14h] [bp-F0h]@5
  char v23; // [sp+1Ch] [bp-E8h]@30
  int v24; // [sp+24h] [bp-E0h]@5
  unsigned int v25; // [sp+28h] [bp-DCh]@5
  void *v26; // [sp+2Ch] [bp-D8h]@5
  int v27; // [sp+3Ch] [bp-C8h]@7
  unsigned int v28; // [sp+40h] [bp-C4h]@5
  int v29; // [sp+44h] [bp-C0h]@24
  char v30; // [sp+48h] [bp-BCh]@32
  int (__stdcall **v31)(char); // [sp+94h] [bp-70h]@32
  int *v32; // [sp+DCh] [bp-28h]@9
  int v33; // [sp+ECh] [bp-18h]@9
  unsigned int v34; // [sp+F0h] [bp-14h]@9
  unsigned int v35; // [sp+F4h] [bp-10h]@1
  int v36; // [sp+100h] [bp-4h]@5
  int v37; // [sp+104h] [bp+0h]@1

  v35 = (unsigned int)&v37 ^ __security_cookie;
  v21 = (unsigned int)&v37 ^ __security_cookie;
  v3 = (const char *)a2;
  v2 = a1;
  LOBYTE(v4) = sub_10030B80(a2, (int)&unk_100688B8);
  if ( !v4 )
  {
    v5 = v3;
    if ( !*v3 )
    {
LABEL_5:
      v25 = 15;
      v24 = 0;
      LOBYTE(v22) = 0;
      loc_1000AEB0(&v22, &unk_100688C0, 1, v21);
      v36 = 0;
      v7 = sub_10015660((int)&v26, (int)&v22, v3);
      LOBYTE(v36) = 1;
      sub_10015660(v2, v7, (const char *)&unk_100688C0);
      if ( v28 >= 0x10 )
        sub_1002A4AA(v26);
      v28 = 15;
      v27 = 0;
      LOBYTE(v26) = 0;
      if ( v25 >= 0x10 )
        sub_1002A4AA(v22);
      return v2;
    }
    while ( 1 )
    {
      v6 = (unsigned __int8)(*v5++ - 1) > 0x1Eu;
      if ( 1 != v6 )
        break;
      if ( !*v5 )
        goto LABEL_5;
    }
  }
  v34 = 15;
  v8 = 2 * strlen(v3) + 3;
  v33 = 0;
  LOBYTE(v32) = 0;
  v36 = 2;
  if ( v8 != 15 )
  {
    if ( (unsigned __int8)loc_1000ADF0(&v32, v8, 1) )
    {
      v9 = (int *)&v32;
      if ( v34 >= 0x10 )
        v9 = v32;
      v33 = 0;
      *(_BYTE *)v9 = 0;
    }
  }
  loc_10014700(&v32, &unk_100688C0, 1, v21);
  for ( ; *v3; ++v3 )
  {
    LOBYTE(v10) = *v3;
    switch ( *v3 )
    {
      case 34:
        loc_10014700(&v32, &unk_100688C4, 2);
        break;
      case 92:
        loc_10014700(&v32, &unk_100688C8, 2);
        break;
      case 8:
        loc_10014700(&v32, &unk_100688CC, 2);
        break;
      case 12:
        loc_10014700(&v32, &unk_100688D0, 2);
        break;
      case 10:
        loc_10014700(&v32, &unk_100688D4, 2);
        break;
      case 13:
        loc_10014700(&v32, &unk_100688D8, 2);
        break;
      case 9:
        loc_10014700(&v32, &unk_100688DC, 2);
        break;
      default:
        if ( (unsigned __int8)(v10 - 1) > 0x1Eu )
        {
          loc_10012FA0(&v32, 1, v10);
        }
        else
        {
          sub_10011A40((int)&v29, v10);
          sub_100127A0(v12, (int)&v29, v2, v20, v13);
          LOBYTE(v36) = 3;
          v11 = sub_10015700(&v29);
          if ( v11 )
            v14 = v11 + *(_DWORD *)(*(_DWORD *)v11 + 4);
          else
            v14 = 0;
          *(_DWORD *)(v14 + 20) = *(_DWORD *)(v14 + 20) & 0xFFFFF9FF | 0x800;
          if ( v11 )
            v15 = v11 + *(_DWORD *)(*(_DWORD *)v11 + 4);
          else
            v15 = 0;
          *(_DWORD *)(v15 + 20) |= 4u;
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)v11 + 4) + v11 + 64) = 48;
          v16 = sub_10029664((int)&v23, 4, 0);
          (*(void (__cdecl **)(int, _DWORD, _DWORD))v16)(
            v11 + *(_DWORD *)(*(_DWORD *)v11 + 4),
            *(_DWORD *)(v16 + 8),
            *(_DWORD *)(v16 + 12));
          sub_10012050(*v3);
          v17 = sub_10012870(&v29, (int)&v26);
          LOBYTE(v36) = 4;
          loc_10014600(&v32, v17, 0, -1);
          if ( v28 >= 0x10 )
            sub_1002A4AA(v26);
          LOBYTE(v36) = 2;
          v28 = 15;
          v27 = 0;
          LOBYTE(v26) = 0;
          *(int *)((char *)&v29 + *(_DWORD *)(v29 + 4)) = (int)off_100689E4;
          *(unsigned int *)((char *)&v28 + *(_DWORD *)(v29 + 4)) = *(_DWORD *)(v29 + 4) - 80;
          sub_10012890((int)&v30);
          *(int *)((char *)&v29 + *(_DWORD *)(v29 + 4)) = (int)off_100689F0;
          *(unsigned int *)((char *)&v28 + *(_DWORD *)(v29 + 4)) = *(_DWORD *)(v29 + 4) - 8;
          v31 = &off_100683D0;
          sub_100296B7((int)&v31);
        }
        break;
    }
  }
  loc_10014700(&v32, &unk_100688C0, 1);
  *(_DWORD *)(v2 + 20) = 15;
  *(_DWORD *)(v2 + 16) = 0;
  *(_BYTE *)v2 = 0;
  v18 = v34;
  if ( v34 >= 0x10 )
  {
    *(_DWORD *)v2 = v32;
  }
  else
  {
    if ( v33 != -1 )
    {
      sub_1002A4B0((void *)v2, &v32, v33 + 1);
      v18 = v34;
    }
  }
  *(_DWORD *)(v2 + 16) = v33;
  *(_DWORD *)(v2 + 20) = v18;
  return v2;
}
// 10012050: using guessed type _DWORD __stdcall sub_10012050(_DWORD);
// 10015700: using guessed type int __thiscall sub_10015700(_DWORD);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100683D0: using guessed type int (__stdcall *off_100683D0)(char);
// 100689E4: using guessed type int (*off_100689E4[6])();
// 100689F0: using guessed type int (*off_100689F0[3])();
// 10074200: using guessed type int __security_cookie;

//----- (10011A40) --------------------------------------------------------
void __thiscall sub_10011A40(int this, int a2)
{
  *(_DWORD *)this = &unk_100683BC;
  *(_DWORD *)(this + 120) = 0;
  *(_DWORD *)(this + 124) = 0;
  *(_DWORD *)(this + 128) = 0;
  *(_DWORD *)(this + 136) = 0;
  *(_DWORD *)(this + 140) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 52) = 0;
  *(_DWORD *)(this + 56) = 0;
  *(_DWORD *)(this + 60) = 0;
}

//----- (10011AD0) --------------------------------------------------------
void *__thiscall sub_10011AD0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_100683B4;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100683B4: using guessed type int (__stdcall *off_100683B4)(char);

//----- (10011B00) --------------------------------------------------------
int __thiscall sub_10011B00(void *this, int a2, int a3)
{
  int v4; // esi@1
  int v5; // edi@1

  v4 = (int)this;
  v5 = (int)((char *)this + 4);
  loc_1000AEB0((char *)this + 4, &unk_1006823C, 0);
  sub_10011B70(v4, v5, a3);
  loc_10014700(v5, &unk_1006846C, 1);
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  loc_1000AB40(a2, v5, 0, -1);
  return a2;
}

//----- (10011B70) --------------------------------------------------------
int __userpurge sub_10011B70<eax>(int a1<ecx>, int a2<edi>, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // eax@3
  void *v6; // eax@3
  unsigned int v7; // edx@3
  int v8; // eax@4
  void *v9; // eax@4
  int v10; // edx@4
  int v11; // eax@5
  int v12; // eax@6
  char v13; // al@7
  int v14; // eax@7
  int v15; // edi@8
  int v16; // esi@8
  int v17; // eax@12
  int v18; // eax@13
  int v19; // esi@13
  int v20; // ecx@13
  char v21; // zf@13
  int v22; // eax@18
  int v23; // edi@18
  int i; // esi@18
  int v25; // edx@22
  int v26; // eax@24
  const char *v27; // edx@26
  char v28; // zf@28
  unsigned int v29; // ecx@29
  int v30; // eax@32
  int v31; // eax@35
  int v32; // eax@36
  int v33; // edi@36
  char v34; // zf@36
  void *v35; // esi@40
  int v36; // [sp+1Ch] [bp-C4h]@8
  int v37; // [sp+1Ch] [bp-C4h]@18
  int v38; // [sp+20h] [bp-C0h]@1
  int v39; // [sp+24h] [bp-BCh]@18
  int v40; // [sp+28h] [bp-B8h]@18
  int v41; // [sp+2Ch] [bp-B4h]@18
  int v42; // [sp+30h] [bp-B0h]@13
  int v43; // [sp+34h] [bp-ACh]@13
  int v44; // [sp+38h] [bp-A8h]@8
  char v45; // [sp+3Ch] [bp-A4h]@13
  void *v46; // [sp+40h] [bp-A0h]@24
  int v47; // [sp+50h] [bp-90h]@28
  unsigned int v48; // [sp+54h] [bp-8Ch]@24
  char v49; // [sp+88h] [bp-58h]@6
  char v50; // [sp+B8h] [bp-28h]@7
  int v51; // [sp+DCh] [bp-4h]@6
  char v52; // [sp+11Ch] [bp+3Ch]@3
  char v53; // [sp+134h] [bp+54h]@5
  char v54; // [sp+14Ch] [bp+6Ch]@6
  char v55; // [sp+164h] [bp+84h]@4
  char v56; // [sp+17Ch] [bp+9Ch]@7
  int v57; // [sp+1A0h] [bp+C0h]@3

  v4 = a1;
  v38 = a1;
  result = *(_BYTE *)(a3 + 8);
  switch ( result )
  {
    case 0:
      result = sub_10011FE0("null");
      break;
    case 1:
      v5 = loc_100105E0(a3);
      v6 = sub_100111E0(&v52, v5, v7);
      v57 = 0;
      loc_10014600(v4 + 4, v6, 0, -1);
      result = sub_10001880((int)&v52);
      break;
    case 2:
      v8 = loc_10010720(a3);
      v9 = sub_100112C0(&v55, v8, v10);
      v57 = 1;
      loc_10014600(v4 + 4, v9, 0, -1);
      result = sub_10001880((int)&v55);
      break;
    case 3:
      loc_10010890(a3);
      __asm { movapd  xmm1, xmm0 }
      v11 = sub_10011360((int)&v53, a3, a2);
      v57 = 2;
      loc_10014600(v4 + 4, v11, 0, -1);
      result = sub_10001880((int)&v53);
      break;
    case 4:
      v12 = sub_10011530((int)&v49, *(_DWORD *)a3);
      v51 = 3;
      loc_10014600(v4 + 4, v12, 0, -1);
      result = sub_10001880((int)&v54);
      break;
    case 5:
      v13 = sub_100109A0((void *)a3);
      v14 = sub_100114C0((int)&v50, v13);
      v51 = 4;
      loc_10014600(v4 + 4, v14, 0, -1);
      result = sub_10001880((int)&v56);
      break;
    case 6:
      v16 = a1 + 4;
      v36 = a1 + 4;
      sub_10011FE0("[");
      v15 = 0;
      v44 = sub_10010A20((void *)a3);
      if ( v44 > 0 )
      {
        do
        {
          if ( v15 > 0 )
            loc_10014700(v16, ",", 1);
          if ( *(_BYTE *)(a3 + 8) )
          {
            v19 = *(_DWORD *)a3;
            v20 = *(_DWORD *)a3;
            v42 = 0;
            v43 = v15;
            v18 = *(_DWORD *)sub_100124C0((void *)v20, (int)&v45, (int)&v42);
            v21 = v18 == *(_DWORD *)v19;
            v16 = v36;
            if ( v21 )
              v17 = (int)&unk_10077A30;
            else
              v17 = v18 + 24;
          }
          else
          {
            v17 = (int)&unk_10077A30;
          }
          sub_10011B70(v17);
          ++v15;
        }
        while ( v15 < v44 );
      }
      result = loc_10014700("]");
      break;
    case 7:
      v39 = 0;
      v40 = 0;
      v41 = 0;
      sub_10010EA0((void *)a3, (int)&v39);
      v23 = v4 + 4;
      v51 = 5;
      v37 = v4 + 4;
      sub_10011FE0("{");
      v22 = v39;
      for ( i = v39; i != v40; i += 24 )
      {
        if ( i != v22 )
          loc_10014700(v23, ",", 1);
        if ( *(_DWORD *)(i + 20) < 0x10u )
          v25 = i;
        else
          v25 = *(_DWORD *)i;
        v26 = sub_10011530((int)&v46, v25);
        LOBYTE(v51) = 6;
        loc_10014600(v23, v26, 0, -1);
        LOBYTE(v51) = 5;
        if ( v48 >= 0x10 )
          sub_1002A4AA(v46);
        v27 = ": ";
        if ( !*(_BYTE *)(v38 + 28) )
          v27 = ":";
        v48 = 15;
        v28 = *v27 == 0;
        v47 = 0;
        LOBYTE(v46) = 0;
        if ( v28 )
        {
          v29 = 0;
        }
        else
        {
          v29 = strlen(v27);
          v23 = v37;
        }
        loc_10014700(v23, v27, v29);
        if ( *(_DWORD *)(i + 20) < 0x10u )
          v30 = i;
        else
          v30 = *(_DWORD *)i;
        if ( *(_BYTE *)(a3 + 8) )
        {
          v33 = *(_DWORD *)a3;
          v42 = v30;
          v43 = 0;
          v32 = *(_DWORD *)sub_100124C0((void *)v33, (int)&v45, (int)&v42);
          v34 = v32 == *(_DWORD *)v33;
          v23 = v37;
          if ( v34 )
            v31 = (int)&unk_10077A30;
          else
            v31 = v32 + 24;
        }
        else
        {
          v31 = (int)&unk_10077A30;
        }
        sub_10011B70(v31);
        v22 = v39;
      }
      result = loc_10014700(v23, "}", 1);
      v35 = (void *)v39;
      if ( v39 )
      {
        sub_10018370(v39, v40);
        result = sub_1002A4AA(v35);
      }
      break;
    default:
      return result;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10011FE0) --------------------------------------------------------
int __stdcall sub_10011FE0(const char *a1)
{
  int result; // eax@2

  if ( *a1 )
    result = loc_10014700(a1, strlen(a1));
  else
    result = loc_10014700(a1, 0);
  return result;
}

//----- (10012020) --------------------------------------------------------
int __thiscall sub_10012020(int this, int a2)
{
  int result; // eax@1
  unsigned int v3; // edx@1
  char v4; // cf@2

  v3 = *(_DWORD *)(this + 16);
  result = a2;
  if ( a2 > v3 )
  {
    result = loc_10012FA0(a2 - v3, 0);
  }
  else
  {
    v4 = *(_DWORD *)(this + 20) < 0x10u;
    *(_DWORD *)(this + 16) = a2;
    if ( !v4 )
      this = *(_DWORD *)this;
    *(_BYTE *)(this + a2) = 0;
  }
  return result;
}

//----- (10012050) --------------------------------------------------------
#error "100121F0: positive sp value has been found (funcsize=125)"

//----- (10012200) --------------------------------------------------------
int __thiscall sub_10012200(void *this, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@4
  int v5; // edx@7
  int v6; // esi@8
  int v7; // eax@15
  int i; // edx@17
  int v9; // eax@18
  int v10; // eax@33
  char v11; // cl@36
  int v12; // ecx@37
  int v13; // ecx@40
  int v14; // esi@62
  int v15; // ecx@65
  int result; // eax@67
  int v17; // [sp+18h] [bp-10h]@1

  v3 = (int)this;
  v17 = a3;
  if ( *(_BYTE *)(a3 + 13) )
    sub_100295B3((int)"invalid map/set<T> iterator");
  sub_10013410(&a3);
  if ( *(_BYTE *)(*(_DWORD *)v17 + 13) )
  {
    v4 = *(_DWORD *)(v17 + 8);
  }
  else
  {
    if ( *(_BYTE *)(*(_DWORD *)(v17 + 8) + 13) )
    {
      v4 = *(_DWORD *)v17;
    }
    else
    {
      v5 = a3;
      v4 = *(_DWORD *)(a3 + 8);
      if ( a3 != v17 )
      {
        *(_DWORD *)(*(_DWORD *)v17 + 4) = a3;
        *(_DWORD *)v5 = *(_DWORD *)v17;
        if ( v5 == *(_DWORD *)(v17 + 8) )
        {
          v6 = v5;
        }
        else
        {
          v6 = *(_DWORD *)(v5 + 4);
          if ( !*(_BYTE *)(v4 + 13) )
            *(_DWORD *)(v4 + 4) = v6;
          *(_DWORD *)v6 = v4;
          *(_DWORD *)(v5 + 8) = *(_DWORD *)(v17 + 8);
          *(_DWORD *)(*(_DWORD *)(v17 + 8) + 4) = v5;
        }
        if ( *(_DWORD *)(*(_DWORD *)v3 + 4) == v17 )
        {
          *(_DWORD *)(*(_DWORD *)v3 + 4) = v5;
        }
        else
        {
          v10 = *(_DWORD *)(v17 + 4);
          if ( *(_DWORD *)v10 == v17 )
            *(_DWORD *)v10 = v5;
          else
            *(_DWORD *)(v10 + 8) = v5;
        }
        *(_DWORD *)(v5 + 4) = *(_DWORD *)(v17 + 4);
        v11 = *(_BYTE *)(v5 + 12);
        *(_BYTE *)(v5 + 12) = *(_BYTE *)(v17 + 12);
        *(_BYTE *)(v17 + 12) = v11;
        goto LABEL_37;
      }
    }
  }
  v6 = *(_DWORD *)(v17 + 4);
  if ( !*(_BYTE *)(v4 + 13) )
    *(_DWORD *)(v4 + 4) = v6;
  if ( *(_DWORD *)(*(_DWORD *)v3 + 4) == v17 )
  {
    *(_DWORD *)(*(_DWORD *)v3 + 4) = v4;
  }
  else
  {
    if ( *(_DWORD *)v6 == v17 )
      *(_DWORD *)v6 = v4;
    else
      *(_DWORD *)(v6 + 8) = v4;
  }
  v7 = *(_DWORD *)v3;
  if ( **(_DWORD **)v3 == v17 )
  {
    if ( *(_BYTE *)(v4 + 13) )
    {
      i = v6;
    }
    else
    {
      v9 = *(_DWORD *)v4;
      for ( i = v4; !*(_BYTE *)(v9 + 13); v9 = *(_DWORD *)v9 )
        i = v9;
      v7 = *(_DWORD *)v3;
    }
    *(_DWORD *)v7 = i;
  }
  if ( *(_DWORD *)(*(_DWORD *)v3 + 8) == v17 )
  {
    if ( *(_BYTE *)(v4 + 13) )
      *(_DWORD *)(*(_DWORD *)v3 + 8) = v6;
    else
      *(_DWORD *)(*(_DWORD *)v3 + 8) = sub_100133F0(v4);
  }
LABEL_37:
  v12 = v17;
  if ( *(_BYTE *)(v17 + 12) != 1 )
    goto LABEL_62;
  if ( v4 == *(_DWORD *)(*(_DWORD *)v3 + 4) )
    goto LABEL_61;
  while ( *(_BYTE *)(v4 + 12) == 1 )
  {
    v13 = *(_DWORD *)v6;
    if ( v4 == *(_DWORD *)v6 )
    {
      v13 = *(_DWORD *)(v6 + 8);
      if ( !*(_BYTE *)(v13 + 12) )
      {
        *(_BYTE *)(v13 + 12) = 1;
        *(_BYTE *)(v6 + 12) = 0;
        sub_100132D0((void *)v3, v6);
        v13 = *(_DWORD *)(v6 + 8);
      }
      if ( *(_BYTE *)(v13 + 13) )
        goto LABEL_55;
      if ( *(_BYTE *)(*(_DWORD *)v13 + 12) != 1 || *(_BYTE *)(*(_DWORD *)(v13 + 8) + 12) != 1 )
      {
        if ( *(_BYTE *)(*(_DWORD *)(v13 + 8) + 12) == 1 )
        {
          *(_BYTE *)(*(_DWORD *)v13 + 12) = 1;
          *(_BYTE *)(v13 + 12) = 0;
          sub_10013330((void *)v3, v13);
          v13 = *(_DWORD *)(v6 + 8);
        }
        *(_BYTE *)(v13 + 12) = *(_BYTE *)(v6 + 12);
        *(_BYTE *)(v6 + 12) = 1;
        *(_BYTE *)(*(_DWORD *)(v13 + 8) + 12) = 1;
        sub_100132D0((void *)v3, v6);
        break;
      }
    }
    else
    {
      if ( !*(_BYTE *)(v13 + 12) )
      {
        *(_BYTE *)(v13 + 12) = 1;
        *(_BYTE *)(v6 + 12) = 0;
        sub_10013330((void *)v3, v6);
        v13 = *(_DWORD *)v6;
      }
      if ( *(_BYTE *)(v13 + 13) )
        goto LABEL_55;
      if ( *(_BYTE *)(*(_DWORD *)(v13 + 8) + 12) != 1 || *(_BYTE *)(*(_DWORD *)v13 + 12) != 1 )
      {
        if ( *(_BYTE *)(*(_DWORD *)v13 + 12) == 1 )
        {
          *(_BYTE *)(*(_DWORD *)(v13 + 8) + 12) = 1;
          *(_BYTE *)(v13 + 12) = 0;
          sub_100132D0((void *)v3, v13);
          v13 = *(_DWORD *)v6;
        }
        *(_BYTE *)(v13 + 12) = *(_BYTE *)(v6 + 12);
        *(_BYTE *)(v6 + 12) = 1;
        *(_BYTE *)(*(_DWORD *)v13 + 12) = 1;
        sub_10013330((void *)v3, v6);
        break;
      }
    }
    *(_BYTE *)(v13 + 12) = 0;
LABEL_55:
    v4 = v6;
    v6 = *(_DWORD *)(v6 + 4);
    if ( v4 == *(_DWORD *)(*(_DWORD *)v3 + 4) )
      break;
  }
  v12 = v17;
LABEL_61:
  *(_BYTE *)(v4 + 12) = 1;
LABEL_62:
  v14 = v12 + 16;
  sub_100101D0(v12 + 24, v3);
  if ( *(_DWORD *)v14 )
  {
    if ( *(_DWORD *)(v14 + 4) == 1 )
      sub_100309A2(v3, *(LPVOID *)v14);
  }
  sub_1002A4AA((LPVOID)v17);
  v15 = *(_DWORD *)(v3 + 4);
  if ( v15 )
    *(_DWORD *)(v3 + 4) = v15 - 1;
  result = a2;
  *(_DWORD *)a2 = a3;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100124C0) --------------------------------------------------------
int __thiscall sub_100124C0(void *this, int a2, int a3)
{
  int v3; // eax@1
  int v4; // esi@1
  void *v5; // esi@1
  int v6; // ecx@2
  int v7; // edx@3
  char v8; // bl@6
  int result; // eax@13
  int v11; // [sp+14h] [bp+Ch]@11

  v5 = this;
  v3 = sub_10013250(this, a3);
  v4 = *(_DWORD *)v5;
  if ( v3 == v4 )
    goto LABEL_16;
  v6 = *(_DWORD *)a3;
  if ( *(_DWORD *)a3 )
  {
    v7 = *(_DWORD *)(v3 + 16);
    while ( *(_BYTE *)v6 == *(_BYTE *)v7 )
    {
      if ( !*(_BYTE *)v6 )
        goto LABEL_8;
      v8 = *(_BYTE *)(v6 + 1);
      if ( v8 != *(_BYTE *)(v7 + 1) )
        break;
      v6 += 2;
      v7 += 2;
      if ( !v8 )
      {
LABEL_8:
        __asm { sets    cl }
        goto LABEL_11;
      }
    }
    __asm { sets    cl }
  }
  else
  {
    _CL = *(_DWORD *)(a3 + 4) < *(_DWORD *)(v3 + 20);
  }
LABEL_11:
  v11 = v3;
  if ( _CL )
LABEL_16:
    v11 = v4;
  result = a2;
  *(_DWORD *)a2 = v11;
  return result;
}

//----- (100126C0) --------------------------------------------------------
int __fastcall sub_100126C0(int a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // ecx@3
  int v5; // ebx@3
  int v6; // eax@3
  int v7; // ecx@3
  int v8; // ecx@4
  int result; // eax@7

  v3 = a1;
  if ( *(_DWORD *)(a1 + 8) <= (unsigned int)(*(_DWORD *)(a1 + 16) + 1) )
    loc_100138D0(a1);
  v6 = *(_DWORD *)(v3 + 16);
  v7 = *(_DWORD *)(v3 + 8) - 1;
  *(_DWORD *)(v3 + 12) &= v7;
  v4 = (*(_DWORD *)(v3 + 12) + v6) & v7;
  v5 = 4 * v4;
  if ( !*(_DWORD *)(4 * v4 + *(_DWORD *)(v3 + 4)) )
  {
    v8 = sub_1002ADB1(a2, v4, v5, v3, 40);
    if ( !v8 )
      sub_10029530();
    *(_DWORD *)(v5 + *(_DWORD *)(v3 + 4)) = v8;
  }
  result = *(_DWORD *)(v3 + 4);
  _EBX = *(_DWORD *)(v5 + result);
  if ( _EBX )
  {
    _ESI = a3;
    __asm
    {
      movq    xmm0, qword ptr [esi]
      movq    qword ptr [ebx], xmm0
    }
    *(_DWORD *)(_EBX + 8) = *(_DWORD *)(a3 + 8);
    *(_DWORD *)(_EBX + 32) = 15;
    *(_DWORD *)(_EBX + 28) = 0;
    *(_BYTE *)(_EBX + 12) = 0;
    loc_1000AB40(a3 + 12, 0, -1);
    result = *(_DWORD *)(a3 + 36);
    *(_DWORD *)(_EBX + 36) = result;
  }
  ++*(_DWORD *)(v3 + 16);
  return result;
}

//----- (100127A0) --------------------------------------------------------
int __userpurge sub_100127A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5)
{
  int ebp0; // ebp@0
  int v7; // edi@1
  int v8; // esi@1
  int v9; // ST04_4@1
  int v10; // edx@1

  v7 = a2;
  *(_DWORD *)a2 = &unk_100683BC;
  *(_DWORD *)(a2 + 80) = &off_100683C4;
  v8 = a2 + 4;
  *(_DWORD *)(a2 + *(_DWORD *)(*(_DWORD *)a2 + 4)) = off_100689F0;
  v9 = *(_DWORD *)(*(_DWORD *)a2 + 4);
  *(_DWORD *)(v9 + a2 - 4) = v9 - 8;
  sub_10017C90(a1, v7 + *(_DWORD *)(*(_DWORD *)a2 + 4), a3, v7, a2 + 4, v9);
  *(_DWORD *)(v7 + *(_DWORD *)(*(_DWORD *)v7 + 4)) = off_100689E4;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v7 + 4) + v7 - 4) = *(_DWORD *)(*(_DWORD *)v7 + 4) - 80;
  sub_10014830(v10, v8, a3, ebp0, v7);
  *(_DWORD *)v8 = &off_100689A8;
  *(_DWORD *)(v8 + 56) = 0;
  *(_DWORD *)(v8 + 60) = 4;
  return v7;
}
// 100683C4: using guessed type int (__stdcall *off_100683C4)(char);
// 100689A8: using guessed type int (__stdcall *off_100689A8)(char);
// 100689E4: using guessed type int (*off_100689E4[6])();
// 100689F0: using guessed type int (*off_100689F0[3])();

//----- (10012870) --------------------------------------------------------
int __thiscall sub_10012870(void *this, int a2)
{
  sub_10013B80((int)((char *)this + 4), a2);
  return a2;
}

//----- (10012890) --------------------------------------------------------
int __thiscall sub_10012890(int this)
{
  int v1; // esi@1
  char v2; // zf@1
  int result; // eax@3
  void *v4; // esi@3
  int v5; // eax@5

  v1 = this;
  v2 = (*(_BYTE *)(this + 60) & 1) == 0;
  *(_DWORD *)this = &off_100689A8;
  if ( !v2 )
    sub_1002A4AA(**(LPVOID **)(this + 12));
  **(_DWORD **)(v1 + 12) = 0;
  **(_DWORD **)(v1 + 28) = 0;
  **(_DWORD **)(v1 + 44) = 0;
  **(_DWORD **)(v1 + 16) = 0;
  **(_DWORD **)(v1 + 32) = 0;
  result = *(_DWORD *)(v1 + 48);
  *(_DWORD *)result = 0;
  *(_DWORD *)(v1 + 60) &= 0xFFFFFFFEu;
  *(_DWORD *)(v1 + 56) = 0;
  *(_DWORD *)v1 = &off_1006896C;
  v4 = *(void **)(v1 + 52);
  if ( v4 )
  {
    if ( *(_DWORD *)v4 )
    {
      v5 = (*(int (**)(void))(**(_DWORD **)v4 + 8))();
      if ( v5 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v5)(v5, 1);
    }
    result = sub_1002A4AA(v4);
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1006896C: using guessed type int (__stdcall *off_1006896C)(char);
// 100689A8: using guessed type int (__stdcall *off_100689A8)(char);

//----- (10012B20) --------------------------------------------------------
signed int __thiscall sub_10012B20(int this, signed int a2)
{
  unsigned int v2; // esi@1
  signed int result; // eax@7

  v2 = **(_DWORD **)(this + 28);
  if ( !v2 || v2 <= **(_DWORD **)(this + 12) || a2 != -1 && (_BYTE)a2 != *(_BYTE *)(v2 - 1) && *(_BYTE *)(this + 60) & 2 )
  {
    result = -1;
  }
  else
  {
    ++**(_DWORD **)(this + 44);
    --**(_DWORD **)(this + 28);
    if ( a2 == -1 )
    {
      result = 0;
    }
    else
    {
      ***(_BYTE ***)(this + 28) = a2;
      result = a2;
    }
  }
  return result;
}

//----- (10012B80) --------------------------------------------------------
signed int __thiscall sub_10012B80(int this)
{
  unsigned int v1; // edx@1
  unsigned int *v2; // esi@1
  signed int result; // eax@2
  int v4; // edi@3
  unsigned int v5; // eax@6

  v2 = *(unsigned int **)(this + 28);
  v1 = *v2;
  if ( *v2 )
  {
    v4 = *(_DWORD *)(this + 44);
    if ( v1 >= v1 + *(_DWORD *)v4 )
    {
      if ( *(_BYTE *)(this + 60) & 4 || (v5 = **(_DWORD **)(this + 32), !v5) || v5 <= v1 && *(_DWORD *)(this + 56) <= v1 )
      {
        result = -1;
      }
      else
      {
        if ( *(_DWORD *)(this + 56) < v5 )
          *(_DWORD *)(this + 56) = v5;
        *(_DWORD *)v4 = *(_DWORD *)(this + 56) - *v2;
        result = ***(_BYTE ***)(this + 28);
      }
    }
    else
    {
      result = *(_BYTE *)v1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10012BE0) --------------------------------------------------------
int __thiscall sub_10012BE0(int this, int a2, __int64 a3, int a4, char a5)
{
  unsigned int v5; // eax@1
  unsigned int *v6; // edx@1
  int v7; // ebx@1
  int v8; // esi@5
  int v9; // edi@7
  int v10; // esi@7
  __int64 v11; // qax@7
  int v12; // eax@10
  __int64 v13; // qax@15
  int v14; // ecx@15
  int v15; // ecx@18
  int v16; // edx@20
  int v17; // ecx@20
  unsigned int v18; // edx@22
  __int64 v19; // qax@24
  __int64 v20; // qax@26
  __int64 v21; // qax@31
  int v22; // ecx@31
  int v23; // ecx@34
  int result; // eax@37
  int v25; // [sp+Ch] [bp-4h]@5
  int v26; // [sp+28h] [bp+18h]@19
  unsigned int v27; // [sp+28h] [bp+18h]@22

  v7 = this;
  v6 = *(unsigned int **)(this + 32);
  v5 = *v6;
  if ( *v6 )
  {
    if ( *(_DWORD *)(this + 56) < v5 )
      *(_DWORD *)(this + 56) = v5;
  }
  if ( !(a5 & 1) || (v8 = **(_DWORD **)(this + 28), v25 = v8, !v8) )
  {
    if ( a5 & 2 && (v18 = *v6, v27 = v18, v18) )
    {
      if ( a4 == 2 )
      {
        v19 = *(_DWORD *)(this + 56) - **(_DWORD **)(this + 12);
        v10 = v19 + a3;
        v9 = (unsigned __int64)(v19 + a3) >> 32;
      }
      else
      {
        if ( a4 == 1 )
        {
          v20 = (signed int)(v18 - **(_DWORD **)(this + 12));
          v10 = v20 + a3;
          v9 = (unsigned __int64)(v20 + a3) >> 32;
        }
        else
        {
          if ( a4 )
          {
            v10 = dword_10061658;
            v9 = dword_1006165C;
          }
          else
          {
            v9 = HIDWORD(a3);
            v10 = a3;
          }
        }
      }
      if ( v9 >= 0 )
      {
        v22 = **(_DWORD **)(this + 12);
        v21 = *(_DWORD *)(v7 + 56) - v22;
        if ( v9 <= HIDWORD(v21) )
        {
          if ( v9 < HIDWORD(v21) || (unsigned int)v10 <= (_DWORD)v21 )
          {
            v23 = v10 + v22 - v27;
            **(_DWORD **)(v7 + 48) -= v23;
            **(_DWORD **)(v7 + 32) += v23;
            goto LABEL_37;
          }
        }
      }
    }
    else
    {
      v10 = a3;
      v9 = HIDWORD(a3);
      if ( !a3 )
        goto LABEL_37;
    }
LABEL_36:
    v10 = dword_10061658;
    v9 = dword_1006165C;
    goto LABEL_37;
  }
  if ( a4 != 2 )
  {
    if ( a4 == 1 )
    {
      if ( !(a5 & 2) )
      {
        v12 = v8 - **(_DWORD **)(this + 12);
        v10 = v12 + a3;
        v9 = (unsigned __int64)(v12 + a3) >> 32;
        goto LABEL_14;
      }
    }
    else
    {
      if ( !a4 )
      {
        v9 = HIDWORD(a3);
        v10 = a3;
        goto LABEL_14;
      }
    }
    v10 = dword_10061658;
    v9 = dword_1006165C;
    goto LABEL_14;
  }
  v11 = *(_DWORD *)(this + 56) - **(_DWORD **)(this + 12);
  v10 = v11 + a3;
  v9 = (unsigned __int64)(v11 + a3) >> 32;
LABEL_14:
  if ( v9 < 0
    || (v14 = **(_DWORD **)(this + 12), v13 = *(_DWORD *)(v7 + 56) - v14, v9 > HIDWORD(v13))
    || v9 >= HIDWORD(v13) && (unsigned int)v10 > (_DWORD)v13 )
    goto LABEL_36;
  v15 = v10 + v14 - v25;
  **(_DWORD **)(v7 + 44) -= v15;
  **(_DWORD **)(v7 + 28) += v15;
  if ( a5 & 2 )
  {
    v26 = **(_DWORD **)(v7 + 32);
    if ( v26 )
    {
      v16 = **(_DWORD **)(v7 + 28);
      v17 = v26 + **(_DWORD **)(v7 + 48);
      **(_DWORD **)(v7 + 32) = v16;
      **(_DWORD **)(v7 + 48) = v17 - v16;
    }
  }
LABEL_37:
  result = a2;
  *(_DWORD *)(a2 + 4) = v9;
  *(_DWORD *)a2 = v10;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  return result;
}
// 10061658: using guessed type int dword_10061658;
// 1006165C: using guessed type int dword_1006165C;

//----- (10012DB0) --------------------------------------------------------
int __thiscall sub_10012DB0(int this, int a2, __int64 a3, __int64 a4, int a5, int a6, char a7)
{
  unsigned int v7; // eax@1
  unsigned int *v8; // edx@1
  int v9; // ebx@1
  int v10; // edi@1
  int v11; // esi@1
  int v12; // eax@4
  __int64 v13; // qax@9
  int v14; // ecx@9
  int v15; // ecx@12
  int v16; // edx@14
  int v17; // ecx@14
  __int64 v18; // qax@20
  int v19; // ecx@20
  int v20; // ecx@23
  int result; // eax@26
  int v22; // [sp+Ch] [bp-Ch]@7
  int v23; // [sp+Ch] [bp-Ch]@13

  v11 = a4 + a3;
  v9 = (unsigned __int64)(a4 + a3) >> 32;
  v10 = this;
  v8 = *(unsigned int **)(this + 32);
  v7 = *v8;
  if ( *v8 )
  {
    if ( *(_DWORD *)(this + 56) < v7 )
      *(_DWORD *)(this + 56) = v7;
  }
  v12 = dword_1006165C;
  if ( v11 != dword_10061658 || v9 != dword_1006165C )
  {
    if ( a7 & 1 )
    {
      v22 = **(_DWORD **)(this + 28);
      if ( v22 )
      {
        if ( v9 >= 0 )
        {
          v14 = **(_DWORD **)(this + 12);
          v13 = *(_DWORD *)(v10 + 56) - v14;
          if ( v9 <= HIDWORD(v13) )
          {
            if ( v9 < HIDWORD(v13) || (unsigned int)v11 <= (_DWORD)v13 )
            {
              v15 = v11 + v14 - v22;
              **(_DWORD **)(v10 + 44) -= v15;
              **(_DWORD **)(v10 + 28) += v15;
              if ( a7 & 2 )
              {
                v23 = **(_DWORD **)(v10 + 32);
                if ( v23 )
                {
                  v16 = **(_DWORD **)(v10 + 28);
                  v17 = v23 + **(_DWORD **)(v10 + 48);
                  **(_DWORD **)(v10 + 32) = v16;
                  **(_DWORD **)(v10 + 48) = v17 - v16;
                }
              }
              goto LABEL_26;
            }
          }
        }
        goto LABEL_15;
      }
      v12 = dword_1006165C;
    }
    if ( !(a7 & 2) || !*v8 )
    {
      v9 = v12;
      goto LABEL_25;
    }
    if ( v9 >= 0 )
    {
      v19 = **(_DWORD **)(this + 12);
      v18 = *(_DWORD *)(v10 + 56) - v19;
      if ( v9 <= HIDWORD(v18) )
      {
        if ( v9 < HIDWORD(v18) || (unsigned int)v11 <= (_DWORD)v18 )
        {
          v20 = v11 + v19 - **(_DWORD **)(v10 + 32);
          **(_DWORD **)(v10 + 48) -= v20;
          **(_DWORD **)(v10 + 32) += v20;
          goto LABEL_26;
        }
      }
    }
LABEL_15:
    v9 = dword_1006165C;
LABEL_25:
    v11 = dword_10061658;
  }
LABEL_26:
  result = a2;
  *(_DWORD *)a2 = v11;
  *(_DWORD *)(a2 + 4) = v9;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  return result;
}
// 10061658: using guessed type int dword_10061658;
// 1006165C: using guessed type int dword_1006165C;

//----- (10012F00) --------------------------------------------------------
void *__thiscall sub_10012F00(void *this, char a2)
{
  void *v2; // edi@1
  int v3; // esi@1

  v2 = (char *)this - 80;
  v3 = (int)this;
  *(_DWORD *)(this + *(_DWORD *)(*((_DWORD *)this - 20) + 4) - 80) = off_100689E4;
  *(_DWORD *)(this + *(_DWORD *)(*((_DWORD *)this - 20) + 4) - 84) = *(_DWORD *)(*((_DWORD *)this - 20) + 4) - 80;
  sub_10012890((int)((char *)this - 76));
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v3 - 80) + 4) + v3 - 80) = off_100689F0;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v3 - 80) + 4) + v3 - 84) = *(_DWORD *)(*(_DWORD *)(v3 - 80) + 4) - 8;
  *(_DWORD *)v3 = &off_100683D0;
  sub_100296B7(v3);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100683D0: using guessed type int (__stdcall *off_100683D0)(char);
// 100689E4: using guessed type int (*off_100689E4[6])();
// 100689F0: using guessed type int (*off_100689F0[3])();

//----- (10012F70) --------------------------------------------------------
void *__thiscall sub_10012F70(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_10012890(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10013050) --------------------------------------------------------
void *__userpurge sub_10013050<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6)
{
  void *v7; // esi@1
  char v8; // [sp+0h] [bp-28h]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  char *v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+24h] [bp-4h]@1

  v11 = &v8;
  v7 = (void *)a2;
  v9 = a2;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)a2 = sub_100155A0(a1, a2, a3, a4);
  v12 = 0;
  LOBYTE(v12) = 1;
  LOBYTE(v10) = 0;
  sub_10015AE0(v7, a5, v10);
  return v7;
}

//----- (100130F0) --------------------------------------------------------
int __thiscall sub_100130F0(void *this, int a2, int a3, int a4)
{
  int v4; // eax@1
  void *v5; // edi@1
  int v6; // esi@1
  int result; // eax@3
  int v8; // ecx@3
  int v9; // ecx@5
  int i; // edx@6
  int j; // eax@7
  char v12; // [sp+Ch] [bp-4h]@14

  v4 = a3;
  v5 = this;
  v6 = *(_DWORD *)this;
  if ( a3 != **(_DWORD **)this || a4 != v6 )
  {
    for ( ; a3 != a4; v4 = a3 )
    {
      v9 = v4;
      if ( !*(_BYTE *)(v4 + 13) )
      {
        i = *(_DWORD *)(v4 + 8);
        if ( *(_BYTE *)(i + 13) )
        {
          for ( i = *(_DWORD *)(v4 + 4); !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 4) )
          {
            if ( v4 != *(_DWORD *)(i + 8) )
              break;
            v4 = i;
          }
        }
        else
        {
          for ( j = *(_DWORD *)i; !*(_BYTE *)(j + 13); j = *(_DWORD *)j )
            i = j;
        }
        a3 = i;
      }
      sub_10012200(v5, (int)&v12, v9);
    }
    *(_DWORD *)a2 = v4;
    result = a2;
  }
  else
  {
    sub_100131B0(this, *(_DWORD *)(v6 + 4));
    result = a2;
    *(_DWORD *)(*(_DWORD *)v5 + 4) = *(_DWORD *)v5;
    **(_DWORD **)v5 = *(_DWORD *)v5;
    *(_DWORD *)(*(_DWORD *)v5 + 8) = *(_DWORD *)v5;
    v8 = *(_DWORD *)v5;
    *((_DWORD *)v5 + 1) = 0;
    *(_DWORD *)a2 = *(_DWORD *)v8;
  }
  return result;
}

//----- (100131B0) --------------------------------------------------------
void *__thiscall sub_100131B0(void *this, int a2)
{
  void *result; // eax@1
  int v3; // edi@1
  int i; // esi@1
  void *v5; // [sp+10h] [bp-10h]@1

  result = this;
  v5 = this;
  v3 = a2;
  for ( i = a2; !*(_BYTE *)(i + 13); v3 = i )
  {
    sub_100131B0(result, *(_DWORD *)(i + 8));
    i = *(_DWORD *)i;
    sub_100101D0(v3 + 24, v3 + 16);
    if ( *(_DWORD *)(v3 + 16) )
    {
      if ( *(_DWORD *)(v3 + 20) == 1 )
        sub_100309A2(v3 + 16, *(LPVOID *)(v3 + 16));
    }
    sub_1002A4AA((LPVOID)v3);
    result = v5;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10013250) --------------------------------------------------------
int __thiscall sub_10013250(void *this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v4; // eax@2
  int v5; // ecx@3
  char v6; // dl@6

  v2 = *(_DWORD *)this;
  v3 = *(_DWORD *)(*(_DWORD *)this + 4);
  while ( !*(_BYTE *)(v3 + 13) )
  {
    v4 = *(_DWORD *)(v3 + 16);
    if ( v4 )
    {
      v5 = *(_DWORD *)a2;
      while ( *(_BYTE *)v4 == *(_BYTE *)v5 )
      {
        if ( !*(_BYTE *)v4 )
          goto LABEL_8;
        v6 = *(_BYTE *)(v4 + 1);
        if ( v6 != *(_BYTE *)(v5 + 1) )
          break;
        v4 += 2;
        v5 += 2;
        if ( !v6 )
        {
LABEL_8:
          __asm { sets    al }
          goto LABEL_11;
        }
      }
      __asm { sets    al }
    }
    else
    {
      _AL = *(_DWORD *)(v3 + 20) < *(_DWORD *)(a2 + 4);
    }
LABEL_11:
    if ( _AL )
    {
      v3 = *(_DWORD *)(v3 + 8);
    }
    else
    {
      v2 = v3;
      v3 = *(_DWORD *)v3;
    }
  }
  return v2;
}

//----- (100132D0) --------------------------------------------------------
int __thiscall sub_100132D0(void *this, int a2)
{
  int v2; // esi@1
  int result; // eax@3

  v2 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)v2;
  if ( !*(_BYTE *)(*(_DWORD *)v2 + 13) )
    *(_DWORD *)(*(_DWORD *)v2 + 4) = a2;
  *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
  result = *(_DWORD *)this;
  if ( a2 == *(_DWORD *)(*(_DWORD *)this + 4) )
  {
    *(_DWORD *)(result + 4) = v2;
    *(_DWORD *)v2 = a2;
    *(_DWORD *)(a2 + 4) = v2;
  }
  else
  {
    result = *(_DWORD *)(a2 + 4);
    if ( a2 == *(_DWORD *)result )
    {
      *(_DWORD *)result = v2;
      *(_DWORD *)v2 = a2;
      *(_DWORD *)(a2 + 4) = v2;
    }
    else
    {
      *(_DWORD *)(result + 8) = v2;
      *(_DWORD *)v2 = a2;
      *(_DWORD *)(a2 + 4) = v2;
    }
  }
  return result;
}

//----- (10013330) --------------------------------------------------------
int __thiscall sub_10013330(void *this, int a2)
{
  int v2; // eax@1
  int v3; // esi@1
  int result; // eax@3

  v3 = *(_DWORD *)a2;
  *(_DWORD *)a2 = *(_DWORD *)(*(_DWORD *)a2 + 8);
  v2 = *(_DWORD *)(v3 + 8);
  if ( !*(_BYTE *)(v2 + 13) )
    *(_DWORD *)(v2 + 4) = a2;
  *(_DWORD *)(v3 + 4) = *(_DWORD *)(a2 + 4);
  result = *(_DWORD *)this;
  if ( a2 == *(_DWORD *)(*(_DWORD *)this + 4) )
  {
    *(_DWORD *)(result + 4) = v3;
    *(_DWORD *)(v3 + 8) = a2;
    *(_DWORD *)(a2 + 4) = v3;
  }
  else
  {
    result = *(_DWORD *)(a2 + 4);
    if ( a2 == *(_DWORD *)(result + 8) )
    {
      *(_DWORD *)(result + 8) = v3;
      *(_DWORD *)(v3 + 8) = a2;
      *(_DWORD *)(a2 + 4) = v3;
    }
    else
    {
      *(_DWORD *)result = v3;
      *(_DWORD *)(v3 + 8) = a2;
      *(_DWORD *)(a2 + 4) = v3;
    }
  }
  return result;
}

//----- (10013390) --------------------------------------------------------
char __stdcall sub_10013390(int a1, int a2)
{
  char result; // al@3

  if ( *(_DWORD *)a1 )
  {
    if ( strcmp(*(const char **)a1, *(const char **)a2) )
      __asm { sets    al }
    else
      __asm { sets    al }
  }
  else
  {
    result = *(_DWORD *)(a1 + 4) < *(_DWORD *)(a2 + 4);
  }
  return result;
}

//----- (100133F0) --------------------------------------------------------
int __fastcall sub_100133F0(int a1)
{
  int i; // eax@1

  for ( i = *(_DWORD *)(a1 + 8); !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 8) )
    a1 = i;
  return a1;
}

//----- (10013410) --------------------------------------------------------
void *__thiscall sub_10013410(void *this)
{
  int v1; // eax@1
  void *v2; // edx@1
  int v3; // ecx@2
  int j; // eax@3
  int i; // eax@6

  v2 = this;
  v1 = *(_DWORD *)this;
  if ( *(_BYTE *)(*(_DWORD *)this + 13) )
    return v2;
  v3 = *(_DWORD *)(v1 + 8);
  if ( *(_BYTE *)(v3 + 13) )
  {
    for ( i = *(_DWORD *)(v1 + 4); !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 4) )
    {
      if ( *(_DWORD *)v2 != *(_DWORD *)(i + 8) )
        break;
      *(_DWORD *)v2 = i;
    }
    *(_DWORD *)v2 = i;
    return v2;
  }
  for ( j = *(_DWORD *)v3; !*(_BYTE *)(j + 13); j = *(_DWORD *)j )
    v3 = j;
  *(_DWORD *)v2 = v3;
  return v2;
}

//----- (10013460) --------------------------------------------------------
void *__thiscall sub_10013460(void *this)
{
  int v1; // eax@1
  void *v2; // edx@1
  int i; // ecx@3
  int v5; // eax@4
  int v6; // ecx@5

  v2 = this;
  v1 = *(_DWORD *)this;
  if ( *(_BYTE *)(*(_DWORD *)this + 13) )
  {
    *(_DWORD *)this = *(_DWORD *)(v1 + 8);
    return this;
  }
  i = *(_DWORD *)v1;
  if ( *(_BYTE *)(*(_DWORD *)v1 + 13) )
  {
    for ( i = *(_DWORD *)(v1 + 4); !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 4) )
    {
      if ( *(_DWORD *)v2 != *(_DWORD *)i )
        break;
      *(_DWORD *)v2 = i;
    }
    if ( *(_BYTE *)(*(_DWORD *)v2 + 13) )
      return v2;
    goto LABEL_11;
  }
  v5 = *(_DWORD *)(i + 8);
  if ( *(_BYTE *)(v5 + 13) )
  {
LABEL_11:
    *(_DWORD *)v2 = i;
    return v2;
  }
  do
  {
    v6 = v5;
    v5 = *(_DWORD *)(v5 + 8);
  }
  while ( !*(_BYTE *)(v5 + 13) );
  *(_DWORD *)v2 = v6;
  return v2;
}

//----- (10013550) --------------------------------------------------------
int __thiscall sub_10013550(int this, int a2)
{
  int result; // eax@1
  int v3; // edx@1

  result = a2;
  v3 = *(_DWORD *)(this + 12);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)a2 = *(_DWORD *)this;
  *(_DWORD *)(a2 + 8) = v3;
  return result;
}

//----- (10013580) --------------------------------------------------------
int __thiscall sub_10013580(int this, int a2)
{
  int result; // eax@1
  int v3; // edx@1

  result = a2;
  v3 = *(_DWORD *)(this + 12) + *(_DWORD *)(this + 16);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)a2 = *(_DWORD *)this;
  *(_DWORD *)(a2 + 8) = v3;
  return result;
}

//----- (100135B0) --------------------------------------------------------
int __userpurge sub_100135B0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int **a5, int a6, int a7, int **a8, int a9, int a10)
{
  int v10; // esi@1
  int v11; // edx@5
  int v12; // edx@9
  int v13; // edi@9
  int v14; // eax@9
  unsigned int v15; // ebx@9
  int v16; // eax@9
  int v17; // edx@18
  int v18; // ebx@20
  char v19; // zf@22
  int v20; // edx@31
  int v21; // ecx@36
  int v22; // ebx@37
  char v23; // zf@39
  int v25; // edi@42
  int v26; // eax@42
  int v27; // edx@42
  char v28; // [sp-28h] [bp-84h]@18
  int v29; // [sp-24h] [bp-80h]@18
  int v30; // [sp-20h] [bp-7Ch]@18
  int **v31; // [sp-1Ch] [bp-78h]@14
  int v32; // [sp-18h] [bp-74h]@14
  int v33; // [sp-14h] [bp-70h]@18
  int v34; // [sp-10h] [bp-6Ch]@1
  int v35; // [sp-Ch] [bp-68h]@1
  int v36; // [sp-8h] [bp-64h]@14
  unsigned int v37; // [sp-4h] [bp-60h]@1
  char v38; // [sp+Ch] [bp-50h]@42
  char v39; // [sp+18h] [bp-44h]@9
  int v40; // [sp+24h] [bp-38h]@1
  char v41; // [sp+28h] [bp-34h]@12
  int ****v42; // [sp+2Ch] [bp-30h]@5
  int v43; // [sp+34h] [bp-28h]@9
  int **v44; // [sp+38h] [bp-24h]@9
  int v45; // [sp+40h] [bp-1Ch]@9
  int v46; // [sp+44h] [bp-18h]@3
  char v47; // [sp+48h] [bp-14h]@16
  unsigned int v48; // [sp+4Ch] [bp-10h]@1
  int v49; // [sp+58h] [bp-4h]@14
  int v50; // [sp+5Ch] [bp+0h]@1

  v48 = (unsigned int)&v50 ^ __security_cookie;
  v37 = (unsigned int)&v50 ^ __security_cookie;
  v10 = a2;
  v40 = a4;
  v34 = 0;
  v35 = 0;
  if ( a5 )
  {
    if ( *a5 )
    {
      v34 = **a5;
    }
    else
    {
      sub_10029A76(a1, (int)&v46, a3, (int)&v34, 3);
      sub_10029AD2(&v46);
    }
  }
  sub_10014A40(a1, v10, a3, (int)&v42, v34, v35, a7);
  v34 = 0;
  v35 = 0;
  if ( a8 )
  {
    if ( *a8 )
    {
      v34 = **a8;
    }
    else
    {
      sub_10029A76(v11, (int)&v46, a3, (int)&v34, 3);
      sub_10029AD2(&v46);
    }
  }
  sub_10014A40(v11, v10, a3, (int)&v44, v34, v35, a10);
  v14 = sub_10013550(v10, (int)&v39);
  v13 = v45 - v43;
  v46 = v43 - *(_DWORD *)(v14 + 8);
  v15 = v46;
  v16 = sub_10013580(v10, (int)&v39);
  LOBYTE(v16) = v15 < *(_DWORD *)(v16 + 8) - v45;
  v34 = 0;
  v35 = 0;
  if ( (_BYTE)v16 )
  {
    if ( v44 )
    {
      if ( *v44 )
      {
        v34 = **v44;
      }
      else
      {
        sub_10029A76(v12, (int)&v41, (int)&v34, v13, 3);
        sub_10029AD2(&v41);
      }
    }
    v36 = v45;
    v49 = 0;
    v31 = 0;
    v32 = 0;
    if ( v42 )
    {
      if ( *v42 )
      {
        v31 = **v42;
      }
      else
      {
        sub_10029A76(v12, (int)&v47, (int)&v31, v13, 3);
        sub_10029AD2(&v47);
      }
    }
    v33 = v43;
    sub_10013550(v10, (int)&v28);
    v49 = -1;
    sub_10015B60(v17, (int)&v39, (int)&v31, *(int ***)&v28, v29, v30, v31, v32, v33, (int **)v34, v35, v36);
    for ( ; v13; --v13 )
    {
      if ( *(_DWORD *)(v10 + 16) )
      {
        v18 = *(_DWORD *)(*(_DWORD *)(v10 + 4) + 4 * (*(_DWORD *)(v10 + 12) & (*(_DWORD *)(v10 + 8) - 1)));
        if ( *(_DWORD *)(v18 + 32) >= 0x10u )
        {
          v36 = *(_DWORD *)(v18 + 12);
          sub_1002A4AA((LPVOID)v36);
        }
        *(_DWORD *)(v18 + 32) = 15;
        *(_DWORD *)(v18 + 28) = 0;
        *(_BYTE *)(v18 + 12) = 0;
        v19 = *(_DWORD *)(v10 + 16)-- == 1;
        if ( v19 )
          *(_DWORD *)(v10 + 12) = 0;
        else
          ++*(_DWORD *)(v10 + 12);
      }
    }
  }
  else
  {
    if ( v42 )
    {
      if ( *v42 )
      {
        v34 = (int)**v42;
      }
      else
      {
        sub_10029A76(v12, (int)&v47, (int)&v34, v13, 3);
        sub_10029AD2(&v47);
      }
    }
    v36 = v43;
    v49 = 1;
    sub_10013580(v10, (int)&v31);
    LOBYTE(v49) = 2;
    *(_DWORD *)&v28 = 0;
    v29 = 0;
    if ( v44 )
    {
      if ( *v44 )
      {
        *(_DWORD *)&v28 = **v44;
      }
      else
      {
        sub_10029A76(v20, (int)&v47, (int)&v28, v13, 3);
        sub_10029AD2(&v47);
      }
    }
    v49 = -1;
    sub_10015C80(v20, (int)&v39, (int)&v28, *(int ***)&v28, v29, v45, v31, v32, v33, (int **)v34, v35, v36);
    for ( ; v13; --v13 )
    {
      v21 = *(_DWORD *)(v10 + 16);
      if ( v21 )
      {
        v22 = *(_DWORD *)(*(_DWORD *)(v10 + 4) + 4 * ((v21 - 1 + *(_DWORD *)(v10 + 12)) & (*(_DWORD *)(v10 + 8) - 1)));
        if ( *(_DWORD *)(v22 + 32) >= 0x10u )
        {
          v36 = *(_DWORD *)(v22 + 12);
          sub_1002A4AA((LPVOID)v36);
        }
        *(_DWORD *)(v22 + 32) = 15;
        *(_DWORD *)(v22 + 28) = 0;
        *(_BYTE *)(v22 + 12) = 0;
        v23 = *(_DWORD *)(v10 + 16)-- == 1;
        if ( v23 )
          *(_DWORD *)(v10 + 12) = 0;
      }
    }
  }
  v36 = v46;
  v25 = v40;
  v35 = v40;
  v26 = sub_10013550(v10, (int)&v38);
  sub_10014540(v26, v27, v35, v36);
  return v25;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10013B80) --------------------------------------------------------
int __thiscall sub_10013B80(int this, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  unsigned int v4; // eax@2
  unsigned int v5; // ecx@3
  int v6; // ST08_4@5
  int v7; // ST04_4@5
  int v9; // eax@8
  int v10; // ST08_4@9
  int v11; // ST04_4@9
  int v12; // ecx@11
  void *v13; // [sp+Ch] [bp-20h]@5
  int v14; // [sp+1Ch] [bp-10h]@5
  unsigned int v15; // [sp+20h] [bp-Ch]@5
  unsigned int v16; // [sp+24h] [bp-8h]@1
  int v17; // [sp+2Ch] [bp+0h]@1

  v16 = (unsigned int)&v17 ^ __security_cookie;
  v2 = this;
  v3 = *(_DWORD *)(this + 60);
  if ( v3 & 2 || (v4 = **(_DWORD **)(v2 + 32), !v4) )
  {
    if ( v3 & 4 || (v9 = *(_DWORD *)(v2 + 28), !*(_DWORD *)v9) )
    {
      v15 = 15;
      v14 = 0;
      LOBYTE(v13) = 0;
      *(_DWORD *)(a2 + 20) = 15;
      *(_DWORD *)(a2 + 16) = 0;
      *(_BYTE *)a2 = 0;
      v12 = v15;
      if ( v15 >= 0x10 )
      {
        *(_DWORD *)a2 = v13;
      }
      else
      {
        if ( v14 != -1 )
        {
          sub_1002A4B0((void *)a2, &v13, v14 + 1);
          v12 = v15;
        }
      }
      *(_DWORD *)(a2 + 16) = v14;
      *(_DWORD *)(a2 + 20) = v12;
    }
    else
    {
      v10 = *(_DWORD *)v9 + **(_DWORD **)(v2 + 44) - **(_DWORD **)(v2 + 12);
      v11 = **(_DWORD **)(v2 + 12);
      v15 = 15;
      v14 = 0;
      LOBYTE(v13) = 0;
      loc_1000AEB0(&v13, v11, v10);
      sub_10001810(a2, (int)&v13);
      if ( v15 >= 0x10 )
      {
        sub_1002A4AA(v13);
        return a2;
      }
    }
  }
  else
  {
    v5 = *(_DWORD *)(v2 + 56);
    if ( v5 < v4 )
      v5 = **(_DWORD **)(v2 + 32);
    v6 = v5 - **(_DWORD **)(v2 + 16);
    v7 = **(_DWORD **)(v2 + 16);
    v15 = 15;
    v14 = 0;
    LOBYTE(v13) = 0;
    loc_1000AEB0(&v13, v7, v6);
    sub_10001810(a2, (int)&v13);
    if ( v15 >= 0x10 )
    {
      sub_1002A4AA(v13);
      return a2;
    }
  }
  return a2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10013CE0) --------------------------------------------------------
int __userpurge sub_10013CE0<eax>(int a1<ecx>, int a2<edi>, int a3, int a4, int a5, int a6, char a7, unsigned __int8 a8)
{
  char v8; // zf@1
  void *v9; // edi@3
  int v10; // eax@3
  int v11; // eax@3
  int v12; // edx@3
  int v13; // eax@4
  int v14; // eax@7
  int v15; // ecx@11
  unsigned int v16; // edi@14
  int v17; // edi@15
  int v18; // eax@18
  int v19; // edx@18
  int v20; // eax@18
  unsigned __int8 *v21; // eax@20
  int v22; // eax@22
  unsigned __int8 v23; // ST10_1@22
  int v24; // ST08_4@22
  int v25; // ST00_4@22
  int v27; // [sp+10h] [bp-54h]@1
  int v28; // [sp+14h] [bp-50h]@1
  int v29; // [sp+18h] [bp-4Ch]@3
  void *v30; // [sp+20h] [bp-44h]@7
  unsigned int v31; // [sp+34h] [bp-30h]@9
  void *v32; // [sp+38h] [bp-2Ch]@6
  unsigned int v33; // [sp+48h] [bp-1Ch]@6
  unsigned int v34; // [sp+4Ch] [bp-18h]@6
  unsigned int v35; // [sp+50h] [bp-14h]@1
  int v36; // [sp+60h] [bp-4h]@3
  int v37; // [sp+74h] [bp+10h]@22

  v35 = (unsigned int)&v27 ^ __security_cookie;
  v28 = a1;
  v8 = (*(_DWORD *)(a6 + 20) & 0x4000) == 0;
  LOBYTE(v27) = a7;
  if ( v8 )
  {
    (*(void (__stdcall **)(int, int, int, int, int, _DWORD))(*(_DWORD *)a1 + 36))(a3, a4, a5, a6, v27, a8);
  }
  else
  {
    v10 = sub_10017D70(a6, (int)&v29);
    v36 = 0;
    v11 = sub_100171B0(v12, a3, a2, v10);
    v36 = -1;
    v9 = (void *)v11;
    if ( v29 )
    {
      v13 = (*(int (**)(void))(*(_DWORD *)v29 + 8))();
      if ( v13 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v13)(v13, 1);
    }
    v34 = 15;
    v33 = 0;
    LOBYTE(v32) = 0;
    v36 = 1;
    if ( a8 )
      v14 = sub_10016D30(v9, (int)&v30);
    else
      v14 = sub_10016D10(v9, (int)&v30);
    sub_10016D50((int)&v32, v14);
    if ( v31 >= 0x10 )
      sub_1002A4AA(v30);
    v15 = v33;
    if ( *(_DWORD *)(a6 + 36) >= 0
      && (*(_DWORD *)(a6 + 36) > 0 || *(_DWORD *)(a6 + 32))
      && (v16 = *(_DWORD *)(a6 + 32), v16 > v33) )
      v17 = v16 - v33;
    else
      v17 = 0;
    if ( (*(_DWORD *)(a6 + 20) & 0x1C0) == 64 )
    {
      v18 = a5;
      v19 = a4;
    }
    else
    {
      v20 = sub_10015490(v28, (int)&v29, a4, a5, v27, v17);
      v19 = *(_DWORD *)v20;
      v15 = v33;
      v18 = *(_DWORD *)(v20 + 4);
      v17 = 0;
    }
    v29 = v18;
    v21 = (unsigned __int8 *)&v32;
    if ( v34 >= 0x10 )
      v21 = (unsigned __int8 *)v32;
    v22 = sub_10015410(v28, (int)&v29, v19, v29, v21, v15);
    v23 = v27;
    v24 = *(_DWORD *)v22;
    v25 = v28;
    v37 = *(_DWORD *)(v22 + 4);
    *(_DWORD *)(a6 + 32) = 0;
    *(_DWORD *)(a6 + 36) = 0;
    sub_10015490(v25, a3, v24, v37, v23, v17);
    if ( v34 >= 0x10 )
      sub_1002A4AA(v32);
  }
  return a3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10013ED0) --------------------------------------------------------
int __thiscall sub_10013ED0(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7)
{
  int v8; // edi@1
  int v9; // eax@1
  int v10; // eax@1
  char v11; // [sp+Ch] [bp-54h]@1
  char v12; // [sp+10h] [bp-50h]@1
  char v13; // [sp+18h] [bp-48h]@1
  unsigned int v14; // [sp+5Ch] [bp-4h]@1

  v14 = (unsigned int)&v11 ^ __security_cookie;
  v8 = this;
  v9 = sub_10014FE0(this, (int)&v12, (int)"ld", *(_DWORD *)(a5 + 20));
  v10 = sub_100308F4(a2, v8, (int)&v13, 0x40u, v9, a7);
  sub_10015070(v8, a2, a3, a4, a5, a6, (int)&v13, v10);
  return a2;
}
// 10074200: using guessed type int __security_cookie;

//----- (10013F50) --------------------------------------------------------
int __thiscall sub_10013F50(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7)
{
  int v8; // edi@1
  int v9; // eax@1
  int v10; // eax@1
  char v11; // [sp+Ch] [bp-54h]@1
  char v12; // [sp+10h] [bp-50h]@1
  char v13; // [sp+18h] [bp-48h]@1
  unsigned int v14; // [sp+5Ch] [bp-4h]@1

  v14 = (unsigned int)&v11 ^ __security_cookie;
  v8 = this;
  v9 = sub_10014FE0(this, (int)&v12, (int)"lu", *(_DWORD *)(a5 + 20));
  v10 = sub_100308F4(a2, v8, (int)&v13, 0x40u, v9, a7);
  sub_10015070(v8, a2, a3, a4, a5, a6, (int)&v13, v10);
  return a2;
}
// 10074200: using guessed type int __security_cookie;

//----- (10013FE0) --------------------------------------------------------
int __thiscall sub_10013FE0(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7, int a8)
{
  int v9; // edi@1
  int v10; // eax@1
  int v11; // eax@1
  char v12; // [sp+Ch] [bp-54h]@1
  char v13; // [sp+10h] [bp-50h]@1
  char v14; // [sp+18h] [bp-48h]@1
  unsigned int v15; // [sp+5Ch] [bp-4h]@1

  v15 = (unsigned int)&v12 ^ __security_cookie;
  v9 = this;
  v10 = sub_10014FE0(this, (int)&v13, (int)"Ld", *(_DWORD *)(a5 + 20));
  v11 = sub_100308F4(a2, v9, (int)&v14, 0x40u, v10, a7);
  sub_10015070(v9, a2, a3, a4, a5, a6, (int)&v14, v11);
  return a2;
}
// 10074200: using guessed type int __security_cookie;

//----- (10014060) --------------------------------------------------------
int __thiscall sub_10014060(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7, int a8)
{
  int v9; // edi@1
  int v10; // eax@1
  int v11; // eax@1
  char v12; // [sp+Ch] [bp-54h]@1
  char v13; // [sp+10h] [bp-50h]@1
  char v14; // [sp+18h] [bp-48h]@1
  unsigned int v15; // [sp+5Ch] [bp-4h]@1

  v15 = (unsigned int)&v12 ^ __security_cookie;
  v9 = this;
  v10 = sub_10014FE0(this, (int)&v13, (int)"Lu", *(_DWORD *)(a5 + 20));
  v11 = sub_100308F4(a2, v9, (int)&v14, 0x40u, v10, a7);
  sub_10015070(v9, a2, a3, a4, a5, a6, (int)&v14, v11);
  return a2;
}
// 10074200: using guessed type int __security_cookie;

//----- (100140E0) --------------------------------------------------------
int __userpurge sub_100140E0<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6, unsigned __int8 a7, __int64 a8)
{
  int v8; // edi@1
  signed int v9; // esi@1
  signed int v10; // eax@9
  unsigned int v11; // edx@11
  unsigned int v12; // ecx@11
  int v13; // edi@11
  int v14; // esi@11
  unsigned __int8 v15; // cf@11
  int v16; // eax@11
  char v22; // al@13
  unsigned __int8 v43; // cf@26
  char *v44; // eax@32
  int v45; // edx@32
  int v46; // edi@32
  int v47; // ecx@36
  int v48; // ecx@39
  char v52; // ST38_1@46
  int v53; // eax@46
  int v54; // ST24_4@46
  int v55; // esi@46
  int v56; // [sp+10h] [bp-98h]@1
  int v57; // [sp+14h] [bp-94h]@11
  int v58; // [sp+18h] [bp-90h]@9
  int v59; // [sp+1Ch] [bp-8Ch]@1
  int v60; // [sp+20h] [bp-88h]@1
  int v61; // [sp+24h] [bp-84h]@1
  char v62; // [sp+28h] [bp-80h]@32
  char v63; // [sp+29h] [bp-7Fh]@32
  char v64; // [sp+2Ah] [bp-7Eh]@33
  char v65; // [sp+30h] [bp-78h]@46
  unsigned int v66; // [sp+A4h] [bp-4h]@1

  v66 = (unsigned int)&v56 ^ __security_cookie;
  v60 = a3;
  v8 = *(_DWORD *)(a6 + 28);
  v9 = *(_DWORD *)(a6 + 24);
  v61 = a1;
  v59 = a6;
  if ( v8 > 0 )
    goto LABEL_49;
  if ( v8 < 0 || !v9 )
  {
    if ( !(*(_DWORD *)(a6 + 20) & 0x2000) )
    {
      v9 = 6;
      v8 = 0;
    }
  }
  if ( v8 < 0 || v8 <= 0 && (unsigned int)v9 <= 0x24 )
  {
    v10 = v9;
    v58 = v9;
  }
  else
  {
LABEL_49:
    v10 = 36;
    v58 = 36;
  }
  __asm { movsd   xmm1, [ebp+arg_14] }
  v15 = v9 < (unsigned int)v10;
  v14 = v9 - v10;
  v13 = v8 - (v15 + ((unsigned __int64)v10 >> 32));
  v11 = 0;
  v12 = 0;
  v16 = *(_DWORD *)(v59 + 20) & 0x3000;
  v56 = 0;
  v57 = 0;
  if ( v16 == 8192 )
  {
    __asm
    {
      movapd  xmm0, xmm1
      mulsd   xmm0, ds:qword_10069498
      ucomisd xmm0, xmm1
      lahf
    }
    if ( __SETP__(_AH & 0x44, 0) )
    {
      __asm
      {
        movsd   xmm4, qword ptr ds:xmmword_100695B0
        xorps   xmm3, xmm3
        comisd  xmm3, xmm1
      }
      v22 = !(_CF | _ZF);
      if ( !(_CF | _ZF) )
        __asm { xorpd   xmm1, xmm4 }
      __asm
      {
        movsd   xmm0, ds:qword_10069558
        comisd  xmm1, xmm0
        movsd   xmm2, ds:qword_10069528
      }
      if ( !_CF )
      {
        do
        {
          if ( v11 >= 0x1388 )
            break;
          __asm { divsd   xmm1, xmm2 }
          v11 += 10;
          __asm { comisd  xmm1, xmm0 }
        }
        while ( !_CF );
        v56 = v11;
      }
      __asm { comisd  xmm1, xmm3 }
      if ( !(_CF | _ZF) )
      {
        if ( v13 >= 0 )
        {
          if ( v13 > 0 || (unsigned int)v14 >= 0xA )
          {
            __asm { movsd   xmm0, ds:qword_10069478 }
            while ( 1 )
            {
              __asm { comisd  xmm0, xmm1 }
              if ( _CF )
                break;
              if ( v12 >= 0x1388 )
                break;
              v43 = (unsigned int)v14 >= 0xA;
              v14 -= 10;
              v13 = v43 + v13 - 1;
              v12 += 10;
              __asm { mulsd   xmm1, xmm2 }
              if ( v13 <= 0 )
              {
                if ( v13 < 0 || (unsigned int)v14 < 0xA )
                  break;
              }
            }
            v57 = v12;
          }
        }
      }
      if ( v22 )
        __asm { xorpd   xmm1, xmm4 }
    }
  }
  v46 = v59;
  v62 = 37;
  v45 = *(_DWORD *)(v59 + 20);
  v44 = &v63;
  if ( v45 & 0x20 )
  {
    v63 = 43;
    v44 = &v64;
  }
  if ( v45 & 0x10 )
    *v44++ = 35;
  v47 = v45 & 0x3000;
  *(_WORD *)v44 = 10798;
  if ( v45 & 4 )
  {
    if ( v47 != 8192 )
    {
      if ( v47 == 12288 )
      {
        LOBYTE(v48) = 65;
      }
      else
      {
        LOBYTE(v47) = v47 != 4096;
        v48 = 2 * v47 + 69;
      }
      goto LABEL_46;
    }
LABEL_42:
    LOBYTE(v48) = 102;
    goto LABEL_46;
  }
  if ( v47 == 8192 )
    goto LABEL_42;
  if ( v47 == 12288 )
  {
    LOBYTE(v48) = 97;
  }
  else
  {
    LOBYTE(v47) = v47 != 4096;
    v48 = 2 * v47 + 101;
  }
LABEL_46:
  v44[2] = v48;
  __asm { movsd   [esp+0A8h+var_A8], xmm1 }
  v52 = v58;
  v44[3] = 0;
  v53 = sub_100308F4(a2, v46, (int)&v65, 0x6Cu, (int)&v62, v52);
  v54 = v14;
  v55 = v60;
  sub_10014B60(v61, v60, a4, a5, v46, a7, (int)&v65, v56, v57, v54, v53);
  return v55;
}
// 10074200: using guessed type int __security_cookie;

//----- (10014320) --------------------------------------------------------
int __userpurge sub_10014320<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6, unsigned __int8 a7, __int64 a8)
{
  int v8; // edi@1
  signed int v9; // esi@1
  signed int v10; // eax@9
  unsigned int v11; // edx@11
  unsigned int v12; // ecx@11
  int v13; // edi@11
  int v14; // esi@11
  unsigned __int8 v15; // cf@11
  char v16; // al@12
  unsigned __int8 v37; // cf@25
  int v39; // edi@31
  char v42; // ST38_1@31
  int v43; // eax@31
  int v44; // eax@31
  int v45; // ST24_4@31
  int v46; // esi@31
  int v47; // [sp+10h] [bp-98h]@1
  int v48; // [sp+14h] [bp-94h]@9
  int v49; // [sp+18h] [bp-90h]@11
  int v50; // [sp+1Ch] [bp-8Ch]@11
  int v51; // [sp+20h] [bp-88h]@1
  int v52; // [sp+24h] [bp-84h]@1
  int v53; // [sp+28h] [bp-80h]@11
  char v54; // [sp+30h] [bp-78h]@31
  unsigned int v55; // [sp+A4h] [bp-4h]@1

  v55 = (unsigned int)&v47 ^ __security_cookie;
  v51 = a3;
  v8 = *(_DWORD *)(a6 + 28);
  v9 = *(_DWORD *)(a6 + 24);
  v52 = a1;
  v47 = a6;
  if ( v8 > 0 )
    goto LABEL_34;
  if ( v8 < 0 || !v9 )
  {
    if ( !(*(_DWORD *)(a6 + 20) & 0x2000) )
    {
      v9 = 6;
      v8 = 0;
    }
  }
  if ( v8 < 0 || v8 <= 0 && (unsigned int)v9 <= 0x24 )
  {
    v10 = v9;
    v48 = v9;
  }
  else
  {
LABEL_34:
    v10 = 36;
    v48 = 36;
  }
  __asm { movsd   xmm0, [ebp+arg_14] }
  v15 = v9 < (unsigned int)v10;
  v14 = v9 - v10;
  v13 = v8 - (v15 + ((unsigned __int64)v10 >> 32));
  v53 = *(_DWORD *)(v47 + 20);
  v11 = 0;
  v12 = 0;
  v50 = 0;
  v49 = 0;
  if ( (v53 & 0x3000) == 8192 )
  {
    __asm
    {
      movsd   xmm4, qword ptr ds:xmmword_100695B0
      xorps   xmm3, xmm3
      comisd  xmm3, xmm0
    }
    v16 = !(_CF | _ZF);
    if ( !(_CF | _ZF) )
      __asm { xorpd   xmm0, xmm4 }
    __asm
    {
      movsd   xmm1, ds:qword_10069558
      comisd  xmm0, xmm1
      movsd   xmm2, ds:qword_10069528
    }
    if ( !_CF )
    {
      do
      {
        if ( v11 >= 0x1388 )
          break;
        __asm { divsd   xmm0, xmm2 }
        v11 += 10;
        __asm { comisd  xmm0, xmm1 }
      }
      while ( !_CF );
      v50 = v11;
    }
    __asm { comisd  xmm0, xmm3 }
    if ( !(_CF | _ZF) )
    {
      if ( v13 >= 0 )
      {
        if ( v13 > 0 || (unsigned int)v14 >= 0xA )
        {
          __asm { movsd   xmm1, ds:qword_10069478 }
          while ( 1 )
          {
            __asm { comisd  xmm1, xmm0 }
            if ( _CF )
              break;
            if ( v12 >= 0x1388 )
              break;
            v37 = (unsigned int)v14 >= 0xA;
            v14 -= 10;
            v13 = v37 + v13 - 1;
            v12 += 10;
            __asm { mulsd   xmm0, xmm2 }
            if ( v13 <= 0 )
            {
              if ( v13 < 0 || (unsigned int)v14 < 0xA )
                break;
            }
          }
          v49 = v12;
        }
      }
    }
    if ( v16 )
      __asm { xorpd   xmm0, xmm4 }
  }
  v39 = v52;
  __asm { movsd   [esp+0A8h+var_A8], xmm0 }
  v42 = v48;
  v43 = sub_10014AA0(v52, (int)&v53, 76, v53);
  v44 = sub_100308F4(a2, v39, (int)&v54, 0x6Cu, v43, v42);
  v45 = v14;
  v46 = v51;
  sub_10014B60(v39, v51, a4, a5, v47, a7, (int)&v54, v50, v49, v45, v44);
  return v46;
}
// 10074200: using guessed type int __security_cookie;

//----- (100144D0) --------------------------------------------------------
int __thiscall sub_100144D0(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7)
{
  int v8; // edi@1
  int v9; // eax@1
  char v10; // [sp+Ch] [bp-4Ch]@1
  char v11; // [sp+10h] [bp-48h]@1
  unsigned int v12; // [sp+54h] [bp-4h]@1

  v12 = (unsigned int)&v10 ^ __security_cookie;
  v8 = this;
  v9 = sub_100308F4(a2, this, (int)&v11, 0x40u, (int)"%p", a7);
  sub_10015070(v8, a2, a3, a4, a5, a6, (int)&v11, v9);
  return a2;
}
// 10074200: using guessed type int __security_cookie;

//----- (10014540) --------------------------------------------------------
int __fastcall sub_10014540(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@1
  int *v6; // eax@2
  int v7; // edi@5
  char v9; // [sp+Ch] [bp-8h]@3
  unsigned int v10; // [sp+10h] [bp-4h]@1
  int v11; // [sp+14h] [bp+0h]@1

  v10 = (unsigned int)&v11 ^ __security_cookie;
  v5 = a1;
  v4 = 0;
  if ( *(_DWORD *)a1 )
  {
    v6 = (int *)**(_DWORD **)a1;
    if ( v6 )
    {
      v4 = *v6;
    }
    else
    {
      sub_10029A76(a2, (int)&v9, 0, a1, 3);
      sub_10029AD2(&v9);
    }
  }
  v7 = a4 + *(_DWORD *)(v5 + 8);
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  if ( v4 )
  {
    if ( *(_DWORD *)v4 )
    {
      *(_DWORD *)a3 = **(_DWORD **)v4;
    }
    else
    {
      sub_10029A76(a2, (int)&v9, v4, v7, 3);
      sub_10029AD2(&v9);
    }
  }
  *(_DWORD *)(a3 + 8) = v7;
  return a3;
}
// 10074200: using guessed type int __security_cookie;

//----- (100145D0) --------------------------------------------------------
void *__thiscall sub_100145D0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10061664;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10061664: using guessed type int (__stdcall *off_10061664)(char);

//----- (10014830) --------------------------------------------------------
int __usercall sub_10014830<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<ebp>, int a5<edi>)
{
  int v5; // eax@1
  int v6; // edi@1
  int v7; // esi@1

  v7 = a2;
  *(_DWORD *)a2 = &off_1006896C;
  v5 = sub_1002ADB1(a1, a2, a3, a5, 4);
  v6 = v5;
  if ( v5 )
  {
    *(_DWORD *)v5 = 0;
    *(_DWORD *)v5 = sub_1002987D(a3, a4, v5);
  }
  else
  {
    v6 = 0;
  }
  *(_DWORD *)(v7 + 12) = v7 + 4;
  *(_DWORD *)(v7 + 28) = v7 + 20;
  *(_DWORD *)(v7 + 32) = v7 + 24;
  *(_DWORD *)(v7 + 52) = v6;
  *(_DWORD *)(v7 + 44) = v7 + 36;
  *(_DWORD *)(v7 + 16) = v7 + 8;
  *(_DWORD *)(v7 + 48) = v7 + 40;
  *(_DWORD *)(v7 + 8) = 0;
  **(_DWORD **)(v7 + 32) = 0;
  **(_DWORD **)(v7 + 48) = 0;
  **(_DWORD **)(v7 + 12) = 0;
  **(_DWORD **)(v7 + 28) = 0;
  **(_DWORD **)(v7 + 44) = 0;
  return v7;
}
// 1006896C: using guessed type int (__stdcall *off_1006896C)(char);

//----- (10014A40) --------------------------------------------------------
int __userpurge sub_10014A40<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7)
{
  char v8; // [sp+8h] [bp-8h]@2
  unsigned int v9; // [sp+Ch] [bp-4h]@1
  int v10; // [sp+10h] [bp+0h]@1

  v9 = (unsigned int)&v10 ^ __security_cookie;
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  if ( a2 )
  {
    *(_DWORD *)a4 = *(_DWORD *)a2;
  }
  else
  {
    sub_10029A76(a1, (int)&v8, a3, a7, 3);
    sub_10029AD2(&v8);
  }
  *(_DWORD *)(a4 + 8) = a7;
  return a4;
}
// 10074200: using guessed type int __security_cookie;

//----- (10014AA0) --------------------------------------------------------
int __cdecl sub_10014AA0(int a1, int a2, char a3, __int16 a4)
{
  int v4; // eax@1
  int v5; // eax@5
  int v6; // ecx@7
  int result; // eax@10

  *(_BYTE *)a2 = 37;
  v4 = a2 + 1;
  if ( a4 & 0x20 )
  {
    *(_BYTE *)v4 = 43;
    v4 = a2 + 2;
  }
  if ( a4 & 0x10 )
    *(_BYTE *)v4++ = 35;
  *(_WORD *)v4 = 10798;
  v5 = v4 + 2;
  if ( a3 )
    *(_BYTE *)v5++ = a3;
  v6 = a4 & 0x3000;
  if ( a4 & 4 )
  {
    if ( v6 != 8192 )
    {
      if ( v6 == 12288 )
      {
        *(_BYTE *)v5 = 65;
        *(_BYTE *)(v5 + 1) = 0;
        result = a2;
      }
      else
      {
        *(_BYTE *)v5 = 2 * (v6 != 4096) + 69;
        *(_BYTE *)(v5 + 1) = 0;
        result = a2;
      }
      return result;
    }
LABEL_13:
    *(_BYTE *)v5 = 102;
    *(_BYTE *)(v5 + 1) = 0;
    return a2;
  }
  if ( v6 == 8192 )
    goto LABEL_13;
  if ( v6 == 12288 )
  {
    *(_BYTE *)v5 = 97;
    *(_BYTE *)(v5 + 1) = 0;
    result = a2;
  }
  else
  {
    *(_BYTE *)v5 = 2 * (v6 != 4096) + 101;
    *(_BYTE *)(v5 + 1) = 0;
    result = a2;
  }
  return result;
}

//----- (10014B60) --------------------------------------------------------
int __cdecl sub_10014B60(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8, int a9, int a10, unsigned int a11)
{
  int v11; // edi@4
  int v12; // eax@6
  int v13; // edx@7
  int v14; // eax@8
  char v15; // cl@10
  int v16; // eax@13
  int v17; // eax@13
  int v18; // edx@13
  int v19; // eax@14
  int *v20; // eax@16
  void *v21; // ebx@18
  int v22; // eax@18
  int v23; // eax@18
  int v24; // edx@18
  int v25; // eax@19
  int v26; // ebx@22
  int *v27; // eax@23
  int v28; // edx@23
  char v29; // cl@23
  int v30; // esi@23
  char v31; // al@23
  int *v32; // esi@26
  char i; // al@28
  unsigned __int8 v34; // zf@34
  unsigned __int8 v35; // sf@34
  int v36; // ebx@34
  unsigned int v37; // esi@37
  int v38; // esi@38
  int v39; // eax@40
  unsigned __int8 *v40; // eax@42
  int v41; // ecx@42
  int v42; // eax@44
  unsigned __int8 *v43; // eax@45
  int v44; // eax@47
  unsigned __int8 *v45; // eax@48
  int *v46; // eax@51
  int v47; // edx@51
  int v48; // ebx@53
  int v49; // eax@53
  int v50; // ST1C_4@53
  int v52; // [sp+50h] [bp-74h]@1
  int v53; // [sp+54h] [bp-70h]@13
  int v54; // [sp+58h] [bp-6Ch]@1
  int v55; // [sp+60h] [bp-64h]@13
  int v56; // [sp+64h] [bp-60h]@13
  unsigned int v57; // [sp+68h] [bp-5Ch]@1
  unsigned int v58; // [sp+6Ch] [bp-58h]@21
  int v59; // [sp+70h] [bp-54h]@13
  int v60; // [sp+74h] [bp-50h]@16
  int v61; // [sp+78h] [bp-4Ch]@1
  __int16 v62; // [sp+7Ch] [bp-48h]@13
  void *v63; // [sp+80h] [bp-44h]@16
  unsigned int v64; // [sp+90h] [bp-34h]@16
  unsigned int v65; // [sp+94h] [bp-30h]@16
  void *v66; // [sp+98h] [bp-2Ch]@21
  int v67; // [sp+A8h] [bp-1Ch]@55
  unsigned int v68; // [sp+ACh] [bp-18h]@26
  unsigned int v69; // [sp+B0h] [bp-14h]@1
  int v70; // [sp+C0h] [bp-4h]@13
  int v71; // [sp+D4h] [bp+10h]@53

  v69 = (unsigned int)&v52 ^ __security_cookie;
  v61 = a2;
  v54 = a5;
  v57 = a11;
  v11 = a11 && (*(_BYTE *)a7 == 43 || *(_BYTE *)a7 == 45);
  v12 = *(_DWORD *)(a5 + 20) & 0x3000;
  v52 = v11;
  if ( v12 == 12288 )
  {
    v14 = v11 + 2;
    v13 = (int)"pP";
    if ( v11 + 2 <= a11 )
    {
      if ( *(_BYTE *)(a7 + v11) == 48 )
      {
        v15 = *(_BYTE *)(a7 + v11 + 1);
        if ( v15 == 120 || v15 == 88 )
        {
          v11 += 2;
          v52 = v14;
        }
      }
    }
  }
  else
  {
    v13 = (int)"eE";
  }
  v59 = sub_10030BF0(a7, v13);
  v62 = 46;
  LOBYTE(v62) = *(_BYTE *)*sub_10030BC0(a7, v11);
  v55 = sub_10030BF0(a7, (int)&v62);
  v16 = sub_10017D70(a5, (int)&v56);
  v70 = 0;
  v17 = sub_10017B50(v18, a7, v11, v16);
  v70 = -1;
  v53 = v17;
  if ( v56 )
  {
    v19 = (*(int (**)(void))(*(_DWORD *)v56 + 8))();
    if ( v19 )
      (**(void (__stdcall ***)(_DWORD))v19)(1);
  }
  LOBYTE(v60) = (*(int (__stdcall **)(signed int))(*(_DWORD *)v53 + 32))(48);
  v65 = 15;
  v64 = 0;
  LOBYTE(v63) = 0;
  loc_10018220(&v63, v57, 0);
  v70 = 1;
  v20 = (int *)&v63;
  if ( v65 >= 0x10 )
    v20 = (int *)v63;
  (*(void (__thiscall **)(int, int, unsigned int, int *))(*(_DWORD *)v53 + 28))(v53, a7, a7 + v57, v20);
  v22 = sub_10017D70(a5, (int)&v56);
  LOBYTE(v70) = 2;
  v23 = sub_100171B0(v24, a7, v11, v22);
  LOBYTE(v70) = 1;
  v21 = (void *)v23;
  v53 = v23;
  if ( v56 )
  {
    v25 = (*(int (**)(void))(*(_DWORD *)v56 + 8))();
    if ( v25 )
      (**(void (__stdcall ***)(_DWORD))v25)(1);
  }
  sub_10016CF0(v21, (int)&v66);
  LOBYTE(v70) = 3;
  LOBYTE(v58) = (*(int (__thiscall **)(void *))(*(_DWORD *)v21 + 16))(v21);
  if ( v55 == v57 )
  {
    v26 = v59 + a8;
    loc_10016BE0(&v63, v59, a8, v60);
  }
  else
  {
    v30 = v60;
    v26 = v55 + a8;
    loc_10016BE0(&v63, v59, a10, v60);
    loc_10016BE0(&v63, v55 + 1, a9, v30);
    v31 = (*(int (__thiscall **)(int))(*(_DWORD *)v53 + 12))(v53);
    v28 = v55;
    v29 = v31;
    v27 = (int *)&v63;
    if ( v65 >= 0x10 )
      v27 = (int *)v63;
    *((_BYTE *)v27 + v55) = v29;
    loc_10016BE0(&v63, v28, a8, v30);
    v11 = v52;
  }
  v32 = (int *)&v66;
  if ( v68 >= 0x10 )
    v32 = (int *)v66;
  for ( i = *(_BYTE *)v32; *(_BYTE *)v32 != 127; i = *(_BYTE *)v32 )
  {
    if ( i <= 0 )
      break;
    if ( i >= (unsigned int)(v26 - v11) )
      break;
    v26 -= i;
    loc_10016BE0(&v63, v26, 1, v58);
    if ( *((_BYTE *)v32 + 1) > 0 )
      v32 = (int *)((char *)v32 + 1);
  }
  v36 = v54;
  v34 = *(_DWORD *)(v54 + 36) == 0;
  v35 = *(_DWORD *)(v54 + 36) < 0;
  v58 = v64;
  if ( v35 || v35 | v34 && !*(_DWORD *)(v54 + 32) || (v37 = *(_DWORD *)(v54 + 32), v37 <= v64) )
    v38 = 0;
  else
    v38 = v37 - v64;
  v39 = *(_DWORD *)(v54 + 20) & 0x1C0;
  if ( v39 == 64 )
  {
    v45 = (unsigned __int8 *)&v63;
    if ( v65 >= 0x10 )
      v45 = (unsigned __int8 *)v63;
    v42 = sub_10015410(a1, (int)&v54, a3, a4, v45, v11);
  }
  else
  {
    if ( v39 == 256 )
    {
      v43 = (unsigned __int8 *)&v63;
      if ( v65 >= 0x10 )
        v43 = (unsigned __int8 *)v63;
      v44 = sub_10015410(a1, (int)&v54, a3, a4, v43, v11);
      v42 = sub_10015490(a1, (int)&v54, *(_DWORD *)v44, *(_DWORD *)(v44 + 4), a6, v38);
      v38 = 0;
    }
    else
    {
      v41 = sub_10015490(a1, (int)&v54, a3, a4, a6, v38);
      v38 = 0;
      v40 = (unsigned __int8 *)&v63;
      if ( v65 >= 0x10 )
        v40 = (unsigned __int8 *)v63;
      v42 = sub_10015410(a1, (int)&v54, *(_DWORD *)v41, *(_DWORD *)(v41 + 4), v40, v11);
    }
  }
  v47 = *(_DWORD *)v42;
  v52 = *(_DWORD *)(v42 + 4);
  v46 = (int *)&v63;
  if ( v65 >= 0x10 )
    v46 = (int *)v63;
  v49 = sub_10015410(a1, (int)&v54, v47, v52, (unsigned __int8 *)v46 + v11, v58 - v11);
  v71 = *(_DWORD *)v49;
  v50 = *(_DWORD *)(v49 + 4);
  *(_DWORD *)(v36 + 32) = 0;
  *(_DWORD *)(v36 + 36) = 0;
  v48 = v61;
  sub_10015490(a1, v61, v71, v50, a6, v38);
  if ( v68 >= 0x10 )
    sub_1002A4AA(v66);
  v68 = 15;
  v67 = 0;
  LOBYTE(v66) = 0;
  if ( v65 >= 0x10 )
    sub_1002A4AA(v63);
  return v48;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10014FE0) --------------------------------------------------------
int __cdecl sub_10014FE0(int a1, int a2, int a3, __int16 a4)
{
  int v4; // eax@1
  int v5; // eax@6
  int v6; // edx@8
  int result; // eax@9

  *(_BYTE *)a2 = 37;
  v4 = a2 + 1;
  if ( a4 & 0x20 )
  {
    *(_BYTE *)v4 = 43;
    v4 = a2 + 2;
  }
  if ( a4 & 8 )
    *(_BYTE *)v4++ = 35;
  if ( *(_BYTE *)a3 == 76 )
  {
    *(_WORD *)v4 = 13897;
    *(_BYTE *)(v4 + 2) = 52;
    v5 = v4 + 3;
  }
  else
  {
    *(_BYTE *)v4 = *(_BYTE *)a3;
    v5 = v4 + 1;
  }
  v6 = a4 & 0xE00;
  if ( v6 == 1024 )
  {
    *(_BYTE *)v5 = 111;
    *(_BYTE *)(v5 + 1) = 0;
    result = a2;
  }
  else
  {
    if ( v6 == 2048 )
    {
      *(_BYTE *)v5 = ~(8 * a4) & 0x20 | 0x58;
      *(_BYTE *)(v5 + 1) = 0;
      result = a2;
    }
    else
    {
      *(_BYTE *)v5 = *(_BYTE *)(a3 + 1);
      *(_BYTE *)(v5 + 1) = 0;
      result = a2;
    }
  }
  return result;
}

//----- (10015070) --------------------------------------------------------
int __cdecl sub_10015070(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8)
{
  int v8; // edi@1
  int v9; // ebx@4
  char v10; // cl@9
  int v11; // eax@12
  int v12; // eax@12
  int v13; // edx@12
  int v14; // eax@13
  int *v15; // eax@15
  void *v16; // esi@17
  int v17; // eax@17
  int v18; // eax@17
  int v19; // edx@17
  int v20; // eax@18
  int *v21; // esi@20
  char i; // al@24
  unsigned __int8 v23; // zf@30
  unsigned __int8 v24; // sf@30
  int v25; // esi@30
  unsigned int v26; // edi@33
  int v27; // edi@34
  int v28; // eax@36
  int v29; // edx@38
  unsigned __int8 *v30; // ecx@38
  int v31; // eax@40
  unsigned __int8 *v32; // eax@41
  int v33; // eax@43
  unsigned __int8 *v34; // eax@44
  int *v35; // eax@47
  int v36; // edx@47
  int v37; // esi@49
  int v38; // eax@49
  int v39; // ST0C_4@49
  int v41; // [sp+28h] [bp-5Ch]@1
  int v42; // [sp+2Ch] [bp-58h]@12
  int v43; // [sp+30h] [bp-54h]@1
  int v44; // [sp+38h] [bp-4Ch]@12
  int v45; // [sp+3Ch] [bp-48h]@1
  void *v46; // [sp+40h] [bp-44h]@15
  unsigned int v47; // [sp+50h] [bp-34h]@15
  unsigned int v48; // [sp+54h] [bp-30h]@15
  void *v49; // [sp+58h] [bp-2Ch]@20
  int v50; // [sp+68h] [bp-1Ch]@51
  unsigned int v51; // [sp+6Ch] [bp-18h]@20
  unsigned int v52; // [sp+70h] [bp-14h]@1
  int v53; // [sp+80h] [bp-4h]@12
  int v54; // [sp+94h] [bp+10h]@49

  v52 = (unsigned int)&v41 ^ __security_cookie;
  v8 = a8;
  v45 = a2;
  v43 = a5;
  v41 = a7;
  v9 = a8 && (*(_BYTE *)a7 == 43 || *(_BYTE *)a7 == 45);
  if ( (*(_DWORD *)(a5 + 20) & 0xE00) == 2048 )
  {
    if ( v9 + 2 <= (unsigned int)a8 )
    {
      if ( *(_BYTE *)(a7 + v9) == 48 )
      {
        v10 = *(_BYTE *)(a7 + v9 + 1);
        if ( v10 == 120 || v10 == 88 )
          v9 += 2;
      }
    }
  }
  v11 = sub_10017D70(a5, (int)&v44);
  v53 = 0;
  v12 = sub_10017B50(v13, v9, a8, v11);
  v53 = -1;
  v42 = v12;
  if ( v44 )
  {
    v14 = (*(int (**)(void))(*(_DWORD *)v44 + 8))();
    if ( v14 )
      (**(void (__thiscall ***)(_DWORD, _DWORD))v14)(v14, 1);
  }
  v48 = 15;
  v47 = 0;
  LOBYTE(v46) = 0;
  loc_10018220(&v46, a8, 0);
  v53 = 1;
  v15 = (int *)&v46;
  if ( v48 >= 0x10 )
    v15 = (int *)v46;
  (*(void (__thiscall **)(int, int, int, int *))(*(_DWORD *)v42 + 28))(v42, v41, a8 + v41, v15);
  v17 = sub_10017D70(a5, (int)&v41);
  LOBYTE(v53) = 2;
  v18 = sub_100171B0(v19, v9, a8, v17);
  LOBYTE(v53) = 1;
  v16 = (void *)v18;
  v44 = v18;
  if ( v41 )
  {
    v20 = (*(int (**)(void))(*(_DWORD *)v41 + 8))();
    if ( v20 )
      (**(void (__thiscall ***)(_DWORD, _DWORD))v20)(v20, 1);
  }
  sub_10016CF0(v16, (int)&v49);
  LOBYTE(v53) = 3;
  v21 = (int *)&v49;
  if ( v51 >= 0x10 )
    v21 = (int *)v49;
  if ( *(_BYTE *)v21 != 127 )
  {
    if ( *(_BYTE *)v21 > 0 )
    {
      LOBYTE(v41) = (*(int (__thiscall **)(int))(*(_DWORD *)v44 + 16))(v44);
      for ( i = *(_BYTE *)v21; *(_BYTE *)v21 != 127; i = *(_BYTE *)v21 )
      {
        if ( i <= 0 )
          break;
        if ( i >= (unsigned int)(v8 - v9) )
          break;
        v8 -= i;
        loc_10016BE0(&v46, v8, 1, v41);
        if ( *((_BYTE *)v21 + 1) > 0 )
          v21 = (int *)((char *)v21 + 1);
      }
    }
  }
  v25 = v43;
  v23 = *(_DWORD *)(v43 + 36) == 0;
  v24 = *(_DWORD *)(v43 + 36) < 0;
  v41 = v47;
  if ( v24 || v24 | v23 && !*(_DWORD *)(v43 + 32) || (v26 = *(_DWORD *)(v43 + 32), v26 <= v47) )
    v27 = 0;
  else
    v27 = v26 - v47;
  v28 = *(_DWORD *)(v43 + 20) & 0x1C0;
  if ( v28 == 64 )
  {
    v34 = (unsigned __int8 *)&v46;
    if ( v48 >= 0x10 )
      v34 = (unsigned __int8 *)v46;
    v31 = sub_10015410(a1, (int)&v43, a3, a4, v34, v9);
  }
  else
  {
    if ( v28 == 256 )
    {
      v32 = (unsigned __int8 *)&v46;
      if ( v48 >= 0x10 )
        v32 = (unsigned __int8 *)v46;
      v33 = sub_10015410(a1, (int)&v43, a3, a4, v32, v9);
      v31 = sub_10015490(a1, (int)&v43, *(_DWORD *)v33, *(_DWORD *)(v33 + 4), a6, v27);
      v27 = 0;
    }
    else
    {
      v29 = sub_10015490(a1, (int)&v43, a3, a4, a6, v27);
      v27 = 0;
      v30 = (unsigned __int8 *)&v46;
      if ( v48 >= 0x10 )
        v30 = (unsigned __int8 *)v46;
      v31 = sub_10015410(a1, (int)&v43, *(_DWORD *)v29, *(_DWORD *)(v29 + 4), v30, v9);
    }
  }
  v36 = *(_DWORD *)v31;
  v42 = *(_DWORD *)(v31 + 4);
  v35 = (int *)&v46;
  if ( v48 >= 0x10 )
    v35 = (int *)v46;
  v38 = sub_10015410(a1, (int)&v43, v36, v42, (unsigned __int8 *)v35 + v9, v41 - v9);
  v54 = *(_DWORD *)v38;
  v39 = *(_DWORD *)(v38 + 4);
  *(_DWORD *)(v25 + 32) = 0;
  *(_DWORD *)(v25 + 36) = 0;
  v37 = v45;
  sub_10015490(a1, v45, v54, v39, a6, v27);
  if ( v51 >= 0x10 )
    sub_1002A4AA(v49);
  v51 = 15;
  v50 = 0;
  LOBYTE(v49) = 0;
  if ( v48 >= 0x10 )
    sub_1002A4AA(v46);
  return v37;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10015410) --------------------------------------------------------
int __cdecl sub_10015410(int a1, int a2, int a3, int a4, unsigned __int8 *a5, int a6)
{
  int result; // eax@1
  unsigned __int8 *v7; // ebx@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edx@4
  int v11; // eax@5
  int v12; // ecx@5
  int v13; // edx@5
  unsigned __int8 v14; // [sp+13h] [bp-1h]@3

  result = a2;
  v7 = a5;
  v9 = a4;
  v8 = a6;
  if ( a6 )
  {
    do
    {
      if ( !v9
        || ((v14 = *v7, !**(_DWORD **)(v9 + 32)) || (v10 = *(_DWORD *)(v9 + 48), *(_DWORD *)v10 <= 0) ? (v11 = (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)v9 + 12))(v9, *v7)) : (--*(_DWORD *)v10, v12 = *(_DWORD *)(v9 + 32), v13 = *(_DWORD *)v12, ++*(_DWORD *)v12, *(_BYTE *)v13 = v14, v11 = v14),
            v9 = a4,
            v11 == -1) )
        LOBYTE(a3) = 1;
      ++v7;
      --v8;
    }
    while ( v8 );
    result = a2;
  }
  *(_DWORD *)(result + 4) = v9;
  *(_DWORD *)result = a3;
  return result;
}

//----- (10015490) --------------------------------------------------------
int __cdecl sub_10015490(int a1, int a2, int a3, int a4, unsigned __int8 a5, int a6)
{
  int result; // eax@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // ecx@4
  int v10; // eax@5
  int v11; // ecx@5
  int v12; // edx@5

  result = a2;
  v8 = a4;
  v7 = a6;
  if ( a6 )
  {
    do
    {
      if ( !v8
        || (!**(_DWORD **)(v8 + 32) || (v9 = *(_DWORD *)(v8 + 48), *(_DWORD *)v9 <= 0) ? (v10 = (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)v8 + 12))(
                                                                                                  v8,
                                                                                                  a5)) : (--*(_DWORD *)v9, v11 = *(_DWORD *)(v8 + 32), v12 = *(_DWORD *)v11, ++*(_DWORD *)v11, *(_BYTE *)v12 = a5, v10 = a5),
            v8 = a4,
            v10 == -1) )
        LOBYTE(a3) = 1;
      --v7;
    }
    while ( v7 );
    result = a2;
  }
  *(_DWORD *)(result + 4) = v8;
  *(_DWORD *)result = a3;
  return result;
}

//----- (10015510) --------------------------------------------------------
int __fastcall sub_10015510(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@1
  int *v6; // eax@2
  int v7; // edi@5
  char v9; // [sp+Ch] [bp-8h]@3
  unsigned int v10; // [sp+10h] [bp-4h]@1
  int v11; // [sp+14h] [bp+0h]@1

  v10 = (unsigned int)&v11 ^ __security_cookie;
  v5 = a1;
  v4 = 0;
  if ( *(_DWORD *)a1 )
  {
    v6 = (int *)**(_DWORD **)a1;
    if ( v6 )
    {
      v4 = *v6;
    }
    else
    {
      sub_10029A76(a2, (int)&v9, 0, a1, 3);
      sub_10029AD2(&v9);
    }
  }
  v7 = *(_DWORD *)(v5 + 8) - 1;
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  if ( v4 )
  {
    if ( *(_DWORD *)v4 )
    {
      *(_DWORD *)a3 = **(_DWORD **)v4;
    }
    else
    {
      sub_10029A76(a2, (int)&v9, v4, v7, 3);
      sub_10029AD2(&v9);
    }
  }
  *(_DWORD *)(a3 + 8) = v7;
  return a3;
}
// 10074200: using guessed type int __security_cookie;

//----- (100155A0) --------------------------------------------------------
int __usercall sub_100155A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int result; // eax@1

  result = sub_1002ADB1(a1, a2, a3, a4, 40);
  JUMPOUT(result, 0, *(unsigned int *)sub_10029530);
  *(_DWORD *)result = result;
  if ( result != -4 )
    *(_DWORD *)(result + 4) = result;
  if ( result != -8 )
    *(_DWORD *)(result + 8) = result;
  *(_WORD *)(result + 12) = 257;
  return result;
}

//----- (100155D0) --------------------------------------------------------
int __fastcall sub_100155D0(int a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@2
  int v5; // esi@3
  char v6; // al@4
  int v7; // eax@6
  int v8; // esi@6
  unsigned int v9; // eax@7
  int result; // eax@10

  v3 = a1;
  if ( *(_BYTE *)a2 )
  {
    v5 = a2;
    a1 = a2 + 1;
    do
      v6 = *(_BYTE *)v5++;
    while ( v6 );
    v4 = v5 - a1;
  }
  else
  {
    v4 = 0;
  }
  v7 = loc_10015E50(a3, a1, a2, v4);
  v8 = v7;
  *(_DWORD *)(v3 + 20) = 15;
  *(_DWORD *)(v3 + 16) = 0;
  *(_BYTE *)v3 = 0;
  if ( *(_DWORD *)(v7 + 20) >= 0x10u )
  {
    *(_DWORD *)v3 = *(_DWORD *)v7;
    *(_DWORD *)v7 = 0;
  }
  else
  {
    v9 = *(_DWORD *)(v7 + 16) + 1;
    if ( v9 )
      sub_1002A4B0((void *)v3, (const void *)v8, v9);
  }
  *(_DWORD *)(v3 + 16) = *(_DWORD *)(v8 + 16);
  *(_DWORD *)(v3 + 20) = *(_DWORD *)(v8 + 20);
  *(_DWORD *)(v8 + 20) = 15;
  *(_DWORD *)(v8 + 16) = 0;
  result = v3;
  *(_BYTE *)v8 = 0;
  return result;
}

//----- (10015660) --------------------------------------------------------
int __fastcall sub_10015660(int a1, int a2, const char *a3)
{
  int v3; // edi@1
  unsigned int v4; // esi@2
  int v5; // eax@4
  int v6; // esi@4
  unsigned int v7; // eax@5
  int result; // eax@8

  v3 = a1;
  if ( *a3 )
    v4 = strlen(a3);
  else
    v4 = 0;
  v5 = loc_10014700(a2, a3, v4);
  v6 = v5;
  *(_DWORD *)(v3 + 20) = 15;
  *(_DWORD *)(v3 + 16) = 0;
  *(_BYTE *)v3 = 0;
  if ( *(_DWORD *)(v5 + 20) >= 0x10u )
  {
    *(_DWORD *)v3 = *(_DWORD *)v5;
    *(_DWORD *)v5 = 0;
  }
  else
  {
    v7 = *(_DWORD *)(v5 + 16) + 1;
    if ( v7 )
      sub_1002A4B0((void *)v3, (const void *)v6, v7);
  }
  *(_DWORD *)(v3 + 16) = *(_DWORD *)(v6 + 16);
  *(_DWORD *)(v3 + 20) = *(_DWORD *)(v6 + 20);
  *(_DWORD *)(v6 + 20) = 15;
  *(_DWORD *)(v6 + 16) = 0;
  result = v3;
  *(_BYTE *)v6 = 0;
  return result;
}

//----- (10015700) --------------------------------------------------------
#error "100159A3: positive sp value has been found (funcsize=219)"

//----- (100159B0) --------------------------------------------------------
int __usercall sub_100159B0<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4)
{
  int v4; // edx@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // ecx@5
  int v8; // esi@6
  int v9; // eax@10
  int v10; // edx@17
  int v11; // ecx@17
  char v13; // [sp+Ch] [bp-2Ch]@16
  int v14; // [sp+18h] [bp-20h]@1
  int v15; // [sp+1Ch] [bp-1Ch]@1
  char v16; // [sp+20h] [bp-18h]@1
  char v17; // [sp+24h] [bp-14h]@2
  unsigned int v18; // [sp+28h] [bp-10h]@1
  int v19; // [sp+34h] [bp-4h]@1
  int v20; // [sp+38h] [bp+0h]@1

  v18 = (unsigned int)&v20 ^ __security_cookie;
  v14 = a4;
  sub_10029A76(a1, (int)&v16, a2, a3, 0);
  v19 = 0;
  v6 = dword_10077A88;
  v5 = dword_100773C0;
  v15 = dword_100773C0;
  if ( !dword_10077A88 )
  {
    sub_10029A76(v4, (int)&v17, dword_100773C0, dword_10077A88, dword_10077A88);
    if ( dword_10077A88 == v6 )
    {
      ++dword_100761E4;
      dword_10077A88 = dword_100761E4;
    }
    sub_10029AD2(&v17);
    v6 = dword_10077A88;
  }
  v7 = *(_DWORD *)a4;
  if ( (unsigned int)v6 >= *(_DWORD *)(*(_DWORD *)a4 + 12) )
  {
    v8 = 0;
  }
  else
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v7 + 8) + 4 * v6);
    if ( v8 )
      goto LABEL_18;
  }
  if ( !*(_BYTE *)(v7 + 20) )
    goto LABEL_12;
  v9 = sub_10029877();
  if ( (unsigned int)v6 < *(_DWORD *)(v9 + 12) )
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v9 + 8) + 4 * v6);
LABEL_12:
    if ( v8 )
      goto LABEL_18;
  }
  if ( v5 )
  {
    v8 = v5;
  }
  else
  {
    if ( sub_10015DA0(v7, v4, (int)&v15, v14) == -1 )
    {
      sub_1002AE51((int)&v13, (unsigned int)"bad cast");
      sub_100355DB((int)&v13, (int)&unk_1006D9A4);
    }
    v8 = v15;
    dword_100773C0 = v15;
    (*(void (__thiscall **)(int))(*(_DWORD *)v15 + 4))(v15);
    sub_1002984F(v10, v11, v5, v6, v8);
  }
LABEL_18:
  sub_10029AD2(&v16);
  return v8;
}
// 10074200: using guessed type int __security_cookie;
// 100761E4: using guessed type int dword_100761E4;
// 100773C0: using guessed type int dword_100773C0;
// 10077A88: using guessed type int dword_10077A88;

//----- (10015AE0) --------------------------------------------------------
int __thiscall sub_10015AE0(void *this, int a2, int a3)
{
  int v3; // edx@1
  int v4; // ecx@1
  void *v5; // ebx@1
  int i; // eax@2
  int result; // eax@4
  int v8; // ecx@4

  v5 = this;
  *(_DWORD *)(*(_DWORD *)this + 4) = sub_100163C0(this, *(_DWORD *)(*(_DWORD *)a2 + 4), *(_DWORD *)this, a3);
  v3 = *(_DWORD *)v5;
  *((_DWORD *)v5 + 1) = *(_DWORD *)(a2 + 4);
  v4 = *(_DWORD *)(v3 + 4);
  if ( *(_BYTE *)(v4 + 13) )
  {
    *(_DWORD *)v3 = v3;
    result = *(_DWORD *)v5;
    *(_DWORD *)(result + 8) = result;
  }
  else
  {
    for ( i = *(_DWORD *)v4; !*(_BYTE *)(i + 13); i = *(_DWORD *)i )
      v4 = i;
    *(_DWORD *)v3 = v4;
    v8 = *(_DWORD *)(*(_DWORD *)v5 + 4);
    for ( result = *(_DWORD *)(v8 + 8); !*(_BYTE *)(result + 13); result = *(_DWORD *)(result + 8) )
      v8 = result;
    *(_DWORD *)(*(_DWORD *)v5 + 8) = v8;
  }
  return result;
}

//----- (10015B60) --------------------------------------------------------
int __usercall sub_10015B60<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int **a4, int a5, int a6, int **a7, int a8, int a9, int **a10, int a11, int a12)
{
  int v12; // edi@1
  int v14; // [sp-2Ch] [bp-50h]@9
  int v15; // [sp-20h] [bp-44h]@5
  int v16; // [sp-14h] [bp-38h]@1
  char v17; // [sp+8h] [bp-1Ch]@3
  char v18; // [sp+Ch] [bp-18h]@7
  int v19; // [sp+10h] [bp-14h]@11
  unsigned int v20; // [sp+14h] [bp-10h]@1
  int v21; // [sp+20h] [bp-4h]@5
  int v22; // [sp+24h] [bp+0h]@1

  v20 = (unsigned int)&v22 ^ __security_cookie;
  v12 = a2;
  v16 = 0;
  if ( a10 )
  {
    if ( *a10 )
    {
      v16 = **a10;
    }
    else
    {
      sub_10029A76(a1, (int)&v17, a3, a2, 3);
      sub_10029AD2(&v17);
    }
  }
  v21 = 0;
  v15 = 0;
  if ( a7 )
  {
    if ( *a7 )
    {
      v15 = **a7;
    }
    else
    {
      sub_10029A76(a1, (int)&v18, a3, v12, 3);
      sub_10029AD2(&v18);
    }
  }
  LOBYTE(v21) = 1;
  v14 = 0;
  if ( a4 )
  {
    if ( *a4 )
    {
      v14 = **a4;
    }
    else
    {
      sub_10029A76(a1, (int)&v19, a3, v12, 3);
      sub_10029AD2(&v19);
    }
  }
  v21 = -1;
  sub_10016480(a1, v12, v12, v14, 0, a6, v15, 0, a9, v16, 0, a12);
  return v12;
}
// 10074200: using guessed type int __security_cookie;

//----- (10015C80) --------------------------------------------------------
int __usercall sub_10015C80<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int **a4, int a5, int a6, int **a7, int a8, int a9, int **a10, int a11, int a12)
{
  int v12; // edi@1
  int v14; // [sp-2Ch] [bp-50h]@9
  int v15; // [sp-20h] [bp-44h]@5
  int v16; // [sp-14h] [bp-38h]@1
  char v17; // [sp+8h] [bp-1Ch]@3
  char v18; // [sp+Ch] [bp-18h]@7
  int v19; // [sp+10h] [bp-14h]@11
  unsigned int v20; // [sp+14h] [bp-10h]@1
  int v21; // [sp+20h] [bp-4h]@5
  int v22; // [sp+24h] [bp+0h]@1

  v20 = (unsigned int)&v22 ^ __security_cookie;
  v12 = a2;
  v16 = 0;
  if ( a10 )
  {
    if ( *a10 )
    {
      v16 = **a10;
    }
    else
    {
      sub_10029A76(a1, (int)&v17, a3, a2, 3);
      sub_10029AD2(&v17);
    }
  }
  v21 = 0;
  v15 = 0;
  if ( a7 )
  {
    if ( *a7 )
    {
      v15 = **a7;
    }
    else
    {
      sub_10029A76(a1, (int)&v18, a3, v12, 3);
      sub_10029AD2(&v18);
    }
  }
  LOBYTE(v21) = 1;
  v14 = 0;
  if ( a4 )
  {
    if ( *a4 )
    {
      v14 = **a4;
    }
    else
    {
      sub_10029A76(a1, (int)&v19, a3, v12, 3);
      sub_10029AD2(&v19);
    }
  }
  v21 = -1;
  sub_10016570(v12, v12, v14, 0, a6, v15, 0, a9, v16, 0, a12);
  return v12;
}
// 10074200: using guessed type int __security_cookie;

//----- (10015DA0) --------------------------------------------------------
signed int __fastcall sub_10015DA0(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edx@3
  int v6; // esi@3
  int v7; // ecx@4
  int v8; // eax@5
  char v10; // [sp+10h] [bp-44h]@8
  int v11; // [sp+44h] [bp-10h]@1
  int v12; // [sp+50h] [bp-4h]@3

  v4 = 0;
  v11 = 0;
  if ( a3 )
  {
    if ( !*(_DWORD *)a3 )
    {
      v6 = sub_1002ADB1(a2, a1, 0, a3, 8);
      v12 = 0;
      if ( v6 )
      {
        v7 = *(_DWORD *)a4;
        if ( *(_DWORD *)a4 )
        {
          v8 = *(_DWORD *)(v7 + 24);
          if ( !v8 )
            v8 = v7 + 28;
        }
        else
        {
          v8 = (int)&unk_1006823C;
        }
        sub_100178F0(v5, (int)&v10, 0, v8);
        v4 = 1;
        *(_DWORD *)(v6 + 4) = 0;
        *(_DWORD *)v6 = &off_10061710;
      }
      else
      {
        v6 = 0;
      }
      *(_DWORD *)a3 = v6;
      if ( v4 & 1 )
        sub_100179E0(&v10, v4);
    }
  }
  return 4;
}
// 10061710: using guessed type int (__stdcall *off_10061710)(char);

//----- (100160E0) --------------------------------------------------------
int __stdcall sub_100160E0(int a1)
{
  int v1; // edx@1
  int v2; // ebx@1
  int v3; // eax@4
  bool v4; // eax@7
  char v6; // [sp+0h] [bp-2Ch]@1
  int v7; // [sp+10h] [bp-1Ch]@1
  int v8; // [sp+14h] [bp-18h]@1
  int v9; // [sp+18h] [bp-14h]@1
  char *v10; // [sp+1Ch] [bp-10h]@1
  int v11; // [sp+28h] [bp-4h]@1

  v10 = &v6;
  v2 = loc_100166D0();
  v11 = 0;
  v9 = v2;
  *(_WORD *)(v2 + 12) = 0;
  v8 = v2 + 16;
  v7 = v2 + 16;
  LOBYTE(v11) = 1;
  if ( v2 != -16 )
  {
    if ( *(_DWORD *)(a1 + 4) && *(_DWORD *)a1 )
      v3 = loc_1000FED0(*(_DWORD *)a1, -1);
    else
      v3 = *(_DWORD *)a1;
    *(_DWORD *)(v2 + 16) = v3;
    if ( *(_DWORD *)a1 )
      v4 = *(_DWORD *)(a1 + 4) != 0;
    else
      v4 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(v2 + 20) = v4;
    LOBYTE(v11) = 2;
    sub_10010010(v2 + 24, v1, a1 + 8);
  }
  return v2;
}

//----- (1001618B) --------------------------------------------------------
void __usercall sub_1001618B(int a1<ebp>)
{
  sub_1002A4AA(*(LPVOID *)(a1 - 20));
  sub_100355DB(0, 0);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_100161A0);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100161A0) --------------------------------------------------------
int __thiscall sub_100161A0(int this, int a2, int a3, int a4, int a5)
{
  char v5; // zf@1
  int v7; // edi@3
  int v8; // ecx@4
  int v9; // esi@7
  int v10; // ebx@9
  int v11; // ecx@10
  int v12; // ebx@10
  int v13; // esi@12
  int v14; // ebx@16
  int v15; // eax@21
  char v16; // [sp+0h] [bp-38h]@1
  char v17; // [sp+10h] [bp-28h]@21
  int v18; // [sp+14h] [bp-24h]@1
  int v19; // [sp+18h] [bp-20h]@1
  int v20; // [sp+1Ch] [bp-1Ch]@10
  int v21; // [sp+20h] [bp-18h]@1
  int v22; // [sp+24h] [bp-14h]@1
  char *v23; // [sp+28h] [bp-10h]@1
  int v24; // [sp+34h] [bp-4h]@1

  v23 = &v16;
  v21 = this;
  v24 = 0;
  v5 = *(_DWORD *)(this + 4) == 0;
  v19 = a2;
  v22 = a5;
  v18 = a5;
  if ( v5 )
  {
    sub_10016710(this, a2, a2, 1, *(_DWORD *)this, a5, a5);
    return a2;
  }
  v7 = *(_DWORD *)this;
  if ( a3 == **(_DWORD **)this )
  {
    if ( sub_10013390(a4, a3 + 16) )
    {
      sub_10016710(v21, a2, a2, 1, a3, v8, v22);
      return a2;
    }
  }
  else
  {
    if ( a3 == v7 )
    {
      v9 = *(_DWORD *)(v7 + 8);
      if ( sub_10013390(v9 + 16, a4) )
      {
        sub_10016710(v21, a2, a2, 0, v9, v8, v22);
        return a2;
      }
    }
    else
    {
      v10 = a4;
      if ( sub_10013390(a4, a3 + 16) )
      {
        v20 = a3;
        sub_10013460(&v20);
        v12 = v20;
        if ( sub_10013390(v20 + 16, a4) )
        {
          if ( *(_BYTE *)(*(_DWORD *)(v12 + 8) + 13) )
          {
            v13 = v19;
            sub_10016710(v21, v12, v19, 0, v12, v11, v22);
          }
          else
          {
            v13 = v19;
            sub_10016710(v21, v12, v19, 1, a3, v11, v22);
          }
          return v13;
        }
        v10 = a4;
      }
      if ( sub_10013390(a3 + 16, v10) )
      {
        v20 = a3;
        sub_10013410(&v20);
        v14 = v20;
        if ( v20 == v7 || sub_10013390(a4, v20 + 16) )
        {
          if ( *(_BYTE *)(*(_DWORD *)(a3 + 8) + 13) )
          {
            v13 = v19;
            sub_10016710(v21, v14, v19, 0, a3, v8, v22);
          }
          else
          {
            v13 = v19;
            sub_10016710(v21, v14, v19, 1, v14, v8, v22);
          }
          return v13;
        }
      }
    }
  }
  v24 = -1;
  v15 = sub_10016980((void *)v21, (int)&v17, v8, a4, v22);
  v13 = v19;
  *(_DWORD *)v19 = *(_DWORD *)v15;
  return v13;
}

//----- (100163A0) --------------------------------------------------------
void __thiscall sub_100163A0(int this)
{
  if ( this )
  {
    *(_DWORD *)(this + 32) = 15;
    *(_DWORD *)(this + 28) = 0;
    *(_BYTE *)(this + 12) = 0;
  }
}

//----- (100163C0) --------------------------------------------------------
int __thiscall sub_100163C0(void *this, int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // eax@2
  int v6; // ebx@2
  char v7; // zf@2
  char v9; // [sp+0h] [bp-24h]@1
  void *v10; // [sp+10h] [bp-14h]@1
  char *v11; // [sp+14h] [bp-10h]@1
  int v12; // [sp+20h] [bp-4h]@2

  v11 = &v9;
  v10 = this;
  v4 = *(_DWORD *)this;
  if ( !*(_BYTE *)(a2 + 13) )
  {
    v5 = sub_100160E0(a2 + 16);
    v6 = v5;
    *(_DWORD *)(v5 + 4) = a3;
    *(_BYTE *)(v5 + 12) = *(_BYTE *)(a2 + 12);
    v7 = *(_BYTE *)(v4 + 13) == 0;
    v12 = 0;
    if ( !v7 )
      v4 = v5;
    *(_DWORD *)v5 = sub_100163C0(*(_DWORD *)a2, v5, a4);
    *(_DWORD *)(v6 + 8) = sub_100163C0(*(_DWORD *)(a2 + 8), v6, a4);
  }
  return v4;
}

//----- (10016480) --------------------------------------------------------
int __usercall sub_10016480<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
  int v12; // eax@1
  int v13; // ebx@1
  int v14; // eax@3
  int v15; // edx@3
  int v16; // eax@5
  int v18; // ecx@5
  int v19; // eax@5
  int v22; // [sp-8h] [bp-14h]@2
  char v23; // [sp+4h] [bp-8h]@13
  unsigned int v24; // [sp+8h] [bp-4h]@1
  int v25; // [sp+Ch] [bp+0h]@1
  int v26; // [sp+28h] [bp+1Ch]@3

  v24 = (unsigned int)&v25 ^ __security_cookie;
  v12 = a9;
  v13 = a2;
  if ( a6 != a9 )
  {
    v22 = a3;
    do
    {
      v15 = a7;
      v14 = v12 - 1;
      v26 = v14;
      if ( a7 )
        v15 = *(_DWORD *)a7;
      v18 = v14 & (*(_DWORD *)(v15 + 8) - 1);
      v19 = *(_DWORD *)(v15 + 4);
      a1 = a10;
      _ESI = *(_DWORD *)(v19 + 4 * v18);
      v16 = a12-- - 1;
      if ( a10 )
        a1 = *(_DWORD *)a10;
      __asm { movq    xmm0, qword ptr [esi] }
      _EDI = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * (v16 & (*(_DWORD *)(a1 + 8) - 1)));
      __asm { movq    qword ptr [edi], xmm0 }
      *(_DWORD *)(_EDI + 8) = *(_DWORD *)(_ESI + 8);
      if ( _EDI + 12 != _ESI + 12 )
        loc_1000AB40(_EDI + 12, _ESI + 12, 0, -1);
      *(_DWORD *)(_EDI + 36) = *(_DWORD *)(_ESI + 36);
      v12 = v26;
    }
    while ( a6 != v26 );
    a3 = v22;
  }
  *(_DWORD *)v13 = 0;
  *(_DWORD *)(v13 + 4) = 0;
  if ( a10 )
  {
    if ( !*(_DWORD *)a10 )
    {
      sub_10029A76(a1, (int)&v23, v13, a3, 3);
      sub_10029AD2(&v23);
      *(_DWORD *)(v13 + 8) = a12;
      return v13;
    }
    *(_DWORD *)v13 = **(_DWORD **)a10;
  }
  *(_DWORD *)(v13 + 8) = a12;
  return v13;
}
// 10074200: using guessed type int __security_cookie;

//----- (10016570) --------------------------------------------------------
int __usercall sub_10016570<eax>(int a1<ecx>, int a2<edi>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  int v11; // eax@1
  int v12; // edx@1
  int v13; // ebx@1
  int v14; // esi@4
  int v15; // edi@7
  int v19; // [sp-8h] [bp-14h]@2
  char v20; // [sp+4h] [bp-8h]@15
  unsigned int v21; // [sp+8h] [bp-4h]@1
  int v22; // [sp+Ch] [bp+0h]@1

  v21 = (unsigned int)&v22 ^ __security_cookie;
  v11 = a5;
  v12 = a11;
  v13 = a1;
  if ( a5 != a8 )
  {
    v19 = a2;
    do
    {
      if ( a3 )
        v14 = *(_DWORD *)a3;
      else
        v14 = 0;
      if ( a9 )
        v15 = *(_DWORD *)a9;
      else
        v15 = 0;
      _ESI = *(_DWORD *)(*(_DWORD *)(v14 + 4) + 4 * (v11 & (*(_DWORD *)(v14 + 8) - 1)));
      __asm { movq    xmm0, qword ptr [esi] }
      _EDI = *(_DWORD *)(*(_DWORD *)(v15 + 4) + 4 * (v12 & (*(_DWORD *)(v15 + 8) - 1)));
      __asm { movq    qword ptr [edi], xmm0 }
      *(_DWORD *)(_EDI + 8) = *(_DWORD *)(_ESI + 8);
      if ( _EDI + 12 != _ESI + 12 )
        loc_1000AB40(_EDI + 12, _ESI + 12, 0, -1);
      *(_DWORD *)(_EDI + 36) = *(_DWORD *)(_ESI + 36);
      v11 = a5 + 1;
      v12 = a11++ + 1;
      a5 = v11;
    }
    while ( v11 != a8 );
    a2 = v19;
  }
  *(_DWORD *)v13 = 0;
  *(_DWORD *)(v13 + 4) = 0;
  if ( a9 )
  {
    if ( !*(_DWORD *)a9 )
    {
      sub_10029A76(v12, (int)&v20, v13, a2, 3);
      sub_10029AD2(&v20);
      *(_DWORD *)(v13 + 8) = a11;
      return v13;
    }
    *(_DWORD *)v13 = **(_DWORD **)a9;
  }
  *(_DWORD *)(v13 + 8) = v12;
  return v13;
}
// 10074200: using guessed type int __security_cookie;

//----- (10016660) --------------------------------------------------------
int __userpurge sub_10016660<eax>(int a1<ebx>, int a2)
{
  sub_100101D0(a2 + 24, a1);
  if ( *(_DWORD *)(a2 + 16) )
  {
    if ( *(_DWORD *)(a2 + 20) == 1 )
      sub_100309A2(a1, *(LPVOID *)(a2 + 16));
  }
  return sub_1002A4AA((LPVOID)a2);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10016710) --------------------------------------------------------
int __userpurge sub_10016710<eax>(int a1<ecx>, int a2<ebx>, int a3, char a4, int a5, int a6, int a7)
{
  unsigned int v7; // eax@1
  int v8; // edi@1
  int v9; // eax@13
  int v10; // edx@14
  int v11; // ecx@14
  int v12; // esi@14
  int v13; // edx@17
  int v14; // ecx@21
  int v15; // edx@25
  int v16; // ecx@25
  int v17; // esi@25
  int v18; // ecx@29
  int v19; // edx@35
  int v20; // ecx@35
  int v21; // ecx@39
  int v22; // ecx@47
  int result; // eax@53

  v8 = a1;
  v7 = *(_DWORD *)(a1 + 4);
  if ( v7 >= 0x6666665 )
  {
    v8 = a7;
    *(_DWORD *)&a4 = a7 + 16;
    sub_100101D0(a7 + 24, a2);
    if ( *(_DWORD *)(a7 + 16) )
    {
      if ( *(_DWORD *)(a7 + 20) == 1 )
        sub_100309A2(a2, *(LPVOID *)(a7 + 16));
    }
    sub_1002A4AA((LPVOID)a7);
    sub_10029585((int)"map/set<T> too long");
  }
  *(_DWORD *)(v8 + 4) = v7 + 1;
  *(_DWORD *)(a7 + 4) = a5;
  if ( a5 == *(_DWORD *)v8 )
  {
    *(_DWORD *)(*(_DWORD *)v8 + 4) = a7;
    **(_DWORD **)v8 = a7;
    *(_DWORD *)(*(_DWORD *)v8 + 8) = a7;
  }
  else
  {
    if ( a4 )
    {
      *(_DWORD *)a5 = a7;
      if ( a5 == **(_DWORD **)v8 )
        **(_DWORD **)v8 = a7;
    }
    else
    {
      *(_DWORD *)(a5 + 8) = a7;
      if ( a5 == *(_DWORD *)(*(_DWORD *)v8 + 8) )
        *(_DWORD *)(*(_DWORD *)v8 + 8) = a7;
    }
  }
  v9 = a7;
  while ( !*(_BYTE *)(*(_DWORD *)(v9 + 4) + 12) )
  {
    v11 = *(_DWORD *)(v9 + 4);
    v12 = *(_DWORD *)(v11 + 4);
    v10 = *(_DWORD *)v12;
    if ( v11 == *(_DWORD *)v12 )
    {
      v10 = *(_DWORD *)(v12 + 8);
      if ( *(_BYTE *)(v10 + 12) )
      {
        if ( v9 == *(_DWORD *)(v11 + 8) )
        {
          v9 = *(_DWORD *)(v9 + 4);
          v13 = *(_DWORD *)(v11 + 8);
          *(_DWORD *)(v11 + 8) = *(_DWORD *)v13;
          if ( !*(_BYTE *)(*(_DWORD *)v13 + 13) )
            *(_DWORD *)(*(_DWORD *)v13 + 4) = v9;
          *(_DWORD *)(v13 + 4) = *(_DWORD *)(v9 + 4);
          if ( v9 == *(_DWORD *)(*(_DWORD *)v8 + 4) )
          {
            *(_DWORD *)(*(_DWORD *)v8 + 4) = v13;
          }
          else
          {
            v14 = *(_DWORD *)(v9 + 4);
            if ( v9 == *(_DWORD *)v14 )
              *(_DWORD *)v14 = v13;
            else
              *(_DWORD *)(v14 + 8) = v13;
          }
          *(_DWORD *)v13 = v9;
          *(_DWORD *)(v9 + 4) = v13;
        }
        *(_BYTE *)(*(_DWORD *)(v9 + 4) + 12) = 1;
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 12) = 0;
        v15 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
        v17 = *(_DWORD *)v15;
        *(_DWORD *)v15 = *(_DWORD *)(*(_DWORD *)v15 + 8);
        v16 = *(_DWORD *)(v17 + 8);
        if ( !*(_BYTE *)(v16 + 13) )
          *(_DWORD *)(v16 + 4) = v15;
        *(_DWORD *)(v17 + 4) = *(_DWORD *)(v15 + 4);
        if ( v15 == *(_DWORD *)(*(_DWORD *)v8 + 4) )
        {
          *(_DWORD *)(*(_DWORD *)v8 + 4) = v17;
          *(_DWORD *)(v17 + 8) = v15;
        }
        else
        {
          v18 = *(_DWORD *)(v15 + 4);
          if ( v15 == *(_DWORD *)(v18 + 8) )
          {
            *(_DWORD *)(v18 + 8) = v17;
            *(_DWORD *)(v17 + 8) = v15;
          }
          else
          {
            *(_DWORD *)v18 = v17;
            *(_DWORD *)(v17 + 8) = v15;
          }
        }
LABEL_51:
        *(_DWORD *)(v15 + 4) = v17;
        continue;
      }
    }
    else
    {
      if ( *(_BYTE *)(v10 + 12) )
      {
        if ( v9 == *(_DWORD *)v11 )
        {
          v9 = *(_DWORD *)(v9 + 4);
          v19 = *(_DWORD *)v11;
          *(_DWORD *)v11 = *(_DWORD *)(*(_DWORD *)v11 + 8);
          v20 = *(_DWORD *)(v19 + 8);
          if ( !*(_BYTE *)(v20 + 13) )
            *(_DWORD *)(v20 + 4) = v9;
          *(_DWORD *)(v19 + 4) = *(_DWORD *)(v9 + 4);
          if ( v9 == *(_DWORD *)(*(_DWORD *)v8 + 4) )
          {
            *(_DWORD *)(*(_DWORD *)v8 + 4) = v19;
          }
          else
          {
            v21 = *(_DWORD *)(v9 + 4);
            if ( v9 == *(_DWORD *)(v21 + 8) )
              *(_DWORD *)(v21 + 8) = v19;
            else
              *(_DWORD *)v21 = v19;
          }
          *(_DWORD *)(v19 + 8) = v9;
          *(_DWORD *)(v9 + 4) = v19;
        }
        *(_BYTE *)(*(_DWORD *)(v9 + 4) + 12) = 1;
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 12) = 0;
        v15 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
        v17 = *(_DWORD *)(v15 + 8);
        *(_DWORD *)(v15 + 8) = *(_DWORD *)v17;
        if ( !*(_BYTE *)(*(_DWORD *)v17 + 13) )
          *(_DWORD *)(*(_DWORD *)v17 + 4) = v15;
        *(_DWORD *)(v17 + 4) = *(_DWORD *)(v15 + 4);
        if ( v15 == *(_DWORD *)(*(_DWORD *)v8 + 4) )
        {
          *(_DWORD *)(*(_DWORD *)v8 + 4) = v17;
        }
        else
        {
          v22 = *(_DWORD *)(v15 + 4);
          if ( v15 == *(_DWORD *)v22 )
            *(_DWORD *)v22 = v17;
          else
            *(_DWORD *)(v22 + 8) = v17;
        }
        *(_DWORD *)v17 = v15;
        goto LABEL_51;
      }
    }
    *(_BYTE *)(v11 + 12) = 1;
    *(_BYTE *)(v10 + 12) = 1;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 12) = 0;
    v9 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
  }
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)v8 + 4) + 12) = 1;
  result = a3;
  *(_DWORD *)a3 = a7;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10016980) --------------------------------------------------------
int __thiscall sub_10016980(void *this, int a2, int a3, int a4, int a5)
{
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // ebx@1
  int v9; // edi@1
  int v10; // esi@1
  char v11; // zf@1
  int v12; // edi@2
  int v13; // eax@4
  int v14; // ecx@4
  char v15; // dl@7
  int v16; // esi@17
  int result; // eax@20
  int v18; // ecx@20
  int v19; // eax@22
  char v20; // dl@26
  int v22; // ebx@33
  int v23; // edi@33
  char v24; // [sp-10h] [bp-40h]@19
  int v25; // [sp-Ch] [bp-3Ch]@19
  int v26; // [sp-8h] [bp-38h]@19
  int v27; // [sp-4h] [bp-34h]@19
  char v28; // [sp+0h] [bp-30h]@1
  int v29; // [sp+10h] [bp-20h]@1
  int v30; // [sp+14h] [bp-1Ch]@1
  int v31; // [sp+18h] [bp-18h]@1
  int v32; // [sp+1Ch] [bp-14h]@1
  char *v33; // [sp+20h] [bp-10h]@1
  int v34; // [sp+2Ch] [bp-4h]@1

  v33 = &v28;
  v9 = (int)this;
  v29 = (int)this;
  v34 = 0;
  v6 = *(_DWORD *)this;
  v8 = a4;
  v10 = *(_DWORD *)(*(_DWORD *)this + 4);
  v7 = v6;
  v11 = *(_BYTE *)(v10 + 13) == 0;
  _AL = 1;
  v30 = v6;
  v32 = v6;
  LOBYTE(v31) = 1;
  if ( v11 )
  {
    v12 = *(_DWORD *)a4;
    do
    {
      v7 = v10;
      v32 = v10;
      if ( v12 )
      {
        v14 = *(_DWORD *)(v10 + 16);
        v13 = v12;
        while ( *(_BYTE *)v13 == *(_BYTE *)v14 )
        {
          if ( !*(_BYTE *)v13 )
            goto LABEL_9;
          v15 = *(_BYTE *)(v13 + 1);
          if ( v15 != *(_BYTE *)(v14 + 1) )
            break;
          v13 += 2;
          v14 += 2;
          if ( !v15 )
          {
LABEL_9:
            v7 = v32;
            __asm { sets    al }
            goto LABEL_12;
          }
        }
        v7 = v32;
        __asm { sets    al }
      }
      else
      {
        _AL = *(_DWORD *)(a4 + 4) < *(_DWORD *)(v10 + 20);
      }
LABEL_12:
      LOBYTE(v31) = _AL;
      if ( _AL )
        v10 = *(_DWORD *)v10;
      else
        v10 = *(_DWORD *)(v10 + 8);
    }
    while ( !*(_BYTE *)(v10 + 13) );
    v6 = v30;
    v9 = v29;
  }
  v16 = v7;
  a4 = v7;
  if ( _AL )
  {
    if ( v7 == *(_DWORD *)v6 )
    {
      v27 = a5;
      v26 = v7;
      v25 = v7;
      v24 = 1;
LABEL_20:
      v18 = *(_DWORD *)sub_10016710(v9, v8, (int)&a4, v24, v25, v26, v27);
      result = a2;
      *(_DWORD *)a2 = v18;
      *(_BYTE *)(a2 + 4) = 1;
      return result;
    }
    sub_10013460(&a4);
    v16 = a4;
  }
  v19 = *(_DWORD *)(v16 + 16);
  if ( v19 )
  {
    v7 = *(_DWORD *)v8;
    while ( *(_BYTE *)v19 == *(_BYTE *)v7 )
    {
      if ( !*(_BYTE *)v19 )
        goto LABEL_28;
      v20 = *(_BYTE *)(v19 + 1);
      if ( v20 != *(_BYTE *)(v7 + 1) )
        break;
      v19 += 2;
      v7 += 2;
      if ( !v20 )
      {
LABEL_28:
        __asm { sets    al }
        goto LABEL_31;
      }
    }
    __asm { sets    al }
  }
  else
  {
    _AL = *(_DWORD *)(v16 + 20) < *(_DWORD *)(v8 + 4);
  }
LABEL_31:
  if ( _AL )
  {
    v27 = a5;
    v26 = v7;
    v25 = v32;
    v24 = v31;
    goto LABEL_20;
  }
  v22 = a5;
  v23 = a5 + 16;
  a4 = a5 + 16;
  LOBYTE(v34) = 1;
  sub_100101D0(a5 + 24, a5);
  if ( *(_DWORD *)v23 )
  {
    if ( *(_DWORD *)(v23 + 4) == 1 )
      sub_100309A2(v22, *(LPVOID *)v23);
  }
  sub_1002A4AA((LPVOID)v22);
  result = a2;
  *(_DWORD *)a2 = v16;
  *(_BYTE *)(a2 + 4) = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10016B40) --------------------------------------------------------
int __fastcall sub_10016B40(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@2
  int v5; // esi@2
  int result; // eax@10

  v3 = a2;
  if ( a1 == a2 )
  {
    result = a3;
  }
  else
  {
    v4 = a3;
    v5 = a1 + 16;
    do
    {
      if ( v4 )
      {
        *(_DWORD *)(v4 + 20) = 15;
        *(_DWORD *)(v4 + 16) = 0;
        *(_BYTE *)v4 = 0;
        if ( *(_DWORD *)(v5 + 4) >= 0x10u )
        {
          *(_DWORD *)v4 = *(_DWORD *)(v5 - 16);
          *(_DWORD *)(v5 - 16) = 0;
        }
        else
        {
          if ( *(_DWORD *)v5 != -1 )
            sub_1002A4B0((void *)v4, (const void *)(v5 - 16), *(_DWORD *)v5 + 1);
        }
        *(_DWORD *)(v4 + 16) = *(_DWORD *)v5;
        *(_DWORD *)(v4 + 20) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(v5 + 4) = 15;
        *(_DWORD *)v5 = 0;
        *(_BYTE *)(v5 - 16) = 0;
      }
      v5 += 24;
      v4 += 24;
    }
    while ( v5 - 16 != v3 );
    result = v4;
  }
  return result;
}

//----- (10016BC4) --------------------------------------------------------
int __thiscall sub_10016BC4(void *this)
{
  return nullsub_3(this + -*((_DWORD *)this - 1) - 72);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (10016BCF) --------------------------------------------------------
void *__thiscall sub_10016BCF(void *this, char a2)
{
  return sub_10012F00((char *)this - *((_DWORD *)this - 1), a2);
}

//----- (10016CF0) --------------------------------------------------------
int __thiscall sub_10016CF0(void *this, int a2)
{
  (*(void (__stdcall **)(int, _DWORD))(*(_DWORD *)this + 20))(a2, 0);
  return a2;
}

//----- (10016D10) --------------------------------------------------------
int __thiscall sub_10016D10(void *this, int a2)
{
  (*(void (__stdcall **)(int, _DWORD))(*(_DWORD *)this + 24))(a2, 0);
  return a2;
}

//----- (10016D30) --------------------------------------------------------
int __thiscall sub_10016D30(void *this, int a2)
{
  (*(void (__stdcall **)(int, _DWORD))(*(_DWORD *)this + 28))(a2, 0);
  return a2;
}

//----- (10016D50) --------------------------------------------------------
int __thiscall sub_10016D50(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  if ( this != a2 )
  {
    if ( *(_DWORD *)(this + 20) >= 0x10u )
      sub_1002A4AA(*(LPVOID *)this);
    *(_DWORD *)(v2 + 20) = 15;
    *(_DWORD *)(v2 + 16) = 0;
    *(_BYTE *)v2 = 0;
    if ( *(_DWORD *)(a2 + 20) >= 0x10u )
    {
      *(_DWORD *)v2 = *(_DWORD *)a2;
      *(_DWORD *)a2 = 0;
    }
    else
    {
      if ( *(_DWORD *)(a2 + 16) != -1 )
        sub_1002A4B0((void *)v2, (const void *)a2, *(_DWORD *)(a2 + 16) + 1);
    }
    *(_DWORD *)(v2 + 16) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(v2 + 20) = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(a2 + 20) = 15;
    *(_DWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10016DD0) --------------------------------------------------------
int __thiscall sub_10016DD0(int this, char a2)
{
  int v2; // esi@1
  void *v3; // ST08_4@1

  v2 = this;
  v3 = *(void **)(this + 8);
  *(_DWORD *)this = &off_10061740;
  sub_10030383(v3);
  sub_10030383(*(LPVOID *)(v2 + 16));
  sub_10030383(*(LPVOID *)(v2 + 20));
  *(_DWORD *)v2 = &off_10061664;
  if ( a2 & 1 )
    sub_1002A4AA((LPVOID)v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 10061664: using guessed type int (__stdcall *off_10061664)(char);
// 10061740: using guessed type int (__stdcall *off_10061740)(char);

//----- (10016E20) --------------------------------------------------------
char __thiscall sub_10016E20(int this)
{
  return *(_BYTE *)(this + 12);
}

//----- (10016E30) --------------------------------------------------------
char __thiscall sub_10016E30(int this)
{
  return *(_BYTE *)(this + 13);
}

//----- (10016E40) --------------------------------------------------------
int __thiscall sub_10016E40(int this, int a2)
{
  const char *v2; // edx@1
  int result; // eax@2

  v2 = *(const char **)(this + 8);
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  if ( *v2 )
  {
    loc_1000AEB0(a2, v2, strlen(v2));
    result = a2;
  }
  else
  {
    loc_1000AEB0(a2, v2, 0);
    result = a2;
  }
  return result;
}

//----- (10016EA0) --------------------------------------------------------
int __thiscall sub_10016EA0(int this, int a2)
{
  const char *v2; // edx@1
  int result; // eax@2

  v2 = *(const char **)(this + 16);
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  if ( *v2 )
  {
    loc_1000AEB0(a2, v2, strlen(v2));
    result = a2;
  }
  else
  {
    loc_1000AEB0(a2, v2, 0);
    result = a2;
  }
  return result;
}

//----- (10016F00) --------------------------------------------------------
int __thiscall sub_10016F00(int this, int a2)
{
  const char *v2; // edx@1
  int result; // eax@2

  v2 = *(const char **)(this + 20);
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  if ( *v2 )
  {
    loc_1000AEB0(a2, v2, strlen(v2));
    result = a2;
  }
  else
  {
    loc_1000AEB0(a2, v2, 0);
    result = a2;
  }
  return result;
}

//----- (10016F60) --------------------------------------------------------
int __thiscall sub_10016F60(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_10030383(*(LPVOID *)(this + 8));
  sub_10030383(*(LPVOID *)(v2 + 16));
  return sub_10030383(*(LPVOID *)(v2 + 20));
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (10016F80) --------------------------------------------------------
int __userpurge sub_10016F80<eax>(int a1<ecx>, int a2<edi>, int a3, char a4)
{
  int v4; // ebx@1
  void **v5; // esi@1
  void *v6; // esi@2
  int v7; // edx@4
  int v8; // ecx@4
  void *v9; // edi@4
  char v10; // al@5
  int v11; // eax@6
  int v12; // ecx@6
  int v13; // edi@6
  int v14; // eax@9
  int v15; // edx@9
  int v16; // ecx@9
  signed int v17; // edi@9
  int v18; // esi@9
  int result; // eax@11
  signed int v20; // edi@11
  int v21; // esi@11
  int v22; // ecx@15
  char v23; // [sp+0h] [bp-54h]@1
  char v24; // [sp+10h] [bp-44h]@1
  int v25; // [sp+3Ch] [bp-18h]@1
  int v26; // [sp+40h] [bp-14h]@1
  char *v27; // [sp+44h] [bp-10h]@1
  int v28; // [sp+50h] [bp-4h]@1

  v27 = &v23;
  v4 = a1;
  v26 = a1;
  v5 = sub_10030BC0(a1, a2);
  v25 = (int)v5;
  sub_10029D5C((int)&v24);
  *(_DWORD *)(v4 + 8) = 0;
  *(_DWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 20) = 0;
  v28 = 0;
  if ( a4 )
    v6 = &unk_1006823C;
  else
    v6 = v5[2];
  sub_10029D5C((int)&v24);
  v9 = v6;
  v8 = (int)((char *)v6 + 1);
  do
  {
    v10 = *(_BYTE *)v9;
    v9 = (char *)v9 + 1;
  }
  while ( v10 );
  v13 = (int)(v9 + -v8 + 1);
  v11 = sub_1002965B(v7, v8, v4, v13, v13);
  if ( v13 )
  {
    v12 = v11 - (_DWORD)v6;
    do
    {
      *((_BYTE *)v6 + v12) = *(_BYTE *)v6;
      v6 = (char *)v6 + 1;
      --v13;
    }
    while ( v13 );
  }
  v17 = 6;
  *(_DWORD *)(v4 + 8) = v11;
  v18 = (int)"false";
  v14 = sub_1002965B(v11, v12, v4, 6, 6);
  v15 = v14 - (_DWORD)"false";
  do
  {
    LOBYTE(v16) = *(_BYTE *)v18;
    *(_BYTE *)(v15 + v18) = *(_BYTE *)v18;
    ++v18;
    --v17;
  }
  while ( v17 );
  v20 = 5;
  *(_DWORD *)(v4 + 16) = v14;
  v21 = (int)"true";
  result = sub_1002965B(v15, v16, v4, 5, 5);
  do
  {
    *(_BYTE *)(result - (_DWORD)"true" + v21) = *(_BYTE *)v21;
    ++v21;
    --v20;
  }
  while ( v20 );
  *(_DWORD *)(v4 + 20) = result;
  if ( a4 )
  {
    *(_WORD *)(v4 + 12) = 11310;
  }
  else
  {
    v22 = v25;
    *(_BYTE *)(v4 + 12) = **(_BYTE **)v25;
    result = **(_BYTE **)(v22 + 4);
    *(_BYTE *)(v4 + 13) = result;
  }
  return result;
}

//----- (100170E0) --------------------------------------------------------
signed int __fastcall sub_100170E0(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edx@3
  int v6; // esi@3
  int v7; // ecx@4
  int v8; // eax@5
  int v9; // eax@8
  char v11; // [sp+10h] [bp-44h]@8
  int v12; // [sp+44h] [bp-10h]@1
  int v13; // [sp+50h] [bp-4h]@3

  v4 = 0;
  v12 = 0;
  if ( a3 )
  {
    if ( !*(_DWORD *)a3 )
    {
      v6 = sub_1002ADB1(a2, a1, 0, a3, 24);
      v13 = 0;
      if ( v6 )
      {
        *(_DWORD *)(v6 + 8) = 0;
        *(_DWORD *)(v6 + 16) = 0;
        *(_DWORD *)(v6 + 20) = 0;
        v7 = *(_DWORD *)a4;
        if ( *(_DWORD *)a4 )
        {
          v8 = *(_DWORD *)(v7 + 24);
          if ( !v8 )
            v8 = v7 + 28;
        }
        else
        {
          v8 = (int)&unk_1006823C;
        }
        v9 = sub_100178F0(v5, (int)&v11, 0, v8);
        v4 = 1;
        v12 = 1;
        *(_DWORD *)(v6 + 4) = 0;
        v13 = 2;
        *(_DWORD *)v6 = &off_10061740;
        sub_10016F80(v6, a3, v9, 1);
      }
      else
      {
        v6 = 0;
      }
      *(_DWORD *)a3 = v6;
      if ( v4 & 1 )
        sub_100179E0(&v11, v4);
    }
  }
  return 4;
}
// 10061740: using guessed type int (__stdcall *off_10061740)(char);

//----- (100171B0) --------------------------------------------------------
int __usercall sub_100171B0<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4)
{
  int v4; // edx@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // ecx@5
  int v8; // esi@6
  int v9; // eax@10
  int v10; // edx@17
  int v11; // ecx@17
  char v13; // [sp+Ch] [bp-2Ch]@16
  int v14; // [sp+18h] [bp-20h]@1
  int v15; // [sp+1Ch] [bp-1Ch]@1
  char v16; // [sp+20h] [bp-18h]@1
  char v17; // [sp+24h] [bp-14h]@2
  unsigned int v18; // [sp+28h] [bp-10h]@1
  int v19; // [sp+34h] [bp-4h]@1
  int v20; // [sp+38h] [bp+0h]@1

  v18 = (unsigned int)&v20 ^ __security_cookie;
  v14 = a4;
  sub_10029A76(a1, (int)&v16, a2, a3, 0);
  v19 = 0;
  v6 = dword_10077A84;
  v5 = dword_100773C4;
  v15 = dword_100773C4;
  if ( !dword_10077A84 )
  {
    sub_10029A76(v4, (int)&v17, dword_100773C4, dword_10077A84, dword_10077A84);
    if ( dword_10077A84 == v6 )
    {
      ++dword_100761E4;
      dword_10077A84 = dword_100761E4;
    }
    sub_10029AD2(&v17);
    v6 = dword_10077A84;
  }
  v7 = *(_DWORD *)a4;
  if ( (unsigned int)v6 >= *(_DWORD *)(*(_DWORD *)a4 + 12) )
  {
    v8 = 0;
  }
  else
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v7 + 8) + 4 * v6);
    if ( v8 )
      goto LABEL_18;
  }
  if ( !*(_BYTE *)(v7 + 20) )
    goto LABEL_12;
  v9 = sub_10029877();
  if ( (unsigned int)v6 < *(_DWORD *)(v9 + 12) )
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v9 + 8) + 4 * v6);
LABEL_12:
    if ( v8 )
      goto LABEL_18;
  }
  if ( v5 )
  {
    v8 = v5;
  }
  else
  {
    if ( sub_100170E0(v7, v4, (int)&v15, v14) == -1 )
    {
      sub_1002AE51((int)&v13, (unsigned int)"bad cast");
      sub_100355DB((int)&v13, (int)&unk_1006D9A4);
    }
    v8 = v15;
    dword_100773C4 = v15;
    (*(void (__thiscall **)(int))(*(_DWORD *)v15 + 4))(v15);
    sub_1002984F(v10, v11, v5, v6, v8);
  }
LABEL_18:
  sub_10029AD2(&v16);
  return v8;
}
// 10074200: using guessed type int __security_cookie;
// 100761E4: using guessed type int dword_100761E4;
// 100773C4: using guessed type int dword_100773C4;
// 10077A84: using guessed type int dword_10077A84;

//----- (100172E0) --------------------------------------------------------
int __thiscall sub_100172E0(int this, char a2)
{
  void *v2; // edi@1
  int v3; // esi@1
  int v4; // eax@3

  v3 = this;
  v2 = *(void **)(this + 52);
  *(_DWORD *)this = &off_1006896C;
  if ( v2 )
  {
    if ( *(_DWORD *)v2 )
    {
      v4 = (*(int (**)(void))(**(_DWORD **)v2 + 8))();
      if ( v4 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v4)(v4, 1);
    }
    sub_1002A4AA(v2);
  }
  if ( a2 & 1 )
    sub_1002A4AA((LPVOID)v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1006896C: using guessed type int (__stdcall *off_1006896C)(char);

//----- (10017330) --------------------------------------------------------
signed int __stdcall sub_10017330(int a1)
{
  return -1;
}

//----- (10017340) --------------------------------------------------------
__int64 __cdecl sub_10017340()
{
  return 0i64;
}

//----- (10017350) --------------------------------------------------------
__int64 __thiscall sub_10017350(int this)
{
  __int64 result; // qax@2

  if ( **(_DWORD **)(this + 28) )
    result = **(_DWORD **)(this + 44);
  else
    result = 0i64;
  return result;
}

//----- (10017370) --------------------------------------------------------
signed int __cdecl sub_10017370()
{
  return -1;
}

//----- (10017380) --------------------------------------------------------
int __thiscall sub_10017380(void *this)
{
  int result; // eax@1
  void *v2; // esi@1
  int v3; // ecx@3
  int *v4; // edx@3

  v2 = this;
  result = (*(int (**)(void))(*(_DWORD *)this + 24))();
  if ( result != -1 )
  {
    --**((_DWORD **)v2 + 11);
    v3 = *((_DWORD *)v2 + 7);
    v4 = (int *)*(_DWORD *)v3++;
    result = *(_BYTE *)v4;
  }
  return result;
}

//----- (100173B0) --------------------------------------------------------
int __thiscall sub_100173B0(int this, void *a2, unsigned int a3, int a4)
{
  int v4; // ebx@1
  unsigned int v5; // edi@2
  __int64 v6; // qax@5
  unsigned int v7; // esi@5
  unsigned __int8 v8; // cf@14
  unsigned __int8 v9; // cf@14
  int v10; // eax@15
  unsigned __int8 v11; // cf@16
  unsigned __int8 v12; // cf@16
  int result; // eax@20
  int v14; // [sp+8h] [bp-14h]@4
  int v15; // [sp+Ch] [bp-10h]@4
  int v16; // [sp+10h] [bp-Ch]@1
  __int64 v17; // [sp+14h] [bp-8h]@1
  int v18; // [sp+14h] [bp-8h]@5

  v4 = a4;
  __asm { xorps   xmm0, xmm0 }
  v16 = this;
  __asm { movlpd  [esp+20h+var_8], xmm0 }
  if ( a4 >= 0 && ((v5 = a3, a4 > 0) || a3) )
  {
    v14 = HIDWORD(v17);
    v15 = v17;
    do
    {
      v6 = sub_10017350(this);
      v7 = v6;
      v18 = HIDWORD(v6);
      if ( HIDWORD(v6) >= 0 && (HIDWORD(v6) > 0 || (_DWORD)v6) )
      {
        if ( v4 <= HIDWORD(v6) )
        {
          if ( v4 < HIDWORD(v6) || v5 < (_DWORD)v6 )
          {
            v7 = v5;
            v18 = v4;
          }
        }
        if ( v7 )
          sub_10034F00(a2, **(const void ***)(v16 + 28), v7);
        a2 = (char *)a2 + v7;
        v8 = v7 >= -v15;
        v15 += v7;
        this = v16;
        v14 += v18 + v8;
        v9 = v5 < v7;
        v5 -= v7;
        v4 -= v9 + v18;
        **(_DWORD **)(v16 + 44) -= v7;
        **(_DWORD **)(v16 + 28) += v7;
      }
      else
      {
        v10 = (*(int (**)(void))(*(_DWORD *)v16 + 28))();
        if ( v10 == -1 )
          break;
        v11 = (unsigned int)v15++ >= 0xFFFFFFFF;
        *(_BYTE *)a2 = v10;
        a2 = (char *)a2 + 1;
        v14 += v11;
        this = v16;
        v12 = v5-- >= 1;
        v4 = v12 + v4 - 1;
      }
    }
    while ( v4 > 0 || v4 >= 0 && v5 );
    result = v15;
  }
  else
  {
    result = v17;
  }
  return result;
}

//----- (100174C0) --------------------------------------------------------
__int64 __thiscall sub_100174C0(int this)
{
  __int64 result; // qax@2

  if ( **(_DWORD **)(this + 32) )
    result = **(_DWORD **)(this + 48);
  else
    result = 0i64;
  return result;
}

//----- (100174E0) --------------------------------------------------------
int __thiscall sub_100174E0(int this, const void *a2, unsigned int a3, int a4)
{
  int v4; // ebx@1
  unsigned int v5; // edi@2
  __int64 v6; // qax@5
  unsigned int v7; // esi@5
  unsigned __int8 v8; // cf@14
  unsigned __int8 v9; // cf@14
  unsigned __int8 v10; // cf@16
  unsigned __int8 v11; // cf@16
  int result; // eax@20
  int v13; // [sp+8h] [bp-14h]@4
  int v14; // [sp+Ch] [bp-10h]@4
  int v15; // [sp+10h] [bp-Ch]@1
  __int64 v16; // [sp+14h] [bp-8h]@1
  int v17; // [sp+14h] [bp-8h]@5

  v4 = a4;
  __asm { xorps   xmm0, xmm0 }
  v15 = this;
  __asm { movlpd  [esp+20h+var_8], xmm0 }
  if ( a4 >= 0 && ((v5 = a3, a4 > 0) || a3) )
  {
    v13 = HIDWORD(v16);
    v14 = v16;
    do
    {
      v6 = sub_100174C0(this);
      v7 = v6;
      v17 = HIDWORD(v6);
      if ( HIDWORD(v6) >= 0 && (HIDWORD(v6) > 0 || (_DWORD)v6) )
      {
        if ( v4 <= HIDWORD(v6) )
        {
          if ( v4 < HIDWORD(v6) || v5 < (_DWORD)v6 )
          {
            v7 = v5;
            v17 = v4;
          }
        }
        if ( v7 )
          sub_10034F00(**(void ***)(v15 + 32), a2, v7);
        a2 = (char *)a2 + v7;
        v8 = v7 >= -v14;
        v14 += v7;
        this = v15;
        v13 += v17 + v8;
        v9 = v5 < v7;
        v5 -= v7;
        v4 -= v9 + v17;
        **(_DWORD **)(v15 + 48) -= v7;
        **(_DWORD **)(v15 + 32) += v7;
      }
      else
      {
        if ( (*(int (__stdcall **)(_DWORD))(*(_DWORD *)v15 + 12))(*(_BYTE *)a2) == -1 )
          break;
        this = v15;
        v10 = (unsigned int)v14++ >= 0xFFFFFFFF;
        a2 = (char *)a2 + 1;
        v13 += v10;
        v11 = v5-- >= 1;
        v4 = v11 + v4 - 1;
      }
    }
    while ( v4 > 0 || v4 >= 0 && v5 );
    result = v14;
  }
  else
  {
    result = v16;
  }
  return result;
}

//----- (100175F0) --------------------------------------------------------
int __stdcall sub_100175F0(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = dword_10061658;
  *(_DWORD *)(a1 + 4) = dword_1006165C;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}
// 10061658: using guessed type int dword_10061658;
// 1006165C: using guessed type int dword_1006165C;

//----- (10017620) --------------------------------------------------------
int __stdcall sub_10017620(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = dword_10061658;
  *(_DWORD *)(a1 + 4) = dword_1006165C;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}
// 10061658: using guessed type int dword_10061658;
// 1006165C: using guessed type int dword_1006165C;

//----- (10017650) --------------------------------------------------------
void *__thiscall sub_10017650(void *this, int a2, int a3, int a4)
{
  return this;
}

//----- (100176B0) --------------------------------------------------------
void *__thiscall sub_100176B0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = (char *)this - 8;
  *(_DWORD *)(this + *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 8) = off_100689F0;
  *(_DWORD *)(this + *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 12) = *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 8;
  *(_DWORD *)this = &off_100683D0;
  sub_100296B7((int)this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100683D0: using guessed type int (__stdcall *off_100683D0)(char);
// 100689F0: using guessed type int (*off_100689F0[3])();

//----- (100176F9) --------------------------------------------------------
void *__thiscall sub_100176F9(void *this, char a2)
{
  return sub_100176B0((char *)this - *((_DWORD *)this - 1), a2);
}

//----- (10017701) --------------------------------------------------------
int __thiscall sub_10017701(void *this)
{
  return nullsub_3((char *)this - *((_DWORD *)this - 1));
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (10017710) --------------------------------------------------------
int __usercall sub_10017710<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<ebp>, int a5<edi>)
{
  int result; // eax@1
  int v6; // edi@1
  int v7; // esi@1

  v7 = a2;
  *(_DWORD *)(a2 + 48) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 513;
  *(_DWORD *)(a2 + 24) = 6;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 32) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  *(_DWORD *)(a2 + 40) = 0;
  *(_DWORD *)(a2 + 44) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  result = sub_1002ADB1(a1, a2, a3, a5, 4);
  v6 = result;
  if ( result )
  {
    *(_DWORD *)result = 0;
    result = sub_1002987D(a3, a4, result);
    *(_DWORD *)v6 = result;
    *(_DWORD *)(v7 + 48) = v6;
  }
  else
  {
    *(_DWORD *)(v7 + 48) = 0;
  }
  return result;
}

//----- (100177A0) --------------------------------------------------------
int __userpurge sub_100177A0<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  int v3; // eax@1
  int v4; // esi@1

  v4 = a1;
  v3 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)a1 = &off_100616E0;
  if ( v3 <= 0 )
  {
    if ( v3 < 0 )
      sub_10030383(*(LPVOID *)(a1 + 12));
  }
  else
  {
    sub_100309A2(a2, *(LPVOID *)(a1 + 12));
  }
  sub_100309A2(a2, *(LPVOID *)(v4 + 20));
  *(_DWORD *)v4 = &off_10061664;
  if ( a3 & 1 )
    sub_1002A4AA((LPVOID)v4);
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 10061664: using guessed type int (__stdcall *off_10061664)(char);
// 100616E0: using guessed type int (__stdcall *off_100616E0)(char);

//----- (10017800) --------------------------------------------------------
int *__thiscall sub_10017800(void *this, int *a2, int a3)
{
  int *v3; // esi@1
  int v4; // ebx@2

  v3 = a2;
  if ( a2 != (int *)a3 )
  {
    v4 = (int)((char *)this + 8);
    do
    {
      *(_BYTE *)v3 = sub_10029B62(v4, a3, *(_BYTE *)v3, v4);
      v3 = (int *)((char *)v3 + 1);
    }
    while ( v3 != (int *)a3 );
  }
  return v3;
}

//----- (10017830) --------------------------------------------------------
int __userpurge sub_10017830<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned __int8 a4)
{
  return sub_10029B62(a2, a3, a4, a1 + 8);
}

//----- (10017850) --------------------------------------------------------
int *__thiscall sub_10017850(void *this, int *a2, int a3)
{
  int *v3; // esi@1
  int v4; // ebx@2

  v3 = a2;
  if ( a2 != (int *)a3 )
  {
    v4 = (int)((char *)this + 8);
    do
    {
      *(_BYTE *)v3 = sub_10029C5F(v4, a3, *(_BYTE *)v3, v4);
      v3 = (int *)((char *)v3 + 1);
    }
    while ( v3 != (int *)a3 );
  }
  return v3;
}

//----- (10017880) --------------------------------------------------------
int __userpurge sub_10017880<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned __int8 a4)
{
  return sub_10029C5F(a2, a3, a4, a1 + 8);
}

//----- (100178A0) --------------------------------------------------------
int __stdcall sub_100178A0(const void *a1, int a2, void *a3)
{
  sub_10034F00(a3, a1, a2 - (_DWORD)a1);
  return a2;
}

//----- (100178C0) --------------------------------------------------------
int __stdcall sub_100178C0(const void *a1, int a2, int a3, void *a4)
{
  sub_10034F00(a4, a1, a2 - (_DWORD)a1);
  return a2;
}

//----- (100178E0) --------------------------------------------------------
char __stdcall sub_100178E0(char a1, int a2)
{
  return a1;
}

//----- (100178F0) --------------------------------------------------------
int __userpurge sub_100178F0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // esi@1
  int (__stdcall **v6)(char); // [sp+8h] [bp-24h]@2
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@2
  unsigned int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+28h] [bp-4h]@1
  int v11; // [sp+2Ch] [bp+0h]@1

  v9 = (unsigned int)&v11 ^ __security_cookie;
  v4 = a2;
  v7 = a2;
  sub_10029A76(a1, a2, a3, a4, 0);
  v10 = 0;
  *(_DWORD *)(v4 + 4) = 0;
  *(_BYTE *)(v4 + 8) = 0;
  *(_DWORD *)(v4 + 12) = 0;
  *(_BYTE *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 20) = 0;
  *(_WORD *)(v4 + 24) = 0;
  *(_DWORD *)(v4 + 28) = 0;
  *(_WORD *)(v4 + 32) = 0;
  *(_DWORD *)(v4 + 36) = 0;
  *(_BYTE *)(v4 + 40) = 0;
  *(_DWORD *)(v4 + 44) = 0;
  *(_BYTE *)(v4 + 48) = 0;
  LOBYTE(v10) = 6;
  if ( !a4 )
  {
    v8 = (int)"bad locale name";
    sub_1002AEA4((int)&v6, &v8);
    v6 = &off_10060320;
    sub_100355DB((int)&v6, (int)&unk_1006D96C);
  }
  sub_10029952(v4, (const CHAR *)a4);
  return v4;
}
// 10060320: using guessed type int (__stdcall *off_10060320)(char);
// 10074200: using guessed type int __security_cookie;

//----- (100179E0) --------------------------------------------------------
void __usercall sub_100179E0(void *this<ecx>, int a2<ebx>)
{
  void *v2; // esi@1

  v2 = this;
  sub_1002999D((int)this);
  if ( *((_DWORD *)v2 + 11) )
    sub_100309A2(a2, *((LPVOID *)v2 + 11));
  *((_DWORD *)v2 + 11) = 0;
  if ( *((_DWORD *)v2 + 9) )
    sub_100309A2(a2, *((LPVOID *)v2 + 9));
  *((_DWORD *)v2 + 9) = 0;
  if ( *((_DWORD *)v2 + 7) )
    sub_100309A2(a2, *((LPVOID *)v2 + 7));
  *((_DWORD *)v2 + 7) = 0;
  if ( *((_DWORD *)v2 + 5) )
    sub_100309A2(a2, *((LPVOID *)v2 + 5));
  *((_DWORD *)v2 + 5) = 0;
  if ( *((_DWORD *)v2 + 3) )
    sub_100309A2(a2, *((LPVOID *)v2 + 3));
  *((_DWORD *)v2 + 3) = 0;
  if ( *((_DWORD *)v2 + 1) )
    sub_100309A2(a2, *((LPVOID *)v2 + 1));
  *((_DWORD *)v2 + 1) = 0;
  sub_10029AD2(v2);
}

//----- (10017A80) --------------------------------------------------------
signed int __fastcall sub_10017A80(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edx@3
  int v7; // ecx@4
  int v8; // eax@5
  char v11; // [sp+14h] [bp-54h]@8
  char v12; // [sp+48h] [bp-20h]@8
  int v13; // [sp+58h] [bp-10h]@1
  int v14; // [sp+64h] [bp-4h]@3

  v4 = 0;
  v13 = 0;
  if ( a3 )
  {
    if ( !*(_DWORD *)a3 )
    {
      _ESI = sub_1002ADB1(a2, a1, 0, a3, 24);
      v14 = 0;
      if ( _ESI )
      {
        v7 = *(_DWORD *)a4;
        if ( *(_DWORD *)a4 )
        {
          v8 = *(_DWORD *)(v7 + 24);
          if ( !v8 )
            v8 = v7 + 28;
        }
        else
        {
          v8 = (int)&unk_1006823C;
        }
        sub_100178F0(v5, (int)&v11, 0, v8);
        v4 = 1;
        *(_DWORD *)(_ESI + 4) = 0;
        *(_DWORD *)_ESI = &off_100616E0;
        _EAX = sub_10029AF6(1, a3, (int)&v12);
        __asm
        {
          movq    xmm0, qword ptr [eax]
          movq    qword ptr [esi+8], xmm0
          movq    xmm0, qword ptr [eax+8]
          movq    qword ptr [esi+10h], xmm0
        }
      }
      else
      {
        _ESI = 0;
      }
      *(_DWORD *)a3 = _ESI;
      if ( v4 & 1 )
        sub_100179E0(&v11, v4);
    }
  }
  return 2;
}
// 100616E0: using guessed type int (__stdcall *off_100616E0)(char);

//----- (10017B50) --------------------------------------------------------
int __usercall sub_10017B50<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4)
{
  int v4; // edx@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // ecx@5
  int v8; // esi@6
  int v9; // eax@10
  int v10; // edx@17
  int v11; // ecx@17
  char v13; // [sp+Ch] [bp-2Ch]@16
  int v14; // [sp+18h] [bp-20h]@1
  int v15; // [sp+1Ch] [bp-1Ch]@1
  char v16; // [sp+20h] [bp-18h]@1
  char v17; // [sp+24h] [bp-14h]@2
  unsigned int v18; // [sp+28h] [bp-10h]@1
  int v19; // [sp+34h] [bp-4h]@1
  int v20; // [sp+38h] [bp+0h]@1

  v18 = (unsigned int)&v20 ^ __security_cookie;
  v14 = a4;
  sub_10029A76(a1, (int)&v16, a2, a3, 0);
  v19 = 0;
  v6 = dword_100761F4;
  v5 = dword_100773C8;
  v15 = dword_100773C8;
  if ( !dword_100761F4 )
  {
    sub_10029A76(v4, (int)&v17, dword_100773C8, dword_100761F4, dword_100761F4);
    if ( dword_100761F4 == v6 )
    {
      ++dword_100761E4;
      dword_100761F4 = dword_100761E4;
    }
    sub_10029AD2(&v17);
    v6 = dword_100761F4;
  }
  v7 = *(_DWORD *)a4;
  if ( (unsigned int)v6 >= *(_DWORD *)(*(_DWORD *)a4 + 12) )
  {
    v8 = 0;
  }
  else
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v7 + 8) + 4 * v6);
    if ( v8 )
      goto LABEL_18;
  }
  if ( !*(_BYTE *)(v7 + 20) )
    goto LABEL_12;
  v9 = sub_10029877();
  if ( (unsigned int)v6 < *(_DWORD *)(v9 + 12) )
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v9 + 8) + 4 * v6);
LABEL_12:
    if ( v8 )
      goto LABEL_18;
  }
  if ( v5 )
  {
    v8 = v5;
  }
  else
  {
    if ( sub_10017A80(v7, v4, (int)&v15, v14) == -1 )
    {
      sub_1002AE51((int)&v13, (unsigned int)"bad cast");
      sub_100355DB((int)&v13, (int)&unk_1006D9A4);
    }
    v8 = v15;
    dword_100773C8 = v15;
    (*(void (__thiscall **)(int))(*(_DWORD *)v15 + 4))(v15);
    sub_1002984F(v10, v11, v5, v6, v8);
  }
LABEL_18:
  sub_10029AD2(&v16);
  return v8;
}
// 10074200: using guessed type int __security_cookie;
// 100761E4: using guessed type int dword_100761E4;
// 100761F4: using guessed type int dword_100761F4;
// 100773C8: using guessed type int dword_100773C8;

//----- (10017C80) --------------------------------------------------------
char __stdcall sub_10017C80(char a1)
{
  return a1;
}

//----- (10017C90) --------------------------------------------------------
int __userpurge sub_10017C90<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6)
{
  int ebp0; // ebp@0
  int v7; // edi@1
  int v8; // esi@1
  int v9; // eax@1
  int v10; // edx@1
  int v11; // eax@2
  int result; // eax@4
  char v13; // zf@4

  v8 = a2;
  sub_10017710(a1, a2, a3, ebp0, a4);
  *(_DWORD *)(v8 + 56) = a5;
  *(_DWORD *)(v8 + 60) = 0;
  v9 = sub_10017D70(v8, (int)&a5);
  v7 = sub_10017B50(v10, a3, a4, v9);
  if ( a5 )
  {
    v11 = (*(int (**)(void))(*(_DWORD *)a5 + 8))();
    if ( v11 )
      (**(void (__thiscall ***)(_DWORD, _DWORD))v11)(v11, 1);
  }
  result = (*(int (__thiscall **)(int, signed int))(*(_DWORD *)v7 + 32))(v7, 32);
  v13 = *(_DWORD *)(v8 + 56) == 0;
  *(_BYTE *)(v8 + 64) = result;
  if ( v13 )
  {
    result = ((unsigned __int8)*(_DWORD *)(v8 + 12) | 4) & 0x17;
    *(_DWORD *)(v8 + 12) = result;
    if ( result & *(_DWORD *)(v8 + 16) )
      result = loc_10017FD0(v8, 0);
  }
  return result;
}

//----- (10017D50) --------------------------------------------------------
void __thiscall sub_10017D50(void *this)
{
  int v1; // ecx@1
  int v2; // eax@2

  v1 = *(_DWORD *)this;
  if ( v1 )
  {
    v2 = (*(int (**)(void))(*(_DWORD *)v1 + 8))();
    if ( v2 )
      (**(void (__thiscall ***)(_DWORD, _DWORD))v2)(v2, 1);
  }
}

//----- (10017D70) --------------------------------------------------------
int __thiscall sub_10017D70(int this, int a2)
{
  int v3; // eax@1
  int v4; // ecx@1

  v3 = *(_DWORD *)(this + 48);
  v4 = *(_DWORD *)v3;
  *(_DWORD *)a2 = *(_DWORD *)v3;
  (*(void (**)(void))(*(_DWORD *)v4 + 4))();
  return a2;
}

//----- (10017DB0) --------------------------------------------------------
int __thiscall sub_10017DB0(void *this)
{
  int result; // eax@1
  void *v2; // esi@1
  char v3; // al@4
  int v4; // ecx@4
  int v5; // ecx@4
  int v6; // eax@4
  char v7; // [sp+0h] [bp-20h]@1
  char *v8; // [sp+10h] [bp-10h]@1
  int v9; // [sp+1Ch] [bp-4h]@1

  v8 = &v7;
  v2 = this;
  v9 = 0;
  result = *(_DWORD *)(*(_DWORD *)this + 4);
  if ( !*(_DWORD *)(this + result + 12) )
  {
    if ( *((_BYTE *)this + result + 20) & 2 )
    {
      result = (*(int (**)(void))(**(_DWORD **)(this + result + 56) + 52))();
      if ( result == -1 )
      {
        v5 = *(_DWORD *)(*(_DWORD *)v2 + 4);
        v6 = *(_DWORD *)(v2 + v5 + 12);
        v4 = (int)((char *)v2 + v5);
        v3 = v6 | 4;
        if ( !*(_DWORD *)(v4 + 56) )
          v3 |= 4u;
        result = v3 & 0x17;
        *(_DWORD *)(v4 + 12) = result;
        if ( result & *(_DWORD *)(v4 + 16) )
          result = loc_10017FD0(0);
      }
    }
  }
  return result;
}

//----- (10017E3E) --------------------------------------------------------
int (*__cdecl sub_10017E3E())()
{
  return loc_10017E2C;
}
// 10017E2C: using guessed type int loc_10017E2C();

//----- (10017E80) --------------------------------------------------------
int __cdecl sub_10017E80()
{
  return 0;
}

//----- (10017E90) --------------------------------------------------------
int __thiscall sub_10017E90(void *this, const char *a2, int a3)
{
  int v3; // ebx@1
  char v4; // zf@1
  unsigned int v5; // eax@2
  int *v6; // eax@4
  int v7; // edi@4
  int v8; // esi@4
  char v9; // cf@6
  int result; // eax@8
  void *v11; // [sp+14h] [bp-24h]@1
  int v12; // [sp+24h] [bp-14h]@1
  unsigned int v13; // [sp+28h] [bp-10h]@1
  int v14; // [sp+34h] [bp-4h]@4

  v3 = (int)this;
  v13 = 15;
  v4 = *a2 == 0;
  v12 = 0;
  LOBYTE(v11) = 0;
  if ( v4 )
    v5 = 0;
  else
    v5 = strlen(a2);
  loc_1000AEB0(&v11, a2, v5);
  v14 = 0;
  v8 = *(_DWORD *)a3;
  v7 = *(_DWORD *)(a3 + 4);
  v6 = (int *)&v11;
  if ( v13 >= 0x10 )
    v6 = (int *)v11;
  a2 = (const char *)v6;
  sub_1002AEA4(v3, (int *)&a2);
  v9 = v13 < 0x10;
  *(_DWORD *)v3 = &off_100683AC;
  *(_DWORD *)(v3 + 12) = v8;
  *(_DWORD *)(v3 + 16) = v7;
  if ( !v9 )
    sub_1002A4AA(v11);
  result = v3;
  *(_DWORD *)v3 = &off_100683AC;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100683AC: using guessed type int (__stdcall *off_100683AC)(char);

//----- (10017F60) --------------------------------------------------------
int __userpurge sub_10017F60<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // edi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_100683AC;
  *(_DWORD *)(v4 + 12) = *(_DWORD *)(a3 + 12);
  *(_DWORD *)(v4 + 16) = *(_DWORD *)(a3 + 16);
  *(_DWORD *)v4 = &off_100683AC;
  return v4;
}
// 100683AC: using guessed type int (__stdcall *off_100683AC)(char);

//----- (10017F90) --------------------------------------------------------
int __userpurge sub_10017F90<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // edi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_100683AC;
  *(_DWORD *)(v4 + 12) = *(_DWORD *)(a3 + 12);
  *(_DWORD *)(v4 + 16) = *(_DWORD *)(a3 + 16);
  return v4;
}
// 100683AC: using guessed type int (__stdcall *off_100683AC)(char);

//----- (10018060) --------------------------------------------------------
int __thiscall sub_10018060(int this)
{
  int v1; // esi@1
  char v2; // al@4
  int v3; // ecx@4
  int v4; // ecx@4
  int v5; // eax@4
  int v6; // eax@6
  int v7; // ecx@10
  void *v9; // [sp+8h] [bp-1Ch]@1
  int v10; // [sp+Ch] [bp-18h]@2
  unsigned int v11; // [sp+10h] [bp-14h]@1
  int v12; // [sp+20h] [bp-4h]@2

  v11 = (unsigned int)&v9 ^ __security_cookie;
  v1 = this;
  if ( *(_DWORD *)(*(_DWORD *)(*(_DWORD *)this + 4) + this + 56) )
  {
    sub_10018150(&v9, this);
    v12 = 0;
    if ( (_BYTE)v10 )
    {
      if ( (*(int (**)(void))(**(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + v1 + 56) + 52))() == -1 )
      {
        v4 = *(_DWORD *)(*(_DWORD *)v1 + 4);
        v5 = *(_DWORD *)(v4 + v1 + 12);
        v3 = v1 + v4;
        v2 = v5 | 4;
        if ( !*(_DWORD *)(v3 + 56) )
          v2 |= 4u;
        v6 = v2 & 0x17;
        *(_DWORD *)(v3 + 12) = v6;
        if ( v6 & *(_DWORD *)(v3 + 16) )
          loc_10017FD0(0);
      }
    }
    v12 = -1;
    if ( !(unsigned __int8)sub_10029736() )
      sub_10017DB0(v9);
    v7 = *(_DWORD *)(v9 + *(_DWORD *)(*(_DWORD *)v9 + 4) + 56);
    if ( v7 )
      (*(void (**)(void))(*(_DWORD *)v7 + 8))();
  }
  return v1;
}
// 10029736: using guessed type int sub_10029736(void);
// 10074200: using guessed type int __security_cookie;

//----- (10018150) --------------------------------------------------------
void *__thiscall sub_10018150(void *this, int a2)
{
  int v2; // ecx@1
  void *v3; // edi@1
  int v4; // eax@3
  int v5; // ecx@4

  v3 = this;
  *(_DWORD *)this = a2;
  v2 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a2 + 4) + a2 + 56);
  if ( v2 )
    (*(void (**)(void))(*(_DWORD *)v2 + 4))();
  v4 = *(_DWORD *)(*(_DWORD *)a2 + 4);
  if ( !*(_DWORD *)(v4 + a2 + 12) )
  {
    v5 = *(_DWORD *)(v4 + a2 + 60);
    if ( v5 )
      sub_10018060(v5);
  }
  *((_BYTE *)v3 + 4) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a2 + 4) + a2 + 12) == 0;
  return v3;
}

//----- (100181E0) --------------------------------------------------------
char __thiscall sub_100181E0(int this, int a2, signed int a3, unsigned __int8 a4)
{
  char result; // al@4

  if ( a3 == 1 )
  {
    if ( *(_DWORD *)(this + 20) >= 0x10u )
      this = *(_DWORD *)this;
    result = a4;
    *(_BYTE *)(this + a2) = a4;
  }
  else
  {
    if ( *(_DWORD *)(this + 20) >= 0x10u )
      this = *(_DWORD *)this;
    result = (unsigned int)sub_10039210((void *)(this + a2), a4, a3);
  }
  return result;
}

//----- (100182F0) --------------------------------------------------------
void *__thiscall sub_100182F0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_100683D0;
  sub_100296B7((int)this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100683D0: using guessed type int (__stdcall *off_100683D0)(char);

//----- (10018340) --------------------------------------------------------
int __thiscall sub_10018340(void *this)
{
  int result; // eax@1

  _ECX = (int)((char *)this + 4);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (10018350) --------------------------------------------------------
void *__thiscall sub_10018350(void *this)
{
  void *result; // eax@1

  _EAX = (int)((char *)this + 4);
  _EDX = -1;
  __asm { lock xadd [eax], edx }
  result = 0;
  if ( _ZF )
    result = this;
  return result;
}

//----- (10018370) --------------------------------------------------------
int __stdcall sub_10018370(int a1, int a2)
{
  int i; // esi@1
  int result; // eax@3

  for ( i = a1; i != a2; i += 24 )
  {
    if ( *(_DWORD *)(i + 20) >= 0x10u )
      result = sub_1002A4AA(*(LPVOID *)i);
    *(_DWORD *)(i + 20) = 15;
    *(_DWORD *)(i + 16) = 0;
    *(_BYTE *)i = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100183F0) --------------------------------------------------------
int __fastcall sub_100183F0(int a1, int a2)
{
  int v2; // edi@1
  int i; // esi@1
  int v4; // eax@3
  int result; // eax@3
  int v6; // ecx@3

  v2 = a2;
  for ( i = a1; i != v2; result = (**(int (__stdcall ***)(_DWORD))v6)(1) )
  {
    if ( !i )
      break;
    v4 = i + 12;
    v6 = i;
    i = *(_DWORD *)(i + 12);
    *(_DWORD *)v4 = 0;
  }
  return result;
}

//----- (10018420) --------------------------------------------------------
void *__thiscall sub_10018420(int this, char a2)
{
  void *v2; // edi@1
  int v3; // esi@1
  int v4; // eax@2
  int v5; // ecx@2

  v2 = (void *)this;
  v3 = *(_DWORD *)(this + 20);
  *(_DWORD *)this = &off_10068B18;
  while ( v3 )
  {
    v4 = v3 + 12;
    v5 = v3;
    v3 = *(_DWORD *)(v3 + 12);
    *(_DWORD *)v4 = 0;
    (**(void (__stdcall ***)(_DWORD))v5)(1);
  }
  *(_DWORD *)v2 = off_10068B14;
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10068B14: using guessed type int (__stdcall *off_10068B14[2])(char);
// 10068B18: using guessed type int (__stdcall *off_10068B18)(char);

//----- (10018470) --------------------------------------------------------
int __fastcall sub_10018470(int a1)
{
  int v1; // edi@1
  int result; // eax@2
  int v3; // ebx@2
  int v4; // esi@2
  int v5; // eax@4
  int v6; // ecx@4
  int v7; // [sp+4h] [bp-4h]@1

  v1 = *(_DWORD *)(a1 + 24);
  v7 = a1;
  *(_DWORD *)a1 = off_10068B10;
  while ( v1 )
  {
    result = v1 + 24;
    v4 = v1;
    v1 = *(_DWORD *)(v1 + 24);
    *(_DWORD *)result = 0;
    v3 = *(_DWORD *)(a1 + 20);
    if ( v4 != v3 )
    {
      do
      {
        if ( !v4 )
          break;
        v5 = v4 + 12;
        v6 = v4;
        v4 = *(_DWORD *)(v4 + 12);
        *(_DWORD *)v5 = 0;
        result = (**(int (__stdcall ***)(_DWORD))v6)(1);
      }
      while ( v4 != v3 );
      a1 = v7;
    }
  }
  *(_DWORD *)a1 = off_10068B14;
  return result;
}
// 10068B10: using guessed type int (__stdcall *off_10068B10[3])(char);
// 10068B14: using guessed type int (__stdcall *off_10068B14[2])(char);

//----- (100184D0) --------------------------------------------------------
void *__thiscall sub_100184D0(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_10018470(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10018500) --------------------------------------------------------
int __thiscall sub_10018500(int this, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1

  v2 = *(_DWORD *)(this + 4);
  v3 = *(_DWORD *)this;
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  if ( v3 != v2 )
    loc_1000AEB0(a2, v3, v2 - v3);
  return a2;
}

//----- (10018590) --------------------------------------------------------
char __thiscall sub_10018590(void *this, int a2)
{
  int v2; // ecx@1
  unsigned int v3; // edi@1
  int v4; // edx@2
  unsigned int v5; // ebx@4
  unsigned int v6; // eax@6
  char v7; // zf@8
  int v8; // eax@8
  bool v9; // eax@10
  int v10; // eax@13
  int v11; // ebx@14
  unsigned int v12; // edi@16
  int v13; // esi@17
  int v14; // edx@19
  unsigned int v15; // ecx@19
  int v16; // eax@20
  unsigned int v17; // edx@21
  int v18; // edi@21
  int v19; // ecx@22
  int v20; // eax@24
  int v21; // ecx@25
  int v22; // esi@28
  int v26; // ecx@40
  int *v27; // ecx@42
  unsigned int v28; // edi@42
  signed int v29; // edx@44
  int v30; // edx@47
  int v31; // esi@47
  char v32; // cf@47
  char v33; // cf@49
  unsigned __int8 v34; // cf@51
  unsigned __int8 v35; // al@53
  unsigned __int8 v36; // al@55
  unsigned __int8 v37; // al@57
  int v38; // eax@58
  char v39; // zf@60
  bool v40; // eax@62
  signed int v41; // edi@66
  int *v42; // edx@67
  signed int v43; // ecx@69
  int v44; // ecx@72
  int v45; // esi@72
  char v46; // cf@72
  char v47; // cf@74
  unsigned __int8 v48; // cf@76
  unsigned __int8 v49; // al@78
  unsigned __int8 v50; // al@80
  unsigned __int8 v51; // al@82
  int v52; // eax@83
  char v53; // zf@85
  bool v54; // eax@87
  int v55; // ecx@92
  unsigned int v56; // eax@94
  char v57; // zf@96
  int v58; // eax@96
  bool v59; // eax@98
  int v60; // ecx@103
  int v61; // ecx@105
  unsigned int v63; // ecx@109
  int v64; // ebx@109
  int v65; // eax@110
  int v66; // edx@112
  char v68; // zf@121
  int i; // esi@122
  int v70; // eax@123
  int v71; // ecx@123
  int v72; // eax@123
  int v73; // edx@126
  char v75; // [sp-10h] [bp-168h]@39
  int v76; // [sp-Ch] [bp-164h]@21
  int v77; // [sp-8h] [bp-160h]@21
  unsigned int v78; // [sp-4h] [bp-15Ch]@1
  char v79; // [sp+Ch] [bp-14Ch]@107
  void *v80; // [sp+24h] [bp-134h]@107
  int v81; // [sp+54h] [bp-104h]@27
  int v82; // [sp+58h] [bp-100h]@27
  int v83; // [sp+5Ch] [bp-FCh]@27
  int v84; // [sp+60h] [bp-F8h]@35
  int v85; // [sp+64h] [bp-F4h]@27
  void *v86; // [sp+6Ch] [bp-ECh]@27
  int v87; // [sp+70h] [bp-E8h]@27
  int v88; // [sp+74h] [bp-E4h]@27
  __int64 v89; // [sp+9Ch] [bp-BCh]@36
  int v90; // [sp+A4h] [bp-B4h]@36
  __int64 v91; // [sp+A8h] [bp-B0h]@39
  __int64 v92; // [sp+B4h] [bp-A4h]@36
  int v93; // [sp+BCh] [bp-9Ch]@36
  int v94; // [sp+C0h] [bp-98h]@46
  __int64 v95; // [sp+C4h] [bp-94h]@105
  int v96; // [sp+D0h] [bp-88h]@1
  int v97; // [sp+D4h] [bp-84h]@21
  int v98; // [sp+D8h] [bp-80h]@21
  int v99; // [sp+DCh] [bp-7Ch]@21
  int v100; // [sp+E0h] [bp-78h]@35
  int v101; // [sp+E4h] [bp-74h]@21
  int v102; // [sp+ECh] [bp-6Ch]@21
  int v103; // [sp+F0h] [bp-68h]@21
  int v104; // [sp+F4h] [bp-64h]@21
  __int64 v105; // [sp+F8h] [bp-60h]@38
  char v106; // [sp+100h] [bp-58h]@37
  int v107; // [sp+104h] [bp-54h]@105
  char v108; // [sp+110h] [bp-48h]@40
  void *v109; // [sp+11Ch] [bp-3Ch]@42
  unsigned int v110; // [sp+12Ch] [bp-2Ch]@42
  unsigned int v111; // [sp+130h] [bp-28h]@42
  int v112; // [sp+134h] [bp-24h]@21
  int v113; // [sp+138h] [bp-20h]@21
  int v114; // [sp+13Ch] [bp-1Ch]@21
  int v115; // [sp+140h] [bp-18h]@21
  unsigned int v116; // [sp+144h] [bp-14h]@1
  int v117; // [sp+154h] [bp-4h]@21
  int v118; // [sp+158h] [bp+0h]@1

  v116 = (unsigned int)&v118 ^ __security_cookie;
  v78 = (unsigned int)&v118 ^ __security_cookie;
  v96 = (int)this;
  v2 = (int)((char *)this + 4);
  v3 = *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 20) < 0x10u )
    v4 = a2;
  else
    v4 = *(_DWORD *)a2;
  v5 = *(_DWORD *)(v2 + 16);
  if ( *(_DWORD *)(v2 + 20) >= 0x10u )
    v2 = *(_DWORD *)v2;
  v6 = *(_DWORD *)(a2 + 16);
  if ( v5 < v3 )
    v6 = v5;
  v8 = sub_100099E0(v2, v4, v6);
  v7 = v8 == 0;
  if ( !v8 )
  {
    if ( v5 >= v3 )
      v9 = v5 != v3;
    else
      v9 = -1;
    v7 = v9 == 0;
  }
  LOBYTE(v10) = v7;
  if ( !v7 )
  {
    v11 = v96 + 4;
    *(_DWORD *)(v96 + 32) = *(_DWORD *)(v96 + 28);
    if ( v11 != a2 )
      loc_1000AB40(v11, a2, 0, -1);
    v12 = *(_DWORD *)(v11 + 16);
    if ( *(_DWORD *)(v11 + 20) < 0x10u )
      v13 = v11;
    else
      v13 = *(_DWORD *)v11;
    v15 = 0;
    v14 = -2128831035;
    if ( v12 )
    {
      do
      {
        v16 = *(_BYTE *)(v13 + v15++);
        v14 = 16777619 * (v16 ^ v14);
      }
      while ( v15 < v12 );
    }
    v18 = v96;
    *(_DWORD *)(v96 + 40) = v14;
    v112 = 0;
    v113 = 0;
    v114 = 0;
    v115 = 0;
    sub_10019500((int)&v112, v18, v76, v77);
    v117 = 0;
    v17 = *(_DWORD *)(v11 + 20);
    v97 = 0;
    v98 = 0;
    v99 = 0;
    v101 = 0;
    v102 = 0;
    v103 = 0;
    v104 = 0;
    if ( v17 < 0x10 )
      v19 = v11;
    else
      v19 = *(_DWORD *)v11;
    v20 = v19 + *(_DWORD *)(v11 + 16);
    if ( v17 < 0x10 )
      v21 = v11;
    else
      v21 = *(_DWORD *)v11;
    sub_10018F50((int)&v97, v21, v20, (int)&v112, v21);
    v81 = 0;
    v82 = 0;
    v83 = 0;
    v85 = 0;
    v86 = 0;
    v87 = 0;
    v88 = 0;
    sub_10018EE0((int)&v81);
    LOBYTE(v117) = 2;
    if ( *(_DWORD *)(v11 + 20) < 0x10u )
      v22 = v11;
    else
      v22 = *(_DWORD *)v11;
    _EBX = (int)v86;
    while ( 1 )
    {
      if ( v99 == v83 )
      {
        if ( !v99 )
          goto LABEL_130;
        if ( v97 == v81 )
        {
          if ( v98 == v82 )
          {
            if ( v100 == v84 )
            {
              __asm { movq    xmm0, qword ptr [ebx] }
              v90 = *(_DWORD *)(_EBX + 8);
              _EAX = v102;
              __asm
              {
                movq    [ebp+var_BC], xmm0
                movq    xmm0, qword ptr [eax]
              }
              v93 = *(_DWORD *)(v102 + 8);
              __asm { movq    [ebp+var_A4], xmm0 }
              if ( !sub_100199B0(&v92, (int)&v89) )
              {
LABEL_130:
                v63 = *(_DWORD *)(v18 + 24);
                v64 = v18 + 4;
                if ( v63 < 0x10 )
                  v65 = v18 + 4;
                else
                  v65 = *(_DWORD *)v64;
                v66 = *(_DWORD *)(v18 + 20);
                if ( v22 != v66 + v65 )
                {
                  if ( v63 >= 0x10 )
                    v64 = *(_DWORD *)v64;
                  HIDWORD(v95) = v64 + v66;
                  _EAX = &v75;
                  LODWORD(v95) = v22;
                  __asm
                  {
                    movq    xmm0, [ebp+var_94]
                    movq    qword ptr [eax], xmm0
                  }
                  sub_10018BD0((void *)v18, *(__int64 *)&v75, 0);
                }
                if ( v86 )
                  sub_1002A4AA(v86);
                if ( v102 )
                {
                  sub_1002A4AA((LPVOID)v102);
                  v102 = 0;
                  v103 = 0;
                  v104 = 0;
                }
                v117 = -1;
                LOBYTE(v10) = v112;
                if ( v112 )
                {
                  v68 = *(_DWORD *)(v112 + 32)-- == 1;
                  if ( v68 )
                  {
                    for ( i = v112; i; LOBYTE(v10) = (*(int (__stdcall **)(signed int))v72)(1) )
                    {
                      v70 = i + 12;
                      v71 = i;
                      i = *(_DWORD *)(i + 12);
                      *(_DWORD *)v70 = 0;
                      v72 = *(_DWORD *)v71;
                      v77 = 1;
                    }
                  }
                }
                v112 = 0;
                if ( v115 )
                {
                  v10 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v115 + 8))(v78);
                  if ( v10 )
                  {
                    v73 = *(_DWORD *)v10;
                    v77 = 1;
                    LOBYTE(v10) = (*(int (__thiscall **)(int, signed int))v73)(v10, 1);
                  }
                }
                return v10;
              }
            }
          }
        }
      }
      if ( v106 )
      {
        if ( HIDWORD(v105) - (_DWORD)v105 > 0 )
        {
          _EAX = &v75;
          v91 = v105;
          __asm
          {
            movq    xmm0, [ebp+var_B0]
            movq    qword ptr [eax], xmm0
          }
          sub_10018BD0((void *)v18, *(__int64 *)&v75, 0);
        }
      }
      v26 = (int)&v108;
      if ( (unsigned int)((v103 - v102) / 12) > 1 )
        v26 = v102 + 12;
      sub_100190D0(v26, (int)&v109);
      LOBYTE(v117) = 3;
      v28 = v110;
      v27 = (int *)&v109;
      if ( v111 >= 0x10 )
        v27 = (int *)v109;
      v29 = 1;
      if ( v110 < 1 )
        v29 = v110;
      v94 = 0;
      if ( v29 )
        break;
LABEL_61:
      if ( v110 >= 1 )
        v40 = v110 != 1;
      else
        v40 = -1;
      v39 = v40 == 0;
LABEL_65:
      if ( v39 )
      {
        v41 = 1;
        goto LABEL_103;
      }
      v42 = (int *)&v109;
      if ( v111 >= 0x10 )
        v42 = (int *)v109;
      v43 = 1;
      if ( v110 < 1 )
        v43 = v110;
      if ( !v43 )
      {
LABEL_86:
        if ( v110 >= 1 )
          v54 = v110 != 1;
        else
          v54 = -1;
        v53 = v54 == 0;
        goto LABEL_90;
      }
      v45 = (int)"i";
      v46 = (unsigned int)v43 < 4;
      v44 = v43 - 4;
      if ( v46 )
      {
LABEL_75:
        if ( v44 == -4 )
          goto LABEL_84;
      }
      else
      {
        while ( *v42 == *(_DWORD *)v45 )
        {
          ++v42;
          v45 += 4;
          v47 = (unsigned int)v44 < 4;
          v44 -= 4;
          if ( v47 )
            goto LABEL_75;
        }
      }
      v48 = *(_BYTE *)v42 < *(_BYTE *)v45;
      if ( *(_BYTE *)v42 != *(_BYTE *)v45
        || v44 != -3
        && ((v49 = *((_BYTE *)v42 + 1), v48 = v49 < *(_BYTE *)(v45 + 1), v49 != *(_BYTE *)(v45 + 1))
         || v44 != -2
         && ((v50 = *((_BYTE *)v42 + 2), v48 = v50 < *(_BYTE *)(v45 + 2), v50 != *(_BYTE *)(v45 + 2))
          || v44 != -1 && (v51 = *((_BYTE *)v42 + 3), v48 = v51 < *(_BYTE *)(v45 + 3), v51 != *(_BYTE *)(v45 + 3)))) )
      {
        v52 = -v48 | 1;
        goto LABEL_85;
      }
LABEL_84:
      v52 = 0;
LABEL_85:
      v53 = v52 == 0;
      if ( !v52 )
        goto LABEL_86;
LABEL_90:
      if ( v53 )
      {
        v41 = 2;
      }
      else
      {
        v55 = (int)&v109;
        if ( v111 >= 0x10 )
          v55 = (int)v109;
        v56 = 3;
        if ( v110 < 3 )
          v56 = v110;
        v58 = sub_100099E0(v55, (int)"url", v56);
        v57 = v58 == 0;
        if ( !v58 )
        {
          if ( v28 >= 3 )
            v59 = v28 != 3;
          else
            v59 = -1;
          v57 = v59 == 0;
        }
        v41 = v94;
        if ( v57 )
          v41 = 8;
      }
LABEL_103:
      v60 = (int)&v108;
      if ( (unsigned int)((v103 - v102) / 12) > 2 )
        v60 = v102 + 24;
      v95 = *(_QWORD *)v60;
      __asm { movq    xmm0, [ebp+var_94] }
      _EAX = &v75;
      __asm { movq    qword ptr [eax], xmm0 }
      v77 = v41;
      v18 = v96;
      sub_10018BD0((void *)v96, *(__int64 *)&v75, v77);
      v22 = v107;
      LOBYTE(v117) = 2;
      if ( v111 >= 0x10 )
        sub_1002A4AA(v109);
      sub_10019030((int)&v97, (int)&v79, v61);
      if ( v80 )
        sub_1002A4AA(v80);
    }
    v31 = (int)"b";
    v32 = (unsigned int)v29 < 4;
    v30 = v29 - 4;
    if ( v32 )
    {
LABEL_50:
      if ( v30 == -4 )
        goto LABEL_59;
    }
    else
    {
      while ( *v27 == *(_DWORD *)v31 )
      {
        ++v27;
        v31 += 4;
        v33 = (unsigned int)v30 < 4;
        v30 -= 4;
        if ( v33 )
          goto LABEL_50;
      }
    }
    v34 = *(_BYTE *)v27 < *(_BYTE *)v31;
    if ( *(_BYTE *)v27 != *(_BYTE *)v31
      || v30 != -3
      && ((v35 = *((_BYTE *)v27 + 1), v34 = v35 < *(_BYTE *)(v31 + 1), v35 != *(_BYTE *)(v31 + 1))
       || v30 != -2
       && ((v36 = *((_BYTE *)v27 + 2), v34 = v36 < *(_BYTE *)(v31 + 2), v36 != *(_BYTE *)(v31 + 2))
        || v30 != -1 && (v37 = *((_BYTE *)v27 + 3), v34 = v37 < *(_BYTE *)(v31 + 3), v37 != *(_BYTE *)(v31 + 3)))) )
    {
      v38 = -v34 | 1;
      goto LABEL_60;
    }
LABEL_59:
    v38 = 0;
LABEL_60:
    v39 = v38 == 0;
    if ( v38 )
      goto LABEL_65;
    goto LABEL_61;
  }
  return v10;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10018BD0) --------------------------------------------------------
void __thiscall sub_10018BD0(void *this, __int64 a2, int a3)
{
  int v3; // eax@1
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // ebx@2
  void *v8; // ecx@6
  unsigned int v9; // edx@12
  int v10; // esi@13
  int v11; // ecx@14
  int v12; // ebx@14
  unsigned int v13; // eax@15
  unsigned int v14; // edx@16
  signed int v15; // edx@17
  int v16; // ecx@17
  int v17; // eax@17
  int v21; // eax@25
  char v22; // [sp-Ch] [bp-50h]@6
  int v23; // [sp-8h] [bp-4Ch]@6
  _DWORD v24[3]; // [sp+Ch] [bp-38h]@12
  __int64 v25; // [sp+18h] [bp-2Ch]@15
  int v26; // [sp+20h] [bp-24h]@14
  int v27; // [sp+24h] [bp-20h]@2
  int v28; // [sp+28h] [bp-1Ch]@1
  int v29; // [sp+2Ch] [bp-18h]@13
  int v30; // [sp+30h] [bp-14h]@12
  __int64 v31; // [sp+34h] [bp-10h]@12
  int v32; // [sp+3Ch] [bp-8h]@12
  unsigned int v33; // [sp+40h] [bp-4h]@1
  int v34; // [sp+44h] [bp+0h]@1

  v33 = (unsigned int)&v34 ^ __security_cookie;
  v3 = a2;
  v5 = (int)this;
  v4 = HIDWORD(a2);
  v28 = v5;
  while ( 1 )
  {
    v6 = v3;
    v27 = v3;
    if ( v3 == v4 )
      break;
    while ( *(_BYTE *)v6 != 10 )
    {
      ++v6;
      v27 = v6;
      if ( v6 == v4 )
        goto LABEL_5;
    }
    if ( v6 == v4 )
    {
LABEL_5:
      if ( v3 != v4 )
      {
        __asm { movq    xmm0, [ebp+arg_0] }
        _EDX = &v22;
        v8 = (void *)v5;
        __asm { movq    qword ptr [edx], xmm0 }
        sub_10018DA0(v8, *(int *)&v22, v23, a3);
      }
      return;
    }
    if ( v6 == v3 )
    {
      if ( (*(_DWORD *)(v5 + 32) - *(_DWORD *)(v5 + 28)) / 12 )
      {
        *(_DWORD *)(*(_DWORD *)(v5 + 32) - 4) |= 4u;
        v4 = HIDWORD(a2);
        v3 = v6 + 1;
        LODWORD(a2) = v6 + 1;
        continue;
      }
    }
    else
    {
      v30 = a3 | 4;
      v32 = a3 | 4;
      v9 = *(_DWORD *)v5;
      v24[0] = v3;
      v24[1] = v6;
      __asm
      {
        movq    xmm0, qword ptr [ebp+var_38]
        movq    [ebp+var_10], xmm0
      }
      if ( !v9 )
        goto LABEL_32;
      v29 = v6 - v3;
      v10 = v31;
      if ( v6 - v3 > v9 )
      {
        v11 = v30;
        v12 = v29;
        v26 = v30;
        do
        {
          HIDWORD(v25) = v9 + v10;
          v13 = *(_DWORD *)(v5 + 32);
          LODWORD(v25) = v10;
          if ( (unsigned int)&v25 >= v13 || (v14 = *(_DWORD *)(v5 + 28), v11 = v30, v14 > (unsigned int)&v25) )
          {
            if ( v13 == *(_DWORD *)(v5 + 36) )
            {
              loc_10019280(v5 + 28, v11);
              v11 = v30;
            }
            _EAX = *(_DWORD *)(v5 + 32);
            if ( _EAX )
            {
              __asm
              {
                movq    xmm0, [ebp+var_2C]
                movq    qword ptr [eax], xmm0
              }
              *(_DWORD *)(_EAX + 8) = v11;
            }
          }
          else
          {
            v17 = *(_DWORD *)(v5 + 32);
            v15 = (signed int)((unsigned __int64)(715827883i64 * (signed int)((char *)&v25 - v14)) >> 32) >> 1;
            v16 = v15 + ((unsigned int)v15 >> 31);
            v29 = v15 + ((unsigned int)v15 >> 31);
            if ( v17 == *(_DWORD *)(v5 + 36) )
            {
              loc_10019280(v5 + 28, v15 + ((unsigned int)v15 >> 31));
              v16 = v29;
            }
            _EAX = *(_DWORD *)(v5 + 28) + 12 * v16;
            _ECX = *(_DWORD *)(v5 + 32);
            if ( _ECX )
            {
              __asm
              {
                movq    xmm0, qword ptr [eax]
                movq    qword ptr [ecx], xmm0
              }
              *(_DWORD *)(_ECX + 8) = *(_DWORD *)(_EAX + 8);
            }
          }
          v21 = v28;
          *(_DWORD *)(v5 + 32) += 12;
          v9 = *(_DWORD *)v21;
          v11 = v30;
          v12 -= *(_DWORD *)v21;
          v10 += *(_DWORD *)v21;
        }
        while ( (unsigned int)v12 > *(_DWORD *)v21 );
        v4 = HIDWORD(a2);
        v6 = v27;
        LODWORD(v31) = v10;
        v5 = v21;
      }
      if ( v10 != HIDWORD(v31) )
      {
LABEL_32:
        sub_10018E10(v5 + 28, (unsigned int)&v31);
        v4 = HIDWORD(a2);
      }
    }
    v3 = v6 + 1;
    LODWORD(a2) = v6 + 1;
  }
}
// 10074200: using guessed type int __security_cookie;

//----- (10018DA0) --------------------------------------------------------
void __thiscall sub_10018DA0(void *this, int a2, int a3, int a4)
{
  void *v4; // ebx@1
  unsigned int v5; // esi@1
  int v6; // eax@2
  int v7; // edx@2
  int v8; // edi@2
  int v9; // ecx@3
  int v10; // [sp+8h] [bp-Ch]@4
  unsigned int v11; // [sp+Ch] [bp-8h]@4
  int v12; // [sp+10h] [bp-4h]@4

  v4 = this;
  v5 = *(_DWORD *)this;
  if ( !*(_DWORD *)this )
    goto LABEL_10;
  v7 = a3;
  v6 = a2;
  v8 = a3 - a2;
  if ( a3 - a2 > v5 )
  {
    v9 = (int)((char *)this + 28);
    do
    {
      v10 = v6;
      v11 = v5 + v6;
      v12 = a4;
      sub_10018E10(v9, (unsigned int)&v10);
      v5 = *(_DWORD *)v4;
      v6 = *(_DWORD *)v4 + a2;
      v8 -= *(_DWORD *)v4;
      a2 += *(_DWORD *)v4;
      v9 = (int)((char *)v4 + 28);
    }
    while ( v8 > v5 );
    v7 = a3;
  }
  if ( v6 != v7 )
LABEL_10:
    sub_10018E10((int)((char *)v4 + 28), (unsigned int)&a2);
}

//----- (10018E10) --------------------------------------------------------
void __thiscall sub_10018E10(int this, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int v4; // esi@1
  int v5; // edi@3
  signed int v6; // edx@3

  v4 = this;
  v2 = *(_DWORD *)(this + 4);
  _EDI = a2;
  if ( a2 >= v2 || *(_DWORD *)v4 > a2 )
  {
    if ( v2 == *(_DWORD *)(v4 + 8) )
      loc_10019280(v4, v2);
    _ECX = *(_DWORD *)(v4 + 4);
    if ( _ECX )
    {
      __asm
      {
        movq    xmm0, qword ptr [edi]
        movq    qword ptr [ecx], xmm0
      }
      *(_DWORD *)(_ECX + 8) = *(_DWORD *)(a2 + 8);
    }
  }
  else
  {
    v6 = (signed int)((unsigned __int64)(715827883i64 * (signed int)(a2 - *(_DWORD *)v4)) >> 32) >> 1;
    v5 = v6 + ((unsigned int)v6 >> 31);
    if ( v2 == *(_DWORD *)(v4 + 8) )
      loc_10019280(v4, v2);
    _EAX = *(_DWORD *)v4 + 12 * v5;
    _ECX = *(_DWORD *)(v4 + 4);
    if ( _ECX )
    {
      __asm
      {
        movq    xmm0, qword ptr [eax]
        movq    qword ptr [ecx], xmm0
      }
      *(_DWORD *)(_ECX + 8) = *(_DWORD *)(_EAX + 8);
      *(_DWORD *)(v4 + 4) += 12;
      return;
    }
  }
  *(_DWORD *)(v4 + 4) += 12;
}

//----- (10018EE0) --------------------------------------------------------
int __thiscall sub_10018EE0(int this)
{
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_BYTE *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 40) = 0;
  *(_BYTE *)(this + 44) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 52) = 0;
  *(_BYTE *)(this + 56) = 0;
  *(_DWORD *)(this + 60) = 0;
  *(_DWORD *)(this + 64) = 0;
  *(_BYTE *)(this + 68) = 0;
  return this;
}

//----- (10018F50) --------------------------------------------------------
int __thiscall sub_10018F50(int this, int a2, int a3, int a4, int a5)
{
  int result; // eax@1
  int v6; // esi@1
  int v7; // ecx@1
  char v8; // zf@1

  v6 = this;
  *(_DWORD *)this = a2;
  *(_DWORD *)(this + 4) = a3;
  v7 = this + 16;
  *(_DWORD *)(v6 + 8) = a4;
  *(_DWORD *)(v6 + 12) = 0;
  *(_DWORD *)v7 = 0;
  *(_BYTE *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) = 0;
  *(_DWORD *)(v7 + 12) = 0;
  *(_DWORD *)(v7 + 16) = 0;
  *(_DWORD *)(v7 + 20) = 0;
  *(_DWORD *)(v7 + 24) = 0;
  *(_BYTE *)(v7 + 28) = 0;
  *(_DWORD *)(v7 + 32) = 0;
  *(_DWORD *)(v7 + 36) = 0;
  *(_BYTE *)(v7 + 40) = 0;
  *(_DWORD *)(v7 + 44) = 0;
  *(_DWORD *)(v7 + 48) = 0;
  *(_BYTE *)(v7 + 52) = 0;
  v8 = sub_100195A0(v7, *(_DWORD *)(v6 + 8), *(_DWORD *)v6, *(_DWORD *)(v6 + 4), *(_DWORD *)(v6 + 12), *(_DWORD *)v6) == 0;
  result = v6;
  if ( v8 )
    *(_DWORD *)(v6 + 8) = 0;
  return result;
}

//----- (10019030) --------------------------------------------------------
int __thiscall sub_10019030(int this, int a2, int a3)
{
  int v4; // edi@1

  v4 = this;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 32) = 0;
  sub_10019200(a2, this);
  sub_10019310(v4);
  return a2;
}

//----- (100190D0) --------------------------------------------------------
int __thiscall sub_100190D0(int this, int a2)
{
  int v2; // eax@2
  int v3; // ecx@2
  char v4; // bl@4
  int *v5; // edi@4
  char v6; // bl@10
  void *v8; // [sp+10h] [bp-34h]@2
  int v9; // [sp+20h] [bp-24h]@2
  unsigned int v10; // [sp+24h] [bp-20h]@2
  void *v11; // [sp+28h] [bp-1Ch]@5
  int v12; // [sp+38h] [bp-Ch]@5
  unsigned int v13; // [sp+3Ch] [bp-8h]@5

  if ( *(_BYTE *)(this + 8) )
  {
    v2 = *(_DWORD *)(this + 4);
    v3 = *(_DWORD *)this;
    v10 = 15;
    v9 = 0;
    LOBYTE(v8) = 0;
    if ( v3 != v2 )
      loc_1000AEB0(&v8, v3, v2 - v3);
    v5 = (int *)&v8;
    v4 = 1;
  }
  else
  {
    v13 = 15;
    v12 = 0;
    LOBYTE(v11) = 0;
    v5 = (int *)&v11;
    v4 = 2;
  }
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  if ( (unsigned int)v5[5] >= 0x10 )
  {
    *(_DWORD *)a2 = *v5;
    *v5 = 0;
  }
  else
  {
    if ( v5[4] != -1 )
      sub_1002A4B0((void *)a2, v5, v5[4] + 1);
  }
  *(_DWORD *)(a2 + 16) = v5[4];
  v6 = v4 | 4;
  *(_DWORD *)(a2 + 20) = v5[5];
  v5[5] = 15;
  v5[4] = 0;
  *(_BYTE *)v5 = 0;
  if ( v6 & 2 )
  {
    v6 &= 0xFDu;
    if ( v13 >= 0x10 )
      sub_1002A4AA(v11);
    v13 = 15;
    v12 = 0;
    LOBYTE(v11) = 0;
  }
  if ( v6 & 1 )
  {
    if ( v10 >= 0x10 )
      sub_1002A4AA(v8);
  }
  return a2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10019200) --------------------------------------------------------
int __thiscall sub_10019200(int this, int a2)
{
  _ESI = a2;
  _EDI = this;
  *(_DWORD *)this = *(_DWORD *)a2;
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(this + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(this + 16) = *(_DWORD *)(a2 + 16);
  *(_BYTE *)(this + 20) = *(_BYTE *)(a2 + 20);
  sub_10019410(this + 24, a2 + 24);
  __asm
  {
    movq    xmm0, qword ptr [esi+24h]
    movq    qword ptr [edi+24h], xmm0
  }
  *(_DWORD *)(_EDI + 44) = *(_DWORD *)(a2 + 44);
  __asm
  {
    movq    xmm0, qword ptr [esi+30h]
    movq    qword ptr [edi+30h], xmm0
  }
  *(_DWORD *)(_EDI + 56) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(_EDI + 60) = 0;
  *(_DWORD *)(_EDI + 64) = 0;
  *(_BYTE *)(_EDI + 68) = 0;
  return _EDI;
}

//----- (10019310) --------------------------------------------------------
int __thiscall sub_10019310(int this)
{
  int v1; // edx@1
  int v2; // edi@1
  int v3; // eax@2
  int v4; // esi@2
  int v5; // ST0C_4@6

  v2 = this;
  v1 = *(_DWORD *)(this + 8);
  if ( !v1 )
    return v2;
  v3 = *(_DWORD *)(this + 24);
  v4 = *(_DWORD *)(v3 + 4);
  if ( *(_DWORD *)v3 != v4 )
    goto LABEL_6;
  if ( v4 == *(_DWORD *)(this + 4) )
  {
LABEL_7:
    *(_DWORD *)(v2 + 8) = 0;
    return v2;
  }
  if ( !sub_100195A0(this + 16, v1, v4, *(_DWORD *)(this + 4), *(_DWORD *)(this + 12) | 0x60, *(_DWORD *)this) )
  {
    ++v4;
LABEL_6:
    v5 = *(_DWORD *)v2;
    *(_DWORD *)(v2 + 12) |= 0x100u;
    if ( !sub_100195A0(v2 + 16, *(_DWORD *)(v2 + 8), v4, *(_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 12), v5) )
      goto LABEL_7;
  }
  return v2;
}

//----- (10019410) --------------------------------------------------------
int __thiscall sub_10019410(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  if ( (unsigned __int8)loc_10019490((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) / 12) )
    *(_DWORD *)(v2 + 4) = sub_1001C280(*(void **)v2, *(_DWORD *)a2, *(_DWORD *)(a2 + 4));
  return v2;
}

//----- (10019500) --------------------------------------------------------
int __userpurge sub_10019500<eax>(int a1<ecx>, int a2<edi>, int a3, int a4)
{
  int v4; // ecx@1
  int v5; // ebx@1
  int ebp0; // ebp@0
  int v7; // edi@1
  int v9; // [sp+10h] [bp-10h]@1

  v5 = a1;
  v9 = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = sub_1002987D(a1, ebp0, a2);
  v7 = (int)&dword_10075FA0;
  v4 = (int)&dword_10075FA0;
  if ( (unsigned int)dword_10075FB4 >= 0x10 )
    v4 = dword_10075FA0;
  if ( (unsigned int)dword_10075FB4 >= 0x10 )
    v7 = dword_10075FA0;
  sub_10019E30(v5, v5, v7, v4 + dword_10075FB0, v4, v9);
  return v5;
}
// 10075FA0: using guessed type int dword_10075FA0;
// 10075FB0: using guessed type int dword_10075FB0;
// 10075FB4: using guessed type int dword_10075FB4;

//----- (100195A0) --------------------------------------------------------
char __fastcall sub_100195A0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // edi@1
  int v8; // edx@3
  int v9; // ecx@3
  char v10; // bl@3
  int v11; // esi@3
  int v12; // eax@7
  int v13; // ecx@9
  int v14; // eax@12
  int v15; // ecx@12
  int v16; // [sp+10h] [bp-94h]@1
  char v17; // [sp+14h] [bp-90h]@3
  int v18; // [sp+68h] [bp-3Ch]@13
  int v19; // [sp+74h] [bp-30h]@12
  unsigned int v20; // [sp+94h] [bp-10h]@1
  int v21; // [sp+A0h] [bp-4h]@9
  int v22; // [sp+A4h] [bp+0h]@1
  int i; // [sp+ACh] [bp+8h]@12

  v20 = (unsigned int)&v22 ^ __security_cookie;
  v16 = a2;
  v6 = a1;
  if ( !*(_DWORD *)a2 )
    return 0;
  v11 = a3;
  v10 = 0;
  sub_10019810((int)&v17, a1);
  v8 = v16;
  v9 = *(_DWORD *)v16;
  if ( *(_DWORD *)v16 )
    v16 = *(_DWORD *)(v9 + 20);
  else
    v16 = 0;
  if ( v9 )
    v12 = *(_DWORD *)(v9 + 28) - 1;
  else
    v12 = 0;
  sub_10019A90((int)&v17, a3, a4, v8 + 4, v9, v12 + 1, v16, a5);
  v21 = 0;
  if ( sub_1001A270((int)&v17, v6, v13) )
    goto LABEL_16;
  if ( a3 == a4 || a5 & 0x40 )
    goto LABEL_18;
  v19 = (v19 | 0x100) & 0xFFFFDFFF;
  v14 = *(_DWORD *)sub_10019F10((int)&v17, (int)&v16, a3 + 1, a4, 0);
  v15 = a4;
  for ( i = v14; v14 != a4; i = v14 )
  {
    v18 = v14;
    if ( sub_1001A270((int)&v17, v6, v15) )
      goto LABEL_16;
    v14 = *(_DWORD *)sub_10019F10((int)&v17, (int)&v16, i + 1, a4, 0);
    v15 = a4;
  }
  v18 = v15;
  if ( sub_1001A270((int)&v17, v6, v15) )
  {
LABEL_16:
    v10 = 1;
    if ( v6 )
    {
      *(_DWORD *)v6 = a6;
      *(_DWORD *)(v6 + 20) = v11;
    }
  }
LABEL_18:
  sub_10019740((int)&v17);
  return v10;
}
// 10074200: using guessed type int __security_cookie;

//----- (10019740) --------------------------------------------------------
int __thiscall sub_10019740(int this)
{
  int v1; // esi@1
  int result; // eax@9

  v1 = this;
  if ( *(_DWORD *)(this + 64) )
  {
    sub_1002A4AA(*(LPVOID *)(this + 64));
    *(_DWORD *)(v1 + 64) = 0;
    *(_DWORD *)(v1 + 68) = 0;
    *(_DWORD *)(v1 + 72) = 0;
  }
  if ( *(_DWORD *)(v1 + 52) )
  {
    sub_1002A4AA(*(LPVOID *)(v1 + 52));
    *(_DWORD *)(v1 + 52) = 0;
    *(_DWORD *)(v1 + 56) = 0;
    *(_DWORD *)(v1 + 60) = 0;
  }
  *(_DWORD *)(v1 + 48) = 0;
  if ( *(_DWORD *)(v1 + 36) )
  {
    sub_1002A4AA(*(LPVOID *)(v1 + 36));
    *(_DWORD *)(v1 + 36) = 0;
    *(_DWORD *)(v1 + 40) = 0;
    *(_DWORD *)(v1 + 44) = 0;
  }
  if ( *(_DWORD *)(v1 + 20) )
  {
    sub_1002A4AA(*(LPVOID *)(v1 + 20));
    *(_DWORD *)(v1 + 20) = 0;
    *(_DWORD *)(v1 + 24) = 0;
    *(_DWORD *)(v1 + 28) = 0;
  }
  *(_DWORD *)(v1 + 16) = 0;
  result = *(_DWORD *)(v1 + 4);
  if ( result )
  {
    result = sub_1002A4AA(*(LPVOID *)(v1 + 4));
    *(_DWORD *)(v1 + 4) = 0;
    *(_DWORD *)(v1 + 8) = 0;
    *(_DWORD *)(v1 + 12) = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10019810) --------------------------------------------------------
void __thiscall sub_10019810(int this, int a2)
{
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 40) = 0;
  *(_DWORD *)(this + 44) = 0;
  *(_DWORD *)(this + 52) = 0;
  *(_DWORD *)(this + 56) = 0;
  *(_DWORD *)(this + 60) = 0;
  *(_DWORD *)(this + 64) = 0;
  *(_DWORD *)(this + 68) = 0;
  *(_DWORD *)(this + 72) = 0;
  *(_DWORD *)(this + 76) = 0;
  *(_DWORD *)(this + 80) = 0;
  *(_DWORD *)(this + 84) = 0;
  *(_DWORD *)(this + 88) = 0;
}

//----- (10019980) --------------------------------------------------------
LPVOID __thiscall sub_10019980(LPVOID *this)
{
  LPVOID result; // eax@1
  LPVOID *v2; // esi@1

  v2 = this;
  result = *this;
  if ( *this )
  {
    result = (LPVOID)sub_1002A4AA(*this);
    *v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100199B0) --------------------------------------------------------
signed int __thiscall sub_100199B0(void *this, int a2)
{
  int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  unsigned int v7; // esi@3
  unsigned int v8; // eax@5
  signed int v9; // ebx@7
  void *v11; // [sp+14h] [bp-40h]@1
  unsigned int v12; // [sp+28h] [bp-2Ch]@13
  void *v13; // [sp+2Ch] [bp-28h]@1
  int v14; // [sp+3Ch] [bp-18h]@13
  unsigned int v15; // [sp+40h] [bp-14h]@11
  int v16; // [sp+50h] [bp-4h]@1
  unsigned int v17; // [sp+5Ch] [bp+8h]@1

  v6 = (int)this;
  v5 = sub_100190D0(a2, (int)&v11);
  v16 = 0;
  v2 = sub_100190D0(v6, (int)&v13);
  v3 = *(_DWORD *)(v5 + 16);
  v4 = v2;
  v17 = *(_DWORD *)(v5 + 16);
  if ( *(_DWORD *)(v5 + 20) >= 0x10u )
    v5 = *(_DWORD *)v5;
  v7 = *(_DWORD *)(v2 + 16);
  if ( *(_DWORD *)(v2 + 20) >= 0x10u )
    v4 = *(_DWORD *)v2;
  v8 = v3;
  if ( v7 < v3 )
    v8 = v7;
  v9 = sub_100099E0(v4, v5, v8);
  if ( !v9 )
  {
    if ( v7 >= v17 )
      v9 = v7 != v17;
    else
      v9 = -1;
  }
  if ( v15 >= 0x10 )
    sub_1002A4AA(v13);
  v15 = 15;
  v14 = 0;
  LOBYTE(v13) = 0;
  if ( v12 >= 0x10 )
    sub_1002A4AA(v11);
  return v9;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10019A90) --------------------------------------------------------
int __thiscall sub_10019A90(int this, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // edi@1
  char v9; // al@3
  int v11; // [sp+10h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-4h]@1

  v8 = this;
  *(_DWORD *)this = 0;
  v11 = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  sub_10019D80((void *)(this + 4), 0, (int)&v11);
  *(_DWORD *)(v8 + 16) = 0;
  *(_DWORD *)(v8 + 20) = 0;
  *(_DWORD *)(v8 + 24) = 0;
  *(_DWORD *)(v8 + 28) = 0;
  v12 = 0;
  *(_DWORD *)(v8 + 32) = 0;
  v11 = 0;
  *(_DWORD *)(v8 + 36) = 0;
  *(_DWORD *)(v8 + 40) = 0;
  *(_DWORD *)(v8 + 44) = 0;
  sub_10019D80((void *)(v8 + 36), 0, (int)&v11);
  *(_DWORD *)(v8 + 48) = 0;
  *(_DWORD *)(v8 + 52) = 0;
  *(_DWORD *)(v8 + 56) = 0;
  *(_DWORD *)(v8 + 60) = 0;
  *(_DWORD *)(v8 + 64) = 0;
  *(_DWORD *)(v8 + 68) = 0;
  *(_DWORD *)(v8 + 72) = 0;
  LOBYTE(v12) = 2;
  *(_DWORD *)(v8 + 76) = 0;
  *(_DWORD *)(v8 + 80) = a3;
  *(_DWORD *)(v8 + 84) = a2;
  *(_DWORD *)(v8 + 92) = a7;
  *(_DWORD *)(v8 + 88) = a5;
  *(_DWORD *)(v8 + 96) = a8;
  *(_BYTE *)(v8 + 100) = 0;
  *(_DWORD *)(v8 + 104) = a6;
  v9 = *(_BYTE *)(a5 + 8) & 8 && !(a8 & 0x10);
  *(_BYTE *)(v8 + 108) = v9;
  *(_DWORD *)(v8 + 112) = a4;
  sub_10019BE0(v8 + 64, *(_DWORD *)(a5 + 24));
  return v8;
}

//----- (10019BE0) --------------------------------------------------------
int __thiscall sub_10019BE0(int this, unsigned int a2)
{
  int result; // eax@1
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // edx@2

  v4 = this;
  v5 = *(_DWORD *)(this + 4);
  result = *(_DWORD *)this;
  v3 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 3;
  if ( v3 <= a2 )
  {
    if ( v3 >= a2 )
      return result;
    loc_10019C80(v4, a2 - v3);
    sub_1001C2C0(*(_DWORD *)(v4 + 4), a2 - ((*(_DWORD *)(v4 + 4) - *(_DWORD *)v4) >> 3));
    result = *(_DWORD *)(v4 + 4) + 8 * (a2 - ((*(_DWORD *)(v4 + 4) - *(_DWORD *)v4) >> 3));
    goto LABEL_9;
  }
  v6 = result + 8 * a2;
  if ( v6 == result )
  {
LABEL_9:
    *(_DWORD *)(v4 + 4) = result;
    return result;
  }
  if ( v6 != v5 )
  {
    result = v5;
    *(_DWORD *)(v4 + 4) = v6;
  }
  return result;
}

//----- (10019D80) --------------------------------------------------------
int __thiscall sub_10019D80(void *this, int a2, int a3)
{
  int result; // eax@1
  void *v4; // ebx@1
  int v5; // esi@1
  int v6; // eax@2
  int v7; // edx@2
  int v8; // ecx@2
  int v9; // [sp+10h] [bp+8h]@2

  v5 = a2;
  v4 = this;
  result = loc_10019DC0(a2);
  if ( (_BYTE)result )
  {
    v6 = *(_DWORD *)v4;
    v9 = *(_DWORD *)v4;
    v8 = v5;
    v7 = *(_DWORD *)v4;
    if ( v5 )
    {
      do
      {
        *(_DWORD *)v7 = *(_DWORD *)a3;
        v7 += 4;
        --v8;
      }
      while ( v8 );
      v6 = v9;
    }
    result = v6 + 4 * v5;
    *((_DWORD *)v4 + 1) = result;
  }
  return result;
}

//----- (10019E30) --------------------------------------------------------
void *__userpurge sub_10019E30<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int *v7; // edi@1
  int v8; // esi@1
  int v9; // ecx@3
  char v10; // zf@4
  void *result; // eax@6
  int v12; // [sp+Ch] [bp-68h]@1
  int v13; // [sp+10h] [bp-64h]@1
  int v14; // [sp+14h] [bp-60h]@1
  void *v15; // [sp+20h] [bp-54h]@1
  int v16; // [sp+24h] [bp-50h]@1
  int v17; // [sp+28h] [bp-4Ch]@1
  int v18; // [sp+2Ch] [bp-48h]@6
  int v19; // [sp+30h] [bp-44h]@1
  int v20; // [sp+34h] [bp-40h]@1
  unsigned int v21; // [sp+64h] [bp-10h]@1
  int v22; // [sp+70h] [bp-4h]@1
  int v23; // [sp+74h] [bp+0h]@1

  v21 = (unsigned int)&v23 ^ __security_cookie;
  v7 = (int *)a1;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v19 = 0;
  v20 = 0;
  sub_1001B7B0((int)&v12, a2, a1 + 4, a3, a4, a1);
  v22 = 0;
  v6 = sub_1001B890(&v12);
  v8 = v6;
  if ( v6 )
    ++*(_DWORD *)(v6 + 32);
  v9 = *v7;
  if ( *v7 )
  {
    v10 = *(_DWORD *)(v9 + 32)-- == 1;
    if ( v10 )
      sub_100183F0(*v7, 0);
  }
  result = v15;
  *v7 = v8;
  v18 = 0;
  if ( result )
    result = (void *)sub_1002A4AA(result);
  return result;
}
// 1001B890: using guessed type int __thiscall sub_1001B890(_DWORD);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10019F10) --------------------------------------------------------
int __thiscall sub_10019F10(int this, int a2, int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // esi@1
  int v8; // eax@3
  int v9; // edx@3
  int v10; // edx@19
  int v11; // ebx@19
  int v12; // esi@19
  int v13; // eax@20
  int v14; // ecx@24
  int v16; // esi@30
  int v17; // eax@31
  int v18; // ecx@31
  char v19; // bl@32
  char v20; // bl@35
  char v21; // al@35
  int v22; // ecx@37
  int v23; // esi@37
  int v24; // esi@38
  int v25; // edx@41
  unsigned __int8 v26; // sf@41
  unsigned __int8 v27; // of@41
  int v28; // ebx@47
  int v29; // ecx@48
  int v30; // esi@48
  int v31; // ebx@54
  char v32; // al@55
  char v33; // zf@55
  int v34; // esi@57
  char v35; // al@58
  char v36; // zf@58
  int v37; // ecx@64
  char v38; // [sp+10h] [bp-28h]@67
  char v39; // [sp+14h] [bp-24h]@22
  char v40; // [sp+18h] [bp-20h]@31
  char v41; // [sp+1Ch] [bp-1Ch]@23
  char v42; // [sp+20h] [bp-18h]@20
  int v43; // [sp+24h] [bp-14h]@23
  int v44; // [sp+28h] [bp-10h]@1
  int v45; // [sp+2Ch] [bp-Ch]@1
  int v46; // [sp+30h] [bp-8h]@19
  unsigned int v47; // [sp+34h] [bp-4h]@1
  int v48; // [sp+38h] [bp+0h]@1

  v47 = (unsigned int)&v48 ^ __security_cookie;
  v7 = a2;
  v6 = a5;
  v5 = this;
  v45 = this;
  v44 = a2;
  if ( !a5 )
    v6 = *(_DWORD *)(this + 88);
  v8 = a3;
  v9 = a4;
  if ( a3 != a4 )
  {
    while ( 2 )
    {
      if ( v6 )
      {
        switch ( *(_DWORD *)(v6 + 4) )
        {
          case 0xC:
          case 0x15:
            v6 = 0;
            continue;
          case 1:
          case 8:
          case 9:
          case 0xD:
          case 0xE:
          case 0x14:
            v6 = *(_DWORD *)(v6 + 12);
            continue;
          case 2:
            if ( *(_BYTE *)(this + 96) & 1 )
              goto LABEL_68;
            if ( a3 != a4 )
            {
              do
              {
                if ( *(_BYTE *)(v8 - 1) == 10 )
                  break;
                ++v8;
              }
              while ( v8 != a4 );
            }
            goto LABEL_27;
          case 3:
            if ( *(_BYTE *)(this + 96) & 2 )
              goto LABEL_68;
            if ( a3 != a4 )
            {
              do
              {
                if ( *(_BYTE *)v8 == 10 )
                  break;
                ++v8;
              }
              while ( v8 != a4 );
            }
            goto LABEL_27;
          case 6:
            if ( a3 == a4 )
              goto LABEL_27;
            do
            {
              v12 = *(_DWORD *)(v5 + 92);
              v10 = *(_DWORD *)(v6 + 28);
              LOBYTE(v46) = (*(_DWORD *)(v5 + 96) >> 7) & 1;
              v11 = v10 + 1;
              if ( v12 & 0x800 )
              {
                v13 = sub_1001D2B0((int)&v42, *(_DWORD *)(v6 + 28), v8, v8 + 1, v11, *(_DWORD *)(v45 + 112), v46);
              }
              else
              {
                if ( v12 & 0x100 )
                {
                  v13 = sub_1001D4B0(
                          (int)&v39,
                          *(_DWORD *)(v6 + 28),
                          v8,
                          (int *)(v8 + 1),
                          v11,
                          *(_DWORD *)(v45 + 112),
                          v46);
                }
                else
                {
                  LOBYTE(v43) = 0;
                  v13 = sub_1001D560((int)&v41, v10, v8, v8 + 1, v10 + 1, v43, v46);
                }
              }
              v14 = *(_DWORD *)v13;
              v8 = a3;
              if ( v14 != a3 )
                break;
              v5 = v45;
              v8 = a3 + 1;
              a3 = v8;
            }
            while ( v8 != a4 );
            goto LABEL_26;
          default:
            goto LABEL_27;
          case 7:
            if ( a3 == a4 )
              goto LABEL_27;
            break;
          case 0x10:
            if ( a3 != a4 )
            {
              do
              {
                if ( !v6 )
                  break;
                v9 = *(_DWORD *)sub_10019F10(&v38, v8, v9, *(_DWORD *)(v6 + 12));
                v8 = a3;
                v6 = *(_DWORD *)(v6 + 24);
              }
              while ( a3 != v9 );
            }
LABEL_68:
            *(_DWORD *)a2 = v9;
            return v7;
        }
        while ( 1 )
        {
          v16 = *(_DWORD *)(v6 + 20);
          LOBYTE(v46) = *(_BYTE *)v8;
          if ( v16 )
          {
            v17 = sub_1001BF10((int)&v40, v16, v8, v8 + 1);
            v9 = a4;
            v18 = v17;
            v8 = a3;
            if ( *(_DWORD *)v18 != a3 )
            {
              v19 = 1;
              goto LABEL_61;
            }
          }
          if ( *(_DWORD *)(v6 + 32) )
          {
            if ( *(_DWORD *)(v5 + 92) & 0x800 )
            {
              v21 = sub_1001A460(*(_DWORD *)(v5 + 112), v5, v6, v46);
              v9 = a4;
              v20 = v21;
              v8 = a3;
            }
            else
            {
              v20 = v46;
            }
            v23 = *(_DWORD *)(v6 + 32);
            v22 = 0;
            if ( *(_DWORD *)(v23 + 4) > 0 )
              break;
          }
LABEL_42:
          if ( dword_100773D8 > (char)v46 || (char)v46 >= 256 )
          {
            v28 = *(_DWORD *)(v6 + 28);
            if ( v28 )
            {
              v30 = *(_DWORD *)(v28 + 8);
              v29 = v30 + *(_DWORD *)(v28 + 4);
              if ( v30 != v29 )
              {
                do
                {
                  if ( *(_BYTE *)v30 == (_BYTE)v46 )
                    break;
                  ++v30;
                }
                while ( v30 != v29 );
                v9 = a4;
              }
              if ( v30 != *(_DWORD *)(v28 + 4) + *(_DWORD *)(v28 + 8) )
              {
                v19 = 1;
                goto LABEL_61;
              }
            }
            v31 = v45;
            if ( *(_WORD *)(v6 + 36) )
            {
              v32 = sub_1001A530(*(_DWORD *)(v45 + 112), v45, v46, *(_WORD *)(v6 + 36));
              v9 = a4;
              v33 = v32 == 0;
              v8 = a3;
              if ( !v33 )
              {
                v19 = 1;
                goto LABEL_61;
              }
            }
            v34 = *(_DWORD *)(v6 + 40);
            if ( v34 )
            {
              v35 = sub_1001BFA0(v46, v34, *(void **)(v31 + 112));
              v9 = a4;
              v36 = v35 == 0;
              v8 = a3;
              if ( !v36 )
                goto LABEL_59;
            }
          }
          else
          {
            if ( *(_DWORD *)(v6 + 24)
              && (unsigned __int8)(1 << (v46 & 7)) & *(_BYTE *)(((unsigned int)(char)v46 >> 3) + *(_DWORD *)(v6 + 24)) )
            {
              v19 = 1;
              goto LABEL_61;
            }
          }
          v19 = 0;
LABEL_61:
          if ( v19 != (*(_BYTE *)(v6 + 8) & 1) )
          {
            v37 = v44;
            *(_DWORD *)v44 = v8;
            return v37;
          }
          v5 = v45;
          ++v8;
          a3 = v8;
          if ( v8 == v9 )
          {
LABEL_26:
            v7 = v44;
            goto LABEL_27;
          }
        }
        v24 = *(_DWORD *)(v23 + 8);
        while ( *(_BYTE *)(v24 + v22) > v20 || v20 > *(_BYTE *)(v24 + v22 + 1) )
        {
          v25 = *(_DWORD *)(v6 + 32);
          v22 += 2;
          v27 = __SETO__(v22, *(_DWORD *)(v25 + 4));
          v26 = v22 - *(_DWORD *)(v25 + 4) < 0;
          v9 = a4;
          if ( !(v26 ^ v27) )
            goto LABEL_42;
        }
LABEL_59:
        v19 = 1;
        goto LABEL_61;
      }
      break;
    }
  }
LABEL_27:
  *(_DWORD *)v7 = v8;
  return v7;
}
// 10074200: using guessed type int __security_cookie;
// 100773D8: using guessed type int dword_100773D8;

//----- (1001A270) --------------------------------------------------------
char __thiscall sub_1001A270(int this, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int v5; // eax@1
  int v6; // ST00_4@1
  int v7; // ST04_4@1
  int v8; // eax@3
  unsigned int v9; // edx@7
  int v10; // ebx@7
  int v11; // edi@8
  int v12; // ebx@9
  int v13; // ebx@11
  int v15; // eax@15
  int v16; // ecx@19

  v4 = this;
  v5 = *(_DWORD *)(this + 84);
  v6 = *(_DWORD *)(this + 104);
  *(_DWORD *)(this + 76) = v5;
  *(_DWORD *)this = v5;
  sub_1001A620(this + 4, v6, this);
  sub_1001A830(v4 + 20, *(_DWORD *)(v4 + 104));
  v3 = a2;
  v7 = *(_DWORD *)(v4 + 88);
  *(_BYTE *)(v4 + 101) = a2 != 0;
  *(_BYTE *)(v4 + 116) = 0;
  *(_DWORD *)(v4 + 120) = 10000000;
  *(_DWORD *)(v4 + 124) = 1000;
  *(_BYTE *)(v4 + 100) = 0;
  if ( !(unsigned __int8)loc_1001B950(v4, v7) )
  {
    if ( !(*(_BYTE *)(v4 + 96) & 0x80) || (v8 = *(_DWORD *)(v4 + 80), *(_DWORD *)v4 != v8) || *(_DWORD *)(v4 + 84) == v8 )
      return 0;
    sub_1001A420((void *)(v4 + 32), v4);
    *(_BYTE *)(v4 + 100) = 1;
  }
  if ( a2 )
  {
    v10 = a2 + 8;
    sub_1001ADC0(a2 + 8, *(_DWORD *)(v4 + 104));
    v9 = 0;
    if ( *(_DWORD *)(v4 + 104) > 0 )
    {
      v11 = 0;
      do
      {
        v12 = *(_DWORD *)(v4 + 36);
        if ( (signed int)v9 < 0 && v9 )
          v13 = v12 - (4 * ((-1 - v9) >> 5) + 4);
        else
          v13 = v12 + 4 * (v9 >> 5);
        if ( (1 << (v9 & 0x1F)) & *(_DWORD *)v13 )
        {
          v10 = a2 + 8;
          *(_BYTE *)(v11 + *(_DWORD *)(a2 + 8) + 8) = 1;
          *(_DWORD *)(v11 + *(_DWORD *)(a2 + 8)) = *(_DWORD *)(*(_DWORD *)(v4 + 52) + 8 * v9);
          v15 = *(_DWORD *)(*(_DWORD *)(v4 + 52) + 8 * v9 + 4);
        }
        else
        {
          v10 = a2 + 8;
          *(_BYTE *)(v11 + *(_DWORD *)(a2 + 8) + 8) = 0;
          *(_DWORD *)(v11 + *(_DWORD *)(a2 + 8)) = *(_DWORD *)(v4 + 80);
          v15 = *(_DWORD *)(v4 + 80);
        }
        ++v9;
        *(_DWORD *)(v11 + *(_DWORD *)v10 + 4) = v15;
        v11 += 12;
      }
      while ( (signed int)v9 < *(_DWORD *)(v4 + 104) );
      v3 = a2;
    }
    v16 = *(_DWORD *)v10;
    *(_DWORD *)v3 = *(_DWORD *)(v4 + 76);
    *(_BYTE *)(v3 + 28) = 1;
    *(_DWORD *)(v3 + 20) = *(_DWORD *)(v4 + 76);
    *(_DWORD *)(v3 + 24) = *(_DWORD *)v16;
    *(_BYTE *)(v3 + 40) = 1;
    *(_DWORD *)(v3 + 32) = *(_DWORD *)(v16 + 4);
    *(_DWORD *)(v3 + 36) = *(_DWORD *)(v4 + 80);
    *(_DWORD *)(v3 + 44) = *(_DWORD *)(v4 + 80);
    *(_DWORD *)(v3 + 48) = *(_DWORD *)(v4 + 80);
    *(_BYTE *)(v3 + 4) = 1;
  }
  return 1;
}

//----- (1001A420) --------------------------------------------------------
void *__thiscall sub_1001A420(void *this, int a2)
{
  void *v3; // edi@1
  int v4; // ecx@1

  v3 = this;
  *(_DWORD *)this = *(_DWORD *)a2;
  v4 = (int)((char *)this + 4);
  *(_DWORD *)(v4 + 12) = *(_DWORD *)(a2 + 16);
  sub_1001ACB0(v4, a2 + 4);
  sub_1001A740((char *)v3 + 20, a2 + 20);
  return v3;
}

//----- (1001A460) --------------------------------------------------------
char __userpurge sub_1001A460<al>(int a1<ecx>, int a2<ebx>, int a3<edi>, __int16 a4)
{
  void **v4; // esi@1
  int v5; // ecx@2
  int v6; // eax@2
  int v7; // eax@2
  int v8; // edx@2
  int v9; // eax@3
  int *v10; // eax@6
  char v11; // bl@8
  unsigned int v13; // [sp-4h] [bp-3Ch]@1
  int v14; // [sp+8h] [bp-30h]@2
  void *v15; // [sp+Ch] [bp-2Ch]@5
  int v16; // [sp+1Ch] [bp-1Ch]@5
  unsigned int v17; // [sp+20h] [bp-18h]@6
  unsigned int v18; // [sp+24h] [bp-14h]@1
  int v19; // [sp+34h] [bp-4h]@2
  int v20; // [sp+38h] [bp+0h]@1

  v18 = (unsigned int)&v20 ^ __security_cookie;
  v13 = (unsigned int)&v20 ^ __security_cookie;
  v4 = (void **)a1;
  if ( !*(_DWORD *)a1 )
  {
    v6 = sub_1001B150(a1, (int)&v14);
    v19 = 0;
    v7 = sub_1001C310(v8, a2, a3, v6);
    v19 = -1;
    v5 = v14;
    *v4 = (void *)v7;
    if ( v5 )
    {
      v9 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v5 + 8))(v13);
      if ( v9 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v9)(v9, 1);
    }
  }
  sub_1001AEF0(*v4, (int)&v15, (int)&a4, (int)((char *)&a4 + 1));
  if ( v16 == 1 )
  {
    v10 = (int *)&v15;
    if ( v17 >= 0x10 )
      v10 = (int *)v15;
    v11 = *(_BYTE *)v10;
  }
  else
  {
    v11 = a4;
  }
  if ( v17 >= 0x10 )
    sub_1002A4AA(v15);
  return v11;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (1001A530) --------------------------------------------------------
bool __userpurge sub_1001A530<eax>(int a1<ecx>, char a2<bl>, unsigned __int8 a3, int a4)
{
  unsigned __int16 v4; // di@1
  int v5; // esi@1
  int v6; // ecx@3
  int v7; // eax@3
  int v8; // eax@3
  int v9; // edx@3
  int v10; // eax@4
  bool result; // eax@6

  v5 = a1;
  v4 = a4;
  if ( (_WORD)a4 == -1 )
  {
    result = a3 == 95 || *(_WORD *)(*(_DWORD *)(sub_1001A9A0(a1, a3, (unsigned __int16)a4) + 12) + 2 * a3) & 0x107;
  }
  else
  {
    if ( !*(_DWORD *)(a1 + 4) )
    {
      v7 = sub_1001B150(a1, (int)&a4);
      v8 = sub_10017B50(v9, a2, v4, v7);
      v6 = a4;
      *(_DWORD *)(v5 + 4) = v8;
      if ( v6 )
      {
        v10 = (*(int (**)(void))(*(_DWORD *)v6 + 8))();
        if ( v10 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v10)(v10, 1);
      }
    }
    result = (v4 & *(_WORD *)(*(_DWORD *)(*(_DWORD *)(v5 + 4) + 12) + 2 * a3)) != 0;
  }
  return result;
}

//----- (1001A620) --------------------------------------------------------
void __thiscall sub_1001A620(int this, int a2, int a3)
{
  unsigned int v3; // esi@1
  int v4; // edx@2
  int v5; // edi@2
  int v6; // eax@10
  int v7; // edi@10
  int v8; // esi@10
  int v9; // eax@10
  char v10; // [sp+10h] [bp-20h]@10
  char v11; // [sp+18h] [bp-18h]@10
  int v12; // [sp+20h] [bp-10h]@8
  int v13; // [sp+24h] [bp-Ch]@10
  int v14; // [sp+28h] [bp-8h]@1
  char v15; // [sp+2Ch] [bp-4h]@1

  v3 = *(_DWORD *)(this + 12);
  v14 = this;
  v15 = 0;
  if ( a2 <= v3 )
  {
    if ( a2 < v3 )
    {
      v6 = sub_1001AA20(this, (int)&v11);
      v7 = *(_DWORD *)v6;
      v8 = *(_DWORD *)(v6 + 4);
      v12 = *(_DWORD *)v14;
      v13 = 0;
      v9 = sub_1001B0B0((int)&v12, (int)&v10, a2);
      sub_1001AA80(v14, (int)&v12, *(_DWORD *)v9, *(_DWORD *)(v9 + 4), v7, v8);
    }
  }
  else
  {
    v5 = *(_DWORD *)this;
    v4 = 0;
    if ( v3 )
    {
      if ( (signed int)v3 < 0 && v3 )
      {
        this = v14;
        v5 += -4 - 4 * ((-1 - v3) >> 5);
      }
      else
      {
        v5 += 4 * (v3 >> 5);
      }
      v4 = v3 & 0x1F;
    }
    sub_1001ABB0((void *)this, (int)&v12, a2 - v3, (int)&v15, v5, v4);
  }
}

//----- (1001A6E0) --------------------------------------------------------
int __thiscall sub_1001A6E0(void *this, int a2, unsigned int a3)
{
  int v3; // esi@1
  int result; // eax@3

  v3 = *(_DWORD *)this;
  if ( (signed int)a3 < 0 && a3 )
  {
    result = a2;
    *(_DWORD *)a2 = -4 - 4 * ((-1 - a3) >> 5) + v3;
    *(_DWORD *)(a2 + 4) = a3 & 0x1F;
  }
  else
  {
    result = a2;
    *(_DWORD *)a2 = v3 + 4 * (a3 >> 5);
    *(_DWORD *)(a2 + 4) = a3 & 0x1F;
  }
  return result;
}

//----- (1001A740) --------------------------------------------------------
void *__thiscall sub_1001A740(void *this, int a2)
{
  void *v2; // edi@1
  int v3; // ecx@2
  int v4; // esi@2
  int v6; // edx@4
  int v7; // eax@6
  int v8; // ecx@9
  int v9; // esi@9
  int v10; // [sp-10h] [bp-20h]@9
  int v11; // [sp+8h] [bp-8h]@4

  v2 = this;
  if ( this == (void *)a2 )
    return v2;
  v3 = *(_DWORD *)a2;
  v4 = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)a2 == v4 )
  {
    *((_DWORD *)v2 + 1) = *(_DWORD *)v2;
    return v2;
  }
  v6 = *(_DWORD *)v2;
  v11 = (*((_DWORD *)v2 + 1) - *(_DWORD *)v2) >> 3;
  if ( (v4 - v3) >> 3 > (unsigned int)v11 )
  {
    if ( (v4 - v3) >> 3 > (unsigned int)((*((_DWORD *)v2 + 2) - v6) >> 3) )
    {
      if ( v6 )
        sub_1002A4AA((LPVOID)v6);
      if ( !(unsigned __int8)loc_1001AE80(v2, (*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 3) )
        return v2;
      v10 = *(_DWORD *)v2;
      v8 = *(_DWORD *)a2;
    }
    else
    {
      v9 = v3 + 8 * v11;
      sub_1001C2E0(v3, v3 + 8 * v11, v6);
      v10 = *((_DWORD *)v2 + 1);
      v8 = v9;
    }
    *((_DWORD *)v2 + 1) = sub_1001D7A0(v8, *(_DWORD *)(a2 + 4), v10);
    return v2;
  }
  for ( ; v3 != v4; v6 += 8 )
  {
    *(_DWORD *)v6 = *(_DWORD *)v3;
    v7 = *(_DWORD *)(v3 + 4);
    v3 += 8;
    *(_DWORD *)(v6 + 4) = v7;
  }
  *((_DWORD *)v2 + 1) = *(_DWORD *)v2 + 8 * ((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 3);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1001A830) --------------------------------------------------------
int __thiscall sub_1001A830(int this, unsigned int a2)
{
  int result; // eax@1
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // edx@2

  v4 = this;
  v5 = *(_DWORD *)(this + 4);
  result = *(_DWORD *)this;
  v3 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 3;
  if ( v3 <= a2 )
  {
    if ( v3 >= a2 )
      return result;
    loc_10019C80(v4, a2 - v3);
    sub_1001D7D0(*(_DWORD *)(v4 + 4), a2 - ((*(_DWORD *)(v4 + 4) - *(_DWORD *)v4) >> 3));
    result = *(_DWORD *)(v4 + 4) + 8 * (a2 - ((*(_DWORD *)(v4 + 4) - *(_DWORD *)v4) >> 3));
    goto LABEL_9;
  }
  v6 = result + 8 * a2;
  if ( v6 == result )
  {
LABEL_9:
    *(_DWORD *)(v4 + 4) = result;
    return result;
  }
  if ( v6 != v5 )
  {
    result = v5;
    *(_DWORD *)(v4 + 4) = v6;
  }
  return result;
}

//----- (1001A8D0) --------------------------------------------------------
int __thiscall sub_1001A8D0(int this)
{
  int v1; // ebx@1
  int v2; // edi@1
  int v3; // esi@2
  int result; // eax@3
  int v5; // esi@3
  int v6; // esi@5
  int i; // edi@7
  int v8; // esi@8

  v1 = this;
  v2 = *(_DWORD *)(this + 20);
  *(_DWORD *)this = off_10068B0C;
  while ( v2 )
  {
    v3 = v2;
    v2 = *(_DWORD *)(v2 + 16);
    sub_100309A2(v1, *(LPVOID *)(v3 + 12));
    sub_1002A4AA((LPVOID)v3);
  }
  result = sub_1002A4AA(*(LPVOID *)(v1 + 24));
  v5 = *(_DWORD *)(v1 + 28);
  if ( v5 )
  {
    sub_100309A2(v1, *(LPVOID *)(v5 + 8));
    result = sub_1002A4AA((LPVOID)v5);
  }
  v6 = *(_DWORD *)(v1 + 32);
  if ( v6 )
  {
    sub_100309A2(v1, *(LPVOID *)(v6 + 8));
    result = sub_1002A4AA((LPVOID)v6);
  }
  for ( i = *(_DWORD *)(v1 + 40); i; result = sub_1002A4AA((LPVOID)v8) )
  {
    v8 = i;
    i = *(_DWORD *)(i + 16);
    sub_100309A2(v1, *(LPVOID *)(v8 + 12));
  }
  *(_DWORD *)v1 = off_10068B14;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10068B0C: using guessed type int (__stdcall *off_10068B0C[4])(char);
// 10068B14: using guessed type int (__stdcall *off_10068B14[2])(char);

//----- (1001A970) --------------------------------------------------------
void *__thiscall sub_1001A970(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_1001A8D0(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1001A9A0) --------------------------------------------------------
int __usercall sub_1001A9A0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // esi@1
  int result; // eax@2
  int v5; // ecx@2
  int v6; // eax@2
  int v7; // edx@2
  int v8; // eax@3
  int v9; // [sp+8h] [bp-10h]@2
  int v10; // [sp+14h] [bp-4h]@2

  v3 = a1;
  if ( !*(_DWORD *)(a1 + 4) )
  {
    v6 = sub_1001B150(a1, (int)&v9);
    v10 = 0;
    result = sub_10017B50(v7, a2, a3, v6);
    v10 = -1;
    v5 = v9;
    *(_DWORD *)(v3 + 4) = result;
    if ( !v5 )
      return result;
    v8 = (*(int (**)(void))(*(_DWORD *)v5 + 8))();
    if ( v8 )
      (**(void (__thiscall ***)(_DWORD, _DWORD))v8)(v8, 1);
  }
  return *(_DWORD *)(v3 + 4);
}

//----- (1001AA20) --------------------------------------------------------
int __thiscall sub_1001AA20(int this, int a2)
{
  unsigned int v2; // edx@1
  int v3; // edi@1
  int result; // eax@4

  v2 = *(_DWORD *)(this + 12);
  v3 = *(_DWORD *)this;
  *(_DWORD *)a2 = *(_DWORD *)this;
  *(_DWORD *)(a2 + 4) = 0;
  if ( v2 )
  {
    if ( (signed int)v2 < 0 && v2 )
    {
      result = a2;
      *(_DWORD *)a2 = v3 - (4 * ((-1 - v2) >> 5) + 4);
      *(_DWORD *)(a2 + 4) = v2 & 0x1F;
      return result;
    }
    *(_DWORD *)a2 = v3 + 4 * (v2 >> 5);
    *(_DWORD *)(a2 + 4) = v2 & 0x1F;
  }
  return a2;
}

//----- (1001AA80) --------------------------------------------------------
int __thiscall sub_1001AA80(int this, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // ecx@1
  int v7; // ebx@1
  unsigned int v8; // esi@1
  int v9; // eax@3
  int v10; // edx@3
  unsigned int v11; // edx@4
  int v12; // ecx@10
  int v13; // ecx@12
  int result; // eax@14
  int v15; // [sp+14h] [bp-20h]@1
  unsigned int v16; // [sp+18h] [bp-1Ch]@1
  int v17; // [sp+1Ch] [bp-18h]@1
  int v18; // [sp+20h] [bp-14h]@1
  int v19; // [sp+24h] [bp-10h]@1
  unsigned int v20; // [sp+28h] [bp-Ch]@2
  unsigned int v21; // [sp+2Ch] [bp-8h]@1
  int v22; // [sp+34h] [bp+0h]@1

  v21 = (unsigned int)&v22 ^ __security_cookie;
  v17 = a2;
  v7 = this;
  v18 = this;
  v15 = 0;
  sub_1001B170(this, (int)&v15, a3, a4);
  v19 = 0;
  sub_1001B170(v7, (int)&v19, a5, a6);
  v6 = *(_DWORD *)v7;
  v8 = v16 + 32 * ((v15 - *(_DWORD *)v7) >> 2);
  if ( v15 != v19 || v16 != v20 )
  {
    v10 = 0;
    v9 = *(_DWORD *)(v18 + 12);
    if ( v9 )
    {
      v11 = *(_DWORD *)(v18 + 12);
      if ( v9 < 0 && v9 )
      {
        v8 = v16 + 32 * ((v15 - *(_DWORD *)v7) >> 2);
        v6 = -4 - 4 * ((-1 - v11) >> 5) + *(_DWORD *)v18;
      }
      else
      {
        v6 += 4 * (v11 >> 5);
      }
      v10 = v11 & 0x1F;
    }
    sub_1001E690(&v19, v17, v19, v20, v6, v10, v15, v16);
    loc_1001B2C0(v18, v20 + 32 * ((v19 - *(_DWORD *)v18) >> 2));
  }
  v20 = 0;
  v12 = *(_DWORD *)v18;
  if ( (signed int)v8 < 0 && v8 )
    v13 = -4 - 4 * ((-1 - v8) >> 5) + v12;
  else
    v13 = v12 + 4 * (v8 >> 5);
  result = v17;
  *(_DWORD *)v17 = v13;
  *(_DWORD *)(result + 4) = v8 & 0x1F;
  return result;
}
// 10074200: using guessed type int __security_cookie;

//----- (1001ABB0) --------------------------------------------------------
int __thiscall sub_1001ABB0(void *this, int a2, int a3, int a4, int a5, int a6)
{
  unsigned int v6; // edx@1
  unsigned int v7; // edi@1
  void *v8; // ebx@1
  int v9; // edx@5
  int v10; // ecx@7
  int v11; // ecx@9
  int v12; // esi@9
  int result; // eax@11
  void *v14; // [sp+14h] [bp-8h]@1
  int v15; // [sp+18h] [bp-4h]@1
  int v16; // [sp+28h] [bp+Ch]@1
  int v17; // [sp+28h] [bp+Ch]@3

  v8 = this;
  v14 = this;
  v7 = loc_1001B1E0(a3, a5, a6);
  v6 = v7 + a3;
  v15 = *(_DWORD *)v8;
  v16 = *(_DWORD *)v8;
  if ( (signed int)v6 < 0 && v6 )
    v17 = -4 - 4 * ((-1 - v6) >> 5) + v16;
  else
    v17 = v16 + 4 * (v6 >> 5);
  v9 = v6 & 0x1F;
  if ( (signed int)v7 < 0 && v7 )
    v10 = -4 - 4 * ((-1 - v7) >> 5) + v15;
  else
    v10 = v15 + 4 * (v7 >> 5);
  v12 = v7 & 0x1F;
  sub_1001D7F0(v7 & 0x1F, a4, v10, v7 & 0x1F, v17, v9);
  v11 = *(_DWORD *)v14;
  if ( (signed int)v7 < 0 && v7 )
  {
    result = a2;
    *(_DWORD *)a2 = -4 - 4 * ((-1 - v7) >> 5) + v11;
    *(_DWORD *)(a2 + 4) = v12;
  }
  else
  {
    result = a2;
    *(_DWORD *)(a2 + 4) = v12;
    *(_DWORD *)a2 = v11 + 4 * (v7 >> 5);
  }
  return result;
}

//----- (1001ACB0) --------------------------------------------------------
int __thiscall sub_1001ACB0(int this, int a2)
{
  int v2; // ebx@1
  int v3; // eax@2
  const void *v4; // edi@2
  int v6; // edx@4
  void *v7; // ecx@4
  const void *v8; // edi@7
  unsigned int v9; // esi@7
  unsigned int v10; // esi@11
  int v11; // [sp+8h] [bp-4h]@4

  v2 = this;
  if ( this != a2 )
  {
    v3 = *(_DWORD *)(a2 + 4);
    v4 = *(const void **)a2;
    if ( *(_DWORD *)a2 == v3 )
    {
      *(_DWORD *)(this + 4) = *(_DWORD *)this;
      return this;
    }
    v7 = *(void **)this;
    v6 = (v3 - (_DWORD)v4) >> 2;
    v11 = (*(_DWORD *)(v2 + 4) - *(_DWORD *)v2) >> 2;
    if ( v6 <= (unsigned int)v11 )
    {
      sub_1002A4B0(v7, v4, (v3 - (_DWORD)v4) & 0xFFFFFFFC);
      *(_DWORD *)(v2 + 4) = *(_DWORD *)v2 + 4 * ((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 2);
      return v2;
    }
    if ( v6 <= (unsigned int)((*(_DWORD *)(v2 + 8) - (_DWORD)v7) >> 2) )
    {
      v8 = (char *)v4 + 4 * v11;
      sub_1002A4B0(v7, *(const void **)a2, (unsigned int)((char *)v8 - *(_DWORD *)a2) & 0xFFFFFFFC);
      v9 = 4 * ((*(_DWORD *)(a2 + 4) - (_DWORD)v8) >> 2);
      *(_DWORD *)(v2 + 4) = (char *)sub_1002A4B0(*(void **)(v2 + 4), v8, v9) + v9;
      return v2;
    }
    if ( v7 )
      sub_1002A4AA(v7);
    if ( (unsigned __int8)loc_10019DC0(v2, (*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 2) )
    {
      v10 = 4 * ((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 2);
      *(_DWORD *)(v2 + 4) = (char *)sub_1002A4B0(*(void **)v2, *(const void **)a2, v10) + v10;
    }
  }
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1001ADC0) --------------------------------------------------------
int __thiscall sub_1001ADC0(int this, unsigned int a2)
{
  signed __int64 v2; // qax@1
  int v3; // ecx@1
  unsigned int v4; // ebx@1
  int v5; // edi@1
  int v6; // esi@1
  int v8; // [sp+Ch] [bp-4h]@1

  v4 = a2;
  v5 = this;
  v6 = *(_DWORD *)(this + 4);
  v8 = this;
  v2 = 715827883i64 * (*(_DWORD *)(this + 4) - *(_DWORD *)this);
  v3 = (HIDWORD(v2) >> 1) + (HIDWORD(v2) >> 31);
  if ( v3 <= a2 )
  {
    if ( v3 < a2 )
    {
      loc_1001B3B0(v5, a2 - v3);
      sub_1001D840(*(_DWORD *)(v5 + 4), v4 - (*(_DWORD *)(v5 + 4) - *(_DWORD *)v8) / 12);
      LODWORD(v2) = *(_DWORD *)(v8 + 4) + 12 * (v4 - (*(_DWORD *)(v8 + 4) - *(_DWORD *)v8) / 12);
      *(_DWORD *)(v8 + 4) = v2;
    }
  }
  else
  {
    LODWORD(v2) = sub_1001B330(v5, (int)&a2, *(_DWORD *)v5 + 12 * a2, v6);
  }
  return v2;
}

//----- (1001AEF0) --------------------------------------------------------
int __thiscall sub_1001AEF0(void *this, int a2, int a3, int a4)
{
  (*(void (__stdcall **)(int, int, int, _DWORD))(*(_DWORD *)this + 16))(a2, a3, a4, 0);
  return a2;
}

//----- (1001AF20) --------------------------------------------------------
bool __userpurge sub_1001AF20<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  bool result; // eax@2

  v6 = sub_10029DE6(a2, a3, a4, a5, a6, a1 + 8);
  if ( v6 >= 0 )
    result = v6 != 0;
  else
    result = -1;
  return result;
}

//----- (1001AF60) --------------------------------------------------------
int __thiscall sub_1001AF60(void *this, int a2, const CHAR *a3, UINT a4)
{
  signed int v4; // eax@1
  UINT v5; // ebx@1
  unsigned int v6; // ecx@3
  char v7; // cf@4
  unsigned int v8; // eax@8
  int v9; // edx@9
  WCHAR *v10; // ecx@12
  unsigned int v11; // ecx@16
  char v12; // cf@17
  int v14; // [sp+30h] [bp+10h]@2

  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  v5 = a4;
  v4 = a4 - (_DWORD)a3;
  if ( (const CHAR *)a4 != a3 )
  {
    v14 = (int)((char *)this + 8);
    do
    {
      v6 = *(_DWORD *)(a2 + 16);
      if ( v4 > v6 )
      {
        loc_10012FA0(a2, v4 - v6, 0);
      }
      else
      {
        v7 = *(_DWORD *)(a2 + 20) < 0x10u;
        *(_DWORD *)(a2 + 16) = v4;
        if ( v7 )
          *(_BYTE *)(a2 + v4) = 0;
        else
          *(_BYTE *)(*(_DWORD *)a2 + v4) = 0;
      }
      v8 = *(_DWORD *)(a2 + 20);
      if ( v8 < 0x10 )
        v9 = a2;
      else
        v9 = *(_DWORD *)a2;
      if ( v8 < 0x10 )
        v10 = (WCHAR *)a2;
      else
        v10 = *(WCHAR **)a2;
      v4 = sub_10029E7B(v10, v9 + *(_DWORD *)(a2 + 16), a3, v5, v14);
    }
    while ( (unsigned int)v4 > *(_DWORD *)(a2 + 16) && v4 );
  }
  v11 = *(_DWORD *)(a2 + 16);
  if ( v4 > v11 )
  {
    loc_10012FA0(a2, v4 - v11, 0);
  }
  else
  {
    v12 = *(_DWORD *)(a2 + 20) < 0x10u;
    *(_DWORD *)(a2 + 16) = v4;
    if ( v12 )
      *(_BYTE *)(a2 + v4) = 0;
    else
      *(_BYTE *)(*(_DWORD *)a2 + v4) = 0;
  }
  return a2;
}

//----- (1001B070) --------------------------------------------------------
int __stdcall sub_1001B070(int a1, int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  int v4; // eax@2

  v2 = -2128831035;
  v3 = 0;
  if ( a2 != a1 )
  {
    do
    {
      v4 = *(_BYTE *)(v3++ + a1);
      v2 = 16777619 * (v4 ^ v2);
    }
    while ( v3 < a2 - a1 );
  }
  return v2;
}

//----- (1001B0B0) --------------------------------------------------------
int __thiscall sub_1001B0B0(int this, int a2, int a3)
{
  unsigned int v3; // edx@1
  int v4; // esi@1
  int result; // eax@3
  int v6; // edx@3
  unsigned int v7; // edx@4

  v3 = *(_DWORD *)(this + 4);
  v4 = *(_DWORD *)this;
  if ( a3 >= 0 || v3 >= -a3 )
  {
    v7 = a3 + v3;
    result = a2;
    *(_DWORD *)a2 = v4 + 4 * (v7 >> 5);
    *(_DWORD *)(a2 + 4) = v7 & 0x1F;
  }
  else
  {
    v6 = a3 + v3;
    result = a2;
    *(_DWORD *)a2 = -4 - 4 * ((unsigned int)(-1 - v6) >> 5) + v4;
    *(_DWORD *)(a2 + 4) = v6 & 0x1F;
  }
  return result;
}

//----- (1001B110) --------------------------------------------------------
void *__userpurge sub_1001B110<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1
  void *v4; // ST00_4@1

  v3 = (void *)a1;
  v4 = *(void **)(a1 + 12);
  *(_DWORD *)a1 = &off_1006176C;
  sub_100309A2(a2, v4);
  *(_DWORD *)v3 = &off_10061664;
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10061664: using guessed type int (__stdcall *off_10061664)(char);
// 1006176C: using guessed type int (__stdcall *off_1006176C)(char);

//----- (1001B150) --------------------------------------------------------
int __thiscall sub_1001B150(int this, int a2)
{
  int v3; // ecx@1

  v3 = *(_DWORD *)(this + 8);
  *(_DWORD *)a2 = v3;
  (*(void (**)(void))(*(_DWORD *)v3 + 4))();
  return a2;
}

//----- (1001B170) --------------------------------------------------------
int __thiscall sub_1001B170(int this, int a2, int a3, int a4)
{
  unsigned int v4; // esi@2
  int v5; // esi@2
  char v6; // sf@2

  *(_DWORD *)a2 = 0;
  *(_DWORD *)a2 = *(_DWORD *)this;
  *(_DWORD *)(a2 + 4) = 0;
  if ( *(_DWORD *)(this + 12) )
  {
    v5 = 32 * ((a3 - *(_DWORD *)this) >> 2);
    v6 = a4 + v5 < 0;
    v4 = a4 + v5;
    if ( v6 && v4 )
    {
      *(_DWORD *)a2 += -4 - 4 * ((-1 - v4) >> 5);
      *(_DWORD *)(a2 + 4) = v4 & 0x1F;
      return a2;
    }
    *(_DWORD *)a2 += 4 * (v4 >> 5);
    *(_DWORD *)(a2 + 4) = v4 & 0x1F;
  }
  return a2;
}

//----- (1001B330) --------------------------------------------------------
int __thiscall sub_1001B330(int this, int a2, int a3, int a4)
{
  int v4; // edx@1
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@5
  int v8; // ecx@5
  int v9; // edx@6

  v4 = a3;
  v5 = this;
  v6 = a4;
  if ( a3 != *(_DWORD *)this || a4 != *(_DWORD *)(this + 4) )
  {
    if ( a3 != a4 )
    {
      v7 = *(_DWORD *)(this + 4);
      v8 = a3;
      if ( a4 != v7 )
      {
        v9 = *(_DWORD *)(v5 + 4);
        do
        {
          *(_DWORD *)v8 = *(_DWORD *)v6;
          *(_DWORD *)(v8 + 4) = *(_DWORD *)(v6 + 4);
          *(_BYTE *)(v8 + 8) = *(_BYTE *)(v6 + 8);
          v6 += 12;
          v8 += 12;
        }
        while ( v6 != v9 );
        v4 = a3;
      }
      *(_DWORD *)(v5 + 4) = v8;
    }
  }
  else
  {
    *(_DWORD *)(this + 4) = *(_DWORD *)this;
  }
  *(_DWORD *)a2 = v4;
  return a2;
}

//----- (1001B450) --------------------------------------------------------
int __thiscall sub_1001B450(int this, unsigned int a2, int a3)
{
  int result; // eax@1
  int v4; // ecx@1
  int v5; // ebx@1
  void *v6; // edi@1
  void *v7; // esi@2
  char v8; // [sp+8h] [bp-4h]@8

  v5 = this;
  result = *(_DWORD *)(this + 4);
  v6 = *(void **)this;
  v4 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 2;
  if ( v4 <= a2 )
  {
    if ( v4 < a2 )
      result = loc_1001B560(v5, &v8, result, a2 - v4, a3);
  }
  else
  {
    v7 = (char *)v6 + 4 * a2;
    if ( v7 == v6 )
    {
      *(_DWORD *)(v5 + 4) = v6;
    }
    else
    {
      if ( v7 != (void *)result )
      {
        sub_1002A4B0(v7, (const void *)result, 0);
        result = (int)((char *)v6 + 4 * a2);
        *(_DWORD *)(v5 + 4) = v7;
      }
    }
  }
  return result;
}

//----- (1001B4D0) --------------------------------------------------------
int __thiscall sub_1001B4D0(void *this, int a2, void *a3, const void *a4)
{
  void *v4; // eax@1
  void *v5; // ecx@1
  unsigned int v7; // esi@6
  void *v8; // [sp+8h] [bp-8h]@1

  v4 = this;
  v5 = *(void **)this;
  v8 = v4;
  if ( a3 == v5 && a4 == *((const void **)v4 + 1) )
  {
    *((_DWORD *)v4 + 1) = v5;
LABEL_4:
    *(_DWORD *)a2 = a3;
    return a2;
  }
  if ( a3 == a4 )
    goto LABEL_4;
  v7 = 4 * ((*((_DWORD *)v4 + 1) - (_DWORD)a4) >> 2);
  sub_1002A4B0(a3, a4, v7);
  *((_DWORD *)v8 + 1) = (char *)a3 + v7;
  *(_DWORD *)a2 = a3;
  return a2;
}

//----- (1001B770) --------------------------------------------------------
int __thiscall sub_1001B770(int this, int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  int v4; // edx@2
  int result; // eax@4
  int v6; // edx@5

  v2 = (*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 2;
  v3 = (unsigned int)(*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 3;
  if ( 1073741823 - v3 >= v2 )
  {
    v6 = v3 + v2;
    if ( v6 < (unsigned int)a2 )
      v6 = a2;
    result = v6;
  }
  else
  {
    v4 = 0;
    if ( (unsigned int)a2 > 0 )
      v4 = a2;
    result = v4;
  }
  return result;
}

//----- (1001B7B0) --------------------------------------------------------
int __userpurge sub_1001B7B0<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6)
{
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // edi@1
  int v10; // [sp+14h] [bp-10h]@1
  int v11; // [sp+20h] [bp-4h]@3

  v8 = a1;
  *(_DWORD *)a1 = a4;
  *(_DWORD *)(a1 + 4) = a4;
  *(_DWORD *)(a1 + 8) = a5;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  v10 = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  sub_10019D80((void *)(a1 + 20), 0, (int)&v10);
  *(_DWORD *)(v8 + 32) = 0;
  v7 = *(_DWORD *)(v8 + 20);
  v6 = (*(_DWORD *)(v8 + 24) - v7) >> 2;
  if ( v6 )
    sub_1001B4D0((void *)(v8 + 20), (int)&v10, (void *)v7, *(const void **)(v8 + 24));
  *(_DWORD *)(v8 + 32) = 0;
  v11 = 1;
  sub_1001C870(v6, v8 + 36, a2, v8, a3, v7);
  *(_DWORD *)(v8 + 60) = a3;
  *(_DWORD *)(v8 + 64) = 1;
  *(_DWORD *)(v8 + 80) = 142040571;
  sub_1001C5A0((void *)v8);
  return v8;
}

//----- (1001B890) --------------------------------------------------------
#error "1001B916: positive sp value has been found (funcsize=47)"

//----- (1001BE80) --------------------------------------------------------
int __fastcall sub_1001BE80(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, char a8)
{
  int v8; // esi@1
  int v9; // eax@2
  int v11; // [sp+8h] [bp-8h]@2
  unsigned int v12; // [sp+Ch] [bp-4h]@1
  int v13; // [sp+10h] [bp+0h]@1

  v12 = (unsigned int)&v13 ^ __security_cookie;
  v8 = a1;
  *(_DWORD *)a1 = a4;
  if ( a7 & 0x800 )
  {
    v9 = sub_1001D2B0((int)&v11, a2, a3, a4, a5, a6, a8);
  }
  else
  {
    if ( a7 & 0x100 )
    {
      v9 = sub_1001D4B0((int)&v11, a2, a3, (int *)a4, a5, a6, a8);
    }
    else
    {
      LOBYTE(v11) = 0;
      v9 = sub_1001D560((int)&v11, a2, a3, a4, a5, v11, a8);
    }
  }
  *(_DWORD *)v8 = *(_DWORD *)v9;
  return v8;
}
// 10074200: using guessed type int __security_cookie;

//----- (1001BF10) --------------------------------------------------------
int __fastcall sub_1001BF10(int a1, int a2, int a3, int a4)
{
  int v4; // eax@1
  int v5; // edx@2
  unsigned int v6; // eax@3
  int v7; // ecx@4
  unsigned int v8; // ebx@4
  int v9; // edx@5
  char v10; // al@6
  char v11; // zf@6
  int result; // eax@14
  int v13; // [sp+Ch] [bp-14h]@2
  int v14; // [sp+10h] [bp-10h]@1
  unsigned int v15; // [sp+14h] [bp-Ch]@3
  int v16; // [sp+18h] [bp-8h]@1
  int v17; // [sp+1Ch] [bp-4h]@2

  v4 = a2;
  v16 = a2;
  v14 = a1;
  if ( a2 )
  {
    while ( 1 )
    {
      v5 = 0;
      v17 = 0;
      v13 = *(_DWORD *)(v4 + 8);
      if ( v13 > 0 )
        break;
LABEL_12:
      v4 = *(_DWORD *)(v4 + 16);
      v16 = v4;
      if ( !v4 )
      {
        a1 = v14;
        goto LABEL_14;
      }
    }
    v6 = *(_DWORD *)v4;
    v15 = v6;
    while ( 1 )
    {
      v8 = 0;
      v7 = a3;
      if ( v6 )
      {
        v9 = v17 + *(_DWORD *)(v16 + 12);
        do
        {
          v10 = *(_BYTE *)v7++;
          v11 = v10 == *(_BYTE *)v9;
          v6 = v15;
          if ( !v11 )
            break;
          ++v8;
          ++v9;
        }
        while ( v8 < v15 );
        v5 = v17;
      }
      if ( v7 == a4 )
        break;
      v5 += v6;
      v17 = v5;
      if ( v5 >= v13 )
      {
        v4 = v16;
        goto LABEL_12;
      }
    }
    result = v14;
    *(_DWORD *)v14 = a4;
  }
  else
  {
LABEL_14:
    *(_DWORD *)a1 = a3;
    result = a1;
  }
  return result;
}

//----- (1001BFA0) --------------------------------------------------------
char __fastcall sub_1001BFA0(unsigned __int8 a1, int a2, void *a3)
{
  int v3; // ebx@1
  void *v4; // edi@1
  int v5; // esi@1
  int v6; // ecx@8
  int *v7; // ecx@9
  int v8; // ecx@11
  int v9; // esi@13
  int *v10; // edx@23
  int *v11; // eax@25
  unsigned int v12; // esi@27
  char v13; // cf@30
  int v14; // esi@30
  char v15; // cf@32
  unsigned __int8 v16; // cf@34
  unsigned __int8 v17; // cl@36
  unsigned __int8 v18; // cl@38
  unsigned __int8 v19; // al@40
  int v20; // eax@41
  char v21; // bl@48
  int v23; // [sp-8h] [bp-80h]@11
  void *v24; // [sp+10h] [bp-68h]@1
  unsigned int v25; // [sp+24h] [bp-54h]@5
  void *v26; // [sp+28h] [bp-50h]@1
  int v27; // [sp+2Ch] [bp-4Ch]@8
  int v28; // [sp+30h] [bp-48h]@1
  void *v29; // [sp+34h] [bp-44h]@1
  unsigned int v30; // [sp+44h] [bp-34h]@1
  unsigned int v31; // [sp+48h] [bp-30h]@1
  void *v32; // [sp+4Ch] [bp-2Ch]@1
  unsigned int v33; // [sp+5Ch] [bp-1Ch]@1
  unsigned int v34; // [sp+60h] [bp-18h]@1
  unsigned int v35; // [sp+64h] [bp-14h]@1
  int v36; // [sp+74h] [bp-4h]@1
  int v37; // [sp+78h] [bp+0h]@1

  v35 = (unsigned int)&v37 ^ __security_cookie;
  v3 = a2;
  v28 = a2;
  v4 = a3;
  v26 = a3;
  v34 = 15;
  v33 = 0;
  LOBYTE(v32) = 0;
  v36 = 0;
  v31 = 15;
  LOWORD(v29) = a1;
  v30 = 1;
  LOBYTE(v36) = 1;
  v5 = sub_1001D600(a3, (int)&v24, (int)&v29, (int)((char *)&v29 + 1));
  if ( &v29 != (void **)v5 )
  {
    if ( v31 >= 0x10 )
      sub_1002A4AA(v29);
    v31 = 15;
    v30 = 0;
    LOBYTE(v29) = 0;
    sub_100017B0(&v29, v5);
  }
  if ( v25 >= 0x10 )
    sub_1002A4AA(v24);
  if ( !v3 )
  {
LABEL_48:
    v21 = 0;
    goto LABEL_49;
  }
  while ( 1 )
  {
    v6 = 0;
    v27 = 0;
    if ( *(_DWORD *)(v3 + 8) > 0 )
      break;
LABEL_47:
    v3 = *(_DWORD *)(v3 + 16);
    v28 = v3;
    if ( !v3 )
      goto LABEL_48;
  }
  while ( 1 )
  {
    loc_1000AEB0(&v32, v6 + *(_DWORD *)(v3 + 12), *(_DWORD *)v3);
    v7 = (int *)&v32;
    if ( v34 >= 0x10 )
      v7 = (int *)v32;
    v23 = (int)((char *)v7 + v33);
    v8 = (int)&v32;
    if ( v34 >= 0x10 )
      v8 = (int)v32;
    v9 = sub_1001D600(v4, (int)&v24, v8, v23);
    if ( &v32 != (void **)v9 )
    {
      if ( v34 >= 0x10 )
        sub_1002A4AA(v32);
      v34 = 15;
      v33 = 0;
      LOBYTE(v32) = 0;
      if ( *(_DWORD *)(v9 + 20) >= 0x10u )
      {
        v32 = *(void **)v9;
        *(_DWORD *)v9 = 0;
      }
      else
      {
        if ( *(_DWORD *)(v9 + 16) != -1 )
          sub_1002A4B0(&v32, (const void *)v9, *(_DWORD *)(v9 + 16) + 1);
      }
      v33 = *(_DWORD *)(v9 + 16);
      v34 = *(_DWORD *)(v9 + 20);
      *(_DWORD *)(v9 + 20) = 15;
      *(_DWORD *)(v9 + 16) = 0;
      *(_BYTE *)v9 = 0;
    }
    if ( v25 >= 0x10 )
      sub_1002A4AA(v24);
    v10 = (int *)&v29;
    if ( v31 >= 0x10 )
      v10 = (int *)v29;
    v11 = (int *)&v32;
    if ( v34 >= 0x10 )
      v11 = (int *)v32;
    v12 = v30;
    if ( v33 < v30 )
      v12 = v33;
    if ( !v12 )
      break;
    v13 = v12 < 4;
    v14 = v12 - 4;
    if ( v13 )
    {
LABEL_33:
      if ( v14 == -4 )
        goto LABEL_42;
    }
    else
    {
      while ( *v11 == *v10 )
      {
        ++v11;
        ++v10;
        v15 = (unsigned int)v14 < 4;
        v14 -= 4;
        if ( v15 )
          goto LABEL_33;
      }
    }
    v16 = *(_BYTE *)v11 < *(_BYTE *)v10;
    if ( *(_BYTE *)v11 != *(_BYTE *)v10
      || v14 != -3
      && ((v17 = *((_BYTE *)v11 + 1), v16 = v17 < *((_BYTE *)v10 + 1), v17 != *((_BYTE *)v10 + 1))
       || v14 != -2
       && ((v18 = *((_BYTE *)v11 + 2), v16 = v18 < *((_BYTE *)v10 + 2), v18 != *((_BYTE *)v10 + 2))
        || v14 != -1 && (v19 = *((_BYTE *)v11 + 3), v16 = v19 < *((_BYTE *)v10 + 3), v19 != *((_BYTE *)v10 + 3)))) )
    {
      v20 = -v16 | 1;
      goto LABEL_43;
    }
LABEL_42:
    v20 = 0;
LABEL_43:
    if ( !v20 )
      break;
LABEL_46:
    v3 = v28;
    v6 = *(_DWORD *)v28 + v27;
    v4 = v26;
    v27 = v6;
    if ( v6 >= *(_DWORD *)(v28 + 8) )
      goto LABEL_47;
  }
  if ( v33 < v30 || v33 != v30 )
    goto LABEL_46;
  v21 = 1;
LABEL_49:
  if ( v31 >= 0x10 )
    sub_1002A4AA(v29);
  v31 = 15;
  v30 = 0;
  LOBYTE(v29) = 0;
  if ( v34 >= 0x10 )
    sub_1002A4AA(v32);
  return v21;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (1001C250) --------------------------------------------------------
int __fastcall sub_1001C250(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a3;
  for ( _ESI = a1; _ESI != a2; result += 12 )
  {
    if ( result )
    {
      __asm
      {
        movq    xmm0, qword ptr [esi]
        movq    qword ptr [eax], xmm0
      }
      *(_DWORD *)(result + 8) = *(_DWORD *)(_ESI + 8);
    }
    _ESI += 12;
  }
  return result;
}

//----- (1001C280) --------------------------------------------------------
void *__thiscall sub_1001C280(void *this, int a2, int a3)
{
  void *result; // eax@1

  result = this;
  for ( _ECX = a2; _ECX != a3; result = (char *)result + 12 )
  {
    if ( result )
    {
      __asm
      {
        movq    xmm0, qword ptr [ecx]
        movq    qword ptr [eax], xmm0
      }
      *((_DWORD *)result + 2) = *(_DWORD *)(_ECX + 8);
    }
    _ECX += 12;
  }
  return result;
}

//----- (1001C2C0) --------------------------------------------------------
void __fastcall sub_1001C2C0(int _ECX, int a2)
{
  for ( ; a2; --a2 )
  {
    if ( _ECX )
    {
      __asm
      {
        xorps   xmm0, xmm0
        movq    qword ptr [ecx], xmm0
      }
    }
    _ECX += 8;
  }
}

//----- (1001C2E0) --------------------------------------------------------
int __fastcall sub_1001C2E0(int a1, int a2, int a3)
{
  int result; // eax@1

  for ( result = a3; a1 != a2; result += 8 )
  {
    *(_DWORD *)result = *(_DWORD *)a1;
    *(_DWORD *)(result + 4) = *(_DWORD *)(a1 + 4);
    a1 += 8;
  }
  return result;
}

//----- (1001C310) --------------------------------------------------------
int __usercall sub_1001C310<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4)
{
  int v4; // edx@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // ecx@5
  int v8; // esi@6
  int v9; // eax@10
  int v10; // edx@17
  int v11; // ecx@17
  char v13; // [sp+Ch] [bp-2Ch]@16
  void *v14; // [sp+18h] [bp-20h]@1
  int v15; // [sp+1Ch] [bp-1Ch]@1
  char v16; // [sp+20h] [bp-18h]@1
  char v17; // [sp+24h] [bp-14h]@2
  unsigned int v18; // [sp+28h] [bp-10h]@1
  int v19; // [sp+34h] [bp-4h]@1
  int v20; // [sp+38h] [bp+0h]@1

  v18 = (unsigned int)&v20 ^ __security_cookie;
  v14 = (void *)a4;
  sub_10029A76(a1, (int)&v16, a2, a3, 0);
  v19 = 0;
  v6 = dword_10077A8C;
  v5 = dword_100773D4;
  v15 = dword_100773D4;
  if ( !dword_10077A8C )
  {
    sub_10029A76(v4, (int)&v17, dword_100773D4, dword_10077A8C, dword_10077A8C);
    if ( dword_10077A8C == v6 )
    {
      ++dword_100761E4;
      dword_10077A8C = dword_100761E4;
    }
    sub_10029AD2(&v17);
    v6 = dword_10077A8C;
  }
  v7 = *(_DWORD *)a4;
  if ( (unsigned int)v6 >= *(_DWORD *)(*(_DWORD *)a4 + 12) )
  {
    v8 = 0;
  }
  else
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v7 + 8) + 4 * v6);
    if ( v8 )
      goto LABEL_18;
  }
  if ( !*(_BYTE *)(v7 + 20) )
    goto LABEL_12;
  v9 = sub_10029877();
  if ( (unsigned int)v6 < *(_DWORD *)(v9 + 12) )
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v9 + 8) + 4 * v6);
LABEL_12:
    if ( v8 )
      goto LABEL_18;
  }
  if ( v5 )
  {
    v8 = v5;
  }
  else
  {
    if ( sub_1001C440(v7, v4, (int)&v15, v14) == -1 )
    {
      sub_1002AE51((int)&v13, (unsigned int)"bad cast");
      sub_100355DB((int)&v13, (int)&unk_1006D9A4);
    }
    v8 = v15;
    dword_100773D4 = v15;
    (*(void (__thiscall **)(int))(*(_DWORD *)v15 + 4))(v15);
    sub_1002984F(v10, v11, v5, v6, v8);
  }
LABEL_18:
  sub_10029AD2(&v16);
  return v8;
}
// 10074200: using guessed type int __security_cookie;
// 100761E4: using guessed type int dword_100761E4;
// 100773D4: using guessed type int dword_100773D4;
// 10077A8C: using guessed type int dword_10077A8C;

//----- (1001C440) --------------------------------------------------------
signed int __fastcall sub_1001C440(int a1, int a2, int a3, void *a4)
{
  int v4; // ebx@1
  int v5; // esi@3
  int v6; // eax@4
  int v7; // edx@4
  int v8; // edx@6
  void *v10; // [sp+18h] [bp-5Ch]@4
  unsigned int v11; // [sp+2Ch] [bp-48h]@11
  char v12; // [sp+30h] [bp-44h]@6
  int v13; // [sp+70h] [bp-4h]@3

  v4 = 0;
  if ( a3 )
  {
    if ( !*(_DWORD *)a3 )
    {
      v5 = sub_1002ADB1(a2, a1, 0, a3, 16);
      v13 = 0;
      if ( v5 )
      {
        v6 = sub_10020A40(a4, (int)&v10);
        LOBYTE(v13) = 1;
        if ( *(_DWORD *)(v6 + 20) >= 0x10u )
          v6 = *(_DWORD *)v6;
        sub_100178F0(v7, (int)&v12, 0, v6);
        v4 = 3;
        *(_DWORD *)(v5 + 4) = 0;
        *(_DWORD *)v5 = &off_1006176C;
        *(_DWORD *)(v5 + 8) = sub_10029DC5(3, a3);
        *(_DWORD *)(v5 + 12) = v8;
      }
      else
      {
        v5 = 0;
      }
      *(_DWORD *)a3 = v5;
      if ( v4 & 2 )
      {
        v4 &= 0xFFFFFFFDu;
        sub_100179E0(&v12, v4);
      }
      if ( v4 & 1 )
      {
        if ( v11 >= 0x10 )
          sub_1002A4AA(v10);
      }
    }
  }
  return 1;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1006176C: using guessed type int (__stdcall *off_1006176C)(char);

//----- (1001C530) --------------------------------------------------------
int __thiscall sub_1001C530(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  if ( (unsigned __int8)loc_10019DC0((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 2) )
    *(_DWORD *)(v2 + 4) = sub_1001EE10(*(void **)v2, *(_DWORD *)a2, *(_DWORD *)(a2 + 4));
  return v2;
}

//----- (1001C5A0) --------------------------------------------------------
char __thiscall sub_1001C5A0(void *this)
{
  int v1; // esi@1
  unsigned __int8 v2; // al@3
  int v3; // eax@4
  int v4; // eax@7
  char v5; // zf@13

  v1 = (int)this;
  if ( *(_DWORD *)this == *((_DWORD *)this + 2) )
  {
    *((_DWORD *)this + 19) = -1;
    *((_BYTE *)this + 72) = -1;
  }
  else
  {
    v2 = **(_BYTE **)this;
    *((_BYTE *)this + 72) = v2;
    if ( sub_10030A50((int)"()$^.*+?[]|\\-{},:=!\n\r\b", v2) )
      v3 = *(_BYTE *)(v1 + 72);
    else
      v3 = 0;
    *(_DWORD *)(v1 + 76) = v3;
  }
  v4 = *(_BYTE *)(v1 + 72) - 10;
  switch ( *(_BYTE *)(v1 + 72) )
  {
    case 92:
      LOBYTE(v4) = sub_1001D9C0(v1);
      if ( (_BYTE)v4 )
      {
        LOBYTE(v4) = *(_BYTE *)(*(_DWORD *)v1 + 1);
        *(_BYTE *)(v1 + 72) = v4;
        *(_DWORD *)(v1 + 76) = (char)v4;
      }
      return v4;
    case 10:
      if ( *(_BYTE *)(v1 + 80) & 4 )
      {
        if ( !*(_DWORD *)(v1 + 16) )
          *(_DWORD *)(v1 + 76) = 124;
      }
      return v4;
    case 40:
    case 41:
      v5 = (*(_BYTE *)(v1 + 80) & 8) == 0;
      goto LABEL_26;
    case 123:
    case 125:
      v5 = (*(_BYTE *)(v1 + 80) & 0x10) == 0;
      goto LABEL_26;
    case 42:
      if ( *(_DWORD *)(v1 + 80) & 0x4000000 )
      {
        LOBYTE(v4) = sub_1001DE90(v1 + 36);
        if ( (_BYTE)v4 )
          *(_DWORD *)(v1 + 76) = 0;
      }
      return v4;
    case 94:
      if ( !(*(_DWORD *)(v1 + 80) & 0x2000000) )
        return v4;
      LOBYTE(v4) = sub_1001DE90(v1 + 36);
      v5 = (_BYTE)v4 == 0;
      goto LABEL_26;
    case 36:
      if ( *(_DWORD *)(v1 + 80) & 0x2000000 )
      {
        v4 = *(_DWORD *)v1 + 1;
        if ( v4 != *(_DWORD *)(v1 + 8) )
        {
          if ( *(_BYTE *)v4 != 10 )
            *(_DWORD *)(v1 + 76) = 0;
        }
      }
      return v4;
    case 43:
    case 63:
      v5 = (*(_BYTE *)(v1 + 80) & 1) == 0;
      goto LABEL_26;
    case 124:
      v5 = (*(_BYTE *)(v1 + 80) & 2) == 0;
LABEL_26:
      if ( v5 )
        *(_DWORD *)(v1 + 76) = 0;
      break;
    default:
      return v4;
  }
  return v4;
}

//----- (1001C750) --------------------------------------------------------
int __thiscall sub_1001C750(int this)
{
  int result; // eax@1
  int v2; // edx@1
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // eax@3
  int v6; // eax@5
  int v7; // ecx@5
  int v8; // eax@7
  int v9; // ecx@8
  int v10; // edx@16
  int v11; // ecx@16
  int v12; // eax@17
  int v14; // ecx@20
  int i; // [sp+Ch] [bp-4h]@4

  v4 = this;
  v3 = *(_DWORD *)(this + 40);
  result = loc_1001DA50();
  if ( !(_BYTE)result )
  {
    if ( *(_DWORD *)(v4 + 76) != 124 )
      return result;
    v5 = sub_1001DED0(v2, v4 + 36, v3, v4);
    sub_1001C8F0(v4 + 36, v2, v5);
  }
  result = sub_1001DF40(v2, v4 + 36, v3, v3);
  for ( i = result; *(_DWORD *)(v4 + 76) == 124; result = sub_1001E000(v4 + 36, v10, v3, i) )
  {
    v6 = *(_DWORD *)v4;
    v7 = *(_DWORD *)(v4 + 8);
    if ( *(_DWORD *)v4 != v7 )
    {
      if ( *(_BYTE *)v6 == 92 )
      {
        v8 = v6 + 1;
        if ( v8 != v7 )
        {
          v9 = *(_DWORD *)(v4 + 80);
          if ( !(v9 & 8) && (*(_BYTE *)v8 == 40 || *(_BYTE *)v8 == 41)
            || !(v9 & 0x10) && (*(_BYTE *)v8 == 123 || *(_BYTE *)v8 == 125) )
            *(_DWORD *)v4 = v8;
        }
      }
      ++*(_DWORD *)v4;
    }
    sub_1001C5A0((void *)v4);
    if ( !(unsigned __int8)loc_1001DA50(v4) )
    {
      v12 = sub_1002ADB1(v10, v11, v3, v4, 20);
      if ( v12 )
      {
        *(_DWORD *)v12 = off_10068B14;
        *(_DWORD *)(v12 + 4) = 8;
        *(_DWORD *)(v12 + 8) = 0;
        *(_DWORD *)(v12 + 12) = 0;
        *(_DWORD *)(v12 + 16) = 0;
      }
      else
      {
        v12 = 0;
      }
      *(_DWORD *)(v12 + 16) = *(_DWORD *)(v4 + 40);
      v14 = *(_DWORD *)(*(_DWORD *)(v4 + 40) + 12);
      if ( v14 )
      {
        *(_DWORD *)(v12 + 12) = v14;
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v4 + 40) + 12) + 16) = v12;
      }
      *(_DWORD *)(*(_DWORD *)(v4 + 40) + 12) = v12;
      *(_DWORD *)(v4 + 40) = v12;
      sub_1001C8F0(v4 + 36, v10, v12);
    }
  }
  return result;
}
// 10068B14: using guessed type int (__stdcall *off_10068B14[2])(char);

//----- (1001C870) --------------------------------------------------------
int __userpurge sub_1001C870<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6)
{
  int v6; // eax@1
  int v7; // esi@1

  v7 = a2;
  v6 = sub_1002ADB1(a1, a2, a3, a4, 36);
  if ( v6 )
  {
    *(_DWORD *)(v6 + 4) = 20;
    *(_DWORD *)(v6 + 8) = 0;
    *(_DWORD *)(v6 + 12) = 0;
    *(_DWORD *)(v6 + 16) = 0;
    *(_DWORD *)v6 = off_10068B14;
    *(_DWORD *)(v6 + 24) = 0;
    *(_DWORD *)(v6 + 28) = 0;
    *(_DWORD *)(v6 + 32) = 0;
  }
  else
  {
    v6 = 0;
  }
  *(_DWORD *)v7 = v6;
  *(_DWORD *)(v7 + 4) = v6;
  *(_DWORD *)(v7 + 12) = a5;
  *(_DWORD *)(v7 + 8) = 1;
  *(_DWORD *)(v7 + 16) = 256;
  *(_DWORD *)(v7 + 20) = 4;
  return v7;
}
// 10068B14: using guessed type int (__stdcall *off_10068B14[2])(char);

//----- (1001C8F0) --------------------------------------------------------
int __fastcall sub_1001C8F0(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // esi@1
  int v5; // ebx@2
  int v6; // eax@6
  int v7; // ecx@6
  int v8; // eax@9
  int result; // eax@11

  v4 = a1;
  v3 = *(_DWORD *)(a3 + 4);
  if ( v3 == 8 )
  {
    v5 = 9;
  }
  else
  {
    if ( v3 == 10 )
      v5 = 12;
    else
      v5 = 2 * (v3 != 11) + 12;
  }
  v6 = sub_1002ADB1(a2, a1, v5, a3, 24);
  v7 = v6;
  if ( v6 )
  {
    *(_DWORD *)(v6 + 4) = v5;
    *(_DWORD *)(v6 + 8) = 0;
    *(_DWORD *)(v6 + 12) = 0;
    *(_DWORD *)(v6 + 16) = 0;
    *(_DWORD *)v6 = off_10068B14;
    *(_DWORD *)(v6 + 20) = a3;
  }
  else
  {
    v7 = 0;
  }
  *(_DWORD *)(v7 + 16) = *(_DWORD *)(v4 + 4);
  v8 = *(_DWORD *)(*(_DWORD *)(v4 + 4) + 12);
  if ( v8 )
  {
    *(_DWORD *)(v7 + 12) = v8;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v4 + 4) + 12) + 16) = v7;
  }
  result = *(_DWORD *)(v4 + 4);
  *(_DWORD *)(result + 12) = v7;
  *(_DWORD *)(v4 + 4) = v7;
  return result;
}
// 10068B14: using guessed type int (__stdcall *off_10068B14[2])(char);

//----- (1001C990) --------------------------------------------------------
int __userpurge sub_1001C990<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v5 = sub_1002ADB1(a1, a2, a3, a4, 24);
  if ( v5 )
  {
    *(_DWORD *)(v5 + 4) = 13;
    *(_DWORD *)(v5 + 8) = 0;
    *(_DWORD *)(v5 + 12) = 0;
    *(_DWORD *)(v5 + 16) = 0;
    *(_DWORD *)v5 = off_10068B14;
    *(_DWORD *)(v5 + 20) = a5;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  result = v5;
  *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) = v5;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 10068B14: using guessed type int (__stdcall *off_10068B14[2])(char);

//----- (1001CA00) --------------------------------------------------------
int __usercall sub_1001CA00<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a4, 20);
  v5 = v4;
  if ( v4 )
  {
    *(_DWORD *)v4 = off_10068B14;
    *(_DWORD *)(v4 + 4) = 21;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) = v5;
  result = *(_DWORD *)v6;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 10068B14: using guessed type int (__stdcall *off_10068B14[2])(char);

//----- (1001CA70) --------------------------------------------------------
char __thiscall sub_1001CA70(void *this, int a2)
{
  char v2; // al@1
  int v3; // ebx@1
  void *v4; // edi@1
  int v5; // eax@1
  int v6; // esi@1
  int v7; // eax@1
  int v8; // esi@2
  int v9; // ecx@3
  int v10; // eax@5
  int v11; // edi@5
  int *v12; // esi@10
  char v13; // bl@12
  void *v15; // [sp+10h] [bp-68h]@1
  int v16; // [sp+14h] [bp-64h]@1
  int v17; // [sp+18h] [bp-60h]@1
  signed int v18; // [sp+1Ch] [bp-5Ch]@1
  char v19; // [sp+23h] [bp-55h]@1
  int v20; // [sp+24h] [bp-54h]@1
  void *v21; // [sp+28h] [bp-50h]@1
  int v22; // [sp+2Ch] [bp-4Ch]@1
  int v23; // [sp+30h] [bp-48h]@1
  int v24; // [sp+34h] [bp-44h]@1
  void *v25; // [sp+38h] [bp-40h]@1
  int v26; // [sp+3Ch] [bp-3Ch]@1
  int v27; // [sp+40h] [bp-38h]@1
  int v28; // [sp+44h] [bp-34h]@1
  void *v29; // [sp+48h] [bp-30h]@1
  int v30; // [sp+4Ch] [bp-2Ch]@1
  int v31; // [sp+50h] [bp-28h]@1
  int v32; // [sp+54h] [bp-24h]@1
  void *v33; // [sp+58h] [bp-20h]@1
  int v34; // [sp+5Ch] [bp-1Ch]@1
  int v35; // [sp+60h] [bp-18h]@1
  unsigned int v36; // [sp+64h] [bp-14h]@1
  int v37; // [sp+74h] [bp-4h]@1
  int v38; // [sp+78h] [bp+0h]@1

  v36 = (unsigned int)&v38 ^ __security_cookie;
  v4 = this;
  v15 = this;
  v5 = *(_DWORD *)this;
  v3 = a2;
  v6 = (int)((char *)this + 4);
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v28 = v5;
  v16 = (int)((char *)this + 4);
  sub_1001C530((int)&v29, (int)((char *)this + 4));
  v32 = *(_DWORD *)(v6 + 12);
  v37 = 0;
  v17 = (int)((char *)v4 + 20);
  sub_1001D860((int)&v33, (int)((char *)v4 + 20));
  v37 = 1;
  v7 = *(_DWORD *)v4;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v20 = v7;
  sub_1001C530((int)&v21, v6);
  v24 = *(_DWORD *)(v6 + 12);
  LOBYTE(v37) = 2;
  sub_1001D860((int)&v25, (int)((char *)v4 + 20));
  v2 = 0;
  LOBYTE(v37) = 3;
  v19 = 0;
  v18 = -1;
  if ( a2 )
  {
    v8 = v28;
    do
    {
      v9 = v32;
      *(_DWORD *)v4 = v8;
      *((_DWORD *)v4 + 4) = v9;
      sub_1001ACB0((int)((char *)v4 + 4), (int)&v29);
      sub_1001A740((char *)v4 + 20, (int)&v33);
      if ( (unsigned __int8)loc_1001B950(v4, *(_DWORD *)(v3 + 12)) )
      {
        if ( !*((_BYTE *)v4 + 108) )
        {
          v13 = 1;
          goto LABEL_13;
        }
        v10 = *(_DWORD *)v4;
        v11 = *(_DWORD *)v4 - v8;
        if ( v18 < v11 )
        {
          v20 = v10;
          v24 = *(_DWORD *)(v16 + 12);
          sub_1001ACB0((int)&v21, v16);
          sub_1001A740(&v25, v17);
          v18 = v11;
        }
        v4 = v15;
        v2 = 1;
        v19 = 1;
      }
      else
      {
        v2 = v19;
      }
      v3 = *(_DWORD *)(v3 + 24);
    }
    while ( v3 );
  }
  v12 = &v20;
  if ( !v2 )
    v12 = &v28;
  *(_DWORD *)v4 = *v12;
  *((_DWORD *)v4 + 4) = v12[4];
  sub_1001ACB0((int)((char *)v4 + 4), (int)(v12 + 1));
  sub_1001A740((char *)v4 + 20, (int)(v12 + 5));
  v13 = v19;
LABEL_13:
  if ( v25 )
    sub_1002A4AA(v25);
  if ( v21 )
    sub_1002A4AA(v21);
  if ( v33 )
    sub_1002A4AA(v33);
  if ( v29 )
    sub_1002A4AA(v29);
  return v13;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (1001CC80) --------------------------------------------------------
char __thiscall sub_1001CC80(void *this, int a2, char a3, signed int a4)
{
  unsigned __int8 v4; // zf@1
  char v5; // sf@1
  char v6; // of@1
  void *v7; // ebx@1
  int i; // eax@2
  int v9; // ecx@2
  bool v10; // eax@6
  int v12; // eax@9
  int v13; // eax@9
  int v14; // ecx@9
  int v15; // esi@9
  int v16; // eax@9
  int v17; // ecx@9
  char v18; // al@11
  char v19; // sf@13
  int v20; // eax@21
  int v21; // ecx@21
  int v22; // eax@26
  int v23; // edx@29
  int v24; // eax@30
  int v25; // [sp-8h] [bp-60h]@17
  int v26; // [sp+10h] [bp-48h]@9
  void *v27; // [sp+14h] [bp-44h]@9
  int v28; // [sp+18h] [bp-40h]@9
  int v29; // [sp+1Ch] [bp-3Ch]@9
  int v30; // [sp+20h] [bp-38h]@9
  void *v31; // [sp+24h] [bp-34h]@9
  int v32; // [sp+28h] [bp-30h]@9
  int v33; // [sp+2Ch] [bp-2Ch]@9
  int v34; // [sp+30h] [bp-28h]@9
  int v35; // [sp+34h] [bp-24h]@9
  int v36; // [sp+38h] [bp-20h]@9
  char v37; // [sp+3Eh] [bp-1Ah]@13
  char v38; // [sp+3Fh] [bp-19h]@9
  int v39; // [sp+40h] [bp-18h]@9
  unsigned int v40; // [sp+44h] [bp-14h]@1
  int v41; // [sp+54h] [bp-4h]@9
  int v42; // [sp+58h] [bp+0h]@1

  v40 = (unsigned int)&v42 ^ __security_cookie;
  v7 = this;
  v6 = 0;
  v4 = *(_DWORD *)(a2 + 36) == 0;
  v5 = *(_DWORD *)(a2 + 36) < 0;
  if ( *(_DWORD *)(a2 + 36) < 0 )
  {
    v9 = *(_DWORD *)(a2 + 12);
    for ( i = *(_DWORD *)(v9 + 4); i != 19; i = *(_DWORD *)(v9 + 4) )
    {
      if ( i == 16 )
        break;
      if ( i == 18 )
        break;
      v9 = *(_DWORD *)(v9 + 12);
    }
    v10 = *(_DWORD *)(v9 + 4) == 19;
    *(_DWORD *)(a2 + 36) = v10;
    v6 = 0;
    v4 = v10 == 0;
    v5 = v10 < 0;
  }
  if ( !((unsigned __int8)(v5 ^ v6) | v4) )
    return sub_1001E0A0(v7, a2, a3);
  v13 = *(_DWORD *)v7;
  v38 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v26 = v13;
  sub_1001C530((int)&v27, (int)((char *)v7 + 4));
  v30 = *((_DWORD *)v7 + 4);
  v41 = 0;
  sub_1001D860((int)&v31, (int)((char *)v7 + 20));
  v41 = 1;
  v16 = *((_DWORD *)v7 + 16);
  v17 = *(_DWORD *)(a2 + 32);
  v15 = *(_DWORD *)(v16 + 8 * v17 + 4);
  v14 = v16 + 8 * v17;
  v36 = v14;
  v34 = *(_DWORD *)v14;
  v12 = *(_DWORD *)v7;
  v35 = v15;
  v39 = v12;
  v18 = !a4 || *(_DWORD *)v15 != v12;
  v19 = *(_DWORD *)(a2 + 24) < 0;
  v37 = v18;
  if ( v19 || *(_DWORD *)(a2 + 24) > a4 )
  {
    if ( a4 < *(_DWORD *)(a2 + 20) )
    {
      if ( v18 )
      {
        *(_DWORD *)v14 = a4 + 1;
        *(_DWORD *)(v14 + 4) = &v39;
        v25 = *(_DWORD *)(a2 + 12);
        goto LABEL_28;
      }
      goto LABEL_27;
    }
    if ( !a3 )
    {
      v38 = loc_1001B950(v7, *(_DWORD *)(*(_DWORD *)(a2 + 28) + 12));
      if ( v38 )
        goto LABEL_30;
      if ( v37 )
      {
        v20 = v30;
        *(_DWORD *)v7 = v26;
        *((_DWORD *)v7 + 4) = v20;
        sub_1001ACB0((int)((char *)v7 + 4), (int)&v27);
        sub_1001A740((char *)v7 + 20, (int)&v31);
        v21 = v36;
        *(_DWORD *)v36 = a4 + 1;
        *(_DWORD *)(v21 + 4) = &v39;
        v25 = *(_DWORD *)(a2 + 12);
        goto LABEL_28;
      }
LABEL_29:
      v23 = v30;
      *(_DWORD *)v7 = v26;
      *((_DWORD *)v7 + 4) = v23;
      sub_1001ACB0((int)((char *)v7 + 4), (int)&v27);
      sub_1001A740((char *)v7 + 20, (int)&v31);
      goto LABEL_30;
    }
    if ( v18 )
    {
      *(_DWORD *)v14 = a4 + 1;
      *(_DWORD *)(v14 + 4) = &v39;
      v38 = loc_1001B950(v7, *(_DWORD *)(a2 + 12));
      if ( v38 )
        goto LABEL_30;
      v14 = v36;
    }
    else
    {
      if ( a4 > 1 )
        goto LABEL_29;
    }
    *(_DWORD *)v14 = v34;
    *(_DWORD *)(v14 + 4) = v35;
    v22 = v30;
    *(_DWORD *)v7 = v26;
    *((_DWORD *)v7 + 4) = v22;
    sub_1001ACB0((int)((char *)v7 + 4), (int)&v27);
    sub_1001A740((char *)v7 + 20, (int)&v31);
  }
LABEL_27:
  v25 = *(_DWORD *)(*(_DWORD *)(a2 + 28) + 12);
LABEL_28:
  v38 = loc_1001B950(v7, v25);
  if ( !v38 )
    goto LABEL_29;
LABEL_30:
  v24 = v36;
  *(_DWORD *)v36 = v34;
  *(_DWORD *)(v24 + 4) = v35;
  if ( v31 )
    sub_1002A4AA(v31);
  if ( v27 )
    sub_1002A4AA(v27);
  return v38;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (1001CEF0) --------------------------------------------------------
char __thiscall sub_1001CEF0(int this, int a2)
{
  int v2; // ecx@1
  char v3; // bl@1
  int v4; // edi@1
  char v5; // zf@1
  int v6; // eax@1
  int v7; // esi@2
  int v8; // ecx@3
  int v9; // eax@3
  int v10; // eax@3
  int v11; // edx@3
  int v12; // eax@4
  char v13; // al@6
  int v14; // edx@7
  int v15; // esi@7
  int v16; // eax@8
  char v17; // cl@9
  char v18; // cl@13
  int v19; // eax@15
  int v20; // edx@15
  int v21; // edx@16
  unsigned int v22; // edx@21
  int v23; // ebx@23
  char v24; // zf@24
  int v25; // edx@25
  int i; // eax@26
  int v27; // ecx@26
  int v28; // eax@32
  int v29; // edx@36
  char result; // al@42
  unsigned int v31; // [sp-4h] [bp-3Ch]@1
  char v32; // [sp+10h] [bp-28h]@8
  int v33; // [sp+14h] [bp-24h]@15
  int v34; // [sp+18h] [bp-20h]@7
  int v35; // [sp+1Ch] [bp-1Ch]@3
  int v36; // [sp+20h] [bp-18h]@1
  int v37; // [sp+24h] [bp-14h]@1
  unsigned int v38; // [sp+28h] [bp-10h]@1
  int v39; // [sp+34h] [bp-4h]@3
  int v40; // [sp+38h] [bp+0h]@1

  v38 = (unsigned int)&v40 ^ __security_cookie;
  v31 = (unsigned int)&v40 ^ __security_cookie;
  v4 = this;
  v5 = (*(_DWORD *)(this + 92) & 0x100) == 0;
  v6 = *(_DWORD *)this;
  v2 = a2;
  v3 = *(_BYTE *)v6;
  v37 = a2;
  LOBYTE(v36) = v3;
  if ( !v5 )
  {
    v7 = *(_DWORD *)(v4 + 112);
    if ( !*(_DWORD *)(v7 + 4) )
    {
      v9 = sub_1001B150(v7, (int)&v35);
      v39 = 0;
      v10 = sub_10017B50(v11, v3, v4, v9);
      v39 = -1;
      v8 = v35;
      *(_DWORD *)(v7 + 4) = v10;
      if ( v8 )
      {
        v12 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v8 + 8))(v31);
        if ( v12 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v12)(v12, 1);
      }
    }
    v13 = (*(int (__stdcall **)(int))(**(_DWORD **)(v7 + 4) + 16))(v36);
    v2 = v37;
    v3 = v13;
    LOBYTE(v36) = v13;
  }
  v14 = *(_DWORD *)(v2 + 20);
  v15 = *(_DWORD *)v4 + 1;
  v34 = *(_DWORD *)v4 + 1;
  if ( v14 )
  {
    v16 = *(_DWORD *)sub_1001BF10((int)&v32, v14, *(_DWORD *)v4, *(_DWORD *)(v4 + 80));
    if ( v16 != *(_DWORD *)v4 )
    {
      v15 = v16;
      v17 = 1;
      goto LABEL_41;
    }
    v2 = v37;
  }
  if ( *(_DWORD *)(v2 + 32) )
  {
    if ( *(_DWORD *)(v4 + 92) & 0x800 )
      v18 = sub_1001A460(*(_DWORD *)(v4 + 112), v3, v4, v36);
    else
      v18 = v3;
    v20 = *(_DWORD *)(v37 + 32);
    v19 = 0;
    v33 = v20;
    if ( *(_DWORD *)(v20 + 4) > 0 )
    {
      v21 = *(_DWORD *)(v20 + 8);
      while ( *(_BYTE *)(v21 + v19) > v18 || v18 > *(_BYTE *)(v21 + v19 + 1) )
      {
        v19 += 2;
        v15 = v34;
        if ( v19 >= *(_DWORD *)(v33 + 4) )
          goto LABEL_20;
      }
      goto LABEL_39;
    }
LABEL_20:
    v2 = v37;
  }
  v22 = v3;
  if ( dword_100773D0 > v3 || v3 >= 256 )
  {
    v25 = *(_DWORD *)(v2 + 28);
    if ( v25 )
    {
      v27 = *(_DWORD *)(v25 + 8);
      for ( i = v27 + *(_DWORD *)(v25 + 4); v27 != i; ++v27 )
      {
        if ( *(_BYTE *)v27 == v3 )
          break;
      }
      if ( v27 != *(_DWORD *)(v25 + 4) + *(_DWORD *)(v25 + 8) )
      {
        v17 = 1;
        goto LABEL_41;
      }
      v2 = v37;
    }
    v28 = *(_WORD *)(v2 + 36);
    if ( (_WORD)v28 )
    {
      if ( sub_1001A530(*(_DWORD *)(v4 + 112), v3, v36, v28) )
      {
        v17 = 1;
        goto LABEL_41;
      }
      v2 = v37;
    }
    v29 = *(_DWORD *)(v2 + 40);
    if ( !v29 )
      goto LABEL_40;
    v24 = sub_1001BFA0(v3, v29, *(void **)(v4 + 112)) == 0;
  }
  else
  {
    v23 = *(_DWORD *)(v2 + 24);
    if ( !v23 )
      goto LABEL_40;
    v24 = ((unsigned __int8)(1 << (v22 & 7)) & *(_BYTE *)((v22 >> 3) + v23)) == 0;
  }
  if ( !v24 )
  {
LABEL_39:
    v17 = 1;
    goto LABEL_41;
  }
LABEL_40:
  v17 = 0;
LABEL_41:
  if ( v17 == (*(_BYTE *)(v37 + 8) & 1) )
  {
    result = 0;
  }
  else
  {
    *(_DWORD *)v4 = v15;
    result = 1;
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 100773D0: using guessed type int dword_100773D0;

//----- (1001D0F0) --------------------------------------------------------
char __thiscall sub_1001D0F0(int this)
{
  unsigned int v1; // eax@1
  int v2; // edx@2
  int v3; // edi@4
  int v4; // edi@7
  int v5; // edi@9
  int v6; // edx@12
  int v7; // esi@12

  v1 = 0;
  if ( *(_DWORD *)(this + 104) <= 0 )
    return 0;
  while ( 1 )
  {
    v2 = *(_DWORD *)(this + 36);
    if ( (signed int)v1 < 0 && v1 )
      v3 = v2 - (4 * ((-1 - v1) >> 5) + 4);
    else
      v3 = v2 + 4 * (v1 >> 5);
    if ( !((1 << (v1 & 0x1F)) & *(_DWORD *)v3)
      || ((v4 = *(_DWORD *)(this + 4), (signed int)v1 >= 0) || !v1 ? (v5 = v4 + 4 * (v1 >> 5)) : (v5 = v4 - (4 * ((-1 - v1) >> 5) + 4)),
          !((1 << (v1 & 0x1F)) & *(_DWORD *)v5)) )
      goto LABEL_14;
    v6 = *(_DWORD *)(this + 52) + 8 * v1;
    v7 = *(_DWORD *)(this + 20) + 8 * v1;
    if ( *(_DWORD *)v6 != *(_DWORD *)v7 )
      return *(_DWORD *)(*(_DWORD *)(this + 52) + 8 * v1) - *(_DWORD *)(this + 76) < *(_DWORD *)(*(_DWORD *)(this + 20)
                                                                                               + 8 * v1)
                                                                                   - *(_DWORD *)(this + 76);
    if ( *(_DWORD *)(v6 + 4) != *(_DWORD *)(v7 + 4) )
      return *(_DWORD *)(*(_DWORD *)(this + 52) + 8 * v1 + 4) - *(_DWORD *)(this + 76) < *(_DWORD *)(*(_DWORD *)(this + 20) + 8 * v1 + 4)
                                                                                       - *(_DWORD *)(this + 76);
LABEL_14:
    ++v1;
    if ( (signed int)v1 >= *(_DWORD *)(this + 104) )
      return 0;
  }
}

//----- (1001D220) --------------------------------------------------------
int __usercall sub_1001D220<eax>(char a1<dl>, int a2<ecx>, __int16 a3<bx>, int a4, int a5, int a6, int a7, __int16 a8, char a9)
{
  int v9; // esi@1
  int v10; // eax@2
  int v12; // [sp+8h] [bp-8h]@2
  unsigned int v13; // [sp+Ch] [bp-4h]@1
  int v14; // [sp+10h] [bp+0h]@1

  v13 = (unsigned int)&v14 ^ __security_cookie;
  v9 = a2;
  *(_DWORD *)a2 = a5;
  if ( a8 & 0x800 )
  {
    v10 = sub_1001E340(a9, (int)&v12, a3, a4, a5, a6, a7, a1);
  }
  else
  {
    if ( a8 & 0x100 )
    {
      v10 = sub_1001E540((int)&v12, a9, a4, (int *)a5, a6, a7, a1);
    }
    else
    {
      LOBYTE(v12) = 0;
      v10 = sub_1001E5F0((int)&v12, a9, a4, a5, a6, a7);
    }
  }
  *(_DWORD *)v9 = *(_DWORD *)v10;
  return v9;
}
// 10074200: using guessed type int __security_cookie;

//----- (1001D2B0) --------------------------------------------------------
int __fastcall sub_1001D2B0(int a1, int a2, int a3, int a4, int a5, int a6, char a7)
{
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // ebx@1
  int v10; // edi@1
  int v11; // esi@1
  void **v12; // edi@3
  int v13; // ecx@4
  int v14; // eax@4
  int v15; // eax@4
  int v16; // edx@4
  int v17; // eax@5
  int *v18; // eax@8
  void **v19; // edi@14
  int v20; // ecx@15
  int v21; // eax@15
  int v22; // eax@15
  int v23; // edx@15
  int v24; // eax@16
  int *v25; // eax@19
  char v26; // zf@30
  int *v27; // eax@30
  int result; // eax@32
  unsigned int v29; // [sp-4h] [bp-74h]@1
  int v30; // [sp+10h] [bp-60h]@15
  int v31; // [sp+14h] [bp-5Ch]@4
  int v32; // [sp+18h] [bp-58h]@1
  int v33; // [sp+1Ch] [bp-54h]@1
  void *v34; // [sp+20h] [bp-50h]@18
  int v35; // [sp+30h] [bp-40h]@18
  unsigned int v36; // [sp+34h] [bp-3Ch]@19
  void *v37; // [sp+38h] [bp-38h]@7
  int v38; // [sp+48h] [bp-28h]@7
  unsigned int v39; // [sp+4Ch] [bp-24h]@8
  int v40; // [sp+50h] [bp-20h]@1
  char v41; // [sp+54h] [bp-1Ch]@3
  char v42; // [sp+55h] [bp-1Bh]@7
  char v43; // [sp+58h] [bp-18h]@14
  char v44; // [sp+59h] [bp-17h]@18
  unsigned int v45; // [sp+5Ch] [bp-14h]@1
  int v46; // [sp+6Ch] [bp-4h]@4
  int v47; // [sp+70h] [bp+0h]@1

  v45 = (unsigned int)&v47 ^ __security_cookie;
  v29 = (unsigned int)&v47 ^ __security_cookie;
  v32 = a2;
  v10 = a1;
  v33 = a1;
  v8 = a3;
  v7 = a4;
  v9 = a5;
  v11 = a3;
  v40 = a3;
  if ( a3 == a4 )
  {
LABEL_28:
    if ( a2 != v9 )
    {
      if ( !a7 || (v26 = v8 == v7, v27 = &a3, !v26) )
        v27 = &v40;
      goto LABEL_32;
    }
  }
  else
  {
    while ( a2 != v9 )
    {
      v12 = (void **)a6;
      LOBYTE(v9) = *(_BYTE *)a2;
      a3 = v8 + 1;
      v41 = *(_BYTE *)v8;
      if ( !*(_DWORD *)a6 )
      {
        v14 = sub_1001B150(a6, (int)&v31);
        v46 = 0;
        v15 = sub_1001C310(v16, v9, (int)v12, v14);
        v46 = -1;
        v13 = v31;
        *v12 = (void *)v15;
        if ( v13 )
        {
          v17 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v13 + 8))(v29);
          if ( v17 )
            (**(void (__thiscall ***)(_DWORD, _DWORD))v17)(v17, 1);
        }
      }
      sub_1001AEF0(*v12, (int)&v37, (int)&v41, (int)&v42);
      if ( v38 == 1 )
      {
        v18 = (int *)&v37;
        if ( v39 >= 0x10 )
          v18 = (int *)v37;
        BYTE1(v9) = *(_BYTE *)v18;
      }
      else
      {
        BYTE1(v9) = v41;
      }
      if ( v39 >= 0x10 )
        sub_1002A4AA(v37);
      v19 = (void **)a6;
      v39 = 15;
      v38 = 0;
      LOBYTE(v37) = 0;
      v43 = v9;
      if ( !*(_DWORD *)a6 )
      {
        v21 = sub_1001B150(a6, (int)&v30);
        v46 = 1;
        v22 = sub_1001C310(v23, v9, (int)v19, v21);
        v46 = -1;
        v20 = v30;
        *v19 = (void *)v22;
        if ( v20 )
        {
          v24 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v20 + 8))(v29);
          if ( v24 )
            (**(void (__thiscall ***)(_DWORD, _DWORD))v24)(v24, 1);
        }
      }
      sub_1001AEF0(*v19, (int)&v34, (int)&v43, (int)&v44);
      if ( v35 == 1 )
      {
        v25 = (int *)&v34;
        if ( v36 >= 0x10 )
          v25 = (int *)v34;
        LOBYTE(v9) = *(_BYTE *)v25;
      }
      else
      {
        LOBYTE(v9) = v43;
      }
      if ( v36 >= 0x10 )
        sub_1002A4AA(v34);
      a2 = v32 + 1;
      v36 = 15;
      v35 = 0;
      LOBYTE(v34) = 0;
      ++v32;
      if ( BYTE1(v9) != (_BYTE)v9 )
      {
        result = v33;
        *(_DWORD *)v33 = v11;
        return result;
      }
      v8 = a3;
      v7 = a4;
      v9 = a5;
      if ( a3 == a4 )
      {
        v10 = v33;
        goto LABEL_28;
      }
    }
    v10 = v33;
  }
  v27 = &a3;
LABEL_32:
  *(_DWORD *)v10 = *v27;
  return v10;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (1001D4B0) --------------------------------------------------------
int __fastcall sub_1001D4B0(int a1, int a2, int a3, int *a4, int a5, char a6, char a7)
{
  int *v7; // eax@1
  int v8; // edx@1
  int *v9; // ecx@1
  int v10; // ebx@1
  int v11; // edi@1
  int v12; // esi@1
  char v13; // zf@8
  int *v14; // eax@8
  int result; // eax@10
  int v16; // [sp+Ch] [bp-Ch]@1
  int v17; // [sp+10h] [bp-8h]@1
  unsigned int v18; // [sp+14h] [bp-4h]@1
  int v19; // [sp+18h] [bp+0h]@1

  v18 = (unsigned int)&v19 ^ __security_cookie;
  v7 = a4;
  v10 = a5;
  v11 = a2;
  v8 = a1;
  v9 = (int *)a3;
  v12 = a3;
  v16 = v8;
  v17 = a3;
  if ( (int *)a3 == a4 )
  {
LABEL_6:
    if ( v11 != v10 )
    {
      if ( !a7 || (v13 = v9 == v7, v14 = &a3, !v13) )
        v14 = &v17;
      goto LABEL_10;
    }
  }
  else
  {
    while ( v11 != v10 )
    {
      LOBYTE(v8) = *(_BYTE *)v11;
      a3 = (int)((char *)v9 + 1);
      ++v11;
      if ( !sub_1001D8D0((int)&a6, v10, *(_BYTE *)v9, v8) )
      {
        result = v16;
        *(_DWORD *)v16 = v12;
        return result;
      }
      v9 = (int *)a3;
      v7 = a4;
      if ( (int *)a3 == a4 )
      {
        v8 = v16;
        goto LABEL_6;
      }
    }
    v8 = v16;
  }
  v14 = &a3;
LABEL_10:
  *(_DWORD *)v8 = *v14;
  return v8;
}
// 10074200: using guessed type int __security_cookie;

//----- (1001D560) --------------------------------------------------------
int __fastcall sub_1001D560(int a1, int a2, int a3, int a4, int a5, int a6, char a7)
{
  int v7; // eax@1
  int v8; // edx@1
  int v9; // ecx@1
  int v10; // ebx@1
  int v11; // edi@1
  char v12; // dl@3
  int v13; // eax@3
  int *v14; // eax@8
  int result; // eax@10
  int v16; // [sp+Ch] [bp-Ch]@1
  int v17; // [sp+10h] [bp-8h]@1
  unsigned int v18; // [sp+14h] [bp-4h]@1
  int v19; // [sp+18h] [bp+0h]@1

  v18 = (unsigned int)&v19 ^ __security_cookie;
  v7 = a5;
  v10 = a2;
  v8 = a1;
  v9 = a3;
  v11 = a3;
  v16 = v8;
  v17 = a3;
  if ( a3 == a4 )
  {
LABEL_6:
    if ( v10 != v7 )
    {
      if ( !a7 || (v14 = &a3, v9 != a4) )
        v14 = &v17;
      goto LABEL_10;
    }
  }
  else
  {
    while ( v10 != v7 )
    {
      v12 = *(_BYTE *)v10;
      v13 = v9++;
      a3 = v9;
      ++v10;
      if ( *(_BYTE *)v13 != v12 )
      {
        result = v16;
        *(_DWORD *)v16 = v11;
        return result;
      }
      v7 = a5;
      if ( v9 == a4 )
      {
        v8 = v16;
        goto LABEL_6;
      }
    }
    v8 = v16;
  }
  v14 = &a3;
LABEL_10:
  *(_DWORD *)v8 = *v14;
  return v8;
}
// 10074200: using guessed type int __security_cookie;

//----- (1001D600) --------------------------------------------------------
int __thiscall sub_1001D600(void *this, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@2
  char v6; // zf@2
  int v7; // ecx@3
  int v8; // eax@3
  int v9; // eax@3
  int v10; // edx@3
  int v11; // eax@4
  int v12; // ecx@7
  int v13; // eax@7
  int v14; // eax@7
  int v15; // edx@7
  int v16; // eax@8
  int v17; // ebx@10
  void *v19; // [sp+10h] [bp-44h]@10
  unsigned int v20; // [sp+24h] [bp-30h]@14
  int v21; // [sp+28h] [bp-2Ch]@1
  int v22; // [sp+2Ch] [bp-28h]@1
  int v23; // [sp+30h] [bp-24h]@2
  int v24; // [sp+34h] [bp-20h]@2
  int v25; // [sp+38h] [bp-1Ch]@2
  int v26; // [sp+3Ch] [bp-18h]@2
  int v27; // [sp+40h] [bp-14h]@3
  int v28; // [sp+50h] [bp-4h]@1

  v4 = (int)this;
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  v21 = a2;
  *(_BYTE *)a2 = 0;
  v28 = 0;
  v22 = 1;
  if ( a3 != a4 )
  {
    v23 = 0;
    v24 = 0;
    v25 = 0;
    sub_1001EDA0((int)&v23, a3, a4);
    v28 = 1;
    v5 = v23;
    v6 = *(_DWORD *)(v4 + 4) == 0;
    v26 = v24 - v23;
    if ( v6 )
    {
      v8 = sub_1001B150(v4, (int)&v27);
      LOBYTE(v28) = 2;
      v9 = sub_10017B50(v10, v4, v5, v8);
      LOBYTE(v28) = 1;
      v7 = v27;
      *(_DWORD *)(v4 + 4) = v9;
      if ( v7 )
      {
        v11 = (*(int (**)(void))(*(_DWORD *)v7 + 8))();
        if ( v11 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v11)(v11, 1);
      }
    }
    (*(void (__stdcall **)(int, int))(**(_DWORD **)(v4 + 4) + 12))(v5, v5 + v26);
    if ( !*(_DWORD *)v4 )
    {
      v13 = sub_1001B150(v4, (int)&v27);
      LOBYTE(v28) = 3;
      v14 = sub_1001C310(v15, v4, v5, v13);
      LOBYTE(v28) = 1;
      v12 = v27;
      *(_DWORD *)v4 = v14;
      if ( v12 )
      {
        v16 = (*(int (**)(void))(*(_DWORD *)v12 + 8))();
        if ( v16 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v16)(v16, 1);
      }
    }
    v17 = sub_1001AEF0(*(void **)v4, (int)&v19, v5, v5 + v26);
    if ( a2 != v17 )
    {
      if ( *(_DWORD *)(a2 + 20) >= 0x10u )
        sub_1002A4AA(*(LPVOID *)a2);
      *(_DWORD *)(a2 + 20) = 15;
      *(_DWORD *)(a2 + 16) = 0;
      *(_BYTE *)a2 = 0;
      sub_100017B0((void *)a2, v17);
    }
    if ( v20 >= 0x10 )
      sub_1002A4AA(v19);
    if ( v5 )
      sub_1002A4AA((LPVOID)v5);
  }
  return a2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1001D7A0) --------------------------------------------------------
int __fastcall sub_1001D7A0(int a1, int a2, int a3)
{
  int result; // eax@1
  int i; // esi@1

  result = a3;
  for ( i = a1; i != a2; result += 8 )
  {
    if ( result )
    {
      *(_DWORD *)result = *(_DWORD *)i;
      *(_DWORD *)(result + 4) = *(_DWORD *)(i + 4);
    }
    i += 8;
  }
  return result;
}

//----- (1001D7D0) --------------------------------------------------------
void __fastcall sub_1001D7D0(int a1, int a2)
{
  for ( ; a2; --a2 )
  {
    if ( a1 )
    {
      *(_DWORD *)a1 = 0;
      *(_DWORD *)(a1 + 4) = 0;
    }
    a1 += 8;
  }
}

//----- (1001D7F0) --------------------------------------------------------
signed int __usercall sub_1001D7F0<eax>(signed int result<eax>, int a2<ecx>, int a3, unsigned int a4, int a5, int a6)
{
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // esi@1

  v6 = a3;
  v8 = a2;
  v7 = a4;
  while ( v6 != a5 || v7 != a6 )
  {
    result = 1 << v7;
    if ( *(_BYTE *)v8 )
    {
      *(_DWORD *)v6 |= result;
    }
    else
    {
      result = ~result;
      *(_DWORD *)v6 &= result;
    }
    v6 = a3;
    if ( a4 >= 0x1F )
    {
      v7 = 0;
      v6 = a3 + 4;
      a4 = 0;
      a3 += 4;
    }
    else
    {
      v7 = a4++ + 1;
    }
  }
  return result;
}

//----- (1001D840) --------------------------------------------------------
void __fastcall sub_1001D840(int a1, int a2)
{
  for ( ; a2; --a2 )
  {
    if ( a1 )
    {
      *(_DWORD *)a1 = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_BYTE *)(a1 + 8) = 0;
    }
    a1 += 12;
  }
}

//----- (1001D860) --------------------------------------------------------
int __thiscall sub_1001D860(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  if ( (unsigned __int8)loc_1001AE80((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 3) )
    *(_DWORD *)(v2 + 4) = sub_1001F560(*(void **)v2, *(_DWORD *)a2, *(_DWORD *)(a2 + 4));
  return v2;
}

//----- (1001D8D0) --------------------------------------------------------
char __userpurge sub_1001D8D0<al>(int a1<ecx>, char a2<bl>, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ecx@2
  int v7; // eax@2
  int v8; // eax@2
  int v9; // edx@2
  int v10; // eax@3
  char v11; // bl@5
  int v12; // esi@5
  char v13; // al@5
  int v14; // ecx@6
  int v15; // eax@6
  int v16; // eax@6
  int v17; // edx@6
  int v18; // eax@7
  int v20; // [sp+10h] [bp-10h]@2
  int v21; // [sp+1Ch] [bp-4h]@2

  v4 = a1;
  v5 = *(_DWORD *)a1;
  if ( !*(_DWORD *)(*(_DWORD *)a1 + 4) )
  {
    v7 = sub_1001B150(v5, (int)&v20);
    v21 = 0;
    v8 = sub_10017B50(v9, a2, v4, v7);
    v21 = -1;
    v6 = v20;
    *(_DWORD *)(v5 + 4) = v8;
    if ( v6 )
    {
      v10 = (*(int (**)(void))(*(_DWORD *)v6 + 8))();
      if ( v10 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v10)(v10, 1);
    }
  }
  v13 = (*(int (__stdcall **)(int))(**(_DWORD **)(v5 + 4) + 16))(a3);
  v12 = *(_DWORD *)v4;
  v11 = v13;
  if ( !*(_DWORD *)(*(_DWORD *)v4 + 4) )
  {
    v15 = sub_1001B150(v12, (int)&a3);
    v21 = 1;
    v16 = sub_10017B50(v17, v11, v4, v15);
    v21 = -1;
    v14 = a3;
    *(_DWORD *)(v12 + 4) = v16;
    if ( v14 )
    {
      v18 = (*(int (**)(void))(*(_DWORD *)v14 + 8))();
      if ( v18 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v18)(v18, 1);
    }
  }
  return v11 == (unsigned __int8)(*(int (__cdecl **)(int))(**(_DWORD **)(v12 + 4) + 16))(a4);
}

//----- (1001D9C0) --------------------------------------------------------
char __thiscall sub_1001D9C0(int this)
{
  int v1; // eax@1
  int v2; // ecx@2
  char v3; // al@6

  v1 = *(_DWORD *)this + 1;
  return v1 != *(_DWORD *)(this + 8)
      && ((v2 = *(_DWORD *)(this + 80), !(v2 & 8)) && (*(_BYTE *)v1 == 40 || *(_BYTE *)v1 == 41)
       || !(v2 & 0x10) && ((v3 = *(_BYTE *)v1, v3 == 123) || v3 == 125));
}

//----- (1001DA00) --------------------------------------------------------
char __thiscall sub_1001DA00(void *this)
{
  int v1; // eax@1
  int v2; // edx@1
  int v3; // eax@3
  int v4; // edx@4

  v1 = *(_DWORD *)this;
  v2 = *((_DWORD *)this + 2);
  if ( *(_DWORD *)this != v2 )
  {
    if ( *(_BYTE *)v1 == 92 )
    {
      v3 = v1 + 1;
      if ( v3 != v2 )
      {
        v4 = *((_DWORD *)this + 20);
        if ( !(v4 & 8) && (*(_BYTE *)v3 == 40 || *(_BYTE *)v3 == 41)
          || !(v4 & 0x10) && (*(_BYTE *)v3 == 123 || *(_BYTE *)v3 == 125) )
          *(_DWORD *)this = v3;
      }
    }
    ++*(_DWORD *)this;
  }
  return sub_1001C5A0(this);
}

//----- (1001DE90) --------------------------------------------------------
char __thiscall sub_1001DE90(int this)
{
  int v1; // eax@1
  int v2; // ecx@1
  int v3; // eax@5

  v2 = *(_DWORD *)(this + 4);
  v1 = *(_DWORD *)(v2 + 4);
  return v1 == 20
      || v1 == 8
      || v1 == 13
      || v1 == 2 && ((v3 = *(_DWORD *)(*(_DWORD *)(v2 + 16) + 4), v3 == 20) || v3 == 8 || v3 == 13);
}

//----- (1001DED0) --------------------------------------------------------
int __usercall sub_1001DED0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a4, 20);
  v5 = v4;
  if ( v4 )
  {
    *(_DWORD *)v4 = off_10068B14;
    *(_DWORD *)(v4 + 4) = 8;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  result = v5;
  *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) = v5;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 10068B14: using guessed type int (__stdcall *off_10068B14[2])(char);

//----- (1001DF40) --------------------------------------------------------
int __userpurge sub_1001DF40<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // eax@4
  int v10; // eax@6
  int v12; // edx@9

  v7 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a2, 20);
  v8 = v4;
  if ( v4 )
  {
    *(_DWORD *)(v4 + 4) = 17;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    *(_DWORD *)v4 = off_10068B14;
  }
  else
  {
    v8 = 0;
  }
  *(_DWORD *)(v8 + 16) = *(_DWORD *)(v7 + 4);
  v9 = *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12);
  if ( v9 )
  {
    *(_DWORD *)(v8 + 12) = v9;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) + 16) = v8;
  }
  *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) = v8;
  *(_DWORD *)(v7 + 4) = v8;
  v10 = sub_1002ADB1(v5, v6, a3, v7, 28);
  if ( v10 )
  {
    *(_DWORD *)(v10 + 4) = 16;
    *(_DWORD *)(v10 + 8) = 0;
    *(_DWORD *)(v10 + 12) = 0;
    *(_DWORD *)(v10 + 16) = 0;
    *(_DWORD *)v10 = off_10068B10;
    *(_DWORD *)(v10 + 20) = v8;
    *(_DWORD *)(v10 + 24) = 0;
  }
  else
  {
    v10 = 0;
  }
  v12 = *(_DWORD *)(a4 + 12);
  *(_DWORD *)(v10 + 16) = *(_DWORD *)(v12 + 16);
  *(_DWORD *)(*(_DWORD *)(v12 + 16) + 12) = v10;
  *(_DWORD *)(v10 + 12) = v12;
  *(_DWORD *)(v12 + 16) = v10;
  return v8;
}
// 10068B10: using guessed type int (__stdcall *off_10068B10[3])(char);
// 10068B14: using guessed type int (__stdcall *off_10068B14[2])(char);

//----- (1001E000) --------------------------------------------------------
int __fastcall sub_1001E000(int a1, int a2, int a3, int a4)
{
  int v4; // eax@1
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@1
  char v8; // zf@2
  int v9; // eax@3
  int result; // eax@4

  v6 = *(_DWORD *)(a3 + 12);
  v5 = *(_DWORD *)(a4 + 12);
  *(_DWORD *)(a4 + 12) = 0;
  v7 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 4) = a4;
  *(_DWORD *)(a4 + 12) = 0;
  *(_DWORD *)(v7 + 12) = a4;
  v4 = v6 + 24;
  if ( *(_DWORD *)(v6 + 24) )
  {
    do
    {
      v6 = *(_DWORD *)v4;
      v8 = *(_DWORD *)(*(_DWORD *)v4 + 24) == 0;
      v4 = *(_DWORD *)v4 + 24;
    }
    while ( !v8 );
  }
  v9 = sub_1002ADB1(a2, a1, v5, a4, 28);
  if ( v9 )
  {
    *(_DWORD *)(v9 + 20) = a4;
    *(_DWORD *)(v9 + 4) = 16;
    *(_DWORD *)(v9 + 8) = 0;
    *(_DWORD *)(v9 + 12) = 0;
    *(_DWORD *)(v9 + 16) = 0;
    *(_DWORD *)v9 = off_10068B10;
    *(_DWORD *)(v9 + 24) = 0;
    *(_DWORD *)(v6 + 24) = v9;
    *(_DWORD *)(v9 + 12) = v5;
    result = *(_DWORD *)(v6 + 24);
    *(_DWORD *)(v5 + 16) = result;
  }
  else
  {
    *(_DWORD *)(v6 + 24) = 0;
    vc = v5;
    result = *(_DWORD *)(v6 + 24);
    *(_DWORD *)(v5 + 16) = result;
  }
  return result;
}
// 10068B10: using guessed type int (__stdcall *off_10068B10[3])(char);

//----- (1001E0A0) --------------------------------------------------------
char __thiscall sub_1001E0A0(void *this, int a2, char a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  void *v5; // esi@1
  int v6; // esi@2
  int v7; // eax@6
  int v8; // edi@6
  int v9; // ecx@9
  int v10; // eax@10
  int v11; // ecx@11
  int v12; // esi@12
  char v13; // bl@17
  int *v14; // esi@19
  int v16; // [sp+10h] [bp-64h]@1
  int v17; // [sp+14h] [bp-60h]@1
  void *v18; // [sp+1Ch] [bp-58h]@1
  char v19; // [sp+23h] [bp-51h]@6
  int v20; // [sp+24h] [bp-50h]@1
  void *v21; // [sp+28h] [bp-4Ch]@1
  int v22; // [sp+2Ch] [bp-48h]@1
  int v23; // [sp+30h] [bp-44h]@1
  int v24; // [sp+34h] [bp-40h]@1
  void *v25; // [sp+38h] [bp-3Ch]@1
  int v26; // [sp+3Ch] [bp-38h]@1
  int v27; // [sp+40h] [bp-34h]@1
  int v28; // [sp+44h] [bp-30h]@6
  void *v29; // [sp+48h] [bp-2Ch]@6
  int v30; // [sp+4Ch] [bp-28h]@6
  int v31; // [sp+50h] [bp-24h]@6
  int v32; // [sp+54h] [bp-20h]@6
  void *v33; // [sp+58h] [bp-1Ch]@6
  int v34; // [sp+5Ch] [bp-18h]@6
  int v35; // [sp+60h] [bp-14h]@6
  unsigned int v36; // [sp+64h] [bp-10h]@1
  int v37; // [sp+70h] [bp-4h]@1
  int v38; // [sp+74h] [bp+0h]@1

  v36 = (unsigned int)&v38 ^ __security_cookie;
  v5 = this;
  v18 = this;
  v4 = a2;
  v3 = 0;
  v20 = *(_DWORD *)this;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v17 = (int)((char *)this + 4);
  sub_1001C530((int)&v21, (int)((char *)this + 4));
  v24 = *((_DWORD *)v5 + 4);
  v37 = 0;
  v16 = (int)((char *)v5 + 20);
  sub_1001D860((int)&v25, (int)((char *)v5 + 20));
  v37 = 1;
  if ( *(_DWORD *)(a2 + 20) <= 0 )
  {
LABEL_6:
    v7 = *(_DWORD *)v5;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v33 = 0;
    v34 = 0;
    v35 = 0;
    v28 = v7;
    sub_1001C530((int)&v29, (int)((char *)v5 + 4));
    v32 = *((_DWORD *)v5 + 4);
    LOBYTE(v37) = 2;
    sub_1001D860((int)&v33, (int)((char *)v5 + 20));
    v19 = 0;
    LOBYTE(v37) = 3;
    v8 = *(_DWORD *)v5;
    if ( !(unsigned __int8)loc_1001B950(v5, *(_DWORD *)(*(_DWORD *)(a2 + 28) + 12)) )
      goto LABEL_9;
    if ( a3 )
    {
      v28 = *(_DWORD *)v5;
      v32 = *((_DWORD *)v5 + 4);
      sub_1001ACB0((int)&v29, (int)((char *)v5 + 4));
      sub_1001A740(&v33, (int)((char *)v5 + 20));
      v19 = 1;
LABEL_9:
      while ( 1 )
      {
        v9 = *(_DWORD *)(a2 + 24);
        if ( v9 != -1 )
        {
          v10 = v3++;
          if ( v10 >= v9 )
            break;
        }
        v11 = v24;
        *(_DWORD *)v5 = v8;
        *((_DWORD *)v5 + 4) = v11;
        sub_1001ACB0((int)((char *)v5 + 4), (int)&v21);
        if ( !(unsigned __int8)loc_1001B950(v5, *(_DWORD *)(a2 + 12)) )
          break;
        v12 = *(_DWORD *)v5;
        if ( (unsigned __int8)loc_1001B950(v18, *(_DWORD *)(*(_DWORD *)(a2 + 28) + 12)) )
        {
          if ( !a3 )
            goto LABEL_18;
          v28 = *(_DWORD *)v18;
          v32 = *(_DWORD *)(v17 + 12);
          sub_1001ACB0((int)&v29, v17);
          sub_1001A740(&v33, v16);
          v19 = 1;
        }
        if ( v8 == v12 )
          break;
        v8 = v12;
        v5 = v18;
      }
      v13 = v19;
      v14 = &v28;
      if ( !v19 )
        v14 = &v20;
      *(_DWORD *)v18 = *v14;
      *(_DWORD *)(v17 + 12) = v14[4];
      sub_1001ACB0(v17, (int)(v14 + 1));
      sub_1001A740((void *)v16, (int)(v14 + 5));
    }
    else
    {
LABEL_18:
      v13 = 1;
    }
    if ( v33 )
      sub_1002A4AA(v33);
    if ( v29 )
      sub_1002A4AA(v29);
  }
  else
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)v5;
      if ( !(unsigned __int8)loc_1001B950(v18, *(_DWORD *)(v4 + 12)) )
        break;
      v4 = a2;
      if ( v6 == *(_DWORD *)v18 )
        v3 = *(_DWORD *)(a2 + 20) - 1;
      v5 = v18;
      ++v3;
      if ( v3 >= *(_DWORD *)(a2 + 20) )
        goto LABEL_6;
    }
    *(_DWORD *)v18 = v20;
    *((_DWORD *)v18 + 4) = v24;
    sub_1001ACB0((int)((char *)v18 + 4), (int)&v21);
    sub_1001A740((char *)v18 + 20, (int)&v25);
    v13 = 0;
  }
  if ( v25 )
    sub_1002A4AA(v25);
  if ( v21 )
    sub_1002A4AA(v21);
  return v13;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (1001E340) --------------------------------------------------------
int __usercall sub_1001E340<eax>(char a1<dl>, int a2<ecx>, __int16 a3<bx>, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // eax@1
  int v9; // edx@1
  char v10; // bl@1
  int v11; // edi@1
  int v12; // esi@1
  int v13; // ecx@3
  void **v14; // esi@3
  char v15; // al@3
  int v16; // ecx@4
  int v17; // eax@4
  int v18; // eax@4
  int v19; // edx@4
  int v20; // eax@5
  int *v21; // eax@8
  void **v22; // esi@14
  int v23; // ecx@15
  int v24; // eax@15
  int v25; // eax@15
  int v26; // edx@15
  int v27; // eax@16
  int *v28; // eax@19
  char v29; // zf@30
  int *v30; // eax@30
  int result; // eax@32
  unsigned int v32; // [sp-4h] [bp-74h]@1
  int v33; // [sp+10h] [bp-60h]@15
  int v34; // [sp+14h] [bp-5Ch]@4
  int v35; // [sp+18h] [bp-58h]@1
  char v36; // [sp+1Fh] [bp-51h]@1
  void *v37; // [sp+20h] [bp-50h]@18
  int v38; // [sp+30h] [bp-40h]@18
  unsigned int v39; // [sp+34h] [bp-3Ch]@19
  void *v40; // [sp+38h] [bp-38h]@7
  int v41; // [sp+48h] [bp-28h]@7
  unsigned int v42; // [sp+4Ch] [bp-24h]@8
  int v43; // [sp+50h] [bp-20h]@1
  char v44; // [sp+54h] [bp-1Ch]@3
  char v45; // [sp+55h] [bp-1Bh]@7
  char v46; // [sp+58h] [bp-18h]@14
  char v47; // [sp+59h] [bp-17h]@18
  unsigned int v48; // [sp+5Ch] [bp-14h]@1
  int v49; // [sp+6Ch] [bp-4h]@4
  int v50; // [sp+70h] [bp+0h]@1

  v48 = (unsigned int)&v50 ^ __security_cookie;
  v32 = (unsigned int)&v50 ^ __security_cookie;
  v10 = a1;
  v36 = a1;
  v9 = a2;
  v35 = a2;
  v12 = a4;
  v8 = a5;
  v11 = a4;
  v43 = a4;
  if ( a4 == a5 )
  {
LABEL_28:
    if ( a6 != a7 )
    {
      if ( !v10 || (v29 = v12 == v8, v30 = &a4, !v29) )
        v30 = &v43;
      goto LABEL_32;
    }
  }
  else
  {
    while ( a6 != a7 )
    {
      v13 = a6++;
      a4 = v12 + 1;
      v15 = *(_BYTE *)v12;
      v14 = (void **)a8;
      LOBYTE(a3) = *(_BYTE *)v13;
      v44 = v15;
      if ( !*(_DWORD *)a8 )
      {
        v17 = sub_1001B150(a8, (int)&v34);
        v49 = 0;
        v18 = sub_1001C310(v19, a3, v11, v17);
        v49 = -1;
        v16 = v34;
        *v14 = (void *)v18;
        if ( v16 )
        {
          v20 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v16 + 8))(v32);
          if ( v20 )
            (**(void (__thiscall ***)(_DWORD, _DWORD))v20)(v20, 1);
        }
      }
      sub_1001AEF0(*v14, (int)&v40, (int)&v44, (int)&v45);
      if ( v41 == 1 )
      {
        v21 = (int *)&v40;
        if ( v42 >= 0x10 )
          v21 = (int *)v40;
        HIBYTE(a3) = *(_BYTE *)v21;
      }
      else
      {
        HIBYTE(a3) = v44;
      }
      if ( v42 >= 0x10 )
        sub_1002A4AA(v40);
      v22 = (void **)a8;
      v42 = 15;
      v41 = 0;
      LOBYTE(v40) = 0;
      v46 = a3;
      if ( !*(_DWORD *)a8 )
      {
        v24 = sub_1001B150(a8, (int)&v33);
        v49 = 1;
        v25 = sub_1001C310(v26, a3, v11, v24);
        v49 = -1;
        v23 = v33;
        *v22 = (void *)v25;
        if ( v23 )
        {
          v27 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v23 + 8))(v32);
          if ( v27 )
            (**(void (__thiscall ***)(_DWORD, _DWORD))v27)(v27, 1);
        }
      }
      sub_1001AEF0(*v22, (int)&v37, (int)&v46, (int)&v47);
      if ( v38 == 1 )
      {
        v28 = (int *)&v37;
        if ( v39 >= 0x10 )
          v28 = (int *)v37;
        LOBYTE(a3) = *(_BYTE *)v28;
      }
      else
      {
        LOBYTE(a3) = v46;
      }
      if ( v39 >= 0x10 )
        sub_1002A4AA(v37);
      v39 = 15;
      v38 = 0;
      LOBYTE(v37) = 0;
      if ( HIBYTE(a3) != (_BYTE)a3 )
      {
        result = v35;
        *(_DWORD *)v35 = v11;
        return result;
      }
      v12 = a4;
      v8 = a5;
      if ( a4 == a5 )
      {
        v9 = v35;
        v10 = v36;
        goto LABEL_28;
      }
    }
    v9 = v35;
  }
  v30 = &a4;
LABEL_32:
  *(_DWORD *)v9 = *v30;
  return v9;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (1001E540) --------------------------------------------------------
int __fastcall sub_1001E540(int a1, char a2, int a3, int *a4, int a5, int a6, char a7)
{
  int *v7; // eax@1
  int v8; // ebx@1
  int v9; // edi@1
  int *v10; // esi@1
  int *v11; // ecx@3
  int *v12; // eax@7
  char v14; // zf@10
  char v15; // [sp+Fh] [bp-9h]@1
  int v16; // [sp+10h] [bp-8h]@1
  unsigned int v17; // [sp+14h] [bp-4h]@1
  int v18; // [sp+18h] [bp+0h]@1

  v17 = (unsigned int)&v18 ^ __security_cookie;
  v7 = a4;
  v10 = (int *)a3;
  v9 = a3;
  v15 = a2;
  v8 = a1;
  v16 = a3;
  if ( (int *)a3 == a4 )
  {
LABEL_6:
    if ( a5 != a6 )
    {
      if ( !a2 || (v14 = v10 == v7, v12 = &a3, !v14) )
        v12 = &v16;
      goto LABEL_12;
    }
  }
  else
  {
    while ( a5 != a6 )
    {
      v11 = (int *)a5++;
      a3 = (int)((char *)v10 + 1);
      if ( !sub_1001D8D0((int)&a7, v8, *(_BYTE *)v10, *(_BYTE *)v11) )
      {
        *(_DWORD *)v8 = v9;
        return v8;
      }
      v10 = (int *)a3;
      v7 = a4;
      if ( (int *)a3 == a4 )
      {
        a2 = v15;
        goto LABEL_6;
      }
    }
  }
  v12 = &a3;
LABEL_12:
  *(_DWORD *)v8 = *v12;
  return v8;
}
// 10074200: using guessed type int __security_cookie;

//----- (1001E5F0) --------------------------------------------------------
int __fastcall sub_1001E5F0(int a1, char a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int v7; // edx@1
  int v8; // ebx@1
  int v9; // esi@1
  int v10; // ecx@3
  int v11; // eax@3
  int *v12; // eax@6
  char v14; // [sp+Fh] [bp-9h]@1
  int v15; // [sp+10h] [bp-8h]@1
  unsigned int v16; // [sp+14h] [bp-4h]@1
  int v17; // [sp+18h] [bp+0h]@1

  v16 = (unsigned int)&v17 ^ __security_cookie;
  v6 = a6;
  v9 = a3;
  v14 = a2;
  v7 = a5;
  v8 = a1;
  v15 = a3;
  if ( a3 == a4 )
  {
LABEL_5:
    if ( v7 != v6 )
    {
      if ( !v14 || (v12 = &a3, v9 != a4) )
        v12 = &v15;
      goto LABEL_11;
    }
  }
  else
  {
    while ( v7 != v6 )
    {
      v10 = v7;
      v11 = v9;
      ++v7;
      ++v9;
      a5 = v7;
      a3 = v9;
      if ( *(_BYTE *)v11 != *(_BYTE *)v10 )
      {
        *(_DWORD *)v8 = v15;
        return v8;
      }
      v6 = a6;
      if ( v9 == a4 )
        goto LABEL_5;
    }
  }
  v12 = &a3;
LABEL_11:
  *(_DWORD *)v8 = *v12;
  return v8;
}
// 10074200: using guessed type int __security_cookie;

//----- (1001E690) --------------------------------------------------------
void *__thiscall sub_1001E690(void *this, int a2, int a3, unsigned int a4, int a5, int a6, int a7, unsigned int a8)
{
  int v8; // edx@1
  int v9; // ecx@1
  void *v10; // ebx@1
  int v11; // edi@1
  int v12; // esi@1

  v8 = a8;
  v12 = a7;
  v11 = a3;
  v10 = this;
  v9 = a4;
  while ( v11 != a5 || v9 != a6 )
  {
    if ( (1 << v9) & *(_DWORD *)v11 )
      *(_DWORD *)v12 |= 1 << v8;
    else
      *(_DWORD *)v12 &= ~(1 << v8);
    v12 = a7;
    if ( a8 >= 0x1F )
    {
      v8 = 0;
      v12 = a7 + 4;
      a7 += 4;
    }
    else
    {
      v8 = a8 + 1;
    }
    v11 = a3;
    a8 = v8;
    if ( a4 >= 0x1F )
    {
      v9 = 0;
      v11 = a3 + 4;
      a4 = 0;
      a3 += 4;
    }
    else
    {
      v9 = a4++ + 1;
    }
  }
  *(_DWORD *)v10 = v12;
  *((_DWORD *)v10 + 1) = v8;
  return v10;
}

//----- (1001E710) --------------------------------------------------------
void *__thiscall sub_1001E710(void *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  void *v8; // ebx@1
  int v9; // edi@2
  int v10; // ecx@5
  int v11; // esi@7
  int v12; // edx@8

  v8 = this;
  while ( 1 )
  {
    v9 = a5;
    if ( a3 == a5 )
    {
      if ( a4 == a6 )
        break;
    }
    if ( a6 )
    {
      v10 = a6 - 1;
    }
    else
    {
      v9 = a5 - 4;
      v10 = 31;
      a5 -= 4;
    }
    v11 = a7;
    a6 = v10;
    if ( a8 )
    {
      v12 = a8 - 1;
    }
    else
    {
      v11 = a7 - 4;
      v12 = 31;
      a7 -= 4;
    }
    a8 = v12;
    if ( (1 << v10) & *(_DWORD *)v9 )
      *(_DWORD *)v11 |= 1 << v12;
    else
      *(_DWORD *)v11 &= ~(1 << v12);
  }
  *(_DWORD *)v8 = a7;
  *((_DWORD *)v8 + 1) = a8;
  return v8;
}

//----- (1001E800) --------------------------------------------------------
int __usercall sub_1001E800<eax>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>)
{
  int v4; // edx@1
  int v5; // esi@1
  int v6; // eax@2
  int v7; // ecx@2
  int v8; // eax@4
  int v9; // ecx@5
  int v10; // ecx@16

  v5 = a2;
  sub_1001F2A0(a1, a2 + 36, a3, a4);
  if ( *(_DWORD *)(v5 + 76) == 94 )
  {
    *(_DWORD *)(*(_DWORD *)(v5 + 40) + 8) ^= 1u;
    v6 = *(_DWORD *)v5;
    v7 = *(_DWORD *)(v5 + 8);
    if ( *(_DWORD *)v5 != v7 )
    {
      if ( *(_BYTE *)v6 == 92 )
      {
        v8 = v6 + 1;
        if ( v8 != v7 )
        {
          v9 = *(_DWORD *)(v5 + 80);
          if ( !(v9 & 8) && (*(_BYTE *)v8 == 40 || *(_BYTE *)v8 == 41)
            || !(v9 & 0x10) && (*(_BYTE *)v8 == 123 || *(_BYTE *)v8 == 125) )
            *(_DWORD *)v5 = v8;
        }
      }
      ++*(_DWORD *)v5;
    }
    sub_1001C5A0((void *)v5);
  }
  if ( *(_DWORD *)(v5 + 80) & 0x20000000 && *(_DWORD *)(v5 + 76) == 93 )
  {
    v10 = v5 + 36;
    if ( dword_100773CC <= 93 )
    {
      sub_1001FDE0(v4, v10, a3, a4, 93);
      sub_1001DA00((void *)v5);
      return loc_1001EF00(v5);
    }
    sub_1001FED0(v4, v10, a3, a4, 93);
    sub_1001DA00((void *)v5);
  }
  return loc_1001EF00(v5);
}
// 100773CC: using guessed type int dword_100773CC;

//----- (1001EB70) --------------------------------------------------------
int __usercall sub_1001EB70<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a4, 20);
  v5 = v4;
  if ( v4 )
  {
    *(_DWORD *)v4 = off_10068B14;
    *(_DWORD *)(v4 + 4) = 2;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  result = *(_DWORD *)(v6 + 4);
  *(_DWORD *)(result + 12) = v5;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 10068B14: using guessed type int (__stdcall *off_10068B14[2])(char);

//----- (1001EBD0) --------------------------------------------------------
int __usercall sub_1001EBD0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a4, 20);
  v5 = v4;
  if ( v4 )
  {
    *(_DWORD *)v4 = off_10068B14;
    *(_DWORD *)(v4 + 4) = 3;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  result = *(_DWORD *)(v6 + 4);
  *(_DWORD *)(result + 12) = v5;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 10068B14: using guessed type int (__stdcall *off_10068B14[2])(char);

//----- (1001EC30) --------------------------------------------------------
int __usercall sub_1001EC30<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a4, 20);
  v5 = v4;
  if ( v4 )
  {
    *(_DWORD *)v4 = off_10068B14;
    *(_DWORD *)(v4 + 4) = 4;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  result = *(_DWORD *)(v6 + 4);
  *(_DWORD *)(result + 12) = v5;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 10068B14: using guessed type int (__stdcall *off_10068B14[2])(char);

//----- (1001EC90) --------------------------------------------------------
int __userpurge sub_1001EC90<eax>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>, int a5)
{
  int v5; // eax@1
  int v6; // esi@1
  int v7; // eax@4
  int v8; // edi@5
  int v9; // ecx@6
  int v10; // eax@6
  int v11; // eax@6
  int v12; // edx@6
  int v13; // eax@7
  char v14; // bl@9
  unsigned int v15; // eax@13
  int v16; // esi@13
  int v17; // eax@14
  int v18; // edi@14
  int result; // eax@17
  int v20; // [sp+14h] [bp-10h]@6
  int v21; // [sp+20h] [bp-4h]@6

  v6 = a2;
  v5 = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(v5 + 4) != 6 || *(_BYTE *)(v5 + 8) & 4 )
    sub_1001F4E0(a1, a2, a3, a4);
  v7 = *(_DWORD *)(v6 + 8);
  if ( v7 & 0x100 )
  {
    v8 = *(_DWORD *)(v6 + 12);
    if ( !*(_DWORD *)(v8 + 4) )
    {
      v10 = sub_1001B150(v8, (int)&v20);
      v21 = 0;
      v11 = sub_10017B50(v12, a3, v8, v10);
      v21 = -1;
      v9 = v20;
      *(_DWORD *)(v8 + 4) = v11;
      if ( v9 )
      {
        v13 = (*(int (**)(void))(*(_DWORD *)v9 + 8))();
        if ( v13 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v13)(v13, 1);
      }
    }
    v14 = (*(int (__stdcall **)(int))(**(_DWORD **)(v8 + 4) + 16))(a5);
  }
  else
  {
    if ( v7 & 0x800 )
      v14 = sub_1001A460(*(_DWORD *)(v6 + 12), a3, a4, a5);
    else
      v14 = a5;
  }
  v16 = *(_DWORD *)(v6 + 4);
  v15 = *(_DWORD *)(v16 + 24);
  if ( *(_DWORD *)(v16 + 20) <= v15 )
  {
    v18 = v15 + 16;
    v17 = sub_10030C36(a1, a2, v14, v15 + 16, *(LPVOID *)(v16 + 28), v15 + 16);
    if ( !v17 )
      sub_10029530();
    *(_DWORD *)(v16 + 28) = v17;
    *(_DWORD *)(v16 + 20) = v18;
  }
  result = *(_DWORD *)(v16 + 24);
  *(_BYTE *)(*(_DWORD *)(v16 + 28) + result) = v14;
  ++*(_DWORD *)(v16 + 24);
  return result;
}

//----- (1001EDA0) --------------------------------------------------------
int __thiscall sub_1001EDA0(int this, int a2, int a3)
{
  char v4; // [sp+0h] [bp-24h]@1
  int v5; // [sp+10h] [bp-14h]@1
  char *v6; // [sp+14h] [bp-10h]@1
  int v7; // [sp+20h] [bp-4h]@1

  v6 = &v4;
  v7 = 0;
  v5 = this;
  return sub_1001FFE0(this, *(_DWORD *)this, a2, a3, this);
}

//----- (1001EE10) --------------------------------------------------------
void *__thiscall sub_1001EE10(void *this, int a2, int a3)
{
  void *result; // eax@1
  int i; // ecx@1

  result = this;
  for ( i = a2; i != a3; result = (char *)result + 4 )
  {
    if ( result )
      *(_DWORD *)result = *(_DWORD *)i;
    i += 4;
  }
  return result;
}

//----- (1001EE40) --------------------------------------------------------
char __thiscall sub_1001EE40(int this)
{
  return sub_1001F5C0(this, 10, 2147483647) != 2147483647;
}

//----- (1001EE60) --------------------------------------------------------
char __userpurge sub_1001EE60<al>(int a1<ecx>, char a2<bl>, char a3)
{
  int v3; // esi@1
  unsigned __int16 v4; // ax@2
  int v5; // edx@2
  int v6; // edi@2
  char result; // al@7

  v3 = a1;
  if ( *(_DWORD *)a1 != *(_DWORD *)(a1 + 8)
    && (v4 = sub_1001F9B0(*(void **)(a1 + 60), *(_DWORD *)a1, *(_DWORD *)a1 + 1, (*(_DWORD *)(a1 + 64) & 0x100) != 0),
        v6 = v4,
        v4) )
  {
    if ( a3 )
      sub_1001F2A0(v5, v3 + 36, a2, v4);
    sub_10020320(*(_DWORD *)(v3 + 40), v6, *(_DWORD *)(v3 + 48));
    if ( sub_1001A530(*(_DWORD *)(v3 + 60), a2, *(_BYTE *)(v3 + 72), 1) )
      *(_DWORD *)(*(_DWORD *)(v3 + 40) + 8) ^= 1u;
    sub_1001DA00((void *)v3);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001F1E0) --------------------------------------------------------
signed int __usercall sub_1001F1E0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>)
{
  unsigned int v3; // edx@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // edx@1
  int v8; // ecx@1
  int v9; // esi@3
  signed int result; // eax@5

  v5 = a2;
  ++*(_DWORD *)(v5 + 12);
  v6 = sub_1001C990(a1, a2 + 36, a2, a3, *(_DWORD *)(a2 + 12));
  sub_1001C750(v5);
  sub_1001C8F0(v5 + 36, v7, v6);
  sub_1001A620(v5 + 20, *(_DWORD *)(v5 + 12) + 1, v8);
  v3 = *(_DWORD *)(v6 + 20);
  v4 = *(_DWORD *)(v5 + 20);
  if ( (signed int)v3 < 0 && v3 )
    v9 = -4 - 4 * ((-1 - v3) >> 5) + v4;
  else
    v9 = v4 + 4 * (v3 >> 5);
  result = 1 << (v3 & 0x1F);
  *(_DWORD *)v9 |= result;
  return result;
}

//----- (1001F270) --------------------------------------------------------
int __userpurge sub_1001F270<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, char a4)
{
  int result; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // edx@1

  v5 = a2;
  v6 = sub_1001FCD0(a1, a2 + 36, a3, a4);
  sub_1001C750(v5);
  result = sub_1001C8F0(v5 + 36, v7, v6);
  *(_DWORD *)(v5 + 40) = v6;
  return result;
}

//----- (1001F2A0) --------------------------------------------------------
int __usercall sub_1001F2A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // edx@1
  int v5; // esi@1
  int v6; // eax@4
  int result; // eax@6

  v5 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a4, 44);
  if ( v4 )
  {
    *(_DWORD *)(v4 + 4) = 7;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    *(_DWORD *)v4 = off_10068B0C;
    *(_DWORD *)(v4 + 20) = 0;
    *(_DWORD *)(v4 + 24) = 0;
    *(_DWORD *)(v4 + 28) = 0;
    *(_DWORD *)(v4 + 32) = 0;
    *(_WORD *)(v4 + 36) = 0;
    *(_DWORD *)(v4 + 40) = 0;
  }
  else
  {
    v4 = 0;
  }
  *(_DWORD *)(v4 + 16) = *(_DWORD *)(v5 + 4);
  v6 = *(_DWORD *)(*(_DWORD *)(v5 + 4) + 12);
  if ( v6 )
  {
    *(_DWORD *)(v4 + 12) = v6;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v5 + 4) + 12) + 16) = v4;
  }
  result = *(_DWORD *)(v5 + 4);
  *(_DWORD *)(result + 12) = v4;
  *(_DWORD *)(v5 + 4) = v4;
  return result;
}
// 10068B0C: using guessed type int (__stdcall *off_10068B0C[4])(char);

//----- (1001F330) --------------------------------------------------------
int __userpurge sub_1001F330<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // eax@1
  int v6; // edx@1
  int v7; // esi@1
  int v8; // eax@4
  int result; // eax@6

  v7 = a2;
  v5 = sub_1002ADB1(a1, a2, a3, a4, 24);
  v6 = v5;
  if ( v5 )
  {
    *(_DWORD *)(v5 + 4) = 15;
    *(_DWORD *)(v5 + 8) = 0;
    *(_DWORD *)(v5 + 12) = 0;
    *(_DWORD *)(v5 + 16) = 0;
    *(_DWORD *)v5 = off_10068B14;
    *(_DWORD *)(v5 + 20) = a5;
  }
  else
  {
    v6 = 0;
  }
  *(_DWORD *)(v6 + 16) = *(_DWORD *)(v7 + 4);
  v8 = *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12);
  if ( v8 )
  {
    *(_DWORD *)(v6 + 12) = v8;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) + 16) = v6;
  }
  result = *(_DWORD *)(v7 + 4);
  *(_DWORD *)(result + 12) = v6;
  *(_DWORD *)(v7 + 4) = v6;
  return result;
}
// 10068B14: using guessed type int (__stdcall *off_10068B14[2])(char);

//----- (1001F3A0) --------------------------------------------------------
int __userpurge sub_1001F3A0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5, char a6)
{
  int v6; // eax@1
  int v7; // ebx@1
  int v8; // eax@4
  int v9; // edx@4
  int v10; // ecx@4
  int v11; // esi@4
  int v12; // eax@7
  int v13; // edi@7
  signed int v14; // eax@8
  int v15; // edx@8
  int v16; // eax@12
  int v17; // eax@14
  int v18; // ecx@14
  int result; // eax@17
  int v20; // [sp+10h] [bp-4h]@4

  v7 = a2;
  v6 = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(v6 + 4) == 6 )
  {
    if ( *(_DWORD *)(v6 + 24) != 1 )
    {
      --*(_DWORD *)(v6 + 24);
      sub_1001EC90(a1, a2, a2, a3, *(_BYTE *)(*(_DWORD *)(v6 + 28) + *(_DWORD *)(v6 + 24)));
    }
  }
  v20 = *(_DWORD *)(v7 + 4);
  v8 = sub_1002ADB1(a1, a2, v7, a3, 24);
  v11 = v8;
  if ( v8 )
  {
    *(_DWORD *)(v8 + 4) = 19;
    *(_DWORD *)(v8 + 8) = 0;
    *(_DWORD *)(v8 + 12) = 0;
    *(_DWORD *)(v8 + 16) = 0;
    *(_DWORD *)v8 = off_10068B14;
    *(_DWORD *)(v8 + 20) = 0;
  }
  else
  {
    v11 = 0;
  }
  v12 = sub_1002ADB1(v9, v10, v7, a3, 40);
  v13 = v12;
  if ( v12 )
  {
    *(_DWORD *)(v12 + 12) = 0;
    *(_DWORD *)(v12 + 16) = 0;
    *(_DWORD *)(v12 + 28) = 0;
    v15 = *(_DWORD *)(*(_DWORD *)v7 + 24);
    *(_DWORD *)(*(_DWORD *)v7 + 24) = v15 + 1;
    v14 = 0;
    if ( a6 )
      v14 = 2;
    *(_DWORD *)(v13 + 8) = v14;
    *(_DWORD *)(v13 + 20) = a4;
    *(_DWORD *)(v13 + 4) = 18;
    *(_DWORD *)(v13 + 12) = 0;
    *(_DWORD *)(v13 + 16) = 0;
    *(_DWORD *)v13 = off_10068B14;
    *(_DWORD *)(v13 + 24) = a5;
    *(_DWORD *)(v13 + 28) = v11;
    *(_DWORD *)(v13 + 32) = v15;
    *(_DWORD *)(v13 + 36) = -1;
  }
  else
  {
    v13 = 0;
  }
  *(_DWORD *)(v11 + 20) = v13;
  *(_DWORD *)(v11 + 16) = *(_DWORD *)(v7 + 4);
  v16 = *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12);
  if ( v16 )
  {
    *(_DWORD *)(v11 + 12) = v16;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) + 16) = v11;
  }
  v18 = v20;
  *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) = v11;
  *(_DWORD *)(v7 + 4) = v11;
  v17 = *(_DWORD *)(v20 + 4);
  if ( v17 == 9 || v17 == 14 )
    v18 = *(_DWORD *)(v20 + 20);
  *(_DWORD *)(*(_DWORD *)(v18 + 16) + 12) = v13;
  result = *(_DWORD *)(v18 + 16);
  *(_DWORD *)(v13 + 16) = result;
  *(_DWORD *)(v18 + 16) = v13;
  *(_DWORD *)(v13 + 12) = v18;
  return result;
}
// 10068B14: using guessed type int (__stdcall *off_10068B14[2])(char);

//----- (1001F4E0) --------------------------------------------------------
int __usercall sub_1001F4E0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a4, 32);
  v5 = v4;
  if ( v4 )
  {
    *(_DWORD *)(v4 + 4) = 6;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    *(_DWORD *)v4 = off_10068B08;
    *(_DWORD *)(v4 + 20) = 0;
    *(_DWORD *)(v4 + 24) = 0;
    *(_DWORD *)(v4 + 28) = 0;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  result = *(_DWORD *)(v6 + 4);
  *(_DWORD *)(result + 12) = v5;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 10068B08: using guessed type int (__stdcall *off_10068B08[5])(char);

//----- (1001F560) --------------------------------------------------------
void *__thiscall sub_1001F560(void *this, int a2, int a3)
{
  void *result; // eax@1
  int i; // ecx@1

  result = this;
  for ( i = a2; i != a3; result = (char *)result + 8 )
  {
    if ( result )
    {
      *(_DWORD *)result = *(_DWORD *)i;
      *((_DWORD *)result + 1) = *(_DWORD *)(i + 4);
    }
    i += 8;
  }
  return result;
}

//----- (1001F590) --------------------------------------------------------
void *__userpurge sub_1001F590<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_100309A2(a2, *(LPVOID *)(a1 + 28));
  *(_DWORD *)v3 = off_10068B14;
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10068B14: using guessed type int (__stdcall *off_10068B14[2])(char);

//----- (1001F5C0) --------------------------------------------------------
int __thiscall sub_1001F5C0(int this, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@1
  char v5; // cl@2
  int v6; // ecx@7
  int v7; // eax@13
  int v8; // ecx@13
  int v9; // eax@13
  int v10; // eax@15
  int v11; // ecx@16

  v3 = a3;
  v4 = this;
  *(_DWORD *)(this + 68) = 0;
  if ( a3 )
  {
    while ( 1 )
    {
      v5 = *(_BYTE *)(v4 + 72);
      if ( a2 == 8 )
      {
        if ( (unsigned __int8)(v5 - 48) > 7u )
          return v3;
      }
      else
      {
        if ( v5 < 48 || v5 > 57 )
        {
          if ( a2 != 16 )
            return v3;
          if ( (unsigned __int8)(v5 - 97) > 5u )
          {
            if ( (unsigned __int8)(v5 - 65) > 5u )
              return v3;
            v6 = v5 - 55;
          }
          else
          {
            v6 = v5 - 87;
          }
          goto LABEL_12;
        }
      }
      v6 = v5 - 48;
LABEL_12:
      if ( v6 != -1 )
      {
        v9 = v6 + a2 * *(_DWORD *)(v4 + 68);
        v8 = *(_DWORD *)(v4 + 8);
        *(_DWORD *)(v4 + 68) = v9;
        v7 = *(_DWORD *)v4;
        --v3;
        if ( *(_DWORD *)v4 != v8 )
        {
          if ( *(_BYTE *)v7 == 92 )
          {
            v10 = v7 + 1;
            if ( v10 != v8 )
            {
              v11 = *(_DWORD *)(v4 + 80);
              if ( !(v11 & 8) && (*(_BYTE *)v10 == 40 || *(_BYTE *)v10 == 41)
                || !(v11 & 0x10) && (*(_BYTE *)v10 == 123 || *(_BYTE *)v10 == 125) )
                *(_DWORD *)v4 = v10;
            }
          }
          ++*(_DWORD *)v4;
        }
        sub_1001C5A0((void *)v4);
        if ( v3 )
          continue;
      }
      return v3;
    }
  }
  return 0;
}

//----- (1001F6A0) --------------------------------------------------------
int __thiscall sub_1001F6A0(int this)
{
  int v1; // eax@1
  int v2; // esi@1
  int v3; // eax@2
  int v4; // ecx@2
  int v5; // eax@4
  int v6; // ecx@5
  int v7; // eax@13
  int v8; // ecx@13
  int result; // eax@14
  int v10; // edi@23

  v2 = this;
  v1 = *(_DWORD *)(this + 76);
  switch ( v1 )
  {
    case -4294967204:
      v3 = *(_DWORD *)this;
      v4 = *(_DWORD *)(this + 8);
      if ( *(_DWORD *)v2 != v4 )
      {
        if ( *(_BYTE *)v3 == 92 )
        {
          v5 = v3 + 1;
          if ( v5 != v4 )
          {
            v6 = *(_DWORD *)(v2 + 80);
            if ( !(v6 & 8) && (*(_BYTE *)v5 == 40 || *(_BYTE *)v5 == 41)
              || !(v6 & 0x10) && (*(_BYTE *)v5 == 123 || *(_BYTE *)v5 == 125) )
              *(_DWORD *)v2 = v5;
          }
        }
        ++*(_DWORD *)v2;
      }
      sub_1001C5A0((void *)v2);
      v7 = *(_DWORD *)(v2 + 80);
      if ( v7 & 0x200000 )
        return loc_100202A0(v2, v8);
      if ( v7 & 0x10000 && sub_1001F930(v2, *(_BYTE *)(v2 + 72)) )
        goto LABEL_20;
      if ( *(_DWORD *)(v2 + 80) & 0x8000 && *(_BYTE *)(v2 + 72) == 97 )
      {
        *(_DWORD *)(v2 + 68) = 7;
LABEL_20:
        sub_1001DA00((void *)v2);
        return 1;
      }
      *(_DWORD *)(v2 + 68) = 92;
      result = 1;
      break;
    case -4294967205:
      sub_1001DA00((void *)this);
      v10 = *(_DWORD *)(v2 + 76);
      if ( v10 == 58 || v10 == 61 || v10 == 46 )
      {
        sub_1001DA00((void *)v2);
        loc_10020130(v2, v10);
        result = 2;
      }
      else
      {
        *(_DWORD *)(v2 + 68) = 91;
        result = 1;
      }
      break;
    case -4294967203:
    case -1:
      result = 0;
      break;
    default:
      *(_DWORD *)(this + 68) = *(_BYTE *)(this + 72);
      sub_1001DA00((void *)this);
      result = 1;
      break;
  }
  return result;
}

//----- (1001F930) --------------------------------------------------------
char __thiscall sub_1001F930(int this, char a2)
{
  char result; // al@2

  switch ( a2 )
  {
    case 98:
      *(_DWORD *)(this + 68) = 8;
      result = 1;
      break;
    case 102:
      *(_DWORD *)(this + 68) = 12;
      result = 1;
      break;
    case 110:
      *(_DWORD *)(this + 68) = 10;
      result = 1;
      break;
    case 114:
      *(_DWORD *)(this + 68) = 13;
      result = 1;
      break;
    case 116:
      *(_DWORD *)(this + 68) = 9;
      result = 1;
      break;
    case 118:
      *(_DWORD *)(this + 68) = 11;
      result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (1001F9B0) --------------------------------------------------------
int __thiscall sub_1001F9B0(void *this, int a2, int a3, char a4)
{
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // eax@2
  char **v7; // edx@2
  int v8; // eax@3
  char *v9; // ebx@3
  int v10; // esi@3
  int v11; // eax@5
  char v12; // al@5
  int result; // eax@10
  int v14; // ecx@10
  int v15; // [sp+0h] [bp-Ch]@2
  int v16; // [sp+4h] [bp-8h]@3
  int v17; // [sp+8h] [bp-4h]@1

  v4 = (int)this;
  v5 = 0;
  v17 = 0;
  if ( off_10068B20 )
  {
    v15 = v4;
    v6 = 0;
    v7 = &off_10068B20;
    do
    {
      v9 = *v7;
      v10 = a2;
      v8 = (int)&(*v7)[*(int *)((char *)&dword_10068B24 + v6)];
      v16 = v8;
      if ( a2 == a3 )
      {
LABEL_8:
        if ( v9 == (char *)v8 )
          break;
      }
      else
      {
        while ( v9 != (char *)v8 )
        {
          LOBYTE(v5) = *v9;
          v11 = *(_BYTE *)v10++;
          v12 = sub_1001D8D0((int)&v15, (char)v9++, v11, v5);
          if ( !v12 )
            goto LABEL_17;
          v8 = v16;
          if ( v10 == a3 )
            goto LABEL_7;
        }
        if ( v10 == a3 )
        {
LABEL_7:
          v5 = v17;
          goto LABEL_8;
        }
LABEL_17:
        v5 = v17;
      }
      ++v5;
      v17 = v5;
      v6 = 12 * v5;
      v7 = &(&off_10068B20)[12 * v5];
    }
    while ( (&off_10068B20)[12 * v5] );
  }
  v14 = 3 * v5;
  result = 0;
  if ( (&off_10068B20)[4 * v14] )
    result = (unsigned __int16)word_10068B28[2 * v14];
  if ( a4 )
  {
    if ( result & 3 )
      result |= 3u;
  }
  return result;
}
// 10068B20: using guessed type char *off_10068B20;
// 10068B24: using guessed type int dword_10068B24;
// 10068B28: using guessed type __int16 word_10068B28[];

//----- (1001FA70) --------------------------------------------------------
int __userpurge sub_1001FA70<eax>(int a1<edx>, int a2<ecx>, __int16 a3<bx>, int a4, int a5)
{
  int v5; // edi@1
  int v6; // esi@2
  int v7; // ecx@3
  int v8; // eax@3
  int v9; // eax@3
  int v10; // edx@3
  int v11; // eax@4
  int v12; // esi@6
  char v13; // al@6
  int v14; // ecx@7
  int v15; // eax@7
  int v16; // eax@7
  int v17; // edx@7
  int v18; // eax@8
  int v19; // esi@12
  int v20; // eax@14
  int result; // eax@25
  int v23; // eax@31
  unsigned int v24; // eax@35
  int v25; // edi@35
  int v26; // eax@36
  int v27; // ecx@39
  unsigned int v28; // edi@39
  int v29; // esi@39
  int v30; // eax@40
  int v31; // edi@40
  int v32; // [sp+10h] [bp-14h]@7
  int v33; // [sp+14h] [bp-10h]@3
  int v34; // [sp+20h] [bp-4h]@3
  int v35; // [sp+2Ch] [bp+8h]@36
  int v36; // [sp+30h] [bp+Ch]@14

  v5 = a2;
  if ( *(_DWORD *)(a2 + 8) & 0x100 )
  {
    v6 = *(_DWORD *)(a2 + 12);
    if ( !*(_DWORD *)(v6 + 4) )
    {
      v8 = sub_1001B150(v6, (int)&v33);
      v34 = 0;
      v9 = sub_10017B50(v10, a3, v5, v8);
      v34 = -1;
      v7 = v33;
      *(_DWORD *)(v6 + 4) = v9;
      if ( v7 )
      {
        v11 = (*(int (**)(void))(*(_DWORD *)v7 + 8))();
        if ( v11 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v11)(v11, 1);
      }
    }
    v13 = (*(int (__stdcall **)(int))(**(_DWORD **)(v6 + 4) + 16))(a4);
    v12 = *(_DWORD *)(v5 + 12);
    LOBYTE(a3) = v13;
    LOBYTE(a4) = v13;
    if ( !*(_DWORD *)(v12 + 4) )
    {
      v15 = sub_1001B150(v12, (int)&v32);
      v34 = 1;
      v16 = sub_10017B50(v17, a3, v5, v15);
      v34 = -1;
      v14 = v32;
      *(_DWORD *)(v12 + 4) = v16;
      if ( v14 )
      {
        v18 = (*(int (**)(void))(*(_DWORD *)v14 + 8))();
        if ( v18 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v18)(v18, 1);
      }
    }
    HIBYTE(a3) = (*(int (__stdcall **)(int))(**(_DWORD **)(v12 + 4) + 16))(a5);
  }
  else
  {
    LOBYTE(a3) = a4;
    HIBYTE(a3) = a5;
  }
  v19 = *(_DWORD *)(v5 + 4);
  if ( (_BYTE)a3 < 0 )
    goto LABEL_46;
  if ( (_BYTE)a3 <= HIBYTE(a3) )
  {
    v20 = SHIBYTE(a3);
    v36 = SHIBYTE(a3);
    do
    {
      if ( v20 >= *(_DWORD *)(v5 + 16) )
        break;
      if ( !*(_DWORD *)(v19 + 24) )
      {
        _EAX = sub_1002ADB1(a1, a2, a3, v5, 32);
        if ( _EAX )
        {
          __asm
          {
            xorps   xmm0, xmm0
            movq    qword ptr [eax], xmm0
            movq    qword ptr [eax+8], xmm0
            movq    qword ptr [eax+10h], xmm0
            movq    qword ptr [eax+18h], xmm0
          }
        }
        else
        {
          _EAX = 0;
        }
        *(_DWORD *)(v19 + 24) = _EAX;
      }
      a1 = ((unsigned int)(char)a3 >> 3) + *(_DWORD *)(v19 + 24);
      a2 = a3 & 7;
      *(_BYTE *)a1 |= 1 << a2;
      if ( (_BYTE)a3 == HIBYTE(a3) )
        break;
      v20 = v36;
      LOBYTE(a3) = a3 + 1;
    }
    while ( (_BYTE)a3 <= HIBYTE(a3) );
    LOBYTE(a4) = a3;
  }
  if ( (_BYTE)a3 < 0 || (result = (char)a3, a2 = SHIBYTE(a3) - (char)a3, a2 >= *(_DWORD *)(v5 + 20)) )
  {
LABEL_46:
    if ( !*(_DWORD *)(v19 + 32) )
    {
      v23 = sub_1002ADB1(a1, a2, a3, v5, 12);
      if ( v23 )
      {
        *(_DWORD *)v23 = 0;
        *(_DWORD *)(v23 + 4) = 0;
        *(_DWORD *)(v23 + 8) = 0;
      }
      else
      {
        v23 = 0;
      }
      *(_DWORD *)(v19 + 32) = v23;
    }
    v25 = *(_DWORD *)(v19 + 32);
    v24 = *(_DWORD *)(v25 + 4);
    if ( *(_DWORD *)v25 <= v24 )
    {
      v35 = v24 + 16;
      v26 = sub_10030C36(a1, a2, a3, v25, *(LPVOID *)(v25 + 8), v24 + 16);
      if ( !v26 )
        sub_10029530();
      *(_DWORD *)(v25 + 8) = v26;
      *(_DWORD *)v25 = v35;
    }
    v27 = *(_DWORD *)(v25 + 8);
    *(_BYTE *)(v27 + *(_DWORD *)(v25 + 4)++) = a3;
    v29 = *(_DWORD *)(v19 + 32);
    v28 = *(_DWORD *)(v29 + 4);
    if ( *(_DWORD *)v29 <= v28 )
    {
      v31 = v28 + 16;
      v30 = sub_10030C36(a1, v27, a3, v31, *(LPVOID *)(v29 + 8), v31);
      if ( !v30 )
        sub_10029530();
      *(_DWORD *)(v29 + 8) = v30;
      *(_DWORD *)v29 = v31;
    }
    result = *(_DWORD *)(v29 + 4);
    *(_BYTE *)(*(_DWORD *)(v29 + 8) + result) = HIBYTE(a3);
    ++*(_DWORD *)(v29 + 4);
  }
  else
  {
    for ( ; (_BYTE)a3 <= HIBYTE(a3); LOBYTE(a4) = a3 )
    {
      result = sub_1001FED0(a1, v5, a3, v5, a4);
      if ( (_BYTE)a3 == HIBYTE(a3) )
        break;
      LOBYTE(a3) = a3 + 1;
    }
  }
  return result;
}

//----- (1001FCD0) --------------------------------------------------------
int __userpurge sub_1001FCD0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, char a4)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // eax@4
  int v10; // edx@4
  int v11; // eax@7
  int result; // eax@9
  char v13; // [sp+0h] [bp-20h]@1
  char *v14; // [sp+10h] [bp-10h]@1
  int v15; // [sp+1Ch] [bp-4h]@4

  v14 = &v13;
  v7 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a2, 24);
  v8 = v4;
  if ( v4 )
  {
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    *(_DWORD *)v4 = &off_10068B18;
    *(_DWORD *)(v4 + 20) = 0;
    *(_DWORD *)(v4 + 4) = (a4 != 0) + 10;
  }
  else
  {
    v8 = 0;
  }
  v15 = 0;
  v9 = sub_1002ADB1(v5, v6, a3, v7, 20);
  v10 = v9;
  if ( v9 )
  {
    *(_DWORD *)v9 = off_10068B14;
    *(_DWORD *)(v9 + 4) = 1;
    *(_DWORD *)(v9 + 8) = 0;
    *(_DWORD *)(v9 + 12) = 0;
    *(_DWORD *)(v9 + 16) = 0;
  }
  else
  {
    v10 = 0;
  }
  *(_DWORD *)(v8 + 16) = *(_DWORD *)(v7 + 4);
  v11 = *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12);
  if ( v11 )
  {
    *(_DWORD *)(v8 + 12) = v11;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) + 16) = v8;
  }
  result = v8;
  *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) = v8;
  *(_DWORD *)(v8 + 20) = v10;
  *(_DWORD *)(v10 + 16) = v8;
  *(_DWORD *)(v7 + 4) = v10;
  return result;
}
// 10068B14: using guessed type int (__stdcall *off_10068B14[2])(char);
// 10068B18: using guessed type int (__stdcall *off_10068B18)(char);

//----- (1001FDE0) --------------------------------------------------------
char __userpurge sub_1001FDE0<al>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>, int a5)
{
  int v5; // esi@1
  int v6; // ecx@3
  int v7; // eax@3
  int v8; // eax@3
  int v9; // edx@3
  int v10; // eax@4
  char v11; // bl@6
  int v12; // esi@8
  char result; // al@13
  unsigned int v15; // edx@13
  int v16; // [sp+10h] [bp-10h]@3
  int v17; // [sp+1Ch] [bp-4h]@3

  v5 = a2;
  if ( *(_DWORD *)(a2 + 8) & 0x100 )
  {
    a4 = *(_DWORD *)(a2 + 12);
    if ( !*(_DWORD *)(a4 + 4) )
    {
      v7 = sub_1001B150(a4, (int)&v16);
      v17 = 0;
      v8 = sub_10017B50(v9, a3, a4, v7);
      v17 = -1;
      v6 = v16;
      *(_DWORD *)(a4 + 4) = v8;
      if ( v6 )
      {
        v10 = (*(int (**)(void))(*(_DWORD *)v6 + 8))();
        if ( v10 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v10)(v10, 1);
      }
    }
    v11 = (*(int (__stdcall **)(int))(**(_DWORD **)(a4 + 4) + 16))(a5);
  }
  else
  {
    v11 = a5;
  }
  v12 = *(_DWORD *)(v5 + 4);
  if ( !*(_DWORD *)(v12 + 24) )
  {
    _EAX = sub_1002ADB1(a1, a2, v11, a4, 32);
    if ( _EAX )
    {
      __asm
      {
        xorps   xmm0, xmm0
        movq    qword ptr [eax], xmm0
        movq    qword ptr [eax+8], xmm0
        movq    qword ptr [eax+10h], xmm0
        movq    qword ptr [eax+18h], xmm0
      }
    }
    else
    {
      _EAX = 0;
    }
    *(_DWORD *)(v12 + 24) = _EAX;
  }
  v15 = ((unsigned int)v11 >> 3) + *(_DWORD *)(v12 + 24);
  result = 1 << (v11 & 7);
  *(_BYTE *)v15 |= result;
  return result;
}

//----- (1001FED0) --------------------------------------------------------
int __userpurge sub_1001FED0<eax>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>, int a5)
{
  int v5; // esi@1
  int v6; // ecx@3
  int v7; // eax@3
  int v8; // eax@3
  int v9; // edx@3
  int v10; // eax@4
  char v11; // bl@6
  int v12; // esi@8
  int v13; // eax@9
  unsigned int v14; // eax@13
  int v15; // esi@13
  int v16; // eax@14
  int v17; // edi@14
  int result; // eax@17
  int v19; // [sp+10h] [bp-10h]@3
  int v20; // [sp+1Ch] [bp-4h]@3

  v5 = a2;
  if ( *(_DWORD *)(a2 + 8) & 0x100 )
  {
    a4 = *(_DWORD *)(a2 + 12);
    if ( !*(_DWORD *)(a4 + 4) )
    {
      v7 = sub_1001B150(a4, (int)&v19);
      v20 = 0;
      v8 = sub_10017B50(v9, a3, a4, v7);
      v20 = -1;
      v6 = v19;
      *(_DWORD *)(a4 + 4) = v8;
      if ( v6 )
      {
        v10 = (*(int (**)(void))(*(_DWORD *)v6 + 8))();
        if ( v10 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v10)(v10, 1);
      }
    }
    v11 = (*(int (__stdcall **)(int))(**(_DWORD **)(a4 + 4) + 16))(a5);
  }
  else
  {
    v11 = a5;
  }
  v12 = *(_DWORD *)(v5 + 4);
  if ( !*(_DWORD *)(v12 + 28) )
  {
    v13 = sub_1002ADB1(a1, a2, v11, a4, 12);
    if ( v13 )
    {
      *(_DWORD *)v13 = 0;
      *(_DWORD *)(v13 + 4) = 0;
      *(_DWORD *)(v13 + 8) = 0;
    }
    else
    {
      v13 = 0;
    }
    *(_DWORD *)(v12 + 28) = v13;
  }
  v15 = *(_DWORD *)(v12 + 28);
  v14 = *(_DWORD *)(v15 + 4);
  if ( *(_DWORD *)v15 <= v14 )
  {
    v17 = v14 + 16;
    v16 = sub_10030C36(a1, a2, v11, v14 + 16, *(LPVOID *)(v15 + 8), v14 + 16);
    if ( !v16 )
      sub_10029530();
    *(_DWORD *)(v15 + 8) = v16;
    *(_DWORD *)v15 = v17;
  }
  result = *(_DWORD *)(v15 + 4);
  *(_BYTE *)(*(_DWORD *)(v15 + 8) + result) = v11;
  ++*(_DWORD *)(v15 + 4);
  return result;
}

//----- (1001FFE0) --------------------------------------------------------
int __thiscall sub_1001FFE0(int this, int a2, int a3, int a4, int a5)
{
  int result; // eax@1
  int v6; // ebx@1
  int v7; // esi@1
  void *v8; // ecx@2
  char v9; // cf@2
  const void *v10; // edx@3
  int v11; // edx@4
  int v12; // ecx@4
  int v13; // ecx@4
  unsigned int v14; // edi@4
  int v15; // edi@5
  int v16; // ecx@9
  int v17; // esi@12
  int v18; // esi@12
  void *v19; // eax@12
  void *v20; // eax@12
  int v21; // edx@15
  int v22; // [sp+8h] [bp-Ch]@9

  result = a4;
  v7 = a4 - a3;
  v6 = this;
  if ( a4 != a3 )
  {
    v9 = *(_DWORD *)(this + 8) - *(_DWORD *)(this + 4) < (unsigned int)v7;
    v8 = *(void **)(this + 4);
    if ( v9 )
    {
      v10 = *(const void **)v6;
      if ( *(_DWORD *)v6 - (_DWORD)v8 - 1 < (unsigned int)v7 )
      {
        sub_10029585((int)"vector<T> too long");
      }
      else
      {
        v13 = v8 - v10;
        v14 = *(_DWORD *)(v6 + 8) - (_DWORD)v10;
        v11 = v14 >> 1;
        v12 = v7 + v13;
        if ( -1 - (v14 >> 1) >= v14 )
          v15 = v11 + v14;
        else
          v15 = 0;
        if ( v15 < (unsigned int)v12 )
          v15 = v12;
        v16 = 0;
        v22 = 0;
        if ( !v15 || (unsigned int)v15 <= 0xFFFFFFFF && (v16 = sub_1002ADB1(v11, 0, v6, v15, v15), v22 = v16, v16) )
        {
          v18 = a2 - *(_DWORD *)v6;
          v19 = sub_1002A4B0((void *)v16, *(const void **)v6, a2 - *(_DWORD *)v6);
          v20 = sub_10020740((char *)v19 + v18, a3, a4);
          sub_1002A4B0(v20, (const void *)a2, *(_DWORD *)(v6 + 4) - a2);
          v17 = *(_DWORD *)(v6 + 4) - *(_DWORD *)v6 + a4 - a3;
          if ( *(_DWORD *)v6 )
            sub_1002A4AA(*(LPVOID *)v6);
          *(_DWORD *)v6 = v22;
          *(_DWORD *)(v6 + 8) = v22 + v15;
          result = v22 + v17;
          *(_DWORD *)(v6 + 4) = v22 + v17;
          return result;
        }
      }
      sub_10029530();
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(loc_10020130);
    }
    sub_10020740(v8, a3, a4);
    v21 = *(_DWORD *)(v6 + 4);
    result = v21 + v7;
    if ( a2 != v21 )
    {
      if ( v21 != result )
        result = sub_10020770(a2, v21, v21 + v7);
    }
    *(_DWORD *)(v6 + 4) += v7;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10020320) --------------------------------------------------------
char __stdcall sub_10020320(int a1, int a2, int a3)
{
  unsigned int v3; // esi@1
  char result; // al@2
  int v5; // edx@2
  int v6; // ecx@2

  v3 = 0;
  do
  {
    result = sub_1001A530(a3, a3, v3, a2);
    if ( result )
    {
      if ( !*(_DWORD *)(a1 + 24) )
      {
        _EAX = sub_1002ADB1(v5, v6, a3, a1, 32);
        if ( _EAX )
        {
          __asm
          {
            xorps   xmm0, xmm0
            movq    qword ptr [eax], xmm0
            movq    qword ptr [eax+8], xmm0
            movq    qword ptr [eax+10h], xmm0
            movq    qword ptr [eax+18h], xmm0
          }
        }
        else
        {
          _EAX = 0;
        }
        *(_DWORD *)(a1 + 24) = _EAX;
      }
      result = 1 << (v3 & 7);
      *(_BYTE *)(*(_DWORD *)(a1 + 24) + (v3 >> 3)) |= result;
    }
    ++v3;
  }
  while ( (signed int)v3 < 256 );
  return result;
}

//----- (100203A0) --------------------------------------------------------
char __thiscall sub_100203A0(int this, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // esi@1
  int v6; // eax@1
  void *v7; // ecx@1
  int v8; // eax@2
  int v9; // ecx@2
  void *v10; // ecx@2
  int *v11; // esi@2
  char v12; // cf@4
  int v13; // edx@6
  char v14; // cf@9
  char v15; // cf@11
  unsigned __int8 v16; // cf@13
  unsigned __int8 v17; // al@19
  int v18; // eax@20
  char v19; // zf@22
  bool v20; // eax@25
  char result; // al@28
  int v22; // edi@31
  void *v24; // [sp+10h] [bp-58h]@2
  unsigned int v25; // [sp+24h] [bp-44h]@28
  int v26; // [sp+28h] [bp-40h]@1
  int v27; // [sp+2Ch] [bp-3Ch]@4
  int v28; // [sp+30h] [bp-38h]@1
  char v29; // [sp+37h] [bp-31h]@28
  void *v30; // [sp+38h] [bp-30h]@1
  unsigned int v31; // [sp+48h] [bp-20h]@6
  unsigned int v32; // [sp+4Ch] [bp-1Ch]@2
  char v33; // [sp+53h] [bp-15h]@2
  unsigned int v34; // [sp+54h] [bp-14h]@1
  int v35; // [sp+64h] [bp-4h]@1
  int v36; // [sp+68h] [bp+0h]@1

  v34 = (unsigned int)&v36 ^ __security_cookie;
  v5 = this;
  v26 = this;
  v6 = *(_DWORD *)(this + 4);
  v7 = *(void **)(this + 12);
  v28 = v6;
  sub_1001D600(v7, (int)&v30, a2, a3);
  v35 = 0;
  v4 = 0;
  do
  {
    v10 = *(void **)(v5 + 12);
    v33 = v4;
    v8 = sub_100205B0(v10, (int)&v24, (int)&v33, (int)&v34);
    v9 = *(_DWORD *)(v8 + 16);
    v11 = (int *)&v30;
    if ( v32 >= 0x10 )
      v11 = (int *)v30;
    v12 = *(_DWORD *)(v8 + 20) < 0x10u;
    v27 = *(_DWORD *)(v8 + 16);
    if ( !v12 )
      v8 = *(_DWORD *)v8;
    v13 = v31;
    if ( v9 < v31 )
      v13 = v9;
    if ( !v13 )
      goto LABEL_24;
    v14 = (unsigned int)v13 < 4;
    v13 -= 4;
    if ( v14 )
    {
LABEL_12:
      if ( v13 == -4 )
        goto LABEL_21;
    }
    else
    {
      while ( 1 )
      {
        v9 = *(_DWORD *)v8;
        if ( *(_DWORD *)v8 != *v11 )
          break;
        v8 += 4;
        ++v11;
        v15 = (unsigned int)v13 < 4;
        v13 -= 4;
        if ( v15 )
          goto LABEL_12;
      }
    }
    LOBYTE(v9) = *(_BYTE *)v8;
    v16 = *(_BYTE *)v8 < *(_BYTE *)v11;
    if ( *(_BYTE *)v8 == *(_BYTE *)v11 )
    {
      if ( v13 == -3
        || (LOBYTE(v9) = *(_BYTE *)(v8 + 1), v16 = (_BYTE)v9 < *((_BYTE *)v11 + 1), (_BYTE)v9 == *((_BYTE *)v11 + 1))
        && (v13 == -2
         || (LOBYTE(v9) = *(_BYTE *)(v8 + 2), v16 = (_BYTE)v9 < *((_BYTE *)v11 + 2), (_BYTE)v9 == *((_BYTE *)v11 + 2))
         && (v13 == -1 || (v17 = *(_BYTE *)(v8 + 3), v16 = v17 < *((_BYTE *)v11 + 3), v17 == *((_BYTE *)v11 + 3)))) )
      {
LABEL_21:
        v18 = 0;
        goto LABEL_22;
      }
    }
    v18 = -v16 | 1;
LABEL_22:
    v19 = v18 == 0;
    if ( v18 )
      goto LABEL_28;
    v9 = v27;
LABEL_24:
    if ( v9 >= v31 )
      v20 = v9 != v31;
    else
      v20 = -1;
    v19 = v20 == 0;
LABEL_28:
    result = v19;
    v29 = v19;
    if ( v25 >= 0x10 )
    {
      sub_1002A4AA(v24);
      result = v29;
    }
    if ( result )
    {
      v22 = v28;
      if ( !*(_DWORD *)(v28 + 24) )
      {
        _EAX = sub_1002ADB1(v13, v9, v4, v28, 32);
        if ( _EAX )
        {
          __asm
          {
            xorps   xmm0, xmm0
            movq    qword ptr [eax], xmm0
            movq    qword ptr [eax+8], xmm0
            movq    qword ptr [eax+10h], xmm0
            movq    qword ptr [eax+18h], xmm0
          }
        }
        else
        {
          _EAX = 0;
        }
        *(_DWORD *)(v22 + 24) = _EAX;
      }
      result = 1 << (v4 & 7);
      *(_BYTE *)(*(_DWORD *)(v22 + 24) + ((unsigned int)v4 >> 3)) |= result;
    }
    v5 = v26;
    ++v4;
  }
  while ( v4 < 256 );
  if ( v32 >= 0x10 )
    result = sub_1002A4AA(v30);
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10020540) --------------------------------------------------------
int __fastcall sub_10020540(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // ebx@1
  int v7; // esi@1
  int v8; // eax@2
  int v9; // eax@6

  v7 = a6;
  v6 = *(_DWORD *)a6;
  if ( !*(_DWORD *)a6 )
    goto LABEL_13;
  do
  {
    v8 = *(_DWORD *)v7;
    if ( (unsigned int)a5 >= **(_DWORD **)v7 )
      break;
    v7 = v8 + 16;
  }
  while ( *(_DWORD *)(v8 + 16) );
  v6 = *(_DWORD *)v7;
  if ( !*(_DWORD *)v7 || a5 != *(_DWORD *)v6 )
  {
LABEL_13:
    v9 = sub_1002ADB1(a2, a1, v6, a5, 20);
    if ( v9 )
    {
      *(_DWORD *)v9 = a5;
      *(_DWORD *)(v9 + 4) = 0;
      *(_DWORD *)(v9 + 8) = 0;
      *(_DWORD *)(v9 + 12) = 0;
    }
    else
    {
      v9 = 0;
    }
    *(_DWORD *)v7 = v9;
    *(_DWORD *)(v9 + 16) = v6;
  }
  return loc_10020840(*(_DWORD *)v7 + 4, a3, a4);
}

//----- (100205B0) --------------------------------------------------------
int __thiscall sub_100205B0(void *this, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@2
  int v6; // ecx@3
  int v7; // eax@3
  int v8; // eax@3
  int v9; // edx@3
  int v10; // eax@4
  int v11; // ecx@7
  int v12; // eax@7
  int v13; // eax@7
  int v14; // edx@7
  int v15; // eax@8
  int v16; // ebx@10
  void *v18; // [sp+14h] [bp-38h]@10
  unsigned int v19; // [sp+28h] [bp-24h]@14
  int v20; // [sp+2Ch] [bp-20h]@2
  int v21; // [sp+30h] [bp-1Ch]@2
  int v22; // [sp+34h] [bp-18h]@2
  int v23; // [sp+38h] [bp-14h]@1
  int v24; // [sp+48h] [bp-4h]@1
  int v25; // [sp+58h] [bp+Ch]@2

  v4 = (int)this;
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  v24 = 0;
  v23 = 1;
  if ( a3 != a4 )
  {
    v20 = 0;
    v21 = 0;
    v22 = 0;
    sub_100208A0(&v20, a3, a4);
    v24 = 1;
    v5 = v20;
    v25 = v21 - v20;
    if ( !*(_DWORD *)(v4 + 4) )
    {
      v7 = sub_1001B150(v4, (int)&a4);
      LOBYTE(v24) = 2;
      v8 = sub_10017B50(v9, v4, v5, v7);
      LOBYTE(v24) = 1;
      v6 = a4;
      *(_DWORD *)(v4 + 4) = v8;
      if ( v6 )
      {
        v10 = (*(int (**)(void))(*(_DWORD *)v6 + 8))();
        if ( v10 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v10)(v10, 1);
      }
    }
    (*(void (__stdcall **)(int, int))(**(_DWORD **)(v4 + 4) + 12))(v5, v5 + v25);
    if ( !*(_DWORD *)v4 )
    {
      v12 = sub_1001B150(v4, (int)&a4);
      LOBYTE(v24) = 3;
      v13 = sub_1001C310(v14, v4, v5, v12);
      LOBYTE(v24) = 1;
      v11 = a4;
      *(_DWORD *)v4 = v13;
      if ( v11 )
      {
        v15 = (*(int (**)(void))(*(_DWORD *)v11 + 8))();
        if ( v15 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v15)(v15, 1);
      }
    }
    v16 = sub_1001AEF0(*(void **)v4, (int)&v18, v5, v5 + v25);
    if ( a2 != v16 )
    {
      if ( *(_DWORD *)(a2 + 20) >= 0x10u )
        sub_1002A4AA(*(LPVOID *)a2);
      *(_DWORD *)(a2 + 20) = 15;
      *(_DWORD *)(a2 + 16) = 0;
      *(_BYTE *)a2 = 0;
      sub_100017B0((void *)a2, v16);
    }
    if ( v19 >= 0x10 )
      sub_1002A4AA(v18);
    if ( v5 )
      sub_1002A4AA((LPVOID)v5);
  }
  return a2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10020740) --------------------------------------------------------
void *__thiscall sub_10020740(void *this, int a2, int a3)
{
  void *result; // eax@1
  int i; // ecx@1

  result = this;
  for ( i = a2; i != a3; result = (char *)result + 1 )
  {
    if ( result )
      *(_BYTE *)result = *(_BYTE *)i;
    ++i;
  }
  return result;
}

//----- (10020770) --------------------------------------------------------
int __fastcall sub_10020770(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // edx@1
  int v5; // ecx@1
  signed int v6; // ebx@1
  int v7; // edi@1
  signed int v8; // esi@1
  int v9; // edi@1
  int v10; // edx@2
  int v11; // ebx@6
  int v12; // eax@7
  int v13; // edx@9
  int v14; // esi@9
  char v15; // dl@10
  int v16; // [sp+Ch] [bp-1Ch]@6
  int v17; // [sp+14h] [bp-14h]@1
  int v18; // [sp+18h] [bp-10h]@1
  int v19; // [sp+18h] [bp-10h]@6
  int v20; // [sp+1Ch] [bp-Ch]@1
  int v21; // [sp+20h] [bp-8h]@9
  int v22; // [sp+24h] [bp-4h]@1

  v9 = a2;
  v4 = a1;
  v5 = a3;
  v7 = v9 - v4;
  result = a3 - v4;
  v22 = v4;
  v17 = v7;
  v18 = a3 - v4;
  v6 = a3 - v4;
  v20 = a3 - v4;
  v8 = v7;
  if ( v7 )
  {
    do
    {
      v10 = v6 % v8;
      v6 = v8;
      v8 = v10;
    }
    while ( v10 );
    v4 = v22;
    result = v18;
    v20 = v6;
  }
  if ( v6 < result )
  {
    if ( v6 > 0 )
    {
      v16 = -v4;
      v19 = -v7;
      v11 = v4 + v6;
      do
      {
        v12 = v11 + v7;
        if ( v11 + v7 == v5 )
          v12 = v22;
        v13 = v11;
        v21 = v11;
        v14 = -v12;
        do
        {
          v15 = *(_BYTE *)v13;
          *(_BYTE *)v21 = *(_BYTE *)v12;
          v7 = v17;
          *(_BYTE *)v12 = v15;
          v13 = v12;
          v21 = v12;
          if ( v17 >= v14 + a3 )
          {
            v12 += v22 + v17 - a3;
            v14 += a3 + v19 + v16;
            v13 = v21;
          }
          else
          {
            v12 += v17;
            v14 += v19;
          }
        }
        while ( v12 != v11 );
        v5 = a3;
        result = v20 - 1;
        --v11;
        v20 = result;
      }
      while ( result > 0 );
    }
  }
  return result;
}

//----- (100208A0) --------------------------------------------------------
int __thiscall sub_100208A0(void *this, int a2, int a3)
{
  char v4; // [sp+0h] [bp-24h]@1
  void *v5; // [sp+10h] [bp-14h]@1
  char *v6; // [sp+14h] [bp-10h]@1
  int v7; // [sp+20h] [bp-4h]@1

  v6 = &v4;
  v7 = 0;
  v5 = this;
  return loc_10020910(*(_DWORD *)this);
}

//----- (10020A40) --------------------------------------------------------
int __thiscall sub_10020A40(void *this, int a2)
{
  int v2; // eax@1
  int v3; // ebx@2
  char *v4; // edi@2
  const char *v5; // edx@3
  unsigned int v6; // ecx@6
  char v7; // bl@13
  LPVOID v9[4]; // [sp+14h] [bp-40h]@5
  int v10; // [sp+24h] [bp-30h]@5
  unsigned int v11; // [sp+28h] [bp-2Ch]@5
  LPVOID v12[4]; // [sp+2Ch] [bp-28h]@2
  int v13; // [sp+3Ch] [bp-18h]@2
  unsigned int v14; // [sp+40h] [bp-14h]@2

  v2 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    v5 = *(const char **)(v2 + 24);
    if ( !v5 )
      v5 = (const char *)(v2 + 28);
    v11 = 15;
    v10 = 0;
    LOBYTE(v9[0]) = 0;
    if ( *v5 )
      v6 = strlen(v5);
    else
      v6 = 0;
    loc_1000AEB0(v9, v5, v6);
    v4 = (char *)v9;
    LOBYTE(v3) = 2;
  }
  else
  {
    v14 = 15;
    v13 = v2;
    LOBYTE(v12[0]) = v2;
    v4 = (char *)v12;
    v3 = v2 + 1;
  }
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  if ( *((_DWORD *)v4 + 5) >= 0x10u )
  {
    *(_DWORD *)a2 = *(_DWORD *)v4;
    *(_DWORD *)v4 = 0;
  }
  else
  {
    if ( *((_DWORD *)v4 + 4) != -1 )
      sub_1002A4B0((void *)a2, v4, *((_DWORD *)v4 + 4) + 1);
  }
  *(_DWORD *)(a2 + 16) = *((_DWORD *)v4 + 4);
  v7 = v3 | 4;
  *(_DWORD *)(a2 + 20) = *((_DWORD *)v4 + 5);
  *((_DWORD *)v4 + 5) = 15;
  *((_DWORD *)v4 + 4) = 0;
  *v4 = 0;
  if ( v7 & 2 )
  {
    v7 &= 0xFDu;
    if ( v11 >= 0x10 )
      sub_1002A4AA(v9[0]);
    v11 = 15;
    v10 = 0;
    LOBYTE(v9[0]) = 0;
  }
  if ( v7 & 1 )
  {
    if ( v14 >= 0x10 )
      sub_1002A4AA(v12[0]);
  }
  return a2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10020BA0) --------------------------------------------------------
int __thiscall sub_10020BA0(void *this, int a2, char a3, int a4, int a5)
{
  char v9; // [sp-48h] [bp-50h]@1
  int v10; // [sp-44h] [bp-4Ch]@1
  int v11; // [sp-40h] [bp-48h]@1
  int v12; // [sp-3Ch] [bp-44h]@1
  int v13; // [sp-38h] [bp-40h]@1
  unsigned int v14; // [sp-34h] [bp-3Ch]@1
  char v15; // [sp-30h] [bp-38h]@1
  __int64 v16; // [sp-28h] [bp-30h]@1
  __int64 v17; // [sp-20h] [bp-28h]@1
  __int64 v18; // [sp-18h] [bp-20h]@1
  __int64 v19; // [sp-10h] [bp-18h]@1
  int v20; // [sp-8h] [bp-10h]@1
  int v21; // [sp-4h] [bp-Ch]@1

  _ESI = a2;
  v21 = a5;
  __asm { movq    xmm0, qword ptr [esi+18h] }
  v20 = a4;
  _EDI = (int)this;
  _EAX = &v15;
  __asm
  {
    movq    qword ptr [eax], xmm0
    movq    xmm0, qword ptr [esi+20h]
    movq    qword ptr [eax+8], xmm0
    movq    xmm0, qword ptr [esi+28h]
    movq    qword ptr [eax+10h], xmm0
    movq    xmm0, qword ptr [esi+30h]
    movq    qword ptr [eax+18h], xmm0
    movq    xmm0, qword ptr [esi+38h]
  }
  v14 = 15;
  v13 = 0;
  __asm { movq    qword ptr [eax+20h], xmm0 }
  v9 = 0;
  loc_1000AB40(a2, 0, -1);
  sub_1000B010(
    _EDI,
    word_10076058,
    a3,
    *(void **)&v9,
    v10,
    v11,
    v12,
    v13,
    v14,
    *(__int64 *)&v15,
    v16,
    v17,
    v18,
    v19,
    v20,
    v21);
  *(_DWORD *)_EDI = &off_1006827C;
  __asm
  {
    movq    xmm0, qword ptr [esi+40h]
    movq    qword ptr [edi+138h], xmm0
    movq    xmm0, qword ptr [esi+48h]
    movq    qword ptr [edi+140h], xmm0
  }
  *(_DWORD *)(_EDI + 344) = 0;
  *(_DWORD *)(_EDI + 348) = 0;
  *(_DWORD *)(_EDI + 352) = 0;
  *(_DWORD *)(_EDI + 356) = 0;
  return _EDI;
}
// 1006827C: using guessed type int (__stdcall *off_1006827C)(char);
// 10076058: using guessed type __int16 word_10076058;

//----- (10020C70) --------------------------------------------------------
int __fastcall sub_10020C70(int a1, char a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9, int a10)
{
  int v10; // edx@1
  char v11; // bl@1
  int v12; // edi@1
  int v13; // ecx@1
  signed int v14; // eax@2
  int v15; // eax@4
  int v16; // ecx@4
  void *v17; // esi@4
  int v18; // esi@5
  char v20; // [sp-1Ch] [bp-90h]@1
  void *v21; // [sp-18h] [bp-8Ch]@1
  int v22; // [sp-14h] [bp-88h]@1
  int v23; // [sp-10h] [bp-84h]@1
  int v24; // [sp-Ch] [bp-80h]@1
  int v25; // [sp-8h] [bp-7Ch]@1
  unsigned int v26; // [sp-4h] [bp-78h]@1
  int v27; // [sp+10h] [bp-64h]@4
  void *v28; // [sp+14h] [bp-60h]@1
  int v29; // [sp+24h] [bp-50h]@1
  unsigned int v30; // [sp+28h] [bp-4Ch]@1
  int v31; // [sp+4Ch] [bp-28h]@2
  unsigned int v32; // [sp+64h] [bp-10h]@1
  int v33; // [sp+70h] [bp-4h]@1
  int v34; // [sp+74h] [bp+0h]@1

  v32 = (unsigned int)&v34 ^ __security_cookie;
  v26 = (unsigned int)&v34 ^ __security_cookie;
  v11 = a2;
  v12 = a1;
  v33 = 0;
  v30 = 15;
  v29 = 0;
  LOBYTE(v28) = 0;
  LOBYTE(v33) = 1;
  v25 = 15;
  v24 = 0;
  v20 = 0;
  loc_1000AB40(&a3, 0, -1, *(_DWORD *)&v20);
  if ( !sub_10020ED0(v13, (int)&v28, v21, v22, v23, v24, v25, v26) )
    goto LABEL_14;
  v14 = v31;
  if ( !v11 )
    v14 = 15;
  v31 = v14;
  v15 = sub_1002ADB1(v10, 15, v11, v12, 360);
  v17 = (void *)v15;
  v27 = v15;
  LOBYTE(v33) = 2;
  if ( v15 )
  {
    sub_1000BC10(v15, v16);
    v18 = sub_10020BA0(v17, (int)&v28, v12, a9, a10);
  }
  else
  {
LABEL_14:
    v18 = 0;
  }
  if ( v30 >= 0x10 )
    sub_1002A4AA(v28);
  v30 = 15;
  v29 = 0;
  LOBYTE(v28) = 0;
  if ( a8 >= 0x10 )
    sub_1002A4AA(a3);
  return v18;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10020D90) --------------------------------------------------------
int __thiscall sub_10020D90(int _ECX, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6, int a7, __int64 a8, int a9, int a10)
{
  int result; // eax@1

  result = *(_DWORD *)(_ECX + 344);
  __asm
  {
    movsd   xmm4, [ebp+arg_10]
    movapd  xmm7, xmm1
    movsd   qword ptr [ecx+148h], xmm7
    movsd   qword ptr [ecx+150h], xmm2
  }
  if ( result && result != 2 )
    goto LABEL_21;
  __asm
  {
    movsd   xmm5, qword ptr [ecx+88h]
    movsd   xmm0, qword ptr [ecx+138h]
    movsd   xmm6, qword ptr [ecx+80h]
    mulsd   xmm0, xmm5
    movapd  xmm1, xmm2
    subsd   xmm1, xmm7
    mulsd   xmm0, xmm6
    comisd  xmm1, xmm0
  }
  if ( _CF | _ZF )
    goto LABEL_21;
  __asm
  {
    movsd   xmm0, qword ptr [ecx+140h]
    movsd   xmm1, [ebp+arg_18]
    mulsd   xmm0, xmm5
    subsd   xmm1, xmm4
    mulsd   xmm0, xmm6
    comisd  xmm1, xmm0
  }
  if ( _CF | _ZF )
  {
LABEL_21:
    __asm { movsd   xmm6, [ebp+arg_8] }
  }
  else
  {
    __asm
    {
      comisd  xmm2, xmm3
      movsd   xmm6, [ebp+arg_8]
    }
    if ( !(_CF | _ZF) )
    {
      __asm
      {
        movsd   xmm0, [ebp+arg_28]
        comisd  xmm0, xmm3
      }
      if ( !(_CF | _ZF) )
      {
        __asm
        {
          movsd   xmm0, [ebp+arg_0]
          comisd  xmm0, xmm6
        }
        if ( !(_CF | _ZF) )
        {
          *(_DWORD *)(_ECX + 344) = 1;
LABEL_18:
          *(_DWORD *)(_ECX + 348) = result;
          *(_DWORD *)(_ECX + 352) = a9;
          result = a10;
          *(_DWORD *)(_ECX + 356) = a10;
          return result;
        }
      }
    }
  }
  if ( !result || result == 1 )
  {
    __asm
    {
      movsd   xmm1, qword ptr [ecx+88h]
      movsd   xmm0, qword ptr [ecx+138h]
      movsd   xmm5, qword ptr [ecx+80h]
      mulsd   xmm0, xmm1
      subsd   xmm7, xmm2
      mulsd   xmm0, xmm5
      comisd  xmm7, xmm0
    }
    if ( !(_CF | _ZF) )
    {
      __asm
      {
        movsd   xmm0, qword ptr [ecx+140h]
        subsd   xmm4, [ebp+arg_18]
        mulsd   xmm0, xmm1
        mulsd   xmm0, xmm5
        comisd  xmm4, xmm0
      }
      if ( !(_CF | _ZF) )
      {
        __asm { comisd  xmm3, xmm2 }
        if ( !(_CF | _ZF) )
        {
          __asm { comisd  xmm3, [ebp+arg_28] }
          if ( !(_CF | _ZF) )
          {
            __asm { comisd  xmm6, [ebp+arg_0] }
            if ( !(_CF | _ZF) )
            {
              *(_DWORD *)(_ECX + 344) = 2;
              goto LABEL_18;
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (10020ED0) --------------------------------------------------------
char __fastcall sub_10020ED0(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8)
{
  char *v8; // ecx@1
  char *v9; // eax@3
  int v10; // edi@5
  int v11; // esi@5
  int v12; // ebx@8
  void *v13; // esi@10
  int v14; // eax@10
  void *v15; // ST00_4@10
  int v16; // ST04_4@10
  int v17; // ST08_4@10
  char v18; // bl@13
  char v20; // [sp-Ch] [bp-48h]@10
  int v21; // [sp-8h] [bp-44h]@10
  unsigned int v22; // [sp-4h] [bp-40h]@10
  int v23; // [sp+0h] [bp-3Ch]@10
  int v24; // [sp+4h] [bp-38h]@10
  signed int v25; // [sp+8h] [bp-34h]@10
  void *v26; // [sp+10h] [bp-2Ch]@10
  int v27; // [sp+20h] [bp-1Ch]@10
  unsigned int v28; // [sp+24h] [bp-18h]@10
  void *v29; // [sp+28h] [bp-14h]@1
  int v30; // [sp+38h] [bp-4h]@1

  v29 = (void *)a2;
  v30 = 0;
  v8 = (char *)&a3;
  if ( a8 >= 0x10 )
    v8 = (char *)a3;
  v9 = (char *)&a3;
  if ( a8 >= 0x10 )
    v9 = (char *)a3;
  v11 = (int)&v8[a7];
  v10 = (int)&a3;
  if ( a8 >= 0x10 )
    v10 = (int)a3;
  if ( v10 != v11 )
  {
    v12 = (int)&v9[-v10];
    do
    {
      *(_BYTE *)(v12 + v10) = sub_10030357(v12, v10, *(_BYTE *)v10);
      ++v10;
    }
    while ( v10 != v11 );
  }
  v28 = 15;
  v27 = 0;
  LOBYTE(v26) = 0;
  loc_1000AB40(&v26, &a3, 0, -1, v23, v24, v25);
  LOBYTE(v30) = 1;
  v25 = 15;
  v24 = 0;
  v20 = 0;
  loc_1000AB40(&v26, 0, -1, *(_DWORD *)&v20);
  v14 = sub_10021080((int)&unk_10075FB8, (int)&word_10076058, v15, v16, v17, *(int *)&v20, v21, v22);
  LOBYTE(v30) = 0;
  v13 = (void *)v14;
  if ( v28 >= 0x10 )
    sub_1002A4AA(v26);
  v28 = 15;
  v27 = 0;
  LOBYTE(v26) = 0;
  if ( v13 == &word_10076058 )
  {
    v18 = 0;
  }
  else
  {
    sub_10021010(v29, v13);
    v18 = 1;
  }
  if ( a8 >= 0x10 )
    sub_1002A4AA(a3);
  return v18;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10076058: using guessed type __int16 word_10076058;

//----- (10021010) --------------------------------------------------------
void *__thiscall sub_10021010(void *this, void *a2)
{
  _EDI = a2;
  _ESI = this;
  if ( this != a2 )
    loc_1000AB40(a2, 0, -1);
  __asm
  {
    movq    xmm0, qword ptr [edi+18h]
    movq    qword ptr [esi+18h], xmm0
    movq    xmm0, qword ptr [edi+20h]
    movq    qword ptr [esi+20h], xmm0
    movq    xmm0, qword ptr [edi+28h]
    movq    qword ptr [esi+28h], xmm0
    movq    xmm0, qword ptr [edi+30h]
    movq    qword ptr [esi+30h], xmm0
    movq    xmm0, qword ptr [edi+38h]
    movq    qword ptr [esi+38h], xmm0
    movq    xmm0, qword ptr [edi+40h]
    movq    qword ptr [esi+40h], xmm0
    movq    xmm0, qword ptr [edi+48h]
    movq    qword ptr [esi+48h], xmm0
  }
  return _ESI;
}

//----- (10021080) --------------------------------------------------------
int __fastcall sub_10021080(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8)
{
  int v8; // edi@1
  int i; // esi@1
  unsigned __int8 *v10; // eax@3

  v8 = a2;
  for ( i = a1; i != v8; i += 80 )
  {
    if ( *(_DWORD *)(i + 20) < 0x10u )
      v10 = (unsigned __int8 *)i;
    else
      v10 = *(unsigned __int8 **)i;
    if ( sub_10002C30((int)&a3, v10, a1, *(_DWORD *)(i + 16)) != -1 )
      break;
  }
  if ( a8 >= 0x10 )
    sub_1002A4AA(a3);
  return i;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100210D0) --------------------------------------------------------
int __thiscall sub_100210D0(void *this, int a2, char a3, int a4, int a5)
{
  char v9; // [sp-48h] [bp-50h]@1
  int v10; // [sp-44h] [bp-4Ch]@1
  int v11; // [sp-40h] [bp-48h]@1
  int v12; // [sp-3Ch] [bp-44h]@1
  int v13; // [sp-38h] [bp-40h]@1
  unsigned int v14; // [sp-34h] [bp-3Ch]@1
  char v15; // [sp-30h] [bp-38h]@1
  __int64 v16; // [sp-28h] [bp-30h]@1
  __int64 v17; // [sp-20h] [bp-28h]@1
  __int64 v18; // [sp-18h] [bp-20h]@1
  __int64 v19; // [sp-10h] [bp-18h]@1
  int v20; // [sp-8h] [bp-10h]@1
  int v21; // [sp-4h] [bp-Ch]@1

  _ESI = a2;
  v21 = a5;
  __asm { movq    xmm0, qword ptr [esi+18h] }
  v20 = a4;
  _EDI = (int)this;
  _EAX = &v15;
  __asm
  {
    movq    qword ptr [eax], xmm0
    movq    xmm0, qword ptr [esi+20h]
    movq    qword ptr [eax+8], xmm0
    movq    xmm0, qword ptr [esi+28h]
    movq    qword ptr [eax+10h], xmm0
    movq    xmm0, qword ptr [esi+30h]
    movq    qword ptr [eax+18h], xmm0
    movq    xmm0, qword ptr [esi+38h]
  }
  v14 = 15;
  v13 = 0;
  __asm { movq    qword ptr [eax+20h], xmm0 }
  v9 = 0;
  loc_1000AB40(a2, 0, -1);
  sub_1000B010(
    _EDI,
    word_1007605C,
    a3,
    *(void **)&v9,
    v10,
    v11,
    v12,
    v13,
    v14,
    *(__int64 *)&v15,
    v16,
    v17,
    v18,
    v19,
    v20,
    v21);
  *(_DWORD *)_EDI = &off_1006827C;
  __asm
  {
    movq    xmm0, qword ptr [esi+40h]
    movq    qword ptr [edi+138h], xmm0
    movq    xmm0, qword ptr [esi+48h]
    movq    qword ptr [edi+140h], xmm0
  }
  return _EDI;
}
// 1006827C: using guessed type int (__stdcall *off_1006827C)(char);
// 1007605C: using guessed type __int16 word_1007605C;

//----- (10021170) --------------------------------------------------------
int __fastcall sub_10021170(int a1, char a2, char a3, void *a4, int a5, int a6, int a7, int a8, unsigned int a9, int a10, int a11)
{
  int v11; // edx@1
  char v12; // bl@1
  int v13; // edi@1
  int v14; // ecx@1
  signed int v15; // eax@2
  int v16; // eax@4
  int v17; // ecx@4
  void *v18; // esi@4
  int v19; // esi@5
  char v21; // [sp-1Ch] [bp-94h]@1
  void *v22; // [sp-18h] [bp-90h]@1
  int v23; // [sp-14h] [bp-8Ch]@1
  int v24; // [sp-10h] [bp-88h]@1
  int v25; // [sp-Ch] [bp-84h]@1
  int v26; // [sp-8h] [bp-80h]@1
  unsigned int v27; // [sp-4h] [bp-7Ch]@1
  int v28; // [sp+10h] [bp-68h]@4
  void *v29; // [sp+14h] [bp-64h]@1
  int v30; // [sp+24h] [bp-54h]@1
  unsigned int v31; // [sp+28h] [bp-50h]@1
  int v32; // [sp+4Ch] [bp-2Ch]@2
  char v33; // [sp+54h] [bp-24h]@4
  unsigned int v34; // [sp+64h] [bp-14h]@1
  int v35; // [sp+74h] [bp-4h]@1
  int v36; // [sp+78h] [bp+0h]@1

  v34 = (unsigned int)&v36 ^ __security_cookie;
  v27 = (unsigned int)&v36 ^ __security_cookie;
  v12 = a2;
  v13 = a1;
  v35 = 0;
  v31 = 15;
  v30 = 0;
  LOBYTE(v29) = 0;
  LOBYTE(v35) = 1;
  v26 = 15;
  v25 = 0;
  v21 = 0;
  loc_1000AB40(&a4, 0, -1, *(_DWORD *)&v21);
  if ( !sub_100213C0(v14, (int)&v29, v22, v23, v24, v25, v26, v27) )
    goto LABEL_14;
  v15 = v32;
  if ( !v12 )
    v15 = 15;
  v32 = v15;
  v33 = a3;
  v16 = sub_1002ADB1(v11, 15, v12, v13, 384);
  v18 = (void *)v16;
  v28 = v16;
  LOBYTE(v35) = 2;
  if ( v16 )
  {
    sub_1000BC10(v16, v17);
    v19 = sub_100210D0(v18, (int)&v29, v13, a10, a11);
  }
  else
  {
LABEL_14:
    v19 = 0;
  }
  if ( v31 >= 0x10 )
    sub_1002A4AA(v29);
  v31 = 15;
  v30 = 0;
  LOBYTE(v29) = 0;
  if ( a9 >= 0x10 )
    sub_1002A4AA(a4);
  return v19;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (100212A0) --------------------------------------------------------
char __thiscall sub_100212A0(int _ECX)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(_ECX + 8);
  if ( !v1 || !(*(_BYTE *)(v1 + 112) & 4) )
    return 0;
  if ( *(_BYTE *)(_ECX + 312) )
  {
    __asm
    {
      movsd   xmm0, qword ptr [ecx+170h]
      comisd  xmm0, qword ptr [ecx+178h]
    }
    if ( _CF | _ZF )
      return 0;
  }
  else
  {
    __asm
    {
      movsd   xmm1, qword ptr [ecx+168h]
      movsd   xmm0, qword ptr [ecx+148h]
      comisd  xmm0, xmm1
    }
    if ( _CF | _ZF )
      return 0;
    __asm { comisd  xmm1, qword ptr [ecx+160h] }
    if ( _CF | _ZF )
      return 0;
    __asm
    {
      movsd   xmm0, qword ptr [ecx+140h]
      mulsd   xmm0, qword ptr [ecx+88h]
      movsd   xmm1, qword ptr [ecx+158h]
      subsd   xmm1, qword ptr [ecx+150h]
      mulsd   xmm0, qword ptr [ecx+80h]
      comisd  xmm1, xmm0
    }
    if ( _CF | _ZF )
      return 0;
  }
  return 1;
}

//----- (10021330) --------------------------------------------------------
char __thiscall sub_10021330(int _ECX)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(_ECX + 8);
  if ( !v1 || !(*(_BYTE *)(v1 + 112) & 4) )
    return 0;
  if ( *(_BYTE *)(_ECX + 312) )
  {
    __asm
    {
      movsd   xmm0, qword ptr [ecx+178h]
      comisd  xmm0, qword ptr [ecx+170h]
    }
    if ( _CF | _ZF )
      return 0;
  }
  else
  {
    __asm
    {
      movsd   xmm1, qword ptr [ecx+168h]
      comisd  xmm1, qword ptr [ecx+148h]
    }
    if ( _CF | _ZF )
      return 0;
    __asm
    {
      movsd   xmm0, qword ptr [ecx+160h]
      comisd  xmm0, xmm1
    }
    if ( _CF | _ZF )
      return 0;
    __asm
    {
      movsd   xmm0, qword ptr [ecx+140h]
      mulsd   xmm0, qword ptr [ecx+88h]
      movsd   xmm1, qword ptr [ecx+150h]
      subsd   xmm1, qword ptr [ecx+158h]
      mulsd   xmm0, qword ptr [ecx+80h]
      comisd  xmm1, xmm0
    }
    if ( _CF | _ZF )
      return 0;
  }
  return 1;
}

//----- (100213C0) --------------------------------------------------------
char __fastcall sub_100213C0(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8)
{
  char *v8; // ecx@1
  char *v9; // eax@3
  int v10; // edi@5
  int v11; // esi@5
  int v12; // ebx@8
  void *v13; // esi@10
  int v14; // eax@10
  void *v15; // ST00_4@10
  int v16; // ST04_4@10
  int v17; // ST08_4@10
  char v18; // bl@13
  char v20; // [sp-Ch] [bp-48h]@10
  int v21; // [sp-8h] [bp-44h]@10
  unsigned int v22; // [sp-4h] [bp-40h]@10
  int v23; // [sp+0h] [bp-3Ch]@10
  int v24; // [sp+4h] [bp-38h]@10
  signed int v25; // [sp+8h] [bp-34h]@10
  void *v26; // [sp+10h] [bp-2Ch]@10
  int v27; // [sp+20h] [bp-1Ch]@10
  unsigned int v28; // [sp+24h] [bp-18h]@10
  void *v29; // [sp+28h] [bp-14h]@1
  int v30; // [sp+38h] [bp-4h]@1

  v29 = (void *)a2;
  v30 = 0;
  v8 = (char *)&a3;
  if ( a8 >= 0x10 )
    v8 = (char *)a3;
  v9 = (char *)&a3;
  if ( a8 >= 0x10 )
    v9 = (char *)a3;
  v11 = (int)&v8[a7];
  v10 = (int)&a3;
  if ( a8 >= 0x10 )
    v10 = (int)a3;
  if ( v10 != v11 )
  {
    v12 = (int)&v9[-v10];
    do
    {
      *(_BYTE *)(v12 + v10) = sub_10030357(v12, v10, *(_BYTE *)v10);
      ++v10;
    }
    while ( v10 != v11 );
  }
  v28 = 15;
  v27 = 0;
  LOBYTE(v26) = 0;
  loc_1000AB40(&v26, &a3, 0, -1, v23, v24, v25);
  LOBYTE(v30) = 1;
  v25 = 15;
  v24 = 0;
  v20 = 0;
  loc_1000AB40(&v26, 0, -1, *(_DWORD *)&v20);
  v14 = sub_10021080((int)&unk_10076060, (int)&dword_10076100, v15, v16, v17, *(int *)&v20, v21, v22);
  LOBYTE(v30) = 0;
  v13 = (void *)v14;
  if ( v28 >= 0x10 )
    sub_1002A4AA(v26);
  v28 = 15;
  v27 = 0;
  LOBYTE(v26) = 0;
  if ( v13 == &dword_10076100 )
  {
    v18 = 0;
  }
  else
  {
    sub_10021010(v29, v13);
    v18 = 1;
  }
  if ( a8 >= 0x10 )
    sub_1002A4AA(a3);
  return v18;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10076100: using guessed type int dword_10076100;

//----- (10021500) --------------------------------------------------------
int *__usercall sub_10021500<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // edx@7
  int v3; // ecx@7
  int v4; // ST00_4@7
  _UNKNOWN *v6; // [sp-4h] [bp-38h]@4
  int v7; // [sp-4h] [bp-38h]@7
  void **v8; // [sp+4h] [bp-30h]@1
  void (__userpurge *v9)(int<ecx>, int<ebx>, int); // [sp+8h] [bp-2Ch]@1
  int *v10; // [sp+Ch] [bp-28h]@1
  int *v11; // [sp+14h] [bp-20h]@1
  int v12; // [sp+1Ch] [bp-18h]@1
  int *v13; // [sp+20h] [bp-14h]@1
  int *v14; // [sp+24h] [bp-10h]@1
  int v15; // [sp+30h] [bp-4h]@1

  v14 = &dword_10077758;
  dword_1007776C = 15;
  dword_10077768 = 0;
  LOBYTE(dword_10077758) = 0;
  v15 = 0;
  dword_10077784 = 15;
  dword_10077780 = 0;
  LOBYTE(dword_10077770) = 0;
  dword_1007779C = 15;
  dword_10077798 = 0;
  LOBYTE(dword_10077788) = 0;
  __asm
  {
    movsd   xmm0, ds:qword_10069560
    movsd   qword_100777A8, xmm0
  }
  dword_100777C4 = 15;
  dword_100777C0 = 0;
  LOBYTE(dword_100777B0) = 0;
  dword_100777C8 = 0;
  dword_100777D0 = 3600000;
  qword_100777D8 = -9223372036854775808i64;
  dword_100777E0 = 60;
  dword_100777F8 = 15;
  dword_100777F4 = 0;
  LOBYTE(dword_100777E4) = 0;
  dword_100777FC = 0;
  dword_10077800 = 0;
  dword_10077804 = 0;
  dword_10077808 = 0;
  dword_1007780C = 60;
  dword_10077824 = 15;
  dword_10077820 = 0;
  LOBYTE(dword_10077810) = 0;
  dword_10077828 = 0;
  dword_1007782C = 0;
  dword_10077830 = 0;
  dword_10077834 = 0;
  dword_10077838 = 0;
  dword_1007783C = 0;
  dword_10077840 = 0;
  dword_10077844 = 0;
  dword_10077848 = 0;
  dword_1007784C = 0;
  dword_10077850 = 0;
  v8 = &off_10068F94;
  v9 = sub_10021F90;
  v10 = &dword_10077758;
  v11 = (int *)&v8;
  LOBYTE(v15) = 9;
  v13 = &dword_10077858;
  sub_10024D60((int)&dword_10077858, a1);
  dword_10077858 = (int)&off_100693C4;
  v12 = (int)&unk_10077950;
  LOBYTE(v15) = 11;
  if ( v11 )
  {
    if ( (void ***)v11 == &v8 )
      v6 = &unk_10077950;
    else
      v6 = 0;
    dword_10077960 = (*(int (__stdcall **)(int))*v11)(v7);
  }
  else
  {
    dword_10077960 = 0;
  }
  LOBYTE(v15) = 12;
  sub_10024E30((int)&dword_10077858, v4, v7);
  sub_10024ED0((int)&dword_10077858);
  LOBYTE(v15) = 14;
  v3 = (int)v11;
  if ( v11 )
    (*(void (__stdcall **)(bool))(*v11 + 16))((void ***)v11 != &v8);
  dword_10077968 = 0;
  LOBYTE(v15) = 15;
  dword_1007796C = 0;
  dword_10077970 = 0;
  sub_10006BC0(v2, (int)&dword_1007796C, a2, v3);
  LOBYTE(v15) = 16;
  sub_1002B607((int)&unk_10077974);
  LOBYTE(v15) = 17;
  sub_1002B5CC((int)&unk_1007799C);
  LOBYTE(v15) = 18;
  sub_1002B5CC((int)&unk_100779BC);
  return &dword_10077758;
}
// 10068F94: using guessed type void *off_10068F94;
// 100693C4: using guessed type int (__stdcall *off_100693C4)(char);
// 10077758: using guessed type int dword_10077758;
// 10077768: using guessed type int dword_10077768;
// 1007776C: using guessed type int dword_1007776C;
// 10077770: using guessed type int dword_10077770;
// 10077780: using guessed type int dword_10077780;
// 10077784: using guessed type int dword_10077784;
// 10077788: using guessed type int dword_10077788;
// 10077798: using guessed type int dword_10077798;
// 1007779C: using guessed type int dword_1007779C;
// 100777B0: using guessed type int dword_100777B0;
// 100777C0: using guessed type int dword_100777C0;
// 100777C4: using guessed type int dword_100777C4;
// 100777C8: using guessed type int dword_100777C8;
// 100777D0: using guessed type int dword_100777D0;
// 100777D8: using guessed type __int64 qword_100777D8;
// 100777E0: using guessed type int dword_100777E0;
// 100777E4: using guessed type int dword_100777E4;
// 100777F4: using guessed type int dword_100777F4;
// 100777F8: using guessed type int dword_100777F8;
// 100777FC: using guessed type int dword_100777FC;
// 10077800: using guessed type int dword_10077800;
// 10077804: using guessed type int dword_10077804;
// 10077808: using guessed type int dword_10077808;
// 1007780C: using guessed type int dword_1007780C;
// 10077810: using guessed type int dword_10077810;
// 10077820: using guessed type int dword_10077820;
// 10077824: using guessed type int dword_10077824;
// 10077828: using guessed type int dword_10077828;
// 1007782C: using guessed type int dword_1007782C;
// 10077830: using guessed type int dword_10077830;
// 10077834: using guessed type int dword_10077834;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;
// 10077840: using guessed type int dword_10077840;
// 10077844: using guessed type int dword_10077844;
// 10077848: using guessed type int dword_10077848;
// 1007784C: using guessed type int dword_1007784C;
// 10077850: using guessed type int dword_10077850;
// 10077858: using guessed type int dword_10077858;
// 10077960: using guessed type int dword_10077960;
// 10077968: using guessed type int dword_10077968;
// 1007796C: using guessed type int dword_1007796C;
// 10077970: using guessed type int dword_10077970;

//----- (100217D0) --------------------------------------------------------
int __usercall sub_100217D0<eax>(int a1<ebx>)
{
  int v1; // ecx@4
  int v2; // esi@7
  int result; // eax@17
  char v18; // [sp+Ch] [bp-1Ch]@5
  int *v19; // [sp+18h] [bp-10h]@1
  int v20; // [sp+24h] [bp-4h]@1

  v19 = &dword_10077758;
  v20 = 13;
  if ( dword_10077968 )
  {
    (**(void (__stdcall ***)(_DWORD))dword_10077968)(1);
    dword_10077968 = 0;
  }
  if ( dword_10077850 )
  {
    v1 = dword_1007796C;
    if ( !dword_1007796C )
    {
      sub_1002FFB9((int)&v18, (unsigned int)"wait() cannot be called on a default constructed task.");
      sub_100355DB((int)&v18, (int)&unk_1006D8B8);
    }
    sub_10009F10(v1, a1);
  }
  LOBYTE(v20) = 12;
  nullsub_2(&unk_100779BC);
  LOBYTE(v20) = 11;
  nullsub_2(&unk_1007799C);
  LOBYTE(v20) = 10;
  nullsub_2(&unk_10077974);
  LOBYTE(v20) = 9;
  v2 = dword_10077970;
  if ( dword_10077970 )
  {
    _EDI = -1;
    _ECX = dword_10077970 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v2)(v2);
      _EAX = v2 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 4))(v2);
    }
  }
  LOBYTE(v20) = 8;
  if ( dword_10077968 )
    (**(void (__stdcall ***)(_DWORD))dword_10077968)(1);
  LOBYTE(v20) = 7;
  sub_100230C0((int)&dword_10077858, a1);
  sub_10024BC0((int)&dword_10077844);
  sub_10024B00((int)&dword_10077838);
  if ( dword_10077828 )
  {
    sub_1002A4AA((LPVOID)dword_10077828);
    dword_10077828 = 0;
    dword_1007782C = 0;
    dword_10077830 = 0;
  }
  if ( (unsigned int)dword_10077824 >= 0x10 )
    sub_1002A4AA((LPVOID)dword_10077810);
  result = dword_100777FC;
  dword_10077824 = 15;
  dword_10077820 = 0;
  LOBYTE(dword_10077810) = 0;
  if ( dword_100777FC )
  {
    result = sub_1002A4AA((LPVOID)dword_100777FC);
    dword_100777FC = 0;
    dword_10077800 = 0;
    dword_10077804 = 0;
  }
  if ( (unsigned int)dword_100777F8 >= 0x10 )
    result = sub_1002A4AA((LPVOID)dword_100777E4);
  dword_100777F8 = 15;
  dword_100777F4 = 0;
  LOBYTE(dword_100777E4) = 0;
  if ( (unsigned int)dword_100777C4 >= 0x10 )
    result = sub_1002A4AA((LPVOID)dword_100777B0);
  dword_100777C4 = 15;
  dword_100777C0 = 0;
  LOBYTE(dword_100777B0) = 0;
  if ( (unsigned int)dword_1007779C >= 0x10 )
    result = sub_1002A4AA((LPVOID)dword_10077788);
  dword_1007779C = 15;
  dword_10077798 = 0;
  LOBYTE(dword_10077788) = 0;
  if ( (unsigned int)dword_10077784 >= 0x10 )
    result = sub_1002A4AA((LPVOID)dword_10077770);
  dword_10077784 = 15;
  dword_10077780 = 0;
  LOBYTE(dword_10077770) = 0;
  if ( (unsigned int)dword_1007776C >= 0x10 )
    result = sub_1002A4AA((LPVOID)dword_10077758);
  dword_1007776C = 15;
  dword_10077768 = 0;
  LOBYTE(dword_10077758) = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1002B6E4: using guessed type int __thiscall nullsub_2(_DWORD);
// 10077758: using guessed type int dword_10077758;
// 10077768: using guessed type int dword_10077768;
// 1007776C: using guessed type int dword_1007776C;
// 10077770: using guessed type int dword_10077770;
// 10077780: using guessed type int dword_10077780;
// 10077784: using guessed type int dword_10077784;
// 10077788: using guessed type int dword_10077788;
// 10077798: using guessed type int dword_10077798;
// 1007779C: using guessed type int dword_1007779C;
// 100777B0: using guessed type int dword_100777B0;
// 100777C0: using guessed type int dword_100777C0;
// 100777C4: using guessed type int dword_100777C4;
// 100777E4: using guessed type int dword_100777E4;
// 100777F4: using guessed type int dword_100777F4;
// 100777F8: using guessed type int dword_100777F8;
// 100777FC: using guessed type int dword_100777FC;
// 10077800: using guessed type int dword_10077800;
// 10077804: using guessed type int dword_10077804;
// 10077810: using guessed type int dword_10077810;
// 10077820: using guessed type int dword_10077820;
// 10077824: using guessed type int dword_10077824;
// 10077828: using guessed type int dword_10077828;
// 1007782C: using guessed type int dword_1007782C;
// 10077830: using guessed type int dword_10077830;
// 10077838: using guessed type int dword_10077838;
// 10077844: using guessed type int dword_10077844;
// 10077850: using guessed type int dword_10077850;
// 10077858: using guessed type int dword_10077858;
// 10077968: using guessed type int dword_10077968;
// 1007796C: using guessed type int dword_1007796C;
// 10077970: using guessed type int dword_10077970;

//----- (10021A90) --------------------------------------------------------
void __stdcall sub_10021A90(int a1, int a2, void *a3, int a4, int a5, int a6, unsigned int a7, signed int a8, void *a9, int a10, int a11, int a12, int a13, signed int a14, void *a15, int a16, int a17, int a18, unsigned int a19, unsigned int a20)
{
  int v20; // edx@1
  int ebp0; // ebp@0
  int v22; // edi@1
  unsigned int v23; // esi@1
  int v24; // ecx@3
  unsigned int v25; // eax@5
  char v26; // zf@7
  int v27; // eax@7
  bool v28; // eax@9
  int v29; // edx@13
  int v30; // edi@13
  unsigned int v31; // esi@13
  int v32; // ecx@15
  unsigned int v33; // eax@17
  char v34; // zf@19
  int v35; // eax@19
  bool v36; // eax@21
  unsigned int v37; // [sp-4h] [bp-40h]@1
  int v38; // [sp+Ch] [bp-30h]@30
  unsigned int v39; // [sp+2Ch] [bp-10h]@1
  int v40; // [sp+38h] [bp-4h]@1
  int v41; // [sp+3Ch] [bp+0h]@1

  v39 = (unsigned int)&v41 ^ __security_cookie;
  v37 = (unsigned int)&v41 ^ __security_cookie;
  v40 = 2;
  sub_1002B62D(ebp0, (int)&unk_1007799C);
  LOBYTE(v40) = 3;
  v23 = a19;
  v22 = dword_10077768;
  v20 = (int)&a15;
  if ( a20 >= 0x10 )
    v20 = (int)a15;
  v24 = (int)&dword_10077758;
  if ( (unsigned int)dword_1007776C >= 0x10 )
    v24 = dword_10077758;
  v25 = a19;
  if ( dword_10077768 < a19 )
    v25 = dword_10077768;
  v27 = sub_100099E0(v24, v20, v25);
  v26 = v27 == 0;
  if ( !v27 )
  {
    if ( v22 >= v23 )
      v28 = v22 != v23;
    else
      v28 = -1;
    v26 = v28 == 0;
  }
  if ( !v26 )
    goto LABEL_39;
  v31 = a7;
  v30 = dword_10077780;
  v29 = (int)&a3;
  if ( (unsigned int)a8 >= 0x10 )
    v29 = (int)a3;
  v32 = (int)&dword_10077770;
  if ( (unsigned int)dword_10077784 >= 0x10 )
    v32 = dword_10077770;
  v33 = a7;
  if ( dword_10077780 < a7 )
    v33 = dword_10077780;
  v35 = sub_100099E0(v32, v29, v33);
  v34 = v35 == 0;
  if ( !v35 )
  {
    if ( v30 >= v31 )
      v36 = v30 != v31;
    else
      v36 = -1;
    v34 = v36 == 0;
  }
  if ( v34
    && sub_100036A0((int)&dword_10077788, (int)&a9)
    && dword_100777A0 == a1
    && dword_100777A4 == a2
    && dword_100777C8 & 1 )
  {
    LOBYTE(v40) = 2;
    sub_1002B6D6();
  }
  else
  {
LABEL_39:
    loc_1000AB40(&dword_10077758, &a15, 0, -1, v37);
    loc_1000AB40(&dword_10077770, &a3, 0, -1);
    loc_1000AB40(&dword_10077788, &a9, 0, -1);
    dword_100777A0 = a1;
    dword_100777A4 = a2;
    LOBYTE(v40) = 2;
    sub_1002B6D6();
    v38 = 1;
    sub_10026770((int)&v38, (int)&dword_10077858, a2);
  }
  if ( (unsigned int)a8 >= 0x10 )
    sub_1002A4AA(a3);
  a8 = 15;
  a7 = 0;
  LOBYTE(a3) = 0;
  if ( (unsigned int)a14 >= 0x10 )
    sub_1002A4AA(a9);
  a14 = 15;
  a13 = 0;
  LOBYTE(a9) = 0;
  if ( a20 >= 0x10 )
    sub_1002A4AA(a15);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;
// 10077758: using guessed type int dword_10077758;
// 10077768: using guessed type int dword_10077768;
// 1007776C: using guessed type int dword_1007776C;
// 10077770: using guessed type int dword_10077770;
// 10077780: using guessed type int dword_10077780;
// 10077784: using guessed type int dword_10077784;
// 10077788: using guessed type int dword_10077788;
// 100777A0: using guessed type int dword_100777A0;
// 100777A4: using guessed type int dword_100777A4;
// 100777C8: using guessed type int dword_100777C8;
// 10077858: using guessed type int dword_10077858;

//----- (10021CA0) --------------------------------------------------------
void __thiscall sub_10021CA0(void *this, void *a2, int a3, int a4, int a5, int a6, unsigned int a7)
{
  int ebp0; // ebp@0

  __asm { movsd   [ebp+var_34], xmm1 }
  _ESI = this;
  sub_1002B62D(ebp0, (int)((char *)this + 580));
  __asm
  {
    movsd   xmm0, [ebp+var_34]
    comisd  xmm0, ds:qword_10069470
  }
  if ( !(_CF | _ZF) )
    __asm { movsd   qword ptr [esi+50h], xmm0 }
  if ( a6 )
  {
    if ( (void **)((char *)_ESI + 88) != &a2 )
      loc_1000AB40((char *)_ESI + 88, &a2, 0, -1);
  }
  sub_1002B6D6();
  if ( a7 >= 0x10 )
    sub_1002A4AA(a2);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10021D60) --------------------------------------------------------
int __userpurge sub_10021D60<eax>(int a1<ebx>, char a2)
{
  int ebp0; // ebp@0
  int v3; // ecx@4
  char v5; // [sp+0h] [bp-38h]@5
  unsigned int v6; // [sp+28h] [bp-10h]@1
  int v7; // [sp+34h] [bp-4h]@4
  int v8; // [sp+38h] [bp+0h]@1

  v6 = (unsigned int)&v8 ^ __security_cookie;
  if ( !a2 && dword_10077850 || dword_10077850 == 1 )
  {
    sub_1002B62D(ebp0, (int)&unk_1007799C);
    v7 = 0;
    v3 = dword_1007796C;
    if ( !dword_1007796C )
    {
      sub_1002FFB9((int)&v5, (unsigned int)"wait() cannot be called on a default constructed task.");
      sub_100355DB((int)&v5, (int)&unk_1006D8B8);
    }
    sub_10009F10(v3, a1);
    v7 = -1;
    sub_1002B6D6();
  }
  return dword_100777C8;
}
// 10074200: using guessed type int __security_cookie;
// 100777C8: using guessed type int dword_100777C8;
// 10077850: using guessed type int dword_10077850;
// 1007796C: using guessed type int dword_1007796C;

//----- (10021E10) --------------------------------------------------------
int __userpurge sub_10021E10<eax>(int a1<ebx>, unsigned int a2)
{
  int v2; // esi@3
  char v4; // [sp+4h] [bp-14h]@1
  unsigned int v5; // [sp+8h] [bp-10h]@1
  int v6; // [sp+14h] [bp-4h]@5
  int v7; // [sp+18h] [bp+0h]@1

  v5 = (unsigned int)&v7 ^ __security_cookie;
  sub_1002B6B7((int)&v4, a1, (int)&unk_10077974);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007783C - dword_10077838) >> 2 )
    v2 = 0;
  else
    v2 = *(_DWORD *)(dword_10077838 + 4 * a2);
  v6 = -1;
  sub_1002B6E5(&v4);
  return v2;
}
// 10074200: using guessed type int __security_cookie;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (10021EA0) --------------------------------------------------------
int __stdcall sub_10021EA0(int a1)
{
  int ebp0; // ebp@0
  int i; // esi@1
  int v3; // ecx@5
  int v4; // esi@9
  int v6; // [sp+8h] [bp-30h]@10
  char v7; // [sp+Ch] [bp-2Ch]@13
  unsigned int v8; // [sp+28h] [bp-10h]@1
  int v9; // [sp+34h] [bp-4h]@1
  int v10; // [sp+38h] [bp+0h]@1

  v8 = (unsigned int)&v10 ^ __security_cookie;
  sub_1002B672(ebp0, (int)&unk_10077974);
  v9 = 0;
  for ( i = dword_10077838; i != dword_1007783C; i += 4 )
  {
    if ( !*(_DWORD *)i )
      break;
  }
  *(_DWORD *)(a1 + 8) = &dword_10077758;
  if ( i == dword_1007783C )
  {
    v6 = a1;
    LOBYTE(v9) = 1;
    sub_10022F30((int)&dword_10077838, &v6);
    LOBYTE(v9) = 0;
    if ( v6 )
      (**(void (__stdcall ***)(_DWORD))v6)(1);
    v4 = ((dword_1007783C - dword_10077838) >> 2) - 1;
  }
  else
  {
    v3 = *(_DWORD *)i;
    if ( a1 != *(_DWORD *)i )
    {
      if ( v3 )
        (**(void (__stdcall ***)(_DWORD))v3)(1);
      *(_DWORD *)i = a1;
    }
    v4 = (i - dword_10077838) >> 2;
  }
  v9 = -1;
  sub_1002B6E5(&v7);
  return v4;
}
// 10074200: using guessed type int __security_cookie;
// 10077758: using guessed type int dword_10077758;
// 10077838: using guessed type int dword_10077838;
// 1007783C: using guessed type int dword_1007783C;

//----- (10021F90) --------------------------------------------------------
void __userpurge sub_10021F90(int a1<ecx>, int a2<ebx>, int a3)
{
  int ebp0; // ebp@0
  int v4; // esi@1
  int v5; // ecx@2
  int v6; // eax@5
  int v7; // eax@5
  int v8; // edx@5
  int v10; // esi@7
  int v25; // esi@11
  int v39; // [sp+Ch] [bp-48h]@1
  char v40; // [sp+10h] [bp-44h]@3
  int v41; // [sp+14h] [bp-40h]@11
  char v42; // [sp+1Ch] [bp-38h]@5
  int v43; // [sp+20h] [bp-34h]@7
  unsigned int v44; // [sp+40h] [bp-14h]@1
  int v45; // [sp+50h] [bp-4h]@1

  v44 = (unsigned int)&v39 ^ __security_cookie;
  v4 = a1;
  sub_1002B62D(ebp0, a1 + 580);
  v45 = 0;
  if ( *(_DWORD *)(v4 + 248) )
  {
    v5 = *(_DWORD *)(v4 + 532);
    if ( !v5 )
    {
      sub_1002FFB9((int)&v40, (unsigned int)"wait() cannot be called on a default constructed task.");
      sub_100355DB((int)&v40, (int)&unk_1006D8B8);
    }
    sub_10009F10(v5, a2);
  }
  *(_DWORD *)(v4 + 248) = a3;
  v7 = sub_10022280((void *)v4, (int)&v40);
  LOBYTE(v45) = 1;
  v39 = v4;
  v6 = sub_10025F80(v7, v8, (int)&v42, (int)&v39);
  if ( v4 + 532 != v6 )
    sub_1000A010((void *)(v4 + 532), v6);
  v10 = v43;
  _EDI = -1;
  if ( v43 )
  {
    _EAX = v43 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v10)(v10);
      _EAX = v10 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v10 + 4))(v10, _EDX);
    }
  }
  LOBYTE(v45) = 0;
  v25 = v41;
  if ( v41 )
  {
    _EAX = v41 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v25)(v25);
      _EAX = v25 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v25 + 4))(v25);
    }
  }
  v45 = -1;
  sub_1002B6D6();
}
// 10074200: using guessed type int __security_cookie;

//----- (100220F0) --------------------------------------------------------
BOOL __userpurge sub_100220F0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // eax@2
  int v9; // ST0C_4@2
  int v10; // edi@2
  int v11; // edx@2
  int v12; // ST08_4@2
  int v13; // ST0C_4@2
  int v14; // ST10_4@2
  int v15; // ecx@4
  int v16; // esi@4
  BOOL result; // eax@8
  int v18; // ecx@8
  int v19; // [sp+14h] [bp-14h]@1
  int v20; // [sp+18h] [bp-10h]@2
  int v21; // [sp+24h] [bp-4h]@1

  v7 = a2;
  v19 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a2, 264);
  v6 = v4;
  v21 = 0;
  if ( v4 )
  {
    sub_100221F0(v4, v5);
    v8 = *(_DWORD *)v7;
    v9 = *(_DWORD *)(*(_DWORD *)v7 + 120);
    v20 = 2;
    v10 = v8 + 256;
    sub_1003117C(v6, v9, 0);
    sub_10025510(v11, v6 + 16, v6);
    LOBYTE(v21) = 2;
    *(_DWORD *)v6 = &off_10069200;
    *(_DWORD *)(v6 + 16) = &off_100691A8;
    sub_10025470(v6, (int)&v20, v10, v12, v13, v14);
    v7 = v19;
  }
  else
  {
    v6 = 0;
  }
  v21 = -1;
  v16 = *(_DWORD *)v7;
  v15 = *(_DWORD *)(*(_DWORD *)v7 + 528);
  if ( v6 != v15 )
  {
    if ( v15 )
      (**(void (__stdcall ***)(_DWORD))v15)(1);
    *(_DWORD *)(v16 + 528) = v6;
  }
  v18 = *(_DWORD *)(*(_DWORD *)v7 + 528);
  result = *(_DWORD *)(v18 + 244);
  if ( !result || result == 2 )
  {
    *(_DWORD *)(v18 + 244) = 1;
    result = sub_100311DA((char *)v18);
  }
  return result;
}
// 100691A8: using guessed type int (*off_100691A8)();
// 10069200: using guessed type int (__stdcall *off_10069200)(char);

//----- (100221F0) --------------------------------------------------------
void __thiscall sub_100221F0(int this, int a2)
{
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 88) = 0;
  *(_DWORD *)(this + 92) = 0;
  *(_DWORD *)(this + 100) = 0;
  *(_DWORD *)(this + 104) = 0;
  *(_DWORD *)(this + 136) = 0;
  *(_DWORD *)(this + 160) = 0;
  *(_DWORD *)(this + 184) = 0;
  *(_DWORD *)(this + 216) = 0;
  *(_DWORD *)(this + 220) = 0;
  *(_DWORD *)(this + 240) = 0;
  *(_DWORD *)(this + 256) = 0;
}

//----- (10022280) --------------------------------------------------------
int __thiscall sub_10022280(void *this, int a2)
{
  int *v2; // ecx@1
  int *v4; // ecx@3
  int v5; // eax@3
  int v6; // edx@3
  int v7; // edx@3
  int v8; // eax@5
  int v9; // edx@5
  int v10; // edx@5
  char v11; // cf@5
  int v12; // ecx@6
  int v13; // edx@8
  int v14; // ecx@8
  int v15; // eax@8
  int v16; // edx@8
  int v17; // edx@8
  char v18; // cf@8
  int v19; // edx@10
  int v20; // ecx@10
  int v21; // eax@10
  int v22; // edx@10
  int v23; // edx@10
  char v24; // cf@10
  __int64 v25; // qax@12
  int v26; // eax@12
  int v27; // edx@12
  int v28; // edx@12
  __int64 v29; // qax@12
  int v30; // eax@12
  int v31; // edx@12
  __int64 v32; // qax@12
  int v37; // edx@15
  int v38; // ecx@15
  char v39; // cf@15
  int v40; // edx@17
  int v41; // esi@18
  int v42; // eax@18
  int v43; // edx@18
  int v44; // edx@18
  int v45; // edx@18
  __int16 v61; // [sp-28h] [bp-90h]@18
  int v62; // [sp-24h] [bp-8Ch]@18
  int v63; // [sp-20h] [bp-88h]@18
  int v64; // [sp-1Ch] [bp-84h]@18
  int v65; // [sp-18h] [bp-80h]@18
  signed int v66; // [sp-14h] [bp-7Ch]@18
  char v67; // [sp-10h] [bp-78h]@18
  int v68; // [sp-Ch] [bp-74h]@3
  unsigned int v69; // [sp-4h] [bp-6Ch]@1
  int v70; // [sp+Ch] [bp-5Ch]@18
  DWORD v71; // [sp+14h] [bp-54h]@18
  int v72; // [sp+18h] [bp-50h]@18
  int v73; // [sp+1Ch] [bp-4Ch]@1
  char *v74; // [sp+20h] [bp-48h]@18
  int v75; // [sp+28h] [bp-40h]@1
  int v76; // [sp+2Ch] [bp-3Ch]@18
  int v77; // [sp+30h] [bp-38h]@18
  char v78; // [sp+34h] [bp-34h]@3
  int v79; // [sp+3Ch] [bp-2Ch]@1
  int v80; // [sp+40h] [bp-28h]@1
  __int64 v81; // [sp+44h] [bp-24h]@3
  int v82; // [sp+4Ch] [bp-1Ch]@3
  int v83; // [sp+50h] [bp-18h]@3
  unsigned int v84; // [sp+54h] [bp-14h]@1
  int v85; // [sp+64h] [bp-4h]@1
  int v86; // [sp+68h] [bp+0h]@1

  v84 = (unsigned int)&v86 ^ __security_cookie;
  v69 = (unsigned int)&v86 ^ __security_cookie;
  _ESI = (int)this;
  v75 = 0;
  v79 &= 0xFFFFFE00u;
  v73 = a2;
  v80 = 0;
  v85 = 2;
  v2 = &dword_10076100;
  if ( (unsigned int)dword_10076114 >= 0x10 )
    v2 = (int *)dword_10076100;
  v82 = v82 & 0xFFFFFF04 | 0x104;
  v83 = 0;
  LODWORD(v81) = loc_1000FED0(v2, dword_10076110, v69);
  LOBYTE(v85) = 3;
  v5 = sub_10010C90((int)&v78, v6, (int)"name", v68);
  sub_10010260(v5, v7, (int)&v81);
  LOBYTE(v85) = 2;
  sub_100101D0((int)&v81, a2);
  v4 = &dword_10076130;
  if ( (unsigned int)dword_10076144 >= 0x10 )
    v4 = (int *)dword_10076130;
  v82 = v82 & 0xFFFFFF04 | 0x104;
  v83 = 0;
  LODWORD(v81) = loc_1000FED0(v4, dword_10076140);
  LOBYTE(v85) = 4;
  v8 = sub_10010C90((int)&v78, v9, (int)"version", v68);
  sub_10010260(v8, v10, (int)&v81);
  LOBYTE(v85) = 2;
  sub_100101D0((int)&v81, a2);
  v11 = *(_DWORD *)(_ESI + 20) < 0x10u;
  v82 = v82 & 0xFFFFFF04 | 0x104;
  v83 = 0;
  if ( v11 )
    v12 = _ESI;
  else
    v12 = *(_DWORD *)_ESI;
  LODWORD(v81) = loc_1000FED0(v12, *(_DWORD *)(_ESI + 16));
  LOBYTE(v85) = 5;
  v15 = sub_10010C90((int)&v78, v16, (int)"code", v68);
  sub_10010260(v15, v17, (int)&v81);
  LOBYTE(v85) = 2;
  sub_100101D0((int)&v81, a2);
  v13 = *(_DWORD *)(_ESI + 40);
  v14 = _ESI + 24;
  v18 = *(_DWORD *)(_ESI + 44) < 0x10u;
  v82 = v82 & 0xFFFFFF04 | 0x104;
  v83 = 0;
  if ( !v18 )
    v14 = *(_DWORD *)v14;
  LODWORD(v81) = loc_1000FED0(v14, v13);
  LOBYTE(v85) = 6;
  v21 = sub_10010C90((int)&v78, v22, (int)"broker", v68);
  sub_10010260(v21, v23, (int)&v81);
  LOBYTE(v85) = 2;
  sub_100101D0((int)&v81, a2);
  v19 = *(_DWORD *)(_ESI + 64);
  v20 = _ESI + 48;
  v24 = *(_DWORD *)(_ESI + 68) < 0x10u;
  v82 = v82 & 0xFFFFFF04 | 0x104;
  v83 = 0;
  if ( !v24 )
    v20 = *(_DWORD *)v20;
  LODWORD(v81) = loc_1000FED0(v20, v19);
  LOBYTE(v85) = 7;
  v26 = sub_10010C90((int)&v78, v27, (int)"server", v68);
  sub_10010260(v26, v28, (int)&v81);
  LOBYTE(v85) = 2;
  sub_100101D0((int)&v81, a2);
  v82 = v82 & 0xFFFFFF01 | 1;
  v29 = *(_DWORD *)(_ESI + 72);
  v83 = 0;
  v81 = v29;
  LOBYTE(v85) = 8;
  v30 = sub_10010C90((int)&v78, SHIDWORD(v29), (int)"account", v68);
  sub_10010260(v30, v31, (int)&v81);
  LOBYTE(v85) = 2;
  sub_100101D0((int)&v81, a2);
  v82 = v82 & 0xFFFFFF01 | 1;
  v32 = *(_DWORD *)(_ESI + 76);
  v83 = 0;
  v81 = v32;
  LOBYTE(v85) = 9;
  LODWORD(v25) = sub_10010C90((int)&v78, SHIDWORD(v32), (int)"type", v68);
  sub_10010260(v25, SHIDWORD(v25), (int)&v81);
  LOBYTE(v85) = 2;
  sub_100101D0((int)&v81, a2);
  __asm
  {
    movsd   xmm0, qword ptr [esi+50h]
    comisd  xmm0, ds:qword_10069470
  }
  if ( !_CF )
  {
    v82 = v82 & 0xFFFFFF03 | 3;
    v83 = 0;
    __asm { movsd   [ebp+var_24], xmm0 }
    LOBYTE(v85) = 10;
    LODWORD(v25) = sub_10010C90((int)&v78, SHIDWORD(v25), (int)"balance", v68);
    sub_10010260(v25, SHIDWORD(v25), (int)&v81);
    LOBYTE(v85) = 2;
    sub_100101D0((int)&v81, a2);
  }
  if ( *(_DWORD *)(_ESI + 104) )
  {
    v37 = *(_DWORD *)(_ESI + 104);
    v38 = _ESI + 88;
    v39 = *(_DWORD *)(_ESI + 108) < 0x10u;
    v82 = v82 & 0xFFFFFF04 | 0x104;
    v83 = 0;
    if ( !v39 )
      v38 = *(_DWORD *)v38;
    LODWORD(v81) = loc_1000FED0(v38, v37);
    LOBYTE(v85) = 11;
    LODWORD(v25) = sub_10010C90((int)&v78, v40, (int)"currency", v68);
    sub_10010260(v25, SHIDWORD(v25), (int)&v81);
    LOBYTE(v85) = 2;
    sub_100101D0((int)&v81, a2);
  }
  v82 &= 0xFFFFFE00u;
  v83 = 0;
  LOBYTE(v85) = 13;
  v42 = sub_10010C90((int)&v81, SHIDWORD(v25), (int)"data", v68);
  sub_10010260(v42, v43, (int)&v78);
  v74 = &v67;
  v76 = 0;
  v77 = 0;
  sub_10010010((int)&v67, v44, (int)&v81);
  LOBYTE(v85) = 14;
  v66 = 7;
  v65 = 0;
  v61 = 0;
  loc_10009CC0(&dword_10076118, 0, -1);
  LOBYTE(v85) = 13;
  sub_100036F0(*(_DWORD *)&v61, v62, v63, v64, v65, v66, v67);
  LOBYTE(v85) = 15;
  v71 = sub_10029F21();
  v70 = _ESI;
  v72 = v45;
  sub_10025FC0(v45, (int)&v76, a2, a2, (int)&v70);
  LOBYTE(v85) = 13;
  v41 = v77;
  v75 = 1;
  if ( v77 )
  {
    _EDI = -1;
    _ECX = v77 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v41)(v41);
      _EAX = v41 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v41 + 4))(v41);
    }
  }
  LOBYTE(v85) = 2;
  sub_100101D0((int)&v81, a2);
  LOBYTE(v85) = 0;
  sub_100101D0((int)&v78, a2);
  return a2;
}
// 100036F0: using guessed type _DWORD __cdecl sub_100036F0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);
// 10074200: using guessed type int __security_cookie;
// 10076100: using guessed type int dword_10076100;
// 10076110: using guessed type int dword_10076110;
// 10076114: using guessed type int dword_10076114;
// 10076118: using guessed type int dword_10076118;
// 10076130: using guessed type int dword_10076130;
// 10076140: using guessed type int dword_10076140;
// 10076144: using guessed type int dword_10076144;

//----- (10022720) --------------------------------------------------------
int __thiscall sub_10022720(void *this, char a2, int a3)
{
  __int64 v3; // qax@1
  int v4; // ecx@1
  int v5; // ebx@1
  void *v6; // edi@1
  int v7; // eax@1
  int v8; // edx@1
  int v9; // edx@1
  int v10; // eax@2
  __int64 v11; // ST08_8@2
  __int16 v12; // cx@2
  double v13; // ST08_8@2
  double v14; // st7@2
  __int64 v15; // qax@2
  __int64 v16; // ST08_8@2
  int v17; // edx@3
  int v18; // ecx@3
  int v19; // eax@3
  int v20; // eax@3
  int v21; // edx@5
  int v22; // ecx@5
  int v23; // eax@5
  int v24; // eax@5
  int v25; // eax@7
  int v26; // edx@7
  int v27; // ecx@8
  int v28; // eax@8
  int v29; // edx@8
  int v30; // esi@9
  double v46; // [sp+8h] [bp-15Ch]@1
  char v47; // [sp+34h] [bp-130h]@1
  void *v48; // [sp+60h] [bp-104h]@3
  unsigned int v49; // [sp+74h] [bp-F0h]@3
  void *v50; // [sp+90h] [bp-D4h]@5
  unsigned int v51; // [sp+A4h] [bp-C0h]@5
  char v52; // [sp+F4h] [bp-70h]@7
  char v53; // [sp+FCh] [bp-68h]@7
  int v54; // [sp+100h] [bp-64h]@7
  char v55; // [sp+104h] [bp-60h]@1
  char v56; // [sp+10Ch] [bp-58h]@1
  int v57; // [sp+110h] [bp-54h]@1
  __int64 v58; // [sp+114h] [bp-50h]@1
  int v59; // [sp+11Ch] [bp-48h]@1
  int v60; // [sp+120h] [bp-44h]@1
  int v61; // [sp+124h] [bp-40h]@1
  void *v62; // [sp+128h] [bp-3Ch]@1
  double v63; // [sp+12Ch] [bp-38h]@2
  int v64; // [sp+138h] [bp-2Ch]@1
  char v65; // [sp+13Ch] [bp-28h]@1
  int v66; // [sp+148h] [bp-1Ch]@1
  unsigned int v67; // [sp+150h] [bp-14h]@1
  double *v68; // [sp+154h] [bp-10h]@1
  int v69; // [sp+160h] [bp-4h]@1
  int v70; // [sp+164h] [bp+0h]@1

  v67 = (unsigned int)&v70 ^ __security_cookie;
  v68 = (double *)((char *)&v46 + 4);
  v6 = this;
  v62 = this;
  v69 = 0;
  LOBYTE(v69) = 1;
  v64 = 0;
  v61 = 0;
  v66 = 0;
  loc_10002BC0(&a2, &v65, (unsigned int)&v70 ^ __security_cookie);
  __asm { xorps   xmm0, xmm0 }
  v59 = v59 & 0xFFFFFF02 | 2;
  v60 = 0;
  __asm { movlpd  [ebp+var_50], xmm0 }
  LOBYTE(v69) = 3;
  v7 = sub_10010E40((int)&v65, v8, (int)&v47, (int)"flags", (int)&v58);
  LOBYTE(v69) = 4;
  v5 = loc_10010400(v7);
  LOBYTE(v69) = 3;
  sub_100101D0((int)&v47, v5);
  LOBYTE(v69) = 2;
  sub_100101D0((int)&v58, v5);
  v64 = v5;
  v57 = 0;
  LODWORD(v3) = sub_10010C90((int)&v65, v9, (int)"utc", v4);
  sub_10010010((int)&v55, SHIDWORD(v3), v3);
  LOBYTE(v69) = 5;
  if ( v56 )
  {
    v10 = loc_10010400(&v55);
    v11 = 10000000i64;
    *(_QWORD *)&v63 = *((_QWORD *)v6 + 1) - sub_10039A40((unsigned int)v10, v11);
    v12 = WORD2(v63);
    v63 = (double)*(signed __int64 *)&v63;
    __asm { movsd   xmm0, [ebp+var_38] }
    v63 = (double)9000000000i64;
    __asm
    {
      divsd   xmm0, [ebp+var_38]
      addsd   xmm0, ds:qword_10069498
      movsd   [ebp+var_38], xmm0
    }
    v13 = v63;
    v14 = sub_10059020(v12, v5, v13);
    LODWORD(v15) = sub_1004D276(v14);
    v16 = 9000000000i64;
    v3 = sub_10039A40(v15, v16);
    v4 = *(_DWORD *)v6;
    *(_DWORD *)(*(_DWORD *)v6 + 128) = v3;
    *(_DWORD *)(v4 + 132) = HIDWORD(v3);
  }
  v19 = sub_10010C90((int)&v65, SHIDWORD(v3), (int)"msg1", v4);
  v20 = loc_100102E0(v19, &v48);
  LOBYTE(v69) = 6;
  sub_10018590((void *)(*(_DWORD *)v6 + 136), v20);
  LOBYTE(v69) = 5;
  if ( v49 >= 0x10 )
    sub_1002A4AA(v48);
  v23 = sub_10010C90((int)&v65, v17, (int)"msg2", v18);
  v24 = loc_100102E0(v23, &v50);
  LOBYTE(v69) = 7;
  sub_10018590((void *)(*(_DWORD *)v6 + 180), v24);
  LOBYTE(v69) = 5;
  if ( v51 >= 0x10 )
    sub_1002A4AA(v50);
  v54 = 0;
  v25 = sub_10010C90((int)&v65, v21, (int)"auth_interval", v22);
  sub_10010010((int)&v52, v26, v25);
  LOBYTE(v69) = 8;
  if ( v53 )
  {
    v27 = loc_10010720(&v52);
    v28 = *(_DWORD *)v6;
    HIDWORD(v63) = v29;
    *(_DWORD *)(v28 + 120) = v27;
  }
  LOBYTE(v69) = 5;
  sub_100101D0((int)&v52, v5);
  LOBYTE(v69) = 2;
  sub_100101D0((int)&v55, v5);
  LOBYTE(v69) = 1;
  sub_100101D0((int)&v65, v5);
  *(_DWORD *)(*(_DWORD *)v6 + 112) = v5;
  *(_DWORD *)(*(_DWORD *)v6 + 116) = v61;
  v69 = -1;
  v30 = a3;
  if ( a3 )
  {
    _EDI = -1;
    _ECX = a3 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v30)(v30);
      _EDX = v30 + 8;
      __asm { lock xadd [edx], edi }
      if ( _EDI == 1 )
        (*(void (**)(void))(*(_DWORD *)v30 + 4))();
    }
  }
  return v5;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10022A7D) --------------------------------------------------------
int (*__usercall sub_10022A7D<eax>(int a1<ebp>))()
{
  int v1; // eax@1
  int v3; // esi@1

  v1 = *(_DWORD *)(a1 - 116);
  *(_DWORD *)(a1 - 44) |= 0x2000u;
  *(_DWORD *)(a1 - 64) = *(_DWORD *)(v1 + 16);
  sub_1000AFB0(a1 - 188, (const char *)&unk_1006823C);
  v3 = *(_DWORD *)(a1 - 60);
  *(_BYTE *)(a1 - 4) = 12;
  sub_10018590((void *)(*(_DWORD *)v3 + 136), a1 - 188);
  *(_BYTE *)(a1 - 4) = 9;
  sub_10001880(a1 - 188);
  sub_1000AFB0(a1 - 236, (const char *)&unk_1006823C);
  *(_BYTE *)(a1 - 4) = 13;
  sub_10018590((void *)(*(_DWORD *)v3 + 180), a1 - 236);
  sub_10001880(a1 - 236);
  return loc_10022B00;
}
// 10022B00: using guessed type int loc_10022B00();

//----- (10022B17) --------------------------------------------------------
int (__stdcall *__usercall sub_10022B17<eax>(int a1<ebp>))(char, int)
{
  int v2; // esi@1

  *(_DWORD *)(a1 - 44) |= 0x4000u;
  sub_1000AFB0(a1 - 284, (const char *)&unk_1006823C);
  v2 = *(_DWORD *)(a1 - 60);
  *(_BYTE *)(a1 - 4) = 14;
  sub_10018590((void *)(*(_DWORD *)v2 + 136), a1 - 284);
  *(_BYTE *)(a1 - 4) = 9;
  sub_10001880(a1 - 284);
  sub_1000AFB0(a1 - 328, (const char *)&unk_1006823C);
  *(_BYTE *)(a1 - 4) = 15;
  sub_10018590((void *)(*(_DWORD *)v2 + 180), a1 - 328);
  sub_10001880(a1 - 328);
  return loc_10022A17;
}
// 10022A17: using guessed type int __stdcall loc_10022A17(char, int);

//----- (10022BA0) --------------------------------------------------------
int __userpurge sub_10022BA0<eax>(int a1<ecx>, int a2<edi>, int a3, void *a4, int a5, int a6, int a7, int a8, unsigned int a9, __int64 a10, __int64 a11)
{
  int v11; // eax@1
  int ebp0; // ebp@0
  int v15; // esi@1
  int v16; // ebx@1
  int v17; // eax@2
  int v31; // ecx@10
  int i; // esi@10
  int v33; // eax@11
  int v34; // eax@14
  int v35; // edx@14
  int v36; // edi@14
  int v37; // eax@15
  int v38; // edi@16
  int v39; // esi@17
  int v54; // edi@27
  int v62; // ecx@30
  int v70; // ecx@33
  int v78; // ecx@36
  int v86; // esi@40
  int v87; // eax@41
  char v101; // [sp-2Ch] [bp-9Ch]@4
  int v102; // [sp-28h] [bp-98h]@4
  int v103; // [sp-24h] [bp-94h]@4
  int v104; // [sp-20h] [bp-90h]@4
  unsigned int v105; // [sp-1Ch] [bp-8Ch]@4
  unsigned int v106; // [sp-18h] [bp-88h]@4
  __int64 v107; // [sp-14h] [bp-84h]@4
  __int64 v108; // [sp-Ch] [bp-7Ch]@4
  unsigned int v109; // [sp-4h] [bp-74h]@1
  int v110; // [sp+10h] [bp-60h]@1
  int v111; // [sp+14h] [bp-5Ch]@1
  int v112; // [sp+18h] [bp-58h]@14
  int v113; // [sp+1Ch] [bp-54h]@36
  int v114; // [sp+20h] [bp-50h]@36
  int v115; // [sp+24h] [bp-4Ch]@1
  int v116; // [sp+28h] [bp-48h]@1
  int v117; // [sp+2Ch] [bp-44h]@1
  int v118; // [sp+30h] [bp-40h]@4
  int v119; // [sp+34h] [bp-3Ch]@4
  int v120; // [sp+38h] [bp-38h]@27
  int v121; // [sp+3Ch] [bp-34h]@27
  unsigned int v122; // [sp+5Ch] [bp-14h]@1
  int v123; // [sp+6Ch] [bp-4h]@1
  int v124; // [sp+70h] [bp+0h]@1

  v122 = (unsigned int)&v124 ^ __security_cookie;
  v109 = (unsigned int)&v124 ^ __security_cookie;
  v16 = a1;
  v117 = a1;
  v115 = a3;
  v110 = a3;
  v116 = 0;
  v123 = 1;
  sub_1002B62D(ebp0, a1 + 612);
  LOBYTE(v123) = 2;
  v15 = *(_DWORD *)(v16 + 236);
  v111 = v16 + 236;
  v11 = v117;
  _EBX = -1;
  if ( v15 == *(_DWORD *)(v117 + 240) )
  {
LABEL_10:
    v31 = *(_DWORD *)(v11 + 240);
    for ( i = *(_DWORD *)(v11 + 236); i != v31; i += 8 )
    {
      v33 = *(_DWORD *)(i + 4);
      if ( !v33 )
        break;
      if ( !*(_DWORD *)(v33 + 4) )
        break;
    }
    v34 = sub_1002ADB1(_EDX, v31, -1, a2, 64);
    v36 = v34;
    v112 = v34;
    LOBYTE(v123) = 4;
    if ( v34 )
    {
      *(_DWORD *)(v34 + 40) = 0;
      *(_DWORD *)(v34 + 44) = 0;
      *(_DWORD *)(v34 + 48) = 0;
      *(_DWORD *)(v34 + 56) = 0;
      *(_DWORD *)(v34 + 60) = 0;
      v108 = a11;
      v107 = a10;
      v106 = 15;
      v105 = 0;
      v101 = 0;
      loc_1000AB40(&a4, 0, -1);
      v37 = sub_10001BD0(v36, v36, *(void **)&v101, v102, v103, v104, v105, v106, v107, v108);
    }
    else
    {
      v37 = 0;
    }
    LOBYTE(v123) = 2;
    v120 = 0;
    v121 = 0;
    sub_10026430(v35, (int)&v120, -1, v37);
    LOBYTE(v123) = 5;
    v54 = v121;
    if ( i == *(_DWORD *)(v117 + 240) )
    {
      if ( v121 )
      {
        _EAX = v121 + 8;
        _ECX = 1;
        __asm { lock xadd [eax], ecx }
      }
      v114 = v54;
      v113 = v120;
      LOBYTE(v123) = 6;
      sub_10022FC0(v111, (unsigned int)&v113);
      LOBYTE(v123) = 5;
      v78 = v114;
      if ( v114 )
      {
        _EAX = v114 + 8;
        _EDX = -1;
        __asm { lock xadd [eax], edx }
        if ( _ZF )
          (*(void (__fastcall **)(int, int))(*(_DWORD *)v78 + 4))(v78, _EDX);
      }
      v70 = v120;
    }
    else
    {
      if ( v121 )
      {
        _EAX = v121 + 8;
        _ECX = 1;
        __asm { lock xadd [eax], ecx }
      }
      v62 = *(_DWORD *)(i + 4);
      if ( v62 )
      {
        _EAX = v62 + 8;
        _EDX = -1;
        __asm { lock xadd [eax], edx }
        if ( _ZF )
          (*(void (__fastcall **)(int, int))(*(_DWORD *)v62 + 4))(v62, _EDX);
      }
      v70 = v120;
      *(_DWORD *)(i + 4) = v54;
      *(_DWORD *)i = v70;
    }
    v86 = v115;
    *(_DWORD *)v115 = 0;
    *(_DWORD *)(v86 + 4) = 0;
    if ( (int *)v86 != &v120 )
    {
      v87 = *(_DWORD *)(v86 + 4);
      *(_DWORD *)(v86 + 4) = v54;
      v54 = v87;
      *(_DWORD *)v86 = v70;
    }
    v116 = 1;
    LOBYTE(v123) = 2;
    if ( v54 )
    {
      _EAX = v54 + 4;
      _ECX = -1;
      __asm { lock xadd [eax], ecx }
      if ( _ZF )
      {
        (**(void (__thiscall ***)(_DWORD))v54)(v54);
        _EAX = v54 + 8;
        __asm { lock xadd [eax], ebx }
        if ( _EBX == 1 )
          (*(void (__thiscall **)(int))(*(_DWORD *)v54 + 4))(v54);
      }
    }
    LOBYTE(v123) = 1;
    sub_1002B6D6();
    if ( a9 >= 0x10 )
      sub_1002A4AA(a4);
    return v86;
  }
  while ( 1 )
  {
    v17 = *(_DWORD *)(v15 + 4);
    if ( !v17 || !*(_DWORD *)(v17 + 4) )
      goto LABEL_9;
    v118 = 0;
    v119 = 0;
    sub_100248A0(v15, (int)&v118);
    LOBYTE(v123) = 3;
    v108 = a11;
    v107 = a10;
    v106 = 15;
    v105 = 0;
    v101 = 0;
    loc_1000AB40(&a4, 0, -1);
    if ( sub_10001FA0(v118, *(void **)&v101, v102, v103, v104, v105, v106, v107, v108) )
      break;
    LOBYTE(v123) = 2;
    a2 = v119;
    if ( v119 )
    {
      _EAX = v119 + 4;
      _ECX = -1;
      __asm { lock xadd [eax], ecx }
      if ( _ZF )
      {
        (**(void (__thiscall ***)(_DWORD))a2)(a2);
        _EAX = a2 + 8;
        _EDX = -1;
        __asm { lock xadd [eax], edx }
        if ( _ZF )
          (*(void (__fastcall **)(int, int))(*(_DWORD *)a2 + 4))(a2, _EDX);
      }
    }
LABEL_9:
    v11 = v117;
    v15 += 8;
    if ( v15 == *(_DWORD *)(v117 + 240) )
      goto LABEL_10;
  }
  v38 = v115;
  *(_DWORD *)v115 = 0;
  *(_DWORD *)(v38 + 4) = 0;
  if ( (int *)v38 == &v118 )
  {
    v39 = v119;
  }
  else
  {
    v39 = *(_DWORD *)(v38 + 4);
    *(_DWORD *)(v38 + 4) = v119;
    *(_DWORD *)v38 = v118;
  }
  v116 = 1;
  LOBYTE(v123) = 2;
  if ( v39 )
  {
    _EAX = v39 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v39)(v39);
      _EAX = v39 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v39 + 4))(v39);
    }
  }
  LOBYTE(v123) = 1;
  sub_1002B6D6();
  if ( a9 >= 0x10 )
    sub_1002A4AA(a4);
  return v38;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10022F30) --------------------------------------------------------
int __thiscall sub_10022F30(int this, int *a2)
{
  int result; // eax@1
  int v3; // esi@1
  int v4; // edi@3
  int v5; // edx@5
  int v6; // ecx@5
  int v7; // ecx@9

  v3 = this;
  result = *(_DWORD *)(this + 4);
  if ( (unsigned int)a2 >= result || (this = *(_DWORD *)this, *(_DWORD *)v3 > (unsigned int)a2) )
  {
    if ( result == *(_DWORD *)(v3 + 8) )
      result = loc_10024A90(v3, this);
    v7 = *(_DWORD *)(v3 + 4);
    if ( v7 )
    {
      result = *a2;
      *a2 = 0;
      *(_DWORD *)v7 = result;
    }
  }
  else
  {
    v4 = (signed int)((char *)a2 - this) >> 2;
    if ( result == *(_DWORD *)(v3 + 8) )
      loc_10024A90(v3, *(_DWORD *)v3);
    result = *(_DWORD *)v3;
    v5 = *(_DWORD *)(v3 + 4);
    v6 = *(_DWORD *)v3 + 4 * v4;
    if ( v5 )
    {
      result = *(_DWORD *)v6;
      *(_DWORD *)v6 = 0;
      *(_DWORD *)v5 = result;
      *(_DWORD *)(v3 + 4) += 4;
      return result;
    }
  }
  *(_DWORD *)(v3 + 4) += 4;
  return result;
}

//----- (10022FC0) --------------------------------------------------------
int __thiscall sub_10022FC0(int this, unsigned int a2)
{
  int result; // eax@1
  int v3; // esi@1
  int v4; // edi@3
  int v5; // edi@5
  int v6; // ebx@6
  int v14; // ecx@8
  int v22; // ebx@14
  int v23; // eax@15
  int v24; // edi@15
  int v32; // ecx@17
  int v40; // [sp+14h] [bp+8h]@6
  int v41; // [sp+14h] [bp+8h]@15

  v3 = this;
  result = *(_DWORD *)(this + 4);
  if ( a2 >= result || (this = *(_DWORD *)this, *(_DWORD *)v3 > a2) )
  {
    if ( result == *(_DWORD *)(v3 + 8) )
      result = loc_10024B50(v3, this);
    v22 = *(_DWORD *)(v3 + 4);
    if ( v22 )
    {
      *(_DWORD *)v22 = 0;
      *(_DWORD *)(v22 + 4) = 0;
      v23 = *(_DWORD *)(a2 + 4);
      v24 = *(_DWORD *)a2;
      v41 = v23;
      if ( v23 )
      {
        _EAX = v23 + 8;
        _ECX = 1;
        __asm { lock xadd [eax], ecx }
      }
      v32 = *(_DWORD *)(v22 + 4);
      if ( v32 )
      {
        _EAX = v32 + 8;
        _EDX = -1;
        __asm { lock xadd [eax], edx }
        if ( _ZF )
          (*(void (__fastcall **)(int, int))(*(_DWORD *)v32 + 4))(v32, _EDX);
      }
      result = v41;
      *(_DWORD *)(v22 + 4) = v41;
      *(_DWORD *)v22 = v24;
    }
    goto LABEL_21;
  }
  v4 = (signed int)(a2 - this) >> 3;
  if ( result == *(_DWORD *)(v3 + 8) )
    loc_10024B50(v3, *(_DWORD *)v3);
  result = *(_DWORD *)v3 + 8 * v4;
  v5 = *(_DWORD *)(v3 + 4);
  if ( !v5 )
  {
LABEL_21:
    *(_DWORD *)(v3 + 4) += 8;
    return result;
  }
  *(_DWORD *)v5 = 0;
  *(_DWORD *)(v5 + 4) = 0;
  v6 = *(_DWORD *)(result + 4);
  v40 = *(_DWORD *)result;
  if ( v6 )
  {
    _EAX = v6 + 8;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v14 = *(_DWORD *)(v5 + 4);
  if ( v14 )
  {
    _EAX = v14 + 8;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _ZF )
      (*(void (__fastcall **)(int, int))(*(_DWORD *)v14 + 4))(v14, _EDX);
  }
  result = v40;
  *(_DWORD *)(v5 + 4) = v6;
  *(_DWORD *)v5 = v40;
  *(_DWORD *)(v3 + 4) += 8;
  return result;
}

//----- (100230C0) --------------------------------------------------------
int __usercall sub_100230C0<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // ecx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // eax@1
  int v6; // ecx@3

  v3 = a1;
  *(_DWORD *)a1 = &off_100693C4;
  v5 = *(_DWORD *)(a1 + 96);
  *(_BYTE *)(a1 + 88) = 1;
  (*(void (**)(void))(v5 + 8))();
  (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 24))(v3);
  v4 = v3 + 248;
  v2 = *(_DWORD *)(v3 + 264);
  if ( v2 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v2 + 16))(v2 != v4);
    *(_DWORD *)(v3 + 264) = 0;
  }
  v6 = *(_DWORD *)(v3 + 264);
  if ( v6 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v6 + 16))(v6 != v4);
    *(_DWORD *)(v3 + 264) = 0;
  }
  return sub_10023430(v3, a2);
}
// 100693C4: using guessed type int (__stdcall *off_100693C4)(char);

//----- (10023170) --------------------------------------------------------
signed int __thiscall sub_10023170(void *this, int a2, int a3)
{
  int v3; // eax@1
  void *v4; // esi@1
  signed int result; // eax@2

  v4 = this;
  v3 = (*(int (__stdcall **)(_DWORD, void *))(*(_DWORD *)a3 + 16))(*(_DWORD *)(a2 + 4), this);
  if ( v3 )
  {
    (*(void (__thiscall **)(char *, int))*((void (__thiscall ***)(_DWORD, _DWORD))v4 + 24))((char *)v4 + 96, v3);
    result = 0;
  }
  else
  {
    result = 3;
  }
  return result;
}

//----- (100231B0) --------------------------------------------------------
signed int __thiscall sub_100231B0(void *this, int a2, int a3)
{
  int v3; // eax@1
  void *v4; // esi@1
  signed int result; // eax@2

  v4 = this;
  v3 = (*(int (__stdcall **)(_DWORD, void *))(*(_DWORD *)a3 + 16))(*(_DWORD *)(a2 + 4), this);
  if ( v3 )
  {
    (*(void (__thiscall **)(char *, int))(*((_DWORD *)v4 + 24) + 4))((char *)v4 + 96, v3);
    result = 0;
  }
  else
  {
    result = 3;
  }
  return result;
}

//----- (100231F0) --------------------------------------------------------
char __cdecl sub_100231F0()
{
  return 1;
}

//----- (10023230) --------------------------------------------------------
int __thiscall sub_10023230(int this)
{
  unsigned int v1; // eax@1
  int v2; // edx@1
  unsigned int v3; // ecx@1
  int v4; // esi@1
  int result; // eax@7
  char v6; // [sp+Ch] [bp-1Ch]@6
  int v7; // [sp+18h] [bp-10h]@1
  int v8; // [sp+24h] [bp-4h]@1

  v4 = this;
  v7 = this;
  *(_DWORD *)this = off_100693A0;
  v8 = 0;
  v3 = *(_DWORD *)(this + 12);
  v2 = 0;
  v1 = 0;
  if ( v3 )
  {
    do
    {
      if ( *(_DWORD *)(*(_DWORD *)(v4 + 8) + 4 * v1) )
        ++v2;
      ++v1;
    }
    while ( v1 < v3 );
    if ( v2 )
    {
      sub_1002FFB9((int)&v6, (unsigned int)"Deleting link registry before removing all the links");
      sub_100355DB((int)&v6, (int)&unk_1006D8B8);
    }
  }
  result = *(_DWORD *)(v4 + 8);
  if ( result )
  {
    result = sub_10030383(*(LPVOID *)(v4 + 8));
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
  }
  return result;
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 100693A0: using guessed type int (__stdcall *off_100693A0[3])(int);

//----- (100232E0) --------------------------------------------------------
int __stdcall sub_100232E0(int a1)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
    JUMPOUT(loc_10024C20);
  return result;
}

//----- (10023300) --------------------------------------------------------
char __thiscall sub_10023300(int this, int a2)
{
  char result; // al@2

  if ( a2 )
    result = sub_10024CD0(this, a2);
  else
    result = 0;
  return result;
}

//----- (10023320) --------------------------------------------------------
char __thiscall sub_10023320(void *this, int a2)
{
  bool v2; // eax@2

  if ( a2 )
    v2 = (unsigned int)(*(int (__stdcall **)(int))(*(_DWORD *)this + 32))(a2) < *((_DWORD *)this + 3);
  else
    LOBYTE(v2) = 0;
  return v2;
}

//----- (10023350) --------------------------------------------------------
int __thiscall sub_10023350(int this)
{
  int result; // eax@1
  int v2; // edx@1
  int v3; // ecx@2

  v2 = *(_DWORD *)(this + 12);
  result = 0;
  if ( v2 )
  {
    v3 = *(_DWORD *)(this + 8);
    do
    {
      if ( *(_DWORD *)v3 )
        ++result;
      v3 += 4;
      --v2;
    }
    while ( v2 );
  }
  return result;
}

//----- (10023370) --------------------------------------------------------
int __thiscall sub_10023370(void *this, int a2)
{
  *(_DWORD *)a2 = this;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  (*(void (__stdcall **)(int))(*(_DWORD *)this + 20))(a2 + 4);
  return a2;
}

//----- (100233A0) --------------------------------------------------------
int __thiscall sub_100233A0(int this, int a2)
{
  int v2; // edi@1
  unsigned int v3; // esi@1
  int result; // eax@2
  int v5; // ecx@2

  v2 = this;
  v3 = *(_DWORD *)(this + 12);
  if ( *(_DWORD *)a2 < v3 )
  {
    do
    {
      v5 = *(_DWORD *)a2;
      result = *(_DWORD *)(v2 + 8);
      if ( *(_DWORD *)(result + 4 * *(_DWORD *)a2) )
        break;
      result = v5 + 1;
      *(_DWORD *)a2 = v5 + 1;
    }
    while ( v5 + 1 < v3 );
  }
  return result;
}

//----- (100233D0) --------------------------------------------------------
int __thiscall sub_100233D0(int this, unsigned int a2)
{
  int result; // eax@2

  if ( a2 >= *(_DWORD *)(this + 12) )
    result = 0;
  else
    result = *(_DWORD *)(*(_DWORD *)(this + 8) + 4 * a2);
  return result;
}

//----- (100233F0) --------------------------------------------------------
unsigned int __thiscall sub_100233F0(int this, int a2)
{
  unsigned int result; // eax@1
  unsigned int v3; // edx@1
  int v4; // ecx@2

  v3 = *(_DWORD *)(this + 12);
  result = 0;
  if ( v3 )
  {
    v4 = *(_DWORD *)(this + 8);
    do
    {
      if ( *(_DWORD *)v4 == a2 )
        break;
      ++result;
      v4 += 4;
    }
    while ( result < v3 );
  }
  return result;
}

//----- (10023430) --------------------------------------------------------
int __usercall sub_10023430<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // edi@1
  int v3; // esi@1
  int v4; // ecx@2
  int v5; // ecx@4
  int v6; // ST0C_4@7
  int v7; // ST10_4@7
  int result; // eax@9

  v2 = a1;
  *(_DWORD *)a1 = &off_10069314;
  v3 = *(_DWORD *)(a1 + 84);
  if ( v3 )
  {
    v4 = *(_DWORD *)(v3 + 16);
    if ( v4 )
    {
      (*(void (__stdcall **)(bool))(*(_DWORD *)v4 + 16))(v4 != v3);
      *(_DWORD *)(v3 + 16) = 0;
    }
    v5 = *(_DWORD *)(v3 + 16);
    if ( v5 )
    {
      (*(void (__stdcall **)(bool))(*(_DWORD *)v5 + 16))(v5 != v3);
      *(_DWORD *)(v3 + 16) = 0;
    }
    sub_1002A4AA((LPVOID)v3);
  }
  sub_10031044(a2, v2, 3, v2, (unsigned __int64)v2 >> 32, v6, v7);
  sub_100238D0((void *)(v2 + 96), a2);
  sub_10023230(v2 + 60);
  if ( *(_DWORD *)(v2 + 48) )
  {
    sub_10030383(*(LPVOID *)(v2 + 48));
    *(_DWORD *)(v2 + 48) = 0;
    *(_DWORD *)(v2 + 52) = 0;
    *(_DWORD *)(v2 + 56) = 0;
  }
  result = nullsub_2(v2 + 4);
  *(_DWORD *)v2 = &off_10069284;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1002B6E4: using guessed type int __thiscall nullsub_2(_DWORD);
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 10069284: using guessed type int (__stdcall *off_10069284)(char);
// 10069314: using guessed type int (__stdcall *off_10069314)(char);

//----- (100236B0) --------------------------------------------------------
signed int __stdcall sub_100236B0(int a1, int a2)
{
  return 1;
}

//----- (100236C0) --------------------------------------------------------
int __thiscall sub_100236C0(void *this, int a2)
{
  int v2; // ebx@1
  int ebp0; // ebp@0
  int v4; // esi@1
  char v6; // [sp+Ch] [bp-2Ch]@2
  unsigned int v7; // [sp+28h] [bp-10h]@1
  int v8; // [sp+34h] [bp-4h]@2
  int v9; // [sp+38h] [bp+0h]@1

  v7 = (unsigned int)&v9 ^ __security_cookie;
  v2 = (int)this;
  v4 = (int)((char *)this + 4);
  if ( a2 )
  {
    sub_1002B589(ebp0, (int)((char *)this + 4));
    v8 = 0;
    (**(void (__stdcall ***)(_DWORD))(v4 + 56))(a2);
    ++*(_DWORD *)(v4 + 40);
    v8 = -1;
    sub_1002B6DD(&v6);
    (*(void (__thiscall **)(int, _DWORD))(*(_DWORD *)a2 + 32))(a2, *(_DWORD *)(v2 + 80));
    sub_10025860(v2 + 4);
  }
  return sub_10031044(v2, a2, 5, a2, (unsigned __int64)a2 >> 32, v2, (unsigned __int64)v2 >> 32);
}
// 10074200: using guessed type int __security_cookie;

//----- (10023770) --------------------------------------------------------
char __userpurge sub_10023770<al>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // edi@1

  v4 = a1;
  sub_10031044(a2, a1, 6, a3, (unsigned __int64)a3 >> 32, a1, (unsigned __int64)a1 >> 32);
  return sub_10025010(v4 + 4, a3);
}

//----- (100237A0) --------------------------------------------------------
void __thiscall sub_100237A0(void *this)
{
  int v1; // eax@1
  void *v2; // edi@1
  void *v3; // ecx@2
  int v4; // esi@2
  int (__stdcall **v5)(char); // [sp+8h] [bp-2Ch]@1
  void *v6; // [sp+Ch] [bp-28h]@1
  unsigned int v7; // [sp+10h] [bp-24h]@2
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  unsigned int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+30h] [bp-4h]@1
  int v13; // [sp+34h] [bp+0h]@1

  v11 = (unsigned int)&v13 ^ __security_cookie;
  v2 = this;
  v6 = 0;
  v8 = 0;
  v10 = 0;
  sub_100250F0((int)((char *)this + 4), (int)&v5);
  v12 = 0;
  v1 = v9;
  while ( 1 )
  {
    v3 = v6;
    v4 = (int)&v10;
    if ( v1 < v7 )
      v4 = (int)((char *)v6 + 4 * v1);
    if ( !*(_DWORD *)v4 )
      break;
    if ( v1 < v7 )
    {
      (*(void (__stdcall **)(void *))(**((_DWORD **)v6 + v1) + 8))(v2);
      v1 = v9++ + 1;
    }
    else
    {
      (*(void (__stdcall **)(void *))(*(_DWORD *)v10 + 8))(v2);
      v1 = v9++ + 1;
    }
  }
  v5 = &off_10069040;
  v12 = 1;
  if ( v8 )
  {
    sub_10025860(v8);
    v3 = v6;
  }
  if ( v3 )
    sub_10030383(v3);
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 10069040: using guessed type int (__stdcall *off_10069040)(char);
// 10074200: using guessed type int __security_cookie;

//----- (100238C0) --------------------------------------------------------
char __cdecl sub_100238C0()
{
  return 0;
}

//----- (100238D0) --------------------------------------------------------
void __usercall sub_100238D0(void *a1<ecx>, int a2<ebx>)
{
  int v2; // ecx@1
  int v3; // edi@1
  void *v4; // esi@1
  int v5; // ecx@3
  int v6; // ecx@5
  int v7; // edi@5
  int v8; // ecx@7
  int v9; // ecx@9
  int v10; // edi@9
  int v11; // ecx@11

  v4 = a1;
  *(_DWORD *)a1 = &off_1006926C;
  sub_10023BE0(a1);
  v3 = (int)((char *)v4 + 128);
  v2 = *((_DWORD *)v4 + 36);
  if ( v2 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v2 + 16))(v2 != v3);
    *((_DWORD *)v4 + 36) = 0;
  }
  v5 = *((_DWORD *)v4 + 36);
  if ( v5 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v5 + 16))(v5 != v3);
    *((_DWORD *)v4 + 36) = 0;
  }
  v7 = (int)((char *)v4 + 104);
  v6 = *((_DWORD *)v4 + 30);
  if ( v6 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v6 + 16))(v6 != v7);
    *((_DWORD *)v4 + 30) = 0;
  }
  v8 = *((_DWORD *)v4 + 30);
  if ( v8 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v8 + 16))(v8 != v7);
    *((_DWORD *)v4 + 30) = 0;
  }
  v10 = (int)((char *)v4 + 80);
  v9 = *((_DWORD *)v4 + 24);
  if ( v9 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v9 + 16))(v9 != v10);
    *((_DWORD *)v4 + 24) = 0;
  }
  v11 = *((_DWORD *)v4 + 24);
  if ( v11 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v11 + 16))(v11 != v10);
    *((_DWORD *)v4 + 24) = 0;
  }
  nullsub_2((char *)v4 + 24);
  sub_10025F00((int)((char *)v4 + 4), a2);
}
// 1002B6E4: using guessed type int __thiscall nullsub_2(_DWORD);
// 1006926C: using guessed type void *off_1006926C;

//----- (10023A00) --------------------------------------------------------
void __thiscall sub_10023A00(int this, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // esi@1
  int v5; // ecx@2
  int v6; // ecx@4
  int v7; // ecx@11
  int v8; // ecx@13
  int v9; // eax@15
  int v10; // [sp-4h] [bp-10h]@7

  v3 = this;
  v4 = this + 104;
  if ( this + 104 != a2 )
  {
    v5 = *(_DWORD *)(this + 120);
    if ( v5 )
    {
      (*(void (__stdcall **)(bool))(*(_DWORD *)v5 + 16))(v5 != v4);
      *(_DWORD *)(v4 + 16) = 0;
    }
    v6 = *(_DWORD *)(a2 + 16);
    if ( v6 )
    {
      if ( v6 == a2 )
        v10 = v4;
      else
        v10 = 0;
      *(_DWORD *)(v4 + 16) = (**(int (__stdcall ***)(_DWORD))v6)(v10);
    }
    else
    {
      *(_DWORD *)(v4 + 16) = 0;
    }
  }
  if ( v3 + 128 != a3 )
  {
    v7 = *(_DWORD *)(v3 + 144);
    if ( v7 )
    {
      (*(void (__stdcall **)(bool))(*(_DWORD *)v7 + 16))(v7 != v3 + 128);
      *(_DWORD *)(v3 + 144) = 0;
    }
    v8 = *(_DWORD *)(a3 + 16);
    if ( v8 )
    {
      v9 = *(_DWORD *)v8;
      if ( v8 == a3 )
        *(_DWORD *)(v3 + 144) = (*(int (__stdcall **)(int))v9)(v3 + 128);
      else
        *(_DWORD *)(v3 + 144) = (*(int (__stdcall **)(_DWORD))v9)(0);
    }
    else
    {
      *(_DWORD *)(v3 + 144) = 0;
    }
  }
}

//----- (10023BE0) --------------------------------------------------------
void __thiscall sub_10023BE0(void *this)
{
  int ebp0; // ebp@0
  void *v2; // esi@1
  char v10; // zf@1
  char v11; // [sp+8h] [bp-44h]@1
  char v12; // [sp+Ch] [bp-40h]@2
  int v13; // [sp+14h] [bp-38h]@1
  int (__usercall *v14)<eax>(int<ebx>, int<ebp>, int<edi>); // [sp+18h] [bp-34h]@1
  unsigned int v15; // [sp+38h] [bp-14h]@1
  int v16; // [sp+48h] [bp-4h]@3

  v15 = (unsigned int)&v11 ^ __security_cookie;
  v2 = this;
  _EAX = (int)((char *)this + 68);
  _ECX = 1;
  __asm { lock xadd [eax], ecx }
  v10 = *((_DWORD *)v2 + 18) == 0;
  v13 = 0;
  v14 = sub_10031170;
  if ( !v10 )
  {
    do
      sub_100282E0((int)&v12);
    while ( *((_DWORD *)v2 + 18) );
  }
  sub_1002B544(ebp0, (int)((char *)v2 + 24));
  v16 = 0;
  sub_10025170(v2);
  v16 = -1;
  sub_1002B6D6();
}
// 10074200: using guessed type int __security_cookie;

//----- (10023CA0) --------------------------------------------------------
int __fastcall sub_10023CA0(int a1)
{
  int result; // eax@1
  int v2; // ebx@1
  __int64 v3; // qdi@1
  int v4; // ST10_4@1
  int v5; // ST14_4@1
  int v6; // eax@1
  int v7; // ST10_4@1

  v2 = a1;
  v3 = a1;
  sub_10031044(a1, a1, 1, a1, (unsigned __int64)a1 >> 32, v4, v5);
  v6 = loc_10025270(v2);
  sub_10031044(v2, v3, 2, v3, SHIDWORD(v3), v6, v7);
  result = v2 + 72;
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  return result;
}

//----- (10023CE0) --------------------------------------------------------
int __stdcall sub_10023CE0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // ecx@1

  result = a1;
  v4 = a1 + 4 * (a2 + 2);
  if ( v4 )
  {
    result = *(_DWORD *)a3;
    *(_DWORD *)v4 = *(_DWORD *)a3;
  }
  return result;
}

//----- (10023D00) --------------------------------------------------------
int __stdcall sub_10023D00(int a1, int a2, int a3)
{
  int result; // eax@2

  if ( a1 )
  {
    result = *(_DWORD *)(a2 + 4 * a3 + 8);
    *(_DWORD *)a1 = result;
  }
  return result;
}

//----- (10023D60) --------------------------------------------------------
int __stdcall sub_10023D60(void *a1)
{
  return sub_1002A4AA(a1);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10023D90) --------------------------------------------------------
void __usercall sub_10023D90(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // esi@1
  int v4; // ecx@3
  int v5; // ecx@3
  int v6; // [sp+10h] [bp-10h]@6
  int v7; // [sp+1Ch] [bp-4h]@1

  v3 = a1;
  *(_DWORD *)a1 = &off_10069200;
  *(_DWORD *)(a1 + 16) = &off_100691A8;
  v7 = 1;
  if ( *(_DWORD *)(a1 + 244) == 1 )
    sub_1003123D(a1);
  (*(void (__thiscall **)(int))(*(_DWORD *)(v3 + 40) + 8))(v3 + 40);
  (*(void (__thiscall **)(int))(*(_DWORD *)(v3 + 16) + 12))(v3 + 16);
  sub_10025C00(v3 + 16, v5);
  v4 = *(_DWORD *)(v3 + 240);
  if ( v4 )
    (*(void (__stdcall **)(signed int))(*(_DWORD *)v4 + 4))(1);
  if ( *(_BYTE *)(v3 + 253) )
  {
    v6 = *(_DWORD *)(v3 + 256);
    sub_100348B8(&v6);
  }
  LOBYTE(v7) = 0;
  sub_10024130(v3 + 16, a2, a3);
  v7 = -1;
  sub_1003119B(v3);
}
// 100691A8: using guessed type int (*off_100691A8)();
// 10069200: using guessed type int (__stdcall *off_10069200)(char);

//----- (10023E50) --------------------------------------------------------
int __thiscall sub_10023E50(int this, int a2)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 224);
  if ( result && a2 == *(_DWORD *)(result + 4) )
    *(_DWORD *)(this + 224) = 0;
  else
    result = 0;
  return result;
}

//----- (10023E80) --------------------------------------------------------
char __thiscall sub_10023E80(int this, int a2)
{
  int v2; // eax@1

  v2 = *(_DWORD *)(this + 224);
  return v2 && *(_DWORD *)(v2 + 4) == a2;
}

//----- (10023EB0) --------------------------------------------------------
int __thiscall sub_10023EB0(void *this)
{
  return (*(int (**)(void))(*(_DWORD *)this + 48))();
}

//----- (10023F10) --------------------------------------------------------
int __thiscall sub_10023F10(int this, int a2)
{
  int v2; // esi@1
  int result; // eax@2

  v2 = *(_DWORD *)(this + 224);
  if ( v2 )
    result = (*(int (__stdcall **)(int, int))(*(_DWORD *)a2 + 4))(v2, this != 16 ? this : 0);
  return result;
}

//----- (10023F40) --------------------------------------------------------
unsigned int __userpurge sub_10023F40<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  unsigned int result; // eax@1
  int v4; // esi@1
  int v5; // eax@2
  int v6; // eax@3
  int v7; // ecx@3
  int v8; // ST00_4@5
  int v9; // [sp+4h] [bp-10h]@2
  int v10; // [sp+8h] [bp-Ch]@2
  unsigned int i; // [sp+Ch] [bp-8h]@2
  unsigned int v12; // [sp+10h] [bp-4h]@1
  int v13; // [sp+14h] [bp+0h]@1

  result = (unsigned int)&v13 ^ __security_cookie;
  v12 = (unsigned int)&v13 ^ __security_cookie;
  v4 = a1;
  if ( !*(_DWORD *)(a1 + 224) )
  {
    *(_DWORD *)(a1 + 224) = sub_100253D0(a1 - 16, a2);
    v5 = *(_DWORD *)(v4 + 12);
    v9 = 0;
    i = 0;
    (*(void (__stdcall **)(int *))(v5 + 16))(&v9);
    result = (*(int (__stdcall **)(int))(*(_DWORD *)v9 + 24))(v10);
    for ( i = result; result; i = result )
    {
      v6 = (*(int (__stdcall **)(int))(*(_DWORD *)v9 + 24))(v10);
      v7 = 0;
      if ( v4 != 16 )
        v7 = v4;
      v8 = *(_DWORD *)(v4 + 224);
      i = v6;
      (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v6 + 4))(v6, v8, v7);
      ++v10;
      (*(void (__stdcall **)(int *))(*(_DWORD *)v9 + 20))(&v10);
      result = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)v9 + 24))(v10);
    }
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;

//----- (10024000) --------------------------------------------------------
int __thiscall sub_10024000(int this)
{
  return (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)(this + 16) + 84))(this + 16, 0);
}

//----- (10024090) --------------------------------------------------------
char __thiscall sub_10024090(int this, int a2)
{
  char result; // al@3

  if ( a2 && *(_DWORD *)(this + 4) == a2 )
  {
    *(_DWORD *)(this + 4) = 0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100240C0) --------------------------------------------------------
char __thiscall sub_100240C0(int this, int a2)
{
  return a2 && *(_DWORD *)(this + 4) == a2;
}

//----- (100240E0) --------------------------------------------------------
bool __thiscall sub_100240E0(int this)
{
  return *(_DWORD *)(this + 4) != 0;
}

//----- (100240F0) --------------------------------------------------------
int __thiscall sub_100240F0(int this, int a2)
{
  int result; // eax@2

  if ( !*(_DWORD *)(this + 4) )
  {
    result = a2;
    ++*(_DWORD *)result;
  }
  return result;
}

//----- (10024110) --------------------------------------------------------
int __thiscall sub_10024110(int this, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = 0;
  else
    result = *(_DWORD *)(this + 4);
  return result;
}

//----- (10024130) --------------------------------------------------------
void __usercall sub_10024130(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // esi@1
  int v4; // ST0C_4@1
  int v5; // ST10_4@1
  char v6; // zf@1
  char v7; // [sp+8h] [bp-1Ch]@2
  int v8; // [sp+14h] [bp-10h]@1
  int v9; // [sp+20h] [bp-4h]@1

  v3 = a1;
  v8 = a1;
  *(_DWORD *)a1 = &off_10069128;
  v9 = 3;
  sub_10031044(a2, a3, 3, a1, (unsigned __int64)a1 >> 32, v4, v5);
  nullsub_2(v3 + 176);
  sub_100238D0((void *)(v3 + 24), a2);
  LOBYTE(v9) = 0;
  v6 = *(_DWORD *)(v3 + 16) == 0;
  *(_DWORD *)(v3 + 12) = &off_10069188;
  if ( !v6 )
  {
    sub_1002FFB9((int)&v7, (unsigned int)"Deleting link registry before removing all the links");
    sub_100355DB((int)&v7, (int)&unk_1006D8B8);
  }
  *(_DWORD *)v3 = &off_10069340;
}
// 1002B6E4: using guessed type int __thiscall nullsub_2(_DWORD);
// 10069128: using guessed type int (__stdcall *off_10069128)(char);
// 10069188: using guessed type void *off_10069188;
// 10069340: using guessed type int (__stdcall *off_10069340)(char);

//----- (100241E0) --------------------------------------------------------
void __thiscall sub_100241E0(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1
  int (__stdcall **v4)(char); // [sp+8h] [bp-3Ch]@2
  int v5; // [sp+14h] [bp-30h]@2
  char v6; // [sp+18h] [bp-2Ch]@3
  unsigned int v7; // [sp+34h] [bp-10h]@1
  int v8; // [sp+40h] [bp-4h]@1
  int v9; // [sp+44h] [bp+0h]@1

  v7 = (unsigned int)&v9 ^ __security_cookie;
  v3 = this;
  sub_1002B589(ebp0, (int)((char *)this + 176));
  v8 = 0;
  if ( !a2 )
  {
    v5 = (int)"_PTarget";
    sub_1002AEA4((int)&v4, &v5);
    v4 = &off_100602FC;
    sub_100355DB((int)&v4, (int)&unk_1006D8F4);
  }
  (*(void (__thiscall **)(char *, int))*((void (__thiscall ***)(_DWORD, _DWORD))v3 + 3))((char *)v3 + 12, a2);
  (*(void (__thiscall **)(int, void *))(*(_DWORD *)a2 + 16))(a2, v3);
  (*(void (__thiscall **)(void *, int))(*(_DWORD *)v3 + 40))(v3, a2);
  v8 = -1;
  sub_1002B6DD(&v6);
}
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);
// 10074200: using guessed type int __security_cookie;

//----- (100242A0) --------------------------------------------------------
void __thiscall sub_100242A0(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v3; // edi@1
  unsigned int v4; // [sp-4h] [bp-48h]@1
  int (__stdcall **v5)(char); // [sp+8h] [bp-3Ch]@2
  int v6; // [sp+14h] [bp-30h]@2
  char v7; // [sp+18h] [bp-2Ch]@5
  unsigned int v8; // [sp+34h] [bp-10h]@1
  int v9; // [sp+40h] [bp-4h]@1
  int v10; // [sp+44h] [bp+0h]@1

  v8 = (unsigned int)&v10 ^ __security_cookie;
  v4 = (unsigned int)&v10 ^ __security_cookie;
  v3 = this;
  sub_1002B589(ebp0, (int)((char *)this + 176));
  v9 = 0;
  if ( !a2 )
  {
    v6 = (int)"_PTarget";
    sub_1002AEA4((int)&v5, &v6);
    v5 = &off_100602FC;
    sub_100355DB((int)&v5, (int)&unk_1006D8F4);
  }
  if ( (unsigned __int8)(*(int (__thiscall **)(char *, int, unsigned int))(*((_DWORD *)v3 + 3) + 4))(
                          (char *)v3 + 12,
                          a2,
                          v4) )
    (*(void (__thiscall **)(int, void *))(*(_DWORD *)a2 + 20))(a2, v3);
  v9 = -1;
  sub_1002B6DD(&v7);
}
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);
// 10074200: using guessed type int __security_cookie;

//----- (10024360) --------------------------------------------------------
void __thiscall sub_10024360(void *this)
{
  int ebp0; // ebp@0
  void *v2; // esi@1
  unsigned int v3; // ST04_4@1
  int v4; // eax@1
  int v5; // eax@2
  int v6; // edx@2
  char v7; // [sp+4h] [bp-38h]@3
  int v8; // [sp+20h] [bp-1Ch]@1
  int v9; // [sp+24h] [bp-18h]@1
  int i; // [sp+28h] [bp-14h]@1
  unsigned int v11; // [sp+2Ch] [bp-10h]@1
  int v12; // [sp+38h] [bp-4h]@1
  int v13; // [sp+3Ch] [bp+0h]@1

  v11 = (unsigned int)&v13 ^ __security_cookie;
  v3 = (unsigned int)&v13 ^ __security_cookie;
  v2 = this;
  sub_1002B589(ebp0, (int)((char *)this + 176));
  v12 = 0;
  v4 = *((_DWORD *)v2 + 3);
  v8 = 0;
  i = 0;
  (*(void (__thiscall **)(char *, int *, unsigned int))(v4 + 16))((char *)v2 + 12, &v8, v3);
  for ( i = (*(int (__stdcall **)(int))(*(_DWORD *)v8 + 24))(v9);
        i;
        i = (*(int (__stdcall **)(int))(*(_DWORD *)v8 + 24))(v9) )
  {
    v5 = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)v8 + 24))(v9);
    v6 = *(_DWORD *)v2;
    i = v5;
    (*(void (__thiscall **)(void *, int))(v6 + 8))(v2, v5);
    ++v9;
    (*(void (__stdcall **)(int *))(*(_DWORD *)v8 + 20))(&v9);
  }
  v12 = -1;
  sub_1002B6DD(&v7);
}
// 10074200: using guessed type int __security_cookie;

//----- (10024490) --------------------------------------------------------
char __thiscall sub_10024490(void *this, int a2, int a3)
{
  int ebp0; // ebp@0
  void *v4; // esi@1
  void *v5; // ecx@4
  char v7; // al@6
  int (__stdcall **v8)(char); // [sp+Ch] [bp-3Ch]@2
  int v9; // [sp+18h] [bp-30h]@2
  char v10; // [sp+1Ch] [bp-2Ch]@4
  unsigned int v11; // [sp+38h] [bp-10h]@1
  int v12; // [sp+44h] [bp-4h]@1
  int v13; // [sp+48h] [bp+0h]@1

  v11 = (unsigned int)&v13 ^ __security_cookie;
  v4 = this;
  sub_1002B589(ebp0, (int)((char *)this + 176));
  v12 = 0;
  if ( !a3 )
  {
    v9 = (int)"_PTarget";
    sub_1002AEA4((int)&v8, &v9);
    v8 = &off_100602FC;
    sub_100355DB((int)&v8, (int)&unk_1006D8F4);
  }
  if ( *((_DWORD *)v4 + 1) )
  {
    v12 = -1;
    v5 = &v10;
LABEL_5:
    sub_1002B6DD(v5);
    return 0;
  }
  v7 = (*(int (__thiscall **)(void *, int))(*(_DWORD *)v4 + 52))(v4, a2);
  v12 = -1;
  v5 = &v10;
  if ( !v7 )
    goto LABEL_5;
  *((_DWORD *)v4 + 1) = a3;
  *((_DWORD *)v4 + 2) = a2;
  sub_1002B6DD(&v10);
  return 1;
}
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);
// 10074200: using guessed type int __security_cookie;

//----- (10024570) --------------------------------------------------------
void __thiscall sub_10024570(void *this, int a2, int a3)
{
  int v3; // ecx@1
  int ebp0; // ebp@0
  void *v5; // esi@1
  int v6; // eax@3
  int v7; // edx@6
  int v8; // eax@8
  int v9; // esi@8
  int v10; // ecx@8
  int v11; // eax@12
  unsigned int v12; // [sp-4Ch] [bp-90h]@8
  void *v13; // [sp-48h] [bp-8Ch]@8
  int *v14; // [sp-8h] [bp-4Ch]@8
  unsigned int v15; // [sp-4h] [bp-48h]@1
  int (__stdcall **v16)(char); // [sp+8h] [bp-3Ch]@2
  int v17; // [sp+14h] [bp-30h]@2
  char v18; // [sp+18h] [bp-2Ch]@7
  unsigned int v19; // [sp+34h] [bp-10h]@1
  int v20; // [sp+40h] [bp-4h]@1
  int v21; // [sp+44h] [bp+0h]@1

  v19 = (unsigned int)&v21 ^ __security_cookie;
  v15 = (unsigned int)&v21 ^ __security_cookie;
  v5 = this;
  sub_1002B589(ebp0, (int)((char *)this + 176));
  v3 = a3;
  v20 = 0;
  if ( !a3 )
  {
    v17 = (int)"_PTarget";
    sub_1002AEA4((int)&v16, &v17);
    v16 = &off_100602FC;
    sub_100355DB((int)&v16, (int)&unk_1006D8F4);
  }
  v6 = *((_DWORD *)v5 + 1);
  if ( v6 && v3 == v6 )
  {
    if ( (*(int (__thiscall **)(void *, int, unsigned int))(*(_DWORD *)v5 + 56))(v5, a2, v15) )
    {
      v7 = *(_DWORD *)v5;
      *((_DWORD *)v5 + 1) = 0;
      (*(void (__thiscall **)(void *))(v7 + 64))(v5);
    }
    v20 = -1;
    sub_1002B6DD(&v18);
  }
  else
  {
    sub_1002FF15((int)&v16);
    sub_100355DB((int)&v16, (int)&unk_1006D9DC);
    __asm { int     3               ; Trap to Debugger }
    v14 = &v21;
    v19 = (unsigned int)&v21 ^ __security_cookie;
    v13 = v5;
    v12 = (unsigned int)&v21 ^ __security_cookie;
    v9 = v10;
    sub_1002B589((int)&v14, v10 + 176);
    v8 = a3;
    v20 = 0;
    if ( !a3 )
    {
      v17 = (int)"_PTarget";
      sub_1002AEA4((int)&v16, &v17);
      v16 = &off_100602FC;
      sub_100355DB((int)&v16, (int)&unk_1006D8F4);
    }
    if ( v8 != *(_DWORD *)(v9 + 4) )
    {
      sub_1002FF15((int)&v16);
      sub_100355DB((int)&v16, (int)&unk_1006D9DC);
    }
    (*(void (__thiscall **)(int, int, unsigned int, void *))(*(_DWORD *)v9 + 60))(v9, a2, v12, v13);
    v11 = *(_DWORD *)v9;
    *(_DWORD *)(v9 + 4) = 0;
    (*(void (__thiscall **)(int))(v11 + 64))(v9);
    v20 = -1;
    sub_1002B6DD(&v18);
  }
}
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);
// 10074200: using guessed type int __security_cookie;

//----- (10024720) --------------------------------------------------------
int __thiscall sub_10024720(void *this, int a2)
{
  int result; // eax@1

  _ECX = (int)((char *)this + 216);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (10024740) --------------------------------------------------------
int __thiscall sub_10024740(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1
  int result; // eax@3
  char v11; // [sp+8h] [bp-2Ch]@2
  unsigned int v12; // [sp+24h] [bp-10h]@1
  int v13; // [sp+30h] [bp-4h]@2
  int v14; // [sp+34h] [bp+0h]@1

  v12 = (unsigned int)&v14 ^ __security_cookie;
  v3 = this;
  if ( a2 )
  {
    sub_1002B589(ebp0, (int)((char *)this + 176));
    v13 = 0;
    (*(void (__thiscall **)(void *, int))(*(_DWORD *)v3 + 44))(v3, a2);
    v13 = -1;
    sub_1002B6DD(&v11);
  }
  result = (int)((char *)v3 + 216);
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  return result;
}
// 10074200: using guessed type int __security_cookie;

//----- (100247D0) --------------------------------------------------------
int __thiscall sub_100247D0(void *this, int a2)
{
  int result; // eax@2

  if ( !*((_DWORD *)this + 1) )
    result = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)this + 76))(0);
  return result;
}

//----- (100247E0) --------------------------------------------------------
int __thiscall sub_100247E0(void *this, int a2)
{
  int result; // eax@2

  if ( *((_DWORD *)this + 1) == a2 )
    result = (*(int (__stdcall **)(_DWORD, int))(*(_DWORD *)this + 28))(*((_DWORD *)this + 2), a2);
  return result;
}

//----- (10024860) --------------------------------------------------------
int __thiscall sub_10024860(int this)
{
  return (*(int (**)(void))(*(_DWORD *)(this + 24) + 4))();
}

//----- (10024870) --------------------------------------------------------
int __thiscall sub_10024870(int this)
{
  return (**(int (***)(void))(this + 24))();
}

//----- (100248A0) --------------------------------------------------------
int __thiscall sub_100248A0(int this, int a2)
{
  sub_10026000(a2, this, this);
  return a2;
}

//----- (100248C0) --------------------------------------------------------
void *__userpurge sub_100248C0<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_100230C0(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100248F0) --------------------------------------------------------
void *__thiscall sub_100248F0(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_10023230(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10024920) --------------------------------------------------------
void *__thiscall sub_10024920(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10069340;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10069340: using guessed type int (__stdcall *off_10069340)(char);

//----- (10024950) --------------------------------------------------------
void *__userpurge sub_10024950<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_10023430(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10024980) --------------------------------------------------------
void *__thiscall sub_10024980(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10069284;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10069284: using guessed type int (__stdcall *off_10069284)(char);

//----- (100249B0) --------------------------------------------------------
void *__userpurge sub_100249B0<eax>(void *a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = a1;
  sub_100238D0(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100249E0) --------------------------------------------------------
void *__userpurge sub_100249E0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  void *v4; // esi@1

  v4 = (void *)a1;
  sub_10023D90(a1, a2, a3);
  if ( a4 & 1 )
    sub_1002A4AA(v4);
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10024A60) --------------------------------------------------------
void *__userpurge sub_10024A60<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  void *v4; // esi@1

  v4 = (void *)a1;
  sub_10024130(a1, a2, a3);
  if ( a4 & 1 )
    sub_1002A4AA(v4);
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10024B00) --------------------------------------------------------
int __thiscall sub_10024B00(int this)
{
  int v1; // edi@1
  int v2; // esi@1
  int i; // ebx@2
  int result; // eax@6

  v1 = this;
  v2 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    for ( i = *(_DWORD *)(this + 4); v2 != i; v2 += 4 )
    {
      if ( *(_DWORD *)v2 )
        (***(void (__stdcall ****)(_DWORD))v2)(1);
    }
    result = sub_1002A4AA(*(LPVOID *)v1);
    *(_DWORD *)v1 = 0;
    *(_DWORD *)(v1 + 4) = 0;
    *(_DWORD *)(v1 + 8) = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10024BC0) --------------------------------------------------------
int __thiscall sub_10024BC0(int this)
{
  int v1; // edi@1
  int v2; // esi@1
  int i; // ebx@2
  int v4; // ecx@3
  int result; // eax@7

  v1 = this;
  v2 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    for ( i = *(_DWORD *)(this + 4); v2 != i; v2 += 8 )
    {
      v4 = *(_DWORD *)(v2 + 4);
      if ( v4 )
      {
        _EAX = v4 + 8;
        _EDX = -1;
        __asm { lock xadd [eax], edx }
        if ( _ZF )
          (*(void (__fastcall **)(int, int))(*(_DWORD *)v4 + 4))(v4, _EDX);
      }
    }
    result = sub_1002A4AA(*(LPVOID *)v1);
    *(_DWORD *)v1 = 0;
    *(_DWORD *)(v1 + 4) = 0;
    *(_DWORD *)(v1 + 8) = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10024CD0) --------------------------------------------------------
char __thiscall sub_10024CD0(int this, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // esi@1
  int v5; // ecx@2
  char result; // al@5
  int v7; // eax@6

  v4 = this;
  v2 = 0;
  v3 = *(_DWORD *)(this + 12);
  if ( v3 )
  {
    v5 = *(_DWORD *)(this + 8);
    while ( *(_DWORD *)v5 != a2 )
    {
      ++v2;
      v5 += 4;
      if ( v2 >= v3 )
        goto LABEL_5;
    }
    *(_DWORD *)(*(_DWORD *)(v4 + 8) + 4 * v2) = 0;
    v7 = *(_DWORD *)(v4 + 4);
    if ( v7 != -1 )
    {
      if ( v7 )
        *(_DWORD *)(v4 + 4) = 0;
    }
    result = 1;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (10024D60) --------------------------------------------------------
int __usercall sub_10024D60<eax>(int a1<ecx>, int a2<ebx>)
{
  int v3; // edi@1
  int v4; // edx@1

  v3 = a1;
  *(_DWORD *)a1 = &off_10069314;
  sub_1002B52D(a1 + 4);
  *(_DWORD *)(v3 + 44) = 0;
  *(_DWORD *)(v3 + 48) = 0;
  *(_DWORD *)(v3 + 52) = 0;
  *(_DWORD *)(v3 + 56) = 0;
  *(_DWORD *)(v3 + 60) = off_100693A0;
  *(_DWORD *)(v3 + 64) = -1;
  *(_DWORD *)(v3 + 68) = 0;
  *(_DWORD *)(v3 + 72) = 0;
  *(_DWORD *)(v3 + 76) = 0;
  *(_DWORD *)(v3 + 80) = 0;
  *(_DWORD *)(v3 + 84) = 0;
  *(_BYTE *)(v3 + 88) = 0;
  sub_10025950(v3 + 96, v4);
  sub_10031044(a2, v3, 0, v3, (unsigned __int64)v3 >> 32, v3 + 96, (unsigned __int64)(v3 + 96) >> 32);
  return v3;
}
// 10069314: using guessed type int (__stdcall *off_10069314)(char);
// 100693A0: using guessed type int (__stdcall *off_100693A0[3])(int);

//----- (10024E30) --------------------------------------------------------
int __thiscall sub_10024E30(int this, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  void **v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int *v7; // [sp+1Ch] [bp-18h]@1
  int v8; // [sp+30h] [bp-4h]@1

  v4 = this;
  v5 = &off_10068F78;
  v6 = this;
  v7 = (int *)&v5;
  v8 = 1;
  result = sub_100259F0(this + 96, 0, this, (int)&v5);
  v8 = -1;
  if ( v7 )
  {
    result = (*(int (__stdcall **)(bool))(*v7 + 16))((void ***)v7 != &v5);
    v7 = 0;
  }
  *(_DWORD *)(v4 + 80) = v4;
  return result;
}
// 10068F78: using guessed type void *off_10068F78;

//----- (10024ED0) --------------------------------------------------------
int __thiscall sub_10024ED0(int this)
{
  int result; // eax@1
  void **v2; // [sp+8h] [bp-40h]@1
  int v3; // [sp+Ch] [bp-3Ch]@1
  int *v4; // [sp+18h] [bp-30h]@1
  char v5; // [sp+20h] [bp-28h]@1
  int v6; // [sp+30h] [bp-18h]@1
  int v7; // [sp+44h] [bp-4h]@1

  v6 = 0;
  v7 = 0;
  v2 = &off_10068F5C;
  v3 = this;
  v4 = (int *)&v2;
  LOBYTE(v7) = 2;
  result = (*(int (__stdcall **)(void ***, char *))(*(_DWORD *)(this + 96) + 20))(&v2, &v5);
  LOBYTE(v7) = 0;
  if ( v4 )
  {
    result = (*(int (__stdcall **)(bool))(*v4 + 16))((void ***)v4 != &v2);
    v4 = 0;
  }
  v7 = -1;
  if ( v6 )
    result = (*(int (__stdcall **)(bool))(*(_DWORD *)v6 + 16))(v6 != (_DWORD)&v5);
  return result;
}
// 10068F5C: using guessed type void *off_10068F5C;

//----- (10024F90) --------------------------------------------------------
int __thiscall sub_10024F90(void *this)
{
  void *v1; // esi@1

  v1 = this;
  sub_10023230((int)((char *)this + 56));
  if ( *((_DWORD *)v1 + 11) )
  {
    sub_10030383(*((LPVOID *)v1 + 11));
    *((_DWORD *)v1 + 11) = 0;
    *((_DWORD *)v1 + 12) = 0;
    *((_DWORD *)v1 + 13) = 0;
  }
  return nullsub_2(v1);
}
// 1002B6E4: using guessed type int __thiscall nullsub_2(_DWORD);
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (10025010) --------------------------------------------------------
char __thiscall sub_10025010(int this, int a2)
{
  int ebp0; // ebp@0
  int v3; // edi@1
  int v4; // esi@1
  unsigned int v6; // eax@7
  int v7; // [sp+Ch] [bp-34h]@1
  char v8; // [sp+13h] [bp-2Dh]@2
  char v9; // [sp+14h] [bp-2Ch]@3
  unsigned int v10; // [sp+30h] [bp-10h]@1
  int v11; // [sp+3Ch] [bp-4h]@2
  int v12; // [sp+40h] [bp+0h]@1

  v10 = (unsigned int)&v12 ^ __security_cookie;
  v4 = this;
  v3 = 0;
  v7 = *(_DWORD *)(this + 76);
  if ( !a2 )
    return 0;
  sub_1002B589(ebp0, this);
  v11 = 0;
  v8 = (*(int (__stdcall **)(int))(*(_DWORD *)(v4 + 56) + 4))(a2);
  if ( !v8 )
  {
    v11 = -1;
    sub_1002B6DD(&v9);
    return 0;
  }
  if ( *(_DWORD *)(v4 + 40) )
  {
    v6 = *(_DWORD *)(v4 + 48);
    if ( v6 >= *(_DWORD *)(v4 + 52) )
      sub_10025D20(v4 + 44, 0, 2 * v6 + 2);
    *(_DWORD *)(*(_DWORD *)(v4 + 44) + 4 * *(_DWORD *)(v4 + 48)++) = a2;
  }
  else
  {
    v3 = a2;
  }
  v11 = -1;
  sub_1002B6DD(&v9);
  if ( v3 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 36))(v3, v7);
  return v8;
}
// 10074200: using guessed type int __security_cookie;

//----- (100250F0) --------------------------------------------------------
int __thiscall sub_100250F0(int this, int a2)
{
  *(_DWORD *)a2 = &off_10069040;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = this;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  sub_10025D80(this, a2 + 4);
  return a2;
}
// 10069040: using guessed type int (__stdcall *off_10069040)(char);

//----- (10025170) --------------------------------------------------------
char __thiscall sub_10025170(void *this)
{
  char result; // al@1
  int v2; // esi@1
  int v3; // [sp+4h] [bp-8h]@1
  unsigned int v4; // [sp+8h] [bp-4h]@1
  int v5; // [sp+Ch] [bp+0h]@1

  v4 = (unsigned int)&v5 ^ __security_cookie;
  v2 = (int)((char *)this + 4);
  v3 = 0;
  for ( result = sub_1002A0FD((int)((char *)this + 4), (int)&v3); result; result = sub_1002A0FD(v2, (int)&v3) )
  {
    if ( v3 )
      (*(void (__stdcall **)(signed int))(*(_DWORD *)v3 + 4))(1);
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;

//----- (100251D0) --------------------------------------------------------
void __thiscall sub_100251D0(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v3; // edi@1
  int v4; // ecx@2
  int v5; // eax@3

  v3 = this;
  sub_1002B544(ebp0, (int)((char *)this + 24));
  if ( *((_DWORD *)v3 + 17) )
  {
    if ( a2 )
      (*(void (__thiscall **)(int, signed int))(*(_DWORD *)a2 + 4))(a2, 1);
  }
  else
  {
    v4 = (int)((char *)v3 + 56);
    if ( *((_DWORD *)v3 + 14) > 0 )
    {
      v5 = *(_DWORD *)v4;
      *(_DWORD *)v4 = 0;
      loc_10025A70(v3, v5);
    }
    loc_10025B00(v3, a2);
  }
  sub_1002B6D6();
}

//----- (100253C0) --------------------------------------------------------
int __cdecl sub_100253C0(int a1)
{
  return (*(int (**)(void))(*(_DWORD *)a1 + 12))();
}

//----- (100253D0) --------------------------------------------------------
int __usercall sub_100253D0<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // eax@1
  int v3; // edi@1
  int v4; // esi@1
  int result; // eax@2

  v3 = a1;
  v2 = sub_1002CB8B(a2, a1, 0x14u);
  v4 = v2;
  if ( v2 )
  {
    *(_DWORD *)(v2 + 12) = 0;
    sub_1002A371(v2);
    *(_DWORD *)v4 = &off_10069044;
    *(_DWORD *)(v4 + 8) = *(_DWORD *)(v3 + 248);
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10069044: using guessed type int (*off_10069044)();

//----- (10025470) --------------------------------------------------------
int __thiscall sub_10025470(int this, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // ecx@1
  int v10; // [sp+Ch] [bp-8h]@1
  unsigned int v11; // [sp+10h] [bp-4h]@1
  int v12; // [sp+14h] [bp+0h]@1

  v11 = (unsigned int)&v12 ^ __security_cookie;
  v7 = this;
  v10 = 0;
  *(_DWORD *)(this + 240) = 0;
  *(_DWORD *)(this + 248) = *(_DWORD *)a2;
  *(_WORD *)(this + 252) = 0;
  *(_DWORD *)(this + 244) = 0;
  sub_1002FEDB(this, a3, this, (int)&v10);
  v8 = v10;
  sub_100348B1(&v10);
  *(_BYTE *)(v7 + 253) = 1;
  *(_DWORD *)(v7 + 256) = v8;
  result = sub_10025B70(v7 + 16, v8, v9);
  if ( a3 )
    result = (*(int (__thiscall **)(int, int))(*(_DWORD *)(v7 + 16) + 4))(v7 + 16, a3);
  return result;
}
// 10074200: using guessed type int __security_cookie;

//----- (10025510) --------------------------------------------------------
int __usercall sub_10025510<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v4; // edi@1

  v4 = a2;
  *(_DWORD *)a2 = &off_10069128;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = -1;
  *(_DWORD *)(a2 + 12) = &off_10069188;
  *(_DWORD *)(a2 + 16) = 0;
  sub_10025950(a2 + 24, a1);
  sub_1002B52D(v4 + 176);
  *(_DWORD *)(v4 + 216) = 0;
  sub_10031044(a3, v4, 0, v4, (unsigned __int64)v4 >> 32, v4 + 24, (unsigned __int64)(v4 + 24) >> 32);
  return v4;
}
// 10069128: using guessed type int (__stdcall *off_10069128)(char);
// 10069188: using guessed type void *off_10069188;

//----- (100255C0) --------------------------------------------------------
int __thiscall sub_100255C0(int this)
{
  int v1; // ecx@1
  int v2; // esi@1
  int result; // eax@3

  v2 = this;
  *(_DWORD *)this = &off_10069040;
  v1 = *(_DWORD *)(this + 16);
  if ( v1 )
    sub_10025860(v1);
  result = *(_DWORD *)(v2 + 4);
  if ( result )
  {
    result = sub_10030383(*(LPVOID *)(v2 + 4));
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
    *(_DWORD *)(v2 + 12) = 0;
  }
  return result;
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 10069040: using guessed type int (__stdcall *off_10069040)(char);

//----- (10025640) --------------------------------------------------------
int __userpurge sub_10025640<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  int v4; // esi@1

  v4 = a1;
  *(_DWORD *)a1 = &off_10069044;
  if ( a4 & 1 )
    sub_1002CC50(a2, a3, a1);
  return v4;
}
// 10069044: using guessed type int (*off_10069044)();

//----- (10025670) --------------------------------------------------------
int __thiscall sub_10025670(int this, char a2)
{
  int v2; // ecx@1
  int v3; // esi@1

  v3 = this;
  *(_DWORD *)this = &off_10069040;
  v2 = *(_DWORD *)(this + 16);
  if ( v2 )
    sub_10025860(v2);
  if ( *(_DWORD *)(v3 + 4) )
  {
    sub_10030383(*(LPVOID *)(v3 + 4));
    *(_DWORD *)(v3 + 4) = 0;
    *(_DWORD *)(v3 + 8) = 0;
    *(_DWORD *)(v3 + 12) = 0;
  }
  if ( a2 & 1 )
    sub_1002A4AA((LPVOID)v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 10069040: using guessed type int (__stdcall *off_10069040)(char);

//----- (100257B0) --------------------------------------------------------
int __fastcall sub_100257B0(int a1, int a2, unsigned int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@4
  int v6; // eax@6
  int v7; // ecx@7
  int result; // eax@13
  int v16; // [sp+Ch] [bp-8h]@4
  int v17; // [sp+10h] [bp-4h]@4

  v4 = 0;
  v3 = a1;
  if ( a3 )
  {
    if ( a3 > 0x1FFFFFFF || (v4 = sub_1002ADB1(a2, a1, a1, 0, 8 * a3), !v4) )
    {
      sub_10029530();
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_10025860);
    }
  }
  sub_10026900(*(_DWORD *)v3, *(_DWORD *)(v3 + 4), v4);
  v5 = *(_DWORD *)v3;
  v17 = *(_DWORD *)(v3 + 4);
  v16 = (*(_DWORD *)(v3 + 4) - *(_DWORD *)v3) >> 3;
  if ( *(_DWORD *)v3 )
  {
    if ( v5 != *(_DWORD *)(v3 + 4) )
    {
      v6 = *(_DWORD *)(v3 + 4);
      do
      {
        v7 = *(_DWORD *)(v5 + 4);
        if ( v7 )
        {
          _EAX = v7 + 8;
          _EDX = -1;
          __asm { lock xadd [eax], edx }
          if ( _ZF )
            (*(void (__fastcall **)(int, int))(*(_DWORD *)v7 + 4))(v7, _EDX);
          v6 = v17;
        }
        v5 += 8;
      }
      while ( v5 != v6 );
    }
    sub_1002A4AA(*(LPVOID *)v3);
  }
  *(_DWORD *)v3 = v4;
  *(_DWORD *)(v3 + 8) = v4 + 8 * a3;
  result = v4 + 8 * v16;
  *(_DWORD *)(v3 + 4) = result;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10025860) --------------------------------------------------------
void __thiscall sub_10025860(int this)
{
  int ebp0; // ebp@0
  int v2; // esi@1
  int v3; // esi@3
  int v4; // ebx@4
  int v5; // edi@4
  int v6; // eax@4
  unsigned int v7; // esi@6
  int v8; // [sp+Ch] [bp-3Ch]@1
  int v9; // [sp+10h] [bp-38h]@1
  int v10; // [sp+14h] [bp-34h]@1
  int v11; // [sp+18h] [bp-30h]@1
  char v12; // [sp+1Ch] [bp-2Ch]@6
  unsigned int v13; // [sp+38h] [bp-10h]@1
  int v14; // [sp+44h] [bp-4h]@1
  int v15; // [sp+48h] [bp+0h]@1

  v13 = (unsigned int)&v15 ^ __security_cookie;
  v2 = this;
  v8 = *(_DWORD *)(this + 76);
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  sub_1002B589(ebp0, this);
  --*(_DWORD *)(v2 + 40);
  if ( *(_DWORD *)(v2 + 40) || !*(_DWORD *)(v2 + 48) || (v3 = v2 + 44, (int *)v3 == &v9) )
  {
    v4 = v10;
    v5 = v9;
  }
  else
  {
    v5 = *(_DWORD *)v3;
    v4 = *(_DWORD *)(v3 + 4);
    v6 = *(_DWORD *)(v3 + 8);
    *(_DWORD *)v3 = 0;
    *(_DWORD *)(v3 + 4) = 0;
    *(_DWORD *)(v3 + 8) = 0;
    v9 = v5;
    v10 = v4;
    v11 = v6;
  }
  sub_1002B6DD(&v12);
  v7 = 0;
  if ( v4 )
  {
    do
      (*(void (__stdcall **)(int))(**(_DWORD **)(v5 + 4 * v7++) + 36))(v8);
    while ( v7 < v4 );
  }
  if ( v5 )
    sub_10030383((LPVOID)v5);
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10025950) --------------------------------------------------------
int __fastcall sub_10025950(int a1, int a2)
{
  int v3; // edi@1

  v3 = a1;
  *(_DWORD *)a1 = &off_1006926C;
  sub_10029F48(a1 + 4, a2, 4u);
  *(_DWORD *)(v3 + 4) = off_10069028;
  sub_1002B4FD(v3 + 24);
  *(_DWORD *)(v3 + 56) = 0;
  *(_DWORD *)(v3 + 60) = 0;
  *(_DWORD *)(v3 + 64) = 0;
  *(_DWORD *)(v3 + 68) = 1;
  *(_DWORD *)(v3 + 72) = 0;
  *(_DWORD *)(v3 + 96) = 0;
  *(_DWORD *)(v3 + 120) = 0;
  *(_DWORD *)(v3 + 144) = 0;
  return v3;
}
// 10069028: using guessed type int (__stdcall *off_10069028[3])(int, int, int);
// 1006926C: using guessed type void *off_1006926C;

//----- (100259F0) --------------------------------------------------------
int __thiscall sub_100259F0(int this, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@2
  int v8; // ecx@4
  int v9; // eax@6

  result = a2;
  v6 = this;
  v5 = this + 80;
  *(_DWORD *)(this + 60) = a2;
  *(_DWORD *)(this + 64) = 0;
  if ( this + 80 != a4 )
  {
    v7 = *(_DWORD *)(this + 96);
    if ( v7 )
    {
      result = (*(int (__stdcall **)(bool))(*(_DWORD *)v7 + 16))(v7 != v5);
      *(_DWORD *)(v5 + 16) = 0;
    }
    v8 = *(_DWORD *)(a4 + 16);
    if ( !v8 )
    {
      *(_DWORD *)(v5 + 16) = 0;
      *(_DWORD *)(v6 + 68) = 0;
      return result;
    }
    v9 = *(_DWORD *)v8;
    if ( v8 == a4 )
    {
      result = (*(int (__stdcall **)(int))v9)(v5);
      *(_DWORD *)(v5 + 16) = result;
      *(_DWORD *)(v6 + 68) = 0;
      return result;
    }
    result = (*(int (__stdcall **)(_DWORD))v9)(0);
    *(_DWORD *)(v5 + 16) = result;
  }
  *(_DWORD *)(v6 + 68) = 0;
  return result;
}

//----- (10025B70) --------------------------------------------------------
int __thiscall sub_10025B70(int this, int a2, int a3)
{
  int result; // eax@1
  void **v4; // [sp+4h] [bp-28h]@1
  int v5; // [sp+8h] [bp-24h]@1
  int *v6; // [sp+14h] [bp-18h]@1
  int v7; // [sp+28h] [bp-4h]@1

  v4 = &off_10068F40;
  v5 = this;
  v6 = (int *)&v4;
  v7 = 1;
  result = sub_100259F0(this + 24, a2, this, (int)&v4);
  v7 = -1;
  if ( v6 )
    result = (*(int (__stdcall **)(bool))(*v6 + 16))((void ***)v6 != &v4);
  return result;
}
// 10068F40: using guessed type void *off_10068F40;

//----- (10025C00) --------------------------------------------------------
char __thiscall sub_10025C00(int this, int a2)
{
  int v2; // eax@1
  int v3; // esi@1
  char v4; // zf@1
  char v5; // zf@3
  char v6; // zf@5
  DWORD v7; // eax@12
  char v9; // [sp+8h] [bp-18h]@1
  DWORD v10; // [sp+Ch] [bp-14h]@3
  int v11; // [sp+10h] [bp-10h]@4
  int v12; // [sp+14h] [bp-Ch]@1
  int (*v13)(void); // [sp+18h] [bp-8h]@1
  unsigned int v14; // [sp+1Ch] [bp-4h]@1

  v2 = (unsigned int)&v9 ^ __security_cookie;
  v14 = (unsigned int)&v9 ^ __security_cookie;
  v3 = this;
  v4 = *(_DWORD *)(this + 216) == 0;
  v12 = 0;
  v13 = sub_10034C15;
  if ( !v4 )
  {
    do
    {
      v2 = v12;
      switch ( v12 )
      {
        case 1:
          __asm { pause                   ; jumptable 10025C4D case 1 }
          v5 = v10-- == 1;
          if ( v5 )
          {
            v2 = 3 - (v11 != 0);
            v12 = 3 - (v11 != 0);
          }
          break;
        case 2:
          v6 = v11-- == 1;
          if ( v6 )
            v2 = 3;
          v12 = v2;
          goto LABEL_8;
        case 4:
LABEL_8:
          LOBYTE(v2) = v13();
          break;
        case 3:
          v12 = 0;
          v2 = sub_1002BD66();
          if ( v2 )
          {
            v10 = v2;
            v11 = 1;
            v12 = 1;
          }
          else
          {
            v12 = 4;
          }
          break;
        case 0:
          v12 = 0;
          v7 = sub_1002BD66();
          if ( v7 )
          {
            v10 = v7;
            v11 = 1;
            v12 = 1;
          }
          else
          {
            v12 = 4;
          }
          LOBYTE(v2) = sub_100282E0((int)&v10);
          break;
        default:
          break;
      }
    }
    while ( *(_DWORD *)(v3 + 216) );
  }
  return v2;
}
// 10074200: using guessed type int __security_cookie;

//----- (10025D20) --------------------------------------------------------
int __userpurge sub_10025D20<eax>(int a1<ecx>, int a2<edi>, int a3)
{
  int result; // eax@1
  int v4; // edi@1
  int v5; // esi@1
  signed __int64 v7; // qax@1
  unsigned int v8; // ecx@2

  v5 = a1;
  _ECX = 0;
  v7 = 4i64 * (unsigned int)a3;
  __asm { seto    cl }
  result = sub_1002965B(SHIDWORD(v7), v7 | -_ECX, a3, a2, v7 | -_ECX);
  v4 = result;
  if ( *(_DWORD *)v5 )
  {
    v8 = 0;
    if ( *(_DWORD *)(v5 + 8) )
    {
      do
      {
        ++v8;
        *(_DWORD *)(result + 4 * v8 - 4) = *(_DWORD *)(*(_DWORD *)v5 + 4 * v8 - 4);
      }
      while ( v8 < *(_DWORD *)(v5 + 8) );
    }
    result = sub_10030383(*(LPVOID *)v5);
  }
  *(_DWORD *)v5 = v4;
  *(_DWORD *)(v5 + 8) = a3;
  return result;
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (10025D80) --------------------------------------------------------
void __thiscall sub_10025D80(int this, int a2)
{
  int ebp0; // ebp@0
  unsigned int v3; // ST04_4@1
  int v4; // edi@1
  int v5; // eax@1
  int v6; // edi@2
  unsigned int v7; // eax@3
  int v8; // edx@3
  int v9; // ebx@4
  int v10; // edi@4
  __int64 v12; // qax@4
  unsigned int v13; // ecx@5
  int v14; // ecx@9
  char v15; // [sp+Ch] [bp-38h]@10
  int v16; // [sp+28h] [bp-1Ch]@1
  int v17; // [sp+2Ch] [bp-18h]@1
  int v18; // [sp+30h] [bp-14h]@1
  unsigned int v19; // [sp+34h] [bp-10h]@1
  int v20; // [sp+40h] [bp-4h]@1
  int v21; // [sp+44h] [bp+0h]@1

  v19 = (unsigned int)&v21 ^ __security_cookie;
  v3 = (unsigned int)&v21 ^ __security_cookie;
  v4 = this;
  sub_1002B589(ebp0, this);
  v20 = 0;
  ++*(_DWORD *)(v4 + 40);
  v5 = *(_DWORD *)(v4 + 56);
  v16 = 0;
  v18 = 0;
  (*(void (__thiscall **)(int, int *, unsigned int))(v5 + 16))(v4 + 56, &v16, v3);
  v18 = (*(int (__stdcall **)(int))(*(_DWORD *)v16 + 24))(v17);
  if ( v18 )
  {
    v6 = 4;
    do
    {
      v8 = (*(int (__stdcall **)(int))(*(_DWORD *)v16 + 24))(v17);
      v7 = *(_DWORD *)(a2 + 4);
      v18 = v8;
      if ( v7 >= *(_DWORD *)(a2 + 8) )
      {
        v9 = 2 * v7 + 2;
        _ECX = 0;
        v12 = v6 * (2 * v7 + 2);
        __asm { seto    cl }
        v10 = sub_1002965B(SHIDWORD(v12), v12 | -_ECX, v9, v6, v12 | -_ECX);
        if ( *(_DWORD *)a2 )
        {
          v13 = 0;
          if ( *(_DWORD *)(a2 + 8) )
          {
            do
            {
              ++v13;
              *(_DWORD *)(v10 + 4 * v13 - 4) = *(_DWORD *)(*(_DWORD *)a2 + 4 * v13 - 4);
            }
            while ( v13 < *(_DWORD *)(a2 + 8) );
          }
          sub_10030383(*(LPVOID *)a2);
        }
        v8 = v18;
        *(_DWORD *)a2 = v10;
        *(_DWORD *)(a2 + 8) = v9;
        v6 = 4;
      }
      *(_DWORD *)(*(_DWORD *)a2 + 4 * *(_DWORD *)(a2 + 4)) = v8;
      v14 = v16;
      ++*(_DWORD *)(a2 + 4);
      ++v17;
      (*(void (__stdcall **)(int *))(*(_DWORD *)v14 + 20))(&v17);
      v18 = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)v16 + 24))(v17);
    }
    while ( v18 );
  }
  v20 = -1;
  sub_1002B6DD(&v15);
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10025ED0) --------------------------------------------------------
void *__userpurge sub_10025ED0<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_10025F00(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10025F00) --------------------------------------------------------
void __usercall sub_10025F00(int a1<ecx>, int a2<ebx>)
{
  int v2; // esi@1

  v2 = a1;
  *(_DWORD *)a1 = off_10069028;
  if ( !sub_1002A09A(a1) )
  {
    while ( sub_1002A0FD(v2, 0) && !sub_1002A09A(v2) )
      ;
  }
  sub_1002A0BD((void *)v2);
  sub_10029FBF(v2, a2);
}
// 10069028: using guessed type int (__stdcall *off_10069028[3])(int, int, int);

//----- (10025F80) --------------------------------------------------------
int __fastcall sub_10025F80(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // ST08_4@1
  int v6; // ST0C_4@1
  int v7; // ST10_4@1
  int v8; // ST14_4@1
  void *v9; // [sp+Ch] [bp+4h]@1

  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  sub_10026260(a1, a2, a3, a4, v5, v6, v7, v8);
  result = a3;
  *(_DWORD *)(*(_DWORD *)a3 + 148) = v9;
  return result;
}

//----- (10025FC0) --------------------------------------------------------
int __userpurge sub_10025FC0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5)
{
  int result; // eax@1
  int v6; // ST08_4@1
  int v7; // ST0C_4@1
  int v8; // ST10_4@1
  int v9; // ST14_4@1
  void *v10; // [sp+Ch] [bp+4h]@1

  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_10026350(a1, a2, a3, a4, a5, v6, v7, v8, v9);
  result = a4;
  *(_DWORD *)(*(_DWORD *)a4 + 148) = v10;
  return result;
}

//----- (10026000) --------------------------------------------------------
int __thiscall sub_10026000(int this, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // esi@1
  int v5; // ecx@2
  int v9; // [sp+10h] [bp+8h]@1

  v4 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  v3 = *(_DWORD *)(a2 + 4);
  v9 = *(_DWORD *)a2;
  if ( v3 )
  {
    v5 = *(_DWORD *)(v3 + 4);
    _EDI = v3 + 4;
    if ( v5 )
    {
      while ( 1 )
      {
        _EDX = v5 + 1;
        __asm { lock cmpxchg [edi], edx }
        if ( v5 == v5 )
          break;
        v5 = *(_DWORD *)_EDI;
        if ( !*(_DWORD *)_EDI )
          return v4;
      }
      sub_10026710(v4, v9, v3);
    }
  }
  return v4;
}

//----- (10026060) --------------------------------------------------------
char __thiscall sub_10026060(void *this, char a2, char a3, int a4, int a5)
{
  char v5; // bl@1
  int ebp0; // ebp@0
  int v7; // esi@1
  int v8; // eax@7
  int v10; // ecx@14
  char v11; // [sp+10h] [bp-4Ch]@1
  void **v12; // [sp+14h] [bp-48h]@18
  int v13; // [sp+18h] [bp-44h]@18
  int *v14; // [sp+24h] [bp-38h]@18
  unsigned int v15; // [sp+48h] [bp-14h]@1
  int v16; // [sp+58h] [bp-4h]@1

  v15 = (unsigned int)&v11 ^ __security_cookie;
  v7 = (int)this;
  v5 = 0;
  sub_1002B62D(ebp0, (int)((char *)this + 100));
  v16 = 0;
  if ( !a3 )
  {
    v8 = *(_DWORD *)(v7 + 84);
    if ( v8 != 3 && v8 != 4 )
    {
      if ( v8 != 2 )
        goto LABEL_4;
      if ( a2 )
      {
LABEL_13:
        *(_DWORD *)(v7 + 84) = 4;
        sub_1002C5B4(ebp0);
        v5 = 1;
        goto LABEL_14;
      }
    }
LABEL_11:
    v16 = -1;
    sub_1002B6D6();
    return 0;
  }
  if ( *(_DWORD *)(v7 + 84) == 4 )
    goto LABEL_11;
  sub_1000A140((void *)(v7 + 92), a5);
LABEL_4:
  if ( a2 || !*(_DWORD *)(v7 + 84) )
    goto LABEL_13;
  *(_DWORD *)(v7 + 84) = 2;
LABEL_14:
  v10 = *(_DWORD *)(v7 + 144);
  if ( v10 )
    sub_1002D5ED(v10 + 8, v5, a5);
  v16 = -1;
  sub_1002B6D6();
  if ( v5 )
  {
    sub_1002C5B4(ebp0);
    if ( *(_DWORD *)(v7 + 132) )
    {
      v12 = &off_10068F24;
      v13 = v7;
      v14 = (int *)&v12;
      v16 = 2;
      sub_10028360((int)&v12, a5);
      sub_10006050((int)&v12);
    }
  }
  return 1;
}
// 10068F24: using guessed type void *off_10068F24;
// 10074200: using guessed type int __security_cookie;

//----- (100261B0) --------------------------------------------------------
int __thiscall sub_100261B0(int this, char a2)
{
  int v2; // eax@1
  int ebp0; // ebp@0
  int v4; // esi@1
  int v5; // ecx@2

  v4 = this;
  *(_DWORD *)this = &off_10069020;
  v2 = *(_DWORD *)(this + 140);
  if ( v2 )
  {
    sub_1002B29A(ebp0, v2);
    v5 = *(_DWORD *)(v4 + 140);
    _EDX = -1;
    _EAX = v5 + 4;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v5 + 4))();
    *(_DWORD *)(v4 + 140) = 0;
  }
  sub_1000A960(v4);
  if ( a2 & 1 )
    sub_1002A4AA((LPVOID)v4);
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10069020: using guessed type int (__stdcall *off_10069020)(char);

//----- (10026260) --------------------------------------------------------
int __fastcall sub_10026260(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // edi@1
  int v9; // esi@1
  int v10; // eax@3
  int v11; // esi@3
  int v12; // eax@4
  int v14; // [sp-8h] [bp-38h]@4
  int v15; // [sp-4h] [bp-34h]@3
  char v16; // [sp+14h] [bp-1Ch]@2
  int v17; // [sp+20h] [bp-10h]@1
  int v18; // [sp+2Ch] [bp-4h]@1

  v8 = a1;
  v18 = 0;
  v17 = 0;
  v9 = *(_DWORD *)a1;
  if ( !*(_DWORD *)a1 )
  {
    sub_1002FFB9((int)&v16, (unsigned int)"then() cannot be called on a default constructed task.");
    sub_100355DB((int)&v16, (int)&unk_1006D8B8);
  }
  v11 = *(_DWORD *)(v9 + 136);
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  sub_10006BC0(a2, a3, v8, a1);
  v18 = 0;
  v17 = 1;
  sub_10009800(a3, v11);
  *(_BYTE *)(*(_DWORD *)a3 + 88) = *(_BYTE *)(*(_DWORD *)v8 + 88) != 0;
  *(_BYTE *)(*(_DWORD *)a3 + 89) = 0;
  *(_BYTE *)(*(_DWORD *)a3 + 90) = 0;
  v10 = sub_1002CB8B(a3, v8, 0x34u);
  if ( v10 )
    v12 = sub_100265C0(v10, v8, a3, a4, v14, v15);
  else
    v12 = 0;
  sub_10009430(*(void **)v8, v12);
  return a3;
}

//----- (10026350) --------------------------------------------------------
int __userpurge sub_10026350<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // edi@1
  int v10; // eax@3
  int v11; // eax@4
  int v13; // [sp-8h] [bp-30h]@4
  int v14; // [sp-4h] [bp-2Ch]@3
  char v15; // [sp+Ch] [bp-1Ch]@2
  int v16; // [sp+18h] [bp-10h]@1
  int v17; // [sp+24h] [bp-4h]@1

  v9 = a2;
  v17 = 0;
  v16 = 0;
  if ( !*(_DWORD *)a2 )
  {
    sub_1002FFB9((int)&v15, (unsigned int)"then() cannot be called on a default constructed task.");
    sub_100355DB((int)&v15, (int)&unk_1006D8B8);
  }
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_10006BC0(a1, a4, v9, a2);
  v17 = 0;
  v16 = 1;
  sub_10026500(a4, 2);
  *(_BYTE *)(*(_DWORD *)a4 + 88) = *(_BYTE *)(*(_DWORD *)v9 + 88) != 0;
  *(_BYTE *)(*(_DWORD *)a4 + 89) = 0;
  *(_BYTE *)(*(_DWORD *)a4 + 90) = 0;
  v10 = sub_1002CB8B(a3, v9, 0x40u);
  if ( v10 )
    v11 = sub_10026630(v10, v9, a4, a5, v13, v14);
  else
    v11 = 0;
  sub_10009430(*(void **)v9, v11);
  return a4;
}

//----- (10026430) --------------------------------------------------------
int __userpurge sub_10026430<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // edi@4
  int result; // eax@8
  char v23; // [sp+0h] [bp-24h]@1
  int v24; // [sp+10h] [bp-14h]@1
  char *v25; // [sp+14h] [bp-10h]@1
  int v26; // [sp+20h] [bp-4h]@1

  v25 = &v23;
  v5 = a2;
  v24 = a2;
  v26 = 0;
  v4 = sub_1002ADB1(a1, a2, a3, a2, 16);
  v6 = v4;
  if ( v4 )
  {
    *(_DWORD *)(v4 + 4) = 1;
    *(_DWORD *)(v4 + 8) = 1;
    *(_DWORD *)v4 = &off_10069010;
    *(_DWORD *)(v4 + 12) = a4;
  }
  else
  {
    v6 = 0;
  }
  v7 = *(_DWORD *)(v5 + 4);
  if ( v7 )
  {
    _ECX = v7 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v7)(v7);
      _EAX = v7 + 8;
      _ECX = -1;
      __asm { lock xadd [eax], ecx }
      if ( _ZF )
        (*(void (**)(void))(*(_DWORD *)v7 + 4))();
    }
  }
  result = v24;
  *(_DWORD *)(v24 + 4) = v6;
  *(_DWORD *)result = a4;
  return result;
}
// 10069010: using guessed type int (*off_10069010)();

//----- (10026500) --------------------------------------------------------
int __thiscall sub_10026500(int this, int a2)
{
  int result; // eax@1
  int v4; // ecx@1
  int v5; // ebx@1
  int v7; // esi@3
  int v19; // esi@7
  int v31; // esi@12
  char v32; // [sp+10h] [bp-14h]@1
  char v33; // [sp+18h] [bp-Ch]@1
  int v34; // [sp+1Ch] [bp-8h]@7

  v5 = this;
  result = sub_100266D0(a2, (int)&v33, this);
  v4 = 0;
  _EDX = 0;
  if ( &v32 != (char *)result )
  {
    _EDX = *(_DWORD *)(result + 4);
    *(_DWORD *)(result + 4) = 0;
    v4 = *(_DWORD *)result;
    *(_DWORD *)result = 0;
  }
  v7 = *(_DWORD *)(v5 + 4);
  _EDI = -1;
  *(_DWORD *)(v5 + 4) = _EDX;
  *(_DWORD *)v5 = v4;
  if ( v7 )
  {
    result = v7 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v7)(v7);
      result = v7 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v7 + 4))(v7, _EDX);
    }
  }
  v19 = v34;
  if ( v34 )
  {
    result = v34 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v19)(v19);
      result = v19 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v19 + 4))(v19);
    }
  }
  if ( a2 != 2 )
  {
    v31 = *(_DWORD *)v5;
    result = sub_1002B396(_EDX, *(_DWORD *)(*(_DWORD *)v5 + 136), v5, (int)sub_100097E0, *(_DWORD *)v5, 1);
    *(_DWORD *)(v31 + 140) = result;
  }
  return result;
}

//----- (100265C0) --------------------------------------------------------
int __thiscall sub_100265C0(int this, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // esi@1

  v7 = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_BYTE *)(this + 25) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = &off_100680E0;
  sub_10004DE0(this + 32, a3);
  *(_DWORD *)(v7 + 4) = sub_10026A30;
  *(_BYTE *)(v7 + 16) = 1;
  *(_DWORD *)v7 = &off_100680E8;
  sub_10004DE0(v7 + 40, a2);
  *(_DWORD *)(v7 + 48) = *(_DWORD *)a4;
  *(_BYTE *)(v7 + 25) = 0;
  *(_DWORD *)(v7 + 28) = 0;
  return v7;
}
// 100680E0: using guessed type int (__stdcall *off_100680E0)(char);
// 100680E8: using guessed type int (__stdcall *off_100680E8)(char);

//----- (10026630) --------------------------------------------------------
int __thiscall sub_10026630(int this, int a2, int a3, int a4, int a5, int a6)
{
  _ESI = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_BYTE *)(this + 25) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = &off_100680E0;
  sub_10004DE0(this + 32, a3);
  *(_DWORD *)(_ESI + 4) = sub_10026A40;
  *(_BYTE *)(_ESI + 16) = 1;
  *(_DWORD *)_ESI = &off_100680E8;
  sub_10004DE0(_ESI + 40, a2);
  _EAX = a4;
  __asm
  {
    movq    xmm0, qword ptr [eax]
    movq    qword ptr [esi+30h], xmm0
    movq    xmm0, qword ptr [eax+8]
    movq    qword ptr [esi+38h], xmm0
  }
  *(_BYTE *)(_ESI + 25) = 1;
  *(_DWORD *)(_ESI + 28) = 0;
  return _ESI;
}
// 100680E0: using guessed type int (__stdcall *off_100680E0)(char);
// 100680E8: using guessed type int (__stdcall *off_100680E8)(char);

//----- (100266B0) --------------------------------------------------------
int __usercall sub_100266B0<eax>(int a1<ecx>, int a2<ebx>)
{
  void *v2; // esi@1
  int result; // eax@2

  v2 = *(void **)(a1 + 12);
  if ( v2 )
  {
    sub_10001EA0(*(_DWORD *)(a1 + 12), a2);
    result = sub_1002A4AA(v2);
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100266D0) --------------------------------------------------------
int __usercall sub_100266D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v4; // esi@1
  int v5; // [sp+8h] [bp-8h]@1
  unsigned int v6; // [sp+Ch] [bp-4h]@1
  int v7; // [sp+10h] [bp+0h]@1

  v6 = (unsigned int)&v7 ^ __security_cookie;
  v5 = a1;
  v4 = a2;
  sub_10026980((int)&v5, a2, a3);
  return v4;
}
// 10074200: using guessed type int __security_cookie;

//----- (10026710) --------------------------------------------------------
int __thiscall sub_10026710(int this, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int result; // eax@5

  v4 = this;
  v3 = *(_DWORD *)(this + 4);
  if ( v3 )
  {
    _EBX = -1;
    _EDX = v3 + 4;
    _EAX = -1;
    __asm { lock xadd [edx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v3)(v3);
      _EAX = v3 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
    }
    *(_DWORD *)(v4 + 4) = a3;
    result = a2;
    *(_DWORD *)v4 = a2;
  }
  else
  {
    *(_DWORD *)(this + 4) = a3;
    result = a2;
    *(_DWORD *)this = a2;
  }
  return result;
}

//----- (10026770) --------------------------------------------------------
char __usercall sub_10026770<al>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v3; // edi@1
  int v4; // esi@1
  char v5; // bl@3
  int (__stdcall **v7)(char); // [sp+Ch] [bp-88h]@5
  int v8; // [sp+10h] [bp-84h]@5
  int v9; // [sp+14h] [bp-80h]@5
  int v10; // [sp+18h] [bp-7Ch]@5
  int v11; // [sp+34h] [bp-60h]@5
  int v12; // [sp+38h] [bp-5Ch]@5
  int v13; // [sp+3Ch] [bp-58h]@5
  char v14; // [sp+40h] [bp-54h]@5
  int v15; // [sp+58h] [bp-3Ch]@5
  int v16; // [sp+5Ch] [bp-38h]@5
  void **v17; // [sp+68h] [bp-2Ch]@5
  int v18; // [sp+6Ch] [bp-28h]@5
  int v19; // [sp+70h] [bp-24h]@5
  int (__stdcall **v20)(char); // [sp+78h] [bp-1Ch]@3
  int v21; // [sp+7Ch] [bp-18h]@3
  int v22; // [sp+80h] [bp-14h]@3
  unsigned int v23; // [sp+84h] [bp-10h]@1
  int v24; // [sp+90h] [bp-4h]@3
  int v25; // [sp+94h] [bp+0h]@1

  v23 = (unsigned int)&v25 ^ __security_cookie;
  v3 = a1;
  v4 = a2;
  if ( a2
    && (unsigned __int8)(*(int (__cdecl **)(unsigned int))(*(_DWORD *)a2 + 12))((unsigned int)&v25 ^ __security_cookie) )
  {
    v20 = &off_10068FE8;
    v21 = 0;
    v22 = 0;
    v24 = 0;
    v5 = sub_10026E30((int)&v20, a3, v4, v3);
    v20 = &off_10068FE8;
    v24 = 1;
    if ( v21 )
      (*(void (__stdcall **)(signed int))(*(_DWORD *)v21 + 4))(1);
  }
  else
  {
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v15 = 0;
    v16 = 0;
    v18 = 0;
    v24 = 2;
    v7 = &off_10068FC0;
    v8 = 0;
    sub_1002C08C((int)&v9);
    LOBYTE(v24) = 3;
    v13 = 2;
    sub_1002B52D((int)&v14);
    v17 = &off_10069188;
    v18 = 0;
    v19 = 0;
    v24 = 4;
    v5 = sub_100273E0(&v7, v4, v3);
    v24 = -1;
    sub_10026F10(&v7);
  }
  return v5;
}
// 10068FC0: using guessed type int (__stdcall *off_10068FC0)(char);
// 10068FE8: using guessed type int (__stdcall *off_10068FE8)(char);
// 10069188: using guessed type void *off_10069188;
// 10074200: using guessed type int __security_cookie;

//----- (100268D0) --------------------------------------------------------
int __fastcall sub_100268D0(int a1, int a2, int a3)
{
  int result; // eax@1
  int i; // esi@1
  int v5; // edx@3

  result = a3;
  for ( i = a2; a1 != i; result += 4 )
  {
    if ( result )
    {
      v5 = *(_DWORD *)a1;
      *(_DWORD *)a1 = 0;
      *(_DWORD *)result = v5;
    }
    a1 += 4;
  }
  return result;
}

//----- (10026900) --------------------------------------------------------
int __fastcall sub_10026900(int a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@2
  int v5; // ebx@4
  int v13; // ecx@6
  int result; // eax@12
  int v22; // [sp+4h] [bp-4h]@1
  int v23; // [sp+10h] [bp+8h]@4

  v3 = a1;
  v22 = a2;
  if ( a1 == a2 )
  {
    result = a3;
  }
  else
  {
    v4 = a3;
    do
    {
      if ( v4 )
      {
        *(_DWORD *)v4 = 0;
        *(_DWORD *)(v4 + 4) = 0;
        v5 = *(_DWORD *)(v3 + 4);
        v23 = *(_DWORD *)v3;
        if ( v5 )
        {
          _EAX = v5 + 8;
          _ECX = 1;
          __asm { lock xadd [eax], ecx }
        }
        v13 = *(_DWORD *)(v4 + 4);
        if ( v13 )
        {
          _EAX = v13 + 8;
          _EDX = -1;
          __asm { lock xadd [eax], edx }
          if ( _ZF )
            (*(void (__fastcall **)(int, int))(*(_DWORD *)v13 + 4))(v13, _EDX);
          a2 = v22;
        }
        *(_DWORD *)(v4 + 4) = v5;
        *(_DWORD *)v4 = v23;
      }
      v3 += 8;
      v4 += 8;
    }
    while ( v3 != a2 );
    result = v4;
  }
  return result;
}

//----- (10026980) --------------------------------------------------------
int __usercall sub_10026980<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v3; // eax@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ebx@2
  int *v8; // [sp+20h] [bp-10h]@1

  v8 = (int *)a1;
  v4 = a2;
  v3 = sub_1002ADB1(a1, a2, a3, a2, 168);
  v5 = v3;
  if ( v3 )
  {
    *(_DWORD *)(v3 + 4) = 1;
    *(_DWORD *)(v3 + 8) = 1;
    v6 = v3 + 12;
    *(_DWORD *)v3 = &off_10068FB0;
    if ( v3 != -12 )
    {
      sub_10009600((void *)(v3 + 12), *v8);
      *(_DWORD *)v6 = &off_10069020;
    }
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)v4 = v5 + 12;
  *(_DWORD *)(v4 + 4) = v5;
  return v4;
}
// 10068FB0: using guessed type int (*off_10068FB0)();
// 10069020: using guessed type int (__stdcall *off_10069020)(char);

//----- (10026A30) --------------------------------------------------------
void __cdecl sub_10026A30(int a1)
{
  JUMPOUT(*(unsigned int *)loc_10026A50);
}
// 10026A50: using guessed type int __cdecl loc_10026A50(int);

//----- (10026A40) --------------------------------------------------------
int __usercall sub_10026A40<eax>(int a1<eax>, int a2)
{
  int v2; // esi@1
  int v4; // edx@4
  unsigned int v5; // [sp-18h] [bp-54h]@1
  int v6; // [sp-14h] [bp-50h]@3
  int v7; // [sp-10h] [bp-4Ch]@3
  int v8; // [sp-Ch] [bp-48h]@3
  char v9; // [sp-8h] [bp-44h]@3
  int v10; // [sp+0h] [bp-3Ch]@4
  int v11; // [sp+4h] [bp-38h]@4
  int v12; // [sp+8h] [bp-34h]@1
  unsigned int v13; // [sp+28h] [bp-14h]@1
  unsigned int *v14; // [sp+2Ch] [bp-10h]@1
  int v15; // [sp+30h] [bp-Ch]@1
  int (__cdecl *v16)(int, int); // [sp+34h] [bp-8h]@1
  int v17; // [sp+38h] [bp-4h]@1
  _DWORD *v18; // [sp+3Ch] [bp+0h]@1

  v18 = &v18;
  v17 = -1;
  v16 = sub_1005CF40;
  v15 = a1;
  v13 = (unsigned int)&v18 ^ __security_cookie;
  v5 = (unsigned int)&v18 ^ __security_cookie;
  v14 = &v5;
  v2 = *(_DWORD *)(a2 + 32);
  v12 = a2;
  sub_1002B62D((int)&v18, v2 + 100);
  v17 = -1;
  if ( *(_DWORD *)(v2 + 84) == 4 )
  {
    sub_1002B6D6();
  }
  else
  {
    *(_DWORD *)(v2 + 84) = 1;
    sub_1002B6D6();
    v17 = 1;
    LOBYTE(v10) = 0;
    LOBYTE(v11) = 0;
    sub_10027860(v4, a2, a2, v11, v10);
  }
  return sub_1002A49B(v8, v6, v7, (unsigned int)&v18 ^ v13, v9);
}
// 1005CF40: using guessed type int __cdecl sub_1005CF40(int, int);
// 10074200: using guessed type int __security_cookie;

//----- (10026C50) --------------------------------------------------------
int *__thiscall sub_10026C50(int this)
{
  int *result; // eax@1
  int v2; // ecx@1
  int v3; // esi@1
  int v4; // [sp+Ch] [bp-Ch]@1
  int v5; // [sp+14h] [bp-4h]@1

  result = &v4;
  v3 = this;
  *(_DWORD *)this = &off_10068FE8;
  v5 = 0;
  v2 = *(_DWORD *)(this + 4);
  if ( v2 )
    result = (int *)(*(int (__stdcall **)(signed int))(*(_DWORD *)v2 + 4))(1);
  *(_DWORD *)v3 = &off_10069340;
  return result;
}
// 10068FE8: using guessed type int (__stdcall *off_10068FE8)(char);
// 10069340: using guessed type int (__stdcall *off_10069340)(char);

//----- (10026D10) --------------------------------------------------------
int __thiscall sub_10026D10(int this, int a2, int a3)
{
  int result; // eax@2

  if ( a3 == *(_DWORD *)(this + 8) && (result = *(_DWORD *)(this + 4)) != 0 && *(_DWORD *)(result + 4) == a2 )
    *(_DWORD *)(this + 4) = 0;
  else
    result = 0;
  return result;
}

//----- (10026E30) --------------------------------------------------------
char __userpurge sub_10026E30<al>(int a1<ecx>, int a2<ebx>, int a3, int a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  int v8; // ecx@4

  v5 = a1;
  *(_DWORD *)(a1 + 8) = a3;
  v4 = sub_1002CB8B(a2, a1, 0x14u);
  v6 = v4;
  if ( v4 )
  {
    *(_DWORD *)(v4 + 12) = 0;
    sub_1002A371(v4);
    *(_DWORD *)v6 = &off_10069044;
    *(_DWORD *)(v6 + 8) = *(_DWORD *)a4;
    *(_DWORD *)(v6 + 12) = 0;
    *(_DWORD *)(v6 + 16) = 0;
  }
  else
  {
    v6 = 0;
  }
  v8 = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(v5 + 4) = v6;
  return (*(int (__cdecl **)(int, int))(*(_DWORD *)v8 + 8))(v6, v5) == 0;
}
// 10069044: using guessed type int (*off_10069044)();

//----- (10026F10) --------------------------------------------------------
int __thiscall sub_10026F10(void *this)
{
  int v1; // ecx@1
  int ebp0; // ebp@0
  int v3; // esi@1
  char v4; // zf@3
  int result; // eax@5
  char v6; // [sp+8h] [bp-1Ch]@4
  void *v7; // [sp+14h] [bp-10h]@1
  int v8; // [sp+20h] [bp-4h]@1

  v3 = (int)this;
  v7 = this;
  *(_DWORD *)this = &off_10068FC0;
  v8 = 3;
  sub_10027090(this);
  sub_10027610(v3);
  v1 = *(_DWORD *)(v3 + 4);
  if ( v1 )
    (*(void (__stdcall **)(signed int))(*(_DWORD *)v1 + 4))(1);
  LOBYTE(v8) = 2;
  v4 = *(_DWORD *)(v3 + 96) == 0;
  *(_DWORD *)(v3 + 92) = &off_10069188;
  if ( !v4 )
  {
    sub_1002FFB9((int)&v6, (unsigned int)"Deleting link registry before removing all the links");
    sub_100355DB((int)&v6, (int)&unk_1006D8B8);
  }
  LOBYTE(v8) = 1;
  nullsub_2(v3 + 52);
  LOBYTE(v8) = 0;
  result = sub_1002C0CF(ebp0);
  *(_DWORD *)v3 = &off_10069340;
  return result;
}
// 1002B6E4: using guessed type int __thiscall nullsub_2(_DWORD);
// 10068FC0: using guessed type int (__stdcall *off_10068FC0)(char);
// 10069188: using guessed type void *off_10069188;
// 10069340: using guessed type int (__stdcall *off_10069340)(char);

//----- (10026FD0) --------------------------------------------------------
void __thiscall sub_10026FD0(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1
  unsigned int v4; // [sp-4h] [bp-48h]@1
  int (__stdcall **v5)(char); // [sp+8h] [bp-3Ch]@2
  int v6; // [sp+14h] [bp-30h]@2
  char v7; // [sp+18h] [bp-2Ch]@5
  unsigned int v8; // [sp+34h] [bp-10h]@1
  int v9; // [sp+40h] [bp-4h]@3
  int v10; // [sp+44h] [bp+0h]@1

  v8 = (unsigned int)&v10 ^ __security_cookie;
  v4 = (unsigned int)&v10 ^ __security_cookie;
  v3 = this;
  if ( !a2 )
  {
    v6 = (int)"_PTarget";
    sub_1002AEA4((int)&v5, &v6);
    v5 = &off_100602FC;
    sub_100355DB((int)&v5, (int)&unk_1006D8F4);
  }
  sub_1002B589(ebp0, (int)((char *)v3 + 52));
  v9 = 0;
  if ( (unsigned __int8)(*(int (__stdcall **)(int, unsigned int))(*((_DWORD *)v3 + 23) + 4))(a2, v4) )
  {
    (*(void (__thiscall **)(int, void *))(*(_DWORD *)a2 + 20))(a2, v3);
    *((_DWORD *)v3 + 12) = 1;
    sub_1002C5B4(ebp0);
  }
  v9 = -1;
  sub_1002B6DD(&v7);
}
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);
// 10074200: using guessed type int __security_cookie;

//----- (10027090) --------------------------------------------------------
void __thiscall sub_10027090(void *this)
{
  int ebp0; // ebp@0
  void *v2; // edi@1
  unsigned int v3; // ST04_4@1
  int v4; // eax@1
  int v5; // esi@2
  int (__thiscall *v6)(_DWORD, _DWORD); // eax@2
  char v7; // [sp+Ch] [bp-38h]@5
  int v8; // [sp+28h] [bp-1Ch]@1
  int v9; // [sp+2Ch] [bp-18h]@1
  int i; // [sp+30h] [bp-14h]@1
  unsigned int v11; // [sp+34h] [bp-10h]@1
  int v12; // [sp+40h] [bp-4h]@1
  int v13; // [sp+44h] [bp+0h]@1

  v11 = (unsigned int)&v13 ^ __security_cookie;
  v3 = (unsigned int)&v13 ^ __security_cookie;
  v2 = this;
  sub_1002B589(ebp0, (int)((char *)this + 52));
  v12 = 0;
  v4 = *((_DWORD *)v2 + 23);
  v8 = 0;
  i = 0;
  (*(void (__thiscall **)(char *, int *, unsigned int))(v4 + 16))((char *)v2 + 92, &v8, v3);
  for ( i = (*(int (__stdcall **)(int))(*(_DWORD *)v8 + 24))(v9);
        i;
        i = (*(int (__stdcall **)(int))(*(_DWORD *)v8 + 24))(v9) )
  {
    v5 = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)v8 + 24))(v9);
    v6 = *(int (__thiscall **)(_DWORD, _DWORD))(*((_DWORD *)v2 + 23) + 4);
    i = v5;
    if ( (unsigned __int8)v6((char *)v2 + 92, v5) )
      (*(void (__thiscall **)(int, void *))(*(_DWORD *)v5 + 20))(v5, v2);
    ++v9;
    (*(void (__stdcall **)(int *))(*(_DWORD *)v8 + 20))(&v9);
  }
  *((_DWORD *)v2 + 12) = 1;
  sub_1002C5B4(ebp0);
  v12 = -1;
  sub_1002B6DD(&v7);
}
// 10074200: using guessed type int __security_cookie;

//----- (10027190) --------------------------------------------------------
int __thiscall sub_10027190(int this, int a2, int a3)
{
  int ebp0; // ebp@0
  int v4; // esi@1
  int result; // eax@2
  int v6; // edi@4

  v4 = this;
  if ( a3 && (unsigned __int8)(*(int (__thiscall **)(int, int))(*(_DWORD *)(this + 92) + 8))(this + 92, a3) )
  {
    v6 = *(_DWORD *)(v4 + 4);
    if ( v6 && *(_DWORD *)(v6 + 4) == a2 )
    {
      *(_DWORD *)(v4 + 4) = 0;
      *(_DWORD *)(v4 + 48) = 0;
      sub_1002C5B4(ebp0);
      result = v6;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100273C0) --------------------------------------------------------
int __thiscall sub_100273C0(void *this, int a2)
{
  int result; // eax@1

  _ECX = (int)((char *)this + 100);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (100273D0) --------------------------------------------------------
int __thiscall sub_100273D0(void *this, int a2)
{
  int result; // eax@1

  _ECX = (int)((char *)this + 100);
  _EAX = -1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (100273E0) --------------------------------------------------------
bool __thiscall sub_100273E0(void *this, int a2, int a3)
{
  int ebp0; // ebp@0
  int v4; // edi@1
  int v5; // eax@3
  int v6; // esi@3
  int v7; // esi@6
  unsigned int v9; // [sp-4h] [bp-4Ch]@1
  int (__stdcall **v10)(char); // [sp+Ch] [bp-3Ch]@2
  int v11; // [sp+18h] [bp-30h]@2
  char v12; // [sp+1Ch] [bp-2Ch]@6
  unsigned int v13; // [sp+38h] [bp-10h]@1
  int v14; // [sp+44h] [bp-4h]@3
  int v15; // [sp+48h] [bp+0h]@1

  v13 = (unsigned int)&v15 ^ __security_cookie;
  v9 = (unsigned int)&v15 ^ __security_cookie;
  v4 = (int)this;
  if ( !a2 )
  {
    v11 = (int)"_PTarget";
    sub_1002AEA4((int)&v10, &v11);
    v10 = &off_100602FC;
    sub_100355DB((int)&v10, (int)&unk_1006D8F4);
  }
  v5 = sub_1002CB8B(a2, v4, 0x14u);
  v6 = v5;
  v11 = v5;
  v14 = 0;
  if ( v5 )
  {
    *(_DWORD *)(v5 + 12) = 0;
    sub_1002A371(v5);
    *(_DWORD *)v6 = &off_10069044;
    *(_DWORD *)(v6 + 8) = *(_DWORD *)a3;
    *(_DWORD *)(v6 + 12) = 0;
    *(_DWORD *)(v6 + 16) = 0;
  }
  else
  {
    v6 = 0;
  }
  v14 = -1;
  sub_1002B589(ebp0, v4 + 52);
  v14 = 1;
  (*(void (__thiscall **)(int, int, unsigned int))(*(_DWORD *)v4 + 4))(v4, a2, v9);
  *(_DWORD *)(v4 + 4) = v6;
  v7 = (*(int (__thiscall **)(int, int, int))(*(_DWORD *)a2 + 8))(a2, v6, v4);
  v14 = -1;
  sub_1002B6DD(&v12);
  if ( v7 == 2 )
  {
    sub_1002C6B5(ebp0, a2, v4, -1);
    v7 = *(_DWORD *)(v4 + 48);
  }
  return v7 == 0;
}
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);
// 10069044: using guessed type int (*off_10069044)();
// 10074200: using guessed type int __security_cookie;

//----- (10027570) --------------------------------------------------------
void *__thiscall sub_10027570(int this, char a2)
{
  int v2; // ecx@1
  void *v3; // esi@1

  v3 = (void *)this;
  *(_DWORD *)this = &off_10068FE8;
  v2 = *(_DWORD *)(this + 4);
  if ( v2 )
    (*(void (__stdcall **)(signed int))(*(_DWORD *)v2 + 4))(1);
  *(_DWORD *)v3 = &off_10069340;
  if ( a2 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10068FE8: using guessed type int (__stdcall *off_10068FE8)(char);
// 10069340: using guessed type int (__stdcall *off_10069340)(char);

//----- (100275E0) --------------------------------------------------------
void *__thiscall sub_100275E0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_10026F10(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10027610) --------------------------------------------------------
char __thiscall sub_10027610(int this)
{
  int v1; // eax@1
  int v2; // esi@1
  char v3; // zf@1
  char v4; // zf@3
  char v5; // zf@5
  DWORD v6; // eax@12
  char v8; // [sp+8h] [bp-18h]@1
  DWORD v9; // [sp+Ch] [bp-14h]@3
  int v10; // [sp+10h] [bp-10h]@4
  int v11; // [sp+14h] [bp-Ch]@1
  int (*v12)(void); // [sp+18h] [bp-8h]@1
  unsigned int v13; // [sp+1Ch] [bp-4h]@1

  v1 = (unsigned int)&v8 ^ __security_cookie;
  v13 = (unsigned int)&v8 ^ __security_cookie;
  v2 = this;
  v3 = *(_DWORD *)(this + 100) == 0;
  v11 = 0;
  v12 = sub_10034C15;
  if ( !v3 )
  {
    do
    {
      v1 = v11;
      switch ( v11 )
      {
        case 1:
          __asm { pause                   ; jumptable 1002765D case 1 }
          v4 = v9-- == 1;
          if ( v4 )
          {
            v1 = 3 - (v10 != 0);
            v11 = 3 - (v10 != 0);
          }
          break;
        case 2:
          v5 = v10-- == 1;
          if ( v5 )
            v1 = 3;
          v11 = v1;
          goto LABEL_8;
        case 4:
LABEL_8:
          LOBYTE(v1) = v12();
          break;
        case 3:
          v11 = 0;
          v1 = sub_1002BD66();
          if ( v1 )
          {
            v9 = v1;
            v10 = 1;
            v11 = 1;
          }
          else
          {
            v11 = 4;
          }
          break;
        case 0:
          v11 = 0;
          v6 = sub_1002BD66();
          if ( v6 )
          {
            v9 = v6;
            v10 = 1;
            v11 = 1;
          }
          else
          {
            v11 = 4;
          }
          LOBYTE(v1) = sub_100282E0((int)&v9);
          break;
        default:
          break;
      }
    }
    while ( *(_DWORD *)(v2 + 100) );
  }
  return v1;
}
// 10074200: using guessed type int __security_cookie;

//----- (10027730) --------------------------------------------------------
#error "1002784F: positive sp value has been found (funcsize=85)"

//----- (10027860) --------------------------------------------------------
void __userpurge sub_10027860(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // edx@1
  int ebp0; // ebp@0
  int v8; // edi@1
  int v9; // esi@1
  int v10; // ebx@1
  int v11; // eax@1
  int v28; // edi@10
  int v29; // eax@10
  int v30; // edx@14
  char v44; // [sp-20h] [bp-94h]@8
  int v45; // [sp-1Ch] [bp-90h]@10
  int v46; // [sp-18h] [bp-8Ch]@10
  int v47; // [sp-14h] [bp-88h]@10
  char v48; // [sp-8h] [bp-7Ch]@6
  int v49; // [sp-4h] [bp-78h]@6
  char v50; // [sp+10h] [bp-64h]@1
  int v51; // [sp+14h] [bp-60h]@1
  int v52; // [sp+18h] [bp-5Ch]@1
  char *v53; // [sp+1Ch] [bp-58h]@1
  int v54; // [sp+20h] [bp-54h]@1
  char *v55; // [sp+24h] [bp-50h]@1
  int v56; // [sp+28h] [bp-4Ch]@1
  char v57; // [sp+2Ch] [bp-48h]@10
  int v58; // [sp+3Ch] [bp-38h]@13
  unsigned int v59; // [sp+60h] [bp-14h]@1
  int v60; // [sp+70h] [bp-4h]@1

  v59 = (unsigned int)&v50 ^ __security_cookie;
  v10 = a2;
  v54 = a2;
  v51 = 0;
  v52 = 0;
  sub_10006BC0(a1, (int)&v51, a3, a2);
  v60 = 0;
  v11 = sub_10004DE0((int)&v55, v10 + 40);
  v9 = *(_DWORD *)(v11 + 4);
  *(_DWORD *)(v11 + 4) = v52;
  v5 = *(_DWORD *)v11;
  *(_DWORD *)v11 = v51;
  v8 = v56;
  _EBX = -1;
  v52 = v9;
  v53 = (char *)v5;
  v51 = v5;
  if ( v56 )
  {
    _EAX = v56 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v8)(v8);
      _EAX = v8 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v8 + 4))(v8, _EDX);
      v5 = (int)v53;
    }
  }
  v53 = &v48;
  *(_DWORD *)&v48 = 0;
  v49 = 0;
  if ( (int *)&v48 != &v51 )
  {
    v49 = v9;
    v9 = 0;
    v52 = 0;
    *(_DWORD *)&v48 = v5;
    v51 = 0;
  }
  v55 = &v44;
  LOBYTE(v60) = 2;
  _EAX = (char *)sub_1002ADB1(v5, (int)&v51, -1, (int)&v44, 32);
  if ( !_EAX )
    sub_10029530();
  _ECX = v54;
  *(_DWORD *)_EAX = off_10068EEC;
  __asm
  {
    movq    xmm0, qword ptr [ecx+30h]
    movq    qword ptr [eax+8], xmm0
    movq    xmm0, qword ptr [ecx+38h]
    movq    qword ptr [eax+10h], xmm0
  }
  LOBYTE(v60) = 1;
  v29 = sub_10027B00((int)&v57, v44, v45, v46, v47, _EAX);
  LOBYTE(v60) = 4;
  v28 = *(_DWORD *)(v54 + 32);
  *(_DWORD *)(v28 + 152) = sub_10027B90(v29, v48, v49);
  sub_1002B62D(ebp0, v28 + 100);
  LOBYTE(v60) = 4;
  if ( *(_DWORD *)(v28 + 84) == 4 )
  {
    sub_1002B6D6();
  }
  else
  {
    *(_DWORD *)(v28 + 84) = 3;
    sub_1002B6D6();
    sub_1002C5B4(ebp0);
    sub_1000A690(v28);
  }
  LOBYTE(v60) = 0;
  if ( v58 )
  {
    v30 = *(_DWORD *)v58;
    v49 = v58 != (_DWORD)&v57;
    (*(void (__stdcall **)(int))(v30 + 16))(v49);
    v58 = 0;
  }
  v60 = -1;
  if ( v9 )
  {
    _EAX = v9 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v9)(v9);
      _EAX = v9 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (**)(void))(*(_DWORD *)v9 + 4))();
    }
  }
}
// 10068EEC: using guessed type int (__stdcall *off_10068EEC[3])(int);
// 10074200: using guessed type int __security_cookie;

//----- (10027A80) --------------------------------------------------------
int __thiscall sub_10027A80(int this, char a2, int a3, int a4, int a5, int a6)
{
  int v6; // edi@1

  v6 = this;
  sub_10027C20((int)&a2, this, this);
  if ( a6 )
    (*(void (__stdcall **)(bool))(*(_DWORD *)a6 + 16))(a6 != (_DWORD)&a2);
  return v6;
}

//----- (10027B00) --------------------------------------------------------
int __thiscall sub_10027B00(int this, char a2, int a3, int a4, int a5, char *a6)
{
  int v6; // edi@1
  char *v7; // esi@1
  int v9; // [sp-4h] [bp-24h]@4

  v6 = this;
  v7 = a6;
  if ( a6 )
  {
    if ( a6 == &a2 )
      v9 = this;
    else
      v9 = 0;
    v7 = a6;
    *(_DWORD *)(this + 16) = (**(int (__stdcall ***)(_DWORD))a6)(v9);
  }
  else
  {
    *(_DWORD *)(this + 16) = a6;
  }
  if ( v7 )
    (*(void (__thiscall **)(char *, bool))(*(_DWORD *)v7 + 16))(v7, v7 != &a2);
  return v6;
}

//----- (10027B90) --------------------------------------------------------
int __thiscall sub_10027B90(int this, char a2, int a3)
{
  int v3; // ecx@1
  int v4; // ebx@3
  int v5; // esi@3

  v3 = *(_DWORD *)(this + 16);
  if ( !v3 )
    sub_10029561();
  v5 = a3;
  v4 = (*(int (__stdcall **)(char *))(*(_DWORD *)v3 + 8))(&a2);
  if ( a3 )
  {
    _EDI = -1;
    _EDX = a3 + 4;
    _ECX = -1;
    __asm { lock xadd [edx], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      _EAX = v5 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (**)(void))(*(_DWORD *)v5 + 4))();
    }
  }
  return v4;
}

//----- (10027C20) --------------------------------------------------------
int __usercall sub_10027C20<eax>(int a1<edx>, int a2<ecx>, int a3<edi>)
{
  int v3; // ecx@1
  int v4; // esi@1
  char *v6; // [sp-4h] [bp-3Ch]@4
  char v7; // [sp+8h] [bp-30h]@1
  int v8; // [sp+18h] [bp-20h]@2
  char *v9; // [sp+20h] [bp-18h]@1
  int v10; // [sp+24h] [bp-14h]@1
  int v11; // [sp+28h] [bp-10h]@1
  int v12; // [sp+34h] [bp-4h]@1

  v4 = a2;
  v11 = a2;
  v10 = 0;
  v9 = &v7;
  v12 = 0;
  v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    if ( v3 == a1 )
    {
      a1 = (int)&v7;
      v6 = &v7;
    }
    else
    {
      v6 = 0;
    }
    v8 = (**(int (__fastcall ***)(int, int, char *))v3)(v3, a1, v6);
  }
  else
  {
    v8 = 0;
  }
  v12 = 2;
  sub_10028040(a1, v4, a3, (int)&v7, v3);
  v12 = -1;
  if ( v8 )
    (*(void (__stdcall **)(bool))(*(_DWORD *)v8 + 16))(v8 != (_DWORD)&v7);
  return v4;
}

//----- (10027D10) --------------------------------------------------------
int __thiscall sub_10027D10(int this, int a2)
{
  return (*(int (__thiscall **)(_DWORD, _DWORD))(this + 4))(*(_DWORD *)(this + 8), *(_DWORD *)a2);
}

//----- (10027D30) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10027D30())(char)
{
  return &off_10075DA0;
}
// 10075DA0: using guessed type int (__stdcall **off_10075DA0)(char);

//----- (10027D80) --------------------------------------------------------
int __thiscall sub_10027D80(int this, int a2)
{
  return (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(this + 4) + 36))(*(_DWORD *)a2);
}

//----- (10027DA0) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10027DA0())(char)
{
  return &off_10075D64;
}
// 10075D64: using guessed type int (__stdcall **off_10075D64)(char);

//----- (10027DF0) --------------------------------------------------------
int __thiscall sub_10027DF0(int this, int a2)
{
  return (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(this + 4) + 40))(*(_DWORD *)a2);
}

//----- (10027E10) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10027E10())(char)
{
  return &off_10075D2C;
}
// 10075D2C: using guessed type int (__stdcall **off_10075D2C)(char);

//----- (10027E60) --------------------------------------------------------
void __thiscall sub_10027E60(int this, int a2)
{
  int ebp0; // ebp@0
  int v3; // edi@1
  int v4; // esi@1
  char v5; // [sp+8h] [bp-2Ch]@1
  unsigned int v6; // [sp+24h] [bp-10h]@1
  int v7; // [sp+30h] [bp-4h]@1
  int v8; // [sp+34h] [bp+0h]@1

  v6 = (unsigned int)&v8 ^ __security_cookie;
  v3 = *(_DWORD *)(this + 4);
  v4 = *(_DWORD *)a2;
  sub_1002B589(ebp0, v3 + 176);
  v7 = 0;
  (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 76))(v3, v4);
  v7 = -1;
  sub_1002B6DD(&v5);
}
// 10074200: using guessed type int __security_cookie;

//----- (10027EE0) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10027EE0())(char)
{
  return &off_10075CF4;
}
// 10075CF4: using guessed type int (__stdcall **off_10075CF4)(char);

//----- (10027F30) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10027F30())(char)
{
  return &off_10075CBC;
}
// 10075CBC: using guessed type int (__stdcall **off_10075CBC)(char);

//----- (10027F80) --------------------------------------------------------
BOOL __userpurge sub_10027F80<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  return sub_100220F0(a1, a2 + 4, a3, a4);
}

//----- (10027F90) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10027F90())(char)
{
  return &off_10075C84;
}
// 10075C84: using guessed type int (__stdcall **off_10075C84)(char);

//----- (10027FA0) --------------------------------------------------------
int __userpurge sub_10027FA0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int result; // eax@1
  int v7; // edi@4
  int v8; // ecx@4
  int v9; // ecx@5
  int v10; // [sp-14h] [bp-18h]@4
  int v11; // [sp-10h] [bp-14h]@4
  int v12; // [sp-Ch] [bp-10h]@4
  int v13; // [sp-8h] [bp-Ch]@4
  _DWORD *v14; // [sp+4h] [bp+0h]@4

  result = a5;
  _ESI = a2;
  if ( a5 || (result = sub_1002ADB1(a1, a2, a3, a4, 32)) != 0 )
  {
    *(_DWORD *)result = off_10068EEC;
    __asm
    {
      movq    xmm0, qword ptr [esi+8]
      movq    qword ptr [eax+8], xmm0
      movq    xmm0, qword ptr [esi+10h]
      movq    qword ptr [eax+10h], xmm0
    }
  }
  else
  {
    sub_10029530();
    __asm { int     3               ; Trap to Debugger }
    v14 = &v14;
    v13 = _ESI;
    v12 = a4;
    v7 = v8;
    v10 = 0;
    v11 = 0;
    if ( &v10 != (int *)a5 )
    {
      v11 = *(_DWORD *)(a5 + 4);
      *(_DWORD *)(a5 + 4) = 0;
      v9 = v10;
      v10 = *(_DWORD *)a5;
      *(_DWORD *)a5 = v9;
    }
    result = sub_10022720((void *)(v7 + 8), v10, v11);
  }
  return result;
}
// 10068EEC: using guessed type int (__stdcall *off_10068EEC[3])(int);

//----- (10028030) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10028030())(char)
{
  return &off_10075C4C;
}
// 10075C4C: using guessed type int (__stdcall **off_10075C4C)(char);

//----- (10028040) --------------------------------------------------------
int __userpurge sub_10028040<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // esi@1
  int v6; // ecx@3
  int result; // eax@9
  int v8; // [sp-4h] [bp-30h]@6
  int v9; // [sp+1Ch] [bp-10h]@1

  v9 = a2;
  v5 = sub_1002ADB1(a1, a2, a4, a3, 40);
  if ( !v5 )
    sub_10029530();
  *(_DWORD *)v5 = off_10068ED0;
  v6 = *(_DWORD *)(a4 + 16);
  if ( v6 )
  {
    if ( v6 == a4 )
      v8 = v5 + 8;
    else
      v8 = 0;
    *(_DWORD *)(v5 + 24) = (**(int (__stdcall ***)(_DWORD))v6)(v8);
  }
  else
  {
    *(_DWORD *)(v5 + 24) = 0;
  }
  result = v9;
  *(_DWORD *)(v9 + 16) = v5;
  return result;
}
// 10068ED0: using guessed type int (__stdcall *off_10068ED0[2])(int);

//----- (100280E0) --------------------------------------------------------
int __userpurge sub_100280E0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4)
{
  int v4; // ebx@1
  int v5; // esi@1
  int v6; // ecx@5
  int v7; // eax@8

  v4 = a2;
  v5 = a4;
  if ( !a4 )
  {
    v5 = sub_1002ADB1(a1, a2, a2, a3, 40);
    if ( !v5 )
      sub_10029530();
  }
  if ( v5 )
  {
    *(_DWORD *)v5 = off_10068ED0;
    v6 = *(_DWORD *)(v4 + 24);
    if ( v6 )
    {
      if ( v6 == v4 + 8 )
        v7 = (**(int (__stdcall ***)(_DWORD))v6)(v5 + 8);
      else
        v7 = (**(int (__stdcall ***)(_DWORD))v6)(0);
      *(_DWORD *)(v5 + 24) = v7;
    }
    else
    {
      *(_DWORD *)(v5 + 24) = 0;
    }
  }
  return v5;
}
// 10068ED0: using guessed type int (__stdcall *off_10068ED0[2])(int);

//----- (100281B0) --------------------------------------------------------
int (__stdcall ***__cdecl sub_100281B0())(char)
{
  return &off_10075C14;
}
// 10075C14: using guessed type int (__stdcall **off_10075C14)(char);

//----- (100281C0) --------------------------------------------------------
void *__thiscall sub_100281C0(int this, char a2)
{
  int v2; // ecx@1
  int v3; // edi@1
  void *v4; // esi@1
  int v5; // ecx@3

  v4 = (void *)this;
  v3 = this + 8;
  *(_DWORD *)this = off_10068ED0;
  v2 = *(_DWORD *)(this + 24);
  if ( v2 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v2 + 16))(v2 != v3);
    *(_DWORD *)(v3 + 16) = 0;
  }
  v5 = *(_DWORD *)(v3 + 16);
  if ( v5 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v5 + 16))(v5 != v3);
    *(_DWORD *)(v3 + 16) = 0;
  }
  *(_DWORD *)v4 = off_10068098;
  if ( a2 & 1 )
    sub_1002A4AA(v4);
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10068098: using guessed type int (*off_10068098[5])();
// 10068ED0: using guessed type int (__stdcall *off_10068ED0[2])(int);

//----- (10028225) --------------------------------------------------------
void *__userpurge sub_10028225<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  return sub_100249E0(a1 - 16, a2, a3, a4);
}

//----- (10028230) --------------------------------------------------------
int __thiscall sub_10028230(int this)
{
  return *(_DWORD *)(this + 4);
}

//----- (10028240) --------------------------------------------------------
int __userpurge sub_10028240<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_100616A8;
  return v4;
}
// 100616A8: using guessed type int (__stdcall *off_100616A8)(char);

//----- (10028270) --------------------------------------------------------
int __userpurge sub_10028270<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_100616C0;
  return v4;
}
// 100616C0: using guessed type int (__stdcall *off_100616C0)(char);

//----- (10028290) --------------------------------------------------------
int __userpurge sub_10028290<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_100616B4;
  return v4;
}
// 100616B4: using guessed type int (__stdcall *off_100616B4)(char);

//----- (100282B0) --------------------------------------------------------
DWORD __thiscall sub_100282B0(int this)
{
  DWORD result; // eax@1
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 8) = 0;
  result = sub_1002BD66();
  if ( result )
  {
    *(_DWORD *)v2 = result;
    *(_DWORD *)(v2 + 4) = 1;
    *(_DWORD *)(v2 + 8) = 1;
  }
  else
  {
    *(_DWORD *)(v2 + 8) = 4;
  }
  return result;
}

//----- (100282E0) --------------------------------------------------------
char __thiscall sub_100282E0(int this)
{
  unsigned int v1; // eax@1
  int v2; // esi@1
  char result; // al@4
  char v4; // zf@5
  char v5; // zf@8

  v2 = this;
  v1 = *(_DWORD *)(this + 8);
  while ( 2 )
  {
    switch ( v1 )
    {
      case 0u:
        sub_100282B0(v2);
        v1 = *(_DWORD *)(v2 + 8);
        if ( v1 <= 4 )
          continue;
        result = 0;
        break;
      case 1u:
        __asm { pause                   ; jumptable 100282F0 case 1 }
        v4 = *(_DWORD *)v2-- == 1;
        if ( v4 )
          *(_DWORD *)(v2 + 8) = 3 - (*(_DWORD *)(v2 + 4) != 0);
        result = 1;
        break;
      case 2u:
        v5 = *(_DWORD *)(v2 + 4)-- == 1;
        if ( v5 )
          *(_DWORD *)(v2 + 8) = 3;
        (*(void (**)(void))(v2 + 12))();
        result = 1;
        break;
      case 3u:
        sub_100282B0(v2);
        result = 0;
        break;
      case 4u:
        (*(void (**)(void))(v2 + 12))();
        goto LABEL_13;
      default:
LABEL_13:
        result = 0;
        break;
    }
    return result;
  }
}

//----- (10028360) --------------------------------------------------------
int __usercall sub_10028360<eax>(int a1<ecx>, int a2<edi>)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // ebx@1
  int ebp0; // ebp@0
  char *v6; // esi@1
  int v7; // ecx@2
  int result; // eax@4
  int v9; // eax@5
  int v10; // ecx@5
  int v11; // edi@5
  int v12; // eax@8

  v4 = a1;
  v6 = sub_1002F41A(a1, ebp0, a2);
  ++*(_DWORD *)v6;
  if ( *(_DWORD *)v6 > 0x10u )
  {
    v9 = sub_1002ADB1(v2, v3, v4, a2, 24);
    v11 = v9;
    if ( v9 )
    {
      v10 = *(_DWORD *)(v4 + 16);
      if ( v10 )
      {
        v12 = *(_DWORD *)v10;
        if ( v10 == v4 )
          *(_DWORD *)(v11 + 16) = (*(int (__stdcall **)(int))v12)(v11);
        else
          *(_DWORD *)(v11 + 16) = (*(int (__stdcall **)(_DWORD))v12)(0);
      }
      else
      {
        *(_DWORD *)(v9 + 16) = 0;
      }
    }
    else
    {
      v11 = 0;
    }
    result = sub_1002FEEC(v10, v4, v11, (int)&loc_1000A1F0, v11);
    --*(_DWORD *)v6;
  }
  else
  {
    v7 = *(_DWORD *)(v4 + 16);
    if ( !v7 )
      sub_10029561();
    result = (*(int (**)(void))(*(_DWORD *)v7 + 8))();
    --*(_DWORD *)v6;
  }
  return result;
}

//----- (10028530) --------------------------------------------------------
int __thiscall sub_10028530(void *this, int a2, DWORD a3)
{
  int v3; // eax@1
  int v4; // esi@1
  char v5; // cf@3
  int v7; // [sp+10h] [bp-2Ch]@3
  void *v8; // [sp+14h] [bp-28h]@1
  unsigned int v9; // [sp+28h] [bp-14h]@3
  int v10; // [sp+38h] [bp-4h]@1

  v4 = (int)this;
  v3 = sub_100285D0((int)&v8, a3);
  v10 = 0;
  if ( *(_DWORD *)(v3 + 20) >= 0x10u )
    v3 = *(_DWORD *)v3;
  v7 = v3;
  sub_1002AEA4(v4, &v7);
  v5 = v9 < 0x10;
  *(_DWORD *)v4 = &off_10060320;
  if ( !v5 )
    sub_1002A4AA(v8);
  *(_DWORD *)(v4 + 12) = a2;
  *(_DWORD *)v4 = &off_100683AC;
  *(_DWORD *)(v4 + 16) = a3;
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10060320: using guessed type int (__stdcall *off_10060320)(char);
// 100683AC: using guessed type int (__stdcall *off_100683AC)(char);

//----- (100285D0) --------------------------------------------------------
int __fastcall sub_100285D0(int a1, DWORD a2)
{
  int v2; // esi@1
  unsigned int v3; // ecx@3
  void *v5; // [sp+Ch] [bp-30h]@2
  int v6; // [sp+1Ch] [bp-20h]@2
  unsigned int v7; // [sp+20h] [bp-1Ch]@2
  int v8; // [sp+24h] [bp-18h]@1
  CHAR hMem[4]; // [sp+28h] [bp-14h]@1
  unsigned int v10; // [sp+2Ch] [bp-10h]@1
  int v11; // [sp+38h] [bp-4h]@1
  int v12; // [sp+3Ch] [bp+0h]@1

  v10 = (unsigned int)&v12 ^ __security_cookie;
  v2 = a1;
  *(_DWORD *)(a1 + 20) = 15;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)a1 = 0;
  v11 = 0;
  v8 = 1;
  FormatMessageA(0x1300u, 0, a2, 0x400u, hMem, 0, 0);
  GetLastError();
  if ( *(_DWORD *)hMem )
  {
    v7 = 15;
    v6 = 0;
    LOBYTE(v5) = 0;
    if ( **(_BYTE **)hMem )
      v3 = strlen(*(const char **)hMem);
    else
      v3 = 0;
    loc_1000AEB0(&v5, *(_DWORD *)hMem, v3);
    if ( (void **)v2 != &v5 )
    {
      if ( *(_DWORD *)(v2 + 20) >= 0x10u )
        sub_1002A4AA(*(LPVOID *)v2);
      *(_DWORD *)(v2 + 20) = 15;
      *(_DWORD *)(v2 + 16) = 0;
      *(_BYTE *)v2 = 0;
      sub_100017B0((void *)v2, (int)&v5);
    }
    if ( v7 >= 0x10 )
      sub_1002A4AA(v5);
    LocalFree(*(HLOCAL *)hMem);
  }
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (100286F0) --------------------------------------------------------
HINTERNET __cdecl sub_100286F0()
{
  HINTERNET result; // eax@1
  int ebp0; // ebp@0
  const WCHAR *v2; // eax@6
  DWORD v3; // [sp-14h] [bp-54h]@7
  const WCHAR *v4; // [sp-10h] [bp-50h]@7
  int i; // [sp-Ch] [bp-4Ch]@4
  const WCHAR *v6; // [sp-Ch] [bp-4Ch]@7
  DWORD v7; // [sp-8h] [bp-48h]@4
  char v8; // [sp+0h] [bp-40h]@5
  unsigned int v9; // [sp+30h] [bp-10h]@1
  int v10; // [sp+3Ch] [bp-4h]@2
  int v11; // [sp+40h] [bp+0h]@1

  v9 = (unsigned int)&v11 ^ __security_cookie;
  result = hInternet;
  if ( !hInternet )
  {
    sub_1002B62D(ebp0, (int)&unk_10077A44);
    v10 = 0;
    if ( !hInternet )
    {
      if ( WinHttpGetIEProxyConfigForCurrentUser(&pProxyConfig) )
        goto LABEL_6;
      v7 = GetLastError();
      for ( i = 12; ; i = 11 )
      {
        sub_10028530(&v8, i, v7);
        sub_100355DB((int)&v8, (int)&unk_1006DA88);
LABEL_6:
        v2 = (const WCHAR *)&pszAgentW;
        if ( pProxyConfig.lpszProxy )
        {
          v6 = pProxyConfig.lpszProxyBypass;
          v4 = pProxyConfig.lpszProxy;
          v3 = 3;
        }
        else
        {
          v6 = 0;
          v4 = 0;
          v3 = 0;
        }
        if ( (unsigned int)dword_10076174 >= 8 )
          v2 = pszAgentW;
        hInternet = WinHttpOpen(v2, v3, v4, v6, 0x10000000u);
        if ( hInternet )
          break;
        v7 = GetLastError();
      }
    }
    v10 = -1;
    sub_1002B6D6();
    result = hInternet;
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10076174: using guessed type int dword_10076174;

//----- (100287F0) --------------------------------------------------------
void *__userpurge sub_100287F0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  void *v4; // esi@1

  v4 = (void *)a1;
  sub_10028820(a1, a2, a3);
  if ( a4 & 1 )
    sub_1002A4AA(v4);
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10028820) --------------------------------------------------------
int __usercall sub_10028820<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // eax@1
  int ebp0; // ebp@0
  int v5; // esi@1
  void *v6; // eax@3

  v5 = a1;
  *(_DWORD *)a1 = &off_10069454;
  v3 = *(_DWORD *)(a1 + 12);
  if ( v3 == 1 || v3 == 2 )
  {
    v6 = *(void **)(a1 + 4);
    *(_DWORD *)(a1 + 12) = 3;
    if ( v6 )
    {
      WinHttpCloseHandle(v6);
      sub_1002C6B5(ebp0, a2, a3, 1000);
      *(_DWORD *)(v5 + 4) = 0;
    }
    if ( *(_DWORD *)(v5 + 8) )
    {
      WinHttpCloseHandle(*(HINTERNET *)(v5 + 8));
      *(_DWORD *)(v5 + 8) = 0;
    }
    *(_DWORD *)(v5 + 12) = 4;
  }
  if ( *(_DWORD *)(v5 + 76) >= 0x10u )
    sub_1002A4AA(*(LPVOID *)(v5 + 56));
  *(_DWORD *)(v5 + 76) = 15;
  *(_DWORD *)(v5 + 72) = 0;
  *(_BYTE *)(v5 + 56) = 0;
  return sub_1002C0CF(ebp0);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10069454: using guessed type int (__stdcall *off_10069454)(char);

//----- (100288F0) --------------------------------------------------------
int __thiscall sub_100288F0(int this, int a2)
{
  int v2; // esi@1
  char v3; // cf@3
  const WCHAR *v4; // eax@4
  DWORD v5; // eax@7
  int v7; // eax@12
  unsigned int v8; // [sp-4h] [bp-94h]@1
  void *v9; // [sp+Ch] [bp-84h]@10
  int v10; // [sp+1Ch] [bp-74h]@10
  unsigned int v11; // [sp+20h] [bp-70h]@10
  void *v12; // [sp+24h] [bp-6Ch]@8
  char v13; // [sp+28h] [bp-68h]@7
  int (__stdcall **v14)(char); // [sp+30h] [bp-60h]@2
  int v15; // [sp+34h] [bp-5Ch]@8
  unsigned int v16; // [sp+38h] [bp-58h]@8
  struct $BC2FB811D417144E831EE3AEA4A279C8 UrlComponents; // [sp+3Ch] [bp-54h]@3
  int v18; // [sp+78h] [bp-18h]@2
  unsigned int v19; // [sp+7Ch] [bp-14h]@1
  int v20; // [sp+8Ch] [bp-4h]@8
  int v21; // [sp+90h] [bp+0h]@1

  v19 = (unsigned int)&v21 ^ __security_cookie;
  v8 = (unsigned int)&v21 ^ __security_cookie;
  v2 = this;
  if ( *(_DWORD *)(this + 12) )
  {
    v18 = (int)"Request is not ready";
    sub_1002AEA4((int)&v14, &v18);
    v14 = &off_100602F0;
    sub_100355DB((int)&v14, (int)&unk_1006D7B8);
  }
  sub_100286F0();
  *(_DWORD *)(v2 + 12) = 1;
  UrlComponents.dwStructSize = 60;
  sub_10039210(&UrlComponents.lpszScheme, 0, 56);
  v3 = *(_DWORD *)(a2 + 20) < 8u;
  UrlComponents.dwSchemeLength = -1;
  UrlComponents.dwHostNameLength = -1;
  UrlComponents.dwUrlPathLength = -1;
  if ( v3 )
    v4 = (const WCHAR *)a2;
  else
    v4 = *(const WCHAR **)a2;
  if ( !WinHttpCrackUrl(v4, *(_DWORD *)(a2 + 16), 0, &UrlComponents) )
  {
    v5 = GetLastError();
    sub_10028530(&v13, 8, v5);
    sub_100355DB((int)&v13, (int)&unk_1006DA88);
  }
  v16 = 7;
  v15 = 0;
  LOWORD(v12) = 0;
  loc_10028430(&v12, UrlComponents.lpszHostName, UrlComponents.dwHostNameLength, v8);
  v20 = 0;
  (*(void (__thiscall **)(int, void **))(*(_DWORD *)v2 + 4))(v2, &v12);
  v20 = -1;
  if ( v16 >= 8 )
    sub_1002A4AA(v12);
  v11 = 7;
  v10 = 0;
  LOWORD(v9) = 0;
  loc_10028430(&v9, UrlComponents.lpszUrlPath, UrlComponents.dwUrlPathLength);
  v20 = 1;
  (*(void (__thiscall **)(int, void **))(*(_DWORD *)v2 + 8))(v2, &v9);
  v20 = -1;
  if ( v11 >= 8 )
    sub_1002A4AA(v9);
  LOWORD(v9) = 0;
  v7 = *(_DWORD *)v2;
  v11 = 7;
  v10 = 0;
  (*(void (__thiscall **)(int))(v7 + 16))(v2);
  return (*(int (__cdecl **)(int))(*(_DWORD *)v2 + 12))(a2);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100602F0: using guessed type int (__stdcall *off_100602F0)(char);
// 10074200: using guessed type int __security_cookie;

//----- (10028AB0) --------------------------------------------------------
int __thiscall sub_10028AB0(void *this, int a2)
{
  return loc_10028E10(a2, this);
}

//----- (10028AC0) --------------------------------------------------------
void __thiscall sub_10028AC0(int this, LPCWSTR pwszObjectName)
{
  int v2; // edi@1
  const WCHAR *v3; // esi@1
  const WCHAR *v4; // eax@5
  DWORD v5; // eax@7
  DWORD v6; // eax@10
  char v7; // [sp+Ch] [bp-48h]@1
  int (__stdcall **v8)(char); // [sp+10h] [bp-44h]@2
  int v9; // [sp+24h] [bp-30h]@2
  LPCWSTR pwszVerb; // [sp+28h] [bp-2Ch]@3
  int v11; // [sp+38h] [bp-1Ch]@3
  unsigned int v12; // [sp+3Ch] [bp-18h]@3
  unsigned int v13; // [sp+40h] [bp-14h]@1
  int v14; // [sp+50h] [bp-4h]@3

  v13 = (unsigned int)&v7 ^ __security_cookie;
  v2 = this;
  v3 = pwszObjectName;
  if ( !*(_DWORD *)(this + 8) )
  {
    v9 = (int)"Invalid connection";
    sub_1002AEA4((int)&v8, &v9);
    v8 = &off_100602F0;
    sub_100355DB((int)&v8, (int)&unk_1006D7B8);
  }
  v12 = 7;
  v11 = 0;
  LOWORD(pwszVerb) = 0;
  v14 = 0;
  loc_10028430(&pwszVerb, L"GET", 3);
  if ( *((_DWORD *)pwszObjectName + 5) >= 8u )
    v3 = *(const WCHAR **)pwszObjectName;
  v4 = (const WCHAR *)&pwszVerb;
  if ( v12 >= 8 )
    v4 = pwszVerb;
  v5 = (DWORD)WinHttpOpenRequest(*(HINTERNET *)(v2 + 8), v4, v3, 0, 0, 0, 0);
  *(_DWORD *)(v2 + 4) = v5;
  if ( !v5 )
  {
    v5 = GetLastError();
    sub_10028530(&v8, 9, v5);
    sub_100355DB((int)&v8, (int)&unk_1006DA88);
  }
  if ( WinHttpSetStatusCallback((HINTERNET)v5, (WINHTTP_STATUS_CALLBACK)fnInternetCallback, 0xFFFFFFFFu, 0) == (WINHTTP_STATUS_CALLBACK)-1 )
  {
    v6 = GetLastError();
    sub_10028530(&v8, 10, v6);
    sub_100355DB((int)&v8, (int)&unk_1006DA88);
  }
  if ( v12 >= 8 )
    sub_1002A4AA((LPVOID)pwszVerb);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100602F0: using guessed type int (__stdcall *off_100602F0)(char);
// 1006944C: using guessed type wchar_t aGet[4];
// 10074200: using guessed type int __security_cookie;

//----- (10028C20) --------------------------------------------------------
void __thiscall sub_10028C20(DWORD_PTR this)
{
  sub_10028EB0(this, 0, 0, 0, 0);
}

//----- (10028D60) --------------------------------------------------------
int __stdcall sub_10028D60(char a1, int a2)
{
  return sub_1002FDDA((int)&a1);
}

//----- (10028EB0) --------------------------------------------------------
void __thiscall sub_10028EB0(DWORD_PTR dwContext, LPVOID lpOptional, DWORD dwOptionalLength, DWORD dwTotalLength, LPCWSTR lpszHeaders)
{
  int v5; // eax@2
  DWORD v6; // eax@2
  int v7; // esi@2
  int v8; // [sp+Ch] [bp-40h]@4
  int (__stdcall **v9)(char); // [sp+10h] [bp-3Ch]@4
  int v10; // [sp+1Ch] [bp-30h]@6
  int v11; // [sp+20h] [bp-2Ch]@6
  void *v12; // [sp+24h] [bp-28h]@2
  int v13; // [sp+34h] [bp-18h]@6
  unsigned int v14; // [sp+38h] [bp-14h]@4
  int v15; // [sp+48h] [bp-4h]@2

  if ( !WinHttpSendRequest(
          *(HINTERNET *)(dwContext + 4),
          lpszHeaders,
          0xFFFFFFFFu,
          lpOptional,
          dwOptionalLength,
          dwTotalLength,
          dwContext) )
  {
    v6 = GetLastError();
    v7 = v6;
    v5 = sub_100285D0((int)&v12, v6);
    v15 = 0;
    if ( *(_DWORD *)(v5 + 20) >= 0x10u )
      v5 = *(_DWORD *)v5;
    v8 = v5;
    sub_1002AEA4((int)&v9, &v8);
    v15 = -1;
    v9 = &off_10060320;
    if ( v14 >= 0x10 )
      sub_1002A4AA(v12);
    v14 = 15;
    v13 = 0;
    LOBYTE(v12) = 0;
    v9 = &off_100683AC;
    v10 = 5;
    v11 = v7;
    sub_100355DB((int)&v9, (int)&unk_1006DA88);
  }
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10060320: using guessed type int (__stdcall *off_10060320)(char);
// 100683AC: using guessed type int (__stdcall *off_100683AC)(char);

//----- (10028FA0) --------------------------------------------------------
void __userpurge fnInternetCallback(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, unsigned int a6, int a7, int a8)
{
  int ebp0; // ebp@0
  void *v9; // esi@9
  char *v10; // ecx@10
  DWORD v11; // eax@10
  int v12; // eax@10
  void *v13; // ST00_4@11
  DWORD v14; // eax@12
  int v15; // eax@12
  DWORD v16; // eax@14
  int v17; // eax@14
  DWORD v18; // eax@18
  int v19; // eax@18
  DWORD v20; // eax@22
  int v21; // eax@22
  int v22; // eax@23
  char v23; // [sp+10h] [bp-94h]@1
  char v24; // [sp+14h] [bp-90h]@14
  char v25; // [sp+28h] [bp-7Ch]@10
  char v26; // [sp+3Ch] [bp-68h]@23
  char v27; // [sp+50h] [bp-54h]@18
  char v28; // [sp+64h] [bp-40h]@12
  char v29; // [sp+78h] [bp-2Ch]@22
  LPVOID dwBufferLength; // [sp+8Ch] [bp-18h]@9
  unsigned int v31; // [sp+90h] [bp-14h]@1
  int v32; // [sp+A0h] [bp-4h]@10

  v31 = (unsigned int)&v23 ^ __security_cookie;
  if ( a5 )
  {
    if ( a6 > 0x80000 )
    {
      if ( a6 == 2097152 )
      {
        v22 = sub_10028530(&v26, *(_DWORD *)a7, *(_DWORD *)(a7 + 4));
        v32 = 5;
        sub_10029260(a5, v22);
        v10 = &v26;
        goto LABEL_24;
      }
      if ( a6 == 4194304 && !WinHttpReceiveResponse(*(HINTERNET *)(a5 + 4), 0) )
      {
        v20 = GetLastError();
        v21 = sub_10028530(&v29, 1, v20);
        v32 = 0;
        sub_10029260(a5, v21);
        v10 = &v29;
        goto LABEL_24;
      }
    }
    else
    {
      if ( a6 == 524288 )
      {
        if ( !a8 )
        {
LABEL_8:
          (*(void (__thiscall **)(int, int))(*(_DWORD *)a5 + 20))(a5, a5 + 56);
          *(_DWORD *)(a5 + 12) = 2;
          return;
        }
        loc_10014700(a5 + 56, a7, a8);
        sub_10030383((LPVOID)a7);
        if ( !WinHttpQueryDataAvailable(*(HINTERNET *)(a5 + 4), 0) )
        {
          v18 = GetLastError();
          v19 = sub_10028530(&v27, 2, v18);
          v32 = 4;
          sub_10029260(a5, v19);
          v10 = &v27;
          goto LABEL_24;
        }
      }
      else
      {
        if ( a6 == 2048 )
        {
          sub_1002C5B4(ebp0);
          return;
        }
        if ( a6 == 131072 )
        {
          v13 = *(void **)(a5 + 4);
          dwBufferLength = (LPVOID)4;
          if ( !WinHttpQueryHeaders(v13, 0x20000013u, 0, (LPVOID)(a5 + 80), (LPDWORD)&dwBufferLength, 0) )
          {
            v14 = GetLastError();
            v15 = sub_10028530(&v28, 6, v14);
            v32 = 1;
            sub_10029260(a5, v15);
            v32 = -1;
            sub_1002AF18((int)&v28, a3);
          }
          if ( !WinHttpQueryDataAvailable(*(HINTERNET *)(a5 + 4), 0) )
          {
            v16 = GetLastError();
            v17 = sub_10028530(&v24, 2, v16);
            v32 = 2;
            sub_10029260(a5, v17);
            v10 = &v24;
            goto LABEL_24;
          }
        }
        else
        {
          if ( a6 != 262144 )
            return;
          a3 = *(_DWORD *)a7;
          if ( !*(_DWORD *)a7 )
            goto LABEL_8;
          dwBufferLength = (LPVOID)sub_1002965B(a1, a2, a3, a5, a3 + 1);
          sub_10039210(dwBufferLength, 0, a3 + 1);
          v9 = dwBufferLength;
          if ( !WinHttpReadData(*(HINTERNET *)(a5 + 4), dwBufferLength, a3, 0) )
          {
            sub_10030383(v9);
            v11 = GetLastError();
            v12 = sub_10028530(&v25, 3, v11);
            v32 = 3;
            sub_10029260(a5, v12);
            v10 = &v25;
LABEL_24:
            sub_1002AF18((int)v10, a3);
            return;
          }
        }
      }
    }
  }
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 10074200: using guessed type int __security_cookie;

//----- (10029260) --------------------------------------------------------
int __thiscall sub_10029260(int this, int a2)
{
  int v3; // ebx@1
  char v4; // [sp-18h] [bp-48h]@1
  int v5; // [sp-Ch] [bp-3Ch]@1
  int v6; // [sp-8h] [bp-38h]@1
  unsigned int v7; // [sp-4h] [bp-34h]@1
  int v8; // [sp+14h] [bp-1Ch]@1
  int v9; // [sp+18h] [bp-18h]@1
  unsigned int v10; // [sp+1Ch] [bp-14h]@1
  int v11; // [sp+2Ch] [bp-4h]@1
  int v12; // [sp+30h] [bp+0h]@1

  v10 = (unsigned int)&v12 ^ __security_cookie;
  v7 = (unsigned int)&v12 ^ __security_cookie;
  v3 = this;
  v8 = 0;
  v9 = 0;
  sub_1002AEE4((int)&v4, this, a2);
  *(_DWORD *)&v4 = &off_100683AC;
  v5 = *(_DWORD *)(a2 + 12);
  v6 = *(_DWORD *)(a2 + 16);
  sub_10029320(&v8, v3, (unsigned int)&off_100683AC);
  v11 = 0;
  sub_1002FD39((int)&v5, (int)&v8);
  (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 24))(v3);
  v11 = -1;
  return sub_1002FDDA((int)&v8);
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);
// 100683AC: using guessed type int (__stdcall *off_100683AC)(char);
// 10074200: using guessed type int __security_cookie;

//----- (10029320) --------------------------------------------------------
void *__usercall sub_10029320<eax>(void *a1<ecx>, int a2<ebx>, char a3)
{
  void *v4; // esi@1

  v4 = a1;
  sub_100098C0(a1, (int)&unk_1006DA88);
  sub_1002AF18((int)&a3, a2);
  return v4;
}

//----- (10029380) --------------------------------------------------------
int __userpurge sub_10029380<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_100602D4;
  return v4;
}
// 100602D4: using guessed type int (__stdcall *off_100602D4)(char);

//----- (1002939B) --------------------------------------------------------
int __userpurge sub_1002939B<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_1006032C;
  return v4;
}
// 1006032C: using guessed type int (__stdcall *off_1006032C)(char);

//----- (100293B6) --------------------------------------------------------
int __userpurge sub_100293B6<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10060308;
  return v4;
}
// 10060308: using guessed type int (__stdcall *off_10060308)(char);

//----- (100293D1) --------------------------------------------------------
int __userpurge sub_100293D1<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10060314;
  return v4;
}
// 10060314: using guessed type int (__stdcall *off_10060314)(char);

//----- (100293EC) --------------------------------------------------------
int __userpurge sub_100293EC<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // edi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_100603BC;
  *(_DWORD *)(v4 + 12) = *(_DWORD *)(a3 + 12);
  return v4;
}
// 100603BC: using guessed type int (__stdcall *off_100603BC)(char);

//----- (10029410) --------------------------------------------------------
int __thiscall sub_10029410(void *this, int a2)
{
  int v3; // esi@1
  int v4; // edi@1

  v3 = a2;
  v4 = (int)this;
  a2 = sub_10029470(a2);
  sub_1002AEA4(v4, &a2);
  *(_DWORD *)(v4 + 12) = v3;
  *(_DWORD *)v4 = &off_100603BC;
  return v4;
}
// 100603BC: using guessed type int (__stdcall *off_100603BC)(char);

//----- (10029440) --------------------------------------------------------
void __usercall sub_10029440(int a1<ecx>, int a2<ebx>)
{
  *(_DWORD *)a1 = &off_100602D4;
  sub_1002AF18(a1, a2);
}
// 100602D4: using guessed type int (__stdcall *off_100602D4)(char);

//----- (1002944B) --------------------------------------------------------
void *__userpurge sub_1002944B<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  *(_DWORD *)a1 = &off_100602D4;
  sub_1002AF18(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100602D4: using guessed type int (__stdcall *off_100602D4)(char);

//----- (10029470) --------------------------------------------------------
int __cdecl sub_10029470(int a1)
{
  int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = (int)"regex_error(error_collate): The expression contained an invalid collating element name.";
      break;
    case 1:
      result = (int)"regex_error(error_ctype): The expression contained an invalid character class name.";
      break;
    case 2:
      result = (int)"regex_error(error_escape): The expression contained an invalid escaped character, or a trailing escape.";
      break;
    case 3:
      result = (int)"regex_error(error_backref): The expression contained an invalid back reference.";
      break;
    case 4:
      result = (int)"regex_error(error_brack): The expression contained mismatched [ and ].";
      break;
    case 5:
      result = (int)"regex_error(error_paren): The expression contained mismatched ( and ).";
      break;
    case 6:
      result = (int)"regex_error(error_brace): The expression contained mismatched { and }.";
      break;
    case 7:
      result = (int)"regex_error(error_badbrace): The expression contained an invalid range in a { expression }.";
      break;
    case 8:
      result = (int)"regex_error(error_range): The expression contained an invalid character range, such as [b-a] in most encodings.";
      break;
    case 9:
      result = (int)"regex_error(error_space): There was insufficient memory to convert the expression into a finite state machine.";
      break;
    case 10:
      result = (int)"regex_error(error_badrepeat): One of *?+{ was not preceded by a valid regular expression.";
      break;
    case 11:
      result = (int)"regex_error(error_complexity): The complexity of an attempted match against a regular expression exceeded a pre-set level.";
      break;
    case 12:
      result = (int)"regex_error(error_stack): There was insufficient memory to determine whether the regular expression could match the specified character sequence.";
      break;
    case 13:
      result = (int)"regex_error(error_parse)";
      break;
    case 14:
      result = (int)"regex_error(error_syntax)";
      break;
    default:
      result = (int)"regex_error";
      break;
  }
  return result;
}

//----- (10029530) --------------------------------------------------------
void __cdecl sub_10029530()
{
  int (__stdcall **v0)(char); // [sp+0h] [bp-10h]@1
  int v1; // [sp+Ch] [bp-4h]@1

  v1 = (int)"bad allocation";
  sub_1002AEC9((int)&v0, (int)&v1, 1);
  v0 = &off_100602D4;
  sub_100355DB((int)&v0, (int)&unk_1006BAB0);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_10029561);
}
// 100602D4: using guessed type int (__stdcall *off_100602D4)(char);

//----- (10029561) --------------------------------------------------------
void __cdecl sub_10029561()
{
  int (__stdcall **v0)(char); // [sp+0h] [bp-Ch]@1

  sub_1002AF07((int)&v0);
  v0 = &off_1006032C;
  sub_100355DB((int)&v0, (int)&unk_1006BB60);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_10029585);
}
// 1006032C: using guessed type int (__stdcall *off_1006032C)(char);

//----- (10029585) --------------------------------------------------------
void __cdecl sub_10029585(int a1)
{
  int (__stdcall **v1)(char); // [sp+0h] [bp-Ch]@1

  sub_1002AEA4((int)&v1, &a1);
  v1 = &off_10060308;
  sub_100355DB((int)&v1, (int)&unk_1006BAE8);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_100295B3);
}
// 10060308: using guessed type int (__stdcall *off_10060308)(char);

//----- (100295B3) --------------------------------------------------------
void __cdecl sub_100295B3(int a1)
{
  int (__stdcall **v1)(char); // [sp+0h] [bp-Ch]@1

  sub_1002AEA4((int)&v1, &a1);
  v1 = &off_10060314;
  sub_100355DB((int)&v1, (int)&unk_1006BB24);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_100295E1);
}
// 100295E1: using guessed type int __cdecl sub_100295E1(int);
// 10060314: using guessed type int (__stdcall *off_10060314)(char);

//----- (100295E1) --------------------------------------------------------
int __cdecl sub_100295E1(int a1)
{
  char v2; // [sp+0h] [bp-10h]@1

  sub_10029410(&v2, a1);
  sub_100355DB((int)&v2, (int)&unk_1006BB98);
  __asm { int     3               ; Trap to Debugger }
  return (int)"bad function call";
}
// 100295E1: using guessed type int __cdecl sub_100295E1(int);

//----- (10029607) --------------------------------------------------------
int __cdecl sub_10029607(int a1)
{
  _UNKNOWN *v1; // eax@1
  int result; // eax@4

  v1 = &unk_10060B58;
  if ( off_10060B5C )
  {
    while ( *(_DWORD *)v1 != a1 )
    {
      v1 = (char *)v1 + 8;
      if ( !*((_DWORD *)v1 + 1) )
        goto LABEL_4;
    }
    result = *((_DWORD *)v1 + 1);
  }
  else
  {
LABEL_4:
    result = 0;
  }
  return result;
}
// 10060B5C: using guessed type char *off_10060B5C;

//----- (10029631) --------------------------------------------------------
int __cdecl sub_10029631(int a1)
{
  _UNKNOWN *v1; // eax@1
  int result; // eax@4

  v1 = &unk_10060900;
  if ( off_10060904 )
  {
    while ( *(_DWORD *)v1 != a1 )
    {
      v1 = (char *)v1 + 8;
      if ( !*((_DWORD *)v1 + 1) )
        goto LABEL_4;
    }
    result = *((_DWORD *)v1 + 1);
  }
  else
  {
LABEL_4:
    result = 0;
  }
  return result;
}
// 10060904: using guessed type char *off_10060904;

//----- (1002965B) --------------------------------------------------------
int __usercall sub_1002965B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int dwBytes)
{
  return sub_1002ADB1(a1, a2, a3, a4, dwBytes);
}

//----- (10029664) --------------------------------------------------------
int __cdecl sub_10029664(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)a1 = sub_1002967E;
  *(_DWORD *)(a1 + 12) = a3;
  return result;
}

//----- (1002967E) --------------------------------------------------------
int __cdecl sub_1002967E(int a1, int a2, int a3)
{
  int result; // eax@1

  *(_DWORD *)(a1 + 32) = a2;
  result = a3;
  *(_DWORD *)(a1 + 36) = a3;
  return result;
}

//----- (10029692) --------------------------------------------------------
int __thiscall sub_10029692(int this, int a2)
{
  int v2; // edi@1
  int i; // esi@1
  int result; // eax@2

  v2 = this;
  for ( i = *(_DWORD *)(this + 44); i; i = *(_DWORD *)i )
    result = (*(int (__cdecl **)(int, int, _DWORD))(i + 8))(a2, v2, *(_DWORD *)(i + 4));
  return result;
}

//----- (100296B7) --------------------------------------------------------
char __cdecl sub_100296B7(int a1)
{
  int v1; // eax@1
  char result; // al@2
  void *v3; // esi@3

  v1 = *(_DWORD *)(a1 + 8);
  if ( !v1 || (--byte_100761D0[v1], result = byte_100761D0[v1], result <= 0) )
  {
    result = (unsigned int)sub_100296F4(a1);
    v3 = *(void **)(a1 + 48);
    if ( v3 )
    {
      sub_10017D50(v3);
      result = sub_1002A4AA(v3);
    }
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100296F4) --------------------------------------------------------
void *__thiscall sub_100296F4(int this)
{
  void *v1; // eax@1
  int v2; // edi@1
  void *v3; // esi@2
  void *result; // eax@3
  void *v5; // esi@4

  v2 = this;
  sub_10029692(this, 0);
  v1 = *(void **)(v2 + 40);
  if ( v1 )
  {
    do
    {
      v3 = *(void **)v1;
      sub_1002A4AA(v1);
      v1 = v3;
    }
    while ( v3 );
  }
  result = *(void **)(v2 + 44);
  *(_DWORD *)(v2 + 40) = 0;
  if ( result )
  {
    do
    {
      v5 = *(void **)result;
      sub_1002A4AA(result);
      result = v5;
    }
    while ( v5 );
  }
  *(_DWORD *)(v2 + 44) = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002973B) --------------------------------------------------------
void *__thiscall sub_1002973B(void *this, char a2)
{
  void *v3; // esi@1
  int v4; // ecx@1

  v3 = this;
  v4 = (int)((char *)this + 24);
  *((_DWORD *)v3 + 1) = 1;
  *(_DWORD *)v3 = &off_10061674;
  *((_DWORD *)v3 + 2) = 0;
  *((_DWORD *)v3 + 3) = 0;
  *((_DWORD *)v3 + 4) = 0;
  *((_BYTE *)v3 + 20) = a2;
  *(_DWORD *)v4 = 0;
  *(_BYTE *)(v4 + 4) = 0;
  sub_100297DC(v4, 0, (int)&unk_10061680);
  return v3;
}
// 10061674: using guessed type int (__stdcall *off_10061674)(char);

//----- (10029778) --------------------------------------------------------
int __thiscall sub_10029778(int this)
{
  int result; // eax@1

  result = (*(int (**)(void))(**(_DWORD **)(this + 4) + 8))();
  if ( result )
    result = (**(int (__thiscall ***)(_DWORD, _DWORD))result)(result, 1);
  return result;
}

//----- (100297B1) --------------------------------------------------------
void __usercall sub_100297B1(int a1<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>)
{
  int v4; // esi@1

  v4 = a1;
  *(_DWORD *)a1 = &off_10061674;
  sub_100298F9(a2, a3, a4);
  if ( *(_DWORD *)(v4 + 24) )
    sub_100309A2(a2, *(LPVOID *)(v4 + 24));
  *(_DWORD *)(v4 + 24) = 0;
  *(_DWORD *)v4 = &off_10061664;
}
// 10061664: using guessed type int (__stdcall *off_10061664)(char);
// 10061674: using guessed type int (__stdcall *off_10061674)(char);

//----- (100297DC) --------------------------------------------------------
int __fastcall sub_100297DC(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // ST0C_4@3
  int i; // esi@5
  int v6; // eax@7
  int v7; // esi@7

  v3 = a1;
  if ( *(_DWORD *)a1 != a3 )
  {
    if ( *(_DWORD *)a1 )
    {
      sub_100309A2(a1, *(LPVOID *)a1);
      a1 = v4;
    }
    *(_DWORD *)v3 = 0;
    if ( a3 )
    {
      for ( i = a3; *(_BYTE *)i; ++i )
        ;
      v7 = i - a3 + 1;
      v6 = sub_10030910(a2, a1, v3, a3, v7);
      *(_DWORD *)v3 = v6;
      if ( v6 )
        sub_10034F00((void *)v6, (const void *)a3, v7);
    }
  }
  return v3;
}

//----- (10029830) --------------------------------------------------------
void *__userpurge sub_10029830<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  int ebp0; // ebp@0
  void *v5; // esi@1

  v5 = (void *)a1;
  sub_100297B1(a1, a2, ebp0, a3);
  if ( a4 & 1 )
    sub_1002A4AA(v5);
  return v5;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002984F) --------------------------------------------------------
int __usercall sub_1002984F<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int result; // eax@1

  result = sub_1002ADB1(a1, a2, a3, a4, 8);
  if ( result )
  {
    *(_DWORD *)result = dword_100761F0;
    *(_DWORD *)(result + 4) = a5;
  }
  else
  {
    result = 0;
  }
  dword_100761F0 = result;
  return result;
}
// 100761F0: using guessed type int dword_100761F0;

//----- (10029877) --------------------------------------------------------
int __cdecl sub_10029877()
{
  return dword_100761EC;
}
// 100761EC: using guessed type int dword_100761EC;

//----- (1002987D) --------------------------------------------------------
int __usercall sub_1002987D<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // esi@1
  int v6; // edx@2

  sub_10035668();
  sub_10029A76(v3, a2 - 16, a1, a3, 0);
  v5 = dword_100761EC;
  *(_DWORD *)(a2 - 4) = 0;
  if ( !v5 )
  {
    v5 = (int)sub_100299B7(v3, v4, a1, a3, 0);
    sub_100299D6(v5);
    *(_DWORD *)(v5 + 16) = 63;
    sub_100297DC(v5 + 24, v6, (int)&unk_10061684);
    dword_100761E8 = v5;
    (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
    dword_10076208 = dword_100761E8;
  }
  if ( *(_BYTE *)(a2 + 8) )
    (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
  sub_10029AD2((void *)(a2 - 16));
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 100761E8: using guessed type int dword_100761E8;
// 100761EC: using guessed type int dword_100761EC;
// 10076208: using guessed type int dword_10076208;

//----- (100298F9) --------------------------------------------------------
int __usercall sub_100298F9<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // edi@1
  int v4; // esi@1
  int v5; // edx@1
  int v6; // ecx@2
  int v7; // eax@3
  signed int v9; // [sp-8h] [bp-8h]@1
  signed int v10; // [sp-4h] [bp-4h]@1

  v10 = 4;
  sub_10035668();
  sub_10029A76(v5, a2 - 16, a1, a3, 0);
  v3 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 - 4) = 0;
  v4 = *(_DWORD *)(v3 + 12);
  while ( v4 )
  {
    --v4;
    v6 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + 4 * v4);
    if ( v6 )
    {
      v7 = (*(int (__cdecl **)(signed int))(*(_DWORD *)v6 + 8))(v10);
      if ( v7 )
      {
        v9 = 1;
        (**(void (__thiscall ***)(_DWORD))v7)(v7);
      }
    }
  }
  sub_100309A2(a1, *(LPVOID *)(v3 + 8));
  sub_10029AD2((void *)(a2 - 16));
  return sub_10035636(v9);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (10029952) --------------------------------------------------------
int __cdecl sub_10029952(int a1, const CHAR *a2)
{
  int v2; // eax@1
  int v3; // edx@1
  int v4; // edx@3
  int v5; // eax@4

  sub_1003686B(0, 0);
  if ( !v2 )
    v2 = (int)&unk_1006823C;
  sub_100297DC(a1 + 36, v3, v2);
  if ( !a2 || (sub_1003686B(0, a2), !v5) )
    v5 = (int)&unk_10061680;
  return sub_100297DC(a1 + 44, v4, v5);
}

//----- (1002999D) --------------------------------------------------------
void __cdecl sub_1002999D(int a1)
{
  if ( *(_DWORD *)(a1 + 36) )
    sub_1003686B(0, *(LPCSTR *)(a1 + 36));
}

//----- (100299B7) --------------------------------------------------------
void *__usercall sub_100299B7<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, char a5)
{
  int v5; // eax@1
  void *result; // eax@2

  v5 = sub_1002ADB1(a1, a2, a3, a4, 32);
  if ( v5 )
    result = sub_1002973B((void *)v5, a5);
  else
    result = 0;
  return result;
}

//----- (100299D6) --------------------------------------------------------
int __cdecl sub_100299D6(int a1)
{
  int result; // eax@3

  if ( !byte_10076210 )
  {
    byte_10076210 = 1;
    sub_1002A3B2(sub_10029A1D);
  }
  result = a1;
  dword_100761EC = a1;
  return result;
}
// 100761EC: using guessed type int dword_100761EC;
// 10076210: using guessed type char byte_10076210;

//----- (100299FE) --------------------------------------------------------
int __cdecl sub_100299FE(int a1)
{
  int result; // eax@1

  result = a1;
  if ( *(_DWORD *)a1 )
  {
    result = (*(int (**)(void))(**(_DWORD **)a1 + 8))();
    if ( result )
      result = (**(int (__thiscall ***)(_DWORD, _DWORD))result)(result, 1);
  }
  return result;
}

//----- (10029A1D) --------------------------------------------------------
void __usercall sub_10029A1D(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // [sp+0h] [bp-4h]@1

  v4 = a2;
  sub_10029A76(a1, (int)&v4, a3, a4, 0);
  sub_100299FE((int)&dword_100761EC);
  dword_100761EC = 0;
  sub_10029AD2(&v4);
}
// 100761EC: using guessed type int dword_100761EC;

//----- (10029A47) --------------------------------------------------------
void *__thiscall sub_10029A47(void *this)
{
  void *v1; // edi@1
  struct _RTL_CRITICAL_SECTION *v2; // esi@2

  v1 = this;
  if ( !InterlockedIncrement(&Addend) )
  {
    v2 = &CriticalSection;
    do
    {
      sub_1002A3EE(v2);
      ++v2;
    }
    while ( (signed int)v2 < (signed int)&unk_10076280 );
  }
  return v1;
}

//----- (10029A76) --------------------------------------------------------
int __userpurge sub_10029A76<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5)
{
  int v5; // esi@1

  v5 = a2;
  *(_DWORD *)a2 = a5;
  if ( a5 )
  {
    if ( a5 < 4 )
      sub_1002A405(&CriticalSection + a5);
  }
  else
  {
    sub_10036A43(a1, a2, a3, a4, 12);
  }
  return v5;
}

//----- (10029AD2) --------------------------------------------------------
void __thiscall sub_10029AD2(void *this)
{
  signed int v1; // eax@1

  v1 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    if ( v1 < 4 )
      sub_1002A413(&CriticalSection + v1);
  }
  else
  {
    sub_10036BA7(12);
  }
}

//----- (10029AF6) --------------------------------------------------------
int __usercall sub_10029AF6<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  LPVOID v3; // eax@1
  int v4; // ecx@1
  int v5; // eax@2
  int v6; // eax@3
  int v7; // eax@4

  *(_DWORD *)a3 = sub_10036EA7(a1, a2);
  v3 = sub_10037506(v4, a1, 0x100u, 2u);
  *(_DWORD *)(a3 + 4) = v3;
  if ( v3 )
  {
    v5 = sub_10036BBC(a1, a2);
    sub_10034F00(*(void **)(a3 + 4), (const void *)v5, 0x200u);
    *(_DWORD *)(a3 + 8) = 1;
  }
  else
  {
    v6 = sub_10036BBC(a1, a2);
    *(_DWORD *)(a3 + 8) = 0;
    *(_DWORD *)(a3 + 4) = v6;
  }
  v7 = *(_DWORD *)(sub_10036EF3(a1, a2) + 4);
  *(_DWORD *)(a3 + 12) = v7;
  if ( v7 )
    *(_DWORD *)(a3 + 12) = sub_10036E54(a1, v7);
  return a3;
}

//----- (10029B62) --------------------------------------------------------
int __usercall sub_10029B62<eax>(int a1<ebx>, int a2<edi>, int a3, int MultiByteStr)
{
  int v4; // esi@1
  int v5; // eax@2
  int v6; // edi@2
  int result; // eax@5
  unsigned int v8; // eax@13
  int v9; // edx@13
  int v10; // eax@13
  int v11; // eax@16
  unsigned int v12; // eax@18
  char v13; // zf@20
  UINT v14; // [sp+Ch] [bp-8h]@4
  WCHAR DestStr; // [sp+10h] [bp-4h]@18

  v4 = MultiByteStr;
  if ( MultiByteStr )
  {
    v6 = *(_DWORD *)(MultiByteStr + 12);
    v5 = *(_DWORD *)MultiByteStr;
  }
  else
  {
    v6 = *(_DWORD *)(sub_10036EF3(a1, a2) + 8);
    v5 = sub_10036EA7(a1, v6);
  }
  v14 = v5;
  if ( !v6 )
  {
    result = a3;
    if ( (unsigned int)(a3 - 65) <= 0x19 )
      result = a3 + 32;
    return result;
  }
  if ( (unsigned int)a3 < 0x100 )
  {
    if ( !v4 )
    {
      if ( !sub_10036DFC(a3, v6, a3) )
        return a3;
      goto LABEL_13;
    }
    if ( !(*(_BYTE *)(*(_DWORD *)(v4 + 4) + 2 * a3) & 1) )
      return a3;
  }
  if ( !v4 )
  {
LABEL_13:
    v10 = sub_10036BBC(a3, v6);
    v9 = a3 >> 8;
    v8 = *(_WORD *)(v10 + 2 * BYTE1(a3)) & 0x8000;
    goto LABEL_15;
  }
  v9 = a3 >> 8;
  v8 = ((unsigned int)*(_WORD *)(*(_DWORD *)(v4 + 4) + 2 * BYTE1(a3)) >> 15) & 1;
LABEL_15:
  if ( v8 )
  {
    LOBYTE(MultiByteStr) = v9;
    *(_WORD *)((char *)&MultiByteStr + 1) = (unsigned __int8)a3;
    v11 = 2;
  }
  else
  {
    LOWORD(MultiByteStr) = (unsigned __int8)a3;
    v11 = 1;
  }
  v12 = sub_100374C2(a3, v6, 0, v6, 0x100u, (LPCSTR)&MultiByteStr, v11, &DestStr, 3, v14, 1);
  if ( !v12 )
    return a3;
  v13 = v12 == 1;
  result = (unsigned __int8)DestStr;
  if ( !v13 )
    result = HIBYTE(DestStr) | ((unsigned __int8)DestStr << 8);
  return result;
}

//----- (10029C5F) --------------------------------------------------------
int __usercall sub_10029C5F<eax>(int a1<ebx>, int a2<edi>, int a3, int MultiByteStr)
{
  int v4; // esi@1
  int v5; // eax@2
  int v6; // edi@2
  int result; // eax@5
  unsigned int v8; // eax@13
  int v9; // edx@13
  int v10; // eax@13
  int v11; // eax@16
  unsigned int v12; // eax@18
  char v13; // zf@20
  UINT v14; // [sp+Ch] [bp-8h]@4
  WCHAR DestStr; // [sp+10h] [bp-4h]@18

  v4 = MultiByteStr;
  if ( MultiByteStr )
  {
    v6 = *(_DWORD *)(MultiByteStr + 12);
    v5 = *(_DWORD *)MultiByteStr;
  }
  else
  {
    v6 = *(_DWORD *)(sub_10036EF3(a1, a2) + 8);
    v5 = sub_10036EA7(a1, v6);
  }
  v14 = v5;
  if ( !v6 )
  {
    result = a3;
    if ( (unsigned int)(a3 - 97) <= 0x19 )
      result = a3 - 32;
    return result;
  }
  if ( (unsigned int)a3 < 0x100 )
  {
    if ( !v4 )
    {
      if ( !sub_10036DA6(a3, v6, a3) )
        return a3;
      goto LABEL_13;
    }
    if ( !(*(_BYTE *)(*(_DWORD *)(v4 + 4) + 2 * a3) & 2) )
      return a3;
  }
  if ( !v4 )
  {
LABEL_13:
    v10 = sub_10036BBC(a3, v6);
    v9 = a3 >> 8;
    v8 = *(_WORD *)(v10 + 2 * BYTE1(a3)) & 0x8000;
    goto LABEL_15;
  }
  v9 = a3 >> 8;
  v8 = ((unsigned int)*(_WORD *)(*(_DWORD *)(v4 + 4) + 2 * BYTE1(a3)) >> 15) & 1;
LABEL_15:
  if ( v8 )
  {
    LOBYTE(MultiByteStr) = v9;
    *(_WORD *)((char *)&MultiByteStr + 1) = (unsigned __int8)a3;
    v11 = 2;
  }
  else
  {
    LOWORD(MultiByteStr) = (unsigned __int8)a3;
    v11 = 1;
  }
  v12 = sub_100374C2(a3, v6, 0, v6, 0x200u, (LPCSTR)&MultiByteStr, v11, &DestStr, 3, v14, 1);
  if ( !v12 )
    return a3;
  v13 = v12 == 1;
  result = (unsigned __int8)DestStr;
  if ( !v13 )
    result = HIBYTE(DestStr) | ((unsigned __int8)DestStr << 8);
  return result;
}

//----- (10029D5C) --------------------------------------------------------
int __cdecl sub_10029D5C(int a1)
{
  signed int v1; // ebx@1
  bool v2; // ecx@1

  v1 = 0;
  *(_DWORD *)a1 = 0;
  memset((void *)(a1 + 4), 0, 0x28u);
  *(_DWORD *)a1 = sub_10036EA7(0, a1 + 44);
  *(_DWORD *)(a1 + 4) = sub_10036F1B(0, a1);
  v2 = *(_DWORD *)(sub_10036EF3(0, a1) + 8) == 0;
  *(_DWORD *)(a1 + 8) = v2;
  if ( !v2 )
  {
    do
    {
      if ( sub_10037713(v1, a1, v1) )
        *(_BYTE *)((v1 >> 3) + a1 + 12) |= 1 << (v1 & 7);
      ++v1;
    }
    while ( v1 < 256 );
  }
  return a1;
}

//----- (10029DC5) --------------------------------------------------------
int __usercall sub_10029DC5<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // esi@1

  v3 = sub_10036ECD(a1, a2);
  v2 = sub_10036EF3(a1, a2);
  if ( *(_DWORD *)(v2 + 4) )
    sub_10036E54(a1, *(_DWORD *)(v2 + 4));
  return v3;
}

//----- (10029DE6) --------------------------------------------------------
int __usercall sub_10029DE6<eax>(int a1<ebx>, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // edi@1
  int v7; // esi@1
  int v8; // eax@2
  int v9; // ebx@2
  unsigned int v10; // eax@5
  int result; // eax@7
  int v12; // eax@10

  v7 = a3 - a2;
  v6 = a5 - a4;
  if ( a6 )
  {
    v9 = *(_DWORD *)(a6 + 4);
    v8 = *(_DWORD *)a6;
  }
  else
  {
    v9 = *(_DWORD *)(sub_10036EF3(a1, v6) + 4);
    v8 = sub_10036ECD(v9, v6);
  }
  if ( v9 )
  {
    v12 = sub_1003912C(v9, v6, 0, v9, 0x1000u, a2, v7, a4, v6, v8);
    if ( v12 )
    {
      result = v12 - 2;
    }
    else
    {
      *(_DWORD *)sub_10037669(v9) = 22;
      result = 2147483647;
    }
  }
  else
  {
    v10 = a3 - a2;
    if ( v7 >= v6 )
      v10 = a5 - a4;
    result = sub_10037729(a2, a4, v10);
    if ( !result )
    {
      if ( v7 != v6 )
      {
        LOBYTE(result) = v7 >= v6;
        result = 2 * result - 1;
      }
    }
  }
  return result;
}

//----- (10029E7B) --------------------------------------------------------
signed int __cdecl sub_10029E7B(LPWSTR lpDestStr, int a2, LPCSTR lpMultiByteStr, UINT CodePage, int a5)
{
  signed int v5; // ebx@1
  int v6; // edi@1
  unsigned int v7; // esi@1
  int v8; // eax@2
  int v9; // ecx@2
  int v10; // eax@9
  int v12; // [sp+18h] [bp+Ch]@2
  UINT v13; // [sp+20h] [bp+14h]@4

  v7 = CodePage - (_DWORD)lpMultiByteStr;
  v6 = a2 - (_DWORD)lpDestStr;
  v5 = -1;
  if ( a5 )
  {
    v9 = *(_DWORD *)(a5 + 4);
    v8 = *(_DWORD *)a5;
    v12 = *(_DWORD *)(a5 + 4);
  }
  else
  {
    v12 = *(_DWORD *)(sub_10036EF3(-1, v6) + 4);
    v8 = sub_10036ECD(-1, v6);
    v9 = v12;
  }
  v13 = v8;
  if ( v9 || v8 )
  {
    v10 = sub_100374C2(-1, v6, 0, v9, 0x400u, lpMultiByteStr, v7, 0, 0, v8, 1);
    if ( v10 )
    {
      v5 = v10;
      if ( v10 <= v6 )
        sub_100374C2(v10, v6, 0, v12, 0x400u, lpMultiByteStr, v7, lpDestStr, v6, v13, 1);
    }
  }
  else
  {
    if ( v7 <= v6 )
      sub_10034F00(lpDestStr, lpMultiByteStr, v7);
    v5 = v7;
  }
  return v5;
}

//----- (10029F21) --------------------------------------------------------
DWORD __cdecl sub_10029F21()
{
  struct _FILETIME SystemTimeAsFileTime; // [sp+0h] [bp-8h]@1

  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  return SystemTimeAsFileTime.dwLowDateTime + 717324288;
}

//----- (10029F48) --------------------------------------------------------
int __fastcall sub_10029F48(int a1, int a2, unsigned int a3)
{
  int v3; // edi@1
  int v4; // eax@3
  int v6; // eax@10
  signed int v7; // [sp-4h] [bp-10h]@2

  v3 = a1;
  *(_DWORD *)a1 = off_1006168C;
  if ( a3 <= 8 )
  {
    v7 = 32;
LABEL_8:
    v4 = v7;
    goto LABEL_10;
  }
  v4 = 16;
  if ( a3 > 0x10 )
  {
    if ( a3 > 0x20 )
    {
      if ( a3 > 0x40 )
      {
        v4 = 2 - (a3 > 0x80);
        goto LABEL_10;
      }
      v7 = 4;
    }
    else
    {
      v7 = 8;
    }
    goto LABEL_8;
  }
LABEL_10:
  *(_DWORD *)(a1 + 8) = v4;
  v6 = sub_1002A421(a2, 320, a1, 1u, 320);
  *(_DWORD *)(v3 + 4) = v6;
  sub_10039210((void *)v6, 0, 320);
  *(_DWORD *)(v3 + 12) = a3;
  return v3;
}
// 1006168C: using guessed type int (*off_1006168C[3])();

//----- (10029FB5) --------------------------------------------------------
int __thiscall sub_10029FB5(int this)
{
  return sub_1002A4AA(*(LPVOID *)(this + 32));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10029FBF) --------------------------------------------------------
void __usercall sub_10029FBF(int a1<ecx>, int a2<ebx>)
{
  int v2; // ST00_4@1

  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = off_1006168C;
  sub_1002A486(a2, v2);
}
// 1006168C: using guessed type int (*off_1006168C[3])();

//----- (10029FCF) --------------------------------------------------------
int __thiscall sub_10029FCF(int this)
{
  int v1; // edi@1
  int v2; // esi@1
  int v3; // ecx@2
  int result; // eax@5
  char v5; // [sp+8h] [bp-4h]@2

  v2 = this;
  v1 = *(_DWORD *)(this + 8);
  if ( v1 )
  {
    sub_100348CD(&v5, *(_DWORD *)(this + 4) + 16);
    v3 = *(_DWORD *)v1;
    **(_DWORD **)(v2 + 4) = *(_DWORD *)v1;
    if ( !v3 )
      *(_DWORD *)(*(_DWORD *)(v2 + 4) + 8) = 0;
    sub_10034913(&v5);
  }
  result = *(_DWORD *)(v2 + 4);
  *(_DWORD *)(result + 4) = *(_DWORD *)v2;
  if ( v1 )
    result = (*(int (__stdcall **)(int))(**(_DWORD **)(v2 + 12) + 20))(v1);
  return result;
}

//----- (1002A02D) --------------------------------------------------------
int __thiscall sub_1002A02D(int this, char a2)
{
  void *v2; // esi@1
  int result; // eax@4

  v2 = (void *)this;
  if ( a2 & 2 )
  {
    sub_1002B11F(this, 36, *(_DWORD *)(this - 4), sub_10029FB5);
    if ( a2 & 1 )
      sub_10030383((char *)v2 - 4);
    result = (int)((char *)v2 - 4);
  }
  else
  {
    sub_1002A4AA(*(LPVOID *)(this + 32));
    if ( a2 & 1 )
      sub_1002A4AA(v2);
    result = (int)v2;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (1002A07B) --------------------------------------------------------
void *__userpurge sub_1002A07B<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_10029FBF(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002A09A) --------------------------------------------------------
char __thiscall sub_1002A09A(int this)
{
  int v1; // edx@1
  char result; // al@2

  v1 = *(_DWORD *)(*(_DWORD *)(this + 4) + 64);
  if ( v1 == *(_DWORD *)(*(_DWORD *)(this + 4) + 64) )
    result = v1 == **(_DWORD **)(this + 4);
  else
    result = 0;
  return result;
}

//----- (1002A0BD) --------------------------------------------------------
int __thiscall sub_1002A0BD(void *this)
{
  void *v1; // edi@1
  unsigned int v2; // esi@1
  int result; // eax@2
  int v4; // ecx@2

  v1 = this;
  v2 = 0;
  do
  {
    result = *((_DWORD *)v1 + 1);
    v4 = *(_DWORD *)(result + v2 + 136);
    if ( v4 )
    {
      if ( v4 != dword_10076284 )
        (*(void (__thiscall **)(void *, int))(*(_DWORD *)v1 + 20))(v1, v4);
      result = *((_DWORD *)v1 + 1);
      *(_DWORD *)(result + v2 + 136) = 0;
    }
    v2 += 20;
  }
  while ( v2 < 0xA0 );
  return result;
}
// 10076284: using guessed type int dword_10076284;

//----- (1002A0FD) --------------------------------------------------------
char __thiscall sub_1002A0FD(int this, int a2)
{
  int ebp0; // ebp@0
  int v3; // edi@1
  int v5; // eax@2

  v3 = this;
  _ESI = *(_DWORD *)(this + 4);
  while ( 2 )
  {
    v5 = *(_DWORD *)_ESI;
    do
    {
      if ( v5 == *(_DWORD *)(_ESI + 64) )
        return 0;
      _ECX = v5 + 1;
      __asm { lock cmpxchg [esi], ecx }
    }
    while ( v5 != v5 );
    if ( !(unsigned __int8)sub_1002A17E(ebp0, a2, v5, v3) )
      continue;
    break;
  }
  return 1;
}

//----- (1002A146) --------------------------------------------------------
int __thiscall sub_1002A146(int this, int a2)
{
  _EAX = *(_DWORD *)(this + 4) + 64;
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  return sub_1002A233(a2, _EDX, this, sub_1002A028);
}
// 1002A028: using guessed type int sub_1002A028();
// 1002A233: using guessed type _DWORD __stdcall sub_1002A233(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1002A17E) --------------------------------------------------------
int __userpurge sub_1002A17E<eax>(int a1<ebp>, int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ecx@1
  int v7; // esi@7
  int v8; // eax@7
  int v9; // edx@7
  int v10; // ecx@7
  int v11; // eax@7
  int v12; // ecx@7
  int v14; // [sp-10h] [bp-10h]@9

  sub_10035668();
  v4 = v6;
  v5 = *(_DWORD *)(a1 + 12) & 0xFFFFFFF8;
  *(_DWORD *)(a1 - 40) = 0;
  *(_DWORD *)(a1 - 36) = sub_10034C15;
  while ( *(_DWORD *)(v4 + 4) != v5 )
    sub_100282E0(a1 - 48);
  *(_DWORD *)(a1 - 56) = 0;
  *(_DWORD *)(a1 - 52) = sub_10034C15;
  while ( *(_DWORD *)(v4 + 12) == v5 )
    sub_100282E0(a1 - 64);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)v4;
  v8 = *(_DWORD *)(*(_DWORD *)(a1 + 16) + 8) - 1;
  v9 = v8 & ((unsigned int)v5 >> 3);
  v10 = (v8 & ((unsigned int)v5 >> 3)) == v8 ? *(_DWORD *)(a1 + 12) : 0;
  v11 = v5 + 8;
  v7 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 - 16) = v9;
  *(_DWORD *)(a1 - 32) = v11;
  *(_DWORD *)(a1 - 28) = v4;
  *(_DWORD *)(a1 - 24) = v10;
  *(_DWORD *)(a1 - 20) = v7;
  v12 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 - 4) = 0;
  if ( (1 << v9) & *(_DWORD *)(v12 + 4) )
  {
    v14 = *(_DWORD *)(a1 + 8);
    (*(void (__thiscall **)(int))(*(_DWORD *)v7 + 8))(v7);
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_10029FCF(a1 - 32);
  return sub_10035636(v14);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002A233) --------------------------------------------------------
#error "1002A369: call analysis failed (funcsize=86)"

//----- (1002A371) --------------------------------------------------------
int __thiscall sub_1002A371(int this)
{
  *(_DWORD *)this = &off_100616D8;
  _EAX = 2;
  _EDX = &unk_10076288;
  __asm { lock xadd [edx], eax }
  *(_DWORD *)(this + 4) = _EAX;
  return this;
}
// 100616D8: using guessed type int (*off_100616D8)();

//----- (1002A3B2) --------------------------------------------------------
PVOID __cdecl sub_1002A3B2(PVOID Ptr)
{
  PVOID result; // eax@1

  JUMPOUT(dword_10073258--, 0, loc_100392BF);
  result = EncodePointer(Ptr);
  dword_100762B0[dword_10073258] = (int)result;
  return result;
}
// 10073258: using guessed type int dword_10073258;
// 100762B0: using guessed type int dword_100762B0[];

//----- (1002A3E0) --------------------------------------------------------
void __cdecl sub_1002A3E0(LPCRITICAL_SECTION lpCriticalSection)
{
  DeleteCriticalSection(lpCriticalSection);
}

//----- (1002A3EE) --------------------------------------------------------
int __cdecl sub_1002A3EE(LPCRITICAL_SECTION lpCriticalSection)
{
  return sub_1003958C(lpCriticalSection, 0xFA0u, 0);
}

//----- (1002A405) --------------------------------------------------------
void __cdecl sub_1002A405(LPCRITICAL_SECTION lpCriticalSection)
{
  EnterCriticalSection(lpCriticalSection);
}

//----- (1002A413) --------------------------------------------------------
void __cdecl sub_1002A413(LPCRITICAL_SECTION lpCriticalSection)
{
  LeaveCriticalSection(lpCriticalSection);
}

//----- (1002A421) --------------------------------------------------------
int __usercall sub_1002A421<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, unsigned int a4, int a5)
{
  int v5; // eax@1
  int v6; // esi@2
  int v7; // eax@3
  int v8; // ecx@3
  int result; // eax@4
  int (__stdcall **v10)(char); // [sp+0h] [bp-Ch]@5

  v5 = a5 * a4;
  if ( a5 * a4 < a4
    || (v6 = dword_1007336C, dword_1007336C + v5 < (unsigned int)v5)
    || (v7 = sub_10030910(a1, dword_1007336C + v5, a2, a3, dword_1007336C + v5), v8 = v7, !v7) )
  {
    a4 = (unsigned int)"bad allocation";
    sub_1002AEC9((int)&v10, (int)&a4, 1);
    v10 = &off_100602D4;
    sub_100355DB((int)&v10, (int)&unk_1006BAB0);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1002A486);
  }
  result = -v6 & (v6 + v7);
  *(_DWORD *)(result - 4) = v8;
  return result;
}
// 100602D4: using guessed type int (__stdcall *off_100602D4)(char);
// 1007336C: using guessed type int dword_1007336C;

//----- (1002A486) --------------------------------------------------------
void __usercall sub_1002A486(int a1<ebx>, int a2)
{
  if ( a2 )
    sub_100309A2(a1, *(LPVOID *)(a2 - 4));
}

//----- (1002A49B) --------------------------------------------------------
int __usercall sub_1002A49B<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, int ecx0<ecx>, char a4)
{
  if ( ecx0 == __security_cookie )
    __asm { rep retn }
  return sub_10030692(a1, a2, a3, a4);
}
// 10074200: using guessed type int __security_cookie;

//----- (1002A4B0) --------------------------------------------------------
void *__cdecl sub_1002A4B0(void *a1, const void *a2, unsigned int a3)
{
  int v38; // eax@29
  int v43; // edx@34
  unsigned int v44; // ecx@34
  void *result; // eax@48
  int v46; // edi@52
  int v47; // esi@52
  int v48; // edx@53
  unsigned int v49; // ecx@53
  int v50; // eax@64
  unsigned int k; // edx@65
  unsigned int v52; // edx@65
  int v53; // ecx@65
  unsigned int l; // edx@68
  int v55; // ecx@70
  char v56; // al@71
  unsigned int m; // ecx@71
  int n; // ecx@73
  unsigned int v59; // eax@76
  int i; // ecx@76
  unsigned int j; // eax@78
  int v62; // [sp-8h] [bp-10h]@76

  _ESI = (int)a2;
  _ECX = a3;
  _EDI = (int)a1;
  if ( a1 > a2 && a1 < (char *)a2 + a3 )
  {
    v47 = (int)(a2 + a3 - 4);
    v46 = (int)(a1 + a3 - 4);
    if ( v46 & 3 )
    {
      if ( a3 >= 4 )
        JUMPOUT(__CS__, *((_DWORD *)loc_1002A884 + (v46 & 3) + 1));
      switch ( a3 )
      {
        case 0u:
LABEL_60:
          result = a1;
          break;
        case 1u:
LABEL_61:
          *(_BYTE *)(v46 + 3) = *(_BYTE *)(v47 + 3);
          result = a1;
          break;
        case 2u:
LABEL_62:
          *(_BYTE *)(v46 + 3) = *(_BYTE *)(v47 + 3);
          *(_BYTE *)(v46 + 2) = *(_BYTE *)(v47 + 2);
          result = a1;
          break;
        case 3u:
          goto LABEL_63;
      }
    }
    else
    {
      v49 = a3 >> 2;
      v48 = a3 & 3;
      if ( a3 >> 2 < 8 )
      {
        switch ( -v49 )
        {
          case 0:
            switch ( v48 )
            {
              case 0:
                goto LABEL_60;
              case 1:
                goto LABEL_61;
              case 2:
                goto LABEL_62;
              case 3:
                goto LABEL_63;
            }
        }
      }
      else
      {
        memcpy((void *)v46, (const void *)v47, 4 * v49);
        v47 += 4 * v49;
        v46 += 4 * v49;
        switch ( v48 )
        {
          case 0:
            goto LABEL_60;
          case 1:
            goto LABEL_61;
          case 2:
            goto LABEL_62;
          case 3:
            break;
        }
      }
LABEL_63:
      *(_BYTE *)(v46 + 3) = *(_BYTE *)(v47 + 3);
      *(_BYTE *)(v46 + 2) = *(_BYTE *)(v47 + 2);
      *(_BYTE *)(v46 + 1) = *(_BYTE *)(v47 + 1);
      result = a1;
    }
  }
  else
  {
    __asm { bt      dword_100768A0, 1 }
    if ( _CF )
    {
      memcpy(a1, a2, a3);
      return a1;
    }
    if ( a3 < 0x80 )
      goto LABEL_33;
    if ( ((unsigned int)a2 ^ (unsigned int)a1) & 0xF )
      goto LABEL_83;
    __asm { bt      dword_10074238, 1 }
    if ( !_CF )
    {
LABEL_83:
      __asm { bt      dword_100768A0, 0 }
      if ( _CF )
      {
        if ( !((_BYTE)a1 & 3) )
        {
          if ( !((_BYTE)a2 & 3) )
          {
            __asm { bt      edi, 2 }
            if ( _CF )
            {
              _ECX = a3 - 4;
              _ESI = (int)((char *)a2 + 4);
              *(_DWORD *)a1 = *(_DWORD *)a2;
              _EDI = (int)((char *)a1 + 4);
            }
            __asm { bt      edi, 3 }
            if ( _CF )
            {
              __asm { movq    xmm1, qword ptr [esi] }
              _ECX -= 8;
              _ESI += 8;
              __asm { movq    qword ptr [edi], xmm1 }
              _EDI += 8;
            }
            if ( _ESI & 7 )
            {
              __asm { bt      esi, 3 }
              if ( _CF )
              {
                __asm { movdqa  xmm1, xmmword ptr [esi-0Ch] }
                _ESI = _ESI - 12;
                do
                {
                  __asm { movdqa  xmm3, xmmword ptr [esi+10h] }
                  _ECX -= 48;
                  __asm
                  {
                    movdqa  xmm0, xmmword ptr [esi+20h]
                    movdqa  xmm5, xmmword ptr [esi+30h]
                  }
                  _ESI += 48;
                  __asm
                  {
                    movdqa  xmm2, xmm3
                    palignr xmm3, xmm1, 0Ch
                    movdqa  xmmword ptr [edi], xmm3
                    movdqa  xmm4, xmm0
                    palignr xmm0, xmm2, 0Ch
                    movdqa  xmmword ptr [edi+10h], xmm0
                    movdqa  xmm1, xmm5
                    palignr xmm5, xmm4, 0Ch
                    movdqa  xmmword ptr [edi+20h], xmm5
                  }
                  _EDI += 48;
                }
                while ( _ECX >= 48 );
                _ESI = _ESI + 12;
              }
              else
              {
                __asm { movdqa  xmm1, xmmword ptr [esi-4] }
                _ESI = _ESI - 4;
                do
                {
                  __asm { movdqa  xmm3, xmmword ptr [esi+10h] }
                  _ECX -= 48;
                  __asm
                  {
                    movdqa  xmm0, xmmword ptr [esi+20h]
                    movdqa  xmm5, xmmword ptr [esi+30h]
                  }
                  _ESI += 48;
                  __asm
                  {
                    movdqa  xmm2, xmm3
                    palignr xmm3, xmm1, 4
                    movdqa  xmmword ptr [edi], xmm3
                    movdqa  xmm4, xmm0
                    palignr xmm0, xmm2, 4
                    movdqa  xmmword ptr [edi+10h], xmm0
                    movdqa  xmm1, xmm5
                    palignr xmm5, xmm4, 4
                    movdqa  xmmword ptr [edi+20h], xmm5
                  }
                  _EDI += 48;
                }
                while ( _ECX >= 48 );
                _ESI = _ESI + 4;
              }
            }
            else
            {
              __asm { movdqa  xmm1, xmmword ptr [esi-8] }
              _ESI = _ESI - 8;
              do
              {
                __asm { movdqa  xmm3, xmmword ptr [esi+10h] }
                _ECX -= 48;
                __asm
                {
                  movdqa  xmm0, xmmword ptr [esi+20h]
                  movdqa  xmm5, xmmword ptr [esi+30h]
                }
                _ESI += 48;
                __asm
                {
                  movdqa  xmm2, xmm3
                  palignr xmm3, xmm1, 8
                  movdqa  xmmword ptr [edi], xmm3
                  movdqa  xmm4, xmm0
                  palignr xmm0, xmm2, 8
                  movdqa  xmmword ptr [edi+10h], xmm0
                  movdqa  xmm1, xmm5
                  palignr xmm5, xmm4, 8
                  movdqa  xmmword ptr [edi+20h], xmm5
                }
                _EDI += 48;
              }
              while ( _ECX >= 48 );
              _ESI = _ESI + 8;
            }
            while ( _ECX >= 16 )
            {
              __asm { movdqu  xmm1, xmmword ptr [esi] }
              _ECX -= 16;
              _ESI += 16;
              __asm { movdqa  xmmword ptr [edi], xmm1 }
              _EDI += 16;
            }
            __asm { bt      ecx, 2 }
            if ( _CF )
            {
              v38 = *(_DWORD *)_ESI;
              _ECX -= 4;
              _ESI += 4;
              *(_DWORD *)_EDI = v38;
              _EDI += 4;
            }
            __asm { bt      ecx, 3 }
            if ( _CF )
            {
              __asm { movq    xmm1, qword ptr [esi] }
              _ECX -= 8;
              __asm { movq    qword ptr [edi], xmm1 }
            }
            JUMPOUT(__CS__, *((_DWORD *)off_1002A7E8 + _ECX));
          }
          goto LABEL_34;
        }
        goto LABEL_36;
      }
LABEL_33:
      if ( !((_BYTE)a1 & 3) )
      {
LABEL_34:
        v44 = a3 >> 2;
        v43 = a3 & 3;
        if ( a3 >> 2 < 8 )
        {
          switch ( v44 )
          {
            case 0u:
              goto LABEL_47;
            case 1u:
              goto LABEL_46;
            case 2u:
              goto LABEL_45;
            case 3u:
              goto LABEL_44;
            case 4u:
              goto LABEL_43;
            case 5u:
              goto LABEL_42;
            case 6u:
              break;
            case 7u:
              *((_DWORD *)a1 + v44 - 7) = *((_DWORD *)a2 + v44 - 7);
              break;
          }
          *((_DWORD *)a1 + v44 - 6) = *((_DWORD *)a2 + v44 - 6);
LABEL_42:
          *((_DWORD *)a1 + v44 - 5) = *((_DWORD *)a2 + v44 - 5);
LABEL_43:
          *((_DWORD *)a1 + v44 - 4) = *((_DWORD *)a2 + v44 - 4);
LABEL_44:
          *((_DWORD *)a1 + v44 - 3) = *((_DWORD *)a2 + v44 - 3);
LABEL_45:
          *((_DWORD *)a1 + v44 - 2) = *((_DWORD *)a2 + v44 - 2);
LABEL_46:
          *((_DWORD *)a1 + v44 - 1) = *((_DWORD *)a2 + v44 - 1);
          _ESI = (int)((char *)a2 + 4 * v44);
          _EDI = (int)((char *)a1 + 4 * v44);
LABEL_47:
          switch ( v43 )
          {
            case 0:
              return a1;
            case 1:
LABEL_49:
              *(_BYTE *)_EDI = *(_BYTE *)_ESI;
              return a1;
            case 2:
LABEL_50:
              *(_BYTE *)_EDI = *(_BYTE *)_ESI;
              *(_BYTE *)(_EDI + 1) = *(_BYTE *)(_ESI + 1);
              return a1;
            case 3:
              break;
          }
        }
        else
        {
          memcpy(a1, a2, 4 * v44);
          _ESI = (int)((char *)a2 + 4 * v44);
          _EDI = (int)((char *)a1 + 4 * v44);
          switch ( v43 )
          {
            case 0:
              return a1;
            case 1:
              goto LABEL_49;
            case 2:
              goto LABEL_50;
            case 3:
              break;
          }
        }
        *(_BYTE *)_EDI = *(_BYTE *)_ESI;
        *(_BYTE *)(_EDI + 1) = *(_BYTE *)(_ESI + 1);
        *(_BYTE *)(_EDI + 2) = *(_BYTE *)(_ESI + 2);
        return a1;
      }
LABEL_36:
      if ( a3 >= 4 )
        JUMPOUT(__CS__, *((_DWORD *)loc_1002A6F8 + ((_BYTE)a1 & 3) + 1));
      JUMPOUT(__CS__, *((_DWORD *)loc_1002A7F8 + a3 - 4));
    }
    v50 = (_BYTE)a2 & 0xF;
    if ( (_BYTE)a2 & 0xF )
    {
      v62 = a3 - (16 - v50);
      v59 = 16 - v50;
      for ( i = v59 & 3; i; --i )
        *(_BYTE *)_EDI++ = *(_BYTE *)_ESI++;
      for ( j = v59 >> 2; j; --j )
      {
        *(_DWORD *)_EDI = *(_DWORD *)_ESI;
        _ESI += 4;
        _EDI += 4;
      }
      _ECX = v62;
    }
    v52 = _ECX;
    v53 = _ECX & 0x7F;
    for ( k = v52 >> 7; k; --k )
    {
      __asm
      {
        movdqa  xmm0, xmmword ptr [esi]
        movdqa  xmm1, xmmword ptr [esi+10h]
        movdqa  xmm2, xmmword ptr [esi+20h]
        movdqa  xmm3, xmmword ptr [esi+30h]
        movdqa  xmmword ptr [edi], xmm0
        movdqa  xmmword ptr [edi+10h], xmm1
        movdqa  xmmword ptr [edi+20h], xmm2
        movdqa  xmmword ptr [edi+30h], xmm3
        movdqa  xmm4, xmmword ptr [esi+40h]
        movdqa  xmm5, xmmword ptr [esi+50h]
        movdqa  xmm6, xmmword ptr [esi+60h]
        movdqa  xmm7, xmmword ptr [esi+70h]
        movdqa  xmmword ptr [edi+40h], xmm4
        movdqa  xmmword ptr [edi+50h], xmm5
        movdqa  xmmword ptr [edi+60h], xmm6
        movdqa  xmmword ptr [edi+70h], xmm7
      }
      _ESI += 128;
      _EDI += 128;
    }
    if ( v53 )
    {
      for ( l = (unsigned int)v53 >> 4; l; --l )
      {
        __asm
        {
          movdqa  xmm0, xmmword ptr [esi]
          movdqa  xmmword ptr [edi], xmm0
        }
        _ESI += 16;
        _EDI += 16;
      }
      v55 = v53 & 0xF;
      if ( v55 )
      {
        v56 = v55;
        for ( m = (unsigned int)v55 >> 2; m; --m )
        {
          *(_DWORD *)_EDI = *(_DWORD *)_ESI;
          _ESI += 4;
          _EDI += 4;
        }
        for ( n = v56 & 3; n; --n )
          *(_BYTE *)_EDI++ = *(_BYTE *)_ESI++;
      }
    }
    result = a1;
  }
  return result;
}
// 1002A6F8: using guessed type int __cdecl loc_1002A6F8(int, int, int);
// 1002A7E8: using guessed type int __cdecl off_1002A7E8(int, int, int);
// 1002A7F8: using guessed type int __cdecl loc_1002A7F8(int, int, int);
// 1002A884: using guessed type int __cdecl loc_1002A884(int, int, int);

//----- (1002AAF4) --------------------------------------------------------
__int64 __usercall sub_1002AAF4<edx:eax>(int a1<ebx>, int a2, int a3)
{
  __int64 result; // qax@2
  unsigned int v4; // eax@3
  int v5; // ebx@3
  int v6; // esi@3
  __int64 v7; // qax@3
  unsigned __int8 v8; // cf@3
  signed int v9; // eax@5
  int v10; // ecx@7
  __int64 v11; // qax@7
  unsigned __int8 v12; // cf@7
  unsigned __int8 v13; // cf@8
  int v14; // edi@11
  unsigned __int64 v15; // ST04_8@11
  __int64 v16; // qax@11
  unsigned __int64 v17; // ST04_8@12
  __int64 v18; // qax@12
  unsigned __int64 v19; // ST04_8@13
  __int64 v20; // qax@13
  __int64 v21; // qax@16
  int v22; // ecx@16
  unsigned __int64 v23; // qdi@16
  unsigned __int64 v24; // ST04_8@16
  __int64 v25; // qax@16
  __int64 v26; // qcx@16
  __int64 v27; // qax@16
  int v28; // eax@16
  unsigned __int8 v29; // cf@16
  int v30; // edx@16
  int v31; // eax@16
  int v32; // edx@16
  __int64 v33; // qax@16
  __int64 v34; // qax@16
  __int64 v35; // qax@16
  __int64 v36; // qax@16
  __int64 v37; // qax@16
  __int64 v38; // qax@16
  int v39; // eax@20
  signed int v40; // eax@23
  int v41; // [sp+4h] [bp-48h]@1
  int v42; // [sp+8h] [bp-44h]@1
  int v43; // [sp+Ch] [bp-40h]@11
  int v44; // [sp+10h] [bp-3Ch]@1
  int v45; // [sp+14h] [bp-38h]@11
  unsigned int v46; // [sp+18h] [bp-34h]@11
  __int64 v47; // [sp+1Ch] [bp-30h]@3
  char v48; // [sp+24h] [bp-28h]@19
  int v49; // [sp+44h] [bp-8h]@22
  unsigned int v50; // [sp+48h] [bp-4h]@1
  int v51; // [sp+4Ch] [bp+0h]@1

  v50 = (unsigned int)&v51 ^ __security_cookie;
  v42 = 0;
  v41 = 0;
  v44 = a2;
  if ( !a2 )
  {
    *(_DWORD *)sub_10037669(a1) = 22;
    sub_1003A16E(a1, 0);
    return -1i64;
  }
  v7 = *(_DWORD *)(a2 + 20);
  v6 = (unsigned __int64)*(_DWORD *)(a2 + 20) >> 32;
  v5 = v7;
  v8 = (_DWORD)v7 >= 0x45u;
  v4 = v7 - 69;
  LODWORD(v47) = v5;
  HIDWORD(v47) = HIDWORD(v7);
  if ( v8 + HIDWORD(v7) != 1 )
    goto LABEL_27;
  if ( v4 > 0x408 )
    goto LABEL_27;
  v9 = *(_DWORD *)(a2 + 16);
  if ( v9 < 0 || v9 > 11 )
  {
    v10 = v9 % 12;
    v11 = v9 / 12;
    v12 = (_DWORD)v11 >= (unsigned int)-v5;
    v5 += v11;
    v6 += HIDWORD(v11) + v12;
    LODWORD(v47) = v5;
    HIDWORD(v47) = v6;
    *(_DWORD *)(a2 + 16) = v10;
    if ( v10 < 0 )
    {
      v13 = (unsigned int)v5-- >= 1;
      v6 = v13 + v6 - 1;
      *(_DWORD *)(a2 + 16) = v10 + 12;
      LODWORD(v47) = v5;
      HIDWORD(v47) = v6;
    }
    if ( ((unsigned int)v5 >= 0x45) + v6 != 1 || (unsigned int)(v5 - 69) > 0x408 )
      goto LABEL_27;
  }
  v46 = *(_DWORD *)(a2 + 16);
  HIDWORD(v15) = v6;
  v14 = dword_100742F0[v46];
  LODWORD(v15) = v5;
  v43 = v14;
  v45 = (unsigned __int64)v14 >> 32;
  LODWORD(v16) = sub_1003AD00(v15, 4i64);
  if ( !v16 && (HIDWORD(v17) = v6, LODWORD(v17) = v5, LODWORD(v18) = sub_1003AD00(v17, 100i64), v18)
    || (HIDWORD(v19) = ((unsigned int)v5 >= 0xFFFFF894) + v6,
        LODWORD(v19) = v5 + 1900,
        LODWORD(v20) = sub_1003AD00(v19, 400i64),
        !v20) )
  {
    if ( (signed int)v46 > 1 )
    {
      v45 += (unsigned int)v14 >= 0xFFFFFFFF;
      v43 = v14 + 1;
    }
  }
  v23 = __PAIR__(v6, v5) - 1;
  HIDWORD(v24) = ((unsigned int)v5 >= 0xFFFFFED5) + HIDWORD(v47);
  LODWORD(v24) = v5 + 299;
  LODWORD(v25) = sub_1003AC50(v24, 0x190u, 0);
  v26 = v25;
  v27 = *(_DWORD *)(v44 + 12);
  v46 = v27 + v26;
  HIDWORD(v26) = (unsigned __int64)(v27 + v26) >> 32;
  v28 = sub_1003AC50(v23, 0x64u, 0);
  v29 = v46 < v28;
  v46 -= v28;
  HIDWORD(v26) -= v29 + v30;
  v31 = sub_1003AC50(v23, 4u, 0);
  HIDWORD(v23) = v31 + v46;
  HIDWORD(v26) += v32 + (v31 >= (unsigned int)-v46);
  v33 = sub_10039A40(v47, 365i64);
  v34 = sub_10039A40(
          __PAIR__(
            v45
          + (v43 >= (unsigned int)-(v33 + HIDWORD(v23)))
          + HIDWORD(v33)
          + (unsigned int)((_DWORD)v33 >= (unsigned int)-HIDWORD(v23))
          + HIDWORD(v26),
            v43 + (_DWORD)v33 + HIDWORD(v23))
        - 25567,
          24i64);
  v5 = v44;
  HIDWORD(v23) = HIDWORD(v34);
  v35 = (unsigned int)v34 + *(_DWORD *)(v44 + 8);
  HIDWORD(v35) += HIDWORD(v23);
  v36 = sub_10039A40(v35, 60i64);
  HIDWORD(v23) = HIDWORD(v36);
  v37 = (unsigned int)v36 + *(_DWORD *)(v44 + 4);
  HIDWORD(v37) += HIDWORD(v23);
  v38 = sub_10039A40(v37, 60i64);
  v22 = v38;
  HIDWORD(v23) = HIDWORD(v38);
  v21 = (unsigned int)v38 + *(_DWORD *)v44;
  HIDWORD(v21) += HIDWORD(v23);
  v47 = v21;
  if ( a3 )
  {
    sub_1003A4B7(SHIDWORD(v21), v22, v44, 0);
    if ( sub_1003A1EB(v44, 0, (int)&v42) || sub_1003A215(v5, 0, (int)&v41) )
    {
      sub_1003A17E(v5, 0);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1002ADA0);
    }
    v47 += v41;
    if ( sub_1003A23F((int)&v48, (int)&v47) )
      goto LABEL_27;
    v39 = *(_DWORD *)(v5 + 32);
    if ( v39 <= 0 && (v39 >= 0 || v49 <= 0) )
      goto LABEL_26;
    v47 += v42;
    v40 = sub_1003A23F((int)&v48, (int)&v47);
  }
  else
  {
    v40 = sub_10030388(v44, 0, (int)&v48, (int)&v47);
  }
  if ( !v40 )
  {
LABEL_26:
    result = v47;
    memcpy((void *)v5, &v48, 0x24u);
    return result;
  }
LABEL_27:
  *(_DWORD *)sub_10037669(v5) = 22;
  return -1i64;
}
// 10074200: using guessed type int __security_cookie;
// 100742F0: using guessed type int dword_100742F0[];

//----- (1002ADA0) --------------------------------------------------------
__int64 __usercall sub_1002ADA0<edx:eax>(int a1<ebx>, int a2)
{
  return sub_1002AAF4(a1, a2, 0);
}

//----- (1002ADB1) --------------------------------------------------------
int __usercall sub_1002ADB1<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int dwBytes)
{
  bool v5; // eax@2
  int v6; // ST08_4@2
  int result; // eax@3
  int v8; // ecx@5
  int v9; // esi@5
  int (__stdcall **v10)(char); // [sp+0h] [bp-10h]@5
  int v11; // [sp+Ch] [bp-4h]@5

  while ( 1 )
  {
    result = sub_10030910(a1, a2, a3, a4, dwBytes);
    if ( result )
      break;
    v5 = sub_1003ADB2(dwBytes);
    a2 = v6;
    if ( !v5 )
    {
      v11 = (int)"bad allocation";
      sub_1002AEC9((int)&v10, (int)&v11, 1);
      v10 = &off_100602D4;
      sub_100355DB((int)&v10, (int)&unk_1006BAB0);
      __asm { int     3               ; Trap to Debugger }
      v9 = v8;
      sub_1002AE6D(v8, a3, dwBytes);
      *(_DWORD *)v9 = &off_10061924;
      return v9;
    }
  }
  return result;
}
// 100602D4: using guessed type int (__stdcall *off_100602D4)(char);
// 10061924: using guessed type int (__stdcall *off_10061924)(char);

//----- (1002AE1B) --------------------------------------------------------
int __thiscall sub_1002AE1B(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002AE88(this, a2);
  *(_DWORD *)v3 = &off_10061924;
  return v3;
}
// 10061924: using guessed type int (__stdcall *off_10061924)(char);

//----- (1002AE36) --------------------------------------------------------
int __userpurge sub_1002AE36<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_1006190C;
  return v4;
}
// 1006190C: using guessed type int (__stdcall *off_1006190C)(char);

//----- (1002AE51) --------------------------------------------------------
int __thiscall sub_1002AE51(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002AEA4(this, (int *)&a2);
  *(_DWORD *)v3 = &off_1006190C;
  return v3;
}
// 1006190C: using guessed type int (__stdcall *off_1006190C)(char);

//----- (1002AE6D) --------------------------------------------------------
int __userpurge sub_1002AE6D<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10061918;
  return v4;
}
// 10061918: using guessed type int (__stdcall *off_10061918)(char);

//----- (1002AE88) --------------------------------------------------------
int __thiscall sub_1002AE88(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002AEA4(this, (int *)&a2);
  *(_DWORD *)v3 = &off_10061918;
  return v3;
}
// 10061918: using guessed type int (__stdcall *off_10061918)(char);

//----- (1002AEA4) --------------------------------------------------------
int __thiscall sub_1002AEA4(int this, int *a2)
{
  int v3; // esi@1

  v3 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = &off_100618EC;
  *(_BYTE *)(this + 8) = 0;
  sub_1002AF7B((void *)this, *a2);
  return v3;
}
// 100618EC: using guessed type int (__stdcall *off_100618EC)(char);

//----- (1002AEC9) --------------------------------------------------------
int __thiscall sub_1002AEC9(int this, int a2, int a3)
{
  *(_DWORD *)this = &off_100618EC;
  *(_DWORD *)(this + 4) = *(_DWORD *)a2;
  *(_BYTE *)(this + 8) = 0;
  return this;
}
// 100618EC: using guessed type int (__stdcall *off_100618EC)(char);

//----- (1002AEE4) --------------------------------------------------------
int __userpurge sub_1002AEE4<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = &off_100618EC;
  *(_BYTE *)(a1 + 8) = 0;
  sub_1002AF23(a1, a2, a3);
  return v4;
}
// 100618EC: using guessed type int (__stdcall *off_100618EC)(char);

//----- (1002AF07) --------------------------------------------------------
int __thiscall sub_1002AF07(int this)
{
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = &off_100618EC;
  *(_BYTE *)(this + 8) = 0;
  return this;
}
// 100618EC: using guessed type int (__stdcall *off_100618EC)(char);

//----- (1002AF18) --------------------------------------------------------
void __usercall sub_1002AF18(int a1<ecx>, int a2<ebx>)
{
  *(_DWORD *)a1 = &off_100618EC;
  sub_1002AFB9(a1, a2);
}
// 100618EC: using guessed type int (__stdcall *off_100618EC)(char);

//----- (1002AF23) --------------------------------------------------------
int __userpurge sub_1002AF23<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v3; // esi@1

  v3 = a1;
  if ( a1 != a3 )
  {
    sub_1002AFB9(a1, a2);
    if ( *(_BYTE *)(a3 + 8) )
      sub_1002AF7B((void *)v3, *(_DWORD *)(a3 + 4));
    else
      *(_DWORD *)(v3 + 4) = *(_DWORD *)(a3 + 4);
  }
  return v3;
}

//----- (1002AF56) --------------------------------------------------------
void *__userpurge sub_1002AF56<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  *(_DWORD *)a1 = &off_100618EC;
  sub_1002AFB9(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100618EC: using guessed type int (__stdcall *off_100618EC)(char);

//----- (1002AF7B) --------------------------------------------------------
void __thiscall sub_1002AF7B(void *this, int a2)
{
  int v2; // ebx@1
  int v3; // eax@2
  int v4; // edi@2
  int v5; // eax@2
  int v6; // edx@2
  int v7; // ecx@2

  v2 = (int)this;
  if ( a2 )
  {
    v5 = sub_10035550(a2);
    v4 = v5 + 1;
    v3 = sub_10030910(v6, v7, v2, v5 + 1, v5 + 1);
    *(_DWORD *)(v2 + 4) = v3;
    if ( v3 )
    {
      sub_1003ADE5(v2, v4, v3, v4, a2);
      *(_BYTE *)(v2 + 8) = 1;
    }
  }
}

//----- (1002AFB9) --------------------------------------------------------
void __usercall sub_1002AFB9(int a1<ecx>, int a2<ebx>)
{
  int v2; // esi@1

  v2 = a1;
  if ( *(_BYTE *)(a1 + 8) )
    sub_100309A2(a2, *(LPVOID *)(a1 + 4));
  *(_DWORD *)(v2 + 4) = 0;
  *(_BYTE *)(v2 + 8) = 0;
}

//----- (1002AFD5) --------------------------------------------------------
int __thiscall sub_1002AFD5(int this)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 4);
  if ( !result )
    result = (int)"Unknown exception";
  return result;
}

//----- (1002AFE5) --------------------------------------------------------
signed int __usercall sub_1002AFE5<eax>(int a1<ecx>, int a2<ebx>)
{
  void *v2; // esi@1
  signed int result; // eax@2

  v2 = sub_10037506(a1, a2, 0x20u, 4u);
  Ptr = EncodePointer(v2);
  dword_10078AC8 = Ptr;
  if ( v2 )
  {
    *(_DWORD *)v2 = 0;
    result = 0;
  }
  else
  {
    result = 24;
  }
  return result;
}

//----- (1002B014) --------------------------------------------------------
void __usercall sub_1002B014(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, PVOID Ptr)
{
  sub_1003B0D9(a1, a2, a3, a4);
  sub_1002B054(Ptr);
  sub_1003B0E2();
}

//----- (1002B054) --------------------------------------------------------
PVOID __cdecl sub_1002B054(PVOID Ptr)
{
  int v1; // ebx@1
  int v2; // edi@2
  int v3; // edx@3
  int v4; // ecx@3
  SIZE_T v5; // esi@3
  signed int v6; // eax@4
  int v7; // eax@6
  int v8; // eax@7
  int v9; // ST04_4@7
  int v11; // [sp-4h] [bp-14h]@3
  PVOID v12; // [sp+Ch] [bp-4h]@1

  v12 = DecodePointer(::Ptr);
  v1 = (int)DecodePointer(dword_10078AC8);
  if ( v1 >= (unsigned int)v12 )
  {
    v2 = v1 - (_DWORD)v12;
    if ( (unsigned int)(v1 - (_DWORD)v12 + 4) >= 4 )
    {
      v5 = sub_1003B21A(v1, v2, v12);
      v4 = v11;
      if ( v5 >= v2 + 4 )
      {
LABEL_11:
        *(_DWORD *)v1 = EncodePointer(Ptr);
        dword_10078AC8 = EncodePointer((PVOID)(v1 + 4));
        return Ptr;
      }
      v6 = 2048;
      if ( v5 < 0x800 )
        v6 = v5;
      v7 = v5 + v6;
      if ( v7 >= v5 && (v8 = sub_10037599(v3, v11, (int)v12, v2, v12, v7), v4 = v9, v8)
        || v5 + 16 >= v5 && (v8 = sub_10037599(v3, v4, (int)v12, v2, v12, v5 + 16)) != 0 )
      {
        v1 = v8 + 4 * (v2 >> 2);
        ::Ptr = EncodePointer((PVOID)v8);
        goto LABEL_11;
      }
    }
  }
  return 0;
}

//----- (1002B10A) --------------------------------------------------------
int __usercall sub_1002B10A<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, void *a5)
{
  int v6; // eax@1

  sub_1002B014(a1, a2, a3, a4, a5);
  return (v6 != 0) - 1;
}

//----- (1002B11F) --------------------------------------------------------
signed int __stdcall sub_1002B11F(int a1, int a2, int a3, void (__thiscall *a4)(_DWORD))
{
  int v4; // edi@1
  int i; // esi@1

  v4 = a3;
  for ( i = a3 * a2 + a1; ; a4(i) )
  {
    --v4;
    if ( v4 < 0 )
      break;
    i -= a2;
  }
  return 1;
}

//----- (1002B18E) --------------------------------------------------------
int __stdcall sub_1002B18E(int a1, int a2, int a3, int (*a4)(void))
{
  char v4; // sf@1
  int result; // eax@2

  while ( 1 )
  {
    v4 = a3-- - 1 < 0;
    if ( v4 )
      break;
    a1 -= a2;
    result = a4();
  }
  return result;
}

//----- (1002B1EC) --------------------------------------------------------
int __thiscall sub_1002B1EC(int this, int a2, int a3, int a4)
{
  int v5; // esi@1

  v5 = this;
  sub_1000C740(this, a4);
  *(_DWORD *)(v5 + 28) = a2;
  *(_DWORD *)(v5 + 32) = a3;
  *(_DWORD *)v5 = &off_1006194C;
  return v5;
}
// 1006194C: using guessed type int (__stdcall *off_1006194C)(char);

//----- (1002B21D) --------------------------------------------------------
void *__thiscall sub_1002B21D(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10061930;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10061930: using guessed type int (__stdcall *off_10061930)(char);

//----- (1002B23D) --------------------------------------------------------
int __thiscall sub_1002B23D(void *this, int a2)
{
  int result; // eax@1

  result = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(result + 4);
    *(_DWORD *)a2 = *(_DWORD *)this;
    **(_DWORD **)(*(_DWORD *)this + 4) = a2;
    result = *(_DWORD *)this;
    *(_DWORD *)(*(_DWORD *)this + 4) = a2;
  }
  else
  {
    *(_DWORD *)(a2 + 4) = a2;
    *(_DWORD *)a2 = a2;
  }
  *(_DWORD *)this = a2;
  return result;
}

//----- (1002B26C) --------------------------------------------------------
int __thiscall sub_1002B26C(void *this, int a2)
{
  int result; // eax@1

  **(_DWORD **)(a2 + 4) = *(_DWORD *)a2;
  *(_DWORD *)(*(_DWORD *)a2 + 4) = *(_DWORD *)(a2 + 4);
  result = *(_DWORD *)this;
  if ( a2 == *(_DWORD *)this )
  {
    if ( result == *(_DWORD *)(result + 4) )
      result = 0;
    else
      result = *(_DWORD *)result;
    *(_DWORD *)this = result;
  }
  return result;
}

//----- (1002B29A) --------------------------------------------------------
int __userpurge sub_1002B29A<eax>(int a1<ebp>, int a2)
{
  char v2; // bl@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // ecx@1

  sub_10035668();
  v3 = v5 + 52;
  v2 = 0;
  *(_DWORD *)(a1 - 16) = v5 + 52;
  sub_1002B98B((void *)(v5 + 56));
  v4 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  if ( *(_DWORD *)v3 )
  {
    sub_1002B26C((void *)v3, v4 + 20);
    *(_DWORD *)(v4 + 8) = 2;
    sub_1000AA50((void *)v4);
  }
  else
  {
    v2 = 1;
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002BB75((void *)(v3 + 4));
  if ( v2 )
  {
    _EBX = v4 + 8;
    _ECX = 1;
    __asm { lock cmpxchg [ebx], ecx }
  }
  return sub_10035636(44);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002B34B) --------------------------------------------------------
int __thiscall sub_1002B34B(int this)
{
  return (*(int (__cdecl **)(_DWORD))(this + 28))(*(_DWORD *)(this + 32));
}

//----- (1002B353) --------------------------------------------------------
int __usercall sub_1002B353<eax>(void *this<ecx>, int a2<ebp>)
{
  void *v2; // esi@1
  DWORD v3; // edi@1

  v2 = this;
  v3 = GetCurrentThreadId();
  _EBX = (int)((char *)v2 + 8);
  _EDX = v3;
  __asm { lock cmpxchg [ebx], edx }
  (*(void (__thiscall **)(_DWORD))(*(_DWORD *)v2 + 8))(v2);
  _ECX = 3;
  __asm { lock cmpxchg [ebx], ecx }
  if ( v3 == 2 )
    sub_1002C5B4(a2);
  return sub_1000AA50(v2);
}

//----- (1002B396) --------------------------------------------------------
int __userpurge sub_1002B396<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int v8; // esi@2

  v7 = a2;
  v6 = sub_1002ADB1(a1, a2, a3, a2, 36);
  if ( v6 )
    v8 = sub_1002B1EC(v6, a4, a5, a6);
  else
    v8 = 0;
  sub_1002B3CF(v7, v8);
  return v8;
}

//----- (1002B3CF) --------------------------------------------------------
int __thiscall sub_1002B3CF(int this, int a2)
{
  char v2; // bl@1
  int ebp0; // ebp@0
  int v4; // edi@1
  void *v5; // esi@1
  int result; // eax@4
  int v14; // [sp+14h] [bp+8h]@2

  v5 = (void *)a2;
  v2 = 1;
  *(_DWORD *)(a2 + 8) = 0;
  v4 = this;
  _EDX = a2 + 4;
  _EAX = 1;
  __asm { lock xadd [edx], eax }
  *(_DWORD *)(a2 + 16) = this;
  if ( *(_DWORD *)(this + 8) )
    goto LABEL_8;
  v14 = this + 52;
  sub_1002B98B((void *)(this + 56));
  if ( !*(_DWORD *)(v4 + 8) )
  {
    v2 = 0;
    sub_1002B23D((void *)v14, (int)((char *)v5 + 20));
  }
  result = sub_1002BB75((void *)(v14 + 4));
  if ( v2 )
LABEL_8:
    result = sub_1002B353(v5, ebp0);
  return result;
}

//----- (1002B434) --------------------------------------------------------
PVOID __thiscall sub_1002B434(PVOID Parameter, DWORD DueTime)
{
  int ebp0; // ebp@0
  HANDLE *v3; // edi@1
  PVOID v4; // esi@1
  int v5; // eax@3
  int *v6; // eax@4
  int v7; // eax@5
  int v9; // [sp-4h] [bp-30h]@4
  int (__stdcall **v10)(char); // [sp+Ch] [bp-20h]@6
  int (__stdcall **v11)(char); // [sp+18h] [bp-14h]@4
  int v12; // [sp+24h] [bp-8h]@6
  int v13; // [sp+28h] [bp-4h]@4

  v4 = Parameter;
  *((_DWORD *)Parameter + 1) = 0;
  v3 = (HANDLE *)((char *)Parameter + 12);
  *((_DWORD *)Parameter + 2) = 1;
  *((_DWORD *)Parameter + 3) = 0;
  *((_DWORD *)Parameter + 4) = 0;
  *((_DWORD *)Parameter + 5) = 0;
  *(_DWORD *)Parameter = sub_1002B772(0, ebp0, (int)((char *)Parameter + 12));
  if ( DueTime != -1 )
  {
    if ( sub_1003D695() < 3 )
    {
      v7 = sub_1002C20E();
      if ( !CreateTimerQueueTimer(v3, (HANDLE)v7, (WAITORTIMERCALLBACK)Callback, v4, DueTime, 0, 0x20u) )
      {
        v12 = (int)"bad allocation";
        sub_1002AEC9((int)&v10, (int)&v12, 1);
        v10 = &off_100602D4;
        v9 = (int)&unk_1006BAB0;
        v6 = (int *)&v10;
        goto LABEL_8;
      }
    }
    else
    {
      v5 = sub_10034AB9(DueTime, (int)sub_1002B7B2, (int)v4);
      *v3 = (HANDLE)v5;
      if ( !v5 )
      {
        v13 = (int)"bad allocation";
        sub_1002AEC9((int)&v11, (int)&v13, 1);
        v11 = &off_100602D4;
        v9 = (int)&unk_1006BAB0;
        v6 = (int *)&v11;
LABEL_8:
        sub_100355DB((int)v6, v9);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_1002B4FD);
      }
    }
  }
  return v4;
}
// 1003D695: using guessed type int sub_1003D695(void);
// 100602D4: using guessed type int (__stdcall *off_100602D4)(char);

//----- (1002B4FD) --------------------------------------------------------
int __thiscall sub_1002B4FD(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002B5CC(this);
  return v2;
}

//----- (1002B509) --------------------------------------------------------
int __thiscall sub_1002B509(int this)
{
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  return this;
}

//----- (1002B519) --------------------------------------------------------
LPCRITICAL_SECTION __thiscall sub_1002B519(LPCRITICAL_SECTION lpCriticalSection)
{
  LPCRITICAL_SECTION v2; // esi@1

  v2 = lpCriticalSection;
  InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
  return v2;
}

//----- (1002B52D) --------------------------------------------------------
int __thiscall sub_1002B52D(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002B5CC(this);
  *(_DWORD *)(v2 + 32) = 0;
  *(_DWORD *)(v2 + 36) = -1;
  return v2;
}

//----- (1002B544) --------------------------------------------------------
int __userpurge sub_1002B544<eax>(int a1<ebp>, int a2)
{
  int v2; // ecx@1
  int v3; // edi@1
  int *v4; // esi@1
  int v6; // ecx@3

  sub_10035668();
  v4 = (int *)v2;
  *(_DWORD *)(a1 - 16) = v2;
  v3 = v2 + 4;
  *(_DWORD *)v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v2 + 4;
  *(_DWORD *)(a1 - 4) = 0;
  if ( v2 != -4 )
    sub_1002B434((PVOID)(v2 + 4), 0xFFFFFFFFu);
  v6 = *v4;
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002B9BF(v6, v3, 1);
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002B589) --------------------------------------------------------
int __userpurge sub_1002B589<eax>(int a1<ebp>, int a2)
{
  int v2; // ecx@1
  int v3; // edi@1
  void **v4; // esi@1
  void *v6; // ecx@3

  sub_10035668();
  v4 = (void **)v2;
  *(_DWORD *)(a1 - 16) = v2;
  v3 = v2 + 4;
  *(_DWORD *)v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v2 + 4;
  *(_DWORD *)(a1 - 4) = 0;
  if ( v2 != -4 )
    sub_1002B434((PVOID)(v2 + 4), 0xFFFFFFFFu);
  v6 = *v4;
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002B926(v6, v3);
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002B5CC) --------------------------------------------------------
int __thiscall sub_1002B5CC(int this)
{
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 8) = 2;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  return this;
}

//----- (1002B5EC) --------------------------------------------------------
int __userpurge sub_1002B5EC<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_1006195C;
  return v4;
}
// 1006195C: using guessed type int (__stdcall *off_1006195C)(char);

//----- (1002B607) --------------------------------------------------------
int __thiscall sub_1002B607(int this)
{
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 8) = 2;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  return this;
}

//----- (1002B62D) --------------------------------------------------------
int __userpurge sub_1002B62D<eax>(int a1<ebp>, int a2)
{
  int v2; // ecx@1
  int *v3; // edi@1
  int v4; // esi@1
  int v6; // ecx@3

  sub_10035668();
  v3 = (int *)v2;
  v4 = v2 + 4;
  *(_DWORD *)v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v2 + 4;
  *(_DWORD *)(a1 - 16) = v2 + 4;
  *(_DWORD *)(a1 - 4) = 0;
  if ( v2 != -4 )
    sub_1002B434((PVOID)(v2 + 4), 0xFFFFFFFFu);
  v6 = *v3;
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002B9BF(v6, v4, 1);
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002B672) --------------------------------------------------------
int __userpurge sub_1002B672<eax>(int a1<ebp>, int a2)
{
  int v2; // ecx@1
  int *v3; // edi@1
  int v4; // esi@1
  int v6; // ecx@3

  sub_10035668();
  v3 = (int *)v2;
  v4 = v2 + 4;
  *(_DWORD *)v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v2 + 4;
  *(_DWORD *)(a1 - 16) = v2 + 4;
  *(_DWORD *)(a1 - 4) = 0;
  if ( v2 != -4 )
    sub_1002B434((PVOID)(v2 + 4), 0xFFFFFFFFu);
  v6 = *v3;
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002BA5E(v6, v4, 1);
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002B6B7) --------------------------------------------------------
int __userpurge sub_1002B6B7<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  *(_DWORD *)a1 = a3;
  sub_1002BDD3(a3, a2);
  return v4;
}

//----- (1002B6CE) --------------------------------------------------------
void __thiscall sub_1002B6CE(LPCRITICAL_SECTION lpCriticalSection)
{
  DeleteCriticalSection(lpCriticalSection);
}

//----- (1002B6D6) --------------------------------------------------------
void __cdecl sub_1002B6D6()
{
  JUMPOUT(*(unsigned int *)loc_1002BE77);
}
// 1002BE77: using guessed type int loc_1002BE77();

//----- (1002B6DD) --------------------------------------------------------
void __thiscall sub_1002B6DD(void *this)
{
  int v1; // ecx@1
  char v2; // zf@1

  v1 = *(_DWORD *)this;
  v2 = *(_DWORD *)(v1 + 32)-- == 1;
  if ( v2 )
  {
    *(_DWORD *)(v1 + 36) = -1;
    JUMPOUT(*(unsigned int *)loc_1002BE77);
  }
}
// 1002BE77: using guessed type int loc_1002BE77();

//----- (1002B6E5) --------------------------------------------------------
char __thiscall sub_1002B6E5(void *this)
{
  int v1; // ecx@1
  void *v9; // ecx@5
  int v10; // edi@5
  int v11; // esi@5
  int v12; // eax@7
  int v15; // eax@10

  v1 = *(_DWORD *)this;
  if ( *(_DWORD *)(v1 + 36) >= 8 )
  {
    _EDX = -8;
    _EAX = v1 + 36;
    __asm { lock xadd [eax], edx }
    if ( (_EDX & 0xFFFFFFFB) == 11 )
      LOBYTE(_EAX) = sub_1002B84F(*(void **)(v1 + 28));
  }
  else
  {
    _EAX = *(_DWORD *)(v1 + 36);
    if ( _EAX & 2 )
    {
      v11 = v1;
      v10 = *(_DWORD *)(v1 + 28);
      v9 = *(void **)(v10 + 4);
      *(_DWORD *)v11 = 0;
      *(_DWORD *)(v11 + 28) = v9;
      if ( v9 )
      {
        LOBYTE(_EAX) = sub_1002B84F(v9);
      }
      else
      {
        _EDX = v11 + 36;
        v12 = *(_DWORD *)(v11 + 36);
        do
        {
          _ECX = v12 & 0xFFFFFFFC;
          __asm { lock cmpxchg [edx], ecx }
        }
        while ( v12 & 0xFFFFFFFC );
        if ( v12 & 4 )
        {
          v15 = sub_1002BB1C((void *)v11);
          sub_1002B84F((void *)v15);
        }
        LOBYTE(_EAX) = sub_1002BB86((void *)v11, v10);
      }
    }
  }
  return _EAX;
}

//----- (1002B6EC) --------------------------------------------------------
int __userpurge sub_1002B6EC<eax>(void *this<ecx>, int ebx0<ebx>, unsigned int a2)
{
  int ebp0; // ebp@0
  unsigned int v4; // edi@1
  void *v5; // esi@1
  unsigned int v6; // edx@3
  char v8; // [sp+8h] [bp-10h]@6
  int v9; // [sp+10h] [bp-8h]@6
  BOOL (__cdecl *v10)(); // [sp+14h] [bp-4h]@6

  v5 = this;
  v4 = sub_1003D69A();
  if ( !((*((_DWORD *)v5 + 2) >> 2) & 1) )
  {
    if ( (*((_DWORD *)v5 + 2) >> 1) & 1 )
      v6 = (*((_DWORD *)v5 + 2) >> 3) - (a2 >> 3);
    else
      v6 = 1;
    v4 += 2;
    if ( v6 <= v4 )
    {
      v9 = 0;
      v10 = sub_10034C15;
      sub_1002BBBF((int)&v8, dwSpinCount + dwSpinCount * (v6 - 1) / v4);
      while ( *((_DWORD *)v5 + 2) & 1 && sub_1002BC26(&v8) )
        ;
    }
  }
  return sub_1003115F(ebx0, ebp0, v4);
}

//----- (1002B772) --------------------------------------------------------
LPVOID __usercall sub_1002B772<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  LPVOID result; // eax@2
  int v4; // edi@2
  int v5; // esi@2

  if ( !(dword_10073D14 & 0x80000000) || (result = TlsGetValue(dwTlsIndex), !result) )
  {
    v4 = sub_1003285B(a2, a3);
    v5 = sub_10031DDF((void *)v4, a1, 0);
    (*(void (__thiscall **)(_DWORD))(*(_DWORD *)v4 + 20))(v4);
    result = (LPVOID)v5;
  }
  return result;
}
// 10073D14: using guessed type int dword_10073D14;

//----- (1002B794) --------------------------------------------------------
int __thiscall sub_1002B794(int this)
{
  int result; // eax@2

  if ( *(_DWORD *)(this + 12) )
  {
    result = this + 20;
    _EDX = 1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      result = sub_1002A4AA((LPVOID)this);
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002B7B2) --------------------------------------------------------
int __stdcall sub_1002B7B2(int a1, int a2, int a3)
{
  _EDX = 2;
  _ECX = a2 + 16;
  __asm { lock cmpxchg [ecx], edx }
  (*(void (**)(void))(**(_DWORD **)a2 + 12))();
  return sub_10034B51(a1, a3);
}

//----- (1002B7EB) --------------------------------------------------------
int __stdcall Callback(int a1, int a2)
{
  void *v3; // ST04_4@1
  int v4; // eax@1

  v3 = *(void **)(a1 + 12);
  v4 = sub_1002C20E();
  sub_1003B587((HANDLE)v4, v3, 0);
  _ECX = a1 + 16;
  _EDX = 2;
  __asm { lock cmpxchg [ecx], edx }
  return (*(int (**)(void))(**(_DWORD **)a1 + 12))();
}

//----- (1002B82A) --------------------------------------------------------
int __usercall sub_1002B82A<eax>(int this<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>)
{
  int v4; // esi@1
  int result; // eax@2
  int v6; // edx@2

  v4 = this;
  if ( *(_DWORD *)(this + 12) )
  {
    result = this + 16;
    v6 = *(_DWORD *)(this + 16);
    *(_DWORD *)(this + 16) = 1;
    if ( v6 == 2 )
    {
      sub_1003115F(a2, a3, a4);
      result = sub_1002B794(v4);
    }
  }
  return result;
}

//----- (1002B84F) --------------------------------------------------------
char __thiscall sub_1002B84F(void *this)
{
  _ESI = 1;
  _EDX = (int)((char *)this + 16);
  __asm { lock cmpxchg [edx], esi }
  *((_DWORD *)this + 2) &= 0xFFFFFFFEu;
  (*(void (**)(void))(**(_DWORD **)this + 12))();
  return 1;
}

//----- (1002B872) --------------------------------------------------------
int __thiscall sub_1002B872(void *this, int a2)
{
  int result; // eax@1
  void *v3; // esi@1

  v3 = this;
  result = *(_DWORD *)(a2 + 8);
  if ( result & 1 )
  {
    result = *(_DWORD *)(a2 + 8) >> 2;
    if ( result & 1 || (result = (*(int (**)(void))(**(_DWORD **)a2 + 16))(), (_BYTE)result) )
      *((_DWORD *)v3 + 2) |= 4u;
  }
  return result;
}

//----- (1002B8A0) --------------------------------------------------------
int __thiscall sub_1002B8A0(int this, int a2)
{
  int result; // eax@1
  int v3; // edi@1
  int v4; // esi@3

  v3 = this;
  result = *(_DWORD *)(this + 8) >> 1;
  if ( !(result & 1) )
  {
    result = *(_DWORD *)(a2 + 8) >> 1;
    if ( result & 1 )
    {
      result = *(_DWORD *)(a2 + 8);
      v4 = (*(_DWORD *)(a2 + 8) + 8) & 0xFFFFFFFA;
      if ( result & 1 )
      {
        result = *(_DWORD *)(a2 + 8) >> 2;
        if ( result & 1
          || !*(_DWORD *)(a2 + 12) && (result = (*(int (**)(void))(**(_DWORD **)a2 + 16))(), (_BYTE)result) )
          v4 |= 4u;
      }
      *(_DWORD *)(v3 + 8) |= v4;
    }
  }
  return result;
}

//----- (1002B8F3) --------------------------------------------------------
int __thiscall sub_1002B8F3(int this)
{
  int result; // eax@1
  int v2; // esi@1
  char v3; // [sp+4h] [bp-10h]@2
  int v4; // [sp+Ch] [bp-8h]@1
  BOOL (__cdecl *v5)(); // [sp+10h] [bp-4h]@1

  v2 = this;
  result = *(_DWORD *)(this + 4);
  v4 = 0;
  v5 = sub_10034C15;
  while ( !result )
  {
    sub_100282E0((int)&v3);
    result = *(_DWORD *)(v2 + 4);
  }
  return result;
}

//----- (1002B91E) --------------------------------------------------------
void __thiscall sub_1002B91E(LPCRITICAL_SECTION lpCriticalSection)
{
  EnterCriticalSection(lpCriticalSection);
}

//----- (1002B926) --------------------------------------------------------
DWORD __thiscall sub_1002B926(void *this, int a2)
{
  DWORD result; // eax@1
  DWORD v3; // edi@1
  int v4; // esi@1

  v4 = (int)this;
  result = GetCurrentThreadId();
  v3 = result;
  if ( *(_DWORD *)(v4 + 36) == result )
  {
    ++*(_DWORD *)(v4 + 32);
  }
  else
  {
    result = sub_1002B9BF(v4, a2, 1);
    *(_DWORD *)(v4 + 36) = v3;
    *(_DWORD *)(v4 + 32) = 1;
  }
  return result;
}

//----- (1002B95B) --------------------------------------------------------
int __thiscall sub_1002B95B(void *this)
{
  int v1; // edi@1
  int v3; // edx@4
  int result; // eax@5

  _ESI = this;
  v1 = (int)((char *)this + 4);
  while ( 1 )
  {
    if ( *(_DWORD *)v1 > 0 )
      sub_1002BD6C(v1, 0, -1);
    v3 = *(_DWORD *)_ESI;
    if ( *(_DWORD *)_ESI != -1 )
    {
      _ECX = v3 + 1;
      result = *(_DWORD *)_ESI;
      __asm { lock cmpxchg [esi], ecx }
      if ( v3 == v3 )
        break;
    }
  }
  return result;
}

//----- (1002B98B) --------------------------------------------------------
int __thiscall sub_1002B98B(void *this)
{
  int result; // eax@1

  _ESI = (int)this;
  _EAX = (int)((char *)this + 4);
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  _EDX = -1;
  result = 0;
  __asm { lock cmpxchg [esi], edx }
  while ( result )
  {
    sub_1002BD6C(_ESI, 0, -1);
    _ECX = -1;
    result = 0;
    __asm { lock cmpxchg [esi], ecx }
  }
  return result;
}

//----- (1002B9BF) --------------------------------------------------------
bool __thiscall sub_1002B9BF(int this, int a2, char a3)
{
  int ebp0; // ebp@0
  int v4; // edi@1
  int v5; // ebx@2
  char v7; // [sp+8h] [bp-Ch]@9

  v4 = this;
  if ( *(_DWORD *)a2 == *(_DWORD *)this )
  {
    sub_1002FF4B((int)&v7, (unsigned int)"Lock already taken");
    sub_100355DB((int)&v7, (int)&unk_1006BD80);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1002BA5E);
  }
  v5 = *(_DWORD *)(this + 28);
  *(_DWORD *)(this + 28) = a2;
  if ( v5 )
  {
    sub_1002B8A0(a2, v5);
    *(_DWORD *)(v5 + 4) = a2;
    sub_1002B6EC((void *)a2, v5, *(_DWORD *)(v4 + 8));
    if ( *(_DWORD *)(a2 + 16) != 2 )
      sub_1002B8A0(a2, v4);
  }
  else
  {
    *(_DWORD *)(this + 24) = a2;
    sub_1002B8A0(a2, this);
    *(_DWORD *)(a2 + 8) &= 0xFFFFFFFEu;
    sub_1002B82A(a2, 0, ebp0, v4);
  }
  if ( a3 )
  {
    *(_DWORD *)(v4 + 8) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(v4 + 4) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)v4 = *(_DWORD *)a2;
    *(_DWORD *)(v4 + 24) = a2;
  }
  return *(_DWORD *)(a2 + 16) != 2;
}

//----- (1002BA5E) --------------------------------------------------------
char __thiscall sub_1002BA5E(int this, int a2, char a3)
{
  int v3; // edi@1
  int v4; // ebx@2
  int v5; // eax@3
  char v7; // [sp+8h] [bp-Ch]@10

  v3 = this;
  if ( *(_DWORD *)a2 == *(_DWORD *)this )
  {
    sub_1002FF4B((int)&v7, (unsigned int)"Lock already taken");
    sub_100355DB((int)&v7, (int)&unk_1006BD80);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1002BAEE);
  }
  v4 = *(_DWORD *)(this + 32);
  *(_DWORD *)(this + 32) = a2;
  if ( v4 )
  {
    sub_1002B8A0(a2, v4);
    *(_DWORD *)(v4 + 4) = a2;
  }
  else
  {
    sub_1002B8A0(a2, this);
    LOBYTE(v5) = sub_1002BBE3(v3, a2);
    if ( (_BYTE)v5 )
    {
      *(_DWORD *)(a2 + 8) &= 0xFFFFFFFEu;
      goto LABEL_7;
    }
  }
  sub_1002B6EC((void *)a2, v4, *(_DWORD *)(v3 + 8));
  LOBYTE(v5) = sub_1002B8A0(a2, v3);
LABEL_7:
  if ( a3 )
  {
    *(_DWORD *)(v3 + 8) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(v3 + 4) = *(_DWORD *)(a2 + 4);
    v5 = *(_DWORD *)a2;
    *(_DWORD *)v3 = *(_DWORD *)a2;
    *(_DWORD *)(v3 + 28) = a2;
  }
  return v5;
}

//----- (1002BAEE) --------------------------------------------------------
int __thiscall sub_1002BAEE(void *this)
{
  int v1; // ecx@1
  int result; // eax@2

  v1 = (int)((char *)this + 4);
  if ( *(_DWORD *)v1 > 0 )
    result = sub_1002BD6C(v1, 0, -1);
  return result;
}

//----- (1002BB04) --------------------------------------------------------
void __thiscall sub_1002BB04(int this)
{
  if ( *(_DWORD *)(this + 28) )
  {
    sub_1002BDA5((void *)this);
    JUMPOUT(*(unsigned int *)loc_1002BE77);
  }
}
// 1002BE77: using guessed type int loc_1002BE77();

//----- (1002BB1C) --------------------------------------------------------
int __thiscall sub_1002BB1C(void *this)
{
  int result; // eax@4
  int v10; // ecx@4

  _EDX = (int)((char *)this + 36);
  _EAX = 4;
  __asm { lock xadd [edx], eax }
  if ( _EAX & 1 )
  {
    if ( !(_EAX & 2) )
    {
      _EAX = 2;
      __asm { lock or [edx], eax }
    }
  }
  v10 = (int)((char *)this + 24);
  result = *(_DWORD *)v10;
  *(_DWORD *)v10 = 0;
  return result;
}

//----- (1002BB3C) --------------------------------------------------------
int __cdecl sub_1002BB3C()
{
  int result; // eax@1

  result = (unsigned int)sub_1003D69A() > 1 ? 0xFA0 : 0;
  dwSpinCount = result;
  return result;
}

//----- (1002BB53) --------------------------------------------------------
void __thiscall sub_1002BB53(LPCRITICAL_SECTION lpCriticalSection)
{
  LeaveCriticalSection(lpCriticalSection);
}

//----- (1002BB6D) --------------------------------------------------------
int __cdecl sub_1002BB6D()
{
  int result; // eax@1

  _EAX = -1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (1002BB75) --------------------------------------------------------
int __thiscall sub_1002BB75(void *this)
{
  int result; // eax@1

  *(_DWORD *)this = 0;
  result = (int)((char *)this + 4);
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  return result;
}

//----- (1002BB86) --------------------------------------------------------
char __thiscall sub_1002BB86(void *this, int a2)
{
  char result; // al@1
  int v3; // edi@1
  int v6; // eax@2
  void *v7; // esi@2

  v3 = (int)this;
  _ESI = 0;
  _EDX = (int)((char *)this + 32);
  result = a2;
  __asm { lock cmpxchg [edx], esi }
  if ( a2 != a2 )
  {
    v6 = sub_1002B8F3(a2);
    v7 = (void *)v6;
    result = sub_1002BBE3(v3, v6);
    if ( result )
      result = sub_1002B84F(v7);
  }
  return result;
}

//----- (1002BBBF) --------------------------------------------------------
int __thiscall sub_1002BBBF(int this, int a2)
{
  int result; // eax@1

  result = a2;
  if ( a2 )
  {
    *(_DWORD *)(this + 4) = 0;
    *(_DWORD *)this = a2;
    *(_DWORD *)(this + 8) = 1;
  }
  else
  {
    *(_DWORD *)(this + 8) = 4;
  }
  return result;
}

//----- (1002BBE3) --------------------------------------------------------
char __thiscall sub_1002BBE3(int this, int a2)
{
  int v2; // eax@1
  signed int v5; // eax@4
  char result; // al@7

  *(_DWORD *)(this + 28) = a2;
  _EDX = this + 36;
  v2 = *(_DWORD *)(this + 36);
  do
  {
    _ECX = v2 | 1;
    __asm { lock cmpxchg [edx], ecx }
  }
  while ( v2 | 1 );
  if ( v2 & 4 )
    goto LABEL_11;
  v5 = *(_DWORD *)_EDX;
  do
  {
    _ECX = v5 | 2;
    __asm { lock cmpxchg [edx], ecx }
  }
  while ( v5 | 2 );
  if ( v5 >= 8 )
LABEL_11:
    result = 0;
  else
    result = 1;
  return result;
}

//----- (1002BC26) --------------------------------------------------------
char __thiscall sub_1002BC26(void *this)
{
  char v1; // bl@1
  int v2; // esi@1
  int v3; // eax@2
  int v4; // eax@4
  int v5; // eax@5
  int v6; // eax@6
  char result; // al@10
  char v8; // zf@11
  char v9; // zf@15

  v2 = (int)this;
  v1 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(v2 + 8);
    if ( v3 )
      break;
    *(_DWORD *)(v2 + 8) = 0;
    sub_1002BBBF(v2, dwSpinCount);
  }
  v4 = v3 - 1;
  if ( v4 )
  {
    v5 = v4 - 1;
    if ( v5 )
    {
      v6 = v5 - 1;
      if ( !v6 )
      {
        *(_DWORD *)(v2 + 8) = 0;
        sub_1002BBBF(v2, dwSpinCount);
        return 0;
      }
      if ( v6 != 1 )
        return 0;
    }
    else
    {
      v8 = *(_DWORD *)(v2 + 4)-- == 1;
      if ( v8 )
        *(_DWORD *)(v2 + 8) = 3;
      v1 = 1;
    }
    __asm { pause }
    result = v1;
  }
  else
  {
    __asm { pause }
    v9 = *(_DWORD *)v2-- == 1;
    if ( v9 )
      *(_DWORD *)(v2 + 8) = 3 - (*(_DWORD *)(v2 + 4) != 0);
    result = 1;
  }
  return result;
}

//----- (1002BC93) --------------------------------------------------------
int __thiscall sub_1002BC93(int this, int a2)
{
  int result; // eax@1
  int v3; // esi@1
  char v4; // zf@1

  v3 = this;
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  v4 = *(_DWORD *)(this + 4) == 0;
  result = *(_DWORD *)a2;
  *(_DWORD *)this = *(_DWORD *)a2;
  if ( v4 )
  {
    _EDX = this;
    _ECX = this + 28;
    result = a2;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 != a2 )
    {
      sub_1002B8F3(a2);
      *(_DWORD *)(v3 + 8) = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(v3 + 4) = *(_DWORD *)(a2 + 4);
      result = *(_DWORD *)a2;
      *(_DWORD *)v3 = *(_DWORD *)a2;
    }
  }
  *(_DWORD *)(v3 + 24) = v3;
  return result;
}

//----- (1002BCE2) --------------------------------------------------------
char __thiscall sub_1002BCE2(void *_ECX)
{
  _EDX = -1;
  __asm { lock cmpxchg [ecx], edx }
  _EDX = (int)((char *)_ECX + 4);
  _ECX = 1;
  __asm { lock xadd [edx], ecx }
  return 1;
}

//----- (1002BD66) --------------------------------------------------------
DWORD __cdecl sub_1002BD66()
{
  return dwSpinCount;
}

//----- (1002BD6C) --------------------------------------------------------
int __cdecl sub_1002BD6C(int a1, int a2, int a3)
{
  signed int v3; // esi@1
  DWORD v4; // ecx@2
  int result; // eax@8
  DWORD v6; // [sp-4h] [bp-Ch]@4

  v3 = 10;
LABEL_7:
  v4 = 0;
  while ( 1 )
  {
    result = a3 & *(_DWORD *)a1;
    if ( result == a2 )
      return result;
    __asm { pause }
    ++v4;
    if ( v4 >= dwSpinCount )
    {
      if ( v3 <= 0 )
      {
        v6 = 1;
      }
      else
      {
        --v3;
        v6 = 0;
      }
      Sleep(v6);
      goto LABEL_7;
    }
  }
}

//----- (1002BDA5) --------------------------------------------------------
int __thiscall sub_1002BDA5(void *this)
{
  int v2; // esi@1
  char Parameter; // [sp+4h] [bp-18h]@1

  v2 = (int)this;
  sub_1002B434(&Parameter, 0xFFFFFFFFu);
  sub_1002B9BF(v2, (int)&Parameter, 0);
  return sub_1002BC93(v2, (int)&Parameter);
}

//----- (1002BDD3) --------------------------------------------------------
char __usercall sub_1002BDD3<al>(int a1<ecx>, int a2<ebx>)
{
  int v2; // edi@1
  int v3; // esi@2
  int v4; // eax@3
  int v7; // eax@6
  int v15; // ecx@13
  int v16; // edi@13
  int v18; // ecx@13
  int v20; // ebx@17
  int Parameter; // [sp+8h] [bp-24h]@1
  char v25; // [sp+20h] [bp-Ch]@13

  v2 = a1;
  sub_1002B434(&Parameter, 0xFFFFFFFFu);
  if ( Parameter == *(_DWORD *)v2 )
  {
    sub_1002FF4B((int)&v25, (unsigned int)"Lock already taken as a writer");
    sub_100355DB((int)&v25, (int)&unk_1006BD80);
    __asm { int     3               ; Trap to Debugger }
    v16 = v18;
    v15 = *(_DWORD *)(v18 + 24);
    *(_DWORD *)v16 = 0;
    _ESI = *(_DWORD *)(v15 + 4);
    *(_DWORD *)(v16 + 24) = _ESI;
    if ( _ESI )
      goto LABEL_24;
    _EDX = v16 + 28;
    LOBYTE(v7) = v15;
    __asm { lock cmpxchg [edx], esi }
    if ( v15 != v15 )
    {
      v7 = sub_1002B8F3(v15);
      _ESI = v7;
      *(_DWORD *)(v16 + 24) = v7;
      if ( v7 )
      {
LABEL_24:
        do
        {
          LOBYTE(v7) = sub_1002B84F((void *)_ESI);
          if ( (_BYTE)v7 )
            break;
          v20 = _ESI;
          _ESI = *(_DWORD *)(_ESI + 4);
          *(_DWORD *)(v16 + 24) = _ESI;
          if ( !_ESI )
          {
            _EDX = 0;
            _ECX = v16 + 28;
            __asm { lock cmpxchg [ecx], edx }
            if ( v20 != v20 )
            {
              _ESI = sub_1002B8F3(v20);
              *(_DWORD *)(v16 + 24) = _ESI;
            }
          }
          LOBYTE(v7) = sub_1002B794(v20);
        }
        while ( _ESI );
      }
    }
  }
  else
  {
    v3 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v2 + 24) = &Parameter;
    if ( v3 )
    {
      sub_1002B872(&Parameter, v3);
    }
    else
    {
      _EDX = v2 + 36;
      v4 = *(_DWORD *)(v2 + 36);
      do
      {
        _ECX = v4 | 4;
        __asm { lock cmpxchg [edx], ecx }
      }
      while ( v4 | 4 );
      if ( !(v4 & 3) )
      {
        v7 = sub_1002BB1C((void *)v2);
        if ( (int *)v7 == &Parameter )
        {
          *(_DWORD *)(v7 + 8) &= 0xFFFFFFFEu;
          return v7;
        }
        sub_1002B84F((void *)v7);
      }
    }
    LOBYTE(v7) = sub_1002B6EC(&Parameter, a2, 0);
    if ( v3 )
    {
      _EDX = 8;
      _EAX = v2 + 36;
      __asm { lock xadd [eax], edx }
      LOBYTE(v7) = sub_1002B84F((void *)v3);
    }
  }
  return v7;
}

//----- (1002BEFE) --------------------------------------------------------
int __thiscall sub_1002BEFE(int this, int a2, char a3, char a4)
{
  signed int i; // ecx@1
  int v5; // edi@1
  int v6; // esi@1

  v5 = this;
  v6 = sub_1002C06C(this);
  for ( i = 3; i; --i )
    v6 += 4;
  *(_DWORD *)v5 = off_100619CC;
  *(_DWORD *)(v5 + 12) = 0;
  *(_DWORD *)(v5 + 16) = 0;
  *(_DWORD *)(v5 + 20) = 0;
  *(_DWORD *)(v5 + 24) = a2 + (a4 != 0);
  *(_DWORD *)(v5 + 32) = 0;
  *(_BYTE *)(v5 + 40) = a3;
  *(_DWORD *)(v5 + 36) = 0;
  *(_BYTE *)(v5 + 41) = 0;
  return v5;
}
// 100619CC: using guessed type int (*off_100619CC[5])();

//----- (1002BF47) --------------------------------------------------------
#error "1002BFE8: call analysis failed (funcsize=57)"

//----- (1002BFF0) --------------------------------------------------------
int __thiscall sub_1002BFF0(int this)
{
  signed int v1; // ecx@1
  int v2; // edi@1
  int v3; // esi@1
  int v4; // eax@1

  v2 = this;
  v4 = sub_1002C06C(this);
  v1 = 3;
  v3 = v4;
  while ( v1 )
  {
    v3 += 4;
    --v1;
  }
  *(_DWORD *)v2 = &off_100619B4;
  return v2;
}
// 100619B4: using guessed type int (__stdcall *off_100619B4)(int, int);

//----- (1002C00B) --------------------------------------------------------
int __thiscall sub_1002C00B(int this, int a2, char a3, char a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@1

  v5 = this;
  v7 = sub_1002BEFE(this, a2, a3, a4);
  v4 = 11;
  *(_DWORD *)v5 = &off_100619E8;
  v6 = v7;
  *(_DWORD *)(v5 + 28) = a2;
  while ( v4 )
  {
    v6 += 4;
    --v4;
  }
  return v5;
}
// 100619E8: using guessed type int (__stdcall *off_100619E8)(int, int);

//----- (1002C03B) --------------------------------------------------------
int __thiscall sub_1002C03B(int this, int a2, char a3, char a4)
{
  signed int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // eax@1

  v5 = this;
  v7 = sub_1002BEFE(this, a2, a3, a4);
  v4 = 11;
  v6 = v7;
  while ( v4 )
  {
    v6 += 4;
    --v4;
  }
  *(_DWORD *)v5 = &off_10061A04;
  *(_DWORD *)(v5 + 28) = 1;
  return v5;
}
// 10061A04: using guessed type int (__stdcall *off_10061A04)(int, int);

//----- (1002C06C) --------------------------------------------------------
int __thiscall sub_1002C06C(int this)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = off_1006199C;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 4) = sub_1003116B();
  return v2;
}
// 1003116B: using guessed type int sub_1003116B(void);
// 1006199C: using guessed type int (*off_1006199C[5])();

//----- (1002C08C) --------------------------------------------------------
int __thiscall sub_1002C08C(int this)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = 0;
  sub_1002B5CC(this + 8);
  return v2;
}

//----- (1002C0B5) --------------------------------------------------------
unsigned int __thiscall sub_1002C0B5(void *this)
{
  void *i; // esi@1
  unsigned int result; // eax@3
  char v3; // cf@3

  for ( i = this; ; sub_1002C2AC(*((_DWORD *)i + 4)) )
  {
    result = *((_DWORD *)i + 5);
    v3 = result < *((_DWORD *)i + 6);
    ++*((_DWORD *)i + 5);
    if ( !v3 )
      break;
  }
  return result;
}

//----- (1002C0CF) --------------------------------------------------------
int __usercall sub_1002C0CF<eax>(int a1<ebp>)
{
  int v1; // edi@1
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // ecx@3
  int v5; // ecx@6
  int v6; // esi@7
  int v8; // [sp-Ch] [bp-Ch]@8
  signed int v9; // [sp-4h] [bp-4h]@1

  v9 = 8;
  sub_10035668();
  v1 = v3;
  *(_DWORD *)(a1 - 20) = v3;
  *(_DWORD *)(a1 - 4) = 0;
  sub_1002BB04(v3 + 8);
  v2 = *(_DWORD *)v1;
  if ( *(_DWORD *)v1 > 1u )
  {
    for ( ; v2; v2 = *(_DWORD *)(a1 - 16) )
    {
      v4 = *(_DWORD *)(v2 + 4);
      *(_DWORD *)(a1 - 16) = *(_DWORD *)v2;
      if ( (unsigned __int8)(**(int (__cdecl ***)(_DWORD, _DWORD, _DWORD))v4)(0, v2, v9) )
        (*(void (**)(void))(**(_DWORD **)(v2 + 4) + 8))();
    }
  }
  v5 = *(_DWORD *)(v1 + 4);
  if ( v5 )
  {
    do
    {
      v6 = *(_DWORD *)v5;
      (*(void (**)(void))(**(_DWORD **)(v5 + 4) + 8))();
      v5 = v6;
    }
    while ( v6 );
  }
  *(_DWORD *)(a1 - 4) = -1;
  nullsub_2(v1 + 8);
  return sub_10035636(v8);
}
// 1002B6E4: using guessed type int __thiscall nullsub_2(_DWORD);
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002C144) --------------------------------------------------------
void *__userpurge sub_1002C144<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1
  int v4; // ST00_4@1

  v3 = (void *)a1;
  v4 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = &off_10061A20;
  sub_1002CAA7(a2, v4);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10061A20: using guessed type int (__stdcall *off_10061A20)(char);

//----- (1002C173) --------------------------------------------------------
int __stdcall sub_1002C173(int a1, int a2, int a3)
{
  char v3; // bl@1
  int v11; // ecx@2
  int result; // eax@4

  v3 = 0;
  _ECX = a2 + 20;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  if ( _EAX == 0 )
  {
    v11 = *(_DWORD *)(a2 + 4);
    v3 = 1;
    *(_BYTE *)(a2 + 41) = 1;
    if ( v11 )
    {
      *(_DWORD *)(a2 + 12) = 0;
      (*(void (**)(void))(*(_DWORD *)v11 + 12))();
    }
  }
  result = sub_1002C2AC(a2);
  if ( v3 )
    result = sub_10034B51(a1, a3);
  return result;
}

//----- (1002C1C0) --------------------------------------------------------
int __stdcall sub_1002C1C0(int a1, int a2)
{
  int v9; // edi@2
  void *v10; // ST04_4@2
  int v11; // eax@2

  _ECX = a1 + 20;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  if ( _EAX == 0 )
  {
    v9 = *(_DWORD *)(a1 + 4);
    v10 = *(void **)(a1 + 16);
    v11 = sub_1002C20E();
    sub_1003B587((HANDLE)v11, v10, 0);
    *(_BYTE *)(a1 + 41) = 1;
    if ( v9 )
    {
      *(_DWORD *)(a1 + 12) = 0;
      (*(void (__thiscall **)(int))(*(_DWORD *)v9 + 12))(v9);
    }
  }
  return sub_1002C2AC(a1);
}

//----- (1002C20E) --------------------------------------------------------
int __cdecl sub_1002C20E()
{
  char v0; // zf@2
  int (__stdcall **v6)(char); // [sp+14h] [bp-10h]@9
  int v7; // [sp+20h] [bp-4h]@9

  if ( !dword_10076380 )
  {
    _ECX = 1;
    _EDI = &dword_1007637C;
    __asm { lock cmpxchg [edi], ecx }
    dword_10076380 = (int)CreateTimerQueue();
    v0 = dword_10076380 == 0;
    if ( !dword_10076380 )
    {
      dword_1007637C = 0;
      v0 = dword_10076380 == 0;
    }
    if ( v0 )
    {
      v7 = (int)"bad allocation";
      sub_1002AEC9((int)&v6, (int)&v7, 1);
      v6 = &off_100602D4;
      sub_100355DB((int)&v6, (int)&unk_1006BAB0);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1002C2AC);
    }
  }
  return dword_10076380;
}
// 100602D4: using guessed type int (__stdcall *off_100602D4)(char);
// 1007637C: using guessed type int dword_1007637C;
// 10076380: using guessed type int dword_10076380;

//----- (1002C2AC) --------------------------------------------------------
int __thiscall sub_1002C2AC(int this)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = *(_DWORD *)(this + 24);
  _EAX = this + 36;
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  result = v2 + 1;
  if ( _EDX + 1 == v2 + 1 )
    result = sub_10030383((LPVOID)this);
  return result;
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (1002C2CB) --------------------------------------------------------
char __thiscall sub_1002C2CB(int this)
{
  int v1; // edx@1
  int v3; // edi@1
  int v4; // esi@1
  char result; // al@5

  v3 = this;
  v4 = *(_DWORD *)(this + 28);
  _EBX = this + 32;
  v1 = *(_DWORD *)(this + 32);
  if ( v1 == v4 )
    goto LABEL_9;
  do
  {
    _ECX = v1 - 1;
    __asm { lock cmpxchg [ebx], ecx }
  }
  while ( v1 != v1 && v1 != v4 );
  if ( v1 == v4 )
  {
LABEL_9:
    sub_1002C2AC(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1002C304) --------------------------------------------------------
char __thiscall sub_1002C304(int this, int a2, int a3)
{
  if ( *(_DWORD *)(*(_DWORD *)(a3 + 4) + 8) == 2 )
  {
    if ( a2 )
      *(_DWORD *)a2 = *(_DWORD *)(this + 4);
    else
      (*(void (**)(void))(**(_DWORD **)(this + 4) + 12))();
  }
  else
  {
    _EDX = 1;
    _ECX = *(_DWORD *)(a3 + 4) + 8;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 )
      *(_DWORD *)a2 = 0;
  }
  return 0;
}

//----- (1002C353) --------------------------------------------------------
char __thiscall sub_1002C353(void *this, int a2, int a3)
{
  int v3; // esi@1
  char result; // al@4

  v3 = (int)this;
  if ( a2 )
    *(_DWORD *)a2 = 0;
  _EAX = (int)((char *)this + 32);
  _ECX = 1;
  __asm { lock xadd [eax], ecx }
  if ( _ECX + 1 == *(_DWORD *)(v3 + 28) )
  {
    (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v3 + 20))(v3, a2, a3);
    sub_1002C2AC(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1002C390) --------------------------------------------------------
char __thiscall sub_1002C390(void *this, int a2, int a3)
{
  int v3; // esi@1

  v3 = (int)this;
  if ( a2 )
    *(_DWORD *)a2 = 0;
  _EAX = (int)((char *)this + 32);
  _ECX = 1;
  __asm { lock xadd [eax], ecx }
  if ( _ECX + 1 == *(_DWORD *)(v3 + 28) )
    (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v3 + 20))(v3, a2, a3);
  sub_1002C2AC(v3);
  return 0;
}

//----- (1002C3C9) --------------------------------------------------------
int __thiscall sub_1002C3C9(void *this)
{
  int result; // eax@1
  unsigned int v2; // edi@1
  unsigned int v6; // esi@6

  _ESI = this;
  v2 = *(_DWORD *)this;
  _EDX = 1;
  result = *(_DWORD *)this;
  __asm { lock cmpxchg [esi], edx }
  while ( result != v2 )
  {
    v2 = result;
    _ECX = 1;
    __asm { lock cmpxchg [esi], ecx }
  }
  if ( v2 > 1 )
  {
    if ( v2 )
    {
      do
      {
        v6 = *(_DWORD *)v2;
        result = (*(int (**)(void))(**(_DWORD **)(v2 + 4) + 12))();
        v2 = v6;
      }
      while ( v6 );
    }
  }
  return result;
}

//----- (1002C403) --------------------------------------------------------
int __thiscall sub_1002C403(int this, int a2, int a3)
{
  int v3; // ebx@1
  int v5; // esi@1
  int result; // eax@2
  char v13; // zf@3
  void *v14; // ST04_4@6
  int v15; // eax@6

  v5 = this;
  v3 = *(_DWORD *)(this + 4);
  _EDI = 1;
  if ( !*(_BYTE *)(this + 40) )
    goto LABEL_17;
  result = this + 20;
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  if ( _EDX == 0 )
  {
LABEL_17:
    v13 = *(_DWORD *)(this + 16) == 0;
    *(_DWORD *)(this + 12) = a3;
    if ( !v13 )
    {
      if ( sub_1003D695() < 3 )
      {
        v14 = *(void **)(v5 + 16);
        v15 = sub_1002C20E();
        sub_1003B587((HANDLE)v15, v14, (HANDLE)0xFFFFFFFF);
      }
      else
      {
        sub_10034927(*(_DWORD *)(v5 + 16));
      }
      if ( *(_DWORD *)(v5 + 20) == 1 )
        sub_1002C2AC(v5);
    }
    if ( *(_DWORD *)(*(_DWORD *)(a3 + 4) + 8) == 2 )
    {
      result = a2;
      if ( a2 )
        *(_DWORD *)a2 = v3;
      else
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 12))(v3);
    }
    else
    {
      _ECX = *(_DWORD *)(a3 + 4) + 8;
      __asm { lock cmpxchg [ecx], edi }
      result = a2;
      if ( a2 )
        *(_DWORD *)a2 = 0;
    }
  }
  return result;
}
// 1003D695: using guessed type int sub_1003D695(void);

//----- (1002C4A7) --------------------------------------------------------
int __cdecl sub_1002C4A7(int a1, char a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v4; // eax@2
  int v5; // ebx@2
  char v6; // al@3

  v3 = a1;
  v2 = 0;
  if ( a1 )
  {
    do
    {
      v5 = *(_DWORD *)v3;
      v4 = **(_DWORD **)(v3 + 4);
      if ( a2 )
        v6 = (*(int (**)(void))(v4 + 12))();
      else
        v6 = (*(int (**)(void))(v4 + 16))();
      if ( v6 )
      {
        *(_DWORD *)v3 = v2;
        v2 = v3;
      }
      v3 = v5;
    }
    while ( v5 );
  }
  return v2;
}

//----- (1002C4E0) --------------------------------------------------------
char __thiscall sub_1002C4E0(void *this)
{
  if ( *((_DWORD *)this + 8) >= *((_DWORD *)this + 7) )
  {
    (*(void (**)(void))(*(_DWORD *)this + 4))();
    return 0;
  }
  if ( *((_BYTE *)this + 41) )
  {
    (*(void (**)(void))(*(_DWORD *)this + 8))();
    return 0;
  }
  return 1;
}

//----- (1002C500) --------------------------------------------------------
char __cdecl sub_1002C500()
{
  return 1;
}

//----- (1002C503) --------------------------------------------------------
char __thiscall sub_1002C503(int this)
{
  int v1; // esi@1
  char result; // al@4
  char v3; // [sp+4h] [bp-4h]@2

  v1 = this;
  if ( *(_BYTE *)(this + 41) )
  {
    if ( (unsigned __int8)(**(int (__stdcall ***)(char *, _DWORD))this)(&v3, 0) )
      (*(void (__thiscall **)(int))(*(_DWORD *)v1 + 8))(v1);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1002C530) --------------------------------------------------------
char __thiscall sub_1002C530(int this)
{
  char result; // al@3
  int v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  if ( *(_DWORD *)(this + 32) >= *(_DWORD *)(this + 28) || *(_BYTE *)(this + 41) )
  {
    (**(void (__stdcall ***)(int *, _DWORD, int))this)(&v2, 0, v2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1002C5B4) --------------------------------------------------------
int __usercall sub_1002C5B4<eax>(int a1<ebp>)
{
  int v1; // edx@1
  int j; // ebx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // ecx@1
  int *v6; // eax@1
  int i; // eax@2
  int v8; // ecx@2
  int v9; // ecx@4
  int v10; // eax@5
  int v11; // ecx@11
  int v12; // ecx@12
  int v13; // eax@13
  signed int v15; // [sp-4h] [bp-4h]@1

  v15 = 56;
  sub_1003569B();
  *(_DWORD *)(a1 - 20) = v5;
  j = 0;
  v4 = 0;
  *(_DWORD *)(a1 - 40) = &off_10061A20;
  *(_DWORD *)(a1 - 36) = 0;
  *(_DWORD *)(a1 - 32) = 0;
  *(_DWORD *)(a1 - 4) = 0;
  sub_1002B62D(a1, v5 + 8);
  v6 = *(int **)(a1 - 20);
  *(_BYTE *)(a1 - 4) = 1;
  v3 = *v6;
  *v6 = 1;
  if ( (unsigned int)v3 > 1 )
  {
    v8 = 0;
    for ( i = v3; i; ++v8 )
      i = *(_DWORD *)i;
    v9 = 4 * v8 + 8;
    if ( (unsigned int)v9 > 0x400 )
    {
      v10 = sub_10030910(v1, v9, 0, v3, v9);
      if ( !v10 )
        goto LABEL_10;
      *(_DWORD *)v10 = 56797;
    }
    else
    {
      sub_1003F590(v9, v9, v15);
      v10 = (int)&v15;
      if ( !&v15 )
        goto LABEL_10;
      v15 = 52428;
    }
    v10 += 8;
LABEL_10:
    v4 = 0;
    for ( j = sub_1002D877(a1 - 40, v10); v3; v3 = *(_DWORD *)(a1 - 24) )
    {
      v11 = *(_DWORD *)(v3 + 4);
      *(_DWORD *)(a1 - 24) = *(_DWORD *)v3;
      if ( (unsigned __int8)(**(int (__stdcall ***)(_DWORD, _DWORD))v11)(a1 - 28, v3) )
      {
        v12 = *(_DWORD *)(a1 - 20);
        *(_DWORD *)v3 = *(_DWORD *)(v12 + 4);
        *(_DWORD *)(v12 + 4) = v3;
      }
      v13 = *(_DWORD *)(a1 - 28);
      if ( v13 )
        *(_DWORD *)(j + 4 * v4++) = v13;
    }
  }
  *(_BYTE *)(a1 - 4) = 0;
  sub_1002B6D6();
  while ( v4 )
  {
    --v4;
    (*(void (**)(void))(**(_DWORD **)(j + 4 * v4) + 12))();
  }
  v15 = *(_DWORD *)(a1 - 36);
  sub_1002CAA7(j, v15);
  return sub_1003564A(v15);
}
// 1003564A: using guessed type int __thiscall sub_1003564A(_DWORD);
// 10061A20: using guessed type int (__stdcall *off_10061A20)(char);

//----- (1002C6B5) --------------------------------------------------------
int __userpurge sub_1002C6B5<eax>(int a1<ebp>, int ebx0<ebx>, int a3<edi>, int a2)
{
  int v4; // eax@1
  int *v5; // ecx@1
  int *v6; // esi@1

  sub_10035668();
  v6 = v5;
  v4 = *(_DWORD *)(a1 + 8);
  if ( v4 == -1 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 - 44) = 0;
    *(_DWORD *)(a1 - 40) = sub_10034C15;
    while ( *v6 != 1 )
    {
      if ( !sub_1002BC26((void *)(a1 - 52)) )
      {
        sub_1002BFF0(a1 - 36);
        *(_DWORD *)(a1 - 20) = a1 - 36;
        sub_1002B62D(a1, (int)(v6 + 2));
        *(_DWORD *)(a1 - 4) = 0;
        if ( *v6 == 1 )
        {
          *(_BYTE *)(a1 + 8) = 1;
        }
        else
        {
          *(_DWORD *)(a1 - 24) = sub_1002C4A7(*v6, 1);
          *v6 = a1 - 24;
        }
        *(_DWORD *)(a1 - 4) = -1;
        sub_1002B6D6();
        if ( !*(_BYTE *)(a1 + 8) )
        {
          if ( *(_DWORD *)(a1 - 28) != 1 )
          {
            _ECX = 2;
            _EDX = a1 - 28;
            __asm { lock cmpxchg [edx], ecx }
            sub_1003115F(ebx0, a1, a3);
          }
        }
        return sub_10035636(68);
      }
    }
  }
  else
  {
    if ( v4 )
    {
      *(_DWORD *)(a1 - 16) = v5;
      sub_1002C78A(a1);
    }
  }
  return sub_10035636(68);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002C78A) --------------------------------------------------------
int __usercall sub_1002C78A<eax>(int a1<ebp>)
{
  int v1; // edx@1
  int v2; // eax@2
  int v3; // ebx@4
  DWORD v4; // edi@6
  unsigned int v5; // eax@12
  int v6; // ecx@20
  int v7; // esi@20
  int v8; // eax@21
  int v9; // edx@21
  int v10; // eax@21
  int *v11; // eax@21
  int v12; // eax@22
  int v13; // edx@22
  int v14; // ecx@22
  int v15; // eax@24
  int v16; // ecx@24
  int v17; // eax@27
  int v18; // ecx@27
  int v19; // eax@32
  int v20; // edi@33
  int v21; // edx@34
  int v32; // eax@48
  int v33; // eax@50
  int v34; // [sp-14h] [bp-14h]@43
  int v35; // [sp-Ch] [bp-Ch]@22
  int v36; // [sp-8h] [bp-8h]@2
  signed int v37; // [sp-4h] [bp-4h]@1

  v37 = 156;
  sub_10035668();
  v1 = *(_DWORD *)(a1 + 8);
  if ( !v1 )
  {
    *(_DWORD *)(a1 - 68) = "pEvents";
    sub_1002AEA4(a1 - 128, (int *)(a1 - 68));
    *(_DWORD *)(a1 - 128) = &off_100602FC;
    v36 = (int)&unk_1006D8F4;
    v2 = a1 - 128;
    goto LABEL_3;
  }
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 12);
    if ( !v3 )
      return sub_10035636(v34);
    v4 = *(_DWORD *)(a1 + 20);
    if ( v3 == 1 && (!v4 || v4 == -1) )
    {
      if ( !*(_DWORD *)v1 )
      {
        *(_DWORD *)(a1 - 76) = "pEvents";
        sub_1002AEA4(a1 - 92, (int *)(a1 - 76));
        *(_DWORD *)(a1 - 92) = &off_100602FC;
        v36 = (int)&unk_1006D8F4;
        v2 = a1 - 92;
        goto LABEL_3;
      }
      sub_1002C6B5(a1, v3, v4, *(_DWORD *)(a1 + 20));
      return sub_10035636(v34);
    }
    v5 = 0;
    if ( v3 )
    {
      do
      {
        if ( !*(_DWORD *)(v1 + 4 * v5) )
        {
          *(_DWORD *)(a1 - 80) = "pEvents";
          sub_1002AEA4(a1 - 116, (int *)(a1 - 80));
          *(_DWORD *)(a1 - 116) = &off_100602FC;
          v36 = (int)&unk_1006D8F4;
          v2 = a1 - 116;
          goto LABEL_3;
        }
        ++v5;
      }
      while ( v5 < v3 );
    }
    LOBYTE(v5) = v4 && v4 != -1;
    sub_1002BF47(*(_DWORD *)(a1 + 16), v3, v4 != -1, v5);
    *(_DWORD *)(a1 - 4) = 0;
    v7 = *(_DWORD *)(a1 - 44);
    v6 = 0;
    *(_BYTE *)(a1 - 13) = 0;
    *(_DWORD *)(a1 - 20) = 0;
    if ( !v3 )
      goto LABEL_38;
    while ( 1 )
    {
      v10 = *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * v6);
      *(_DWORD *)(a1 - 28) = v10;
      sub_1002B62D(a1, v10 + 8);
      v11 = *(int **)(a1 - 28);
      v9 = *(_DWORD *)(a1 - 60) + *(_DWORD *)(a1 - 48) + *(_DWORD *)(a1 - 20) * *(_DWORD *)(a1 - 56);
      ++*(_DWORD *)(a1 - 40);
      v8 = *v11;
      *(_BYTE *)(a1 - 4) = 1;
      *(_DWORD *)(a1 - 32) = v9;
      if ( v8 == 1 )
        break;
      v17 = sub_1002C4A7(v8, 1);
      v18 = *(_DWORD *)(a1 - 32);
      *(_DWORD *)v18 = v17;
      **(_DWORD **)(a1 - 28) = v18;
LABEL_28:
      *(_BYTE *)(a1 - 4) = 0;
      sub_1002B6D6();
      v6 = *(_DWORD *)(a1 - 20) + 1;
      *(_DWORD *)(a1 - 20) = v6;
      if ( v6 >= (unsigned int)v3 )
        goto LABEL_37;
    }
    v14 = *(_DWORD *)(v9 + 4);
    v36 = v9;
    v12 = *(_DWORD *)v14;
    v13 = a1 - 24;
    v35 = a1 - 24;
    if ( *(_BYTE *)(a1 + 16) )
    {
      if ( (unsigned __int8)(*(int (__fastcall **)(int, int))v12)(v14, v13) )
      {
        v15 = sub_1002C4A7(*(_DWORD *)(*(_DWORD *)(a1 - 28) + 4), 0);
        v16 = *(_DWORD *)(a1 - 32);
        *(_DWORD *)v16 = v15;
        *(_DWORD *)(*(_DWORD *)(a1 - 28) + 4) = v16;
      }
      if ( *(_DWORD *)(a1 - 24) )
        *(_BYTE *)(a1 - 13) = 1;
      goto LABEL_28;
    }
    (*(void (__fastcall **)(int, int))v12)(v14, v13);
    if ( *(_DWORD *)(a1 - 24) )
      *(_BYTE *)(a1 - 13) = 1;
    v19 = *(_DWORD *)(a1 - 20) + 1;
    *(_DWORD *)(a1 + 8) = v19;
    if ( v19 < (unsigned int)v3 )
    {
      v20 = v19;
      do
      {
        v21 = *(_DWORD *)(a1 - 60) + *(_DWORD *)(a1 - 48) + v20 * *(_DWORD *)(a1 - 56);
        ++*(_DWORD *)(a1 - 40);
        (***(void (__cdecl ****)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(v21 + 4))(a1 - 24, v21, v35, v36, v37);
        ++v20;
      }
      while ( v20 < (unsigned int)v3 );
      v4 = *(_DWORD *)(a1 + 20);
    }
    *(_BYTE *)(a1 - 4) = 0;
    sub_1002B6D6();
LABEL_37:
    if ( *(_BYTE *)(a1 - 13) )
    {
LABEL_42:
      sub_1002C0B5((void *)(a1 - 60));
      return sub_10035636(v34);
    }
LABEL_38:
    _EDX = v7 + 8;
    if ( *(_DWORD *)(v7 + 8) == 1 )
      goto LABEL_42;
    _ECX = 2;
    __asm { lock cmpxchg [edx], ecx }
    if ( !v4 )
    {
      _EAX = v7 + 20;
      _ECX = 1;
      __asm { lock xadd [eax], ecx }
      if ( _ECX == 0 )
      {
        *(_DWORD *)(v7 + 12) &= v4;
        *(_BYTE *)(v7 + 41) = 1;
      }
      else
      {
        sub_1003115F(1, a1, v4);
      }
      goto LABEL_42;
    }
    if ( v4 == -1 || *(_DWORD *)(v7 + 20) )
      goto LABEL_53;
    if ( sub_1003D695() >= 3 )
    {
      v32 = sub_10034AB9(v4, (int)sub_1002C173, v7);
      *(_DWORD *)(v7 + 16) = v32;
      if ( !v32 )
      {
        *(_DWORD *)(a1 - 64) = "bad allocation";
        sub_1002AEC9(a1 - 140, a1 - 64, 1);
        *(_DWORD *)(a1 - 140) = &off_100602D4;
        v2 = a1 - 140;
        goto LABEL_3;
      }
LABEL_52:
      ++*(_DWORD *)(a1 - 40);
LABEL_53:
      sub_1003115F(-1, a1, v4);
      goto LABEL_42;
    }
    v33 = sub_1002C20E();
    if ( CreateTimerQueueTimer(
           (PHANDLE)(v7 + 16),
           (HANDLE)v33,
           (WAITORTIMERCALLBACK)sub_1002C1C0,
           (PVOID)v7,
           v4,
           0,
           0x20u) )
      goto LABEL_52;
    *(_DWORD *)(a1 - 72) = "bad allocation";
    sub_1002AEC9(a1 - 104, a1 - 72, 1);
    *(_DWORD *)(a1 - 104) = &off_100602D4;
    v2 = a1 - 104;
LABEL_3:
    sub_100355DB(v2, v36);
  }
}
// 1002BF47: using guessed type _DWORD __stdcall sub_1002BF47(_DWORD, _DWORD, _DWORD, _DWORD);
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 1003D695: using guessed type int sub_1003D695(void);
// 100602D4: using guessed type int (__stdcall *off_100602D4)(char);
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);

//----- (1002CAA7) --------------------------------------------------------
void __usercall sub_1002CAA7(int a1<ebx>, int a2)
{
  if ( a2 )
  {
    if ( *(_DWORD *)(a2 - 8) == 56797 )
      sub_100309A2(a1, (LPVOID)(a2 - 8));
  }
}

//----- (1002CAC5) --------------------------------------------------------
void __usercall sub_1002CAC5(int a1<ebx>)
{
  void (*v1)(void); // eax@1

  v1 = (void (*)(void))DecodePointer(dword_10077018);
  if ( v1 )
    v1();
  sub_1003F619(a1, 25);
  sub_100392A0(0, 1);
  JUMPOUT(loc_100392BF);
}

//----- (1002CAEF) --------------------------------------------------------
void __usercall sub_1002CAEF(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  *(_DWORD *)a2 = &off_10061A30;
  sub_1003F9B8(a1, a2, a3, a4, a2);
}
// 10061A30: using guessed type int (__stdcall *off_10061A30)(char);

//----- (1002CAFD) --------------------------------------------------------
bool __thiscall sub_1002CAFD(void *this, int a2)
{
  return sub_10039310(a2 + 9, (int)((char *)this + 9)) == 0;
}

//----- (1002CB1B) --------------------------------------------------------
void *__userpurge sub_1002CB1B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, char a5)
{
  void *v5; // esi@1

  v5 = (void *)a2;
  sub_1002CAEF(a1, a2, a3, a4);
  if ( a5 & 1 )
    sub_1002A4AA(v5);
  return v5;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002CB72) --------------------------------------------------------
int __thiscall sub_1002CB72(int this)
{
  int result; // eax@1
  int v2; // esi@1
  int v3; // ecx@2

  v2 = this;
  result = sub_1003491A(*(_DWORD *)(this + 4));
  if ( result )
  {
    v3 = *(_DWORD *)result;
    --*(_DWORD *)v2;
    *(_DWORD *)(v2 + 4) = v3;
  }
  return result;
}

//----- (1002CB8B) --------------------------------------------------------
int __usercall sub_1002CB8B<eax>(int a1<ebx>, int a2<edi>, unsigned int a3)
{
  int ebp0; // ebp@0
  LPVOID v4; // eax@2
  int v6; // eax@3
  int v7; // edx@3
  int v8; // ecx@3
  int v9; // ebx@3
  int v10; // edi@3
  int v11; // esi@3
  int v12; // ecx@3
  int v13; // ST00_4@3
  int v14; // esi@4
  int (__stdcall **v15)(char); // [sp+0h] [bp-Ch]@3

  if ( a3 <= 0x7FFFFFFF )
  {
    v4 = sub_1002B772(a1, ebp0, a2);
    return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v4 + 40))(v4);
  }
  a3 = (unsigned int)"bad allocation";
  sub_1002AEC9((int)&v15, (int)&a3, 1);
  v15 = &off_100602D4;
  sub_100355DB((int)&v15, (int)&unk_1006BAB0);
  __asm { int     3               ; Trap to Debugger }
  v11 = a3 + 4;
  v9 = v12;
  v6 = sub_1002CCA1(a3 + 4);
  v10 = v6;
  v8 = v13;
  if ( v6 == -1 )
    goto LABEL_6;
  v14 = sub_1002CB72(v9 + 4 + 8 * v6);
  if ( !v14 )
  {
    v11 = dword_10061A38[v10];
LABEL_6:
    v14 = sub_1002965B(v7, v8, v9, v10, v11);
  }
  *(_DWORD *)v14 = sub_1003491A(v10);
  return v14 + 4;
}
// 100602D4: using guessed type int (__stdcall *off_100602D4)(char);
// 10061A38: using guessed type int dword_10061A38[];

//----- (1002CC26) --------------------------------------------------------
char __thiscall sub_1002CC26(int this, int a2)
{
  int v2; // esi@1
  char result; // al@2
  int v4; // eax@2

  v2 = this;
  if ( *(_DWORD *)this >= 32 )
  {
    result = 0;
  }
  else
  {
    *(_DWORD *)a2 = *(_DWORD *)(this + 4);
    v4 = sub_1003491A(a2);
    ++*(_DWORD *)v2;
    *(_DWORD *)(v2 + 4) = v4;
    result = 1;
  }
  return result;
}

//----- (1002CC50) --------------------------------------------------------
void __usercall sub_1002CC50(int a1<ebx>, int a2<edi>, int a3)
{
  int ebp0; // ebp@0
  LPVOID v4; // eax@2

  if ( a3 )
  {
    v4 = sub_1002B772(a1, ebp0, a2);
    (*(void (__thiscall **)(LPVOID, int))(*(_DWORD *)v4 + 44))(v4, a3);
  }
}

//----- (1002CC6A) --------------------------------------------------------
char __thiscall sub_1002CC6A(void *this, int a2)
{
  int v2; // eax@1
  void *v3; // edi@1
  int v4; // esi@1
  char result; // al@2

  v4 = a2 - 4;
  v3 = this;
  v2 = sub_1003491A(*(_DWORD *)(a2 - 4));
  if ( v2 == -1 || (result = sub_1002CC26((int)(v3 + 8 * v2 + 4), v4), !result) )
    result = sub_10030383((LPVOID)v4);
  return result;
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (1002CCA1) --------------------------------------------------------
int __cdecl sub_1002CCA1(int a1)
{
  int v1; // edx@1
  int result; // eax@2
  signed int v3; // edx@3
  signed int v4; // ecx@5

  v1 = (a1 + 7) & 0xFFFFFFF8;
  if ( (unsigned int)v1 <= 0x1000 )
  {
    v3 = (unsigned int)v1 >> 3;
    if ( v3 > 32 )
    {
      v4 = 5;
      if ( (v3 & 0xFFFFFFE0) > 0 )
      {
        do
          ++v4;
        while ( v3 >> v4 > 0 );
      }
      result = ((~((1 << (v4 - 5)) - 1) & ((1 << (v4 - 5)) - 1 + v3)) >> (v4 - 5)) + 16 * (v4 - 5) - 1;
    }
    else
    {
      result = v3 - 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1002CCF6) --------------------------------------------------------
int __usercall sub_1002CCF6<eax>(int a1<ebx>, int a2)
{
  int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // esi@3
  int v8; // [sp-4h] [bp-Ch]@1

  v5 = a2 + 4;
  v2 = sub_1002CCA1(a2 + 4);
  v4 = v2;
  if ( v2 != -1 )
    v5 = dword_10061A38[v2];
  v7 = sub_1002965B(v3, v8, a1, v2, v5);
  *(_DWORD *)v7 = sub_1003491A(v4);
  return v7 + 4;
}
// 10061A38: using guessed type int dword_10061A38[];

//----- (1002CD2F) --------------------------------------------------------
int __userpurge sub_1002CD2F<eax>(int a1<ebp>, int a2)
{
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // ST00_4@1

  sub_10035668();
  v4 = v3;
  *(_DWORD *)(a1 - 16) = v3;
  *(_DWORD *)v3 = &off_10061930;
  *(_DWORD *)(v3 + 4) = 1;
  v5 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)v3 = &off_10061BE8;
  sub_1002CE95(a1, v5);
  *(_DWORD *)(v4 + 144) = sub_1002D764;
  *(_DWORD *)(v4 + 148) = v4;
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 10061930: using guessed type int (__stdcall *off_10061930)(char);
// 10061BE8: using guessed type int (__stdcall *off_10061BE8)(int);

//----- (1002CD7C) --------------------------------------------------------
int __userpurge sub_1002CD7C<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10061BC4;
  return v4;
}
// 10061BC4: using guessed type int (__stdcall *off_10061BC4)(char);

//----- (1002CD97) --------------------------------------------------------
int __userpurge sub_1002CD97<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // esi@4
  int v9; // esi@4
  LPVOID v10; // eax@4
  int v18; // eax@7
  int v19; // esi@7
  LPVOID v24; // esi@12
  int v26; // eax@14

  sub_10035668();
  v5 = v7;
  *(_DWORD *)(a2 - 16) = v7;
  *(_DWORD *)(v5 + 4) |= 0xFFFFFFFu;
  v4 = 7;
  *(_DWORD *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 16) = 0;
  v6 = v5;
  while ( v4 )
  {
    v6 += 4;
    --v4;
  }
  *(_DWORD *)(v5 + 20) = -2147483648;
  *(_DWORD *)(v5 + 24) = 0;
  *(_DWORD *)(v5 + 56) = 0;
  sub_1002C08C(v5 + 60);
  v9 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(v5 + 100) = *(_DWORD *)(v9 + 100);
  *(_DWORD *)(v5 + 108) = 0;
  *(_DWORD *)(a2 - 4) = 0;
  *(_DWORD *)(v5 + 120) = 0;
  *(_DWORD *)(v5 + 132) = 0;
  *(_DWORD *)(v5 + 136) = 0;
  v10 = sub_1002B772(a1, a2, v5);
  *(_DWORD *)(v5 + 12) = v10;
  *(_DWORD *)v5 = *((_DWORD *)v10 + 13);
  v8 = *(_DWORD *)(v9 + 8);
  *(_DWORD *)(v5 + 8) = v8;
  if ( sub_100097C0(v8) )
  {
    _EAX = v8 + 4;
    _EDX = 1;
    __asm { lock xadd [eax], edx }
  }
  sub_1002D90B(a2);
  sub_1002C5B4(a2);
  if ( *(_BYTE *)(a2 + 12) )
  {
    _EDX = *(_DWORD *)(v5 + 100) + 104;
    _ECX = v5;
    v19 = *(_DWORD *)_EDX;
    *(_DWORD *)(v5 + 104) = *(_DWORD *)_EDX;
    v18 = v19;
    __asm { lock cmpxchg [edx], ecx }
    while ( v18 != v19 )
    {
      *(_DWORD *)(v5 + 104) = v18;
      v19 = v18;
      _EDX = v5;
      _ECX = *(_DWORD *)(v5 + 100) + 104;
      __asm { lock cmpxchg [ecx], edx }
    }
  }
  else
  {
    *(_DWORD *)(v5 + 120) |= 1u;
    *(_DWORD *)(v5 + 104) = 0;
  }
  v24 = sub_10032365();
  if ( !*((_DWORD *)v24 + 8) )
    sub_1002E78D(a1, a2);
  v26 = *(_DWORD *)(*((_DWORD *)v24 + 8) + 64);
  *(_DWORD *)(v5 + 4) &= 0xFFFFFFFu;
  *(_DWORD *)(v5 + 128) = v26;
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002CE95) --------------------------------------------------------
int __userpurge sub_1002CE95<eax>(int a1<ebp>, int a2)
{
  signed int v2; // ecx@1
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ecx@1
  LPVOID v14; // eax@6
  LPVOID v15; // esi@6
  int v17; // eax@8

  sub_10035668();
  v4 = v6;
  *(_DWORD *)(a1 - 16) = v6;
  *(_DWORD *)(v4 + 4) |= 0xFFFFFFFu;
  v3 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(v6 + 16) = 0;
  *(_DWORD *)(v6 + 24) = 0;
  v2 = 7;
  *(_DWORD *)(v4 + 8) = v3;
  v5 = v4;
  while ( v2 )
  {
    v5 += 4;
    --v2;
  }
  *(_DWORD *)(v4 + 20) = -2147483648;
  *(_DWORD *)(v4 + 56) = 0;
  sub_1002C08C(v4 + 60);
  *(_DWORD *)(v4 + 104) = 0;
  *(_DWORD *)(v4 + 108) = 0;
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)(v4 + 120) = 0;
  *(_DWORD *)(v4 + 132) = 0;
  *(_DWORD *)(v4 + 136) = 0;
  if ( sub_100097C0(v3) )
  {
    _EAX = v3 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v14 = sub_1002B772(v3, a1, v4);
  *(_DWORD *)(v4 + 12) = v14;
  *(_DWORD *)v4 = *((_DWORD *)v14 + 13);
  sub_1002D90B(a1);
  sub_1002C5B4(a1);
  *(_DWORD *)(v4 + 100) = v4;
  v15 = sub_10032365();
  if ( !*((_DWORD *)v15 + 8) )
    sub_1002E78D(v3, a1);
  v17 = *(_DWORD *)(*((_DWORD *)v15 + 8) + 64);
  *(_DWORD *)(v4 + 4) &= 0xFFFFFFFu;
  *(_DWORD *)(v4 + 128) = v17;
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002CF57) --------------------------------------------------------
int __userpurge sub_1002CF57<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10061BDC;
  return v4;
}
// 10061BDC: using guessed type int (__stdcall *off_10061BDC)(char);

//----- (1002CF72) --------------------------------------------------------
int __userpurge sub_1002CF72<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10061BD0;
  return v4;
}
// 10061BD0: using guessed type int (__stdcall *off_10061BD0)(char);

//----- (1002CF9D) --------------------------------------------------------
int __thiscall sub_1002CF9D(int this)
{
  int result; // eax@2

  if ( *(_DWORD *)(this + 8) )
    result = sub_10030383(*(LPVOID *)(this + 8));
  return result;
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (1002CFB7) --------------------------------------------------------
int __usercall sub_1002CFB7<eax>(int a1<ebp>)
{
  char v1; // bl@1
  int v2; // edi@1
  int v3; // ecx@1
  int v4; // ecx@3
  int v5; // esi@4
  void *v6; // esi@5
  int v7; // esi@7

  sub_10035668();
  v2 = v3;
  *(_DWORD *)(a1 - 16) = v3;
  v1 = 0;
  *(_DWORD *)(a1 - 4) = 0;
  if ( !sub_1002D93B(v3) )
  {
    v1 = sub_1002E0B9(v2, v2, 0) == 0;
    if ( *(_DWORD *)(v2 + 100) == v2 )
    {
      v4 = *(_DWORD *)(v2 + 104);
      if ( v4 )
      {
        do
        {
          v5 = *(_DWORD *)(v4 + 104);
          sub_1002DA54(v4, a1);
          v4 = v5;
        }
        while ( v5 );
      }
    }
  }
  v6 = *(void **)(v2 + 108);
  if ( v6 )
  {
    sub_1002CF9D(*(_DWORD *)(v2 + 108));
    sub_1002A4AA(v6);
  }
  v7 = *(_DWORD *)(v2 + 24) & 0xFFFFFFFC;
  if ( *(_DWORD *)(v2 + 24) & 0xFFFFFFFC )
  {
    if ( v7 != 12 )
    {
      sub_1002FDDA(*(_DWORD *)(v2 + 24) & 0xFFFFFFFC);
      sub_1002A4AA((LPVOID)v7);
    }
  }
  if ( sub_100097C0(*(_DWORD *)(v2 + 8)) )
    sub_1000AA50(*(void **)(v2 + 8));
  if ( v1 )
  {
    sub_10030055(a1 - 28);
    sub_100355DB(a1 - 28, (int)&unk_1006C0A0);
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002C0CF(a1);
  return sub_10035636(16);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002D071) --------------------------------------------------------
void *__userpurge sub_1002D071<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1
  int v4; // ST00_4@1

  v3 = (void *)a1;
  v4 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = &off_10061BF4;
  sub_1002CAA7(a2, v4);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10061BF4: using guessed type int (__stdcall *off_10061BF4)(char);

//----- (1002D09A) --------------------------------------------------------
int __userpurge sub_1002D09A<eax>(int a1<ebp>, int a2)
{
  void *v2; // esi@1
  void *v3; // ecx@1
  char v4; // zf@1

  sub_10035668();
  v2 = v3;
  *(_DWORD *)(a1 - 16) = v3;
  *(_DWORD *)(a1 - 4) = 0;
  sub_1002CFB7(a1);
  v4 = (*(_BYTE *)(a1 + 8) & 1) == 0;
  *(_DWORD *)v2 = &off_10061930;
  if ( !v4 )
    sub_1002A4AA(v2);
  return sub_10035636(4);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 10061930: using guessed type int (__stdcall *off_10061930)(char);

//----- (1002D0D4) --------------------------------------------------------
void *__userpurge sub_1002D0D4<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_1002AF18(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002D0F3) --------------------------------------------------------
int __thiscall sub_1002D0F3(void *this, char a2, char a3)
{
  void *v4; // esi@1

  v4 = this;
  sub_1002EFE2(this);
  return sub_1002D1B1((unsigned int *)v4 + 32, (int)&a2, (int)&a3);
}

//----- (1002D116) --------------------------------------------------------
char __thiscall sub_1002D116(unsigned int *this, int a2, int a3)
{
  int v3; // eax@1
  int v4; // esi@1
  int v5; // eax@1
  char result; // al@4

  v4 = (int)this;
  v5 = sub_10032DDF(a2, *this);
  v3 = sub_1002D2B1(v4, a2, v5);
  if ( v3 )
  {
    if ( a3 )
      *(_DWORD *)a3 = *(_DWORD *)(v3 + 8);
    sub_1002A4AA((LPVOID)v3);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002D155) --------------------------------------------------------
int __thiscall sub_1002D155(int this, char a2)
{
  int v2; // eax@1
  int ebp0; // ebp@0
  unsigned int *v4; // edi@1
  int v5; // esi@2
  int v7; // [sp+8h] [bp-4h]@6

  v4 = (unsigned int *)(this + 128);
  v2 = sub_1003249B((unsigned int *)(this + 128), (int)&a2, 0);
  if ( v2 )
    v5 = *(_DWORD *)(v2 + 8);
  else
    v5 = 0;
  if ( v5 )
  {
    if ( (*(_DWORD *)(v5 + 120) >> 1) & 1 )
    {
      v7 = *(_DWORD *)(v5 + 100);
      sub_1002D116(v4, (int)&v7, 0);
      sub_1002CFB7(ebp0);
      sub_1002A4AA((LPVOID)v5);
      v5 = 0;
    }
  }
  return v5;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002D1B1) --------------------------------------------------------
int __thiscall sub_1002D1B1(unsigned int *this, int a2, int a3)
{
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@2
  int v8; // edx@2
  int result; // eax@5

  v6 = (int)this;
  v5 = sub_10032DDF(a2, *this);
  if ( sub_1002D215(v6, a2, v5) )
  {
    result = 0;
  }
  else
  {
    v7 = sub_1002ADB1(v3, v4, v5, a2, 12);
    v8 = v7;
    if ( v7 )
    {
      *(_DWORD *)v7 = 0;
      *(_DWORD *)(v7 + 4) = *(_DWORD *)a2;
      *(_DWORD *)(v7 + 8) = *(_DWORD *)a3;
    }
    else
    {
      v8 = 0;
    }
    result = v8;
    *(_DWORD *)v8 = *(_DWORD *)(*(_DWORD *)(v6 + 8) + 4 * v5);
    *(_DWORD *)(*(_DWORD *)(v6 + 8) + 4 * v5) = v8;
    ++*(_DWORD *)(v6 + 4);
  }
  return result;
}

//----- (1002D215) --------------------------------------------------------
int __thiscall sub_1002D215(int this, int a2, int a3)
{
  int v3; // ecx@1
  int result; // eax@4

  v3 = *(_DWORD *)(*(_DWORD *)(this + 8) + 4 * a3);
  if ( v3 )
  {
    while ( *(_DWORD *)(v3 + 4) != *(_DWORD *)a2 )
    {
      v3 = *(_DWORD *)v3;
      if ( !v3 )
        goto LABEL_4;
    }
    result = v3;
  }
  else
  {
LABEL_4:
    result = 0;
  }
  return result;
}

//----- (1002D23F) --------------------------------------------------------
char __thiscall sub_1002D23F(int this, int a2)
{
  int v2; // ebx@1
  int v4; // edi@4
  signed __int64 v6; // qax@4
  int v7; // esi@4
  void *v8; // ST00_4@4

  v2 = this;
  if ( *(_DWORD *)(this + 4) >= *(_DWORD *)this )
  {
    if ( *(_DWORD *)(this + 4) >= 1024 )
    {
      *(_BYTE *)(this + 12) = 1;
      return 0;
    }
    v4 = *(_DWORD *)this + 8;
    _ECX = 0;
    v6 = 4i64 * (unsigned int)v4;
    __asm { seto    cl }
    v7 = sub_1002965B(SHIDWORD(v6), v6 | -_ECX, v2, v4, v6 | -_ECX);
    sub_10034F00((void *)v7, *(const void **)(v2 + 8), 4 * *(_DWORD *)v2);
    v8 = *(void **)(v2 + 8);
    *(_DWORD *)v2 = v4;
    sub_10030383(v8);
    *(_DWORD *)(v2 + 8) = v7;
  }
  *(_DWORD *)(*(_DWORD *)(v2 + 8) + 4 * *(_DWORD *)(v2 + 4)++) = a2;
  return 1;
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (1002D2B1) --------------------------------------------------------
int __thiscall sub_1002D2B1(int this, int a2, int a3)
{
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  int result; // eax@4

  v5 = this;
  v6 = 0;
  v4 = *(_DWORD *)(this + 8);
  v3 = *(_DWORD *)(v4 + 4 * a3);
  if ( v3 )
  {
    while ( *(_DWORD *)(v3 + 4) != *(_DWORD *)a2 )
    {
      v6 = v3;
      v3 = *(_DWORD *)v3;
      if ( !v3 )
        goto LABEL_4;
    }
    if ( v6 )
      *(_DWORD *)v6 = *(_DWORD *)v3;
    else
      *(_DWORD *)(v4 + 4 * a3) = *(_DWORD *)v3;
    --*(_DWORD *)(v5 + 4);
    result = v3;
  }
  else
  {
LABEL_4:
    result = 0;
  }
  return result;
}

//----- (1002D2F9) --------------------------------------------------------
int __thiscall sub_1002D2F9(int this, char a2)
{
  int v2; // ebx@1
  int ebp0; // ebp@0
  int v4; // esi@1
  int v5; // edi@2
  unsigned int v6; // eax@8
  int v7; // eax@9
  int v8; // eax@11
  int v9; // ecx@11
  int v10; // eax@13
  int result; // eax@25
  int v12; // [sp+Ch] [bp-Ch]@1
  int v13; // [sp+14h] [bp-4h]@1

  v4 = this;
  v2 = *(_DWORD *)(this + 108);
  v13 = (int)sub_10032365();
  v12 = *(_DWORD *)(v4 + 108);
  if ( sub_1002D94E(v4) )
    v5 = 0;
  else
    v5 = *(_DWORD *)(*(_DWORD *)(v4 + 100) + 104);
  if ( v2 && *(_BYTE *)(v2 + 12) )
  {
    sub_1002D426((void *)v4, v13);
    *(_BYTE *)(v2 + 12) = 0;
  }
  else
  {
    while ( *(_DWORD *)(v4 + 132) > 0 )
    {
      v6 = *(_DWORD *)(v4 + 132);
      if ( v6 <= 2 )
      {
        v7 = *(_DWORD *)(v4 + 4 * v6 + 108);
      }
      else
      {
        --*(_DWORD *)(v2 + 4);
        v7 = *(_DWORD *)(*(_DWORD *)(v2 + 8) + 4 * *(_DWORD *)(v2 + 4));
      }
      --*(_DWORD *)(v4 + 132);
      v8 = sub_1002F3D6(v13, v7);
      v9 = v8;
      if ( !v8 )
        break;
      if ( v8 != 1 )
      {
        v10 = *(_DWORD *)(v13 + 156);
        if ( *(_BYTE *)(v13 + 76) )
          ++*(_DWORD *)(v10 + 12);
        else
          ++*(_DWORD *)(v10 + 96);
        *(_DWORD *)(v9 + 8) = 0;
        sub_1002D9AB((void *)v4, v9);
      }
    }
  }
  LOBYTE(v2) = a2;
  while ( 1 )
  {
    if ( a2 || *(_DWORD *)(v4 + 16) > 0 || sub_1002D93B(v4) || v5 )
      sub_1002D54E(*(void **)(v4 + 100), v2, v5, 0, v5);
    sub_1002D7A9(ebp0, v5);
    result = sub_1002D94E(v4) ? 0 : *(_DWORD *)(*(_DWORD *)(v4 + 100) + 104);
    if ( v5 == result )
      break;
    v5 = result;
  }
  *(_DWORD *)(v4 + 132) = 0;
  if ( v12 )
    *(_DWORD *)(v12 + 4) = 0;
  if ( !a2 )
    result = sub_1002DAC5((void *)v4, v5);
  return result;
}

//----- (1002D426) --------------------------------------------------------
int __thiscall sub_1002D426(void *this, int a2)
{
  int result; // eax@1
  LPVOID v3; // eax@2
  int v4; // ecx@2
  char v5; // zf@2
  void *v6; // [sp+0h] [bp-8h]@1
  int v7; // [sp+4h] [bp-4h]@1

  v7 = 0;
  v6 = this;
  result = sub_1002F05E(
             (int (__cdecl *)(_DWORD, _DWORD))sub_1002D74F,
             (int)&v6,
             (int (__cdecl *)(_DWORD, _DWORD))sub_1002E0A0);
  if ( v7 )
  {
    v3 = sub_10032365();
    v5 = *((_BYTE *)v3 + 76) == 0;
    v4 = *((_DWORD *)v3 + 39);
    result = v7;
    if ( v5 )
      *(_DWORD *)(v4 + 96) += v7;
    else
      *(_DWORD *)(v4 + 12) += v7;
  }
  return result;
}

//----- (1002D46E) --------------------------------------------------------
int __usercall sub_1002D46E<eax>(int a1<ebp>, int a2<ebx>, int a3<edi>)
{
  char v3; // bl@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ecx@1
  int v7; // eax@6
  int v8; // edx@8
  int v9; // ecx@8
  int v10; // eax@9

  sub_10035668();
  v5 = v6;
  v4 = (int)sub_1002B772(a2, a1, a3);
  v3 = 0;
  if ( !*(_DWORD *)(v4 + 32) )
    sub_1002E78D(0, a1);
  if ( v4 != *(_DWORD *)(v5 + 12) || *(_DWORD *)(*(_DWORD *)(v4 + 32) + 64) != *(_DWORD *)(v5 + 128) )
  {
    v7 = sub_1002EA23(v4);
    if ( !v7 || *(_DWORD *)(v7 + 100) != v5 )
    {
      if ( !sub_1002D155(v4, v5) )
      {
        v10 = sub_1002ADB1(v8, v9, 0, v4, 144);
        *(_DWORD *)(a1 - 16) = v10;
        *(_DWORD *)(a1 - 4) = 0;
        if ( v10 )
          v3 = sub_1002CD97(0, a1, v5, 1);
        *(_DWORD *)(a1 - 4) = -1;
        sub_1002D0F3((void *)v4, v5, v3);
      }
    }
  }
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002D4FA) --------------------------------------------------------
char __usercall sub_1002D4FA<al>(int a1<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>)
{
  int v4; // esi@1
  char result; // al@3
  int v6; // ecx@4
  int v14; // [sp-4h] [bp-8h]@5

  v4 = a1;
  if ( !*(_DWORD *)(a1 + 12) )
    *(_DWORD *)(a1 + 12) = sub_1002B772(a2, a3, a4);
  result = sub_1003FF73(v4);
  if ( result )
  {
    v6 = *(_DWORD *)(v4 + 12);
    if ( 16 * *(_DWORD *)(v4 + 4) >> 4 < 0 )
    {
      _EAX = v6 + 120;
      _ECX = 1;
      __asm { lock xadd [eax], ecx }
      v14 = 2;
    }
    else
    {
      sub_1002E53F(v6, 16 * *(_DWORD *)(v4 + 4) >> 4);
      v14 = 3;
    }
    sub_1003FF25(v4, v14);
    result = sub_1002E5DE(a3, v4);
  }
  return result;
}

//----- (1002D54E) --------------------------------------------------------
char __userpurge sub_1002D54E<al>(void *this<ecx>, int ebx0<ebx>, int edi0<edi>, int a2, int a3)
{
  char result; // al@1
  int ebp0; // ebp@0
  int v7; // edi@1
  int v8; // esi@1
  int v9; // edi@4
  int v11; // edi@6
  int v13; // [sp+8h] [bp-4h]@12

  v8 = (int)this;
  v7 = sub_1002D46E(ebp0, ebx0, edi0);
  result = sub_1002E066(v8, 1);
  if ( result )
  {
    if ( sub_1002D94E(v7) || v7 == v8 )
    {
      _EBX = v8 + 56;
      do
      {
        while ( 1 )
        {
          v11 = *(_DWORD *)_EBX;
          if ( *(_DWORD *)_EBX != 1 )
          {
            if ( v11 != 5 )
              break;
          }
          v13 = *(_DWORD *)(v8 + 12);
          sub_1002E53F(v13, 16 * *(_DWORD *)(v8 + 4) >> 4);
          if ( v11 == 5 )
            sub_1002D426((void *)v8, v13);
          *(_DWORD *)_EBX = 4;
        }
        _ECX = 3;
        __asm { lock cmpxchg [ebx], ecx }
      }
      while ( v11 );
      v9 = a2;
      sub_1002D6BB(ebp0, a2, 1);
    }
    else
    {
      v9 = a2;
      sub_1002D61A(v8, a2);
    }
    result = sub_1002D5FB(v9, a3);
  }
  return result;
}

//----- (1002D5ED) --------------------------------------------------------
char __usercall sub_1002D5ED<al>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  return sub_1002D54E(*(void **)(a1 + 100), a2, a3, 0, *(_DWORD *)(a1 + 104));
}

//----- (1002D5FB) --------------------------------------------------------
int __stdcall sub_1002D5FB(int a1, int a2)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = a2; i; i = *(_DWORD *)(i + 104) )
    result = sub_1002D61A(i, a1);
  return result;
}

//----- (1002D61A) --------------------------------------------------------
int __thiscall sub_1002D61A(int this, int a2)
{
  char v3; // bl@1
  int ebp0; // ebp@0
  int v5; // esi@1
  int result; // eax@2
  int v8; // [sp+Ch] [bp-10h]@12
  int v9; // [sp+10h] [bp-Ch]@1
  int v10; // [sp+14h] [bp-8h]@14
  int v11; // [sp+18h] [bp-4h]@1

  v3 = 0;
  v5 = *(_DWORD *)(this + 56);
  v11 = this;
  v9 = this + 56;
  _EDX = 0;
  do
  {
    result = v5;
    if ( v5 )
    {
      if ( v5 == 1 || (result = v5 - 5, v5 == 5) )
      {
        _EDX = 9;
        goto LABEL_8;
      }
    }
    else
    {
      _EDX = 3;
    }
    if ( !_EDX )
      return result;
LABEL_8:
    _ECX = v9;
    __asm { lock cmpxchg [ecx], edx }
    _EDX = v5;
  }
  while ( v5 != v5 );
  LOBYTE(v10) = 0;
  if ( v5 == 1 || v5 == 5 )
  {
    v3 = 1;
    LOBYTE(v10) = 1;
    v8 = *(_DWORD *)(v11 + 12);
    sub_1002E53F(v8, 16 * *(_DWORD *)(v11 + 4) >> 4);
    if ( v5 == 5 )
      sub_1002D426((void *)v11, v8);
  }
  result = sub_1002D6BB(ebp0, a2, v10);
  if ( v3 )
  {
    result = v9;
    *(_DWORD *)v9 = 4;
  }
  return result;
}

//----- (1002D6BB) --------------------------------------------------------
int __userpurge sub_1002D6BB<eax>(int a1<ebp>, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // esi@1
  void *v5; // ecx@1
  int v6; // edi@3
  char i; // zf@5

  sub_10035668();
  v4 = (int)v5;
  v3 = (int)((char *)v5 + 28);
  *(_DWORD *)(a1 - 20) = (char *)v5 + 28;
  v5 = (char *)v5 + 32;
  *(_DWORD *)(a1 - 16) = v5;
  sub_1002B95B(v5);
  *(_DWORD *)(a1 - 4) = 0;
  if ( *(_BYTE *)(a1 + 12) )
  {
LABEL_4:
    sub_1002E5DE(a1, v4);
    goto LABEL_5;
  }
  if ( *(_DWORD *)(v4 + 48) > 0 )
  {
    v6 = *(_DWORD *)v3;
    if ( *(_DWORD *)v3 )
      goto LABEL_8;
    goto LABEL_4;
  }
LABEL_5:
  v6 = *(_DWORD *)v3;
  for ( i = *(_DWORD *)v3 == 0; ; i = v6 == *(_DWORD *)v3 )
  {
    if ( i )
      v6 = 0;
    else
LABEL_8:
      v6 = *(_DWORD *)(v6 + 4);
    if ( !v6 )
      break;
    *(_DWORD *)(v6 + 24) = 1;
    sub_1002E53F(v6 - 92, -999);
    sub_1002E5DE(a1, 0);
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002BB6D();
  return sub_10035636(8);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002D743) --------------------------------------------------------
char __usercall sub_1002D743<al>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  return sub_1002D5ED(a4, a2, a3);
}

//----- (1002D74F) --------------------------------------------------------
bool __cdecl sub_1002D74F(int a1, int a2)
{
  return *(_DWORD *)(a1 + 8) == *(_DWORD *)a2;
}

//----- (1002D764) --------------------------------------------------------
int __cdecl sub_1002D764(void *a2)
{
  return sub_1000AA50(a2);
}

//----- (1002D770) --------------------------------------------------------
int __thiscall sub_1002D770(int this)
{
  int v2; // esi@1
  int result; // eax@3

  v2 = this;
  _EDI = this + 20;
  if ( *(_DWORD *)(this + 20) <= -2147483647 )
    sub_1002D8BA(this);
  _EAX = 1;
  __asm { lock xadd [edi], eax }
  result = _EAX + 1;
  if ( !result )
    result = sub_1002C3C9((void *)(v2 + 28));
  return result;
}

//----- (1002D79E) --------------------------------------------------------
int __thiscall sub_1002D79E(void *this)
{
  int result; // eax@2

  if ( this )
    result = (**(int (__stdcall ***)(_DWORD))this)(1);
  return result;
}

//----- (1002D7A9) --------------------------------------------------------
int __userpurge sub_1002D7A9<eax>(int a1<ebp>, int a2)
{
  int v2; // eax@1
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // esi@1
  unsigned int v8; // eax@4
  int v9; // eax@5
  int v10; // edx@10
  signed int v11; // ecx@10
  int v12; // esi@10
  int v13; // ecx@12
  signed int v15; // [sp-4h] [bp-4h]@1

  v15 = 16;
  sub_1003569B();
  v5 = v4;
  v6 = *(_DWORD *)(a1 + 8);
  v2 = v6;
  v7 = 0;
  if ( !v6 )
    goto LABEL_17;
  do
  {
    v2 = *(_DWORD *)(v2 + 104);
    ++v7;
  }
  while ( v2 );
  if ( v7 <= 0 )
  {
LABEL_17:
    sub_1002C6B5(a1, v4, v6, -1);
    return sub_1003564A(v13);
  }
  *(_DWORD *)(a1 - 28) = &off_10061BF4;
  *(_DWORD *)(a1 - 24) = 0;
  *(_DWORD *)(a1 - 20) = 0;
  v8 = 4 * v7 + 12;
  *(_DWORD *)(a1 - 4) = 0;
  if ( v8 > 0x400 )
  {
    v9 = sub_10030910(v3, 0, v4, v6, 4 * v7 + 12);
    if ( v9 )
    {
      *(_DWORD *)v9 = 56797;
      goto LABEL_9;
    }
  }
  else
  {
    sub_1003F590(v8, 0, v15);
    v9 = (int)&v15;
    if ( &v15 )
    {
      v15 = 52428;
LABEL_9:
      v9 += 8;
      goto LABEL_10;
    }
  }
LABEL_10:
  v10 = sub_1002D877(a1 - 28, v9);
  *(_DWORD *)v10 = *(_DWORD *)(v5 + 100) + 60;
  v11 = 1;
  v12 = v7 + 1;
  if ( v12 > 1 )
  {
    do
    {
      *(_DWORD *)(v10 + 4 * v11) = v6 + 60;
      v6 = *(_DWORD *)(v6 + 104);
      ++v11;
    }
    while ( v11 < v12 );
  }
  sub_1002C78A(a1);
  sub_1002CAA7(v5, *(_DWORD *)(a1 - 24));
  return sub_1003564A(v13);
}
// 1003564A: using guessed type int __thiscall sub_1003564A(_DWORD);
// 10061BF4: using guessed type int (__stdcall *off_10061BF4)(char);

//----- (1002D873) --------------------------------------------------------
int __thiscall sub_1002D873(void *this)
{
  return (int)((char *)this + 28);
}

//----- (1002D877) --------------------------------------------------------
int __thiscall sub_1002D877(int this, int a2)
{
  int result; // eax@1
  int (__stdcall **v3)(char); // [sp+0h] [bp-Ch]@3

  result = a2;
  if ( !a2 )
  {
    a2 = (int)"bad allocation";
    sub_1002AEC9((int)&v3, (int)&a2, 1);
    v3 = &off_100602D4;
    sub_100355DB((int)&v3, (int)&unk_1006BAB0);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1002D8BA);
  }
  *(_DWORD *)(this + 4) = a2;
  *(_DWORD *)(this + 8) = 0;
  return result;
}
// 100602D4: using guessed type int (__stdcall *off_100602D4)(char);

//----- (1002D8BA) --------------------------------------------------------
char __thiscall sub_1002D8BA(int this)
{
  int v3; // eax@3

  _ESI = this + 20;
  _EDX = -2147483647;
  __asm { lock cmpxchg [esi], edx }
  if ( this != -28 )
    *(_DWORD *)(this + 28) = 0;
  v3 = *(_DWORD *)_ESI;
  *(_DWORD *)_ESI = 0;
  return v3;
}

//----- (1002D90B) --------------------------------------------------------
int __usercall sub_1002D90B<eax>(int a1<ebp>)
{
  void *v1; // ecx@1
  int v2; // ecx@1
  char v3; // zf@1

  sub_10035668();
  *(_DWORD *)(a1 - 16) = v2;
  *(_DWORD *)(v2 + 48) = 0;
  *(_DWORD *)(v2 + 52) = 0;
  *(_DWORD *)(v2 + 124) = 0;
  v3 = v2 == -28;
  v1 = (void *)(v2 + 28);
  *(_DWORD *)(a1 - 20) = v1;
  *(_DWORD *)(a1 - 4) = 0;
  if ( !v3 )
    sub_1003134A(v1);
  return sub_10035636(8);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002D93B) --------------------------------------------------------
bool __thiscall sub_1002D93B(int this)
{
  return *(_DWORD *)(this + 100) != this && !(*(_DWORD *)(this + 120) & 1);
}

//----- (1002D94E) --------------------------------------------------------
bool __thiscall sub_1002D94E(int this)
{
  return *(_DWORD *)(this + 100) != this && *(_DWORD *)(this + 120) & 1;
}

//----- (1002D961) --------------------------------------------------------
bool __thiscall sub_1002D961(int this)
{
  return *(_DWORD *)(*(_DWORD *)(this + 100) + 52) != 0;
}

//----- (1002D96F) --------------------------------------------------------
int __thiscall sub_1002D96F(int this)
{
  return (*(_DWORD *)(this + 120) >> 1) & 1;
}

//----- (1002D978) --------------------------------------------------------
int __usercall sub_1002D978<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // eax@1
  int v4; // edx@1
  int v5; // ecx@1

  sub_10035668();
  v3 = sub_1002ADB1(v4, v5, a1, a3, 152);
  *(_DWORD *)(a2 - 16) = v3;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v3 )
    sub_1002CD2F(a2, *(_DWORD *)(a2 + 8));
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002D9AB) --------------------------------------------------------
int __thiscall sub_1002D9AB(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1
  int result; // eax@3
  int v5; // ebx@3
  int (__cdecl *v6)(_DWORD); // edi@3

  v3 = this;
  if ( *(_BYTE *)(a2 + 16) )
    sub_1003FA50(a2);
  v6 = (int (__cdecl *)(_DWORD))*((_DWORD *)v3 + 34);
  v5 = *((_DWORD *)v3 + 35);
  result = (int)((char *)v3 + 16);
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  if ( _ECX == 1 )
    result = sub_1002C5B4(ebp0);
  if ( v6 )
    result = v6(v5);
  return result;
}

//----- (1002D9F4) --------------------------------------------------------
#error "1002C5AE: call analysis failed (funcsize=51)"

//----- (1002DA1A) --------------------------------------------------------
int __thiscall sub_1002DA1A(int this)
{
  return *(_DWORD *)(this + 100);
}

//----- (1002DA1E) --------------------------------------------------------
int __thiscall sub_1002DA1E(int this)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = this;
  sub_1003FF9B(*(_DWORD *)(this + 100));
  _ECX = 1073741824;
  result = *(_DWORD *)(v2 + 100) + 52;
  __asm { lock or [eax], ecx }
  return result;
}

//----- (1002DA39) --------------------------------------------------------
int __usercall sub_1002DA39<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  int result; // eax@1
  int v4; // esi@1

  v4 = a1;
  sub_1003FFC6(a2, a3);
  _ECX = -2147483648;
  result = *(_DWORD *)(v4 + 100) + 52;
  __asm { lock or [eax], ecx }
  return result;
}

//----- (1002DA54) --------------------------------------------------------
int __usercall sub_1002DA54<eax>(int a1<ecx>, int a2<ebp>)
{
  int v2; // ecx@1
  void *v4; // esi@1
  int result; // eax@2

  v4 = (void *)a1;
  _EDI = a1 + 120;
  v2 = *(_DWORD *)(a1 + 120);
  if ( v2 & 2 )
  {
LABEL_4:
    sub_1002CFB7(a2);
    result = sub_1002A4AA(v4);
  }
  else
  {
    while ( 1 )
    {
      _EDX = v2 | 2;
      result = v2;
      __asm { lock cmpxchg [edi], edx }
      if ( v2 == v2 )
        break;
      if ( v2 & 2 )
        goto LABEL_4;
    }
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002DA88) --------------------------------------------------------
int __usercall sub_1002DA88<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@2
  int v3; // ST10_4@2

  if ( dword_10076388 )
  {
    v2 = sub_1003491A(dword_10076388);
    ((void (__thiscall *)(int))v2)(v3);
  }
  if ( IsProcessorFeaturePresent(0x17u) )
    __asm { int     29h             ; DOS 2+ internal - FAST PUTCHAR }
  sub_1003A013(a1, a2, 1073741845, 3, 1073741845, 1);
  return sub_10039874(0x40000015u);
}
// 10076388: using guessed type int dword_10076388;

//----- (1002DAC5) --------------------------------------------------------
int __thiscall sub_1002DAC5(void *this, int a2)
{
  int ebp0; // ebp@0
  int v3; // edi@1
  int v4; // esi@1
  LPVOID v5; // eax@2
  int v6; // ecx@2
  int v8; // edx@3
  int result; // eax@14
  int v12; // ecx@23
  char v13; // [sp+Ch] [bp-24h]@25
  int v14; // [sp+14h] [bp-1Ch]@24
  BOOL (__cdecl *v15)(); // [sp+18h] [bp-18h]@24
  char v16; // [sp+1Ch] [bp-14h]@6
  int v17; // [sp+24h] [bp-Ch]@5
  BOOL (__cdecl *v18)(); // [sp+28h] [bp-8h]@5
  int v19; // [sp+2Ch] [bp-4h]@2
  int v20; // [sp+38h] [bp+8h]@2

  v3 = a2;
  v4 = (int)this;
  while ( 2 )
  {
    v5 = sub_10032365();
    v6 = *(_DWORD *)(v4 + 12);
    v20 = (int)v5;
    v19 = *(_DWORD *)(v4 + 12);
    _EBX = v4 + 56;
LABEL_3:
    v8 = *(_DWORD *)_EBX;
    while ( 1 )
    {
      if ( v8 == 9 )
      {
        v17 = 0;
        v18 = sub_10034C15;
        if ( *(_DWORD *)_EBX == 9 )
        {
          do
            sub_100282E0((int)&v16);
          while ( *(_DWORD *)_EBX == 9 );
          v5 = (LPVOID)v20;
          v6 = v19;
        }
        goto LABEL_3;
      }
      if ( v5 != (LPVOID)v6 )
      {
        _ECX = 0;
        __asm { lock cmpxchg [ebx], ecx }
        goto LABEL_13;
      }
      _ECX = 0;
      __asm { lock cmpxchg [ebx], ecx }
      if ( v8 == v8 )
        break;
      v6 = v19;
      v5 = (LPVOID)v20;
    }
    if ( v8 == 4 )
      sub_1002E5AC(v20, 16 * *(_DWORD *)(v4 + 4) >> 4);
    *(_DWORD *)(v4 + 4) |= 0xFFFFFFFu;
LABEL_13:
    if ( *(_DWORD *)(v4 + 100) == v4 )
    {
      while ( v3 )
      {
        if ( !((*(_DWORD *)(v3 + 120) >> 1) & 1) )
          sub_1002DAC5(0);
        v3 = *(_DWORD *)(v3 + 104);
      }
      result = v4 + 52;
      v12 = *(_DWORD *)(v4 + 52);
      *(_DWORD *)(v4 + 52) = 0;
      if ( v12 < 0 )
      {
        v14 &= v3;
        v15 = sub_10034C15;
        while ( *(_DWORD *)(v4 + 24) == 8 )
          sub_100282E0((int)&v13);
        result = sub_10040035(_EBX, ebp0);
      }
    }
    else
    {
      result = sub_1002D93B(v4);
      if ( (_BYTE)result && v3 )
      {
        v4 = *(_DWORD *)(v4 + 100);
        continue;
      }
    }
    return result;
  }
}

//----- (1002DBC0) --------------------------------------------------------
int __userpurge sub_1002DBC0<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // edi@1
  int v8; // esi@1
  LPVOID v9; // eax@1
  int v10; // eax@1
  int v11; // edx@2
  int v12; // eax@4
  int v13; // eax@7
  int v16; // eax@15
  int i; // eax@17
  unsigned int v18; // ecx@22
  int v19; // eax@23
  int v20; // eax@23
  int v21; // eax@24
  int v22; // ecx@26
  int v23; // eax@27
  int v24; // eax@30
  int v27; // eax@34
  int v33; // [sp-8h] [bp-8h]@10

  sub_100356D1();
  v8 = sub_1002D46E(a2, a1, a3);
  *(_DWORD *)(a2 - 24) = v8;
  v9 = sub_10032365();
  v6 = *(_DWORD *)(a2 + 8);
  v7 = (int)v9;
  v10 = *(_DWORD *)(v6 + 104);
  v5 = *(_DWORD *)(v7 + 52);
  *(_DWORD *)(a2 - 36) = v7;
  *(_DWORD *)(a2 - 28) = v10;
  *(_BYTE *)(a2 - 17) = 0;
  *(_DWORD *)v8 = v5;
  if ( v5 )
    v11 = (16 * *(_DWORD *)(v5 + 4) >> 4) + 1;
  else
    v11 = 0;
  *(_DWORD *)(v8 + 4) ^= (v11 ^ *(_DWORD *)(v8 + 4)) & 0xFFFFFFF;
  *(_DWORD *)(v7 + 52) = v8;
  v12 = *(_DWORD *)(v6 + 8);
  *(_DWORD *)(a2 - 32) = 0;
  if ( v12 )
  {
    if ( v12 != 2 )
    {
      if ( v12 != *(_DWORD *)(v7 + 56) )
      {
        v13 = sub_1002B396(v11, v12, 0, (int)sub_1002D743, v6, 1);
        v6 = *(_DWORD *)(a2 + 8);
        *(_DWORD *)(a2 - 32) = v13;
      }
    }
    sub_1002ECFD(v7, *(_DWORD *)(v6 + 8), 16 * *(_DWORD *)(v8 + 4) >> 4);
  }
  *(_DWORD *)(a2 - 4) = 0;
  _EDX = 1;
  _ECX = v8 + 56;
  __asm { lock cmpxchg [ecx], edx }
  while ( *(_DWORD *)(a2 + 12) )
  {
    sub_1002D9F4(v8);
    if ( !*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 8) + 100) + 52)
      && (*(_DWORD *)(v7 + 112) + *(_DWORD *)(v7 + 120) <= 0 || !sub_1002EB38(v7, v8, 0)) )
    {
      (*(void (__cdecl **)(_DWORD))(*(_DWORD *)(a2 + 12) + 4))(*(_DWORD *)(a2 + 12));
      v16 = *(_DWORD *)(a2 + 12);
LABEL_16:
      *(_DWORD *)(v16 + 8) = 0;
      sub_1002D9AB((void *)v8, v16);
      *(_DWORD *)(a2 + 12) = 0;
      break;
    }
    sub_1002FF03(a2 - 64);
    v33 = (int)&unk_1006C110;
    v21 = a2 - 64;
LABEL_10:
    sub_100355DB(v21, v33);
  }
  for ( i = *(_DWORD *)(a2 + 8); ; *(_DWORD *)(a2 - 28) = *(_DWORD *)(i + 104) )
  {
    while ( 1 )
    {
      if ( *(_DWORD *)(v8 + 132) <= 0 )
        goto LABEL_30;
      if ( *(_DWORD *)(*(_DWORD *)(i + 100) + 52)
        || *(_DWORD *)(v7 + 112) + *(_DWORD *)(v7 + 120) > 0 && sub_1002EB38(v7, v8, 0) )
      {
        sub_1002FF03(a2 - 76);
        v33 = (int)&unk_1006C110;
        v21 = a2 - 76;
        goto LABEL_10;
      }
      v18 = *(_DWORD *)(v8 + 132);
      if ( v18 <= 2 )
      {
        v19 = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4 * v18 + 108);
      }
      else
      {
        v20 = *(_DWORD *)(v8 + 108);
        --*(_DWORD *)(v20 + 4);
        v19 = *(_DWORD *)(*(_DWORD *)(v20 + 8) + 4 * *(_DWORD *)(v20 + 4));
      }
      --*(_DWORD *)(v8 + 132);
      v22 = sub_1002F3D6(v7, v19);
      *(_DWORD *)(a2 - 40) = v22;
      *(_DWORD *)(a2 + 12) = v22;
      if ( !v22 )
        break;
      i = *(_DWORD *)(a2 + 8);
      if ( v22 != 1 )
      {
        v27 = *(_DWORD *)(v7 + 156);
        if ( *(_BYTE *)(v7 + 76) )
          ++*(_DWORD *)(v27 + 12);
        else
          ++*(_DWORD *)(v27 + 96);
        (*(void (__cdecl **)(int))(v22 + 4))(v22);
        v16 = *(_DWORD *)(a2 - 40);
        goto LABEL_16;
      }
    }
    v23 = *(_DWORD *)(v8 + 108);
    if ( v23 )
      *(_DWORD *)(v23 + 4) = 0;
    *(_DWORD *)(v8 + 132) = 0;
LABEL_30:
    v24 = *(_DWORD *)(v8 + 108);
    if ( v24 )
    {
      if ( *(_BYTE *)(v24 + 12) )
      {
        *(_BYTE *)(a2 - 17) = 1;
        _EDX = 5;
        _ECX = v8 + 56;
        __asm { lock cmpxchg [ecx], edx }
      }
    }
    sub_1002D7A9(a2, *(_DWORD *)(a2 - 28));
    if ( *(_BYTE *)(a2 - 17) )
    {
      _EDX = 1;
      _ECX = v8 + 56;
      __asm { lock cmpxchg [ecx], edx }
    }
    i = *(_DWORD *)(a2 + 8);
    if ( *(_DWORD *)(a2 - 28) == *(_DWORD *)(i + 104) )
      break;
  }
  *(_DWORD *)(a2 - 4) = -1;
  if ( *(_DWORD *)(i + 8) )
  {
    sub_1002EC3C(v7, *(_DWORD *)(i + 8));
    if ( *(_DWORD *)(a2 - 32) )
    {
      sub_1002B29A(a2, *(_DWORD *)(a2 - 32));
      sub_1000AA50(*(void **)(a2 - 32));
    }
  }
  *(_DWORD *)(v7 + 52) = *(_DWORD *)v8;
  if ( *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 8) + 100) + 52) )
  {
    sub_1002D2F9(v8, 0);
    if ( *(_DWORD *)(v7 + 112) + *(_DWORD *)(v7 + 120) > 0
      && sub_1002EB38(v7, v8, *(_DWORD *)(*(_DWORD *)(a2 + 8) + 8) != 0) )
    {
      sub_1002FF03(a2 - 100);
      v21 = a2 - 100;
      goto LABEL_10;
    }
  }
  else
  {
    sub_1002DAC5((void *)v8, *(_DWORD *)(a2 - 28));
    if ( *(_DWORD *)(v7 + 112) + *(_DWORD *)(v7 + 120) > 0
      && sub_1002EB38(v7, v8, *(_DWORD *)(*(_DWORD *)(a2 + 8) + 8) != 0) )
    {
      sub_1002FF03(a2 - 112);
      v21 = a2 - 112;
      goto LABEL_10;
    }
  }
  return sub_10035636(v33);
}
// 1002D9F4: using guessed type int __thiscall sub_1002D9F4(_DWORD);
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002DF80) --------------------------------------------------------
int __userpurge sub_1002DF80<eax>(int a1<ebp>, int a2)
{
  int v2; // edi@1
  int v3; // edx@3
  int v4; // ecx@3
  int v5; // esi@3
  int v6; // edi@4
  int v7; // eax@5
  int v8; // eax@9
  int v9; // eax@9
  int v11; // eax@12

  sub_100356D1();
  v2 = *(_DWORD *)(a1 + 8);
  if ( *(_DWORD *)(v2 + 8) )
  {
    sub_1002FFA7(a1 - 32);
    sub_100355DB(a1 - 32, (int)&unk_1006C0D8);
  }
  *(_DWORD *)(a1 - 4) = 0;
  v5 = sub_1002D46E(a1, 0, v2);
  *(_DWORD *)(v2 + 8) = v5;
  *(_DWORD *)(v2 + 12) = sub_1003FC60;
  v4 = *(_DWORD *)(v5 + 132);
  *(_DWORD *)(a1 - 20) = v4;
  *(_DWORD *)(v5 + 132) = v4 + 1;
  if ( (unsigned int)v4 < 2 )
  {
    sub_1002D9F4(v5);
    v11 = (int)sub_10032365();
    *(_DWORD *)(v5 + 4 * *(_DWORD *)(a1 - 20) + 112) = sub_1002ED10(v11, 0, v2);
  }
  else
  {
    v6 = *(_DWORD *)(v5 + 108);
    if ( !v6 )
    {
      v7 = sub_1002ADB1(v3, v4, 0, 0, 16);
      v6 = v7;
      if ( v7 )
      {
        *(_DWORD *)v7 = 0;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v7 + 8) = 0;
        *(_BYTE *)(v7 + 12) = 0;
      }
      else
      {
        v6 = 0;
      }
      *(_DWORD *)(v5 + 108) = v6;
    }
    sub_1002D9F4(v5);
    v8 = (int)sub_10032365();
    v9 = sub_1002ED10(v8, 0, *(_DWORD *)(a1 + 8));
    if ( !sub_1002D23F(v6, v9) )
      --*(_DWORD *)(v5 + 132);
  }
  return sub_10035636(20);
}
// 1002D9F4: using guessed type int __thiscall sub_1002D9F4(_DWORD);
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 1003FC60: using guessed type int sub_1003FC60();

//----- (1002E04D) --------------------------------------------------------
void __userpurge sub_1002E04D(int a1<ebp>, int a2)
{
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 8) + 16) )
    sub_1003FA50(*(_DWORD *)(a1 + 8));
  JUMPOUT(*(unsigned int *)loc_1002DFA7);
}
// 1002DFA7: using guessed type int __stdcall loc_1002DFA7(int);

//----- (1002E066) --------------------------------------------------------
char __thiscall sub_1002E066(int this, int a2)
{
  int v2; // edx@1
  char result; // al@4

  _ESI = this + 52;
  v2 = *(_DWORD *)(this + 52);
  if ( v2 & 0x3FFFFFFF )
  {
LABEL_4:
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      _ECX = a2 | v2 & 0xC0000000;
      __asm { lock cmpxchg [esi], ecx }
      if ( v2 == v2 )
        break;
      if ( v2 & 0x3FFFFFFF )
        goto LABEL_4;
    }
    result = 1;
  }
  return result;
}

//----- (1002E0A0) --------------------------------------------------------
char __cdecl sub_1002E0A0(int a1, int a2)
{
  void *v3; // ecx@1

  v3 = *(void **)(a1 + 8);
  ++*(_DWORD *)(a2 + 4);
  sub_1002D9AB(v3, a1);
  return 1;
}

//----- (1002E0B9) --------------------------------------------------------
bool __userpurge sub_1002E0B9<eax>(int a1<ecx>, int a2<edi>, char a3)
{
  char v3; // bl@1
  int v4; // esi@1
  int i; // eax@4

  v4 = a1;
  v3 = 0;
  if ( !sub_1002D93B(a1) )
  {
    if ( sub_100363BF(0, a2) )
      goto LABEL_14;
    v3 = *(_DWORD *)(v4 + 16) > 0;
    if ( *(_DWORD *)(v4 + 100) == v4 )
    {
      for ( i = *(_DWORD *)(v4 + 104); i; i = *(_DWORD *)(i + 104) )
      {
        if ( *(_DWORD *)(i + 16) > 0 )
          v3 = 1;
      }
    }
    if ( v3 )
LABEL_14:
      sub_1002D2F9(v4, a3);
  }
  return v3 == 0;
}

//----- (1002E10F) --------------------------------------------------------
int __userpurge sub_1002E10F<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned int a4)
{
  int v5; // esi@1
  signed __int64 v7; // qax@1
  int v8; // eax@1
  signed int v9; // ST08_4@1

  v5 = a1;
  _ECX = 0;
  *(_DWORD *)(v5 + 4) = 0;
  *(_DWORD *)v5 = a4;
  v7 = 4i64 * a4;
  __asm { seto    cl }
  v8 = sub_1002965B(SHIDWORD(v7), v7 | -_ECX, a2, a3, v7 | -_ECX);
  v9 = 4 * *(_DWORD *)v5;
  *(_DWORD *)(v5 + 8) = v8;
  sub_10039210((void *)v8, 0, v9);
  return v5;
}

//----- (1002E14D) --------------------------------------------------------
int __usercall sub_1002E14D<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v5; // esi@1

  v5 = a2;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = sub_1002965B(a1, a2, a3, a4, 16);
  return v5;
}

//----- (1002E166) --------------------------------------------------------
#error "1002E221: call analysis failed (funcsize=56)"

//----- (1002E229) --------------------------------------------------------
int __thiscall sub_1002E229(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_10030383(*(LPVOID *)(this + 28));
  return sub_10030383(*(LPVOID *)(v2 + 32));
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (1002E240) --------------------------------------------------------
int __thiscall sub_1002E240(int this)
{
  int v1; // ebx@1
  int v2; // edi@2
  int v3; // esi@3

  v1 = this;
  if ( *(_DWORD *)(this + 4) > 0 )
  {
    v2 = **(_DWORD **)(this + 8);
    if ( v2 )
    {
      do
      {
        v3 = *(_DWORD *)(v2 + 4);
        sub_10030383(*(LPVOID *)v2);
        sub_1002A4AA((LPVOID)v2);
        v2 = v3;
      }
      while ( v3 );
    }
  }
  return sub_1002A4AA(*(LPVOID *)(v1 + 8));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (1002E280) --------------------------------------------------------
int __thiscall sub_1002E280(void *this)
{
  int result; // eax@1
  void *v2; // edi@1

  v2 = this;
  sub_1002E240((int)((char *)this + 140));
  sub_10034867((int)((char *)v2 + 128));
  result = sub_10030383(*((LPVOID *)v2 + 34));
  *(_DWORD *)v2 = off_10061BFC;
  return result;
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 10061BFC: using guessed type int (*off_10061BFC[5])();

//----- (1002E2B8) --------------------------------------------------------
int __thiscall sub_1002E2B8(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_10030383(*(LPVOID *)(this + 12));
  return sub_10030383(*(LPVOID *)(v2 + 8));
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (1002E2CF) --------------------------------------------------------
bool __thiscall sub_1002E2CF(int this, int a2)
{
  return !((*(_DWORD *)this ^ *(_DWORD *)a2) & 0xFFFFFFF) && *(_DWORD *)(this + 8) == *(_DWORD *)(a2 + 8);
}

//----- (1002E2F3) --------------------------------------------------------
int __thiscall sub_1002E2F3(int this, signed int a2)
{
  int v2; // eax@1
  signed int v3; // edx@1
  int v4; // eax@2
  int i; // edx@3

  v2 = *(_DWORD *)(this + 8);
  v3 = a2 >> 4;
  if ( a2 >> 4 >= 4 )
  {
    v4 = *(_DWORD *)(v2 + 12);
    for ( i = v3 - 3; i; --i )
      v4 = *(_DWORD *)(v4 + 4);
  }
  else
  {
    v4 = *(_DWORD *)(v2 + 4 * v3);
  }
  return *(_DWORD *)v4 + 8 * (a2 & 0xF);
}

//----- (1002E327) --------------------------------------------------------
void *__thiscall sub_1002E327(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_10061BFC;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10061BFC: using guessed type int (*off_10061BFC[5])();

//----- (1002E347) --------------------------------------------------------
void *__thiscall sub_1002E347(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_1002E280(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002E366) --------------------------------------------------------
int __thiscall sub_1002E366(void *this, char a2)
{
  int v2; // esi@1

  v2 = (int)this;
  sub_1002E229((int)((char *)this + 76));
  sub_10044F1A(v2);
  if ( a2 & 1 )
    sub_1002A4AA((LPVOID)v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002E38F) --------------------------------------------------------
int __thiscall sub_1002E38F(int this, int a2)
{
  signed int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // edx@3
  int v12; // ecx@11
  signed __int64 v15; // qax@11
  signed int v16; // ST0C_4@11
  int v17; // edx@11
  int v18; // ecx@11
  int v19; // eax@12
  int v28; // edx@17
  char v30; // [sp+Ch] [bp-20h]@22
  int v31; // [sp+14h] [bp-18h]@21
  BOOL (__cdecl *v32)(); // [sp+18h] [bp-14h]@21
  int v33; // [sp+1Ch] [bp-10h]@5
  int v34; // [sp+20h] [bp-Ch]@2
  int v35; // [sp+24h] [bp-8h]@1
  char v36; // [sp+2Bh] [bp-1h]@1

  v5 = this;
  v3 = *(_DWORD *)(this + 48);
  v36 = 0;
  v4 = 0;
  v35 = v3;
  v2 = 4;
  do
  {
    _EBX = v3 + 8;
    v34 = v3 + 8;
    if ( *(_DWORD *)(v3 + 8) >= -1 )
    {
      _EBX = *(_DWORD *)v3;
      v7 = 0;
      if ( *(_DWORD *)(v5 + 40) <= 0 )
      {
LABEL_7:
        _EBX = v34;
      }
      else
      {
        while ( *(_DWORD *)_EBX )
        {
          ++v7;
          _EBX += v2;
          if ( v7 >= *(_DWORD *)(v5 + 40) )
            goto LABEL_7;
        }
        _ECX = a2;
        *(_DWORD *)(a2 + 68) = v7 + v4;
        v33 = *(_DWORD *)(v5 + 64);
        __asm { lock cmpxchg [ebx], ecx }
        v4 += v7;
        v36 = 1;
        if ( v4 >= v33 )
        {
          _EAX = v5 + 64;
          _ECX = 1;
          __asm { lock xadd [eax], ecx }
        }
        _EBX = v34;
        _ECX = -1;
        __asm { lock cmpxchg [ebx], ecx }
      }
      v3 = v35;
    }
    if ( !v36 )
    {
      _ECX = -2;
      __asm { lock cmpxchg [ebx], ecx }
      v4 += *(_DWORD *)(v5 + 40);
      _EBX = v3 + 4;
      if ( !*(_DWORD *)(v3 + 4) )
      {
        _ECX = 1;
        __asm { lock cmpxchg [ebx], ecx }
        _ECX = 0;
        v15 = 4i64 * *(_DWORD *)(v5 + 40);
        __asm { seto    cl }
        v16 = 4 * *(_DWORD *)(v5 + 40);
        v33 = sub_1002965B(SHIDWORD(v15), v15 | -_ECX, _EBX, v4, v15 | -_ECX);
        sub_10039210((void *)v33, 0, v16);
        v12 = sub_1002ADB1(v17, v18, _EBX, v4, 12);
        if ( v12 )
        {
          v19 = v33;
          *(_DWORD *)(v12 + 4) = 0;
          *(_DWORD *)(v12 + 8) = -1;
          *(_DWORD *)v12 = v19;
        }
        else
        {
          v12 = 0;
        }
        v28 = *(_DWORD *)(v5 + 60);
        if ( v28 < *(_DWORD *)(v5 + 56) )
        {
          *(_DWORD *)(*(_DWORD *)(v5 + 52) + 4 * v28) = v12;
          ++*(_DWORD *)(v5 + 60);
        }
        *(_DWORD *)_EBX = v12;
        v3 = v35;
      }
      if ( *(_DWORD *)_EBX == 1 )
      {
        v31 = 0;
        v32 = sub_10034C15;
        do
          sub_100282E0((int)&v30);
        while ( *(_DWORD *)_EBX == 1 );
        v3 = v35;
      }
    }
    v3 = *(_DWORD *)(v3 + 4);
    v35 = v3;
    v2 = 4;
  }
  while ( !v36 );
  return v4;
}

//----- (1002E4E8) --------------------------------------------------------
int __thiscall sub_1002E4E8(void *this, int a2, char a3)
{
  int result; // eax@1
  void *v4; // edi@1

  v4 = this;
  result = sub_1002E518((int)((char *)this + 80), a2 + 92);
  *(_BYTE *)(a2 + 77) = 1;
  if ( a3 )
  {
    result = (int)((char *)v4 + 100);
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
  }
  return result;
}

//----- (1002E518) --------------------------------------------------------
int __thiscall sub_1002E518(int this, int a2)
{
  int v3; // edi@1

  v3 = this;
  sub_1002B98B((void *)(this + 4));
  sub_1002B23D((void *)v3, a2);
  return sub_1002BB75((void *)(v3 + 4));
}

//----- (1002E53F) --------------------------------------------------------
int __thiscall sub_1002E53F(int this, int a2)
{
  int result; // eax@1
  int v3; // edx@1
  int v5; // esi@1
  int v13; // eax@7
  int v14; // edx@10

  v5 = this;
  result = this + 112;
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  _EBX = this + 104;
  v3 = *(_DWORD *)(this + 104);
  while ( v3 == -1 || a2 <= v3 )
  {
    _ECX = a2;
    result = v3;
    __asm { lock cmpxchg [ebx], ecx }
    if ( v3 == v3 )
    {
      if ( *(_DWORD *)(v5 + 116) )
        v13 = -1;
      else
        v13 = a2;
      result = sub_1002E9BF(v5, v13);
      break;
    }
  }
  _ESI = v5 + 108;
  v14 = *(_DWORD *)_ESI;
  do
  {
    if ( v14 != -1 && a2 < v14 )
      break;
    _ECX = a2;
    result = v14;
    __asm { lock cmpxchg [esi], ecx }
  }
  while ( v14 != v14 );
  return result;
}

//----- (1002E5AC) --------------------------------------------------------
bool __thiscall sub_1002E5AC(int this, int a2)
{
  int v3; // edi@1

  v3 = this;
  _EBX = -1;
  _ESI = -1;
  _EDX = this + 104;
  __asm { lock cmpxchg [edx], esi }
  sub_1002ED8D(this);
  _EAX = v3 + 112;
  __asm { lock xadd [eax], ebx }
  return _EBX == 1;
}

//----- (1002E5DE) --------------------------------------------------------
int __userpurge sub_1002E5DE<eax>(int a1<ebp>, int a2)
{
  char i; // zf@1
  signed int v3; // edi@1
  int v4; // esi@1
  void *v5; // ecx@1
  int v6; // eax@3
  int v7; // edx@3
  int v8; // eax@5
  int v9; // ecx@7
  int v10; // ecx@9

  sub_10035668();
  *(_DWORD *)(a1 - 16) = v5;
  v4 = (int)((char *)v5 + 80);
  *(_DWORD *)(a1 - 24) = (char *)v5 + 80;
  v5 = (char *)v5 + 84;
  *(_DWORD *)(a1 - 20) = v5;
  sub_1002B95B(v5);
  v3 = *(_DWORD *)v4;
  *(_DWORD *)(a1 - 4) = 0;
  for ( i = v3 == 0; ; i = v3 == *(_DWORD *)v4 )
  {
    v3 = i ? 0 : *(_DWORD *)(v3 + 4);
    if ( !v3 )
      break;
    if ( *(_DWORD *)(v3 + 24) )
      continue;
    v7 = *(_DWORD *)(v3 - 44);
    v6 = *(_DWORD *)(a1 + 8);
    if ( v7 == v6 )
    {
LABEL_11:
      *(_DWORD *)(v3 + 24) = 1;
      sub_1002E53F(v3 - 92, -999);
      sub_1002E5DE(0);
      continue;
    }
    if ( v6 )
    {
      v9 = 16 * *(_DWORD *)(v6 + 4) >> 4;
      if ( v9 == -1 )
        continue;
      v8 = 16 * *(_DWORD *)(v7 + 4) >> 4;
      if ( v8 <= v9 )
        continue;
    }
    else
    {
      v8 = 16 * *(_DWORD *)(v7 + 4) >> 4;
      if ( v8 == -1 )
        continue;
    }
    v10 = *(_DWORD *)(a1 - 16);
    if ( *(_DWORD *)(v10 + 60) == -1 || sub_1002EA4E(v10, v7, v8) )
      goto LABEL_11;
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002BB6D();
  return sub_10035636(12);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002E6CB) --------------------------------------------------------
bool __cdecl sub_1002E6CB(int a1)
{
  bool result; // eax@1

  result = sub_10032DCA(*(_DWORD *)(a1 + 36));
  if ( !result )
  {
    sub_1002E80C(*(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    *(_DWORD *)(a1 + 72) = 0;
  }
  return result;
}

//----- (1002E6D7) --------------------------------------------------------
char __thiscall sub_1002E6D7(int this, int a2)
{
  int v2; // edi@1
  int v3; // eax@2
  int v4; // edx@2
  char result; // al@5

  v2 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)this + 12) + 4 * *(_DWORD *)(this + 4));
  if ( v2 == 1
    || (v3 = *(_DWORD *)(*(_DWORD *)this + 12) + 4 * *(_DWORD *)(this + 4),
        v4 = *(_DWORD *)v3,
        *(_DWORD *)v3 = 1,
        v4 != v2) )
  {
    sub_1002E82E(*(_DWORD *)this);
    result = 0;
  }
  else
  {
    if ( a2 )
      *(_DWORD *)a2 = v2;
    result = 1;
  }
  return result;
}

//----- (1002E71E) --------------------------------------------------------
int __usercall sub_1002E71E<eax>(int a1<ecx>, int a2<ebp>)
{
  int v3; // esi@1
  int v4; // ST0C_4@1
  int v5; // eax@1

  v3 = a1;
  sub_1002EE1F(a1, a2);
  v4 = *(_DWORD *)(v3 + 8);
  v5 = (*(int (**)(void))(**(_DWORD **)(v3 + 28) + 4))();
  return sub_1002F346(2, 4, v5, v4);
}

//----- (1002E73F) --------------------------------------------------------
void __thiscall sub_1002E73F(void *this)
{
  int ebp0; // ebp@0
  int v2; // edi@1
  int v3; // esi@2
  int v4; // [sp+8h] [bp-4h]@1

  v4 = 0;
  v2 = (int)((char *)this + 128);
  while ( 1 )
  {
    v3 = sub_1002EB94(v2, (int)&v4);
    if ( !v3 )
      break;
    do
    {
      sub_1002DA54(*(_DWORD *)(v3 + 8), ebp0);
      v3 = *(_DWORD *)v3;
    }
    while ( v3 );
    ++v4;
  }
  sub_10034867(v2);
}

//----- (1002E77E) --------------------------------------------------------
BOOL __cdecl sub_1002E77E()
{
  return TlsSetValue(dwTlsIndex, 0);
}

//----- (1002E78D) --------------------------------------------------------
int __usercall sub_1002E78D<eax>(int a1<ebx>, int a2<ebp>)
{
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // eax@1
  PSINGLE_LIST_ENTRY v5; // eax@2
  int v6; // edx@2
  void *v7; // ecx@2
  int v8; // edi@2
  int v9; // eax@5

  sub_10035668();
  v2 = v3;
  v4 = sub_1004107E(*(_DWORD *)(v3 + 24));
  *(_DWORD *)(v2 + 32) = v4;
  if ( !v4 )
  {
    v5 = InterlockedPopEntrySList((PSLIST_HEADER)(*(_DWORD *)(v2 + 24) + 88));
    v8 = 0;
    v7 = 0;
    if ( v5 )
      v7 = &v5[-6];
    *(_DWORD *)(v2 + 32) = v7;
    if ( v7 )
    {
      sub_1004025E(v7);
    }
    else
    {
      v9 = sub_1002ADB1(v6, 0, a1, 0, 116);
      *(_DWORD *)(a2 - 16) = v9;
      *(_DWORD *)(a2 - 4) = 0;
      if ( v9 )
        v8 = sub_100401D8(a2);
      *(_DWORD *)(a2 - 4) = -1;
      *(_DWORD *)(v2 + 32) = v8;
    }
    sub_1002E38F(*(_DWORD *)(v2 + 24) + 88, *(_DWORD *)(v2 + 32));
  }
  *(_DWORD *)(*(_DWORD *)(v2 + 32) + 72) = v2;
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002E80C) --------------------------------------------------------
int __stdcall sub_1002E80C(int a1)
{
  int v1; // esi@1
  void *v2; // ecx@2
  int result; // eax@3

  v1 = a1;
  while ( v1 )
  {
    v2 = (void *)(v1 - 24);
    v1 = *(_DWORD *)v1;
    if ( v2 )
      result = sub_1002E366(v2, 1);
  }
  return result;
}

//----- (1002E82E) --------------------------------------------------------
int __thiscall sub_1002E82E(int this)
{
  int result; // eax@1

  result = this + 20;
  _EDX = -1;
  __asm { lock xadd [eax], edx }
  if ( _ZF )
    result = sub_1003337E(this + 28, sub_1002EFC4, this, *(_DWORD *)this);
  return result;
}

//----- (1002E968) --------------------------------------------------------
void __cdecl sub_1002E968()
{
  JUMPOUT(*(int *)sub_1002E970);
}

//----- (1002E970) --------------------------------------------------------
int __usercall sub_1002E970<eax>(int a1<ebp>)
{
  return sub_1002BB75((void *)(*(_DWORD *)(a1 - 40) + 4));
}

//----- (1002E97C) --------------------------------------------------------
void __usercall sub_1002E97C(int a1<eax>, int a2<ebp>)
{
  LOBYTE(a1) = *(_BYTE *)(a2 - 26);
  *(_DWORD *)(a2 - 32) = a1;
  JUMPOUT(*(int *)sub_1002E987);
}

//----- (1002E987) --------------------------------------------------------
int __usercall sub_1002E987<eax>(int a1<ebp>, int a2<edi>)
{
  int result; // eax@2

  if ( *(_BYTE *)(a1 - 25) )
    result = sub_1002BB75((void *)(a2 + 84));
  return result;
}

//----- (1002E996) --------------------------------------------------------
int __thiscall sub_1002E996(int this)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 12) + 1;
  *(_DWORD *)(this + 12) = result;
  return result;
}

//----- (1002E99E) --------------------------------------------------------
int __cdecl sub_1002E99E()
{
  return 0;
}

//----- (1002E9A1) --------------------------------------------------------
int __thiscall sub_1002E9A1(int this)
{
  int v1; // eax@1
  int result; // eax@1

  v1 = *(_DWORD *)(this + 16);
  ++*(_DWORD *)(this + 12);
  result = v1 + 1;
  *(_DWORD *)(this + 16) = result;
  return result;
}

//----- (1002E9AC) --------------------------------------------------------
int __thiscall sub_1002E9AC(int this)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 12) - 1;
  *(_DWORD *)(this + 12) = result;
  return result;
}

//----- (1002E9B4) --------------------------------------------------------
int __thiscall sub_1002E9B4(int this)
{
  int v1; // eax@1
  int result; // eax@1

  v1 = *(_DWORD *)(this + 16);
  --*(_DWORD *)(this + 12);
  result = v1 - 1;
  *(_DWORD *)(this + 16) = result;
  return result;
}

//----- (1002E9BF) --------------------------------------------------------
int __thiscall sub_1002E9BF(int this, int a2)
{
  int result; // eax@1
  int v3; // ebx@1
  signed int v4; // edi@1
  signed int i; // esi@1

  v3 = this;
  result = this + 140;
  v4 = *(_DWORD *)(this + 140);
  for ( i = 0; i < v4; result = v3 + 140 )
  {
    _ECX = sub_1002E2F3(result, i);
    if ( *(_DWORD *)(_ECX + 4) >= a2 )
    {
      if ( *(_DWORD *)(v3 + 60) == -1 || *(_DWORD *)(v3 + 60) <= a2 )
      {
        _EAX = 1;
        __asm { lock xadd [ecx], eax }
      }
    }
    ++i;
  }
  return result;
}

//----- (1002EA0B) --------------------------------------------------------
bool __thiscall sub_1002EA0B(int this)
{
  bool result; // eax@2

  if ( *(_DWORD *)(this + 16) )
    result = 2;
  else
    result = *(_DWORD *)(this + 12) > 0u;
  return result;
}

//----- (1002EA1F) --------------------------------------------------------
int __thiscall sub_1002EA1F(int this)
{
  return *(_DWORD *)(this + 8);
}

//----- (1002EA23) --------------------------------------------------------
int __thiscall sub_1002EA23(int this)
{
  return *(_DWORD *)(this + 124);
}

//----- (1002EA27) --------------------------------------------------------
int __thiscall sub_1002EA27(int this)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = *(_DWORD *)(this + 24);
  if ( v1 )
    result = *(_DWORD *)(v1 + 256);
  else
    result = 0;
  return result;
}

//----- (1002EA38) --------------------------------------------------------
int __thiscall sub_1002EA38(int this)
{
  int v1; // ecx@1
  int result; // eax@2

  v1 = *(_DWORD *)(this + 24);
  if ( v1 )
    result = (*(int (**)(void))(**(_DWORD **)(v1 + 256) + 4))();
  else
    result = -1;
  return result;
}

//----- (1002EA4E) --------------------------------------------------------
char __thiscall sub_1002EA4E(int this, int a2, int a3)
{
  int v3; // edi@1
  int v4; // eax@5
  int v5; // esi@5
  int v6; // ecx@7
  int v7; // ecx@8
  char v9; // al@16
  signed int v10; // eax@26

  v3 = this;
  if ( *(_DWORD *)(this + 112) <= 0 || *(_DWORD *)(this + 104) > a3 )
    return 0;
  if ( *(_DWORD *)(this + 60) == -1 || *(_DWORD *)(this + 104) >= *(_DWORD *)(this + 60) )
    return 1;
  v4 = *(_DWORD *)(this + 52);
  v5 = a2;
  if ( a2 != v4 || a3 != 16 * *(_DWORD *)(v4 + 4) >> 4 )
  {
    do
    {
      if ( v5 == *(_DWORD *)(v3 + 48) )
        break;
      if ( 16 * *(_DWORD *)(v5 + 4) >> 4 == a3 )
        break;
      v5 = sub_1002F423(v5);
    }
    while ( v5 );
    while ( v5 )
    {
      if ( v5 == *(_DWORD *)(v3 + 48) || sub_1003FF4B(v5, 0) )
      {
        if ( v5 )
        {
          if ( v5 != *(_DWORD *)(v3 + 48) )
          {
            v10 = sub_1003FF4B(v5, 0);
            if ( v10 != 2 )
            {
              v7 = *(_DWORD *)(v10 + 8);
              return v7 != 0;
            }
          }
        }
        return 0;
      }
      v9 = (*(_DWORD *)(v5 + 4) >> 28) & 1;
      if ( v9 && *(_BYTE *)(v5 + 24) & 3 || !v9 && sub_1002D961(v5) )
        return 1;
      v5 = sub_1002F423(v5);
    }
    return 0;
  }
  v6 = *(_DWORD *)(this + 56);
  if ( v6 == 2 )
    return 0;
  v7 = *(_DWORD *)(v6 + 8);
  return v7 != 0;
}

//----- (1002EB38) --------------------------------------------------------
char __thiscall sub_1002EB38(int this, int a2, char a3)
{
  char v3; // bl@1
  int v4; // esi@1

  v4 = this;
  v3 = 0;
  if ( *(_DWORD *)(this + 112) > 0 && !sub_1002F2F9((void *)this, a2, a3)
    || *(_DWORD *)(v4 + 120) > 0 && sub_100400A5(a2) )
    v3 = 1;
  return v3;
}

//----- (1002EB71) --------------------------------------------------------
int __thiscall sub_1002EB71(int this, int a2)
{
  int v3; // edi@1

  v3 = this;
  sub_10034BBC((void *)(this + 112));
  *(_DWORD *)(v3 + 72) = a2;
  return sub_10034BCC((void *)(v3 + 112));
}

//----- (1002EB94) --------------------------------------------------------
int __thiscall sub_1002EB94(int this, int a2)
{
  int v2; // edx@1
  int v3; // eax@2
  int result; // eax@5

  v2 = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 >= *(_DWORD *)this )
  {
LABEL_5:
    result = 0;
  }
  else
  {
    v3 = *(_DWORD *)(this + 8) + 4 * v2;
    while ( !*(_DWORD *)v3 )
    {
      ++v2;
      v3 += 4;
      if ( v2 >= *(_DWORD *)this )
        goto LABEL_5;
    }
    *(_DWORD *)a2 = v2;
    result = *(_DWORD *)(*(_DWORD *)(this + 8) + 4 * v2);
  }
  return result;
}

//----- (1002EBC5) --------------------------------------------------------
int __usercall sub_1002EBC5<eax>(int a1<ecx>, int a2<ebp>)
{
  int v2; // edi@1
  int v3; // esi@2
  int v4; // ebx@3
  int result; // eax@6
  int v6; // ecx@9
  int v7; // ebx@9
  int v8; // edi@9
  int v9; // esi@9
  int v10; // ecx@9
  void *v11; // ecx@9
  int v12; // ecx@10
  int v13; // edx@10
  void *v14; // ecx@16

  v2 = a1 + 4;
  while ( 1 )
  {
    v3 = *(_DWORD *)v2-- - 1;
    if ( *(_DWORD *)a1 > v3 )
      break;
    v4 = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4 * (v3 & *(_DWORD *)(a1 + 8)));
    if ( v4 )
    {
      if ( !(v4 & 1) || (v4 &= 0xFFFFFFFEu, sub_1002E6D7(*(_DWORD *)(a1 + 32) + 8 * (v3 & *(_DWORD *)(a1 + 8)), 0)) )
        result = v4;
      else
        result = 1;
      return result;
    }
  }
  *(_DWORD *)v2 = v3 + 1;
  sub_10035668();
  v9 = v10;
  v11 = *(void **)(v10 + 16);
  *(_DWORD *)(a2 - 16) = v11;
  sub_10034BBC(v11);
  v6 = 0;
  v8 = *(_DWORD *)(v9 + 4) - 1;
  *(_DWORD *)(a2 - 24) = 0;
  *(_DWORD *)(a2 - 20) = 0;
  *(_DWORD *)(v9 + 4) = v8;
  *(_DWORD *)(a2 - 4) = 0;
  LOBYTE(v7) = 0;
  if ( *(_DWORD *)v9 > v8 )
  {
    *(_DWORD *)(v9 + 4) = v8 + 1;
  }
  else
  {
    v12 = *(_DWORD *)(v9 + 32);
    v13 = v8 & *(_DWORD *)(v9 + 8);
    v7 = *(_DWORD *)(*(_DWORD *)(v9 + 28) + 4 * v13);
    *(_DWORD *)(a2 - 24) = *(_DWORD *)(v12 + 8 * v13);
    *(_DWORD *)(a2 - 20) = *(_DWORD *)(v12 + 8 * v13 + 4);
    v6 = 0;
  }
  if ( *(_DWORD *)v9 >= v8 )
  {
    *(_DWORD *)(v9 + 12) += *(_DWORD *)v9;
    *(_DWORD *)v9 = v6;
    *(_DWORD *)(v9 + 4) = v6;
    *(_DWORD *)(v9 + 24) = v6;
    *(_BYTE *)(v9 + 20) = v6;
  }
  if ( v7 & 1 )
    sub_1002E6D7(a2 - 24, v6);
  v14 = *(void **)(a2 - 16);
  *(_DWORD *)(a2 - 4) = -1;
  sub_10034BCC(v14);
  return sub_10035636(12);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002EC1F) --------------------------------------------------------
int __thiscall sub_1002EC1F(int this)
{
  int v2; // edi@1
  int v3; // esi@1

  v2 = this;
  v3 = *(_DWORD *)(this + 36);
  TlsSetValue(dwTlsIndex, *(LPVOID *)(this + 36));
  *(_DWORD *)(v2 + 36) = 0;
  return v3;
}

//----- (1002EC3C) --------------------------------------------------------
int __thiscall sub_1002EC3C(int this, int a2)
{
  int result; // eax@1
  int v3; // edi@1
  int v4; // esi@1

  v3 = this;
  result = sub_1002F423(*(_DWORD *)(this + 52));
  v4 = result;
  if ( !result )
    goto LABEL_11;
  do
  {
    if ( v4 == *(_DWORD *)(v3 + 48) )
      break;
    result = sub_1003FF4B(v4, 0);
    if ( result )
      break;
    result = sub_1002F423(v4);
    v4 = result;
  }
  while ( result );
  if ( v4 && v4 != *(_DWORD *)(v3 + 48) )
  {
    *(_DWORD *)(v3 + 56) = sub_1003FF4B(v4, 0);
    result = 16 * *(_DWORD *)(v4 + 4) >> 4;
    *(_DWORD *)(v3 + 60) = result;
  }
  else
  {
LABEL_11:
    *(_DWORD *)(v3 + 56) = 0;
    *(_DWORD *)(v3 + 60) = -1;
  }
  return result;
}

//----- (1002EC9D) --------------------------------------------------------
int __thiscall sub_1002EC9D(int this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int result; // eax@2

  v3 = *(_DWORD *)(this + 4);
  v2 = *(_DWORD *)(this + 8);
  if ( v3 >= v2 + *(_DWORD *)this )
  {
    result = sub_1002F100((void *)this, a2, 0, 0);
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(this + 28) + 4 * (v3 & v2)) = a2;
    *(_DWORD *)(this + 4) = v3 + 1;
    result = v3 + *(_DWORD *)(this + 12);
  }
  return result;
}

//----- (1002ECE3) --------------------------------------------------------
BOOL __thiscall sub_1002ECE3(LPVOID lpTlsValue, int a2)
{
  *((_DWORD *)lpTlsValue + 9) = a2;
  return TlsSetValue(dwTlsIndex, lpTlsValue);
}

//----- (1002ECFD) --------------------------------------------------------
int __thiscall sub_1002ECFD(int this, int a2, int a3)
{
  int result; // eax@1

  *(_DWORD *)(this + 56) = a2;
  result = a3;
  *(_DWORD *)(this + 60) = a3;
  return result;
}

//----- (1002ED10) --------------------------------------------------------
int __userpurge sub_1002ED10<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int ebp0; // ebp@0
  int v4; // esi@1
  int v5; // edi@3
  int v6; // ST08_4@7

  v4 = a1;
  if ( !*(_DWORD *)(a1 + 32) )
    sub_1002E78D(a2, ebp0);
  v5 = sub_1002EC9D(*(_DWORD *)(v4 + 32) + 76, a3);
  if ( *(_BYTE *)(v4 + 76) )
    ++*(_DWORD *)(*(_DWORD *)(v4 + 156) + 8);
  else
    ++*(_DWORD *)(*(_DWORD *)(v4 + 156) + 92);
  if ( *(_DWORD *)(*(_DWORD *)(v4 + 28) + 428) - *(_DWORD *)(*(_DWORD *)(v4 + 28) + 432) > 0 )
    (*(void (__stdcall **)(_DWORD, _DWORD, int, _DWORD, _DWORD))(**(_DWORD **)(v4 + 28) + 56))(
      *(_DWORD *)(v4 + 24),
      0,
      v6,
      0,
      0);
  return v5;
}

//----- (1002ED8D) --------------------------------------------------------
char __thiscall sub_1002ED8D(int this)
{
  int v1; // ebx@1
  int v2; // edi@1
  int v3; // esi@1
  char v4; // al@3
  char result; // al@14
  int v9; // [sp+Ch] [bp-4h]@1

  v1 = this;
  v9 = this + 108;
  *(_DWORD *)(this + 108) = -1;
  v2 = *(_DWORD *)(this + 52);
  v3 = (*(_DWORD *)(this + 116) != 0 ? 0xFFFFFC1A : 0) - 1;
  while ( v2 && v2 != *(_DWORD *)(v1 + 48) )
  {
    v4 = (*(_DWORD *)(v2 + 4) >> 28) & 1;
    if ( v4 && *(_BYTE *)(v2 + 24) & 3 || !v4 && sub_1002D961(v2) )
    {
      v3 = 16 * *(_DWORD *)(v2 + 4) >> 4;
      break;
    }
    v2 = sub_1002F423(v2);
  }
  _EDI = v9;
  _ECX = v3;
  result = -1;
  __asm { lock cmpxchg [edi], ecx }
  return result;
}

//----- (1002EE14) --------------------------------------------------------
int __thiscall sub_1002EE14(void *this)
{
  int result; // eax@1

  _ECX = (int)((char *)this + 100);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (1002EE1F) --------------------------------------------------------
int __usercall sub_1002EE1F<eax>(int a1<ecx>, int a2<ebp>)
{
  int v2; // ecx@8
  int v4; // ST14_4@15
  int v5; // ST18_4@15
  int v6; // ST1C_4@15
  int v7; // ST20_4@15
  int v8; // ST24_4@15
  int v9; // ST28_4@15
  int v10; // ST2C_4@15
  int v11; // ST30_4@15
  int v12; // ST34_4@15
  int v13; // ST38_4@15
  int v14; // ST3C_4@15
  int v15; // ST40_4@15
  int v16; // ST44_4@15
  int v17; // ST48_4@15
  int v18; // ST4C_4@15
  int v19; // ST50_4@15
  int v20; // ST54_4@15
  int v21; // ST58_4@15
  int v22; // eax@16
  char v23; // al@18
  int v24; // esi@18
  int v25; // esi@19
  int v26; // eax@26
  bool v27; // eax@28
  int v28; // esi@29
  int v29; // edi@1
  int v30; // esi@1
  int v31; // edi@8
  int v32; // [sp+0h] [bp-8h]@8
  int v33; // [sp+4h] [bp-4h]@8

  v29 = a1;
  v30 = *(_DWORD *)(a1 + 32);
  if ( v30 )
  {
    *(_DWORD *)(a1 + 32) = 0;
    if ( *(_DWORD *)(v30 + 80) <= *(_DWORD *)(v30 + 76) )
    {
      if ( *(_DWORD *)(v30 + 112) )
        sub_1002EB71(v30, 0);
      else
        *(_DWORD *)(v30 + 72) = 0;
      sub_1002EE76((void *)(*(_DWORD *)(v29 + 24) + 88), v30, *(_DWORD *)(v30 + 68), 1);
    }
    else
    {
      sub_1002EB71(v30, 0);
      sub_10040FB6(*(_DWORD *)(v29 + 24), v30);
    }
  }
  _SEH_prolog4(&unk_1006C1B0, 44);
  v31 = v2;
  *(_DWORD *)(a2 - 44) = v2;
  if ( *(_DWORD *)(v2 + 100) )
  {
    *(_DWORD *)(a2 - 52) = 0;
    *(_DWORD *)(a2 - 48) = sub_10034C15;
    do
      sub_1002BC26((void *)(a2 - 60));
    while ( *(_DWORD *)(v31 + 100) );
  }
  if ( *(_DWORD *)(v31 + 132) > 0 )
    sub_1002E73F((void *)v31);
  if ( *(_DWORD *)(v31 + 80) )
  {
    LOBYTE(v22) = 0;
    *(_BYTE *)(a2 - 26) = 0;
    while ( !(_BYTE)v22 )
    {
      *(_BYTE *)(a2 - 25) = 1;
      sub_1002B98B((void *)(v31 + 84));
      *(_DWORD *)(a2 - 4) = 0;
      v23 = 1;
      *(_BYTE *)(a2 - 25) = 1;
      v24 = *(_DWORD *)(v31 + 80);
      if ( v24 )
        v25 = *(_DWORD *)(v24 + 4);
      else
        v25 = 0;
      while ( v25 && v23 )
      {
        if ( v25 == *(_DWORD *)(v31 + 80) )
          *(_DWORD *)(a2 - 32) = 0;
        else
          *(_DWORD *)(a2 - 32) = *(_DWORD *)(v25 + 4);
        *(_DWORD *)(a2 - 36) = v25 - 92;
        v26 = sub_1002D873(*(void **)(v25 - 92 + 48));
        *(_DWORD *)(a2 - 40) = v26;
        if ( !sub_1002BCE2((void *)(v26 + 4)) )
        {
          sub_1002BB75((void *)(v31 + 84));
          *(_BYTE *)(a2 - 25) = 0;
          Sleep(1u);
          break;
        }
        *(_DWORD *)(a2 - 4) = 1;
        v28 = *(_DWORD *)(a2 - 36) + 92;
        sub_1002B26C((void *)(v31 + 80), v28);
        *(_BYTE *)(*(_DWORD *)(a2 - 36) + 77) = 0;
        sub_1002B23D(*(void **)(a2 - 40), v28);
        *(_DWORD *)(a2 - 4) = 0;
        v25 = *(_DWORD *)(a2 - 32);
        sub_1002E970(a2);
        v23 = *(_BYTE *)(a2 - 25);
      }
      v27 = v25 == 0;
      *(_DWORD *)(a2 - 32) = v27;
      *(_BYTE *)(a2 - 26) = v27;
      *(_DWORD *)(a2 - 4) = -2;
      sub_1002E987(a2, v31);
      v22 = *(_DWORD *)(a2 - 32);
    }
  }
  else
  {
    sub_1002BAEE((void *)(v31 + 84));
  }
  return _SEH_epilog4(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v32, v33);
}
// 1003B250: using guessed type _DWORD __cdecl _SEH_prolog4(_DWORD, _DWORD);
// 1003B295: using guessed type int __stdcall _SEH_epilog4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1002EE76) --------------------------------------------------------
char __thiscall sub_1002EE76(void *ListHead, int a2, signed int a3, char a4)
{
  signed int v4; // edx@1
  int v6; // esi@1
  char result; // al@2
  int v8; // eax@3
  int v9; // ecx@3
  int v10; // edx@4
  int v11; // edi@4
  int v12; // edx@5
  PSINGLE_LIST_ENTRY v18; // eax@14
  int v19; // ST08_4@14

  v6 = (int)ListHead;
  v4 = a3 >> *((_DWORD *)ListHead + 11);
  _EBX = a3 & (*((_DWORD *)ListHead + 10) - 1);
  if ( v4 < *((_DWORD *)ListHead + 15) )
  {
    v9 = *((_DWORD *)ListHead + 14);
    v8 = *(_DWORD *)(v6 + 52);
    if ( v4 < v9 )
    {
      v11 = *(_DWORD *)(v8 + 4 * v4);
    }
    else
    {
      v10 = v4 - v9;
      v11 = *(_DWORD *)(v8 + 4 * v9 - 4);
      if ( v10 >= 0 )
      {
        v12 = v10 + 1;
        do
        {
          v11 = *(_DWORD *)(v11 + 4);
          --v12;
        }
        while ( v12 );
      }
    }
    _ECX = *(_DWORD *)v11 + 4 * _EBX;
    _EDX = 0;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 == a2 )
    {
      _ECX = v11 + 8;
      __asm { lock cmpxchg [ecx], ebx }
      if ( a4 )
      {
        if ( (signed int)QueryDepthSList((PSLIST_HEADER)v6) <= *(_DWORD *)(v6 + 68) )
        {
          InterlockedPushEntrySList((PSLIST_HEADER)v6, (PSINGLE_LIST_ENTRY)(a2 + 24));
        }
        else
        {
          InterlockedPushEntrySList((PSLIST_HEADER)(v6 + 8), (PSINGLE_LIST_ENTRY)(a2 + 24));
          if ( (signed int)QueryDepthSList((PSLIST_HEADER)(v6 + 8)) > *(_DWORD *)(v6 + 68) )
          {
            if ( !sub_10032DCA(*(_DWORD *)(v6 + 36)) )
            {
              _EDX = 1;
              _ECX = v6 + 72;
              __asm { lock cmpxchg [ecx], edx }
              v18 = InterlockedFlushSList((PSLIST_HEADER)(v6 + 8));
              v19 = *(_DWORD *)(v6 + 36);
              *(_DWORD *)(v6 + 16) = v18;
              sub_1003337E(v6 + 20, (int (__cdecl *)(_DWORD))sub_1002E6CB, v6, v19);
            }
          }
        }
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002EF6C) --------------------------------------------------------
int __thiscall sub_1002EF6C(int this, int a2)
{
  int v3; // edi@1

  v3 = this;
  sub_1002B98B((void *)(this + 4));
  sub_1002B26C((void *)v3, a2);
  return sub_1002BB75((void *)(v3 + 4));
}

//----- (1002EF93) --------------------------------------------------------
int __thiscall sub_1002EF93(void *this, int a2)
{
  return sub_1002EF6C((int)((char *)this + 80), a2 + 92);
}

//----- (1002EFA9) --------------------------------------------------------
BOOL __thiscall sub_1002EFA9(LPVOID lpTlsValue)
{
  return TlsSetValue(dwTlsIndex, lpTlsValue);
}

//----- (1002EFB7) --------------------------------------------------------
int __thiscall sub_1002EFB7(int this, int a2)
{
  int result; // eax@1

  result = a2;
  *(_DWORD *)(this + 124) = a2;
  return result;
}

//----- (1002EFC4) --------------------------------------------------------
int __cdecl sub_1002EFC4(int a1)
{
  int result; // eax@2

  if ( a1 )
  {
    sub_1002E2B8(a1);
    result = sub_1002A4AA((LPVOID)a1);
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002EFE2) --------------------------------------------------------
char __thiscall sub_1002EFE2(void *this)
{
  int v1; // eax@1
  int v2; // ebx@1
  int ebp0; // ebp@0
  int v4; // edi@1
  int v5; // esi@2
  int v6; // edi@5
  int v8; // [sp+8h] [bp-8h]@5
  int v9; // [sp+Ch] [bp-4h]@1

  v9 = 0;
  v2 = (int)((char *)this + 128);
  v1 = sub_1002EB94((int)((char *)this + 128), (int)&v9);
  v4 = v1;
  if ( v1 )
  {
    do
    {
      v5 = *(_DWORD *)v4;
      if ( !*(_DWORD *)v4 )
      {
        ++v9;
        v5 = sub_1002EB94(v2, (int)&v9);
      }
      LOBYTE(v1) = sub_1002D96F(*(_DWORD *)(v4 + 8));
      if ( (_BYTE)v1 )
      {
        v6 = *(_DWORD *)(v4 + 8);
        v8 = sub_1002DA1A(v6);
        LOBYTE(v1) = sub_1002D116((unsigned int *)v2, (int)&v8, 0);
        if ( v6 )
        {
          sub_1002CFB7(ebp0);
          LOBYTE(v1) = sub_1002A4AA((LPVOID)v6);
        }
      }
      v4 = v5;
    }
    while ( v5 );
  }
  return v1;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002F05E) --------------------------------------------------------
int __cdecl sub_1002F05E(int (__cdecl *a1)(_DWORD, _DWORD), int a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  return sub_100403BD(a1, a2, a3);
}

//----- (1002F100) --------------------------------------------------------
int __thiscall sub_1002F100(void *this, int a2, int a3, int a4)
{
  int v4; // eax@1
  int v5; // ebx@1
  int v6; // edi@1
  signed __int64 v8; // qax@1
  signed __int64 v10; // qax@1
  int v11; // edx@2
  int i; // ecx@2
  int v13; // edx@6
  int v14; // ebx@6
  void *v15; // esi@6
  int v16; // edx@7
  int v17; // ecx@8
  int v18; // edx@8
  int v19; // eax@8
  int v20; // ebx@12
  int v21; // edx@13
  int v22; // ecx@13
  int v23; // edx@13
  void *v25; // [sp+Ch] [bp-24h]@6
  void *v26; // [sp+10h] [bp-20h]@1
  int v27; // [sp+14h] [bp-1Ch]@1
  void *v28; // [sp+18h] [bp-18h]@6
  int v29; // [sp+1Ch] [bp-14h]@1
  int v30; // [sp+20h] [bp-10h]@1
  int v31; // [sp+24h] [bp-Ch]@6
  int v32; // [sp+28h] [bp-8h]@6
  int v33; // [sp+2Ch] [bp-4h]@1

  v6 = (int)this;
  _ECX = 0;
  v5 = 2 * (*(_DWORD *)(v6 + 8) + 1);
  v8 = 4i64 * (unsigned int)(2 * (*(_DWORD *)(v6 + 8) + 1));
  __asm { seto    cl }
  v29 = v6;
  v27 = v5;
  v30 = sub_1002965B(SHIDWORD(v8), v8 | -_ECX, v5, v6, v8 | -_ECX);
  v26 = *(void **)(v6 + 28);
  _ECX = 0;
  v10 = 8i64 * (unsigned int)v5;
  __asm { seto    cl }
  v4 = sub_1002965B(SHIDWORD(v10), v10 | -_ECX, v5, v6, v10 | -_ECX);
  v33 = v4;
  if ( v4 )
  {
    v11 = v5 - 1;
    for ( i = v4; v11 >= 0; --v11 )
    {
      *(_DWORD *)i = 0;
      *(_DWORD *)(i + 4) = 0;
      i += 8;
    }
  }
  else
  {
    v33 = 0;
  }
  v15 = *(void **)(v6 + 16);
  v25 = *(void **)(v6 + 32);
  v28 = *(void **)(v6 + 16);
  sub_10034BBC(v15);
  v32 = 0;
  v13 = *(_DWORD *)(v6 + 4) - *(_DWORD *)v6;
  v14 = *(_DWORD *)(v6 + 8) & *(_DWORD *)v6;
  v31 = v13;
  *(_DWORD *)(v6 + 12) = *(_DWORD *)(v6 + 12) - v14 - v13 + *(_DWORD *)(v6 + 4);
  *(_DWORD *)v6 = v14;
  *(_DWORD *)(v6 + 4) = v14 + v13;
  if ( v13 > 0 )
  {
    v16 = 0;
    do
    {
      *(_DWORD *)(v30 + 4 * v16) = *(_DWORD *)(*(_DWORD *)(v6 + 28) + 4 * (*(_DWORD *)(v6 + 8) & v14));
      v17 = *(_DWORD *)(v6 + 32);
      v18 = *(_DWORD *)(v6 + 8) & v14;
      *(_DWORD *)(v33 + 8 * v32) = *(_DWORD *)(v17 + 8 * v18);
      v19 = *(_DWORD *)(v17 + 8 * v18 + 4);
      v6 = v29;
      v16 = v32 + 1;
      *(_DWORD *)(v33 + 8 * (v32 + 1) - 4) = v19;
      ++v14;
      v32 = v16;
    }
    while ( v16 < v31 );
    v15 = v28;
    v13 = v31;
  }
  *(_DWORD *)(v6 + 28) = v30;
  *(_DWORD *)(v6 + 32) = v33;
  *(_DWORD *)(v6 + 12) += *(_DWORD *)v6;
  if ( *(_BYTE *)(v6 + 20) )
    *(_DWORD *)(v6 + 24) -= *(_DWORD *)v6;
  *(_DWORD *)(v6 + 8) = v27 - 1;
  *(_DWORD *)v6 = 0;
  *(_DWORD *)(v6 + 4) = v13;
  v20 = *(_DWORD *)(v6 + 4);
  if ( a3 )
  {
    v22 = *(_DWORD *)(v6 + 32);
    v23 = *(_DWORD *)(v6 + 8) & v20;
    *(_DWORD *)(v22 + 8 * v23) = a3;
    *(_DWORD *)(v22 + 8 * v23 + 4) = a4;
    v21 = a2 | 1;
  }
  else
  {
    v21 = a2;
  }
  *(_DWORD *)(*(_DWORD *)(v6 + 28) + 4 * (*(_DWORD *)(v6 + 8) & v20)) = v21;
  *(_DWORD *)(v6 + 4) = v20 + 1;
  sub_10034BCC(v15);
  sub_10030383(v26);
  sub_10030383(v25);
  return *(_DWORD *)(v6 + 12) - 1 + *(_DWORD *)(v6 + 4);
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (1002F288) --------------------------------------------------------
int __cdecl sub_1002F288(char a1, char a2, int a3, int a4)
{
  int v4; // ebx@1
  int result; // eax@2
  __int16 v6; // [sp+4h] [bp-40h]@2
  char v7; // [sp+6h] [bp-3Eh]@2
  char v8; // [sp+8h] [bp-3Ch]@2
  char v9; // [sp+9h] [bp-3Bh]@2
  int v10; // [sp+1Ch] [bp-28h]@2
  int v11; // [sp+20h] [bp-24h]@2
  int v12; // [sp+24h] [bp-20h]@2
  int v13; // [sp+28h] [bp-1Ch]@2
  int v14; // [sp+30h] [bp-14h]@2
  int v15; // [sp+38h] [bp-Ch]@2
  int v16; // [sp+3Ch] [bp-8h]@2

  v4 = dword_100766D8;
  if ( dword_100766D8 )
  {
    sub_10039210(&v7, 0, 62);
    v14 = 131072;
    v6 = 64;
    v8 = a1;
    v9 = a2;
    v10 = dword_10068304[0];
    v11 = dword_10068304[1];
    v12 = dword_10068304[2];
    v13 = dword_10068304[3];
    v15 = a3;
    v16 = a4;
    result = sub_10030F35(v4, dword_100766D0, dword_100766D4, (int)&v6);
  }
  return result;
}
// 100766D0: using guessed type int dword_100766D0;
// 100766D4: using guessed type int dword_100766D4;
// 100766D8: using guessed type int dword_100766D8;

//----- (1002F2F9) --------------------------------------------------------
char __thiscall sub_1002F2F9(void *this, int a2, char a3)
{
  void *v3; // esi@1
  signed int v4; // eax@2
  char result; // al@4
  int v6; // eax@5
  int v7; // ecx@7

  v3 = this;
  if ( a3 )
  {
    v4 = sub_1003FF4B(a2, 0);
    if ( v4 == 2 || !*(_DWORD *)(v4 + 8) )
      return 1;
  }
  v6 = *((_DWORD *)v3 + 15);
  if ( *((_DWORD *)v3 + 27) >= v6 || v6 == -1 )
  {
    result = 0;
  }
  else
  {
    v7 = *((_DWORD *)v3 + 14);
    if ( v7 == 2 )
      return 1;
    result = *(_DWORD *)(v7 + 8) == 0;
  }
  return result;
}

//----- (1002F346) --------------------------------------------------------
int __stdcall sub_1002F346(char a1, char a2, int a3, int a4)
{
  int result; // eax@2

  if ( a2 <= (unsigned __int8)byte_100766CC )
  {
    result = dword_100766C8;
    if ( dword_100766C8 & 2 )
      result = sub_1002F288(a1, a2, a3, a4);
  }
  return result;
}
// 100766C8: using guessed type int dword_100766C8;
// 100766CC: using guessed type char byte_100766CC;

//----- (1002F373) --------------------------------------------------------
int __thiscall sub_1002F373(int this, int a2)
{
  int ebp0; // ebp@0
  int v3; // esi@1
  int result; // eax@2
  int v5; // ebx@5
  int v6; // eax@5

  v3 = a2 - *(_DWORD *)(this + 12);
  if ( v3 == *(_DWORD *)(this + 4) - 1 )
  {
    result = sub_1002EBC5(this, ebp0);
  }
  else
  {
    if ( v3 >= *(_DWORD *)(this + 4) || v3 < *(_DWORD *)this )
    {
      result = 0;
    }
    else
    {
      v6 = *(_DWORD *)(this + 28) + 4 * (v3 & *(_DWORD *)(this + 8));
      v5 = *(_DWORD *)v6;
      *(_DWORD *)v6 = 0;
      if ( !(v5 & 1) || (v5 &= 0xFFFFFFFEu, sub_1002E6D7(*(_DWORD *)(this + 32) + 8 * (v3 & *(_DWORD *)(this + 8)), 0)) )
        result = v5;
      else
        result = 1;
    }
  }
  return result;
}

//----- (1002F3D6) --------------------------------------------------------
int __thiscall sub_1002F3D6(int this, int a2)
{
  return sub_1002F373(*(_DWORD *)(this + 32) + 76, a2);
}

//----- (1002F3E5) --------------------------------------------------------
int __thiscall sub_1002F3E5(int this, int a2)
{
  int result; // eax@1

  *(_DWORD *)this ^= (*(_DWORD *)this ^ *(_DWORD *)a2) & 0xFFFFFFF;
  *(_DWORD *)this = *(_DWORD *)a2 ^ (*(_DWORD *)this ^ *(_DWORD *)a2) & 0xFFFFFFF;
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  result = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(this + 12) = result;
  return result;
}

//----- (1002F41A) --------------------------------------------------------
char *__usercall sub_1002F41A<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  return (char *)sub_1002B772(a1, a2, a3) + 64;
}

//----- (1002F423) --------------------------------------------------------
int __thiscall sub_1002F423(int this)
{
  int result; // eax@2

  if ( (*(_DWORD *)(this + 4) & 0xFFFFFFF) == 268435455 )
    result = 0;
  else
    result = *(_DWORD *)this;
  return result;
}

//----- (1002F437) --------------------------------------------------------
int __userpurge sub_1002F437<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4)
{
  int v4; // eax@1
  int v5; // esi@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // ecx@2

  sub_100356D1();
  v5 = v6;
  *(_DWORD *)(a2 - 4) = 0;
  v4 = sub_1002ADB1(v7, v6, a1, a3, 16);
  if ( v4 )
  {
    *(_DWORD *)(v4 + 4) = 1;
    *(_DWORD *)(v4 + 8) = 1;
    v8 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)v4 = off_10061CCC;
    *(_DWORD *)(v4 + 12) = v8;
  }
  else
  {
    v8 = *(_DWORD *)(a2 + 8);
    v4 = 0;
  }
  sub_1002FBE7(v5, v8, v4);
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 10061CCC: using guessed type int (*off_10061CCC[2])();

//----- (1002F482) --------------------------------------------------------
void __usercall sub_1002F482(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  void *v3; // esi@1

  v3 = *(void **)(a2 + 8);
  if ( v3 )
  {
    sub_1002F6D1(*(_DWORD *)(a2 + 8), a1, a3);
    sub_1002A4AA(v3);
  }
  sub_100355DB(0, 0);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_1002F4A1);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002F4A1) --------------------------------------------------------
int __userpurge sub_1002F4A1<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4, int a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // esi@1
  int v8; // ecx@1
  unsigned int v9; // eax@1
  int v10; // edx@1
  int v11; // eax@2

  sub_100356D1();
  v7 = v8;
  *(_DWORD *)(a2 - 4) = 0;
  v9 = sub_1002FDF7(v10, a2 - 17, a1, 1u);
  v6 = *(_DWORD *)(a2 + 8);
  v5 = v9;
  if ( v9 )
  {
    v11 = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(v5 + 4) = 1;
    *(_DWORD *)(v5 + 8) = 1;
    *(_DWORD *)v5 = &off_10061CE0;
    *(_DWORD *)(v5 + 12) = v6;
    *(_DWORD *)(v5 + 16) = v11;
  }
  sub_1002FBE7(v7, v6, v5);
  return sub_10035636(8);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 10061CE0: using guessed type int (*off_10061CE0)();

//----- (1002F4EE) --------------------------------------------------------
void __usercall sub_1002F4EE(int a1<ebp>)
{
  (*(void (__cdecl **)(_DWORD))(a1 + 12))(*(_DWORD *)(a1 + 8));
  sub_100355DB(0, 0);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_1002F4FF);
}

//----- (1002F4FF) --------------------------------------------------------
int __userpurge sub_1002F4FF<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  int result; // eax@1
  void *v5; // ecx@1
  int ebp0; // ebp@0
  int v7; // esi@1

  v7 = a1;
  sub_1002F437(a2, ebp0, a3, a4);
  v5 = *(void **)(v7 + 4);
  *(_DWORD *)(v7 + 4) = 0;
  result = 0;
  *(_DWORD *)v7 = 0;
  if ( v5 )
    result = sub_1000AA70(v5);
  return result;
}

//----- (1002F536) --------------------------------------------------------
int __userpurge sub_1002F536<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5)
{
  int result; // eax@1
  void *v6; // ecx@1
  int ebp0; // ebp@0
  int v8; // esi@1

  v8 = a1;
  sub_1002F4A1(a2, ebp0, a3, a4, a1);
  v6 = *(void **)(v8 + 4);
  *(_DWORD *)(v8 + 4) = 0;
  result = 0;
  *(_DWORD *)v8 = 0;
  if ( v6 )
    result = sub_1000AA70(v6);
  return result;
}

//----- (1002F572) --------------------------------------------------------
int __thiscall sub_1002F572(int this, int a2, char a3)
{
  int v3; // edx@1
  int v4; // ebx@1
  int ebp0; // ebp@0
  unsigned int v6; // edi@1
  int v7; // esi@1
  int v8; // eax@1
  int v9; // edx@2
  unsigned int v10; // eax@6
  int v11; // eax@10
  int v12; // edi@14
  int v13; // eax@16
  int v14; // edx@18
  int v15; // ecx@18
  PVOID v16; // eax@18
  char v17; // zf@18
  int v18; // eax@19
  int v20; // ecx@25
  int v21; // esi@25
  int v22; // [sp-4h] [bp-20h]@18
  int (__stdcall **v23)(char); // [sp+Ch] [bp-10h]@24
  int v24; // [sp+18h] [bp-4h]@25
  _DWORD *v25; // [sp+1Ch] [bp+0h]@25

  v3 = 0;
  v4 = a2;
  v7 = this;
  *(_BYTE *)(this + 80) = a3;
  *(_DWORD *)this = *(_DWORD *)a2;
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  v8 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(this + 16) = v8;
  v6 = 0;
  if ( v8 )
  {
    v9 = this + 20;
    do
    {
      if ( v6 >= 0xF )
        break;
      *(_DWORD *)v9 = *(_DWORD *)(a2 - this + v9);
      ++v6;
      v9 += 4;
    }
    while ( v6 < *(_DWORD *)(this + 16) );
    v4 = a2;
    v3 = 0;
  }
  v10 = *(_DWORD *)(this + 16);
  if ( v10 < 0xF )
    memset((void *)(this + 20 + 4 * v10), 0, 4 * (15 - v10));
  if ( *(_DWORD *)v4 != -529697949
    || *(_DWORD *)(v4 + 16) != 3
    || (v11 = *(_DWORD *)(v4 + 20), v11 != 429065504) && v11 != 429065505 && v11 != 429065506 && v11 != 26820608 )
    return v7;
  *(_DWORD *)(this + 24) = v3;
  v12 = *(_DWORD *)(v4 + 28);
  if ( *(_DWORD *)(v4 + 24) != v3 )
  {
    if ( v12 )
    {
      v13 = *(_DWORD *)(v12 + 12);
      if ( v13 )
      {
        if ( *(_DWORD *)v13 > v3 )
        {
          v16 = EncodePointer(*(PVOID *)(v4 + 28));
          v17 = a3 == 0;
          *(_DWORD *)(v7 + 28) = v16;
          a2 = *(_DWORD *)(*(_DWORD *)(v12 + 12) + 4);
          v22 = *(_DWORD *)(a2 + 20);
          if ( v17 )
            v18 = sub_10037550(v14, v15, v4, v22);
          else
            v18 = sub_10030910(v14, v15, v4, v12, v22);
          v12 = v18;
          if ( v18 )
          {
            sub_1002F851(ebp0, v18, *(_DWORD *)(v4 + 24), *(_DWORD *)(a2 + 20), a2);
            *(_DWORD *)(v7 + 24) = v12;
            return v7;
          }
          *(_DWORD *)&a3 = "bad allocation";
          sub_1002AEC9((int)&v23, (int)&a3, 1);
          v23 = &off_100602D4;
          sub_100355DB((int)&v23, (int)&unk_1006BAB0);
        }
      }
    }
  }
  sub_1003B47D(v4, v12);
  __asm { int     3               ; Trap to Debugger }
  v25 = &v25;
  v24 = v7;
  v21 = v20;
  sub_1002AEE4(v20, v4, a2);
  *(_DWORD *)v21 = &off_10061C68;
  return v21;
}
// 100602D4: using guessed type int (__stdcall *off_100602D4)(char);
// 10061C68: using guessed type int (__stdcall *off_10061C68)(char);

//----- (1002F6D1) --------------------------------------------------------
void __usercall sub_1002F6D1(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // esi@1
  int v4; // eax@3
  PVOID v5; // eax@7
  PVOID v6; // edx@7
  int v7; // ecx@8
  int v8; // eax@9
  int v9; // ecx@12
  int v10; // ecx@16

  v3 = a1;
  if ( *(_DWORD *)a1 == -529697949 )
  {
    if ( *(_DWORD *)(a1 + 16) == 3 )
    {
      v4 = *(_DWORD *)(a1 + 20);
      if ( v4 == 429065504 || v4 == 429065505 || v4 == 429065506 || v4 == 26820608 )
      {
        v5 = DecodePointer(*(PVOID *)(a1 + 28));
        v6 = v5;
        if ( v5 )
        {
          v7 = *(_DWORD *)(v3 + 24);
          if ( v7 )
          {
            v8 = *(_DWORD *)(*((_DWORD *)v5 + 3) + 4);
            if ( *((_DWORD *)v6 + 1) )
            {
              sub_1003586C(v7, *((_DWORD *)v6 + 1));
            }
            else
            {
              if ( *(_BYTE *)v8 & 8 )
              {
                v9 = *(_DWORD *)v7;
                if ( v9 )
                  (*(void (__stdcall **)(int))(*(_DWORD *)v9 + 8))(v9);
              }
            }
          }
          sub_100309A2(a2, *(LPVOID *)(v3 + 24));
        }
        else
        {
          sub_1003B47D(a2, a3);
          __asm { int     3               ; Trap to Debugger }
          *(_DWORD *)v10 = &off_10061C68;
          sub_1002AF18(v10, a2);
        }
      }
    }
  }
}
// 1003586C: using guessed type _DWORD __cdecl sub_1003586C(_DWORD, _DWORD);
// 10061C68: using guessed type int (__stdcall *off_10061C68)(char);

//----- (1002F75B) --------------------------------------------------------
void *__thiscall sub_1002F75B(void *this, int a2)
{
  void *v2; // ecx@1
  void *v3; // esi@1
  int v5; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v3 = this;
  sub_1002F7FF((int)&v5, a2);
  v2 = (void *)*((_DWORD *)v3 + 1);
  *((_DWORD *)v3 + 1) = v6;
  *(_DWORD *)v3 = v5;
  if ( v2 )
    sub_1000AA70(v2);
  return v3;
}

//----- (1002F794) --------------------------------------------------------
void *__thiscall sub_1002F794(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_10061C74;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10061C74: using guessed type int (*off_10061C74[2])();

//----- (1002F7B4) --------------------------------------------------------
int __thiscall sub_1002F7B4(int this, char a2)
{
  void *v2; // ecx@1
  int v3; // esi@1

  v3 = this;
  v2 = *(void **)(this + 4);
  if ( v2 )
    sub_1000AA70(v2);
  if ( a2 & 1 )
    sub_1002A4AA((LPVOID)v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002F7DA) --------------------------------------------------------
void *__userpurge sub_1002F7DA<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  *(_DWORD *)a1 = &off_10061C68;
  sub_1002AF18(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10061C68: using guessed type int (__stdcall *off_10061C68)(char);

//----- (1002F7FF) --------------------------------------------------------
int __thiscall sub_1002F7FF(int this, int a2)
{
  int v2; // esi@1
  int result; // eax@2
  int v4; // edx@2
  int v5; // ecx@2

  v2 = this;
  if ( this != a2 )
  {
    v4 = *(_DWORD *)(this + 4);
    *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a2 + 4) = v4;
    result = *(_DWORD *)a2;
    v5 = *(_DWORD *)this;
    *(_DWORD *)v2 = *(_DWORD *)a2;
    *(_DWORD *)a2 = v5;
  }
  return result;
}

//----- (1002F827) --------------------------------------------------------
int __cdecl sub_1002F827(int a1)
{
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  sub_1002FC09(a1, dword_10076390, dword_10076394);
  return a1;
}
// 10076390: using guessed type int dword_10076390;
// 10076394: using guessed type int dword_10076394;

//----- (1002F851) --------------------------------------------------------
int __userpurge sub_1002F851<eax>(int a1<ebp>, int a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  int v6; // edi@6
  int v8; // [sp-8h] [bp-8h]@4

  sub_100356D1();
  v5 = *(_DWORD *)(a1 + 20);
  if ( *(_BYTE *)v5 & 1 || !*(_DWORD *)(v5 + 24) )
  {
    v6 = *(_DWORD *)(a1 + 12);
    sub_10034F00(*(void **)(a1 + 8), *(const void **)(a1 + 12), *(_DWORD *)(a1 + 16));
    if ( *(_BYTE *)v5 & 8 )
    {
      if ( *(_DWORD *)v6 )
        (*(void (__cdecl **)(_DWORD, signed int))(**(_DWORD **)v6 + 4))(*(_DWORD *)v6, 4);
    }
  }
  else
  {
    *(_DWORD *)(a1 - 4) = 0;
    if ( *(_BYTE *)v5 & 4 )
    {
      v8 = 1;
      sub_100363D0(*(_DWORD *)(a1 + 12), v5 + 8);
      sub_1003586C(*(_DWORD *)(a1 + 8), *(_DWORD *)(v5 + 24));
    }
    else
    {
      v8 = sub_100363D0(*(_DWORD *)(a1 + 12), v5 + 8);
      sub_1003586C(*(_DWORD *)(a1 + 8), *(_DWORD *)(v5 + 24));
    }
  }
  return sub_10035636(v8);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 1003586C: using guessed type _DWORD __cdecl sub_1003586C(_DWORD, _DWORD);

//----- (1002F8DB) --------------------------------------------------------
int __usercall sub_1002F8DB<eax>(int a1<ebp>)
{
  int v1; // eax@1
  int v2; // edx@1
  int v3; // ecx@1
  char v4; // zf@7
  int v5; // eax@8
  int v6; // eax@9
  int v7; // eax@12
  int v8; // ecx@12
  int v9; // eax@13
  void *v10; // ecx@16
  int v11; // esi@16

  sub_100356D1();
  v1 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 - 20) = 0;
  v3 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 - 4) = 1;
  *(_DWORD *)(a1 - 72) = -529697949;
  *(_DWORD *)(a1 - 68) = 1;
  *(_DWORD *)(a1 - 64) = 0;
  *(_DWORD *)(a1 - 60) = 0;
  *(_DWORD *)(a1 - 56) = 3;
  *(_DWORD *)(a1 - 52) = 429065504;
  *(_DWORD *)(a1 - 48) = v3;
  if ( v1 )
  {
    if ( *(_BYTE *)v1 & 0x10 )
      v1 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v3 - 4) + 24);
  }
  *(_DWORD *)(a1 - 44) = v1;
  if ( v1 )
  {
    if ( *(_BYTE *)v1 & 8 )
      *(_DWORD *)(a1 - 52) = 26820608;
  }
  *(_DWORD *)(a1 - 28) = 0;
  *(_DWORD *)(a1 - 24) = 0;
  v4 = *(_BYTE *)(a1 + 20) == 0;
  *(_BYTE *)(a1 - 4) = 2;
  if ( v4 )
  {
    v7 = sub_1002FE69(v2, a1 + 23, 1, 1u);
    *(_DWORD *)(a1 + 20) = v7;
    *(_DWORD *)(a1 + 12) = v7;
    *(_BYTE *)(a1 - 4) = 4;
    if ( v7 )
      v9 = sub_1002F572(v7, a1 - 72, 0);
    else
      v9 = 0;
    *(_BYTE *)(a1 - 4) = 2;
    sub_1002F536(a1 - 28, 1, v9, (int)sub_1002FB18, v8);
  }
  else
  {
    v5 = sub_1002ADB1(v2, v3, 1, 0, 84);
    *(_DWORD *)(a1 + 20) = v5;
    *(_BYTE *)(a1 - 4) = 3;
    if ( v5 )
      v6 = sub_1002F572(v5, a1 - 72, 1);
    else
      v6 = 0;
    *(_BYTE *)(a1 - 4) = 2;
    sub_1002F4FF(a1 - 28, 1, 0, v6);
  }
  v11 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)v11 = 0;
  *(_DWORD *)(v11 + 4) = 0;
  sub_1002F7FF(v11, a1 - 28);
  v10 = *(void **)(a1 - 24);
  *(_DWORD *)(a1 - 20) = 1;
  *(_BYTE *)(a1 - 4) = 1;
  if ( v10 )
    sub_1000AA70(v10);
  return sub_10035636(60);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002F9E6) --------------------------------------------------------
int (*__usercall sub_1002F9E6<eax>(int a1<ebx>, int a2<ebp>))()
{
  int v3; // ST00_4@1

  v3 = *(_DWORD *)(a2 + 8);
  *(_BYTE *)(a2 - 4) = 6;
  sub_1002F827(v3);
  *(_DWORD *)(a2 - 40) = &off_100602D4;
  sub_1002AF18(a2 - 40, a1);
  return loc_1002FA08;
}
// 1002FA08: using guessed type int loc_1002FA08();
// 100602D4: using guessed type int (__stdcall *off_100602D4)(char);

//----- (1002FA0D) --------------------------------------------------------
void __usercall sub_1002FA0D(int a1<ebx>, int a2<edi>)
{
  sub_1003B47D(a1, a2);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_1002FA13);
}

//----- (1002FA13) --------------------------------------------------------
int __usercall sub_1002FA13<eax>(int a1<ebp>)
{
  int v1; // edx@4
  int v2; // ecx@4
  int v3; // esi@5
  int v4; // eax@6
  int v5; // eax@6
  void *v6; // ecx@8
  int v7; // esi@8
  int v8; // eax@11

  sub_100356D1();
  *(_DWORD *)(a1 - 20) = 0;
  *(_DWORD *)(a1 - 4) = 1;
  if ( !*(_DWORD *)(sub_10041A5C(1, 0) + 136)
    || *(_DWORD *)(sub_10041A5C(1, 0) + 144)
    || **(_DWORD **)(sub_10041A5C(1, 0) + 136) == -532459699
    || **(_DWORD **)(sub_10041A5C(1, 0) + 136) == -532462766 )
  {
    v8 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)v8 = 0;
    *(_DWORD *)(v8 + 4) = 0;
  }
  else
  {
    v3 = sub_1002ADB1(v1, v2, 1, 0, 84);
    *(_DWORD *)(a1 - 24) = v3;
    *(_BYTE *)(a1 - 4) = 2;
    if ( v3 )
    {
      v5 = sub_10041A5C(1, 0);
      v4 = sub_1002F572(v3, *(_DWORD *)(v5 + 136), 1);
    }
    else
    {
      v4 = 0;
    }
    *(_BYTE *)(a1 - 4) = 1;
    *(_DWORD *)(a1 - 28) = 0;
    *(_DWORD *)(a1 - 24) = 0;
    sub_1002F437(1, a1, 0, v4);
    v7 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)v7 = 0;
    *(_DWORD *)(v7 + 4) = 0;
    sub_1002F7FF(v7, a1 - 28);
    v6 = *(void **)(a1 - 24);
    *(_DWORD *)(a1 - 20) = 1;
    if ( v6 )
      sub_1000AA70(v6);
  }
  return sub_10035636(28);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002FB18) --------------------------------------------------------
void __usercall sub_1002FB18(int a1<ebx>, int a2<edi>, LPVOID lpMem)
{
  sub_1002F6D1((int)lpMem, a1, a2);
  sub_100309A2(a1, lpMem);
}

//----- (1002FB29) --------------------------------------------------------
int __thiscall sub_1002FB29(void *this)
{
  int result; // eax@2

  if ( this )
    result = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)this + 8))(1);
  return result;
}

//----- (1002FB35) --------------------------------------------------------
void __usercall sub_1002FB35(LPVOID lpMem<ecx>, int a2<ebx>)
{
  void *v2; // esi@1

  v2 = lpMem;
  (*(void (__stdcall **)(_DWORD))(*(_DWORD *)lpMem + 8))(0);
  sub_100309A2(a2, v2);
}

//----- (1002FB48) --------------------------------------------------------
int __usercall sub_1002FB48<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  void *v3; // esi@1
  int result; // eax@2

  v3 = *(void **)(a1 + 12);
  if ( v3 )
  {
    sub_1002F6D1(*(_DWORD *)(a1 + 12), a2, a3);
    result = sub_1002A4AA(v3);
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002FB60) --------------------------------------------------------
int __thiscall sub_1002FB60(int this)
{
  return (*(int (__cdecl **)(_DWORD))(this + 16))(*(_DWORD *)(this + 12));
}

//----- (1002FB68) --------------------------------------------------------
int __thiscall sub_1002FB68(void *this, void *a2)
{
  return sub_1002CAFD(a2, (int)&off_100738C4) != 0 ? (int)((char *)this + 16) : 0;
}
// 100738C4: using guessed type int (__stdcall **off_100738C4)(char);

//----- (1002FB8C) --------------------------------------------------------
#error "1002FBE1: call analysis failed (funcsize=26)"

//----- (1002FBE7) --------------------------------------------------------
int __thiscall sub_1002FBE7(int this, int a2, int a3)
{
  void *v3; // ecx@1
  int v4; // esi@1
  int result; // eax@3

  v4 = this;
  v3 = *(void **)(this + 4);
  if ( v3 )
    sub_1000AA70(v3);
  *(_DWORD *)(v4 + 4) = a3;
  result = a2;
  *(_DWORD *)v4 = a2;
  return result;
}

//----- (1002FC09) --------------------------------------------------------
int __thiscall sub_1002FC09(int this, int a2, int a3)
{
  if ( a3 )
  {
    _EAX = a3 + 4;
    _EDX = 1;
    __asm { lock xadd [eax], edx }
  }
  return sub_1002FBE7(this, a2, a3);
}

//----- (1002FC2C) --------------------------------------------------------
void __usercall sub_1002FC2C(const void *a1<ecx>, int a2<edi>)
{
  int v2; // ebx@1
  int ebp0; // ebp@0
  signed int v4; // eax@2
  DWORD v5; // edx@2
  PVOID v6; // eax@8
  int v7; // ecx@10
  int v8; // esi@12
  char v9; // [sp+0h] [bp-70h]@12
  int (__stdcall **v10)(char); // [sp+Ch] [bp-64h]@16
  int v11; // [sp+18h] [bp-58h]@16
  DWORD dwExceptionCode; // [sp+1Ch] [bp-54h]@2
  DWORD dwExceptionFlags; // [sp+20h] [bp-50h]@15
  DWORD nNumberOfArguments; // [sp+2Ch] [bp-44h]@2
  ULONG_PTR Arguments; // [sp+30h] [bp-40h]@4
  int v16; // [sp+34h] [bp-3Ch]@8
  PVOID Ptr; // [sp+38h] [bp-38h]@8
  unsigned int v18; // [sp+6Ch] [bp-4h]@1
  int v19; // [sp+70h] [bp+0h]@1

  v18 = (unsigned int)&v19 ^ __security_cookie;
  v2 = (int)a1;
  if ( !a1 )
  {
    v11 = (int)"bad exception";
    sub_1002AEA4((int)&v10, &v11);
    v10 = &off_10061C68;
    sub_100355DB((int)&v10, (int)&unk_1006C474);
    goto LABEL_17;
  }
  memcpy(&dwExceptionCode, a1, 0x50u);
  a2 = (int)&v18;
  v5 = dwExceptionCode;
  v4 = nNumberOfArguments;
  if ( dwExceptionCode != -529697949 || nNumberOfArguments != 3 )
    goto LABEL_13;
  if ( Arguments == 429065504 || Arguments == 429065505 || Arguments == 429065506 || Arguments == 26820608 )
  {
    v6 = DecodePointer(Ptr);
    if ( v16 )
    {
      if ( v6 )
      {
        v7 = *((_DWORD *)v6 + 3);
        if ( v7 )
        {
          if ( *(_DWORD *)v7 > 0 )
          {
            Ptr = v6;
            v8 = *(_DWORD *)(*((_DWORD *)v6 + 3) + 4);
            sub_1003F590(*(_DWORD *)(v8 + 20), v7, v9);
            sub_1002F851(ebp0, (int)&v9, v16, *(_DWORD *)(v8 + 20), v8);
            v4 = nNumberOfArguments;
            v5 = dwExceptionCode;
            v16 = (int)&v9;
LABEL_13:
            if ( (unsigned int)v4 > 0xF )
            {
              v4 = 15;
              nNumberOfArguments = 15;
            }
            goto LABEL_15;
          }
        }
      }
    }
LABEL_17:
    sub_1003B47D(v2, a2);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1002FD39);
  }
LABEL_15:
  RaiseException(v5, dwExceptionFlags, v4, &Arguments);
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);
// 10061C68: using guessed type int (__stdcall *off_10061C68)(char);
// 10074200: using guessed type int __security_cookie;

//----- (1002FD39) --------------------------------------------------------
int __cdecl sub_1002FD39(int a1, int a2)
{
  int result; // eax@2

  if ( a1 )
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    result = sub_1002FC09(a1, *(_DWORD *)a2, *(_DWORD *)(a2 + 4));
  }
  return result;
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);

//----- (1002FD59) --------------------------------------------------------
void *__cdecl sub_1002FD59(void *a1)
{
  void *result; // eax@1
  int ebp0; // ebp@0
  int v3; // eax@1
  void *v4; // [sp+4h] [bp-4h]@1

  v3 = sub_1002F8DB(ebp0);
  result = sub_1002F75B(a1, v3);
  if ( v4 )
    result = (void *)sub_1000AA70(v4);
  return result;
}

//----- (1002FD89) --------------------------------------------------------
int __cdecl sub_1002FD89(int a1)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return result;
}

//----- (1002FD9C) --------------------------------------------------------
int __usercall sub_1002FD9C<eax>(int a1<ebp>)
{
  void *v1; // ecx@1

  sub_10035668();
  sub_1002FA13(a1);
  *(_DWORD *)(a1 - 4) = 0;
  sub_1002FD39(*(_DWORD *)(a1 + 8), a1 - 20);
  v1 = *(void **)(a1 - 16);
  *(_DWORD *)(a1 - 4) = -1;
  if ( v1 )
    sub_1000AA70(v1);
  return sub_10035636(8);
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1002FDDA) --------------------------------------------------------
int __cdecl sub_1002FDDA(int a1)
{
  return sub_1002F7B4(a1, 0);
}

//----- (1002FDE9) --------------------------------------------------------
void __usercall sub_1002FDE9(const void *a1<ecx>, int a2<edi>, const void **a3)
{
  sub_1002FC2C(*a3, a2);
}

//----- (1002FDF7) --------------------------------------------------------
unsigned int __userpurge sub_1002FDF7<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, unsigned int a4)
{
  unsigned int result; // eax@1
  int v5; // [sp-4h] [bp-10h]@5
  int (__stdcall **v6)(char); // [sp+0h] [bp-Ch]@5

  result = a4;
  if ( a4 )
  {
    if ( a4 > 0xAAAAAAA )
    {
      a4 = (unsigned int)"_DebugMallocator<T>::allocate() - Integer overflow.";
      sub_1002AEA4((int)&v6, (int *)&a4);
      v6 = &off_10060308;
      v5 = (int)&unk_1006BAE8;
    }
    else
    {
      result = sub_10037550(a1, a2, a3, 24 * a4);
      if ( result )
        return result;
      a4 = (unsigned int)"bad allocation";
      sub_1002AEC9((int)&v6, (int)&a4, 1);
      v6 = &off_100602D4;
      v5 = (int)&unk_1006BAB0;
    }
    sub_100355DB((int)&v6, v5);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1002FE69);
  }
  return result;
}
// 100602D4: using guessed type int (__stdcall *off_100602D4)(char);
// 10060308: using guessed type int (__stdcall *off_10060308)(char);

//----- (1002FE69) --------------------------------------------------------
unsigned int __userpurge sub_1002FE69<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, unsigned int a4)
{
  unsigned int result; // eax@1
  int v5; // [sp-4h] [bp-10h]@5
  int (__stdcall **v6)(char); // [sp+0h] [bp-Ch]@5

  result = a4;
  if ( a4 )
  {
    if ( a4 > 0x30C30C3 )
    {
      a4 = (unsigned int)"_DebugMallocator<T>::allocate() - Integer overflow.";
      sub_1002AEA4((int)&v6, (int *)&a4);
      v6 = &off_10060308;
      v5 = (int)&unk_1006BAE8;
    }
    else
    {
      result = sub_10037550(a1, a2, a3, 84 * a4);
      if ( result )
        return result;
      a4 = (unsigned int)"bad allocation";
      sub_1002AEC9((int)&v6, (int)&a4, 1);
      v6 = &off_100602D4;
      v5 = (int)&unk_1006BAB0;
    }
    sub_100355DB((int)&v6, v5);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1002FEDB);
  }
  return result;
}
// 100602D4: using guessed type int (__stdcall *off_100602D4)(char);
// 10060308: using guessed type int (__stdcall *off_10060308)(char);

//----- (1002FEDB) --------------------------------------------------------
int __usercall sub_1002FEDB<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  int ebp0; // ebp@0

  *(_DWORD *)a4 = sub_10032224(a1, a2, ebp0, a3);
  return a4;
}

//----- (1002FEEC) --------------------------------------------------------
int __usercall sub_1002FEEC<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4, int a5)
{
  int ebp0; // ebp@0
  int v7; // eax@1

  v7 = sub_10032224(a1, a2, ebp0, a3);
  return (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v7 + 44))(v7, a4, a5);
}

//----- (1002FF03) --------------------------------------------------------
int __thiscall sub_1002FF03(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10061BC4;
  return v2;
}
// 10061BC4: using guessed type int (__stdcall *off_10061BC4)(char);

//----- (1002FF15) --------------------------------------------------------
int __thiscall sub_1002FF15(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_100616A8;
  return v2;
}
// 100616A8: using guessed type int (__stdcall *off_100616A8)(char);

//----- (1002FF27) --------------------------------------------------------
int __thiscall sub_1002FF27(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10061D3C;
  return v2;
}
// 10061D3C: using guessed type int (__stdcall *off_10061D3C)(char);

//----- (1002FF39) --------------------------------------------------------
int __thiscall sub_1002FF39(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10061D30;
  return v2;
}
// 10061D30: using guessed type int (__stdcall *off_10061D30)(char);

//----- (1002FF4B) --------------------------------------------------------
int __thiscall sub_1002FF4B(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002AEA4(this, (int *)&a2);
  *(_DWORD *)v3 = &off_1006195C;
  return v3;
}
// 1006195C: using guessed type int (__stdcall *off_1006195C)(char);

//----- (1002FF67) --------------------------------------------------------
int __thiscall sub_1002FF67(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10061D18;
  return v2;
}
// 10061D18: using guessed type int (__stdcall *off_10061D18)(char);

//----- (1002FF79) --------------------------------------------------------
int __thiscall sub_1002FF79(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10061D24;
  return v2;
}
// 10061D24: using guessed type int (__stdcall *off_10061D24)(char);

//----- (1002FF8B) --------------------------------------------------------
int __thiscall sub_1002FF8B(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002AEA4(this, (int *)&a2);
  *(_DWORD *)v3 = &off_100616C0;
  return v3;
}
// 100616C0: using guessed type int (__stdcall *off_100616C0)(char);

//----- (1002FFA7) --------------------------------------------------------
int __thiscall sub_1002FFA7(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10061BDC;
  return v2;
}
// 10061BDC: using guessed type int (__stdcall *off_10061BDC)(char);

//----- (1002FFB9) --------------------------------------------------------
int __thiscall sub_1002FFB9(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002AEA4(this, (int *)&a2);
  *(_DWORD *)v3 = &off_100616CC;
  return v3;
}
// 100616CC: using guessed type int (__stdcall *off_100616CC)(char);

//----- (1002FFD5) --------------------------------------------------------
int __thiscall sub_1002FFD5(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_100616CC;
  return v2;
}
// 100616CC: using guessed type int (__stdcall *off_100616CC)(char);

//----- (1002FFE7) --------------------------------------------------------
int __thiscall sub_1002FFE7(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10061D78;
  return v2;
}
// 10061D78: using guessed type int (__stdcall *off_10061D78)(char);

//----- (1002FFF9) --------------------------------------------------------
int __thiscall sub_1002FFF9(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002AEA4(this, (int *)&a2);
  *(_DWORD *)v3 = &off_10061D48;
  return v3;
}
// 10061D48: using guessed type int (__stdcall *off_10061D48)(char);

//----- (10030015) --------------------------------------------------------
int __thiscall sub_10030015(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10061D60;
  return v2;
}
// 10061D60: using guessed type int (__stdcall *off_10061D60)(char);

//----- (10030027) --------------------------------------------------------
int __thiscall sub_10030027(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002AEA4(this, (int *)&a2);
  *(_DWORD *)v3 = &off_10061D54;
  return v3;
}
// 10061D54: using guessed type int (__stdcall *off_10061D54)(char);

//----- (10030043) --------------------------------------------------------
int __thiscall sub_10030043(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_100616B4;
  return v2;
}
// 100616B4: using guessed type int (__stdcall *off_100616B4)(char);

//----- (10030055) --------------------------------------------------------
int __thiscall sub_10030055(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10061BD0;
  return v2;
}
// 10061BD0: using guessed type int (__stdcall *off_10061BD0)(char);

//----- (10030067) --------------------------------------------------------
int __thiscall sub_10030067(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10061D6C;
  return v2;
}
// 10061D6C: using guessed type int (__stdcall *off_10061D6C)(char);

//----- (10030079) --------------------------------------------------------
int __thiscall sub_10030079(int this, int a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002AF07(this);
  *(_DWORD *)(v3 + 12) = a2;
  *(_DWORD *)v3 = &off_10061CF4;
  return v3;
}
// 10061CF4: using guessed type int (__stdcall *off_10061CF4)(char);

//----- (10030097) --------------------------------------------------------
int __thiscall sub_10030097(int this, int a2)
{
  int v3; // esi@1

  v3 = this;
  sub_10030079(this, a2);
  *(_DWORD *)v3 = &off_10061D00;
  return v3;
}
// 10061D00: using guessed type int (__stdcall *off_10061D00)(char);

//----- (100300B2) --------------------------------------------------------
int __thiscall sub_100300B2(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10061D84;
  return v2;
}
// 10061D84: using guessed type int (__stdcall *off_10061D84)(char);

//----- (100300C4) --------------------------------------------------------
int __thiscall sub_100300C4(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10061D0C;
  return v2;
}
// 10061D0C: using guessed type int (__stdcall *off_10061D0C)(char);

//----- (100300E0) --------------------------------------------------------
int __cdecl sub_100300E0(int a1, unsigned __int8 a2, int a3)
{
  int result; // eax@1
  int v4; // edx@2
  int v5; // ebx@2
  unsigned __int8 v6; // cl@3
  char v7; // cf@6
  int v8; // eax@6
  char v9; // zf@8
  unsigned __int8 v10; // cl@9
  char v11; // cf@12
  int v12; // ecx@13
  unsigned int v13; // ecx@14
  unsigned int v14; // ecx@16

  result = a3;
  if ( a3 )
  {
    v4 = a1;
    LOBYTE(v5) = a2;
    while ( v4 & 3 )
    {
      v6 = *(_BYTE *)v4++;
      if ( !(a2 ^ v6) )
        return v4 - 1;
      --result;
      if ( !result )
        return result;
    }
    v7 = (unsigned int)result < 4;
    v8 = result - 4;
    if ( !v7 )
    {
      v5 = 16843009 * a2;
      do
      {
        v12 = v5 ^ *(_DWORD *)v4;
        v4 += 4;
        if ( ((v12 + 2130640639) ^ ~v12) & 0x81010100 )
        {
          v13 = *(_DWORD *)(v4 - 4);
          LOBYTE(v13) = v5 ^ v13;
          if ( !(_BYTE)v13 )
            return v4 - 4;
          BYTE1(v13) ^= v5;
          if ( !BYTE1(v13) )
            return v4 - 3;
          v14 = v13 >> 16;
          if ( !((_BYTE)v5 ^ (_BYTE)v14) )
            return v4 - 2;
          if ( !((_BYTE)v5 ^ BYTE1(v14)) )
            return v4 - 1;
        }
        v11 = (unsigned int)v8 < 4;
        v8 -= 4;
      }
      while ( !v11 );
    }
    v9 = v8 == -4;
    result = v8 + 4;
    if ( !v9 )
    {
      while ( 1 )
      {
        v10 = *(_BYTE *)v4++;
        if ( !((_BYTE)v5 ^ v10) )
          break;
        --result;
        if ( !result )
          return result;
      }
      return v4 - 1;
    }
  }
  return result;
}

//----- (1003018D) --------------------------------------------------------
int __userpurge sub_1003018D<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  int v4; // esi@1
  int v5; // edx@2
  int v6; // eax@4
  int v7; // eax@7
  int v8; // eax@8
  int v9; // ecx@8

  v4 = a1;
  *(_BYTE *)(a1 + 12) = 0;
  if ( a4 )
  {
    *(_DWORD *)a1 = *(_DWORD *)a4;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a4 + 4);
  }
  else
  {
    v5 = sub_10041A5C(a2, a3);
    *(_DWORD *)(v4 + 8) = v5;
    *(_DWORD *)v4 = *(_DWORD *)(v5 + 108);
    *(_DWORD *)(v4 + 4) = *(_DWORD *)(v5 + 104);
    if ( *(volatile LONG **)v4 != off_10074B44 )
    {
      if ( !(dword_10074C0C & *(_DWORD *)(v5 + 112)) )
      {
        sub_10041EAE(a2, a3);
        *(_DWORD *)v4 = v6;
      }
    }
    if ( *(LPVOID *)(v4 + 4) != lpAddend )
    {
      if ( !(dword_10074C0C & *(_DWORD *)(*(_DWORD *)(v4 + 8) + 112)) )
      {
        sub_10042230(a2, a3);
        *(_DWORD *)(v4 + 4) = v7;
      }
    }
    v9 = *(_DWORD *)(v4 + 8);
    v8 = *(_DWORD *)(v9 + 112);
    if ( !(v8 & 2) )
    {
      *(_DWORD *)(v9 + 112) = v8 | 2;
      *(_BYTE *)(v4 + 12) = 1;
    }
  }
  return v4;
}
// 10074C0C: using guessed type int dword_10074C0C;

//----- (10030215) --------------------------------------------------------
int __usercall sub_10030215<eax>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // ecx@2
  int v6; // eax@3
  __int16 v7; // ax@4
  int v8; // ecx@6
  int result; // eax@8
  int v10; // ecx@14
  unsigned int v11; // eax@16
  int v12; // edx@22
  int v13; // [sp+4h] [bp-18h]@1
  int v14; // [sp+Ch] [bp-10h]@7
  char v15; // [sp+10h] [bp-Ch]@6
  WCHAR DestStr; // [sp+14h] [bp-8h]@16
  const CHAR MultiByteStr; // [sp+18h] [bp-4h]@14
  char v18; // [sp+19h] [bp-3h]@14
  char v19; // [sp+1Ah] [bp-2h]@14
  int v20; // [sp+24h] [bp+8h]@13

  sub_1003018D((int)&v13, a1, a2, a4);
  v4 = a3;
  if ( (unsigned int)a3 < 0x100 )
  {
    v5 = v13;
    if ( *(_DWORD *)(v13 + 116) <= 1 )
    {
      v7 = *(_WORD *)(*(_DWORD *)(v13 + 144) + 2 * a3);
      v6 = v7 & 2;
    }
    else
    {
      v6 = sub_10042678(a3, a2, a3, 2, (int)&v13);
      v5 = v13;
    }
    if ( v6 )
    {
      v8 = *(_BYTE *)(*(_DWORD *)(v5 + 152) + a3);
      if ( v15 )
        *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
      return v8;
    }
    if ( v15 )
      *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
    return v4;
  }
  if ( *(_DWORD *)(v13 + 116) > 1 && (v20 = a3 >> 8, sub_10042727(v4, a2, BYTE1(v4), (int)&v13)) )
  {
    MultiByteStr = v20;
    v18 = v4;
    v19 = 0;
    v10 = 2;
  }
  else
  {
    *(_DWORD *)sub_10037669(v4) = 42;
    MultiByteStr = v4;
    v18 = 0;
    v10 = 1;
  }
  v11 = sub_100374C2(
          v4,
          a2,
          (int)&v13,
          *(_DWORD *)(v13 + 168),
          0x200u,
          &MultiByteStr,
          v10,
          &DestStr,
          3,
          *(_DWORD *)(v13 + 4),
          1);
  if ( !v11 )
  {
    if ( v15 )
      *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
    return v4;
  }
  if ( v11 == 1 )
  {
    result = (unsigned __int8)DestStr;
    if ( v15 )
      *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
  }
  else
  {
    v12 = HIBYTE(DestStr) | ((unsigned __int8)DestStr << 8);
    if ( v15 )
      *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
    result = v12;
  }
  return result;
}

//----- (10030357) --------------------------------------------------------
int __usercall sub_10030357<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // ecx@2
  int result; // eax@4

  if ( dword_10077048 )
  {
    result = sub_10030215(a1, a2, a3, 0);
  }
  else
  {
    v3 = a3;
    if ( (unsigned int)(a3 - 97) <= 0x19 )
      v3 = a3 - 32;
    result = v3;
  }
  return result;
}
// 10077048: using guessed type int dword_10077048;

//----- (10030388) --------------------------------------------------------
signed int __usercall sub_10030388<eax>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  signed int v5; // eax@4
  int v6; // ebx@4
  unsigned int v7; // ebx@11
  int v8; // esi@11
  __int64 v9; // qax@11
  __int64 v10; // qax@11
  unsigned __int8 v11; // cf@11
  char v12; // zf@14
  int v13; // ecx@14
  unsigned __int8 v14; // cf@14
  unsigned __int8 v15; // cf@19
  char v16; // zf@20
  int *v17; // ecx@26
  int v18; // ebx@26
  int v19; // esi@26
  unsigned __int64 v20; // ST00_8@26
  int v21; // eax@26
  __int64 v22; // qax@26
  unsigned __int8 v23; // cf@26
  signed int v24; // eax@28
  int v25; // edx@28
  int v26; // eax@30
  int v27; // eax@30
  unsigned __int64 v28; // ST00_8@30
  int v29; // eax@30
  __int64 v30; // qax@30
  unsigned __int8 v31; // cf@30
  int v32; // ebx@30
  unsigned __int64 v33; // ST00_8@30
  int v34; // eax@30
  signed int v35; // [sp+4h] [bp-18h]@11
  signed int v36; // [sp+8h] [bp-14h]@4
  signed int v37; // [sp+14h] [bp-8h]@11
  signed int v38; // [sp+18h] [bp-4h]@1

  v38 = 0;
  if ( !a3 || (sub_10039210((void *)a3, 0xFFu, 36), !a4) )
  {
    *(_DWORD *)sub_10037669(a1) = 22;
    sub_1003A16E(a1, a2);
    return 22;
  }
  v6 = *(_DWORD *)a4;
  v5 = *(_DWORD *)(a4 + 4);
  v36 = v5;
  if ( v5 <= -1 && (v5 < -1 || (unsigned int)v6 < 0xFFFF5740) || v5 >= 7 && (v5 > 7 || (unsigned int)v6 > 0x934126CF) )
  {
    *(_DWORD *)sub_10037669(v6) = 22;
    return 22;
  }
  v37 = sub_1003AC50(*(_QWORD *)a4, 0x1E13380u, 0) + 70;
  v35 = v37 - 1;
  v9 = sub_10039A40(v37 - 70, -365i64);
  v10 = sub_10039A40(v9 - ((v37 + 299) / 400 - (v37 - 1) / 100 + (v37 - 1) / 4 - 17), 86400i64);
  v11 = (_DWORD)v10 >= (unsigned int)-v6;
  v7 = v10 + v6;
  v8 = HIDWORD(v10) + v11 + v36;
  if ( v8 <= 0 && v8 < 0 )
  {
    v13 = v37 - 1;
    v14 = v7 >= 0xFE1ECC80;
    v7 += 31536000;
    v8 += v14;
    v12 = (v35 & 0x80000003) == 0;
    if ( (v35 & 0x80000003) < 0 )
      v12 = (((v35 & 0x80000003) - 1) | 0xFFFFFFFC) == -1;
    if ( (!v12 || !(v35 % 100)) && (v35 + 1900) % 400 )
      goto LABEL_26;
    v15 = v7 >= 0xFFFEAE80;
    v7 += 86400;
    v8 += v15;
  }
  else
  {
    v13 = v37;
    v16 = (v37 & 0x80000003) == 0;
    if ( (v37 & 0x80000003) < 0 )
      v16 = (((v37 & 0x80000003) - 1) | 0xFFFFFFFC) == -1;
    if ( (!v16 || !(v37 % 100)) && (v37 + 1900) % 400 )
      goto LABEL_26;
  }
  v38 = 1;
LABEL_26:
  HIDWORD(v20) = v8;
  LODWORD(v20) = v7;
  *(_DWORD *)(a3 + 20) = v13;
  v21 = sub_1003AC50(v20, 0x15180u, 0);
  *(_DWORD *)(a3 + 28) = v21;
  v22 = sub_10039A40(v21, -86400i64);
  v23 = (_DWORD)v22 >= (unsigned int)-v7;
  v18 = v22 + v7;
  v19 = HIDWORD(v22) + v23 + v8;
  v17 = &dword_10074324;
  if ( !v38 )
    v17 = dword_100742F0;
  v25 = *(_DWORD *)(a3 + 28);
  v24 = 1;
  if ( v17[1] < v25 )
  {
    do
      ++v24;
    while ( v17[v24] < v25 );
  }
  v26 = v24 - 1;
  *(_DWORD *)(a3 + 16) = v26;
  *(_DWORD *)(a3 + 12) = v25 - v17[v26];
  v27 = sub_1003AC50(*(_QWORD *)a4, 0x15180u, 0);
  HIDWORD(v28) = v19;
  LODWORD(v28) = v18;
  *(_DWORD *)(a3 + 24) = (v27 + 4) % 7;
  v29 = sub_1003AC50(v28, 0xE10u, 0);
  *(_DWORD *)(a3 + 8) = v29;
  v30 = sub_10039A40(v29, -3600i64);
  v31 = (_DWORD)v30 >= (unsigned int)-v18;
  v32 = v30 + v18;
  HIDWORD(v33) = HIDWORD(v30) + v31 + v19;
  LODWORD(v33) = v32;
  v34 = sub_1003AC50(v33, 0x3Cu, 0);
  *(_DWORD *)(a3 + 32) = 0;
  *(_DWORD *)(a3 + 4) = v34;
  *(_DWORD *)a3 = v32 - 60 * v34;
  return 0;
}
// 100742F0: using guessed type int dword_100742F0[];
// 10074324: using guessed type int dword_10074324;

//----- (100305B1) --------------------------------------------------------
signed int __usercall sub_100305B1<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6)
{
  int v6; // edx@1
  int v8; // esi@9
  int v9; // eax@11
  int v10; // ebx@14
  int v11; // edi@14
  char v12; // al@15
  char v13; // al@18
  char v14; // zf@23
  int v15; // [sp-8h] [bp-Ch]@14
  signed int v16; // [sp-4h] [bp-8h]@11
  int v17; // [sp-4h] [bp-8h]@14

  v6 = a6;
  if ( a6 )
  {
    if ( !a3 )
    {
LABEL_11:
      v9 = sub_10037669(a1);
      v16 = 22;
LABEL_12:
      *(_DWORD *)v9 = v16;
      sub_1003A16E(a1, a2);
      return v16;
    }
  }
  else
  {
    if ( !a3 )
    {
      if ( !a4 )
        return 0;
      goto LABEL_11;
    }
  }
  if ( !a4 )
    goto LABEL_11;
  if ( !a6 )
  {
    *(_BYTE *)a3 = 0;
    return 0;
  }
  v8 = a5;
  if ( !a5 )
  {
    *(_BYTE *)a3 = 0;
    goto LABEL_11;
  }
  v17 = a1;
  v15 = a2;
  v10 = a3;
  v11 = a4;
  if ( a6 == -1 )
  {
    do
    {
      v12 = *(_BYTE *)v8;
      *(_BYTE *)(a3 - a5 + v8) = *(_BYTE *)v8;
      ++v8;
      if ( !v12 )
        break;
      --v11;
    }
    while ( v11 );
  }
  else
  {
    do
    {
      v13 = *(_BYTE *)(a5 - a3 + v10);
      *(_BYTE *)v10++ = v13;
      if ( !v13 )
        break;
      --v11;
      if ( !v11 )
        break;
      --v6;
    }
    while ( v6 );
    if ( !v6 )
      *(_BYTE *)v10 = 0;
  }
  v14 = v11 == 0;
  a2 = v15;
  a1 = v17;
  if ( !v14 )
    return 0;
  if ( v6 != -1 )
  {
    *(_BYTE *)a3 = 0;
    v9 = sub_10037669(v17);
    v16 = 34;
    goto LABEL_12;
  }
  *(_BYTE *)(a3 + a4 - 1) = 0;
  return 80;
}

//----- (10030655) --------------------------------------------------------
int __cdecl sub_10030655(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  dword_100766BC = IsDebuggerPresent();
  sub_1004362C();
  sub_10039889(ExceptionInfo);
  if ( !dword_100766BC )
    sub_1004362C();
  return sub_10039874(0xC0000409u);
}
// 100766BC: using guessed type int dword_100766BC;

//----- (10030692) --------------------------------------------------------
int __usercall sub_10030692<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, char a4)
{
  BOOL v8; // eax@1
  int v9; // edx@1
  signed int v10; // ecx@1
  int v12; // ST328_4@3
  int v13; // [sp-4h] [bp-328h]@1
  int v14; // [sp+328h] [bp+4h]@3

  v8 = IsProcessorFeaturePresent(0x17u);
  _OF = 0;
  _CF = 0;
  _ZF = v8 == 0;
  _SF = v8 < 0;
  if ( v8 )
  {
    v10 = 2;
    __asm { int     29h             ; DOS 2+ internal - FAST PUTCHAR }
  }
  dword_100764A0 = v8;
  dword_1007649C = v10;
  dword_10076498 = v9;
  dword_10076494 = a1;
  dword_10076490 = a3;
  dword_1007648C = a2;
  word_100764B8 = __SS__;
  word_100764AC = __CS__;
  word_10076488 = __DS__;
  word_10076484 = __ES__;
  word_10076480 = __FS__;
  word_1007647C = __GS__;
  __asm { pushf }
  dword_100764B0 = v13;
  dword_100764A4 = v12;
  dword_100764A8 = v14;
  dword_100764B4 = (int)&a4;
  dword_100763F0 = 65537;
  dword_100763AC = dword_100764A8;
  dword_100763A0 = -1073740791;
  dword_100763A4 = 1;
  dword_100763B0 = 1;
  dword_100763B4 = 2;
  return sub_10030655(&ExceptionInfo);
}
// 100763A0: using guessed type int dword_100763A0;
// 100763A4: using guessed type int dword_100763A4;
// 100763AC: using guessed type int dword_100763AC;
// 100763B0: using guessed type int dword_100763B0;
// 100763B4: using guessed type int dword_100763B4;
// 100763F0: using guessed type int dword_100763F0;
// 1007647C: using guessed type __int16 word_1007647C;
// 10076480: using guessed type __int16 word_10076480;
// 10076484: using guessed type __int16 word_10076484;
// 10076488: using guessed type __int16 word_10076488;
// 1007648C: using guessed type int dword_1007648C;
// 10076490: using guessed type int dword_10076490;
// 10076494: using guessed type int dword_10076494;
// 10076498: using guessed type int dword_10076498;
// 1007649C: using guessed type int dword_1007649C;
// 100764A0: using guessed type int dword_100764A0;
// 100764A4: using guessed type int dword_100764A4;
// 100764A8: using guessed type int dword_100764A8;
// 100764AC: using guessed type __int16 word_100764AC;
// 100764B0: using guessed type int dword_100764B0;
// 100764B4: using guessed type int dword_100764B4;
// 100764B8: using guessed type __int16 word_100764B8;

//----- (1003078B) --------------------------------------------------------
int __usercall sub_1003078B<eax>(int a1<ebx>, int a2<edi>, int a3<esi>)
{
  return sub_10030797(a1, a2, a3, 8);
}

//----- (10030797) --------------------------------------------------------
int __usercall sub_10030797<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, int a4)
{
  BOOL v8; // eax@1
  int v9; // edx@1
  int v10; // ecx@1
  int v12; // ST320_4@3
  int v13; // [sp-4h] [bp-320h]@1
  int v14; // [sp+320h] [bp+4h]@3

  v8 = IsProcessorFeaturePresent(0x17u);
  _OF = 0;
  _CF = 0;
  _ZF = v8 == 0;
  _SF = v8 < 0;
  if ( v8 )
  {
    v10 = a4;
    __asm { int     29h             ; DOS 2+ internal - FAST PUTCHAR }
  }
  dword_100764A0 = v8;
  dword_1007649C = v10;
  dword_10076498 = v9;
  dword_10076494 = a1;
  dword_10076490 = a3;
  dword_1007648C = a2;
  word_100764B8 = __SS__;
  word_100764AC = __CS__;
  word_10076488 = __DS__;
  word_10076484 = __ES__;
  word_10076480 = __FS__;
  word_1007647C = __GS__;
  __asm { pushf }
  dword_100764B0 = v13;
  dword_100764A4 = v12;
  dword_100764A8 = v14;
  dword_100764B4 = (int)&a4;
  dword_100763AC = dword_100764A8;
  dword_100763A0 = -1073740791;
  dword_100763A4 = 1;
  dword_100763B0 = 1;
  dword_100763B4 = a4;
  return sub_10030655(&ExceptionInfo);
}
// 100763A0: using guessed type int dword_100763A0;
// 100763A4: using guessed type int dword_100763A4;
// 100763AC: using guessed type int dword_100763AC;
// 100763B0: using guessed type int dword_100763B0;
// 100763B4: using guessed type int dword_100763B4;
// 1007647C: using guessed type __int16 word_1007647C;
// 10076480: using guessed type __int16 word_10076480;
// 10076484: using guessed type __int16 word_10076484;
// 10076488: using guessed type __int16 word_10076488;
// 1007648C: using guessed type int dword_1007648C;
// 10076490: using guessed type int dword_10076490;
// 10076494: using guessed type int dword_10076494;
// 10076498: using guessed type int dword_10076498;
// 1007649C: using guessed type int dword_1007649C;
// 100764A0: using guessed type int dword_100764A0;
// 100764A4: using guessed type int dword_100764A4;
// 100764A8: using guessed type int dword_100764A8;
// 100764AC: using guessed type __int16 word_100764AC;
// 100764B0: using guessed type int dword_100764B0;
// 100764B4: using guessed type int dword_100764B4;
// 100764B8: using guessed type __int16 word_100764B8;

//----- (10030865) --------------------------------------------------------
int __usercall sub_10030865<eax>(int a1<ebx>, int a2, int a3, char a4)
{
  return sub_10030883(a1, sub_100436D6, a2, a3, 0, (int)&a4);
}

//----- (10030883) --------------------------------------------------------
int __usercall sub_10030883<eax>(int a1<ebx>, int (__cdecl *a2)(_DWORD, _DWORD, _DWORD, _DWORD), int a3, int a4, int a5, int a6)
{
  int result; // eax@2
  int v7; // eax@4
  int v8; // [sp+8h] [bp-20h]@1
  int v9; // [sp+Ch] [bp-1Ch]@1
  int v10; // [sp+10h] [bp-18h]@4
  int v11; // [sp+14h] [bp-14h]@4
  int v12; // [sp+28h] [bp+0h]@2

  v8 = 0;
  memset(&v9, 0, 0x1Cu);
  if ( a3 && a4 )
  {
    v7 = sub_10035550(a3);
    v11 = 73;
    v10 = a3;
    v8 = a3;
    v9 = 2147483647;
    if ( (unsigned int)v7 <= 0x7FFFFFFF )
      v9 = v7;
    result = a2(&v8, a4, a5, a6);
  }
  else
  {
    *(_DWORD *)sub_10037669(a1) = 22;
    sub_1003A16E(a1, (int)&v12);
    result = -1;
  }
  return result;
}

//----- (100308F4) --------------------------------------------------------
int __usercall sub_100308F4<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned int a4, int a5, char a6)
{
  return sub_10044A07(a1, a2, a3, a4, a5, 0, (int)&a6);
}

//----- (10030910) --------------------------------------------------------
int __usercall sub_10030910<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int dwBytes)
{
  HMODULE v5; // ecx@3
  SIZE_T v6; // ecx@6
  bool v7; // eax@10
  int v8; // ST08_4@10
  int result; // eax@14

  if ( (unsigned int)dwBytes > 0xFFFFFFE0 )
  {
    sub_1003ADB2(dwBytes);
    *(_DWORD *)sub_10037669(a3) = 12;
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      if ( !hHeap )
      {
        sub_1003F5BC(a1, a2, a3, a4);
        sub_1003F619(a3, 30);
        sub_1003AE6C(v5, 0xFFu);
      }
      v6 = dwBytes ? dwBytes : 1;
      a4 = (int)HeapAlloc(hHeap, 0, v6);
      if ( a4 )
        break;
      a3 = 12;
      if ( !dword_1007704C )
      {
        *(_DWORD *)sub_10037669(12) = 12;
LABEL_13:
        *(_DWORD *)sub_10037669(12) = 12;
        break;
      }
      v7 = sub_1003ADB2(dwBytes);
      a2 = v8;
      if ( !v7 )
        goto LABEL_13;
    }
    result = a4;
  }
  return result;
}
// 1007704C: using guessed type int dword_1007704C;

//----- (100309A2) --------------------------------------------------------
void __usercall sub_100309A2(int a1<ebx>, LPVOID lpMem)
{
  int v2; // esi@3
  int v3; // eax@3

  if ( lpMem )
  {
    if ( !HeapFree(hHeap, 0, lpMem) )
    {
      v2 = sub_10037669(a1);
      v3 = GetLastError();
      *(_DWORD *)v2 = sub_1003767C(v3);
    }
  }
}

//----- (100309DA) --------------------------------------------------------
signed int __stdcall sub_100309DA(int a1, int a2, int a3, void (__thiscall *a4)(_DWORD), int a5)
{
  int v5; // edi@1
  int v6; // esi@1

  v6 = 0;
  v5 = a1;
  while ( v6 < a3 )
  {
    a4(v5);
    v5 += a2;
    ++v6;
  }
  return 1;
}

//----- (10030A50) --------------------------------------------------------
int __cdecl sub_10030A50(int a1, unsigned __int8 a2)
{
  signed int v2; // eax@2
  int result; // eax@5
  int v14; // edx@8
  char v15; // cl@9
  int v16; // ebx@12
  int v17; // eax@13
  int v18; // esi@13
  int v19; // ecx@13
  int v20; // eax@14
  unsigned int v21; // eax@19
  unsigned int v22; // eax@23

  if ( (unsigned int)dword_1007689C < 1 )
  {
    v14 = a1;
    if ( a1 & 3 )
    {
      while ( 1 )
      {
        v15 = *(_BYTE *)v14++;
        if ( v15 == a2 )
          break;
        if ( !v15 )
          return 0;
        if ( !(v14 & 3) )
          goto LABEL_12;
      }
      result = v14 - 1;
    }
    else
    {
LABEL_12:
      v16 = (a2 << 8) | a2 | (((a2 << 8) | a2) << 16);
      while ( 1 )
      {
        while ( 1 )
        {
          v19 = v16 ^ *(_DWORD *)v14;
          v18 = *(_DWORD *)v14 + 2130640639;
          v17 = (*(_DWORD *)v14 + 2130640639) ^ ~*(_DWORD *)v14;
          v14 += 4;
          if ( ((v19 + 2130640639) ^ ~v19) & 0x81010100 )
            break;
          v20 = v17 & 0x81010100;
          if ( v20 && (v20 & 0x1010100 || !(v18 & 0x80000000)) )
            return 0;
        }
        v21 = *(_DWORD *)(v14 - 4);
        if ( (_BYTE)v21 == (_BYTE)v16 )
          break;
        if ( !(_BYTE)v21 )
          return 0;
        if ( BYTE1(v21) == (_BYTE)v16 )
          return v14 - 3;
        if ( !BYTE1(v21) )
          return 0;
        v22 = v21 >> 16;
        if ( (_BYTE)v22 == (_BYTE)v16 )
          return v14 - 2;
        if ( !(_BYTE)v22 )
          return 0;
        if ( BYTE1(v22) == (_BYTE)v16 )
          return v14 - 1;
        if ( !BYTE1(v22) )
          return 0;
      }
      result = v14 - 4;
    }
  }
  else
  {
    _EDX = (a2 << 8) | a2;
    __asm
    {
      movd    xmm3, edx
      pshuflw xmm3, xmm3, 0
      movlhps xmm3, xmm3
    }
    v2 = -1 << (a1 & 0xF);
    for ( _EDX = a1 - (a1 & 0xF); ; _EDX += 16 )
    {
      __asm
      {
        movdqu  xmm1, xmmword ptr [edx]
        pxor    xmm2, xmm2
        pcmpeqb xmm2, xmm1
        pcmpeqb xmm1, xmm3
        por     xmm2, xmm1
        pmovmskb ecx, xmm2
      }
      _ECX = v2 & _ECX;
      if ( _ECX )
        break;
      v2 = -1;
    }
    __asm { bsf     eax, ecx }
    result = _EDX + _EAX;
    __asm { movd    edx, xmm3 }
    if ( (_BYTE)_EDX != *(_BYTE *)result )
      result = 0;
  }
  return result;
}
// 1007689C: using guessed type int dword_1007689C;

//----- (10030B80) --------------------------------------------------------
char __cdecl sub_10030B80(int a1, int a2)
{
  int v3; // edx@1
  int v8; // esi@4
  int v14; // [sp+0h] [bp-24h]@1

  _EAX = 0;
  v14 = 0;
  v3 = a2;
  while ( 1 )
  {
    LOBYTE(_EAX) = *(_BYTE *)v3;
    if ( !*(_BYTE *)v3 )
      break;
    ++v3;
    __asm { bts     [esp+24h+var_24], eax }
  }
  v8 = a1;
  while ( 1 )
  {
    LOBYTE(_EAX) = *(_BYTE *)v8;
    if ( !*(_BYTE *)v8 )
      break;
    ++v8;
    __asm { bt      [esp+24h+var_24], eax }
    if ( _CF )
      return v8 - 1;
  }
  return _EAX;
}

//----- (10030BC0) --------------------------------------------------------
void **__usercall sub_10030BC0<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1

  v2 = sub_10041A5C(a1, a2);
  if ( *(volatile LONG **)(v2 + 108) != off_10074B44 )
  {
    if ( !(dword_10074C0C & *(_DWORD *)(v2 + 112)) )
      sub_10041EAE(a1, a2);
  }
  return off_10073C50;
}
// 10073C50: using guessed type void **off_10073C50;
// 10074C0C: using guessed type int dword_10074C0C;

//----- (10030BF0) --------------------------------------------------------
signed int __cdecl sub_10030BF0(int a1, int a2)
{
  int v3; // edx@1
  signed int v8; // ecx@4
  int v9; // esi@4
  int v15; // [sp+0h] [bp-24h]@1

  _EAX = 0;
  v15 = 0;
  v3 = a2;
  while ( 1 )
  {
    LOBYTE(_EAX) = *(_BYTE *)v3;
    if ( !*(_BYTE *)v3 )
      break;
    ++v3;
    __asm { bts     [esp+24h+var_24], eax }
  }
  v9 = a1;
  v8 = -1;
  do
  {
    ++v8;
    LOBYTE(_EAX) = *(_BYTE *)v9;
    if ( !*(_BYTE *)v9 )
      break;
    ++v9;
    __asm { bt      [esp+24h+var_24], eax }
  }
  while ( !_CF );
  return v8;
}

//----- (10030C36) --------------------------------------------------------
int __usercall sub_10030C36<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, LPVOID lpMem, int dwBytes)
{
  signed int v7; // esi@3
  int v8; // esi@15
  int v9; // eax@15
  int v10; // esi@16
  int v11; // eax@16

  if ( !lpMem )
    return sub_10030910(a1, a2, a3, a4, dwBytes);
  v7 = dwBytes;
  if ( !dwBytes )
  {
    sub_100309A2(a3, lpMem);
    return 0;
  }
  while ( 1 )
  {
    if ( (unsigned int)v7 > 0xFFFFFFE0 )
    {
      sub_1003ADB2(v7);
      *(_DWORD *)sub_10037669(a3) = 12;
      return 0;
    }
    if ( !v7 )
      v7 = 1;
    a3 = (int)HeapReAlloc(hHeap, 0, lpMem, v7);
    if ( a3 )
      return a3;
    if ( !dword_1007704C )
      break;
    if ( !sub_1003ADB2(v7) )
    {
      v8 = sub_10037669(a3);
      v9 = GetLastError();
      *(_DWORD *)v8 = sub_1003767C(v9);
      return 0;
    }
  }
  v10 = sub_10037669(a3);
  v11 = GetLastError();
  *(_DWORD *)v10 = sub_1003767C(v11);
  return a3;
}
// 1007704C: using guessed type int dword_1007704C;

//----- (10030CE1) --------------------------------------------------------
void *__thiscall sub_10030CE1(void *this)
{
  void *v1; // ebx@1
  HMODULE v2; // edi@1
  int v3; // eax@4
  int v4; // eax@4
  int v5; // eax@4
  int v6; // eax@4
  int v7; // eax@4
  int v8; // eax@4

  v1 = this;
  v2 = LoadLibraryExW(L"advapi32.dll", 0, 0x800u);
  if ( v2 || GetLastError() == 87 && (v2 = LoadLibraryW(L"advapi32.dll")) != 0 )
  {
    v3 = (int)GetProcAddress(v2, "RegisterTraceGuidsW");
    *(_DWORD *)v1 = sub_1003491A(v3);
    v4 = (int)GetProcAddress(v2, "UnregisterTraceGuids");
    *((_DWORD *)v1 + 1) = sub_1003491A(v4);
    v5 = (int)GetProcAddress(v2, "TraceEvent");
    *((_DWORD *)v1 + 2) = sub_1003491A(v5);
    v6 = (int)GetProcAddress(v2, "GetTraceLoggerHandle");
    *((_DWORD *)v1 + 3) = sub_1003491A(v6);
    v7 = (int)GetProcAddress(v2, "GetTraceEnableLevel");
    *((_DWORD *)v1 + 4) = sub_1003491A(v7);
    v8 = (int)GetProcAddress(v2, "GetTraceEnableFlags");
    *((_DWORD *)v1 + 5) = sub_1003491A(v8);
  }
  return v1;
}

//----- (10030DA0) --------------------------------------------------------
signed int __stdcall sub_10030DA0(int a1, int a2, int a3, int a4)
{
  signed int result; // eax@3
  int v5; // edx@5
  char v6; // bl@7
  int v7; // eax@10

  if ( a1 == 4 )
  {
    dword_100766D0 = sub_10030ECB(dword_100766D8, a4);
    dword_100766D4 = v5;
    if ( dword_100766D0 == -1 )
      return GetLastError();
    SetLastError(0);
    v6 = sub_10030E98(dword_100766D8, dword_100766D0, dword_100766D4);
    if ( !v6 )
    {
      result = GetLastError();
      if ( result )
        return result;
      v6 = 4;
    }
    v7 = sub_10030E65(dword_100766D8, dword_100766D0, dword_100766D4);
    if ( !v7 )
    {
      result = GetLastError();
      if ( result )
        return result;
      v7 = -1;
    }
    dword_100766C8 = v7;
    byte_100766CC = v6;
  }
  else
  {
    if ( a1 != 5 )
      return 87;
    byte_100766CC = 0;
    dword_100766C8 = 0;
    dword_100766D0 = 0;
    dword_100766D4 = 0;
  }
  return 0;
}
// 100766C8: using guessed type int dword_100766C8;
// 100766CC: using guessed type char byte_100766CC;
// 100766D0: using guessed type int dword_100766D0;
// 100766D4: using guessed type int dword_100766D4;
// 100766D8: using guessed type int dword_100766D8;

//----- (10030E65) --------------------------------------------------------
int __thiscall sub_10030E65(int this, int a2, int a3)
{
  int v3; // esi@1
  int result; // eax@2
  int v5; // eax@2
  int v6; // ST04_4@2

  v3 = *(_DWORD *)(this + 20);
  if ( (PVOID)v3 == EncodePointer(0) )
  {
    SetLastError(0x7Fu);
    result = 0;
  }
  else
  {
    v5 = sub_1003491A(v3);
    result = ((int (__thiscall *)(int, int, int))v5)(v6, a2, a3);
  }
  return result;
}

//----- (10030E98) --------------------------------------------------------
char __thiscall sub_10030E98(int this, int a2, int a3)
{
  int v3; // esi@1
  char result; // al@2
  int v5; // eax@2
  int v6; // ST04_4@2

  v3 = *(_DWORD *)(this + 16);
  if ( (PVOID)v3 == EncodePointer(0) )
  {
    SetLastError(0x7Fu);
    result = 0;
  }
  else
  {
    v5 = sub_1003491A(v3);
    result = ((int (__thiscall *)(int, int, int))v5)(v6, a2, a3);
  }
  return result;
}

//----- (10030ECB) --------------------------------------------------------
int __thiscall sub_10030ECB(int this, int a2)
{
  int v2; // esi@1
  int result; // eax@2
  int v4; // eax@2
  int v5; // ST00_4@2

  v2 = *(_DWORD *)(this + 12);
  if ( (PVOID)v2 == EncodePointer(0) )
  {
    SetLastError(0x7Fu);
    result = -1;
  }
  else
  {
    v4 = sub_1003491A(v2);
    result = ((int (__thiscall *)(int, int))v4)(v5, a2);
  }
  return result;
}

//----- (10030EFB) --------------------------------------------------------
int __thiscall sub_10030EFB(void *this, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // esi@1
  int result; // eax@2
  int v8; // eax@2
  int v9; // ST1C_4@2

  v6 = *(_DWORD *)this;
  if ( *(PVOID *)this == EncodePointer(0) )
  {
    result = 127;
  }
  else
  {
    v8 = sub_1003491A(v6);
    result = ((int (__thiscall *)(int, int, _DWORD, int, int, int, _DWORD, _DWORD, int))v8)(
               v9,
               a2,
               0,
               a3,
               a4,
               a5,
               0,
               0,
               a6);
  }
  return result;
}

//----- (10030F35) --------------------------------------------------------
int __thiscall sub_10030F35(int this, int a2, int a3, int a4)
{
  int v4; // esi@1
  int result; // eax@2
  int v6; // eax@2
  int v7; // ST08_4@2

  v4 = *(_DWORD *)(this + 8);
  if ( (PVOID)v4 == EncodePointer(0) )
  {
    result = 127;
  }
  else
  {
    v6 = sub_1003491A(v4);
    result = ((int (__thiscall *)(int, int, int, int))v6)(v7, a2, a3, a4);
  }
  return result;
}

//----- (10030F64) --------------------------------------------------------
int __thiscall sub_10030F64(int this, int a2, int a3)
{
  int v3; // esi@1
  int result; // eax@2
  int v5; // eax@2
  int v6; // ST04_4@2

  v3 = *(_DWORD *)(this + 4);
  if ( (PVOID)v3 == EncodePointer(0) )
  {
    result = 127;
  }
  else
  {
    v5 = sub_1003491A(v3);
    result = ((int (__thiscall *)(int, int, int))v5)(v6, a2, a3);
  }
  return result;
}

//----- (10030F90) --------------------------------------------------------
int __thiscall sub_10030F90(void *this)
{
  int result; // eax@1
  void *v2; // esi@1
  char v3; // [sp+4h] [bp-10h]@3
  int v4; // [sp+Ch] [bp-8h]@2
  void (__cdecl *v5)(); // [sp+10h] [bp-4h]@2

  v2 = this;
  result = *(_DWORD *)this;
  *(_DWORD *)this = 1;
  if ( result )
  {
    v4 = 0;
    v5 = sub_10034BD7;
    do
    {
      sub_100282E0((int)&v3);
      result = *(_DWORD *)v2;
      *(_DWORD *)v2 = 1;
    }
    while ( result );
  }
  return result;
}

//----- (10030FC1) --------------------------------------------------------
int *__usercall sub_10030FC1<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  if ( !dword_100766D8 )
    sub_10030FD5(a1, a2, a3);
  return &dword_100766C8;
}
// 100766C8: using guessed type int dword_100766C8;
// 100766D8: using guessed type int dword_100766D8;

//----- (10030FD5) --------------------------------------------------------
int __usercall sub_10030FD5<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // eax@2
  void *v6; // eax@3

  sub_10035668();
  *(_DWORD *)(a2 - 16) = &dword_10077068;
  sub_10030F90(&dword_10077068);
  *(_DWORD *)(a2 - 4) = 0;
  if ( !dword_100766D8 )
  {
    v5 = sub_1002ADB1(v3, v4, a1, a3, 24);
    if ( v5 )
      v6 = sub_10030CE1((void *)v5);
    else
      v6 = 0;
    dword_100766D8 = (int)v6;
    sub_10030EFB(v6, (int)sub_10030DA0, (int)&unk_10068334, 7, (int)&off_10073CB0, (int)&dword_100766E0);
  }
  dword_10077068 = 0;
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 10073CB0: using guessed type void *off_10073CB0;
// 100766D8: using guessed type int dword_100766D8;
// 100766E0: using guessed type int dword_100766E0;
// 10077068: using guessed type int dword_10077068;

//----- (10031044) --------------------------------------------------------
int __usercall sub_10031044<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4, int a5, int a6, int a7)
{
  int result; // eax@1
  int ebp0; // ebp@0
  __int16 v9; // [sp+0h] [bp-7Ch]@3
  char v10; // [sp+2h] [bp-7Ah]@3
  char v11; // [sp+4h] [bp-78h]@3
  char v12; // [sp+5h] [bp-77h]@3
  int v13; // [sp+18h] [bp-64h]@3
  int v14; // [sp+1Ch] [bp-60h]@3
  int v15; // [sp+20h] [bp-5Ch]@3
  int v16; // [sp+24h] [bp-58h]@3
  int v17; // [sp+2Ch] [bp-50h]@3
  int v18; // [sp+30h] [bp-4Ch]@3
  int v19; // [sp+34h] [bp-48h]@3
  int v20; // [sp+38h] [bp-44h]@9
  int v21; // [sp+3Ch] [bp-40h]@11
  unsigned int v22; // [sp+78h] [bp-4h]@1
  int v23; // [sp+7Ch] [bp+0h]@1

  v22 = (unsigned int)&v23 ^ __security_cookie;
  result = (int)sub_10030FC1(a1, ebp0, a2);
  if ( *(_BYTE *)(result + 4) >= 4u )
  {
    result = *(_DWORD *)result;
    if ( result & 0x20 )
    {
      sub_10039210(&v10, 0, 118);
      v17 = 131072;
      v9 = 120;
      v13 = dword_10068324[0];
      v14 = dword_10068324[1];
      v15 = dword_10068324[2];
      v16 = dword_10068324[3];
      v18 = a4;
      v11 = a3;
      v12 = 4;
      v19 = a5;
      if ( a3 )
      {
        if ( a3 == 2 )
        {
          v20 = a6;
        }
        else
        {
          if ( a3 > 4 )
          {
            if ( a3 > 6 )
            {
              if ( a3 == 7 )
              {
                if ( a6 )
                  sub_10044A99(a1, a2, (int)&v20, 32, a6, -1);
              }
              return sub_10030F35(dword_100766D8, dword_100766D0, dword_100766D4, (int)&v9);
            }
            goto LABEL_11;
          }
        }
        return sub_10030F35(dword_100766D8, dword_100766D0, dword_100766D4, (int)&v9);
      }
LABEL_11:
      v20 = a6;
      v21 = a7;
      return sub_10030F35(dword_100766D8, dword_100766D0, dword_100766D4, (int)&v9);
    }
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 100766D0: using guessed type int dword_100766D0;
// 100766D4: using guessed type int dword_100766D4;
// 100766D8: using guessed type int dword_100766D8;

//----- (1003111F) --------------------------------------------------------
int __cdecl sub_1003111F()
{
  int result; // eax@2

  if ( dword_100766D8 )
  {
    byte_100766CC = 0;
    dword_100766C8 = 0;
    sub_10030F64(dword_100766D8, dword_100766E0, dword_100766E4);
    result = sub_1002A4AA((LPVOID)dword_100766D8);
    dword_100766D8 = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100766C8: using guessed type int dword_100766C8;
// 100766CC: using guessed type char byte_100766CC;
// 100766D8: using guessed type int dword_100766D8;
// 100766E0: using guessed type int dword_100766E0;
// 100766E4: using guessed type int dword_100766E4;

//----- (1003115F) --------------------------------------------------------
int __usercall sub_1003115F<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  LPVOID v3; // eax@1

  v3 = sub_1002B772(a1, a2, a3);
  return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v3 + 24))(v3);
}

//----- (10031170) --------------------------------------------------------
int __usercall sub_10031170<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  LPVOID v3; // eax@1

  v3 = sub_1002B772(a1, a2, a3);
  return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v3 + 28))(v3);
}

//----- (1003117C) --------------------------------------------------------
int __thiscall sub_1003117C(int this, int a2, char a3)
{
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = a2;
  *(_BYTE *)(this + 12) = a3;
  *(_DWORD *)this = &off_10061E2C;
  return this;
}
// 10061E2C: using guessed type int (__stdcall *off_10061E2C)(char);

//----- (1003119B) --------------------------------------------------------
void __thiscall sub_1003119B(int this)
{
  char v1; // zf@1

  v1 = *(_DWORD *)(this + 4) == 0;
  *(_DWORD *)this = &off_10061E2C;
  JUMPOUT(!v1, *(unsigned int *)sub_1003123D);
}
// 10061E2C: using guessed type int (__stdcall *off_10061E2C)(char);

//----- (100311AC) --------------------------------------------------------
void *__thiscall sub_100311AC(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_1003119B(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100311CB) --------------------------------------------------------
int __stdcall sub_100311CB(int a1, int a2)
{
  return (*(int (**)(void))(*(_DWORD *)a1 + 4))();
}

//----- (100311DA) --------------------------------------------------------
BOOL __thiscall sub_100311DA(char *Parameter)
{
  BOOL result; // eax@1
  HANDLE *v2; // esi@1
  DWORD v3; // ST14_4@4
  DWORD v4; // ST10_4@4
  void *v5; // ST0C_4@4
  int v6; // eax@4
  int (__stdcall **v7)(char); // [sp+4h] [bp-10h]@6
  int v8; // [sp+10h] [bp-4h]@6

  result = 0;
  v2 = (HANDLE *)(Parameter + 4);
  if ( !*((_DWORD *)Parameter + 1) )
  {
    if ( Parameter[12] )
      result = *((_DWORD *)Parameter + 2);
    v3 = result;
    v4 = *((_DWORD *)Parameter + 2);
    v5 = Parameter;
    v6 = sub_1002C20E();
    result = CreateTimerQueueTimer(v2, (HANDLE)v6, (WAITORTIMERCALLBACK)sub_100311CB, v5, v4, v3, 0x20u);
    if ( !result )
    {
      v8 = (int)"bad allocation";
      sub_1002AEC9((int)&v7, (int)&v8, 1);
      v7 = &off_100602D4;
      sub_100355DB((int)&v7, (int)&unk_1006BAB0);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1003123D);
    }
  }
  return result;
}
// 100602D4: using guessed type int (__stdcall *off_100602D4)(char);

//----- (1003123D) --------------------------------------------------------
DWORD __thiscall sub_1003123D(int this)
{
  DWORD result; // eax@1
  int v2; // esi@1
  void *v3; // ST04_4@1
  int v4; // eax@1

  v2 = this;
  v3 = *(void **)(this + 4);
  v4 = sub_1002C20E();
  result = sub_1003B587((HANDLE)v4, v3, (HANDLE)0xFFFFFFFF);
  *(_DWORD *)(v2 + 4) = 0;
  return result;
}

//----- (10031259) --------------------------------------------------------
int __thiscall sub_10031259(void *ListHead, int a2, signed int a3, int a4)
{
  int v4; // edx@1
  int v5; // edi@1
  int v6; // edx@2
  int v7; // edx@2
  int v8; // eax@3
  int v10; // esi@3
  signed __int64 v12; // qax@3
  int v13; // edx@3
  signed int v14; // ecx@6
  signed __int64 v15; // qax@6
  int v16; // eax@6
  int v17; // ecx@6
  int v18; // eax@7

  v4 = a3;
  v5 = (int)ListHead;
  *((_DWORD *)ListHead + 9) = a2;
  *((_DWORD *)ListHead + 17) = a4;
  *((_DWORD *)ListHead + 4) = 0;
  *((_DWORD *)ListHead + 11) = 0;
  *((_DWORD *)ListHead + 12) = 0;
  *((_DWORD *)ListHead + 14) = 512;
  *((_DWORD *)ListHead + 15) = 1;
  *((_DWORD *)ListHead + 16) = 0;
  *((_DWORD *)ListHead + 18) = 0;
  if ( (v4 - 1) & v4 )
  {
    v6 = (((a3 >> 1) | a3) >> 2) | (a3 >> 1) | a3;
    v7 = (((v6 >> 4) | v6) >> 8) | (v6 >> 4) | v6;
    v4 = ((v7 >> 16) | v7) + 1;
  }
  *((_DWORD *)ListHead + 10) = v4;
  _ECX = 0;
  v12 = 4i64 * (unsigned int)v4;
  __asm { seto    cl }
  _QCX = (_DWORD)v12 | (unsigned int)-_ECX;
  v10 = sub_1002965B(SHIDWORD(v12), _QCX, SHIDWORD(_QCX), v5, _QCX);
  sub_10039210((void *)v10, 0, 4 * *(_DWORD *)(v5 + 40));
  v8 = sub_1002ADB1(v13, _QCX, SHIDWORD(_QCX), v5, 12);
  if ( v8 )
  {
    *(_DWORD *)(v8 + 8) = -1;
    *(_DWORD *)v8 = v10;
    *(_DWORD *)(v8 + 4) = 0;
  }
  else
  {
    v8 = 0;
  }
  *(_DWORD *)(v5 + 48) = v8;
  LODWORD(_QCX) = 0;
  v15 = 4i64 * *(_DWORD *)(v5 + 56);
  __asm { seto    cl }
  v16 = sub_1002965B(SHIDWORD(v15), v15 | -(_DWORD)_QCX, SHIDWORD(_QCX), v5, v15 | -(_DWORD)_QCX);
  v17 = *(_DWORD *)(v5 + 48);
  *(_DWORD *)(v5 + 52) = v16;
  *(_DWORD *)v16 = v17;
  InitializeSListHead((PSLIST_HEADER)v5);
  InitializeSListHead((PSLIST_HEADER)(v5 + 8));
  v14 = *(_DWORD *)(v5 + 40) >> 1;
  if ( v14 )
  {
    v18 = *(_DWORD *)(v5 + 44);
    do
    {
      ++v18;
      v14 >>= 1;
    }
    while ( v14 );
    *(_DWORD *)(v5 + 44) = v18;
  }
  return v5;
}

//----- (1003134A) --------------------------------------------------------
void *__thiscall sub_1003134A(void *this)
{
  void *v2; // esi@1
  int v3; // edx@1

  v2 = this;
  *(_DWORD *)this = 0;
  v3 = *(_DWORD *)sub_1002B509((int)((char *)this + 4));
  return v2;
}

//----- (10031361) --------------------------------------------------------
void *__thiscall sub_10031361(void *this, int a2, int a3, int a4)
{
  int ebp0; // ebp@0
  void *v6; // esi@1

  v6 = this;
  sub_100406B5(ebp0, a2, a3, a4);
  *(_DWORD *)v6 = &off_10061F08;
  *((_DWORD *)v6 + 72) = 0;
  *((_DWORD *)v6 + 73) = (char *)v6 + 288;
  *((_DWORD *)v6 + 74) = 0;
  return v6;
}
// 10061F08: using guessed type int (__stdcall *off_10061F08)(char);

//----- (10031398) --------------------------------------------------------
void *__thiscall sub_10031398(void *this, int a2, int a3, int a4)
{
  int ebp0; // ebp@0
  void *v6; // esi@1

  v6 = this;
  sub_100406B5(ebp0, a2, a3, a4);
  *(_DWORD *)v6 = &off_10061F48;
  *((_DWORD *)v6 + 72) = 0;
  *((_DWORD *)v6 + 73) = (char *)v6 + 288;
  *((_DWORD *)v6 + 74) = 0;
  return v6;
}
// 10061F48: using guessed type int (__stdcall *off_10061F48)(char);

//----- (100313DF) --------------------------------------------------------
int __userpurge sub_100313DF<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  int v5; // esi@1
  unsigned int v7; // eax@1
  int v8; // eax@1
  signed int v9; // ST08_4@1

  v5 = a1;
  _ECX = 0;
  *(_DWORD *)v5 = a4;
  v7 = 4 * ((unsigned int)(a4 + 31) >> 5);
  __asm { seto    cl }
  v8 = sub_1002965B((a4 + 31) / 0x100u, v7 | -_ECX, a2, a3, v7 | -_ECX);
  v9 = 4 * ((unsigned int)(*(_DWORD *)v5 + 31) >> 5);
  *(_DWORD *)(v5 + 4) = v8;
  sub_10039210((void *)v8, 0, v9);
  return v5;
}

//----- (10031425) --------------------------------------------------------
int __userpurge sub_10031425<eax>(int a1<ebp>, int a2)
{
  int v2; // ebx@1
  int v3; // edi@1
  int v4; // ecx@1
  const void **v5; // ST18_4@1
  int v6; // edx@1
  int v7; // esi@1
  int v8; // eax@2
  DWORD v9; // eax@4
  int v10; // eax@5
  int i; // eax@7
  HANDLE v12; // eax@9
  int v13; // eax@10
  int v14; // eax@14
  int v15; // eax@18
  int v17; // [sp-8h] [bp-8h]@7

  sub_10035668();
  v3 = v4;
  *(_DWORD *)(a1 - 16) = v4;
  v2 = *(_DWORD *)(a1 + 8);
  v5 = *(const void ***)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)v4 = &off_10061EA4;
  sub_10044B75(v6, v4 + 4, v2, v4, v5);
  *(_DWORD *)(v3 + 48) = 0;
  *(_DWORD *)(v3 + 52) = 0;
  *(_DWORD *)(v3 + 56) = 0;
  *(_DWORD *)(v3 + 60) = 0;
  *(_DWORD *)(v3 + 64) = 0;
  *(_DWORD *)(v3 + 68) = 0;
  *(_DWORD *)(v3 + 72) = 0;
  *(_DWORD *)(v3 + 76) = 0;
  *(_DWORD *)(v3 + 80) = 0;
  *(_DWORD *)(v3 + 84) = 0;
  *(_DWORD *)(v3 + 88) = 0;
  *(_BYTE *)(a1 - 4) = 5;
  sub_10031259((void *)(v3 + 96), 0, 256, 64);
  *(_DWORD *)(v3 + 180) = 0;
  *(_BYTE *)(a1 - 4) = 6;
  sub_1003134A((void *)(v3 + 184));
  sub_10031259((void *)(v3 + 200), 0, 256, 2147483647);
  *(_BYTE *)(a1 - 4) = 7;
  sub_1002B519((LPCRITICAL_SECTION)(v3 + 280));
  *(_BYTE *)(a1 - 4) = 8;
  sub_1003134A((void *)(v3 + 304));
  *(_DWORD *)(v3 + 316) = 0;
  *(_DWORD *)(v3 + 320) = v3 + 316;
  *(_DWORD *)(v3 + 324) = 0;
  *(_DWORD *)(v3 + 328) = -1;
  *(_DWORD *)(v3 + 332) = -1;
  *(_DWORD *)(v3 + 336) = 0;
  *(_DWORD *)(v3 + 340) = 0;
  *(_DWORD *)(v3 + 344) = 0;
  sub_1002E10F(v3 + 348, v2, v3, 0x1001u);
  *(_BYTE *)(a1 - 4) = 9;
  sub_1002E10F(v3 + 360, v2, v3, 0x1001u);
  *(_DWORD *)(v3 + 372) = -1;
  *(_DWORD *)(v3 + 376) = 0;
  *(_DWORD *)(v3 + 384) = 0;
  *(_DWORD *)(v3 + 388) = 0;
  *(_DWORD *)(v3 + 392) = 1;
  *(_DWORD *)(v3 + 396) = 0;
  *(_DWORD *)(v3 + 400) = 0;
  *(_DWORD *)(v3 + 404) = 0;
  *(_BYTE *)(a1 - 4) = 10;
  *(_DWORD *)(v3 + 408) = 0;
  *(_DWORD *)(v3 + 412) = 0;
  *(_DWORD *)(v3 + 416) = 0;
  *(_DWORD *)(v3 + 424) = 0;
  *(_DWORD *)(v3 + 432) = 0;
  *(_DWORD *)(v3 + 436) = 0;
  *(_DWORD *)(v3 + 440) = 0;
  *(_DWORD *)(v3 + 444) = 0;
  *(_DWORD *)(v3 + 448) = 0;
  *(_DWORD *)(v3 + 456) = 0;
  *(_DWORD *)(v3 + 472) = 0;
  InitializeSListHead((PSLIST_HEADER)(v3 + 480));
  InitializeSListHead((PSLIST_HEADER)(v3 + 488));
  InitializeSListHead((PSLIST_HEADER)(v3 + 496));
  InitializeSListHead((PSLIST_HEADER)(v3 + 504));
  *(_DWORD *)(v3 + 132) = v3;
  *(_DWORD *)(v3 + 8) = sub_10044C13((void *)v2, 0);
  *(_WORD *)(v3 + 16) = sub_10044C13((void *)v2, 4u);
  *(_DWORD *)(v3 + 12) = sub_10044C13((void *)v2, 7u);
  v7 = sub_10044C13((void *)v2, 1u);
  if ( 4 * sub_1003D69A() <= (unsigned int)v7 )
    v8 = sub_10044C13((void *)v2, 1u);
  else
    v8 = 4 * sub_1003D69A();
  *(_DWORD *)(v3 + 452) = v8;
  v9 = TlsAlloc();
  *(_DWORD *)(v3 + 24) = v9;
  if ( v9 != -1 )
    goto LABEL_9;
  v10 = GetLastError();
  if ( v10 > 0 )
    v10 = (unsigned __int16)v10 | 0x80070000;
  sub_10030079(a1 - 32, v10);
  v17 = (int)&unk_1006C6F4;
  for ( i = a1 - 32; ; i = a1 - 80 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        sub_100355DB(i, v17);
LABEL_9:
        v12 = CreateEventW(0, 0, 0, 0);
        *(_DWORD *)(v3 + 460) = v12;
        if ( v12 )
          break;
        v13 = GetLastError();
        if ( v13 > 0 )
          v13 = (unsigned __int16)v13 | 0x80070000;
        sub_10030079(a1 - 48, v13);
        v17 = (int)&unk_1006C6F4;
        i = a1 - 48;
      }
      if ( RegisterWaitForSingleObject(
             (PHANDLE)(v3 + 464),
             v12,
             (WAITORTIMERCALLBACK)sub_10034519,
             (PVOID)v3,
             0xFFFFFFFFu,
             0) )
        break;
      v14 = GetLastError();
      if ( v14 > 0 )
        v14 = (unsigned __int16)v14 | 0x80070000;
      sub_10030079(a1 - 64, v14);
      v17 = (int)&unk_1006C6F4;
      i = a1 - 64;
    }
    if ( CreateTimerQueueTimer(
           (PHANDLE)(v3 + 468),
           0,
           (WAITORTIMERCALLBACK)sub_1003450A,
           (PVOID)v3,
           0x7FFFFFFFu,
           0x7FFFFFFFu,
           0) )
      break;
    v15 = GetLastError();
    if ( v15 > 0 )
      v15 = (unsigned __int16)v15 | 0x80070000;
    sub_10030079(a1 - 80, v15);
    v17 = (int)&unk_1006C6F4;
  }
  return sub_10035636(68);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 10061EA4: using guessed type int (__stdcall *off_10061EA4)(char);

//----- (10031730) --------------------------------------------------------
void *__thiscall sub_10031730(void *this)
{
  void *v2; // esi@1

  v2 = this;
  sub_100309DA((int)((char *)this + 4), 8, 96, (void (__thiscall *)(_DWORD))sub_1002CB3A, (int)sub_1002CB4F);
  *((_BYTE *)v2 + 772) = 0;
  return v2;
}
// 1002CB3A: using guessed type int sub_1002CB3A();
// 1002CB4F: using guessed type int sub_1002CB4F();

//----- (10031755) --------------------------------------------------------
int __userpurge sub_10031755<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10061D18;
  return v4;
}
// 10061D18: using guessed type int (__stdcall *off_10061D18)(char);

//----- (10031770) --------------------------------------------------------
int __userpurge sub_10031770<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10061D24;
  return v4;
}
// 10061D24: using guessed type int (__stdcall *off_10061D24)(char);

//----- (1003178B) --------------------------------------------------------
int __userpurge sub_1003178B<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // edi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10061CF4;
  *(_DWORD *)(v4 + 12) = *(_DWORD *)(a3 + 12);
  return v4;
}
// 10061CF4: using guessed type int (__stdcall *off_10061CF4)(char);

//----- (100317C2) --------------------------------------------------------
int __thiscall sub_100317C2(PSLIST_HEADER ListHead)
{
  int v1; // ebx@1
  PSLIST_HEADER v2; // edi@1
  int v3; // eax@1
  int v4; // eax@1
  int i; // esi@2
  int v6; // ecx@3
  int v7; // esi@6

  v2 = ListHead;
  v3 = (int)InterlockedFlushSList(ListHead);
  sub_10032289(v3);
  v4 = (int)InterlockedFlushSList(v2 + 1);
  sub_10032289(v4);
  sub_10032289(LODWORD(v2[2].Alignment));
  v1 = LODWORD(v2[6].Alignment);
  if ( v1 )
  {
    do
    {
      for ( i = 0; i < LODWORD(v2[5].Alignment); ++i )
      {
        v6 = *(_DWORD *)(*(_DWORD *)v1 + 4 * i);
        if ( v6 )
          (*(void (__stdcall **)(signed int))(*(_DWORD *)v6 + 16))(1);
      }
      v7 = *(_DWORD *)(v1 + 4);
      sub_10030383(*(LPVOID *)v1);
      sub_1002A4AA((LPVOID)v1);
      v1 = v7;
    }
    while ( v7 );
  }
  return sub_10030383(HIDWORD(v2[6].Alignment));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (10031839) --------------------------------------------------------
int __thiscall sub_10031839(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_10030383(*(LPVOID *)(this + 12));
  return sub_10030383(*(LPVOID *)(v2 + 4));
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (10031850) --------------------------------------------------------
int __thiscall sub_10031850(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_10030383(*(LPVOID *)(this + 8));
  return sub_10030383(*(LPVOID *)(v2 + 4));
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (10031875) --------------------------------------------------------
#error "1003191D: call analysis failed (funcsize=43)"

//----- (1003192A) --------------------------------------------------------
int __thiscall sub_1003192A(int this, char a2)
{
  void *v2; // esi@1
  int result; // eax@4

  v2 = (void *)this;
  if ( a2 & 2 )
  {
    sub_1002B11F(this, 16, *(_DWORD *)(this - 4), sub_10031839);
    if ( a2 & 1 )
      sub_10030383((char *)v2 - 4);
    result = (int)((char *)v2 - 4);
  }
  else
  {
    sub_10031839(this);
    if ( a2 & 1 )
      sub_1002A4AA(v2);
    result = (int)v2;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (10031974) --------------------------------------------------------
void *__thiscall sub_10031974(void *this, char a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1

  v3 = this;
  sub_1004090D(ebp0);
  if ( a2 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10031993) --------------------------------------------------------
void *__thiscall sub_10031993(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10061E90;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10061E90: using guessed type int (__stdcall *off_10061E90)(char);

//----- (100319B3) --------------------------------------------------------
void *__thiscall sub_100319B3(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_10061E40;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10061E40: using guessed type int (*off_10061E40[4])();

//----- (100319D3) --------------------------------------------------------
void *__thiscall sub_100319D3(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10061E58;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10061E58: using guessed type int (__stdcall *off_10061E58)(char);

//----- (100319F3) --------------------------------------------------------
void *__thiscall sub_100319F3(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_10031875(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10031875: using guessed type _DWORD __thiscall sub_10031875(_DWORD ecx0);

//----- (10031A12) --------------------------------------------------------
void *__thiscall sub_10031A12(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_1002B11F((int)((char *)this + 4), 8, 96, (void (__thiscall *)(_DWORD))sub_1002CB4F);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1002CB4F: using guessed type int sub_1002CB4F();

//----- (10031A3E) --------------------------------------------------------
int __thiscall sub_10031A3E(int this, int a2)
{
  signed int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // edx@3
  int v12; // ecx@11
  signed __int64 v15; // qax@11
  signed int v16; // ST0C_4@11
  int v17; // edx@11
  int v18; // ecx@11
  int v19; // eax@12
  int v28; // edx@17
  char v30; // [sp+Ch] [bp-20h]@22
  int v31; // [sp+14h] [bp-18h]@21
  BOOL (__cdecl *v32)(); // [sp+18h] [bp-14h]@21
  int v33; // [sp+1Ch] [bp-10h]@5
  int v34; // [sp+20h] [bp-Ch]@2
  int v35; // [sp+24h] [bp-8h]@1
  char v36; // [sp+2Bh] [bp-1h]@1

  v5 = this;
  v3 = *(_DWORD *)(this + 48);
  v36 = 0;
  v4 = 0;
  v35 = v3;
  v2 = 4;
  do
  {
    _EBX = v3 + 8;
    v34 = v3 + 8;
    if ( *(_DWORD *)(v3 + 8) >= -1 )
    {
      _EBX = *(_DWORD *)v3;
      v7 = 0;
      if ( *(_DWORD *)(v5 + 40) <= 0 )
      {
LABEL_7:
        _EBX = v34;
      }
      else
      {
        while ( *(_DWORD *)_EBX )
        {
          ++v7;
          _EBX += v2;
          if ( v7 >= *(_DWORD *)(v5 + 40) )
            goto LABEL_7;
        }
        _ECX = a2;
        *(_DWORD *)(a2 + 24) = v7 + v4;
        v33 = *(_DWORD *)(v5 + 64);
        __asm { lock cmpxchg [ebx], ecx }
        v4 += v7;
        v36 = 1;
        if ( v4 >= v33 )
        {
          _EAX = v5 + 64;
          _ECX = 1;
          __asm { lock xadd [eax], ecx }
        }
        _EBX = v34;
        _ECX = -1;
        __asm { lock cmpxchg [ebx], ecx }
      }
      v3 = v35;
    }
    if ( !v36 )
    {
      _ECX = -2;
      __asm { lock cmpxchg [ebx], ecx }
      v4 += *(_DWORD *)(v5 + 40);
      _EBX = v3 + 4;
      if ( !*(_DWORD *)(v3 + 4) )
      {
        _ECX = 1;
        __asm { lock cmpxchg [ebx], ecx }
        _ECX = 0;
        v15 = 4i64 * *(_DWORD *)(v5 + 40);
        __asm { seto    cl }
        v16 = 4 * *(_DWORD *)(v5 + 40);
        v33 = sub_1002965B(SHIDWORD(v15), v15 | -_ECX, _EBX, v4, v15 | -_ECX);
        sub_10039210((void *)v33, 0, v16);
        v12 = sub_1002ADB1(v17, v18, _EBX, v4, 12);
        if ( v12 )
        {
          v19 = v33;
          *(_DWORD *)(v12 + 4) = 0;
          *(_DWORD *)(v12 + 8) = -1;
          *(_DWORD *)v12 = v19;
        }
        else
        {
          v12 = 0;
        }
        v28 = *(_DWORD *)(v5 + 60);
        if ( v28 < *(_DWORD *)(v5 + 56) )
        {
          *(_DWORD *)(*(_DWORD *)(v5 + 52) + 4 * v28) = v12;
          ++*(_DWORD *)(v5 + 60);
        }
        *(_DWORD *)_EBX = v12;
        v3 = v35;
      }
      if ( *(_DWORD *)_EBX == 1 )
      {
        v31 = 0;
        v32 = sub_10034C15;
        do
          sub_100282E0((int)&v30);
        while ( *(_DWORD *)_EBX == 1 );
        v3 = v35;
      }
    }
    v3 = *(_DWORD *)(v3 + 4);
    v35 = v3;
    v2 = 4;
  }
  while ( !v36 );
  return v4;
}

//----- (10031B97) --------------------------------------------------------
int __userpurge sub_10031B97<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // eax@1
  int v6; // esi@1

  v6 = a2;
  v5 = sub_1002ADB1(a1, a2, a3, a4, 8);
  if ( v5 )
    *(_DWORD *)(v5 + 4) = a5;
  else
    v5 = 0;
  return sub_10033822((void *)(v6 + 180), v5);
}

//----- (10031BC4) --------------------------------------------------------
int __thiscall sub_10031BC4(void *this, int a2)
{
  int result; // eax@2

  if ( *(_DWORD *)this )
  {
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(*(_DWORD *)this + 4);
    *(_DWORD *)(a2 + 8) = *(_DWORD *)this;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)this + 4) + 8) = a2;
    result = *(_DWORD *)this;
    *(_DWORD *)(*(_DWORD *)this + 4) = a2;
  }
  else
  {
    *(_DWORD *)this = a2;
    *(_DWORD *)(a2 + 8) = a2;
    result = *(_DWORD *)this;
    *(_DWORD *)(result + 4) = result;
  }
  return result;
}

//----- (10031BFD) --------------------------------------------------------
int __thiscall sub_10031BFD(void *this, int a2)
{
  int result; // eax@1

  result = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    *(_DWORD *)a2 = *(_DWORD *)result;
    *(_DWORD *)(a2 + 4) = *(_DWORD *)this;
    *(_DWORD *)(**(_DWORD **)this + 4) = a2;
    result = *(_DWORD *)this;
    **(_DWORD **)this = a2;
  }
  else
  {
    *(_DWORD *)a2 = a2;
    *(_DWORD *)(a2 + 4) = a2;
  }
  *(_DWORD *)this = a2;
  return result;
}

//----- (10031C2A) --------------------------------------------------------
int __thiscall sub_10031C2A(int this, int a2)
{
  int v3; // edi@1

  v3 = this;
  sub_1002B98B((void *)(this + 4));
  sub_10031BFD((void *)v3, a2);
  return sub_1002BB75((void *)(v3 + 4));
}

//----- (10031C51) --------------------------------------------------------
int __thiscall sub_10031C51(void *this, int a2, unsigned int a3)
{
  int result; // eax@1
  void *v4; // edi@1
  unsigned int v5; // esi@2
  int *v6; // eax@3
  unsigned int v7; // ebx@4
  int v8; // eax@5
  int v9; // ecx@5
  int v17; // [sp-4h] [bp-34h]@3
  int (__stdcall **v18)(char); // [sp+Ch] [bp-24h]@3
  int (__stdcall **v19)(char); // [sp+18h] [bp-18h]@9
  int v20; // [sp+24h] [bp-Ch]@5
  int v21; // [sp+28h] [bp-8h]@5
  int v22; // [sp+2Ch] [bp-4h]@3

  result = a2;
  v4 = this;
  if ( !a2 )
  {
    a3 = (unsigned int)"ppVirtualProcessorRoots";
    sub_1002AEA4((int)&v19, (int *)&a3);
    v19 = &off_100602FC;
    v17 = (int)&unk_1006D8F4;
    v6 = (int *)&v19;
    goto LABEL_10;
  }
  v5 = a3;
  if ( a3 < 1 )
  {
    v22 = (int)"count";
    sub_1002AEA4((int)&v18, &v22);
    v18 = &off_100602FC;
    v17 = (int)&unk_1006D8F4;
    v6 = (int *)&v18;
LABEL_10:
    sub_100355DB((int)v6, v17);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10031D15);
  }
  v7 = 0;
  if ( a3 )
  {
    do
    {
      v20 = *(_DWORD *)(result + 4 * v7);
      v8 = (**(int (***)(void))v20)();
      v9 = *((_DWORD *)v4 + 9);
      v21 = v8;
      if ( !*(_DWORD *)(*(_DWORD *)(v9 + 4 * v8) + 188) )
      {
        sub_100473E6(*(_DWORD *)(*((_DWORD *)v4 + 9) + 4 * v8));
        v8 = v21;
      }
      sub_10045C79(*(void **)(*((_DWORD *)v4 + 8) + 4 * v8), v20, 0);
      _EAX = 1;
      _ECX = (int)((char *)v4 + 20);
      __asm { lock xadd [ecx], eax }
      result = a2;
      ++v7;
    }
    while ( v7 < v5 );
  }
  return result;
}
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);

//----- (10031D15) --------------------------------------------------------
int __userpurge sub_10031D15<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@1

  sub_10035668();
  v6 = v7;
  v5 = sub_1002ADB1(v8, v7, a1, a3, 304);
  *(_DWORD *)(a2 - 16) = v5;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v5 )
    sub_10031361((void *)v5, v6, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12));
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (10031D50) --------------------------------------------------------
int __userpurge sub_10031D50<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // ecx@1
  int v7; // edx@1

  sub_10035668();
  v5 = v6;
  *(_DWORD *)(a2 - 32) = 0;
  *(_DWORD *)(a2 - 24) = 0;
  *(_DWORD *)(a2 - 20) = 0;
  v4 = sub_1002ADB1(v7, v6, a1, v6, 304);
  *(_DWORD *)(a2 - 16) = v4;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v4 )
    sub_10031398((void *)v4, v5, *(_DWORD *)(a2 + 8), a2 - 32);
  return sub_10035636(20);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (10031D99) --------------------------------------------------------
int __usercall sub_10031D99<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-Ch]@3

  v2 = a1;
  if ( sub_10032372() == a1 )
  {
    sub_1002FF67((int)&v4);
    sub_100355DB((int)&v4, (int)&unk_1006C764);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10031DDF);
  }
  sub_10031DDF((void *)v2, a2, 1);
  return sub_10034663(7, 4, *(_DWORD *)(v2 + 372));
}

//----- (10031DDF) --------------------------------------------------------
int __userpurge sub_10031DDF<eax>(void *a1<ecx>, int a2<ebx>, int a3)
{
  LPVOID v3; // eax@1
  int ebp0; // ebp@0
  int v5; // edi@1
  void *v6; // esi@1
  int v8; // esi@6
  char v9; // [sp+8h] [bp-Ch]@7

  v6 = a1;
  v3 = sub_10032365();
  v5 = (int)v3;
  if ( v3 )
  {
    if ( *((void **)v3 + 7) == v6 )
    {
      sub_1002FF67((int)&v9);
      sub_100355DB((int)&v9, (int)&unk_1006C764);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_10031E48);
    }
    if ( !*((_BYTE *)v3 + 76) )
      sub_10046989((char *)v3 - 4);
    sub_1002E77E();
  }
  sub_1003395E(v6);
  v8 = sub_100328EB(a2, ebp0, a3);
  sub_1002ECE3((LPVOID)v8, v5);
  return v8;
}

//----- (10031E48) --------------------------------------------------------
BOOL __thiscall sub_10031E48(void *this)
{
  _ESI = -1073741824;
  _EDX = (char *)this + 404;
  __asm { lock cmpxchg [edx], esi }
  return sub_1003435B(this);
}

//----- (10031E6B) --------------------------------------------------------
int __thiscall sub_10031E6B(void *this)
{
  int result; // eax@1
  int i; // esi@1
  int v3; // esi@1
  int v4; // ecx@1

  v3 = (int)this;
  sub_1002EFDD(this);
  sub_10033B18(v3);
  result = sub_1002EFDD(v4);
  for ( i = *(_DWORD *)(v3 + 180); i; i = *(_DWORD *)i )
    result = (*(int (**)(void))(**(_DWORD **)(i + 4) + 24))();
  return result;
}
// 1002EFDD: using guessed type _DWORD __thiscall sub_1002EFDD(_DWORD ecx0);

//----- (10031EF3) --------------------------------------------------------
int __cdecl sub_10031EF3(int a1)
{
  int result; // eax@1

  result = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 404) & 0xA0000000;
  if ( result != -1610612736 )
  {
    sub_1003226B(*(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    *(_DWORD *)(a1 + 72) = 0;
  }
  return result;
}

//----- (10031EFF) --------------------------------------------------------
int __cdecl sub_10031EFF(int a1)
{
  int result; // eax@1

  result = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 404) & 0xA0000000;
  if ( result != -1610612736 )
  {
    sub_10032289(*(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    *(_DWORD *)(a1 + 72) = 0;
  }
  return result;
}

//----- (10031F0B) --------------------------------------------------------
int __cdecl sub_10031F0B()
{
  int result; // eax@1

  _ESI = &dword_10073D14;
  _EAX = -1;
  __asm { lock xadd [esi], eax }
  result = _EAX - 1;
  if ( result == -2147483648 )
  {
    sub_10033556();
    result = 2147483647;
    __asm { lock and [esi], eax }
  }
  return result;
}
// 10073D14: using guessed type int dword_10073D14;

//----- (10031F2F) --------------------------------------------------------
int __usercall sub_10031F2F<eax>(int a1<ebp>)
{
  int v1; // eax@1

  sub_10035668();
  *(_DWORD *)(a1 - 16) = &dword_1007706C;
  sub_10030F90(&dword_1007706C);
  v1 = dword_10076700;
  *(_DWORD *)(a1 - 4) = 0;
  dword_10076700 = v1 + 1;
  if ( dword_10076700 == 1 )
  {
    sub_100341BF();
    _ESI = -2147483648;
    if ( !(dword_10073D14 & 0x80000000) )
    {
      sub_10033508();
      _EAX = &dword_10073D14;
      __asm { lock or [eax], esi }
    }
  }
  dword_1007706C = 0;
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 10073D14: using guessed type int dword_10073D14;
// 10076700: using guessed type int dword_10076700;
// 1007706C: using guessed type int dword_1007706C;

//----- (10031F8B) --------------------------------------------------------
int __usercall sub_10031F8B<eax>(int a1<ecx>, int a2<ebp>)
{
  int i; // edi@1
  int v3; // esi@1
  void *v4; // ebx@2
  int j; // edi@5
  void *v6; // ebx@6
  int v7; // ecx@9
  int v8; // ecx@11
  char v9; // zf@11
  PSINGLE_LIST_ENTRY v10; // eax@14

  v3 = a1;
  for ( i = 0; i < *(_DWORD *)(v3 + 44); ++i )
  {
    v4 = *(void **)(*(_DWORD *)(v3 + 32) + 4 * i);
    if ( v4 )
    {
      sub_10045AE0(a2);
      sub_1002A4AA(v4);
    }
  }
  for ( j = 0; j < *(_DWORD *)(v3 + 44); ++j )
  {
    v6 = *(void **)(*(_DWORD *)(v3 + 36) + 4 * j);
    if ( v6 )
    {
      sub_100473B3(a2);
      sub_1002A4AA(v6);
    }
  }
  sub_10030383(*(LPVOID *)(v3 + 92));
  sub_10030383(*(LPVOID *)(v3 + 32));
  sub_10030383(*(LPVOID *)(v3 + 36));
  v7 = *(_DWORD *)(v3 + 28);
  if ( v7 )
    sub_1003192A(v7, 3);
  TlsFree(*(_DWORD *)(v3 + 24));
  v8 = *(_DWORD *)(v3 + 416);
  *(_DWORD *)(v3 + 24) = 0;
  (*(void (**)(void))(*(_DWORD *)v8 + 4))();
  sub_10035668();
  *(_DWORD *)(a2 - 16) = &dword_1007706C;
  sub_10030F90(&dword_1007706C);
  *(_DWORD *)(a2 - 4) = 0;
  v9 = dword_10076700-- == 1;
  if ( v9 )
  {
    sub_1003111F();
    while ( 1 )
    {
      v10 = InterlockedPopEntrySList(&ListHead);
      if ( !v10 )
        break;
      sub_10031A12(v10, 1);
    }
  }
  dword_1007706C = 0;
  return sub_10035636(4);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 10076700: using guessed type int dword_10076700;
// 1007706C: using guessed type int dword_1007706C;

//----- (10032023) --------------------------------------------------------
int __thiscall sub_10032023(int this)
{
  signed int i; // eax@1
  void *v2; // ebx@1
  int v3; // edi@1
  int result; // eax@3
  unsigned int v5; // esi@3

  v3 = this;
  v2 = (void *)(this + 324);
  sub_10034BBC((void *)(this + 324));
  for ( i = sub_10034738(v3); ; i = sub_100346F0(v3, v5) )
  {
    v5 = i;
    result = sub_10034BCC(v2);
    if ( !v5 )
      break;
    sub_10032066(v3, v5);
    sub_10034BBC(v2);
  }
  return result;
}

//----- (10032066) --------------------------------------------------------
int __thiscall sub_10032066(int this, unsigned int a2)
{
  int v2; // eax@1
  int v3; // ebx@1
  int v4; // edi@1
  unsigned int v5; // eax@3
  int v6; // eax@5
  int v7; // esi@5
  int result; // eax@7
  int v9; // eax@8
  int v10; // [sp+8h] [bp-Ch]@1
  int *v11; // [sp+Ch] [bp-8h]@1
  int v12; // [sp+10h] [bp-4h]@1

  v10 = 0;
  v4 = this;
  v3 = this + 324;
  v11 = &v10;
  v12 = this + 324;
  sub_10034BBC((void *)(this + 324));
  v2 = *(_DWORD *)(v4 + 316);
  if ( v2 )
  {
    do
    {
      if ( a2 )
      {
        v5 = *(_DWORD *)(v2 + 8);
        if ( v5 < *(_DWORD *)(v4 + 340) )
          break;
        if ( v5 > a2 )
          break;
      }
      v6 = sub_10040F79((void *)(v4 + 316));
      v7 = v6 + 12;
      *(_DWORD *)(v6 + 12) = 0;
      *v11 = v6;
      v2 = *(_DWORD *)(v4 + 316);
      v11 = (int *)v7;
    }
    while ( v2 );
    v3 = v12;
  }
  result = sub_10034BCC((void *)v3);
  while ( v10 )
  {
    v9 = sub_10040F79(&v10);
    result = (*(int (__cdecl **)(_DWORD))v9)(*(_DWORD *)(v9 + 4));
  }
  return result;
}

//----- (100320F3) --------------------------------------------------------
signed int __thiscall sub_100320F3(int this)
{
  int v1; // ebx@1
  signed int v2; // edi@1
  int v3; // esi@1
  int v4; // eax@2
  signed int v5; // ecx@3
  int v6; // eax@4
  int v7; // eax@5
  signed int v8; // eax@6
  int v10; // [sp+Ch] [bp-10h]@2
  int v11; // [sp+10h] [bp-Ch]@1
  signed int v12; // [sp+14h] [bp-8h]@3
  char v13; // [sp+1Bh] [bp-1h]@1

  v1 = this;
  v3 = 0;
  v2 = 0;
  v13 = 0;
  v11 = 0;
  if ( *(_DWORD *)(this + 44) > 0 )
  {
    while ( 1 )
    {
      v4 = *(_DWORD *)(*(_DWORD *)(v1 + 32) + 4 * v3);
      v10 = v4;
      if ( v4 )
      {
        v5 = 0;
        v12 = 0;
        if ( *(_DWORD *)(v4 + 120) > 0 )
          break;
      }
LABEL_15:
      ++v3;
      v11 = v3;
      if ( v3 >= *(_DWORD *)(v1 + 44) )
        return v2;
    }
    v6 = v4 + 56;
    while ( 1 )
    {
      v7 = sub_1004099B(v6, v5);
      if ( v7 )
      {
        v8 = *(_DWORD *)(v7 + 180);
        if ( (unsigned int)v8 < *(_DWORD *)(v1 + 340) )
          v8 = -1;
        if ( !v13 )
        {
          v13 = 1;
LABEL_12:
          v2 = v8;
          goto LABEL_13;
        }
        if ( v2 > (unsigned int)v8 )
          goto LABEL_12;
      }
LABEL_13:
      v5 = v12 + 1;
      v12 = v5;
      v6 = v10 + 56;
      if ( v5 >= *(_DWORD *)(v10 + 120) )
      {
        v3 = v11;
        goto LABEL_15;
      }
    }
  }
  return v2;
}

//----- (1003217C) --------------------------------------------------------
int __userpurge sub_1003217C<eax>(int a1<ecx>, int a2<edi>, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  unsigned int v5; // edx@3
  unsigned int v6; // edi@3

  result = *(_DWORD *)a3;
  v4 = a1;
  if ( *(_DWORD *)a1 != *(_DWORD *)a3 )
    result = sub_100338A4(a1, a3, a2, *(_DWORD *)a3);
  v5 = (unsigned int)(*(_DWORD *)v4 + 31) >> 5;
  v6 = 0;
  if ( v5 )
  {
    do
    {
      result = *(_DWORD *)(*(_DWORD *)(a3 + 4) + 4 * v6);
      *(_DWORD *)(*(_DWORD *)(v4 + 4) + 4 * v6++) = result;
    }
    while ( v6 < v5 );
  }
  return result;
}

//----- (100321D9) --------------------------------------------------------
int __stdcall sub_100321D9(int a2)
{
  int v2; // ST00_4@1

  return sub_1003324F(v2, a2);
}

//----- (100321E2) --------------------------------------------------------
int __cdecl sub_100321E2()
{
  int ebp0; // ebp@0
  int v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+8h] [bp-8h]@1
  int v4; // [sp+Ch] [bp-4h]@1

  v2 = 0;
  v3 = 0;
  v4 = 0;
  return sub_1003324F(ebp0, (int)&v2);
}

//----- (100321FE) --------------------------------------------------------
int __usercall sub_100321FE<eax>(int a1<ebx>, int a2<edi>, void *a3)
{
  int v3; // eax@1
  int ebp0; // ebp@0
  int result; // eax@2

  sub_10044E80(a3);
  sub_10031F2F(ebp0);
  v3 = sub_10047CDC(a1, ebp0, a2);
  if ( v3 )
    result = v3 + 8;
  else
    result = 0;
  return result;
}

//----- (10032224) --------------------------------------------------------
int __usercall sub_10032224<eax>(int this<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>)
{
  int v4; // eax@1

  v4 = (int)sub_1002B772(a2, a3, a4);
  return sub_10032E0B(v4);
}

//----- (10032230) --------------------------------------------------------
int __thiscall sub_10032230(int this)
{
  int result; // eax@1

  result = this + 392;
  _EDX = -1;
  __asm { lock xadd [eax], edx }
  if ( _EDX == 1 )
    result = sub_100323A2(this);
  return result;
}

//----- (1003224B) --------------------------------------------------------
BOOL __thiscall sub_1003224B(int this)
{
  BOOL result; // eax@1

  _EDX = this + 472;
  _EAX = 1;
  __asm { lock xadd [edx], eax }
  result = _EAX + 1;
  if ( result == 1 )
    result = SetEvent(*(HANDLE *)(this + 460));
  return result;
}

//----- (1003226B) --------------------------------------------------------
int __stdcall sub_1003226B(int a1)
{
  int v1; // esi@1
  void *v2; // eax@2
  int result; // eax@2

  v1 = a1;
  while ( v1 )
  {
    v2 = (void *)(v1 - 4);
    v1 = *(_DWORD *)v1;
    result = sub_1002A4AA(v2);
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10032289) --------------------------------------------------------
int __stdcall sub_10032289(int a1)
{
  int v1; // esi@1
  int v2; // ecx@2
  int result; // eax@3

  v1 = a1;
  while ( v1 )
  {
    v2 = v1 - 52;
    v1 = *(_DWORD *)v1;
    if ( v2 )
      result = (*(int (__stdcall **)(signed int))(*(_DWORD *)v2 + 16))(1);
  }
  return result;
}

//----- (100322AB) --------------------------------------------------------
int __thiscall sub_100322AB(void *this)
{
  void *v1; // eax@1
  int v2; // edx@1
  int result; // eax@2
  int v4; // ecx@3

  v1 = this;
  v2 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    v4 = *(_DWORD *)(v2 + 232);
    *(_DWORD *)v1 = v4;
    if ( !v4 )
      *((_DWORD *)v1 + 1) = v1;
    result = v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100322EB) --------------------------------------------------------
int __thiscall sub_100322EB(int this)
{
  int v2; // esi@1

  v2 = this;
  UnregisterWaitEx(*(HANDLE *)(this + 464), (HANDLE)0xFFFFFFFF);
  sub_1003B587(0, *(HANDLE *)(v2 + 468), (HANDLE)0xFFFFFFFF);
  CloseHandle(*(HANDLE *)(v2 + 460));
  return sub_10032230(v2);
}

//----- (10032322) --------------------------------------------------------
char __thiscall sub_10032322(void *this, int a2, char a3)
{
  int v3; // edi@1
  int v4; // esi@1
  char result; // al@3

  v4 = 0;
  v3 = (int)this;
  if ( a3 )
    v4 = sub_1002EC1F(a2);
  sub_10033A3B(v3, a2);
  result = sub_10033A82((void *)v3);
  if ( v4 )
  {
    result = *(_BYTE *)(v4 + 76);
    if ( !result )
      result = sub_10046BE3((void *)(v4 - 4));
  }
  return result;
}

//----- (10032365) --------------------------------------------------------
LPVOID __cdecl sub_10032365()
{
  return TlsGetValue(dwTlsIndex);
}

//----- (10032372) --------------------------------------------------------
int __cdecl sub_10032372()
{
  int v1; // eax@1
  int result; // eax@2

  v1 = (int)sub_10032365();
  if ( v1 )
    result = sub_10032E0B(v1);
  else
    result = 0;
  return result;
}

//----- (10032385) --------------------------------------------------------
int __thiscall sub_10032385(int this)
{
  unsigned int v1; // edx@1
  unsigned int v2; // esi@1
  int result; // eax@2

  v1 = (unsigned int)(*(_DWORD *)this + 31) >> 5;
  v2 = 0;
  if ( v1 )
  {
    do
    {
      result = *(_DWORD *)(this + 4);
      *(_DWORD *)(result + 4 * v2++) = -1;
    }
    while ( v2 < v1 );
  }
  return result;
}

//----- (100323A2) --------------------------------------------------------
int __thiscall sub_100323A2(int this)
{
  int v1; // ecx@1
  int v2; // edi@1
  int v3; // esi@1
  int v4; // ecx@2
  int v5; // ebx@2
  int v6; // ST08_4@4
  int v7; // ecx@5
  int v8; // eax@5
  int v9; // esi@6
  int v10; // ecx@7
  PSINGLE_LIST_ENTRY v11; // eax@7
  int v12; // esi@8
  void *v13; // esi@10

  v2 = this;
  (*(void (**)(void))(**(_DWORD **)(this + 420) + 4))();
  CloseHandle(*(HANDLE *)(v2 + 380));
  v3 = *(_DWORD *)(v2 + 180);
  *(_DWORD *)(v2 + 180) = 0;
  if ( v3 )
  {
    do
    {
      v4 = *(_DWORD *)(v3 + 4);
      v5 = *(_DWORD *)v3;
      if ( v4 )
        (*(void (__stdcall **)(signed int))(*(_DWORD *)(v4 + 4) + 20))(1);
      sub_1002A4AA((LPVOID)v3);
      v1 = v6;
      v3 = v5;
    }
    while ( v5 );
  }
  v8 = ((int (__thiscall *)(int, int))InterlockedFlushSList)(v1, v2 + 488);
  v7 = v8 != 0 ? v8 - 4 : 0;
  if ( v7 )
  {
    do
    {
      v9 = *(_DWORD *)(v7 + 4) != 0 ? *(_DWORD *)(v7 + 4) - 4 : 0;
      (*(void (__stdcall **)(signed int))(*(_DWORD *)v7 + 20))(1);
      v7 = v9;
    }
    while ( v9 );
  }
  v11 = InterlockedFlushSList((PSLIST_HEADER)(v2 + 496));
  v10 = v11 != 0 ? (int)&v11[-3] : 0;
  if ( v10 )
  {
    do
    {
      v12 = *(_DWORD *)(v10 + 12) != 0 ? *(_DWORD *)(v10 + 12) - 12 : 0;
      (**(void (__stdcall ***)(_DWORD))v10)(1);
      v10 = v12;
    }
    while ( v12 );
  }
  sub_10034663(2, 4, *(_DWORD *)(v2 + 372));
  while ( *(_DWORD *)(v2 + 184) )
  {
    v13 = sub_10033DFD(v2 + 184);
    SetEvent(*((HANDLE *)v13 + 2));
    CloseHandle(*((HANDLE *)v13 + 2));
    sub_1002A4AA(v13);
  }
  return (**(int (__thiscall ***)(_DWORD, _DWORD))v2)(v2, 1);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1003249B) --------------------------------------------------------
int __thiscall sub_1003249B(unsigned int *this, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // eax@1

  v4 = (int)this;
  v5 = sub_10032DDF(a2, *this);
  result = sub_1002D215(v4, a2, v5);
  if ( result )
  {
    if ( a3 )
      *(_DWORD *)a3 = *(_DWORD *)(result + 8);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100324D1) --------------------------------------------------------
int __thiscall sub_100324D1(void *this)
{
  LPVOID v1; // eax@1
  int v2; // ebx@1
  LPVOID v3; // edi@1
  void *v4; // esi@1

  v4 = this;
  v2 = 0;
  v1 = sub_10032365();
  v3 = v1;
  if ( v1 )
  {
    if ( *((void **)v1 + 7) == v4 )
    {
      if ( !*((_BYTE *)v1 + 76) )
      {
        sub_1002E99E();
        v2 = *(_DWORD *)(*((_DWORD *)v3 + 39) + 68);
        sub_1002E99E();
      }
    }
  }
  return v2;
}

//----- (1003250C) --------------------------------------------------------
int __thiscall sub_1003250C(int this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v5; // [sp+8h] [bp-4h]@3

  v2 = this;
  v3 = 0;
  if ( (*(_DWORD *)a2 & 0xFFFFFFF) == 2 )
  {
    v3 = *(_DWORD *)(*(_DWORD *)(this + 32) + 4 * *(_DWORD *)(a2 + 8));
  }
  else
  {
    if ( (*(_DWORD *)a2 & 0xFFFFFFF) == 3 )
    {
      a2 = *(_DWORD *)(a2 + 8);
      if ( sub_1003249B((unsigned int *)(this + 348), (int)&a2, (int)&v5) )
        v3 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 4 * v5);
    }
  }
  return v3;
}

//----- (10032560) --------------------------------------------------------
int __stdcall sub_10032560(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // esi@1

  v5 = a1;
  for ( result = 0; v5 < a2 && !result; result = sub_1004099B(a4, v5++) )
    ;
  *(_DWORD *)a3 = v5 - 1;
  return result;
}

//----- (1003258B) --------------------------------------------------------
int __thiscall sub_1003258B(void *this, int a2, int a3, int a4)
{
  int result; // eax@1
  void *v5; // edi@1
  int v6; // esi@1

  v6 = a2;
  v5 = this;
  for ( result = 0; v6 < a3 && !result; result = sub_1004099B((int)((char *)v5 + 56), v6++) )
    ;
  *(_DWORD *)a4 = v6 - 1;
  return result;
}

//----- (100325BA) --------------------------------------------------------
char __thiscall sub_100325BA(int this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  char v7; // bl@1
  int v8; // esi@1
  int v9; // edi@3
  int v10; // eax@6
  unsigned int v11; // edi@6
  int v12; // edi@10
  int v13; // ecx@11
  char v15; // [sp-14h] [bp-28h]@4
  int v16; // [sp-10h] [bp-24h]@4
  int v17; // [sp-Ch] [bp-20h]@4
  int v18; // [sp-8h] [bp-1Ch]@4
  int v19; // [sp-4h] [bp-18h]@4
  int v20; // [sp+10h] [bp-4h]@6

  v7 = 1;
  v8 = this;
  if ( (a3 & 0xFFFFFFF) != 1 )
  {
    if ( (a3 & 0xFFFFFFFu) - 2 <= 1 )
    {
      v9 = sub_1003250C(this, (int)&a3);
      if ( v9 )
      {
        v19 = a7;
        sub_1002F3E5((int)&v15, (int)&a3);
        if ( sub_10045E52((void *)v9, a2, *(int *)&v15, v16, v17, v18, v19) )
          return v7;
      }
    }
    goto LABEL_10;
  }
  v10 = *(_DWORD *)(this + 28) + 16 * a5;
  v11 = 0;
  v20 = *(_DWORD *)(this + 28) + 16 * a5;
  if ( *(_DWORD *)(this + 44) <= 0 )
  {
LABEL_10:
    v12 = 0;
    if ( *(_DWORD *)(v8 + 44) <= 0 )
    {
LABEL_15:
      v7 = 0;
    }
    else
    {
      while ( 1 )
      {
        v13 = *(_DWORD *)(*(_DWORD *)(v8 + 32) + 4 * v12);
        if ( v13 )
        {
          if ( *(_DWORD *)(v13 + 28) > 0 )
          {
            *(_DWORD *)&v15 &= 0xF0000000u;
            *(_DWORD *)&v15 &= 0xFFFFFFFu;
            if ( sub_10045E52((void *)v13, a2, *(int *)&v15, v16, 0, 0, a7) )
              break;
          }
        }
        ++v12;
        if ( v12 >= *(_DWORD *)(v8 + 44) )
          goto LABEL_15;
      }
    }
    return v7;
  }
  while ( 1 )
  {
    if ( (1 << (v11 & 0x1F)) & *(_DWORD *)(*(_DWORD *)(v10 + 4) + 4 * (v11 >> 5)) )
    {
      v19 = a7;
      sub_1002F3E5((int)&v15, (int)&a3);
      if ( sub_10045E52(*(void **)(*(_DWORD *)(v8 + 32) + 4 * v11), a2, *(int *)&v15, v16, v17, v18, v19) )
        return v7;
    }
    v10 = v20;
    ++v11;
    if ( (signed int)v11 >= *(_DWORD *)(v8 + 44) )
      goto LABEL_10;
  }
}

//----- (100326B7) --------------------------------------------------------
char __thiscall sub_100326B7(int this)
{
  char v1; // dl@1
  int v2; // ecx@1

  v2 = *(_DWORD *)(this + 180);
  v1 = 0;
  while ( v2 )
  {
    if ( !*(_BYTE *)(*(_DWORD *)(v2 + 4) + 236) && *(_DWORD *)(*(_DWORD *)(v2 + 4) + 44) )
      return 1;
    v2 = *(_DWORD *)v2;
  }
  return v1;
}

//----- (100326E1) --------------------------------------------------------
char __thiscall sub_100326E1(void *this)
{
  void *v1; // eax@1
  int v2; // ecx@1
  char v3; // bl@1
  int v4; // esi@2
  signed int v5; // edi@3
  int v6; // eax@4
  signed int v7; // edi@12
  int v8; // eax@13
  void *v10; // [sp+4h] [bp-Ch]@1
  void *v11; // [sp+8h] [bp-8h]@4
  void *v12; // [sp+8h] [bp-8h]@13
  int i; // [sp+Ch] [bp-4h]@1

  v1 = this;
  v2 = 0;
  v3 = 0;
  v10 = v1;
  for ( i = 0; v2 < *((_DWORD *)v10 + 11); i = v2 )
  {
    v4 = *(_DWORD *)(*((_DWORD *)v1 + 9) + 4 * v2);
    if ( v4 )
    {
      v5 = 0;
      if ( *(_DWORD *)(v4 + 80) > 0 )
      {
        while ( 1 )
        {
          v6 = sub_1004099B(v4 + 16, v5);
          v11 = (void *)v6;
          if ( v6 )
          {
            if ( sub_10041170(v6) || sub_10041179(v11) )
              break;
          }
          ++v5;
          if ( v5 >= *(_DWORD *)(v4 + 80) )
            goto LABEL_10;
        }
        v3 = 1;
LABEL_10:
        v2 = i;
      }
      if ( v3 )
        return v3;
      v7 = 0;
      if ( *(_DWORD *)(v4 + 160) > 0 )
      {
        while ( 1 )
        {
          v8 = sub_1004099B(v4 + 96, v7);
          v12 = (void *)v8;
          if ( v8 )
          {
            if ( sub_10041170(v8) || sub_10041179(v12) )
              break;
          }
          ++v7;
          if ( v7 >= *(_DWORD *)(v4 + 160) )
            goto LABEL_19;
        }
        v3 = 1;
LABEL_19:
        v2 = i;
      }
    }
    v1 = v10;
    ++v2;
  }
  return v3;
}

//----- (100327A8) --------------------------------------------------------
int __thiscall sub_100327A8(int this)
{
  return *(_DWORD *)(sub_10032B1F(this) + 8);
}

//----- (100327B1) --------------------------------------------------------
int __userpurge sub_100327B1<eax>(int a1<ebp>, int a2, int a3)
{
  int v3; // eax@1
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // eax@1
  int v9; // eax@2
  int v10; // eax@3
  int v11; // eax@6

  sub_10035668();
  v5 = v7;
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)(a1 - 16) = 0;
  v8 = sub_1003D69A();
  v6 = *(_DWORD *)(a1 + 8);
  sub_100313DF(*(_DWORD *)(a1 + 8), 0, v5, v8);
  v4 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 - 4) = 0;
  v3 = *(_DWORD *)v4 & 0xFFFFFFF;
  *(_DWORD *)(a1 - 16) = 1;
  if ( !v3 )
  {
    sub_10032385(v6);
    return sub_10035636(4);
  }
  v9 = v3 - 1;
  if ( !v9 )
  {
    v11 = 16 * *(_DWORD *)(v4 + 8) + 8 + *(_DWORD *)(v5 + 28);
    goto LABEL_8;
  }
  v10 = v9 - 1;
  if ( !v10 )
  {
    v11 = *(_DWORD *)(*(_DWORD *)(v5 + 32) + 4 * *(_DWORD *)(v4 + 8)) + 8;
LABEL_8:
    sub_1003217C(v6, v5, v11);
    return sub_10035636(4);
  }
  if ( v10 == 1 )
  {
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(v4 + 8);
    sub_1003249B((unsigned int *)(v5 + 360), a1 + 8, a1 + 12);
    *(_DWORD *)(*(_DWORD *)(v6 + 4) + 4 * (*(_DWORD *)(a1 + 12) >> 5)) |= 1 << (*(_DWORD *)(a1 + 12) & 0x1F);
  }
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1003285B) --------------------------------------------------------
int __usercall sub_1003285B<eax>(int a1<ebp>, int a2<edi>)
{
  void *v2; // ecx@1
  const void **v3; // eax@3
  signed int v5; // [sp-4h] [bp-4h]@1

  v5 = 8;
  sub_10035668();
  *(_DWORD *)(a1 - 20) = &dword_10077070;
  sub_10030F90(&dword_10077070);
  v2 = (void *)dword_100766F0;
  *(_DWORD *)(a1 - 4) = 0;
  if ( !v2 || !sub_10034028(v2) )
  {
    sub_10044B57(0, a1 - 16, 0, 8);
    v3 = (const void **)dword_100766F4;
    *(_BYTE *)(a1 - 4) = 1;
    if ( v3 )
      sub_10044BF5((void **)(a1 - 16), v3);
    dword_100766F0 = sub_100321FE(0, a2, (void *)(a1 - 16));
    sub_10032E16(dword_100766F0);
    (*(void (**)(void))(*(_DWORD *)dword_100766F0 + 16))();
    *(_BYTE *)(a1 - 4) = 0;
    sub_10044BEC((LPVOID *)(a1 - 16));
  }
  dword_10077070 = 0;
  return sub_10035636(v5);
}
// 10032E16: using guessed type int __thiscall sub_10032E16(_DWORD);
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 100766F0: using guessed type int dword_100766F0;
// 100766F4: using guessed type int dword_100766F4;
// 10077070: using guessed type int dword_10077070;

//----- (100328EB) --------------------------------------------------------
int __userpurge sub_100328EB<eax>(int a1<ebx>, int a2<ebp>, int a3)
{
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  PSINGLE_LIST_ENTRY v7; // eax@1
  int v8; // eax@2

  sub_10035668();
  v5 = v4;
  v7 = InterlockedPopEntrySList((PSLIST_HEADER)(v4 + 488));
  v6 = v7 != 0 ? (int)&v7[-1] : 0;
  if ( v6 )
  {
    sub_10047A88(v6, *(_DWORD *)(a2 + 8));
  }
  else
  {
    v8 = sub_1002ADB1(v3, v4, a1, v5, 176);
    *(_DWORD *)(a2 - 16) = v8;
    *(_DWORD *)(a2 - 4) = 0;
    if ( v8 )
      sub_100477F0(a1, a2, v5, *(_DWORD *)(a2 + 8));
  }
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1003294B) --------------------------------------------------------
int __userpurge sub_1003294B<eax>(int a1<ebp>, int a2)
{
  int v2; // ecx@1
  int v3; // edi@1
  int v5; // esi@4
  int v13; // esi@11
  PSINGLE_LIST_ENTRY v14; // eax@11
  int v15; // edx@12
  int v23; // [sp-8h] [bp-8h]@15
  signed int v24; // [sp-4h] [bp-4h]@1

  v24 = 8;
  sub_100356D1();
  v3 = v2;
  *(_DWORD *)(a1 - 20) = v2;
  if ( !*(_BYTE *)(a1 + 8) )
  {
    _EBX = 1;
LABEL_9:
    _EAX = v3 + 400;
    _ECX = _EBX;
    __asm { lock xadd [eax], ecx }
    if ( !*(_BYTE *)(a1 + 8) )
      *(_DWORD *)(v3 + 456) = GetTickCount();
    v14 = InterlockedPopEntrySList((PSLIST_HEADER)(v3 + 480));
    v13 = v14 != 0 ? (int)&v14[-2] : 0;
    *(_DWORD *)(a1 + 8) = v13;
    if ( !v13 )
    {
      v13 = (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 64))(v3);
      *(_DWORD *)(a1 + 8) = v13;
      sub_10031B97(v15, v3, _EBX, v3, v13);
      _ECX = v3 + 392;
      __asm { lock xadd [ecx], ebx }
    }
    sub_10046C65(v13);
    *(_DWORD *)(a1 - 4) = 0;
    *(_DWORD *)(v13 + 156) = 0;
    (*(void (__cdecl **)(int, signed int))(**(_DWORD **)(v3 + 420) + 8))(v13, v24);
    if ( v13 )
    {
      *(_DWORD *)(v13 + 16) = 0;
      *(_DWORD *)(v13 + 20) = 0;
    }
    return sub_10035636(v23);
  }
  if ( !(unsigned __int8)(*(int (__cdecl **)(signed int))(*(_DWORD *)v2 + 88))(8) || !sub_10032C0F(v3) )
  {
    _EBX = 1;
    v5 = sub_10034561(v3, 1);
    if ( v5 )
    {
      if ( GetTickCount() - *(_DWORD *)(v3 + 456) < v5 )
        return sub_10035636(v23);
      *(_BYTE *)(a1 + 8) = 0;
    }
    goto LABEL_9;
  }
  return sub_10035636(v23);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (10032A58) --------------------------------------------------------
int __thiscall sub_10032A58(void *this)
{
  _ECX = (int)((char *)this + 328);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return _EAX + 1;
}

//----- (10032A67) --------------------------------------------------------
int __thiscall sub_10032A67(void *this)
{
  _ECX = (int)((char *)this + 332);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return _EAX + 1;
}

//----- (10032A76) --------------------------------------------------------
int __cdecl sub_10032A76()
{
  _ECX = &unk_100766FC;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return _EAX + 1;
}

//----- (10032A84) --------------------------------------------------------
int __thiscall sub_10032A84(int this)
{
  int v1; // eax@1
  void *v2; // edi@1
  int v3; // esi@1
  int v4; // esi@1

  v4 = this;
  v2 = (void *)(this + 308);
  sub_1002B98B((void *)(this + 308));
  v1 = sub_10033DB1((void *)(v4 + 304));
  v3 = v1;
  if ( v1 )
    *(_DWORD *)(v1 + 12) = 1;
  sub_1002BB75(v2);
  return v3;
}

//----- (10032AB9) --------------------------------------------------------
int __stdcall sub_10032AB9(int a1, int a2, int a3)
{
  int v3; // edx@1
  int result; // eax@2

  v3 = *(_DWORD *)a1 + 1;
  if ( v3 <= a2 || (result = sub_10032560(v3, *(_DWORD *)(a3 + 64), a1, a3), v3 = 0, !result) )
    result = sub_10032560(v3, a2, a1, a3);
  return result;
}

//----- (10032AF5) --------------------------------------------------------
int __thiscall sub_10032AF5(int this, int a2, int a3)
{
  int v4; // esi@1
  int v5; // eax@1

  v4 = this;
  v5 = sub_10032B40(this, *(_DWORD *)(a3 + 184));
  return *(_DWORD *)(*(_DWORD *)(v4 + 36) + 4 * v5) != a2 ? *(_DWORD *)(*(_DWORD *)(v4 + 36) + 4 * v5) : 0;
}

//----- (10032B1F) --------------------------------------------------------
int __thiscall sub_10032B1F(int this)
{
  int v2; // edx@1
  int v3; // esi@1

  v2 = *(_DWORD *)(this + 376);
  v3 = *(_DWORD *)(*(_DWORD *)(this + 36) + 4 * v2);
  *(_DWORD *)(this + 376) = sub_10032B40(this, v2);
  return v3;
}

//----- (10032B40) --------------------------------------------------------
int __thiscall sub_10032B40(int this, int a2)
{
  int v2; // edx@1

  v2 = a2;
  do
    v2 = (v2 + 1) % *(_DWORD *)(this + 44);
  while ( !*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 36) + 4 * v2) + 188) );
  return v2;
}

//----- (10032B62) --------------------------------------------------------
int __thiscall sub_10032B62(int this, int a2, int a3)
{
  int v3; // edx@1
  void *v4; // edi@1
  int result; // eax@2

  v3 = *(_DWORD *)a2 + 1;
  v4 = (void *)this;
  if ( v3 <= a3 || (result = sub_1003258B((void *)this, v3, *(_DWORD *)(this + 120), a2), v3 = 0, !result) )
    result = sub_1003258B(v4, v3, a3, a2);
  return result;
}

//----- (10032B97) --------------------------------------------------------
int __thiscall sub_10032B97(int this)
{
  return *(_DWORD *)(this + 20);
}

//----- (10032B9B) --------------------------------------------------------
int __userpurge sub_10032B9B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  sub_10044B75(a1, a5, a3, a4, (const void **)(a2 + 4));
  return a5;
}

//----- (10032BB6) --------------------------------------------------------
int __userpurge sub_10032BB6<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4, int a5)
{
  PSINGLE_LIST_ENTRY v5; // eax@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // eax@2

  v5 = InterlockedPopEntrySList((PSLIST_HEADER)(a1 + 496));
  v6 = v5 != 0 ? (int)&v5[-3] : 0;
  if ( v6 )
  {
    *(_DWORD *)(v5 != 0 ? (int)&v5[-3] + 4 : 4) = a4;
    *(_DWORD *)(v5 != 0 ? (int)&v5[-3] + 8 : 8) = a5;
    goto LABEL_6;
  }
  v8 = sub_1002ADB1(0, v7, a2, a3, 16);
  v6 = v8;
  if ( v8 )
  {
    *(_DWORD *)(v8 + 4) = a4;
    *(_DWORD *)v8 = &off_10061E98;
    *(_DWORD *)(v8 + 8) = a5;
LABEL_6:
    *(_DWORD *)(v6 + 12) = 0;
    return v6;
  }
  return 0;
}
// 10061E98: using guessed type int (__stdcall *off_10061E98)(char);

//----- (10032C0F) --------------------------------------------------------
int __thiscall sub_10032C0F(int this)
{
  PSINGLE_LIST_ENTRY v2; // eax@1

  v2 = InterlockedPopEntrySList((PSLIST_HEADER)(this + 504));
  return v2 != 0 ? (int)&v2[-2] : 0;
}

//----- (10032C26) --------------------------------------------------------
int __thiscall sub_10032C26(int this, char a2)
{
  int v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  sub_1003249B((unsigned int *)(this + 360), (int)&a2, (int)&v3);
  return v3;
}

//----- (10032C44) --------------------------------------------------------
int __thiscall sub_10032C44(void *this)
{
  void *v1; // edi@3
  void *v2; // esi@3
  int v3; // edi@3
  int v4; // ecx@1
  int result; // eax@2

  v4 = (int)((char *)this + 288);
  if ( *(_DWORD *)v4 )
  {
    v1 = (void *)v4;
    v2 = (void *)(v4 + 8);
    sub_10034BBC((void *)(v4 + 8));
    v3 = sub_100322AB(v1);
    sub_10034BCC(v2);
    result = v3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10032C57) --------------------------------------------------------
int __usercall sub_10032C57<eax>(int a1<ebp>, int a2<edi>)
{
  char v2; // bl@1
  void *v10; // eax@4
  int v11; // edx@4
  int v12; // ecx@4
  void *v13; // ecx@5
  int v14; // eax@5

  sub_10035668();
  v2 = *(_BYTE *)(a1 + 8);
  if ( v2 )
  {
    if ( dword_10076704 >= 32 )
      return sub_10035636(0);
    _ECX = &dword_10076704;
    _EAX = 1;
    __asm { lock xadd [ecx], eax }
  }
  v10 = InterlockedPopEntrySList(&ListHead);
  if ( !v10 )
  {
    v14 = sub_1002ADB1(v11, v12, v2, a2, 776);
    v13 = (void *)v14;
    *(_DWORD *)(a1 + 8) = v14;
    v10 = 0;
    *(_DWORD *)(a1 - 4) = 0;
    if ( v13 )
      v10 = sub_10031730(v13);
  }
  *((_BYTE *)v10 + 772) = v2;
  return sub_10035636(0);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 10076704: using guessed type int dword_10076704;

//----- (10032CB8) --------------------------------------------------------
int __thiscall sub_10032CB8(int this, int a2)
{
  int result; // eax@2

  if ( *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 36) + 4 * a2) + 188) )
    result = a2;
  else
    result = sub_10032B40(this, a2);
  return result;
}

//----- (10032CDB) --------------------------------------------------------
void __thiscall sub_10032CDB(void *this, int a2)
{
  int v2; // ebx@1
  void *v3; // esi@1
  int v4; // eax@2
  unsigned int v5; // edx@2
  unsigned int v6; // ecx@2
  int v7; // edi@2
  unsigned int v9; // eax@2
  int v10; // [sp+8h] [bp-4h]@2

  v2 = a2;
  v3 = this;
  if ( a2 != *(_DWORD *)this )
  {
    v7 = (unsigned int)(a2 + 31) >> 5;
    _ECX = 0;
    v9 = 4 * ((unsigned int)(a2 + 31) >> 5);
    __asm { seto    cl }
    v4 = sub_1002965B((a2 + 31) / 0x100u, v9 | -_ECX, a2, v7, v9 | -_ECX);
    v6 = (unsigned int)(*(_DWORD *)v3 + 31) >> 5;
    v5 = 0;
    v10 = v4;
    if ( v6 )
    {
      do
      {
        *(_DWORD *)(v4 + 4 * v5) = *(_DWORD *)(*((_DWORD *)v3 + 1) + 4 * v5);
        ++v5;
      }
      while ( v5 < v6 );
      v2 = a2;
    }
    sub_10039210((void *)(v4 + 4 * v6), 0, 4 * (v7 - v6));
    sub_10030383(*((LPVOID *)v3 + 1));
    *((_DWORD *)v3 + 1) = v10;
    *(_DWORD *)v3 = v2;
  }
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (10032D5A) --------------------------------------------------------
void __thiscall sub_10032D5A(void *this, int a2)
{
  int v2; // ebx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // edx@2
  unsigned int v6; // ecx@2
  signed __int64 v8; // qax@2
  int v9; // [sp+14h] [bp+8h]@2

  v4 = a2;
  v3 = (int)this;
  v2 = *(_DWORD *)this;
  if ( a2 != *(_DWORD *)this )
  {
    sub_10032CDB(this, a2);
    _ECX = 0;
    v8 = 4i64 * (unsigned int)a2;
    __asm { seto    cl }
    v5 = sub_1002965B(SHIDWORD(v8), v8 | -_ECX, v2, v3, v8 | -_ECX);
    v6 = 0;
    v9 = v5;
    if ( v2 )
    {
      do
      {
        *(_DWORD *)(v5 + 4 * v6) = *(_DWORD *)(*(_DWORD *)(v3 + 8) + 4 * v6);
        ++v6;
      }
      while ( v6 < v2 );
    }
    sub_10039210((void *)(v5 + 4 * v2), 0, 4 * (v4 - v2));
    sub_10030383(*(LPVOID *)(v3 + 8));
    *(_DWORD *)(v3 + 8) = v9;
  }
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (10032DCA) --------------------------------------------------------
bool __thiscall sub_10032DCA(int this)
{
  return (*(_DWORD *)(this + 404) & 0xA0000000) == -1610612736;
}

//----- (10032DDF) --------------------------------------------------------
int __cdecl sub_10032DDF(int a1, unsigned int a2)
{
  unsigned int v2; // edx@1
  unsigned int v3; // ecx@1

  v2 = -2128831035;
  v3 = 0;
  do
    v2 = 16777619 * (*(_BYTE *)(v3++ + a1) ^ v2);
  while ( v3 < 4 );
  return v2 % a2;
}

//----- (10032E0B) --------------------------------------------------------
int __thiscall sub_10032E0B(int this)
{
  return *(_DWORD *)(this + 28);
}

//----- (10032E0F) --------------------------------------------------------
int __thiscall sub_10032E0F(int this)
{
  return *(_DWORD *)(this + 372);
}

//----- (10032E16) --------------------------------------------------------
#error "1003323B: call analysis failed (funcsize=373)"

//----- (10033241) --------------------------------------------------------
int __thiscall sub_10033241(void *this)
{
  int result; // eax@1

  _ECX = (int)((char *)this + 392);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (1003324F) --------------------------------------------------------
int __userpurge sub_1003324F<eax>(int a1<ebp>, int a2)
{
  PSINGLE_LIST_ENTRY v2; // eax@1
  int v3; // edx@1
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v9; // [sp-8h] [bp-8h]@7

  sub_10035668();
  v5 = v7;
  v4 = v7 + 96;
  v2 = InterlockedPopEntrySList((PSLIST_HEADER)(v7 + 96));
  v6 = 0;
  if ( v2 )
    v6 = (int)&v2[-13];
  if ( *(_DWORD *)(v5 + 12) )
  {
    *(_DWORD *)(a1 - 32) = 0;
    *(_DWORD *)(a1 - 24) = 0;
    *(_DWORD *)(a1 - 20) = 0;
    if ( !v6 )
    {
      v6 = sub_1002ADB1(v3, 0, v4, v5, 60);
      *(_DWORD *)(a1 + 8) = v6;
      *(_DWORD *)(a1 - 4) = 1;
      if ( v6 )
      {
        sub_1004065C(a1, v5, a1 - 32);
        *(_DWORD *)(v6 + 56) = 0;
        *(_DWORD *)v6 = &off_10061F5C;
        *(_BYTE *)(v6 + 48) = 2;
        goto LABEL_12;
      }
LABEL_11:
      v6 = 0;
      goto LABEL_12;
    }
    v9 = a1 - 32;
LABEL_14:
    sub_100411AE(v6, v9);
    goto LABEL_15;
  }
  if ( v6 )
  {
    v9 = *(_DWORD *)(a1 + 8);
    goto LABEL_14;
  }
  v6 = sub_1002ADB1(v3, 0, v4, v5, 56);
  *(_DWORD *)(a1 - 16) = v6;
  *(_DWORD *)(a1 - 4) = 0;
  if ( !v6 )
    goto LABEL_11;
  sub_1004065C(a1, v5, *(_DWORD *)(a1 + 8));
  *(_DWORD *)v6 = &off_10061F1C;
  *(_BYTE *)(v6 + 48) = 1;
LABEL_12:
  *(_DWORD *)(a1 - 4) = -1;
LABEL_15:
  sub_10031A3E(v4, v6);
  return sub_10035636(20);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 10061F1C: using guessed type int (__stdcall *off_10061F1C)(int, int);
// 10061F5C: using guessed type int (__stdcall *off_10061F5C)(int, int);

//----- (10033312) --------------------------------------------------------
int __thiscall sub_10033312(void *this)
{
  int v1; // esi@1
  int v2; // edi@2
  int result; // eax@4

  v1 = (int)this;
  if ( *((_BYTE *)this + 48) & 4 )
  {
    result = 0;
  }
  else
  {
    _EAX = (int)((char *)this + 20);
    _EDI = -1;
    __asm { lock xadd [eax], edi }
    v2 = _EDI - 1;
    if ( !v2 )
    {
      (*(void (**)(void))(*(_DWORD *)this + 28))();
      sub_10033E5C(*(_DWORD *)(v1 + 4), v1);
    }
    result = v2;
  }
  return result;
}

//----- (10033340) --------------------------------------------------------
bool __thiscall sub_10033340(int this, int a2)
{
  int v2; // edx@1
  unsigned int v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v4 = (unsigned int)(*(_DWORD *)this + 31) >> 5;
  v3 = 0;
  if ( v4 )
  {
    do
    {
      if ( v2 )
        break;
      v2 = *(_DWORD *)(*(_DWORD *)(this + 4) + 4 * v3) & *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * v3);
      ++v3;
    }
    while ( v3 < v4 );
  }
  return v2 != 0;
}

//----- (1003337E) --------------------------------------------------------
int __thiscall sub_1003337E(int this, int (__cdecl *a2)(_DWORD), int a3, int a4)
{
  int result; // eax@2

  if ( *(_DWORD *)(a4 + 404) & 0x20000000 )
  {
    result = a2(a3);
  }
  else
  {
    *(_DWORD *)this = a2;
    *(_DWORD *)(this + 4) = a3;
    result = sub_100333B1(a4, this);
  }
  return result;
}

//----- (100333B1) --------------------------------------------------------
int __thiscall sub_100333B1(int this, int a2)
{
  int v3; // ebx@1
  void *v4; // edi@1

  v3 = this;
  v4 = (void *)(this + 324);
  sub_10034BBC((void *)(this + 324));
  *(_DWORD *)(a2 + 8) = sub_1003380A((void *)v3);
  *(_DWORD *)(a2 + 12) = 0;
  **(_DWORD **)(v3 + 320) = a2;
  *(_DWORD *)(v3 + 320) = a2 + 12;
  return sub_10034BCC(v4);
}

//----- (100333F5) --------------------------------------------------------
char __thiscall sub_100333F5(int this)
{
  char v1; // dl@1

  v1 = 0;
  if ( *(_DWORD *)(this + 24)
    || *(_DWORD *)(this + 8) != *(_DWORD *)(this + 16)
    || *(_DWORD *)(this + 12) != *(_DWORD *)(this + 20) )
    v1 = 1;
  return v1;
}

//----- (10033412) --------------------------------------------------------
char __thiscall sub_10033412(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v4; // esi@1
  char v5; // bl@1
  char v6; // [sp+8h] [bp-8h]@1
  void *v7; // [sp+Ch] [bp-4h]@1

  v4 = this;
  sub_100327B1(ebp0, (int)&v6, a2);
  v5 = sub_10033340((int)&v6, (int)((char *)v4 + 48));
  sub_10030383(v7);
  return v5;
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (10033446) --------------------------------------------------------
int __stdcall sub_10033446(int a1, int a2, int a3, int a4)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (10033457) --------------------------------------------------------
char __thiscall sub_10033457(int this, int a2)
{
  char result; // al@2

  if ( *(_DWORD *)a2 == *(_DWORD *)(this + 336) )
  {
    result = 0;
  }
  else
  {
    *(_DWORD *)a2 = *(_DWORD *)(this + 336);
    result = 1;
  }
  return result;
}

//----- (10033479) --------------------------------------------------------
char __thiscall sub_10033479(int this, int a2)
{
  int v2; // esi@1
  int v3; // ST08_4@1
  char result; // al@6
  int v5; // [sp+8h] [bp-Ch]@1
  int v6; // [sp+Ch] [bp-8h]@5

  v5 = 0;
  v2 = this;
  if ( sub_100325BA(this, (int)&v5, 0, v3, 0, 0, 12) )
  {
    if ( v5 == 2 || v5 == 8 )
    {
      InterlockedPushEntrySList((PSLIST_HEADER)(v2 + 504), (PSINGLE_LIST_ENTRY)(a2 + 8));
      sub_10045165(v6, v5, 0, 0);
    }
    else
    {
      sub_100451D9((int)&v5, a2);
    }
    result = 1;
  }
  else
  {
    InterlockedPushEntrySList((PSLIST_HEADER)(v2 + 504), (PSINGLE_LIST_ENTRY)(a2 + 8));
    result = 0;
  }
  return result;
}

//----- (10033508) --------------------------------------------------------
DWORD __cdecl sub_10033508()
{
  int v0; // eax@2
  char v2; // [sp+0h] [bp-10h]@5

  sub_1002BB3C();
  dwTlsIndex = TlsAlloc();
  if ( dwTlsIndex == -1 )
  {
    v0 = GetLastError();
    if ( v0 > 0 )
      v0 = (unsigned __int16)v0 | 0x80070000;
    sub_10030079((int)&v2, v0);
    sub_100355DB((int)&v2, (int)&unk_1006C6F4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10033556);
  }
  return sub_10047DD2();
}

//----- (10033556) --------------------------------------------------------
BOOL __cdecl sub_10033556()
{
  BOOL result; // eax@1

  sub_10047E16();
  result = TlsFree(dwTlsIndex);
  dwTlsIndex = 0;
  return result;
}

//----- (1003356F) --------------------------------------------------------
int __thiscall sub_1003356F(void *this, int a2)
{
  void *v3; // edi@1
  int v4; // esi@2
  int v6; // esi@3
  int v7; // eax@4
  int v8; // ecx@4
  int v9; // ST04_4@4
  int v10; // esi@5
  int v11; // eax@11
  int v12; // esi@12
  int v13; // eax@18
  int v14; // esi@19
  char v16; // [sp+Ch] [bp-14h]@18
  int v17; // [sp+10h] [bp-10h]@4
  char v18; // [sp+14h] [bp-Ch]@4
  int v19; // [sp+18h] [bp-8h]@4
  int i; // [sp+1Ch] [bp-4h]@3

  v3 = this;
  _ECX = (int)((char *)this + 412);
  do
  {
    v4 = *(_DWORD *)_ECX;
    _EDX = a2;
    __asm { lock cmpxchg [ecx], edx }
  }
  while ( v4 != v4 );
  sub_1002B98B((char *)v3 + 308);
  v6 = 0;
  for ( i = 0; v6 < *((_DWORD *)v3 + 11); i = v6 )
  {
    v8 = *(_DWORD *)(*((_DWORD *)v3 + 9) + 4 * v6);
    v17 = *(_DWORD *)(*((_DWORD *)v3 + 8) + 4 * v6);
    v9 = *(_DWORD *)(v8 + 80);
    v19 = v8;
    v7 = sub_10032560(0, v9, (int)&v18, v8 + 16);
    if ( v7 )
    {
      v10 = v19;
      do
      {
        if ( (unsigned int)(a2 - *(_DWORD *)(v7 + 264)) > 0x7D0 )
        {
          if ( *(_DWORD *)(v7 + 280) == 1 )
          {
            *(_DWORD *)(v7 + 280) = 2;
            sub_10031BC4((char *)v3 + 304, v7 + 268);
          }
        }
        v7 = sub_10032AB9((int)&v18, 0, v10 + 16);
      }
      while ( v7 );
      v6 = i;
    }
    v11 = sub_10032560(0, *(_DWORD *)(v19 + 160), (int)&v18, v19 + 96);
    if ( v11 )
    {
      v12 = v19;
      do
      {
        if ( (unsigned int)(a2 - *(_DWORD *)(v11 + 264)) > 0x7D0 )
        {
          if ( *(_DWORD *)(v11 + 280) == 1 )
          {
            *(_DWORD *)(v11 + 280) = 2;
            sub_10031BC4((char *)v3 + 304, v11 + 268);
          }
        }
        v11 = sub_10032AB9((int)&v18, 0, v12 + 96);
      }
      while ( v11 );
      v6 = i;
    }
    v13 = sub_1003258B((void *)v17, 0, *(_DWORD *)(v17 + 120), (int)&v16);
    if ( v13 )
    {
      v14 = v17;
      do
      {
        if ( (unsigned int)(a2 - *(_DWORD *)(v13 + 184)) > 0x7D0 )
        {
          if ( *(_DWORD *)(v13 + 204) == 1 )
          {
            *(_DWORD *)(v13 + 204) = 2;
            sub_10031BC4((char *)v3 + 304, v13 + 192);
          }
        }
        v13 = sub_10032B62(v14, (int)&v16, 0);
      }
      while ( v13 );
      v6 = i;
    }
    ++v6;
  }
  return sub_1002BB75((char *)v3 + 308);
}

//----- (1003370C) --------------------------------------------------------
int __thiscall sub_1003370C(int this)
{
  int v1; // esi@1
  int i; // eax@4
  int v3; // edx@4
  int v4; // ecx@4

  v1 = this;
  if ( dword_100766F0 == this )
  {
    sub_10030F90(&dword_10077070);
    dword_100766F0 = dword_100766F0 != v1 ? dword_100766F0 : 0;
    dword_10077070 = 0;
  }
  if ( *(_DWORD *)(v1 + 392) > 1 )
  {
    _EDI = v1 + 404;
    v3 = *(_DWORD *)(v1 + 404);
    v4 = *(_DWORD *)(v1 + 404);
    for ( i = *(_DWORD *)(v1 + 404); ; v4 = i )
    {
      _ECX = v4 | 0x80000000;
      __asm { lock cmpxchg [edi], ecx }
      if ( i == v3 )
        break;
      v3 = i;
    }
    if ( !(v3 & 0x1FFFFFFF) )
      sub_10031E48((void *)v1);
  }
  return sub_10032230(v1);
}
// 100766F0: using guessed type int dword_100766F0;
// 10077070: using guessed type int dword_10077070;

//----- (10033782) --------------------------------------------------------
int __thiscall sub_10033782(int this)
{
  int v1; // eax@1
  int v2; // esi@1
  char v3; // bl@4
  int v11; // eax@6
  int result; // eax@8

  v2 = this;
  v1 = (int)sub_10032365();
  if ( !v1 || *(_BYTE *)(v1 + 76) || sub_10032E0B(v1) != v2 )
  {
    v3 = 1;
    _EAX = v2 + 392;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  else
  {
    v3 = 0;
  }
  sub_10032066(v2, 0);
  (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 84))(v2);
  _EDI = v2 + 404;
  v11 = *(_DWORD *)(v2 + 404);
  do
  {
    _ECX = v11 & 0xBFFFFFFF | 0x20000000;
    __asm { lock cmpxchg [edi], ecx }
  }
  while ( v11 != v11 );
  sub_10033B65(v2, v11 & 0x1FFFFFFF);
  result = (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 80))(v2);
  if ( v3 )
    result = sub_10032230(v2);
  return result;
}

//----- (1003380A) --------------------------------------------------------
int __thiscall sub_1003380A(void *this)
{
  int result; // eax@2

  _ECX = (int)((char *)this + 336);
  do
  {
    do
    {
      _EAX = 1;
      __asm { lock xadd [ecx], eax }
      result = _EAX + 1;
    }
    while ( !result );
  }
  while ( result == -1 );
  return result;
}

//----- (10033822) --------------------------------------------------------
int __thiscall sub_10033822(void *_ECX, int a2)
{
  int result; // eax@1
  int v3; // esi@1

  do
  {
    v3 = *(_DWORD *)_ECX;
    *(_DWORD *)a2 = *(_DWORD *)_ECX;
    _EDX = a2;
    result = v3;
    __asm { lock cmpxchg [ecx], edx }
  }
  while ( v3 != v3 );
  return result;
}

//----- (10033840) --------------------------------------------------------
char __thiscall sub_10033840(void *this, int a2, char a3, int a4, int a5, int a6)
{
  char v6; // bl@1
  void *v7; // edi@1
  int v8; // ecx@3
  int v9; // ecx@4
  char v11; // [sp-14h] [bp-2Ch]@4
  int v12; // [sp-10h] [bp-28h]@4
  int v13; // [sp-Ch] [bp-24h]@4
  int v14; // [sp-8h] [bp-20h]@4
  int v15; // [sp-4h] [bp-1Ch]@4
  int v16; // [sp+Ch] [bp-Ch]@4
  int v17; // [sp+14h] [bp-4h]@1

  v6 = 0;
  v17 = (int)this;
  v7 = (void *)(a2 + 4);
  if ( !a2 )
    v7 = 0;
  if ( sub_10032365() != v7 )
  {
    sub_1002EFDD(v8);
    v15 = 5;
    v16 = 0;
    sub_1002F3E5((int)&v11, (int)&a3);
    if ( sub_100325BA(v17, (int)&v16, *(int *)&v11, v12, v13, v14, v15) )
    {
      sub_100451D9((int)&v16, a2);
      v6 = 1;
    }
    sub_1002EFDD(v9);
  }
  return v6;
}
// 1002EFDD: using guessed type _DWORD __thiscall sub_1002EFDD(_DWORD ecx0);

//----- (100338A4) --------------------------------------------------------
int __userpurge sub_100338A4<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  int result; // eax@1
  int v5; // esi@1
  unsigned int v7; // eax@1

  v5 = a1;
  sub_10030383(*(LPVOID *)(a1 + 4));
  *(_DWORD *)v5 = a4;
  _ECX = 0;
  v7 = 4 * ((unsigned int)(a4 + 31) >> 5);
  __asm { seto    cl }
  result = sub_1002965B((a4 + 31) / 0x100u, v7 | -_ECX, a2, a3, v7 | -_ECX);
  *(_DWORD *)(v5 + 4) = result;
  return result;
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (100338DB) --------------------------------------------------------
int __thiscall sub_100338DB(int this)
{
  int v2; // ecx@2

  if ( *(_BYTE *)(this + 48) & 4 )
  {
    v2 = 0;
  }
  else
  {
    _EAX = this + 20;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
    v2 = _ECX + 1;
  }
  return v2;
}

//----- (100338F3) --------------------------------------------------------
int __thiscall sub_100338F3(int this)
{
  int v1; // edi@1
  void *v2; // esi@1
  int v10; // eax@3
  char v12; // [sp+8h] [bp-Ch]@9

  v2 = (void *)this;
  _EAX = this + 384;
  _EDI = 1;
  __asm { lock xadd [eax], edi }
  v1 = _EDI + 1;
  if ( v1 == 1 )
  {
    if ( *(_DWORD *)(this + 396) <= 0 )
    {
      *(_DWORD *)(this + 396) = 1;
    }
    else
    {
      v10 = (int)sub_10032365();
      if ( !v10 || *(_BYTE *)(v10 + 76) || (void *)sub_10032E0B(v10) != v2 )
      {
        sub_1002FF79((int)&v12);
        sub_100355DB((int)&v12, (int)&unk_1006C72C);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_1003395E);
      }
      sub_10033F78(v2);
    }
  }
  return v1;
}

//----- (1003395E) --------------------------------------------------------
int __thiscall sub_1003395E(void *this)
{
  _EAX = (int)((char *)this + 388);
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  return (*(int (**)(void))(*(_DWORD *)this + 16))();
}

//----- (10033970) --------------------------------------------------------
int __userpurge sub_10033970<eax>(int a1<ecx>, int a2<edi>, HANDLE hSourceHandle)
{
  int v3; // ebx@1
  int v4; // edx@3
  int v5; // ecx@3
  HANDLE v6; // ST08_4@3
  HANDLE v7; // ST04_4@3
  HANDLE v8; // eax@3
  int v9; // eax@4
  int v11; // eax@6
  int v12; // eax@7
  void *v13; // ecx@9
  int v14; // [sp-4h] [bp-1Ch]@7
  char v15; // [sp+4h] [bp-14h]@8
  int (__stdcall **v16)(char); // [sp+8h] [bp-10h]@7
  HANDLE TargetHandle; // [sp+14h] [bp-4h]@3

  v3 = a1;
  if ( hSourceHandle && hSourceHandle != (HANDLE)-1 )
  {
    TargetHandle = 0;
    v6 = GetCurrentProcess();
    v7 = hSourceHandle;
    v8 = GetCurrentProcess();
    if ( DuplicateHandle(v8, v7, v6, &TargetHandle, 0, 0, 2u) )
    {
      v11 = sub_1002ADB1(v4, v5, v3, a2, 12);
      *(_DWORD *)(v11 + 8) = TargetHandle;
      return sub_10031C2A(v3 + 184, v11);
    }
    v9 = GetLastError();
    if ( v9 > 0 )
      v9 = (unsigned __int16)v9 | 0x80070000;
    sub_10030079((int)&v15, v9);
    v14 = (int)&unk_1006C6F4;
    v12 = (int)&v15;
  }
  else
  {
    hSourceHandle = "eventObject";
    sub_1002AEA4((int)&v16, (int *)&hSourceHandle);
    v16 = &off_100602FC;
    v14 = (int)&unk_1006D8F4;
    v12 = (int)&v16;
  }
  sub_100355DB(v12, v14);
  __asm { int     3               ; Trap to Debugger }
  return sub_10033312(v13);
}
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);

//----- (10033A21) --------------------------------------------------------
int __thiscall sub_10033A21(int this)
{
  int v1; // esi@1

  _EDX = this + 384;
  _ESI = -1;
  __asm { lock xadd [edx], esi }
  v1 = _ESI - 1;
  if ( !v1 )
    sub_1003370C(this);
  return v1;
}

//----- (10033A3B) --------------------------------------------------------
USHORT __thiscall sub_10033A3B(int this, int a2)
{
  USHORT result; // ax@1
  int ebp0; // ebp@0
  union _SLIST_HEADER *v4; // edi@1
  int v5; // esi@1

  v5 = this;
  v4 = (union _SLIST_HEADER *)(this + 488);
  result = QueryDepthSList((PSLIST_HEADER)(this + 488));
  if ( (signed int)result >= *(_DWORD *)(v5 + 20) )
  {
    if ( a2 )
      result = (*(int (__stdcall **)(signed int))(*(_DWORD *)a2 + 20))(1);
  }
  else
  {
    sub_10047B55(a2, ebp0);
    result = (unsigned int)InterlockedPushEntrySList(v4, (PSINGLE_LIST_ENTRY)(a2 + 4));
  }
  return result;
}

//----- (10033A82) --------------------------------------------------------
int __thiscall sub_10033A82(void *this)
{
  _EAX = (int)((char *)this + 388);
  _EDX = -1;
  __asm { lock xadd [eax], edx }
  return (*(int (**)(void))(*(_DWORD *)this + 20))();
}

//----- (10033A94) --------------------------------------------------------
PSINGLE_LIST_ENTRY __thiscall sub_10033A94(int this, int a2, char a3)
{
  int v3; // esi@1

  v3 = this;
  if ( a3 )
    (*(void (__stdcall **)(int))(**(_DWORD **)(this + 420) + 12))(a2);
  _EAX = v3 + 400;
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  return InterlockedPushEntrySList((PSLIST_HEADER)(v3 + 480), (PSINGLE_LIST_ENTRY)(a2 + 8));
}

//----- (10033AD4) --------------------------------------------------------
int __thiscall sub_10033AD4(int this, int a2)
{
  int result; // eax@1
  union _SLIST_HEADER *v3; // edi@1
  int v4; // esi@1
  int v5; // edx@1

  v4 = this;
  v3 = (union _SLIST_HEADER *)(this + 496);
  v5 = QueryDepthSList((PSLIST_HEADER)(this + 496));
  result = 32 * *(_DWORD *)(v4 + 20);
  if ( v5 >= result )
  {
    if ( a2 )
      result = (**(int (__stdcall ***)(_DWORD))a2)(1);
  }
  else
  {
    result = (int)InterlockedPushEntrySList(v3, (PSINGLE_LIST_ENTRY)(a2 + 12));
  }
  return result;
}

//----- (10033B18) --------------------------------------------------------
PSINGLE_LIST_ENTRY __thiscall sub_10033B18(int this)
{
  PSINGLE_LIST_ENTRY result; // eax@1
  int v2; // edx@1
  union _SLIST_HEADER *v3; // ebx@1
  int v4; // edi@1
  int i; // esi@1
  PSINGLE_LIST_ENTRY v6; // eax@2
  PSINGLE_LIST_ENTRY v7; // esi@2

  v4 = this;
  v3 = (union _SLIST_HEADER *)(this + 504);
  result = InterlockedPopEntrySList((PSLIST_HEADER)(this + 504));
  v2 = (int)&result[-2];
  for ( i = result != 0 ? (int)&result[-2] : 0; i; i = v7 != 0 ? (int)result : 0 )
  {
    (*(void (__fastcall **)(_DWORD, _DWORD, _DWORD))(**(_DWORD **)(v4 + 420) + 12))(*(_DWORD *)(v4 + 420), v2, i);
    sub_10033A94(v4, i, 0);
    v6 = InterlockedPopEntrySList(v3);
    v7 = v6;
    result = v6 - 2;
  }
  return result;
}

//----- (10033B65) --------------------------------------------------------
BOOL __thiscall sub_10033B65(int this, LONG lReleaseCount)
{
  BOOL result; // eax@2

  if ( lReleaseCount > 0 )
    result = ReleaseSemaphore(*(HANDLE *)(this + 380), lReleaseCount, 0);
  return result;
}

//----- (10033B83) --------------------------------------------------------
int __thiscall sub_10033B83(void *this, int a2)
{
  int result; // eax@1

  *(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4) = *(_DWORD *)(a2 + 4);
  result = *(_DWORD *)this;
  if ( a2 == *(_DWORD *)this )
  {
    if ( result == *(_DWORD *)(result + 4) )
      result = 0;
    else
      result = *(_DWORD *)(result + 8);
    *(_DWORD *)this = result;
  }
  return result;
}

//----- (10033BB5) --------------------------------------------------------
char __thiscall sub_10033BB5(void *ListHead, int a2, signed int a3, char a4)
{
  signed int v4; // edx@1
  int v6; // esi@1
  char result; // al@2
  int v8; // eax@3
  int v9; // ecx@3
  int v10; // edx@4
  int v11; // edi@4
  int v12; // edx@5
  PSINGLE_LIST_ENTRY v18; // eax@14
  int v19; // ST08_4@14

  v6 = (int)ListHead;
  v4 = a3 >> *((_DWORD *)ListHead + 11);
  _EBX = a3 & (*((_DWORD *)ListHead + 10) - 1);
  if ( v4 < *((_DWORD *)ListHead + 15) )
  {
    v9 = *((_DWORD *)ListHead + 14);
    v8 = *(_DWORD *)(v6 + 52);
    if ( v4 < v9 )
    {
      v11 = *(_DWORD *)(v8 + 4 * v4);
    }
    else
    {
      v10 = v4 - v9;
      v11 = *(_DWORD *)(v8 + 4 * v9 - 4);
      if ( v10 >= 0 )
      {
        v12 = v10 + 1;
        do
        {
          v11 = *(_DWORD *)(v11 + 4);
          --v12;
        }
        while ( v12 );
      }
    }
    _ECX = *(_DWORD *)v11 + 4 * _EBX;
    _EDX = 0;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 == a2 )
    {
      _ECX = v11 + 8;
      __asm { lock cmpxchg [ecx], ebx }
      if ( a4 )
      {
        if ( (signed int)QueryDepthSList((PSLIST_HEADER)v6) <= *(_DWORD *)(v6 + 68) )
        {
          InterlockedPushEntrySList((PSLIST_HEADER)v6, (PSINGLE_LIST_ENTRY)(a2 + 4));
        }
        else
        {
          InterlockedPushEntrySList((PSLIST_HEADER)(v6 + 8), (PSINGLE_LIST_ENTRY)(a2 + 4));
          if ( (signed int)QueryDepthSList((PSLIST_HEADER)(v6 + 8)) > *(_DWORD *)(v6 + 68) )
          {
            if ( (*(_DWORD *)(*(_DWORD *)(v6 + 36) + 404) & 0xA0000000) != -1610612736 )
            {
              _EDX = 1;
              _ECX = v6 + 72;
              __asm { lock cmpxchg [ecx], edx }
              v18 = InterlockedFlushSList((PSLIST_HEADER)(v6 + 8));
              v19 = *(_DWORD *)(v6 + 36);
              *(_DWORD *)(v6 + 16) = v18;
              sub_1003337E(v6 + 20, sub_10031EF3, v6, v19);
            }
          }
        }
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10033CB3) --------------------------------------------------------
char __thiscall sub_10033CB3(void *ListHead, int a2, signed int a3, char a4)
{
  signed int v4; // edx@1
  int v6; // esi@1
  char result; // al@2
  int v8; // eax@3
  int v9; // ecx@3
  int v10; // edx@4
  int v11; // edi@4
  int v12; // edx@5
  PSINGLE_LIST_ENTRY v18; // eax@14
  int v19; // ST08_4@14

  v6 = (int)ListHead;
  v4 = a3 >> *((_DWORD *)ListHead + 11);
  _EBX = a3 & (*((_DWORD *)ListHead + 10) - 1);
  if ( v4 < *((_DWORD *)ListHead + 15) )
  {
    v9 = *((_DWORD *)ListHead + 14);
    v8 = *(_DWORD *)(v6 + 52);
    if ( v4 < v9 )
    {
      v11 = *(_DWORD *)(v8 + 4 * v4);
    }
    else
    {
      v10 = v4 - v9;
      v11 = *(_DWORD *)(v8 + 4 * v9 - 4);
      if ( v10 >= 0 )
      {
        v12 = v10 + 1;
        do
        {
          v11 = *(_DWORD *)(v11 + 4);
          --v12;
        }
        while ( v12 );
      }
    }
    _ECX = *(_DWORD *)v11 + 4 * _EBX;
    _EDX = 0;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 == a2 )
    {
      _ECX = v11 + 8;
      __asm { lock cmpxchg [ecx], ebx }
      if ( a4 )
      {
        if ( (signed int)QueryDepthSList((PSLIST_HEADER)v6) <= *(_DWORD *)(v6 + 68) )
        {
          InterlockedPushEntrySList((PSLIST_HEADER)v6, (PSINGLE_LIST_ENTRY)(a2 + 52));
        }
        else
        {
          InterlockedPushEntrySList((PSLIST_HEADER)(v6 + 8), (PSINGLE_LIST_ENTRY)(a2 + 52));
          if ( (signed int)QueryDepthSList((PSLIST_HEADER)(v6 + 8)) > *(_DWORD *)(v6 + 68) )
          {
            if ( (*(_DWORD *)(*(_DWORD *)(v6 + 36) + 404) & 0xA0000000) != -1610612736 )
            {
              _EDX = 1;
              _ECX = v6 + 72;
              __asm { lock cmpxchg [ecx], edx }
              v18 = InterlockedFlushSList((PSLIST_HEADER)(v6 + 8));
              v19 = *(_DWORD *)(v6 + 36);
              *(_DWORD *)(v6 + 16) = v18;
              sub_1003337E(v6 + 20, sub_10031EFF, v6, v19);
            }
          }
        }
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10033DB1) --------------------------------------------------------
int __thiscall sub_10033DB1(void *this)
{
  int result; // eax@1
  int v2; // esi@3

  result = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    v2 = *(_DWORD *)(result + 4);
    if ( result == v2 )
    {
      *(_DWORD *)this = 0;
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)(v2 + 4) + 8) = result;
      *(_DWORD *)(*(_DWORD *)this + 4) = *(_DWORD *)(v2 + 4);
    }
    result = v2;
  }
  return result;
}

//----- (10033DD9) --------------------------------------------------------
_DWORD *__thiscall sub_10033DD9(void *this)
{
  _DWORD *result; // eax@1
  _DWORD *v2; // esi@3

  result = *(_DWORD **)this;
  if ( *(_DWORD *)this )
  {
    v2 = (_DWORD *)*result;
    if ( result == (_DWORD *)*result )
    {
      *(_DWORD *)this = 0;
    }
    else
    {
      *(_DWORD *)(*v2 + 4) = result;
      **(_DWORD **)this = *v2;
    }
    result = v2;
  }
  return result;
}

//----- (10033DFD) --------------------------------------------------------
_DWORD *__thiscall sub_10033DFD(int this)
{
  void *v2; // edi@1
  void *v3; // esi@1
  _DWORD *v4; // edi@1

  v2 = (void *)this;
  v3 = (void *)(this + 4);
  sub_1002B98B((void *)(this + 4));
  v4 = sub_10033DD9(v2);
  sub_1002BB75(v3);
  return v4;
}

//----- (10033E20) --------------------------------------------------------
int __thiscall sub_10033E20(int this, int a2)
{
  int v2; // ebx@1
  void *v3; // edi@1

  v2 = this;
  v3 = (void *)(this + 308);
  sub_1002B98B((void *)(this + 308));
  if ( *(_DWORD *)(a2 + 12) == 2 )
    sub_10033B83((void *)(v2 + 304), a2);
  *(_DWORD *)(a2 + 12) = 0;
  return sub_1002BB75(v3);
}

//----- (10033E5C) --------------------------------------------------------
char __thiscall sub_10033E5C(int this, int a2)
{
  return sub_10033CB3((void *)(this + 96), a2, *(_DWORD *)(a2 + 24), 1);
}

//----- (10033E74) --------------------------------------------------------
char __thiscall sub_10033E74(int this)
{
  char result; // al@1
  int v2; // esi@1

  v2 = this;
  result = sub_10041512(this);
  *(_DWORD *)(v2 + 56) = 0;
  return result;
}

//----- (10033E82) --------------------------------------------------------
int __thiscall sub_10033E82(void *this, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // esi@2
  unsigned int v5; // edi@4
  int v6; // eax@5
  int v7; // ebx@5
  char v8; // al@5
  int v9; // eax@5
  int v10; // esi@6
  int v11; // eax@9
  char v12; // [sp+0h] [bp-14h]@8
  int (__stdcall **v13)(char); // [sp+4h] [bp-10h]@18
  int v14; // [sp+8h] [bp-Ch]@7
  BOOL (__cdecl *v15)(); // [sp+Ch] [bp-8h]@7
  int v16; // [sp+10h] [bp-4h]@1

  result = a2;
  v16 = (int)this;
  if ( !a2 )
  {
    a3 = (unsigned int)"ppVirtualProcessorRoots";
    goto LABEL_18;
  }
  v4 = a3;
  if ( a3 < 1 )
  {
    a3 = (unsigned int)"count";
LABEL_18:
    sub_1002AEA4((int)&v13, (int *)&a3);
    v13 = &off_100602FC;
    sub_100355DB((int)&v13, (int)&unk_1006D8F4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10033F78);
  }
  v5 = 0;
  if ( a3 )
  {
    do
    {
      v7 = *(_DWORD *)(result + 4 * v5);
      v8 = (*(int (__thiscall **)(int))(*(_DWORD *)v7 + 4))(v7);
      sub_10032C26(v16, v8);
      v9 = (**(int (__thiscall ***)(_DWORD))v7)(v7);
      v6 = sub_10045DB8(*(_DWORD *)(*(_DWORD *)(v16 + 32) + 4 * v9), v7);
      if ( !v6 )
      {
        v10 = v16;
        do
        {
          v14 = 0;
          v15 = sub_10034C15;
          while ( sub_100282E0((int)&v12) )
            ;
          SwitchToThread();
          v11 = (**(int (__thiscall ***)(_DWORD))v7)(v7);
          v6 = sub_10045DB8(*(_DWORD *)(*(_DWORD *)(v10 + 32) + 4 * v11), v7);
        }
        while ( !v6 );
        v4 = a3;
      }
      if ( *(_BYTE *)(v6 + 160) )
        v6 = sub_10046743(*(_DWORD *)(v6 + 164), v6);
      if ( v6 )
        sub_10045460(v6);
      result = a2;
      ++v5;
    }
    while ( v5 < v4 );
  }
  return result;
}
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);

//----- (10033F78) --------------------------------------------------------
int __thiscall sub_10033F78(void *this)
{
  int v1; // eax@1
  void *v3; // edi@1
  int result; // eax@3

  v3 = this;
  _EBX = (int)((char *)this + 404);
  v1 = sub_1003410B((int)((char *)this + 404), -2147483648);
  _EDX = v1 & 0x7FFFFFFF;
  __asm { lock cmpxchg [ebx], edx }
  while ( v1 != v1 )
  {
    _ECX = v1 & 0x7FFFFFFF;
    __asm { lock cmpxchg [ebx], ecx }
  }
  result = (int)((char *)v3 + 392);
  _ECX = 1;
  __asm { lock xadd [eax], ecx }
  return result;
}

//----- (10033FC5) --------------------------------------------------------
void *__cdecl sub_10033FC5(void *ListEntry)
{
  void *result; // eax@4

  if ( *((_BYTE *)ListEntry + 772) )
  {
    _ECX = &dword_10076704;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
  }
  if ( QueryDepthSList(&ListHead) >= 0x10u )
    result = sub_10031A12(ListEntry, 1);
  else
    result = InterlockedPushEntrySList(&ListHead, (PSINGLE_LIST_ENTRY)ListEntry);
  return result;
}
// 10076704: using guessed type int dword_10076704;

//----- (1003400C) --------------------------------------------------------
LPVOID __cdecl sub_1003400C()
{
  LPVOID result; // eax@2

  if ( dword_10073D14 & 0x80000000 )
    result = TlsGetValue(dwTlsIndex);
  else
    result = 0;
  return result;
}
// 10073D14: using guessed type int dword_10073D14;

//----- (10034028) --------------------------------------------------------
char __thiscall sub_10034028(void *this)
{
  int v2; // edx@2

  _ESI = (int)((char *)this + 384);
  while ( 1 )
  {
    v2 = *(_DWORD *)_ESI;
    if ( !*(_DWORD *)_ESI )
      break;
    _ECX = v2 + 1;
    __asm { lock cmpxchg [esi], ecx }
    if ( v2 == v2 )
      return 1;
  }
  return 0;
}

//----- (1003404A) --------------------------------------------------------
int __thiscall sub_1003404A(void *this)
{
  int v1; // eax@1
  void *v2; // edi@1
  int v3; // esi@1
  int v4; // ecx@3

  v2 = this;
  v1 = (int)sub_10032365();
  v3 = v1;
  if ( v1 && (void *)sub_10032E0B(v1) == v2 )
    v4 = sub_1002EA27(v3);
  else
    v4 = *((_DWORD *)v2 + 44);
  return (**(int (***)(void))v4)();
}

//----- (1003407F) --------------------------------------------------------
int __thiscall sub_1003407F(void *this, int a2, int a3, int a4)
{
  int v4; // eax@1
  void *v5; // edi@1
  int v6; // esi@1
  int v7; // eax@3

  v5 = this;
  v4 = (int)sub_10032365();
  v6 = v4;
  if ( v4 && (void *)sub_10032E0B(v4) == v5 )
    v7 = sub_1002EA27(v6);
  else
    v7 = *((_DWORD *)v5 + 44);
  return sub_100415BA((void *)v7, a2, a3, a4);
}

//----- (100340B5) --------------------------------------------------------
void __thiscall sub_100340B5(int this, int a2)
{
  if ( *(_DWORD *)(this + 12) == 1 )
    *(_DWORD *)(this + 376) = sub_10032B40(this, *(_DWORD *)(a2 + 184));
}

//----- (100340DA) --------------------------------------------------------
int __cdecl sub_100340DA(int a1, int a2)
{
  int result; // eax@1
  char v3; // [sp+8h] [bp-10h]@3
  int v4; // [sp+10h] [bp-8h]@2
  void (__cdecl *v5)(); // [sp+14h] [bp-4h]@2

  result = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 & a2 )
  {
    v4 = 0;
    v5 = sub_10034BD7;
    do
    {
      sub_100282E0((int)&v3);
      result = *(_DWORD *)a1;
    }
    while ( *(_DWORD *)a1 & a2 );
  }
  return result;
}

//----- (1003410B) --------------------------------------------------------
int __cdecl sub_1003410B(int a1, int a2)
{
  int v2; // edx@1
  char v4; // [sp+4h] [bp-10h]@3
  int v5; // [sp+Ch] [bp-8h]@2
  void (__cdecl *v6)(); // [sp+10h] [bp-4h]@2

  v2 = *(_DWORD *)a1;
  if ( (a2 & *(_DWORD *)a1) != a2 )
  {
    v5 = 0;
    v6 = sub_10034BD7;
    do
    {
      sub_100282E0((int)&v4);
      v2 = *(_DWORD *)a1;
    }
    while ( (a2 & *(_DWORD *)a1) != a2 );
  }
  return v2;
}

//----- (10034145) --------------------------------------------------------
char __thiscall sub_10034145(void *this, int a2, char a3, int a4, int a5, int a6)
{
  void *v7; // esi@1
  char v8; // [sp-14h] [bp-1Ch]@1
  int v9; // [sp-10h] [bp-18h]@1
  int v10; // [sp-Ch] [bp-14h]@1
  int v11; // [sp-8h] [bp-10h]@1
  int v12; // [sp-4h] [bp-Ch]@1

  v12 = 3;
  v7 = this;
  sub_1002F3E5((int)&v8, (int)&a3);
  return sub_1003416B(v7, a2, v8, v9, v10, v11, v12);
}

//----- (1003416B) --------------------------------------------------------
char __thiscall sub_1003416B(void *this, int a2, char a3, int a4, int a5, int a6, int a7)
{
  int v7; // ecx@1
  char v8; // bl@1
  int v9; // esi@1
  char v11; // [sp-14h] [bp-24h]@1
  int v12; // [sp-10h] [bp-20h]@1
  int v13; // [sp-Ch] [bp-1Ch]@1
  int v14; // [sp-8h] [bp-18h]@1
  int v15; // [sp-4h] [bp-14h]@1
  int v16; // [sp+8h] [bp-8h]@1
  int v17; // [sp+Ch] [bp-4h]@2

  v9 = (int)this;
  v8 = 0;
  sub_1002EFDD(this);
  v15 = a7;
  v16 = 0;
  sub_1002F3E5((int)&v11, (int)&a3);
  if ( sub_100325BA(v9, (int)&v16, *(int *)&v11, v12, v13, v14, v15) )
  {
    sub_10045165(v17, v16, a2, 0);
    v16 = 0;
    v8 = 1;
  }
  sub_1002EFDD(v7);
  return v8;
}
// 1002EFDD: using guessed type _DWORD __thiscall sub_1002EFDD(_DWORD ecx0);

//----- (100341BF) --------------------------------------------------------
void __cdecl sub_100341BF()
{
  JUMPOUT(dword_100766D8, 0, *(unsigned int *)sub_10030FD5);
}
// 100766D8: using guessed type int dword_100766D8;

//----- (10034222) --------------------------------------------------------
int __thiscall sub_10034222(void *this, int a2, int a3, int a4)
{
  int v4; // edi@1
  void *v5; // esi@1
  int v6; // ebx@2
  int v7; // eax@4
  signed int v8; // esi@4
  int v9; // eax@5
  int v10; // edx@6
  int v11; // eax@6
  int v12; // ecx@6
  int result; // eax@10
  signed int v14; // ebx@10
  int v15; // edx@10
  int v16; // ecx@10
  int v17; // eax@12
  int v18; // edi@12
  int v19; // eax@13
  int v20; // edx@13
  int v21; // ecx@13
  void *v22; // [sp+Ch] [bp-Ch]@1
  int v23; // [sp+10h] [bp-8h]@5
  int i; // [sp+14h] [bp-4h]@1

  v5 = this;
  v4 = 0;
  v22 = this;
  for ( i = 0; v4 < *((_DWORD *)v5 + 11); i = v4 )
  {
    v6 = *(_DWORD *)(*((_DWORD *)v5 + 8) + 4 * v4);
    if ( v6 )
    {
      if ( *(_DWORD *)(v6 + 120) > 0 )
      {
        v8 = 0;
        v7 = v6 + 56;
        do
        {
          v9 = sub_1004099B(v7, v8);
          v23 = v9;
          if ( v9 )
          {
            v10 = *(_DWORD *)(v9 + 92) - *(_DWORD *)(v9 + 100);
            *(_DWORD *)(v9 + 100) = *(_DWORD *)(v9 + 92);
            v11 = *(_DWORD *)(v9 + 96);
            v12 = v11 - *(_DWORD *)(v23 + 104);
            *(_DWORD *)(v23 + 104) = v11;
            *(_DWORD *)a3 += v10;
            *(_DWORD *)a2 += v12;
            *(_DWORD *)a4 += v10 - v12;
          }
          ++v8;
          v7 = v6 + 56;
        }
        while ( v8 < *(_DWORD *)(v6 + 120) );
        v5 = v22;
        v4 = i;
      }
    }
    ++v4;
  }
  v15 = *((_DWORD *)v5 + 109) - *((_DWORD *)v5 + 111);
  *((_DWORD *)v5 + 111) = *((_DWORD *)v5 + 109);
  v16 = *((_DWORD *)v5 + 110) - *((_DWORD *)v5 + 112);
  *((_DWORD *)v5 + 112) = *((_DWORD *)v5 + 110);
  v14 = 0;
  *(_DWORD *)a3 += v15;
  *(_DWORD *)a2 += v16;
  result = a4;
  *(_DWORD *)result += v15 - v16;
  if ( *((_DWORD *)v5 + 66) > 0 )
  {
    result = (int)((char *)v5 + 200);
    do
    {
      v17 = sub_1004099B(result, v14);
      v18 = v17;
      if ( v17 )
      {
        v19 = *(_DWORD *)(v17 + 12);
        v20 = *(_DWORD *)(v18 + 8) - *(_DWORD *)(v18 + 16);
        *(_DWORD *)(v18 + 16) = *(_DWORD *)(v18 + 8);
        v21 = v19 - *(_DWORD *)(v18 + 20);
        *(_DWORD *)(v18 + 20) = v19;
        *(_DWORD *)a3 += v20;
        *(_DWORD *)a2 += v21;
        *(_DWORD *)a4 += v20 - v21;
        if ( !sub_100333F5(v18) )
        {
          sub_10033BB5((char *)v5 + 200, v18, *(_DWORD *)v18, 0);
          sub_1002A4AA((LPVOID)v18);
        }
      }
      ++v14;
      result = (int)((char *)v5 + 200);
    }
    while ( v14 < *((_DWORD *)v5 + 66) );
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1003435B) --------------------------------------------------------
BOOL __thiscall sub_1003435B(void *this)
{
  LPVOID v1; // eax@1
  int v2; // esi@1
  int v3; // eax@4
  BOOL result; // eax@5
  int v5; // eax@9
  char v8; // [sp+Fh] [bp-1h]@1

  v2 = (int)this;
  v1 = sub_10032365();
  v8 = 1;
  if ( v1 )
  {
    if ( !*((_BYTE *)v1 + 76) )
    {
      v8 = 0;
      sub_1002E99E();
    }
  }
  v3 = (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 72))(v2);
  if ( v3 )
  {
    if ( v3 == 2 )
    {
      if ( !*(_DWORD *)(v2 + 408) )
        *(_DWORD *)(v2 + 408) = 1;
    }
    _EBX = v2 + 404;
    v5 = *(_DWORD *)(v2 + 404);
    do
    {
      _ECX = v5 & 0xBFFFFFFF;
      __asm { lock cmpxchg [ebx], ecx }
    }
    while ( v5 != v5 );
    result = sub_10033B65(v2, v5 & 0x1FFFFFFF);
  }
  else
  {
    result = sub_10033782(v2);
  }
  if ( !v8 )
    result = sub_1002E99E();
  return result;
}

//----- (100343E5) --------------------------------------------------------
char __thiscall sub_100343E5(int this)
{
  char result; // al@1
  int ebp0; // ebp@0
  int v4; // edi@1
  int i; // eax@2
  char v6; // dl@4
  char v7; // al@4
  char v8; // al@7
  int v9; // ecx@13
  int v16; // esi@16
  ULONG v17; // eax@18
  int v18; // esi@18
  DWORD v19; // eax@18
  char v20; // [sp-14h] [bp-38h]@16
  int v21; // [sp-10h] [bp-34h]@16
  int v22; // [sp-Ch] [bp-30h]@16
  int v23; // [sp-8h] [bp-2Ch]@16
  int v24; // [sp-4h] [bp-28h]@16
  int v25; // [sp+Ch] [bp-18h]@16
  int v26; // [sp+14h] [bp-10h]@16
  int v27; // [sp+18h] [bp-Ch]@16
  __int16 v28; // [sp+22h] [bp-2h]@2

  result = 0;
  v4 = this;
  _EBX = this + 472;
  if ( *(_DWORD *)(this + 472) > 0 )
  {
    v28 = 0;
    for ( i = sub_1003294B(ebp0, 0); ; i = sub_1003294B(ebp0, 0) )
    {
      if ( !i )
      {
        v6 = HIBYTE(v28);
        v8 = 1;
        LOBYTE(v28) = 1;
        goto LABEL_10;
      }
      v7 = sub_10033479(v4, i);
      v6 = v7 | HIBYTE(v28);
      HIBYTE(v28) |= v7;
      if ( *(_DWORD *)(v4 + 432) <= 0 )
        break;
      if ( sub_10034561(v4, 1) )
      {
        v6 = HIBYTE(v28);
        break;
      }
    }
    v8 = v28;
LABEL_10:
    if ( !*(_DWORD *)(v4 + 408) && (v8 || *(_DWORD *)(v4 + 432) > 0) )
      goto LABEL_24;
    v9 = *(_DWORD *)_EBX;
    _EAX = -*(_DWORD *)_EBX;
    __asm { lock xadd [ebx], eax }
    result = _EAX != v9;
    if ( result )
    {
LABEL_18:
      v18 = sub_10034561(v4, 1);
      v19 = GetTickCount();
      v17 = v19 - *(_DWORD *)(v4 + 456) < v18 ? v18 - (v19 - *(_DWORD *)(v4 + 456)) : 0;
      if ( (_BYTE)v28 )
      {
        if ( v17 < 0x1F4 )
          v17 = 500;
      }
      v24 = 2147483647;
      v23 = v17;
      v22 = *(_DWORD *)(v4 + 468);
      return ChangeTimerQueueTimer(0, (HANDLE)v22, v17, 0x7FFFFFFFu);
    }
    if ( *(_DWORD *)(v4 + 408) )
    {
      if ( !v6 )
      {
        v25 = 0;
        v26 = 0;
        v27 = 0;
        v16 = *(_DWORD *)(sub_10032B1F(v4) + 8);
        v24 = 11;
        sub_1002F3E5((int)&v20, (int)&v25);
        result = sub_1003416B((void *)v4, v16, v20, v21, v22, v23, v24);
        if ( !result )
        {
LABEL_24:
          *(_DWORD *)_EBX = 1;
          goto LABEL_18;
        }
      }
    }
  }
  return result;
}

//----- (1003450A) --------------------------------------------------------
char __stdcall sub_1003450A(int a1, int a2)
{
  return sub_100343E5(a1);
}

//----- (10034519) --------------------------------------------------------
char __stdcall sub_10034519(int a1, int a2)
{
  DWORD v2; // eax@1
  int v3; // esi@1
  char result; // al@2

  v3 = sub_10034561(a1, 1);
  v2 = GetTickCount() - *(_DWORD *)(a1 + 456);
  if ( v2 >= v3 )
    result = sub_100343E5(a1);
  else
    result = ChangeTimerQueueTimer(0, *(HANDLE *)(a1 + 468), v3 - v2, 0x7FFFFFFFu);
  return result;
}

//----- (10034561) --------------------------------------------------------
int __thiscall sub_10034561(int this, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // ecx@1
  int result; // eax@2
  unsigned int v5; // eax@3
  int v6; // eax@4

  v2 = *(_DWORD *)(this + 400);
  v3 = *(_DWORD *)(this + 452);
  if ( v2 >= v3 )
  {
    v5 = v2 - v3;
    if ( v5 >= 0x64 )
    {
      if ( v5 >= 0x12C )
      {
        if ( v5 >= 0x258 )
        {
          if ( v5 >= 0x5DC )
          {
            if ( v5 >= 0x9C4 )
            {
              if ( v5 >= 0xFA0 )
                v6 = (v5 >> 1) + 8200;
              else
                v6 = v5 / 3 + 2500;
            }
            else
            {
              v6 = v5 / 3 + 555;
            }
          }
          else
          {
            v6 = (v5 >> 2) + 180;
          }
        }
        else
        {
          v6 = v5 / 5 + 60;
        }
      }
      else
      {
        v6 = (v5 >> 3) + 15;
      }
    }
    else
    {
      v6 = v5 / 0xA + 5;
    }
    result = a2 * v6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100345F8) --------------------------------------------------------
int __cdecl sub_100345F8(char a1, char a2, int a3)
{
  int v3; // ebx@1
  int result; // eax@2
  __int16 v5; // [sp+4h] [bp-40h]@2
  char v6; // [sp+6h] [bp-3Eh]@2
  char v7; // [sp+8h] [bp-3Ch]@2
  char v8; // [sp+9h] [bp-3Bh]@2
  int v9; // [sp+1Ch] [bp-28h]@2
  int v10; // [sp+20h] [bp-24h]@2
  int v11; // [sp+24h] [bp-20h]@2
  int v12; // [sp+28h] [bp-1Ch]@2
  int v13; // [sp+30h] [bp-14h]@2
  int v14; // [sp+38h] [bp-Ch]@2

  v3 = dword_100766D8;
  if ( dword_100766D8 )
  {
    sub_10039210(&v6, 0, 62);
    v13 = 131072;
    v5 = 64;
    v7 = a1;
    v8 = a2;
    v9 = dword_100682E4[0];
    v10 = dword_100682E4[1];
    v11 = dword_100682E4[2];
    v12 = dword_100682E4[3];
    v14 = a3;
    result = sub_10030F35(v3, dword_100766D0, dword_100766D4, (int)&v5);
  }
  return result;
}
// 100766D0: using guessed type int dword_100766D0;
// 100766D4: using guessed type int dword_100766D4;
// 100766D8: using guessed type int dword_100766D8;

//----- (10034663) --------------------------------------------------------
int __stdcall sub_10034663(char a1, char a2, int a3)
{
  int result; // eax@2

  if ( a2 <= (unsigned __int8)byte_100766CC )
  {
    result = dword_100766C8;
    if ( dword_100766C8 & 1 )
      result = sub_100345F8(a1, a2, a3);
  }
  return result;
}
// 100766C8: using guessed type int dword_100766C8;
// 100766CC: using guessed type char byte_100766CC;

//----- (1003468D) --------------------------------------------------------
int __thiscall sub_1003468D(int this, int a2)
{
  void *v2; // edi@1
  int v3; // esi@1

  v3 = this;
  v2 = (void *)(this + 324);
  sub_10034BBC((void *)(this + 324));
  if ( *(_DWORD *)a2 != *(_DWORD *)(v3 + 336) )
    sub_1003380A((void *)v3);
  return sub_10034BCC(v2);
}

//----- (100346C2) --------------------------------------------------------
signed int __thiscall sub_100346C2(int this)
{
  int v1; // esi@1
  signed int result; // eax@4

  v1 = this;
  if ( sub_100326B7(this) || sub_100326E1((void *)v1) )
  {
    result = 1;
  }
  else
  {
    if ( *(_DWORD *)(v1 + 472) <= 0 )
      result = 0;
    else
      result = 2;
  }
  return result;
}

//----- (100346F0) --------------------------------------------------------
int __thiscall sub_100346F0(int this, int a2)
{
  int v2; // esi@1
  int result; // eax@5

  v2 = this;
  if ( a2 == -1 )
  {
    *(_DWORD *)(this + 340) = 0;
    *(_DWORD *)(this + 344) = sub_100320F3(this);
  }
  else
  {
    *(_DWORD *)(this + 340) = a2;
  }
  if ( *(_DWORD *)(v2 + 340) == *(_DWORD *)(v2 + 344) )
    result = 0;
  else
    result = *(_DWORD *)(v2 + 344);
  return result;
}

//----- (10034738) --------------------------------------------------------
signed int __thiscall sub_10034738(int this)
{
  signed int v1; // ecx@1
  int v2; // esi@1
  signed int result; // eax@2

  v2 = this;
  v1 = sub_100320F3(this);
  if ( (unsigned int)v1 > *(_DWORD *)(v2 + 344) )
  {
    if ( *(_DWORD *)(v2 + 344) == *(_DWORD *)(v2 + 340) )
      result = v1;
    else
      result = 0;
    *(_DWORD *)(v2 + 344) = v1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003476A) --------------------------------------------------------
char __thiscall sub_1003476A(int this, int a2)
{
  void *v2; // esi@1
  int v3; // eax@2
  int v5; // edx@3
  char result; // al@8
  int v15; // edi@9

  v2 = (void *)this;
  if ( (_BYTE)a2 )
  {
    _EDI = this + 404;
    v3 = *(_DWORD *)(this + 404);
    while ( 1 )
    {
      v5 = v3;
      if ( v3 & 0x40000000 )
        v5 = sub_100340DA((int)((char *)v2 + 404), 1073741824);
      if ( v5 & 0x20000000 )
        break;
      _ECX = v5 + 1;
      v3 = v5;
      __asm { lock cmpxchg [edi], ecx }
      if ( v5 == v5 )
      {
        _EAX = (int)((char *)v2 + 424);
        _ECX = 1;
        __asm { lock xadd [eax], ecx }
        (*(void (__thiscall **)(void *, int, int))(*(_DWORD *)v2 + 68))(v2, a2, _ECX + 1);
        goto LABEL_12;
      }
    }
    result = 0;
  }
  else
  {
    _EDI = -1;
    _EAX = this + 424;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    (*(void (__thiscall **)(void *, _DWORD, int))(*(_DWORD *)v2 + 68))(v2, 0, _ECX - 1);
    _EAX = (int)((char *)v2 + 404);
    __asm { lock xadd [eax], edi }
    v15 = _EDI - 1;
    if ( !(v15 & 0x1FFFFFFF) )
    {
      if ( v15 < 0 )
        sub_10031E48(v2);
    }
LABEL_12:
    result = 1;
  }
  return result;
}

//----- (1003480B) --------------------------------------------------------
int __thiscall sub_1003480B(void *this, char a2)
{
  void *v3; // esi@1
  int v4; // ecx@2

  v3 = this;
  sub_1002EFDD(this);
  _EAX = (int)((char *)v3 + 404);
  if ( a2 )
  {
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    v4 = _ECX - 1;
    if ( !(v4 & 0x1FFFFFFF) )
    {
      if ( v4 < 0 )
        sub_10031E48(v3);
    }
  }
  else
  {
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
    v4 = _ECX + 1;
    if ( v4 & 0x40000000 )
      WaitForSingleObject(*((HANDLE *)v3 + 95), 0xFFFFFFFFu);
  }
  return sub_1002EFDD(v4);
}
// 1002EFDD: using guessed type _DWORD __thiscall sub_1002EFDD(_DWORD ecx0);

//----- (10034867) --------------------------------------------------------
void __thiscall sub_10034867(int this)
{
  int v1; // edi@1
  int v2; // ebx@2
  void *v3; // eax@3
  void *v4; // esi@4
  int v5; // eax@6

  v1 = this;
  if ( *(_DWORD *)(this + 4) > 0 )
  {
    v2 = 0;
    if ( *(_DWORD *)this > 0 )
    {
      do
      {
        v3 = *(void **)(*(_DWORD *)(v1 + 8) + 4 * v2);
        if ( v3 )
        {
          do
          {
            v4 = *(void **)v3;
            sub_1002A4AA(v3);
            v3 = v4;
          }
          while ( v4 );
        }
        ++v2;
      }
      while ( v2 < *(_DWORD *)v1 );
    }
    v5 = *(_DWORD *)v1;
    *(_DWORD *)(v1 + 4) = 0;
    sub_10039210(*(void **)(v1 + 8), 0, 4 * v5);
  }
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100348B1) --------------------------------------------------------
int __thiscall sub_100348B1(void *this)
{
  return (*(int (**)(void))(**(_DWORD **)this + 16))();
}

//----- (100348B8) --------------------------------------------------------
int __thiscall sub_100348B8(void *this)
{
  return (*(int (**)(void))(**(_DWORD **)this + 20))();
}

//----- (100348BF) --------------------------------------------------------
void __cdecl sub_100348BF()
{
  JUMPOUT((unsigned int)hLibModule, 0, *(unsigned int *)sub_10031F0B);
}

//----- (100348CD) --------------------------------------------------------
void *__thiscall sub_100348CD(void *this, int a2)
{
  _ESI = a2;
  _EDX = 1;
  *(_DWORD *)this = a2;
  __asm { lock cmpxchg [esi], edx }
  return this;
}

//----- (10034913) --------------------------------------------------------
_DWORD *__thiscall sub_10034913(void *this)
{
  _DWORD *result; // eax@1

  result = *(_DWORD **)this;
  **(_DWORD **)this = 0;
  return result;
}

//----- (1003491A) --------------------------------------------------------
int __cdecl sub_1003491A(int a1)
{
  return a1 ^ dword_10077078;
}
// 10077078: using guessed type int dword_10077078;

//----- (10034927) --------------------------------------------------------
BOOL __cdecl sub_10034927(int a1)
{
  BOOL result; // eax@1

  sub_10039837(a1, 0, 0, 0);
  sub_1003989F(a1, 1);
  sub_10039413(a1);
  sub_10031F0B();
  result = (BOOL)hLibModule;
  if ( hLibModule )
    result = FreeLibrary(hLibModule);
  return result;
}

//----- (10034963) --------------------------------------------------------
HMODULE __cdecl sub_10034963(DWORD dwExitCode)
{
  HMODULE result; // eax@1

  _ECX = &unk_10076720;
  _EAX = -1;
  __asm { lock xadd [ecx], eax }
  if ( _ZF )
  {
    sub_10031F0B();
    result = hLibModule;
    if ( hLibModule )
      FreeLibraryAndExitThread(hLibModule, dwExitCode);
  }
  return result;
}

//----- (1003498E) --------------------------------------------------------
unsigned int __cdecl sub_1003498E()
{
  unsigned int v0; // esi@1
  HANDLE v1; // eax@1
  struct _FILETIME CreationTime; // [sp+4h] [bp-10h]@1
  struct _FILETIME ExitTime; // [sp+Ch] [bp-8h]@1

  dword_10077058 = 1;
  v0 = __security_cookie ^ (unsigned int)EncodePointer(&dword_10077078);
  v1 = GetCurrentThread();
  if ( GetThreadTimes(v1, &CreationTime, &ExitTime, &ExitTime, &ExitTime) )
    v0 ^= CreationTime.dwLowDateTime ^ CreationTime.dwHighDateTime;
  return v0;
}
// 10074200: using guessed type int __security_cookie;
// 10077058: using guessed type int dword_10077058;
// 10077078: using guessed type int dword_10077078;

//----- (100349DA) --------------------------------------------------------
HANDLE __cdecl sub_100349DA(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
{
  HANDLE v6; // edi@1

  v6 = CreateThread(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
  if ( v6 )
  {
    _ESI = 1;
    _EAX = &unk_10076720;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
    if ( _ECX == 0 )
    {
      sub_10034A25();
      _EAX = &dword_10073D14;
      __asm { lock xadd [eax], esi }
    }
  }
  return v6;
}
// 10073D14: using guessed type int dword_10073D14;

//----- (10034A25) --------------------------------------------------------
HMODULE __cdecl sub_10034A25()
{
  HMODULE result; // eax@1
  DWORD v1; // eax@2
  int v2; // eax@6
  char v3; // [sp+4h] [bp-21Ch]@8
  WCHAR LibFileName; // [sp+14h] [bp-20Ch]@2
  unsigned int v5; // [sp+21Ch] [bp-4h]@1
  int v6; // [sp+220h] [bp+0h]@1

  v5 = (unsigned int)&v6 ^ __security_cookie;
  result = GetModuleHandleA(0);
  if ( result != (HMODULE)268435456 )
  {
    v1 = GetModuleFileNameW((HMODULE)0x10000000, &LibFileName, 0x104u);
    if ( !v1 || v1 == 260 )
    {
      v2 = GetLastError();
      if ( v2 > 0 )
        v2 = (unsigned __int16)v2 | 0x80070000;
      sub_10030079((int)&v3, v2);
      sub_100355DB((int)&v3, (int)&unk_1006C6F4);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_10034AB9);
    }
    result = LoadLibraryExW(&LibFileName, 0, 0);
    hLibModule = result;
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;

//----- (10034AB9) --------------------------------------------------------
int __cdecl sub_10034AB9(unsigned int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  __int64 v12; // [sp+8h] [bp-8h]@2

  result = sub_1003946A(a2, a3, 0);
  v4 = result;
  if ( result )
  {
    sub_10034A25();
    _ECX = &dword_10073D14;
    _EAX = 1;
    __asm { lock xadd [ecx], eax }
    v12 = sub_10039A40(a1, -10000i64);
    sub_10039837(v4, (int)&v12, 0, 0);
    result = v4;
  }
  return result;
}
// 10073D14: using guessed type int dword_10073D14;

//----- (10034B13) --------------------------------------------------------
int __cdecl sub_10034B13(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_1003948B(a2, a3, 0);
  v4 = result;
  if ( result )
  {
    sub_10034A25();
    _ECX = &dword_10073D14;
    _EAX = 1;
    __asm { lock xadd [ecx], eax }
    sub_10039857(v4, a1, 0);
    result = v4;
  }
  return result;
}
// 10073D14: using guessed type int dword_10073D14;

//----- (10034B51) --------------------------------------------------------
int __cdecl sub_10034B51(int a1, int a2)
{
  int result; // eax@1

  sub_10039837(a2, 0, 0, 0);
  sub_10039413(a2);
  sub_10031F0B();
  result = (int)hLibModule;
  if ( hLibModule )
    result = sub_1003953A(a1, (int)hLibModule);
  return result;
}

//----- (10034B87) --------------------------------------------------------
int __cdecl sub_10034B87(int a1, int a2)
{
  int result; // eax@1

  sub_10039857(a2, 0, 0);
  sub_1003942A(a2);
  sub_10031F0B();
  result = (int)hLibModule;
  if ( hLibModule )
    result = sub_1003953A(a1, (int)hLibModule);
  return result;
}

//----- (10034BBC) --------------------------------------------------------
int __thiscall sub_10034BBC(void *this)
{
  void *v2; // esi@1

  v2 = this;
  sub_1002EFDD(this);
  return sub_10030F90(v2);
}
// 1002EFDD: using guessed type _DWORD __thiscall sub_1002EFDD(_DWORD ecx0);

//----- (10034BCC) --------------------------------------------------------
int __thiscall sub_10034BCC(void *this)
{
  *(_DWORD *)this = 0;
  return sub_1002EFDD(this);
}
// 1002EFDD: using guessed type _DWORD __thiscall sub_1002EFDD(_DWORD ecx0);

//----- (10034BD7) --------------------------------------------------------
void __cdecl sub_10034BD7()
{
  Sleep(0);
}

//----- (10034BE0) --------------------------------------------------------
char __thiscall sub_10034BE0(void *this)
{
  int v1; // ecx@1
  char v2; // bl@1
  void *v3; // esi@1

  v3 = this;
  sub_1002EFDD(this);
  v2 = sub_10034C00(v3);
  if ( !v2 )
    sub_1002EFDD(v1);
  return v2;
}
// 1002EFDD: using guessed type _DWORD __thiscall sub_1002EFDD(_DWORD ecx0);

//----- (10034C00) --------------------------------------------------------
char __thiscall sub_10034C00(void *this)
{
  char v1; // dl@2
  int v2; // eax@2

  if ( *(_DWORD *)this || (v1 = 1, v2 = *(_DWORD *)this, *(_DWORD *)this = 1, v2) )
    v1 = 0;
  return v1;
}

//----- (10034C15) --------------------------------------------------------
BOOL __cdecl sub_10034C15()
{
  LPVOID v0; // eax@1
  BOOL result; // eax@2

  v0 = sub_1003400C();
  if ( v0 )
    result = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v0 + 32))(v0);
  else
    result = SwitchToThread();
  return result;
}

//----- (10034C2B) --------------------------------------------------------
void __usercall sub_10034C2B(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, int a7)
{
  int v7; // edx@6
  int v8; // ecx@6
  int v9; // eax@6
  int v10; // ecx@8
  int v11; // eax@9
  void *v12; // eax@25
  int v13; // esi@25
  int v14; // edx@26
  int v15; // [sp-4h] [bp-2Ch]@24
  int v16; // [sp-4h] [bp-2Ch]@26

  if ( a6 == 1 )
  {
    if ( sub_10044A7C() )
    {
      if ( sub_10041B96(a3) )
      {
        sub_10048A61();
        dword_10078B54 = (int)GetCommandLineA();
        dword_10076734 = (LPVOID)sub_100489D6(a3);
        sub_1004832E(v7, v8, a3, a4);
        if ( v9 >= 0 )
        {
          if ( sub_1004862E(a3) >= 0 )
          {
            v11 = sub_1004885B(v10, a3);
            if ( v11 >= 0 )
            {
              if ( !sub_1003AFBE(v11, a3, a4, 0) )
              {
                ++dword_10076730;
                return;
              }
            }
          }
          sub_100485DC(a3);
        }
        sub_10041C0C();
      }
      sub_10044A91();
    }
  }
  else
  {
    if ( a6 )
    {
      if ( a6 == 2 )
      {
        if ( !sub_100394E9(dword_100744B0) )
        {
          v12 = sub_10037506(v15, a3, 1u, 0x3BCu);
          v13 = (int)v12;
          if ( v12 )
          {
            if ( sub_10039508(dword_100744B0, v12) )
            {
              sub_10041AE3(v14, v16, a3, v13);
              *(_DWORD *)v13 = GetCurrentThreadId();
              *(_DWORD *)(v13 + 4) = -1;
            }
            else
            {
              sub_100309A2(a3, (LPVOID)v13);
            }
          }
        }
      }
      else
      {
        if ( a6 == 3 )
          sub_10041A26(a3, a4, 0);
      }
    }
    else
    {
      if ( dword_10076730 > 0 )
      {
        --dword_10076730;
        if ( !dword_10076970 )
          sub_1003AFAE(a1, a2, a3, a4);
        sub_1003AE82(a3);
        if ( !a7 )
        {
          sub_100485DC(a3);
          sub_10041C0C();
          sub_10044A91();
        }
        if ( !a7 )
        {
          if ( dword_100744B0 != -1 )
            sub_10041C0C();
        }
      }
    }
  }
}
// 100744B0: using guessed type int dword_100744B0;
// 10076730: using guessed type int dword_10076730;
// 10076970: using guessed type int dword_10076970;
// 10078B54: using guessed type int dword_10078B54;

//----- (10034D9D) --------------------------------------------------------
BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
  int v4; // edx@3
  int v5; // ebx@3
  int v6; // edi@3

  if ( fdwReason == 1 )
    sub_1004893C();
  return sub_10034DC0(v4, v5, v6, (int)hinstDLL, fdwReason, (int)lpReserved);
}

//----- (10034DC0) --------------------------------------------------------
int __usercall sub_10034DC0<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4, int a5, int a6)
{
  int v6; // eax@1
  int v7; // ecx@5
  int v8; // eax@8
  signed int v9; // eax@9
  int v10; // edx@9
  int v11; // ecx@9
  int v12; // edi@9
  int v13; // eax@15
  int result; // eax@18

  v6 = 1;
  if ( !a5 && !dword_10076730 )
    goto LABEL_22;
  if ( a5 != 1 && a5 != 2 )
    goto LABEL_23;
  v7 = (int)dword_10061FB0;
  if ( dword_10061FB0 )
    v6 = dword_10061FB0(a4, a5, a6);
  if ( v6 && (sub_10034C2B(a1, v7, a2, a3, a4, a5, a6), v8) )
  {
LABEL_23:
    v9 = sub_1000C8F0(a4, a5, a6);
    v12 = v9;
    if ( a5 == 1 )
    {
      if ( !v9 )
      {
        sub_1000C8F0(a4, 0, a6);
        sub_10034C2B(v10, v11, a6, v12, a4, v12, a6);
        if ( dword_10061FB0 )
          dword_10061FB0(a4, v12, a6);
      }
    }
    if ( !a5 || a5 == 3 )
    {
      sub_10034C2B(v10, v11, a6, v12, a4, a5, a6);
      v12 = v13 != 0 ? v12 : 0;
      if ( v12 )
      {
        if ( dword_10061FB0 )
          v12 = dword_10061FB0(a4, a5, a6);
      }
    }
    result = v12;
  }
  else
  {
LABEL_22:
    result = 0;
  }
  return result;
}
// 10061FB0: using guessed type int (__stdcall *dword_10061FB0)(_DWORD, _DWORD, _DWORD);
// 10076730: using guessed type int dword_10076730;

//----- (10034ECE) --------------------------------------------------------
int __usercall sub_10034ECE<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, int a7, int a8, int a9)
{
  if ( a6 == 1 )
    sub_10034C2B(a1, a2, a3, a4, a5, 0, a7);
  return sub_10048310(a3, a8, a9);
}

//----- (10034F00) --------------------------------------------------------
void *__cdecl sub_10034F00(void *a1, const void *a2, unsigned int a3)
{
  int v38; // eax@29
  int v43; // edx@34
  unsigned int v44; // ecx@34
  void *result; // eax@48
  int v46; // edi@52
  int v47; // esi@52
  int v48; // edx@53
  unsigned int v49; // ecx@53
  int v50; // eax@64
  unsigned int k; // edx@65
  unsigned int v52; // edx@65
  int v53; // ecx@65
  unsigned int l; // edx@68
  int v55; // ecx@70
  char v56; // al@71
  unsigned int m; // ecx@71
  int n; // ecx@73
  unsigned int v59; // eax@76
  int i; // ecx@76
  unsigned int j; // eax@78
  int v62; // [sp-8h] [bp-10h]@76

  _ESI = (int)a2;
  _ECX = a3;
  _EDI = (int)a1;
  if ( a1 > a2 && a1 < (char *)a2 + a3 )
  {
    v47 = (int)(a2 + a3 - 4);
    v46 = (int)(a1 + a3 - 4);
    if ( v46 & 3 )
    {
      if ( a3 >= 4 )
        JUMPOUT(__CS__, *((_DWORD *)loc_100352D4 + (v46 & 3) + 1));
      switch ( a3 )
      {
        case 0u:
LABEL_60:
          result = a1;
          break;
        case 1u:
LABEL_61:
          *(_BYTE *)(v46 + 3) = *(_BYTE *)(v47 + 3);
          result = a1;
          break;
        case 2u:
LABEL_62:
          *(_BYTE *)(v46 + 3) = *(_BYTE *)(v47 + 3);
          *(_BYTE *)(v46 + 2) = *(_BYTE *)(v47 + 2);
          result = a1;
          break;
        case 3u:
          goto LABEL_63;
      }
    }
    else
    {
      v49 = a3 >> 2;
      v48 = a3 & 3;
      if ( a3 >> 2 < 8 )
      {
        switch ( -v49 )
        {
          case 0:
            switch ( v48 )
            {
              case 0:
                goto LABEL_60;
              case 1:
                goto LABEL_61;
              case 2:
                goto LABEL_62;
              case 3:
                goto LABEL_63;
            }
        }
      }
      else
      {
        memcpy((void *)v46, (const void *)v47, 4 * v49);
        v47 += 4 * v49;
        v46 += 4 * v49;
        switch ( v48 )
        {
          case 0:
            goto LABEL_60;
          case 1:
            goto LABEL_61;
          case 2:
            goto LABEL_62;
          case 3:
            break;
        }
      }
LABEL_63:
      *(_BYTE *)(v46 + 3) = *(_BYTE *)(v47 + 3);
      *(_BYTE *)(v46 + 2) = *(_BYTE *)(v47 + 2);
      *(_BYTE *)(v46 + 1) = *(_BYTE *)(v47 + 1);
      result = a1;
    }
  }
  else
  {
    __asm { bt      dword_100768A0, 1 }
    if ( _CF )
    {
      memcpy(a1, a2, a3);
      return a1;
    }
    if ( a3 < 0x80 )
      goto LABEL_33;
    if ( ((unsigned int)a2 ^ (unsigned int)a1) & 0xF )
      goto LABEL_83;
    __asm { bt      dword_10074238, 1 }
    if ( !_CF )
    {
LABEL_83:
      __asm { bt      dword_100768A0, 0 }
      if ( _CF )
      {
        if ( !((_BYTE)a1 & 3) )
        {
          if ( !((_BYTE)a2 & 3) )
          {
            __asm { bt      edi, 2 }
            if ( _CF )
            {
              _ECX = a3 - 4;
              _ESI = (int)((char *)a2 + 4);
              *(_DWORD *)a1 = *(_DWORD *)a2;
              _EDI = (int)((char *)a1 + 4);
            }
            __asm { bt      edi, 3 }
            if ( _CF )
            {
              __asm { movq    xmm1, qword ptr [esi] }
              _ECX -= 8;
              _ESI += 8;
              __asm { movq    qword ptr [edi], xmm1 }
              _EDI += 8;
            }
            if ( _ESI & 7 )
            {
              __asm { bt      esi, 3 }
              if ( _CF )
              {
                __asm { movdqa  xmm1, xmmword ptr [esi-0Ch] }
                _ESI = _ESI - 12;
                do
                {
                  __asm { movdqa  xmm3, xmmword ptr [esi+10h] }
                  _ECX -= 48;
                  __asm
                  {
                    movdqa  xmm0, xmmword ptr [esi+20h]
                    movdqa  xmm5, xmmword ptr [esi+30h]
                  }
                  _ESI += 48;
                  __asm
                  {
                    movdqa  xmm2, xmm3
                    palignr xmm3, xmm1, 0Ch
                    movdqa  xmmword ptr [edi], xmm3
                    movdqa  xmm4, xmm0
                    palignr xmm0, xmm2, 0Ch
                    movdqa  xmmword ptr [edi+10h], xmm0
                    movdqa  xmm1, xmm5
                    palignr xmm5, xmm4, 0Ch
                    movdqa  xmmword ptr [edi+20h], xmm5
                  }
                  _EDI += 48;
                }
                while ( _ECX >= 48 );
                _ESI = _ESI + 12;
              }
              else
              {
                __asm { movdqa  xmm1, xmmword ptr [esi-4] }
                _ESI = _ESI - 4;
                do
                {
                  __asm { movdqa  xmm3, xmmword ptr [esi+10h] }
                  _ECX -= 48;
                  __asm
                  {
                    movdqa  xmm0, xmmword ptr [esi+20h]
                    movdqa  xmm5, xmmword ptr [esi+30h]
                  }
                  _ESI += 48;
                  __asm
                  {
                    movdqa  xmm2, xmm3
                    palignr xmm3, xmm1, 4
                    movdqa  xmmword ptr [edi], xmm3
                    movdqa  xmm4, xmm0
                    palignr xmm0, xmm2, 4
                    movdqa  xmmword ptr [edi+10h], xmm0
                    movdqa  xmm1, xmm5
                    palignr xmm5, xmm4, 4
                    movdqa  xmmword ptr [edi+20h], xmm5
                  }
                  _EDI += 48;
                }
                while ( _ECX >= 48 );
                _ESI = _ESI + 4;
              }
            }
            else
            {
              __asm { movdqa  xmm1, xmmword ptr [esi-8] }
              _ESI = _ESI - 8;
              do
              {
                __asm { movdqa  xmm3, xmmword ptr [esi+10h] }
                _ECX -= 48;
                __asm
                {
                  movdqa  xmm0, xmmword ptr [esi+20h]
                  movdqa  xmm5, xmmword ptr [esi+30h]
                }
                _ESI += 48;
                __asm
                {
                  movdqa  xmm2, xmm3
                  palignr xmm3, xmm1, 8
                  movdqa  xmmword ptr [edi], xmm3
                  movdqa  xmm4, xmm0
                  palignr xmm0, xmm2, 8
                  movdqa  xmmword ptr [edi+10h], xmm0
                  movdqa  xmm1, xmm5
                  palignr xmm5, xmm4, 8
                  movdqa  xmmword ptr [edi+20h], xmm5
                }
                _EDI += 48;
              }
              while ( _ECX >= 48 );
              _ESI = _ESI + 8;
            }
            while ( _ECX >= 16 )
            {
              __asm { movdqu  xmm1, xmmword ptr [esi] }
              _ECX -= 16;
              _ESI += 16;
              __asm { movdqa  xmmword ptr [edi], xmm1 }
              _EDI += 16;
            }
            __asm { bt      ecx, 2 }
            if ( _CF )
            {
              v38 = *(_DWORD *)_ESI;
              _ECX -= 4;
              _ESI += 4;
              *(_DWORD *)_EDI = v38;
              _EDI += 4;
            }
            __asm { bt      ecx, 3 }
            if ( _CF )
            {
              __asm { movq    xmm1, qword ptr [esi] }
              _ECX -= 8;
              __asm { movq    qword ptr [edi], xmm1 }
            }
            JUMPOUT(__CS__, *((_DWORD *)off_10035238 + _ECX));
          }
          goto LABEL_34;
        }
        goto LABEL_36;
      }
LABEL_33:
      if ( !((_BYTE)a1 & 3) )
      {
LABEL_34:
        v44 = a3 >> 2;
        v43 = a3 & 3;
        if ( a3 >> 2 < 8 )
        {
          switch ( v44 )
          {
            case 0u:
              goto LABEL_47;
            case 1u:
              goto LABEL_46;
            case 2u:
              goto LABEL_45;
            case 3u:
              goto LABEL_44;
            case 4u:
              goto LABEL_43;
            case 5u:
              goto LABEL_42;
            case 6u:
              break;
            case 7u:
              *((_DWORD *)a1 + v44 - 7) = *((_DWORD *)a2 + v44 - 7);
              break;
          }
          *((_DWORD *)a1 + v44 - 6) = *((_DWORD *)a2 + v44 - 6);
LABEL_42:
          *((_DWORD *)a1 + v44 - 5) = *((_DWORD *)a2 + v44 - 5);
LABEL_43:
          *((_DWORD *)a1 + v44 - 4) = *((_DWORD *)a2 + v44 - 4);
LABEL_44:
          *((_DWORD *)a1 + v44 - 3) = *((_DWORD *)a2 + v44 - 3);
LABEL_45:
          *((_DWORD *)a1 + v44 - 2) = *((_DWORD *)a2 + v44 - 2);
LABEL_46:
          *((_DWORD *)a1 + v44 - 1) = *((_DWORD *)a2 + v44 - 1);
          _ESI = (int)((char *)a2 + 4 * v44);
          _EDI = (int)((char *)a1 + 4 * v44);
LABEL_47:
          switch ( v43 )
          {
            case 0:
              return a1;
            case 1:
LABEL_49:
              *(_BYTE *)_EDI = *(_BYTE *)_ESI;
              return a1;
            case 2:
LABEL_50:
              *(_BYTE *)_EDI = *(_BYTE *)_ESI;
              *(_BYTE *)(_EDI + 1) = *(_BYTE *)(_ESI + 1);
              return a1;
            case 3:
              break;
          }
        }
        else
        {
          memcpy(a1, a2, 4 * v44);
          _ESI = (int)((char *)a2 + 4 * v44);
          _EDI = (int)((char *)a1 + 4 * v44);
          switch ( v43 )
          {
            case 0:
              return a1;
            case 1:
              goto LABEL_49;
            case 2:
              goto LABEL_50;
            case 3:
              break;
          }
        }
        *(_BYTE *)_EDI = *(_BYTE *)_ESI;
        *(_BYTE *)(_EDI + 1) = *(_BYTE *)(_ESI + 1);
        *(_BYTE *)(_EDI + 2) = *(_BYTE *)(_ESI + 2);
        return a1;
      }
LABEL_36:
      if ( a3 >= 4 )
        JUMPOUT(__CS__, *((_DWORD *)loc_10035148 + ((_BYTE)a1 & 3) + 1));
      JUMPOUT(__CS__, *((_DWORD *)loc_10035248 + a3 - 4));
    }
    v50 = (_BYTE)a2 & 0xF;
    if ( (_BYTE)a2 & 0xF )
    {
      v62 = a3 - (16 - v50);
      v59 = 16 - v50;
      for ( i = v59 & 3; i; --i )
        *(_BYTE *)_EDI++ = *(_BYTE *)_ESI++;
      for ( j = v59 >> 2; j; --j )
      {
        *(_DWORD *)_EDI = *(_DWORD *)_ESI;
        _ESI += 4;
        _EDI += 4;
      }
      _ECX = v62;
    }
    v52 = _ECX;
    v53 = _ECX & 0x7F;
    for ( k = v52 >> 7; k; --k )
    {
      __asm
      {
        movdqa  xmm0, xmmword ptr [esi]
        movdqa  xmm1, xmmword ptr [esi+10h]
        movdqa  xmm2, xmmword ptr [esi+20h]
        movdqa  xmm3, xmmword ptr [esi+30h]
        movdqa  xmmword ptr [edi], xmm0
        movdqa  xmmword ptr [edi+10h], xmm1
        movdqa  xmmword ptr [edi+20h], xmm2
        movdqa  xmmword ptr [edi+30h], xmm3
        movdqa  xmm4, xmmword ptr [esi+40h]
        movdqa  xmm5, xmmword ptr [esi+50h]
        movdqa  xmm6, xmmword ptr [esi+60h]
        movdqa  xmm7, xmmword ptr [esi+70h]
        movdqa  xmmword ptr [edi+40h], xmm4
        movdqa  xmmword ptr [edi+50h], xmm5
        movdqa  xmmword ptr [edi+60h], xmm6
        movdqa  xmmword ptr [edi+70h], xmm7
      }
      _ESI += 128;
      _EDI += 128;
    }
    if ( v53 )
    {
      for ( l = (unsigned int)v53 >> 4; l; --l )
      {
        __asm
        {
          movdqa  xmm0, xmmword ptr [esi]
          movdqa  xmmword ptr [edi], xmm0
        }
        _ESI += 16;
        _EDI += 16;
      }
      v55 = v53 & 0xF;
      if ( v55 )
      {
        v56 = v55;
        for ( m = (unsigned int)v55 >> 2; m; --m )
        {
          *(_DWORD *)_EDI = *(_DWORD *)_ESI;
          _ESI += 4;
          _EDI += 4;
        }
        for ( n = v56 & 3; n; --n )
          *(_BYTE *)_EDI++ = *(_BYTE *)_ESI++;
      }
    }
    result = a1;
  }
  return result;
}
// 10035148: using guessed type int __cdecl loc_10035148(int, int, int);
// 10035238: using guessed type int __cdecl off_10035238(int, int, int);
// 10035248: using guessed type int __cdecl loc_10035248(int, int, int);
// 100352D4: using guessed type int __cdecl loc_100352D4(int, int, int);

//----- (10035550) --------------------------------------------------------
int __cdecl sub_10035550(int a1)
{
  int v1; // ecx@1
  char v2; // al@2
  int v3; // eax@4
  int v4; // eax@5
  int result; // eax@10

  v1 = a1;
  if ( a1 & 3 )
  {
    while ( 1 )
    {
      v2 = *(_BYTE *)v1++;
      if ( !v2 )
        break;
      if ( !(v1 & 3) )
        goto LABEL_4;
    }
LABEL_10:
    result = v1 - 1 - a1;
  }
  else
  {
    while ( 1 )
    {
      do
      {
LABEL_4:
        v3 = (*(_DWORD *)v1 + 2130640639) ^ ~*(_DWORD *)v1;
        v1 += 4;
      }
      while ( !(v3 & 0x81010100) );
      v4 = *(_DWORD *)(v1 - 4);
      if ( !(_BYTE)v4 )
        break;
      if ( !BYTE1(v4) )
        return v1 - 3 - a1;
      if ( !(v4 & 0xFF0000) )
        return v1 - 2 - a1;
      if ( !(v4 & 0xFF000000) )
        goto LABEL_10;
    }
    result = v1 - 4 - a1;
  }
  return result;
}

//----- (100355DB) --------------------------------------------------------
void __stdcall sub_100355DB(int a1, int a2)
{
  int v2; // eax@1
  DWORD dwExceptionCode; // [sp+8h] [bp-20h]@1
  DWORD dwExceptionFlags; // [sp+Ch] [bp-1Ch]@7
  DWORD nNumberOfArguments; // [sp+18h] [bp-10h]@7
  ULONG_PTR Arguments; // [sp+1Ch] [bp-Ch]@6
  int v7; // [sp+20h] [bp-8h]@4
  int v8; // [sp+24h] [bp-4h]@4

  v2 = a2;
  memcpy(&dwExceptionCode, &unk_10061FB4, 0x20u);
  if ( a2 )
  {
    if ( *(_BYTE *)a2 & 0x10 )
      v2 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 - 4) + 24);
  }
  v7 = a1;
  v8 = v2;
  if ( v2 )
  {
    if ( *(_BYTE *)v2 & 8 )
      Arguments = 26820608;
  }
  RaiseException(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, &Arguments);
}

//----- (10035636) --------------------------------------------------------
#error "10035641: positive sp value has been found (funcsize=3)"

//----- (1003564A) --------------------------------------------------------
#error "1003564F: call analysis failed (funcsize=4)"

//----- (10035659) --------------------------------------------------------
#error "1003565E: call analysis failed (funcsize=4)"

//----- (10035668) --------------------------------------------------------
char *__cdecl sub_10035668()
{
  char v1; // [sp-8h] [bp-8h]@1

  return &v1;
}

//----- (1003569B) --------------------------------------------------------
char *__cdecl sub_1003569B()
{
  char v1; // [sp-8h] [bp-8h]@1

  return &v1;
}

//----- (100356D1) --------------------------------------------------------
char *__cdecl sub_100356D1()
{
  char v1; // [sp-8h] [bp-8h]@1

  return &v1;
}

//----- (10035707) --------------------------------------------------------
char *__cdecl sub_10035707()
{
  char v1; // [sp-8h] [bp-8h]@1

  return &v1;
}

//----- (10035740) --------------------------------------------------------
int __usercall sub_10035740<eax>(int a1<ebx>, int a2<edi>, PEXCEPTION_RECORD ExceptionRecord, int TargetFrame, int a5)
{
  char v6; // ST20_1@1

  sub_1002A49B(a1, a2, TargetFrame, TargetFrame ^ *(_DWORD *)(TargetFrame + 8), v6);
  return sub_1003672F(
           a1,
           a2,
           (int)ExceptionRecord,
           *(_DWORD *)(TargetFrame + 16),
           a5,
           0,
           *(_DWORD *)(TargetFrame + 12),
           *(_DWORD *)(TargetFrame + 20),
           (PVOID)TargetFrame,
           0);
}

//----- (10035771) --------------------------------------------------------
int __usercall sub_10035771<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4<esi>)
{
  char v4; // ST20_1@1
  int result; // eax@2

  sub_1002A49B(a1, a3, a4, *(_DWORD *)(a2 + 12) ^ *(_DWORD *)(*(_DWORD *)(a2 + 12) + 8), v4);
  if ( *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4) & 0x66 )
  {
    *(_DWORD *)(*(_DWORD *)(a2 + 12) + 36) = 1;
    result = 1;
  }
  else
  {
    sub_1003672F(
      a1,
      a3,
      *(_DWORD *)(a2 + 8),
      *(_DWORD *)(*(_DWORD *)(a2 + 12) + 16),
      *(_DWORD *)(a2 + 16),
      0,
      *(_DWORD *)(*(_DWORD *)(a2 + 12) + 12),
      *(_DWORD *)(*(_DWORD *)(a2 + 12) + 20),
      *(PVOID *)(*(_DWORD *)(a2 + 12) + 24),
      1);
    if ( !*(_DWORD *)(*(_DWORD *)(a2 + 12) + 36) )
      sub_100359F7(a3, a4, *(PVOID *)(a2 + 12), *(PEXCEPTION_RECORD *)(a2 + 8));
    sub_10035873(a1, a3, 291, a2 - 4, 0, 0, 0, 0, 0);
    result = (*(int (**)(void))(a2 - 4))();
  }
  return result;
}

//----- (1003580E) --------------------------------------------------------
void __usercall sub_1003580E(int a1<edi>, int a2<esi>, int a3, int a4, int a5, int a6, int a7)
{
  int ebp0; // ebp@0
  int v8; // [sp+0h] [bp-18h]@1
  int (__usercall *v9)<eax>(int<ebx>, int<edi>, PEXCEPTION_RECORD, int, int); // [sp+4h] [bp-14h]@1
  unsigned int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v10 = (unsigned int)&v8 ^ __security_cookie;
  v11 = a4;
  v9 = sub_10035740;
  v12 = a3;
  v13 = a6 + 1;
  v8 = a6 + 1;
  sub_10048AB0(ebp0, a1, a2, a5, a3, a7);
}
// 10074200: using guessed type int __security_cookie;

//----- (1003586C) --------------------------------------------------------
#error "FFFFFFFF: positive sp value has been found (funcsize=0)"

//----- (10035873) --------------------------------------------------------
signed int __usercall sub_10035873<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  signed int result; // eax@2
  char v10; // [sp+0h] [bp-3Ch]@3
  int v11; // [sp+4h] [bp-38h]@3
  int (__usercall *v12)<eax>(int<ebx>, int<ebp>, int<edi>, int<esi>); // [sp+8h] [bp-34h]@3
  unsigned int v13; // [sp+Ch] [bp-30h]@3
  int v14; // [sp+10h] [bp-2Ch]@3
  int v15; // [sp+14h] [bp-28h]@3
  int v16; // [sp+18h] [bp-24h]@3
  int v17; // [sp+1Ch] [bp-20h]@3
  char *v18; // [sp+20h] [bp-1Ch]@3
  int *v19; // [sp+24h] [bp-18h]@3
  int v20; // [sp+28h] [bp-14h]@3
  int v21; // [sp+2Ch] [bp-10h]@3
  int v22; // [sp+30h] [bp-Ch]@3
  int v23; // [sp+34h] [bp-8h]@3
  int v24; // [sp+38h] [bp-4h]@3
  int v25; // [sp+3Ch] [bp+0h]@3

  if ( a3 == 291 )
  {
    *(_DWORD *)a4 = loc_1003591C;
    result = 1;
  }
  else
  {
    v12 = sub_10035771;
    v13 = (unsigned int)&v11 ^ __security_cookie;
    v14 = a7;
    v15 = a4;
    v16 = a8;
    v17 = a9;
    v20 = 0;
    v18 = &v10;
    v19 = &v25;
    v11 = a9;
    v24 = 1;
    v21 = a3;
    v22 = a5;
    v23 = *(_DWORD *)(sub_10041A5C(a1, a2) + 128);
    ((void (__cdecl *)(_DWORD, int *))v23)(*(_DWORD *)a3, &v21);
    v24 = 0;
    if ( v20 )
      *(_DWORD *)v11 = *(_DWORD *)a1;
    result = v24;
  }
  return result;
}
// 1003591C: using guessed type int __cdecl loc_1003591C(int, int, int, int, int, int, int);
// 10074200: using guessed type int __security_cookie;

//----- (10035948) --------------------------------------------------------
int __cdecl sub_10035948(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // edx@2
  int v10; // esi@10
  int v12; // [sp+Ch] [bp-8h]@1
  int v13; // [sp+10h] [bp-4h]@1

  v6 = a2;
  v5 = *(_DWORD *)(a1 + 16);
  v8 = *(_DWORD *)(a1 + 12);
  v12 = *(_DWORD *)(a1 + 16);
  v7 = *(_DWORD *)(a1 + 12);
  v13 = *(_DWORD *)(a1 + 12);
  if ( a2 >= 0 )
  {
    v9 = a3;
    do
    {
      if ( v8 == -1 )
      {
        sub_1003B445(v6, v7);
        v5 = v12;
        v9 = a3;
      }
      --v8;
      if ( *(_DWORD *)(20 * v8 + v5 + 4) < v9 && v9 <= *(_DWORD *)(20 * v8 + v5 + 8) || v8 == -1 )
      {
        v7 = v13;
        --v6;
        v13 = v8;
      }
    }
    while ( v6 >= 0 );
  }
  v10 = v8 + 1;
  *(_DWORD *)a4 = v10;
  *(_DWORD *)a5 = v7;
  if ( (unsigned int)v7 > *(_DWORD *)(a1 + 12) || v10 > (unsigned int)v7 )
  {
    sub_1003B445(v6, v7);
    v5 = v12;
  }
  return v5 + 20 * v10;
}

//----- (100359C7) --------------------------------------------------------
int __usercall sub_100359C7<eax>(int a1<ebp>, int a2, int a3)
{
  *(_DWORD *)(a1 - 4) = *(_DWORD *)(a1 + 12) + 12;
  return (*(int (**)(void))(a1 + 8))();
}

//----- (100359F7) --------------------------------------------------------
DWORD __userpurge sub_100359F7<eax>(int a1<edi>, int a2<esi>, PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord)
{
  DWORD result; // eax@1

  RtlUnwind(TargetFrame, loc_10035A21, ExceptionRecord, 0);
  result = ExceptionRecord->ExceptionFlags & 0xFFFFFFFD;
  ExceptionRecord->ExceptionFlags = result;
  *(_DWORD *)a2 = a1;
  return result;
}
// 10035A21: using guessed type int __stdcall loc_10035A21(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord);

//----- (10035A4A) --------------------------------------------------------
int __usercall sub_10035A4A<eax>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  *(_DWORD *)a3 = a4;
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(sub_10041A5C(a1, a2) + 152);
  *(_DWORD *)(sub_10041A5C(a1, a2) + 152) = a3;
  return a3;
}

//----- (10035A74) --------------------------------------------------------
void __usercall sub_10035A74(int a1<ebx>, int a2<edi>, int a3)
{
  int i; // ecx@4

  if ( a3 == *(_DWORD *)(sub_10041A5C(a1, a2) + 152) )
  {
    *(_DWORD *)(sub_10041A5C(a1, a2) + 152) = *(_DWORD *)(a3 + 4);
  }
  else
  {
    for ( i = *(_DWORD *)(sub_10041A5C(a1, a2) + 152); ; i = *(_DWORD *)(i + 4) )
    {
      if ( !*(_DWORD *)(i + 4) )
      {
        sub_1003B445(a1, a2);
        return;
      }
      if ( a3 == *(_DWORD *)(i + 4) )
        break;
    }
    *(_DWORD *)(i + 4) = *(_DWORD *)(a3 + 4);
  }
}

//----- (10035AC4) --------------------------------------------------------
signed int __usercall sub_10035AC4<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // eax@1
  signed int result; // eax@4

  v3 = *(_DWORD *)(sub_10041A5C(a1, a2) + 152);
  if ( v3 )
  {
    while ( *(_DWORD *)v3 != a3 )
    {
      v3 = *(_DWORD *)(v3 + 4);
      if ( !v3 )
        goto LABEL_4;
    }
    result = 0;
  }
  else
  {
LABEL_4:
    result = 1;
  }
  return result;
}

//----- (10035AED) --------------------------------------------------------
int __usercall sub_10035AED<eax>(int a1<eax>, int a2<ebx>, int a3<edi>, int ExceptionRecord, int a5, int a6, int a7)
{
  return sub_1003672F(a2, a3, ExceptionRecord, a5, a6, a7, a1, 0, 0, 0);
}

//----- (10035B23) --------------------------------------------------------
int __cdecl sub_10035B23(int a1)
{
  int result; // eax@1
  int v2; // ecx@7
  int v3; // edx@8

  result = a1;
  if ( a1 )
  {
    if ( *(_DWORD *)a1 == -529697949 )
    {
      if ( *(_DWORD *)(a1 + 16) == 3 )
      {
        if ( *(_DWORD *)(a1 + 20) == 429065504 || *(_DWORD *)(a1 + 20) == 429065505 || *(_DWORD *)(a1 + 20) == 429065506 )
        {
          v2 = *(_DWORD *)(a1 + 28);
          if ( v2 )
          {
            v3 = *(_DWORD *)(v2 + 4);
            if ( v3 )
            {
              result = sub_1003586C(*(_DWORD *)(a1 + 24), v3);
            }
            else
            {
              if ( *(_BYTE *)v2 & 0x10 )
              {
                result = *(_DWORD *)(a1 + 24);
                if ( *(_DWORD *)result )
                  result = (*(int (__stdcall **)(_DWORD))(**(_DWORD **)result + 8))(*(_DWORD *)result);
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 1003586C: using guessed type _DWORD __cdecl sub_1003586C(_DWORD, _DWORD);

//----- (10035BAE) --------------------------------------------------------
int __cdecl sub_10035BAE(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int result; // eax@1
  int v8; // eax@1
  int v9; // eax@1
  char v10; // [sp+10h] [bp-40h]@1
  int v11; // [sp+18h] [bp-38h]@1
  int v12; // [sp+1Ch] [bp-34h]@1
  int v13; // [sp+20h] [bp-30h]@1
  int v14; // [sp+24h] [bp-2Ch]@1
  int v15; // [sp+28h] [bp-28h]@1
  int v16; // [sp+34h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+38h] [bp-18h]@1

  v16 = a5;
  v11 = 0;
  v15 = *(_DWORD *)(a2 - 4);
  v14 = sub_10035A4A(0, a2, (int)&v10, *(_DWORD *)(a1 + 24));
  v13 = *(_DWORD *)(sub_10041A5C(0, a2) + 136);
  v12 = *(_DWORD *)(sub_10041A5C(0, a2) + 140);
  *(_DWORD *)(sub_10041A5C(0, a2) + 136) = a1;
  *(_DWORD *)(sub_10041A5C(0, a2) + 140) = a3;
  ms_exc.disabled = 1;
  sub_1003580E(a2, a1, a2, a4, a5, a6, a7);
  v16 = v8;
  ms_exc.disabled = -2;
  *(_DWORD *)(a2 - 4) = v15;
  sub_10035A74(0, a2, v14);
  v9 = sub_10041A5C(0, a2);
  *(_DWORD *)(v9 + 136) = v13;
  result = sub_10041A5C(0, a2);
  *(_DWORD *)(result + 140) = v12;
  if ( *(_DWORD *)a1 == -529697949 )
  {
    if ( *(_DWORD *)(a1 + 16) == 3 )
    {
      if ( *(_DWORD *)(a1 + 20) == 429065504 || *(_DWORD *)(a1 + 20) == 429065505 || *(_DWORD *)(a1 + 20) == 429065506 )
      {
        if ( !v11 )
        {
          if ( v16 )
          {
            result = sub_10035AC4(0, v16, *(_DWORD *)(a1 + 24));
            if ( result )
              result = sub_10035B23(a1);
          }
        }
      }
    }
  }
  return result;
}

//----- (10035D7C) --------------------------------------------------------
void __usercall sub_10035D7C(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  sub_100356D1();
  if ( *(_DWORD *)(sub_10041A5C(a1, a3) + 148) )
    sub_1003B445(a1, a3);
  *(_DWORD *)(a2 - 4) = 0;
  sub_1003B4B1(a1, a3);
  *(_DWORD *)(sub_10041A5C(a1, a3) + 148) = *(_DWORD *)(a2 + 8);
  sub_100355DB(0, 0);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_10035DBC);
}

//----- (10035DBC) --------------------------------------------------------
int __usercall sub_10035DBC<eax>(int a1<ebx>, int a2<esi>, PEXCEPTION_RECORD ExceptionRecord, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, PVOID TargetFrame)
{
  int ebp0; // ebp@0
  int result; // eax@6
  PVOID v14; // [sp-8h] [bp-Ch]@4

  if ( a9 )
    sub_100363F5((int)ExceptionRecord, a4, a8, a9);
  if ( TargetFrame )
    v14 = TargetFrame;
  else
    v14 = (PVOID)a4;
  sub_100359F7(a4, a2, v14, ExceptionRecord);
  sub_10036656(a1, a4, a4, a6, a7, *(_DWORD *)a10);
  *(_DWORD *)(a4 + 8) = *(_DWORD *)(a10 + 4) + 1;
  result = sub_10035BAE((int)ExceptionRecord, a4, a5, a7, *(_DWORD *)(a8 + 12), a11, 256);
  if ( result )
    result = sub_100359C7(ebp0, result, a4);
  return result;
}

//----- (10035E37) --------------------------------------------------------
signed int __usercall sub_10035E37<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  _DWORD *v3; // eax@1
  signed int result; // eax@7

  v3 = *(_DWORD **)a3;
  if ( **(_DWORD **)a3 != -529697949
    || v3[4] != 3
    || v3[5] != 429065504 && v3[5] != 429065505 && v3[5] != 429065506
    || v3[7] )
  {
    result = 0;
  }
  else
  {
    *(_DWORD *)(sub_10041A5C(a1, a2) + 940) = 1;
    result = 1;
  }
  return result;
}

//----- (10035E84) --------------------------------------------------------
void __cdecl sub_10035E84(int ExceptionRecord, int a2, int a3, int a4, int a5, char a6, int a7, PVOID TargetFrame)
{
  int v8; // ebx@1
  int ebp0; // ebp@0
  int v10; // edi@1
  unsigned __int8 v11; // zf@1
  char v12; // sf@1
  unsigned __int8 v13; // of@1
  int v14; // eax@2
  int v15; // esi@7
  int v16; // ST28_4@24
  int v17; // eax@26
  int v18; // eax@30
  int v19; // eax@38
  unsigned int v20; // ecx@38
  int v21; // eax@39
  int v22; // edx@39
  int v23; // edi@42
  unsigned __int8 v24; // zf@42
  unsigned __int8 v25; // sf@42
  int v26; // ecx@43
  int v27; // eax@44
  int v28; // edx@44
  int *v29; // eax@44
  int v30; // ST28_4@45
  int v31; // eax@60
  char v32; // zf@60
  PEXCEPTION_RECORD v33; // ST2C_4@72
  PVOID v34; // [sp-4h] [bp-4Ch]@60
  int (__stdcall **v35)(char); // [sp+Ch] [bp-3Ch]@70
  int v36; // [sp+18h] [bp-30h]@45
  int v37; // [sp+1Ch] [bp-2Ch]@40
  unsigned int v38; // [sp+20h] [bp-28h]@38
  int v39; // [sp+24h] [bp-24h]@1
  int v40; // [sp+28h] [bp-20h]@42
  int v41; // [sp+2Ch] [bp-1Ch]@46
  int v42; // [sp+30h] [bp-18h]@46
  int v43; // [sp+34h] [bp-14h]@24
  unsigned int v44; // [sp+38h] [bp-10h]@38
  int v45; // [sp+3Ch] [bp-Ch]@42
  int v46; // [sp+40h] [bp-8h]@4
  char v47; // [sp+47h] [bp-1h]@1
  int v48; // [sp+50h] [bp+8h]@14

  v10 = a5;
  v8 = 0;
  v13 = __SETO__(*(_DWORD *)(a5 + 4), 128);
  v11 = *(_DWORD *)(a5 + 4) == 128;
  v12 = *(_DWORD *)(a5 + 4) - 128 < 0;
  LOBYTE(v39) = 0;
  v47 = 0;
  if ( (unsigned __int8)(v12 ^ v13) | v11 )
    v14 = *(_BYTE *)(a2 + 8);
  else
    v14 = *(_DWORD *)(a2 + 8);
  v46 = v14;
  if ( v14 < -1 || v14 >= *(_DWORD *)(a5 + 4) )
    sub_1003B445(0, a5);
  v15 = ExceptionRecord;
  if ( *(_DWORD *)ExceptionRecord != -529697949 )
  {
    v18 = a3;
LABEL_63:
    if ( *(_DWORD *)(v10 + 12) > 0u )
    {
      if ( a6 )
        goto LABEL_69;
      sub_1003621F(0, (PEXCEPTION_RECORD)v15, a2, v18, a4, v10, v46, a7, TargetFrame);
    }
    goto LABEL_66;
  }
  if ( *(_DWORD *)(ExceptionRecord + 16) != 3
    || *(_DWORD *)(ExceptionRecord + 20) != 429065504
    && *(_DWORD *)(ExceptionRecord + 20) != 429065505
    && *(_DWORD *)(ExceptionRecord + 20) != 429065506
    || *(_DWORD *)(ExceptionRecord + 28) )
  {
    v18 = a3;
    v48 = a3;
  }
  else
  {
    if ( !*(_DWORD *)(sub_10041A5C(0, v10) + 136) )
      return;
    v15 = *(_DWORD *)(sub_10041A5C(0, v10) + 136);
    v48 = *(_DWORD *)(sub_10041A5C(0, v10) + 140);
    LOBYTE(v39) = 1;
    if ( !sub_10048AFC(v15) )
      sub_1003B445(0, v10);
    if ( *(_DWORD *)v15 == -529697949 )
    {
      if ( *(_DWORD *)(v15 + 16) == 3 )
      {
        if ( *(_DWORD *)(v15 + 20) == 429065504
          || *(_DWORD *)(v15 + 20) == 429065505
          || *(_DWORD *)(v15 + 20) == 429065506 )
        {
          if ( !*(_DWORD *)(v15 + 28) )
            sub_1003B445(0, v10);
        }
      }
    }
    if ( *(_DWORD *)(sub_10041A5C(0, v10) + 148) )
    {
      v43 = *(_DWORD *)(sub_10041A5C(0, v10) + 148);
      v16 = v43;
      *(_DWORD *)(sub_10041A5C(0, v10) + 148) = 0;
      if ( !sub_10036339(0, v10, v15, v16) )
      {
        v10 = v43;
        if ( *(_DWORD *)v43 > 0 )
        {
          v17 = 0;
          a5 = 0;
          while ( !sub_1002CAFD(*(void **)(v17 + *(_DWORD *)(v43 + 4) + 4), (int)&off_100738A4) )
          {
            ++v8;
            v17 = a5 + 16;
            a5 += 16;
            if ( v8 >= *(_DWORD *)v43 )
              goto LABEL_69;
          }
          goto LABEL_70;
        }
LABEL_69:
        sub_1003B47D(v8, v10);
LABEL_70:
        sub_10035B23(v15);
        a5 = (int)"bad exception";
        sub_1002AEA4((int)&v35, &a5);
        v35 = &off_10061C68;
        sub_100355DB((int)&v35, (int)&unk_1006C474);
LABEL_71:
        v34 = TargetFrame;
LABEL_72:
        sub_100359F7(v10, v15, v34, v33);
        sub_10036656(v8, v10, a2, a4, v10, -1);
        sub_10035D7C(v8, ebp0, v10);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_1003621F);
      }
    }
    v18 = v48;
  }
  if ( *(_DWORD *)v15 != -529697949
    || *(_DWORD *)(v15 + 16) != 3
    || *(_DWORD *)(v15 + 20) != 429065504 && *(_DWORD *)(v15 + 20) != 429065505 && *(_DWORD *)(v15 + 20) != 429065506 )
    goto LABEL_63;
  if ( *(_DWORD *)(v10 + 12) > 0u )
  {
    v19 = sub_10035948(v10, a7, v46, (int)&v44, (int)&v38);
    v20 = v44;
    if ( v44 < v38 )
    {
      v22 = v19 + 16;
      v21 = v46;
      v43 = v22;
      do
      {
        v37 = v22 - 16;
        if ( *(_DWORD *)(v22 - 16) <= v21 )
        {
          if ( v21 <= *(_DWORD *)(v22 - 12) )
          {
            v45 = *(_DWORD *)v22;
            v23 = *(_DWORD *)(v22 - 4);
            v40 = v23;
            v24 = v23 == 0;
            v25 = v23 < 0;
            v10 = a5;
            if ( !(v25 | v24) )
            {
              v26 = v45;
              while ( 2 )
              {
                v29 = *(int **)(*(_DWORD *)(v15 + 28) + 12);
                v28 = (int)(v29 + 1);
                v27 = *v29;
                while ( 1 )
                {
                  v42 = v27;
                  v41 = v28;
                  if ( v27 <= 0 )
                    break;
                  v30 = *(_DWORD *)(v15 + 28);
                  v36 = *(_DWORD *)v28;
                  if ( sub_1003680E(v26, v36, v30) )
                  {
                    v47 = 1;
                    sub_10035DBC(a2, v15, (PEXCEPTION_RECORD)v15, a2, v48, a4, v10, v45, v36, v37, a7, TargetFrame);
                    goto LABEL_51;
                  }
                  v26 = v45;
                  v27 = v42 - 1;
                  v28 = v41 + 4;
                }
                v26 += 16;
                --v40;
                v45 = v26;
                if ( v40 > 0 )
                  continue;
                break;
              }
LABEL_51:
              v22 = v43;
              v21 = v46;
              v20 = v44;
            }
          }
        }
        ++v20;
        v22 += 20;
        v44 = v20;
        v43 = v22;
      }
      while ( v20 < v38 );
      v8 = 0;
    }
  }
  if ( a6 )
    sub_10035B23(v15);
  if ( !v47
    && (*(_DWORD *)v10 & 0x1FFFFFFFu) >= 0x19930521
    && *(_DWORD *)(v10 + 28)
    && !sub_10036339(v8, v10, v15, *(_DWORD *)(v10 + 28)) )
  {
    sub_10041A5C(v8, v10);
    sub_10041A5C(v8, v10);
    *(_DWORD *)(sub_10041A5C(v8, v10) + 136) = v15;
    v31 = sub_10041A5C(v8, v10);
    v32 = TargetFrame == 0;
    *(_DWORD *)(v31 + 140) = v48;
    v34 = (PVOID)v15;
    if ( v32 )
      goto LABEL_72;
    goto LABEL_71;
  }
LABEL_66:
  if ( *(_DWORD *)(sub_10041A5C(v8, v10) + 148) != v8 )
    sub_1003B445(v8, v10);
}
// 10061C68: using guessed type int (__stdcall *off_10061C68)(char);
// 100738A4: using guessed type int (__stdcall **off_100738A4)(char);

//----- (1003621F) --------------------------------------------------------
void __usercall sub_1003621F(int a1<ebx>, PEXCEPTION_RECORD ExceptionRecord, int a3, int a4, int a5, int a6, int a7, int a8, PVOID TargetFrame)
{
  int v9; // ebx@2
  int v10; // eax@2
  PVOID v11; // esi@3
  int v12; // eax@9
  int v13; // edx@9
  int v14; // ecx@9
  int v15; // eax@10
  int v16; // esi@10
  int v17; // eax@13
  int v18; // eax@15
  unsigned int v19; // [sp+4h] [bp-8h]@9
  unsigned int v20; // [sp+8h] [bp-4h]@9

  if ( ExceptionRecord->ExceptionCode != -2147483645 )
  {
    v10 = sub_10041A5C(a1, (int)ExceptionRecord);
    v9 = a6;
    if ( !*(_DWORD *)(v10 + 128)
      || (v11 = EncodePointer(0), *(PVOID *)(sub_10041A5C(a6, (int)ExceptionRecord) + 128) == v11)
      || ExceptionRecord->ExceptionCode == -532459699
      || ExceptionRecord->ExceptionCode == -532462766
      || !sub_10035873(a6, (int)ExceptionRecord, (int)ExceptionRecord, a3, a4, a5, a6, a8, (int)TargetFrame) )
    {
      if ( !*(_DWORD *)(a6 + 12) )
        sub_1003B445(a6, (int)ExceptionRecord);
      v12 = sub_10035948(a6, a8, a7, (int)&v19, (int)&v20);
      v14 = v19;
      v13 = v20;
      if ( v19 < v20 )
      {
        v16 = v12 + 12;
        v15 = a7;
        do
        {
          if ( v15 >= *(_DWORD *)(v16 - 12) )
          {
            if ( v15 <= *(_DWORD *)(v16 - 8) )
            {
              v17 = 16 * *(_DWORD *)v16;
              if ( !*(_DWORD *)(*(_DWORD *)(v16 + 4) + v17 - 12)
                || (v13 = v20, v9 = a6, !*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v16 + 4) + v17 - 12) + 8)) )
              {
                v18 = *(_DWORD *)(v16 + 4) - 16 + v17;
                if ( !(*(_BYTE *)v18 & 0x40) )
                {
                  sub_10035DBC(v9, v16, ExceptionRecord, a3, a4, a5, v9, v18, 0, v16 - 12, a8, TargetFrame);
                  v13 = v20;
                  v14 = v19;
                }
              }
              v15 = a7;
            }
          }
          ++v14;
          v16 += 20;
          v19 = v14;
        }
        while ( v14 < (unsigned int)v13 );
      }
    }
  }
}

//----- (10036339) --------------------------------------------------------
char __usercall sub_10036339<al>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  int v4; // esi@1
  char v5; // bl@2
  int v6; // edi@2
  int v7; // ecx@3
  int v8; // edx@4
  int v9; // eax@4
  bool v10; // eax@5
  int v12; // [sp+Ch] [bp-8h]@4
  int v13; // [sp+10h] [bp-4h]@4
  int v14; // [sp+20h] [bp+Ch]@3

  v4 = a4;
  if ( !a4 )
  {
    sub_1003B445(a1, a2);
    sub_1003B47D(a1, a2);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_100363BF);
  }
  v5 = 0;
  v6 = 0;
  if ( *(_DWORD *)a4 > 0 )
  {
    v7 = 0;
    v14 = 0;
    do
    {
      v9 = *(_DWORD *)(*(_DWORD *)(a3 + 28) + 12);
      v8 = v9 + 4;
      v12 = v9 + 4;
      v13 = *(_DWORD *)v9;
      if ( *(_DWORD *)v9 > 0 )
      {
        while ( 1 )
        {
          v10 = sub_1003680E(v7 + *(_DWORD *)(v4 + 4), *(_DWORD *)v8, *(_DWORD *)(a3 + 28));
          v7 = v14;
          if ( v10 )
            break;
          v8 = v12 + 4;
          --v13;
          v12 += 4;
          if ( v13 <= 0 )
            goto LABEL_9;
        }
        v5 = 1;
      }
LABEL_9:
      ++v6;
      v7 += 16;
      v14 = v7;
    }
    while ( v6 < *(_DWORD *)v4 );
  }
  return v5;
}

//----- (100363BF) --------------------------------------------------------
char __usercall sub_100363BF<al>(int a1<ebx>, int a2<edi>)
{
  return *(_DWORD *)(sub_10041A5C(a1, a2) + 144) != 0;
}

//----- (100363D0) --------------------------------------------------------
int __cdecl sub_100363D0(int a1, int a2)
{
  int result; // eax@1
  int v3; // esi@1

  v3 = *(_DWORD *)(a2 + 4);
  result = a1 + *(_DWORD *)a2;
  if ( v3 >= 0 )
    result += v3 + *(_DWORD *)(*(_DWORD *)(v3 + a1) + *(_DWORD *)(a2 + 8));
  return result;
}

//----- (100363F5) --------------------------------------------------------
int __cdecl sub_100363F5(int a1, int a2, int a3, int a4)
{
  int v4; // edi@2
  int v5; // eax@4
  int result; // eax@5

  _SEH_prolog4(stru_1006C830, 8);
  if ( *(_DWORD *)a3 & 0x80000000 )
    v4 = a2;
  else
    v4 = *(_DWORD *)(a3 + 8) + a2 + 12;
  v5 = sub_10036483(a1, a2, a3, a4) - 1;
  if ( v5 )
  {
    result = v5 - 1;
    if ( !result )
    {
      sub_100363D0(*(_DWORD *)(a1 + 24), a4 + 8);
      result = sub_1003586C(v4, *(_DWORD *)(a4 + 24));
    }
  }
  else
  {
    sub_100363D0(*(_DWORD *)(a1 + 24), a4 + 8);
    result = sub_1003586C(v4, *(_DWORD *)(a4 + 24));
  }
  return result;
}
// 1003586C: using guessed type _DWORD __cdecl sub_1003586C(_DWORD, _DWORD);
// 1003B250: using guessed type _DWORD __cdecl _SEH_prolog4(_DWORD, _DWORD);
// 1006C830: using guessed type _EH4_SCOPETABLE stru_1006C830[1];

//----- (10036483) --------------------------------------------------------
int __cdecl sub_10036483(int a1, int a2, int a3, int a4)
{
  int v4; // ecx@1
  int v5; // ebx@1
  int v6; // ecx@3
  int v7; // edx@5
  int v8; // edi@5
  int v9; // ecx@10
  unsigned int v10; // ST08_4@21
  int v11; // eax@21
  int v13; // [sp-8h] [bp-34h]@10
  int v14; // [sp-8h] [bp-34h]@12
  int v15; // [sp-4h] [bp-30h]@10

  v5 = 0;
  v4 = *(_DWORD *)(a3 + 4);
  if ( v4 )
  {
    if ( *(_BYTE *)(v4 + 8) )
    {
      v6 = *(_DWORD *)(a3 + 8);
      if ( v6 || *(_DWORD *)a3 & 0x80000000 )
      {
        v7 = *(_DWORD *)a3;
        v8 = a2;
        if ( *(_DWORD *)a3 >= 0 )
          v8 = v6 + a2 + 12;
        if ( v7 & 8 )
        {
          if ( sub_10048AFC(*(_DWORD *)(a1 + 24)) && sub_10048AFC(v8) )
          {
            v9 = *(_DWORD *)(a1 + 24);
            *(_DWORD *)v8 = v9;
            v15 = a4 + 8;
            v13 = v9;
LABEL_11:
            *(_DWORD *)v8 = sub_100363D0(v13, v15);
            return v5;
          }
        }
        else
        {
          v14 = *(_DWORD *)(a1 + 24);
          if ( *(_BYTE *)a4 & 1 )
          {
            if ( sub_10048AFC(v14) && sub_10048AFC(v8) )
            {
              sub_1002A4B0((void *)v8, *(const void **)(a1 + 24), *(_DWORD *)(a4 + 20));
              if ( *(_DWORD *)(a4 + 20) != 4 || !*(_DWORD *)v8 )
                return v5;
              v15 = a4 + 8;
              v13 = *(_DWORD *)v8;
              goto LABEL_11;
            }
          }
          else
          {
            if ( *(_DWORD *)(a4 + 24) )
            {
              if ( sub_10048AFC(v14) && sub_10048AFC(v8) && sub_10048AFC(*(_DWORD *)(a4 + 24)) )
                return ((*(_BYTE *)a4 & 4) != 0) + 1;
            }
            else
            {
              if ( sub_10048AFC(v14) && sub_10048AFC(v8) )
              {
                v10 = *(_DWORD *)(a4 + 20);
                v11 = sub_100363D0(*(_DWORD *)(a1 + 24), a4 + 8);
                sub_1002A4B0((void *)v8, (const void *)v11, v10);
                return v5;
              }
            }
          }
        }
        sub_1003B445(0, v8);
        return v5;
      }
    }
  }
  return 0;
}

//----- (10036608) --------------------------------------------------------
void __usercall sub_10036608(int a1<ebx>, int a2<edi>, int a3)
{
  _DWORD *v3; // eax@1
  int v4; // eax@6

  v3 = *(_DWORD **)a3;
  if ( **(_DWORD **)a3 == -532462766 || *v3 == -532459699 )
  {
    if ( *(_DWORD *)(sub_10041A5C(a1, a2) + 144) > 0 )
    {
      v4 = sub_10041A5C(a1, a2);
      --*(_DWORD *)(v4 + 144);
    }
  }
  else
  {
    if ( *v3 == -529697949 )
    {
      *(_DWORD *)(sub_10041A5C(a1, a2) + 144) = 0;
      sub_1003B47D(a1, a2);
    }
  }
}

//----- (10036656) --------------------------------------------------------
int __usercall sub_10036656<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6)
{
  int ebp0; // ebp@0
  int v7; // esi@2
  int v8; // eax@4
  int v9; // eax@9
  int result; // eax@12
  int v11; // [sp+10h] [bp-20h]@9

  if ( *(_DWORD *)(a5 + 4) > 128 )
    v7 = *(_DWORD *)(a3 + 8);
  else
    v7 = *(_BYTE *)(a3 + 8);
  v8 = sub_10041A5C(a1, a2);
  ++*(_DWORD *)(v8 + 144);
  while ( v7 != a6 )
  {
    if ( v7 <= -1 || v7 >= *(_DWORD *)(a5 + 4) )
      sub_1003B445(a1, a2);
    v9 = *(_DWORD *)(a5 + 8);
    v11 = *(_DWORD *)(v9 + 8 * v7);
    if ( *(_DWORD *)(v9 + 8 * v7 + 4) )
    {
      *(_DWORD *)(a3 + 8) = *(_DWORD *)(v9 + 8 * v7);
      sub_10048AB0(ebp0, a2, v7, *(_DWORD *)(*(_DWORD *)(a5 + 8) + 8 * v7 + 4), a3, 259);
    }
    v7 = v11;
  }
  result = sub_10041A5C(a1, a2);
  if ( *(_DWORD *)(result + 144) > 0 )
  {
    result = sub_10041A5C(a1, a2);
    --*(_DWORD *)(result + 144);
  }
  return result;
}

//----- (1003672F) --------------------------------------------------------
int __usercall sub_1003672F<eax>(int a1<ebx>, int a2<edi>, int ExceptionRecord, int a4, int a5, int a6, int a7, int a8, PVOID TargetFrame, char a10)
{
  int (__cdecl *v10)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // esi@16

  if ( *(_DWORD *)(sub_10041A5C(a1, a2) + 940)
    || *(_DWORD *)ExceptionRecord == -529697949
    || *(_DWORD *)ExceptionRecord == -2147483610
    || (*(_DWORD *)a7 & 0x1FFFFFFFu) < 0x19930522
    || !(*(_BYTE *)(a7 + 32) & 1) )
  {
    if ( *(_BYTE *)(ExceptionRecord + 4) & 0x66 )
    {
      if ( *(_DWORD *)(a7 + 4) )
      {
        if ( !a8 )
          sub_10036656(-529697949, 429065506, a4, a6, a7, -1);
      }
    }
    else
    {
      if ( *(_DWORD *)(a7 + 12) || (*(_DWORD *)a7 & 0x1FFFFFFFu) >= 0x19930521 && *(_DWORD *)(a7 + 28) )
      {
        if ( *(_DWORD *)ExceptionRecord == -529697949 )
        {
          if ( *(_DWORD *)(ExceptionRecord + 16) >= 3u )
          {
            if ( *(_DWORD *)(ExceptionRecord + 20) > 0x19930522u )
            {
              v10 = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(ExceptionRecord + 28) + 8);
              if ( v10 )
                return v10(ExceptionRecord, a4, a5, a6, a7, a8, TargetFrame, (unsigned __int8)a10);
            }
          }
        }
        sub_10035E84(ExceptionRecord, a4, a5, a6, a7, a10, a8, TargetFrame);
      }
    }
  }
  return 1;
}

//----- (1003680E) --------------------------------------------------------
bool __cdecl sub_1003680E(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // edx@3

  v3 = *(_DWORD *)(a1 + 4);
  return !v3
      || !*(_BYTE *)(v3 + 8)
      || ((v4 = *(_DWORD *)(a2 + 4), v3 == v4) || !sub_10039310(v3 + 8, v4 + 8))
      && (!(*(_BYTE *)a2 & 2) || *(_BYTE *)a1 & 8)
      && (!(*(_BYTE *)a3 & 1) || *(_BYTE *)a1 & 1)
      && (!(*(_BYTE *)a3 & 2) || *(_BYTE *)a1 & 2);
}

//----- (1003686B) --------------------------------------------------------
void __cdecl sub_1003686B(unsigned int a1, LPCSTR lpWideCharStr)
{
  int v2; // ebx@1
  int v3; // edi@1
  const CHAR *v4; // esi@1
  int v5; // eax@2
  int v6; // ecx@2
  WCHAR *v7; // eax@6
  int v8; // eax@8
  int v9; // eax@13
  signed int v10; // eax@14
  int v11; // eax@14
  int v12; // edx@14
  int v13; // ecx@14
  int v14; // eax@19
  signed int v15; // eax@20
  int v16; // edx@20
  int v17; // ecx@20
  int v18; // edi@25
  int v19; // ecx@33
  int v20; // [sp+10h] [bp-30h]@14
  int v21; // [sp+14h] [bp-2Ch]@14
  int v22; // [sp+18h] [bp-28h]@20
  int v23; // [sp+1Ch] [bp-24h]@19
  int v24; // [sp+20h] [bp-20h]@14
  int cbMultiByte; // [sp+24h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+28h] [bp-18h]@25
  int v27; // [sp+4Ch] [bp+Ch]@13

  v2 = 0;
  cbMultiByte = 0;
  v3 = 0;
  v4 = lpWideCharStr;
  if ( !lpWideCharStr )
    goto LABEL_13;
  v5 = sub_10048D46((int)&cbMultiByte, 0, 0, lpWideCharStr, 2147483647);
  if ( !v5 || v5 != 22 && v5 != 34 )
    goto LABEL_6;
  while ( 1 )
  {
    sub_1003A17E(v2, v3);
LABEL_6:
    v7 = (WCHAR *)sub_10037506(v6, v2, cbMultiByte, 2u);
    v3 = (int)v7;
    if ( !v7 )
      break;
    v8 = sub_10048D46(v2, v7, cbMultiByte, v4, -1);
    if ( !v8 )
      goto LABEL_13;
    if ( v8 != 22 && v8 != 34 )
    {
      if ( v8 )
        goto LABEL_12;
LABEL_13:
      v4 = (const CHAR *)a1;
      sub_10042D1C(v3, a1, v3);
      v2 = v9;
      v27 = v9;
      sub_100309A2(v9, (LPVOID)v3);
      if ( !v2 )
        return;
      v11 = sub_10041A5C(v2, v3);
      v24 = v11;
      v20 = *(_DWORD *)(v11 + 108);
      v21 = *(_DWORD *)(v11 + 104);
      v3 = 0;
      cbMultiByte = 0;
      v10 = sub_10048FC9(v2, (int)&cbMultiByte, 0, 0, v2, 0, (int)&v20);
      if ( !v10 )
        goto LABEL_19;
      if ( v10 != 22 && v10 != 34 )
      {
        if ( v10 )
          return;
LABEL_19:
        v14 = sub_10037550(v12, v13, v2, cbMultiByte + 4);
        v3 = v14;
        v23 = v14;
        if ( !v14 )
          return;
        v2 = v14 + 4;
        v22 = v14 + 4;
        v15 = sub_10048FC9(v14 + 4, 0, (CHAR *)(v14 + 4), cbMultiByte, v27, -1, (int)&v20);
        if ( !v15 )
          goto LABEL_25;
        if ( v15 != 22 && v15 != 34 )
        {
          if ( v15 )
          {
LABEL_12:
            sub_100309A2(v2, (LPVOID)v3);
            return;
          }
LABEL_25:
          v18 = v20;
          sub_10036A43(v16, v17, v2, v20, 12);
          ms_exc.disabled = 0;
          if ( *(_DWORD *)(v18 + 16 * a1 + 24) )
          {
            if ( !InterlockedDecrement(*(volatile LONG **)(v18 + 16 * a1 + 24)) )
              sub_100309A2(v2, *(LPVOID *)(v18 + 16 * a1 + 24));
          }
          if ( !(*(_BYTE *)(v24 + 112) & 2) )
          {
            if ( !(dword_10074C0C & 1) )
            {
              if ( *(_DWORD *)(v18 + 16 * a1 + 24) )
              {
                if ( !InterlockedDecrement(*(volatile LONG **)(v18 + 16 * a1 + 24)) )
                  sub_100309A2(v2, *(LPVOID *)(v18 + 16 * a1 + 24));
              }
            }
          }
          v19 = v23;
          *(_DWORD *)v23 = *(_DWORD *)v18;
          *(_DWORD *)(v18 + 16 * a1 + 24) = v19;
          *(_DWORD *)(v18 + 16 * a1 + 16) = v2;
          sub_10036BA7(12);
          return;
        }
      }
    }
  }
}
// 10074C0C: using guessed type int dword_10074C0C;

//----- (10036A43) --------------------------------------------------------
void __usercall sub_10036A43(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // edx@2
  int v6; // eax@2
  int v7; // [sp-4h] [bp-8h]@2

  if ( !*(&lpCriticalSection + 2 * a5) )
  {
    sub_10036ACB(a1, a2, a3, a4, a5);
    if ( !v6 )
      sub_1003AF92(v5, v7, a3, a4, 17);
  }
  EnterCriticalSection(*(&lpCriticalSection + 2 * a5));
}

//----- (10036ACB) --------------------------------------------------------
void __usercall sub_10036ACB(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  HMODULE v5; // ecx@2
  int v6; // edx@5
  int v7; // esi@5
  int v8; // [sp-4h] [bp-2Ch]@5

  if ( !hHeap )
  {
    sub_1003F5BC(a1, a2, a3, a4);
    sub_1003F619(a3, 30);
    sub_1003AE6C(v5, 0xFFu);
  }
  if ( !*(&lpCriticalSection + 2 * a5) )
  {
    v7 = sub_10037550(a1, a2, a3, 24);
    if ( v7 )
    {
      sub_10036A43(v6, v8, a3, a5, 10);
      if ( *(&lpCriticalSection + 2 * a5) )
      {
        sub_100309A2(a3, (LPVOID)v7);
      }
      else
      {
        InitializeCriticalSectionAndSpinCount((LPCRITICAL_SECTION)v7, 0xFA0u);
        *(&lpCriticalSection + 2 * a5) = (LPCRITICAL_SECTION)v7;
      }
      sub_10036BA7(10);
    }
    else
    {
      *(_DWORD *)sub_10037669(a3) = 12;
    }
  }
}

//----- (10036B72) --------------------------------------------------------
signed int __cdecl sub_10036B72()
{
  _UNKNOWN *v0; // edi@1
  signed int v1; // esi@1

  v1 = (signed int)&lpCriticalSection;
  v0 = &unk_10076740;
  do
  {
    if ( *(_DWORD *)(v1 + 4) == 1 )
    {
      *(_DWORD *)v1 = v0;
      v0 = (char *)v0 + 24;
      InitializeCriticalSectionAndSpinCount(*(LPCRITICAL_SECTION *)v1, 0xFA0u);
    }
    v1 += 8;
  }
  while ( v1 < (signed int)&off_10074080 );
  return 1;
}
// 10074080: using guessed type wchar_t *off_10074080;

//----- (10036BA7) --------------------------------------------------------
void __cdecl sub_10036BA7(int a1)
{
  LeaveCriticalSection(*(&lpCriticalSection + 2 * a1));
}

//----- (10036BBC) --------------------------------------------------------
int __usercall sub_10036BBC<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // eax@1
  int v4; // edx@1

  v3 = sub_10041A5C(a1, a2);
  v4 = v3;
  v2 = *(_DWORD *)(v3 + 108);
  if ( (volatile LONG *)v2 != off_10074B44 )
  {
    if ( !(dword_10074C0C & *(_DWORD *)(v4 + 112)) )
      sub_10041EAE(a1, a2);
  }
  return *(_DWORD *)(v2 + 144);
}
// 10074C0C: using guessed type int dword_10074C0C;

//----- (10036BE5) --------------------------------------------------------
int __usercall sub_10036BE5<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4)
{
  int v4; // ecx@2
  __int16 v5; // cx@3
  int v7; // [sp+0h] [bp-10h]@1
  int v8; // [sp+8h] [bp-8h]@5
  char v9; // [sp+Ch] [bp-4h]@4

  sub_1003018D((int)&v7, a1, a2, a4);
  if ( *(_DWORD *)(v7 + 116) <= 1 )
  {
    v5 = *(_WORD *)(*(_DWORD *)(v7 + 144) + 2 * a3);
    v4 = v5 & 4;
  }
  else
  {
    v4 = sub_10042678(a1, a2, a3, 4, (int)&v7);
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFDu;
  return v4;
}

//----- (10036C35) --------------------------------------------------------
int __usercall sub_10036C35<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4)
{
  int v4; // ecx@2
  __int16 v5; // cx@3
  int v7; // [sp+0h] [bp-10h]@1
  int v8; // [sp+8h] [bp-8h]@5
  char v9; // [sp+Ch] [bp-4h]@4

  sub_1003018D((int)&v7, a1, a2, a4);
  if ( *(_DWORD *)(v7 + 116) <= 1 )
  {
    v5 = *(_WORD *)(*(_DWORD *)(v7 + 144) + 2 * a3);
    v4 = v5 & 2;
  }
  else
  {
    v4 = sub_10042678(a1, a2, a3, 2, (int)&v7);
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFDu;
  return v4;
}

//----- (10036C85) --------------------------------------------------------
int __usercall sub_10036C85<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4)
{
  int v4; // ecx@2
  __int16 v5; // cx@3
  int v7; // [sp+0h] [bp-10h]@1
  int v8; // [sp+8h] [bp-8h]@5
  char v9; // [sp+Ch] [bp-4h]@4

  sub_1003018D((int)&v7, a1, a2, a4);
  if ( *(_DWORD *)(v7 + 116) <= 1 )
  {
    v5 = *(_WORD *)(*(_DWORD *)(v7 + 144) + 2 * a3);
    v4 = v5 & 8;
  }
  else
  {
    v4 = sub_10042678(a1, a2, a3, 8, (int)&v7);
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFDu;
  return v4;
}

//----- (10036CD5) --------------------------------------------------------
int __usercall sub_10036CD5<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4)
{
  int v4; // ecx@2
  __int16 v5; // cx@3
  int v7; // [sp+0h] [bp-10h]@1
  int v8; // [sp+8h] [bp-8h]@5
  char v9; // [sp+Ch] [bp-4h]@4

  sub_1003018D((int)&v7, a1, a2, a4);
  if ( *(_DWORD *)(v7 + 116) <= 1 )
  {
    v5 = *(_WORD *)(*(_DWORD *)(v7 + 144) + 2 * a3);
    v4 = v5 & 1;
  }
  else
  {
    v4 = sub_10042678(a1, a2, a3, 1, (int)&v7);
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFDu;
  return v4;
}

//----- (10036D25) --------------------------------------------------------
int __usercall sub_10036D25<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4)
{
  int v4; // ecx@2
  __int16 v5; // cx@3
  int v7; // [sp+0h] [bp-10h]@1
  int v8; // [sp+8h] [bp-8h]@5
  char v9; // [sp+Ch] [bp-4h]@4

  sub_1003018D((int)&v7, a1, a2, a4);
  if ( *(_DWORD *)(v7 + 116) <= 1 )
  {
    v5 = *(_WORD *)(*(_DWORD *)(v7 + 144) + 2 * a3);
    v4 = v5 & 0x80;
  }
  else
  {
    v4 = sub_10042678(a1, a2, a3, 128, (int)&v7);
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFDu;
  return v4;
}

//----- (10036D7B) --------------------------------------------------------
int __usercall sub_10036D7B<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  int result; // eax@2
  wchar_t v4; // ax@2

  if ( dword_10077048 )
  {
    result = sub_10036BE5(a1, a2, a3, 0);
  }
  else
  {
    v4 = off_10074BD8[a3];
    result = v4 & 4;
  }
  return result;
}
// 10074BD8: using guessed type wchar_t *off_10074BD8;
// 10077048: using guessed type int dword_10077048;

//----- (10036DA6) --------------------------------------------------------
int __usercall sub_10036DA6<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  int result; // eax@2
  wchar_t v4; // ax@2

  if ( dword_10077048 )
  {
    result = sub_10036C35(a1, a2, a3, 0);
  }
  else
  {
    v4 = off_10074BD8[a3];
    result = v4 & 2;
  }
  return result;
}
// 10074BD8: using guessed type wchar_t *off_10074BD8;
// 10077048: using guessed type int dword_10077048;

//----- (10036DD1) --------------------------------------------------------
int __usercall sub_10036DD1<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  int result; // eax@2
  wchar_t v4; // ax@2

  if ( dword_10077048 )
  {
    result = sub_10036C85(a1, a2, a3, 0);
  }
  else
  {
    v4 = off_10074BD8[a3];
    result = v4 & 8;
  }
  return result;
}
// 10074BD8: using guessed type wchar_t *off_10074BD8;
// 10077048: using guessed type int dword_10077048;

//----- (10036DFC) --------------------------------------------------------
int __usercall sub_10036DFC<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  int result; // eax@2
  wchar_t v4; // ax@2

  if ( dword_10077048 )
  {
    result = sub_10036CD5(a1, a2, a3, 0);
  }
  else
  {
    v4 = off_10074BD8[a3];
    result = v4 & 1;
  }
  return result;
}
// 10074BD8: using guessed type wchar_t *off_10074BD8;
// 10077048: using guessed type int dword_10077048;

//----- (10036E27) --------------------------------------------------------
int __usercall sub_10036E27<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  int result; // eax@2
  wchar_t v4; // ax@2

  if ( dword_10077048 )
  {
    result = sub_10036D25(a1, a2, a3, 0);
  }
  else
  {
    v4 = off_10074BD8[a3];
    result = v4 & 0x80;
  }
  return result;
}
// 10074BD8: using guessed type wchar_t *off_10074BD8;
// 10077048: using guessed type int dword_10077048;

//----- (10036E54) --------------------------------------------------------
int __usercall sub_10036E54<eax>(int a1<ebx>, int a2)
{
  int result; // eax@2
  int v3; // eax@3
  int v4; // edx@3
  int v5; // ecx@3
  int v6; // ebx@3
  int v7; // edi@3
  int v8; // eax@3

  if ( a2 )
  {
    v8 = sub_100398B9(a2);
    v7 = v8 + 1;
    v3 = (int)sub_10049092((void *)v5, a1, v8 + 1, 2u);
    v6 = v3;
    if ( v3 )
    {
      if ( sub_100490D0(v4, v5, v3, v7, v3, v7, a2) )
      {
        sub_1003A17E(v6, v7);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_10036EA7);
      }
      result = v6;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10036EA7) --------------------------------------------------------
int __usercall sub_10036EA7<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // eax@1
  int v4; // edx@1

  v3 = sub_10041A5C(a1, a2);
  v4 = v3;
  v2 = *(_DWORD *)(v3 + 108);
  if ( (volatile LONG *)v2 != off_10074B44 )
  {
    if ( !(dword_10074C0C & *(_DWORD *)(v4 + 112)) )
      sub_10041EAE(a1, a2);
  }
  return *(_DWORD *)(v2 + 4);
}
// 10074C0C: using guessed type int dword_10074C0C;

//----- (10036ECD) --------------------------------------------------------
int __usercall sub_10036ECD<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // eax@1
  int v4; // edx@1

  v3 = sub_10041A5C(a1, a2);
  v4 = v3;
  v2 = *(_DWORD *)(v3 + 108);
  if ( (volatile LONG *)v2 != off_10074B44 )
  {
    if ( !(dword_10074C0C & *(_DWORD *)(v4 + 112)) )
      sub_10041EAE(a1, a2);
  }
  return *(_DWORD *)(v2 + 8);
}
// 10074C0C: using guessed type int dword_10074C0C;

//----- (10036EF3) --------------------------------------------------------
int __usercall sub_10036EF3<eax>(int a1<ebx>, int a2<edi>)
{
  volatile LONG *v2; // eax@1
  int v3; // eax@1
  int v4; // edx@1

  v3 = sub_10041A5C(a1, a2);
  v4 = v3;
  v2 = *(volatile LONG **)(v3 + 108);
  if ( v2 != off_10074B44 )
  {
    if ( !(dword_10074C0C & *(_DWORD *)(v4 + 112)) )
      sub_10041EAE(a1, a2);
  }
  return (int)(v2 + 40);
}
// 10074C0C: using guessed type int dword_10074C0C;

//----- (10036F1B) --------------------------------------------------------
int __usercall sub_10036F1B<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // eax@1
  int v4; // edx@1

  v3 = sub_10041A5C(a1, a2);
  v4 = v3;
  v2 = *(_DWORD *)(v3 + 108);
  if ( (volatile LONG *)v2 != off_10074B44 )
  {
    if ( !(dword_10074C0C & *(_DWORD *)(v4 + 112)) )
      sub_10041EAE(a1, a2);
  }
  return *(_DWORD *)(v2 + 116);
}
// 10074C0C: using guessed type int dword_10074C0C;

//----- (10036F41) --------------------------------------------------------
int __fastcall sub_10036F41(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // ebx@1
  int v5; // edi@2
  LPVOID v6; // ecx@4
  int v7; // ecx@4
  int v8; // ecx@4
  int v9; // ecx@4
  int v10; // ecx@4
  signed int v11; // eax@9
  UINT v12; // ST1C_4@13
  int v13; // ST04_4@13
  char *v14; // ecx@17
  int v15; // edi@17
  int v16; // eax@18
  int v17; // edx@19
  int v18; // edi@25
  int v19; // eax@25
  int v20; // ecx@25
  unsigned __int8 v21; // zf@25
  char v22; // sf@25
  unsigned __int8 v23; // of@25
  char *v24; // ecx@27
  signed int v25; // edx@29
  int v26; // edi@30
  LPVOID v27; // eax@37
  int result; // eax@39
  int v29; // [sp+8h] [bp-44h]@1
  int v30; // [sp+Ch] [bp-40h]@1
  int v31; // [sp+10h] [bp-3Ch]@25
  int v32; // [sp+14h] [bp-38h]@25
  LPCSTR lpMultiByteStr; // [sp+18h] [bp-34h]@13
  int v34; // [sp+1Ch] [bp-30h]@13
  LPVOID lpMem; // [sp+20h] [bp-2Ch]@1
  int v36; // [sp+24h] [bp-28h]@1
  LPVOID v37; // [sp+28h] [bp-24h]@1
  LPVOID v38; // [sp+2Ch] [bp-20h]@1
  LPVOID v39; // [sp+30h] [bp-1Ch]@1
  struct _cpinfo CPInfo; // [sp+34h] [bp-18h]@11
  unsigned int v41; // [sp+48h] [bp-4h]@1
  int v42; // [sp+4Ch] [bp+0h]@1

  v41 = (unsigned int)&v42 ^ __security_cookie;
  v4 = 0;
  lpMem = 0;
  v3 = *(_DWORD *)(a3 + 168);
  v38 = 0;
  v37 = 0;
  v39 = 0;
  v36 = 0;
  v29 = a3;
  v30 = 0;
  if ( v3 )
  {
    v5 = a3 + 4;
    if ( !*(_DWORD *)(a3 + 4) && sub_1003F7D4((int)&v29, 0, v3, 0x1004u, (LPVOID *)(a3 + 4)) )
      goto LABEL_45;
    lpMem = (LPVOID)sub_10037550(a2, a1, 0, 4);
    v38 = sub_10037506(v7, 0, 0x180u, 2u);
    v37 = sub_10037506(v8, 0, 0x180u, 1u);
    v39 = sub_10037506(v9, 0, 0x180u, 1u);
    v6 = sub_10037506(v10, 0, 0x101u, 1u);
    v36 = (int)v6;
    if ( !lpMem )
      goto LABEL_45;
    if ( !v38 )
      goto LABEL_45;
    if ( !v6 )
      goto LABEL_45;
    if ( !v37 )
      goto LABEL_45;
    if ( !v39 )
      goto LABEL_45;
    *(_DWORD *)lpMem = 0;
    v11 = 0;
    do
    {
      *((_BYTE *)v6 + v11) = v11;
      ++v11;
    }
    while ( v11 < 256 );
    if ( !GetCPInfo(*(_DWORD *)v5, &CPInfo) )
      goto LABEL_45;
    if ( (_DWORD)CPInfo.MaxCharSize > 5u )
      goto LABEL_45;
    v12 = *(_DWORD *)v5;
    v34 = (unsigned __int16)CPInfo.MaxCharSize;
    v13 = *(_DWORD *)(a3 + 168);
    lpMultiByteStr = (LPCSTR)(v36 + 1);
    if ( !sub_100374C2(0, v5, 0, v13, 0x100u, (LPCSTR)(v36 + 1), 255, (LPWSTR)((char *)v37 + 129), 255, v12, 0) )
      goto LABEL_45;
    if ( !sub_100374C2(
            0,
            v5,
            0,
            *(_DWORD *)(a3 + 168),
            0x200u,
            lpMultiByteStr,
            255,
            (LPWSTR)((char *)v39 + 129),
            255,
            *(_DWORD *)v5,
            0) )
      goto LABEL_45;
    if ( v34 > 1 )
    {
      if ( CPInfo.LeadByte[0] )
      {
        v15 = v36;
        v14 = (char *)&CPInfo.LeadByte[1];
        do
        {
          LOBYTE(v16) = *v14;
          if ( !*v14 )
            break;
          v17 = (unsigned __int8)*(v14 - 1);
          v16 = (unsigned __int8)v16;
          while ( v17 <= v16 )
          {
            *(_BYTE *)(v17 + v15) = 32;
            v16 = (unsigned __int8)*v14;
            ++v17;
          }
          v14 += 2;
        }
        while ( *(v14 - 1) );
        v5 = a3 + 4;
      }
    }
    if ( sub_10049218(0, v5, 0, 1u, (LPCSTR)v36, 256, (LPWORD)v38 + 128, *(_DWORD *)v5, 0) )
    {
      v18 = (int)v38;
      v19 = (int)v39;
      *((_WORD *)v38 + 127) = 0;
      v20 = (int)((char *)v37 + 128);
      *((_BYTE *)v37 + 127) = 0;
      *(_BYTE *)(v19 + 127) = 0;
      v23 = __SETO__(v34, 1);
      v21 = v34 == 1;
      v22 = v34 - 1 < 0;
      *(_BYTE *)v20 = 0;
      v31 = v20;
      v32 = v19 + 128;
      *(_BYTE *)(v19 + 128) = 0;
      if ( !((unsigned __int8)(v22 ^ v23) | v21) )
      {
        if ( CPInfo.LeadByte[0] )
        {
          v24 = (char *)&CPInfo.LeadByte[1];
          do
          {
            if ( !*v24 )
              break;
            v25 = (unsigned __int8)*(v24 - 1);
            if ( v25 <= (unsigned __int8)*v24 )
            {
              lpMultiByteStr = (LPCSTR)(v18 + 256 + 2 * v25);
              v26 = v18 + 256 + 2 * v25;
              do
              {
                *(_WORD *)v26 = -32768;
                ++v25;
                v26 += 2;
              }
              while ( v25 <= (unsigned __int8)*v24 );
              v18 = (int)v38;
            }
            v24 += 2;
          }
          while ( *(v24 - 1) );
        }
      }
      sub_10034F00((void *)v18, (const void *)(v18 + 512), 0xFEu);
      sub_10034F00(v37, (char *)v37 + 256, 0x7Fu);
      sub_10034F00(v39, (char *)v39 + 256, 0x7Fu);
      if ( *(_DWORD *)(a3 + 136) )
      {
        if ( !InterlockedDecrement(*(volatile LONG **)(a3 + 136)) )
        {
          sub_100309A2(0, (LPVOID)(*(_DWORD *)(a3 + 140) - 254));
          sub_100309A2(0, (LPVOID)(*(_DWORD *)(a3 + 148) - 128));
          sub_100309A2(0, (LPVOID)(*(_DWORD *)(a3 + 152) - 128));
          sub_100309A2(0, *(LPVOID *)(a3 + 136));
        }
      }
      v27 = lpMem;
      *(_DWORD *)lpMem = 1;
      *(_DWORD *)(a3 + 136) = v27;
      *(_DWORD *)(a3 + 144) = v18 + 256;
      *(_DWORD *)(a3 + 140) = v18 + 254;
      *(_DWORD *)(a3 + 148) = v31;
      *(_DWORD *)(a3 + 152) = v32;
      *(_DWORD *)(a3 + 116) = v34;
    }
    else
    {
LABEL_45:
      sub_100309A2(0, lpMem);
      sub_100309A2(0, v38);
      sub_100309A2(0, v37);
      sub_100309A2(0, v39);
      v4 = 1;
    }
    sub_100309A2(v4, (LPVOID)v36);
    result = v4;
  }
  else
  {
    if ( *(_DWORD *)(a3 + 136) )
      InterlockedDecrement(*(volatile LONG **)(a3 + 136));
    *(_DWORD *)(a3 + 136) = 0;
    *(_DWORD *)(a3 + 140) = 0;
    *(_DWORD *)(a3 + 144) = L"         (((((                  H";
    *(_DWORD *)(a3 + 148) = &unk_10062560;
    *(_DWORD *)(a3 + 152) = &unk_100626E0;
    *(_DWORD *)(a3 + 116) = 1;
    result = 0;
  }
  return result;
}
// 100620D8: using guessed type wchar_t asc_100620D8[33];
// 10074200: using guessed type int __security_cookie;

//----- (100372D9) --------------------------------------------------------
unsigned int __usercall sub_100372D9<eax>(int a1<ebx>, int a2, int a3, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpDestStr, int cchDest, UINT CodePage, int a10)
{
  int v10; // esi@1
  LPCSTR v11; // eax@2
  signed int v12; // ecx@2
  UINT v13; // ecx@8
  unsigned int v14; // edi@8
  unsigned int v15; // eax@10
  int v16; // ecx@10
  int v18; // ecx@14
  int v19; // ebx@15
  int v20; // eax@17
  unsigned int v21; // eax@24
  int v22; // esi@24
  unsigned int v23; // eax@31
  char *v24; // esi@32
  int v25; // eax@34
  int v26; // esi@36
  CHAR *v27; // [sp-10h] [bp-24h]@41
  int v28; // [sp-Ch] [bp-20h]@41
  char v29; // [sp+0h] [bp-14h]@15
  int cchSrc; // [sp+Ch] [bp-8h]@10
  unsigned int v31; // [sp+10h] [bp-4h]@1
  int v32; // [sp+14h] [bp+0h]@1

  v31 = (unsigned int)&v32 ^ __security_cookie;
  v10 = cbMultiByte;
  if ( cbMultiByte > 0 )
  {
    v11 = lpMultiByteStr;
    v12 = cbMultiByte;
    while ( 1 )
    {
      --v12;
      if ( !*v11 )
        break;
      ++v11;
      if ( !v12 )
      {
        v12 = -1;
        break;
      }
    }
    v10 = cbMultiByte - v12;
    if ( cbMultiByte - v12 - 1 >= cbMultiByte )
      v10 = cbMultiByte - v12 - 1;
  }
  v13 = CodePage;
  v14 = 0;
  if ( !CodePage )
  {
    CodePage = *(_DWORD *)(*(_DWORD *)a2 + 4);
    v13 = *(_DWORD *)(*(_DWORD *)a2 + 4);
  }
  v15 = MultiByteToWideChar(v13, 8 * (a10 != 0) + 1, lpMultiByteStr, v10, 0, 0);
  v16 = v15;
  cchSrc = v15;
  if ( !v15 )
    return 0;
  if ( (signed int)v15 > 0 && 0xFFFFFFE0 / v15 >= 2 )
  {
    v18 = 2 * v15 + 8;
    if ( (unsigned int)v18 > 0x400 )
    {
      v20 = sub_10030910(0xFFFFFFE0 % v15, v18, a1, 0, v18);
      v19 = v20;
      if ( v20 )
      {
        *(_DWORD *)v20 = 56797;
        goto LABEL_19;
      }
    }
    else
    {
      sub_1003F590(v18, v18, v29);
      v19 = (int)&v29;
      if ( &v29 )
      {
        *(_DWORD *)&v29 = 52428;
LABEL_19:
        v19 += 8;
        goto LABEL_20;
      }
    }
LABEL_20:
    v16 = cchSrc;
    goto LABEL_22;
  }
  v19 = 0;
LABEL_22:
  if ( !v19 )
    return 0;
  if ( MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, v10, (LPWSTR)v19, v16) )
  {
    v22 = cchSrc;
    v21 = sub_10039D33(a3, dwMapFlags, (LPCWSTR)v19, cchSrc, 0, 0);
    v14 = v21;
    if ( v21 )
    {
      if ( dwMapFlags & 0x400 )
      {
        if ( cchDest )
        {
          if ( (signed int)v21 <= cchDest )
            sub_10039D33(a3, dwMapFlags, (LPCWSTR)v19, v22, lpDestStr, cchDest);
        }
        goto LABEL_45;
      }
      if ( (signed int)v21 <= 0 || 0xFFFFFFE0 / v21 < 2 )
      {
        v26 = 0;
LABEL_38:
        if ( v26 )
        {
          if ( sub_10039D33(a3, dwMapFlags, (LPCWSTR)v19, cchSrc, (LPWSTR)v26, v14) )
          {
            if ( cchDest )
            {
              v28 = cchDest;
              v27 = (CHAR *)lpDestStr;
            }
            else
            {
              v28 = 0;
              v27 = 0;
            }
            v14 = WideCharToMultiByte(CodePage, 0, (LPCWSTR)v26, v14, v27, v28, 0, 0);
          }
          sub_1002CAA7(v19, v26);
        }
        goto LABEL_45;
      }
      v23 = 2 * v21 + 8;
      if ( v23 > 0x400 )
      {
        v25 = sub_10030910(0xFFFFFFE0 % v14, 1024, v19, v14, 2 * v14 + 8);
        v24 = (char *)v25;
        if ( v25 )
        {
          *(_DWORD *)v25 = 56797;
          goto LABEL_36;
        }
      }
      else
      {
        sub_1003F590(v23, 1024, v29);
        v24 = &v29;
        if ( &v29 )
        {
          *(_DWORD *)&v29 = 52428;
LABEL_36:
          v26 = (int)(v24 + 8);
          goto LABEL_38;
        }
      }
    }
  }
LABEL_45:
  sub_1002CAA7(v19, v19);
  return v14;
}
// 10074200: using guessed type int __security_cookie;

//----- (100374C2) --------------------------------------------------------
unsigned int __usercall sub_100374C2<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpDestStr, int cchDest, UINT CodePage, int a11)
{
  unsigned int result; // eax@1
  int v12; // [sp+0h] [bp-10h]@1
  int v13; // [sp+8h] [bp-8h]@2
  char v14; // [sp+Ch] [bp-4h]@1

  sub_1003018D((int)&v12, a1, a2, a3);
  result = sub_100372D9(a1, (int)&v12, a4, dwMapFlags, lpMultiByteStr, cbMultiByte, lpDestStr, cchDest, CodePage, a11);
  if ( v14 )
    *(_DWORD *)(v13 + 112) &= 0xFFFFFFFDu;
  return result;
}

//----- (10037506) --------------------------------------------------------
LPVOID __usercall sub_10037506<eax>(int this<ecx>, int ebx0<ebx>, unsigned int a2, unsigned int a3)
{
  int v4; // esi@1
  LPVOID v5; // edi@2

  v4 = 0;
  do
  {
    v5 = sub_100492BF((void *)this, ebx0, a2, a3, 0);
    if ( v5 )
      break;
    if ( (unsigned int)dword_10076890 <= 0 )
      break;
    Sleep(v4);
    this = v4 + 1000;
    v4 = this;
    if ( this > (unsigned int)dword_10076890 )
      v4 = -1;
  }
  while ( v4 != -1 );
  return v5;
}
// 10076890: using guessed type int dword_10076890;

//----- (10037550) --------------------------------------------------------
int __usercall sub_10037550<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int dwBytes)
{
  int v4; // edi@1
  DWORD v5; // esi@1

  v4 = dword_10076890;
  v5 = 0;
  do
  {
    a3 = sub_10030910(a1, a2, a3, v4, dwBytes);
    if ( a3 )
      break;
    if ( !v4 )
      break;
    Sleep(v5);
    v4 = dword_10076890;
    a2 = v5 + 1000;
    v5 = a2;
    if ( a2 > (unsigned int)dword_10076890 )
      v5 = -1;
  }
  while ( v5 != -1 );
  return a3;
}
// 10076890: using guessed type int dword_10076890;

//----- (10037599) --------------------------------------------------------
int __usercall sub_10037599<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, LPVOID lpMem, int dwBytes)
{
  DWORD v6; // esi@1
  int v7; // eax@2

  v6 = 0;
  do
  {
    v7 = sub_10030C36(a1, a2, a3, a4, lpMem, dwBytes);
    a4 = v7;
    if ( v7 )
      break;
    if ( !dwBytes )
      break;
    if ( dword_10076890 <= (unsigned int)v7 )
      break;
    Sleep(v6);
    v6 += 1000;
    if ( v6 > dword_10076890 )
      v6 = -1;
  }
  while ( v6 != -1 );
  return a4;
}
// 10076890: using guessed type int dword_10076890;

//----- (100375E5) --------------------------------------------------------
int __usercall sub_100375E5<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, const void *lpMem, unsigned int a5, unsigned int a6)
{
  DWORD v6; // esi@1
  int v7; // eax@2
  int v8; // edi@2

  v6 = 0;
  do
  {
    v7 = sub_10049256(a1, a2, a3, lpMem, a5, a6);
    v8 = v7;
    if ( v7 )
      break;
    if ( !a6 )
      break;
    if ( dword_10076890 <= (unsigned int)v7 )
      break;
    Sleep(v6);
    v6 += 1000;
    if ( v6 > dword_10076890 )
      v6 = -1;
  }
  while ( v6 != -1 );
  return v8;
}
// 10076890: using guessed type int dword_10076890;

//----- (10037635) --------------------------------------------------------
int __usercall sub_10037635<eax>(int a1<ebx>)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10041A74(a1);
  if ( v1 )
    result = v1 + 12;
  else
    result = (int)&unk_100741F4;
  return result;
}

//----- (10037648) --------------------------------------------------------
int __usercall sub_10037648<eax>(int a1<ebx>, int a2)
{
  int result; // eax@1
  signed int v3; // esi@1

  *(_DWORD *)sub_10037635(a1) = a2;
  v3 = sub_1003767C(a2);
  result = sub_10037669(a1);
  *(_DWORD *)result = v3;
  return result;
}

//----- (10037669) --------------------------------------------------------
int __usercall sub_10037669<eax>(int a1<ebx>)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_10041A74(a1);
  if ( v1 )
    result = v1 + 8;
  else
    result = (int)&unk_100741F0;
  return result;
}

//----- (1003767C) --------------------------------------------------------
signed int __cdecl sub_1003767C(int a1)
{
  unsigned int v1; // eax@1
  signed int result; // eax@5

  v1 = 0;
  do
  {
    if ( a1 == dword_10074088[2 * v1] )
      return dword_1007408C[2 * v1];
    ++v1;
  }
  while ( v1 < 0x2D );
  if ( (unsigned int)(a1 - 19) > 0x11 )
    result = (unsigned int)(a1 - 188) > 0xE ? 22 : 8;
  else
    result = 13;
  return result;
}
// 10074088: using guessed type int dword_10074088[];
// 1007408C: using guessed type int dword_1007408C[];

//----- (100376BD) --------------------------------------------------------
signed int __usercall sub_100376BD<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned __int8 a4, int a5, unsigned __int8 a6)
{
  signed int v6; // edx@2
  int v7; // eax@3
  int v9; // [sp+4h] [bp-10h]@1
  int v10; // [sp+8h] [bp-Ch]@1
  int v11; // [sp+Ch] [bp-8h]@8
  char v12; // [sp+10h] [bp-4h]@7

  sub_1003018D((int)&v9, a1, a2, a3);
  if ( a6 & *(_BYTE *)(v10 + a4 + 25)
    || ((v6 = 0, !a5) ? (v7 = 0) : (v7 = (unsigned __int16)(a5 & *(_WORD *)(*(_DWORD *)(v9 + 144) + 2 * a4))), v7) )
    v6 = 1;
  if ( v12 )
    *(_DWORD *)(v11 + 112) &= 0xFFFFFFFDu;
  return v6;
}

//----- (10037713) --------------------------------------------------------
signed int __usercall sub_10037713<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3)
{
  return sub_100376BD(a1, a2, 0, a3, 0, 4u);
}

//----- (10037729) --------------------------------------------------------
int __cdecl sub_10037729(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // ebx@1
  int v4; // edx@5
  int v5; // esi@6
  int v6; // eax@7
  int v7; // edi@8
  int v8; // ecx@9
  bool v9; // ecx@9
  int v10; // edi@10
  bool v11; // ecx@11
  int v12; // edi@12
  bool v13; // ecx@13
  int v14; // eax@18
  int v15; // edi@21
  bool v16; // ecx@22
  int v17; // edi@23
  bool v18; // ecx@24
  int v19; // eax@29
  int v20; // edi@32
  bool v21; // ecx@33
  int v22; // edi@34
  bool v23; // ecx@35
  int v24; // eax@40
  int v25; // edi@43
  bool v26; // ecx@44
  int v27; // edi@45
  bool v28; // ecx@46
  int v29; // edi@54
  bool v30; // ecx@55
  int v31; // edi@56
  bool v32; // ecx@57
  int v33; // eax@62
  int v34; // edi@65
  bool v35; // ecx@66
  int v36; // edi@67
  bool v37; // ecx@68
  int v38; // eax@73
  int v39; // edi@76
  bool v40; // ecx@77
  int v41; // edi@78
  bool v42; // ecx@79
  int v43; // eax@84
  int v44; // edi@87
  bool v45; // ecx@88
  int v46; // edi@89
  bool v47; // ecx@90
  int v48; // edx@96
  int v49; // esi@96
  int v50; // eax@97
  int v51; // edi@98
  bool v52; // ecx@99
  int v53; // edi@100
  bool v54; // ecx@101
  int v55; // edi@102
  bool v56; // ecx@103
  int v57; // eax@108
  int v58; // edi@109
  bool v59; // ecx@110
  int v60; // edi@111
  bool v61; // ecx@112
  int v62; // edi@113
  bool v63; // ecx@114
  int v64; // eax@119
  int v65; // edi@120
  bool v66; // ecx@121
  int v67; // edi@122
  bool v68; // ecx@123
  int v69; // edi@124
  bool v70; // ecx@125
  int v71; // eax@130
  int v72; // edi@131
  bool v73; // ecx@132
  int v74; // edi@133
  bool v75; // ecx@134
  int v76; // edi@135
  bool v77; // ecx@136
  int v78; // edi@142
  bool v79; // ecx@143
  int v80; // edi@144
  bool v81; // ecx@145
  int v82; // edi@146
  bool v83; // ecx@147
  int v84; // eax@152
  int v85; // edi@153
  bool v86; // ecx@154
  int v87; // edi@155
  bool v88; // ecx@156
  int v89; // edi@157
  bool v90; // ecx@158
  int v91; // eax@163
  int v92; // edi@164
  bool v93; // ecx@165
  int v94; // edi@166
  bool v95; // ecx@167
  int v96; // edi@168
  bool v97; // ecx@169
  int result; // eax@175
  int v99; // eax@176
  int v100; // edi@177
  bool v101; // ecx@178
  int v102; // edi@179
  bool v103; // ecx@180
  int v104; // edi@181
  bool v105; // ecx@182
  int v106; // eax@187
  int v107; // edi@188
  bool v108; // ecx@189
  int v109; // edi@190
  bool v110; // ecx@191
  int v111; // edi@192
  bool v112; // ecx@193
  int v113; // eax@198
  int v114; // edi@199
  bool v115; // ecx@200
  int v116; // edi@201
  bool v117; // ecx@202
  int v118; // edi@203
  bool v119; // ecx@204
  int v120; // eax@209
  int v121; // edi@210
  bool v122; // ecx@211
  int v123; // edi@212
  bool v124; // ecx@213
  int v125; // edi@214
  bool v126; // ecx@215
  int v127; // eax@220
  int v128; // edi@221
  bool v129; // ecx@222
  int v130; // edi@223
  bool v131; // ecx@224
  int v132; // edi@225
  bool v133; // ecx@226
  int v134; // edi@232
  bool v135; // ecx@233
  int v136; // edi@234
  bool v137; // ecx@235
  int v138; // edi@236
  bool v139; // ecx@237
  int v140; // eax@242
  int v141; // edi@243
  bool v142; // ecx@244
  int v143; // edi@245
  bool v144; // ecx@246
  int v145; // edi@247
  bool v146; // ecx@248
  int v147; // eax@255
  int v148; // edi@256
  bool v149; // ecx@257
  int v150; // edi@258
  bool v151; // ecx@259
  int v152; // edi@260
  bool v153; // ecx@261
  int v154; // eax@266
  int v155; // edi@267
  bool v156; // ecx@268
  int v157; // edi@269
  bool v158; // ecx@270
  int v159; // edi@271
  bool v160; // ecx@272
  int v161; // eax@277
  int v162; // edi@278
  bool v163; // ecx@279
  int v164; // edi@280
  bool v165; // ecx@281
  int v166; // edi@282
  bool v167; // ecx@283
  int v168; // eax@288
  int v169; // edi@289
  bool v170; // ecx@290
  int v171; // edi@291
  bool v172; // ecx@292
  int v173; // edi@293
  bool v174; // ecx@294
  int v175; // eax@299
  int v176; // edi@300
  bool v177; // ecx@301
  int v178; // edi@302
  bool v179; // ecx@303
  int v180; // edi@304
  bool v181; // ecx@305
  int v182; // edi@311
  bool v183; // ecx@312
  int v184; // edi@313
  bool v185; // ecx@314
  int v186; // edi@315
  bool v187; // ecx@316
  int v188; // eax@321
  int v189; // edi@322
  bool v190; // ecx@323
  int v191; // edi@324
  bool v192; // ecx@325
  int v193; // edi@326
  bool v194; // ecx@327
  int v195; // eax@334
  int v196; // edi@335
  bool v197; // ecx@336
  int v198; // edi@337
  bool v199; // ecx@338
  int v200; // edi@339
  bool v201; // ecx@340
  int v202; // eax@345
  int v203; // edi@346
  bool v204; // ecx@347
  int v205; // edi@348
  bool v206; // ecx@349
  int v207; // edi@350
  bool v208; // ecx@351
  int v209; // eax@356
  int v210; // edi@357
  bool v211; // ecx@358
  int v212; // edi@359
  bool v213; // ecx@360
  int v214; // edi@361
  bool v215; // ecx@362
  int v216; // eax@367
  int v217; // edi@368
  bool v218; // ecx@369
  int v219; // edi@370
  bool v220; // ecx@371
  int v221; // edi@372
  bool v222; // ecx@373
  int v223; // edi@379
  bool v224; // ecx@380
  int v225; // edi@381
  bool v226; // ecx@382
  int v227; // edi@383
  bool v228; // ecx@384
  int v229; // eax@389
  int v230; // edi@390
  bool v231; // ecx@391
  int v232; // edi@392
  bool v233; // ecx@393
  int v234; // edi@394
  bool v235; // ecx@395
  int v236; // eax@400
  int v237; // edi@401
  bool v238; // ecx@402
  int v239; // edi@403
  bool v240; // ecx@404
  int v241; // edi@405
  bool v242; // ecx@406
  int v243; // edi@411
  bool v244; // ecx@412
  int v245; // edi@413
  bool v246; // ecx@414
  int v247; // esi@415
  bool v248; // eax@416
  int v249; // esi@417
  bool v250; // eax@418
  int v251; // esi@419
  bool v252; // eax@420
  int v253; // eax@421
  int v254; // ecx@421
  int v255; // ecx@422
  int v256; // ecx@425
  bool v257; // eax@426
  int v258; // ecx@427
  bool v259; // eax@428
  int v260; // ecx@430
  bool v261; // eax@431

  v3 = a3;
  if ( !a3 )
    return 0;
  if ( a3 == 1 )
  {
    v254 = *(_BYTE *)a1;
    v253 = *(_BYTE *)a2;
    goto LABEL_422;
  }
  if ( a3 == 2 )
  {
    v260 = *(_BYTE *)a1 - *(_BYTE *)a2;
    if ( *(_BYTE *)a1 != *(_BYTE *)a2 )
    {
      v261 = v260 < 0;
      LOBYTE(v261) = v260 > 0;
      result = 2 * v261 - 1;
      if ( result )
        return result;
    }
    v254 = *(_BYTE *)(a1 + 1);
    v253 = *(_BYTE *)(a2 + 1);
LABEL_422:
    v255 = v254 - v253;
    if ( v255 )
      v255 = 2 * (v255 > 0) - 1;
    return v255;
  }
  if ( a3 == 3 )
  {
    v256 = *(_BYTE *)a1 - *(_BYTE *)a2;
    if ( *(_BYTE *)a1 != *(_BYTE *)a2 && (v257 = v256 < 0, LOBYTE(v257) = v256 > 0, (result = 2 * v257 - 1) != 0)
      || (v258 = *(_BYTE *)(a1 + 1) - *(_BYTE *)(a2 + 1), *(_BYTE *)(a1 + 1) != *(_BYTE *)(a2 + 1))
      && (v259 = v258 < 0, LOBYTE(v259) = v258 > 0, (result = 2 * v259 - 1) != 0) )
      return result;
    v254 = *(_BYTE *)(a1 + 2);
    v253 = *(_BYTE *)(a2 + 2);
    goto LABEL_422;
  }
  v4 = a2;
  if ( a3 == 4 )
  {
    v247 = *(_BYTE *)a1 - *(_BYTE *)a2;
    if ( *(_BYTE *)a1 != *(_BYTE *)a2 && (v248 = v247 < 0, LOBYTE(v248) = v247 > 0, (result = 2 * v248 - 1) != 0)
      || (v249 = *(_BYTE *)(a1 + 1) - *(_BYTE *)(a2 + 1), *(_BYTE *)(a1 + 1) != *(_BYTE *)(a2 + 1))
      && (v250 = v249 < 0, LOBYTE(v250) = v249 > 0, (result = 2 * v250 - 1) != 0)
      || (v251 = *(_BYTE *)(a1 + 2) - *(_BYTE *)(a2 + 2), *(_BYTE *)(a1 + 2) != *(_BYTE *)(a2 + 2))
      && (v252 = v251 < 0, LOBYTE(v252) = v251 > 0, (result = 2 * v252 - 1) != 0) )
      return result;
    v254 = *(_BYTE *)(a1 + 3);
    v253 = *(_BYTE *)(a2 + 3);
    goto LABEL_422;
  }
  v5 = a1;
  if ( a3 >= 0x20 )
  {
    do
    {
      v6 = *(_DWORD *)v5;
      if ( *(_DWORD *)v5 == *(_DWORD *)v4 )
      {
        v8 = 0;
      }
      else
      {
        v7 = (unsigned __int8)v6 - *(_BYTE *)v4;
        if ( (unsigned __int8)v6 != *(_BYTE *)v4 && (v9 = v7 < 0, LOBYTE(v9) = v7 > 0, (v8 = 2 * v9 - 1) != 0)
          || (v10 = *(_BYTE *)(v5 + 1) - *(_BYTE *)(v4 + 1), *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1))
          && (v11 = v10 < 0, LOBYTE(v11) = v10 > 0, (v8 = 2 * v11 - 1) != 0)
          || (v12 = *(_BYTE *)(v5 + 2) - *(_BYTE *)(v4 + 2), *(_BYTE *)(v5 + 2) != *(_BYTE *)(v4 + 2))
          && (v13 = v12 < 0, LOBYTE(v13) = v12 > 0, (v8 = 2 * v13 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 3) - *(_BYTE *)(v4 + 3);
        if ( *(_BYTE *)(v5 + 3) != *(_BYTE *)(v4 + 3) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v14 = *(_DWORD *)(v5 + 4);
      if ( v14 == *(_DWORD *)(v4 + 4) )
      {
        v8 = 0;
      }
      else
      {
        if ( (unsigned __int8)v14 != *(_BYTE *)(v4 + 4)
          && (LOBYTE(v8) = (unsigned __int8)v14 - *(_BYTE *)(v4 + 4) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v15 = *(_BYTE *)(v5 + 5) - *(_BYTE *)(v4 + 5), *(_BYTE *)(v5 + 5) != *(_BYTE *)(v4 + 5))
          && (v16 = v15 < 0, LOBYTE(v16) = v15 > 0, (v8 = 2 * v16 - 1) != 0)
          || (v17 = *(_BYTE *)(v5 + 6) - *(_BYTE *)(v4 + 6), *(_BYTE *)(v5 + 6) != *(_BYTE *)(v4 + 6))
          && (v18 = v17 < 0, LOBYTE(v18) = v17 > 0, (v8 = 2 * v18 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 7) - *(_BYTE *)(v4 + 7);
        if ( *(_BYTE *)(v5 + 7) != *(_BYTE *)(v4 + 7) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v19 = *(_DWORD *)(v5 + 8);
      if ( v19 == *(_DWORD *)(v4 + 8) )
      {
        v8 = 0;
      }
      else
      {
        if ( (unsigned __int8)v19 != *(_BYTE *)(v4 + 8)
          && (LOBYTE(v8) = (unsigned __int8)v19 - *(_BYTE *)(v4 + 8) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v20 = *(_BYTE *)(v5 + 9) - *(_BYTE *)(v4 + 9), *(_BYTE *)(v5 + 9) != *(_BYTE *)(v4 + 9))
          && (v21 = v20 < 0, LOBYTE(v21) = v20 > 0, (v8 = 2 * v21 - 1) != 0)
          || (v22 = *(_BYTE *)(v5 + 10) - *(_BYTE *)(v4 + 10), *(_BYTE *)(v5 + 10) != *(_BYTE *)(v4 + 10))
          && (v23 = v22 < 0, LOBYTE(v23) = v22 > 0, (v8 = 2 * v23 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 11) - *(_BYTE *)(v4 + 11);
        if ( *(_BYTE *)(v5 + 11) != *(_BYTE *)(v4 + 11) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v24 = *(_DWORD *)(v5 + 12);
      if ( v24 == *(_DWORD *)(v4 + 12) )
      {
        v8 = 0;
      }
      else
      {
        if ( (unsigned __int8)v24 != *(_BYTE *)(v4 + 12)
          && (LOBYTE(v8) = (unsigned __int8)v24 - *(_BYTE *)(v4 + 12) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v25 = *(_BYTE *)(v5 + 13) - *(_BYTE *)(v4 + 13), *(_BYTE *)(v5 + 13) != *(_BYTE *)(v4 + 13))
          && (v26 = v25 < 0, LOBYTE(v26) = v25 > 0, (v8 = 2 * v26 - 1) != 0)
          || (v27 = *(_BYTE *)(v5 + 14) - *(_BYTE *)(v4 + 14), *(_BYTE *)(v5 + 14) != *(_BYTE *)(v4 + 14))
          && (v28 = v27 < 0, LOBYTE(v28) = v27 > 0, (v8 = 2 * v28 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 15) - *(_BYTE *)(v4 + 15);
        if ( *(_BYTE *)(v5 + 15) != *(_BYTE *)(v4 + 15) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      if ( *(_DWORD *)(v5 + 16) == *(_DWORD *)(v4 + 16) )
      {
        v8 = 0;
      }
      else
      {
        if ( *(_BYTE *)(v5 + 16) != *(_BYTE *)(v4 + 16)
          && (LOBYTE(v8) = *(_BYTE *)(v5 + 16) - *(_BYTE *)(v4 + 16) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v29 = *(_BYTE *)(v5 + 17) - *(_BYTE *)(v4 + 17), *(_BYTE *)(v5 + 17) != *(_BYTE *)(v4 + 17))
          && (v30 = v29 < 0, LOBYTE(v30) = v29 > 0, (v8 = 2 * v30 - 1) != 0)
          || (v31 = *(_BYTE *)(v5 + 18) - *(_BYTE *)(v4 + 18), *(_BYTE *)(v5 + 18) != *(_BYTE *)(v4 + 18))
          && (v32 = v31 < 0, LOBYTE(v32) = v31 > 0, (v8 = 2 * v32 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 19) - *(_BYTE *)(v4 + 19);
        if ( *(_BYTE *)(v5 + 19) != *(_BYTE *)(v4 + 19) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v33 = *(_DWORD *)(v5 + 20);
      if ( v33 == *(_DWORD *)(v4 + 20) )
      {
        v8 = 0;
      }
      else
      {
        if ( (unsigned __int8)v33 != *(_BYTE *)(v4 + 20)
          && (LOBYTE(v8) = (unsigned __int8)v33 - *(_BYTE *)(v4 + 20) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v34 = *(_BYTE *)(v5 + 21) - *(_BYTE *)(v4 + 21), *(_BYTE *)(v5 + 21) != *(_BYTE *)(v4 + 21))
          && (v35 = v34 < 0, LOBYTE(v35) = v34 > 0, (v8 = 2 * v35 - 1) != 0)
          || (v36 = *(_BYTE *)(v5 + 22) - *(_BYTE *)(v4 + 22), *(_BYTE *)(v5 + 22) != *(_BYTE *)(v4 + 22))
          && (v37 = v36 < 0, LOBYTE(v37) = v36 > 0, (v8 = 2 * v37 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 23) - *(_BYTE *)(v4 + 23);
        if ( *(_BYTE *)(v5 + 23) != *(_BYTE *)(v4 + 23) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v38 = *(_DWORD *)(v5 + 24);
      if ( v38 == *(_DWORD *)(v4 + 24) )
      {
        v8 = 0;
      }
      else
      {
        if ( (unsigned __int8)v38 != *(_BYTE *)(v4 + 24)
          && (LOBYTE(v8) = (unsigned __int8)v38 - *(_BYTE *)(v4 + 24) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v39 = *(_BYTE *)(v5 + 25) - *(_BYTE *)(v4 + 25), *(_BYTE *)(v5 + 25) != *(_BYTE *)(v4 + 25))
          && (v40 = v39 < 0, LOBYTE(v40) = v39 > 0, (v8 = 2 * v40 - 1) != 0)
          || (v41 = *(_BYTE *)(v5 + 26) - *(_BYTE *)(v4 + 26), *(_BYTE *)(v5 + 26) != *(_BYTE *)(v4 + 26))
          && (v42 = v41 < 0, LOBYTE(v42) = v41 > 0, (v8 = 2 * v42 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 27) - *(_BYTE *)(v4 + 27);
        if ( *(_BYTE *)(v5 + 27) != *(_BYTE *)(v4 + 27) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v43 = *(_DWORD *)(v5 + 28);
      if ( v43 == *(_DWORD *)(v4 + 28) )
      {
        v8 = 0;
      }
      else
      {
        if ( (unsigned __int8)v43 != *(_BYTE *)(v4 + 28)
          && (LOBYTE(v8) = (unsigned __int8)v43 - *(_BYTE *)(v4 + 28) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v44 = *(_BYTE *)(v5 + 29) - *(_BYTE *)(v4 + 29), *(_BYTE *)(v5 + 29) != *(_BYTE *)(v4 + 29))
          && (v45 = v44 < 0, LOBYTE(v45) = v44 > 0, (v8 = 2 * v45 - 1) != 0)
          || (v46 = *(_BYTE *)(v5 + 30) - *(_BYTE *)(v4 + 30), *(_BYTE *)(v5 + 30) != *(_BYTE *)(v4 + 30))
          && (v47 = v46 < 0, LOBYTE(v47) = v46 > 0, (v8 = 2 * v47 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 31) - *(_BYTE *)(v4 + 31);
        if ( *(_BYTE *)(v5 + 31) != *(_BYTE *)(v4 + 31) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v3 -= 32;
      v5 += 32;
      v4 += 32;
    }
    while ( v3 >= 0x20 );
  }
  v49 = v3 + v5;
  v48 = v3 + v4;
  switch ( v3 )
  {
    case 0x1Cu:
      v50 = *(_DWORD *)(v49 - 28);
      if ( v50 == *(_DWORD *)(v48 - 28) )
      {
        v8 = 0;
      }
      else
      {
        v51 = (unsigned __int8)v50 - *(_BYTE *)(v48 - 28);
        if ( (unsigned __int8)v50 != *(_BYTE *)(v48 - 28)
          && (v52 = v51 < 0, LOBYTE(v52) = v51 > 0, (v8 = 2 * v52 - 1) != 0)
          || (v53 = *(_BYTE *)(v49 - 27) - *(_BYTE *)(v48 - 27), *(_BYTE *)(v49 - 27) != *(_BYTE *)(v48 - 27))
          && (v54 = v53 < 0, LOBYTE(v54) = v53 > 0, (v8 = 2 * v54 - 1) != 0)
          || (v55 = *(_BYTE *)(v49 - 26) - *(_BYTE *)(v48 - 26), *(_BYTE *)(v49 - 26) != *(_BYTE *)(v48 - 26))
          && (v56 = v55 < 0, LOBYTE(v56) = v55 > 0, (v8 = 2 * v56 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 25) - *(_BYTE *)(v48 - 25);
        if ( *(_BYTE *)(v49 - 25) != *(_BYTE *)(v48 - 25) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        goto LABEL_108;
      return v8;
    case 0x18u:
LABEL_108:
      v57 = *(_DWORD *)(v49 - 24);
      if ( v57 == *(_DWORD *)(v48 - 24) )
      {
        v8 = 0;
      }
      else
      {
        v58 = (unsigned __int8)v57 - *(_BYTE *)(v48 - 24);
        if ( (unsigned __int8)v57 != *(_BYTE *)(v48 - 24)
          && (v59 = v58 < 0, LOBYTE(v59) = v58 > 0, (v8 = 2 * v59 - 1) != 0)
          || (v60 = *(_BYTE *)(v49 - 23) - *(_BYTE *)(v48 - 23), *(_BYTE *)(v49 - 23) != *(_BYTE *)(v48 - 23))
          && (v61 = v60 < 0, LOBYTE(v61) = v60 > 0, (v8 = 2 * v61 - 1) != 0)
          || (v62 = *(_BYTE *)(v49 - 22) - *(_BYTE *)(v48 - 22), *(_BYTE *)(v49 - 22) != *(_BYTE *)(v48 - 22))
          && (v63 = v62 < 0, LOBYTE(v63) = v62 > 0, (v8 = 2 * v63 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 21) - *(_BYTE *)(v48 - 21);
        if ( *(_BYTE *)(v49 - 21) != *(_BYTE *)(v48 - 21) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        goto LABEL_119;
      return v8;
    case 0x14u:
LABEL_119:
      v64 = *(_DWORD *)(v49 - 20);
      if ( v64 == *(_DWORD *)(v48 - 20) )
      {
        v8 = 0;
      }
      else
      {
        v65 = (unsigned __int8)v64 - *(_BYTE *)(v48 - 20);
        if ( (unsigned __int8)v64 != *(_BYTE *)(v48 - 20)
          && (v66 = v65 < 0, LOBYTE(v66) = v65 > 0, (v8 = 2 * v66 - 1) != 0)
          || (v67 = *(_BYTE *)(v49 - 19) - *(_BYTE *)(v48 - 19), *(_BYTE *)(v49 - 19) != *(_BYTE *)(v48 - 19))
          && (v68 = v67 < 0, LOBYTE(v68) = v67 > 0, (v8 = 2 * v68 - 1) != 0)
          || (v69 = *(_BYTE *)(v49 - 18) - *(_BYTE *)(v48 - 18), *(_BYTE *)(v49 - 18) != *(_BYTE *)(v48 - 18))
          && (v70 = v69 < 0, LOBYTE(v70) = v69 > 0, (v8 = 2 * v70 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 17) - *(_BYTE *)(v48 - 17);
        if ( *(_BYTE *)(v49 - 17) != *(_BYTE *)(v48 - 17) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        goto LABEL_130;
      return v8;
    case 0x10u:
LABEL_130:
      v71 = *(_DWORD *)(v49 - 16);
      if ( v71 == *(_DWORD *)(v48 - 16) )
      {
        v8 = 0;
      }
      else
      {
        v72 = (unsigned __int8)v71 - *(_BYTE *)(v48 - 16);
        if ( (unsigned __int8)v71 != *(_BYTE *)(v48 - 16)
          && (v73 = v72 < 0, LOBYTE(v73) = v72 > 0, (v8 = 2 * v73 - 1) != 0)
          || (v74 = *(_BYTE *)(v49 - 15) - *(_BYTE *)(v48 - 15), *(_BYTE *)(v49 - 15) != *(_BYTE *)(v48 - 15))
          && (v75 = v74 < 0, LOBYTE(v75) = v74 > 0, (v8 = 2 * v75 - 1) != 0)
          || (v76 = *(_BYTE *)(v49 - 14) - *(_BYTE *)(v48 - 14), *(_BYTE *)(v49 - 14) != *(_BYTE *)(v48 - 14))
          && (v77 = v76 < 0, LOBYTE(v77) = v76 > 0, (v8 = 2 * v77 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 13) - *(_BYTE *)(v48 - 13);
        if ( *(_BYTE *)(v49 - 13) != *(_BYTE *)(v48 - 13) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        goto LABEL_141;
      return v8;
    case 0xCu:
LABEL_141:
      if ( *(_DWORD *)(v49 - 12) == *(_DWORD *)(v48 - 12) )
      {
        v8 = 0;
      }
      else
      {
        v78 = *(_BYTE *)(v49 - 12) - *(_BYTE *)(v48 - 12);
        if ( *(_BYTE *)(v49 - 12) != *(_BYTE *)(v48 - 12)
          && (v79 = v78 < 0, LOBYTE(v79) = v78 > 0, (v8 = 2 * v79 - 1) != 0)
          || (v80 = *(_BYTE *)(v49 - 11) - *(_BYTE *)(v48 - 11), *(_BYTE *)(v49 - 11) != *(_BYTE *)(v48 - 11))
          && (v81 = v80 < 0, LOBYTE(v81) = v80 > 0, (v8 = 2 * v81 - 1) != 0)
          || (v82 = *(_BYTE *)(v49 - 10) - *(_BYTE *)(v48 - 10), *(_BYTE *)(v49 - 10) != *(_BYTE *)(v48 - 10))
          && (v83 = v82 < 0, LOBYTE(v83) = v82 > 0, (v8 = 2 * v83 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 9) - *(_BYTE *)(v48 - 9);
        if ( *(_BYTE *)(v49 - 9) != *(_BYTE *)(v48 - 9) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        goto LABEL_152;
      return v8;
    case 8u:
LABEL_152:
      v84 = *(_DWORD *)(v49 - 8);
      if ( v84 == *(_DWORD *)(v48 - 8) )
      {
        v8 = 0;
      }
      else
      {
        v85 = (unsigned __int8)v84 - *(_BYTE *)(v48 - 8);
        if ( (unsigned __int8)v84 != *(_BYTE *)(v48 - 8)
          && (v86 = v85 < 0, LOBYTE(v86) = v85 > 0, (v8 = 2 * v86 - 1) != 0)
          || (v87 = *(_BYTE *)(v49 - 7) - *(_BYTE *)(v48 - 7), *(_BYTE *)(v49 - 7) != *(_BYTE *)(v48 - 7))
          && (v88 = v87 < 0, LOBYTE(v88) = v87 > 0, (v8 = 2 * v88 - 1) != 0)
          || (v89 = *(_BYTE *)(v49 - 6) - *(_BYTE *)(v48 - 6), *(_BYTE *)(v49 - 6) != *(_BYTE *)(v48 - 6))
          && (v90 = v89 < 0, LOBYTE(v90) = v89 > 0, (v8 = 2 * v90 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 5) - *(_BYTE *)(v48 - 5);
        if ( *(_BYTE *)(v49 - 5) != *(_BYTE *)(v48 - 5) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        goto LABEL_163;
      return v8;
    case 4u:
LABEL_163:
      v91 = *(_DWORD *)(v49 - 4);
      if ( v91 == *(_DWORD *)(v48 - 4) )
      {
        v8 = 0;
      }
      else
      {
        v92 = (unsigned __int8)v91 - *(_BYTE *)(v48 - 4);
        if ( (unsigned __int8)v91 != *(_BYTE *)(v48 - 4)
          && (v93 = v92 < 0, LOBYTE(v93) = v92 > 0, (v8 = 2 * v93 - 1) != 0)
          || (v94 = *(_BYTE *)(v49 - 3) - *(_BYTE *)(v48 - 3), *(_BYTE *)(v49 - 3) != *(_BYTE *)(v48 - 3))
          && (v95 = v94 < 0, LOBYTE(v95) = v94 > 0, (v8 = 2 * v95 - 1) != 0)
          || (v96 = *(_BYTE *)(v49 - 2) - *(_BYTE *)(v48 - 2), *(_BYTE *)(v49 - 2) != *(_BYTE *)(v48 - 2))
          && (v97 = v96 < 0, LOBYTE(v97) = v96 > 0, (v8 = 2 * v97 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 1) - *(_BYTE *)(v48 - 1);
        if ( *(_BYTE *)(v49 - 1) != *(_BYTE *)(v48 - 1) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        return 0;
      return v8;
    default:
      return 0;
    case 0x1Du:
      v99 = *(_DWORD *)(v49 - 29);
      if ( v99 == *(_DWORD *)(v48 - 29) )
      {
        v8 = 0;
      }
      else
      {
        v100 = (unsigned __int8)v99 - *(_BYTE *)(v48 - 29);
        if ( (unsigned __int8)v99 != *(_BYTE *)(v48 - 29)
          && (v101 = v100 < 0, LOBYTE(v101) = v100 > 0, (v8 = 2 * v101 - 1) != 0)
          || (v102 = *(_BYTE *)(v49 - 28) - *(_BYTE *)(v48 - 28), *(_BYTE *)(v49 - 28) != *(_BYTE *)(v48 - 28))
          && (v103 = v102 < 0, LOBYTE(v103) = v102 > 0, (v8 = 2 * v103 - 1) != 0)
          || (v104 = *(_BYTE *)(v49 - 27) - *(_BYTE *)(v48 - 27), *(_BYTE *)(v49 - 27) != *(_BYTE *)(v48 - 27))
          && (v105 = v104 < 0, LOBYTE(v105) = v104 > 0, (v8 = 2 * v105 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 26) - *(_BYTE *)(v48 - 26);
        if ( *(_BYTE *)(v49 - 26) != *(_BYTE *)(v48 - 26) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_187:
      v106 = *(_DWORD *)(v49 - 25);
      if ( v106 == *(_DWORD *)(v48 - 25) )
      {
        v8 = 0;
      }
      else
      {
        v107 = (unsigned __int8)v106 - *(_BYTE *)(v48 - 25);
        if ( (unsigned __int8)v106 != *(_BYTE *)(v48 - 25)
          && (v108 = v107 < 0, LOBYTE(v108) = v107 > 0, (v8 = 2 * v108 - 1) != 0)
          || (v109 = *(_BYTE *)(v49 - 24) - *(_BYTE *)(v48 - 24), *(_BYTE *)(v49 - 24) != *(_BYTE *)(v48 - 24))
          && (v110 = v109 < 0, LOBYTE(v110) = v109 > 0, (v8 = 2 * v110 - 1) != 0)
          || (v111 = *(_BYTE *)(v49 - 23) - *(_BYTE *)(v48 - 23), *(_BYTE *)(v49 - 23) != *(_BYTE *)(v48 - 23))
          && (v112 = v111 < 0, LOBYTE(v112) = v111 > 0, (v8 = 2 * v112 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 22) - *(_BYTE *)(v48 - 22);
        if ( *(_BYTE *)(v49 - 22) != *(_BYTE *)(v48 - 22) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_198:
      v113 = *(_DWORD *)(v49 - 21);
      if ( v113 == *(_DWORD *)(v48 - 21) )
      {
        v8 = 0;
      }
      else
      {
        v114 = (unsigned __int8)v113 - *(_BYTE *)(v48 - 21);
        if ( (unsigned __int8)v113 != *(_BYTE *)(v48 - 21)
          && (v115 = v114 < 0, LOBYTE(v115) = v114 > 0, (v8 = 2 * v115 - 1) != 0)
          || (v116 = *(_BYTE *)(v49 - 20) - *(_BYTE *)(v48 - 20), *(_BYTE *)(v49 - 20) != *(_BYTE *)(v48 - 20))
          && (v117 = v116 < 0, LOBYTE(v117) = v116 > 0, (v8 = 2 * v117 - 1) != 0)
          || (v118 = *(_BYTE *)(v49 - 19) - *(_BYTE *)(v48 - 19), *(_BYTE *)(v49 - 19) != *(_BYTE *)(v48 - 19))
          && (v119 = v118 < 0, LOBYTE(v119) = v118 > 0, (v8 = 2 * v119 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 18) - *(_BYTE *)(v48 - 18);
        if ( *(_BYTE *)(v49 - 18) != *(_BYTE *)(v48 - 18) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_209:
      v120 = *(_DWORD *)(v49 - 17);
      if ( v120 == *(_DWORD *)(v48 - 17) )
      {
        v8 = 0;
      }
      else
      {
        v121 = (unsigned __int8)v120 - *(_BYTE *)(v48 - 17);
        if ( (unsigned __int8)v120 != *(_BYTE *)(v48 - 17)
          && (v122 = v121 < 0, LOBYTE(v122) = v121 > 0, (v8 = 2 * v122 - 1) != 0)
          || (v123 = *(_BYTE *)(v49 - 16) - *(_BYTE *)(v48 - 16), *(_BYTE *)(v49 - 16) != *(_BYTE *)(v48 - 16))
          && (v124 = v123 < 0, LOBYTE(v124) = v123 > 0, (v8 = 2 * v124 - 1) != 0)
          || (v125 = *(_BYTE *)(v49 - 15) - *(_BYTE *)(v48 - 15), *(_BYTE *)(v49 - 15) != *(_BYTE *)(v48 - 15))
          && (v126 = v125 < 0, LOBYTE(v126) = v125 > 0, (v8 = 2 * v126 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 14) - *(_BYTE *)(v48 - 14);
        if ( *(_BYTE *)(v49 - 14) != *(_BYTE *)(v48 - 14) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_220:
      v127 = *(_DWORD *)(v49 - 13);
      if ( v127 == *(_DWORD *)(v48 - 13) )
      {
        v8 = 0;
      }
      else
      {
        v128 = (unsigned __int8)v127 - *(_BYTE *)(v48 - 13);
        if ( (unsigned __int8)v127 != *(_BYTE *)(v48 - 13)
          && (v129 = v128 < 0, LOBYTE(v129) = v128 > 0, (v8 = 2 * v129 - 1) != 0)
          || (v130 = *(_BYTE *)(v49 - 12) - *(_BYTE *)(v48 - 12), *(_BYTE *)(v49 - 12) != *(_BYTE *)(v48 - 12))
          && (v131 = v130 < 0, LOBYTE(v131) = v130 > 0, (v8 = 2 * v131 - 1) != 0)
          || (v132 = *(_BYTE *)(v49 - 11) - *(_BYTE *)(v48 - 11), *(_BYTE *)(v49 - 11) != *(_BYTE *)(v48 - 11))
          && (v133 = v132 < 0, LOBYTE(v133) = v132 > 0, (v8 = 2 * v133 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 10) - *(_BYTE *)(v48 - 10);
        if ( *(_BYTE *)(v49 - 10) != *(_BYTE *)(v48 - 10) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_231:
      if ( *(_DWORD *)(v49 - 9) == *(_DWORD *)(v48 - 9) )
      {
        v8 = 0;
      }
      else
      {
        v134 = *(_BYTE *)(v49 - 9) - *(_BYTE *)(v48 - 9);
        if ( *(_BYTE *)(v49 - 9) != *(_BYTE *)(v48 - 9)
          && (v135 = v134 < 0, LOBYTE(v135) = v134 > 0, (v8 = 2 * v135 - 1) != 0)
          || (v136 = *(_BYTE *)(v49 - 8) - *(_BYTE *)(v48 - 8), *(_BYTE *)(v49 - 8) != *(_BYTE *)(v48 - 8))
          && (v137 = v136 < 0, LOBYTE(v137) = v136 > 0, (v8 = 2 * v137 - 1) != 0)
          || (v138 = *(_BYTE *)(v49 - 7) - *(_BYTE *)(v48 - 7), *(_BYTE *)(v49 - 7) != *(_BYTE *)(v48 - 7))
          && (v139 = v138 < 0, LOBYTE(v139) = v138 > 0, (v8 = 2 * v139 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 6) - *(_BYTE *)(v48 - 6);
        if ( *(_BYTE *)(v49 - 6) != *(_BYTE *)(v48 - 6) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_242:
      v140 = *(_DWORD *)(v49 - 5);
      if ( v140 == *(_DWORD *)(v48 - 5) )
      {
        v8 = 0;
        goto LABEL_252;
      }
      v141 = (unsigned __int8)v140 - *(_BYTE *)(v48 - 5);
      if ( (unsigned __int8)v140 == *(_BYTE *)(v48 - 5)
        || (v142 = v141 < 0, LOBYTE(v142) = v141 > 0, v8 = 2 * v142 - 1, !v8) )
      {
        v143 = *(_BYTE *)(v49 - 4) - *(_BYTE *)(v48 - 4);
        if ( *(_BYTE *)(v49 - 4) == *(_BYTE *)(v48 - 4)
          || (v144 = v143 < 0, LOBYTE(v144) = v143 > 0, v8 = 2 * v144 - 1, !v8) )
        {
          v145 = *(_BYTE *)(v49 - 3) - *(_BYTE *)(v48 - 3);
          if ( *(_BYTE *)(v49 - 3) == *(_BYTE *)(v48 - 3)
            || (v146 = v145 < 0, LOBYTE(v146) = v145 > 0, v8 = 2 * v146 - 1, !v8) )
          {
            v8 = *(_BYTE *)(v49 - 2) - *(_BYTE *)(v48 - 2);
            if ( *(_BYTE *)(v49 - 2) != *(_BYTE *)(v48 - 2) )
              v8 = 2 * (v8 > 0) - 1;
            goto LABEL_252;
          }
        }
      }
      return v8;
    case 0x19u:
      goto LABEL_187;
    case 0x15u:
      goto LABEL_198;
    case 0x11u:
      goto LABEL_209;
    case 0xDu:
      goto LABEL_220;
    case 9u:
      goto LABEL_231;
    case 5u:
      goto LABEL_242;
    case 1u:
      goto LABEL_253;
    case 0x1Eu:
      v147 = *(_DWORD *)(v49 - 30);
      if ( v147 == *(_DWORD *)(v48 - 30) )
      {
        v8 = 0;
      }
      else
      {
        v148 = (unsigned __int8)v147 - *(_BYTE *)(v48 - 30);
        if ( (unsigned __int8)v147 != *(_BYTE *)(v48 - 30)
          && (v149 = v148 < 0, LOBYTE(v149) = v148 > 0, (v8 = 2 * v149 - 1) != 0)
          || (v150 = *(_BYTE *)(v49 - 29) - *(_BYTE *)(v48 - 29), *(_BYTE *)(v49 - 29) != *(_BYTE *)(v48 - 29))
          && (v151 = v150 < 0, LOBYTE(v151) = v150 > 0, (v8 = 2 * v151 - 1) != 0)
          || (v152 = *(_BYTE *)(v49 - 28) - *(_BYTE *)(v48 - 28), *(_BYTE *)(v49 - 28) != *(_BYTE *)(v48 - 28))
          && (v153 = v152 < 0, LOBYTE(v153) = v152 > 0, (v8 = 2 * v153 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 27) - *(_BYTE *)(v48 - 27);
        if ( *(_BYTE *)(v49 - 27) != *(_BYTE *)(v48 - 27) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_266:
      v154 = *(_DWORD *)(v49 - 26);
      if ( v154 == *(_DWORD *)(v48 - 26) )
      {
        v8 = 0;
      }
      else
      {
        v155 = (unsigned __int8)v154 - *(_BYTE *)(v48 - 26);
        if ( (unsigned __int8)v154 != *(_BYTE *)(v48 - 26)
          && (v156 = v155 < 0, LOBYTE(v156) = v155 > 0, (v8 = 2 * v156 - 1) != 0)
          || (v157 = *(_BYTE *)(v49 - 25) - *(_BYTE *)(v48 - 25), *(_BYTE *)(v49 - 25) != *(_BYTE *)(v48 - 25))
          && (v158 = v157 < 0, LOBYTE(v158) = v157 > 0, (v8 = 2 * v158 - 1) != 0)
          || (v159 = *(_BYTE *)(v49 - 24) - *(_BYTE *)(v48 - 24), *(_BYTE *)(v49 - 24) != *(_BYTE *)(v48 - 24))
          && (v160 = v159 < 0, LOBYTE(v160) = v159 > 0, (v8 = 2 * v160 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 23) - *(_BYTE *)(v48 - 23);
        if ( *(_BYTE *)(v49 - 23) != *(_BYTE *)(v48 - 23) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_277:
      v161 = *(_DWORD *)(v49 - 22);
      if ( v161 == *(_DWORD *)(v48 - 22) )
      {
        v8 = 0;
      }
      else
      {
        v162 = (unsigned __int8)v161 - *(_BYTE *)(v48 - 22);
        if ( (unsigned __int8)v161 != *(_BYTE *)(v48 - 22)
          && (v163 = v162 < 0, LOBYTE(v163) = v162 > 0, (v8 = 2 * v163 - 1) != 0)
          || (v164 = *(_BYTE *)(v49 - 21) - *(_BYTE *)(v48 - 21), *(_BYTE *)(v49 - 21) != *(_BYTE *)(v48 - 21))
          && (v165 = v164 < 0, LOBYTE(v165) = v164 > 0, (v8 = 2 * v165 - 1) != 0)
          || (v166 = *(_BYTE *)(v49 - 20) - *(_BYTE *)(v48 - 20), *(_BYTE *)(v49 - 20) != *(_BYTE *)(v48 - 20))
          && (v167 = v166 < 0, LOBYTE(v167) = v166 > 0, (v8 = 2 * v167 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 19) - *(_BYTE *)(v48 - 19);
        if ( *(_BYTE *)(v49 - 19) != *(_BYTE *)(v48 - 19) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_288:
      v168 = *(_DWORD *)(v49 - 18);
      if ( v168 == *(_DWORD *)(v48 - 18) )
      {
        v8 = 0;
      }
      else
      {
        v169 = (unsigned __int8)v168 - *(_BYTE *)(v48 - 18);
        if ( (unsigned __int8)v168 != *(_BYTE *)(v48 - 18)
          && (v170 = v169 < 0, LOBYTE(v170) = v169 > 0, (v8 = 2 * v170 - 1) != 0)
          || (v171 = *(_BYTE *)(v49 - 17) - *(_BYTE *)(v48 - 17), *(_BYTE *)(v49 - 17) != *(_BYTE *)(v48 - 17))
          && (v172 = v171 < 0, LOBYTE(v172) = v171 > 0, (v8 = 2 * v172 - 1) != 0)
          || (v173 = *(_BYTE *)(v49 - 16) - *(_BYTE *)(v48 - 16), *(_BYTE *)(v49 - 16) != *(_BYTE *)(v48 - 16))
          && (v174 = v173 < 0, LOBYTE(v174) = v173 > 0, (v8 = 2 * v174 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 15) - *(_BYTE *)(v48 - 15);
        if ( *(_BYTE *)(v49 - 15) != *(_BYTE *)(v48 - 15) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_299:
      v175 = *(_DWORD *)(v49 - 14);
      if ( v175 == *(_DWORD *)(v48 - 14) )
      {
        v8 = 0;
      }
      else
      {
        v176 = (unsigned __int8)v175 - *(_BYTE *)(v48 - 14);
        if ( (unsigned __int8)v175 != *(_BYTE *)(v48 - 14)
          && (v177 = v176 < 0, LOBYTE(v177) = v176 > 0, (v8 = 2 * v177 - 1) != 0)
          || (v178 = *(_BYTE *)(v49 - 13) - *(_BYTE *)(v48 - 13), *(_BYTE *)(v49 - 13) != *(_BYTE *)(v48 - 13))
          && (v179 = v178 < 0, LOBYTE(v179) = v178 > 0, (v8 = 2 * v179 - 1) != 0)
          || (v180 = *(_BYTE *)(v49 - 12) - *(_BYTE *)(v48 - 12), *(_BYTE *)(v49 - 12) != *(_BYTE *)(v48 - 12))
          && (v181 = v180 < 0, LOBYTE(v181) = v180 > 0, (v8 = 2 * v181 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 11) - *(_BYTE *)(v48 - 11);
        if ( *(_BYTE *)(v49 - 11) != *(_BYTE *)(v48 - 11) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_310:
      if ( *(_DWORD *)(v49 - 10) == *(_DWORD *)(v48 - 10) )
      {
        v8 = 0;
      }
      else
      {
        v182 = *(_BYTE *)(v49 - 10) - *(_BYTE *)(v48 - 10);
        if ( *(_BYTE *)(v49 - 10) != *(_BYTE *)(v48 - 10)
          && (v183 = v182 < 0, LOBYTE(v183) = v182 > 0, (v8 = 2 * v183 - 1) != 0)
          || (v184 = *(_BYTE *)(v49 - 9) - *(_BYTE *)(v48 - 9), *(_BYTE *)(v49 - 9) != *(_BYTE *)(v48 - 9))
          && (v185 = v184 < 0, LOBYTE(v185) = v184 > 0, (v8 = 2 * v185 - 1) != 0)
          || (v186 = *(_BYTE *)(v49 - 8) - *(_BYTE *)(v48 - 8), *(_BYTE *)(v49 - 8) != *(_BYTE *)(v48 - 8))
          && (v187 = v186 < 0, LOBYTE(v187) = v186 > 0, (v8 = 2 * v187 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 7) - *(_BYTE *)(v48 - 7);
        if ( *(_BYTE *)(v49 - 7) != *(_BYTE *)(v48 - 7) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_321:
      v188 = *(_DWORD *)(v49 - 6);
      if ( v188 == *(_DWORD *)(v48 - 6) )
      {
        v8 = 0;
      }
      else
      {
        v189 = (unsigned __int8)v188 - *(_BYTE *)(v48 - 6);
        if ( (unsigned __int8)v188 != *(_BYTE *)(v48 - 6)
          && (v190 = v189 < 0, LOBYTE(v190) = v189 > 0, (v8 = 2 * v190 - 1) != 0)
          || (v191 = *(_BYTE *)(v49 - 5) - *(_BYTE *)(v48 - 5), *(_BYTE *)(v49 - 5) != *(_BYTE *)(v48 - 5))
          && (v192 = v191 < 0, LOBYTE(v192) = v191 > 0, (v8 = 2 * v192 - 1) != 0)
          || (v193 = *(_BYTE *)(v49 - 4) - *(_BYTE *)(v48 - 4), *(_BYTE *)(v49 - 4) != *(_BYTE *)(v48 - 4))
          && (v194 = v193 < 0, LOBYTE(v194) = v193 > 0, (v8 = 2 * v194 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 3) - *(_BYTE *)(v48 - 3);
        if ( *(_BYTE *)(v49 - 3) != *(_BYTE *)(v48 - 3) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_332:
      if ( *(_WORD *)(v49 - 2) == *(_WORD *)(v48 - 2) )
        return 0;
      goto LABEL_413;
    case 0x1Au:
      goto LABEL_266;
    case 0x16u:
      goto LABEL_277;
    case 0x12u:
      goto LABEL_288;
    case 0xEu:
      goto LABEL_299;
    case 0xAu:
      goto LABEL_310;
    case 6u:
      goto LABEL_321;
    case 2u:
      goto LABEL_332;
    case 0x1Fu:
      v195 = *(_DWORD *)(v49 - 31);
      if ( v195 == *(_DWORD *)(v48 - 31) )
      {
        v8 = 0;
      }
      else
      {
        v196 = (unsigned __int8)v195 - *(_BYTE *)(v48 - 31);
        if ( (unsigned __int8)v195 != *(_BYTE *)(v48 - 31)
          && (v197 = v196 < 0, LOBYTE(v197) = v196 > 0, (v8 = 2 * v197 - 1) != 0)
          || (v198 = *(_BYTE *)(v49 - 30) - *(_BYTE *)(v48 - 30), *(_BYTE *)(v49 - 30) != *(_BYTE *)(v48 - 30))
          && (v199 = v198 < 0, LOBYTE(v199) = v198 > 0, (v8 = 2 * v199 - 1) != 0)
          || (v200 = *(_BYTE *)(v49 - 29) - *(_BYTE *)(v48 - 29), *(_BYTE *)(v49 - 29) != *(_BYTE *)(v48 - 29))
          && (v201 = v200 < 0, LOBYTE(v201) = v200 > 0, (v8 = 2 * v201 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 28) - *(_BYTE *)(v48 - 28);
        if ( *(_BYTE *)(v49 - 28) != *(_BYTE *)(v48 - 28) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_345:
      v202 = *(_DWORD *)(v49 - 27);
      if ( v202 == *(_DWORD *)(v48 - 27) )
      {
        v8 = 0;
      }
      else
      {
        v203 = (unsigned __int8)v202 - *(_BYTE *)(v48 - 27);
        if ( (unsigned __int8)v202 != *(_BYTE *)(v48 - 27)
          && (v204 = v203 < 0, LOBYTE(v204) = v203 > 0, (v8 = 2 * v204 - 1) != 0)
          || (v205 = *(_BYTE *)(v49 - 26) - *(_BYTE *)(v48 - 26), *(_BYTE *)(v49 - 26) != *(_BYTE *)(v48 - 26))
          && (v206 = v205 < 0, LOBYTE(v206) = v205 > 0, (v8 = 2 * v206 - 1) != 0)
          || (v207 = *(_BYTE *)(v49 - 25) - *(_BYTE *)(v48 - 25), *(_BYTE *)(v49 - 25) != *(_BYTE *)(v48 - 25))
          && (v208 = v207 < 0, LOBYTE(v208) = v207 > 0, (v8 = 2 * v208 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 24) - *(_BYTE *)(v48 - 24);
        if ( *(_BYTE *)(v49 - 24) != *(_BYTE *)(v48 - 24) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_356:
      v209 = *(_DWORD *)(v49 - 23);
      if ( v209 == *(_DWORD *)(v48 - 23) )
      {
        v8 = 0;
      }
      else
      {
        v210 = (unsigned __int8)v209 - *(_BYTE *)(v48 - 23);
        if ( (unsigned __int8)v209 != *(_BYTE *)(v48 - 23)
          && (v211 = v210 < 0, LOBYTE(v211) = v210 > 0, (v8 = 2 * v211 - 1) != 0)
          || (v212 = *(_BYTE *)(v49 - 22) - *(_BYTE *)(v48 - 22), *(_BYTE *)(v49 - 22) != *(_BYTE *)(v48 - 22))
          && (v213 = v212 < 0, LOBYTE(v213) = v212 > 0, (v8 = 2 * v213 - 1) != 0)
          || (v214 = *(_BYTE *)(v49 - 21) - *(_BYTE *)(v48 - 21), *(_BYTE *)(v49 - 21) != *(_BYTE *)(v48 - 21))
          && (v215 = v214 < 0, LOBYTE(v215) = v214 > 0, (v8 = 2 * v215 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 20) - *(_BYTE *)(v48 - 20);
        if ( *(_BYTE *)(v49 - 20) != *(_BYTE *)(v48 - 20) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_367:
      v216 = *(_DWORD *)(v49 - 19);
      if ( v216 == *(_DWORD *)(v48 - 19) )
      {
        v8 = 0;
      }
      else
      {
        v217 = (unsigned __int8)v216 - *(_BYTE *)(v48 - 19);
        if ( (unsigned __int8)v216 != *(_BYTE *)(v48 - 19)
          && (v218 = v217 < 0, LOBYTE(v218) = v217 > 0, (v8 = 2 * v218 - 1) != 0)
          || (v219 = *(_BYTE *)(v49 - 18) - *(_BYTE *)(v48 - 18), *(_BYTE *)(v49 - 18) != *(_BYTE *)(v48 - 18))
          && (v220 = v219 < 0, LOBYTE(v220) = v219 > 0, (v8 = 2 * v220 - 1) != 0)
          || (v221 = *(_BYTE *)(v49 - 17) - *(_BYTE *)(v48 - 17), *(_BYTE *)(v49 - 17) != *(_BYTE *)(v48 - 17))
          && (v222 = v221 < 0, LOBYTE(v222) = v221 > 0, (v8 = 2 * v222 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 16) - *(_BYTE *)(v48 - 16);
        if ( *(_BYTE *)(v49 - 16) != *(_BYTE *)(v48 - 16) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_378:
      if ( *(_DWORD *)(v49 - 15) == *(_DWORD *)(v48 - 15) )
      {
        v8 = 0;
      }
      else
      {
        v223 = *(_BYTE *)(v49 - 15) - *(_BYTE *)(v48 - 15);
        if ( *(_BYTE *)(v49 - 15) != *(_BYTE *)(v48 - 15)
          && (v224 = v223 < 0, LOBYTE(v224) = v223 > 0, (v8 = 2 * v224 - 1) != 0)
          || (v225 = *(_BYTE *)(v49 - 14) - *(_BYTE *)(v48 - 14), *(_BYTE *)(v49 - 14) != *(_BYTE *)(v48 - 14))
          && (v226 = v225 < 0, LOBYTE(v226) = v225 > 0, (v8 = 2 * v226 - 1) != 0)
          || (v227 = *(_BYTE *)(v49 - 13) - *(_BYTE *)(v48 - 13), *(_BYTE *)(v49 - 13) != *(_BYTE *)(v48 - 13))
          && (v228 = v227 < 0, LOBYTE(v228) = v227 > 0, (v8 = 2 * v228 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 12) - *(_BYTE *)(v48 - 12);
        if ( *(_BYTE *)(v49 - 12) != *(_BYTE *)(v48 - 12) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_389:
      v229 = *(_DWORD *)(v49 - 11);
      if ( v229 == *(_DWORD *)(v48 - 11) )
      {
        v8 = 0;
      }
      else
      {
        v230 = (unsigned __int8)v229 - *(_BYTE *)(v48 - 11);
        if ( (unsigned __int8)v229 != *(_BYTE *)(v48 - 11)
          && (v231 = v230 < 0, LOBYTE(v231) = v230 > 0, (v8 = 2 * v231 - 1) != 0)
          || (v232 = *(_BYTE *)(v49 - 10) - *(_BYTE *)(v48 - 10), *(_BYTE *)(v49 - 10) != *(_BYTE *)(v48 - 10))
          && (v233 = v232 < 0, LOBYTE(v233) = v232 > 0, (v8 = 2 * v233 - 1) != 0)
          || (v234 = *(_BYTE *)(v49 - 9) - *(_BYTE *)(v48 - 9), *(_BYTE *)(v49 - 9) != *(_BYTE *)(v48 - 9))
          && (v235 = v234 < 0, LOBYTE(v235) = v234 > 0, (v8 = 2 * v235 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 8) - *(_BYTE *)(v48 - 8);
        if ( *(_BYTE *)(v49 - 8) != *(_BYTE *)(v48 - 8) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_400:
      v236 = *(_DWORD *)(v49 - 7);
      if ( v236 == *(_DWORD *)(v48 - 7) )
      {
        v8 = 0;
      }
      else
      {
        v237 = (unsigned __int8)v236 - *(_BYTE *)(v48 - 7);
        if ( (unsigned __int8)v236 != *(_BYTE *)(v48 - 7)
          && (v238 = v237 < 0, LOBYTE(v238) = v237 > 0, (v8 = 2 * v238 - 1) != 0)
          || (v239 = *(_BYTE *)(v49 - 6) - *(_BYTE *)(v48 - 6), *(_BYTE *)(v49 - 6) != *(_BYTE *)(v48 - 6))
          && (v240 = v239 < 0, LOBYTE(v240) = v239 > 0, (v8 = 2 * v240 - 1) != 0)
          || (v241 = *(_BYTE *)(v49 - 5) - *(_BYTE *)(v48 - 5), *(_BYTE *)(v49 - 5) != *(_BYTE *)(v48 - 5))
          && (v242 = v241 < 0, LOBYTE(v242) = v241 > 0, (v8 = 2 * v242 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 4) - *(_BYTE *)(v48 - 4);
        if ( *(_BYTE *)(v49 - 4) != *(_BYTE *)(v48 - 4) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
      {
LABEL_411:
        v243 = *(_BYTE *)(v49 - 3) - *(_BYTE *)(v48 - 3);
        if ( *(_BYTE *)(v49 - 3) == *(_BYTE *)(v48 - 3)
          || (v244 = v243 < 0, LOBYTE(v244) = v243 > 0, v8 = 2 * v244 - 1, !v8) )
        {
LABEL_413:
          v245 = *(_BYTE *)(v49 - 2) - *(_BYTE *)(v48 - 2);
          if ( *(_BYTE *)(v49 - 2) == *(_BYTE *)(v48 - 2) )
            goto LABEL_253;
          v246 = v245 < 0;
          LOBYTE(v246) = v245 > 0;
          v8 = 2 * v246 - 1;
LABEL_252:
          if ( !v8 )
          {
LABEL_253:
            v8 = *(_BYTE *)(v49 - 1) - *(_BYTE *)(v48 - 1);
            if ( *(_BYTE *)(v49 - 1) != *(_BYTE *)(v48 - 1) )
              v8 = 2 * (v8 > 0) - 1;
          }
        }
      }
      break;
    case 0x1Bu:
      goto LABEL_345;
    case 0x17u:
      goto LABEL_356;
    case 0x13u:
      goto LABEL_367;
    case 0xFu:
      goto LABEL_378;
    case 0xBu:
      goto LABEL_389;
    case 7u:
      goto LABEL_400;
    case 3u:
      goto LABEL_411;
  }
  return v8;
}

//----- (10038EA1) --------------------------------------------------------
int __cdecl sub_10038EA1(int a1, int a2, DWORD dwCmpFlags, int a4, int a5, int a6, int a7, UINT CodePage)
{
  int v8; // ecx@1
  int v9; // esi@1
  int v10; // eax@2
  signed int v11; // edi@3
  UINT v13; // eax@8
  int v14; // ebx@8
  char *v15; // eax@22
  unsigned __int8 v16; // cl@23
  char *v17; // eax@30
  unsigned __int8 v18; // cl@31
  unsigned int v19; // eax@36
  int v20; // ecx@36
  int v21; // ecx@39
  int v22; // eax@42
  int v23; // eax@48
  int v24; // ecx@48
  int v25; // ecx@51
  int v26; // esi@52
  int v27; // eax@54
  char v29; // [sp+0h] [bp-38h]@40
  int v30; // [sp+Ch] [bp-2Ch]@1
  int v31; // [sp+10h] [bp-28h]@8
  const CHAR *v32; // [sp+14h] [bp-24h]@1
  int cchCount1; // [sp+18h] [bp-20h]@1
  LPCSTR cchWideChar; // [sp+1Ch] [bp-1Ch]@1
  struct _cpinfo CPInfo; // [sp+20h] [bp-18h]@19
  unsigned int v36; // [sp+34h] [bp-4h]@1
  int v37; // [sp+38h] [bp+0h]@1

  v36 = (unsigned int)&v37 ^ __security_cookie;
  v8 = a6;
  cchCount1 = a1;
  v9 = a5;
  v30 = a2;
  cchWideChar = (LPCSTR)a4;
  v32 = (const CHAR *)a6;
  if ( a5 <= 0 )
  {
    if ( a5 < -1 )
      return 0;
  }
  else
  {
    v10 = sub_1003910C(a4, a5);
    v8 = (int)v32;
    v9 = v10;
  }
  v11 = a7;
  if ( a7 <= 0 )
  {
    if ( a7 < -1 )
      return 0;
  }
  else
  {
    v11 = sub_1003910C(v8, a7);
  }
  v13 = CodePage;
  v14 = 0;
  v31 = 0;
  if ( !CodePage )
  {
    v13 = *(_DWORD *)(*(_DWORD *)cchCount1 + 4);
    CodePage = *(_DWORD *)(*(_DWORD *)cchCount1 + 4);
  }
  if ( v9 && v11 )
    goto LABEL_36;
  if ( v9 == v11 )
    return 2;
  if ( v11 > 1 )
    return 1;
  if ( v9 > 1 )
    return 3;
  if ( !GetCPInfo(v13, &CPInfo) )
    return 0;
  if ( v9 > 0 )
  {
    if ( (_DWORD)CPInfo.MaxCharSize >= 2u )
    {
      v15 = (char *)CPInfo.LeadByte;
      if ( CPInfo.LeadByte[0] )
      {
        while ( 1 )
        {
          v16 = v15[1];
          if ( !v16 )
            break;
          if ( *cchWideChar >= (unsigned __int8)*v15 && *cchWideChar <= v16 )
            return 2;
          v15 += 2;
          if ( !*v15 )
            return 3;
        }
      }
    }
    return 3;
  }
  if ( v11 > 0 )
  {
    if ( (_DWORD)CPInfo.MaxCharSize >= 2u )
    {
      v17 = (char *)CPInfo.LeadByte;
      if ( CPInfo.LeadByte[0] )
      {
        do
        {
          v18 = v17[1];
          if ( !v18 )
            break;
          if ( *v32 >= (unsigned __int8)*v17 && *v32 <= v18 )
            return 2;
          v17 += 2;
        }
        while ( *v17 );
      }
    }
    return 1;
  }
LABEL_36:
  v19 = MultiByteToWideChar(CodePage, 9u, cchWideChar, v9, 0, 0);
  v20 = v19;
  cchCount1 = v19;
  if ( !v19 )
    return 0;
  if ( (signed int)v19 > 0 && 0xFFFFFFE0 / v19 >= 2 )
  {
    v21 = 2 * v19 + 8;
    if ( (unsigned int)v21 > 0x400 )
    {
      v22 = sub_10030910(0xFFFFFFE0 % v19, v21, 0, v11, v21);
      v14 = v22;
      if ( v22 )
      {
        *(_DWORD *)v22 = 56797;
        goto LABEL_44;
      }
    }
    else
    {
      sub_1003F590(v21, v21, v29);
      v14 = (int)&v29;
      if ( &v29 )
      {
        *(_DWORD *)&v29 = 52428;
LABEL_44:
        v14 += 8;
        goto LABEL_45;
      }
    }
LABEL_45:
    v20 = cchCount1;
  }
  if ( !v14 )
    return 0;
  if ( !MultiByteToWideChar(CodePage, 1u, cchWideChar, v9, (LPWSTR)v14, v20)
    || (v23 = MultiByteToWideChar(CodePage, 9u, v32, v11, 0, 0), v24 = v23, cchWideChar = (LPCSTR)v23, !v23) )
    goto LABEL_63;
  if ( v23 > 0 && 0xFFFFFFE0u / v23 >= 2 )
  {
    v25 = 2 * v23 + 8;
    if ( (unsigned int)v25 > 0x400 )
    {
      v27 = sub_10030910(0xFFFFFFE0u % v23, v25, v14, v11, v25);
      v26 = v27;
      if ( v27 )
      {
        *(_DWORD *)v27 = 56797;
        goto LABEL_56;
      }
    }
    else
    {
      sub_1003F590(v25, v25, v29);
      v26 = (int)&v29;
      if ( &v29 )
      {
        *(_DWORD *)&v29 = 52428;
LABEL_56:
        v26 += 8;
        goto LABEL_57;
      }
    }
LABEL_57:
    v24 = (int)cchWideChar;
    goto LABEL_59;
  }
  v26 = 0;
LABEL_59:
  if ( v26 )
  {
    if ( MultiByteToWideChar(CodePage, 1u, v32, v11, (LPWSTR)v26, v24) )
      v31 = sub_10039B6B(v30, dwCmpFlags, (PCNZWCH)v14, cchCount1, (PCNZWCH)v26, (int)cchWideChar);
    sub_1002CAA7(v14, v26);
  }
LABEL_63:
  sub_1002CAA7(v14, v14);
  return v31;
}
// 10074200: using guessed type int __security_cookie;

//----- (1003910C) --------------------------------------------------------
int __cdecl sub_1003910C(int a1, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1

  v2 = a1;
  v3 = a2;
  if ( a2 )
  {
    while ( 1 )
    {
      --v3;
      if ( !*(_BYTE *)v2 )
        break;
      ++v2;
      if ( !v3 )
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    --v3;
  }
  return a2 - v3 - 1;
}

//----- (1003912C) --------------------------------------------------------
int __usercall sub_1003912C<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, DWORD dwCmpFlags, int a6, int a7, int a8, int a9, UINT CodePage)
{
  int result; // eax@1
  int v11; // [sp+0h] [bp-10h]@1
  int v12; // [sp+8h] [bp-8h]@2
  char v13; // [sp+Ch] [bp-4h]@1

  sub_1003018D((int)&v11, a1, a2, a3);
  result = sub_10038EA1((int)&v11, a4, dwCmpFlags, a6, a7, a8, a9, CodePage);
  if ( v13 )
    *(_DWORD *)(v12 + 112) &= 0xFFFFFFFDu;
  return result;
}

//----- (10039170) --------------------------------------------------------
int __stdcall sub_10039170(unsigned __int64 a1, __int64 a2)
{
  int v2; // esi@2
  unsigned __int64 v3; // qtt@2
  unsigned __int64 v4; // qax@3
  unsigned int v5; // ecx@3
  unsigned int v6; // ebx@3
  char v7; // cf@4
  char v8; // cf@4
  int v9; // eax@5
  unsigned __int64 v10; // qax@5
  int v11; // ecx@5
  char v12; // cf@5

  if ( HIDWORD(a2) )
  {
    v5 = HIDWORD(a2);
    v6 = a2;
    v4 = a1;
    do
    {
      v7 = v5 & 1;
      v5 >>= 1;
      v6 = __RCR__(v6, v7);
      v8 = BYTE4(v4) & 1;
      HIDWORD(v4) >>= 1;
      LODWORD(v4) = __RCR__(v4, v8);
    }
    while ( v5 );
    v9 = v4 / v6;
    v2 = v9;
    v11 = HIDWORD(a2) * v9;
    v10 = v9 * (unsigned int)a2;
    v12 = v11 >= (unsigned int)-HIDWORD(v10);
    HIDWORD(v10) += v11;
    if ( v12 || HIDWORD(v10) > HIDWORD(a1) || v10 > a1 )
      --v2;
  }
  else
  {
    LODWORD(v3) = a1;
    HIDWORD(v3) = HIDWORD(a1) % (_DWORD)a2;
    v2 = v3 / (unsigned int)a2;
  }
  return v2;
}

//----- (10039210) --------------------------------------------------------
void *__cdecl sub_10039210(void *a1, unsigned __int8 a2, signed int a3)
{
  signed int v9; // ecx@3
  void *v10; // edi@3
  int v11; // edx@7
  void *v16; // edi@9
  int v17; // ecx@10
  unsigned int v18; // ecx@13
  unsigned int v19; // ecx@13
  void *result; // eax@16
  int v21; // edx@22
  unsigned int k; // ebx@22
  unsigned int v23; // ebx@22
  unsigned int l; // ebx@25
  int v25; // edx@27
  unsigned int m; // edx@28
  char v27; // bl@28
  int n; // ebx@30
  int i; // edx@33
  unsigned int v30; // ebx@33
  unsigned int j; // ebx@35
  int v32; // [sp-Ch] [bp-Ch]@33

  _ECX = a1;
  if ( a3 )
  {
    _EAX = a2;
    __asm { bt      dword_100768A0, 1 }
    if ( _CF )
    {
      v9 = a3;
      v10 = a1;
      while ( v9 )
      {
        *(_BYTE *)v10 = _EAX;
        v10 = (char *)v10 + 1;
        --v9;
      }
      return a1;
    }
    v11 = a3;
    if ( a3 < 128 )
      goto LABEL_40;
    __asm { bt      dword_10074238, 1 }
    if ( !_CF )
    {
LABEL_40:
      v16 = a1;
      if ( (unsigned int)a3 < 4 )
        goto LABEL_41;
      v17 = -(signed int)a1 & 3;
      if ( v17 )
      {
        v11 = a3 - v17;
        do
        {
          *(_BYTE *)v16 = _EAX;
          v16 = (char *)v16 + 1;
          --v17;
        }
        while ( v17 );
      }
      _EAX = 16843009 * a2;
      v19 = v11;
      v11 &= 3u;
      v18 = v19 >> 2;
      if ( !v18 || (memset(v16, _EAX, 4 * v18), v16 = (char *)v16 + 4 * v18, v11) )
      {
LABEL_41:
        do
        {
          *(_BYTE *)v16 = _EAX;
          v16 = (char *)v16 + 1;
          --v11;
        }
        while ( v11 );
      }
      return a1;
    }
    if ( a2 )
    {
      __asm
      {
        movd    xmm0, eax
        punpcklbw xmm0, xmm0
        punpcklwd xmm0, xmm0
        pshufd  xmm0, xmm0, 0
      }
    }
    else
    {
      __asm { pxor    xmm0, xmm0 }
    }
    if ( (_BYTE)a1 & 0xF )
    {
      v30 = 16 - ((_BYTE)a1 & 0xF);
      v32 = a3 - v30;
      for ( i = v30 & 3; i; --i )
      {
        *(_BYTE *)_ECX = _EAX;
        _ECX = (char *)_ECX + 1;
      }
      for ( j = v30 >> 2; j; --j )
      {
        __asm { movd    dword ptr [ecx], xmm0 }
        _ECX = (char *)_ECX + 4;
      }
      v11 = v32;
    }
    v23 = v11;
    v21 = v11 & 0x7F;
    for ( k = v23 >> 7; k; --k )
    {
      __asm
      {
        movdqa  xmmword ptr [ecx], xmm0
        movdqa  xmmword ptr [ecx+10h], xmm0
        movdqa  xmmword ptr [ecx+20h], xmm0
        movdqa  xmmword ptr [ecx+30h], xmm0
        movdqa  xmmword ptr [ecx+40h], xmm0
        movdqa  xmmword ptr [ecx+50h], xmm0
        movdqa  xmmword ptr [ecx+60h], xmm0
        movdqa  xmmword ptr [ecx+70h], xmm0
      }
      _ECX = (char *)_ECX + 128;
    }
    if ( v21 )
    {
      for ( l = (unsigned int)v21 >> 4; l; --l )
      {
        __asm { movdqa  xmmword ptr [ecx], xmm0 }
        _ECX = (char *)_ECX + 16;
      }
      v25 = v21 & 0xF;
      if ( v25 )
      {
        v27 = v25;
        for ( m = (unsigned int)v25 >> 2; m; --m )
        {
          __asm { movd    dword ptr [ecx], xmm0 }
          _ECX = (char *)_ECX + 4;
        }
        for ( n = v27 & 3; n; --n )
        {
          *(_BYTE *)_ECX = _EAX;
          _ECX = (char *)_ECX + 1;
        }
      }
    }
    result = a1;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (100392A0) --------------------------------------------------------
int __cdecl sub_100392A0(int a1, int a2)
{
  int result; // eax@1

  result = dword_10074210;
  dword_10074210 = a2 & a1 | dword_10074210 & ~a2;
  return result;
}
// 10074210: using guessed type int dword_10074210;

//----- (10039310) --------------------------------------------------------
int __cdecl sub_10039310(int a1, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  unsigned __int8 v4; // cf@2
  unsigned int v5; // eax@2
  unsigned int v6; // eax@6
  __int16 v8; // ax@16

  v2 = a1;
  v3 = a2;
  if ( !(a1 & 3) )
  {
LABEL_2:
    while ( 1 )
    {
      v5 = *(_DWORD *)v2;
      v4 = (unsigned __int8)*(_DWORD *)v2 < *(_BYTE *)v3;
      if ( (unsigned __int8)*(_DWORD *)v2 != *(_BYTE *)v3 )
        break;
      if ( !(_BYTE)v5 )
        return 0;
      v4 = BYTE1(v5) < *(_BYTE *)(v3 + 1);
      if ( BYTE1(v5) != *(_BYTE *)(v3 + 1) )
        break;
      if ( !BYTE1(v5) )
        return 0;
      v6 = v5 >> 16;
      v4 = (_BYTE)v6 < *(_BYTE *)(v3 + 2);
      if ( (_BYTE)v6 != *(_BYTE *)(v3 + 2) )
        break;
      if ( !(_BYTE)v6 )
        return 0;
      v4 = BYTE1(v6) < *(_BYTE *)(v3 + 3);
      if ( BYTE1(v6) != *(_BYTE *)(v3 + 3) )
        break;
      v3 += 4;
      v2 += 4;
      if ( !BYTE1(v6) )
        return 0;
    }
    return -v4 | 1;
  }
  if ( a1 & 1 )
  {
    v2 = a1 + 1;
    v4 = *(_BYTE *)a1 < *(_BYTE *)a2;
    if ( *(_BYTE *)a1 != *(_BYTE *)a2 )
      return -v4 | 1;
    v3 = a2 + 1;
    if ( !*(_BYTE *)a1 )
      return 0;
    if ( !(v2 & 2) )
      goto LABEL_2;
  }
  v8 = *(_WORD *)v2;
  v2 += 2;
  v4 = (_BYTE)v8 < *(_BYTE *)v3;
  if ( (_BYTE)v8 != *(_BYTE *)v3 )
    return -v4 | 1;
  if ( !(_BYTE)v8 )
    return 0;
  v4 = HIBYTE(v8) < *(_BYTE *)(v3 + 1);
  if ( HIBYTE(v8) == *(_BYTE *)(v3 + 1) )
  {
    if ( HIBYTE(v8) )
    {
      v3 += 2;
      goto LABEL_2;
    }
    return 0;
  }
  return -v4 | 1;
}

//----- (1003939C) --------------------------------------------------------
signed int (__usercall *__usercall sub_1003939C<eax>(int a1<ebx>, int a2<edi>, int a3))<eax>(int<edi>, int, int, unsigned int, int, int, int)
{
  signed int (__usercall *result)<eax>(int<edi>, int, int, unsigned int, int, int, int); // eax@1

  result = sub_100393B3();
  if ( a3 )
    result = (signed int (__usercall *)<eax>(int<edi>, int, int, unsigned int, int, int, int))sub_1004AAA5(a1, a2);
  __asm { fnclex }
  return result;
}

//----- (100393B3) --------------------------------------------------------
signed int (__usercall *__cdecl sub_100393B3())<eax>(int<edi>, int, int, unsigned int, int, int, int)
{
  signed int (__usercall *result)<eax>(int<edi>, int, int, unsigned int, int, int, int); // eax@1

  result = sub_1004A019;
  off_100751CC[0] = (int (*)())sub_1004A019;
  off_100751D0[0] = (int (*)())sub_1004A8F9;
  off_100751D4[0] = (int (*)())sub_1004A988;
  off_100751D8[0] = (int (*)())sub_1004A9E0;
  off_100751DC[0] = (int (*)())sub_1004AA63;
  off_100751E0[0] = (int (*)())sub_1004A019;
  off_100751E4 = sub_1004A03A;
  off_100751E8 = sub_1004A9A0;
  off_100751EC = sub_1004A90A;
  off_100751F0 = sub_1004A9F1;
  return result;
}
// 100751CC: using guessed type int (*off_100751CC[10])();
// 100751D0: using guessed type int (*off_100751D0[9])();
// 100751D4: using guessed type int (*off_100751D4[8])();
// 100751D8: using guessed type int (*off_100751D8[7])();
// 100751DC: using guessed type int (*off_100751DC[6])();
// 100751E0: using guessed type int (*off_100751E0[5])();

//----- (10039413) --------------------------------------------------------
int __cdecl sub_10039413(int a1)
{
  int result; // eax@1

  result = __security_cookie ^ dword_10078B08;
  if ( __security_cookie != dword_10078B08 )
    result = ((int (__stdcall *)(int))result)(a1);
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078B08: using guessed type int dword_10078B08;

//----- (1003942A) --------------------------------------------------------
int __cdecl sub_1003942A(int a1)
{
  int result; // eax@1

  result = __security_cookie ^ dword_10078B14;
  if ( __security_cookie != dword_10078B14 )
    result = ((int (__stdcall *)(int))result)(a1);
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078B14: using guessed type int dword_10078B14;

//----- (10039441) --------------------------------------------------------
HANDLE __stdcall sub_10039441(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, int a5, int a6)
{
  HANDLE result; // eax@2

  if ( __security_cookie == dword_10078AF4 )
    result = CreateSemaphoreW(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
  else
    result = (HANDLE)((int (__stdcall *)(LPSECURITY_ATTRIBUTES, LONG, LONG, LPCWSTR, int, int))(__security_cookie ^ dword_10078AF4))(
                       lpSemaphoreAttributes,
                       lInitialCount,
                       lMaximumCount,
                       lpName,
                       a5,
                       a6);
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078AF4: using guessed type int dword_10078AF4;

//----- (1003946A) --------------------------------------------------------
int __cdecl sub_1003946A(int a1, int a2, int a3)
{
  int result; // eax@2

  if ( __security_cookie == dword_10078AFC )
    result = 0;
  else
    result = ((int (__stdcall *)(int, int, int))(__security_cookie ^ dword_10078AFC))(a1, a2, a3);
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078AFC: using guessed type int dword_10078AFC;

//----- (1003948B) --------------------------------------------------------
int __cdecl sub_1003948B(int a1, int a2, int a3)
{
  int result; // eax@2

  if ( __security_cookie == dword_10078B0C )
    result = 0;
  else
    result = ((int (__stdcall *)(int, int, int))(__security_cookie ^ dword_10078B0C))(a1, a2, a3);
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078B0C: using guessed type int dword_10078B0C;

//----- (100394AC) --------------------------------------------------------
DWORD __cdecl sub_100394AC(int a1)
{
  DWORD result; // eax@2

  if ( __security_cookie == dword_10078AE0 )
    result = TlsAlloc();
  else
    result = ((int (__stdcall *)(int))(__security_cookie ^ dword_10078AE0))(a1);
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078AE0: using guessed type int dword_10078AE0;

//----- (100394CA) --------------------------------------------------------
BOOL __cdecl sub_100394CA(DWORD a1)
{
  BOOL result; // eax@2

  if ( __security_cookie == dword_10078AE4 )
    result = TlsFree(a1);
  else
    result = ((int (__stdcall *)(_DWORD))(__security_cookie ^ dword_10078AE4))(a1);
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078AE4: using guessed type int dword_10078AE4;

//----- (100394E9) --------------------------------------------------------
LPVOID __cdecl sub_100394E9(DWORD a1)
{
  LPVOID result; // eax@2

  if ( __security_cookie == dword_10078AE8 )
    result = TlsGetValue(a1);
  else
    result = (LPVOID)((int (__stdcall *)(_DWORD))(__security_cookie ^ dword_10078AE8))(a1);
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078AE8: using guessed type int dword_10078AE8;

//----- (10039508) --------------------------------------------------------
BOOL __cdecl sub_10039508(DWORD a1, void *a2)
{
  BOOL result; // eax@2

  if ( __security_cookie == dword_10078AEC )
    result = TlsSetValue(a1, a2);
  else
    result = ((int (__stdcall *)(_DWORD, _DWORD))(__security_cookie ^ dword_10078AEC))(a1, a2);
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078AEC: using guessed type int dword_10078AEC;

//----- (1003952A) --------------------------------------------------------
int __cdecl sub_1003952A()
{
  int result; // eax@1

  result = __security_cookie ^ dword_10078B18;
  if ( __security_cookie != dword_10078B18 )
    result = ((int (*)(void))result)();
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078B18: using guessed type int dword_10078B18;

//----- (1003953A) --------------------------------------------------------
int __cdecl sub_1003953A(int a1, int a2)
{
  int result; // eax@1

  result = __security_cookie ^ dword_10078B1C;
  if ( __security_cookie != dword_10078B1C )
    result = ((int (__stdcall *)(int, int))result)(a1, a2);
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078B1C: using guessed type int dword_10078B1C;

//----- (10039554) --------------------------------------------------------
int __cdecl sub_10039554()
{
  int result; // eax@2

  if ( __security_cookie == dword_10078B20 )
    result = 0;
  else
    result = ((int (*)(void))(__security_cookie ^ dword_10078B20))();
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078B20: using guessed type int dword_10078B20;

//----- (10039566) --------------------------------------------------------
int __cdecl sub_10039566(int a1, int a2)
{
  int result; // eax@2

  if ( __security_cookie == dword_10078B24 )
  {
    SetLastError(0x78u);
    result = 0;
  }
  else
  {
    result = ((int (__stdcall *)(int, int))(__security_cookie ^ dword_10078B24))(a1, a2);
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078B24: using guessed type int dword_10078B24;

//----- (1003958C) --------------------------------------------------------
int __cdecl sub_1003958C(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, int a3)
{
  int result; // eax@2

  if ( __security_cookie == dword_10078AF0 )
  {
    InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
    result = 1;
  }
  else
  {
    result = ((int (__stdcall *)(LPCRITICAL_SECTION, DWORD, int))(__security_cookie ^ dword_10078AF0))(
               lpCriticalSection,
               dwSpinCount,
               a3);
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078AF0: using guessed type int dword_10078AF0;

//----- (100395BA) --------------------------------------------------------
char __cdecl sub_100395BA()
{
  signed int v0; // esi@1
  int v2; // [sp+4h] [bp-4h]@2

  v0 = dword_10074228;
  if ( dword_10074228 < 0 )
  {
    v0 = 0;
    v2 = 0;
    if ( __security_cookie != dword_10078B50 )
    {
      if ( ((int (__stdcall *)(int *, _DWORD))(__security_cookie ^ dword_10078B50))(&v2, 0) == 122 )
        v0 = 1;
    }
    dword_10074228 = v0;
  }
  return v0 > 0;
}
// 10074200: using guessed type int __security_cookie;
// 10074228: using guessed type int dword_10074228;
// 10078B50: using guessed type int dword_10078B50;

//----- (10039837) --------------------------------------------------------
int __cdecl sub_10039837(int a1, int a2, int a3, int a4)
{
  int result; // eax@1

  result = __security_cookie ^ dword_10078B00;
  if ( __security_cookie != dword_10078B00 )
    result = ((int (__stdcall *)(int, int, int, int))result)(a1, a2, a3, a4);
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078B00: using guessed type int dword_10078B00;

//----- (10039857) --------------------------------------------------------
int __cdecl sub_10039857(int a1, int a2, int a3)
{
  int result; // eax@1

  result = __security_cookie ^ dword_10078B10;
  if ( __security_cookie != dword_10078B10 )
    result = ((int (__stdcall *)(int, int, int))result)(a1, a2, a3);
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078B10: using guessed type int dword_10078B10;

//----- (10039874) --------------------------------------------------------
BOOL __cdecl sub_10039874(UINT uExitCode)
{
  HANDLE v2; // eax@1

  v2 = GetCurrentProcess();
  return TerminateProcess(v2, uExitCode);
}

//----- (10039889) --------------------------------------------------------
LONG __cdecl sub_10039889(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  SetUnhandledExceptionFilter(0);
  return UnhandledExceptionFilter(ExceptionInfo);
}

//----- (1003989F) --------------------------------------------------------
int __cdecl sub_1003989F(int a1, int a2)
{
  int result; // eax@1

  result = __security_cookie ^ dword_10078B04;
  if ( __security_cookie != dword_10078B04 )
    result = ((int (__stdcall *)(int, int))result)(a1, a2);
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078B04: using guessed type int dword_10078B04;

//----- (100398B9) --------------------------------------------------------
int __cdecl sub_100398B9(int a1)
{
  int v1; // eax@1
  __int16 v2; // cx@2

  v1 = a1;
  do
  {
    v2 = *(_WORD *)v1;
    v1 += 2;
  }
  while ( v2 );
  return ((v1 - a1) >> 1) - 1;
}

//----- (100398D2) --------------------------------------------------------
int __usercall sub_100398D2<eax>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // ecx@2
  int v6; // eax@3
  __int16 v7; // ax@4
  int v8; // ecx@6
  int result; // eax@8
  int v10; // ecx@14
  unsigned int v11; // eax@16
  int v12; // edx@22
  int v13; // [sp+8h] [bp-18h]@1
  int v14; // [sp+10h] [bp-10h]@7
  char v15; // [sp+14h] [bp-Ch]@6
  WCHAR DestStr; // [sp+18h] [bp-8h]@16
  const CHAR MultiByteStr; // [sp+1Ch] [bp-4h]@14
  char v18; // [sp+1Dh] [bp-3h]@14
  char v19; // [sp+1Eh] [bp-2h]@14
  int v20; // [sp+28h] [bp+8h]@13

  sub_1003018D((int)&v13, a1, a2, a4);
  v4 = a3;
  if ( (unsigned int)a3 < 0x100 )
  {
    v5 = v13;
    if ( *(_DWORD *)(v13 + 116) <= 1 )
    {
      v7 = *(_WORD *)(*(_DWORD *)(v13 + 144) + 2 * a3);
      v6 = v7 & 1;
    }
    else
    {
      v6 = sub_10042678(a3, 256, a3, 1, (int)&v13);
      v5 = v13;
    }
    if ( v6 )
    {
      v8 = *(_BYTE *)(*(_DWORD *)(v5 + 148) + a3);
      if ( v15 )
        *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
      return v8;
    }
    if ( v15 )
      *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
    return v4;
  }
  if ( *(_DWORD *)(v13 + 116) > 1 && (v20 = a3 >> 8, sub_10042727(v4, 256, BYTE1(v4), (int)&v13)) )
  {
    MultiByteStr = v20;
    v18 = v4;
    v19 = 0;
    v10 = 2;
  }
  else
  {
    *(_DWORD *)sub_10037669(v4) = 42;
    MultiByteStr = v4;
    v18 = 0;
    v10 = 1;
  }
  v11 = sub_100374C2(
          v4,
          256,
          (int)&v13,
          *(_DWORD *)(v13 + 168),
          0x100u,
          &MultiByteStr,
          v10,
          &DestStr,
          3,
          *(_DWORD *)(v13 + 4),
          1);
  if ( !v11 )
  {
    if ( v15 )
      *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
    return v4;
  }
  if ( v11 == 1 )
  {
    result = (unsigned __int8)DestStr;
    if ( v15 )
      *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
  }
  else
  {
    v12 = HIBYTE(DestStr) | ((unsigned __int8)DestStr << 8);
    if ( v15 )
      *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
    result = v12;
  }
  return result;
}

//----- (10039A13) --------------------------------------------------------
int __usercall sub_10039A13<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // ecx@2
  int result; // eax@4

  if ( dword_10077048 )
  {
    result = sub_100398D2(a1, a2, a3, 0);
  }
  else
  {
    v3 = a3;
    if ( (unsigned int)(a3 - 65) <= 0x19 )
      v3 = a3 + 32;
    result = v3;
  }
  return result;
}
// 10077048: using guessed type int dword_10077048;

//----- (10039A40) --------------------------------------------------------
__int64 __stdcall sub_10039A40(__int64 a1, __int64 a2)
{
  __int64 result; // qax@2

  if ( HIDWORD(a1) | HIDWORD(a2) )
    result = a2 * a1;
  else
    result = (unsigned int)a2 * (unsigned int)a1;
  return result;
}

//----- (10039A80) --------------------------------------------------------
__int64 __stdcall sub_10039A80(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  __int64 result; // qax@2
  unsigned __int64 v4; // qtt@2
  unsigned __int64 v5; // qax@3
  unsigned int v6; // ecx@3
  unsigned int v7; // ebx@3
  char v8; // cf@4
  char v9; // cf@4
  unsigned int v10; // eax@5
  unsigned __int64 v11; // qax@5
  unsigned int v12; // esi@5
  int v13; // ecx@5
  char v14; // cf@5

  if ( a3 )
  {
    v6 = a3;
    v7 = a2;
    v5 = a1;
    do
    {
      v8 = v6 & 1;
      v6 >>= 1;
      v7 = __RCR__(v7, v8);
      v9 = BYTE4(v5) & 1;
      HIDWORD(v5) >>= 1;
      LODWORD(v5) = __RCR__(v5, v9);
    }
    while ( v6 );
    v10 = v5 / v7;
    v12 = v10;
    v13 = a3 * v10;
    v11 = v10 * a2;
    v14 = v13 >= (unsigned int)-HIDWORD(v11);
    HIDWORD(v11) += v13;
    if ( v14 || HIDWORD(v11) > HIDWORD(a1) || v11 > a1 )
      --v12;
    result = v12;
  }
  else
  {
    LODWORD(v4) = a1;
    HIDWORD(v4) = HIDWORD(a1) % a2;
    LODWORD(result) = v4 / a2;
    HIDWORD(result) = HIDWORD(a1) / a2;
  }
  return result;
}

//----- (10039AE8) --------------------------------------------------------
int __cdecl sub_10039AE8(int a1)
{
  int v1; // ecx@1
  int v2; // esi@1
  int result; // eax@2

  v1 = 0;
  v2 = 227;
  while ( 1 )
  {
    result = (v2 + v1) / 2;
    if ( a1 == dword_10062A68[2 * result] )
      break;
    if ( a1 - dword_10062A68[2 * result] >= 0 )
      v1 = result + 1;
    else
      v2 = result - 1;
    if ( v1 > v2 )
      return -1;
  }
  return result;
}
// 10062A68: using guessed type int dword_10062A68[];

//----- (10039B1D) --------------------------------------------------------
int __cdecl sub_10039B1D(int a1)
{
  int v1; // ebx@1
  int v2; // edi@1
  int v3; // eax@2
  int v4; // esi@2

  v2 = 0;
  v1 = 227;
  while ( 1 )
  {
    v4 = (v1 + v2) / 2;
    v3 = sub_10039D7F(a1, (unsigned __int16 *)*(&off_10063188 + 2 * (v1 + v2) / 2), 85);
    if ( !v3 )
      break;
    if ( v3 >= 0 )
      v2 = v4 + 1;
    else
      v1 = v4 - 1;
    if ( v2 > v1 )
      return -1;
  }
  return dword_1006318C[2 * v4];
}
// 10063188: using guessed type void *off_10063188;
// 1006318C: using guessed type int dword_1006318C[];

//----- (10039B6B) --------------------------------------------------------
int __cdecl sub_10039B6B(int a1, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2)
{
  int result; // eax@2
  int v7; // eax@3

  if ( __security_cookie == dword_10078B30 )
  {
    v7 = sub_10039C33(a1);
    result = CompareStringW(v7, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
  }
  else
  {
    result = ((int (__stdcall *)(int, DWORD, PCNZWCH, int, PCNZWCH, int, _DWORD, _DWORD, _DWORD))(__security_cookie ^ dword_10078B30))(
               a1,
               dwCmpFlags,
               lpString1,
               cchCount1,
               lpString2,
               cchCount2,
               0,
               0,
               0);
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078B30: using guessed type int dword_10078B30;

//----- (10039BB7) --------------------------------------------------------
int __cdecl sub_10039BB7(int a1, int a2, int a3)
{
  int v3; // eax@7
  int v4; // eax@8
  int v5; // edx@8
  int v6; // ebx@8
  int v7; // edi@8
  int v9; // [sp-4h] [bp-10h]@8

  if ( a1 )
  {
    if ( a1 != 1024 )
    {
      if ( a1 != 2048 )
      {
        if ( a2 || a3 <= 0 )
        {
          if ( a3 >= 0 )
          {
            v3 = sub_10039AE8(a1);
            if ( v3 >= 0 )
            {
              v6 = off_10062A6C[2 * v3];
              v4 = sub_1004AC57(off_10062A6C[2 * v3], 0x55u);
              v7 = v4;
              if ( a3 <= 0 )
                return v7 + 1;
              if ( v4 < a3 )
              {
                if ( sub_100490D0(v5, v9, v6, v4, a2, a3, v6) )
                {
                  sub_1003A17E(v6, v7);
                  __asm { int     3               ; Trap to Debugger }
                  JUMPOUT(*(int *)sub_10039C33);
                }
                return v7 + 1;
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

//----- (10039C33) --------------------------------------------------------
int __cdecl sub_10039C33(int a1)
{
  int v1; // eax@2
  int result; // eax@4

  if ( a1 && (v1 = sub_10039B1D(a1), v1 >= 0) && (unsigned int)v1 < 0xE4 )
    result = dword_10062A68[2 * v1];
  else
    result = 0;
  return result;
}
// 10062A68: using guessed type int dword_10062A68[];

//----- (10039C5D) --------------------------------------------------------
int __stdcall LocaleEnumProc(int a1)
{
  return dword_10076898(a1, 0, 0);
}
// 10076898: using guessed type int (__stdcall *dword_10076898)(_DWORD, _DWORD, _DWORD);

//----- (10039C71) --------------------------------------------------------
BOOL __cdecl sub_10039C71(int (__stdcall *a1)(_DWORD, _DWORD, _DWORD), int a2, int a3)
{
  BOOL result; // eax@2

  if ( __security_cookie == dword_10078B34 )
  {
    dword_10076898 = a1;
    result = EnumSystemLocalesW((LOCALE_ENUMPROCW)LocaleEnumProc, 1u);
    dword_10076898 = 0;
  }
  else
  {
    result = ((int (__stdcall *)(int (__stdcall *)(_DWORD, _DWORD, _DWORD), int, int, _DWORD))(__security_cookie ^ dword_10078B34))(
               a1,
               a2,
               a3,
               0);
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10076898: using guessed type int (__stdcall *dword_10076898)(_DWORD, _DWORD, _DWORD);
// 10078B34: using guessed type int dword_10078B34;

//----- (10039CAE) --------------------------------------------------------
int __cdecl sub_10039CAE(int a1, LCTYPE a2, WCHAR *a3, int a4)
{
  int result; // eax@2
  int v5; // eax@3

  if ( __security_cookie == dword_10078B3C )
  {
    v5 = sub_10039C33(a1);
    result = GetLocaleInfoW(v5, a2, a3, a4);
  }
  else
  {
    result = ((int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))(__security_cookie ^ dword_10078B3C))(a1, a2, a3, a4);
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078B3C: using guessed type int dword_10078B3C;

//----- (10039CDD) --------------------------------------------------------
int __cdecl sub_10039CDD(int a1, int a2)
{
  int result; // eax@2
  int v3; // eax@3

  if ( __security_cookie == dword_10078B44 )
  {
    v3 = GetUserDefaultLCID();
    result = sub_10039BB7(v3, a1, a2);
  }
  else
  {
    result = ((int (__stdcall *)(_DWORD, _DWORD))(__security_cookie ^ dword_10078B44))(a1, a2);
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078B44: using guessed type int dword_10078B44;

//----- (10039D08) --------------------------------------------------------
BOOL __cdecl sub_10039D08(int a1)
{
  BOOL result; // eax@2
  int v2; // eax@3

  if ( __security_cookie == dword_10078B48 )
  {
    v2 = sub_10039C33(a1);
    result = IsValidLocale(v2, 1u);
  }
  else
  {
    result = ((int (__stdcall *)(_DWORD))(__security_cookie ^ dword_10078B48))(a1);
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078B48: using guessed type int dword_10078B48;

//----- (10039D33) --------------------------------------------------------
int __cdecl sub_10039D33(int a1, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
{
  int result; // eax@2
  int v7; // eax@3

  if ( __security_cookie == dword_10078B4C )
  {
    v7 = sub_10039C33(a1);
    result = LCMapStringW(v7, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
  }
  else
  {
    result = ((int (__stdcall *)(int, DWORD, LPCWSTR, int, LPWSTR, int, _DWORD, _DWORD, _DWORD))(__security_cookie ^ dword_10078B4C))(
               a1,
               dwMapFlags,
               lpSrcStr,
               cchSrc,
               lpDestStr,
               cchDest,
               0,
               0,
               0);
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078B4C: using guessed type int dword_10078B4C;

//----- (10039D7F) --------------------------------------------------------
int __cdecl sub_10039D7F(int a1, unsigned __int16 *a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  signed __int16 v5; // dx@2
  unsigned __int16 *v6; // ecx@2
  unsigned __int16 v7; // ax@4
  unsigned __int16 v8; // dx@6
  unsigned __int16 v9; // ax@8
  signed int v10; // [sp+14h] [bp+10h]@2

  v4 = a3;
  result = 0;
  if ( a3 )
  {
    v6 = a2;
    v5 = 90;
    v10 = 90;
    while ( 1 )
    {
      v7 = *(unsigned __int16 *)((char *)v6 + a1 - (_DWORD)a2);
      if ( v7 < 0x41u || v7 > v5 )
        v8 = *(unsigned __int16 *)((char *)v6 + a1 - (_DWORD)a2);
      else
        v8 = v7 + 32;
      v9 = *v6;
      if ( *v6 >= 0x41u )
      {
        if ( v9 <= (_WORD)v10 )
          v9 += 32;
      }
      ++v6;
      --v4;
      if ( !v4 )
        break;
      if ( !v8 || v8 != v9 )
        break;
      v5 = 90;
    }
    result = v8 - v9;
  }
  return result;
}

//----- (10039DED) --------------------------------------------------------
int __cdecl sub_10039DED(int a1, DWORD dwMapFlags, LPCWSTR lpSrcStr, unsigned int cchSrc, LPWSTR lpDestStr, int cchDest)
{
  int v6; // eax@1

  v6 = cchSrc;
  if ( (signed int)cchSrc > 0 )
    v6 = sub_1004AC57((int)lpSrcStr, cchSrc);
  return sub_10039D33(a1, dwMapFlags, lpSrcStr, v6, lpDestStr, cchDest);
}

//----- (10039E20) --------------------------------------------------------
void __usercall sub_10039E20(unsigned __int64 a1<st0>)
{
  int v1; // ST00_4@1
  int v2; // ST04_4@1

  sub_1004AF38(a1, a1 >> 32);
  sub_10039E3D(v1, v2);
}
// 10039E3D: using guessed type double __cdecl sub_10039E3D(_DWORD, _DWORD);

//----- (10039E3D) --------------------------------------------------------
#error "10039ED3: call analysis failed (funcsize=60)"

//----- (10039EDA) --------------------------------------------------------
int __cdecl sub_10039EDA()
{
  int v1; // esi@2
  int v6; // ST18_4@2

  dword_1007689C = 0;
  dword_10074238 |= 1u;
  if ( IsProcessorFeaturePresent(0xAu) )
  {
    _EAX = 1;
    dword_1007689C = 1;
    __asm { cpuid }
    v1 = dword_10074238 | 2;
    v6 = _ECX;
    dword_10074238 |= 2u;
    if ( v6 & 0x100000 )
    {
      v1 |= 4u;
      dword_1007689C = 2;
      dword_10074238 = v1;
    }
    if ( _ECX & 0x10000000 )
    {
      dword_1007689C = 3;
      dword_10074238 = v1 | 8;
    }
    _EAX = 7;
    __asm { cpuid }
    _EAX = 0;
    __asm { cpuid }
  }
  return 0;
}
// 10074238: using guessed type int dword_10074238;
// 1007689C: using guessed type int dword_1007689C;

//----- (1003A013) --------------------------------------------------------
void __usercall sub_1003A013(int a1<ebx>, int a2<edi>, int a3<esi>, int a4, int a5, int a6)
{
  BOOL v6; // edi@3
  int v11; // ecx@3
  int v12; // edx@3
  int v13; // ST08_4@3
  char v14; // [sp-Ch] [bp-338h]@3
  char v15; // [sp+0h] [bp-32Ch]@3
  struct _EXCEPTION_POINTERS ExceptionInfo; // [sp+4h] [bp-328h]@3
  int v17; // [sp+Ch] [bp-320h]@3
  int v18; // [sp+10h] [bp-31Ch]@3
  void *v19; // [sp+18h] [bp-314h]@3
  int v20; // [sp+5Ch] [bp-2D0h]@3
  __int16 v21; // [sp+E8h] [bp-244h]@3
  __int16 v22; // [sp+ECh] [bp-240h]@3
  __int16 v23; // [sp+F0h] [bp-23Ch]@3
  __int16 v24; // [sp+F4h] [bp-238h]@3
  int v25; // [sp+F8h] [bp-234h]@3
  int v26; // [sp+FCh] [bp-230h]@3
  int v27; // [sp+100h] [bp-22Ch]@3
  int v28; // [sp+104h] [bp-228h]@3
  int v29; // [sp+108h] [bp-224h]@3
  int *v30; // [sp+10Ch] [bp-220h]@3
  int v31; // [sp+110h] [bp-21Ch]@3
  void *v32; // [sp+114h] [bp-218h]@3
  __int16 v33; // [sp+118h] [bp-214h]@3
  int v34; // [sp+11Ch] [bp-210h]@3
  void **v35; // [sp+120h] [bp-20Ch]@3
  __int16 v36; // [sp+124h] [bp-208h]@3
  unsigned int v37; // [sp+328h] [bp-4h]@1
  int v38; // [sp+32Ch] [bp+0h]@1
  int v39; // [sp+330h] [bp+4h]@3

  v37 = (unsigned int)&v38 ^ __security_cookie;
  if ( a4 != -1 )
    sub_1004362C();
  sub_10039210(&v18, 0, 76);
  ExceptionInfo.ExceptionRecord = (PEXCEPTION_RECORD)&v17;
  _CF = (unsigned int)&v14 >= 0xFFFFFFF4;
  _OF = __SETO__(&v14, -12);
  _ZF = &v15 == 0;
  _SF = (signed int)&v15 < 0;
  ExceptionInfo.ContextRecord = (PCONTEXT)&v20;
  v30 = &v20;
  v29 = v11;
  v28 = v12;
  v27 = a1;
  v26 = a3;
  v25 = a2;
  v36 = __SS__;
  v33 = __CS__;
  v24 = __DS__;
  v23 = __ES__;
  v22 = __FS__;
  v21 = __GS__;
  __asm { pushf }
  v34 = v13;
  v32 = (void *)v39;
  v35 = (void **)&v39;
  v20 = 65537;
  v31 = v38;
  v17 = a5;
  v18 = a6;
  v19 = (void *)v39;
  v6 = IsDebuggerPresent();
  if ( !sub_10039889(&ExceptionInfo) )
  {
    if ( !v6 )
    {
      if ( a4 != -1 )
        sub_1004362C();
    }
  }
}
// 10074200: using guessed type int __security_cookie;

//----- (1003A136) --------------------------------------------------------
void *__cdecl sub_1003A136(void *a1)
{
  void *result; // eax@1

  result = a1;
  dword_100768A4 = a1;
  return result;
}

//----- (1003A143) --------------------------------------------------------
int __usercall sub_1003A143<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6, int a7)
{
  int (*v7)(void); // eax@1

  v7 = (int (*)(void))DecodePointer(dword_100768A4);
  if ( !v7 )
  {
    sub_1003A17E(a1, a2);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003A16E);
  }
  return v7();
}

//----- (1003A16E) --------------------------------------------------------
int __usercall sub_1003A16E<eax>(int a1<ebx>, int a2<edi>)
{
  return sub_1003A143(a1, a2, 0, 0, 0, 0, 0);
}

//----- (1003A17E) --------------------------------------------------------
int __usercall sub_1003A17E<eax>(int a1<ebx>, int a2<edi>)
{
  if ( IsProcessorFeaturePresent(0x17u) )
    __asm { int     29h             ; DOS 2+ internal - FAST PUTCHAR }
  sub_1003A013(a1, a2, -1073740777, 2, -1073740777, 1);
  return sub_10039874(0xC0000417u);
}

//----- (1003A1A9) --------------------------------------------------------
int *__cdecl sub_1003A1A9()
{
  return &dword_10074244;
}
// 10074244: using guessed type int dword_10074244;

//----- (1003A1AF) --------------------------------------------------------
int *__cdecl sub_1003A1AF()
{
  return &dword_10074248;
}
// 10074248: using guessed type int dword_10074248;

//----- (1003A1B5) --------------------------------------------------------
int *__cdecl sub_1003A1B5()
{
  return &dword_10074240;
}
// 10074240: using guessed type int dword_10074240;

//----- (1003A1BB) --------------------------------------------------------
void **__cdecl sub_1003A1BB()
{
  return &off_100742D0;
}
// 100742D0: using guessed type void *off_100742D0;

//----- (1003A1C1) --------------------------------------------------------
signed int __usercall sub_1003A1C1<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  signed int result; // eax@2

  if ( a3 )
  {
    *(_DWORD *)a3 = dword_10074244;
    result = 0;
  }
  else
  {
    *(_DWORD *)sub_10037669(a1) = 22;
    sub_1003A16E(a1, a2);
    result = 22;
  }
  return result;
}
// 10074244: using guessed type int dword_10074244;

//----- (1003A1EB) --------------------------------------------------------
signed int __usercall sub_1003A1EB<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  signed int result; // eax@2

  if ( a3 )
  {
    *(_DWORD *)a3 = dword_10074248;
    result = 0;
  }
  else
  {
    *(_DWORD *)sub_10037669(a1) = 22;
    sub_1003A16E(a1, a2);
    result = 22;
  }
  return result;
}
// 10074248: using guessed type int dword_10074248;

//----- (1003A215) --------------------------------------------------------
signed int __usercall sub_1003A215<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  signed int result; // eax@2

  if ( a3 )
  {
    *(_DWORD *)a3 = dword_10074240;
    result = 0;
  }
  else
  {
    *(_DWORD *)sub_10037669(a1) = 22;
    sub_1003A16E(a1, a2);
    result = 22;
  }
  return result;
}
// 10074240: using guessed type int dword_10074240;

//----- (1003A23F) --------------------------------------------------------
signed int __cdecl sub_1003A23F(int a1, int a2)
{
  signed int v2; // esi@2
  signed int result; // eax@3
  int v4; // edx@5
  int v5; // ecx@5
  __int64 v6; // qcx@16
  int v7; // edx@17
  __int64 v8; // qcx@17
  int v9; // eax@19
  int v10; // edx@22
  int v11; // eax@24
  int v12; // ebx@25
  int v13; // esi@25
  int v14; // eax@25
  int v15; // eax@27
  unsigned __int64 v16; // ST04_8@27
  unsigned __int8 v17; // cf@28
  int v18; // eax@29
  int v19; // ebx@29
  unsigned int v20; // esi@29
  unsigned __int64 v21; // ST04_8@29
  int v22; // esi@29
  int v23; // edx@29
  int v24; // ebx@29
  __int64 v25; // qax@29
  unsigned __int8 v26; // cf@29
  unsigned __int64 v27; // ST04_8@29
  unsigned __int8 v28; // cf@30
  int v29; // eax@31
  int v30; // ebx@31
  unsigned int v31; // esi@31
  unsigned __int64 v32; // ST04_8@31
  int v33; // esi@31
  int v34; // edx@31
  int v35; // ebx@31
  __int64 v36; // qax@31
  unsigned __int8 v37; // cf@31
  unsigned __int64 v38; // ST04_8@31
  unsigned __int8 v39; // cf@32
  int v40; // eax@33
  int v41; // edx@33
  int v42; // ecx@33
  unsigned __int64 v43; // ST04_8@33
  int v44; // edx@36
  int v45; // eax@42
  int v46; // edx@42
  int v47; // [sp-4h] [bp-24h]@17
  int v48; // [sp-4h] [bp-24h]@22
  __int64 v49; // [sp+Ch] [bp-14h]@17
  int v50; // [sp+14h] [bp-Ch]@1
  int v51; // [sp+18h] [bp-8h]@1
  int v52; // [sp+1Ch] [bp-4h]@1

  v51 = 0;
  v50 = 0;
  v52 = 0;
  if ( !a1 || (sub_10039210((void *)a1, 0xFFu, 36), !a2) )
  {
    v2 = 22;
    *(_DWORD *)sub_10037669(0) = 22;
    sub_1003A16E(0, a1);
    return v2;
  }
  if ( *(_DWORD *)(a2 + 4) <= 0 && *(_DWORD *)(a2 + 4) < 0
    || *(_DWORD *)(a2 + 4) >= 7 && (*(_DWORD *)(a2 + 4) > 7 || *(_DWORD *)a2 > 0x93406FFFu) )
  {
    v2 = 22;
    *(_DWORD *)sub_10037669(0) = 22;
    return v2;
  }
  sub_1003A4B7(v4, v5, 0, a1);
  if ( sub_1003A1C1(0, a1, (int)&v51) || sub_1003A1EB(0, a1, (int)&v50) || sub_1003A215(0, a1, (int)&v52) )
  {
    sub_1003A17E(0, a1);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003A4B7);
  }
  v6 = *(_QWORD *)a2;
  if ( *(_QWORD *)a2 > 259200i64 )
  {
    v8 = v6 - v52;
    v49 = v8;
    result = sub_10030388(SHIDWORD(v8), a1, a1, (int)&v49);
    if ( result )
      return result;
    if ( v51 )
    {
      sub_1003A507(v7, v47, SHIDWORD(v8), a1, a1);
      if ( v9 )
      {
        v49 -= v50;
        result = sub_10030388(SHIDWORD(v8), a1, a1, (int)&v49);
        if ( result )
          return result;
        *(_DWORD *)(a1 + 32) = 1;
      }
    }
    return 0;
  }
  result = sub_10030388(SHIDWORD(v6), a1, a1, a2);
  if ( result )
    return result;
  if ( v51 && (sub_1003A507(v10, v48, SHIDWORD(v6), a1, a1), v11) )
  {
    v14 = v52 + v50;
    *(_DWORD *)(a1 + 32) = 1;
    v12 = *(_DWORD *)a1 - v14;
    v13 = (unsigned __int64)(*(_DWORD *)a1 - v14) >> 32;
  }
  else
  {
    v12 = *(_DWORD *)a1 - v52;
    v13 = (unsigned __int64)(*(_DWORD *)a1 - v52) >> 32;
  }
  HIDWORD(v16) = v13;
  LODWORD(v16) = v12;
  v15 = sub_1003AD00(v16, 60i64);
  *(_DWORD *)a1 = v15;
  if ( v15 < 0 )
  {
    v17 = (unsigned int)v12 >= 0x3C;
    v12 -= 60;
    *(_DWORD *)a1 = v15 + 60;
    v13 = v17 + v13 - 1;
  }
  HIDWORD(v21) = v13;
  LODWORD(v21) = v12;
  v22 = sub_1003AC50(v21, 0x3Cu, 0);
  v24 = v23;
  v25 = *(_DWORD *)(a1 + 4);
  v26 = (_DWORD)v25 >= (unsigned int)-v22;
  v20 = v25 + v22;
  v19 = HIDWORD(v25) + v26 + v24;
  HIDWORD(v27) = v19;
  LODWORD(v27) = v20;
  v18 = sub_1003AD00(v27, 60i64);
  *(_DWORD *)(a1 + 4) = v18;
  if ( v18 < 0 )
  {
    v28 = v20 >= 0x3C;
    v20 -= 60;
    *(_DWORD *)(a1 + 4) = v18 + 60;
    v19 = v28 + v19 - 1;
  }
  HIDWORD(v32) = v19;
  LODWORD(v32) = v20;
  v33 = sub_1003AC50(v32, 0x3Cu, 0);
  v35 = v34;
  v36 = *(_DWORD *)(a1 + 8);
  v37 = (_DWORD)v36 >= (unsigned int)-v33;
  v31 = v36 + v33;
  v30 = HIDWORD(v36) + v37 + v35;
  HIDWORD(v38) = v30;
  LODWORD(v38) = v31;
  v29 = sub_1003AD00(v38, 24i64);
  *(_DWORD *)(a1 + 8) = v29;
  if ( v29 < 0 )
  {
    v39 = v31 >= 0x18;
    v31 -= 24;
    *(_DWORD *)(a1 + 8) = v29 + 24;
    v30 = v39 + v30 - 1;
  }
  HIDWORD(v43) = v30;
  LODWORD(v43) = v31;
  v40 = sub_1003AC50(v43, 0x18u, 0);
  v42 = v40;
  if ( v41 >= 0 )
  {
    if ( v41 > 0 || v40 )
    {
      v44 = (v40 + *(_DWORD *)(a1 + 24)) % 7;
      *(_DWORD *)(a1 + 12) += v40;
      *(_DWORD *)(a1 + 24) = v44;
      goto LABEL_37;
    }
    if ( v41 > 0 || v41 >= 0 )
      return 0;
  }
  v46 = (v40 + *(_DWORD *)(a1 + 24) + 7) % 7;
  *(_DWORD *)(a1 + 12) += v40;
  v45 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 24) = v46;
  if ( v45 <= 0 )
  {
    *(_DWORD *)(a1 + 12) = v45 + 31;
    *(_DWORD *)(a1 + 28) += v42 + 365;
    --*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 16) = 11;
    return 0;
  }
LABEL_37:
  *(_DWORD *)(a1 + 28) += v42;
  return 0;
}

//----- (1003A4B7) --------------------------------------------------------
void __usercall sub_1003A4B7(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // edx@2
  int v5; // [sp-4h] [bp-2Ch]@2

  if ( !dword_100768AC )
  {
    sub_10036A43(a1, a2, a3, a4, 6);
    if ( !dword_100768AC )
    {
      sub_1003A731(v4, v5, a4);
      ++dword_100768AC;
    }
    sub_10036BA7(6);
  }
}
// 100768AC: using guessed type int dword_100768AC;

//----- (1003A507) --------------------------------------------------------
void __usercall sub_1003A507(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  sub_10036A43(a1, a2, a3, a4, 6);
  sub_1003A54D(a4, a5);
  sub_10036BA7(6);
}

//----- (1003A54D) --------------------------------------------------------
char __usercall sub_1003A54D<al>(int a1<edi>, int a2)
{
  signed int v2; // eax@1
  signed int v3; // ecx@3
  signed int v4; // eax@13
  signed int v5; // edx@13
  signed int v6; // ebx@13
  signed int v7; // edi@13
  int v8; // edx@16
  int v9; // ecx@28
  signed int v11; // [sp-30h] [bp-38h]@7
  signed int v12; // [sp-30h] [bp-38h]@10
  int v13; // [sp-2Ch] [bp-34h]@7
  int v14; // [sp-2Ch] [bp-34h]@10
  int v15; // [sp-28h] [bp-30h]@7
  int v16; // [sp-28h] [bp-30h]@10
  int v17; // [sp-24h] [bp-2Ch]@7
  int v18; // [sp-24h] [bp-2Ch]@10
  int v19; // [sp-20h] [bp-28h]@7
  int v20; // [sp-20h] [bp-28h]@10
  int v21; // [sp-1Ch] [bp-24h]@7
  int v22; // [sp-1Ch] [bp-24h]@10
  int v23; // [sp+4h] [bp-4h]@1

  v23 = 0;
  v2 = sub_1003A1C1(0, a1, (int)&v23);
  if ( v2 )
  {
    sub_1003A17E(0, a1);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003A731);
  }
  if ( v23 )
  {
    v3 = *(_DWORD *)(a2 + 20);
    if ( v3 != dword_100742D8 || v3 != dword_100742E4 )
    {
      if ( dword_100768B0 )
      {
        if ( TimeZoneInformation.DaylightDate.wYear )
        {
          v21 = TimeZoneInformation.DaylightDate.wDay;
          v19 = 0;
          v17 = 0;
          v15 = TimeZoneInformation.DaylightDate.wMonth;
          v13 = *(_DWORD *)(a2 + 20);
          v11 = 0;
        }
        else
        {
          v21 = 0;
          v19 = TimeZoneInformation.DaylightDate.wDayOfWeek;
          v17 = TimeZoneInformation.DaylightDate.wDay;
          v15 = TimeZoneInformation.DaylightDate.wMonth;
          v13 = *(_DWORD *)(a2 + 20);
          v11 = 1;
        }
        loc_1003AA65(
          1,
          v11,
          v13,
          v15,
          v17,
          v19,
          v21,
          TimeZoneInformation.DaylightDate.wHour,
          TimeZoneInformation.DaylightDate.wMinute,
          TimeZoneInformation.DaylightDate.wSecond,
          TimeZoneInformation.DaylightDate.wMilliseconds);
        if ( TimeZoneInformation.StandardDate.wYear )
        {
          v22 = TimeZoneInformation.StandardDate.wDay;
          v20 = 0;
          v18 = 0;
          v16 = TimeZoneInformation.StandardDate.wMonth;
          v14 = *(_DWORD *)(a2 + 20);
          v12 = 0;
        }
        else
        {
          v22 = 0;
          v20 = TimeZoneInformation.StandardDate.wDayOfWeek;
          v18 = TimeZoneInformation.StandardDate.wDay;
          v16 = TimeZoneInformation.StandardDate.wMonth;
          v14 = *(_DWORD *)(a2 + 20);
          v12 = 1;
        }
        loc_1003AA65(
          0,
          v12,
          v14,
          v16,
          v18,
          v20,
          v22,
          TimeZoneInformation.StandardDate.wHour,
          TimeZoneInformation.StandardDate.wMinute,
          TimeZoneInformation.StandardDate.wSecond,
          TimeZoneInformation.StandardDate.wMilliseconds);
      }
      else
      {
        v4 = 3;
        v5 = 2;
        v6 = 1;
        v7 = 11;
        if ( v3 < 107 )
        {
          v4 = 4;
          v7 = 10;
          v5 = 1;
          v6 = 5;
        }
        loc_1003AA65(1, 1, v3, v4, v5, 0, 0, 2, 0, 0, 0);
        loc_1003AA65(0, 1, *(_DWORD *)(a2 + 20), v7, v6, 0, 0, 2, 0, 0, 0);
      }
    }
    v8 = *(_DWORD *)(a2 + 28);
    if ( dword_100742DC >= dword_100742E8 )
    {
      if ( v8 < dword_100742E8 || v8 > dword_100742DC )
        goto LABEL_21;
      if ( v8 <= dword_100742E8 || v8 >= dword_100742DC )
        goto LABEL_28;
    }
    else
    {
      if ( v8 >= dword_100742DC && v8 <= dword_100742E8 )
      {
        if ( v8 > dword_100742DC && v8 < dword_100742E8 )
        {
LABEL_21:
          LOBYTE(v2) = 1;
          return v2;
        }
LABEL_28:
        v9 = 1000 * (*(_DWORD *)a2 + 60 * (*(_DWORD *)(a2 + 4) + 60 * *(_DWORD *)(a2 + 8)));
        if ( v8 == dword_100742DC )
          LOBYTE(v2) = v9 >= dword_100742E0;
        else
          LOBYTE(v2) = v9 < dword_100742EC;
        return v2;
      }
    }
    LOBYTE(v2) = 0;
  }
  return v2;
}
// 100742D8: using guessed type int dword_100742D8;
// 100742DC: using guessed type int dword_100742DC;
// 100742E0: using guessed type int dword_100742E0;
// 100742E4: using guessed type int dword_100742E4;
// 100742E8: using guessed type int dword_100742E8;
// 100742EC: using guessed type int dword_100742EC;
// 100768B0: using guessed type int dword_100768B0;

//----- (1003A731) --------------------------------------------------------
void __usercall sub_1003A731(int a1<edx>, int a2<ecx>, int a3<edi>)
{
  int v3; // eax@4
  int v4; // eax@10
  int v5; // edx@10
  int v6; // ecx@10
  int v7; // eax@12
  int v21; // [sp+18h] [bp-38h]@23
  BOOL UsedDefaultChar; // [sp+20h] [bp-30h]@23
  int v23; // [sp+24h] [bp-2Ch]@1
  int v24; // [sp+28h] [bp-28h]@1
  int v25; // [sp+2Ch] [bp-24h]@1
  void **v26; // [sp+30h] [bp-20h]@1
  int v27; // [sp+34h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+38h] [bp-18h]@1

  v23 = 0;
  v27 = 0;
  v25 = 0;
  v24 = 0;
  sub_10036A43(a1, a2, 0, a3, 7);
  ms_exc.disabled = 0;
  v26 = sub_1003A1BB();
  if ( !sub_1003A215(0, a3, (int)&v27) && !sub_1003A1C1(0, a3, (int)&v25) && !sub_1003A1EB(0, a3, (int)&v24) )
  {
    v21 = sub_10036EA7(0, a3);
    dword_100768B0 = 0;
    dword_100742E4 = -1;
    dword_100742D8 = -1;
    v3 = sub_1004B050(0, (int)"TZ");
    a3 = v3;
    if ( !v3 || !*(_BYTE *)v3 )
      goto LABEL_14;
    if ( lpMem )
    {
      if ( !sub_10039310(v3, (int)lpMem) )
      {
LABEL_11:
        v23 = 1;
        goto LABEL_32;
      }
      if ( lpMem )
        sub_100309A2(0, lpMem);
    }
    v4 = sub_10035550(a3);
    lpMem = (LPVOID)sub_10037550(v5, v6, 0, v4 + 1);
    if ( !lpMem )
      goto LABEL_11;
    v7 = sub_10035550(a3);
    if ( !sub_1003ADE5(0, a3, (int)lpMem, v7 + 1, a3) )
      goto LABEL_32;
  }
  sub_1003A17E(0, a3);
LABEL_14:
  if ( lpMem )
  {
    sub_100309A2(0, lpMem);
    lpMem = 0;
  }
  if ( GetTimeZoneInformation(&TimeZoneInformation) != -1 )
  {
    dword_100768B0 = 1;
    v27 = 60 * TimeZoneInformation.Bias;
    if ( TimeZoneInformation.StandardDate.wMonth )
      v27 = 60 * TimeZoneInformation.StandardBias + 60 * TimeZoneInformation.Bias;
    if ( TimeZoneInformation.DaylightDate.wMonth && TimeZoneInformation.DaylightBias )
    {
      v25 = 1;
      v24 = 60 * (TimeZoneInformation.DaylightBias - TimeZoneInformation.StandardBias);
    }
    else
    {
      v25 = 0;
      v24 = 0;
    }
    if ( !WideCharToMultiByte(v21, 0, TimeZoneInformation.StandardName, -1, (LPSTR)*v26, 63, 0, &UsedDefaultChar)
      || UsedDefaultChar )
      *(_BYTE *)*v26 = 0;
    else
      *((_BYTE *)*v26 + 63) = 0;
    if ( !WideCharToMultiByte(v21, 0, TimeZoneInformation.DaylightName, -1, (LPSTR)v26[1], 63, 0, &UsedDefaultChar)
      || UsedDefaultChar )
      *(_BYTE *)v26[1] = 0;
    else
      *((_BYTE *)v26[1] + 63) = 0;
  }
  v23 = 1;
LABEL_32:
  *sub_1003A1B5() = v27;
  *sub_1003A1A9() = v25;
  *sub_1003A1AF() = v24;
  ms_exc.disabled = -2;
  sub_10036BA7(7);
}
// 100742D8: using guessed type int dword_100742D8;
// 100742E4: using guessed type int dword_100742E4;
// 100768B0: using guessed type int dword_100768B0;

//----- (1003AC50) --------------------------------------------------------
int __stdcall sub_1003AC50(unsigned __int64 a1, unsigned int a2, int a3)
{
  signed int v3; // edi@1
  int v4; // eax@3
  int result; // eax@6
  unsigned __int64 v6; // qtt@6
  unsigned __int64 v7; // qax@7
  unsigned int v8; // ecx@7
  unsigned int v9; // ebx@7
  char v10; // cf@8
  char v11; // cf@8
  int v12; // eax@9
  unsigned __int64 v13; // qax@9
  int v14; // esi@9
  int v15; // ecx@9
  char v16; // cf@9

  v3 = 0;
  if ( HIDWORD(a1) < 0 )
  {
    v3 = 1;
    HIDWORD(a1) = -HIDWORD(a1) - ((_DWORD)a1 != 0);
    LODWORD(a1) = -(_DWORD)a1;
  }
  v4 = a3;
  if ( a3 < 0 )
  {
    ++v3;
    v4 = -a3 - (a2 != 0);
    a3 = -a3 - (a2 != 0);
    a2 = -a2;
  }
  if ( v4 )
  {
    v9 = v4;
    v8 = a2;
    v7 = a1;
    do
    {
      v10 = v9 & 1;
      v9 >>= 1;
      v8 = __RCR__(v8, v10);
      v11 = BYTE4(v7) & 1;
      HIDWORD(v7) >>= 1;
      LODWORD(v7) = __RCR__(v7, v11);
    }
    while ( v9 );
    v12 = v7 / v8;
    v14 = v12;
    v15 = a3 * v12;
    v13 = v12 * a2;
    v16 = v15 >= (unsigned int)-HIDWORD(v13);
    HIDWORD(v13) += v15;
    if ( v16 || HIDWORD(v13) > HIDWORD(a1) || v13 > a1 )
      --v14;
    result = v14;
  }
  else
  {
    LODWORD(v6) = a1;
    HIDWORD(v6) = HIDWORD(a1) % a2;
    result = v6 / a2;
  }
  if ( v3 == 1 )
    result = -result;
  return result;
}

//----- (1003AD00) --------------------------------------------------------
int __stdcall sub_1003AD00(unsigned __int64 a1, __int64 a2)
{
  signed int v2; // edi@1
  int v3; // eax@3
  unsigned __int64 v4; // qax@6
  unsigned __int64 v5; // qtt@6
  unsigned __int64 v6; // qax@8
  unsigned int v7; // ecx@8
  unsigned int v8; // ebx@8
  char v9; // cf@9
  char v10; // cf@9
  int v11; // eax@10
  unsigned __int64 v12; // qax@10
  int v13; // ecx@10
  char v14; // cf@10

  v2 = 0;
  if ( HIDWORD(a1) < 0 )
  {
    v2 = 1;
    HIDWORD(a1) = -HIDWORD(a1) - ((_DWORD)a1 != 0);
    LODWORD(a1) = -(_DWORD)a1;
  }
  v3 = HIDWORD(a2);
  if ( HIDWORD(a2) < 0 )
  {
    v3 = -HIDWORD(a2) - ((_DWORD)a2 != 0);
    HIDWORD(a2) = -HIDWORD(a2) - ((_DWORD)a2 != 0);
    LODWORD(a2) = -(_DWORD)a2;
  }
  if ( !v3 )
  {
    LODWORD(v5) = a1;
    HIDWORD(v5) = HIDWORD(a1) % (_DWORD)a2;
    LODWORD(v4) = v5 % (unsigned int)a2;
    if ( v2 - 1 < 0 )
      return v4;
    goto LABEL_15;
  }
  v8 = v3;
  v7 = a2;
  v6 = a1;
  do
  {
    v9 = v8 & 1;
    v8 >>= 1;
    v7 = __RCR__(v7, v9);
    v10 = BYTE4(v6) & 1;
    HIDWORD(v6) >>= 1;
    LODWORD(v6) = __RCR__(v6, v10);
  }
  while ( v8 );
  v11 = v6 / v7;
  v13 = HIDWORD(a2) * v11;
  v12 = (unsigned int)a2 * v11;
  v14 = v13 >= (unsigned int)-HIDWORD(v12);
  HIDWORD(v12) += v13;
  if ( v14 || HIDWORD(v12) > HIDWORD(a1) || v12 > a1 )
    v12 -= a2;
  v4 = v12 - a1;
  if ( v2 - 1 < 0 )
LABEL_15:
    LODWORD(v4) = -(_DWORD)v4;
  return v4;
}

//----- (1003ADB2) --------------------------------------------------------
bool __cdecl sub_1003ADB2(int a1)
{
  PVOID v1; // eax@1

  v1 = DecodePointer(dword_10076964);
  return v1 && ((int (__cdecl *)(int))v1)(a1);
}

//----- (1003ADD8) --------------------------------------------------------
void *__cdecl sub_1003ADD8(void *a1)
{
  void *result; // eax@1

  result = a1;
  dword_10076964 = a1;
  return result;
}

//----- (1003ADE5) --------------------------------------------------------
signed int __usercall sub_1003ADE5<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  int v5; // edx@2
  int v6; // ecx@3
  int v7; // eax@5
  char v9; // al@8
  signed int v10; // [sp-4h] [bp-8h]@5

  if ( !a3 || (v5 = a4, !a4) )
    goto LABEL_5;
  v6 = a5;
  if ( !a5 )
  {
    *(_BYTE *)a3 = a5;
LABEL_5:
    v7 = sub_10037669(a1);
    v10 = 22;
LABEL_6:
    *(_DWORD *)v7 = v10;
    sub_1003A16E(a1, a2);
    return v10;
  }
  do
  {
    v9 = *(_BYTE *)v6;
    *(_BYTE *)(a3 - a5 + v6) = *(_BYTE *)v6;
    ++v6;
    if ( !v9 )
      break;
    --v5;
  }
  while ( v5 );
  if ( !v5 )
  {
    *(_BYTE *)a3 = 0;
    v7 = sub_10037669(a1);
    v10 = 34;
    goto LABEL_6;
  }
  return 0;
}

//----- (1003AE3A) --------------------------------------------------------
int (__stdcall *__thiscall sub_1003AE3A(HMODULE this, int a2))()
{
  int (__stdcall *result)(); // eax@1
  HMODULE hModule; // [sp+0h] [bp-4h]@1

  hModule = this;
  result = (int (__stdcall *)())GetModuleHandleExW(0, L"mscoree.dll", &hModule);
  if ( result )
  {
    result = GetProcAddress(hModule, "CorExitProcess");
    if ( result )
      result = (int (__stdcall *)())((int (__stdcall *)(int))result)(a2);
  }
  return result;
}

//----- (1003AE6C) --------------------------------------------------------
void __thiscall sub_1003AE6C(HMODULE this, UINT uExitCode)
{
  sub_1003AE3A(this, uExitCode);
  ExitProcess(uExitCode);
}

//----- (1003AE82) --------------------------------------------------------
void __usercall sub_1003AE82(int a1<ebx>)
{
  PVOID v1; // edi@1
  LPVOID v2; // esi@1
  char v3; // zf@3
  LPVOID v4; // esi@5
  char v5; // zf@7

  v2 = dword_10076990;
  v1 = DecodePointer(Ptr);
  if ( dword_10076990 )
  {
    do
    {
      if ( !*(_DWORD *)v2 )
        break;
      sub_100309A2(a1, *(LPVOID *)v2);
      v3 = (char *)v2 + 4 == 0;
      v2 = (char *)v2 + 4;
    }
    while ( !v3 );
    v2 = dword_10076990;
  }
  sub_100309A2(a1, v2);
  v4 = dword_1007698C;
  dword_10076990 = 0;
  if ( dword_1007698C )
  {
    do
    {
      if ( !*(_DWORD *)v4 )
        break;
      sub_100309A2(0, *(LPVOID *)v4);
      v5 = (char *)v4 + 4 == 0;
      v4 = (char *)v4 + 4;
    }
    while ( !v5 );
    v4 = dword_1007698C;
  }
  sub_100309A2(0, v4);
  dword_1007698C = 0;
  sub_100309A2(0, dword_10076988);
  sub_100309A2(0, dword_10076984);
  dword_10076988 = 0;
  dword_10076984 = 0;
  if ( v1 != (PVOID)-1 )
  {
    if ( Ptr )
      sub_100309A2(0, v1);
  }
  Ptr = EncodePointer((PVOID)0xFFFFFFFF);
  if ( dword_100772C0 )
  {
    sub_100309A2(0, dword_100772C0);
    dword_100772C0 = 0;
  }
  if ( dword_100772C4 )
  {
    sub_100309A2(0, dword_100772C4);
    dword_100772C4 = 0;
  }
  if ( !InterlockedDecrement((volatile LONG *)lpAddend) )
  {
    if ( lpAddend != &unk_100747B8 )
    {
      sub_100309A2(a1, lpAddend);
      lpAddend = &unk_100747B8;
    }
  }
}

//----- (1003AF92) --------------------------------------------------------
void __usercall sub_1003AF92(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // edx@1
  int v6; // ST00_4@1

  sub_1003F5BC(a1, a2, a3, a4);
  sub_1003F619(a3, a5);
  sub_1003B04F(v5, v6, a3, a4, 0xFFu);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_1003AFAE);
}

//----- (1003AFAE) --------------------------------------------------------
void __usercall sub_1003AFAE(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  sub_1003B0EB(a1, a2, a3, a4, 0, 0, 1);
}

//----- (1003AFBE) --------------------------------------------------------
int __usercall sub_1003AFBE<eax>(int a1<eax>, int a2<ebx>, int a3<edi>, int a4)
{
  int result; // eax@4
  int v5; // edx@4
  int v6; // eax@5
  unsigned int i; // esi@5
  int v8; // [sp-4h] [bp-4h]@4
  int v9; // [sp-4h] [bp-4h]@11

  if ( off_100627E0 )
  {
    if ( sub_1004B130(a1, (int)&off_100627E0) )
      off_100627E0(a4);
  }
  sub_1004AACC();
  result = sub_1003B0B7((unsigned int)&unk_10060288, (unsigned int)&unk_100602A0);
  if ( !result )
  {
    v6 = sub_1002B10A(v5, v8, a2, a3, sub_10048A81);
    for ( i = (unsigned int)&unk_10060200; i < (unsigned int)&unk_10060284; i += 4 )
    {
      v6 = *(_DWORD *)i;
      if ( *(_DWORD *)i )
        v6 = ((int (*)(void))v6)();
    }
    if ( dword_10078AC4 )
    {
      if ( sub_1004B130(v6, (int)&dword_10078AC4) )
        dword_10078AC4(v9, 0, 2, 0);
    }
    result = 0;
  }
  return result;
}
// 100627E0: using guessed type int (__cdecl *off_100627E0)(_DWORD);
// 10078AC4: using guessed type int (__thiscall *dword_10078AC4)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003B04F) --------------------------------------------------------
void __usercall sub_1003B04F(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, UINT uExitCode)
{
  sub_1003B0EB(a1, a2, a3, a4, uExitCode, 1, 0);
}

//----- (1003B063) --------------------------------------------------------
unsigned int __cdecl sub_1003B063()
{
  HMODULE v0; // edi@1
  unsigned int result; // eax@1
  PVOID v2; // esi@1

  v2 = EncodePointer(0);
  sub_1003ADD8(v2);
  sub_1003A136(v2);
  sub_1003F9AB(v2);
  sub_1004B221((int)v2);
  sub_1004940E((int)v2);
  sub_1003B4C4();
  v0 = GetModuleHandleW(L"kernel32.dll");
  dword_10078AE0 = __security_cookie ^ (int)GetProcAddress(v0, "FlsAlloc");
  dword_10078AE4 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "FlsFree");
  dword_10078AE8 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "FlsGetValue");
  dword_10078AEC = __security_cookie ^ (unsigned int)GetProcAddress(v0, "FlsSetValue");
  dword_10078AF0 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "InitializeCriticalSectionEx");
  dword_10078AF4 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CreateSemaphoreExW");
  dword_10078AF8 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "SetThreadStackGuarantee");
  dword_10078AFC = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CreateThreadpoolTimer");
  dword_10078B00 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "SetThreadpoolTimer");
  dword_10078B04 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "WaitForThreadpoolTimerCallbacks");
  dword_10078B08 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CloseThreadpoolTimer");
  dword_10078B0C = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CreateThreadpoolWait");
  dword_10078B10 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "SetThreadpoolWait");
  dword_10078B14 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CloseThreadpoolWait");
  dword_10078B18 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "FlushProcessWriteBuffers");
  dword_10078B1C = __security_cookie ^ (unsigned int)GetProcAddress(v0, "FreeLibraryWhenCallbackReturns");
  dword_10078B20 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetCurrentProcessorNumber");
  dword_10078B24 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetLogicalProcessorInformation");
  dword_10078B28 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CreateSymbolicLinkW");
  dword_10078B2C = __security_cookie ^ (unsigned int)GetProcAddress(v0, "SetDefaultDllDirectories");
  dword_10078B34 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "EnumSystemLocalesEx");
  dword_10078B30 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CompareStringEx");
  dword_10078B38 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetDateFormatEx");
  dword_10078B3C = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetLocaleInfoEx");
  dword_10078B40 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetTimeFormatEx");
  dword_10078B44 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetUserDefaultLocaleName");
  dword_10078B48 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "IsValidLocaleName");
  dword_10078B4C = __security_cookie ^ (unsigned int)GetProcAddress(v0, "LCMapStringEx");
  result = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetCurrentPackageId");
  dword_10078B50 = result;
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10078AE0: using guessed type int dword_10078AE0;
// 10078AE4: using guessed type int dword_10078AE4;
// 10078AE8: using guessed type int dword_10078AE8;
// 10078AEC: using guessed type int dword_10078AEC;
// 10078AF0: using guessed type int dword_10078AF0;
// 10078AF4: using guessed type int dword_10078AF4;
// 10078AF8: using guessed type int dword_10078AF8;
// 10078AFC: using guessed type int dword_10078AFC;
// 10078B00: using guessed type int dword_10078B00;
// 10078B04: using guessed type int dword_10078B04;
// 10078B08: using guessed type int dword_10078B08;
// 10078B0C: using guessed type int dword_10078B0C;
// 10078B10: using guessed type int dword_10078B10;
// 10078B14: using guessed type int dword_10078B14;
// 10078B18: using guessed type int dword_10078B18;
// 10078B1C: using guessed type int dword_10078B1C;
// 10078B20: using guessed type int dword_10078B20;
// 10078B24: using guessed type int dword_10078B24;
// 10078B28: using guessed type int dword_10078B28;
// 10078B2C: using guessed type int dword_10078B2C;
// 10078B30: using guessed type int dword_10078B30;
// 10078B34: using guessed type int dword_10078B34;
// 10078B38: using guessed type int dword_10078B38;
// 10078B3C: using guessed type int dword_10078B3C;
// 10078B40: using guessed type int dword_10078B40;
// 10078B44: using guessed type int dword_10078B44;
// 10078B48: using guessed type int dword_10078B48;
// 10078B4C: using guessed type int dword_10078B4C;
// 10078B50: using guessed type int dword_10078B50;

//----- (1003B09B) --------------------------------------------------------
void __cdecl sub_1003B09B(unsigned int a1, unsigned int a2)
{
  unsigned int i; // esi@1

  for ( i = a1; i < a2; i += 4 )
  {
    if ( *(_DWORD *)i )
      (*(void (**)(void))i)();
  }
}

//----- (1003B0B7) --------------------------------------------------------
int __cdecl sub_1003B0B7(unsigned int a1, unsigned int a2)
{
  int result; // eax@1
  unsigned int v3; // esi@1

  v3 = a1;
  result = 0;
  while ( v3 < a2 && !result )
  {
    if ( *(_DWORD *)v3 )
      result = (*(int (**)(void))v3)();
    v3 += 4;
  }
  return result;
}

//----- (1003B0D9) --------------------------------------------------------
void __usercall sub_1003B0D9(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  sub_10036A43(a1, a2, a3, a4, 8);
}

//----- (1003B0E2) --------------------------------------------------------
void __cdecl sub_1003B0E2()
{
  sub_10036BA7(8);
}

//----- (1003B0EB) --------------------------------------------------------
void __usercall sub_1003B0EB(int a1<edx>, int ecx0<ecx>, int ebx0<ebx>, int a4<edi>, UINT uExitCode, int a2, int a3)
{
  PVOID v7; // ebx@3
  PVOID (__stdcall *v8)(PVOID); // esi@3
  PVOID v9; // edi@4
  PVOID v10; // eax@8
  void (*v11)(void); // esi@8
  PVOID v12; // [sp+14h] [bp-28h]@8
  PVOID v13; // [sp+1Ch] [bp-20h]@4
  PVOID v14; // [sp+20h] [bp-1Ch]@4

  sub_10036A43(a1, ecx0, ebx0, a4, 8);
  if ( dword_1007697C != 1 )
  {
    dword_10076970 = 1;
    byte_1007696C = a3;
    if ( !a2 )
    {
      v8 = DecodePointer;
      v7 = DecodePointer(Ptr);
      if ( v7 )
      {
        v9 = DecodePointer(dword_10078AC8);
        v14 = v7;
        v13 = v9;
        while ( 1 )
        {
          v9 = (char *)v9 - 4;
          if ( v9 < v7 )
            break;
          if ( *(PVOID *)v9 != EncodePointer(0) )
          {
            if ( v9 < v7 )
              break;
            v11 = (void (*)(void))v8(*(PVOID *)v9);
            *(_DWORD *)v9 = EncodePointer(0);
            v11();
            v8 = DecodePointer;
            v12 = DecodePointer(Ptr);
            v10 = DecodePointer(dword_10078AC8);
            if ( v14 != v12 || v13 != v10 )
            {
              v14 = v12;
              v7 = v12;
              v13 = v10;
              v9 = v10;
            }
          }
        }
      }
      sub_1003B09B((unsigned int)&unk_100602A4, (unsigned int)&unk_100602B8);
    }
    sub_1003B09B((unsigned int)&unk_100602BC, (unsigned int)&unk_100602C0);
  }
  if ( a3 )
    sub_10036BA7(8);
}
// 1007696C: using guessed type char byte_1007696C;
// 10076970: using guessed type int dword_10076970;
// 1007697C: using guessed type int dword_1007697C;

//----- (1003B21A) --------------------------------------------------------
SIZE_T __usercall sub_1003B21A<eax>(int a1<ebx>, int a2<edi>, LPCVOID lpMem)
{
  SIZE_T result; // eax@2

  if ( lpMem )
  {
    result = HeapSize(hHeap, 0, lpMem);
  }
  else
  {
    *(_DWORD *)sub_10037669(a1) = 22;
    sub_1003A16E(a1, a2);
    result = -1;
  }
  return result;
}

//----- (1003B2B0) --------------------------------------------------------
int __cdecl sub_1003B2B0(PEXCEPTION_RECORD ExceptionRecord, int TargetFrame, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // eax@4
  void *v7; // ecx@5
  int v8; // eax@5
  int v9; // eax@6
  char v10; // cl@6
  int v11; // eax@12
  char v13; // [sp+0h] [bp-24h]@3
  char v14; // [sp+0h] [bp-24h]@3
  PEXCEPTION_RECORD v15; // [sp+Ch] [bp-18h]@4
  int v16; // [sp+10h] [bp-14h]@4
  int v17; // [sp+14h] [bp-10h]@5
  int v18; // [sp+18h] [bp-Ch]@1
  unsigned int v19; // [sp+1Ch] [bp-8h]@4
  char v20; // [sp+23h] [bp-1h]@1

  v3 = TargetFrame;
  v4 = __security_cookie ^ *(_DWORD *)(TargetFrame + 8);
  v20 = 0;
  v18 = 1;
  v5 = TargetFrame + 16;
  if ( *(_DWORD *)v4 != -2 )
    sub_1002A49B(TargetFrame, v4, v5, *(_DWORD *)(*(_DWORD *)v4 + v5) ^ (v5 + *(_DWORD *)(v4 + 4)), v13);
  sub_1002A49B(TargetFrame, v4, v5, *(_DWORD *)(*(_DWORD *)(v4 + 8) + v5) ^ (v5 + *(_DWORD *)(v4 + 12)), v13);
  if ( ExceptionRecord->ExceptionFlags & 0x66 )
  {
    if ( *(_DWORD *)(TargetFrame + 12) == -2 )
      return v18;
    sub_1004B36B(TargetFrame, 0xFFFFFFFEu, v5, (int)&__security_cookie);
  }
  else
  {
    v15 = ExceptionRecord;
    v16 = a3;
    *(_DWORD *)(TargetFrame - 4) = &v15;
    v6 = *(_DWORD *)(TargetFrame + 12);
    v19 = v6;
    if ( v6 == -2 )
      return v18;
    do
    {
      v8 = 3 * v6 + 4;
      v7 = *(void **)(v4 + 4 * v8 + 4);
      v3 = *(_DWORD *)(v4 + 4 * v8);
      v17 = v4 + 4 * v8;
      if ( v7 )
      {
        v9 = sub_1004B322(v7);
        v10 = 1;
        v20 = 1;
        if ( v9 < 0 )
        {
          v18 = 0;
          goto LABEL_23;
        }
        if ( v9 > 0 )
        {
          if ( ExceptionRecord->ExceptionCode == -529697949 )
          {
            if ( off_10061FD4 )
            {
              if ( sub_1004B130((int)ExceptionRecord, (int)&off_10061FD4) )
                off_10061FD4(ExceptionRecord, 1);
            }
          }
          sub_1004B352((PVOID)TargetFrame, ExceptionRecord);
          v11 = TargetFrame;
          if ( *(_DWORD *)(TargetFrame + 12) != v19 )
          {
            sub_1004B36B(TargetFrame, v19, v5, (int)&__security_cookie);
            v11 = TargetFrame;
          }
          *(_DWORD *)(v11 + 12) = v3;
          if ( *(_DWORD *)v4 != -2 )
            sub_1002A49B(v3, v4, v5, *(_DWORD *)(*(_DWORD *)v4 + v5) ^ (v5 + *(_DWORD *)(v4 + 4)), v14);
          sub_1002A49B(v3, v4, v5, *(_DWORD *)(*(_DWORD *)(v4 + 8) + v5) ^ (v5 + *(_DWORD *)(v4 + 12)), v14);
          sub_1004B339(*(_DWORD *)(v17 + 8), v5);
          __asm { int     3               ; Trap to Debugger }
          JUMPOUT(*(int *)sub_1003B445);
        }
      }
      else
      {
        v10 = v20;
      }
      v6 = v3;
      v19 = v3;
    }
    while ( v3 != -2 );
    if ( !v10 )
      return v18;
  }
LABEL_23:
  if ( *(_DWORD *)v4 != -2 )
    sub_1002A49B(v3, v4, v5, *(_DWORD *)(*(_DWORD *)v4 + v5) ^ (v5 + *(_DWORD *)(v4 + 4)), v14);
  sub_1002A49B(v3, v4, v5, *(_DWORD *)(*(_DWORD *)(v4 + 8) + v5) ^ (v5 + *(_DWORD *)(v4 + 12)), v14);
  return v18;
}
// 10061FD4: using guessed type int (__cdecl *off_10061FD4)(_DWORD, _DWORD);
// 10074200: using guessed type int __security_cookie;

//----- (1003B445) --------------------------------------------------------
void __usercall sub_1003B445(int a1<ebx>, int a2<edi>)
{
  void (*v2)(void); // eax@1

  v2 = (void (*)(void))DecodePointer(dword_1007699C);
  if ( v2 )
    v2();
  sub_1003B47D(a1, a2);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_1003B47D);
}

//----- (1003B47D) --------------------------------------------------------
void __usercall sub_1003B47D(int a1<ebx>, int a2<edi>)
{
  void (*v2)(void); // eax@1

  v2 = *(void (**)(void))(sub_10041A5C(a1, a2) + 120);
  if ( v2 )
    v2();
  loc_100392BF();
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_1003B4B1);
}

//----- (1003B4B1) --------------------------------------------------------
void __usercall sub_1003B4B1(int a1<ebx>, int a2<edi>)
{
  void (*v2)(void); // eax@1

  v2 = *(void (**)(void))(sub_10041A5C(a1, a2) + 124);
  if ( v2 )
    v2();
  sub_1003B47D(a1, a2);
}

//----- (1003B4C4) --------------------------------------------------------
PVOID __cdecl sub_1003B4C4()
{
  PVOID result; // eax@1

  result = EncodePointer(sub_1003B47D);
  dword_1007699C = result;
  return result;
}

//----- (1003B4D5) --------------------------------------------------------
int __cdecl sub_1003B4D5()
{
  int v0; // esi@1
  HMODULE v1; // esi@1
  int v2; // eax@3
  HMODULE v3; // eax@3
  int v4; // eax@4
  int result; // eax@6
  char v6; // [sp+8h] [bp-14h]@9
  int v7; // [sp+18h] [bp-4h]@1

  v1 = GetModuleHandleW(L"kernel32.dll");
  v7 = (int)GetProcAddress(v1, "SetThreadGroupAffinity");
  v0 = (int)GetProcAddress(v1, "GetThreadGroupAffinity");
  if ( !v7 || !v0 )
  {
    v4 = GetLastError();
    if ( v4 > 0 )
LABEL_8:
      v4 = (unsigned __int16)v4 | 0x80070000;
LABEL_9:
    sub_10030079((int)&v6, v4);
    sub_100355DB((int)&v6, (int)&unk_1006C6F4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003B587);
  }
  dword_100769A4 = sub_1003491A(v7);
  dword_100769A8 = sub_1003491A(v0);
  v3 = GetModuleHandleW(L"kernel32.dll");
  v2 = (int)GetProcAddress(v3, "GetCurrentProcessorNumberEx");
  if ( !v2 )
  {
    v4 = GetLastError();
    if ( v4 > 0 )
      goto LABEL_8;
    goto LABEL_9;
  }
  result = sub_1003491A(v2);
  dword_100769A0 = result;
  return result;
}
// 100769A0: using guessed type int dword_100769A0;
// 100769A4: using guessed type int dword_100769A4;
// 100769A8: using guessed type int dword_100769A8;

//----- (1003B587) --------------------------------------------------------
DWORD __cdecl sub_1003B587(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent)
{
  DWORD result; // eax@2

  do
  {
    result = DeleteTimerQueueTimer(TimerQueue, Timer, CompletionEvent);
    if ( result )
      break;
    result = GetLastError();
  }
  while ( result != 997 );
  return result;
}

//----- (1003B5AE) --------------------------------------------------------
int __cdecl sub_1003B5AE(int a1)
{
  int v2; // eax@1
  int v3; // ST00_4@1

  v2 = sub_1003491A(dword_100769A0);
  return ((int (__thiscall *)(int, int))v2)(v3, a1);
}
// 100769A0: using guessed type int dword_100769A0;

//----- (1003B5C4) --------------------------------------------------------
int __usercall sub_1003B5C4<eax>(int a1<ebx>, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // ST04_4@1
  int v5; // eax@2
  int v6; // eax@4
  int v7; // ebx@4
  int v8; // eax@5
  int v10; // [sp-4h] [bp-24h]@5
  char v11; // [sp+Ch] [bp-14h]@11
  int (__stdcall **v12)(char); // [sp+10h] [bp-10h]@5
  int v13; // [sp+1Ch] [bp-4h]@5

  sub_10039566(0, a2);
  if ( ((int (__thiscall *)(int))GetLastError)(v4) != 122 )
  {
    v5 = GetLastError();
    if ( v5 > 0 )
LABEL_10:
      v5 = (unsigned __int16)v5 | 0x80070000;
LABEL_11:
    sub_10030079((int)&v11, v5);
    v10 = (int)&unk_1006C6F4;
    v8 = (int)&v11;
    goto LABEL_12;
  }
  v6 = sub_10030910(v2, v3, a1, a2, *(_DWORD *)a2);
  v7 = v6;
  if ( !v6 )
  {
    v13 = (int)"bad allocation";
    sub_1002AEC9((int)&v12, (int)&v13, 1);
    v12 = &off_100602D4;
    v10 = (int)&unk_1006BAB0;
    v8 = (int)&v12;
LABEL_12:
    sub_100355DB(v8, v10);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003B65F);
  }
  if ( !sub_10039566(v6, a2) )
  {
    v5 = GetLastError();
    if ( v5 > 0 )
      goto LABEL_10;
    goto LABEL_11;
  }
  return v7;
}
// 1003B65F: using guessed type int __cdecl sub_1003B65F(int, int);
// 100602D4: using guessed type int (__stdcall *off_100602D4)(char);

//----- (1003B65F) --------------------------------------------------------
int __cdecl sub_1003B65F(int a1, int a2)
{
  FARPROC v2; // eax@1
  int v3; // edi@1
  HMODULE v4; // eax@1
  int v5; // eax@2
  int v6; // edx@4
  int v7; // ecx@4
  int v8; // ebx@7
  int v9; // eax@8
  int v11; // [sp-10h] [bp-30h]@7
  int v12; // [sp-4h] [bp-24h]@4
  char v13; // [sp+Ch] [bp-14h]@12
  int (__stdcall **v14)(char); // [sp+10h] [bp-10h]@8
  int v15; // [sp+1Ch] [bp-4h]@8

  v4 = GetModuleHandleW(L"kernel32.dll");
  v2 = GetProcAddress(v4, "GetLogicalProcessorInformationEx");
  v3 = (int)v2;
  if ( !v2 )
  {
    v5 = GetLastError();
    if ( v5 > 0 )
LABEL_11:
      v5 = (unsigned __int16)v5 | 0x80070000;
LABEL_12:
    sub_10030079((int)&v13, v5);
    v12 = (int)&unk_1006C6F4;
    v9 = (int)&v13;
    goto LABEL_13;
  }
  v12 = a2;
  ((void (__cdecl *)(int, _DWORD))v2)(a1, 0);
  if ( GetLastError() != 122 )
    goto LABEL_17;
  v8 = sub_10030910(v6, v7, a2, v3, *(_DWORD *)a2);
  if ( !v8 )
  {
    v15 = (int)"bad allocation";
    sub_1002AEC9((int)&v14, (int)&v15, 1);
    v14 = &off_100602D4;
    v9 = (int)&v14;
LABEL_13:
    sub_100355DB(v9, v12);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003B719);
  }
  if ( !((int (__thiscall *)(int))v3)(v11) )
  {
LABEL_17:
    v5 = GetLastError();
    if ( v5 > 0 )
      goto LABEL_11;
    goto LABEL_12;
  }
  return v8;
}
// 1003B65F: using guessed type int __cdecl sub_1003B65F(int, int);
// 100602D4: using guessed type int (__stdcall *off_100602D4)(char);

//----- (1003B719) --------------------------------------------------------
signed int __cdecl sub_1003B719(int a1, int a2)
{
  int v2; // eax@2
  int v3; // ST08_4@2
  HANDLE v4; // eax@3
  ULONG_PTR SystemAffinityMask; // [sp+0h] [bp-8h]@3
  ULONG_PTR ProcessAffinityMask; // [sp+4h] [bp-4h]@3

  if ( sub_1003D695() < 4 )
  {
    v4 = GetCurrentProcess();
    GetProcessAffinityMask(v4, &ProcessAffinityMask, &SystemAffinityMask);
    *(_WORD *)(a2 + 4) = 0;
    *(_DWORD *)a2 = ProcessAffinityMask;
  }
  else
  {
    v2 = sub_1003491A(dword_100769A8);
    ((void (__thiscall *)(int, int, int))v2)(v3, a1, a2);
  }
  return 1;
}
// 1003D695: using guessed type int sub_1003D695(void);
// 100769A8: using guessed type int dword_100769A8;

//----- (1003B766) --------------------------------------------------------
signed int __cdecl sub_1003B766(HANDLE hThread, DWORD_PTR *a2)
{
  int v2; // eax@2
  int v3; // ST08_4@2

  if ( sub_1003D695() < 4 )
  {
    SetThreadAffinityMask(hThread, *a2);
  }
  else
  {
    v2 = sub_1003491A(dword_100769A4);
    ((void (__thiscall *)(int, HANDLE, DWORD_PTR *, _DWORD))v2)(v3, hThread, a2, 0);
  }
  return 1;
}
// 1003D695: using guessed type int sub_1003D695(void);
// 100769A4: using guessed type int dword_100769A4;

//----- (1003B79E) --------------------------------------------------------
int __thiscall sub_1003B79E(int this, int a2)
{
  int v3; // esi@1

  v3 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  sub_1003B719(a2, this);
  return v3;
}

//----- (1003B7BF) --------------------------------------------------------
#error "1003B8B3: call analysis failed (funcsize=78)"

//----- (1003B8B9) --------------------------------------------------------
int __userpurge sub_1003B8B9<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10061D0C;
  return v4;
}
// 10061D0C: using guessed type int (__stdcall *off_10061D0C)(char);

//----- (1003B8DE) --------------------------------------------------------
int __usercall sub_1003B8DE<eax>(int a1<ebp>)
{
  unsigned int v1; // edi@1
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // ebx@2
  int v5; // ecx@3
  int v6; // ecx@6
  void *v7; // eax@8
  int v8; // ecx@8
  int v9; // ST08_4@8

  sub_10035668();
  v2 = v3;
  *(_DWORD *)(a1 - 16) = v3;
  *(_DWORD *)v3 = off_10064C1C;
  v1 = 0;
  *(_DWORD *)(a1 - 4) = 1;
  if ( *(_DWORD *)(v3 + 24) )
  {
    v4 = 0;
    do
    {
      v5 = *(_DWORD *)(v4 + *(_DWORD *)(v2 + 72) + 32);
      if ( v5 )
        sub_1002A02D(v5, 3);
      ++v1;
      v4 += 40;
    }
    while ( v1 < *(_DWORD *)(v2 + 24) );
  }
  v6 = *(_DWORD *)(v2 + 72);
  if ( v6 )
    sub_1003B9A5(v6, 3);
  sub_10030383(*(LPVOID *)(v2 + 68));
  v7 = *(void **)(v2 + 140);
  v8 = v9;
  if ( v7 )
    VirtualFree(v7, 0, 0x8000u);
  ((void (__thiscall *)(int, _DWORD))CloseHandle)(v8, *(_DWORD *)(v2 + 80));
  sub_10030383(*(LPVOID *)(v2 + 84));
  if ( *(_DWORD *)(v2 + 76) )
  {
    CloseHandle(*(HANDLE *)(v2 + 76));
    sub_10030383(*(LPVOID *)(v2 + 88));
    sub_10030383(*(LPVOID *)(v2 + 92));
  }
  *(_BYTE *)(a1 - 4) = 0;
  sub_1004CED6(a1);
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002B6CE((LPCRITICAL_SECTION)(v2 + 44));
  return sub_10035636(4);
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 10064C1C: using guessed type int (*off_10064C1C[2])();

//----- (1003B9A5) --------------------------------------------------------
int __thiscall sub_1003B9A5(int this, char a2)
{
  void *v2; // esi@1
  int result; // eax@4

  v2 = (void *)this;
  if ( a2 & 2 )
  {
    sub_1002B11F(this, 40, *(_DWORD *)(this - 4), (void (__thiscall *)(_DWORD))sub_1003B8D4);
    if ( a2 & 1 )
      sub_10030383((char *)v2 - 4);
    result = (int)((char *)v2 - 4);
  }
  else
  {
    sub_1002A4AA(*(LPVOID *)(this + 36));
    if ( a2 & 1 )
      sub_1002A4AA(v2);
    result = (int)v2;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 1003B8D4: using guessed type int sub_1003B8D4();

//----- (1003B9F3) --------------------------------------------------------
int __thiscall sub_1003B9F3(int this, int a2)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 4);
  if ( result )
  {
    *(_DWORD *)(a2 + 24) = *(_DWORD *)(result + 24);
    *(_DWORD *)(a2 + 28) = *(_DWORD *)(this + 4);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 4) + 24) + 28) = a2;
    result = *(_DWORD *)(this + 4);
    *(_DWORD *)(result + 24) = a2;
  }
  else
  {
    *(_DWORD *)(a2 + 24) = a2;
    *(_DWORD *)(a2 + 28) = a2;
  }
  *(_DWORD *)(this + 4) = a2;
  ++*(_DWORD *)this;
  return result;
}

//----- (1003BA2C) --------------------------------------------------------
unsigned int __thiscall sub_1003BA2C(int this, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  unsigned int v6; // esi@5
  int v7; // edx@6
  unsigned int v8; // esi@10
  int v9; // edx@11

  v4 = a3;
  v5 = a2;
  if ( a2 >= a3 )
  {
    v8 = 0;
    if ( a4 )
    {
      do
      {
        v9 = *(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v8++);
        *(_DWORD *)(v9 + 4) = *(_DWORD *)(v9 + 36) - *(_DWORD *)(*(_DWORD *)(v9 + 16) + 160);
      }
      while ( v8 < a4 );
      v4 = a3;
    }
    v5 = v4;
  }
  else
  {
    if ( a4 == 1 )
    {
      *(_DWORD *)(**(_DWORD **)(this + 92) + 4) = a2;
    }
    else
    {
      if ( a4 )
      {
        v6 = 0;
        do
        {
          v7 = *(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v6++);
          *(double *)(v7 + 8) = (double)(unsigned int)(*(_DWORD *)(v7 + 36) - *(_DWORD *)(*(_DWORD *)(v7 + 16) + 160))
                              * (double)a2
                              / (double)a3;
        }
        while ( v6 < a4 );
        v5 = a2;
      }
      sub_1003EF54(*(_DWORD *)(this + 92), a4);
    }
  }
  return v5;
}

//----- (1003BAFC) --------------------------------------------------------
int __thiscall sub_1003BAFC(int this, int a2)
{
  int result; // eax@1

  result = sub_1003D3E4(this, *(_WORD *)(a2 + 4));
  if ( result )
  {
    result = *(_DWORD *)result;
    *(_DWORD *)a2 &= result;
  }
  else
  {
    *(_DWORD *)a2 = 0;
  }
  return result;
}

//----- (1003BB1F) --------------------------------------------------------
int __cdecl sub_1003BB1F(int a1)
{
  int result; // eax@1
  int v2; // [sp+4h] [bp-Ch]@1
  int v3; // [sp+8h] [bp-8h]@1
  int v4; // [sp+Ch] [bp-4h]@1

  v3 = 0;
  v4 = 0;
  LOWORD(v3) = 0;
  v2 = *(_DWORD *)a1;
  sub_1003BB4E((int)&v2);
  result = v2;
  *(_DWORD *)a1 = v2;
  return result;
}

//----- (1003BB4E) --------------------------------------------------------
int __cdecl sub_1003BB4E(int a1)
{
  int result; // eax@1
  int v2; // ecx@2

  result = a1;
  if ( *(_DWORD *)a1 )
  {
    v2 = dword_100769C0;
    if ( dword_100769C0 || (v2 = dword_100769BC, dword_100769BC) )
      result = sub_1003BAFC(v2, a1);
  }
  return result;
}
// 100769BC: using guessed type int dword_100769BC;
// 100769C0: using guessed type int dword_100769C0;

//----- (1003BB75) --------------------------------------------------------
signed int __thiscall sub_1003BB75(DWORD_PTR *this, HANDLE hThread)
{
  return sub_1003B766(hThread, this);
}

//----- (1003BB87) --------------------------------------------------------
int __usercall sub_1003BB87<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1
  HANDLE v5; // eax@1
  int v6; // eax@2
  int v7; // eax@7
  int v8; // edx@7
  int v9; // ecx@7
  int v10; // esi@7
  int v11; // ecx@7
  int v12; // ST08_4@7
  int v13; // eax@10
  int v14; // ST08_4@10
  int v15; // edx@14
  int v16; // esi@14
  int v17; // eax@15
  int v18; // edx@15
  int v19; // ST08_4@15
  int v21; // [sp-8h] [bp-8h]@14

  sub_1003569B();
  v5 = GetCurrentProcess();
  if ( !GetProcessAffinityMask(v5, &ProcessAffinityMask, &SystemAffinityMask) )
  {
    v6 = GetLastError();
    if ( v6 > 0 )
      v6 = (unsigned __int16)v6 | 0x80070000;
    sub_10030079(a2 - 48, v6);
    sub_100355DB(a2 - 48, (int)&unk_1006C6F4);
  }
  if ( ProcessAffinityMask != SystemAffinityMask )
  {
    if ( dword_100769D4 < 4 )
    {
      v16 = sub_1002ADB1(v3, v4, a1, a3, 8);
      v4 = v21;
      *(_DWORD *)(a2 - 32) = v16;
      *(_DWORD *)(a2 - 4) = 0;
      if ( v16 )
      {
        v17 = sub_1002ADB1(v15, v21, a1, a3, 12);
        v18 = v17;
        v4 = v19;
        if ( v17 )
        {
          v4 = ProcessAffinityMask;
          *(_DWORD *)v17 = 0;
          *(_DWORD *)(v17 + 4) = 0;
          *(_DWORD *)(v17 + 8) = 0;
          *(_WORD *)(v17 + 4) = 0;
          *(_DWORD *)v17 = v4;
        }
        else
        {
          v18 = 0;
        }
        *(_WORD *)v16 = 1;
        *(_DWORD *)(v16 + 4) = v18;
      }
      else
      {
        v16 = 0;
      }
      dword_100769C0 = v16;
    }
    else
    {
      v7 = (int)GetCurrentThread();
      sub_1003B79E(a2 - 28, v7);
      v10 = sub_1002ADB1(v8, v11, a1, a3, 12);
      v9 = v12;
      if ( v10 )
      {
        v9 = *(_WORD *)(a2 - 24);
        v8 = ProcessAffinityMask;
        *(_DWORD *)v10 = 0;
        *(_DWORD *)(v10 + 4) = 0;
        *(_DWORD *)(v10 + 8) = 0;
        a3 = v10 + 12;
        *(_WORD *)(v10 + 4) = v9;
        *(_DWORD *)v10 = v8;
      }
      else
      {
        v10 = 0;
      }
      v13 = sub_1002ADB1(v8, v9, a1, a3, 8);
      v4 = v14;
      if ( v13 )
      {
        v4 = 1;
        *(_WORD *)v13 = 1;
        *(_DWORD *)(v13 + 4) = v10;
      }
      else
      {
        v13 = 0;
      }
      dword_100769C0 = v13;
    }
  }
  return sub_1003564A(v4);
}
// 1003564A: using guessed type int __thiscall sub_1003564A(_DWORD);
// 100769C0: using guessed type int dword_100769C0;
// 100769D4: using guessed type int dword_100769D4;

//----- (1003BC9E) --------------------------------------------------------
void __usercall sub_1003BC9E(int a1<ebx>)
{
  sub_100309A2(a1, dword_100769DC);
  dword_100769DC = 0;
  dword_100769D8 = 0;
}
// 100769D8: using guessed type int dword_100769D8;

//----- (1003BCB9) --------------------------------------------------------
int __thiscall sub_1003BCB9(void *this, int a2)
{
  int result; // eax@1
  unsigned int v3; // ecx@1
  void *v4; // ebx@1
  int ebp0; // ebp@0
  int v6; // esi@2
  int v7; // edi@3
  int v8; // ecx@4
  signed int v9; // edx@5
  int v10; // eax@6
  int v11; // edx@7
  int v12; // ecx@7
  char v13; // zf@12
  int v14; // eax@22
  int v15; // [sp+4h] [bp-18h]@2
  unsigned int v16; // [sp+8h] [bp-14h]@1
  signed int v17; // [sp+Ch] [bp-10h]@5
  int v18; // [sp+10h] [bp-Ch]@5
  signed int v19; // [sp+14h] [bp-8h]@5
  int v20; // [sp+24h] [bp+8h]@4

  result = *(_DWORD *)(a2 + 16);
  v4 = this;
  v3 = 0;
  v16 = 0;
  if ( *((_DWORD *)v4 + 6) )
  {
    v6 = result + 4;
    v15 = -4 - result;
    do
    {
      v7 = 0;
      if ( *(_DWORD *)v6 )
      {
        v8 = 0;
        v20 = 0;
        do
        {
          v17 = 0;
          v9 = 1;
          result = v8 + *(_DWORD *)(v6 + 44);
          v18 = v8 + *(_DWORD *)(v6 + 44);
          v19 = 1;
          if ( *((_DWORD *)v4 + 2) > 1u )
          {
            do
            {
              v10 = *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v4 + 21) + 4 * v9) + 16);
              if ( *(_DWORD *)(v10 + 108) )
              {
                v12 = *(_DWORD *)(v10 + 16) + v6 + v15;
                v11 = v20 + *(_DWORD *)(v12 + 48);
                if ( *(_DWORD *)v11 == 5 )
                {
                  if ( *(_DWORD *)v18 != 4 )
                  {
                    ++**(_DWORD **)(v11 + 20);
                    v14 = *(_DWORD *)(v12 + 48);
                    v8 = v20;
                    *(_DWORD *)(v20 + v14) = 4;
                    goto LABEL_16;
                  }
                  if ( *(_DWORD *)(v18 + 24) || *(_BYTE *)(v11 + 48) || v17 )
                  {
                    sub_1004CAB7(ebp0, v12, v7);
                  }
                  else
                  {
                    ++**(_DWORD **)(v11 + 20);
                    v13 = *(_BYTE *)(v11 + 49) == 0;
                    *(_DWORD *)v11 = 4;
                    if ( v13 )
                      sub_1004CC9B(v10, v12, v7);
                    v17 = 1;
                  }
                }
                v8 = v20;
              }
LABEL_16:
              result = v19 + 1;
              v19 = result;
              v9 = result;
            }
            while ( (unsigned int)result < *((_DWORD *)v4 + 2) );
          }
          ++v7;
          v8 += 52;
          v20 = v8;
        }
        while ( (unsigned int)v7 < *(_DWORD *)v6 );
        v3 = v16;
      }
      ++v3;
      v6 += 52;
      v16 = v3;
    }
    while ( v3 < *((_DWORD *)v4 + 6) );
  }
  return result;
}

//----- (1003BDC6) --------------------------------------------------------
int __thiscall sub_1003BDC6(int this)
{
  int v1; // edi@1
  int v2; // esi@1

  v1 = this;
  v2 = *(_DWORD *)(this + 188);
  if ( v2 >= (unsigned int)(sub_1003C119(this) + 1) )
    v2 = sub_1003C119(v1) + 1;
  return v2;
}

//----- (1003BDE9) --------------------------------------------------------
int __thiscall sub_1003BDE9(int this)
{
  int v1; // edx@1
  int v2; // edi@1
  int v3; // esi@1
  int v4; // eax@1

  v3 = this;
  v2 = *(_DWORD *)(this + 184);
  v4 = sub_1003DDD2(this);
  v1 = *(_DWORD *)(v3 + 188);
  if ( v1 >= (unsigned int)(v2 + v4 + 1) )
    v1 = sub_1003DDD2(v3) + v2 + 1;
  return v1;
}

//----- (1003BE16) --------------------------------------------------------
int __usercall sub_1003BE16<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // ebx@1
  int v4; // esi@1
  unsigned int v5; // eax@1
  signed __int64 v7; // qax@1
  int v8; // ecx@2
  int v9; // edx@3
  signed int v10; // edi@3
  unsigned int v11; // esi@3
  const void *v12; // eax@3
  signed __int64 v14; // qax@3
  int v15; // eax@4
  int v16; // ecx@5
  signed int v17; // ST0C_4@9
  int v18; // edx@10
  int v19; // ecx@10
  int v20; // edi@11
  int v21; // esi@11
  int v23; // [sp+Ch] [bp-1Ch]@1
  int v24; // [sp+10h] [bp-18h]@1
  int v25; // [sp+14h] [bp-14h]@2
  unsigned int v26; // [sp+18h] [bp-10h]@1
  int v27; // [sp+1Ch] [bp-Ch]@10
  unsigned int v28; // [sp+20h] [bp-8h]@9
  const void *v29; // [sp+24h] [bp-4h]@3

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 24);
  _ECX = 0;
  v7 = 52i64 * v5;
  __asm { seto    cl }
  v24 = v4;
  v3 = sub_1002965B(SHIDWORD(v7), v7 | -_ECX, a2, a3, v7 | -_ECX);
  v23 = v3;
  sub_10039210((void *)v3, 0, 52 * *(_DWORD *)(v4 + 24));
  v26 = 0;
  if ( *(_DWORD *)(v4 + 24) > 0u )
  {
    v8 = 0;
    v25 = 0;
    do
    {
      v12 = (const void *)(v8 + *(_DWORD *)(v4 + 72));
      memcpy((void *)v3, v12, 0x18u);
      v11 = *(_DWORD *)(v3 + 4);
      v29 = v12;
      _ECX = 0;
      v10 = 52;
      v14 = 52i64 * v11;
      __asm { seto    cl }
      v9 = sub_1002965B(SHIDWORD(v14), v14 | -_ECX, v3, 52, v14 | -_ECX);
      if ( v9 )
      {
        v15 = v11 - 1;
        if ( (signed int)(v11 - 1) >= 0 )
        {
          v16 = v9 + 12;
          do
          {
            *(_DWORD *)v16 = 0;
            *(_DWORD *)(v16 + 4) = 0;
            v16 += 52;
            --v15;
          }
          while ( v15 >= 0 );
        }
      }
      else
      {
        v9 = 0;
      }
      v17 = 52 * *(_DWORD *)(v3 + 4);
      *(_DWORD *)(v3 + 48) = v9;
      sub_10039210((void *)v9, 0, v17);
      v28 = 0;
      if ( *(_DWORD *)(v3 + 4) )
      {
        v18 = 0;
        v19 = 0;
        v27 = 0;
        do
        {
          v20 = v18 + *(_DWORD *)(v3 + 48);
          v21 = v19 + *((_DWORD *)v29 + 8);
          *(_DWORD *)v20 = *(_DWORD *)v21;
          v21 += 4;
          v20 += 4;
          *(_DWORD *)v20 = *(_DWORD *)v21;
          *(_DWORD *)(v20 + 4) = *(_DWORD *)(v21 + 4);
          *(_DWORD *)(v18 + *(_DWORD *)(v3 + 48)) = 1;
          v10 = 52;
          *(_DWORD *)(v18 + *(_DWORD *)(v3 + 48) + 20) = *((_DWORD *)v29 + 8) + 16 + v19;
          v19 = v27 + 36;
          v18 += 52;
          ++v28;
          v27 += 36;
        }
        while ( v28 < *(_DWORD *)(v3 + 4) );
      }
      v4 = v24;
      v8 = v25 + 40;
      v3 += v10;
      ++v26;
      v25 += 40;
    }
    while ( v26 < *(_DWORD *)(v24 + 24) );
    v3 = v23;
  }
  return v3;
}

//----- (1003BF43) --------------------------------------------------------
void __thiscall sub_1003BF43(LPVOID lpParameter)
{
  HANDLE v1; // eax@1
  LPVOID v2; // esi@1
  int v3; // eax@2
  char v4; // [sp+4h] [bp-10h]@9

  v2 = lpParameter;
  v1 = sub_100349DA(0, 0x10000u, (LPTHREAD_START_ROUTINE)StartAddress, lpParameter, 0, 0);
  *((_DWORD *)v2 + 19) = v1;
  if ( !v1 )
  {
    v3 = GetLastError();
    if ( v3 > 0 )
LABEL_8:
      v3 = (unsigned __int16)v3 | 0x80070000;
LABEL_9:
    sub_10030079((int)&v4, v3);
    sub_100355DB((int)&v4, (int)&unk_1006C6F4);
    __asm { int     3               ; Trap to Debugger }
    return;
  }
  if ( !SetThreadPriority(v1, 15) )
  {
    v3 = GetLastError();
    if ( v3 > 0 )
      goto LABEL_8;
    goto LABEL_9;
  }
}

//----- (1003BFBB) --------------------------------------------------------
#error "1003C00F: call analysis failed (funcsize=32)"

//----- (1003C017) --------------------------------------------------------
int __usercall sub_1003C017<eax>(int a1<ebp>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // eax@2
  int v6; // edx@3
  int v7; // ecx@3
  int v8; // esi@3
  int v9; // esi@6
  int v10; // eax@8

  sub_10035668();
  *(_DWORD *)(a1 - 16) = &dword_10077074;
  sub_10030F90(&dword_10077074);
  v2 = dword_100769B0;
  *(_DWORD *)(a1 - 4) = 0;
  if ( v2 )
  {
    v8 = sub_1003491A(v2);
    if ( sub_1003F113((void *)v8) )
      goto LABEL_9;
    v5 = sub_1002ADB1(v6, v7, 0, a2, 144);
    *(_DWORD *)(a1 - 20) = v5;
    *(_BYTE *)(a1 - 4) = 2;
  }
  else
  {
    v5 = sub_1002ADB1(v3, v4, 0, a2, 144);
    *(_DWORD *)(a1 - 20) = v5;
    *(_BYTE *)(a1 - 4) = 1;
  }
  if ( v5 )
    v9 = sub_1003B7BF(v5);
  else
    v9 = 0;
  v10 = *(_DWORD *)v9;
  *(_BYTE *)(a1 - 4) = 0;
  (*(void (__thiscall **)(int))v10)(v9);
  dword_100769B0 = sub_1003491A(v9);
LABEL_9:
  dword_10077074 = 0;
  return sub_10035636(8);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 1003B7BF: using guessed type int __thiscall sub_1003B7BF(_DWORD);
// 100769B0: using guessed type int dword_100769B0;
// 10077074: using guessed type int dword_10077074;

//----- (1003C0AC) --------------------------------------------------------
int __thiscall sub_1003C0AC(int this, int a2, int a3)
{
  int v3; // ecx@1
  int v4; // ebx@1
  struct _RTL_CRITICAL_SECTION *v5; // esi@1
  int v6; // edi@1
  int v7; // ecx@2
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v6 = this;
  v10 = this;
  v5 = (struct _RTL_CRITICAL_SECTION *)(this + 44);
  v4 = 0;
  v9 = this + 44;
  sub_1002B91E((LPCRITICAL_SECTION)(this + 44));
  v3 = *(_DWORD *)(v6 + 100);
  if ( v3 )
    v7 = *(_DWORD *)(v3 + 24);
  else
    v7 = 0;
  if ( v7 )
  {
    do
    {
      v4 += *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 16) + 52 * a2 + 48) + 52 * a3 + 24);
      if ( v7 == *(_DWORD *)(v10 + 100) )
        v7 = 0;
      else
        v7 = *(_DWORD *)(v7 + 24);
    }
    while ( v7 );
    v5 = (struct _RTL_CRITICAL_SECTION *)v9;
  }
  sub_1002BB53(v5);
  return v4;
}

//----- (1003C119) --------------------------------------------------------
int __thiscall sub_1003C119(int this)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 188);
  if ( result >= (unsigned int)(*(_DWORD *)(this + 128) + *(_DWORD *)(this + 184)) )
    result = *(_DWORD *)(this + 128) + *(_DWORD *)(this + 184);
  return result;
}

//----- (1003C132) --------------------------------------------------------
int __thiscall sub_1003C132(int this, int a2)
{
  void *v2; // ebx@1
  unsigned int v3; // esi@1
  int v4; // ebx@2
  LPVOID *v5; // edi@2

  v2 = (void *)a2;
  v3 = 0;
  if ( *(_DWORD *)(this + 24) )
  {
    v5 = (LPVOID *)(a2 + 48);
    v4 = this;
    do
    {
      sub_10030383(*v5);
      ++v3;
      v5 += 13;
    }
    while ( v3 < *(_DWORD *)(v4 + 24) );
    v2 = (void *)a2;
  }
  return sub_10030383(v2);
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (1003C16C) --------------------------------------------------------
void __usercall sub_1003C16C(int a1<ecx>, int a2<ebx>)
{
  int v2; // eax@1
  __int64 v3; // qcx@1
  int v4; // edi@1
  int v5; // esi@1
  signed __int64 v7; // qax@1
  int v8; // eax@1
  signed int v9; // ST10_4@1
  signed __int64 v11; // qax@1
  void *v12; // ecx@2
  int v13; // edx@4
  signed int v14; // ST14_4@4
  int v15; // edx@5
  int v16; // eax@10
  int v17; // edx@10
  int v18; // esi@10
  int v19; // eax@13
  unsigned __int8 v20; // sf@13
  unsigned __int8 v21; // of@13
  int v22; // esi@17
  int v23; // esi@18
  int v24; // edx@19
  LPVOID v25; // esi@23
  ULONG_PTR v26; // esi@25
  int v27; // edx@28
  int v28; // eax@31
  int v29; // eax@39
  unsigned int v30; // ebx@43
  int v31; // edx@44
  unsigned int v32; // ecx@45
  int v33; // esi@46
  int v34; // [sp+Ch] [bp-14h]@10
  void *v35; // [sp+Ch] [bp-14h]@38
  int v36; // [sp+10h] [bp-10h]@6
  int v37; // [sp+10h] [bp-10h]@29
  int v38; // [sp+14h] [bp-Ch]@10
  int v39; // [sp+14h] [bp-Ch]@28
  int v40; // [sp+18h] [bp-8h]@5
  int v41; // [sp+1Ch] [bp-4h]@5
  int v42; // [sp+1Ch] [bp-4h]@28

  v4 = a1;
  _ECX = 0;
  *(_DWORD *)(v4 + 20) = dword_100769D0;
  *(_DWORD *)(v4 + 24) = dword_100769CC;
  *(_DWORD *)(v4 + 28) = dword_100769C4;
  v7 = 12i64 * *(_DWORD *)(v4 + 20);
  __asm { seto    cl }
  v8 = sub_1002965B(SHIDWORD(v7), v7 | -_ECX, a2, v4, v7 | -_ECX);
  v9 = 12 * *(_DWORD *)(v4 + 20);
  *(_DWORD *)(v4 + 68) = v8;
  sub_10039210((void *)v8, 0, v9);
  v5 = *(_DWORD *)(v4 + 24);
  _ECX = 0;
  v11 = 40i64 * *(_DWORD *)(v4 + 24);
  __asm { seto    cl }
  v3 = (_DWORD)v11 | (unsigned int)-_ECX;
  v2 = sub_1002965B(SHIDWORD(v11), v3 + 4, SHIDWORD(v3), v4, (v3 + 4) | -((_DWORD)v3 >= 0xFFFFFFFCu));
  if ( v2 )
  {
    *(_DWORD *)v2 = v5;
    v12 = (void *)(v2 + 4);
  }
  else
  {
    v12 = 0;
  }
  v14 = 40 * *(_DWORD *)(v4 + 24);
  *(_DWORD *)(v4 + 72) = v12;
  sub_10039210(v12, 0, v14);
  if ( dword_100769D4 >= 4 )
  {
    LODWORD(v3) = 0;
    v15 = 0;
    HIDWORD(v3) = dword_100769DC;
    v40 = 0;
    v41 = 0;
    if ( dword_100769D8 )
    {
      v36 = 0;
      while ( 1 )
      {
        if ( *HIDWORD(v3) == 1 )
        {
          if ( !byte_100769C8 )
          {
            if ( *(_DWORD *)(HIDWORD(v3) + 32) )
            {
              v22 = 40 * v3;
              sub_1003D9B8(
                v15,
                40 * v3 + *(_DWORD *)(v4 + 72),
                SHIDWORD(v3),
                v4,
                v4,
                v3,
                *(_WORD *)(HIDWORD(v3) + 36),
                *(void **)(HIDWORD(v3) + 32),
                0,
                0);
              ++v41;
              v15 = v40;
              *(_DWORD *)(v22 + *(_DWORD *)(v4 + 72) + 20) = *(_DWORD *)(HIDWORD(v3) + 8);
            }
          }
          v23 = *(_DWORD *)(HIDWORD(v3) + 32);
          if ( !v23 )
            goto LABEL_21;
          v24 = v36 + *(_DWORD *)(v4 + 68);
          LODWORD(v3) = *(_WORD *)(HIDWORD(v3) + 36);
          v36 += 12;
          *(_DWORD *)(v24 + 8) = *(_DWORD *)(HIDWORD(v3) + 8);
          *(_DWORD *)(v24 + 4) = v3;
          *(_DWORD *)v24 = v23;
        }
        else
        {
          if ( *HIDWORD(v3) != 3 || !byte_100769C8 )
            goto LABEL_21;
          v17 = 0;
          v16 = HIDWORD(v3) + 32;
          v18 = 40 * v3;
          v34 = 0;
          v38 = HIDWORD(v3) + 32;
          do
          {
            if ( *(_DWORD *)v16 )
            {
              sub_1003D9B8(
                v17,
                v18 + *(_DWORD *)(v4 + 72),
                SHIDWORD(v3),
                v4,
                v4,
                v3,
                *(_WORD *)(v16 + 4),
                *(void **)v16,
                0,
                0);
              v16 = v38;
              v17 = v34;
              LODWORD(v3) = v41++ + 1;
              v18 += 40;
            }
            v38 = v16 + 12;
            v19 = *(_WORD *)(HIDWORD(v3) + 30);
            ++v17;
            v21 = __SETO__(v17, v19);
            v20 = v17 - v19 < 0;
            v16 = v38;
            v34 = v17;
          }
          while ( v20 ^ v21 );
        }
        v15 = v40;
LABEL_21:
        v15 += *(_DWORD *)(HIDWORD(v3) + 4);
        HIDWORD(v3) += *(_DWORD *)(HIDWORD(v3) + 4);
        LODWORD(v3) = v41;
        v40 = v15;
        if ( v15 >= (unsigned int)dword_100769D8 )
          goto LABEL_41;
      }
    }
    goto LABEL_41;
  }
  v25 = dword_100769DC;
  if ( dword_100769DC )
  {
    LOWORD(v3) = 0;
    v27 = 0;
    v39 = 0;
    v42 = 0;
    if ( (unsigned int)dword_100769D8 <= 0 )
    {
LABEL_41:
      sub_1003BC9E(SHIDWORD(v3));
      goto LABEL_42;
    }
    v37 = 0;
    while ( 1 )
    {
      if ( *((_DWORD *)v25 + 1) == 1 )
      {
        if ( byte_100769C8 )
          goto LABEL_38;
        if ( *(_DWORD *)v25 )
        {
          sub_1003D9B8(v27, HIDWORD(v3) + *(_DWORD *)(v4 + 72), SHIDWORD(v3), v4, v4, v3, 0, *(void **)v25, 0, 0);
          v27 = v39;
          *(_DWORD *)(HIDWORD(v3) + *(_DWORD *)(v4 + 72) + 20) = *((_DWORD *)v25 + 2);
          ++v42;
          LODWORD(v3) = v42;
          v3 += 171798691840i64;
LABEL_38:
          v35 = *(void **)v25;
          if ( *(_DWORD *)v25 )
          {
            LODWORD(v3) = v37 + *(_DWORD *)(v4 + 68);
            v29 = *((_DWORD *)v25 + 2);
            *(_DWORD *)(v3 + 4) = 0;
            v37 += 12;
            *(_DWORD *)(v3 + 8) = v29;
            *(_DWORD *)v3 = v35;
            LOWORD(v3) = v42;
          }
          goto LABEL_40;
        }
      }
      else
      {
        v28 = *((_DWORD *)v25 + 1) - 3;
        if ( *((_DWORD *)v25 + 1) == 3 )
        {
          if ( byte_100769C8 )
          {
            if ( *(_DWORD *)v25 != v28 )
            {
              sub_1003D9B8(
                v27,
                HIDWORD(v3) + *(_DWORD *)(v4 + 72),
                SHIDWORD(v3),
                v4,
                v4,
                v3,
                v28,
                *(void **)v25,
                v28,
                v28);
              v27 = v39;
              ++v42;
              LODWORD(v3) = v42;
              v3 += 171798691840i64;
            }
          }
        }
      }
LABEL_40:
      v27 += 24;
      v25 = (char *)v25 + 24;
      v39 = v27;
      if ( v27 >= (unsigned int)dword_100769D8 )
        goto LABEL_41;
    }
  }
  if ( dword_100769BC )
    v26 = *(_DWORD *)sub_1003D3E4(dword_100769BC, 0);
  else
    v26 = ProcessAffinityMask;
  sub_1003D9B8(v13, *(_DWORD *)(v4 + 72), SHIDWORD(v3), v4, v4, 0, 0, (void *)v26, 0, 0);
  **(_DWORD **)(v4 + 68) = v26;
LABEL_42:
  if ( byte_100769C8 )
  {
    v30 = 0;
    if ( *(_DWORD *)(v4 + 24) )
    {
      v31 = 0;
      do
      {
        v32 = 0;
        if ( *(_DWORD *)(v4 + 20) )
        {
          v33 = *(_DWORD *)(v4 + 68);
          while ( *(_DWORD *)(v31 + *(_DWORD *)(v4 + 72) + 12) != *(_DWORD *)(v33 + 4)
               || !(*(_DWORD *)(v31 + *(_DWORD *)(v4 + 72)) & *(_DWORD *)v33) )
          {
            ++v32;
            v33 += 12;
            if ( v32 >= *(_DWORD *)(v4 + 20) )
              goto LABEL_52;
          }
          *(_DWORD *)(v31 + *(_DWORD *)(v4 + 72) + 20) = *(_DWORD *)(12 * v32 + *(_DWORD *)(v4 + 68) + 8);
        }
LABEL_52:
        ++v30;
        v31 += 40;
      }
      while ( v30 < *(_DWORD *)(v4 + 24) );
    }
  }
}
// 100769BC: using guessed type int dword_100769BC;
// 100769C4: using guessed type int dword_100769C4;
// 100769C8: using guessed type char byte_100769C8;
// 100769CC: using guessed type int dword_100769CC;
// 100769D0: using guessed type int dword_100769D0;
// 100769D4: using guessed type int dword_100769D4;
// 100769D8: using guessed type int dword_100769D8;

//----- (1003C484) --------------------------------------------------------
int __thiscall sub_1003C484(int this)
{
  char i; // zf@1
  int v2; // edi@1
  signed int v3; // esi@1
  int v4; // eax@2
  int result; // eax@2
  int v6; // ecx@2
  int v7; // [sp+8h] [bp-Ch]@2
  int v8; // [sp+Ch] [bp-8h]@2
  int v9; // [sp+10h] [bp-4h]@2

  v2 = this;
  v3 = *(_DWORD *)(this + 100);
  for ( i = v3 == 0; ; i = v3 == *(_DWORD *)(v2 + 100) )
  {
    v3 = i ? 0 : *(_DWORD *)(v3 + 24);
    if ( !v3 )
      break;
    v4 = *(_DWORD *)(v3 + 120);
    v6 = *(_DWORD *)(v3 + 8);
    v7 = 0;
    v8 = 0;
    v9 = v4;
    (*(void (__stdcall **)(int *, int *, int *))(*(_DWORD *)v6 + 4))(&v7, &v8, &v9);
    result = v9;
    *(_DWORD *)(v3 + 120) = v9;
  }
  return result;
}

//----- (1003C4D1) --------------------------------------------------------
char __thiscall sub_1003C4D1(int this)
{
  int v1; // ebx@1
  int v2; // esi@2
  int v3; // esi@3
  char v4; // dl@7
  unsigned int v5; // ecx@7
  unsigned int v6; // edi@7
  int v7; // eax@7
  int v8; // edx@9
  int v9; // ecx@10
  int v10; // esi@10
  char v11; // zf@14
  int v12; // edi@16
  int v13; // ecx@17
  int v14; // ebx@17
  int v15; // eax@18
  char result; // al@29
  int v17; // [sp+4h] [bp-2Ch]@9
  unsigned int v18; // [sp+Ch] [bp-24h]@7
  int v19; // [sp+10h] [bp-20h]@1
  int v20; // [sp+14h] [bp-1Ch]@5
  unsigned int v21; // [sp+18h] [bp-18h]@7
  int v22; // [sp+1Ch] [bp-14h]@7
  int v23; // [sp+20h] [bp-10h]@14
  int v24; // [sp+20h] [bp-10h]@17
  int v25; // [sp+24h] [bp-Ch]@7
  int v26; // [sp+28h] [bp-8h]@7
  char v27; // [sp+2Fh] [bp-1h]@8

  v1 = this;
  v19 = this;
  if ( *(_DWORD *)(this + 100) )
  {
    v2 = *(_DWORD *)(this + 100);
    if ( v2 )
      v3 = *(_DWORD *)(v2 + 24);
    else
      v3 = 0;
    v20 = v3;
    if ( *(_DWORD *)(v3 + 160) < (unsigned int)sub_1003C119(v3) || *(_DWORD *)(v3 + 168) )
    {
      v7 = sub_1003C119(v3);
      v25 = sub_1004C0EA((void *)v3, v7) - *(_DWORD *)(v3 + 160);
      v22 = *(_DWORD *)(v3 + 16);
      v26 = *(_DWORD *)(v3 + 20);
      v6 = *(_DWORD *)(v1 + 24);
      v4 = sub_1003C119(v3) != *(_DWORD *)(v1 + 28);
      v5 = 0;
      v21 = 0;
      v18 = v6;
      if ( v6 )
      {
        while ( 1 )
        {
          v27 = v25 != 0 & v4;
          if ( v27 )
          {
            v8 = v5 + 1;
            v17 = *(_DWORD *)(v26 + 4 * v5);
            if ( v5 + 1 < v6 )
            {
              v10 = v5;
              v9 = v22 + 52 * v17;
              do
              {
                if ( *(_DWORD *)(v22 + 52 * *(_DWORD *)(v26 + 4 * v8) + 28) > *(_DWORD *)(v9 + 28) )
                {
                  v10 = v8;
                  v9 = v22 + 52 * *(_DWORD *)(v26 + 4 * v8);
                }
                ++v8;
              }
              while ( v8 < v18 );
              v5 = v21;
              v1 = v19;
              v23 = v10;
              v11 = v21 == v10;
              v3 = v20;
              if ( !v11 )
              {
                *(_DWORD *)(v26 + 4 * v21) = *(_DWORD *)(v26 + 4 * v23);
                *(_DWORD *)(v26 + 4 * v23) = v17;
              }
            }
          }
          v12 = v22 + 52 * *(_DWORD *)(v26 + 4 * v5);
          if ( *(_DWORD *)(v12 + 4) )
            break;
LABEL_26:
          v6 = *(_DWORD *)(v1 + 24);
          v4 = v27;
          ++v5;
          v21 = v5;
          v18 = v6;
          if ( v5 >= v6 )
            goto LABEL_27;
        }
        v14 = 0;
        v13 = 0;
        v24 = 0;
        while ( 1 )
        {
          v15 = *(_DWORD *)(v12 + 48);
          if ( *(_DWORD *)(v15 + v13) == 1 )
          {
            if ( v25 )
            {
              ++**(_DWORD **)(v15 + v13 + 20);
              sub_1004BEFE(v3, v12, v14, 0);
              --v25;
LABEL_23:
              v13 = v24;
              goto LABEL_24;
            }
          }
          else
          {
            if ( *(_BYTE *)(v15 + v13 + 49) )
            {
              sub_1004CC9B(v3, v12, v14);
              goto LABEL_23;
            }
          }
LABEL_24:
          ++v14;
          v13 += 52;
          v24 = v13;
          if ( (unsigned int)v14 >= *(_DWORD *)(v12 + 4) )
          {
            v1 = v19;
            v5 = v21;
            goto LABEL_26;
          }
        }
      }
    }
LABEL_27:
    if ( *(_DWORD *)(v3 + 132) == *(_DWORD *)(v3 + 128) )
      sub_1003F132((void *)v1, 0);
    result = *(_DWORD *)(v3 + 160) == sub_1003C119(v3);
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1003C67E) --------------------------------------------------------
void __thiscall sub_1003C67E(int this, int a2, char a3, char a4, int a5, unsigned int a6)
{
  int v6; // ebx@1
  int v7; // esi@1
  unsigned int v8; // edi@2
  int v9; // ecx@3
  int v10; // edx@10
  int v11; // edi@11
  int v12; // edx@12
  int v13; // ebx@12
  int v14; // eax@14
  int v15; // ecx@18
  int v16; // eax@24
  unsigned int v17; // edi@25
  int v18; // eax@26
  int v19; // eax@27
  int v20; // [sp+Ch] [bp-10h]@11
  int v21; // [sp+10h] [bp-Ch]@10
  int v22; // [sp+14h] [bp-8h]@12
  int v23; // [sp+18h] [bp-4h]@1
  int v24; // [sp+24h] [bp+8h]@26

  v6 = a2;
  v7 = a5;
  v23 = this;
  do
  {
    v8 = 0;
    BYTE3(a5) = 0;
    if ( !v7 )
      break;
    do
    {
      v9 = *(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v8);
      if ( *(_DWORD *)(v9 + 4) )
      {
        if ( *(_DWORD *)(v9 + 40) > *(_DWORD *)(v9 + 44) )
        {
          BYTE3(a5) = 1;
          if ( sub_1003D2DA((void *)v23, (int)&a3, (int)&a4, v9, a6) )
            --v6;
        }
      }
      this = v23;
      ++v8;
    }
    while ( v8 < v7 );
    a2 = v6;
  }
  while ( BYTE3(a5) );
  if ( v6 )
  {
    v10 = 0;
    v21 = 0;
    if ( v7 )
    {
      while ( 1 )
      {
        a5 = v10;
        v20 = v10 + 1;
        v11 = v10 + 1;
        if ( v10 + 1 < (unsigned int)v7 )
        {
          v22 = *(_DWORD *)(this + 92);
          v13 = 4 * v10;
          v12 = *(_DWORD *)(this + 92);
          do
          {
            if ( *(_DWORD *)(*(_DWORD *)(v12 + 4 * v11) + 4) <= *(_DWORD *)(*(_DWORD *)(v13 + v12) + 4) )
            {
              v14 = a5;
            }
            else
            {
              v14 = v11;
              a5 = v11;
              v13 = 4 * v11;
            }
            ++v11;
          }
          while ( v11 < (unsigned int)v7 );
          v10 = v21;
          v6 = a2;
          if ( v21 != v14 )
          {
            v15 = *(_DWORD *)(v22 + 4 * v21);
            *(_DWORD *)(v22 + 4 * v21) = *(_DWORD *)(v22 + 4 * v14);
            *(_DWORD *)(*(_DWORD *)(v23 + 92) + 4 * a5) = v15;
          }
          this = v23;
        }
        if ( !*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v10) + 4) )
          break;
        v10 = v20;
        v21 = v20;
        if ( v20 >= (unsigned int)v7 )
          goto LABEL_24;
      }
      v7 = v10;
    }
LABEL_24:
    v16 = v7;
    a5 = v7;
    do
    {
      v17 = 0;
      if ( v16 )
      {
        do
        {
          v18 = *(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v17);
          v24 = v18;
          if ( *(_DWORD *)(v18 + 4) )
          {
            v19 = sub_1003CE89(this, (int *)&a3, (unsigned int *)&a4, v18, v7, a6);
            this = v23;
            v6 -= v19;
            if ( !*(_DWORD *)(v24 + 4) )
              --v7;
          }
          v16 = a5;
          ++v17;
        }
        while ( v17 < a5 );
      }
    }
    while ( v6 );
  }
}

//----- (1003C7B8) --------------------------------------------------------
void __thiscall sub_1003C7B8(int this, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // esi@1
  int v5; // edi@2
  int v6; // edi@4
  unsigned int v7; // edx@5
  int v8; // ecx@6
  int v9; // edx@14
  int v10; // edi@15
  int v11; // ebx@16
  int v12; // eax@18
  int v13; // ecx@22
  int v14; // eax@28
  unsigned int v15; // edi@29
  int v16; // eax@31
  int v17; // eax@32
  int v18; // [sp+Ch] [bp-10h]@15
  int v19; // [sp+10h] [bp-Ch]@6
  int v20; // [sp+10h] [bp-Ch]@14
  int v21; // [sp+14h] [bp-8h]@2
  int v22; // [sp+14h] [bp-8h]@16
  int v23; // [sp+18h] [bp-4h]@1
  int v24; // [sp+24h] [bp+8h]@6
  int v25; // [sp+24h] [bp+8h]@31
  int v26; // [sp+28h] [bp+Ch]@15
  int v27; // [sp+28h] [bp+Ch]@28
  char v28; // [sp+2Bh] [bp+Fh]@2

  v3 = a2;
  v4 = a3;
  v23 = this;
  do
  {
    v5 = 0;
    v28 = 0;
    v21 = 0;
    if ( !v4 )
      break;
    do
    {
      if ( !v3 )
        break;
      v6 = *(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v5);
      if ( *(_DWORD *)(v6 + 4) )
      {
        v7 = *(_DWORD *)(v6 + 44);
        if ( *(_DWORD *)(v6 + 40) > v7 )
        {
          v8 = *(_DWORD *)(v6 + 16);
          v28 = 1;
          v24 = *(_DWORD *)(*(_DWORD *)(v8 + 20) + 4 * v7);
          v19 = *(_DWORD *)(v8 + 16) + 52 * v24;
          this = v23;
          if ( *(_DWORD *)(40 * v24 + *(_DWORD *)(v23 + 72) + 28) )
          {
            sub_1003CB9B(v23, *(_DWORD *)(v6 + 16), v24, 1, 1);
            if ( *(_DWORD *)(v19 + 28) == *(_DWORD *)(v19 + 4) )
              ++*(_DWORD *)(v6 + 44);
            --*(_DWORD *)(v6 + 4);
            this = v23;
            --v3;
          }
          else
          {
            ++*(_DWORD *)(v6 + 44);
          }
        }
      }
      v5 = v21 + 1;
      v21 = v5;
    }
    while ( v5 < (unsigned int)v4 );
    a2 = v3;
  }
  while ( v28 );
  if ( v3 )
  {
    v9 = 0;
    v20 = 0;
    if ( v4 )
    {
      while ( 1 )
      {
        v26 = v9;
        v18 = v9 + 1;
        v10 = v9 + 1;
        if ( v9 + 1 < (unsigned int)v4 )
        {
          v22 = *(_DWORD *)(this + 92);
          v11 = 4 * v9;
          do
          {
            if ( *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v10) + 4) <= *(_DWORD *)(*(_DWORD *)(v11 + *(_DWORD *)(this + 92))
                                                                                             + 4) )
            {
              v12 = v26;
            }
            else
            {
              v12 = v10;
              v26 = v10;
              v11 = 4 * v10;
            }
            ++v10;
          }
          while ( v10 < (unsigned int)v4 );
          v9 = v20;
          v3 = a2;
          if ( v20 != v12 )
          {
            v13 = *(_DWORD *)(v22 + 4 * v20);
            *(_DWORD *)(v22 + 4 * v20) = *(_DWORD *)(v22 + 4 * v12);
            *(_DWORD *)(*(_DWORD *)(v23 + 92) + 4 * v26) = v13;
          }
          this = v23;
        }
        if ( !*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v9) + 4) )
          break;
        v9 = v18;
        v20 = v18;
        if ( v18 >= (unsigned int)v4 )
          goto LABEL_28;
      }
      v4 = v9;
    }
LABEL_28:
    v14 = v4;
    v27 = v4;
    while ( 1 )
    {
      v15 = 0;
      if ( v14 )
        break;
LABEL_35:
      if ( !v3 )
        return;
    }
    while ( v3 )
    {
      v16 = *(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v15);
      v25 = v16;
      if ( *(_DWORD *)(v16 + 4) )
      {
        v17 = sub_1003D1CE((void *)this, v3, v16, v4);
        this = v23;
        v3 -= v17;
        if ( !*(_DWORD *)(v25 + 4) )
          --v4;
      }
      v14 = v27;
      ++v15;
      if ( v15 >= v27 )
        goto LABEL_35;
    }
  }
}

//----- (1003C939) --------------------------------------------------------
int __thiscall sub_1003C939(int this)
{
  unsigned int v1; // ecx@1
  unsigned int v2; // ebx@1
  int v3; // edi@1
  int v4; // edx@2
  int v5; // ecx@3
  int v6; // esi@3
  int v7; // esi@4
  int v8; // ecx@7
  int v9; // eax@9
  int v10; // eax@9
  unsigned int v11; // edx@11
  int v12; // ecx@11
  int v13; // esi@12
  int v14; // eax@13
  unsigned int v15; // edx@14
  int v16; // ebx@14
  int v17; // ecx@15
  int v18; // esi@15
  int v19; // esi@23
  unsigned int v20; // edx@29
  unsigned int v21; // ecx@29
  unsigned int v22; // ebx@29
  int v23; // esi@30
  int v24; // edx@35
  int v25; // ecx@35
  int v26; // esi@35
  int v27; // esi@44
  int v28; // eax@44
  int v30; // [sp+Ch] [bp-18h]@35
  unsigned int v31; // [sp+10h] [bp-14h]@1
  int v32; // [sp+14h] [bp-10h]@6
  unsigned int v33; // [sp+14h] [bp-10h]@11
  unsigned int v34; // [sp+14h] [bp-10h]@29
  unsigned int v35; // [sp+18h] [bp-Ch]@1
  int v36; // [sp+1Ch] [bp-8h]@6
  int v37; // [sp+1Ch] [bp-8h]@12
  unsigned int v38; // [sp+1Ch] [bp-8h]@23
  int v39; // [sp+20h] [bp-4h]@11

  v3 = this;
  sub_1003E007(this);
  sub_1003E117(v3);
  v35 = 0;
  v1 = 0;
  v2 = 0;
  v31 = 0;
  if ( *(_DWORD *)(v3 + 8) )
  {
    do
    {
      v4 = *(_DWORD *)(*(_DWORD *)(v3 + 84) + 4 * v2);
      if ( *(_DWORD *)(*(_DWORD *)(v4 + 16) + 160) > *(_DWORD *)(v4 + 36) )
      {
        *(_DWORD *)(*(_DWORD *)(v3 + 88) + 4 * v1) = v4;
        v31 = v1 + 1;
        v5 = *(_DWORD *)(v4 + 16);
        v6 = *(_DWORD *)(v5 + 160);
        v35 += *(_DWORD *)(v5 + 160) - *(_DWORD *)(v4 + 36);
        if ( *(_DWORD *)(v4 + 24) >= (unsigned int)(v6 - *(_DWORD *)(v4 + 36)) )
          v7 = v6 - *(_DWORD *)(v4 + 36);
        else
          v7 = *(_DWORD *)(v4 + 24);
        *(_DWORD *)(v4 + 40) = v7;
        v36 = *(_DWORD *)(v5 + 160);
        v32 = *(_DWORD *)(v5 + 168);
        if ( v32 - *(_DWORD *)(v4 + 24) >= (unsigned int)(v36 - *(_DWORD *)(v4 + 36) - v7) )
          v8 = v36 - *(_DWORD *)(v4 + 36) - v7;
        else
          v8 = v32 - *(_DWORD *)(v4 + 24);
        v9 = *(_DWORD *)(v4 + 16);
        *(_DWORD *)(v4 + 44) = v8;
        v10 = *(_DWORD *)(v9 + 160) - *(_DWORD *)(v4 + 36) - v8;
        v1 = v31;
        *(_DWORD *)(v4 + 48) = v10 - v7;
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)(v3 + 8) );
  }
  v12 = 0;
  *(_DWORD *)(v3 + 32) = 0;
  v11 = 0;
  v39 = 0;
  v33 = 0;
  if ( *(_DWORD *)(v3 + 24) )
  {
    v13 = 0;
    v37 = 0;
    do
    {
      v14 = v13 + *(_DWORD *)(v3 + 72);
      if ( *(_DWORD *)(v14 + 4) )
      {
        v15 = 0;
        v16 = 0;
        do
        {
          v17 = v16 + *(_DWORD *)(v14 + 32);
          v18 = *(_DWORD *)(v17 + 16);
          if ( v18 )
          {
            if ( v18 == *(_DWORD *)(v17 + 28) )
            {
              *(_DWORD *)v17 = 6;
              ++*(_DWORD *)(v14 + 28);
              ++*(_DWORD *)(v3 + 32);
            }
            v12 = v39;
          }
          else
          {
            *(_DWORD *)v17 = 2;
            ++*(_DWORD *)(v14 + 8);
            v12 = v39++ + 1;
          }
          ++v15;
          v16 += 36;
        }
        while ( v15 < *(_DWORD *)(v14 + 4) );
        v11 = v33;
        v13 = v37;
      }
      ++v11;
      v13 += 40;
      v33 = v11;
      v37 = v13;
    }
    while ( v11 < *(_DWORD *)(v3 + 24) );
  }
  v19 = v12 + v35;
  *(_DWORD *)(v3 + 36) = 0;
  v38 = v12 + v35;
  while ( (v19 || *(_DWORD *)(v3 + 32) > 0u) && *(_DWORD *)(v3 + 36) < 2u )
  {
    if ( *(_DWORD *)(v3 + 36) == 1 )
      sub_1003D949(v3);
    v21 = 0;
    v22 = 0;
    v20 = 0;
    v34 = 0;
    if ( *(_DWORD *)(v3 + 8) )
    {
      do
      {
        v23 = *(_DWORD *)(*(_DWORD *)(v3 + 84) + 4 * v20);
        if ( *(_DWORD *)(*(_DWORD *)(v23 + 16) + 160) < *(_DWORD *)(v23 + 36) )
        {
          *(_DWORD *)(*(_DWORD *)(v3 + 92) + 4 * v21) = v23;
          v34 = v21 + 1;
          v22 += *(_DWORD *)(v23 + 36) - *(_DWORD *)(*(_DWORD *)(v23 + 16) + 160);
          ++v21;
        }
        ++v20;
      }
      while ( v20 < *(_DWORD *)(v3 + 8) );
      v19 = v38;
      if ( v21 )
      {
        if ( v38 )
        {
          v26 = sub_1003BA2C(v3, v38, v22, v21);
          v30 = sub_1003E217((void *)v3, v34);
          LOBYTE(v25) = 0;
          v24 = v39;
          if ( v39 >= (unsigned int)v26 )
            v24 = v26;
          v39 -= v24;
          if ( v24 < (unsigned int)v26 )
          {
            v25 = v26 - v24;
            if ( v26 - v24 >= v35 )
              v25 = v35;
            v35 -= v25;
          }
          sub_1003C67E(v3, v26, v24, v25, v30, v31);
          v38 -= v26;
          v21 = v34;
          v22 -= v26;
          v19 = v38;
        }
        if ( v22 )
        {
          if ( *(_DWORD *)(v3 + 32) )
          {
            v27 = sub_1003BA2C(v3, *(_DWORD *)(v3 + 32), v22, v21);
            v28 = sub_1003E217((void *)v3, v34);
            sub_1003C7B8(v3, v27, v28);
            *(_DWORD *)(v3 + 32) -= v27;
            v19 = v38;
          }
        }
      }
    }
    ++*(_DWORD *)(v3 + 36);
  }
  return sub_1003EE15(v3);
}

//----- (1003CB9B) --------------------------------------------------------
char *__thiscall sub_1003CB9B(int this, int a2, int a3, int a4, char a5)
{
  int i; // ecx@1
  int v6; // edi@1
  int v7; // esi@1
  int v8; // eax@2
  char *result; // eax@9
  char v10; // zf@9
  int v11; // [sp+Ch] [bp-4h]@2

  v7 = *(_DWORD *)(this + 72) + 40 * a3;
  v6 = 0;
  for ( i = 0; ; i += 36 )
  {
    v8 = i + *(_DWORD *)(v7 + 32);
    v11 = i;
    if ( *(_DWORD *)v8 == 2 )
    {
      if ( !a5 )
        break;
    }
    if ( *(_DWORD *)v8 == 6 && a5 )
      break;
LABEL_11:
    ++v6;
  }
  ++*(_DWORD *)(v8 + 16);
  *(_DWORD *)v8 = 0;
  if ( a5 )
    --*(_DWORD *)(v7 + 28);
  else
    --*(_DWORD *)(v7 + 8);
  result = sub_1004BEFE(a2, *(_DWORD *)(a2 + 16) + 52 * a3, v6, a5);
  v10 = a4-- == 1;
  if ( !v10 )
  {
    i = v11;
    goto LABEL_11;
  }
  return result;
}

//----- (1003CC07) --------------------------------------------------------
char *__thiscall sub_1003CC07(void *this, int a2, int a3, int a4, unsigned int a5)
{
  int v5; // eax@1
  int v6; // edx@1
  unsigned int v7; // ecx@1
  int ebp0; // ebp@0
  unsigned int v9; // esi@2
  int v10; // edi@4
  int v11; // edx@6
  int v12; // esi@6
  int v13; // eax@8
  int v14; // ecx@8
  int v15; // esi@8
  int v16; // ebx@9
  char v17; // al@11
  char v18; // cl@22
  char *result; // eax@29
  char v20; // zf@29
  char v21; // [sp+14h] [bp-24h]@24
  int v22; // [sp+18h] [bp-20h]@1
  int v23; // [sp+1Ch] [bp-1Ch]@8
  int v24; // [sp+20h] [bp-18h]@8
  int v25; // [sp+24h] [bp-14h]@6
  int v26; // [sp+28h] [bp-10h]@1
  unsigned int v27; // [sp+2Ch] [bp-Ch]@2
  int v28; // [sp+30h] [bp-8h]@9
  char v29; // [sp+37h] [bp-1h]@11

  v22 = (int)this;
  v5 = *(_DWORD *)(a2 + 16);
  v6 = 52 * a4 + *(_DWORD *)(v5 + 16);
  v7 = *(_DWORD *)(v6 + 44);
  v26 = 52 * a4 + *(_DWORD *)(v5 + 16);
  if ( a5 >= v7 )
  {
    v9 = *(_DWORD *)(v6 + 44);
    v27 = *(_DWORD *)(v6 + 44);
  }
  else
  {
    v9 = a5;
    v27 = a5;
  }
  v10 = a5 - v9;
  if ( a5 - v9 >= *(_DWORD *)(v6 + 32) - v7 )
    v10 = *(_DWORD *)(v6 + 32) - v7;
  v12 = a5 - v10 - v27;
  v11 = *(_DWORD *)(v6 + 40) - v7;
  v25 = v11;
  if ( v12 < (unsigned int)v11 )
  {
    v11 = a5 - v10 - v27;
    v25 = a5 - v10 - v27;
  }
  v14 = 52 * a4 + *(_DWORD *)(v5 + 16);
  v13 = 0;
  v23 = 0;
  v15 = v12 - v11;
  v24 = 0;
  while ( 1 )
  {
    v16 = v24 + *(_DWORD *)(v14 + 48);
    v28 = v13;
    if ( *(_DWORD *)v16 == 4 )
    {
      if ( !*(_DWORD *)(v16 + 40) )
        break;
    }
LABEL_32:
    v24 += 52;
    ++v13;
    v23 += 36;
  }
  v17 = *(_BYTE *)(v16 + 48);
  v29 = *(_BYTE *)(v16 + 48);
  if ( *(_BYTE *)(v16 + 49) )
  {
    if ( v17 && v27 )
    {
      --v27;
      goto LABEL_22;
    }
    if ( v10 )
    {
      --v10;
      goto LABEL_22;
    }
LABEL_31:
    v13 = v28;
    goto LABEL_32;
  }
  if ( v17 && v11 )
  {
    v25 = v11 - 1;
  }
  else
  {
    if ( !v15 )
      goto LABEL_31;
    --v15;
  }
LABEL_22:
  v18 = *(_BYTE *)(v16 + 48);
  if ( v29 )
  {
    sub_1003F4D9(
      v22,
      v26,
      v16,
      40 * a4 + *(_DWORD *)(v22 + 72),
      v23 + *(_DWORD *)(40 * a4 + *(_DWORD *)(v22 + 72) + 32),
      a2);
    v18 = v29;
  }
  v21 = 0;
  if ( *(_BYTE *)(v16 + 49) )
  {
    v21 = 1;
    if ( v18 )
      --*(_DWORD *)(a2 + 40);
    else
      --*(_DWORD *)(a2 + 44);
  }
  else
  {
    --*(_DWORD *)(a2 + 48);
  }
  sub_1004CAB7(ebp0, v26, v28);
  result = sub_1004BEFE(a3, 52 * a4 + *(_DWORD *)(a3 + 16), v28, v21);
  v20 = a5-- == 1;
  if ( !v20 )
  {
    v11 = v25;
    v14 = v26;
    goto LABEL_31;
  }
  return result;
}

//----- (1003CD6F) --------------------------------------------------------
int __stdcall StartAddress(int a1)
{
  int ebp0; // ebp@0

  sub_1003CD88(ebp0);
  sub_10034963(0);
  return 0;
}

//----- (1003CD88) --------------------------------------------------------
int __usercall sub_1003CD88<eax>(int a1<ebp>)
{
  DWORD v1; // ebx@1
  int v2; // edi@1
  int v3; // ecx@1
  DWORD v4; // eax@1
  char v5; // zf@1
  struct _RTL_CRITICAL_SECTION *v6; // esi@2
  int v7; // eax@3
  DWORD v8; // eax@8
  int v9; // esi@9
  struct _RTL_CRITICAL_SECTION *v10; // ecx@20
  signed int v12; // [sp-4h] [bp-4h]@1

  v12 = 12;
  sub_10035668();
  v2 = v3;
  v1 = 100;
  v4 = GetTickCount();
  v5 = *(_DWORD *)(v2 + 40) == 2;
  *(_DWORD *)(a1 - 16) = v4 - 500;
  if ( !v5 )
  {
    v6 = (struct _RTL_CRITICAL_SECTION *)(v2 + 44);
    for ( *(_DWORD *)(a1 - 20) = v2 + 44; ; v6 = *(struct _RTL_CRITICAL_SECTION **)(a1 - 20) )
    {
      *(_DWORD *)(a1 - 24) = WaitForSingleObject(*(HANDLE *)(v2 + 80), v1);
      sub_1002B91E(v6);
      v7 = *(_DWORD *)(v2 + 40);
      *(_DWORD *)(a1 - 4) = 0;
      if ( v7 )
      {
        if ( v7 != 1 )
          goto LABEL_20;
        if ( *(_DWORD *)(a1 - 24) == 258 )
        {
          sub_1003C939(v2);
          if ( *(_DWORD *)(v2 + 16) > 0u )
            sub_1003F132((void *)v2, 0);
          v8 = GetTickCount();
LABEL_15:
          *(_DWORD *)(a1 - 16) = v8;
          v1 = 100;
          goto LABEL_20;
        }
        v9 = ((int (__cdecl *)(signed int))GetTickCount)(v12) - *(_DWORD *)(a1 - 16);
        if ( (unsigned int)v9 > 0x64 )
        {
          if ( (unsigned int)v9 <= 0x82 )
          {
            if ( *(_DWORD *)(v2 + 16) )
              sub_1003F132((void *)v2, 0);
          }
          else
          {
            sub_1003C484(v2);
          }
          v8 = GetTickCount();
          goto LABEL_15;
        }
        if ( *(_DWORD *)(v2 + 16) )
          sub_1003F132((void *)v2, 0);
        v1 = 100 - v9;
      }
      else
      {
        v1 = (unsigned __int8)sub_1003C4D1(v2) != 0 ? -1 : 100;
      }
LABEL_20:
      v10 = *(struct _RTL_CRITICAL_SECTION **)(a1 - 20);
      *(_DWORD *)(a1 - 4) = -1;
      sub_1002BB53(v10);
      if ( *(_DWORD *)(v2 + 40) == 2 )
        return sub_10035636(v12);
    }
  }
  return sub_10035636(v12);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1003CE89) --------------------------------------------------------
int __thiscall sub_1003CE89(int this, int *a2, unsigned int *a3, int a4, int a5, unsigned int a6)
{
  int v6; // edx@1
  unsigned int v7; // ebx@1
  int v8; // esi@1
  int v9; // eax@1
  int v10; // eax@4
  int v11; // eax@5
  int v12; // ecx@5
  int v13; // edi@5
  int v14; // esi@8
  int v15; // eax@9
  unsigned int *v16; // eax@13
  int v17; // ecx@13
  int v18; // ebx@15
  int v19; // ecx@17
  int v20; // eax@18
  unsigned int v21; // esi@19
  int v22; // edx@21
  int v23; // edx@21
  int v24; // ecx@23
  int v25; // ecx@25
  int v26; // ecx@25
  char v27; // zf@25
  int v28; // eax@26
  char v29; // cf@30
  int v30; // eax@32
  char v31; // zf@33
  signed int v32; // ecx@39
  unsigned int v33; // eax@44
  int v34; // ecx@44
  int v35; // esi@46
  int v36; // eax@47
  int v37; // ecx@48
  unsigned int *v38; // eax@56
  unsigned int v39; // esi@58
  int v40; // eax@60
  int v41; // edx@63
  int v42; // edx@63
  int v43; // ecx@65
  int v44; // eax@67
  unsigned int v45; // ecx@68
  int v46; // edx@77
  int v47; // ecx@77
  int v49; // [sp+Ch] [bp-48h]@1
  int v50; // [sp+Ch] [bp-48h]@59
  int v51; // [sp+Ch] [bp-48h]@63
  unsigned int v52; // [sp+10h] [bp-44h]@4
  int v53; // [sp+14h] [bp-40h]@21
  int v54; // [sp+18h] [bp-3Ch]@4
  int v55; // [sp+1Ch] [bp-38h]@5
  unsigned int v56; // [sp+1Ch] [bp-38h]@19
  unsigned int v57; // [sp+1Ch] [bp-38h]@61
  int v58; // [sp+20h] [bp-34h]@17
  int v59; // [sp+24h] [bp-30h]@4
  int v60; // [sp+28h] [bp-2Ch]@4
  unsigned int v61; // [sp+2Ch] [bp-28h]@6
  unsigned int v62; // [sp+30h] [bp-24h]@8
  unsigned int v63; // [sp+34h] [bp-20h]@14
  int v64; // [sp+38h] [bp-1Ch]@1
  int v65; // [sp+3Ch] [bp-18h]@4
  int v66; // [sp+40h] [bp-14h]@1
  int v67; // [sp+44h] [bp-10h]@1
  int v68; // [sp+48h] [bp-Ch]@13
  signed int v69; // [sp+4Ch] [bp-8h]@8
  signed int v70; // [sp+50h] [bp-4h]@4
  int v71; // [sp+5Ch] [bp+8h]@59
  int v72; // [sp+68h] [bp+14h]@44
  char v73; // [sp+6Bh] [bp+17h]@2

  v6 = a4;
  v9 = *(_DWORD *)(a4 + 16);
  v8 = *(_DWORD *)(v9 + 20);
  v64 = *(_DWORD *)(v9 + 16);
  v7 = 0;
  v67 = this;
  v49 = *(_DWORD *)(a4 + 16);
  v66 = *(_DWORD *)(v9 + 20);
  if ( a5 == 1 )
    v73 = 0;
  else
    v73 = *(_BYTE *)(a4 + 32);
  v10 = *(_DWORD *)(a4 + 44);
  v54 = 0;
  v70 = -1;
  v65 = 0;
  v60 = 0;
  v59 = v10;
  v52 = *(_DWORD *)(this + 24);
  if ( v10 >= v52 )
    goto LABEL_78;
  do
  {
    v12 = *(_DWORD *)(v8 + 4 * v10);
    v11 = 52 * *(_DWORD *)(v8 + 4 * v10);
    v55 = v11;
    v13 = v65;
    if ( *(_DWORD *)(v11 + v64 + 28) == v7 )
    {
      v61 = *(_DWORD *)(v6 + 4);
      if ( v61 >= *(_DWORD *)(v11 + v64 + 4) )
        v61 = *(_DWORD *)(v11 + v64 + 4);
      v13 = v65;
      v14 = v7;
      v62 = v7;
      v69 = v7;
      if ( *a2 )
      {
        v15 = *(_DWORD *)(40 * v12 + *(_DWORD *)(v67 + 72) + 8);
        if ( v15 )
        {
          if ( *a2 < (unsigned int)v15 )
            v15 = *a2;
          v14 = 1;
          v62 = v15;
          v69 = 1;
        }
      }
      v16 = a3;
      v17 = v7;
      v68 = v7;
      if ( *a3 )
      {
        v63 = v7;
        if ( a6 )
        {
          v18 = v55;
          do
          {
            if ( v17 >= *v16 )
              break;
            v58 = *(_DWORD *)(*(_DWORD *)(v67 + 88) + 4 * v63);
            v19 = *(_DWORD *)(v58 + 16);
            if ( *(_DWORD *)(v19 + 160) <= *(_DWORD *)(v58 + 36) )
              goto LABEL_82;
            v20 = *(_DWORD *)(v19 + 16);
            if ( *(_DWORD *)(v18 + v20 + 28) == *(_DWORD *)(v18 + v20 + 36) )
              goto LABEL_82;
            v21 = *(_DWORD *)(v18 + v20 + 44);
            v56 = *(_DWORD *)(v58 + 40);
            if ( v21 < v56 )
              v56 = *(_DWORD *)(v18 + v20 + 44);
            v23 = *(_DWORD *)(v18 + v20 + 32);
            v53 = v23;
            v22 = v23 - v21;
            if ( (unsigned int)v22 >= *(_DWORD *)(v58 + 44) )
              v22 = *(_DWORD *)(v58 + 44);
            v24 = *(_DWORD *)(v18 + v20 + 28) - *(_DWORD *)(v18 + v20 + 36) - v53;
            if ( (unsigned int)v24 >= *(_DWORD *)(v58 + 48) )
              v24 = *(_DWORD *)(v58 + 48);
            v26 = v22 + v24;
            v27 = v56 + v26 == 0;
            v25 = v56 + v26;
            if ( v27 )
            {
LABEL_82:
              v14 = v69;
              v17 = v68;
            }
            else
            {
              v28 = *a3 - v68;
              if ( v28 >= (unsigned int)v25 )
                v28 = v25;
              v17 = v28 + v68;
              v14 = v69 + 1;
              v68 += v28;
              ++v69;
            }
            v29 = v63++ + 1 < a6;
            v16 = a3;
          }
          while ( v29 );
          v13 = v65;
          v6 = a4;
          v7 = 0;
        }
      }
      v30 = v17 + v62;
      if ( v73 )
      {
        v31 = v30 == v61;
      }
      else
      {
        if ( v13 < v61 && v30 > (unsigned int)v13 )
        {
LABEL_39:
          v32 = v59;
          v13 = v30;
          v60 = v14;
          v8 = v66;
          v70 = v59;
          v65 = v30;
          goto LABEL_42;
        }
        v31 = v30 == v13;
      }
      if ( v31 && v14 > (unsigned int)v60 )
        goto LABEL_39;
      v8 = v66;
    }
    v32 = v70;
LABEL_42:
    v10 = v59 + 1;
    v59 = v10;
  }
  while ( v10 < v52 );
  if ( v32 == -1 )
  {
LABEL_78:
    *(_BYTE *)(v6 + 32) = v7;
    return v54;
  }
  v33 = *(_DWORD *)(v6 + 4);
  v34 = *(_DWORD *)(v8 + 4 * v32);
  v72 = v34;
  if ( v33 < v13 )
    v13 = *(_DWORD *)(v6 + 4);
  *(_DWORD *)(v6 + 4) = v33 - v13;
  v54 = v13;
  v35 = *a2;
  if ( *a2 )
  {
    v36 = *(_DWORD *)(40 * v34 + *(_DWORD *)(v67 + 72) + 8);
    if ( v36 )
    {
      v37 = *a2;
      if ( v35 >= (unsigned int)v36 )
        v37 = v36;
      if ( v37 >= (unsigned int)v13 )
      {
        v35 = v13;
      }
      else
      {
        if ( v35 >= (unsigned int)v36 )
          v35 = v36;
      }
      sub_1003CB9B(v67, v49, v72, v35, v7);
      *a2 -= v35;
      v13 -= v35;
    }
  }
  if ( v13 )
  {
    v38 = a3;
    if ( *a3 > v7 )
    {
      do
      {
        if ( v7 >= a6 )
          break;
        v39 = *v38;
        if ( !*v38 )
          break;
        v71 = *(_DWORD *)(*(_DWORD *)(v67 + 88) + 4 * v7++);
        v50 = *(_DWORD *)(v71 + 16);
        if ( *(_DWORD *)(v50 + 160) <= *(_DWORD *)(v71 + 36) )
          goto LABEL_83;
        v40 = *(_DWORD *)(v50 + 16) + 52 * v72;
        if ( *(_DWORD *)(v40 + 28) == *(_DWORD *)(v40 + 36) )
          goto LABEL_83;
        v57 = *(_DWORD *)(v71 + 40);
        if ( *(_DWORD *)(v40 + 44) < v57 )
          v57 = *(_DWORD *)(v40 + 44);
        v42 = *(_DWORD *)(v40 + 32);
        v51 = v42;
        v41 = v42 - *(_DWORD *)(v40 + 44);
        if ( (unsigned int)v41 >= *(_DWORD *)(v71 + 44) )
          v41 = *(_DWORD *)(v71 + 44);
        v43 = *(_DWORD *)(v40 + 28) - *(_DWORD *)(v40 + 36) - v51;
        if ( (unsigned int)v43 >= *(_DWORD *)(v71 + 48) )
          v43 = *(_DWORD *)(v71 + 48);
        v44 = v57 + v43 + v41;
        if ( v57 + v43 + v41 )
        {
          v45 = v39;
          if ( v39 >= v44 )
            v45 = v44;
          if ( v45 >= v13 )
          {
            v39 = v13;
          }
          else
          {
            if ( v39 >= v44 )
              v39 = v44;
          }
          sub_1003CC07((void *)v67, v71, *(_DWORD *)(a4 + 16), v72, v39);
          v38 = a3;
          *v38 -= v39;
          v13 -= v39;
        }
        else
        {
LABEL_83:
          v38 = a3;
        }
      }
      while ( v13 );
    }
  }
  v46 = *(_DWORD *)(a4 + 44);
  v47 = *(_DWORD *)(v66 + 4 * v46);
  *(_DWORD *)(v66 + 4 * v46) = *(_DWORD *)(v66 + 4 * v70);
  *(_DWORD *)(v66 + 4 * v70) = v47;
  ++*(_DWORD *)(a4 + 44);
  *(_BYTE *)(a4 + 32) = 1;
  return v54;
}

//----- (1003D1CE) --------------------------------------------------------
int __thiscall sub_1003D1CE(void *this, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // eax@1
  signed int v8; // edx@4
  int v9; // ecx@4
  int v10; // eax@5
  int v11; // eax@5
  unsigned int v12; // eax@8
  signed int v13; // eax@14
  int v14; // edx@19
  int v15; // ecx@19
  unsigned int v17; // [sp+Ch] [bp-1Ch]@4
  int v18; // [sp+10h] [bp-18h]@1
  unsigned int v19; // [sp+14h] [bp-14h]@6
  int v20; // [sp+18h] [bp-10h]@1
  int v21; // [sp+1Ch] [bp-Ch]@5
  int v22; // [sp+1Ch] [bp-Ch]@8
  unsigned int v23; // [sp+20h] [bp-8h]@4
  signed int v24; // [sp+24h] [bp-4h]@4
  char v25; // [sp+3Bh] [bp+13h]@2

  v6 = a3;
  v20 = (int)this;
  v7 = *(_DWORD *)(a3 + 16);
  v4 = 0;
  v5 = *(_DWORD *)(v7 + 20);
  v18 = *(_DWORD *)(v7 + 16);
  if ( a4 == 1 )
    v25 = 0;
  else
    v25 = *(_BYTE *)(a3 + 32);
  v8 = *(_DWORD *)(a3 + 44);
  v24 = -1;
  v9 = 0;
  v23 = 0;
  v17 = *(_DWORD *)(v20 + 24);
  if ( v8 >= v17 )
    goto LABEL_27;
  while ( 1 )
  {
    v11 = *(_DWORD *)(v5 + 4 * v8);
    v21 = v11;
    v10 = v18 + 52 * v11;
    if ( !*(_DWORD *)(v10 + 28) )
      break;
LABEL_14:
    v13 = v24;
LABEL_15:
    ++v8;
    if ( v8 >= v17 )
      goto LABEL_16;
  }
  v19 = *(_DWORD *)(v6 + 4);
  if ( v19 >= *(_DWORD *)(v10 + 4) )
    v19 = *(_DWORD *)(v10 + 4);
  v22 = 40 * v21;
  v9 = 0;
  v12 = *(_DWORD *)(v22 + *(_DWORD *)(v20 + 72) + 28);
  v6 = a3;
  if ( v12 )
  {
    v9 = a2;
    if ( a2 >= v12 )
      v9 = *(_DWORD *)(v22 + *(_DWORD *)(v20 + 72) + 28);
  }
  if ( v25 )
  {
    if ( v9 == v19 )
      goto LABEL_21;
    goto LABEL_13;
  }
  if ( v9 <= v23 )
  {
LABEL_13:
    v9 = v23;
    goto LABEL_14;
  }
LABEL_21:
  v13 = v8;
  v24 = v8;
  v23 = v9;
  if ( !v25 )
    goto LABEL_15;
LABEL_16:
  if ( v13 == -1 )
  {
LABEL_27:
    *(_BYTE *)(v6 + 32) = 0;
    return v4;
  }
  v4 = *(_DWORD *)(v6 + 4);
  if ( v4 >= (unsigned int)v9 )
    v4 = v9;
  sub_1003CB9B(v20, *(_DWORD *)(v6 + 16), *(_DWORD *)(v5 + 4 * v13), v4, 1);
  *(_DWORD *)(v6 + 4) -= v4;
  v14 = *(_DWORD *)(v6 + 44);
  v15 = *(_DWORD *)(v5 + 4 * v14);
  *(_DWORD *)(v5 + 4 * v14) = *(_DWORD *)(v5 + 4 * v24);
  *(_DWORD *)(v5 + 4 * v24) = v15;
  ++*(_DWORD *)(v6 + 44);
  *(_BYTE *)(v6 + 32) = 1;
  return v4;
}

//----- (1003D2DA) --------------------------------------------------------
char __thiscall sub_1003D2DA(void *this, int a2, int a3, int a4, unsigned int a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  char v7; // bl@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // eax@1
  int v11; // ecx@5
  int v12; // ecx@7
  int v13; // edx@8
  int v15; // [sp+Ch] [bp-8h]@1
  int v16; // [sp+10h] [bp-4h]@1
  int v17; // [sp+1Ch] [bp+8h]@5
  int v18; // [sp+24h] [bp+10h]@1

  v9 = a4;
  v16 = (int)this;
  v10 = *(_DWORD *)(a4 + 16);
  v15 = *(_DWORD *)(v10 + 16);
  v6 = *(_DWORD *)(*(_DWORD *)(v10 + 20) + 4 * *(_DWORD *)(a4 + 44));
  v5 = v16;
  v7 = 0;
  v8 = 52 * v6;
  v18 = *(_DWORD *)(*(_DWORD *)(v10 + 20) + 4 * *(_DWORD *)(a4 + 44));
  if ( *(_DWORD *)a2 && *(_DWORD *)(40 * v6 + *(_DWORD *)(v16 + 72) + 8) )
  {
    v7 = 1;
    sub_1003CB9B(v16, *(_DWORD *)(v9 + 16), v18, 1, 0);
    --*(_DWORD *)a2;
  }
  else
  {
    if ( !*(_DWORD *)a3 || (v11 = 0, v17 = 0, !a5) )
    {
LABEL_20:
      ++*(_DWORD *)(v9 + 44);
      return v7;
    }
    while ( !v7 )
    {
      v12 = *(_DWORD *)(*(_DWORD *)(v5 + 88) + 4 * v11);
      if ( *(_DWORD *)(*(_DWORD *)(v12 + 16) + 160) > *(_DWORD *)(v12 + 36) )
      {
        v13 = *(_DWORD *)(*(_DWORD *)(v12 + 16) + 16);
        if ( *(_DWORD *)(v8 + v13 + 44)
          || *(_DWORD *)(v8 + v13 + 32) != *(_DWORD *)(v8 + v13 + 44) && *(_DWORD *)(v12 + 44)
          || *(_DWORD *)(v8 + v13 + 28) != *(_DWORD *)(v8 + v13 + 36) && *(_DWORD *)(v12 + 48) )
        {
          v7 = 1;
          sub_1003CC07((void *)v16, v12, *(_DWORD *)(v9 + 16), v18, 1u);
          --*(_DWORD *)a3;
        }
        v5 = v16;
      }
      v11 = v17 + 1;
      v17 = v11;
      if ( v11 >= a5 )
      {
        if ( !v7 )
          goto LABEL_20;
        break;
      }
    }
  }
  if ( *(_DWORD *)(v8 + v15 + 28) == *(_DWORD *)(v8 + v15 + 4) )
    ++*(_DWORD *)(v9 + 44);
  --*(_DWORD *)(v9 + 4);
  return v7;
}

//----- (1003D3E4) --------------------------------------------------------
int __thiscall sub_1003D3E4(int this, __int16 a2)
{
  int v2; // eax@1
  signed int v3; // esi@1
  int v4; // edx@2
  int v5; // ecx@2
  int result; // eax@5

  v3 = *(_WORD *)this;
  v2 = 0;
  if ( v3 <= 0 )
  {
LABEL_5:
    result = 0;
  }
  else
  {
    v5 = *(_DWORD *)(this + 4);
    v4 = 0;
    while ( *(_WORD *)(12 * v4 + v5 + 4) != a2 )
    {
      ++v2;
      v4 = (unsigned __int16)v2;
      if ( (unsigned __int16)v2 >= v3 )
        goto LABEL_5;
    }
    result = v5 + 12 * (unsigned __int16)v2;
  }
  return result;
}

//----- (1003D41F) --------------------------------------------------------
BOOL __thiscall sub_1003D41F(DWORD this)
{
  BOOL result; // eax@2
  DWORD flOldProtect; // [sp+0h] [bp-4h]@1

  flOldProtect = this;
  if ( dword_100769D4 < 3 )
  {
    result = *(_DWORD *)(this + 140);
    if ( *(_BYTE *)result == 1 )
      result = VirtualProtect((LPVOID)result, 1u, 2u, &flOldProtect);
  }
  else
  {
    result = sub_1003952A();
  }
  return result;
}
// 100769D4: using guessed type int dword_100769D4;

//----- (1003D44F) --------------------------------------------------------
int __thiscall sub_1003D44F(int this)
{
  return *(_DWORD *)(this + 24);
}

//----- (1003D453) --------------------------------------------------------
int __usercall sub_1003D453<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4<esi>)
{
  int v4; // eax@2

  sub_10035668();
  if ( !dword_100769C4 )
  {
    *(_DWORD *)(a2 - 16) = &dword_10077074;
    sub_10030F90(&dword_10077074);
    v4 = dword_100769C4;
    *(_DWORD *)(a2 - 4) = 0;
    if ( !v4 )
      sub_1003DB93(a1, a3, a4, 0);
    dword_10077074 = 0;
  }
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 100769C4: using guessed type int dword_100769C4;
// 10077074: using guessed type int dword_10077074;

//----- (1003D49E) --------------------------------------------------------
int __userpurge sub_1003D49E<eax>(int a1<ecx>, int a2<esi>, int a3)
{
  int v3; // ebx@1
  int ebp0; // ebp@0
  signed int v5; // eax@2
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // esi@2
  unsigned int v9; // edx@5
  int v10; // edi@6
  int result; // eax@14
  signed int v12; // eax@21
  int v13; // eax@21
  int v14; // edx@21
  int v15; // ecx@21
  int v16; // ecx@21
  unsigned int v17; // esi@23
  int v18; // edi@24
  int v19; // ecx@33
  char v20; // [sp+Ch] [bp-18h]@33
  int v21; // [sp+18h] [bp-Ch]@2
  int v22; // [sp+1Ch] [bp-8h]@2
  unsigned __int16 v23; // [sp+20h] [bp-4h]@2
  unsigned __int8 v24; // [sp+22h] [bp-2h]@2

  v3 = a1;
  if ( sub_1003F546(ebp0, a2) < 4 )
  {
    if ( sub_1003F546(ebp0, a2) != 2 && sub_1003F546(ebp0, a2) != 3 )
    {
      if ( dword_100769D4 == 1 )
      {
        if ( a3 )
          *(_DWORD *)a3 = 0;
        result = 0;
      }
      else
      {
        sub_100300C4((int)&v20);
        sub_100355DB((int)&v20, (int)&unk_1006CB98);
        __asm { int     3               ; Trap to Debugger }
        result = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v19 + 4) + 32) + 32);
      }
      return result;
    }
    v13 = sub_10039554();
    v16 = v13;
    v12 = 1 << v13;
    v21 = v16;
    v15 = *(_DWORD *)(v3 + 72);
    v14 = 0;
    v22 = v12;
    while ( 1 )
    {
      if ( v12 & *(_DWORD *)v15 )
      {
        v17 = 0;
        if ( *(_DWORD *)(v15 + 4) )
        {
          v18 = *(_DWORD *)(v15 + 32) + 8;
          do
          {
            if ( *(_BYTE *)v18 == v21 )
            {
              if ( a3 )
                *(_DWORD *)a3 = v17;
              return v14;
            }
            ++v17;
            v18 += 36;
          }
          while ( v17 < *(_DWORD *)(v15 + 4) );
          v12 = v22;
        }
      }
      ++v14;
      v15 += 40;
    }
  }
  sub_1003B5AE((int)&v23);
  v6 = v23;
  v5 = 1 << v24;
  v22 = v24;
  v7 = *(_DWORD *)(v3 + 72);
  v8 = 0;
  v21 = 1 << v24;
  while ( *(_DWORD *)(v7 + 12) != v6 || !(v5 & *(_DWORD *)v7) )
  {
LABEL_11:
    ++v8;
    v7 += 40;
  }
  v9 = 0;
  if ( !*(_DWORD *)(v7 + 4) )
  {
LABEL_10:
    v6 = v23;
    goto LABEL_11;
  }
  v10 = *(_DWORD *)(v7 + 32) + 8;
  while ( *(_BYTE *)v10 != v22 )
  {
    ++v9;
    v10 += 36;
    if ( v9 >= *(_DWORD *)(v7 + 4) )
    {
      v5 = v21;
      goto LABEL_10;
    }
  }
  if ( a3 )
    *(_DWORD *)a3 = v9;
  return v8;
}
// 100769D4: using guessed type int dword_100769D4;

//----- (1003D5B6) --------------------------------------------------------
int __thiscall sub_1003D5B6(int this)
{
  return *(_DWORD *)(*(_DWORD *)(this + 72) + 36);
}

//----- (1003D5BD) --------------------------------------------------------
int __thiscall sub_1003D5BD(int this)
{
  return *(_DWORD *)(*(_DWORD *)(this + 4) + 4);
}

//----- (1003D5C4) --------------------------------------------------------
int __thiscall sub_1003D5C4(int this)
{
  return *(_DWORD *)(*(_DWORD *)(this + 4) + 16);
}

//----- (1003D5CB) --------------------------------------------------------
int __thiscall sub_1003D5CB(int this)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1003D5F9(*(_DWORD *)(*(_DWORD *)(this + 4) + 12), *(_DWORD *)(this + 4));
  if ( v1 )
    result = *(_DWORD *)(v1 + 32);
  else
    result = 0;
  return result;
}

//----- (1003D5E2) --------------------------------------------------------
int __thiscall sub_1003D5E2(int this)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1003D61E(*(_DWORD *)(*(_DWORD *)(this + 4) + 24), *(_DWORD *)(this + 4));
  if ( v1 )
    result = *(_DWORD *)(v1 + 36);
  else
    result = 0;
  return result;
}

//----- (1003D5F9) --------------------------------------------------------
int __thiscall sub_1003D5F9(int this, int a2)
{
  int v2; // eax@1
  int result; // eax@2

  v2 = (a2 - *(_DWORD *)(this + 32)) / 36 + 1;
  if ( (unsigned int)v2 >= *(_DWORD *)(this + 4) )
    result = 0;
  else
    result = *(_DWORD *)(this + 32) + 36 * v2;
  return result;
}

//----- (1003D61E) --------------------------------------------------------
int __thiscall sub_1003D61E(int this, int a2)
{
  int v2; // eax@1
  int result; // eax@2

  v2 = (a2 - *(_DWORD *)(this + 72)) / 40 + 1;
  if ( (unsigned int)v2 >= *(_DWORD *)(this + 24) )
    result = 0;
  else
    result = *(_DWORD *)(this + 72) + 40 * v2;
  return result;
}

//----- (1003D643) --------------------------------------------------------
int __usercall sub_1003D643<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4<esi>)
{
  int v4; // eax@2

  sub_10035668();
  if ( !dword_100769CC )
  {
    *(_DWORD *)(a2 - 16) = &dword_10077074;
    sub_10030F90(&dword_10077074);
    v4 = dword_100769CC;
    *(_DWORD *)(a2 - 4) = 0;
    if ( !v4 )
      sub_1003DB93(a1, a3, a4, 0);
    dword_10077074 = 0;
  }
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 100769CC: using guessed type int dword_100769CC;
// 10077074: using guessed type int dword_10077074;

//----- (1003D68E) --------------------------------------------------------
int __thiscall sub_1003D68E(int this)
{
  return *(_DWORD *)(*(_DWORD *)(this + 4) + 20);
}

//----- (1003D6A4) --------------------------------------------------------
int __cdecl sub_1003D6A4()
{
  _ECX = &unk_10074360;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return _EAX + 1;
}

//----- (1003D6B2) --------------------------------------------------------
int __usercall sub_1003D6B2<eax>(int a1<ebx>, int a2)
{
  int result; // eax@2

  if ( dword_100769D4 < 4 )
    result = sub_1003B5C4(a1, (int)&dword_100769D8);
  else
    result = sub_1003B65F(a2, (int)&dword_100769D8);
  dword_100769DC = (LPVOID)result;
  return result;
}
// 1003B65F: using guessed type int __cdecl sub_1003B65F(int, int);
// 100769D4: using guessed type int dword_100769D4;
// 100769D8: using guessed type int dword_100769D8;

//----- (1003D6DB) --------------------------------------------------------
unsigned int __thiscall sub_1003D6DB(int this, int a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // edx@1
  int ebp0; // ebp@0
  int v6; // ecx@2
  int v7; // esi@2
  int v8; // ebx@4
  int v9; // eax@5
  int v10; // edi@6
  int v11; // eax@8
  int v12; // ecx@8
  unsigned int v13; // [sp+Ch] [bp-14h]@1
  int v14; // [sp+10h] [bp-10h]@5
  int v15; // [sp+14h] [bp-Ch]@5
  int v16; // [sp+18h] [bp-8h]@1
  int v17; // [sp+1Ch] [bp-4h]@2

  v4 = this;
  result = 0;
  v16 = this;
  v13 = 0;
  if ( *(_DWORD *)(this + 24) )
  {
    v6 = 0;
    v17 = 0;
    v7 = *(_DWORD *)(a2 + 16) + 44;
    do
    {
      if ( *(_DWORD *)(v7 - 12) )
      {
        v8 = 0;
        if ( *(_DWORD *)(v7 - 40) )
        {
          v15 = 0;
          v9 = 0;
          v14 = 0;
          do
          {
            v10 = v9 + *(_DWORD *)(v7 + 4);
            if ( *(_DWORD *)v10 == 4 )
            {
              if ( *(_BYTE *)(v10 + 49) )
              {
                v11 = v15 + *(_DWORD *)(v6 + *(_DWORD *)(v4 + 72) + 32);
                v12 = *(_DWORD *)(v11 + 16);
                if ( v12 == 1 )
                {
                  sub_1004CC9B(a2, v7 - 44, v8);
                  v4 = v16;
                  v6 = v17;
                  if ( *(_BYTE *)(v10 + 48) )
                  {
                    --*(_DWORD *)v7;
                    --*(_DWORD *)(a3 + 24);
                  }
                }
                else
                {
                  if ( v12 - *(_DWORD *)(v11 + 28) > (unsigned int)(*(_BYTE *)(v10 + 48) == 0) )
                  {
                    *(_DWORD *)(v11 + 16) = v12 - 1;
                    if ( *(_BYTE *)(v10 + 48) )
                      sub_1003F4D9(v4, v7 - 44, v10, v17 + *(_DWORD *)(v4 + 72), v11, a3);
                    sub_1004CAB7(ebp0, v7 - 44, v8);
                    v4 = v16;
                  }
                  v6 = v17;
                }
              }
            }
            v14 += 52;
            v15 += 36;
            v9 = v14;
            ++v8;
          }
          while ( (unsigned int)v8 < *(_DWORD *)(v7 - 40) );
          result = v13;
        }
      }
      ++result;
      v6 += 40;
      v7 += 52;
      v13 = result;
      v17 = v6;
    }
    while ( result < *(_DWORD *)(v4 + 24) );
  }
  return result;
}

//----- (1003D7F4) --------------------------------------------------------
int __thiscall sub_1003D7F4(void *this, int a2, int a3)
{
  int ebp0; // ebp@0
  int v4; // edi@1
  int v5; // esi@1
  int result; // eax@2
  int v7; // esi@2
  unsigned int v8; // edx@4
  int v9; // edi@5
  int v10; // ecx@8
  int v11; // edx@9
  int v12; // ecx@11
  unsigned int v13; // eax@14
  int v14; // eax@14
  unsigned int v15; // [sp+Ch] [bp-1Ch]@4
  int v16; // [sp+10h] [bp-18h]@14
  int v17; // [sp+14h] [bp-14h]@5
  int v18; // [sp+18h] [bp-10h]@9
  int v19; // [sp+1Ch] [bp-Ch]@8
  int v20; // [sp+20h] [bp-8h]@1
  int v21; // [sp+24h] [bp-4h]@9

  v5 = *(_DWORD *)(a2 + 160);
  v20 = (int)this;
  v4 = v5 - *(_DWORD *)(a2 + 168);
  if ( v5 - *(_DWORD *)(a3 + 24) - *(_DWORD *)(a3 + 36) >= (unsigned int)(v5
                                                                        - *(_DWORD *)(a2 + 168)
                                                                        - (*(_DWORD *)(a2 + 184)
                                                                         + sub_1003DDD2(a2))) )
  {
    result = *(_DWORD *)(a2 + 184) + sub_1003DDD2(a2);
    v7 = v4 - result;
  }
  else
  {
    result = a3;
    v7 = v5 - *(_DWORD *)(a3 + 24) - *(_DWORD *)(a3 + 36);
  }
  v8 = 0;
  v15 = 0;
  if ( v7 )
  {
    v17 = 0;
    v9 = *(_DWORD *)(a2 + 16) + 36;
    do
    {
      result = v20;
      if ( v8 >= *(_DWORD *)(v20 + 24) )
        break;
      result = *(_DWORD *)(v9 - 8) - *(_DWORD *)v9;
      if ( *(_DWORD *)(v9 - 8) != *(_DWORD *)v9 )
      {
        v10 = 0;
        v19 = 0;
        if ( v7 )
        {
          v21 = 0;
          result = 0;
          v11 = 0;
          v18 = 0;
          do
          {
            if ( (unsigned int)v10 >= *(_DWORD *)(v9 - 32) )
              break;
            v12 = v11 + *(_DWORD *)(v9 + 12);
            if ( *(_DWORD *)v12 == 4 )
            {
              if ( !*(_DWORD *)(v12 + 40) )
              {
                if ( !*(_BYTE *)(v12 + 49) )
                {
                  v14 = v21 + *(_DWORD *)(*(_DWORD *)(v20 + 72) + v17 + 32);
                  v16 = v14;
                  v13 = *(_DWORD *)(v14 + 16);
                  if ( v13 > 1 )
                  {
                    *(_DWORD *)(v16 + 16) = v13 - 1;
                    if ( *(_BYTE *)(v12 + 48) )
                      sub_1003F4D9(v20, v9 - 36, v12, v17 + *(_DWORD *)(v20 + 72), v16, a3);
                    sub_1004CAB7(ebp0, v9 - 36, v19);
                    --v7;
                  }
                  v11 = v18;
                }
                result = v21;
              }
            }
            v10 = v19 + 1;
            v11 += 52;
            result += 36;
            ++v19;
            v18 = v11;
            v21 = result;
          }
          while ( v7 );
          v8 = v15;
        }
      }
      v17 += 40;
      ++v8;
      v9 += 52;
      v15 = v8;
    }
    while ( v7 );
  }
  return result;
}

//----- (1003D949) --------------------------------------------------------
void __thiscall sub_1003D949(int this)
{
  int v1; // edi@1
  unsigned int v2; // esi@1
  int v3; // ebx@2
  int v4; // eax@3

  v1 = this;
  v2 = 0;
  if ( *(_DWORD *)(this + 8) )
  {
    do
    {
      v3 = *(_DWORD *)(*(_DWORD *)(v1 + 84) + 4 * v2);
      if ( *(_BYTE *)(v3 + 33) == 1 )
      {
        v4 = sub_1003C119(*(_DWORD *)(v3 + 16));
        *(_DWORD *)(v3 + 36) = sub_1004C0EA(*(void **)(v3 + 16), v4);
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)(v1 + 8) );
  }
}

//----- (1003D97F) --------------------------------------------------------
char __userpurge sub_1003D97F<al>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, char a7)
{
  int v7; // eax@1
  int v8; // esi@1
  char result; // al@4

  v8 = a2;
  v7 = sub_1002ADB1(a1, a2, a3, a4, 8);
  if ( v7 )
  {
    *(_DWORD *)v7 = off_10064BF8;
    *(_DWORD *)(v7 + 4) = v8;
  }
  else
  {
    v7 = 0;
  }
  *(_DWORD *)(v8 + 32) = v7;
  *(_DWORD *)(v8 + 12) = a5;
  *(_DWORD *)(v8 + 4) = a6;
  result = a7;
  *(_BYTE *)(v8 + 8) = a7;
  return result;
}
// 10064BF8: using guessed type int (*off_10064BF8[2])();

//----- (1003D9B8) --------------------------------------------------------
void *__userpurge sub_1003D9B8<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, unsigned __int16 a6, unsigned __int16 a7, void *a8, int a9, char a10)
{
  int v10; // eax@1
  int v11; // esi@1
  int i; // edx@5
  void *v13; // ecx@5
  int v14; // eax@9
  __int64 v15; // qcx@9
  int v16; // edi@9
  signed __int64 v18; // qax@9
  void *v19; // ecx@10
  void *result; // eax@12
  int v21; // edx@12
  signed int v22; // ST08_4@12
  int v23; // edi@13
  int v24; // eax@16
  int v25; // edx@16
  char v26; // [sp-4h] [bp-10h]@16
  int v27; // [sp+1Ch] [bp+10h]@16

  v11 = a2;
  v10 = sub_1002ADB1(a1, a2, a3, a4, 8);
  if ( v10 )
  {
    *(_DWORD *)v10 = off_10064C04;
    *(_DWORD *)(v10 + 4) = v11;
  }
  else
  {
    v10 = 0;
  }
  *(_DWORD *)(v11 + 36) = v10;
  *(_DWORD *)(v11 + 24) = a5;
  *(_DWORD *)(v11 + 16) = a6;
  *(_DWORD *)(v11 + 12) = a7;
  *(_DWORD *)v11 = a8;
  if ( a9 )
  {
    *(_DWORD *)(v11 + 4) = a9;
  }
  else
  {
    v13 = a8;
    for ( i = 0; v13; v13 = (void *)((unsigned int)((char *)v13 - 1) & (unsigned int)v13) )
      ++i;
    *(_DWORD *)(v11 + 4) = (unsigned __int16)i;
  }
  v16 = *(_DWORD *)(v11 + 4);
  _ECX = 0;
  v18 = 36i64 * *(_DWORD *)(v11 + 4);
  __asm { seto    cl }
  *(_DWORD *)(v11 + 8) = 0;
  v15 = (_DWORD)v18 | (unsigned int)-_ECX;
  v14 = sub_1002965B(SHIDWORD(v18), v15 + 4, SHIDWORD(v15), v16, (v15 + 4) | -((_DWORD)v15 >= 0xFFFFFFFCu));
  if ( v14 )
  {
    *(_DWORD *)v14 = v16;
    v19 = (void *)(v14 + 4);
  }
  else
  {
    v19 = 0;
  }
  v22 = 36 * *(_DWORD *)(v11 + 4);
  *(_DWORD *)(v11 + 32) = v19;
  result = sub_10039210(v19, 0, v22);
  v21 = 0;
  if ( *(_DWORD *)(v11 + 4) > 0u )
  {
    result = a8;
    LODWORD(v15) = a9;
    v23 = 0;
    while ( !(_DWORD)v15 )
    {
      if ( (_BYTE)result & 1 )
      {
        v24 = *(_DWORD *)(v11 + 12);
        LODWORD(v15) = v23 + *(_DWORD *)(v11 + 32);
        v25 = v21 + 1;
        v27 = v25;
        v26 = BYTE4(v15);
LABEL_18:
        v23 += 36;
        sub_1003D97F(v25, v15, SHIDWORD(v15), v23, v11, HIDWORD(v15) + (v24 << 8), v26);
        LODWORD(v15) = a9;
        v21 = v27;
        result = a8;
      }
      result = (void *)((unsigned int)result >> 1);
      v15 += 4294967296i64;
      a8 = result;
      if ( (unsigned int)v21 >= *(_DWORD *)(v11 + 4) )
        return result;
    }
    LODWORD(v15) = v23 + *(_DWORD *)(v11 + 32);
    v26 = BYTE4(v15) + a10;
    v27 = v21 + 1;
    v25 = a6;
    v24 = a6 + (*(_DWORD *)(v11 + 12) << 8);
    goto LABEL_18;
  }
  return result;
}
// 10064C04: using guessed type int (*off_10064C04[4])();

//----- (1003DAD1) --------------------------------------------------------
void *__thiscall sub_1003DAD1(int this)
{
  unsigned int v1; // eax@1
  int v2; // esi@1
  void *v3; // ST10_4@3
  signed __int64 v5; // qax@3
  signed __int64 v7; // qax@4
  signed __int64 v9; // qax@4
  void *result; // eax@5

  v2 = this;
  v1 = *(_DWORD *)(this + 12);
  if ( v1 < *(_DWORD *)(this + 8) )
  {
    do
      v1 *= 2;
    while ( v1 < *(_DWORD *)(this + 8) );
    v3 = *(void **)(this + 84);
    *(_DWORD *)(this + 12) = v1;
    sub_10030383(v3);
    sub_10030383(*(LPVOID *)(v2 + 88));
    sub_10030383(*(LPVOID *)(v2 + 92));
    _ECX = 0;
    v5 = 4i64 * *(_DWORD *)(v2 + 12);
    __asm { seto    cl }
    *(_DWORD *)(v2 + 84) = sub_1002965B(SHIDWORD(v5), v5 | -_ECX, 4, 0, v5 | -_ECX);
    if ( *(_DWORD *)(v2 + 88) )
    {
      _ECX = 0;
      v7 = 4i64 * *(_DWORD *)(v2 + 12);
      __asm { seto    cl }
      *(_DWORD *)(v2 + 88) = sub_1002965B(SHIDWORD(v7), v7 | -_ECX, 4, 0, v7 | -_ECX);
      _ECX = 0;
      v9 = 4i64 * *(_DWORD *)(v2 + 12);
      __asm { seto    cl }
      *(_DWORD *)(v2 + 92) = sub_1002965B(SHIDWORD(v9), v9 | -_ECX, 4, 0, v9 | -_ECX);
    }
  }
  result = sub_10039210(*(void **)(v2 + 84), 0, 4 * *(_DWORD *)(v2 + 8));
  if ( *(_DWORD *)(v2 + 88) )
  {
    sub_10039210(*(void **)(v2 + 88), 0, 4 * *(_DWORD *)(v2 + 8));
    result = sub_10039210(*(void **)(v2 + 92), 0, 4 * *(_DWORD *)(v2 + 8));
  }
  return result;
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (1003DB93) --------------------------------------------------------
void __usercall sub_1003DB93(int a1<ebx>, int a2<edi>, int a3<esi>, char a4)
{
  signed int v4; // eax@1
  int ebp0; // ebp@0
  int v6; // ecx@3
  int v7; // edx@6
  unsigned int v8; // ecx@6
  int v9; // ebx@6
  LPVOID v10; // edi@6
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // ecx@9
  int v14; // edx@10
  unsigned int v15; // eax@24
  int v16; // ecx@24
  int v17; // edi@24
  int v18; // esi@24
  int v19; // ecx@26
  int v20; // edx@27
  ULONG_PTR v21; // ecx@42
  int i; // edx@44
  void *v23; // esi@47
  int v24; // [sp+0h] [bp-10h]@6
  int v25; // [sp+4h] [bp-Ch]@6
  int v26; // [sp+4h] [bp-Ch]@24
  int v27; // [sp+8h] [bp-8h]@6
  signed int v28; // [sp+8h] [bp-8h]@8
  unsigned int v29; // [sp+Ch] [bp-4h]@6
  unsigned int v30; // [sp+Ch] [bp-4h]@24

  v4 = dword_100769D4;
  if ( !dword_100769D4 )
  {
    sub_1003EE6C(a3);
    v4 = dword_100769D4;
  }
  v6 = dword_100769BC;
  if ( !dword_100769BC )
  {
    sub_1003BB87(a1, ebp0, a2);
    v4 = dword_100769D4;
    v6 = dword_100769BC;
  }
  if ( v4 >= 4 )
  {
    sub_1003D6B2(a1, 65535);
    v10 = dword_100769DC;
    v8 = 0;
    v11 = 0;
    v7 = 0;
    v9 = 0;
    v29 = 0;
    v27 = 0;
    v25 = 0;
    v24 = 0;
    if ( dword_100769D8 )
    {
      do
      {
        if ( *(_DWORD *)v10 == 3 )
        {
          v28 = 0;
          v12 = (int)((char *)v10 + 32);
          do
          {
            sub_1003BB4E(v12);
            v13 = *(_DWORD *)v12;
            if ( *(_DWORD *)v12 )
            {
              ++v11;
              v14 = 0;
              do
              {
                ++v14;
                v13 &= v13 - 1;
              }
              while ( v13 );
              v25 += (unsigned __int16)v14;
            }
            v12 += 12;
            ++v28;
          }
          while ( v28 < *((_WORD *)v10 + 15) );
          v9 = v24;
          v8 = v29;
          v27 = v11;
        }
        if ( *(_DWORD *)v10 == 1 )
        {
          sub_1003BB4E((int)((char *)v10 + 32));
          v11 = v27;
          v8 = v29;
          if ( *((_DWORD *)v10 + 8) )
          {
            ++v9;
            v24 = v9;
          }
        }
        v8 += *((_DWORD *)v10 + 1);
        v10 = (char *)v10 + *((_DWORD *)v10 + 1);
        v29 = v8;
      }
      while ( v8 < dword_100769D8 );
      v7 = v25;
    }
    byte_100769C8 = v11 > (unsigned int)v9;
    dword_100769CC = v11;
    if ( v11 <= (unsigned int)v9 )
      dword_100769CC = v9;
    dword_100769C4 = v7;
    dword_100769D0 = v9;
LABEL_39:
    if ( !a4 )
      sub_1003BC9E(v9);
    goto LABEL_47;
  }
  if ( v4 == 3 )
  {
    sub_1003D6B2(a1, 65535);
    v18 = (int)dword_100769DC;
    v15 = 0;
    v16 = 0;
    v9 = 0;
    v17 = 0;
    v30 = 0;
    v26 = 0;
    if ( dword_100769D8 )
    {
      do
      {
        if ( *(_DWORD *)(v18 + 4) == 3 )
        {
          sub_1003BB1F(v18);
          v19 = *(_DWORD *)v18;
          if ( *(_DWORD *)v18 )
          {
            ++v9;
            v20 = 0;
            do
            {
              ++v20;
              v19 &= v19 - 1;
            }
            while ( v19 );
            v26 += (unsigned __int16)v20;
          }
          v15 = v30;
        }
        if ( *(_DWORD *)(v18 + 4) == 1 )
        {
          sub_1003BB1F(v18);
          v15 = v30;
          if ( *(_DWORD *)v18 )
            ++v17;
        }
        v15 += 24;
        v18 += 24;
        v30 = v15;
      }
      while ( v15 < dword_100769D8 );
      v16 = v26;
    }
    byte_100769C8 = v9 > (unsigned int)v17;
    dword_100769CC = v9;
    if ( v9 <= (unsigned int)v17 )
      dword_100769CC = v17;
    dword_100769C4 = v16;
    dword_100769D0 = v17;
    goto LABEL_39;
  }
  byte_100769C8 = 0;
  dword_100769CC = 1;
  if ( v6 )
  {
    sub_1003BB87(a1, ebp0, a2);
    v21 = *(_DWORD *)sub_1003D3E4(dword_100769BC, 0) & ProcessAffinityMask;
  }
  else
  {
    v21 = ProcessAffinityMask;
  }
  for ( i = 0; v21; v21 &= v21 - 1 )
    ++i;
  dword_100769C4 = (unsigned __int16)i;
  dword_100769D0 = 1;
LABEL_47:
  v23 = (void *)dword_100769C0;
  if ( dword_100769C0 )
  {
    sub_1002A4AA(*(LPVOID *)(dword_100769C0 + 4));
    sub_1002A4AA(v23);
  }
  dword_100769C0 = 0;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100769BC: using guessed type int dword_100769BC;
// 100769C0: using guessed type int dword_100769C0;
// 100769C4: using guessed type int dword_100769C4;
// 100769C8: using guessed type char byte_100769C8;
// 100769CC: using guessed type int dword_100769CC;
// 100769D0: using guessed type int dword_100769D0;
// 100769D4: using guessed type int dword_100769D4;
// 100769D8: using guessed type int dword_100769D8;

//----- (1003DDD2) --------------------------------------------------------
int __thiscall sub_1003DDD2(int this)
{
  int result; // eax@1
  int v2; // ecx@1

  result = *(_DWORD *)(this + 172) - *(_DWORD *)(this + 184);
  v2 = *(_DWORD *)(this + 132);
  if ( result <= (unsigned int)v2 )
    result = v2;
  return result;
}

//----- (1003DDEB) --------------------------------------------------------
int __userpurge sub_1003DDEB<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, char a5)
{
  int v5; // edi@1
  int v6; // esi@1
  unsigned int v7; // ebx@3
  int v8; // ecx@4
  bool v9; // eax@5
  int v10; // eax@6
  int v11; // ebx@18
  unsigned int v13; // [sp+Ch] [bp-10h]@3
  int v14; // [sp+10h] [bp-Ch]@4
  unsigned int v15; // [sp+14h] [bp-8h]@7
  bool v16; // [sp+18h] [bp-4h]@4
  char v17; // [sp+27h] [bp+Bh]@9

  v6 = a3;
  v5 = a1;
  if ( (_BYTE)a4 )
    *(_DWORD *)(a3 + 16) = sub_1003BE16(a1, a2, a1);
  v7 = 0;
  v13 = *(_DWORD *)(a3 + 160);
  if ( a5 )
  {
    v14 = sub_1003BDE9(a3);
    v8 = sub_1003BDC6(a3);
    v16 = v8;
    if ( (_BYTE)a4 )
    {
      v9 = v14;
    }
    else
    {
      v10 = sub_1003DDD2(a3);
      v8 = (unsigned int)(*(_DWORD *)(a3 + 184) + v10) < *(_DWORD *)(v5 + 28);
      v16 = (unsigned int)(*(_DWORD *)(a3 + 184) + v10) < *(_DWORD *)(v5 + 28);
      v9 = v13 < v14;
    }
    v15 = v9;
  }
  else
  {
    v14 = *(_DWORD *)(a3 + 184) + sub_1003DDD2(a3);
    v15 = v14;
    v8 = sub_1003C119(a3);
    v16 = v8;
  }
  v17 = 0;
  if ( v8 )
  {
    sub_1003F301(v5, v6, a5);
    sub_1003E1E8(v5);
    v7 = sub_1003EC43(v5, v6, v16, 0);
    if ( v7 < v16 )
    {
      if ( (_BYTE)a4 || v15 )
      {
        v17 = 1;
        v7 += sub_1003E90F(v5, v6, v16 - v7, -2);
        if ( v7 < v16 )
        {
          v7 += sub_1003E446(v5, v6, v7 + v13, v14, v13 + v16);
          if ( v7 < v15 )
          {
            v7 += sub_1003E90F(v5, v6, v15 - v7, -1);
            if ( v7 < v15 )
              v7 += sub_1003EC0F(v5, v6, v15 - v7);
          }
        }
      }
    }
    sub_1003EE15(v5);
  }
  v11 = sub_1004C63F(v6, v7, a4, a5);
  if ( v17 )
    sub_1003BCB9((void *)v5, v6);
  return v11;
}

//----- (1003DF41) --------------------------------------------------------
int __thiscall sub_1003DF41(int this, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  unsigned int v7; // edx@2
  unsigned int v8; // ebx@2
  int v9; // esi@3
  unsigned int v10; // ecx@6
  int v11; // edx@7
  char v12; // zf@7
  int v13; // [sp+8h] [bp-Ch]@3
  unsigned int v14; // [sp+Ch] [bp-8h]@2
  int v15; // [sp+10h] [bp-4h]@1
  unsigned int v16; // [sp+1Ch] [bp+8h]@6
  unsigned int v17; // [sp+20h] [bp+Ch]@6
  unsigned int v18; // [sp+24h] [bp+10h]@5

  v5 = a4;
  v15 = this;
  *(_DWORD *)a4 = a2;
  *(double *)(a4 + 8) = 0.0;
  result = a3;
  *(_DWORD *)(a4 + 16) = a3;
  v6 = *(_DWORD *)(a3 + 16);
  if ( v6 )
  {
    v7 = 0;
    v8 = 0;
    v14 = 0;
    if ( *(_DWORD *)(this + 24) )
    {
      result = 0;
      v13 = 0;
      v9 = v6 + 44;
      do
      {
        *(_DWORD *)(v9 - 4) = v7;
        *(_DWORD *)v9 = v7;
        if ( *(_DWORD *)(v9 - 16) > v7 )
        {
          v18 = v7;
          if ( *(_DWORD *)(v9 - 40) > v7 )
          {
            v17 = v7;
            v16 = v7;
            v10 = v7;
            do
            {
              v11 = v16 + *(_DWORD *)(v9 + 4);
              v12 = *(_DWORD *)v11 == 4;
              *(_BYTE *)(v11 + 48) = 0;
              if ( v12 )
              {
                if ( !*(_DWORD *)(v11 + 24) )
                {
                  sub_1003F4D9(
                    v15,
                    v9 - 44,
                    v11,
                    result + *(_DWORD *)(v15 + 72),
                    v17 + *(_DWORD *)(result + *(_DWORD *)(v15 + 72) + 32),
                    v5);
                  result = v13;
                  v10 = v18;
                }
              }
              v16 += 52;
              v17 += 36;
              ++v10;
              v18 = v10;
            }
            while ( v10 < *(_DWORD *)(v9 - 40) );
            v8 = v14;
            this = v15;
            v7 = 0;
          }
        }
        ++v8;
        result += 40;
        v9 += 52;
        v14 = v8;
        v13 = result;
      }
      while ( v8 < *(_DWORD *)(this + 24) );
    }
  }
  return result;
}

//----- (1003E007) --------------------------------------------------------
void *__thiscall sub_1003E007(int this)
{
  void *result; // eax@1
  int v2; // edi@1
  int v3; // esi@1
  int v4; // edi@2
  int v5; // eax@6
  int v6; // eax@6
  int v7; // ecx@6
  int v8; // esi@6
  unsigned int v9; // esi@10
  char v10; // al@12
  int v11; // ecx@13
  int v12; // [sp+8h] [bp-14h]@1
  unsigned int v13; // [sp+Ch] [bp-10h]@6
  int v14; // [sp+10h] [bp-Ch]@6
  int v15; // [sp+14h] [bp-8h]@1
  int v16; // [sp+18h] [bp-4h]@6

  v15 = 0;
  v3 = this;
  v12 = this;
  result = sub_1003DAD1(this);
  v2 = *(_DWORD *)(v3 + 100);
  if ( v2 )
    v4 = *(_DWORD *)(v2 + 24);
  else
    v4 = 0;
  while ( v4 )
  {
    sub_10039210((void *)(v4 + 64), 0, 56);
    sub_1003DF41(v3, v15, v4, v4 + 64);
    if ( *(_BYTE *)(v4 + 204) )
    {
      v6 = *(_DWORD *)(v4 + 120);
      v7 = *(_DWORD *)(v4 + 8);
      v13 = 0;
      v14 = 0;
      v8 = *(_DWORD *)(v4 + 160);
      v16 = v6;
      (*(void (__stdcall **)(unsigned int *, int *, int *))(*(_DWORD *)v7 + 4))(&v13, &v14, &v16);
      v5 = sub_1004BA54(*(_DWORD *)(v4 + 56), v8, v13, v14, v16);
      *(_DWORD *)(v4 + 100) = v5;
      if ( (unsigned int)v5 > *(_DWORD *)(v4 + 160) )
        *(_DWORD *)(v4 + 100) = sub_1004C0EA((void *)v4, v5);
      *(_DWORD *)(v4 + 120) = v16;
    }
    else
    {
      *(_DWORD *)(v4 + 100) = *(_DWORD *)(v4 + 160);
    }
    v9 = *(_DWORD *)(v4 + 160);
    if ( v9 )
    {
      if ( *(_DWORD *)(v4 + 84) )
        goto LABEL_12;
    }
    else
    {
      if ( !*(_DWORD *)(v4 + 196) )
        goto LABEL_12;
    }
    if ( v9 <= *(_DWORD *)(v4 + 100) && v9 < sub_1003C119(v4) )
    {
      v10 = 1;
      goto LABEL_13;
    }
LABEL_12:
    v10 = 0;
LABEL_13:
    v3 = v12;
    v11 = v15;
    *(_BYTE *)(v4 + 97) = v10;
    result = *(void **)(v12 + 84);
    *((_DWORD *)result + v11) = v4 + 64;
    v15 = v11 + 1;
    if ( v4 == *(_DWORD *)(v12 + 100) )
      v4 = 0;
    else
      v4 = *(_DWORD *)(v4 + 24);
  }
  return result;
}

//----- (1003E117) --------------------------------------------------------
void __fastcall sub_1003E117(int a1)
{
  unsigned int v1; // ebx@1
  int v2; // eax@2
  int v3; // edi@2
  int v4; // esi@2
  int v5; // edx@7
  unsigned int v6; // eax@14
  int v7; // [sp+4h] [bp-8h]@5
  unsigned int v8; // [sp+4h] [bp-8h]@10
  int v9; // [sp+8h] [bp-4h]@1

  v1 = 0;
  v9 = a1;
  if ( *(_DWORD *)(a1 + 8) )
  {
    do
    {
      v2 = *(_DWORD *)(a1 + 84);
      v3 = *(_DWORD *)(v2 + 4 * v1);
      v4 = *(_DWORD *)(v3 + 16);
      if ( *(_DWORD *)(v4 + 168) )
        sub_1003D6DB(a1, v4, *(_DWORD *)(v2 + 4 * v1));
      if ( *(_DWORD *)(v3 + 20) )
      {
        v7 = *(_DWORD *)(v4 + 160);
        if ( *(_DWORD *)(v3 + 36) > (unsigned int)(v7 - *(_DWORD *)(v3 + 20)) )
        {
          if ( *(_DWORD *)(v4 + 184) + sub_1003DDD2(v4) <= (unsigned int)(v7 - *(_DWORD *)(v3 + 20)) )
            v5 = v7 - *(_DWORD *)(v3 + 20);
          else
            v5 = *(_DWORD *)(v4 + 184) + sub_1003DDD2(v4);
          *(_DWORD *)(v3 + 36) = v5;
        }
      }
      v8 = *(_DWORD *)(v4 + 160);
      if ( *(_DWORD *)(v3 + 36) < v8 )
      {
        if ( v8 - *(_DWORD *)(v4 + 168) > *(_DWORD *)(v4 + 184) + sub_1003DDD2(v4) )
          sub_1003D7F4((void *)v9, v4, v3);
      }
      if ( !*(_BYTE *)(v4 + 204) )
      {
        v6 = *(_DWORD *)(v4 + 160);
        if ( *(_DWORD *)(v3 + 36) > v6 )
          *(_DWORD *)(v3 + 36) = v6;
      }
      a1 = v9;
      ++v1;
    }
    while ( v1 < *(_DWORD *)(v9 + 8) );
  }
}

//----- (1003E1E8) --------------------------------------------------------
unsigned int __thiscall sub_1003E1E8(int this)
{
  int v1; // edi@1
  unsigned int v2; // esi@1
  unsigned int result; // eax@2
  int v4; // ecx@2

  v1 = this;
  v2 = 0;
  if ( *(_DWORD *)(this + 8) )
  {
    do
    {
      result = *(_DWORD *)(*(_DWORD *)(v1 + 84) + 4 * v2);
      v4 = *(_DWORD *)(result + 16);
      if ( *(_DWORD *)(v4 + 168) )
        result = sub_1003D6DB(v1, v4, *(_DWORD *)(*(_DWORD *)(v1 + 84) + 4 * v2));
      ++v2;
    }
    while ( v2 < *(_DWORD *)(v1 + 8) );
  }
  return result;
}

//----- (1003E217) --------------------------------------------------------
unsigned int __thiscall sub_1003E217(void *this, unsigned int a2)
{
  unsigned int v2; // edx@1
  unsigned int v3; // ecx@1
  void *v4; // esi@1
  int v5; // ebx@3
  int v6; // edi@3
  int v7; // eax@6
  unsigned int v8; // ecx@7
  int v9; // eax@9
  unsigned int v10; // ebx@10
  int v11; // edi@11
  int v12; // eax@14
  int v13; // ebx@16
  int v14; // edi@16
  int v15; // edi@21
  int v16; // ebx@22
  int v17; // ecx@23
  int v18; // esi@23
  char v19; // zf@28
  int v20; // ecx@29
  int v21; // eax@30
  int v22; // ebx@30
  int v23; // ecx@30
  int v24; // eax@30
  int v25; // ebx@30
  int v26; // edx@31
  int v27; // eax@32
  int v28; // ecx@32
  int v29; // edi@32
  unsigned int v30; // edi@32
  char v31; // cf@32
  unsigned int v32; // ebx@33
  int v33; // edi@33
  int v34; // eax@34
  unsigned int v35; // edx@34
  unsigned int v36; // eax@36
  int v37; // eax@39
  unsigned int v39; // [sp+Ch] [bp-30h]@7
  int v40; // [sp+10h] [bp-2Ch]@22
  int v41; // [sp+14h] [bp-28h]@32
  unsigned int v42; // [sp+18h] [bp-24h]@32
  int v43; // [sp+18h] [bp-24h]@34
  int v44; // [sp+20h] [bp-1Ch]@30
  int v45; // [sp+24h] [bp-18h]@23
  int v46; // [sp+24h] [bp-18h]@30
  int v47; // [sp+28h] [bp-14h]@23
  int v48; // [sp+28h] [bp-14h]@32
  void *v49; // [sp+2Ch] [bp-10h]@1
  int v50; // [sp+30h] [bp-Ch]@28
  int v51; // [sp+30h] [bp-Ch]@30
  int v52; // [sp+34h] [bp-8h]@21
  int v53; // [sp+38h] [bp-4h]@23
  int v54; // [sp+38h] [bp-4h]@32

  v2 = a2;
  v4 = this;
  v3 = 0;
  v49 = v4;
  if ( a2 )
  {
    if ( a2 <= 0 )
      goto LABEL_6;
    do
    {
      do
      {
        v6 = *((_DWORD *)v4 + 23);
        v5 = *(_DWORD *)(v6 + 4 * v3);
        if ( *(_DWORD *)(v5 + 4) )
          break;
        --v2;
        *(_DWORD *)(v6 + 4 * v3) = *(_DWORD *)(v6 + 4 * v2);
        *(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v2) = v5;
      }
      while ( v3 < v2 );
      a2 = v2;
LABEL_6:
      *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v3) + 40) = 0;
      *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v3) + 44) = 0;
      v7 = *(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v3++);
      *(_BYTE *)(v7 + 32) = 1;
    }
    while ( v3 < v2 );
  }
  v8 = 0;
  v39 = v2;
  if ( v2 )
  {
    if ( v2 <= 0 )
      goto LABEL_20;
    do
    {
      do
      {
        v9 = *(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v8);
        if ( *(_DWORD *)(v9 + 40) )
          break;
        v10 = 0;
        if ( *((_DWORD *)v4 + 6) )
        {
          v11 = *(_DWORD *)(*(_DWORD *)(v9 + 16) + 16) + 28;
          do
          {
            if ( *(_DWORD *)v11 )
            {
              if ( *(_DWORD *)v11 < *(_DWORD *)(v11 - 24) )
              {
                v12 = *(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v8);
                ++*(_DWORD *)(v12 + 40);
              }
            }
            ++v10;
            v11 += 52;
          }
          while ( v10 < *((_DWORD *)v4 + 6) );
        }
        v14 = *((_DWORD *)v4 + 23);
        v13 = *(_DWORD *)(v14 + 4 * v8);
        if ( !*(_DWORD *)(v13 + 40) )
        {
          --v2;
          *(_DWORD *)(v14 + 4 * v8) = *(_DWORD *)(v14 + 4 * v2);
          *(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v2) = v13;
        }
      }
      while ( v8 < v2 );
      a2 = v2;
LABEL_20:
      ++v8;
    }
    while ( v8 < v2 );
  }
  v15 = 0;
  v52 = 0;
  if ( v2 )
  {
    do
    {
      v40 = v15 + 1;
      v16 = v15 + 1;
      if ( v15 + 1 < v2 )
      {
        v53 = *((_DWORD *)v4 + 23);
        v17 = 4 * v15;
        v18 = v15;
        v45 = 4 * v15;
        v47 = 4 * v15;
        do
        {
          if ( *(_DWORD *)(*(_DWORD *)(v53 + 4 * v16) + 40) >= *(_DWORD *)(*(_DWORD *)(v17 + v53) + 40) )
          {
            v17 = v47;
          }
          else
          {
            v17 = 4 * v16;
            v18 = v16;
            v47 = 4 * v16;
          }
          ++v16;
        }
        while ( v16 < v2 );
        v15 = v52;
        v50 = v18;
        v19 = v52 == v18;
        v4 = v49;
        if ( !v19 )
        {
          v20 = *(_DWORD *)(v45 + v53);
          *(_DWORD *)(v45 + v53) = *(_DWORD *)(v53 + 4 * v50);
          v4 = v49;
          v15 = v52;
          *(_DWORD *)(*((_DWORD *)v49 + 23) + 4 * v50) = v20;
        }
      }
      v23 = *(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v15);
      v24 = *(_DWORD *)(v23 + 16);
      v25 = *(_DWORD *)(v24 + 16);
      v21 = *(_DWORD *)(v24 + 20);
      v46 = v25;
      v22 = 0;
      v51 = v21;
      v44 = 0;
      if ( *(_DWORD *)(v23 + 40) )
      {
        v26 = v21;
        do
        {
          v30 = *((_DWORD *)v4 + 6);
          v28 = v46 + 52 * *(_DWORD *)(v26 + 4 * v22);
          v41 = *(_DWORD *)(v26 + 4 * v22);
          v27 = v22 + 1;
          v42 = v30;
          v31 = v22 + 1 < v30;
          v29 = v52;
          v54 = v22;
          v48 = v22 + 1;
          if ( v31 )
          {
            v32 = v42;
            v33 = v27;
            do
            {
              v34 = v46 + 52 * *(_DWORD *)(v51 + 4 * v33);
              v43 = v34;
              v35 = *(_DWORD *)(v34 + 28);
              if ( !v35
                || v35 >= *(_DWORD *)(v34 + 4)
                || (v36 = *(_DWORD *)(v28 + 28)) != 0 && v36 < *(_DWORD *)(v28 + 4) && v35 <= v36 )
              {
                v37 = v54;
              }
              else
              {
                v28 = v43;
                v37 = v33;
                v54 = v33;
              }
              ++v33;
            }
            while ( v33 < v32 );
            v4 = v49;
            v29 = v52;
            v26 = v51;
            if ( v44 != v37 )
            {
              *(_DWORD *)(v51 + 4 * v44) = *(_DWORD *)(v51 + 4 * v37);
              *(_DWORD *)(v51 + 4 * v54) = v41;
            }
            v27 = v48;
          }
          v22 = v27;
          v44 = v27;
        }
        while ( (unsigned int)v27 < *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v29) + 40) );
        v2 = a2;
      }
      v15 = v40;
      v52 = v40;
    }
    while ( v40 < v2 );
  }
  return v39;
}

//----- (1003E446) --------------------------------------------------------
unsigned int __thiscall sub_1003E446(int this, int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  int v5; // eax@1
  unsigned int v6; // ecx@1
  unsigned int v7; // ebx@2
  int v8; // edi@2
  unsigned int v9; // esi@2
  int v10; // ecx@3
  int v11; // ST40_4@3
  int v12; // eax@3
  int v13; // eax@4
  signed int v15; // ebx@7
  int v16; // eax@9
  int v18; // edi@9
  double v19; // st7@9
  signed __int64 v20; // qax@9
  int v21; // ecx@9
  signed int v22; // edi@10
  int v23; // esi@10
  double v24; // st6@16
  unsigned int v25; // ecx@17
  double v26; // st7@17
  int v27; // eax@18
  char v28; // dl@19
  signed int v29; // ecx@19
  unsigned int v30; // edi@20
  unsigned __int8 v31; // cf@20
  unsigned __int8 v32; // zf@20
  double v33; // st7@21
  double v34; // st6@21
  int v35; // eax@25
  char v36; // dl@27
  double v37; // st7@27
  double v38; // st6@27
  int v39; // eax@31
  int v40; // eax@32
  int v41; // eax@32
  char v42; // cl@33
  double v43; // st7@33
  double v44; // st7@33
  double v45; // st6@33
  unsigned int v46; // ecx@37
  int v47; // eax@39
  int v48; // edx@39
  double v50; // [sp+4h] [bp-3Ch]@17
  double v51; // [sp+Ch] [bp-34h]@16
  double v52; // [sp+14h] [bp-2Ch]@9
  int v53; // [sp+20h] [bp-20h]@26
  unsigned int v54; // [sp+24h] [bp-1Ch]@1
  int v55; // [sp+2Ch] [bp-14h]@3
  unsigned int v56; // [sp+2Ch] [bp-14h]@20
  int v57; // [sp+2Ch] [bp-14h]@26
  int v58; // [sp+2Ch] [bp-14h]@31
  int v59; // [sp+30h] [bp-10h]@9
  int v60; // [sp+34h] [bp-Ch]@2
  unsigned int v61; // [sp+34h] [bp-Ch]@7
  int v62; // [sp+34h] [bp-Ch]@25
  int v63; // [sp+34h] [bp-Ch]@32
  int v64; // [sp+38h] [bp-8h]@1
  unsigned int v65; // [sp+3Ch] [bp-4h]@2
  int v66; // [sp+50h] [bp+10h]@3
  unsigned int v67; // [sp+50h] [bp+10h]@7
  signed int v68; // [sp+50h] [bp+10h]@9
  int v69; // [sp+50h] [bp+10h]@11
  int v70; // [sp+50h] [bp+10h]@20
  char v71; // [sp+53h] [bp+13h]@19
  int v72; // [sp+54h] [bp+14h]@20
  unsigned int v73; // [sp+54h] [bp+14h]@26
  int v74; // [sp+54h] [bp+14h]@32

  v54 = 0;
  v5 = this;
  v6 = *(_DWORD *)(this + 8);
  v64 = v5;
  if ( v6 > 1 )
  {
    v8 = *(_DWORD *)(v5 + 84) + 4;
    v9 = 1;
    v7 = a4;
    v65 = a3;
    v60 = v6 - 1;
    do
    {
      v11 = *(_DWORD *)(*(_DWORD *)v8 + 16);
      v66 = *(_DWORD *)(v11 + 184);
      v12 = sub_1003DDD2(*(_DWORD *)(*(_DWORD *)v8 + 16));
      v10 = v11;
      v55 = *(_DWORD *)(v11 + 160) - *(_DWORD *)(v11 + 168);
      if ( v55 <= (unsigned int)(v66 + v12) )
      {
        v13 = v65;
      }
      else
      {
        ++v9;
        v7 += v66 + sub_1003DDD2(v10);
        v13 = v55 + v65;
        v65 += v55;
      }
      v8 += 4;
    }
    while ( v60-- != 1 );
    v67 = v7;
    v15 = 1;
    v61 = v9;
    if ( v9 > 1 )
    {
      if ( v67 <= v13 )
      {
        _ECX = 0;
        v20 = 4i64 * v9;
        __asm { seto    cl }
        v16 = sub_1002965B(SHIDWORD(v20), v20 | -_ECX, 1, v8, v20 | -_ECX);
        v18 = v16;
        v21 = **(_DWORD **)(v64 + 84);
        v59 = v16;
        *(_DWORD *)v16 = v21;
        *(double *)(v21 + 32) = (double)a5;
        v68 = 1;
        v19 = *(double *)(*(_DWORD *)v16 + 32) + 0.0;
        v52 = v19;
        if ( *(_DWORD *)(v64 + 8) > 1u )
        {
          v23 = v16 + 4;
          v22 = v68;
          do
          {
            v69 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v64 + 84) + 4 * v22) + 16);
            if ( *(_DWORD *)(v69 + 160) - *(_DWORD *)(v69 + 168) <= (unsigned int)(*(_DWORD *)(v69 + 184)
                                                                                 + sub_1003DDD2(v69)) )
            {
              v19 = v52;
            }
            else
            {
              *(_DWORD *)v23 = v69 + 64;
              v23 += 4;
              v19 = *(double *)(v69 + 96) + v52;
              v52 = v19;
            }
            ++v22;
          }
          while ( (unsigned int)v22 < *(_DWORD *)(v64 + 8) );
          v9 = v61;
          v18 = v59;
          v15 = 1;
        }
        v24 = (double)v65;
        v51 = v24;
        while ( 1 )
        {
          v26 = v24 / v19;
          v25 = 0;
          v50 = v26;
          if ( v9 )
          {
            do
            {
              v27 = *(_DWORD *)(v18 + 4 * v25++);
              *(double *)(v27 + 8) = *(double *)(v27 + 32) * v26;
            }
            while ( v25 < v9 );
          }
          sub_1003EF54(v18, v9);
          v28 = 0;
          v71 = 0;
          v29 = v15;
          if ( v9 <= v15 )
            goto LABEL_48;
          do
          {
            v70 = *(_DWORD *)(v18 + 4 * v29);
            v72 = *(_DWORD *)(*(_DWORD *)(v70 + 16) + 160) - *(_DWORD *)(*(_DWORD *)(v70 + 16) + 168);
            v30 = *(_DWORD *)(v70 + 4);
            v56 = v30;
            v31 = v30 < v72;
            v32 = v30 == v72;
            v18 = v59;
            if ( v31 | v32 )
            {
              v19 = v52;
            }
            else
            {
              v33 = (double)(unsigned int)v72 / (double)v56;
              v28 = v15;
              v52 = v52 - (1.0 - v33) * *(double *)(v70 + 32);
              v34 = v33 * *(double *)(v70 + 32);
              v19 = v52;
              *(_QWORD *)(v70 + 32) = *(_QWORD *)&v34;
            }
            ++v29;
          }
          while ( v29 < v9 );
          v24 = v51;
          v71 = v28;
          if ( !v28 )
          {
LABEL_48:
            v35 = 0;
            v62 = 0;
            if ( !v9 )
              goto LABEL_49;
            do
            {
              v53 = *(_DWORD *)(v18 + 4 * v35);
              v57 = *(_DWORD *)(v53 + 16);
              v73 = *(_DWORD *)(v53 + 4);
              if ( v73 <= sub_1003C119(v57) )
              {
                v19 = v52;
                v36 = v71;
              }
              else
              {
                v37 = (double)(unsigned int)sub_1003C119(v57) / (double)v73;
                v36 = v15;
                v71 = v15;
                v52 = v52 - (1.0 - v37) * *(double *)(v53 + 32);
                v38 = v37 * *(double *)(v53 + 32);
                v19 = v52;
                *(_QWORD *)(v53 + 32) = *(_QWORD *)&v38;
              }
              v35 = v62 + 1;
              v62 = v35;
            }
            while ( v35 < v9 );
            v24 = v51;
            if ( !v36 )
            {
LABEL_49:
              v39 = 0;
              v58 = 0;
              if ( !v9 )
                break;
              do
              {
                v40 = *(_DWORD *)(v18 + 4 * v39);
                v63 = v40;
                v41 = *(_DWORD *)(v40 + 16);
                v74 = *(_DWORD *)(v41 + 184);
                if ( (unsigned int)(v74 + sub_1003DDD2(v41)) <= *(_DWORD *)(v63 + 4) )
                {
                  v19 = v52;
                  v42 = v71;
                }
                else
                {
                  v43 = (double)(unsigned int)(v74 + sub_1003DDD2(*(_DWORD *)(v63 + 16)));
                  v42 = v15;
                  v44 = v43 / v50;
                  v71 = v15;
                  v52 = v44 - *(double *)(v63 + 32) + v52;
                  v45 = v44;
                  v19 = v52;
                  *(_QWORD *)(v63 + 32) = *(_QWORD *)&v45;
                }
                v39 = v58 + 1;
                v58 = v39;
              }
              while ( v39 < v9 );
              v24 = v51;
              if ( !v42 )
                break;
            }
          }
        }
        v46 = a3;
        if ( *(_DWORD *)(*(_DWORD *)v18 + 4) > a3 )
        {
          if ( v9 > v15 )
          {
            do
            {
              v47 = *(_DWORD *)(v18 + 4 * v15);
              v48 = *(_DWORD *)(v47 + 16);
              if ( *(_DWORD *)(v48 + 160) - *(_DWORD *)(v47 + 4) != *(_DWORD *)(v48 + 168) )
                sub_1003E964(v64, a2, v48, *(_DWORD *)(v48 + 160) - *(_DWORD *)(v47 + 4) - *(_DWORD *)(v48 + 168));
              ++v15;
            }
            while ( v15 < v9 );
            v46 = a3;
          }
          v54 = sub_1003EC43(v64, a2, *(_DWORD *)(*(_DWORD *)v18 + 4) - v46, 0);
        }
        sub_10030383((LPVOID)v18);
      }
    }
  }
  return v54;
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (1003E819) --------------------------------------------------------
int __thiscall sub_1003E819(void *this)
{
  _ECX = (int)((char *)this + 4);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return _EAX + 1;
}

//----- (1003E825) --------------------------------------------------------
int __stdcall sub_1003E825(int a1, int a2)
{
  int (__stdcall **v3)(char); // [sp+0h] [bp-Ch]@6

  if ( !a1 )
  {
    a1 = (int)"pScheduler";
    goto LABEL_6;
  }
  if ( a2 != 65536 )
  {
    a1 = (int)"version";
LABEL_6:
    sub_1002AEA4((int)&v3, &a1);
    v3 = &off_100602FC;
    sub_100355DB((int)&v3, (int)&unk_1006D8F4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003E878);
  }
  return sub_1003BFBB(a1);
}
// 1003BFBB: using guessed type _DWORD __stdcall sub_1003BFBB(_DWORD);
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);

//----- (1003E878) --------------------------------------------------------
int __usercall sub_1003E878<eax>(int a1<ebp>)
{
  int v1; // edi@1
  int v2; // ecx@1
  int v10; // ST04_4@2

  sub_10035668();
  v1 = v2;
  _EAX = v2 + 4;
  _EBX = -1;
  __asm { lock xadd [eax], ebx }
  if ( _EBX == 1 )
  {
    *(_DWORD *)(a1 - 16) = &dword_10077074;
    sub_10030F90(&dword_10077074);
    v10 = dword_100769B0;
    *(_DWORD *)(a1 - 4) = 0;
    dword_100769B0 = v1 != sub_1003491A(v10) ? dword_100769B0 : 0;
    *(_DWORD *)(a1 - 4) = -1;
    dword_10077074 = 0;
    if ( *(_DWORD *)(v1 + 76) )
    {
      sub_1002B91E((LPCRITICAL_SECTION)(v1 + 44));
      *(_DWORD *)(v1 + 40) = 2;
      sub_1002BB53((LPCRITICAL_SECTION)(v1 + 44));
      SetEvent(*(HANDLE *)(v1 + 80));
      WaitForSingleObject(*(HANDLE *)(v1 + 76), 0xFFFFFFFFu);
    }
    sub_1003B8DE(a1);
    sub_1002A4AA((LPVOID)v1);
  }
  return sub_10035636(4);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 100769B0: using guessed type int dword_100769B0;
// 10077074: using guessed type int dword_10077074;

//----- (1003E90F) --------------------------------------------------------
unsigned int __thiscall sub_1003E90F(int this, int a2, unsigned int a3, int a4)
{
  unsigned int v4; // ebx@1
  signed int v5; // edi@1
  int v6; // esi@1
  char v7; // zf@5

  v6 = this;
  v5 = 1;
  v4 = 0;
  if ( *(_DWORD *)(this + 8) > 1u )
  {
    do
    {
      if ( sub_1003E964(v6, a2, *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 84) + 4 * v5) + 16), a4) )
        LOBYTE(v4) = 1;
      ++v5;
    }
    while ( (unsigned int)v5 < *(_DWORD *)(v6 + 8) );
    v7 = (_BYTE)v4 == 0;
    v4 = 0;
    if ( !v7 )
      v4 = sub_1003EC43(v6, a2, a3, 0);
  }
  return v4;
}

//----- (1003E964) --------------------------------------------------------
char __thiscall sub_1003E964(int this, int a2, int a3, int a4)
{
  int v4; // edx@1
  int v5; // esi@1
  int v6; // eax@2
  int v7; // ebx@6
  int v8; // eax@7
  int v9; // edi@7
  int v10; // ecx@8
  unsigned int v11; // eax@9
  int v12; // edi@11
  int v14; // [sp+Ch] [bp-Ch]@7
  int v15; // [sp+10h] [bp-8h]@7
  int v16; // [sp+14h] [bp-4h]@1
  int v17; // [sp+20h] [bp+8h]@7
  unsigned int v18; // [sp+24h] [bp+Ch]@9
  int v19; // [sp+28h] [bp+10h]@10

  v4 = a4;
  v5 = a3;
  v16 = this;
  if ( a4 == -2 )
  {
    v6 = *(_DWORD *)(a3 + 168);
    v4 = *(_DWORD *)(a3 + 168);
  }
  else
  {
    if ( a4 == -1 )
    {
      v4 = *(_DWORD *)(a3 + 168)
         + *(_DWORD *)(a3 + 160)
         - *(_DWORD *)(a3 + 108)
         - *(_DWORD *)(a3 + 168)
         - (*(_DWORD *)(a3 + 184)
          + sub_1003DDD2(a3));
      this = v16;
    }
    v6 = 0;
  }
  v7 = v4 - v6;
  if ( !v4
    || (v9 = *(_DWORD *)(a3 + 16),
        v15 = *(_DWORD *)(a2 + 20),
        v8 = 0,
        v14 = *(_DWORD *)(a3 + 16),
        v17 = 0,
        !*(_DWORD *)(this + 24)) )
    return 0;
  while ( 1 )
  {
    v10 = v9 + 52 * *(_DWORD *)(v15 + 4 * v8);
    if ( *(_DWORD *)(v10 + 28) != *(_DWORD *)(v10 + 36) )
    {
      v11 = 0;
      v18 = 0;
      if ( *(_DWORD *)(v10 + 4) )
        break;
    }
LABEL_21:
    v8 = v17 + 1;
    v17 = v8;
    if ( (unsigned int)v8 >= *(_DWORD *)(v16 + 24) )
      return 0;
  }
  v19 = 0;
  while ( 1 )
  {
    v12 = v19 + *(_DWORD *)(v10 + 48);
    if ( *(_DWORD *)v12 != 4 || *(_DWORD *)(v12 + 40) )
      goto LABEL_19;
    if ( *(_BYTE *)(v12 + 49) || v7 )
    {
      *(_DWORD *)v12 = 5;
      ++*(_DWORD *)(v5 + 108);
      --**(_DWORD **)(v12 + 20);
      if ( !*(_BYTE *)(v12 + 49) )
        --v7;
      --v4;
      if ( !v4 )
        return 1;
    }
    v11 = v18;
LABEL_19:
    v19 += 52;
    ++v11;
    v18 = v11;
    if ( v11 >= *(_DWORD *)(v10 + 4) )
    {
      v9 = v14;
      goto LABEL_21;
    }
  }
}

//----- (1003EA5A) --------------------------------------------------------
int __thiscall sub_1003EA5A(int this, int a2)
{
  int result; // eax@1

  --*(_DWORD *)this;
  *(_DWORD *)(*(_DWORD *)(a2 + 24) + 28) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(*(_DWORD *)(a2 + 28) + 24) = *(_DWORD *)(a2 + 24);
  result = *(_DWORD *)(this + 4);
  if ( a2 == result )
  {
    if ( result == *(_DWORD *)(result + 24) )
      result = 0;
    else
      result = *(_DWORD *)(result + 28);
    *(_DWORD *)(this + 4) = result;
  }
  return result;
}

//----- (1003EA90) --------------------------------------------------------
int __userpurge sub_1003EA90<eax>(int a1<ebp>, int a2)
{
  int v2; // ebx@1
  struct _RTL_CRITICAL_SECTION *v3; // esi@1
  int v4; // ecx@1
  int v5; // ecx@1
  int v6; // edi@1

  sub_10035668();
  v2 = v4;
  *(_DWORD *)(a1 - 16) = 0;
  v3 = (struct _RTL_CRITICAL_SECTION *)(v4 + 44);
  *(_DWORD *)(a1 - 20) = v4 + 44;
  sub_1002B91E((LPCRITICAL_SECTION)(v4 + 44));
  v5 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  v6 = *(_DWORD *)(v5 + 20);
  sub_1004B45A(v5);
  if ( *(_DWORD *)(v6 + 160) < (unsigned int)sub_1003C119(v6) )
  {
    if ( *(_DWORD *)(v2 + 8) == 1 )
    {
      if ( !sub_1003C4D1(v2) )
        *(_BYTE *)(a1 - 16) = 1;
    }
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002BB53(v3);
  if ( *(_BYTE *)(a1 - 16) )
    SetEvent(*(HANDLE *)(v2 + 80));
  return sub_10035636(8);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1003EB04) --------------------------------------------------------
int __userpurge sub_1003EB04<eax>(int a1<ebp>, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  struct _RTL_CRITICAL_SECTION *v5; // esi@1
  int v6; // ecx@1
  char v7; // zf@1
  int v8; // eax@2
  int v9; // eax@6
  char v10; // bl@12
  int v12; // ebx@13
  signed __int64 v13; // qax@13
  signed __int64 v15; // qax@13

  sub_10035668();
  v4 = v6;
  v5 = (struct _RTL_CRITICAL_SECTION *)(v6 + 44);
  *(_DWORD *)(a1 - 16) = 0;
  *(_BYTE *)(a1 - 20) = 0;
  *(_DWORD *)(a1 - 24) = v6 + 44;
  sub_1002B91E((LPCRITICAL_SECTION)(v6 + 44));
  v7 = *(_BYTE *)(a1 + 12) == 0;
  *(_DWORD *)(a1 - 4) = 0;
  v3 = *(_DWORD *)(a1 + 8);
  if ( !v7 )
  {
    v8 = sub_1004C9FB(*(_DWORD *)(a1 + 8), a1);
    *(_DWORD *)(a1 - 16) = v8;
    if ( !v8 )
      *(_BYTE *)(a1 - 20) = 1;
  }
  if ( *(_DWORD *)(v3 + 132) == *(_DWORD *)(v3 + 128) )
    ++*(_DWORD *)(v4 + 16);
  ++*(_DWORD *)(v4 + 8);
  sub_1003B9F3(v4 + 96, v3);
  v9 = sub_1003DDEB(v4, v3, v3, 1, *(_DWORD *)(a1 - 20));
  if ( !*(_DWORD *)(a1 - 16) )
    *(_DWORD *)(a1 - 16) = v9;
  if ( *(_DWORD *)(v3 + 132) == *(_DWORD *)(v3 + 128) )
    sub_1003F132((void *)v4, v3);
  if ( *(_DWORD *)(v4 + 8) == 2 )
  {
    v10 = 0;
    *(_DWORD *)(v4 + 40) = 1;
    if ( !*(_DWORD *)(v4 + 76) )
    {
      *(_DWORD *)(v4 + 76) = 1;
      _ECX = 0;
      v12 = 4;
      v13 = 4i64 * *(_DWORD *)(v4 + 12);
      __asm { seto    cl }
      *(_DWORD *)(v4 + 88) = sub_1002965B(SHIDWORD(v13), v13 | -_ECX, 4, v4, v13 | -_ECX);
      _ECX = 0;
      v15 = 4i64 * *(_DWORD *)(v4 + 12);
      __asm { seto    cl }
      *(_DWORD *)(v4 + 92) = sub_1002965B(SHIDWORD(v15), v15 | -_ECX, v12, v4, v15 | -_ECX);
      v10 = 1;
    }
    *(_DWORD *)(a1 - 4) = -1;
    sub_1002BB53(v5);
    SetEvent(*(HANDLE *)(v4 + 80));
    if ( v10 )
      sub_1003BF43((LPVOID)v4);
  }
  else
  {
    *(_DWORD *)(a1 - 4) = -1;
    sub_1002BB53(v5);
  }
  return sub_10035636(12);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1003EC0F) --------------------------------------------------------
unsigned int __thiscall sub_1003EC0F(int this, int a2, unsigned int a3)
{
  int v3; // edi@1
  unsigned int v4; // esi@1
  unsigned int v5; // eax@2
  int v7; // [sp+8h] [bp-4h]@1

  v3 = 0;
  v4 = 0;
  v7 = this;
  if ( a3 )
  {
    do
    {
      ++v3;
      v5 = sub_1003EC43(this, a2, a3 - v4, v3);
      this = v7;
      v4 += v5;
    }
    while ( v4 < a3 );
  }
  return v4;
}

//----- (1003EC43) --------------------------------------------------------
unsigned int __thiscall sub_1003EC43(int this, int a2, unsigned int a3, int a4)
{
  int v4; // ebx@1
  char v5; // dl@3
  int v6; // ecx@3
  unsigned int v7; // esi@3
  int v8; // ecx@4
  unsigned int v9; // eax@5
  int v10; // edi@6
  int v11; // edx@7
  unsigned int result; // eax@14
  int v13; // edi@15
  int v14; // eax@16
  int v15; // edx@17
  int v16; // ebx@17
  int v17; // esi@17
  int v18; // esi@20
  int v19; // eax@21
  char v20; // zf@23
  int v21; // ST10_4@23
  int v22; // ecx@23
  char v23; // cf@23
  int v24; // ebx@33
  unsigned int v25; // edi@33
  int v26; // eax@34
  int v27; // ecx@45
  unsigned int v28; // [sp+10h] [bp-1Ch]@3
  int v29; // [sp+10h] [bp-1Ch]@15
  int v30; // [sp+14h] [bp-18h]@1
  int v31; // [sp+18h] [bp-14h]@1
  unsigned int v32; // [sp+1Ch] [bp-10h]@5
  int v33; // [sp+1Ch] [bp-10h]@17
  int v34; // [sp+20h] [bp-Ch]@3
  int v35; // [sp+24h] [bp-8h]@3
  char v36; // [sp+2Bh] [bp-1h]@3
  unsigned int v37; // [sp+3Ch] [bp+10h]@14

  v30 = -1;
  v4 = this;
  v31 = this;
  if ( *(_BYTE *)(a2 + 104) )
    v30 = sub_1003D49E(this, a2, 0);
  v6 = *(_DWORD *)(a2 + 20);
  v7 = 0;
  v5 = 0;
  v34 = *(_DWORD *)(a2 + 16);
  v35 = *(_DWORD *)(a2 + 20);
  v36 = 0;
  v28 = 0;
  if ( *(_DWORD *)(v4 + 24) )
  {
    v8 = *(_DWORD *)(a2 + 16) + 8;
    do
    {
      v9 = 0;
      v32 = 0;
      if ( *(_DWORD *)(v8 - 4) )
      {
        v10 = 0;
        do
        {
          v11 = v10 + *(_DWORD *)(v8 + 40);
          if ( *(_DWORD *)v11 == 1 )
          {
            v9 = v32;
            if ( a4 == **(_DWORD **)(v11 + 20) )
            {
              *(_DWORD *)v11 = 2;
              ++*(_DWORD *)v8;
              v36 = 1;
            }
          }
          ++v9;
          v10 += 52;
          v32 = v9;
        }
        while ( v9 < *(_DWORD *)(v8 - 4) );
        v7 = v28;
        v4 = v31;
      }
      ++v7;
      v8 += 52;
      v28 = v7;
    }
    while ( v7 < *(_DWORD *)(v4 + 24) );
    v6 = v35;
    v5 = v36;
  }
  result = 0;
  v37 = 0;
  if ( v5 )
  {
    v13 = 0;
    v29 = 0;
    if ( *(_DWORD *)(v4 + 24) > 0u )
    {
      v14 = v31;
      do
      {
        v15 = v34 + 52 * *(_DWORD *)(v6 + 4 * v13);
        v17 = v13;
        v33 = v13;
        v16 = a3 - v37;
        if ( a3 != v37 )
        {
          if ( *(_DWORD *)(v15 + 8) > (unsigned int)v16 )
            *(_DWORD *)(v15 + 8) = v16;
          v18 = v13 + 1;
          if ( (unsigned int)(v13 + 1) < *(_DWORD *)(v14 + 24) )
          {
            do
            {
              v19 = v34 + 52 * *(_DWORD *)(v6 + 4 * v18);
              if ( *(_DWORD *)(v19 + 8) > (unsigned int)v16 )
                *(_DWORD *)(v19 + 8) = v16;
              v21 = *(_DWORD *)(v19 + 24) + *(_DWORD *)(v19 + 28) + *(_DWORD *)(v19 + 8);
              v22 = *(_DWORD *)(v15 + 8) + *(_DWORD *)(v15 + 24) + *(_DWORD *)(v15 + 28);
              v23 = v22 < (unsigned int)v21;
              v20 = v22 == v21;
              v6 = v35;
              if ( v23 || v20 && *(_BYTE *)(a2 + 104) && *(_DWORD *)(v35 + 4 * v18) == v30 )
              {
                v15 = v34 + 52 * *(_DWORD *)(v35 + 4 * v18);
                v33 = v18;
              }
              ++v18;
            }
            while ( (unsigned int)v18 < *(_DWORD *)(v31 + 24) );
            v13 = v29;
          }
          v17 = v33;
        }
        if ( *(_DWORD *)(v15 + 8) )
        {
          if ( *(_DWORD *)(v15 + 4) )
          {
            v25 = 0;
            v24 = 0;
            do
            {
              v26 = v24 + *(_DWORD *)(v15 + 48);
              if ( *(_DWORD *)v26 == 2 )
              {
                v6 = v35;
                if ( v37 >= a3 )
                {
                  *(_DWORD *)v26 = 1;
                }
                else
                {
                  *(_DWORD *)v26 = 3;
                  ++**(_DWORD **)(v26 + 20);
                  ++*(_DWORD *)(v15 + 24);
                  if ( *(_BYTE *)(a2 + 104) )
                  {
                    if ( *(_DWORD *)(v35 + 4 * v17) == v30 )
                      *(_BYTE *)(a2 + 104) = 0;
                  }
                  ++v37;
                }
              }
              ++v25;
              v24 += 52;
            }
            while ( v25 < *(_DWORD *)(v15 + 4) );
            v13 = v29;
          }
          *(_DWORD *)(v15 + 8) = 0;
        }
        if ( v13 != v17 )
        {
          v27 = *(_DWORD *)(v6 + 4 * v13);
          *(_DWORD *)(v35 + 4 * v13) = *(_DWORD *)(v35 + 4 * v17);
          *(_DWORD *)(v35 + 4 * v17) = v27;
        }
        v14 = v31;
        v6 = v35;
        ++v13;
        v29 = v13;
      }
      while ( (unsigned int)v13 < *(_DWORD *)(v31 + 24) );
      result = v37;
    }
  }
  return result;
}

//----- (1003EE15) --------------------------------------------------------
int __thiscall sub_1003EE15(int this)
{
  __int64 v1; // qax@1
  int v2; // esi@1
  int v3; // edi@2
  int v4; // ecx@3
  int v5; // ebx@4
  unsigned int v6; // esi@4
  int v7; // eax@5
  int v9; // [sp+4h] [bp-8h]@1

  v2 = this;
  v1 = 0i64;
  v9 = this;
  if ( *(_DWORD *)(this + 24) )
  {
    v3 = 0;
    do
    {
      v4 = v3 + *(_DWORD *)(v2 + 72);
      *(_DWORD *)(v4 + 8) = v1;
      *(_DWORD *)(v4 + 28) = v1;
      if ( *(_DWORD *)(v4 + 4) > (_DWORD)v1 )
      {
        v5 = v1;
        v6 = v1;
        do
        {
          v7 = v5 + *(_DWORD *)(v4 + 32);
          v5 += 36;
          *(_DWORD *)v7 = 0;
          *(_DWORD *)(v7 + 28) = 0;
          ++v6;
        }
        while ( v6 < *(_DWORD *)(v4 + 4) );
        v2 = v9;
        LODWORD(v1) = 0;
      }
      v1 += 4294967296i64;
      v3 += 40;
    }
    while ( HIDWORD(v1) < *(_DWORD *)(v2 + 24) );
  }
  return v1;
}

//----- (1003EE6C) --------------------------------------------------------
DWORD __usercall sub_1003EE6C<eax>(int a1<esi>)
{
  DWORD result; // eax@5
  char v2; // [sp+0h] [bp-124h]@20
  struct _OSVERSIONINFOW VersionInformation; // [sp+Ch] [bp-118h]@1
  unsigned int v4; // [sp+120h] [bp-4h]@1
  int v5; // [sp+124h] [bp+0h]@1

  v4 = (unsigned int)&v5 ^ __security_cookie;
  VersionInformation.dwOSVersionInfoSize = 276;
  if ( !GetVersionExW(&VersionInformation) )
  {
LABEL_20:
    sub_100300C4((int)&v2);
    sub_100355DB((int)&v2, (int)&unk_1006CB98);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003EF54);
  }
  if ( VersionInformation.dwMajorVersion != 5 )
  {
    if ( VersionInformation.dwMajorVersion != 6 )
      goto LABEL_24;
    result = VersionInformation.dwMinorVersion;
    if ( !VersionInformation.dwMinorVersion )
    {
      dword_100769D4 = 3;
      return result;
    }
    if ( VersionInformation.dwMinorVersion != 1 )
LABEL_24:
      dword_100769D4 = 6;
    else
      dword_100769D4 = 4;
LABEL_17:
    result = sub_1003B4D5();
    if ( dword_100769D4 >= 6 )
      result = sub_1004CD16(a1);
    return result;
  }
  if ( !VersionInformation.dwMinorVersion )
  {
    dword_100769D4 = 0;
    goto LABEL_20;
  }
  if ( VersionInformation.dwMinorVersion == 1 )
  {
    result = 1;
    dword_100769D4 = 1;
  }
  else
  {
    result = VersionInformation.dwMinorVersion - 2;
    if ( VersionInformation.dwMinorVersion == 2 )
    {
      dword_100769D4 = 2;
      return result;
    }
    result = dword_100769D4;
  }
  if ( (signed int)result >= 4 )
    goto LABEL_17;
  return result;
}
// 1003EE6C: could not find valid save-restore pair for esi
// 10074200: using guessed type int __security_cookie;
// 100769D4: using guessed type int dword_100769D4;

//----- (1003EF54) --------------------------------------------------------
void __cdecl sub_1003EF54(int a1, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // edi@1
  int v4; // esi@1
  double v5; // st6@1
  int v6; // ecx@2
  int v7; // esi@4
  double v8; // st5@4
  int v9; // eax@5
  int v10; // edx@5
  int v11; // esi@6
  int v12; // eax@8
  int v13; // ecx@12
  int v14; // ecx@16
  unsigned int v15; // esi@16
  double v16; // st4@17
  double v17; // qt0@18
  double v18; // st4@18
  double v19; // qt1@18
  double v20; // qt2@19
  double v21; // st4@19
  double v22; // st6@19
  double v23; // st4@20
  double v24; // st5@20
  double v25; // qtt@20
  double v26; // qt0@21
  double v27; // st4@24
  double v28; // st5@24
  double v29; // qt1@24
  int v30; // eax@25
  int v31; // eax@28
  int v32; // esi@28
  int v33; // edx@29
  int v34; // eax@31
  double v35; // qt0@32
  int v36; // eax@33
  double v37; // qt1@33
  double v38; // st4@33
  double v39; // qt2@33
  int v40; // ecx@40
  int v41; // [sp+Ch] [bp-10h]@1
  int v42; // [sp+14h] [bp-8h]@4
  int v43; // [sp+14h] [bp-8h]@28
  int v44; // [sp+18h] [bp-4h]@1
  int v45; // [sp+18h] [bp-4h]@5
  int v46; // [sp+28h] [bp+Ch]@5
  int v47; // [sp+28h] [bp+Ch]@28

  v5 = 0.0;
  v2 = 0;
  v3 = a2;
  v4 = 0;
  v41 = 0;
  v44 = 0;
  if ( a2 )
  {
    do
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 4 * v4) + 4) = sub_1004D276(0.0);
      v6 = *(_DWORD *)(a1 + 4 * v44);
      v4 = v44 + 1;
      v44 = v4;
      *(double *)(v6 + 8) = *(double *)(v6 + 8) - (double)*(unsigned int *)(v6 + 4);
    }
    while ( v4 < a2 );
    v2 = 0;
  }
  v8 = 0.0000001;
  v7 = v2;
  v42 = v2;
  if ( a2 )
  {
    do
    {
      v9 = v7 + 1;
      v46 = v7;
      v45 = v7 + 1;
      v10 = v7 + 1;
      if ( v7 + 1 < v3 )
      {
        v11 = 4 * v7;
        do
        {
          if ( *(double *)(*(_DWORD *)(v11 + a1) + 8) + 0.0000001 >= *(double *)(*(_DWORD *)(a1 + 4 * v10) + 8) )
          {
            v12 = v46;
          }
          else
          {
            v12 = v10;
            v46 = v10;
            v11 = 4 * v10;
          }
          ++v10;
        }
        while ( v10 < v3 );
        if ( v42 != v12 )
        {
          v13 = *(_DWORD *)(a1 + 4 * v42);
          *(_DWORD *)(a1 + 4 * v42) = *(_DWORD *)(a1 + 4 * v12);
          *(_DWORD *)(a1 + 4 * v46) = v13;
        }
        v9 = v45;
      }
      v7 = v9;
      v42 = v9;
    }
    while ( v9 < v3 );
    v2 = 0;
  }
  v15 = v2;
  v14 = v3 - 1;
  if ( v3 )
  {
    v16 = 1.0;
    while ( 1 )
    {
      v20 = v16;
      v21 = v5;
      v22 = v20;
      while ( v21 > v8 )
      {
        v25 = v21;
        v23 = v8;
        v24 = v25;
        if ( v23 < *(double *)(*(_DWORD *)(a1 + 4 * v14) + 8) )
        {
          while ( 1 )
          {
            v36 = *(_DWORD *)(a1 + 4 * v14);
            v37 = v23;
            v38 = v24;
            v8 = v37;
            --v14;
            v39 = v38 - *(double *)(v36 + 8);
            *(double *)(v36 + 8) = 0.0;
            v21 = v39;
            if ( v39 <= v37 )
              break;
            v35 = v21;
            v23 = v8;
            v24 = v35;
          }
        }
        else
        {
          --v14;
          v26 = v23;
          v21 = v24;
          v8 = v26;
        }
      }
      if ( v15 > v14 )
        break;
      v29 = v21;
      v27 = v8;
      v28 = v29;
      if ( v27 < *(double *)(*(_DWORD *)(a1 + 4 * v15) + 8) )
      {
        v30 = *(_DWORD *)(a1 + 4 * v15);
        v28 = v28 + v22 - *(double *)(v30 + 8);
        *(double *)(v30 + 8) = 0.0;
        ++*(_DWORD *)(*(_DWORD *)(a1 + 4 * v15) + 4);
      }
      ++v15;
      if ( v15 >= v3 )
        break;
      v17 = v27;
      v18 = v28;
      v8 = v17;
      v19 = v18;
      v16 = v22;
      v5 = v19;
    }
  }
  if ( v3 )
  {
    do
    {
      v31 = v2 + 1;
      v47 = v2;
      v43 = v2 + 1;
      v32 = v2 + 1;
      if ( v2 + 1 < v3 )
      {
        v33 = 4 * v2;
        do
        {
          if ( **(_DWORD **)(a1 + 4 * v32) >= **(_DWORD **)(v33 + a1) )
          {
            v34 = v47;
          }
          else
          {
            v34 = v32;
            v47 = v32;
            v33 = 4 * v32;
          }
          ++v32;
        }
        while ( v32 < v3 );
        if ( v41 != v34 )
        {
          v40 = *(_DWORD *)(a1 + 4 * v41);
          *(_DWORD *)(a1 + 4 * v41) = *(_DWORD *)(a1 + 4 * v34);
          *(_DWORD *)(a1 + 4 * v47) = v40;
        }
        v31 = v43;
      }
      v2 = v31;
      v41 = v31;
    }
    while ( v31 < v3 );
  }
}

//----- (1003F113) --------------------------------------------------------
char __thiscall sub_1003F113(void *this)
{
  int v2; // edx@2

  _ESI = (int)((char *)this + 4);
  while ( 1 )
  {
    v2 = *(_DWORD *)_ESI;
    if ( !*(_DWORD *)_ESI )
      break;
    _ECX = v2 + 1;
    __asm { lock cmpxchg [esi], ecx }
    if ( v2 == v2 )
      return 1;
  }
  return 0;
}

//----- (1003F132) --------------------------------------------------------
int __thiscall sub_1003F132(void *this, int a2)
{
  int result; // eax@1
  unsigned int v3; // ecx@1
  int v4; // ebx@1
  void *v5; // edi@1
  signed int v6; // edx@2
  int v7; // esi@2
  int v8; // edx@4
  int v9; // ecx@4
  int v10; // edx@5
  int v11; // ebx@5
  int v12; // eax@5
  int v13; // edx@6
  int v14; // ecx@9
  int v15; // eax@9
  int v16; // ecx@17
  unsigned int v17; // edx@19
  int v18; // ecx@20
  int v19; // eax@21
  int v20; // esi@21
  int v21; // esi@22
  int v22; // eax@27
  char v23; // zf@32
  signed int v24; // [sp-4h] [bp-30h]@30
  unsigned int v25; // [sp+Ch] [bp-20h]@21
  int v26; // [sp+10h] [bp-1Ch]@2
  unsigned int v27; // [sp+10h] [bp-1Ch]@19
  unsigned int v28; // [sp+14h] [bp-18h]@1
  int v29; // [sp+14h] [bp-18h]@20
  int v30; // [sp+18h] [bp-14h]@4
  int v31; // [sp+18h] [bp-14h]@17
  signed int v32; // [sp+1Ch] [bp-10h]@1
  signed int v33; // [sp+20h] [bp-Ch]@2
  int v34; // [sp+20h] [bp-Ch]@20
  int v35; // [sp+24h] [bp-8h]@4
  int v36; // [sp+24h] [bp-8h]@18
  int v37; // [sp+28h] [bp-4h]@3
  unsigned int v38; // [sp+28h] [bp-4h]@25

  v5 = this;
  v4 = 0;
  v3 = 0;
  result = 48;
  v28 = 0;
  v32 = 48;
  if ( *((_DWORD *)v5 + 6) )
  {
    v7 = 0;
    v26 = 0;
    v6 = 48;
    v33 = 48;
    do
    {
      result = v7 + *((_DWORD *)v5 + 18);
      v37 = v4;
      if ( *(_DWORD *)(result + 4) > (unsigned int)v4 )
      {
        v8 = v4;
        v35 = v4;
        v30 = v4;
        v9 = v4;
        do
        {
          v11 = v8 + *(_DWORD *)(result + 32);
          v12 = *(_DWORD *)(v11 + 20);
          *(_DWORD *)(v11 + 20) = 0;
          *(_DWORD *)(v11 + 24) = v12;
          v10 = *((_DWORD *)v5 + 25);
          if ( v10 )
            v13 = *(_DWORD *)(v10 + 24);
          else
            v13 = 0;
          if ( v13 )
          {
            do
            {
              v14 = v35 + *(_DWORD *)(v33 + *(_DWORD *)(v13 + 16));
              *(_DWORD *)(v14 + 32) = *(_DWORD *)(v14 + 28);
              v15 = *(_DWORD *)(v14 + 24);
              *(_DWORD *)(v14 + 28) = v15;
              *(_DWORD *)(v11 + 20) += v15;
              if ( v13 == *((_DWORD *)v5 + 25) )
                v13 = 0;
              else
                v13 = *(_DWORD *)(v13 + 24);
            }
            while ( v13 );
            v7 = v26;
            v9 = v37;
          }
          v35 += 52;
          ++v9;
          result = v7 + *((_DWORD *)v5 + 18);
          v8 = v30 + 36;
          v37 = v9;
          v30 += 36;
        }
        while ( (unsigned int)v9 < *(_DWORD *)(result + 4) );
        v3 = v28;
        v6 = v33;
        v4 = 0;
      }
      ++v3;
      v7 += 40;
      v6 += 52;
      v28 = v3;
      v26 = v7;
      v33 = v6;
    }
    while ( v3 < *((_DWORD *)v5 + 6) );
  }
  v16 = v4;
  v31 = v4;
  if ( *((_DWORD *)v5 + 6) <= (unsigned int)v4 )
    return result;
  v36 = v4;
  do
  {
    v17 = 0;
    result = v4 + *((_DWORD *)v5 + 18);
    v27 = 0;
    if ( !*(_DWORD *)(result + 4) )
      goto LABEL_46;
    v34 = 0;
    v18 = 0;
    v29 = 0;
    do
    {
      v19 = *(_DWORD *)(result + 32);
      v25 = *(_DWORD *)(v19 + v18 + 24);
      v20 = *((_DWORD *)v5 + 25);
      if ( v20 )
        v21 = *(_DWORD *)(v20 + 24);
      else
        v21 = 0;
      if ( v21 )
      {
        v38 = *(_DWORD *)(v19 + v18 + 20);
        while ( 1 )
        {
          if ( *(_DWORD *)(v21 + 132) != *(_DWORD *)(v21 + 128)
            || (v22 = v34 + *(_DWORD *)(v32 + *(_DWORD *)(v21 + 16)), !*(_DWORD *)(v22 + 36)) )
            goto LABEL_39;
          if ( v21 == a2 )
          {
            if ( v38 <= *(_DWORD *)(v22 + 28) )
              goto LABEL_37;
            v24 = 1;
          }
          else
          {
            if ( v25 != *(_DWORD *)(v22 + 32) )
            {
              v23 = v38 == *(_DWORD *)(v22 + 28);
LABEL_35:
              if ( !v23 || v25 <= *(_DWORD *)(v22 + 32) )
                goto LABEL_39;
LABEL_37:
              v24 = 0;
              goto LABEL_38;
            }
            v23 = v38 == *(_DWORD *)(v22 + 28);
            if ( v38 <= *(_DWORD *)(v22 + 28) )
              goto LABEL_35;
            v24 = 1;
          }
LABEL_38:
          sub_1004CBC2(v22, v24);
LABEL_39:
          if ( v21 == *((_DWORD *)v5 + 25) )
            v21 = 0;
          else
            v21 = *(_DWORD *)(v21 + 24);
          if ( !v21 )
          {
            v4 = v36;
            v17 = v27;
            v18 = v29;
            break;
          }
        }
      }
      v34 += 52;
      ++v17;
      result = v4 + *((_DWORD *)v5 + 18);
      v18 += 36;
      v27 = v17;
      v29 = v18;
    }
    while ( v17 < *(_DWORD *)(result + 4) );
    v16 = v31;
LABEL_46:
    v32 += 52;
    ++v16;
    v4 += 40;
    v31 = v16;
    v36 = v4;
  }
  while ( (unsigned int)v16 < *((_DWORD *)v5 + 6) );
  return result;
}
// 1004CBC2: using guessed type _DWORD __stdcall sub_1004CBC2(_DWORD, _DWORD);

//----- (1003F301) --------------------------------------------------------
int __thiscall sub_1003F301(int this, int a2, char a3)
{
  int result; // eax@1
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // edi@2
  int v7; // [sp+1Ch] [bp+Ch]@1

  v4 = this;
  sub_1003DAD1(this);
  sub_10039210((void *)(a2 + 64), 0, 48);
  sub_1003DF41(v4, 0, a2, a2 + 64);
  *(double *)(a2 + 96) = (double)(unsigned int)sub_1003C119(a2);
  *(_BYTE *)(a2 + 104) = a3;
  result = *(_DWORD *)(v4 + 84);
  v7 = 1;
  *(_DWORD *)result = a2 + 64;
  v5 = *(_DWORD *)(v4 + 100);
  if ( v5 )
    v6 = *(_DWORD *)(v5 + 24);
  else
    v6 = 0;
  if ( v6 )
  {
    result = a2;
    do
    {
      if ( v6 != result )
      {
        sub_10039210((void *)(v6 + 64), 0, 48);
        sub_1003DF41(v4, v7, v6, v6 + 64);
        *(double *)(v6 + 96) = (double)(unsigned int)sub_1003C119(v6);
        *(_DWORD *)(*(_DWORD *)(v4 + 84) + 4 * v7) = v6 + 64;
        result = a2;
        ++v7;
      }
      if ( v6 == *(_DWORD *)(v4 + 100) )
        v6 = 0;
      else
        v6 = *(_DWORD *)(v6 + 24);
    }
    while ( v6 );
  }
  return result;
}

//----- (1003F3CF) --------------------------------------------------------
int __thiscall sub_1003F3CF(int this, int a2)
{
  unsigned int v2; // eax@1
  int v3; // ecx@1
  char v4; // bl@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // edx@2
  unsigned int v8; // eax@4
  int v9; // esi@5
  int v10; // ecx@6
  unsigned int v12; // [sp+Ch] [bp-8h]@4
  unsigned int v13; // [sp+10h] [bp-4h]@1

  v5 = this;
  v4 = 0;
  v6 = this + 44;
  sub_1002B91E((LPCRITICAL_SECTION)(this + 44));
  sub_1003EA5A(v5 + 96, a2);
  v3 = a2;
  v2 = 0;
  v13 = 0;
  if ( *(_DWORD *)(v5 + 24) > 0u )
  {
    v7 = *(_DWORD *)(a2 + 16) + 4;
    do
    {
      if ( *(_DWORD *)(v7 + 24) > 0u )
      {
        v8 = 0;
        v12 = 0;
        if ( *(_DWORD *)v7 > 0u )
        {
          v9 = 0;
          do
          {
            v10 = *(_DWORD *)(v7 + 44);
            if ( *(_DWORD *)(v9 + v10) == 4 )
            {
              --**(_DWORD **)(v9 + v10 + 20);
              v8 = v12;
            }
            ++v8;
            v9 += 52;
            v12 = v8;
          }
          while ( v8 < *(_DWORD *)v7 );
        }
        v2 = v13;
      }
      ++v2;
      v7 += 52;
      v13 = v2;
    }
    while ( v2 < *(_DWORD *)(v5 + 24) );
    v3 = a2;
    v6 = v5 + 44;
  }
  if ( *(_DWORD *)(v3 + 132) == *(_DWORD *)(v3 + 128) )
    --*(_DWORD *)(v5 + 16);
  --*(_DWORD *)(v5 + 8);
  if ( *(_DWORD *)(v5 + 8) == 1 )
  {
    *(_DWORD *)(v5 + 40) = 0;
    v4 = 1;
  }
  sub_1002BB53((LPCRITICAL_SECTION)v6);
  if ( v4 )
    SetEvent(*(HANDLE *)(v5 + 80));
  return (*(int (**)(void))(*(_DWORD *)a2 + 32))();
}

//----- (1003F488) --------------------------------------------------------
int __userpurge sub_1003F488<eax>(int a1<ebp>, int a2)
{
  int v2; // ebx@1
  struct _RTL_CRITICAL_SECTION *v3; // esi@1
  int v4; // ecx@1
  int v5; // ecx@1

  sub_10035668();
  v2 = v4;
  v3 = (struct _RTL_CRITICAL_SECTION *)(v4 + 44);
  *(_DWORD *)(a1 - 16) = v4 + 44;
  sub_1002B91E((LPCRITICAL_SECTION)(v4 + 44));
  v5 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  if ( !sub_1004C9FB(v5, a1) )
    sub_1003DDEB(v2, v2, *(_DWORD *)(a1 + 8), 0, 1);
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002BB53(v3);
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1003F4D9) --------------------------------------------------------
int __thiscall sub_1003F4D9(int this, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@2

  if ( *(_BYTE *)(a3 + 48) )
  {
    result = a6;
    *(_BYTE *)(a3 + 48) = 0;
    --*(_DWORD *)(result + 20);
    --*(_DWORD *)(a2 + 40);
    if ( *(_BYTE *)(a3 + 49) )
    {
      --*(_DWORD *)(a6 + 24);
      --*(_DWORD *)(a2 + 44);
    }
    if ( *(_DWORD *)a5 == 6 )
    {
      result = a4;
      *(_DWORD *)a5 = 0;
      --*(_DWORD *)(result + 28);
      --*(_DWORD *)(this + 32);
    }
    --*(_DWORD *)(a5 + 28);
  }
  else
  {
    *(_BYTE *)(a3 + 48) = 1;
    ++*(_DWORD *)(a6 + 20);
    ++*(_DWORD *)(a2 + 40);
    if ( *(_BYTE *)(a3 + 49) )
    {
      ++*(_DWORD *)(a6 + 24);
      ++*(_DWORD *)(a2 + 44);
    }
    result = a5;
    ++*(_DWORD *)(result + 28);
  }
  return result;
}

//----- (1003F546) --------------------------------------------------------
int __usercall sub_1003F546<eax>(int a1<ebp>, int a2<esi>)
{
  int v2; // eax@2

  sub_10035668();
  if ( !dword_100769D4 )
  {
    *(_DWORD *)(a1 - 16) = &dword_10077074;
    sub_10030F90(&dword_10077074);
    v2 = dword_100769D4;
    *(_DWORD *)(a1 - 4) = 0;
    if ( !v2 )
      sub_1003EE6C(a2);
    dword_10077074 = 0;
  }
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 100769D4: using guessed type int dword_100769D4;
// 10077074: using guessed type int dword_10077074;

//----- (1003F590) --------------------------------------------------------
int __usercall sub_1003F590<eax>(unsigned int a1<eax>, int a2<ecx>, char a3)
{
  return sub_1004D2F0(-(((unsigned int)(&a3 - a1) & 0xF) >= -a1) | (((unsigned int)(&a3 - a1) & 0xF) + a1), a2);
}

//----- (1003F5BC) --------------------------------------------------------
void *__usercall sub_1003F5BC<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // edx@1
  void *result; // eax@2
  int v6; // [sp-4h] [bp-4h]@1

  if ( sub_1004D387(a1, a2, a3, a4, 3) == 1
    || (result = (void *)sub_1004D387(v4, v6, a3, a4, 3), !result) && dword_100769E8 == 1 )
  {
    sub_1003F619(a3, 252);
    result = sub_1003F619(a3, 255);
  }
  return result;
}
// 100769E8: using guessed type int dword_100769E8;

//----- (1003F5F5) --------------------------------------------------------
wchar_t *__cdecl sub_1003F5F5(int a1)
{
  unsigned int v1; // eax@1

  v1 = 0;
  while ( a1 != dword_100654D8[2 * v1] )
  {
    ++v1;
    if ( v1 >= 0x17 )
      return 0;
  }
  return (wchar_t *)off_100654DC[2 * v1];
}
// 100654D8: using guessed type int dword_100654D8[];

//----- (1003F619) --------------------------------------------------------
void *__usercall sub_1003F619<eax>(int a1<ebx>, int a2)
{
  void *result; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // edx@2
  int v6; // edx@3
  int v7; // edx@7
  int v8; // ecx@7
  int v9; // edx@9
  int v10; // ecx@9
  int v11; // eax@9
  int v12; // ST10_4@9
  int v13; // eax@10
  int v14; // edx@11
  int v15; // ecx@11
  void *v16; // esi@14
  unsigned int v17; // ecx@16
  int v18; // eax@19
  int v19; // [sp-8h] [bp-20Ch]@2
  int v20; // [sp-8h] [bp-20Ch]@3
  int v21; // [sp-4h] [bp-208h]@1
  DWORD NumberOfBytesWritten; // [sp+8h] [bp-1FCh]@19
  char Buffer[499]; // [sp+Ch] [bp-1F8h]@17
  char v24; // [sp+1FFh] [bp-5h]@19
  unsigned int v25; // [sp+200h] [bp-4h]@1
  int v26; // [sp+204h] [bp+0h]@1

  v25 = (unsigned int)&v26 ^ __security_cookie;
  result = sub_1003F5F5(a2);
  v4 = (int)result;
  if ( result )
  {
    if ( sub_1004D387(v3, v21, a1, (int)result, 3) != 1
      && ((result = (void *)sub_1004D387(v5, v19, a1, v4, 3)) != 0 || dword_100769E8 != 1) )
    {
      if ( a2 != 252 )
      {
        if ( sub_100490D0(v6, v20, a1, v4, (int)&unk_100769F0, 788, (int)L"Runtime Error!\n\nProgram: ")
          || (word_10076C2A = 0, !GetModuleFileNameW(0, &Filename, 0x104u))
          && sub_100490D0(v7, v8, 0, v4, (int)&Filename, 763, (int)L"<program name unknown>")
          || (v11 = sub_100398B9((int)&Filename), v10 = v12, (unsigned int)(v11 + 1) > 0x3C)
          && (v13 = sub_100398B9((int)&Filename),
              sub_10044A99(
                0,
                v4,
                (int)((char *)&unk_100769AC + 2 * v13),
                763 - ((signed int)((_UNKNOWN *)((char *)&unk_100769AC + 2 * v13) - (_UNKNOWN *)&Filename) >> 1),
                (int)L"...",
                3))
          || sub_1004D31B(v9, v10, 0, (int)&unk_100769F0, 788, (int)L"\n\n")
          || sub_1004D31B(v14, v15, 0, (int)&unk_100769F0, 788, v4) )
        {
          sub_1003A17E(0, v4);
          __asm { int     3               ; Trap to Debugger }
          JUMPOUT(*(int *)sub_1003F7D4);
        }
        result = (void *)sub_1004D3C7((const WCHAR *)&unk_100769F0, (int)L"Microsoft Visual C++ Runtime Library", 73744);
      }
    }
    else
    {
      result = GetStdHandle(0xFFFFFFF4u);
      v16 = result;
      if ( result )
      {
        if ( result != (void *)-1 )
        {
          v17 = 0;
          do
          {
            Buffer[v17] = *(_BYTE *)(v4 + 2 * v17);
            if ( !*(_WORD *)(v4 + 2 * v17) )
              break;
            ++v17;
          }
          while ( v17 < 0x1F4 );
          v24 = 0;
          v18 = sub_10035550((int)Buffer);
          result = (void *)WriteFile(v16, Buffer, v18, &NumberOfBytesWritten, 0);
        }
      }
    }
  }
  return result;
}
// 100655EC: using guessed type wchar_t aRuntimeErrorPr[26];
// 10065620: using guessed type wchar_t aProgramNameUnk[23];
// 10065650: using guessed type wchar_t a___[4];
// 10065658: using guessed type wchar_t asc_10065658[3];
// 10065660: using guessed type wchar_t aMicrosoftVisua[37];
// 10074200: using guessed type int __security_cookie;
// 100769E8: using guessed type int dword_100769E8;
// 10076C2A: using guessed type __int16 word_10076C2A;
// 1003F619: using guessed type char Buffer[499];

//----- (1003F7D4) --------------------------------------------------------
signed int __cdecl sub_1003F7D4(int a1, int a2, int a3, LCTYPE a4, LPVOID *a5)
{
  int v5; // eax@2
  int v6; // ecx@2
  void *v7; // ebx@2
  int v8; // eax@4
  int v9; // ecx@4
  CHAR *v10; // eax@5
  int v11; // edx@7
  int v13; // eax@17
  int v14; // ecx@17
  int v15; // ebx@17
  WCHAR *v16; // eax@18
  signed int v17; // [sp+10h] [bp-90h]@2
  int cbMultiByte; // [sp+18h] [bp-88h]@2
  char Mem; // [sp+1Ch] [bp-84h]@2
  unsigned int v20; // [sp+9Ch] [bp-4h]@1
  int v21; // [sp+A0h] [bp+0h]@1

  v20 = (unsigned int)&v21 ^ __security_cookie;
  if ( a2 == 1 )
  {
    v7 = &Mem;
    v17 = 0;
    v5 = sub_1004D681((int)&Mem, (int)a5, a1, a3, a4, &Mem, 128);
    cbMultiByte = v5;
    if ( !v5 )
    {
      if ( GetLastError() != 122
        || (v8 = sub_1004D681((int)&Mem, (int)a5, a1, a3, a4, 0, 0), cbMultiByte = v8, !v8)
        || (v10 = (CHAR *)sub_10037506(v9, (int)&Mem, v8, 1u), v7 = v10, !v10) )
        return -1;
      v17 = 1;
      v5 = sub_1004D681((int)v10, (int)a5, a1, a3, a4, v10, cbMultiByte);
      cbMultiByte = v5;
      if ( !v5 )
        goto LABEL_9;
    }
    v11 = (int)sub_10037506(v6, (int)v7, v5, 1u);
    *a5 = (LPVOID)v11;
    if ( !v11 )
    {
      if ( !v17 )
        return -1;
LABEL_9:
      sub_100309A2((int)v7, v7);
      return -1;
    }
    if ( sub_100305B1((int)v7, (int)a5, v11, cbMultiByte, (int)v7, cbMultiByte - 1) )
    {
      sub_1003A17E((int)v7, (int)a5);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1003F9AB);
    }
    if ( v17 )
      sub_100309A2((int)v7, v7);
  }
  else
  {
    if ( a2 == 2 )
    {
      *a5 = 0;
      v13 = sub_10039CAE(a3, a4, 0, 0);
      v15 = v13;
      if ( !v13 || (v16 = (WCHAR *)sub_10037506(v14, v13, v13, 2u), *a5 = v16, !v16) || !sub_10039CAE(a3, a4, v16, v15) )
      {
        sub_100309A2(v15, *a5);
        *a5 = 0;
        return -1;
      }
    }
    else
    {
      if ( a2 || (cbMultiByte = 0, !sub_10039CAE(a3, a4 | 0x20000000, (WCHAR *)&cbMultiByte, 2)) )
        return -1;
      *(_BYTE *)a5 = cbMultiByte;
    }
  }
  return 0;
}
// 10074200: using guessed type int __security_cookie;

//----- (1003F9AB) --------------------------------------------------------
void *__cdecl sub_1003F9AB(void *a1)
{
  void *result; // eax@1

  result = a1;
  dword_10077018 = a1;
  return result;
}

//----- (1003F9B8) --------------------------------------------------------
void __usercall sub_1003F9B8(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // eax@1
  LPVOID v6; // edx@2
  void *v7; // ecx@2

  sub_10036A43(a1, a2, a3, a4, 14);
  v5 = *(_DWORD *)(a5 + 4);
  if ( v5 )
  {
    v7 = dword_10077020;
    v6 = &unk_1007701C;
    while ( dword_10077020 )
    {
      if ( *(_DWORD *)dword_10077020 == v5 )
      {
        *((_DWORD *)v6 + 1) = *((_DWORD *)dword_10077020 + 1);
        sub_100309A2(a3, v7);
        break;
      }
      v6 = dword_10077020;
    }
    sub_100309A2(a3, *(LPVOID *)(a5 + 4));
    *(_DWORD *)(a5 + 4) = 0;
  }
  sub_10036BA7(14);
}

//----- (1003FA29) --------------------------------------------------------
int __cdecl sub_1003FA29(int a1)
{
  int ebp0; // ebp@0

  *(_DWORD *)(a1 + 116) = 1;
  sub_1002E53F(a1, -999);
  return sub_1002E5DE(ebp0, 0);
}

//----- (1003FA50) --------------------------------------------------------
int __cdecl sub_1003FA50(int a1)
{
  return (**(int (__stdcall ***)(_DWORD))a1)(1);
}

//----- (1003FA5E) --------------------------------------------------------
void __thiscall sub_1003FA5E(int this, int a2)
{
  int v2; // edx@5
  int v3; // eax@8
  int v4; // edx@8
  void *v5; // ecx@8
  int v6; // eax@11
  int v7; // ebx@14
  int v8; // edi@14
  void *v9; // edx@14
  _DWORD *v10; // [sp+0h] [bp+0h]@4
  void *v11; // [sp+8h] [bp+8h]@14

  if ( *(int (**)())(this + 12) == sub_1003FB1E )
  {
    v10 = &v10;
    if ( a2 )
      v2 = a2 - 4;
    else
      v2 = 0;
    if ( !*(_DWORD *)(v2 + 52) )
    {
      v3 = *(_DWORD *)(this + 8);
      v4 = v2 + 4;
      v5 = *(void **)(v3 + 12);
      *(_DWORD *)(v4 + 48) = v3;
      *(_DWORD *)(v4 + 52) = v3;
      sub_1002E4E8(v5, v4, 0);
    }
  }
  else
  {
    v10 = &v10;
    if ( a2 )
      v6 = a2 - 4;
    else
      v6 = 0;
    if ( !*(_DWORD *)(v6 + 52) )
    {
      v8 = *(_DWORD *)(this + 8);
      v7 = v6 + 4;
      v9 = *(void **)(v8 + 12);
      *(_DWORD *)(v6 + 52) = v8;
      *(_DWORD *)(v6 + 56) = v8;
      v11 = v9;
      if ( *(_BYTE *)(this + 17) )
      {
        *(_BYTE *)(v6 + 81) = 0;
        sub_1002E518(v8 + 28, v6 + 96);
      }
      else
      {
        sub_1002B98B((void *)(v8 + 32));
        ++*(_DWORD *)(v8 + 48);
        sub_1002BB75((void *)(v8 + 32));
        sub_1002E4E8(v11, v7, 1);
      }
    }
  }
}
// 1003FB1E: using guessed type int sub_1003FB1E();

//----- (1003FB11) --------------------------------------------------------
char __thiscall sub_1003FB11(int this, char a2)
{
  char result; // al@1

  result = a2;
  *(_BYTE *)(this + 17) = a2;
  return result;
}

//----- (1003FB1E) --------------------------------------------------------
#error "1003FC5A: call analysis failed (funcsize=85)"

//----- (1003FD8A) --------------------------------------------------------
void (__usercall *__usercall sub_1003FD8A<eax>(int a1<ebp>, int a2<edi>))(int<ebp>)
{
  int v2; // eax@1

  v2 = *(_DWORD *)(a1 - 172);
  if ( *(_DWORD *)(v2 + 116) > 0 )
  {
    if ( !*(_DWORD *)(v2 + 120) )
      sub_1002D5ED(*(_DWORD *)(a1 - 168), 0, a2);
  }
  return sub_1003FDAD;
}

//----- (1003FDAD) --------------------------------------------------------
void __usercall sub_1003FDAD(int a1<ebp>)
{
  int v1; // edi@1

  v1 = *(_DWORD *)(a1 - 168);
  *(_DWORD *)(a1 - 4) = 1;
  sub_1002DBC0(0, a1, v1, a1 - 164, 0);
  *(_BYTE *)(a1 - 4) = 0;
  sub_1002CFB7(a1);
  *(_DWORD *)(a1 - 4) = -1;
  JUMPOUT(*(unsigned int *)loc_1003FE34);
}
// 1003FE34: using guessed type int loc_1003FE34();

//----- (1003FDE3) --------------------------------------------------------
void (__usercall *__usercall sub_1003FDE3<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>))(int<ebp>)
{
  sub_1002DA39(*(_DWORD *)(a2 - 168), a1, a2);
  sub_1002D5ED(*(_DWORD *)(a2 - 168), a1, a3);
  return sub_1003FDAD;
}

//----- (1003FDFF) --------------------------------------------------------
int (__usercall *__usercall sub_1003FDFF<eax>(int a1<ebp>, int a2<edi>))<eax>(int<ebp>)
{
  int v2; // eax@1

  v2 = *(_DWORD *)(a1 - 172);
  if ( *(_DWORD *)(v2 + 116) > 0 )
  {
    if ( !*(_DWORD *)(v2 + 120) )
      sub_1002D5ED(*(_DWORD *)(a1 - 168), 0, a2);
  }
  return sub_1003FE22;
}

//----- (1003FE22) --------------------------------------------------------
int __usercall sub_1003FE22<eax>(int a1<ebp>)
{
  int v1; // edi@1
  int v2; // esi@1
  int v3; // eax@2
  void *v4; // ecx@5
  void *v5; // esi@7
  int v7; // esi@9
  int v8; // eax@9

  *(_DWORD *)(a1 - 4) = -1;
  v1 = *(_DWORD *)(a1 - 168);
  v2 = *(_DWORD *)(a1 - 172);
  *(_DWORD *)(a1 - 172) = v2 + 4;
  sub_1002EFB7(v2 + 4, 0);
  if ( *(_BYTE *)(*(_DWORD *)(a1 - 176) + 17) )
  {
    sub_1002EF6C(*(_DWORD *)(a1 - 184), v2 + 96);
  }
  else
  {
    v3 = *(_DWORD *)(a1 - 184);
    *(_DWORD *)(a1 - 168) = v3 + 4;
    sub_1002B98B((void *)(v3 + 4));
    if ( *(_BYTE *)(v2 + 81) )
      sub_1002EF93(*(void **)(a1 - 196), *(_DWORD *)(a1 - 172));
    else
      sub_1002B26C(*(void **)(a1 - 184), v2 + 96);
    v4 = *(void **)(a1 - 168);
    --*(_DWORD *)(v1 + 48);
    sub_1002BB75(v4);
  }
  v5 = *(void **)(a1 - 192);
  if ( v5 )
  {
    sub_1002B29A(a1, *(_DWORD *)(a1 - 192));
    sub_1000AA50(v5);
  }
  v7 = *(_DWORD *)(a1 - 172);
  *(_DWORD *)(v7 + 104) = -1;
  *(_DWORD *)(v7 + 108) = -1;
  *(_DWORD *)(v7 + 112) = 0;
  *(_DWORD *)(v7 + 116) = 0;
  sub_1002E73F((void *)v7);
  v8 = *(_DWORD *)(a1 - 176);
  *(_DWORD *)(v7 + 48) = 0;
  *(_DWORD *)(v7 + 52) = 0;
  *(_DWORD *)(v8 + 8) = 0;
  sub_1002D9AB((void *)v1, v8);
  return sub_10035659();
}
// 10035659: using guessed type int sub_10035659(void);

//----- (1003FF25) --------------------------------------------------------
int __thiscall sub_1003FF25(int this, int a2)
{
  int result; // eax@1
  int v3; // edx@1
  int v4; // ecx@1

  _ESI = this + 24;
  v3 = *(_DWORD *)(this + 24);
  v4 = v3;
  for ( result = v3; ; v4 = result )
  {
    _ECX = a2 | v4 & 0xFFFFFFFC;
    __asm { lock cmpxchg [esi], ecx }
    if ( result == v3 )
      break;
    v3 = result;
  }
  return result;
}

//----- (1003FF4B) --------------------------------------------------------
signed int __thiscall sub_1003FF4B(int this, int a2)
{
  signed int result; // eax@1
  int v3; // ecx@1

  result = *(_DWORD *)(this + 8);
  v3 = 0;
  if ( result & 1 )
  {
    v3 = result & 0xFFFFFFFE;
    if ( result & 0xFFFFFFFE )
      result = *(_DWORD *)((result & 0xFFFFFFFE) + 0x10);
    else
      result = 2;
  }
  if ( a2 )
    *(_DWORD *)a2 = v3;
  return result;
}

//----- (1003FF73) --------------------------------------------------------
char __thiscall sub_1003FF73(int this)
{
  int v1; // edx@1
  char result; // al@4

  _ESI = this + 24;
  v1 = *(_DWORD *)(this + 24);
  if ( v1 & 3 )
  {
LABEL_4:
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      _ECX = v1 | 1;
      __asm { lock cmpxchg [esi], ecx }
      if ( v1 == v1 )
        break;
      if ( v1 & 3 )
        goto LABEL_4;
    }
    result = 1;
  }
  return result;
}

//----- (1003FF9B) --------------------------------------------------------
int __thiscall sub_1003FF9B(int this)
{
  int v1; // edx@1
  int result; // eax@2

  _ESI = this + 24;
  v1 = *(_DWORD *)(this + 24);
  if ( !(v1 & 0xFFFFFFFC) )
  {
    do
    {
      _ECX = v1 & 3 | 0xC;
      result = v1;
      __asm { lock cmpxchg [esi], ecx }
    }
    while ( v1 != v1 && !(v1 & 0xFFFFFFFC) );
  }
  return result;
}

//----- (1003FFC6) --------------------------------------------------------
int __usercall sub_1003FFC6<eax>(int a1<ebx>, int a2<ebp>)
{
  int v2; // edx@1
  int v4; // ecx@1
  int v6; // eax@6
  int v7; // esi@6
  int i; // eax@8
  int v9; // edx@8
  int v10; // ecx@8

  sub_10035668();
  _EDI = v4 + 24;
  v2 = *(_DWORD *)(v4 + 24);
  while ( !(v2 & 0xFFFFFFFC) || (v2 & 0xFFFFFFFC) == 12 )
  {
    _ECX = v2 & 3 | 8;
    __asm { lock cmpxchg [edi], ecx }
    if ( v2 == v2 )
    {
      v6 = sub_1002ADB1(v2, _ECX, a1, _EDI, 8);
      *(_DWORD *)(a2 - 16) = v6;
      v7 = 0;
      *(_DWORD *)(a2 - 4) = 0;
      if ( v6 )
        v7 = sub_1000A4E0(v6);
      v9 = *(_DWORD *)_EDI;
      v10 = *(_DWORD *)_EDI;
      for ( i = *(_DWORD *)_EDI; ; LOBYTE(v10) = i )
      {
        _ECX = v7 | v10 & 3;
        __asm { lock cmpxchg [edi], ecx }
        if ( i == v9 )
          break;
        v9 = i;
      }
      return sub_10035636(4);
    }
  }
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (10040035) --------------------------------------------------------
int __usercall sub_10040035<eax>(int a1<ebx>, int a2<ebp>)
{
  int v2; // ecx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // ecx@3
  const void *v6; // ST04_4@4
  int v8; // [sp-Ch] [bp-Ch]@4
  int v9; // [sp-8h] [bp-8h]@4
  signed int v10; // [sp-4h] [bp-4h]@1

  v10 = 12;
  sub_10035668();
  v3 = v2;
  v4 = *(_DWORD *)(v2 + 24) & 0xFFFFFFFC;
  if ( *(_DWORD *)(v2 + 24) & 0xFFFFFFFC )
  {
    if ( v4 != 12 )
    {
      sub_1002FD39(a2 - 24, *(_DWORD *)(v2 + 24) & 0xFFFFFFFC);
      *(_DWORD *)(a2 - 4) = 0;
      sub_1002FDDA(v4);
      sub_1002A4AA((LPVOID)v4);
      *(_DWORD *)(v3 + 24) = 0;
      if ( !sub_100363BF(a1, v3) )
      {
        v9 = v5;
        v8 = v5;
        sub_1002FD39((int)&v8, a2 - 24);
        sub_10009E30(v6, v3, v8);
      }
      *(_DWORD *)(a2 - 4) = -1;
      sub_1002FDDA(a2 - 24);
    }
  }
  return sub_10035636(v10);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (100400A5) --------------------------------------------------------
char __thiscall sub_100400A5(int this)
{
  int v1; // edi@1
  signed int v2; // esi@1
  int v3; // esi@1
  char v4; // al@3

  v3 = this;
  v1 = sub_1002F423(this);
  v2 = sub_1003FF4B(v3, 0);
  while ( 1 )
  {
    if ( !v1 )
      return 0;
    if ( v2 )
      break;
    v4 = (*(_DWORD *)(v1 + 4) >> 28) & 1;
    if ( v4 && *(_BYTE *)(v1 + 24) & 3 || !v4 && sub_1002D961(v1) )
      return 1;
    v2 = sub_1003FF4B(v1, 0);
    v1 = sub_1002F423(v1);
  }
  if ( v2 == 2 )
    return 0;
  return *(_DWORD *)(v2 + 8) != 0;
}

//----- (10040112) --------------------------------------------------------
int __fastcall sub_10040112(int a1, int a2, int a3)
{
  int v3; // eax@1
  signed int v4; // edi@1
  int v5; // esi@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // ecx@2
  void *v10; // ST00_4@6

  v5 = a1;
  v4 = 63;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 20) = a3;
  *(_DWORD *)(a1 + 8) = 63;
  *(_DWORD *)(a1 + 12) = sub_1002965B(a2, a1, 0, 63, 256);
  v3 = sub_1002965B(v6, v7, 0, 63, 512);
  if ( v3 )
  {
    v8 = v3;
    do
    {
      --v4;
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      v8 += 8;
    }
    while ( v4 >= 0 );
  }
  else
  {
    v3 = 0;
  }
  v10 = *(void **)(v5 + 12);
  *(_DWORD *)(v5 + 16) = v3;
  sub_10039210(v10, 0, 256);
  return v5;
}

//----- (10040179) --------------------------------------------------------
int __fastcall sub_10040179(int a1, int a2, int a3)
{
  int v3; // eax@1
  signed int v4; // edi@1
  int v5; // esi@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // ecx@2

  v5 = a1;
  *(_DWORD *)(a1 + 16) = a3;
  v4 = 63;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 8) = 63;
  *(_DWORD *)(a1 + 28) = sub_1002965B(a2, a1, 0, 63, 256);
  v3 = sub_1002965B(v6, v7, 0, 63, 512);
  if ( v3 )
  {
    v8 = v3;
    do
    {
      --v4;
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      v8 += 8;
    }
    while ( v4 >= 0 );
  }
  else
  {
    v3 = 0;
  }
  *(_DWORD *)(v5 + 32) = v3;
  return v5;
}

//----- (100401D8) --------------------------------------------------------
int __usercall sub_100401D8<eax>(int a1<ebp>)
{
  int v2; // ecx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // edx@1
  int v6; // edx@1

  sub_10035668();
  v3 = v2;
  *(_DWORD *)(a1 - 16) = v2;
  v4 = v2 + 112;
  sub_10040112(v2, v5, v2 + 112);
  *(_DWORD *)(v3 + 56) = 0;
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)(v3 + 72) = 0;
  sub_10040179(v3 + 76, v6, v4);
  *(_DWORD *)v4 = 0;
  *(_BYTE *)(a1 - 4) = 1;
  *(_DWORD *)(v3 + 44) = 0;
  *(_DWORD *)(v3 + 52) = v3;
  *(_DWORD *)(v3 + 64) = sub_10032A76();
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (10040224) --------------------------------------------------------
bool __thiscall sub_10040224(int this)
{
  return *(_DWORD *)(this + 4) <= *(_DWORD *)this && *(_DWORD *)(this + 80) <= *(_DWORD *)(this + 76);
}

//----- (1004023A) --------------------------------------------------------
int __thiscall sub_1004023A(int this, int a2)
{
  *(_DWORD *)(this + 60) = a2;
  return sub_1003337E(this + 28, sub_100402BC, this, *(_DWORD *)(*(_DWORD *)(a2 + 256) + 4));
}

//----- (1004025E) --------------------------------------------------------
int __thiscall sub_1004025E(void *this)
{
  void *v2; // edi@1

  v2 = this;
  sub_10034BBC((char *)this + 112);
  *((_DWORD *)v2 + 16) = sub_10032A76();
  *(_DWORD *)v2 = 0;
  *((_DWORD *)v2 + 1) = 0;
  *((_DWORD *)v2 + 19) = 0;
  *((_DWORD *)v2 + 20) = 0;
  *((_WORD *)v2 + 48) = 0;
  *((_DWORD *)v2 + 22) = 0;
  *((_DWORD *)v2 + 14) = 0;
  *((_DWORD *)v2 + 18) = 0;
  return sub_10034BCC((char *)v2 + 112);
}

//----- (10040298) --------------------------------------------------------
int __thiscall sub_10040298(int this, int a2)
{
  *(_DWORD *)(this + 60) = a2;
  return sub_1003337E(this + 28, sub_100402CD, this, *(_DWORD *)(*(_DWORD *)(a2 + 256) + 4));
}

//----- (100402BC) --------------------------------------------------------
int __cdecl sub_100402BC(int a1)
{
  return sub_100413BA(*(void **)(a1 + 60), a1);
}

//----- (100402CD) --------------------------------------------------------
int __cdecl sub_100402CD(int a1)
{
  return sub_10041551(*(_DWORD *)(a1 + 60), a1);
}

//----- (100402DE) --------------------------------------------------------
int __userpurge sub_100402DE<eax>(int a1<ebp>, int a2)
{
  int v3; // ecx@1
  int v4; // edi@1
  void *v5; // esi@1
  int v6; // ST00_4@1

  sub_10035668();
  v4 = v3;
  v5 = (void *)(v3 + 112);
  *(_DWORD *)(a1 - 16) = v3 + 112;
  sub_10034BBC((void *)(v3 + 112));
  v6 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  sub_1004053B(v4, v6);
  *(_DWORD *)(a1 - 4) = -1;
  sub_10034BCC(v5);
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (100403BD) --------------------------------------------------------
int __cdecl sub_100403BD(int (__cdecl *a1)(_DWORD, _DWORD), int a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int v3; // ecx@1
  int v4; // edx@2
  int v5; // eax@3
  char v6; // al@5
  int v8; // eax@1
  int v9; // ebx@1
  int v10; // edi@1
  int v11; // esi@1
  void *v12; // [sp+0h] [bp-1Ch]@1
  int v13; // [sp+8h] [bp-14h]@3
  int v14; // [sp+Ch] [bp-10h]@2

  sub_10035668();
  v9 = v3;
  v12 = *(void **)(v3 + 16);
  sub_10034BBC(v12);
  v8 = v9 + 4;
  v10 = *(_DWORD *)(v9 + 4);
  v11 = *(_DWORD *)(v9 + 4) - 1;
  if ( v11 >= *(_DWORD *)v9 )
  {
    v14 = *(_DWORD *)(v9 + 4);
    v4 = *(_DWORD *)(v9 + 4);
    do
    {
      v5 = *(_DWORD *)(*(_DWORD *)(v9 + 28) + 4 * (*(_DWORD *)(v9 + 8) & v11));
      v13 = v5;
      if ( v5 )
      {
        if ( (unsigned __int8)a1(v5, a2) )
        {
          v6 = a3(v13, a2);
          v4 = v14;
          if ( v6 )
          {
            if ( v14 == v10 )
              --v10;
            else
              *(_DWORD *)(*(_DWORD *)(v9 + 28) + 4 * (*(_DWORD *)(v9 + 8) & v11)) = 0;
          }
        }
        else
        {
          v4 = v14;
        }
      }
      --v11;
      --v4;
      v14 = v4;
    }
    while ( v11 >= *(_DWORD *)v9 );
    v8 = v9 + 4;
  }
  *(_DWORD *)v8 = v10;
  sub_10034BCC(v12);
  return sub_10035636(16);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (100403C9) --------------------------------------------------------
int __thiscall sub_100403C9(int this, char a2, int a3)
{
  int v3; // esi@1
  int result; // eax@2

  v3 = this;
  if ( sub_10034BE0((void *)(this + 112)) )
  {
    sub_1004053B(v3, a2);
    result = sub_10034BCC((void *)(v3 + 112));
  }
  else
  {
    *(_BYTE *)a3 = 0;
    result = 0;
  }
  return result;
}

//----- (1004042F) --------------------------------------------------------
int __thiscall sub_1004042F(void *this, char a2)
{
  void *i; // esi@1
  int v3; // ecx@2
  int v4; // edi@2
  int v5; // ebx@5
  int v6; // eax@5

  for ( i = this; ; *(_DWORD *)i = v4 + 1 )
  {
    if ( *(_DWORD *)i >= *((_DWORD *)i + 1)
      || (v4 = *(_DWORD *)i, v3 = *(_DWORD *)i & *((_DWORD *)i + 2), *(_BYTE *)(*((_DWORD *)i + 3) + 4 * v3) & 1)
      && !a2
      && sub_10045D62((void *)(*((_DWORD *)i + 4) + 8 * v3)) )
      return 0;
    v6 = *((_DWORD *)i + 3) + 4 * (*((_DWORD *)i + 2) & v4);
    v5 = *(_DWORD *)v6;
    *(_DWORD *)v6 = 0;
    if ( v5 & 1 )
    {
      v5 &= 0xFFFFFFFEu;
      if ( !sub_1002E6D7(*((_DWORD *)i + 4) + 8 * (*((_DWORD *)i + 2) & v4), 0) )
        continue;
    }
    break;
  }
  if ( v5 )
    *(_DWORD *)i = v4 + 1;
  return v5;
}

//----- (100404AD) --------------------------------------------------------
int __thiscall sub_100404AD(void *this, char a2, int a3)
{
  void *v3; // esi@1
  int v4; // ecx@2
  int v5; // ebx@8
  int v6; // eax@8
  int v7; // edi@12

  v3 = this;
LABEL_11:
  v5 = 0;
  while ( 1 )
  {
    v7 = *(_DWORD *)v3++;
    if ( v7 >= *((_DWORD *)v3 + 1) )
    {
      *(_DWORD *)v3 = v7;
      return v5;
    }
    v4 = v7 & *((_DWORD *)v3 + 2);
    if ( *(_BYTE *)(*((_DWORD *)v3 + 7) + 4 * v4) & 1 )
    {
      if ( !a2 && sub_10045D62((void *)(*((_DWORD *)v3 + 8) + 8 * v4)) )
        break;
    }
    if ( *((_BYTE *)v3 + 20) )
    {
      if ( *(_DWORD *)v3 >= *((_DWORD *)v3 + 6) )
        *((_BYTE *)v3 + 20) = 0;
    }
    v6 = *((_DWORD *)v3 + 7) + 4 * (v7 & *((_DWORD *)v3 + 2));
    v5 = *(_DWORD *)v6;
    *(_DWORD *)v6 = 0;
    if ( v5 )
    {
      if ( !(v5 & 1) || (v5 &= 0xFFFFFFFEu, sub_1002E6D7(*((_DWORD *)v3 + 8) + 8 * (v7 & *((_DWORD *)v3 + 2)), 0)) )
        return v5;
      goto LABEL_11;
    }
  }
  *(_DWORD *)v3 = v7;
  return 0;
}

//----- (1004053B) --------------------------------------------------------
int __thiscall sub_1004053B(int this, char a2)
{
  int v2; // ebx@1
  int result; // eax@2
  int v4; // ecx@3
  int v5; // edi@3
  int v6; // esi@3
  LPVOID v7; // eax@8
  int v8; // eax@12
  void *v9; // ecx@13
  char v10; // [sp-Ch] [bp-10h]@15

  v2 = this;
  if ( sub_10040224(this) )
    return 0;
  v4 = *(_DWORD *)(v2 + 72);
  v5 = 0;
  v6 = 0;
  if ( v4 && *(_DWORD *)(v4 + 112) > 0 && !(unsigned __int8)(*(int (**)(void))(*(_DWORD *)v4 + 16))() )
  {
    if ( !*(_BYTE *)(v2 + 96) || (v6 = sub_100404AD((void *)(v2 + 76), a2, 1), !v6) )
    {
      v7 = sub_10032365();
      if ( v7 )
        v5 = (int)((char *)v7 - 4);
      *(_BYTE *)(v5 + 179) |= 2u;
      return v6;
    }
    goto LABEL_16;
  }
  result = sub_1004042F((void *)v2, a2);
  if ( result )
    return result;
  v8 = sub_100404AD((void *)(v2 + 76), a2, 0);
  v6 = v8;
  if ( v8 )
  {
    v9 = *(void **)(v2 + 72);
    if ( v9 && *(void **)(*(_DWORD *)(v8 + 8) + 12) == v9 )
    {
      sub_1002EE14(v9);
      v10 = 0;
LABEL_17:
      sub_1003FB11(v6, v10);
      return v6;
    }
LABEL_16:
    v10 = 1;
    goto LABEL_17;
  }
  return v6;
}

//----- (100405E2) --------------------------------------------------------
int __userpurge sub_100405E2<eax>(int a1<ebp>, int a2, int a3, int a4, int a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // ebx@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // eax@2

  sub_10035668();
  v9 = v6;
  *(_DWORD *)(a1 - 16) = v6;
  v7 = v6 + 4;
  v8 = 0;
  *(_DWORD *)v6 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(v6 + 4) = 0;
  *(_DWORD *)(v6 + 8) = 0;
  *(_DWORD *)(v6 + 12) = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(v6 + 16) = 0;
  *(_DWORD *)(v6 + 20) = 0;
  *(_DWORD *)(v6 + 24) = 0;
  *(_DWORD *)(v6 + 28) = 0;
  *(_DWORD *)(v6 + 32) = 0;
  *(_DWORD *)(a1 - 4) = 0;
  sub_10041185(v6, 0, v6 + 4);
  if ( !*(_BYTE *)(a1 + 16) )
  {
    v10 = sub_1002ADB1(v5, v6, v7, 0, 44);
    *(_DWORD *)(a1 + 16) = v10;
    *(_BYTE *)(a1 - 4) = 1;
    if ( v10 )
      v8 = sub_1004076E(*(_DWORD *)v9, v7, *(_DWORD *)(a1 + 20), 0);
    *(_DWORD *)(v9 + 16) = v8;
    *(_DWORD *)(v9 + 20) = v8;
  }
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 1004076E: using guessed type _DWORD __stdcall sub_1004076E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1004065C) --------------------------------------------------------
int __userpurge sub_1004065C<eax>(int a1<ebp>, int a2, int a3)
{
  int v4; // ecx@1
  int v5; // esi@1
  int v6; // eax@1
  int v7; // ST00_4@1

  sub_10035668();
  v5 = v4;
  *(_DWORD *)(a1 - 16) = v4;
  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)v4 = &off_100656C4;
  *(_DWORD *)(v4 + 4) = v6;
  *(_DWORD *)(v4 + 8) = 0;
  *(_DWORD *)(v4 + 12) = 0;
  *(_DWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 20) = 0;
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)(v4 + 32) = 0;
  *(_DWORD *)(v4 + 40) = 0;
  *(_DWORD *)(v4 + 44) = 0;
  sub_100411AE(v4, v7);
  *(_DWORD *)(v5 + 28) = sub_10032A67(*(void **)(v5 + 4));
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 100656C4: using guessed type int (__stdcall *off_100656C4)(int, int);

//----- (100406B5) --------------------------------------------------------
int __userpurge sub_100406B5<eax>(int a1<ebp>, int a2, int a3, int a4)
{
  int v5; // ecx@1
  int v6; // edi@1
  int v7; // esi@1
  int v8; // eax@1
  int v9; // ST00_4@1
  void *v10; // ST0C_4@1
  int v11; // ST04_4@1
  int v12; // ST0C_4@1
  int v13; // ST08_4@1

  sub_10035668();
  v6 = v5;
  *(_DWORD *)(a1 - 16) = v5;
  *(_DWORD *)v5 = &off_100656B0;
  *(_DWORD *)(v5 + 12) = 0;
  *(_DWORD *)(v5 + 20) = 0;
  *(_DWORD *)(v5 + 24) = 0;
  *(_DWORD *)(v5 + 28) = 0;
  *(_DWORD *)(v5 + 32) = 0;
  v7 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(v5 + 40) = 0;
  *(_DWORD *)(v5 + 44) = v5 + 40;
  *(_DWORD *)(v5 + 48) = 0;
  *(_DWORD *)(a1 - 4) = 0;
  v8 = sub_100327B1(a1, a1 - 24, v5 + 12);
  v9 = *(_DWORD *)(v7 + 4);
  *(_BYTE *)(a1 - 4) = 1;
  sub_100405E2(a1, v9, v8, 0, 64);
  v10 = *(void **)(a1 - 20);
  *(_BYTE *)(a1 - 4) = 3;
  sub_10030383(v10);
  sub_10031259((void *)(v6 + 88), *(_DWORD *)(v7 + 4), 256, 64);
  v11 = *(_DWORD *)(v7 + 4);
  *(_BYTE *)(a1 - 4) = 4;
  sub_10031259((void *)(v6 + 168), v11, 256, 2147483647);
  v12 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(v6 + 264) = 0;
  v13 = *(_DWORD *)(a1 + 12);
  *(_BYTE *)(a1 - 4) = 5;
  sub_100411C1(v6, v7, v13, v12);
  return sub_10035636(12);
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 100656B0: using guessed type int (__stdcall *off_100656B0)(char);

//----- (1004076E) --------------------------------------------------------
#error "100407D2: call analysis failed (funcsize=39)"

//----- (100407DA) --------------------------------------------------------
int __thiscall sub_100407DA(PSLIST_HEADER ListHead)
{
  int v1; // ebx@1
  PSLIST_HEADER v2; // edi@1
  int v3; // eax@1
  int v4; // eax@1
  int i; // esi@2
  int v6; // esi@4

  v2 = ListHead;
  v3 = (int)InterlockedFlushSList(ListHead);
  sub_1003226B(v3);
  v4 = (int)InterlockedFlushSList(v2 + 1);
  sub_1003226B(v4);
  sub_1003226B(LODWORD(v2[2].Alignment));
  v1 = LODWORD(v2[6].Alignment);
  if ( v1 )
  {
    do
    {
      for ( i = 0; i < LODWORD(v2[5].Alignment); ++i )
        sub_1002A4AA(*(LPVOID *)(*(_DWORD *)v1 + 4 * i));
      v6 = *(_DWORD *)(v1 + 4);
      sub_10030383(*(LPVOID *)v1);
      sub_1002A4AA((LPVOID)v1);
      v1 = v6;
    }
    while ( v6 );
  }
  return sub_10030383(HIDWORD(v2[6].Alignment));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (1004084C) --------------------------------------------------------
int __thiscall sub_1004084C(PSLIST_HEADER ListHead)
{
  int v1; // ebx@1
  PSLIST_HEADER v2; // edi@1
  int v3; // eax@1
  int v4; // eax@1
  int i; // esi@2
  void *v6; // ecx@3
  int v7; // esi@6

  v2 = ListHead;
  v3 = (int)InterlockedFlushSList(ListHead);
  sub_1002E80C(v3);
  v4 = (int)InterlockedFlushSList(v2 + 1);
  sub_1002E80C(v4);
  sub_1002E80C(LODWORD(v2[2].Alignment));
  v1 = LODWORD(v2[6].Alignment);
  if ( v1 )
  {
    do
    {
      for ( i = 0; i < LODWORD(v2[5].Alignment); ++i )
      {
        v6 = *(void **)(*(_DWORD *)v1 + 4 * i);
        if ( v6 )
          sub_1002E366(v6, 1);
      }
      v7 = *(_DWORD *)(v1 + 4);
      sub_10030383(*(LPVOID *)v1);
      sub_1002A4AA((LPVOID)v1);
      v1 = v7;
    }
    while ( v7 );
  }
  return sub_10030383(HIDWORD(v2[6].Alignment));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (100408C3) --------------------------------------------------------
int __usercall sub_100408C3<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // edi@2
  int v6; // [sp-8h] [bp-8h]@3

  sub_10035668();
  v2 = v3;
  *(_DWORD *)(a1 - 16) = v3;
  v1 = *(_DWORD *)(v3 + 20);
  *(_DWORD *)(a1 - 4) = 0;
  if ( v1 )
  {
    do
    {
      v4 = *(_DWORD *)(v1 + 24);
      if ( v1 == *(_DWORD *)(v2 + 16) )
        v6 = *(_DWORD *)(v2 + 28) - *(_DWORD *)(v1 + 16);
      else
        v6 = *(_DWORD *)(v2 + 12);
      sub_1004171A(v1, v6);
      v1 = v4;
    }
    while ( v4 );
  }
  sub_10030383(*(LPVOID *)(v2 + 8));
  return sub_10035636(4);
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1004090D) --------------------------------------------------------
int __usercall sub_1004090D<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int v2; // esi@1
  int v3; // eax@1

  sub_10035668();
  v2 = v1;
  *(_DWORD *)(a1 - 16) = v1;
  *(_DWORD *)v1 = &off_100656B0;
  v3 = *(_DWORD *)(v1 + 12);
  *(_DWORD *)(a1 - 4) = 0;
  if ( (v3 & 0xFFFFFFF) == 3 )
    sub_10040D84(*(_DWORD *)(*(_DWORD *)(v1 + 256) + 4), *(_DWORD *)(v1 + 36), v1);
  sub_100407DA((PSLIST_HEADER)(v2 + 168));
  sub_1004084C((PSLIST_HEADER)(v2 + 88));
  sub_100408C3(a1);
  sub_10030383(*(LPVOID *)(v2 + 32));
  return sub_10035636(4);
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 100656B0: using guessed type int (__stdcall *off_100656B0)(char);

//----- (10040971) --------------------------------------------------------
int __thiscall sub_10040971(int this, int a2)
{
  int v3; // esi@1

  v3 = this;
  sub_10030383(*(LPVOID *)(this + 4));
  *(_DWORD *)v3 = *(_DWORD *)a2;
  *(_DWORD *)(v3 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  return v3;
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (1004099B) --------------------------------------------------------
int __thiscall sub_1004099B(int this, signed int a2)
{
  signed int v2; // edx@1
  int v3; // esi@1
  int result; // eax@2
  int v5; // eax@3
  int v6; // ecx@3
  int v7; // eax@4
  int v8; // edx@4
  int v9; // edx@5

  v3 = this;
  v2 = a2 >> *(_DWORD *)(this + 44);
  if ( v2 < *(_DWORD *)(this + 60) )
  {
    v6 = *(_DWORD *)(this + 56);
    v5 = *(_DWORD *)(v3 + 52);
    if ( v2 < v6 )
    {
      v7 = *(_DWORD *)(v5 + 4 * v2);
    }
    else
    {
      v8 = v2 - v6;
      v7 = *(_DWORD *)(v5 + 4 * v6 - 4);
      if ( v8 >= 0 )
      {
        v9 = v8 + 1;
        do
        {
          v7 = *(_DWORD *)(v7 + 4);
          --v9;
        }
        while ( v9 );
      }
    }
    result = *(_DWORD *)(*(_DWORD *)v7 + 4 * (a2 & (*(_DWORD *)(v3 + 40) - 1)));
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100409E1) --------------------------------------------------------
int __thiscall sub_100409E1(int this, int a2)
{
  signed int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // edx@3
  int v12; // ecx@11
  signed __int64 v15; // qax@11
  signed int v16; // ST0C_4@11
  int v17; // edx@11
  int v18; // ecx@11
  int v19; // eax@12
  int v28; // edx@17
  char v30; // [sp+Ch] [bp-20h]@22
  int v31; // [sp+14h] [bp-18h]@21
  BOOL (__cdecl *v32)(); // [sp+18h] [bp-14h]@21
  int v33; // [sp+1Ch] [bp-10h]@5
  int v34; // [sp+20h] [bp-Ch]@2
  int v35; // [sp+24h] [bp-8h]@1
  char v36; // [sp+2Bh] [bp-1h]@1

  v5 = this;
  v3 = *(_DWORD *)(this + 48);
  v36 = 0;
  v4 = 0;
  v35 = v3;
  v2 = 4;
  do
  {
    _EBX = v3 + 8;
    v34 = v3 + 8;
    if ( *(_DWORD *)(v3 + 8) >= -1 )
    {
      _EBX = *(_DWORD *)v3;
      v7 = 0;
      if ( *(_DWORD *)(v5 + 40) <= 0 )
      {
LABEL_7:
        _EBX = v34;
      }
      else
      {
        while ( *(_DWORD *)_EBX )
        {
          ++v7;
          _EBX += v2;
          if ( v7 >= *(_DWORD *)(v5 + 40) )
            goto LABEL_7;
        }
        _ECX = a2;
        *(_DWORD *)a2 = v7 + v4;
        v33 = *(_DWORD *)(v5 + 64);
        __asm { lock cmpxchg [ebx], ecx }
        v4 += v7;
        v36 = 1;
        if ( v4 >= v33 )
        {
          _EAX = v5 + 64;
          _ECX = 1;
          __asm { lock xadd [eax], ecx }
        }
        _EBX = v34;
        _ECX = -1;
        __asm { lock cmpxchg [ebx], ecx }
      }
      v3 = v35;
    }
    if ( !v36 )
    {
      _ECX = -2;
      __asm { lock cmpxchg [ebx], ecx }
      v4 += *(_DWORD *)(v5 + 40);
      _EBX = v3 + 4;
      if ( !*(_DWORD *)(v3 + 4) )
      {
        _ECX = 1;
        __asm { lock cmpxchg [ebx], ecx }
        _ECX = 0;
        v15 = 4i64 * *(_DWORD *)(v5 + 40);
        __asm { seto    cl }
        v16 = 4 * *(_DWORD *)(v5 + 40);
        v33 = sub_1002965B(SHIDWORD(v15), v15 | -_ECX, _EBX, v4, v15 | -_ECX);
        sub_10039210((void *)v33, 0, v16);
        v12 = sub_1002ADB1(v17, v18, _EBX, v4, 12);
        if ( v12 )
        {
          v19 = v33;
          *(_DWORD *)(v12 + 4) = 0;
          *(_DWORD *)(v12 + 8) = -1;
          *(_DWORD *)v12 = v19;
        }
        else
        {
          v12 = 0;
        }
        v28 = *(_DWORD *)(v5 + 60);
        if ( v28 < *(_DWORD *)(v5 + 56) )
        {
          *(_DWORD *)(*(_DWORD *)(v5 + 52) + 4 * v28) = v12;
          ++*(_DWORD *)(v5 + 60);
        }
        *(_DWORD *)_EBX = v12;
        v3 = v35;
      }
      if ( *(_DWORD *)_EBX == 1 )
      {
        v31 = 0;
        v32 = sub_10034C15;
        do
          sub_100282E0((int)&v30);
        while ( *(_DWORD *)_EBX == 1 );
        v3 = v35;
      }
    }
    v3 = *(_DWORD *)(v3 + 4);
    v35 = v3;
    v2 = 4;
  }
  while ( !v36 );
  return v4;
}

//----- (10040B39) --------------------------------------------------------
int __thiscall sub_10040B39(int this, int a2)
{
  signed int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // edx@3
  int v12; // ecx@11
  signed __int64 v15; // qax@11
  signed int v16; // ST0C_4@11
  int v17; // edx@11
  int v18; // ecx@11
  int v19; // eax@12
  int v28; // edx@17
  char v30; // [sp+Ch] [bp-20h]@22
  int v31; // [sp+14h] [bp-18h]@21
  BOOL (__cdecl *v32)(); // [sp+18h] [bp-14h]@21
  int v33; // [sp+1Ch] [bp-10h]@5
  int v34; // [sp+20h] [bp-Ch]@2
  int v35; // [sp+24h] [bp-8h]@1
  char v36; // [sp+2Bh] [bp-1h]@1

  v5 = this;
  v3 = *(_DWORD *)(this + 48);
  v36 = 0;
  v4 = 0;
  v35 = v3;
  v2 = 4;
  do
  {
    _EBX = v3 + 8;
    v34 = v3 + 8;
    if ( *(_DWORD *)(v3 + 8) >= -1 )
    {
      _EBX = *(_DWORD *)v3;
      v7 = 0;
      if ( *(_DWORD *)(v5 + 40) <= 0 )
      {
LABEL_7:
        _EBX = v34;
      }
      else
      {
        while ( *(_DWORD *)_EBX )
        {
          ++v7;
          _EBX += v2;
          if ( v7 >= *(_DWORD *)(v5 + 40) )
            goto LABEL_7;
        }
        _ECX = a2;
        *(_DWORD *)(a2 + 248) = v7 + v4;
        v33 = *(_DWORD *)(v5 + 64);
        __asm { lock cmpxchg [ebx], ecx }
        v4 += v7;
        v36 = 1;
        if ( v4 >= v33 )
        {
          _EAX = v5 + 64;
          _ECX = 1;
          __asm { lock xadd [eax], ecx }
        }
        _EBX = v34;
        _ECX = -1;
        __asm { lock cmpxchg [ebx], ecx }
      }
      v3 = v35;
    }
    if ( !v36 )
    {
      _ECX = -2;
      __asm { lock cmpxchg [ebx], ecx }
      v4 += *(_DWORD *)(v5 + 40);
      _EBX = v3 + 4;
      if ( !*(_DWORD *)(v3 + 4) )
      {
        _ECX = 1;
        __asm { lock cmpxchg [ebx], ecx }
        _ECX = 0;
        v15 = 4i64 * *(_DWORD *)(v5 + 40);
        __asm { seto    cl }
        v16 = 4 * *(_DWORD *)(v5 + 40);
        v33 = sub_1002965B(SHIDWORD(v15), v15 | -_ECX, _EBX, v4, v15 | -_ECX);
        sub_10039210((void *)v33, 0, v16);
        v12 = sub_1002ADB1(v17, v18, _EBX, v4, 12);
        if ( v12 )
        {
          v19 = v33;
          *(_DWORD *)(v12 + 4) = 0;
          *(_DWORD *)(v12 + 8) = -1;
          *(_DWORD *)v12 = v19;
        }
        else
        {
          v12 = 0;
        }
        v28 = *(_DWORD *)(v5 + 60);
        if ( v28 < *(_DWORD *)(v5 + 56) )
        {
          *(_DWORD *)(*(_DWORD *)(v5 + 52) + 4 * v28) = v12;
          ++*(_DWORD *)(v5 + 60);
        }
        *(_DWORD *)_EBX = v12;
        v3 = v35;
      }
      if ( *(_DWORD *)_EBX == 1 )
      {
        v31 = 0;
        v32 = sub_10034C15;
        do
          sub_100282E0((int)&v30);
        while ( *(_DWORD *)_EBX == 1 );
        v3 = v35;
      }
    }
    v3 = *(_DWORD *)(v3 + 4);
    v35 = v3;
    v2 = 4;
  }
  while ( !v36 );
  return v4;
}

//----- (10040C95) --------------------------------------------------------
char __thiscall sub_10040C95(void *this, int a2, char a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int v7; // esi@1
  int v8; // ebx@4
  int v9; // eax@5
  int v10; // eax@6
  char v12; // [sp-14h] [bp-30h]@10
  char v13; // [sp-10h] [bp-2Ch]@5
  int v14; // [sp-Ch] [bp-28h]@5
  int v15; // [sp-8h] [bp-24h]@5
  int v16; // [sp-4h] [bp-20h]@5
  char v17; // [sp+Ch] [bp-10h]@10

  v7 = (int)this;
  v6 = (int)sub_10032365();
  if ( !v6 || sub_1003D44F(v6) != v7 )
    *(_DWORD *)(a2 + 228) = 1;
  v8 = *(_DWORD *)(*(_DWORD *)(v7 + 256) + 4);
  if ( *(_DWORD *)(v8 + 432) <= 0
    || (sub_1002F3E5((int)&v13, (int)&a3),
        LOBYTE(v9) = (*(int (__thiscall **)(int, int, _DWORD, int, int, int))(*(_DWORD *)v8 + 60))(
                       v8,
                       a2,
                       *(_DWORD *)&v13,
                       v14,
                       v15,
                       v16),
        !(_BYTE)v9) )
  {
    v10 = *(_DWORD *)v7;
    v16 = a2;
    (*(void (__thiscall **)(int, int))(v10 + 8))(v7, a2);
    v9 = v7 + 12;
    if ( *(_DWORD *)(v7 + 12) & 0xFFFFFFF )
    {
      LOBYTE(v9) = sub_1002E2CF((int)&a3, v7 + 12);
      if ( (_BYTE)v9 )
        LOBYTE(v9) = (*(int (__thiscall **)(int))(*(_DWORD *)v7 + 4))(v7);
    }
    if ( *(_DWORD *)(v8 + 428) > 0 )
    {
      sub_1002F3E5((int)&v17, (int)&a3);
      v16 = 11;
      sub_1002F3E5((int)&v12, (int)&v17);
      LOBYTE(v9) = sub_1003416B((void *)v8, v7, v12, *(int *)&v13, v14, v15, v16);
    }
  }
  *(_DWORD *)(a2 + 228) = 0;
  return v9;
}

//----- (10040D78) --------------------------------------------------------
bool __cdecl sub_10040D78(int a1)
{
  bool result; // eax@1

  result = sub_10032DCA(*(_DWORD *)(a1 + 36));
  if ( !result )
  {
    sub_1003226B(*(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    *(_DWORD *)(a1 + 72) = 0;
  }
  return result;
}

//----- (10040D84) --------------------------------------------------------
int __thiscall sub_10040D84(int this, int a2, int a3)
{
  int result; // eax@1

  result = a3;
  if ( *(_DWORD *)((a2 << 7) + *(_DWORD *)(this + 92)) == a3 )
  {
    _EDX = 0;
    _ECX = (a2 << 7) + *(_DWORD *)(this + 92);
    __asm { lock cmpxchg [ecx], edx }
  }
  return result;
}

//----- (10040DA9) --------------------------------------------------------
int __thiscall sub_10040DA9(void *this, int a2, int a3)
{
  int v3; // ecx@1
  int v4; // ebx@1
  int v5; // eax@3
  PSINGLE_LIST_ENTRY v6; // eax@5
  int v7; // esi@6
  int v8; // ecx@11
  int v10; // [sp+Ch] [bp-4h]@3

  v4 = (int)this;
  v3 = (int)((char *)this + 16);
  if ( *(_DWORD *)a2 & 0xFFFFFFF )
    v3 = v4 + 12;
  v10 = v3;
  v5 = a3 + 96;
  if ( *(_DWORD *)a2 & 0xFFFFFFF )
    v5 = a3 + 16;
  v6 = InterlockedPopEntrySList((PSLIST_HEADER)v5);
  if ( v6 && (v7 = (int)&v6[-71], v6 != (PSINGLE_LIST_ENTRY)284) )
    sub_100411C1((int)&v6[-71], v4, a3, a2);
  else
    v7 = (*(int (__thiscall **)(_DWORD, _DWORD, _DWORD))(*(_DWORD *)v4 + 32))(v4, a3, a2);
  *(_DWORD *)(v7 + 260) = *(_DWORD *)v10;
  *(_DWORD *)v10 = v7;
  if ( !*(_DWORD *)(a3 + 188) )
    sub_100473E6(a3);
  v8 = a3 + 96;
  if ( *(_DWORD *)a2 & 0xFFFFFFF )
    v8 = a3 + 16;
  sub_10040B39(v8, v7);
  return v7;
}

//----- (10040E41) --------------------------------------------------------
int __usercall sub_10040E41<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int v3; // esi@1
  int v5; // eax@2
  int v6; // eax@3

  sub_10035668();
  v3 = v1;
  _EDI = v1 + 16;
  if ( !*(_DWORD *)(v1 + 16) )
  {
    _EDX = 1;
    __asm { lock cmpxchg [edi], edx }
    v5 = sub_1002ADB1(1, v1, 0, _EDI, 44);
    *(_DWORD *)(a1 - 16) = v5;
    *(_DWORD *)(a1 - 4) = 0;
    if ( v5 )
      v6 = sub_1004076E(*(_DWORD *)v3, v3 + 4, *(_DWORD *)(v3 + 12), 0);
    else
      v6 = 0;
    *(_DWORD *)(a1 - 4) = -1;
    *(_DWORD *)_EDI = v6;
    *(_DWORD *)(v3 + 20) = v6;
  }
  if ( !*(_DWORD *)(v3 + 20) )
  {
    *(_DWORD *)(a1 - 24) = 0;
    *(_DWORD *)(a1 - 20) = sub_10034BD7;
    do
      sub_100282E0(a1 - 32);
    while ( !*(_DWORD *)(v3 + 20) );
  }
  return sub_10035636(20);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 1004076E: using guessed type _DWORD __stdcall sub_1004076E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10040EB7) --------------------------------------------------------
char __userpurge sub_10040EB7<al>(int a1<ecx>, int i<edi>, int a3)
{
  int v4; // ebx@1
  unsigned int v5; // esi@2
  int v7; // eax@6
  int v8; // ecx@6
  int v9; // edx@7
  int v10; // eax@11
  int v13; // esi@16
  char v14; // al@16
  int v16; // [sp+Ch] [bp-18h]@16
  int v17; // [sp+10h] [bp-14h]@16
  int v18; // [sp+14h] [bp-10h]@1
  int v19; // [sp+18h] [bp-Ch]@6
  int v20; // [sp+1Ch] [bp-8h]@11
  int v21; // [sp+20h] [bp-4h]@6

  v4 = a1;
  v18 = a1;
  _EDX = a1 + 24;
LABEL_2:
  v5 = *(_DWORD *)_EDX;
  while ( v5 != *(_DWORD *)(v4 + 28) )
  {
    _ECX = v5 + 1;
    __asm { lock cmpxchg [edx], ecx }
    if ( v5 == v5 )
    {
      v8 = sub_10041243(v4, v4, i, v5, 0);
      v7 = v4 + 20;
      v21 = v8;
      v19 = v4 + 20;
      if ( v8 != *(_DWORD *)(v4 + 20) )
      {
        v9 = *(_DWORD *)v7;
        for ( i = *(_DWORD *)v7; ; i = v9 )
        {
          while ( !(*(_DWORD *)(v4 + 12) + *(_DWORD *)(i + 20)) )
            i = *(_DWORD *)(i + 24);
          if ( *(_DWORD *)(i + 16) <= *(_DWORD *)(v9 + 16) )
            break;
          _EBX = v19;
          _ECX = i;
          v10 = v9;
          __asm { lock cmpxchg [ebx], ecx }
          v4 = v18;
          v20 = v9;
          if ( v9 == v9 )
          {
            while ( v10 != i )
            {
              sub_1004171A(v10, *(_DWORD *)(v4 + 12));
              v10 = *(_DWORD *)(v20 + 24);
              v20 = *(_DWORD *)(v20 + 24);
            }
            break;
          }
        }
        v8 = v21;
      }
      v13 = v5 - *(_DWORD *)(v8 + 16);
      v16 = v8;
      v17 = v13;
      v14 = sub_1002E6D7((int)&v16, a3);
      _EDX = v4 + 24;
      if ( v14 )
        return 1;
      goto LABEL_2;
    }
  }
  return 0;
}

//----- (10040F79) --------------------------------------------------------
int __thiscall sub_10040F79(void *this)
{
  void *v1; // eax@1
  int v2; // edx@1
  int result; // eax@2
  int v4; // ecx@3

  v1 = this;
  v2 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    v4 = *(_DWORD *)(v2 + 12);
    *(_DWORD *)v1 = v4;
    if ( !v4 )
      *((_DWORD *)v1 + 1) = v1;
    result = v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10040FB6) --------------------------------------------------------
int __thiscall sub_10040FB6(int this, int a2)
{
  int v2; // eax@1
  int v3; // ebx@1

  v3 = this;
  v2 = *(_DWORD *)(this + 256);
  if ( !(*(_BYTE *)(v2 + 48) & 4) )
  {
    _EAX = v2 + 20;
    _EDX = 1;
    __asm { lock xadd [eax], edx }
  }
  sub_10041399((void *)(a2 + 76));
  *(_DWORD *)(a2 + 56) = 1;
  return sub_100409E1(v3 + 168, a2 + 44);
}

//----- (10040FFC) --------------------------------------------------------
int __thiscall sub_10040FFC(int this, int a2)
{
  int v3; // ebx@1

  v3 = this;
  sub_10034BBC((void *)(this + 8));
  *(_DWORD *)(a2 + 12) = 0;
  **(_DWORD **)(v3 + 4) = a2;
  *(_DWORD *)(v3 + 4) = a2 + 12;
  return sub_10034BCC((void *)(v3 + 8));
}

//----- (1004102C) --------------------------------------------------------
int __thiscall sub_1004102C(void *this, int a2, int a3)
{
  int v3; // esi@1
  int v4; // esi@3
  char v6; // [sp+Ch] [bp-10h]@3

  v3 = (int)((char *)this + 16);
  if ( *(_DWORD *)a2 & 0xFFFFFFF )
    v3 = (int)((char *)this + 12);
  v4 = *(_DWORD *)v3;
  sub_10045EC2(*(void **)(a3 + 4), (int)&v6);
  while ( v4 && (!sub_1002E2CF(v4 + 12, a2) || *(_DWORD *)(v4 + 8) != a3) )
    v4 = *(_DWORD *)(v4 + 260);
  return v4;
}

//----- (1004107E) --------------------------------------------------------
int __thiscall sub_1004107E(int this)
{
  signed int v1; // ebx@1
  int v2; // edi@1
  signed int v3; // esi@1
  int v4; // eax@2
  int result; // eax@5
  int v6; // esi@7
  int v7; // [sp+Ch] [bp-4h]@2

  v2 = this;
  v3 = 0;
  v1 = *(_DWORD *)(this + 232);
  if ( v1 <= 0 )
  {
LABEL_5:
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      v4 = sub_1004099B(v2 + 168, v3);
      v7 = v4;
      if ( v4 )
      {
        if ( sub_100413F9((void *)(v2 + 168), v4, v3, 0) )
          break;
      }
      ++v3;
      if ( v3 >= v1 )
        goto LABEL_5;
    }
    v6 = *(_DWORD *)(v7 + 8);
    *(_DWORD *)(v6 + 56) = 0;
    sub_10033312(*(void **)(v2 + 256));
    result = v6;
  }
  return result;
}

//----- (100410E3) --------------------------------------------------------
int __thiscall sub_100410E3(void *this, int a2, char a3)
{
  int v3; // eax@1
  int ebp0; // ebp@0
  int v5; // edi@1
  int v6; // esi@1

  v5 = (int)this;
  v3 = sub_1003294B(ebp0, 1);
  v6 = v3;
  if ( v3 )
    sub_10046AD3(v3, v5, a2, a3);
  return v6;
}

//----- (10041116) --------------------------------------------------------
int __thiscall sub_10041116(void *this)
{
  void *v1; // edi@3
  void *v2; // esi@3
  int v3; // edi@3
  int v4; // ecx@1
  int result; // eax@2

  v4 = (int)((char *)this + 40);
  if ( *(_DWORD *)v4 )
  {
    v1 = (void *)v4;
    v2 = (void *)(v4 + 8);
    sub_10034BBC((void *)(v4 + 8));
    v3 = sub_10040F79(v1);
    sub_10034BCC(v2);
    result = v3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10041126) --------------------------------------------------------
int __userpurge sub_10041126<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // eax@1
  int v9; // edx@1
  int v10; // ecx@1

  sub_10035668();
  v6 = v7;
  v8 = sub_1002ADB1(v9, v7, a1, a3, 44);
  v10 = v8;
  *(_DWORD *)(a2 - 16) = v8;
  v5 = *(_DWORD *)(a2 + 8);
  v4 = 0;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v10 )
    v4 = sub_1004076E(*(_DWORD *)v6, v6 + 4, *(_DWORD *)(v6 + 12), *(_DWORD *)(v6 + 12) + *(_DWORD *)(v5 + 16));
  *(_DWORD *)(v6 + 16) = v4;
  *(_DWORD *)(v5 + 24) = v4;
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 1004076E: using guessed type _DWORD __stdcall sub_1004076E(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10041170) --------------------------------------------------------
bool __thiscall sub_10041170(int this)
{
  return *(_DWORD *)(this + 40) != 0;
}

//----- (10041179) --------------------------------------------------------
bool __thiscall sub_10041179(void *this)
{
  return sub_10041346(this) != 0;
}

//----- (10041185) --------------------------------------------------------
int __userpurge sub_10041185<eax>(int a1<ecx>, int a2<edi>, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  v4 = a1;
  result = sub_1003217C(a1 + 4, a2, a3);
  if ( *(_DWORD *)(v4 + 20) )
    result = sub_1003217C(*(_DWORD *)(v4 + 20) + 4, a2, a3);
  return result;
}

//----- (100411AE) --------------------------------------------------------
int __thiscall sub_100411AE(int this, int a2)
{
  *(_DWORD *)(this + 20) = 1;
  return sub_1002F3E5(this + 32, a2);
}

//----- (100411C1) --------------------------------------------------------
int __thiscall sub_100411C1(int this, int a2, int a3, int a4)
{
  int ebp0; // ebp@0
  int v5; // esi@1
  int v6; // eax@1
  char v8; // [sp+Ch] [bp-8h]@1
  void *v9; // [sp+10h] [bp-4h]@1

  v5 = this;
  *(_DWORD *)(this + 256) = a2;
  *(_DWORD *)(this + 8) = a3;
  sub_1002F3E5(this + 12, a4);
  *(_DWORD *)(v5 + 268) = 0;
  *(_DWORD *)(v5 + 280) = 1;
  v6 = sub_100327B1(ebp0, (int)&v8, a4);
  sub_10040971(v5 + 28, v6);
  sub_10030383(v9);
  if ( (*(_DWORD *)a4 & 0xFFFFFFF) == 3 )
    *(_DWORD *)(v5 + 36) = sub_10032C26(*(_DWORD *)(a2 + 4), *(_DWORD *)(a4 + 8));
  return sub_10041185(v5 + 52, a4, v5 + 28);
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (10041243) --------------------------------------------------------
int __userpurge sub_10041243<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned int a4, char a5)
{
  int ebp0; // ebp@0
  int v6; // esi@1
  int v7; // ecx@4
  int v8; // edx@6

  v6 = a1;
  if ( !*(_DWORD *)(a1 + 20) )
    sub_10040E41(ebp0);
  if ( a5 )
    v7 = *(_DWORD *)(v6 + 16);
  else
    v7 = *(_DWORD *)(v6 + 20);
  v8 = v7;
  do
  {
    if ( a4 < *(_DWORD *)(v6 + 12) + *(_DWORD *)(v7 + 16) )
      break;
    v7 = *(_DWORD *)(v7 + 24);
    if ( !v7 )
      v7 = sub_10041126(a2, ebp0, a3, v8);
    v8 = v7;
  }
  while ( v7 );
  return v7;
}

//----- (1004128D) --------------------------------------------------------
int __thiscall sub_1004128D(int this, int a2, char a3)
{
  int v3; // eax@1
  int v4; // esi@1
  int v5; // edi@2
  int v6; // ebx@4
  int v7; // eax@5
  int v8; // eax@5
  int result; // eax@8
  char v10; // [sp+Ch] [bp-34h]@5
  char v11; // [sp+1Ch] [bp-24h]@4
  int v12; // [sp+2Ch] [bp-14h]@4
  int v13; // [sp+34h] [bp-Ch]@4
  int v14; // [sp+38h] [bp-8h]@4
  int v15; // [sp+3Ch] [bp-4h]@4

  v4 = this;
  v3 = sub_100324D1(*(void **)(this + 4));
  if ( v3 )
    v5 = *(_DWORD *)(v3 + 4);
  else
    v5 = sub_10032B1F(*(_DWORD *)(v4 + 4));
  sub_10045EC2(*(void **)(v5 + 4), (int)&v11);
  v6 = a2;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = v5;
  while ( !sub_1004D709((int)&v11, v6) )
  {
    v7 = sub_10032AF5(*(_DWORD *)(v4 + 4), 0, v5);
    v5 = v7;
    v8 = sub_10045EC2(*(void **)(v7 + 4), (int)&v10);
    sub_1002F3E5((int)&v11, v8);
    if ( v5 == v15 )
      v6 = (int)&v12;
  }
  result = (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v4 + 36))(v4, v6, v5);
  if ( !result )
  {
    if ( a3 )
    {
      sub_10030F90((void *)(v4 + 8));
      result = (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v4 + 36))(v4, v6, v5);
      if ( !result )
        result = sub_10040DA9((void *)v4, v6, v5);
      *(_DWORD *)(v4 + 8) = 0;
    }
  }
  return result;
}

//----- (10041346) --------------------------------------------------------
bool __thiscall sub_10041346(void *this)
{
  signed int i; // edi@1
  int v2; // esi@1
  bool result; // eax@2

  v2 = (int)this;
  for ( i = 0; i < *(_DWORD *)(v2 + 152); ++i )
  {
    result = sub_1004099B(v2 + 88, i);
    if ( result )
    {
      if ( *(_DWORD *)(result + 4) > *(_DWORD *)result || *(_DWORD *)(result + 80) > *(_DWORD *)(result + 76) )
        return result;
      if ( *(_DWORD *)(result + 56) == 1 )
        sub_10041578(v2, result);
    }
  }
  return *(_DWORD *)(v2 + 76) != *(_DWORD *)(v2 + 80);
}

//----- (10041399) --------------------------------------------------------
int __thiscall sub_10041399(void *this)
{
  void *v2; // edi@1
  void *v3; // esi@1
  int v4; // eax@1

  v2 = this;
  v3 = (void *)*((_DWORD *)this + 4);
  sub_10034BBC(*((void **)this + 4));
  v4 = *((_DWORD *)v2 + 1);
  *((_BYTE *)v2 + 20) = 1;
  *((_DWORD *)v2 + 6) = v4;
  return sub_10034BCC(v3);
}

//----- (100413BA) --------------------------------------------------------
int __thiscall sub_100413BA(void *this, int a2)
{
  return sub_100409E1((int)((char *)this + 168), a2 + 44);
}

//----- (100413D3) --------------------------------------------------------
PSINGLE_LIST_ENTRY __thiscall sub_100413D3(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v4; // esi@1

  v4 = this;
  sub_10046C02(a2, ebp0);
  return sub_10033A94(*(_DWORD *)(*((_DWORD *)v4 + 64) + 4), a2, 0);
}

//----- (100413F9) --------------------------------------------------------
char __thiscall sub_100413F9(void *ListHead, int a2, signed int a3, char a4)
{
  signed int v4; // edx@1
  int v6; // esi@1
  char result; // al@2
  int v8; // eax@3
  int v9; // ecx@3
  int v10; // edx@4
  int v11; // edi@4
  int v12; // edx@5
  PSINGLE_LIST_ENTRY v18; // eax@14
  int v19; // ST08_4@14

  v6 = (int)ListHead;
  v4 = a3 >> *((_DWORD *)ListHead + 11);
  _EBX = a3 & (*((_DWORD *)ListHead + 10) - 1);
  if ( v4 < *((_DWORD *)ListHead + 15) )
  {
    v9 = *((_DWORD *)ListHead + 14);
    v8 = *(_DWORD *)(v6 + 52);
    if ( v4 < v9 )
    {
      v11 = *(_DWORD *)(v8 + 4 * v4);
    }
    else
    {
      v10 = v4 - v9;
      v11 = *(_DWORD *)(v8 + 4 * v9 - 4);
      if ( v10 >= 0 )
      {
        v12 = v10 + 1;
        do
        {
          v11 = *(_DWORD *)(v11 + 4);
          --v12;
        }
        while ( v12 );
      }
    }
    _ECX = *(_DWORD *)v11 + 4 * _EBX;
    _EDX = 0;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 == a2 )
    {
      _ECX = v11 + 8;
      __asm { lock cmpxchg [ecx], ebx }
      if ( a4 )
      {
        if ( (signed int)QueryDepthSList((PSLIST_HEADER)v6) <= *(_DWORD *)(v6 + 68) )
        {
          InterlockedPushEntrySList((PSLIST_HEADER)v6, (PSINGLE_LIST_ENTRY)(a2 + 4));
        }
        else
        {
          InterlockedPushEntrySList((PSLIST_HEADER)(v6 + 8), (PSINGLE_LIST_ENTRY)(a2 + 4));
          if ( (signed int)QueryDepthSList((PSLIST_HEADER)(v6 + 8)) > *(_DWORD *)(v6 + 68) )
          {
            if ( !sub_10032DCA(*(_DWORD *)(v6 + 36)) )
            {
              _EDX = 1;
              _ECX = v6 + 72;
              __asm { lock cmpxchg [ecx], edx }
              v18 = InterlockedFlushSList((PSLIST_HEADER)(v6 + 8));
              v19 = *(_DWORD *)(v6 + 36);
              *(_DWORD *)(v6 + 16) = v18;
              sub_1003337E(v6 + 20, (int (__cdecl *)(_DWORD))sub_10040D78, v6, v19);
            }
          }
        }
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100414EF) --------------------------------------------------------
char __thiscall sub_100414EF(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_10033E20(*(_DWORD *)(*(_DWORD *)(this + 256) + 4), this + 268);
  return sub_10047543(*(void **)(v2 + 8), v2);
}

//----- (10041512) --------------------------------------------------------
char __thiscall sub_10041512(int this)
{
  int v1; // ecx@1
  int v2; // edi@1
  char result; // al@2
  int v4; // esi@2
  int v5; // ecx@3
  int v6; // esi@4

  v2 = this;
  v1 = *(_DWORD *)(this + 16);
  if ( v1 )
  {
    do
    {
      v4 = *(_DWORD *)(v1 + 260);
      result = sub_100414EF(v1);
      v1 = v4;
    }
    while ( v4 );
  }
  v5 = *(_DWORD *)(v2 + 12);
  if ( v5 )
  {
    do
    {
      v6 = *(_DWORD *)(v5 + 260);
      result = sub_100414EF(v5);
      v5 = v6;
    }
    while ( v6 );
  }
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)(v2 + 12) = 0;
  return result;
}

//----- (10041551) --------------------------------------------------------
int __thiscall sub_10041551(int this, int a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002EE76((void *)(this + 88), a2, *(_DWORD *)(a2 + 68), 1);
  return sub_10033312(*(void **)(v3 + 256));
}

//----- (10041578) --------------------------------------------------------
char __thiscall sub_10041578(int this, int a2)
{
  int v2; // edi@1

  v2 = this;
  if ( sub_100413F9((void *)(this + 168), a2 + 44, *(_DWORD *)(a2 + 44), 0) )
  {
    if ( *(_DWORD *)(a2 + 80) <= *(_DWORD *)(a2 + 76) )
    {
      sub_10040298(a2, v2);
      return 1;
    }
    sub_1004023A(a2, v2);
  }
  return 0;
}

//----- (100415BA) --------------------------------------------------------
int __thiscall sub_100415BA(void *this, int a2, int a3, int a4)
{
  int v5; // eax@1

  v5 = (*(int (__stdcall **)(int, signed int))(*(_DWORD *)this + 20))(a4, 1);
  return sub_100415EE(v5, a2, a3);
}

//----- (100415D8) --------------------------------------------------------
int __thiscall sub_100415D8(void *this, int a2, int a3)
{
  int v4; // eax@1

  v4 = (*(int (__cdecl **)(_DWORD, _DWORD))(*(_DWORD *)this + 20))((char *)this + 32, 1);
  return sub_100415EE(v4, a2, a3);
}

//----- (100415EE) --------------------------------------------------------
int __thiscall sub_100415EE(int this, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // eax@2
  int v5; // eax@2
  int v6; // ecx@2
  int v7; // edi@2
  int v15; // eax@4
  int v16; // esi@4
  int v17; // eax@6
  int v18; // edx@9
  int v19; // ecx@9
  void *v20; // esi@9
  int result; // eax@17
  char v22; // [sp-10h] [bp-28h]@18
  int v23; // [sp-4h] [bp-1Ch]@2
  int (__stdcall **v24)(char); // [sp+Ch] [bp-Ch]@20

  v3 = this;
  if ( !a2 )
  {
    a2 = (int)"proc";
    sub_1002AEA4((int)&v24, &a2);
    v24 = &off_100602FC;
    sub_100355DB((int)&v24, (int)&unk_1006D8F4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1004171A);
  }
  v5 = *(_DWORD *)(this + 256);
  v23 = a3;
  v7 = *(_DWORD *)(v5 + 4);
  v4 = sub_10032BB6(v7, this, v7, a2, a3);
  v6 = *(_DWORD *)(v3 + 256);
  if ( !(*(_BYTE *)(v6 + 48) & 4) )
  {
    _ECX = v6 + 20;
    _EDX = 1;
    __asm { lock xadd [ecx], edx }
  }
  sub_10040FFC(v3 + 40, v4);
  v15 = (int)sub_10032365();
  v16 = v15;
  if ( v15 && sub_10032E0B(v15) == v7 )
  {
    v17 = *(_DWORD *)(v16 + 156);
    if ( *(_BYTE *)(v16 + 76) )
      ++*(_DWORD *)(v17 + 8);
    else
      ++*(_DWORD *)(v17 + 92);
  }
  else
  {
    v20 = TlsGetValue(*(_DWORD *)(v7 + 24));
    if ( !v20 )
    {
      v20 = (void *)sub_1002ADB1(v18, v19, v3, v7, 28);
      if ( v20 )
      {
        *((_DWORD *)v20 + 2) = 0;
        *((_DWORD *)v20 + 3) = 0;
        *((_DWORD *)v20 + 4) = 0;
        *((_DWORD *)v20 + 5) = 0;
        *((_DWORD *)v20 + 6) = 1;
      }
      else
      {
        v20 = 0;
      }
      sub_100409E1(v7 + 200, (int)v20);
      TlsSetValue(*(_DWORD *)(v7 + 24), v20);
    }
    ++*((_DWORD *)v20 + 2);
  }
  if ( *(_DWORD *)(v3 + 12) & 0xFFFFFFF )
    (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
  result = *(_DWORD *)(v7 + 432);
  if ( *(_DWORD *)(v7 + 428) - result > 0 )
  {
    sub_1002F3E5((int)&v22, v3 + 12);
    result = (*(int (__thiscall **)(int))(*(_DWORD *)v7 + 56))(v7);
  }
  return result;
}
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);

//----- (1004171A) --------------------------------------------------------
int __thiscall sub_1004171A(int this, int a2)
{
  int result; // eax@1

  _EDX = a2;
  result = this + 20;
  __asm { lock xadd [eax], edx }
  if ( !(a2 + _EDX) )
    result = sub_1003337E(this + 28, sub_1002EFC4, this, *(_DWORD *)this);
  return result;
}

//----- (10041740) --------------------------------------------------------
int __userpurge sub_10041740<eax>(int a1<ecx>, int a2<edi>, char a3)
{
  signed int v3; // ebx@1
  int ebp0; // ebp@0
  int v5; // esi@1
  int v6; // ecx@1
  signed int v7; // eax@2
  int v8; // eax@3
  int result; // eax@5
  int v10; // eax@7
  int v11; // eax@8
  int v12; // ecx@8
  char v13; // al@12
  int v14; // ecx@17
  int v15; // ecx@20
  int v16; // eax@21
  char v17; // al@26
  int v18; // eax@35
  int v19; // [sp+Ch] [bp-5Ch]@1
  int v20; // [sp+10h] [bp-58h]@9
  int v21; // [sp+14h] [bp-54h]@5
  int v22; // [sp+18h] [bp-50h]@2
  int v23; // [sp+1Ch] [bp-4Ch]@2
  char v24; // [sp+22h] [bp-46h]@2
  char v25; // [sp+23h] [bp-45h]@1
  int v26[16]; // [sp+24h] [bp-44h]@8
  unsigned int v27; // [sp+64h] [bp-4h]@1
  int v28; // [sp+68h] [bp+0h]@1

  v27 = (unsigned int)&v28 ^ __security_cookie;
  v5 = a1;
  v3 = 0;
  v6 = *(_DWORD *)(a1 + 152);
  LOBYTE(v20) = a3;
  v25 = 0;
  v19 = v6;
  if ( v6 > 0 )
  {
    v7 = 0;
    v22 = 0;
    v24 = 0;
    v23 = 0;
    while ( 1 )
    {
      v8 = sub_1004099B(v5 + 88, v7);
      a2 = v8;
      if ( v8 )
      {
        if ( sub_10040224(v8) )
        {
          v13 = *(_DWORD *)(a2 + 56) == 1;
        }
        else
        {
          result = sub_100403C9(a2, a3, (int)&v24);
          v21 = result;
          if ( result )
            return result;
          if ( !v24 )
          {
            v10 = v22;
            if ( v22 < 15 )
            {
              v12 = v23;
              v26[v22] = v23;
              v11 = v10 + 1;
              v22 = v11;
              goto LABEL_17;
            }
            result = sub_100402DE(ebp0, v20);
            v21 = result;
            if ( result )
              return result;
          }
          v13 = *(_DWORD *)(a2 + 56) == 1 && sub_10040224(a2);
        }
        v25 |= v13;
      }
      v11 = v22;
      v12 = v23;
LABEL_17:
      v14 = v12 + 1;
      v23 = v14;
      if ( v14 >= v19 )
      {
        if ( v11 > 0 )
        {
          v15 = 0;
          v23 = 0;
          while ( 1 )
          {
            v16 = sub_1004099B(v5 + 88, v26[v15]);
            a2 = v16;
            if ( v16 )
            {
              if ( !sub_10040224(v16) )
              {
                result = sub_100402DE(ebp0, v20);
                v21 = result;
                if ( result )
                  return result;
              }
              v17 = *(_DWORD *)(a2 + 56) == 1 && sub_10040224(a2);
              v25 |= v17;
            }
            v15 = v23 + 1;
            v23 = v15;
            if ( v15 >= v22 )
              goto LABEL_30;
          }
        }
        break;
      }
      v7 = v14;
    }
  }
LABEL_30:
  if ( sub_10040EB7(v5 + 52, a2, (int)&v21) )
  {
    sub_1003FB11(v21, 1);
    result = v21;
  }
  else
  {
    if ( *(_DWORD *)(v5 + 232) > 0 )
    {
      if ( v25 )
      {
        if ( *(_DWORD *)(v5 + 152) > 0 )
        {
          do
          {
            v18 = sub_1004099B(v5 + 88, v3);
            if ( v18 )
            {
              if ( *(_DWORD *)(v18 + 56) == 1 )
              {
                if ( *(_DWORD *)(v18 + 80) <= *(_DWORD *)(v18 + 76) )
                  sub_10041578(v5, v18);
              }
            }
            ++v3;
          }
          while ( v3 < *(_DWORD *)(v5 + 152) );
        }
      }
    }
    result = 0;
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10041740: using guessed type int var_44[16];

//----- (100418EF) --------------------------------------------------------
void __userpurge sub_100418EF(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, LPVOID lpMem)
{
  int v5; // ST04_4@3
  int v6; // ST04_4@5
  int v7; // ST04_4@7
  int v8; // ST04_4@9
  int v9; // ST04_4@11
  int v10; // ST04_4@13
  int v11; // ST04_4@15
  int v12; // ST04_4@17
  void *v13; // edi@18

  if ( lpMem )
  {
    if ( *((_DWORD *)lpMem + 9) )
    {
      sub_100309A2(a3, *((LPVOID *)lpMem + 9));
      a2 = v5;
    }
    if ( *((_DWORD *)lpMem + 11) )
    {
      sub_100309A2(a3, *((LPVOID *)lpMem + 11));
      a2 = v6;
    }
    if ( *((_DWORD *)lpMem + 13) )
    {
      sub_100309A2(a3, *((LPVOID *)lpMem + 13));
      a2 = v7;
    }
    if ( *((_DWORD *)lpMem + 15) )
    {
      sub_100309A2(a3, *((LPVOID *)lpMem + 15));
      a2 = v8;
    }
    if ( *((_DWORD *)lpMem + 16) )
    {
      sub_100309A2(a3, *((LPVOID *)lpMem + 16));
      a2 = v9;
    }
    if ( *((_DWORD *)lpMem + 17) )
    {
      sub_100309A2(a3, *((LPVOID *)lpMem + 17));
      a2 = v10;
    }
    if ( *((_DWORD *)lpMem + 18) )
    {
      sub_100309A2(a3, *((LPVOID *)lpMem + 18));
      a2 = v11;
    }
    if ( *((_UNKNOWN **)lpMem + 23) != &unk_10065F58 )
    {
      sub_100309A2(a3, *((LPVOID *)lpMem + 23));
      a2 = v12;
    }
    sub_10036A43(a1, a2, a3, a4, 13);
    v13 = (void *)*((_DWORD *)lpMem + 26);
    if ( v13 )
    {
      if ( !InterlockedDecrement(*((volatile LONG **)lpMem + 26)) )
      {
        if ( v13 != &unk_100747B8 )
          sub_100309A2(a3, v13);
      }
    }
    sub_10036BA7(13);
  }
}

//----- (10041A26) --------------------------------------------------------
void __usercall sub_10041A26(int a1<ebx>, int a2<edi>, LPVOID lpMem)
{
  DWORD v3; // eax@1
  void *v4; // esi@2
  int v5; // edx@4
  int v6; // ST04_4@4

  v3 = dword_100744B0;
  if ( dword_100744B0 != -1 )
  {
    v4 = lpMem;
    if ( !lpMem )
    {
      v4 = sub_100394E9(dword_100744B0);
      v3 = dword_100744B0;
    }
    sub_10039508(v3, 0);
    sub_100418EF(v5, v6, a1, a2, v4);
  }
}
// 100744B0: using guessed type int dword_100744B0;

//----- (10041A5C) --------------------------------------------------------
int __usercall sub_10041A5C<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // esi@1

  v4 = sub_10041A74(a1);
  if ( !v4 )
    sub_1003AF92(v2, v3, a1, a2, 16);
  return v4;
}

//----- (10041A74) --------------------------------------------------------
int __usercall sub_10041A74<eax>(int a1<ebx>)
{
  DWORD v1; // edi@1
  int v2; // esi@1
  void *v3; // eax@2
  int v4; // edx@3
  DWORD v5; // eax@4
  int v7; // [sp-4h] [bp-Ch]@1
  int v8; // [sp-4h] [bp-Ch]@3

  v1 = GetLastError();
  v2 = (int)sub_100394E9(dword_100744B0);
  if ( !v2 )
  {
    v3 = sub_10037506(v7, a1, 1u, 0x3BCu);
    v2 = (int)v3;
    if ( v3 )
    {
      if ( sub_10039508(dword_100744B0, v3) )
      {
        sub_10041AE3(v4, v8, a1, v2);
        v5 = GetCurrentThreadId();
        *(_DWORD *)(v2 + 4) = -1;
        *(_DWORD *)v2 = v5;
      }
      else
      {
        sub_100309A2(a1, (LPVOID)v2);
        v2 = 0;
      }
    }
  }
  SetLastError(v1);
  return v2;
}
// 100744B0: using guessed type int dword_100744B0;

//----- (10041AE3) --------------------------------------------------------
void __usercall sub_10041AE3(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  *(_DWORD *)(a4 + 92) = &unk_10065F58;
  *(_DWORD *)(a4 + 8) = 0;
  *(_DWORD *)(a4 + 20) = 1;
  *(_DWORD *)(a4 + 112) = 1;
  *(_WORD *)(a4 + 184) = 67;
  *(_WORD *)(a4 + 446) = 67;
  *(_DWORD *)(a4 + 104) = &unk_100747B8;
  *(_DWORD *)(a4 + 952) = 0;
  sub_10036A43(a1, a2, a3, 1, 13);
  InterlockedIncrement(*(volatile LONG **)(a4 + 104));
  sub_10036BA7(13);
}

//----- (10041B96) --------------------------------------------------------
signed int __usercall sub_10041B96<eax>(int a1<ebx>)
{
  signed int result; // eax@2
  void *v2; // eax@4
  int v3; // esi@4
  int v4; // edx@5
  DWORD v5; // eax@6
  int v6; // [sp-8h] [bp-8h]@5
  int v7; // [sp-4h] [bp-4h]@3

  sub_1003B063();
  if ( sub_10036B72() && (dword_100744B0 = sub_100394AC((int)sub_100418EF), dword_100744B0 != -1) )
  {
    v2 = sub_10037506(v7, a1, 1u, 0x3BCu);
    v3 = (int)v2;
    if ( v2 && sub_10039508(dword_100744B0, v2) )
    {
      sub_10041AE3(v4, v6, a1, v3);
      v5 = GetCurrentThreadId();
      *(_DWORD *)(v3 + 4) = -1;
      *(_DWORD *)v3 = v5;
      result = 1;
    }
    else
    {
      sub_10041C0C();
      result = 0;
    }
  }
  else
  {
    sub_10041C0C();
    result = 0;
  }
  return result;
}
// 100744B0: using guessed type int dword_100744B0;

//----- (10041C0C) --------------------------------------------------------
void __cdecl sub_10041C0C()
{
  signed int v0; // edi@3
  signed int v1; // esi@3
  LPCRITICAL_SECTION v2; // ebx@4

  if ( dword_100744B0 != -1 )
  {
    sub_100394CA(dword_100744B0);
    dword_100744B0 = -1;
  }
  v1 = (signed int)&lpCriticalSection;
  v0 = (signed int)&lpCriticalSection;
  do
  {
    v2 = *(LPCRITICAL_SECTION *)v0;
    if ( *(_DWORD *)v0 )
    {
      if ( *(_DWORD *)(v0 + 4) != 1 )
      {
        DeleteCriticalSection(*(LPCRITICAL_SECTION *)v0);
        sub_100309A2((int)v2, v2);
        *(_DWORD *)v0 = 0;
      }
    }
    v0 += 8;
  }
  while ( v0 < (signed int)&off_10074080 );
  do
  {
    if ( *(_DWORD *)v1 )
    {
      if ( *(_DWORD *)(v1 + 4) == 1 )
        DeleteCriticalSection(*(LPCRITICAL_SECTION *)v1);
    }
    v1 += 8;
  }
  while ( v1 < (signed int)&off_10074080 );
}
// 10074080: using guessed type wchar_t *off_10074080;
// 100744B0: using guessed type int dword_100744B0;

//----- (10041C29) --------------------------------------------------------
LONG __cdecl sub_10041C29(volatile LONG *lpAddend)
{
  volatile LONG *v1; // edi@1
  signed int v2; // eax@9
  volatile LONG **v3; // ebx@9
  signed int v5; // [sp+14h] [bp+8h]@9

  v1 = lpAddend;
  InterlockedIncrement(lpAddend);
  if ( lpAddend[30] )
    InterlockedIncrement((volatile LONG *)lpAddend[30]);
  if ( lpAddend[32] )
    InterlockedIncrement((volatile LONG *)lpAddend[32]);
  if ( lpAddend[31] )
    InterlockedIncrement((volatile LONG *)lpAddend[31]);
  if ( lpAddend[34] )
    InterlockedIncrement((volatile LONG *)lpAddend[34]);
  v2 = 6;
  v3 = (volatile LONG **)(lpAddend + 7);
  v5 = 6;
  do
  {
    if ( (_UNKNOWN *)*(v3 - 2) != &unk_100749D8 )
    {
      if ( *v3 )
      {
        InterlockedIncrement(*v3);
        v2 = v5;
      }
    }
    if ( *(v3 - 3) )
    {
      if ( *(v3 - 1) )
      {
        InterlockedIncrement(*(v3 - 1));
        v2 = v5;
      }
    }
    v3 += 4;
    --v2;
    v5 = v2;
  }
  while ( v2 );
  return InterlockedIncrement((volatile LONG *)(v1[39] + 176));
}

//----- (10041CB9) --------------------------------------------------------
void __cdecl sub_10041CB9(LPVOID lpMem)
{
  void **v1; // eax@1
  void *v2; // esi@1
  int v3; // eax@3
  int v4; // eax@5
  int v5; // eax@8
  int v6; // eax@12
  int v7; // eax@15
  signed int v8; // eax@18
  int v9; // ebx@18
  LPVOID *v10; // edi@18
  int v11; // eax@25
  signed int v12; // [sp+14h] [bp+8h]@18

  v2 = lpMem;
  v1 = (void **)*((_DWORD *)lpMem + 33);
  if ( v1 )
  {
    if ( v1 != &off_10073C58 )
    {
      v3 = *((_DWORD *)lpMem + 30);
      if ( v3 )
      {
        if ( !*(_DWORD *)v3 )
        {
          v4 = *((_DWORD *)lpMem + 32);
          if ( v4 )
          {
            if ( !*(_DWORD *)v4 )
            {
              sub_100309A2(0, *((LPVOID *)lpMem + 32));
              sub_1004D798(0, *((_DWORD *)lpMem + 33));
            }
          }
          v5 = *((_DWORD *)lpMem + 31);
          if ( v5 )
          {
            if ( !*(_DWORD *)v5 )
            {
              sub_100309A2(0, *((LPVOID *)lpMem + 31));
              sub_1004DC36(0, *((_DWORD *)lpMem + 33));
            }
          }
          sub_100309A2(0, *((LPVOID *)lpMem + 30));
          sub_100309A2(0, *((LPVOID *)lpMem + 33));
        }
      }
    }
  }
  v6 = *((_DWORD *)lpMem + 34);
  if ( v6 )
  {
    if ( !*(_DWORD *)v6 )
    {
      sub_100309A2(0, (LPVOID)(*((_DWORD *)lpMem + 35) - 254));
      sub_100309A2(0, (LPVOID)(*((_DWORD *)lpMem + 37) - 128));
      sub_100309A2(0, (LPVOID)(*((_DWORD *)lpMem + 38) - 128));
      sub_100309A2(0, *((LPVOID *)lpMem + 34));
    }
  }
  v7 = *((_DWORD *)lpMem + 39);
  if ( (void **)v7 != &off_100749E0 )
  {
    if ( !*(_DWORD *)(v7 + 176) )
    {
      sub_1004DEA5(0, *((_DWORD *)lpMem + 39));
      sub_100309A2(0, *((LPVOID *)lpMem + 39));
    }
  }
  v8 = 6;
  v9 = (int)((char *)lpMem + 160);
  v10 = (LPVOID *)((char *)lpMem + 28);
  v12 = 6;
  do
  {
    if ( *(v10 - 2) != &unk_100749D8 )
    {
      if ( *v10 )
      {
        if ( !*(_DWORD *)*v10 )
        {
          sub_100309A2(v9, *v10);
          sub_100309A2(v9, *(LPVOID *)v9);
        }
      }
      v8 = v12;
    }
    if ( *(v10 - 3) )
    {
      v11 = (int)*(v10 - 1);
      if ( v11 )
      {
        if ( !*(_DWORD *)v11 )
          sub_100309A2(v9, *(v10 - 1));
      }
      v8 = v12;
    }
    v9 += 4;
    v10 += 4;
    --v8;
    v12 = v8;
  }
  while ( v8 );
  sub_100309A2(v9, v2);
}
// 10073C58: using guessed type void *off_10073C58;
// 100749E0: using guessed type void *off_100749E0;

//----- (10041E13) --------------------------------------------------------
volatile LONG *__cdecl sub_10041E13(volatile LONG *lpAddend)
{
  volatile LONG *v1; // esi@1
  signed int v2; // eax@10
  volatile LONG **v3; // ebx@10
  signed int v5; // [sp+Ch] [bp+8h]@10

  v1 = lpAddend;
  if ( lpAddend )
  {
    InterlockedDecrement(lpAddend);
    if ( lpAddend[30] )
      InterlockedDecrement((volatile LONG *)lpAddend[30]);
    if ( lpAddend[32] )
      InterlockedDecrement((volatile LONG *)lpAddend[32]);
    if ( lpAddend[31] )
      InterlockedDecrement((volatile LONG *)lpAddend[31]);
    if ( lpAddend[34] )
      InterlockedDecrement((volatile LONG *)lpAddend[34]);
    v2 = 6;
    v3 = (volatile LONG **)(lpAddend + 7);
    v5 = 6;
    do
    {
      if ( (_UNKNOWN *)*(v3 - 2) != &unk_100749D8 )
      {
        if ( *v3 )
        {
          InterlockedDecrement(*v3);
          v2 = v5;
        }
      }
      if ( *(v3 - 3) )
      {
        if ( *(v3 - 1) )
        {
          InterlockedDecrement(*(v3 - 1));
          v2 = v5;
        }
      }
      v3 += 4;
      --v2;
      v5 = v2;
    }
    while ( v2 );
    InterlockedDecrement((volatile LONG *)(v1[39] + 176));
  }
  return v1;
}

//----- (10041EAE) --------------------------------------------------------
void __usercall sub_10041EAE(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // edx@1
  int v4; // esi@1
  int v5; // edx@3
  int v6; // ecx@3

  v2 = sub_10041A5C(a1, a2);
  v4 = v2;
  if ( dword_10074C0C & *(_DWORD *)(v2 + 112) && *(_DWORD *)(v2 + 108) )
  {
    if ( !*(_DWORD *)(sub_10041A5C(a1, a2) + 108) )
      sub_1003AF92(v5, v6, a1, a2, 32);
  }
  else
  {
    sub_10036A43(v3, dword_10074C0C, a1, a2, 12);
    sub_10041F2A((volatile LONG **)(v4 + 108), off_10074B44);
    sub_10036BA7(12);
  }
}
// 10074C0C: using guessed type int dword_10074C0C;

//----- (10041F2A) --------------------------------------------------------
volatile LONG *__cdecl sub_10041F2A(volatile LONG **a1, volatile LONG *lpAddend)
{
  volatile LONG *v2; // esi@3
  volatile LONG *result; // eax@8

  if ( lpAddend && a1 )
  {
    v2 = *a1;
    if ( *a1 != lpAddend )
    {
      *a1 = lpAddend;
      sub_10041C29(lpAddend);
      if ( v2 )
      {
        sub_10041E13(v2);
        if ( !*v2 )
        {
          if ( v2 != &dword_10074B48 )
            sub_10041CB9(v2);
        }
      }
    }
    result = lpAddend;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10041F75) --------------------------------------------------------
int __usercall sub_10041F75<eax>(int a1<ebx>)
{
  if ( !dword_10078AD0 )
  {
    sub_100422D5(a1, 0xFFFFFFFDu);
    dword_10078AD0 = 1;
  }
  return 0;
}
// 10078AD0: using guessed type int dword_10078AD0;

//----- (10041F93) --------------------------------------------------------
wchar_t *__cdecl sub_10041F93(int a1)
{
  wchar_t *result; // eax@5

  switch ( a1 )
  {
    case 932:
      result = off_100656F4[0];
      break;
    case 936:
      result = off_100656F8[0];
      break;
    case 949:
      result = off_100656FC[0];
      break;
    case 950:
      result = off_10065700;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 100656F4: using guessed type wchar_t *off_100656F4[4];
// 100656F8: using guessed type wchar_t *off_100656F8[3];
// 100656FC: using guessed type wchar_t *off_100656FC[2];
// 10065700: using guessed type wchar_t *off_10065700;

//----- (10041FCD) --------------------------------------------------------
UINT __usercall sub_10041FCD<eax>(int a1<ebx>, int a2<edi>, UINT a3)
{
  UINT result; // eax@1
  int v4; // [sp+0h] [bp-10h]@1
  int v5; // [sp+8h] [bp-8h]@8
  char v6; // [sp+Ch] [bp-4h]@7

  sub_1003018D((int)&v4, a1, a2, 0);
  result = a3;
  dword_10077044 = 0;
  switch ( a3 )
  {
    case 0xFFFFFFFEu:
      dword_10077044 = 1;
      result = GetOEMCP();
      break;
    case 0xFFFFFFFDu:
      dword_10077044 = 1;
      result = GetACP();
      break;
    case 0xFFFFFFFCu:
      dword_10077044 = 1;
      result = *(_DWORD *)(v4 + 4);
      break;
  }
  if ( v6 )
    *(_DWORD *)(v5 + 112) &= 0xFFFFFFFDu;
  return result;
}
// 10077044: using guessed type int dword_10077044;

//----- (10042039) --------------------------------------------------------
int __cdecl sub_10042039(int a1)
{
  int result; // eax@1
  signed int v2; // ecx@1
  char *v3; // edi@1
  int v4; // esi@1
  signed int v5; // edx@3
  int v6; // ecx@3

  v4 = a1 + 24;
  sub_10039210((void *)(a1 + 24), 0, 257);
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 540) = 0;
  result = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  v3 = (char *)&unk_100747B8 - a1;
  v2 = 257;
  do
  {
    *(_BYTE *)v4 = v3[v4];
    ++v4;
    --v2;
  }
  while ( v2 );
  v6 = a1 + 281;
  v5 = 256;
  do
  {
    LOBYTE(result) = v3[v6];
    *(_BYTE *)v6++ = result;
    --v5;
  }
  while ( v5 );
  return result;
}

//----- (100420A2) --------------------------------------------------------
char __cdecl sub_100420A2(int a1)
{
  unsigned int v1; // eax@2
  unsigned int i; // eax@4
  char *v3; // ecx@4
  unsigned int v4; // edx@5
  unsigned int v5; // ecx@11
  int v6; // eax@12
  int v7; // edx@20
  unsigned int v8; // ecx@20
  int v9; // edx@21
  int v10; // eax@22
  struct _cpinfo CPInfo; // [sp+14h] [bp-518h]@1
  WORD CharType[256]; // [sp+28h] [bp-504h]@11
  char v14[256]; // [sp+228h] [bp-304h]@11
  _BYTE DestStr[256]; // [sp+328h] [bp-204h]@11
  const CHAR MultiByteStr[256]; // [sp+428h] [bp-104h]@3
  unsigned int v17; // [sp+528h] [bp-4h]@1
  int v18; // [sp+52Ch] [bp+0h]@1

  v17 = (unsigned int)&v18 ^ __security_cookie;
  if ( GetCPInfo(*(_DWORD *)(a1 + 4), &CPInfo) )
  {
    v1 = 0;
    do
    {
      MultiByteStr[v1] = v1;
      ++v1;
    }
    while ( v1 < 0x100 );
    LOBYTE(i) = CPInfo.LeadByte[0];
    MultiByteStr[0] = 32;
    v3 = (char *)CPInfo.LeadByte;
    while ( (_BYTE)i )
    {
      v4 = (unsigned __int8)v3[1];
      for ( i = (unsigned __int8)i; i <= v4 && i < 0x100; ++i )
        MultiByteStr[i] = 32;
      v3 += 2;
      LOBYTE(i) = *v3;
    }
    sub_10049218(0, 256, 0, 1u, MultiByteStr, 256, CharType, *(_DWORD *)(a1 + 4), 0);
    sub_100374C2(
      0,
      256,
      0,
      *(_DWORD *)(a1 + 540),
      0x100u,
      MultiByteStr,
      256,
      (LPWSTR)DestStr,
      256,
      *(_DWORD *)(a1 + 4),
      0);
    sub_100374C2(0, 256, 0, *(_DWORD *)(a1 + 540), 0x200u, MultiByteStr, 256, (LPWSTR)v14, 256, *(_DWORD *)(a1 + 4), 0);
    v5 = 0;
    while ( 1 )
    {
      LOWORD(v6) = CharType[v5];
      if ( v6 & 1 )
      {
        *(_BYTE *)(a1 + v5 + 25) |= 0x10u;
        LOBYTE(v6) = DestStr[v5];
      }
      else
      {
        if ( !(v6 & 2) )
        {
          *(_BYTE *)(a1 + v5 + 281) = 0;
          goto LABEL_18;
        }
        *(_BYTE *)(a1 + v5 + 25) |= 0x20u;
        LOBYTE(v6) = v14[v5];
      }
      *(_BYTE *)(a1 + v5 + 281) = v6;
LABEL_18:
      ++v5;
      if ( v5 >= 0x100 )
        return v6;
    }
  }
  v7 = a1 + 281;
  v6 = -97 - (a1 + 281);
  v8 = 0;
  do
  {
    v9 = v8 + v7;
    if ( (unsigned int)(v9 + v6 + 32) <= 0x19 )
    {
      *(_BYTE *)(a1 + v8 + 25) |= 0x10u;
      v10 = v8 + 32;
LABEL_25:
      *(_BYTE *)v9 = v10;
      goto LABEL_27;
    }
    if ( (unsigned int)(v9 + v6) <= 0x19 )
    {
      *(_BYTE *)(a1 + v8 + 25) |= 0x20u;
      v10 = v8 - 32;
      goto LABEL_25;
    }
    *(_BYTE *)v9 = 0;
LABEL_27:
    v6 = -97 - (a1 + 281);
    ++v8;
    v7 = a1 + 281;
  }
  while ( v8 < 0x100 );
  return v6;
}
// 10074200: using guessed type int __security_cookie;
// 100420A2: using guessed type const CHAR MultiByteStr[256];
// 100420A2: using guessed type WORD CharType[256];
// 100420A2: using guessed type char var_304[256];

//----- (10042230) --------------------------------------------------------
void __usercall sub_10042230(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  void *v5; // esi@6

  v2 = sub_10041A5C(a1, a2);
  v4 = v2;
  if ( dword_10074C0C & *(_DWORD *)(v2 + 112) && *(_DWORD *)(v2 + 108) )
  {
    if ( !*(_DWORD *)(v2 + 104) )
      sub_1003AF92(v3, dword_10074C0C, a1, v2, 32);
  }
  else
  {
    sub_10036A43(v3, dword_10074C0C, a1, v2, 13);
    v5 = *(void **)(v4 + 104);
    if ( v5 != lpAddend )
    {
      if ( v5 )
      {
        if ( !InterlockedDecrement((volatile LONG *)v5) )
        {
          if ( v5 != &unk_100747B8 )
            sub_100309A2(a1, v5);
        }
      }
      *(_DWORD *)(v4 + 104) = lpAddend;
      InterlockedIncrement((volatile LONG *)lpAddend);
    }
    sub_10036BA7(13);
  }
}
// 10074C0C: using guessed type int dword_10074C0C;

//----- (100422D5) --------------------------------------------------------
void __usercall sub_100422D5(int a1<ebx>, UINT a2)
{
  int v2; // edx@1
  int v3; // ebx@1
  int v4; // esi@1
  int v5; // eax@2
  int v6; // ebx@2
  signed int v7; // eax@3
  int v8; // edi@3
  signed int v9; // esi@3
  int v10; // eax@4
  char v11; // zf@4
  int v12; // edx@7
  int v13; // ecx@7
  signed int i; // ecx@9
  signed int j; // ecx@12
  int v16; // [sp-4h] [bp-34h]@1
  int v17; // [sp+14h] [bp-1Ch]@1
  UINT v18; // [sp+38h] [bp+8h]@1

  v3 = sub_10041A5C(a1, -1);
  v17 = v3;
  sub_10042230(v3, -1);
  v4 = *(_DWORD *)(v3 + 104);
  v18 = sub_10041FCD(v3, -1, a2);
  if ( v18 != *(_DWORD *)(v4 + 4) )
  {
    v5 = sub_10037550(v2, v16, v3, 544);
    v6 = v5;
    if ( v5 )
    {
      memcpy((void *)v5, *(const void **)(v17 + 104), 0x220u);
      v9 = 0;
      *(_DWORD *)v5 = 0;
      v7 = sub_10042483(v5, v5 + 544, v18, v5);
      v8 = v7;
      if ( v7 )
      {
        if ( v7 == -1 )
        {
          if ( (_UNKNOWN *)v6 != &unk_100747B8 )
            sub_100309A2(v6, (LPVOID)v6);
          *(_DWORD *)sub_10037669(v6) = 22;
        }
      }
      else
      {
        v11 = InterlockedDecrement(*(volatile LONG **)(v17 + 104)) == 0;
        v10 = v17;
        if ( v11 )
        {
          if ( *(_UNKNOWN **)(v17 + 104) != &unk_100747B8 )
          {
            sub_100309A2(v6, *(LPVOID *)(v17 + 104));
            v10 = v17;
          }
        }
        *(_DWORD *)(v10 + 104) = v6;
        InterlockedIncrement((volatile LONG *)v6);
        if ( !(*(_BYTE *)(v17 + 112) & 2) )
        {
          if ( !(dword_10074C0C & 1) )
          {
            sub_10036A43(v12, v13, v6, v8, 13);
            dword_10077030 = *(_DWORD *)(v6 + 4);
            dword_10077034 = *(_DWORD *)(v6 + 8);
            dword_1007702C = *(_DWORD *)(v6 + 540);
            for ( i = 0; i < 5; ++i )
              word_10077038[i] = *(_WORD *)(v6 + 2 * i + 12);
            for ( j = 0; j < 257; ++j )
              byte_100745B0[j] = *(_BYTE *)(j + v6 + 24);
            while ( v9 < 256 )
            {
              byte_100746B8[v9] = *(_BYTE *)(v9 + v6 + 281);
              ++v9;
            }
            if ( !InterlockedDecrement((volatile LONG *)lpAddend) )
            {
              if ( lpAddend != &unk_100747B8 )
                sub_100309A2(v6, lpAddend);
            }
            lpAddend = (LPVOID)v6;
            InterlockedIncrement((volatile LONG *)v6);
            sub_10036BA7(13);
          }
        }
      }
    }
  }
}
// 10074C0C: using guessed type int dword_10074C0C;
// 1007702C: using guessed type int dword_1007702C;
// 10077030: using guessed type int dword_10077030;
// 10077034: using guessed type int dword_10077034;
// 10077038: using guessed type __int16 word_10077038[];

//----- (10042483) --------------------------------------------------------
signed int __usercall sub_10042483<eax>(int a1<ebx>, int a2<edi>, UINT a3, int a4)
{
  UINT v4; // ebx@1
  signed int result; // eax@2
  unsigned int v6; // eax@3
  int v7; // ecx@3
  unsigned int v8; // edi@3
  char *v9; // eax@11
  unsigned int v10; // edx@12
  unsigned int v11; // ecx@13
  int v12; // eax@17
  signed int v13; // ecx@17
  char *v14; // eax@25
  char *v15; // ecx@26
  unsigned int v16; // eax@27
  unsigned int v17; // ebx@28
  char *v18; // edx@35
  int v19; // ecx@35
  signed int v20; // edi@35
  int v21; // edx@35
  int v22; // [sp+8h] [bp-20h]@1
  int v23; // [sp+Ch] [bp-1Ch]@3
  char *v24; // [sp+Ch] [bp-1Ch]@25
  struct _cpinfo CPInfo; // [sp+10h] [bp-18h]@9
  unsigned int v26; // [sp+24h] [bp-4h]@1
  int v27; // [sp+28h] [bp+0h]@1

  v26 = (unsigned int)&v27 ^ __security_cookie;
  v4 = sub_10041FCD(a1, a2, a3);
  v22 = v4;
  if ( v4 )
  {
    v8 = 0;
    v7 = 0;
    v23 = 0;
    v6 = 0;
    while ( *(int *)((char *)&dword_100744C0 + v6) != v4 )
    {
      ++v7;
      v6 += 48;
      v23 = v7;
      if ( v6 >= 0xF0 )
      {
        if ( v4 == 65000 || v4 == 65001 || !IsValidCodePage((unsigned __int16)v4) )
          return -1;
        if ( GetCPInfo(v4, &CPInfo) )
        {
          sub_10039210((void *)(a4 + 24), 0, 257);
          *(_DWORD *)(a4 + 4) = v4;
          *(_DWORD *)(a4 + 540) = 0;
          if ( (_DWORD)CPInfo.MaxCharSize <= 1u )
          {
            *(_DWORD *)(a4 + 8) = 0;
          }
          else
          {
            v9 = (char *)CPInfo.LeadByte;
            if ( CPInfo.LeadByte[0] )
            {
              do
              {
                LOBYTE(v10) = v9[1];
                if ( !(_BYTE)v10 )
                  break;
                v11 = (unsigned __int8)*v9;
                v10 = (unsigned __int8)v10;
                while ( v11 <= v10 )
                  *(_BYTE *)(a4 + v11++ + 25) |= 4u;
                v9 += 2;
              }
              while ( *v9 );
            }
            v12 = a4 + 26;
            v13 = 254;
            do
            {
              *(_BYTE *)v12++ |= 8u;
              --v13;
            }
            while ( v13 );
            *(_DWORD *)(a4 + 540) = sub_10041F93(*(_DWORD *)(a4 + 4));
            *(_DWORD *)(a4 + 8) = 1;
          }
          *(_DWORD *)(a4 + 12) = 0;
          *(_DWORD *)(a4 + 16) = 0;
          *(_DWORD *)(a4 + 20) = 0;
          goto LABEL_37;
        }
        if ( !dword_10077044 )
          return -1;
        sub_10042039(a4);
        goto LABEL_38;
      }
    }
    sub_10039210((void *)(a4 + 24), 0, 257);
    v14 = &aJ[48 * v23];
    v24 = &aJ[48 * v23];
    do
    {
      v15 = v14;
      if ( *v14 )
      {
        do
        {
          LOBYTE(v16) = v15[1];
          if ( !(_BYTE)v16 )
            break;
          v17 = (unsigned __int8)*v15;
          v16 = (unsigned __int8)v16;
          while ( v17 <= v16 && v17 < 0x100 )
          {
            *(_BYTE *)(a4 + v17 + 25) |= byte_100744BC[v8];
            v16 = (unsigned __int8)v15[1];
            ++v17;
          }
          v15 += 2;
        }
        while ( *v15 );
        v14 = v24;
      }
      ++v8;
      v14 += 8;
      v24 = v14;
    }
    while ( v8 < 4 );
    *(_DWORD *)(a4 + 4) = v22;
    *(_DWORD *)(a4 + 8) = 1;
    *(_DWORD *)(a4 + 540) = sub_10041F93(v22);
    v19 = a4 + 12;
    v18 = &aVyv[v21];
    v20 = 6;
    do
    {
      *(_WORD *)v19 = *(_WORD *)v18;
      v18 += 2;
      v19 += 2;
      --v20;
    }
    while ( v20 );
LABEL_37:
    sub_100420A2(a4);
LABEL_38:
    result = 0;
  }
  else
  {
    sub_10042039(a4);
    result = 0;
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 100744C0: using guessed type int dword_100744C0;
// 10077044: using guessed type int dword_10077044;

//----- (10042678) --------------------------------------------------------
int __usercall sub_10042678<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // eax@2
  int v7; // ecx@4
  int result; // eax@9
  int v9; // [sp+4h] [bp-18h]@1
  int v10; // [sp+Ch] [bp-10h]@8
  char v11; // [sp+10h] [bp-Ch]@7
  const CHAR MultiByteStr; // [sp+14h] [bp-8h]@4
  char v13; // [sp+15h] [bp-7h]@4
  char v14; // [sp+16h] [bp-6h]@4
  WORD CharType; // [sp+18h] [bp-4h]@6
  signed int v16; // [sp+24h] [bp+8h]@3

  sub_1003018D((int)&v9, a1, a2, a5);
  v5 = a3;
  if ( (unsigned int)(a3 + 1) <= 0x100 )
  {
    v6 = *(_WORD *)(*(_DWORD *)(v9 + 144) + 2 * a3);
    goto LABEL_11;
  }
  v16 = a3 >> 8;
  if ( sub_10042727(v5, a2, BYTE1(v5), (int)&v9) )
  {
    MultiByteStr = v16;
    v13 = v5;
    v14 = 0;
    v7 = 2;
  }
  else
  {
    MultiByteStr = v5;
    v13 = 0;
    v7 = 1;
  }
  if ( sub_10049218(v5, a2, (int)&v9, 1u, &MultiByteStr, v7, &CharType, *(_DWORD *)(v9 + 4), 1) )
  {
    v6 = CharType;
LABEL_11:
    result = a4 & v6;
    if ( v11 )
      *(_DWORD *)(v10 + 112) &= 0xFFFFFFFDu;
    return result;
  }
  if ( v11 )
    *(_DWORD *)(v10 + 112) &= 0xFFFFFFFDu;
  return 0;
}

//----- (10042727) --------------------------------------------------------
int __usercall sub_10042727<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3, int a4)
{
  int result; // eax@1
  int v5; // [sp+0h] [bp-10h]@1
  int v6; // [sp+8h] [bp-8h]@2
  char v7; // [sp+Ch] [bp-4h]@1

  sub_1003018D((int)&v5, a1, a2, a4);
  result = *(_WORD *)(*(_DWORD *)(v5 + 144) + 2 * a3) & 0x8000;
  if ( v7 )
    *(_DWORD *)(v6 + 112) &= 0xFFFFFFFDu;
  return result;
}

//----- (1004275D) --------------------------------------------------------
int __usercall sub_1004275D<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3)
{
  return sub_10042727(a1, a2, a3, 0);
}

//----- (1004276E) --------------------------------------------------------
void __usercall sub_1004276E(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  if ( off_10074B44 != &dword_10074B48 )
  {
    sub_10036A43(a1, a2, a3, a4, 12);
    off_10074B44 = sub_10041F2A(&off_10074B44, &dword_10074B48);
    sub_10036BA7(12);
  }
}

//----- (100427C0) --------------------------------------------------------
int __cdecl sub_100427C0(int a1)
{
  int result; // eax@2
  int v2; // edx@3
  int v3; // ebx@3
  int v4; // edi@5
  int v5; // [sp-8h] [bp-8h]@3

  if ( a1 )
  {
    v3 = sub_1004AC57(a1, 0x55u);
    if ( (unsigned int)v3 < 0x55 )
    {
      result = sub_10037550(v2, v5, v3, 2 * v3 + 2);
      v4 = result;
      if ( result )
      {
        if ( sub_10044A99(v3, result, result, v3 + 1, a1, v3 + 1) )
        {
          sub_1003A17E(v3, v4);
          __asm { int     3               ; Trap to Debugger }
          JUMPOUT(*(int *)sub_10042824);
        }
        result = v4;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10042824) --------------------------------------------------------
void __usercall sub_10042824(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6)
{
  int v6; // edx@1
  int v7; // ecx@1

  if ( sub_100490D0(a1, a2, a3, a6, a4, a5, a6) )
  {
    sub_1003A17E(a3, a6);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10042892);
  }
  if ( *(_WORD *)(a6 + 128) )
    sub_10042CDD(v7, v6, a4, a5, 2);
  if ( *(_WORD *)(a6 + 256) )
    sub_10042CDD(v7, v6, a4, a5, 2);
}
// 10042892: using guessed type int __cdecl sub_10042892(int, int);

//----- (10042892) --------------------------------------------------------
signed int __cdecl sub_10042892(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // esi@1
  int v5; // eax@8
  int v6; // eax@16
  int v7; // [sp-10h] [bp-20h]@12
  int v8; // [sp-Ch] [bp-1Ch]@12
  int v9; // [sp-8h] [bp-18h]@12
  int v10; // [sp-4h] [bp-14h]@12
  int v11; // [sp+Ch] [bp-4h]@9
  int i; // [sp+1Ch] [bp+Ch]@7

  v2 = 0;
  sub_10039210((void *)a1, 0, 458);
  v3 = a2;
  if ( !*(_WORD *)a2 )
    return 0;
  if ( *(_WORD *)a2 == 46 && *(_WORD *)(a2 + 2) )
  {
    if ( sub_10044A99(0, a1, a1 + 256, 16, a2 + 2, 15) )
    {
LABEL_30:
      sub_1003A17E(v2, a1);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_100429BC);
    }
    *(_WORD *)(a1 + 286) = 0;
    return 0;
  }
  for ( i = 0; ; ++i )
  {
    v5 = sub_1004EB22(v3, (int)L"_.,");
    if ( !v5 )
      break;
    v11 = v3 + 2 * v5;
    v2 = *(_WORD *)v11;
    if ( i )
    {
      if ( i == 1 )
      {
        if ( (unsigned int)v5 >= 0x40 || v2 == 95 )
          return -1;
        v10 = v5;
        v9 = v3;
        v8 = 64;
        v6 = a1 + 128;
      }
      else
      {
        if ( i != 2 || (unsigned int)v5 >= 0x10 || (_WORD)v2 && (_WORD)v2 != 44 )
          return -1;
        v10 = v5;
        v9 = v3;
        v8 = 16;
        v6 = a1 + 256;
      }
      v7 = v6;
    }
    else
    {
      if ( (unsigned int)v5 >= 0x40 || (_WORD)v2 == 46 )
        return -1;
      v10 = v5;
      v9 = v3;
      v8 = 64;
      v7 = a1;
    }
    if ( sub_10044A99(v2, a1, v7, v8, v9, v10) )
      goto LABEL_30;
    if ( (_WORD)v2 == 44 || !(_WORD)v2 )
      return 0;
    v3 = v11 + 2;
  }
  return -1;
}
// 10042892: using guessed type int __cdecl sub_10042892(int, int);
// 10065BB4: using guessed type wchar_t a__[4];

//----- (100429BC) --------------------------------------------------------
void __cdecl sub_100429BC(void *lpAddend, const void *a2)
{
  if ( a2 )
  {
    if ( lpAddend )
    {
      if ( lpAddend != a2 )
      {
        memcpy(lpAddend, a2, 0xB8u);
        *(_DWORD *)lpAddend = 0;
        sub_10041C29((volatile LONG *)lpAddend);
      }
    }
  }
}

//----- (100429E8) --------------------------------------------------------
int __cdecl sub_100429E8(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int v7; // ebx@1
  int v8; // edi@1
  signed int v10; // eax@4
  int v11; // edx@4
  int v12; // ecx@4
  signed int v13; // eax@7
  int v14; // edx@12
  int v15; // ecx@12
  int v16; // eax@12
  int v17; // ST10_4@12
  int v18; // eax@13
  int v19; // ST10_4@13
  int v20; // edi@14
  char v21; // zf@15
  signed int v22; // eax@16
  int v24; // ecx@16
  int v25; // eax@20
  UINT v26; // eax@25
  int v27; // eax@41
  int v28; // [sp+14h] [bp-1E8h]@4
  int v29; // [sp+18h] [bp-1E4h]@11
  int v30; // [sp+1Ch] [bp-1E0h]@1
  UINT v31; // [sp+20h] [bp-1DCh]@1
  int v32; // [sp+24h] [bp-1D8h]@1
  int v33; // [sp+28h] [bp-1D4h]@1
  char v34; // [sp+2Ch] [bp-1D0h]@14
  char v35; // [sp+14Ch] [bp-B0h]@20
  unsigned int v36; // [sp+1F8h] [bp-4h]@1
  int v37; // [sp+1FCh] [bp+0h]@1

  v36 = (unsigned int)&v37 ^ __security_cookie;
  v7 = a4;
  v8 = a6;
  v6 = sub_10041A5C(a4, a6);
  v32 = v6 + 180;
  v30 = v6 + 184;
  v33 = v6 + 446;
  v31 = 0;
  if ( !a1 )
    return 0;
  v28 = v6 + 748;
  v10 = sub_10044A99(a4, a6, a4, a5, v6 + 748, 85);
  if ( v10 )
    goto LABEL_43;
  if ( *(_WORD *)a1 != 67 || *(_WORD *)(a1 + 2) != (_WORD)v10 )
  {
    v29 = sub_100398B9(a1);
    if ( (unsigned int)v29 < 0x83 )
    {
      v16 = sub_1004EAE4(v33, a1);
      v15 = v17;
      if ( !v16 || (v18 = sub_1004EAE4(v30, a1), v15 = v19, !v18) )
      {
LABEL_37:
        if ( v8 )
          sub_10034F00((void *)v8, (const void *)v32, 4u);
        v7 = v33;
        if ( !sub_100490D0(v14, v15, v33, v8, a2, a3, v33) )
          return v7;
LABEL_43:
        sub_1003A17E(v7, v8);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_10042CDD);
      }
    }
    v20 = __security_cookie == dword_10078B34 ? 1 : 0;
    if ( sub_10042892((int)&v34, a1) )
    {
      v8 = v32;
    }
    else
    {
      v21 = v20 == 0;
      v8 = v32;
      if ( v21 )
        v22 = sub_1004F0FE(a4, v32, (int)&v34, v32, (int)&v34);
      else
        v22 = sub_1004F94A(a4, v32, (int)&v34, v32, (int)&v34);
      if ( v22 )
      {
        v8 = 131;
        sub_10042824(v14, v24, a4, v33, 131, (int)&v34);
        if ( a4 )
        {
          v25 = sub_100398B9((int)&v35);
          if ( sub_10044A99(a4, 131, a4, a5, (int)&v35, v25 + 1) )
            goto LABEL_43;
        }
LABEL_31:
        v7 = 0;
        if ( *(_WORD *)a1 && v29 < (unsigned int)v8 )
        {
          if ( sub_10044A99(0, v8, v30, v8, a1, v29 + 1) )
            goto LABEL_43;
        }
        else
        {
          v15 = 0;
          *(_WORD *)v30 = 0;
        }
        v8 = a6;
        goto LABEL_37;
      }
    }
    if ( !sub_10039D08(a1) )
    {
      v27 = sub_100398B9(a4);
      if ( !sub_10044A99(a4, v8, v28, 85, a4, v27 + 1) )
        return 0;
      goto LABEL_43;
    }
    if ( !sub_10039CAE(a1, 0x20001004u, (WCHAR *)&v31, 2) || (LOWORD(v26) = v31, !v31) )
    {
      v26 = GetACP();
      v31 = v26;
    }
    *(_DWORD *)v8 = (unsigned __int16)v26;
    v8 = v29 + 1;
    if ( sub_10044A99(a4, v29 + 1, v33, 131, a1, v29 + 1)
      || sub_10044A99(a4, v8, a4, a5, a1, v8)
      || sub_10044A99(a4, v8, v28, 85, a1, v8) )
      goto LABEL_43;
    v8 = 131;
    goto LABEL_31;
  }
  v13 = sub_100490D0(v11, v12, a4, a6, a2, a3, (int)L"C");
  if ( v13 )
    goto LABEL_43;
  if ( a6 )
    *(_DWORD *)a6 = v13;
  return a2;
}
// 10042892: using guessed type int __cdecl sub_10042892(int, int);
// 10065BB0: using guessed type wchar_t aC[2];
// 10074200: using guessed type int __security_cookie;
// 10078B34: using guessed type int dword_10078B34;

//----- (10042CDD) --------------------------------------------------------
void __fastcall sub_10042CDD(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  int *v6; // edi@2

  v5 = 0;
  if ( a5 > 0 )
  {
    v6 = &a5;
    do
    {
      ++v6;
      if ( sub_1004D31B(a2, a1, 0, a3, a4, *v6) )
      {
        sub_1003A17E(0, (int)v6);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_10042D1C);
      }
      ++v5;
    }
    while ( v5 < a5 );
  }
}

//----- (10042D1C) --------------------------------------------------------
void __usercall sub_10042D1C(int a1<edi>, unsigned int a2, int a3)
{
  int v3; // eax@3
  int v4; // edx@3
  void *v5; // edi@3
  int v6; // esi@3
  int v7; // ecx@3
  int v8; // [sp-4h] [bp-38h]@3

  if ( a2 <= 5 )
  {
    v6 = sub_10041A5C(0, a1);
    sub_10041EAE(0, a1);
    *(_DWORD *)(v6 + 112) |= 0x10u;
    v3 = (int)sub_10037506(v7, 0, 0xB8u, 1u);
    v5 = (void *)v3;
    if ( v3 )
    {
      sub_10036A43(v4, v8, 0, v3, 12);
      sub_100429BC(v5, *(const void **)(v6 + 108));
      sub_10036BA7(12);
    }
    else
    {
      *(_DWORD *)(v6 + 112) &= 0xFFFFFFEFu;
    }
  }
  else
  {
    *(_DWORD *)sub_10037669(0) = 22;
    sub_1003A16E(0, a1);
  }
}

//----- (10042E99) --------------------------------------------------------
int __usercall sub_10042E99<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int result; // eax@1
  int v5; // edx@1
  int v6; // ebx@1
  int v7; // edx@2
  int v8; // ecx@2
  int v9; // esi@2
  int v10; // [sp-4h] [bp-18h]@1
  int v11; // [sp+8h] [bp-Ch]@2
  signed int v12; // [sp+Ch] [bp-8h]@1
  signed int v13; // [sp+10h] [bp-4h]@2

  v12 = 1;
  v6 = sub_10037550(a1, a2, a3, 1702);
  result = 0;
  if ( v6 )
  {
    v9 = v6 + 4;
    *(_WORD *)(v6 + 4) = 0;
    *(_DWORD *)v6 = 1;
    sub_10042CDD(v10, v5, v6 + 4, 849, 3);
    v13 = (signed int)&off_10065A64;
    v11 = a4 + 36;
    do
    {
      if ( sub_1004D31B(v7, v8, v6, v9, 849, (int)L";") )
      {
        sub_1003A17E(v6, a4);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_1004300D);
      }
      v12 = sub_1004EAE4(*(_DWORD *)v11, *(_DWORD *)(v11 + 16)) == 0 ? v12 : 0;
      v9 = v6 + 4;
      v11 += 16;
      v13 += 12;
      sub_10042CDD(v11, v7, v6 + 4, 849, 3);
    }
    while ( v13 < (signed int)&off_10065A94 );
    if ( v12 )
    {
      sub_100309A2(v6, (LPVOID)v6);
      if ( *(_DWORD *)(a4 + 28) )
      {
        if ( !InterlockedDecrement(*(volatile LONG **)(a4 + 28)) )
          sub_100309A2(v6, *(LPVOID *)(a4 + 28));
      }
      if ( *(_DWORD *)(a4 + 24) )
      {
        if ( !InterlockedDecrement(*(volatile LONG **)(a4 + 24)) )
          sub_100309A2(v6, *(LPVOID *)(a4 + 24));
      }
      result = *(_DWORD *)(a4 + 52);
      *(_DWORD *)(a4 + 24) = 0;
      *(_DWORD *)(a4 + 16) = 0;
      *(_DWORD *)(a4 + 28) = 0;
      *(_DWORD *)(a4 + 20) = 0;
    }
    else
    {
      if ( *(_DWORD *)(a4 + 28) )
      {
        if ( !InterlockedDecrement(*(volatile LONG **)(a4 + 28)) )
          sub_100309A2(v6, *(LPVOID *)(a4 + 28));
      }
      if ( *(_DWORD *)(a4 + 24) )
      {
        if ( !InterlockedDecrement(*(volatile LONG **)(a4 + 24)) )
          sub_100309A2(v6, *(LPVOID *)(a4 + 24));
      }
      *(_DWORD *)(a4 + 24) = 0;
      *(_DWORD *)(a4 + 16) = 0;
      *(_DWORD *)(a4 + 28) = v6;
      *(_DWORD *)(a4 + 20) = v9;
      result = v6 + 4;
    }
  }
  return result;
}
// 10065A64: using guessed type wchar_t *off_10065A64;
// 10065A94: using guessed type wchar_t *off_10065A94;
// 10065BA8: using guessed type wchar_t asc_10065BA8[2];

//----- (1004300D) --------------------------------------------------------
int __fastcall sub_1004300D(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // edi@1
  int v6; // esi@1
  int result; // eax@3
  int v8; // ebx@5
  int v9; // eax@9
  int *v10; // ebx@12
  int v11; // eax@16
  int v12; // esi@16
  int v13; // ST14_4@16
  char v14; // zf@21
  int v15; // esi@23
  int *v16; // eax@29
  int v17; // esi@29
  char v18; // zf@32
  int v19; // [sp+10h] [bp-1C8h]@9
  int v20; // [sp+14h] [bp-1C4h]@5
  signed int v21; // [sp+18h] [bp-1C0h]@5
  int v22; // [sp+18h] [bp-1C0h]@12
  int v23; // [sp+1Ch] [bp-1BCh]@12
  int v24; // [sp+1Ch] [bp-1BCh]@16
  int v25; // [sp+1Ch] [bp-1BCh]@29
  char v26; // [sp+20h] [bp-1B8h]@28
  __int16 v27[132]; // [sp+CCh] [bp-10Ch]@19
  unsigned int v28; // [sp+1D4h] [bp-4h]@1
  int v29; // [sp+1D8h] [bp+0h]@1

  v28 = (unsigned int)&v29 ^ __security_cookie;
  v6 = a5;
  v5 = a3;
  if ( !a4 )
  {
    v8 = 0;
    v21 = 1;
    v20 = 0;
    if ( !a5 )
      return sub_10042E99(a2, a1, v8, v5);
    if ( *(_WORD *)a5 == 76 && *(_WORD *)(a5 + 2) == 67 && *(_WORD *)(a5 + 4) == 95 )
    {
      while ( 1 )
      {
        v9 = sub_1004EBA7(v6, (int)L"=;");
        v19 = v9;
        if ( !v9 )
          return 0;
        if ( !((v9 - v6) >> 1) )
          return 0;
        if ( *(_WORD *)v9 == 59 )
          return 0;
        v23 = (v9 - v6) >> 1;
        v22 = 1;
        v10 = (int *)&off_10065A64;
        do
        {
          if ( !sub_1004EB71(*v10, v6, v23) && v23 == sub_100398B9(*v10) )
            break;
          ++v22;
          v10 += 3;
        }
        while ( (signed int)v10 <= (signed int)&off_10065A94 );
        v12 = v19 + 2;
        v11 = sub_1004EB22(v19 + 2, (int)L";");
        v5 = a3;
        v8 = v20;
        a1 = v13;
        v24 = v11;
        if ( !v11 )
        {
          a1 = 59;
          if ( *(_WORD *)v12 != 59 )
            return 0;
        }
        if ( v22 <= 5 )
        {
          if ( sub_10044A99(v20, a3, (int)v27, 131, v12, v11) )
            goto LABEL_43;
          if ( (unsigned int)(2 * v24) >= 0x106 )
          {
            sub_1003078B(v20, a3, v12);
LABEL_43:
            sub_1003A17E(v20, a3);
            __asm { int     3               ; Trap to Debugger }
            JUMPOUT(*(int *)sub_10043294);
          }
          v27[v24] = 0;
          v14 = sub_10043294(a3, v22, (int)v27) == 0;
          v11 = v24;
          if ( !v14 )
            v8 = v20++ + 1;
        }
        v15 = v12 + 2 * v11;
        result = 0;
        if ( *(_WORD *)v15 )
        {
          v6 = v15 + 2;
          if ( *(_WORD *)v6 )
            continue;
        }
        if ( v8 )
          return sub_10042E99(a2, a1, v8, v5);
        return result;
      }
    }
    result = sub_100429E8(a5, (int)v27, 131, (int)&v26, 85, 0);
    if ( !result )
      return result;
    v16 = (int *)(a3 + 20);
    v17 = 0;
    v25 = a3 + 20;
    while ( 1 )
    {
      if ( !v17 )
        goto LABEL_36;
      if ( !sub_1004EAE4((int)v27, *v16) )
      {
        v16 = (int *)v25;
LABEL_35:
        ++v8;
LABEL_36:
        a1 = v21;
        goto LABEL_37;
      }
      v18 = sub_10043294(a3, v17, (int)v27) == 0;
      v16 = (int *)v25;
      if ( !v18 )
        goto LABEL_35;
      a1 = 0;
      v21 = 0;
LABEL_37:
      ++v17;
      v16 += 4;
      v25 = (int)v16;
      if ( v17 > 5 )
      {
        if ( a1 || v8 )
          return sub_10042E99(a2, a1, v8, v5);
        return 0;
      }
    }
  }
  if ( a5 )
    result = sub_10043294(a3, a4, a5);
  else
    result = *(_DWORD *)(a3 + 16 * a4 + 20);
  return result;
}
// 10065A64: using guessed type wchar_t *off_10065A64;
// 10065A94: using guessed type wchar_t *off_10065A94;
// 10065BA0: using guessed type wchar_t asc_10065BA0[3];
// 10065BA8: using guessed type wchar_t asc_10065BA8[2];
// 10074200: using guessed type int __security_cookie;
// 1004300D: using guessed type __int16 var_10C[132];

//----- (10043294) --------------------------------------------------------
int __cdecl sub_10043294(int a1, int a2, int a3)
{
  int v4; // ebx@4
  int v5; // eax@6
  int v6; // edx@6
  int v7; // esi@6
  int v8; // eax@6
  char v9; // zf@8
  int v10; // edx@12
  int v11; // ecx@13
  int v12; // edx@15
  int v13; // eax@15
  int v14; // ecx@15
  int v15; // ebx@15
  int v16; // eax@16
  int v17; // ecx@16
  unsigned int v18; // eax@19
  int v19; // eax@21
  int v20; // ebx@32
  int v21; // eax@35
  LPVOID v22; // [sp+Ch] [bp-2ECh]@7
  int v23; // [sp+10h] [bp-2E8h]@7
  _UNKNOWN *v24; // [sp+18h] [bp-2E0h]@7
  void *v25; // [sp+1Ch] [bp-2DCh]@6
  int v26; // [sp+20h] [bp-2D8h]@13
  int v27; // [sp+24h] [bp-2D4h]@1
  int v28; // [sp+28h] [bp-2D0h]@7
  int v29; // [sp+2Ch] [bp-2CCh]@1
  int v30; // [sp+30h] [bp-2C8h]@13
  int v31; // [sp+34h] [bp-2C4h]@7
  int v32; // [sp+38h] [bp-2C0h]@1
  int v33; // [sp+3Ch] [bp-2BCh]@13
  char v34; // [sp+40h] [bp-2B8h]@1
  WORD CharType[128]; // [sp+ECh] [bp-20Ch]@18
  __int16 v36; // [sp+1ECh] [bp-10Ch]@1
  __int16 v37; // [sp+1EEh] [bp-10Ah]@9
  unsigned int v38; // [sp+2F4h] [bp-4h]@1
  int v39; // [sp+2F8h] [bp+0h]@1

  v38 = (unsigned int)&v39 ^ __security_cookie;
  v29 = a2;
  v32 = sub_10041A5C(a2, a1) + 708;
  if ( !sub_100429E8(a3, (int)&v36, 131, (int)&v34, 85, (int)&v27) )
    return 0;
  v4 = 16 * a2;
  if ( sub_1004EAE4((int)&v36, *(_DWORD *)(16 * a2 + a1 + 20)) )
  {
    v8 = sub_100398B9((int)&v36);
    v7 = v8 + 1;
    v5 = sub_10037550(v6, 2 * (v8 + 1) + 4, v4, 2 * (v8 + 1) + 4);
    v25 = (void *)v5;
    if ( v5 )
    {
      v24 = *(_UNKNOWN **)(v4 + a1 + 20);
      v28 = v5 + 4;
      v31 = a1 + 4 * (v29 + 40);
      v22 = *(LPVOID *)v31;
      v23 = *(_DWORD *)(a1 + 4);
      if ( sub_100490D0(v6, v28, v4, a1, v28, v7, (int)&v36) )
      {
        sub_1003A17E(v4, a1);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_1004362C);
      }
      v9 = v36 == 67;
      *(_DWORD *)(v4 + a1 + 20) = v28;
      if ( !v9 || v37 )
        *(_DWORD *)v31 = sub_100427C0((int)&v34);
      else
        *(_DWORD *)v31 = 0;
      v10 = v29;
      switch ( v29 )
      {
        case 2:
          *(_DWORD *)(a1 + 4) = v27;
          v30 = v32;
          v26 = *(_DWORD *)(v32 + 32);
          v28 = *(_DWORD *)(v32 + 36);
          v11 = 0;
          v33 = 0;
          while ( 1 )
          {
            v10 = v29;
            if ( *(_DWORD *)(a1 + 4) == *(_DWORD *)v30 )
              break;
            v12 = v30;
            v13 = *(_DWORD *)v30;
            v14 = *(_DWORD *)(v30 + 4);
            v30 += 8;
            *(_DWORD *)v12 = v26;
            v15 = v28;
            v28 = v14;
            v11 = v33 + 1;
            *(_DWORD *)(v12 + 4) = v15;
            v4 = 16 * a2;
            v10 = v29;
            v26 = v13;
            v33 = v11;
            if ( v11 >= 5 )
              goto LABEL_16;
          }
          if ( !v11 )
          {
LABEL_16:
            v16 = v33;
            v17 = v32;
            goto LABEL_17;
          }
          v17 = v32;
          *(_DWORD *)v32 = *(_DWORD *)(v32 + 8 * v33);
          *(_DWORD *)(v17 + 4) = *(_DWORD *)(v17 + 8 * v33 + 4);
          v16 = v33;
          *(_DWORD *)(v17 + 8 * v33) = v26;
          *(_DWORD *)(v17 + 8 * v16 + 4) = v28;
          v4 = 16 * a2;
LABEL_17:
          if ( v16 == 5 )
          {
            if ( sub_10049218(v4, a1, 0, 1u, &MultiByteStr, 127, CharType, *(_DWORD *)(a1 + 4), 1) )
            {
              v18 = 0;
              do
                CharType[v18++] &= 0x1FFu;
              while ( v18 < 0x7F );
              v19 = sub_10037729((int)CharType, (int)off_10074C10, 0xFEu);
              v17 = v32;
              *(_DWORD *)(v32 + 4) = v19 == 0;
            }
            else
            {
              v17 = v32;
              *(_DWORD *)(v32 + 4) = 0;
            }
            v10 = v29;
            *(_DWORD *)v17 = *(_DWORD *)(a1 + 4);
          }
          *(_DWORD *)(a1 + 112) = *(_DWORD *)(v17 + 4);
          break;
        case 1:
          *(_DWORD *)(a1 + 8) = v27;
          break;
        case 5:
          *(_DWORD *)(a1 + 12) = v27;
          break;
      }
      if ( !((int (__cdecl *)(int))*(&off_10065A60 + 3 * v10))(a1) )
      {
        if ( v24 != &unk_100749D8 )
        {
          if ( !InterlockedDecrement(*(volatile LONG **)(v4 + a1 + 28)) )
          {
            sub_100309A2(v4, *(LPVOID *)(v4 + a1 + 28));
            sub_100309A2(v4, *(LPVOID *)(v4 + a1 + 24));
            sub_100309A2(v4, *(LPVOID *)v31);
            v21 = v31;
            *(_DWORD *)(v4 + a1 + 20) = 0;
            *(_DWORD *)v21 = 0;
          }
        }
        *(_DWORD *)v25 = 1;
        *(_DWORD *)(v4 + a1 + 28) = v25;
        return *(_DWORD *)(v4 + a1 + 20);
      }
      *(_DWORD *)(v4 + a1 + 20) = v24;
      v20 = v31;
      sub_100309A2(v31, *(LPVOID *)v31);
      *(_DWORD *)v20 = v22;
      sub_100309A2(v20, v25);
      *(_DWORD *)(a1 + 4) = v23;
    }
    return 0;
  }
  return *(_DWORD *)(v4 + a1 + 20);
}
// 10065A60: using guessed type int (*off_10065A60)();
// 10074200: using guessed type int __security_cookie;
// 10074C10: using guessed type wchar_t *off_10074C10;
// 10043294: using guessed type WORD CharType[128];

//----- (1004362C) --------------------------------------------------------
void __cdecl sub_1004362C()
{
  dword_10078AC0 = 0;
}
// 10078AC0: using guessed type int dword_10078AC0;

//----- (10043634) --------------------------------------------------------
signed int __usercall sub_10043634<eax>(int a1<edx>, int a2<ebx>, int a3, unsigned int *a4, void **a5, const void *a6, int a7)
{
  unsigned int v7; // eax@2
  const void *v8; // ecx@2
  LPVOID v9; // eax@3
  int v11; // eax@6

  if ( a3 == *a4 )
  {
    v8 = *a5;
    v7 = *a4;
    if ( *a5 == a6 )
    {
      v9 = sub_10037506((int)v8, a2, v7, 2u);
      *a5 = v9;
      if ( !v9 )
        return 0;
      *(_DWORD *)a7 = 1;
      sub_10034F00(*a5, a6, *a4);
    }
    else
    {
      v11 = sub_100375E5(a1, (int)v8, a2, v8, v7, 2u);
      if ( !v11 )
        return 0;
      *a5 = (void *)v11;
    }
    *a4 *= 2;
  }
  return 1;
}

//----- (10043693) --------------------------------------------------------
int __usercall sub_10043693<eax>(int a1<edi>, unsigned __int8 a2)
{
  int result; // eax@1
  char v3; // zf@1

  v3 = sub_10036D7B(a2, a1, a2) == 0;
  result = (char)a2;
  if ( v3 )
    result = ((char)a2 & 0xFFFFFFDF) - 7;
  return result;
}

//----- (100436B4) --------------------------------------------------------
signed int __usercall sub_100436B4<eax>(int a1<edx>, int a2<ebx>, int a3)
{
  char v3; // sf@1
  signed int v4; // edx@2

  v3 = *(_DWORD *)(a3 + 4)-- - 1 < 0;
  if ( v3 )
    v4 = sub_1004FB64(a1, a3, a2, a3);
  else
    v4 = *(_BYTE *)*(_DWORD *)a3++;
  return v4;
}

//----- (100436D6) --------------------------------------------------------
signed int __cdecl sub_100436D6(int a1, int a2, int a3, int a4)
{
  signed int v4; // ebx@1
  int v5; // edi@1
  signed int result; // eax@2
  signed int v7; // eax@5
  int v8; // edx@7
  int v9; // ecx@12
  unsigned __int8 v10; // al@16
  int v11; // ecx@16
  int v12; // esi@16
  int v13; // edx@18
  int v14; // eax@19
  int v15; // edx@19
  int v16; // esi@19
  int v17; // edi@25
  int v18; // esi@25
  char v19; // al@28
  char v20; // cl@29
  int v21; // esi@31
  int v22; // edx@32
  char v23; // al@40
  int v24; // edx@67
  char v25; // al@68
  signed int v26; // edi@71
  signed int v27; // eax@74
  int v28; // eax@78
  int v29; // ecx@78
  int v30; // eax@88
  int v31; // esi@91
  int v32; // edi@94
  int i; // eax@98
  int v34; // edx@98
  int v35; // ecx@99
  int v36; // eax@100
  int v38; // eax@102
  int v39; // eax@104
  int v40; // edx@105
  int j; // eax@106
  int v42; // eax@107
  int v44; // eax@109
  int v45; // eax@114
  int v46; // edx@115
  int v47; // eax@116
  int v48; // edx@116
  int v49; // eax@120
  int k; // eax@123
  int v51; // eax@124
  int v53; // eax@126
  int v54; // ecx@132
  LPVOID v55; // ST10_4@132
  int v56; // ST0C_4@132
  int v57; // ST08_4@132
  PVOID v58; // eax@132
  int v59; // ecx@137
  int v60; // esi@137
  int v61; // eax@141
  signed int v62; // eax@142
  int v63; // ecx@142
  int v64; // ST14_4@142
  int v65; // edx@152
  int v66; // edx@154
  char v67; // al@161
  int v68; // edx@165
  char v69; // ah@168
  int v70; // edx@170
  char v71; // cl@172
  char v72; // al@174
  char v73; // al@182
  int v74; // eax@194
  int v75; // edx@194
  char v76; // zf@198
  int v77; // eax@209
  char v78; // al@226
  int v79; // edx@234
  int v80; // ecx@234
  int v81; // eax@234
  int v82; // ST14_4@234
  int v83; // ecx@237
  __int64 v84; // qt0@237
  __int64 v85; // ST08_8@238
  __int64 v86; // qax@238
  int v87; // eax@239
  int v88; // ST14_4@239
  __int64 v89; // qt0@240
  __int64 v90; // qax@241
  int v91; // ecx@241
  unsigned __int8 v92; // cf@241
  char v93; // zf@242
  int v94; // ecx@248
  int v95; // edx@252
  int v96; // ecx@252
  int v97; // eax@252
  int v98; // ST14_4@252
  int v99; // eax@255
  int v100; // eax@257
  int v101; // ST14_4@257
  int v102; // eax@259
  char v103; // zf@260
  int v104; // eax@271
  int v105; // eax@280
  int v106; // ST14_4@280
  int v108; // eax@282
  int v109; // esi@289
  int v110; // ST14_4@290
  int v111; // [sp-8h] [bp-20Ch]@19
  int v112; // [sp-8h] [bp-20Ch]@106
  int v113; // [sp-8h] [bp-20Ch]@123
  int v114; // [sp-8h] [bp-20Ch]@194
  signed int v115; // [sp-8h] [bp-20Ch]@200
  int v116; // [sp-8h] [bp-20Ch]@292
  int v117; // [sp+8h] [bp-1FCh]@16
  int v118; // [sp+10h] [bp-1F4h]@303
  char v119; // [sp+14h] [bp-1F0h]@302
  int v120; // [sp+18h] [bp-1ECh]@17
  int v121; // [sp+1Ch] [bp-1E8h]@17
  int v122; // [sp+20h] [bp-1E4h]@1
  WCHAR WideCharStr[2]; // [sp+24h] [bp-1E0h]@1
  const CHAR MultiByteStr; // [sp+28h] [bp-1DCh]@152
  char v125; // [sp+29h] [bp-1DBh]@153
  int v126; // [sp+2Ch] [bp-1D8h]@1
  int v127; // [sp+30h] [bp-1D4h]@25
  char v128; // [sp+37h] [bp-1CDh]@25
  int v129; // [sp+38h] [bp-1CCh]@1
  int v130; // [sp+3Ch] [bp-1C8h]@16
  int v131; // [sp+40h] [bp-1C4h]@25
  int v132; // [sp+44h] [bp-1C0h]@25
  int v133; // [sp+48h] [bp-1BCh]@17
  int v134; // [sp+4Ch] [bp-1B8h]@26
  int v135; // [sp+50h] [bp-1B4h]@25
  LPVOID lpMem; // [sp+54h] [bp-1B0h]@1
  int v137; // [sp+58h] [bp-1ACh]@17
  __int16 v138; // [sp+5Eh] [bp-1A6h]@25
  int v139; // [sp+60h] [bp-1A4h]@1
  int v140; // [sp+64h] [bp-1A0h]@1
  int v141; // [sp+68h] [bp-19Ch]@16
  char v142; // [sp+6Eh] [bp-196h]@25
  char v143; // [sp+6Fh] [bp-195h]@31
  int v144; // [sp+70h] [bp-194h]@16
  int v145; // [sp+74h] [bp-190h]@1
  int v146; // [sp+78h] [bp-18Ch]@31
  char v147; // [sp+7Ch] [bp-188h]@67
  char v148; // [sp+7Dh] [bp-187h]@16
  char v149; // [sp+7Eh] [bp-186h]@25
  char v150; // [sp+7Fh] [bp-185h]@25
  char v151; // [sp+80h] [bp-184h]@1
  char v152[11]; // [sp+1E0h] [bp-24h]@149
  char v153; // [sp+1EBh] [bp-19h]@168
  unsigned int v154; // [sp+200h] [bp-4h]@1
  int v155; // [sp+204h] [bp+0h]@1

  v154 = (unsigned int)&v155 ^ __security_cookie;
  v129 = 0;
  *(_DWORD *)WideCharStr = 0;
  v5 = a2;
  v122 = a4;
  v4 = 0;
  v145 = a1;
  v139 = a2;
  lpMem = &v151;
  v126 = 350;
  v140 = 0;
  if ( !a2 || !a1 )
  {
    *(_DWORD *)sub_10037669(0) = 22;
    sub_1003A16E(0, a2);
    return -1;
  }
  if ( !(*(_BYTE *)(a1 + 12) & 0x40) )
  {
    v7 = sub_1004FC85(0, a2, a1);
    if ( v7 == -1 || v7 == -2 )
      v8 = (int)&unk_10075060;
    else
      v8 = dword_100770A0[v7 >> 5] + ((v7 & 0x1F) << 6);
    if ( *(_BYTE *)(v8 + 36) & 0x7F
      || (v7 == -1 || v7 == -2 ? (v9 = (int)&unk_10075060) : (v9 = dword_100770A0[v7 >> 5] + ((v7 & 0x1F) << 6)),
          *(_BYTE *)(v9 + 36) & 0x80) )
    {
      *(_DWORD *)sub_10037669(0) = 22;
      sub_1003A16E(0, a2);
      return -1;
    }
  }
  sub_1003018D((int)&v117, 0, a2, a3);
  v10 = *(_BYTE *)a2;
  v12 = 0;
  v11 = 0;
  v148 = 0;
  v144 = 0;
  v141 = 0;
  v130 = 0;
  if ( !v10 )
    goto LABEL_301;
  v137 = v121;
  v133 = v120;
  while ( 1 )
  {
    if ( sub_10036DD1(v4, v5, v10) )
    {
      v141 = v12 - 1;
      v16 = v145;
      v14 = sub_100447C4(v13, v4, v5, (int)&v141, v145);
      if ( v14 != -1 )
        sub_1004FCA9(v15, v111, v4, v14, v16);
      do
        ++v5;
      while ( sub_10036DD1(v4, v5, *(_BYTE *)v5) );
      v12 = v141;
      v139 = v5;
      v144 = v141;
      goto LABEL_287;
    }
    if ( *(_BYTE *)v5 != 37 )
      goto LABEL_280;
    if ( *(_BYTE *)(v5 + 1) != 37 )
      break;
    if ( *(_BYTE *)v5 == 37 )
    {
      if ( *(_BYTE *)(v5 + 1) == 37 )
        ++v5;
    }
LABEL_280:
    ++v12;
    v144 = v12;
    v141 = v12;
    v4 = sub_100436B4(v13, v4, v145);
    v105 = *(_BYTE *)v5++;
    v29 = v106;
    v140 = v4;
    v139 = v5;
    if ( v105 != v4 )
      goto LABEL_293;
    if ( !sub_1004275D(v4, v5, v4) )
      goto LABEL_284;
    v108 = sub_100436B4(v24, v4, v145);
    v29 = *(_BYTE *)v5++;
    v139 = v5;
    if ( v29 != v108 )
    {
      v109 = v145;
      if ( v108 != -1 )
      {
        sub_1004FCA9(v24, v29, v4, v108, v145);
        v29 = v110;
      }
      if ( v4 == -1 )
        goto LABEL_296;
      v116 = v109;
LABEL_295:
      sub_1004FCA9(v24, v29, v4, v4, v116);
      goto LABEL_296;
    }
    v144 = v12;
    v141 = v12;
LABEL_284:
    if ( v4 == -1 && (*(_BYTE *)v5 != 37 || *(_BYTE *)(v5 + 1) != 110) )
      goto LABEL_296;
LABEL_287:
    v10 = *(_BYTE *)v5;
    if ( !*(_BYTE *)v5 )
      goto LABEL_296;
  }
  v18 = v139;
  v131 = 0;
  v128 = 0;
  v135 = 0;
  v132 = 0;
  v17 = 0;
  v138 = 0;
  v149 = 0;
  v142 = 0;
  v150 = 0;
  v127 = 0;
  LOWORD(v4) = 256;
  do
  {
    ++v18;
    v134 = *(_BYTE *)v18;
    if ( sub_10036D7B(v4, v17, (unsigned __int8)v134) )
    {
      ++v132;
      v17 = v134 + 10 * v17 - 48;
      goto LABEL_28;
    }
    if ( v134 > 78 )
    {
      if ( v134 == 104 )
      {
        --BYTE1(v4);
        v20 = v150 - 1;
      }
      else
      {
        if ( v134 == 108 )
        {
          if ( *(_BYTE *)(v18 + 1) == 108 )
          {
            ++v18;
            goto LABEL_43;
          }
          LOWORD(v4) = v4 + 256;
        }
        else
        {
          if ( v134 != 119 )
            goto LABEL_57;
        }
        v20 = v150 + 1;
      }
      v150 = v20;
    }
    else
    {
      if ( v134 == 78 )
        goto LABEL_28;
      if ( v134 == 42 )
      {
        v19 = v149++ + 1;
        goto LABEL_29;
      }
      if ( v134 == 70 )
        goto LABEL_28;
      if ( v134 != 73 )
      {
        if ( v134 == 76 )
        {
          LOWORD(v4) = v4 + 256;
          goto LABEL_28;
        }
        goto LABEL_57;
      }
      v23 = *(_BYTE *)(v18 + 1);
      if ( v23 == 54 && *(_BYTE *)(v18 + 2) == 52 )
      {
        v18 += 2;
LABEL_43:
        ++v127;
        v133 = 0;
        v137 = 0;
        goto LABEL_28;
      }
      if ( v23 == 51 && *(_BYTE *)(v18 + 2) == 50 )
      {
        v18 += 2;
        goto LABEL_28;
      }
      if ( v23 == 100 )
        goto LABEL_28;
      if ( v23 != 105 )
      {
        if ( v23 == 111 || v23 == 120 || v23 == 88 )
        {
LABEL_28:
          v19 = v149;
LABEL_29:
          v20 = v150;
          continue;
        }
LABEL_57:
        LOBYTE(v4) = v4 + 1;
        goto LABEL_28;
      }
      v20 = v150;
    }
    v19 = v149;
  }
  while ( !(_BYTE)v4 );
  v143 = BYTE1(v4);
  v4 = v140;
  v139 = v18;
  v21 = v144;
  v146 = v17;
  if ( v19 )
  {
    v134 = 0;
  }
  else
  {
    v121 = v122;
    v22 = *(_DWORD *)v122;
    v122 += 4;
    v134 = v22;
  }
  v24 = v139;
  v147 = 0;
  if ( !v20 )
  {
    v25 = *(_BYTE *)v139;
    if ( *(_BYTE *)v139 == 83 || (v150 = -1, v25 == 67) )
      v150 = 1;
  }
  v26 = *(_BYTE *)v139 | 0x20;
  if ( v26 == 110 )
  {
LABEL_78:
    v28 = v132;
    v29 = v146;
    if ( v132 && !v146 )
    {
LABEL_293:
      if ( v4 == -1 )
        goto LABEL_296;
      v116 = v145;
      goto LABEL_295;
    }
    if ( v26 <= 111 )
    {
      if ( v26 == 111 )
        goto LABEL_221;
      if ( v26 != 99 )
      {
        if ( v26 != 100 )
        {
          if ( v26 <= 100 )
            goto LABEL_160;
          if ( v26 > 103 )
          {
            if ( v26 != 105 )
            {
              if ( v26 == 110 )
              {
                v30 = v21;
                if ( v149 )
                {
LABEL_275:
                  v67 = v148;
LABEL_276:
                  v12 = v144;
                  v5 = v139 + 1;
                  v148 = v67 + 1;
                  ++v139;
                  goto LABEL_284;
                }
LABEL_270:
                if ( v127 )
                {
                  v104 = v134;
                  *(_DWORD *)v134 = v133;
                  *(_DWORD *)(v104 + 4) = v137;
                }
                else
                {
                  if ( v143 )
                    *(_DWORD *)v134 = v30;
                  else
                    *(_WORD *)v134 = v30;
                }
                goto LABEL_275;
              }
LABEL_160:
              if ( *(_BYTE *)v24 != v4 )
                goto LABEL_293;
              v67 = v148 - 1;
              if ( !v149 )
                v122 = v121;
              goto LABEL_276;
            }
            v26 = 100;
LABEL_186:
            if ( v4 == 45 )
            {
              LOBYTE(v138) = 1;
            }
            else
            {
              if ( v4 != 43 )
              {
LABEL_193:
                if ( v4 != 48 )
                {
LABEL_229:
                  v78 = v147;
                  goto LABEL_230;
                }
                ++v21;
                v144 = v21;
                v141 = v21;
                v74 = sub_100436B4(v24, 48, v145);
                v4 = v74;
                v140 = v74;
                if ( (_BYTE)v74 == 120 || (_BYTE)v74 == 88 )
                {
                  ++v21;
                  v144 = v21;
                  v141 = v21;
                  v4 = sub_100436B4(v75, v74, v145);
                  v140 = v4;
                  if ( v132 )
                  {
                    v146 -= 2;
                    if ( v146 < 1 )
                      ++v147;
                  }
                  v115 = 120;
                  goto LABEL_201;
                }
                v135 = 1;
                if ( v26 != 120 )
                {
                  if ( v132 )
                  {
                    v76 = v146-- == 1;
                    if ( v76 )
                      ++v147;
                  }
                  v115 = 111;
LABEL_201:
                  v26 = v115;
                  goto LABEL_229;
                }
                --v21;
                v144 = v21;
                v141 = v21;
                if ( v74 != -1 )
                  sub_1004FCA9(v75, v114, v74, v74, v145);
                v4 = 48;
LABEL_228:
                v140 = v4;
                goto LABEL_229;
              }
            }
            --v146;
            if ( v146 || !v28 )
            {
              ++v21;
              v144 = v21;
              v141 = v21;
              v4 = sub_100436B4(v24, v4, v145);
              v140 = v4;
            }
            else
            {
              v147 = 1;
            }
            goto LABEL_193;
          }
          v31 = 0;
          if ( v4 == 45 )
          {
            v31 = 1;
            *(_BYTE *)lpMem = 45;
          }
          else
          {
            if ( v4 != 43 )
            {
              v32 = v144;
              goto LABEL_96;
            }
          }
          v146 = v29 - 1;
          v32 = v144 + 1;
          v4 = sub_100436B4(v24, v4, v145);
          v28 = v132;
          v140 = v4;
LABEL_96:
          if ( !v28 )
            v146 = -1;
          for ( i = sub_10036D7B(v4, v32, (unsigned __int8)v4); ; i = sub_10036D7B(v38, v32, (unsigned __int8)v38) )
          {
            v35 = v146;
            if ( !i )
              break;
            v36 = v146;
            v35 = v146-- - 1;
            if ( !v36 )
              break;
            ++v135;
            *((_BYTE *)lpMem + v31++) = v4;
            if ( !sub_10043634(v34, v4, v31, (unsigned int *)&v126, &lpMem, &v151, (int)&v129) )
              goto LABEL_296;
            ++v32;
            v38 = sub_100436B4(v34, v4, v145);
            v4 = v38;
            v140 = v38;
          }
          HIBYTE(v138) = ***(_BYTE ***)(v117 + 132);
          if ( HIBYTE(v138) == (_BYTE)v4 )
          {
            v39 = v35--;
            v146 = v35;
            if ( v39 )
            {
              ++v32;
              v4 = sub_100436B4(v34, v4, v145);
              *((_BYTE *)lpMem + v31++) = HIBYTE(v138);
              v140 = v4;
              if ( !sub_10043634(v40, v4, v31, (unsigned int *)&v126, &lpMem, &v151, (int)&v129) )
                goto LABEL_296;
              for ( j = sub_10036D7B(v4, v32, (unsigned __int8)v4); ; j = sub_10036D7B(v44, v32, (unsigned __int8)v44) )
              {
                v35 = v112;
                if ( !j )
                  break;
                v42 = v146;
                v35 = v146-- - 1;
                if ( !v42 )
                  break;
                ++v135;
                *((_BYTE *)lpMem + v31++) = v4;
                if ( !sub_10043634(v34, v4, v31, (unsigned int *)&v126, &lpMem, &v151, (int)&v129) )
                  goto LABEL_296;
                ++v32;
                v44 = sub_100436B4(v34, v4, v145);
                v4 = v44;
                v140 = v44;
              }
            }
          }
          if ( !v135 || v4 != 101 && v4 != 69 || (v45 = v146, v35 = v146 - 1, --v146, !v45) )
            goto LABEL_128;
          *((_BYTE *)lpMem + v31++) = 101;
          if ( !sub_10043634(v34, v4, v31, (unsigned int *)&v126, &lpMem, &v151, (int)&v129) )
            goto LABEL_296;
          ++v32;
          v47 = sub_100436B4(v46, v4, v145);
          v4 = v47;
          v140 = v47;
          if ( v47 == 45 )
          {
            *((_BYTE *)lpMem + v31++) = 45;
            if ( !sub_10043634(v48, v47, v31, (unsigned int *)&v126, &lpMem, &v151, (int)&v129) )
              goto LABEL_296;
          }
          else
          {
            if ( v47 != 43 )
              goto LABEL_123;
          }
          v49 = v146--;
          if ( v49 )
          {
            ++v32;
            v4 = sub_100436B4(v48, v4, v145);
            v140 = v4;
          }
          else
          {
            v146 = 0;
          }
LABEL_123:
          for ( k = sub_10036D7B(v4, v32, (unsigned __int8)v4); ; k = sub_10036D7B(v53, v32, (unsigned __int8)v53) )
          {
            v35 = v113;
            if ( !k )
              break;
            v51 = v146;
            v35 = v146-- - 1;
            if ( !v51 )
              break;
            ++v135;
            *((_BYTE *)lpMem + v31++) = v4;
            if ( !sub_10043634(v34, v4, v31, (unsigned int *)&v126, &lpMem, &v151, (int)&v129) )
              goto LABEL_296;
            ++v32;
            v53 = sub_100436B4(v34, v4, v145);
            v4 = v53;
            v140 = v53;
          }
LABEL_128:
          v144 = v32 - 1;
          v141 = v32 - 1;
          if ( v4 != -1 )
            sub_1004FCA9(v34, v35, v4, v4, v145);
          if ( !v135 )
            goto LABEL_296;
          if ( !v149 )
          {
            ++v130;
            v54 = v134;
            v55 = lpMem;
            *((_BYTE *)lpMem + v31) = 0;
            v56 = v54;
            v57 = v143 - 1;
            v58 = DecodePointer(off_100751E8);
            ((void (__cdecl *)(int, int, LPVOID, int *))v58)(v57, v56, v55, &v117);
          }
          goto LABEL_275;
        }
LABEL_221:
        if ( v4 == 45 )
        {
          LOBYTE(v138) = 1;
        }
        else
        {
          if ( v4 != 43 )
            goto LABEL_229;
        }
        --v146;
        if ( !v146 && v28 )
        {
          v78 = 1;
LABEL_230:
          if ( v127 )
          {
            if ( !v78 )
            {
              while ( 1 )
              {
                if ( v26 == 120 || v26 == 112 )
                {
                  v87 = sub_10036E27(v4, v26, (unsigned __int8)v4);
                  v80 = v88;
                  if ( !v87 )
                  {
LABEL_244:
                    v144 = v21 - 1;
                    v141 = v21 - 1;
                    if ( v4 != -1 )
                      sub_1004FCA9(v79, v80, v4, v4, v145);
                    break;
                  }
                  HIDWORD(v89) = v137;
                  LODWORD(v89) = v133;
                  v137 = (unsigned __int64)(16 * v89) >> 32;
                  v133 *= 16;
                  v4 = sub_10043693(v26, v4);
                  v83 = v133;
                  v140 = v4;
                }
                else
                {
                  v81 = sub_10036D7B(v4, v26, (unsigned __int8)v4);
                  v80 = v82;
                  if ( !v81 )
                    goto LABEL_244;
                  if ( v26 == 111 )
                  {
                    if ( v4 >= 56 )
                      goto LABEL_244;
                    HIDWORD(v84) = v137;
                    LODWORD(v84) = v133;
                    v137 = (unsigned __int64)(8 * v84) >> 32;
                    v83 = 8 * v133;
                  }
                  else
                  {
                    HIDWORD(v85) = v137;
                    LODWORD(v85) = v133;
                    v86 = sub_10039A40(v85, 10i64);
                    v83 = v86;
                    v137 = HIDWORD(v86);
                  }
                }
                ++v135;
                v90 = v4 - 48;
                v92 = (_DWORD)v90 >= (unsigned int)-v83;
                v91 = v90 + v83;
                LODWORD(v90) = HIDWORD(v90) + v92 + v137;
                v133 = v91;
                v137 += HIDWORD(v90) + v92;
                if ( v132 )
                {
                  v93 = v146-- == 1;
                  if ( v93 )
                    goto LABEL_247;
                }
                ++v21;
                v144 = v21;
                v141 = v21;
                v4 = sub_100436B4(SHIDWORD(v90), v4, v145);
                v140 = v4;
              }
            }
            v91 = v133;
            LODWORD(v90) = v137;
LABEL_247:
            if ( (_BYTE)v138 )
            {
              v94 = -v91;
              v133 = v94;
              v137 = (unsigned __int64)-__PAIR__(v90, v94) >> 32;
            }
          }
          else
          {
            if ( !v78 )
            {
              while ( 1 )
              {
                if ( v26 == 120 || v26 == 112 )
                {
                  v100 = sub_10036E27(v4, v26, (unsigned __int8)v4);
                  v96 = v101;
                  if ( !v100 )
                  {
LABEL_262:
                    v144 = v21 - 1;
                    v141 = v21 - 1;
                    if ( v4 != -1 )
                      sub_1004FCA9(v95, v96, v4, v4, v145);
                    break;
                  }
                  v131 *= 16;
                  v4 = sub_10043693(v26, v4);
                  v99 = v131;
                  v140 = v4;
                }
                else
                {
                  v97 = sub_10036D7B(v4, v26, (unsigned __int8)v4);
                  v96 = v98;
                  if ( !v97 )
                    goto LABEL_262;
                  if ( v26 == 111 )
                  {
                    if ( v4 >= 56 )
                      goto LABEL_262;
                    v99 = 8 * v131;
                  }
                  else
                  {
                    v99 = 10 * v131;
                  }
                }
                ++v135;
                v102 = v4 + v99 - 48;
                v131 = v102;
                if ( v132 )
                {
                  v103 = v146-- == 1;
                  if ( v103 )
                    goto LABEL_265;
                }
                ++v21;
                v144 = v21;
                v141 = v21;
                v4 = sub_100436B4(v95, v4, v145);
                v140 = v4;
              }
            }
            v102 = v131;
LABEL_265:
            if ( (_BYTE)v138 )
              v131 = -v102;
          }
          if ( !(v26 != 70 ? v135 : 0) )
            goto LABEL_296;
          if ( v149 )
            goto LABEL_275;
          ++v130;
          v30 = v131;
          goto LABEL_270;
        }
        ++v21;
        v144 = v21;
        v141 = v21;
        v4 = sub_100436B4(v24, v4, v145);
        goto LABEL_228;
      }
      if ( !v132 )
      {
        v132 = 1;
        ++v146;
      }
      goto LABEL_135;
    }
    if ( v26 == 112 )
    {
      v143 = 1;
    }
    else
    {
      if ( v26 == 115 )
      {
LABEL_135:
        if ( v150 > 0 )
          v142 = 1;
        goto LABEL_137;
      }
      if ( v26 != 117 )
      {
        if ( v26 == 120 )
        {
          v28 = v132;
          goto LABEL_186;
        }
        if ( v26 != 123 )
          goto LABEL_160;
        if ( v150 > 0 )
          v142 = 1;
        v68 = v24 + 1;
        v139 = v68;
        if ( *(_BYTE *)v68 == 94 )
        {
          v139 = v68 + 1;
          HIBYTE(v138) = -1;
        }
        sub_10039210(v152, 0, 32);
        v24 = v139;
        if ( *(_BYTE *)v139 == 93 )
        {
          v69 = 93;
          v24 = v139 + 1;
          v153 = 32;
        }
        else
        {
          v69 = v128;
        }
        while ( 1 )
        {
          v73 = *(_BYTE *)v24;
          if ( *(_BYTE *)v24 == 93 )
            break;
          v70 = v24 + 1;
          v139 = v70;
          if ( v73 == 45 && v69 && (v71 = *(_BYTE *)v70, *(_BYTE *)v70 != 93) )
          {
            v139 = v70 + 1;
            if ( v69 >= (unsigned __int8)v71 )
            {
              v72 = v69;
              v69 = v71;
            }
            else
            {
              v72 = v71;
            }
            while ( (unsigned __int8)v69 < (signed int)(unsigned __int8)v72 )
            {
              v152[(unsigned int)(unsigned __int8)v69 >> 3] |= 1 << (v69 & 7);
              ++v69;
            }
            v152[(unsigned int)(unsigned __int8)v72 >> 3] |= 1 << (v72 & 7);
            v69 = 0;
          }
          else
          {
            v69 = v73;
            v152[(unsigned int)(unsigned __int8)v73 >> 3] |= 1 << (v73 & 7);
          }
          v24 = v139;
        }
        if ( !v73 )
          goto LABEL_296;
        v139 = v24;
LABEL_137:
        v60 = v134;
        v59 = v144 - 1;
        v144 = v59;
        v141 = v59;
        if ( v4 != -1 )
        {
          sub_1004FCA9(v24, v59, v4, v4, v145);
          goto LABEL_139;
        }
        while ( 1 )
        {
          if ( v132 )
          {
            v61 = v146;
            v24 = v146-- - 1;
            if ( !v61 )
              break;
          }
          v144 = v59 + 1;
          v141 = v59 + 1;
          v62 = sub_100436B4(v24, v4, v145);
          v4 = v62;
          v63 = v64;
          v140 = v62;
          if ( v62 == -1 )
            goto LABEL_211;
          if ( v26 != 99 )
          {
            if ( v26 != 115 )
              goto LABEL_306;
            if ( v62 >= 9 && v62 <= 13 )
            {
LABEL_211:
              --v144;
              v141 = v144;
              if ( v62 != -1 )
                sub_1004FCA9(v24, v63, v62, v62, v145);
              break;
            }
            if ( v62 == 32 )
            {
LABEL_306:
              if ( v26 != 123 || (v24 = 1 << (v62 & 7), v63 = SHIBYTE(v138) ^ v152[v62 >> 3], !(v24 & v63)) )
                goto LABEL_211;
            }
          }
          if ( v149 )
          {
            ++v60;
          }
          else
          {
            if ( v142 )
            {
              MultiByteStr = v62;
              if ( sub_1004275D(v62, v26, v62) )
              {
                ++v144;
                v141 = v144;
                v125 = sub_100436B4(v65, v4, v145);
              }
              *(_DWORD *)WideCharStr = 63;
              sub_1004FD89(v26, WideCharStr, &MultiByteStr, *(_DWORD *)(v117 + 116), (int)&v117);
              v66 = v134;
              *(_WORD *)v134 = WideCharStr[0];
              v24 = v66 + 2;
              v134 = v24;
            }
            else
            {
              v77 = v134;
              *(_BYTE *)v134 = v4;
              v134 = v77 + 1;
            }
          }
LABEL_139:
          v59 = v144;
        }
        if ( v60 == v134 )
          goto LABEL_296;
        if ( !v149 )
        {
          ++v130;
          if ( v26 != 99 )
          {
            if ( v142 )
              *(_WORD *)v134 = 0;
            else
              *(_BYTE *)v134 = 0;
          }
        }
        goto LABEL_275;
      }
    }
    v28 = v132;
    goto LABEL_221;
  }
  if ( v26 == 99 || v26 == 123 )
  {
    v21 = v144 + 1;
    v144 = v21;
    v141 = v21;
    v27 = sub_100436B4(v139, v140, v145);
  }
  else
  {
    v27 = sub_100447C4(v139, v140, v26, (int)&v141, v145);
    v21 = v141;
    v144 = v141;
  }
  v4 = v27;
  v140 = v27;
  if ( v27 != -1 )
  {
    v24 = v139;
    goto LABEL_78;
  }
LABEL_296:
  if ( v129 == 1 )
    sub_100309A2(v4, lpMem);
  v11 = v130;
  result = -1;
  if ( v4 != -1 || v130 || v148 )
LABEL_301:
    result = v11;
  if ( v119 )
    *(_DWORD *)(v118 + 112) &= 0xFFFFFFFDu;
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 100770A0: using guessed type int dword_100770A0[];
// 100436D6: using guessed type char var_24[11];

//----- (100447C4) --------------------------------------------------------
int __usercall sub_100447C4<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4, int a5)
{
  int v5; // eax@1

  do
  {
    ++*(_DWORD *)a4;
    v5 = sub_100436B4(a1, a2, a5);
    a2 = v5;
  }
  while ( v5 != -1 && sub_10036DD1(v5, a3, (unsigned __int8)v5) );
  return a2;
}

//----- (100447F2) --------------------------------------------------------
signed int __usercall sub_100447F2<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3, int a4)
{
  int v4; // edx@1
  int v5; // ecx@1
  int v6; // edi@1
  int v7; // esi@1
  signed int v8; // eax@1
  int v10; // ebx@6
  int v11; // eax@9
  int v12; // eax@12
  int v13; // ST0C_4@12
  int v14; // ST0C_4@13
  int v15; // edx@15
  int v16; // ecx@15
  void *v17; // ecx@15
  int v18; // eax@15
  int v19; // eax@16
  int v20; // ecx@20
  int v21; // eax@23
  int v22; // edx@23
  int v23; // eax@25

  v7 = a4;
  v8 = sub_1004FC85(a1, a2, a4);
  v5 = *(_DWORD *)(v7 + 12);
  v6 = v8;
  if ( !(v5 & 0x82) )
  {
    *(_DWORD *)sub_10037669(a1) = 9;
LABEL_3:
    *(_DWORD *)(v7 + 12) |= 0x20u;
    return -1;
  }
  if ( v5 & 0x40 )
  {
    *(_DWORD *)sub_10037669(a1) = 34;
    goto LABEL_3;
  }
  v10 = 0;
  if ( v5 & 1 )
  {
    *(_DWORD *)(v7 + 4) = 0;
    if ( !(v5 & 0x10) )
    {
      *(_DWORD *)(v7 + 12) = v5 | 0x20;
      return -1;
    }
    v5 &= 0xFFFFFFFEu;
    *(_DWORD *)v7 = *(_DWORD *)(v7 + 8);
    *(_DWORD *)(v7 + 12) = v5;
  }
  v11 = *(_DWORD *)(v7 + 12) & 0xFFFFFFEF | 2;
  *(_DWORD *)(v7 + 12) = v11;
  *(_DWORD *)(v7 + 4) = 0;
  if ( !(v11 & 0x10C) )
  {
    if ( (void **)v7 != sub_10047EC4() + 8 && (void **)v7 != sub_10047EC4() + 16
      || (v12 = sub_1004FE94(0, v6, v6), v5 = v13, !v12) )
    {
      sub_10050961(v4, v5, 0, v7);
      v5 = v14;
    }
  }
  if ( *(_DWORD *)(v7 + 12) & 0x108 )
  {
    v15 = *(_DWORD *)(v7 + 8);
    v17 = *(void **)v7;
    *(_DWORD *)v7 = v15 + 1;
    v16 = (int)((char *)v17 - v15);
    v18 = *(_DWORD *)(v7 + 24) - 1;
    a4 = v16;
    *(_DWORD *)(v7 + 4) = v18;
    if ( v16 <= 0 )
    {
      if ( v6 == -1 || v6 == -2 )
        v20 = (int)&unk_10075060;
      else
        v20 = dword_100770A0[v6 >> 5] + ((v6 & 0x1F) << 6);
      if ( *(_BYTE *)(v20 + 4) & 0x20 )
      {
        sub_100507F4(v15, v20, 0, v6, 0i64, 2u);
        if ( (v22 & v21) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      sub_1004FEE8(v15, v16, 0, v6, v6, (const void *)v15, v16);
      v10 = v19;
    }
    **(_BYTE **)(v7 + 8) = a3;
  }
  else
  {
    a4 = 1;
    sub_1004FEE8(v4, v5, 0, v6, v6, &a3, 1);
    v10 = v23;
  }
  if ( v10 != a4 )
  {
LABEL_27:
    *(_DWORD *)(v7 + 12) |= 0x20u;
    return -1;
  }
  return a3;
}
// 100770A0: using guessed type int dword_100770A0[];

//----- (1004493F) --------------------------------------------------------
int __usercall sub_1004493F<eax>(int a1<ebx>, int (__cdecl *a2)(_DWORD, _DWORD, _DWORD, _DWORD), int a3, unsigned int a4, int a5, int a6, int a7)
{
  int result; // eax@2
  int v8; // ebx@8
  char v9; // sf@10
  char v10; // sf@14
  int v11; // [sp+4h] [bp-20h]@1
  unsigned int v12; // [sp+8h] [bp-1Ch]@1
  int v13; // [sp+Ch] [bp-18h]@8
  int v14; // [sp+10h] [bp-14h]@8
  int v15; // [sp+24h] [bp+0h]@2

  v11 = 0;
  memset(&v12, 0, 0x1Cu);
  if ( !a5 )
  {
    *(_DWORD *)sub_10037669(a1) = 22;
    sub_1003A16E(a1, (int)&v15);
    return -1;
  }
  if ( a4 && !a3 )
  {
    *(_DWORD *)sub_10037669(a1) = 22;
    sub_1003A16E(a1, 0);
    return -1;
  }
  v12 = 2147483647;
  if ( a4 <= 0x7FFFFFFF )
    v12 = a4;
  v14 = 66;
  v13 = a3;
  v11 = a3;
  result = a2(&v11, a5, a6, a7);
  v8 = result;
  if ( a3 )
  {
    if ( result >= 0 )
    {
      v9 = (signed int)(v12-- - 1) < 0;
      if ( !v9 )
      {
        *(_BYTE *)v11 = 0;
        return v8;
      }
      if ( sub_100447F2(result, a3, 0, (int)&v11) != -1 )
        return v8;
    }
    v10 = (signed int)v12 < 0;
    *(_BYTE *)(a3 + a4 - 1) = 0;
    result = !v10 - 2;
  }
  return result;
}

//----- (10044A07) --------------------------------------------------------
int __usercall sub_10044A07<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned int a4, int a5, int a6, int a7)
{
  int result; // eax@2

  if ( !a5 )
  {
    *(_DWORD *)sub_10037669(a1) = 22;
    sub_1003A16E(a1, a2);
    return -1;
  }
  if ( !a3 || !a4 )
  {
    *(_DWORD *)sub_10037669(a1) = 22;
    goto LABEL_10;
  }
  result = sub_1004493F(a1, sub_100509A7, a3, a4, a5, a6, a7);
  if ( result < 0 )
    *(_BYTE *)a3 = 0;
  if ( result == -2 )
  {
    *(_DWORD *)sub_10037669(a1) = 34;
LABEL_10:
    sub_1003A16E(a1, a2);
    result = -1;
  }
  return result;
}

//----- (10044A7C) --------------------------------------------------------
bool __cdecl sub_10044A7C()
{
  hHeap = GetProcessHeap();
  return hHeap != 0;
}

//----- (10044A91) --------------------------------------------------------
void __cdecl sub_10044A91()
{
  hHeap = 0;
}

//----- (10044A99) --------------------------------------------------------
signed int __usercall sub_10044A99<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6)
{
  int v6; // edx@1
  int v8; // esi@9
  int v9; // eax@11
  int v10; // ebx@14
  int v11; // edi@14
  __int16 v12; // ax@15
  __int16 v13; // ax@18
  char v14; // zf@23
  int v15; // [sp-8h] [bp-Ch]@14
  signed int v16; // [sp-4h] [bp-8h]@11
  int v17; // [sp-4h] [bp-8h]@14

  v6 = a6;
  if ( a6 )
  {
    if ( !a3 )
    {
LABEL_11:
      v9 = sub_10037669(a1);
      v16 = 22;
LABEL_12:
      *(_DWORD *)v9 = v16;
      sub_1003A16E(a1, a2);
      return v16;
    }
  }
  else
  {
    if ( !a3 )
    {
      if ( !a4 )
        return 0;
      goto LABEL_11;
    }
  }
  if ( !a4 )
    goto LABEL_11;
  if ( !a6 )
  {
    *(_WORD *)a3 = 0;
    return 0;
  }
  v8 = a5;
  if ( !a5 )
  {
    *(_WORD *)a3 = 0;
    goto LABEL_11;
  }
  v17 = a1;
  v15 = a2;
  v10 = a3;
  v11 = a4;
  if ( a6 == -1 )
  {
    do
    {
      v12 = *(_WORD *)v8;
      *(_WORD *)(a3 - a5 + v8) = *(_WORD *)v8;
      v8 += 2;
      if ( !v12 )
        break;
      --v11;
    }
    while ( v11 );
  }
  else
  {
    do
    {
      v13 = *(_WORD *)(a5 - a3 + v10);
      *(_WORD *)v10 = v13;
      v10 += 2;
      if ( !v13 )
        break;
      --v11;
      if ( !v11 )
        break;
      --v6;
    }
    while ( v6 );
    if ( !v6 )
      *(_WORD *)v10 = 0;
  }
  v14 = v11 == 0;
  a2 = v15;
  a1 = v17;
  if ( !v14 )
    return 0;
  if ( v6 != -1 )
  {
    *(_WORD *)a3 = 0;
    v9 = sub_10037669(v17);
    v16 = 34;
    goto LABEL_12;
  }
  *(_WORD *)(a3 + 2 * a4 - 2) = 0;
  return 80;
}

//----- (10044B57) --------------------------------------------------------
int __usercall sub_10044B57<eax>(int a1<ebx>, int a2, int a3, char a4)
{
  int ebp0; // ebp@0
  char *v6; // [sp+0h] [bp-4h]@1

  v6 = &a4;
  sub_10044C85(a1, ebp0, a3, (int)&v6);
  return a2;
}

//----- (10044B75) --------------------------------------------------------
int __userpurge sub_10044B75<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, const void **a5)
{
  int v6; // esi@1
  int v7; // eax@1

  v6 = a2;
  v7 = sub_1002ADB1(a1, a2, a3, a4, 40);
  *(_DWORD *)v6 = v7;
  sub_10034F00((void *)v7, *a5, 0x28u);
  return v6;
}

//----- (10044B9B) --------------------------------------------------------
int __userpurge sub_10044B9B<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10061D48;
  return v4;
}
// 10061D48: using guessed type int (__stdcall *off_10061D48)(char);

//----- (10044BB6) --------------------------------------------------------
int __userpurge sub_10044BB6<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10061D60;
  return v4;
}
// 10061D60: using guessed type int (__stdcall *off_10061D60)(char);

//----- (10044BD1) --------------------------------------------------------
int __userpurge sub_10044BD1<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10061D54;
  return v4;
}
// 10061D54: using guessed type int (__stdcall *off_10061D54)(char);

//----- (10044BEC) --------------------------------------------------------
int __thiscall sub_10044BEC(LPVOID *this)
{
  return sub_1002A4AA(*this);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10044BF5) --------------------------------------------------------
void **__thiscall sub_10044BF5(void **this, const void **a2)
{
  void **v3; // esi@1

  v3 = this;
  sub_10034F00(*this, *a2, 0x28u);
  return v3;
}

//----- (10044C13) --------------------------------------------------------
int __thiscall sub_10044C13(void *this, unsigned int a2)
{
  char v3; // al@3
  char v4; // [sp+0h] [bp-Ch]@3

  if ( a2 > 9 )
  {
    v3 = (unsigned int)sub_10044DAD(a2);
    sub_1002FFF9((int)&v4, v3);
    sub_100355DB((int)&v4, (int)&unk_1006D074);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10044C49);
  }
  return *(_DWORD *)(*(_DWORD *)this + 4 * a2);
}

//----- (10044C49) --------------------------------------------------------
char __thiscall sub_10044C49(void *this)
{
  void *v2; // esi@1
  int v3; // ST04_4@1
  int v4; // eax@1

  v2 = this;
  v3 = sub_10044C13(this, 1u);
  v4 = sub_10044C13(v2, 2u);
  return sub_10044C67(v4, v3);
}

//----- (10044C67) --------------------------------------------------------
char __cdecl sub_10044C67(unsigned int a1, unsigned int a2)
{
  return a2 == -1 || a1 == -1 || a2 >= a1;
}

//----- (10044C85) --------------------------------------------------------
int __userpurge sub_10044C85<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4)
{
  int v4; // ebx@1
  unsigned int v5; // esi@1
  int v6; // ecx@1
  int v7; // edi@1
  int v8; // edx@1
  int v9; // eax@3
  int v10; // ecx@3
  unsigned int v11; // edi@3
  int v12; // eax@3
  int i; // eax@4
  char v14; // al@4
  char v15; // al@7
  int v17; // [sp-8h] [bp-8h]@4

  sub_100356D1();
  v7 = v6;
  *(_DWORD *)(a2 - 24) = v6;
  v4 = sub_1002ADB1(v8, v6, a1, v6, 40);
  v5 = 0;
  *(_DWORD *)(a2 - 28) = v4;
  *(_DWORD *)v7 = v4;
  *(_DWORD *)(a2 - 4) = 0;
  sub_10034F00((void *)v4, &unk_10074C1C, 0x28u);
  while ( 1 )
  {
    if ( v5 < *(_DWORD *)(a2 + 8) )
    {
      v10 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)v10 += 4;
      v12 = *(_DWORD *)v10 + 4;
      v11 = *(_DWORD *)(*(_DWORD *)v10 - 4);
      *(_DWORD *)v10 = v12;
      v9 = *(_DWORD *)(v12 - 4);
      *(_DWORD *)(a2 - 20) = v9;
      if ( v11 > 9 )
      {
        v14 = (unsigned int)sub_10044DAD(v11);
        sub_1002FFF9(a2 - 40, v14);
        v17 = (int)&unk_1006D074;
        i = a2 - 40;
        goto LABEL_5;
      }
      goto LABEL_6;
    }
    v11 = *(_DWORD *)(a2 - 24);
    if ( sub_10044C49(*(void **)(a2 - 24)) )
      break;
    sub_10030015(a2 - 64);
    v17 = (int)&unk_1006D0E4;
LABEL_5:
    for ( i = a2 - 64; ; i = a2 - 52 )
    {
      sub_100355DB(v9, v17);
LABEL_6:
      if ( sub_10044DC4(v11, v9) )
        break;
      v15 = (unsigned int)sub_10044DAD(v11);
      sub_10030027(a2 - 52, v15);
      v17 = (int)&unk_1006D0AC;
    }
    *(_DWORD *)(v4 + 4 * v11) = *(_DWORD *)(a2 - 20);
    ++v5;
  }
  sub_10044D65((void *)v11);
  return sub_10035636(52);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (10044D56) --------------------------------------------------------
void __userpurge sub_10044D56(int a1<ebp>, int a2, int a3)
{
  sub_1002A4AA(*(LPVOID *)(a1 - 28));
  JUMPOUT(*(unsigned int *)loc_10044CF2);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10044CF2: using guessed type int __stdcall loc_10044CF2(int, int);

//----- (10044D65) --------------------------------------------------------
int __thiscall sub_10044D65(void *this)
{
  int result; // eax@1
  int v2; // edx@1
  void *v3; // edi@1
  int v4; // esi@1
  int v5; // ecx@2

  v3 = this;
  **(_DWORD **)this = 0;
  v2 = sub_1003D69A();
  result = *(_DWORD *)v3;
  v4 = *(_DWORD *)(*(_DWORD *)v3 + 8);
  if ( v4 == -1 )
  {
    v5 = *(_DWORD *)(result + 4);
    if ( v5 == -1 )
    {
      *(_DWORD *)(result + 4) = v2;
      result = *(_DWORD *)v3;
      *(_DWORD *)(*(_DWORD *)v3 + 8) = v2;
    }
    else
    {
      if ( v5 >= (unsigned int)v2 )
        v5 = v2;
      *(_DWORD *)(result + 8) = v5;
    }
  }
  else
  {
    if ( *(_DWORD *)(result + 4) == -1 )
    {
      if ( v4 <= (unsigned int)v2 )
        v4 = v2;
      *(_DWORD *)(result + 4) = v4;
    }
  }
  return result;
}

//----- (10044DAD) --------------------------------------------------------
char *__cdecl sub_10044DAD(unsigned int a1)
{
  signed int v1; // eax@1

  v1 = a1;
  if ( a1 > 0xA )
    v1 = 10;
  return off_10074C44[v1];
}
// 10074C44: using guessed type char *off_10074C44[11];

//----- (10044DC4) --------------------------------------------------------
char __cdecl sub_10044DC4(int a1, signed int a2)
{
  char v2; // cl@1
  char v3; // zf@2

  v2 = 1;
  switch ( a1 )
  {
    case 0:
      goto LABEL_2;
    case 1:
      if ( a2 && (unsigned int)a2 <= 0x7FFFFFFF )
        return v2;
      v3 = a2 == -1;
      goto LABEL_3;
    case 2:
      if ( (unsigned int)a2 <= 0x7FFFFFFF )
        return v2;
      v3 = a2 == -1;
      goto LABEL_3;
    case 3:
      if ( a2 )
        goto LABEL_17;
      goto LABEL_4;
    case 4:
    case 5:
LABEL_17:
      if ( (unsigned int)a2 > 0x7FFFFFFF )
        goto LABEL_4;
      return v2;
    case 6:
      if ( a2 >= -7 && a2 < 7 || a2 == 15 || a2 == -15 )
        return v2;
      v3 = a2 == 61440;
      goto LABEL_3;
    case 7:
      if ( !a2 )
        return v2;
      v3 = a2 == 1;
      goto LABEL_3;
    case 8:
      if ( a2 != 1 )
      {
LABEL_2:
        v3 = a2 == 0;
LABEL_3:
        if ( !v3 )
LABEL_4:
          v2 = 0;
      }
      break;
    case 9:
      if ( a2 )
        v2 = ((a2 != 1) - 1) & 1;
      break;
  }
  return v2;
}

//----- (10044E80) --------------------------------------------------------
int __thiscall sub_10044E80(void *this)
{
  void *v1; // esi@1
  int result; // eax@2
  int v3; // ecx@6
  int v4; // edi@6
  int v5; // esi@6
  int v6; // edx@6
  char v7; // [sp-4h] [bp-14h]@2
  char v8; // [sp+4h] [bp-Ch]@6

  v1 = this;
  if ( !sub_10044C13(this, 2u) )
  {
    v7 = LOBYTE(off_10074C4C[0]);
LABEL_6:
    sub_10030027((int)&v8, v7);
    sub_100355DB((int)&v8, (int)&unk_1006D0AC);
    __asm { int     3               ; Trap to Debugger }
    v4 = v3;
    v5 = v3 + 120;
    *(_DWORD *)v3 = &off_10065D20;
    sub_10040112(v3 + 12, v6, v3 + 120);
    *(_DWORD *)(v4 + 36) = 0;
    *(_DWORD *)(v4 + 40) = 0;
    *(_DWORD *)(v4 + 60) = 0;
    *(_DWORD *)(v4 + 64) = 0;
    *(_DWORD *)v5 = 0;
    *(_DWORD *)(v4 + 136) = 0;
    *(_DWORD *)(v4 + 144) = 0;
    *(_DWORD *)(v4 + 148) = 0;
    *(_DWORD *)(v4 + 152) = 0;
    *(_DWORD *)(v4 + 156) = 0;
    *(_DWORD *)(v4 + 180) = 0;
    return v4;
  }
  result = sub_10044C13(v1, 8u);
  if ( !result )
    goto LABEL_6;
  return result;
}
// 10065D20: using guessed type int (__stdcall *off_10065D20)(char);
// 10074C4C: using guessed type char *off_10074C4C[9];

//----- (10044F1A) --------------------------------------------------------
int __thiscall sub_10044F1A(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_10030383(*(LPVOID *)(this + 12));
  return sub_10030383(*(LPVOID *)(v2 + 16));
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (10044F31) --------------------------------------------------------
int __usercall sub_10044F31<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int v2; // esi@1
  char v3; // zf@1

  sub_10035668();
  v2 = v1;
  *(_DWORD *)(a1 - 16) = v1;
  *(_DWORD *)v1 = &off_10065D20;
  v3 = *(_DWORD *)(v1 + 80) == 0;
  *(_DWORD *)(a1 - 4) = 1;
  if ( !v3 )
  {
    sub_10033FC5(*(void **)(v1 + 80));
    *(_DWORD *)(v2 + 80) = 0;
  }
  sub_10030383(*(LPVOID *)(v2 + 156));
  sub_10044F1A(v2 + 12);
  return sub_10035636(4);
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 10065D20: using guessed type int (__stdcall *off_10065D20)(char);

//----- (10044F7C) --------------------------------------------------------
void *__thiscall sub_10044F7C(void *this, char a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1

  v3 = this;
  sub_10044F31(ebp0);
  if ( a2 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10044F9B) --------------------------------------------------------
char __thiscall sub_10044F9B(int this, unsigned int a2)
{
  char result; // al@1
  signed int v3; // edx@1
  int v4; // edi@1

  v3 = 1 << (a2 & 0x1F);
  v4 = 4 * (a2 >> 5);
  result = (v3 & *(_DWORD *)(v4 + *(_DWORD *)(this + 88))) != 0;
  if ( result )
  {
    _EDX = ~v3;
    _ECX = v4 + *(_DWORD *)(this + 88);
    __asm { lock and [ecx], edx }
  }
  return result;
}

//----- (10044FD2) --------------------------------------------------------
int __thiscall sub_10044FD2(void *this, int a2)
{
  void *v2; // edi@1
  int result; // eax@2

  v2 = this;
  if ( a2 )
  {
    sub_10046C65(a2);
    result = (*(int (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)a2 + 28))(a2, v2);
  }
  *((_DWORD *)v2 + 28) = a2;
  if ( a2 )
  {
    if ( *(_BYTE *)(a2 + 179) & 1 )
    {
      ++*((_DWORD *)v2 + 24);
      *(_BYTE *)(a2 + 179) &= 0xFEu;
    }
  }
  return result;
}

//----- (1004500F) --------------------------------------------------------
char __thiscall sub_1004500F(int this)
{
  char result; // al@2

  if ( *(_BYTE *)(this + 86) )
  {
    *(_BYTE *)(this + 86) = 0;
    result = 1;
  }
  else
  {
    result = sub_10044F9B(**(_DWORD **)(this + 68), *(_DWORD *)(this + 132));
  }
  return result;
}

//----- (10045053) --------------------------------------------------------
bool __cdecl sub_10045053(int a1)
{
  bool result; // eax@1

  result = sub_10032DCA(*(_DWORD *)(a1 + 36));
  if ( !result )
  {
    sub_10045135(*(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    *(_DWORD *)(a1 + 72) = 0;
  }
  return result;
}

//----- (1004505F) --------------------------------------------------------
char __thiscall sub_1004505F(int this, int a2, int a3, char a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  char v7; // al@3
  int v8; // edx@3
  char result; // al@6

  v6 = this;
  v4 = this + 4;
  v5 = *(_DWORD *)(this + 4);
  if ( !(v5 & a3) )
    goto LABEL_6;
  if ( a3 == 15 )
  {
    v8 = *(_DWORD *)v4;
    *(_DWORD *)v4 = 0;
    v7 = v8 != 0;
  }
  else
  {
    while ( 1 )
    {
      _ECX = 0;
      _EDX = v6 + 4;
      __asm { lock cmpxchg [edx], ecx }
      v8 = v5;
      if ( v5 == v5 )
        break;
      if ( !(v5 & a3) )
        goto LABEL_6;
    }
    v7 = 1;
  }
  if ( v7 )
  {
    if ( a4 )
    {
      _EDI = -1;
      _ECX = **(_DWORD **)(v6 + 68) + 428;
      _EAX = -1;
      __asm { lock xadd [ecx], eax }
      _ECX = *(_DWORD *)(v6 + 68) + 28;
      _EAX = -1;
      __asm { lock xadd [ecx], eax }
      if ( v8 == 4 || v8 == 8 )
      {
        _ECX = **(_DWORD **)(v6 + 68) + 432;
        _EAX = -1;
        __asm { lock xadd [ecx], eax }
        _ECX = *(_DWORD *)(v6 + 68) + 32;
        __asm { lock xadd [ecx], edi }
      }
    }
    result = 1;
    *(_DWORD *)a2 = v8;
    *(_DWORD *)(a2 + 4) = v6;
    *(_DWORD *)(v6 + 8) = v8;
  }
  else
  {
LABEL_6:
    result = 0;
  }
  return result;
}

//----- (10045104) --------------------------------------------------------
signed int __thiscall sub_10045104(int this, int a2)
{
  signed int result; // eax@1

  result = 1;
  if ( *(_DWORD *)((a2 << 7) + *(_DWORD *)(this + 92)) == 1 )
  {
    _EDX = 0;
    _ECX = (a2 << 7) + *(_DWORD *)(this + 92);
    __asm { lock cmpxchg [ecx], edx }
  }
  return result;
}

//----- (10045129) --------------------------------------------------------
int __thiscall sub_10045129(int this)
{
  return (*(int (**)(void))(**(_DWORD **)(this + 76) + 24))();
}

//----- (10045135) --------------------------------------------------------
int __stdcall sub_10045135(int a1)
{
  int v1; // esi@1
  int v2; // ecx@2
  int result; // eax@3

  v1 = a1;
  while ( v1 )
  {
    v2 = v1 - 176;
    v1 = *(_DWORD *)v1;
    if ( v2 )
      result = (**(int (__stdcall ***)(_DWORD))v2)(1);
  }
  return result;
}

//----- (10045159) --------------------------------------------------------
int __thiscall sub_10045159(int this)
{
  return (*(int (**)(void))(**(_DWORD **)(this + 76) + 28))();
}

//----- (10045165) --------------------------------------------------------
char __thiscall sub_10045165(int this, int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  char result; // al@3
  int v7; // eax@8

  v5 = this;
  v4 = **(_DWORD **)(this + 68);
  if ( a2 == 1 || a2 == 4 )
  {
    if ( sub_1003476A(v4, 1) )
    {
      v7 = a3;
      if ( !a3 )
        v7 = sub_100327A8(v4);
      result = (*(int (__thiscall **)(_DWORD, _DWORD, _DWORD))(*(_DWORD *)v5 + 28))(v5, v7, a4);
    }
    else
    {
      if ( a4 )
        sub_10033A94(v4, a4, 1);
      sub_100453E2(v5, a2, 0);
      result = 0;
    }
  }
  else
  {
    (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(this + 76) + 20))(*(_DWORD *)(this + 116));
    result = 1;
  }
  return result;
}

//----- (100451D9) --------------------------------------------------------
char __thiscall sub_100451D9(int this, int a2)
{
  char result; // al@1
  int v3; // esi@1

  v3 = this;
  result = 0;
  if ( *(_DWORD *)this )
  {
    result = sub_10045165(
               *(_DWORD *)(this + 4),
               *(_DWORD *)this,
               *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 4) + 68) + 4) + 8),
               a2);
    *(_DWORD *)v3 = 0;
  }
  return result;
}

//----- (10045204) --------------------------------------------------------
int __usercall sub_10045204<eax>(int a1<ecx>, int a2<ebp>, int a3<edi>)
{
  int v3; // esi@1

  v3 = a1;
  if ( !*(_DWORD *)(a1 + 80) )
    *(_DWORD *)(a1 + 80) = sub_10032C57(a2, a3);
  return *(_DWORD *)(v3 + 80);
}

//----- (1004521D) --------------------------------------------------------
int __thiscall sub_1004521D(int this, int a2, int a3)
{
  int v3; // ebx@1
  int *v4; // eax@1
  int v5; // edi@1
  int v6; // eax@1
  int v7; // eax@1
  int v9; // eax@4
  int v10; // eax@4
  int v11; // esi@4
  int v12; // ST0C_4@4
  int v13; // eax@4
  int v14; // [sp-4h] [bp-20h]@2
  char v15; // [sp+Ch] [bp-10h]@4
  int v16; // [sp+24h] [bp+8h]@1

  v3 = this;
  *(_DWORD *)(this + 184) = 0;
  *(_DWORD *)(this + 108) = 0;
  *(_DWORD *)(this + 68) = a2;
  *(_DWORD *)(this + 204) = 1;
  *(_DWORD *)(this + 192) = 1;
  *(_DWORD *)(this + 72) = *(_DWORD *)(a2 + 4);
  v4 = *(int **)(this + 68);
  *(_WORD *)(this + 160) = 0;
  *(_DWORD *)(this + 76) = a3;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 92) = 0;
  *(_DWORD *)(this + 96) = 0;
  *(_DWORD *)(this + 100) = 0;
  *(_DWORD *)(this + 104) = 0;
  *(_DWORD *)(this + 112) = 0;
  *(_DWORD *)(this + 164) = 0;
  *(_DWORD *)(this + 180) = 0;
  *(_DWORD *)(this + 80) = 0;
  *(_WORD *)(this + 84) = 0;
  *(_BYTE *)(this + 86) = 1;
  v5 = *v4;
  v16 = *v4;
  *(_DWORD *)(this + 124) = (*(int (__thiscall **)(int))(*(_DWORD *)a3 + 16))(a3);
  v6 = (*(int (__thiscall **)(int))(*(_DWORD *)a3 + 4))(a3);
  *(_DWORD *)(v3 + 128) = v6;
  *(_DWORD *)(v3 + 132) = sub_10032C26(v5, v6);
  v7 = sub_1003D69A();
  sub_10032CDB((void *)(v3 + 152), v7);
  sub_100459D0(v3 + 152);
  *(_DWORD *)(*(_DWORD *)(v3 + 156) + 4 * (*(_DWORD *)(v3 + 132) >> 5)) |= 1 << (*(_DWORD *)(v3 + 132) & 0x1F);
  if ( *(_DWORD *)(v16 + 12) )
    v14 = 2;
  else
    v14 = 1;
  sub_10051D79(v3 + 36, v3, v14);
  v9 = (*(int (**)(void))(***(_DWORD ***)(v3 + 68) + 4))();
  v10 = sub_1004D6B9((int)&v15, 3, *(_DWORD *)(v3 + 128), v9, v3);
  sub_1002F3E5(v3 + 136, v10);
  v11 = *(_DWORD *)(v3 + 132);
  sub_1004539C(v16 + 72, *(_DWORD *)(v3 + 132));
  sub_10045104(v16, v11);
  v12 = *(_DWORD *)(v3 + 124);
  v13 = (*(int (**)(void))(***(_DWORD ***)(v3 + 68) + 4))();
  return sub_10045945(1, 4, v13, v12);
}

//----- (1004535A) --------------------------------------------------------
int __thiscall sub_1004535A(int this, unsigned int a2)
{
  int v2; // ebx@1
  int v3; // esi@1

  v2 = this;
  _ESI = -1;
  _EAX = *(_DWORD *)(this + 8) + 4 * a2;
  __asm { lock xadd [eax], esi }
  v3 = _ESI - 1;
  if ( !v3 )
  {
    sub_100457F9(this, a2);
    _EDX = ~(1 << (a2 & 0x1F));
    _ECX = *(_DWORD *)(v2 + 4) + 4 * (a2 >> 5);
    __asm { lock and [ecx], edx }
  }
  return v3;
}

//----- (1004539C) --------------------------------------------------------
int __thiscall sub_1004539C(int this, unsigned int a2)
{
  int v2; // esi@1
  int v13; // [sp+Ch] [bp-4h]@1

  v13 = this;
  _EAX = *(_DWORD *)(this + 8) + 4 * a2;
  _ESI = 1;
  __asm { lock xadd [eax], esi }
  v2 = _ESI + 1;
  if ( v2 == 1 )
  {
    sub_100457B1(this, a2);
    _EDI = 1 << (a2 & 0x1F);
    _ECX = *(_DWORD *)(v13 + 4) + 4 * (a2 >> 5);
    __asm { lock or [ecx], edi }
  }
  return v2;
}

//----- (100453E2) --------------------------------------------------------
int __thiscall sub_100453E2(int this, int a2, char a3)
{
  int v4; // edi@1
  int result; // eax@8

  v4 = this;
  _EBX = 1;
  *(_DWORD *)(this + 116) = *(_DWORD *)(this + 112);
  if ( a3 )
  {
    if ( a2 == 1 || a2 == 4 )
      sub_1003476A(**(_DWORD **)(this + 68), 0);
  }
  _ECX = **(_DWORD **)(v4 + 68) + 428;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  _ECX = *(_DWORD *)(v4 + 68) + 28;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  if ( a2 == 4 || a2 == 8 )
  {
    _ECX = **(_DWORD **)(v4 + 68) + 432;
    _EAX = 1;
    __asm { lock xadd [ecx], eax }
    _EAX = *(_DWORD *)(v4 + 68) + 32;
    __asm { lock xadd [eax], ebx }
  }
  result = v4 + 4;
  *(_DWORD *)(v4 + 4) = a2;
  return result;
}

//----- (10045460) --------------------------------------------------------
char __thiscall sub_10045460(int this)
{
  char result; // al@1
  int v2; // esi@1
  int v3; // ecx@5
  int v4; // ST00_4@5
  int v5; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@5

  v5 = 0;
  v2 = this;
  result = sub_1004505F(this, (int)&v5, 15, 1);
  if ( result )
  {
    if ( v5 == 2 || v5 == 8 )
    {
      v3 = v6;
      v4 = v5;
      *(_BYTE *)(v2 + 161) = 1;
      result = sub_10045165(v3, v4, 0, 0);
    }
    else
    {
      result = (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 12))(v2);
    }
  }
  else
  {
    *(_BYTE *)(v2 + 161) = 1;
  }
  return result;
}

//----- (100454B4) --------------------------------------------------------
int __thiscall sub_100454B4(int this)
{
  int v2; // esi@1
  int v3; // eax@1

  v2 = this;
  v3 = (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(**(_DWORD **)(this + 68) + 420) + 20))(*(_DWORD *)(this + 76));
  return sub_10045C79(*(void **)(v2 + 68), v3, 1);
}

//----- (100454D7) --------------------------------------------------------
signed int __thiscall sub_100454D7(int this)
{
  signed int v1; // ebx@1
  int v2; // edi@1
  int v3; // eax@1
  int v4; // edx@1
  int v5; // eax@1
  signed int result; // eax@5

  v3 = *(_DWORD *)(this + 12);
  v2 = *(_DWORD *)(this + 4) - 1;
  v4 = v2 & *(_DWORD *)(this + 8);
  *(_DWORD *)(this + 4) = v2;
  v5 = v3 + 4 * v4;
  v1 = *(_DWORD *)v5;
  *(_DWORD *)v5 = 0;
  if ( !v1 )
    *(_DWORD *)(this + 4) = v2 + 1;
  if ( !(v1 & 1) || (v1 &= 0xFFFFFFFEu, sub_1002E6D7(*(_DWORD *)(this + 16) + 8 * (v2 & *(_DWORD *)(this + 8)), 0)) )
    result = v1;
  else
    result = 1;
  return result;
}

//----- (10045525) --------------------------------------------------------
char __thiscall sub_10045525(void *ListHead, int a2, signed int a3, char a4)
{
  signed int v4; // edx@1
  int v6; // esi@1
  char result; // al@2
  int v8; // eax@3
  int v9; // ecx@3
  int v10; // edx@4
  int v11; // edi@4
  int v12; // edx@5
  PSINGLE_LIST_ENTRY v18; // eax@14
  int v19; // ST08_4@14

  v6 = (int)ListHead;
  v4 = a3 >> *((_DWORD *)ListHead + 11);
  _EBX = a3 & (*((_DWORD *)ListHead + 10) - 1);
  if ( v4 < *((_DWORD *)ListHead + 15) )
  {
    v9 = *((_DWORD *)ListHead + 14);
    v8 = *(_DWORD *)(v6 + 52);
    if ( v4 < v9 )
    {
      v11 = *(_DWORD *)(v8 + 4 * v4);
    }
    else
    {
      v10 = v4 - v9;
      v11 = *(_DWORD *)(v8 + 4 * v9 - 4);
      if ( v10 >= 0 )
      {
        v12 = v10 + 1;
        do
        {
          v11 = *(_DWORD *)(v11 + 4);
          --v12;
        }
        while ( v12 );
      }
    }
    _ECX = *(_DWORD *)v11 + 4 * _EBX;
    _EDX = 0;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 == a2 )
    {
      _ECX = v11 + 8;
      __asm { lock cmpxchg [ecx], ebx }
      if ( a4 )
      {
        if ( (signed int)QueryDepthSList((PSLIST_HEADER)v6) <= *(_DWORD *)(v6 + 68) )
        {
          InterlockedPushEntrySList((PSLIST_HEADER)v6, (PSINGLE_LIST_ENTRY)(a2 + 176));
        }
        else
        {
          InterlockedPushEntrySList((PSLIST_HEADER)(v6 + 8), (PSINGLE_LIST_ENTRY)(a2 + 176));
          if ( (signed int)QueryDepthSList((PSLIST_HEADER)(v6 + 8)) > *(_DWORD *)(v6 + 68) )
          {
            if ( !sub_10032DCA(*(_DWORD *)(v6 + 36)) )
            {
              _EDX = 1;
              _ECX = v6 + 72;
              __asm { lock cmpxchg [ecx], edx }
              v18 = InterlockedFlushSList((PSLIST_HEADER)(v6 + 8));
              v19 = *(_DWORD *)(v6 + 36);
              *(_DWORD *)(v6 + 16) = v18;
              sub_1003337E(v6 + 20, (int (__cdecl *)(_DWORD))sub_10045053, v6, v19);
            }
          }
        }
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10045620) --------------------------------------------------------
char __thiscall sub_10045620(int this)
{
  int v2; // edi@1
  int v16; // ecx@5
  int v17; // ebx@6
  int v18; // edi@9
  int v19; // esi@10
  int v20; // esi@15
  int v21; // eax@15
  int v22; // ecx@15
  int v23; // eax@15
  int v24; // ecx@15
  int v25; // eax@15
  int v27; // ecx@17
  char v28; // [sp-10h] [bp-24h]@10
  int v29; // [sp-Ch] [bp-20h]@10
  int v30; // [sp-8h] [bp-1Ch]@10
  int v31; // [sp-4h] [bp-18h]@10
  int v32; // [sp+Ch] [bp-8h]@1
  int v33; // [sp+10h] [bp-4h]@5

  v2 = this;
  v32 = this;
  sub_10033E20(**(_DWORD **)(this + 68), this + 192);
  sub_1004535A(**(_DWORD **)(v2 + 68) + 48, *(_DWORD *)(v2 + 132));
  _EDX = -1;
  _ECX = *(_DWORD *)(v2 + 68) + 36;
  _EAX = -1;
  __asm { lock xadd [ecx], eax }
  if ( !*(_BYTE *)(v2 + 160) )
  {
    _EAX = **(_DWORD **)(v2 + 68) + 20;
    __asm { lock xadd [eax], edx }
  }
  sub_10045777(**(void ***)(v2 + 68), v2);
  if ( !*(_BYTE *)(v2 + 84) )
    sub_1004535A(**(_DWORD **)(v2 + 68) + 72, *(_DWORD *)(v2 + 132));
  *(_DWORD *)(v2 + 112) = 0;
  v16 = *(_DWORD *)(v2 + 16) - *(_DWORD *)(v2 + 12);
  v33 = v2 + 12;
  if ( v16 <= 0 )
    v17 = 0;
  else
    v17 = sub_100454D7(v2 + 12);
  if ( v17 )
  {
    v18 = v33;
    do
    {
      v19 = sub_1003D44F(v17 + 4);
      sub_1002F3E5((int)&v28, v19 + 12);
      sub_10040C95((void *)v19, v17, v28, v29, v30, v31);
      if ( *(_DWORD *)(v18 + 4) - *(_DWORD *)v18 <= 0 )
        v17 = 0;
      else
        v17 = sub_100454D7(v18);
    }
    while ( v17 );
    v2 = v32;
  }
  v20 = **(_DWORD **)(v2 + 76);
  v21 = (*(int (**)(void))(***(_DWORD ***)(v2 + 68) + 52))();
  v22 = *(_DWORD *)(v2 + 76);
  v31 = v21;
  (*(void (__thiscall **)(int))(v20 + 8))(v22);
  v23 = *(_DWORD *)(v2 + 68);
  *(_DWORD *)(v2 + 76) = 0;
  v24 = *(_DWORD *)v23;
  v30 = *(_DWORD *)(v2 + 124);
  v25 = (*(int (__stdcall **)(int))(*(_DWORD *)v24 + 4))(v30);
  sub_10045945(2, 4, v25, v31);
  if ( *(_DWORD *)(v2 + 80) )
  {
    v31 = *(_DWORD *)(v2 + 80);
    sub_10033FC5((void *)v31);
    *(_DWORD *)(v2 + 80) = 0;
  }
  v27 = *(_DWORD *)(v2 + 68);
  v31 = 1;
  v30 = *(_DWORD *)(v2 + 88);
  return sub_10045525((void *)(v27 + 56), v2, v30, 1);
}

//----- (10045763) --------------------------------------------------------
char __thiscall sub_10045763(int this)
{
  return sub_10033457(**(_DWORD **)(this + 68), this + 180);
}

//----- (10045777) --------------------------------------------------------
int __thiscall sub_10045777(void *this, int a2)
{
  int result; // eax@1
  int v3; // esi@1
  void *v5; // edi@1

  v3 = a2;
  _EDX = *(_DWORD *)(a2 + 92) - *(_DWORD *)(a2 + 100);
  v5 = this;
  *(_DWORD *)(a2 + 100) = *(_DWORD *)(a2 + 92);
  _EAX = (int)((char *)this + 436);
  __asm { lock xadd [eax], edx }
  _ECX = *(_DWORD *)(v3 + 96) - *(_DWORD *)(v3 + 104);
  *(_DWORD *)(v3 + 104) = *(_DWORD *)(v3 + 96);
  result = (int)((char *)v5 + 440);
  __asm { lock xadd [eax], ecx }
  return result;
}

//----- (100457B1) --------------------------------------------------------
int __thiscall sub_100457B1(int this, unsigned int a2)
{
  int result; // eax@1
  int v3; // ebx@1
  signed int v4; // edi@1
  char v5; // [sp+Ch] [bp-10h]@3
  int v6; // [sp+14h] [bp-8h]@2
  void (__cdecl *v7)(); // [sp+18h] [bp-4h]@2

  v3 = *(_DWORD *)(this + 4);
  v4 = 1 << (a2 & 0x1F);
  result = *(_DWORD *)(v3 + 4 * (a2 >> 5));
  if ( result & v4 )
  {
    v6 = 0;
    v7 = sub_10034BD7;
    while ( 1 )
    {
      result = *(_DWORD *)(v3 + 4 * (a2 >> 5));
      if ( !(result & v4) )
        break;
      sub_100282E0((int)&v5);
    }
  }
  return result;
}

//----- (100457F9) --------------------------------------------------------
int __thiscall sub_100457F9(int this, unsigned int a2)
{
  int result; // eax@1
  int v3; // ebx@1
  signed int v4; // edi@1
  char v5; // [sp+Ch] [bp-10h]@3
  int v6; // [sp+14h] [bp-8h]@2
  void (__cdecl *v7)(); // [sp+18h] [bp-4h]@2

  v3 = *(_DWORD *)(this + 4);
  v4 = 1 << (a2 & 0x1F);
  result = *(_DWORD *)(v3 + 4 * (a2 >> 5));
  if ( !(result & v4) )
  {
    v6 = 0;
    v7 = sub_10034BD7;
    while ( 1 )
    {
      result = *(_DWORD *)(v3 + 4 * (a2 >> 5));
      if ( result & v4 )
        break;
      sub_100282E0((int)&v5);
    }
  }
  return result;
}

//----- (10045841) --------------------------------------------------------
char __thiscall sub_10045841(int this, int a2, int a3)
{
  int v3; // esi@1
  int v4; // edi@4
  char result; // al@9
  char v6; // [sp+Ch] [bp-10h]@3
  int v7; // [sp+14h] [bp-8h]@2
  void (__cdecl *v8)(); // [sp+18h] [bp-4h]@2

  v3 = this;
  if ( *(_DWORD *)(this + 112) )
  {
    v7 = 0;
    v8 = sub_10034BD7;
    do
      sub_100282E0((int)&v6);
    while ( *(_DWORD *)(v3 + 112) );
  }
  v4 = a3;
  if ( a3 )
  {
    if ( !*(_DWORD *)(a3 + 28) )
      sub_10046AD3(a3, a2, 0, 0);
  }
  else
  {
    v4 = sub_100410E3((void *)a2, 0, 0);
  }
  if ( v4 )
  {
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 16))(v3, v4);
    (*(void (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(v3 + 76) + 20))(*(_DWORD *)(v3 + 76), *(_DWORD *)(v3 + 112));
    result = 1;
  }
  else
  {
    sub_100453E2(v3, 4, 1);
    sub_1003224B(**(_DWORD **)(v3 + 68));
    result = 0;
  }
  return result;
}

//----- (100458CA) --------------------------------------------------------
int __cdecl sub_100458CA(char a1, char a2, int a3, int a4)
{
  int v4; // ebx@1
  int result; // eax@2
  __int16 v6; // [sp+4h] [bp-40h]@2
  char v7; // [sp+6h] [bp-3Eh]@2
  char v8; // [sp+8h] [bp-3Ch]@2
  char v9; // [sp+9h] [bp-3Bh]@2
  int v10; // [sp+1Ch] [bp-28h]@2
  int v11; // [sp+20h] [bp-24h]@2
  int v12; // [sp+24h] [bp-20h]@2
  int v13; // [sp+28h] [bp-1Ch]@2
  int v14; // [sp+30h] [bp-14h]@2
  int v15; // [sp+34h] [bp-10h]@2
  int v16; // [sp+38h] [bp-Ch]@2

  v4 = dword_100766D8;
  if ( dword_100766D8 )
  {
    sub_10039210(&v7, 0, 62);
    v14 = 131072;
    v6 = 64;
    v8 = a1;
    v9 = a2;
    v10 = dword_100682F4[0];
    v11 = dword_100682F4[1];
    v12 = dword_100682F4[2];
    v13 = dword_100682F4[3];
    v16 = a3;
    v15 = a4;
    result = sub_10030F35(v4, dword_100766D0, dword_100766D4, (int)&v6);
  }
  return result;
}
// 100766D0: using guessed type int dword_100766D0;
// 100766D4: using guessed type int dword_100766D4;
// 100766D8: using guessed type int dword_100766D8;

//----- (1004593B) --------------------------------------------------------
int __stdcall sub_1004593B(int a1)
{
  return a1;
}

//----- (10045945) --------------------------------------------------------
int __stdcall sub_10045945(char a1, char a2, int a3, int a4)
{
  int result; // eax@2

  if ( a2 <= (unsigned __int8)byte_100766CC )
  {
    result = dword_100766C8;
    if ( dword_100766C8 & 4 )
      result = sub_100458CA(a1, a2, a3, a4);
  }
  return result;
}
// 100766C8: using guessed type int dword_100766C8;
// 100766CC: using guessed type char byte_100766CC;

//----- (10045972) --------------------------------------------------------
char __thiscall sub_10045972(int this, char a2, char a3)
{
  int v3; // eax@1
  int v4; // edi@1
  int v5; // esi@3
  unsigned int v6; // ST00_4@3
  char result; // al@6
  int v8; // [sp+8h] [bp-4h]@1

  v4 = this;
  v3 = **(_DWORD **)(this + 68);
  v8 = **(_DWORD **)(this + 68);
  if ( *(_BYTE *)(this + 84) )
  {
    if ( !a2 )
    {
      v5 = *(_DWORD *)(this + 132);
      v6 = *(_DWORD *)(this + 132);
      *(_BYTE *)(this + 86) = 1;
      sub_1004539C(v3 + 72, v6);
      sub_10045104(v8, v5);
    }
  }
  else
  {
    if ( a2 )
      sub_1004535A(v3 + 72, *(_DWORD *)(this + 132));
  }
  result = a3;
  *(_BYTE *)(v4 + 84) = a2;
  *(_BYTE *)(v4 + 85) = a3;
  return result;
}

//----- (100459D0) --------------------------------------------------------
int __thiscall sub_100459D0(int this)
{
  unsigned int v1; // edx@1
  unsigned int v2; // esi@1
  int result; // eax@2

  v1 = (unsigned int)(*(_DWORD *)this + 31) >> 5;
  v2 = 0;
  if ( v1 )
  {
    do
    {
      result = *(_DWORD *)(this + 4);
      *(_DWORD *)(result + 4 * v2++) = 0;
    }
    while ( v2 < v1 );
  }
  return result;
}

//----- (100459ED) --------------------------------------------------------
int __userpurge sub_100459ED<eax>(int a1<ebp>, int a2, int a3, int a4)
{
  int v5; // ecx@1
  int v6; // edi@1
  int *v7; // esi@1
  int v8; // ST08_4@1
  int v9; // eax@1
  int v10; // ST00_4@1
  int v11; // ecx@1

  sub_10035668();
  v6 = v5;
  *(_DWORD *)(a1 - 16) = v5;
  v7 = *(int **)(a1 + 16);
  v8 = *(_DWORD *)(a1 + 8);
  v5 += 8;
  *(_DWORD *)(v6 + 4) = v7;
  *(_DWORD *)v5 = 0;
  *(_DWORD *)(v5 + 4) = 0;
  sub_1003217C(v5, v6, v8);
  *(_DWORD *)(a1 - 4) = 0;
  sub_1002E10F(v6 + 16, 0, v6, 0x1001u);
  v9 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(v6 + 28) = 0;
  *(_DWORD *)(v6 + 32) = 0;
  *(_DWORD *)(v6 + 36) = 0;
  *(_DWORD *)(v6 + 40) = 0;
  *(_DWORD *)(v6 + 44) = v9;
  v10 = *v7;
  *(_BYTE *)(a1 - 4) = 1;
  sub_10031259((void *)(v6 + 56), v10, 256, 2147483647);
  v11 = *(_DWORD *)(v6 + 4);
  *(_DWORD *)v6 = *(_DWORD *)v11;
  *(_DWORD *)(v6 + 48) = *(_DWORD *)(v11 + 184);
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (10045A6A) --------------------------------------------------------
int __thiscall sub_10045A6A(PSLIST_HEADER ListHead)
{
  int v1; // ebx@1
  PSLIST_HEADER v2; // edi@1
  int v3; // eax@1
  int v4; // eax@1
  int i; // esi@2
  int v6; // ecx@3
  int v7; // esi@6

  v2 = ListHead;
  v3 = (int)InterlockedFlushSList(ListHead);
  sub_10045135(v3);
  v4 = (int)InterlockedFlushSList(v2 + 1);
  sub_10045135(v4);
  sub_10045135(LODWORD(v2[2].Alignment));
  v1 = LODWORD(v2[6].Alignment);
  if ( v1 )
  {
    do
    {
      for ( i = 0; i < LODWORD(v2[5].Alignment); ++i )
      {
        v6 = *(_DWORD *)(*(_DWORD *)v1 + 4 * i);
        if ( v6 )
          (**(void (__stdcall ***)(_DWORD))v6)(1);
      }
      v7 = *(_DWORD *)(v1 + 4);
      sub_10030383(*(LPVOID *)v1);
      sub_1002A4AA((LPVOID)v1);
      v1 = v7;
    }
    while ( v7 );
  }
  return sub_10030383(HIDWORD(v2[6].Alignment));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (10045AE0) --------------------------------------------------------
int __usercall sub_10045AE0<eax>(int a1<ebp>)
{
  int v2; // ecx@1
  int v3; // edi@1

  sub_10035668();
  v3 = v2;
  *(_DWORD *)(a1 - 16) = v2;
  *(_DWORD *)(a1 - 4) = 1;
  sub_10045A6A((PSLIST_HEADER)(v2 + 56));
  sub_10034867(v3 + 16);
  sub_10030383(*(LPVOID *)(v3 + 24));
  sub_10030383(*(LPVOID *)(v3 + 12));
  return sub_10035636(4);
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (10045B20) --------------------------------------------------------
int __thiscall sub_10045B20(int this, int a2)
{
  signed int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // edx@3
  int v12; // ecx@11
  signed __int64 v15; // qax@11
  signed int v16; // ST0C_4@11
  int v17; // edx@11
  int v18; // ecx@11
  int v19; // eax@12
  int v28; // edx@17
  char v30; // [sp+Ch] [bp-20h]@22
  int v31; // [sp+14h] [bp-18h]@21
  BOOL (__cdecl *v32)(); // [sp+18h] [bp-14h]@21
  int v33; // [sp+1Ch] [bp-10h]@5
  int v34; // [sp+20h] [bp-Ch]@2
  int v35; // [sp+24h] [bp-8h]@1
  char v36; // [sp+2Bh] [bp-1h]@1

  v5 = this;
  v3 = *(_DWORD *)(this + 48);
  v36 = 0;
  v4 = 0;
  v35 = v3;
  v2 = 4;
  do
  {
    _EBX = v3 + 8;
    v34 = v3 + 8;
    if ( *(_DWORD *)(v3 + 8) >= -1 )
    {
      _EBX = *(_DWORD *)v3;
      v7 = 0;
      if ( *(_DWORD *)(v5 + 40) <= 0 )
      {
LABEL_7:
        _EBX = v34;
      }
      else
      {
        while ( *(_DWORD *)_EBX )
        {
          ++v7;
          _EBX += v2;
          if ( v7 >= *(_DWORD *)(v5 + 40) )
            goto LABEL_7;
        }
        _ECX = a2;
        *(_DWORD *)(a2 + 88) = v7 + v4;
        v33 = *(_DWORD *)(v5 + 64);
        __asm { lock cmpxchg [ebx], ecx }
        v4 += v7;
        v36 = 1;
        if ( v4 >= v33 )
        {
          _EAX = v5 + 64;
          _ECX = 1;
          __asm { lock xadd [eax], ecx }
        }
        _EBX = v34;
        _ECX = -1;
        __asm { lock cmpxchg [ebx], ecx }
      }
      v3 = v35;
    }
    if ( !v36 )
    {
      _ECX = -2;
      __asm { lock cmpxchg [ebx], ecx }
      v4 += *(_DWORD *)(v5 + 40);
      _EBX = v3 + 4;
      if ( !*(_DWORD *)(v3 + 4) )
      {
        _ECX = 1;
        __asm { lock cmpxchg [ebx], ecx }
        _ECX = 0;
        v15 = 4i64 * *(_DWORD *)(v5 + 40);
        __asm { seto    cl }
        v16 = 4 * *(_DWORD *)(v5 + 40);
        v33 = sub_1002965B(SHIDWORD(v15), v15 | -_ECX, _EBX, v4, v15 | -_ECX);
        sub_10039210((void *)v33, 0, v16);
        v12 = sub_1002ADB1(v17, v18, _EBX, v4, 12);
        if ( v12 )
        {
          v19 = v33;
          *(_DWORD *)(v12 + 4) = 0;
          *(_DWORD *)(v12 + 8) = -1;
          *(_DWORD *)v12 = v19;
        }
        else
        {
          v12 = 0;
        }
        v28 = *(_DWORD *)(v5 + 60);
        if ( v28 < *(_DWORD *)(v5 + 56) )
        {
          *(_DWORD *)(*(_DWORD *)(v5 + 52) + 4 * v28) = v12;
          ++*(_DWORD *)(v5 + 60);
        }
        *(_DWORD *)_EBX = v12;
        v3 = v35;
      }
      if ( *(_DWORD *)_EBX == 1 )
      {
        v31 = 0;
        v32 = sub_10034C15;
        do
          sub_100282E0((int)&v30);
        while ( *(_DWORD *)_EBX == 1 );
        v3 = v35;
      }
    }
    v3 = *(_DWORD *)(v3 + 4);
    v35 = v3;
    v2 = 4;
  }
  while ( !v36 );
  return v4;
}

//----- (10045C79) --------------------------------------------------------
int __thiscall sub_10045C79(void *this, int a2, char a3)
{
  PSINGLE_LIST_ENTRY v3; // eax@1
  int v4; // ebx@1
  int *v5; // edi@1
  int v6; // esi@2
  int v14; // ecx@11

  v5 = (int *)this;
  v4 = (int)sub_10032365();
  v3 = InterlockedPopEntrySList((PSLIST_HEADER)v5 + 7);
  if ( v3 && (v6 = (int)&v3[-44], v3 != (PSINGLE_LIST_ENTRY)176) )
    (*(void (__thiscall **)(int, int *, int))(*(_DWORD *)v6 + 24))(v6, v5, a2);
  else
    v6 = (*(int (__stdcall **)(int *, int))(*(_DWORD *)*v5 + 92))(v5, a2);
  if ( a3 )
  {
    *(_BYTE *)(v6 + 160) = 1;
    *(_DWORD *)(v6 + 164) = v4 - 4;
    *(_DWORD *)(v4 - 4 + 164) = v6;
  }
  _EAX = (int)(v5 + 9);
  _ECX = 1;
  __asm { lock xadd [eax], ecx }
  sub_1004539C(*v5 + 48, *(_DWORD *)(v6 + 132));
  if ( *(_DWORD *)(*v5 + 428) != *(_DWORD *)(*v5 + 432) || *(_DWORD *)(*v5 + 20) <= 0 )
  {
    sub_10045B20((int)(v5 + 14), v6);
    sub_100453E2(v6, 1, 0);
  }
  else
  {
    sub_10045B20((int)(v5 + 14), v6);
    if ( sub_1003476A(*v5, 1) )
    {
      if ( v4 )
        v14 = sub_1003D44F(v4);
      else
        v14 = *(_DWORD *)(v5[1] + 8);
      (*(void (__thiscall **)(int, int, _DWORD))(*(_DWORD *)v6 + 28))(v6, v14, 0);
    }
  }
  return v6;
}

//----- (10045D62) --------------------------------------------------------
char __thiscall sub_10045D62(void *this)
{
  LPVOID v1; // eax@1
  void *v2; // edi@1
  int v3; // esi@2
  char v4; // bl@5

  v2 = this;
  v1 = sub_10032365();
  if ( v1 )
    v3 = (int)((char *)v1 - 4);
  else
    v3 = 0;
  if ( !sub_10033340(**(_DWORD **)v2 + 60, *(_DWORD *)v2 + 4)
    || (v4 = 1,
        (1 << (*(_DWORD *)(*(_DWORD *)(v3 + 160) + 132) & 0x1F)) & *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v2 + 8)
                                                                             + 4
                                                                             * (*(_DWORD *)(*(_DWORD *)(v3 + 160) + 132) >> 5))) )
    v4 = 0;
  return v4;
}

//----- (10045DB8) --------------------------------------------------------
int __thiscall sub_10045DB8(int this, int a2)
{
  signed int v2; // edi@1
  signed int v3; // esi@1
  int v4; // eax@2
  int result; // eax@3
  int i; // [sp+Ch] [bp-4h]@2

  v2 = *(_DWORD *)(this + 120);
  v3 = 0;
  if ( v2 <= 0 )
  {
LABEL_7:
    result = 0;
  }
  else
  {
    v4 = this + 56;
    for ( i = this + 56; ; v4 = i )
    {
      result = sub_1004099B(v4, v3);
      if ( result )
      {
        if ( *(_DWORD *)(result + 76) == a2 )
          break;
      }
      ++v3;
      if ( v3 >= v2 )
        goto LABEL_7;
    }
  }
  return result;
}

//----- (10045DF5) --------------------------------------------------------
int __thiscall sub_10045DF5(void *this, int a2)
{
  void *v2; // ebx@1
  int result; // eax@2
  signed int v4; // esi@5

  v2 = this;
  if ( (*(_DWORD *)a2 & 0xFFFFFFF) == 3 )
  {
    if ( *(_DWORD *)(a2 + 4) == *(_DWORD *)(*(_DWORD *)this + 372) )
    {
      result = *(_DWORD *)(a2 + 12);
    }
    else
    {
      v4 = 0;
      if ( *((_DWORD *)this + 30) <= 0 )
      {
LABEL_9:
        result = 0;
      }
      else
      {
        while ( 1 )
        {
          result = sub_1004099B((int)((char *)v2 + 56), v4);
          if ( result )
          {
            if ( *(_DWORD *)(result + 128) == *(_DWORD *)(a2 + 8) )
              break;
          }
          ++v4;
          if ( v4 >= *((_DWORD *)v2 + 30) )
            goto LABEL_9;
        }
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10045E52) --------------------------------------------------------
char __thiscall sub_10045E52(void *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  char v7; // bl@1
  void *v8; // esi@1
  int v9; // eax@2
  signed int v10; // edi@4
  int v11; // eax@5

  v7 = 1;
  v8 = this;
  if ( (a3 & 0xFFFFFFF) != 3 || (v9 = sub_10045DF5(this, (int)&a3), !v9) || !sub_1004505F(v9, a2, a7, 1) )
  {
    v10 = 0;
    if ( *((_DWORD *)v8 + 30) <= 0 )
    {
LABEL_8:
      v7 = 0;
    }
    else
    {
      while ( 1 )
      {
        v11 = sub_1004099B((int)((char *)v8 + 56), v10);
        if ( v11 )
        {
          if ( sub_1004505F(v11, a2, a7, 1) )
            break;
        }
        ++v10;
        if ( v10 >= *((_DWORD *)v8 + 30) )
          goto LABEL_8;
      }
    }
  }
  return v7;
}

//----- (10045EC2) --------------------------------------------------------
int __thiscall sub_10045EC2(void *this, int a2)
{
  void *v3; // esi@1
  int v4; // ST0C_4@1
  int v5; // eax@1

  v3 = this;
  v4 = (int)this;
  v5 = (*(int (**)(void))(**(_DWORD **)this + 4))();
  sub_1004D6B9(a2, 2, *((_DWORD *)v3 + 12), v5, v4);
  return a2;
}

//----- (10045EE6) --------------------------------------------------------
int __userpurge sub_10045EE6<eax>(int a1<ebp>, int a2)
{
  int v3; // ecx@1
  void *v4; // edi@1
  void *v5; // esi@1
  int v6; // ST00_4@1

  sub_10035668();
  v4 = (void *)v3;
  v5 = *(void **)(v3 + 20);
  *(_DWORD *)(a1 - 16) = v5;
  sub_10034BBC(v5);
  v6 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  sub_1004042F(v4, v6);
  *(_DWORD *)(a1 - 4) = -1;
  sub_10034BCC(v5);
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (10045F26) --------------------------------------------------------
void *__thiscall sub_10045F26(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v4; // edi@1

  v4 = this;
  *(_DWORD *)this = off_10065D48;
  sub_1002E166(0, ebp0, a2, 0);
  *((_BYTE *)v4 + 179) &= 0xFCu;
  *(_DWORD *)v4 = off_10065D60;
  *((_DWORD *)v4 + 1) = off_10065D8C;
  *((_DWORD *)v4 + 39) = 0;
  *((_DWORD *)v4 + 40) = 0;
  *((_DWORD *)v4 + 41) = 0;
  *((_DWORD *)v4 + 42) = 0;
  *((_DWORD *)v4 + 43) = 0;
  *((_BYTE *)v4 + 176) = 0;
  *((_BYTE *)v4 + 178) = 0;
  *((_DWORD *)v4 + 57) = 0;
  *((_DWORD *)v4 + 7) = 0;
  *((_BYTE *)v4 + 236) = 1;
  return v4;
}
// 10065D48: using guessed type int (*off_10065D48[5])();
// 10065D60: using guessed type int (*off_10065D60[3])();
// 10065D8C: using guessed type int (*off_10065D8C[5])();

//----- (10045F99) --------------------------------------------------------
int __userpurge sub_10045F99<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10061D3C;
  return v4;
}
// 10061D3C: using guessed type int (__stdcall *off_10061D3C)(char);

//----- (10045FB4) --------------------------------------------------------
int __userpurge sub_10045FB4<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10061D30;
  return v4;
}
// 10061D30: using guessed type int (__stdcall *off_10061D30)(char);

//----- (10045FCF) --------------------------------------------------------
int __userpurge sub_10045FCF<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10061D78;
  return v4;
}
// 10061D78: using guessed type int (__stdcall *off_10061D78)(char);

//----- (10045FEA) --------------------------------------------------------
int __userpurge sub_10045FEA<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10061D6C;
  return v4;
}
// 10061D6C: using guessed type int (__stdcall *off_10061D6C)(char);

//----- (10046005) --------------------------------------------------------
int __usercall sub_10046005<eax>(int a1<ebp>)
{
  int v2; // ecx@1
  void *v3; // esi@1

  sub_10035668();
  *(_DWORD *)(a1 - 16) = v2;
  v3 = (void *)(v2 + 4);
  *(_DWORD *)v2 = off_10065D60;
  *(_DWORD *)(v2 + 4) = off_10065D8C;
  *(_DWORD *)(a1 - 4) = 0;
  sub_100463C7(v2, a1);
  sub_1002E280(v3);
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 10065D60: using guessed type int (*off_10065D60[3])();
// 10065D8C: using guessed type int (*off_10065D8C[5])();

//----- (10046040) --------------------------------------------------------
void *__thiscall sub_10046040(void *this, char a2)
{
  void *v2; // esi@1
  char v4; // [sp-4h] [bp-4h]@1

  v2 = (char *)this - 4;
  sub_10046005((int)&v4);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10046067) --------------------------------------------------------
char __thiscall sub_10046067(void *this, char a2, int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // edi@1
  char result; // al@2
  int v8; // esi@9
  int v9; // ebx@12
  void *v10; // esi@12
  char v11; // [sp-14h] [bp-3Ch]@12
  char v12; // [sp-10h] [bp-38h]@2
  int v13; // [sp-Ch] [bp-34h]@2
  int v14; // [sp-8h] [bp-30h]@2
  int v15; // [sp-4h] [bp-2Ch]@2
  char v16; // [sp+Ch] [bp-1Ch]@12
  int v17; // [sp+20h] [bp-8h]@6
  int v18; // [sp+24h] [bp-4h]@9

  v6 = (int)this;
  v5 = (int)sub_10032365();
  if ( *(_DWORD *)(*(_DWORD *)(v6 + 32) + 432) <= 0
    || (sub_1002F3E5((int)&v12, (int)&a2),
        result = (*(int (__stdcall **)(int, _DWORD, int, int, int))(**(_DWORD **)(v6 + 32) + 60))(
                   v6,
                   *(_DWORD *)&v12,
                   v13,
                   v14,
                   v15),
        !result) )
  {
    if ( v5 && !*(_BYTE *)(v5 + 76) && *(_DWORD *)(v6 + 32) == sub_10032E0B(v5) )
    {
      v17 = v5;
      sub_1002E99E();
      if ( !(*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v6 + 28) + 256) + 48) & 2)
        && (1 << (*(_DWORD *)(*(_DWORD *)(v5 + 156) + 132) & 0x1F)) & *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 28) + 32)
                                                                                + 4
                                                                                * (*(_DWORD *)(*(_DWORD *)(v5 + 156)
                                                                                             + 132) >> 5))
        && *(_DWORD *)(*(_DWORD *)(v5 + 156) + 16) - *(_DWORD *)(*(_DWORD *)(v5 + 156) + 12) < *(_WORD *)(*(_DWORD *)(v6 + 32) + 16) )
      {
        v8 = *(_DWORD *)(*(_DWORD *)(v6 + 28) + 256);
        v18 = *(_DWORD *)(v6 + 28);
        if ( sub_1002EA27(v5) != v8 )
          *(_DWORD *)(v6 + 228) = 1;
        sub_10046B53(*(_DWORD *)(v5 + 156) + 12, v6);
        if ( *(_DWORD *)(*(_DWORD *)(v6 + 32) + 428) <= 0 )
        {
          v9 = v18;
        }
        else
        {
          sub_1002F3E5((int)&v16, (int)&a2);
          v10 = *(void **)(v6 + 32);
          v15 = 11;
          sub_1002F3E5((int)&v11, (int)&v16);
          v9 = v18;
          sub_1003416B(v10, v18, v11, *(int *)&v12, v13, v14, v15);
        }
        if ( sub_1002EA27(v17) != *(_DWORD *)(v9 + 256) )
          *(_DWORD *)(v6 + 228) = 0;
        return sub_1002E99E();
      }
      sub_1002E99E();
    }
    sub_1002F3E5((int)&v12, (int)&a2);
    result = sub_10040C95(*(void **)(v6 + 28), v6, v12, v13, v14, v15);
  }
  return result;
}

//----- (100461E0) --------------------------------------------------------
int __userpurge sub_100461E0<eax>(int a1<ebp>, int a2)
{
  int v3; // ecx@1
  int v4; // esi@1
  int v5; // edi@1
  int v6; // ecx@1
  int v7; // ST00_4@1

  sub_10035668();
  v4 = v3;
  v5 = v3 != 4 ? v3 : 0;
  *(_DWORD *)(a1 - 16) = v5;
  sub_1002E99E();
  v6 = *(_DWORD *)(v4 + 156);
  *(_DWORD *)(a1 - 4) = 0;
  sub_10045204(v6, a1, v5);
  loc_1002CBD6(*(_DWORD *)(a1 + 8));
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002E99E();
  return sub_10035636(v7);
}
// 1002CBD6: using guessed type _DWORD __cdecl loc_1002CBD6(_DWORD);
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (10046231) --------------------------------------------------------
int __thiscall sub_10046231(void *this)
{
  void *v2; // edi@1
  int v3; // ecx@1
  int v4; // eax@1
  int v18; // ebx@7
  int v22; // [sp-4h] [bp-18h]@1
  char v23; // [sp+12h] [bp-2h]@7
  char v24; // [sp+13h] [bp-1h]@7

  v2 = this;
  sub_1002E99E();
  v3 = *((_DWORD *)v2 + 7);
  v22 = *((_DWORD *)v2 + 2);
  v4 = (*(int (**)(void))(*(_DWORD *)v3 + 4))();
  sub_1002F346(3, 4, v4, v22);
  _EAX = 1;
  if ( *(_BYTE *)(*((_DWORD *)v2 + 39) + 161) )
  {
    _EDX = (int)((char *)v2 + 44);
    __asm { lock xadd [edx], eax }
    if ( _EAX == 0 )
    {
      _ECX = 2;
      __asm { lock cmpxchg [edx], ecx }
      v22 = 1;
    }
    else
    {
      v22 = 2;
    }
    sub_10046D9E((int)((char *)v2 - 4), v22);
  }
  else
  {
    _ECX = (int)((char *)v2 + 44);
    __asm { lock xadd [ecx], eax }
    if ( _EAX == 0 )
    {
      v24 = 0;
      v23 = 0;
      v18 = sub_10046615((int)((char *)v2 - 4), (int)&v24, (int)&v23);
      _ECX = 2;
      _EDX = (int)((char *)v2 + 44);
      __asm { lock cmpxchg [edx], ecx }
      if ( v24 )
        sub_10046AD3(v18, *((_DWORD *)v2 + 6), 0, 0);
      sub_10046E8A((int)((char *)v2 - 4), v18, 1);
    }
  }
  return sub_1002E99E();
}

//----- (10046355) --------------------------------------------------------
char __thiscall sub_10046355(int this)
{
  int ebp0; // ebp@0
  int v2; // edi@1
  LPVOID v3; // eax@2
  int v4; // ecx@2
  int v5; // esi@4
  int v7; // [sp+8h] [bp-8h]@2
  int v8; // [sp+Ch] [bp-4h]@3

  v2 = this;
  if ( *(_DWORD *)(this + 160) )
  {
    *(_BYTE *)(this + 176) = 1;
    v4 = *(_DWORD *)(this + 160);
    v7 = 0;
    LOBYTE(v3) = sub_1004505F(v4, (int)&v7, 15, 1);
    if ( (_BYTE)v3 )
      LOBYTE(v3) = sub_10045165(v8, v7, 0, 0);
  }
  else
  {
    v5 = this + 4;
    v3 = sub_10032365();
    if ( v3 == (LPVOID)v5 )
    {
      *(_BYTE *)(v2 + 176) = 1;
    }
    else
    {
      sub_10046C65(v2);
      sub_100463C7(v2, ebp0);
      LOBYTE(v3) = sub_10032230(*(_DWORD *)(v2 + 32));
    }
  }
  return (char)v3;
}

//----- (100463C7) --------------------------------------------------------
void __usercall sub_100463C7(int a1<ecx>, int a2<ebp>)
{
  int v2; // esi@1

  v2 = a1;
  sub_1002E71E(a1 + 4, a2);
  sub_10046D4D(v2, 0, 0);
}

//----- (100463DF) --------------------------------------------------------
int __usercall sub_100463DF<eax>(int this<ecx>, int a2<ebp>)
{
  int v3; // esi@1

  v3 = this;
  sub_1002E99E();
  sub_100463C7(v3, a2);
  return sub_10032230(*(_DWORD *)(v3 + 32));
}

//----- (100463FA) --------------------------------------------------------
int __userpurge sub_100463FA<eax>(int a1<ebp>, int a2)
{
  char v2; // bh@1
  int v3; // esi@1
  int v4; // ecx@1
  void *v5; // eax@1
  char v6; // bl@3
  char v7; // bl@7
  int v9; // [sp-8h] [bp-8h]@1

  sub_10035668();
  v3 = v4;
  *(_DWORD *)(a1 - 16) = 0;
  v2 = 0;
  *(_DWORD *)(v4 + 72) = GetCurrentThreadId();
  sub_1002EFA9((LPVOID)(v3 + 4));
  v5 = (void *)(*(int (__cdecl **)(int, signed int))(**(_DWORD **)(v3 + 32) + 12))(a1 - 20, 32);
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)(a1 - 16) = 1;
  v6 = !sub_10044C13(v5, 9u) && sub_1003D695() == 6;
  *(_DWORD *)(a1 - 4) = -1;
  sub_10044BEC((LPVOID *)(a1 - 20));
  if ( v6 )
  {
    v2 = 1;
    loc_1004CDC5(1);
  }
  sub_1002E99E();
  *(_DWORD *)(v3 + 172) = 0;
  v7 = 0;
  if ( !sub_100465AB(v3, a1) )
    goto LABEL_9;
LABEL_8:
  v7 = sub_1004692B(v3, a1);
  while ( !v7 )
  {
LABEL_9:
    *(_BYTE *)(v3 + 179) &= 0xFDu;
    *(_DWORD *)(a1 - 32) = 0;
    *(_DWORD *)(a1 - 24) = 0;
    if ( !*(_DWORD *)(v3 + 160) )
    {
      sub_1002E99E();
      sub_10030067(a1 - 44);
      sub_100355DB(a1 - 44, (int)&unk_1006D2B0);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1004656E);
    }
    if ( !*(_BYTE *)(v3 + 178) )
    {
      if ( sub_10045763(*(_DWORD *)(v3 + 160)) )
      {
        sub_1002E99E();
        sub_10032023(*(_DWORD *)(v3 + 32));
        sub_1002E99E();
      }
    }
    if ( sub_10047115(v3, a1 - 32) )
    {
      if ( *(_DWORD *)(a1 - 32) != 1 )
      {
        sub_1004656E(v3, a1 - 32);
        goto LABEL_8;
      }
      sub_10046E8A(v3, *(_DWORD *)(a1 - 24), 0);
      break;
    }
    if ( sub_1004692B(v3, a1) )
      break;
    sub_10047025(v3);
    if ( *(_BYTE *)(v3 + 176) )
    {
      sub_100463DF(v3, a1);
      v7 = 1;
    }
  }
  if ( v2 )
    sub_1004CDDB();
  sub_1002E77E();
  return sub_10035636(v9);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 1003D695: using guessed type int sub_1003D695(void);
// 1004CDC5: using guessed type _DWORD __cdecl loc_1004CDC5(_DWORD);

//----- (1004656E) --------------------------------------------------------
int __thiscall sub_1004656E(int this, int a2)
{
  int ebp0; // ebp@0
  int v4; // esi@1

  v4 = this;
  sub_10052BC5((void *)a2, this);
  ++*(_DWORD *)(*(_DWORD *)(v4 + 160) + 96);
  sub_1002E99E();
  sub_10051C1A(a2);
  sub_1002E99E();
  return sub_1002EE1F(v4 + 4, ebp0);
}

//----- (100465AB) --------------------------------------------------------
char __usercall sub_100465AB<al>(int a1<ecx>, int a2<ebp>)
{
  int v2; // edi@1
  int v3; // esi@4
  int v4; // ecx@4
  char result; // al@5

  v2 = a1;
  if ( *(_DWORD *)(a1 + 168) )
  {
    sub_1002E99E();
    if ( *(_BYTE *)(v2 + 177) )
    {
      (*(void (__cdecl **)(_DWORD))(*(_DWORD *)(v2 + 168) + 12))(*(_DWORD *)(v2 + 168));
      *(_DWORD *)(v2 + 168) = 0;
    }
    else
    {
      v3 = *(_DWORD *)(v2 + 168);
      sub_10052C1A(*(_DWORD *)(v2 + 168));
      v4 = *(_DWORD *)(v2 + 32);
      *(_DWORD *)(v2 + 168) = 0;
      sub_10033AD4(v4, v3);
    }
    sub_1002E99E();
    sub_1002EE1F(v2 + 4, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10046615) --------------------------------------------------------
int __thiscall sub_10046615(int this, int a2, int a3)
{
  int v3; // ebx@1
  int ebp0; // ebp@0
  int v5; // edx@1
  int v6; // eax@1
  int v7; // edi@3
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+10h] [bp-4h]@1

  v3 = this;
  v5 = *(_DWORD *)(this + 28);
  v6 = *(_DWORD *)(this + 160);
  v9 = 0;
  v10 = 0;
  if ( !(unsigned __int8)(*(int (__thiscall **)(int, int *, int, _DWORD, signed int))(v6 + 60))(v6 + 36, &v9, v5, 0, 25) )
  {
    v7 = sub_1003294B(ebp0, 1);
    *(_BYTE *)a2 = v7 != 0;
    return v7;
  }
  if ( v9 == 1 )
    return v10;
  sub_1002E99E();
  v7 = sub_1003294B(ebp0, 1);
  sub_1002E99E();
  if ( !v7 )
  {
    if ( !(unsigned __int8)(*(int (__thiscall **)(int, int *, _DWORD, _DWORD, signed int))(*(_DWORD *)(v3 + 160) + 60))(
                             *(_DWORD *)(v3 + 160) + 36,
                             &v9,
                             *(_DWORD *)(v3 + 28),
                             0,
                             1) )
      return v7;
    return sub_100517C2((int)&v9, v7);
  }
  if ( !sub_10051DCD((int)&v9, v7) )
  {
    if ( !(unsigned __int8)(*(int (__thiscall **)(int, int *, _DWORD, _DWORD, signed int))(*(_DWORD *)(v3 + 160) + 60))(
                             *(_DWORD *)(v3 + 160) + 36,
                             &v9,
                             *(_DWORD *)(v3 + 28),
                             0,
                             7) )
    {
      *(_BYTE *)a2 = 1;
      return v7;
    }
    if ( v9 == 1 )
    {
      sub_10033A94(*(_DWORD *)(v3 + 32), v7, 1);
      return sub_100517C2((int)&v9, v7);
    }
  }
  *(_BYTE *)a3 = v9 == 4;
  sub_1005180B((int)&v9, v7);
  return v7;
}

//----- (10046717) --------------------------------------------------------
int __userpurge sub_10046717<eax>(int a1<ecx>, int a2<edi>, int a3)
{
  int ebp0; // ebp@0
  int v5; // esi@1
  int v6; // eax@1

  v5 = a1;
  sub_1002E99E();
  v6 = sub_10045204(*(_DWORD *)(v5 + 156), ebp0, a2);
  sub_1002CC6A((void *)v6, a3);
  return sub_1002E99E();
}

//----- (10046743) --------------------------------------------------------
int __thiscall sub_10046743(int this, int a2)
{
  int v2; // esi@1

  v2 = 0;
  if ( a2 )
  {
    _EDI = this + 164;
    if ( a2 == *(_DWORD *)(this + 164) )
    {
      _ECX = 0;
      __asm { lock cmpxchg [edi], ecx }
      if ( a2 == a2 )
        v2 = a2;
    }
  }
  return v2;
}

//----- (10046771) --------------------------------------------------------
int __thiscall sub_10046771(int this)
{
  return *(_DWORD *)(this + 12);
}

//----- (10046775) --------------------------------------------------------
int __thiscall sub_10046775(int this)
{
  return sub_10046771(this - 4);
}

//----- (1004677D) --------------------------------------------------------
int __thiscall sub_1004677D(int this)
{
  return *(_DWORD *)(this + 156);
}

//----- (10046784) --------------------------------------------------------
int __thiscall sub_10046784(int this)
{
  return (*(int (**)(void))(**(_DWORD **)(this + 32) + 52))();
}

//----- (1004678C) --------------------------------------------------------
signed int __thiscall sub_1004678C(void *this)
{
  void *v1; // esi@1
  signed int v2; // edi@2

  v1 = this;
  sub_1002E99E();
  if ( *((_DWORD *)v1 + 39) )
    v2 = *(_DWORD *)(*((_DWORD *)v1 + 39) + 124);
  else
    v2 = -1;
  sub_1002E99E();
  return v2;
}

//----- (100467B8) --------------------------------------------------------
int __thiscall sub_100467B8(void *this, int a2, int a3, int a4)
{
  int v4; // eax@1
  int v5; // ebx@1
  int v6; // edi@1
  signed __int64 v8; // qax@1
  signed __int64 v10; // qax@1
  int v11; // edx@2
  int i; // ecx@2
  int v13; // eax@6
  int v14; // edx@6
  int v15; // ebx@6
  void *v16; // esi@6
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edx@10
  int v20; // ecx@10
  int v21; // edx@10
  void *v23; // [sp+Ch] [bp-24h]@6
  void *v24; // [sp+10h] [bp-20h]@1
  void *v25; // [sp+14h] [bp-1Ch]@6
  int v26; // [sp+18h] [bp-18h]@1
  int v27; // [sp+1Ch] [bp-14h]@1
  int v28; // [sp+20h] [bp-10h]@1
  int v29; // [sp+24h] [bp-Ch]@1
  int v30; // [sp+28h] [bp-8h]@6
  int v31; // [sp+2Ch] [bp-4h]@6

  v6 = (int)this;
  _ECX = 0;
  v5 = 2 * *(_DWORD *)(v6 + 8) + 2;
  v8 = 4i64 * (unsigned int)(2 * *(_DWORD *)(v6 + 8) + 2);
  __asm { seto    cl }
  v26 = v6;
  v27 = v5;
  v29 = sub_1002965B(SHIDWORD(v8), v8 | -_ECX, v5, v6, v8 | -_ECX);
  v24 = *(void **)(v6 + 12);
  _ECX = 0;
  v10 = 8i64 * (unsigned int)v5;
  __asm { seto    cl }
  v4 = sub_1002965B(SHIDWORD(v10), v10 | -_ECX, v5, v6, v10 | -_ECX);
  v28 = v4;
  if ( v4 )
  {
    v11 = v5 - 1;
    for ( i = v4; v11 >= 0; --v11 )
    {
      *(_DWORD *)i = 0;
      *(_DWORD *)(i + 4) = 0;
      i += 8;
    }
  }
  else
  {
    v28 = 0;
  }
  v16 = *(void **)(v6 + 20);
  v23 = *(void **)(v6 + 16);
  v25 = *(void **)(v6 + 20);
  sub_10034BBC(v16);
  v13 = *(_DWORD *)v6;
  v15 = *(_DWORD *)(v6 + 4) - *(_DWORD *)v6;
  v14 = 0;
  v30 = *(_DWORD *)v6;
  v31 = 0;
  if ( v15 > 0 )
  {
    do
    {
      *(_DWORD *)(v29 + 4 * v14) = *(_DWORD *)(*(_DWORD *)(v6 + 12) + 4 * (*(_DWORD *)(v6 + 8) & v13));
      v17 = *(_DWORD *)(v6 + 16);
      v18 = *(_DWORD *)(v6 + 8) & v30;
      *(_DWORD *)(v28 + 8 * v31) = *(_DWORD *)(v17 + 8 * v18);
      v6 = v26;
      *(_DWORD *)(v28 + 8 * v31 + 4) = *(_DWORD *)(v17 + 8 * v18 + 4);
      v14 = v31 + 1;
      v13 = v30 + 1;
      v31 = v14;
      ++v30;
    }
    while ( v14 < v15 );
    v16 = v25;
  }
  sub_10039210((void *)(v29 + 4 * v15), 0, 4 * (v27 - v15));
  *(_DWORD *)(v6 + 12) = v29;
  *(_DWORD *)(v6 + 16) = v28;
  *(_DWORD *)v6 = 0;
  *(_DWORD *)(v6 + 8) = v27 - 1;
  if ( a3 )
  {
    v20 = *(_DWORD *)(v6 + 16);
    v21 = v15 & (v27 - 1);
    *(_DWORD *)(v20 + 8 * v21) = a3;
    *(_DWORD *)(v20 + 8 * v21 + 4) = a4;
    v19 = a2 | 1;
  }
  else
  {
    v19 = a2;
  }
  *(_DWORD *)(*(_DWORD *)(v6 + 12) + 4 * (*(_DWORD *)(v6 + 8) & v15)) = v19;
  *(_DWORD *)(v6 + 4) = v15 + 1;
  sub_10034BCC(v16);
  sub_10030383(v24);
  return sub_10030383(v23);
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (1004691F) --------------------------------------------------------
bool __thiscall sub_1004691F(int this)
{
  return *(_DWORD *)(this + 44) == 2;
}

//----- (1004692B) --------------------------------------------------------
char __usercall sub_1004692B<al>(int a1<ecx>, int a2<ebp>)
{
  int v2; // esi@1
  char result; // al@7

  v2 = a1;
  if ( *(_BYTE *)(a1 + 178) || !*(_BYTE *)(*(_DWORD *)(a1 + 160) + 161) )
  {
    result = 0;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 172) )
      sub_1004535A(*(_DWORD *)(a1 + 32) + 60, *(_DWORD *)(*(_DWORD *)(a1 + 160) + 132));
    *(_DWORD *)(v2 + 172) = 0;
    if ( sub_10046D9E(v2, 0) )
      sub_100463DF(v2, a2);
    result = 1;
  }
  return result;
}

//----- (10046989) --------------------------------------------------------
int __thiscall sub_10046989(void *this)
{
  int v1; // eax@1
  int v2; // esi@1
  int v3; // eax@3
  int v4; // edi@3
  int v6; // [sp+Ch] [bp-14h]@3
  int v7; // [sp+10h] [bp-10h]@3
  int v8; // [sp+14h] [bp-Ch]@1
  int v9; // [sp+18h] [bp-8h]@3
  char v10; // [sp+1Eh] [bp-2h]@1
  char v11; // [sp+1Fh] [bp-1h]@1

  v2 = (int)this;
  sub_1002E99E();
  v11 = 0;
  v10 = 0;
  v1 = sub_10046615(v2, (int)&v11, (int)&v10);
  v8 = v1;
  if ( v11 )
    sub_10046AD3(v1, *(_DWORD *)(v2 + 28), 0, 0);
  sub_1002E99E();
  v3 = *(_DWORD *)(v2 + 160);
  v6 = *(_DWORD *)(v2 + 32);
  *(_DWORD *)(v2 + 160) = 0;
  v4 = *(_DWORD *)(v2 + 156);
  v9 = v3;
  v7 = v8;
  if ( !v8 )
  {
    v7 = (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
    v3 = v9;
  }
  *(_DWORD *)(v2 + 44) = 1;
  (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 16))(v3, v8);
  if ( v7 )
  {
    (*(void (__thiscall **)(int, int, signed int))(*(_DWORD *)v4 + 4))(v4, v7, 2);
  }
  else
  {
    sub_100453E2(v9, 4, 1);
    sub_1003224B(v6);
    (*(void (__thiscall **)(int, signed int))(*(_DWORD *)v4 + 8))(v4, 2);
  }
  sub_1002E99E();
  return sub_1002E99E();
}

//----- (10046A5F) --------------------------------------------------------
void __thiscall sub_10046A5F(int this, char a2)
{
  int v2; // esi@1
  int v3; // eax@4
  int v4; // eax@5
  int v5; // eax@6
  char v6; // [sp+4h] [bp-Ch]@9

  v2 = this;
  if ( a2 )
  {
    ++*(_DWORD *)(this + 20);
    if ( *(_DWORD *)(this + 20) == 1 )
    {
      sub_1002E99E();
      (*(void (**)(void))(**(_DWORD **)(v2 + 156) + 32))();
      sub_1002E99E();
    }
  }
  else
  {
    v3 = *(_DWORD *)(this + 20);
    if ( !v3 )
    {
      sub_1002FFE7((int)&v6);
      sub_100355DB((int)&v6, (int)&unk_1006D278);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_10046AD3);
    }
    v4 = v3 - 1;
    *(_DWORD *)(this + 20) = v4;
    if ( !v4 )
    {
      v5 = sub_10046743(this - 4, *(_DWORD *)(this + 160));
      if ( v5 )
        sub_10045460(v5);
    }
  }
}

//----- (10046AD3) --------------------------------------------------------
int __thiscall sub_10046AD3(int this, int a2, int a3, char a4)
{
  int result; // eax@1
  int v5; // edx@1

  result = a2;
  v5 = this;
  *(_BYTE *)(this + 236) = 0;
  *(_DWORD *)(this + 28) = a2;
  if ( a3 )
  {
    if ( a4 )
    {
      result = *(_DWORD *)(a2 + 256);
      if ( !(*(_BYTE *)(result + 48) & 4) )
      {
        result += 20;
        _ECX = 1;
        __asm { lock xadd [eax], ecx }
      }
      *(_BYTE *)(v5 + 177) = 1;
    }
    else
    {
      *(_BYTE *)(this + 177) = 0;
    }
    *(_DWORD *)(v5 + 168) = a3;
  }
  else
  {
    result = *(_DWORD *)(a2 + 256);
    if ( !(*(_BYTE *)(result + 48) & 4) )
    {
      result += 20;
      _ECX = 1;
      __asm { lock xadd [eax], ecx }
    }
  }
  return result;
}

//----- (10046B3C) --------------------------------------------------------
int __thiscall sub_10046B3C(int this, int a2)
{
  int result; // eax@1

  *(_DWORD *)(this + 160) = a2;
  result = this + 44;
  *(_DWORD *)(this + 44) = 0;
  return result;
}

//----- (10046B53) --------------------------------------------------------
int __thiscall sub_10046B53(int this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int result; // eax@2

  v2 = *(_DWORD *)(this + 4);
  v3 = *(_DWORD *)(this + 8);
  if ( v2 >= v3 + *(_DWORD *)this )
  {
    result = sub_100467B8((void *)this, a2, 0, 0);
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(this + 12) + 4 * (v2 & v3)) = a2;
    result = v2 + 1;
    *(_DWORD *)(this + 4) = v2 + 1;
  }
  return result;
}

//----- (10046B94) --------------------------------------------------------
void __thiscall sub_10046B94(int this)
{
  int v1; // esi@1
  int v2; // ecx@2
  int v3; // [sp+4h] [bp-8h]@2

  v1 = this;
  if ( *(_BYTE *)(this + 178) )
  {
    v2 = *(_DWORD *)(this + 160);
    v3 = 0;
    if ( !sub_1004505F(v2, (int)&v3, 15, 1) )
    {
      while ( !(unsigned __int8)sub_10045129(*(_DWORD *)(v1 + 160)) )
        (*(void (__thiscall **)(int))(*(_DWORD *)v1 + 32))(v1);
    }
    *(_BYTE *)(v1 + 178) = 0;
  }
}

//----- (10046BE3) --------------------------------------------------------
int __thiscall sub_10046BE3(void *this)
{
  int v2; // esi@1

  v2 = (int)this;
  sub_1002E99E();
  sub_10046D9E(v2, 3);
  return sub_1002E99E();
}

//----- (10046C02) --------------------------------------------------------
void __usercall sub_10046C02(int a1<ecx>, int a2<ebp>)
{
  int v2; // esi@1

  v2 = a1;
  sub_1002EE1F(a1 + 4, a2);
  sub_10046D4D(v2, 0, 0);
  *(_DWORD *)(v2 + 72) = 0;
  *(_BYTE *)(v2 + 236) = 1;
}

//----- (10046C25) --------------------------------------------------------
int __thiscall sub_10046C25(int this, int a2)
{
  int result; // eax@1
  int (__stdcall **v3)(char); // [sp+0h] [bp-Ch]@3

  result = a2;
  if ( !a2 )
  {
    a2 = (int)"pThreadProxy";
    sub_1002AEA4((int)&v3, &a2);
    v3 = &off_100602FC;
    sub_100355DB((int)&v3, (int)&unk_1006D8F4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10046C65);
  }
  *(_DWORD *)(this + 156) = a2;
  return result;
}
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);

//----- (10046C65) --------------------------------------------------------
char __thiscall sub_10046C65(int this)
{
  int v1; // esi@1
  char result; // al@3
  char v3; // [sp+4h] [bp-10h]@3
  int v4; // [sp+Ch] [bp-8h]@2
  void (__cdecl *v5)(); // [sp+10h] [bp-4h]@2

  v1 = this;
  if ( !*(_DWORD *)(this + 44) )
  {
    v4 = 0;
    v5 = sub_10034BD7;
    do
      result = sub_100282E0((int)&v3);
    while ( !*(_DWORD *)(v1 + 44) );
  }
  return result;
}

//----- (10046C90) --------------------------------------------------------
char __cdecl sub_10046C90(int a1, int a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-10h]@3
  int v4; // [sp+10h] [bp-8h]@2
  void (__cdecl *v5)(); // [sp+14h] [bp-4h]@2

  if ( *(_DWORD *)a1 != a2 )
  {
    v4 = 0;
    v5 = sub_10034BD7;
    do
      result = sub_100282E0((int)&v3);
    while ( *(_DWORD *)a1 != a2 );
  }
  return result;
}

//----- (10046CBD) --------------------------------------------------------
int __thiscall sub_10046CBD(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  int v3; // ST0C_4@1
  int v4; // eax@1
  int v5; // eax@3
  int v6; // ST04_4@3
  int result; // eax@6
  int v8; // [sp+8h] [bp-Ch]@3
  int v9; // [sp+10h] [bp-4h]@3

  v2 = this;
  v1 = 0;
  sub_1002E99E();
  v3 = *((_DWORD *)v2 + 2);
  v4 = (*(int (**)(void))(**((_DWORD **)v2 + 7) + 4))();
  sub_1002F346(5, 4, v4, v3);
  if ( *(_BYTE *)(*((_DWORD *)v2 + 39) + 161) )
  {
    sub_10046D9E((int)((char *)v2 - 4), 2);
  }
  else
  {
    v5 = *((_DWORD *)v2 + 39);
    v6 = *((_DWORD *)v2 + 6);
    v8 = 0;
    v9 = 0;
    if ( (unsigned __int8)(*(int (__thiscall **)(int, int *, int, _DWORD, signed int))(v5 + 60))(v5 + 36, &v8, v6, 0, 1) )
      sub_10046E8A((int)((char *)v2 - 4), v9, 2);
    else
      v1 = 1;
  }
  result = sub_1002E99E();
  if ( v1 )
    result = (*(int (**)(void))(**((_DWORD **)v2 + 38) + 12))();
  return result;
}

//----- (10046D4D) --------------------------------------------------------
void __thiscall sub_10046D4D(int this, int a2, char a3)
{
  int v3; // esi@1
  int v4; // eax@3

  v3 = this;
  if ( *(_DWORD *)(this + 28) )
  {
    sub_10046C90(this + 228, 0);
    sub_10033312(*(void **)(*(_DWORD *)(v3 + 28) + 256));
    if ( a3 )
    {
      v4 = *(_DWORD *)(a2 + 256);
      if ( !(*(_BYTE *)(v4 + 48) & 4) )
      {
        _EAX = v4 + 20;
        _ECX = 1;
        __asm { lock xadd [eax], ecx }
      }
    }
    *(_DWORD *)(v3 + 28) = a2;
  }
}

//----- (10046D9E) --------------------------------------------------------
char __thiscall sub_10046D9E(int this, int a2)
{
  char v2; // bl@1
  int v3; // esi@1
  int v4; // ecx@4
  int v5; // eax@4
  char v7; // [sp-10h] [bp-24h]@9
  int v8; // [sp-Ch] [bp-20h]@9
  int v9; // [sp-8h] [bp-1Ch]@9
  int v10; // [sp-4h] [bp-18h]@4
  int v11; // [sp+Ch] [bp-8h]@1
  int v12; // [sp+10h] [bp-4h]@2

  v3 = this;
  v2 = 0;
  v11 = *(_DWORD *)(this + 156);
  if ( *(_DWORD *)(this + 160) )
  {
    sub_10046B94(this);
    v12 = *(_DWORD *)(*(_DWORD *)(v3 + 160) + 180);
    sub_1002E99E();
    (*(void (**)(void))(**(_DWORD **)(v3 + 160) + 12))();
    *(_DWORD *)(v3 + 160) = 0;
    if ( a2 )
    {
      sub_1002E99E();
      *(_DWORD *)(v3 + 44) = 1;
    }
    else
    {
      v4 = *(_DWORD *)(v3 + 32);
      v10 = *(_DWORD *)(v3 + 12);
      v5 = (*(int (**)(void))(*(_DWORD *)v4 + 4))();
      sub_1002F346(6, 4, v5, v10);
      sub_100413D3(*(void **)(v3 + 28), v3);
    }
    sub_1003468D(*(_DWORD *)(v3 + 32), (int)&v12);
    sub_1003476A(*(_DWORD *)(v3 + 32), 0);
    v2 = *(_BYTE *)(v3 + 176);
    if ( !a2 )
      *(_DWORD *)(v3 + 44) = 1;
  }
  if ( a2 == 2 || a2 == 3 )
  {
    sub_1002F3E5((int)&v7, *(_DWORD *)(v3 + 28) + 12);
    sub_10040C95(*(void **)(v3 + 28), v3, v7, v8, v9, v10);
  }
  if ( a2 )
  {
    v10 = 1;
    (*(void (__thiscall **)(int, signed int))(*(_DWORD *)v11 + 8))(v11, 1);
  }
  return v2;
}

//----- (10046E8A) --------------------------------------------------------
int __thiscall sub_10046E8A(int this, int a2, int a3)
{
  signed int v3; // edi@1
  int v4; // esi@1
  int v5; // ecx@7
  int v6; // eax@7
  int v7; // eax@8
  int v8; // ebx@8
  int v9; // edx@10
  int result; // eax@11
  int v11; // eax@11
  int v12; // eax@12
  char v13; // [sp-10h] [bp-28h]@6
  int v14; // [sp-Ch] [bp-24h]@6
  int v15; // [sp-8h] [bp-20h]@6
  int v16; // [sp-4h] [bp-1Ch]@6
  int v17; // [sp+Ch] [bp-Ch]@8
  int v18; // [sp+10h] [bp-8h]@8
  int v19; // [sp+14h] [bp-4h]@8

  v3 = 1;
  v4 = this;
  if ( a3 )
  {
    if ( a3 != 1 )
    {
      if ( a3 == 2 )
      {
        sub_1002F3E5((int)&v13, *(_DWORD *)(this + 28) + 12);
        sub_10040C95(*(void **)(v4 + 28), v4, v13, v14, v15, v16);
      }
      else
      {
        if ( a3 == 3 )
          v3 = 2;
      }
    }
  }
  else
  {
    v5 = *(_DWORD *)(this + 32);
    v16 = *(_DWORD *)(v4 + 12);
    v6 = (*(int (**)(void))(*(_DWORD *)v5 + 4))();
    sub_1002F346(6, 4, v6, v16);
    sub_100413D3(*(void **)(v4 + 28), v4);
    v3 = 0;
  }
  sub_1002E99E();
  v7 = *(_DWORD *)(v4 + 160);
  v17 = *(_DWORD *)(v4 + 32);
  *(_DWORD *)(v4 + 160) = 0;
  v8 = *(_DWORD *)(v4 + 156);
  v19 = v7;
  v18 = a2;
  if ( !a2 )
  {
    v18 = (*(int (__thiscall **)(int))(*(_DWORD *)v7 + 4))(v19);
    v7 = v19;
  }
  *(_DWORD *)(v4 + 44) = 1;
  v9 = *(_DWORD *)v7;
  v16 = a2;
  (*(void (__thiscall **)(int, int))(v9 + 16))(v7, a2);
  if ( v18 )
  {
    v12 = *(_DWORD *)v8;
    v16 = v3;
    v15 = v18;
    result = (*(int (__thiscall **)(int, int, signed int))(v12 + 4))(v8, v18, v3);
  }
  else
  {
    sub_100453E2(v19, 4, 1);
    sub_1003224B(v17);
    v11 = *(_DWORD *)v8;
    v16 = v3;
    result = (*(int (__thiscall **)(int, signed int))(v11 + 8))(v8, v3);
  }
  if ( a3 )
    result = sub_1002E99E();
  return result;
}

//----- (10046F81) --------------------------------------------------------
int __fastcall sub_10046F81(int a1)
{
  int v1; // edi@1
  int v3; // esi@2
  int v10; // ecx@2
  int v11; // eax@2
  int result; // eax@3
  char *v13; // eax@6
  char v14; // [sp-10h] [bp-38h]@3
  int v15; // [sp-4h] [bp-2Ch]@2
  char v16; // [sp+Ch] [bp-1Ch]@7
  char v17; // [sp+18h] [bp-10h]@6

  v1 = a1;
  if ( (LPVOID)(a1 != 4 ? a1 : 0) == sub_10032365() )
  {
    sub_1002FF27((int)&v16);
    v15 = (int)&unk_1006D240;
    v13 = &v16;
    goto LABEL_8;
  }
  _EBX = v1 + 44;
  _ESI = -1;
  __asm { lock xadd [ebx], esi }
  v3 = _ESI - 1;
  v10 = *(_DWORD *)(v1 + 28);
  v15 = *(_DWORD *)(v1 + 8);
  v11 = (*(int (**)(void))(*(_DWORD *)v10 + 4))();
  sub_1002F346(4, 4, v11, v15);
  if ( v3 == 1 )
  {
    *(_DWORD *)_EBX = 0;
    sub_10046C65(v1 - 4);
    sub_1002F3E5((int)&v14, *(_DWORD *)(v1 + 24) + 12);
    return (*(int (__thiscall **)(int))(*(_DWORD *)(v1 - 4) + 20))(v1 - 4);
  }
  result = v3 + 1;
  if ( (unsigned int)(v3 + 1) > 1 )
  {
    sub_1002FF39((int)&v17);
    v15 = (int)&unk_1006D208;
    v13 = &v17;
LABEL_8:
    sub_100355DB((int)v13, v15);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10047025);
  }
  return result;
}

//----- (10047025) --------------------------------------------------------
int __thiscall sub_10047025(int this)
{
  int v1; // ebx@1
  int v2; // esi@2
  int v3; // edi@2
  unsigned int v4; // eax@3
  int result; // eax@4
  int v6; // ecx@6
  int v7; // ecx@8
  char v8; // zf@12

  v1 = this;
  ++*(_DWORD *)(v1 + 172);
  if ( *(_DWORD *)(this + 172) == 1 )
  {
    v2 = *(_DWORD *)(*(_DWORD *)(this + 160) + 132);
    v3 = *(_DWORD *)(this + 32);
    sub_1004539C(v3 + 60, *(_DWORD *)(*(_DWORD *)(this + 160) + 132));
    sub_10045104(v3, v2);
  }
  v4 = *(_DWORD *)(v1 + 172);
  if ( v4 >= 0x100 )
  {
    if ( v4 == 256 )
    {
      v6 = *(_DWORD *)(v1 + 160);
      *(_BYTE *)(v1 + 178) = 1;
      sub_100453E2(v6, 2, 1);
      result = sub_10045159(*(_DWORD *)(v1 + 160));
    }
    else
    {
      if ( *(_BYTE *)(v1 + 179) & 2 )
      {
        v7 = *(_DWORD *)(v1 + 156);
        *(_DWORD *)(v1 + 172) = v4 - 1;
        result = (*(int (**)(void))(*(_DWORD *)v7 + 12))();
      }
      else
      {
        sub_1003480B(*(void **)(v1 + 32), 1);
        while ( !(unsigned __int8)sub_10045129(*(_DWORD *)(v1 + 160)) )
          (*(void (__thiscall **)(int))(*(_DWORD *)v1 + 32))(v1);
        result = sub_1003480B(*(void **)(v1 + 32), 0);
        v8 = *(_DWORD *)(v1 + 172) == 0;
        *(_BYTE *)(v1 + 178) = 0;
        if ( !v8 )
          result = sub_1004535A(*(_DWORD *)(v1 + 32) + 60, *(_DWORD *)(*(_DWORD *)(v1 + 160) + 132));
        *(_DWORD *)(v1 + 172) = 0;
      }
    }
  }
  else
  {
    result = (*(int (**)(void))(**(_DWORD **)(v1 + 156) + 12))();
  }
  return result;
}

//----- (10047115) --------------------------------------------------------
char __thiscall sub_10047115(int this, int a2)
{
  int v2; // esi@1
  char v3; // ST14_1@1
  char result; // al@4

  v2 = this;
  v3 = *(_BYTE *)(this + 178);
  if ( (unsigned __int8)(*(int (__thiscall **)(int, int, _DWORD))(*(_DWORD *)(this + 160) + 60))(
                          *(_DWORD *)(this + 160) + 36,
                          a2,
                          *(_DWORD *)(this + 28)) )
  {
    sub_10046B94(v2);
    if ( *(_DWORD *)(v2 + 172) )
      sub_1004535A(*(_DWORD *)(v2 + 32) + 60, *(_DWORD *)(*(_DWORD *)(v2 + 160) + 132));
    *(_DWORD *)(v2 + 172) = 0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004717C) --------------------------------------------------------
int __thiscall sub_1004717C(void *this)
{
  char v1; // bl@1
  int ebp0; // ebp@0
  void *v3; // esi@1
  int v4; // ST10_4@1
  int v5; // eax@1
  int v6; // eax@3
  int v7; // ST04_4@3
  int v8; // edi@5
  int result; // eax@18
  int v10; // [sp+8h] [bp-Ch]@3
  int v11; // [sp+10h] [bp-4h]@3

  v3 = this;
  v1 = 0;
  sub_1002E99E();
  v4 = *((_DWORD *)v3 + 2);
  v5 = (*(int (**)(void))(**((_DWORD **)v3 + 7) + 4))();
  sub_1002F346(5, 4, v5, v4);
  if ( *(_BYTE *)(*((_DWORD *)v3 + 39) + 161) )
  {
    sub_10046D9E((int)((char *)v3 - 4), 2);
    goto LABEL_18;
  }
  v6 = *((_DWORD *)v3 + 39);
  v7 = *((_DWORD *)v3 + 6);
  v10 = 0;
  v11 = 0;
  if ( !(unsigned __int8)(*(int (__thiscall **)(int, int *, int, _DWORD, signed int))(v6 + 64))(v6 + 36, &v10, v7, 0, 9) )
    goto LABEL_17;
  if ( v10 == 1 )
  {
LABEL_11:
    v8 = v11;
    goto LABEL_12;
  }
  sub_1002E99E();
  v8 = sub_1003294B(ebp0, 1);
  sub_1002E99E();
  if ( v8 )
  {
    if ( sub_10051DCD((int)&v10, v8) )
    {
LABEL_7:
      sub_1005180B((int)&v10, v8);
      goto LABEL_12;
    }
    if ( (unsigned __int8)(*(int (__thiscall **)(int, int *, _DWORD, _DWORD, signed int))(*((_DWORD *)v3 + 39) + 64))(
                            *((_DWORD *)v3 + 39) + 36,
                            &v10,
                            *((_DWORD *)v3 + 6),
                            0,
                            3) )
    {
      if ( v10 != 1 )
        goto LABEL_7;
      sub_10033A94(*((_DWORD *)v3 + 7), v8, 1);
      goto LABEL_11;
    }
    sub_10033A94(*((_DWORD *)v3 + 7), v8, 1);
    v8 = 0;
  }
  else
  {
    if ( !(unsigned __int8)(*(int (__thiscall **)(int, int *, _DWORD, _DWORD, signed int))(*((_DWORD *)v3 + 39) + 64))(
                             *((_DWORD *)v3 + 39) + 36,
                             &v10,
                             *((_DWORD *)v3 + 6),
                             0,
                             1) )
      goto LABEL_17;
    v8 = sub_100517C2((int)&v10, v8);
  }
LABEL_12:
  if ( v8 )
  {
    sub_10046E8A((int)((char *)v3 - 4), v8, 2);
    goto LABEL_18;
  }
LABEL_17:
  v1 = 1;
LABEL_18:
  result = sub_1002E99E();
  if ( v1 )
    result = (*(int (**)(void))(**((_DWORD **)v3 + 38) + 12))();
  return result;
}

//----- (100472B7) --------------------------------------------------------
int __userpurge sub_100472B7<eax>(int a1<ebp>, int a2, int a3)
{
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  void *v7; // ecx@1

  sub_10035668();
  v5 = v4;
  *(_DWORD *)(a1 - 16) = v4;
  v6 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(v4 + 4) = 0;
  *(_DWORD *)(v4 + 8) = 0;
  *(_DWORD *)v4 = v6;
  sub_10031259((void *)(v4 + 16), v6, 256, 64);
  *(_DWORD *)(a1 - 4) = 0;
  sub_10031259((void *)(v5 + 96), v6, 256, 64);
  *(_DWORD *)(v5 + 184) = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(v5 + 176) = 0;
  *(_DWORD *)(v5 + 180) = 0;
  *(_DWORD *)(v5 + 188) = 0;
  *(_DWORD *)(a1 - 32) = 0;
  *(_DWORD *)(a1 - 24) = 0;
  *(_DWORD *)(a1 - 20) = 0;
  v7 = *(void **)(v6 + 176);
  *(_BYTE *)(a1 - 4) = 1;
  *(_DWORD *)(v5 + 8) = sub_10040DA9(v7, a1 - 32, v5);
  return sub_10035636(20);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1004733D) --------------------------------------------------------
int __thiscall sub_1004733D(PSLIST_HEADER ListHead)
{
  int v1; // ebx@1
  PSLIST_HEADER v2; // edi@1
  int v3; // eax@1
  int v4; // eax@1
  int i; // esi@2
  int v6; // ecx@3
  int v7; // esi@6

  v2 = ListHead;
  v3 = (int)InterlockedFlushSList(ListHead);
  sub_10047424(v3);
  v4 = (int)InterlockedFlushSList(v2 + 1);
  sub_10047424(v4);
  sub_10047424(LODWORD(v2[2].Alignment));
  v1 = LODWORD(v2[6].Alignment);
  if ( v1 )
  {
    do
    {
      for ( i = 0; i < LODWORD(v2[5].Alignment); ++i )
      {
        v6 = *(_DWORD *)(*(_DWORD *)v1 + 4 * i);
        if ( v6 )
          (**(void (__stdcall ***)(_DWORD))v6)(1);
      }
      v7 = *(_DWORD *)(v1 + 4);
      sub_10030383(*(LPVOID *)v1);
      sub_1002A4AA((LPVOID)v1);
      v1 = v7;
    }
    while ( v7 );
  }
  return sub_10030383(HIDWORD(v2[6].Alignment));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (100473B3) --------------------------------------------------------
int __usercall sub_100473B3<eax>(int a1<ebp>)
{
  int v2; // ecx@1
  int v3; // esi@1

  sub_10035668();
  v3 = v2;
  *(_DWORD *)(a1 - 16) = v2;
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  sub_1004733D((PSLIST_HEADER)(v2 + 96));
  *(_DWORD *)(a1 - 4) = -1;
  sub_1004733D((PSLIST_HEADER)(v3 + 16));
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (100473E6) --------------------------------------------------------
int __thiscall sub_100473E6(int this)
{
  int result; // eax@1

  result = this + 188;
  *(_DWORD *)(this + 188) = 1;
  return result;
}

//----- (10047418) --------------------------------------------------------
bool __cdecl sub_10047418(int a1)
{
  bool result; // eax@1

  result = sub_10032DCA(*(_DWORD *)(a1 + 36));
  if ( !result )
  {
    sub_10047424(*(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    *(_DWORD *)(a1 + 72) = 0;
  }
  return result;
}

//----- (10047424) --------------------------------------------------------
int __stdcall sub_10047424(int a1)
{
  int v1; // esi@1
  int v2; // ecx@2
  int result; // eax@3

  v1 = a1;
  while ( v1 )
  {
    v2 = v1 - 284;
    v1 = *(_DWORD *)v1;
    if ( v2 )
      result = (**(int (__stdcall ***)(_DWORD))v2)(1);
  }
  return result;
}

//----- (10047448) --------------------------------------------------------
char __thiscall sub_10047448(void *ListHead, int a2, signed int a3, char a4)
{
  signed int v4; // edx@1
  int v6; // esi@1
  char result; // al@2
  int v8; // eax@3
  int v9; // ecx@3
  int v10; // edx@4
  int v11; // edi@4
  int v12; // edx@5
  PSINGLE_LIST_ENTRY v18; // eax@14
  int v19; // ST08_4@14

  v6 = (int)ListHead;
  v4 = a3 >> *((_DWORD *)ListHead + 11);
  _EBX = a3 & (*((_DWORD *)ListHead + 10) - 1);
  if ( v4 < *((_DWORD *)ListHead + 15) )
  {
    v9 = *((_DWORD *)ListHead + 14);
    v8 = *(_DWORD *)(v6 + 52);
    if ( v4 < v9 )
    {
      v11 = *(_DWORD *)(v8 + 4 * v4);
    }
    else
    {
      v10 = v4 - v9;
      v11 = *(_DWORD *)(v8 + 4 * v9 - 4);
      if ( v10 >= 0 )
      {
        v12 = v10 + 1;
        do
        {
          v11 = *(_DWORD *)(v11 + 4);
          --v12;
        }
        while ( v12 );
      }
    }
    _ECX = *(_DWORD *)v11 + 4 * _EBX;
    _EDX = 0;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 == a2 )
    {
      _ECX = v11 + 8;
      __asm { lock cmpxchg [ecx], ebx }
      if ( a4 )
      {
        if ( (signed int)QueryDepthSList((PSLIST_HEADER)v6) <= *(_DWORD *)(v6 + 68) )
        {
          InterlockedPushEntrySList((PSLIST_HEADER)v6, (PSINGLE_LIST_ENTRY)(a2 + 284));
        }
        else
        {
          InterlockedPushEntrySList((PSLIST_HEADER)(v6 + 8), (PSINGLE_LIST_ENTRY)(a2 + 284));
          if ( (signed int)QueryDepthSList((PSLIST_HEADER)(v6 + 8)) > *(_DWORD *)(v6 + 68) )
          {
            if ( !sub_10032DCA(*(_DWORD *)(v6 + 36)) )
            {
              _EDX = 1;
              _ECX = v6 + 72;
              __asm { lock cmpxchg [ecx], edx }
              v18 = InterlockedFlushSList((PSLIST_HEADER)(v6 + 8));
              v19 = *(_DWORD *)(v6 + 36);
              *(_DWORD *)(v6 + 16) = v18;
              sub_1003337E(v6 + 20, (int (__cdecl *)(_DWORD))sub_10047418, v6, v19);
            }
          }
        }
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10047543) --------------------------------------------------------
char __thiscall sub_10047543(void *this, int a2)
{
  int v2; // ecx@2

  if ( *(_DWORD *)(a2 + 12) & 0xFFFFFFF )
    v2 = (int)((char *)this + 16);
  else
    v2 = (int)((char *)this + 96);
  return sub_10047448((void *)v2, a2, *(_DWORD *)(a2 + 248), 1);
}

//----- (1004756C) --------------------------------------------------------
int __thiscall sub_1004756C(int *this, int a2, int a3)
{
  unsigned int v3; // edi@1
  unsigned int v4; // esi@1
  int *v5; // esi@1
  int *v7; // [sp+10h] [bp-4h]@1

  v5 = this;
  v3 = 0;
  v7 = this;
  sub_100313DF(a2, a2, 0, *this);
  v4 = (unsigned int)(*v5 + 31) >> 5;
  if ( v4 )
  {
    do
    {
      *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * v3) = *(_DWORD *)(v7[1] + 4 * v3) & *(_DWORD *)(*(_DWORD *)(a3 + 4) + 4 * v3);
      ++v3;
    }
    while ( v3 < v4 );
  }
  return a2;
}

//----- (100475BC) --------------------------------------------------------
int __userpurge sub_100475BC<eax>(int a1<ecx>, int a2<edi>, int a3, int a4)
{
  int result; // eax@1
  int v5; // esi@1
  int v6; // ST14_4@1
  int v8; // eax@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // edx@1

  v5 = a1;
  v6 = a1 + 32;
  sub_10030F90((void *)(a1 + 32));
  _EBX = v5 + 28;
  v8 = sub_10041243(v5, v5 + 28, a2, *(_DWORD *)(v5 + 28), 1);
  v9 = v8;
  v10 = *(_DWORD *)_EBX - *(_DWORD *)(v8 + 16);
  v11 = *(_DWORD *)(v8 + 12);
  _EAX = 1;
  *(_DWORD *)(v11 + 4 * v10) = a4;
  __asm { lock xadd [ebx], eax }
  *(_DWORD *)v6 = 0;
  result = a3;
  *(_DWORD *)(a3 + 4) = v10;
  *(_DWORD *)a3 = v9;
  return result;
}

//----- (1004760F) --------------------------------------------------------
int __thiscall sub_1004760F(int this, int a2)
{
  int v3; // ebx@1

  v3 = this;
  sub_10034BBC((void *)(this + 8));
  *(_DWORD *)(a2 + 232) = 0;
  **(_DWORD **)(v3 + 4) = a2;
  *(_DWORD *)(v3 + 4) = a2 + 232;
  return sub_10034BCC((void *)(v3 + 8));
}

//----- (10047642) --------------------------------------------------------
int __thiscall sub_10047642(int this, int a2)
{
  unsigned int v2; // edi@1
  unsigned int v3; // esi@1
  int result; // eax@2

  v3 = (unsigned int)(*(_DWORD *)this + 31) >> 5;
  v2 = 0;
  if ( v3 )
  {
    do
    {
      _EDX = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * v2);
      result = 4 * v2 + *(_DWORD *)(this + 4);
      __asm { lock or [eax], edx }
      ++v2;
    }
    while ( v2 < v3 );
  }
  return result;
}

//----- (1004767A) --------------------------------------------------------
int __userpurge sub_1004767A<eax>(int a1<ecx>, int a2<edi>, int a3, int a4, int a5, int a6)
{
  int v7; // eax@1

  v7 = (*(int (__stdcall **)(int, signed int))(*(_DWORD *)a1 + 20))(a5, 1);
  *(_DWORD *)a6 = v7;
  sub_100476A0(v7, a2, a3, a4);
  return a3;
}

//----- (100476A0) --------------------------------------------------------
int __userpurge sub_100476A0<eax>(int a1<ecx>, int a2<edi>, int a3, int a4)
{
  sub_100475BC(a1 + 52, a2, a3, a4);
  return a3;
}

//----- (100476B8) --------------------------------------------------------
int __thiscall sub_100476B8(int this)
{
  int result; // eax@1
  int v2; // edi@1
  int v3; // esi@1

  v3 = this;
  v2 = *(_DWORD *)(*(_DWORD *)(this + 256) + 4);
  sub_100476EB(*(void **)(*(_DWORD *)(this + 256) + 4), this + 28);
  result = *(_DWORD *)(v3 + 12) & 0xFFFFFFF;
  if ( result == 3 )
    result = sub_10047729(v2, *(_DWORD *)(v3 + 36), v3);
  return result;
}

//----- (100476EB) --------------------------------------------------------
bool __thiscall sub_100476EB(void *this, int a2)
{
  bool result; // eax@1
  void *v3; // esi@1
  int v4; // eax@2
  char v5; // [sp+8h] [bp-8h]@2
  void *v6; // [sp+Ch] [bp-4h]@2

  v3 = this;
  result = sub_10033340(a2, (int)((char *)this + 72));
  if ( result )
  {
    v4 = sub_1004756C((int *)a2, (int)&v5, (int)((char *)v3 + 72));
    sub_10047642((int)((char *)v3 + 84), v4);
    result = sub_10030383(v6);
  }
  return result;
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (10047729) --------------------------------------------------------
int __thiscall sub_10047729(int this, int a2, int a3)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 92);
  if ( !*(_DWORD *)((a2 << 7) + result) )
  {
    _EDX = a3;
    _ECX = (a2 << 7) + *(_DWORD *)(this + 92);
    result = 0;
    __asm { lock cmpxchg [ecx], edx }
  }
  return result;
}

//----- (1004774F) --------------------------------------------------------
int __thiscall sub_1004774F(int this, int a2)
{
  return sub_1004760F(this + 288, a2);
}

//----- (1004775E) --------------------------------------------------------
int __thiscall sub_1004775E(int this, int a2, int a3)
{
  char v3; // zf@1
  int result; // eax@2
  int v5; // [sp+0h] [bp-10h]@1
  int v6; // [sp+8h] [bp-8h]@1
  int v7; // [sp+Ch] [bp-4h]@1

  v3 = (*(_BYTE *)(this + 48) & 4) == 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  if ( v3 )
    result = *(_DWORD *)(this + 56);
  else
    result = sub_1004102C((void *)this, (int)&v5, a3);
  return result;
}

//----- (1004778A) --------------------------------------------------------
int __thiscall sub_1004778A(int this, int a2, char a3)
{
  int v3; // esi@1
  char v4; // zf@1
  int result; // eax@2
  int v6; // eax@6
  int v7; // [sp+8h] [bp-10h]@1
  int v8; // [sp+10h] [bp-8h]@1
  int v9; // [sp+14h] [bp-4h]@1

  v3 = this;
  v7 = 0;
  v4 = (*(_BYTE *)(this + 48) & 4) == 0;
  v8 = 0;
  v9 = 0;
  if ( v4 )
  {
    result = *(_DWORD *)(this + 56);
    if ( a3 )
    {
      if ( !result )
      {
        sub_10030F90((void *)(this + 8));
        result = *(_DWORD *)(v3 + 56);
        if ( !result )
        {
          v6 = sub_10032B1F(*(_DWORD *)(v3 + 4));
          result = sub_10040DA9((void *)v3, (int)&v7, v6);
          *(_DWORD *)(v3 + 56) = result;
        }
        *(_DWORD *)(v3 + 8) = 0;
      }
    }
  }
  else
  {
    result = sub_1004128D(this, (int)&v7, a3);
  }
  return result;
}

//----- (100477F0) --------------------------------------------------------
int __userpurge sub_100477F0<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4)
{
  int v4; // esi@1
  int v5; // ecx@1
  HANDLE v6; // eax@1
  int v7; // eax@2
  int v8; // eax@5
  int v9; // edx@5
  int v10; // ecx@5
  int v12; // ecx@8

  sub_10035668();
  v4 = v5;
  *(_DWORD *)(a2 - 16) = v5;
  sub_1002E166(a1, a2, *(_DWORD *)(a2 + 8), 1);
  *(_DWORD *)(a2 - 4) = 0;
  *(_DWORD *)v4 = off_10065DEC;
  *(_DWORD *)(v4 + 160) = 0;
  *(_DWORD *)(v4 + 164) = 0;
  v6 = CreateEventW(0, 0, 0, 0);
  *(_DWORD *)(v4 + 168) = v6;
  if ( !v6 )
  {
    v7 = GetLastError();
    if ( v7 > 0 )
      v7 = (unsigned __int16)v7 | 0x80070000;
    sub_10030079(a2 - 32, v7);
    sub_100355DB(a2 - 32, (int)&unk_1006C6F4);
  }
  *(_DWORD *)(v4 + 24) = sub_100327A8(*(_DWORD *)(v4 + 28));
  v8 = sub_1002ADB1(v9, v10, a1, 0, 28);
  if ( v8 )
  {
    *(_DWORD *)(v8 + 8) = 0;
    *(_DWORD *)(v8 + 12) = 0;
    *(_DWORD *)(v8 + 16) = 0;
    *(_DWORD *)(v8 + 20) = 0;
    *(_DWORD *)(v8 + 24) = 1;
  }
  else
  {
    v8 = 0;
  }
  v12 = *(_DWORD *)(v4 + 28);
  *(_DWORD *)(v4 + 156) = v8;
  sub_100409E1(v12 + 200, v8);
  sub_10047A88(v4, *(_DWORD *)(a2 + 12));
  return sub_10035636(20);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 10065DEC: using guessed type int (*off_10065DEC[5])();

//----- (100478B6) --------------------------------------------------------
int __usercall sub_100478B6<eax>(int a1<ebp>)
{
  int v2; // ecx@1
  void *v3; // esi@1

  sub_10035668();
  v3 = (void *)v2;
  *(_DWORD *)(a1 - 16) = v2;
  *(_DWORD *)v2 = off_10065DEC;
  *(_DWORD *)(a1 - 4) = 0;
  sub_1004795D(v2, a1);
  sub_1002E280(v3);
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 10065DEC: using guessed type int (*off_10065DEC[5])();

//----- (100478E3) --------------------------------------------------------
void *__thiscall sub_100478E3(void *this, char a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1

  v3 = this;
  sub_100478B6(ebp0);
  if ( a2 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10047902) --------------------------------------------------------
int __userpurge sub_10047902<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  int ebp0; // ebp@0

  if ( sub_100479DA(a1, ebp0, a3) )
    JUMPOUT(*(unsigned int *)loc_1002CBD6);
  return sub_1002CCF6(a2, a4);
}
// 1002CBD6: using guessed type _DWORD __cdecl loc_1002CBD6(_DWORD);

//----- (10047923) --------------------------------------------------------
DWORD __thiscall sub_10047923(int this)
{
  DWORD result; // eax@1
  int v2; // esi@1
  int v3; // ST0C_4@1
  int v4; // eax@1

  v2 = this;
  v3 = *(_DWORD *)(this + 8);
  v4 = (*(int (**)(void))(**(_DWORD **)(this + 28) + 4))();
  sub_1002F346(3, 4, v4, v3);
  _ECX = v2 + 44;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  result = _EAX + 1;
  if ( result == 1 )
    result = WaitForSingleObject(*(HANDLE *)(v2 + 168), 0xFFFFFFFFu);
  return result;
}

//----- (1004795D) --------------------------------------------------------
int __usercall sub_1004795D<eax>(int a1<ecx>, int a2<ebp>)
{
  int v2; // esi@1
  int result; // eax@7

  v2 = a1;
  sub_1002E71E(a1, a2);
  if ( *(_DWORD *)(v2 + 164) )
  {
    CloseHandle(*(HANDLE *)(v2 + 164));
    *(_DWORD *)(v2 + 164) = 0;
  }
  if ( *(_DWORD *)(v2 + 168) )
    CloseHandle(*(HANDLE *)(v2 + 168));
  if ( *(_DWORD *)(v2 + 160) )
    sub_10033FC5(*(void **)(v2 + 160));
  result = *(_DWORD *)(v2 + 156);
  *(_DWORD *)(v2 + 156) = 0;
  *(_DWORD *)(result + 24) = 0;
  return result;
}

//----- (100479B5) --------------------------------------------------------
char __userpurge sub_100479B5<al>(void *this<ecx>, int edi0<edi>, int a2)
{
  int v3; // eax@1
  int ebp0; // ebp@0
  char result; // al@2

  v3 = sub_100479DA((int)this, ebp0, edi0);
  if ( v3 )
    result = sub_1002CC6A((void *)v3, a2);
  else
    result = sub_10030383((LPVOID)(a2 - 4));
  return result;
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (100479DA) --------------------------------------------------------
int __usercall sub_100479DA<eax>(int a1<ecx>, int a2<ebp>, int a3<edi>)
{
  int v3; // esi@1

  v3 = a1;
  if ( !*(_DWORD *)(a1 + 160) )
    *(_DWORD *)(a1 + 160) = sub_10032C57(a2, a3);
  return *(_DWORD *)(v3 + 160);
}

//----- (100479FC) --------------------------------------------------------
signed int __cdecl sub_100479FC()
{
  return -1;
}

//----- (10047A00) --------------------------------------------------------
int __stdcall sub_10047A00(int a1, int a2, int a3, int a4)
{
  sub_10032322(*(void **)(a2 + 28), a2, 0);
  return sub_10034B87(a1, a3);
}

//----- (10047A22) --------------------------------------------------------
char __stdcall sub_10047A22(int a1, int a2)
{
  UnregisterWait(*(HANDLE *)(a1 + 172));
  return sub_10032322(*(void **)(a1 + 28), a1, 0);
}

//----- (10047A45) --------------------------------------------------------
bool __thiscall sub_10047A45(int this)
{
  return *(_DWORD *)(this + 44) == 1;
}

//----- (10047A51) --------------------------------------------------------
void __thiscall sub_10047A51(int this, char a2)
{
  int v2; // eax@3
  char v3; // [sp+0h] [bp-Ch]@6

  if ( a2 )
  {
    ++*(_DWORD *)(this + 20);
  }
  else
  {
    v2 = *(_DWORD *)(this + 20);
    if ( !v2 )
    {
      sub_1002FFE7((int)&v3);
      sub_100355DB((int)&v3, (int)&unk_1006D278);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_10047A88);
    }
    *(_DWORD *)(this + 20) = v2 - 1;
  }
}

//----- (10047A88) --------------------------------------------------------
DWORD __thiscall sub_10047A88(int Context, char a2)
{
  DWORD result; // eax@1
  int v3; // edi@1
  HANDLE *v4; // ebx@2
  HANDLE v5; // ST08_4@2
  HANDLE v6; // ST04_4@2
  HANDLE v7; // eax@2
  int v8; // eax@3
  char v9; // [sp+8h] [bp-10h]@13

  v3 = Context;
  *(_BYTE *)(Context + 152) = a2;
  result = GetCurrentThreadId();
  *(_DWORD *)(v3 + 68) = result;
  if ( !a2 )
  {
    v4 = (HANDLE *)(v3 + 164);
    v5 = GetCurrentProcess();
    v6 = GetCurrentThread();
    v7 = GetCurrentProcess();
    if ( !DuplicateHandle(v7, v6, v5, (LPHANDLE)(v3 + 164), 0, 0, 2u) )
    {
      v8 = GetLastError();
      if ( v8 > 0 )
LABEL_12:
        v8 = (unsigned __int16)v8 | 0x80070000;
LABEL_13:
      sub_10030079((int)&v9, v8);
      sub_100355DB((int)&v9, (int)&unk_1006C6F4);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_10047B55);
    }
    if ( sub_1003D695() < 3 )
    {
      result = RegisterWaitForSingleObject(
                 (PHANDLE)(v3 + 172),
                 *v4,
                 (WAITORTIMERCALLBACK)sub_10047A22,
                 (PVOID)v3,
                 0xFFFFFFFFu,
                 0xCu);
    }
    else
    {
      result = sub_10034B13((int)*v4, (int)sub_10047A00, v3);
      *(_DWORD *)(v3 + 172) = result;
    }
    if ( !result )
    {
      v8 = GetLastError();
      if ( v8 > 0 )
        goto LABEL_12;
      goto LABEL_13;
    }
  }
  return result;
}
// 1003D695: using guessed type int sub_1003D695(void);

//----- (10047B55) --------------------------------------------------------
BOOL __usercall sub_10047B55<eax>(int a1<ecx>, int a2<ebp>)
{
  BOOL result; // eax@1
  int v3; // esi@1

  v3 = a1;
  sub_1002EE1F(a1, a2);
  result = *(_DWORD *)(v3 + 164);
  if ( result )
  {
    result = CloseHandle(*(HANDLE *)(v3 + 164));
    *(_DWORD *)(v3 + 164) = 0;
  }
  return result;
}

//----- (10047B77) --------------------------------------------------------
int __thiscall sub_10047B77(void *this)
{
  return (*(int (**)(void))(*(_DWORD *)this + 28))();
}

//----- (10047B7C) --------------------------------------------------------
int __thiscall sub_10047B7C(void *this)
{
  void *v1; // esi@1
  int v2; // ecx@2
  int v3; // ST0C_4@2
  int v4; // eax@2
  int result; // eax@3
  int v13; // ecx@8
  int v14; // eax@8
  int v15; // ST10_4@8
  int v16; // [sp-4h] [bp-14h]@6
  char v17; // [sp+4h] [bp-Ch]@6
  int v18; // [sp+8h] [bp-8h]@8
  int v19; // [sp+Ch] [bp-4h]@8

  v1 = this;
  if ( this == sub_10032365() )
  {
    sub_1002FF27((int)&v17);
    v16 = (int)&unk_1006D240;
    goto LABEL_8;
  }
  v3 = *((_DWORD *)v1 + 2);
  v4 = (*(int (**)(void))(**((_DWORD **)v1 + 7) + 4))();
  sub_1002F346(4, 4, v4, v3);
  _EAX = (int)((char *)v1 + 44);
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  v2 = _ECX - 1;
  if ( !v2 )
    return SetEvent(*((HANDLE *)v1 + 42));
  result = v2 + 1;
  if ( (unsigned int)(v2 + 1) > 1 )
  {
    sub_1002FF39((int)&v17);
    v16 = (int)&unk_1006D208;
LABEL_8:
    sub_100355DB((int)&v17, v16);
    __asm { int     3               ; Trap to Debugger }
    v14 = (*(int (__stdcall **)(_DWORD, void *, int, _DWORD, int))(**(_DWORD **)(v13 + 28) + 4))(
            *(_DWORD *)(v13 + 8),
            v1,
            v15,
            *(_DWORD *)&v17,
            v18);
    sub_1002F346(5, 4, v14, v19);
    result = SwitchToThread();
  }
  return result;
}

//----- (10047C12) --------------------------------------------------------
void *__thiscall sub_10047C12(void *this, int a2)
{
  void *v3; // esi@1

  v3 = this;
  sub_10045F26(this, a2);
  *(_DWORD *)v3 = off_10065E58;
  *((_DWORD *)v3 + 1) = off_10065E84;
  return v3;
}
// 10065E58: using guessed type int (*off_10065E58[3])();
// 10065E84: using guessed type int (*off_10065E84[5])();

//----- (10047C34) --------------------------------------------------------
void *__thiscall sub_10047C34(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v4; // edi@1

  v4 = this;
  *(_DWORD *)this = off_10065E38;
  sub_10031425(ebp0, a2);
  *(_DWORD *)v4 = off_10065ED0;
  *((_DWORD *)v4 + 2) = &off_10065EF4;
  return v4;
}
// 10065E38: using guessed type int (*off_10065E38[7])();
// 10065ED0: using guessed type int (*off_10065ED0[2])();
// 10065EF4: using guessed type int (__stdcall *off_10065EF4)(int);

//----- (10047C61) --------------------------------------------------------
int __thiscall sub_10047C61(int this)
{
  *(_DWORD *)this = off_10065ED0;
  *(_DWORD *)(this + 8) = &off_10065EF4;
  return sub_10031875(this);
}
// 10031875: using guessed type _DWORD __thiscall sub_10031875(_DWORD ecx0);
// 10065ED0: using guessed type int (*off_10065ED0[2])();
// 10065EF4: using guessed type int (__stdcall *off_10065EF4)(int);

//----- (10047C75) --------------------------------------------------------
void __stdcall sub_10047C75(int a1)
{
  JUMPOUT(*(unsigned int *)loc_10047C85);
}
// 10047C85: using guessed type int __stdcall loc_10047C85(int);

//----- (10047C7D) --------------------------------------------------------
void *__thiscall sub_10047C7D(void *this, char a2)
{
  void *v2; // esi@1

  v2 = (char *)this - 8;
  sub_10047C61((int)((char *)this - 8));
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10047CD0) --------------------------------------------------------
int __thiscall sub_10047CD0(void *this, int a2, unsigned int a3)
{
  return sub_10031C51((char *)this + 8, a2, a3);
}

//----- (10047CDC) --------------------------------------------------------
int __usercall sub_10047CDC<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // ecx@1
  int v4; // edx@1
  int v5; // ecx@1

  sub_10035668();
  v3 = sub_1002ADB1(v4, v5, a1, a3, 520);
  *(_DWORD *)(a2 - 16) = v3;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v3 )
    sub_10047C34((void *)v3, *(_DWORD *)(a2 + 8));
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (10047D0F) --------------------------------------------------------
int __usercall sub_10047D0F<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // edx@1
  int v4; // esi@1
  int v5; // ecx@1
  int v6; // edx@1

  sub_10035668();
  v4 = v5;
  v3 = sub_1002ADB1(v6, v5, a1, a3, 240);
  *(_DWORD *)(a2 - 16) = v3;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v3 )
    sub_10047C12((void *)v3, v4 != 8 ? v4 : 0);
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (10047D4D) --------------------------------------------------------
int __userpurge sub_10047D4D<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5)
{
  int v5; // eax@1
  int v6; // edx@1
  int v7; // ecx@1

  sub_10035668();
  v5 = sub_1002ADB1(v6, v7, a1, a3, 208);
  *(_DWORD *)(a2 - 16) = v5;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v5 )
    sub_10052C22(a2, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12));
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (10047D85) --------------------------------------------------------
signed int __cdecl sub_10047D85()
{
  return 1;
}

//----- (10047D89) --------------------------------------------------------
int __thiscall sub_10047D89(void *this)
{
  return (int)((char *)this - 8);
}

//----- (10047D8D) --------------------------------------------------------
int __thiscall sub_10047D8D(int this)
{
  return (*(int (**)(void))(*(_DWORD *)(this + 8) + 4))();
}

//----- (10047D95) --------------------------------------------------------
int __userpurge sub_10047D95<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  sub_10032B9B(a1, a2 + 8, a3, a4, a5);
  return a5;
}

//----- (10047DAF) --------------------------------------------------------
int __userpurge sub_10047DAF<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  return sub_10047D95(a1, a2 - 8, a3, a4, a5);
}

//----- (10047DBA) --------------------------------------------------------
int __thiscall sub_10047DBA(void *this, int a2, unsigned int a3)
{
  return sub_10033E82((char *)this + 8, a2, a3);
}

//----- (10047DC6) --------------------------------------------------------
int __thiscall sub_10047DC6(void *this, int a2, int a3, int a4)
{
  return sub_10034222((char *)this + 8, a2, a3, a4);
}

//----- (10047DD2) --------------------------------------------------------
DWORD __cdecl sub_10047DD2()
{
  DWORD result; // eax@1
  int v1; // eax@2
  char v2; // [sp+0h] [bp-10h]@5

  result = TlsAlloc();
  dword_10077090 = result;
  if ( result == -1 )
  {
    v1 = GetLastError();
    if ( v1 > 0 )
      v1 = (unsigned __int16)v1 | 0x80070000;
    sub_10030079((int)&v2, v1);
    sub_100355DB((int)&v2, (int)&unk_1006C6F4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10047E16);
  }
  return result;
}

//----- (10047E16) --------------------------------------------------------
BOOL __cdecl sub_10047E16()
{
  BOOL result; // eax@1

  result = TlsFree(dword_10077090);
  dword_10077090 = 0;
  return result;
}

//----- (10047E2A) --------------------------------------------------------
signed int __usercall sub_10047E2A<eax>(int a1<ecx>, int a2<ebx>)
{
  unsigned int v2; // eax@1
  void *v3; // eax@6
  signed int result; // eax@8
  int v5; // edx@9
  signed int v6; // ecx@9
  int v7; // [sp-4h] [bp-8h]@6

  v2 = dword_10077AA0;
  if ( !dword_10077AA0 )
  {
    v2 = 512;
LABEL_5:
    dword_10077AA0 = v2;
    goto LABEL_6;
  }
  if ( dword_10077AA0 < 20 )
  {
    v2 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v3 = sub_10037506(a1, a2, v2, 4u);
  dword_10077A9C = v3;
  if ( v3 || (dword_10077AA0 = 20, v3 = sub_10037506(v7, a2, 0x14u, 4u), dword_10077A9C = v3, v3) )
  {
    v5 = 0;
    v6 = (signed int)&off_10074DD8;
    while ( 1 )
    {
      *(_DWORD *)((char *)v3 + v5) = v6;
      v6 += 32;
      v5 += 4;
      if ( v6 >= (signed int)&unk_10075058 )
        break;
      v3 = dword_10077A9C;
    }
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 10074DD8: using guessed type void *off_10074DD8;
// 10077AA0: using guessed type int dword_10077AA0;

//----- (10047E9D) --------------------------------------------------------
void __usercall sub_10047E9D(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v3; // edx@1
  int v4; // ecx@1

  sub_1004804A(a1, a2, a3);
  if ( byte_1007696C )
    sub_10052C7E(v3, v4, a3);
  sub_100309A2(a3, dword_10077A9C);
  dword_10077A9C = 0;
}
// 1007696C: using guessed type char byte_1007696C;

//----- (10047EC4) --------------------------------------------------------
void **__cdecl sub_10047EC4()
{
  return &off_10074DD8;
}
// 10074DD8: using guessed type void *off_10074DD8;

//----- (10047ECA) --------------------------------------------------------
void __usercall sub_10047ECA(int a1<edx>, int a2<ebx>, int a3<edi>, unsigned int a4)
{
  if ( a4 < (unsigned int)&off_10074DD8 || a4 > (unsigned int)&unk_10075038 )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(a4 + 32));
  }
  else
  {
    sub_10036A43(a1, (int)&off_10074DD8, a2, a3, ((signed int)(a4 - (_DWORD)&off_10074DD8) >> 5) + 16);
    *(_DWORD *)(a4 + 12) |= 0x8000u;
  }
}
// 10074DD8: using guessed type void *off_10074DD8;

//----- (10047F09) --------------------------------------------------------
void __usercall sub_10047F09(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5, int a6)
{
  if ( a5 >= 20 )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(a6 + 32));
  }
  else
  {
    sub_10036A43(a1, a2, a3, a4, a5 + 16);
    *(_DWORD *)(a6 + 12) |= 0x8000u;
  }
}

//----- (10047F39) --------------------------------------------------------
void __cdecl sub_10047F39(unsigned int a1)
{
  if ( a1 < (unsigned int)&off_10074DD8 || a1 > (unsigned int)&unk_10075038 )
  {
    LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 32));
  }
  else
  {
    *(_DWORD *)(a1 + 12) &= 0xFFFF7FFFu;
    sub_10036BA7(((signed int)(a1 - (_DWORD)&off_10074DD8) >> 5) + 16);
  }
}
// 10074DD8: using guessed type void *off_10074DD8;

//----- (10047F73) --------------------------------------------------------
void __cdecl sub_10047F73(signed int a1, int a2)
{
  if ( a1 >= 20 )
  {
    LeaveCriticalSection((LPCRITICAL_SECTION)(a2 + 32));
  }
  else
  {
    *(_DWORD *)(a2 + 12) &= 0xFFFF7FFFu;
    sub_10036BA7(a1 + 16);
  }
}

//----- (10047FA0) --------------------------------------------------------
void __usercall sub_10047FA0(int a1<ebx>, int a2<edi>, int edx0<edx>, int a4<ecx>, int a3)
{
  int v5; // eax@6
  int v6; // edx@6
  int v7; // ecx@6

  if ( a3 )
  {
    if ( !sub_10047FE6(a3) )
    {
      if ( *(_DWORD *)(a3 + 12) & 0x4000 )
      {
        v5 = sub_1004FC85(a1, a2, a3);
        sub_10052D1B(v6, v7, a1, v5);
      }
    }
  }
  else
  {
    sub_10048053(edx0, a4, a1, 0);
  }
}

//----- (10047FE6) --------------------------------------------------------
signed int __cdecl sub_10047FE6(int a1)
{
  signed int v1; // ebx@1
  int v2; // edi@3
  int v3; // ST08_4@4
  const void *v4; // ST04_4@4
  int v5; // eax@4
  int v6; // edx@4
  int v7; // ST00_4@4
  int v8; // eax@4
  int v9; // eax@5
  int v11; // ecx@8

  v1 = 0;
  if ( (*(_DWORD *)(a1 + 12) & 3) == 2 )
  {
    if ( *(_DWORD *)(a1 + 12) & 0x108 )
    {
      v2 = *(_DWORD *)a1 - *(_DWORD *)(a1 + 8);
      if ( *(_DWORD *)a1 - *(_DWORD *)(a1 + 8) > 0 )
      {
        v3 = *(_DWORD *)a1 - *(_DWORD *)(a1 + 8);
        v4 = *(const void **)(a1 + 8);
        v5 = sub_1004FC85(0, v2, a1);
        sub_1004FEE8(v6, v7, 0, v2, v5, v4, v3);
        if ( v8 == v2 )
        {
          v9 = *(_DWORD *)(a1 + 12);
          if ( (_BYTE)v9 < 0 )
            *(_DWORD *)(a1 + 12) = v9 & 0xFFFFFFFD;
        }
        else
        {
          *(_DWORD *)(a1 + 12) |= 0x20u;
          v1 = -1;
        }
      }
    }
  }
  v11 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = v11;
  return v1;
}

//----- (1004804A) --------------------------------------------------------
void __usercall sub_1004804A(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  sub_10048053(a1, a2, a3, 1);
}

//----- (10048053) --------------------------------------------------------
void __usercall sub_10048053(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // edx@1
  signed int i; // esi@1
  int v6; // eax@3
  int v7; // eax@5
  int v8; // edx@5
  int v9; // eax@7
  int v10; // [sp-4h] [bp-38h]@1
  int v11; // [sp-4h] [bp-38h]@5

  sub_10036A43(a1, a2, a3, 0, 1);
  for ( i = 0; ; ++i )
  {
    if ( i >= dword_10077AA0 )
    {
      sub_10036BA7(1);
      return;
    }
    v6 = *((_DWORD *)dword_10077A9C + i);
    if ( v6 )
    {
      if ( *(_BYTE *)(v6 + 12) & 0x83 )
        break;
    }
  }
  sub_10047F09(v4, v10, a4, 0, i, *((_DWORD *)dword_10077A9C + i));
  v7 = *((_DWORD *)dword_10077A9C + i);
  if ( *(_BYTE *)(v7 + 12) & 0x83 )
  {
    if ( a4 == 1 )
    {
      sub_10047FA0(1, 0, v8, v11, *((_DWORD *)dword_10077A9C + i));
      v9 == -1;
    }
    else
    {
      if ( !a4 )
      {
        if ( *(_BYTE *)(v7 + 12) & 2 )
          sub_10047FA0(a4, 0, v8, v11, *((_DWORD *)dword_10077A9C + i));
      }
    }
  }
  sub_10047F73(i, *((_DWORD *)dword_10077A9C + i));
}
// 10077AA0: using guessed type int dword_10077AA0;

//----- (100481B5) --------------------------------------------------------
int __usercall sub_100481B5<eax>(int a1<ebx>, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // edx@2
  unsigned int v6; // ecx@2
  void (__cdecl *v7)(_DWORD); // edx@9
  int v8; // ebx@14
  signed int v9; // edi@15
  int v10; // edi@17
  int v11; // ST04_4@36

  result = sub_10041A74(a1);
  v4 = result;
  if ( result )
  {
    v5 = *(_DWORD *)(result + 92);
    v6 = *(_DWORD *)(result + 92);
    do
    {
      if ( *(_DWORD *)v6 == a2 )
        break;
      v6 += 12;
    }
    while ( v6 < v5 + 144 );
    if ( v6 >= v5 + 144 || *(_DWORD *)v6 != a2 )
      v6 = 0;
    if ( v6 && (v7 = *(void (__cdecl **)(_DWORD))(v6 + 8)) != 0 )
    {
      if ( v7 == (void (__cdecl *)(_DWORD))5 )
      {
        *(_DWORD *)(v6 + 8) = 0;
        result = 1;
      }
      else
      {
        if ( v7 == (void (__cdecl *)(_DWORD))1 )
        {
          result = -1;
        }
        else
        {
          v8 = *(_DWORD *)(result + 96);
          *(_DWORD *)(result + 96) = a3;
          if ( *(_DWORD *)(v6 + 4) == 8 )
          {
            v9 = 36;
            do
            {
              v9 += 12;
              *(_DWORD *)(v9 + *(_DWORD *)(result + 92) - 4) = 0;
            }
            while ( v9 < 144 );
            v10 = *(_DWORD *)(result + 100);
            switch ( *(_DWORD *)v6 )
            {
              case 0xC000008E:
                *(_DWORD *)(result + 100) = 131;
                break;
              case 0xC0000090:
                *(_DWORD *)(result + 100) = 129;
                break;
              case 0xC0000091:
                *(_DWORD *)(result + 100) = 132;
                break;
              case 0xC0000093:
                *(_DWORD *)(result + 100) = 133;
                break;
              case 0xC000008D:
                *(_DWORD *)(result + 100) = 130;
                break;
              case 0xC000008F:
                *(_DWORD *)(result + 100) = 134;
                break;
              case 0xC0000092:
                *(_DWORD *)(result + 100) = 138;
                break;
              case 0xC00002B5:
                *(_DWORD *)(result + 100) = 141;
                break;
              case 0xC00002B4:
                *(_DWORD *)(result + 100) = 142;
                break;
            }
            v7(8);
            *(_DWORD *)(v4 + 100) = v10;
          }
          else
          {
            v11 = *(_DWORD *)(v6 + 4);
            *(_DWORD *)(v6 + 8) = 0;
            v7(v11);
          }
          *(_DWORD *)(v4 + 96) = v8;
          result = -1;
        }
      }
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (10048310) --------------------------------------------------------
int __usercall sub_10048310<eax>(int a1<ebx>, int a2, int a3)
{
  int result; // eax@2

  if ( a2 == -529697949 )
    result = sub_100481B5(a1, -529697949, a3);
  else
    result = 0;
  return result;
}

//----- (1004832E) --------------------------------------------------------
void __usercall sub_1004832E(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int ebp0; // ebp@0
  int v5; // eax@1
  unsigned int v6; // ecx@1
  signed int v7; // ebx@1
  int v8; // ST08_4@1
  int v9; // ecx@8
  signed int v10; // esi@10
  int v11; // eax@12
  unsigned int v12; // ecx@12
  int v13; // eax@14
  HANDLE *v14; // edx@14
  signed int v15; // edi@14
  char v16; // al@18
  DWORD v17; // eax@20
  int v18; // esi@21
  int v19; // esi@29
  DWORD v20; // eax@33
  HANDLE v21; // eax@35
  HANDLE v22; // edi@35
  DWORD v23; // eax@37
  int v24; // eax@38
  char v25; // al@39
  struct _STARTUPINFOW StartupInfo; // [sp+10h] [bp-74h]@6
  int v27; // [sp+54h] [bp-30h]@10
  int v28; // [sp+58h] [bp-2Ch]@14
  LPBYTE v29; // [sp+5Ch] [bp-28h]@8
  unsigned int v30; // [sp+60h] [bp-24h]@1
  BYTE *v31; // [sp+64h] [bp-20h]@8
  int v32; // [sp+68h] [bp-1Ch]@8
  CPPEH_RECORD ms_exc; // [sp+6Ch] [bp-18h]@1

  sub_10036A43(a1, a2, a3, a4, 11);
  v7 = 0;
  ms_exc.disabled = 0;
  v5 = (int)sub_10037506(v8, 0, 0x20u, 0x40u);
  v6 = v5;
  v30 = v5;
  if ( !v5 )
  {
    sub_1004B230(ebp0, (int)&__security_cookie, (int)&ms_exc.prev_er, 0xFFFFFFFEu);
    return;
  }
  dword_100770A0[0] = v5;
  dword_10077A98 = 32;
  while ( v6 < v5 + 2048 )
  {
    *(_WORD *)(v6 + 4) = 2560;
    *(_DWORD *)v6 = -1;
    *(_DWORD *)(v6 + 8) = 0;
    *(_BYTE *)(v6 + 36) &= 0x80u;
    *(_BYTE *)(v6 + 36) &= 0x7Fu;
    *(_WORD *)(v6 + 37) = 2570;
    *(_WORD *)(v6 + 52) = 0;
    v6 += 64;
    v30 = v6;
    v5 = dword_100770A0[0];
  }
  GetStartupInfoW(&StartupInfo);
  if ( StartupInfo.cbReserved2 && StartupInfo.lpReserved2 )
  {
    v9 = *(_DWORD *)StartupInfo.lpReserved2;
    v32 = v9;
    v29 = StartupInfo.lpReserved2 + 4;
    v31 = &StartupInfo.lpReserved2[v9 + 4];
    if ( v9 >= 2048 )
    {
      v9 = 2048;
      v32 = 2048;
    }
    v10 = 1;
    v27 = 1;
    while ( 1 )
    {
      if ( dword_10077A98 >= v9 )
        goto LABEL_14;
      v11 = (int)sub_10037506(v9, 0, 0x20u, 0x40u);
      v12 = v11;
      v30 = v11;
      if ( !v11 )
      {
        v9 = dword_10077A98;
        v32 = dword_10077A98;
LABEL_14:
        v15 = 0;
        v28 = 0;
        v13 = (int)v29;
        v14 = (HANDLE *)v31;
        while ( v15 < v9 )
        {
          if ( *v14 != (HANDLE)-1 )
          {
            if ( *v14 != (HANDLE)-2 )
            {
              v16 = *(_BYTE *)v13;
              if ( v16 & 1 )
              {
                if ( v16 & 8 || (v17 = GetFileType(*v14), v14 = (HANDLE *)v31, v17) )
                {
                  v18 = dword_100770A0[v15 >> 5] + ((v15 & 0x1F) << 6);
                  v30 = v18;
                  *(_DWORD *)v18 = *v14;
                  *(_BYTE *)(v18 + 4) = *v29;
                  InitializeCriticalSectionAndSpinCount((LPCRITICAL_SECTION)(v18 + 12), 0xFA0u);
                  ++*(_DWORD *)(v18 + 8);
                  v14 = (HANDLE *)v31;
                }
                v9 = v32;
              }
            }
          }
          ++v15;
          v28 = v15;
          v13 = (int)(v29++ + 1);
          ++v14;
          v31 = (BYTE *)v14;
        }
        break;
      }
      dword_100770A0[v10] = v11;
      dword_10077A98 += 32;
      while ( v12 < dword_100770A0[v10] + 2048 )
      {
        *(_WORD *)(v12 + 4) = 2560;
        *(_DWORD *)v12 = -1;
        *(_DWORD *)(v12 + 8) = 0;
        *(_BYTE *)(v12 + 36) &= 0x80u;
        *(_WORD *)(v12 + 37) = 2570;
        *(_WORD *)(v12 + 52) = 0;
        v12 += 64;
        v30 = v12;
      }
      ++v10;
      v27 = v10;
      v9 = v32;
    }
  }
  while ( 1 )
  {
    v28 = v7;
    if ( v7 >= 3 )
      break;
    v19 = dword_100770A0[0] + (v7 << 6);
    v30 = v19;
    if ( *(_DWORD *)v19 != -1 && *(_DWORD *)v19 != -2 )
    {
      *(_BYTE *)(v19 + 4) |= 0x80u;
      goto LABEL_46;
    }
    *(_BYTE *)(v19 + 4) = -127;
    if ( v7 )
      v20 = -(v7 != 1) - 11;
    else
      v20 = -10;
    v21 = GetStdHandle(v20);
    v22 = v21;
    if ( v21 != (HANDLE)-1 )
    {
      if ( v21 )
      {
        v23 = GetFileType(v21);
        if ( v23 )
        {
          *(_DWORD *)v19 = v22;
          v24 = (unsigned __int8)v23;
          if ( v24 == 2 )
          {
            v25 = *(_BYTE *)(v19 + 4) | 0x40;
            goto LABEL_42;
          }
          if ( v24 == 3 )
          {
            v25 = *(_BYTE *)(v19 + 4) | 8;
LABEL_42:
            *(_BYTE *)(v19 + 4) = v25;
          }
          InitializeCriticalSectionAndSpinCount((LPCRITICAL_SECTION)(v19 + 12), 0xFA0u);
          ++*(_DWORD *)(v19 + 8);
          goto LABEL_46;
        }
      }
    }
    *(_BYTE *)(v19 + 4) |= 0x40u;
    *(_DWORD *)v19 = -2;
    if ( dword_10077A9C )
      *(_DWORD *)(*((_DWORD *)dword_10077A9C + v7) + 16) = -2;
LABEL_46:
    ++v7;
  }
  ms_exc.disabled = -2;
  sub_10036BA7(11);
}
// 10074200: using guessed type int __security_cookie;
// 100770A0: using guessed type int dword_100770A0[];
// 10077A98: using guessed type int dword_10077A98;

//----- (100485DC) --------------------------------------------------------
void __usercall sub_100485DC(int a1<ebx>)
{
  LPVOID *v1; // esi@1
  LPVOID v2; // edi@2
  struct _RTL_CRITICAL_SECTION *v3; // edi@4

  v1 = (LPVOID *)dword_100770A0;
  do
  {
    v2 = *v1;
    if ( *v1 )
    {
      if ( v2 < (char *)v2 + 2048 )
      {
        v3 = (struct _RTL_CRITICAL_SECTION *)((char *)v2 + 12);
        do
        {
          if ( *((_DWORD *)v3 - 1) )
            DeleteCriticalSection(v3);
          v3 = (struct _RTL_CRITICAL_SECTION *)((char *)v3 + 64);
        }
        while ( (char *)((char *)v3 - 12) < (char *)*v1 + 2048 );
      }
      sub_100309A2(a1, *v1);
      *v1 = 0;
    }
    ++v1;
  }
  while ( (signed int)v1 < (signed int)byte_100771A0 );
}
// 100770A0: using guessed type int dword_100770A0[];

//----- (1004862E) --------------------------------------------------------
signed int __usercall sub_1004862E<eax>(int a1<ebx>)
{
  int v1; // esi@3
  int v2; // ebx@6
  int v3; // edx@8
  int v4; // edi@9
  signed int result; // eax@10
  int v6; // [sp+0h] [bp-8h]@6
  int v7; // [sp+4h] [bp-4h]@6

  if ( !dword_10078AD0 )
    sub_10041F75(a1);
  byte_100772A4 = 0;
  GetModuleFileNameA(0, byte_100771A0, 0x104u);
  v1 = dword_10078B54;
  dword_10076994 = (int)byte_100771A0;
  if ( !dword_10078B54 || !*(_BYTE *)dword_10078B54 )
    v1 = (int)byte_100771A0;
  sub_100486DF(v1, 0, 0, (int)&v7, (int)&v6);
  v2 = v7;
  if ( (unsigned int)v7 < 0x3FFFFFFF
    && (unsigned int)v6 < 0xFFFFFFFF
    && (v3 = v6 + 4 * v7, v3 >= (unsigned int)v6)
    && (v4 = sub_10037550(v3, v6, v7, v6 + 4 * v7)) != 0 )
  {
    sub_100486DF(v1, v4, v4 + 4 * v2, (int)&v7, (int)&v6);
    dword_10076980 = v7 - 1;
    dword_10076984 = (LPVOID)v4;
    result = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 10076980: using guessed type int dword_10076980;
// 10076994: using guessed type int dword_10076994;
// 100772A4: using guessed type char byte_100772A4;
// 10078AD0: using guessed type int dword_10078AD0;
// 10078B54: using guessed type int dword_10078B54;

//----- (100486DF) --------------------------------------------------------
int __cdecl sub_100486DF(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // esi@1
  bool v8; // ecx@3
  char v9; // al@5
  unsigned __int8 v10; // ST00_1@8
  signed int v11; // edx@29
  unsigned int v12; // ecx@29
  unsigned __int8 v13; // al@43
  signed int v14; // eax@48
  int result; // eax@61
  bool v16; // [sp+14h] [bp+8h]@3
  bool v17; // [sp+24h] [bp+18h]@20
  char v18; // [sp+27h] [bp+1Bh]@8

  v5 = a5;
  *(_DWORD *)a5 = 0;
  v7 = a1;
  *(_DWORD *)a4 = 1;
  v6 = a3;
  if ( a2 )
  {
    *(_DWORD *)a2 = a3;
    a2 += 4;
  }
  v8 = 0;
  v16 = 0;
  do
  {
    if ( *(_BYTE *)v7 == 34 )
    {
      ++v7;
      v8 = v8 == 0;
      v16 = v8;
      v9 = 34;
    }
    else
    {
      ++*(_DWORD *)v5;
      if ( v6 )
        *(_BYTE *)v6++ = *(_BYTE *)v7;
      v18 = *(_BYTE *)v7;
      v10 = *(_BYTE *)v7++;
      if ( sub_10037713(v5, v6, v10) )
      {
        ++*(_DWORD *)v5;
        if ( v6 )
          *(_BYTE *)v6++ = *(_BYTE *)v7;
        ++v7;
      }
      v9 = v18;
      if ( !v18 )
      {
        --v7;
        goto LABEL_20;
      }
      v8 = v16;
    }
  }
  while ( v8 || v9 != 32 && v9 != 9 );
  if ( v6 )
    *(_BYTE *)(v6 - 1) = 0;
LABEL_20:
  v17 = 0;
  while ( *(_BYTE *)v7 )
  {
    while ( *(_BYTE *)v7 == 32 || *(_BYTE *)v7 == 9 )
      ++v7;
    if ( !*(_BYTE *)v7 )
      break;
    if ( a2 )
    {
      *(_DWORD *)a2 = v6;
      a2 += 4;
    }
    ++*(_DWORD *)a4;
    while ( 1 )
    {
      v11 = 1;
      v12 = 0;
      while ( *(_BYTE *)v7 == 92 )
      {
        ++v7;
        ++v12;
      }
      if ( *(_BYTE *)v7 == 34 )
      {
        if ( !(v12 & 1) )
        {
          if ( v17 && *(_BYTE *)(v7 + 1) == 34 )
          {
            ++v7;
          }
          else
          {
            v11 = 0;
            v17 = v17 == 0;
          }
        }
        v12 >>= 1;
      }
      while ( v12 )
      {
        --v12;
        if ( v6 )
          *(_BYTE *)v6++ = 92;
        ++*(_DWORD *)v5;
      }
      v13 = *(_BYTE *)v7;
      if ( !*(_BYTE *)v7 )
        break;
      if ( v17 == v12 && (v13 == 32 || v13 == 9) )
        break;
      if ( v11 )
      {
        v14 = sub_10037713(v5, v6, v13);
        if ( v6 )
        {
          if ( v14 )
          {
            *(_BYTE *)v6++ = *(_BYTE *)v7++;
            ++*(_DWORD *)v5;
          }
          *(_BYTE *)v6++ = *(_BYTE *)v7;
        }
        else
        {
          if ( v14 )
          {
            ++v7;
            ++*(_DWORD *)v5;
          }
        }
        ++*(_DWORD *)v5;
      }
      ++v7;
    }
    if ( v6 )
      *(_BYTE *)v6++ = 0;
    ++*(_DWORD *)v5;
  }
  if ( a2 )
    *(_DWORD *)a2 = 0;
  result = a4;
  ++*(_DWORD *)result;
  return result;
}

//----- (1004885B) --------------------------------------------------------
signed int __usercall sub_1004885B<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // edi@3
  int v3; // esi@3
  int v5; // eax@7
  int v6; // ST14_4@7
  void *v7; // edi@9
  void *v8; // esi@10
  int v9; // eax@11
  int v10; // eax@12
  int v11; // [sp-10h] [bp-10h]@11

  if ( !dword_10078AD0 )
    sub_10041F75(a2);
  v3 = (int)dword_10076734;
  v2 = 0;
  if ( !dword_10076734 )
    return -1;
  while ( *(_BYTE *)v3 )
  {
    if ( *(_BYTE *)v3 != 61 )
      ++v2;
    v5 = sub_10035550(v3);
    a1 = v6;
    v3 += v5 + 1;
  }
  v7 = sub_10037506(a1, a2, v2 + 1, 4u);
  dword_1007698C = v7;
  if ( !v7 )
    return -1;
  v8 = dword_10076734;
  if ( !*(_BYTE *)dword_10076734 )
  {
LABEL_17:
    sub_100309A2(a2, v8);
    dword_10076734 = 0;
    *(_DWORD *)v7 = 0;
    dword_10078AD4 = 1;
    return 0;
  }
  while ( 1 )
  {
    v9 = sub_10035550((int)v8);
    a2 = v9 + 1;
    if ( *(_BYTE *)v8 != 61 )
      break;
LABEL_15:
    v8 = (char *)v8 + a2;
    if ( !*(_BYTE *)v8 )
    {
      v8 = dword_10076734;
      goto LABEL_17;
    }
  }
  v10 = (int)sub_10037506(v11, a2, v9 + 1, 1u);
  *(_DWORD *)v7 = v10;
  if ( v10 )
  {
    if ( sub_1003ADE5(a2, (int)v7, v10, a2, (int)v8) )
    {
      sub_1003A17E(a2, (int)v7);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1004893C);
    }
    v7 = (char *)v7 + 4;
    goto LABEL_15;
  }
  sub_100309A2(a2, dword_1007698C);
  dword_1007698C = 0;
  return -1;
}
// 10078AD0: using guessed type int dword_10078AD0;
// 10078AD4: using guessed type int dword_10078AD4;

//----- (1004893C) --------------------------------------------------------
signed int __cdecl sub_1004893C()
{
  signed int result; // eax@3
  DWORD v1; // ecx@4
  LARGE_INTEGER PerformanceCount; // [sp+8h] [bp-14h]@4
  struct _FILETIME SystemTimeAsFileTime; // [sp+10h] [bp-Ch]@1
  DWORD v4; // [sp+18h] [bp-4h]@4

  SystemTimeAsFileTime.dwLowDateTime = 0;
  SystemTimeAsFileTime.dwHighDateTime = 0;
  if ( __security_cookie != -1153374642 && __security_cookie & 0xFFFF0000 )
  {
    result = ~__security_cookie;
    dword_10074204 = ~__security_cookie;
  }
  else
  {
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v4 = SystemTimeAsFileTime.dwLowDateTime ^ SystemTimeAsFileTime.dwHighDateTime;
    v4 = GetCurrentThreadId() ^ SystemTimeAsFileTime.dwLowDateTime ^ SystemTimeAsFileTime.dwHighDateTime;
    v4 ^= GetCurrentProcessId();
    QueryPerformanceCounter(&PerformanceCount);
    result = (signed int)&v4;
    v1 = (unsigned int)&v4 ^ v4 ^ PerformanceCount.LowPart ^ PerformanceCount.HighPart;
    if ( v1 == -1153374642 )
    {
      v1 = -1153374641;
    }
    else
    {
      if ( !(v1 & 0xFFFF0000) )
      {
        result = (v1 | 0x4711) << 16;
        v1 |= result;
      }
    }
    __security_cookie = v1;
    dword_10074204 = ~v1;
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 10074204: using guessed type int dword_10074204;

//----- (100489D6) --------------------------------------------------------
int __usercall sub_100489D6<eax>(int a1<ebx>)
{
  int result; // eax@1
  const WCHAR *v2; // edi@1
  const WCHAR *i; // esi@2
  int v4; // eax@5
  int v5; // edx@5
  int v6; // ecx@5
  int v7; // esi@5
  int v8; // ebx@6
  int v9; // [sp+4h] [bp-4h]@5

  v2 = GetEnvironmentStringsW();
  result = 0;
  if ( v2 )
  {
    for ( i = v2; *i; ++i )
    {
      do
        ++i;
      while ( *i );
    }
    v7 = ((signed int)((char *)i - (char *)v2) >> 1) + 1;
    v4 = WideCharToMultiByte(0, 0, v2, v7, 0, 0, 0, 0);
    v9 = v4;
    if ( v4 && (v8 = sub_10037550(v5, v6, a1, v4)) != 0 )
    {
      if ( !WideCharToMultiByte(0, 0, v2, v7, (LPSTR)v8, v9, 0, 0) )
      {
        sub_100309A2(v8, (LPVOID)v8);
        v8 = 0;
      }
      FreeEnvironmentStringsW((LPWCH)v2);
      result = v8;
    }
    else
    {
      FreeEnvironmentStringsW((LPWCH)v2);
      result = 0;
    }
  }
  return result;
}

//----- (10048A61) --------------------------------------------------------
void __cdecl sub_10048A61()
{
  unsigned int i; // esi@1

  for ( i = (unsigned int)&unk_1006BAA0; i < (unsigned int)&unk_1006BAA0; i += 4 )
  {
    if ( *(_DWORD *)i )
      (*(void (**)(void))i)();
  }
}

//----- (10048A81) --------------------------------------------------------
void __cdecl sub_10048A81()
{
  unsigned int i; // esi@1

  for ( i = (unsigned int)&unk_1006BAA8; i < (unsigned int)&unk_1006BAA8; i += 4 )
  {
    if ( *(_DWORD *)i )
      (*(void (**)(void))i)();
  }
}

//----- (10048AB0) --------------------------------------------------------
void __userpurge sub_10048AB0(int a1<ebp>, int a2<edi>, int a3<esi>, int a4, int a5, int a6)
{
  void (__stdcall *v6)(_DWORD, _DWORD); // eax@1

  *(_DWORD *)(a1 - 4) = *(_DWORD *)(a1 + 12) + 12;
  sub_10052F1C();
  v6(a2, a3);
  sub_10052F1C();
}

//----- (10048AFC) --------------------------------------------------------
int __cdecl sub_10048AFC(int a1)
{
  return a1 != 0 ? 1 : 0;
}

//----- (10048B0B) --------------------------------------------------------
signed int __cdecl sub_10048B0B(LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int cchWideChar, int a4)
{
  signed int result; // eax@1
  LPWSTR v5; // edi@1
  int v6; // esi@1
  int v7; // eax@12
  unsigned __int8 *i; // eax@14
  int v9; // ecx@14
  int v10; // eax@16
  char v11; // zf@16
  int v12; // eax@20
  int v13; // [sp+8h] [bp-14h]@6
  int v14; // [sp+10h] [bp-Ch]@29
  char v15; // [sp+14h] [bp-8h]@28
  int v16; // [sp+18h] [bp-4h]@15
  int v17; // [sp+24h] [bp+8h]@19

  result = cchWideChar;
  v5 = lpWideCharStr;
  v6 = 0;
  if ( lpWideCharStr )
  {
    if ( !cchWideChar )
      return result;
    *lpWideCharStr = 0;
  }
  if ( !lpMultiByteStr )
  {
    *(_DWORD *)sub_10037669(0) = 22;
    sub_1003A16E(0, (int)lpWideCharStr);
    return -1;
  }
  sub_1003018D((int)&v13, (int)lpMultiByteStr, (int)lpWideCharStr, a4);
  if ( !lpWideCharStr )
  {
    if ( !*(_DWORD *)(v13 + 168) )
    {
      v12 = sub_10035550((int)lpMultiByteStr);
LABEL_24:
      v6 = v12;
      goto LABEL_28;
    }
    v6 = -1;
    v7 = MultiByteToWideChar(*(_DWORD *)(v13 + 4), 9u, lpMultiByteStr, -1, 0, 0);
    if ( !v7 )
    {
      *(_DWORD *)sub_10037669((int)lpMultiByteStr) = 42;
      goto LABEL_28;
    }
LABEL_27:
    v6 = v7 - 1;
    goto LABEL_28;
  }
  if ( !*(_DWORD *)(v13 + 168) )
  {
    if ( (unsigned int)cchWideChar > 0 )
    {
      do
      {
        *v5 = (unsigned __int8)lpMultiByteStr[v6];
        if ( !lpMultiByteStr[v6] )
          break;
        ++v6;
        ++v5;
      }
      while ( v6 < (unsigned int)cchWideChar );
    }
    goto LABEL_28;
  }
  v6 = -1;
  v7 = MultiByteToWideChar(*(_DWORD *)(v13 + 4), 9u, lpMultiByteStr, -1, lpWideCharStr, cchWideChar);
  if ( v7 )
    goto LABEL_27;
  if ( GetLastError() == 122 )
  {
    v9 = cchWideChar;
    for ( i = (unsigned __int8 *)lpMultiByteStr; ; i = (unsigned __int8 *)(v10 + 1) )
    {
      v17 = (int)i;
      if ( !v9 )
        break;
      v16 = v9 - 1;
      if ( !*i )
        break;
      v11 = sub_10042727((int)lpMultiByteStr, (int)v5, *i, (int)&v13) == 0;
      v10 = v17;
      if ( !v11 )
      {
        v10 = v17 + 1;
        if ( !*(_BYTE *)(v17 + 1) )
          goto LABEL_21;
      }
      v9 = v16;
    }
    v12 = MultiByteToWideChar(
            *(_DWORD *)(v13 + 4),
            1u,
            lpMultiByteStr,
            i - (unsigned __int8 *)lpMultiByteStr,
            v5,
            cchWideChar);
    if ( v12 )
      goto LABEL_24;
  }
LABEL_21:
  *(_DWORD *)sub_10037669((int)lpMultiByteStr) = 42;
  *v5 = 0;
LABEL_28:
  if ( v15 )
    *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
  return v6;
}

//----- (10048C6A) --------------------------------------------------------
signed int __cdecl sub_10048C6A(int a1, LPWSTR lpWideCharStr, int cchWideChar, LPCSTR lpMultiByteStr, int a5, int a6)
{
  signed int v6; // esi@1
  int v7; // eax@9
  int v8; // eax@12
  int v9; // eax@13
  int v10; // eax@17
  signed int v12; // [sp-4h] [bp-20h]@12
  int v13; // [sp+Ch] [bp-10h]@9
  int v14; // [sp+14h] [bp-8h]@27
  char v15; // [sp+18h] [bp-4h]@26

  v6 = 0;
  if ( lpWideCharStr )
  {
    if ( !cchWideChar )
    {
LABEL_5:
      v6 = 22;
      *(_DWORD *)sub_10037669(cchWideChar) = 22;
      sub_1003A16E(cchWideChar, (int)lpWideCharStr);
      return v6;
    }
    *lpWideCharStr = 0;
  }
  else
  {
    if ( cchWideChar )
      goto LABEL_5;
  }
  if ( a1 )
    *(_DWORD *)a1 = 0;
  sub_1003018D((int)&v13, cchWideChar, (int)lpWideCharStr, a6);
  v7 = cchWideChar;
  if ( a5 <= (unsigned int)cchWideChar )
    v7 = a5;
  if ( (unsigned int)v7 <= 0x7FFFFFFF )
  {
    v9 = sub_10048B0B(lpWideCharStr, lpMultiByteStr, v7, (int)&v13);
    if ( v9 == -1 )
    {
      if ( lpWideCharStr )
        *lpWideCharStr = 0;
      v6 = *(_DWORD *)sub_10037669(cchWideChar);
      goto LABEL_26;
    }
    v10 = v9 + 1;
    if ( lpWideCharStr )
    {
      if ( v10 > (unsigned int)cchWideChar )
      {
        if ( a5 != -1 )
        {
          *lpWideCharStr = 0;
          v8 = sub_10037669(cchWideChar);
          v12 = 34;
          goto LABEL_21;
        }
        v10 = cchWideChar;
        v6 = 80;
      }
      lpWideCharStr[v10 - 1] = 0;
    }
    if ( a1 )
      *(_DWORD *)a1 = v10;
    goto LABEL_26;
  }
  v8 = sub_10037669(cchWideChar);
  v12 = 22;
LABEL_21:
  v6 = v12;
  *(_DWORD *)v8 = v12;
  sub_1003A16E(cchWideChar, (int)lpWideCharStr);
LABEL_26:
  if ( v15 )
    *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
  return v6;
}

//----- (10048D46) --------------------------------------------------------
int __cdecl sub_10048D46(int a1, LPWSTR lpWideCharStr, int cchWideChar, LPCSTR lpMultiByteStr, int a5)
{
  return sub_10048C6A(a1, lpWideCharStr, cchWideChar, lpMultiByteStr, a5, 0);
}

//----- (10048D64) --------------------------------------------------------
signed int __cdecl sub_10048D64(CHAR *a1, int lpWideCharStr, int cbMultiByte, int a4)
{
  int v4; // ebx@1
  LPCWSTR v5; // edi@1
  int v6; // esi@1
  int v8; // eax@6
  LPSTR v9; // ecx@6
  const WCHAR v10; // ax@10
  LPCWSTR v11; // eax@15
  int v12; // edx@15
  int v13; // eax@26
  int v14; // edi@26
  int v15; // eax@32
  int v16; // eax@33
  int v17; // edx@33
  int v18; // eax@38
  LPSTR v19; // ecx@39
  CHAR v20; // al@40
  const WCHAR v21; // ax@46
  int v22; // eax@50
  int v23; // [sp+Ch] [bp-2Ch]@6
  int v24; // [sp+14h] [bp-24h]@55
  char v25; // [sp+18h] [bp-20h]@54
  int v26; // [sp+1Ch] [bp-1Ch]@38
  LPSTR lpMultiByteStr; // [sp+20h] [bp-18h]@1
  LPCWSTR v28; // [sp+24h] [bp-14h]@1
  BOOL UsedDefaultChar; // [sp+28h] [bp-10h]@1
  CHAR MultiByteStr[8]; // [sp+2Ch] [bp-Ch]@33
  unsigned int v31; // [sp+34h] [bp-4h]@1
  int v32; // [sp+38h] [bp+0h]@1

  v31 = (unsigned int)&v32 ^ __security_cookie;
  v4 = cbMultiByte;
  v5 = (LPCWSTR)lpWideCharStr;
  v6 = 0;
  lpMultiByteStr = a1;
  v28 = (LPCWSTR)lpWideCharStr;
  UsedDefaultChar = 0;
  if ( a1 && !cbMultiByte )
    return 0;
  if ( !lpWideCharStr )
  {
    *(_DWORD *)sub_10037669(cbMultiByte) = 22;
    sub_1003A16E(cbMultiByte, 0);
    return -1;
  }
  sub_1003018D((int)&v23, cbMultiByte, lpWideCharStr, a4);
  v9 = lpMultiByteStr;
  v8 = v23;
  if ( !lpMultiByteStr )
  {
    if ( *(_DWORD *)(v23 + 168) )
    {
      v22 = WideCharToMultiByte(*(_DWORD *)(v23 + 4), 0, (LPCWSTR)lpWideCharStr, -1, 0, 0, 0, &UsedDefaultChar);
      if ( v22 && !UsedDefaultChar )
      {
        v14 = v22 - 1;
        goto LABEL_54;
      }
    }
    else
    {
      v21 = *(_WORD *)lpWideCharStr;
      if ( !*(_WORD *)lpWideCharStr )
        goto LABEL_49;
      while ( v21 <= 0xFFu )
      {
        ++v5;
        ++v6;
        v21 = *v5;
        if ( !*v5 )
          goto LABEL_49;
      }
    }
LABEL_53:
    *(_DWORD *)sub_10037669(cbMultiByte) = 42;
    v14 = -1;
    goto LABEL_54;
  }
  if ( !*(_DWORD *)(v23 + 168) )
  {
    if ( cbMultiByte )
    {
      while ( *v5 <= 0xFFu )
      {
        v9[v6] = *(_BYTE *)v5;
        v10 = *v5;
        ++v5;
        if ( v10 )
        {
          ++v6;
          if ( v6 < (unsigned int)cbMultiByte )
            continue;
        }
        goto LABEL_49;
      }
      goto LABEL_44;
    }
LABEL_49:
    v14 = v6;
    goto LABEL_54;
  }
  if ( *(_DWORD *)(v23 + 116) == 1 )
  {
    if ( cbMultiByte )
    {
      v11 = (LPCWSTR)lpWideCharStr;
      v12 = cbMultiByte;
      do
      {
        if ( !*v11 )
          break;
        ++v11;
        --v12;
      }
      while ( v12 );
      if ( v12 )
      {
        if ( !*v11 )
          v4 = ((signed int)((char *)v11 - lpWideCharStr) >> 1) + 1;
      }
      v8 = v23;
    }
    v6 = WideCharToMultiByte(
           *(_DWORD *)(v8 + 4),
           0,
           (LPCWSTR)lpWideCharStr,
           v4,
           lpMultiByteStr,
           v4,
           0,
           &UsedDefaultChar);
    if ( v6 && !UsedDefaultChar )
    {
      if ( !lpMultiByteStr[v6 - 1] )
        --v6;
      goto LABEL_49;
    }
    goto LABEL_44;
  }
  v13 = WideCharToMultiByte(
          *(_DWORD *)(v23 + 4),
          0,
          (LPCWSTR)lpWideCharStr,
          -1,
          lpMultiByteStr,
          cbMultiByte,
          0,
          &UsedDefaultChar);
  v14 = v13;
  if ( v13 )
  {
    if ( !UsedDefaultChar )
    {
      v6 = v13 - 1;
      goto LABEL_49;
    }
LABEL_44:
    *(_DWORD *)sub_10037669(v4) = 42;
    v6 = -1;
    goto LABEL_49;
  }
  if ( UsedDefaultChar || GetLastError() != 122 )
    goto LABEL_44;
  if ( cbMultiByte )
  {
    v15 = (int)v28;
    do
    {
      v16 = WideCharToMultiByte(
              *(_DWORD *)(v23 + 4),
              0,
              (LPCWSTR)v15,
              1,
              MultiByteStr,
              *(_DWORD *)(v23 + 116),
              0,
              &UsedDefaultChar);
      v17 = v16;
      if ( !v16 )
        goto LABEL_53;
      if ( UsedDefaultChar || v16 < 0 || (unsigned int)v16 > 5 )
        goto LABEL_53;
      if ( v16 + v14 > (unsigned int)cbMultiByte )
        break;
      v18 = 0;
      v26 = 0;
      if ( v17 > 0 )
      {
        v19 = lpMultiByteStr;
        do
        {
          v20 = MultiByteStr[v18];
          v19[v14] = v20;
          if ( !v20 )
            goto LABEL_54;
          v18 = v26 + 1;
          ++v14;
          v26 = v18;
        }
        while ( v18 < v17 );
      }
      v15 = (int)(v28 + 1);
      ++v28;
    }
    while ( v14 < (unsigned int)cbMultiByte );
  }
LABEL_54:
  if ( v25 )
    *(_DWORD *)(v24 + 112) &= 0xFFFFFFFDu;
  return v14;
}
// 10074200: using guessed type int __security_cookie;
// 10048D64: using guessed type CHAR MultiByteStr[8];

//----- (10048FC9) --------------------------------------------------------
signed int __usercall sub_10048FC9<eax>(int a1<ebx>, int a2, CHAR *a3, int cbMultiByte, int lpWideCharStr, int a6, int a7)
{
  int v7; // eax@7
  int v8; // eax@10
  signed int result; // eax@12
  signed int v10; // eax@13
  int v11; // eax@17
  signed int v12; // ecx@23
  signed int v13; // [sp-8h] [bp-14h]@10

  if ( a3 )
  {
    if ( cbMultiByte )
      goto LABEL_3;
LABEL_12:
    *(_DWORD *)sub_10037669(a1) = 22;
    sub_1003A16E(a1, cbMultiByte);
    return 22;
  }
  if ( cbMultiByte )
    goto LABEL_12;
LABEL_3:
  if ( a3 )
    *a3 = 0;
  if ( a2 )
    *(_DWORD *)a2 = 0;
  v7 = cbMultiByte;
  if ( a6 <= (unsigned int)cbMultiByte )
    v7 = a6;
  if ( (unsigned int)v7 > 0x7FFFFFFF )
  {
    v8 = sub_10037669(a2);
    v13 = 22;
LABEL_22:
    *(_DWORD *)v8 = v13;
    sub_1003A16E(a2, cbMultiByte);
    return v13;
  }
  v10 = sub_10048D64(a3, lpWideCharStr, v7, a7);
  if ( v10 == -1 )
  {
    if ( a3 )
      *a3 = 0;
    result = *(_DWORD *)sub_10037669(a2);
  }
  else
  {
    v11 = v10 + 1;
    if ( a3 )
    {
      if ( v11 <= (unsigned int)cbMultiByte )
      {
        v12 = 0;
      }
      else
      {
        if ( a6 != -1 )
        {
          *a3 = 0;
          if ( cbMultiByte <= (unsigned int)v11 )
          {
            v8 = sub_10037669(a2);
            v13 = 34;
            goto LABEL_22;
          }
        }
        v11 = cbMultiByte;
        v12 = 80;
      }
      a3[v11 - 1] = 0;
    }
    else
    {
      v12 = 0;
    }
    if ( a2 )
      *(_DWORD *)a2 = v11;
    result = v12;
  }
  return result;
}

//----- (10049092) --------------------------------------------------------
LPVOID __usercall sub_10049092<eax>(void *a1<ecx>, int a2<ebx>, unsigned int a3, unsigned int a4)
{
  LPVOID v4; // esi@1
  int v5; // eax@4
  int v7; // [sp+4h] [bp-4h]@1

  v7 = 0;
  v4 = sub_100492BF(a1, a2, a3, a4, (int)&v7);
  if ( !v4 )
  {
    if ( v7 )
    {
      if ( sub_10037669(a2) )
      {
        v5 = sub_10037669(a2);
        *(_DWORD *)v5 = v7;
      }
    }
  }
  return v4;
}

//----- (100490D0) --------------------------------------------------------
signed int __usercall sub_100490D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, int a7)
{
  int v7; // edx@2
  int v8; // ecx@3
  int v9; // eax@5
  signed int result; // eax@6
  __int16 v11; // ax@8
  signed int v12; // [sp-4h] [bp-8h]@5

  if ( !a5 || (v7 = a6, !a6) )
    goto LABEL_5;
  v8 = a7;
  if ( !a7 )
  {
    *(_WORD *)a5 = 0;
LABEL_5:
    v9 = sub_10037669(a3);
    v12 = 22;
LABEL_6:
    *(_DWORD *)v9 = v12;
    sub_1003A16E(a3, a4);
    return v12;
  }
  do
  {
    v11 = *(_WORD *)v8;
    *(_WORD *)(a5 - a7 + v8) = *(_WORD *)v8;
    v8 += 2;
    if ( !v11 )
      break;
    --v7;
  }
  while ( v7 );
  result = 0;
  if ( !v7 )
  {
    *(_WORD *)a5 = 0;
    v9 = sub_10037669(a3);
    v12 = 34;
    goto LABEL_6;
  }
  return result;
}

//----- (1004912C) --------------------------------------------------------
BOOL __cdecl sub_1004912C(int a1, DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, int a7)
{
  UINT v7; // ecx@1
  BOOL v8; // edi@1
  int v9; // eax@3
  int v10; // edx@3
  int v11; // ecx@3
  int v12; // ebx@3
  unsigned int v14; // eax@7
  char *v15; // esi@8
  int v16; // eax@10
  int v17; // esi@12
  int v18; // eax@15
  char v19; // [sp+0h] [bp-10h]@8
  unsigned int v20; // [sp+Ch] [bp-4h]@1
  int v21; // [sp+10h] [bp+0h]@1

  v20 = (unsigned int)&v21 ^ __security_cookie;
  v7 = CodePage;
  v8 = 0;
  if ( !CodePage )
  {
    CodePage = *(_DWORD *)(*(_DWORD *)a1 + 4);
    v7 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  }
  v9 = MultiByteToWideChar(v7, 8 * (a7 != 0) + 1, lpMultiByteStr, cbMultiByte, 0, 0);
  v12 = v9;
  if ( !v9 )
    return 0;
  if ( v9 > 0 && (unsigned int)v9 <= 0x7FFFFFF0 )
  {
    v14 = 2 * v9 + 8;
    if ( v14 > 0x400 )
    {
      v16 = sub_10030910(v10, v11, v12, 0, 2 * v12 + 8);
      v15 = (char *)v16;
      if ( v16 )
      {
        *(_DWORD *)v16 = 56797;
        goto LABEL_12;
      }
    }
    else
    {
      sub_1003F590(v14, v11, v19);
      v15 = &v19;
      if ( &v19 )
      {
        *(_DWORD *)&v19 = 52428;
LABEL_12:
        v17 = (int)(v15 + 8);
        goto LABEL_14;
      }
    }
    return 0;
  }
  v17 = 0;
LABEL_14:
  if ( !v17 )
    return 0;
  sub_10039210((void *)v17, 0, 2 * v12);
  v18 = MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, cbMultiByte, (LPWSTR)v17, v12);
  if ( v18 )
    v8 = GetStringTypeW(dwInfoType, (LPCWSTR)v17, v18, lpCharType);
  sub_1002CAA7(v12, v17);
  return v8;
}
// 10074200: using guessed type int __security_cookie;

//----- (10049218) --------------------------------------------------------
int __usercall sub_10049218<eax>(int a1<ebx>, int a2<edi>, int a3, DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, int a9)
{
  int result; // eax@1
  int v10; // [sp+0h] [bp-10h]@1
  int v11; // [sp+8h] [bp-8h]@2
  char v12; // [sp+Ch] [bp-4h]@1

  sub_1003018D((int)&v10, a1, a2, a3);
  result = sub_1004912C((int)&v10, dwInfoType, lpMultiByteStr, cbMultiByte, lpCharType, CodePage, a9);
  if ( v12 )
    *(_DWORD *)(v11 + 112) &= 0xFFFFFFFDu;
  return result;
}

//----- (10049256) --------------------------------------------------------
int __usercall sub_10049256<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, const void *lpMem, unsigned int a5, unsigned int a6)
{
  int v6; // edi@1
  int result; // eax@3
  int v8; // esi@4
  SIZE_T v9; // eax@5
  int v10; // ST08_4@5
  int v11; // ebx@6

  v6 = 0;
  if ( a5 && (a1 = 0xFFFFFFE0 % a5, 0xFFFFFFE0 / a5 < a6) )
  {
    *(_DWORD *)sub_10037669(a3) = 12;
    result = 0;
  }
  else
  {
    v8 = a6 * a5;
    if ( lpMem )
    {
      v9 = sub_1003B21A((int)lpMem, 0, lpMem);
      a2 = v10;
      v6 = v9;
    }
    v11 = sub_10030C36(a1, a2, (int)lpMem, v6, (LPVOID)lpMem, v8);
    if ( v11 )
    {
      if ( v6 < (unsigned int)v8 )
        sub_10039210((void *)(v6 + v11), 0, v8 - v6);
    }
    result = v11;
  }
  return result;
}

//----- (100492BF) --------------------------------------------------------
LPVOID __usercall sub_100492BF<eax>(void *this<ecx>, int ebx0<ebx>, unsigned int a2, unsigned int a3, int a4)
{
  int v5; // eax@3
  unsigned int v7; // esi@6
  LPVOID v8; // ecx@8

  if ( a2 && 0xFFFFFFE0 / a2 < a3 )
  {
    v5 = sub_10037669(ebx0);
  }
  else
  {
    v7 = a3 * a2;
    if ( !(a3 * a2) )
      v7 = 1;
    do
    {
      v8 = 0;
      if ( v7 <= 0xFFFFFFE0 )
      {
        v8 = HeapAlloc(hHeap, 8u, v7);
        if ( v8 )
          return v8;
      }
      if ( !dword_1007704C )
      {
        if ( a4 )
          *(_DWORD *)a4 = 12;
        return v8;
      }
    }
    while ( sub_1003ADB2(v7) );
    v5 = a4;
    if ( !a4 )
      return 0;
  }
  *(_DWORD *)v5 = 12;
  return 0;
}
// 1007704C: using guessed type int dword_1007704C;

//----- (10049401) --------------------------------------------------------
PVOID __cdecl sub_10049401()
{
  return DecodePointer(dword_100772B0);
}

//----- (1004940E) --------------------------------------------------------
int __cdecl sub_1004940E(int a1)
{
  int result; // eax@1

  result = a1;
  dword_100772A8 = (PVOID)a1;
  dword_100772AC = a1;
  dword_100772B0 = (PVOID)a1;
  dword_100772B4 = a1;
  return result;
}
// 100772AC: using guessed type int dword_100772AC;
// 100772B4: using guessed type int dword_100772B4;

//----- (1004942A) --------------------------------------------------------
void __cdecl sub_1004942A(int a1)
{
  int v1; // ebx@1
  int v2; // edi@1
  int v3; // eax@7
  PVOID v4; // eax@9
  PVOID v5; // eax@10
  int v6; // edx@10
  int v7; // ecx@10
  unsigned int v8; // eax@10
  int v9; // ST08_4@10
  int v10; // edx@30
  int v11; // ecx@30
  int *v12; // [sp+28h] [bp-1Ch]@9

  v1 = 0;
  v2 = 0;
  if ( a1 > 11 )
  {
    if ( a1 == 15 )
    {
      v12 = &dword_100772B4;
      v4 = (PVOID)dword_100772B4;
      goto LABEL_18;
    }
    if ( a1 == 21 )
    {
      v12 = &dword_100772AC;
      v4 = (PVOID)dword_100772AC;
      goto LABEL_18;
    }
    if ( a1 != 22 )
      goto LABEL_14;
    goto LABEL_15;
  }
  if ( a1 != 11 )
  {
    if ( a1 == 2 )
    {
      v12 = (int *)&dword_100772A8;
      v4 = dword_100772A8;
LABEL_18:
      v1 = 1;
      v5 = DecodePointer(v4);
      goto LABEL_19;
    }
    if ( a1 != 4 )
    {
      if ( a1 != 6 )
      {
        if ( a1 == 8 )
          goto LABEL_7;
LABEL_14:
        *(_DWORD *)sub_10037669(0) = 22;
        sub_1003A16E(0, 0);
        return;
      }
LABEL_15:
      v12 = (int *)&dword_100772B0;
      v4 = dword_100772B0;
      goto LABEL_18;
    }
  }
LABEL_7:
  v3 = sub_10041A74(0);
  v2 = v3;
  if ( !v3 )
    return;
  v8 = sub_100495DF(a1, *(_DWORD *)(v3 + 92));
  v7 = v9;
  v12 = (int *)(v8 + 8);
  v5 = *(PVOID *)(v8 + 8);
LABEL_19:
  if ( v5 == (PVOID)1 )
    return;
  if ( !v5 )
    sub_1003B04F(v6, v7, v1, v2, 3u);
  if ( v1 )
    sub_10036A43(v6, v7, v1, v2, 0);
  if ( a1 == 8 || a1 == 11 || a1 == 4 )
  {
    *(_DWORD *)(v2 + 96) = 0;
    if ( a1 != 8 )
      goto LABEL_33;
    *(_DWORD *)(v2 + 100) = 140;
  }
  if ( a1 == 8 )
  {
    v11 = dword_10065FF0;
    v10 = dword_10065FF0;
    while ( v10 < v11 + dword_10065FF4 )
    {
      *(_DWORD *)(12 * v10++ + *(_DWORD *)(v2 + 92) + 8) = 0;
      v11 = dword_10065FF0;
    }
    goto LABEL_34;
  }
LABEL_33:
  *v12 = (int)EncodePointer(0);
LABEL_34:
  if ( v1 )
    sub_10036BA7(0);
}
// 10065FF0: using guessed type int dword_10065FF0;
// 10065FF4: using guessed type int dword_10065FF4;
// 100772AC: using guessed type int dword_100772AC;
// 100772B4: using guessed type int dword_100772B4;

//----- (100495DF) --------------------------------------------------------
unsigned int __cdecl sub_100495DF(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  unsigned int result; // eax@6

  v2 = a2;
  do
  {
    if ( *(_DWORD *)(v2 + 4) == a1 )
      break;
    v2 += 12;
  }
  while ( v2 < a2 + 12 * dword_10065FE8 );
  if ( v2 >= a2 + 12 * dword_10065FE8 || *(_DWORD *)(v2 + 4) != a1 )
    result = 0;
  else
    result = v2;
  return result;
}
// 10065FE8: using guessed type int dword_10065FE8;

//----- (1004961B) --------------------------------------------------------
signed int __cdecl sub_1004961B(double a1)
{
  int v1; // eax@2
  int v2; // eax@3
  signed int result; // eax@5
  int v4; // ecx@10
  signed int v5; // [sp+4h] [bp-4h]@6

  if ( (WORD3(a1) & 0x7FF0) == 32752 )
  {
    v1 = sub_100497B4(SLODWORD(a1), SHIDWORD(a1)) - 1;
    if ( v1 )
    {
      v2 = v1 - 1;
      if ( v2 )
      {
        if ( v2 != 1 )
          return 1;
        v5 = 2;
      }
      else
      {
        v5 = 4;
      }
      result = v5;
    }
    else
    {
      result = 512;
    }
  }
  else
  {
    v4 = WORD3(a1) & 0x8000;
    if ( !(WORD3(a1) & 0x7FF0) && (HIDWORD(a1) & 0xFFFFF || LODWORD(a1)) )
    {
      result = v4 != 0 ? 16 : 128;
    }
    else
    {
      if ( 0.0 == a1 )
        result = v4 != 0 ? 32 : 64;
      else
        result = v4 != 0 ? 8 : 256;
    }
  }
  return result;
}

//----- (100496B7) --------------------------------------------------------
#error "FFFFFFFF: variables would overlap: edx/4 and edx/8 (funcsize=79)"

//----- (10049789) --------------------------------------------------------
double __cdecl sub_10049789(double a1, __int16 a2)
{
  double v3; // ST00_8@1

  v3 = a1;
  WORD3(v3) = WORD3(a1) & 0x800F | 16 * (a2 + 1022);
  return v3;
}

//----- (100497B4) --------------------------------------------------------
signed int __cdecl sub_100497B4(int a1, int a2)
{
  if ( a2 == 2146435072 )
  {
    if ( !a1 )
      return 1;
  }
  else
  {
    if ( a2 == -1048576 && !a1 )
      return 2;
  }
  if ( (HIWORD(a2) & 0x7FF8) == 32760 )
    return 3;
  if ( (HIWORD(a2) & 0x7FF8) == 32752 && (a2 & 0x7FFFF || a1) )
    return 4;
  return 0;
}

//----- (10049810) --------------------------------------------------------
int __cdecl sub_10049810(char a1)
{
  if ( a1 & 0x20 )
    return 5;
  if ( a1 & 8 )
    return 1;
  if ( a1 & 4 )
    return 2;
  if ( a1 & 1 )
    return 3;
  return 2 * (a1 & 2);
}

//----- (10049842) --------------------------------------------------------
int __usercall sub_10049842<eax>(int a1<ebp>, int a2<edi>, signed int a3, int a4, int a5, int a6, double a7, int a8)
{
  double v8; // ST1C_8@1
  int v9; // eax@3
  __int16 v10; // cx@6
  int v12; // ST24_4@7
  char v13; // ST28_1@7
  char v14; // [sp+2Ch] [bp-8Ch]@2
  int v15; // [sp+6Ch] [bp-4Ch]@2
  unsigned int v16; // [sp+A8h] [bp-10h]@1
  int v17; // [sp+ACh] [bp-Ch]@1
  void *v18; // [sp+B0h] [bp-8h]@1
  char v19; // [sp+B4h] [bp-4h]@5
  int v20; // [sp+B8h] [bp+0h]@1

  v17 = a1;
  v18 = (void *)v20;
  v16 = (unsigned int)&v17 ^ __security_cookie;
  HIDWORD(v8) = a8;
  LODWORD(v8) = &a7;
  if ( !sub_1004990A(a3, v8) )
  {
    v15 &= 0xFFFFFFFEu;
    sub_10049B57((ULONG_PTR)&v14, (int)&a8, a3, a4, (int)&a5, (int)&a7, 0);
  }
  v9 = sub_10049810(a3);
  if ( dword_10075480 || !v9 )
  {
    sub_10049E3C((int)&v19, v9);
    sub_10049F8C(v10);
  }
  else
  {
    sub_10049E69((int)&v19, v9, a4, a5, a6, COERCE_UNSIGNED_INT64(0.0), COERCE_UNSIGNED_INT64(0.0) >> 32, a7);
  }
  return sub_1002A49B((int)&v19, a2, v12, (unsigned int)&v17 ^ v16, v13);
}
// 10049842: could not find valid save-restore pair for ebp
// 10074200: using guessed type int __security_cookie;
// 10075480: using guessed type int dword_10075480;

//----- (1004990A) --------------------------------------------------------
bool __cdecl sub_1004990A(signed int a1, double a2)
{
  char v2; // bl@1
  int v3; // esi@1
  int v4; // eax@9
  int v5; // ecx@13
  double v6; // st7@13
  signed int v7; // edi@27
  double v8; // st7@30
  double v9; // st7@31
  signed int v10; // edx@32
  unsigned int v11; // eax@35
  int v12; // ecx@35
  double v14; // [sp+18h] [bp-Ch]@30

  v2 = a1;
  v3 = a1 & 0x1F;
  if ( a1 & 8 && BYTE4(a2) & 1 )
  {
    sub_10049FB5();
    v3 &= 0xFFFFFFF7u;
    goto LABEL_49;
  }
  if ( a1 & 4 && BYTE4(a2) & 4 )
  {
    sub_10049FB5();
    v3 &= 0xFFFFFFFBu;
    goto LABEL_49;
  }
  if ( a1 & 1 && BYTE4(a2) & 8 )
  {
    sub_10049FB5();
    v4 = WORD2(a2) & 0xC00;
    if ( WORD2(a2) & 0xC00 )
    {
      if ( v4 != 1024 )
      {
        if ( v4 != 2048 )
        {
          if ( v4 != 3072 )
          {
LABEL_24:
            v3 &= 0xFFFFFFFEu;
            goto LABEL_49;
          }
          v5 = LODWORD(a2);
          v6 = dbl_100750B0;
          if ( *LODWORD(a2) <= 0.0 )
            goto LABEL_22;
LABEL_23:
          *(_QWORD *)v5 = *(_QWORD *)&v6;
          goto LABEL_24;
        }
        v5 = LODWORD(a2);
        if ( *LODWORD(a2) <= 0.0 )
        {
          v6 = dbl_100750B0;
LABEL_22:
          v6 = -v6;
          goto LABEL_23;
        }
LABEL_20:
        v6 = dbl_100750A0;
        goto LABEL_23;
      }
      v5 = LODWORD(a2);
      if ( *LODWORD(a2) > 0.0 )
      {
        v6 = dbl_100750B0;
        goto LABEL_23;
      }
    }
    else
    {
      v5 = LODWORD(a2);
      if ( *LODWORD(a2) > 0.0 )
        goto LABEL_20;
    }
    v6 = dbl_100750A0;
    goto LABEL_22;
  }
  if ( a1 & 2 )
  {
    if ( BYTE4(a2) & 0x10 )
    {
      v7 = 0;
      if ( a1 & 0x10 )
        v7 = 1;
      if ( 0.0 == *LODWORD(a2) )
      {
        v7 = 1;
      }
      else
      {
        v8 = *LODWORD(a2);
        sub_100496B7(v8, (int)&a1);
        v14 = v8;
        a1 -= 1536;
        if ( a1 >= -1074 )
        {
          v10 = 0;
          if ( v8 < 0.0 )
            v10 = 1;
          WORD3(v14) = BYTE6(v14) & 0xF | 0x10;
          if ( a1 < -1021 )
          {
            v12 = -1021 - a1;
            v11 = LODWORD(v14);
            do
            {
              if ( LOBYTE(v14) & 1 )
              {
                if ( !v7 )
                  v7 = 1;
              }
              v11 >>= 1;
              LODWORD(v14) = v11;
              if ( BYTE4(v14) & 1 )
              {
                v11 |= 0x80000000u;
                LODWORD(v14) = v11;
              }
              HIDWORD(v14) >>= 1;
              --v12;
            }
            while ( v12 );
          }
          v9 = v14;
          if ( v10 )
            v9 = -v14;
        }
        else
        {
          v9 = v8 * 0.0;
          v7 = 1;
        }
        *LODWORD(a2) = *(_QWORD *)&v9;
      }
      if ( v7 )
        sub_10049FB5();
      v3 &= 0xFFFFFFFDu;
    }
  }
LABEL_49:
  if ( v2 & 0x10 )
  {
    if ( BYTE4(a2) & 0x20 )
    {
      sub_10049FB5();
      v3 &= 0xFFFFFFEFu;
    }
  }
  return v3 == 0;
}
// 100750A0: using guessed type double dbl_100750A0;
// 100750B0: using guessed type double dbl_100750B0;

//----- (10049AE6) --------------------------------------------------------
double __usercall sub_10049AE6<st0>(__int16 a1<cx>, int a2<ebx>, int a3, double a4)
{
  double result; // st7@2

  if ( dword_10075480 )
  {
    *(_DWORD *)sub_10037669(a2) = 33;
    sub_10049F8C(a1);
    result = a4;
  }
  else
  {
    result = sub_10049E69(
               a2,
               1,
               a3,
               SLODWORD(a4),
               SHIDWORD(a4),
               COERCE_UNSIGNED_INT64(0.0),
               COERCE_UNSIGNED_INT64(0.0) >> 32,
               a4);
  }
  return result;
}
// 10075480: using guessed type int dword_10075480;

//----- (10049B36) --------------------------------------------------------
int __cdecl sub_10049B36(ULONG_PTR Arguments, int a2, char a3, int a4, int a5, int a6)
{
  return sub_10049B57(Arguments, a2, a3, a4, a5, a6, 0);
}

//----- (10049B57) --------------------------------------------------------
int __cdecl sub_10049B57(ULONG_PTR Arguments, int a2, char a3, int a4, int a5, int a6, int a7)
{
  char v7; // cl@1
  DWORD v8; // edi@2
  char v9; // al@12
  int v10; // esi@12
  ULONG_PTR v11; // ecx@12
  int v12; // eax@22
  int v13; // eax@27
  ULONG_PTR v14; // ecx@27
  int v15; // eax@31
  int v16; // eax@35
  ULONG_PTR v17; // ecx@35
  int v18; // ecx@38
  int v19; // ecx@38
  int v20; // ebx@39
  ULONG_PTR v21; // ecx@41
  int v22; // eax@51
  int v23; // eax@52
  int v24; // eax@53
  int v25; // eax@56
  int v26; // eax@60
  int v27; // eax@61
  int result; // eax@62

  *(_DWORD *)(Arguments + 4) = 0;
  *(_DWORD *)(Arguments + 8) = 0;
  *(_DWORD *)(Arguments + 12) = 0;
  v7 = a3;
  if ( a3 & 0x10 )
  {
    v8 = -1073741681;
    *(_DWORD *)(Arguments + 4) |= 1u;
  }
  else
  {
    v8 = Arguments;
  }
  if ( v7 & 2 )
  {
    v8 = -1073741677;
    *(_DWORD *)(Arguments + 4) |= 2u;
  }
  if ( v7 & 1 )
  {
    v8 = -1073741679;
    *(_DWORD *)(Arguments + 4) |= 4u;
  }
  if ( v7 & 4 )
  {
    v8 = -1073741682;
    *(_DWORD *)(Arguments + 4) |= 8u;
  }
  if ( v7 & 8 )
  {
    v8 = -1073741680;
    *(_DWORD *)(Arguments + 4) |= 0x10u;
  }
  v10 = a2;
  *(_DWORD *)(Arguments + 8) ^= (*(_DWORD *)(Arguments + 8) ^ ~(16 * *(_DWORD *)a2)) & 0x10;
  *(_DWORD *)(Arguments + 8) ^= (*(_DWORD *)(Arguments + 8) ^ ~(2 * *(_DWORD *)v10)) & 8;
  *(_DWORD *)(Arguments + 8) ^= (*(_DWORD *)(Arguments + 8) ^ ~(*(_DWORD *)v10 >> 1)) & 4;
  *(_DWORD *)(Arguments + 8) ^= (*(_DWORD *)(Arguments + 8) ^ ~(*(_DWORD *)v10 >> 3)) & 2;
  v11 = Arguments;
  *(_DWORD *)(v11 + 8) ^= (*(_DWORD *)(Arguments + 8) ^ ~(*(_DWORD *)v10 >> 5)) & 1;
  v9 = sub_1004A00B((int (*)(void))v11);
  if ( v9 & 1 )
    *(_DWORD *)(Arguments + 12) |= 0x10u;
  if ( v9 & 4 )
    *(_DWORD *)(Arguments + 12) |= 8u;
  if ( v9 & 8 )
    *(_DWORD *)(Arguments + 12) |= 4u;
  if ( v9 & 0x10 )
    *(_DWORD *)(Arguments + 12) |= 2u;
  if ( v9 & 0x20 )
    *(_DWORD *)(Arguments + 12) |= 1u;
  v12 = *(_DWORD *)v10 & 0xC00;
  if ( !(*(_DWORD *)v10 & 0xC00) )
  {
    *(_DWORD *)Arguments &= 0xFFFFFFFCu;
    goto LABEL_31;
  }
  if ( v12 == 1024 )
  {
    v14 = Arguments;
    v13 = *(_DWORD *)Arguments & 0xFFFFFFFD | 1;
    goto LABEL_28;
  }
  if ( v12 == 2048 )
  {
    v14 = Arguments;
    v13 = *(_DWORD *)Arguments & 0xFFFFFFFE | 2;
LABEL_28:
    *(_DWORD *)v14 = v13;
    goto LABEL_31;
  }
  if ( v12 == 3072 )
    *(_DWORD *)Arguments |= 3u;
LABEL_31:
  v15 = *(_DWORD *)v10 & 0x300;
  if ( !(*(_DWORD *)v10 & 0x300) )
  {
    v17 = Arguments;
    v16 = *(_DWORD *)Arguments & 0xFFFFFFEB | 8;
    goto LABEL_37;
  }
  if ( v15 == 512 )
  {
    v17 = Arguments;
    v16 = *(_DWORD *)Arguments & 0xFFFFFFE7 | 4;
LABEL_37:
    *(_DWORD *)v17 = v16;
    goto LABEL_38;
  }
  if ( v15 == 768 )
    *(_DWORD *)Arguments &= 0xFFFFFFE3u;
LABEL_38:
  v19 = *(_DWORD *)Arguments ^ 32 * a4;
  v18 = v19 & 0x1FFE0;
  *(_DWORD *)Arguments ^= v18;
  *(_DWORD *)(Arguments + 32) |= 1u;
  if ( a7 )
  {
    *(_DWORD *)(Arguments + 32) &= 0xFFFFFFE1u;
    *(float *)(Arguments + 16) = *(float *)a5;
    *(_DWORD *)(Arguments + 96) |= 1u;
    v20 = a6;
    *(_DWORD *)(Arguments + 96) &= 0xFFFFFFE1u;
    *(float *)(Arguments + 80) = *(float *)v20;
  }
  else
  {
    *(_DWORD *)(Arguments + 32) = *(_DWORD *)(Arguments + 32) & 0xFFFFFFE3 | 2;
    *(double *)(Arguments + 16) = *(double *)a5;
    *(_DWORD *)(Arguments + 96) |= 1u;
    v18 = Arguments;
    v20 = a6;
    *(_DWORD *)(Arguments + 96) = *(_DWORD *)(Arguments + 96) & 0xFFFFFFE3 | 2;
    *(double *)(Arguments + 80) = *(double *)v20;
  }
  sub_10049F7D((int (*)(void))v18);
  RaiseException(v8, 0, 1u, &Arguments);
  v21 = Arguments;
  if ( *(_BYTE *)(Arguments + 8) & 0x10 )
    *(_DWORD *)v10 &= 0xFFFFFFFEu;
  if ( *(_BYTE *)(v21 + 8) & 8 )
    *(_DWORD *)v10 &= 0xFFFFFFFBu;
  if ( *(_BYTE *)(v21 + 8) & 4 )
    *(_DWORD *)v10 &= 0xFFFFFFF7u;
  if ( *(_BYTE *)(v21 + 8) & 2 )
    *(_DWORD *)v10 &= 0xFFFFFFEFu;
  if ( *(_BYTE *)(v21 + 8) & 1 )
    *(_DWORD *)v10 &= 0xFFFFFFDFu;
  v22 = *(_DWORD *)v21 & 3;
  if ( !v22 )
  {
    *(_DWORD *)v10 &= 0xFFFFF3FFu;
    goto LABEL_60;
  }
  v23 = v22 - 1;
  if ( !v23 )
  {
    v25 = *(_DWORD *)v10 & 0xFFFFF7FF | 0x400;
    goto LABEL_57;
  }
  v24 = v23 - 1;
  if ( !v24 )
  {
    v25 = *(_DWORD *)v10 & 0xFFFFFBFF | 0x800;
LABEL_57:
    *(_DWORD *)v10 = v25;
    goto LABEL_60;
  }
  if ( v24 == 1 )
    *(_DWORD *)v10 |= 0xC00u;
LABEL_60:
  v26 = (*(_DWORD *)v21 >> 2) & 7;
  if ( !v26 )
  {
    result = *(_DWORD *)v10 & 0xFFFFF3FF | 0x300;
    goto LABEL_66;
  }
  v27 = v26 - 1;
  if ( !v27 )
  {
    result = *(_DWORD *)v10 & 0xFFFFF3FF | 0x200;
LABEL_66:
    *(_DWORD *)v10 = result;
    goto LABEL_67;
  }
  result = v27 - 1;
  if ( !result )
    *(_DWORD *)v10 &= 0xFFFFF3FFu;
LABEL_67:
  if ( a7 )
    *(float *)v20 = *(float *)(v21 + 80);
  else
    *(double *)v20 = *(double *)(v21 + 80);
  return result;
}

//----- (10049E3C) --------------------------------------------------------
int __usercall sub_10049E3C<eax>(int a1<ebx>, int a2)
{
  int result; // eax@2

  if ( a2 == 1 )
  {
    result = sub_10037669(a1);
    *(_DWORD *)result = 33;
  }
  else
  {
    result = a2 - 2;
    if ( (unsigned int)(a2 - 2) <= 1 )
    {
      result = sub_10037669(a1);
      *(_DWORD *)result = 34;
    }
  }
  return result;
}

//----- (10049E69) --------------------------------------------------------
double __usercall sub_10049E69<st0>(int a1<ebx>, int a2, int a3, int a4, int a5, int a6, int a7, double a8)
{
  signed int v8; // eax@1
  int v9; // ecx@1
  double result; // st7@9
  int v11; // [sp+0h] [bp-20h]@7
  int v12; // [sp+4h] [bp-1Ch]@6
  int v13; // [sp+8h] [bp-18h]@7
  int v14; // [sp+Ch] [bp-14h]@7
  int v15; // [sp+10h] [bp-10h]@7
  int v16; // [sp+14h] [bp-Ch]@7
  double v17; // [sp+18h] [bp-8h]@7

  v9 = 0;
  v8 = 0;
  while ( dword_100750C8[2 * v8] != a3 )
  {
    ++v8;
    if ( v8 >= 29 )
      goto LABEL_6;
  }
  v9 = (int)*(&off_100750CC + 2 * v8);
LABEL_6:
  v12 = v9;
  if ( v9 )
  {
    v13 = a4;
    v14 = a5;
    v15 = a6;
    v16 = a7;
    v17 = a8;
    v11 = a2;
    sub_10049F8C(v9);
    if ( !sub_1002E99E() )
      sub_10049E3C(a1, a2);
    result = v17;
  }
  else
  {
    sub_10049F8C(0);
    sub_10049E3C(a1, a2);
    result = a8;
  }
  return result;
}
// 100750C8: using guessed type int dword_100750C8[];
// 100750CC: using guessed type void *off_100750CC;

//----- (10049F07) --------------------------------------------------------
int __cdecl sub_10049F07(int a1)
{
  int result; // eax@2
  int v2; // [sp+30h] [bp+8h]@5

  if ( dword_1007689C >= 1 )
  {
    result = a1;
    if ( a1 & 0x40 && dword_100751C8 )
    {
      __asm { ldmxcsr [ebp+arg_0] }
    }
    else
    {
      result = a1 & 0xFFFFFFBF;
      v2 = a1 & 0xFFFFFFBF;
      __asm { ldmxcsr [ebp+arg_0] }
    }
  }
  return result;
}
// 100751C8: using guessed type int dword_100751C8;
// 1007689C: using guessed type int dword_1007689C;

//----- (10049F7D) --------------------------------------------------------
int __thiscall sub_10049F7D(int (*this)(void))
{
  __asm { fnclex }
  return this();
}

//----- (10049F8C) --------------------------------------------------------
int __fastcall sub_10049F8C(__int16 a1)
{
  return a1;
}

//----- (10049FB5) --------------------------------------------------------
void __cdecl sub_10049FB5()
{
  ;
}

//----- (1004A00B) --------------------------------------------------------
int __thiscall sub_1004A00B(int (*this)(void))
{
  return this();
}

//----- (1004A019) --------------------------------------------------------
signed int __usercall sub_1004A019<eax>(int a1<edi>, int a2, int a3, unsigned int a4, int a5, int a6, int a7)
{
  return sub_1004A03A(a1, a2, a3, a4, a5, a6, a7, 0);
}

//----- (1004A03A) --------------------------------------------------------
signed int __usercall sub_1004A03A<eax>(int a1<edi>, int a2, int a3, unsigned int a4, int a5, int a6, int a7, int a8)
{
  signed int result; // eax@4

  switch ( a5 )
  {
    case 101:
    case 69:
      result = sub_1004A587(a2, a3, a4, a6, a7, a8);
      break;
    case 102:
      result = sub_1004A73D(a2, a3, a4, a6, a8);
      break;
    case 97:
    case 65:
      result = sub_1004A0C0(a1, a2, a3, a4, a6, a7, a8);
      break;
    default:
      result = sub_1004A7FC(a2, a3, a4, a6, a7, a8);
      break;
  }
  return result;
}

//----- (1004A0C0) --------------------------------------------------------
signed int __usercall sub_1004A0C0<eax>(int a1<edi>, int a2, int a3, unsigned int a4, int a5, int a6, int a7)
{
  int v7; // edi@1
  int v8; // esi@3
  int v9; // eax@5
  signed int v10; // edi@8
  int v11; // edx@9
  unsigned int v12; // ebx@9
  unsigned int v13; // eax@10
  void *v14; // ecx@12
  int v15; // eax@16
  char v16; // zf@21
  int v17; // esi@22
  int v18; // eax@22
  int v19; // ecx@26
  int v20; // esi@26
  int v21; // eax@29
  int v22; // eax@31
  signed int v23; // ecx@31
  unsigned int v24; // eax@33
  unsigned __int64 v25; // qax@33
  unsigned __int64 v26; // qt0@35
  unsigned __int64 v27; // qax@37
  int i; // eax@38
  signed int v29; // eax@51
  unsigned __int64 v30; // qcx@51
  unsigned int v31; // ecx@51
  unsigned __int8 v32; // cf@51
  int v33; // esi@52
  int v34; // edi@54
  int v35; // edx@57
  __int64 v36; // ST0C_8@61
  int v37; // edx@61
  __int64 v38; // ST0C_8@66
  int v40; // [sp-4h] [bp-3Ch]@5
  int v41; // [sp+Ch] [bp-2Ch]@1
  int v42; // [sp+14h] [bp-24h]@69
  char v43; // [sp+18h] [bp-20h]@68
  int v44; // [sp+20h] [bp-18h]@29
  int v45; // [sp+24h] [bp-14h]@9
  int v46; // [sp+28h] [bp-10h]@21
  int v47; // [sp+2Ch] [bp-Ch]@26
  unsigned int v48; // [sp+30h] [bp-8h]@1
  int v49; // [sp+34h] [bp-4h]@1
  unsigned int v50; // [sp+44h] [bp+Ch]@31
  int v51; // [sp+4Ch] [bp+14h]@31

  v49 = 48;
  v48 = 1023;
  sub_1003018D((int)&v41, 0, a1, a7);
  v7 = a5;
  if ( a5 < 0 )
    v7 = 0;
  v8 = a3;
  if ( !a3 || !a4 )
  {
    v9 = sub_10037669(0);
    v40 = 22;
LABEL_8:
    v10 = v40;
    *(_DWORD *)v9 = v40;
    sub_1003A16E(0, v40);
    goto LABEL_68;
  }
  *(_BYTE *)a3 = 0;
  if ( a4 <= v7 + 11 )
  {
    v9 = sub_10037669(0);
    v40 = 34;
    goto LABEL_8;
  }
  v11 = a2;
  v12 = *(_DWORD *)(a2 + 4);
  v45 = *(_DWORD *)a2;
  if ( ((v12 >> 20) & 0x7FF) == 2047 )
  {
    v13 = -1;
    if ( a4 != -1 )
      v13 = a4 - 2;
    v10 = sub_1004A41A(a2, a3 + 2, v13, v7, 0);
    if ( v10 )
    {
      *(_BYTE *)a3 = 0;
    }
    else
    {
      if ( *(_BYTE *)(a3 + 2) == 45 )
      {
        *(_BYTE *)a3 = 45;
        v8 = a3 + 1;
      }
      *(_BYTE *)v8 = 48;
      *(_BYTE *)(v8 + 1) = (((a6 == 0) - 1) & 0xE0) + 120;
      v15 = sub_10052F50(v14, v8 + 2, 0x65u);
      if ( v15 )
      {
        *(_BYTE *)v15 = (((a6 == 0) - 1) & 0xE0) + 112;
        *(_BYTE *)(v15 + 3) = 0;
      }
      v10 = 0;
    }
  }
  else
  {
    if ( v12 & 0x80000000 )
    {
      *(_BYTE *)a3 = 45;
      v8 = a3 + 1;
    }
    *(_BYTE *)v8 = 48;
    *(_BYTE *)(v8 + 1) = (((a6 == 0) - 1) & 0xE0) + 120;
    v16 = (*(_DWORD *)(a2 + 4) & 0x7FF00000) == 0;
    v46 = a6 != 0 ? 7 : 39;
    if ( v16 )
    {
      *(_BYTE *)(v8 + 2) = 48;
      v18 = *(_DWORD *)(a2 + 4);
      v17 = v8 + 3;
      if ( v18 & 0xFFFFF | *(_DWORD *)a2 )
        v48 = 1022;
      else
        v48 = 0;
    }
    else
    {
      *(_BYTE *)(v8 + 2) = 49;
      v17 = v8 + 3;
    }
    v19 = v17;
    v20 = v17 + 1;
    v47 = v19;
    if ( v7 )
      *(_BYTE *)v19 = ***(_BYTE ***)(v41 + 132);
    else
      *(_BYTE *)v19 = 0;
    v21 = *(_DWORD *)(a2 + 4);
    v44 = v21 & 0xFFFFF;
    if ( v21 & 0xFFFFF || *(_DWORD *)a2 )
    {
      v51 = 0;
      LOWORD(v22) = v49;
      v23 = 983040;
      v50 = 983040;
      do
      {
        if ( v7 <= 0 )
          break;
        LODWORD(v25) = v51 & *(_DWORD *)v11;
        HIDWORD(v25) = v23 & *(_DWORD *)(v11 + 4);
        HIDWORD(v25) &= 0xFFFFFu;
        v24 = (unsigned __int16)(sub_10053490(v25, v49) + 48);
        if ( v24 > 0x39 )
          v24 += a6 != 0 ? 7 : 39;
        v11 = a2;
        *(_BYTE *)v20 = v24;
        LODWORD(v26) = v51;
        HIDWORD(v26) = v50;
        v51 = v26 >> 4;
        v23 = v50 >> 4;
        v22 = v49 - 4;
        ++v20;
        --v7;
        v50 >>= 4;
        v49 = v22;
      }
      while ( (_WORD)v22 >= 0 );
      if ( (_WORD)v22 >= 0 )
      {
        LODWORD(v27) = v51 & *(_DWORD *)v11;
        HIDWORD(v27) = v23 & *(_DWORD *)(v11 + 4);
        HIDWORD(v27) &= 0xFFFFFu;
        if ( (unsigned __int16)sub_10053490(v27, v49) > 8u )
        {
          for ( i = v20 - 1; *(_BYTE *)i == 102 || *(_BYTE *)i == 70; --i )
            *(_BYTE *)i = 48;
          if ( i == v47 )
          {
            ++*(_BYTE *)(i - 1);
          }
          else
          {
            if ( *(_BYTE *)i == 57 )
              *(_BYTE *)i = v46 + 58;
            else
              ++*(_BYTE *)i;
          }
        }
      }
    }
    if ( v7 > 0 )
    {
      sub_10039210((void *)v20, 0x30u, v7);
      v20 += v7;
    }
    if ( !*(_BYTE *)v47 )
      v20 = v47;
    *(_BYTE *)v20 = (((a6 == 0) - 1) & 0xE0) + 112;
    LOWORD(v31) = sub_10053490(*(_QWORD *)a2, 0x34u);
    v29 = 0;
    v31 &= 0x7FFu;
    v32 = v31 < v48;
    LODWORD(v30) = v31 - v48;
    HIDWORD(v30) = -v32;
    if ( (signed int)v32 > 0 )
    {
      *(_BYTE *)(v20 + 1) = 45;
      v33 = v20 + 2;
      v30 = -v30;
    }
    else
    {
      *(_BYTE *)(v20 + 1) = 43;
      v33 = v20 + 2;
    }
    v34 = v33;
    *(_BYTE *)v33 = 48;
    if ( HIDWORD(v30) >= 0 )
    {
      if ( (HIDWORD(v30) > 0 || (_DWORD)v30 >= 0x3E8u)
        && (*(_BYTE *)v33 = sub_100533B0(v30, 1000i64) + 48, ++v33, v29 = 0, v44 = v35, v33 != v34)
        || HIDWORD(v30) >= v29 && (HIDWORD(v30) > v29 || (_DWORD)v30 >= 0x64u) )
      {
        HIDWORD(v36) = v29;
        LODWORD(v36) = 100;
        *(_BYTE *)v33++ = sub_100533B0(v30, v36) + 48;
        v44 = v37;
        v29 = 0;
      }
    }
    if ( v33 != v34 || HIDWORD(v30) >= v29 && (HIDWORD(v30) > v29 || (_DWORD)v30 >= 0xAu) )
    {
      HIDWORD(v38) = v29;
      LODWORD(v38) = 10;
      *(_BYTE *)v33++ = sub_100533B0(v30, v38) + 48;
      v44 = HIDWORD(v30);
      v29 = 0;
    }
    *(_BYTE *)v33 = v30 + 48;
    *(_BYTE *)(v33 + 1) = v29;
    v10 = v29;
  }
LABEL_68:
  if ( v43 )
    *(_DWORD *)(v42 + 112) &= 0xFFFFFFFDu;
  return v10;
}

//----- (1004A41A) --------------------------------------------------------
signed int __cdecl sub_1004A41A(int a1, int a2, unsigned int a3, int a4, int a5)
{
  return sub_1004A587(a1, a2, a3, a4, a5, 0);
}

//----- (1004A438) --------------------------------------------------------
int __usercall sub_1004A438<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned int a4, int a5, int a6, int a7, char a8, int a9)
{
  int v9; // eax@3
  int v10; // eax@4
  int v11; // edx@4
  int v12; // edi@4
  int v13; // esi@11
  int v14; // eax@15
  int v15; // esi@15
  int v16; // edx@21
  signed __int64 v17; // qax@24
  signed __int64 v18; // qtt@24
  signed __int64 v19; // qax@26
  signed __int64 v20; // qtt@26
  int v22; // [sp-4h] [bp-1Ch]@3
  int v23; // [sp+8h] [bp-10h]@1
  int v24; // [sp+10h] [bp-8h]@32
  char v25; // [sp+14h] [bp-4h]@31

  sub_1003018D((int)&v23, a1, a2, a9);
  if ( !a3 || !a4 )
  {
    v9 = sub_10037669(a3);
    v22 = 22;
LABEL_8:
    v12 = v22;
    *(_DWORD *)v9 = v22;
    sub_1003A16E(a3, v22);
    goto LABEL_31;
  }
  v11 = a5;
  v12 = 0;
  v10 = a5;
  if ( a5 <= 0 )
    v10 = 0;
  if ( a4 <= v10 + 9 )
  {
    v9 = sub_10037669(a3);
    v22 = 34;
    goto LABEL_8;
  }
  if ( a8 )
  {
    sub_1004AA7D(a3 + (*(_DWORD *)a7 == 45), a5 > 0);
    v11 = a5;
  }
  v13 = a3;
  if ( *(_DWORD *)a7 == 45 )
  {
    *(_BYTE *)a3 = 45;
    v13 = a3 + 1;
  }
  if ( v11 > 0 )
  {
    *(_BYTE *)v13 = *(_BYTE *)(v13 + 1);
    ++v13;
    *(_BYTE *)v13 = ***(_BYTE ***)(v23 + 132);
  }
  v15 = v11 + (a8 == 0) + v13;
  v14 = -1;
  if ( a4 != -1 )
    v14 = a4 + a3 - v15;
  if ( sub_1003ADE5(a3, 0, v15, v14, (int)"e+000") )
  {
    sub_1003A17E(a3, 0);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1004A587);
  }
  if ( a6 )
    *(_BYTE *)v15 = 69;
  if ( **(_BYTE **)(a7 + 12) != 48 )
  {
    v16 = *(_DWORD *)(a7 + 4) - 1;
    if ( v16 < 0 )
    {
      v16 = -v16;
      *(_BYTE *)(v15 + 1) = 45;
    }
    if ( v16 >= 100 )
    {
      v17 = v16;
      v18 = v17;
      LODWORD(v17) = v17 / 100;
      v16 = v18 % 100;
      *(_BYTE *)(v15 + 2) += v17;
    }
    if ( v16 >= 10 )
    {
      v19 = v16;
      v20 = v19;
      LODWORD(v19) = v19 / 10;
      v16 = v20 % 10;
      *(_BYTE *)(v15 + 3) += v19;
    }
    *(_BYTE *)(v15 + 4) += v16;
  }
  if ( byte_10077350 & 1 )
  {
    if ( *(_BYTE *)(v15 + 2) == 48 )
      sub_1002A4B0((void *)(v15 + 2), (const void *)(v15 + 3), 3u);
  }
LABEL_31:
  if ( v25 )
    *(_DWORD *)(v24 + 112) &= 0xFFFFFFFDu;
  return v12;
}
// 10077350: using guessed type char byte_10077350;

//----- (1004A587) --------------------------------------------------------
signed int __cdecl sub_1004A587(int a1, int a2, unsigned int a3, int a4, int a5, int a6)
{
  signed int v6; // esi@1
  int v7; // eax@2
  signed int result; // eax@3
  unsigned int v9; // ecx@6
  int v10; // [sp+Ch] [bp-2Ch]@1
  char v11; // [sp+1Ch] [bp-1Ch]@1
  unsigned int v12; // [sp+34h] [bp-4h]@1
  int v13; // [sp+38h] [bp+0h]@1

  v12 = (unsigned int)&v13 ^ __security_cookie;
  v6 = 22;
  loc_10053315(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), &v10, &v11, 22);
  if ( !a2 )
  {
    v7 = sub_10037669(a4);
LABEL_3:
    *(_DWORD *)v7 = v6;
    sub_1003A16E(a4, a2);
    return v6;
  }
  if ( !a3 )
  {
    v7 = sub_10037669(a4);
    v6 = 22;
    goto LABEL_3;
  }
  v9 = -1;
  if ( a3 != -1 )
    v9 = a3 - (v10 == 45) - (a4 > 0);
  result = sub_10053087(a4, a2 + (v10 == 45) + (a4 > 0), v9, a4 + 1, (int)&v10);
  if ( result )
    *(_BYTE *)a2 = 0;
  else
    result = sub_1004A438(a4, a2, a2, a3, a4, a5, (int)&v10, 0, a6);
  return result;
}
// 10074200: using guessed type int __security_cookie;

//----- (1004A653) --------------------------------------------------------
signed int __usercall sub_1004A653<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6, char a7, int a8)
{
  int v8; // esi@1
  int v9; // eax@3
  signed int v10; // ebx@3
  int v11; // edi@4
  int v12; // eax@9
  int v13; // esi@10
  int v14; // eax@13
  int v15; // esi@13
  int v16; // eax@16
  int v18; // [sp+8h] [bp-14h]@1
  int v19; // [sp+10h] [bp-Ch]@20
  char v20; // [sp+14h] [bp-8h]@19
  int v21; // [sp+18h] [bp-4h]@1

  v21 = *(_DWORD *)(a6 + 4) - 1;
  sub_1003018D((int)&v18, a1, a2, a8);
  v8 = a3;
  if ( a3 && a4 )
  {
    v10 = 0;
    v11 = a5;
    if ( a7 )
    {
      if ( v21 == a5 )
        *(_WORD *)(v21 + (*(_DWORD *)a6 == 45) + a3) = 48;
    }
    if ( *(_DWORD *)a6 == 45 )
    {
      *(_BYTE *)a3 = 45;
      v8 = a3 + 1;
    }
    v12 = *(_DWORD *)(a6 + 4);
    if ( v12 > 0 )
    {
      v13 = v12 + v8;
    }
    else
    {
      sub_1004AA7D(v8, 1);
      *(_BYTE *)v8 = 48;
      v13 = v8 + 1;
    }
    if ( a5 > 0 )
    {
      sub_1004AA7D(v13, 1);
      *(_BYTE *)v13 = ***(_BYTE ***)(v18 + 132);
      v15 = v13 + 1;
      v14 = *(_DWORD *)(a6 + 4);
      if ( v14 < 0 )
      {
        if ( a7 )
        {
          v11 = -v14;
        }
        else
        {
          v16 = -v14;
          if ( a5 >= v16 )
            v11 = v16;
        }
        sub_1004AA7D(v15, v11);
        sub_10039210((void *)v15, 0x30u, v11);
      }
    }
  }
  else
  {
    v9 = sub_10037669(a1);
    v10 = 22;
    *(_DWORD *)v9 = 22;
    sub_1003A16E(22, a2);
  }
  if ( v20 )
    *(_DWORD *)(v19 + 112) &= 0xFFFFFFFDu;
  return v10;
}

//----- (1004A73D) --------------------------------------------------------
signed int __cdecl sub_1004A73D(int a1, int a2, int a3, int a4, int a5)
{
  signed int result; // eax@2
  unsigned int v6; // ecx@5
  int v7; // [sp+8h] [bp-2Ch]@1
  int v8; // [sp+Ch] [bp-28h]@7
  char v9; // [sp+18h] [bp-1Ch]@1
  unsigned int v10; // [sp+30h] [bp-4h]@1
  int v11; // [sp+34h] [bp+0h]@1

  v10 = (unsigned int)&v11 ^ __security_cookie;
  loc_10053315(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), &v7, &v9, 22);
  if ( a2 )
  {
    if ( a3 )
    {
      v6 = -1;
      if ( a3 != -1 )
        v6 = a3 - (v7 == 45);
      result = sub_10053087(a4, a2 + (v7 == 45), v6, a4 + v8, (int)&v7);
      if ( result )
        *(_BYTE *)a2 = 0;
      else
        result = sub_1004A653(a4, a2, a2, a3, a4, (int)&v7, 0, a5);
    }
    else
    {
      *(_DWORD *)sub_10037669(22) = 22;
      sub_1003A16E(22, a2);
      result = 22;
    }
  }
  else
  {
    *(_DWORD *)sub_10037669(22) = 22;
    sub_1003A16E(22, 0);
    result = 22;
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;

//----- (1004A7FC) --------------------------------------------------------
signed int __cdecl sub_1004A7FC(int a1, int a2, unsigned int a3, int a4, int a5, int a6)
{
  signed int result; // eax@2
  unsigned int v7; // eax@5
  bool v8; // ecx@5
  int v9; // ebx@5
  char v10; // al@12
  int v11; // [sp+8h] [bp-30h]@1
  int v12; // [sp+Ch] [bp-2Ch]@5
  int v13; // [sp+18h] [bp-20h]@5
  char v14; // [sp+1Ch] [bp-1Ch]@1
  unsigned int v15; // [sp+34h] [bp-4h]@1
  int v16; // [sp+38h] [bp+0h]@1

  v15 = (unsigned int)&v16 ^ __security_cookie;
  loc_10053315(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), &v11, &v14, 22);
  if ( a2 )
  {
    if ( a3 )
    {
      v13 = v12 - 1;
      v8 = v11 == 45;
      v7 = -1;
      v9 = v8 + a2;
      if ( a3 != -1 )
        v7 = a3 - v8;
      result = sub_10053087(v9, v9, v7, a4, (int)&v11);
      if ( result )
      {
        *(_BYTE *)a2 = 0;
      }
      else
      {
        if ( v12 - 1 < -4 || v12 - 1 >= a4 )
        {
          result = sub_1004A438(v9, a2, a2, a3, a4, a5, (int)&v11, 1, a6);
        }
        else
        {
          if ( v13 < v12 - 1 )
          {
            do
              v10 = *(_BYTE *)v9++;
            while ( v10 );
            *(_BYTE *)(v9 - 2) = 0;
          }
          result = sub_1004A653(v9, a2, a2, a3, a4, (int)&v11, 1, a6);
        }
      }
    }
    else
    {
      *(_DWORD *)sub_10037669(22) = 22;
      sub_1003A16E(22, a2);
      result = 22;
    }
  }
  else
  {
    *(_DWORD *)sub_10037669(22) = 22;
    sub_1003A16E(22, 0);
    result = 22;
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;

//----- (1004A8F9) --------------------------------------------------------
char __usercall sub_1004A8F9<al>(int a1<ebx>, int a2<edi>, int a3)
{
  return sub_1004A90A(a1, a2, a3, 0);
}

//----- (1004A90A) --------------------------------------------------------
char __usercall sub_1004A90A<al>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  int v4; // edx@1
  char i; // cl@1
  int v6; // eax@4
  int v7; // edx@4
  char v8; // al@9
  int v9; // esi@10
  int v11; // [sp+4h] [bp-10h]@1
  int v12; // [sp+Ch] [bp-8h]@16
  char v13; // [sp+10h] [bp-4h]@15

  sub_1003018D((int)&v11, a1, a2, a4);
  v4 = a3;
  for ( i = *(_BYTE *)a3; *(_BYTE *)v4; i = *(_BYTE *)v4 )
  {
    if ( i == ***(_BYTE ***)(v11 + 132) )
      break;
    ++v4;
  }
  LOBYTE(v6) = *(_BYTE *)v4;
  v7 = v4 + 1;
  if ( (_BYTE)v6 )
  {
    while ( 1 )
    {
      v8 = *(_BYTE *)v7;
      if ( !*(_BYTE *)v7 )
        break;
      if ( v8 == 101 || v8 == 69 )
        break;
      ++v7;
    }
    v9 = v7;
    do
      --v7;
    while ( *(_BYTE *)v7 == 48 );
    if ( *(_BYTE *)v7 == ***(_BYTE ***)(v11 + 132) )
      --v7;
    do
    {
      LOBYTE(v6) = *(_BYTE *)v9;
      ++v7;
      ++v9;
      *(_BYTE *)v7 = v6;
    }
    while ( (_BYTE)v6 );
  }
  if ( v13 )
  {
    v6 = v12;
    *(_DWORD *)(v6 + 112) &= 0xFFFFFFFDu;
  }
  return v6;
}

//----- (1004A988) --------------------------------------------------------
int __usercall sub_1004A988<eax>(int a1<ebx>, int a2, int a3, int a4)
{
  return sub_1004A9A0(a1, a2, a3, a4, 0);
}

//----- (1004A9A0) --------------------------------------------------------
int __usercall sub_1004A9A0<eax>(int a1<ebx>, int a2, int a3, int a4, int a5)
{
  int result; // eax@2
  int v6; // ecx@2
  int v7; // [sp+0h] [bp-8h]@2
  int v8; // [sp+4h] [bp-4h]@2

  if ( a2 )
  {
    sub_10053137(a1, (int)&v7, a4, a5);
    v6 = a3;
    *(_DWORD *)a3 = v7;
    result = v8;
    *(_DWORD *)(v6 + 4) = v8;
  }
  else
  {
    sub_100531C3(a1, (int)&a2, a4, a5);
    result = a2;
    *(_DWORD *)a3 = a2;
  }
  return result;
}

//----- (1004A9E0) --------------------------------------------------------
char __usercall sub_1004A9E0<al>(int a1<ebx>, int a2<edi>, int *a3)
{
  return sub_1004A9F1(a1, a2, a3, 0);
}

//----- (1004A9F1) --------------------------------------------------------
char __usercall sub_1004A9F1<al>(int a1<ebx>, int a2<edi>, int *a3, int a4)
{
  char i; // zf@1
  signed int *v5; // esi@1
  char v6; // cl@6
  int v7; // esi@6
  int v8; // eax@7
  int v10; // [sp+4h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-8h]@9
  char v12; // [sp+10h] [bp-4h]@8

  sub_1003018D((int)&v10, a1, a2, a4);
  v5 = a3;
  for ( i = sub_10039A13(a1, a2, *(_BYTE *)a3) == 101; !i; i = sub_10036D7B(a1, a2, *(_BYTE *)v5) == 0 )
    v5 = (signed int *)((char *)v5 + 1);
  if ( sub_10039A13(a1, a2, *(_BYTE *)v5) == 120 )
    v5 = (signed int *)((char *)v5 + 2);
  v6 = *(_BYTE *)v5;
  *(_BYTE *)v5 = ***(_BYTE ***)(v10 + 132);
  v7 = (int)((char *)v5 + 1);
  do
  {
    LOBYTE(v8) = *(_BYTE *)v7;
    *(_BYTE *)v7 = v6;
    v6 = v8;
    LOBYTE(v8) = *(_BYTE *)v7++;
  }
  while ( (_BYTE)v8 );
  if ( v12 )
  {
    v8 = v11;
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFDu;
  }
  return v8;
}

//----- (1004AA63) --------------------------------------------------------
bool __cdecl sub_1004AA63(int a1)
{
  return *(double *)a1 >= 0.0;
}

//----- (1004AA7D) --------------------------------------------------------
void __cdecl sub_1004AA7D(int a1, int a2)
{
  int v2; // eax@2

  if ( a2 )
  {
    v2 = sub_10035550(a1);
    sub_1002A4B0((void *)(a1 + a2), (const void *)a1, v2 + 1);
  }
}

//----- (1004AAA5) --------------------------------------------------------
signed int __usercall sub_1004AAA5<eax>(int a1<ebx>, int a2<edi>)
{
  signed int result; // eax@1

  result = sub_100534AF(a1, a2, 0, 65536, 196608);
  if ( result )
  {
    sub_1003A17E(a1, a2);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1004AACC);
  }
  return result;
}

//----- (1004AACC) --------------------------------------------------------
int (*__cdecl sub_1004AACC())()
{
  unsigned int v0; // esi@1
  int (*result)(); // eax@2

  v0 = 0;
  do
  {
    result = (int (*)())EncodePointer(*(int (**)())((char *)off_100751CC + v0));
    *(int (**)())((char *)off_100751CC + v0) = result;
    v0 += 4;
  }
  while ( v0 < 0x28 );
  return result;
}
// 100751CC: using guessed type int (*off_100751CC[10])();

//----- (1004AAEB) --------------------------------------------------------
int __usercall sub_1004AAEB<eax>(int a1<ebx>, int a2<edi>, int a3, const WCHAR *a4)
{
  int result; // eax@3
  const WCHAR *v5; // ecx@4
  int v6; // edx@5
  unsigned __int16 v7; // ax@6
  unsigned __int16 v8; // si@8
  const WCHAR v9; // ax@10

  if ( dword_10077048 )
  {
    result = sub_1004AB7E(a1, a2, a3, a4, 0);
  }
  else
  {
    if ( a3 && (v5 = a4, a4) )
    {
      v6 = a3 - (_DWORD)a4;
      do
      {
        v7 = *(const WCHAR *)((char *)v5 + v6);
        if ( v7 < 0x41u || v7 > 0x5Au )
          v8 = *(const WCHAR *)((char *)v5 + v6);
        else
          v8 = v7 + 32;
        v9 = *v5;
        if ( *v5 >= 0x41u )
        {
          if ( v9 <= 0x5Au )
            v9 += 32;
        }
        ++v5;
      }
      while ( v8 && v8 == v9 );
      result = v8 - v9;
    }
    else
    {
      *(_DWORD *)sub_10037669(a1) = 22;
      sub_1003A16E(a1, a2);
      result = 2147483647;
    }
  }
  return result;
}
// 10077048: using guessed type int dword_10077048;

//----- (1004AB7E) --------------------------------------------------------
int __usercall sub_1004AB7E<eax>(int a1<ebx>, int a2<edi>, int a3, const WCHAR *a4, int a5)
{
  int v5; // ebx@1
  const WCHAR *v6; // esi@2
  int v7; // edx@3
  int v8; // ebx@5
  unsigned __int16 v9; // ax@6
  WCHAR v10; // ax@10
  int v12; // [sp+8h] [bp-10h]@1
  int v13; // [sp+10h] [bp-8h]@20
  char v14; // [sp+14h] [bp-4h]@19

  sub_1003018D((int)&v12, a1, a2, a5);
  v5 = a3;
  if ( a3 && (v6 = a4, a4) )
  {
    if ( *(_DWORD *)(v12 + 168) )
    {
      do
      {
        a2 = sub_10053515(v5, a2, *(_WORD *)v5, (int)&v12);
        v5 += 2;
        v10 = sub_10053515(v5, a2, *v6, (int)&v12);
        ++v6;
      }
      while ( (_WORD)a2 && (_WORD)a2 == v10 );
    }
    else
    {
      v8 = a3 - (_DWORD)a4;
      do
      {
        v9 = *(const WCHAR *)((char *)v6 + v8);
        if ( v9 < 0x41u || v9 > 0x5Au )
          LOWORD(a2) = *(const WCHAR *)((char *)v6 + v8);
        else
          LOWORD(a2) = v9 + 32;
        v10 = *v6;
        if ( *v6 >= 0x41u )
        {
          if ( v10 <= 0x5Au )
            v10 += 32;
        }
        ++v6;
      }
      while ( (_WORD)a2 && (_WORD)a2 == v10 );
    }
    v7 = (unsigned __int16)a2 - v10;
  }
  else
  {
    *(_DWORD *)sub_10037669(a3) = 22;
    sub_1003A16E(a3, a2);
    v7 = 2147483647;
  }
  if ( v14 )
    *(_DWORD *)(v13 + 112) &= 0xFFFFFFFDu;
  return v7;
}

//----- (1004AC57) --------------------------------------------------------
unsigned int __cdecl sub_1004AC57(int a1, unsigned int a2)
{
  unsigned int result; // eax@1
  int v3; // ecx@2

  result = 0;
  if ( a2 )
  {
    v3 = a1;
    do
    {
      if ( !*(_WORD *)v3 )
        break;
      ++result;
      v3 += 2;
    }
    while ( result < a2 );
  }
  return result;
}

//----- (1004AC80) --------------------------------------------------------
int __usercall sub_1004AC80<eax>(int a1<edx>, __int16 a2<cx>, int a3<ebp>, __int16 a4<fpstat>, double _ST7<st0>, char a6, char a7, char a8)
{
  signed __int16 v8; // bx@2

  if ( *(_BYTE *)(a1 + 14) == 5 )
  {
    HIBYTE(v8) = ((unsigned __int8)(*(_WORD *)(a3 - 164) >> 8) | 2) & 0xFE;
    LOBYTE(v8) = 63;
  }
  else
  {
    v8 = 4927;
  }
  *(_WORD *)(a3 - 162) = v8;
  _EBX = &unk_100660EC;
  __asm { fxam }
  *(_DWORD *)(a3 - 148) = a1;
  *(_WORD *)(a3 - 160) = a4;
  *(_BYTE *)(a3 - 144) = 0;
  LOBYTE(a2) = __ROL__((char)(2 * *(_BYTE *)(a3 - 159)) >> 1, 1);
  _AL = a2 & 0xF;
  __asm { xlat }
  return (*(int (__thiscall **)(int))(_AL + a1 + 16))(a2 & 0x404);
}

//----- (1004ACE7) --------------------------------------------------------
int __usercall sub_1004ACE7<eax>(int a1<edx>, int a2<ebp>, __int16 a3<fpstat>, double _ST6<st1>, double a5<st0>, char a6, char a7, char a8)
{
  signed __int16 v8; // bx@2
  __int16 v11; // fps@4
  char v13; // cl@4
  __int16 v14; // cx@4
  char v17; // ah@4

  if ( *(_BYTE *)(a1 + 14) == 5 )
  {
    HIBYTE(v8) = ((unsigned __int8)(*(_WORD *)(a2 - 164) >> 8) | 2) & 0xFE;
    LOBYTE(v8) = 63;
  }
  else
  {
    v8 = 4927;
  }
  *(_WORD *)(a2 - 162) = v8;
  _EBX = &unk_100660EC;
  __asm { fxam }
  *(_DWORD *)(a2 - 148) = a1;
  *(_WORD *)(a2 - 160) = a3;
  *(_BYTE *)(a2 - 144) = 0;
  UNDEF(v11);
  _ST6 = a5;
  v13 = *(_BYTE *)(a2 - 159);
  __asm { fxam }
  *(_WORD *)(a2 - 160) = v11;
  HIBYTE(v14) = __ROL__((char)(2 * *(_BYTE *)(a2 - 159)) >> 1, 1);
  _AL = HIBYTE(v14) & 0xF;
  __asm { xlat }
  v17 = _AL;
  LOBYTE(v14) = __ROL__((char)(2 * v13) >> 1, 1);
  _AL = v14 & 0xF;
  __asm { xlat }
  return (*(int (__thiscall **)(int))((char)(4 * v17 | _AL) + a1 + 16))(v14 & 0x404);
}

//----- (1004AD8D) --------------------------------------------------------
double __cdecl sub_1004AD8D()
{
  return 1.0;
}

//----- (1004AD92) --------------------------------------------------------
double __usercall sub_1004AD92<st0>(int a1<ebp>, double a2<st0>)
{
  double result; // st7@1

  *(_QWORD *)(a1 - 158) = *(_QWORD *)&a2;
  result = *(double *)(a1 - 158);
  if ( *(_BYTE *)(a1 - 151) & 0x40 )
  {
    *(_BYTE *)(a1 - 144) = 7;
  }
  else
  {
    *(_BYTE *)(a1 - 144) = 1;
    result = result + 1.0;
  }
  return result;
}

//----- (1004AE39) --------------------------------------------------------
void __usercall sub_1004AE39(int a1<ebp>)
{
  *(_BYTE *)(a1 - 144) = 1;
}

//----- (1004AE50) --------------------------------------------------------
void __cdecl sub_1004AE50()
{
  JUMPOUT(*(unsigned int *)loc_1004AE70);
}
// 1004AE70: using guessed type int __cdecl loc_1004AE70(__int16, int, int, int);

//----- (1004AE67) --------------------------------------------------------
double __usercall sub_1004AE67<st0>(int a1<eax>, int a2<edx>, int a3<ecx>, double a4<st0>, __int16 a5, int a6, int a7, int a8)
{
  int ebp0; // ebp@0
  int v10; // [sp+0h] [bp-20h]@1
  int v11; // [sp+4h] [bp-1Ch]@1
  int v12; // [sp+8h] [bp-18h]@1
  int v13; // [sp+Ch] [bp-14h]@1
  double v14; // [sp+18h] [bp-8h]@1

  v10 = a1;
  v14 = a4;
  v11 = a3;
  v12 = a7;
  v13 = a8;
  sub_100535C7(ebp0, a2, (int)&v10, (int)&a5);
  return v14;
}

//----- (1004AEC5) --------------------------------------------------------
void __cdecl sub_1004AEC5()
{
  ;
}

//----- (1004AEDC) --------------------------------------------------------
double __usercall sub_1004AEDC<st0>(int a1<eax>, double result<st0>)
{
  if ( !(a1 & 0x80000) )
    result = result + 1.0;
  return result;
}

//----- (1004AEF5) --------------------------------------------------------
double __fastcall sub_1004AEF5(int a1, int a2)
{
  double result; // st7@2

  if ( (*(_DWORD *)(a2 + 4) & 0x7FF00000) == 2146435072 )
    result = COERCE_DOUBLE(*(_QWORD *)a2 << 11);
  else
    result = *(double *)a2;
  return result;
}

//----- (1004AF38) --------------------------------------------------------
int __cdecl sub_1004AF38(int a1, int a2)
{
  int result; // eax@1

  result = a2 & 0x7FF00000;
  if ( (a2 & 0x7FF00000) == 2146435072 )
    result = a2;
  return result;
}

//----- (1004B03C) --------------------------------------------------------
int __usercall sub_1004B03C<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  return sub_100538F4(a1, a2, a3, 0, 10);
}

//----- (1004B050) --------------------------------------------------------
int __usercall sub_1004B050<eax>(int a1<ebx>, int a2)
{
  LPVOID v2; // esi@1
  int result; // eax@2
  unsigned int v4; // edi@8

  v2 = dword_1007698C;
  if ( dword_10078AD4 )
  {
    if ( dword_1007698C || dword_10076990 && !sub_1005391E(a1) && (v2 = dword_1007698C, dword_1007698C) )
    {
      if ( a2 )
      {
        v4 = sub_10035550(a2);
        while ( *(_DWORD *)v2 )
        {
          if ( sub_10035550(*(_DWORD *)v2) > v4
            && *(_BYTE *)(*(_DWORD *)v2 + v4) == 61
            && !sub_100539AB(a1, v4, *(_DWORD *)v2, a2, v4) )
            return v4 + *(_DWORD *)v2 + 1;
          v2 = (char *)v2 + 4;
        }
      }
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10078AD4: using guessed type int dword_10078AD4;

//----- (1004B0E0) --------------------------------------------------------
int __cdecl sub_1004B0E0(int a1, unsigned int a2)
{
  int result; // eax@1
  unsigned int v3; // edx@1
  int v4; // ecx@1
  unsigned int v5; // esi@2

  v4 = a1 + *(_DWORD *)(a1 + 60);
  v3 = 0;
  result = v4 + *(_WORD *)(v4 + 20) + 24;
  if ( *(_WORD *)(v4 + 6) )
  {
    while ( 1 )
    {
      v5 = *(_DWORD *)(result + 12);
      if ( a2 >= v5 )
      {
        if ( a2 < v5 + *(_DWORD *)(result + 8) )
          break;
      }
      ++v3;
      result += 40;
      if ( v3 >= *(_WORD *)(v4 + 6) )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (1004B130) --------------------------------------------------------
unsigned int __usercall sub_1004B130<eax>(int a1<eax>, int a2)
{
  int v2; // eax@1
  int v3; // eax@2
  unsigned int result; // eax@3
  unsigned int v5; // [sp-10h] [bp-28h]@1
  unsigned int *v6; // [sp+0h] [bp-18h]@1
  int v7; // [sp+8h] [bp-10h]@1
  int (__cdecl *v8)(PEXCEPTION_RECORD, int, int); // [sp+Ch] [bp-Ch]@1
  unsigned int v9; // [sp+10h] [bp-8h]@1
  int v10; // [sp+14h] [bp-4h]@1
  int v11; // [sp+18h] [bp+0h]@1

  v8 = sub_1003B2B0;
  v7 = a1;
  v9 = __security_cookie ^ (unsigned int)&unk_1006D428;
  v5 = (unsigned int)&v11 ^ __security_cookie;
  v6 = &v5;
  v10 = 0;
  LOBYTE(v2) = sub_1004B1F0(268435456);
  if ( v2 && (v3 = sub_1004B0E0(268435456, a2 - 268435456)) != 0 )
  {
    result = ~(unsigned __int8)(*(_DWORD *)(v3 + 36) >> 31) & 1;
    v10 = -2;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;

//----- (1004B1F0) --------------------------------------------------------
char __cdecl sub_1004B1F0(int a1)
{
  char result; // al@2
  int v2; // ecx@3

  if ( *(_WORD *)a1 == 23117 )
  {
    v2 = a1 + *(_DWORD *)(a1 + 60);
    result = 0;
    if ( *(_DWORD *)v2 == 17744 )
      result = *(_WORD *)(v2 + 24) == 267;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004B221) --------------------------------------------------------
int __cdecl sub_1004B221(int a1)
{
  int result; // eax@1

  result = a1;
  dword_100772BC = a1;
  return result;
}
// 100772BC: using guessed type int dword_100772BC;

//----- (1004B230) --------------------------------------------------------
int __usercall sub_1004B230<eax>(int a1<ebp>, int a2, int a3, unsigned int a4)
{
  int result; // eax@2
  unsigned int v5; // esi@2
  int v6; // ebx@5
  char v7; // [sp-8h] [bp-28h]@1
  int (__cdecl *v8)(int, int, int, int); // [sp-4h] [bp-24h]@1
  unsigned int v9; // [sp+0h] [bp-20h]@1
  unsigned int v10; // [sp+4h] [bp-1Ch]@1
  int v11; // [sp+8h] [bp-18h]@1
  int v12; // [sp+Ch] [bp-14h]@1

  v12 = a2;
  v11 = a3;
  v10 = a4;
  v8 = loc_1004B2C0;
  v9 = (unsigned int)&v7 ^ __security_cookie;
  while ( 1 )
  {
    result = a3;
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 == -2 )
      break;
    if ( a4 != -2 && v5 <= a4 )
      break;
    v6 = (*(_DWORD *)a2 ^ *(_DWORD *)(a3 + 8)) + 12 * v5 + 16;
    *(_DWORD *)(a3 + 12) = *(_DWORD *)((*(_DWORD *)a2 ^ *(_DWORD *)(a3 + 8)) + 12 * v5 + 0x10);
    if ( !*(_DWORD *)(v6 + 4) )
    {
      sub_10052F25(*(_DWORD *)(v6 + 8), a1, 257);
      sub_10052F44(*(int (**)(void))(v6 + 8));
    }
  }
  return result;
}
// 1004B2C0: using guessed type int __cdecl loc_1004B2C0(int, int, int, int);
// 10074200: using guessed type int __security_cookie;

//----- (1004B322) --------------------------------------------------------
int __thiscall sub_1004B322(void *this)
{
  return ((int (__fastcall *)(_DWORD, _DWORD))this)(this, 0);
}

//----- (1004B339) --------------------------------------------------------
int __fastcall sub_1004B339(int a1, int a2)
{
  int v3; // esi@1

  v3 = a1;
  sub_10052F25(a1, a2, 1);
  return ((int (__fastcall *)(_DWORD, _DWORD))v3)(0, 0);
}

//----- (1004B352) --------------------------------------------------------
void __fastcall sub_1004B352(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord)
{
  RtlUnwind(TargetFrame, loc_1004B366, ExceptionRecord, 0);
}
// 1004B366: using guessed type int __fastcall loc_1004B366(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord);

//----- (1004B36B) --------------------------------------------------------
int __fastcall sub_1004B36B(int a1, unsigned int a2, int a3, int a4)
{
  return sub_1004B230(a3, a4, a1, a2);
}

//----- (1004B382) --------------------------------------------------------
int __thiscall sub_1004B382(int this, int a2, int a3, int a4)
{
  int v5; // eax@1

  *(_DWORD *)this = off_10066148;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_WORD *)(this + 12) = 0;
  *(_DWORD *)(this + 20) = a2;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  v5 = *(_DWORD *)(a3 + 16);
  *(_DWORD *)(this + 40) = a4;
  *(_DWORD *)(this + 36) = v5;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 44) = (*(_DWORD *)(a3 + 12) << 8) + *(_BYTE *)(*(_DWORD *)(a3 + 48) + 52 * a4 + 8);
  return this;
}
// 10066148: using guessed type int (*off_10066148[2])();

//----- (1004B3E9) --------------------------------------------------------
int __thiscall sub_1004B3E9(int this, int a2, int a3)
{
  int v4; // ebx@1
  int v5; // eax@1

  v4 = this;
  *(_DWORD *)this = off_10066148;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_WORD *)(this + 12) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 20) = a2;
  *(_DWORD *)(this + 24) = a3;
  *(_DWORD *)(this + 36) = (**(int (__thiscall ***)(_DWORD))a3)(a3);
  v5 = *(_DWORD *)(a3 + 40);
  *(_DWORD *)(v4 + 48) = 0;
  *(_DWORD *)(v4 + 40) = v5;
  *(_DWORD *)(v4 + 44) = (*(int (__thiscall **)(int))(*(_DWORD *)a3 + 4))(a3);
  return v4;
}
// 10066148: using guessed type int (*off_10066148[2])();

//----- (1004B448) --------------------------------------------------------
int __thiscall sub_1004B448(int this)
{
  return sub_1003C0AC(*(_DWORD *)(*(_DWORD *)(this + 20) + 12), *(_DWORD *)(this + 36), *(_DWORD *)(this + 40));
}

//----- (1004B45A) --------------------------------------------------------
void __thiscall sub_1004B45A(int this)
{
  int v1; // esi@1
  char v2; // zf@1
  char v3; // bl@2
  HANDLE v4; // eax@4

  v1 = this;
  v2 = *(_DWORD *)(this + 48) == 1;
  --*(_DWORD *)(v1 + 48);
  if ( v2 )
  {
    v3 = *(_DWORD *)(this + 28) != 0;
    sub_1004B605(this);
    if ( *(_DWORD *)(v1 + 24) )
    {
      sub_1004B45A();
      sub_1004CB86(*(void **)(v1 + 20), (void *)v1);
    }
    else
    {
      sub_1004C3FC(*(_DWORD *)(v1 + 20), *(_DWORD *)(v1 + 36), *(_DWORD *)(v1 + 40), v3 == 0);
      if ( !v3 )
      {
        v4 = GetCurrentThread();
        sub_1003BB75((DWORD_PTR *)(v1 + 8), v4);
        sub_1004C3A4(*(_DWORD *)(v1 + 20), v1);
        sub_1004C48C(*(_DWORD *)(v1 + 20), v1);
      }
    }
  }
}

//----- (1004B4C5) --------------------------------------------------------
int __thiscall sub_1004B4C5(int this)
{
  return *(_DWORD *)(this + 44);
}

//----- (1004B4C9) --------------------------------------------------------
int __thiscall sub_1004B4C9(int this)
{
  return *(_DWORD *)(this + 36);
}

//----- (1004B4CD) --------------------------------------------------------
BOOL __thiscall sub_1004B4CD(int lpTlsValue)
{
  BOOL result; // eax@1
  int v2; // ebx@1
  int v3; // ecx@1
  int v4; // ecx@2
  int v5; // eax@4
  void *v6; // esi@4
  int v7; // eax@4
  int v8; // ecx@4
  int v9; // eax@4
  int v10; // edx@4
  char v11; // [sp+7h] [bp-1Dh]@2
  char v12; // [sp+8h] [bp-1Ch]@4
  int v13; // [sp+14h] [bp-10h]@4
  _DWORD v14[2]; // [sp+18h] [bp-Ch]@4
  int v15; // [sp+1Ch] [bp-8h]@4
  unsigned int v16; // [sp+20h] [bp-4h]@1
  int v17; // [sp+24h] [bp+0h]@1

  v16 = (unsigned int)&v17 ^ __security_cookie;
  v2 = lpTlsValue;
  v3 = *(_DWORD *)(lpTlsValue + 48);
  result = v3 + 1;
  *(_DWORD *)(v2 + 48) = v3 + 1;
  if ( !v3 )
  {
    v4 = *(_DWORD *)(v2 + 20);
    v11 = *(_DWORD *)(v2 + 28) != 0;
    if ( *(_DWORD *)(v2 + 24) )
    {
      sub_1004C047(v4, v2);
    }
    else
    {
      sub_1004C979(v4, *(_DWORD *)(v2 + 36), *(_DWORD *)(v2 + 40), (*(_DWORD *)(v2 + 28) != 0) == 0);
      if ( !v11 )
      {
        v5 = (int)GetCurrentThread();
        v6 = (void *)v5;
        v7 = sub_1003B79E((int)&v12, v5);
        *(_WORD *)(v2 + 12) = *(_WORD *)(v7 + 4);
        *(_DWORD *)(v2 + 8) = *(_DWORD *)v7;
        v8 = 52 * *(_DWORD *)(v2 + 36);
        v9 = *(_DWORD *)(*(_DWORD *)(v2 + 20) + 16);
        v10 = *(_DWORD *)(v8 + v9);
        LOWORD(v8) = *(_WORD *)(v8 + v9 + 12);
        v14[0] = 0;
        v15 = 0;
        LOWORD(v14[0]) = v8;
        v13 = v10;
        sub_1003BB75((DWORD_PTR *)&v13, v6);
        sub_1004C91D(*(_DWORD *)(v2 + 20), v2);
        sub_1004BFB6(v2);
      }
    }
    result = sub_1004B620((LPVOID)v2);
  }
  return result;
}
// 1004BFB6: using guessed type _DWORD __stdcall sub_1004BFB6(_DWORD);
// 10074200: using guessed type int __security_cookie;

//----- (1004B599) --------------------------------------------------------
int __thiscall sub_1004B599(int this, int a2)
{
  int ebp0; // ebp@0
  int v3; // edi@1
  int v4; // esi@1
  int v6; // [sp-4h] [bp-18h]@3
  int (__stdcall **v7)(char); // [sp+8h] [bp-Ch]@3

  v3 = a2;
  v4 = this;
  if ( !a2 )
  {
    a2 = (int)"pScheduler";
    sub_1002AEA4((int)&v7, &a2);
    v7 = &off_100602FC;
    v6 = (int)&unk_1006D8F4;
    goto LABEL_7;
  }
  if ( sub_1004C594(*(_DWORD *)(this + 20)) != (LPVOID)this || *(_DWORD *)(*(_DWORD *)(v4 + 20) + 8) != v3 )
  {
    sub_1002FFD5((int)&v7);
    v6 = (int)&unk_1006D8B8;
LABEL_7:
    sub_100355DB((int)&v7, v6);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1004B605);
  }
  return sub_1003EA90(ebp0, v4);
}
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);

//----- (1004B605) --------------------------------------------------------
BOOL __thiscall sub_1004B605(int this)
{
  BOOL result; // eax@1
  int v2; // esi@1

  v2 = this;
  result = TlsSetValue(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 20) + 12) + 112), *(LPVOID *)(this + 32));
  *(_DWORD *)(v2 + 32) = 0;
  return result;
}

//----- (1004B620) --------------------------------------------------------
BOOL __thiscall sub_1004B620(LPVOID lpTlsValue)
{
  void *v2; // edi@1
  DWORD v3; // esi@1

  v2 = lpTlsValue;
  v3 = *(_DWORD *)(*(_DWORD *)(*((_DWORD *)lpTlsValue + 5) + 12) + 112);
  *((_DWORD *)lpTlsValue + 8) = TlsGetValue(v3);
  return TlsSetValue(v3, v2);
}

//----- (1004B642) --------------------------------------------------------
unsigned int __cdecl sub_1004B642(unsigned int a1)
{
  unsigned int result; // eax@1

  result = a1;
  if ( a1 )
    result = (a1 > 0 ? 2 : 0) - 1;
  return result;
}

//----- (1004B65A) --------------------------------------------------------
double __cdecl sub_1004B65A(double a1)
{
  double result; // st7@2
  signed int v2; // [sp+Ch] [bp+Ch]@4

  if ( 0.0 == a1 )
  {
    result = 0.0;
  }
  else
  {
    if ( a1 <= 0.0 )
      v2 = -1;
    else
      v2 = 1;
    result = (double)v2;
  }
  return result;
}

//----- (1004B690) --------------------------------------------------------
int __thiscall sub_1004B690(int this, int a2, unsigned int a3, int a4)
{
  int v4; // eax@1
  signed int v5; // edx@1

  v5 = 63;
  v4 = this + 8;
  do
  {
    *(double *)(v4 - 8) = 0.0;
    *(_DWORD *)(v4 + 8) = 0;
    *(double *)v4 = 0.0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    v4 += 32;
    --v5;
  }
  while ( v5 >= 0 );
  *(_DWORD *)(this + 2048) = a4;
  *(_DWORD *)(this + 2076) = a2;
  *(_DWORD *)(this + 2068) = 0;
  *(_DWORD *)(this + 2072) = 0;
  *(_DWORD *)(this + 2080) = 0;
  *(_DWORD *)(this + 2084) = 0;
  *(_DWORD *)(this + 2088) = 0;
  *(_DWORD *)(this + 2092) = 0;
  *(_DWORD *)(this + 2096) = 0;
  *(_BYTE *)(this + 2100) = 1;
  *(_DWORD *)(this + 2064) = a3;
  *(double *)(this + 2056) = (double)a3;
  return this;
}

//----- (1004B71A) --------------------------------------------------------
int __thiscall sub_1004B71A(int this, double a2, int a3)
{
  int result; // eax@1
  double v4; // st7@1

  v4 = *(double *)this;
  result = a3;
  ++*(_DWORD *)(this + 16);
  *(_DWORD *)(this + 24) = a3;
  *(double *)this = v4 + a2;
  *(double *)(this + 8) = a2 * a2 + *(double *)(this + 8);
  return result;
}

//----- (1004B73D) --------------------------------------------------------
double __stdcall sub_1004B73D(unsigned int a1, unsigned int a2, int a3, int a4)
{
  return (double)a2 * 10.0 / (double)a1;
}

//----- (1004B778) --------------------------------------------------------
double __thiscall sub_1004B778(void *this, int a2, int a3)
{
  int v3; // edi@1
  long double v4; // st7@1
  void *v5; // edi@1
  int v6; // esi@1
  double v7; // ST28_8@1
  double v8; // ST28_8@2
  double v9; // ST20_8@2
  double v10; // st7@2
  double v12; // [sp+Ch] [bp-20h]@1
  double v13; // [sp+14h] [bp-18h]@1

  v5 = this;
  v6 = sub_1004B8F0(this, a2);
  v3 = sub_1004B8F0(v5, a3);
  v7 = sub_1004B964(v6);
  v13 = sub_1004B964(v3) - v7;
  v12 = v13 / v7 / ((double)(a3 - a2) / (double)a2) - 0.15;
  v4 = 0.0;
  if ( fabs(v13) > 0.0 )
  {
    v8 = (double)*(signed int *)(v3 + 16);
    v9 = sub_1004BC13(v3) / v8;
    v10 = sub_1004BC13(v3) / v8 + v9;
    sub_10039E20();
    v4 = fabs(v10 / v13);
  }
  sub_10053ABC();
  return -v4 * v12;
}
// 10039E20: using guessed type double sub_10039E20(void);
// 10053ABC: using guessed type double sub_10053ABC(void);

//----- (1004B830) --------------------------------------------------------
double __thiscall sub_1004B830(int this)
{
  int v2; // esi@1
  double v3; // st7@1
  double v4; // ST04_8@1
  double v5; // st7@1

  v2 = this;
  sub_1004BC13(this);
  sub_10039E20();
  v4 = v3;
  v5 = (double)*(signed int *)(v2 + 16);
  sub_10039E20();
  return v4 / v5 / sub_1004B964(v2);
}
// 10039E20: using guessed type double sub_10039E20(void);

//----- (1004B867) --------------------------------------------------------
int __thiscall sub_1004B867(int this, int a2)
{
  int result; // eax@1
  int v3; // ecx@1
  int v4; // esi@1
  int v5; // eax@2

  result = a2;
  v4 = this;
  v3 = *(_DWORD *)(this + 2068);
  if ( a2 != v3 )
  {
    *(_DWORD *)(v4 + 2072) = v3;
    *(_DWORD *)(v4 + 2068) = a2;
    v5 = sub_1004B8F0((void *)v4, a2);
    *(double *)v5 = 0.0;
    *(_DWORD *)(v5 + 16) = 0;
    *(double *)(v5 + 8) = 0.0;
    *(_DWORD *)(v5 + 20) = 0;
    *(_DWORD *)(v5 + 24) = 0;
    result = sub_1004B8AC(v4);
  }
  return result;
}

//----- (1004B8AC) --------------------------------------------------------
__int64 __fastcall sub_1004B8AC(int a1)
{
  __int64 result; // qax@1
  signed int v2; // esi@1

  HIDWORD(result) = a1 + 20;
  v2 = 64;
  do
  {
    LODWORD(result) = *HIDWORD(result);
    if ( *HIDWORD(result) != *(_DWORD *)(a1 + 2068) )
    {
      if ( (_DWORD)result != *(_DWORD *)(a1 + 2072) )
      {
        LODWORD(result) = *(_DWORD *)(a1 + 2084) - *(_DWORD *)(HIDWORD(result) + 4);
        if ( (_DWORD)result > 0x32u )
        {
          *(_DWORD *)(HIDWORD(result) - 4) = 0;
          *(double *)(HIDWORD(result) - 20) = 0.0;
          *HIDWORD(result) = 0;
          *(double *)(HIDWORD(result) - 12) = 0.0;
          *(_DWORD *)(HIDWORD(result) + 4) = 0;
        }
      }
    }
    result += 137438953472i64;
    --v2;
  }
  while ( v2 );
  return result;
}

//----- (1004B8F0) --------------------------------------------------------
int __thiscall sub_1004B8F0(void *this, int a2)
{
  int result; // eax@1

  result = (int)((char *)this + 32 * (a2 & 0x3F));
  if ( *(_DWORD *)(result + 20) != a2 )
  {
    *(_DWORD *)(result + 16) = 0;
    *(_DWORD *)(result + 24) = 0;
    *(double *)result = 0.0;
    *(double *)(result + 8) = 0.0;
    *(_DWORD *)(result + 20) = a2;
  }
  return result;
}

//----- (1004B91B) --------------------------------------------------------
bool __thiscall sub_1004B91B(int this)
{
  bool result; // eax@1
  char v2; // dl@1

  v2 = *(_BYTE *)(this + 2100);
  result = v2 != 0;
  *(_BYTE *)(this + 2100) = v2 == 0;
  return result;
}

//----- (1004B934) --------------------------------------------------------
char __stdcall sub_1004B934(int a1)
{
  return *(_DWORD *)(a1 + 16) > 5u || *(_DWORD *)(a1 + 16) >= 3u && fabs(sub_1004B830(a1)) <= 0.004;
}

//----- (1004B964) --------------------------------------------------------
double __fastcall sub_1004B964(int a1)
{
  double result; // st7@2
  signed int v2; // [sp+4h] [bp-4h]@1

  v2 = *(_DWORD *)(a1 + 16);
  if ( v2 )
    result = *(double *)a1 / (double)v2;
  else
    result = 0.0;
  return result;
}

//----- (1004B984) --------------------------------------------------------
int __thiscall sub_1004B984(int this, unsigned int a2)
{
  int v2; // eax@1
  unsigned int v3; // ecx@1
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // esi@1
  int v10; // [sp+Ch] [bp-4h]@1

  v7 = this;
  v10 = this;
  v8 = *(_DWORD *)(this + 2048);
  v4 = *(_DWORD *)(v8 + 184) + sub_1003DDD2(*(_DWORD *)(this + 2048));
  v2 = sub_1003C119(v8);
  v5 = *(_DWORD *)(v7 + 2068);
  v3 = *(_DWORD *)(v10 + 2064);
  v6 = a2;
  if ( v3 + v5 < a2 )
    v6 = v3 + v5;
  if ( v5 > v3 )
  {
    if ( v5 - v3 > v6 )
      v6 = v5 - v3;
  }
  if ( v6 == v5 )
  {
    if ( v6 <= (unsigned int)v4 )
      ++v6;
    else
      --v6;
  }
  if ( v4 > (unsigned int)v6 )
    v6 = v4;
  if ( v2 < (unsigned int)v6 )
    v6 = v2;
  if ( v6 != v5 && sub_1004B642(v6 - v5) == -1 )
  {
    while ( 1 )
    {
      --v5;
      if ( v5 != v6 )
      {
        if ( sub_1004B642(v6 - v5) != -1 )
          break;
      }
      if ( *(_DWORD *)(sub_1004B8F0((void *)v10, v5) + 16) > 0
        && sub_1004B778((void *)v10, *(_DWORD *)(v10 + 2068), v5) * -1.0 <= 0.0 )
        return v5 + 1;
    }
  }
  return v6;
}

//----- (1004BA54) --------------------------------------------------------
int __thiscall sub_1004BA54(int this, int a2, unsigned int a3, int a4, int a5)
{
  int v5; // ebx@1
  int result; // eax@2
  int v7; // edx@3
  unsigned int v8; // ecx@3
  int v9; // edi@3
  unsigned int v10; // esi@8
  int v11; // esi@12
  int v12; // edi@12
  int v13; // edi@14
  unsigned int v14; // eax@14
  int v15; // esi@14
  int v16; // esi@16
  unsigned int v17; // eax@19
  double v18; // st7@19
  int v19; // esi@19
  double v20; // st7@20
  double v21; // [sp+18h] [bp-8h]@14
  double v22; // [sp+18h] [bp-8h]@19
  int v23; // [sp+34h] [bp+14h]@16

  v5 = this;
  if ( !a2 )
    return 0;
  ++*(_DWORD *)(this + 2084);
  sub_1004B867(this, a2);
  v9 = *(_DWORD *)(v5 + 2088);
  v8 = a3;
  v7 = a4;
  if ( v9 )
  {
    v8 = *(_DWORD *)(v5 + 2092) + a3;
    v7 = *(_DWORD *)(v5 + 2096) + a4;
  }
  if ( v8 < a2 )
  {
    if ( v8 < a5 )
    {
      v7 += a2 - v8;
      v8 = a2;
    }
  }
  v10 = *(_DWORD *)(v5 + 2080);
  if ( v10 < 1 || v8 >= 1 || (unsigned int)v7 >= 1 || a5 )
  {
    v14 = v9 + 1;
    v15 = v10 + 1;
    *(_DWORD *)(v5 + 2092) = 0;
    *(_DWORD *)(v5 + 2096) = 0;
    *(_DWORD *)(v5 + 2088) = 0;
    v13 = *(_DWORD *)(v5 + 2068);
    *(_DWORD *)(v5 + 2080) = v15;
    v21 = sub_1004B73D(v14, v8, v7, a5);
    if ( (unsigned int)v15 <= 1 )
    {
      *(_DWORD *)(v5 + 2072) = v13;
      return v13;
    }
    v16 = sub_1004B8F0((void *)v5, v13);
    v23 = sub_1004B8F0((void *)v5, *(_DWORD *)(v5 + 2072));
    sub_1004B71A(v16, v21, *(_DWORD *)(v5 + 2084));
    if ( *(_DWORD *)(v23 + 16) && v16 != v23 )
    {
      if ( !sub_1004B934(v16) )
        return v13;
      v18 = sub_1004B778((void *)v5, *(_DWORD *)(v5 + 2072), *(_DWORD *)(v5 + 2068)) * *(double *)(v5 + 2056);
      v19 = *(_DWORD *)(v5 + 2068);
      v22 = (double)*(unsigned int *)(v5 + 2068);
      sub_1004D276(v18);
      if ( v17 == v19 )
      {
        v20 = sub_1004B65A(v18);
        sub_1004D276(v20 + v22);
      }
    }
    else
    {
      if ( !sub_1004B934(v16) )
        return v13;
      v17 = *(_DWORD *)(v5 + 2068) + sub_1004B91B(v5);
    }
    return sub_1004B984(v5, v17);
  }
  v11 = *(_DWORD *)(v5 + 2048);
  *(_DWORD *)(v5 + 2092) = v8;
  v12 = v9 + 1;
  *(_DWORD *)(v5 + 2088) = v12;
  *(_DWORD *)(v5 + 2096) = v7;
  result = *(_DWORD *)(v11 + 184) + sub_1003DDD2(v11);
  if ( (unsigned int)v12 < 3 )
    result = *(_DWORD *)(v5 + 2068);
  return result;
}
// 1004D276: using guessed type double __usercall sub_1004D276<st0>(double<st0>);

//----- (1004BC13) --------------------------------------------------------
double __fastcall sub_1004BC13(int a1)
{
  signed int v1; // eax@1
  double v2; // st6@1
  double result; // st7@1

  v1 = *(_DWORD *)(a1 + 16);
  result = 0.0;
  v2 = 0.0;
  if ( v1 >= 2 )
    v2 = (*(double *)(a1 + 8) - *(double *)a1 * *(double *)a1 / (double)v1) / (double)(v1 - 1);
  if ( fabs(v2) > 0.0001 )
    result = v2;
  return result;
}

//----- (1004BC5F) --------------------------------------------------------
#error "1004BEAD: call analysis failed (funcsize=178)"

//----- (1004BEB5) --------------------------------------------------------
#error "1004BEF8: call analysis failed (funcsize=21)"

//----- (1004BEFE) --------------------------------------------------------
char *__thiscall sub_1004BEFE(int this, int a2, int a3, char a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // eax@4
  void *v8; // ebx@7
  signed __int64 v10; // qax@8
  char *result; // eax@11
  char v12; // [sp+Ch] [bp-4h]@7
  unsigned int v13; // [sp+20h] [bp+10h]@9

  v6 = this;
  v4 = *(_DWORD *)(this + 164);
  v5 = *(_DWORD *)(this + 144);
  if ( v4 )
    *(_DWORD *)(this + 164) = v4 - 1;
  else
    --v5;
  ++*(_DWORD *)(a2 + 28);
  ++*(_DWORD *)(this + 160);
  v7 = *(_DWORD *)(a2 + 48) + 52 * a3;
  *(_DWORD *)v7 = 4;
  *(_DWORD *)(v7 + 36) = v5;
  *(_DWORD *)(this + 176) += v5;
  if ( a4 )
    sub_1004CC9B(this, a2, a3);
  if ( v5 == 1 )
  {
    v8 = &v12;
  }
  else
  {
    _ECX = 0;
    v10 = 4i64 * (unsigned int)v5;
    __asm { seto    cl }
    v8 = (void *)sub_1002965B(SHIDWORD(v10), v10 | -_ECX, 4, v5, v10 | -_ECX);
  }
  v13 = 0;
  if ( v5 )
  {
    do
      *((_DWORD *)v8 + v13++) = (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v6 + 24))(v6, a2, a3);
    while ( v13 < v5 );
  }
  sub_1004C056(v8, v5);
  result = &v12;
  if ( v8 != &v12 )
    result = (char *)sub_10030383(v8);
  return result;
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 1004C056: using guessed type _DWORD __stdcall sub_1004C056(_DWORD, _DWORD);

//----- (1004BFB6) --------------------------------------------------------
#error "1004C006: call analysis failed (funcsize=28)"

//----- (1004C00E) --------------------------------------------------------
int __thiscall sub_1004C00E(int this, int a2)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 4);
  if ( result )
  {
    *(_DWORD *)(a2 + 56) = *(_DWORD *)(result + 56);
    *(_DWORD *)(a2 + 52) = *(_DWORD *)(this + 4);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 4) + 56) + 52) = a2;
    result = *(_DWORD *)(this + 4);
    *(_DWORD *)(result + 56) = a2;
  }
  else
  {
    *(_DWORD *)(a2 + 56) = a2;
    *(_DWORD *)(a2 + 52) = a2;
  }
  *(_DWORD *)(this + 4) = a2;
  ++*(_DWORD *)this;
  return result;
}

//----- (1004C047) --------------------------------------------------------
int __thiscall sub_1004C047(int this, int a2)
{
  return sub_1004C00E(this + 196, a2);
}

//----- (1004C056) --------------------------------------------------------
#error "1004C0E2: call analysis failed (funcsize=51)"

//----- (1004C0EA) --------------------------------------------------------
int __thiscall sub_1004C0EA(void *this, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // ecx@1
  int v5; // edi@1
  unsigned __int64 v6; // qax@2
  int v7; // ebx@2
  unsigned int v8; // esi@2
  int v9; // esi@5

  v5 = (int)this;
  v4 = 0;
  v2 = *(_DWORD *)(v5 + 140);
  v3 = *(_DWORD *)(v5 + 156);
  if ( v2 > v3 )
  {
    v8 = *(_DWORD *)(v5 + 144);
    v7 = *(_DWORD *)(v5 + 164);
    v6 = v2 - v3;
    if ( v7 * v8 < (_DWORD)v6 )
    {
      LODWORD(v6) = v6 - v7 * v8;
      v4 = v7 + v6 / (v8 - 1);
    }
    else
    {
      v4 = (_DWORD)v6 / v8;
    }
  }
  v9 = v4 + *(_DWORD *)(v5 + 160);
  if ( v9 >= (unsigned int)sub_1003C119(v5) )
    v9 = sub_1003C119(v5);
  if ( v9 >= (unsigned int)a2 )
    v9 = a2;
  return v9;
}

//----- (1004C15A) --------------------------------------------------------
int __thiscall sub_1004C15A(void *this, int a2)
{
  void *v2; // edi@1
  int result; // eax@2
  int (__stdcall **v4)(char); // [sp+8h] [bp-Ch]@5

  v2 = this;
  if ( !a2 )
  {
    a2 = (int)"pContext";
    sub_1002AEA4((int)&v4, &a2);
    v4 = &off_100602FC;
    sub_100355DB((int)&v4, (int)&unk_1006D8F4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1004C1AD);
  }
  result = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)a2 + 8))(a2);
  if ( !result )
    result = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v2 + 28))(v2);
  return result;
}
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);

//----- (1004C1AD) --------------------------------------------------------
int __thiscall sub_1004C1AD(void *this)
{
  unsigned int v1; // ecx@1
  void *v2; // ebx@1
  int v3; // edx@2
  unsigned int v4; // esi@3
  int v5; // ecx@4
  int v6; // ebx@4
  int v7; // edi@5
  int v8; // edi@6
  int v9; // esi@9
  int v10; // esi@12
  void *v12; // [sp+4h] [bp-18h]@1
  int v13; // [sp+Ch] [bp-10h]@2
  unsigned int v14; // [sp+10h] [bp-Ch]@1
  unsigned int v15; // [sp+14h] [bp-8h]@3
  int v16; // [sp+18h] [bp-4h]@4

  v2 = this;
  v1 = 0;
  v12 = v2;
  v14 = 0;
  if ( *((_DWORD *)v2 + 48) )
  {
    v3 = 0;
    v13 = 0;
    do
    {
      v4 = 0;
      v15 = 0;
      if ( *(_DWORD *)(v3 + *((_DWORD *)v2 + 4) + 4) )
      {
        v5 = 0;
        v16 = 0;
        v6 = v3 + *((_DWORD *)v2 + 4);
        do
        {
          v7 = *(_DWORD *)(*(_DWORD *)(v6 + 48) + v5 + 16);
          if ( v7 )
            v8 = *(_DWORD *)(v7 + 56);
          else
            v8 = 0;
          if ( v8 )
          {
            do
            {
              v9 = v8;
              if ( v8 == *(_DWORD *)(*(_DWORD *)(v6 + 48) + v5 + 16) )
                v8 = 0;
              else
                v8 = *(_DWORD *)(v8 + 56);
              v10 = *(_DWORD *)(v9 + 28);
              sub_10053BCA(v10);
              (*(void (__thiscall **)(int))(*(_DWORD *)v10 + 36))(v10);
              v5 = v16;
            }
            while ( v8 );
            v4 = v15;
          }
          ++v4;
          v5 += 52;
          v15 = v4;
          v16 = v5;
        }
        while ( v4 < *(_DWORD *)(v6 + 4) );
        v2 = v12;
        v1 = v14;
        v3 = v13;
      }
      ++v1;
      v3 += 52;
      v14 = v1;
      v13 = v3;
    }
    while ( v1 < *((_DWORD *)v2 + 48) );
  }
  return sub_1002A4AA(*((LPVOID *)v2 + 14));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1004C269) --------------------------------------------------------
int __userpurge sub_1004C269<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@1

  sub_10035668();
  v5 = v7;
  v4 = sub_1002ADB1(v8, v7, a1, v7, 60);
  *(_DWORD *)(a2 - 16) = v4;
  v6 = 0;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v4 )
    v6 = sub_1004B382(v4, v5, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12));
  *(_DWORD *)(a2 - 4) = -1;
  sub_1004B4CD(v6);
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1004C2B0) --------------------------------------------------------
#error "1004C364: call analysis failed (funcsize=61)"

//----- (1004C36C) --------------------------------------------------------
int __userpurge sub_1004C36C<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@1

  sub_10035668();
  v6 = v7;
  v5 = sub_1002ADB1(v8, v7, a1, a3, 88);
  *(_DWORD *)(a2 - 16) = v5;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v5 )
    sub_10053BFC(v5, v6, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12));
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1004C3A4) --------------------------------------------------------
int __thiscall sub_1004C3A4(int this, int a2)
{
  int result; // eax@1
  int v3; // edi@1
  int v10; // ecx@2

  v3 = this;
  result = 52 * *(_DWORD *)(a2 + 40)
         + 24
         + *(_DWORD *)(52 * (**(int (__thiscall ***)(_DWORD))a2)(a2) + *(_DWORD *)(this + 16) + 48);
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  if ( _ZF )
  {
    v10 = *(_DWORD *)(v3 + 12);
    result = *(_DWORD *)(v3 + 132) == *(_DWORD *)(v3 + 128);
    if ( *(_DWORD *)(v10 + 16) > (unsigned int)result )
      result = SetEvent(*(HANDLE *)(v10 + 80));
  }
  return result;
}

//----- (1004C3FC) --------------------------------------------------------
int __thiscall sub_1004C3FC(int this, int a2, int a3, char a4)
{
  int result; // eax@1
  int v5; // ecx@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // esi@1
  char v9; // zf@3
  int v10; // [sp+14h] [bp+8h]@1

  v6 = 52 * a2;
  v8 = this;
  result = *(_DWORD *)(this + 16);
  v5 = 52 * a3;
  v7 = 52 * a3 + *(_DWORD *)(result + 52 * a2 + 48);
  v10 = 52 * a3;
  if ( a4 )
  {
    --*(_DWORD *)(v7 + 44);
    --*(_DWORD *)(v8 + 180);
  }
  v9 = *(_DWORD *)(v7 + 40)-- == 1;
  if ( v9 )
  {
    result = v6 + *(_DWORD *)(v8 + 16);
    --*(_DWORD *)(v8 + 172);
    --*(_DWORD *)(result + 36);
    if ( *(_BYTE *)(v7 + 50) )
    {
      result = sub_1004CC9B(v8, result, a3);
      v5 = v10;
      *(_BYTE *)(v7 + 50) = 0;
    }
    if ( a4 )
    {
      result = *(_DWORD *)(*(_DWORD *)(v8 + 16) + v6 + 48);
      if ( !*(_DWORD *)(result + v5 + 36) )
        --*(_DWORD *)(v8 + 184);
    }
  }
  return result;
}

//----- (1004C477) --------------------------------------------------------
int __thiscall sub_1004C477(void *this)
{
  void *v1; // esi@1
  int result; // eax@2

  v1 = this;
  if ( this )
  {
    sub_1004BEB5();
    result = sub_1002A4AA(v1);
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1004BEB5: using guessed type int sub_1004BEB5(void);

//----- (1004C48C) --------------------------------------------------------
int __thiscall sub_1004C48C(int this, int a2)
{
  int v2; // edx@1
  int v3; // ebx@1
  int v4; // esi@1
  int v5; // esi@2
  int v7; // [sp+Ch] [bp-4h]@1

  v4 = this;
  v7 = this;
  v2 = *(_DWORD *)(this + 16) + 52 * (**(int (__thiscall ***)(_DWORD))a2)(a2);
  v3 = *(_DWORD *)(v2 + 48) + 52 * *(_DWORD *)(a2 + 40);
  if ( !(*(_DWORD *)(v3 + 36) + *(_DWORD *)(v3 + 44)) )
  {
    --*(_DWORD *)(v2 + 28);
    *(_DWORD *)v3 = 1;
    --*(_DWORD *)(v4 + 160);
    v5 = *(_DWORD *)(40 * (**(int (__thiscall ***)(_DWORD))a2)(a2) + *(_DWORD *)(*(_DWORD *)(v7 + 12) + 72) + 32)
       + 36 * *(_DWORD *)(a2 + 40);
    --*(_DWORD *)(v5 + 16);
    v4 = v7;
  }
  sub_1002B91E((LPCRITICAL_SECTION)(v4 + 32));
  sub_1004CA81(v3 + 12, a2);
  sub_1002BB53((LPCRITICAL_SECTION)(v4 + 32));
  *(_DWORD *)a2 = off_10066148;
  return sub_1002A4AA((LPVOID)a2);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10066148: using guessed type int (*off_10066148[2])();

//----- (1004C518) --------------------------------------------------------
#error "1004C57C: call analysis failed (funcsize=35)"

//----- (1004C584) --------------------------------------------------------
int __thiscall sub_1004C584(void *this)
{
  void *v2; // esi@1

  v2 = this;
  sub_1004C1AD(this);
  return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v2 + 36))(v2);
}

//----- (1004C594) --------------------------------------------------------
LPVOID __thiscall sub_1004C594(int this)
{
  LPVOID v1; // eax@1
  LPVOID v2; // esi@1

  v2 = 0;
  v1 = TlsGetValue(*(_DWORD *)(*(_DWORD *)(this + 12) + 112));
  if ( v1 )
  {
    if ( !((_BYTE)v1 & 3) )
      v2 = v1;
  }
  return v2;
}

//----- (1004C5B1) --------------------------------------------------------
int __userpurge sub_1004C5B1<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int ebp0; // ebp@0
  int v4; // esi@1
  int v6; // esi@3

  v4 = a1;
  if ( !*(_DWORD *)(a1 + 4) )
    *(_DWORD *)(a1 + 4) = sub_1004CFBF(a2, ebp0);
  v6 = (***(int (__stdcall ****)(_DWORD, _DWORD))(v4 + 4))(*(_DWORD *)(v4 + 148), *(_DWORD *)(v4 + 152));
  sub_10053FD5(v6, a3);
  return v6;
}

//----- (1004C5F1) --------------------------------------------------------
int __userpurge sub_1004C5F1<eax>(int a1<ebp>, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@2
  int v7; // esi@2

  sub_10035668();
  v4 = v3;
  v5 = *(_DWORD *)(a1 + 8);
  if ( *(_DWORD *)(v5 + 20) != v3 )
  {
    v6 = sub_1002ADB1(v2, v3, v3, v5, 60);
    *(_DWORD *)(a1 + 8) = v6;
    v7 = 0;
    *(_DWORD *)(a1 - 4) = 0;
    if ( v6 )
      v7 = sub_1004B3E9(v6, v4, v5);
    *(_DWORD *)(a1 - 4) = -1;
    sub_1004B4CD(v7);
  }
  return sub_10035636(0);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1004C63F) --------------------------------------------------------
int __thiscall sub_1004C63F(int this, unsigned int a2, int a3, char a4)
{
  __int64 v4; // qcx@1
  int ebp0; // ebp@0
  int v6; // esi@1
  int v7; // eax@2
  unsigned int v8; // edx@2
  bool v9; // ecx@2
  int v10; // edi@4
  unsigned int v11; // eax@14
  int v12; // edx@15
  signed __int64 v14; // qax@18
  unsigned int v15; // eax@20
  int v16; // edx@20
  char v17; // cl@20
  unsigned int v18; // edi@20
  int v19; // edx@26
  int v20; // edi@30
  char v21; // al@34
  char v22; // dl@35
  int v23; // eax@41
  int v24; // edi@41
  int v25; // eax@53
  int v27; // [sp+Ch] [bp-40h]@30
  int i; // [sp+10h] [bp-3Ch]@20
  int v29; // [sp+14h] [bp-38h]@10
  unsigned int v30; // [sp+18h] [bp-34h]@24
  int v31; // [sp+1Ch] [bp-30h]@20
  bool v32; // [sp+20h] [bp-2Ch]@4
  int v33; // [sp+24h] [bp-28h]@18
  int v34; // [sp+28h] [bp-24h]@13
  int j; // [sp+2Ch] [bp-20h]@26
  int v36; // [sp+30h] [bp-1Ch]@27
  int v37; // [sp+34h] [bp-18h]@11
  unsigned int v38; // [sp+38h] [bp-14h]@1
  int v39; // [sp+3Ch] [bp-10h]@10
  int v40; // [sp+40h] [bp-Ch]@10
  unsigned int v41; // [sp+44h] [bp-8h]@21
  char v42; // [sp+49h] [bp-3h]@5
  char v43; // [sp+4Ah] [bp-2h]@8
  char v44; // [sp+4Bh] [bp-1h]@20

  HIDWORD(v4) = 0;
  v6 = this;
  v38 = 0;
  if ( a4 )
  {
    v7 = sub_1003DDD2(this);
    v8 = a2;
    v9 = *(_DWORD *)(v6 + 184) + v7 < a2 + *(_DWORD *)(v6 + 160);
  }
  else
  {
    v8 = a2;
    v9 = 0;
  }
  v10 = v9 < v8 ? v8 - v9 : 0;
  v32 = v9;
  if ( !v9 || (v42 = 1, v8) )
    v42 = 0;
  if ( !a4 || (v43 = 1, v9) )
    v43 = 0;
  v29 = -1;
  v39 = -1;
  v40 = 0;
  if ( a4 )
    v37 = sub_1003D49E(*(_DWORD *)(v6 + 12), v6, 0);
  else
    v37 = -1;
  v34 = 0;
  if ( v10
    && ((v11 = *(_DWORD *)(v6 + 164), v10 > v11) ? (v12 = *(_DWORD *)(v6 + 164) * *(_DWORD *)(v6 + 144)
                                                        + (*(_DWORD *)(v6 + 144) - 1) * (v10 - v11)) : (v12 = v10 * *(_DWORD *)(v6 + 144)),
        v34 = v12,
        v12) )
  {
    _ECX = 0;
    v14 = 4i64 * (unsigned int)v12;
    __asm { seto    cl }
    v4 = (_DWORD)v14 | (unsigned int)-_ECX;
    v33 = sub_1002965B(SHIDWORD(v14), v4, SHIDWORD(v4), v10, v4);
  }
  else
  {
    v33 = 0;
  }
  v15 = a2;
  v17 = a4 == 0;
  v31 = 0;
  v44 = a4 == 0;
  v18 = 0;
  v16 = 0;
  for ( i = 0; ; i = v16 )
  {
    v41 = v18;
    if ( v38 >= v15 )
    {
      if ( v17 )
        break;
    }
    if ( v18 >= *(_DWORD *)(v6 + 192) )
      break;
    LODWORD(v4) = v16 + *(_DWORD *)(v6 + 16);
    v30 = v4;
    if ( *(_DWORD *)(v4 + 24) > HIDWORD(v4) || *(_DWORD *)(v4 + 28) > HIDWORD(v4) )
    {
      v19 = HIDWORD(v4);
      for ( j = HIDWORD(v4); ; j += 52 )
      {
        v36 = v19;
        if ( v38 >= v15 && v44 || (unsigned int)v19 >= *(_DWORD *)(v4 + 4) )
        {
          v16 = i;
          *(_DWORD *)(v4 + 24) = HIDWORD(v4);
          goto LABEL_64;
        }
        v20 = j + *(_DWORD *)(v4 + 48);
        v27 = v20;
        if ( *(_DWORD *)v20 == 3 )
          break;
        if ( *(_DWORD *)v20 != 4 )
          goto LABEL_49;
        if ( v43 )
        {
          v25 = *(_DWORD *)(v20 + 36) + *(_DWORD *)(v20 + 44);
          if ( v25 < (unsigned int)v29 || v25 == v29 && v41 == v37 )
          {
            v29 = *(_DWORD *)(v20 + 36) + *(_DWORD *)(v20 + 44);
            v40 = v4;
            v39 = v19;
          }
          goto LABEL_48;
        }
        if ( !v42 || *(_DWORD *)(v20 + 40) > HIDWORD(v4) )
          goto LABEL_49;
        v18 = v41;
        if ( !v40 || v41 == v37 )
        {
          v15 = a2;
          v40 = v4;
          v39 = v19;
          if ( v41 == v37 )
            v44 = 1;
        }
LABEL_50:
        ++v19;
      }
      if ( v44 || v38 != v15 - 1 && v37 != v41 )
      {
        v21 = BYTE4(v4);
      }
      else
      {
        v21 = 1;
        if ( v32 )
        {
          v22 = BYTE4(v4);
LABEL_38:
          *(_DWORD *)v20 = 4;
          ++*(_DWORD *)(v4 + 28);
          ++*(_DWORD *)(v6 + 160);
          if ( v21 )
          {
            v40 = v4;
            v39 = v36;
            v44 = 1;
          }
          if ( v22 )
          {
            v23 = *(_DWORD *)(v6 + 164);
            v24 = *(_DWORD *)(v6 + 144);
            if ( v23 )
              *(_DWORD *)(v6 + 164) = v23 - 1;
            else
              --v24;
            *(_DWORD *)(v27 + 36) += v24;
            *(_DWORD *)(v6 + 176) += v24;
            if ( v24 )
            {
              do
              {
                *(_DWORD *)(v33 + 4 * v31++) = (*(int (__thiscall **)(int, unsigned int, int))(*(_DWORD *)v6 + 24))(
                                                 v6,
                                                 v30,
                                                 v36);
                --v24;
              }
              while ( v24 );
              v4 = v30;
            }
          }
          ++v38;
          v19 = v36;
LABEL_48:
          v15 = a2;
LABEL_49:
          v18 = v41;
          goto LABEL_50;
        }
      }
      v22 = 1;
      goto LABEL_38;
    }
LABEL_64:
    v17 = v44;
    ++v18;
    v16 += 52;
  }
  if ( v34 )
  {
    sub_1004C056(v33, v34);
    sub_10030383((LPVOID)v33);
  }
  if ( a4 )
  {
    if ( !v43 )
    {
      if ( v42 )
      {
        sub_1004CAB7(ebp0, v40, v39);
        *(_DWORD *)(52 * v39 + *(_DWORD *)(v40 + 48)) = 4;
        ++*(_DWORD *)(v40 + 28);
        ++*(_DWORD *)(v6 + 160);
      }
    }
    HIDWORD(v4) = sub_1004C269(v40, ebp0, v40, v39);
  }
  return HIDWORD(v4);
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);
// 1004C056: using guessed type _DWORD __stdcall sub_1004C056(_DWORD, _DWORD);

//----- (1004C91D) --------------------------------------------------------
int __thiscall sub_1004C91D(int this, int a2)
{
  int result; // eax@1
  int v3; // edi@1
  int v11; // ecx@2

  v3 = this;
  _ECX = *(_DWORD *)(52 * (**(int (__thiscall ***)(_DWORD))a2)(a2) + *(_DWORD *)(this + 16) + 48)
       + 52 * *(_DWORD *)(a2 + 40)
       + 24;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  result = _EAX + 1;
  if ( result == 1 )
  {
    v11 = *(_DWORD *)(v3 + 12);
    result = *(_DWORD *)(v3 + 132) == *(_DWORD *)(v3 + 128);
    if ( *(_DWORD *)(v11 + 16) > (unsigned int)result )
      result = SetEvent(*(HANDLE *)(v11 + 80));
  }
  return result;
}

//----- (1004C979) --------------------------------------------------------
int __thiscall sub_1004C979(int this, int a2, int a3, char a4)
{
  int result; // eax@1
  int v5; // edx@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // ecx@1
  int v10; // [sp+14h] [bp+8h]@1

  v5 = 52 * a3;
  v6 = 52 * a2;
  v8 = this;
  v10 = 52 * a3;
  v7 = 52 * a3 + *(_DWORD *)(*(_DWORD *)(this + 16) + v6 + 48);
  v9 = *(_DWORD *)(v7 + 40);
  result = v9 + 1;
  *(_DWORD *)(v7 + 40) = v9 + 1;
  if ( v9 )
    goto LABEL_7;
  result = v6 + *(_DWORD *)(v8 + 16);
  ++*(_DWORD *)(result + 36);
  ++*(_DWORD *)(v8 + 172);
  if ( *(_BYTE *)(v7 + 49) )
  {
    *(_BYTE *)(v7 + 50) = 1;
    result = sub_1004CC9B(v8, result, a3);
    v5 = v10;
  }
  if ( a4 )
  {
    result = *(_DWORD *)(*(_DWORD *)(v8 + 16) + v6 + 48);
    if ( !*(_DWORD *)(result + v5 + 36) )
      ++*(_DWORD *)(v8 + 184);
LABEL_7:
    if ( a4 )
    {
      ++*(_DWORD *)(v8 + 180);
      ++*(_DWORD *)(v7 + 44);
    }
  }
  return result;
}

//----- (1004C9FB) --------------------------------------------------------
int __usercall sub_1004C9FB<eax>(int a1<ecx>, int a2<ebp>)
{
  LPVOID v2; // eax@1
  int v3; // esi@1
  int v4; // eax@2
  int v5; // eax@4
  int v6; // eax@7
  int v7; // edi@7
  int v8; // esi@7
  int v9; // esi@7

  v2 = TlsGetValue(*(_DWORD *)(*(_DWORD *)(a1 + 12) + 112));
  v3 = (int)v2;
  if ( !v2 )
    return 0;
  v4 = (_BYTE)v2 & 3;
  if ( !v4 )
  {
LABEL_6:
    sub_1004B4CD(v3);
    goto LABEL_12;
  }
  if ( v4 == 1 )
  {
    v3 = *(_DWORD *)((v3 & 0xFFFFFFFE) + 0x10) + 8;
    v5 = *(_DWORD *)(v3 + 28);
    if ( v5 && *(_BYTE *)(v5 + 68) )
      return 0;
    goto LABEL_6;
  }
  v8 = v3 & 0xFFFFFFFD;
  v7 = v8 + 4;
  (*(void (__thiscall **)(int))(*(_DWORD *)(v8 + 4) + 16))(v8 + 4);
  v9 = *(_DWORD *)(v8 + 32);
  v6 = *(_DWORD *)(v9 + 44);
  v3 = v9 + 16;
  if ( v6 && *(_BYTE *)(v6 + 68) )
    v3 = 0;
  else
    sub_1004B4CD(v3);
  (*(void (__thiscall **)(int))(*(_DWORD *)v7 + 20))(v7);
LABEL_12:
  if ( v3 )
    return sub_1004C5F1(a2, v3);
  return 0;
}

//----- (1004CA81) --------------------------------------------------------
int __thiscall sub_1004CA81(int this, int a2)
{
  int result; // eax@1

  --*(_DWORD *)this;
  *(_DWORD *)(*(_DWORD *)(a2 + 56) + 52) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(*(_DWORD *)(a2 + 52) + 56) = *(_DWORD *)(a2 + 56);
  result = *(_DWORD *)(this + 4);
  if ( a2 == result )
  {
    if ( result == *(_DWORD *)(result + 56) )
      result = 0;
    else
      result = *(_DWORD *)(result + 52);
    *(_DWORD *)(this + 4) = result;
  }
  return result;
}

//----- (1004CAB7) --------------------------------------------------------
int __userpurge sub_1004CAB7<eax>(int a1<ebp>, int a2, int a3)
{
  int v3; // ecx@1
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // ecx@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // eax@5
  int v10; // eax@6
  int v11; // ecx@12
  int v13; // [sp-Ch] [bp-Ch]@16
  signed int v14; // [sp-4h] [bp-4h]@1

  v14 = 4;
  sub_10035668();
  v4 = v6;
  v3 = *(_DWORD *)(a1 + 8);
  v7 = 52 * *(_DWORD *)(a1 + 12);
  --*(_DWORD *)(v3 + 28);
  --*(_DWORD *)(v4 + 160);
  v5 = *(_DWORD *)(v3 + 48) + v7;
  v8 = *(_DWORD *)(v5 + 36);
  *(_DWORD *)v5 = 1;
  if ( v8 == *(_DWORD *)(v4 + 144) )
    ++*(_DWORD *)(v4 + 164);
  *(_DWORD *)(v4 + 176) -= *(_DWORD *)(v5 + 36);
  *(_DWORD *)(v5 + 36) = 0;
  if ( *(_BYTE *)(v5 + 49) )
    sub_1004CC9B(v4, v3, *(_DWORD *)(a1 + 12));
  *(_BYTE *)(v5 + 48) = 0;
  *(_DWORD *)(a1 - 16) = v4 + 32;
  sub_1002B91E((LPCRITICAL_SECTION)(v4 + 32));
  v9 = *(_DWORD *)(v5 + 16);
  *(_DWORD *)(a1 - 4) = 0;
  if ( v9 )
    v10 = *(_DWORD *)(v9 + 56);
  else
    v10 = 0;
  for ( ; v10; v10 = *(_DWORD *)(a1 + 12) )
  {
    if ( v10 == *(_DWORD *)(v5 + 16) )
      *(_DWORD *)(a1 + 12) = 0;
    else
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(v10 + 56);
    v11 = *(_DWORD *)(v10 + 28);
    if ( v11 )
    {
      if ( !*(_BYTE *)(v11 + 68) )
      {
        *(_BYTE *)(v11 + 68) = 1;
        *(_DWORD *)(a1 + 8) = v11;
        (*(void (__cdecl **)(int, signed int, signed int))(**(_DWORD **)(v4 + 8) + 16))(a1 + 8, 1, v14);
      }
    }
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002BB53((LPCRITICAL_SECTION)(v4 + 32));
  return sub_10035636(v13);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1004CB86) --------------------------------------------------------
int __thiscall sub_1004CB86(void *this, void *a2)
{
  int result; // eax@1

  result = sub_1004CA81((int)((char *)this + 196), (int)a2);
  if ( a2 )
  {
    *(_DWORD *)a2 = off_10066148;
    result = sub_1002A4AA(a2);
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10066148: using guessed type int (*off_10066148[2])();

//----- (1004CBAF) --------------------------------------------------------
int __thiscall sub_1004CBAF(int this, int a2)
{
  int ebp0; // ebp@0

  return sub_1003EB04(ebp0, this, a2);
}

//----- (1004CBC2) --------------------------------------------------------
#error "1004CC7F: call analysis failed (funcsize=77)"

//----- (1004CC87) --------------------------------------------------------
int __thiscall sub_1004CC87(int this)
{
  return sub_1003F3CF(*(_DWORD *)(this + 12), this);
}

//----- (1004CC91) --------------------------------------------------------
int __usercall sub_1004CC91<eax>(int a1<ecx>, int a2<ebp>)
{
  return sub_1003F488(a2, a1);
}

//----- (1004CC9B) --------------------------------------------------------
int __thiscall sub_1004CC9B(int this, int a2, int a3)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 + 48) + 52 * a3;
  if ( *(_BYTE *)(result + 49) )
  {
    --*(_DWORD *)(this + 168);
    --*(_DWORD *)(a2 + 32);
    *(_BYTE *)(result + 49) = 0;
  }
  else
  {
    ++*(_DWORD *)(this + 168);
    ++*(_DWORD *)(a2 + 32);
    *(_BYTE *)(result + 49) = 1;
  }
  return result;
}

//----- (1004CCD0) --------------------------------------------------------
int __stdcall sub_1004CCD0(int a1)
{
  int v2; // eax@2
  int (__stdcall **v3)(char); // [sp+0h] [bp-Ch]@3

  if ( !a1 )
  {
    a1 = (int)"pContext";
    sub_1002AEA4((int)&v3, &a1);
    v3 = &off_100602FC;
    sub_100355DB((int)&v3, (int)&unk_1006D8F4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1004CD16);
  }
  v2 = (*(int (**)(void))(*(_DWORD *)a1 + 8))();
  return sub_10054064(v2);
}
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);

//----- (1004CD16) --------------------------------------------------------
int __cdecl sub_1004CD16(int a1)
{
  int v1; // eax@2
  int v2; // eax@4
  HMODULE v3; // eax@4
  int v4; // eax@7
  HMODULE v5; // eax@7
  int result; // eax@8
  int v7; // eax@10
  int v8; // ST04_4@10
  int *v9; // [sp+0h] [bp-18h]@10
  int v10; // [sp+4h] [bp-14h]@10
  char v11; // [sp+8h] [bp-10h]@10
  int v12; // [sp+Ch] [bp-Ch]@10
  int v13; // [sp+10h] [bp-8h]@10
  int v14; // [sp+14h] [bp-4h]@10
  int v15; // [sp+18h] [bp+0h]@10

  dword_100772D8 = (int)LoadLibraryExW(L"combase.dll", 0, 0x800u);
  if ( dword_100772D8 )
  {
    v3 = GetModuleHandleW(L"combase.dll");
    v2 = (int)GetProcAddress(v3, "RoInitialize");
    if ( v2 )
    {
      dword_100772D0 = sub_1003491A(v2);
      v5 = GetModuleHandleW(L"combase.dll");
      v4 = (int)GetProcAddress(v5, "RoUninitialize");
      if ( v4 )
      {
        dword_100772D4 = sub_1003491A(v4);
        result = unk_100772DC;
        unk_100772DC = 1;
        return result;
      }
    }
    v1 = GetLastError();
    if ( v1 > 0 )
      goto LABEL_9;
  }
  else
  {
    v1 = GetLastError();
    if ( v1 > 0 )
    {
LABEL_9:
      v1 = (unsigned __int16)v1 | 0x80070000;
      goto LABEL_10;
    }
  }
LABEL_10:
  sub_10030079((int)&v11, v1);
  sub_100355DB((int)&v11, (int)&unk_1006C6F4);
  __asm { int     3               ; Trap to Debugger }
  v9 = &v15;
  v7 = sub_1003491A(dword_100772D0);
  return ((int (__thiscall *)(int, int, int *, int, _DWORD, int, int, int))v7)(
           v8,
           a1,
           v9,
           v10,
           *(_DWORD *)&v11,
           v12,
           v13,
           v14);
}
// 100772D0: using guessed type int dword_100772D0;
// 100772D4: using guessed type int dword_100772D4;
// 100772D8: using guessed type int dword_100772D8;

//----- (1004CDDB) --------------------------------------------------------
int __cdecl sub_1004CDDB()
{
  int v1; // eax@1
  int v2; // ST00_4@1

  v1 = sub_1003491A(dword_100772D4);
  return ((int (__thiscall *)(int))v1)(v2);
}
// 100772D4: using guessed type int dword_100772D4;

//----- (1004CDE9) --------------------------------------------------------
int __thiscall sub_1004CDE9(int this, int a2)
{
  signed int v2; // ebx@1
  int v3; // edi@1
  union _SLIST_HEADER *v4; // esi@1

  v3 = this;
  *(_DWORD *)this = &off_10066238;
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 8);
  v4 = (union _SLIST_HEADER *)(this + 8);
  v2 = 3;
  do
  {
    InitializeSListHead(v4);
    ++v4;
    --v2;
  }
  while ( v2 >= 0 );
  return v3;
}
// 10066238: using guessed type int (__stdcall *off_10066238)(int, int);

//----- (1004CE1C) --------------------------------------------------------
void *__thiscall sub_1004CE1C(void *this, int a2, int a3)
{
  void *v4; // esi@1

  v4 = this;
  sub_100545AB(this, a2, a3);
  *(_DWORD *)v4 = &off_100661F0;
  *((_DWORD *)v4 + 12) = 0;
  *((_DWORD *)v4 + 13) = 0;
  *((_DWORD *)v4 + 14) = 0;
  *((_DWORD *)v4 + 12) = 0;
  *((_WORD *)v4 + 26) = 0;
  return v4;
}
// 100661F0: using guessed type int (*off_100661F0)();

//----- (1004CE4D) --------------------------------------------------------
int __thiscall sub_1004CE4D(int this, int a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1004CDE9(this, a2);
  *(_DWORD *)v3 = &off_10066264;
  *(_DWORD *)(v3 + 40) = 1;
  *(_BYTE *)(v3 + 44) = 0;
  return v3;
}
// 10066264: using guessed type int (__stdcall *off_10066264)(int, int);

//----- (1004CE73) --------------------------------------------------------
int __usercall sub_1004CE73<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int v2; // esi@1
  DWORD v3; // eax@1
  int v4; // eax@2

  sub_10035668();
  v2 = v1;
  *(_DWORD *)(a1 - 16) = v1;
  *(_DWORD *)v1 = 0;
  *(_DWORD *)(v1 + 4) = 0;
  sub_1002B519((LPCRITICAL_SECTION)(v1 + 12));
  *(_DWORD *)(a1 - 4) = 0;
  v3 = TlsAlloc();
  *(_DWORD *)(v2 + 8) = v3;
  if ( v3 == -1 )
  {
    v4 = GetLastError();
    if ( v4 > 0 )
      v4 = (unsigned __int16)v4 | 0x80070000;
    sub_10030079(a1 - 32, v4);
    sub_100355DB(a1 - 32, (int)&unk_1006C6F4);
  }
  return sub_10035636(20);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1004CED6) --------------------------------------------------------
int __usercall sub_1004CED6<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // ecx@3
  signed int v6; // [sp-4h] [bp-4h]@1

  v6 = 4;
  sub_10035668();
  v2 = v3;
  *(_DWORD *)(a1 - 16) = v3;
  v1 = *(_DWORD *)v3;
  *(_DWORD *)(a1 - 4) = 0;
  if ( v1 )
    (*(void (__cdecl **)(signed int))(*(_DWORD *)v1 + 24))(4);
  v4 = *(_DWORD *)(v2 + 4);
  if ( v4 )
    (*(void (__cdecl **)(signed int))(*(_DWORD *)v4 + 24))(v6);
  TlsFree(*(_DWORD *)(v2 + 8));
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002B6CE((LPCRITICAL_SECTION)(v2 + 12));
  return sub_10035636(v6);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1004CF1D) --------------------------------------------------------
void *__thiscall sub_1004CF1D(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_1006620C;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1006620C: using guessed type int (*off_1006620C[5])();

//----- (1004CF3D) --------------------------------------------------------
void *__thiscall sub_1004CF3D(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_100661F0;
  sub_100546AB((int)this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100661F0: using guessed type int (*off_100661F0)();

//----- (1004CF62) --------------------------------------------------------
int __userpurge sub_1004CF62<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4)
{
  int v4; // ecx@1
  int v5; // esi@1
  int v6; // ecx@1
  int v7; // edx@1

  sub_10035668();
  v5 = v6;
  v4 = sub_1002ADB1(v7, v6, a1, a3, 68);
  *(_DWORD *)(a2 - 16) = v4;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v4 )
    sub_1004CE1C((void *)v4, v5, *(_DWORD *)(a2 + 8));
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1004CF97) --------------------------------------------------------
int __usercall sub_1004CF97<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // eax@1
  int v4; // edx@1
  int v5; // ecx@1
  int result; // eax@2

  sub_1004D216();
  v3 = sub_1002ADB1(v4, v5, a1, a2, 48);
  if ( v3 )
    result = sub_1004CE4D(v3, a3);
  else
    result = 0;
  return result;
}

//----- (1004CFBB) --------------------------------------------------------
int __thiscall sub_1004CFBB(int this)
{
  return *(_DWORD *)(this + 4);
}

//----- (1004CFBF) --------------------------------------------------------
int __usercall sub_1004CFBF<eax>(int a1<ebx>, int a2<ebp>)
{
  int v2; // ecx@1
  int v3; // edi@1

  sub_10035668();
  v3 = v2;
  if ( !*(_DWORD *)v2 )
  {
    *(_DWORD *)(a2 - 16) = v2 + 12;
    sub_1002B91E((LPCRITICAL_SECTION)(v2 + 12));
    *(_DWORD *)(a2 - 4) = 0;
    if ( !*(_DWORD *)v3 )
      *(_DWORD *)v3 = sub_1004CF97(a1, v3, v3);
    *(_DWORD *)(a2 - 4) = -1;
    sub_1002BB53((LPCRITICAL_SECTION)(v3 + 12));
  }
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);

//----- (1004D004) --------------------------------------------------------
BOOL __stdcall sub_1004D004(int a1, int nPriority)
{
  BOOL result; // eax@1

  result = nPriority;
  if ( *(_DWORD *)(a1 + 24) != nPriority )
    result = sub_1005470D(a1, nPriority);
  return result;
}

//----- (1004D01C) --------------------------------------------------------
__int16 __thiscall sub_1004D01C(void *this, int a2)
{
  signed int v2; // eax@1
  void *v3; // edi@1
  int v4; // esi@1
  union _SLIST_HEADER *v5; // ebx@5

  v4 = a2;
  v3 = this;
  v2 = 0;
  while ( *(_DWORD *)(a2 + 20) != dword_10066224[v2] )
  {
    ++v2;
    if ( v2 >= 4 )
      goto LABEL_7;
  }
  v5 = (union _SLIST_HEADER *)(this + 8 * v2 + 8);
  LOWORD(v2) = QueryDepthSList((PSLIST_HEADER)this + v2 + 1);
  if ( (unsigned __int16)v2 < dword_100772E4 )
  {
    LOWORD(v2) = (unsigned int)InterlockedPushEntrySList(v5, (PSINGLE_LIST_ENTRY)(a2 + 60));
    v4 = 0;
  }
LABEL_7:
  if ( v4 )
    LOWORD(v2) = (*(int (__thiscall **)(void *, int))(*(_DWORD *)v3 + 32))(v3, v4);
  return v2;
}
// 10066224: using guessed type int dword_10066224[];
// 100772E4: using guessed type int dword_100772E4;

//----- (1004D075) --------------------------------------------------------
void __thiscall sub_1004D075(int this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  signed int v4; // eax@2
  union _SLIST_HEADER *v5; // ebx@6
  int v6; // edx@8
  PSINGLE_LIST_ENTRY v7; // eax@8
  int v8; // esi@9

  v3 = a2;
  v2 = this;
  if ( !*(_BYTE *)(this + 44) )
  {
    v4 = 0;
    while ( *(_DWORD *)(a2 + 20) != dword_10066224[v4] )
    {
      ++v4;
      if ( v4 >= 4 )
        goto LABEL_11;
    }
    v5 = (union _SLIST_HEADER *)(this + 8 + 8 * v4);
    if ( QueryDepthSList((PSLIST_HEADER)(this + 8 + 8 * v4)) < dword_100772E4 )
    {
      InterlockedPushEntrySList(v5, (PSINGLE_LIST_ENTRY)(a2 + 60));
      if ( *(_BYTE *)(v2 + 44) )
      {
        v7 = InterlockedFlushSList(v5);
        v6 = v7 != 0 ? (int)&v7[-15] : 0;
        if ( v7 != 0 ? (int)&v7[-15] : 0 )
        {
          do
          {
            v8 = *(_DWORD *)(v6 + 60);
            (*(void (__thiscall **)(int, int))(*(_DWORD *)v2 + 32))(v2, v6);
            v6 = v8 != 0 ? v8 - 60 : 0;
          }
          while ( v8 != 0 ? v8 - 60 : 0 );
        }
      }
      v3 = 0;
    }
  }
LABEL_11:
  if ( v3 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v2 + 32))(v2, v3);
}
// 10066224: using guessed type int dword_10066224[];
// 100772E4: using guessed type int dword_100772E4;

//----- (1004D106) --------------------------------------------------------
int __thiscall sub_1004D106(void *this)
{
  _ECX = (int)((char *)this + 40);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return _EAX + 1;
}

//----- (1004D112) --------------------------------------------------------
int __thiscall sub_1004D112(void *this)
{
  int v1; // esi@1

  _EAX = (int)((char *)this + 40);
  _ESI = -1;
  __asm { lock xadd [eax], esi }
  v1 = _ESI - 1;
  if ( !v1 )
  {
    if ( this )
      (*(void (__stdcall **)(signed int))(*(_DWORD *)this + 20))(1);
  }
  return v1;
}

//----- (1004D12F) --------------------------------------------------------
int __thiscall sub_1004D12F(void *this, unsigned int a2, int a3)
{
  union _SLIST_HEADER *v3; // eax@1
  unsigned int v4; // ecx@1
  signed int v5; // ebx@1
  void *v6; // edi@1
  int v7; // esi@1
  PSINGLE_LIST_ENTRY v8; // eax@3
  int v10; // [sp+Ch] [bp-4h]@1

  v6 = this;
  v4 = a2;
  v3 = (union _SLIST_HEADER *)((char *)v6 + 8);
  v7 = 0;
  v5 = (signed int)dword_10066224;
  v10 = (int)((char *)v6 + 8);
  do
  {
    if ( v4 <= *(_DWORD *)v5 )
    {
      v8 = InterlockedPopEntrySList(v3);
      v7 = v8 != 0 ? (int)&v8[-15] : 0;
      if ( v7 )
        goto LABEL_8;
      v3 = (union _SLIST_HEADER *)v10;
      v4 = a2;
    }
    v5 += 4;
    ++v3;
    v10 = (int)v3;
  }
  while ( v5 < (signed int)&off_10066234 );
  if ( v7 || (v7 = (*(int (__thiscall **)(void *, unsigned int))(*(_DWORD *)v6 + 28))(v6, v4)) != 0 )
LABEL_8:
    (*(void (__thiscall **)(void *, int, int))(*(_DWORD *)v6 + 36))(v6, v7, a3);
  return v7;
}
// 10066224: using guessed type int dword_10066224[];
// 10066234: using guessed type void *off_10066234;

//----- (1004D19D) --------------------------------------------------------
BOOL __stdcall sub_1004D19D(int a1)
{
  return sub_100546EE(a1);
}

//----- (1004D1AC) --------------------------------------------------------
PSINGLE_LIST_ENTRY __thiscall sub_1004D1AC(void *this)
{
  signed int v1; // ebx@1
  union _SLIST_HEADER *v2; // edi@1
  PSINGLE_LIST_ENTRY result; // eax@2
  int v4; // edx@2
  int v5; // esi@3
  void *v6; // [sp+Ch] [bp-8h]@1
  signed int v7; // [sp+10h] [bp-4h]@1

  v1 = 4;
  v6 = this;
  v2 = (union _SLIST_HEADER *)((char *)this + 8);
  v7 = 4;
  do
  {
    result = InterlockedFlushSList(v2);
    v4 = result != 0 ? (int)&result[-15] : 0;
    if ( result != 0 ? (int)&result[-15] : 0 )
    {
      do
      {
        v5 = *(_DWORD *)(v4 + 60);
        (*(void (__thiscall **)(void *, int))(*(_DWORD *)v6 + 32))(v6, v4);
        result = (PSINGLE_LIST_ENTRY)(v5 - 60);
        v4 = v5 != 0 ? v5 - 60 : 0;
      }
      while ( v5 != 0 ? v5 - 60 : 0 );
      v1 = v7;
    }
    ++v2;
    --v1;
    v7 = v1;
  }
  while ( v1 );
  return result;
}

//----- (1004D202) --------------------------------------------------------
int __thiscall sub_1004D202(int this)
{
  int v2; // esi@1

  v2 = this;
  *(_BYTE *)(this + 44) = 1;
  sub_1004D1AC((void *)this);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 12))(v2);
}

//----- (1004D216) --------------------------------------------------------
void __cdecl sub_1004D216()
{
  if ( !dword_100772E4 )
    dword_100772E4 = 4 * sub_1003D69A();
}
// 100772E4: using guessed type int dword_100772E4;

//----- (1004D276) --------------------------------------------------------
int __usercall sub_1004D276<eax>(double a1<st0>)
{
  int result; // eax@1
  float v2; // edx@1
  float v3; // ST18_4@1
  double v4; // st7@2
  float v5; // ST00_4@3
  float v6; // ST00_4@4
  signed __int64 v7; // [sp+10h] [bp-10h]@1

  v3 = a1;
  v7 = (signed __int64)a1;
  v2 = v3;
  result = (signed __int64)a1;
  if ( result || (LODWORD(v2) = HIDWORD(v7), HIDWORD(v7) & 0x7FFFFFFF) )
  {
    v4 = a1 - (double)(signed __int64)a1;
    if ( LODWORD(v2) >= 0 )
    {
      v6 = v4;
      result -= LODWORD(v6) >= 0x80000001u;
    }
    else
    {
      v5 = v4;
      result += (LODWORD(v5) ^ 0x80000000u) >= 0x80000001;
    }
  }
  return result;
}

//----- (1004D2F0) --------------------------------------------------------
int __usercall sub_1004D2F0<eax>(unsigned int a1<eax>, int a2<ecx>)
{
  unsigned int i; // eax@1
  int v3; // ecx@1
  int v5; // [sp-4h] [bp-4h]@1
  void *v6; // [sp+0h] [bp+0h]@1
  int v7; // [sp+0h] [bp+0h]@3

  v5 = a2;
  v3 = (unsigned int)&v6 >= a1 ? (int)((char *)&v6 - a1) : 0;
  for ( i = (unsigned int)&v5 & 0xFFFFF000; v3 < i; i -= 4096 )
    ;
  return v7;
}

//----- (1004D31B) --------------------------------------------------------
signed int __usercall sub_1004D31B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6)
{
  int v6; // ecx@2
  int v7; // edx@3
  int v8; // eax@5
  signed int result; // eax@6
  int v10; // esi@8
  int v11; // esi@12
  __int16 v12; // ax@13
  signed int v13; // [sp-4h] [bp-Ch]@5

  if ( !a4 || (v6 = a5, !a5) )
    goto LABEL_5;
  v7 = a6;
  if ( !a6 )
    goto LABEL_19;
  v10 = a4;
  do
  {
    if ( !*(_WORD *)v10 )
      break;
    v10 += 2;
    --v6;
  }
  while ( v6 );
  if ( !v6 )
  {
LABEL_19:
    *(_WORD *)a4 = 0;
LABEL_5:
    v8 = sub_10037669(a3);
    v13 = 22;
LABEL_6:
    *(_DWORD *)v8 = v13;
    sub_1003A16E(a3, a4);
    return v13;
  }
  v11 = v10 - a6;
  do
  {
    v12 = *(_WORD *)v7;
    *(_WORD *)(v11 + v7) = *(_WORD *)v7;
    v7 += 2;
    if ( !v12 )
      break;
    --v6;
  }
  while ( v6 );
  result = 0;
  if ( !v6 )
  {
    *(_WORD *)a4 = 0;
    v8 = sub_10037669(a3);
    v13 = 34;
    goto LABEL_6;
  }
  return result;
}

//----- (1004D387) --------------------------------------------------------
signed int __usercall sub_1004D387<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5)
{
  int v5; // ecx@4

  if ( a5 >= 0 )
  {
    if ( a5 <= 2 )
    {
      v5 = dword_100772E8;
      dword_100772E8 = a5;
      return v5;
    }
    if ( a5 == 3 )
      return dword_100772E8;
  }
  *(_DWORD *)sub_10037669(a3) = 22;
  sub_1003A16E(a3, a4);
  return -1;
}
// 100772E8: using guessed type int dword_100772E8;

//----- (1004D3C7) --------------------------------------------------------
int __cdecl sub_1004D3C7(const WCHAR *a1, int a2, int a3)
{
  int v3; // edi@1
  PVOID v4; // esi@1
  int v5; // eax@1
  HMODULE v6; // esi@2
  FARPROC v7; // eax@5
  FARPROC v8; // eax@6
  FARPROC v9; // eax@6
  FARPROC v10; // eax@6
  FARPROC v11; // eax@7
  PVOID v13; // eax@19
  int v14; // eax@21
  int v15; // esi@24
  int (*v16)(void); // eax@26
  PVOID v17; // eax@29
  PVOID v18; // eax@32
  char v20; // [sp+Ch] [bp-24h]@22
  int v21; // [sp+10h] [bp-20h]@1
  LPCWSTR lpOutputString; // [sp+14h] [bp-1Ch]@1
  PVOID v23; // [sp+18h] [bp-18h]@1
  int (*v24)(void); // [sp+1Ch] [bp-14h]@1
  char v25; // [sp+20h] [bp-10h]@22
  char v26; // [sp+28h] [bp-8h]@23
  unsigned int v27; // [sp+2Ch] [bp-4h]@1
  int v28; // [sp+30h] [bp+0h]@1

  v27 = (unsigned int)&v28 ^ __security_cookie;
  lpOutputString = a1;
  v3 = 0;
  v21 = a2;
  v4 = EncodePointer(0);
  v23 = v4;
  LOBYTE(v5) = sub_100395BA();
  v24 = (int (*)(void))v5;
  if ( !dword_100772EC )
  {
    v6 = LoadLibraryExW(L"USER32.DLL", 0, 0x800u);
    if ( !v6 && (GetLastError() != 87 || (v6 = LoadLibraryW(L"USER32.DLL"), !v6))
      || (v7 = GetProcAddress(v6, "MessageBoxW"), !v7) )
      return 0;
    dword_100772EC = EncodePointer(v7);
    v8 = GetProcAddress(v6, "GetActiveWindow");
    dword_100772F0 = EncodePointer(v8);
    v9 = GetProcAddress(v6, "GetLastActivePopup");
    dword_100772F4 = EncodePointer(v9);
    v10 = GetProcAddress(v6, "GetUserObjectInformationW");
    dword_100772FC = EncodePointer(v10);
    if ( dword_100772FC )
    {
      v11 = GetProcAddress(v6, "GetProcessWindowStation");
      dword_100772F8 = EncodePointer(v11);
    }
    v4 = v23;
  }
  if ( IsDebuggerPresent() )
  {
    if ( lpOutputString )
      OutputDebugStringW(lpOutputString);
    if ( v24 )
      return 4;
  }
  else
  {
    if ( v24 )
    {
      DecodePointer(dword_100772EC);
      return 3;
    }
  }
  if ( dword_100772F8 == v4
    || dword_100772FC == v4
    || (v24 = (int (*)(void))DecodePointer(dword_100772F8), v13 = DecodePointer(dword_100772FC), v23 = v13, !v24)
    || !v13
    || (v14 = v24()) != 0
    && ((int (__stdcall *)(int, signed int, char *, signed int, char *))v23)(v14, 1, &v25, 12, &v20)
    && v26 & 1 )
  {
    if ( dword_100772F0 != v4 )
    {
      v16 = (int (*)(void))DecodePointer(dword_100772F0);
      if ( v16 )
      {
        v3 = v16();
        if ( v3 )
        {
          if ( dword_100772F4 != v4 )
          {
            v17 = DecodePointer(dword_100772F4);
            if ( v17 )
              v3 = ((int (__stdcall *)(int))v17)(v3);
          }
        }
      }
    }
    v15 = a3;
  }
  else
  {
    v15 = a3 | 0x200000;
  }
  v18 = DecodePointer(dword_100772EC);
  if ( v18 )
    return ((int (__stdcall *)(int, LPCWSTR, int, int))v18)(v3, lpOutputString, v21, v15);
  return 0;
}
// 10074200: using guessed type int __security_cookie;

//----- (1004D5A9) --------------------------------------------------------
int __usercall sub_1004D5A9<eax>(int a1<edi>, int a2, int a3, LCTYPE a4, LPSTR lpMultiByteStr, int cbMultiByte)
{
  int v6; // eax@1
  int v7; // ecx@1
  int v8; // ebx@1
  int v9; // esi@1
  unsigned int v11; // eax@5
  char *v12; // edi@6
  int v13; // eax@8
  int v14; // edi@10
  CHAR *v15; // [sp-10h] [bp-24h]@15
  int v16; // [sp-Ch] [bp-20h]@15
  char v17; // [sp+0h] [bp-14h]@6
  UINT CodePage; // [sp+Ch] [bp-8h]@1
  unsigned int v19; // [sp+10h] [bp-4h]@1
  int v20; // [sp+14h] [bp+0h]@1

  v19 = (unsigned int)&v20 ^ __security_cookie;
  v9 = 0;
  CodePage = *(_DWORD *)(*(_DWORD *)a2 + 4);
  v6 = sub_10039CAE(a3, a4, 0, 0);
  v8 = v6;
  if ( !v6 )
    return 0;
  if ( v6 > 0 && 0xFFFFFFE0u / v6 >= 2 )
  {
    v11 = 2 * v6 + 8;
    if ( v11 > 0x400 )
    {
      v13 = sub_10030910(0xFFFFFFE0u % v8, v7, v8, a1, 2 * v8 + 8);
      v12 = (char *)v13;
      if ( v13 )
      {
        *(_DWORD *)v13 = 56797;
        goto LABEL_10;
      }
    }
    else
    {
      sub_1003F590(v11, v7, v17);
      v12 = &v17;
      if ( &v17 )
      {
        *(_DWORD *)&v17 = 52428;
LABEL_10:
        v14 = (int)(v12 + 8);
        goto LABEL_12;
      }
    }
    return 0;
  }
  v14 = 0;
LABEL_12:
  if ( !v14 )
    return 0;
  if ( sub_10039CAE(a3, a4, (WCHAR *)v14, v8) )
  {
    if ( cbMultiByte )
    {
      v16 = cbMultiByte;
      v15 = lpMultiByteStr;
    }
    else
    {
      v16 = 0;
      v15 = 0;
    }
    v9 = WideCharToMultiByte(CodePage, 0, (LPCWSTR)v14, -1, v15, v16, 0, 0);
  }
  sub_1002CAA7(v8, v14);
  return v9;
}
// 10074200: using guessed type int __security_cookie;

//----- (1004D681) --------------------------------------------------------
int __usercall sub_1004D681<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, LCTYPE a5, LPSTR lpMultiByteStr, int cbMultiByte)
{
  int result; // eax@1
  int v8; // [sp+0h] [bp-10h]@1
  int v9; // [sp+8h] [bp-8h]@2
  char v10; // [sp+Ch] [bp-4h]@1

  sub_1003018D((int)&v8, a1, a2, a3);
  result = sub_1004D5A9(a2, (int)&v8, a4, a5, lpMultiByteStr, cbMultiByte);
  if ( v10 )
    *(_DWORD *)(v9 + 112) &= 0xFFFFFFFDu;
  return result;
}

//----- (1004D6B9) --------------------------------------------------------
int __thiscall sub_1004D6B9(int this, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)this = a2 & 0xFFFFFFF;
  *(_DWORD *)(this + 4) = a4;
  *(_DWORD *)(this + 12) = a5;
  *(_DWORD *)(this + 8) = a3;
  return this;
}

//----- (1004D6DE) --------------------------------------------------------
bool __thiscall sub_1004D6DE(int this, char a2)
{
  int v3; // esi@1
  int v4; // eax@1

  v3 = this + 16;
  v4 = sub_10032DDF((int)&a2, *(_DWORD *)(this + 16));
  return sub_1002D215(v3, (int)&a2, v4) != 0;
}

//----- (1004D709) --------------------------------------------------------
char __thiscall sub_1004D709(int this, int a2)
{
  int v2; // eax@1
  int v3; // eax@2
  int v4; // eax@3
  char result; // al@5
  int v6; // eax@7

  v2 = *(_DWORD *)a2 & 0xFFFFFFF;
  if ( !v2 )
    return 1;
  v3 = v2 - 1;
  if ( !v3 )
  {
    v6 = *(_DWORD *)(*(_DWORD *)(this + 12) + 44);
    return v6 == *(_DWORD *)(a2 + 8);
  }
  v4 = v3 - 1;
  if ( !v4 )
  {
    v6 = *(_DWORD *)(this + 8);
    return v6 == *(_DWORD *)(a2 + 8);
  }
  if ( v4 == 1 )
    result = sub_1004D6DE(*(_DWORD *)(this + 12), *(_DWORD *)(a2 + 8));
  else
    result = 0;
  return result;
}

//----- (1004D750) --------------------------------------------------------
char __thiscall sub_1004D750(int this, int a2)
{
  int v2; // eax@1
  int v3; // eax@2
  int v4; // eax@3
  char result; // al@5
  int v6; // eax@6

  v2 = *(_DWORD *)a2 & 0xFFFFFFF;
  if ( v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      v4 = v3 - 1;
      if ( v4 )
      {
        if ( v4 != 1 )
          return 0;
        v6 = *(_DWORD *)(this + 8);
      }
      else
      {
        v6 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 12) + 68) + 48);
      }
    }
    else
    {
      v6 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 12) + 68) + 44);
    }
    result = v6 == *(_DWORD *)(a2 + 8);
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1004D798) --------------------------------------------------------
void __usercall sub_1004D798(int a1<ebx>, int a2)
{
  if ( a2 )
  {
    if ( *(void **)(a2 + 12) != off_10073C64 )
      sub_100309A2(a1, *(LPVOID *)(a2 + 12));
    if ( *(void **)(a2 + 16) != off_10073C68 )
      sub_100309A2(a1, *(LPVOID *)(a2 + 16));
    if ( *(void **)(a2 + 20) != off_10073C6C )
      sub_100309A2(a1, *(LPVOID *)(a2 + 20));
    if ( *(void **)(a2 + 24) != off_10073C70 )
      sub_100309A2(a1, *(LPVOID *)(a2 + 24));
    if ( *(void **)(a2 + 28) != off_10073C74 )
      sub_100309A2(a1, *(LPVOID *)(a2 + 28));
    if ( *(void **)(a2 + 32) != off_10073C78 )
      sub_100309A2(a1, *(LPVOID *)(a2 + 32));
    if ( *(void **)(a2 + 36) != off_10073C7C )
      sub_100309A2(a1, *(LPVOID *)(a2 + 36));
    if ( *(void **)(a2 + 56) != off_10073C90 )
      sub_100309A2(a1, *(LPVOID *)(a2 + 56));
    if ( *(void **)(a2 + 60) != off_10073C94 )
      sub_100309A2(a1, *(LPVOID *)(a2 + 60));
    if ( *(void **)(a2 + 64) != off_10073C98 )
      sub_100309A2(a1, *(LPVOID *)(a2 + 64));
    if ( *(void **)(a2 + 68) != off_10073C9C )
      sub_100309A2(a1, *(LPVOID *)(a2 + 68));
    if ( *(void **)(a2 + 72) != off_10073CA0 )
      sub_100309A2(a1, *(LPVOID *)(a2 + 72));
    if ( *(void **)(a2 + 76) != off_10073CA4 )
      sub_100309A2(a1, *(LPVOID *)(a2 + 76));
  }
}
// 10073C64: using guessed type void *off_10073C64;
// 10073C68: using guessed type void *off_10073C68;
// 10073C6C: using guessed type void *off_10073C6C;
// 10073C70: using guessed type void *off_10073C70;
// 10073C74: using guessed type void *off_10073C74;
// 10073C78: using guessed type void *off_10073C78;
// 10073C7C: using guessed type void *off_10073C7C;
// 10073C90: using guessed type void *off_10073C90;
// 10073C94: using guessed type void *off_10073C94;
// 10073C98: using guessed type void *off_10073C98;
// 10073C9C: using guessed type void *off_10073C9C;
// 10073CA0: using guessed type void *off_10073CA0;
// 10073CA4: using guessed type void *off_10073CA4;

//----- (1004D894) --------------------------------------------------------
signed int __cdecl sub_1004D894(int lpMem)
{
  int v1; // ebx@1
  int v2; // edi@3
  void **v3; // esi@3
  int v4; // edx@4
  LPVOID v5; // esi@4
  int v7; // eax@6
  int v8; // edx@6
  void *v9; // edi@6
  int v10; // eax@10
  int v11; // edi@12
  signed int v12; // esi@12
  int v13; // esi@12
  int v14; // esi@12
  int v15; // esi@12
  int v16; // esi@12
  int v17; // esi@12
  int v18; // esi@12
  int v19; // esi@12
  int v20; // esi@12
  int v21; // esi@12
  int v22; // esi@12
  int v23; // esi@12
  int v24; // esi@12
  int v25; // esi@12
  int v26; // esi@12
  int v27; // esi@12
  int v28; // esi@12
  int v29; // esi@12
  int v30; // esi@12
  int v31; // esi@12
  int v32; // edx@14
  char v33; // al@15
  int v34; // esi@22
  int v35; // [sp-4h] [bp-24h]@4
  int v36; // [sp-4h] [bp-24h]@6
  LPVOID v37; // [sp+Ch] [bp-14h]@1
  int v38; // [sp+10h] [bp-10h]@1
  int v39; // [sp+14h] [bp-Ch]@12
  void *v40; // [sp+18h] [bp-8h]@1
  void *v41; // [sp+1Ch] [bp-4h]@3
  int v42; // [sp+28h] [bp+8h]@4

  v1 = lpMem;
  v40 = 0;
  v37 = (LPVOID)lpMem;
  v38 = 0;
  if ( *(_DWORD *)(lpMem + 172) || *(_DWORD *)(lpMem + 176) )
  {
    v5 = sub_10037506(0, lpMem, 1u, 0x50u);
    v42 = (int)v5;
    if ( !v5 )
      return 1;
    v7 = sub_10037550(v4, v35, v1, 4);
    v9 = (void *)v7;
    v41 = (void *)v7;
    if ( !v7 )
    {
      sub_100309A2(v1, v5);
      return 1;
    }
    *(_DWORD *)v7 = 0;
    if ( !*(_DWORD *)(v1 + 172) )
    {
      memcpy((void *)v42, &off_10073C58, 0x50u);
LABEL_26:
      v3 = (void **)v42;
      *(_DWORD *)v42 = **(_DWORD **)(v1 + 132);
      v2 = (int)v40;
      *(_DWORD *)(v42 + 4) = *(_DWORD *)(*(_DWORD *)(v1 + 132) + 4);
      *(_DWORD *)(v42 + 8) = *(_DWORD *)(*(_DWORD *)(v1 + 132) + 8);
      *(_DWORD *)(v42 + 48) = *(_DWORD *)(*(_DWORD *)(v1 + 132) + 48);
      *(_DWORD *)(v42 + 52) = *(_DWORD *)(*(_DWORD *)(v1 + 132) + 52);
      *(_DWORD *)v41 = 1;
      if ( v2 )
        *(_DWORD *)v2 = 1;
      goto LABEL_28;
    }
    v10 = sub_10037550(v8, v36, v1, 4);
    v40 = (void *)v10;
    if ( !v10 )
    {
      sub_100309A2(v1, v5);
      sub_100309A2(v1, v9);
      return 1;
    }
    *(_DWORD *)v10 = 0;
    v11 = *(_DWORD *)(v1 + 172);
    v12 = sub_1003F7D4((int)&v37, 1, *(_DWORD *)(v1 + 172), 0x15u, (LPVOID *)v5 + 3);
    v13 = sub_1003F7D4((int)&v37, 1, v11, 0x14u, (LPVOID *)(v42 + 16)) | v12;
    v14 = sub_1003F7D4((int)&v37, 1, v11, 0x16u, (LPVOID *)(v42 + 20)) | v13;
    v15 = sub_1003F7D4((int)&v37, 1, v11, 0x17u, (LPVOID *)(v42 + 24)) | v14;
    v39 = v42 + 28;
    v16 = sub_1003F7D4((int)&v37, 1, v11, 0x18u, (LPVOID *)(v42 + 28)) | v15;
    v17 = sub_1003F7D4((int)&v37, 1, v11, 0x50u, (LPVOID *)(v42 + 32)) | v16;
    v18 = sub_1003F7D4((int)&v37, 1, v11, 0x51u, (LPVOID *)(v42 + 36)) | v17;
    v19 = sub_1003F7D4((int)&v37, 0, v11, 0x1Au, (LPVOID *)(v42 + 40)) | v18;
    v20 = sub_1003F7D4((int)&v37, 0, v11, 0x19u, (LPVOID *)(v42 + 41)) | v19;
    v21 = sub_1003F7D4((int)&v37, 0, v11, 0x54u, (LPVOID *)(v42 + 42)) | v20;
    v22 = sub_1003F7D4((int)&v37, 0, v11, 0x55u, (LPVOID *)(v42 + 43)) | v21;
    v23 = sub_1003F7D4((int)&v37, 0, v11, 0x56u, (LPVOID *)(v42 + 44)) | v22;
    v24 = sub_1003F7D4((int)&v37, 0, v11, 0x57u, (LPVOID *)(v42 + 45)) | v23;
    v25 = sub_1003F7D4((int)&v37, 0, v11, 0x52u, (LPVOID *)(v42 + 46)) | v24;
    v26 = sub_1003F7D4((int)&v37, 0, v11, 0x53u, (LPVOID *)(v42 + 47)) | v25;
    v27 = sub_1003F7D4((int)&v37, 2, v11, 0x15u, (LPVOID *)(v42 + 56)) | v26;
    v28 = sub_1003F7D4((int)&v37, 2, v11, 0x14u, (LPVOID *)(v42 + 60)) | v27;
    v29 = sub_1003F7D4((int)&v37, 2, v11, 0x16u, (LPVOID *)(v42 + 64)) | v28;
    v30 = sub_1003F7D4((int)&v37, 2, v11, 0x17u, (LPVOID *)(v42 + 68)) | v29;
    v31 = sub_1003F7D4((int)&v37, 2, v11, 0x50u, (LPVOID *)(v42 + 72)) | v30;
    if ( v31 | sub_1003F7D4((int)&v37, 2, v11, 0x51u, (LPVOID *)(v42 + 76)) )
    {
      sub_1004D798(v42, v42);
      sub_100309A2(v42, (LPVOID)v42);
      sub_100309A2(v42, v41);
      sub_100309A2(v42, v40);
      return 1;
    }
    v32 = *(_DWORD *)v39;
    while ( 1 )
    {
      if ( !*(_BYTE *)v32 )
        goto LABEL_26;
      v33 = *(_BYTE *)v32;
      if ( *(_BYTE *)v32 >= 48 )
      {
        if ( v33 <= 57 )
          break;
      }
      if ( v33 == 59 )
      {
        v34 = v32;
        do
        {
          *(_BYTE *)v34 = *(_BYTE *)(v34 + 1);
          ++v34;
        }
        while ( *(_BYTE *)v34 );
      }
      else
      {
LABEL_18:
        ++v32;
      }
    }
    *(_BYTE *)v32 = v33 - 48;
    goto LABEL_18;
  }
  v2 = 0;
  v41 = 0;
  v3 = &off_10073C58;
LABEL_28:
  if ( *(_DWORD *)(v1 + 128) )
    InterlockedDecrement(*(volatile LONG **)(v1 + 128));
  if ( *(_DWORD *)(v1 + 120) )
  {
    if ( !InterlockedDecrement(*(volatile LONG **)(v1 + 120)) )
    {
      sub_100309A2(v1, *(LPVOID *)(v1 + 132));
      sub_100309A2(v1, *(LPVOID *)(v1 + 120));
    }
  }
  *(_DWORD *)(v1 + 120) = v41;
  *(_DWORD *)(v1 + 128) = v2;
  *(_DWORD *)(v1 + 132) = v3;
  return 0;
}
// 10073C58: using guessed type void *off_10073C58;

//----- (1004DC36) --------------------------------------------------------
void __usercall sub_1004DC36(int a1<ebx>, int a2)
{
  if ( a2 )
  {
    if ( *(void **)a2 != off_10073C58 )
      sub_100309A2(a1, *(LPVOID *)a2);
    if ( *(void **)(a2 + 4) != off_10073C5C )
      sub_100309A2(a1, *(LPVOID *)(a2 + 4));
    if ( *(void **)(a2 + 8) != off_10073C60 )
      sub_100309A2(a1, *(LPVOID *)(a2 + 8));
    if ( *(void **)(a2 + 48) != off_10073C88 )
      sub_100309A2(a1, *(LPVOID *)(a2 + 48));
    if ( *(void **)(a2 + 52) != off_10073C8C )
      sub_100309A2(a1, *(LPVOID *)(a2 + 52));
  }
}
// 10073C58: using guessed type void *off_10073C58;
// 10073C5C: using guessed type void *off_10073C5C;
// 10073C60: using guessed type void *off_10073C60;
// 10073C88: using guessed type void *off_10073C88;
// 10073C8C: using guessed type void *off_10073C8C;

//----- (1004DC9D) --------------------------------------------------------
int __thiscall sub_1004DC9D(int this, int lpMem)
{
  int v2; // ebx@1
  int v3; // edi@3
  void **v4; // esi@3
  void *v5; // eax@4
  int v6; // edx@4
  int v8; // eax@6
  int v9; // edx@6
  int v10; // eax@9
  int v11; // edi@10
  signed int v12; // esi@10
  int v13; // esi@10
  int v14; // esi@10
  int v15; // esi@10
  int v16; // edx@13
  char v17; // al@14
  int v18; // esi@30
  int v19; // [sp-4h] [bp-24h]@6
  LPVOID v20; // [sp+Ch] [bp-14h]@1
  int v21; // [sp+10h] [bp-10h]@1
  int v22; // [sp+14h] [bp-Ch]@9
  int v23; // [sp+18h] [bp-8h]@4
  void *v24; // [sp+1Ch] [bp-4h]@3
  int v25; // [sp+28h] [bp+8h]@4

  v2 = lpMem;
  v20 = (LPVOID)lpMem;
  v21 = 0;
  if ( !*(_DWORD *)(lpMem + 176) && !*(_DWORD *)(lpMem + 172) )
  {
    v3 = 0;
    v24 = 0;
    v4 = &off_10073C58;
    goto LABEL_22;
  }
  v23 = 1;
  v5 = sub_10037506(this, lpMem, 1u, 0x50u);
  v25 = (int)v5;
  if ( !v5 )
    return 1;
  memcpy(v5, *(const void **)(v2 + 132), 0x50u);
  v8 = sub_10037550(v6, 0, v2, 4);
  v24 = (void *)v8;
  if ( !v8 )
  {
    sub_100309A2(v2, (LPVOID)v25);
    return 1;
  }
  v3 = 0;
  *(_DWORD *)v8 = 0;
  if ( !*(_DWORD *)(v2 + 176) )
  {
    v4 = (void **)v25;
    *(_DWORD *)v25 = off_10073C58;
    *(_DWORD *)(v25 + 4) = off_10073C5C;
    *(_DWORD *)(v25 + 8) = off_10073C60;
    *(_DWORD *)(v25 + 48) = off_10073C88;
    *(_DWORD *)(v25 + 52) = off_10073C8C;
    goto LABEL_20;
  }
  v10 = sub_10037550(v9, v19, v2, 4);
  v22 = v10;
  if ( !v10 )
    goto LABEL_12;
  *(_DWORD *)v10 = 0;
  v11 = *(_DWORD *)(v2 + 176);
  v12 = sub_1003F7D4((int)&v20, 1, *(_DWORD *)(v2 + 176), 0xEu, (LPVOID *)v25);
  v13 = sub_1003F7D4((int)&v20, 1, v11, 0xFu, (LPVOID *)(v25 + 4)) | v12;
  v23 = v25 + 8;
  v14 = sub_1003F7D4((int)&v20, 1, v11, 0x10u, (LPVOID *)(v25 + 8)) | v13;
  v15 = sub_1003F7D4((int)&v20, 2, v11, 0xEu, (LPVOID *)(v25 + 48)) | v14;
  if ( v15 | sub_1003F7D4((int)&v20, 2, v11, 0xFu, (LPVOID *)(v25 + 52)) )
  {
    sub_1004DC36(v2, v25);
    v23 = -1;
LABEL_12:
    sub_100309A2(v2, (LPVOID)v25);
    sub_100309A2(v2, v24);
    return v23;
  }
  v16 = *(_DWORD *)v23;
  while ( *(_BYTE *)v16 )
  {
    v17 = *(_BYTE *)v16;
    if ( *(_BYTE *)v16 >= 48 && v17 <= 57 )
    {
      *(_BYTE *)v16 = v17 - 48;
      goto LABEL_17;
    }
    if ( v17 == 59 )
    {
      v18 = v16;
      do
      {
        *(_BYTE *)v18 = *(_BYTE *)(v18 + 1);
        ++v18;
      }
      while ( *(_BYTE *)v18 );
    }
    else
    {
LABEL_17:
      ++v16;
    }
  }
  v3 = v22;
  v4 = (void **)v25;
LABEL_20:
  *(_DWORD *)v24 = 1;
  if ( v3 )
    *(_DWORD *)v3 = 1;
LABEL_22:
  if ( *(_DWORD *)(v2 + 124) )
    InterlockedDecrement(*(volatile LONG **)(v2 + 124));
  if ( *(_DWORD *)(v2 + 120) )
  {
    if ( !InterlockedDecrement(*(volatile LONG **)(v2 + 120)) )
    {
      sub_100309A2(v2, *(LPVOID *)(v2 + 120));
      sub_100309A2(v2, *(LPVOID *)(v2 + 132));
    }
  }
  *(_DWORD *)(v2 + 120) = v24;
  *(_DWORD *)(v2 + 124) = v3;
  *(_DWORD *)(v2 + 132) = v4;
  return 0;
}
// 10073C58: using guessed type void *off_10073C58;
// 10073C5C: using guessed type void *off_10073C5C;
// 10073C60: using guessed type void *off_10073C60;
// 10073C88: using guessed type void *off_10073C88;
// 10073C8C: using guessed type void *off_10073C8C;

//----- (1004DEA5) --------------------------------------------------------
void __usercall sub_1004DEA5(int a1<ebx>, int a2)
{
  if ( a2 )
  {
    sub_100309A2(a1, *(LPVOID *)(a2 + 4));
    sub_100309A2(a1, *(LPVOID *)(a2 + 8));
    sub_100309A2(a1, *(LPVOID *)(a2 + 12));
    sub_100309A2(a1, *(LPVOID *)(a2 + 16));
    sub_100309A2(a1, *(LPVOID *)(a2 + 20));
    sub_100309A2(a1, *(LPVOID *)(a2 + 24));
    sub_100309A2(a1, *(LPVOID *)a2);
    sub_100309A2(a1, *(LPVOID *)(a2 + 32));
    sub_100309A2(a1, *(LPVOID *)(a2 + 36));
    sub_100309A2(a1, *(LPVOID *)(a2 + 40));
    sub_100309A2(a1, *(LPVOID *)(a2 + 44));
    sub_100309A2(a1, *(LPVOID *)(a2 + 48));
    sub_100309A2(a1, *(LPVOID *)(a2 + 52));
    sub_100309A2(a1, *(LPVOID *)(a2 + 28));
    sub_100309A2(a1, *(LPVOID *)(a2 + 56));
    sub_100309A2(a1, *(LPVOID *)(a2 + 60));
    sub_100309A2(a1, *(LPVOID *)(a2 + 64));
    sub_100309A2(a1, *(LPVOID *)(a2 + 68));
    sub_100309A2(a1, *(LPVOID *)(a2 + 72));
    sub_100309A2(a1, *(LPVOID *)(a2 + 76));
    sub_100309A2(a1, *(LPVOID *)(a2 + 80));
    sub_100309A2(a1, *(LPVOID *)(a2 + 84));
    sub_100309A2(a1, *(LPVOID *)(a2 + 88));
    sub_100309A2(a1, *(LPVOID *)(a2 + 92));
    sub_100309A2(a1, *(LPVOID *)(a2 + 96));
    sub_100309A2(a1, *(LPVOID *)(a2 + 100));
    sub_100309A2(a1, *(LPVOID *)(a2 + 104));
    sub_100309A2(a1, *(LPVOID *)(a2 + 108));
    sub_100309A2(a1, *(LPVOID *)(a2 + 112));
    sub_100309A2(a1, *(LPVOID *)(a2 + 116));
    sub_100309A2(a1, *(LPVOID *)(a2 + 120));
    sub_100309A2(a1, *(LPVOID *)(a2 + 124));
    sub_100309A2(a1, *(LPVOID *)(a2 + 128));
    sub_100309A2(a1, *(LPVOID *)(a2 + 132));
    sub_100309A2(a1, *(LPVOID *)(a2 + 136));
    sub_100309A2(a1, *(LPVOID *)(a2 + 140));
    sub_100309A2(a1, *(LPVOID *)(a2 + 144));
    sub_100309A2(a1, *(LPVOID *)(a2 + 148));
    sub_100309A2(a1, *(LPVOID *)(a2 + 152));
    sub_100309A2(a1, *(LPVOID *)(a2 + 156));
    sub_100309A2(a1, *(LPVOID *)(a2 + 160));
    sub_100309A2(a1, *(LPVOID *)(a2 + 164));
    sub_100309A2(a1, *(LPVOID *)(a2 + 168));
    sub_100309A2(a1, *(LPVOID *)(a2 + 184));
    sub_100309A2(a1, *(LPVOID *)(a2 + 188));
    sub_100309A2(a1, *(LPVOID *)(a2 + 192));
    sub_100309A2(a1, *(LPVOID *)(a2 + 196));
    sub_100309A2(a1, *(LPVOID *)(a2 + 200));
    sub_100309A2(a1, *(LPVOID *)(a2 + 204));
    sub_100309A2(a1, *(LPVOID *)(a2 + 180));
    sub_100309A2(a1, *(LPVOID *)(a2 + 212));
    sub_100309A2(a1, *(LPVOID *)(a2 + 216));
    sub_100309A2(a1, *(LPVOID *)(a2 + 220));
    sub_100309A2(a1, *(LPVOID *)(a2 + 224));
    sub_100309A2(a1, *(LPVOID *)(a2 + 228));
    sub_100309A2(a1, *(LPVOID *)(a2 + 232));
    sub_100309A2(a1, *(LPVOID *)(a2 + 208));
    sub_100309A2(a1, *(LPVOID *)(a2 + 236));
    sub_100309A2(a1, *(LPVOID *)(a2 + 240));
    sub_100309A2(a1, *(LPVOID *)(a2 + 244));
    sub_100309A2(a1, *(LPVOID *)(a2 + 248));
    sub_100309A2(a1, *(LPVOID *)(a2 + 252));
    sub_100309A2(a1, *(LPVOID *)(a2 + 256));
    sub_100309A2(a1, *(LPVOID *)(a2 + 260));
    sub_100309A2(a1, *(LPVOID *)(a2 + 264));
    sub_100309A2(a1, *(LPVOID *)(a2 + 268));
    sub_100309A2(a1, *(LPVOID *)(a2 + 272));
    sub_100309A2(a1, *(LPVOID *)(a2 + 276));
    sub_100309A2(a1, *(LPVOID *)(a2 + 280));
    sub_100309A2(a1, *(LPVOID *)(a2 + 284));
    sub_100309A2(a1, *(LPVOID *)(a2 + 288));
    sub_100309A2(a1, *(LPVOID *)(a2 + 292));
    sub_100309A2(a1, *(LPVOID *)(a2 + 296));
    sub_100309A2(a1, *(LPVOID *)(a2 + 300));
    sub_100309A2(a1, *(LPVOID *)(a2 + 304));
    sub_100309A2(a1, *(LPVOID *)(a2 + 308));
    sub_100309A2(a1, *(LPVOID *)(a2 + 312));
    sub_100309A2(a1, *(LPVOID *)(a2 + 316));
    sub_100309A2(a1, *(LPVOID *)(a2 + 320));
    sub_100309A2(a1, *(LPVOID *)(a2 + 324));
    sub_100309A2(a1, *(LPVOID *)(a2 + 328));
    sub_100309A2(a1, *(LPVOID *)(a2 + 332));
    sub_100309A2(a1, *(LPVOID *)(a2 + 336));
    sub_100309A2(a1, *(LPVOID *)(a2 + 340));
    sub_100309A2(a1, *(LPVOID *)(a2 + 344));
    sub_100309A2(a1, *(LPVOID *)(a2 + 348));
    sub_100309A2(a1, *(LPVOID *)(a2 + 352));
  }
}

//----- (1004E225) --------------------------------------------------------
signed int __thiscall sub_1004E225(int this, int a2)
{
  int v2; // eax@2
  int v3; // esi@2
  int v5; // eax@8

  if ( *(_DWORD *)(a2 + 180) )
  {
    v2 = (int)sub_10037506(this, 1, 1u, 0x164u);
    v3 = v2;
    if ( !v2 )
      return 1;
    if ( sub_1004E2A1(v2, a2) )
    {
      sub_1004DEA5(1, v3);
      sub_100309A2(1, (LPVOID)v3);
      return 1;
    }
    *(_DWORD *)(v3 + 176) = 1;
  }
  else
  {
    v3 = (int)&off_100749E0;
  }
  v5 = *(_DWORD *)(a2 + 156);
  if ( (void **)v5 != &off_100749E0 )
    InterlockedDecrement((volatile LONG *)(v5 + 176));
  *(_DWORD *)(a2 + 156) = v3;
  return 0;
}
// 100749E0: using guessed type void *off_100749E0;

//----- (1004E2A1) --------------------------------------------------------
int __cdecl sub_1004E2A1(int a1, int a2)
{
  int v2; // ebx@1
  int result; // eax@2
  int v4; // eax@3
  signed int v5; // esi@3
  int v6; // esi@3
  int v7; // esi@3
  int v8; // esi@3
  int v9; // esi@3
  int v10; // esi@3
  int v11; // esi@3
  int v12; // esi@3
  int v13; // esi@3
  int v14; // esi@3
  int v15; // esi@3
  int v16; // esi@3
  int v17; // esi@3
  int v18; // esi@3
  int v19; // esi@3
  int v20; // esi@3
  int v21; // esi@3
  int v22; // esi@3
  int v23; // esi@3
  int v24; // esi@3
  int v25; // esi@3
  int v26; // esi@3
  int v27; // esi@3
  int v28; // esi@3
  int v29; // esi@3
  int v30; // esi@3
  int v31; // esi@3
  int v32; // esi@3
  int v33; // esi@3
  int v34; // esi@3
  int v35; // esi@3
  int v36; // esi@3
  int v37; // esi@3
  int v38; // esi@3
  int v39; // esi@3
  int v40; // esi@3
  int v41; // esi@3
  int v42; // esi@3
  int v43; // esi@3
  int v44; // esi@3
  int v45; // esi@3
  int v46; // esi@3
  int v47; // esi@3
  int v48; // esi@3
  int v49; // esi@3
  int v50; // esi@3
  int v51; // esi@3
  int v52; // esi@3
  int v53; // esi@3
  int v54; // esi@3
  int v55; // esi@3
  int v56; // esi@3
  int v57; // esi@3
  int v58; // esi@3
  int v59; // esi@3
  int v60; // esi@3
  int v61; // esi@3
  int v62; // esi@3
  int v63; // esi@3
  int v64; // esi@3
  int v65; // esi@3
  int v66; // esi@3
  int v67; // esi@3
  int v68; // esi@3
  int v69; // esi@3
  int v70; // esi@3
  int v71; // esi@3
  int v72; // esi@3
  int v73; // esi@3
  int v74; // esi@3
  int v75; // esi@3
  int v76; // esi@3
  int v77; // esi@3
  int v78; // esi@3
  int v79; // esi@3
  int v80; // esi@3
  int v81; // esi@3
  int v82; // esi@3
  int v83; // esi@3
  int v84; // esi@3
  int v85; // esi@3
  int v86; // esi@3
  int v87; // esi@3
  int v88; // esi@3
  int v89; // esi@3
  int v90; // esi@3
  int v91; // [sp+Ch] [bp-8h]@3
  int v92; // [sp+10h] [bp-4h]@3

  v2 = *(_DWORD *)(a2 + 180);
  if ( a1 )
  {
    v4 = sub_100427C0(*(_DWORD *)(a2 + 180));
    v92 = 0;
    *(_DWORD *)(a1 + 352) = v4;
    v91 = a2;
    v5 = sub_1003F7D4((int)&v91, 1, v2, 0x31u, (LPVOID *)(a1 + 4));
    v6 = sub_1003F7D4((int)&v91, 1, v2, 0x32u, (LPVOID *)(a1 + 8)) | v5;
    v7 = sub_1003F7D4((int)&v91, 1, v2, 0x33u, (LPVOID *)(a1 + 12)) | v6;
    v8 = sub_1003F7D4((int)&v91, 1, v2, 0x34u, (LPVOID *)(a1 + 16)) | v7;
    v9 = sub_1003F7D4((int)&v91, 1, v2, 0x35u, (LPVOID *)(a1 + 20)) | v8;
    v10 = sub_1003F7D4((int)&v91, 1, v2, 0x36u, (LPVOID *)(a1 + 24)) | v9;
    v11 = sub_1003F7D4((int)&v91, 1, v2, 0x37u, (LPVOID *)a1) | v10;
    v12 = sub_1003F7D4((int)&v91, 1, v2, 0x2Au, (LPVOID *)(a1 + 32)) | v11;
    v13 = sub_1003F7D4((int)&v91, 1, v2, 0x2Bu, (LPVOID *)(a1 + 36)) | v12;
    v14 = sub_1003F7D4((int)&v91, 1, v2, 0x2Cu, (LPVOID *)(a1 + 40)) | v13;
    v15 = sub_1003F7D4((int)&v91, 1, v2, 0x2Du, (LPVOID *)(a1 + 44)) | v14;
    v16 = sub_1003F7D4((int)&v91, 1, v2, 0x2Eu, (LPVOID *)(a1 + 48)) | v15;
    v17 = sub_1003F7D4((int)&v91, 1, v2, 0x2Fu, (LPVOID *)(a1 + 52)) | v16;
    v18 = sub_1003F7D4((int)&v91, 1, v2, 0x30u, (LPVOID *)(a1 + 28)) | v17;
    v19 = sub_1003F7D4((int)&v91, 1, v2, 0x44u, (LPVOID *)(a1 + 56)) | v18;
    v20 = sub_1003F7D4((int)&v91, 1, v2, 0x45u, (LPVOID *)(a1 + 60)) | v19;
    v21 = sub_1003F7D4((int)&v91, 1, v2, 0x46u, (LPVOID *)(a1 + 64)) | v20;
    v22 = sub_1003F7D4((int)&v91, 1, v2, 0x47u, (LPVOID *)(a1 + 68)) | v21;
    v23 = sub_1003F7D4((int)&v91, 1, v2, 0x48u, (LPVOID *)(a1 + 72)) | v22;
    v24 = sub_1003F7D4((int)&v91, 1, v2, 0x49u, (LPVOID *)(a1 + 76)) | v23;
    v25 = sub_1003F7D4((int)&v91, 1, v2, 0x4Au, (LPVOID *)(a1 + 80)) | v24;
    v26 = sub_1003F7D4((int)&v91, 1, v2, 0x4Bu, (LPVOID *)(a1 + 84)) | v25;
    v27 = sub_1003F7D4((int)&v91, 1, v2, 0x4Cu, (LPVOID *)(a1 + 88)) | v26;
    v28 = sub_1003F7D4((int)&v91, 1, v2, 0x4Du, (LPVOID *)(a1 + 92)) | v27;
    v29 = sub_1003F7D4((int)&v91, 1, v2, 0x4Eu, (LPVOID *)(a1 + 96)) | v28;
    v30 = sub_1003F7D4((int)&v91, 1, v2, 0x4Fu, (LPVOID *)(a1 + 100)) | v29;
    v31 = sub_1003F7D4((int)&v91, 1, v2, 0x38u, (LPVOID *)(a1 + 104)) | v30;
    v32 = sub_1003F7D4((int)&v91, 1, v2, 0x39u, (LPVOID *)(a1 + 108)) | v31;
    v33 = sub_1003F7D4((int)&v91, 1, v2, 0x3Au, (LPVOID *)(a1 + 112)) | v32;
    v34 = sub_1003F7D4((int)&v91, 1, v2, 0x3Bu, (LPVOID *)(a1 + 116)) | v33;
    v35 = sub_1003F7D4((int)&v91, 1, v2, 0x3Cu, (LPVOID *)(a1 + 120)) | v34;
    v36 = sub_1003F7D4((int)&v91, 1, v2, 0x3Du, (LPVOID *)(a1 + 124)) | v35;
    v37 = sub_1003F7D4((int)&v91, 1, v2, 0x3Eu, (LPVOID *)(a1 + 128)) | v36;
    v38 = sub_1003F7D4((int)&v91, 1, v2, 0x3Fu, (LPVOID *)(a1 + 132)) | v37;
    v39 = sub_1003F7D4((int)&v91, 1, v2, 0x40u, (LPVOID *)(a1 + 136)) | v38;
    v40 = sub_1003F7D4((int)&v91, 1, v2, 0x41u, (LPVOID *)(a1 + 140)) | v39;
    v41 = sub_1003F7D4((int)&v91, 1, v2, 0x42u, (LPVOID *)(a1 + 144)) | v40;
    v42 = sub_1003F7D4((int)&v91, 1, v2, 0x43u, (LPVOID *)(a1 + 148)) | v41;
    v43 = sub_1003F7D4((int)&v91, 1, v2, 0x28u, (LPVOID *)(a1 + 152)) | v42;
    v44 = sub_1003F7D4((int)&v91, 1, v2, 0x29u, (LPVOID *)(a1 + 156)) | v43;
    v45 = sub_1003F7D4((int)&v91, 1, v2, 0x1Fu, (LPVOID *)(a1 + 160)) | v44;
    v46 = sub_1003F7D4((int)&v91, 1, v2, 0x20u, (LPVOID *)(a1 + 164)) | v45;
    v47 = sub_1003F7D4((int)&v91, 1, v2, 0x1003u, (LPVOID *)(a1 + 168)) | v46;
    v48 = sub_1003F7D4((int)&v91, 0, v2, 0x1009u, (LPVOID *)(a1 + 172)) | v47;
    v49 = sub_1003F7D4((int)&v91, 2, v2, 0x31u, (LPVOID *)(a1 + 184)) | v48;
    v50 = sub_1003F7D4((int)&v91, 2, v2, 0x32u, (LPVOID *)(a1 + 188)) | v49;
    v51 = sub_1003F7D4((int)&v91, 2, v2, 0x33u, (LPVOID *)(a1 + 192)) | v50;
    v52 = sub_1003F7D4((int)&v91, 2, v2, 0x34u, (LPVOID *)(a1 + 196)) | v51;
    v53 = sub_1003F7D4((int)&v91, 2, v2, 0x35u, (LPVOID *)(a1 + 200)) | v52;
    v54 = sub_1003F7D4((int)&v91, 2, v2, 0x36u, (LPVOID *)(a1 + 204)) | v53;
    v55 = sub_1003F7D4((int)&v91, 2, v2, 0x37u, (LPVOID *)(a1 + 180)) | v54;
    v56 = sub_1003F7D4((int)&v91, 2, v2, 0x2Au, (LPVOID *)(a1 + 212)) | v55;
    v57 = sub_1003F7D4((int)&v91, 2, v2, 0x2Bu, (LPVOID *)(a1 + 216)) | v56;
    v58 = sub_1003F7D4((int)&v91, 2, v2, 0x2Cu, (LPVOID *)(a1 + 220)) | v57;
    v59 = sub_1003F7D4((int)&v91, 2, v2, 0x2Du, (LPVOID *)(a1 + 224)) | v58;
    v60 = sub_1003F7D4((int)&v91, 2, v2, 0x2Eu, (LPVOID *)(a1 + 228)) | v59;
    v61 = sub_1003F7D4((int)&v91, 2, v2, 0x2Fu, (LPVOID *)(a1 + 232)) | v60;
    v62 = sub_1003F7D4((int)&v91, 2, v2, 0x30u, (LPVOID *)(a1 + 208)) | v61;
    v63 = sub_1003F7D4((int)&v91, 2, v2, 0x44u, (LPVOID *)(a1 + 236)) | v62;
    v64 = sub_1003F7D4((int)&v91, 2, v2, 0x45u, (LPVOID *)(a1 + 240)) | v63;
    v65 = sub_1003F7D4((int)&v91, 2, v2, 0x46u, (LPVOID *)(a1 + 244)) | v64;
    v66 = sub_1003F7D4((int)&v91, 2, v2, 0x47u, (LPVOID *)(a1 + 248)) | v65;
    v67 = sub_1003F7D4((int)&v91, 2, v2, 0x48u, (LPVOID *)(a1 + 252)) | v66;
    v68 = sub_1003F7D4((int)&v91, 2, v2, 0x49u, (LPVOID *)(a1 + 256)) | v67;
    v69 = sub_1003F7D4((int)&v91, 2, v2, 0x4Au, (LPVOID *)(a1 + 260)) | v68;
    v70 = sub_1003F7D4((int)&v91, 2, v2, 0x4Bu, (LPVOID *)(a1 + 264)) | v69;
    v71 = sub_1003F7D4((int)&v91, 2, v2, 0x4Cu, (LPVOID *)(a1 + 268)) | v70;
    v72 = sub_1003F7D4((int)&v91, 2, v2, 0x4Du, (LPVOID *)(a1 + 272)) | v71;
    v73 = sub_1003F7D4((int)&v91, 2, v2, 0x4Eu, (LPVOID *)(a1 + 276)) | v72;
    v74 = sub_1003F7D4((int)&v91, 2, v2, 0x4Fu, (LPVOID *)(a1 + 280)) | v73;
    v75 = sub_1003F7D4((int)&v91, 2, v2, 0x38u, (LPVOID *)(a1 + 284)) | v74;
    v76 = sub_1003F7D4((int)&v91, 2, v2, 0x39u, (LPVOID *)(a1 + 288)) | v75;
    v77 = sub_1003F7D4((int)&v91, 2, v2, 0x3Au, (LPVOID *)(a1 + 292)) | v76;
    v78 = sub_1003F7D4((int)&v91, 2, v2, 0x3Bu, (LPVOID *)(a1 + 296)) | v77;
    v79 = sub_1003F7D4((int)&v91, 2, v2, 0x3Cu, (LPVOID *)(a1 + 300)) | v78;
    v80 = sub_1003F7D4((int)&v91, 2, v2, 0x3Du, (LPVOID *)(a1 + 304)) | v79;
    v81 = sub_1003F7D4((int)&v91, 2, v2, 0x3Eu, (LPVOID *)(a1 + 308)) | v80;
    v82 = sub_1003F7D4((int)&v91, 2, v2, 0x3Fu, (LPVOID *)(a1 + 312)) | v81;
    v83 = sub_1003F7D4((int)&v91, 2, v2, 0x40u, (LPVOID *)(a1 + 316)) | v82;
    v84 = sub_1003F7D4((int)&v91, 2, v2, 0x41u, (LPVOID *)(a1 + 320)) | v83;
    v85 = sub_1003F7D4((int)&v91, 2, v2, 0x42u, (LPVOID *)(a1 + 324)) | v84;
    v86 = sub_1003F7D4((int)&v91, 2, v2, 0x43u, (LPVOID *)(a1 + 328)) | v85;
    v87 = sub_1003F7D4((int)&v91, 2, v2, 0x28u, (LPVOID *)(a1 + 332)) | v86;
    v88 = sub_1003F7D4((int)&v91, 2, v2, 0x29u, (LPVOID *)(a1 + 336)) | v87;
    v89 = sub_1003F7D4((int)&v91, 2, v2, 0x1Fu, (LPVOID *)(a1 + 340)) | v88;
    v90 = sub_1003F7D4((int)&v91, 2, v2, 0x20u, (LPVOID *)(a1 + 344)) | v89;
    result = v90 | sub_1003F7D4((int)&v91, 2, v2, 0x1003u, (LPVOID *)(a1 + 348));
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1004EA92) --------------------------------------------------------
int __thiscall sub_1004EA92(void *this, const WCHAR SrcStr, __int16 a3)
{
  int result; // eax@2
  int v4; // eax@4
  BOOL v5; // eax@5
  WORD CharType[2]; // [sp+0h] [bp-4h]@1

  *(_DWORD *)CharType = this;
  if ( SrcStr == -1 )
  {
    result = 0;
  }
  else
  {
    if ( SrcStr >= 0x100u )
    {
      v5 = GetStringTypeW(1u, &SrcStr, 1, CharType);
      v4 = v5 != 0 ? *(_DWORD *)CharType : 0;
    }
    else
    {
      LOWORD(v4) = *((_WORD *)off_10074084 + SrcStr);
    }
    result = (unsigned __int16)(a3 & v4);
  }
  return result;
}
// 10074084: using guessed type void *off_10074084;

//----- (1004EAE4) --------------------------------------------------------
int __cdecl sub_1004EAE4(int a1, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // esi@2

  v2 = a2;
  v4 = *(_WORD *)a2;
  v3 = *(_WORD *)a1 - v4;
  if ( *(_WORD *)a1 == v4 )
  {
    v5 = a1 - a2;
    do
    {
      if ( !(_WORD)v4 )
        break;
      v2 += 2;
      v4 = *(_WORD *)v2;
      v3 = *(_WORD *)(v5 + v2) - v4;
    }
    while ( *(_WORD *)(v5 + v2) == v4 );
  }
  if ( v3 >= 0 )
  {
    if ( v3 > 0 )
      v3 = 1;
  }
  else
  {
    v3 = -1;
  }
  return v3;
}

//----- (1004EB22) --------------------------------------------------------
int __cdecl sub_1004EB22(int a1, int a2)
{
  int v2; // eax@1
  __int16 v3; // dx@1
  int v4; // ecx@1
  int v5; // esi@2
  __int16 v6; // dx@3

  v4 = a1;
  v3 = 0;
  v2 = a1;
  if ( *(_WORD *)a1 )
  {
    while ( 1 )
    {
      v5 = a2;
      if ( *(_WORD *)a2 )
        break;
LABEL_7:
      v2 += 2;
      if ( *(_WORD *)v2 == v3 )
        return (v2 - v4) >> 1;
    }
    v4 = a1;
    v6 = *(_WORD *)a2;
    while ( v6 != *(_WORD *)v2 )
    {
      v5 += 2;
      v6 = *(_WORD *)v5;
      if ( !*(_WORD *)v5 )
      {
        v3 = 0;
        goto LABEL_7;
      }
    }
  }
  return (v2 - v4) >> 1;
}

//----- (1004EB71) --------------------------------------------------------
int __cdecl sub_1004EB71(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // edx@3
  int v5; // ecx@3

  result = a3;
  if ( a3 )
  {
    v5 = a2;
    v4 = a1;
    while ( 1 )
    {
      --result;
      if ( !result )
        break;
      if ( !*(_WORD *)v4 || *(_WORD *)v4 != *(_WORD *)v5 )
        break;
      v4 += 2;
      v5 += 2;
    }
    result = *(_WORD *)v4 - *(_WORD *)v5;
  }
  return result;
}

//----- (1004EBA7) --------------------------------------------------------
int __cdecl sub_1004EBA7(int a1, int a2)
{
  int result; // eax@1
  __int16 v3; // cx@1
  int v4; // esi@2
  __int16 v5; // dx@3

  result = a1;
  v3 = *(_WORD *)a1;
  if ( *(_WORD *)a1 )
  {
    while ( 1 )
    {
      v4 = a2;
      if ( *(_WORD *)a2 )
        break;
LABEL_6:
      result += 2;
      v3 = *(_WORD *)result;
      if ( !*(_WORD *)result )
        goto LABEL_7;
    }
    v5 = *(_WORD *)a2;
    while ( v5 != v3 )
    {
      v4 += 2;
      v5 = *(_WORD *)v4;
      if ( !*(_WORD *)v4 )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_7:
    result = 0;
  }
  return result;
}

//----- (1004EBE9) --------------------------------------------------------
int __usercall sub_1004EBE9<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  char v5; // [sp+4h] [bp-B0h]@1
  unsigned int v6; // [sp+B0h] [bp-4h]@1
  int v7; // [sp+B4h] [bp+0h]@1

  v6 = (unsigned int)&v7 ^ __security_cookie;
  *(_DWORD *)(a3 + 8) |= 0x104u;
  result = sub_10039CDD((int)&v5, 85);
  if ( result > 1 )
  {
    v4 = sub_100398B9((int)&v5);
    result = sub_10044A99(a1, a2, a3 + 592, 85, (int)&v5, v4 + 1);
    if ( result )
    {
      sub_1003A17E(a1, a2);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1004EC60);
    }
  }
  return result;
}
// 1004EC60: using guessed type int __cdecl sub_1004EC60(int);
// 10074200: using guessed type int __security_cookie;

//----- (1004EC60) --------------------------------------------------------
BOOL __cdecl sub_1004EC60(int a1)
{
  int v1; // ST04_4@1
  int v2; // eax@1
  char v3; // zf@1
  int v4; // eax@2
  BOOL result; // eax@4

  v1 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 16) = sub_100398B9(*(_DWORD *)a1) == 3;
  v2 = sub_100398B9(v1);
  v3 = *(_DWORD *)(a1 + 16) == 0;
  *(_DWORD *)(a1 + 20) = v2 == 3;
  if ( v3 )
    v4 = sub_1004ED1E(*(unsigned __int16 **)a1);
  else
    v4 = 2;
  *(_DWORD *)(a1 + 12) = v4;
  result = sub_10039C71((int (__stdcall *)(_DWORD, _DWORD, _DWORD))sub_1004ED50, 3, 0);
  if ( !(*(_DWORD *)(a1 + 8) & 0x100) || !(*(_DWORD *)(a1 + 8) & 0x200) || !(*(_BYTE *)(a1 + 8) & 7) )
    *(_DWORD *)(a1 + 8) = 0;
  return result;
}
// 1004EC60: using guessed type int __cdecl sub_1004EC60(int);

//----- (1004ECD4) --------------------------------------------------------
BOOL __cdecl sub_1004ECD4(int a1)
{
  bool v1; // eax@1
  int v2; // eax@2
  BOOL result; // eax@4

  v1 = sub_100398B9(*(_DWORD *)a1) == 3;
  *(_DWORD *)(a1 + 16) = v1;
  if ( v1 )
    v2 = 2;
  else
    v2 = sub_1004ED1E(*(unsigned __int16 **)a1);
  *(_DWORD *)(a1 + 12) = v2;
  result = sub_10039C71((int (__stdcall *)(_DWORD, _DWORD, _DWORD))sub_1004EF6E, 3, 0);
  if ( !(*(_BYTE *)(a1 + 8) & 4) )
    *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (1004ED1E) --------------------------------------------------------
int __cdecl sub_1004ED1E(unsigned __int16 *a1)
{
  int v1; // edx@1
  unsigned __int16 *v2; // ecx@1
  int result; // eax@2
  unsigned __int16 v4; // ax@3

  v2 = a1;
  v1 = 0;
  if ( a1 )
  {
    while ( 1 )
    {
      v4 = *v2;
      ++v2;
      if ( v4 < 0x41u || v4 > 0x5Au )
      {
        if ( (unsigned __int16)(v4 - 97) > 0x19u )
          break;
      }
      ++v1;
    }
    result = v1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004ED50) --------------------------------------------------------
unsigned int __userpurge sub_1004ED50<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@1
  int v9; // eax@7
  int v10; // edi@8
  int v11; // eax@22
  int v12; // esi@28
  const WCHAR v13[64]; // [sp+Ch] [bp-84h]@1
  unsigned int v14; // [sp+8Ch] [bp-4h]@1
  int v15; // [sp+90h] [bp+0h]@1

  v14 = (unsigned int)&v15 ^ __security_cookie;
  v6 = a3;
  v7 = sub_10041A5C(a1, a2);
  v5 = v7 + 156;
  if ( !sub_10039CAE(a3, *(_DWORD *)(v7 + 176) != 0 ? 7 : 4098, (WCHAR *)v13, 64) )
  {
    *(_DWORD *)(v5 + 8) = 0;
    return 1;
  }
  if ( !sub_1004AAEB(v5, a2, *(_DWORD *)(v5 + 4), v13) )
  {
    if ( !sub_10039CAE(a3, *(_DWORD *)(v5 + 16) != 0 ? 3 : 4097, (WCHAR *)v13, 64) )
    {
LABEL_18:
      *(_DWORD *)(v5 + 8) = 0;
      return 1;
    }
    if ( !sub_1004AAEB(v5, -4094, *(_DWORD *)v5, v13) )
    {
      *(_DWORD *)(v5 + 8) |= 0x304u;
      goto LABEL_7;
    }
    if ( !(*(_BYTE *)(v5 + 8) & 2) )
    {
      if ( *(_DWORD *)(v5 + 12) && !sub_100549B2(v5, -4094, *(_DWORD *)v5, (int)v13, *(_DWORD *)(v5 + 12)) )
      {
        *(_DWORD *)(v5 + 8) |= 2u;
        goto LABEL_7;
      }
      if ( !(*(_BYTE *)(v5 + 8) & 1) && sub_1004F0B4(a3) )
      {
        *(_DWORD *)(v5 + 8) |= 1u;
LABEL_7:
        v9 = sub_100398B9(a3);
        if ( sub_10044A99(v5, -4094, v5 + 592, 85, a3, v9 + 1) )
        {
          v10 = 0;
          goto LABEL_30;
        }
        goto LABEL_16;
      }
    }
  }
LABEL_16:
  if ( (*(_DWORD *)(v5 + 8) & 0x300) != 768 )
  {
    if ( !sub_10039CAE(a3, *(_DWORD *)(v5 + 16) != 0 ? 3 : 4097, (WCHAR *)v13, 128) )
      goto LABEL_18;
    if ( !sub_1004AAEB(v5, -4094, *(_DWORD *)v5, v13) )
    {
      *(_DWORD *)(v5 + 8) |= 0x200u;
      v10 = 0;
      if ( *(_DWORD *)(v5 + 16)
        || !*(_DWORD *)(v5 + 12)
        || sub_100398B9(*(_DWORD *)v5) != *(_DWORD *)(v5 + 12)
        || sub_1004F0B4(a3) )
      {
LABEL_21:
        *(_DWORD *)(v5 + 8) |= 0x100u;
        if ( !*(_WORD *)(v5 + 592) )
        {
          v11 = sub_100398B9(v6);
          if ( sub_10044A99(v5, 0, v5 + 592, 85, v6, v11 + 1) )
          {
LABEL_30:
            sub_1003A17E(v5, v10);
            __asm { int     3               ; Trap to Debugger }
            JUMPOUT(*(int *)sub_1004EF6E);
          }
        }
        return ~(unsigned __int8)(*(_DWORD *)(v5 + 8) >> 2) & 1;
      }
      v12 = sub_1004ED1E(*(unsigned __int16 **)v5);
      if ( v12 != sub_100398B9(*(_DWORD *)v5) )
      {
        v6 = a3;
        goto LABEL_21;
      }
    }
  }
  return ~(unsigned __int8)(*(_DWORD *)(v5 + 8) >> 2) & 1;
}
// 10074200: using guessed type int __security_cookie;

//----- (1004EF6E) --------------------------------------------------------
unsigned int __userpurge sub_1004EF6E<eax>(int a1<ebx>, int a2, int a3, int a4)
{
  int v4; // esi@1
  int v5; // eax@1
  unsigned int result; // eax@2
  int v7; // eax@4
  const WCHAR v8[120]; // [sp+8h] [bp-F4h]@1
  unsigned int v9; // [sp+F8h] [bp-4h]@1
  int v10; // [sp+FCh] [bp+0h]@1

  v9 = (unsigned int)&v10 ^ __security_cookie;
  v5 = sub_10041A5C(a1, a2);
  v4 = v5 + 156;
  if ( sub_10039CAE(a2, *(_DWORD *)(v5 + 172) != 0 ? 3 : 4097, (WCHAR *)v8, 120) )
  {
    if ( !sub_1004AAEB(a1, a2, *(_DWORD *)v4, v8) )
    {
      v7 = sub_100398B9(a2);
      if ( sub_10044A99(a1, a2, v4 + 592, 85, a2, v7 + 1) )
      {
        sub_1003A17E(a1, a2);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_1004F01F);
      }
      *(_DWORD *)(v4 + 8) |= 4u;
    }
    result = ~(unsigned __int8)(*(_DWORD *)(v4 + 8) >> 2) & 1;
  }
  else
  {
    *(_DWORD *)(v4 + 8) = 0;
    result = 1;
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;

//----- (1004F01F) --------------------------------------------------------
int __usercall sub_1004F01F<eax>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  int v4; // esi@1
  int result; // eax@6

  v4 = a3;
  if ( a3 && *(_WORD *)a3 && sub_1004EAE4(a3, (int)L"ACP") )
  {
    if ( sub_1004EAE4(v4, (int)L"OCP") )
      return sub_100548F0(a1, a2, v4);
    if ( sub_10039CAE(a4 + 592, 0x2000000Bu, (WCHAR *)&a3, 2) )
      return a3;
    return 0;
  }
  if ( !sub_10039CAE(a4 + 592, 0x20001004u, (WCHAR *)&a3, 2) )
    return 0;
  result = a3;
  if ( !a3 )
    result = GetACP();
  return result;
}
// 100677BC: using guessed type wchar_t aAcp[4];
// 100677C4: using guessed type wchar_t aOcp[4];

//----- (1004F0B4) --------------------------------------------------------
int __cdecl sub_1004F0B4(int a1)
{
  int result; // eax@1
  char v2; // [sp+4h] [bp-18h]@1
  unsigned int v3; // [sp+18h] [bp-4h]@1
  int v4; // [sp+1Ch] [bp+0h]@1

  v3 = (unsigned int)&v4 ^ __security_cookie;
  result = sub_10039CAE(a1, 0x59u, (WCHAR *)&v2, 9);
  if ( result )
    result = sub_1004EB71((int)&v2, a1, 9) == 0;
  return result;
}
// 10074200: using guessed type int __security_cookie;

//----- (1004F0FE) --------------------------------------------------------
signed int __usercall sub_1004F0FE<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  int v5; // eax@1
  __int16 v6; // cx@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // eax@14
  unsigned int v10; // esi@14
  int v11; // eax@21
  int v13; // [sp+Ch] [bp-4h]@1

  v5 = sub_10041A5C(a1, a2);
  v8 = v5 + 156;
  v6 = 0;
  v13 = v5 + 748;
  *(_WORD *)(v5 + 748) = 0;
  v7 = v5 + 160;
  *(_DWORD *)(v5 + 164) = 0;
  *(_DWORD *)(v5 + 156) = a3;
  *(_DWORD *)(v5 + 160) = a3 + 128;
  if ( *(_WORD *)(a3 + 128) )
  {
    sub_1004F8DE((int)&off_100674E0, 22, (int *)(v5 + 160));
    v6 = 0;
  }
  if ( **(_WORD **)v8 == v6 )
  {
    sub_1004EBE9(a3, v7, v8);
  }
  else
  {
    if ( **(_WORD **)v7 == v6 )
      sub_1004ECD4(v8);
    else
      sub_1004EC60(v8);
    if ( !*(_DWORD *)(v8 + 8) )
    {
      if ( sub_1004F8DE((int)&off_10066A30, 64, (int *)v8) )
      {
        if ( **(_WORD **)v7 )
          sub_1004EC60(v8);
        else
          sub_1004ECD4(v8);
      }
    }
  }
  if ( *(_DWORD *)(v8 + 8) )
  {
    v9 = sub_1004F01F(a3, 0, a3 + 256, v8);
    v10 = v9;
    if ( v9 )
    {
      if ( v9 != 65000 && v9 != 65001 && IsValidCodePage((unsigned __int16)v9) )
      {
        if ( a4 )
          *(_DWORD *)a4 = v10;
        if ( !a5 )
          return 1;
        *(_WORD *)(a5 + 288) = 0;
        v11 = sub_100398B9(v13);
        if ( sub_10044A99(a5 + 288, a5, a5 + 288, 85, v13, v11 + 1) )
        {
          sub_1003A17E(a5 + 288, a5);
          __asm { int     3               ; Trap to Debugger }
          JUMPOUT(*(int *)sub_1004F2C0);
        }
        if ( sub_10039CAE(a5 + 288, 0x1001u, (WCHAR *)a5, 64)
          && sub_10039CAE(a5 + 288, 0x1002u, (WCHAR *)(a5 + 128), 64)
          && (!sub_10054904(a5 + 128, 0x5Fu) && !sub_10054904(a5 + 128, 0x2Eu)
           || sub_10039CAE(a5 + 288, 7u, (WCHAR *)(a5 + 128), 64)) )
        {
          sub_100547D4(a5 + 128, a5, v10, a5 + 256, 0x10u, 0xAu);
          return 1;
        }
      }
    }
  }
  return 0;
}
// 1004EC60: using guessed type int __cdecl sub_1004EC60(int);
// 10066A30: using guessed type wchar_t *off_10066A30;
// 100674E0: using guessed type wchar_t *off_100674E0;

//----- (1004F2C0) --------------------------------------------------------
unsigned int __userpurge sub_1004F2C0<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  unsigned int result; // eax@2
  WCHAR LCData; // [sp+Ch] [bp-F4h]@1
  unsigned int v8; // [sp+FCh] [bp-4h]@1
  int v9; // [sp+100h] [bp+0h]@1

  v8 = (unsigned int)&v9 ^ __security_cookie;
  v3 = sub_10041A5C(a1, a2);
  v4 = *(_DWORD *)(sub_10041A5C(v3, a2) + 952);
  v5 = sub_1004F77A(a3);
  if ( GetLocaleInfoW(v5, *(_DWORD *)(v3 + 176) != 0 ? 7 : 4098, &LCData, 240) )
  {
    if ( !sub_1004AAEB(v3, v4, *(_DWORD *)(v3 + 160), &LCData) )
    {
      if ( sub_1004F854(v5) )
      {
        *(_DWORD *)v4 |= 4u;
        *(_DWORD *)(v4 + 8) = v5;
        *(_DWORD *)(v4 + 4) = v5;
      }
    }
    result = ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
  }
  else
  {
    *(_DWORD *)v4 = 0;
    result = 1;
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;

//----- (1004F36E) --------------------------------------------------------
int __usercall sub_1004F36E<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int result; // eax@1
  int v4; // eax@1

  v4 = sub_10041A5C(a1, a2);
  *(_DWORD *)(v4 + 176) = sub_100398B9(*(_DWORD *)(v4 + 160)) == 3;
  EnumSystemLocalesW((LOCALE_ENUMPROCW)sub_1004F2C0, 1u);
  result = a3;
  if ( !(*(_BYTE *)a3 & 4) )
    *(_DWORD *)a3 = 0;
  return result;
}

//----- (1004F3AE) --------------------------------------------------------
BOOL __usercall sub_1004F3AE<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // esi@1
  int v4; // eax@1
  int v5; // ST00_4@1
  int v6; // eax@2
  BOOL result; // eax@4

  v4 = sub_10041A5C(a1, a2);
  v3 = v4 + 156;
  v5 = *(_DWORD *)(v4 + 160);
  *(_DWORD *)(v4 + 172) = sub_100398B9(*(_DWORD *)(v4 + 156)) == 3;
  *(_DWORD *)(v3 + 20) = sub_100398B9(v5) == 3;
  *(_DWORD *)(a3 + 4) = 0;
  if ( *(_DWORD *)(v3 + 16) )
    v6 = 2;
  else
    v6 = sub_1004F484(*(unsigned __int16 **)v3);
  *(_DWORD *)(v3 + 12) = v6;
  result = EnumSystemLocalesW((LOCALE_ENUMPROCW)sub_1004F4AE, 1u);
  if ( !(*(_DWORD *)a3 & 0x100) || !(*(_DWORD *)a3 & 0x200) || !(*(_BYTE *)a3 & 7) )
    *(_DWORD *)a3 = 0;
  return result;
}

//----- (1004F42B) --------------------------------------------------------
int __usercall sub_1004F42B<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // esi@1
  int v4; // eax@1
  bool v5; // eax@1
  int v6; // eax@2
  int result; // eax@4

  v4 = sub_10041A5C(a1, a2);
  v3 = v4;
  v5 = sub_100398B9(*(_DWORD *)(v4 + 156)) == 3;
  *(_DWORD *)(v3 + 172) = v5;
  if ( v5 )
    v6 = 2;
  else
    v6 = sub_1004F484(*(unsigned __int16 **)(v3 + 156));
  *(_DWORD *)(v3 + 168) = v6;
  EnumSystemLocalesW((LOCALE_ENUMPROCW)sub_1004F6A1, 1u);
  result = a3;
  if ( !(*(_BYTE *)a3 & 4) )
    *(_DWORD *)a3 = 0;
  return result;
}

//----- (1004F484) --------------------------------------------------------
int __cdecl sub_1004F484(unsigned __int16 *a1)
{
  int i; // edx@1
  unsigned __int16 *v2; // ecx@1
  unsigned __int16 v3; // ax@2

  v2 = a1;
  for ( i = 0; ; ++i )
  {
    v3 = *v2;
    ++v2;
    if ( v3 < 0x41u || v3 > 0x5Au )
    {
      if ( (unsigned __int16)(v3 - 97) > 0x19u )
        break;
    }
  }
  return i;
}

//----- (1004F4AE) --------------------------------------------------------
signed int __userpurge sub_1004F4AE<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // edx@13
  int v8; // eax@18
  int v9; // [sp-8h] [bp-108h]@22
  WCHAR LCData; // [sp+Ch] [bp-F4h]@1
  unsigned int v11; // [sp+FCh] [bp-4h]@1
  int v12; // [sp+100h] [bp+0h]@1

  v11 = (unsigned int)&v12 ^ __security_cookie;
  v3 = sub_10041A5C(a1, a2) + 156;
  v4 = *(_DWORD *)(sub_10041A5C(v3, a2) + 952);
  v5 = sub_1004F77A(a3);
  if ( !GetLocaleInfoW(v5, *(_DWORD *)(v3 + 20) != 0 ? 7 : 4098, &LCData, 240) )
    goto LABEL_2;
  if ( !sub_1004AAEB(v3, v4, *(_DWORD *)(v3 + 4), &LCData) )
  {
    if ( !GetLocaleInfoW(v5, *(_DWORD *)(v3 + 16) != 0 ? 3 : 4097, &LCData, 240) )
      goto LABEL_2;
    if ( !sub_1004AAEB(v3, v4, *(_DWORD *)v3, &LCData) )
    {
      *(_DWORD *)v4 |= 0x304u;
      *(_DWORD *)(v4 + 4) = v5;
LABEL_15:
      *(_DWORD *)(v4 + 8) = v5;
      goto LABEL_16;
    }
    if ( *(_BYTE *)v4 & 2 )
      goto LABEL_16;
    if ( !*(_DWORD *)(v3 + 12) || sub_100549B2(v3, v4, *(_DWORD *)v3, (int)&LCData, *(_DWORD *)(v3 + 12)) )
    {
      if ( !(*(_DWORD *)v4 & 1) && sub_1004F854(v5) )
      {
        *(_DWORD *)v4 = v7 | 1;
        goto LABEL_15;
      }
    }
    else
    {
      *(_DWORD *)v4 |= 2u;
      *(_DWORD *)(v4 + 8) = v5;
      if ( sub_100398B9(*(_DWORD *)v3) == *(_DWORD *)(v3 + 12) )
        *(_DWORD *)(v4 + 4) = v5;
    }
  }
LABEL_16:
  if ( (*(_DWORD *)v4 & 0x300) == 768 )
    return ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
  if ( !GetLocaleInfoW(v5, *(_DWORD *)(v3 + 16) != 0 ? 3 : 4097, &LCData, 240) )
  {
LABEL_2:
    *(_DWORD *)v4 = 0;
    return 1;
  }
  v8 = sub_1004AAEB(v3, v4, *(_DWORD *)v3, &LCData);
  if ( v8 )
  {
    if ( *(_DWORD *)(v3 + 16) || !*(_DWORD *)(v3 + 12) || sub_1004AAEB(v3, v4, *(_DWORD *)v3, &LCData) )
      return ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
    v9 = 0;
  }
  else
  {
    *(_DWORD *)v4 |= 0x200u;
    if ( *(_DWORD *)(v3 + 16) || *(_DWORD *)(v3 + 12) == v8 || sub_100398B9(*(_DWORD *)v3) != *(_DWORD *)(v3 + 12) )
      goto LABEL_28;
    v9 = 1;
  }
  if ( sub_1004F876(v3, v4, v5, v9) )
  {
LABEL_28:
    *(_DWORD *)v4 |= 0x100u;
    if ( !*(_DWORD *)(v4 + 4) )
      *(_DWORD *)(v4 + 4) = v5;
  }
  return ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
}
// 10074200: using guessed type int __security_cookie;

//----- (1004F6A1) --------------------------------------------------------
signed int __userpurge sub_1004F6A1<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // [sp-8h] [bp-108h]@5
  WCHAR LCData; // [sp+Ch] [bp-F4h]@1
  unsigned int v9; // [sp+FCh] [bp-4h]@1
  int v10; // [sp+100h] [bp+0h]@1

  v9 = (unsigned int)&v10 ^ __security_cookie;
  v3 = sub_10041A5C(a1, a2) + 156;
  v4 = *(_DWORD *)(sub_10041A5C(v3, a2) + 952);
  v5 = sub_1004F77A(a3);
  if ( !GetLocaleInfoW(v5, *(_DWORD *)(v3 + 16) != 0 ? 3 : 4097, &LCData, 240) )
  {
    *(_DWORD *)v4 = 0;
    return 1;
  }
  if ( sub_1004AAEB(v3, v4, *(_DWORD *)v3, &LCData) )
  {
    if ( *(_DWORD *)(v3 + 16) || !*(_DWORD *)(v3 + 12) || sub_1004AAEB(v3, v4, *(_DWORD *)v3, &LCData) )
      return ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
    v7 = 0;
  }
  else
  {
    if ( *(_DWORD *)(v3 + 16) )
    {
LABEL_11:
      *(_DWORD *)v4 |= 4u;
      *(_DWORD *)(v4 + 4) = v5;
      *(_DWORD *)(v4 + 8) = v5;
      return ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
    }
    v7 = 1;
  }
  if ( sub_1004F876(v3, v4, v5, v7) )
    goto LABEL_11;
  return ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
}
// 10074200: using guessed type int __security_cookie;

//----- (1004F77A) --------------------------------------------------------
int __cdecl sub_1004F77A(int a1)
{
  int v1; // edx@1
  int v2; // ecx@1
  int i; // esi@1

  v1 = a1;
  v2 = *(_WORD *)a1;
  for ( i = 0; (_WORD)v2; v2 = *(_WORD *)v1 )
  {
    v1 += 2;
    if ( (unsigned __int16)(v2 - 97) > 5u )
    {
      if ( (unsigned __int16)(v2 - 65) <= 5u )
        v2 += 65529;
    }
    else
    {
      v2 += 65497;
    }
    i = (unsigned __int16)v2 - 48 + 16 * i;
  }
  return i;
}

//----- (1004F7C9) --------------------------------------------------------
int __usercall sub_1004F7C9<eax>(int a1<ebx>, int a2<edi>, int LCData, int a4)
{
  int v4; // esi@1
  int result; // eax@6

  v4 = LCData;
  if ( LCData && *(_WORD *)LCData && sub_1004EAE4(LCData, (int)L"ACP") )
  {
    if ( sub_1004EAE4(v4, (int)L"OCP") )
      return sub_100548F0(a1, a2, v4);
    if ( GetLocaleInfoW(*(_DWORD *)(a4 + 8), 0x2000000Bu, (LPWSTR)&LCData, 2) )
      return LCData;
    return 0;
  }
  if ( !GetLocaleInfoW(*(_DWORD *)(a4 + 8), 0x20001004u, (LPWSTR)&LCData, 2) )
    return 0;
  result = LCData;
  if ( !LCData )
    result = GetACP();
  return result;
}
// 100677BC: using guessed type wchar_t aAcp[4];
// 100677C4: using guessed type wchar_t aOcp[4];

//----- (1004F854) --------------------------------------------------------
signed int __cdecl sub_1004F854(__int16 a1)
{
  unsigned int v1; // eax@1

  v1 = 0;
  while ( a1 != *(__int16 *)((char *)&word_100677CC + v1) )
  {
    v1 += 2;
    if ( v1 >= 0x14 )
      return 1;
  }
  return 0;
}
// 100677CC: using guessed type __int16 word_100677CC;

//----- (1004F876) --------------------------------------------------------
bool __usercall sub_1004F876<eax>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  int v4; // edi@1
  int v6; // esi@5
  WCHAR LCData[2]; // [sp+8h] [bp-4h]@1

  v4 = sub_10041A5C(a1, a2);
  return GetLocaleInfoW(a3 & 0x3FF | 0x400, 0x20000001u, LCData, 2)
      && (a3 == *(_DWORD *)LCData
       || !a4
       || (v6 = sub_1004F484(*(unsigned __int16 **)(v4 + 156)), v6 != sub_100398B9(*(_DWORD *)(v4 + 156))));
}

//----- (1004F8DE) --------------------------------------------------------
bool __cdecl sub_1004F8DE(int a1, int a2, int *a3)
{
  signed int v3; // edx@1
  int i; // edi@1
  int v5; // esi@1
  int v6; // eax@3
  int v7; // ebx@3
  int v9; // [sp+14h] [bp+Ch]@3

  v5 = a2;
  v3 = 1;
  for ( i = 0; i <= v5; v6 ? (v6 >= 0 ? (i = v7 + 1) : (v5 = v7 - 1)) : (*a3 = v9 + 4 + a1) )
  {
    if ( !v3 )
      break;
    v7 = (i + v5) / 2;
    v9 = 12 * (i + v5) / 2;
    v6 = sub_1004AAEB(v7, i, *a3, *(const WCHAR **)(v9 + a1));
    v3 = v6;
  }
  return v3 == 0;
}

//----- (1004F94A) --------------------------------------------------------
signed int __usercall sub_1004F94A<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // ecx@3
  int v7; // eax@25
  unsigned int v8; // esi@25
  int v10; // [sp+14h] [bp-10h]@1
  LCID Locale; // [sp+18h] [bp-Ch]@23
  LCID v12; // [sp+1Ch] [bp-8h]@23
  unsigned int v13; // [sp+20h] [bp-4h]@1
  int v14; // [sp+24h] [bp+0h]@1

  v13 = (unsigned int)&v14 ^ __security_cookie;
  v5 = sub_10041A5C(a1, a2) + 156;
  sub_10039210(&v10, 0, 12);
  *(_DWORD *)(sub_10041A5C(v5, a2) + 952) = &v10;
  if ( !a3 )
  {
    v10 |= 0x104u;
LABEL_23:
    Locale = GetUserDefaultLCID();
    v12 = Locale;
    goto LABEL_24;
  }
  a2 = v5 + 4;
  v6 = 0;
  *(_DWORD *)v5 = a3;
  *(_DWORD *)(v5 + 4) = a3 + 128;
  if ( a3 != -128 )
  {
    if ( *(_WORD *)(a3 + 128) )
    {
      sub_1004F8DE((int)&off_100674E0, dword_100677B8 - 1, (int *)(v5 + 4));
      v6 = 0;
    }
  }
  v10 = v6;
  if ( !*(_DWORD *)v5 || **(_WORD **)v5 == (_WORD)v6 )
  {
    if ( !*(_DWORD *)a2 || **(_WORD **)a2 == (_WORD)v6 )
    {
      v10 = 260;
      goto LABEL_23;
    }
    sub_1004F36E(v5, a2, (int)&v10);
LABEL_24:
    if ( !v10 )
      return 0;
    goto LABEL_25;
  }
  if ( *(_DWORD *)a2 && **(_WORD **)a2 != (_WORD)v6 )
    sub_1004F3AE(v5, a2, (int)&v10);
  else
    sub_1004F42B(v5, a2, (int)&v10);
  if ( !v10 )
  {
    if ( sub_1004F8DE((int)&off_10066A30, dword_100677B4 - 1, (int *)v5) )
    {
      if ( *(_DWORD *)a2 && **(_WORD **)a2 )
        sub_1004F3AE(v5, a2, (int)&v10);
      else
        sub_1004F42B(v5, a2, (int)&v10);
    }
    goto LABEL_24;
  }
LABEL_25:
  v7 = sub_1004F7C9(v5, a2, a3 != 0 ? a3 + 256 : 0, (int)&v10);
  v8 = v7;
  if ( v7 && v7 != 65000 && v7 != 65001 && IsValidCodePage((unsigned __int16)v7) && IsValidLocale(Locale, 1u) )
  {
    if ( a4 )
      *(_DWORD *)a4 = v8;
    sub_10039BB7(Locale, v5 + 592, 85);
    if ( !a5 )
      return 1;
    sub_10039BB7(Locale, a5 + 288, 85);
    if ( GetLocaleInfoW(Locale, 4097u, (LPWSTR)a5, 64) && GetLocaleInfoW(v12, 0x1002u, (LPWSTR)(a5 + 128), 64) )
    {
      sub_100547D4(a5, (int)GetLocaleInfoW, v8, a5 + 256, 0x10u, 0xAu);
      return 1;
    }
  }
  return 0;
}
// 10066A30: using guessed type wchar_t *off_10066A30;
// 100674E0: using guessed type wchar_t *off_100674E0;
// 100677B4: using guessed type int dword_100677B4;
// 100677B8: using guessed type int dword_100677B8;
// 10074200: using guessed type int __security_cookie;

//----- (1004FB64) --------------------------------------------------------
signed int __usercall sub_1004FB64<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // eax@3
  int v5; // eax@7
  signed int v6; // eax@10
  signed int v7; // ST08_4@10
  const CHAR *v8; // ST04_4@10
  int v9; // edx@10
  int v10; // ST00_4@10
  int v11; // eax@15
  signed int v12; // esi@15
  signed int result; // eax@23
  signed int *v14; // ecx@23

  if ( !a4 )
  {
    *(_DWORD *)sub_10037669(a3) = 22;
    sub_1003A16E(a3, 0);
    return -1;
  }
  v4 = *(_DWORD *)(a4 + 12);
  if ( !(v4 & 0x83) || v4 & 0x40 )
    return -1;
  if ( v4 & 2 )
  {
    *(_DWORD *)(a4 + 12) = v4 | 0x20;
    return -1;
  }
  v5 = v4 | 1;
  *(_DWORD *)(a4 + 12) = v5;
  if ( v5 & 0x10C )
    *(_DWORD *)a4 = *(_DWORD *)(a4 + 8);
  else
    sub_10050961(a1, a2, a3, a4);
  v7 = *(_DWORD *)(a4 + 24);
  v8 = *(const CHAR **)(a4 + 8);
  v6 = sub_1004FC85(a3, a4, a4);
  sub_10054B5D(v9, v10, a3, a4, v6, v8, v7);
  *(_DWORD *)(a4 + 4) = v6;
  if ( !v6 || v6 == -1 )
  {
    *(_DWORD *)(a4 + 12) |= v6 != 0 ? 32 : 16;
    *(_DWORD *)(a4 + 4) = 0;
    return -1;
  }
  if ( !(*(_BYTE *)(a4 + 12) & 0x82) )
  {
    if ( sub_1004FC85(a3, a4, a4) == -1 || sub_1004FC85(a3, a4, a4) == -2 )
    {
      v11 = (int)&unk_10075060;
    }
    else
    {
      v12 = sub_1004FC85(a3, a4, a4) >> 5;
      v11 = dword_100770A0[v12] + ((sub_1004FC85(a3, a4, a4) & 0x1F) << 6);
    }
    if ( (*(_BYTE *)(v11 + 4) & 0x82) == -126 )
      *(_DWORD *)(a4 + 12) |= 0x2000u;
  }
  if ( *(_DWORD *)(a4 + 24) == 512 )
  {
    if ( *(_BYTE *)(a4 + 12) & 8 )
    {
      if ( !(*(_DWORD *)(a4 + 12) & 0x400) )
        *(_DWORD *)(a4 + 24) = 4096;
    }
  }
  v14 = *(signed int **)a4;
  --*(_DWORD *)(a4 + 4);
  result = *(_BYTE *)v14;
  *(_DWORD *)a4 = (char *)v14 + 1;
  return result;
}
// 100770A0: using guessed type int dword_100770A0[];

//----- (1004FC85) --------------------------------------------------------
signed int __usercall sub_1004FC85<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  signed int result; // eax@2

  if ( a3 )
  {
    result = *(_DWORD *)(a3 + 16);
  }
  else
  {
    *(_DWORD *)sub_10037669(a1) = 22;
    sub_1003A16E(a1, a2);
    result = -1;
  }
  return result;
}

//----- (1004FCA9) --------------------------------------------------------
signed int __usercall sub_1004FCA9<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5)
{
  signed int v5; // eax@2
  int v7; // eax@24
  int v8; // eax@28

  if ( !(*(_BYTE *)(a5 + 12) & 0x40) )
  {
    v5 = sub_1004FC85(a3, -1, a5);
    if ( v5 == -1 || v5 == -2 )
      a1 = (int)&unk_10075060;
    else
      a1 = dword_100770A0[v5 >> 5] + ((v5 & 0x1F) << 6);
    if ( *(_BYTE *)(a1 + 36) & 0x7F
      || (v5 == -1 || v5 == -2 ? (a2 = (int)&unk_10075060) : (a2 = dword_100770A0[v5 >> 5] + ((v5 & 0x1F) << 6)),
          *(_BYTE *)(a2 + 36) & 0x80) )
    {
      *(_DWORD *)sub_10037669((int)&unk_10075060) = 22;
      sub_1003A16E((int)&unk_10075060, -1);
      return -1;
    }
  }
  if ( a4 == -1 || !(*(_BYTE *)(a5 + 12) & 1) && (!(*(_BYTE *)(a5 + 12) & 0x80) || *(_BYTE *)(a5 + 12) & 2) )
    return -1;
  if ( !*(_DWORD *)(a5 + 8) )
    sub_10050961(a1, a2, a4, a5);
  if ( *(_DWORD *)a5 == *(_DWORD *)(a5 + 8) )
  {
    if ( *(_DWORD *)(a5 + 4) )
      return -1;
    ++*(_DWORD *)a5;
  }
  --*(_DWORD *)a5;
  v7 = *(_DWORD *)a5;
  if ( *(_BYTE *)(a5 + 12) & 0x40 )
  {
    if ( *(_BYTE *)v7 != (_BYTE)a4 )
    {
      *(_DWORD *)a5 = v7 + 1;
      return -1;
    }
  }
  else
  {
    *(_BYTE *)v7 = a4;
  }
  v8 = *(_DWORD *)(a5 + 12);
  ++*(_DWORD *)(a5 + 4);
  *(_DWORD *)(a5 + 12) = v8 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a4;
}
// 100770A0: using guessed type int dword_100770A0[];

//----- (1004FD89) --------------------------------------------------------
signed int __usercall sub_1004FD89<eax>(int a1<edi>, LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int a4, int a5)
{
  signed int v6; // edi@11
  int v7; // edi@13
  char v8; // cf@14
  int v9; // [sp+8h] [bp-10h]@8
  int v10; // [sp+10h] [bp-8h]@23
  char v11; // [sp+14h] [bp-4h]@22

  if ( !lpMultiByteStr || !a4 )
    return 0;
  if ( !*lpMultiByteStr )
  {
    if ( lpWideCharStr )
      *lpWideCharStr = 0;
    return 0;
  }
  sub_1003018D((int)&v9, a4, a1, a5);
  if ( !*(_DWORD *)(v9 + 168) )
  {
    if ( lpWideCharStr )
      *lpWideCharStr = (unsigned __int8)*lpMultiByteStr;
    v6 = 1;
    goto LABEL_22;
  }
  if ( !sub_10042727(a4, a1, *lpMultiByteStr, (int)&v9) )
  {
    v6 = 1;
    if ( MultiByteToWideChar(*(_DWORD *)(v9 + 4), 9u, lpMultiByteStr, 1, lpWideCharStr, lpWideCharStr != 0) )
      goto LABEL_22;
    goto LABEL_21;
  }
  v7 = v9;
  if ( *(_DWORD *)(v9 + 116) <= 1 )
    goto LABEL_27;
  v8 = (unsigned int)a4 < *(_DWORD *)(v9 + 116);
  if ( a4 < *(_DWORD *)(v9 + 116) )
  {
LABEL_17:
    if ( !v8 && lpMultiByteStr[1] )
      goto LABEL_19;
LABEL_21:
    v6 = -1;
    *(_DWORD *)sub_10037669(a4) = 42;
    goto LABEL_22;
  }
  v7 = v9;
  if ( !MultiByteToWideChar(
          *(_DWORD *)(v9 + 4),
          9u,
          lpMultiByteStr,
          *(_DWORD *)(v9 + 116),
          lpWideCharStr,
          lpWideCharStr != 0) )
  {
LABEL_27:
    v8 = (unsigned int)a4 < *(_DWORD *)(v7 + 116);
    goto LABEL_17;
  }
LABEL_19:
  v6 = *(_DWORD *)(v7 + 116);
LABEL_22:
  if ( v11 )
    *(_DWORD *)(v10 + 112) &= 0xFFFFFFFDu;
  return v6;
}

//----- (1004FE7C) --------------------------------------------------------
signed int __usercall sub_1004FE7C<eax>(int a1<edi>, LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int a4)
{
  return sub_1004FD89(a1, lpWideCharStr, lpMultiByteStr, a4, 0);
}

//----- (1004FE94) --------------------------------------------------------
int __usercall sub_1004FE94<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  if ( a3 == -2 )
  {
    *(_DWORD *)sub_10037669(a1) = 9;
  }
  else
  {
    if ( a3 >= 0 && a3 < (unsigned int)dword_10077A98 )
      return *(_BYTE *)(dword_100770A0[a3 >> 5] + ((a3 & 0x1F) << 6) + 4) & 0x40;
    *(_DWORD *)sub_10037669(a1) = 9;
    sub_1003A16E(a1, a2);
  }
  return 0;
}
// 100770A0: using guessed type int dword_100770A0[];
// 10077A98: using guessed type int dword_10077A98;

//----- (1004FEE8) --------------------------------------------------------
void __usercall sub_1004FEE8(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, const void *a6, int nNumberOfBytesToWrite)
{
  int v7; // [sp-4h] [bp-34h]@6

  if ( a5 == -2 )
  {
    *(_DWORD *)sub_10037635(a3) = 0;
    *(_DWORD *)sub_10037669(a3) = 9;
  }
  else
  {
    if ( a5 >= 0
      && a5 < (unsigned int)dword_10077A98
      && (a3 = a5 >> 5, a4 = (a5 & 0x1F) << 6, *(_BYTE *)(dword_100770A0[a5 >> 5] + a4 + 4) & 1) )
    {
      sub_100553F4(a1, a2, a3, a5);
      if ( *(_BYTE *)(dword_100770A0[a3] + a4 + 4) & 1 )
      {
        sub_1004FFCA(v7, a3, a4, a5, a5, a6, nNumberOfBytesToWrite);
      }
      else
      {
        *(_DWORD *)sub_10037669(a3) = 9;
        *(_DWORD *)sub_10037635(a3) = 0;
      }
      sub_1005556D(a5);
    }
    else
    {
      *(_DWORD *)sub_10037635(a3) = 0;
      *(_DWORD *)sub_10037669(a3) = 9;
      sub_1003A16E(a3, a4);
    }
  }
}
// 100770A0: using guessed type int dword_100770A0[];
// 10077A98: using guessed type int dword_10077A98;

//----- (1004FFCA) --------------------------------------------------------
int __usercall sub_1004FFCA<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<esi>, signed int a5, const void *a6, int nNumberOfBytesToWrite)
{
  signed int v7; // eax@1
  int v8; // edi@1
  int v10; // ecx@5
  int v11; // esi@5
  unsigned __int8 v12; // zf@14
  UINT v13; // eax@17
  LPCVOID v14; // edx@17
  const CHAR *v15; // ecx@17
  int v16; // eax@18
  int v17; // edx@20
  unsigned __int8 v18; // cl@20
  LPCSTR v19; // eax@25
  int v20; // eax@29
  unsigned __int8 v21; // zf@38
  signed __int16 v22; // ax@41
  signed __int16 v23; // ax@43
  int v24; // esi@49
  int v25; // eax@51
  LPCVOID v26; // eax@53
  int v27; // eax@54
  char *v28; // edx@54
  char *v29; // ebx@54
  char v30; // cl@56
  int v31; // ecx@56
  char v32; // zf@56
  DWORD v33; // ecx@63
  int v34; // eax@65
  unsigned int v35; // edx@65
  char *v36; // ebx@65
  int v37; // edi@65
  __int16 v38; // si@67
  char *v39; // eax@75
  unsigned int v40; // edx@75
  int v41; // ecx@75
  DWORD v42; // esi@75
  __int16 v43; // di@77
  const CHAR *v44; // eax@80
  int v45; // ecx@81
  DWORD v46; // eax@85
  UINT v47; // [sp+0h] [bp-1AF0h]@17
  int v48; // [sp+4h] [bp-1AECh]@5
  DWORD Mode; // [sp+Ch] [bp-1AE4h]@14
  char v50; // [sp+13h] [bp-1ADDh]@56
  DWORD NumberOfBytesWritten; // [sp+14h] [bp-1ADCh]@17
  int v52; // [sp+18h] [bp-1AD8h]@59
  int v53; // [sp+1Ch] [bp-1AD4h]@1
  int v54; // [sp+20h] [bp-1AD0h]@5
  LPCSTR lpMultiByteStr; // [sp+24h] [bp-1ACCh]@17
  int v56; // [sp+28h] [bp-1AC8h]@18
  const WCHAR WideCharStr[2]; // [sp+2Ch] [bp-1AC4h]@1
  const void *v58; // [sp+30h] [bp-1AC0h]@1
  LPCVOID lpBuffer; // [sp+34h] [bp-1ABCh]@1
  char v60; // [sp+38h] [bp-1AB8h]@54
  CHAR MultiByteStr[3416]; // [sp+6E0h] [bp-1410h]@80
  char v62; // [sp+1438h] [bp-6B8h]@75
  void *v63; // [sp+1AD0h] [bp-20h]@30
  char *v64; // [sp+1AD4h] [bp-1Ch]@30
  LPCSTR v65[3]; // [sp+1AD8h] [bp-18h]@14
  signed int v66; // [sp+1AE0h] [bp-10h]@14
  int Buffer; // [sp+1AE4h] [bp-Ch]@5
  int v68; // [sp+1AE8h] [bp-8h]@5
  int v69; // [sp+1AECh] [bp-4h]@1

  sub_1004D2F0(0x1AF0u, a1);
  v7 = a5;
  v69 = a3;
  v8 = 0;
  v58 = (const void *)a5;
  lpBuffer = a6;
  *(_DWORD *)WideCharStr = 0;
  v53 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a6 )
  {
    *(_DWORD *)sub_10037635(a2) = 0;
    *(_DWORD *)sub_10037669(a2) = 22;
    sub_1003A16E(a2, 0);
    return -1;
  }
  v68 = a2;
  Buffer = a4;
  v11 = (a5 & 0x1F) << 6;
  v54 = a5 >> 5;
  v10 = dword_100770A0[a5 >> 5];
  v48 = v11;
  LOBYTE(a2) = (char)(2 * *(_BYTE *)(v11 + v10 + 36)) >> 1;
  if ( (_BYTE)a2 == 2 || (_BYTE)a2 == 1 )
  {
    if ( !(~(_BYTE)nNumberOfBytesToWrite & 1) )
    {
      *(_DWORD *)sub_10037635(a2) = 0;
      *(_DWORD *)sub_10037669(a2) = 22;
      sub_1003A16E(a2, 0);
      return -1;
    }
    v7 = (signed int)v58;
  }
  if ( *(_BYTE *)(v11 + v10 + 4) & 0x20 )
    sub_100508F0(a2, 0, v7, 0i64, 2u);
  if ( !sub_1004FE94(a2, 0, (signed int)v58)
    || !(*(_BYTE *)(v11 + dword_100770A0[v54] + 4) & 0x80)
    || (v12 = *(_DWORD *)(*(_DWORD *)(sub_10041A5C(a2, 0) + 108) + 168) == 0,
        v66 = (signed int)&Mode,
        v65[1] = *(LPCSTR *)(v11 + dword_100770A0[v54]),
        v58 = (const void *)v12,
        !GetConsoleMode((HANDLE)v65[1], &Mode))
    || v58 && !(_BYTE)a2 )
  {
    v25 = dword_100770A0[v54];
    if ( *(_BYTE *)(v11 + v25 + 4) & 0x80 )
    {
      v14 = lpBuffer;
      v24 = 0;
      v56 = 0;
      if ( (_BYTE)a2 )
      {
        v33 = (DWORD)lpBuffer;
        if ( (_BYTE)a2 == 2 )
        {
          v58 = lpBuffer;
          if ( (unsigned int)nNumberOfBytesToWrite <= 0 )
            goto LABEL_98;
          while ( 1 )
          {
            Mode = 0;
            v37 = v53;
            v34 = v33 - (_DWORD)v14;
            v35 = 0;
            v36 = &v60;
            do
            {
              if ( v34 >= (unsigned int)nNumberOfBytesToWrite )
                break;
              v38 = *(_WORD *)v33;
              v33 += 2;
              v34 += 2;
              v58 = (const void *)v33;
              if ( v38 == 10 )
              {
                *(_WORD *)v36 = 13;
                v33 = (DWORD)v58;
                v37 += 2;
                v36 += 2;
                v35 += 2;
              }
              *(_WORD *)v36 = v38;
              v35 += 2;
              v36 += 2;
            }
            while ( v35 < 0x13FE );
            a2 = v36 - &v60;
            v66 = 0;
            v65[1] = (LPCSTR)&v52;
            v65[0] = (LPCSTR)a2;
            v64 = &v60;
            v53 = v37;
            v63 = *(void **)(v48 + dword_100770A0[v54]);
            v24 = v56;
            v8 = *(_DWORD *)WideCharStr;
            if ( !WriteFile(v63, &v60, a2, (LPDWORD)&v52, 0) )
              break;
            v8 = v52 + *(_DWORD *)WideCharStr;
            v14 = lpBuffer;
            *(_DWORD *)WideCharStr += v52;
            if ( v52 >= a2 )
            {
              v33 = (DWORD)v58;
              if ( v58 - lpBuffer < nNumberOfBytesToWrite )
                continue;
            }
            goto LABEL_93;
          }
        }
        else
        {
          a2 = nNumberOfBytesToWrite;
          NumberOfBytesWritten = (DWORD)lpBuffer;
          if ( !nNumberOfBytesToWrite )
            goto LABEL_98;
          while ( 1 )
          {
            Mode = 0;
            v42 = NumberOfBytesWritten;
            v41 = v33 - (_DWORD)v14;
            v40 = 0;
            v39 = &v62;
            do
            {
              if ( v41 >= (unsigned int)nNumberOfBytesToWrite )
                break;
              v43 = *(_WORD *)v42;
              v42 += 2;
              v41 += 2;
              NumberOfBytesWritten = v42;
              if ( v43 == 10 )
              {
                *(_WORD *)v39 = 13;
                v42 = NumberOfBytesWritten;
                v39 += 2;
                v40 += 2;
              }
              *(_WORD *)v39 = v43;
              v40 += 2;
              v39 += 2;
            }
            while ( v40 < 0x6A8 );
            v44 = (const CHAR *)WideCharToMultiByte(
                                  0xFDE9u,
                                  0,
                                  (LPCWSTR)&v62,
                                  (signed int)(v39 - &v62) / 2,
                                  MultiByteStr,
                                  3413,
                                  0,
                                  0);
            v24 = v56;
            v8 = *(_DWORD *)WideCharStr;
            lpMultiByteStr = v44;
            if ( !v44 )
              break;
            v45 = 0;
            v58 = 0;
            while ( 1 )
            {
              v66 = 0;
              v65[1] = (LPCSTR)&v52;
              v65[0] = &v44[-v45];
              v64 = &MultiByteStr[v45];
              v63 = *(void **)(v48 + dword_100770A0[v54]);
              if ( !WriteFile(v63, &MultiByteStr[v45], (DWORD)&v44[-v45], (LPDWORD)&v52, 0) )
                break;
              v45 = (int)((char *)v58 + v52);
              v44 = lpMultiByteStr;
              v58 = (const void *)v45;
              if ( (signed int)lpMultiByteStr <= v45 )
                goto LABEL_86;
            }
            v46 = GetLastError();
            v45 = (int)v58;
            v24 = v46;
            v44 = lpMultiByteStr;
            v56 = v24;
LABEL_86:
            if ( (signed int)v44 > v45 )
              goto LABEL_92;
            v33 = NumberOfBytesWritten;
            v14 = lpBuffer;
            v8 = NumberOfBytesWritten - (_DWORD)lpBuffer;
            *(_DWORD *)WideCharStr = NumberOfBytesWritten - (_DWORD)lpBuffer;
            if ( NumberOfBytesWritten - (_DWORD)lpBuffer >= nNumberOfBytesToWrite )
              goto LABEL_93;
          }
        }
      }
      else
      {
        v26 = lpBuffer;
        *(_DWORD *)WideCharStr = lpBuffer;
        if ( (unsigned int)nNumberOfBytesToWrite <= 0 )
          goto LABEL_98;
        while ( 1 )
        {
          v27 = v26 - v14;
          v28 = *(char **)WideCharStr;
          v29 = &v60;
          v58 = 0;
          do
          {
            if ( v27 >= (unsigned int)nNumberOfBytesToWrite )
              break;
            v30 = *v28;
            ++v27;
            v50 = v30;
            v32 = v30 == 10;
            v31 = (int)v58;
            *(_DWORD *)WideCharStr = v28 + 1;
            if ( v32 )
            {
              ++v53;
              *v29++ = 13;
              ++v31;
            }
            *v29 = v50;
            v28 = *(char **)WideCharStr;
            ++v29;
            v58 = (const void *)(v31 + 1);
          }
          while ( (unsigned int)(v31 + 1) < 0x13FF );
          a2 = v29 - &v60;
          v66 = 0;
          v65[1] = (LPCSTR)&v52;
          v65[0] = (LPCSTR)a2;
          v64 = &v60;
          v63 = *(void **)(v48 + dword_100770A0[v54]);
          if ( !WriteFile(v63, &v60, a2, (LPDWORD)&v52, 0) )
            break;
          v8 += v52;
          v14 = lpBuffer;
          if ( v52 >= a2 )
          {
            v26 = *(LPCVOID *)WideCharStr;
            if ( *(_DWORD *)WideCharStr - (_DWORD)lpBuffer < (unsigned int)nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_93;
        }
      }
    }
    else
    {
      v66 = 0;
      v65[1] = (LPCSTR)&v52;
      v65[0] = (LPCSTR)nNumberOfBytesToWrite;
      v64 = (char *)lpBuffer;
      v63 = *(void **)(v11 + v25);
      if ( WriteFile(v63, lpBuffer, nNumberOfBytesToWrite, (LPDWORD)&v52, 0) )
      {
        v8 = v52;
        v24 = 0;
        goto LABEL_92;
      }
    }
LABEL_91:
    v24 = GetLastError();
    goto LABEL_92;
  }
  v13 = GetConsoleCP();
  v14 = lpBuffer;
  NumberOfBytesWritten = 0;
  v15 = (const CHAR *)lpBuffer;
  v47 = v13;
  lpMultiByteStr = (LPCSTR)lpBuffer;
  if ( (unsigned int)nNumberOfBytesToWrite <= 0 )
  {
    v24 = (int)v58;
    goto LABEL_94;
  }
  v16 = 0;
  v56 = 0;
  while ( (_BYTE)a2 )
  {
    if ( (_BYTE)a2 == 1 || (_BYTE)a2 == 2 )
    {
      v21 = *(_WORD *)v15 == 10;
      *(_DWORD *)WideCharStr = *(_WORD *)v15;
      v15 += 2;
      v16 = v56 + 2;
      lpMultiByteStr = v15;
      v56 += 2;
      v58 = (const void *)v21;
    }
    if ( (_BYTE)a2 != 1 && (_BYTE)a2 != 2 )
      goto LABEL_46;
    v22 = sub_10055593((DWORD)v15, WideCharStr[0]);
    if ( v22 != WideCharStr[0] )
      goto LABEL_91;
    v8 += 2;
    if ( v58 )
    {
      *(_DWORD *)WideCharStr = 13;
      v23 = sub_10055593(v66, 13);
      if ( v23 != WideCharStr[0] )
        goto LABEL_91;
      ++v8;
      ++v53;
    }
LABEL_45:
    v16 = v56;
    v15 = lpMultiByteStr;
LABEL_46:
    if ( v16 >= (unsigned int)nNumberOfBytesToWrite )
      goto LABEL_49;
  }
  v18 = *v15;
  v58 = (const void *)(v18 == 10);
  v17 = dword_100770A0[v54];
  if ( *(_DWORD *)(v11 + v17 + 56) )
  {
    LOBYTE(Buffer) = *(_BYTE *)(v11 + v17 + 52);
    v66 = 2;
    BYTE1(Buffer) = v18;
    *(_DWORD *)(v11 + v17 + 56) = 0;
    v65[1] = (LPCSTR)&Buffer;
LABEL_27:
    if ( sub_1004FE7C(v8, (LPWSTR)WideCharStr, v65[1], v66) == -1 )
      goto LABEL_49;
    v19 = lpMultiByteStr;
LABEL_29:
    ++v56;
    lpMultiByteStr = v19 + 1;
    v20 = WideCharToMultiByte(v47, 0, WideCharStr, 1, (LPSTR)&Buffer, 5, 0, 0);
    Mode = v20;
    if ( !v20 )
      goto LABEL_49;
    v66 = 0;
    v65[1] = (LPCSTR)&NumberOfBytesWritten;
    v65[0] = (LPCSTR)v20;
    v64 = (char *)&Buffer;
    v63 = *(void **)(v11 + dword_100770A0[v54]);
    if ( !WriteFile(v63, &Buffer, v20, &NumberOfBytesWritten, 0) )
      goto LABEL_91;
    v8 = v53 + v56;
    if ( (signed int)NumberOfBytesWritten < (signed int)Mode )
      goto LABEL_49;
    if ( v58 )
    {
      v66 = 0;
      v65[1] = (LPCSTR)&NumberOfBytesWritten;
      v65[0] = (LPCSTR)1;
      v64 = (char *)&Buffer;
      LOBYTE(Buffer) = 13;
      v63 = *(void **)(v11 + dword_100770A0[v54]);
      if ( !WriteFile(v63, &Buffer, 1u, &NumberOfBytesWritten, 0) )
        goto LABEL_91;
      if ( (signed int)NumberOfBytesWritten < 1 )
        goto LABEL_49;
      ++v53;
      ++v8;
    }
    goto LABEL_45;
  }
  if ( !sub_1004275D(a2, v8, v18) )
  {
    v66 = 1;
    v65[1] = lpMultiByteStr;
    goto LABEL_27;
  }
  if ( nNumberOfBytesToWrite + lpBuffer - lpMultiByteStr > 1 )
  {
    if ( sub_1004FE7C(v8, (LPWSTR)WideCharStr, lpMultiByteStr, 2) == -1 )
      goto LABEL_49;
    v19 = lpMultiByteStr + 1;
    ++v56;
    goto LABEL_29;
  }
  a2 = v54;
  ++v8;
  *(_BYTE *)(v11 + dword_100770A0[v54] + 52) = *lpMultiByteStr;
  *(_DWORD *)(v11 + dword_100770A0[a2] + 56) = 1;
LABEL_49:
  v24 = (int)v58;
LABEL_92:
  v14 = lpBuffer;
LABEL_93:
  if ( v8 )
    return v8 - v53;
LABEL_94:
  if ( v24 )
  {
    if ( v24 == 5 )
    {
      *(_DWORD *)sub_10037669(5) = 9;
      *(_DWORD *)sub_10037635(5) = 5;
    }
    else
    {
      sub_10037648(5, v24);
    }
    return -1;
  }
LABEL_98:
  if ( !(*(_BYTE *)(v48 + dword_100770A0[v54] + 4) & 0x40) || *(_BYTE *)v14 != 26 )
  {
    *(_DWORD *)sub_10037669(a2) = 28;
    *(_DWORD *)sub_10037635(a2) = 0;
    return -1;
  }
  return 0;
}
// 100770A0: using guessed type int dword_100770A0[];
// 1004FFCA: using guessed type CHAR MultiByteStr[3416];

//----- (100507F4) --------------------------------------------------------
void __usercall sub_100507F4(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, LARGE_INTEGER liDistanceToMove, DWORD dwMoveMethod)
{
  if ( a4 == -2 )
  {
    *(_DWORD *)sub_10037635(a3) = 0;
    *(_DWORD *)sub_10037669(a3) = 9;
  }
  else
  {
    if ( a4 >= 0
      && a4 < (unsigned int)dword_10077A98
      && (a3 = (a4 & 0x1F) << 6, *(_BYTE *)(dword_100770A0[a4 >> 5] + a3 + 4) & 1) )
    {
      sub_100553F4(a1, a2, a3, a4);
      if ( *(_BYTE *)(dword_100770A0[a4 >> 5] + a3 + 4) & 1 )
      {
        sub_100508F0(a3, a4, a4, liDistanceToMove, dwMoveMethod);
      }
      else
      {
        *(_DWORD *)sub_10037669(a3) = 9;
        *(_DWORD *)sub_10037635(a3) = 0;
      }
      sub_1005556D(a4);
    }
    else
    {
      *(_DWORD *)sub_10037635(a3) = 0;
      *(_DWORD *)sub_10037669(a3) = 9;
      sub_1003A16E(a3, a4);
    }
  }
}
// 100770A0: using guessed type int dword_100770A0[];
// 10077A98: using guessed type int dword_10077A98;

//----- (100508F0) --------------------------------------------------------
LARGE_INTEGER __usercall sub_100508F0<edx:eax>(int a1<ebx>, int a2<edi>, signed int a3, LARGE_INTEGER liDistanceToMove, DWORD dwMoveMethod)
{
  void *v5; // eax@1
  int v7; // eax@5
  LARGE_INTEGER NewFilePointer; // [sp+8h] [bp-8h]@4

  v5 = (void *)sub_10055506(a1, a2, a3);
  if ( v5 == (void *)-1 )
  {
    *(_DWORD *)sub_10037669(a1) = 9;
    return (LARGE_INTEGER)-1i64;
  }
  if ( !SetFilePointerEx(v5, liDistanceToMove, &NewFilePointer, dwMoveMethod) )
  {
    v7 = GetLastError();
    sub_10037648(a1, v7);
    return (LARGE_INTEGER)-1i64;
  }
  *(_BYTE *)(dword_100770A0[a3 >> 5] + ((a3 & 0x1F) << 6) + 4) &= 0xFDu;
  return NewFilePointer;
}
// 100770A0: using guessed type int dword_100770A0[];

//----- (10050961) --------------------------------------------------------
int __usercall sub_10050961<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // eax@1
  int result; // eax@4

  ++dword_10077098;
  v4 = sub_10037550(a1, a2, a3, 4096);
  *(_DWORD *)(a4 + 8) = v4;
  if ( v4 )
  {
    *(_DWORD *)(a4 + 12) |= 8u;
    *(_DWORD *)(a4 + 24) = 4096;
  }
  else
  {
    *(_DWORD *)(a4 + 12) |= 4u;
    *(_DWORD *)(a4 + 8) = a4 + 20;
    *(_DWORD *)(a4 + 24) = 2;
  }
  result = *(_DWORD *)(a4 + 8);
  *(_DWORD *)(a4 + 4) = 0;
  *(_DWORD *)a4 = result;
  return result;
}
// 10077098: using guessed type int dword_10077098;

//----- (100509A7) --------------------------------------------------------
signed int __cdecl sub_100509A7(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@1
  signed int v6; // eax@3
  signed int v7; // ecx@3
  int v8; // edx@5
  int v9; // ecx@10
  int v10; // edx@13
  signed int result; // eax@14
  int v12; // ecx@14
  int v13; // esi@15
  int v14; // eax@18
  unsigned int v15; // eax@20
  int v16; // eax@35
  int v17; // eax@40
  char v18; // al@52
  int v19; // eax@64
  signed int v20; // eax@78
  int i; // eax@89
  signed int v22; // eax@92
  int v23; // eax@102
  int v24; // ST1C_4@108
  int v25; // esi@127
  int v26; // eax@134
  int v27; // edi@134
  int v28; // eax@138
  int v29; // edi@138
  int v30; // ST18_4@138
  int v31; // ST14_4@138
  int v32; // ST10_4@138
  int v33; // ST0C_4@138
  PVOID v34; // eax@138
  PVOID v35; // eax@140
  PVOID v36; // eax@143
  int v37; // edi@154
  int v38; // eax@156
  signed int v39; // edx@169
  char *k; // esi@175
  int v41; // ecx@178
  unsigned __int64 v42; // ST10_8@178
  int v43; // eax@178
  int v44; // ecx@178
  int v45; // edx@178
  int v46; // eax@181
  int j; // eax@187
  int v48; // eax@202
  int v49; // eax@207
  const WCHAR v50; // ST1C_2@210
  signed int v51; // eax@214
  signed int v52; // [sp-4h] [bp-290h]@147
  int v53; // [sp+Ch] [bp-280h]@138
  int v54; // [sp+10h] [bp-27Ch]@138
  char v55; // [sp+14h] [bp-278h]@1
  int v56; // [sp+1Ch] [bp-270h]@228
  char v57; // [sp+20h] [bp-26Ch]@227
  int v58; // [sp+28h] [bp-264h]@15
  int v59; // [sp+2Ch] [bp-260h]@22
  int v60; // [sp+30h] [bp-25Ch]@210
  int v61; // [sp+34h] [bp-258h]@1
  int v62; // [sp+38h] [bp-254h]@1
  LPVOID lpMem; // [sp+3Ch] [bp-250h]@14
  int v64; // [sp+40h] [bp-24Ch]@14
  int v65; // [sp+44h] [bp-248h]@1
  int v66; // [sp+48h] [bp-244h]@1
  int v67; // [sp+4Ch] [bp-240h]@78
  unsigned int v68; // [sp+50h] [bp-23Ch]@14
  int v69; // [sp+54h] [bp-238h]@1
  int v70; // [sp+58h] [bp-234h]@1
  int v71; // [sp+5Ch] [bp-230h]@1
  int v72; // [sp+60h] [bp-22Ch]@1
  char v73; // [sp+64h] [bp-228h]@153
  char v74; // [sp+65h] [bp-227h]@153
  int v75; // [sp+68h] [bp-224h]@14
  int v76; // [sp+6Ch] [bp-220h]@1
  int v77; // [sp+70h] [bp-21Ch]@14
  int v78; // [sp+74h] [bp-218h]@1
  int v79; // [sp+78h] [bp-214h]@1
  char v80; // [sp+7Fh] [bp-20Dh]@14
  CHAR UsedDefaultChar; // [sp+80h] [bp-20Ch]@78
  char v82; // [sp+27Fh] [bp-Dh]@175
  char v83; // [sp+280h] [bp-Ch]@210
  unsigned int v84; // [sp+288h] [bp-4h]@1
  int v85; // [sp+28Ch] [bp+0h]@1

  v84 = (unsigned int)&v85 ^ __security_cookie;
  v5 = a4;
  v70 = a2;
  v4 = 0;
  v72 = a1;
  v78 = a4;
  v62 = 0;
  v79 = 0;
  v69 = 0;
  v76 = 0;
  v71 = 0;
  v65 = 0;
  v66 = 0;
  sub_1003018D((int)&v55, 0, a4, a3);
  v61 = sub_10037669(0);
  if ( !a1
    || !(*(_BYTE *)(a1 + 12) & 0x40)
    && ((v7 = sub_1004FC85(0, a4, a1), v6 = -1, v7 == -1) || v7 == -2 ? (v8 = (int)&unk_10075060) : (v8 = dword_100770A0[v7 >> 5] + ((v7 & 0x1F) << 6), v6 = -1),
        *(_BYTE *)(v8 + 36) & 0x7F
     || (v7 == v6 || v7 == -2 ? (v9 = (int)&unk_10075060) : (v9 = dword_100770A0[v7 >> 5] + ((v7 & 0x1F) << 6)),
         *(_BYTE *)(v9 + 36) & 0x80))
    || (v10 = v70, !v70) )
    goto LABEL_226;
  result = 0;
  v77 = 0;
  v68 = 0;
  lpMem = 0;
  v12 = *(_BYTE *)v70;
  v75 = 0;
  v80 = v12;
  LOBYTE(v64) = v12;
  if ( (_BYTE)v12 )
  {
    v13 = v58;
    while ( 1 )
    {
      ++v10;
      v70 = v10;
      if ( result < 0 )
        break;
      if ( (unsigned __int8)(v12 - 32) > 0x58u )
        v14 = 0;
      else
        v14 = *((_BYTE *)&aAcp[2] + (char)v12) & 0xF;
      v15 = (unsigned int)(unsigned __int8)*(&byte_100677E0[9 * v14] + v68) >> 4;
      v5 = v78;
      v68 = v15;
      if ( v15 == 8 )
        goto LABEL_226;
      switch ( v15 )
      {
        case 1u:
          v76 = -1;
          v4 = 0;
          v59 = 0;
          v65 = 0;
          v69 = 0;
          v71 = 0;
          v79 = 0;
          v66 = 0;
          goto LABEL_223;
        case 2u:
          switch ( (char)v12 )
          {
            case 32:
              v4 |= 2u;
              break;
            case 35:
              v4 |= 0x80u;
              break;
            case 43:
              v4 |= 1u;
              break;
            case 45:
              v4 |= 4u;
              break;
            default:
              if ( (char)v12 != 48 )
                goto LABEL_223;
              v4 |= 8u;
              break;
          }
          goto LABEL_33;
        case 3u:
          if ( (_BYTE)v12 == 42 )
          {
            v16 = *(_DWORD *)v78;
            v5 = v78 + 4;
            v78 += 4;
            v69 = v16;
            if ( v16 < 0 )
            {
              v4 |= 4u;
              v79 = v4;
              v69 = -v16;
            }
          }
          else
          {
            v69 *= 10;
            v12 = (char)v12 + v69 - 48;
            v69 = v12;
          }
          goto LABEL_223;
        case 4u:
          v76 = 0;
          goto LABEL_223;
        case 5u:
          if ( (_BYTE)v12 != 42 )
          {
            v76 = (char)v12 + 10 * v76 - 48;
            goto LABEL_222;
          }
          v17 = *(_DWORD *)v78;
          v5 = v78 + 4;
          v78 += 4;
          v76 = v17;
          if ( v17 < 0 )
            v76 = -1;
          goto LABEL_223;
        case 6u:
          if ( (_BYTE)v12 == 73 )
          {
            v18 = *(_BYTE *)v10;
            if ( *(_BYTE *)v10 == 54 && *(_BYTE *)(v10 + 1) == 52 )
            {
              v10 += 2;
              v4 |= 0x8000u;
              goto LABEL_33;
            }
            if ( v18 == 51 && *(_BYTE *)(v10 + 1) == 50 )
            {
              v10 += 2;
              v4 &= 0xFFFF7FFFu;
              goto LABEL_33;
            }
            if ( v18 != 100 && v18 != 105 && v18 != 111 && v18 != 117 && v18 != 120 && v18 != 88 )
            {
              v19 = 0;
              v68 = 0;
LABEL_66:
              v66 = v19;
              if ( sub_10042727(v4, v78, v12, (int)&v55) )
              {
                sub_1005150F(v4, v5, v64, v72, (int)&v75);
                LOBYTE(v64) = *(_BYTE *)v70++;
                if ( !(_BYTE)v64 )
                  goto LABEL_226;
              }
              sub_1005150F(v4, v5, v64, v72, (int)&v75);
              goto LABEL_222;
            }
          }
          else
          {
            if ( (_BYTE)v12 == 104 )
            {
              v4 |= 0x20u;
              goto LABEL_33;
            }
            if ( (_BYTE)v12 == 108 )
            {
              if ( *(_BYTE *)v10 == 108 )
              {
                ++v10;
                v4 |= 0x1000u;
              }
              else
              {
                v4 |= 0x10u;
              }
              goto LABEL_33;
            }
            if ( (_BYTE)v12 == 119 )
            {
              v4 |= 0x800u;
LABEL_33:
              v79 = v4;
              goto LABEL_223;
            }
          }
          goto LABEL_223;
        case 0u:
          v19 = 0;
          goto LABEL_66;
        case 7u:
          if ( (char)v12 <= 100 )
          {
            if ( (char)v12 == 100 )
            {
LABEL_123:
              v4 |= 0x40u;
              v79 = v4;
              goto LABEL_124;
            }
            if ( (char)v12 <= 83 )
            {
              if ( (char)v12 == 83 )
              {
                if ( !(v4 & 0x830) )
                {
                  v4 |= 0x800u;
                  v79 = v4;
                }
                goto LABEL_84;
              }
              if ( (char)v12 != 65 )
              {
                if ( (char)v12 != 67 )
                {
                  if ( (char)v12 != 69 && (char)v12 != 71 )
                    goto LABEL_193;
                  goto LABEL_77;
                }
                if ( !(v4 & 0x830) )
                {
                  v4 |= 0x800u;
                  v79 = v4;
                }
LABEL_97:
                v5 = v78 + 4;
                v78 += 4;
                if ( v4 & 0x810 )
                {
                  if ( sub_10051730((int)&v77, &UsedDefaultChar, 512, *(_WORD *)(v5 - 4)) )
                    v65 = 1;
                }
                else
                {
                  UsedDefaultChar = *(_BYTE *)(v5 - 4);
                  v77 = 1;
                }
                v13 = (int)&UsedDefaultChar;
                goto LABEL_193;
              }
LABEL_77:
              LOBYTE(v12) = v12 + 32;
              v59 = 1;
              v80 = v12;
              goto LABEL_78;
            }
            if ( (char)v12 == 88 )
              goto LABEL_147;
            if ( (char)v12 == 90 )
            {
              v23 = *(_DWORD *)v78;
              v5 = v78 + 4;
              v78 += 4;
              if ( v23 )
              {
                v13 = *(_DWORD *)(v23 + 4);
                if ( v13 )
                {
                  v22 = *(_WORD *)v23;
                  if ( v4 & 0x800 )
                  {
                    v22 /= 2;
                    v66 = 1;
                  }
                  else
                  {
                    v12 = 0;
                    v66 = 0;
                  }
                  goto LABEL_192;
                }
              }
              v13 = (int)off_10074C14;
            }
            else
            {
              if ( (char)v12 != 97 )
              {
                if ( (char)v12 != 99 )
                  goto LABEL_193;
                goto LABEL_97;
              }
LABEL_78:
              v20 = v76;
              v4 |= 0x40u;
              v79 = v4;
              v13 = (int)&UsedDefaultChar;
              v67 = 512;
              if ( v76 >= 0 )
              {
                if ( v76 )
                {
                  if ( v76 > 512 )
                  {
                    v20 = 512;
                    v76 = 512;
                  }
                  if ( v20 > 163 )
                  {
                    v27 = v20 + 349;
                    v26 = sub_10037550(512, v12, v4, v20 + 349);
                    LOBYTE(v12) = v80;
                    lpMem = (LPVOID)v26;
                    if ( v26 )
                    {
                      v13 = v26;
                      v67 = v27;
                    }
                    else
                    {
                      v76 = 163;
                    }
                    v5 = v78;
                  }
                }
                else
                {
                  if ( (_BYTE)v12 == 103 )
                    v76 = 1;
                }
              }
              else
              {
                v76 = 6;
              }
              v28 = *(_DWORD *)v5;
              v29 = v5 + 8;
              v53 = v28;
              v54 = *(_DWORD *)(v29 - 4);
              v30 = v59;
              v31 = v76;
              v78 = v29;
              v32 = (char)v12;
              v33 = v67;
              v34 = DecodePointer(off_100751E4);
              ((void (__cdecl *)(int *, int, int, int, int, int, char *))v34)(&v53, v13, v33, v32, v31, v30, &v55);
              v5 = v4 & 0x80;
              if ( v4 & 0x80 )
              {
                if ( !v76 )
                {
                  v35 = DecodePointer(off_100751F0);
                  ((void (__cdecl *)(int, char *))v35)(v13, &v55);
                }
              }
              if ( v80 == 103 )
              {
                if ( !(v4 & 0x80) )
                {
                  v36 = DecodePointer(off_100751EC);
                  ((void (__cdecl *)(int, char *))v36)(v13, &v55);
                }
              }
              if ( *(_BYTE *)v13 == 45 )
              {
                v4 |= 0x100u;
                v79 = v4;
                ++v13;
              }
            }
            v22 = sub_10035550(v13);
            v12 = v24;
            goto LABEL_192;
          }
          if ( (char)v12 > 112 )
          {
            if ( (char)v12 != 115 )
            {
              if ( (char)v12 != 117 )
              {
                if ( (char)v12 != 120 )
                  goto LABEL_193;
                v52 = 39;
                goto LABEL_152;
              }
LABEL_124:
              v77 = 10;
              goto LABEL_125;
            }
LABEL_84:
            v12 = 2147483647;
            if ( v76 != -1 )
              v12 = v76;
            v13 = *(_DWORD *)v78;
            v5 = v78 + 4;
            v78 += 4;
            if ( v4 & 0x810 )
            {
              if ( !v13 )
                v13 = (int)off_10074C18;
              v66 = 1;
              for ( i = v13; v12; i += 2 )
              {
                --v12;
                if ( !*(_WORD *)i )
                  break;
              }
              v22 = (i - v13) >> 1;
            }
            else
            {
              if ( !v13 )
                v13 = (int)off_10074C14;
              for ( j = v13; ; ++j )
              {
                if ( v12 )
                {
                  --v12;
                  if ( *(_BYTE *)j )
                    continue;
                }
                break;
              }
              v22 = j - v13;
            }
LABEL_192:
            v77 = v22;
            goto LABEL_193;
          }
          if ( (char)v12 == 112 )
          {
            v76 = 8;
LABEL_147:
            v52 = 7;
LABEL_152:
            v62 = v52;
            v77 = 16;
            if ( (_BYTE)v4 < 0 )
            {
              v73 = 48;
              v74 = v52 + 81;
              v71 = 2;
            }
            goto LABEL_125;
          }
          if ( (char)v12 < 101 )
            goto LABEL_193;
          if ( (char)v12 <= 103 )
            goto LABEL_78;
          if ( (char)v12 == 105 )
            goto LABEL_123;
          if ( (char)v12 != 110 )
          {
            if ( (char)v12 == 111 )
            {
              v77 = 8;
              if ( (_BYTE)v4 < 0 )
              {
                v4 |= 0x200u;
                v79 = v4;
              }
LABEL_125:
              if ( (unsigned __int16)(v4 & 0x8000) || v4 & 0x1000 )
              {
                v12 = *(_DWORD *)v78;
                v78 += 8;
                v5 = *(_DWORD *)(v5 + 4);
                v25 = 0;
                goto LABEL_162;
              }
              v37 = v78 + 4;
              v25 = 0;
              v78 += 4;
              if ( v4 & 0x20 )
              {
                if ( v4 & 0x40 )
                  v38 = *(_WORD *)(v37 - 4);
                else
                  v38 = *(_WORD *)(v37 - 4);
LABEL_160:
                v12 = v38;
                v5 = (unsigned __int64)v38 >> 32;
              }
              else
              {
                if ( v4 & 0x40 )
                {
                  v38 = *(_DWORD *)(v37 - 4);
                  goto LABEL_160;
                }
                v12 = *(_DWORD *)(v37 - 4);
                v5 = 0;
              }
LABEL_162:
              if ( v4 & 0x40 )
              {
                if ( v5 <= v25 )
                {
                  if ( v5 < v25 || v12 < (unsigned int)v25 )
                  {
                    v12 = -v12;
                    v5 = -(v25 + (v12 != 0) + v5);
                    v4 |= 0x100u;
                    v79 = v4;
                  }
                }
              }
              if ( !(v4 & 0x9000) )
                v5 = v25;
              v39 = v76;
              if ( v76 >= 0 )
              {
                v4 &= 0xFFFFFFF7u;
                v79 = v4;
                if ( v76 > 512 )
                  v39 = 512;
              }
              else
              {
                v39 = 1;
              }
              if ( !(v5 | v12) )
                v71 = v25;
              for ( k = &v82; ; --k )
              {
                v76 = v39 - 1;
                if ( v39 <= 0 )
                {
                  if ( !(v5 | v12) )
                    break;
                }
                HIDWORD(v42) = v5;
                LODWORD(v42) = v12;
                v43 = sub_10039170(v42, v77);
                v41 = v44 + 48;
                v58 = v4;
                v67 = v43;
                v5 = v45;
                if ( v41 > 57 )
                  v41 += v62;
                v39 = v76;
                *k = v41;
                v12 = v67;
              }
              v4 = v79;
              v46 = &v82 - k;
              v13 = (int)(k + 1);
              v77 = v46;
              if ( v79 & 0x200 )
              {
                if ( !v46 || *(_BYTE *)v13 != 48 )
                {
                  --v13;
                  ++v77;
                  *(_BYTE *)v13 = 48;
                }
              }
            }
LABEL_193:
            if ( v65 )
              goto LABEL_220;
            if ( v4 & 0x40 )
            {
              if ( v4 & 0x100 )
              {
                v73 = 45;
                goto LABEL_201;
              }
              if ( v4 & 1 )
              {
                v73 = 43;
                goto LABEL_201;
              }
              if ( v4 & 2 )
              {
                v73 = 32;
LABEL_201:
                v71 = 1;
              }
            }
            v48 = v71;
            v5 = v69 - v77 - v71;
            if ( !(v4 & 0xC) )
            {
              sub_10051555(v4, 0x20u, v69 - v77 - v71, v72, (int)&v75);
              v48 = v71;
            }
            sub_10051581((unsigned __int8 *)&v73, v48, v72, (int)&v75, (int *)v61);
            if ( v4 & 8 )
            {
              if ( !(v4 & 4) )
                sub_10051555(v4, 0x30u, v5, v72, (int)&v75);
            }
            v49 = v77;
            if ( v66 && v77 > 0 )
            {
              v12 = v13;
              while ( 1 )
              {
                v67 = v49 - 1;
                v50 = *(_WORD *)v12;
                v58 = v12 + 2;
                if ( sub_10051730((int)&v60, &v83, 6, v50) )
                  break;
                if ( !v60 )
                  break;
                sub_10051581((unsigned __int8 *)&v83, v60, v72, (int)&v75, (int *)v61);
                v49 = v67;
                v12 = v58;
                if ( !v67 )
                  goto LABEL_216;
              }
              v51 = -1;
              v75 = -1;
            }
            else
            {
              sub_10051581((unsigned __int8 *)v13, v77, v72, (int)&v75, (int *)v61);
LABEL_216:
              v51 = v75;
            }
            if ( v51 >= 0 )
            {
              if ( v4 & 4 )
                sub_10051555(v4, 0x20u, v5, v72, (int)&v75);
            }
            goto LABEL_220;
          }
          v78 += 4;
          v5 = *(_DWORD *)v5;
          if ( !sub_100515F9() )
            goto LABEL_226;
          if ( v4 & 0x20 )
            *(_WORD *)v5 = v75;
          else
            *(_DWORD *)v5 = v75;
          v65 = 1;
LABEL_220:
          if ( lpMem )
          {
            sub_100309A2(v4, lpMem);
            v12 = 0;
            lpMem = 0;
          }
LABEL_222:
          v10 = v70;
LABEL_223:
          LOBYTE(v12) = *(_BYTE *)v10;
          result = v75;
          v80 = v12;
          LOBYTE(v64) = v12;
          if ( !(_BYTE)v12 )
            goto LABEL_224;
          break;
        default:
          goto LABEL_223;
      }
    }
LABEL_224:
    if ( v68 && v68 != 7 )
    {
LABEL_226:
      *(_DWORD *)sub_10037669(v4) = 22;
      sub_1003A16E(v4, v5);
      result = -1;
    }
  }
  if ( v57 )
    *(_DWORD *)(v56 + 112) &= 0xFFFFFFFDu;
  return result;
}
// 100677BC: using guessed type wchar_t aAcp[4];
// 10074200: using guessed type int __security_cookie;
// 10074C14: using guessed type char *off_10074C14;
// 10074C18: using guessed type wchar_t *off_10074C18;
// 100770A0: using guessed type int dword_100770A0[];

//----- (1005150F) --------------------------------------------------------
int __usercall sub_1005150F<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3, int a4, int a5)
{
  char v5; // sf@3
  signed int v6; // eax@4
  int result; // eax@7

  if ( *(_BYTE *)(a4 + 12) & 0x40 && !*(_DWORD *)(a4 + 8)
    || ((v5 = *(_DWORD *)(a4 + 4) - 1 < 0, --*(_DWORD *)(a4 + 4), v5) ? (v6 = sub_100447F2(a1, a2, a3, a4)) : (**(_BYTE **)a4 = a3, ++*(_DWORD *)a4, v6 = a3),
        v6 != -1) )
  {
    result = a5;
    ++*(_DWORD *)result;
  }
  else
  {
    result = a5;
    *(_DWORD *)a5 = -1;
  }
  return result;
}

//----- (10051555) --------------------------------------------------------
int __usercall sub_10051555<eax>(int a1<ebx>, unsigned __int8 a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  int result; // eax@2

  v5 = a3;
  if ( a3 > 0 )
  {
    do
    {
      --v5;
      result = sub_1005150F(a1, a5, a2, a4, a5);
    }
    while ( *(_DWORD *)a5 != -1 && v5 > 0 );
  }
  return result;
}

//----- (10051581) --------------------------------------------------------
int __cdecl sub_10051581(unsigned __int8 *a1, int a2, int a3, int a4, int *a5)
{
  int result; // eax@1
  int *v6; // esi@1
  int v7; // ebx@4
  int v8; // [sp+20h] [bp+18h]@1

  v6 = a5;
  result = *a5;
  v8 = *a5;
  if ( *(_BYTE *)(a3 + 12) & 0x40 && !*(_DWORD *)(a3 + 8) )
  {
    result = a2;
    *(_DWORD *)a4 += a2;
    return result;
  }
  *v6 = 0;
  v7 = a2;
  if ( a2 <= 0 )
    goto LABEL_12;
  result = a4;
  do
  {
    --v7;
    sub_1005150F(v7, a3, *a1, a3, result);
    result = a4;
    ++a1;
    if ( *(_DWORD *)a4 == -1 )
    {
      if ( *v6 != 42 )
        break;
      sub_1005150F(v7, a3, 0x3Fu, a3, a4);
      result = a4;
    }
  }
  while ( v7 > 0 );
  if ( !*v6 )
  {
    result = v8;
LABEL_12:
    *v6 = result;
  }
  return result;
}

//----- (100515F9) --------------------------------------------------------
bool __cdecl sub_100515F9()
{
  return dword_10077340 == (__security_cookie | 1);
}
// 10074200: using guessed type int __security_cookie;
// 10077340: using guessed type int dword_10077340;

//----- (1005160E) --------------------------------------------------------
signed int __cdecl sub_1005160E(int a1, LPSTR UsedDefaultChar, int cbMultiByte, const WCHAR WideCharStr, int a5)
{
  CHAR *v5; // ebx@1
  int v6; // edi@1
  signed int v8; // esi@9
  int v9; // ecx@25
  int v10; // [sp+8h] [bp-10h]@10
  int v11; // [sp+10h] [bp-8h]@17
  char v12; // [sp+14h] [bp-4h]@16

  v5 = UsedDefaultChar;
  v6 = cbMultiByte;
  if ( UsedDefaultChar || !cbMultiByte )
  {
    if ( a1 )
      *(_DWORD *)a1 = -1;
    if ( (unsigned int)v6 > 0x7FFFFFFF )
    {
      v8 = 22;
      *(_DWORD *)sub_10037669((int)v5) = 22;
      sub_1003A16E((int)v5, v6);
      return v8;
    }
    sub_1003018D((int)&v10, (int)v5, v6, a5);
    v8 = 0;
    if ( *(_DWORD *)(v10 + 168) )
    {
      UsedDefaultChar = 0;
      v9 = WideCharToMultiByte(*(_DWORD *)(v10 + 4), 0, &WideCharStr, 1, v5, v6, 0, (LPBOOL)&UsedDefaultChar);
      if ( v9 )
      {
        if ( !UsedDefaultChar )
        {
          if ( a1 )
            *(_DWORD *)a1 = v9;
          goto LABEL_16;
        }
        goto LABEL_15;
      }
      if ( GetLastError() != 122 )
      {
LABEL_15:
        *(_DWORD *)sub_10037669((int)v5) = 42;
        v8 = *(_DWORD *)sub_10037669((int)v5);
        goto LABEL_16;
      }
      if ( v5 )
      {
        if ( v6 )
          sub_10039210(v5, 0, v6);
      }
    }
    else
    {
      if ( WideCharStr > 0xFFu )
      {
        if ( v5 )
        {
          if ( v6 )
            sub_10039210(v5, 0, v6);
        }
        goto LABEL_15;
      }
      if ( !v5 )
      {
LABEL_23:
        if ( a1 )
          *(_DWORD *)a1 = 1;
        goto LABEL_16;
      }
      if ( v6 )
      {
        *v5 = WideCharStr;
        goto LABEL_23;
      }
    }
    v8 = 34;
    *(_DWORD *)sub_10037669((int)v5) = 34;
    sub_1003A16E((int)v5, v6);
LABEL_16:
    if ( v12 )
      *(_DWORD *)(v11 + 112) &= 0xFFFFFFFDu;
    return v8;
  }
  if ( a1 )
    *(_DWORD *)a1 = 0;
  return 0;
}

//----- (10051730) --------------------------------------------------------
int __cdecl sub_10051730(int a1, LPSTR UsedDefaultChar, int cbMultiByte, const WCHAR WideCharStr)
{
  return sub_1005160E(a1, UsedDefaultChar, cbMultiByte, WideCharStr, 0);
}

//----- (1005174B) --------------------------------------------------------
int __thiscall sub_1005174B(int this, int a2)
{
  int v3; // edi@1

  v3 = this;
  *(_DWORD *)this = 1;
  *(_DWORD *)(this + 4) = sub_1003D44F(a2 + 4);
  *(_DWORD *)(v3 + 8) = a2;
  return v3;
}

//----- (10051771) --------------------------------------------------------
unsigned int __thiscall sub_10051771(int this, int a2)
{
  unsigned int result; // eax@3
  unsigned int v3; // edx@4
  _DWORD *v6; // [sp+0h] [bp+0h]@4

  if ( *(_DWORD *)((a2 << 7) + *(_DWORD *)(this + 92)) <= 1u )
  {
    result = 0;
  }
  else
  {
    v6 = &v6;
    v3 = *(_DWORD *)((a2 << 7) + *(_DWORD *)(this + 92));
    _EDI = 1;
    if ( v3 <= 1 )
      goto LABEL_10;
    _ECX = (a2 << 7) + *(_DWORD *)(this + 92);
    __asm { lock cmpxchg [ecx], edi }
    if ( v3 != v3 )
LABEL_10:
      result = 0;
    else
      result = v3;
  }
  return result;
}

//----- (100517C2) --------------------------------------------------------
int __usercall sub_100517C2<eax>(int a1<ecx>, int a2<edi>)
{
  int v2; // esi@1
  int v4; // eax@8
  char v5; // [sp-4h] [bp-8h]@6

  v2 = a1;
  if ( *(_BYTE *)a1 & 0x18 && !sub_10051DCD(a1, a2) )
    return 0;
  if ( *(_DWORD *)v2 == 2 )
  {
    v5 = 0;
LABEL_8:
    v4 = sub_100410E3(*(void **)(v2 + 4), *(_DWORD *)(v2 + 8), v5);
    *(_DWORD *)(v2 + 8) = v4;
    if ( v4 )
    {
      *(_BYTE *)(v4 + 179) |= 1u;
      *(_DWORD *)v2 = 1;
    }
    return *(_DWORD *)(v2 + 8);
  }
  if ( *(_DWORD *)v2 == 4 )
  {
    v5 = 1;
    goto LABEL_8;
  }
  return *(_DWORD *)(v2 + 8);
}

//----- (1005180B) --------------------------------------------------------
int __thiscall sub_1005180B(int this, int a2)
{
  int v2; // esi@1
  int result; // eax@2
  char v4; // [sp-4h] [bp-Ch]@3

  v2 = this;
  if ( *(_DWORD *)this == 2 )
  {
    v4 = 0;
    goto LABEL_5;
  }
  result = *(_DWORD *)this - 4;
  if ( *(_DWORD *)this == 4 )
  {
    v4 = 1;
LABEL_5:
    result = sub_10046AD3(a2, *(_DWORD *)(this + 4), *(_DWORD *)(this + 8), v4);
  }
  *(_DWORD *)(v2 + 8) = a2;
  *(_DWORD *)v2 = 1;
  return result;
}

//----- (10051841) --------------------------------------------------------
char __thiscall sub_10051841(int this, int a2)
{
  char result; // al@1

  result = (unsigned int)(a2 - *(_DWORD *)(this + 20)) > 0x3E8;
  if ( result )
    *(_DWORD *)(this + 20) = a2;
  return result;
}

//----- (1005185F) --------------------------------------------------------
char __thiscall sub_1005185F(int this, int a2, int a3, char a4)
{
  int v4; // ebx@1
  int ebp0; // ebp@0
  int v6; // eax@3
  int v7; // eax@6
  int v9; // eax@10
  int v10; // eax@15
  char v11; // [sp+Ch] [bp-18h]@15
  char v12; // [sp+18h] [bp-Ch]@6

  v4 = this;
  if ( !a4 )
  {
    if ( *(_DWORD *)(this + 12) < 0x65u )
    {
      if ( *(_DWORD *)(a3 + 16) - *(_DWORD *)(a3 + 12) <= 0 )
        v9 = 0;
      else
        v9 = sub_100454D7(a3 + 12);
    }
    else
    {
      if ( *(_DWORD *)(this + 12) >= 0x7Fu )
      {
LABEL_16:
        *(_DWORD *)(v4 + 12) = 0;
        return 0;
      }
      v9 = sub_10052BAE(a3, ebp0);
    }
    if ( v9 )
    {
      v10 = sub_1005174B((int)&v11, v9);
      *(_DWORD *)a2 = *(_DWORD *)v10;
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(v10 + 4);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v10 + 8);
      ++*(_DWORD *)(v4 + 12);
      return 1;
    }
    goto LABEL_16;
  }
  if ( *(_DWORD *)(a3 + 16) - *(_DWORD *)(a3 + 12) <= 0 )
    v6 = 0;
  else
    v6 = sub_100454D7(a3 + 12);
  if ( v6 )
  {
    v7 = sub_1005174B((int)&v12, v6);
    *(_DWORD *)a2 = *(_DWORD *)v7;
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(v7 + 4);
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(v7 + 8);
    return 1;
  }
  return 0;
}

//----- (100518F6) --------------------------------------------------------
int __thiscall sub_100518F6(int this, int a2, int a3)
{
  signed int v3; // edi@1
  signed int i; // esi@1
  int v5; // edx@2
  int result; // eax@3

  v3 = *(_DWORD *)(this + 44);
  for ( i = 0; i < v3; ++i )
  {
    v5 = (i + *(_DWORD *)a2 + (a3 != -1)) % v3;
    if ( v5 == a3 )
      break;
    result = *(_DWORD *)(*(_DWORD *)(this + 32) + 4 * v5);
    if ( result )
    {
      *(_DWORD *)a2 = v5;
      return result;
    }
  }
  return 0;
}

//----- (10051943) --------------------------------------------------------
int __thiscall sub_10051943(int this, int a2)
{
  int result; // eax@1
  int v3; // ebx@1
  int v4; // edi@1

  v4 = *(_DWORD *)(this + 176);
  v3 = this + 16;
  result = sub_10032560(*(_DWORD *)(this + 176), *(_DWORD *)(this + 80), a2, this + 16);
  if ( !result )
  {
    if ( v4 )
      result = sub_10032560(result, v4, a2, v3);
  }
  return result;
}

//----- (1005197E) --------------------------------------------------------
int __thiscall sub_1005197E(int this, int a2)
{
  int result; // eax@1
  int v3; // ebx@1
  int v4; // edi@1

  v4 = *(_DWORD *)(this + 180);
  v3 = this + 96;
  result = sub_10032560(*(_DWORD *)(this + 180), *(_DWORD *)(this + 160), a2, this + 96);
  if ( !result )
  {
    if ( v4 )
      result = sub_10032560(result, v4, a2, v3);
  }
  return result;
}

//----- (100519BC) --------------------------------------------------------
char __stdcall sub_100519BC(int a1, int a2, char a3)
{
  int v3; // eax@2
  signed int v5; // [sp+8h] [bp-Ch]@3
  int v6; // [sp+10h] [bp-4h]@4

  if ( a3 )
  {
    v3 = sub_10041116((void *)a2);
    if ( v3 )
    {
      v5 = 2;
      v6 = v3;
LABEL_4:
      *(_DWORD *)a1 = v5;
      *(_DWORD *)(a1 + 4) = a2;
      *(_DWORD *)(a1 + 8) = v6;
      return 1;
    }
  }
  else
  {
    if ( sub_10041170(a2) )
    {
      v5 = 8;
      goto LABEL_4;
    }
  }
  return 0;
}

//----- (10051A0C) --------------------------------------------------------
char __thiscall sub_10051A0C(void *this, int a2, int a3, char a4, int a5, char a6)
{
  void *v6; // edi@1
  int v7; // esi@1
  char result; // al@3
  int v9; // esi@5

  v7 = *(_DWORD *)(a3 + 256);
  v6 = this;
  if ( sub_10052A78(this, a3, 0, a5, a6) || !sub_100519BC(a2, a3, a4) )
  {
    if ( a5 )
      v9 = *(_DWORD *)(v7 + 12);
    else
      v9 = *(_DWORD *)(v7 + 16);
    while ( v9 )
    {
      if ( !sub_10052A78(v6, v9, a3, a5, a6) && sub_100519BC(a2, v9, a4) )
        goto LABEL_3;
      v9 = *(_DWORD *)(v9 + 260);
    }
    result = 0;
  }
  else
  {
LABEL_3:
    result = 1;
  }
  return result;
}

//----- (10051A8D) --------------------------------------------------------
char __stdcall sub_10051A8D(int a1, int a2)
{
  int v2; // eax@1
  char result; // al@2
  int v4; // eax@2
  char v5; // [sp+0h] [bp-Ch]@2

  v2 = (*(int (**)(void))(*(_DWORD *)a2 + 12))();
  if ( v2 )
  {
    v4 = sub_1005174B((int)&v5, v2);
    *(_DWORD *)a1 = *(_DWORD *)v4;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(v4 + 4);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(v4 + 8);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10051ABE) --------------------------------------------------------
char __thiscall sub_10051ABE(void *this, int a2, int a3, int a4, char a5)
{
  void *v5; // edi@1
  int v6; // esi@1
  char result; // al@3
  int v8; // esi@5

  v6 = *(_DWORD *)(a3 + 256);
  v5 = this;
  if ( sub_10052A78(this, a3, 0, a4, a5) || !sub_10051A8D(a2, a3) )
  {
    if ( a4 )
      v8 = *(_DWORD *)(v6 + 12);
    else
      v8 = *(_DWORD *)(v6 + 16);
    while ( v8 )
    {
      if ( !sub_10052A78(v5, v8, a3, a4, a5) && sub_10051A8D(a2, v8) )
        goto LABEL_3;
      v8 = *(_DWORD *)(v8 + 260);
    }
    result = 0;
  }
  else
  {
LABEL_3:
    result = 1;
  }
  return result;
}

//----- (10051B39) --------------------------------------------------------
char __userpurge sub_10051B39<al>(int a1<edi>, int a2, int a3, char a4, char a5)
{
  int v5; // eax@2
  signed int v7; // [sp+8h] [bp-Ch]@3

  if ( a5 )
  {
    v5 = sub_10041740(a3, a1, a4);
    if ( v5 )
    {
      v7 = 4;
LABEL_4:
      *(_DWORD *)a2 = v7;
      *(_DWORD *)(a2 + 4) = a3;
      *(_DWORD *)(a2 + 8) = v5;
      return 1;
    }
  }
  else
  {
    v5 = sub_10041346((void *)a3);
    if ( v5 )
    {
      v7 = 16;
      goto LABEL_4;
    }
  }
  return 0;
}

//----- (10051B8C) --------------------------------------------------------
char __thiscall sub_10051B8C(void *this, int a2, int a3, char a4, int a5, char a6)
{
  int v6; // edi@1
  char result; // al@3
  int v8; // esi@5
  int v9; // [sp+8h] [bp-4h]@1

  v6 = (int)this;
  v9 = *(_DWORD *)(a3 + 256);
  if ( sub_10052A78(this, a3, 0, a5, a6) || !sub_10051B39(v6, a2, a3, a6, a4) )
  {
    if ( a5 )
      v8 = *(_DWORD *)(v9 + 12);
    else
      v8 = *(_DWORD *)(v9 + 16);
    while ( v8 )
    {
      if ( !sub_10052A78((void *)v6, v8, a3, a5, a6) && sub_10051B39(v6, a2, v8, a6, a4) )
        goto LABEL_3;
      v8 = *(_DWORD *)(v8 + 260);
    }
    result = 0;
  }
  else
  {
LABEL_3:
    result = 1;
  }
  return result;
}

//----- (10051C1A) --------------------------------------------------------
int __thiscall sub_10051C1A(int this)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = this;
  if ( *(_DWORD *)this == 2 )
  {
    sub_10052C1A(*(_DWORD *)(this + 8));
    result = sub_10033AD4(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 4) + 256) + 4), *(_DWORD *)(v1 + 8));
  }
  else
  {
    result = *(_DWORD *)this - 4;
    if ( *(_DWORD *)this == 4 )
      result = (*(int (__cdecl **)(_DWORD))(*(_DWORD *)(this + 8) + 12))(*(_DWORD *)(this + 8));
  }
  return result;
}

//----- (10051C4F) --------------------------------------------------------
int __thiscall sub_10051C4F(void *this, int a2)
{
  int result; // eax@1

  result = a2 - *((_DWORD *)this + 103);
  if ( (unsigned int)result > 0x7D0 )
    result = sub_1003356F(this, a2);
  return result;
}

//----- (10051C6E) --------------------------------------------------------
char __thiscall sub_10051C6E(void *this, int a2)
{
  int v2; // eax@1
  char result; // al@2
  int v4; // eax@2
  char v5; // [sp+0h] [bp-Ch]@2

  v2 = (*(int (**)(void))(**(_DWORD **)this + 8))();
  if ( v2 )
  {
    v4 = sub_1005174B((int)&v5, v2);
    *(_DWORD *)a2 = *(_DWORD *)v4;
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(v4 + 4);
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(v4 + 8);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10051C9E) --------------------------------------------------------
char __userpurge sub_10051C9E<al>(int a1<edi>, int a2, int a3, char a4, unsigned int a5)
{
  return a5 & 1 && sub_10051A8D(a3, a2)
      || a5 & 0xA && sub_100519BC(a3, a2, (a5 >> 1) & 1)
      || a5 & 0x14 && sub_10051B39(a1, a3, a2, a4, (a5 >> 2) & 1);
}

//----- (10051D0B) --------------------------------------------------------
char __userpurge sub_10051D0B<al>(int a1<edi>, int a2, int a3, char a4, unsigned int a5)
{
  return a5 & 0x14 && sub_10051B39(a1, a3, a2, a4, (a5 >> 2) & 1)
      || a5 & 0xA && sub_100519BC(a3, a2, (a5 >> 1) & 1)
      || a5 & 1 && sub_10051A8D(a3, a2);
}

//----- (10051D79) --------------------------------------------------------
DWORD __thiscall sub_10051D79(int this, int a2, int a3)
{
  DWORD result; // eax@1
  int v4; // esi@1

  v4 = this;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)this = a2;
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 132);
  *(_DWORD *)(this + 4) = **(_DWORD **)(a2 + 68);
  result = GetTickCount();
  *(_DWORD *)(v4 + 20) = result;
  *(_DWORD *)(v4 + 16) = result;
  if ( a3 == 1 )
  {
    *(_DWORD *)(v4 + 24) = sub_10051E4B;
    *(_DWORD *)(v4 + 28) = sub_10052109;
  }
  else
  {
    *(_DWORD *)(v4 + 24) = sub_10052683;
    *(_DWORD *)(v4 + 28) = sub_10052796;
  }
  return result;
}

//----- (10051DCD) --------------------------------------------------------
bool __usercall sub_10051DCD<eax>(int a1<ecx>, int a2<edi>)
{
  int ebp0; // ebp@0
  int v3; // esi@1
  char v4; // al@4
  int v5; // edi@4
  int v6; // eax@6
  int v8; // [sp+8h] [bp-4h]@4

  v3 = a1;
  if ( *(_DWORD *)a1 == 8 )
  {
    v6 = sub_10041116(*(void **)(a1 + 4));
    if ( !v6 )
      return (*(_BYTE *)v3 & 0x18) == 0;
    *(_DWORD *)v3 = 2;
    goto LABEL_10;
  }
  if ( *(_DWORD *)a1 != 16 )
    return (*(_BYTE *)v3 & 0x18) == 0;
  if ( *(_DWORD *)(a1 + 8) != 1 )
  {
    v6 = sub_100402DE(ebp0, 0);
    if ( !v6 )
      return (*(_BYTE *)v3 & 0x18) == 0;
    *(_DWORD *)v3 = 4;
LABEL_10:
    *(_DWORD *)(v3 + 8) = v6;
    return (*(_BYTE *)v3 & 0x18) == 0;
  }
  v4 = sub_10040EB7(*(_DWORD *)(a1 + 4) + 52, a2, (int)&v8);
  v5 = (unsigned __int8)v4 != 0 ? v8 : 0;
  if ( (unsigned __int8)v4 != 0 ? v8 : 0 )
  {
    sub_1003FB11((unsigned __int8)v4 != 0 ? v8 : 0, 1);
    *(_DWORD *)(v3 + 8) = v5;
    *(_DWORD *)v3 = 4;
  }
  return (*(_BYTE *)v3 & 0x18) == 0;
}

//----- (10051E4B) --------------------------------------------------------
char __thiscall sub_10051E4B(void *this, int a2, int a3, char a4, unsigned int a5)
{
  int v5; // ebx@1
  int ebp0; // ebp@0
  int v7; // edi@1
  char result; // al@2
  int v9; // eax@3
  void *v10; // ecx@3
  int v11; // ecx@4
  int v12; // eax@10
  int v13; // eax@12
  int v14; // eax@14
  int v15; // ecx@17
  char v16; // zf@18
  bool v17; // esi@21
  int v18; // eax@26
  int v19; // edi@44
  int v20; // esi@44
  int v21; // esi@44
  int v22; // [sp+10h] [bp-28h]@25
  int v23; // [sp+14h] [bp-24h]@17
  int v24; // [sp+18h] [bp-20h]@25
  int v25; // [sp+1Fh] [bp-19h]@32
  char v26; // [sp+1Fh] [bp-19h]@44
  char v27; // [sp+23h] [bp-15h]@1
  char v28; // [sp+24h] [bp-14h]@45
  int v29; // [sp+28h] [bp-10h]@14
  int v30; // [sp+2Ch] [bp-Ch]@18
  int v31; // [sp+30h] [bp-8h]@18
  unsigned int v32; // [sp+34h] [bp-4h]@1
  int v33; // [sp+38h] [bp+0h]@1

  v32 = (unsigned int)&v33 ^ __security_cookie;
  v7 = a2;
  v5 = (int)this;
  v27 = 0;
  if ( sub_10051C6E(this, a2) )
  {
    result = 1;
  }
  else
  {
    v9 = GetTickCount();
    v10 = *(void **)(v5 + 4);
    *(_DWORD *)(v5 + 16) = v9;
    sub_10051C4F(v10, v9);
    if ( sub_10051841(v5, *(_DWORD *)(v5 + 16)) )
    {
      v11 = *(_DWORD *)(v5 + 4);
      if ( *(_DWORD *)(v11 + 304) )
      {
        while ( 1 )
        {
          v13 = sub_10032A84(v11);
          if ( !v13 )
            break;
          if ( *(_DWORD *)v13 )
          {
            if ( a5 & 1 )
            {
              v12 = sub_10052BAE(v13 - 192, ebp0);
              if ( v12 )
              {
                v14 = sub_1005174B((int)&v29, v12);
                *(_DWORD *)a2 = *(_DWORD *)v14;
                *(_DWORD *)(a2 + 4) = *(_DWORD *)(v14 + 4);
                *(_DWORD *)(a2 + 8) = *(_DWORD *)(v14 + 8);
                v7 = a2;
LABEL_15:
                v27 = 1;
                break;
              }
            }
          }
          else
          {
            if ( sub_10051C9E(a2, v13 - 268, a2, a4, a5) )
              goto LABEL_15;
          }
          v11 = *(_DWORD *)(v5 + 4);
        }
      }
      *(_BYTE *)(*(_DWORD *)v5 + 86) = 1;
    }
    v15 = *(_DWORD *)v5;
    v23 = *(_DWORD *)(*(_DWORD *)v5 + 72);
    if ( v27 )
      goto LABEL_52;
    v17 = (v30 = 0, v16 = *(_BYTE *)(v15 + 84) == 0, v29 = 1, v31 = 2, v16) && !sub_1004500F(v15) && !a4;
    result = v27;
    LOBYTE(v25) = 1;
    do
    {
      if ( v17 > 2 )
        break;
      v22 = a3;
      v24 = v23;
      if ( v23 )
      {
        while ( 1 )
        {
          v18 = sub_10051771(*(_DWORD *)(v5 + 4), *(_DWORD *)(v5 + 8));
          if ( v18 )
          {
            if ( sub_10051C9E(v7, v18, v7, a4, a5) )
              break;
          }
          if ( (_BYTE)v25 && a5 & 1 && sub_1005185F(v5, v7, *(_DWORD *)v5, 0)
            || a5 & 1 && sub_10052481((void *)v5, v7, v24, v22, v25, *(&v29 + v17), a5, a4)
            || a5 & 0xA && sub_10052388((void *)v5, v7, v24, v22, (a5 >> 1) & 1, *(&v29 + v17), a5, a4)
            || a5 & 0x14 && sub_10052587((void *)v5, v7, v24, v22, (a5 >> 2) & 1, *(&v29 + v17), a5, a4)
            || a5 & 1 && v17 == 2 && sub_10052B42((void *)v5, v7, *(_DWORD *)(v24 + 4), *(_DWORD *)v5) )
            break;
          v22 = 0;
          LOBYTE(v25) = 0;
          v24 = sub_10032AF5(*(_DWORD *)(v5 + 4), v23, v24);
          if ( !v24 )
          {
            result = v27;
            goto LABEL_42;
          }
        }
        result = 1;
        v27 = 1;
      }
LABEL_42:
      ++v17;
    }
    while ( !result );
    if ( result )
    {
LABEL_52:
      v21 = *(_DWORD *)(v7 + 4);
      v19 = *(_DWORD *)(v21 + 8);
      sub_10052A3E(v21, *(_DWORD *)(v5 + 16));
      v20 = v21 + 12;
      v26 = 0;
      if ( *(_DWORD *)v20 & 0xFFFFFFF )
      {
        sub_1002F3E5((int)&v28, *(_DWORD *)v5 + 136);
        if ( sub_1004D750((int)&v28, v20) )
          v26 = 1;
      }
      sub_10045972(*(_DWORD *)v5, v26, v19 == v23);
      result = v27;
    }
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;

//----- (10052109) --------------------------------------------------------
char __thiscall sub_10052109(void *this, int a2, int a3, char a4, unsigned int a5)
{
  int v5; // ebx@1
  int ebp0; // ebp@0
  int v7; // edi@1
  char result; // al@2
  int v9; // eax@3
  void *v10; // ecx@3
  int v11; // ecx@4
  int v12; // eax@10
  int v13; // eax@12
  int v14; // eax@14
  int v15; // ecx@17
  char v16; // zf@18
  bool v17; // esi@21
  int v18; // edx@25
  int v19; // ecx@25
  int i; // eax@26
  int v21; // eax@32
  int v22; // ecx@48
  int v23; // esi@48
  int v24; // [sp+10h] [bp-28h]@33
  int v25; // [sp+18h] [bp-20h]@17
  int v26; // [sp+1Ch] [bp-1Ch]@25
  int v27; // [sp+20h] [bp-18h]@25
  char v28; // [sp+27h] [bp-11h]@1
  int v29; // [sp+28h] [bp-10h]@14
  int v30; // [sp+2Ch] [bp-Ch]@18
  int v31; // [sp+30h] [bp-8h]@18
  unsigned int v32; // [sp+34h] [bp-4h]@1
  int v33; // [sp+38h] [bp+0h]@1

  v32 = (unsigned int)&v33 ^ __security_cookie;
  v7 = a2;
  v5 = (int)this;
  v28 = 0;
  if ( sub_10051C6E(this, a2) )
  {
    result = 1;
  }
  else
  {
    v9 = GetTickCount();
    v10 = *(void **)(v5 + 4);
    *(_DWORD *)(v5 + 16) = v9;
    sub_10051C4F(v10, v9);
    if ( sub_10051841(v5, *(_DWORD *)(v5 + 16)) )
    {
      v11 = *(_DWORD *)(v5 + 4);
      if ( *(_DWORD *)(v11 + 304) )
      {
        while ( 1 )
        {
          v13 = sub_10032A84(v11);
          if ( !v13 )
            break;
          if ( *(_DWORD *)v13 )
          {
            if ( a5 & 1 )
            {
              v12 = sub_10052BAE(v13 - 192, ebp0);
              if ( v12 )
              {
                v14 = sub_1005174B((int)&v29, v12);
                *(_DWORD *)a2 = *(_DWORD *)v14;
                *(_DWORD *)(a2 + 4) = *(_DWORD *)(v14 + 4);
                *(_DWORD *)(a2 + 8) = *(_DWORD *)(v14 + 8);
                v7 = a2;
LABEL_15:
                v28 = 1;
                break;
              }
            }
          }
          else
          {
            if ( sub_10051D0B(a2, v13 - 268, a2, a4, a5) )
              goto LABEL_15;
          }
          v11 = *(_DWORD *)(v5 + 4);
        }
      }
      *(_BYTE *)(*(_DWORD *)v5 + 86) = 1;
    }
    v15 = *(_DWORD *)v5;
    v25 = *(_DWORD *)(*(_DWORD *)v5 + 72);
    if ( v28 )
      goto LABEL_51;
    v17 = (v30 = 0, v16 = *(_BYTE *)(v15 + 84) == 0, v29 = 1, v31 = 2, v16) && !sub_1004500F(v15) && !a4;
    result = v28;
    LOBYTE(v24) = 1;
    do
    {
      if ( v17 > 2 )
        break;
      v19 = v25;
      v18 = a3;
      v26 = a3;
      v27 = v25;
      if ( v25 )
      {
        for ( i = a5 & 0x14; ; i = a5 & 0x14 )
        {
          if ( i )
          {
            if ( sub_10052587((void *)v5, v7, v19, v18, (a5 >> 2) & 1, *(&v29 + v17), a5, a4) )
              goto LABEL_44;
            v19 = v27;
            v18 = v26;
          }
          if ( a5 & 0xA && sub_10052388((void *)v5, v7, v19, v18, (a5 >> 1) & 1, *(&v29 + v17), a5, a4) )
            goto LABEL_44;
          v21 = a5 & 1;
          if ( a5 & 1 )
          {
            if ( sub_10052481((void *)v5, v7, v27, v26, v24, *(&v29 + v17), a5, a4) )
              goto LABEL_44;
            v21 = a5 & 1;
          }
          if ( v21 && v17 == 2 )
          {
            if ( sub_10052B42((void *)v5, v7, *(_DWORD *)(v27 + 4), *(_DWORD *)v5) )
              goto LABEL_44;
            v21 = a5 & 1;
          }
          if ( (_BYTE)v24 && v21 && sub_1005185F(v5, v7, *(_DWORD *)v5, 1) )
          {
LABEL_44:
            result = 1;
            v28 = 1;
            goto LABEL_46;
          }
          LOBYTE(v24) = 0;
          v26 = 0;
          v19 = sub_10032AF5(*(_DWORD *)(v5 + 4), v25, v27);
          v27 = v19;
          if ( !v19 )
            break;
          v18 = 0;
        }
        result = v28;
      }
LABEL_46:
      ++v17;
    }
    while ( !result );
    if ( result )
    {
LABEL_51:
      v22 = *(_DWORD *)(v7 + 4);
      v23 = *(_DWORD *)(v22 + 8);
      sub_10052A3E(v22, *(_DWORD *)(v5 + 16));
      sub_10045972(*(_DWORD *)v5, (*(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) & 0xFFFFFFF) == 0, v23 == v25);
      result = v28;
    }
  }
  return result;
}
// 10074200: using guessed type int __security_cookie;

//----- (10052388) --------------------------------------------------------
char __thiscall sub_10052388(void *this, int a2, int a3, int a4, char a5, int a6, unsigned int a7, char a8)
{
  int v8; // edi@1
  char result; // al@3
  int v10; // esi@4
  int v11; // eax@5
  int v12; // ebx@7
  int v13; // eax@8
  int v14; // eax@12
  void *v15; // [sp+4h] [bp-4h]@1
  int i; // [sp+14h] [bp+Ch]@7

  v8 = a6;
  v15 = this;
  if ( a4 && sub_10051A0C(this, a2, a4, a5, a6, a8) )
  {
    result = 1;
  }
  else
  {
    v10 = a3;
    if ( v8 )
      v11 = sub_10051943(a3, (int)&a6);
    else
      v11 = sub_1005197E(a3, (int)&a6);
    v12 = v11;
    for ( i = a6; ; v12 = sub_10032AB9((int)&a6, i, v14) )
    {
      if ( !v12 )
        return 0;
      v13 = sub_10051771(*((_DWORD *)v15 + 1), *((_DWORD *)v15 + 2));
      if ( v13 )
      {
        if ( sub_10051C9E(v8, v13, a2, a8, a7) )
          break;
      }
      if ( !sub_10052A78(v15, v12, a4, v8, a8) && sub_100519BC(a2, v12, a5) )
      {
        if ( v8 )
          *(_DWORD *)(v10 + 176) = (a6 + 1) % *(_DWORD *)(v10 + 80);
        else
          *(_DWORD *)(v10 + 180) = (a6 + 1) % *(_DWORD *)(v10 + 160);
        break;
      }
      v14 = v10 + 96;
      if ( v8 )
        v14 = v10 + 16;
    }
    result = 1;
  }
  return result;
}

//----- (10052481) --------------------------------------------------------
char __thiscall sub_10052481(void *this, int a2, int a3, int a4, int a5, int i, unsigned int a7, char a8)
{
  int v8; // ebx@1
  int v9; // edi@1
  char result; // al@3
  int v11; // esi@6
  int v12; // eax@7
  int v13; // eax@10
  int v14; // eax@14
  int v15; // [sp+14h] [bp+Ch]@17

  v8 = i;
  v9 = (int)this;
  if ( a4 && sub_10051ABE(this, a2, a4, i, a8)
    || (_BYTE)a5 && sub_10052B42((void *)v9, a2, *(_DWORD *)(*(_DWORD *)v9 + 68), *(_DWORD *)v9) )
  {
    result = 1;
  }
  else
  {
    v11 = a3;
    if ( v8 )
      v12 = sub_10051943(a3, (int)&a5);
    else
      v12 = sub_1005197E(a3, (int)&a5);
    for ( i = a5; ; v12 = sub_10032AB9((int)&a5, i, v14) )
    {
      v15 = v12;
      if ( !v12 )
        return 0;
      v13 = sub_10051771(*(_DWORD *)(v9 + 4), *(_DWORD *)(v9 + 8));
      if ( v13 )
      {
        if ( sub_10051C9E(v9, v13, a2, a8, a7) )
          break;
      }
      if ( !sub_10052A78((void *)v9, v15, a4, v8, a8) && sub_10051A8D(a2, v15) )
      {
        if ( v8 )
          *(_DWORD *)(v11 + 176) = (a5 + 1) % *(_DWORD *)(v11 + 80);
        else
          *(_DWORD *)(v11 + 180) = (a5 + 1) % *(_DWORD *)(v11 + 160);
        break;
      }
      v14 = v11 + 96;
      if ( v8 )
        v14 = v11 + 16;
    }
    result = 1;
  }
  return result;
}

//----- (10052587) --------------------------------------------------------
char __thiscall sub_10052587(void *this, int a2, int a3, int a4, char a5, int a6, unsigned int a7, char a8)
{
  int v8; // edi@1
  char result; // al@3
  int v10; // esi@4
  int v11; // eax@5
  int v12; // ebx@7
  int v13; // eax@8
  int v14; // eax@12
  void *v15; // [sp+4h] [bp-4h]@1
  int i; // [sp+14h] [bp+Ch]@7

  v8 = a6;
  v15 = this;
  if ( a4 && sub_10051B8C(this, a2, a4, a5, a6, a8) )
  {
    result = 1;
  }
  else
  {
    v10 = a3;
    if ( v8 )
      v11 = sub_10051943(a3, (int)&a6);
    else
      v11 = sub_1005197E(a3, (int)&a6);
    v12 = v11;
    for ( i = a6; ; v12 = sub_10032AB9((int)&a6, i, v14) )
    {
      if ( !v12 )
        return 0;
      v13 = sub_10051771(*((_DWORD *)v15 + 1), *((_DWORD *)v15 + 2));
      if ( v13 )
      {
        if ( sub_10051C9E(v8, v13, a2, a8, a7) )
          break;
      }
      if ( !sub_10052A78(v15, v12, a4, v8, a8) && sub_10051B39(v8, a2, v12, a8, a5) )
      {
        if ( v8 )
          *(_DWORD *)(v10 + 176) = (a6 + 1) % *(_DWORD *)(v10 + 80);
        else
          *(_DWORD *)(v10 + 180) = (a6 + 1) % *(_DWORD *)(v10 + 160);
        break;
      }
      v14 = v10 + 96;
      if ( v8 )
        v14 = v10 + 16;
    }
    result = 1;
  }
  return result;
}

//----- (10052683) --------------------------------------------------------
char __thiscall sub_10052683(void *this, int a2, int a3, int a4, unsigned int a5)
{
  char v5; // bl@1
  void *v6; // esi@1
  unsigned int v8; // eax@3
  int v9; // edi@3
  int v10; // eax@4
  int v11; // ecx@5
  char v12; // al@5
  int v13; // ecx@10
  int v14; // eax@11
  char v15; // al@12
  int v16; // ecx@16
  int v17; // eax@17
  char v18; // al@18
  int v19; // [sp-8h] [bp-18h]@5
  char v20; // [sp+8h] [bp-8h]@11
  int v21; // [sp+Ch] [bp-4h]@4
  int v22; // [sp+Ch] [bp-4h]@10
  int v23; // [sp+Ch] [bp-4h]@16
  int v24; // [sp+24h] [bp+14h]@17

  v6 = this;
  v5 = 0;
  if ( sub_10051C6E(this, a2) )
    return 1;
  v9 = sub_10032B1F(*((_DWORD *)v6 + 1));
  v8 = a5;
  if ( !(a5 & 1) )
  {
LABEL_9:
    if ( v8 & 0xA && (v13 = v9, v22 = v9, v9) )
    {
      v14 = v8 >> 1;
      v20 = v14;
      while ( 1 )
      {
        v15 = sub_100528A4(a2, v13, v14 & 1);
        v11 = *((_DWORD *)v6 + 1);
        v19 = v22;
        v5 = v15;
        if ( v15 )
          break;
        v14 = sub_10032AF5(v11, v9, v22);
        v13 = v14;
        v22 = v14;
        LOBYTE(v14) = v20;
        if ( !v13 )
        {
          v8 = a5;
          goto LABEL_15;
        }
      }
    }
    else
    {
LABEL_15:
      if ( !(v8 & 0x14) || (v16 = v9, v23 = v9, !v9) )
        return v5;
      v17 = v8 >> 2;
      v24 = v17;
      while ( 1 )
      {
        v18 = sub_100529A6(a2, v16, v17 & 1);
        v11 = *((_DWORD *)v6 + 1);
        v19 = v23;
        v5 = v18;
        if ( v18 )
          break;
        v17 = sub_10032AF5(v11, v9, v23);
        v16 = v17;
        v23 = v17;
        LOBYTE(v17) = v24;
        if ( !v16 )
          return v5;
      }
    }
    goto LABEL_21;
  }
  v10 = v9;
  v21 = v9;
  if ( v9 )
  {
    while ( 1 )
    {
      v12 = sub_10052938(a2, v10);
      v19 = v21;
      v11 = *((_DWORD *)v6 + 1);
      v5 = v12;
      if ( v12 )
        break;
      v10 = sub_10032AF5(v11, v9, v21);
      v21 = v10;
      if ( !v10 )
        goto LABEL_7;
    }
LABEL_21:
    sub_100340B5(v11, v19);
    return v5;
  }
LABEL_7:
  v5 = sub_10052B00(v6, a2, *(_DWORD *)(*(_DWORD *)v6 + 68));
  if ( !v5 )
  {
    v8 = a5;
    goto LABEL_9;
  }
  return v5;
}

//----- (10052796) --------------------------------------------------------
char __thiscall sub_10052796(void *this, int a2, int a3, int a4, unsigned int a5)
{
  char v5; // bl@1
  void *v6; // esi@1
  int v8; // eax@3
  int v9; // edi@3
  int v10; // ecx@4
  unsigned int v11; // eax@5
  int v12; // ecx@6
  char v13; // al@6
  int v14; // eax@7
  int v15; // ecx@9
  unsigned int v16; // eax@10
  char v17; // al@11
  int v18; // eax@12
  int v19; // eax@14
  char v20; // al@15
  int v21; // [sp-8h] [bp-18h]@6
  int v22; // [sp+Ch] [bp-4h]@4
  int v23; // [sp+Ch] [bp-4h]@9
  int v24; // [sp+24h] [bp+14h]@14

  v6 = this;
  v5 = 0;
  if ( sub_10051C6E(this, a2) )
    return 1;
  v8 = sub_10032B1F(*((_DWORD *)v6 + 1));
  v9 = v8;
  if ( a5 & 0x14 )
  {
    v10 = v8;
    v22 = v8;
    if ( v8 )
    {
      v11 = a5 >> 2;
      do
      {
        v13 = sub_100529A6(a2, v10, v11 & 1);
        v12 = *((_DWORD *)v6 + 1);
        v21 = v22;
        v5 = v13;
        if ( v13 )
          goto LABEL_20;
        v14 = sub_10032AF5(v12, v9, v22);
        v10 = v14;
        v22 = v14;
        v11 = a5 >> 2;
      }
      while ( v10 );
    }
  }
  if ( a5 & 0xA )
  {
    v15 = v9;
    v23 = v9;
    if ( v9 )
    {
      v16 = a5 >> 1;
      do
      {
        v17 = sub_100528A4(a2, v15, v16 & 1);
        v12 = *((_DWORD *)v6 + 1);
        v21 = v23;
        v5 = v17;
        if ( v17 )
          goto LABEL_20;
        v18 = sub_10032AF5(v12, v9, v23);
        v15 = v18;
        v23 = v18;
        v16 = a5 >> 1;
      }
      while ( v15 );
    }
  }
  if ( a5 & 1 )
  {
    v19 = v9;
    v24 = v9;
    if ( v9 )
    {
      while ( 1 )
      {
        v20 = sub_10052938(a2, v19);
        v21 = v24;
        v12 = *((_DWORD *)v6 + 1);
        v5 = v20;
        if ( v20 )
          break;
        v19 = sub_10032AF5(v12, v9, v24);
        v24 = v19;
        if ( !v19 )
          goto LABEL_17;
      }
LABEL_20:
      sub_100340B5(v12, v21);
      return v5;
    }
LABEL_17:
    v5 = sub_10052B00(v6, a2, *(_DWORD *)(*(_DWORD *)v6 + 68));
  }
  return v5;
}

//----- (100528A4) --------------------------------------------------------
char __stdcall sub_100528A4(int a1, int a2, char a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int v5; // eax@3
  char result; // al@5
  signed int v7; // [sp+Ch] [bp-10h]@4
  int v8; // [sp+14h] [bp-8h]@5
  int v9; // [sp+18h] [bp-4h]@1
  int v10; // [sp+28h] [bp+Ch]@1

  v3 = a2;
  v4 = sub_1005197E(a2, (int)&v9);
  v10 = v9;
  while ( v4 )
  {
    if ( a3 )
    {
      v5 = sub_10041116((void *)v4);
      if ( v5 )
      {
        v7 = 2;
        v8 = v5;
LABEL_5:
        result = 1;
        *(_DWORD *)(v3 + 180) = (v9 + 1) % *(_DWORD *)(v3 + 160);
        *(_DWORD *)a1 = v7;
        *(_DWORD *)(a1 + 4) = v4;
        *(_DWORD *)(a1 + 8) = v8;
        return result;
      }
    }
    else
    {
      if ( sub_10041170(v4) )
      {
        v7 = 8;
        goto LABEL_5;
      }
    }
    v4 = sub_10032AB9((int)&v9, v10, v3 + 96);
  }
  return 0;
}

//----- (10052938) --------------------------------------------------------
char __stdcall sub_10052938(int a1, int a2)
{
  int v2; // eax@1
  int i; // ebx@1
  int v4; // edi@2
  int v6; // eax@7
  char v7; // [sp+Ch] [bp-10h]@7
  int v8; // [sp+18h] [bp-4h]@1

  v2 = sub_1005197E(a2, (int)&v8);
  for ( i = v8; ; v2 = sub_10032AB9((int)&v8, i, a2 + 96) )
  {
    if ( !v2 )
      return 0;
    v4 = (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 12))(v2);
    if ( v4 )
      break;
  }
  *(_DWORD *)(a2 + 180) = (v8 + 1) % *(_DWORD *)(a2 + 160);
  v6 = sub_1005174B((int)&v7, v4);
  *(_DWORD *)a1 = *(_DWORD *)v6;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(v6 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(v6 + 8);
  return 1;
}

//----- (100529A6) --------------------------------------------------------
char __stdcall sub_100529A6(int a1, int a2, char a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int v5; // ebx@3
  char result; // al@5
  signed int v7; // [sp+Ch] [bp-10h]@4
  int v8; // [sp+18h] [bp-4h]@1
  int v9; // [sp+28h] [bp+Ch]@1

  v3 = a2;
  v4 = sub_1005197E(a2, (int)&v8);
  v9 = v8;
  while ( v4 )
  {
    if ( a3 )
    {
      v5 = sub_10041740(v4, v3, 0);
      if ( v5 )
      {
        v7 = 4;
LABEL_5:
        result = 1;
        *(_DWORD *)(v3 + 180) = (v8 + 1) % *(_DWORD *)(v3 + 160);
        *(_DWORD *)a1 = v7;
        *(_DWORD *)(a1 + 4) = v4;
        *(_DWORD *)(a1 + 8) = v5;
        return result;
      }
    }
    else
    {
      v5 = sub_10041346((void *)v4);
      if ( v5 )
      {
        v7 = 16;
        goto LABEL_5;
      }
    }
    v4 = sub_10032AB9((int)&v8, v9, v3 + 96);
  }
  return 0;
}

//----- (10052A3E) --------------------------------------------------------
int __thiscall sub_10052A3E(int this, int a2)
{
  int result; // eax@1

  result = a2 - *(_DWORD *)(this + 264);
  if ( (unsigned int)result > 0x64 )
    *(_DWORD *)(this + 264) = a2;
  return result;
}

//----- (10052A5B) --------------------------------------------------------
int __thiscall sub_10052A5B(int this, int a2)
{
  int result; // eax@1

  result = a2 - *(_DWORD *)(this + 184);
  if ( (unsigned int)result > 0x64 )
    *(_DWORD *)(this + 184) = a2;
  return result;
}

//----- (10052A78) --------------------------------------------------------
char __thiscall sub_10052A78(void *this, int a2, int a3, int a4, char a5)
{
  void *v5; // edi@1
  int v7; // edx@3
  char v8; // bl@3
  char v9; // zf@9

  v5 = this;
  if ( a2 == a3 )
    return 1;
  v8 = 0;
  v7 = a2 + 12;
  if ( !a4 )
    return (*(_DWORD *)v7 & 0xFFFFFFF) != 0;
  if ( a4 == 1 )
  {
    if ( !(*(_DWORD *)v7 & 0xFFFFFFF) )
      return 1;
    v9 = sub_1004D750(*(_DWORD *)this + 136, a2 + 12) == 0;
  }
  else
  {
    if ( a4 != 2 )
      return v8;
    if ( !(*(_DWORD *)v7 & 0xFFFFFFF) || sub_1004D750(*(_DWORD *)this + 136, a2 + 12) )
      return 1;
    if ( !sub_10033340(*((_DWORD *)v5 + 1) + 60, a2 + 28) )
      return v8;
    v9 = a5 == 0;
  }
  if ( v9 )
    return 1;
  return v8;
}

//----- (10052B00) --------------------------------------------------------
char __thiscall sub_10052B00(void *this, int a2, int a3)
{
  void *v3; // esi@1
  int v4; // eax@5
  int i; // [sp-4h] [bp-Ch]@1
  int v7; // [sp+4h] [bp-4h]@1

  v7 = 0;
  v3 = this;
  for ( i = -1; ; i = 0 )
  {
    v4 = sub_100518F6(*((_DWORD *)v3 + 1), (int)&v7, i);
    if ( !v4 )
      return 0;
    if ( v4 != a3 && sub_10052B42(v3, a2, v4, 0) )
      break;
  }
  return 1;
}

//----- (10052B42) --------------------------------------------------------
char __thiscall sub_10052B42(void *this, int a2, int a3, int a4)
{
  int i; // eax@1
  void *v5; // ebx@1
  int ebp0; // ebp@0
  int v7; // edi@1
  int v8; // eax@3
  int v9; // esi@5
  int v11; // eax@8
  char v12; // [sp+Ch] [bp-Ch]@8

  v7 = a3;
  v5 = this;
  for ( i = sub_1003258B((void *)a3, 0, *(_DWORD *)(a3 + 120), (int)&a3); ; i = sub_10032B62(v7, (int)&a3, 0) )
  {
    v9 = i;
    if ( !i )
      return 0;
    if ( i != a4 )
    {
      sub_10052A5B(i, *((_DWORD *)v5 + 4));
      v8 = sub_10052BAE(v9, ebp0);
      if ( v8 )
        break;
    }
  }
  v11 = sub_1005174B((int)&v12, v8);
  *(_DWORD *)a2 = *(_DWORD *)v11;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(v11 + 4);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(v11 + 8);
  return 1;
}

//----- (10052BAE) --------------------------------------------------------
int __usercall sub_10052BAE<eax>(int a1<ecx>, int a2<ebp>)
{
  int v2; // edx@1

  v2 = 0;
  if ( *(_DWORD *)(a1 + 16) > *(_DWORD *)(a1 + 12) )
    v2 = sub_10045EE6(a2, 0);
  return v2;
}

//----- (10052BC5) --------------------------------------------------------
void __thiscall sub_10052BC5(void *this, int a2)
{
  int v2; // eax@1
  void *v3; // edi@1
  void *v4; // ecx@2
  int v5; // [sp-8h] [bp-10h]@3
  char v6; // [sp-4h] [bp-Ch]@3

  v3 = this;
  v2 = sub_1003D44F(a2 + 4);
  if ( *(_DWORD *)v3 == 2 )
  {
    v4 = *(void **)(v2 + 256);
    if ( v4 == *(void **)(*((_DWORD *)v3 + 1) + 256) )
    {
      sub_10033312(v4);
      return;
    }
    v6 = 0;
    v5 = *((_DWORD *)v3 + 1);
  }
  else
  {
    if ( *(_DWORD *)(v2 + 256) == *(_DWORD *)(*((_DWORD *)v3 + 1) + 256) )
      return;
    v6 = 1;
    v5 = *((_DWORD *)v3 + 1);
  }
  sub_10046D4D(a2, v5, v6);
}

//----- (10052C1A) --------------------------------------------------------
int __thiscall sub_10052C1A(int this)
{
  return (*(int (__cdecl **)(_DWORD))(this + 4))(*(_DWORD *)(this + 8));
}

//----- (10052C22) --------------------------------------------------------
int __userpurge sub_10052C22<eax>(int a1<ebp>, int a2, int a3)
{
  int v4; // ecx@1
  int v5; // esi@1
  int v6; // ST04_4@1
  int v7; // ST00_4@1

  sub_10035668();
  v5 = v4;
  *(_DWORD *)(a1 - 16) = v4;
  loc_10044EC9();
  v6 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 - 4) = 0;
  v7 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)v5 = &off_10067840;
  sub_1004521D(v5, v7, v6);
  return sub_10035636(4);
}
// 10035636: using guessed type int __cdecl sub_10035636(_DWORD);
// 10044EC9: using guessed type _DWORD loc_10044EC9();
// 10067840: using guessed type int (__stdcall *off_10067840)(char);

//----- (10052C59) --------------------------------------------------------
void *__thiscall sub_10052C59(void *this, char a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1

  v3 = this;
  *(_DWORD *)this = &off_10067840;
  sub_10044F31(ebp0);
  if ( a2 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067840: using guessed type int (__stdcall *off_10067840)(char);

//----- (10052C7E) --------------------------------------------------------
void __usercall sub_10052C7E(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v3; // edx@1
  int v4; // edi@1
  signed int i; // esi@1
  int v6; // eax@3
  int v7; // eax@5

  v4 = 0;
  sub_10036A43(a1, a2, a3, 0, 1);
  for ( i = 3; i < dword_10077AA0; ++i )
  {
    v6 = *((_DWORD *)dword_10077A9C + i);
    if ( v6 )
    {
      if ( *(_BYTE *)(v6 + 12) & 0x83 )
      {
        sub_10055640(v3, a3, *((_DWORD *)dword_10077A9C + i));
        if ( v7 != -1 )
          ++v4;
      }
      if ( i >= 20 )
      {
        DeleteCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)dword_10077A9C + i) + 32));
        sub_100309A2(a3, *((LPVOID *)dword_10077A9C + i));
        *((_DWORD *)dword_10077A9C + i) = 0;
      }
    }
  }
  sub_10036BA7(1);
}
// 10077AA0: using guessed type int dword_10077AA0;

//----- (10052D1B) --------------------------------------------------------
void __usercall sub_10052D1B(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  DWORD v4; // esi@6
  void *v5; // eax@7

  if ( a4 == -2 )
  {
    *(_DWORD *)sub_10037669(a3) = 9;
    return;
  }
  if ( a4 >= 0 )
  {
    if ( a4 < (unsigned int)dword_10077A98 )
    {
      a3 = (a4 & 0x1F) << 6;
      if ( *(_BYTE *)(a3 + dword_100770A0[a4 >> 5] + 4) & 1 )
      {
        sub_100553F4(a1, a2, a3, a4);
        v4 = 0;
        if ( *(_BYTE *)(a3 + dword_100770A0[a4 >> 5] + 4) & 1 )
        {
          v5 = (void *)sub_10055506(a3, a4, a4);
          if ( !FlushFileBuffers(v5) )
            v4 = GetLastError();
          if ( !v4 )
            goto LABEL_12;
          *(_DWORD *)sub_10037635(a3) = v4;
        }
        *(_DWORD *)sub_10037669(a3) = 9;
LABEL_12:
        sub_1005556D(a4);
        return;
      }
    }
  }
  *(_DWORD *)sub_10037669(a3) = 9;
  sub_1003A16E(a3, a4);
}
// 100770A0: using guessed type int dword_100770A0[];
// 10077A98: using guessed type int dword_10077A98;

//----- (10052E30) --------------------------------------------------------
#error "10052E4B: call analysis failed (funcsize=22)"

//----- (10052E75) --------------------------------------------------------
int __usercall sub_10052E75<eax>(int a1<ebp>, int a2, unsigned int a3)
{
  int result; // eax@2
  int v4; // ebx@2
  unsigned int v5; // esi@2
  int v6; // esi@5
  int (__cdecl *v7)(int, int, int, int, int); // [sp+4h] [bp-1Ch]@1
  int v8; // [sp+8h] [bp-18h]@1
  int v9; // [sp+Ch] [bp-14h]@1

  v9 = a2;
  v8 = -2;
  v7 = sub_10052E30;
  while ( 1 )
  {
    result = a2;
    v4 = *(_DWORD *)(a2 + 8);
    v5 = *(_DWORD *)(a2 + 12);
    if ( v5 == -1 )
      break;
    if ( a3 != -1 && v5 <= a3 )
      break;
    v6 = 3 * v5;
    v8 = *(_DWORD *)(v4 + 4 * v6);
    *(_DWORD *)(a2 + 12) = v8;
    if ( !*(_DWORD *)(v4 + 4 * v6 + 4) )
    {
      sub_10052F25(*(_DWORD *)(v4 + 4 * v6 + 8), a1, 257);
      sub_10052F44(*(int (**)(void))(v4 + 4 * v6 + 8));
    }
  }
  return result;
}
// 10052E30: using guessed type int __cdecl sub_10052E30(int, int, int, int, int);

//----- (10052F1C) --------------------------------------------------------
void __cdecl sub_10052F1C()
{
  JUMPOUT(*(unsigned int *)loc_10052F30);
}
// 10052F30: using guessed type int __stdcall loc_10052F30(int);

//----- (10052F25) --------------------------------------------------------
int __userpurge sub_10052F25<eax>(int result<eax>, int a2<ebp>, int a3)
{
  dword_10075470[2] = a3;
  dword_10075470[1] = result;
  dword_10075470[3] = a2;
  return result;
}

//----- (10052F44) --------------------------------------------------------
int __usercall sub_10052F44<eax>(int (*a1)(void)<eax>)
{
  return a1();
}

//----- (10052F50) --------------------------------------------------------
int __thiscall sub_10052F50(void *this, unsigned int a2, unsigned __int8 a3)
{
  signed int v4; // eax@3
  int v5; // edx@3
  int v8; // ecx@4
  int v10; // eax@5
  int result; // eax@8
  char v27; // cf@18
  char v28; // zf@18
  signed int v31; // edx@22
  signed int v38; // ecx@25
  unsigned int v39; // edi@25
  char v40; // zf@27
  int v41; // ecx@29
  int v42; // edi@29
  char v43; // zf@31
  int v44; // edi@33

  if ( (unsigned int)dword_1007689C < 1 )
  {
    v39 = a2;
    v38 = -1;
    do
    {
      if ( !v38 )
        break;
      v40 = *(_BYTE *)v39++ == 0;
      --v38;
    }
    while ( !v40 );
    v41 = -(v38 + 1);
    v42 = v39 - 1;
    do
    {
      if ( !v41 )
        break;
      v43 = *(_BYTE *)v42++ == a3;
      --v41;
    }
    while ( !v43 );
    v44 = v42 + 1;
    if ( *(_BYTE *)v44 == a3 )
      result = v44;
    else
      result = 0;
  }
  else
  {
    _EDI = a2;
    if ( (unsigned int)dword_1007689C > 1 )
    {
      _EDX = a3;
      if ( a3 )
      {
        result = 0;
        if ( a2 & 0xF )
        {
          while ( 1 )
          {
            this = (void *)*(_BYTE *)_EDI;
            if ( this == (void *)a3 )
              result = _EDI;
            if ( !*(_BYTE *)_EDI )
              break;
            ++_EDI;
            if ( !(_EDI & 0xF) )
              goto LABEL_17;
          }
        }
        else
        {
LABEL_17:
          __asm { movd    xmm0, edx }
          do
          {
            v27 = _EDI >= 0xFFFFFFF0;
            v28 = _EDI == -16;
            _EDI += 16;
            __asm { pcmpistri xmm0, xmmword ptr [edi-10h], 40h }
            this += _EDI - 16;
            if ( v27 )
              result = (int)this;
          }
          while ( !v28 );
        }
      }
      else
      {
        _EAX = a2 & 0xFFFFFFF0;
        __asm
        {
          pxor    xmm0, xmm0
          pcmpeqb xmm0, xmmword ptr [eax]
        }
        v31 = -1 << (a2 & 0xF);
        __asm { pmovmskb edi, xmm0 }
        _EDI = v31 & _EDI;
        while ( !_EDI )
        {
          __asm
          {
            pxor    xmm0, xmm0
            pcmpeqb xmm0, xmmword ptr [eax+10h]
          }
          _EAX += 16;
          __asm { pmovmskb edi, xmm0 }
        }
        __asm { bsf     edx, edi }
        result = _EDX + _EAX;
      }
    }
    else
    {
      _EDX = a3 | (a3 << 8);
      __asm
      {
        movd    xmm3, edx
        pshuflw xmm3, xmm3, 0
        movlhps xmm3, xmm3
      }
      v4 = -1 << (a2 & 0xF);
      _EDI = a2 - (a2 & 0xF);
      v5 = 0;
      while ( 1 )
      {
        __asm
        {
          movdqu  xmm1, xmmword ptr [edi]
          pxor    xmm2, xmm2
          pcmpeqb xmm2, xmm1
          pcmpeqb xmm1, xmm3
          pmovmskb ecx, xmm2
        }
        v8 = v4 & _ECX;
        if ( v8 )
          break;
        __asm { pmovmskb ecx, xmm1 }
        _ECX = v4 & _ECX;
        __asm { bsr     eax, ecx }
        v10 = _EDI + _EAX;
        if ( _ECX )
          v5 = v10;
        v4 = -1;
        _EDI += 16;
      }
      __asm { pmovmskb ebx, xmm1 }
      _ECX = v4 & _EBX & ((-2 * v8 & 2 * v8) - 1);
      __asm { bsr     eax, ecx }
      result = _EDI + _EAX;
      if ( !_ECX )
        result = v5;
    }
  }
  return result;
}
// 1007689C: using guessed type int dword_1007689C;

//----- (10053087) --------------------------------------------------------
signed int __usercall sub_10053087<eax>(int a1<ebx>, int a2, unsigned int a3, int a4, int a5)
{
  int v5; // edx@1
  int v6; // edi@1
  int v7; // eax@2
  int v9; // ecx@5
  int v10; // eax@6
  int v11; // eax@10
  char v12; // dl@11
  int v13; // eax@24
  signed int v14; // [sp-4h] [bp-Ch]@2

  v5 = a5;
  v6 = *(_DWORD *)(a5 + 12);
  if ( !a2 || !a3 )
  {
    v7 = sub_10037669(a1);
    v14 = 22;
LABEL_3:
    *(_DWORD *)v7 = v14;
    sub_1003A16E(a1, v6);
    return v14;
  }
  v9 = a4;
  *(_BYTE *)a2 = 0;
  if ( a4 <= 0 )
    v10 = 0;
  else
    v10 = a4;
  if ( a3 <= v10 + 1 )
  {
    v7 = sub_10037669(a1);
    v14 = 34;
    goto LABEL_3;
  }
  *(_BYTE *)a2 = 48;
  v11 = a2 + 1;
  if ( a4 > 0 )
  {
    do
    {
      v12 = *(_BYTE *)v6;
      if ( *(_BYTE *)v6 )
        ++v6;
      else
        v12 = 48;
      *(_BYTE *)v11++ = v12;
      --v9;
    }
    while ( v9 > 0 );
    v5 = a5;
  }
  *(_BYTE *)v11 = 0;
  if ( v9 >= 0 )
  {
    if ( *(_BYTE *)v6 >= 53 )
    {
      while ( 1 )
      {
        --v11;
        if ( *(_BYTE *)v11 != 57 )
          break;
        *(_BYTE *)v11 = 48;
      }
      ++*(_BYTE *)v11;
    }
  }
  if ( *(_BYTE *)a2 == 49 )
  {
    ++*(_DWORD *)(v5 + 4);
  }
  else
  {
    v13 = sub_10035550(a2 + 1);
    sub_1002A4B0((void *)a2, (const void *)(a2 + 1), v13 + 1);
  }
  return 0;
}

//----- (10053137) --------------------------------------------------------
signed int __usercall sub_10053137<eax>(int a1<ebx>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  signed int v5; // ebx@1
  signed int v7; // [sp-4h] [bp-38h]@4
  char v8; // [sp+Ch] [bp-28h]@1
  int v9; // [sp+14h] [bp-20h]@10
  char v10; // [sp+18h] [bp-1Ch]@9
  char v11; // [sp+1Ch] [bp-18h]@1
  int v12; // [sp+20h] [bp-14h]@1
  char v13; // [sp+24h] [bp-10h]@1
  unsigned int v14; // [sp+30h] [bp-4h]@1
  int v15; // [sp+34h] [bp+0h]@1

  v14 = (unsigned int)&v15 ^ __security_cookie;
  sub_1003018D((int)&v8, a1, a2, a4);
  v5 = 0;
  v12 = sub_1005638B((int)&v13, (int)&v11, a3, 0, 0, 0, 0, (int)&v8);
  v4 = sub_100558AB((int)&v13, a2);
  if ( !(v12 & 3) )
  {
    if ( v4 != 1 )
    {
      if ( v4 != 2 )
        goto LABEL_9;
      goto LABEL_4;
    }
LABEL_7:
    v7 = 3;
    goto LABEL_8;
  }
  if ( !(v12 & 1) )
  {
    if ( !(v12 & 2) )
      goto LABEL_9;
    goto LABEL_7;
  }
LABEL_4:
  v7 = 4;
LABEL_8:
  v5 = v7;
LABEL_9:
  if ( v10 )
    *(_DWORD *)(v9 + 112) &= 0xFFFFFFFDu;
  return v5;
}
// 10074200: using guessed type int __security_cookie;

//----- (100531C3) --------------------------------------------------------
signed int __usercall sub_100531C3<eax>(int a1<ebx>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  signed int v5; // ebx@1
  signed int v7; // [sp-4h] [bp-38h]@4
  char v8; // [sp+Ch] [bp-28h]@1
  int v9; // [sp+14h] [bp-20h]@10
  char v10; // [sp+18h] [bp-1Ch]@9
  char v11; // [sp+1Ch] [bp-18h]@1
  int v12; // [sp+20h] [bp-14h]@1
  char v13; // [sp+24h] [bp-10h]@1
  unsigned int v14; // [sp+30h] [bp-4h]@1
  int v15; // [sp+34h] [bp+0h]@1

  v14 = (unsigned int)&v15 ^ __security_cookie;
  sub_1003018D((int)&v8, a1, a2, a4);
  v5 = 0;
  v12 = sub_1005638B((int)&v13, (int)&v11, a3, 0, 0, 0, 0, (int)&v8);
  v4 = sub_10055E1B((int)&v13, a2);
  if ( !(v12 & 3) )
  {
    if ( v4 != 1 )
    {
      if ( v4 != 2 )
        goto LABEL_9;
      goto LABEL_4;
    }
LABEL_7:
    v7 = 3;
    goto LABEL_8;
  }
  if ( !(v12 & 1) )
  {
    if ( !(v12 & 2) )
      goto LABEL_9;
    goto LABEL_7;
  }
LABEL_4:
  v7 = 4;
LABEL_8:
  v5 = v7;
LABEL_9:
  if ( v10 )
    *(_DWORD *)(v9 + 112) &= 0xFFFFFFFDu;
  return v5;
}
// 10074200: using guessed type int __security_cookie;

//----- (1005324F) --------------------------------------------------------
__int16 __cdecl sub_1005324F(int a1, int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  signed int v4; // ebx@1
  __int16 v5; // di@1
  unsigned int v6; // esi@1
  int v7; // edx@1
  int v8; // eax@3
  int v9; // esi@10
  int v10; // edi@11
  __int16 v12; // [sp+Ch] [bp-8h]@1
  unsigned int v13; // [sp+10h] [bp-4h]@1
  int v14; // [sp+20h] [bp+Ch]@13

  v7 = *(_DWORD *)(a2 + 4);
  v3 = ((unsigned int)*(_WORD *)(a2 + 6) >> 4) & 0x7FF;
  v5 = *(_WORD *)(a2 + 6) & 0x8000;
  v6 = ((unsigned int)*(_WORD *)(a2 + 6) >> 4) & 0x7FF;
  v2 = v7 & 0xFFFFF;
  v4 = -2147483648;
  v12 = *(_WORD *)(a2 + 6) & 0x8000;
  v13 = *(_DWORD *)a2;
  if ( !v6 )
  {
    if ( !v2 && !*(_DWORD *)a2 )
    {
      v8 = a1;
      *(_DWORD *)(v8 + 4) &= v2;
      *(_DWORD *)v8 &= v2;
      *(_WORD *)(a1 + 8) = v5;
      return v8;
    }
    v8 = v3 + 15361;
    v4 = 0;
    goto LABEL_9;
  }
  if ( v6 != 2047 )
  {
    v8 = v3 + 15360;
LABEL_9:
    v8 = (unsigned __int16)v8;
    goto LABEL_10;
  }
  v8 = 32767;
LABEL_10:
  v9 = v4 | (v2 << 11) | (v13 >> 21);
  *(_DWORD *)(a1 + 4) = v9;
  *(_DWORD *)a1 = v13 << 11;
  if ( v9 >= 0 )
  {
    v10 = v8;
    do
    {
      v10 += 65535;
      v9 = (*(_DWORD *)a1 >> 31) | 2 * v9;
      *(_DWORD *)a1 *= 2;
    }
    while ( v9 >= 0 );
    v14 = v10;
    v5 = v12;
    LOWORD(v8) = v14;
    *(_DWORD *)(a1 + 4) = v9;
  }
  *(_WORD *)(a1 + 8) = v8 | v5;
  return v8;
}

//----- (100533B0) --------------------------------------------------------
int __stdcall sub_100533B0(unsigned __int64 a1, __int64 a2)
{
  signed int v2; // edi@1
  int v3; // eax@3
  int v4; // esi@6
  unsigned __int64 v5; // qtt@6
  unsigned __int64 v6; // qax@7
  unsigned int v7; // ecx@7
  unsigned int v8; // ebx@7
  char v9; // cf@8
  char v10; // cf@8
  int v11; // eax@9
  unsigned __int64 v12; // qax@9
  int v13; // ecx@9
  char v14; // cf@9
  int result; // eax@13

  v2 = 0;
  if ( HIDWORD(a1) < 0 )
  {
    v2 = 1;
    HIDWORD(a1) = -HIDWORD(a1) - ((_DWORD)a1 != 0);
    LODWORD(a1) = -(_DWORD)a1;
  }
  v3 = HIDWORD(a2);
  if ( HIDWORD(a2) < 0 )
  {
    ++v2;
    v3 = -HIDWORD(a2) - ((_DWORD)a2 != 0);
    HIDWORD(a2) = -HIDWORD(a2) - ((_DWORD)a2 != 0);
    LODWORD(a2) = -(_DWORD)a2;
  }
  if ( v3 )
  {
    v8 = v3;
    v7 = a2;
    v6 = a1;
    do
    {
      v9 = v8 & 1;
      v8 >>= 1;
      v7 = __RCR__(v7, v9);
      v10 = BYTE4(v6) & 1;
      HIDWORD(v6) >>= 1;
      LODWORD(v6) = __RCR__(v6, v10);
    }
    while ( v8 );
    v11 = v6 / v7;
    v4 = v11;
    v13 = HIDWORD(a2) * v11;
    v12 = v11 * (unsigned int)a2;
    v14 = v13 >= (unsigned int)-HIDWORD(v12);
    HIDWORD(v12) += v13;
    if ( v14 || HIDWORD(v12) > HIDWORD(a1) || v12 > a1 )
      --v4;
  }
  else
  {
    LODWORD(v5) = a1;
    HIDWORD(v5) = HIDWORD(a1) % (_DWORD)a2;
    v4 = v5 / (unsigned int)a2;
  }
  result = v4;
  if ( v2 == 1 )
    result = -v4;
  return result;
}

//----- (10053490) --------------------------------------------------------
unsigned __int64 __usercall sub_10053490<edx:eax>(unsigned __int64 a1<edx:eax>, unsigned __int8 a2<cl>)
{
  unsigned __int64 result; // qax@2

  if ( a2 >= 0x40u )
    result = 0i64;
  else
    result = a1 >> a2;
  return result;
}

//----- (100534AF) --------------------------------------------------------
signed int __usercall sub_100534AF<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  signed int result; // eax@4
  int v6; // [sp-4h] [bp-8h]@5

  if ( a5 & 0xFFF7FFFF & a4 & 0xFCF0FCE0 )
  {
    if ( a3 )
      *(_DWORD *)a3 = sub_10057574(0, 0);
    *(_DWORD *)sub_10037669(a1) = 22;
    sub_1003A16E(a1, a2);
    result = 22;
  }
  else
  {
    v6 = a5 & 0xFFF7FFFF;
    if ( a3 )
      *(_DWORD *)a3 = sub_10057574(a4, v6);
    else
      sub_10057574(a4, v6);
    result = 0;
  }
  return result;
}

//----- (1005350C) --------------------------------------------------------
void __usercall sub_1005350C(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  sub_1003AF92(a1, a2, a3, a4, 2);
}

//----- (10053515) --------------------------------------------------------
WCHAR __usercall sub_10053515<ax>(int a1<ebx>, int a2<edi>, const WCHAR SrcStr, int a4)
{
  WCHAR result; // ax@1
  int v5; // eax@2
  void *v6; // ecx@2
  int v7; // esi@2
  WCHAR v8; // cx@3
  int v9; // [sp+0h] [bp-14h]@2
  int v10; // [sp+8h] [bp-Ch]@17
  char v11; // [sp+Ch] [bp-8h]@16
  WCHAR DestStr; // [sp+10h] [bp-4h]@12

  result = -1;
  if ( SrcStr != -1 )
  {
    sub_1003018D((int)&v9, a1, a2, a4);
    v7 = v9;
    v5 = *(_DWORD *)(v9 + 168);
    if ( v5 )
    {
      if ( SrcStr >= 0x100u )
      {
        if ( sub_10039DED(v5, 0x100u, &SrcStr, 1u, &DestStr, 1) )
          result = DestStr;
        else
          result = SrcStr;
      }
      else
      {
        if ( sub_1004EA92(v6, SrcStr, 1) )
          result = *(_BYTE *)(*(_DWORD *)(v7 + 148) + SrcStr);
        else
          result = SrcStr;
      }
    }
    else
    {
      v8 = SrcStr;
      if ( (unsigned __int16)(SrcStr - 65) <= 0x19u )
        v8 = SrcStr + 32;
      result = v8;
    }
    if ( v11 )
      *(_DWORD *)(v10 + 112) &= 0xFFFFFFFDu;
  }
  return result;
}

//----- (100535C7) --------------------------------------------------------
int __usercall sub_100535C7<eax>(int a1<ebp>, int a2, int a3, int a4)
{
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // eax@1
  int v7; // eax@2
  int v8; // eax@3
  int v9; // eax@4
  int v10; // eax@5
  int v11; // eax@6
  signed int v12; // edi@14
  double v13; // ST10_8@14
  int v15; // ST18_4@26
  int v16; // ST1C_4@26
  char v17; // ST20_1@26
  signed int v18; // [sp-98h] [bp-A0h]@8
  int v19; // [sp-88h] [bp-90h]@1
  char v20; // [sp-84h] [bp-8Ch]@20
  double v21; // [sp-54h] [bp-5Ch]@19
  int v22; // [sp-44h] [bp-4Ch]@18
  unsigned int v23; // [sp-8h] [bp-10h]@1
  int v24; // [sp-4h] [bp-Ch]@1
  void *v25; // [sp+0h] [bp-8h]@1
  char v26; // [sp+4h] [bp-4h]@25
  int v27; // [sp+8h] [bp+0h]@1

  v24 = a1;
  v25 = (void *)v27;
  v23 = (unsigned int)&v24 ^ __security_cookie;
  v5 = *(_WORD *)a4;
  v6 = *(_DWORD *)a3;
  v19 = *(_WORD *)a4;
  v4 = v6 - 1;
  if ( !v4 )
    goto LABEL_29;
  v7 = v4 - 1;
  if ( !v7 )
  {
    v18 = 4;
    goto LABEL_14;
  }
  v8 = v7 - 1;
  if ( !v8 )
  {
    v18 = 17;
    goto LABEL_14;
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
    v18 = 18;
    goto LABEL_14;
  }
  v10 = v9 - 1;
  if ( !v10 )
  {
LABEL_29:
    v18 = 8;
    goto LABEL_14;
  }
  v11 = v10 - 2;
  if ( !v11 )
  {
    *(_DWORD *)a3 = 1;
    goto LABEL_22;
  }
  if ( v11 == 1 )
  {
    v18 = 16;
LABEL_14:
    v12 = v18;
    HIDWORD(v13) = v5;
    LODWORD(v13) = a3 + 24;
    if ( !sub_1004990A(v12, v13) )
    {
      if ( a2 == 16 || a2 == 22 || a2 == 29 )
      {
        v21 = *(double *)(a3 + 16);
        v22 = v22 & 0xFFFFFFE3 | 3;
      }
      else
      {
        v22 &= 0xFFFFFFFEu;
      }
      sub_10049B36((ULONG_PTR)&v20, (int)&v19, v12, a2, a3 + 8, a3 + 24);
    }
    LOWORD(v5) = v19;
  }
LABEL_22:
  sub_10049F8C(v5);
  if ( *(_DWORD *)a3 == 8 || dword_10075480 || !sub_1002E99E() )
    sub_10049E3C((int)&v26, *(_DWORD *)a3);
  return sub_1002A49B((int)&v26, v15, v16, (unsigned int)&v24 ^ v23, v17);
}
// 100535C7: could not find valid save-restore pair for ebp
// 10074200: using guessed type int __security_cookie;
// 10075480: using guessed type int dword_10075480;

//----- (100536D0) --------------------------------------------------------
int __usercall sub_100536D0<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, signed int a6, int a7)
{
  int v7; // ebx@8
  int v8; // edi@8
  int i; // esi@8
  int v10; // eax@10
  __int16 v11; // ax@11
  int v12; // eax@14
  char v13; // cl@16
  int v14; // ebx@19
  unsigned int v15; // edi@19
  int v16; // eax@35
  int v17; // edx@35
  __int16 v18; // ax@36
  int v19; // eax@37
  int v20; // eax@39
  int v21; // eax@46
  int v22; // esi@51
  int v23; // eax@61
  signed int v25; // [sp-10h] [bp-34h]@24
  int v26; // [sp+0h] [bp-24h]@1
  int v27; // [sp+8h] [bp-1Ch]@72
  char v28; // [sp+Ch] [bp-18h]@71
  int v29; // [sp+10h] [bp-14h]@35
  unsigned int v30; // [sp+14h] [bp-10h]@35
  unsigned int v31; // [sp+18h] [bp-Ch]@8
  int v32; // [sp+1Ch] [bp-8h]@19
  char v33; // [sp+23h] [bp-1h]@14

  sub_1003018D((int)&v26, a1, a2, a3);
  if ( a5 )
    *(_DWORD *)a5 = a4;
  if ( !a4 || (a2 = a6, a6) && (a6 < 2 || a6 > 36) )
  {
    *(_DWORD *)sub_10037669(a1) = 22;
    sub_1003A16E(a1, a2);
LABEL_70:
    v14 = 0;
    goto LABEL_71;
  }
  v8 = v26;
  v31 = 0;
  v7 = *(_BYTE *)a4;
  for ( i = a4 + 1; ; ++i )
  {
    if ( *(_DWORD *)(v8 + 116) <= 1 )
    {
      v11 = *(_WORD *)(*(_DWORD *)(v8 + 144) + 2 * (unsigned __int8)v7);
      v10 = v11 & 8;
    }
    else
    {
      v10 = sub_10042678(v7, v8, (unsigned __int8)v7, 8, (int)&v26);
      v8 = v26;
    }
    if ( !v10 )
      break;
    LOBYTE(v7) = *(_BYTE *)i;
  }
  v12 = a7;
  v33 = v7;
  if ( (_BYTE)v7 == 45 )
  {
    v12 = a7 | 2;
  }
  else
  {
    if ( (_BYTE)v7 != 43 )
    {
      v13 = v33;
      goto LABEL_19;
    }
  }
  v13 = *(_BYTE *)i;
  v33 = *(_BYTE *)i++;
LABEL_19:
  v15 = a6;
  v14 = v31;
  v32 = v12;
  if ( a6 < 0 || a6 == 1 || a6 > 36 )
  {
    if ( a5 )
      *(_DWORD *)a5 = a4;
    goto LABEL_70;
  }
  if ( !a6 )
  {
    if ( v13 != 48 )
    {
      v25 = 10;
LABEL_25:
      v15 = v25;
      goto LABEL_35;
    }
    if ( *(_BYTE *)i != 120 && *(_BYTE *)i != 88 )
    {
      v25 = 8;
      goto LABEL_25;
    }
    v15 = 16;
    goto LABEL_32;
  }
  if ( a6 == 16 && v13 == 48 )
  {
LABEL_32:
    if ( *(_BYTE *)i == 120 || *(_BYTE *)i == 88 )
    {
      v13 = *(_BYTE *)(i + 1);
      v33 = *(_BYTE *)(i + 1);
      i += 2;
    }
  }
LABEL_35:
  v31 = 0xFFFFFFFF / v15;
  v30 = 0xFFFFFFFF % v15;
  v16 = *(_DWORD *)(v26 + 144);
  v17 = v32;
  v29 = *(_DWORD *)(v26 + 144);
  while ( 1 )
  {
    v18 = *(_WORD *)(v16 + 2 * (unsigned __int8)v13);
    if ( v18 & 4 )
    {
      v19 = v33 - 48;
    }
    else
    {
      if ( !(v18 & 0x103) )
        break;
      v20 = v33;
      if ( (unsigned __int8)(v33 - 97) <= 0x19u )
        v20 = v33 - 32;
      v19 = v20 - 55;
    }
    if ( v19 >= v15 )
      break;
    v17 |= 8u;
    if ( v14 < v31 || v14 == v31 && v19 <= v30 )
    {
      v14 = v19 + v15 * v14;
    }
    else
    {
      v21 = a5;
      v17 |= 4u;
      if ( !a5 )
        goto LABEL_51;
    }
    v13 = *(_BYTE *)i;
    v16 = v29;
    v33 = *(_BYTE *)i++;
  }
  v21 = a5;
LABEL_51:
  v22 = i - 1;
  v32 = v17;
  if ( v17 & 8 )
  {
    if ( v17 & 4
      || !(v17 & 1) && (v17 & 2 && (unsigned int)v14 > 0x80000000 || !(v17 & 2) && (unsigned int)v14 > 0x7FFFFFFF) )
    {
      v23 = sub_10037669(v14);
      LOBYTE(v17) = v32;
      *(_DWORD *)v23 = 34;
      if ( v17 & 1 )
        v14 = -1;
      else
        v14 = ((v17 & 2) != 0) + 2147483647;
    }
  }
  else
  {
    if ( v21 )
      v22 = a4;
    v14 = 0;
  }
  if ( a5 )
    *(_DWORD *)a5 = v22;
  if ( v17 & 2 )
    v14 = -v14;
LABEL_71:
  if ( v28 )
    *(_DWORD *)(v27 + 112) &= 0xFFFFFFFDu;
  return v14;
}

//----- (100538F4) --------------------------------------------------------
int __usercall sub_100538F4<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, signed int a5)
{
  int v6; // [sp-14h] [bp-14h]@2

  if ( dword_10077048 )
    v6 = 0;
  else
    v6 = (int)&off_10074C00;
  return sub_100536D0(a1, a2, v6, a3, a4, a5, 0);
}
// 10074C00: using guessed type int *off_10074C00;
// 10077048: using guessed type int dword_10077048;

//----- (1005391E) --------------------------------------------------------
const WCHAR *__usercall sub_1005391E<eax>(int a1<ebx>)
{
  DWORD v1; // edi@1
  LPVOID v2; // esi@1
  int v3; // eax@2
  int v4; // ecx@2
  int v5; // edi@2
  void *v6; // eax@3
  int v7; // ST14_4@4
  const WCHAR *result; // eax@9
  LPVOID lpMem; // [sp+8h] [bp-4h]@1

  v2 = dword_10076990;
  v1 = 0;
  lpMem = 0;
  while ( 1 )
  {
    result = *(const WCHAR **)v2;
    if ( !*(_DWORD *)v2 )
      break;
    v3 = WideCharToMultiByte(v1, v1, result, -1, (LPSTR)v1, v1, (LPCSTR)v1, (LPBOOL)v1);
    v5 = v3;
    if ( !v3 || (v6 = sub_10037506(v4, a1, v3, 1u), lpMem = v6, !v6) )
      return (const WCHAR *)-1;
    v7 = v5;
    v1 = 0;
    if ( !WideCharToMultiByte(0, 0, *(LPCWSTR *)v2, -1, (LPSTR)v6, v7, 0, 0) )
    {
      sub_100309A2(a1, lpMem);
      return (const WCHAR *)-1;
    }
    if ( sub_1005790B(a1, 0, (int)&lpMem, 0) < 0 )
    {
      if ( lpMem )
      {
        sub_100309A2(a1, lpMem);
        lpMem = 0;
      }
    }
    v2 = (char *)v2 + 4;
  }
  return result;
}

//----- (100539AB) --------------------------------------------------------
signed int __usercall sub_100539AB<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  return sub_100539C3(a1, a2, a3, a4, a5, 0);
}

//----- (100539C3) --------------------------------------------------------
signed int __usercall sub_100539C3<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6)
{
  signed int v6; // esi@2
  int v7; // eax@10
  int v9; // [sp+8h] [bp-10h]@1
  int v10; // [sp+Ch] [bp-Ch]@8
  int v11; // [sp+10h] [bp-8h]@13
  char v12; // [sp+14h] [bp-4h]@12

  sub_1003018D((int)&v9, a1, a2, a6);
  if ( a5 )
  {
    if ( a3 && a4 )
    {
      v6 = 2147483647;
      if ( (unsigned int)a5 <= 0x7FFFFFFF )
      {
        if ( *(_DWORD *)(v10 + 8) )
        {
          v7 = sub_1003912C(a1, v10, (int)&v9, *(_DWORD *)(v10 + 540), 0x1001u, a3, a5, a4, a5, *(_DWORD *)(v10 + 4));
          if ( v7 )
            v6 = v7 - 2;
        }
        else
        {
          v6 = sub_10057C0C(a1, v10, a3, a4, a5, a6);
        }
      }
      else
      {
        *(_DWORD *)sub_10037669(a1) = 22;
        sub_1003A16E(a1, a2);
      }
    }
    else
    {
      *(_DWORD *)sub_10037669(a1) = 22;
      sub_1003A16E(a1, a2);
      v6 = 2147483647;
    }
  }
  else
  {
    v6 = 0;
  }
  if ( v12 )
    *(_DWORD *)(v11 + 112) &= 0xFFFFFFFDu;
  return v6;
}

//----- (10053ABC) --------------------------------------------------------
void __usercall sub_10053ABC(int a1<ebx>, __int64 a2<st0>, int edx0<edx>, __int16 a4<cx>, __int16 a3<fpstat>, char c0_0, char c2_0, char a8, char a5, char a6, char a7)
{
  char v11; // zf@2
  int v12; // ST04_4@2
  int v13; // eax@2
  char v14; // ST00_1@3

  if ( !dword_10077A94 )
    goto LABEL_9;
  __asm { stmxcsr [esp+8+var_4] }
  v13 = v12 & 0x7F80;
  v11 = v13 == 8064;
  if ( v13 == 8064 )
    v11 = (v14 & 0x7F) == 127;
  if ( v11 )
    sub_10057CE0(a1, a2);
  else
LABEL_9:
    sub_100581DE((int)&unk_10067E7A, a4, a3, *(double *)&a2, a5, a6, a7);
}
// 10077A94: using guessed type int dword_10077A94;

//----- (10053B0B) --------------------------------------------------------
int __thiscall sub_10053B0B(int this, int a2, int a3, int a4)
{
  int v5; // edi@1

  v5 = this;
  *(_DWORD *)this = off_10067868;
  *(_DWORD *)(this + 4) = 0;
  sub_1004B382(this + 8, a2, a3, a4);
  *(_WORD *)(v5 + 68) = 0;
  *(_DWORD *)(v5 + 76) = 0;
  _ECX = &unk_10077354;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  *(_DWORD *)(v5 + 72) = _EAX + 1;
  *(_DWORD *)(v5 + 36) = v5;
  return v5;
}
// 10067868: using guessed type int (*off_10067868[2])();

//----- (10053B52) --------------------------------------------------------
int __thiscall sub_10053B52(int this)
{
  return (*(int (**)(void))(*(_DWORD *)(this + 8) + 12))();
}

//----- (10053B5A) --------------------------------------------------------
int __thiscall sub_10053B5A(int this)
{
  return *(_DWORD *)(this + 72);
}

//----- (10053B5E) --------------------------------------------------------
int __thiscall sub_10053B5E(int this)
{
  return (**(int (***)(void))(this + 8))();
}

//----- (10053B65) --------------------------------------------------------
int __thiscall sub_10053B65(int this, int a2)
{
  int v2; // esi@1
  int v4; // [sp-4h] [bp-14h]@3
  int (__stdcall **v5)(char); // [sp+4h] [bp-Ch]@3

  v2 = this;
  if ( !a2 )
  {
    a2 = (int)"pScheduler";
    sub_1002AEA4((int)&v5, &a2);
    v5 = &off_100602FC;
    v4 = (int)&unk_1006D8F4;
    goto LABEL_6;
  }
  if ( *(_DWORD *)(*(_DWORD *)(this + 28) + 8) != a2 )
  {
    sub_1002FFD5((int)&v5);
    v4 = (int)&unk_1006D8B8;
LABEL_6:
    sub_100355DB((int)&v5, v4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10053BCA);
  }
  sub_10053BCA(this);
  return sub_1004C518(v2);
}
// 1004C518: using guessed type _DWORD __stdcall sub_1004C518(_DWORD);
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);

//----- (10053BCA) --------------------------------------------------------
int __thiscall sub_10053BCA(int this)
{
  int result; // eax@1

  result = this + 76;
  _EDX = -1;
  __asm { lock xadd [eax], edx }
  if ( _EDX == 1 )
    result = sub_10053BEF(this);
  return result;
}

//----- (10053BE2) --------------------------------------------------------
int __thiscall sub_10053BE2(int this)
{
  return sub_1004C91D(*(_DWORD *)(this + 28), this + 8);
}

//----- (10053BEF) --------------------------------------------------------
int __thiscall sub_10053BEF(int this)
{
  return sub_1004C3A4(*(_DWORD *)(this + 28), this + 8);
}

//----- (10053BFC) --------------------------------------------------------
int __thiscall sub_10053BFC(int this, int a2, int a3, int a4)
{
  int v5; // esi@1

  v5 = this;
  sub_10053B0B(this, a2, a3, a4);
  *(_DWORD *)v5 = off_10067894;
  *(_DWORD *)(v5 + 80) = 0;
  *(_DWORD *)(v5 + 84) = 0;
  return v5;
}
// 10067894: using guessed type int (*off_10067894[2])();

//----- (10053C2B) --------------------------------------------------------
bool __thiscall sub_10053C2B(int this, int a2)
{
  return *(_WORD *)(a2 + 4) == *(_WORD *)(this + 4) && *(_DWORD *)a2 == *(_DWORD *)this;
}

//----- (10053C4C) --------------------------------------------------------
int __thiscall sub_10053C4C(int this, char a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_10067868;
  *(_DWORD *)(this + 8) = off_10066148;
  if ( a2 & 1 )
    sub_1002A4AA((LPVOID)this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10066148: using guessed type int (*off_10066148[2])();
// 10067868: using guessed type int (*off_10067868[2])();

//----- (10053C73) --------------------------------------------------------
int __thiscall sub_10053C73(void *this)
{
  void *v1; // esi@1
  int result; // eax@4
  char v3; // [sp+8h] [bp-10h]@2
  int v4; // [sp+10h] [bp-8h]@1
  void (__cdecl *v5)(); // [sp+14h] [bp-4h]@1

  v1 = this;
  v4 = 0;
  v5 = sub_10034BD7;
  while ( !*((_DWORD *)v1 + 1) )
    sub_100282E0((int)&v3);
  result = *((_DWORD *)v1 + 1);
  *((_DWORD *)v1 + 1) = 0;
  return result;
}

//----- (10053CA2) --------------------------------------------------------
BOOL __thiscall sub_10053CA2(void *this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v4; // ebx@2
  BOOL result; // eax@5
  int v13; // eax@8
  int v14; // [sp-4h] [bp-28h]@12
  char v15; // [sp+Ch] [bp-18h]@8
  int (__stdcall **v16)(char); // [sp+18h] [bp-Ch]@11

  v2 = a2;
  v3 = (int)this;
  if ( !a2 )
  {
    a2 = (int)"pContext";
    sub_1002AEA4((int)&v16, &a2);
    v16 = &off_100602FC;
    v14 = (int)&unk_1006D8F4;
    v13 = (int)&v16;
    goto LABEL_12;
  }
  v4 = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 8))(a2);
  if ( !v4 )
  {
    v14 = v2;
    v4 = (*(int (**)(void))(**(_DWORD **)(v3 + 28) + 28))();
  }
  _EAX = v3 + 76;
  _ECX = 1;
  __asm { lock xadd [eax], ecx }
  if ( _ECX == 1 )
  {
    result = v3 + 4;
    *(_DWORD *)(v3 + 4) = v2;
    return result;
  }
  sub_10053FA7((void *)v3);
  if ( *(_DWORD *)(v3 + 80) && v4 != *(_DWORD *)(v3 + 80) )
  {
    sub_1002FFD5((int)&v15);
    v13 = (int)&v15;
LABEL_12:
    sub_100355DB(v13, v14);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10053D54);
  }
  *(_DWORD *)(v3 + 84) = 0;
  sub_10053BE2(v3);
  sub_10053D54((void *)v3, v4);
  return sub_10054703(v4);
}
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);

//----- (10053D54) --------------------------------------------------------
int __thiscall sub_10053D54(void *this, int a2)
{
  void *v3; // esi@1
  int v4; // ebx@1
  int v5; // eax@1

  v3 = this;
  sub_10054757(a2);
  *((_DWORD *)v3 + 20) = a2;
  *(_DWORD *)(a2 + 16) = v3;
  v4 = *((_DWORD *)v3 + 7);
  v5 = (**(int (__thiscall ***)(void *))v3)(v3);
  return sub_10053F71(
           (void *)a2,
           *(_DWORD *)(52 * v5 + *(_DWORD *)(v4 + 16)),
           *(_WORD *)(52 * v5 + *(_DWORD *)(v4 + 16) + 12),
           0);
}

//----- (10053DB1) --------------------------------------------------------
char __thiscall sub_10053DB1(int this, int a2)
{
  int v2; // esi@1
  char *v3; // eax@3
  int v4; // edi@4
  LPVOID v13; // eax@11
  int v14; // esi@11
  int v15; // ecx@11
  int v16; // eax@13
  int v17; // [sp-4h] [bp-30h]@3
  int v18; // [sp-4h] [bp-30h]@11
  char v19; // [sp+8h] [bp-24h]@5
  char v20; // [sp+14h] [bp-18h]@3
  int (__stdcall **v21)(char); // [sp+20h] [bp-Ch]@10

  v2 = this;
  if ( !a2 )
  {
    a2 = (int)"pContext";
    sub_1002AEA4((int)&v21, &a2);
    v21 = &off_100602FC;
    v17 = (int)&unk_1006D8F4;
    v3 = (char *)&v21;
LABEL_11:
    sub_100355DB((int)v3, v17);
    __asm { int     3               ; Trap to Debugger }
    v18 = v2;
    v14 = v15;
    v13 = TlsGetValue(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v15 + 28) + 12) + 112));
    if ( v13 && ((_BYTE)v13 & 3) == 1 && (v16 = (unsigned int)v13 & 0xFFFFFFFE) != 0 && v16 == *(_DWORD *)(v14 + 80) )
      *(_DWORD *)(v16 + 16) = 0;
    else
      sub_10053FA7((void *)v14);
    return (*(int (__thiscall **)(int, signed int, int))(*(_DWORD *)v14 + 32))(v14, 1, v18);
  }
  if ( !*(_DWORD *)(this + 80) )
  {
    sub_1002FFD5((int)&v20);
    v17 = (int)&unk_1006D8B8;
    v3 = &v20;
    goto LABEL_11;
  }
  v4 = (*(int (**)(void))(*(_DWORD *)a2 + 8))();
  if ( *(_DWORD *)(v2 + 80) != v4 )
  {
    sub_1002FFD5((int)&v19);
    v17 = (int)&unk_1006D8B8;
    v3 = &v19;
    goto LABEL_11;
  }
  _EAX = v2 + 76;
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  if ( _ECX == 1 )
  {
    *(_DWORD *)(v2 + 84) = *(_DWORD *)(v2 + 80);
    sub_10053BEF(v2);
    sub_10054782(v4);
  }
  else
  {
    sub_10053C73((void *)v2);
  }
  return 1;
}
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);

//----- (10053E97) --------------------------------------------------------
BOOL __thiscall sub_10053E97(int this, int a2)
{
  int v2; // esi@1
  char *v3; // eax@3
  int v5; // [sp-4h] [bp-2Ch]@3
  char v6; // [sp+4h] [bp-24h]@5
  char v7; // [sp+10h] [bp-18h]@3
  int (__stdcall **v8)(char); // [sp+1Ch] [bp-Ch]@7

  v2 = this;
  if ( !a2 )
  {
    a2 = (int)"pContext";
    sub_1002AEA4((int)&v8, &a2);
    v8 = &off_100602FC;
    v5 = (int)&unk_1006D8F4;
    v3 = (char *)&v8;
    goto LABEL_8;
  }
  if ( !*(_DWORD *)(this + 80) )
  {
    sub_1002FFD5((int)&v7);
    v5 = (int)&unk_1006D8B8;
    v3 = &v7;
LABEL_8:
    sub_100355DB((int)v3, v5);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10053F14);
  }
  if ( *(_DWORD *)(this + 80) != (*(int (**)(void))(*(_DWORD *)a2 + 8))() )
  {
    sub_1002FFD5((int)&v6);
    v5 = (int)&unk_1006D8B8;
    v3 = &v6;
    goto LABEL_8;
  }
  return sub_1003D41F(*(_DWORD *)(*(_DWORD *)(v2 + 28) + 12));
}
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);

//----- (10053F14) --------------------------------------------------------
int __thiscall sub_10053F14(int this, int a2)
{
  int result; // eax@1
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // esi@1
  int v12; // esi@6
  int v13; // eax@6

  v5 = this;
  v4 = *(_DWORD *)(this + 80);
  result = this + 76;
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  v3 = _ECX - 1;
  if ( v3 > 0 )
  {
    v13 = sub_10053C73((void *)v5);
    v12 = v13;
    result = (*(int (__thiscall **)(int))(*(_DWORD *)v13 + 8))(v13);
    if ( v4 != result )
      result = (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v4 + 4))(v4, v12, a2);
  }
  else
  {
    if ( !v3 )
      result = sub_10053BEF(v5);
    *(_DWORD *)(v5 + 80) = 0;
    if ( a2 == 1 )
      result = sub_10054782(v4);
  }
  return result;
}

//----- (10053F71) --------------------------------------------------------
int __thiscall sub_10053F71(void *this, int a2, __int16 a3, int a4)
{
  void *v4; // edi@1
  int result; // eax@3

  v4 = this;
  if ( !sub_10053C2B((int)((char *)this + 48), (int)&a2) )
    sub_1003BB75((DWORD_PTR *)&a2, *((HANDLE *)v4 + 2));
  *((_WORD *)v4 + 26) = a3;
  result = a2;
  *((_DWORD *)v4 + 12) = a2;
  return result;
}

//----- (10053FA7) --------------------------------------------------------
char __thiscall sub_10053FA7(void *this)
{
  void *v1; // esi@1
  char result; // al@3
  char v3; // [sp+8h] [bp-10h]@3
  int v4; // [sp+10h] [bp-8h]@1
  void (__cdecl *v5)(); // [sp+14h] [bp-4h]@1

  v1 = this;
  v4 = 0;
  v5 = sub_10034BD7;
  while ( *((_DWORD *)v1 + 20) && !*((_DWORD *)v1 + 21) )
    result = sub_100282E0((int)&v3);
  return result;
}

//----- (10053FD5) --------------------------------------------------------
int __thiscall sub_10053FD5(int this, int a2)
{
  *(_DWORD *)(this + 64) = a2;
  return (*(int (__stdcall **)(int))(*(_DWORD *)a2 + 12))(this);
}

//----- (10053FEA) --------------------------------------------------------
void __fastcall sub_10053FEA(int a1)
{
  int v1; // esi@1
  DWORD v2; // eax@2
  int v3; // edi@3
  int v4; // [sp+8h] [bp-8h]@1
  int v5; // [sp+Ch] [bp-4h]@1

  v1 = a1;
  v4 = 8;
  v5 = 0;
  if ( !*(_DWORD *)(a1 + 36) )
  {
    v2 = (*(int (**)(void))(**(_DWORD **)(a1 + 4) + 16))();
    TlsSetValue(v2, (LPVOID)(v1 | 1));
    while ( !*(_DWORD *)(v1 + 36) )
    {
      (*(void (__stdcall **)(int))(**(_DWORD **)(v1 + 64) + 12))(v1);
      (*(void (__stdcall **)(int *))(**(_DWORD **)(v1 + 64) + 16))(&v4);
      v3 = *(_DWORD *)(v1 + 16);
      *(_DWORD *)(v1 + 64) = 0;
      *(_DWORD *)(v1 + 16) = 0;
      sub_10054064(v1);
      if ( v3 )
        sub_10053F14(v3, 1);
      else
        sub_10054782(v1);
    }
  }
}

//----- (10054064) --------------------------------------------------------
int __thiscall sub_10054064(int this)
{
  int v2; // edx@1
  int v3; // ecx@1

  v2 = this;
  v3 = *(_DWORD *)(this + 4);
  *(_DWORD *)(v2 + 64) = 0;
  return (*(int (__stdcall **)(int))(*(_DWORD *)v3 + 4))(v2);
}

//----- (10054074) --------------------------------------------------------
int __thiscall sub_10054074(int this, int a2)
{
  int v2; // eax@1
  int v3; // edx@2
  int (__stdcall **v5)(char); // [sp+0h] [bp-Ch]@10

  v2 = a2;
  if ( !a2 )
    goto LABEL_14;
  v3 = *(_DWORD *)(this + 16);
  if ( v3 )
    goto LABEL_5;
  if ( a2 != 1 )
  {
LABEL_14:
    a2 = (int)"switchState";
    sub_1002AEA4((int)&v5, &a2);
    v5 = &off_100602FC;
    sub_100355DB((int)&v5, (int)&unk_1006D8F4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_100540D6);
  }
  if ( !v3 )
    return sub_10054782(this);
LABEL_5:
  if ( a2 == 2 )
    *(_DWORD *)(this + 16) = 0;
  return sub_10053F14(v3, v2);
}
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);

//----- (100540D6) --------------------------------------------------------
BOOL __thiscall sub_100540D6(void *this, int a2, int a3)
{
  int v3; // ebx@1
  void *v4; // edi@1
  int v5; // esi@2
  void *v6; // ecx@4
  int v7; // ebx@4
  BOOL result; // eax@8
  int (__stdcall **v9)(char); // [sp+Ch] [bp-Ch]@11

  v3 = a2;
  v4 = this;
  if ( !a2 )
  {
    a2 = (int)"pContext";
    sub_1002AEA4((int)&v9, &a2);
    v9 = &off_100602FC;
    sub_100355DB((int)&v9, (int)&unk_1006D8F4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10054178);
  }
  v5 = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 8))(a2);
  if ( !v5 )
    v5 = (*(int (__cdecl **)(int))(**(_DWORD **)(*((_DWORD *)v4 + 4) + 28) + 28))(v3);
  v6 = (void *)*((_DWORD *)v4 + 4);
  v7 = a3;
  *((_DWORD *)v4 + 4) = 0;
  if ( v7 == 1 )
    *((_DWORD *)v4 + 8) = 1;
  sub_10053D54(v6, v5);
  if ( v7 && v7 == 1 )
  {
    SignalObjectAndWait(*(HANDLE *)(v5 + 12), *((HANDLE *)v4 + 3), 0xFFFFFFFFu, 1);
    result = (BOOL)((char *)v4 + 32);
    *((_DWORD *)v4 + 8) = 0;
  }
  else
  {
    result = sub_10054703(v5);
  }
  return result;
}
// 100602FC: using guessed type int (__stdcall *off_100602FC)(char);

//----- (10054178) --------------------------------------------------------
int __cdecl sub_10054178(int a1)
{
  int result; // eax@1
  int v2; // ecx@1

  v2 = *(_DWORD *)(*(_DWORD *)a1 - 4);
  result = a1 - *(_DWORD *)(v2 + 4);
  if ( *(_DWORD *)(v2 + 8) )
    result -= *(_DWORD *)(a1 - *(_DWORD *)(v2 + 8));
  return result;
}

//----- (10054195) --------------------------------------------------------
int __cdecl sub_10054195(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // edx@1
  signed int v6; // ecx@1
  signed int v7; // ebx@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // eax@1
  int v11; // edi@2
  int v13; // ebx@19
  int v14; // [sp+Ch] [bp-10h]@1
  unsigned int v15; // [sp+10h] [bp-Ch]@1
  unsigned int v16; // [sp+14h] [bp-8h]@1
  int v17; // [sp+18h] [bp-4h]@1
  signed int v18; // [sp+28h] [bp+Ch]@1

  v10 = *(_DWORD *)(a2 + 16);
  v9 = 0;
  v8 = *(_DWORD *)(v10 + 12);
  v6 = -1;
  v5 = 0;
  v17 = 0;
  v14 = *(_DWORD *)(v10 + 12);
  v15 = *(_DWORD *)(v10 + 8);
  v16 = 0;
  v18 = -1;
  v7 = 0;
  if ( !v15 )
    return 0;
  while ( 1 )
  {
    v11 = *(_DWORD *)(v8 + 4 * v7);
    if ( v7 - v6 <= v16 )
      goto LABEL_8;
    if ( *(_DWORD *)v11 != a5 )
    {
      if ( sub_10039310(*(_DWORD *)v11 + 8, a5 + 8) )
        goto LABEL_8;
      v5 = v17;
    }
    if ( v5 )
    {
      if ( !(*(_BYTE *)(v11 + 20) & 3) && !(*(_BYTE *)(v5 + 20) & 1) )
        return v11;
      return 0;
    }
    v9 = v11;
    v18 = v7;
    v16 = *(_DWORD *)(v11 + 4);
LABEL_8:
    if ( *(_DWORD *)v11 == a3 )
      goto LABEL_29;
    if ( !sub_10039310(*(_DWORD *)v11 + 8, a3 + 8) )
    {
LABEL_29:
      if ( sub_100544AB(a1, v11 + 8) == a4 )
        break;
    }
    v5 = v17;
LABEL_14:
    ++v7;
    if ( v7 >= v15 )
      return 0;
    v6 = v18;
    v8 = v14;
  }
  if ( !v9 )
  {
    v5 = v11;
    v17 = v11;
    goto LABEL_14;
  }
  v13 = v7 - v18;
  if ( v13 > v16 )
  {
    if ( !(*(_BYTE *)(v9 + 20) & 3) )
      goto LABEL_22;
    return 0;
  }
  if ( !(*(_BYTE *)(v9 + 20) & 0x40) )
  {
    if ( !v18 )
    {
LABEL_22:
      if ( *(_BYTE *)(v11 + 20) & 1 )
        return 0;
    }
    return v9;
  }
  return (*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v9 + 24) + 12) + 4 * v13) + 20) & 1) == 0 ? v9 : 0;
}

//----- (100542A8) --------------------------------------------------------
int __cdecl sub_100542A8(int a1, int a2, int a3)
{
  int v3; // edx@1
  unsigned int v4; // edi@1
  unsigned int v5; // esi@1
  int v6; // eax@1
  int v7; // eax@3
  int i; // esi@7
  int v10; // eax@8
  int v11; // [sp+Ch] [bp-4h]@2
  int v12; // [sp+18h] [bp+8h]@1

  v6 = *(_DWORD *)(a1 + 16);
  v3 = *(_DWORD *)(v6 + 12);
  v4 = *(_DWORD *)(v6 + 8);
  v5 = 0;
  v12 = *(_DWORD *)(v6 + 12);
  if ( v4 )
  {
    while ( 1 )
    {
      v11 = *(_DWORD *)(v3 + 4 * v5);
      if ( *(_DWORD *)v11 == a3 )
        break;
      v7 = sub_10039310(*(_DWORD *)v11 + 8, a3 + 8);
      v3 = v12;
      if ( !v7 )
        break;
      ++v5;
      if ( v5 >= v4 )
        return 0;
    }
    for ( i = v5 + 1; i < v4; ++i )
    {
      v10 = *(_DWORD *)(v3 + 4 * i);
      if ( *(_BYTE *)(v10 + 20) & 4 )
        break;
      if ( *(_DWORD *)v10 == a2 || !sub_10039310(*(_DWORD *)v10 + 8, a2 + 8) )
        return v11;
      v3 = v12;
    }
  }
  return 0;
}

//----- (1005432E) --------------------------------------------------------
int __cdecl sub_1005432E(int a1, int a2, int a3, int a4, int a5)
{
  signed int v5; // ecx@1
  signed int v6; // ebx@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // eax@1
  int v10; // esi@2
  char v11; // dl@11
  char v12; // cl@16
  int v13; // esi@16
  int v14; // eax@17
  int v15; // eax@20
  int v16; // eax@24
  int result; // eax@31
  int v18; // [sp+Ch] [bp-20h]@1
  unsigned int v19; // [sp+10h] [bp-1Ch]@1
  int v20; // [sp+14h] [bp-18h]@1
  signed int v21; // [sp+18h] [bp-14h]@1
  unsigned int v22; // [sp+1Ch] [bp-10h]@1
  signed int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1
  char v26; // [sp+3Bh] [bp+Fh]@1

  v9 = *(_DWORD *)(a2 + 16);
  v8 = *(_DWORD *)(v9 + 12);
  v5 = -1;
  v7 = 0;
  v25 = 0;
  v20 = 0;
  v24 = 0;
  v18 = *(_DWORD *)(v9 + 12);
  v19 = *(_DWORD *)(v9 + 8);
  v22 = 0;
  v23 = -1;
  v26 = 1;
  v21 = -1;
  v6 = 0;
  if ( !v19 )
    goto LABEL_34;
  while ( 1 )
  {
    v10 = *(_DWORD *)(v8 + 4 * v6);
    if ( v6 - v5 > v22 )
    {
      if ( *(_DWORD *)v10 == a5 || !sub_10039310(*(_DWORD *)v10 + 8, a5 + 8) )
      {
        if ( !(*(_BYTE *)(v10 + 20) & 3) )
          v20 = v10;
        v24 = v10;
        v23 = v6;
        v22 = *(_DWORD *)(v10 + 4);
      }
    }
    if ( *(_DWORD *)v10 != a3 && sub_10039310(*(_DWORD *)v10 + 8, a3 + 8) || sub_100544AB(a1, v10 + 8) != a4 )
      goto LABEL_23;
    v11 = v26;
    if ( v6 - v23 <= v22 )
    {
      if ( v26 )
      {
        if ( *(_BYTE *)(v24 + 20) & 0x40 )
        {
          v13 = v24;
          v14 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v24 + 24) + 12) + 4 * (v6 - v23));
          v11 = (*(_DWORD *)(v14 + 20) & 1) == 0 ? v26 : 0;
          v26 = (*(_DWORD *)(v14 + 20) & 1) == 0 ? v26 : 0;
          v12 = ~(unsigned __int8)(*(_DWORD *)(v14 + 20) >> 2) & 1;
        }
        else
        {
          if ( !v23 )
          {
            v11 = (*(_BYTE *)(v10 + 20) & 1) == 0 ? v26 : 0;
            v26 = (*(_BYTE *)(v10 + 20) & 1) == 0 ? v26 : 0;
          }
          v13 = v24;
          v12 = 1;
        }
        if ( v11 && v12 )
        {
          v15 = sub_100544AB(a1, v13 + 8);
          if ( v7 && v21 != v15 )
            goto LABEL_34;
          v7 = v13;
          v21 = v15;
LABEL_23:
          v11 = v26;
        }
      }
LABEL_24:
      v16 = v25;
      goto LABEL_25;
    }
    if ( *(_BYTE *)(v10 + 20) & 5 )
      goto LABEL_24;
    v16 = v10;
    v25 = v10;
LABEL_25:
    ++v6;
    if ( v6 >= v19 )
      break;
    v5 = v23;
    v8 = v18;
  }
  if ( v11 && v7 )
    return v7;
  if ( !v16 || (result = v20, !v20) )
LABEL_34:
    result = 0;
  return result;
}

//----- (100544AB) --------------------------------------------------------
int __cdecl sub_100544AB(int a1, int a2)
{
  int v2; // edx@1

  v2 = 0;
  if ( *(_DWORD *)(a2 + 4) >= 0 )
    v2 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 4) + a1) + *(_DWORD *)(a2 + 8)) + *(_DWORD *)(a2 + 4);
  return v2 + *(_DWORD *)a2;
}

//----- (100544CF) --------------------------------------------------------
bool __cdecl sub_100544CF(int a1, int a2, int a3, int a4, int a5)
{
  bool result; // eax@2
  int v6; // eax@4
  int v7; // ecx@4
  int v8; // ebx@4
  int v9; // edi@4
  int v10; // esi@4
  int v11; // eax@5
  int v12; // eax@10
  char v13; // [sp+10h] [bp-28h]@13
  int v14; // [sp+1Ch] [bp-1Ch]@10
  CPPEH_RECORD ms_exc; // [sp+20h] [bp-18h]@4

  if ( a1 )
  {
    v10 = 0;
    ms_exc.disabled = 0;
    v8 = sub_10054178(a1);
    v6 = *(_DWORD *)(*(_DWORD *)a1 - 4);
    v9 = a1 - a2 - v8;
    v7 = *(_DWORD *)(*(_DWORD *)(v6 + 16) + 4);
    if ( v7 & 1 )
    {
      if ( v7 & 2 )
        v11 = sub_1005432E(v8, v6, a3, v9, a4);
      else
        v11 = sub_10054195(v8, v6, a3, v9, a4);
    }
    else
    {
      v11 = sub_100542A8(v6, a3, a4);
    }
    if ( v11 )
    {
      v12 = sub_100544AB(v8, v11 + 8);
      v10 = v8 + v12;
      v14 = v8 + v12;
    }
    else
    {
      v14 = 0;
      if ( a5 )
      {
        sub_1002AE51((int)&v13, (unsigned int)"Bad dynamic_cast!");
        sub_100355DB((int)&v13, (int)&unk_1006D9A4);
        return ms_exc.exc_ptr->ExceptionRecord->ExceptionCode == -1073741819;
      }
    }
    ms_exc.disabled = -2;
    result = v10;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100545AB) --------------------------------------------------------
LPVOID __thiscall sub_100545AB(LPVOID lpParameter, int a2, int a3)
{
  LPVOID v3; // edi@1
  int v4; // ecx@1
  HANDLE v12; // eax@1
  int v13; // eax@2
  HANDLE v14; // eax@4
  int v15; // eax@5
  char *v16; // eax@7
  int v18; // ecx@10
  int v19; // esi@10
  int v20; // [sp-4h] [bp-30h]@7
  char v21; // [sp+Ch] [bp-20h]@7
  char v22; // [sp+1Ch] [bp-10h]@9

  v3 = lpParameter;
  *((_DWORD *)lpParameter + 1) = a2;
  v4 = *((_DWORD *)lpParameter + 1);
  *(_DWORD *)v3 = off_10067904;
  *((_DWORD *)v3 + 5) = a3;
  *((_DWORD *)v3 + 6) = 0;
  *((_BYTE *)v3 + 28) = 0;
  _ESI = 1;
  *((_DWORD *)v3 + 8) = 1;
  *((_DWORD *)v3 + 9) = 0;
  (*(void (**)(void))(*(_DWORD *)v4 + 8))();
  _EAX = &unk_10074368;
  __asm { lock xadd [eax], esi }
  *((_DWORD *)v3 + 10) = _ESI + 1;
  v12 = CreateEventW(0, 0, 0, 0);
  *((_DWORD *)v3 + 3) = v12;
  if ( v12 )
  {
    v14 = sub_100349DA(
            0,
            *((_DWORD *)v3 + 5) << 10,
            (LPTHREAD_START_ROUTINE)sub_1005479C,
            v3,
            0x10000u,
            (LPDWORD)v3 + 11);
    *((_DWORD *)v3 + 2) = v14;
    if ( v14 )
      return v3;
    CloseHandle(*((HANDLE *)v3 + 3));
    (*(void (**)(void))(**((_DWORD **)v3 + 1) + 12))();
    v15 = GetLastError();
    if ( v15 > 0 )
      v15 = (unsigned __int16)v15 | 0x80070000;
    sub_10030097((int)&v21, v15);
    v20 = (int)&unk_1006D6F4;
    v16 = &v21;
  }
  else
  {
    v13 = GetLastError();
    if ( v13 > 0 )
      v13 = (unsigned __int16)v13 | 0x80070000;
    sub_10030079((int)&v22, v13);
    v20 = (int)&unk_1006C6F4;
    v16 = &v22;
  }
  sub_100355DB((int)v16, v20);
  __asm { int     3               ; Trap to Debugger }
  v19 = v18;
  sub_1003178B(v18, 0, a2);
  *(_DWORD *)v19 = &off_10061D00;
  return (LPVOID)v19;
}
// 10061D00: using guessed type int (__stdcall *off_10061D00)(char);
// 10067904: using guessed type int (*off_10067904[4])();

//----- (100546AB) --------------------------------------------------------
int __thiscall sub_100546AB(int this)
{
  int v2; // edi@1
  void *v3; // ST00_4@1

  v2 = this;
  v3 = *(void **)(this + 12);
  *(_DWORD *)this = off_10067904;
  CloseHandle(v3);
  CloseHandle(*(HANDLE *)(v2 + 8));
  return (*(int (**)(void))(**(_DWORD **)(v2 + 4) + 12))();
}
// 10067904: using guessed type int (*off_10067904[4])();

//----- (100546CF) --------------------------------------------------------
void *__thiscall sub_100546CF(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_100546AB(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100546EE) --------------------------------------------------------
BOOL __thiscall sub_100546EE(int this)
{
  void *v2; // ST00_4@1

  v2 = *(void **)(this + 12);
  *(_DWORD *)(this + 36) = 1;
  return SetEvent(v2);
}

//----- (100546FF) --------------------------------------------------------
int __thiscall sub_100546FF(int this)
{
  return *(_DWORD *)(this + 40);
}

//----- (10054703) --------------------------------------------------------
BOOL __thiscall sub_10054703(int this)
{
  return SetEvent(*(HANDLE *)(this + 12));
}

//----- (1005470D) --------------------------------------------------------
BOOL __thiscall sub_1005470D(int this, int nPriority)
{
  BOOL result; // eax@1
  int v3; // eax@2
  char v4; // [sp+0h] [bp-10h]@5

  *(_DWORD *)(this + 24) = nPriority;
  result = SetThreadPriority(*(HANDLE *)(this + 8), nPriority);
  if ( !result )
  {
    v3 = GetLastError();
    if ( v3 > 0 )
      v3 = (unsigned __int16)v3 | 0x80070000;
    sub_10030079((int)&v4, v3);
    sub_100355DB((int)&v4, (int)&unk_1006C6F4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10054757);
  }
  return result;
}

//----- (10054757) --------------------------------------------------------
char __thiscall sub_10054757(int this)
{
  int v1; // esi@1
  char result; // al@3
  char v3; // [sp+4h] [bp-10h]@3
  int v4; // [sp+Ch] [bp-8h]@2
  void (__cdecl *v5)(); // [sp+10h] [bp-4h]@2

  v1 = this;
  if ( !*(_DWORD *)(this + 32) )
  {
    v4 = 0;
    v5 = sub_10034BD7;
    do
      result = sub_100282E0((int)&v3);
    while ( !*(_DWORD *)(v1 + 32) );
  }
  return result;
}

//----- (10054782) --------------------------------------------------------
int __thiscall sub_10054782(int this)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = this + 32;
  *(_DWORD *)(this + 32) = 1;
  WaitForSingleObject(*(HANDLE *)(this + 12), 0xFFFFFFFFu);
  result = *(_DWORD *)v2;
  *(_DWORD *)v2 = 0;
  return result;
}

//----- (1005479C) --------------------------------------------------------
int __stdcall sub_1005479C(int a1)
{
  int v2; // esi@1

  v2 = a1;
  WaitForSingleObject(*(HANDLE *)(a1 + 12), 0xFFFFFFFFu);
  *(_DWORD *)(a1 + 32) = 0;
  (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 20))(v2);
  (*(void (__thiscall **)(int, signed int))(*(_DWORD *)v2 + 16))(v2, 1);
  sub_10034963(0);
  return 0;
}

//----- (100547D4) --------------------------------------------------------
signed int __usercall sub_100547D4<eax>(int a1<ebx>, int a2<edi>, unsigned int a3, int a4, unsigned int a5, unsigned int a6)
{
  unsigned int v7; // [sp-8h] [bp-8h]@3
  int v8; // [sp-4h] [bp-4h]@3

  if ( a6 != 10 || (signed int)a3 >= 0 )
  {
    v8 = 0;
    v7 = a6;
  }
  else
  {
    v8 = 1;
    v7 = 10;
  }
  return sub_100547FD(a1, a2, a3, a4, a5, v7, v8);
}

//----- (100547FD) --------------------------------------------------------
signed int __userpurge sub_100547FD<eax>(int a1<ebx>, int a2<edi>, unsigned int a3, int a4, unsigned int a5, unsigned int a6, int a7)
{
  int v8; // eax@4
  signed int v9; // esi@5
  unsigned int v10; // edx@9
  char v11; // zf@9
  signed int v12; // ecx@11
  int v13; // eax@12
  unsigned int v14; // ett@12
  int v15; // eax@13
  int v16; // edi@20
  __int16 v17; // cx@21
  signed int v18; // [sp-Ch] [bp-10h]@4
  signed int v19; // [sp+1Ch] [bp+18h]@9

  if ( !a4 )
  {
    *(_DWORD *)sub_10037669(a1) = 22;
    sub_1003A16E(a1, a2);
    return 22;
  }
  if ( !a5 )
    goto LABEL_25;
  *(_WORD *)a4 = 0;
  if ( a5 <= (unsigned int)(a7 != 0) + 1 )
  {
    v8 = sub_10037669(a1);
    v18 = 34;
    goto LABEL_5;
  }
  v9 = 34;
  if ( a6 - 2 > 0x22 )
  {
LABEL_25:
    v8 = sub_10037669(a1);
    v18 = 22;
LABEL_5:
    v9 = v18;
LABEL_19:
    *(_DWORD *)v8 = v9;
    sub_1003A16E(a1, a2);
    return v9;
  }
  v11 = a7 == 0;
  v10 = a3;
  v19 = 0;
  a2 = a4;
  if ( !v11 )
  {
    *(_WORD *)a4 = 45;
    a2 = a4 + 2;
    v19 = 1;
    v10 = -a3;
  }
  v12 = v19;
  a1 = a2;
  do
  {
    v14 = v10;
    v10 /= a6;
    v13 = v14 % a6;
    if ( v14 % a6 <= 9 )
      v15 = v13 + 48;
    else
      v15 = v13 + 87;
    *(_WORD *)a2 = v15;
    a2 += 2;
    ++v12;
  }
  while ( v10 && v12 < a5 );
  if ( v12 >= a5 )
  {
    *(_WORD *)a4 = 0;
    v8 = sub_10037669(a1);
    goto LABEL_19;
  }
  *(_WORD *)a2 = 0;
  v16 = a2 - 2;
  do
  {
    v17 = *(_WORD *)v16;
    *(_WORD *)v16 = *(_WORD *)a1;
    *(_WORD *)a1 = v17;
    v16 -= 2;
    a1 += 2;
  }
  while ( a1 < (unsigned int)v16 );
  return 0;
}

//----- (100548F0) --------------------------------------------------------
int __usercall sub_100548F0<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  return sub_10055893(a1, a2, a3, 0, 0xAu);
}

//----- (10054904) --------------------------------------------------------
int __cdecl sub_10054904(int a1, unsigned __int16 a2)
{
  int result; // eax@9

  _ECX = a1;
  if ( dword_1007689C < 1 )
  {
    while ( *(_WORD *)_ECX && *(_WORD *)_ECX != a2 )
      _ECX += 2;
LABEL_9:
    result = _ECX & ((*(_WORD *)_ECX != a2) - 1);
  }
  else
  {
    _EAX = a2;
    __asm
    {
      movd    xmm0, eax
      pshuflw xmm0, xmm0, 0
      pshufd  xmm2, xmm0, 0
    }
    while ( 1 )
    {
      while ( (_ECX & 0xFFFu) <= 0xFF0 )
      {
        __asm
        {
          movdqu  xmm0, xmmword ptr [ecx]
          pxor    xmm1, xmm1
          pcmpeqw xmm1, xmm0
          pcmpeqw xmm0, xmm2
          por     xmm1, xmm0
          pmovmskb eax, xmm1
        }
        if ( _EAX )
        {
          __asm { bsf     eax, eax }
          _ECX += _EAX;
          goto LABEL_9;
        }
        _ECX += 16;
      }
      if ( *(_WORD *)_ECX == a2 )
        break;
      if ( !*(_WORD *)_ECX )
        return 0;
      _ECX += 2;
    }
    result = _ECX;
  }
  return result;
}
// 10054904: could not find valid save-restore pair for ebp
// 1007689C: using guessed type int dword_1007689C;

//----- (100549B2) --------------------------------------------------------
signed int __usercall sub_100549B2<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  signed int result; // eax@2
  int v6; // edi@2
  int v7; // ecx@5
  int v8; // edx@6
  signed __int16 v9; // si@6
  unsigned __int16 v10; // ax@8
  unsigned __int16 v11; // si@10
  unsigned __int16 v12; // ax@12

  if ( dword_10077048 )
  {
    result = sub_10054A66(a2, a3, a4, a5, 0);
  }
  else
  {
    v6 = a5;
    result = 0;
    if ( a5 )
    {
      if ( a3 && (v7 = a4, a4) )
      {
        v9 = 90;
        v8 = a3 - a4;
        while ( 1 )
        {
          v10 = *(_WORD *)(v8 + v7);
          if ( v10 < 0x41u || v10 > v9 )
            v11 = *(_WORD *)(v8 + v7);
          else
            v11 = v10 + 32;
          v12 = *(_WORD *)v7;
          if ( *(_WORD *)v7 >= 0x41u )
          {
            if ( v12 <= 0x5Au )
              v12 += 32;
          }
          v7 += 2;
          --v6;
          if ( !v6 )
            break;
          if ( !v11 || v11 != v12 )
            break;
          v9 = 90;
        }
        result = v11 - v12;
      }
      else
      {
        *(_DWORD *)sub_10037669(a1) = 22;
        sub_1003A16E(a1, a5);
        result = 2147483647;
      }
    }
  }
  return result;
}
// 10077048: using guessed type int dword_10077048;

//----- (10054A66) --------------------------------------------------------
signed int __usercall sub_10054A66<eax>(int a1<edi>, int a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  int v6; // ebx@2
  int v8; // ecx@6
  int v9; // ebx@6
  signed __int16 v10; // si@6
  unsigned __int16 v11; // ax@8
  WCHAR v12; // si@10
  WCHAR v13; // ax@12
  char v14; // zf@19
  int v15; // [sp+Ch] [bp-14h]@5
  int v16; // [sp+14h] [bp-Ch]@23
  char v17; // [sp+18h] [bp-8h]@22
  int v18; // [sp+1Ch] [bp-4h]@6

  v5 = 0;
  if ( a4 )
  {
    v6 = a2;
    if ( !a2 || (a1 = a3, !a3) )
    {
      *(_DWORD *)sub_10037669(a2) = 22;
      sub_1003A16E(a2, a1);
      return 2147483647;
    }
    sub_1003018D((int)&v15, a2, a3, a5);
    if ( *(_DWORD *)(v15 + 168) )
    {
      do
      {
        v12 = sub_10053515(v6, a1, *(_WORD *)v6, (int)&v15);
        v13 = sub_10053515(v6, a1, *(_WORD *)a1, (int)&v15);
        v14 = a4-- == 1;
        v6 += 2;
        a1 += 2;
      }
      while ( !v14 && v12 && v12 == v13 );
    }
    else
    {
      v8 = a4;
      v10 = 90;
      v9 = a2 - a3;
      v18 = 90;
      while ( 1 )
      {
        v11 = *(_WORD *)(v9 + a1);
        if ( v11 < 0x41u || v11 > v10 )
          v12 = *(_WORD *)(v9 + a1);
        else
          v12 = v11 + 32;
        v13 = *(_WORD *)a1;
        if ( *(_WORD *)a1 >= 0x41u )
        {
          if ( v13 <= (_WORD)v18 )
            v13 += 32;
        }
        a1 += 2;
        --v8;
        if ( !v8 )
          break;
        if ( !v12 || v12 != v13 )
          break;
        v10 = 90;
      }
    }
    v5 = v12 - v13;
    if ( v17 )
      *(_DWORD *)(v16 + 112) &= 0xFFFFFFFDu;
  }
  return v5;
}

//----- (10054B5D) --------------------------------------------------------
void __usercall sub_10054B5D(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5, const CHAR *lpWideCharStr, signed int nNumberOfBytesToRead)
{
  if ( a5 == -2 )
  {
    *(_DWORD *)sub_10037635(a3) = 0;
    *(_DWORD *)sub_10037669(a3) = 9;
    return;
  }
  if ( a5 < 0
    || a5 >= (unsigned int)dword_10077A98
    || (a3 = a5 >> 5, a4 = (a5 & 0x1F) << 6, !(*(_BYTE *)(dword_100770A0[a5 >> 5] + a4 + 4) & 1)) )
  {
    *(_DWORD *)sub_10037635(a3) = 0;
    *(_DWORD *)sub_10037669(a3) = 9;
    goto LABEL_13;
  }
  if ( (unsigned int)nNumberOfBytesToRead > 0x7FFFFFFF )
  {
    *(_DWORD *)sub_10037635(a3) = 0;
    *(_DWORD *)sub_10037669(a3) = 22;
LABEL_13:
    sub_1003A16E(a3, a4);
    return;
  }
  sub_100553F4(a1, a2, a3, a5);
  if ( *(_BYTE *)(dword_100770A0[a3] + a4 + 4) & 1 )
  {
    sub_10054C65(a3, a5, lpWideCharStr, nNumberOfBytesToRead);
  }
  else
  {
    *(_DWORD *)sub_10037669(a3) = 9;
    *(_DWORD *)sub_10037635(a3) = 0;
  }
  sub_1005556D(a5);
}
// 100770A0: using guessed type int dword_100770A0[];
// 10077A98: using guessed type int dword_10077A98;

//----- (10054C65) --------------------------------------------------------
signed int __usercall sub_10054C65<eax>(int a1<ebx>, unsigned int a2, const CHAR *lpWideCharStr, signed int nNumberOfBytesToRead)
{
  signed int v4; // edi@1
  unsigned int v5; // esi@1
  char v6; // al@5
  int v7; // edx@5
  int v8; // ecx@5
  int v9; // eax@13
  char v10; // al@13
  void *v11; // eax@17
  LARGE_INTEGER v12; // qax@23
  int v13; // ecx@23
  int v14; // edx@24
  int v15; // ecx@24
  char v16; // zf@24
  char v17; // dl@25
  void *v18; // edx@27
  int v19; // eax@27
  char v20; // al@28
  int v21; // edx@30
  int v22; // eax@30
  char v23; // al@31
  int v24; // eax@33
  int v25; // eax@34
  char v26; // zf@34
  int v27; // ecx@35
  int v28; // eax@39
  int v29; // ebx@41
  LPCSTR v30; // eax@42
  DWORD v31; // ecx@43
  char v32; // al@48
  int v33; // edx@48
  int v34; // esi@48
  char v35; // al@52
  LPCSTR v36; // esi@54
  char v37; // cl@55
  int v38; // edi@55
  const CHAR v39; // al@56
  char v40; // al@81
  int v41; // ecx@81
  int v42; // esi@86
  signed int v43; // edx@88
  int v44; // ecx@97
  char v45; // al@98
  int v46; // eax@98
  int v47; // esi@98
  int v48; // esi@104
  bool v49; // ecx@105
  unsigned int v51; // edx@114
  LPCSTR v52; // ecx@114
  LPCSTR v53; // esi@114
  signed __int16 v54; // di@115
  __int16 v55; // ax@116
  signed __int16 v56; // ax@120
  char v57; // al@129
  LPCSTR v58; // esi@131
  signed __int16 v59; // cx@132
  int v60; // edi@132
  __int16 v61; // ax@133
  char v62; // al@159
  int v63; // ecx@159
  char v64; // [sp-4h] [bp-38h]@67
  signed __int16 v65; // [sp-4h] [bp-38h]@145
  unsigned int v66; // [sp+Ch] [bp-28h]@1
  DWORD Mode; // [sp+14h] [bp-20h]@1
  LPVOID lpBuffer; // [sp+18h] [bp-1Ch]@24
  int v69; // [sp+1Ch] [bp-18h]@1
  DWORD NumberOfBytesRead; // [sp+20h] [bp-14h]@38
  LPCSTR lpMem; // [sp+24h] [bp-10h]@17
  int v72; // [sp+28h] [bp-Ch]@5
  __int16 v73; // [sp+2Ch] [bp-8h]@141
  char Buffer; // [sp+33h] [bp-1h]@63
  signed int v75; // [sp+44h] [bp+10h]@115
  signed int v76; // [sp+44h] [bp+10h]@132
  char v77; // [sp+47h] [bp+13h]@13

  v5 = nNumberOfBytesToRead;
  v4 = 0;
  Mode = 0;
  v69 = -2;
  v66 = nNumberOfBytesToRead;
  if ( a2 == -2 )
  {
    *(_DWORD *)sub_10037635(a1) = 0;
    *(_DWORD *)sub_10037669(a1) = 9;
    return -1;
  }
  if ( (signed int)a2 < 0
    || a2 >= dword_10077A98
    || (v8 = (signed int)a2 >> 5,
        v7 = dword_100770A0[(signed int)a2 >> 5],
        a1 = (a2 & 0x1F) << 6,
        v72 = (signed int)a2 >> 5,
        v6 = *(_BYTE *)(v7 + a1 + 4),
        !(v6 & 1)) )
  {
    *(_DWORD *)sub_10037635(a1) = 0;
    *(_DWORD *)sub_10037669(a1) = 9;
    goto LABEL_169;
  }
  if ( (unsigned int)nNumberOfBytesToRead > 0x7FFFFFFF )
  {
    *(_DWORD *)sub_10037635(a1) = 0;
LABEL_8:
    *(_DWORD *)sub_10037669(a1) = 22;
LABEL_169:
    sub_1003A16E(a1, 0);
    return -1;
  }
  if ( !nNumberOfBytesToRead || v6 & 2 )
    return 0;
  if ( !lpWideCharStr )
  {
LABEL_12:
    *(_DWORD *)sub_10037635(a1) = 0;
    goto LABEL_8;
  }
  v10 = (char)(2 * *(_BYTE *)(v7 + a1 + 36)) >> 1;
  v77 = v10;
  v9 = v10 - 1;
  if ( v9 )
  {
    if ( v9 == 1 )
    {
      if ( !(~(_BYTE)v5 & 1) )
        goto LABEL_12;
      v5 &= 0xFFFFFFFEu;
    }
    v11 = (void *)lpWideCharStr;
    lpMem = lpWideCharStr;
  }
  else
  {
    if ( !(~(_BYTE)v5 & 1) )
      goto LABEL_12;
    v5 >>= 1;
    if ( v5 < 4 )
      v5 = 4;
    lpMem = (LPCSTR)sub_10037550(v7, v8, a1, v5);
    if ( !lpMem )
    {
      *(_DWORD *)sub_10037669(a1) = 12;
      *(_DWORD *)sub_10037635(a1) = 8;
      return -1;
    }
    v12 = sub_100508F0(a1, 0, a2, 0i64, 1u);
    v13 = dword_100770A0[v72];
    *(_DWORD *)(v13 + a1 + 40) = v12.LowPart;
    v11 = (void *)lpMem;
    *(_DWORD *)(v13 + a1 + 44) = v12.HighPart;
    v8 = v72;
  }
  v14 = dword_100770A0[v8];
  v15 = v72;
  v16 = (*(_BYTE *)(v14 + a1 + 4) & 0x48) == 0;
  lpBuffer = v11;
  if ( !v16 )
  {
    v17 = *(_BYTE *)(v14 + a1 + 5);
    if ( v17 != 10 )
    {
      if ( v5 )
      {
        *(_BYTE *)v11 = v17;
        v18 = (char *)v11 + 1;
        v19 = dword_100770A0[v15];
        v4 = 1;
        --v5;
        lpBuffer = v18;
        *(_BYTE *)(v19 + a1 + 5) = 10;
        if ( v77 )
        {
          v20 = *(_BYTE *)(dword_100770A0[v15] + a1 + 37);
          if ( v20 != 10 )
          {
            if ( v5 )
            {
              *(_BYTE *)v18 = v20;
              v22 = dword_100770A0[v15];
              v21 = (int)((char *)v18 + 1);
              --v5;
              lpBuffer = (LPVOID)v21;
              v4 = 2;
              *(_BYTE *)(v22 + a1 + 37) = 10;
              if ( v77 == 1 )
              {
                v23 = *(_BYTE *)(dword_100770A0[v15] + a1 + 38);
                if ( v23 != 10 )
                {
                  if ( v5 )
                  {
                    v4 = 3;
                    *(_BYTE *)v21 = v23;
                    v24 = dword_100770A0[v15];
                    lpBuffer = (LPVOID)(v21 + 1);
                    --v5;
                    *(_BYTE *)(v24 + a1 + 38) = 10;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  v26 = sub_1004FE94(a1, v4, a2) == 0;
  v25 = v72;
  if ( v26 || (v27 = dword_100770A0[v72], !(*(_BYTE *)(v27 + a1 + 4) & 0x80)) )
  {
LABEL_45:
    if ( !ReadFile(*(HANDLE *)(dword_100770A0[v25] + a1), lpBuffer, v5, &NumberOfBytesRead, 0)
      || (v31 = NumberOfBytesRead, (signed int)NumberOfBytesRead < 0)
      || NumberOfBytesRead > v5 )
    {
      v28 = GetLastError();
      if ( v28 == 5 )
      {
        *(_DWORD *)sub_10037669(a1) = 9;
        *(_DWORD *)sub_10037635(a1) = 5;
        goto LABEL_41;
      }
      if ( v28 == 109 )
      {
        v29 = 0;
        goto LABEL_42;
      }
      goto LABEL_40;
    }
    goto LABEL_48;
  }
  Mode = GetConsoleMode(*(HANDLE *)(v27 + a1), &Mode);
  if ( !Mode || v77 != 2 )
  {
    v25 = v72;
    goto LABEL_45;
  }
  if ( ReadConsoleW(*(HANDLE *)(dword_100770A0[v72] + a1), lpBuffer, v5 >> 1, &NumberOfBytesRead, 0) )
  {
    v31 = 2 * NumberOfBytesRead;
    NumberOfBytesRead *= 2;
LABEL_48:
    v33 = v72;
    v4 += v31;
    v34 = dword_100770A0[v72];
    v32 = *(_BYTE *)(v34 + a1 + 4);
    if ( v32 >= 0 )
      goto LABEL_106;
    if ( v77 != 2 )
    {
      if ( v31 && *lpMem == 10 )
        v35 = v32 | 4;
      else
        v35 = v32 & 0xFB;
      *(_BYTE *)(v34 + a1 + 4) = v35;
      v36 = lpMem;
      Mode = (DWORD)lpMem;
      lpBuffer = (LPVOID)&lpMem[v4];
      if ( lpMem < &lpMem[v4] )
      {
        v37 = 13;
        v38 = (int)lpMem;
        do
        {
          v39 = *(_BYTE *)v38;
          if ( *(_BYTE *)v38 == 26 )
          {
            v41 = dword_100770A0[v33];
            v40 = *(_BYTE *)(v41 + a1 + 4);
            if ( v40 & 0x40 )
              *v36++ = *(_BYTE *)v38;
            else
              *(_BYTE *)(v41 + a1 + 4) = v40 | 2;
            break;
          }
          if ( v39 == v37 )
          {
            if ( v38 >= (unsigned int)((char *)lpBuffer - 1) )
            {
              ++v38;
              if ( !ReadFile(*(HANDLE *)(dword_100770A0[v33] + a1), &Buffer, 1u, &NumberOfBytesRead, 0)
                && GetLastError()
                || !NumberOfBytesRead )
              {
                v33 = v72;
                v37 = 13;
                *v36++ = 13;
                continue;
              }
              v33 = v72;
              if ( *(_BYTE *)(dword_100770A0[v72] + a1 + 4) & 0x48 )
              {
                v64 = 13;
                if ( Buffer == 10 )
                {
                  *v36++ = 10;
                }
                else
                {
                  *v36++ = 13;
                  *(_BYTE *)(dword_100770A0[v33] + a1 + 5) = Buffer;
                }
              }
              else
              {
                if ( v36 != lpMem || Buffer != 10 )
                {
                  sub_100508F0(a1, v38, a2, (LARGE_INTEGER)-1i64, 1u);
                  v33 = v72;
                  if ( Buffer != 10 )
                  {
                    v37 = 13;
                    *v36 = 13;
                    goto LABEL_79;
                  }
                }
                else
                {
                  *v36++ = 10;
                }
                v64 = 13;
              }
              v37 = v64;
            }
            else
            {
              if ( *(_BYTE *)(v38 + 1) == 10 )
              {
                v38 += 2;
                *v36 = 10;
LABEL_79:
                ++v36;
                continue;
              }
              *v36++ = v37;
              ++v38;
            }
          }
          else
          {
            *v36++ = v39;
            ++v38;
          }
        }
        while ( v38 < (unsigned int)lpBuffer );
      }
      v30 = lpMem;
      v4 = v36 - lpMem;
      if ( v77 != 1 || v36 == lpMem )
      {
LABEL_107:
        v29 = v69;
        goto LABEL_108;
      }
      v42 = (int)(v36 - 1);
      if ( *(_BYTE *)v42 < 0 )
      {
        v43 = 1;
        if ( !byte_10075538[*(_BYTE *)v42] )
        {
          do
          {
            if ( v43 > 4 )
              break;
            if ( v42 < (unsigned int)lpMem )
              break;
            --v42;
            ++v43;
          }
          while ( !byte_10075538[*(_BYTE *)v42] );
          a1 = (a2 & 0x1F) << 6;
        }
        if ( !byte_10075538[*(_BYTE *)v42] )
        {
          *(_DWORD *)sub_10037669(a1) = 42;
          goto LABEL_41;
        }
        if ( byte_10075538[*(_BYTE *)v42] + 1 == v43 )
        {
          v42 += v43;
        }
        else
        {
          v44 = dword_100770A0[v72];
          if ( *(_BYTE *)(v44 + a1 + 4) & 0x48 )
          {
            v45 = *(_BYTE *)v42;
            v47 = v42 + 1;
            *(_BYTE *)(v44 + a1 + 5) = v45;
            v46 = v72;
            if ( v43 >= 2 )
            {
              *(_BYTE *)(dword_100770A0[v72] + a1 + 37) = *(_BYTE *)v47;
              v46 = v72;
              ++v47;
            }
            if ( v43 == 3 )
              *(_BYTE *)(dword_100770A0[v46] + a1 + 38) = *(_BYTE *)v47++;
            v42 = v47 - v43;
          }
          else
          {
            sub_100508F0(a1, v4, a2, (LARGE_INTEGER)-v43, 1u);
          }
        }
      }
      else
      {
        ++v42;
      }
      v48 = v42 - (_DWORD)lpMem;
      v4 = MultiByteToWideChar(0xFDE9u, 0, lpMem, v48, (LPWSTR)lpWideCharStr, v66 >> 1);
      if ( !v4 )
        goto LABEL_39;
      v49 = v4 != v48;
      v4 *= 2;
      *(_DWORD *)(dword_100770A0[v72] + a1 + 48) = v49;
LABEL_106:
      v30 = lpMem;
      goto LABEL_107;
    }
    if ( Mode )
    {
      v53 = lpMem;
      v52 = lpMem;
      v51 = (unsigned int)&lpMem[2 * v4 / 2];
      if ( (unsigned int)lpMem < v51 )
      {
        v75 = 26;
        v54 = 13;
        while ( 1 )
        {
          v55 = *(_WORD *)v52;
          if ( *(_WORD *)v52 == (_WORD)v75 )
            break;
          if ( v55 == v54 )
          {
            if ( (unsigned int)v52 < v51 - 2 )
            {
              v52 += 2;
              v56 = 10;
              if ( *(_WORD *)v52 != 10 )
              {
                v56 = 13;
                v54 = 13;
              }
              *(_WORD *)v53 = v56;
              v53 += 2;
            }
          }
          else
          {
            *(_WORD *)v53 = v55;
            v53 += 2;
            v52 += 2;
          }
          if ( (unsigned int)v52 >= v51 )
            goto LABEL_126;
        }
        *(_BYTE *)(dword_100770A0[v72] + a1 + 4) |= 2u;
      }
LABEL_126:
      v30 = lpMem;
      v4 = (v53 - lpMem) & 0xFFFFFFFE;
      goto LABEL_107;
    }
    if ( v31 && (v33 = v72, *(_WORD *)lpMem == 10) )
      v57 = v32 | 4;
    else
      v57 = v32 & 0xFB;
    *(_BYTE *)(v34 + a1 + 4) = v57;
    v58 = lpMem;
    Mode = (DWORD)&lpMem[v4];
    if ( lpMem >= &lpMem[v4] )
    {
LABEL_162:
      v30 = lpMem;
      v4 = v58 - lpMem;
      goto LABEL_107;
    }
    v59 = 13;
    v76 = 26;
    v60 = (int)lpMem;
    while ( 1 )
    {
      v61 = *(_WORD *)v60;
      if ( *(_WORD *)v60 == (_WORD)v76 )
      {
        v63 = dword_100770A0[v33];
        v62 = *(_BYTE *)(v63 + a1 + 4);
        if ( v62 & 0x40 )
        {
          *(_WORD *)v58 = *(_WORD *)v60;
          v58 += 2;
        }
        else
        {
          *(_BYTE *)(v63 + a1 + 4) = v62 | 2;
        }
        goto LABEL_162;
      }
      if ( v61 == v59 )
      {
        if ( v60 >= Mode - 2 )
        {
          v60 += 2;
          if ( !ReadFile(*(HANDLE *)(dword_100770A0[v33] + a1), &v73, 2u, &NumberOfBytesRead, 0) && GetLastError()
            || !NumberOfBytesRead )
          {
            v33 = v72;
            v59 = 13;
            *(_WORD *)v58 = 13;
            v58 += 2;
            goto LABEL_150;
          }
          v33 = v72;
          if ( *(_BYTE *)(dword_100770A0[v72] + a1 + 4) & 0x48 )
          {
            v65 = 13;
            if ( v73 == 10 )
            {
              *(_WORD *)v58 = 10;
              v58 += 2;
LABEL_149:
              v59 = v65;
              goto LABEL_150;
            }
            *(_WORD *)v58 = 13;
            *(_BYTE *)(dword_100770A0[v33] + a1 + 5) = v73;
            *(_BYTE *)(dword_100770A0[v33] + a1 + 37) = HIBYTE(v73);
            v58 += 2;
            *(_BYTE *)(dword_100770A0[v33] + a1 + 38) = 10;
          }
          else
          {
            if ( v58 != lpMem || v73 != 10 )
            {
              sub_100508F0(a1, v60, a2, (LARGE_INTEGER)-2i64, 1u);
              v33 = v72;
              if ( v73 != 10 )
              {
                v59 = 13;
                *(_WORD *)v58 = 13;
                goto LABEL_157;
              }
            }
            else
            {
              *(_WORD *)v58 = 10;
              v58 += 2;
            }
          }
          v65 = 13;
          goto LABEL_149;
        }
        v33 = v72;
        if ( *(_WORD *)(v60 + 2) == 10 )
        {
          v60 += 4;
          *(_WORD *)v58 = 10;
LABEL_157:
          v58 += 2;
          goto LABEL_150;
        }
        *(_WORD *)v58 = v59;
      }
      else
      {
        *(_WORD *)v58 = v61;
      }
      v58 += 2;
      v60 += 2;
LABEL_150:
      if ( v60 >= Mode )
        goto LABEL_162;
    }
  }
LABEL_39:
  v28 = GetLastError();
LABEL_40:
  sub_10037648(a1, v28);
LABEL_41:
  v29 = -1;
LABEL_42:
  v30 = lpMem;
LABEL_108:
  if ( v30 != lpWideCharStr )
    sub_100309A2(v29, (LPVOID)v30);
  if ( v29 != -2 )
    v4 = v29;
  return v4;
}
// 100770A0: using guessed type int dword_100770A0[];
// 10077A98: using guessed type int dword_10077A98;

//----- (100553F4) --------------------------------------------------------
void __usercall sub_100553F4(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // esi@1

  v4 = dword_100770A0[a4 >> 5] + ((a4 & 0x1F) << 6);
  if ( *(_DWORD *)(v4 + 8) )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(((a4 & 0x1F) << 6) + dword_100770A0[a4 >> 5] + 12));
  }
  else
  {
    sub_10036A43(a1, a2, a3, a4, 10);
    if ( !*(_DWORD *)(v4 + 8) )
    {
      InitializeCriticalSectionAndSpinCount((LPCRITICAL_SECTION)(v4 + 12), 0xFA0u);
      ++*(_DWORD *)(v4 + 8);
    }
    sub_10036BA7(10);
  }
}
// 100770A0: using guessed type int dword_100770A0[];

//----- (10055480) --------------------------------------------------------
signed int __usercall sub_10055480<eax>(int a1<ebx>, signed int a2)
{
  int v2; // ecx@3
  int v3; // esi@3
  DWORD v5; // [sp-8h] [bp-10h]@9
  void *v6; // [sp-4h] [bp-Ch]@9

  if ( a2 >= 0 )
  {
    if ( a2 < (unsigned int)dword_10077A98 )
    {
      v2 = dword_100770A0[a2 >> 5];
      v3 = (a2 & 0x1F) << 6;
      if ( *(_BYTE *)(v3 + v2 + 4) & 1 )
      {
        if ( *(_DWORD *)(v3 + v2) != -1 )
        {
          if ( dword_100769E8 == 1 )
          {
            if ( !a2 )
            {
              v6 = 0;
              v5 = -10;
              goto LABEL_12;
            }
            if ( a2 == 1 )
            {
              v6 = 0;
              v5 = -11;
              goto LABEL_12;
            }
            if ( a2 == 2 )
            {
              v6 = 0;
              v5 = -12;
LABEL_12:
              SetStdHandle(v5, v6);
              goto LABEL_13;
            }
          }
LABEL_13:
          *(_DWORD *)(v3 + dword_100770A0[a2 >> 5]) = -1;
          return 0;
        }
      }
    }
  }
  *(_DWORD *)sub_10037669(a1) = 9;
  *(_DWORD *)sub_10037635(a1) = 0;
  return -1;
}
// 100769E8: using guessed type int dword_100769E8;
// 100770A0: using guessed type int dword_100770A0[];
// 10077A98: using guessed type int dword_10077A98;

//----- (10055506) --------------------------------------------------------
signed int __usercall sub_10055506<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  int v3; // eax@5
  int v4; // ecx@5

  if ( a3 == -2 )
  {
    *(_DWORD *)sub_10037635(a1) = 0;
    *(_DWORD *)sub_10037669(a1) = 9;
  }
  else
  {
    if ( a3 >= 0 )
    {
      if ( a3 < (unsigned int)dword_10077A98 )
      {
        v3 = dword_100770A0[a3 >> 5];
        v4 = (a3 & 0x1F) << 6;
        if ( *(_BYTE *)(v3 + v4 + 4) & 1 )
          return *(_DWORD *)(v3 + v4);
      }
    }
    *(_DWORD *)sub_10037635(a1) = 0;
    *(_DWORD *)sub_10037669(a1) = 9;
    sub_1003A16E(a1, a2);
  }
  return -1;
}
// 100770A0: using guessed type int dword_100770A0[];
// 10077A98: using guessed type int dword_10077A98;

//----- (1005556D) --------------------------------------------------------
void __cdecl sub_1005556D(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(((a1 & 0x1F) << 6) + 12 + dword_100770A0[a1 >> 5]));
}
// 100770A0: using guessed type int dword_100770A0[];

//----- (10055593) --------------------------------------------------------
signed __int16 __thiscall sub_10055593(DWORD this, __int16 Buffer)
{
  HANDLE v2; // eax@1
  signed __int16 result; // ax@4
  DWORD NumberOfCharsWritten; // [sp+0h] [bp-4h]@1

  NumberOfCharsWritten = this;
  v2 = hConsoleOutput;
  if ( hConsoleOutput == (HANDLE)-2 )
  {
    sub_10058430();
    v2 = hConsoleOutput;
  }
  if ( v2 != (HANDLE)-1 && WriteConsoleW(v2, &Buffer, 1u, &NumberOfCharsWritten, 0) )
    result = Buffer;
  else
    result = -1;
  return result;
}

//----- (100555D4) --------------------------------------------------------
signed int __usercall sub_100555D4<eax>(int a1<ebx>, int a2)
{
  int v2; // edi@1
  signed int result; // eax@2
  int v4; // eax@4
  int v5; // edx@4
  int v6; // ecx@4
  int v7; // eax@4

  v2 = -1;
  if ( a2 )
  {
    if ( *(_BYTE *)(a2 + 12) & 0x83 )
    {
      v2 = sub_10047FE6(a2);
      sub_100585B3(a1, a2);
      v4 = sub_1004FC85(a1, v2, a2);
      sub_1005844F(v5, v6, a1, v2, v4);
      if ( v7 >= 0 )
      {
        if ( *(_DWORD *)(a2 + 28) )
        {
          sub_100309A2(a1, *(LPVOID *)(a2 + 28));
          *(_DWORD *)(a2 + 28) = 0;
        }
      }
      else
      {
        v2 = -1;
      }
    }
    *(_DWORD *)(a2 + 12) = 0;
    result = v2;
  }
  else
  {
    *(_DWORD *)sub_10037669(a1) = 22;
    sub_1003A16E(a1, -1);
    result = -1;
  }
  return result;
}

//----- (10055640) --------------------------------------------------------
void __usercall sub_10055640(int a1<edx>, int a2<ebx>, unsigned int a3)
{
  if ( a3 != 0 )
  {
    if ( *(_BYTE *)(a3 + 12) & 0x40 )
    {
      *(_DWORD *)(a3 + 12) = 0;
    }
    else
    {
      sub_10047ECA(a1, a2, -1, a3);
      sub_100555D4(a2, a3);
      sub_10047F39(a3);
    }
  }
  else
  {
    *(_DWORD *)sub_10037669(a2) = 22;
    sub_1003A16E(a2, -1);
  }
}

//----- (100556B7) --------------------------------------------------------
int __usercall sub_100556B7<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, unsigned int a5, int a6)
{
  void *v6; // ecx@1
  int v8; // ebx@8
  const WCHAR v9; // di@8
  int i; // esi@8
  int v11; // eax@10
  void *v12; // ST04_4@10
  int v13; // eax@11
  signed int v14; // eax@15
  int v15; // edx@28
  unsigned __int16 v16; // cx@31
  int v17; // eax@32
  int v18; // edi@33
  int v19; // esi@34
  int v20; // edx@39
  int v21; // eax@43
  unsigned int v22; // [sp+4h] [bp-8h]@27
  int v23; // [sp+8h] [bp-4h]@15

  v6 = (void *)a3;
  if ( a4 )
    *(_DWORD *)a4 = a3;
  if ( !a3 || a5 && ((signed int)a5 < 2 || (signed int)a5 > 36) )
  {
    *(_DWORD *)sub_10037669(a1) = 22;
    sub_1003A16E(a1, a2);
    return 0;
  }
  v9 = *(_WORD *)a3;
  v8 = 0;
  for ( i = a3 + 2; ; i += 2 )
  {
    v11 = sub_1004EA92(v6, v9, 8);
    v6 = v12;
    if ( !v11 )
      break;
    v9 = *(_WORD *)i;
  }
  v13 = a6;
  if ( v9 == 45 )
  {
    v13 = a6 | 2;
  }
  else
  {
    if ( v9 != 43 )
      goto LABEL_15;
  }
  v9 = *(_WORD *)i;
  i += 2;
LABEL_15:
  v23 = v13;
  v14 = a5;
  if ( a5 )
    goto LABEL_22;
  if ( !sub_100585E3(v9) )
  {
    if ( *(_WORD *)i != 120 && *(_WORD *)i != 88 )
    {
      a5 = 8;
      goto LABEL_27;
    }
    v14 = 16;
    a5 = 16;
LABEL_22:
    if ( v14 == 16 )
    {
      if ( !sub_100585E3(v9) )
      {
        if ( *(_WORD *)i == 120 || *(_WORD *)i == 88 )
        {
          v9 = *(_WORD *)(i + 2);
          i += 4;
        }
      }
    }
    goto LABEL_27;
  }
  a5 = 10;
LABEL_27:
  v22 = 0xFFFFFFFF / a5;
  while ( 1 )
  {
    v15 = sub_100585E3(v9);
    if ( v15 != -1 )
      goto LABEL_42;
    if ( v9 >= 0x41u && v9 <= 0x5Au )
    {
      v16 = 25;
      goto LABEL_39;
    }
    v16 = 25;
    if ( (unsigned __int16)(v9 - 97) > 0x19u )
      break;
LABEL_39:
    v20 = v9;
    if ( (unsigned __int16)(v9 - 97) <= v16 )
      v20 = v9 - 32;
    v15 = v20 - 55;
LABEL_42:
    LOBYTE(v17) = v23;
    if ( v15 >= a5 )
      goto LABEL_33;
    v21 = v23 | 8;
    v23 |= 8u;
    if ( v8 < v22 || v8 == v22 && v15 <= 0xFFFFFFFF % a5 )
    {
      v8 = v15 + a5 * v8;
    }
    else
    {
      v18 = a4;
      v17 = v21 | 4;
      v23 = v17;
      if ( !a4 )
        goto LABEL_34;
    }
    v9 = *(_WORD *)i;
    i += 2;
  }
  LOBYTE(v17) = v23;
LABEL_33:
  v18 = a4;
LABEL_34:
  v19 = i - 2;
  if ( v17 & 8 )
  {
    if ( v17 & 4
      || !(v17 & 1) && (v17 & 2 && (unsigned int)v8 > 0x80000000 || !(v17 & 2) && (unsigned int)v8 > 0x7FFFFFFF) )
    {
      *(_DWORD *)sub_10037669(v8) = 34;
      LOBYTE(v17) = v23;
      if ( v23 & 1 )
        v8 = -1;
      else
        v8 = ((v23 & 2) != 0) + 2147483647;
    }
  }
  else
  {
    if ( v18 )
      v19 = a3;
    v8 = 0;
  }
  if ( v18 )
    *(_DWORD *)v18 = v19;
  if ( v17 & 2 )
    v8 = -v8;
  return v8;
}

//----- (10055893) --------------------------------------------------------
int __usercall sub_10055893<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, unsigned int a5)
{
  return sub_100556B7(a1, a2, a3, a4, a5, 0);
}

//----- (100558AB) --------------------------------------------------------
signed int __cdecl sub_100558AB(int a1, int a2)
{
  int v2; // edx@1
  signed int v3; // ebx@1
  int v4; // edi@1
  __int16 v5; // dx@1
  signed int v6; // eax@2
  int v7; // esi@2
  int v8; // edx@8
  int v9; // ecx@8
  signed int v10; // edi@8
  char i; // zf@9
  int v12; // eax@14
  signed int v13; // ecx@14
  unsigned int v14; // eax@14
  char v15; // cf@14
  int v16; // edx@17
  int v17; // eax@19
  unsigned int v18; // eax@19
  char v19; // cf@19
  int v20; // ecx@28
  char v21; // di@34
  int v22; // eax@34
  int v23; // eax@35
  unsigned int v24; // edx@35
  int v25; // eax@36
  int *v26; // edx@36
  signed int v27; // ecx@36
  signed int v28; // edi@36
  int v29; // edx@41
  int v30; // ecx@41
  int v31; // ecx@41
  char j; // zf@42
  int v33; // eax@47
  signed int v34; // ecx@47
  unsigned int v35; // eax@47
  signed int v36; // edi@47
  int v37; // edi@47
  char v38; // cf@47
  int v39; // edx@50
  int v40; // eax@52
  unsigned int v41; // eax@52
  char v42; // cf@52
  int v43; // edx@59
  int v44; // eax@61
  char v45; // bl@61
  signed int v46; // edi@61
  int v47; // ecx@61
  unsigned int v48; // edx@62
  int *v49; // edx@63
  signed int v50; // ecx@63
  int v51; // ecx@70
  signed int v52; // edi@70
  int v53; // eax@71
  unsigned int v54; // edx@71
  int *v55; // edx@72
  signed int v56; // ecx@72
  char v57; // bl@78
  signed int v58; // edi@78
  signed int v59; // esi@78
  int v60; // eax@79
  unsigned int v61; // edx@79
  int *v62; // edx@80
  signed int v63; // ecx@80
  int v64; // esi@86
  int v65; // eax@87
  int v67; // [sp+Ch] [bp-44h]@1
  int v68; // [sp+14h] [bp-3Ch]@8
  int v69; // [sp+14h] [bp-3Ch]@34
  signed int v70; // [sp+18h] [bp-38h]@14
  int v71; // [sp+18h] [bp-38h]@34
  int v72; // [sp+18h] [bp-38h]@70
  int v73; // [sp+18h] [bp-38h]@78
  signed int v74; // [sp+1Ch] [bp-34h]@8
  int v75; // [sp+1Ch] [bp-34h]@61
  int v76; // [sp+1Ch] [bp-34h]@70
  char v77; // [sp+20h] [bp-30h]@8
  int v78; // [sp+20h] [bp-30h]@41
  signed int v79; // [sp+24h] [bp-2Ch]@8
  signed int v80; // [sp+28h] [bp-28h]@34
  int v81; // [sp+28h] [bp-28h]@61
  int v82; // [sp+28h] [bp-28h]@70
  int v83; // [sp+28h] [bp-28h]@78
  int v84; // [sp+2Ch] [bp-24h]@8
  signed int v85; // [sp+2Ch] [bp-24h]@47
  int v86; // [sp+2Ch] [bp-24h]@61
  int v87; // [sp+2Ch] [bp-24h]@78
  int v88; // [sp+30h] [bp-20h]@1
  int v89; // [sp+30h] [bp-20h]@34
  int v90; // [sp+30h] [bp-20h]@61
  int v91; // [sp+30h] [bp-20h]@70
  int v92; // [sp+30h] [bp-20h]@78
  int v93; // [sp+34h] [bp-1Ch]@8
  int v94; // [sp+38h] [bp-18h]@8
  int v95; // [sp+3Ch] [bp-14h]@8
  int v96; // [sp+40h] [bp-10h]@1
  int v97; // [sp+44h] [bp-Ch]@1
  int v98; // [sp+48h] [bp-8h]@1
  unsigned int v99; // [sp+4Ch] [bp-4h]@1
  int v100; // [sp+50h] [bp+0h]@1

  v99 = (unsigned int)&v100 ^ __security_cookie;
  v5 = *(_WORD *)(a1 + 10);
  v67 = *(_WORD *)(a1 + 10) & 0x8000;
  v96 = *(_DWORD *)(a1 + 6);
  v97 = *(_DWORD *)(a1 + 2);
  v2 = (v5 & 0x7FFF) - 16383;
  v4 = a2;
  v3 = 0;
  v88 = v2;
  v98 = *(_WORD *)a1 << 16;
  if ( v2 == -16383 )
  {
    v7 = 0;
    v6 = 0;
    while ( !*(&v96 + v6) )
    {
      ++v6;
      if ( v6 >= 3 )
        goto LABEL_86;
    }
    v96 = 0;
    v97 = 0;
    v98 = 0;
  }
  else
  {
    v93 = v96;
    v94 = v97;
    v84 = v2;
    v74 = dword_10075640 - 1;
    v95 = v98;
    v8 = dword_10075640 / 32;
    v79 = 0;
    v68 = dword_10075640 / 32;
    v9 = 31 - dword_10075640 % 32;
    v10 = -1;
    v77 = v9;
    if ( (1 << v9) & *(&v96 + dword_10075640 / 32) )
    {
      for ( i = (~(-1 << v9) & *(&v96 + v8)) == 0; i; i = *(&v96 + v8) == 0 )
      {
        ++v8;
        if ( v8 >= 3 )
          goto LABEL_25;
      }
      v79 = 0;
      v10 = -1;
      v70 = 1 << (31 - v74 % 32);
      v14 = *(&v96 + v74 / 32);
      v15 = v14 + v70 < v14;
      v12 = v14 + v70;
      v13 = 0;
      if ( v15 || v12 < (unsigned int)v70 )
      {
        v13 = 1;
        v79 = 1;
      }
      v16 = v74 / 32 - 1;
      *(&v97 + v16) = v12;
      if ( v16 >= 0 )
      {
        do
        {
          if ( !v13 )
            break;
          v18 = *(&v96 + v16);
          v13 = 0;
          v19 = v18 + 1 < v18;
          v79 = 0;
          v17 = v18 + 1;
          if ( v19 || (unsigned int)v17 < 1 )
          {
            v13 = 1;
            v79 = 1;
          }
          --v16;
          *(&v97 + v16) = v17;
        }
        while ( v16 >= 0 );
        v10 = -1;
      }
      LOBYTE(v9) = v77;
LABEL_25:
      v8 = v68;
    }
    *(&v96 + v8) &= v10 << v9;
    if ( v8 + 1 < 3 )
    {
      memset(&v96 + v8 + 1, 0, 4 * (3 - (v8 + 1)));
      v10 = -1;
    }
    v20 = v88;
    if ( v79 )
      v20 = v88 + 1;
    if ( v20 >= dword_1007563C - dword_10075640 )
    {
      if ( v20 > dword_1007563C )
      {
        if ( v20 < dword_10075638 )
        {
          v96 &= 0x7FFFFFFFu;
          v73 = v20 + dword_1007564C;
          v83 = dword_10075644 / 32;
          v92 = 0;
          v59 = 0;
          v57 = dword_10075644 % 32;
          v58 = ~(v10 << dword_10075644 % 32);
          v87 = 32 - dword_10075644 % 32;
          do
          {
            v60 = (v58 & *(&v96 + v59)) << v87;
            v61 = v92 | ((unsigned int)*(&v96 + v59++) >> v57);
            *(&v95 + v59) = v61;
            v92 = v60;
          }
          while ( v59 < 3 );
          v7 = v73;
          v62 = &v98 - v83;
          v63 = 2;
          v3 = 0;
          do
          {
            if ( v63 < v83 )
              *(&v96 + v63) = 0;
            else
              *(&v96 + v63) = *v62;
            --v62;
            --v63;
          }
          while ( v63 >= 0 );
        }
        else
        {
          v97 = 0;
          v98 = 0;
          v96 = -2147483648;
          v76 = dword_10075644 / 32;
          v51 = dword_10075644 % 32;
          v72 = dword_10075644 % 32;
          v52 = ~(-1 << dword_10075644 % 32);
          v91 = 0;
          v82 = 32 - dword_10075644 % 32;
          do
          {
            v53 = (v52 & *(&v96 + v3)) << v82;
            v54 = v91 | ((unsigned int)*(&v96 + v3) >> v51);
            LOBYTE(v51) = v72;
            *(&v96 + v3++) = v54;
            v91 = v53;
          }
          while ( v3 < 3 );
          v55 = &v98 - v76;
          v56 = 2;
          do
          {
            if ( v56 < v76 )
              *(&v96 + v56) = 0;
            else
              *(&v96 + v56) = *v55;
            --v55;
            --v56;
          }
          while ( v56 >= 0 );
          v7 = dword_10075638 + dword_1007564C;
          v3 = 1;
        }
        goto LABEL_85;
      }
      v96 = v93;
      v97 = v94;
      v69 = (dword_1007563C - v84) / 32;
      v98 = v95;
      v22 = (dword_1007563C - v84) % 32;
      v21 = (dword_1007563C - v84) % 32;
      v89 = 0;
      v80 = ~(-1 << v22);
      v71 = 32 - v22;
      do
      {
        v23 = (v80 & *(&v96 + v3)) << v71;
        v24 = v89 | ((unsigned int)*(&v96 + v3++) >> v21);
        *(&v95 + v3) = v24;
        v89 = v23;
      }
      while ( v3 < 3 );
      v26 = &v98 - v69;
      v25 = v69;
      v27 = 2;
      v28 = -1;
      do
      {
        if ( v27 < v25 )
        {
          *(&v96 + v27) = 0;
        }
        else
        {
          *(&v96 + v27) = *v26;
          v25 = v69;
        }
        --v26;
        --v27;
      }
      while ( v27 >= 0 );
      v29 = (v74 + 1) / 32;
      v31 = (v74 + 1) % 32;
      v78 = 31 - v31;
      v30 = 31 - v31;
      if ( (1 << v30) & *(&v96 + v29) )
      {
        for ( j = (~(-1 << v30) & *(&v96 + v29)) == 0; j; j = *(&v96 + v29) == 0 )
        {
          ++v29;
          if ( v29 >= 3 )
            goto LABEL_58;
        }
        v35 = *(&v96 + v74 / 32);
        v36 = 1 << (31 - v74 % 32);
        v34 = 0;
        v85 = v36;
        v37 = v35 + v36;
        v38 = v37 < v35;
        v33 = v37;
        v28 = -1;
        if ( v38 || v33 < (unsigned int)v85 )
          v34 = 1;
        v39 = v74 / 32 - 1;
        *(&v97 + v39) = v33;
        if ( v39 >= 0 )
        {
          do
          {
            if ( !v34 )
              break;
            v41 = *(&v96 + v39);
            v34 = 0;
            v42 = v41 + 1 < v41;
            v40 = v41 + 1;
            if ( v42 || (unsigned int)v40 < 1 )
              v34 = 1;
            --v39;
            *(&v97 + v39) = v40;
          }
          while ( v39 >= 0 );
          v28 = -1;
        }
        LOBYTE(v30) = v78;
LABEL_58:
        v29 = (v74 + 1) / 32;
      }
      *(&v96 + v29) &= v28 << v30;
      v43 = v29 + 1;
      if ( v43 < 3 )
      {
        memset(&v96 + v43, 0, 4 * (3 - v43));
        v28 = -1;
      }
      v81 = (dword_10075644 + 1) / 32;
      v47 = (dword_10075644 + 1) % 32;
      v44 = 0;
      v90 = 0;
      v45 = (dword_10075644 + 1) % 32;
      v46 = ~(v28 << v47);
      v75 = 0;
      v86 = 32 - v47;
      do
      {
        v48 = *(&v96 + v44);
        *(&v96 + v75) = v90 | (v48 >> v45);
        v90 = (v46 & v48) << v86;
        v44 = v75 + 1;
        v75 = v44;
      }
      while ( v44 < 3 );
      v49 = &v98 - v81;
      v50 = 2;
      v3 = 0;
      do
      {
        if ( v50 < v81 )
          *(&v96 + v50) = 0;
        else
          *(&v96 + v50) = *v49;
        --v49;
        --v50;
      }
      while ( v50 >= 0 );
    }
    else
    {
      v96 = 0;
      v97 = 0;
      v98 = 0;
    }
    v7 = v3;
  }
  v3 = 2;
LABEL_85:
  v4 = a2;
LABEL_86:
  v64 = v96 | (v67 != 0 ? 0x80000000 : 0) | (v7 << (31 - dword_10075644));
  if ( dword_10075648 == 64 )
  {
    v65 = v97;
    *(_DWORD *)(v4 + 4) = v64;
    *(_DWORD *)v4 = v65;
  }
  else
  {
    if ( dword_10075648 == 32 )
      *(_DWORD *)v4 = v64;
  }
  return v3;
}
// 10074200: using guessed type int __security_cookie;
// 10075638: using guessed type int dword_10075638;
// 1007563C: using guessed type int dword_1007563C;
// 10075640: using guessed type int dword_10075640;
// 10075644: using guessed type int dword_10075644;
// 10075648: using guessed type int dword_10075648;
// 1007564C: using guessed type int dword_1007564C;

//----- (10055E1B) --------------------------------------------------------
signed int __cdecl sub_10055E1B(int a1, int a2)
{
  int v2; // edx@1
  signed int v3; // ebx@1
  int v4; // edi@1
  __int16 v5; // dx@1
  signed int v6; // eax@2
  int v7; // esi@2
  int v8; // edx@8
  int v9; // ecx@8
  signed int v10; // edi@8
  char i; // zf@9
  int v12; // eax@14
  signed int v13; // ecx@14
  unsigned int v14; // eax@14
  char v15; // cf@14
  int v16; // edx@17
  int v17; // eax@19
  unsigned int v18; // eax@19
  char v19; // cf@19
  int v20; // ecx@28
  char v21; // di@34
  int v22; // eax@34
  int v23; // eax@35
  unsigned int v24; // edx@35
  int v25; // eax@36
  int *v26; // edx@36
  signed int v27; // ecx@36
  signed int v28; // edi@36
  int v29; // edx@41
  int v30; // ecx@41
  int v31; // ecx@41
  char j; // zf@42
  int v33; // eax@47
  signed int v34; // ecx@47
  unsigned int v35; // eax@47
  signed int v36; // edi@47
  int v37; // edi@47
  char v38; // cf@47
  int v39; // edx@50
  int v40; // eax@52
  unsigned int v41; // eax@52
  char v42; // cf@52
  int v43; // edx@59
  int v44; // eax@61
  char v45; // bl@61
  signed int v46; // edi@61
  int v47; // ecx@61
  unsigned int v48; // edx@62
  int *v49; // edx@63
  signed int v50; // ecx@63
  int v51; // ecx@70
  signed int v52; // edi@70
  int v53; // eax@71
  unsigned int v54; // edx@71
  int *v55; // edx@72
  signed int v56; // ecx@72
  char v57; // bl@78
  signed int v58; // edi@78
  signed int v59; // esi@78
  int v60; // eax@79
  unsigned int v61; // edx@79
  int *v62; // edx@80
  signed int v63; // ecx@80
  int v64; // esi@86
  int v65; // eax@87
  int v67; // [sp+Ch] [bp-44h]@1
  int v68; // [sp+14h] [bp-3Ch]@8
  int v69; // [sp+14h] [bp-3Ch]@34
  signed int v70; // [sp+18h] [bp-38h]@14
  int v71; // [sp+18h] [bp-38h]@34
  int v72; // [sp+18h] [bp-38h]@70
  int v73; // [sp+18h] [bp-38h]@78
  signed int v74; // [sp+1Ch] [bp-34h]@8
  int v75; // [sp+1Ch] [bp-34h]@61
  int v76; // [sp+1Ch] [bp-34h]@70
  char v77; // [sp+20h] [bp-30h]@8
  int v78; // [sp+20h] [bp-30h]@41
  signed int v79; // [sp+24h] [bp-2Ch]@8
  signed int v80; // [sp+28h] [bp-28h]@34
  int v81; // [sp+28h] [bp-28h]@61
  int v82; // [sp+28h] [bp-28h]@70
  int v83; // [sp+28h] [bp-28h]@78
  int v84; // [sp+2Ch] [bp-24h]@8
  signed int v85; // [sp+2Ch] [bp-24h]@47
  int v86; // [sp+2Ch] [bp-24h]@61
  int v87; // [sp+2Ch] [bp-24h]@78
  int v88; // [sp+30h] [bp-20h]@1
  int v89; // [sp+30h] [bp-20h]@34
  int v90; // [sp+30h] [bp-20h]@61
  int v91; // [sp+30h] [bp-20h]@70
  int v92; // [sp+30h] [bp-20h]@78
  int v93; // [sp+34h] [bp-1Ch]@8
  int v94; // [sp+38h] [bp-18h]@8
  int v95; // [sp+3Ch] [bp-14h]@8
  int v96; // [sp+40h] [bp-10h]@1
  int v97; // [sp+44h] [bp-Ch]@1
  int v98; // [sp+48h] [bp-8h]@1
  unsigned int v99; // [sp+4Ch] [bp-4h]@1
  int v100; // [sp+50h] [bp+0h]@1

  v99 = (unsigned int)&v100 ^ __security_cookie;
  v5 = *(_WORD *)(a1 + 10);
  v67 = *(_WORD *)(a1 + 10) & 0x8000;
  v96 = *(_DWORD *)(a1 + 6);
  v97 = *(_DWORD *)(a1 + 2);
  v2 = (v5 & 0x7FFF) - 16383;
  v4 = a2;
  v3 = 0;
  v88 = v2;
  v98 = *(_WORD *)a1 << 16;
  if ( v2 == -16383 )
  {
    v7 = 0;
    v6 = 0;
    while ( !*(&v96 + v6) )
    {
      ++v6;
      if ( v6 >= 3 )
        goto LABEL_86;
    }
    v96 = 0;
    v97 = 0;
    v98 = 0;
  }
  else
  {
    v93 = v96;
    v94 = v97;
    v84 = v2;
    v74 = dword_10075658 - 1;
    v95 = v98;
    v8 = dword_10075658 / 32;
    v79 = 0;
    v68 = dword_10075658 / 32;
    v9 = 31 - dword_10075658 % 32;
    v10 = -1;
    v77 = v9;
    if ( (1 << v9) & *(&v96 + dword_10075658 / 32) )
    {
      for ( i = (~(-1 << v9) & *(&v96 + v8)) == 0; i; i = *(&v96 + v8) == 0 )
      {
        ++v8;
        if ( v8 >= 3 )
          goto LABEL_25;
      }
      v79 = 0;
      v10 = -1;
      v70 = 1 << (31 - v74 % 32);
      v14 = *(&v96 + v74 / 32);
      v15 = v14 + v70 < v14;
      v12 = v14 + v70;
      v13 = 0;
      if ( v15 || v12 < (unsigned int)v70 )
      {
        v13 = 1;
        v79 = 1;
      }
      v16 = v74 / 32 - 1;
      *(&v97 + v16) = v12;
      if ( v16 >= 0 )
      {
        do
        {
          if ( !v13 )
            break;
          v18 = *(&v96 + v16);
          v13 = 0;
          v19 = v18 + 1 < v18;
          v79 = 0;
          v17 = v18 + 1;
          if ( v19 || (unsigned int)v17 < 1 )
          {
            v13 = 1;
            v79 = 1;
          }
          --v16;
          *(&v97 + v16) = v17;
        }
        while ( v16 >= 0 );
        v10 = -1;
      }
      LOBYTE(v9) = v77;
LABEL_25:
      v8 = v68;
    }
    *(&v96 + v8) &= v10 << v9;
    if ( v8 + 1 < 3 )
    {
      memset(&v96 + v8 + 1, 0, 4 * (3 - (v8 + 1)));
      v10 = -1;
    }
    v20 = v88;
    if ( v79 )
      v20 = v88 + 1;
    if ( v20 >= dword_10075654 - dword_10075658 )
    {
      if ( v20 > dword_10075654 )
      {
        if ( v20 < dword_10075650 )
        {
          v96 &= 0x7FFFFFFFu;
          v73 = v20 + dword_10075664;
          v83 = dword_1007565C / 32;
          v92 = 0;
          v59 = 0;
          v57 = dword_1007565C % 32;
          v58 = ~(v10 << dword_1007565C % 32);
          v87 = 32 - dword_1007565C % 32;
          do
          {
            v60 = (v58 & *(&v96 + v59)) << v87;
            v61 = v92 | ((unsigned int)*(&v96 + v59++) >> v57);
            *(&v95 + v59) = v61;
            v92 = v60;
          }
          while ( v59 < 3 );
          v7 = v73;
          v62 = &v98 - v83;
          v63 = 2;
          v3 = 0;
          do
          {
            if ( v63 < v83 )
              *(&v96 + v63) = 0;
            else
              *(&v96 + v63) = *v62;
            --v62;
            --v63;
          }
          while ( v63 >= 0 );
        }
        else
        {
          v97 = 0;
          v98 = 0;
          v96 = -2147483648;
          v76 = dword_1007565C / 32;
          v51 = dword_1007565C % 32;
          v72 = dword_1007565C % 32;
          v52 = ~(-1 << dword_1007565C % 32);
          v91 = 0;
          v82 = 32 - dword_1007565C % 32;
          do
          {
            v53 = (v52 & *(&v96 + v3)) << v82;
            v54 = v91 | ((unsigned int)*(&v96 + v3) >> v51);
            LOBYTE(v51) = v72;
            *(&v96 + v3++) = v54;
            v91 = v53;
          }
          while ( v3 < 3 );
          v55 = &v98 - v76;
          v56 = 2;
          do
          {
            if ( v56 < v76 )
              *(&v96 + v56) = 0;
            else
              *(&v96 + v56) = *v55;
            --v55;
            --v56;
          }
          while ( v56 >= 0 );
          v7 = dword_10075650 + dword_10075664;
          v3 = 1;
        }
        goto LABEL_85;
      }
      v96 = v93;
      v97 = v94;
      v69 = (dword_10075654 - v84) / 32;
      v98 = v95;
      v22 = (dword_10075654 - v84) % 32;
      v21 = (dword_10075654 - v84) % 32;
      v89 = 0;
      v80 = ~(-1 << v22);
      v71 = 32 - v22;
      do
      {
        v23 = (v80 & *(&v96 + v3)) << v71;
        v24 = v89 | ((unsigned int)*(&v96 + v3++) >> v21);
        *(&v95 + v3) = v24;
        v89 = v23;
      }
      while ( v3 < 3 );
      v26 = &v98 - v69;
      v25 = v69;
      v27 = 2;
      v28 = -1;
      do
      {
        if ( v27 < v25 )
        {
          *(&v96 + v27) = 0;
        }
        else
        {
          *(&v96 + v27) = *v26;
          v25 = v69;
        }
        --v26;
        --v27;
      }
      while ( v27 >= 0 );
      v29 = (v74 + 1) / 32;
      v31 = (v74 + 1) % 32;
      v78 = 31 - v31;
      v30 = 31 - v31;
      if ( (1 << v30) & *(&v96 + v29) )
      {
        for ( j = (~(-1 << v30) & *(&v96 + v29)) == 0; j; j = *(&v96 + v29) == 0 )
        {
          ++v29;
          if ( v29 >= 3 )
            goto LABEL_58;
        }
        v35 = *(&v96 + v74 / 32);
        v36 = 1 << (31 - v74 % 32);
        v34 = 0;
        v85 = v36;
        v37 = v35 + v36;
        v38 = v37 < v35;
        v33 = v37;
        v28 = -1;
        if ( v38 || v33 < (unsigned int)v85 )
          v34 = 1;
        v39 = v74 / 32 - 1;
        *(&v97 + v39) = v33;
        if ( v39 >= 0 )
        {
          do
          {
            if ( !v34 )
              break;
            v41 = *(&v96 + v39);
            v34 = 0;
            v42 = v41 + 1 < v41;
            v40 = v41 + 1;
            if ( v42 || (unsigned int)v40 < 1 )
              v34 = 1;
            --v39;
            *(&v97 + v39) = v40;
          }
          while ( v39 >= 0 );
          v28 = -1;
        }
        LOBYTE(v30) = v78;
LABEL_58:
        v29 = (v74 + 1) / 32;
      }
      *(&v96 + v29) &= v28 << v30;
      v43 = v29 + 1;
      if ( v43 < 3 )
      {
        memset(&v96 + v43, 0, 4 * (3 - v43));
        v28 = -1;
      }
      v81 = (dword_1007565C + 1) / 32;
      v47 = (dword_1007565C + 1) % 32;
      v44 = 0;
      v90 = 0;
      v45 = (dword_1007565C + 1) % 32;
      v46 = ~(v28 << v47);
      v75 = 0;
      v86 = 32 - v47;
      do
      {
        v48 = *(&v96 + v44);
        *(&v96 + v75) = v90 | (v48 >> v45);
        v90 = (v46 & v48) << v86;
        v44 = v75 + 1;
        v75 = v44;
      }
      while ( v44 < 3 );
      v49 = &v98 - v81;
      v50 = 2;
      v3 = 0;
      do
      {
        if ( v50 < v81 )
          *(&v96 + v50) = 0;
        else
          *(&v96 + v50) = *v49;
        --v49;
        --v50;
      }
      while ( v50 >= 0 );
    }
    else
    {
      v96 = 0;
      v97 = 0;
      v98 = 0;
    }
    v7 = v3;
  }
  v3 = 2;
LABEL_85:
  v4 = a2;
LABEL_86:
  v64 = v96 | (v67 != 0 ? 0x80000000 : 0) | (v7 << (31 - dword_1007565C));
  if ( dword_10075660 == 64 )
  {
    v65 = v97;
    *(_DWORD *)(v4 + 4) = v64;
    *(_DWORD *)v4 = v65;
  }
  else
  {
    if ( dword_10075660 == 32 )
      *(_DWORD *)v4 = v64;
  }
  return v3;
}
// 10074200: using guessed type int __security_cookie;
// 10075650: using guessed type int dword_10075650;
// 10075654: using guessed type int dword_10075654;
// 10075658: using guessed type int dword_10075658;
// 1007565C: using guessed type int dword_1007565C;
// 10075660: using guessed type int dword_10075660;
// 10075664: using guessed type int dword_10075664;

//----- (1005638B) --------------------------------------------------------
signed int __cdecl sub_1005638B(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  signed int v8; // eax@1
  signed int v9; // ebx@1
  char *v10; // edi@1
  int v11; // esi@1
  int v13; // ecx@3
  char v14; // dl@4
  char v15; // dl@9
  unsigned int v16; // eax@38
  int v17; // esi@38
  int v18; // eax@49
  unsigned __int8 v19; // sf@50
  unsigned __int8 v20; // of@50
  int v21; // eax@51
  int v22; // esi@56
  char v23; // zf@74
  int v24; // ecx@109
  int v25; // edi@112
  signed int v26; // esi@117
  char *v27; // eax@123
  char v28; // cl@128
  int v29; // ecx@128
  int v30; // ecx@129
  int v31; // esi@130
  unsigned __int16 v32; // di@131
  int v33; // esi@131
  signed int v34; // eax@145
  char *v35; // edx@145
  signed int v36; // edi@145
  int v37; // eax@147
  signed int v38; // ecx@147
  char *v39; // esi@147
  int v40; // edi@148
  int v41; // edi@148
  signed int v42; // eax@150
  int v43; // edx@157
  int v44; // edi@157
  int v45; // esi@157
  unsigned int v46; // eax@159
  int v47; // eax@165
  char v48; // zf@165
  char v49; // zf@166
  unsigned __int16 v50; // ax@167
  int v51; // ecx@177
  unsigned int v52; // eax@186
  int v53; // edx@186
  __int16 v54; // cx@186
  signed int v55; // esi@186
  signed int v56; // [sp-4h] [bp-8Ch]@11
  signed int v57; // [sp-4h] [bp-8Ch]@14
  signed int v58; // [sp-4h] [bp-8Ch]@188
  signed int v59; // [sp+18h] [bp-70h]@145
  signed __int16 v60; // [sp+1Ch] [bp-6Ch]@1
  signed int v61; // [sp+20h] [bp-68h]@145
  int v62; // [sp+20h] [bp-68h]@162
  signed int v63; // [sp+24h] [bp-64h]@1
  int v64; // [sp+24h] [bp-64h]@147
  signed int v65; // [sp+28h] [bp-60h]@1
  __int16 v66; // [sp+28h] [bp-60h]@131
  signed int v67; // [sp+2Ch] [bp-5Ch]@1
  int v68; // [sp+2Ch] [bp-5Ch]@131
  signed int v69; // [sp+30h] [bp-58h]@1
  int v70; // [sp+30h] [bp-58h]@148
  int v71; // [sp+34h] [bp-54h]@1
  signed int v72; // [sp+34h] [bp-54h]@128
  int v73; // [sp+38h] [bp-50h]@3
  __int64 *v74; // [sp+38h] [bp-50h]@129
  int v75; // [sp+38h] [bp-50h]@157
  unsigned int v76; // [sp+3Ch] [bp-4Ch]@1
  char *v77; // [sp+3Ch] [bp-4Ch]@128
  __int64 v78; // [sp+40h] [bp-48h]@130
  int v79; // [sp+48h] [bp-40h]@130
  int v80; // [sp+4Ch] [bp-3Ch]@115
  int v81; // [sp+50h] [bp-38h]@138
  unsigned int v82; // [sp+54h] [bp-34h]@135
  int v83; // [sp+56h] [bp-32h]@131
  __int64 v84; // [sp+5Ah] [bp-2Eh]@131
  signed int v85; // [sp+62h] [bp-26h]@172
  int v86; // [sp+64h] [bp-24h]@131
  char v87; // [sp+68h] [bp-20h]@1
  char v88; // [sp+7Fh] [bp-9h]@107
  unsigned int v89; // [sp+84h] [bp-4h]@1
  int v90; // [sp+88h] [bp+0h]@1

  v89 = (unsigned int)&v90 ^ __security_cookie;
  v9 = 0;
  v65 = 1;
  v8 = 0;
  v10 = &v87;
  v60 = 0;
  v76 = 0;
  v63 = 0;
  v69 = 0;
  v67 = 0;
  v11 = 0;
  v71 = 0;
  if ( !a8 )
  {
    *(_DWORD *)sub_10037669(0) = 22;
    sub_1003A16E(0, (int)&v87);
    return 0;
  }
  v13 = a3;
  v73 = a3;
  while ( 1 )
  {
    v14 = *(_BYTE *)v13;
    if ( *(_BYTE *)v13 != 32 )
    {
      if ( v14 != 9 && v14 != 10 && v14 != 13 )
        break;
    }
    ++v13;
  }
  while ( 2 )
  {
    v15 = *(_BYTE *)v13++;
    switch ( v8 )
    {
      case 0:
        if ( (unsigned __int8)(v15 - 49) <= 8u )
          goto LABEL_11;
        if ( v15 == ***(_BYTE ***)(*(_DWORD *)a8 + 132) )
          goto LABEL_14;
        if ( v15 == 43 )
        {
          v8 = 2;
          v60 = 0;
          continue;
        }
        if ( v15 == 45 )
        {
          v8 = 2;
          v60 = -32768;
          continue;
        }
        if ( v15 != 48 )
          goto LABEL_103;
        goto LABEL_19;
      case 1:
        v63 = 1;
        if ( (unsigned __int8)(v15 - 49) <= 8u )
          goto LABEL_11;
        if ( v15 == ***(_BYTE ***)(*(_DWORD *)a8 + 132) )
          goto LABEL_24;
        if ( v15 == 43 || v15 == 45 )
          goto LABEL_32;
        if ( v15 != 48 )
          goto LABEL_28;
        goto LABEL_19;
      case 2:
        if ( (unsigned __int8)(v15 - 49) <= 8u )
        {
LABEL_11:
          v56 = 3;
          goto LABEL_12;
        }
        if ( v15 == ***(_BYTE ***)(*(_DWORD *)a8 + 132) )
        {
LABEL_14:
          v57 = 5;
          goto LABEL_15;
        }
        if ( v15 != 48 )
          goto LABEL_36;
LABEL_19:
        v8 = 1;
        continue;
      case 3:
        v63 = 1;
        if ( v15 >= 48 )
        {
          v16 = v76;
          v17 = v71;
          do
          {
            if ( v15 > 57 )
              break;
            if ( v16 >= 0x19 )
            {
              ++v17;
            }
            else
            {
              ++v16;
              *v10++ = v15 - 48;
            }
            v15 = *(_BYTE *)v13++;
          }
          while ( v15 >= 48 );
          v71 = v17;
          v76 = v16;
          v11 = 0;
        }
        if ( v15 == ***(_BYTE ***)(*(_DWORD *)a8 + 132) )
        {
LABEL_24:
          v57 = 4;
        }
        else
        {
          if ( v15 == 43 || v15 == 45 )
          {
LABEL_32:
            --v13;
            v57 = 11;
          }
          else
          {
LABEL_28:
            if ( v15 <= 67 || v15 > 69 && (unsigned __int8)(v15 - 100) > 1u )
            {
LABEL_103:
              --v13;
              goto LABEL_104;
            }
LABEL_31:
            v57 = 6;
          }
        }
        goto LABEL_15;
      case 4:
        v63 = 1;
        v69 = 1;
        v18 = v76;
        if ( v76 )
          goto LABEL_54;
        v20 = __SETO__(v15, 48);
        v19 = (char)(v15 - 48) < 0;
        if ( v15 == 48 )
        {
          v21 = v71;
          do
          {
            v15 = *(_BYTE *)v13;
            --v21;
            ++v13;
          }
          while ( v15 == 48 );
          v71 = v21;
          v18 = v76;
LABEL_54:
          v20 = __SETO__(v15, 48);
          v19 = (char)(v15 - 48) < 0;
        }
        if ( !(v19 ^ v20) )
        {
          v22 = v71;
          do
          {
            if ( v15 > 57 )
              break;
            if ( (unsigned int)v18 < 0x19 )
            {
              ++v18;
              *v10++ = v15 - 48;
              --v22;
            }
            v15 = *(_BYTE *)v13++;
          }
          while ( v15 >= 48 );
          v71 = v22;
          v76 = v18;
          v11 = 0;
        }
        if ( v15 == 43 || v15 == 45 )
          goto LABEL_32;
        if ( v15 > 67 && (v15 <= 69 || (unsigned __int8)(v15 - 100) <= 1u) )
          goto LABEL_31;
        --v13;
        goto LABEL_105;
      case 5:
        v69 = 1;
        if ( (unsigned __int8)(v15 - 48) > 9u )
          goto LABEL_36;
        v56 = 4;
        goto LABEL_12;
      case 6:
        v73 = v13 - 2;
        if ( (unsigned __int8)(v15 - 49) <= 8u )
          goto LABEL_71;
        if ( v15 == 43 )
          goto LABEL_78;
        if ( v15 != 45 )
        {
          v23 = v15 == 48;
          goto LABEL_75;
        }
        v8 = 7;
        v65 = -1;
        continue;
      case 8:
        v67 = 1;
        while ( v15 == 48 )
          v15 = *(_BYTE *)v13++;
        if ( (unsigned __int8)(v15 - 49) <= 8u )
          goto LABEL_71;
        goto LABEL_103;
      case 7:
        if ( (unsigned __int8)(v15 - 49) <= 8u )
        {
LABEL_71:
          v56 = 9;
LABEL_12:
          v8 = v56;
          --v13;
          continue;
        }
        v23 = v15 == 48;
LABEL_75:
        if ( !v23 )
          goto LABEL_36;
        v57 = 8;
        goto LABEL_15;
      case 11:
        if ( !a7 )
        {
          v8 = 10;
          --v13;
LABEL_91:
          if ( v8 == 10 )
            goto LABEL_104;
          continue;
        }
        v73 = v13 - 1;
        if ( v15 == 43 )
        {
LABEL_78:
          v57 = 7;
LABEL_15:
          v8 = v57;
          continue;
        }
        if ( v15 == 45 )
        {
          v65 = -1;
          v8 = 7;
          continue;
        }
LABEL_36:
        v13 = v73;
LABEL_104:
        v18 = v76;
LABEL_105:
        *(_DWORD *)a2 = v13;
        if ( !v63 )
        {
          LOWORD(v52) = 0;
          v55 = 0;
          v58 = 4;
          goto LABEL_191;
        }
        if ( (unsigned int)v18 <= 0x18 )
        {
          v24 = v71;
        }
        else
        {
          if ( v88 >= 5 )
            ++v88;
          --v10;
          v24 = v71 + 1;
          v18 = 24;
          ++v71;
        }
        if ( !v18 )
        {
          v54 = 0;
          LOWORD(v52) = 0;
          v55 = 0;
          v53 = 0;
          goto LABEL_192;
        }
        v25 = (int)(v10 - 1);
        if ( !*(_BYTE *)v25 )
        {
          do
          {
            --v18;
            ++v24;
            --v25;
          }
          while ( !*(_BYTE *)v25 );
          v71 = v24;
        }
        sub_10058782((unsigned int *)&v87, v18, (int)&v80);
        if ( v65 < 0 )
          v11 = -v11;
        v26 = v71 + v11;
        if ( !v67 )
          v26 += a5;
        if ( !v69 )
          v26 -= a6;
        if ( v26 > 5200 )
        {
          LOWORD(v52) = 32767;
          v55 = -2147483648;
          v58 = 2;
LABEL_191:
          v54 = 0;
          v53 = 0;
          v9 = v58;
          goto LABEL_192;
        }
        if ( v26 < -5200 )
        {
          v54 = 0;
          LOWORD(v52) = 0;
          v55 = 0;
          v53 = 0;
          v9 = 1;
        }
        else
        {
          v27 = (char *)&unk_10075678 - 96;
          if ( v26 )
          {
            if ( v26 < 0 )
            {
              v26 = -v26;
              v27 = (char *)&unk_100757D8 - 96;
            }
            if ( !a4 )
              LOWORD(v80) = 0;
            do
            {
LABEL_185:
              if ( !v26 )
                goto LABEL_186;
              v28 = v26;
              v27 += 84;
              v26 >>= 3;
              v77 = v27;
              v72 = v26;
              v29 = v28 & 7;
            }
            while ( !v29 );
            v30 = (int)&v27[12 * v29];
            v74 = (__int64 *)v30;
            if ( *(_WORD *)v30 >= 0x8000u )
            {
              v78 = *(_QWORD *)v30;
              v31 = v30 + 8;
              v30 = (int)&v78;
              v79 = *(_DWORD *)v31;
              --*(_DWORD *)((char *)&v78 + 2);
              v74 = &v78;
            }
            v66 = (v83 ^ *(_WORD *)(v30 + 10)) & 0x8000;
            v32 = *(_WORD *)(v30 + 10) & 0x7FFF;
            v33 = (unsigned __int16)(v32 + (v83 & 0x7FFF));
            *(_DWORD *)((char *)&v84 + 2) = v9;
            *(_DWORD *)((char *)&v84 + 6) = v9;
            v86 = v9;
            v68 = (unsigned __int16)(v32 + (v83 & 0x7FFF));
            if ( (v83 & 0x7FFFu) >= 0x7FFF || v32 >= 0x7FFFu || (_WORD)v33 > 0xBFFDu )
              goto LABEL_182;
            if ( (_WORD)v33 <= 0x3FBFu )
              goto LABEL_135;
            if ( !(v83 & 0x7FFF) )
            {
              ++v33;
              v68 = v33;
              if ( !(v82 & 0x7FFFFFFF) )
              {
                if ( !v81 && !v80 )
                {
                  LOWORD(v83) = 0;
LABEL_184:
                  v27 = v77;
                  v26 = v72;
                  goto LABEL_185;
                }
              }
            }
            if ( v32
              || (v68 = v33 + 1, *(_DWORD *)(v30 + 8) & 0x7FFFFFFF)
              || *(_DWORD *)(v30 + 4) != v9
              || *(_DWORD *)v30 != v9 )
            {
              v34 = v9;
              v36 = 5;
              v59 = v9;
              v35 = (char *)&v84 + 6;
              v61 = 5;
              do
              {
                if ( v36 > 0 )
                {
                  v39 = (char *)&v80 + 2 * v34;
                  v37 = v30 + 8;
                  v64 = v30 + 8;
                  v38 = v36;
                  do
                  {
                    v41 = *(_WORD *)v39 * *(_WORD *)v37;
                    v70 = v41;
                    v40 = *((_DWORD *)v35 - 1) + v41;
                    if ( (unsigned int)v40 >= *((_DWORD *)v35 - 1) && v40 >= (unsigned int)v70 )
                      v42 = v9;
                    else
                      v42 = 1;
                    *((_DWORD *)v35 - 1) = v40;
                    if ( v42 )
                      ++*(_WORD *)v35;
                    v37 = v64 - 2;
                    v39 += 2;
                    --v38;
                    v64 -= 2;
                  }
                  while ( v38 > 0 );
                  v30 = (int)v74;
                  v36 = v61;
                  v34 = v59;
                }
                v35 += 2;
                ++v34;
                --v36;
                v59 = v34;
                v61 = v36;
              }
              while ( v36 > 0 );
              v43 = v86;
              v44 = *(_DWORD *)((char *)&v84 + 2);
              v45 = v68 + 49154;
              v75 = v86;
              if ( (signed __int16)(v68 - 16382) > 0 )
              {
                do
                {
                  if ( v43 < 0 )
                    break;
                  v46 = *(_DWORD *)((char *)&v84 + 6);
                  *(_DWORD *)((char *)&v84 + 6) = ((unsigned int)v44 >> 31) | 2 * *(_DWORD *)((char *)&v84 + 6);
                  v43 = (v46 >> 31) | 2 * v75;
                  v44 *= 2;
                  v45 += 65535;
                  *(_DWORD *)((char *)&v84 + 2) = v44;
                  v75 = v43;
                  v86 = v43;
                }
                while ( (_WORD)v45 > 0 );
                if ( (_WORD)v45 > 0 )
                  goto LABEL_195;
              }
              v45 += 65535;
              if ( (_WORD)v45 >= 0 )
                goto LABEL_195;
              v62 = (unsigned __int16)-(_WORD)v45;
              v45 += v62;
              do
              {
                if ( BYTE2(v84) & 1 )
                  ++v9;
                v47 = (v43 << 31) | (*(_DWORD *)((char *)&v84 + 6) >> 1);
                v43 = (unsigned int)v43 >> 1;
                v44 = (*(_DWORD *)((char *)&v84 + 6) << 31) | ((unsigned int)v44 >> 1);
                v48 = v62-- == 1;
                v86 = v43;
                *(_DWORD *)((char *)&v84 + 6) = v47;
                *(_DWORD *)((char *)&v84 + 2) = v44;
              }
              while ( !v48 );
              v49 = v9 == 0;
              v75 = v43;
              v9 = 0;
              if ( v49 )
              {
LABEL_195:
                v50 = WORD1(v84);
              }
              else
              {
                v50 = v44 | 1;
                WORD1(v84) = v44 | 1;
                v44 = *(_DWORD *)((char *)&v84 + 2);
              }
              if ( v50 > 0x8000u || (v44 & 0x1FFFF) == 98304 )
              {
                if ( HIDWORD(v84) == -1 )
                {
                  HIDWORD(v84) = v9;
                  if ( v85 == -1 )
                  {
                    v85 = v9;
                    if ( HIWORD(v86) == -1 )
                    {
                      HIWORD(v86) = -32768;
                      ++v45;
                    }
                    else
                    {
                      v86 += 65536;
                    }
                  }
                  else
                  {
                    *(__int64 *)((char *)&v84 + 4) += 4294967296i64;
                  }
                  v51 = v86;
                  goto LABEL_180;
                }
                v84 += 4294967296i64;
              }
              v51 = v75;
LABEL_180:
              if ( (_WORD)v45 < 0x7FFFu )
              {
                LOWORD(v80) = WORD2(v84);
                *(int *)((char *)&v80 + 2) = *(_DWORD *)((char *)&v84 + 6);
                *(int *)((char *)&v81 + 2) = v51;
                LOWORD(v83) = v66 | v45;
                goto LABEL_184;
              }
LABEL_182:
              v82 = (((v66 == 0) - 1) & 0x80000000) + 2147450880;
            }
            else
            {
LABEL_135:
              v82 = v9;
            }
            v80 = v9;
            v81 = v9;
            goto LABEL_184;
          }
LABEL_186:
          v54 = v80;
          v53 = *(int *)((char *)&v80 + 2);
          v55 = *(int *)((char *)&v81 + 2);
          v52 = v82 >> 16;
        }
LABEL_192:
        *(_WORD *)a1 = v54;
        *(_WORD *)(a1 + 10) = v60 | v52;
        *(_DWORD *)(a1 + 2) = v53;
        *(_DWORD *)(a1 + 6) = v55;
        return v9;
      default:
        goto LABEL_91;
      case 9:
        v67 = 1;
        v11 = 0;
        while ( 2 )
        {
          if ( v15 >= 48 && v15 <= 57 )
          {
            v11 = v15 + 10 * v11 - 48;
            if ( v11 <= 5200 )
            {
              v15 = *(_BYTE *)v13++;
              continue;
            }
            v11 = 5201;
          }
          break;
        }
        while ( v15 >= 48 && v15 <= 57 )
          v15 = *(_BYTE *)v13++;
        goto LABEL_103;
    }
  }
}
// 10074200: using guessed type int __security_cookie;

//----- (10056B07) --------------------------------------------------------
signed int __cdecl sub_10056B07(__int64 a1, __int16 a2, int a3, char a4, int a5)
{
  __int16 v5; // dx@1
  unsigned __int16 v6; // si@1
  signed int result; // eax@6
  char v8; // zf@25
  char *v9; // eax@25
  int v10; // ecx@25
  int v11; // ebx@25
  int v12; // ecx@25
  int v13; // edx@29
  int v14; // esi@29
  int v15; // ecx@30
  int v16; // ecx@31
  int v17; // esi@32
  int v18; // edi@33
  unsigned __int16 v19; // di@33
  int v20; // eax@47
  char *v21; // edx@47
  signed int v22; // esi@47
  int v23; // eax@49
  signed int v24; // ecx@49
  int v25; // esi@49
  int v26; // eax@50
  int v27; // edi@50
  unsigned int v28; // eax@50
  char v29; // cf@50
  signed int v30; // esi@52
  int v31; // eax@59
  int v32; // edi@59
  int v33; // esi@59
  unsigned int v34; // eax@61
  unsigned int v35; // ebx@64
  int v36; // edi@64
  int v37; // eax@64
  int v38; // eax@67
  char v39; // zf@67
  char v40; // zf@68
  unsigned __int16 v41; // ax@69
  int v42; // ecx@79
  int v43; // eax@91
  int v44; // edi@92
  signed int v45; // eax@106
  int v46; // edx@106
  char *v47; // ecx@106
  signed int v48; // esi@107
  int v49; // eax@108
  int v50; // edi@108
  int v51; // edx@109
  int v52; // edi@109
  unsigned int v53; // eax@109
  signed int v54; // eax@111
  int v55; // edi@118
  int v56; // esi@118
  unsigned int v57; // ebx@119
  unsigned int v58; // eax@121
  int v59; // edx@122
  unsigned __int16 v60; // cx@123
  int v61; // edi@132
  int v62; // eax@132
  int v63; // ebx@135
  char v64; // zf@135
  char v65; // zf@136
  int v66; // ecx@146
  int v67; // edi@146
  int v68; // ebx@153
  signed int v69; // edi@153
  unsigned int v70; // eax@154
  int v71; // edi@156
  unsigned int v72; // ebx@157
  unsigned int v73; // eax@158
  int v74; // ecx@160
  int v75; // edi@160
  int v76; // esi@160
  unsigned int v77; // edx@161
  unsigned int v78; // ecx@161
  int v79; // esi@161
  int v80; // esi@161
  int v81; // ecx@161
  signed int v82; // ecx@163
  char v83; // zf@166
  unsigned int v84; // edi@168
  char v85; // al@174
  int v86; // ecx@174
  char v87; // cl@182
  int v88; // [sp-4h] [bp-98h]@11
  int v89; // [sp-4h] [bp-98h]@15
  int *v90; // [sp+Ch] [bp-88h]@31
  int v91; // [sp+10h] [bp-84h]@49
  int v92; // [sp+14h] [bp-80h]@47
  int v93; // [sp+18h] [bp-7Ch]@92
  __int16 v94; // [sp+1Ch] [bp-78h]@1
  int v95; // [sp+20h] [bp-74h]@33
  unsigned __int16 v96; // [sp+20h] [bp-74h]@92
  int *v97; // [sp+28h] [bp-6Ch]@108
  int v98; // [sp+2Ch] [bp-68h]@153
  __int16 v99; // [sp+30h] [bp-64h]@33
  unsigned __int16 v100; // [sp+34h] [bp-60h]@33
  signed int v101; // [sp+34h] [bp-60h]@48
  signed int v102; // [sp+38h] [bp-5Ch]@25
  int v103; // [sp+38h] [bp-5Ch]@132
  int v104; // [sp+38h] [bp-5Ch]@160
  char *v105; // [sp+3Ch] [bp-58h]@108
  int v106; // [sp+3Ch] [bp-58h]@160
  char *v107; // [sp+40h] [bp-54h]@30
  __int16 v108; // [sp+40h] [bp-54h]@92
  signed int v109; // [sp+44h] [bp-50h]@47
  int v110; // [sp+44h] [bp-50h]@64
  int v111; // [sp+44h] [bp-50h]@106
  int v112; // [sp+48h] [bp-4Ch]@33
  int v113; // [sp+48h] [bp-4Ch]@64
  int v114; // [sp+48h] [bp-4Ch]@92
  int v115; // [sp+48h] [bp-4Ch]@132
  int v116; // [sp+4Ch] [bp-48h]@25
  signed int v117; // [sp+4Ch] [bp-48h]@147
  unsigned int v118; // [sp+4Ch] [bp-48h]@161
  signed int v119; // [sp+50h] [bp-44h]@25
  unsigned int v120; // [sp+50h] [bp-44h]@155
  int v121; // [sp+54h] [bp-40h]@29
  int v122; // [sp+54h] [bp-40h]@49
  int v123; // [sp+54h] [bp-40h]@59
  unsigned int v124; // [sp+54h] [bp-40h]@155
  int v125; // [sp+58h] [bp-3Ch]@32
  __int64 v126; // [sp+5Ch] [bp-38h]@32
  int v127; // [sp+64h] [bp-30h]@1
  int v128; // [sp+68h] [bp-2Ch]@1
  int v129; // [sp+6Ch] [bp-28h]@1
  _TBYTE v130; // [sp+74h] [bp-20h]@25
  __int16 v131; // [sp+7Eh] [bp-16h]@25
  __int64 v132; // [sp+82h] [bp-12h]@33
  int v133; // [sp+8Ah] [bp-Ah]@74
  int v134; // [sp+8Ch] [bp-8h]@33
  unsigned int v135; // [sp+90h] [bp-4h]@1
  int v136; // [sp+94h] [bp+0h]@1

  v135 = (unsigned int)&v136 ^ __security_cookie;
  v5 = a2 & 0x8000;
  v6 = a2 & 0x7FFF;
  v127 = -858993460;
  v128 = -858993460;
  v129 = 1073466572;
  v94 = a2 & 0x8000;
  if ( a2 & 0x8000 )
    *(_BYTE *)(a5 + 2) = 45;
  else
    *(_BYTE *)(a5 + 2) = 32;
  if ( v6 )
  {
    if ( v6 != 32767 )
      goto LABEL_25;
    *(_WORD *)a5 = 1;
    if ( (HIDWORD(a1) != -2147483648 || (_DWORD)a1) && !(HIDWORD(a1) & 0x40000000) )
    {
      v88 = (int)"1#SNAN";
      goto LABEL_22;
    }
    if ( v5 && HIDWORD(a1) == -1073741824 )
    {
      if ( !(_DWORD)a1 )
      {
        v89 = (int)"1#IND";
        goto LABEL_19;
      }
    }
    else
    {
      if ( HIDWORD(a1) == -2147483648 && !(_DWORD)a1 )
      {
        v89 = (int)"1#INF";
LABEL_19:
        if ( !sub_1003ADE5(a5, SHIDWORD(a1), a5 + 4, 22, v89) )
        {
          *(_BYTE *)(a5 + 3) = 5;
          return 0;
        }
LABEL_189:
        sub_1003A17E(0, SHIDWORD(a1));
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_100574CB);
      }
    }
    v88 = (int)"1#QNAN";
LABEL_22:
    if ( !sub_1003ADE5(a5, SHIDWORD(a1), a5 + 4, 22, v88) )
    {
      *(_BYTE *)(a5 + 3) = 6;
      return 0;
    }
    goto LABEL_189;
  }
  if ( !a1 )
  {
    *(_WORD *)a5 = 0;
    *(_BYTE *)(a5 + 2) = (((v5 != -32768) - 1) & 0xD) + 32;
    *(_BYTE *)(a5 + 3) = 1;
    *(_WORD *)(a5 + 4) = 48;
    return 1;
  }
LABEL_25:
  v12 = (unsigned __int16)((signed int)(19728 * v6 - 323162868 + 77
                                                               * (((unsigned int)v6 >> 8) + 2 * (HIDWORD(a1) >> 24))) >> 16);
  *(_QWORD *)((char *)&v130 + 2) = a1;
  v116 = v12;
  LOWORD(v130) = 0;
  v10 = -(signed __int16)v12;
  v9 = (char *)&unk_10075678 - 96;
  v11 = 0;
  v131 = a2 & 0x7FFF;
  v119 = v10;
  v102 = 5;
  v8 = v10 == 0;
  if ( v10 )
  {
    if ( v10 < 0 )
    {
      v10 = -v10;
      v9 = (char *)&unk_100757D8 - 96;
      v119 = v10;
      v8 = v10 == 0;
    }
    if ( !v8 )
    {
      v14 = LODWORD(v130);
      v13 = DWORD1(v130);
      v121 = LODWORD(v130);
      while ( 1 )
      {
        v119 >>= 3;
        v9 += 84;
        v107 = v9;
        v15 = v10 & 7;
        if ( v15 )
          break;
LABEL_88:
        LOBYTE(v10) = v119;
        if ( !v119 )
          goto LABEL_91;
      }
      v16 = (int)&v9[12 * v15];
      v90 = (int *)v16;
      if ( *(_WORD *)v16 >= 0x8000u )
      {
        v125 = *(_DWORD *)v16;
        LODWORD(v126) = *(_DWORD *)(v16 + 4);
        v17 = v16 + 8;
        v16 = (int)&v125;
        HIDWORD(v126) = *(_DWORD *)v17;
        --*(int *)((char *)&v125 + 2);
        v90 = &v125;
      }
      v19 = *(_WORD *)(v16 + 10) & 0x7FFF;
      v99 = (v131 ^ *(_WORD *)(v16 + 10)) & 0x8000;
      v100 = v19;
      v18 = (unsigned __int16)(v19 + (v131 & 0x7FFF));
      v95 = v11;
      *(_DWORD *)((char *)&v132 + 2) = v11;
      *(_DWORD *)((char *)&v132 + 6) = v11;
      v134 = v11;
      v112 = v18;
      if ( (v131 & 0x7FFFu) >= 0x7FFF || (v14 = v121, v100 >= 0x7FFFu) || (_WORD)v18 > 0xBFFDu )
      {
LABEL_84:
        *((_DWORD *)&v130 + 2) = (((v99 == 0) - 1) & 0x80000000) + 2147450880;
        goto LABEL_85;
      }
      if ( (_WORD)v18 <= 0x3FBFu )
        goto LABEL_193;
      if ( !(v131 & 0x7FFF) )
      {
        ++v18;
        v112 = v18;
        if ( !(*((_DWORD *)&v130 + 2) & 0x7FFFFFFF) )
        {
          if ( !v13 && !v121 )
          {
            v131 = 0;
LABEL_87:
            v9 = v107;
            goto LABEL_88;
          }
        }
      }
      if ( !v100 )
      {
        v112 = v18 + 1;
        if ( !(*(_DWORD *)(v16 + 8) & 0x7FFFFFFF) )
        {
          if ( *(_DWORD *)(v16 + 4) == v11 && *(_DWORD *)v16 == v11 )
          {
LABEL_193:
            *((_DWORD *)&v130 + 2) = v11;
LABEL_85:
            v14 = v11;
            v13 = v11;
            LODWORD(v130) = v11;
            DWORD1(v130) = v11;
            goto LABEL_86;
          }
        }
      }
      v20 = v11;
      v22 = 5;
      v92 = v11;
      v21 = (char *)&v132 + 6;
      v109 = 5;
      do
      {
        v101 = v22;
        if ( v22 > 0 )
        {
          v23 = (int)((char *)&v130 + 2 * v20);
          v25 = v16 + 8;
          v24 = v101;
          v122 = v23;
          v91 = v25;
          do
          {
            v27 = *(_WORD *)v25 * *(_WORD *)v23;
            v28 = *((_DWORD *)v21 - 1);
            v29 = v28 + v27 < v28;
            v26 = v28 + v27;
            if ( v29 || v26 < (unsigned int)v27 )
              v30 = 1;
            else
              v30 = v11;
            *((_DWORD *)v21 - 1) = v26;
            if ( v30 )
              ++*(_WORD *)v21;
            v23 = v122 + 2;
            v25 = v91 - 2;
            --v24;
            v122 += 2;
            v91 -= 2;
          }
          while ( v24 > 0 );
          v16 = (int)v90;
          v22 = v109;
          v20 = v92;
        }
        v21 += 2;
        ++v20;
        --v22;
        v92 = v20;
        v109 = v22;
      }
      while ( v22 > 0 );
      v31 = v134;
      v33 = *(_DWORD *)((char *)&v132 + 2);
      v32 = v112 + 49154;
      v123 = v134;
      if ( (signed __int16)(v112 - 16382) > 0 )
      {
        do
        {
          if ( v31 < 0 )
            break;
          v34 = *(_DWORD *)((char *)&v132 + 6);
          *(_DWORD *)((char *)&v132 + 6) = ((unsigned int)v33 >> 31) | 2 * *(_DWORD *)((char *)&v132 + 6);
          v31 = (v34 >> 31) | 2 * v123;
          v33 *= 2;
          v32 += 65535;
          *(_DWORD *)((char *)&v132 + 2) = v33;
          v123 = v31;
          v134 = v31;
        }
        while ( (_WORD)v32 > 0 );
        if ( (_WORD)v32 > 0 )
          goto LABEL_194;
      }
      v32 += 65535;
      if ( (_WORD)v32 >= 0 )
        goto LABEL_194;
      v35 = v123;
      v37 = (unsigned __int16)-(_WORD)v32;
      v113 = v37 + v32;
      v36 = v95;
      v110 = v37;
      do
      {
        if ( BYTE2(v132) & 1 )
          ++v36;
        v38 = (v35 << 31) | (*(_DWORD *)((char *)&v132 + 6) >> 1);
        v35 >>= 1;
        v33 = (*(_DWORD *)((char *)&v132 + 6) << 31) | ((unsigned int)v33 >> 1);
        v39 = v110-- == 1;
        v134 = v35;
        *(_DWORD *)((char *)&v132 + 6) = v38;
        *(_DWORD *)((char *)&v132 + 2) = v33;
      }
      while ( !v39 );
      v123 = v35;
      v40 = v36 == 0;
      v32 = v113;
      v11 = 0;
      if ( v40 )
      {
LABEL_194:
        v41 = WORD1(v132);
      }
      else
      {
        v41 = v33 | 1;
        WORD1(v132) = v33 | 1;
        v33 = *(_DWORD *)((char *)&v132 + 2);
      }
      if ( v41 > 0x8000u || (v33 & 0x1FFFF) == 98304 )
      {
        if ( HIDWORD(v132) == -1 )
        {
          HIDWORD(v132) = v11;
          if ( v133 == -1 )
          {
            v133 = v11;
            if ( HIWORD(v134) == -1 )
            {
              HIWORD(v134) = -32768;
              ++v32;
            }
            else
            {
              v134 += 65536;
            }
          }
          else
          {
            *(__int64 *)((char *)&v132 + 4) += 4294967296i64;
          }
          v42 = v134;
LABEL_82:
          if ( (_WORD)v32 < 0x7FFFu )
          {
            LOWORD(v130) = WORD2(v132);
            *(_DWORD *)((char *)&v130 + 2) = *(_DWORD *)((char *)&v132 + 6);
            v14 = LODWORD(v130);
            *(_DWORD *)((char *)&v130 + 6) = v42;
            v13 = DWORD1(v130);
            v131 = v99 | v32;
LABEL_86:
            v121 = v14;
            goto LABEL_87;
          }
          goto LABEL_84;
        }
        v132 += 4294967296i64;
      }
      v42 = v123;
      goto LABEL_82;
    }
  }
  v13 = DWORD1(v130);
  v14 = LODWORD(v130);
LABEL_91:
  v43 = *((_DWORD *)&v130 + 2) >> 16;
  if ( (unsigned __int16)(*((_DWORD *)&v130 + 2) >> 16) >= 0x3FFFu )
  {
    ++v116;
    v108 = (v43 ^ HIWORD(v129)) & 0x8000;
    v96 = HIWORD(v129) & 0x7FFF;
    v44 = (unsigned __int16)((v43 & 0x7FFF) + (HIWORD(v129) & 0x7FFF));
    v93 = v11;
    *(_DWORD *)((char *)&v132 + 2) = v11;
    *(_DWORD *)((char *)&v132 + 6) = v11;
    v134 = v11;
    v114 = (unsigned __int16)((v43 & 0x7FFF) + (HIWORD(v129) & 0x7FFF));
    if ( (v43 & 0x7FFFu) >= 0x7FFF || v96 >= 0x7FFFu || (_WORD)v44 > 0xBFFDu )
    {
LABEL_144:
      *((_DWORD *)&v130 + 2) = (((v108 == 0) - 1) & 0x80000000) + 2147450880;
      goto LABEL_145;
    }
    if ( (_WORD)v44 <= 0x3FBFu )
      goto LABEL_195;
    if ( !(v43 & 0x7FFF) )
    {
      ++v44;
      v114 = v44;
      if ( !(*((_DWORD *)&v130 + 2) & 0x7FFFFFFF) )
      {
        if ( !v13 && !v14 )
        {
          v131 = 0;
          goto LABEL_146;
        }
      }
    }
    if ( !v96 )
    {
      v114 = v44 + 1;
      if ( !(v129 & 0x7FFFFFFF) )
      {
        if ( !v128 && !v127 )
        {
LABEL_195:
          *((_DWORD *)&v130 + 2) = v11;
LABEL_145:
          v14 = v11;
          v13 = v11;
          goto LABEL_146;
        }
      }
    }
    v46 = v11;
    v111 = v11;
    v47 = (char *)&v132 + 6;
    v45 = 5;
    do
    {
      v48 = v45;
      if ( v45 > 0 )
      {
        v49 = (int)&v129;
        v50 = (int)((char *)&v130 + 2 * v46);
        v97 = &v129;
        v105 = (char *)&v130 + 2 * v46;
        do
        {
          v51 = *(_WORD *)v50 * *(_WORD *)v49;
          v53 = *((_DWORD *)v47 - 1);
          v52 = v53 + v51;
          if ( v53 + v51 >= v53 && v52 >= (unsigned int)v51 )
            v54 = v11;
          else
            v54 = 1;
          *((_DWORD *)v47 - 1) = v52;
          if ( v54 )
            ++*(_WORD *)v47;
          v50 = (int)(v105 + 2);
          v49 = (int)((char *)v97 - 2);
          --v48;
          v105 += 2;
          v97 = (int *)((char *)v97 - 2);
        }
        while ( v48 > 0 );
        v46 = v111;
        v45 = v102;
      }
      v47 += 2;
      ++v46;
      --v45;
      v111 = v46;
      v102 = v45;
    }
    while ( v45 > 0 );
    v56 = v134;
    v55 = v114 + 49154;
    if ( (signed __int16)(v114 - 16382) <= 0 )
    {
      v59 = *(_DWORD *)((char *)&v132 + 2);
    }
    else
    {
      v57 = *(_DWORD *)((char *)&v132 + 2);
      do
      {
        if ( v56 < 0 )
          break;
        v58 = *(_DWORD *)((char *)&v132 + 6);
        *(_DWORD *)((char *)&v132 + 6) = (v57 >> 31) | 2 * *(_DWORD *)((char *)&v132 + 6);
        v57 *= 2;
        v56 = (v58 >> 31) | 2 * v56;
        v55 += 65535;
        *(_DWORD *)((char *)&v132 + 2) = v57;
        v134 = v56;
      }
      while ( (_WORD)v55 > 0 );
      v59 = v57;
      v11 = 0;
      if ( (_WORD)v55 > 0 )
        goto LABEL_123;
    }
    v55 += 65535;
    if ( (_WORD)v55 < 0 )
    {
      v62 = (unsigned __int16)-(_WORD)v55;
      v115 = v62 + v55;
      v61 = v93;
      v103 = v62;
      do
      {
        if ( BYTE2(v132) & 1 )
          ++v61;
        v63 = (v56 << 31) | (*(_DWORD *)((char *)&v132 + 6) >> 1);
        v59 = (*(_DWORD *)((char *)&v132 + 6) << 31) | ((unsigned int)v59 >> 1);
        v56 = (unsigned int)v56 >> 1;
        v64 = v103-- == 1;
        *(_DWORD *)((char *)&v132 + 6) = v63;
        *(_DWORD *)((char *)&v132 + 2) = v59;
      }
      while ( !v64 );
      v65 = v61 == 0;
      v55 = v115;
      v134 = v56;
      v11 = 0;
      if ( !v65 )
      {
        v60 = v59 | 1;
        WORD1(v132) = v59 | 1;
        v59 = *(_DWORD *)((char *)&v132 + 2);
        goto LABEL_124;
      }
    }
LABEL_123:
    v60 = WORD1(v132);
LABEL_124:
    if ( v60 > 0x8000u || (v59 & 0x1FFFF) == 98304 )
    {
      if ( HIDWORD(v132) == -1 )
      {
        HIDWORD(v132) = v11;
        if ( v133 == -1 )
        {
          v133 = v11;
          if ( HIWORD(v134) == -1 )
          {
            HIWORD(v134) = -32768;
            ++v55;
          }
          else
          {
            v134 += 65536;
          }
        }
        else
        {
          ++v133;
        }
        v56 = v134;
      }
      else
      {
        v132 += 4294967296i64;
      }
    }
    if ( (_WORD)v55 < 0x7FFFu )
    {
      LOWORD(v130) = WORD2(v132);
      *(_DWORD *)((char *)&v130 + 2) = *(_DWORD *)((char *)&v132 + 6);
      *(_DWORD *)((char *)&v130 + 6) = v56;
      v13 = DWORD1(v130);
      v14 = LODWORD(v130);
      v131 = v108 | v55;
      goto LABEL_146;
    }
    goto LABEL_144;
  }
LABEL_146:
  v66 = a5;
  v67 = a3;
  *(_WORD *)a5 = v116;
  if ( a4 & 1 )
  {
    v67 = (signed __int16)v116 + a3;
    v117 = v67;
    if ( v67 <= 0 )
    {
      *(_WORD *)a5 = 0;
      *(_BYTE *)(a5 + 2) = (((v94 != -32768) - 1) & 0xD) + 32;
      result = 1;
      *(_BYTE *)(a5 + 3) = 1;
      *(_BYTE *)(a5 + 4) = 48;
LABEL_149:
      *(_BYTE *)(v66 + 5) = v11;
      return result;
    }
  }
  else
  {
    v117 = a3;
  }
  if ( v67 > 21 )
    v117 = 21;
  v98 = (*((_DWORD *)&v130 + 2) >> 16) - 16382;
  v131 = 0;
  v68 = *((_DWORD *)&v130 + 2);
  v69 = 8;
  do
  {
    v70 = (unsigned int)v14 >> 31;
    v14 *= 2;
    v68 = ((unsigned int)v13 >> 31) | 2 * v68;
    v13 = v70 | 2 * v13;
    LODWORD(v130) = v14;
    *((_DWORD *)&v130 + 2) = v68;
    --v69;
  }
  while ( v69 );
  v120 = v68;
  DWORD1(v130) = v13;
  v124 = v14;
  v11 = 0;
  if ( v98 < 0 )
  {
    v71 = -v98 & 0xFF;
    if ( v71 > 0 )
    {
      v72 = v120;
      do
      {
        v73 = v72 << 31;
        v72 >>= 1;
        v14 = (v13 << 31) | ((unsigned int)v14 >> 1);
        v13 = v73 | ((unsigned int)v13 >> 1);
        --v71;
        *((_DWORD *)&v130 + 2) = v72;
        LODWORD(v130) = v14;
      }
      while ( v71 > 0 );
      v120 = v72;
      DWORD1(v130) = v13;
      v124 = v14;
      v11 = 0;
    }
  }
  v76 = a5;
  v75 = a5 + 4;
  v74 = a5 + 4;
  v104 = a5 + 4;
  v106 = v117 + 1;
  if ( v117 + 1 > 0 )
  {
    while ( 1 )
    {
      v125 = LODWORD(v130);
      v126 = *(_QWORD *)((char *)&v130 + 4);
      v80 = ((unsigned int)v13 >> 31) | 2 * v120;
      v81 = (v124 >> 31) | 2 * v13;
      v77 = (2 * v124 >> 31) | 2 * v81;
      v79 = ((unsigned int)v81 >> 31) | 2 * v80;
      v78 = LODWORD(v130) + 4 * v124;
      v118 = v78;
      if ( v78 < 4 * v124 || v78 < LODWORD(v130) )
      {
        v82 = v11;
        if ( v77 + 1 < v77 || v77 + 1 < 1 )
          v82 = 1;
        v83 = v82 == 0;
        v78 = v118;
        ++v77;
        if ( !v83 )
          ++v79;
      }
      v84 = v126 + v77;
      if ( (_DWORD)v126 + v77 < v77 || v84 < (_DWORD)v126 )
        ++v79;
      v124 = 2 * v118;
      LODWORD(v130) = 2 * v118;
      v13 = (v78 >> 31) | 2 * v84;
      *((_DWORD *)&v130 + 2) = (v84 >> 31) | 2 * (HIDWORD(v126) + v79);
      *(_BYTE *)v104 = (*((_DWORD *)&v130 + 2) >> 24) + 48;
      v74 = v104 + 1;
      DWORD1(v130) = v13;
      ++v104;
      HIBYTE(v131) = v11;
      --v106;
      if ( v106 <= 0 )
        break;
      v120 = *((_DWORD *)&v130 + 2);
    }
    v76 = a5;
    v75 = a5 + 4;
  }
  v85 = *(_BYTE *)(v74 - 1);
  v86 = v74 - 2;
  if ( v85 < 53 )
  {
    while ( v86 >= (unsigned int)v75 && *(_BYTE *)v86 == 48 )
      --v86;
    if ( v86 < (unsigned int)v75 )
    {
      v66 = a5;
      *(_WORD *)a5 = 0;
      *(_BYTE *)(a5 + 2) = (((v94 != -32768) - 1) & 0xD) + 32;
      result = 1;
      *(_BYTE *)(a5 + 3) = 1;
      *(_BYTE *)v75 = 48;
      goto LABEL_149;
    }
  }
  else
  {
    while ( v86 >= (unsigned int)v75 && *(_BYTE *)v86 == 57 )
      *(_BYTE *)v86-- = 48;
    if ( v86 < (unsigned int)v75 )
    {
      ++v86;
      ++*(_WORD *)v76;
    }
    ++*(_BYTE *)v86;
  }
  v87 = v86 - (_BYTE)a5 - 3;
  *(_BYTE *)(a5 + 3) = v87;
  *(_BYTE *)(v87 + a5 + 4) = v11;
  return 1;
}
// 10074200: using guessed type int __security_cookie;

//----- (100574CB) --------------------------------------------------------
signed int __cdecl sub_100574CB(int a1)
{
  signed int result; // eax@1
  int v2; // ecx@1
  int v3; // edx@13
  int v4; // ecx@20

  v2 = a1;
  result = 0;
  if ( a1 & 0x10 )
    result = 128;
  if ( a1 & 8 )
    result |= 0x200u;
  if ( a1 & 4 )
    result |= 0x400u;
  if ( a1 & 2 )
    result |= 0x800u;
  if ( a1 & 1 )
    result |= 0x1000u;
  if ( v2 & 0x80000 )
    result |= 0x100u;
  v3 = a1 & 0x300;
  if ( a1 & 0x300 )
  {
    switch ( v3 )
    {
      case 256:
        result |= 0x2000u;
        break;
      case 512:
        result |= 0x4000u;
        break;
      case 768:
        result |= 0x6000u;
        break;
    }
  }
  v4 = a1 & 0x3000000;
  if ( (a1 & 0x3000000) == 16777216 )
  {
    result |= 0x8040u;
  }
  else
  {
    if ( v4 == 33554432 )
    {
      result |= 0x40u;
    }
    else
    {
      if ( v4 == 50331648 )
        result |= 0x8000u;
    }
  }
  return result;
}

//----- (10057574) --------------------------------------------------------
int __cdecl sub_10057574(int a1, int a2)
{
  signed int v2; // ecx@1
  char v3; // ST1C_1@1
  char v4; // ST1C_1@3
  char v5; // ST1C_1@5
  char v6; // ST1C_1@7
  char v7; // ST1C_1@9
  char v8; // ST1C_1@11
  int v9; // edx@13
  __int16 v10; // ST1C_2@13
  __int16 v11; // ST1C_2@20
  __int16 v12; // ST1C_2@21
  signed int v13; // edx@24
  __int16 v14; // ST1C_2@24
  int v15; // esi@26
  __int16 v16; // ax@27
  int v17; // ecx@39
  signed int v18; // ecx@53
  int v19; // edx@65
  int v20; // eax@78
  int v21; // eax@79
  int v22; // edx@91
  int v23; // ecx@104
  int v24; // eax@104
  int result; // eax@106
  int v26; // [sp+0h] [bp-Ch]@53
  int v27; // [sp+18h] [bp+Ch]@79

  v2 = 0;
  if ( v3 & 1 )
    v2 = 16;
  if ( v4 & 4 )
    v2 |= 8u;
  if ( v5 & 8 )
    v2 |= 4u;
  if ( v6 & 0x10 )
    v2 |= 2u;
  if ( v7 & 0x20 )
    v2 |= 1u;
  if ( v8 & 2 )
    v2 |= 0x80000u;
  v9 = v10 & 0xC00;
  if ( v10 & 0xC00 )
  {
    switch ( v9 )
    {
      case 1024:
        v2 |= 0x100u;
        break;
      case 2048:
        v2 |= 0x200u;
        break;
      case 3072:
        v2 |= 0x300u;
        break;
    }
  }
  if ( v11 & 0x300 )
  {
    if ( (v12 & 0x300) == 512 )
      v2 |= 0x10000u;
  }
  else
  {
    v2 |= 0x20000u;
  }
  v13 = 4096;
  if ( v14 & 0x1000 )
    v2 |= 0x40000u;
  v15 = a2 & a1 | v2 & ~a2;
  if ( v15 != v2 )
  {
    v16 = sub_10057874(a2 & a1 | v2 & ~a2);
    v15 = 0;
    if ( v16 & 1 )
      v15 = 16;
    if ( v16 & 4 )
      v15 |= 8u;
    if ( v16 & 8 )
      v15 |= 4u;
    if ( v16 & 0x10 )
      v15 |= 2u;
    if ( v16 & 0x20 )
      v15 |= 1u;
    if ( v16 & 2 )
      v15 |= 0x80000u;
    v17 = v16 & 0xC00;
    if ( v16 & 0xC00 )
    {
      switch ( v17 )
      {
        case 1024:
          v15 |= 0x100u;
          break;
        case 2048:
          v15 |= 0x200u;
          break;
        case 3072:
          v15 |= 0x300u;
          break;
      }
    }
    if ( v16 & 0x300 )
    {
      if ( (v16 & 0x300) == 512 )
        v15 |= 0x10000u;
    }
    else
    {
      v15 |= 0x20000u;
    }
    v13 = 4096;
    if ( v16 & 0x1000 )
      v15 |= 0x40000u;
  }
  if ( dword_1007689C < 1 )
  {
    result = v15;
  }
  else
  {
    __asm { stmxcsr [ebp+var_C] }
    v18 = 0;
    if ( (_BYTE)v26 < 0 )
      v18 = 16;
    if ( v26 & 0x200 )
      v18 |= 8u;
    if ( v26 & 0x400 )
      v18 |= 4u;
    if ( v26 & 0x800 )
      v18 |= 2u;
    if ( v26 & v13 )
      v18 |= 1u;
    if ( v26 & 0x100 )
      v18 |= 0x80000u;
    v19 = v26 & 0x6000;
    if ( v26 & 0x6000 )
    {
      switch ( v19 )
      {
        case 8192:
          v18 |= 0x100u;
          break;
        case 16384:
          v18 |= 0x200u;
          break;
        case 24576:
          v18 |= 0x300u;
          break;
      }
    }
    switch ( v26 & 0x8040 )
    {
      case 0x40:
        v18 |= 0x2000000u;
        break;
      case 0x8000:
        v18 |= 0x3000000u;
        break;
      case 0x8040:
        v18 |= 0x1000000u;
        break;
    }
    v20 = a1 & a2 & 0x308031F | v18 & ~(a2 & 0x308031F);
    if ( v20 != v18 )
    {
      v21 = sub_100574CB(v20);
      sub_10049F07(v21);
      __asm { stmxcsr [ebp+arg_4] }
      v18 = 0;
      if ( (_BYTE)v27 < 0 )
        v18 = 16;
      if ( v27 & 0x200 )
        v18 |= 8u;
      if ( v27 & 0x400 )
        v18 |= 4u;
      if ( v27 & 0x800 )
        v18 |= 2u;
      if ( v27 & 0x1000 )
        v18 |= 1u;
      if ( v27 & 0x100 )
        v18 |= 0x80000u;
      v22 = v27 & 0x6000;
      if ( v27 & 0x6000 )
      {
        switch ( v22 )
        {
          case 8192:
            v18 |= 0x100u;
            break;
          case 16384:
            v18 |= 0x200u;
            break;
          case 24576:
            v18 |= 0x300u;
            break;
        }
      }
      switch ( v27 & 0x8040 )
      {
        case 0x40:
          v18 |= 0x2000000u;
          break;
        case 0x8000:
          v18 |= 0x3000000u;
          break;
        case 0x8040:
          v18 |= 0x1000000u;
          break;
      }
    }
    v24 = v15 ^ v18;
    v23 = v15 | v18;
    if ( v24 & 0x8031F )
      v23 |= 0x80000000u;
    result = v23;
  }
  return result;
}
// 1007689C: using guessed type int dword_1007689C;

//----- (10057874) --------------------------------------------------------
signed int __cdecl sub_10057874(int a1)
{
  signed int result; // eax@1
  int v2; // ecx@1
  int v3; // edx@13
  int v4; // edx@20
  int v5; // edx@20

  v2 = a1;
  result = 0;
  if ( a1 & 0x10 )
    result = 1;
  if ( a1 & 8 )
    result |= 4u;
  if ( a1 & 4 )
    result |= 8u;
  if ( a1 & 2 )
    result |= 0x10u;
  if ( a1 & 1 )
    result |= 0x20u;
  if ( v2 & 0x80000 )
    result |= 2u;
  v3 = a1 & 0x300;
  if ( a1 & 0x300 )
  {
    switch ( v3 )
    {
      case 256:
        result |= 0x400u;
        break;
      case 512:
        result |= 0x800u;
        break;
      case 768:
        result |= 0xC00u;
        break;
    }
  }
  v5 = a1;
  v4 = v5 & 0x30000;
  if ( v4 )
  {
    if ( v4 == 65536 )
      result |= 0x200u;
  }
  else
  {
    result |= 0x300u;
  }
  if ( v2 & 0x40000 )
    result |= 0x1000u;
  return result;
}

//----- (1005790B) --------------------------------------------------------
signed int __usercall sub_1005790B<eax>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  int v5; // ebx@3
  int v6; // eax@4
  int v7; // edx@4
  int v8; // ecx@4
  int v9; // esi@4
  int v10; // ST10_4@4
  bool v11; // eax@6
  void *v12; // edi@6
  int v13; // ST10_4@7
  int v14; // eax@16
  int v15; // edx@16
  int v16; // eax@18
  int v17; // eax@21
  int v18; // edx@21
  unsigned int v19; // esi@21
  int v20; // edx@23
  int v21; // edi@24
  int v22; // eax@28
  const CHAR *v23; // esi@39
  int v24; // eax@39
  int v25; // ST0C_4@39
  int v26; // eax@40
  int v27; // ecx@41
  int v28; // [sp-Ch] [bp-1Ch]@16
  int v29; // [sp-Ch] [bp-1Ch]@21
  int v30; // [sp-Ch] [bp-1Ch]@23
  int v31; // [sp+4h] [bp-Ch]@4
  signed int v32; // [sp+8h] [bp-8h]@1
  bool v33; // [sp+Ch] [bp-4h]@6

  v32 = 0;
  if ( !a3 )
  {
    *(_DWORD *)sub_10037669(a1) = 22;
    sub_1003A16E(a1, a2);
    return -1;
  }
  v5 = *(_DWORD *)a3;
  if ( !*(_DWORD *)a3 || (v6 = sub_100589B4(v5, a2, v5, 61), v9 = v6, v8 = v10, v31 = v6, !v6) || v5 == v6 )
    goto LABEL_12;
  v12 = dword_1007698C;
  v11 = *(_BYTE *)(v6 + 1) == 0;
  v33 = *(_BYTE *)(v9 + 1) == 0;
  if ( dword_1007698C == (LPVOID)dword_10076978 )
  {
    v12 = (void *)sub_10057B51(v5, (int *)dword_1007698C);
    v11 = v33;
    v8 = v13;
    dword_1007698C = v12;
  }
  if ( !v12 )
  {
    if ( a4 && dword_10076990 != v12 )
    {
      if ( sub_1005391E(v5) )
      {
LABEL_12:
        *(_DWORD *)sub_10037669(v5) = 22;
        return -1;
      }
    }
    else
    {
      if ( v11 )
        return 0;
      v14 = sub_10037550(v7, v8, v5, 4);
      dword_1007698C = (LPVOID)v14;
      if ( !v14 )
        return -1;
      *(_DWORD *)v14 = 0;
      if ( !dword_10076990 )
      {
        v16 = sub_10037550(v15, v28, v5, 4);
        dword_10076990 = (LPVOID)v16;
        if ( !v16 )
          return -1;
        *(_DWORD *)v16 = 0;
      }
    }
    v12 = dword_1007698C;
    if ( !dword_1007698C )
      return -1;
  }
  v17 = sub_10057BB1(v5, v5, v9 - v5);
  v19 = v17;
  if ( v17 < 0 || !*(_DWORD *)v12 )
  {
    if ( !v33 )
    {
      if ( v17 < 0 )
        v19 = -v17;
      if ( __SETO__(v19 + 2, v19)
        || v19 + 2 >= 0x3FFFFFFF
        || (v22 = sub_100375E5(v18, v29, v5, dword_1007698C, 4u, v19 + 2), !v22) )
        return -1;
      v21 = a3;
      *(_DWORD *)(v22 + 4 * v19 + 4) = 0;
      *(_DWORD *)(v22 + 4 * v19) = v5;
      *(_DWORD *)a3 = 0;
      goto LABEL_29;
    }
    sub_100309A2(v5, (LPVOID)v5);
    *(_DWORD *)a3 = 0;
    return 0;
  }
  sub_100309A2(v5, *((LPVOID *)v12 + v17));
  if ( !v33 )
  {
    *((_DWORD *)v12 + v19) = v5;
    v21 = a3;
    *(_DWORD *)a3 = 0;
    goto LABEL_38;
  }
  while ( *((_DWORD *)v12 + v19) )
  {
    *((_DWORD *)v12 + v19) = *((_DWORD *)v12 + v19 + 1);
    ++v19;
  }
  if ( v19 >= 0x3FFFFFFF )
  {
    v21 = a3;
    goto LABEL_38;
  }
  v22 = sub_100375E5(v20, v30, v5, dword_1007698C, v19, 4u);
  v21 = a3;
  if ( v22 )
LABEL_29:
    dword_1007698C = (LPVOID)v22;
LABEL_38:
  if ( a4 )
  {
    v24 = sub_10035550(v5);
    v23 = (const CHAR *)sub_10037506(v25, v5, v24 + 2, 1u);
    if ( v23 )
    {
      v26 = sub_10035550(v5);
      if ( sub_1003ADE5(v5, v21, (int)v23, v26 + 2, v5) )
      {
        sub_1003A17E(v5, v21);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_10057B51);
      }
      v27 = (int)(&v23[v31] - v5);
      *(_BYTE *)v27 = 0;
      if ( !SetEnvironmentVariableA(v23, (LPCSTR)(v33 == 0 ? v27 + 1 : 0)) )
      {
        v32 = -1;
        *(_DWORD *)sub_10037669(v5) = 42;
      }
      sub_100309A2(v5, (LPVOID)v23);
    }
  }
  if ( v33 )
  {
    sub_100309A2(v5, (LPVOID)v5);
    *(_DWORD *)v21 = 0;
  }
  return v32;
}
// 10076978: using guessed type int dword_10076978;

//----- (10057B51) --------------------------------------------------------
int __usercall sub_10057B51<eax>(int a1<ebx>, int *a2)
{
  int result; // eax@1
  int v3; // ecx@1
  int v4; // edx@4
  int v5; // ebx@4
  int v6; // edi@4
  int v7; // eax@6
  int v8; // esi@7
  int v9; // [sp-Ch] [bp-10h]@4

  v3 = 0;
  result = (int)a2;
  if ( a2 )
  {
    if ( *a2 )
    {
      do
      {
        result += 4;
        ++v3;
      }
      while ( *(_DWORD *)result );
    }
    v6 = (int)sub_10037506(v3, a1, v3 + 1, 4u);
    v5 = v6;
    if ( !v6 )
      sub_1003AF92(v4, v9, v6, 0, 9);
    v7 = *a2;
    if ( *a2 )
    {
      v8 = (int)((char *)a2 - v6);
      do
      {
        *(_DWORD *)v6 = sub_10058964(v5, v7);
        v6 += 4;
        v7 = *(_DWORD *)(v8 + v6);
      }
      while ( v7 );
    }
    *(_DWORD *)v6 = 0;
    result = v5;
  }
  return result;
}

//----- (10057BB1) --------------------------------------------------------
int __usercall sub_10057BB1<eax>(int a1<ebx>, int a2, int a3)
{
  int v3; // eax@1
  LPVOID v4; // ecx@1
  LPVOID v5; // esi@1
  char v6; // al@3
  int v7; // esi@7

  v4 = dword_1007698C;
  v5 = dword_1007698C;
  v3 = *(_DWORD *)dword_1007698C;
  if ( *(_DWORD *)dword_1007698C )
  {
    while ( 1 )
    {
      if ( !sub_100539AB(a1, a3, a2, v3, a3) )
      {
        v6 = *(_BYTE *)(a3 + *(_DWORD *)v5);
        if ( v6 == 61 )
          break;
        if ( !v6 )
          break;
      }
      v5 = (char *)v5 + 4;
      v3 = *(_DWORD *)v5;
      if ( !*(_DWORD *)v5 )
      {
        v4 = dword_1007698C;
        goto LABEL_7;
      }
    }
    v7 = (signed int)(v5 - dword_1007698C) >> 2;
  }
  else
  {
LABEL_7:
    v7 = -((signed int)(v5 - v4) >> 2);
  }
  return v7;
}

//----- (10057C0C) --------------------------------------------------------
signed int __usercall sub_10057C0C<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6)
{
  signed int v6; // esi@2
  int v7; // ebx@8
  int v8; // eax@10
  int v10; // [sp+Ch] [bp-10h]@1
  int v11; // [sp+14h] [bp-8h]@14
  char v12; // [sp+18h] [bp-4h]@13

  sub_1003018D((int)&v10, a1, a2, a6);
  if ( a5 )
  {
    if ( a3 && a4 )
    {
      v6 = 2147483647;
      if ( (unsigned int)a5 <= 0x7FFFFFFF )
      {
        v7 = *(_DWORD *)(v10 + 164);
        if ( v7 )
        {
          v8 = sub_1003912C(v7, v10, (int)&v10, v7, 0x1001u, a3, a5, a4, a5, *(_DWORD *)(v10 + 8));
          if ( v8 )
            v6 = v8 - 2;
          else
            *(_DWORD *)sub_10037669(v7) = 22;
        }
        else
        {
          v6 = sub_10058A64(0, v10, a3, (unsigned __int8 *)a4, a5, (int)&v10);
        }
      }
      else
      {
        *(_DWORD *)sub_10037669(a1) = 22;
        sub_1003A16E(a1, a2);
      }
    }
    else
    {
      *(_DWORD *)sub_10037669(a1) = 22;
      sub_1003A16E(a1, a2);
      v6 = 2147483647;
    }
  }
  else
  {
    v6 = 0;
  }
  if ( v12 )
    *(_DWORD *)(v11 + 112) &= 0xFFFFFFFDu;
  return v6;
}

//----- (10057CCF) --------------------------------------------------------
int __cdecl sub_10057CCF()
{
  dword_10077A94 = IsProcessorFeaturePresent(0xAu);
  return 0;
}
// 10077A94: using guessed type int dword_10077A94;

//----- (10057CE0) --------------------------------------------------------
void __usercall sub_10057CE0(int a1<ebx>, __int64 a2<st0>)
{
  double v2; // ST00_8@1

  v2 = *(double *)&a2;
  __asm { movq    xmm0, [esp+8+var_8] }
  sub_10057CFE(a1, a2);
}

//----- (10057CFE) --------------------------------------------------------
double __usercall sub_10057CFE<st0>(int a1<ebx>, __int64 a2)
{
  signed int v3; // eax@2
  double result; // st7@3
  int v7; // ecx@4
  signed int v8; // edx@4
  double v11; // ST0A_8@4
  double v12; // st7@4
  double v13; // st7@4
  double v14; // ST0A_8@4
  double v15; // ST0A_8@4
  signed int v17; // edx@7
  int v18; // eax@21
  _BYTE v19[14]; // [sp+Ah] [bp-12h]@3

  __asm
  {
    unpcklpd xmm0, xmm0
    movapd  xmm1, ds:xmmword_100679A0
    movapd  xmm6, ds:xmmword_10067980
    movapd  xmm2, ds:xmmword_100679B0
    movapd  xmm3, ds:xmmword_100679C0
    pextrw  eax, xmm0, 3
  }
  if ( (((_EAX & 0x7FFF) - 15504) | (16527 - (_EAX & 0x7FFFu))) < 0x80000000 )
  {
    __asm
    {
      mulpd   xmm1, xmm0
      addpd   xmm1, xmm6
      movapd  xmm7, xmm1
      subpd   xmm1, xmm6
      mulpd   xmm2, xmm1
      movapd  xmm4, ds:xmmword_100679D0
      mulpd   xmm3, xmm1
      movapd  xmm5, ds:xmmword_100679E0
      subpd   xmm0, xmm2
      movd    eax, xmm7
    }
    _ECX = 16 * (_EAX & 0x3F);
    v3 = _EAX >> 6;
    __asm
    {
      subpd   xmm0, xmm3
      movapd  xmm2, ds:xmmword_100679F0[ecx]
      mulpd   xmm4, xmm0
      movapd  xmm1, xmm0
      mulpd   xmm0, xmm0
      addpd   xmm5, xmm4
      mulsd   xmm0, xmm0
      addsd   xmm1, xmm2
      unpckhpd xmm2, xmm2
      movdqa  xmm6, ds:xmmword_10067960
      pand    xmm7, xmm6
      movdqa  xmm6, ds:xmmword_10067970
      paddq   xmm7, xmm6
      psllq   xmm7, 2Eh
      mulpd   xmm0, xmm5
      addsd   xmm1, xmm0
      orpd    xmm2, xmm7
      unpckhpd xmm0, xmm0
      addsd   xmm0, xmm1
    }
    if ( (unsigned int)(v3 + 894) <= 0x77C )
    {
      __asm
      {
        mulsd   xmm0, xmm2
        addsd   xmm0, xmm2
        movlpd  [esp+10h+var_12+6], xmm0
      }
      return *(double *)&v19[6];
    }
    v8 = v3;
    _EAX = v3 >> 1;
    _EDX = v8 - _EAX;
    __asm
    {
      movdqa  xmm6, ds:xmmword_10067950
      pandn   xmm6, xmm2
    }
    _EAX += 1023;
    __asm
    {
      movd    xmm3, eax
      psllq   xmm3, 34h
      orpd    xmm6, xmm3
    }
    _EDX += 1023;
    __asm
    {
      movd    xmm4, edx
      psllq   xmm4, 34h
      movlpd  [esp+12h+var_12], xmm0
    }
    v12 = v11;
    __asm { movlpd  [esp+12h+var_A], xmm6 }
    v13 = v12 * *(double *)&v19[8] + *(double *)&v19[8];
    __asm { movlpd  [esp+12h+var_12], xmm4 }
    v15 = v13 * v14;
    __asm
    {
      movlpd  xmm0, [esp+12h+var_12]
      pextrw  ecx, xmm0, 3
    }
    v7 = _ECX & 0x7FF0;
    if ( (unsigned int)v7 >= 0x7FF0 )
    {
      v17 = 14;
    }
    else
    {
      if ( v7 )
        goto LABEL_10;
      v17 = 15;
    }
LABEL_9:
    __asm { movlpd  [esp+1Ch+var_12+6], xmm0 }
    sub_10058B13(a1, (int)&a2, (int)&a2, (int)&v19[6], v17);
    __asm { movlpd  xmm0, [esp+1Ch+var_12+6] }
LABEL_10:
    __asm { movlpd  [esp+10h+var_12+6], xmm0 }
    return *(double *)&v19[6];
  }
  v18 = HIDWORD(a2) & 0x7FFFFFFF;
  if ( (HIDWORD(a2) & 0x7FFFFFFFu) >= 0x40900000 )
  {
    if ( (unsigned int)v18 < 0x7FF00000 )
    {
      if ( HIDWORD(a2) >= 0x80000000u )
      {
        __asm
        {
          movlpd  xmm0, ds:qword_10067E28
          mulsd   xmm0, xmm0
        }
        v17 = 15;
      }
      else
      {
        __asm
        {
          movlpd  xmm0, ds:qword_10067E20
          mulsd   xmm0, xmm0
        }
        v17 = 14;
      }
      goto LABEL_9;
    }
    if ( (unsigned int)v18 > 0x7FF00000 || (_DWORD)a2 )
    {
      v17 = 1002;
      goto LABEL_9;
    }
    if ( HIDWORD(a2) == 2146435072 )
      result = 1.797693134862316e308;
    else
      result = 0.0;
  }
  else
  {
    __asm
    {
      movlpd  xmm0, [esp+arg_0]
      addsd   xmm0, ds:qword_10067DF0
      movlpd  [esp+10h+var_12+6], xmm0
    }
    result = *(double *)&v19[6];
  }
  return result;
}

//----- (10057FB1) --------------------------------------------------------
double __usercall sub_10057FB1<st0>(int a1<ebp>, double result<st0>)
{
  char v2; // ch@1

  *(_BYTE *)(a1 - 144) = -2;
  sub_100580EE();
  if ( v2 )
    result = -result;
  return result;
}
// 100580EE: using guessed type int sub_100580EE(void);

//----- (100580E1) --------------------------------------------------------
double __fastcall sub_100580E1(char a1)
{
  if ( a1 )
    JUMPOUT(*(unsigned int *)loc_1004AD86);
  return 1.189731495357232e4932;
}
// 1004AD86: using guessed type int loc_1004AD86();

//----- (100580EE) --------------------------------------------------------
#error "FFFFFFFF: positive sp value has been found (funcsize=0)"

//----- (10058131) --------------------------------------------------------
double __usercall sub_10058131<st0>(double result<st0>)
{
  double v3; // st6@2

  _ST6 = result;
  __asm { frndint }
  if ( _ST6 == result )
  {
    v3 = result * 0.5;
    _ST5 = result * 0.5;
    __asm { frndint }
    _ST5 == v3;
  }
  return result;
}

//----- (100581DE) --------------------------------------------------------
void __usercall sub_100581DE(int a1<edx>, __int16 a2<cx>, __int16 a3<fpstat>, double a4<st0>, char a5, char a6, char a7)
{
  int ebp0; // ebp@0
  char v8; // ST00_1@2
  char v9; // ST04_1@2
  char v10; // ST08_1@2

  if ( !dword_10075480 )
    UNDEF(a3);
  sub_1004AC80(a1, a2, ebp0, a3, a4, v8, v9, v10);
  sub_10058263(ebp0, a4);
}
// 10075480: using guessed type int dword_10075480;

//----- (10058263) --------------------------------------------------------
double __usercall sub_10058263<st0>(int a1<ebp>, double result<st0>)
{
  char v2; // al@2
  __int16 v3; // fps@2
  __int16 v7; // ax@11
  int v8; // ebx@20

  if ( dword_10076894 )
    return result;
  UNDEF(v3);
  *(_QWORD *)(a1 - 720) = *(_QWORD *)&result;
  v2 = *(_BYTE *)(a1 - 144);
  if ( v2 )
  {
    if ( v2 == -1 )
    {
      if ( (*(_WORD *)(a1 - 714) & 0x7FF0) != 32752 )
        goto LABEL_7;
    }
    else
    {
      if ( v2 != -2 )
      {
        if ( !v2 )
          return result;
        *(_DWORD *)(a1 - 142) = v2;
        goto LABEL_20;
      }
      v7 = *(_WORD *)(a1 - 714) & 0x7FF0;
      if ( !v7 )
      {
        *(_DWORD *)(a1 - 142) = 4;
        if ( fabs(result) < 2.225073858507201e-308 )
          result = result * 0.0;
        goto LABEL_20;
      }
      if ( v7 != 32752 )
        goto LABEL_7;
    }
    *(_DWORD *)(a1 - 142) = 3;
    if ( fabs(result) > 1.797693134862316e308 )
      result = result * 1.797693134862316e308;
    goto LABEL_20;
  }
LABEL_7:
  if ( !(*(_WORD *)(a1 - 164) & 0x20) && v3 & 0x20 )
  {
    *(_DWORD *)(a1 - 142) = 8;
LABEL_20:
    v8 = *(_DWORD *)(a1 - 148) + 1;
    *(_DWORD *)(a1 - 138) = v8;
    if ( !(*(_BYTE *)(a1 - 712) & 1) )
    {
      *(_DWORD *)(a1 - 134) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 - 134 + 4) = *(_DWORD *)(a1 + 12);
      if ( *(_BYTE *)(v8 + 12) != 1 )
      {
        *(_DWORD *)(a1 - 126) = *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 - 126 + 4) = *(_DWORD *)(a1 + 20);
      }
    }
    *(_QWORD *)(a1 - 118) = *(_QWORD *)&result;
    sub_100535C7(a1, *(_BYTE *)(*(_DWORD *)(a1 - 148) + 14), a1 - 142, a1 - 164);
    result = *(double *)(a1 - 118);
  }
  return result;
}
// 10076894: using guessed type int dword_10076894;

//----- (100583AA) --------------------------------------------------------
int __usercall sub_100583AA<eax>(__int16 a1<fpstat>, char a2, char a3, char a4, double a5)
{
  int ebp0; // ebp@0
  double v7; // st7@1
  int v8; // edx@1
  __int16 v9; // cx@1
  char v10; // ST08_1@1
  char v11; // ST0C_1@1
  char v12; // ST10_1@1

  v7 = sub_100583DD(a5);
  sub_1004AC80(v8, v9, ebp0, a1, v7, v10, v11, v12);
  return sub_1005825C();
}
// 1005825C: using guessed type int sub_1005825C(void);

//----- (100583DD) --------------------------------------------------------
double __cdecl sub_100583DD(double a1)
{
  double result; // st7@2
  double v2; // ST06_8@2

  if ( (WORD3(a1) & 0x7FF0) == 32752 )
  {
    HIDWORD(v2) = *(_QWORD *)&a1 << 11 >> 32;
    LODWORD(v2) = LODWORD(a1);
    result = v2;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10058419) --------------------------------------------------------
BOOL __cdecl sub_10058419()
{
  BOOL result; // eax@1

  result = (BOOL)hConsoleOutput;
  if ( hConsoleOutput != (HANDLE)-1 )
  {
    if ( hConsoleOutput != (HANDLE)-2 )
      result = CloseHandle(hConsoleOutput);
  }
  return result;
}

//----- (10058430) --------------------------------------------------------
HANDLE __cdecl sub_10058430()
{
  HANDLE result; // eax@1

  result = CreateFileW(L"CONOUT$", 0x40000000u, 3u, 0, 3u, 0, 0);
  hConsoleOutput = result;
  return result;
}

//----- (1005844F) --------------------------------------------------------
void __usercall sub_1005844F(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  if ( a5 == -2 )
  {
    *(_DWORD *)sub_10037635(a3) = 0;
    *(_DWORD *)sub_10037669(a3) = 9;
  }
  else
  {
    if ( a5 >= 0
      && a5 < (unsigned int)dword_10077A98
      && (a3 = a5 >> 5, a4 = (a5 & 0x1F) << 6, *(_BYTE *)(dword_100770A0[a5 >> 5] + a4 + 4) & 1) )
    {
      sub_100553F4(a1, a2, a3, a5);
      if ( *(_BYTE *)(dword_100770A0[a3] + a4 + 4) & 1 )
        sub_10058519(a3, a5);
      else
        *(_DWORD *)sub_10037669(a3) = 9;
      sub_1005556D(a5);
    }
    else
    {
      *(_DWORD *)sub_10037635(a3) = 0;
      *(_DWORD *)sub_10037669(a3) = 9;
      sub_1003A16E(a3, a4);
    }
  }
}
// 100770A0: using guessed type int dword_100770A0[];
// 10077A98: using guessed type int dword_10077A98;

//----- (10058519) --------------------------------------------------------
signed int __usercall sub_10058519<eax>(int a1<ebx>, int a2)
{
  signed int v2; // esi@6
  void *v3; // eax@7
  int v4; // esi@8
  signed int result; // eax@11

  if ( sub_10055506(a1, a2, a2) == -1
    || (a2 == 1 && *(_BYTE *)(dword_100770A0[0] + 132) & 1 || a2 == 2 && *(_BYTE *)(dword_100770A0[0] + 68) & 1)
    && (v2 = sub_10055506(a1, a2, 2), sub_10055506(a1, a2, 1) == v2)
    || (v3 = (void *)sub_10055506(a1, a2, a2), CloseHandle(v3)) )
    v4 = 0;
  else
    v4 = GetLastError();
  sub_10055480(a1, a2);
  *(_BYTE *)(dword_100770A0[a2 >> 5] + ((a2 & 0x1F) << 6) + 4) = 0;
  if ( v4 )
  {
    sub_10037648(a1, v4);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100770A0: using guessed type int dword_100770A0[];

//----- (100585B3) --------------------------------------------------------
int __usercall sub_100585B3<eax>(int a1<ebx>, int a2)
{
  int result; // eax@3

  if ( *(_BYTE *)(a2 + 12) & 0x83 )
  {
    if ( *(_BYTE *)(a2 + 12) & 8 )
    {
      sub_100309A2(a1, *(LPVOID *)(a2 + 8));
      *(_DWORD *)(a2 + 12) &= 0xFFFFFBF7u;
      result = 0;
      *(_DWORD *)a2 = 0;
      *(_DWORD *)(a2 + 8) = 0;
      *(_DWORD *)(a2 + 4) = 0;
    }
  }
  return result;
}

//----- (100585E3) --------------------------------------------------------
int __cdecl sub_100585E3(unsigned __int16 a1)
{
  signed int v2; // edx@4
  unsigned __int16 v3; // cx@37

  if ( a1 < 0x30u )
    return -1;
  if ( a1 < 0x3Au )
    return a1 - 48;
  v2 = 65296;
  if ( a1 >= 0xFF10u )
  {
    v3 = -230;
LABEL_39:
    if ( a1 < v3 )
      return a1 - v2;
    return -1;
  }
  v2 = 1632;
  if ( a1 >= 0x660u )
  {
    if ( a1 < 0x66Au )
      return a1 - v2;
    v2 = 1776;
    if ( a1 >= 0x6F0u )
    {
      if ( a1 < 0x6FAu )
        return a1 - v2;
      v2 = 2406;
      if ( a1 >= 0x966u )
      {
        if ( a1 < 0x970u )
          return a1 - v2;
        v2 = 2534;
        if ( a1 >= 0x9E6u )
        {
          if ( a1 < 0x9F0u )
            return a1 - v2;
          v2 = 2662;
          if ( a1 >= 0xA66u )
          {
            if ( a1 < 0xA70u )
              return a1 - v2;
            v2 = 2790;
            if ( a1 >= 0xAE6u )
            {
              if ( a1 < 0xAF0u )
                return a1 - v2;
              v2 = 2918;
              if ( a1 >= 0xB66u )
              {
                if ( a1 < 0xB70u )
                  return a1 - v2;
                v2 = 3174;
                if ( a1 >= 0xC66u )
                {
                  if ( a1 < 0xC70u )
                    return a1 - v2;
                  v2 = 3302;
                  if ( a1 >= 0xCE6u )
                  {
                    if ( a1 < 0xCF0u )
                      return a1 - v2;
                    v2 = 3430;
                    if ( a1 >= 0xD66u )
                    {
                      if ( a1 < 0xD70u )
                        return a1 - v2;
                      v2 = 3664;
                      if ( a1 >= 0xE50u )
                      {
                        if ( a1 < 0xE5Au )
                          return a1 - v2;
                        v2 = 3792;
                        if ( a1 >= 0xED0u )
                        {
                          if ( a1 < 0xEDAu )
                            return a1 - v2;
                          v2 = 3872;
                          if ( a1 >= 0xF20u )
                          {
                            if ( a1 < 0xF2Au )
                              return a1 - v2;
                            v2 = 4160;
                            if ( a1 >= 0x1040u )
                            {
                              if ( a1 < 0x104Au )
                                return a1 - v2;
                              v2 = 6112;
                              if ( a1 >= 0x17E0u )
                              {
                                if ( a1 < 0x17EAu )
                                  return a1 - v2;
                                v2 = 6160;
                                if ( a1 >= 0x1810u )
                                {
                                  v3 = 6170;
                                  goto LABEL_39;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return -1;
}

//----- (10058782) --------------------------------------------------------
int __cdecl sub_10058782(unsigned int *a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // edx@1
  int v5; // ebx@1
  unsigned int v6; // ecx@2
  int v7; // eax@3
  signed int v8; // ecx@3
  int v9; // edi@3
  unsigned int v10; // esi@3
  int v11; // esi@3
  unsigned int v12; // ecx@3
  int v13; // edx@3
  unsigned int v14; // eax@7
  signed int v15; // ecx@7
  signed int v16; // eax@12
  unsigned int v17; // ecx@12
  int v18; // eax@17
  unsigned int v19; // edi@17
  int v20; // esi@17
  int v21; // edx@17
  bool v22; // edx@19
  signed int v23; // edx@22
  int v24; // ecx@22
  int v25; // edx@30
  unsigned int v26; // esi@31
  unsigned int v27; // esi@31
  int v28; // edx@33
  unsigned int v29; // edi@34
  int v30; // esi@34
  unsigned int v31; // ecx@35
  unsigned int v32; // [sp+Ch] [bp-1Ch]@3
  int v33; // [sp+10h] [bp-18h]@3
  int v34; // [sp+14h] [bp-14h]@3
  int v35; // [sp+1Ch] [bp-Ch]@2
  int v36; // [sp+1Ch] [bp-Ch]@12
  int v37; // [sp+20h] [bp-8h]@2
  signed int v38; // [sp+24h] [bp-4h]@1
  int v39; // [sp+38h] [bp+10h]@2
  unsigned int v40; // [sp+38h] [bp+10h]@3

  v5 = a3;
  v4 = 0;
  result = 16462;
  v38 = 16462;
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 8) = 0;
  if ( a2 )
  {
    v6 = 0;
    v39 = 0;
    v37 = 0;
    v35 = 0;
    do
    {
      v32 = *(_DWORD *)v5;
      v33 = *(_DWORD *)(v5 + 4);
      v34 = *(_DWORD *)(v5 + 8);
      v11 = (v6 >> 31) | 2 * v37;
      v12 = v11;
      v10 = ((unsigned int)(2 * v39) >> 31) | 2 * v11;
      v13 = 4 * v39;
      v9 = (v12 >> 31) | 2 * (((unsigned int)v37 >> 31) | 2 * v35);
      v7 = 4 * v39 + *(_DWORD *)v5;
      v8 = 0;
      *(_DWORD *)v5 = 4 * v39;
      *(_DWORD *)(v5 + 4) = v10;
      *(_DWORD *)(v5 + 8) = v9;
      v40 = v7;
      if ( v7 < (unsigned int)v13 || v7 < v32 )
        v8 = 1;
      *(_DWORD *)v5 = v7;
      if ( v8 )
      {
        v14 = v10;
        v15 = 0;
        ++v10;
        if ( v10 < v14 || v10 < 1 )
          v15 = 1;
        *(_DWORD *)(v5 + 4) = v10;
        if ( v15 )
        {
          ++v9;
          *(_DWORD *)(v5 + 8) = v9;
        }
      }
      v16 = 0;
      v17 = v10 + v33;
      v36 = v10 + v33;
      if ( v10 + v33 < v10 || v17 < v33 )
        v16 = 1;
      *(_DWORD *)(v5 + 4) = v17;
      if ( v16 )
      {
        ++v9;
        *(_DWORD *)(v5 + 8) = v9;
      }
      v20 = (v40 >> 31) | 2 * v36;
      v18 = (v17 >> 31) | 2 * (v34 + v9);
      v21 = 2 * v40;
      *(_DWORD *)v5 = 2 * v40;
      *(_DWORD *)(v5 + 4) = v20;
      *(_DWORD *)(v5 + 8) = v18;
      v19 = *(_BYTE *)a1;
      v37 = (v40 >> 31) | 2 * v36;
      v6 = 2 * v40 + v19;
      v35 = v18;
      v39 = 2 * v40 + v19;
      v22 = v21 + v19 < v21 || v6 < v19;
      *(_DWORD *)v5 = v6;
      if ( v22 )
      {
        v24 = v20 + 1;
        v23 = 0;
        if ( v20 + 1 < (unsigned int)v20 || (unsigned int)v24 < 1 )
          v23 = 1;
        ++v20;
        *(_DWORD *)(v5 + 4) = v24;
        v6 = v39;
        v37 = v20;
        if ( v23 )
        {
          ++v18;
          v35 = v18;
          *(_DWORD *)(v5 + 8) = v18;
        }
      }
      *(_DWORD *)(v5 + 8) = v18;
      a1 = (unsigned int *)((char *)a1 + 1);
      *(_DWORD *)(v5 + 4) = v20;
      --a2;
    }
    while ( a2 );
    result = 16462;
    v4 = 0;
  }
  if ( *(_DWORD *)(v5 + 8) == v4 )
  {
    v25 = *(_DWORD *)(v5 + 4);
    do
    {
      v27 = v25;
      v25 = (*(_DWORD *)v5 >> 16) | (v25 << 16);
      v26 = v27 >> 16;
      result = v38 + 65520;
      *(_DWORD *)v5 <<= 16;
      v38 += 65520;
    }
    while ( !v26 );
    *(_DWORD *)(v5 + 4) = v25;
    *(_DWORD *)(v5 + 8) = v26;
  }
  v28 = *(_DWORD *)(v5 + 8);
  if ( !(v28 & 0x8000) )
  {
    v29 = *(_DWORD *)v5;
    v30 = *(_DWORD *)(v5 + 4);
    do
    {
      v31 = v30;
      v30 = (v29 >> 31) | 2 * v30;
      v28 = (v31 >> 31) | 2 * v28;
      result = v38 + 65535;
      v29 *= 2;
      v38 += 65535;
    }
    while ( !(v28 & 0x8000) );
    *(_DWORD *)v5 = v29;
    *(_DWORD *)(v5 + 4) = v30;
    *(_DWORD *)(v5 + 8) = v28;
  }
  *(_WORD *)(v5 + 10) = result;
  return result;
}

//----- (10058964) --------------------------------------------------------
int __usercall sub_10058964<eax>(int a1<ebx>, int a2)
{
  int result; // eax@2
  int v3; // eax@3
  int v4; // ebx@3
  int v5; // edi@3
  int v6; // eax@3
  int v7; // edx@3
  int v8; // ecx@3

  if ( a2 )
  {
    v6 = sub_10035550(a2);
    v5 = v6 + 1;
    v3 = sub_10030910(v7, v8, a1, v6 + 1, v6 + 1);
    v4 = v3;
    if ( v3 )
    {
      if ( sub_1003ADE5(v3, v5, v3, v5, a2) )
      {
        sub_1003A17E(v4, v5);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_100589B4);
      }
      result = v4;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100589B4) --------------------------------------------------------
int __usercall sub_100589B4<eax>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  return sub_100589C9(a1, a2, a3, a4, 0);
}

//----- (100589C9) --------------------------------------------------------
int __usercall sub_100589C9<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  int v5; // edx@1
  int v6; // esi@2
  unsigned __int16 v7; // cx@11
  char v9; // [sp+8h] [bp-10h]@1
  int v10; // [sp+Ch] [bp-Ch]@3
  int v11; // [sp+10h] [bp-8h]@15
  char v12; // [sp+14h] [bp-4h]@14

  sub_1003018D((int)&v9, a1, a2, a5);
  v5 = a3;
  if ( a3 )
  {
    v6 = 0;
    if ( *(_DWORD *)(v10 + 8) )
    {
      while ( 1 )
      {
        v7 = *(_BYTE *)v5;
        if ( !*(_BYTE *)v5 )
          break;
        if ( *(_BYTE *)((unsigned __int8)v7 + v10 + 25) & 4 )
        {
          ++v5;
          if ( !*(_BYTE *)v5 )
            goto LABEL_14;
          if ( a4 == (*(_BYTE *)v5 | (v7 << 8)) )
          {
            v6 = v5 - 1;
            goto LABEL_14;
          }
        }
        else
        {
          if ( a4 == *(_BYTE *)v5 )
            break;
        }
        ++v5;
      }
      if ( a4 == *(_BYTE *)v5 )
        v6 = v5;
    }
    else
    {
      v6 = sub_10030A50(a3, a4);
    }
  }
  else
  {
    *(_DWORD *)sub_10037669(a1) = 22;
    sub_1003A16E(a1, a2);
    v6 = 0;
  }
LABEL_14:
  if ( v12 )
    *(_DWORD *)(v11 + 112) &= 0xFFFFFFFDu;
  return v6;
}

//----- (10058A64) --------------------------------------------------------
signed int __usercall sub_10058A64<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned __int8 *a4, signed int a5, int a6)
{
  signed int v6; // esi@2
  int v7; // edi@8
  int v8; // eax@9
  int v9; // esi@9
  char v10; // zf@9
  signed int result; // eax@15
  int v12; // [sp+0h] [bp-10h]@2
  int v13; // [sp+8h] [bp-8h]@14
  char v14; // [sp+Ch] [bp-4h]@13

  if ( a5 )
  {
    sub_1003018D((int)&v12, a1, a2, a6);
    v6 = 2147483647;
    if ( a3 && (a1 = (int)a4, a4) && (unsigned int)a5 <= 0x7FFFFFFF )
    {
      if ( *(_DWORD *)(v12 + 168) )
      {
        v7 = a3 - (_DWORD)a4;
        do
        {
          v9 = sub_100398D2(a1, v7, *(_BYTE *)(v7 + a1), (int)&v12);
          v8 = sub_100398D2(a1, v7, *(_BYTE *)a1, (int)&v12);
          ++a1;
          v10 = a5-- == 1;
        }
        while ( !v10 && v9 && v9 == v8 );
        v6 = v9 - v8;
      }
      else
      {
        v6 = sub_10058FA0((unsigned __int8 *)a3, a4, a5);
      }
    }
    else
    {
      *(_DWORD *)sub_10037669(a1) = 22;
      sub_1003A16E(a1, a3);
    }
    if ( v14 )
      *(_DWORD *)(v13 + 112) &= 0xFFFFFFFDu;
    result = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10058B13) --------------------------------------------------------
int __usercall sub_10058B13<eax>(int a1<ebx>, int a2, int a3, int a4, signed int a5)
{
  void *v5; // ecx@2
  int result; // eax@4
  int v7; // esi@17
  int v8; // eax@37
  double v9; // st7@51
  int v10; // [sp+0h] [bp-28h]@15
  char v11[4]; // [sp+4h] [bp-24h]@16
  double v12; // [sp+8h] [bp-20h]@17
  double v13; // [sp+10h] [bp-18h]@17
  double v14; // [sp+18h] [bp-10h]@17
  double v15; // [sp+20h] [bp-8h]@1

  *(_QWORD *)&v15 = 0i64;
  if ( dword_100773B8 )
    v5 = DecodePointer(dword_10077A90);
  else
    v5 = sub_1002E99E;
  result = a5;
  if ( a5 <= 166 )
  {
    if ( a5 == 166 )
    {
      v10 = 3;
      *(_DWORD *)v11 = "exp10";
      goto LABEL_17;
    }
    if ( a5 > 25 )
    {
      if ( a5 == 26 )
      {
        result = a4;
        *(double *)a4 = 1.0;
        return result;
      }
      if ( a5 == 27 )
      {
        v10 = 2;
LABEL_16:
        *(_DWORD *)v11 = &unk_10065FFC;
        goto LABEL_17;
      }
      if ( a5 == 28 )
      {
LABEL_38:
        *(_DWORD *)v11 = &unk_10065FFC;
      }
      else
      {
        if ( a5 == 29 )
        {
          *(_DWORD *)v11 = &unk_10065FFC;
LABEL_37:
          v8 = a2;
          v7 = a4;
          *(double *)a4 = *(double *)a2;
LABEL_56:
          v12 = *(double *)v8;
          v13 = *(double *)a3;
          v9 = *(double *)v7;
LABEL_57:
          v14 = v9;
          v10 = 1;
          result = ((int (__cdecl *)(int *))v5)(&v10);
          if ( !result )
          {
            result = sub_10037669(a1);
            *(_DWORD *)result = 33;
          }
          goto LABEL_59;
        }
        if ( a5 == 49 )
        {
LABEL_54:
          *(_DWORD *)v11 = "sqrt";
        }
        else
        {
          if ( a5 == 58 )
          {
LABEL_35:
            *(_DWORD *)v11 = "acos";
          }
          else
          {
            result = a5 - 61;
            if ( a5 != 61 )
              return result;
LABEL_34:
            *(_DWORD *)v11 = "asin";
          }
        }
      }
    }
    else
    {
      if ( a5 == 25 )
      {
        *(_DWORD *)v11 = &unk_10065FFC;
        goto LABEL_20;
      }
      if ( a5 == 2 )
      {
        v10 = 2;
        *(_DWORD *)v11 = &unk_10066000;
        goto LABEL_17;
      }
      if ( a5 == 3 )
      {
        *(_DWORD *)v11 = &unk_10066000;
      }
      else
      {
        if ( a5 == 8 )
        {
          v10 = 2;
          *(_DWORD *)v11 = "log10";
          goto LABEL_17;
        }
        if ( a5 != 9 )
        {
          if ( a5 != 14 )
          {
            if ( a5 != 15 )
            {
              result = a5 - 24;
              if ( a5 != 24 )
                return result;
              v10 = 3;
              goto LABEL_16;
            }
            *(_DWORD *)v11 = &unk_10065FF8;
LABEL_20:
            v7 = a4;
            v12 = *(double *)a2;
            v10 = 4;
            v13 = *(double *)a3;
            v14 = *(double *)a4;
            result = ((int (__cdecl *)(int *))v5)(&v10);
LABEL_59:
            *(_QWORD *)v7 = *(_QWORD *)&v14;
            return result;
          }
          v10 = 3;
          *(_DWORD *)v11 = &unk_10065FF8;
LABEL_17:
          v7 = a4;
          v12 = *(double *)a2;
          v13 = *(double *)a3;
          v14 = *(double *)a4;
          result = ((int (__cdecl *)(_DWORD))v5)(&v10);
          if ( !result )
          {
            result = sub_10037669(a1);
            *(_DWORD *)result = 34;
          }
          goto LABEL_59;
        }
        *(_DWORD *)v11 = "log10";
      }
    }
    v8 = a2;
    v7 = a4;
    goto LABEL_56;
  }
  switch ( a5 )
  {
    case 1009:
      goto LABEL_34;
    case 1008:
      goto LABEL_35;
    case 1006:
      goto LABEL_38;
    case 1000:
      *(_DWORD *)v11 = &unk_10066000;
      goto LABEL_37;
    case 1001:
      *(_DWORD *)v11 = "log10";
      goto LABEL_37;
    case 1002:
      *(_DWORD *)v11 = &unk_10065FF8;
      goto LABEL_37;
    case 1003:
      *(_DWORD *)v11 = "atan";
      goto LABEL_37;
    case 1004:
      *(_DWORD *)v11 = "ceil";
      goto LABEL_37;
    case 1005:
      *(_DWORD *)v11 = "floor";
      goto LABEL_37;
    case 1007:
      *(_DWORD *)v11 = "modf";
      goto LABEL_37;
    case 1010:
      *(_DWORD *)v11 = "sin";
      goto LABEL_51;
    case 1011:
      *(_DWORD *)v11 = "cos";
      goto LABEL_51;
    case 1012:
      *(_DWORD *)v11 = "tan";
LABEL_51:
      v7 = a4;
      v9 = *(double *)a2 * v15;
      *(_QWORD *)a4 = *(_QWORD *)&v9;
      v12 = *(double *)a2;
      v13 = *(double *)a3;
      goto LABEL_57;
    case 1013:
      goto LABEL_54;
    default:
      return result;
  }
  return result;
}
// 100773B8: using guessed type int dword_100773B8;

//----- (10058DFB) --------------------------------------------------------
signed int __cdecl sub_10058DFB(double a1)
{
  signed int result; // eax@4

  if ( sub_1004961B(a1) & 0x90 || a1 != sub_10059001(a1) )
  {
    result = 0;
  }
  else
  {
    if ( a1 * 0.5 == sub_10059001(a1 * 0.5) )
      result = 2;
    else
      result = 1;
  }
  return result;
}

//----- (10058E61) --------------------------------------------------------
signed int __cdecl sub_10058E61(long double a1, double a2, int a3)
{
  int v3; // esi@1
  long double v4; // st7@1
  double v5; // st7@4
  int v6; // eax@5
  unsigned __int8 v7; // c0@5
  unsigned __int8 v8; // c3@5
  int v9; // ecx@21

  v4 = fabs(a1);
  v3 = 0;
  if ( HIDWORD(a2) == 2146435072 )
  {
    if ( !LODWORD(a2) )
    {
      if ( v4 <= 1.0 )
      {
        v7 = 1.0 < v4;
        v8 = 1.0 == v4;
        v5 = 1.0;
        v6 = a3;
        if ( !(v7 | v8) )
          v5 = 0.0;
        goto LABEL_28;
      }
      goto LABEL_4;
    }
  }
  else
  {
    if ( HIDWORD(a2) == -1048576 && !LODWORD(a2) )
    {
      if ( v4 > 1.0 )
      {
        v5 = 0.0;
        goto LABEL_27;
      }
      v6 = a3;
      if ( v4 < 1.0 )
      {
        v5 = dbl_100750A0;
LABEL_28:
        *(_QWORD *)v6 = *(_QWORD *)&v5;
        return v3;
      }
      *(_QWORD *)a3 = *(_QWORD *)&dbl_100750A8;
      return 1;
    }
  }
  if ( HIDWORD(a1) == 2146435072 )
  {
    if ( !LODWORD(a1) )
    {
      v5 = 0.0;
      if ( a2 <= 0.0 )
      {
        v6 = a3;
        if ( a2 >= 0.0 )
          v5 = 1.0;
        goto LABEL_28;
      }
LABEL_4:
      v5 = dbl_100750A0;
LABEL_27:
      v6 = a3;
      goto LABEL_28;
    }
  }
  else
  {
    if ( HIDWORD(a1) == -1048576 && !LODWORD(a1) )
    {
      v5 = 0.0;
      v9 = sub_10058DFB(a2);
      if ( a2 <= 0.0 )
      {
        if ( a2 >= 0.0 )
        {
          *(double *)a3 = 1.0;
          return v3;
        }
        if ( v9 == 1 )
          v5 = dbl_100750C0;
      }
      else
      {
        v5 = dbl_100750A0;
        if ( v9 == 1 )
          v5 = -dbl_100750A0;
      }
      goto LABEL_27;
    }
  }
  return v3;
}
// 100750A0: using guessed type double dbl_100750A0;
// 100750A8: using guessed type double dbl_100750A8;
// 100750C0: using guessed type double dbl_100750C0;

//----- (10058FA0) --------------------------------------------------------
signed int __cdecl sub_10058FA0(unsigned __int8 *a1, unsigned __int8 *a2, signed int a3)
{
  signed int v3; // ecx@1
  unsigned __int8 *v4; // edi@2
  unsigned __int8 *v5; // esi@2
  unsigned __int8 v6; // al@3
  unsigned __int8 v7; // ah@3
  char v8; // cf@11

  v3 = a3;
  if ( a3 )
  {
    v5 = a1;
    v4 = a2;
    do
    {
      v7 = *v5;
      v6 = *v4;
      if ( !*v5 || !v6 )
        break;
      ++v5;
      ++v4;
      if ( v7 >= 0x41u )
      {
        if ( v7 <= 0x5Au )
          v7 += 32;
      }
      if ( v6 >= 0x41u )
      {
        if ( v6 <= 0x5Au )
          v6 += 32;
      }
      v8 = v7 < v6;
      if ( v7 != v6 )
        goto LABEL_14;
      --v3;
    }
    while ( v3 );
    v3 = 0;
    v8 = v7 < v6;
    if ( v7 == v6 )
      return v3;
LABEL_14:
    v3 = -1;
    if ( !v8 )
      v3 = 1;
  }
  return v3;
}

//----- (10059001) --------------------------------------------------------
double __cdecl sub_10059001(double a1)
{
  double result; // st7@1

  _ST7 = a1;
  __asm { frndint }
  return result;
}

//----- (10059020) --------------------------------------------------------
double __usercall sub_10059020<st0>(__int16 a1<cx>, int a2<ebx>, double a3)
{
  char v3; // zf@2
  int v4; // ST2C_4@2
  int v5; // eax@2
  char v6; // ST28_1@3
  unsigned __int8 v8; // pf@7
  double result; // st7@8
  int v14; // ebx@17
  signed int v15; // eax@18
  __int16 v16; // cx@24
  char v17; // [sp-8h] [bp-30h]@23
  signed int v18; // [sp-4h] [bp-2Ch]@23
  __int64 v19; // [sp+0h] [bp-28h]@23
  __int16 v20; // [sp+10h] [bp-18h]@18

  if ( !dword_10077A94 )
    goto LABEL_31;
  __asm { stmxcsr [esp+8+var_4] }
  v5 = v4 & 0x7F80;
  v3 = v5 == 8064;
  if ( v5 == 8064 )
    v3 = (v6 & 0x7F) == 127;
  if ( v3 )
  {
    __asm
    {
      movq    xmm0, [esp+arg_0]
      movapd  xmm2, ds:xmmword_100695D0
      movapd  xmm1, xmm0
      movapd  xmm7, xmm0
      psrlq   xmm0, 34h
      movd    eax, xmm0
      andpd   xmm0, ds:xmmword_10069600
      psubd   xmm2, xmm0
      psrlq   xmm1, xmm2
    }
    if ( _EAX & 0x800 )
    {
      __asm
      {
        movq    xmm0, [esp+arg_0]
        psllq   xmm1, xmm2
        movapd  xmm3, xmm0
        cmpltpd xmm0, xmm1
      }
      if ( _EAX < 3071 )
      {
        __asm
        {
          cmpltpd xmm3, ds:xmmword_100695F0
          orpd    xmm3, ds:xmmword_100695F0
          andpd   xmm3, ds:xmmword_100695E0
          movq    [esp+arg_0], xmm3
        }
        return a3;
      }
      v8 = __SETP__(_EAX - 3122, 0);
      if ( _EAX <= 3122 )
      {
        __asm
        {
          andpd   xmm0, ds:xmmword_100695C0
          subsd   xmm1, xmm0
          movq    [esp+arg_0], xmm1
        }
        return a3;
      }
    }
    else
    {
      if ( _EAX < 1023 )
        return 0.0;
      __asm { psllq   xmm1, xmm2 }
      v8 = __SETP__(_EAX - 1074, 0);
      if ( _EAX <= 1074 )
      {
        __asm { movq    [esp+arg_0], xmm1 }
        return a3;
      }
    }
    __asm { ucomisd xmm7, xmm7 }
    if ( v8 )
      sub_10058B13(a2, (int)&a3, (int)&a3, (int)&a3, 1005);
    result = a3;
  }
  else
  {
LABEL_31:
    v14 = sub_10049F8C(a1);
    if ( (WORD3(a3) & 0x7FF0) == 32752 )
    {
      v15 = sub_100497B4(SLODWORD(a3), SHIDWORD(a3));
      if ( v15 > 0 )
      {
        if ( v15 <= 2 )
        {
          sub_10049F8C(v20);
          return a3;
        }
        if ( v15 == 3 )
          return sub_10049AE6(v20, v14, 11, a3);
      }
      *(double *)&v19 = a3;
      v18 = 11;
      v17 = 8;
    }
    else
    {
      result = sub_10059001(a3);
      if ( a3 == result || v14 & 0x20 )
      {
        sub_10049F8C(v16);
        return result;
      }
      *(double *)&v19 = a3;
      v18 = 11;
      v17 = 16;
    }
    result = sub_10049842(v17, v18, v19);
  }
  return result;
}
// 10059020: could not find valid save-restore pair for ebp
// 10049842: using guessed type double __cdecl sub_10049842(char, _DWORD, _DWORD);
// 10077A94: using guessed type int dword_10077A94;

//----- (10059220) --------------------------------------------------------
void __usercall sub_10059220(void *this<ecx>, int a2<ebp>)
{
  sub_10029AD2((void *)(a2 - 16));
}

//----- (10059228) --------------------------------------------------------
#error "10059234: call analysis failed (funcsize=7)"

//----- (10059243) --------------------------------------------------------
int __usercall sub_10059243<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10029FCF(a2 - 32);
}

//----- (1005924B) --------------------------------------------------------
#error "10059257: call analysis failed (funcsize=7)"

//----- (10059266) --------------------------------------------------------
int __usercall sub_10059266<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 40 + 4);
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 - 40);
  return result;
}

//----- (1005926E) --------------------------------------------------------
_DWORD *__usercall sub_1005926E<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10034913((void *)(a2 - 32));
}

//----- (10059276) --------------------------------------------------------
#error "10059282: call analysis failed (funcsize=7)"

//----- (10059291) --------------------------------------------------------
int __usercall sub_10059291<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_1002BB75((void *)(*(_DWORD *)(a2 - 16) + 4));
}

//----- (10059299) --------------------------------------------------------
int __usercall sub_10059299<eax>(int a1<ebp>)
{
  return sub_1002C0CF(a1);
}

//----- (100592A1) --------------------------------------------------------
#error "100592AD: call analysis failed (funcsize=7)"

//----- (100592BC) --------------------------------------------------------
int __thiscall sub_100592BC(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (100592CE) --------------------------------------------------------
#error "100592DA: call analysis failed (funcsize=7)"

//----- (100592E9) --------------------------------------------------------
int __thiscall sub_100592E9(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (100592F7) --------------------------------------------------------
#error "10059303: call analysis failed (funcsize=7)"

//----- (10059312) --------------------------------------------------------
int __thiscall sub_10059312(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (10059323) --------------------------------------------------------
int __thiscall sub_10059323(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (10059334) --------------------------------------------------------
#error "10059340: call analysis failed (funcsize=7)"

//----- (1005934F) --------------------------------------------------------
int __usercall sub_1005934F<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 20) + 8);
}
// 1002B6E4: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005935A) --------------------------------------------------------
#error "10059366: call analysis failed (funcsize=7)"

//----- (10059375) --------------------------------------------------------
void __cdecl sub_10059375()
{
  sub_1002B6D6();
}

//----- (1005937D) --------------------------------------------------------
#error "10059389: call analysis failed (funcsize=7)"

//----- (10059398) --------------------------------------------------------
void __usercall sub_10059398(int a1<ebx>, int a2<ebp>)
{
  int v2; // ST00_4@1

  v2 = *(_DWORD *)(a2 - 40 + 4);
  *(_DWORD *)(a2 - 40) = &off_10061A20;
  sub_1002CAA7(a1, v2);
}
// 10061A20: using guessed type int (__stdcall *off_10061A20)(char);

//----- (100593A0) --------------------------------------------------------
void __cdecl sub_100593A0()
{
  sub_1002B6D6();
}

//----- (100593A8) --------------------------------------------------------
#error "100593B4: call analysis failed (funcsize=10)"

//----- (100593CD) --------------------------------------------------------
void __cdecl sub_100593CD()
{
  sub_1002B6D6();
}

//----- (100593D5) --------------------------------------------------------
#error "100593E1: call analysis failed (funcsize=7)"

//----- (100593F0) --------------------------------------------------------
unsigned int __usercall sub_100593F0<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_1002C0B5((void *)(a2 - 60));
}

//----- (100593F8) --------------------------------------------------------
void __cdecl sub_100593F8()
{
  sub_1002B6D6();
}

//----- (10059403) --------------------------------------------------------
#error "10059412: call analysis failed (funcsize=7)"

//----- (10059421) --------------------------------------------------------
void __usercall sub_10059421(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = &off_10061930;
}
// 10061930: using guessed type int (__stdcall *off_10061930)(char);

//----- (10059429) --------------------------------------------------------
#error "10059435: call analysis failed (funcsize=7)"

//----- (10059444) --------------------------------------------------------
int __usercall sub_10059444<eax>(int a1<ebp>)
{
  return sub_1002C0CF(a1);
}

//----- (1005944F) --------------------------------------------------------
#error "1005945B: call analysis failed (funcsize=7)"

//----- (1005946A) --------------------------------------------------------
int __usercall sub_1005946A<eax>(int a1<ebp>)
{
  return sub_1002C0CF(a1);
}

//----- (10059475) --------------------------------------------------------
#error "10059481: call analysis failed (funcsize=7)"

//----- (10059490) --------------------------------------------------------
int __cdecl sub_10059490()
{
  return sub_1002BB6D();
}

//----- (10059498) --------------------------------------------------------
#error "100594A4: call analysis failed (funcsize=7)"

//----- (100594B3) --------------------------------------------------------
void __usercall sub_100594B3(int a1<ebx>, int a2<ebp>)
{
  int v2; // ST00_4@1

  v2 = *(_DWORD *)(a2 - 28 + 4);
  *(_DWORD *)(a2 - 28) = &off_10061BF4;
  sub_1002CAA7(a1, v2);
}
// 10061BF4: using guessed type int (__stdcall *off_10061BF4)(char);

//----- (100594BB) --------------------------------------------------------
#error "100594C7: call analysis failed (funcsize=10)"

//----- (100594E0) --------------------------------------------------------
int __thiscall sub_100594E0(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (100594F2) --------------------------------------------------------
#error "100594FE: call analysis failed (funcsize=7)"

//----- (1005950D) --------------------------------------------------------
#error "1005951C: call analysis failed (funcsize=7)"

//----- (1005952B) --------------------------------------------------------
#error "10059537: call analysis failed (funcsize=7)"

//----- (10059546) --------------------------------------------------------
void __usercall sub_10059546(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = off_10061BFC;
}
// 10061BFC: using guessed type int (*off_10061BFC[5])();

//----- (1005954E) --------------------------------------------------------
int __usercall sub_1005954E<eax>(int a1<ebp>)
{
  int v1; // esi@1

  v1 = *(_DWORD *)(a1 - 16) + 128;
  sub_10034867(v1);
  return sub_10030383(*(LPVOID *)(v1 + 8));
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (1005955C) --------------------------------------------------------
int __usercall sub_1005955C<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_1002E240(*(_DWORD *)(a2 - 16) + 140);
}

//----- (1005956A) --------------------------------------------------------
#error "10059576: call analysis failed (funcsize=7)"

//----- (10059585) --------------------------------------------------------
void __cdecl sub_10059585()
{
  JUMPOUT(*(unsigned int *)loc_1002CFAD);
}
// 1002CFAD: using guessed type int loc_1002CFAD();

//----- (1005958D) --------------------------------------------------------
#error "10059599: call analysis failed (funcsize=7)"

//----- (100595A8) --------------------------------------------------------
int __usercall sub_100595A8<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10034BCC(*(void **)(a2 - 16));
}

//----- (100595B0) --------------------------------------------------------
#error "100595BC: call analysis failed (funcsize=7)"

//----- (100595CB) --------------------------------------------------------
#error "100595D7: call analysis failed (funcsize=7)"

//----- (100595E6) --------------------------------------------------------
#error "100595F2: call analysis failed (funcsize=7)"

//----- (10059601) --------------------------------------------------------
#error "1005960D: call analysis failed (funcsize=7)"

//----- (1005961C) --------------------------------------------------------
void __cdecl sub_1005961C()
{
  JUMPOUT(*(unsigned int *)loc_1002F6C5);
}
// 1002F6C5: using guessed type int loc_1002F6C5();

//----- (10059624) --------------------------------------------------------
int __usercall sub_10059624<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 + 20));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005962E) --------------------------------------------------------
int __thiscall sub_1005962E(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005963C) --------------------------------------------------------
int __usercall sub_1005963C<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 20) & 1;
  if ( *(_DWORD *)(a1 - 20) & 1 )
  {
    *(_DWORD *)(a1 - 20) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_1002F6C5);
  }
  return result;
}
// 1002F6C5: using guessed type int loc_1002F6C5();

//----- (10059655) --------------------------------------------------------
void __usercall sub_10059655(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_10029440(a3 - 40, a2);
}

//----- (1005965D) --------------------------------------------------------
#error "10059669: call analysis failed (funcsize=7)"

//----- (10059678) --------------------------------------------------------
int __usercall sub_10059678<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 24));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059682) --------------------------------------------------------
void __usercall sub_10059682(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_10029440(a3 - 40, a2);
}

//----- (1005968A) --------------------------------------------------------
int __usercall sub_1005968A<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 20) & 1;
  if ( *(_DWORD *)(a1 - 20) & 1 )
  {
    *(_DWORD *)(a1 - 20) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_1002F6C5);
  }
  return result;
}
// 1002F6C5: using guessed type int loc_1002F6C5();

//----- (100596A3) --------------------------------------------------------
#error "100596AF: call analysis failed (funcsize=7)"

//----- (100596BE) --------------------------------------------------------
void __usercall sub_100596BE(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_10029440(a3 - 32, a2);
}

//----- (100596C6) --------------------------------------------------------
#error "100596D2: call analysis failed (funcsize=7)"

//----- (100596E1) --------------------------------------------------------
void __usercall sub_100596E1(int a1<ebp>)
{
  JUMPOUT(*(_DWORD *)(a1 - 20 + 4), 0, *(unsigned int *)sub_1000AA70);
}

//----- (100596E9) --------------------------------------------------------
#error "100596F5: call analysis failed (funcsize=7)"

//----- (10059704) --------------------------------------------------------
void __usercall sub_10059704(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = &off_10061E58;
}
// 10061E58: using guessed type int (__stdcall *off_10061E58)(char);

//----- (1005970C) --------------------------------------------------------
int __usercall sub_1005970C<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_10044BEC((LPVOID *)(*(_DWORD *)(a2 - 16) + 4));
}

//----- (10059717) --------------------------------------------------------
int __usercall sub_10059717<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10031850(*(_DWORD *)(a2 - 16) + 48);
}

//----- (10059722) --------------------------------------------------------
int __usercall sub_10059722<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10031850(*(_DWORD *)(a2 - 16) + 60);
}

//----- (1005972D) --------------------------------------------------------
int __usercall sub_1005972D<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10031850(*(_DWORD *)(a2 - 16) + 72);
}

//----- (10059738) --------------------------------------------------------
int __usercall sub_10059738<eax>(int a1<ebp>)
{
  return sub_10030383(*(LPVOID *)(*(_DWORD *)(a1 - 16) + 88));
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (10059743) --------------------------------------------------------
int __usercall sub_10059743<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_100317C2((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 96));
}

//----- (1005974E) --------------------------------------------------------
int __usercall sub_1005974E<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_100407DA((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 200));
}

//----- (1005975C) --------------------------------------------------------
void __usercall sub_1005975C(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_1002B6CE((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 280));
}

//----- (1005976A) --------------------------------------------------------
void __cdecl sub_1005976A()
{
  JUMPOUT(*(unsigned int *)loc_100317AF);
}
// 100317AF: using guessed type int loc_100317AF();

//----- (10059778) --------------------------------------------------------
void __cdecl sub_10059778()
{
  JUMPOUT(*(unsigned int *)loc_100317AF);
}
// 100317AF: using guessed type int loc_100317AF();

//----- (10059786) --------------------------------------------------------
#error "10059792: call analysis failed (funcsize=7)"

//----- (100597A1) --------------------------------------------------------
void __cdecl sub_100597A1()
{
  JUMPOUT(*(unsigned int *)loc_1003186E);
}
// 1003186E: using guessed type int loc_1003186E();

//----- (100597A9) --------------------------------------------------------
int __usercall sub_100597A9<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_10044BEC((LPVOID *)(*(_DWORD *)(a2 - 16) + 4));
}

//----- (100597B4) --------------------------------------------------------
int __usercall sub_100597B4<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10031850(*(_DWORD *)(a2 - 16) + 48);
}

//----- (100597BF) --------------------------------------------------------
int __usercall sub_100597BF<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10031850(*(_DWORD *)(a2 - 16) + 60);
}

//----- (100597CA) --------------------------------------------------------
int __usercall sub_100597CA<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10031850(*(_DWORD *)(a2 - 16) + 72);
}

//----- (100597D5) --------------------------------------------------------
void __cdecl sub_100597D5()
{
  JUMPOUT(*(unsigned int *)loc_1002E2AE);
}
// 1002E2AE: using guessed type int loc_1002E2AE();

//----- (100597E0) --------------------------------------------------------
int __usercall sub_100597E0<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_100317C2((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 96));
}

//----- (100597EB) --------------------------------------------------------
int __usercall sub_100597EB<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_100407DA((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 200));
}

//----- (100597F9) --------------------------------------------------------
void __usercall sub_100597F9(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_1002B6CE((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 280));
}

//----- (10059807) --------------------------------------------------------
void __cdecl sub_10059807()
{
  JUMPOUT(*(unsigned int *)loc_100317AF);
}
// 100317AF: using guessed type int loc_100317AF();

//----- (10059815) --------------------------------------------------------
void __cdecl sub_10059815()
{
  JUMPOUT(*(unsigned int *)loc_100317AF);
}
// 100317AF: using guessed type int loc_100317AF();

//----- (10059823) --------------------------------------------------------
#error "1005982F: call analysis failed (funcsize=7)"

//----- (1005983E) --------------------------------------------------------
int __usercall sub_1005983E<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 16) & 1;
  if ( *(_DWORD *)(a1 - 16) & 1 )
  {
    *(_DWORD *)(a1 - 16) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_1002E2AE);
  }
  return result;
}
// 1002E2AE: using guessed type int loc_1002E2AE();

//----- (10059857) --------------------------------------------------------
#error "10059863: call analysis failed (funcsize=7)"

//----- (10059872) --------------------------------------------------------
int __usercall sub_10059872<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 20);
  **(_DWORD **)(a1 - 20) = 0;
  return result;
}

//----- (1005987A) --------------------------------------------------------
int __usercall sub_1005987A<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_10044BEC((LPVOID *)(a2 - 16));
}

//----- (10059882) --------------------------------------------------------
#error "1005988E: call analysis failed (funcsize=7)"

//----- (1005989D) --------------------------------------------------------
#error "100598A9: call analysis failed (funcsize=7)"

//----- (100598B8) --------------------------------------------------------
int __usercall sub_100598B8<eax>(int a1<ebp>)
{
  return sub_10030383(*(LPVOID *)(a1 - 60));
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (100598C2) --------------------------------------------------------
void __cdecl sub_100598C2()
{
  JUMPOUT(*(unsigned int *)loc_1002E2AE);
}
// 1002E2AE: using guessed type int loc_1002E2AE();

//----- (100598CA) --------------------------------------------------------
int __usercall sub_100598CA<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 48));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100598D4) --------------------------------------------------------
int __usercall sub_100598D4<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 48));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100598DE) --------------------------------------------------------
#error "100598EA: call analysis failed (funcsize=7)"

//----- (100598F9) --------------------------------------------------------
int __usercall sub_100598F9<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 16));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059903) --------------------------------------------------------
int __usercall sub_10059903<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 + 8));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005990D) --------------------------------------------------------
#error "10059919: call analysis failed (funcsize=7)"

//----- (10059928) --------------------------------------------------------
#error "10059934: call analysis failed (funcsize=7)"

//----- (10059943) --------------------------------------------------------
void __usercall sub_10059943(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_1002B6CE((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 20) + 44));
}

//----- (1005994E) --------------------------------------------------------
int __usercall sub_1005994E<eax>(int a1<ebp>)
{
  return sub_1004CED6(a1);
}

//----- (10059959) --------------------------------------------------------
#error "10059965: call analysis failed (funcsize=7)"

//----- (10059974) --------------------------------------------------------
void __usercall sub_10059974(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_1002B6CE((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 44));
}

//----- (1005997F) --------------------------------------------------------
int __usercall sub_1005997F<eax>(int a1<ebp>)
{
  return sub_1004CED6(a1);
}

//----- (1005998A) --------------------------------------------------------
#error "10059996: call analysis failed (funcsize=7)"

//----- (100599A5) --------------------------------------------------------
int __usercall sub_100599A5<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 32));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100599AF) --------------------------------------------------------
#error "100599BB: call analysis failed (funcsize=10)"

//----- (100599D4) --------------------------------------------------------
int __usercall sub_100599D4<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_10044BEC((LPVOID *)(a2 + 8));
}

//----- (100599DC) --------------------------------------------------------
int __usercall sub_100599DC<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 16));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100599E6) --------------------------------------------------------
#error "100599F2: call analysis failed (funcsize=7)"

//----- (10059A01) --------------------------------------------------------
void __cdecl sub_10059A01()
{
  JUMPOUT(*(unsigned int *)loc_10030D97);
}
// 10030D97: using guessed type int loc_10030D97();

//----- (10059A09) --------------------------------------------------------
int __usercall sub_10059A09<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 20));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059A13) --------------------------------------------------------
int __usercall sub_10059A13<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 20));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059A1D) --------------------------------------------------------
#error "10059A29: call analysis failed (funcsize=7)"

//----- (10059A38) --------------------------------------------------------
void __cdecl sub_10059A38()
{
  JUMPOUT(*(unsigned int *)loc_1003B99E);
}
// 1003B99E: using guessed type int loc_1003B99E();

//----- (10059A40) --------------------------------------------------------
#error "10059A4C: call analysis failed (funcsize=7)"

//----- (10059A5B) --------------------------------------------------------
void __cdecl sub_10059A5B()
{
  JUMPOUT(*(unsigned int *)loc_1003B99E);
}
// 1003B99E: using guessed type int loc_1003B99E();

//----- (10059A63) --------------------------------------------------------
#error "10059A6F: call analysis failed (funcsize=7)"

//----- (10059A7E) --------------------------------------------------------
void __usercall sub_10059A7E(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_1002BB53(*(LPCRITICAL_SECTION *)(a2 - 16));
}

//----- (10059A86) --------------------------------------------------------
#error "10059A92: call analysis failed (funcsize=7)"

//----- (10059AA1) --------------------------------------------------------
void __cdecl sub_10059AA1()
{
  JUMPOUT(*(unsigned int *)loc_10030D97);
}
// 10030D97: using guessed type int loc_10030D97();

//----- (10059AA9) --------------------------------------------------------
#error "10059AB5: call analysis failed (funcsize=7)"

//----- (10059AC4) --------------------------------------------------------
#error "10059AD0: call analysis failed (funcsize=7)"

//----- (10059ADF) --------------------------------------------------------
int __usercall sub_10059ADF<eax>(int a1<ebp>)
{
  return sub_1002CFB7(a1);
}

//----- (10059AEA) --------------------------------------------------------
#error "10059AF9: call analysis failed (funcsize=10)"

//----- (10059B12) --------------------------------------------------------
int __usercall sub_10059B12<eax>(int a1<ebp>)
{
  return sub_1002FDDA(a1 - 24);
}

//----- (10059B1A) --------------------------------------------------------
#error "10059B26: call analysis failed (funcsize=7)"

//----- (10059B35) --------------------------------------------------------
int __usercall sub_10059B35<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10044F1A(*(_DWORD *)(a2 - 16));
}

//----- (10059B3D) --------------------------------------------------------
int __usercall sub_10059B3D<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_1002E229(*(_DWORD *)(a2 - 16) + 76);
}

//----- (10059B48) --------------------------------------------------------
#error "10059B54: call analysis failed (funcsize=7)"

//----- (10059B63) --------------------------------------------------------
void __cdecl sub_10059B63()
{
  JUMPOUT(*(unsigned int *)loc_10031923);
}
// 10031923: using guessed type int loc_10031923();

//----- (10059B6B) --------------------------------------------------------
#error "10059B77: call analysis failed (funcsize=7)"

//----- (10059B86) --------------------------------------------------------
void __cdecl sub_10059B86()
{
  JUMPOUT(*(unsigned int *)loc_10031923);
}
// 10031923: using guessed type int loc_10031923();

//----- (10059B8E) --------------------------------------------------------
#error "10059B9A: call analysis failed (funcsize=7)"

//----- (10059BA9) --------------------------------------------------------
void __cdecl sub_10059BA9()
{
  JUMPOUT(*(unsigned int *)loc_1002E2AE);
}
// 1002E2AE: using guessed type int loc_1002E2AE();

//----- (10059BB4) --------------------------------------------------------
int __usercall sub_10059BB4<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 + 16));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059BBE) --------------------------------------------------------
#error "10059BCA: call analysis failed (funcsize=7)"

//----- (10059BD9) --------------------------------------------------------
void __usercall sub_10059BD9(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = off_10061E40;
}
// 10061E40: using guessed type int (*off_10061E40[4])();

//----- (10059BE1) --------------------------------------------------------
#error "10059BED: call analysis failed (funcsize=7)"

//----- (10059BFC) --------------------------------------------------------
void __cdecl sub_10059BFC()
{
  JUMPOUT(*(unsigned int *)loc_1002E2AE);
}
// 1002E2AE: using guessed type int loc_1002E2AE();

//----- (10059C07) --------------------------------------------------------
void __cdecl sub_10059C07()
{
  JUMPOUT(*(unsigned int *)loc_1002E2AE);
}
// 1002E2AE: using guessed type int loc_1002E2AE();

//----- (10059C0F) --------------------------------------------------------
int __usercall sub_10059C0F<eax>(int a1<ebp>)
{
  return sub_100408C3(a1);
}

//----- (10059C1A) --------------------------------------------------------
int __usercall sub_10059C1A<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_1004084C((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 88));
}

//----- (10059C25) --------------------------------------------------------
int __usercall sub_10059C25<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_100407DA((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 168));
}

//----- (10059C33) --------------------------------------------------------
#error "10059C3F: call analysis failed (funcsize=7)"

//----- (10059C4E) --------------------------------------------------------
void __cdecl sub_10059C4E()
{
  JUMPOUT(*(unsigned int *)loc_1002E2AE);
}
// 1002E2AE: using guessed type int loc_1002E2AE();

//----- (10059C59) --------------------------------------------------------
#error "10059C65: call analysis failed (funcsize=7)"

//----- (10059C74) --------------------------------------------------------
void __cdecl sub_10059C74()
{
  JUMPOUT(*(unsigned int *)loc_1002E2AE);
}
// 1002E2AE: using guessed type int loc_1002E2AE();

//----- (10059C7F) --------------------------------------------------------
#error "10059C8B: call analysis failed (funcsize=7)"

//----- (10059C9A) --------------------------------------------------------
int __usercall sub_10059C9A<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 16));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059CA4) --------------------------------------------------------
#error "10059CB0: call analysis failed (funcsize=7)"

//----- (10059CBF) --------------------------------------------------------
#error "10059CCB: call analysis failed (funcsize=7)"

//----- (10059CDA) --------------------------------------------------------
int __usercall sub_10059CDA<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10044F1A(*(_DWORD *)(a2 - 16) + 12);
}

//----- (10059CE5) --------------------------------------------------------
void __cdecl sub_10059CE5()
{
  JUMPOUT(*(unsigned int *)loc_1002E2AE);
}
// 1002E2AE: using guessed type int loc_1002E2AE();

//----- (10059CF3) --------------------------------------------------------
#error "10059CFF: call analysis failed (funcsize=7)"

//----- (10059D0E) --------------------------------------------------------
void __cdecl sub_10059D0E()
{
  JUMPOUT(*(unsigned int *)loc_1002E2AE);
}
// 1002E2AE: using guessed type int loc_1002E2AE();

//----- (10059D19) --------------------------------------------------------
void __cdecl sub_10059D19()
{
  JUMPOUT(*(unsigned int *)loc_100317AF);
}
// 100317AF: using guessed type int loc_100317AF();

//----- (10059D24) --------------------------------------------------------
#error "10059D30: call analysis failed (funcsize=7)"

//----- (10059D3F) --------------------------------------------------------
int __usercall sub_10059D3F<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_1002E280((void *)(*(_DWORD *)(a2 - 16) + 4));
}

//----- (10059D4A) --------------------------------------------------------
#error "10059D56: call analysis failed (funcsize=7)"

//----- (10059D65) --------------------------------------------------------
int __cdecl sub_10059D65()
{
  return sub_1002E99E();
}

//----- (10059D6D) --------------------------------------------------------
#error "10059D79: call analysis failed (funcsize=7)"

//----- (10059D88) --------------------------------------------------------
int __usercall sub_10059D88<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 16) & 1;
  if ( *(_DWORD *)(a2 - 16) & 1 )
  {
    *(_DWORD *)(a2 - 16) &= 0xFFFFFFFEu;
    result = sub_10044BEC((LPVOID *)(a2 - 20));
  }
  return result;
}

//----- (10059DA1) --------------------------------------------------------
#error "10059DAD: call analysis failed (funcsize=7)"

//----- (10059DBC) --------------------------------------------------------
int __usercall sub_10059DBC<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_1004733D((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 16));
}

//----- (10059DC7) --------------------------------------------------------
int __usercall sub_10059DC7<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_1004733D((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 96));
}

//----- (10059DD2) --------------------------------------------------------
#error "10059DDE: call analysis failed (funcsize=7)"

//----- (10059DED) --------------------------------------------------------
int __usercall sub_10059DED<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_1004733D((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 16));
}

//----- (10059DF8) --------------------------------------------------------
#error "10059E04: call analysis failed (funcsize=7)"

//----- (10059E13) --------------------------------------------------------
int __usercall sub_10059E13<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_1002E280(*(void **)(a2 - 16));
}

//----- (10059E1B) --------------------------------------------------------
#error "10059E27: call analysis failed (funcsize=7)"

//----- (10059E36) --------------------------------------------------------
int __usercall sub_10059E36<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_1002E280(*(void **)(a2 - 16));
}

//----- (10059E3E) --------------------------------------------------------
#error "10059E4A: call analysis failed (funcsize=7)"

//----- (10059E59) --------------------------------------------------------
void __usercall sub_10059E59(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_1002B6CE((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 32));
}

//----- (10059E64) --------------------------------------------------------
int __usercall sub_10059E64<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 + 12));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059E6E) --------------------------------------------------------
#error "10059E7A: call analysis failed (funcsize=7)"

//----- (10059E89) --------------------------------------------------------
void __usercall sub_10059E89(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_1002B6CE((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 32));
}

//----- (10059E94) --------------------------------------------------------
#error "10059EA0: call analysis failed (funcsize=7)"

//----- (10059EAF) --------------------------------------------------------
void __cdecl sub_10059EAF()
{
  JUMPOUT(*(unsigned int *)loc_1003B99E);
}
// 1003B99E: using guessed type int loc_1003B99E();

//----- (10059EB7) --------------------------------------------------------
#error "10059EC3: call analysis failed (funcsize=7)"

//----- (10059ED2) --------------------------------------------------------
void __cdecl sub_10059ED2()
{
  JUMPOUT(*(unsigned int *)loc_1003B99E);
}
// 1003B99E: using guessed type int loc_1003B99E();

//----- (10059EDA) --------------------------------------------------------
#error "10059EE6: call analysis failed (funcsize=7)"

//----- (10059EF5) --------------------------------------------------------
int __usercall sub_10059EF5<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 16));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059EFF) --------------------------------------------------------
#error "10059F0B: call analysis failed (funcsize=7)"

//----- (10059F1A) --------------------------------------------------------
int __usercall sub_10059F1A<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 + 8));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059F24) --------------------------------------------------------
#error "10059F30: call analysis failed (funcsize=7)"

//----- (10059F3F) --------------------------------------------------------
void __cdecl sub_10059F3F()
{
  JUMPOUT(*(unsigned int *)loc_1003B99E);
}
// 1003B99E: using guessed type int loc_1003B99E();

//----- (10059F47) --------------------------------------------------------
#error "10059F53: call analysis failed (funcsize=7)"

//----- (10059F62) --------------------------------------------------------
void __usercall sub_10059F62(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_1002B6CE((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 12));
}

//----- (10059F6D) --------------------------------------------------------
#error "10059F79: call analysis failed (funcsize=7)"

//----- (10059F88) --------------------------------------------------------
void __usercall sub_10059F88(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_1002B6CE((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 12));
}

//----- (10059F93) --------------------------------------------------------
#error "10059F9F: call analysis failed (funcsize=7)"

//----- (10059FAE) --------------------------------------------------------
int __usercall sub_10059FAE<eax>(int a1<ebp>)
{
  return sub_10044F31(a1);
}

//----- (10059FB6) --------------------------------------------------------
#error "10059FC2: call analysis failed (funcsize=7)"

//----- (10059FE0) --------------------------------------------------------
void __usercall sub_10059FE0(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = off_10061C74;
}
// 10061C74: using guessed type int (*off_10061C74[2])();

//----- (10059FE8) --------------------------------------------------------
int __thiscall sub_10059FE8(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (10059FFC) --------------------------------------------------------
int __usercall sub_10059FFC<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_1000A960(*(_DWORD *)(a2 - 20));
}

//----- (1005A004) --------------------------------------------------------
#error "1005A010: call analysis failed (funcsize=7)"

//----- (1005A020) --------------------------------------------------------
int __usercall sub_1005A020<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10004BA0(a2 + 8);
}

//----- (1005A028) --------------------------------------------------------
void __cdecl sub_1005A028()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A030) --------------------------------------------------------
void __cdecl sub_1005A030()
{
  JUMPOUT(*(unsigned int *)loc_10009DE0);
}
// 10009DE0: using guessed type int loc_10009DE0();

//----- (1005A038) --------------------------------------------------------
int __usercall sub_1005A038<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100099A0((void *)(a2 - 20));
}

//----- (1005A040) --------------------------------------------------------
void __cdecl sub_1005A040()
{
  JUMPOUT(*(unsigned int *)loc_10009DE0);
}
// 10009DE0: using guessed type int loc_10009DE0();

//----- (1005A048) --------------------------------------------------------
int __usercall sub_1005A048<eax>(int a1<ebp>)
{
  return sub_1000A680(*(_DWORD *)(a1 - 16));
}
// 1000A680: using guessed type _DWORD __cdecl sub_1000A680(_DWORD);

//----- (1005A053) --------------------------------------------------------
void __cdecl sub_1005A053()
{
  JUMPOUT(*(unsigned int *)loc_10009DE0);
}
// 10009DE0: using guessed type int loc_10009DE0();

//----- (1005A05B) --------------------------------------------------------
#error "1005A067: call analysis failed (funcsize=7)"

//----- (1005A080) --------------------------------------------------------
int __usercall sub_1005A080<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100099A0((void *)(a2 + 8));
}

//----- (1005A088) --------------------------------------------------------
void __cdecl sub_1005A088()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A090) --------------------------------------------------------
void __cdecl sub_1005A090()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A098) --------------------------------------------------------
#error "1005A0A4: call analysis failed (funcsize=7)"

//----- (1005A0C0) --------------------------------------------------------
void __cdecl sub_1005A0C0()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005A0C8) --------------------------------------------------------
#error "1005A0D4: call analysis failed (funcsize=10)"

//----- (1005A0F0) --------------------------------------------------------
int __usercall sub_1005A0F0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 + 32, a2);
}

//----- (1005A0F8) --------------------------------------------------------
void __cdecl sub_1005A0F8()
{
  JUMPOUT(*(unsigned int *)loc_10009DE0);
}
// 10009DE0: using guessed type int loc_10009DE0();

//----- (1005A100) --------------------------------------------------------
int __usercall sub_1005A100<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(*(_DWORD *)(a3 - 28), a2);
}

//----- (1005A108) --------------------------------------------------------
int __usercall sub_1005A108<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 20) & 1;
  if ( *(_DWORD *)(a1 - 20) & 1 )
  {
    *(_DWORD *)(a1 - 20) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A121) --------------------------------------------------------
#error "1005A12D: call analysis failed (funcsize=7)"

//----- (1005A140) --------------------------------------------------------
int __usercall sub_1005A140<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100099A0((void *)(a2 + 8));
}

//----- (1005A148) --------------------------------------------------------
int __usercall sub_1005A148<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 + 36, a2);
}

//----- (1005A150) --------------------------------------------------------
void __cdecl sub_1005A150()
{
  JUMPOUT(*(unsigned int *)loc_10009DE0);
}
// 10009DE0: using guessed type int loc_10009DE0();

//----- (1005A158) --------------------------------------------------------
int __usercall sub_1005A158<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 20));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005A163) --------------------------------------------------------
void __cdecl sub_1005A163()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A16B) --------------------------------------------------------
int __usercall sub_1005A16B<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 24) & 1;
  if ( *(_DWORD *)(a1 - 24) & 1 )
  {
    *(_DWORD *)(a1 - 24) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A184) --------------------------------------------------------
#error "1005A190: call analysis failed (funcsize=7)"

//----- (1005A1A0) --------------------------------------------------------
void __cdecl sub_1005A1A0()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A1A8) --------------------------------------------------------
#error "1005A1B4: call analysis failed (funcsize=7)"

//----- (1005A1D0) --------------------------------------------------------
void __cdecl sub_1005A1D0()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A1D8) --------------------------------------------------------
#error "1005A1E4: call analysis failed (funcsize=7)"

//----- (1005A200) --------------------------------------------------------
int __thiscall sub_1005A200(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005A211) --------------------------------------------------------
void __cdecl sub_1005A211()
{
  JUMPOUT(*(unsigned int *)loc_10006150);
}
// 10006150: using guessed type int loc_10006150();

//----- (1005A219) --------------------------------------------------------
void __cdecl sub_1005A219()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005A221) --------------------------------------------------------
#error "1005A22D: call analysis failed (funcsize=7)"

//----- (1005A240) --------------------------------------------------------
#error "1005A24C: call analysis failed (funcsize=7)"

//----- (1005A260) --------------------------------------------------------
void __cdecl sub_1005A260()
{
  JUMPOUT(*(unsigned int *)loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();

//----- (1005A268) --------------------------------------------------------
#error "1005A274: call analysis failed (funcsize=10)"

//----- (1005A290) --------------------------------------------------------
void __cdecl sub_1005A290()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005A298) --------------------------------------------------------
int __usercall sub_1005A298<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 - 48);
}

//----- (1005A2A0) --------------------------------------------------------
void __cdecl sub_1005A2A0()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005A2A8) --------------------------------------------------------
#error "1005A2B4: call analysis failed (funcsize=7)"

//----- (1005A2D0) --------------------------------------------------------
void __cdecl sub_1005A2D0()
{
  JUMPOUT(*(unsigned int *)loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();

//----- (1005A2D8) --------------------------------------------------------
#error "1005A2E4: call analysis failed (funcsize=10)"

//----- (1005A300) --------------------------------------------------------
int __usercall sub_1005A300<eax>(int a1<ebp>)
{
  int result; // eax@2
  int v2; // esi@1

  v2 = a1 - 64;
  if ( *(_DWORD *)(a1 - 64 + 40) >= 0x10u )
    result = sub_1002A4AA(*(LPVOID *)(a1 - 64 + 20));
  *(_DWORD *)(v2 + 40) = 15;
  *(_DWORD *)(v2 + 36) = 0;
  *(_BYTE *)(v2 + 20) = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005A308) --------------------------------------------------------
#error "1005A314: call analysis failed (funcsize=10)"

//----- (1005A330) --------------------------------------------------------
#error "1005A33C: call analysis failed (funcsize=7)"

//----- (1005A350) --------------------------------------------------------
void __cdecl sub_1005A350()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005A358) --------------------------------------------------------
void __cdecl sub_1005A358()
{
  sub_1002B6D6();
}

//----- (1005A360) --------------------------------------------------------
#error "1005A36C: call analysis failed (funcsize=10)"

//----- (1005A390) --------------------------------------------------------
void __cdecl sub_1005A390()
{
  JUMPOUT(*(unsigned int *)loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();

//----- (1005A398) --------------------------------------------------------
void __cdecl sub_1005A398()
{
  JUMPOUT(*(unsigned int *)loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();

//----- (1005A3A0) --------------------------------------------------------
void __cdecl sub_1005A3A0()
{
  JUMPOUT(*(unsigned int *)loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();

//----- (1005A3A8) --------------------------------------------------------
void __cdecl sub_1005A3A8()
{
  JUMPOUT(*(unsigned int *)loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();

//----- (1005A3B0) --------------------------------------------------------
#error "1005A3BF: call analysis failed (funcsize=10)"

//----- (1005A3E0) --------------------------------------------------------
int __thiscall sub_1005A3E0(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005A3F1) --------------------------------------------------------
#error "1005A3FD: call analysis failed (funcsize=7)"

//----- (1005A410) --------------------------------------------------------
int __usercall sub_1005A410<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100029F0((void *)(a2 - 48));
}

//----- (1005A418) --------------------------------------------------------
#error "1005A424: call analysis failed (funcsize=10)"

//----- (1005A440) --------------------------------------------------------
void __cdecl sub_1005A440()
{
  JUMPOUT(*(unsigned int *)loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();

//----- (1005A448) --------------------------------------------------------
void __cdecl sub_1005A448()
{
  JUMPOUT(*(unsigned int *)loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();

//----- (1005A450) --------------------------------------------------------
#error "1005A45C: call analysis failed (funcsize=10)"

//----- (1005A480) --------------------------------------------------------
int __usercall sub_1005A480<eax>(int a1<ebp>)
{
  return sub_10001940(a1 + 8);
}
// 10001940: using guessed type int __thiscall sub_10001940(_DWORD);

//----- (1005A488) --------------------------------------------------------
#error "1005A494: call analysis failed (funcsize=7)"

//----- (1005A4B0) --------------------------------------------------------
int __usercall sub_1005A4B0<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 24));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005A4BB) --------------------------------------------------------
int __usercall sub_1005A4BB<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 20) & 1;
  if ( *(_DWORD *)(a1 - 20) & 1 )
  {
    *(_DWORD *)(a1 - 20) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A4D4) --------------------------------------------------------
#error "1005A4E0: call analysis failed (funcsize=7)"

//----- (1005A4F0) --------------------------------------------------------
int __usercall sub_1005A4F0<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 24));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005A4FB) --------------------------------------------------------
int __usercall sub_1005A4FB<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 20) & 1;
  if ( *(_DWORD *)(a1 - 20) & 1 )
  {
    *(_DWORD *)(a1 - 20) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A514) --------------------------------------------------------
#error "1005A520: call analysis failed (funcsize=7)"

//----- (1005A530) --------------------------------------------------------
void __cdecl sub_1005A530()
{
  JUMPOUT(*(unsigned int *)loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();

//----- (1005A538) --------------------------------------------------------
#error "1005A544: call analysis failed (funcsize=10)"

//----- (1005A560) --------------------------------------------------------
int __usercall sub_1005A560<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>)
{
  return sub_10028820(*(_DWORD *)(a4 - 56), a2, a3);
}

//----- (1005A568) --------------------------------------------------------
int __usercall sub_1005A568<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>)
{
  int v19; // ST08_4@6
  int v20; // ebx@1
  int v21; // esi@1
  int v22; // [sp-Ch] [bp-Ch]@2

  v20 = *(_DWORD *)(a4 - 56);
  v21 = *(_DWORD *)(v20 + 88);
  if ( v21 )
  {
    v22 = a3;
    _EDI = -1;
    _EDX = v21 + 4;
    _EAX = -1;
    __asm { lock xadd [edx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v21)(v21);
      _EAX = v21 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v21 + 4))(v21);
    }
    a3 = v22;
  }
  return sub_10028820(v20, v19, a3);
}

//----- (1005A570) --------------------------------------------------------
int __usercall sub_1005A570<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 56) + 92);
}

//----- (1005A57B) --------------------------------------------------------
int __usercall sub_1005A57B<eax>(int a1<ebp>)
{
  int result; // eax@2
  int v2; // esi@1

  v2 = a1 - 52;
  *(_DWORD *)(a1 - 52) = &off_100680F0;
  if ( *(_DWORD *)(a1 - 52 + 24) >= 0x10u )
    result = sub_1002A4AA(*(LPVOID *)(a1 - 52 + 4));
  *(_DWORD *)(v2 + 24) = 15;
  *(_DWORD *)(v2 + 20) = 0;
  *(_BYTE *)(v2 + 4) = 0;
  *(_DWORD *)v2 = &off_100683B4;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100680F0: using guessed type int (__stdcall *off_100680F0)(char);
// 100683B4: using guessed type int (__stdcall *off_100683B4)(char);

//----- (1005A583) --------------------------------------------------------
#error "1005A58F: call analysis failed (funcsize=10)"

//----- (1005A5B0) --------------------------------------------------------
void __cdecl sub_1005A5B0()
{
  JUMPOUT(*(unsigned int *)loc_10007AD0);
}
// 10007AD0: using guessed type int loc_10007AD0();

//----- (1005A5B8) --------------------------------------------------------
#error "1005A5C4: call analysis failed (funcsize=7)"

//----- (1005A5E0) --------------------------------------------------------
void __cdecl sub_1005A5E0()
{
  JUMPOUT(*(unsigned int *)loc_1000A390);
}
// 1000A390: using guessed type int loc_1000A390();

//----- (1005A5E8) --------------------------------------------------------
int __thiscall sub_1005A5E8(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005A5FC) --------------------------------------------------------
int __usercall sub_1005A5FC<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100034E0(*(void **)(a2 - 20));
}

//----- (1005A604) --------------------------------------------------------
int __usercall sub_1005A604<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 20) + 12);
}
// 1002B6E4: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005A60F) --------------------------------------------------------
#error "1005A61B: call analysis failed (funcsize=7)"

//----- (1005A630) --------------------------------------------------------
int __usercall sub_1005A630<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 8);
}

//----- (1005A638) --------------------------------------------------------
int __usercall sub_1005A638<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 24));
}

//----- (1005A640) --------------------------------------------------------
int __usercall sub_1005A640<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100029F0((void *)(*(_DWORD *)(a2 - 24) + 40));
}

//----- (1005A64B) --------------------------------------------------------
void __cdecl sub_1005A64B()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A656) --------------------------------------------------------
int __usercall sub_1005A656<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 64);
}

//----- (1005A65E) --------------------------------------------------------
#error "1005A66A: call analysis failed (funcsize=7)"

//----- (1005A680) --------------------------------------------------------
int __usercall sub_1005A680<eax>(int a1<ebp>)
{
  return sub_1002C0CF(a1);
}

//----- (1005A68B) --------------------------------------------------------
int __usercall sub_1005A68B<eax>(int a1<ebp>)
{
  return sub_1002C0CF(a1);
}

//----- (1005A696) --------------------------------------------------------
void __cdecl sub_1005A696()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A6A1) --------------------------------------------------------
#error "1005A6AD: call analysis failed (funcsize=7)"

//----- (1005A6C0) --------------------------------------------------------
void __cdecl sub_1005A6C0()
{
  JUMPOUT(*(unsigned int *)loc_10009DE0);
}
// 10009DE0: using guessed type int loc_10009DE0();

//----- (1005A6CB) --------------------------------------------------------
#error "1005A6D7: call analysis failed (funcsize=7)"

//----- (1005A6F0) --------------------------------------------------------
int __usercall sub_1005A6F0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>)
{
  return sub_10028820(*(_DWORD *)(a4 - 16), a2, a3);
}

//----- (1005A6F8) --------------------------------------------------------
#error "1005A704: call analysis failed (funcsize=7)"

//----- (1005A720) --------------------------------------------------------
int __usercall sub_1005A720<eax>(int a1<ebp>)
{
  int result; // eax@2
  int v14; // ecx@1
  int v15; // edi@1
  int v16; // esi@1

  v14 = *(_DWORD *)(a1 - 16);
  v16 = v14;
  *(_DWORD *)v14 = off_10068054;
  v15 = *(_DWORD *)(v14 + 24);
  if ( v15 )
  {
    _EBX = -1;
    _EDX = v15 + 4;
    _EAX = -1;
    __asm { lock xadd [edx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v15)(v15);
      result = v15 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v15 + 4))(v15);
    }
    *(_DWORD *)v16 = &off_10061E90;
  }
  else
  {
    *(_DWORD *)v14 = &off_10061E90;
  }
  return result;
}
// 10061E90: using guessed type int (__stdcall *off_10061E90)(char);
// 10068054: using guessed type int (__stdcall *off_10068054[2])(char);

//----- (1005A728) --------------------------------------------------------
int __usercall sub_1005A728<eax>(int a1<ebp>)
{
  int result; // eax@3
  int v2; // esi@1

  v2 = *(_DWORD *)(a1 - 20) + 4;
  if ( *(_DWORD *)(*(_DWORD *)(a1 - 20) + 24) >= 8u )
    sub_1002A4AA(*(LPVOID *)(*(_DWORD *)(a1 - 20) + 4));
  *(_DWORD *)(v2 + 20) = 7;
  *(_DWORD *)(v2 + 16) = 0;
  result = 0;
  *(_WORD *)v2 = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005A733) --------------------------------------------------------
#error "1005A73F: call analysis failed (funcsize=7)"

//----- (1005A750) --------------------------------------------------------
int __usercall sub_1005A750<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100034E0(*(void **)(a2 - 16));
}

//----- (1005A758) --------------------------------------------------------
int __usercall sub_1005A758<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 16) + 12);
}
// 1002B6E4: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005A763) --------------------------------------------------------
int __usercall sub_1005A763<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(*(_DWORD *)(a3 - 16) + 48, a2);
}

//----- (1005A76E) --------------------------------------------------------
void __cdecl sub_1005A76E()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A779) --------------------------------------------------------
#error "1005A785: call analysis failed (funcsize=7)"

//----- (1005A7A0) --------------------------------------------------------
int __usercall sub_1005A7A0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_1000A960(*(_DWORD *)(a2 - 16));
}

//----- (1005A7A8) --------------------------------------------------------
int __usercall sub_1005A7A8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(*(_DWORD *)(a3 - 16) + 152, a2);
}

//----- (1005A7B6) --------------------------------------------------------
#error "1005A7C2: call analysis failed (funcsize=7)"

//----- (1005A7E0) --------------------------------------------------------
int __usercall sub_1005A7E0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 16));
}

//----- (1005A7E8) --------------------------------------------------------
int __usercall sub_1005A7E8<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100029F0((void *)(*(_DWORD *)(a2 - 16) + 40));
}

//----- (1005A7F3) --------------------------------------------------------
void __cdecl sub_1005A7F3()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A7FE) --------------------------------------------------------
#error "1005A80A: call analysis failed (funcsize=7)"

//----- (1005A820) --------------------------------------------------------
void __cdecl sub_1005A820()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005A82B) --------------------------------------------------------
#error "1005A837: call analysis failed (funcsize=7)"

//----- (1005A850) --------------------------------------------------------
int __usercall sub_1005A850<eax>(int a1<ebp>)
{
  return sub_1002C0CF(a1);
}

//----- (1005A85B) --------------------------------------------------------
int __usercall sub_1005A85B<eax>(int a1<ebp>)
{
  return sub_1002C0CF(a1);
}

//----- (1005A866) --------------------------------------------------------
int __usercall sub_1005A866<eax>(int a1<ebp>)
{
  int result; // eax@2
  int v14; // esi@1

  v14 = *(_DWORD *)(*(_DWORD *)(a1 - 16) + 96);
  if ( v14 )
  {
    _EDI = -1;
    _ECX = v14 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v14)(v14);
      result = v14 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v14 + 4))(v14);
    }
  }
  return result;
}

//----- (1005A871) --------------------------------------------------------
int __usercall sub_1005A871<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 16) + 100);
}
// 1002B6E4: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005A87C) --------------------------------------------------------
#error "1005A888: call analysis failed (funcsize=7)"

//----- (1005A8A0) --------------------------------------------------------
void __cdecl sub_1005A8A0()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A8A8) --------------------------------------------------------
int __usercall sub_1005A8A8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 120, a2);
}

//----- (1005A8B0) --------------------------------------------------------
int __usercall sub_1005A8B0<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100029F0((void *)(a2 - 92));
}

//----- (1005A8B8) --------------------------------------------------------
void __cdecl sub_1005A8B8()
{
  JUMPOUT(*(unsigned int *)loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();

//----- (1005A8C0) --------------------------------------------------------
int __usercall sub_1005A8C0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 136, a2);
}

//----- (1005A8CB) --------------------------------------------------------
int __usercall sub_1005A8CB<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 160, a2);
}

//----- (1005A8D6) --------------------------------------------------------
#error "1005A8E5: call analysis failed (funcsize=10)"

//----- (1005A900) --------------------------------------------------------
void __cdecl sub_1005A900()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A908) --------------------------------------------------------
#error "1005A914: call analysis failed (funcsize=7)"

//----- (1005A930) --------------------------------------------------------
void __cdecl sub_1005A930()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A938) --------------------------------------------------------
#error "1005A944: call analysis failed (funcsize=7)"

//----- (1005A960) --------------------------------------------------------
void __cdecl sub_1005A960()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A968) --------------------------------------------------------
#error "1005A974: call analysis failed (funcsize=7)"

//----- (1005A990) --------------------------------------------------------
void __cdecl sub_1005A990()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A998) --------------------------------------------------------
#error "1005A9A4: call analysis failed (funcsize=7)"

//----- (1005A9C0) --------------------------------------------------------
void __cdecl sub_1005A9C0()
{
  sub_1002B6D6();
}

//----- (1005A9C8) --------------------------------------------------------
void __cdecl sub_1005A9C8()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005A9D0) --------------------------------------------------------
#error "1005A9DC: call analysis failed (funcsize=10)"

//----- (1005AA00) --------------------------------------------------------
void __cdecl sub_1005AA00()
{
  sub_1002B6D6();
}

//----- (1005AA08) --------------------------------------------------------
void __cdecl sub_1005AA08()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005AA10) --------------------------------------------------------
#error "1005AA1C: call analysis failed (funcsize=10)"

//----- (1005AA40) --------------------------------------------------------
void __cdecl sub_1005AA40()
{
  sub_1002B6D6();
}

//----- (1005AA48) --------------------------------------------------------
void __cdecl sub_1005AA48()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005AA50) --------------------------------------------------------
#error "1005AA5C: call analysis failed (funcsize=10)"

//----- (1005AA80) --------------------------------------------------------
void __cdecl sub_1005AA80()
{
  sub_1002B6D6();
}

//----- (1005AA88) --------------------------------------------------------
void __cdecl sub_1005AA88()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005AA90) --------------------------------------------------------
#error "1005AA9C: call analysis failed (funcsize=10)"

//----- (1005AAC0) --------------------------------------------------------
void __cdecl sub_1005AAC0()
{
  sub_1002B6D6();
}

//----- (1005AAC8) --------------------------------------------------------
void __cdecl sub_1005AAC8()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005AAD0) --------------------------------------------------------
#error "1005AADC: call analysis failed (funcsize=10)"

//----- (1005AB00) --------------------------------------------------------
int __usercall sub_1005AB00<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_1000A960(*(_DWORD *)(a2 - 16));
}

//----- (1005AB08) --------------------------------------------------------
#error "1005AB14: call analysis failed (funcsize=7)"

//----- (1005AB30) --------------------------------------------------------
int __usercall sub_1005AB30<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 96);
}

//----- (1005AB38) --------------------------------------------------------
int __usercall sub_1005AB38<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 128);
}

//----- (1005AB40) --------------------------------------------------------
int __cdecl sub_1005AB40()
{
  return sub_10001880((int)&byte_10077710);
}
// 10077710: using guessed type char byte_10077710;

//----- (1005AB4A) --------------------------------------------------------
int __usercall sub_1005AB4A<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 72);
}

//----- (1005AB52) --------------------------------------------------------
int __usercall sub_1005AB52<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 48);
}

//----- (1005AB5A) --------------------------------------------------------
#error "1005AB6C: call analysis failed (funcsize=7)"

//----- (1005AB80) --------------------------------------------------------
int __usercall sub_1005AB80<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100099A0((void *)(a2 + 16));
}

//----- (1005AB88) --------------------------------------------------------
void __cdecl sub_1005AB88()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005AB90) --------------------------------------------------------
int __usercall sub_1005AB90<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 28) & 1;
  if ( *(_DWORD *)(a1 - 28) & 1 )
  {
    *(_DWORD *)(a1 - 28) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005ABA9) --------------------------------------------------------
#error "1005ABB5: call analysis failed (funcsize=10)"

//----- (1005ABD0) --------------------------------------------------------
int __usercall sub_1005ABD0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 60, a2);
}

//----- (1005ABD8) --------------------------------------------------------
int __usercall sub_1005ABD8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005ABE0) --------------------------------------------------------
int __usercall sub_1005ABE0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005ABE8) --------------------------------------------------------
int __usercall sub_1005ABE8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005ABF0) --------------------------------------------------------
int __usercall sub_1005ABF0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005ABF8) --------------------------------------------------------
int __usercall sub_1005ABF8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(*(_DWORD *)(a3 - 64), a2);
}

//----- (1005AC00) --------------------------------------------------------
void __cdecl sub_1005AC00()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005AC08) --------------------------------------------------------
int __usercall sub_1005AC08<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 68) & 1;
  if ( *(_DWORD *)(a1 - 68) & 1 )
  {
    *(_DWORD *)(a1 - 68) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005AC21) --------------------------------------------------------
#error "1005AC2D: call analysis failed (funcsize=10)"

//----- (1005AC50) --------------------------------------------------------
void __cdecl sub_1005AC50()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005AC58) --------------------------------------------------------
#error "1005AC64: call analysis failed (funcsize=7)"

//----- (1005AC80) --------------------------------------------------------
int __usercall sub_1005AC80<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001B00(a2 - 136);
}

//----- (1005AC8B) --------------------------------------------------------
int __usercall sub_1005AC8B<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 152, a2);
}

//----- (1005AC96) --------------------------------------------------------
int __usercall sub_1005AC96<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 176, a2);
}

//----- (1005ACA1) --------------------------------------------------------
int __usercall sub_1005ACA1<eax>(int a1<ebp>)
{
  return sub_10001940(a1 - 176);
}
// 10001940: using guessed type int __thiscall sub_10001940(_DWORD);

//----- (1005ACAC) --------------------------------------------------------
#error "1005ACBE: call analysis failed (funcsize=11)"

//----- (1005ACE0) --------------------------------------------------------
void __cdecl sub_1005ACE0()
{
  sub_1002B6D6();
}

//----- (1005ACE8) --------------------------------------------------------
int __usercall sub_1005ACE8<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int v2; // esi@1
  int result; // eax@2

  v2 = a1 - 72;
  v1 = *(_DWORD *)(a1 - 72 + 16);
  if ( v1 )
  {
    result = (*(int (__stdcall **)(bool))(*(_DWORD *)v1 + 16))(v1 != v2);
    *(_DWORD *)(v2 + 16) = 0;
  }
  return result;
}

//----- (1005ACF0) --------------------------------------------------------
int __usercall sub_1005ACF0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 - 72);
}

//----- (1005ACF8) --------------------------------------------------------
#error "1005AD04: call analysis failed (funcsize=11)"

//----- (1005AD20) --------------------------------------------------------
int __usercall sub_1005AD20<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100034E0((void *)(a2 - 64));
}

//----- (1005AD28) --------------------------------------------------------
void __cdecl sub_1005AD28()
{
  sub_1002B6D6();
}

//----- (1005AD30) --------------------------------------------------------
#error "1005AD3C: call analysis failed (funcsize=10)"

//----- (1005AD60) --------------------------------------------------------
void __cdecl sub_1005AD60()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005AD68) --------------------------------------------------------
#error "1005AD74: call analysis failed (funcsize=7)"

//----- (1005AD90) --------------------------------------------------------
void __cdecl sub_1005AD90()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005AD98) --------------------------------------------------------
void __cdecl sub_1005AD98()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005ADA0) --------------------------------------------------------
#error "1005ADAC: call analysis failed (funcsize=7)"

//----- (1005ADC0) --------------------------------------------------------
void __cdecl sub_1005ADC0()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005ADC8) --------------------------------------------------------
void __cdecl sub_1005ADC8()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005ADD0) --------------------------------------------------------
void __cdecl sub_1005ADD0()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005ADD8) --------------------------------------------------------
int __usercall sub_1005ADD8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 - 72);
}

//----- (1005ADE0) --------------------------------------------------------
void __cdecl sub_1005ADE0()
{
  sub_1002B6D6();
}

//----- (1005ADE8) --------------------------------------------------------
#error "1005ADF4: call analysis failed (funcsize=11)"

//----- (1005AE10) --------------------------------------------------------
int __thiscall sub_1005AE10(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005AE21) --------------------------------------------------------
void __usercall sub_1005AE21(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = off_10068098;
}
// 10068098: using guessed type int (*off_10068098[5])();

//----- (1005AE29) --------------------------------------------------------
void __cdecl sub_1005AE29()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005AE31) --------------------------------------------------------
#error "1005AE3D: call analysis failed (funcsize=7)"

//----- (1005AE50) --------------------------------------------------------
#error "1005AE5C: call analysis failed (funcsize=7)"

//----- (1005AE70) --------------------------------------------------------
#error "1005AE7C: call analysis failed (funcsize=7)"

//----- (1005AE90) --------------------------------------------------------
int __usercall sub_1005AE90<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 16) & 1;
  if ( *(_DWORD *)(a1 - 16) & 1 )
  {
    *(_DWORD *)(a1 - 16) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_1000A500);
  }
  return result;
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005AEA9) --------------------------------------------------------
#error "1005AEB5: call analysis failed (funcsize=7)"

//----- (1005AED0) --------------------------------------------------------
int __usercall sub_1005AED0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 + 8, a2);
}

//----- (1005AED8) --------------------------------------------------------
void __cdecl sub_1005AED8()
{
  sub_1002B6D6();
}

//----- (1005AEE0) --------------------------------------------------------
#error "1005AEEC: call analysis failed (funcsize=10)"

//----- (1005AF10) --------------------------------------------------------
void __cdecl sub_1005AF10()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005AF18) --------------------------------------------------------
#error "1005AF24: call analysis failed (funcsize=7)"

//----- (1005AF40) --------------------------------------------------------
int __usercall sub_1005AF40<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 + 8);
}

//----- (1005AF48) --------------------------------------------------------
#error "1005AF54: call analysis failed (funcsize=7)"

//----- (1005AF70) --------------------------------------------------------
void __cdecl sub_1005AF70()
{
  sub_1002B6D6();
}

//----- (1005AF78) --------------------------------------------------------
#error "1005AF84: call analysis failed (funcsize=10)"

//----- (1005AFA0) --------------------------------------------------------
void __cdecl sub_1005AFA0()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005AFA8) --------------------------------------------------------
#error "1005AFB4: call analysis failed (funcsize=7)"

//----- (1005AFD0) --------------------------------------------------------
void __cdecl sub_1005AFD0()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005AFD8) --------------------------------------------------------
#error "1005AFE4: call analysis failed (funcsize=11)"

//----- (1005B000) --------------------------------------------------------
void __cdecl sub_1005B000()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005B008) --------------------------------------------------------
void __cdecl sub_1005B008()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005B010) --------------------------------------------------------
void __cdecl sub_1005B010()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005B018) --------------------------------------------------------
#error "1005B024: call analysis failed (funcsize=10)"

//----- (1005B040) --------------------------------------------------------
void __cdecl sub_1005B040()
{
  JUMPOUT(*(unsigned int *)loc_1000A510);
}
// 1000A510: using guessed type int loc_1000A510();

//----- (1005B048) --------------------------------------------------------
int __usercall sub_1005B048<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 20));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005B053) --------------------------------------------------------
void __cdecl sub_1005B053()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005B05B) --------------------------------------------------------
#error "1005B067: call analysis failed (funcsize=7)"

//----- (1005B080) --------------------------------------------------------
#error "1005B08C: call analysis failed (funcsize=7)"

//----- (1005B0A0) --------------------------------------------------------
int __usercall sub_1005B0A0<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 + 12);
  --*(_DWORD *)result;
  return result;
}

//----- (1005B0A8) --------------------------------------------------------
#error "1005B0B4: call analysis failed (funcsize=7)"

//----- (1005B0D0) --------------------------------------------------------
void __cdecl sub_1005B0D0()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005B0D8) --------------------------------------------------------
#error "1005B0E4: call analysis failed (funcsize=10)"

//----- (1005B100) --------------------------------------------------------
void __cdecl sub_1005B100()
{
  JUMPOUT(*(unsigned int *)loc_1000A510);
}
// 1000A510: using guessed type int loc_1000A510();

//----- (1005B108) --------------------------------------------------------
void __cdecl sub_1005B108()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005B110) --------------------------------------------------------
#error "1005B11C: call analysis failed (funcsize=7)"

//----- (1005B130) --------------------------------------------------------
int __thiscall sub_1005B130(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005B141) --------------------------------------------------------
int __thiscall sub_1005B141(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005B152) --------------------------------------------------------
#error "1005B15E: call analysis failed (funcsize=7)"

//----- (1005B170) --------------------------------------------------------
void __cdecl sub_1005B170()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005B178) --------------------------------------------------------
#error "1005B184: call analysis failed (funcsize=7)"

//----- (1005B1A0) --------------------------------------------------------
int __usercall sub_1005B1A0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 + 8, a2);
}

//----- (1005B1A8) --------------------------------------------------------
int __usercall sub_1005B1A8<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100034E0((void *)(a2 - 64));
}

//----- (1005B1B0) --------------------------------------------------------
void __cdecl sub_1005B1B0()
{
  sub_1002B6D6();
}

//----- (1005B1B8) --------------------------------------------------------
int __usercall sub_1005B1B8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 80, a2);
}

//----- (1005B1C0) --------------------------------------------------------
void __cdecl sub_1005B1C0()
{
  sub_1002B6D6();
}

//----- (1005B1C8) --------------------------------------------------------
#error "1005B1D4: call analysis failed (funcsize=10)"

//----- (1005B1F0) --------------------------------------------------------
void __cdecl sub_1005B1F0()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005B1F8) --------------------------------------------------------
void __cdecl sub_1005B1F8()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005B200) --------------------------------------------------------
#error "1005B20C: call analysis failed (funcsize=7)"

//----- (1005B220) --------------------------------------------------------
int __usercall sub_1005B220<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 16);
}

//----- (1005B228) --------------------------------------------------------
void __usercall sub_1005B228(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = off_10068B14;
}
// 10068B14: using guessed type int (__stdcall *off_10068B14[2])(char);

//----- (1005B230) --------------------------------------------------------
#error "1005B23C: call analysis failed (funcsize=7)"

//----- (1005B250) --------------------------------------------------------
int __usercall sub_1005B250<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 88);
}

//----- (1005B258) --------------------------------------------------------
#error "1005B264: call analysis failed (funcsize=10)"

//----- (1005B280) --------------------------------------------------------
int __cdecl sub_1005B280()
{
  return sub_10001880((int)&unk_10075E80);
}

//----- (1005B28A) --------------------------------------------------------
#error "1005B296: call analysis failed (funcsize=7)"

//----- (1005B2B0) --------------------------------------------------------
int __usercall sub_1005B2B0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 8);
}

//----- (1005B2B8) --------------------------------------------------------
int __usercall sub_1005B2B8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 160);
}

//----- (1005B2C3) --------------------------------------------------------
int __usercall sub_1005B2C3<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 164));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005B2D1) --------------------------------------------------------
#error "1005B2E0: call analysis failed (funcsize=10)"

//----- (1005B300) --------------------------------------------------------
int __usercall sub_1005B300<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 16) & 1;
  if ( *(_DWORD *)(a2 - 16) & 1 )
  {
    *(_DWORD *)(a2 - 16) &= 0xFFFFFFFEu;
    result = sub_10001880(a2 - 64);
  }
  return result;
}

//----- (1005B319) --------------------------------------------------------
#error "1005B325: call analysis failed (funcsize=7)"

//----- (1005B340) --------------------------------------------------------
void __cdecl sub_1005B340()
{
  JUMPOUT(*(unsigned int *)loc_10017D90);
}
// 10017D90: using guessed type int loc_10017D90();

//----- (1005B348) --------------------------------------------------------
void __cdecl sub_1005B348()
{
  JUMPOUT(*(unsigned int *)loc_10017E50);
}
// 10017E50: using guessed type int loc_10017E50();

//----- (1005B350) --------------------------------------------------------
#error "1005B35C: call analysis failed (funcsize=7)"

//----- (1005B370) --------------------------------------------------------
int __thiscall sub_1005B370(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005B381) --------------------------------------------------------
void __cdecl sub_1005B381()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005B389) --------------------------------------------------------
#error "1005B395: call analysis failed (funcsize=7)"

//----- (1005B3B0) --------------------------------------------------------
#error "1005B3BC: call analysis failed (funcsize=7)"

//----- (1005B3D0) --------------------------------------------------------
void __cdecl sub_1005B3D0()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005B3D8) --------------------------------------------------------
#error "1005B3E4: call analysis failed (funcsize=7)"

//----- (1005B400) --------------------------------------------------------
#error "1005B40C: call analysis failed (funcsize=7)"

//----- (1005B420) --------------------------------------------------------
void __usercall sub_1005B420(int a1<ebx>, int a2<ebp>)
{
  int v2; // ecx@1

  v2 = *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)v2 )
  {
    if ( *(_DWORD *)(v2 + 4) == 1 )
      sub_100309A2(a1, *(LPVOID *)v2);
  }
}

//----- (1005B428) --------------------------------------------------------
#error "1005B434: call analysis failed (funcsize=7)"

//----- (1005B45A) --------------------------------------------------------
#error "1005B466: call analysis failed (funcsize=10)"

//----- (1005B480) --------------------------------------------------------
void __usercall sub_1005B480(void *this<ecx>, int a2<ebp>)
{
  sub_10029AD2((void *)(a2 - 24));
}

//----- (1005B488) --------------------------------------------------------
#error "1005B494: call analysis failed (funcsize=10)"

//----- (1005B4B0) --------------------------------------------------------
int __usercall sub_1005B4B0<eax>(int a1<ebp>)
{
  return sub_1002A4AA(**(LPVOID **)(a1 - 24));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005B4B8) --------------------------------------------------------
#error "1005B4C4: call analysis failed (funcsize=7)"

//----- (1005B4E0) --------------------------------------------------------
char __usercall sub_1005B4E0<al>(int a1<ebp>)
{
  int v1; // eax@1
  int v2; // ecx@2

  v1 = *(_DWORD *)(a1 - 16) & 1;
  if ( *(_DWORD *)(a1 - 16) & 1 )
  {
    *(_DWORD *)(a1 - 16) &= 0xFFFFFFFEu;
    v2 = *(_DWORD *)(a1 - 20) + 80;
    *(_DWORD *)v2 = &off_100683D0;
    LOBYTE(v1) = sub_100296B7(v2);
  }
  return v1;
}
// 100683D0: using guessed type int (__stdcall *off_100683D0)(char);

//----- (1005B4FC) --------------------------------------------------------
int __usercall sub_1005B4FC<eax>(int a1<ebp>)
{
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@1

  v3 = *(_DWORD *)(a1 - 20) + 8;
  *(_DWORD *)(*(_DWORD *)(**(_DWORD **)(a1 - 20) + 4) + *(_DWORD *)(a1 - 20) + 8 - 8) = off_100689F0;
  v1 = *(_DWORD *)(*(_DWORD *)(v3 - 8) + 4);
  result = v1 - 8;
  *(_DWORD *)(v1 + v3 - 12) = v1 - 8;
  return result;
}
// 100689F0: using guessed type int (*off_100689F0[3])();

//----- (1005B507) --------------------------------------------------------
void __usercall sub_1005B507(int a1<ebp>)
{
  int v1; // eax@3
  int v2; // ecx@1
  void *v3; // esi@1

  v2 = *(_DWORD *)(a1 - 24);
  v3 = *(void **)(v2 + 52);
  *(_DWORD *)v2 = &off_1006896C;
  if ( v3 )
  {
    if ( *(_DWORD *)v3 )
    {
      v1 = (*(int (**)(void))(**(_DWORD **)v3 + 8))();
      if ( v1 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v1)(v1, 1);
    }
    sub_1002A4AA(v3);
  }
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1006896C: using guessed type int (__stdcall *off_1006896C)(char);

//----- (1005B50F) --------------------------------------------------------
#error "1005B51B: call analysis failed (funcsize=7)"

//----- (1005B530) --------------------------------------------------------
int __usercall sub_1005B530<eax>(int a1<ebp>)
{
  int v1; // esi@1
  int result; // eax@1

  v1 = *(_DWORD *)(a1 - 16);
  sub_10002D20(v1);
  result = sub_1002A4AA(*(LPVOID *)v1);
  *(_DWORD *)v1 = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005B538) --------------------------------------------------------
#error "1005B544: call analysis failed (funcsize=7)"

//----- (1005B560) --------------------------------------------------------
int __usercall sub_1005B560<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 24));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005B56B) --------------------------------------------------------
int __usercall sub_1005B56B<eax>(int a1<ebp>)
{
  return sub_10030383(*(LPVOID *)(a1 - 24));
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (1005B576) --------------------------------------------------------
#error "1005B582: call analysis failed (funcsize=10)"

//----- (1005B5A0) --------------------------------------------------------
void __usercall sub_1005B5A0(void *this<ecx>, int a2<ebp>)
{
  sub_10029AD2(*(void **)(a2 - 24));
}

//----- (1005B5A8) --------------------------------------------------------
void __usercall sub_1005B5A8(int a1<ebx>, int a2<ebp>)
{
  LPVOID *v2; // ecx@1
  LPVOID *v3; // esi@1

  v2 = (LPVOID *)(*(_DWORD *)(a2 - 24) + 4);
  v3 = v2;
  if ( *v2 )
    sub_100309A2(a1, *v2);
  *v3 = 0;
}

//----- (1005B5B3) --------------------------------------------------------
void __cdecl sub_1005B5B3()
{
  JUMPOUT(*(unsigned int *)loc_100179C0);
}
// 100179C0: using guessed type int loc_100179C0();

//----- (1005B5BE) --------------------------------------------------------
void __cdecl sub_1005B5BE()
{
  JUMPOUT(*(unsigned int *)loc_100179C0);
}
// 100179C0: using guessed type int loc_100179C0();

//----- (1005B5C9) --------------------------------------------------------
void __cdecl sub_1005B5C9()
{
  JUMPOUT(*(unsigned int *)loc_100179C0);
}
// 100179C0: using guessed type int loc_100179C0();

//----- (1005B5D4) --------------------------------------------------------
void __cdecl sub_1005B5D4()
{
  JUMPOUT(*(unsigned int *)loc_100179C0);
}
// 100179C0: using guessed type int loc_100179C0();

//----- (1005B5DF) --------------------------------------------------------
void __cdecl sub_1005B5DF()
{
  JUMPOUT(*(unsigned int *)loc_100179C0);
}
// 100179C0: using guessed type int loc_100179C0();

//----- (1005B5EA) --------------------------------------------------------
#error "1005B5F6: call analysis failed (funcsize=10)"

//----- (1005B610) --------------------------------------------------------
int __usercall sub_1005B610<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 36);
}

//----- (1005B618) --------------------------------------------------------
#error "1005B624: call analysis failed (funcsize=7)"

//----- (1005B640) --------------------------------------------------------
int __usercall sub_1005B640<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // ecx@1
  int v3; // ecx@1

  v3 = **(_DWORD **)(a1 - 16);
  result = *(_DWORD *)(*(_DWORD *)v3 + 4);
  v2 = *(_DWORD *)(result + v3 + 56);
  if ( v2 )
    result = (*(int (**)(void))(*(_DWORD *)v2 + 8))();
  return result;
}

//----- (1005B648) --------------------------------------------------------
#error "1005B654: call analysis failed (funcsize=7)"

//----- (1005B670) --------------------------------------------------------
void __cdecl sub_1005B670()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005B678) --------------------------------------------------------
#error "1005B684: call analysis failed (funcsize=7)"

//----- (1005B6A0) --------------------------------------------------------
void __cdecl sub_1005B6A0()
{
  JUMPOUT(*(unsigned int *)loc_10017D90);
}
// 10017D90: using guessed type int loc_10017D90();

//----- (1005B6A8) --------------------------------------------------------
void __cdecl sub_1005B6A8()
{
  JUMPOUT(*(unsigned int *)loc_10017E50);
}
// 10017E50: using guessed type int loc_10017E50();

//----- (1005B6B0) --------------------------------------------------------
void __usercall sub_1005B6B0(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 28));
}

//----- (1005B6B8) --------------------------------------------------------
#error "1005B6C4: call analysis failed (funcsize=7)"

//----- (1005B6E0) --------------------------------------------------------
int __usercall sub_1005B6E0<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 48));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005B6EB) --------------------------------------------------------
int __usercall sub_1005B6EB<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 68, a2);
}

//----- (1005B6F3) --------------------------------------------------------
void __cdecl sub_1005B6F3()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005B6FB) --------------------------------------------------------
void __cdecl sub_1005B6FB()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005B703) --------------------------------------------------------
void __usercall sub_1005B703(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_10010C30(a3 - 44, a2);
}

//----- (1005B70B) --------------------------------------------------------
void __cdecl sub_1005B70B()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005B713) --------------------------------------------------------
#error "1005B71F: call analysis failed (funcsize=10)"

//----- (1005B740) --------------------------------------------------------
void __cdecl sub_1005B740()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005B748) --------------------------------------------------------
#error "1005B754: call analysis failed (funcsize=7)"

//----- (1005B770) --------------------------------------------------------
void __cdecl sub_1005B770()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005B778) --------------------------------------------------------
#error "1005B784: call analysis failed (funcsize=7)"

//----- (1005B7A0) --------------------------------------------------------
void __usercall sub_1005B7A0(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 96));
}

//----- (1005B7A8) --------------------------------------------------------
int __usercall sub_1005B7A8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 68);
}

//----- (1005B7B0) --------------------------------------------------------
void __usercall sub_1005B7B0(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 96));
}

//----- (1005B7B8) --------------------------------------------------------
int __usercall sub_1005B7B8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 44);
}

//----- (1005B7C0) --------------------------------------------------------
#error "1005B7CC: call analysis failed (funcsize=11)"

//----- (1005B7F0) --------------------------------------------------------
int __usercall sub_1005B7F0<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 + 8));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005B7FB) --------------------------------------------------------
#error "1005B807: call analysis failed (funcsize=7)"

//----- (1005B820) --------------------------------------------------------
int __usercall sub_1005B820<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 + 8));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005B82B) --------------------------------------------------------
#error "1005B837: call analysis failed (funcsize=7)"

//----- (1005B850) --------------------------------------------------------
int __usercall sub_1005B850<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 + 8));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005B85B) --------------------------------------------------------
void __usercall sub_1005B85B(void *this<ecx>, int a2<ebx>, int a3<ebp>)
{
  if ( *(_DWORD *)(a3 - 16) & 1 )
  {
    *(_DWORD *)(a3 - 16) &= 0xFFFFFFFEu;
    sub_100179E0((void *)(a3 - 68), a2);
  }
}

//----- (1005B874) --------------------------------------------------------
void __usercall sub_1005B874(int a1<ebp>)
{
  **(_DWORD **)(a1 + 8) = &off_10061664;
}
// 10061664: using guessed type int (__stdcall *off_10061664)(char);

//----- (1005B87C) --------------------------------------------------------
#error "1005B888: call analysis failed (funcsize=7)"

//----- (1005B8A0) --------------------------------------------------------
#error "1005B8AC: call analysis failed (funcsize=7)"

//----- (1005B8C0) --------------------------------------------------------
void __usercall sub_1005B8C0(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 76));
}

//----- (1005B8C8) --------------------------------------------------------
int __usercall sub_1005B8C8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 68);
}

//----- (1005B8D0) --------------------------------------------------------
void __usercall sub_1005B8D0(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 92));
}

//----- (1005B8D8) --------------------------------------------------------
int __usercall sub_1005B8D8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 44);
}

//----- (1005B8E0) --------------------------------------------------------
#error "1005B8EC: call analysis failed (funcsize=11)"

//----- (1005B910) --------------------------------------------------------
#error "1005B91C: call analysis failed (funcsize=7)"

//----- (1005B930) --------------------------------------------------------
int __usercall sub_1005B930<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 40);
}

//----- (1005B938) --------------------------------------------------------
int __usercall sub_1005B938<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 64);
}

//----- (1005B940) --------------------------------------------------------
#error "1005B94C: call analysis failed (funcsize=7)"

//----- (1005B960) --------------------------------------------------------
int __usercall sub_1005B960<eax>(int a1<ebp>)
{
  int result; // eax@2
  int v2; // esi@1

  v2 = a1 - 60;
  if ( *(_DWORD *)(a1 - 60 + 32) >= 0x10u )
    result = sub_1002A4AA(*(LPVOID *)(a1 - 60 + 12));
  *(_DWORD *)(v2 + 32) = 15;
  *(_DWORD *)(v2 + 28) = 0;
  *(_BYTE *)(v2 + 12) = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005B968) --------------------------------------------------------
#error "1005B974: call analysis failed (funcsize=10)"

//----- (1005B990) --------------------------------------------------------
int __usercall sub_1005B990<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 16) & 1;
  if ( *(_DWORD *)(a2 - 16) & 1 )
  {
    *(_DWORD *)(a2 - 16) &= 0xFFFFFFFEu;
    result = sub_10001880(*(_DWORD *)(a2 - 20));
  }
  return result;
}

//----- (1005B9A9) --------------------------------------------------------
#error "1005B9B5: call analysis failed (funcsize=7)"

//----- (1005B9D0) --------------------------------------------------------
int __usercall sub_1005B9D0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 84);
}

//----- (1005B9D8) --------------------------------------------------------
int __usercall sub_1005B9D8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 48);
}

//----- (1005B9E0) --------------------------------------------------------
int __usercall sub_1005B9E0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 116);
}

//----- (1005B9E8) --------------------------------------------------------
int __usercall sub_1005B9E8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 76, a2);
}

//----- (1005B9F0) --------------------------------------------------------
#error "1005B9FF: call analysis failed (funcsize=10)"

//----- (1005BA20) --------------------------------------------------------
int __usercall sub_1005BA20<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 100, a2);
}

//----- (1005BA28) --------------------------------------------------------
int __usercall sub_1005BA28<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 108);
}

//----- (1005BA30) --------------------------------------------------------
int __usercall sub_1005BA30<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 60);
}

//----- (1005BA38) --------------------------------------------------------
int __usercall sub_1005BA38<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 84);
}

//----- (1005BA40) --------------------------------------------------------
int __usercall sub_1005BA40<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 100, a2);
}

//----- (1005BA48) --------------------------------------------------------
int __usercall sub_1005BA48<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 100, a2);
}

//----- (1005BA50) --------------------------------------------------------
#error "1005BA5C: call analysis failed (funcsize=7)"

//----- (1005BA70) --------------------------------------------------------
int __usercall sub_1005BA70<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 44);
}

//----- (1005BA78) --------------------------------------------------------
int __usercall sub_1005BA78<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 60, a2);
}

//----- (1005BA80) --------------------------------------------------------
#error "1005BA8C: call analysis failed (funcsize=10)"

//----- (1005BAB0) --------------------------------------------------------
int __usercall sub_1005BAB0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 84);
}

//----- (1005BAB8) --------------------------------------------------------
int __usercall sub_1005BAB8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 60);
}

//----- (1005BAC0) --------------------------------------------------------
int __usercall sub_1005BAC0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 60);
}

//----- (1005BAC8) --------------------------------------------------------
#error "1005BAD4: call analysis failed (funcsize=7)"

//----- (1005BAF0) --------------------------------------------------------
int __usercall sub_1005BAF0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 40);
}

//----- (1005BAF8) --------------------------------------------------------
int __usercall sub_1005BAF8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 64);
}

//----- (1005BB00) --------------------------------------------------------
#error "1005BB0C: call analysis failed (funcsize=7)"

//----- (1005BB20) --------------------------------------------------------
void __usercall sub_1005BB20(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 76));
}

//----- (1005BB28) --------------------------------------------------------
int __usercall sub_1005BB28<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 44);
}

//----- (1005BB30) --------------------------------------------------------
#error "1005BB3C: call analysis failed (funcsize=11)"

//----- (1005BB60) --------------------------------------------------------
void __cdecl sub_1005BB60()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005BB68) --------------------------------------------------------
#error "1005BB74: call analysis failed (funcsize=7)"

//----- (1005BB9F) --------------------------------------------------------
#error "1005BBAB: call analysis failed (funcsize=10)"

//----- (1005BBD0) --------------------------------------------------------
int __usercall sub_1005BBD0<eax>(int a1<ebp>)
{
  int result; // eax@3
  int v2; // ecx@3
  void **v3; // esi@1

  v3 = (void **)(a1 - 28);
  if ( !(unsigned __int8)sub_10029736() )
    sub_10017DB0(*v3);
  result = *(_DWORD *)(*(_DWORD *)*v3 + 4);
  v2 = *(_DWORD *)(*v3 + result + 56);
  if ( v2 )
    result = (*(int (**)(void))(*(_DWORD *)v2 + 8))();
  return result;
}
// 10029736: using guessed type int sub_10029736(void);

//----- (1005BBD8) --------------------------------------------------------
#error "1005BBE4: call analysis failed (funcsize=11)"

//----- (1005BC00) --------------------------------------------------------
void __cdecl sub_1005BC00()
{
  JUMPOUT(*(unsigned int *)loc_100183B0);
}
// 100183B0: using guessed type int loc_100183B0();

//----- (1005BC08) --------------------------------------------------------
int __usercall sub_1005BC08<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 60);
}

//----- (1005BC10) --------------------------------------------------------
#error "1005BC1C: call analysis failed (funcsize=7)"

//----- (1005BC30) --------------------------------------------------------
void __usercall sub_1005BC30(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 + 8));
}

//----- (1005BC38) --------------------------------------------------------
#error "1005BC44: call analysis failed (funcsize=7)"

//----- (1005BC60) --------------------------------------------------------
int __usercall sub_1005BC60<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 64);
}

//----- (1005BC68) --------------------------------------------------------
#error "1005BC74: call analysis failed (funcsize=10)"

//----- (1005BC90) --------------------------------------------------------
int __thiscall sub_1005BC90(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005BCA1) --------------------------------------------------------
#error "1005BCAD: call analysis failed (funcsize=7)"

//----- (1005BCC0) --------------------------------------------------------
int __usercall sub_1005BCC0<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 20));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005BCCB) --------------------------------------------------------
int __usercall sub_1005BCCB<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 60, a2);
}

//----- (1005BCD3) --------------------------------------------------------
int __usercall sub_1005BCD3<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 84);
}

//----- (1005BCDB) --------------------------------------------------------
#error "1005BCE7: call analysis failed (funcsize=7)"

//----- (1005BD00) --------------------------------------------------------
int __usercall sub_1005BD00<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 44);
}

//----- (1005BD08) --------------------------------------------------------
int __usercall sub_1005BD08<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 72));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005BD13) --------------------------------------------------------
int __usercall sub_1005BD13<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 60, a2);
}

//----- (1005BD1B) --------------------------------------------------------
int __usercall sub_1005BD1B<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 68);
}

//----- (1005BD23) --------------------------------------------------------
int __usercall sub_1005BD23<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 68);
}

//----- (1005BD2B) --------------------------------------------------------
int __usercall sub_1005BD2B<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 68);
}

//----- (1005BD33) --------------------------------------------------------
#error "1005BD3F: call analysis failed (funcsize=10)"

//----- (1005BD60) --------------------------------------------------------
int __usercall sub_1005BD60<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 56, a2);
}

//----- (1005BD68) --------------------------------------------------------
int __usercall sub_1005BD68<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 56, a2);
}

//----- (1005BD70) --------------------------------------------------------
int __usercall sub_1005BD70<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 56, a2);
}

//----- (1005BD78) --------------------------------------------------------
int __usercall sub_1005BD78<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 80);
}

//----- (1005BD80) --------------------------------------------------------
#error "1005BD8C: call analysis failed (funcsize=7)"

//----- (1005BDA5) --------------------------------------------------------
#error "1005BDB1: call analysis failed (funcsize=10)"

//----- (1005BDD0) --------------------------------------------------------
int __usercall sub_1005BDD0<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 48));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005BDDB) --------------------------------------------------------
int __usercall sub_1005BDDB<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 72, a2);
}

//----- (1005BDE3) --------------------------------------------------------
void __cdecl sub_1005BDE3()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005BDEB) --------------------------------------------------------
void __cdecl sub_1005BDEB()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005BDF3) --------------------------------------------------------
void __usercall sub_1005BDF3(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_10010C30(a3 - 40, a2);
}

//----- (1005BDFB) --------------------------------------------------------
void __cdecl sub_1005BDFB()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005BE03) --------------------------------------------------------
#error "1005BE0F: call analysis failed (funcsize=10)"

//----- (1005BE30) --------------------------------------------------------
int __usercall sub_1005BE30<eax>(int a1<ebp>)
{
  return sub_10030383(*(LPVOID *)(a1 + 8));
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (1005BE3B) --------------------------------------------------------
#error "1005BE47: call analysis failed (funcsize=7)"

//----- (1005BE60) --------------------------------------------------------
int __usercall sub_1005BE60<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 240);
}

//----- (1005BE6B) --------------------------------------------------------
int __usercall sub_1005BE6B<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 216);
}

//----- (1005BE76) --------------------------------------------------------
int __usercall sub_1005BE76<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 40);
}

//----- (1005BE7E) --------------------------------------------------------
char __usercall sub_1005BE7E<al>(int a1<ebp>)
{
  int v1; // esi@1
  int v3; // ecx@1

  v3 = a1 - 192;
  v1 = a1 - 192 + 80;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v3 + 4) + v3 + 80 - 80) = off_100689E4;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v3 + 4) + v3 + 80 - 84) = *(_DWORD *)(*(_DWORD *)v3 + 4) - 80;
  sub_10012890(a1 - 192 + 4);
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 - 192) + 4) + a1 - 192 + 80 - 80) = off_100689F0;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 - 192) + 4) + a1 - 192 + 80 - 84) = *(_DWORD *)(*(_DWORD *)(a1 - 192) + 4) - 8;
  *(_DWORD *)v1 = &off_100683D0;
  return sub_100296B7(v1);
}
// 100683D0: using guessed type int (__stdcall *off_100683D0)(char);
// 100689E4: using guessed type int (*off_100689E4[6])();
// 100689F0: using guessed type int (*off_100689F0[3])();

//----- (1005BE89) --------------------------------------------------------
int __usercall sub_1005BE89<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 216);
}

//----- (1005BE94) --------------------------------------------------------
#error "1005BEA3: call analysis failed (funcsize=10)"

//----- (1005BEC0) --------------------------------------------------------
int __usercall sub_1005BEC0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 136);
}

//----- (1005BECB) --------------------------------------------------------
int __usercall sub_1005BECB<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 64);
}

//----- (1005BED3) --------------------------------------------------------
int __usercall sub_1005BED3<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 112);
}

//----- (1005BEDB) --------------------------------------------------------
int __usercall sub_1005BEDB<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 88);
}

//----- (1005BEE3) --------------------------------------------------------
int __usercall sub_1005BEE3<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 40);
}

//----- (1005BEEB) --------------------------------------------------------
int __usercall sub_1005BEEB<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = a1 - 188;
  result = *(_DWORD *)(a1 - 188);
  if ( *(_DWORD *)(a1 - 188) )
  {
    sub_10018370(result, *(_DWORD *)(a1 - 188 + 4));
    result = sub_1002A4AA(*(LPVOID *)v2);
    *(_DWORD *)v2 = 0;
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005BEF6) --------------------------------------------------------
int __usercall sub_1005BEF6<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 160);
}

//----- (1005BF01) --------------------------------------------------------
#error "1005BF13: call analysis failed (funcsize=7)"

//----- (1005BF30) --------------------------------------------------------
void __usercall sub_1005BF30(int a1<ebp>)
{
  int v1; // eax@2
  int v2; // ecx@1

  v2 = *(_DWORD *)(*(_DWORD *)(a1 - 16) + 12);
  if ( v2 )
  {
    v1 = (*(int (**)(void))(*(_DWORD *)v2 + 8))();
    if ( v1 )
      (**(void (__thiscall ***)(_DWORD, _DWORD))v1)(v1, 1);
  }
}

//----- (1005BF3B) --------------------------------------------------------
#error "1005BF47: call analysis failed (funcsize=7)"

//----- (1005BF60) --------------------------------------------------------
void __usercall sub_1005BF60(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 92));
}

//----- (1005BF68) --------------------------------------------------------
void __usercall sub_1005BF68(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 96));
}

//----- (1005BF70) --------------------------------------------------------
#error "1005BF7C: call analysis failed (funcsize=10)"

//----- (1005BFA0) --------------------------------------------------------
#error "1005BFAC: call analysis failed (funcsize=7)"

//----- (1005BFC0) --------------------------------------------------------
#error "1005BFCC: call analysis failed (funcsize=7)"

//----- (1005BFE0) --------------------------------------------------------
int __usercall sub_1005BFE0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 44);
}

//----- (1005BFE8) --------------------------------------------------------
int __usercall sub_1005BFE8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 68);
}

//----- (1005BFF0) --------------------------------------------------------
#error "1005BFFC: call analysis failed (funcsize=10)"

//----- (1005C020) --------------------------------------------------------
int __usercall sub_1005C020<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10019740(a2 - 144);
}

//----- (1005C02B) --------------------------------------------------------
#error "1005C03A: call analysis failed (funcsize=10)"

//----- (1005C060) --------------------------------------------------------
int __usercall sub_1005C060<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = a1 - 104;
  *(_DWORD *)(a1 - 104 + 32) = 0;
  result = *(_DWORD *)(a1 - 104 + 20);
  if ( result )
  {
    result = sub_1002A4AA(*(LPVOID *)(a1 - 104 + 20));
    *(_DWORD *)(v2 + 20) = 0;
    *(_DWORD *)(v2 + 24) = 0;
    *(_DWORD *)(v2 + 28) = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005C068) --------------------------------------------------------
#error "1005C074: call analysis failed (funcsize=10)"

//----- (1005C090) --------------------------------------------------------
int __usercall sub_1005C090<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 20) & 1;
  if ( *(_DWORD *)(a2 - 20) & 1 )
  {
    *(_DWORD *)(a2 - 20) &= 0xFFFFFFFEu;
    result = sub_10001880(*(_DWORD *)(a2 + 8));
  }
  return result;
}

//----- (1005C0A9) --------------------------------------------------------
LPVOID __usercall sub_1005C0A9<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_10019980((LPVOID *)(a2 - 32));
}

//----- (1005C0B1) --------------------------------------------------------
void __usercall sub_1005C0B1(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 + 16));
}

//----- (1005C0B9) --------------------------------------------------------
void __usercall sub_1005C0B9(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 + 16));
}

//----- (1005C0C1) --------------------------------------------------------
#error "1005C0CD: call analysis failed (funcsize=7)"

//----- (1005C0E0) --------------------------------------------------------
int __usercall sub_1005C0E0<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 40) & 1;
  if ( *(_DWORD *)(a2 - 40) & 1 )
  {
    *(_DWORD *)(a2 - 40) &= 0xFFFFFFFEu;
    result = sub_10001880(*(_DWORD *)(a2 - 44));
  }
  return result;
}

//----- (1005C0F9) --------------------------------------------------------
LPVOID __usercall sub_1005C0F9<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_10019980((LPVOID *)(a2 - 36));
}

//----- (1005C101) --------------------------------------------------------
void __usercall sub_1005C101(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 20));
}

//----- (1005C109) --------------------------------------------------------
void __usercall sub_1005C109(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 20));
}

//----- (1005C111) --------------------------------------------------------
#error "1005C11D: call analysis failed (funcsize=7)"

//----- (1005C130) --------------------------------------------------------
void __cdecl sub_1005C130()
{
  JUMPOUT(*(unsigned int *)loc_100198B0);
}
// 100198B0: using guessed type int loc_100198B0();

//----- (1005C138) --------------------------------------------------------
void __cdecl sub_1005C138()
{
  JUMPOUT(*(unsigned int *)loc_100198B0);
}
// 100198B0: using guessed type int loc_100198B0();

//----- (1005C143) --------------------------------------------------------
LPVOID __usercall sub_1005C143<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_10019980((LPVOID *)(*(_DWORD *)(a2 - 20) + 64));
}

//----- (1005C14E) --------------------------------------------------------
#error "1005C15A: call analysis failed (funcsize=7)"

//----- (1005C170) --------------------------------------------------------
LPVOID __usercall sub_1005C170<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_10019980(*(LPVOID **)(a2 - 24));
}

//----- (1005C178) --------------------------------------------------------
LPVOID __usercall sub_1005C178<eax>(int a1<ebp>)
{
  LPVOID result; // eax@1
  LPVOID *v2; // ecx@1
  LPVOID *v3; // esi@1

  v2 = (LPVOID *)(*(_DWORD *)(a1 - 20) + 20);
  v3 = v2;
  *(_DWORD *)(*(_DWORD *)(a1 - 20) + 32) = 0;
  result = *v2;
  if ( *v2 )
  {
    result = (LPVOID)sub_1002A4AA(*v2);
    *v3 = 0;
    v3[1] = 0;
    v3[2] = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005C183) --------------------------------------------------------
#error "1005C18F: call analysis failed (funcsize=7)"

//----- (1005C1A0) --------------------------------------------------------
int __usercall sub_1005C1A0<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = *(_DWORD *)(a1 - 16) + 16;
  result = *(_DWORD *)(*(_DWORD *)(a1 - 16) + 24);
  if ( result )
  {
    result = sub_1002A4AA(*(LPVOID *)(*(_DWORD *)(a1 - 16) + 24));
    *(_DWORD *)(v2 + 8) = 0;
    *(_DWORD *)(v2 + 12) = 0;
    *(_DWORD *)(v2 + 16) = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005C1AB) --------------------------------------------------------
#error "1005C1B7: call analysis failed (funcsize=7)"

//----- (1005C1D0) --------------------------------------------------------
int __usercall sub_1005C1D0<eax>(int a1<ebp>)
{
  int v1; // esi@4
  int result; // eax@1
  int v3; // ecx@2

  result = *(_DWORD *)(a1 - 16) & 1;
  if ( *(_DWORD *)(a1 - 16) & 1 )
  {
    *(_DWORD *)(a1 - 16) &= 0xFFFFFFFEu;
    v3 = *(_DWORD *)(a1 + 8);
    v1 = *(_DWORD *)(a1 + 8);
    result = *(_DWORD *)(v3 + 24);
    if ( result )
    {
      result = sub_1002A4AA(*(LPVOID *)(v3 + 24));
      *(_DWORD *)(v1 + 24) = 0;
      *(_DWORD *)(v1 + 28) = 0;
      *(_DWORD *)(v1 + 32) = 0;
    }
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005C1E9) --------------------------------------------------------
#error "1005C1F5: call analysis failed (funcsize=7)"

//----- (1005C210) --------------------------------------------------------
void __usercall sub_1005C210(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 16));
}

//----- (1005C218) --------------------------------------------------------
void __usercall sub_1005C218(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 + 8));
}

//----- (1005C220) --------------------------------------------------------
#error "1005C22C: call analysis failed (funcsize=7)"

//----- (1005C240) --------------------------------------------------------
int __usercall sub_1005C240<eax>(int a1<ebp>)
{
  char v1; // zf@2
  int v2; // ecx@4
  int result; // eax@1
  int v4; // esi@1

  v4 = a1 - 36;
  result = *(_DWORD *)(a1 - 36);
  if ( *(_DWORD *)(a1 - 36) )
  {
    v1 = *(_DWORD *)(result + 32)-- == 1;
    if ( v1 )
      result = sub_100183F0(*(_DWORD *)(a1 - 36), 0);
  }
  *(_DWORD *)v4 = 0;
  v2 = *(_DWORD *)(v4 + 12);
  if ( v2 )
  {
    result = (*(int (**)(void))(*(_DWORD *)v2 + 8))();
    if ( result )
      result = (**(int (__thiscall ***)(_DWORD, _DWORD))result)(result, 1);
  }
  return result;
}

//----- (1005C248) --------------------------------------------------------
void __cdecl sub_1005C248()
{
  JUMPOUT(*(unsigned int *)loc_10018B70);
}
// 10018B70: using guessed type int loc_10018B70();

//----- (1005C253) --------------------------------------------------------
void __cdecl sub_1005C253()
{
  JUMPOUT(*(unsigned int *)loc_10018B70);
}
// 10018B70: using guessed type int loc_10018B70();

//----- (1005C25E) --------------------------------------------------------
int __usercall sub_1005C25E<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 60);
}

//----- (1005C266) --------------------------------------------------------
#error "1005C275: call analysis failed (funcsize=10)"

//----- (1005C290) --------------------------------------------------------
void __usercall sub_1005C290(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 16));
}

//----- (1005C298) --------------------------------------------------------
#error "1005C2A4: call analysis failed (funcsize=7)"

//----- (1005C2C0) --------------------------------------------------------
void __usercall sub_1005C2C0(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 16));
}

//----- (1005C2C8) --------------------------------------------------------
#error "1005C2D4: call analysis failed (funcsize=7)"

//----- (1005C2F0) --------------------------------------------------------
int __usercall sub_1005C2F0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 48);
}

//----- (1005C2F8) --------------------------------------------------------
#error "1005C304: call analysis failed (funcsize=10)"

//----- (1005C320) --------------------------------------------------------
void __usercall sub_1005C320(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 16));
}

//----- (1005C328) --------------------------------------------------------
void __usercall sub_1005C328(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 20));
}

//----- (1005C330) --------------------------------------------------------
#error "1005C33C: call analysis failed (funcsize=7)"

//----- (1005C350) --------------------------------------------------------
#error "1005C35C: call analysis failed (funcsize=7)"

//----- (1005C370) --------------------------------------------------------
#error "1005C37C: call analysis failed (funcsize=7)"

//----- (1005C390) --------------------------------------------------------
void __usercall sub_1005C390(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 28));
}

//----- (1005C398) --------------------------------------------------------
#error "1005C3A4: call analysis failed (funcsize=10)"

//----- (1005C3C0) --------------------------------------------------------
void __cdecl sub_1005C3C0()
{
  JUMPOUT(*(unsigned int *)loc_10019910);
}
// 10019910: using guessed type int loc_10019910();

//----- (1005C3C8) --------------------------------------------------------
void __cdecl sub_1005C3C8()
{
  JUMPOUT(*(unsigned int *)loc_100198B0);
}
// 100198B0: using guessed type int loc_100198B0();

//----- (1005C3D0) --------------------------------------------------------
void __cdecl sub_1005C3D0()
{
  JUMPOUT(*(unsigned int *)loc_10019910);
}
// 10019910: using guessed type int loc_10019910();

//----- (1005C3D8) --------------------------------------------------------
void __cdecl sub_1005C3D8()
{
  JUMPOUT(*(unsigned int *)loc_100198B0);
}
// 100198B0: using guessed type int loc_100198B0();

//----- (1005C3E0) --------------------------------------------------------
#error "1005C3EC: call analysis failed (funcsize=10)"

//----- (1005C410) --------------------------------------------------------
int __usercall sub_1005C410<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = a1 - 80;
  *(_DWORD *)(a1 - 80 + 16) = 0;
  result = *(_DWORD *)(a1 - 80 + 4);
  if ( result )
  {
    result = sub_1002A4AA(*(LPVOID *)(a1 - 80 + 4));
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
    *(_DWORD *)(v2 + 12) = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005C418) --------------------------------------------------------
int __usercall sub_1005C418<eax>(int a1<ebp>)
{
  int result; // eax@3
  int v2; // esi@1

  v2 = a1 - 80;
  if ( *(_DWORD *)(a1 - 80 + 20) )
  {
    sub_1002A4AA(*(LPVOID *)(a1 - 80 + 20));
    *(_DWORD *)(v2 + 20) = 0;
    *(_DWORD *)(v2 + 24) = 0;
    *(_DWORD *)(v2 + 28) = 0;
  }
  *(_DWORD *)(v2 + 16) = 0;
  result = *(_DWORD *)(v2 + 4);
  if ( result )
  {
    result = sub_1002A4AA(*(LPVOID *)(v2 + 4));
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
    *(_DWORD *)(v2 + 12) = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005C420) --------------------------------------------------------
void __cdecl sub_1005C420()
{
  JUMPOUT(*(unsigned int *)loc_10019910);
}
// 10019910: using guessed type int loc_10019910();

//----- (1005C428) --------------------------------------------------------
void __cdecl sub_1005C428()
{
  JUMPOUT(*(unsigned int *)loc_100198B0);
}
// 100198B0: using guessed type int loc_100198B0();

//----- (1005C430) --------------------------------------------------------
#error "1005C43C: call analysis failed (funcsize=10)"

//----- (1005C460) --------------------------------------------------------
void __cdecl sub_1005C460()
{
  JUMPOUT(*(unsigned int *)loc_10019910);
}
// 10019910: using guessed type int loc_10019910();

//----- (1005C468) --------------------------------------------------------
void __cdecl sub_1005C468()
{
  JUMPOUT(*(unsigned int *)loc_100198B0);
}
// 100198B0: using guessed type int loc_100198B0();

//----- (1005C470) --------------------------------------------------------
#error "1005C47C: call analysis failed (funcsize=10)"

//----- (1005C4A0) --------------------------------------------------------
int __usercall sub_1005C4A0<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 96));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005C4AB) --------------------------------------------------------
int __usercall sub_1005C4AB<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 100) & 1;
  if ( *(_DWORD *)(a2 - 100) & 1 )
  {
    *(_DWORD *)(a2 - 100) &= 0xFFFFFFFEu;
    result = sub_10001880(a2 - 92);
  }
  return result;
}

//----- (1005C4C4) --------------------------------------------------------
#error "1005C4D0: call analysis failed (funcsize=7)"

//----- (1005C4E0) --------------------------------------------------------
void __usercall sub_1005C4E0(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 16));
}

//----- (1005C4E8) --------------------------------------------------------
#error "1005C4F4: call analysis failed (funcsize=7)"

//----- (1005C510) --------------------------------------------------------
void __cdecl sub_1005C510()
{
  JUMPOUT(*(unsigned int *)loc_10019910);
}
// 10019910: using guessed type int loc_10019910();

//----- (1005C518) --------------------------------------------------------
#error "1005C524: call analysis failed (funcsize=11)"

//----- (1005C540) --------------------------------------------------------
int __usercall sub_1005C540<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 64);
}

//----- (1005C548) --------------------------------------------------------
#error "1005C554: call analysis failed (funcsize=7)"

//----- (1005C570) --------------------------------------------------------
int __usercall sub_1005C570<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 16) & 1;
  if ( *(_DWORD *)(a2 - 16) & 1 )
  {
    *(_DWORD *)(a2 - 16) &= 0xFFFFFFFEu;
    result = sub_10001880(*(_DWORD *)(a2 + 8));
  }
  return result;
}

//----- (1005C589) --------------------------------------------------------
#error "1005C595: call analysis failed (funcsize=7)"

//----- (1005C5B0) --------------------------------------------------------
void __usercall sub_1005C5B0(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 + 12));
}

//----- (1005C5B8) --------------------------------------------------------
#error "1005C5C4: call analysis failed (funcsize=7)"

//----- (1005C5E0) --------------------------------------------------------
int __usercall sub_1005C5E0<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 68) & 1;
  if ( *(_DWORD *)(a2 - 68) & 1 )
  {
    *(_DWORD *)(a2 - 68) &= 0xFFFFFFFEu;
    result = sub_10001880(a2 - 40);
  }
  return result;
}

//----- (1005C5F9) --------------------------------------------------------
#error "1005C605: call analysis failed (funcsize=7)"

//----- (1005C620) --------------------------------------------------------
void __usercall sub_1005C620(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 48));
}

//----- (1005C628) --------------------------------------------------------
#error "1005C634: call analysis failed (funcsize=10)"

//----- (1005C650) --------------------------------------------------------
int __usercall sub_1005C650<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 8);
}

//----- (1005C658) --------------------------------------------------------
int __usercall sub_1005C658<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 44);
}

//----- (1005C660) --------------------------------------------------------
#error "1005C66C: call analysis failed (funcsize=7)"

//----- (1005C680) --------------------------------------------------------
int __cdecl sub_1005C680()
{
  return sub_10001880((int)&unk_10075FB8);
}

//----- (1005C68A) --------------------------------------------------------
#error "1005C696: call analysis failed (funcsize=7)"

//----- (1005C6B0) --------------------------------------------------------
int __usercall sub_1005C6B0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 8);
}

//----- (1005C6B8) --------------------------------------------------------
int __usercall sub_1005C6B8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 96);
}

//----- (1005C6C0) --------------------------------------------------------
int __usercall sub_1005C6C0<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 100));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005C6CB) --------------------------------------------------------
#error "1005C6D7: call analysis failed (funcsize=10)"

//----- (1005C6F0) --------------------------------------------------------
int __cdecl sub_1005C6F0()
{
  return sub_10001880((int)&unk_10076060);
}

//----- (1005C6FA) --------------------------------------------------------
#error "1005C706: call analysis failed (funcsize=7)"

//----- (1005C720) --------------------------------------------------------
int __usercall sub_1005C720<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 12);
}

//----- (1005C728) --------------------------------------------------------
int __usercall sub_1005C728<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 100);
}

//----- (1005C730) --------------------------------------------------------
int __usercall sub_1005C730<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 104));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005C73B) --------------------------------------------------------
#error "1005C747: call analysis failed (funcsize=10)"

//----- (1005C760) --------------------------------------------------------
#error "1005C76C: call analysis failed (funcsize=7)"

//----- (1005C780) --------------------------------------------------------
int __usercall sub_1005C780<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 16) & 1;
  if ( *(_DWORD *)(a1 - 16) & 1 )
  {
    *(_DWORD *)(a1 - 16) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005C799) --------------------------------------------------------
#error "1005C7A5: call analysis failed (funcsize=7)"

//----- (1005C7C0) --------------------------------------------------------
int __usercall sub_1005C7C0<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 16) & 1;
  if ( *(_DWORD *)(a1 - 16) & 1 )
  {
    *(_DWORD *)(a1 - 16) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005C7D9) --------------------------------------------------------
#error "1005C7E5: call analysis failed (funcsize=7)"

//----- (1005C800) --------------------------------------------------------
int *__usercall sub_1005C800<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10026C50(a2 - 28);
}

//----- (1005C808) --------------------------------------------------------
void __cdecl sub_1005C808()
{
  JUMPOUT(*(unsigned int *)loc_10023420);
}
// 10023420: using guessed type int loc_10023420();

//----- (1005C810) --------------------------------------------------------
void __cdecl sub_1005C810()
{
  JUMPOUT(*(unsigned int *)loc_10023420);
}
// 10023420: using guessed type int loc_10023420();

//----- (1005C81B) --------------------------------------------------------
int __usercall sub_1005C81B<eax>(int a1<ebp>)
{
  return sub_1002C0CF(a1);
}

//----- (1005C823) --------------------------------------------------------
int __usercall sub_1005C823<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10026F10((void *)(a2 - 136));
}

//----- (1005C82E) --------------------------------------------------------
#error "1005C83D: call analysis failed (funcsize=10)"

//----- (1005C860) --------------------------------------------------------
int __usercall sub_1005C860<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 28));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005C86B) --------------------------------------------------------
void __cdecl sub_1005C86B()
{
  JUMPOUT(*(unsigned int *)loc_1000A390);
}
// 1000A390: using guessed type int loc_1000A390();

//----- (1005C873) --------------------------------------------------------
int __thiscall sub_1005C873(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005C887) --------------------------------------------------------
int __usercall sub_1005C887<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 24) & 1;
  if ( *(_DWORD *)(a1 - 24) & 1 )
  {
    *(_DWORD *)(a1 - 24) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005C8A0) --------------------------------------------------------
#error "1005C8AC: call analysis failed (funcsize=7)"

//----- (1005C8C0) --------------------------------------------------------
void __usercall sub_1005C8C0(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_10025F00(*(_DWORD *)(a3 - 16) + 4, a2);
}

//----- (1005C8CB) --------------------------------------------------------
#error "1005C8D7: call analysis failed (funcsize=7)"

//----- (1005C8F0) --------------------------------------------------------
void __cdecl sub_1005C8F0()
{
  JUMPOUT(*(unsigned int *)loc_10023420);
}
// 10023420: using guessed type int loc_10023420();

//----- (1005C8F8) --------------------------------------------------------
void __cdecl sub_1005C8F8()
{
  JUMPOUT(loc_10024010);
}

//----- (1005C903) --------------------------------------------------------
void __usercall sub_1005C903(void *a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_100238D0((void *)(*(_DWORD *)(a3 - 16) + 24), a2);
}

//----- (1005C90E) --------------------------------------------------------
int __usercall sub_1005C90E<eax>(int a1<ebp>)
{
  return j_nullsub_2(*(_DWORD *)(a1 - 16) + 176);
}
// 10028260: using guessed type int __thiscall j_nullsub_2(_DWORD);

//----- (1005C91C) --------------------------------------------------------
#error "1005C928: call analysis failed (funcsize=7)"

//----- (1005C940) --------------------------------------------------------
void __usercall sub_1005C940(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = &off_10069284;
}
// 10069284: using guessed type int (__stdcall *off_10069284)(char);

//----- (1005C948) --------------------------------------------------------
int __usercall sub_1005C948<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10024F90((void *)(*(_DWORD *)(a2 - 16) + 4));
}

//----- (1005C953) --------------------------------------------------------
void __usercall sub_1005C953(void *a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_100238D0((void *)(*(_DWORD *)(a3 - 16) + 96), a2);
}

//----- (1005C95E) --------------------------------------------------------
#error "1005C96A: call analysis failed (funcsize=7)"

//----- (1005C980) --------------------------------------------------------
int __usercall sub_1005C980<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 16));
}

//----- (1005C988) --------------------------------------------------------
int __usercall sub_1005C988<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 16) + 24);
}

//----- (1005C993) --------------------------------------------------------
int __usercall sub_1005C993<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 16) + 48);
}

//----- (1005C99E) --------------------------------------------------------
int __usercall sub_1005C99E<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 16) + 88);
}

//----- (1005C9A9) --------------------------------------------------------
void __cdecl sub_1005C9A9()
{
  JUMPOUT(*(unsigned int *)loc_10018540);
}
// 10018540: using guessed type int loc_10018540();

//----- (1005C9B7) --------------------------------------------------------
void __cdecl sub_1005C9B7()
{
  JUMPOUT(*(unsigned int *)loc_10018540);
}
// 10018540: using guessed type int loc_10018540();

//----- (1005C9C5) --------------------------------------------------------
int __usercall sub_1005C9C5<eax>(int a1<ebp>)
{
  return sub_10022FB0(*(_DWORD *)(a1 - 16) + 224);
}
// 10022FB0: using guessed type int __thiscall sub_10022FB0(_DWORD);

//----- (1005C9D3) --------------------------------------------------------
int __usercall sub_1005C9D3<eax>(int a1<ebp>)
{
  return sub_100230B0(*(_DWORD *)(a1 - 16) + 236);
}
// 100230B0: using guessed type int __thiscall sub_100230B0(_DWORD);

//----- (1005C9E1) --------------------------------------------------------
void __cdecl sub_1005C9E1()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005C9E9) --------------------------------------------------------
int __usercall sub_1005C9E9<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 - 48);
}

//----- (1005C9F1) --------------------------------------------------------
int __usercall sub_1005C9F1<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10023430(*(_DWORD *)(a3 - 20), a2);
}

//----- (1005C9F9) --------------------------------------------------------
void __cdecl sub_1005C9F9()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005CA01) --------------------------------------------------------
int __usercall sub_1005CA01<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(*(_DWORD *)(a2 - 20) + 248);
}

//----- (1005CA0F) --------------------------------------------------------
int __usercall sub_1005CA0F<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100230C0(*(_DWORD *)(a3 - 16) + 256, a2);
}

//----- (1005CA1D) --------------------------------------------------------
void __cdecl sub_1005CA1D()
{
  JUMPOUT(*(unsigned int *)loc_10023D80);
}
// 10023D80: using guessed type int loc_10023D80();

//----- (1005CA2B) --------------------------------------------------------
void __cdecl sub_1005CA2B()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005CA39) --------------------------------------------------------
int __usercall sub_1005CA39<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 16) + 540);
}
// 1002B6E4: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005CA47) --------------------------------------------------------
int __usercall sub_1005CA47<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 16) + 580);
}
// 1002B6E4: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005CA55) --------------------------------------------------------
#error "1005CA61: call analysis failed (funcsize=7)"

//----- (1005CA70) --------------------------------------------------------
void __cdecl sub_1005CA70()
{
  JUMPOUT(*(unsigned int *)loc_10024D30);
}
// 10024D30: using guessed type int loc_10024D30();

//----- (1005CA7B) --------------------------------------------------------
#error "1005CA87: call analysis failed (funcsize=7)"

//----- (1005CAA0) --------------------------------------------------------
void __cdecl sub_1005CAA0()
{
  JUMPOUT(*(unsigned int *)loc_10023420);
}
// 10023420: using guessed type int loc_10023420();

//----- (1005CAA8) --------------------------------------------------------
int __usercall sub_1005CAA8<eax>(int a1<ebp>)
{
  return sub_1002C0CF(a1);
}

//----- (1005CAB3) --------------------------------------------------------
int __usercall sub_1005CAB3<eax>(int a1<ebp>)
{
  return j_nullsub_2(*(_DWORD *)(a1 - 16) + 52);
}
// 10028260: using guessed type int __thiscall j_nullsub_2(_DWORD);

//----- (1005CABE) --------------------------------------------------------
void __cdecl sub_1005CABE()
{
  JUMPOUT(loc_10024010);
}

//----- (1005CAC9) --------------------------------------------------------
#error "1005CAD5: call analysis failed (funcsize=7)"

//----- (1005CAF0) --------------------------------------------------------
int __usercall sub_1005CAF0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10023430(*(_DWORD *)(a3 - 16), a2);
}

//----- (1005CAF8) --------------------------------------------------------
int __usercall sub_1005CAF8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(*(_DWORD *)(a2 - 16) + 248);
}

//----- (1005CB06) --------------------------------------------------------
#error "1005CB12: call analysis failed (funcsize=7)"

//----- (1005CB30) --------------------------------------------------------
void __usercall sub_1005CB30(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_10029FBF(*(_DWORD *)(a3 - 16), a2);
}

//----- (1005CB38) --------------------------------------------------------
#error "1005CB44: call analysis failed (funcsize=7)"

//----- (1005CB60) --------------------------------------------------------
void __cdecl sub_1005CB60()
{
  JUMPOUT(*(unsigned int *)loc_10024D30);
}
// 10024D30: using guessed type int loc_10024D30();

//----- (1005CB6B) --------------------------------------------------------
#error "1005CB77: call analysis failed (funcsize=7)"

//----- (1005CB90) --------------------------------------------------------
void __usercall sub_1005CB90(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_10025F00(*(_DWORD *)(a3 - 16) + 4, a2);
}

//----- (1005CB9B) --------------------------------------------------------
int __usercall sub_1005CB9B<eax>(int a1<ebp>)
{
  return j_nullsub_2(*(_DWORD *)(a1 - 16) + 24);
}
// 10028260: using guessed type int __thiscall j_nullsub_2(_DWORD);

//----- (1005CBA6) --------------------------------------------------------
int __usercall sub_1005CBA6<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(*(_DWORD *)(a2 - 16) + 80);
}

//----- (1005CBB1) --------------------------------------------------------
int __usercall sub_1005CBB1<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(*(_DWORD *)(a2 - 16) + 104);
}

//----- (1005CBBC) --------------------------------------------------------
int __usercall sub_1005CBBC<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(*(_DWORD *)(a2 - 16) + 128);
}

//----- (1005CBCA) --------------------------------------------------------
#error "1005CBD6: call analysis failed (funcsize=7)"

//----- (1005CBF0) --------------------------------------------------------
void __cdecl sub_1005CBF0()
{
  JUMPOUT(*(unsigned int *)loc_10023420);
}
// 10023420: using guessed type int loc_10023420();

//----- (1005CBF8) --------------------------------------------------------
void __cdecl sub_1005CBF8()
{
  JUMPOUT(loc_10024010);
}

//----- (1005CC03) --------------------------------------------------------
void __usercall sub_1005CC03(void *a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_100238D0((void *)(*(_DWORD *)(a3 - 16) + 24), a2);
}

//----- (1005CC0E) --------------------------------------------------------
int __usercall sub_1005CC0E<eax>(int a1<ebp>)
{
  return j_nullsub_2(*(_DWORD *)(a1 - 16) + 176);
}
// 10028260: using guessed type int __thiscall j_nullsub_2(_DWORD);

//----- (1005CC1C) --------------------------------------------------------
#error "1005CC28: call analysis failed (funcsize=7)"

//----- (1005CC40) --------------------------------------------------------
int __usercall sub_1005CC40<eax>(int a1<ebp>)
{
  return j_nullsub_2(*(_DWORD *)(a1 - 16));
}
// 10028260: using guessed type int __thiscall j_nullsub_2(_DWORD);

//----- (1005CC48) --------------------------------------------------------
void __cdecl sub_1005CC48()
{
  JUMPOUT(*(unsigned int *)loc_10024D30);
}
// 10024D30: using guessed type int loc_10024D30();

//----- (1005CC53) --------------------------------------------------------
#error "1005CC5F: call analysis failed (funcsize=7)"

//----- (1005CC70) --------------------------------------------------------
void __cdecl sub_1005CC70()
{
  JUMPOUT(*(unsigned int *)loc_100238B0);
}
// 100238B0: using guessed type int loc_100238B0();

//----- (1005CC78) --------------------------------------------------------
int __usercall sub_1005CC78<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10024F90((void *)(*(_DWORD *)(a2 - 16) + 4));
}

//----- (1005CC83) --------------------------------------------------------
void __usercall sub_1005CC83(void *a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_100238D0((void *)(*(_DWORD *)(a3 - 16) + 96), a2);
}

//----- (1005CC8E) --------------------------------------------------------
int __usercall sub_1005CC8E<eax>(int a1<ebp>)
{
  return j_nullsub_2(*(_DWORD *)(a1 - 20));
}
// 10028260: using guessed type int __thiscall j_nullsub_2(_DWORD);

//----- (1005CC96) --------------------------------------------------------
void __cdecl sub_1005CC96()
{
  JUMPOUT(*(unsigned int *)loc_10024D30);
}
// 10024D30: using guessed type int loc_10024D30();

//----- (1005CCA1) --------------------------------------------------------
#error "1005CCAD: call analysis failed (funcsize=7)"

//----- (1005CCC0) --------------------------------------------------------
void __usercall sub_1005CCC0(int this<ecx>, int a2<ebp>)
{
  sub_1003119B(*(_DWORD *)(a2 - 20));
}

//----- (1005CCC8) --------------------------------------------------------
void __usercall sub_1005CCC8(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>)
{
  sub_10024130(*(_DWORD *)(a4 - 20) + 16, a2, a3);
}

//----- (1005CCD3) --------------------------------------------------------
#error "1005CCDF: call analysis failed (funcsize=7)"

//----- (1005CCF0) --------------------------------------------------------
int __usercall sub_1005CCF0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 16));
}

//----- (1005CCF8) --------------------------------------------------------
int __usercall sub_1005CCF8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 16) + 24);
}

//----- (1005CD03) --------------------------------------------------------
int __usercall sub_1005CD03<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 16) + 48);
}

//----- (1005CD0E) --------------------------------------------------------
int __usercall sub_1005CD0E<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 16) + 88);
}

//----- (1005CD19) --------------------------------------------------------
int __usercall sub_1005CD19<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = *(_DWORD *)(a1 - 16) + 136;
  result = *(_DWORD *)(*(_DWORD *)(a1 - 16) + 164);
  if ( result )
  {
    result = sub_1002A4AA(*(LPVOID *)(*(_DWORD *)(a1 - 16) + 164));
    *(_DWORD *)(v2 + 28) = 0;
    *(_DWORD *)(v2 + 32) = 0;
    *(_DWORD *)(v2 + 36) = 0;
  }
  if ( *(_DWORD *)(v2 + 24) >= 0x10u )
    result = sub_1002A4AA(*(LPVOID *)(v2 + 4));
  *(_DWORD *)(v2 + 24) = 15;
  *(_DWORD *)(v2 + 20) = 0;
  *(_BYTE *)(v2 + 4) = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005CD27) --------------------------------------------------------
void __cdecl sub_1005CD27()
{
  JUMPOUT(*(unsigned int *)loc_10018540);
}
// 10018540: using guessed type int loc_10018540();

//----- (1005CD35) --------------------------------------------------------
int __usercall sub_1005CD35<eax>(int a1<ebp>)
{
  return sub_10022FB0(*(_DWORD *)(a1 - 16) + 224);
}
// 10022FB0: using guessed type int __thiscall sub_10022FB0(_DWORD);

//----- (1005CD43) --------------------------------------------------------
int __usercall sub_1005CD43<eax>(int a1<ebp>)
{
  return sub_100230B0(*(_DWORD *)(a1 - 16) + 236);
}
// 100230B0: using guessed type int __thiscall sub_100230B0(_DWORD);

//----- (1005CD51) --------------------------------------------------------
int __usercall sub_1005CD51<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100230C0(*(_DWORD *)(a3 - 16) + 256, a2);
}

//----- (1005CD5F) --------------------------------------------------------
void __cdecl sub_1005CD5F()
{
  JUMPOUT(*(unsigned int *)loc_10023D80);
}
// 10023D80: using guessed type int loc_10023D80();

//----- (1005CD6D) --------------------------------------------------------
void __cdecl sub_1005CD6D()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005CD7B) --------------------------------------------------------
int __usercall sub_1005CD7B<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 16) + 540);
}
// 1002B6E4: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005CD89) --------------------------------------------------------
int __usercall sub_1005CD89<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 16) + 580);
}
// 1002B6E4: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005CD97) --------------------------------------------------------
int __usercall sub_1005CD97<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 16) + 612);
}
// 1002B6E4: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005CDA5) --------------------------------------------------------
#error "1005CDB1: call analysis failed (funcsize=7)"

//----- (1005CDC0) --------------------------------------------------------
char __usercall sub_1005CDC0<al>(void *this<ecx>, int a2<ebp>)
{
  return sub_1002B6E5((void *)(a2 - 20));
}

//----- (1005CDC8) --------------------------------------------------------
#error "1005CDD4: call analysis failed (funcsize=10)"

//----- (1005CDF0) --------------------------------------------------------
void __cdecl sub_1005CDF0()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005CDF8) --------------------------------------------------------
int __usercall sub_1005CDF8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 40, a2);
}

//----- (1005CE00) --------------------------------------------------------
int __usercall sub_1005CE00<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 80, a2);
}

//----- (1005CE08) --------------------------------------------------------
int __usercall sub_1005CE08<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 304, a2);
}

//----- (1005CE13) --------------------------------------------------------
int __usercall sub_1005CE13<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 96, a2);
}

//----- (1005CE1B) --------------------------------------------------------
int __usercall sub_1005CE1B<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 260);
}

//----- (1005CE26) --------------------------------------------------------
int __usercall sub_1005CE26<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 212);
}

//----- (1005CE31) --------------------------------------------------------
int __usercall sub_1005CE31<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 112, a2);
}

//----- (1005CE39) --------------------------------------------------------
int __usercall sub_1005CE39<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 140);
}

//----- (1005CE44) --------------------------------------------------------
int __usercall sub_1005CE44<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 164);
}

//----- (1005CE4F) --------------------------------------------------------
int __usercall sub_1005CE4F<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 188);
}

//----- (1005CE5A) --------------------------------------------------------
int __usercall sub_1005CE5A<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 236);
}

//----- (1005CE65) --------------------------------------------------------
int __usercall sub_1005CE65<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 284);
}

//----- (1005CE70) --------------------------------------------------------
int __usercall sub_1005CE70<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 328);
}

//----- (1005CE7B) --------------------------------------------------------
#error "1005CE8A: call analysis failed (funcsize=10)"

//----- (1005CEB0) --------------------------------------------------------
int __usercall sub_1005CEB0<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 24));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005CEBB) --------------------------------------------------------
void __usercall sub_1005CEBB(int this<ecx>, int a2<ebp>)
{
  sub_1003119B(*(_DWORD *)(a2 - 24));
}

//----- (1005CEC3) --------------------------------------------------------
void __usercall sub_1005CEC3(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>)
{
  sub_10024130(*(_DWORD *)(a4 - 24) + 16, a2, a3);
}

//----- (1005CECE) --------------------------------------------------------
#error "1005CEDA: call analysis failed (funcsize=7)"

//----- (1005CEF0) --------------------------------------------------------
void __cdecl sub_1005CEF0()
{
  sub_1002B6D6();
}

//----- (1005CEF8) --------------------------------------------------------
void __cdecl sub_1005CEF8()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005CF00) --------------------------------------------------------
#error "1005CF0C: call analysis failed (funcsize=10)"

//----- (1005CF30) --------------------------------------------------------
void __cdecl sub_1005CF30()
{
  sub_1002B6D6();
}

//----- (1005CF38) --------------------------------------------------------
void __cdecl sub_1005CF38()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005CF40) --------------------------------------------------------
#error "1005CF4C: call analysis failed (funcsize=10)"

//----- (1005CF70) --------------------------------------------------------
void __usercall sub_1005CF70(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = &off_10069340;
}
// 10069340: using guessed type int (__stdcall *off_10069340)(char);

//----- (1005CF78) --------------------------------------------------------
#error "1005CF84: call analysis failed (funcsize=7)"

//----- (1005CFA0) --------------------------------------------------------
int __usercall sub_1005CFA0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 8);
}

//----- (1005CFA8) --------------------------------------------------------
void __cdecl sub_1005CFA8()
{
  sub_1002B6D6();
}

//----- (1005CFB0) --------------------------------------------------------
#error "1005CFBC: call analysis failed (funcsize=10)"

//----- (1005CFE0) --------------------------------------------------------
char __usercall sub_1005CFE0<al>(void *this<ecx>, int a2<ebp>)
{
  return sub_1002B6E5((void *)(a2 - 44));
}

//----- (1005CFE8) --------------------------------------------------------
int __usercall sub_1005CFE8<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int result; // eax@2

  v1 = *(_DWORD *)(a1 - 48);
  if ( v1 )
    result = (**(int (__stdcall ***)(_DWORD))v1)(1);
  return result;
}

//----- (1005CFF0) --------------------------------------------------------
#error "1005CFFC: call analysis failed (funcsize=10)"

//----- (1005D020) --------------------------------------------------------
int __usercall sub_1005D020<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 12);
}

//----- (1005D028) --------------------------------------------------------
void __cdecl sub_1005D028()
{
  sub_1002B6D6();
}

//----- (1005D030) --------------------------------------------------------
void __cdecl sub_1005D030()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005D038) --------------------------------------------------------
int __usercall sub_1005D038<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 88));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005D043) --------------------------------------------------------
int __usercall sub_1005D043<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 72) & 1;
  if ( *(_DWORD *)(a1 - 72) & 1 )
  {
    *(_DWORD *)(a1 - 72) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005D05C) --------------------------------------------------------
void __cdecl sub_1005D05C()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005D064) --------------------------------------------------------
int __usercall sub_1005D064<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int result; // eax@2

  v1 = *(_DWORD *)(a1 - 84 + 4);
  if ( v1 )
  {
    result = v1 + 8;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _ZF )
      result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v1 + 4))(v1, _EDX);
  }
  return result;
}

//----- (1005D06C) --------------------------------------------------------
#error "1005D078: call analysis failed (funcsize=10)"

//----- (1005D0A0) --------------------------------------------------------
int __usercall sub_1005D0A0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 64);
}

//----- (1005D0A8) --------------------------------------------------------
int __usercall sub_1005D0A8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 40);
}

//----- (1005D0B0) --------------------------------------------------------
int __usercall sub_1005D0B0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 16);
}

//----- (1005D0B8) --------------------------------------------------------
void __cdecl sub_1005D0B8()
{
  sub_1002B6D6();
}

//----- (1005D0C0) --------------------------------------------------------
#error "1005D0CC: call analysis failed (funcsize=10)"

//----- (1005D0F0) --------------------------------------------------------
int __usercall sub_1005D0F0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 52, a2);
}

//----- (1005D0F8) --------------------------------------------------------
int __usercall sub_1005D0F8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005D100) --------------------------------------------------------
int __usercall sub_1005D100<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005D108) --------------------------------------------------------
int __usercall sub_1005D108<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005D110) --------------------------------------------------------
int __usercall sub_1005D110<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005D118) --------------------------------------------------------
int __usercall sub_1005D118<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005D120) --------------------------------------------------------
int __usercall sub_1005D120<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005D128) --------------------------------------------------------
int __usercall sub_1005D128<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005D130) --------------------------------------------------------
int __usercall sub_1005D130<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005D138) --------------------------------------------------------
int __usercall sub_1005D138<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005D140) --------------------------------------------------------
int __usercall sub_1005D140<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005D148) --------------------------------------------------------
int __usercall sub_1005D148<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(*(_DWORD *)(a3 - 72), a2);
}

//----- (1005D150) --------------------------------------------------------
void __cdecl sub_1005D150()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005D158) --------------------------------------------------------
int __usercall sub_1005D158<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 64) & 1;
  if ( *(_DWORD *)(a1 - 64) & 1 )
  {
    *(_DWORD *)(a1 - 64) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005D171) --------------------------------------------------------
#error "1005D17D: call analysis failed (funcsize=10)"

//----- (1005D1A0) --------------------------------------------------------
void __cdecl sub_1005D1A0()
{
  sub_1002B6D6();
}

//----- (1005D1A8) --------------------------------------------------------
void __cdecl sub_1005D1A8()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005D1B0) --------------------------------------------------------
#error "1005D1BC: call analysis failed (funcsize=11)"

//----- (1005D1E0) --------------------------------------------------------
void __cdecl sub_1005D1E0()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005D1E8) --------------------------------------------------------
void __cdecl sub_1005D1E8()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005D1F0) --------------------------------------------------------
void __cdecl sub_1005D1F0()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005D1F8) --------------------------------------------------------
int __usercall sub_1005D1F8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 - 72);
}

//----- (1005D200) --------------------------------------------------------
void __cdecl sub_1005D200()
{
  sub_1002B6D6();
}

//----- (1005D208) --------------------------------------------------------
#error "1005D214: call analysis failed (funcsize=11)"

//----- (1005D230) --------------------------------------------------------
void __cdecl sub_1005D230()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005D238) --------------------------------------------------------
int __usercall sub_1005D238<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 - 80);
}

//----- (1005D240) --------------------------------------------------------
void __cdecl sub_1005D240()
{
  sub_1002B6D6();
}

//----- (1005D248) --------------------------------------------------------
#error "1005D254: call analysis failed (funcsize=11)"

//----- (1005D270) --------------------------------------------------------
void __usercall sub_1005D270(void *this<ecx>, int a2<ebp>)
{
  sub_1002B6DD((void *)(a2 - 44));
}

//----- (1005D278) --------------------------------------------------------
#error "1005D284: call analysis failed (funcsize=10)"

//----- (1005D2A0) --------------------------------------------------------
int __usercall sub_1005D2A0<eax>(int a1<ebp>)
{
  return sub_1000A680(*(_DWORD *)(a1 - 16));
}
// 1000A680: using guessed type _DWORD __cdecl sub_1000A680(_DWORD);

//----- (1005D2AB) --------------------------------------------------------
#error "1005D2B7: call analysis failed (funcsize=7)"

//----- (1005D2D0) --------------------------------------------------------
int __usercall sub_1005D2D0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 + 8);
}

//----- (1005D2D8) --------------------------------------------------------
void __cdecl sub_1005D2D8()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005D2E0) --------------------------------------------------------
#error "1005D2EC: call analysis failed (funcsize=7)"

//----- (1005D300) --------------------------------------------------------
void __cdecl sub_1005D300()
{
  sub_1002B6D6();
}

//----- (1005D308) --------------------------------------------------------
#error "1005D314: call analysis failed (funcsize=10)"

//----- (1005D330) --------------------------------------------------------
void __cdecl sub_1005D330()
{
  sub_1002B6D6();
}

//----- (1005D338) --------------------------------------------------------
#error "1005D344: call analysis failed (funcsize=10)"

//----- (1005D360) --------------------------------------------------------
int __usercall sub_1005D360<eax>(int a1<ebp>)
{
  return sub_1000A680(*(_DWORD *)(a1 + 8));
}
// 1000A680: using guessed type _DWORD __cdecl sub_1000A680(_DWORD);

//----- (1005D36B) --------------------------------------------------------
#error "1005D377: call analysis failed (funcsize=7)"

//----- (1005D390) --------------------------------------------------------
int __usercall sub_1005D390<eax>(int a1<ebp>)
{
  return sub_1000A680(*(_DWORD *)(a1 - 48));
}
// 1000A680: using guessed type _DWORD __cdecl sub_1000A680(_DWORD);

//----- (1005D39B) --------------------------------------------------------
void __usercall sub_1005D39B(void *this<ecx>, int a2<ebp>)
{
  sub_1002B6DD((void *)(a2 - 44));
}

//----- (1005D3A3) --------------------------------------------------------
#error "1005D3AF: call analysis failed (funcsize=10)"

//----- (1005D3D0) --------------------------------------------------------
void __cdecl sub_1005D3D0()
{
  JUMPOUT(*(unsigned int *)loc_10024D30);
}
// 10024D30: using guessed type int loc_10024D30();

//----- (1005D3DB) --------------------------------------------------------
#error "1005D3E7: call analysis failed (funcsize=7)"

//----- (1005D400) --------------------------------------------------------
int __usercall sub_1005D400<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 - 40);
}

//----- (1005D408) --------------------------------------------------------
void __cdecl sub_1005D408()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005D410) --------------------------------------------------------
int __usercall sub_1005D410<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 - 64);
}

//----- (1005D418) --------------------------------------------------------
#error "1005D424: call analysis failed (funcsize=7)"

//----- (1005D440) --------------------------------------------------------
void __cdecl sub_1005D440()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005D448) --------------------------------------------------------
int __usercall sub_1005D448<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 - 40);
}

//----- (1005D450) --------------------------------------------------------
#error "1005D45C: call analysis failed (funcsize=7)"

//----- (1005D470) --------------------------------------------------------
void __cdecl sub_1005D470()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005D478) --------------------------------------------------------
int __usercall sub_1005D478<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 - 40);
}

//----- (1005D480) --------------------------------------------------------
#error "1005D48C: call analysis failed (funcsize=7)"

//----- (1005D4A0) --------------------------------------------------------
void __usercall sub_1005D4A0(void *this<ecx>, int a2<ebp>)
{
  sub_1002B6DD((void *)(a2 - 44));
}

//----- (1005D4A8) --------------------------------------------------------
#error "1005D4B4: call analysis failed (funcsize=10)"

//----- (1005D4D0) --------------------------------------------------------
void __usercall sub_1005D4D0(void *this<ecx>, int a2<ebp>)
{
  sub_1002B6DD((void *)(a2 - 44));
}

//----- (1005D4D8) --------------------------------------------------------
#error "1005D4E4: call analysis failed (funcsize=10)"

//----- (1005D500) --------------------------------------------------------
int __usercall sub_1005D500<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = a1 - 56;
  result = *(_DWORD *)(a1 - 56);
  if ( *(_DWORD *)(a1 - 56) )
  {
    result = sub_10030383(*(LPVOID *)(a1 - 56));
    *(_DWORD *)v2 = 0;
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
  }
  return result;
}
// 10030383: using guessed type _DWORD __cdecl sub_10030383(LPVOID lpMem);

//----- (1005D508) --------------------------------------------------------
#error "1005D514: call analysis failed (funcsize=10)"

//----- (1005D530) --------------------------------------------------------
void __usercall sub_1005D530(void *this<ecx>, int a2<ebp>)
{
  sub_1002B6DD((void *)(a2 - 44));
}

//----- (1005D538) --------------------------------------------------------
#error "1005D544: call analysis failed (funcsize=10)"

//----- (1005D560) --------------------------------------------------------
void __usercall sub_1005D560(void *this<ecx>, int a2<ebp>)
{
  sub_1002B6DD((void *)(a2 - 44));
}

//----- (1005D568) --------------------------------------------------------
#error "1005D574: call analysis failed (funcsize=10)"

//----- (1005D590) --------------------------------------------------------
int __usercall sub_1005D590<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_100255C0(a2 - 44);
}

//----- (1005D598) --------------------------------------------------------
void __cdecl sub_1005D598()
{
  JUMPOUT(*(unsigned int *)loc_10024D30);
}
// 10024D30: using guessed type int loc_10024D30();

//----- (1005D5A0) --------------------------------------------------------
#error "1005D5AC: call analysis failed (funcsize=10)"

//----- (1005D5D0) --------------------------------------------------------
void __usercall sub_1005D5D0(void *this<ecx>, int a2<ebp>)
{
  sub_1002B6DD((void *)(a2 - 56));
}

//----- (1005D5D8) --------------------------------------------------------
#error "1005D5E4: call analysis failed (funcsize=10)"

//----- (1005D600) --------------------------------------------------------
void __usercall sub_1005D600(void *this<ecx>, int a2<ebp>)
{
  sub_1002B6DD((void *)(a2 - 56));
}

//----- (1005D608) --------------------------------------------------------
#error "1005D614: call analysis failed (funcsize=10)"

//----- (1005D630) --------------------------------------------------------
void __cdecl sub_1005D630()
{
  sub_1002B6D6();
}

//----- (1005D638) --------------------------------------------------------
#error "1005D644: call analysis failed (funcsize=11)"

//----- (1005D660) --------------------------------------------------------
int __usercall sub_1005D660<eax>(int a1<ebp>)
{
  return sub_10001940(a1 + 8);
}
// 10001940: using guessed type int __thiscall sub_10001940(_DWORD);

//----- (1005D668) --------------------------------------------------------
#error "1005D674: call analysis failed (funcsize=7)"

//----- (1005D690) --------------------------------------------------------
int __usercall sub_1005D690<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 40);
}

//----- (1005D698) --------------------------------------------------------
#error "1005D6A4: call analysis failed (funcsize=7)"

//----- (1005D6C0) --------------------------------------------------------
int __usercall sub_1005D6C0<eax>(int a1<ebp>)
{
  return sub_1002C0CF(a1);
}

//----- (1005D6CB) --------------------------------------------------------
int __usercall sub_1005D6CB<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 16) + 56);
}

//----- (1005D6D6) --------------------------------------------------------
#error "1005D6E2: call analysis failed (funcsize=7)"

//----- (1005D700) --------------------------------------------------------
void __cdecl sub_1005D700()
{
  JUMPOUT(*(unsigned int *)loc_10009DE0);
}
// 10009DE0: using guessed type int loc_10009DE0();

//----- (1005D708) --------------------------------------------------------
void __cdecl sub_1005D708()
{
  JUMPOUT(*(unsigned int *)loc_10009DE0);
}
// 10009DE0: using guessed type int loc_10009DE0();

//----- (1005D713) --------------------------------------------------------
#error "1005D722: call analysis failed (funcsize=10)"

//----- (1005D740) --------------------------------------------------------
int __usercall sub_1005D740<eax>(int a1<ebp>)
{
  return sub_10001940(a1 - 124);
}
// 10001940: using guessed type int __thiscall sub_10001940(_DWORD);

//----- (1005D748) --------------------------------------------------------
int __usercall sub_1005D748<eax>(int a1<ebp>)
{
  return sub_10001940(a1 - 64);
}
// 10001940: using guessed type int __thiscall sub_10001940(_DWORD);

//----- (1005D750) --------------------------------------------------------
int __usercall sub_1005D750<eax>(int a1<ebp>)
{
  return sub_10001940(a1 - 144);
}
// 10001940: using guessed type int __thiscall sub_10001940(_DWORD);

//----- (1005D75B) --------------------------------------------------------
int __usercall sub_1005D75B<eax>(int a1<ebp>)
{
  return sub_10001940(a1 - 84);
}
// 10001940: using guessed type int __thiscall sub_10001940(_DWORD);

//----- (1005D763) --------------------------------------------------------
int __usercall sub_1005D763<eax>(int a1<ebp>)
{
  return sub_10001940(a1 - 44);
}
// 10001940: using guessed type int __thiscall sub_10001940(_DWORD);

//----- (1005D76B) --------------------------------------------------------
int __usercall sub_1005D76B<eax>(int a1<ebp>)
{
  return sub_10001940(a1 - 104);
}
// 10001940: using guessed type int __thiscall sub_10001940(_DWORD);

//----- (1005D773) --------------------------------------------------------
#error "1005D785: call analysis failed (funcsize=11)"

//----- (1005D7B0) --------------------------------------------------------
int __usercall sub_1005D7B0<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 24) & 1;
  if ( *(_DWORD *)(a2 - 24) & 1 )
  {
    *(_DWORD *)(a2 - 24) &= 0xFFFFFFFEu;
    result = sub_10001880(*(_DWORD *)(a2 - 52));
  }
  return result;
}

//----- (1005D7C9) --------------------------------------------------------
#error "1005D7D5: call analysis failed (funcsize=10)"

//----- (1005D7F0) --------------------------------------------------------
void __cdecl sub_1005D7F0()
{
  sub_1002B6D6();
}

//----- (1005D7F8) --------------------------------------------------------
#error "1005D804: call analysis failed (funcsize=10)"

//----- (1005D820) --------------------------------------------------------
void __cdecl sub_1005D820()
{
  JUMPOUT(*(unsigned int *)loc_10009DE0);
}
// 10009DE0: using guessed type int loc_10009DE0();

//----- (1005D828) --------------------------------------------------------
#error "1005D834: call analysis failed (funcsize=11)"

//----- (1005D850) --------------------------------------------------------
int __usercall sub_1005D850<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 40);
}

//----- (1005D858) --------------------------------------------------------
#error "1005D864: call analysis failed (funcsize=7)"

//----- (1005D880) --------------------------------------------------------
int __usercall sub_1005D880<eax>(int a1<ebx>)
{
  __int64 v3; // qax@1
  __int64 v4; // qax@1
  unsigned int v5; // edi@1
  int v6; // eax@1
  int v7; // edx@1
  __int64 v9; // qax@1
  __int64 v10; // qax@1
  int v11; // edi@1
  __int64 v13; // qax@1
  __int64 v14; // qax@1
  __int64 v16; // qax@1
  __int64 v17; // qax@1
  unsigned int v18; // edi@1
  int v19; // eax@1
  unsigned __int8 v20; // cf@1
  int v21; // eax@1
  int v22; // edx@1
  int v23; // edi@1
  __int64 v25; // qax@1
  __int64 v26; // qax@1
  int v27; // esi@1
  __int64 v29; // qax@1
  __int64 v30; // qax@1
  __int64 v32; // qax@1
  __int64 v33; // qax@1
  __int64 v35; // qax@1
  __int64 v36; // qax@1
  __int64 v38; // qax@1
  __int64 v39; // qax@1
  __int64 v41; // qax@1
  __int64 v42; // qax@1
  __int64 v44; // qax@1
  __int64 v45; // qax@1
  __int64 v47; // qax@1
  __int64 v48; // qax@1
  unsigned int v49; // edi@1
  int v50; // eax@1
  unsigned __int8 v51; // cf@1
  int v52; // eax@1
  int v53; // edx@1
  int v54; // edi@1
  __int64 v56; // qax@1
  __int64 v57; // qax@1
  char v58; // [sp+4h] [bp-58h]@1
  int v59; // [sp+8h] [bp-54h]@1
  int v60; // [sp+Ch] [bp-50h]@1
  int v61; // [sp+10h] [bp-4Ch]@1
  int v62; // [sp+14h] [bp-48h]@1
  int v63; // [sp+18h] [bp-44h]@1
  __int128 v64; // [sp+1Ch] [bp-40h]@1
  __int128 v65; // [sp+2Ch] [bp-30h]@1
  int v66; // [sp+3Ch] [bp-20h]@1
  unsigned int v67; // [sp+58h] [bp-4h]@1

  v67 = (unsigned int)&v58 ^ __security_cookie;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+5Ch+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  v66 = 0;
  *(_QWORD *)&v65 = 485331304449i64;
  *((_QWORD *)&v64 + 1) = 107374182414i64;
  *(_QWORD *)&v64 = 0i64;
  v3 = sub_1002ADA0(a1, (int)&v64);
  v4 = sub_10039A40(v3, 10000000i64);
  v5 = v4;
  v59 = HIDWORD(v4);
  qword_100773E0 = v4;
  sub_1004D276(7.2e10);
  v63 = v6;
  v61 = v7;
  dword_100773E8 = v5 + v6;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_100773EC = v59 + (v5 >= -v6) + v7;
  dword_100773F0 = 15;
  dword_10077408 = 15;
  dword_10077404 = 0;
  byte_100773F4 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304453i64;
  *((_QWORD *)&v64 + 1) = 60129542147i64;
  *(_QWORD *)&v64 = 128849018880i64;
  v9 = sub_1002ADA0(a1, (int)&v64);
  v10 = sub_10039A40(v9, 10000000i64);
  v11 = v61;
  qword_10077410 = v10;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_10077418 = v10 + v63;
  dword_1007741C = HIDWORD(v10) + ((_DWORD)v10 >= (unsigned int)-v63) + v61;
  dword_10077420 = 15;
  dword_10077438 = 15;
  dword_10077434 = 0;
  byte_10077424 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304453i64;
  *((_QWORD *)&v64 + 1) = 73014444032i64;
  *(_QWORD *)&v64 = 128849018880i64;
  v13 = sub_1002ADA0(a1, (int)&v64);
  v14 = sub_10039A40(v13, 10000000i64);
  qword_10077440 = v14;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_10077448 = v14 + v63;
  dword_1007744C = HIDWORD(v14) + ((_DWORD)v14 >= (unsigned int)-v63) + v11;
  dword_10077450 = 15;
  dword_10077468 = 15;
  dword_10077464 = 0;
  byte_10077454 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304454i64;
  *((_QWORD *)&v64 + 1) = 47244640271i64;
  *(_QWORD *)&v64 = 128849018880i64;
  v16 = sub_1002ADA0(a1, (int)&v64);
  v17 = sub_10039A40(v16, 10000000i64);
  v18 = v17;
  v60 = HIDWORD(v17);
  qword_10077470 = v17;
  sub_1004D276(3.6e10);
  v62 = v19;
  v20 = v18 >= -v19;
  v21 = v18 + v19;
  v23 = v22;
  dword_10077478 = v21;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_1007747C = v60 + v20 + v22;
  dword_10077480 = 15;
  dword_10077498 = 15;
  dword_10077494 = 0;
  byte_10077484 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304454i64;
  *((_QWORD *)&v64 + 1) = 103079215106i64;
  *(_QWORD *)&v64 = 0i64;
  v25 = sub_1002ADA0(a1, (int)&v64);
  v26 = sub_10039A40(v25, 10000000i64);
  v27 = v62;
  qword_100774A0 = v26;
  dword_100774AC = HIDWORD(v26) + ((_DWORD)v26 >= (unsigned int)-v62) + v23;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_100774A8 = v26 + v62;
  dword_100774B0 = 15;
  dword_100774C8 = 15;
  dword_100774C4 = 0;
  byte_100774B4 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304454i64;
  *((_QWORD *)&v64 + 1) = 107374182403i64;
  *(_QWORD *)&v64 = 0i64;
  v29 = sub_1002ADA0(a1, (int)&v64);
  v30 = sub_10039A40(v29, 10000000i64);
  qword_100774D0 = v30;
  dword_100774DC = HIDWORD(v30) + ((_DWORD)v30 >= (unsigned int)-v63) + v61;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_100774D8 = v30 + v63;
  dword_100774E0 = 15;
  dword_100774F8 = 15;
  dword_100774F4 = 0;
  byte_100774E4 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304455i64;
  *((_QWORD *)&v64 + 1) = 111669149710i64;
  *(_QWORD *)&v64 = 128849018880i64;
  v32 = sub_1002ADA0(a1, (int)&v64);
  v33 = sub_10039A40(v32, 10000000i64);
  qword_10077500 = v33;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_1007750C = HIDWORD(v33) + ((_DWORD)v33 >= (unsigned int)-v27) + v23;
  dword_10077508 = v33 + v27;
  dword_10077510 = 15;
  dword_10077528 = 15;
  dword_10077524 = 0;
  byte_10077514 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304455i64;
  *((_QWORD *)&v64 + 1) = 115964117001i64;
  *(_QWORD *)&v64 = 0i64;
  v35 = sub_1002ADA0(a1, (int)&v64);
  v36 = sub_10039A40(v35, 10000000i64);
  qword_10077530 = v36;
  dword_1007753C = HIDWORD(v36) + ((_DWORD)v36 >= (unsigned int)-v27) + v23;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_10077538 = v36 + v27;
  dword_10077540 = 15;
  dword_10077558 = 15;
  dword_10077554 = 0;
  byte_10077544 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304455i64;
  *((_QWORD *)&v64 + 1) = 120259084302i64;
  *(_QWORD *)&v64 = 128849018880i64;
  v38 = sub_1002ADA0(a1, (int)&v64);
  v39 = sub_10039A40(v38, 10000000i64);
  qword_10077560 = v39;
  dword_1007756C = HIDWORD(v39) + ((_DWORD)v39 >= (unsigned int)-v27) + v23;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_10077568 = v39 + v27;
  dword_10077570 = 15;
  dword_10077588 = 15;
  dword_10077584 = 0;
  byte_10077574 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304456i64;
  *((_QWORD *)&v64 + 1) = 47244640260i64;
  *(_QWORD *)&v64 = 0i64;
  v41 = sub_1002ADA0(a1, (int)&v64);
  v42 = sub_10039A40(v41, 10000000i64);
  qword_10077590 = v42;
  dword_10077598 = v42 + v63;
  dword_1007759C = HIDWORD(v42) + ((_DWORD)v42 >= (unsigned int)-v63) + v61;
  dword_100775A0 = 15;
  dword_100775B8 = 15;
  dword_100775B4 = 0;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  byte_100775A4 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304456i64;
  *((_QWORD *)&v64 + 1) = 51539607567i64;
  *(_QWORD *)&v64 = 85899345920i64;
  v44 = sub_1002ADA0(a1, (int)&v64);
  v45 = sub_10039A40(v44, 10000000i64);
  qword_100775C0 = v45;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_100775C8 = v45 + v27;
  dword_100775CC = HIDWORD(v45) + ((_DWORD)v45 >= (unsigned int)-v27) + v23;
  dword_100775D0 = 15;
  dword_100775E8 = 15;
  dword_100775E4 = 0;
  byte_100775D4 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304457i64;
  *((_QWORD *)&v64 + 1) = 47244640270i64;
  *(_QWORD *)&v64 = 128849018880i64;
  v47 = sub_1002ADA0(a1, (int)&v64);
  v48 = sub_10039A40(v47, 10000000i64);
  v49 = v48;
  v60 = HIDWORD(v48);
  qword_100775F0 = v48;
  sub_1004D276(5.4e10);
  v59 = v50;
  v51 = v49 >= -v50;
  v52 = v49 + v50;
  v54 = v53;
  dword_100775F8 = v52;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_100775FC = v60 + v51 + v53;
  dword_10077600 = 15;
  dword_10077618 = 15;
  dword_10077614 = 0;
  byte_10077604 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304457i64;
  *((_QWORD *)&v64 + 1) = 47244640270i64;
  *(_QWORD *)&v64 = 128849018880i64;
  v56 = sub_1002ADA0(a1, (int)&v64);
  v57 = sub_10039A40(v56, 10000000i64);
  qword_10077620 = v57;
  dword_10077628 = v57 + v59;
  dword_1007762C = HIDWORD(v57) + ((_DWORD)v57 >= (unsigned int)-v59) + v54;
  dword_10077630 = 15;
  dword_10077648 = 15;
  dword_10077644 = 0;
  byte_10077634 = 0;
  return sub_1002B10A(SHIDWORD(v57), v57 + v59, a1, dword_1007762C, sub_1005F3D0);
}
// 1004D276: using guessed type double __usercall sub_1004D276<st0>(double<st0>);
// 10074200: using guessed type int __security_cookie;
// 100773E0: using guessed type __int64 qword_100773E0;
// 100773E8: using guessed type int dword_100773E8;
// 100773EC: using guessed type int dword_100773EC;
// 100773F0: using guessed type int dword_100773F0;
// 100773F4: using guessed type char byte_100773F4;
// 10077404: using guessed type int dword_10077404;
// 10077408: using guessed type int dword_10077408;
// 10077410: using guessed type __int64 qword_10077410;
// 10077418: using guessed type int dword_10077418;
// 1007741C: using guessed type int dword_1007741C;
// 10077420: using guessed type int dword_10077420;
// 10077424: using guessed type char byte_10077424;
// 10077434: using guessed type int dword_10077434;
// 10077438: using guessed type int dword_10077438;
// 10077440: using guessed type __int64 qword_10077440;
// 10077448: using guessed type int dword_10077448;
// 1007744C: using guessed type int dword_1007744C;
// 10077450: using guessed type int dword_10077450;
// 10077454: using guessed type char byte_10077454;
// 10077464: using guessed type int dword_10077464;
// 10077468: using guessed type int dword_10077468;
// 10077470: using guessed type __int64 qword_10077470;
// 10077478: using guessed type int dword_10077478;
// 1007747C: using guessed type int dword_1007747C;
// 10077480: using guessed type int dword_10077480;
// 10077484: using guessed type char byte_10077484;
// 10077494: using guessed type int dword_10077494;
// 10077498: using guessed type int dword_10077498;
// 100774A0: using guessed type __int64 qword_100774A0;
// 100774A8: using guessed type int dword_100774A8;
// 100774AC: using guessed type int dword_100774AC;
// 100774B0: using guessed type int dword_100774B0;
// 100774B4: using guessed type char byte_100774B4;
// 100774C4: using guessed type int dword_100774C4;
// 100774C8: using guessed type int dword_100774C8;
// 100774D0: using guessed type __int64 qword_100774D0;
// 100774D8: using guessed type int dword_100774D8;
// 100774DC: using guessed type int dword_100774DC;
// 100774E0: using guessed type int dword_100774E0;
// 100774E4: using guessed type char byte_100774E4;
// 100774F4: using guessed type int dword_100774F4;
// 100774F8: using guessed type int dword_100774F8;
// 10077500: using guessed type __int64 qword_10077500;
// 10077508: using guessed type int dword_10077508;
// 1007750C: using guessed type int dword_1007750C;
// 10077510: using guessed type int dword_10077510;
// 10077514: using guessed type char byte_10077514;
// 10077524: using guessed type int dword_10077524;
// 10077528: using guessed type int dword_10077528;
// 10077530: using guessed type __int64 qword_10077530;
// 10077538: using guessed type int dword_10077538;
// 1007753C: using guessed type int dword_1007753C;
// 10077540: using guessed type int dword_10077540;
// 10077544: using guessed type char byte_10077544;
// 10077554: using guessed type int dword_10077554;
// 10077558: using guessed type int dword_10077558;
// 10077560: using guessed type __int64 qword_10077560;
// 10077568: using guessed type int dword_10077568;
// 1007756C: using guessed type int dword_1007756C;
// 10077570: using guessed type int dword_10077570;
// 10077574: using guessed type char byte_10077574;
// 10077584: using guessed type int dword_10077584;
// 10077588: using guessed type int dword_10077588;
// 10077590: using guessed type __int64 qword_10077590;
// 10077598: using guessed type int dword_10077598;
// 1007759C: using guessed type int dword_1007759C;
// 100775A0: using guessed type int dword_100775A0;
// 100775A4: using guessed type char byte_100775A4;
// 100775B4: using guessed type int dword_100775B4;
// 100775B8: using guessed type int dword_100775B8;
// 100775C0: using guessed type __int64 qword_100775C0;
// 100775C8: using guessed type int dword_100775C8;
// 100775CC: using guessed type int dword_100775CC;
// 100775D0: using guessed type int dword_100775D0;
// 100775D4: using guessed type char byte_100775D4;
// 100775E4: using guessed type int dword_100775E4;
// 100775E8: using guessed type int dword_100775E8;
// 100775F0: using guessed type __int64 qword_100775F0;
// 100775F8: using guessed type int dword_100775F8;
// 100775FC: using guessed type int dword_100775FC;
// 10077600: using guessed type int dword_10077600;
// 10077604: using guessed type char byte_10077604;
// 10077614: using guessed type int dword_10077614;
// 10077618: using guessed type int dword_10077618;
// 10077620: using guessed type __int64 qword_10077620;
// 10077628: using guessed type int dword_10077628;
// 1007762C: using guessed type int dword_1007762C;
// 10077630: using guessed type int dword_10077630;
// 10077634: using guessed type char byte_10077634;
// 10077644: using guessed type int dword_10077644;
// 10077648: using guessed type int dword_10077648;

//----- (1005E180) --------------------------------------------------------
int __usercall sub_1005E180<eax>(int a1<ebx>)
{
  __int64 v3; // qax@1
  __int64 v4; // qax@1
  unsigned int v5; // esi@1
  unsigned int v6; // edi@1
  __int64 v8; // qax@1
  __int64 v9; // qax@1
  __int64 v10; // qax@1
  unsigned int v11; // edi@1
  int v12; // eax@1
  unsigned __int8 v13; // cf@1
  int v14; // eax@1
  int v15; // edx@1
  int v16; // edi@1
  __int64 v18; // qax@1
  __int64 v19; // qax@1
  int v20; // esi@1
  __int64 v22; // qax@1
  __int64 v23; // qax@1
  int v24; // ecx@1
  char v25; // [sp+4h] [bp-58h]@1
  int v26; // [sp+10h] [bp-4Ch]@1
  int v27; // [sp+14h] [bp-48h]@1
  __int128 v28; // [sp+1Ch] [bp-40h]@1
  __int128 v29; // [sp+2Ch] [bp-30h]@1
  int v30; // [sp+3Ch] [bp-20h]@1
  unsigned int v31; // [sp+58h] [bp-4h]@1

  v31 = (unsigned int)&v25 ^ __security_cookie;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+5Ch+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  v30 = 0;
  *(_QWORD *)&v29 = 485331304456i64;
  *((_QWORD *)&v28 + 1) = 25769803776i64;
  *(_QWORD *)&v28 = 0i64;
  v3 = sub_1002ADA0(a1, (int)&v28);
  v4 = sub_10039A40(v3, 10000000i64);
  v5 = v4;
  v6 = HIDWORD(v4);
  qword_10077650 = v4;
  sub_1004D276(-7.2e10);
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  qword_10077658 = __PAIR__(v6, v5) - v8;
  dword_10077660 = 15;
  dword_10077678 = 15;
  dword_10077674 = 0;
  byte_10077664 = 0;
  v30 = 0;
  *(_QWORD *)&v29 = 485331304456i64;
  *((_QWORD *)&v28 + 1) = 85899345920i64;
  *(_QWORD *)&v28 = 0i64;
  v9 = sub_1002ADA0(a1, (int)&v28);
  v10 = sub_10039A40(v9, 10000000i64);
  v11 = v10;
  v26 = HIDWORD(v10);
  qword_10077680 = v10;
  sub_1004D276(3.6e10);
  v27 = v12;
  v13 = v11 >= -v12;
  v14 = v11 + v12;
  v16 = v15;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_10077688 = v14;
  dword_1007768C = v26 + v13 + v15;
  dword_10077690 = 15;
  dword_100776A8 = 15;
  dword_100776A4 = 0;
  byte_10077694 = 0;
  v30 = 0;
  *(_QWORD *)&v29 = 485331304456i64;
  *((_QWORD *)&v28 + 1) = 98784247808i64;
  *(_QWORD *)&v28 = 128849018880i64;
  v18 = sub_1002ADA0(a1, (int)&v28);
  v19 = sub_10039A40(v18, 10000000i64);
  v20 = v27;
  qword_100776B0 = v19;
  dword_100776BC = HIDWORD(v19) + ((_DWORD)v19 >= (unsigned int)-v27) + v16;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_100776B8 = v19 + v27;
  dword_100776C0 = 15;
  dword_100776D8 = 15;
  dword_100776D4 = 0;
  byte_100776C4 = 0;
  v30 = 0;
  *(_QWORD *)&v29 = 485331304457i64;
  *((_QWORD *)&v28 + 1) = 8589934598i64;
  *(_QWORD *)&v28 = 0i64;
  v22 = sub_1002ADA0(a1, (int)&v28);
  v23 = sub_10039A40(v22, 10000000i64);
  qword_100776E0 = v23;
  dword_100776E8 = v23 + v20;
  dword_100776EC = HIDWORD(v23) + ((_DWORD)v23 >= (unsigned int)-v20) + v16;
  dword_100776F0 = 15;
  dword_10077708 = 15;
  dword_10077704 = 0;
  byte_100776F4 = 0;
  return sub_1002B10A(SHIDWORD(v23), v24, a1, dword_100776EC, sub_1005F3F0);
}
// 1004D276: using guessed type double __usercall sub_1004D276<st0>(double<st0>);
// 10074200: using guessed type int __security_cookie;
// 10077650: using guessed type __int64 qword_10077650;
// 10077658: using guessed type __int64 qword_10077658;
// 10077660: using guessed type int dword_10077660;
// 10077664: using guessed type char byte_10077664;
// 10077674: using guessed type int dword_10077674;
// 10077678: using guessed type int dword_10077678;
// 10077680: using guessed type __int64 qword_10077680;
// 10077688: using guessed type int dword_10077688;
// 1007768C: using guessed type int dword_1007768C;
// 10077690: using guessed type int dword_10077690;
// 10077694: using guessed type char byte_10077694;
// 100776A4: using guessed type int dword_100776A4;
// 100776A8: using guessed type int dword_100776A8;
// 100776B0: using guessed type __int64 qword_100776B0;
// 100776B8: using guessed type int dword_100776B8;
// 100776BC: using guessed type int dword_100776BC;
// 100776C0: using guessed type int dword_100776C0;
// 100776C4: using guessed type char byte_100776C4;
// 100776D4: using guessed type int dword_100776D4;
// 100776D8: using guessed type int dword_100776D8;
// 100776E0: using guessed type __int64 qword_100776E0;
// 100776E8: using guessed type int dword_100776E8;
// 100776EC: using guessed type int dword_100776EC;
// 100776F0: using guessed type int dword_100776F0;
// 100776F4: using guessed type char byte_100776F4;
// 10077704: using guessed type int dword_10077704;
// 10077708: using guessed type int dword_10077708;

//----- (1005E470) --------------------------------------------------------
int __usercall sub_1005E470<eax>(int a1<ebx>)
{
  signed int v1; // eax@1
  int v2; // edi@1
  void *v3; // esi@4
  void *v4; // esi@6
  void *v5; // esi@10
  int v6; // edx@11
  int v7; // ecx@11
  void *v8; // esi@12
  char v10; // [sp+41h] [bp-85h]@4
  char v11; // [sp+42h] [bp-84h]@3
  char v12; // [sp+43h] [bp-83h]@4
  char v13; // [sp+44h] [bp-82h]@3
  char v14; // [sp+45h] [bp-81h]@3
  void *v15; // [sp+46h] [bp-80h]@3
  int v16; // [sp+56h] [bp-70h]@3
  unsigned int v17; // [sp+5Ah] [bp-6Ch]@3
  __int64 *v18; // [sp+5Eh] [bp-68h]@3
  __int64 *v19; // [sp+62h] [bp-64h]@3
  void *v20; // [sp+66h] [bp-60h]@3
  int v21; // [sp+76h] [bp-50h]@3
  unsigned int v22; // [sp+7Ah] [bp-4Ch]@3
  void *v23; // [sp+7Eh] [bp-48h]@9
  int v24; // [sp+8Eh] [bp-38h]@9
  unsigned int v25; // [sp+92h] [bp-34h]@9
  void *v26; // [sp+96h] [bp-30h]@9
  int v27; // [sp+A6h] [bp-20h]@9
  unsigned int v28; // [sp+AAh] [bp-1Ch]@9
  __int64 *v29; // [sp+AEh] [bp-18h]@9
  char *v30; // [sp+B2h] [bp-14h]@9
  int v31; // [sp+C2h] [bp-4h]@3

  v2 = 6;
  v1 = 6;
  if ( !byte_10067F64 )
    v1 = 0;
  v22 = 15;
  v21 = 0;
  LOBYTE(v20) = 0;
  loc_1000AEB0(&v20, &byte_10067F64, v1);
  v31 = 0;
  sub_100018D0(&v13);
  sub_100035D0((int)&v11);
  sub_10003480(&v14, (int)&v11);
  v17 = 15;
  v16 = 0;
  LOBYTE(v15) = 0;
  loc_1000AB40(&v15, &v20, 0, -1);
  v18 = &qword_100773E0;
  v19 = &qword_10077650;
  if ( v22 >= 0x10 )
  {
    v3 = v20;
    sub_100018D0(&v10);
    nullsub_1(&v20);
    sub_100018D0(&v12);
    sub_1002A4AA(v3);
  }
  v22 = 15;
  v21 = 0;
  LOBYTE(v20) = 0;
  v31 = 1;
  sub_100018D0(&v10);
  sub_100035D0((int)&v11);
  sub_10003480(&v12, (int)&v11);
  dword_10077724 = 15;
  dword_10077720 = 0;
  byte_10077710 = 0;
  loc_1000AB40(&byte_10077710, &v15, 0, -1);
  dword_10077728 = (int)v18;
  dword_1007772C = (int)v19;
  LOBYTE(v31) = 3;
  if ( v17 >= 0x10 )
  {
    v4 = v15;
    sub_100018D0(&v10);
    nullsub_1(&v15);
    sub_100018D0(&v12);
    sub_1002A4AA(v4);
  }
  if ( !byte_10067F6C )
    v2 = 0;
  v17 = 15;
  v16 = 0;
  LOBYTE(v15) = 0;
  v25 = 15;
  v24 = 0;
  LOBYTE(v23) = 0;
  loc_1000AEB0(&v23, &byte_10067F6C, v2);
  LOBYTE(v31) = 4;
  sub_100018D0(&v10);
  sub_100035D0((int)&v11);
  sub_10003480(&v12, (int)&v11);
  v28 = 15;
  v27 = 0;
  LOBYTE(v26) = 0;
  loc_1000AB40(&v26, &v23, 0, -1);
  v29 = &qword_10077650;
  v30 = &byte_10077710;
  if ( v25 >= 0x10 )
  {
    v5 = v23;
    sub_100018D0(&v13);
    nullsub_1(&v23);
    sub_100018D0(&v14);
    sub_1002A4AA(v5);
  }
  v25 = 15;
  v24 = 0;
  LOBYTE(v23) = 0;
  LOBYTE(v31) = 5;
  sub_100018D0(&v10);
  sub_100035D0((int)&v11);
  sub_10003480(&v12, (int)&v11);
  dword_10077744 = 15;
  dword_10077740 = 0;
  byte_10077730 = 0;
  loc_1000AB40(&byte_10077730, &v26, 0, -1);
  dword_10077748 = (int)v29;
  dword_1007774C = (int)v30;
  if ( v28 >= 0x10 )
  {
    v8 = v26;
    sub_100018D0(&v10);
    nullsub_1(&v26);
    sub_100018D0(&v12);
    sub_1002A4AA(v8);
  }
  return sub_1002B10A(v6, v7, a1, v2, sub_1005F410);
}
// 100018C0: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067F64: using guessed type char byte_10067F64;
// 10067F6C: using guessed type char byte_10067F6C;
// 100773E0: using guessed type __int64 qword_100773E0;
// 10077650: using guessed type __int64 qword_10077650;
// 10077710: using guessed type char byte_10077710;
// 10077720: using guessed type int dword_10077720;
// 10077724: using guessed type int dword_10077724;
// 10077728: using guessed type int dword_10077728;
// 1007772C: using guessed type int dword_1007772C;
// 10077730: using guessed type char byte_10077730;
// 10077740: using guessed type int dword_10077740;
// 10077744: using guessed type int dword_10077744;
// 10077748: using guessed type int dword_10077748;
// 1007774C: using guessed type int dword_1007774C;

//----- (1005E7F0) --------------------------------------------------------
int __usercall sub_1005E7F0<eax>(int a1<ebx>, int a2<edi>)
{
  signed int v2; // eax@1
  int v4; // edx@3
  int v5; // ecx@3

  v2 = 6;
  if ( !byte_10067F64 )
    v2 = 0;
  loc_1000AEB0(&unk_10075E80, &byte_10067F64, v2);
  __asm
  {
    xorps   xmm0, xmm0
    movsd   qword_10075E98, xmm0
    movsd   xmm0, ds:qword_10069500
    movsd   xmm1, ds:qword_100694D0
    movsd   qword_10075EA0, xmm0
    movsd   xmm0, ds:qword_100694F0
    movsd   qword_10075EA8, xmm0
    movsd   xmm0, ds:qword_100694B8
    movsd   qword_10075EB0, xmm0
    movsd   xmm0, ds:qword_10069508
    movsd   qword_10075EC0, xmm0
    movsd   xmm0, ds:qword_100694A8
    movsd   qword_10075EC8, xmm0
    movsd   xmm0, ds:qword_100694C0
    movsd   qword_10075ED0, xmm0
    movsd   xmm0, ds:dbl_100694D8
    movsd   qword_10075EE0, xmm0
    movsd   xmm0, ds:qword_100694B0
    movsd   qword_10075EF8, xmm0
    movsd   xmm0, ds:qword_10069498
  }
  dword_10075EB8 = 1;
  dword_10075ED8 = 70;
  dword_10075EDC = 300;
  byte_10075EE8 = 1;
  __asm
  {
    movsd   qword_10075EF0, xmm1
    movsd   qword_10075F00, xmm0
    movsd   qword_10075F08, xmm1
  }
  dword_10075F24 = 15;
  dword_10075F20 = 0;
  byte_10075F10 = 0;
  loc_1000AEB0(&byte_10075F10);
  __asm
  {
    xorps   xmm0, xmm0
    movsd   qword_10075F28, xmm0
    movsd   xmm0, ds:qword_10069500
    movsd   xmm1, ds:qword_100694D0
    movsd   qword_10075F30, xmm0
    movsd   xmm0, ds:qword_100694F0
    movsd   qword_10075F38, xmm0
    movsd   xmm0, ds:qword_100694B8
    movsd   qword_10075F40, xmm0
    movsd   xmm0, ds:qword_10069508
    movsd   qword_10075F50, xmm0
    movsd   xmm0, ds:qword_100694A8
    movsd   qword_10075F58, xmm0
    movsd   xmm0, ds:qword_100694C0
    movsd   qword_10075F60, xmm0
    movsd   xmm0, ds:dbl_100694D8
    movsd   qword_10075F70, xmm0
    movsd   xmm0, ds:qword_100694B0
    movsd   qword_10075F88, xmm0
    movsd   xmm0, ds:qword_10069498
  }
  dword_10075F48 = 1;
  dword_10075F68 = 70;
  dword_10075F6C = 300;
  byte_10075F78 = 1;
  __asm
  {
    movsd   qword_10075F80, xmm1
    movsd   qword_10075F90, xmm0
    movsd   qword_10075F98, xmm1
  }
  return sub_1002B10A(v4, v5, a1, a2, sub_1005F430);
}
// 10067F64: using guessed type char byte_10067F64;
// 10075EB8: using guessed type int dword_10075EB8;
// 10075ED8: using guessed type int dword_10075ED8;
// 10075EDC: using guessed type int dword_10075EDC;
// 10075EE8: using guessed type char byte_10075EE8;
// 10075F10: using guessed type char byte_10075F10;
// 10075F20: using guessed type int dword_10075F20;
// 10075F24: using guessed type int dword_10075F24;
// 10075F48: using guessed type int dword_10075F48;
// 10075F68: using guessed type int dword_10075F68;
// 10075F6C: using guessed type int dword_10075F6C;
// 10075F78: using guessed type char byte_10075F78;

//----- (1005EA40) --------------------------------------------------------
int __usercall sub_1005EA40<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v4; // edx@1
  int v5; // ecx@1

  sub_1000C770(a1, a1);
  sub_10021500(a2, a3);
  return sub_1002B10A(v4, v5, a2, a3, sub_1005F450);
}
// 1005F450: using guessed type int sub_1005F450();

//----- (1005EA60) --------------------------------------------------------
int __usercall sub_1005EA60<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  return sub_1002B10A(a1, a2, a3, a4, sub_1005F480);
}
// 1005F480: using guessed type int sub_1005F480();

//----- (1005EA70) --------------------------------------------------------
int __usercall sub_1005EA70<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  return sub_1002B10A(a1, a2, a3, a4, sub_1005F470);
}
// 1005F470: using guessed type int sub_1005F470();

//----- (1005EA80) --------------------------------------------------------
int __usercall sub_1005EA80<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  return sub_1002B10A(a1, a2, a3, a4, sub_1005F460);
}

//----- (1005EA90) --------------------------------------------------------
__int64 __usercall sub_1005EA90<edx:eax>(int a1<ebx>)
{
  __int64 result; // qax@1
  __int64 v3; // qax@1
  __int64 v4; // qax@1
  int v5; // esi@1
  int v7; // edi@1
  __int64 v8; // qax@1
  __int64 v10; // qax@1
  __int64 v11; // qax@1
  int v12; // esi@1
  int v14; // edi@1
  __int64 v15; // qax@1
  __int64 v17; // qax@1
  __int64 v18; // qax@1
  int v19; // esi@1
  int v21; // edi@1
  __int64 v22; // qax@1
  __int64 v24; // qax@1
  __int64 v25; // qax@1
  int v27; // esi@1
  int v28; // edi@1
  __int64 v29; // qax@1
  __int64 v31; // qax@1
  __int64 v32; // qax@1
  int v33; // esi@1
  int v35; // edi@1
  __int64 v36; // qax@1
  char v37; // [sp+4h] [bp-78h]@1
  __int128 v38; // [sp+Ch] [bp-70h]@1
  __int128 v39; // [sp+1Ch] [bp-60h]@1
  int v40; // [sp+2Ch] [bp-50h]@1
  __int128 v41; // [sp+3Ch] [bp-40h]@1
  __int128 v42; // [sp+4Ch] [bp-30h]@1
  int v43; // [sp+5Ch] [bp-20h]@1
  unsigned int v44; // [sp+78h] [bp-4h]@1

  v44 = (unsigned int)&v37 ^ __security_cookie;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+7Ch+var_70], xmm0
    movdqa  [esp+80h+var_60], xmm0
  }
  v40 = 0;
  *(_QWORD *)&v39 = 485331304457i64;
  *((_QWORD *)&v38 + 1) = 115964116993i64;
  *(_QWORD *)&v38 = 0i64;
  v3 = sub_1002ADA0(a1, (int)&v38);
  v4 = sub_10039A40(v3, 10000000i64);
  v5 = v4;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+80h+var_40], xmm0
    movdqa  [esp+80h+var_30], xmm0
  }
  v7 = HIDWORD(v4);
  v43 = 0;
  *(_QWORD *)&v42 = 485331304450i64;
  *((_QWORD *)&v41 + 1) = 133143986177i64;
  *(_QWORD *)&v41 = 0i64;
  v8 = sub_1002ADA0(a1, (int)&v41);
  qword_100779E0 = sub_10039A40(v8, 10000000i64);
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+80h+var_40], xmm0
    movdqa  [esp+80h+var_30], xmm0
  }
  dword_100779E8 = v5;
  dword_100779EC = v7;
  v43 = 0;
  *(_QWORD *)&v42 = 485331304457i64;
  *((_QWORD *)&v41 + 1) = 111669149697i64;
  *(_QWORD *)&v41 = 0i64;
  v10 = sub_1002ADA0(a1, (int)&v41);
  v11 = sub_10039A40(v10, 10000000i64);
  v12 = v11;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+80h+var_70], xmm0
    movdqa  [esp+80h+var_60], xmm0
  }
  v14 = HIDWORD(v11);
  v40 = 0;
  *(_QWORD *)&v39 = 489626271746i64;
  *((_QWORD *)&v38 + 1) = 128849018881i64;
  *(_QWORD *)&v38 = 0i64;
  v15 = sub_1002ADA0(a1, (int)&v38);
  qword_100779F0 = sub_10039A40(v15, 10000000i64);
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+80h+var_40], xmm0
    movdqa  [esp+80h+var_30], xmm0
  }
  dword_100779F8 = v12;
  dword_100779FC = v14;
  v43 = 0;
  *(_QWORD *)&v42 = 485331304457i64;
  *((_QWORD *)&v41 + 1) = 107374182401i64;
  *(_QWORD *)&v41 = 0i64;
  v17 = sub_1002ADA0(a1, (int)&v41);
  v18 = sub_10039A40(v17, 10000000i64);
  v19 = v18;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+80h+var_70], xmm0
    movdqa  [esp+80h+var_60], xmm0
  }
  v21 = HIDWORD(v18);
  v40 = 0;
  *(_QWORD *)&v39 = 493921239042i64;
  *((_QWORD *)&v38 + 1) = 124554051585i64;
  *(_QWORD *)&v38 = 0i64;
  v22 = sub_1002ADA0(a1, (int)&v38);
  qword_10077A00 = sub_10039A40(v22, 10000000i64);
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+80h+var_40], xmm0
    movdqa  [esp+80h+var_30], xmm0
  }
  dword_10077A08 = v19;
  dword_10077A0C = v21;
  v43 = 0;
  *(_QWORD *)&v42 = 485331304457i64;
  *((_QWORD *)&v41 + 1) = 128849018881i64;
  *(_QWORD *)&v41 = 0i64;
  v24 = sub_1002ADA0(a1, (int)&v41);
  v25 = sub_10039A40(v24, 10000000i64);
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+80h+var_60], xmm0
    movdqa  [esp+80h+var_70], xmm0
  }
  v27 = v25;
  v28 = HIDWORD(v25);
  v40 = 0;
  *(_QWORD *)&v39 = 498216206338i64;
  *((_QWORD *)&v38 + 1) = 115964116993i64;
  *(_QWORD *)&v38 = 0i64;
  v29 = sub_1002ADA0(a1, (int)&v38);
  qword_10077A10 = sub_10039A40(v29, 10000000i64);
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+80h+var_40], xmm0
    movdqa  [esp+80h+var_30], xmm0
  }
  dword_10077A18 = v27;
  dword_10077A1C = v28;
  v43 = 0;
  *(_QWORD *)&v42 = 485331304457i64;
  *((_QWORD *)&v41 + 1) = 124554051585i64;
  *(_QWORD *)&v41 = 0i64;
  v31 = sub_1002ADA0(a1, (int)&v41);
  v32 = sub_10039A40(v31, 10000000i64);
  v33 = v32;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+80h+var_70], xmm0
    movdqa  [esp+80h+var_60], xmm0
  }
  v35 = HIDWORD(v32);
  v40 = 0;
  *(_QWORD *)&v39 = 502511173634i64;
  *((_QWORD *)&v38 + 1) = 111669149697i64;
  *(_QWORD *)&v38 = 0i64;
  v36 = sub_1002ADA0(a1, (int)&v38);
  result = sub_10039A40(v36, 10000000i64);
  dword_10077A2C = v35;
  dword_10077A28 = v33;
  qword_10077A20 = result;
  return result;
}
// 10074200: using guessed type int __security_cookie;
// 100779E0: using guessed type __int64 qword_100779E0;
// 100779E8: using guessed type int dword_100779E8;
// 100779EC: using guessed type int dword_100779EC;
// 100779F0: using guessed type __int64 qword_100779F0;
// 100779F8: using guessed type int dword_100779F8;
// 100779FC: using guessed type int dword_100779FC;
// 10077A00: using guessed type __int64 qword_10077A00;
// 10077A08: using guessed type int dword_10077A08;
// 10077A0C: using guessed type int dword_10077A0C;
// 10077A10: using guessed type __int64 qword_10077A10;
// 10077A18: using guessed type int dword_10077A18;
// 10077A1C: using guessed type int dword_10077A1C;
// 10077A20: using guessed type __int64 qword_10077A20;
// 10077A28: using guessed type int dword_10077A28;
// 10077A2C: using guessed type int dword_10077A2C;

//----- (1005EF20) --------------------------------------------------------
int __usercall sub_1005EF20<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  dword_10077A38 &= 0xFFFFFE00u;
  return sub_1002B10A(a1, a2, a3, a4, sub_1005F490);
}
// 1005F490: using guessed type int sub_1005F490();
// 10077A38: using guessed type int dword_10077A38;

//----- (1005EF40) --------------------------------------------------------
int __usercall sub_1005EF40<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  loc_1000AEB0(&dword_10075FA0, "\\[(b|i|url)\\](.+?)\\[/\\1\\]", 25);
  return sub_1002B10A(v3, v4, a1, a2, sub_1005F4A0);
}
// 10075FA0: using guessed type int dword_10075FA0;

//----- (1005EF60) --------------------------------------------------------
int __usercall sub_1005EF60<eax>(int a1<ebx>, int a2<edi>)
{
  signed int v2; // eax@1
  int v4; // edx@3
  int v5; // ecx@3

  v2 = 6;
  if ( !byte_10067F64 )
    v2 = 0;
  loc_1000AEB0(&unk_10075FB8, &byte_10067F64, v2);
  __asm
  {
    movsd   xmm0, ds:qword_100694B0
    movsd   qword_10075FD0, xmm0
    movsd   xmm0, ds:qword_100694F8
    movsd   qword_10075FD8, xmm0
    movsd   xmm0, ds:qword_100694F0
    movsd   qword_10075FE0, xmm0
    xorps   xmm0, xmm0
    movsd   qword_10075FE8, xmm0
    movsd   xmm0, ds:qword_100694C8
    movsd   qword_10075FF8, xmm0
    movsd   xmm0, ds:qword_100694A8
  }
  dword_10075FF0 = 7;
  __asm { movsd   qword_10076000, xmm0 }
  dword_1007601C = 15;
  dword_10076018 = 0;
  byte_10076008 = 0;
  loc_1000AEB0(&byte_10076008);
  __asm
  {
    movsd   xmm0, ds:qword_100694B0
    movsd   qword_10076020, xmm0
    movsd   xmm0, ds:qword_100694F8
    movsd   qword_10076028, xmm0
    movsd   xmm0, ds:qword_100694F0
    movsd   qword_10076030, xmm0
    xorps   xmm0, xmm0
    movsd   qword_10076038, xmm0
    movsd   xmm0, ds:qword_100694C8
    movsd   qword_10076048, xmm0
    movsd   xmm0, ds:qword_100694A8
  }
  dword_10076040 = 7;
  __asm { movsd   qword_10076050, xmm0 }
  return sub_1002B10A(v4, v5, a1, a2, sub_1005F500);
}
// 10067F64: using guessed type char byte_10067F64;
// 10075FF0: using guessed type int dword_10075FF0;
// 10076008: using guessed type char byte_10076008;
// 10076018: using guessed type int dword_10076018;
// 1007601C: using guessed type int dword_1007601C;
// 10076040: using guessed type int dword_10076040;

//----- (1005F0D0) --------------------------------------------------------
int __usercall sub_1005F0D0<eax>(int a1<ebx>, int a2<edi>)
{
  signed int v2; // eax@1
  int v4; // edx@3
  int v5; // ecx@3

  v2 = 6;
  if ( !byte_10067F64 )
    v2 = 0;
  loc_1000AEB0(&unk_10076060, &byte_10067F64, v2);
  __asm
  {
    movsd   xmm0, ds:qword_100694E0
    movsd   qword_10076078, xmm0
    movsd   xmm0, ds:qword_100694E8
    movsd   qword_10076080, xmm0
    movsd   xmm0, ds:qword_100694D0
    movsd   qword_10076088, xmm0
    xorps   xmm0, xmm0
    movsd   qword_10076090, xmm0
    movsd   xmm0, ds:qword_100694A8
  }
  dword_10076098 = 7;
  byte_100760A0 = 0;
  __asm { movsd   qword_100760A8, xmm0 }
  dword_100760C4 = 15;
  dword_100760C0 = 0;
  byte_100760B0 = 0;
  loc_1000AEB0(&byte_100760B0);
  __asm
  {
    movsd   xmm0, ds:qword_100694E0
    movsd   qword_100760C8, xmm0
    movsd   xmm0, ds:qword_100694E8
    movsd   qword_100760D0, xmm0
    movsd   xmm0, ds:qword_100694D0
    movsd   qword_100760D8, xmm0
    xorps   xmm0, xmm0
    movsd   qword_100760E0, xmm0
    movsd   xmm0, ds:qword_100694A8
  }
  dword_100760E8 = 7;
  byte_100760F0 = 0;
  __asm { movsd   qword_100760F8, xmm0 }
  return sub_1002B10A(v4, v5, a1, a2, sub_1005F520);
}
// 10067F64: using guessed type char byte_10067F64;
// 10076098: using guessed type int dword_10076098;
// 100760A0: using guessed type char byte_100760A0;
// 100760B0: using guessed type char byte_100760B0;
// 100760C0: using guessed type int dword_100760C0;
// 100760C4: using guessed type int dword_100760C4;
// 100760E8: using guessed type int dword_100760E8;
// 100760F0: using guessed type char byte_100760F0;

//----- (1005F230) --------------------------------------------------------
int __usercall sub_1005F230<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  loc_1000AEB0(&dword_10076100, "ForexSensationExtended", 22);
  return sub_1002B10A(v3, v4, a1, a2, sub_1005F540);
}
// 10076100: using guessed type int dword_10076100;

//----- (1005F250) --------------------------------------------------------
int __usercall sub_1005F250<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  loc_1000AEB0(&dword_10076130, "1.01", 4);
  return sub_1002B10A(v3, v4, a1, a2, sub_1005F5A0);
}
// 10076130: using guessed type int dword_10076130;

//----- (1005F270) --------------------------------------------------------
int __usercall sub_1005F270<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  loc_10028430(&dword_10076118, L"http://forexsensation.com/access", 32);
  return sub_1002B10A(v3, v4, a1, a2, sub_1005F600);
}
// 10068C00: using guessed type wchar_t aHttpForexsensa[33];
// 10076118: using guessed type int dword_10076118;

//----- (1005F290) --------------------------------------------------------
int __usercall sub_1005F290<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  loc_10028430(&dword_10076148, L"http://forexsensation.com/newsapi/exceptions", 44);
  return sub_1002B10A(v3, v4, a1, a2, sub_1005F660);
}
// 10068C48: using guessed type wchar_t aHttpForexsen_0[45];
// 10076148: using guessed type int dword_10076148;

//----- (1005F2B0) --------------------------------------------------------
int __usercall sub_1005F2B0<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  loc_10028430(&pszAgentW, L"Client", 6);
  return sub_1002B10A(v3, v4, a1, a2, sub_1005F6C0);
}
// 100693F0: using guessed type wchar_t aClient[7];

//----- (1005F2D0) --------------------------------------------------------
int __usercall sub_1005F2D0<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  dword_10077A5C = 0;
  dword_10077A60 = 0;
  hInternet = 0;
  sub_1002B5CC((int)&unk_10077A44);
  __asm
  {
    xorps   xmm0, xmm0
    movq    qword ptr pProxyConfig.fAutoDetect, xmm0
    movq    qword ptr pProxyConfig.lpszProxy, xmm0
  }
  return sub_1002B10A(v3, v4, a1, a2, sub_1005F720);
}
// 10077A5C: using guessed type int dword_10077A5C;
// 10077A60: using guessed type int dword_10077A60;

//----- (1005F317) --------------------------------------------------------
int __usercall sub_1005F317<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  return sub_1002B10A(a1, a2, a3, a4, sub_1005F770);
}
// 1005F770: using guessed type int sub_1005F770();

//----- (1005F323) --------------------------------------------------------
int __usercall sub_1005F323<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  return sub_1002B10A(a1, a2, a3, a4, sub_1005F77A);
}
// 1005F77A: using guessed type int sub_1005F77A();

//----- (1005F32F) --------------------------------------------------------
int __usercall sub_1005F32F<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  sub_10029A47(&unk_10076218);
  return sub_1002B10A(v3, v4, a1, a2, sub_1005F784);
}
// 1005F784: using guessed type int sub_1005F784();

//----- (1005F345) --------------------------------------------------------
int __usercall sub_1005F345<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  return sub_1002B10A(a1, a2, a3, a4, sub_1005F78E);
}
// 1005F78E: using guessed type int sub_1005F78E();

//----- (1005F351) --------------------------------------------------------
int __usercall sub_1005F351<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  sub_10029A47(&unk_100762D8);
  return sub_1002B10A(v3, v4, a1, a2, sub_1005F798);
}
// 1005F798: using guessed type int sub_1005F798();

//----- (1005F367) --------------------------------------------------------
int __usercall sub_1005F367<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  sub_1002FB8C(&dword_10076390);
  return sub_1002B10A(v3, v4, a1, a2, sub_1005F7A2);
}
// 1002FB8C: using guessed type int __cdecl sub_1002FB8C(_DWORD);
// 1005F7A2: using guessed type int sub_1005F7A2();
// 10076390: using guessed type int dword_10076390;

//----- (1005F37F) --------------------------------------------------------
void **__cdecl sub_1005F37F()
{
  void **result; // eax@1

  result = sub_10047EC4() + 16;
  dword_1007672C = (int)result;
  return result;
}
// 1007672C: using guessed type int dword_1007672C;

//----- (1005F38D) --------------------------------------------------------
unsigned int __cdecl sub_1005F38D()
{
  unsigned int result; // eax@1

  result = sub_1003498E();
  dword_10077078 = result;
  return result;
}
// 10077078: using guessed type int dword_10077078;

//----- (1005F398) --------------------------------------------------------
void __cdecl sub_1005F398()
{
  dword_10077070 = 0;
}
// 10077070: using guessed type int dword_10077070;

//----- (1005F3A3) --------------------------------------------------------
void __cdecl sub_1005F3A3()
{
  dword_10077068 = 0;
}
// 10077068: using guessed type int dword_10077068;

//----- (1005F3AE) --------------------------------------------------------
void __cdecl sub_1005F3AE()
{
  dword_10077074 = 0;
}
// 10077074: using guessed type int dword_10077074;

//----- (1005F3B9) --------------------------------------------------------
void __cdecl sub_1005F3B9()
{
  dword_1007706C = 0;
}
// 1007706C: using guessed type int dword_1007706C;

//----- (1005F3C4) --------------------------------------------------------
void __cdecl sub_1005F3C4()
{
  InitializeSListHead(&ListHead);
}

//----- (1005F3D0) --------------------------------------------------------
signed int __cdecl sub_1005F3D0()
{
  return sub_1002B11F((int)&dword_100773E0, 48, 13, (void (__thiscall *)(_DWORD))loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();
// 100773E0: using guessed type int dword_100773E0;

//----- (1005F3F0) --------------------------------------------------------
signed int __cdecl sub_1005F3F0()
{
  return sub_1002B11F((int)&dword_10077650, 48, 4, (void (__thiscall *)(_DWORD))loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();
// 10077650: using guessed type int dword_10077650;

//----- (1005F410) --------------------------------------------------------
signed int __cdecl sub_1005F410()
{
  return sub_1002B11F((int)&byte_10077710, 32, 2, sub_10001880);
}
// 10077710: using guessed type char byte_10077710;

//----- (1005F430) --------------------------------------------------------
signed int __cdecl sub_1005F430()
{
  return sub_1002B11F((int)&unk_10075E80, 144, 2, sub_10001880);
}

//----- (1005F460) --------------------------------------------------------
void __cdecl sub_1005F460()
{
  off_10076178[0] = (int (__stdcall *)(char))&off_1006034C;
}
// 1006034C: using guessed type int (__stdcall *off_1006034C)(char);
// 10076178: using guessed type int (__stdcall *off_10076178[3])(char);

//----- (1005F4A0) --------------------------------------------------------
int __cdecl sub_1005F4A0()
{
  int result; // eax@2
  void *v1; // esi@2
  char v2; // [sp+1h] [bp-1h]@2

  if ( (unsigned int)dword_10075FB4 >= 0x10 )
  {
    v1 = (void *)dword_10075FA0;
    sub_100018D0(&v2);
    nullsub_1(&dword_10075FA0);
    sub_100018D0(&v2);
    result = sub_1002A4AA(v1);
  }
  dword_10075FB4 = 15;
  dword_10075FB0 = 0;
  LOBYTE(dword_10075FA0) = 0;
  return result;
}
// 100018C0: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10075FA0: using guessed type int dword_10075FA0;
// 10075FB0: using guessed type int dword_10075FB0;
// 10075FB4: using guessed type int dword_10075FB4;

//----- (1005F500) --------------------------------------------------------
signed int __cdecl sub_1005F500()
{
  return sub_1002B11F((int)&unk_10075FB8, 80, 2, sub_10001880);
}

//----- (1005F520) --------------------------------------------------------
signed int __cdecl sub_1005F520()
{
  return sub_1002B11F((int)&unk_10076060, 80, 2, sub_10001880);
}

//----- (1005F540) --------------------------------------------------------
int __cdecl sub_1005F540()
{
  int result; // eax@2
  void *v1; // esi@2
  char v2; // [sp+1h] [bp-1h]@2

  if ( (unsigned int)dword_10076114 >= 0x10 )
  {
    v1 = (void *)dword_10076100;
    sub_100018D0(&v2);
    nullsub_1(&dword_10076100);
    sub_100018D0(&v2);
    result = sub_1002A4AA(v1);
  }
  dword_10076114 = 15;
  dword_10076110 = 0;
  LOBYTE(dword_10076100) = 0;
  return result;
}
// 100018C0: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10076100: using guessed type int dword_10076100;
// 10076110: using guessed type int dword_10076110;
// 10076114: using guessed type int dword_10076114;

//----- (1005F5A0) --------------------------------------------------------
int __cdecl sub_1005F5A0()
{
  int result; // eax@2
  void *v1; // esi@2
  char v2; // [sp+1h] [bp-1h]@2

  if ( (unsigned int)dword_10076144 >= 0x10 )
  {
    v1 = (void *)dword_10076130;
    sub_100018D0(&v2);
    nullsub_1(&dword_10076130);
    sub_100018D0(&v2);
    result = sub_1002A4AA(v1);
  }
  dword_10076144 = 15;
  dword_10076140 = 0;
  LOBYTE(dword_10076130) = 0;
  return result;
}
// 100018C0: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10076130: using guessed type int dword_10076130;
// 10076140: using guessed type int dword_10076140;
// 10076144: using guessed type int dword_10076144;

//----- (1005F600) --------------------------------------------------------
int __cdecl sub_1005F600()
{
  void *v0; // esi@2
  int result; // eax@3
  char v2; // [sp+1h] [bp-1h]@2

  if ( (unsigned int)dword_1007612C >= 8 )
  {
    v0 = (void *)dword_10076118;
    sub_100018D0(&v2);
    nullsub_1(&dword_10076118);
    sub_100018D0(&v2);
    sub_1002A4AA(v0);
  }
  result = 0;
  dword_1007612C = 7;
  dword_10076128 = 0;
  LOWORD(dword_10076118) = 0;
  return result;
}
// 100018C0: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10076118: using guessed type int dword_10076118;
// 10076128: using guessed type int dword_10076128;
// 1007612C: using guessed type int dword_1007612C;

//----- (1005F660) --------------------------------------------------------
int __cdecl sub_1005F660()
{
  void *v0; // esi@2
  int result; // eax@3
  char v2; // [sp+1h] [bp-1h]@2

  if ( (unsigned int)dword_1007615C >= 8 )
  {
    v0 = (void *)dword_10076148;
    sub_100018D0(&v2);
    nullsub_1(&dword_10076148);
    sub_100018D0(&v2);
    sub_1002A4AA(v0);
  }
  result = 0;
  dword_1007615C = 7;
  dword_10076158 = 0;
  LOWORD(dword_10076148) = 0;
  return result;
}
// 100018C0: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10076148: using guessed type int dword_10076148;
// 10076158: using guessed type int dword_10076158;
// 1007615C: using guessed type int dword_1007615C;

//----- (1005F6C0) --------------------------------------------------------
int __cdecl sub_1005F6C0()
{
  LPCWSTR v0; // esi@2
  int result; // eax@3
  char v2; // [sp+1h] [bp-1h]@2

  if ( (unsigned int)dword_10076174 >= 8 )
  {
    v0 = pszAgentW;
    sub_100018D0(&v2);
    nullsub_1(&pszAgentW);
    sub_100018D0(&v2);
    sub_1002A4AA((LPVOID)v0);
  }
  result = 0;
  dword_10076174 = 7;
  dword_10076170 = 0;
  LOWORD(pszAgentW) = 0;
  return result;
}
// 100018C0: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10076170: using guessed type int dword_10076170;
// 10076174: using guessed type int dword_10076174;

//----- (1005F720) --------------------------------------------------------
int __cdecl sub_1005F720()
{
  if ( hInternet )
  {
    WinHttpCloseHandle(hInternet);
    hInternet = 0;
  }
  if ( pProxyConfig.lpszAutoConfigUrl )
    GlobalFree(pProxyConfig.lpszAutoConfigUrl);
  if ( pProxyConfig.lpszProxy )
    GlobalFree(pProxyConfig.lpszProxy);
  if ( pProxyConfig.lpszProxyBypass )
    GlobalFree(pProxyConfig.lpszProxyBypass);
  return nullsub_2(&unk_10077A44);
}
// 1002B6E4: using guessed type int __thiscall nullsub_2(_DWORD);

#error "There were 346 decompilation failure(s) on 3367 function(s)"
