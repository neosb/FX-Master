/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2009 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Data declarations

extern _UNKNOWN loc_10002BC0; // weak
extern _UNKNOWN loc_10002E20; // weak
extern _UNKNOWN loc_10002ED0; // weak
extern _UNKNOWN loc_10007010; // weak
extern _UNKNOWN loc_10009CC0; // weak
extern _UNKNOWN loc_1000A1F0; // weak
extern _UNKNOWN loc_1000AB40; // weak
extern _UNKNOWN loc_1000AC70; // weak
extern _UNKNOWN loc_1000ADF0; // weak
extern _UNKNOWN loc_1000AEB0; // weak
extern _UNKNOWN loc_1000F6D0; // weak
extern _UNKNOWN loc_1000FED0; // weak
extern _UNKNOWN loc_1000FF70; // weak
extern _UNKNOWN loc_100102E0; // weak
extern _UNKNOWN loc_10010400; // weak
extern _UNKNOWN loc_100105E0; // weak
extern _UNKNOWN loc_10010720; // weak
extern _UNKNOWN loc_10010890; // weak
extern _UNKNOWN loc_10012540; // weak
extern _UNKNOWN loc_10012FA0; // weak
extern _UNKNOWN loc_100134C0; // weak
extern _UNKNOWN loc_100138D0; // weak
extern _UNKNOWN loc_10013A40; // weak
extern _UNKNOWN loc_10013AE0; // weak
extern _UNKNOWN loc_10014600; // weak
extern _UNKNOWN loc_10014700; // weak
extern _UNKNOWN loc_10015E50; // weak
extern _UNKNOWN loc_100166D0; // weak
extern _UNKNOWN loc_10016BE0; // weak
extern _UNKNOWN loc_10017FD0; // weak
extern _UNKNOWN loc_10018220; // weak
extern _UNKNOWN loc_10019280; // weak
extern _UNKNOWN loc_10019490; // weak
extern _UNKNOWN loc_10019C80; // weak
extern _UNKNOWN loc_10019DC0; // weak
extern _UNKNOWN loc_1001AE80; // weak
extern _UNKNOWN loc_1001B1E0; // weak
extern _UNKNOWN loc_1001B2C0; // weak
extern _UNKNOWN loc_1001B3B0; // weak
extern _UNKNOWN loc_1001B560; // weak
extern _UNKNOWN loc_1001B950; // weak
extern _UNKNOWN loc_1001DA50; // weak
extern _UNKNOWN loc_1001EF00; // weak
extern _UNKNOWN loc_10020130; // weak
extern _UNKNOWN loc_100202A0; // weak
extern _UNKNOWN loc_10020840; // weak
extern _UNKNOWN loc_10020910; // weak
extern _UNKNOWN loc_10024010; // weak
extern _UNKNOWN loc_10024A90; // weak
extern _UNKNOWN loc_10024B50; // weak
extern _UNKNOWN loc_10024C20; // weak
extern _UNKNOWN loc_10025270; // weak
extern _UNKNOWN loc_10025A70; // weak
extern _UNKNOWN loc_10025B00; // weak
extern _UNKNOWN sub_10027730; // weak
extern _UNKNOWN loc_10028430; // weak
extern _UNKNOWN loc_10028E10; // weak
extern _UNKNOWN loc_1002B04E; // weak
extern _UNKNOWN loc_1002B17E; // weak
extern _UNKNOWN loc_10030A52; // weak
extern _UNKNOWN loc_10034CEC; // weak
extern _UNKNOWN loc_10035CDD; // weak
extern _UNKNOWN loc_100366F5; // weak
extern _UNKNOWN loc_10036A1A; // weak
extern _UNKNOWN loc_10036B49; // weak
extern _UNKNOWN loc_1003929F; // weak
extern _UNKNOWN loc_1003A4E1; // weak
extern _UNKNOWN loc_1003A527; // weak
extern _UNKNOWN loc_1003A9A6; // weak
extern _UNKNOWN loc_1003AA48; // weak
extern _UNKNOWN loc_1003B1F5; // weak
extern _UNKNOWN loc_1003FA10; // weak
extern _UNKNOWN loc_1004045D; // weak
extern _UNKNOWN loc_10041907; // weak
extern _UNKNOWN loc_10041913; // weak
extern _UNKNOWN loc_10041A7A; // weak
extern _UNKNOWN loc_10041A83; // weak
extern _UNKNOWN loc_10041E17; // weak
extern _UNKNOWN loc_100421C2; // weak
extern _UNKNOWN loc_10042343; // weak
extern _UNKNOWN loc_100426AD; // weak
extern _UNKNOWN loc_10042D48; // weak
extern _UNKNOWN loc_10042D57; // weak
extern _UNKNOWN loc_10042D8A; // weak
extern _UNKNOWN loc_10048102; // weak
extern _UNKNOWN loc_10048135; // weak
extern _UNKNOWN loc_100485D3; // weak
extern _UNKNOWN loc_100495A5; // weak
extern _UNKNOWN sub_1004C2B0; // weak
extern _UNKNOWN loc_1004FFA4; // weak
extern _UNKNOWN loc_100508C9; // weak
extern _UNKNOWN loc_10052D15; // weak
extern _UNKNOWN loc_10052DE3; // weak
extern _UNKNOWN loc_10053315; // weak
extern _UNKNOWN loc_10054C44; // weak
extern _UNKNOWN loc_1005547F; // weak
extern _UNKNOWN loc_100556B7; // weak
extern _UNKNOWN loc_10058500; // weak
extern _UNKNOWN sub_10059238; // weak
extern _UNKNOWN sub_1005925B; // weak
extern _UNKNOWN sub_10059286; // weak
extern _UNKNOWN sub_100592B1; // weak
extern _UNKNOWN sub_100592DE; // weak
extern _UNKNOWN sub_10059307; // weak
extern _UNKNOWN sub_10059344; // weak
extern _UNKNOWN sub_1005936A; // weak
extern _UNKNOWN sub_1005938D; // weak
extern _UNKNOWN sub_100593B8; // weak
extern _UNKNOWN sub_100593E5; // weak
extern _UNKNOWN sub_10059413; // weak
extern _UNKNOWN sub_1005943C; // weak
extern _UNKNOWN sub_10059462; // weak
extern _UNKNOWN sub_10059485; // weak
extern _UNKNOWN sub_100594A8; // weak
extern _UNKNOWN sub_100594CB; // weak
extern _UNKNOWN sub_10059502; // weak
extern _UNKNOWN sub_1005951D; // weak
extern _UNKNOWN sub_1005953B; // weak
extern _UNKNOWN sub_1005957A; // weak
extern _UNKNOWN sub_1005959D; // weak
extern _UNKNOWN sub_100595C0; // weak
extern _UNKNOWN sub_100595DB; // weak
extern _UNKNOWN sub_100595F6; // weak
extern _UNKNOWN sub_10059611; // weak
extern _UNKNOWN sub_1005966D; // weak
extern _UNKNOWN sub_100596B3; // weak
extern _UNKNOWN sub_100596D6; // weak
extern _UNKNOWN sub_100596F9; // weak
extern _UNKNOWN sub_1005971C; // weak
extern _UNKNOWN sub_100597B9; // weak
extern _UNKNOWN sub_10059856; // weak
extern _UNKNOWN sub_1005988A; // weak
extern _UNKNOWN sub_100598B5; // weak
extern _UNKNOWN sub_100598D0; // weak
extern _UNKNOWN sub_10059911; // weak
extern _UNKNOWN sub_10059940; // weak
extern _UNKNOWN sub_1005995B; // weak
extern _UNKNOWN sub_1005998C; // weak
extern _UNKNOWN sub_100599BD; // weak
extern _UNKNOWN sub_100599E2; // weak
extern _UNKNOWN sub_10059A19; // weak
extern _UNKNOWN sub_10059A50; // weak
extern _UNKNOWN sub_10059A73; // weak
extern _UNKNOWN sub_10059A96; // weak
extern _UNKNOWN sub_10059AB9; // weak
extern _UNKNOWN sub_10059ADC; // weak
extern _UNKNOWN sub_10059AF7; // weak
extern _UNKNOWN sub_10059B1D; // weak
extern _UNKNOWN sub_10059B4D; // weak
extern _UNKNOWN sub_10059B7B; // weak
extern _UNKNOWN sub_10059B9E; // weak
extern _UNKNOWN sub_10059BCE; // weak
extern _UNKNOWN sub_10059BF1; // weak
extern _UNKNOWN sub_10059C43; // weak
extern _UNKNOWN sub_10059C69; // weak
extern _UNKNOWN sub_10059C8F; // weak
extern _UNKNOWN sub_10059CB4; // weak
extern _UNKNOWN sub_10059CCF; // weak
extern _UNKNOWN sub_10059D03; // weak
extern _UNKNOWN sub_10059D34; // weak
extern _UNKNOWN sub_10059D57; // weak
extern _UNKNOWN sub_10059D7D; // weak
extern _UNKNOWN sub_10059DA0; // weak
extern _UNKNOWN sub_10059DD4; // weak
extern _UNKNOWN sub_10059E05; // weak
extern _UNKNOWN sub_10059E2B; // weak
extern _UNKNOWN sub_10059E4E; // weak
extern _UNKNOWN sub_10059E71; // weak
extern _UNKNOWN sub_10059EA1; // weak
extern _UNKNOWN sub_10059EC7; // weak
extern _UNKNOWN sub_10059EEA; // weak
extern _UNKNOWN sub_10059F0F; // weak
extern _UNKNOWN sub_10059F32; // weak
extern _UNKNOWN sub_10059F58; // weak
extern _UNKNOWN sub_10059F7E; // weak
extern _UNKNOWN sub_10059FA3; // weak
extern _UNKNOWN sub_10059FC6; // weak
extern _UNKNOWN sub_1005A014; // weak
extern _UNKNOWN sub_1005A06B; // weak
extern _UNKNOWN sub_1005A0A8; // weak
extern _UNKNOWN sub_1005A101; // weak
extern _UNKNOWN sub_1005A164; // weak
extern _UNKNOWN sub_1005A188; // weak
extern _UNKNOWN sub_1005A1B8; // weak
extern _UNKNOWN sub_1005A201; // weak
extern _UNKNOWN sub_1005A220; // weak
extern _UNKNOWN sub_1005A248; // weak
extern _UNKNOWN sub_1005A278; // weak
extern _UNKNOWN sub_1005A2A0; // weak
extern _UNKNOWN sub_1005A2C8; // weak
extern _UNKNOWN sub_1005A300; // weak
extern _UNKNOWN sub_1005A349; // weak
extern _UNKNOWN sub_1005A390; // weak
extern _UNKNOWN sub_1005A3D1; // weak
extern _UNKNOWN sub_1005A3F8; // weak
extern _UNKNOWN sub_1005A430; // weak
extern _UNKNOWN sub_1005A468; // weak
extern _UNKNOWN sub_1005A4B4; // weak
extern _UNKNOWN sub_1005A510; // weak
extern _UNKNOWN sub_1005A554; // weak
extern _UNKNOWN sub_1005A578; // weak
extern _UNKNOWN sub_1005A5C3; // weak
extern _UNKNOWN sub_1005A5F8; // weak
extern _UNKNOWN sub_1005A64F; // weak
extern _UNKNOWN sub_1005A69E; // weak
extern _UNKNOWN sub_1005A6E1; // weak
extern _UNKNOWN sub_1005A70B; // weak
extern _UNKNOWN sub_1005A738; // weak
extern _UNKNOWN sub_1005A773; // weak
extern _UNKNOWN sub_1005A7F6; // weak
extern _UNKNOWN sub_1005A83E; // weak
extern _UNKNOWN sub_1005A86B; // weak
extern _UNKNOWN sub_1005A8BC; // weak
extern _UNKNOWN sub_1005A916; // weak
extern _UNKNOWN sub_1005A948; // weak
extern _UNKNOWN sub_1005A978; // weak
extern _UNKNOWN sub_1005A9A8; // weak
extern _UNKNOWN sub_1005A9E0; // weak
extern _UNKNOWN sub_1005AA60; // weak
extern _UNKNOWN sub_1005AAE0; // weak
extern _UNKNOWN sub_1005AB18; // weak
extern _UNKNOWN sub_1005AB50; // weak
extern _UNKNOWN sub_1005AB99; // weak
extern _UNKNOWN sub_1005AC11; // weak
extern _UNKNOWN sub_1005AC48; // weak
extern _UNKNOWN sub_1005AC9C; // weak
extern _UNKNOWN sub_1005ACE8; // weak
extern _UNKNOWN sub_1005AD20; // weak
extern _UNKNOWN sub_1005AD58; // weak
extern _UNKNOWN sub_1005AD90; // weak
extern _UNKNOWN sub_1005ADD8; // weak
extern _UNKNOWN sub_1005AE48; // weak
extern _UNKNOWN sub_1005AE89; // weak
extern _UNKNOWN sub_1005AEC0; // weak
extern _UNKNOWN sub_1005AEF8; // weak
extern _UNKNOWN sub_1005AF28; // weak
extern _UNKNOWN sub_1005AF58; // weak
extern _UNKNOWN sub_1005AF88; // weak
extern _UNKNOWN sub_1005AFB8; // weak
extern _UNKNOWN sub_1005AFF8; // weak
extern _UNKNOWN sub_1005B03B; // weak
extern _UNKNOWN sub_1005B060; // weak
extern _UNKNOWN sub_1005B088; // weak
extern _UNKNOWN sub_1005B0B8; // weak
extern _UNKNOWN sub_1005B0F0; // weak
extern _UNKNOWN sub_1005B132; // weak
extern _UNKNOWN sub_1005B158; // weak
extern _UNKNOWN sub_1005B1A8; // weak
extern _UNKNOWN sub_1005B1E0; // weak
extern _UNKNOWN sub_1005B210; // weak
extern _UNKNOWN sub_1005B238; // weak
extern _UNKNOWN sub_1005B270; // weak
extern _UNKNOWN sub_1005B2B1; // weak
extern _UNKNOWN sub_1005B2F9; // weak
extern _UNKNOWN sub_1005B330; // weak
extern _UNKNOWN sub_1005B369; // weak
extern _UNKNOWN sub_1005B390; // weak
extern _UNKNOWN sub_1005B3B8; // weak
extern _UNKNOWN sub_1005B3E0; // weak
extern _UNKNOWN sub_1005B408; // weak
extern _UNKNOWN sub_1005B43A; // weak
extern _UNKNOWN sub_1005B468; // weak
extern _UNKNOWN sub_1005B498; // weak
extern _UNKNOWN sub_1005B4EF; // weak
extern _UNKNOWN sub_1005B518; // weak
extern _UNKNOWN sub_1005B556; // weak
extern _UNKNOWN sub_1005B5CA; // weak
extern _UNKNOWN sub_1005B5F8; // weak
extern _UNKNOWN sub_1005B628; // weak
extern _UNKNOWN sub_1005B658; // weak
extern _UNKNOWN sub_1005B698; // weak
extern _UNKNOWN sub_1005B6F3; // weak
extern _UNKNOWN sub_1005B728; // weak
extern _UNKNOWN sub_1005B758; // weak
extern _UNKNOWN sub_1005B7A0; // weak
extern _UNKNOWN sub_1005B7DB; // weak
extern _UNKNOWN sub_1005B80B; // weak
extern _UNKNOWN sub_1005B85C; // weak
extern _UNKNOWN sub_1005B880; // weak
extern _UNKNOWN sub_1005B8C0; // weak
extern _UNKNOWN sub_1005B8F0; // weak
extern _UNKNOWN sub_1005B920; // weak
extern _UNKNOWN sub_1005B948; // weak
extern _UNKNOWN sub_1005B989; // weak
extern _UNKNOWN sub_1005B9D0; // weak
extern _UNKNOWN sub_1005BA30; // weak
extern _UNKNOWN sub_1005BA60; // weak
extern _UNKNOWN sub_1005BAA8; // weak
extern _UNKNOWN sub_1005BAE0; // weak
extern _UNKNOWN sub_1005BB10; // weak
extern _UNKNOWN sub_1005BB48; // weak
extern _UNKNOWN sub_1005BB7F; // weak
extern _UNKNOWN sub_1005BBB8; // weak
extern _UNKNOWN sub_1005BBF0; // weak
extern _UNKNOWN sub_1005BC18; // weak
extern _UNKNOWN sub_1005BC48; // weak
extern _UNKNOWN sub_1005BC81; // weak
extern _UNKNOWN sub_1005BCBB; // weak
extern _UNKNOWN sub_1005BD13; // weak
extern _UNKNOWN sub_1005BD60; // weak
extern _UNKNOWN sub_1005BD85; // weak
extern _UNKNOWN sub_1005BDE3; // weak
extern _UNKNOWN sub_1005BE1B; // weak
extern _UNKNOWN sub_1005BE74; // weak
extern _UNKNOWN sub_1005BEE1; // weak
extern _UNKNOWN sub_1005BF1B; // weak
extern _UNKNOWN sub_1005BF50; // weak
extern _UNKNOWN sub_1005BF80; // weak
extern _UNKNOWN sub_1005BFA0; // weak
extern _UNKNOWN sub_1005BFD0; // weak
extern _UNKNOWN sub_1005C00B; // weak
extern _UNKNOWN sub_1005C048; // weak
extern _UNKNOWN sub_1005C0A1; // weak
extern _UNKNOWN sub_1005C0F1; // weak
extern _UNKNOWN sub_1005C12E; // weak
extern _UNKNOWN sub_1005C163; // weak
extern _UNKNOWN sub_1005C18B; // weak
extern _UNKNOWN sub_1005C1C9; // weak
extern _UNKNOWN sub_1005C200; // weak
extern _UNKNOWN sub_1005C246; // weak
extern _UNKNOWN sub_1005C278; // weak
extern _UNKNOWN sub_1005C2A8; // weak
extern _UNKNOWN sub_1005C2E0; // weak
extern _UNKNOWN sub_1005C300; // weak
extern _UNKNOWN sub_1005C320; // weak
extern _UNKNOWN sub_1005C348; // weak
extern _UNKNOWN sub_1005C390; // weak
extern _UNKNOWN sub_1005C3E0; // weak
extern _UNKNOWN sub_1005C420; // weak
extern _UNKNOWN sub_1005C474; // weak
extern _UNKNOWN sub_1005C498; // weak
extern _UNKNOWN sub_1005C4C8; // weak
extern _UNKNOWN sub_1005C4F8; // weak
extern _UNKNOWN sub_1005C528; // weak
extern _UNKNOWN sub_1005C569; // weak
extern _UNKNOWN sub_1005C598; // weak
extern _UNKNOWN sub_1005C5D9; // weak
extern _UNKNOWN sub_1005C608; // weak
extern _UNKNOWN sub_1005C64B; // weak
extern _UNKNOWN sub_1005C68B; // weak
extern _UNKNOWN sub_1005C6C8; // weak
extern _UNKNOWN sub_1005C6F0; // weak
extern _UNKNOWN sub_1005C729; // weak
extern _UNKNOWN sub_1005C77E; // weak
extern _UNKNOWN sub_1005C7BB; // weak
extern _UNKNOWN sub_1005C80C; // weak
extern _UNKNOWN sub_1005C84E; // weak
extern _UNKNOWN sub_1005C945; // weak
extern _UNKNOWN sub_1005C968; // weak
extern _UNKNOWN sub_1005C99B; // weak
extern _UNKNOWN sub_1005C9E9; // weak
extern _UNKNOWN sub_1005CA26; // weak
extern _UNKNOWN sub_1005CA58; // weak
extern _UNKNOWN sub_1005CA8B; // weak
extern _UNKNOWN sub_1005CAEA; // weak
extern _UNKNOWN sub_1005CB3C; // weak
extern _UNKNOWN sub_1005CB73; // weak
extern _UNKNOWN sub_1005CBC1; // weak
extern _UNKNOWN sub_1005CBF3; // weak
extern _UNKNOWN sub_1005CCC5; // weak
extern _UNKNOWN sub_1005CCE8; // weak
extern _UNKNOWN sub_1005CD9B; // weak
extern _UNKNOWN sub_1005CDEE; // weak
extern _UNKNOWN sub_1005CE18; // weak
extern _UNKNOWN sub_1005CE50; // weak
extern _UNKNOWN sub_1005CED0; // weak
extern _UNKNOWN sub_1005CF10; // weak
extern _UNKNOWN sub_1005CF8C; // weak
extern _UNKNOWN sub_1005CFE0; // weak
extern _UNKNOWN sub_1005D091; // weak
extern _UNKNOWN sub_1005D0D0; // weak
extern _UNKNOWN sub_1005D128; // weak
extern _UNKNOWN sub_1005D168; // weak
extern _UNKNOWN sub_1005D1B1; // weak
extern _UNKNOWN sub_1005D1DB; // weak
extern _UNKNOWN sub_1005D210; // weak
extern _UNKNOWN sub_1005D238; // weak
extern _UNKNOWN sub_1005D268; // weak
extern _UNKNOWN sub_1005D298; // weak
extern _UNKNOWN sub_1005D2CB; // weak
extern _UNKNOWN sub_1005D303; // weak
extern _UNKNOWN sub_1005D33B; // weak
extern _UNKNOWN sub_1005D378; // weak
extern _UNKNOWN sub_1005D3B0; // weak
extern _UNKNOWN sub_1005D3E0; // weak
extern _UNKNOWN sub_1005D408; // weak
extern _UNKNOWN sub_1005D438; // weak
extern _UNKNOWN sub_1005D468; // weak
extern _UNKNOWN sub_1005D498; // weak
extern _UNKNOWN sub_1005D4C8; // weak
extern _UNKNOWN sub_1005D4F8; // weak
extern _UNKNOWN sub_1005D530; // weak
extern _UNKNOWN sub_1005D568; // weak
extern _UNKNOWN sub_1005D598; // weak
extern _UNKNOWN sub_1005D5C8; // weak
extern _UNKNOWN sub_1005D5F8; // weak
extern _UNKNOWN sub_1005D636; // weak
extern _UNKNOWN sub_1005D673; // weak
extern _UNKNOWN sub_1005D6D3; // weak
extern _UNKNOWN sub_1005D729; // weak
extern _UNKNOWN sub_1005D758; // weak
extern _UNKNOWN sub_1005D788; // weak
extern _UNKNOWN sub_1005D7B8; // weak
extern _UNKNOWN unk_1005F200; // weak
extern _UNKNOWN unk_1005F280; // weak
extern _UNKNOWN unk_1005F284; // weak
extern _UNKNOWN unk_1005F29C; // weak
extern _UNKNOWN unk_1005F2A0; // weak
extern _UNKNOWN unk_1005F2B4; // weak
extern _UNKNOWN unk_1005F2B8; // weak
extern _UNKNOWN unk_1005F2BC; // weak
extern int (__stdcall *off_1005F2C4)(char); // weak
extern char aBadAllocation[15]; // weak
extern int (__stdcall *off_1005F2E0)(char); // weak
extern int (__stdcall *off_1005F2EC)(char); // weak
extern int (__stdcall *off_1005F2F8)(char); // weak
extern int (__stdcall *off_1005F304)(char); // weak
extern int (__stdcall *off_1005F310)(char); // weak
extern int (__stdcall *off_1005F31C)(char); // weak
extern char aBadFunctionCal[18]; // weak
extern int (__stdcall *off_1005F33C)(char); // weak
extern int (__stdcall *off_1005F3AC)(char); // weak
extern char aRegex_errorErr[88]; // weak
extern char aRegex_errorE_0[84]; // weak
extern char aRegex_errorE_1[104]; // weak
extern char aRegex_errorE_2[80]; // weak
extern char aRegex_errorE_3[71]; // weak
extern char aRegex_errorE_4[71]; // weak
extern char aRegex_errorE_5[71]; // weak
extern char aRegex_errorE_6[92]; // weak
extern char aRegex_errorE_7[112]; // weak
extern char aRegex_errorE_8[111]; // weak
extern char aRegex_errorE_9[90]; // weak
extern char aRegex_error_10[123]; // weak
extern char aRegex_error_11[146]; // weak
extern char aRegex_error_12[25]; // weak
extern char aRegex_error_13[26]; // weak
extern char aRegex_error[12]; // weak
extern _UNKNOWN unk_1005F8F0; // weak
extern char *off_1005F8F4; // weak
extern _UNKNOWN unk_1005FB48; // weak
extern char *off_1005FB4C; // weak
extern int dword_10060648; // weak
extern int dword_1006064C; // weak
extern int (__stdcall *off_10060654)(char); // weak
extern int (__stdcall *off_10060664)(char); // weak
extern _UNKNOWN unk_10060670; // weak
extern _UNKNOWN unk_10060674; // weak
extern int (*off_1006067C[3])(); // weak
extern int (__stdcall *off_10060698)(char); // weak
extern int (__stdcall *off_100606A4)(char); // weak
extern int (__stdcall *off_100606B0)(char); // weak
extern int (__stdcall *off_100606BC)(char); // weak
extern int (*off_100606C8)(); // weak
extern int (__stdcall *off_100606D0)(char); // weak
extern int (__stdcall *off_10060700)(char); // weak
extern int (__stdcall *off_10060730)(char); // weak
extern int (__stdcall *off_1006075C)(char); // weak
extern int (__stdcall *off_100608DC)(char); // weak
extern char aUnknownExcepti[18]; // weak
extern int (__stdcall *off_100608FC)(char); // weak
extern int (__stdcall *off_10060908)(char); // weak
extern int (__stdcall *off_10060914)(char); // weak
extern int (__stdcall *off_10060920)(char); // weak
extern int (__stdcall *off_1006092C)(char); // weak
extern int (__stdcall *off_1006093C)(char); // weak
extern int (__stdcall *off_1006094C)(char); // weak
extern char aLockAlreadyTak[19]; // weak
extern char aLockAlreadyT_0[31]; // weak
extern int (*off_1006098C[5])(); // weak
extern int (__stdcall *off_100609A4)(int, int); // weak
extern int (*off_100609BC[5])(); // weak
extern int (__stdcall *off_100609D8)(int, int); // weak
extern int (__stdcall *off_100609F4)(int, int); // weak
extern int (__stdcall *off_10060A10)(char); // weak
extern char aPevents[8]; // weak
extern int (__stdcall *off_10060A20)(char); // weak
extern int dword_10060A28[]; // weak
extern int (__stdcall *off_10060BB4)(char); // weak
extern int (__stdcall *off_10060BC0)(char); // weak
extern int (__stdcall *off_10060BCC)(char); // weak
extern int (__stdcall *off_10060BD8)(int); // weak
extern int (__stdcall *off_10060BE4)(char); // weak
extern int (*off_10060BEC[5])(); // weak
extern int (*off_10060C0C[5])(); // weak
extern int (__stdcall *off_10060C58)(char); // weak
extern int (*off_10060C64[2])(); // weak
extern char aBadException[14]; // weak
extern char a_debugmallocat[52]; // weak
extern int (*off_10060CBC[2])(); // weak
extern int (*off_10060CD0)(); // weak
extern int (__stdcall *off_10060CE4)(char); // weak
extern int (__stdcall *off_10060CF0)(char); // weak
extern int (__stdcall *off_10060CFC)(char); // weak
extern int (__stdcall *off_10060D08)(char); // weak
extern int (__stdcall *off_10060D14)(char); // weak
extern int (__stdcall *off_10060D20)(char); // weak
extern int (__stdcall *off_10060D2C)(char); // weak
extern int (__stdcall *off_10060D38)(char); // weak
extern int (__stdcall *off_10060D44)(char); // weak
extern int (__stdcall *off_10060D50)(char); // weak
extern int (__stdcall *off_10060D5C)(char); // weak
extern int (__stdcall *off_10060D68)(char); // weak
extern int (__stdcall *off_10060D74)(char); // weak
extern struct _EXCEPTION_POINTERS ExceptionInfo; // idb
extern const WCHAR LibFileName[]; // idb
extern char ProcName[]; // idb
extern char aUnregistertrac[21]; // weak
extern char aTraceevent[11]; // weak
extern char aGettracelogger[21]; // weak
extern char aGettraceenable[20]; // weak
extern char aGettraceenab_0[20]; // weak
extern int (__stdcall *off_10060E1C)(char); // weak
extern int (*off_10060E30[4])(); // weak
extern int (__stdcall *off_10060E48)(char); // weak
extern int (__stdcall *off_10060E80)(char); // weak
extern int (__stdcall *off_10060E88)(char); // weak
extern int (__stdcall *off_10060E94)(char); // weak
extern int (__stdcall *off_10060EF8)(char); // weak
extern int (__stdcall *off_10060F0C)(int, int); // weak
extern int (__stdcall *off_10060F38)(char); // weak
extern int (__stdcall *off_10060F4C)(int, int); // weak
extern char aEventobject[12]; // weak
extern char aPpvirtualproce[24]; // weak
extern char aCount[6]; // weak
extern int (__stdcall *dword_10060FA0)(_DWORD, _DWORD, _DWORD); // weak
extern _UNKNOWN unk_10060FA4; // weak
extern int (__cdecl *off_10060FC4)(_DWORD, _DWORD); // weak
extern wchar_t asc_100610C8[33]; // weak
extern _UNKNOWN unk_10061550; // weak
extern _UNKNOWN unk_100616D0; // weak
extern int (__cdecl *off_100617D0)(_DWORD); // weak
extern const WCHAR ModuleName[]; // idb
extern char aFlsalloc[]; // idb
extern char aFlsfree[]; // idb
extern char aFlsgetvalue[]; // idb
extern char aFlssetvalue[]; // idb
extern char aInitializecrit[]; // idb
extern char aCreatesemaphor[]; // idb
extern char aSetthreadstack[]; // idb
extern char aCreatethreadpo[]; // idb
extern char aSetthreadpoolt[]; // idb
extern char aWaitforthreadp[]; // idb
extern char aClosethreadpoo[]; // idb
extern char aCreatethread_0[]; // idb
extern char aSetthreadpoolw[]; // idb
extern char aClosethreadp_0[]; // idb
extern char aFlushprocesswr[]; // idb
extern char aFreelibrarywhe[]; // idb
extern char aGetcurrentpr_0[]; // idb
extern char aGetlogicalpr_0[]; // idb
extern char aCreatesymbolic[]; // idb
extern char aSetdefaultdlld[]; // idb
extern char aEnumsystemloca[]; // idb
extern char aComparestringe[]; // idb
extern char aGetdateformate[]; // idb
extern char aGetlocaleinfoe[]; // idb
extern char aGettimeformate[]; // idb
extern char aGetuserdefault[]; // idb
extern char aIsvalidlocalen[]; // idb
extern char aLcmapstringex[]; // idb
extern char aGetcurrentpack[]; // idb
extern int dword_10061A58[]; // weak
extern _DWORD off_10061A5C[2]; // idb
extern void *off_10062178; // weak
extern int dword_1006217C[]; // weak
extern char aTz[3]; // weak
extern const WCHAR aMscoree_dll[]; // idb
extern char aCorexitprocess[]; // idb
extern char aSetthreadgroup[]; // idb
extern char aGetthreadgroup[]; // idb
extern char aGetcurrentproc[]; // idb
extern char aGetlogicalproc[]; // idb
extern int (*off_10063BE8[2])(); // weak
extern int (*off_10063BF4[4])(); // weak
extern int (*off_10063C0C[2])(); // weak
extern char aPscheduler[11]; // weak
extern int dword_100644C8[]; // weak
extern _DWORD off_100644CC[2]; // idb
extern wchar_t aRuntimeErrorPr[26]; // weak
extern wchar_t aProgramNameUnk[23]; // weak
extern wchar_t a___[4]; // weak
extern wchar_t asc_10064648[3]; // weak
extern wchar_t aMicrosoftVisua[37]; // weak
extern int (__stdcall *off_100646A0)(char); // weak
extern int (__stdcall *off_100646B4)(int, int); // weak
extern char aProc[5]; // weak
extern wchar_t *off_100646E4[4]; // weak
extern wchar_t *off_100646E8[3]; // weak
extern wchar_t *off_100646EC[2]; // weak
extern wchar_t *off_100646F0; // weak
extern int (*off_10064A50)(); // weak
extern wchar_t *off_10064A54; // weak
extern wchar_t *off_10064A84; // weak
extern const CHAR MultiByteStr; // idb
extern wchar_t asc_10064B90[3]; // weak
extern wchar_t asc_10064B98[2]; // weak
extern wchar_t aC[2]; // weak
extern wchar_t a__[4]; // weak
extern int (__stdcall *off_10064D10)(char); // weak
extern int (*off_10064D38[5])(); // weak
extern int (*off_10064D50[3])(); // weak
extern int (*off_10064D7C[5])(); // weak
extern char aPthreadproxy[13]; // weak
extern int (*off_10064DDC[5])(); // weak
extern int (*off_10064E28[7])(); // weak
extern int (*off_10064E48[3])(); // weak
extern int (*off_10064E74[5])(); // weak
extern int (*off_10064EC0[2])(); // weak
extern int (__stdcall *off_10064EE4)(int); // weak
extern _UNKNOWN unk_10064F48; // weak
extern int dword_10064FD8; // weak
extern int dword_10064FE0; // weak
extern int dword_10064FE4; // weak
extern _UNKNOWN unk_10064FE8; // weak
extern _UNKNOWN unk_10064FEC; // weak
extern _UNKNOWN unk_10064FF0; // weak
extern char aLog10[6]; // weak
extern char aAsin[5]; // weak
extern char aAcos[5]; // weak
extern char aAtan[5]; // weak
extern char aSqrt_0[5]; // weak
extern char aSin[4]; // weak
extern char aCos[4]; // weak
extern char aTan[4]; // weak
extern char aCeil[5]; // weak
extern char aFloor[6]; // weak
extern char aModf[5]; // weak
extern char aE000[6]; // weak
extern _UNKNOWN unk_100650DC; // weak
extern int (*off_10065138[2])(); // weak
extern char aPcontext[9]; // weak
extern const WCHAR aCombase_dll[]; // idb
extern char aRoinitialize[]; // idb
extern char aRouninitialize[15]; // weak
extern int (*off_100651E0)(); // weak
extern int (*off_100651FC[5])(); // weak
extern int dword_10065214[]; // weak
extern void *off_10065224; // weak
extern int (__stdcall *off_10065228)(int, int); // weak
extern int (__stdcall *off_10065254)(int, int); // weak
extern const WCHAR aUser32_dll[]; // idb
extern char aMessageboxw[]; // idb
extern char aGetactivewindo[]; // idb
extern char aGetlastactivep[]; // idb
extern char aGetuserobjecti[]; // idb
extern char aGetprocesswind[]; // idb
extern wchar_t *off_10065A20; // weak
extern wchar_t *off_100664D0; // weak
extern int dword_100667A4; // weak
extern int dword_100667A8; // weak
extern wchar_t aAcp[4]; // weak
extern wchar_t aOcp[4]; // weak
extern __int16 word_100667BC; // weak
extern char byte_100667D0[]; // weak
extern int (__stdcall *off_10066830)(char); // weak
extern int (*off_10066858[2])(); // weak
extern int (*off_10066884[2])(); // weak
extern char aSwitchstate[12]; // weak
extern char aBadDynamic_cas[18]; // weak
extern int (*off_100668F4[4])(); // weak
extern char a1Snan[7]; // weak
extern char a1Ind[6]; // weak
extern char a1Inf[6]; // weak
extern char a1Qnan[7]; // weak
extern _UNKNOWN unk_10066E6A; // weak
extern const WCHAR FileName[]; // idb
extern char aExp10[6]; // weak
extern char aJsonParsingFai[20]; // weak
extern char byte_10066F54; // weak
extern char aSymbol[7]; // weak
extern char aStart[6]; // weak
extern char aEnd[4]; // weak
extern char aData[5]; // weak
extern char aClass[6]; // weak
extern char aComment[8]; // weak
extern char aRequestIsNotRe[21]; // weak
extern const WCHAR szHeaders[]; // idb
extern void *off_10066FE0; // weak
extern int (__stdcall *off_10066FFC)(char); // weak
extern int (__stdcall *off_10067004[2])(int); // weak
extern void *off_10067020; // weak
extern int (__stdcall *off_1006703C[2])(char); // weak
extern int (__stdcall *off_10067040)(char); // weak
extern int (*off_10067044)(); // weak
extern int (*off_10067054)(); // weak
extern void *off_10067064; // weak
extern int (*off_10067080[5])(); // weak
extern int (__stdcall *off_1006709C[4])(int); // weak
extern int (__stdcall *off_100670AC)(char); // weak
extern int (__stdcall *off_100670C8)(char); // weak
extern int (__stdcall *off_100670D0)(char); // weak
extern int (__stdcall *off_100670D8)(char); // weak
extern int (__stdcall *off_100670E0)(char); // weak
extern int (*off_100670FC)(); // weak
extern char aThenCannotBeCa[55]; // weak
extern int (__stdcall *off_10067144)(char); // weak
extern char aVectorTTooLong[19]; // weak
extern char aWaitCannotBeCa[55]; // weak
extern int (*off_100671D0)(); // weak
extern void *off_100671E0; // weak
extern int (__stdcall *off_100671FC)(char); // weak
extern int (__stdcall *off_10067204)(char); // weak
extern int (__stdcall *off_1006720C)(char); // weak
extern _UNKNOWN unk_1006723C; // weak
extern int (__stdcall *off_10067240)(char); // weak
extern char a__[23]; // weak
extern int (__stdcall *off_1006727C)(char); // weak
extern char aGeneric[8]; // weak
extern char aUnknownError[14]; // weak
extern char aIostream[9]; // weak
extern char aIostreamStream[22]; // weak
extern char aSystem[7]; // weak
extern _DWORD dword_100672E4[4]; // idb
extern _DWORD dword_100672F4[4]; // idb
extern _DWORD dword_10067304[4]; // idb
extern _DWORD dword_10067324[4]; // idb
extern _UNKNOWN unk_10067334; // weak
extern int (__stdcall *off_1006737C)(char); // weak
extern _UNKNOWN unk_10067384; // weak
extern int (__stdcall *off_1006738C)(char); // weak
extern int (__stdcall *off_10067398)(char); // weak
extern char aFalse[6]; // weak
extern char aTrue[5]; // weak
extern char aAValidJsonDocu[66]; // weak
extern char aSyntaxErrorVal[47]; // weak
extern char byte_10067424[]; // weak
extern char byte_10067428[]; // weak
extern char byte_10067430[]; // weak
extern _UNKNOWN unk_10067434; // weak
extern char aMissingAfterOb[37]; // weak
extern char aMissingOrInObj[41]; // weak
extern char aMissingOrObjec[34]; // weak
extern char aMissingOrInArr[40]; // weak
extern char aIsNotANumber_[19]; // weak
extern char asc_100674EC[2]; // weak
extern char aLf[4]; // weak
extern char aAdditionalSixC[68]; // weak
extern char aExpectingAnoth[80]; // weak
extern char aBadUnicodeEsca[61]; // weak
extern char aBadUnicodeEs_0[67]; // weak
extern char aCommentsMustSt[27]; // weak
extern char a_16g[7]; // weak
extern _UNKNOWN unk_10067880; // weak
extern _UNKNOWN unk_10067888; // weak
extern _UNKNOWN unk_1006788C; // weak
extern _UNKNOWN unk_10067890; // weak
extern _UNKNOWN unk_10067894; // weak
extern _UNKNOWN unk_10067898; // weak
extern _UNKNOWN unk_1006789C; // weak
extern _UNKNOWN unk_100678A0; // weak
extern _UNKNOWN unk_100678A4; // weak
extern char aNull[5]; // weak
extern char asc_100678B4[2]; // weak
extern char asc_100678B8[2]; // weak
extern char asc_100678BC[2]; // weak
extern char asc_100678C0[2]; // weak
extern char asc_100678C4[3]; // weak
extern char asc_100678C8[2]; // weak
extern char asc_100678CC[2]; // weak
extern char aInvalidMapSetT[28]; // weak
extern char aMapSetTTooLong[20]; // weak
extern char aPp[3]; // weak
extern char aEe[3]; // weak
extern char aP[3]; // weak
extern char aLu[3]; // weak
extern char aLd[3]; // weak
extern char aLu_0[3]; // weak
extern char aLd_0[3]; // weak
extern int (__stdcall *off_10067934)(char); // weak
extern int (__stdcall *off_10067970)(char); // weak
extern int (*off_100679AC[6])(); // weak
extern int (*off_100679B8[3])(); // weak
extern char aBadLocaleName[16]; // weak
extern char aBadCast[9]; // weak
extern char aBIUrl__1[26]; // weak
extern char aB[2]; // weak
extern char aI[2]; // weak
extern char aUrl[4]; // weak
extern int (__stdcall *off_10067B00[5])(char); // weak
extern int (__stdcall *off_10067B04[4])(char); // weak
extern int (__stdcall *off_10067B08[3])(char); // weak
extern int (__stdcall *off_10067B0C[2])(char); // weak
extern int (__stdcall *off_10067B10)(char); // weak
extern char *off_10067B18; // weak
extern int dword_10067B1C; // weak
extern __int16 word_10067B20[]; // weak
extern char aForexsensati_0[15]; // weak
extern char a1_01[5]; // weak
extern wchar_t aHttpForexsensa[33]; // weak
extern wchar_t aHttpForexsen_0[45]; // weak
extern char aName[5]; // weak
extern char aVersion[8]; // weak
extern char aCode[5]; // weak
extern char aBroker[7]; // weak
extern char aServer[7]; // weak
extern char aAccount[8]; // weak
extern char aType[5]; // weak
extern char aBalance[8]; // weak
extern char aCurrency[9]; // weak
extern char aFlags[6]; // weak
extern char aUtc_0[4]; // weak
extern char aMsg1[5]; // weak
extern char aMsg2[5]; // weak
extern char aAuth_interval[14]; // weak
extern int (__stdcall *off_10067EC0[2])(int); // weak
extern int (__stdcall *off_10067EDC[3])(int); // weak
extern void *off_10067F14; // weak
extern void *off_10067F30; // weak
extern void *off_10067F4C; // weak
extern void *off_10067F68; // weak
extern void *off_10067F84; // weak
extern int (__stdcall *off_10067FA0)(char); // weak
extern int (__stdcall *off_10067FC8)(char); // weak
extern int (*off_10067FF0)(); // weak
extern int (__stdcall *off_10068000)(char); // weak
extern int (__stdcall *off_10068008[3])(int, int, int); // weak
extern int (__stdcall *off_10068020)(char); // weak
extern int (*off_10068024)(); // weak
extern char a_ptarget[9]; // weak
extern int (__stdcall *off_10068108)(char); // weak
extern void *off_10068168; // weak
extern int (*off_10068188)(); // weak
extern int (__stdcall *off_100681E0)(char); // weak
extern void *off_1006824C; // weak
extern int (__stdcall *off_10068264)(char); // weak
extern int (__stdcall *off_100682F4)(char); // weak
extern int (__stdcall *off_10068320)(char); // weak
extern char aDeletingLinkRe[53]; // weak
extern int (__stdcall *off_10068380[3])(int); // weak
extern int (__stdcall *off_100683A4)(char); // weak
extern wchar_t aClient[7]; // weak
extern char aInvalidConnect[19]; // weak
extern wchar_t aPost[5]; // weak
extern wchar_t aGet[4]; // weak
extern int (__stdcall *off_10068434)(char); // weak
extern _UNKNOWN unk_1006AA64; // weak
extern _UNKNOWN unk_1006AA6C; // weak
extern _UNKNOWN unk_1006AA70; // weak
extern _UNKNOWN unk_1006AAA8; // weak
extern _UNKNOWN unk_1006AAE4; // weak
extern _UNKNOWN unk_1006AB20; // weak
extern _UNKNOWN unk_1006AB58; // weak
extern _UNKNOWN unk_1006AD40; // weak
extern _UNKNOWN unk_1006B060; // weak
extern _UNKNOWN unk_1006B098; // weak
extern _UNKNOWN unk_1006B0D0; // weak
extern _UNKNOWN unk_1006B170; // weak
extern _UNKNOWN unk_1006B434; // weak
extern _UNKNOWN unk_1006B6E0; // weak
extern _UNKNOWN unk_1006B718; // weak
extern _UNKNOWN unk_1006B750; // weak
extern _EH4_SCOPETABLE stru_1006B818[1]; // weak
extern _UNKNOWN unk_1006BB80; // weak
extern _UNKNOWN unk_1006C02C; // weak
extern _UNKNOWN unk_1006C064; // weak
extern _UNKNOWN unk_1006C09C; // weak
extern _UNKNOWN unk_1006C1EC; // weak
extern _UNKNOWN unk_1006C224; // weak
extern _UNKNOWN unk_1006C25C; // weak
extern _UNKNOWN unk_1006C294; // weak
extern _UNKNOWN unk_1006C410; // weak
extern _UNKNOWN unk_1006C6B4; // weak
extern _UNKNOWN unk_1006C778; // weak
extern _UNKNOWN unk_1006C7D0; // weak
extern _UNKNOWN unk_1006C878; // weak
extern _UNKNOWN unk_1006C8B4; // weak
extern _UNKNOWN unk_1006C92C; // weak
extern _UNKNOWN unk_1006C964; // weak
extern _UNKNOWN unk_1006C99C; // weak
extern _UNKNOWN unk_1006CA48; // weak
extern volatile LONG Addend; // idb
extern int dword_10072258; // weak
extern int dword_1007236C; // weak
extern DWORD dwSpinCount; // idb
extern int (__stdcall **off_100728A4)(char); // weak
extern int (__stdcall **off_100728C4)(char); // weak
extern void **off_10072C50; // weak
extern void *off_10072C58; // weak
extern void *off_10072C5C; // weak
extern void *off_10072C60; // weak
extern void *off_10072C64; // weak
extern void *off_10072C68; // weak
extern void *off_10072C6C; // weak
extern void *off_10072C70; // weak
extern void *off_10072C74; // weak
extern void *off_10072C78; // weak
extern void *off_10072C7C; // weak
extern void *off_10072C88; // weak
extern void *off_10072C8C; // weak
extern void *off_10072C90; // weak
extern void *off_10072C94; // weak
extern void *off_10072C98; // weak
extern void *off_10072C9C; // weak
extern void *off_10072CA0; // weak
extern void *off_10072CA4; // weak
extern void *off_10072CB0; // weak
extern int dword_10072D14; // weak
extern LPCRITICAL_SECTION lpCriticalSection; // idb
extern wchar_t *off_10073080; // weak
extern void *off_10073084; // weak
extern int dword_10073088[]; // weak
extern int dword_1007308C[]; // weak
extern _UNKNOWN unk_100731F0; // weak
extern _UNKNOWN unk_100731F4; // weak
extern int __security_cookie; // weak
extern int dword_10073204; // weak
extern int dword_10073210; // weak
extern int dword_10073228; // weak
extern int dword_10073238; // weak
extern int dword_10073240; // weak
extern int dword_10073244; // weak
extern int dword_10073248; // weak
extern void *off_100732D0; // weak
extern int dword_100732D8; // weak
extern int dword_100732DC; // weak
extern int dword_100732E0; // weak
extern int dword_100732E4; // weak
extern int dword_100732E8; // weak
extern int dword_100732EC; // weak
extern int dword_100732F0[]; // weak
extern int dword_10073324; // weak
extern _UNKNOWN unk_10073360; // weak
extern _UNKNOWN unk_10073368; // weak
extern int dword_100734B0; // weak
extern LPVOID lpAddend; // idb
extern char byte_100734BC[]; // weak
extern int dword_100734C0; // weak
extern char aVyv[6]; // weak
extern char aJ[3]; // weak
extern char byte_100735B0[]; // weak
extern char byte_100736B8[]; // weak
extern _UNKNOWN unk_100737B8; // weak
extern _UNKNOWN unk_100739D8; // weak
extern void *off_100739E0; // weak
extern volatile LONG *off_10073B44; // idb
extern volatile LONG dword_10073B48; // idb
extern wchar_t *off_10073BD8; // weak
extern int *off_10073C00; // weak
extern int dword_10073C0C; // weak
extern wchar_t *off_10073C10; // weak
extern char *off_10073C14; // weak
extern wchar_t *off_10073C18; // weak
extern _UNKNOWN unk_10073C1C; // weak
extern char *off_10073C44[11]; // weak
extern char *off_10073C4C[9]; // weak
extern void *off_10073DD8; // weak
extern _UNKNOWN unk_10074038; // weak
extern _UNKNOWN unk_10074058; // weak
extern _UNKNOWN unk_10074060; // weak
extern double dbl_100740A0; // weak
extern double dbl_100740A8; // weak
extern double dbl_100740B0; // weak
extern double dbl_100740C0; // weak
extern int dword_100740C8[]; // weak
extern void *off_100740CC; // weak
extern int dword_100741C8; // weak
extern int (*off_100741CC[10])(); // weak
extern int (*off_100741D0[9])(); // weak
extern int (*off_100741D4[8])(); // weak
extern int (*off_100741D8[7])(); // weak
extern int (*off_100741DC[6])(); // weak
extern int (*off_100741E0[5])(); // weak
extern PVOID off_100741E4; // idb
extern PVOID off_100741E8; // idb
extern PVOID off_100741EC; // idb
extern PVOID off_100741F0; // idb
extern _DWORD dword_10074470[4]; // idb
extern int dword_10074480; // weak
extern char byte_10074538[]; // weak
extern int dword_10074638; // weak
extern int dword_1007463C; // weak
extern int dword_10074640; // weak
extern int dword_10074644; // weak
extern int dword_10074648; // weak
extern int dword_1007464C; // weak
extern int dword_10074650; // weak
extern int dword_10074654; // weak
extern int dword_10074658; // weak
extern int dword_1007465C; // weak
extern int dword_10074660; // weak
extern int dword_10074664; // weak
extern HANDLE hConsoleOutput; // idb
extern _UNKNOWN unk_10074678; // weak
extern _UNKNOWN unk_100747D8; // weak
extern int (__stdcall **off_10074940)(char); // weak
extern int (__stdcall **off_10074978)(char); // weak
extern int (__stdcall **off_100749B0)(char); // weak
extern int (__stdcall **off_100749E8)(char); // weak
extern int (__stdcall **off_10074B58)(char); // weak
extern int (__stdcall **off_10074C14)(char); // weak
extern int (__stdcall **off_10074C4C)(char); // weak
extern int (__stdcall **off_10074C84)(char); // weak
extern int (__stdcall **off_10074CBC)(char); // weak
extern int (__stdcall **off_10074CF4)(char); // weak
extern int (__stdcall **off_10074D2C)(char); // weak
extern int (__stdcall **off_10074D64)(char); // weak
extern int (__stdcall **off_10074DA0)(char); // weak
extern __int64 qword_10074E70; // weak
extern __int16 word_10074E78; // weak
extern _UNKNOWN unk_10074E80; // weak
extern int dword_10074EB8; // weak
extern int dword_10074ED8; // weak
extern int dword_10074EDC; // weak
extern char byte_10074EE8; // weak
extern int dword_10074F10; // weak
extern int dword_10074F20; // weak
extern int dword_10074F24; // weak
extern _UNKNOWN unk_10074F28; // weak
extern int dword_10074F60; // weak
extern __int16 word_10074F78; // weak
extern __int16 word_10074F7C; // weak
extern _UNKNOWN unk_10074F80; // weak
extern int dword_10074FB8; // weak
extern char byte_10074FC0; // weak
extern int dword_10074FD0; // weak
extern int dword_10074FE0; // weak
extern int dword_10074FE4; // weak
extern int dword_10074FE8; // weak
extern int dword_10074FF8; // weak
extern int dword_10074FFC; // weak
extern int dword_10075000; // weak
extern int dword_10075010; // weak
extern int dword_10075014; // weak
extern int dword_10075018; // weak
extern int dword_10075028; // weak
extern int dword_1007502C; // weak
extern LPCWSTR pszAgentW; // idb
extern int dword_10075040; // weak
extern int dword_10075044; // weak
extern int (__stdcall *off_10075048[3])(char); // weak
extern int (__stdcall *off_1007504C[2])(char); // weak
extern char byte_100750B0[]; // weak
extern int dword_100750C4; // weak
extern int dword_100750C8; // weak
extern int dword_100750CC; // weak
extern int dword_100750D0; // weak
extern int dword_100750D4; // weak
extern int dword_100750E8; // weak
extern char byte_100750F0; // weak
extern _UNKNOWN unk_100750F8; // weak
extern struct _RTL_CRITICAL_SECTION CriticalSection; // idb
extern _UNKNOWN unk_10075160; // weak
extern int dword_10075164; // weak
extern _UNKNOWN unk_10075168; // weak
extern _UNKNOWN dword_10075190; // weak
extern _UNKNOWN unk_100751B8; // weak
extern int dword_1007525C; // weak
extern int dword_10075260; // weak
extern int dword_10075268; // weak
extern int dword_10075270; // weak
extern int dword_10075274; // weak
extern int dword_10075280; // weak
extern int dword_10075284; // weak
extern int dword_1007528C; // weak
extern int dword_10075290; // weak
extern int dword_10075294; // weak
extern int dword_100752D0; // weak
extern __int16 word_1007535C; // weak
extern __int16 word_10075360; // weak
extern __int16 word_10075364; // weak
extern __int16 word_10075368; // weak
extern int dword_1007536C; // weak
extern int dword_10075370; // weak
extern int dword_10075374; // weak
extern int dword_10075378; // weak
extern int dword_1007537C; // weak
extern int dword_10075380; // weak
extern int dword_10075384; // weak
extern int dword_10075388; // weak
extern __int16 word_1007538C; // weak
extern int dword_10075390; // weak
extern int dword_10075394; // weak
extern __int16 word_10075398; // weak
extern int dword_1007559C; // weak
extern int dword_100755A8; // weak
extern char byte_100755AC; // weak
extern int dword_100755B0; // weak
extern int dword_100755B4; // weak
extern int dword_100755B8; // weak
extern int dword_100755C0; // weak
extern int dword_100755C4; // weak
extern int dword_100755D0; // weak
extern int dword_100755D4; // weak
extern DWORD dwTlsIndex; // idb
extern _UNKNOWN unk_100755DC; // weak
extern int dword_100755E0; // weak
extern int dword_100755E4; // weak
extern _UNKNOWN unk_10075600; // weak
extern HMODULE hLibModule; // idb
extern int dword_1007560C; // weak
extern int dword_10075610; // weak
extern LPVOID dword_10075614; // idb
extern _UNKNOWN unk_10075620; // weak
extern int dword_10075770; // weak
extern int dword_10075774; // weak
extern int (__stdcall *dword_10075778)(_DWORD, _DWORD, _DWORD); // weak
extern int dword_1007577C; // weak
extern PVOID dword_10075784; // idb
extern LPVOID lpMem; // idb
extern int dword_1007578C; // weak
extern int dword_10075790; // weak
extern struct _TIME_ZONE_INFORMATION TimeZoneInformation; // idb
extern PVOID dword_10075844; // idb
extern char byte_1007584C; // weak
extern int dword_10075850; // weak
extern int dword_10075858; // weak
extern int dword_1007585C; // weak
extern int dword_10075860; // weak
extern LPVOID dword_10075864; // idb
extern LPVOID dword_10075868; // idb
extern LPVOID dword_1007586C; // idb
extern LPVOID dword_10075870; // idb
extern int dword_10075874; // weak
extern PVOID dword_1007587C; // idb
extern int dword_10075880; // weak
extern int dword_10075884; // weak
extern int dword_10075888; // weak
extern _UNKNOWN unk_1007588C; // weak
extern int dword_10075890; // weak
extern ULONG_PTR ProcessAffinityMask; // idb
extern ULONG_PTR SystemAffinityMask; // idb
extern int dword_1007589C; // weak
extern int dword_100758A0; // weak
extern int dword_100758A4; // weak
extern char byte_100758A8; // weak
extern int dword_100758AC; // weak
extern int dword_100758B0; // weak
extern int dword_100758B4; // weak
extern int dword_100758B8; // weak
extern LPVOID dword_100758BC; // idb
extern int dword_100758C8; // weak
extern _UNKNOWN unk_100758D0; // weak
extern WCHAR Filename; // idb
extern __int16 word_10075B0A; // weak
extern PVOID dword_10075EF8; // idb
extern _UNKNOWN unk_10075EFC; // weak
extern LPVOID dword_10075F00; // idb
extern int dword_10075F0C; // weak
extern int dword_10075F10; // weak
extern int dword_10075F14; // weak
extern __int16 word_10075F18[]; // weak
extern int dword_10075F24; // weak
extern int dword_10075F28; // weak
extern int dword_10075F2C; // weak
extern HANDLE hHeap; // idb
extern int dword_10075F38; // weak
extern union _SLIST_HEADER ListHead; // idb
extern int dword_10075F48; // weak
extern int dword_10075F4C; // weak
extern int dword_10075F50; // weak
extern int dword_10075F54; // weak
extern int dword_10075F58; // weak
extern DWORD dword_10075F70; // idb
extern int dword_10075F78; // weak
extern int dword_10075F80[]; // weak
extern char byte_10076080[260]; // idb
extern char byte_10076184; // weak
extern PVOID dword_10076188; // idb
extern int dword_1007618C; // weak
extern PVOID dword_10076190; // idb
extern int dword_10076194; // weak
extern int dword_1007619C; // weak
extern LPVOID dword_100761A0; // idb
extern LPVOID dword_100761A4; // idb
extern int dword_100761B0; // weak
extern int dword_100761B4; // weak
extern int dword_100761B8; // weak
extern _UNKNOWN unk_100761BC; // weak
extern int dword_100761C4; // weak
extern int dword_100761C8; // weak
extern PVOID dword_100761CC; // idb
extern PVOID dword_100761D0; // idb
extern PVOID dword_100761D4; // idb
extern PVOID dword_100761D8; // idb
extern PVOID dword_100761DC; // idb
extern int dword_10076220; // weak
extern char byte_10076230; // weak
extern _UNKNOWN unk_10076234; // weak
extern int dword_10076298; // weak
extern int dword_100762A0; // weak
extern int dword_100762A4; // weak
extern int dword_100762A8; // weak
extern int dword_100762AC; // weak
extern int dword_100762B0; // weak
extern int dword_100762B4; // weak
extern int dword_100762B8; // weak
extern __int64 qword_100762C0; // weak
extern int dword_100762C8; // weak
extern int dword_100762CC; // weak
extern int dword_100762D0; // weak
extern char byte_100762D4; // weak
extern int dword_100762E4; // weak
extern int dword_100762E8; // weak
extern __int64 qword_100762F0; // weak
extern int dword_100762F8; // weak
extern int dword_100762FC; // weak
extern int dword_10076300; // weak
extern char byte_10076304; // weak
extern int dword_10076314; // weak
extern int dword_10076318; // weak
extern __int64 qword_10076320; // weak
extern int dword_10076328; // weak
extern int dword_1007632C; // weak
extern int dword_10076330; // weak
extern char byte_10076334; // weak
extern int dword_10076344; // weak
extern int dword_10076348; // weak
extern __int64 qword_10076350; // weak
extern int dword_10076358; // weak
extern int dword_1007635C; // weak
extern int dword_10076360; // weak
extern char byte_10076364; // weak
extern int dword_10076374; // weak
extern int dword_10076378; // weak
extern __int64 qword_10076380; // weak
extern int dword_10076388; // weak
extern int dword_1007638C; // weak
extern int dword_10076390; // weak
extern char byte_10076394; // weak
extern int dword_100763A4; // weak
extern int dword_100763A8; // weak
extern __int64 qword_100763B0; // weak
extern int dword_100763B8; // weak
extern int dword_100763BC; // weak
extern int dword_100763C0; // weak
extern char byte_100763C4; // weak
extern int dword_100763D4; // weak
extern int dword_100763D8; // weak
extern __int64 qword_100763E0; // weak
extern int dword_100763E8; // weak
extern int dword_100763EC; // weak
extern int dword_100763F0; // weak
extern char byte_100763F4; // weak
extern int dword_10076404; // weak
extern int dword_10076408; // weak
extern __int64 qword_10076410; // weak
extern int dword_10076418; // weak
extern int dword_1007641C; // weak
extern int dword_10076420; // weak
extern char byte_10076424; // weak
extern int dword_10076434; // weak
extern int dword_10076438; // weak
extern __int64 qword_10076440; // weak
extern int dword_10076448; // weak
extern int dword_1007644C; // weak
extern int dword_10076450; // weak
extern char byte_10076454; // weak
extern int dword_10076464; // weak
extern int dword_10076468; // weak
extern __int64 qword_10076470; // weak
extern int dword_10076478; // weak
extern int dword_1007647C; // weak
extern int dword_10076480; // weak
extern char byte_10076484; // weak
extern int dword_10076494; // weak
extern int dword_10076498; // weak
extern __int64 qword_100764A0; // weak
extern int dword_100764A8; // weak
extern int dword_100764AC; // weak
extern int dword_100764B0; // weak
extern char byte_100764B4; // weak
extern int dword_100764C4; // weak
extern int dword_100764C8; // weak
extern __int64 qword_100764D0; // weak
extern int dword_100764D8; // weak
extern int dword_100764DC; // weak
extern int dword_100764E0; // weak
extern char byte_100764E4; // weak
extern int dword_100764F4; // weak
extern int dword_100764F8; // weak
extern __int64 qword_10076500; // weak
extern int dword_10076508; // weak
extern int dword_1007650C; // weak
extern int dword_10076510; // weak
extern char byte_10076514; // weak
extern int dword_10076524; // weak
extern int dword_10076528; // weak
extern char byte_10076530; // weak
extern int dword_10076540; // weak
extern int dword_10076544; // weak
extern int dword_10076548; // weak
extern int dword_1007654C; // weak
extern _UNKNOWN unk_10076550; // weak
extern int dword_10076558; // weak
extern int dword_10076568; // weak
extern int dword_1007656C; // weak
extern int dword_10076570; // weak
extern int dword_10076580; // weak
extern int dword_10076584; // weak
extern int dword_10076588; // weak
extern int dword_10076598; // weak
extern int dword_1007659C; // weak
extern int dword_100765A0; // weak
extern int dword_100765A4; // weak
extern int dword_100765B0; // weak
extern int dword_100765C0; // weak
extern int dword_100765C4; // weak
extern int dword_100765C8; // weak
extern int dword_100765CC; // weak
extern int dword_100765D0; // weak
extern __int64 qword_100765D8; // weak
extern int dword_100765E0; // weak
extern int dword_100765E4; // weak
extern int dword_100765F4; // weak
extern int dword_100765F8; // weak
extern int dword_100765FC; // weak
extern int dword_10076600; // weak
extern int dword_10076604; // weak
extern int dword_10076608; // weak
extern int dword_1007660C; // weak
extern int dword_10076610; // weak
extern int dword_10076620; // weak
extern int dword_10076624; // weak
extern int dword_10076628; // weak
extern int dword_1007662C; // weak
extern int dword_10076630; // weak
extern int dword_10076634; // weak
extern int dword_10076638; // weak
extern int dword_1007663C; // weak
extern int dword_10076640; // weak
extern int dword_10076644; // weak
extern int dword_10076648; // weak
extern int dword_1007664C; // weak
extern int dword_10076650; // weak
extern int dword_10076658; // weak
extern _UNKNOWN unk_10076750; // weak
extern int dword_10076760; // weak
extern int dword_10076768; // weak
extern int dword_1007676C; // weak
extern int dword_10076770; // weak
extern _UNKNOWN unk_10076774; // weak
extern int dword_1007678C; // weak
extern int dword_10076790; // weak
extern int dword_10076794; // weak
extern _UNKNOWN unk_1007679C; // weak
extern int dword_100767B4; // weak
extern int dword_100767B8; // weak
extern _UNKNOWN unk_100767BC; // weak
extern int dword_100767D4; // weak
extern int dword_100767D8; // weak
extern __int64 qword_100767E0; // weak
extern int dword_100767E8; // weak
extern int dword_100767EC; // weak
extern __int64 qword_100767F0; // weak
extern int dword_100767F8; // weak
extern int dword_100767FC; // weak
extern __int64 qword_10076800; // weak
extern int dword_10076808; // weak
extern int dword_1007680C; // weak
extern __int64 qword_10076810; // weak
extern int dword_10076818; // weak
extern int dword_1007681C; // weak
extern __int64 qword_10076820; // weak
extern int dword_10076828; // weak
extern int dword_1007682C; // weak
extern _UNKNOWN unk_10076830; // weak
extern int dword_10076838; // weak
extern _UNKNOWN unk_10076844; // weak
extern int dword_1007685C; // weak
extern int dword_10076860; // weak
extern HINTERNET hInternet; // idb
extern WINHTTP_CURRENT_USER_IE_PROXY_CONFIG pProxyConfig; // idb
extern int dword_10076884; // weak
extern int dword_10076888; // weak
extern int dword_1007688C; // weak
extern PVOID dword_10076890; // idb
extern int dword_10076894; // weak
extern int dword_10076898; // weak
extern LPVOID dword_1007689C; // idb
extern int dword_100768A0; // weak
extern int dword_100778C0; // weak
extern int (__thiscall *dword_100778C4)(_DWORD, _DWORD, _DWORD, _DWORD); // weak
extern PVOID dword_100778C8; // idb
extern PVOID Ptr; // idb
extern int dword_100778D0; // weak
extern int dword_100778D4; // weak
extern int dword_100778E0; // weak
extern int dword_100778E4; // weak
extern int dword_100778E8; // weak
extern int dword_100778EC; // weak
extern int dword_100778F0; // weak
extern int dword_100778F4; // weak
extern int dword_100778F8; // weak
extern int dword_100778FC; // weak
extern int dword_10077900; // weak
extern int dword_10077904; // weak
extern int dword_10077908; // weak
extern int dword_1007790C; // weak
extern int dword_10077910; // weak
extern int dword_10077914; // weak
extern int dword_10077918; // weak
extern int dword_1007791C; // weak
extern int dword_10077920; // weak
extern int dword_10077924; // weak
extern int dword_10077928; // weak
extern int dword_1007792C; // weak
extern int dword_10077930; // weak
extern int dword_10077934; // weak
extern int dword_10077938; // weak
extern int dword_1007793C; // weak
extern int dword_10077940; // weak
extern int dword_10077944; // weak
extern int dword_10077948; // weak
extern int dword_1007794C; // weak
extern int dword_10077950; // weak
extern int dword_10077954; // weak

//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

// char __userpurge S2_SetIndicators<al>(int a1<ebx>, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, int a10, int a11, __int64 a12, unsigned int a13);
// bool __userpurge S2_OpenLong<eax>(int a1<ebx>, unsigned int a2, unsigned int a3);
// bool __userpurge S2_OpenShort<eax>(int a1<ebx>, unsigned int a2, unsigned int a3);
// signed int __userpurge S2_CloseLong<eax>(int a1<ebx>, unsigned int a2, __int64 a3);
// signed int __userpurge S2_CloseShort<eax>(int a1<ebx>, unsigned int a2, __int64 a3);
// char __userpurge S3_SetIndicators<al>(int a1<ebx>, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
// char __userpurge S3_OpenLong<al>(int a1<ebx>, unsigned int a2);
// char __userpurge S3_OpenShort<al>(int a1<ebx>, unsigned int a2);
int __thiscall sub_100016C0(int this, int a2);
char __cdecl sub_10001750(int a1, int a2);
bool __fastcall sub_10001780(int a1, int a2);
int __thiscall sub_100017B0(void *this, int a2);
int __thiscall sub_10001810(int this, int a2);
int __thiscall sub_10001880(int this);
int __thiscall nullsub_3(_DWORD); // weak
_DWORD __stdcall nullsub_1(_DWORD); // weak
void *__thiscall sub_100018D0(void *this);
int __thiscall sub_100018E0(int this, int a2);
// void *__userpurge sub_10001910<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __thiscall sub_10001940(_DWORD); // weak
// int __userpurge sub_10001950<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int *a4);
int __thiscall sub_10001B00(int this);
int loc_10001BA0(); // weak
// int __userpurge sub_10001BD0<eax>(int a1<ecx>, int a2<edi>, void *a3, int a4, int a5, int a6, int a7, unsigned int a8, __int64 a9, __int64 a10);
// signed int __usercall sub_10001EA0<eax>(int a1<ecx>, int a2<ebx>);
char __thiscall sub_10001FA0(int this, void *a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, __int64 a8, __int64 a9);
char __thiscall sub_10002040(int this, int a2, __int64 a3);
int __thiscall sub_100020F0(int this, int a2);
int __thiscall sub_10002130(int this, int a2);
int __thiscall sub_100023C0(int this, char a2, int a3);
// int (*__usercall sub_10002953<eax>(int a1<ebp>))();
int loc_10002965(); // weak
// int (*__usercall sub_1000297B<eax>(int a1<ebp>))();
int loc_1000298D(); // weak
int loc_100029B0(); // weak
int __thiscall sub_100029F0(void *this);
int __thiscall sub_10002A30(int this, unsigned int a2);
int __thiscall sub_10002B40(int this, char a2, int a3);
int __thiscall sub_10002C30(int this, unsigned __int8 *a2, int a3, unsigned int a4);
int __thiscall sub_10002D20(int this);
int __thiscall sub_10002D80(int this);
// char __userpurge sub_10002F80<al>(int a1<ecx>, int a2<ebx>, char a3, int a4, int a5, int a6);
char __thiscall sub_10003180(void *this, char a2, int a3);
// int __usercall sub_10003230<eax>(int a1<ecx>, int a2<ebx>);
char __thiscall sub_100032D0(void *this, char a2, char a3, int a4, int a5);
int __fastcall sub_10003420(int a1, int a2, int a3);
// void *__userpurge sub_10003450<eax>(int a1<ecx>, int a2<ebx>, char a3);
void *__thiscall sub_10003480(void *this, int a2);
int __thiscall sub_10003490(int this, int a2);
int __thiscall sub_100034E0(void *this);
// int __userpurge sub_10003520<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, char a4, int a5, int a6, int a7);
int __stdcall sub_100035D0(int a1);
int __thiscall sub_100035E0(int this, int a2);
char __fastcall sub_100036A0(int a1, int a2);
_DWORD __cdecl sub_100036F0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char); // weak
int __thiscall sub_100037D0(void *this, int a2, int a3);
// int __userpurge sub_10003960<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5);
// int __userpurge sub_100039A0<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_100039D0(int this, int a2, int a3, int a4);
char __thiscall sub_10003A60(void *this);
int __thiscall sub_10003B90(int this, unsigned int a2);
// void *__usercall sub_10003C50<eax>(void *a1<ecx>, int a2<ebx>, char a3);
int __fastcall sub_10003CB0(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8);
// int __usercall sub_10003D00<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, unsigned int a4, void *a5, int a6, int a7, int a8, int a9, signed int a10, char a11);
int __thiscall sub_10003E70(int this, unsigned int a2, int a3);
// int __userpurge sub_10004130<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9);
char __thiscall sub_10004210(void *this, char a2, int a3, int a4);
int __fastcall sub_10004310(int a1, int a2);
int __fastcall sub_10004350(int a1, int a2);
int __thiscall sub_100043A0(void *this, int a2, int a3, int a4);
int __thiscall sub_10004460(int this, int a2, int a3, unsigned int a4);
int __thiscall sub_100045A0(void *this, int a2);
int __thiscall sub_10004650(void *this, int a2, int a3, int a4);
// int __usercall sub_10004750<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, char a4);
// int __userpurge sub_100047D0<eax>(int a1<ecx>, int a2<edi>, int a3);
void __thiscall sub_10004910(int this, LPCWSTR pwszObjectName);
void __thiscall sub_10004A70(DWORD_PTR this);
int __thiscall sub_10004A90(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10004B00(int this);
int __thiscall sub_10004B80(int this, int a2);
int __thiscall sub_10004BA0(int this);
// void *__userpurge sub_10004C30<eax>(int a1<ecx>, int a2<ebx>, char a3);
// int __userpurge sub_10004CA0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
// int __userpurge sub_10004CD0<eax>(int a1<ecx>, int a2<ebx>, char a3);
// int __usercall sub_10004D30<eax>(int a1<ecx>, int _EBX<ebx>);
int __thiscall sub_10004DE0(int this, int a2);
// int __userpurge sub_10004E50<eax>(int a1<ecx>, int _EBX<ebx>, char a3);
int __thiscall sub_10004EF0(int this, int a2, int a3, int a4, int a5);
// int __userpurge sub_100050F0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5);
int __fastcall sub_10005130(int a1, int a2, signed int a3, int a4);
int __fastcall sub_10005280(int a1, int a2, int a3, int a4, int a5, int a6, int (__cdecl *a7)(_DWORD, _DWORD));
int __fastcall sub_10005410(int a1, int a2, int a3);
int __stdcall sub_10005450(int a1);
int __fastcall sub_10005480(int a1, int a2, int a3);
void __fastcall sub_100054F0(int a1, int a2);
int __thiscall sub_10005540(int this, int a2, char a3, int a4);
int __thiscall sub_10005660(int this, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9);
// int __userpurge sub_10005880<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5);
void __cdecl sub_100058C0(int a2);
// int __usercall sub_100058D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
int __thiscall sub_10005980(int this, int a2);
void __thiscall sub_10005A40(int this);
int __thiscall sub_10005B40(int this);
// int __userpurge sub_10005BF0<eax>(int a1<eax>, int a2<ecx>, int _EBX<ebx>, int a4);
// int __usercall sub_10005DA0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
// void __userpurge sub_10005DE0(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
int __thiscall sub_10005FD0(int this, char a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10006050(int this);
char __thiscall sub_10006090(int this, char a2, int a3);
int loc_10006120(); // weak
int loc_10006150(); // weak
void *__thiscall sub_10006160(void *this, char a2);
// int __userpurge sub_10006190<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9);
int __fastcall sub_10006270(int a1, int a2, unsigned int a3, int (__cdecl *a4)(_DWORD, _DWORD));
int __fastcall sub_10006900(int a1, int a2, int (__cdecl *a3)(_DWORD, _DWORD));
char __cdecl sub_10006970(int a1, int a2);
// int __userpurge sub_100069B0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9);
// int __usercall sub_10006A90<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
// int __usercall sub_10006B10<eax>(int a1<edx>, int a2<ecx>, int a3<edi>);
// int __userpurge sub_10006BC0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4);
int __thiscall sub_10006C80(int this, char a2, int a3);
int __thiscall sub_10006D10(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10006DC0(int this);
int (__stdcall ***__cdecl sub_10006DD0())(char);
int __thiscall sub_10006DE0(void *this);
int __thiscall sub_10006DF0(void *this, char a2);
int __thiscall sub_10006E20(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10006E90(int this);
int __thiscall sub_10006EA0(int this);
void *__thiscall sub_10006EB0(void *this, char a2);
// void __userpurge sub_10006EE0(int *a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_10006FA0(int this, int a2);
int __fastcall sub_10007110(int a1, int a2, int a3, int (__cdecl *a4)(_DWORD, _DWORD));
int __fastcall sub_100072E0(int a1, int a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __fastcall sub_10007420(int a1, int a2, int a3);
int __thiscall sub_10007630(int this, int *a2);
int __thiscall sub_100076D0(int this, int a2, int a3);
void __cdecl sub_10007740(int a1);
// int __usercall sub_10007750<eax>(int a1<eax>, int a2);
int __cdecl loc_10007760(int); // weak
int __thiscall sub_10007940(int this, int a2, int a3);
int __thiscall sub_100079F0(int this);
int loc_10007AD0(); // weak
// int __userpurge sub_10007B20<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
// int __userpurge sub_10007B50<eax>(int a1<ecx>, int a2<ebx>, char a3);
// int __userpurge sub_10007BB0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
// int __userpurge sub_10007D20<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
int __fastcall sub_10007E90(int a1, int a2, int a3);
int __fastcall sub_10007F60(int a1, int a2, int a3);
int *__fastcall sub_10008190(int a1, int a2);
int __fastcall sub_10008260(int a1, int a2, int a3, int a4, int (__cdecl *a5)(_DWORD, _DWORD));
int __fastcall sub_10008350(int a1, int a2, int a3);
// void __usercall sub_100083A0(int a1<ecx>, int a2<ebx>, int a3);
// int __usercall sub_100083B0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
// int __userpurge sub_10008470<eax>(int a1<edx>, int *a2<ecx>, int a3<ebx>, int a4, int a5);
// void __usercall sub_10008530(int a1<ecx>, int a2<ebx>);
// int __userpurge sub_10008620<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __fastcall sub_100086C0(int a1, int a2, int a3, int a4, int (__cdecl *a5)(_DWORD, _DWORD));
int __fastcall sub_10008790(int a1, int a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __fastcall sub_10008860(int a1, int a2, int a3);
// int __userpurge sub_100088D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8);
int __thiscall sub_10008940(void *this, int a2);
int (__stdcall ***__cdecl sub_10008990())(char);
// int __userpurge sub_100089A0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
// int __userpurge sub_10008A40<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9);
// int __userpurge sub_10008B20<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4);
char __thiscall sub_10008BC0(void *this, int a2);
int (__stdcall ***__cdecl sub_10008BD0())(char);
int __thiscall sub_10008BE0(void *this);
int __thiscall sub_10008BF0(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10008C60(int this);
void *__thiscall sub_10008D00(int this, char a2);
// int __userpurge sub_10008D70<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
char __thiscall sub_10008DA0(void *this, int a2);
// int __usercall sub_10008E60<eax>(int a1<eax>, int a2);
// void __userpurge sub_10008F70(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
// int __userpurge sub_100091B0<eax>(int a1<ecx>, int a2<ebx>, int a3);
int (__stdcall ***__cdecl sub_10009200())(char);
void *__thiscall sub_10009210(int this, char a2);
int __thiscall sub_10009270(int this, char a2);
// int __usercall sub_10009300<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4);
void *__thiscall sub_100093C0(void *this, int a2);
void __thiscall sub_10009430(void *this, int a2);
int __thiscall sub_100095F0(int this);
void *__thiscall sub_10009600(void *this, int a2);
// int __usercall sub_100096D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
// int __usercall sub_10009780<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
char __cdecl sub_100097C0(int a1);
int __cdecl sub_100097E0(int a1);
int __thiscall sub_10009800(int this, int a2);
int __thiscall sub_100098C0(void *this, int a2);
// int __userpurge sub_10009980<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_100099A0(void *this);
void *__thiscall sub_100099D0(void *this);
int __fastcall sub_100099E0(int a1, int a2, unsigned int a3);
// int __userpurge sub_10009A40<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10009A60<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10009B30<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, unsigned int a4);
// int (__cdecl *__usercall sub_10009B60<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<ebx>, int a5<edi>, int a6<esi>, int a7, int a8))(int, int);
int __cdecl loc_10009C1E(int, int); // weak
int loc_10009DE0(); // weak
// int __userpurge sub_10009E10<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __usercall sub_10009E30<eax>(const void *a1<ecx>, int a2<edi>, char a3);
// int __usercall sub_10009E90<eax>(int a1<ecx>, int a2<edi>);
// signed int __usercall sub_10009F10<eax>(int a1<ecx>, int a2<ebx>);
void *__thiscall sub_1000A010(void *this, int a2);
int __thiscall sub_1000A090(int this, char a2);
void *__thiscall sub_1000A140(void *this, int a2);
int __fastcall sub_1000A250(int a1, int a2);
// int __usercall sub_1000A320<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
// int __usercall sub_1000A380<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
int loc_1000A390(); // weak
int __stdcall sub_1000A3A0(int a1);
// char __userpurge sub_1000A3B0<al>(int a1<ecx>, int a2<edi>, int a3);
int __cdecl sub_1000A460(int a1);
int __cdecl sub_1000A4E0(int a1);
int loc_1000A500(); // weak
int loc_1000A510(); // weak
int __thiscall sub_1000A520(int this, int a2, int a3);
// int __userpurge sub_1000A5C0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4, int a5);
int __stdcall loc_1000A61C(int, int); // weak
int (__stdcall *__cdecl sub_1000A642())(int, int);
void *__thiscall sub_1000A650(void *this, char a2);
_DWORD __cdecl sub_1000A680(_DWORD); // weak
int __thiscall sub_1000A690(int this);
int (__stdcall ***__cdecl sub_1000A7D0())(char);
char __thiscall sub_1000A7E0(void *this, char a2, char a3, int a4, int a5);
void *__thiscall sub_1000A930(int this, char a2);
int __thiscall sub_1000A960(int this);
int __thiscall sub_1000AA50(void *this);
int __thiscall sub_1000AA70(void *this);
// int (__cdecl *__usercall sub_1000ACA0<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<ebx>, int a5<edi>, int a6<esi>, int a7, unsigned int a8))(int, int);
int __cdecl loc_1000AD55(int, int); // weak
int __thiscall sub_1000AFB0(int this, const char *a2);
int __thiscall sub_1000B010(int this, __int16 a2, char a3, void *a4, int a5, int a6, int a7, int a8, unsigned int a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, int a15, int a16);
void *__thiscall sub_1000B2B0(int this, char a2);
int __thiscall sub_1000B2E0(int this);
char __thiscall sub_1000B410(int this, __int64 a2, __int64 a3, __int64 a4);
int __cdecl sub_1000B970(double a1, __int64 a2, __int64 a3);
int __thiscall sub_1000BA00(void *this, int a2, char a3, int a4, int a5);
void *__thiscall sub_1000BAA0(void *this, char a2);
int __fastcall sub_1000BAD0(int a1, char a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9, int a10);
void __thiscall sub_1000BC10(int this, int a2);
char __thiscall sub_1000BC60(int _ECX);
char __thiscall sub_1000BD30(int _ECX);
char __thiscall sub_1000BE10(int _ECX);
char __thiscall sub_1000BEA0(int this, __int64 a2);
char __thiscall sub_1000C000(int this, __int64 a2);
char __thiscall sub_1000C160(int this, __int64 a2, __int64 a3);
char __fastcall sub_1000C2A0(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8);
void *__thiscall sub_1000C3E0(void *this, int a2);
int __fastcall sub_1000C450(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8);
void *__thiscall sub_1000C4A0(void *this, char a2);
int __thiscall sub_1000C4D0(void *this, int a2, int a3);
char __thiscall sub_1000C4F0(void *this, int a2, int a3);
char __thiscall sub_1000C530(void *this, int a2, int a3);
int __cdecl sub_1000C550();
int __stdcall sub_1000C560(int a1, int a2);
int __cdecl sub_1000C5D0();
int __stdcall sub_1000C5E0(int a1, int a2);
int __cdecl sub_1000C630();
int __stdcall sub_1000C640(int a1, int a2);
int __stdcall sub_1000C6B0(int a1, int a2);
int __thiscall sub_1000C700(void *this);
void *__thiscall sub_1000C710(void *this, char a2);
int __thiscall sub_1000C740(int this, int a2);
void __thiscall sub_1000C770(int this, int a2);
void __thiscall sub_1000C870(int this, int a2);
signed int __stdcall sub_1000C8F0(int a1, int a2, int a3);
void *__thiscall sub_1000C900(void *this, char a2);
// __int16 __userpurge sub_1000C940<ax>(int a1<ecx>, int a2<edi>, __int64 a3);
char __stdcall sub_1000CA40(int a1);
// int __userpurge sub_1000CA90<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __fastcall sub_1000CAB0(int a1, const char *a2);
// void __userpurge SetBalance(int a1<ebx>, unsigned int a2, __int64 a3, const char *a4);
// char __userpurge SetMarket<al>(int a1<ebx>, unsigned int a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7);
// char __userpurge SetMaxSpread<al>(int a1<ebx>, unsigned int a2, __int64 a3);
// char __userpurge S1_SetIndicators<al>(int a1<ebx>, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10);
// char __userpurge S1_OpenLong1<al>(int a1<ebx>, unsigned int a2, __int64 a3);
// char __userpurge S1_OpenShort1<al>(int a1<ebx>, unsigned int a2, __int64 a3);
// signed int __userpurge S1_OpenLong2<eax>(int a1<ebx>, unsigned int a2, __int64 a3);
// char __userpurge S1_OpenShort2<al>(int a1<ebx>, unsigned int a2, __int64 a3);
// signed int __userpurge S1_OpenLong22<eax>(int a1<ebx>, unsigned int a2, signed int a3, __int64 a4, __int64 a5);
// signed int __userpurge S1_OpenShort22<eax>(int a1<ebx>, unsigned int a2, signed int a3, __int64 a4, __int64 a5);
// char __userpurge S1_CloseLong<al>(int a1<ebx>, unsigned int a2, __int64 a3, __int64 a4, unsigned int a5);
// char __userpurge S1_CloseShort<al>(int a1<ebx>, unsigned int a2, __int64 a3, __int64 a4, unsigned int a5);
// char __userpurge S1_CloseDa<al>(int a1<ebx>, unsigned int a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
bool __stdcall CheckVersion(const char *a1);
void __stdcall Initialize(const char *a1, const char *a2, int a3, int a4, const char *a5);
int __cdecl Status();
int __cdecl ErrorCode();
int __cdecl Utc();
// int __userpurge Msg<eax>(int a1<ebx>, int a2, unsigned int a3, int a4);
// signed int __userpurge GetMsg<eax>(int a1<ebx>, int a2, unsigned int a3, int a4, int a5, int a6);
int __fastcall StartExpert(int a1, int a2, int a3, int a4, const char *a5, __int64 a6, unsigned int a7);
char __stdcall StopExpert(unsigned int a1);
int __fastcall sub_1000DBA0(int a1, unsigned int a2);
char __fastcall sub_1000DDD0(unsigned int a1, unsigned int a2);
// int __usercall sub_1000DDF0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
char __thiscall sub_1000DF00(int this, int a2, int a3, int a4, int a5);
char __thiscall sub_1000E050(int this);
char __thiscall sub_1000E2C0(int this, int a2);
char __thiscall sub_1000E530(int this, int a2);
char __thiscall sub_1000E800(int this);
// int __userpurge sub_1000E8B0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5, int a6);
bool __thiscall sub_1000E9A0(int this);
void __thiscall sub_1000E9F0(int this);
bool __thiscall sub_1000EA30(int this);
// char __userpurge sub_1000EA70<al>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// char __userpurge sub_1000EDD0<al>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
char __thiscall sub_1000F050(void *this, int a2);
char __thiscall sub_1000F380(void *this, int a2);
// char __userpurge sub_1000F5C0<al>(int a1<ecx>, int a2<ebx>, int a3);
char __thiscall sub_1000FA50(void *this, int a2, int *a3, int a4, int a5);
char __thiscall sub_1000FBC0(void *this, int a2, int *a3, int a4, int a5);
char __thiscall sub_1000FD10(void *this, int *a2, int a3, int a4);
char __thiscall sub_1000FDD0(int this, int a2);
char __thiscall sub_1000FE20(void *this, int *a2, int a3, int a4);
int __thiscall sub_1000FE80(int this);
int sub_1000FF60(); // weak
int loc_1000FFF0(); // weak
int __fastcall sub_10010010(int a1, int a2, int a3);
// int __usercall sub_100101D0<eax>(int a1<ecx>, int a2<ebx>);
int __fastcall sub_10010260(int a1, int a2, int a3);
char __thiscall sub_100109A0(void *_ECX);
int __thiscall sub_10010A20(void *this);
// int __userpurge sub_10010A90<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4);
// void __usercall sub_10010C30(int a1<ecx>, int a2<ebx>);
int __fastcall sub_10010C90(int a1, int a2, int a3, int a4);
int __fastcall sub_10010E40(int a1, int a2, int a3, int a4, int a5);
int __thiscall sub_10010EA0(void *this, int a2);
// int __userpurge sub_10011140<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
void *__thiscall sub_100111E0(void *this, int a2, unsigned int a3);
void *__thiscall sub_100112C0(void *this, int a2, int a3);
// int __usercall sub_10011360<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
int __fastcall sub_100114C0(int a1, char a2);
int __fastcall sub_10011530(int a1, int a2);
void __thiscall sub_10011A40(int this, int a2);
void *__thiscall sub_10011AD0(void *this, char a2);
int __thiscall sub_10011B00(void *this, int a2, int a3);
// int __userpurge sub_10011B70<eax>(int a1<ecx>, int a2<edi>, int a3);
int __stdcall sub_10011FE0(const char *a1);
int __thiscall sub_10012020(int this, int a2);
_DWORD __stdcall sub_10012050(_DWORD); // weak
int __thiscall sub_10012200(void *this, int a2, int a3);
int __thiscall sub_100124C0(void *this, int a2, int a3);
int __fastcall sub_100126C0(int a1, int a2, int a3);
// int __userpurge sub_100127A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5);
int __thiscall sub_10012870(void *this, int a2);
int __thiscall sub_10012890(int this);
signed int __thiscall sub_10012B20(int this, signed int a2);
signed int __thiscall sub_10012B80(int this);
int __thiscall sub_10012BE0(int this, int a2, __int64 a3, int a4, char a5);
int __thiscall sub_10012DB0(int this, int a2, __int64 a3, __int64 a4, int a5, int a6, char a7);
void *__thiscall sub_10012F00(void *this, char a2);
void *__thiscall sub_10012F70(int this, char a2);
// void *__userpurge sub_10013050<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6);
int __thiscall sub_100130F0(void *this, int a2, int a3, int a4);
void *__thiscall sub_100131B0(void *this, int a2);
int __thiscall sub_10013250(void *this, int a2);
int __thiscall sub_100132D0(void *this, int a2);
int __thiscall sub_10013330(void *this, int a2);
char __stdcall sub_10013390(int a1, int a2);
int __fastcall sub_100133F0(int a1);
void *__thiscall sub_10013410(void *this);
void *__thiscall sub_10013460(void *this);
int __thiscall sub_10013550(int this, int a2);
int __thiscall sub_10013580(int this, int a2);
// int __userpurge sub_100135B0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int **a5, int a6, int a7, int **a8, int a9, int a10);
int __thiscall sub_10013B80(int this, int a2);
// int __userpurge sub_10013CE0<eax>(int a1<ecx>, int a2<edi>, int a3, int a4, int a5, int a6, char a7, unsigned __int8 a8);
int __thiscall sub_10013ED0(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7);
int __thiscall sub_10013F50(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7);
int __thiscall sub_10013FE0(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7, int a8);
int __thiscall sub_10014060(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7, int a8);
// int __userpurge sub_100140E0<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6, unsigned __int8 a7, __int64 a8);
// int __userpurge sub_10014320<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6, unsigned __int8 a7, __int64 a8);
int __thiscall sub_100144D0(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7);
int __fastcall sub_10014540(int a1, int a2, int a3, int a4);
void *__thiscall sub_100145D0(void *this, char a2);
// int __usercall sub_10014830<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<ebp>, int a5<edi>);
// int __userpurge sub_10014A40<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7);
int __cdecl sub_10014AA0(int a1, int a2, char a3, __int16 a4);
int __cdecl sub_10014B60(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8, int a9, int a10, unsigned int a11);
int __cdecl sub_10014FE0(int a1, int a2, int a3, __int16 a4);
int __cdecl sub_10015070(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8);
int __cdecl sub_10015410(int a1, int a2, int a3, int a4, unsigned __int8 *a5, int a6);
int __cdecl sub_10015490(int a1, int a2, int a3, int a4, unsigned __int8 a5, int a6);
int __fastcall sub_10015510(int a1, int a2, int a3, int a4);
// int __usercall sub_100155A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
int __fastcall sub_100155D0(int a1, int a2, int a3);
int __fastcall sub_10015660(int a1, int a2, const char *a3);
int __thiscall sub_10015700(_DWORD); // weak
// int __usercall sub_100159B0<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4);
int __thiscall sub_10015AE0(void *this, int a2, int a3);
// int __usercall sub_10015B60<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int **a4, int a5, int a6, int **a7, int a8, int a9, int **a10, int a11, int a12);
// int __usercall sub_10015C80<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int **a4, int a5, int a6, int **a7, int a8, int a9, int **a10, int a11, int a12);
signed int __fastcall sub_10015DA0(int a1, int a2, int a3, int a4);
int __stdcall sub_100160E0(int a1);
// void __usercall sub_1001618B(int a1<ebp>);
int __thiscall sub_100161A0(int this, int a2, int a3, int a4, int a5);
void __thiscall sub_100163A0(int this);
int __thiscall sub_100163C0(void *this, int a2, int a3, int a4);
// int __usercall sub_10016480<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12);
// int __usercall sub_10016570<eax>(int a1<ecx>, int a2<edi>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11);
// int __userpurge sub_10016660<eax>(int a1<ebx>, int a2);
// int __userpurge sub_10016710<eax>(int a1<ecx>, int a2<ebx>, int a3, char a4, int a5, int a6, int a7);
int __thiscall sub_10016980(void *this, int a2, int a3, int a4, int a5);
int __fastcall sub_10016B40(int a1, int a2, int a3);
int __thiscall sub_10016BC4(void *this);
void *__thiscall sub_10016BCF(void *this, char a2);
int __thiscall sub_10016CF0(void *this, int a2);
int __thiscall sub_10016D10(void *this, int a2);
int __thiscall sub_10016D30(void *this, int a2);
int __thiscall sub_10016D50(int this, int a2);
int __thiscall sub_10016DD0(int this, char a2);
char __thiscall sub_10016E20(int this);
char __thiscall sub_10016E30(int this);
int __thiscall sub_10016E40(int this, int a2);
int __thiscall sub_10016EA0(int this, int a2);
int __thiscall sub_10016F00(int this, int a2);
int __thiscall sub_10016F60(int this);
// int __userpurge sub_10016F80<eax>(int a1<ecx>, int a2<edi>, int a3, char a4);
signed int __fastcall sub_100170E0(int a1, int a2, int a3, int a4);
// int __usercall sub_100171B0<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4);
int __thiscall sub_100172E0(int this, char a2);
signed int __stdcall sub_10017330(int a1);
__int64 __cdecl sub_10017340();
__int64 __thiscall sub_10017350(int this);
signed int __cdecl sub_10017370();
int __thiscall sub_10017380(void *this);
int __thiscall sub_100173B0(int this, void *a2, unsigned int a3, int a4);
__int64 __thiscall sub_100174C0(int this);
int __thiscall sub_100174E0(int this, const void *a2, unsigned int a3, int a4);
int __stdcall sub_100175F0(int a1, int a2, int a3, int a4, int a5);
int __stdcall sub_10017620(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
void *__thiscall sub_10017650(void *this, int a2, int a3, int a4);
void *__thiscall sub_100176B0(void *this, char a2);
void *__thiscall sub_100176F9(void *this, char a2);
int __thiscall sub_10017701(void *this);
// int __usercall sub_10017710<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<ebp>, int a5<edi>);
// int __userpurge sub_100177A0<eax>(int a1<ecx>, int a2<ebx>, char a3);
int *__thiscall sub_10017800(void *this, int *a2, int a3);
// int __userpurge sub_10017830<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned __int8 a4);
int *__thiscall sub_10017850(void *this, int *a2, int a3);
// int __userpurge sub_10017880<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned __int8 a4);
int __stdcall sub_100178A0(const void *a1, int a2, void *a3);
int __stdcall sub_100178C0(const void *a1, int a2, int a3, void *a4);
char __stdcall sub_100178E0(char a1, int a2);
// int __userpurge sub_100178F0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
int loc_100179C0(); // weak
// void __usercall sub_100179E0(void *this<ecx>, int a2<ebx>);
signed int __fastcall sub_10017A80(int a1, int a2, int a3, int a4);
// int __usercall sub_10017B50<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4);
char __stdcall sub_10017C80(char a1);
// int __userpurge sub_10017C90<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6);
void __thiscall sub_10017D50(void *this);
int __thiscall sub_10017D70(int this, int a2);
int loc_10017D90(); // weak
int __thiscall sub_10017DB0(void *this);
int loc_10017E2C(); // weak
int (*__cdecl sub_10017E3E())();
int loc_10017E50(); // weak
int __cdecl sub_10017E80();
int __thiscall sub_10017E90(void *this, const char *a2, int a3);
// int __userpurge sub_10017F60<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10017F90<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_10018060(int this);
void *__thiscall sub_10018150(void *this, int a2);
char __thiscall sub_100181E0(int this, int a2, signed int a3, unsigned __int8 a4);
void *__thiscall sub_100182F0(void *this, char a2);
int __thiscall sub_10018340(void *this);
void *__thiscall sub_10018350(void *this);
int __stdcall sub_10018370(int a1, int a2);
int loc_100183B0(); // weak
int __fastcall sub_100183F0(int a1, int a2);
void *__thiscall sub_10018420(int this, char a2);
int __fastcall sub_10018470(int a1);
void *__thiscall sub_100184D0(int this, char a2);
int __thiscall sub_10018500(int this, int a2);
int loc_10018540(); // weak
char __thiscall sub_10018590(void *this, int a2);
int loc_10018B70(); // weak
void __thiscall sub_10018BD0(void *this, __int64 a2, int a3);
void __thiscall sub_10018DA0(void *this, int a2, int a3, int a4);
void __thiscall sub_10018E10(int this, unsigned int a2);
int __thiscall sub_10018EE0(int this);
int __thiscall sub_10018F50(int this, int a2, int a3, int a4, int a5);
int __thiscall sub_10019030(int this, int a2, int a3);
int __thiscall sub_100190D0(int this, int a2);
int __thiscall sub_10019200(int this, int a2);
int __thiscall sub_10019310(int this);
int __thiscall sub_10019410(int this, int a2);
// int __userpurge sub_10019500<eax>(int a1<ecx>, int a2<edi>, int a3, int a4);
char __fastcall sub_100195A0(int a1, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10019740(int this);
void __thiscall sub_10019810(int this, int a2);
int loc_100198B0(); // weak
int loc_10019910(); // weak
LPVOID __thiscall sub_10019980(LPVOID *this);
signed int __thiscall sub_100199B0(void *this, int a2);
int __thiscall sub_10019A90(int this, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __thiscall sub_10019BE0(int this, unsigned int a2);
int __thiscall sub_10019D80(void *this, int a2, int a3);
// void *__userpurge sub_10019E30<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6);
int __thiscall sub_10019F10(int this, int a2, int a3, int a4, int a5);
char __thiscall sub_1001A270(int this, int a2, int a3);
void *__thiscall sub_1001A420(void *this, int a2);
// char __userpurge sub_1001A460<al>(int a1<ecx>, int a2<ebx>, int a3<edi>, __int16 a4);
// bool __userpurge sub_1001A530<eax>(int a1<ecx>, char a2<bl>, unsigned __int8 a3, int a4);
void __thiscall sub_1001A620(int this, int a2, int a3);
int __thiscall sub_1001A6E0(void *this, int a2, unsigned int a3);
void *__thiscall sub_1001A740(void *this, int a2);
int __thiscall sub_1001A830(int this, unsigned int a2);
int __thiscall sub_1001A8D0(int this);
void *__thiscall sub_1001A970(int this, char a2);
// int __usercall sub_1001A9A0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
int __thiscall sub_1001AA20(int this, int a2);
int __thiscall sub_1001AA80(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_1001ABB0(void *this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_1001ACB0(int this, int a2);
int __thiscall sub_1001ADC0(int this, unsigned int a2);
int __thiscall sub_1001AEF0(void *this, int a2, int a3, int a4);
// bool __userpurge sub_1001AF20<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6);
int __thiscall sub_1001AF60(void *this, int a2, const CHAR *a3, UINT a4);
int __stdcall sub_1001B070(int a1, int a2);
int __thiscall sub_1001B0B0(int this, int a2, int a3);
// void *__userpurge sub_1001B110<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __thiscall sub_1001B150(int this, int a2);
int __thiscall sub_1001B170(int this, int a2, int a3, int a4);
int __thiscall sub_1001B330(int this, int a2, int a3, int a4);
int __thiscall sub_1001B450(int this, unsigned int a2, int a3);
int __thiscall sub_1001B4D0(void *this, int a2, void *a3, const void *a4);
int __thiscall sub_1001B770(int this, int a2);
// int __userpurge sub_1001B7B0<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6);
int __thiscall sub_1001B890(_DWORD); // weak
int __fastcall sub_1001BE80(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, char a8);
int __fastcall sub_1001BF10(int a1, int a2, int a3, int a4);
char __fastcall sub_1001BFA0(unsigned __int8 a1, int a2, void *a3);
int __fastcall sub_1001C250(int a1, int a2, int a3);
void *__thiscall sub_1001C280(void *this, int a2, int a3);
void __fastcall sub_1001C2C0(int _ECX, int a2);
int __fastcall sub_1001C2E0(int a1, int a2, int a3);
// int __usercall sub_1001C310<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4);
signed int __fastcall sub_1001C440(int a1, int a2, int a3, void *a4);
int __thiscall sub_1001C530(int this, int a2);
char __thiscall sub_1001C5A0(void *this);
int __thiscall sub_1001C750(int this);
// int __userpurge sub_1001C870<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6);
int __fastcall sub_1001C8F0(int a1, int a2, int a3);
// int __userpurge sub_1001C990<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// int __usercall sub_1001CA00<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
char __thiscall sub_1001CA70(void *this, int a2);
char __thiscall sub_1001CC80(void *this, int a2, char a3, signed int a4);
char __thiscall sub_1001CEF0(int this, int a2);
char __thiscall sub_1001D0F0(int this);
// int __usercall sub_1001D220<eax>(char a1<dl>, int a2<ecx>, __int16 a3<bx>, int a4, int a5, int a6, int a7, __int16 a8, char a9);
int __fastcall sub_1001D2B0(int a1, int a2, int a3, int a4, int a5, int a6, char a7);
int __fastcall sub_1001D4B0(int a1, int a2, int a3, int *a4, int a5, char a6, char a7);
int __fastcall sub_1001D560(int a1, int a2, int a3, int a4, int a5, int a6, char a7);
int __thiscall sub_1001D600(void *this, int a2, int a3, int a4);
int __fastcall sub_1001D7A0(int a1, int a2, int a3);
void __fastcall sub_1001D7D0(int a1, int a2);
// signed int __usercall sub_1001D7F0<eax>(signed int result<eax>, int a2<ecx>, int a3, unsigned int a4, int a5, int a6);
void __fastcall sub_1001D840(int a1, int a2);
int __thiscall sub_1001D860(int this, int a2);
// char __userpurge sub_1001D8D0<al>(int a1<ecx>, char a2<bl>, int a3, int a4);
char __thiscall sub_1001D9C0(int this);
char __thiscall sub_1001DA00(void *this);
char __thiscall sub_1001DE90(int this);
// int __usercall sub_1001DED0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __userpurge sub_1001DF40<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
int __fastcall sub_1001E000(int a1, int a2, int a3, int a4);
char __thiscall sub_1001E0A0(void *this, int a2, char a3);
// int __usercall sub_1001E340<eax>(char a1<dl>, int a2<ecx>, __int16 a3<bx>, int a4, int a5, int a6, int a7, int a8);
int __fastcall sub_1001E540(int a1, char a2, int a3, int *a4, int a5, int a6, char a7);
int __fastcall sub_1001E5F0(int a1, char a2, int a3, int a4, int a5, int a6);
void *__thiscall sub_1001E690(void *this, int a2, int a3, unsigned int a4, int a5, int a6, int a7, unsigned int a8);
void *__thiscall sub_1001E710(void *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
// int __usercall sub_1001E800<eax>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>);
// int __usercall sub_1001EB70<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_1001EBD0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_1001EC30<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __userpurge sub_1001EC90<eax>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>, int a5);
int __thiscall sub_1001EDA0(int this, int a2, int a3);
void *__thiscall sub_1001EE10(void *this, int a2, int a3);
char __thiscall sub_1001EE40(int this);
// char __userpurge sub_1001EE60<al>(int a1<ecx>, char a2<bl>, char a3);
// signed int __usercall sub_1001F1E0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>);
// int __userpurge sub_1001F270<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, char a4);
// int __usercall sub_1001F2A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __userpurge sub_1001F330<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// int __userpurge sub_1001F3A0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5, char a6);
// int __usercall sub_1001F4E0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
void *__thiscall sub_1001F560(void *this, int a2, int a3);
// void *__userpurge sub_1001F590<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __thiscall sub_1001F5C0(int this, int a2, int a3);
int __thiscall sub_1001F6A0(int this);
char __thiscall sub_1001F930(int this, char a2);
int __thiscall sub_1001F9B0(void *this, int a2, int a3, char a4);
// int __userpurge sub_1001FA70<eax>(int a1<edx>, int a2<ecx>, __int16 a3<bx>, int a4, int a5);
// int __userpurge sub_1001FCD0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, char a4);
// char __userpurge sub_1001FDE0<al>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>, int a5);
// int __userpurge sub_1001FED0<eax>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>, int a5);
int __thiscall sub_1001FFE0(int this, int a2, int a3, int a4, int a5);
char __stdcall sub_10020320(int a1, int a2, int a3);
char __thiscall sub_100203A0(int this, int a2, int a3, int a4);
int __fastcall sub_10020540(int a1, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_100205B0(void *this, int a2, int a3, int a4);
void *__thiscall sub_10020740(void *this, int a2, int a3);
int __fastcall sub_10020770(int a1, int a2, int a3);
int __thiscall sub_100208A0(void *this, int a2, int a3);
int __thiscall sub_10020A40(void *this, int a2);
int __thiscall sub_10020BA0(void *this, int a2, char a3, int a4, int a5);
int __fastcall sub_10020C70(int a1, char a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9, int a10);
int __thiscall sub_10020D90(int _ECX, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6, int a7, __int64 a8, int a9, int a10);
char __fastcall sub_10020ED0(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8);
void *__thiscall sub_10021010(void *this, void *a2);
int __fastcall sub_10021080(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8);
int __thiscall sub_100210D0(void *this, int a2, char a3, int a4, int a5);
int __fastcall sub_10021170(int a1, char a2, char a3, void *a4, int a5, int a6, int a7, int a8, unsigned int a9, int a10, int a11);
char __thiscall sub_100212A0(int _ECX);
char __thiscall sub_10021330(int _ECX);
char __fastcall sub_100213C0(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8);
// int *__usercall sub_10021500<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_100217D0<eax>(int a1<ebx>);
void __stdcall sub_10021A90(int a1, int a2, void *a3, int a4, int a5, int a6, unsigned int a7, signed int a8, void *a9, int a10, int a11, int a12, int a13, signed int a14, void *a15, int a16, int a17, int a18, unsigned int a19, unsigned int a20);
void __thiscall sub_10021CA0(void *this, void *a2, int a3, int a4, int a5, int a6, unsigned int a7);
// int __userpurge sub_10021D60<eax>(int a1<ebx>, char a2);
// int __userpurge sub_10021E10<eax>(int a1<ebx>, unsigned int a2);
int __stdcall sub_10021EA0(int a1);
// void __userpurge sub_10021F90(int a1<ecx>, int a2<ebx>, int a3);
// BOOL __userpurge sub_100220F0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
void __thiscall sub_100221F0(int this, int a2);
int __thiscall sub_10022280(void *this, int a2);
int __thiscall sub_10022720(void *this, char a2, int a3);
int __stdcall loc_10022A17(char, int); // weak
// int (*__usercall sub_10022A7D<eax>(int a1<ebp>))();
int loc_10022B00(); // weak
// int (__stdcall *__usercall sub_10022B17<eax>(int a1<ebp>))(char, int);
// int __userpurge sub_10022BA0<eax>(int a1<ecx>, int a2<edi>, int a3, void *a4, int a5, int a6, int a7, int a8, unsigned int a9, __int64 a10, __int64 a11);
int __thiscall sub_10022F30(int this, int *a2);
int __thiscall sub_10022FB0(_DWORD); // weak
int __thiscall sub_10022FC0(int this, unsigned int a2);
int __thiscall sub_100230B0(_DWORD); // weak
// int __usercall sub_100230C0<eax>(int a1<ecx>, int a2<ebx>);
signed int __thiscall sub_10023170(void *this, int a2, int a3);
signed int __thiscall sub_100231B0(void *this, int a2, int a3);
char __cdecl sub_100231F0();
int __thiscall sub_10023230(int this);
int __stdcall sub_100232E0(int a1);
char __thiscall sub_10023300(int this, int a2);
char __thiscall sub_10023320(void *this, int a2);
int __thiscall sub_10023350(int this);
int __thiscall sub_10023370(void *this, int a2);
int __thiscall sub_100233A0(int this, int a2);
int __thiscall sub_100233D0(int this, unsigned int a2);
unsigned int __thiscall sub_100233F0(int this, int a2);
int loc_10023420(); // weak
// int __usercall sub_10023430<eax>(int a1<ecx>, int a2<ebx>);
signed int __stdcall sub_100236B0(int a1, int a2);
int __thiscall sub_100236C0(void *this, int a2);
// char __userpurge sub_10023770<al>(int a1<ecx>, int a2<ebx>, int a3);
void __thiscall sub_100237A0(void *this);
int loc_100238B0(); // weak
char __cdecl sub_100238C0();
// void __usercall sub_100238D0(void *a1<ecx>, int a2<ebx>);
void __thiscall sub_10023A00(int this, int a2, int a3);
void __thiscall sub_10023BE0(void *this);
int __fastcall sub_10023CA0(int a1);
int __stdcall sub_10023CE0(int a1, int a2, int a3);
int __stdcall sub_10023D00(int a1, int a2, int a3);
int __stdcall sub_10023D60(void *a1);
int loc_10023D80(); // weak
// void __usercall sub_10023D90(int a1<ecx>, int a2<ebx>, int a3<edi>);
int __thiscall sub_10023E50(int this, int a2);
char __thiscall sub_10023E80(int this, int a2);
int __thiscall sub_10023EB0(void *this);
int __thiscall sub_10023F10(int this, int a2);
// unsigned int __userpurge sub_10023F40<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_10024000(int this);
char __thiscall sub_10024090(int this, int a2);
char __thiscall sub_100240C0(int this, int a2);
bool __thiscall sub_100240E0(int this);
int __thiscall sub_100240F0(int this, int a2);
int __thiscall sub_10024110(int this, int a2);
// void __usercall sub_10024130(int a1<ecx>, int a2<ebx>, int a3<edi>);
void __thiscall sub_100241E0(void *this, int a2);
void __thiscall sub_100242A0(void *this, int a2);
void __thiscall sub_10024360(void *this);
char __thiscall sub_10024490(void *this, int a2, int a3);
void __thiscall sub_10024570(void *this, int a2, int a3);
int __thiscall sub_10024720(void *this, int a2);
int __thiscall sub_10024740(void *this, int a2);
int __thiscall sub_100247D0(void *this, int a2);
int __thiscall sub_100247E0(void *this, int a2);
int __thiscall sub_10024860(int this);
int __thiscall sub_10024870(int this);
int __thiscall sub_100248A0(int this, int a2);
// void *__userpurge sub_100248C0<eax>(int a1<ecx>, int a2<ebx>, char a3);
void *__thiscall sub_100248F0(int this, char a2);
void *__thiscall sub_10024920(void *this, char a2);
// void *__userpurge sub_10024950<eax>(int a1<ecx>, int a2<ebx>, char a3);
void *__thiscall sub_10024980(void *this, char a2);
// void *__userpurge sub_100249B0<eax>(void *a1<ecx>, int a2<ebx>, char a3);
// void *__userpurge sub_100249E0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
// void *__userpurge sub_10024A60<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
int __thiscall sub_10024B00(int this);
int __thiscall sub_10024BC0(int this);
char __thiscall sub_10024CD0(int this, int a2);
int loc_10024D30(); // weak
// int __usercall sub_10024D60<eax>(int a1<ecx>, int a2<ebx>);
int __thiscall sub_10024E30(int this, int a2, int a3);
int __thiscall sub_10024ED0(int this);
int __thiscall sub_10024F90(void *this);
char __thiscall sub_10025010(int this, int a2);
int __thiscall sub_100250F0(int this, int a2);
char __thiscall sub_10025170(void *this);
void __thiscall sub_100251D0(void *this, int a2);
int __cdecl sub_100253C0(int a1);
// int __usercall sub_100253D0<eax>(int a1<ecx>, int a2<ebx>);
int __thiscall sub_10025470(int this, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_10025510<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
int __thiscall sub_100255C0(int this);
// int __userpurge sub_10025640<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
int __thiscall sub_10025670(int this, char a2);
int __fastcall sub_100257B0(int a1, int a2, unsigned int a3);
void __thiscall sub_10025860(int this);
int __fastcall sub_10025950(int a1, int a2);
int __thiscall sub_100259F0(int this, int a2, int a3, int a4);
int __thiscall sub_10025B70(int this, int a2, int a3);
char __thiscall sub_10025C00(int this, int a2);
// int __userpurge sub_10025D20<eax>(int a1<ecx>, int a2<edi>, int a3);
void __thiscall sub_10025D80(int this, int a2);
// void *__userpurge sub_10025ED0<eax>(int a1<ecx>, int a2<ebx>, char a3);
// void __usercall sub_10025F00(int a1<ecx>, int a2<ebx>);
int __fastcall sub_10025F80(int a1, int a2, int a3, int a4);
// int __userpurge sub_10025FC0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5);
int __thiscall sub_10026000(int this, int a2, int a3);
char __thiscall sub_10026060(void *this, char a2, char a3, int a4, int a5);
int __thiscall sub_100261B0(int this, char a2);
int __fastcall sub_10026260(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
// int __userpurge sub_10026350<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9);
// int __userpurge sub_10026430<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
int __thiscall sub_10026500(int this, int a2);
int __thiscall sub_100265C0(int this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10026630(int this, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_100266B0<eax>(int a1<ecx>, int a2<ebx>);
// int __usercall sub_100266D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
int __thiscall sub_10026710(int this, int a2, int a3);
// char __usercall sub_10026770<al>(int a1<edx>, int a2<ecx>, int a3<ebx>);
int __fastcall sub_100268D0(int a1, int a2, int a3);
int __fastcall sub_10026900(int a1, int a2, int a3);
// int __usercall sub_10026980<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>);
void __cdecl sub_10026A30(int a1);
// int __usercall sub_10026A40<eax>(int a1<eax>, int a2);
int __cdecl loc_10026A50(int); // weak
int *__thiscall sub_10026C50(int this);
int __thiscall sub_10026D10(int this, int a2, int a3);
// char __userpurge sub_10026E30<al>(int a1<ecx>, int a2<ebx>, int a3, int a4);
int __thiscall sub_10026F10(void *this);
void __thiscall sub_10026FD0(void *this, int a2);
void __thiscall sub_10027090(void *this);
int __thiscall sub_10027190(int this, int a2, int a3);
int __thiscall sub_100273C0(void *this, int a2);
int __thiscall sub_100273D0(void *this, int a2);
bool __thiscall sub_100273E0(void *this, int a2, int a3);
void *__thiscall sub_10027570(int this, char a2);
void *__thiscall sub_100275E0(void *this, char a2);
char __thiscall sub_10027610(int this);
// void __userpurge sub_10027860(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
int __thiscall sub_10027A80(int this, char a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10027B00(int this, char a2, int a3, int a4, int a5, char *a6);
int __thiscall sub_10027B90(int this, char a2, int a3);
// int __usercall sub_10027C20<eax>(int a1<edx>, int a2<ecx>, int a3<edi>);
int __thiscall sub_10027D10(int this, int a2);
int (__stdcall ***__cdecl sub_10027D30())(char);
int __thiscall sub_10027D80(int this, int a2);
int (__stdcall ***__cdecl sub_10027DA0())(char);
int __thiscall sub_10027DF0(int this, int a2);
int (__stdcall ***__cdecl sub_10027E10())(char);
void __thiscall sub_10027E60(int this, int a2);
int (__stdcall ***__cdecl sub_10027EE0())(char);
int (__stdcall ***__cdecl sub_10027F30())(char);
// BOOL __userpurge sub_10027F80<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
int (__stdcall ***__cdecl sub_10027F90())(char);
// int __userpurge sub_10027FA0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
int (__stdcall ***__cdecl sub_10028030())(char);
// int __userpurge sub_10028040<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5);
// int __userpurge sub_100280E0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4);
int (__stdcall ***__cdecl sub_100281B0())(char);
void *__thiscall sub_100281C0(int this, char a2);
// void *__userpurge sub_10028225<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
int __thiscall sub_10028230(int this);
// int __userpurge sub_10028240<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall j_nullsub_2(_DWORD); // weak
// int __userpurge sub_10028270<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10028290<eax>(int a1<ecx>, int a2<ebx>, int a3);
DWORD __thiscall sub_100282B0(int this);
char __thiscall sub_100282E0(int this);
// int __usercall sub_10028360<eax>(int a1<ecx>, int a2<edi>);
int __thiscall sub_10028530(void *this, int a2, DWORD a3);
int __fastcall sub_100285D0(int a1, DWORD a2);
HINTERNET __cdecl sub_100286F0();
// void *__userpurge sub_100287F0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
// int __usercall sub_10028820<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
int __thiscall sub_100288F0(int this, int a2);
int __thiscall sub_10028AB0(void *this, int a2);
void __thiscall sub_10028AC0(int this, LPCWSTR pwszObjectName);
void __thiscall sub_10028C20(DWORD_PTR this);
int __stdcall sub_10028D60(char a1, int a2);
void __thiscall sub_10028EB0(DWORD_PTR dwContext, LPVOID lpOptional, DWORD dwOptionalLength, DWORD dwTotalLength, LPCWSTR lpszHeaders);
// void __userpurge fnInternetCallback(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, unsigned int a6, int a7, int a8);
int __thiscall sub_10029260(int this, int a2);
// void *__usercall sub_10029320<eax>(void *a1<ecx>, int a2<ebx>, char a3);
// int __userpurge sub_10029380<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1002939B<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_100293B6<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_100293D1<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_100293EC<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_10029410(void *this, int a2);
// void __usercall sub_10029440(int a1<ecx>, int a2<ebx>);
// void *__userpurge sub_1002944B<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __cdecl sub_10029470(int a1);
void __cdecl sub_10029530();
void __cdecl sub_10029561();
void __cdecl sub_10029585(int a1);
void __cdecl sub_100295B3(int a1);
int __cdecl sub_100295E1(int); // weak
int __cdecl sub_10029607(int a1);
int __cdecl sub_10029631(int a1);
// int __usercall sub_1002965B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int dwBytes);
int __cdecl sub_10029664(int a1, int a2, int a3);
int __cdecl sub_1002967E(int a1, int a2, int a3);
int __thiscall sub_10029692(int this, int a2);
char __cdecl sub_100296B7(int a1);
void *__thiscall sub_100296F4(int this);
int sub_10029736(void); // weak
void *__thiscall sub_1002973B(void *this, char a2);
int __thiscall sub_10029778(int this);
// void __usercall sub_100297B1(int a1<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>);
int __fastcall sub_100297DC(int a1, int a2, int a3);
// void *__userpurge sub_10029830<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4);
// int __usercall sub_1002984F<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
int __cdecl sub_10029877();
// int __usercall sub_1002987D<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __usercall sub_100298F9<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
int __cdecl sub_10029952(int a1, const CHAR *a2);
void __cdecl sub_1002999D(int a1);
// void *__usercall sub_100299B7<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, char a5);
int __cdecl sub_100299D6(int a1);
int __cdecl sub_100299FE(int a1);
// void __usercall sub_10029A1D(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
void *__thiscall sub_10029A47(void *this);
// int __userpurge sub_10029A76<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5);
void __thiscall sub_10029AD2(void *this);
// int __usercall sub_10029AF6<eax>(int a1<ebx>, int a2<edi>, int a3);
// int __usercall sub_10029B62<eax>(int a1<ebx>, int a2<edi>, int a3, int MultiByteStr);
// int __usercall sub_10029C5F<eax>(int a1<ebx>, int a2<edi>, int a3, int MultiByteStr);
int __cdecl sub_10029D5C(int a1);
// int __usercall sub_10029DC5<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_10029DE6<eax>(int a1<ebx>, int a2, int a3, int a4, int a5, int a6);
signed int __cdecl sub_10029E7B(LPWSTR lpDestStr, int a2, LPCSTR lpMultiByteStr, UINT CodePage, int a5);
DWORD __cdecl sub_10029F21();
int __fastcall sub_10029F48(int a1, int a2, unsigned int a3);
int __thiscall sub_10029FB5(int this);
// void __usercall sub_10029FBF(int a1<ecx>, int a2<ebx>);
int __thiscall sub_10029FCF(int this);
int sub_1002A028(); // weak
int __thiscall sub_1002A02D(int this, char a2);
// void *__userpurge sub_1002A07B<eax>(int a1<ecx>, int a2<ebx>, char a3);
char __thiscall sub_1002A09A(int this);
int __thiscall sub_1002A0BD(void *this);
char __thiscall sub_1002A0FD(int this, int a2);
int __thiscall sub_1002A146(int this, int a2);
// int __userpurge sub_1002A17E<eax>(int a1<ebp>, int a2, int a3, int a4);
_DWORD __stdcall sub_1002A233(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __thiscall sub_1002A371(int this);
PVOID __cdecl sub_1002A3B2(PVOID Ptr);
void __cdecl sub_1002A3E0(LPCRITICAL_SECTION lpCriticalSection);
int __cdecl sub_1002A3EE(LPCRITICAL_SECTION lpCriticalSection); // idb
void __cdecl sub_1002A405(LPCRITICAL_SECTION lpCriticalSection);
void __cdecl sub_1002A413(LPCRITICAL_SECTION lpCriticalSection);
// int __usercall sub_1002A421<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, unsigned int a4, int a5);
// void __usercall sub_1002A486(int a1<ebx>, int a2);
// int __usercall sub_1002A49B<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, int ecx0<ecx>, char a4);
_DWORD __cdecl sub_1002A4AA(LPVOID lpMem); // weak
void *__cdecl sub_1002A4B0(void *a1, const void *a2, unsigned int a3);
int __cdecl loc_1002A6F8(int, int, int); // weak
int __cdecl off_1002A7E8(int, int, int); // weak
int __cdecl loc_1002A7F8(int, int, int); // weak
int __cdecl loc_1002A884(int, int, int); // weak
// __int64 __usercall sub_1002AAF4<edx:eax>(int a1<ebx>, int a2, int a3);
// __int64 __usercall sub_1002ADA0<edx:eax>(int a1<ebx>, int a2);
// int __usercall sub_1002ADB1<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int dwBytes);
int __thiscall sub_1002AE1B(int this, char a2);
// int __userpurge sub_1002AE36<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_1002AE51(int this, char a2);
// int __userpurge sub_1002AE6D<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_1002AE88(int this, char a2);
int __thiscall sub_1002AEA4(int this, int *a2);
int __thiscall sub_1002AEC9(int this, int a2, int a3);
// int __userpurge sub_1002AEE4<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_1002AF07(int this);
// void __usercall sub_1002AF18(int a1<ecx>, int a2<ebx>);
// int __userpurge sub_1002AF23<eax>(int a1<ecx>, int a2<ebx>, int a3);
// void *__userpurge sub_1002AF56<eax>(int a1<ecx>, int a2<ebx>, char a3);
void __thiscall sub_1002AF7B(void *this, int a2);
// void __usercall sub_1002AFB9(int a1<ecx>, int a2<ebx>);
int __thiscall sub_1002AFD5(int this);
// signed int __usercall sub_1002AFE5<eax>(int a1<ecx>, int a2<ebx>);
// void __usercall sub_1002B014(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, PVOID Ptr);
PVOID __cdecl sub_1002B054(PVOID Ptr);
// int __usercall sub_1002B10A<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, void *a5);
signed int __stdcall sub_1002B11F(int a1, int a2, int a3, void (__thiscall *a4)(_DWORD));
int __stdcall sub_1002B18E(int a1, int a2, int a3, int (*a4)(void));
int __thiscall sub_1002B1EC(int this, int a2, int a3, int a4);
void *__thiscall sub_1002B21D(void *this, char a2);
int __thiscall sub_1002B23D(void *this, int a2);
int __thiscall sub_1002B26C(void *this, int a2);
// int __userpurge sub_1002B29A<eax>(int a1<ebp>, int a2);
int __thiscall sub_1002B34B(int this);
// int __usercall sub_1002B353<eax>(void *this<ecx>, int a2<ebp>);
// int __userpurge sub_1002B396<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6);
int __thiscall sub_1002B3CF(int this, int a2);
PVOID __thiscall sub_1002B434(PVOID Parameter, DWORD DueTime);
LPCRITICAL_SECTION __thiscall sub_1002B4FD(LPCRITICAL_SECTION lpCriticalSection);
int __thiscall sub_1002B511(int this);
int __thiscall sub_1002B51D(int this);
int __thiscall sub_1002B52D(int this);
// int __userpurge sub_1002B544<eax>(int a1<ebp>, int a2);
// int __userpurge sub_1002B589<eax>(int a1<ebp>, int a2);
int __thiscall sub_1002B5CC(int this);
// int __userpurge sub_1002B5EC<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_1002B607(int this);
// int __userpurge sub_1002B62D<eax>(int a1<ebp>, int a2);
// int __userpurge sub_1002B672<eax>(int a1<ebp>, int a2);
// int __userpurge sub_1002B6B7<eax>(int a1<ecx>, int a2<ebx>, int a3);
void __thiscall sub_1002B6CE(LPCRITICAL_SECTION lpCriticalSection);
void __cdecl sub_1002B6D6();
void __thiscall sub_1002B6DD(void *this);
char __thiscall sub_1002B6E4(void *this);
// int __userpurge sub_1002B6EB<eax>(void *this<ecx>, int ebx0<ebx>, unsigned int a2);
// LPVOID __usercall sub_1002B771<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
int __thiscall sub_1002B793(int this);
int __stdcall sub_1002B7B1(int a1, int a2, int a3);
int __stdcall Callback(int a1, int a2);
// int __usercall sub_1002B829<eax>(int this<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>);
char __thiscall sub_1002B84E(void *this);
int __thiscall sub_1002B871(void *this, int a2);
int __thiscall sub_1002B89F(int this, int a2);
int __thiscall sub_1002B8F2(int this);
void __thiscall sub_1002B91D(LPCRITICAL_SECTION lpCriticalSection);
DWORD __thiscall sub_1002B925(void *this, int a2);
int __thiscall sub_1002B95A(void *this);
int __thiscall sub_1002B98A(void *this);
bool __thiscall sub_1002B9BE(int this, int a2, char a3);
char __thiscall sub_1002BA5D(int this, int a2, char a3);
int __thiscall sub_1002BAED(void *this);
void __thiscall sub_1002BB03(int this);
int __thiscall sub_1002BB1B(void *this);
int __cdecl sub_1002BB3B();
void __thiscall sub_1002BB52(LPCRITICAL_SECTION lpCriticalSection);
int __cdecl sub_1002BB6C();
int __thiscall sub_1002BB74(void *this);
char __thiscall sub_1002BB85(void *this, int a2);
int __thiscall sub_1002BBBE(int this, int a2);
char __thiscall sub_1002BBE2(int this, int a2);
char __thiscall sub_1002BC25(void *this);
int __thiscall sub_1002BC92(int this, int a2);
char __thiscall sub_1002BCE1(void *_ECX);
DWORD __cdecl sub_1002BD65();
int __cdecl sub_1002BD6B(int a1, int a2, int a3);
int __thiscall sub_1002BDA4(void *this);
// char __usercall sub_1002BDD2<al>(int a1<ecx>, int a2<ebx>);
int loc_1002BE76(); // weak
int __thiscall sub_1002BEFD(int this, int a2, char a3, char a4);
_DWORD __stdcall sub_1002BF46(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __thiscall sub_1002BFEF(int this);
int __thiscall sub_1002C00A(int this, int a2, char a3, char a4);
int __thiscall sub_1002C03A(int this, int a2, char a3, char a4);
int __thiscall sub_1002C06B(int this);
int __thiscall sub_1002C08B(int this);
unsigned int __thiscall sub_1002C0B4(void *this);
// int __usercall sub_1002C0CE<eax>(int a1<ebp>);
// void *__userpurge sub_1002C143<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __thiscall nullsub_2(_DWORD); // weak
int __stdcall sub_1002C172(int a1, int a2, int a3);
int __stdcall sub_1002C1BF(int a1, int a2);
int __cdecl sub_1002C20D();
int __thiscall sub_1002C2AB(int this);
char __thiscall sub_1002C2CA(int this);
char __thiscall sub_1002C304(int this, int a2, int a3);
char __thiscall sub_1002C353(void *this, int a2, int a3);
char __thiscall sub_1002C390(void *this, int a2, int a3);
int __thiscall sub_1002C3C9(void *this);
int __thiscall sub_1002C403(int this, int a2, int a3);
int __cdecl sub_1002C4A7(int a1, char a2);
char __thiscall sub_1002C4E0(void *this);
char __thiscall sub_1002C500(int this);
char __thiscall sub_1002C52D(int this);
// int __usercall sub_1002C5B1<eax>(int a1<ebp>);
// int __userpurge sub_1002C6B2<eax>(int a1<ebp>, int ebx0<ebx>, int a3<edi>, int a2);
// int __usercall sub_1002C787<eax>(int a1<ebp>);
// void __usercall sub_1002CAA4(int a1<ebx>, int a2);
// void __usercall sub_1002CAC2(int a1<ebx>);
// void __usercall sub_1002CAEC(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
bool __thiscall sub_1002CAFA(void *this, int a2);
// void *__userpurge sub_1002CB18<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, char a5);
int sub_1002CB37(); // weak
int sub_1002CB4C(); // weak
int __thiscall sub_1002CB6F(int this);
// int __usercall sub_1002CB88<eax>(int a1<ebx>, int a2<edi>, unsigned int a3);
_DWORD __cdecl loc_1002CBD3(_DWORD); // weak
char __thiscall sub_1002CC23(int this, int a2);
// void __usercall sub_1002CC4D(int a1<ebx>, int a2<edi>, int a3);
char __thiscall sub_1002CC67(void *this, int a2);
int __cdecl sub_1002CC9E(int a1);
// int __usercall sub_1002CCF3<eax>(int a1<ebx>, int a2);
// int __userpurge sub_1002CD2C<eax>(int a1<ebp>, int a2);
// int __userpurge sub_1002CD79<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1002CD94<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4);
// int __userpurge sub_1002CE92<eax>(int a1<ebp>, int a2);
// int __userpurge sub_1002CF54<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1002CF6F<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_1002CF9A(int this);
int loc_1002CFAA(); // weak
// int __usercall sub_1002CFB4<eax>(int a1<ebp>);
// void *__userpurge sub_1002D06E<eax>(int a1<ecx>, int a2<ebx>, char a3);
// int __userpurge sub_1002D097<eax>(int a1<ebp>, int a2);
int __thiscall sub_1002D0D1(void *this, char a2, char a3);
char __thiscall sub_1002D0F4(unsigned int *this, int a2, int a3);
int __thiscall sub_1002D133(int this, char a2);
int __cdecl sub_1002D18F(int a1, unsigned int a2);
int __thiscall sub_1002D1BB(int this, int a2, int a3);
char __thiscall sub_1002D1E5(int this, int a2);
int __thiscall sub_1002D257(int this, int a2, int a3);
int __thiscall sub_1002D29F(int this, char a2);
int __thiscall sub_1002D3CC(void *this, int a2);
// int __usercall sub_1002D414<eax>(int a1<ebp>, int a2<ebx>, int a3<edi>);
// char __usercall sub_1002D4A0<al>(int a1<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>);
// char __userpurge sub_1002D4F4<al>(void *this<ecx>, int ebx0<ebx>, int edi0<edi>, int a2, int a3);
// char __usercall sub_1002D593<al>(int a1<ecx>, int a2<ebx>, int a3<edi>);
int __stdcall sub_1002D5A1(int a1, int a2);
int __thiscall sub_1002D5C0(int this, int a2);
// int __userpurge sub_1002D661<eax>(int a1<ebp>, int a2, int a3);
// char __usercall sub_1002D6E9<al>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
bool __cdecl sub_1002D6F5(int a1, int a2);
int __cdecl sub_1002D70A(void *a2);
int __thiscall sub_1002D716(int this);
int __thiscall sub_1002D744(void *this);
// int __userpurge sub_1002D74F<eax>(int a1<ebp>, int a2);
int __thiscall sub_1002D819(void *this);
int __thiscall sub_1002D81D(int this, int a2);
char __thiscall sub_1002D860(int this);
// int __usercall sub_1002D8B1<eax>(int a1<ebp>);
bool __thiscall sub_1002D8E1(int this);
bool __thiscall sub_1002D8F4(int this);
bool __thiscall sub_1002D907(int this);
int __thiscall sub_1002D915(int this);
// int __usercall sub_1002D91E<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
int __thiscall sub_1002D951(void *this, int a2);
int __thiscall sub_1002D99A(_DWORD); // weak
int __thiscall sub_1002D9C0(int this);
int __thiscall sub_1002D9C4(int this);
// int __usercall sub_1002D9DF<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1002D9FA<eax>(int a1<ecx>, int a2<ebp>);
// int __usercall sub_1002DA2E<eax>(int a1<ebx>, int a2<edi>);
int __thiscall sub_1002DA6B(void *this, int a2);
// int __userpurge sub_1002DB66<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5);
// int __userpurge sub_1002DF26<eax>(int a1<ebp>, int a2);
int __stdcall loc_1002DF4D(int); // weak
// void __userpurge sub_1002DFF3(int a1<ebp>, int a2);
char __thiscall sub_1002E00C(int this, int a2);
char __cdecl sub_1002E046(int a1, int a2);
// bool __userpurge sub_1002E05F<eax>(int a1<ecx>, int a2<edi>, char a3);
// int __userpurge sub_1002E0B5<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned int a4);
// int __usercall sub_1002E0F3<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __userpurge sub_1002E10C<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4);
int loc_1002E1CF(); // weak
int __thiscall sub_1002E1E2(int this);
int __thiscall sub_1002E1F9(int this);
int __thiscall sub_1002E239(void *this);
int loc_1002E267(); // weak
int __thiscall sub_1002E271(int this);
bool __thiscall sub_1002E288(int this, int a2);
int __thiscall sub_1002E2AC(int this, signed int a2);
void *__thiscall sub_1002E2E0(void *this, char a2);
void *__thiscall sub_1002E300(void *this, char a2);
int __thiscall sub_1002E31F(void *this, char a2);
int __thiscall sub_1002E348(int this, int a2);
int __thiscall sub_1002E4A1(void *this, int a2, char a3);
int __thiscall sub_1002E4D1(int this, int a2);
int __thiscall sub_1002E4F8(int this, int a2);
bool __thiscall sub_1002E565(int this, int a2);
// int __userpurge sub_1002E597<eax>(int a1<ebp>, int a2);
bool __cdecl sub_1002E684(int a1);
char __thiscall sub_1002E690(int this, int a2);
// int __usercall sub_1002E6D7<eax>(int a1<ecx>, int a2<ebp>);
void __thiscall sub_1002E6F8(void *this);
BOOL __cdecl sub_1002E737();
// int __usercall sub_1002E746<eax>(int a1<ebx>, int a2<ebp>);
int __stdcall sub_1002E7C5(int a1);
int __thiscall sub_1002E7E7(int this);
void __cdecl sub_1002E921();
// int __usercall sub_1002E929<eax>(int a1<ebp>);
// void __usercall sub_1002E935(int a1<eax>, int a2<ebp>);
// int __usercall sub_1002E940<eax>(int a1<ebp>, int a2<edi>);
int __thiscall sub_1002E94F(int this);
int __thiscall sub_1002E957(int this);
int __thiscall sub_1002E962(int this);
int __thiscall sub_1002E96A(int this);
int __thiscall sub_1002E975(int this, int a2);
bool __thiscall sub_1002E9C1(int this);
int __thiscall sub_1002E9D5(int this);
int __thiscall sub_1002E9D9(int this);
int __thiscall sub_1002E9DD(int this);
int __thiscall sub_1002E9EE(int this);
char __thiscall sub_1002EA04(int this, int a2, int a3);
char __thiscall sub_1002EAEE(int this, int a2, char a3);
int __thiscall sub_1002EB27(int this, int a2);
int __thiscall sub_1002EB4A(int this, int a2);
// int __usercall sub_1002EB7B<eax>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_1002EBD5(int this);
int __thiscall sub_1002EBF2(int this, int a2);
int __thiscall sub_1002EC53(int this, int a2);
int __thiscall sub_1002EC99(LPVOID lpTlsValue, int); // idb
int __thiscall sub_1002ECB3(int this, int a2, int a3);
// int __userpurge sub_1002ECC6<eax>(int a1<ecx>, int a2<ebx>, int a3);
char __thiscall sub_1002ED43(int this);
int __thiscall sub_1002EDCA(void *this);
// int __usercall sub_1002EDD5<eax>(int a1<ecx>, int a2<ebp>);
char __thiscall sub_1002EE2C(void *ListHead, int a2, signed int a3, char a4);
int __thiscall sub_1002EF22(int this, int a2);
int __thiscall sub_1002EF49(void *this, int a2);
BOOL __thiscall sub_1002EF5F(LPVOID lpTlsValue);
int __thiscall sub_1002EF6D(int this, int a2);
int __cdecl sub_1002EF7A(int a1);
_DWORD __thiscall sub_1002EF93(_DWORD ecx0); // weak
char __thiscall sub_1002EF98(void *this);
int __cdecl sub_1002F014(int (__cdecl *a1)(_DWORD, _DWORD), int a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __thiscall sub_1002F0B6(void *this, int a2, int a3, int a4);
int __cdecl sub_1002F23E(char a1, char a2, int a3, int a4);
char __thiscall sub_1002F2AF(void *this, int a2, char a3);
int __stdcall sub_1002F2FC(char a1, char a2, int a3, int a4);
int __thiscall sub_1002F329(int this, int a2);
int __thiscall sub_1002F38C(int this, int a2);
void __thiscall sub_1002F39B(int this);
int __thiscall sub_1002F3E5(int this, int a2);
// char *__usercall sub_1002F41A<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
int __thiscall sub_1002F423(int this);
// int __userpurge sub_1002F437<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4);
// void __usercall sub_1002F482(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __userpurge sub_1002F4A1<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4, int a5);
// void __usercall sub_1002F4EE(int a1<ebp>);
// int __userpurge sub_1002F4FF<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
// int __userpurge sub_1002F536<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5);
int __thiscall sub_1002F572(int this, int a2, char a3);
int loc_1002F6C5(); // weak
// void __usercall sub_1002F6D1(int a1<ecx>, int a2<ebx>, int a3<edi>);
void *__thiscall sub_1002F75B(void *this, int a2);
void *__thiscall sub_1002F794(void *this, char a2);
int __thiscall sub_1002F7B4(int this, char a2);
// void *__userpurge sub_1002F7DA<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __thiscall sub_1002F7FF(int this, int a2);
int __cdecl sub_1002F827(int a1);
// int __userpurge sub_1002F851<eax>(int a1<ebp>, int a2, int a3, int a4, int a5);
// int __usercall sub_1002F8DB<eax>(int a1<ebp>);
// int (*__usercall sub_1002F9E6<eax>(int a1<ebx>, int a2<ebp>))();
int loc_1002FA08(); // weak
// void __usercall sub_1002FA0D(int a1<ebx>, int a2<edi>);
// int __usercall sub_1002FA13<eax>(int a1<ebp>);
// void __usercall sub_1002FB18(int a1<ebx>, int a2<edi>, LPVOID lpMem);
int __thiscall sub_1002FB29(void *this);
// void __usercall sub_1002FB35(LPVOID lpMem<ecx>, int a2<ebx>);
// int __usercall sub_1002FB48<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
int __thiscall sub_1002FB60(int this);
int __thiscall sub_1002FB68(void *this, void *a2);
int __cdecl sub_1002FB8C(_DWORD); // weak
int __thiscall sub_1002FBE7(int this, int a2, int a3);
int __thiscall sub_1002FC09(int this, int a2, int a3);
// void __usercall sub_1002FC2C(const void *a1<ecx>, int a2<edi>);
int __cdecl sub_1002FD39(int, int); // weak
void *__cdecl sub_1002FD59(void *a1);
int __cdecl sub_1002FD89(int a1);
// int __usercall sub_1002FD9C<eax>(int a1<ebp>);
int __cdecl sub_1002FDDA(int a1);
// void __usercall sub_1002FDE9(const void *a1<ecx>, int a2<edi>, const void **a3);
// unsigned int __userpurge sub_1002FDF7<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, unsigned int a4);
// unsigned int __userpurge sub_1002FE69<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, unsigned int a4);
// int __usercall sub_1002FEDB<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
// int __usercall sub_1002FEEC<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4, int a5);
int __thiscall sub_1002FF03(int this);
int __thiscall sub_1002FF15(int this);
int __thiscall sub_1002FF27(int this);
int __thiscall sub_1002FF39(int this);
int __thiscall sub_1002FF4B(int this, char a2);
int __thiscall sub_1002FF67(int this);
int __thiscall sub_1002FF79(int this);
int __thiscall sub_1002FF8B(int this, char a2);
int __thiscall sub_1002FFA7(int this);
int __thiscall sub_1002FFB9(int this, char a2);
int __thiscall sub_1002FFD5(int this);
int __thiscall sub_1002FFE7(int this);
int __thiscall sub_1002FFF9(int this, char a2);
int __thiscall sub_10030015(int this);
int __thiscall sub_10030027(int this, char a2);
int __thiscall sub_10030043(int this);
int __thiscall sub_10030055(int this);
int __thiscall sub_10030067(int this);
int __thiscall sub_10030079(int this, int a2);
int __thiscall sub_10030097(int this, int a2);
int __thiscall sub_100300B2(int this);
int __thiscall sub_100300C4(int this);
// void *__userpurge sub_100300DB<eax>(int a1<ecx>, int a2<ebx>, char a3);
int __cdecl sub_10030100(int a1, unsigned __int8 a2, int a3);
// int __userpurge sub_100301AD<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
// int __usercall sub_10030235<eax>(int a1<ebx>, int a2<edi>, int a3, int a4);
// int __usercall sub_10030377<eax>(int a1<ebx>, int a2<edi>, int a3);
_DWORD __cdecl sub_100303A3(LPVOID lpMem); // weak
// signed int __usercall sub_100303A8<eax>(int a1<ebx>, int a2<edi>, int a3, int a4);
// signed int __usercall sub_100305D1<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_10030675(struct _EXCEPTION_POINTERS *ExceptionInfo); // idb
// int __usercall sub_100306B2<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, char a4);
// int __usercall sub_100307AB<eax>(int a1<ebx>, int a2<edi>, int a3<esi>);
// int __usercall sub_100307B7<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, int a4);
// int __usercall sub_10030885<eax>(int a1<ebx>, int a2, int a3, char a4);
// int __usercall sub_100308A3<eax>(int a1<ebx>, int (__cdecl *a2)(_DWORD, _DWORD, _DWORD, _DWORD), int a3, int a4, int a5, int a6);
// int __usercall sub_10030914<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned int a4, int a5, char a6);
// int __usercall sub_10030930<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int dwBytes);
// void __usercall sub_100309C2(int a1<ebx>, LPVOID lpMem);
signed int __stdcall sub_100309FA(int a1, int a2, int a3, void (__thiscall *a4)(_DWORD), int a5);
int __cdecl sub_10030A70(int a1, unsigned __int8 a2);
char __cdecl sub_10030BA0(int a1, int a2);
// void **__usercall sub_10030BE0<eax>(int a1<ebx>, int a2<edi>);
signed int __cdecl sub_10030C10(int a1, int a2);
// int __usercall sub_10030C56<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, LPVOID lpMem, int dwBytes);
void *__thiscall sub_10030D01(void *this);
int loc_10030DB7(); // weak
signed int __stdcall sub_10030DC0(int a1, int a2, int a3, int a4);
int __thiscall sub_10030E85(int this, int a2, int a3);
char __thiscall sub_10030EB8(int this, int a2, int a3);
int __thiscall sub_10030EEB(int this, int a2);
int __thiscall sub_10030F1B(void *this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_10030F55(int this, int a2, int a3, int a4);
int __thiscall sub_10030F84(int this, int a2, int a3);
int __thiscall sub_10030FB0(void *this);
// int *__usercall sub_10030FE1<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __usercall sub_10030FF5<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __usercall sub_10031064<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4, int a5, int a6, int a7);
int __cdecl sub_1003113F();
// int __usercall sub_1003117F<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
int sub_1003118B(void); // weak
// int __usercall sub_10031190<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
int __thiscall sub_1003119C(int this, int a2, char a3);
void __thiscall sub_100311BB(int this);
void *__thiscall sub_100311CC(int this, char a2);
int __stdcall sub_100311EB(int a1, int a2);
BOOL __thiscall sub_100311FA(char *Parameter);
DWORD __thiscall sub_1003125D(int this);
void *__thiscall sub_10031279(void *this);
void *__thiscall sub_10031290(void *this, int a2, int a3, int a4);
void *__thiscall sub_100312C7(void *this, int a2, int a3, int a4);
// int __userpurge sub_1003130E<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
// int __userpurge sub_10031354<eax>(int a1<ebp>, int a2);
void *__thiscall sub_1003165F(void *this);
// int __userpurge sub_10031684<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1003169F<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_100316BA<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_100316DE(PSLIST_HEADER ListHead);
int __thiscall sub_10031750(PSLIST_HEADER ListHead);
int __thiscall sub_100317C7(int this);
int __thiscall sub_100317DE(int this);
int loc_100317FC(); // weak
_DWORD __thiscall sub_10031803(_DWORD ecx0); // weak
int loc_100318B1(); // weak
int __thiscall sub_100318B8(int this, signed int a2);
int __thiscall sub_100318FE(int this, char a2);
void *__thiscall sub_10031948(void *this, char a2);
void *__thiscall sub_10031968(void *this, char a2);
void *__thiscall sub_10031987(void *this, char a2);
void *__thiscall sub_100319A7(void *this, char a2);
void *__thiscall sub_100319C7(void *this, char a2);
void *__thiscall sub_100319E6(void *this, char a2);
int __thiscall sub_10031A12(int this, int a2);
// int __userpurge sub_10031B6B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
int __thiscall sub_10031B98(void *this, int a2);
int __thiscall sub_10031BD1(void *this, int a2);
int __thiscall sub_10031BFE(int this, int a2);
int __thiscall sub_10031C25(void *this, int a2, unsigned int a3);
// int __userpurge sub_10031CE9<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5);
// int __userpurge sub_10031D24<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4);
char __cdecl sub_10031D6D();
// int __usercall sub_10031D70<eax>(int a1<ecx>, int a2<ebx>);
// int __userpurge sub_10031DB6<eax>(void *a1<ecx>, int a2<ebx>, int a3);
BOOL __thiscall sub_10031E1F(void *this);
int __thiscall sub_10031E42(void *this);
int __cdecl sub_10031ECA(int a1);
int __cdecl sub_10031ED6(int a1);
int __cdecl sub_10031EE2();
// int __usercall sub_10031F06<eax>(int a1<ebp>);
// int __usercall sub_10031F62<eax>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_10031FFA(int this);
int __thiscall sub_1003203D(int this, unsigned int a2);
signed int __thiscall sub_100320CA(int this);
// int __userpurge sub_10032153<eax>(int a1<ecx>, int a2<edi>, int a3);
int __stdcall sub_100321B0(int a2);
int __cdecl sub_100321B9();
// int __usercall sub_100321D5<eax>(int a1<ebx>, int a2<edi>, void *a3);
// int __usercall sub_100321FB<eax>(int this<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>);
int __thiscall sub_10032207(int this);
BOOL __thiscall sub_10032222(int this);
int __stdcall sub_10032242(int a1);
int __stdcall sub_10032260(int a1);
int __thiscall sub_10032282(void *this);
int __thiscall sub_1003229F(void *this);
int __thiscall sub_100322DC(int this);
char __thiscall sub_10032313(void *this, int a2, char a3);
LPVOID __cdecl sub_10032356();
int __cdecl sub_10032363();
int __thiscall sub_10032376(int this);
int __thiscall sub_10032393(int this);
int __thiscall sub_1003248C(unsigned int *this, int a2, int a3);
int __thiscall sub_100324C2(void *this);
int __thiscall sub_100324FD(int this, int a2);
int __stdcall sub_10032551(int a1, int a2, int a3, int a4);
int __thiscall sub_1003257C(void *this, int a2, int a3, int a4);
char __thiscall sub_100325AB(int this, int a2, int a3, int a4, int a5, int a6, int a7);
char __thiscall sub_100326A8(int this);
char __thiscall sub_100326D2(void *this);
int __thiscall sub_10032799(int this);
// int __userpurge sub_100327A2<eax>(int a1<ebp>, int a2, int a3);
// int __usercall sub_1003284C<eax>(int a1<ebp>, int a2<edi>);
// int __userpurge sub_100328DC<eax>(int a1<ebx>, int a2<ebp>, int a3);
// int __userpurge sub_1003293C<eax>(int a1<ebp>, int a2);
int __thiscall sub_10032A49(void *this);
int __thiscall sub_10032A58(void *this);
int __cdecl sub_10032A67();
int __thiscall sub_10032A75(int this);
int __stdcall sub_10032AAA(int a1, int a2, int a3);
int __thiscall sub_10032AE6(int this, int a2, int a3);
int __thiscall sub_10032B10(int this);
int __thiscall sub_10032B31(int this, int a2);
int __thiscall sub_10032B53(int this, int a2, int a3);
int __thiscall sub_10032B88(int this);
// int __userpurge sub_10032B8C<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// int __userpurge sub_10032BA7<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4, int a5);
int __thiscall sub_10032C00(int this);
int __thiscall sub_10032C17(int this, char a2);
int __thiscall sub_10032C35(void *this);
// int __usercall sub_10032C48<eax>(int a1<ebp>, int a2<edi>);
int __thiscall sub_10032CA9(int this, int a2);
void __thiscall sub_10032CCC(void *this, int a2);
void __thiscall sub_10032D4B(void *this, int a2);
bool __thiscall sub_10032DBB(int this);
int __thiscall sub_10032DD0(int this);
int __thiscall sub_10032DD4(int this);
int __thiscall sub_10032DDB(_DWORD); // weak
int __thiscall sub_10033206(void *this);
int __thiscall sub_10033214(unsigned int *this, int a2, int a3);
// int __userpurge sub_10033278<eax>(int a1<ebp>, int a2);
int __thiscall sub_1003333B(void *this);
bool __thiscall sub_10033369(int this, int a2);
int __thiscall sub_100333A7(int this, int (__cdecl *a2)(_DWORD), int a3, int a4);
int __thiscall sub_100333DA(int this, int a2);
char __thiscall sub_1003341E(int this);
char __thiscall sub_1003343B(void *this, int a2);
int __stdcall sub_1003346F(int a1, int a2, int a3, int a4);
char __thiscall sub_10033480(int this, int a2);
char __thiscall sub_100334A2(int this, int a2);
DWORD __cdecl sub_10033531();
BOOL __cdecl sub_1003357F();
int __thiscall sub_10033598(void *this, int a2);
int __thiscall sub_10033735(int this);
int __thiscall sub_100337AB(int this);
int __thiscall sub_10033833(void *this);
int __thiscall sub_1003384B(void *_ECX, int a2);
char __thiscall sub_10033869(void *this, int a2, char a3, int a4, int a5, int a6);
// int __userpurge sub_100338CD<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
int __thiscall sub_10033904(int this);
int __thiscall sub_1003391C(int this);
int __thiscall sub_10033987(void *this);
// int __userpurge sub_10033999<eax>(int a1<ecx>, int a2<edi>, HANDLE hSourceHandle);
int __thiscall sub_10033A4A(int this);
USHORT __thiscall sub_10033A64(int this, int a2);
int __thiscall sub_10033AAB(void *this);
PSINGLE_LIST_ENTRY __thiscall sub_10033ABD(int this, int a2, char a3);
int __thiscall sub_10033AFD(int this, int a2);
PSINGLE_LIST_ENTRY __thiscall sub_10033B41(int this);
BOOL __thiscall sub_10033B8E(int this, LONG lReleaseCount);
int __thiscall sub_10033BAC(void *this, int a2);
char __thiscall sub_10033BDE(void *ListHead, int a2, signed int a3, char a4);
char __thiscall sub_10033CDC(void *ListHead, int a2, signed int a3, char a4);
int __thiscall sub_10033DDA(void *this);
_DWORD *__thiscall sub_10033E02(void *this);
_DWORD *__thiscall sub_10033E26(int this);
int __thiscall sub_10033E49(int this, int a2);
char __thiscall sub_10033E85(int this, int a2);
char __thiscall sub_10033E9D(int this);
int __thiscall sub_10033EAB(void *this, int a2, unsigned int a3);
int __thiscall sub_10033FA1(void *this);
void *__cdecl sub_10033FEE(void *ListEntry);
LPVOID __cdecl sub_10034035();
char __thiscall sub_10034051(void *this);
int __thiscall sub_10034073(void *this);
int __thiscall sub_100340A8(void *this, int a2, int a3, int a4);
void __thiscall sub_100340DE(int this, int a2);
int __cdecl sub_10034103(int a1, int a2);
int __cdecl sub_10034134(int a1, int a2);
char __thiscall sub_1003416E(void *this, int a2, char a3, int a4, int a5, int a6);
char __thiscall sub_10034194(void *this, int a2, char a3, int a4, int a5, int a6, int a7);
void __cdecl sub_100341E8();
int __thiscall sub_1003424B(void *this, int a2, int a3, int a4);
BOOL __thiscall sub_10034384(void *this);
char __thiscall sub_1003440E(int this);
char __stdcall sub_10034533(int a1, int a2);
char __stdcall sub_10034542(int a1, int a2);
int __thiscall sub_1003458A(int this, int a2);
int __cdecl sub_10034621(char a1, char a2, int a3);
int __stdcall sub_1003468C(char a1, char a2, int a3);
int __thiscall sub_100346B6(int this, int a2);
signed int __thiscall sub_100346EB(int this);
int __thiscall sub_10034719(int this, int a2);
signed int __thiscall sub_10034761(int this);
char __thiscall sub_10034793(int this, int a2);
int __thiscall sub_10034834(void *this, char a2);
int __thiscall sub_10034890(void *this);
int __thiscall sub_10034897(void *this);
void __cdecl sub_1003489E();
void *__thiscall sub_100348AC(void *this, int a2);
_DWORD *__thiscall sub_100348F2(void *this);
int __cdecl sub_100348F9(int a1);
BOOL __cdecl sub_10034906(int a1);
HMODULE __cdecl sub_10034942(DWORD dwExitCode);
unsigned int __cdecl sub_1003496D();
HANDLE __cdecl sub_100349B9(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
HMODULE __cdecl sub_10034A04();
int __cdecl sub_10034A98(unsigned int a1, int a2, int a3);
int __cdecl sub_10034AF2(int a1, int a2, int a3);
int __cdecl sub_10034B30(int a1, int a2);
int __cdecl sub_10034B66(int a1, int a2);
int __thiscall sub_10034B9B(void *this);
int __thiscall sub_10034BAB(void *this);
void __cdecl sub_10034BB6();
char __thiscall sub_10034BBF(void *this);
char __thiscall sub_10034BDF(void *this);
BOOL __cdecl sub_10034BF4();
// void __usercall sub_10034C0A(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, int a7);
BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);
// int __usercall sub_10034D9F<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4, int a5, int a6);
// int __usercall sub_10034EAD<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, int a7, int a8, int a9);
void *__cdecl sub_10034EE0(void *a1, const void *a2, unsigned int a3);
int __cdecl loc_10035128(int, int, int); // weak
int __cdecl off_10035218(int, int, int); // weak
int __cdecl loc_10035228(int, int, int); // weak
int __cdecl loc_100352B4(int, int, int); // weak
int __cdecl sub_10035530(int a1);
void __stdcall sub_100355BB(int a1, int a2);
int __cdecl sub_10035616(_DWORD); // weak
int __thiscall sub_1003562A(_DWORD); // weak
int sub_10035639(void); // weak
char *__cdecl sub_10035648();
char *__cdecl sub_1003567B();
char *__cdecl sub_100356B1();
char *__cdecl sub_100356E7();
// int __usercall sub_10035720<eax>(int a1<ebx>, int a2<edi>, PEXCEPTION_RECORD ExceptionRecord, int TargetFrame, int a5);
// int __usercall sub_10035751<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4<esi>);
// void __usercall sub_100357EE(int a1<edi>, int a2<esi>, int a3, int a4, int a5, int a6, int a7);
_DWORD __cdecl sub_1003584C(_DWORD, _DWORD); // weak
// signed int __usercall sub_10035853<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6, int a7, int a8, int a9);
int __cdecl loc_100358FC(int, int, int, int, int, int, int); // weak
int __cdecl sub_10035928(int a1, int a2, int a3, int a4, int a5);
// int __usercall sub_100359A7<eax>(int a1<ebp>, int a2, int a3);
// DWORD __userpurge sub_100359D7<eax>(int a1<edi>, int a2<esi>, PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord);
int __stdcall loc_10035A01(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord); // weak
// int __usercall sub_10035A2A<eax>(int a1<ebx>, int a2<edi>, int a3, int a4);
// void __usercall sub_10035A54(int a1<ebx>, int a2<edi>, int a3);
// signed int __usercall sub_10035AA4<eax>(int a1<ebx>, int a2<edi>, int a3);
// int __usercall sub_10035ACD<eax>(int a1<eax>, int a2<ebx>, int a3<edi>, int ExceptionRecord, int a5, int a6, int a7);
int __cdecl sub_10035B03(int a1);
int __cdecl sub_10035B8E(int a1, int a2, int a3, int a4, int a5, int a6, int a7);
// void __usercall sub_10035D5C(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __usercall sub_10035D9C<eax>(int a1<ebx>, int a2<esi>, PEXCEPTION_RECORD ExceptionRecord, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, PVOID TargetFrame);
// signed int __usercall sub_10035E17<eax>(int a1<ebx>, int a2<edi>, int a3);
void __cdecl sub_10035E64(int ExceptionRecord, int a2, int a3, int a4, int a5, char a6, int a7, PVOID TargetFrame);
// void __usercall sub_100361FF(int a1<ebx>, PEXCEPTION_RECORD ExceptionRecord, int a3, int a4, int a5, int a6, int a7, int a8, PVOID TargetFrame);
// char __usercall sub_10036319<al>(int a1<ebx>, int a2<edi>, int a3, int a4);
// char __usercall sub_1003639F<al>(int a1<ebx>, int a2<edi>);
int __cdecl sub_100363B0(int a1, int a2);
int __cdecl sub_100363D5(int a1, int a2, int a3, int a4);
int __cdecl sub_10036463(int a1, int a2, int a3, int a4);
// void __usercall sub_100365E8(int a1<ebx>, int a2<edi>, int a3);
// int __usercall sub_10036636<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6);
// int __usercall sub_1003670F<eax>(int a1<ebx>, int a2<edi>, int ExceptionRecord, int a4, int a5, int a6, int a7, int a8, PVOID TargetFrame, char a10);
bool __cdecl sub_100367EE(int a1, int a2, int a3);
void __cdecl sub_1003684B(unsigned int a1, LPCSTR lpWideCharStr);
// void __usercall sub_10036A23(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// void __usercall sub_10036AAB(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
signed int __cdecl sub_10036B52();
void __cdecl sub_10036B87(int a1);
// int __usercall sub_10036B9C<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_10036BC5<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4);
// int __usercall sub_10036C15<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4);
// int __usercall sub_10036C65<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4);
// int __usercall sub_10036CB5<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4);
// int __usercall sub_10036D05<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4);
// int __usercall sub_10036D5B<eax>(int a1<ebx>, int a2<edi>, signed int a3);
// int __usercall sub_10036D86<eax>(int a1<ebx>, int a2<edi>, signed int a3);
// int __usercall sub_10036DB1<eax>(int a1<ebx>, int a2<edi>, signed int a3);
// int __usercall sub_10036DDC<eax>(int a1<ebx>, int a2<edi>, signed int a3);
// int __usercall sub_10036E07<eax>(int a1<ebx>, int a2<edi>, signed int a3);
// int __usercall sub_10036E34<eax>(int a1<ebx>, int a2);
// int __usercall sub_10036E87<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_10036EAD<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_10036ED3<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_10036EFB<eax>(int a1<ebx>, int a2<edi>);
int __fastcall sub_10036F21(int a1, int a2, int a3);
// unsigned int __usercall sub_100372B9<eax>(int a1<ebx>, int a2, int a3, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpDestStr, int cchDest, UINT CodePage, int a10);
// unsigned int __usercall sub_100374A2<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpDestStr, int cchDest, UINT CodePage, int a11);
// LPVOID __usercall sub_100374E6<eax>(int this<ecx>, int ebx0<ebx>, unsigned int a2, unsigned int a3);
// int __usercall sub_10037530<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int dwBytes);
// int __usercall sub_10037579<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, LPVOID lpMem, int dwBytes);
// int __usercall sub_100375C5<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, const void *lpMem, unsigned int a5, unsigned int a6);
// int __usercall sub_10037615<eax>(int a1<ebx>);
// int __usercall sub_10037628<eax>(int a1<ebx>, int a2);
// int __usercall sub_10037649<eax>(int a1<ebx>);
signed int __cdecl sub_1003765C(int a1);
// signed int __usercall sub_1003769D<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned __int8 a4, int a5, unsigned __int8 a6);
// signed int __usercall sub_100376F3<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3);
int __cdecl sub_10037709(int a1, int a2, unsigned int a3);
int __cdecl sub_10038E81(int, int, DWORD dwCmpFlags, int, int, int, int, UINT CodePage); // idb
int __cdecl sub_100390EC(int a1, int a2);
// int __usercall sub_1003910C<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, DWORD dwCmpFlags, int a6, int a7, int a8, int a9, UINT CodePage);
int __stdcall sub_10039150(unsigned __int64 a1, __int64 a2);
void *__cdecl sub_100391F0(void *a1, unsigned __int8 a2, signed int a3);
int __cdecl sub_10039280(int a1, int a2);
int __cdecl sub_100392F0(int a1, int a2);
// signed int (__usercall *__usercall sub_1003937C<eax>(int a1<ebx>, int a2<edi>, int a3))<eax>(int<edi>, int, int, unsigned int, int, int, int);
signed int (__usercall *__cdecl sub_10039393())<eax>(int<edi>, int, int, unsigned int, int, int, int);
int __cdecl sub_100393F3(int a1);
int __cdecl sub_1003940A(int a1);
HANDLE __stdcall sub_10039421(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, int a5, int a6);
int __cdecl sub_1003944A(int a1, int a2, int a3);
int __cdecl sub_1003946B(int a1, int a2, int a3);
DWORD __cdecl sub_1003948C(int a1);
BOOL __cdecl sub_100394AA(DWORD a1);
LPVOID __cdecl sub_100394C9(DWORD a1);
BOOL __cdecl sub_100394E8(DWORD a1, void *a2);
int __cdecl sub_1003950A();
int __cdecl sub_1003951A(int a1, int a2);
int __cdecl sub_10039534();
int __cdecl sub_10039546(int a1, int a2);
int __cdecl sub_1003956C(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, int); // idb
char __cdecl sub_1003959A();
int __cdecl sub_10039817(int a1, int a2, int a3, int a4);
int __cdecl sub_10039837(int a1, int a2, int a3);
int __cdecl sub_10039854(UINT uExitCode); // idb
LONG __cdecl sub_10039869(struct _EXCEPTION_POINTERS *ExceptionInfo);
int __cdecl sub_1003987F(int a1, int a2);
int __cdecl sub_10039899(int a1);
// int __usercall sub_100398B2<eax>(int a1<ebx>, int a2<edi>, int a3, int a4);
// int __usercall sub_100399F3<eax>(int a1<ebx>, int a2<edi>, int a3);
__int64 __stdcall sub_10039A20(__int64 a1, __int64 a2);
__int64 __stdcall sub_10039A60(unsigned __int64 a1, unsigned int a2, unsigned int a3);
int __cdecl sub_10039AC8(int a1);
int __cdecl sub_10039AFD(int a1);
int __cdecl sub_10039B4B(int, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2); // idb
int __cdecl sub_10039B97(int a1, int a2, int a3);
int __cdecl sub_10039C13(int a1);
int __stdcall LocaleEnumProc(int a1);
BOOL __cdecl sub_10039C51(int (__stdcall *a1)(_DWORD, _DWORD, _DWORD), int a2, int a3);
int __cdecl sub_10039C8E(int a1, LCTYPE a2, WCHAR *a3, int a4);
int __cdecl sub_10039CBD(int a1, int a2);
BOOL __cdecl sub_10039CE8(int a1);
int __cdecl sub_10039D13(int, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest); // idb
int __cdecl sub_10039D5F(int a1, unsigned __int16 *a2, int a3);
int __cdecl sub_10039DCD(int a1, DWORD dwMapFlags, LPCWSTR lpSrcStr, unsigned int cchSrc, LPWSTR lpDestStr, int cchDest);
double sub_10039E00(void); // weak
double __cdecl sub_10039E1D(_DWORD, _DWORD); // weak
int __cdecl sub_10039EBA();
// void __usercall sub_10039FF6(int a1<ebx>, int a2<edi>, int a3<esi>, int a4, int a5, int a6);
void *__cdecl sub_1003A119(void *a1);
// int __usercall sub_1003A126<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6, int a7);
// int __usercall sub_1003A151<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1003A161<eax>(int a1<ebx>, int a2<edi>);
int *__cdecl sub_1003A18C();
int *__cdecl sub_1003A192();
int *__cdecl sub_1003A198();
void **__cdecl sub_1003A19E();
// signed int __usercall sub_1003A1A4<eax>(int a1<ebx>, int a2<edi>, int a3);
// signed int __usercall sub_1003A1CE<eax>(int a1<ebx>, int a2<edi>, int a3);
// signed int __usercall sub_1003A1F8<eax>(int a1<ebx>, int a2<edi>, int a3);
signed int __cdecl sub_1003A222(int a1, int a2);
// void __usercall sub_1003A49A(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// void __usercall sub_1003A4EA(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// char __usercall sub_1003A530<al>(int a1<edi>, int a2);
// void __usercall sub_1003A714(int a1<edx>, int a2<ecx>, int a3<edi>);
int __stdcall sub_1003AC40(unsigned __int64 a1, unsigned int a2, int a3);
int __stdcall sub_1003ACF0(unsigned __int64 a1, __int64 a2);
bool __cdecl sub_1003ADA2(int a1);
void *__cdecl sub_1003ADC8(void *a1);
// signed int __usercall sub_1003ADD5<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
int (__stdcall *__thiscall sub_1003AE2A(HMODULE this, int a2))();
void __thiscall sub_1003AE5C(HMODULE this, UINT uExitCode);
// void __usercall sub_1003AE72(int a1<ebx>);
// void __usercall sub_1003AF82(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// void __usercall sub_1003AF9E(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_1003AFAE<eax>(int a1<eax>, int a2<ebx>, int a3<edi>, int a4);
// void __usercall sub_1003B03F(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, UINT uExitCode);
unsigned int __cdecl sub_1003B053();
void __cdecl sub_1003B08B(unsigned int a1, unsigned int a2);
int __cdecl sub_1003B0A7(unsigned int a1, unsigned int a2);
// void __usercall sub_1003B0C9(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
void __cdecl sub_1003B0D2();
// void __usercall sub_1003B0DB(int a1<edx>, int ecx0<ecx>, int ebx0<ebx>, int a4<edi>, UINT uExitCode, int a2, int a3);
// SIZE_T __usercall sub_1003B20A<eax>(int a1<ebx>, int a2<edi>, LPCVOID lpMem);
// _DWORD __cdecl _SEH_prolog4(_DWORD, _DWORD); weak
// int __stdcall _SEH_epilog4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_1003B2A0(PEXCEPTION_RECORD ExceptionRecord, int TargetFrame, int a3);
// void __usercall sub_1003B435(int a1<ebx>, int a2<edi>);
// void __usercall sub_1003B46D(int a1<ebx>, int a2<edi>);
// void __usercall sub_1003B4A1(int a1<ebx>, int a2<edi>);
PVOID __cdecl sub_1003B4B4();
int __cdecl sub_1003B4C5();
DWORD __cdecl sub_1003B577(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent);
int __cdecl sub_1003B59E(int a1);
// int __usercall sub_1003B5B4<eax>(int a1<ebx>, int a2);
int __cdecl sub_1003B64F(int, int); // weak
signed int __cdecl sub_1003B709(int a1, int a2);
signed int __cdecl sub_1003B756(HANDLE hThread, DWORD_PTR *a2);
int __thiscall sub_1003B78E(int this, int a2);
int __thiscall sub_1003B7AF(_DWORD); // weak
// int __userpurge sub_1003B8A9<eax>(int a1<ecx>, int a2<ebx>, int a3);
int sub_1003B8C4(); // weak
// int __usercall sub_1003B8CE<eax>(int a1<ebp>);
int loc_1003B98E(); // weak
int __thiscall sub_1003B995(int this, char a2);
int __thiscall sub_1003B9E3(int this, int a2);
unsigned int __thiscall sub_1003BA1C(int this, unsigned int a2, unsigned int a3, unsigned int a4);
int __thiscall sub_1003BAEC(int this, int a2);
int __cdecl sub_1003BB0F(int a1);
int __cdecl sub_1003BB3E(int a1);
signed int __thiscall sub_1003BB65(DWORD_PTR *this, HANDLE hThread);
// int __usercall sub_1003BB77<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
// void __usercall sub_1003BC8E(int a1<ebx>);
int __thiscall sub_1003BCA9(void *this, int a2);
int __thiscall sub_1003BDB6(int this);
int __thiscall sub_1003BDD9(int this);
// int __usercall sub_1003BE06<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
void __thiscall sub_1003BF33(LPVOID lpParameter);
int __cdecl sub_1003BFA6(_DWORD); // weak
_DWORD __stdcall sub_1003BFAB(_DWORD); // weak
// int __usercall sub_1003C007<eax>(int a1<ebp>, int a2<edi>);
int __thiscall sub_1003C09C(int this, int a2, int a3);
int __thiscall sub_1003C109(int this);
int __thiscall sub_1003C122(int this, int a2);
// void __usercall sub_1003C15C(int a1<ecx>, int a2<ebx>);
int __thiscall sub_1003C474(int this);
char __thiscall sub_1003C4C1(int this);
void __thiscall sub_1003C66E(int this, int a2, char a3, char a4, int a5, unsigned int a6);
void __thiscall sub_1003C7A8(int this, int a2, int a3);
int __thiscall sub_1003C929(int this);
char *__thiscall sub_1003CB8B(int this, int a2, int a3, int a4, char a5);
char *__thiscall sub_1003CBF7(void *this, int a2, int a3, int a4, unsigned int a5);
int __stdcall StartAddress(int a1);
// int __usercall sub_1003CD78<eax>(int a1<ebp>);
int __thiscall sub_1003CE79(int this, int *a2, unsigned int *a3, int a4, int a5, unsigned int a6);
int __thiscall sub_1003D1BE(void *this, int a2, int a3, int a4);
char __thiscall sub_1003D2CA(void *this, int a2, int a3, int a4, unsigned int a5);
int __thiscall sub_1003D3D4(int this, __int16 a2);
BOOL __thiscall sub_1003D40F(DWORD this);
int __thiscall sub_1003D43F(int this);
// int __usercall sub_1003D443<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4<esi>);
// int __userpurge sub_1003D48E<eax>(int a1<ecx>, int a2<esi>, int a3);
int __thiscall sub_1003D5A6(int this);
int __thiscall sub_1003D5AD(int this);
int __thiscall sub_1003D5B4(int this);
int __thiscall sub_1003D5BB(int this);
int __thiscall sub_1003D5D2(int this);
int __thiscall sub_1003D5E9(int this, int a2);
int __thiscall sub_1003D60E(int this, int a2);
// int __usercall sub_1003D633<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4<esi>);
int __thiscall sub_1003D67E(int this);
int sub_1003D685(void); // weak
int __cdecl sub_1003D68A();
int sub_1003D68F(void); // weak
int __cdecl sub_1003D694();
// int __usercall sub_1003D6A2<eax>(int a1<ebx>, int a2);
unsigned int __thiscall sub_1003D6CB(int this, int a2, int a3);
int __thiscall sub_1003D7E4(void *this, int a2, int a3);
void __thiscall sub_1003D939(int this);
// char __userpurge sub_1003D96F<al>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, char a7);
// void *__userpurge sub_1003D9A8<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, unsigned __int16 a6, unsigned __int16 a7, void *a8, int a9, char a10);
void *__thiscall sub_1003DAC1(int this);
// void __usercall sub_1003DB83(int a1<ebx>, int a2<edi>, int a3<esi>, char a4);
int __thiscall sub_1003DDC2(int this);
// int __userpurge sub_1003DDDB<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, char a5);
int __thiscall sub_1003DF31(int this, int a2, int a3, int a4);
void *__thiscall sub_1003DFF7(int this);
void __fastcall sub_1003E107(int a1);
unsigned int __thiscall sub_1003E1D8(int this);
unsigned int __thiscall sub_1003E207(void *this, unsigned int a2);
unsigned int __thiscall sub_1003E436(int this, int a2, unsigned int a3, unsigned int a4, unsigned int a5);
int __thiscall sub_1003E809(void *this);
int __stdcall sub_1003E815(int a1, int a2);
// int __usercall sub_1003E868<eax>(int a1<ebp>);
unsigned int __thiscall sub_1003E8FF(int this, int a2, unsigned int a3, int a4);
char __thiscall sub_1003E954(int this, int a2, int a3, int a4);
int __thiscall sub_1003EA4A(int this, int a2);
// int __userpurge sub_1003EA80<eax>(int a1<ebp>, int a2);
// int __userpurge sub_1003EAF4<eax>(int a1<ebp>, int a2, int a3);
unsigned int __thiscall sub_1003EBFF(int this, int a2, unsigned int a3);
unsigned int __thiscall sub_1003EC33(int this, int a2, unsigned int a3, int a4);
int __thiscall sub_1003EE05(int this);
// DWORD __usercall sub_1003EE5C<eax>(int a1<esi>);
void __cdecl sub_1003EF44(int a1, unsigned int a2);
char __thiscall sub_1003F103(void *this);
int __thiscall sub_1003F122(void *this, int a2);
int __thiscall sub_1003F2F1(int this, int a2, char a3);
int __thiscall sub_1003F3BF(int this, int a2);
// int __userpurge sub_1003F478<eax>(int a1<ebp>, int a2);
int __thiscall sub_1003F4C9(int this, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_1003F536<eax>(int a1<ebp>, int a2<esi>);
// int __usercall sub_1003F580<eax>(unsigned int a1<eax>, int a2<ecx>, char a3);
// void *__usercall sub_1003F5AC<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
wchar_t *__cdecl sub_1003F5E5(int a1);
// void *__usercall sub_1003F609<eax>(int a1<ebx>, int a2);
signed int __cdecl sub_1003F7C4(int a1, int a2, int a3, LCTYPE a4, LPVOID *a5);
void *__cdecl sub_1003F99B(void *a1);
// void __usercall sub_1003F9A8(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
int __cdecl sub_1003FA19(int a1);
int __cdecl sub_1003FA40(int a1);
void __thiscall sub_1003FA4E(int this, int a2);
_DWORD __stdcall loc_1003FA66(_DWORD); // weak
char __thiscall sub_1003FB01(int this, char a2);
int sub_1003FB0E(); // weak
int sub_1003FC50(); // weak
// void (__usercall *__usercall sub_1003FD7A<eax>(int a1<ebp>, int a2<edi>))(int<ebp>);
// void __usercall sub_1003FD9D(int a1<ebp>);
// void (__usercall *__usercall sub_1003FDD3<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>))(int<ebp>);
// int (__usercall *__usercall sub_1003FDEF<eax>(int a1<ebp>, int a2<edi>))<eax>(int<ebp>);
// int __usercall sub_1003FE12<eax>(int a1<ebp>);
int loc_1003FE24(); // weak
int __thiscall sub_1003FF15(int this, int a2);
signed int __thiscall sub_1003FF3B(int this, int a2);
char __thiscall sub_1003FF63(int this);
int __thiscall sub_1003FF8B(int this);
// int __usercall sub_1003FFB6<eax>(int a1<ebx>, int a2<ebp>);
// int __usercall sub_10040025<eax>(int a1<ebx>, int a2<ebp>);
char __thiscall sub_10040095(int this);
int __fastcall sub_10040102(int a1, int a2, int a3);
int __fastcall sub_10040169(int a1, int a2, int a3);
// int __usercall sub_100401C8<eax>(int a1<ebp>);
char __thiscall sub_10040214(void *this);
bool __thiscall sub_1004026A(int this);
int __thiscall sub_10040280(int this, int a2);
int __thiscall sub_100402A4(void *this);
int __thiscall sub_100402DE(int this, int a2);
int __cdecl sub_10040302(int a1);
int __cdecl sub_10040313(int a1);
// int __userpurge sub_10040324<eax>(int a1<ebp>, int a2);
int __cdecl sub_10040403(int (__cdecl *a1)(_DWORD, _DWORD), int a2, int (__cdecl *a3)(_DWORD, _DWORD));
int __thiscall sub_1004040F(int this, char a2, int a3);
int __thiscall sub_10040475(void *this, char a2, int a3);
int __thiscall sub_10040503(int this, char a2);
// int __userpurge sub_100405AA<eax>(int a1<ebp>, int a2, int a3, int a4, int a5);
// int __userpurge sub_10040624<eax>(int a1<ebp>, int a2, int a3);
// int __userpurge sub_1004067D<eax>(int a1<ebp>, int a2, int a3, int a4);
_DWORD __stdcall sub_10040736(_DWORD, _DWORD, _DWORD, _DWORD); // weak
int __thiscall sub_100407A2(PSLIST_HEADER ListHead);
// int __usercall sub_10040819<eax>(int a1<ebp>);
// int __usercall sub_10040863<eax>(int a1<ebp>);
int __thiscall sub_100408C7(int this, int a2);
int __thiscall sub_100408F1(int this, int a2);
int __thiscall sub_10040A49(int this, int a2);
char __thiscall sub_10040BA5(void *this, int a2, char a3, int a4, int a5, int a6);
bool __cdecl sub_10040C88(int a1);
int __thiscall sub_10040C94(int this, int a2, int a3);
int __thiscall sub_10040CB9(void *this, int a2, int a3);
// int __usercall sub_10040D51<eax>(int a1<ebp>);
// char __userpurge sub_10040DC7<al>(int a1<ecx>, int i<edi>, int a3);
int __thiscall sub_10040EAC(int this, int a2);
int __thiscall sub_10040EF2(int this, int a2);
int __thiscall sub_10040F22(void *this, int a2, int a3);
int __thiscall sub_10040F74(int this);
int __thiscall sub_10040FD9(void *this, int a2, char a3);
int __thiscall sub_1004100C(void *this);
// int __userpurge sub_1004101C<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4);
bool __thiscall sub_10041066(int this);
bool __thiscall sub_1004106F(void *this);
// int __userpurge sub_1004107B<eax>(int a1<ecx>, int a2<edi>, int a3);
int __thiscall sub_100410A4(int this, int a2);
int __thiscall sub_100410B7(int this, int a2, int a3, int a4);
// int __userpurge sub_10041139<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned int a4, char a5);
int __thiscall sub_10041183(int this, int a2, char a3);
bool __thiscall sub_1004123C(void *this);
int __thiscall sub_1004128F(void *this);
int __thiscall sub_100412B0(void *this, int a2);
PSINGLE_LIST_ENTRY __thiscall sub_100412C9(void *this, int a2);
char __thiscall sub_100412EF(void *ListHead, int a2, signed int a3, char a4);
char __thiscall sub_100413E5(int this);
char __thiscall sub_10041408(int this);
int __thiscall sub_10041447(int this, int a2);
char __thiscall sub_1004146E(int this, int a2);
int __thiscall sub_100414B0(void *this, int a2, int a3, int a4);
int __thiscall sub_100414CE(void *this, int a2, int a3);
int __thiscall sub_100414E4(int this, int a2, int a3);
int __thiscall sub_10041610(int this, int a2);
// int __userpurge sub_10041636<eax>(int a1<ecx>, int a2<edi>, char a3);
// void __userpurge sub_100417E5(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, LPVOID lpMem);
// void __usercall sub_1004191C(int a1<ebx>, int a2<edi>, LPVOID lpMem);
// int __usercall sub_10041952<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1004196A<eax>(int a1<ebx>);
// void __usercall sub_100419D9(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
// signed int __usercall sub_10041A8C<eax>(int a1<ebx>);
void __cdecl sub_10041B02();
LONG __cdecl sub_10041B1F(volatile LONG *lpAddend);
void __cdecl sub_10041BAF(LPVOID lpMem);
volatile LONG *__cdecl sub_10041D09(volatile LONG *lpAddend);
// void __usercall sub_10041DA4(int a1<ebx>, int a2<edi>);
volatile LONG *__cdecl sub_10041E20(volatile LONG **a1, volatile LONG *lpAddend);
// int __usercall sub_10041E6B<eax>(int a1<ebx>);
wchar_t *__cdecl sub_10041E89(int a1);
// UINT __usercall sub_10041EC3<eax>(int a1<ebx>, int a2<edi>, UINT a3);
int __cdecl sub_10041F2F(int a1);
char __cdecl sub_10041F98(int a1);
// void __usercall sub_10042126(int a1<ebx>, int a2<edi>);
// void __usercall sub_100421CB(int a1<ebx>, UINT a2);
// signed int __usercall sub_10042379<eax>(int a1<ebx>, int a2<edi>, UINT a3, int a4);
// int __usercall sub_1004256E<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4, int a5);
// int __usercall sub_1004261D<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3, int a4);
// int __usercall sub_10042653<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3);
// void __usercall sub_10042664(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
int __cdecl sub_100426B6(int a1);
// void __usercall sub_1004271A(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6);
int __cdecl sub_10042788(int, int); // weak
void __cdecl sub_100428B2(void *lpAddend, const void *a2);
int __cdecl sub_100428DE(int a1, int a2, int a3, int a4, int a5, int a6);
void __fastcall sub_10042BD3(int a1, int a2, int a3, int a4, int a5);
// void __usercall sub_10042C12(int a1<edi>, unsigned int a2, int a3);
// int __usercall sub_10042D8F<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
int __fastcall sub_10042F03(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_1004318A(int a1, int a2, int a3);
void __cdecl sub_10043522();
// signed int __usercall sub_1004352A<eax>(int a1<edx>, int a2<ebx>, int a3, unsigned int *a4, void **a5, const void *a6, int a7);
// int __usercall sub_10043589<eax>(int a1<edi>, unsigned __int8 a2);
// signed int __usercall sub_100435AA<eax>(int a1<edx>, int a2<ebx>, int a3);
signed int __cdecl sub_100435CC(int a1, int a2, int a3, int a4);
// int __usercall sub_100446BA<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4, int a5);
// signed int __usercall sub_100446E8<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3, int a4);
// int __usercall sub_10044835<eax>(int a1<ebx>, int (__cdecl *a2)(_DWORD, _DWORD, _DWORD, _DWORD), int a3, unsigned int a4, int a5, int a6, int a7);
// int __usercall sub_100448FD<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned int a4, int a5, int a6, int a7);
bool __cdecl sub_10044972();
void __cdecl sub_10044987();
// signed int __usercall sub_1004498F<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6);
// int __usercall sub_10044A4D<eax>(int a1<ebx>, int a2, int a3, char a4);
// int __userpurge sub_10044A6B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, const void **a5);
// int __userpurge sub_10044A91<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10044AAC<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10044AC7<eax>(int a1<ecx>, int a2<ebx>, int a3);
int __thiscall sub_10044AE2(LPVOID *this);
void **__thiscall sub_10044AEB(void **this, const void **a2);
int __thiscall sub_10044B09(void *this, unsigned int a2);
char __thiscall sub_10044B3F(void *this);
char __cdecl sub_10044B5D(unsigned int a1, unsigned int a2);
// int __userpurge sub_10044B7B<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4);
int __stdcall loc_10044BE8(int, int); // weak
// void __userpurge sub_10044C4C(int a1<ebp>, int a2, int a3);
int __thiscall sub_10044C5B(void *this);
char *__cdecl sub_10044CA3(unsigned int a1);
char __cdecl sub_10044CBA(int a1, signed int a2);
int __thiscall sub_10044D76(void *this);
_DWORD loc_10044DBF(); // weak
int __thiscall sub_10044E10(int this);
// int __usercall sub_10044E27<eax>(int a1<ebp>);
void *__thiscall sub_10044E72(void *this, char a2);
char __thiscall sub_10044E91(int this, unsigned int a2);
int __thiscall sub_10044EC8(void *this, int a2);
char __thiscall sub_10044F05(int this);
bool __cdecl sub_10044F49(int a1);
char __thiscall sub_10044F55(int this, int a2, int a3, char a4);
signed int __thiscall sub_10044FFA(int this, int a2);
int __thiscall sub_1004501F(int this);
int __stdcall sub_1004502B(int a1);
int __thiscall sub_1004504F(int this);
char __thiscall sub_1004505B(int this, int a2, int a3, int a4);
char __thiscall sub_100450CF(int this, int a2);
// int __usercall sub_100450FA<eax>(int a1<ecx>, int a2<ebp>, int a3<edi>);
int __thiscall sub_10045113(int this, int a2, int a3);
int __thiscall sub_10045250(int this, unsigned int a2);
int __thiscall sub_10045292(int this, unsigned int a2);
int __thiscall sub_100452D8(int this, int a2, char a3);
char __thiscall sub_10045356(int this);
int __thiscall sub_100453AA(int this);
signed int __thiscall sub_100453CD(int this);
char __thiscall sub_1004541B(void *ListHead, int a2, signed int a3, char a4);
char __thiscall sub_10045516(int this);
char __thiscall sub_10045659(int this);
int __thiscall sub_1004566D(void *this, int a2);
int __thiscall sub_100456A7(int this, unsigned int a2);
int __thiscall sub_100456EF(int this, unsigned int a2);
char __thiscall sub_10045737(int this, int a2, int a3);
int __cdecl sub_100457C0(char a1, char a2, int a3, int a4);
int __stdcall sub_10045831(int a1);
int __stdcall sub_1004583B(char a1, char a2, int a3, int a4);
char __thiscall sub_10045868(int this, char a2, char a3);
int __thiscall sub_100458C6(int this);
int __thiscall sub_100458E3(void *ListHead, int a2, signed int a3, int a4);
// int __userpurge sub_100459D4<eax>(int a1<ebp>, int a2, int a3, int a4);
int __thiscall sub_10045A51(PSLIST_HEADER ListHead);
// int __usercall sub_10045AC7<eax>(int a1<ebp>);
int __thiscall sub_10045B07(int this, int a2);
int __thiscall sub_10045C60(void *this, int a2, char a3);
int __thiscall sub_10045D49(int this, int a2);
int __thiscall sub_10045D86(void *this, int a2);
char __thiscall sub_10045DE3(void *this, int a2, int a3, int a4, int a5, int a6, int a7);
int __thiscall sub_10045E53(void *this, int a2);
// int __userpurge sub_10045E77<eax>(int a1<ebp>, int a2);
int __thiscall sub_10045EB7(void *this, char a2);
void *__thiscall sub_10045F35(void *this, int a2);
// int __userpurge sub_10045FA8<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10045FC3<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10045FDE<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_10045FF9<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __usercall sub_10046014<eax>(int a1<ebp>);
void *__thiscall sub_1004604F(void *this, char a2);
char __thiscall sub_10046076(void *this, char a2, int a3, int a4, int a5);
// int __userpurge sub_100461EF<eax>(int a1<ebp>, int a2);
int __thiscall sub_10046240(void *this);
char __thiscall sub_10046364(int this);
// void __usercall sub_100463D6(int a1<ecx>, int a2<ebp>);
// int __usercall sub_100463EE<eax>(int this<ecx>, int a2<ebp>);
// int __userpurge sub_10046409<eax>(int a1<ebp>, int a2);
int __thiscall sub_1004657D(int this, int a2);
// char __usercall sub_100465BA<al>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_10046624(int this, int a2, int a3);
// int __userpurge sub_10046726<eax>(int a1<ecx>, int a2<edi>, int a3);
int __thiscall sub_10046752(int this, int a2);
int __thiscall sub_10046780(int this);
int __thiscall sub_10046784(int this);
int __thiscall sub_1004678C(int this);
int __thiscall sub_10046793(int this);
signed int __thiscall sub_1004679B(void *this);
int __thiscall sub_100467C7(void *this, int a2, int a3, int a4);
bool __thiscall sub_1004692E(int this);
// char __usercall sub_1004693A<al>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_10046998(void *this);
void __thiscall sub_10046A6E(int this, char a2);
int __thiscall sub_10046AE2(int this, int a2, int a3, char a4);
int __thiscall sub_10046B4B(int this, int a2);
int __thiscall sub_10046B62(int this, int a2);
void __thiscall sub_10046BA3(int this);
int __thiscall sub_10046BF2(void *this);
// void __usercall sub_10046C11(int a1<ecx>, int a2<ebp>);
int __thiscall sub_10046C34(int this, int a2);
char __thiscall sub_10046C74(int this);
char __cdecl sub_10046C9F(int a1, int a2);
int __thiscall sub_10046CCC(void *this);
void __thiscall sub_10046D5C(int this, int a2, char a3);
char __thiscall sub_10046DAD(int this, int a2);
int __thiscall sub_10046E99(int this, int a2, int a3);
int __fastcall sub_10046F90(int a1);
int __thiscall sub_10047034(int this);
char __thiscall sub_10047124(int this, int a2);
int __thiscall sub_1004718B(void *this);
// int __userpurge sub_100472C6<eax>(int a1<ebp>, int a2, int a3);
int __thiscall sub_1004734C(PSLIST_HEADER ListHead);
// int __usercall sub_100473C2<eax>(int a1<ebp>);
int __thiscall sub_100473F5(int this);
bool __cdecl sub_10047427(int a1);
int __stdcall sub_10047433(int a1);
char __thiscall sub_10047457(void *ListHead, int a2, signed int a3, char a4);
char __thiscall sub_10047552(void *this, int a2);
int __thiscall sub_1004757B(int *this, int a2, int a3);
// int __userpurge sub_100475CB<eax>(int a1<ecx>, int a2<edi>, int a3, int a4);
int __thiscall sub_1004761E(int this, int a2);
int __thiscall sub_10047651(int this, int a2);
// int __userpurge sub_10047689<eax>(int a1<ecx>, int a2<edi>, int a3, int a4, int a5, int a6);
// int __userpurge sub_100476AF<eax>(int a1<ecx>, int a2<edi>, int a3, int a4);
int __thiscall sub_100476C7(int this);
bool __thiscall sub_100476FA(void *this, int a2);
int __thiscall sub_10047738(int this, int a2, int a3);
int __thiscall sub_1004775E(int this, int a2);
int __thiscall sub_1004776D(int this, int a2, int a3);
int __thiscall sub_10047799(int this, int a2, char a3);
// int __userpurge sub_100477FF<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4);
// int __usercall sub_100478C5<eax>(int a1<ebp>);
void *__thiscall sub_100478F2(void *this, char a2);
// int __userpurge sub_10047911<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4);
DWORD __thiscall sub_10047932(int this);
// int __usercall sub_1004796C<eax>(int a1<ecx>, int a2<ebp>);
// char __userpurge sub_100479C4<al>(void *this<ecx>, int edi0<edi>, int a2);
// int __usercall sub_100479E9<eax>(int a1<ecx>, int a2<ebp>, int a3<edi>);
signed int __cdecl sub_10047A0B();
int __stdcall sub_10047A0F(int a1, int a2, int a3, int a4);
char __stdcall sub_10047A31(int a1, int a2);
bool __thiscall sub_10047A54(int this);
void __thiscall sub_10047A60(int this, char a2);
DWORD __thiscall sub_10047A97(int Context, char a2);
// BOOL __usercall sub_10047B64<eax>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_10047B86(void *this);
int __thiscall sub_10047B8B(void *this);
void *__thiscall sub_10047C21(void *this, int a2);
void *__thiscall sub_10047C43(void *this, int a2);
int __thiscall sub_10047C70(int this);
void __stdcall sub_10047C84(int a1);
void *__thiscall sub_10047C8C(void *this, char a2);
int __stdcall loc_10047C94(int); // weak
int __thiscall sub_10047CDF(void *this, int a2, unsigned int a3);
// int __usercall sub_10047CEB<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __usercall sub_10047D1E<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>);
// int __userpurge sub_10047D5C<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5);
signed int __cdecl sub_10047D94();
int __thiscall sub_10047D98(void *this);
// int __userpurge sub_10047D9C<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// int __userpurge sub_10047DB6<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
int __thiscall sub_10047DC1(void *this, int a2, unsigned int a3);
int __thiscall sub_10047DCD(void *this, int a2, int a3, int a4);
DWORD __cdecl sub_10047DD9();
BOOL __cdecl sub_10047E1D();
// signed int __usercall sub_10047E31<eax>(int a1<ecx>, int a2<ebx>);
// void __usercall sub_10047EA4(int a1<edx>, int a2<ecx>, int a3<ebx>);
void **__cdecl sub_10047ECB();
// void __usercall sub_10047ED1(int a1<edx>, int a2<ebx>, int a3<edi>, unsigned int a4);
// void __usercall sub_10047F10(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5, int a6);
void __cdecl sub_10047F40(unsigned int a1);
void __cdecl sub_10047F7A(signed int a1, int a2);
// void __usercall sub_10047FA7(int a1<ebx>, int a2<edi>, int edx0<edx>, int a4<ecx>, int a3);
signed int __cdecl sub_10047FED(int a1);
// void __usercall sub_10048051(int a1<edx>, int a2<ecx>, int a3<ebx>);
// void __usercall sub_1004805A(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
// int __usercall sub_100481B5<eax>(int a1<ebx>, int a2, int a3);
// int __usercall sub_10048310<eax>(int a1<ebx>, int a2, int a3);
// void __usercall sub_1004832E(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// void __usercall sub_100485DC(int a1<ebx>);
// signed int __usercall sub_1004862E<eax>(int a1<ebx>);
int __cdecl sub_100486DF(int a1, int a2, int a3, int a4, int a5);
// signed int __usercall sub_1004885B<eax>(int a1<ecx>, int a2<ebx>);
signed int __cdecl sub_1004893C();
// int __usercall sub_100489D6<eax>(int a1<ebx>);
void __cdecl sub_10048A61();
void __cdecl sub_10048A81();
// void __userpurge sub_10048AB0(int a1<ebp>, int a2<edi>, int a3<esi>, int a4, int a5, int a6);
int __cdecl sub_10048AFC(int a1);
int __cdecl sub_10048B0B(LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int cchWideChar, int); // idb
int __cdecl sub_10048C6A(int, LPWSTR lpWideCharStr, int cchWideChar, LPCSTR lpMultiByteStr, int, int); // idb
int __cdecl sub_10048D46(int, LPWSTR lpWideCharStr, int cchWideChar, LPCSTR lpMultiByteStr, int); // idb
signed int __cdecl sub_10048D64(CHAR *a1, int lpWideCharStr, int cbMultiByte, int a4);
// signed int __usercall sub_10048FC9<eax>(int a1<ebx>, int a2, CHAR *a3, int cbMultiByte, int lpWideCharStr, int a6, int a7);
// LPVOID __usercall sub_10049092<eax>(void *a1<ecx>, int a2<ebx>, unsigned int a3, unsigned int a4);
// signed int __usercall sub_100490D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, int a7);
int __cdecl sub_1004912C(int, DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, int); // idb
// int __usercall sub_10049218<eax>(int a1<ebx>, int a2<edi>, int a3, DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, int a9);
// int __usercall sub_10049256<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, const void *lpMem, unsigned int a5, unsigned int a6);
// LPVOID __usercall sub_100492BF<eax>(void *this<ecx>, int ebx0<ebx>, unsigned int a2, unsigned int a3, int a4);
PVOID __cdecl sub_10049401();
int __cdecl sub_1004940E(int a1);
void __cdecl sub_1004942A(int a1);
unsigned int __cdecl sub_100495DF(int a1, unsigned int a2);
int __cdecl sub_1004961B(double); // idb
int __cdecl sub_100496B7(double, int); // idb
double __cdecl sub_10049789(double a1, __int16 a2);
signed int __cdecl sub_100497B4(int a1, int a2);
int __cdecl sub_10049810(char a1);
double __cdecl sub_10049842(char, _DWORD, _DWORD); // weak
bool __cdecl sub_1004990A(signed int a1, double a2);
// double __usercall sub_10049AE6<st0>(__int16 a1<cx>, int a2<ebx>, int a3, double a4);
int __cdecl sub_10049B36(ULONG_PTR Arguments, int a2, char a3, int a4, int a5, int a6);
int __cdecl sub_10049B57(ULONG_PTR Arguments, int a2, char a3, int a4, int a5, int a6, int a7);
// int __usercall sub_10049E3C<eax>(int a1<ebx>, int a2);
// double __usercall sub_10049E69<st0>(int a1<ebx>, int a2, int a3, int a4, int a5, int a6, int a7, double a8);
int __cdecl sub_10049F07(int a1);
int __thiscall sub_10049F7D(int (*this)(void));
int __fastcall sub_10049F8C(__int16 a1);
void __cdecl sub_10049FB5();
int __thiscall sub_1004A00B(int (*this)(void));
// signed int __usercall sub_1004A019<eax>(int a1<edi>, int a2, int a3, unsigned int a4, int a5, int a6, int a7);
// signed int __usercall sub_1004A03A<eax>(int a1<edi>, int a2, int a3, unsigned int a4, int a5, int a6, int a7, int a8);
// signed int __usercall sub_1004A0C0<eax>(int a1<edi>, int a2, int a3, unsigned int a4, int a5, int a6, int a7);
signed int __cdecl sub_1004A41A(int a1, int a2, unsigned int a3, int a4, int a5);
// int __usercall sub_1004A438<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned int a4, int a5, int a6, int a7, char a8, int a9);
signed int __cdecl sub_1004A587(int a1, int a2, unsigned int a3, int a4, int a5, int a6);
// signed int __usercall sub_1004A653<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6, char a7, int a8);
signed int __cdecl sub_1004A73D(int a1, int a2, int a3, int a4, int a5);
signed int __cdecl sub_1004A7FC(int a1, int a2, unsigned int a3, int a4, int a5, int a6);
// char __usercall sub_1004A8F9<al>(int a1<ebx>, int a2<edi>, int a3);
// char __usercall sub_1004A90A<al>(int a1<ebx>, int a2<edi>, int a3, int a4);
// int __usercall sub_1004A988<eax>(int a1<ebx>, int a2, int a3, int a4);
// int __usercall sub_1004A9A0<eax>(int a1<ebx>, int a2, int a3, int a4, int a5);
// char __usercall sub_1004A9E0<al>(int a1<ebx>, int a2<edi>, int *a3);
// char __usercall sub_1004A9F1<al>(int a1<ebx>, int a2<edi>, int *a3, int a4);
bool __cdecl sub_1004AA63(int a1);
void __cdecl sub_1004AA7D(int a1, int a2);
// signed int __usercall sub_1004AAA5<eax>(int a1<ebx>, int a2<edi>);
int (*__cdecl sub_1004AACC())();
// int __usercall sub_1004AAEB<eax>(int a1<ebx>, int a2<edi>, int a3, const WCHAR *a4);
// int __usercall sub_1004AB7E<eax>(int a1<ebx>, int a2<edi>, int a3, const WCHAR *a4, int a5);
unsigned int __cdecl sub_1004AC57(int a1, unsigned int a2);
// int __usercall sub_1004AC80<eax>(int a1<edx>, __int16 a2<cx>, int a3<ebp>, __int16 a4<fpstat>, double _ST7<st0>, char a6, char a7, char a8);
// int __usercall sub_1004ACE7<eax>(int a1<edx>, int a2<ebp>, __int16 a3<fpstat>, double _ST6<st1>, double a5<st0>, char a6, char a7, char a8);
int loc_1004AD86(); // weak
double __cdecl sub_1004AD8D();
// double __usercall sub_1004AD92<st0>(int a1<ebp>, double a2<st0>);
// void __usercall sub_1004AE39(int a1<ebp>);
void __cdecl sub_1004AE50();
// double __usercall sub_1004AE67<st0>(int a1<eax>, int a2<edx>, int a3<ecx>, double a4<st0>, __int16 a5, int a6, int a7, int a8);
int __cdecl loc_1004AE70(__int16, int, int, int); // weak
double __cdecl sub_1004AEC5(_DWORD); // weak
// double __usercall sub_1004AEDC<st0>(int a1<eax>, double result<st0>);
double __fastcall sub_1004AEF5(int a1, int a2);
int __cdecl sub_1004AF38(int a1, int a2);
// int __usercall sub_1004B03C<eax>(int a1<ebx>, int a2<edi>, int a3);
// int __usercall sub_1004B050<eax>(int a1<ebx>, int a2);
int __cdecl sub_1004B0E0(int a1, unsigned int a2);
// unsigned int __usercall sub_1004B130<eax>(int a1<eax>, int a2);
char __cdecl sub_1004B1F0(int a1);
int __cdecl sub_1004B221(int a1);
// int __usercall sub_1004B230<eax>(int a1<ebp>, int a2, int a3, unsigned int a4);
int __cdecl loc_1004B2C0(int, int, int, int); // weak
int __thiscall sub_1004B322(void *this);
int __fastcall sub_1004B339(int a1, int a2);
void __fastcall sub_1004B352(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord);
int __fastcall loc_1004B366(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord); // weak
int __fastcall sub_1004B36B(int a1, unsigned int a2, int a3, int a4);
int __thiscall sub_1004B382(int this, int a2, int a3, int a4);
int __thiscall sub_1004B3E9(int this, int a2, int a3);
int __thiscall sub_1004B448(int this);
void __thiscall sub_1004B45A(int this);
int __thiscall sub_1004B4C5(int this);
int __thiscall sub_1004B4C9(int this);
BOOL __thiscall sub_1004B4CD(int lpTlsValue);
int __thiscall sub_1004B599(int this, int a2);
BOOL __thiscall sub_1004B605(int this);
BOOL __thiscall sub_1004B620(LPVOID lpTlsValue);
unsigned int __cdecl sub_1004B642(unsigned int a1);
double __cdecl sub_1004B65A(double a1);
int __thiscall sub_1004B690(int this, int a2, unsigned int a3, int a4);
int __thiscall sub_1004B71A(int this, double a2, int a3);
double __stdcall sub_1004B73D(unsigned int a1, unsigned int a2, int a3, int a4);
double __thiscall sub_1004B778(void *this, int a2, int a3);
double __thiscall sub_1004B830(int this);
int __thiscall sub_1004B867(int this, int a2);
__int64 __fastcall sub_1004B8AC(int a1);
int __thiscall sub_1004B8F0(void *this, int a2);
bool __thiscall sub_1004B91B(int this);
char __stdcall sub_1004B934(int a1);
double __fastcall sub_1004B964(int a1);
int __thiscall sub_1004B984(int this, unsigned int a2);
int __thiscall sub_1004BA54(int this, int a2, unsigned int a3, int a4, int a5);
double __fastcall sub_1004BC13(int a1);
_DWORD __stdcall sub_1004BC5F(_DWORD, _DWORD, _DWORD); // weak
int sub_1004BEB5(void); // weak
char *__thiscall sub_1004BEFE(int this, int a2, int a3, char a4);
_DWORD __stdcall sub_1004BFB6(_DWORD); // weak
int __thiscall sub_1004C00E(int this, int a2);
int __thiscall sub_1004C047(int this, int a2);
_DWORD __stdcall sub_1004C056(_DWORD, _DWORD); // weak
int __thiscall sub_1004C0EA(void *this, int a2);
int __thiscall sub_1004C15A(void *this, int a2);
int __thiscall sub_1004C1AD(void *this);
// int __userpurge sub_1004C269<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4);
// int __userpurge sub_1004C36C<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5);
int __thiscall sub_1004C3A4(int this, int a2);
int __thiscall sub_1004C3FC(int this, int a2, int a3, char a4);
int __thiscall sub_1004C477(void *this);
int __thiscall sub_1004C48C(int this, int a2);
_DWORD __stdcall sub_1004C518(_DWORD); // weak
int __thiscall sub_1004C584(void *this);
LPVOID __thiscall sub_1004C594(int this);
// int __userpurge sub_1004C5B1<eax>(int a1<ecx>, int a2<ebx>, int a3);
// int __userpurge sub_1004C5F1<eax>(int a1<ebp>, int a2);
int __thiscall sub_1004C63F(int this, unsigned int a2, int a3, char a4);
int __thiscall sub_1004C91D(int this, int a2);
int __thiscall sub_1004C979(int this, int a2, int a3, char a4);
// int __usercall sub_1004C9FB<eax>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_1004CA81(int this, int a2);
// int __userpurge sub_1004CAB7<eax>(int a1<ebp>, int a2, int a3);
int __thiscall sub_1004CB86(void *this, void *a2);
int __thiscall sub_1004CBAF(int this, int a2);
_DWORD __stdcall sub_1004CBC2(_DWORD, _DWORD); // weak
int __thiscall sub_1004CC87(int this);
// int __usercall sub_1004CC91<eax>(int a1<ecx>, int a2<ebp>);
int __thiscall sub_1004CC9B(int this, int a2, int a3);
int __stdcall sub_1004CCD0(int a1);
int __cdecl sub_1004CD16(int a1);
_DWORD __cdecl loc_1004CDC5(_DWORD); // weak
int __cdecl sub_1004CDDB();
int __thiscall sub_1004CDE9(int this, int a2);
void *__thiscall sub_1004CE1C(void *this, int a2, int a3);
int __thiscall sub_1004CE4D(int this, int a2);
// int __usercall sub_1004CE73<eax>(int a1<ebp>);
// int __usercall sub_1004CED6<eax>(int a1<ebp>);
void *__thiscall sub_1004CF1D(void *this, char a2);
void *__thiscall sub_1004CF42(void *this, char a2);
// int __userpurge sub_1004CF62<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4);
// int __usercall sub_1004CF97<eax>(int a1<ebx>, int a2<edi>, int a3);
int __thiscall sub_1004CFBB(int this);
// int __usercall sub_1004CFBF<eax>(int a1<ebx>, int a2<ebp>);
int __stdcall sub_1004D004(int, int nPriority); // idb
__int16 __thiscall sub_1004D01C(void *this, int a2);
void __thiscall sub_1004D075(int this, int a2);
int __thiscall sub_1004D106(void *this);
int __thiscall sub_1004D112(void *this);
int __thiscall sub_1004D12F(void *this, unsigned int a2, int a3);
BOOL __stdcall sub_1004D19D(int a1);
PSINGLE_LIST_ENTRY __thiscall sub_1004D1AC(void *this);
int __thiscall sub_1004D202(int this);
void __cdecl sub_1004D216();
// double __usercall sub_1004D276<st0>(double<st0>); weak
// int __usercall sub_1004D2F0<eax>(unsigned int a1<eax>, int a2<ecx>);
// signed int __usercall sub_1004D31B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6);
// signed int __usercall sub_1004D387<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5);
int __cdecl sub_1004D3C7(const WCHAR *a1, int a2, int a3);
// int __usercall sub_1004D5A9<eax>(int a1<edi>, int a2, int a3, LCTYPE a4, LPSTR lpMultiByteStr, int cbMultiByte);
// int __usercall sub_1004D681<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, LCTYPE a5, LPSTR lpMultiByteStr, int cbMultiByte);
int __thiscall sub_1004D6B9(int this, int a2, int a3, int a4, int a5);
bool __thiscall sub_1004D6DE(int this, char a2);
char __thiscall sub_1004D709(int this, int a2);
char __thiscall sub_1004D750(int this, int a2);
// void __usercall sub_1004D798(int a1<ebx>, int a2);
signed int __cdecl sub_1004D894(int lpMem);
// void __usercall sub_1004DC36(int a1<ebx>, int a2);
int __thiscall sub_1004DC9D(int this, int lpMem);
// void __usercall sub_1004DEA5(int a1<ebx>, int a2);
signed int __thiscall sub_1004E225(int this, int a2);
int __cdecl sub_1004E2A1(int a1, int a2);
int __thiscall sub_1004EA92(void *this, const WCHAR SrcStr, __int16 a3);
int __cdecl sub_1004EAE4();
int __cdecl sub_1004EAE7(int a1, int a2);
int __cdecl sub_1004EB25(int a1, int a2);
int __cdecl sub_1004EB74(int a1, int a2, int a3);
int __cdecl sub_1004EBAA(int a1, int a2);
// int __usercall sub_1004EBEC<eax>(int a1<ebx>, int a2<edi>, int a3);
int __cdecl sub_1004EC63(int); // weak
BOOL __cdecl sub_1004ECD7(int a1);
int __cdecl sub_1004ED21(unsigned __int16 *a1);
// unsigned int __userpurge sub_1004ED53<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
// unsigned int __userpurge sub_1004EF71<eax>(int a1<ebx>, int a2, int a3, int a4);
// int __usercall sub_1004F022<eax>(int a1<ebx>, int a2<edi>, int a3, int a4);
int __cdecl sub_1004F0B7(int a1);
bool __cdecl sub_1004F101(int a1, int a2, int *a3);
// signed int __usercall sub_1004F16D<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
// unsigned int __userpurge sub_1004F32F<eax>(int a1<ebx>, int a2<edi>, int a3);
// int __usercall sub_1004F3DD<eax>(int a1<ebx>, int a2<edi>, int a3);
// BOOL __usercall sub_1004F41D<eax>(int a1<ebx>, int a2<edi>, int a3);
// int __usercall sub_1004F49A<eax>(int a1<ebx>, int a2<edi>, int a3);
int __cdecl sub_1004F4F3(unsigned __int16 *a1);
// signed int __userpurge sub_1004F51D<eax>(int a1<ebx>, int a2<edi>, int a3);
// signed int __userpurge sub_1004F710<eax>(int a1<ebx>, int a2<edi>, int a3);
int __cdecl sub_1004F7E9(int a1);
// int __usercall sub_1004F838<eax>(int a1<ebx>, int a2<edi>, int LCData, int a4);
signed int __cdecl sub_1004F8C3(__int16 a1);
// bool __usercall sub_1004F8E5<eax>(int a1<ebx>, int a2<edi>, int a3, int a4);
// signed int __usercall sub_1004F94D<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
// signed int __usercall sub_1004FB67<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
// signed int __usercall sub_1004FC88<eax>(int a1<ebx>, int a2<edi>, int a3);
// signed int __usercall sub_1004FCAC<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5);
// signed int __usercall sub_1004FD8C<eax>(int a1<edi>, LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int a4, int a5);
// signed int __usercall sub_1004FE7F<eax>(int a1<edi>, LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int a4);
// int __usercall sub_1004FE97<eax>(int a1<ebx>, int a2<edi>, signed int a3);
// void __usercall sub_1004FEEB(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, const void *a6, int nNumberOfBytesToWrite);
// int __usercall sub_1004FFCD<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<esi>, signed int a5, const void *a6, int nNumberOfBytesToWrite);
// void __usercall sub_100507F7(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, LARGE_INTEGER liDistanceToMove, DWORD dwMoveMethod);
// LARGE_INTEGER __usercall sub_100508F3<edx:eax>(int a1<ebx>, int a2<edi>, signed int a3, LARGE_INTEGER liDistanceToMove, DWORD dwMoveMethod);
// int __usercall sub_10050964<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
signed int __cdecl sub_100509AA(int a1, int a2, int a3, int a4);
// int __usercall sub_10051512<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3, int a4, int a5);
// int __usercall sub_10051558<eax>(int a1<ebx>, unsigned __int8 a2, int a3, int a4, int a5);
int __cdecl sub_10051584(unsigned __int8 *a1, int a2, int a3, int a4, int *a5);
bool __cdecl sub_100515FC();
int __cdecl sub_10051611(int, LPSTR UsedDefaultChar, int cbMultiByte, const WCHAR WideCharStr, int); // idb
int __cdecl sub_10051733(int a1, LPSTR UsedDefaultChar, int cbMultiByte, const WCHAR WideCharStr);
int __thiscall sub_1005174E(int this, int a2);
unsigned int __thiscall sub_10051774(int this, int a2);
// int __usercall sub_100517C5<eax>(int a1<ecx>, int a2<edi>);
int __thiscall sub_1005180E(int this, int a2);
char __thiscall sub_10051844(int this, int a2);
char __thiscall sub_10051862(int this, int a2, int a3, char a4);
int __thiscall sub_100518F9(int this, int a2, int a3);
int __thiscall sub_10051946(int this, int a2);
int __thiscall sub_10051981(int this, int a2);
char __stdcall sub_100519BF(int a1, int a2, char a3);
char __thiscall sub_10051A0F(void *this, int a2, int a3, char a4, int a5, char a6);
char __stdcall sub_10051A90(int a1, int a2);
char __thiscall sub_10051AC1(void *this, int a2, int a3, int a4, char a5);
// char __userpurge sub_10051B3C<al>(int a1<edi>, int a2, int a3, char a4, char a5);
char __thiscall sub_10051B8F(void *this, int a2, int a3, char a4, int a5, char a6);
int __thiscall sub_10051C1D(int this);
int __thiscall sub_10051C52(void *this, int a2);
char __thiscall sub_10051C71(void *this, int a2);
// char __userpurge sub_10051CA1<al>(int a1<edi>, int a2, int a3, char a4, unsigned int a5);
// char __userpurge sub_10051D0E<al>(int a1<edi>, int a2, int a3, char a4, unsigned int a5);
DWORD __thiscall sub_10051D7C(int this, int a2, int a3);
// bool __usercall sub_10051DD0<eax>(int a1<ecx>, int a2<edi>);
char __thiscall sub_10051E4E(void *this, int a2, int a3, char a4, unsigned int a5);
char __thiscall sub_1005210C(void *this, int a2, int a3, char a4, unsigned int a5);
char __thiscall sub_1005238B(void *this, int a2, int a3, int a4, char a5, int a6, unsigned int a7, char a8);
char __thiscall sub_10052484(void *this, int a2, int a3, int a4, int a5, int i, unsigned int a7, char a8);
char __thiscall sub_1005258A(void *this, int a2, int a3, int a4, char a5, int a6, unsigned int a7, char a8);
char __thiscall sub_10052686(void *this, int a2, int a3, int a4, unsigned int a5);
char __thiscall sub_10052799(void *this, int a2, int a3, int a4, unsigned int a5);
char __stdcall sub_100528A7(int a1, int a2, char a3);
char __stdcall sub_1005293B(int a1, int a2);
char __stdcall sub_100529A9(int a1, int a2, char a3);
int __thiscall sub_10052A41(int this, int a2);
int __thiscall sub_10052A5E(int this, int a2);
char __thiscall sub_10052A7B(void *this, int a2, int a3, int a4, char a5);
char __thiscall sub_10052B03(void *this, int a2, int a3);
char __thiscall sub_10052B45(void *this, int a2, int a3, int a4);
// int __usercall sub_10052BB1<eax>(int a1<ecx>, int a2<ebp>);
void __thiscall sub_10052BC8(void *this, int a2);
int __thiscall sub_10052C1D(int this);
// int __userpurge sub_10052C25<eax>(int a1<ebp>, int a2, int a3);
void *__thiscall sub_10052C5C(void *this, char a2);
// void __usercall sub_10052C81(int a1<edx>, int a2<ecx>, int a3<ebx>);
// void __usercall sub_10052D1E(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
int __cdecl sub_10052E30(int, int, int, int, int); // weak
// int __usercall sub_10052E75<eax>(int a1<ebp>, int a2, unsigned int a3);
void __cdecl sub_10052F1C();
// int __userpurge sub_10052F25<eax>(int result<eax>, int a2<ebp>, int a3);
int __stdcall loc_10052F30(int); // weak
// int __usercall sub_10052F44<eax>(int (*a1)(void)<eax>);
int __thiscall sub_10052F50(void *this, unsigned int a2, unsigned __int8 a3);
// signed int __usercall sub_10053087<eax>(int a1<ebx>, int a2, unsigned int a3, int a4, int a5);
// signed int __usercall sub_10053137<eax>(int a1<ebx>, int a2, int a3, int a4);
// signed int __usercall sub_100531C3<eax>(int a1<ebx>, int a2, int a3, int a4);
__int16 __cdecl sub_1005324F(int a1, int a2);
int __stdcall sub_100533B0(unsigned __int64 a1, __int64 a2);
// unsigned __int64 __usercall sub_10053490<edx:eax>(unsigned __int64 a1<edx:eax>, unsigned __int8 a2<cl>);
// signed int __usercall sub_100534AF<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
// void __usercall sub_1005350C(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// WCHAR __usercall sub_10053515<ax>(int a1<ebx>, int a2<edi>, const WCHAR SrcStr, int a4);
// int __usercall sub_100535C7<eax>(int a1<ebp>, int a2, int a3, int a4);
// int __usercall sub_100536D0<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, signed int a6, int a7);
// int __usercall sub_100538F4<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, signed int a5);
// const WCHAR *__usercall sub_1005391E<eax>(int a1<ebx>);
// signed int __usercall sub_100539AB<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
// signed int __usercall sub_100539C3<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6);
double sub_10053ABC(void); // weak
int __thiscall sub_10053B0B(int this, int a2, int a3, int a4);
int __thiscall sub_10053B52(int this);
int __thiscall sub_10053B5A(int this);
int __thiscall sub_10053B62(int this);
int __thiscall sub_10053B66(int this);
int __thiscall sub_10053B6D(int this, int a2);
int __thiscall sub_10053BD2(int this);
int __thiscall sub_10053BEA(int this);
int __thiscall sub_10053BF7(int this);
int __thiscall sub_10053C04(int this, int a2, int a3, int a4);
bool __thiscall sub_10053C33(int this, int a2);
int __thiscall sub_10053C54(int this, char a2);
int __thiscall sub_10053C7B(void *this);
BOOL __thiscall sub_10053CAA(void *this, int a2);
int __thiscall sub_10053D5C(void *this, int a2);
char __thiscall sub_10053DB9(int this, int a2);
BOOL __thiscall sub_10053E9F(int this, int a2);
int __thiscall sub_10053F1C(int this, int a2);
int __thiscall sub_10053F79(void *this, int a2, __int16 a3, int a4);
char __thiscall sub_10053FAF(void *this);
int __thiscall sub_10053FDD(int this, int a2);
void __fastcall sub_10053FF2(int a1);
int __thiscall sub_1005406C(int this);
int __thiscall sub_1005407C(int this, int a2);
BOOL __thiscall sub_100540DE(void *this, int a2, int a3);
int __cdecl sub_10054180(int a1);
int __cdecl sub_1005419D(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_100542B0(int a1, int a2, int a3);
int __cdecl sub_10054336(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_100544B3(int a1, int a2);
bool __cdecl sub_100544D7(int a1, int a2, int a3, int a4, int a5);
LPVOID __thiscall sub_100545B3(LPVOID lpParameter, int a2, int a3);
int __thiscall sub_100546B3(int this);
void *__thiscall sub_100546D7(int this, char a2);
BOOL __thiscall sub_100546F6(int this);
int __thiscall sub_10054707(int this);
BOOL __thiscall sub_1005470B(int this);
BOOL __thiscall sub_10054715(int this, int nPriority);
char __thiscall sub_1005475F(int this);
int __thiscall sub_1005478A(int this);
int __stdcall sub_100547A4(int a1);
// signed int __usercall sub_100547DC<eax>(int a1<ebx>, int a2<edi>, unsigned int a3, int a4, unsigned int a5, unsigned int a6);
// signed int __userpurge sub_10054805<eax>(int a1<ebx>, int a2<edi>, unsigned int a3, int a4, unsigned int a5, unsigned int a6, int a7);
// int __usercall sub_100548F8<eax>(int a1<ebx>, int a2<edi>, int a3);
int __cdecl sub_1005490C(int a1, unsigned __int16 a2);
// signed int __usercall sub_100549BA<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
// signed int __usercall sub_10054A6E<eax>(int a1<edi>, int a2, int a3, int a4, int a5);
// void __usercall sub_10054B65(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5, const CHAR *lpWideCharStr, signed int nNumberOfBytesToRead);
// signed int __usercall sub_10054C6D<eax>(int a1<ebx>, unsigned int a2, const CHAR *lpWideCharStr, signed int nNumberOfBytesToRead);
// void __usercall sub_100553FC(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4);
// signed int __usercall sub_10055488<eax>(int a1<ebx>, signed int a2);
// signed int __usercall sub_1005550E<eax>(int a1<ebx>, int a2<edi>, signed int a3);
void __cdecl sub_10055575(signed int a1);
signed __int16 __thiscall sub_1005559B(DWORD this, __int16 Buffer);
// signed int __usercall sub_100555DC<eax>(int a1<ebx>, int a2);
// void __usercall sub_10055648(int a1<edx>, int a2<ebx>, unsigned int a3);
// int __usercall sub_100556BF<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, unsigned int a5, int a6);
// int __usercall sub_1005589B<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, unsigned int a5);
signed int __cdecl sub_100558B3(int a1, int a2);
signed int __cdecl sub_10055E23(int a1, int a2);
signed int __cdecl sub_10056393(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
signed int __cdecl sub_10056B0F(__int64 a1, __int16 a2, int a3, char a4, int a5);
signed int __cdecl sub_100574D3(int a1);
int __cdecl sub_1005757C(int a1, int a2);
signed int __cdecl sub_1005787C(int a1);
// signed int __usercall sub_10057913<eax>(int a1<ebx>, int a2<edi>, int a3, int a4);
// int __usercall sub_10057B59<eax>(int a1<ebx>, int *a2);
// int __usercall sub_10057BB9<eax>(int a1<ebx>, int a2, int a3);
// signed int __usercall sub_10057C14<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6);
int __cdecl sub_10057CD7();
// void __usercall sub_10057CF0(int a1<ebx>, __int64 a2<st0>);
// double __usercall sub_10057D0E<st0>(int a1<ebx>, __int64 a2);
// double __usercall sub_10057FC1<st0>(int a1<ebp>, double result<st0>);
double __fastcall sub_100580F1(char a1);
int sub_100580FE(void); // weak
// double __usercall sub_10058141<st0>(double result<st0>);
// void __usercall sub_100581EE(int a1<edx>, __int16 a2<cx>, __int16 a3<fpstat>, double a4<st0>, char a5, char a6, char a7);
int sub_1005826C(void); // weak
// double __usercall sub_10058273<st0>(int a1<ebp>, double result<st0>);
// int __usercall sub_100583BA<eax>(__int16 a1<fpstat>, char a2, char a3, char a4, double a5);
double __cdecl sub_100583ED(double a1);
BOOL __cdecl sub_10058429();
HANDLE __cdecl sub_10058440();
// void __usercall sub_1005845F(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5);
// signed int __usercall sub_10058529<eax>(int a1<ebx>, int a2);
// int __usercall sub_100585C3<eax>(int a1<ebx>, int a2);
int __cdecl sub_100585F3(unsigned __int16 a1);
int __cdecl sub_10058792(unsigned int *a1, int a2, int a3);
// int __usercall sub_10058974<eax>(int a1<ebx>, int a2);
// int __usercall sub_100589C4<eax>(int a1<ebx>, int a2<edi>, int a3, int a4);
// int __usercall sub_100589D9<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5);
// signed int __usercall sub_10058A74<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned __int8 *a4, signed int a5, int a6);
// int __usercall sub_10058B23<eax>(int a1<ebx>, int a2, int a3, int a4, signed int a5);
int __cdecl sub_10058E0B(double); // idb
signed int __cdecl sub_10058E71(long double a1, double a2, int a3);
signed int __cdecl sub_10058FB0(unsigned __int8 *a1, unsigned __int8 *a2, signed int a3);
double __cdecl sub_10059011(double a1);
// BOOL __stdcall IsProcessorFeaturePresent(DWORD ProcessorFeature);
// void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
// double __usercall sub_10059030<st0>(__int16 a1<cx>, int a2<ebx>, double a3);
// void __usercall sub_10059230(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10059253<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10059276<eax>(int a1<ebp>);
// _DWORD *__usercall sub_1005927E<eax>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_100592A1<eax>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_100592A9<eax>(int a1<ebp>);
int __thiscall sub_100592CC(void *this);
int __thiscall sub_100592F9(void *this);
int __thiscall sub_10059322(void *this);
int __thiscall sub_10059333(void *this);
// int __usercall sub_1005935F<eax>(int a1<ebp>);
void __cdecl sub_10059385();
// void __usercall sub_100593A8(int a1<ebx>, int a2<ebp>);
void __cdecl sub_100593B0();
void __cdecl sub_100593DD();
// unsigned int __usercall sub_10059400<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_10059408();
// int __usercall sub_10059431<eax>(int a1<ebp>);
// int __usercall sub_10059457<eax>(int a1<ebp>);
// void __usercall sub_1005947D(int a1<ebp>);
int __cdecl sub_100594A0();
// void __usercall sub_100594C3(int a1<ebx>, int a2<ebp>);
int __thiscall sub_100594F0(void *this);
// void __usercall sub_10059556(int a1<ebp>);
// int __usercall sub_1005955E<eax>(int a1<ebp>);
// int __usercall sub_1005956C<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10059595();
// int __usercall sub_100595B8<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005962C();
// int __usercall sub_10059634<eax>(int a1<ebp>);
int __thiscall sub_1005963E(void *this);
// int __usercall sub_1005964C<eax>(int a1<ebp>);
// void __usercall sub_10059665(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_10059688<eax>(int a1<ebp>);
// void __usercall sub_10059692(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005969A<eax>(int a1<ebp>);
// void __usercall sub_100596CE(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// void __usercall sub_100596F1(int a1<ebp>);
// int __usercall sub_10059714<eax>(int a1<ebp>);
// void __usercall sub_10059737(int a1<ebp>);
// int __usercall sub_1005973F<eax>(LPVOID *this<ecx>, int a2<ebp>);
// int __usercall sub_1005974A<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10059755<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10059760<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005976B<eax>(int a1<ebp>);
// int __usercall sub_10059776<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// int __usercall sub_10059781<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// void __usercall sub_1005978F(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
void __cdecl sub_1005979D();
void __cdecl sub_100597AB();
void __cdecl sub_100597D4();
// int __usercall sub_100597DC<eax>(LPVOID *this<ecx>, int a2<ebp>);
// int __usercall sub_100597E7<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_100597F2<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_100597FD<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10059808();
// int __usercall sub_10059813<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// int __usercall sub_1005981E<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// void __usercall sub_1005982C(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
void __cdecl sub_1005983A();
void __cdecl sub_10059848();
// int __usercall sub_10059871<eax>(int a1<ebp>);
void __cdecl sub_100598A5();
// int __usercall sub_100598AD<eax>(LPVOID *this<ecx>, int a2<ebp>);
// int __usercall sub_100598EB<eax>(int a1<ebp>);
void __cdecl sub_100598F5();
// int __usercall sub_100598FD<eax>(int a1<ebp>);
// int __usercall sub_10059907<eax>(int a1<ebp>);
// int __usercall sub_1005992C<eax>(int a1<ebp>);
// int __usercall sub_10059936<eax>(int a1<ebp>);
// void __usercall sub_10059976(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
// int __usercall sub_10059981<eax>(int a1<ebp>);
// void __usercall sub_100599A7(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
// int __usercall sub_100599B2<eax>(int a1<ebp>);
// int __usercall sub_100599D8<eax>(int a1<ebp>);
// int __usercall sub_10059A07<eax>(LPVOID *this<ecx>, int a2<ebp>);
// int __usercall sub_10059A0F<eax>(int a1<ebp>);
void __cdecl sub_10059A34();
// int __usercall sub_10059A3C<eax>(int a1<ebp>);
// int __usercall sub_10059A46<eax>(int a1<ebp>);
void __cdecl sub_10059A6B();
void __cdecl sub_10059A8E();
void __cdecl sub_10059AB1();
// void __usercall sub_10059AD4(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
// int __usercall sub_10059B12<eax>(int a1<ebp>);
// int __usercall sub_10059B45<eax>(int a1<ebp>);
// int __usercall sub_10059B68<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_10059B70<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10059B96();
void __cdecl sub_10059BB9();
// int __usercall sub_10059BC4<eax>(int a1<ebp>);
// void __usercall sub_10059BE9(int a1<ebp>);
void __cdecl sub_10059C0C();
void __cdecl sub_10059C17();
// int __usercall sub_10059C1F<eax>(int a1<ebp>);
// int __usercall sub_10059C2A<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// int __usercall sub_10059C35<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
void __cdecl sub_10059C5E();
void __cdecl sub_10059C84();
// int __usercall sub_10059CAA<eax>(int a1<ebp>);
// int __usercall sub_10059CEA<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_10059CF5();
void __cdecl sub_10059D1E();
void __cdecl sub_10059D29();
void __cdecl sub_10059D4F();
// int __usercall sub_10059D72<eax>(void *this<ecx>, int a2<ebp>);
int __cdecl sub_10059D98();
// int __usercall sub_10059DBB<eax>(LPVOID *this<ecx>, int a2<ebp>);
// int __usercall sub_10059DEF<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// int __usercall sub_10059DFA<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// int __usercall sub_10059E20<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>);
// int __usercall sub_10059E46<eax>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_10059E69<eax>(void *this<ecx>, int a2<ebp>);
// void __usercall sub_10059E8C(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
// int __usercall sub_10059E97<eax>(int a1<ebp>);
// void __usercall sub_10059EBC(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
void __cdecl sub_10059EE2();
// int __usercall sub_10059F05<eax>(int a1<ebp>);
void __cdecl sub_10059F2A();
// void __usercall sub_10059F4D(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
// void __usercall sub_10059F73(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>);
// int __usercall sub_10059F99<eax>(int a1<ebp>);
// int __usercall sub_10059FBE<eax>(int a1<ebp>);
void __cdecl sub_10059FF0();
int __thiscall sub_10059FF8(void *this);
// int __usercall sub_1005A00C<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005A030<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005A038();
void __cdecl sub_1005A040();
// int __usercall sub_1005A048<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005A050();
// int __usercall sub_1005A058<eax>(int a1<ebp>);
void __cdecl sub_1005A063();
// int __usercall sub_1005A090<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005A098();
void __cdecl sub_1005A0A0();
// int __usercall sub_1005A0D0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005A0D8();
// int __usercall sub_1005A0E0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005A0E8<eax>(int a1<ebp>);
// int __usercall sub_1005A120<eax>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005A128<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005A130();
// int __usercall sub_1005A138<eax>(int a1<ebp>);
void __cdecl sub_1005A143();
// int __usercall sub_1005A14B<eax>(int a1<ebp>);
void __cdecl sub_1005A180();
void __cdecl sub_1005A1B0();
int __thiscall sub_1005A1E0(void *this);
// void __usercall sub_1005A1F1(int a1<ebp>);
void __cdecl sub_1005A1F9();
void __cdecl sub_1005A240();
// int __usercall sub_1005A270<eax>(int a1<ebp>);
void __cdecl sub_1005A2C0();
void __cdecl sub_1005A2F0();
void __cdecl sub_1005A2F8();
// int __usercall sub_1005A330<eax>(int a1<ebp>);
void __cdecl sub_1005A370();
void __cdecl sub_1005A378();
void __cdecl sub_1005A380();
void __cdecl sub_1005A388();
int __thiscall sub_1005A3C0(void *this);
// int __usercall sub_1005A3F0<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005A420();
void __cdecl sub_1005A428();
// int __usercall sub_1005A460<eax>(int a1<ebp>);
// int __usercall sub_1005A490<eax>(int a1<ebp>);
// int __usercall sub_1005A49B<eax>(int a1<ebp>);
// int __usercall sub_1005A4D0<eax>(int a1<ebp>);
// void __usercall sub_1005A4DB(int a1<ebp>);
int __thiscall sub_1005A4E3(void *this);
// int __usercall sub_1005A4F7<eax>(int a1<ebp>);
// int __usercall sub_1005A530<eax>(int a1<ebp>);
// int __usercall sub_1005A53B<eax>(int a1<ebp>);
void __cdecl sub_1005A570();
// int __usercall sub_1005A5A0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>);
// int __usercall sub_1005A5A8<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>);
// int __usercall sub_1005A5B0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005A5BB<eax>(int a1<ebp>);
void __cdecl sub_1005A5F0();
void __cdecl sub_1005A620();
int __thiscall sub_1005A628(void *this);
// int __usercall sub_1005A63C<eax>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005A644<eax>(int a1<ebp>);
// int __usercall sub_1005A670<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005A678<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005A680<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005A68B();
// int __usercall sub_1005A696<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005A6C0<eax>(int a1<ebp>);
// int __usercall sub_1005A6CB<eax>(int a1<ebp>);
void __cdecl sub_1005A6D6();
void __cdecl sub_1005A700();
// int __usercall sub_1005A730<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>);
// int __usercall sub_1005A760<eax>(int a1<ebp>);
// int __usercall sub_1005A768<eax>(int a1<ebp>);
// int __usercall sub_1005A790<eax>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005A798<eax>(int a1<ebp>);
// int __usercall sub_1005A7A3<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005A7AE();
int __cdecl sub_1005A7B9(int, int); // weak
// int __usercall sub_1005A7E0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005A7E8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005A820<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005A828<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005A833();
void __cdecl sub_1005A860();
// int __usercall sub_1005A890<eax>(int a1<ebp>);
// int __usercall sub_1005A89B<eax>(int a1<ebp>);
// int __usercall sub_1005A8A6<eax>(int a1<ebp>);
// int __usercall sub_1005A8B1<eax>(int a1<ebp>);
void __cdecl sub_1005A8E0();
// int __usercall sub_1005A8E8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005A8F0<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005A8F8();
// int __usercall sub_1005A900<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005A90B<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005A940();
void __cdecl sub_1005A970();
void __cdecl sub_1005A9A0();
void __cdecl sub_1005A9D0();
void __cdecl sub_1005A9D8();
void __cdecl sub_1005AA10();
void __cdecl sub_1005AA18();
int __cdecl sub_1005AA20(int, int); // weak
void __cdecl sub_1005AA50();
void __cdecl sub_1005AA58();
void __cdecl sub_1005AA90();
void __cdecl sub_1005AA98();
int __cdecl sub_1005AAA0(int, int); // weak
void __cdecl sub_1005AAD0();
void __cdecl sub_1005AAD8();
// int __usercall sub_1005AB10<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005AB40<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005AB48<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005AB70<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005AB78();
// int __usercall sub_1005AB80<eax>(int a1<ebp>);
// int __usercall sub_1005ABC0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005ABC8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005ABD0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005ABD8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005ABE0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005ABE8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005ABF0();
// int __usercall sub_1005ABF8<eax>(int a1<ebp>);
void __cdecl sub_1005AC40();
// int __usercall sub_1005AC70<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005AC7B<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005AC86<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005AC91<eax>(int a1<ebp>);
void __cdecl sub_1005ACD0();
void __cdecl sub_1005ACD8();
// int __usercall sub_1005ACE0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005AD10<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005AD18();
void __cdecl sub_1005AD50();
void __cdecl sub_1005AD80();
void __cdecl sub_1005AD88();
void __cdecl sub_1005ADB0();
void __cdecl sub_1005ADB8();
void __cdecl sub_1005ADC0();
// int __usercall sub_1005ADC8<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005ADD0();
int __cdecl sub_1005AE00(int, int); // weak
int __cdecl sub_1005AE20(int, int); // weak
void __cdecl sub_1005AE40();
// int __usercall sub_1005AE70<eax>(int a1<ebp>);
// int __usercall sub_1005AEB0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005AEB8();
void __cdecl sub_1005AEF0();
// int __usercall sub_1005AF20<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005AF50();
void __cdecl sub_1005AF80();
void __cdecl sub_1005AFB0();
void __cdecl sub_1005AFE0();
void __cdecl sub_1005AFE8();
void __cdecl sub_1005AFF0();
void __cdecl sub_1005B020();
// int __usercall sub_1005B028<eax>(int a1<ebp>);
// int __usercall sub_1005B033<eax>(int a1<ebp>);
// int __usercall sub_1005B080<eax>(int a1<ebp>);
void __cdecl sub_1005B0B0();
void __cdecl sub_1005B0E0();
void __cdecl sub_1005B0E8();
int __thiscall sub_1005B110(void *this);
int __thiscall sub_1005B121(void *this);
void __cdecl sub_1005B150();
// int __usercall sub_1005B180<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005B188<eax>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005B190();
// int __usercall sub_1005B198<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005B1A0();
void __cdecl sub_1005B1D0();
void __cdecl sub_1005B1D8();
// int __usercall sub_1005B200<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005B208(int a1<ebp>);
// int __usercall sub_1005B230<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B260<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B268<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B290<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B298<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B2A3<eax>(int a1<ebp>);
// int __usercall sub_1005B2E0<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005B320();
void __cdecl sub_1005B328();
int __thiscall sub_1005B350(void *this);
void __cdecl sub_1005B361();
void __cdecl sub_1005B3B0();
// void __usercall sub_1005B400(int a1<ebx>, int a2<ebp>);
// void __usercall sub_1005B460(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005B490<eax>(int a1<ebp>);
// char __usercall sub_1005B4C0<al>(int a1<ebp>);
// int __usercall sub_1005B4DC<eax>(int a1<ebp>);
// void __usercall sub_1005B4E7(int a1<ebp>);
// int __usercall sub_1005B510<eax>(int a1<ebp>);
// int __usercall sub_1005B540<eax>(int a1<ebp>);
// int __usercall sub_1005B54B<eax>(int a1<ebp>);
// void __usercall sub_1005B580(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005B588(int a1<ebx>, int a2<ebp>);
void __cdecl sub_1005B593();
void __cdecl sub_1005B59E();
void __cdecl sub_1005B5A9();
void __cdecl sub_1005B5B4();
void __cdecl sub_1005B5BF();
// int __usercall sub_1005B5F0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B620<eax>(int a1<ebp>);
void __cdecl sub_1005B650();
void __cdecl sub_1005B680();
void __cdecl sub_1005B688();
// void __usercall sub_1005B690(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005B6C0<eax>(int a1<ebp>);
// int __usercall sub_1005B6CB<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005B6D3();
void __cdecl sub_1005B6DB();
// void __usercall sub_1005B6E3(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005B6EB();
void __cdecl sub_1005B720();
void __cdecl sub_1005B750();
// void __usercall sub_1005B780(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005B788<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005B790(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005B798<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B7D0<eax>(int a1<ebp>);
// int __usercall sub_1005B800<eax>(int a1<ebp>);
// int __usercall sub_1005B830<eax>(int a1<ebp>);
// void __usercall sub_1005B83B(void *this<ecx>, int a2<ebx>, int a3<ebp>);
// void __usercall sub_1005B854(int a1<ebp>);
// void __usercall sub_1005B8A0(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005B8A8<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005B8B0(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005B8B8<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B910<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B918<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B940<eax>(int a1<ebp>);
// int __usercall sub_1005B970<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B9B0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B9B8<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B9C0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005B9C8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005BA00<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005BA08<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BA10<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BA18<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BA20<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005BA28<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005BA50<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BA58<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005BA90<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BA98<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BAA0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BAD0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BAD8<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005BB00(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005BB08<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005BB40();
// int __usercall sub_1005BBB0<eax>(int a1<ebp>);
void __cdecl sub_1005BBE0();
// int __usercall sub_1005BBE8<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005BC10(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005BC40<eax>(int this<ecx>, int a2<ebp>);
int __thiscall sub_1005BC70(void *this);
// int __usercall sub_1005BCA0<eax>(int a1<ebp>);
// int __usercall sub_1005BCAB<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005BCB3<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BCE0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BCE8<eax>(int a1<ebp>);
// int __usercall sub_1005BCF3<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005BCFB<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BD03<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BD0B<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BD40<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005BD48<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005BD50<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005BD58<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BDB0<eax>(int a1<ebp>);
// int __usercall sub_1005BDBB<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005BDC3();
void __cdecl sub_1005BDCB();
// void __usercall sub_1005BDD3(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005BDDB();
// int __usercall sub_1005BE10<eax>(int a1<ebp>);
// int __usercall sub_1005BE40<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BE4B<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BE56<eax>(int this<ecx>, int a2<ebp>);
// char __usercall sub_1005BE5E<al>(int a1<ebp>);
// int __usercall sub_1005BE69<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BEA0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BEAB<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BEB3<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BEBB<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BEC3<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BECB<eax>(int a1<ebp>);
// int __usercall sub_1005BED6<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005BF10(int a1<ebp>);
// void __usercall sub_1005BF40(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005BF48(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005BFC0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005BFC8<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C000<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C040<eax>(int a1<ebp>);
// int __usercall sub_1005C070<eax>(int this<ecx>, int a2<ebp>);
// LPVOID __usercall sub_1005C089<eax>(LPVOID *this<ecx>, int a2<ebp>);
// void __usercall sub_1005C091(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005C099(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005C0C0<eax>(int this<ecx>, int a2<ebp>);
// LPVOID __usercall sub_1005C0D9<eax>(LPVOID *this<ecx>, int a2<ebp>);
// void __usercall sub_1005C0E1(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005C0E9(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005C110();
void __cdecl sub_1005C118();
// LPVOID __usercall sub_1005C123<eax>(LPVOID *this<ecx>, int a2<ebp>);
// LPVOID __usercall sub_1005C150<eax>(LPVOID *this<ecx>, int a2<ebp>);
// LPVOID __usercall sub_1005C158<eax>(int a1<ebp>);
// int __usercall sub_1005C180<eax>(int a1<ebp>);
// int __usercall sub_1005C1B0<eax>(int a1<ebp>);
// void __usercall sub_1005C1F0(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005C1F8(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005C220<eax>(int a1<ebp>);
void __cdecl sub_1005C228();
void __cdecl sub_1005C233();
// int __usercall sub_1005C23E<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005C270(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005C2A0<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005C2D0(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005C2D8(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005C340(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005C370();
void __cdecl sub_1005C378();
void __cdecl sub_1005C380();
void __cdecl sub_1005C388();
// int __usercall sub_1005C3C0<eax>(int a1<ebp>);
// int __usercall sub_1005C3C8<eax>(int a1<ebp>);
void __cdecl sub_1005C3D0();
void __cdecl sub_1005C3D8();
void __cdecl sub_1005C410();
void __cdecl sub_1005C418();
// int __usercall sub_1005C450<eax>(int a1<ebp>);
// int __usercall sub_1005C45B<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005C490(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005C4C0(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005C4F0();
// int __usercall sub_1005C520<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C550<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005C590(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005C5C0<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005C600(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005C630<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C638<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C640<eax>(int a1<ebp>);
// int __usercall sub_1005C670<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C678<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C680<eax>(int a1<ebp>);
void __cdecl sub_1005C6B0();
// int __usercall sub_1005C6B8<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005C6C0();
// int __usercall sub_1005C710<eax>(int a1<ebp>);
// int *__usercall sub_1005C750<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005C758();
void __cdecl sub_1005C760();
// int __usercall sub_1005C76B<eax>(int a1<ebp>);
// int __usercall sub_1005C773<eax>(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005C7B0(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005C7E0();
void __cdecl sub_1005C7E8();
// void __usercall sub_1005C7F3(void *a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005C7FE<eax>(int a1<ebp>);
// void __usercall sub_1005C830(int a1<ebp>);
// int __usercall sub_1005C838<eax>(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005C843(void *a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005C870<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C878<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C883<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C88E<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005C899();
void __cdecl sub_1005C8A7();
// int __usercall sub_1005C8B5<eax>(int a1<ebp>);
// int __usercall sub_1005C8C3<eax>(int a1<ebp>);
void __cdecl sub_1005C8D1();
// int __usercall sub_1005C8D9<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C8E1<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005C8E9();
// int __usercall sub_1005C8F1<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005C8FF<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005C90D();
void __cdecl sub_1005C91B();
// int __usercall sub_1005C929<eax>(int a1<ebp>);
// int __usercall sub_1005C937<eax>(int a1<ebp>);
void __cdecl sub_1005C960();
void __cdecl sub_1005C990();
// void __usercall sub_1005C9C0(int a1<ebp>);
// int __usercall sub_1005C9C8<eax>(int a1<ebp>);
// int __usercall sub_1005C9D3<eax>(int a1<ebp>);
void __cdecl sub_1005C9DE();
// int __usercall sub_1005CA10<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005CA18<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005CA50(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005CA80();
// void __usercall sub_1005CAB0(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005CABB<eax>(int a1<ebp>);
// int __usercall sub_1005CAC6<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CAD1<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CADC<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005CB10();
void __cdecl sub_1005CB18();
// void __usercall sub_1005CB23(void *a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005CB2E<eax>(int a1<ebp>);
// int __usercall sub_1005CB60<eax>(int a1<ebp>);
void __cdecl sub_1005CB68();
void __cdecl sub_1005CB90();
// int __usercall sub_1005CB98<eax>(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005CBA3(void *a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005CBAE<eax>(int a1<ebp>);
void __cdecl sub_1005CBB6();
// void __usercall sub_1005CBE0(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005CBE8(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>);
// int __usercall sub_1005CC10<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CC18<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CC23<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CC2E<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CC39<eax>(int a1<ebp>);
void __cdecl sub_1005CC47();
// int __usercall sub_1005CC55<eax>(int a1<ebp>);
// int __usercall sub_1005CC63<eax>(int a1<ebp>);
// int __usercall sub_1005CC71<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005CC7F();
void __cdecl sub_1005CC8D();
// int __usercall sub_1005CC9B<eax>(int a1<ebp>);
// int __usercall sub_1005CCA9<eax>(int a1<ebp>);
// int __usercall sub_1005CCB7<eax>(int a1<ebp>);
// char __usercall sub_1005CCE0<al>(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005CD10();
// int __usercall sub_1005CD18<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005CD20<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005CD28<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005CD33<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005CD3B<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CD46<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CD51<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005CD59<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CD64<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CD6F<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CD7A<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CD85<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CD90<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CDD0<eax>(int a1<ebp>);
// void __usercall sub_1005CDDB(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005CDE3(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>);
void __cdecl sub_1005CE10();
void __cdecl sub_1005CE40();
void __cdecl sub_1005CE48();
void __cdecl sub_1005CE80();
void __cdecl sub_1005CE88();
int __cdecl sub_1005CE90(int, int); // weak
// int __usercall sub_1005CEC0<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005CEC8();
// char __usercall sub_1005CF00<al>(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005CF08<eax>(int a1<ebp>);
// int __usercall sub_1005CF40<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005CF48();
void __cdecl sub_1005CF50();
// int __usercall sub_1005CF58<eax>(int a1<ebp>);
// int __usercall sub_1005CF63<eax>(int a1<ebp>);
void __cdecl sub_1005CF7C();
// int __usercall sub_1005CF84<eax>(int a1<ebp>);
// int __usercall sub_1005CFC0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CFC8<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005CFD0<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005CFD8();
// int __usercall sub_1005D010<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D018<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D020<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D028<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D030<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D038<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D040<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D048<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D050<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D058<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D060<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
// int __usercall sub_1005D068<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>);
void __cdecl sub_1005D070();
// int __usercall sub_1005D078<eax>(int a1<ebp>);
void __cdecl sub_1005D0C0();
void __cdecl sub_1005D0C8();
void __cdecl sub_1005D100();
void __cdecl sub_1005D108();
void __cdecl sub_1005D110();
// int __usercall sub_1005D118<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005D120();
void __cdecl sub_1005D150();
// int __usercall sub_1005D158<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005D160();
int __thiscall sub_1005D190(void *this);
void __cdecl sub_1005D1A1();
void __cdecl sub_1005D1A9();
// int __usercall sub_1005D1D0<eax>(int a1<ebp>);
// int __usercall sub_1005D200<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005D208();
void __cdecl sub_1005D230();
void __cdecl sub_1005D260();
// void __usercall sub_1005D290(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005D2C0<eax>(int a1<ebp>);
// int __usercall sub_1005D2F0<eax>(int a1<ebp>);
// void __usercall sub_1005D2FB(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005D330();
// int __usercall sub_1005D360<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005D368();
// int __usercall sub_1005D370<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005D3A0();
// int __usercall sub_1005D3A8<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005D3D0();
// int __usercall sub_1005D3D8<eax>(int this<ecx>, int a2<ebp>);
// void __usercall sub_1005D400(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005D430(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005D460<eax>(int a1<ebp>);
// void __usercall sub_1005D490(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005D4C0(void *this<ecx>, int a2<ebp>);
// void __usercall sub_1005D4F0(void *this<ecx>, int a2<ebp>);
// int __usercall sub_1005D520<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005D528();
// void __usercall sub_1005D560(void *this<ecx>, int a2<ebp>);
void __cdecl sub_1005D590();
// int __usercall sub_1005D5C0<eax>(int a1<ebp>);
// int __usercall sub_1005D5F0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005D620<eax>(int a1<ebp>);
// int __usercall sub_1005D62B<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005D660();
void __cdecl sub_1005D668();
// int __usercall sub_1005D6A0<eax>(int a1<ebp>);
// int __usercall sub_1005D6A8<eax>(int a1<ebp>);
// int __usercall sub_1005D6B0<eax>(int a1<ebp>);
// int __usercall sub_1005D6BB<eax>(int a1<ebp>);
// int __usercall sub_1005D6C3<eax>(int a1<ebp>);
// int __usercall sub_1005D6CB<eax>(int a1<ebp>);
// int __usercall sub_1005D710<eax>(int this<ecx>, int a2<ebp>);
void __cdecl sub_1005D750();
void __cdecl sub_1005D780();
// int __usercall sub_1005D7B0<eax>(int this<ecx>, int a2<ebp>);
// int __usercall sub_1005D7E0<eax>(int a1<ebx>);
// int __usercall sub_1005E0E0<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005E2B0<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005E3C0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>);
// int __usercall sub_1005E3E0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_1005E3F0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_1005E400<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// __int64 __usercall sub_1005E410<edx:eax>(int a1<ebx>);
// int __usercall sub_1005E8A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_1005E8C0<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005E8E0<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005E980<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005EA10<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005EA30<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005EA50<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005EA70<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005EA90<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005EAB0<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005EAF7<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_1005EB03<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_1005EB0F<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005EB25<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>);
// int __usercall sub_1005EB31<eax>(int a1<ebx>, int a2<edi>);
// int __usercall sub_1005EB47<eax>(int a1<ebx>, int a2<edi>);
void **__cdecl sub_1005EB5F();
unsigned int __cdecl sub_1005EB6D();
void __cdecl sub_1005EB78();
void __cdecl sub_1005EB83();
void __cdecl sub_1005EB8E();
void __cdecl sub_1005EB99();
void __cdecl sub_1005EBA4();
signed int __cdecl sub_1005EBB0();
signed int __cdecl sub_1005EBD0();
signed int __cdecl sub_1005EBF0();
int sub_1005EC10(); // weak
void __cdecl sub_1005EC20();
int sub_1005EC30(); // weak
int sub_1005EC40(); // weak
int sub_1005EC50(); // weak
int __cdecl sub_1005EC60();
signed int __cdecl sub_1005ECC0();
signed int __cdecl sub_1005ECE0();
int __cdecl sub_1005ED00();
int __cdecl sub_1005ED60();
int __cdecl sub_1005EDC0();
int __cdecl sub_1005EE20();
int __cdecl sub_1005EE80();
int __cdecl sub_1005EEE0();
int sub_1005EF30(); // weak
int sub_1005EF3A(); // weak
int sub_1005EF44(); // weak
int sub_1005EF4E(); // weak
int sub_1005EF58(); // weak
int sub_1005EF62(); // weak
// HANDLE __stdcall CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// BOOL __stdcall SetEnvironmentVariableA(LPCSTR lpName, LPCSTR lpValue);
// BOOL __stdcall WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved);
// BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);
// BOOL __stdcall ReadConsoleW(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable);
// BOOL __stdcall FlushFileBuffers(HANDLE hFile);
// BOOL __stdcall SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
// BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);
// UINT __stdcall GetConsoleCP();
// int __stdcall GetThreadPriority(HANDLE hThread);
// DWORD __stdcall FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments);
// DWORD __stdcall GetLastError();
// HGLOBAL __stdcall GlobalFree(HGLOBAL hMem);
// HLOCAL __stdcall LocalFree(HLOCAL hMem);
// LONG __stdcall InterlockedIncrement(volatile LONG *lpAddend);
// LONG __stdcall InterlockedDecrement(volatile LONG *lpAddend);
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar);
// void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);
// PVOID __stdcall EncodePointer(PVOID Ptr);
// PVOID __stdcall DecodePointer(PVOID Ptr);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void __stdcall Sleep(DWORD dwMilliseconds);
// int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// BOOL __stdcall GetStringTypeW(DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
// DWORD __stdcall GetCurrentThreadId();
// BOOL __stdcall InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);
// LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);
// BOOL __stdcall CreateTimerQueueTimer(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags);
// HANDLE __stdcall CreateTimerQueue();
// PSINGLE_LIST_ENTRY __stdcall InterlockedPopEntrySList(PSLIST_HEADER ListHead);
// PSINGLE_LIST_ENTRY __stdcall InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSINGLE_LIST_ENTRY ListEntry);
// PSINGLE_LIST_ENTRY __stdcall InterlockedFlushSList(PSLIST_HEADER ListHead);
// USHORT __stdcall QueryDepthSList(PSLIST_HEADER ListHead);
// BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);
// void __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments);
// BOOL __stdcall IsDebuggerPresent();
// LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);
// void __stdcall SetLastError(DWORD dwErrCode);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// HMODULE __stdcall LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
// HMODULE __stdcall LoadLibraryW(LPCWSTR lpLibFileName);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions);
// BOOL __stdcall SetEvent(HANDLE hEvent);
// BOOL __stdcall ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// HANDLE __stdcall CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
// void __stdcall InitializeSListHead(PSLIST_HEADER ListHead);
// HANDLE __stdcall GetCurrentProcess();
// BOOL __stdcall SwitchToThread();
// DWORD __stdcall TlsAlloc();
// BOOL __stdcall TlsFree(DWORD dwTlsIndex);
// DWORD __stdcall GetTickCount();
// BOOL __stdcall UnregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent);
// BOOL __stdcall ChangeTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period);
// BOOL __stdcall GetNumaHighestNodeNumber(PULONG HighestNodeNumber);
// BOOL __stdcall RegisterWaitForSingleObject(PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags);
// void __stdcall OutputDebugStringW(LPCWSTR lpOutputString);
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// HANDLE __stdcall GetCurrentThread();
// BOOL __stdcall GetThreadTimes(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// void __stdcall FreeLibraryAndExitThread(HMODULE hLibModule, DWORD dwExitCode);
// DWORD __stdcall GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// LPSTR __stdcall GetCommandLineA();
// void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);
// BOOL __stdcall GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo);
// LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo);
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// void __stdcall GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo);
// HMODULE __stdcall GetModuleHandleW(LPCWSTR lpModuleName);
// HANDLE __stdcall CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName);
// int __stdcall CompareStringW(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2);
// int __stdcall LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
// int __stdcall GetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData);
// BOOL __stdcall IsValidLocale(LCID Locale, DWORD dwFlags);
// LCID __stdcall GetUserDefaultLCID();
// BOOL __stdcall EnumSystemLocalesW(LOCALE_ENUMPROCW lpLocaleEnumProc, DWORD dwFlags);
// DWORD __stdcall GetTimeZoneInformation(LPTIME_ZONE_INFORMATION lpTimeZoneInformation);
// void __stdcall ExitProcess(UINT uExitCode);
// BOOL __stdcall GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule);
// SIZE_T __stdcall HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);
// BOOL __stdcall DeleteTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent);
// BOOL __stdcall GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask);
// DWORD_PTR __stdcall SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask);
// BOOL __stdcall SetThreadPriority(HANDLE hThread, int nPriority);
// BOOL __stdcall GetVersionExW(LPOSVERSIONINFOW lpVersionInformation);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// HANDLE __stdcall GetStdHandle(DWORD nStdHandle);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall IsValidCodePage(UINT CodePage);
// UINT __stdcall GetACP();
// UINT __stdcall GetOEMCP();
// HANDLE __stdcall GetProcessHeap();
// BOOL __stdcall UnregisterWait(HANDLE WaitHandle);
// DWORD __stdcall GetFileType(HANDLE hFile);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
// DWORD __stdcall GetCurrentProcessId();
// LPWCH __stdcall GetEnvironmentStringsW();
// BOOL __stdcall FreeEnvironmentStringsW(LPWCH);
// BOOL __stdcall WinHttpReadData(HINTERNET hRequest, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead);
// BOOL __stdcall WinHttpCrackUrl(LPCWSTR pwszUrl, DWORD dwUrlLength, DWORD dwFlags, LPURL_COMPONENTS lpUrlComponents);
// HINTERNET __stdcall WinHttpOpenRequest(HINTERNET hConnect, LPCWSTR pwszVerb, LPCWSTR pwszObjectName, LPCWSTR pwszVersion, LPCWSTR pwszReferrer, LPCWSTR *ppwszAcceptTypes, DWORD dwFlags);
// HINTERNET __stdcall WinHttpOpen(LPCWSTR pszAgentW, DWORD dwAccessType, LPCWSTR pszProxyW, LPCWSTR pszProxyBypassW, DWORD dwFlags);
// BOOL __stdcall WinHttpQueryDataAvailable(HINTERNET hRequest, LPDWORD lpdwNumberOfBytesAvailable);
// WINHTTP_STATUS_CALLBACK __stdcall WinHttpSetStatusCallback(HINTERNET hInternet, WINHTTP_STATUS_CALLBACK lpfnInternetCallback, DWORD dwNotificationFlags, DWORD_PTR dwReserved);
// BOOL __stdcall WinHttpQueryHeaders(HINTERNET hRequest, DWORD dwInfoLevel, LPCWSTR pwszName, LPVOID lpBuffer, LPDWORD lpdwBufferLength, LPDWORD lpdwIndex);
// BOOL __stdcall WinHttpCloseHandle(HINTERNET hInternet);
// BOOL __stdcall WinHttpSendRequest(HINTERNET hRequest, LPCWSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength, DWORD dwTotalLength, DWORD_PTR dwContext);
// BOOL __stdcall WinHttpGetIEProxyConfigForCurrentUser(WINHTTP_CURRENT_USER_IE_PROXY_CONFIG *pProxyConfig);
// BOOL __stdcall WinHttpReceiveResponse(HINTERNET hRequest, LPVOID lpReserved);


//----- (10001000) --------------------------------------------------------
char __userpurge S2_SetIndicators<al>(int a1<ebx>, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, int a10, int a11, __int64 a12, unsigned int a13)
{
  __int16 v13; // ax@3
  int v14; // esi@3
  signed __int64 v15; // ST30_8@5
  int v16; // ecx@5
  __int64 v18; // ST28_8@5
  __int64 v20; // ST18_8@5
  __int64 v22; // ST10_8@5
  __int64 v24; // ST08_8@5
  __int64 v26; // ST00_8@5
  int v27; // ST20_4@5
  int v28; // ST24_4@5
  char v30; // [sp+3Ch] [bp-3Ch]@1
  char v31; // [sp+70h] [bp-8h]@1
  unsigned int v32; // [sp+74h] [bp-4h]@1

  v32 = (unsigned int)&v30 ^ __security_cookie;
  sub_1002B6B7((int)&v31, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    LOBYTE(v13) = sub_1002B6E4(&v31);
  }
  else
  {
    v14 = *(_DWORD *)(dword_10076638 + 4 * a2);
    LOBYTE(v13) = sub_1002B6E4(&v31);
    if ( v14 )
    {
      v13 = *(_WORD *)(v14 + 56);
      if ( v13 == word_10074F78 )
      {
        __asm
        {
          movsd   xmm0, [ebp+arg_44]
          movsd   xmm3, [ebp+arg_14]
          movsd   xmm2, [ebp+arg_C]
          movsd   xmm1, [ebp+arg_4]
        }
        v15 = 10000000i64 * a13;
        v16 = v14;
        __asm
        {
          movsd   [esp+78h+var_50], xmm0
          movsd   xmm0, [ebp+arg_34]
          movsd   [esp+78h+var_60], xmm0
          movsd   xmm0, [ebp+arg_2C]
          movsd   [esp+78h+var_68], xmm0
          movsd   xmm0, [ebp+arg_24]
          movsd   [esp+78h+var_70], xmm0
          movsd   xmm0, [ebp+arg_1C]
          movsd   [esp+78h+var_78], xmm0
        }
        LOBYTE(v13) = sub_10020D90(v16, v26, v24, v22, v20, v27, v28, v18, v15, SHIDWORD(v15));
      }
    }
  }
  return v13;
}
// 10073200: using guessed type int __security_cookie;
// 10074F78: using guessed type __int16 word_10074F78;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (100010F0) --------------------------------------------------------
bool __userpurge S2_OpenLong<eax>(int a1<ebx>, unsigned int a2, unsigned int a3)
{
  int v3; // esi@3
  signed __int64 v4; // qax@5
  int v5; // ecx@5
  char v7; // [sp+4h] [bp-Ch]@1
  char v8; // [sp+8h] [bp-8h]@1
  unsigned int v9; // [sp+Ch] [bp-4h]@1

  v9 = (unsigned int)&v7 ^ __security_cookie;
  sub_1002B6B7((int)&v8, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    sub_1002B6E4(&v8);
    return 0;
  }
  v3 = *(_DWORD *)(dword_10076638 + 4 * a2);
  sub_1002B6E4(&v8);
  if ( !v3 || *(_WORD *)(v3 + 56) != word_10074F78 )
    return 0;
  v4 = 10000000i64 * a3;
  v5 = *(_DWORD *)(v3 + 8);
  return v5
      && *(_BYTE *)(v5 + 112) & 4
      && *(_DWORD *)(v3 + 348) == 2
      && *(_DWORD *)(v3 + 344) == 1
      && *(_DWORD *)(v3 + 352) == (_DWORD)v4
      && *(_DWORD *)(v3 + 356) == HIDWORD(v4);
}
// 10073200: using guessed type int __security_cookie;
// 10074F78: using guessed type __int16 word_10074F78;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (100011E0) --------------------------------------------------------
bool __userpurge S2_OpenShort<eax>(int a1<ebx>, unsigned int a2, unsigned int a3)
{
  int v3; // esi@3
  signed __int64 v4; // qax@5
  int v5; // ecx@5
  char v7; // [sp+4h] [bp-Ch]@1
  char v8; // [sp+8h] [bp-8h]@1
  unsigned int v9; // [sp+Ch] [bp-4h]@1

  v9 = (unsigned int)&v7 ^ __security_cookie;
  sub_1002B6B7((int)&v8, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    sub_1002B6E4(&v8);
    return 0;
  }
  v3 = *(_DWORD *)(dword_10076638 + 4 * a2);
  sub_1002B6E4(&v8);
  if ( !v3 || *(_WORD *)(v3 + 56) != word_10074F78 )
    return 0;
  v4 = 10000000i64 * a3;
  v5 = *(_DWORD *)(v3 + 8);
  return v5
      && *(_BYTE *)(v5 + 112) & 4
      && *(_DWORD *)(v3 + 348) == 1
      && *(_DWORD *)(v3 + 344) == 2
      && *(_DWORD *)(v3 + 352) == (_DWORD)v4
      && *(_DWORD *)(v3 + 356) == HIDWORD(v4);
}
// 10073200: using guessed type int __security_cookie;
// 10074F78: using guessed type __int16 word_10074F78;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (100012D0) --------------------------------------------------------
signed int __userpurge S2_CloseLong<eax>(int a1<ebx>, unsigned int a2, __int64 a3)
{
  signed int result; // eax@7
  char v13; // [sp+4h] [bp-8h]@1
  unsigned int v14; // [sp+8h] [bp-4h]@1
  int v15; // [sp+Ch] [bp+0h]@1

  v14 = (unsigned int)&v15 ^ __security_cookie;
  sub_1002B6B7((int)&v13, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    sub_1002B6E4(&v13);
    return 0;
  }
  _ESI = *(_DWORD *)(dword_10076638 + 4 * a2);
  sub_1002B6E4(&v13);
  if ( !_ESI || *(_WORD *)(_ESI + 56) != word_10074F78 )
    return 0;
  __asm
  {
    movsd   xmm0, qword ptr [esi+138h]
    mulsd   xmm0, qword ptr [esi+88h]
    movsd   xmm1, qword ptr [esi+148h]
    subsd   xmm1, qword ptr [esi+150h]
    mulsd   xmm0, qword ptr [esi+80h]
    mulsd   xmm0, ds:qword_10068478
    comisd  xmm1, xmm0
  }
  if ( _CF )
    goto LABEL_13;
  __asm
  {
    movsd   xmm0, [ebp+arg_4]
    comisd  xmm0, ds:qword_10068450
  }
  if ( _CF | _ZF )
LABEL_13:
    result = 0;
  else
    result = 1;
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10074F78: using guessed type __int16 word_10074F78;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (100013C0) --------------------------------------------------------
signed int __userpurge S2_CloseShort<eax>(int a1<ebx>, unsigned int a2, __int64 a3)
{
  signed int result; // eax@7
  char v13; // [sp+4h] [bp-8h]@1
  unsigned int v14; // [sp+8h] [bp-4h]@1
  int v15; // [sp+Ch] [bp+0h]@1

  v14 = (unsigned int)&v15 ^ __security_cookie;
  sub_1002B6B7((int)&v13, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    sub_1002B6E4(&v13);
    return 0;
  }
  _ESI = *(_DWORD *)(dword_10076638 + 4 * a2);
  sub_1002B6E4(&v13);
  if ( !_ESI || *(_WORD *)(_ESI + 56) != word_10074F78 )
    return 0;
  __asm
  {
    movsd   xmm0, qword ptr [esi+138h]
    mulsd   xmm0, qword ptr [esi+88h]
    movsd   xmm1, qword ptr [esi+150h]
    subsd   xmm1, qword ptr [esi+148h]
    mulsd   xmm0, qword ptr [esi+80h]
    mulsd   xmm0, ds:qword_10068478
    comisd  xmm1, xmm0
  }
  if ( _CF )
    goto LABEL_13;
  __asm
  {
    movsd   xmm0, [ebp+arg_4]
    comisd  xmm0, ds:qword_10068450
  }
  if ( _CF | _ZF )
LABEL_13:
    result = 0;
  else
    result = 1;
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10074F78: using guessed type __int16 word_10074F78;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (100014B0) --------------------------------------------------------
char __userpurge S3_SetIndicators<al>(int a1<ebx>, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9)
{
  __int16 v9; // ax@3
  char v12; // [sp+4h] [bp-Ch]@1
  char v13; // [sp+8h] [bp-8h]@1
  unsigned int v14; // [sp+Ch] [bp-4h]@1

  v14 = (unsigned int)&v12 ^ __security_cookie;
  sub_1002B6B7((int)&v13, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    LOBYTE(v9) = sub_1002B6E4(&v13);
  }
  else
  {
    _ESI = *(_DWORD *)(dword_10076638 + 4 * a2);
    LOBYTE(v9) = sub_1002B6E4(&v13);
    if ( _ESI )
    {
      v9 = *(_WORD *)(_ESI + 56);
      if ( v9 == word_10074F7C )
      {
        __asm
        {
          movsd   xmm0, [ebp+arg_4]
          movsd   qword ptr [esi+148h], xmm0
          movsd   xmm0, [ebp+arg_C]
          movsd   qword ptr [esi+150h], xmm0
          movsd   xmm0, [ebp+arg_14]
          movsd   qword ptr [esi+158h], xmm0
          movsd   xmm0, [ebp+arg_1C]
          movsd   qword ptr [esi+160h], xmm0
          movsd   xmm0, [ebp+arg_24]
          movsd   qword ptr [esi+168h], xmm0
          movsd   xmm0, [ebp+arg_2C]
          movsd   qword ptr [esi+170h], xmm0
          movsd   xmm0, [ebp+arg_34]
          movsd   qword ptr [esi+178h], xmm0
        }
      }
    }
  }
  return v9;
}
// 10073200: using guessed type int __security_cookie;
// 10074F7C: using guessed type __int16 word_10074F7C;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (100015A0) --------------------------------------------------------
char __userpurge S3_OpenLong<al>(int a1<ebx>, unsigned int a2)
{
  int v2; // esi@3
  int v3; // eax@5
  char v5; // [sp+4h] [bp-8h]@1
  unsigned int v6; // [sp+8h] [bp-4h]@1
  int v7; // [sp+Ch] [bp+0h]@1

  v6 = (unsigned int)&v7 ^ __security_cookie;
  sub_1002B6B7((int)&v5, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    sub_1002B6E4(&v5);
LABEL_7:
    LOBYTE(v3) = 0;
    return v3;
  }
  v2 = *(_DWORD *)(dword_10076638 + 4 * a2);
  sub_1002B6E4(&v5);
  if ( !v2 || *(_WORD *)(v2 + 56) != word_10074F7C )
    goto LABEL_7;
  return sub_100212A0(v2);
}
// 10073200: using guessed type int __security_cookie;
// 10074F7C: using guessed type __int16 word_10074F7C;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (10001630) --------------------------------------------------------
char __userpurge S3_OpenShort<al>(int a1<ebx>, unsigned int a2)
{
  int v2; // esi@3
  int v3; // eax@5
  char v5; // [sp+4h] [bp-8h]@1
  unsigned int v6; // [sp+8h] [bp-4h]@1
  int v7; // [sp+Ch] [bp+0h]@1

  v6 = (unsigned int)&v7 ^ __security_cookie;
  sub_1002B6B7((int)&v5, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    sub_1002B6E4(&v5);
LABEL_7:
    LOBYTE(v3) = 0;
    return v3;
  }
  v2 = *(_DWORD *)(dword_10076638 + 4 * a2);
  sub_1002B6E4(&v5);
  if ( !v2 || *(_WORD *)(v2 + 56) != word_10074F7C )
    goto LABEL_7;
  return sub_10021330(v2);
}
// 10073200: using guessed type int __security_cookie;
// 10074F7C: using guessed type __int16 word_10074F7C;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (100016C0) --------------------------------------------------------
int __thiscall sub_100016C0(int this, int a2)
{
  int v2; // ebx@1
  int v3; // edi@1
  int v4; // esi@1

  v2 = this;
  *(_DWORD *)this = *(_DWORD *)a2;
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(this + 12) = *(_DWORD *)(a2 + 12);
  v3 = this + 20;
  *(_DWORD *)(this + 16) = *(_DWORD *)(a2 + 16);
  v4 = a2 + 20;
  *(_DWORD *)(this + 40) = 15;
  *(_DWORD *)(this + 36) = 0;
  *(_BYTE *)(this + 20) = 0;
  if ( *(_DWORD *)(a2 + 40) >= 0x10u )
  {
    *(_DWORD *)v3 = *(_DWORD *)v4;
    *(_DWORD *)v4 = 0;
  }
  else
  {
    if ( *(_DWORD *)(a2 + 36) != -1 )
      sub_1002A4B0((void *)(this + 20), (const void *)(a2 + 20), *(_DWORD *)(a2 + 36) + 1);
  }
  *(_DWORD *)(v3 + 16) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(v3 + 20) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a2 + 40) = 15;
  *(_DWORD *)(a2 + 36) = 0;
  *(_BYTE *)v4 = 0;
  return v2;
}

//----- (10001750) --------------------------------------------------------
char __cdecl sub_10001750(int a1, int a2)
{
  return *(_QWORD *)a1 < *(_QWORD *)a2;
}

//----- (10001780) --------------------------------------------------------
bool __fastcall sub_10001780(int a1, int a2)
{
  int v2; // eax@1

  v2 = *(_DWORD *)(a2 + 4);
  return v2 > *(_DWORD *)(a1 + 4) || v2 >= *(_DWORD *)(a1 + 4) && *(_DWORD *)a2 >= *(_DWORD *)a1;
}

//----- (100017B0) --------------------------------------------------------
int __thiscall sub_100017B0(void *this, int a2)
{
  void *v2; // edi@1
  int result; // eax@7

  v2 = this;
  if ( *(_DWORD *)(a2 + 20) >= 0x10u )
  {
    if ( this )
      *(_DWORD *)this = *(_DWORD *)a2;
    *(_DWORD *)a2 = 0;
  }
  else
  {
    if ( *(_DWORD *)(a2 + 16) != -1 )
      sub_1002A4B0(this, (const void *)a2, *(_DWORD *)(a2 + 16) + 1);
  }
  *((_DWORD *)v2 + 4) = *(_DWORD *)(a2 + 16);
  result = *(_DWORD *)(a2 + 20);
  *((_DWORD *)v2 + 5) = result;
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  return result;
}

//----- (10001810) --------------------------------------------------------
int __thiscall sub_10001810(int this, int a2)
{
  int v2; // edi@1
  int result; // eax@5

  v2 = this;
  *(_DWORD *)(this + 20) = 15;
  *(_DWORD *)(this + 16) = 0;
  *(_BYTE *)this = 0;
  if ( *(_DWORD *)(a2 + 20) >= 0x10u )
  {
    *(_DWORD *)this = *(_DWORD *)a2;
    *(_DWORD *)a2 = 0;
  }
  else
  {
    if ( *(_DWORD *)(a2 + 16) != -1 )
      sub_1002A4B0((void *)this, (const void *)a2, *(_DWORD *)(a2 + 16) + 1);
  }
  *(_DWORD *)(v2 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(v2 + 20) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  result = v2;
  *(_BYTE *)a2 = 0;
  return result;
}

//----- (10001880) --------------------------------------------------------
int __thiscall sub_10001880(int this)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = this;
  if ( *(_DWORD *)(this + 20) >= 0x10u )
    result = sub_1002A4AA(*(LPVOID *)this);
  *(_DWORD *)(v1 + 20) = 15;
  *(_DWORD *)(v1 + 16) = 0;
  *(_BYTE *)v1 = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100018D0) --------------------------------------------------------
void *__thiscall sub_100018D0(void *this)
{
  return this;
}

//----- (100018E0) --------------------------------------------------------
int __thiscall sub_100018E0(int this, int a2)
{
  char v2; // cf@1
  int result; // eax@2

  v2 = *(_DWORD *)(this + 20) < 0x10u;
  *(_DWORD *)(this + 16) = a2;
  if ( v2 )
  {
    *(_BYTE *)(this + a2) = 0;
  }
  else
  {
    result = *(_DWORD *)this;
    *(_BYTE *)(*(_DWORD *)this + a2) = 0;
  }
  return result;
}

//----- (10001910) --------------------------------------------------------
void *__userpurge sub_10001910<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_1002AF18(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10001950) --------------------------------------------------------
int __userpurge sub_10001950<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int *a4)
{
  int v4; // edi@1
  int v5; // ecx@3
  int v6; // edx@5
  int v7; // edx@6
  int v8; // esi@7
  char v10; // [sp-10h] [bp-CCh]@6
  int v11; // [sp-Ch] [bp-C8h]@6
  int v12; // [sp-8h] [bp-C4h]@6
  int v13; // [sp-4h] [bp-C0h]@6
  int (__stdcall **v14)(char); // [sp+Ch] [bp-B0h]@1
  int v15; // [sp+18h] [bp-A4h]@7
  int v16; // [sp+20h] [bp-9Ch]@7
  char v17; // [sp+24h] [bp-98h]@5
  int v18; // [sp+2Ch] [bp-90h]@1
  int v19; // [sp+30h] [bp-8Ch]@1
  char v20; // [sp+34h] [bp-88h]@1
  int v21; // [sp+38h] [bp-84h]@1
  int v22; // [sp+4Ch] [bp-70h]@1
  int v23; // [sp+5Ch] [bp-60h]@1
  int v24; // [sp+6Ch] [bp-50h]@5
  unsigned int v25; // [sp+70h] [bp-4Ch]@3
  int v26; // [sp+74h] [bp-48h]@1
  int v27; // [sp+78h] [bp-44h]@1
  int v28; // [sp+7Ch] [bp-40h]@1
  int v29; // [sp+80h] [bp-3Ch]@1
  int v30; // [sp+84h] [bp-38h]@1
  unsigned int v31; // [sp+A8h] [bp-14h]@1
  int v32; // [sp+B8h] [bp-4h]@1

  v31 = (unsigned int)&v14 ^ __security_cookie;
  v4 = a2;
  v21 = 0;
  v22 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  sub_1000DDF0(a1, (int)&v20, a3, a2);
  v32 = 0;
  v18 &= 0xFFFFFE00u;
  v19 = 0;
  LOBYTE(v32) = 2;
  if ( &v23 != a4 )
    loc_1000AB40(&v23, a4, 0, -1);
  v5 = (int)&v23;
  if ( v25 >= 0x10 )
    v5 = v23;
  if ( sub_1000DF00((int)&v20, v5, v5 + v24, (int)&v17, v5) )
  {
    sub_10010010((int)&v14, v6, (int)&v17);
    LOBYTE(v32) = 3;
    sub_10010010((int)&v10, v7, (int)&v14);
    sub_10002F80(v4 + 84, a3, v10, v11, v12, v13);
    LOBYTE(v32) = 2;
    sub_100101D0((int)&v14, a3);
  }
  else
  {
    v8 = *(_DWORD *)(v4 + 80);
    v16 = (int)"Json parsing failed";
    sub_1002AEA4((int)&v14, &v16);
    v14 = &off_1006720C;
    v15 = v8;
    LOBYTE(v32) = 4;
    sub_100035E0(v4, (int)&v14);
    sub_1002AF18((int)&v14, a3);
  }
  LOBYTE(v32) = 0;
  sub_100101D0((int)&v17, a3);
  return sub_10001B00((int)&v20);
}
// 1006720C: using guessed type int (__stdcall *off_1006720C)(char);
// 10073200: using guessed type int __security_cookie;

//----- (10001B00) --------------------------------------------------------
int __thiscall sub_10001B00(int this)
{
  int v1; // edi@1
  int result; // eax@5

  v1 = this;
  if ( *(_DWORD *)(this + 104) >= 0x10u )
    sub_1002A4AA(*(LPVOID *)(this + 84));
  *(_DWORD *)(v1 + 104) = 15;
  *(_DWORD *)(v1 + 100) = 0;
  *(_BYTE *)(v1 + 84) = 0;
  if ( *(_DWORD *)(v1 + 60) >= 0x10u )
    sub_1002A4AA(*(LPVOID *)(v1 + 40));
  *(_DWORD *)(v1 + 60) = 15;
  *(_DWORD *)(v1 + 56) = 0;
  *(_BYTE *)(v1 + 40) = 0;
  sub_10002D80(v1 + 20);
  sub_1002A4AA(*(LPVOID *)(v1 + 20));
  *(_DWORD *)(v1 + 20) = 0;
  sub_10002D20(v1);
  result = sub_1002A4AA(*(LPVOID *)v1);
  *(_DWORD *)v1 = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10001BD0) --------------------------------------------------------
int __userpurge sub_10001BD0<eax>(int a1<ecx>, int a2<edi>, void *a3, int a4, int a5, int a6, int a7, unsigned int a8, __int64 a9, __int64 a10)
{
  int v10; // ebx@1
  int v11; // esi@1
  int v12; // ecx@1
  int v13; // edx@1
  int v14; // eax@1
  unsigned int v16; // eax@4
  int v17; // ecx@4
  int v18; // ebx@7
  signed int v19; // ecx@8
  signed int v20; // edx@8
  signed int v21; // ecx@14
  int v22; // esi@14
  signed int v23; // edx@14
  int v24; // ecx@20
  int v25; // eax@20
  int v26; // eax@21
  int v27; // eax@23
  int v28; // esi@25
  char v43; // [sp-30h] [bp-80h]@1
  int v44; // [sp-2Ch] [bp-7Ch]@1
  int v45; // [sp-28h] [bp-78h]@1
  int v46; // [sp-24h] [bp-74h]@1
  void *v47; // [sp-18h] [bp-68h]@1
  int v48; // [sp-14h] [bp-64h]@1
  int v49; // [sp-10h] [bp-60h]@1
  int v50; // [sp-Ch] [bp-5Ch]@1
  int v51; // [sp-8h] [bp-58h]@1
  signed int v52; // [sp-4h] [bp-54h]@1
  void *v53; // [sp+10h] [bp-40h]@1
  int v54; // [sp+20h] [bp-30h]@1
  unsigned int v55; // [sp+24h] [bp-2Ch]@1
  char v56; // [sp+2Ch] [bp-24h]@23
  int v57; // [sp+30h] [bp-20h]@4
  int v58; // [sp+34h] [bp-1Ch]@7
  int v59; // [sp+38h] [bp-18h]@1
  int v60; // [sp+3Ch] [bp-14h]@1
  int v61; // [sp+40h] [bp-10h]@1
  int v62; // [sp+4Ch] [bp-4h]@1

  v11 = a1;
  v61 = a1;
  v59 = a1;
  v52 = -1;
  v62 = 0;
  v51 = 0;
  *(_DWORD *)(a1 + 20) = 15;
  *(_DWORD *)(a1 + 16) = 0;
  v50 = (int)&a3;
  *(_BYTE *)a1 = 0;
  loc_1000AB40(v50, v51, v52);
  *(_QWORD *)(v11 + 24) = a9;
  *(_QWORD *)(v11 + 32) = a10;
  v60 = v11 + 40;
  *(_DWORD *)(v11 + 40) = 0;
  *(_DWORD *)(v11 + 44) = 0;
  *(_DWORD *)(v11 + 48) = 0;
  *(_DWORD *)(v11 + 52) = 0;
  v49 = v12;
  *(_DWORD *)(v11 + 56) = 0;
  *(_DWORD *)(v11 + 60) = 0;
  sub_10006BC0(v13, v11 + 56, a2, v49);
  v49 = -1;
  LOBYTE(v62) = 3;
  v48 = 0;
  v47 = &a3;
  v55 = 15;
  v54 = 0;
  LOBYTE(v53) = 0;
  loc_1000AB40(&v53);
  LOBYTE(v62) = 4;
  v43 = 0;
  loc_1000AB40(&v53, 0, -1, *(_DWORD *)&v43, v44, v45, v46, 0, 15);
  v14 = sub_10003CB0((int)&byte_10076530, (int)&unk_10076550, v47, v48, v49, v50, v51, v52);
  LOBYTE(v62) = 3;
  v10 = v14;
  if ( v55 >= 0x10 )
    sub_1002A4AA(v53);
  _EDI = -1;
  v55 = 15;
  v54 = 0;
  LOBYTE(v53) = 0;
  if ( (_UNKNOWN *)v10 != &unk_10076550 )
  {
    v17 = *(_DWORD *)(v10 + 28);
    v16 = *(_DWORD *)(v17 - 40);
    v57 = *(_DWORD *)(v10 + 28);
    if ( HIDWORD(a9) <= *(_DWORD *)(v17 - 36) )
    {
      if ( HIDWORD(a9) < *(_DWORD *)(v17 - 36) || (_DWORD)a9 < v16 )
      {
        v18 = *(_DWORD *)(v10 + 24);
        v58 = v18;
        if ( a10 >= *(_QWORD *)v18 )
        {
          v20 = (signed int)((unsigned __int64)(715827883i64 * (v17 - v18)) >> 32) >> 3;
          v19 = v20 + ((unsigned int)v20 >> 31);
          if ( v19 > 0 )
          {
            do
            {
              if ( *(_QWORD *)(v18 + 48 * v19 / 2 + 8) >= a9 )
              {
                v19 /= 2;
              }
              else
              {
                v18 += 48 * v19 / 2 + 48;
                v19 += -1 - v19 / 2;
              }
            }
            while ( v19 > 0 );
            v58 = v18;
          }
          v23 = (signed int)((unsigned __int64)(715827883i64 * (v57 - v18)) >> 32) >> 3;
          v21 = v23 + ((unsigned int)v23 >> 31);
          v22 = v18;
          if ( v21 > 0 )
          {
            do
            {
              if ( *(_QWORD *)(v22 + 48 * v21 / 2 + 8) >= a10 )
              {
                v21 /= 2;
              }
              else
              {
                v22 += 48 * v21 / 2 + 48;
                v21 += -1 - v21 / 2;
              }
            }
            while ( v21 > 0 );
            v18 = v58;
          }
          v52 = v59;
          v51 = v21;
          sub_10004310(*(_DWORD *)v60, *(_DWORD *)(v60 + 4));
          v24 = v60;
          v25 = *(_DWORD *)v60;
          v52 = v59;
          *(_DWORD *)(v60 + 4) = v25;
          sub_10004EF0(v24, v25, v18, v22, v52);
          v11 = v61;
        }
      }
    }
  }
  v26 = *(_DWORD *)(v11 + 52);
  if ( !v26 || v26 == 3 )
  {
    v27 = sub_10002130(v11, (int)&v56);
    if ( v11 + 56 != v27 )
      sub_1000A010((void *)(v11 + 56), v27);
    v28 = v57;
    if ( v57 )
    {
      _EAX = v57 + 4;
      _ECX = -1;
      __asm { lock xadd [eax], ecx }
      if ( _ZF )
      {
        (**(void (__thiscall ***)(_DWORD))v28)(v28);
        _EAX = v28 + 8;
        __asm { lock xadd [eax], edi }
        if ( _EDI == 1 )
          (*(void (__thiscall **)(int))(*(_DWORD *)v28 + 4))(v28);
      }
    }
    v11 = v61;
  }
  if ( a8 >= 0x10 )
    sub_1002A4AA(a3);
  return v11;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10076530: using guessed type char byte_10076530;

//----- (10001EA0) --------------------------------------------------------
signed int __usercall sub_10001EA0<eax>(int a1<ecx>, int a2<ebx>)
{
  signed int result; // eax@1
  int v3; // esi@1
  int v4; // ecx@2
  int v5; // edi@5
  int v18; // ecx@9
  char v19; // [sp+14h] [bp-1Ch]@3
  int v20; // [sp+20h] [bp-10h]@1
  int v21; // [sp+24h] [bp-Ch]@1
  int v22; // [sp+2Ch] [bp-4h]@1

  result = (signed int)&v21;
  v3 = a1;
  v20 = a1;
  v22 = 2;
  if ( *(_DWORD *)(a1 + 52) == 1 )
  {
    v4 = *(_DWORD *)(a1 + 56);
    if ( !v4 )
    {
      sub_1002FFB9((int)&v19, (unsigned int)"wait() cannot be called on a default constructed task.");
      sub_100355BB((int)&v19, (int)&unk_1006C878);
    }
    result = sub_10009F10(v4, a2);
  }
  LOBYTE(v22) = 1;
  v5 = *(_DWORD *)(v3 + 60);
  if ( v5 )
  {
    _EBX = -1;
    _ECX = v5 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      result = v5 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
    }
  }
  v18 = *(_DWORD *)(v3 + 40);
  if ( v18 )
  {
    sub_10004310(v18, *(_DWORD *)(v3 + 44));
    result = sub_1002A4AA(*(LPVOID *)(v3 + 40));
    *(_DWORD *)(v3 + 40) = 0;
    *(_DWORD *)(v3 + 44) = 0;
    *(_DWORD *)(v3 + 48) = 0;
  }
  if ( *(_DWORD *)(v3 + 20) >= 0x10u )
    result = sub_1002A4AA(*(LPVOID *)v3);
  *(_DWORD *)(v3 + 20) = 15;
  *(_DWORD *)(v3 + 16) = 0;
  *(_BYTE *)v3 = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10001FA0) --------------------------------------------------------
char __thiscall sub_10001FA0(int this, void *a2, int a3, int a4, int a5, unsigned int a6, unsigned int a7, __int64 a8, __int64 a9)
{
  unsigned int v9; // edi@1
  int v10; // esi@1
  int v11; // edx@2
  int v12; // ecx@4
  unsigned int v13; // ebx@4
  unsigned int v14; // eax@6
  int v15; // eax@8
  int v16; // eax@11
  int v17; // eax@14
  char v18; // bl@17

  v10 = this;
  v9 = *(_DWORD *)(this + 16);
  if ( *(_DWORD *)(this + 20) < 0x10u )
    v11 = this;
  else
    v11 = *(_DWORD *)this;
  v13 = a6;
  v12 = (int)&a2;
  if ( a7 >= 0x10 )
    v12 = (int)a2;
  v14 = v9;
  if ( a6 < v9 )
    v14 = a6;
  v15 = sub_100099E0(v12, v11, v14);
  v18 = !v15
     && v13 >= v9
     && (LOBYTE(v15) = v13 != v9, !v15)
     && (v16 = (unsigned __int64)(a8 + qword_10074E70) >> 32, v16 >= *(_DWORD *)(v10 + 28))
     && (v16 > *(_DWORD *)(v10 + 28) || (unsigned int)(a8 + (_DWORD)qword_10074E70) >= *(_DWORD *)(v10 + 24))
     && (v17 = (unsigned __int64)(a9 - qword_10074E70) >> 32, *(_DWORD *)(v10 + 36) >= v17)
     && (*(_DWORD *)(v10 + 36) > v17 || *(_DWORD *)(v10 + 32) >= (unsigned int)(a9 - (_DWORD)qword_10074E70));
  if ( a7 >= 0x10 )
    sub_1002A4AA(a2);
  return v18;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074E70: using guessed type __int64 qword_10074E70;

//----- (10002040) --------------------------------------------------------
char __thiscall sub_10002040(int this, int a2, __int64 a3)
{
  int v3; // esi@2
  int v4; // ebx@3
  signed int v5; // ecx@6
  signed int v6; // edx@6
  int v7; // eax@7
  char result; // al@12

  if ( *(_DWORD *)(this + 52) != 2 )
    goto LABEL_16;
  v3 = *(_DWORD *)(this + 40);
  if ( v3 == *(_DWORD *)(this + 44) )
    goto LABEL_16;
  v4 = *(_DWORD *)(this + 44);
  if ( *(_DWORD *)(v4 - 36) < HIDWORD(a3) )
    goto LABEL_16;
  if ( *(_DWORD *)(v4 - 36) <= HIDWORD(a3) && *(_DWORD *)(v4 - 40) < (_DWORD)a3 )
    goto LABEL_16;
  v6 = (signed int)((unsigned __int64)(715827883i64 * (v4 - v3)) >> 32) >> 3;
  v5 = v6 + ((unsigned int)v6 >> 31);
  while ( v5 > 0 )
  {
    v7 = v3 + 48 * v5 / 2;
    if ( *(_QWORD *)(v7 + 8) >= a3 )
    {
      v5 /= 2;
    }
    else
    {
      v3 = v7 + 48;
      v5 += -1 - v5 / 2;
    }
  }
  if ( v3 == v4 )
  {
LABEL_16:
    result = 0;
  }
  else
  {
    sub_100020F0(a2, v3);
    result = 1;
  }
  return result;
}

//----- (100020F0) --------------------------------------------------------
int __thiscall sub_100020F0(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = *(_DWORD *)a2;
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(this + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(this + 16) = *(_DWORD *)(a2 + 16);
  if ( this + 20 != a2 + 20 )
    loc_1000AB40(a2 + 20, 0, -1);
  return v2;
}

//----- (10002130) --------------------------------------------------------
int __thiscall sub_10002130(int this, int a2)
{
  int v2; // esi@1
  char v3; // cf@1
  int v4; // esi@3
  int v5; // eax@3
  int v6; // edx@3
  int v7; // edx@3
  int v8; // edx@3
  int v9; // eax@3
  int v10; // edx@3
  int v11; // edx@3
  int v12; // eax@3
  int v13; // edx@3
  int v14; // eax@3
  int v15; // edx@3
  int v16; // edx@3
  int v17; // edx@3
  int v18; // edx@3
  __int16 v34; // [sp-1Ch] [bp-74h]@3
  int v35; // [sp-18h] [bp-70h]@3
  int v36; // [sp-14h] [bp-6Ch]@3
  char v37; // [sp-10h] [bp-68h]@3
  int v38; // [sp-Ch] [bp-64h]@3
  signed int v39; // [sp-8h] [bp-60h]@3
  unsigned int v40; // [sp-4h] [bp-5Ch]@1
  int v41; // [sp+0h] [bp-58h]@3
  int v42; // [sp+4h] [bp-54h]@3
  int v43; // [sp+8h] [bp-50h]@3
  int v44; // [sp+Ch] [bp-4Ch]@1
  int v45; // [sp+14h] [bp-44h]@1
  unsigned int *v46; // [sp+18h] [bp-40h]@3
  char v47; // [sp+1Ch] [bp-3Ch]@3
  int v48; // [sp+24h] [bp-34h]@1
  int v49; // [sp+28h] [bp-30h]@1
  int v50; // [sp+2Ch] [bp-2Ch]@3
  int v51; // [sp+30h] [bp-28h]@3
  int v52; // [sp+34h] [bp-24h]@3
  int v53; // [sp+38h] [bp-20h]@3
  int v54; // [sp+3Ch] [bp-1Ch]@1
  int v55; // [sp+40h] [bp-18h]@1
  unsigned int v56; // [sp+44h] [bp-14h]@1
  int v57; // [sp+54h] [bp-4h]@1
  int v58; // [sp+58h] [bp+0h]@1

  v56 = (unsigned int)&v58 ^ __security_cookie;
  v40 = (unsigned int)&v58 ^ __security_cookie;
  v2 = this;
  v45 = 0;
  v48 &= 0xFFFFFE00u;
  v44 = a2;
  *(_DWORD *)(this + 52) = 1;
  v49 = 0;
  v57 = 2;
  v3 = *(_DWORD *)(this + 20) < 0x10u;
  v54 = v54 & 0xFFFFFF04 | 0x104;
  v55 = 0;
  if ( !v3 )
    this = *(_DWORD *)this;
  v52 = loc_1000FED0(this, *(_DWORD *)(v2 + 16), v40, v41, v42, v43);
  LOBYTE(v57) = 3;
  v5 = sub_10010C90((int)&v47, v6, (int)"symbol", v41);
  sub_10010260(v5, v7, (int)&v52);
  LOBYTE(v57) = 2;
  sub_100101D0((int)&v52, a2);
  *(_QWORD *)&v40 = *(_QWORD *)(v2 + 24) + 5000000i64;
  v54 = v54 & 0xFFFFFF01 | 1;
  v55 = 0;
  v52 = sub_1003AC40(*(unsigned __int64 *)&v40, 0x989680u, 0);
  v53 = v8;
  LOBYTE(v57) = 4;
  v9 = sub_10010C90((int)&v47, v8, (int)"start", v41);
  sub_10010260(v9, v10, (int)&v52);
  LOBYTE(v57) = 2;
  sub_100101D0((int)&v52, a2);
  *(_QWORD *)&v40 = *(_QWORD *)(v2 + 32) + 5000000i64;
  v54 = v54 & 0xFFFFFF01 | 1;
  v55 = 0;
  v52 = sub_1003AC40(*(unsigned __int64 *)&v40, 0x989680u, 0);
  v53 = v11;
  LOBYTE(v57) = 5;
  v12 = sub_10010C90((int)&v47, v11, (int)"end", v41);
  sub_10010260(v12, v13, (int)&v52);
  LOBYTE(v57) = 2;
  sub_100101D0((int)&v52, a2);
  v54 &= 0xFFFFFE00u;
  v55 = 0;
  LOBYTE(v57) = 7;
  v14 = sub_10010C90((int)&v52, v15, (int)"data", v41);
  sub_10010260(v14, v16, (int)&v47);
  v46 = &v40;
  v50 = 0;
  v51 = 0;
  sub_10010010((int)&v40, v17, (int)&v52);
  LOBYTE(v57) = 8;
  v39 = 7;
  v38 = 0;
  v34 = 0;
  loc_10009CC0();
  LOBYTE(v57) = 7;
  sub_100036F0(&dword_10075018, 0, -1, *(_DWORD *)&v34, v35, v36, v37);
  LOBYTE(v57) = 9;
  v46 = (unsigned int *)v2;
  sub_10003960(v18, (int)&v50, a2, a2, (int)&v46);
  LOBYTE(v57) = 7;
  v4 = v51;
  v45 = 1;
  if ( v51 )
  {
    _EDI = -1;
    _ECX = v51 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v4)(v4);
      _EAX = v4 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 4))(v4);
    }
  }
  LOBYTE(v57) = 2;
  sub_100101D0((int)&v52, a2);
  LOBYTE(v57) = 0;
  sub_100101D0((int)&v47, a2);
  return a2;
}
// 100036F0: using guessed type _DWORD __cdecl sub_100036F0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);
// 10073200: using guessed type int __security_cookie;
// 10075018: using guessed type int dword_10075018;

//----- (100023C0) --------------------------------------------------------
int __thiscall sub_100023C0(int this, char a2, int a3)
{
  int v3; // eax@1
  int v4; // edx@1
  int v5; // ecx@1
  int v6; // edi@1
  int v7; // esi@7
  int v8; // ebx@9
  int v9; // eax@12
  __int64 v10; // qax@17
  int v11; // ecx@17
  int v12; // ebx@17
  int v13; // eax@17
  int v14; // eax@17
  __int64 v15; // ST08_8@17
  __int64 v16; // qax@17
  int v17; // eax@17
  int v18; // ecx@17
  int v19; // eax@17
  __int64 v20; // qax@17
  LPVOID v21; // edi@19
  void *v22; // edi@25
  void *v23; // edi@28
  void *v24; // edi@34
  int v25; // edi@35
  int v26; // eax@35
  int v27; // eax@49
  int j; // eax@50
  int i; // eax@53
  int v30; // ebx@57
  int v31; // esi@57
  signed int v32; // edx@57
  signed int v33; // ebx@57
  int v34; // ebx@61
  int v35; // esi@61
  int v36; // esi@63
  void *v37; // esi@70
  int result; // eax@75
  void *v39; // esi@76
  int v40; // esi@77
  char v53; // [sp-4h] [bp-C8h]@1
  void *v54; // [sp+Ch] [bp-B8h]@35
  unsigned int v55; // [sp+20h] [bp-A4h]@43
  LPVOID lpMem; // [sp+24h] [bp-A0h]@17
  int v57; // [sp+2Ch] [bp-98h]@17
  int v58; // [sp+30h] [bp-94h]@24
  char v59; // [sp+38h] [bp-8Ch]@29
  void *v60; // [sp+3Ch] [bp-88h]@17
  int v61; // [sp+40h] [bp-84h]@17
  int v62; // [sp+44h] [bp-80h]@9
  int v63; // [sp+48h] [bp-7Ch]@17
  void *v64; // [sp+4Ch] [bp-78h]@1
  int v65; // [sp+54h] [bp-70h]@5
  int v66; // [sp+58h] [bp-6Ch]@1
  int v67; // [sp+60h] [bp-64h]@20
  int v68; // [sp+64h] [bp-60h]@1
  int v69; // [sp+68h] [bp-5Ch]@1
  int v70; // [sp+6Ch] [bp-58h]@1
  int v71; // [sp+70h] [bp-54h]@1
  int v72; // [sp+74h] [bp-50h]@1
  char v73; // [sp+7Bh] [bp-49h]@9
  __int64 v74; // [sp+7Ch] [bp-48h]@17
  __int64 v75; // [sp+84h] [bp-40h]@17
  int v76; // [sp+8Ch] [bp-38h]@17
  void *v77; // [sp+90h] [bp-34h]@17
  int v78; // [sp+A0h] [bp-24h]@17
  unsigned int v79; // [sp+A4h] [bp-20h]@17
  unsigned int v80; // [sp+B0h] [bp-14h]@1
  char *v81; // [sp+B4h] [bp-10h]@1
  int v82; // [sp+C0h] [bp-4h]@1
  int v83; // [sp+C4h] [bp+0h]@1

  v80 = (unsigned int)&v83 ^ __security_cookie;
  v81 = &v53;
  v68 = this;
  v72 = this;
  v82 = 0;
  LOBYTE(v82) = 1;
  v66 = 0;
  loc_10002BC0(&a2, &v64, (unsigned int)&v83 ^ __security_cookie);
  v6 = 0;
  v69 = 0;
  v70 = 0;
  v71 = 0;
  LOBYTE(v82) = 3;
  v3 = sub_10010A20(&v64);
  if ( v3 )
  {
    if ( (unsigned int)v3 > 0x5555555 )
      sub_10029585((int)"vector<T> too long");
    loc_10002E20(&v69, v3);
    v6 = v69;
  }
  if ( (unsigned int)((char)v65 - 6) <= 1 && v64 )
  {
    LOBYTE(v4) = 0;
    v7 = **(_DWORD **)v64;
  }
  else
  {
    v7 = 0;
    LOBYTE(v4) = 1;
  }
  v8 = v62;
  v73 = v4;
  while ( 1 )
  {
    if ( (unsigned int)((char)v65 - 6) <= 1 && v64 )
    {
      v9 = *(_DWORD *)v64;
      LOBYTE(v5) = 0;
    }
    else
    {
      v9 = 0;
      LOBYTE(v5) = 1;
    }
    if ( !(_BYTE)v4 )
      LOBYTE(v5) = v7 == v9;
    if ( (_BYTE)v5 )
      break;
    __asm
    {
      xorps   xmm0, xmm0
      movlpd  [ebp+var_48], xmm0
      movlpd  [ebp+var_40], xmm0
    }
    v79 = 15;
    v78 = 0;
    LOBYTE(v77) = v5;
    LOBYTE(v82) = 4;
    v13 = sub_10010C90(v7 + 24, v4, (int)"start", v5);
    v14 = loc_10010400(v13);
    *(_DWORD *)&v53 = 0;
    LODWORD(v15) = 10000000;
    v16 = sub_10039A20((unsigned int)v14, v15);
    v74 = v16;
    v17 = sub_10010C90(v7 + 24, SHIDWORD(v16), (int)"end", v18);
    v19 = loc_10010400(v17);
    *(_DWORD *)&v53 = 0;
    LODWORD(v15) = 10000000;
    v20 = sub_10039A20((unsigned int)v19, v15);
    v12 = v8 & 0xFFFFFF01 | 1;
    v75 = v20;
    v62 = v12;
    v63 = 0;
    v60 = (void *)1;
    v61 = 0;
    LOBYTE(v82) = 5;
    LODWORD(v10) = sub_10010E40(v7 + 24, SHIDWORD(v20), (int)&lpMem, (int)"class", (int)&v60);
    LOBYTE(v82) = 6;
    v76 = loc_10010400(v10);
    LOBYTE(v82) = 5;
    v11 = (char)v57;
    if ( (char)v57 == 4 )
    {
      if ( v57 & 0x100 )
      {
        if ( lpMem )
          sub_100309C2(v12, lpMem);
      }
    }
    else
    {
      if ( (unsigned int)((char)v57 - 6) <= 1 )
      {
        v21 = lpMem;
        if ( lpMem )
        {
          *(_DWORD *)&v53 = *(_DWORD *)lpMem;
          sub_100130F0(lpMem, (int)&v67, **(_DWORD **)&v53, *(int *)&v53);
          *(_DWORD *)&v53 = *(_DWORD *)v21;
          sub_1002A4AA(*(LPVOID *)&v53);
          sub_1002A4AA(v21);
        }
      }
    }
    if ( v58 )
    {
      *(_DWORD *)&v53 = sub_1000FF60;
      v22 = (void *)(v58 - 4);
      sub_1002B11F(v58, 4, *(_DWORD *)(v58 - 4), (void (__thiscall *)(_DWORD))sub_1000FF60);
      sub_100303A3(v22);
    }
    LOBYTE(v82) = 4;
    v8 = v62;
    if ( (char)v62 == 4 )
    {
      if ( v62 & 0x100 )
      {
        if ( v60 )
          sub_100309C2(v62, v60);
      }
    }
    else
    {
      if ( (unsigned int)((char)v62 - 6) <= 1 )
      {
        v23 = v60;
        if ( v60 )
        {
          *(_DWORD *)&v53 = *(_DWORD *)v60;
          sub_100130F0(v60, (int)&v59, **(_DWORD **)&v53, *(int *)&v53);
          *(_DWORD *)&v53 = *(_DWORD *)v23;
          sub_1002A4AA(*(LPVOID *)&v53);
          sub_1002A4AA(v23);
        }
      }
    }
    if ( v63 )
    {
      *(_DWORD *)&v53 = sub_1000FF60;
      v24 = (void *)(v63 - 4);
      sub_1002B11F(v63, 4, *(_DWORD *)(v63 - 4), (void (__thiscall *)(_DWORD))sub_1000FF60);
      sub_100303A3(v24);
    }
    v26 = sub_10010C90(v7 + 24, SHIDWORD(v10), (int)"comment", v11);
    v25 = loc_100102E0(v26, &v54);
    if ( &v77 != (void **)v25 )
    {
      if ( v79 >= 0x10 )
        sub_1002A4AA(v77);
      v79 = 15;
      v78 = 0;
      LOBYTE(v77) = 0;
      if ( *(_DWORD *)(v25 + 20) >= 0x10u )
      {
        v77 = *(void **)v25;
        *(_DWORD *)v25 = 0;
      }
      else
      {
        if ( *(_DWORD *)(v25 + 16) != -1 )
          sub_1002A4B0(&v77, (const void *)v25, *(_DWORD *)(v25 + 16) + 1);
      }
      v78 = *(_DWORD *)(v25 + 16);
      v79 = *(_DWORD *)(v25 + 20);
      *(_DWORD *)(v25 + 20) = 15;
      *(_DWORD *)(v25 + 16) = 0;
      *(_BYTE *)v25 = 0;
    }
    if ( v55 >= 0x10 )
      sub_1002A4AA(v54);
    sub_10002A30((int)&v69, (unsigned int)&v74);
    LOBYTE(v82) = 3;
    if ( v79 >= 0x10 )
      sub_1002A4AA(v77);
    if ( *(_BYTE *)(v7 + 13) )
    {
      v6 = v69;
      LOBYTE(v4) = v73;
    }
    else
    {
      v27 = *(_DWORD *)(v7 + 8);
      if ( *(_BYTE *)(v27 + 13) )
      {
        for ( i = *(_DWORD *)(v7 + 4); !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 4) )
        {
          if ( v7 != *(_DWORD *)(i + 8) )
            break;
          v7 = i;
        }
        v6 = v69;
        LOBYTE(v4) = v73;
        v7 = i;
      }
      else
      {
        v7 = *(_DWORD *)(v7 + 8);
        for ( j = *(_DWORD *)v27; !*(_BYTE *)(j + 13); j = *(_DWORD *)j )
          v7 = j;
        v6 = v69;
        LOBYTE(v4) = v73;
      }
    }
  }
  v32 = (signed int)((unsigned __int64)(715827883i64 * (v70 - v6)) >> 32) >> 3;
  v33 = v32 + ((unsigned int)v32 >> 31);
  sub_10005130(v6, v70, v33, (int)sub_10001750);
  v67 = *(_DWORD *)v68 + 40;
  v31 = v33 + (*(_DWORD *)(v67 + 4) - *(_DWORD *)v67) / 48;
  v30 = v67;
  if ( (*(_DWORD *)(v30 + 8) - *(_DWORD *)v30) / 48 < (unsigned int)v31 )
  {
    if ( (unsigned int)v31 > 0x5555555 )
      sub_10029585((int)"vector<T> too long");
    loc_10002E20(v30, v31);
  }
  v34 = v68;
  v35 = v70;
  sub_100037D0((void *)(*(_DWORD *)v68 + 40), v6, v70);
  *(_DWORD *)(*(_DWORD *)v34 + 52) = 2;
  if ( v6 )
  {
    if ( v6 != v35 )
    {
      v36 = v6 + 40;
      do
      {
        if ( *(_DWORD *)v36 >= 0x10u )
        {
          *(_DWORD *)&v53 = *(_DWORD *)(v36 - 20);
          sub_1002A4AA(*(LPVOID *)&v53);
        }
        *(_DWORD *)v36 = 15;
        *(_DWORD *)(v36 - 4) = 0;
        *(_BYTE *)(v36 - 20) = 0;
        v36 += 48;
      }
      while ( v36 - 40 != v70 );
    }
    sub_1002A4AA((LPVOID)v6);
  }
  LOBYTE(v82) = 1;
  if ( (char)v65 == 4 )
  {
    if ( v65 & 0x100 )
    {
      if ( v64 )
        sub_100309C2(v34, v64);
    }
  }
  else
  {
    if ( (unsigned int)((char)v65 - 6) <= 1 )
    {
      v37 = v64;
      if ( v64 )
      {
        *(_DWORD *)&v53 = *(_DWORD *)v64;
        sub_100130F0(v64, (int)&v59, **(_DWORD **)&v53, *(int *)&v53);
        *(_DWORD *)&v53 = *(_DWORD *)v37;
        sub_1002A4AA(*(LPVOID *)&v53);
        sub_1002A4AA(v37);
      }
    }
  }
  result = v66;
  if ( v66 )
  {
    *(_DWORD *)&v53 = sub_1000FF60;
    v39 = (void *)(v66 - 4);
    sub_1002B11F(v66, 4, *(_DWORD *)(v66 - 4), (void (__thiscall *)(_DWORD))sub_1000FF60);
    result = sub_100303A3(v39);
  }
  v82 = -1;
  v40 = a3;
  if ( a3 )
  {
    _EDI = -1;
    _ECX = a3 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v40)(v40);
      result = v40 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (**)(void))(*(_DWORD *)v40 + 4))();
    }
  }
  return result;
}
// 1000FF60: using guessed type int sub_1000FF60();
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10002953) --------------------------------------------------------
int (*__usercall sub_10002953<eax>(int a1<ebp>))()
{
  *(_DWORD *)(**(_DWORD **)(a1 - 80) + 52) = 3;
  return loc_10002965;
}
// 10002965: using guessed type int loc_10002965();

//----- (1000297B) --------------------------------------------------------
int (*__usercall sub_1000297B<eax>(int a1<ebp>))()
{
  *(_DWORD *)(**(_DWORD **)(a1 - 80) + 52) = 3;
  return loc_1000298D;
}
// 1000298D: using guessed type int loc_1000298D();

//----- (100029F0) --------------------------------------------------------
int __thiscall sub_100029F0(void *this)
{
  int v1; // ecx@1
  void *v2; // esi@1
  int result; // eax@2

  v2 = this;
  v1 = *(_DWORD *)this;
  if ( v1 )
  {
    sub_10004310(v1, *((_DWORD *)v2 + 1));
    result = sub_1002A4AA(*(LPVOID *)v2);
    *(_DWORD *)v2 = 0;
    *((_DWORD *)v2 + 1) = 0;
    *((_DWORD *)v2 + 2) = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10002A30) --------------------------------------------------------
int __thiscall sub_10002A30(int this, unsigned int a2)
{
  signed __int64 v2; // qax@1
  unsigned int v3; // ecx@1
  int v4; // esi@1
  int v5; // edi@3
  int v6; // edx@5
  int v7; // ecx@5
  int v8; // eax@6
  int v9; // ecx@11
  int v11; // [sp+10h] [bp-Ch]@1
  int v12; // [sp+18h] [bp-4h]@5

  LODWORD(v2) = &v11;
  v4 = this;
  v3 = *(_DWORD *)(this + 4);
  if ( a2 >= v3 || (LODWORD(v2) = *(_DWORD *)v4, *(_DWORD *)v4 > a2) )
  {
    if ( v3 == *(_DWORD *)(v4 + 8) )
      LODWORD(v2) = loc_10002ED0(v4, 1);
    v7 = *(_DWORD *)(v4 + 4);
    v12 = 1;
    if ( v7 )
    {
      *(_DWORD *)v7 = *(_DWORD *)a2;
      *(_DWORD *)(v7 + 4) = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(v7 + 8) = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(v7 + 12) = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(v7 + 16) = *(_DWORD *)(a2 + 16);
      v8 = a2 + 20;
      goto LABEL_11;
    }
  }
  else
  {
    v2 = 715827883i64 * (signed int)(a2 - v2);
    v5 = (HIDWORD(v2) >> 3) + (HIDWORD(v2) >> 31);
    if ( v3 == *(_DWORD *)(v4 + 8) )
      LODWORD(v2) = loc_10002ED0(v4, 1);
    v7 = *(_DWORD *)(v4 + 4);
    v6 = *(_DWORD *)v4 + 48 * v5;
    v12 = 0;
    if ( v7 )
    {
      *(_DWORD *)v7 = *(_DWORD *)v6;
      *(_DWORD *)(v7 + 4) = *(_DWORD *)(v6 + 4);
      *(_DWORD *)(v7 + 8) = *(_DWORD *)(v6 + 8);
      *(_DWORD *)(v7 + 12) = *(_DWORD *)(v6 + 12);
      *(_DWORD *)(v7 + 16) = *(_DWORD *)(v6 + 16);
      v8 = v6 + 20;
LABEL_11:
      v9 = v7 + 20;
      *(_DWORD *)(v9 + 20) = 15;
      *(_DWORD *)(v9 + 16) = 0;
      *(_BYTE *)v9 = 0;
      LODWORD(v2) = loc_1000AB40(v8, 0, -1);
      goto LABEL_12;
    }
  }
LABEL_12:
  *(_DWORD *)(v4 + 4) += 48;
  return v2;
}

//----- (10002B40) --------------------------------------------------------
int __thiscall sub_10002B40(int this, char a2, int a3)
{
  int v3; // esi@1
  char v5; // [sp-8h] [bp-20h]@2
  int v6; // [sp-4h] [bp-1Ch]@2
  int v7; // [sp+14h] [bp-4h]@1

  v3 = this;
  v7 = 0;
  if ( *(_DWORD *)(this + 12) != 3 )
  {
    sub_1002FD39((int)&v5, (int)&a2);
    sub_10003180((void *)(v3 + 84), v5, v6);
  }
  v7 = -1;
  return sub_1002FDDA((int)&a2);
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);

//----- (10002C30) --------------------------------------------------------
int __thiscall sub_10002C30(int this, unsigned __int8 *a2, int a3, unsigned int a4)
{
  int result; // eax@2
  unsigned int v5; // edi@3
  int v6; // edi@5
  int v7; // eax@8
  int v8; // ebx@8
  unsigned __int8 *v9; // esi@8
  int v10; // edx@9
  int v11; // ecx@9
  char v12; // cf@11
  int v13; // eax@21
  int v14; // [sp+0h] [bp-8h]@1
  int v15; // [sp+4h] [bp-4h]@7

  v14 = this;
  if ( a4 )
  {
    v5 = *(_DWORD *)(this + 16);
    if ( v5 && a4 <= v5 )
    {
      v6 = 1 - a4 + v5;
      if ( *(_DWORD *)(this + 20) >= 0x10u )
        this = *(_DWORD *)this;
      while ( 1 )
      {
        v15 = this;
        if ( !v6 )
          break;
        v9 = a2;
        v7 = sub_10030100(this, *a2, v6);
        v8 = v7;
        if ( !v7 )
          break;
        v10 = v7;
        v11 = a4 - 4;
        if ( a4 < 4 )
        {
LABEL_12:
          if ( v11 == -4 )
            goto LABEL_21;
        }
        else
        {
          while ( *(_DWORD *)v10 == *(_DWORD *)v9 )
          {
            v10 += 4;
            v9 += 4;
            v12 = (unsigned int)v11 < 4;
            v11 -= 4;
            if ( v12 )
              goto LABEL_12;
          }
        }
        if ( *(_BYTE *)v10 == *v9
          && (v11 == -3
           || *(_BYTE *)(v10 + 1) == v9[1]
           && (v11 == -2 || *(_BYTE *)(v10 + 2) == v9[2] && (v11 == -1 || *(_BYTE *)(v10 + 3) == v9[3]))) )
        {
LABEL_21:
          v13 = v14;
          if ( *(_DWORD *)(v14 + 20) >= 0x10u )
            v13 = *(_DWORD *)v14;
          return v8 - v13;
        }
        v6 += v15 - v7 - 1;
        this = v7 + 1;
      }
    }
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10002D20) --------------------------------------------------------
int __thiscall sub_10002D20(int this)
{
  int v1; // eax@1
  int v2; // esi@1
  int v3; // edi@6
  int result; // eax@10

  v2 = this;
  v1 = *(_DWORD *)(this + 16);
  if ( v1 )
  {
    do
    {
      --v1;
      if ( !v1 )
        *(_DWORD *)(this + 12) = 0;
    }
    while ( v1 );
    *(_DWORD *)(this + 16) = 0;
  }
  v3 = *(_DWORD *)(this + 8);
  while ( v3 )
  {
    --v3;
    if ( *(_DWORD *)(*(_DWORD *)(v2 + 4) + 4 * v3) )
      sub_1002A4AA(*(LPVOID *)(*(_DWORD *)(v2 + 4) + 4 * v3));
  }
  result = *(_DWORD *)(v2 + 4);
  if ( result )
    result = sub_1002A4AA(*(LPVOID *)(v2 + 4));
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10002D80) --------------------------------------------------------
int __thiscall sub_10002D80(int this)
{
  int v1; // ecx@1
  int v2; // esi@1
  int v3; // edi@2
  char v4; // zf@4
  int v5; // edi@7
  int result; // eax@11

  v2 = this;
  v1 = *(_DWORD *)(this + 16);
  while ( v1 )
  {
    v3 = *(_DWORD *)(*(_DWORD *)(v2 + 4) + 4 * ((v1 + *(_DWORD *)(v2 + 12) - 1) & (*(_DWORD *)(v2 + 8) - 1)));
    if ( *(_DWORD *)(v3 + 32) >= 0x10u )
      sub_1002A4AA(*(LPVOID *)(v3 + 12));
    *(_DWORD *)(v3 + 32) = 15;
    *(_DWORD *)(v3 + 28) = 0;
    *(_BYTE *)(v3 + 12) = 0;
    v4 = *(_DWORD *)(v2 + 16)-- == 1;
    v1 = *(_DWORD *)(v2 + 16);
    if ( v4 )
      *(_DWORD *)(v2 + 12) = 0;
  }
  v5 = *(_DWORD *)(v2 + 8);
  while ( v5 )
  {
    --v5;
    if ( *(_DWORD *)(*(_DWORD *)(v2 + 4) + 4 * v5) )
      sub_1002A4AA(*(LPVOID *)(*(_DWORD *)(v2 + 4) + 4 * v5));
  }
  result = *(_DWORD *)(v2 + 4);
  if ( result )
    result = sub_1002A4AA(*(LPVOID *)(v2 + 4));
  *(_DWORD *)(v2 + 4) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10002F80) --------------------------------------------------------
char __userpurge sub_10002F80<al>(int a1<ecx>, int a2<ebx>, char a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int ebp0; // ebp@0
  int v8; // esi@1
  int v9; // edx@3
  int v10; // ecx@3
  int v11; // edi@3
  int v12; // ecx@5
  int v13; // eax@6
  int v14; // edx@8
  int v15; // esi@9
  int v16; // edi@10
  int v17; // ecx@10
  int v18; // edx@10
  int v19; // eax@15
  int v20; // esi@16
  char v36; // [sp+Ch] [bp-50h]@10
  int v37; // [sp+1Ch] [bp-40h]@3
  int v38; // [sp+20h] [bp-3Ch]@3
  int v39; // [sp+24h] [bp-38h]@3
  int v40; // [sp+28h] [bp-34h]@1
  char v41; // [sp+2Fh] [bp-2Dh]@3
  unsigned int v42; // [sp+4Ch] [bp-10h]@1
  int v43; // [sp+58h] [bp-4h]@1
  int v44; // [sp+5Ch] [bp+0h]@1

  v42 = (unsigned int)&v44 ^ __security_cookie;
  v8 = a1;
  v40 = a1;
  v43 = 0;
  v6 = *(_DWORD *)a1;
  if ( *(_BYTE *)(*(_DWORD *)a1 + 72) || *(_BYTE *)(v6 + 73) )
  {
    v41 = 0;
  }
  else
  {
    a2 = 0;
    v11 = 0;
    v37 = 0;
    v38 = 0;
    v39 = 0;
    v41 = 0;
    sub_1002B62D(ebp0, v6 + 12);
    LOBYTE(v43) = 2;
    v10 = *(_DWORD *)v8;
    if ( !*(_BYTE *)(*(_DWORD *)v8 + 72) )
    {
      if ( !*(_BYTE *)(v10 + 73) )
      {
        sub_10010260(v10 + 48, v9, (int)&a3);
        *(_BYTE *)(*(_DWORD *)v8 + 72) = 1;
        v12 = *(_DWORD *)v8;
        if ( &v37 != *(int **)v8 )
        {
          v11 = *(_DWORD *)v12;
          *(_DWORD *)v12 = 0;
          a2 = *(_DWORD *)(v12 + 4);
          *(_DWORD *)(v12 + 4) = 0;
          v13 = *(_DWORD *)(v12 + 8);
          v37 = v11;
          v38 = a2;
          v39 = v13;
          *(_DWORD *)(v12 + 8) = 0;
        }
        v41 = 1;
      }
    }
    LOBYTE(v43) = 1;
    sub_1002B6D6();
    if ( v41 )
    {
      v15 = v11;
      if ( v11 != a2 )
      {
        do
        {
          sub_10010010((int)&v36, v14, *(_DWORD *)v40 + 48);
          v16 = *(_DWORD *)v15;
          v17 = *(_DWORD *)v15 + 152;
          LOBYTE(v43) = 4;
          sub_10010260(v17, v18, (int)&v36);
          sub_1002B62D(ebp0, v16 + 100);
          LOBYTE(v43) = 4;
          if ( *(_DWORD *)(v16 + 84) == 4 )
          {
            sub_1002B6D6();
          }
          else
          {
            *(_DWORD *)(v16 + 84) = 3;
            sub_1002B6D6();
            sub_1002C5B1(ebp0);
            sub_1000A690(v16);
          }
          LOBYTE(v43) = 1;
          sub_100101D0((int)&v36, a2);
          v15 += 8;
        }
        while ( v15 != a2 );
        v11 = v37;
      }
      v19 = *(_DWORD *)v40;
      if ( *(_DWORD *)(*(_DWORD *)v40 + 64) )
      {
        v20 = *(_DWORD *)(v19 + 68);
        *(_DWORD *)(v19 + 68) = 0;
        *(_DWORD *)(v19 + 64) = 0;
        if ( v20 )
        {
          _ECX = v20 + 4;
          _EAX = -1;
          __asm { lock xadd [ecx], eax }
          if ( _ZF )
          {
            (**(void (__thiscall ***)(_DWORD))v20)(v20);
            _EAX = v20 + 8;
            _ECX = -1;
            __asm { lock xadd [eax], ecx }
            if ( _ZF )
              (*(void (__thiscall **)(int))(*(_DWORD *)v20 + 4))(v20);
          }
        }
      }
      v41 = 1;
    }
    else
    {
      v41 = 0;
    }
    if ( v11 )
    {
      sub_10004350(v11, a2);
      sub_1002A4AA((LPVOID)v11);
    }
  }
  v43 = -1;
  sub_100101D0((int)&a3, a2);
  return v41;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10003180) --------------------------------------------------------
char __thiscall sub_10003180(void *this, char a2, int a3)
{
  void *v3; // esi@1
  char v4; // bl@2
  char v6; // [sp-Ch] [bp-30h]@1
  int v7; // [sp-8h] [bp-2Ch]@1
  int v8; // [sp-4h] [bp-28h]@1
  char v9; // [sp+10h] [bp-14h]@1
  int v10; // [sp+20h] [bp-4h]@1

  v3 = this;
  v10 = 0;
  sub_1002FD39((int)&v9, (int)&a2);
  v8 = 0;
  LOBYTE(v10) = 1;
  sub_1002FD39((int)&v6, (int)&v9);
  if ( sub_10004210(v3, v6, v7, v8) )
    v4 = sub_10003A60(v3);
  else
    v4 = 0;
  LOBYTE(v10) = 0;
  sub_1002FDDA((int)&v9);
  v10 = -1;
  sub_1002FDDA((int)&a2);
  return v4;
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);

//----- (10003230) --------------------------------------------------------
int __usercall sub_10003230<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // eax@1
  int ebp0; // ebp@0
  int v4; // esi@1
  int v5; // ecx@2

  v4 = a1;
  *(_DWORD *)a1 = &off_10067144;
  v2 = *(_DWORD *)(a1 + 140);
  if ( v2 )
  {
    sub_1002B29A(ebp0, v2);
    v5 = *(_DWORD *)(v4 + 140);
    _EDX = -1;
    _EAX = v5 + 4;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v5 + 4))();
    *(_DWORD *)(v4 + 140) = 0;
  }
  sub_100101D0(v4 + 152, a2);
  return sub_1000A960(v4);
}
// 10067144: using guessed type int (__stdcall *off_10067144)(char);

//----- (100032D0) --------------------------------------------------------
char __thiscall sub_100032D0(void *this, char a2, char a3, int a4, int a5)
{
  char v5; // bl@1
  int ebp0; // ebp@0
  int v7; // esi@1
  int v8; // eax@7
  int v10; // ecx@14
  char v11; // [sp+10h] [bp-4Ch]@1
  void **v12; // [sp+14h] [bp-48h]@18
  int v13; // [sp+18h] [bp-44h]@18
  int *v14; // [sp+24h] [bp-38h]@18
  unsigned int v15; // [sp+48h] [bp-14h]@1
  int v16; // [sp+58h] [bp-4h]@1

  v15 = (unsigned int)&v11 ^ __security_cookie;
  v7 = (int)this;
  v5 = 0;
  sub_1002B62D(ebp0, (int)((char *)this + 100));
  v16 = 0;
  if ( !a3 )
  {
    v8 = *(_DWORD *)(v7 + 84);
    if ( v8 != 3 && v8 != 4 )
    {
      if ( v8 != 2 )
        goto LABEL_4;
      if ( a2 )
      {
LABEL_13:
        *(_DWORD *)(v7 + 84) = 4;
        sub_1002C5B1(ebp0);
        v5 = 1;
        goto LABEL_14;
      }
    }
LABEL_11:
    v16 = -1;
    sub_1002B6D6();
    return 0;
  }
  if ( *(_DWORD *)(v7 + 84) == 4 )
    goto LABEL_11;
  sub_1000A140((void *)(v7 + 92), a5);
LABEL_4:
  if ( a2 || !*(_DWORD *)(v7 + 84) )
    goto LABEL_13;
  *(_DWORD *)(v7 + 84) = 2;
LABEL_14:
  v10 = *(_DWORD *)(v7 + 144);
  if ( v10 )
    sub_1002D593(v10 + 8, v5, a5);
  v16 = -1;
  sub_1002B6D6();
  if ( v5 )
  {
    sub_1002C5B1(ebp0);
    if ( *(_DWORD *)(v7 + 132) )
    {
      v12 = &off_10067064;
      v13 = v7;
      v14 = (int *)&v12;
      v16 = 2;
      sub_1000A250((int)&v12, 16);
      sub_10006050((int)&v12);
    }
  }
  return 1;
}
// 10067064: using guessed type void *off_10067064;
// 10073200: using guessed type int __security_cookie;

//----- (10003420) --------------------------------------------------------
int __fastcall sub_10003420(int a1, int a2, int a3)
{
  sub_10010010(a3, a2, a1 + 152);
  return a3;
}

//----- (10003450) --------------------------------------------------------
void *__userpurge sub_10003450<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_10003230(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10003480) --------------------------------------------------------
void *__thiscall sub_10003480(void *this, int a2)
{
  return this;
}

//----- (10003490) --------------------------------------------------------
int __thiscall sub_10003490(int this, int a2)
{
  unsigned int v2; // ecx@1
  int v3; // esi@1
  int v4; // esi@2
  int result; // eax@4
  int v6; // esi@5

  v3 = (*(_DWORD *)(this + 8) - *(_DWORD *)this) / 48;
  v2 = (unsigned int)((*(_DWORD *)(this + 8) - *(_DWORD *)this) / 48) >> 1;
  if ( 89478485 - v2 >= v3 )
  {
    v6 = v2 + v3;
    if ( v6 < (unsigned int)a2 )
      v6 = a2;
    result = v6;
  }
  else
  {
    v4 = 0;
    if ( (unsigned int)a2 > 0 )
      v4 = a2;
    result = v4;
  }
  return result;
}

//----- (100034E0) --------------------------------------------------------
int __thiscall sub_100034E0(void *this)
{
  int v1; // ecx@1
  void *v2; // esi@1
  int result; // eax@2

  v2 = this;
  v1 = *(_DWORD *)this;
  if ( v1 )
  {
    sub_10004350(v1, *((_DWORD *)v2 + 1));
    result = sub_1002A4AA(*(LPVOID *)v2);
    *(_DWORD *)v2 = 0;
    *((_DWORD *)v2 + 1) = 0;
    *((_DWORD *)v2 + 2) = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10003520) --------------------------------------------------------
int __userpurge sub_10003520<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, char a4, int a5, int a6, int a7)
{
  int ebp0; // ebp@0
  int v8; // esi@1

  v8 = a2;
  sub_10010260(a2 + 152, a1, (int)&a4);
  sub_1002B62D(ebp0, v8 + 100);
  if ( *(_DWORD *)(v8 + 84) == 4 )
  {
    sub_1002B6D6();
  }
  else
  {
    *(_DWORD *)(v8 + 84) = 3;
    sub_1002B6D6();
    sub_1002C5B1(ebp0);
    sub_1000A690(v8);
  }
  return sub_100101D0((int)&a4, a3);
}

//----- (100035D0) --------------------------------------------------------
int __stdcall sub_100035D0(int a1)
{
  return a1;
}

//----- (100035E0) --------------------------------------------------------
int __thiscall sub_100035E0(int this, int a2)
{
  int v3; // ebx@1
  char v4; // [sp-14h] [bp-44h]@1
  char v5; // [sp-Ch] [bp-3Ch]@1
  int v6; // [sp-8h] [bp-38h]@1
  unsigned int v7; // [sp-4h] [bp-34h]@1
  int v8; // [sp+14h] [bp-1Ch]@1
  int v9; // [sp+18h] [bp-18h]@1
  unsigned int v10; // [sp+1Ch] [bp-14h]@1
  int v11; // [sp+2Ch] [bp-4h]@1
  int v12; // [sp+30h] [bp+0h]@1

  v10 = (unsigned int)&v12 ^ __security_cookie;
  v7 = (unsigned int)&v12 ^ __security_cookie;
  v3 = this;
  v8 = 0;
  v9 = 0;
  sub_1002AEE4((int)&v4, this, a2);
  *(_DWORD *)&v4 = &off_1006720C;
  v6 = *(_DWORD *)(a2 + 12);
  sub_10003C50(&v8, v3, (unsigned int)&off_1006720C);
  v11 = 0;
  sub_1002FD39((int)&v5, (int)&v8);
  (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 24))(v3);
  v11 = -1;
  return sub_1002FDDA((int)&v8);
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);
// 1006720C: using guessed type int (__stdcall *off_1006720C)(char);
// 10073200: using guessed type int __security_cookie;

//----- (100036A0) --------------------------------------------------------
char __fastcall sub_100036A0(int a1, int a2)
{
  unsigned int v2; // edi@1
  unsigned int v3; // esi@3
  unsigned int v4; // eax@5
  int v5; // ecx@7

  v2 = *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 20) >= 0x10u )
    a2 = *(_DWORD *)a2;
  v3 = *(_DWORD *)(a1 + 16);
  if ( *(_DWORD *)(a1 + 20) >= 0x10u )
    a1 = *(_DWORD *)a1;
  v4 = v2;
  if ( v3 < v2 )
    v4 = v3;
  v5 = sub_100099E0(a1, a2, v4);
  if ( !v5 )
  {
    if ( v3 < v2 )
      return 0;
    v5 = v3 != v2;
  }
  return v5 == 0;
}

//----- (100036F0) --------------------------------------------------------
#error "100037BF: positive sp value has been found (funcsize=61)"

//----- (100037D0) --------------------------------------------------------
int __thiscall sub_100037D0(void *this, int a2, int a3)
{
  int result; // eax@1
  unsigned int v4; // ecx@1
  int v5; // esi@1
  signed int v6; // ebx@2
  int v7; // edi@2
  signed int v8; // edx@2
  int v9; // ecx@3
  int v10; // ebx@11
  int v11; // ebx@12
  int v12; // edi@12
  int v13; // esi@12
  int v14; // [sp+Ch] [bp-30h]@12
  int v15; // [sp+10h] [bp-2Ch]@12
  int v16; // [sp+14h] [bp-28h]@12
  int v17; // [sp+18h] [bp-24h]@3
  unsigned int v18; // [sp+1Ch] [bp-20h]@3
  int v19; // [sp+20h] [bp-1Ch]@1
  int v20; // [sp+24h] [bp-18h]@2
  int v21; // [sp+28h] [bp-14h]@2
  unsigned int v22; // [sp+2Ch] [bp-10h]@1
  int v23; // [sp+38h] [bp-4h]@12
  int v24; // [sp+3Ch] [bp+0h]@1

  v22 = (unsigned int)&v24 ^ __security_cookie;
  result = (int)this;
  v19 = (int)this;
  v4 = a2;
  v5 = a3;
  if ( a2 != a3 )
  {
    v7 = *(_DWORD *)(result + 4);
    v20 = *(_DWORD *)result;
    v8 = (signed int)((unsigned __int64)(715827883i64 * (v7 - v20)) >> 32) >> 3;
    v6 = v8 + ((unsigned int)v8 >> 31);
    v21 = v7;
    if ( v6 > 0 )
    {
      v18 = *(_DWORD *)a2;
      v9 = v20;
      v17 = *(_DWORD *)(a2 + 4);
      do
      {
        if ( v17 < *(_DWORD *)(v9 + 48 * v6 / 2 + 4)
          || v17 <= *(_DWORD *)(v9 + 48 * v6 / 2 + 4) && v18 < *(_DWORD *)(v9 + 48 * v6 / 2) )
        {
          v6 /= 2;
        }
        else
        {
          v9 += 48 * v6 / 2 + 48;
          v6 += -1 - v6 / 2;
        }
      }
      while ( v6 > 0 );
      v5 = a3;
      v7 = v21;
      v20 = v9;
      v4 = a2;
    }
    v10 = v20;
    if ( v20 == v7 )
    {
      result = sub_10003E70(v19, v4, v5);
    }
    else
    {
      v14 = 0;
      v15 = 0;
      v16 = 0;
      sub_10003B90((int)&v14, (v7 - v20) / 48 + (signed int)(v5 - v4) / 48);
      v13 = v19;
      v23 = 0;
      v12 = v14;
      sub_10005280((int)&v21, v10, *(_DWORD *)(v19 + 4), a2, a3, v14, (int (__cdecl *)(_DWORD, _DWORD))sub_10001750);
      sub_100039D0(v13, (int)&v21, v10, *(_DWORD *)(v13 + 4));
      v11 = v15;
      result = sub_10003E70(v13, v12, v15);
      if ( v12 )
      {
        sub_10004310(v12, v11);
        result = sub_1002A4AA((LPVOID)v12);
      }
    }
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10003960) --------------------------------------------------------
int __userpurge sub_10003960<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5)
{
  int result; // eax@1
  int v6; // ST08_4@1
  int v7; // ST0C_4@1
  int v8; // ST10_4@1
  int v9; // ST14_4@1
  void *v10; // [sp+Ch] [bp+4h]@1

  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_10004130(a1, a2, a3, a4, a5, v6, v7, v8, v9);
  result = a4;
  *(_DWORD *)(*(_DWORD *)a4 + 148) = v10;
  return result;
}

//----- (100039A0) --------------------------------------------------------
int __userpurge sub_100039A0<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // edi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_1006720C;
  *(_DWORD *)(v4 + 12) = *(_DWORD *)(a3 + 12);
  return v4;
}
// 1006720C: using guessed type int (__stdcall *off_1006720C)(char);

//----- (100039D0) --------------------------------------------------------
int __thiscall sub_100039D0(int this, int a2, int a3, int a4)
{
  int v4; // eax@1
  int v5; // ebx@1
  int v6; // edx@2
  int v7; // esi@5

  v4 = a3;
  v5 = this;
  if ( a3 != *(_DWORD *)this || (v6 = *(_DWORD *)(this + 4), a4 != v6) )
  {
    if ( a3 != a4 )
    {
      v7 = sub_10005480(a4, *(_DWORD *)(this + 4), a3);
      sub_10004310(v7, *(_DWORD *)(v5 + 4));
      v4 = a3;
      *(_DWORD *)(v5 + 4) = v7;
    }
    *(_DWORD *)a2 = v4;
  }
  else
  {
    sub_10004310(*(_DWORD *)this, v6);
    *(_DWORD *)(v5 + 4) = *(_DWORD *)v5;
    *(_DWORD *)a2 = a3;
  }
  return a2;
}

//----- (10003A60) --------------------------------------------------------
char __thiscall sub_10003A60(void *this)
{
  int v1; // eax@1
  int ebp0; // ebp@0
  void *v3; // esi@1
  char result; // al@2
  int v5; // ebx@3
  int v6; // edi@3
  int v7; // ecx@4
  int v8; // eax@5
  char v9; // al@7
  int v10; // esi@8
  int v11; // ebx@9
  signed int v12; // [sp-10h] [bp-5Ch]@11
  signed int v13; // [sp-Ch] [bp-58h]@11
  int v14; // [sp-8h] [bp-54h]@11
  int v15; // [sp+Ch] [bp-40h]@3
  int v16; // [sp+10h] [bp-3Ch]@3
  int v17; // [sp+14h] [bp-38h]@3
  int v18; // [sp+18h] [bp-34h]@1
  char v19; // [sp+1Eh] [bp-2Eh]@7
  char v20; // [sp+1Fh] [bp-2Dh]@3
  unsigned int v21; // [sp+3Ch] [bp-10h]@1
  int v22; // [sp+48h] [bp-4h]@3
  int v23; // [sp+4Ch] [bp+0h]@1

  v21 = (unsigned int)&v23 ^ __security_cookie;
  v3 = this;
  v18 = (int)this;
  v1 = *(_DWORD *)this;
  if ( *(_BYTE *)(*(_DWORD *)this + 73) )
  {
    result = 0;
  }
  else
  {
    v5 = 0;
    v6 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v22 = 0;
    v20 = 0;
    sub_1002B62D(ebp0, v1 + 12);
    if ( !*(_BYTE *)(*(_DWORD *)v3 + 73) )
    {
      *(_BYTE *)(*(_DWORD *)v3 + 73) = 1;
      v7 = *(_DWORD *)v3;
      if ( &v15 != *(int **)v3 )
      {
        v5 = *(_DWORD *)v7;
        *(_DWORD *)v7 = 0;
        v6 = *(_DWORD *)(v7 + 4);
        *(_DWORD *)(v7 + 4) = 0;
        v8 = *(_DWORD *)(v7 + 8);
        v15 = v5;
        v16 = v6;
        v17 = v8;
        *(_DWORD *)(v7 + 8) = 0;
      }
      v20 = 1;
    }
    LOBYTE(v22) = 0;
    sub_1002B6D6();
    v9 = *(_DWORD *)(*(_DWORD *)v3 + 64) != 0;
    v19 = *(_DWORD *)(*(_DWORD *)v3 + 64) != 0;
    if ( v20 )
    {
      v10 = v5;
      if ( v5 != v6 )
      {
        v11 = v18;
        do
        {
          if ( v9 )
          {
            v14 = *(_DWORD *)v11 + 64;
            v13 = 1;
            v12 = 1;
          }
          else
          {
            v14 = *(_DWORD *)v10 + 92;
            v13 = 0;
            v12 = 0;
          }
          (*(void (__stdcall **)(signed int, signed int, signed int, int))(**(_DWORD **)v10 + 4))(1, v12, v13, v14);
          v9 = v19;
          v10 += 8;
        }
        while ( v10 != v6 );
        v5 = v15;
      }
    }
    if ( v5 )
    {
      sub_10004350(v5, v6);
      sub_1002A4AA((LPVOID)v5);
    }
    result = v20;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10003B90) --------------------------------------------------------
int __thiscall sub_10003B90(int this, unsigned int a2)
{
  signed __int64 v2; // qax@1
  int v3; // ecx@1
  unsigned int v4; // ebx@1
  int v5; // edi@1
  int v6; // esi@1
  int v8; // [sp+Ch] [bp-4h]@1

  v4 = a2;
  v5 = this;
  v6 = *(_DWORD *)(this + 4);
  v8 = this;
  v2 = 715827883i64 * (*(_DWORD *)(this + 4) - *(_DWORD *)this);
  v3 = (HIDWORD(v2) >> 3) + (HIDWORD(v2) >> 31);
  if ( v3 <= a2 )
  {
    if ( v3 < a2 )
    {
      loc_10002ED0(v5, a2 - v3);
      sub_100054F0(*(_DWORD *)(v5 + 4), v4 - (*(_DWORD *)(v5 + 4) - *(_DWORD *)v8) / 48);
      LODWORD(v2) = 48 * (v4 - (*(_DWORD *)(v8 + 4) - *(_DWORD *)v8) / 48);
      *(_DWORD *)(v8 + 4) += v2;
    }
  }
  else
  {
    LODWORD(v2) = sub_100039D0(v5, (int)&a2, *(_DWORD *)v5 + 48 * a2, v6);
  }
  return v2;
}

//----- (10003C50) --------------------------------------------------------
void *__usercall sub_10003C50<eax>(void *a1<ecx>, int a2<ebx>, char a3)
{
  void *v4; // esi@1

  v4 = a1;
  sub_100098C0(a1, (int)&unk_1006C7D0);
  sub_1002AF18((int)&a3, a2);
  return v4;
}

//----- (10003CB0) --------------------------------------------------------
int __fastcall sub_10003CB0(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8)
{
  int v8; // edi@1
  int i; // esi@1
  unsigned __int8 *v10; // eax@3

  v8 = a2;
  for ( i = a1; i != v8; i += 32 )
  {
    if ( *(_DWORD *)(i + 20) < 0x10u )
      v10 = (unsigned __int8 *)i;
    else
      v10 = *(unsigned __int8 **)i;
    if ( sub_10002C30((int)&a3, v10, a1, *(_DWORD *)(i + 16)) != -1 )
      break;
  }
  if ( a8 >= 0x10 )
    sub_1002A4AA(a3);
  return i;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10003D00) --------------------------------------------------------
int __usercall sub_10003D00<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, unsigned int a4, void *a5, int a6, int a7, int a8, int a9, signed int a10, char a11)
{
  int v11; // eax@1
  int v12; // ecx@1
  int v13; // edi@1
  int v14; // esi@2
  int v23; // esi@6
  int v24; // eax@6
  int v25; // edx@6
  int v47; // [sp-Ch] [bp-48h]@4
  int v48; // [sp-8h] [bp-44h]@4
  int v49; // [sp-4h] [bp-40h]@2
  char v50; // [sp+14h] [bp-28h]@6
  int v51; // [sp+18h] [bp-24h]@6
  int v52; // [sp+1Ch] [bp-20h]@1
  int v53; // [sp+20h] [bp-1Ch]@4
  int v54; // [sp+24h] [bp-18h]@1
  int v55; // [sp+28h] [bp-14h]@1
  int v56; // [sp+38h] [bp-4h]@1

  v13 = a2;
  v52 = a2;
  v54 = 0;
  v56 = 3;
  v11 = sub_1002ADB1(a1, a2, a3, a2, 116);
  v55 = v11;
  LOBYTE(v56) = 4;
  if ( v11 )
  {
    *(_DWORD *)(v11 + 4) = 0;
    *(_DWORD *)(v11 + 8) = 0;
    *(_DWORD *)(v11 + 16) = 0;
    *(_DWORD *)(v11 + 20) = 0;
    *(_DWORD *)(v11 + 48) = 0;
    *(_DWORD *)(v11 + 52) = 0;
    v49 = (int)&a11;
    *(_DWORD *)(v11 + 84) = 0;
    *(_DWORD *)(v11 + 88) = 0;
    v14 = sub_100047D0(v11, v13, v49);
  }
  else
  {
    v14 = 0;
  }
  v49 = (int)&v53;
  LOBYTE(v56) = 3;
  v48 = v13;
  v47 = v12;
  v53 = v14;
  if ( a4 )
  {
    _EAX = a4 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v24 = sub_10004460(v14, (int)&v50, (int)&a5, a4);
  LOBYTE(v56) = 5;
  sub_100050F0(v25, v24, (int)&v47, v48, v49);
  LOBYTE(v56) = 3;
  v23 = v51;
  _EBX = -1;
  v54 = 1;
  if ( v51 )
  {
    _EAX = v51 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v23)(v23);
      _EAX = v23 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v23 + 4))(v23, _EDX);
    }
  }
  if ( (unsigned int)a10 >= 8 )
    sub_1002A4AA(a5);
  a10 = 7;
  a9 = 0;
  LOWORD(a5) = 0;
  LOBYTE(v56) = 1;
  sub_100101D0((int)&a11, -1);
  LOBYTE(v56) = 0;
  if ( a4 )
  {
    _EDX = a4 + 4;
    __asm { lock xadd [edx], ebx }
    if ( _EBX == 1 )
      (*(void (**)(void))(*(_DWORD *)a4 + 4))();
  }
  return v13;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10003E70) --------------------------------------------------------
int __thiscall sub_10003E70(int this, unsigned int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  unsigned int v5; // ST08_4@2
  unsigned int i; // ecx@3
  int v7; // edx@4
  int v8; // edx@8
  int v9; // edi@8
  int v10; // edx@11
  int v11; // edx@12
  int v12; // edi@12
  int v13; // ecx@16
  int v14; // eax@18
  int v15; // edx@21
  int v16; // eax@22
  int v17; // ecx@22
  unsigned int v18; // edi@22
  int v19; // [sp+Ch] [bp-70h]@18
  int v20; // [sp+10h] [bp-6Ch]@18
  int v21; // [sp+14h] [bp-68h]@18
  int v22; // [sp+18h] [bp-64h]@18
  int v23; // [sp+1Ch] [bp-60h]@18
  void *v24; // [sp+20h] [bp-5Ch]@18
  int v25; // [sp+30h] [bp-4Ch]@18
  unsigned int v26; // [sp+34h] [bp-48h]@18
  int v27; // [sp+3Ch] [bp-40h]@22
  int v28; // [sp+40h] [bp-3Ch]@22
  unsigned int v29; // [sp+44h] [bp-38h]@22
  int v30; // [sp+48h] [bp-34h]@22
  int v31; // [sp+4Ch] [bp-30h]@22
  void *v32; // [sp+50h] [bp-2Ch]@22
  int v33; // [sp+60h] [bp-1Ch]@22
  unsigned int v34; // [sp+64h] [bp-18h]@22
  unsigned int v35; // [sp+6Ch] [bp-10h]@1
  int v36; // [sp+78h] [bp-4h]@18
  int v37; // [sp+7Ch] [bp+0h]@1

  v35 = (unsigned int)&v37 ^ __security_cookie;
  v4 = this;
  result = *(_DWORD *)this;
  if ( *(_DWORD *)this == *(_DWORD *)(this + 4) )
  {
    v5 = a2;
    a2 += 48;
    result = sub_10002A30(this, v5);
  }
  for ( i = a2; i != a3; a2 = i )
  {
    result = *(_DWORD *)(v4 + 4);
    v7 = *(_DWORD *)(i + 4);
    if ( v7 < *(_DWORD *)(result - 36) || v7 <= *(_DWORD *)(result - 36) && *(_DWORD *)i < *(_DWORD *)(result - 40) )
    {
      v8 = *(_DWORD *)(result - 36);
      v9 = *(_DWORD *)(i + 8);
      if ( v8 > *(_DWORD *)(i + 12) || v8 >= *(_DWORD *)(i + 12) && *(_DWORD *)(result - 40) >= (unsigned int)v9 )
      {
        v15 = *(_DWORD *)(result - 32);
        if ( v15 < *(_DWORD *)(i + 16) )
        {
          v27 = *(_DWORD *)(result - 48);
          v28 = *(_DWORD *)(result - 44);
          v29 = *(_DWORD *)(result - 40);
          v30 = *(_DWORD *)(result - 36);
          v31 = v15;
          v34 = 15;
          v33 = 0;
          LOBYTE(v32) = 0;
          loc_1000AB40(&v32, result - 28, 0, -1);
          v36 = 1;
          v16 = *(_DWORD *)(v4 + 4);
          v17 = *(_DWORD *)(v16 - 44);
          v18 = *(_DWORD *)a2;
          if ( v17 > *(_DWORD *)(a2 + 4) || v17 >= *(_DWORD *)(a2 + 4) && *(_DWORD *)(v16 - 48) >= v18 )
          {
            *(_DWORD *)(v16 - 48) = v18;
            *(_DWORD *)(v16 - 44) = *(_DWORD *)(a2 + 4);
            *(_DWORD *)(v16 - 40) = *(_DWORD *)(a2 + 8);
            *(_DWORD *)(v16 - 36) = *(_DWORD *)(a2 + 12);
            *(_DWORD *)(v16 - 32) = *(_DWORD *)(a2 + 16);
            if ( v16 - 28 != a2 + 20 )
              loc_1000AB40(v16 - 28, a2 + 20, 0, -1);
          }
          else
          {
            *(_DWORD *)(v16 - 40) = v18;
            *(_DWORD *)(v16 - 36) = *(_DWORD *)(a2 + 4);
            sub_10002A30(v4, a2);
          }
          i = a2;
          result = *(_DWORD *)(a2 + 12);
          if ( result <= v30 )
          {
            if ( result < v30 || *(_DWORD *)(a2 + 8) < v29 )
            {
              v27 = *(_DWORD *)(a2 + 8);
              v28 = *(_DWORD *)(a2 + 12);
              result = sub_10002A30(v4, (unsigned int)&v27);
              i = a2;
            }
          }
          v36 = -1;
          if ( v34 >= 0x10 )
          {
            result = sub_1002A4AA(v32);
            i = a2;
          }
          v34 = 15;
          v33 = 0;
          LOBYTE(v32) = 0;
        }
        goto LABEL_35;
      }
      v10 = *(_DWORD *)(i + 16);
      if ( *(_DWORD *)(result - 32) > v10 )
      {
        v19 = *(_DWORD *)i;
        v20 = *(_DWORD *)(i + 4);
        v21 = v9;
        v22 = *(_DWORD *)(i + 12);
        v23 = v10;
        v26 = 15;
        v25 = 0;
        LOBYTE(v24) = 0;
        loc_1000AB40(&v24, i + 20, 0, -1);
        v36 = 0;
        v14 = *(_DWORD *)(v4 + 4);
        v19 = *(_DWORD *)(v14 - 40);
        v20 = *(_DWORD *)(v14 - 36);
        result = sub_10002A30(v4, (unsigned int)&v19);
        v36 = -1;
        if ( v26 >= 0x10 )
          result = sub_1002A4AA(v24);
LABEL_20:
        i = a2;
        goto LABEL_35;
      }
      v11 = *(_DWORD *)(result - 44);
      v12 = *(_DWORD *)i;
      if ( v11 > *(_DWORD *)(i + 4) || v11 >= *(_DWORD *)(i + 4) && *(_DWORD *)(result - 48) >= (unsigned int)v12 )
      {
        *(_DWORD *)(result - 48) = v12;
        *(_DWORD *)(result - 44) = *(_DWORD *)(i + 4);
        *(_DWORD *)(result - 40) = *(_DWORD *)(i + 8);
        *(_DWORD *)(result - 36) = *(_DWORD *)(i + 12);
        *(_DWORD *)(result - 32) = *(_DWORD *)(i + 16);
        v13 = i + 20;
        result -= 28;
        if ( result == v13 )
          goto LABEL_20;
        result = loc_1000AB40(result, v13, 0, -1);
        i = a2;
      }
      else
      {
        *(_DWORD *)(result - 40) = v12;
        *(_DWORD *)(result - 36) = *(_DWORD *)(i + 4);
        result = sub_10002A30(v4, a2);
        i = a2;
      }
    }
    else
    {
      result = sub_10002A30(v4, i);
      i = a2;
    }
LABEL_35:
    i += 48;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10004130) --------------------------------------------------------
int __userpurge sub_10004130<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // edi@1
  int v10; // eax@3
  int v11; // eax@4
  int v13; // [sp-8h] [bp-30h]@4
  int v14; // [sp-4h] [bp-2Ch]@3
  char v15; // [sp+Ch] [bp-1Ch]@2
  int v16; // [sp+18h] [bp-10h]@1
  int v17; // [sp+24h] [bp-4h]@1

  v9 = a2;
  v17 = 0;
  v16 = 0;
  if ( !*(_DWORD *)a2 )
  {
    sub_1002FFB9((int)&v15, (unsigned int)"then() cannot be called on a default constructed task.");
    sub_100355BB((int)&v15, (int)&unk_1006C878);
  }
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_10006BC0(a1, a4, v9, a2);
  v17 = 0;
  v16 = 1;
  sub_10009800(a4, 2);
  *(_BYTE *)(*(_DWORD *)a4 + 88) = *(_BYTE *)(*(_DWORD *)v9 + 88) != 0;
  *(_BYTE *)(*(_DWORD *)a4 + 89) = 0;
  *(_BYTE *)(*(_DWORD *)a4 + 90) = 0;
  v10 = sub_1002CB88(a3, v9, 0x34u);
  if ( v10 )
    v11 = sub_10004A90(v10, v9, a4, a5, v13, v14);
  else
    v11 = 0;
  sub_10009430(*(void **)v9, v11);
  return a4;
}

//----- (10004210) --------------------------------------------------------
char __thiscall sub_10004210(void *this, char a2, int a3, int a4)
{
  int v4; // eax@1
  int ebp0; // ebp@0
  int v6; // edi@1
  void *v7; // esi@1
  int v8; // esi@4
  int v9; // eax@4
  char v24; // bl@8
  char v26; // [sp-Ch] [bp-4Ch]@4
  unsigned int v27; // [sp-4h] [bp-44h]@1
  char v28; // [sp+Ch] [bp-34h]@4
  int v29; // [sp+10h] [bp-30h]@4
  unsigned int v30; // [sp+30h] [bp-10h]@1
  int v31; // [sp+3Ch] [bp-4h]@1
  int v32; // [sp+40h] [bp+0h]@1

  v30 = (unsigned int)&v32 ^ __security_cookie;
  v27 = (unsigned int)&v32 ^ __security_cookie;
  v7 = this;
  v6 = a4;
  v31 = 0;
  sub_1002B62D(ebp0, *(_DWORD *)this + 12);
  LOBYTE(v31) = 1;
  v4 = *(_DWORD *)v7;
  if ( *(_BYTE *)(*(_DWORD *)v7 + 72) || *(_BYTE *)(v4 + 73) || *(_DWORD *)(v4 + 64) )
  {
    v24 = 0;
  }
  else
  {
    sub_1002FD39((int)&v26, (int)&a2);
    v9 = sub_10004750(v6, (int)&v28, v6, v26);
    sub_100093C0((void *)(*(_DWORD *)v7 + 64), v9);
    v8 = v29;
    if ( v29 )
    {
      _EDI = -1;
      _ECX = v29 + 4;
      _EAX = -1;
      __asm { lock xadd [ecx], eax }
      if ( _ZF )
      {
        (**(void (__thiscall ***)(_DWORD))v8)(v8);
        _EAX = v8 + 8;
        __asm { lock xadd [eax], edi }
        if ( _EDI == 1 )
          (*(void (__thiscall **)(int))(*(_DWORD *)v8 + 4))(v8);
      }
    }
    v24 = 1;
  }
  LOBYTE(v31) = 0;
  sub_1002B6D6();
  v31 = -1;
  sub_1002FDDA((int)&a2);
  return v24;
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);
// 10073200: using guessed type int __security_cookie;

//----- (10004310) --------------------------------------------------------
int __fastcall sub_10004310(int a1, int a2)
{
  int v2; // edi@1
  int v3; // esi@2
  int result; // eax@5

  v2 = a2;
  if ( a1 != a2 )
  {
    v3 = a1 + 40;
    do
    {
      if ( *(_DWORD *)v3 >= 0x10u )
        sub_1002A4AA(*(LPVOID *)(v3 - 20));
      *(_DWORD *)v3 = 15;
      *(_DWORD *)(v3 - 4) = 0;
      *(_BYTE *)(v3 - 20) = 0;
      v3 += 48;
      result = v3 - 40;
    }
    while ( v3 - 40 != v2 );
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10004350) --------------------------------------------------------
int __fastcall sub_10004350(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // edi@2
  int v4; // esi@3
  int result; // eax@7

  v2 = a2;
  if ( a1 != a2 )
  {
    v3 = a1 + 4;
    do
    {
      v4 = *(_DWORD *)v3;
      if ( *(_DWORD *)v3 )
      {
        _EAX = v4 + 4;
        _ECX = -1;
        __asm { lock xadd [eax], ecx }
        if ( _ZF )
        {
          (**(void (__thiscall ***)(_DWORD))v4)(v4);
          _EAX = v4 + 8;
          _ECX = -1;
          __asm { lock xadd [eax], ecx }
          if ( _ZF )
            (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 4))(v4);
        }
      }
      v3 += 8;
      result = v3 - 4;
    }
    while ( v3 - 4 != v2 );
  }
  return result;
}

//----- (100043A0) --------------------------------------------------------
int __thiscall sub_100043A0(void *this, int a2, int a3, int a4)
{
  int v4; // ecx@1
  int v5; // edi@4

  v4 = *(_DWORD *)this;
  if ( v4 )
    (**(void (__stdcall ***)(_DWORD))v4)(1);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  if ( (int *)a2 == &a3 )
  {
    v5 = a4;
  }
  else
  {
    *(_DWORD *)(a2 + 4) = a4;
    v5 = 0;
    a4 = 0;
    *(_DWORD *)a2 = a3;
    a3 = 0;
  }
  if ( v5 )
  {
    _EBX = -1;
    _ECX = v5 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      _EDX = v5 + 8;
      __asm { lock xadd [edx], ebx }
      if ( _EBX == 1 )
        (*(void (**)(void))(*(_DWORD *)v5 + 4))();
    }
  }
  return a2;
}

//----- (10004460) --------------------------------------------------------
int __thiscall sub_10004460(int this, int a2, int a3, unsigned int a4)
{
  int v4; // eax@1
  int v13; // esi@5
  int v14; // eax@5
  int v15; // edx@5
  __int16 v37; // [sp-28h] [bp-68h]@3
  void *v38; // [sp-24h] [bp-64h]@5
  int v39; // [sp-20h] [bp-60h]@5
  int v40; // [sp-1Ch] [bp-5Ch]@5
  int v41; // [sp-18h] [bp-58h]@3
  int v42; // [sp-14h] [bp-54h]@3
  int v43; // [sp-Ch] [bp-4Ch]@3
  int v44; // [sp-8h] [bp-48h]@3
  int v45; // [sp-4h] [bp-44h]@1
  int v46; // [sp+10h] [bp-30h]@1
  int (__stdcall **v47)(char); // [sp+14h] [bp-2Ch]@2
  char v48; // [sp+18h] [bp-28h]@5
  int v49; // [sp+1Ch] [bp-24h]@5
  int v50; // [sp+24h] [bp-1Ch]@1
  int v51; // [sp+28h] [bp-18h]@2
  unsigned int v52; // [sp+2Ch] [bp-14h]@1
  int v53; // [sp+3Ch] [bp-4h]@1
  int v54; // [sp+40h] [bp+0h]@1

  v52 = (unsigned int)&v54 ^ __security_cookie;
  v45 = (unsigned int)&v54 ^ __security_cookie;
  v4 = a3;
  v46 = a2;
  v50 = 0;
  v53 = 1;
  if ( *(_DWORD *)(this + 12) )
  {
    v51 = (int)"Request is not ready";
    sub_1002AEA4((int)&v47, &v51);
    v47 = &off_1005F2E0;
    sub_100355BB((int)&v47, (int)&unk_1006C778);
  }
  v44 = (int)&v51;
  v43 = a2;
  v51 = this;
  v42 = 7;
  v41 = 0;
  v37 = 0;
  loc_10009CC0(v4, 0, -1, this);
  if ( a4 )
  {
    _EAX = a4 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v14 = sub_10005660((int)&v48, *(int *)&v37, v38, v39, v40, v41, v42, a4, v43);
  LOBYTE(v53) = 2;
  sub_10005880(v15, v14, a2, v44, v45);
  LOBYTE(v53) = 1;
  v13 = v49;
  _EDI = -1;
  v50 = 1;
  if ( v49 )
  {
    _EAX = v49 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v13)(v13);
      _EAX = v13 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v13 + 4))(v13, _EDX);
    }
  }
  LOBYTE(v53) = 0;
  if ( a4 )
  {
    _EAX = a4 + 4;
    __asm { lock xadd [eax], edi }
    if ( _EDI == 1 )
      (*(void (**)(void))(*(_DWORD *)a4 + 4))();
  }
  return a2;
}
// 1005F2E0: using guessed type int (__stdcall *off_1005F2E0)(char);
// 10073200: using guessed type int __security_cookie;

//----- (100045A0) --------------------------------------------------------
int __thiscall sub_100045A0(void *this, int a2)
{
  int v2; // edx@1
  void *v3; // esi@1
  int v4; // ecx@1
  int v12; // eax@3
  int v13; // ecx@4
  int v14; // edi@5
  char v30; // [sp-8h] [bp-2Ch]@1
  int v31; // [sp-4h] [bp-28h]@3
  char v32; // [sp+10h] [bp-14h]@3
  int v33; // [sp+14h] [bp-10h]@5
  int v34; // [sp+1Ch] [bp-8h]@1

  v3 = this;
  v4 = *(_DWORD *)this;
  v34 = 0;
  sub_100288F0(v4, (int)((char *)v3 + 4));
  sub_10004DE0((int)&v30, *(_DWORD *)v3 + 84);
  v2 = *((_DWORD *)v3 + 7);
  if ( v2 )
  {
    _EAX = v2 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v12 = sub_10005540((int)&v32, v2, v30, v31);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  if ( a2 != v12 )
  {
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(v12 + 4);
    *(_DWORD *)(v12 + 4) = 0;
    v13 = *(_DWORD *)a2;
    *(_DWORD *)a2 = *(_DWORD *)v12;
    *(_DWORD *)v12 = v13;
  }
  v14 = v33;
  if ( v33 )
  {
    _EBX = -1;
    _ECX = v33 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v14)(v14);
      _EDX = v14 + 8;
      __asm { lock xadd [edx], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v14 + 4))(v14);
    }
  }
  return a2;
}

//----- (10004650) --------------------------------------------------------
int __thiscall sub_10004650(void *this, int a2, int a3, int a4)
{
  int v4; // eax@1
  int ebp0; // ebp@0
  int v6; // edi@1
  void *v7; // eax@3
  int v8; // edi@9

  v6 = *(_DWORD *)this;
  v4 = *(_DWORD *)(*(_DWORD *)this + 12);
  if ( v4 == 1 || v4 == 2 )
  {
    v7 = *(void **)(v6 + 4);
    *(_DWORD *)(v6 + 12) = 3;
    if ( v7 )
    {
      WinHttpCloseHandle(v7);
      sub_1002C6B2(ebp0, (int)WinHttpCloseHandle, v6, 1000);
      *(_DWORD *)(v6 + 4) = 0;
    }
    if ( *(_DWORD *)(v6 + 8) )
    {
      WinHttpCloseHandle(*(HINTERNET *)(v6 + 8));
      *(_DWORD *)(v6 + 8) = 0;
    }
    *(_DWORD *)(v6 + 12) = 4;
  }
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  if ( (int *)a2 == &a3 )
  {
    v8 = a4;
  }
  else
  {
    *(_DWORD *)(a2 + 4) = a4;
    v8 = 0;
    a4 = 0;
    *(_DWORD *)a2 = a3;
    a3 = 0;
  }
  if ( v8 )
  {
    _EBX = -1;
    _ECX = v8 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v8)(v8);
      _EDX = v8 + 8;
      __asm { lock xadd [edx], ebx }
      if ( _EBX == 1 )
        (*(void (**)(void))(*(_DWORD *)v8 + 4))();
    }
  }
  return a2;
}

//----- (10004750) --------------------------------------------------------
int __usercall sub_10004750<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, char a4)
{
  int v5; // esi@1
  int v6; // [sp+8h] [bp-14h]@1
  unsigned int v7; // [sp+Ch] [bp-10h]@1
  int v8; // [sp+18h] [bp-4h]@1
  int v9; // [sp+1Ch] [bp+0h]@1

  v7 = (unsigned int)&v9 ^ __security_cookie;
  v6 = a1;
  v5 = a2;
  v8 = 0;
  sub_10009300((int)&a4, a2, a3, (int)&v6);
  v8 = -1;
  sub_1002FDDA((int)&a4);
  return v5;
}
// 10073200: using guessed type int __security_cookie;

//----- (100047D0) --------------------------------------------------------
int __userpurge sub_100047D0<eax>(int a1<ecx>, int a2<edi>, int a3)
{
  int v3; // ebx@1
  LPVOID *v4; // edi@1
  int v5; // esi@1
  int v6; // edx@1
  void *v8; // [sp+10h] [bp-50h]@1
  unsigned int v9; // [sp+24h] [bp-3Ch]@5
  int v10; // [sp+28h] [bp-38h]@1
  int (__stdcall **v11)(char); // [sp+2Ch] [bp-34h]@1
  void *v12; // [sp+30h] [bp-30h]@1
  int v13; // [sp+40h] [bp-20h]@1
  unsigned int v14; // [sp+44h] [bp-1Ch]@1
  char v15; // [sp+48h] [bp-18h]@1
  unsigned int v16; // [sp+4Ch] [bp-14h]@1
  int v17; // [sp+5Ch] [bp-4h]@1
  int v18; // [sp+60h] [bp+0h]@1

  v16 = (unsigned int)&v18 ^ __security_cookie;
  v3 = a1;
  v10 = a1;
  *(_DWORD *)a1 = &off_10068434;
  *(_DWORD *)(a1 + 12) = 0;
  sub_1002C08B(a1 + 16);
  *(_DWORD *)(v3 + 76) = 15;
  *(_DWORD *)(v3 + 72) = 0;
  *(_BYTE *)(v3 + 56) = 0;
  *(_DWORD *)v3 = &off_100670AC;
  sub_100058D0(v6, v3 + 84, v3, a2);
  v17 = 1;
  v4 = (LPVOID *)(v3 + 92);
  *(_DWORD *)v3 = &off_100670E0;
  *(_DWORD *)(v3 + 112) = 15;
  *(_DWORD *)(v3 + 108) = 0;
  *(_BYTE *)(v3 + 92) = 0;
  v11 = &off_100670D8;
  v14 = 15;
  v13 = 0;
  LOBYTE(v12) = 0;
  v15 = 0;
  LOBYTE(v17) = 3;
  v5 = sub_10011B00(&v11, (int)&v8, a3);
  if ( v3 + 92 != v5 )
  {
    if ( *(_DWORD *)(v3 + 112) >= 0x10u )
      sub_1002A4AA(*v4);
    *(_DWORD *)(v3 + 112) = 15;
    *(_DWORD *)(v3 + 108) = 0;
    *(_BYTE *)v4 = 0;
    sub_100017B0((void *)(v3 + 92), v5);
  }
  if ( v9 >= 0x10 )
    sub_1002A4AA(v8);
  v11 = &off_100670D8;
  if ( v14 >= 0x10 )
    sub_1002A4AA(v12);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100670AC: using guessed type int (__stdcall *off_100670AC)(char);
// 100670D8: using guessed type int (__stdcall *off_100670D8)(char);
// 100670E0: using guessed type int (__stdcall *off_100670E0)(char);
// 10068434: using guessed type int (__stdcall *off_10068434)(char);
// 10073200: using guessed type int __security_cookie;

//----- (10004910) --------------------------------------------------------
void __thiscall sub_10004910(int this, LPCWSTR pwszObjectName)
{
  int v2; // edi@1
  const WCHAR *v3; // esi@1
  const WCHAR *v4; // eax@5
  DWORD v5; // eax@7
  DWORD v6; // eax@10
  char v7; // [sp+Ch] [bp-48h]@1
  int (__stdcall **v8)(char); // [sp+10h] [bp-44h]@2
  int v9; // [sp+24h] [bp-30h]@2
  LPCWSTR pwszVerb; // [sp+28h] [bp-2Ch]@3
  int v11; // [sp+38h] [bp-1Ch]@3
  unsigned int v12; // [sp+3Ch] [bp-18h]@3
  unsigned int v13; // [sp+40h] [bp-14h]@1
  int v14; // [sp+50h] [bp-4h]@3

  v13 = (unsigned int)&v7 ^ __security_cookie;
  v2 = this;
  v3 = pwszObjectName;
  if ( !*(_DWORD *)(this + 8) )
  {
    v9 = (int)"Invalid connection";
    sub_1002AEA4((int)&v8, &v9);
    v8 = &off_1005F2E0;
    sub_100355BB((int)&v8, (int)&unk_1006C778);
  }
  v12 = 7;
  v11 = 0;
  LOWORD(pwszVerb) = 0;
  v14 = 0;
  loc_10028430(&pwszVerb, L"POST", 4);
  if ( *((_DWORD *)pwszObjectName + 5) >= 8u )
    v3 = *(const WCHAR **)pwszObjectName;
  v4 = (const WCHAR *)&pwszVerb;
  if ( v12 >= 8 )
    v4 = pwszVerb;
  v5 = (DWORD)WinHttpOpenRequest(*(HINTERNET *)(v2 + 8), v4, v3, 0, 0, 0, 0);
  *(_DWORD *)(v2 + 4) = v5;
  if ( !v5 )
  {
    v5 = GetLastError();
    sub_10028530(&v8, 9, v5);
    sub_100355BB((int)&v8, (int)&unk_1006CA48);
  }
  if ( WinHttpSetStatusCallback((HINTERNET)v5, (WINHTTP_STATUS_CALLBACK)fnInternetCallback, 0xFFFFFFFFu, 0) == (WINHTTP_STATUS_CALLBACK)-1 )
  {
    v6 = GetLastError();
    sub_10028530(&v8, 10, v6);
    sub_100355BB((int)&v8, (int)&unk_1006CA48);
  }
  if ( v12 >= 8 )
    sub_1002A4AA((LPVOID)pwszVerb);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1005F2E0: using guessed type int (__stdcall *off_1005F2E0)(char);
// 10068420: using guessed type wchar_t aPost[5];
// 10073200: using guessed type int __security_cookie;

//----- (10004A70) --------------------------------------------------------
void __thiscall sub_10004A70(DWORD_PTR this)
{
  void *v1; // eax@1

  v1 = (void *)(this + 92);
  if ( *(_DWORD *)(this + 112) >= 0x10u )
    v1 = *(void **)v1;
  sub_10028EB0(this, v1, *(_DWORD *)(this + 108), *(_DWORD *)(this + 108), L"Content-Type: application/json");
}

//----- (10004A90) --------------------------------------------------------
int __thiscall sub_10004A90(int this, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // esi@1

  v7 = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_BYTE *)(this + 25) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = &off_100670C8;
  sub_10004DE0(this + 32, a3);
  *(_DWORD *)(v7 + 4) = sub_100058C0;
  *(_BYTE *)(v7 + 16) = 1;
  *(_DWORD *)v7 = &off_100670D0;
  sub_10004DE0(v7 + 40, a2);
  *(_DWORD *)(v7 + 48) = *(_DWORD *)a4;
  *(_BYTE *)(v7 + 25) = 1;
  *(_DWORD *)(v7 + 28) = 0;
  return v7;
}
// 100670C8: using guessed type int (__stdcall *off_100670C8)(char);
// 100670D0: using guessed type int (__stdcall *off_100670D0)(char);

//----- (10004B00) --------------------------------------------------------
int __thiscall sub_10004B00(int this)
{
  int v2; // edi@1
  int v3; // esi@1
  int result; // eax@2
  int v17; // edi@5

  v3 = this;
  *(_DWORD *)this = &off_100670D0;
  v2 = *(_DWORD *)(this + 44);
  _EBX = -1;
  if ( v2 )
  {
    result = v2 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v2)(v2);
      result = v2 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v2 + 4))(v2, _EDX);
    }
  }
  *(_DWORD *)v3 = &off_100670C8;
  v17 = *(_DWORD *)(v3 + 36);
  if ( v17 )
  {
    result = v17 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v17)(v17);
      result = v17 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v17 + 4))(v17);
    }
  }
  *(_DWORD *)v3 = &off_10060E80;
  return result;
}
// 10060E80: using guessed type int (__stdcall *off_10060E80)(char);
// 100670C8: using guessed type int (__stdcall *off_100670C8)(char);
// 100670D0: using guessed type int (__stdcall *off_100670D0)(char);

//----- (10004B80) --------------------------------------------------------
int __thiscall sub_10004B80(int this, int a2)
{
  sub_100076D0(a2, this + 32, this);
  return a2;
}

//----- (10004BA0) --------------------------------------------------------
int __thiscall sub_10004BA0(int this)
{
  int v1; // ecx@1
  int v2; // esi@1
  int result; // eax@6

  v2 = this;
  v1 = *(_DWORD *)(this + 28);
  if ( v1 )
  {
    _EAX = v1 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v1 + 4))();
  }
  *(_DWORD *)(v2 + 28) = 0;
  if ( *(_DWORD *)(v2 + 24) >= 8u )
    sub_1002A4AA(*(LPVOID *)(v2 + 4));
  result = 0;
  *(_DWORD *)(v2 + 24) = 7;
  *(_DWORD *)(v2 + 20) = 0;
  *(_WORD *)(v2 + 4) = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10004C30) --------------------------------------------------------
void *__userpurge sub_10004C30<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_10004D30(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10004CA0) --------------------------------------------------------
int __userpurge sub_10004CA0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  int v4; // esi@1

  v4 = a1;
  sub_10004B00(a1);
  if ( a4 & 1 )
    sub_1002CC4D(a2, a3, v4);
  return v4;
}

//----- (10004CD0) --------------------------------------------------------
int __userpurge sub_10004CD0<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int v20; // [sp-4h] [bp-Ch]@2

  v4 = a1;
  *(_DWORD *)a1 = &off_100670C8;
  v3 = *(_DWORD *)(a1 + 36);
  if ( v3 )
  {
    v20 = a2;
    _EBX = -1;
    _EDX = v3 + 4;
    _EAX = -1;
    __asm { lock xadd [edx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v3)(v3);
      _EAX = v3 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
    }
    a2 = v20;
  }
  *(_DWORD *)v4 = &off_10060E80;
  if ( a3 & 1 )
    sub_1002CC4D(a2, v3, v4);
  return v4;
}
// 10060E80: using guessed type int (__stdcall *off_10060E80)(char);
// 100670C8: using guessed type int (__stdcall *off_100670C8)(char);

//----- (10004D30) --------------------------------------------------------
int __usercall sub_10004D30<eax>(int a1<ecx>, int _EBX<ebx>)
{
  int v2; // esi@1
  int v3; // edi@3

  v2 = a1;
  if ( *(_DWORD *)(a1 + 112) >= 0x10u )
    sub_1002A4AA(*(LPVOID *)(a1 + 92));
  *(_DWORD *)(v2 + 112) = 15;
  *(_DWORD *)(v2 + 108) = 0;
  *(_BYTE *)(v2 + 92) = 0;
  v3 = *(_DWORD *)(v2 + 88);
  if ( v3 )
  {
    _EBX = -1;
    _ECX = v3 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v3)(v3);
      _EAX = v3 + 8;
      __asm { lock xadd [eax], ebx }
      _EBX = _EBX - 1;
      if ( !_EBX )
        (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
    }
  }
  return sub_10028820(v2, _EBX, v3);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10004DE0) --------------------------------------------------------
int __thiscall sub_10004DE0(int this, int a2)
{
  int v2; // ebx@1
  int v3; // esi@1
  int v11; // edi@3
  int v27; // [sp+14h] [bp+8h]@1

  v3 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  v2 = *(_DWORD *)(a2 + 4);
  v27 = *(_DWORD *)a2;
  if ( v2 )
  {
    _EAX = v2 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v11 = *(_DWORD *)(v3 + 4);
  if ( v11 )
  {
    _ECX = v11 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v11)(v11);
      _EAX = v11 + 8;
      _ECX = -1;
      __asm { lock xadd [eax], ecx }
      if ( _ZF )
        (*(void (__thiscall **)(int))(*(_DWORD *)v11 + 4))(v11);
    }
  }
  *(_DWORD *)v3 = v27;
  *(_DWORD *)(v3 + 4) = v2;
  return v3;
}

//----- (10004E50) --------------------------------------------------------
int __userpurge sub_10004E50<eax>(int a1<ecx>, int _EBX<ebx>, char a3)
{
  int v3; // edi@1
  int v4; // esi@1

  v4 = a1;
  v3 = *(_DWORD *)(a1 + 88);
  if ( v3 )
  {
    _EBX = -1;
    _ECX = v3 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v3)(v3);
      _EAX = v3 + 8;
      __asm { lock xadd [eax], ebx }
      _EBX = _EBX - 1;
      if ( !_EBX )
        (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
    }
  }
  sub_10028820(v4, _EBX, v3);
  if ( a3 & 1 )
    sub_1002A4AA((LPVOID)v4);
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10004EF0) --------------------------------------------------------
int __thiscall sub_10004EF0(int this, int a2, int a3, int a4, int a5)
{
  int result; // eax@1
  unsigned int v6; // ebx@1
  int v7; // esi@1
  int v8; // edi@2
  int v9; // ecx@3
  int v10; // eax@5
  int v11; // edx@5
  int v12; // ecx@5
  int v13; // edi@5
  int v14; // ebx@9
  int v15; // ecx@9
  int v16; // eax@9
  int v17; // eax@9
  int v18; // edx@9
  int v19; // eax@11
  int v20; // edx@12
  char v21; // [sp+0h] [bp-38h]@1
  int v22; // [sp+14h] [bp-24h]@5
  int v23; // [sp+18h] [bp-20h]@1
  int v24; // [sp+1Ch] [bp-1Ch]@1
  int v25; // [sp+20h] [bp-18h]@9
  int v26; // [sp+24h] [bp-14h]@5
  char *v27; // [sp+28h] [bp-10h]@1
  int v28; // [sp+34h] [bp-4h]@9

  v27 = &v21;
  v7 = this;
  v23 = a3;
  result = 715827883 * (a4 - a3);
  v24 = a4;
  v6 = (a4 - a3) / 48;
  if ( v6 )
  {
    v8 = *(_DWORD *)(this + 4);
    if ( (*(_DWORD *)(this + 8) - v8) / 48 >= v6 )
    {
      sub_10007E90(v23, v24, v8);
      v20 = *(_DWORD *)(v7 + 4);
      result = 48 * v6 + v20;
      if ( a2 != v20 )
      {
        if ( v20 != result )
          result = sub_10007F60(a2, v20, 48 * v6 + v20);
      }
      *(_DWORD *)(v7 + 4) += 48 * v6;
    }
    else
    {
      v9 = (v8 - *(_DWORD *)this) / 48;
      if ( 89478485 - v9 < v6 )
        sub_10029585((int)"vector<T> too long");
      v10 = sub_10003490(v7, v9 + v6);
      v13 = 0;
      v26 = v10;
      v22 = 0;
      if ( v10 )
      {
        if ( (unsigned int)v10 > 0x5555555 || (v13 = sub_1002ADB1(v11, v12, v6, 0, 48 * v10), v22 = v13, !v13) )
          sub_10029530();
      }
      v28 = 0;
      v15 = *(_DWORD *)v7;
      v25 = v13;
      v16 = sub_10005410(v15, a2, v13);
      v25 = v16;
      v17 = sub_10007E90(v23, v24, v16);
      v18 = *(_DWORD *)(v7 + 4);
      v25 = v17;
      sub_10005410(a2, v18, v17);
      v14 = (*(_DWORD *)(v7 + 4) - *(_DWORD *)v7) / 48 + v6;
      if ( *(_DWORD *)v7 )
      {
        sub_10004310(*(_DWORD *)v7, *(_DWORD *)(v7 + 4));
        sub_1002A4AA(*(LPVOID *)v7);
      }
      v19 = v26;
      *(_DWORD *)v7 = v13;
      *(_DWORD *)(v7 + 8) = v13 + 48 * v19;
      result = v13 + 48 * v14;
      *(_DWORD *)(v7 + 4) = result;
    }
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100050F0) --------------------------------------------------------
int __userpurge sub_100050F0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5)
{
  int result; // eax@1
  int v6; // ST08_4@1
  int v7; // ST0C_4@1
  int v8; // ST10_4@1
  int v9; // ST14_4@1
  void *v10; // [sp+Ch] [bp+4h]@1

  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_10006190(a1, a2, a3, a4, a5, v6, v7, v8, v9);
  result = a4;
  *(_DWORD *)(*(_DWORD *)a4 + 148) = v10;
  return result;
}

//----- (10005130) --------------------------------------------------------
int __fastcall sub_10005130(int a1, int a2, signed int a3, int a4)
{
  int result; // eax@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // esi@1
  signed int v8; // esi@2
  int v9; // eax@4
  int v10; // ecx@4
  int v11; // esi@4
  int v12; // eax@4
  unsigned __int8 v13; // sf@4
  unsigned __int8 v14; // of@4
  char v15; // [sp+Ch] [bp-14h]@4
  int v16; // [sp+14h] [bp-Ch]@4
  int v17; // [sp+18h] [bp-8h]@4
  int v18; // [sp+1Ch] [bp-4h]@1
  int v19; // [sp+28h] [bp+8h]@4

  v7 = a4;
  v5 = a2;
  v6 = a1;
  result = (a2 - a1) / 48;
  v18 = a4;
  if ( result <= 32 )
  {
LABEL_9:
    if ( result > 1 )
    {
      if ( v6 != v5 )
        result = sub_10007420(v6, v5, v7);
    }
  }
  else
  {
    v8 = a3;
    while ( v8 > 0 )
    {
      v9 = sub_10006270((int)&v15, v6, v5, (int (__cdecl *)(_DWORD, _DWORD))v18);
      v10 = *(_DWORD *)v9;
      v17 = *(_DWORD *)(v9 + 4);
      v16 = v10;
      v19 = v8 / 2 / 2 + v8 / 2;
      v11 = (v10 - v6) / 48;
      v12 = (v5 - v17) / 48;
      v14 = __SETO__(v11, v12);
      v13 = v11 - v12 < 0;
      v8 = v19;
      if ( v13 ^ v14 )
      {
        sub_10005130(v19, v18);
        v6 = v17;
      }
      else
      {
        sub_10005130(v19, v18);
        v5 = v16;
      }
      result = (v5 - v6) / 48;
      if ( result <= 32 )
        goto LABEL_8;
    }
    if ( result <= 32 )
    {
LABEL_8:
      v7 = v18;
      goto LABEL_9;
    }
    if ( (v5 - v6) / 48 > 1 )
      sub_100072E0(v6, v5, (int (__cdecl *)(_DWORD, _DWORD))v18);
    result = sub_10006900(v6, v5, (int (__cdecl *)(_DWORD, _DWORD))v18);
  }
  return result;
}

//----- (10005280) --------------------------------------------------------
int __fastcall sub_10005280(int a1, int a2, int a3, int a4, int a5, int a6, int (__cdecl *a7)(_DWORD, _DWORD))
{
  int (__cdecl *v7)(_DWORD, _DWORD); // edx@1
  int v8; // ecx@1
  int v9; // ebx@1
  int v10; // edi@1
  int v11; // esi@1
  int v12; // ebx@13
  int v13; // edi@13
  int v14; // ecx@19
  int v15; // ebx@19
  int v16; // edi@19
  int result; // eax@23
  int v18; // [sp+10h] [bp-10h]@2
  int v19; // [sp+14h] [bp-Ch]@1
  int v20; // [sp+18h] [bp-8h]@2
  int v21; // [sp+1Ch] [bp-4h]@1
  int v22; // [sp+1Ch] [bp-4h]@19

  v9 = a4;
  v11 = a6;
  v10 = a2;
  v7 = a7;
  v19 = a1;
  v8 = a3;
  v21 = a4;
  if ( v10 != a3 )
  {
    v20 = v10 + 20;
    v18 = a4 + 20;
    do
    {
      if ( v9 == a5 )
        break;
      if ( (unsigned __int8)v7(v9, v10) )
      {
        *(_DWORD *)a6 = *(_DWORD *)v9;
        *(_DWORD *)(a6 + 4) = *(_DWORD *)(v9 + 4);
        *(_DWORD *)(a6 + 8) = *(_DWORD *)(v18 - 12);
        *(_DWORD *)(a6 + 12) = *(_DWORD *)(v18 - 8);
        *(_DWORD *)(a6 + 16) = *(_DWORD *)(v18 - 4);
        if ( a6 + 20 != v18 )
          loc_1000AB40(v18, 0, -1);
        v9 += 48;
        v21 = v9;
        v18 += 48;
      }
      else
      {
        *(_DWORD *)a6 = *(_DWORD *)v10;
        *(_DWORD *)(a6 + 4) = *(_DWORD *)(v10 + 4);
        *(_DWORD *)(a6 + 8) = *(_DWORD *)(v20 - 12);
        *(_DWORD *)(a6 + 12) = *(_DWORD *)(v20 - 8);
        *(_DWORD *)(a6 + 16) = *(_DWORD *)(v20 - 4);
        if ( a6 + 20 != v20 )
          loc_1000AB40(v20, 0, -1);
        v10 += 48;
        v20 += 48;
      }
      v8 = a3;
      v7 = a7;
      v11 = a6 + 48;
      a6 += 48;
    }
    while ( v10 != a3 );
    if ( v10 != v8 )
    {
      v12 = v11 + 20;
      v13 = v10 + 20;
      do
      {
        *(_DWORD *)v11 = *(_DWORD *)(v13 - 20);
        *(_DWORD *)(v11 + 4) = *(_DWORD *)(v13 - 16);
        *(_DWORD *)(v12 - 12) = *(_DWORD *)(v13 - 12);
        *(_DWORD *)(v12 - 8) = *(_DWORD *)(v13 - 8);
        *(_DWORD *)(v12 - 4) = *(_DWORD *)(v13 - 4);
        if ( v12 != v13 )
        {
          loc_1000AB40(v12, v13, 0, -1);
          v8 = a3;
        }
        v13 += 48;
        v11 += 48;
        v12 += 48;
      }
      while ( v13 - 20 != v8 );
      v9 = v21;
    }
  }
  if ( v9 != a5 )
  {
    v14 = v21 - v11;
    v16 = v9 + 20;
    v15 = v11 + 8;
    v22 = v21 - v11;
    do
    {
      *(_DWORD *)v11 = *(_DWORD *)(v16 - 20);
      *(_DWORD *)(v11 + 4) = *(_DWORD *)(v16 - 16);
      *(_DWORD *)v15 = *(_DWORD *)(v14 + v15);
      *(_DWORD *)(v15 + 4) = *(_DWORD *)(v14 + v15 + 4);
      *(_DWORD *)(v15 + 8) = *(_DWORD *)(v16 - 4);
      if ( v15 + 12 != v16 )
        loc_1000AB40(v15 + 12, v16, 0, -1);
      v16 += 48;
      v11 += 48;
      v15 += 48;
      v14 = v22;
    }
    while ( v16 - 20 != a5 );
  }
  result = v19;
  *(_DWORD *)v19 = v11;
  return result;
}

//----- (10005410) --------------------------------------------------------
int __fastcall sub_10005410(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@2
  int result; // eax@6

  v3 = a2;
  v4 = a1;
  if ( a1 == a2 )
  {
    result = a3;
  }
  else
  {
    v5 = a3;
    do
    {
      if ( v5 )
        sub_100016C0(v5, v4);
      v4 += 48;
      v5 += 48;
    }
    while ( v4 != v3 );
    result = v5;
  }
  return result;
}

//----- (10005450) --------------------------------------------------------
int __stdcall sub_10005450(int a1)
{
  int result; // eax@2

  if ( *(_DWORD *)(a1 + 40) >= 0x10u )
    result = sub_1002A4AA(*(LPVOID *)(a1 + 20));
  *(_DWORD *)(a1 + 40) = 15;
  *(_DWORD *)(a1 + 36) = 0;
  *(_BYTE *)(a1 + 20) = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10005480) --------------------------------------------------------
int __fastcall sub_10005480(int a1, int a2, int a3)
{
  int v3; // ebx@2
  int v4; // edi@2
  int v5; // esi@2
  int result; // eax@6
  int v7; // [sp+0h] [bp-4h]@1

  v7 = a2;
  if ( a1 == a2 )
  {
    result = a3;
  }
  else
  {
    v3 = a3;
    v4 = a3 + 20;
    v5 = a1 + 20;
    do
    {
      *(_DWORD *)v3 = *(_DWORD *)(v5 - 20);
      *(_DWORD *)(v3 + 4) = *(_DWORD *)(v5 - 16);
      *(_DWORD *)(v4 - 12) = *(_DWORD *)(v5 - 12);
      *(_DWORD *)(v4 - 8) = *(_DWORD *)(v5 - 8);
      *(_DWORD *)(v4 - 4) = *(_DWORD *)(v5 - 4);
      if ( v4 != v5 )
        loc_1000AB40(v4, v5, 0, -1);
      v5 += 48;
      v3 += 48;
      v4 += 48;
    }
    while ( v5 - 20 != v7 );
    result = v3;
  }
  return result;
}

//----- (100054F0) --------------------------------------------------------
void __fastcall sub_100054F0(int a1, int a2)
{
  int v2; // eax@2

  if ( a2 )
  {
    v2 = a1 + 36;
    do
    {
      if ( v2 != 36 )
      {
        *(_DWORD *)(v2 - 36) = 0;
        *(_DWORD *)(v2 - 32) = 0;
        *(_DWORD *)(v2 - 28) = 0;
        *(_DWORD *)(v2 - 24) = 0;
        *(_DWORD *)(v2 + 4) = 15;
        *(_DWORD *)v2 = 0;
        *(_BYTE *)(v2 - 16) = 0;
      }
      v2 += 48;
      --a2;
    }
    while ( a2 );
  }
}

//----- (10005540) --------------------------------------------------------
int __thiscall sub_10005540(int this, int a2, char a3, int a4)
{
  int v5; // edi@1
  int v6; // esi@1
  int v21; // eax@5
  int v22; // edi@7
  int v23; // eax@7
  char v45; // [sp-Ch] [bp-40h]@7
  int v46; // [sp-8h] [bp-3Ch]@7
  int v47; // [sp-4h] [bp-38h]@7
  int v48; // [sp+14h] [bp-20h]@1
  char v49; // [sp+18h] [bp-1Ch]@1
  int v50; // [sp+1Ch] [bp-18h]@1
  int v51; // [sp+30h] [bp-4h]@1
  void *v52; // [sp+38h] [bp+4h]@7

  v6 = this;
  v48 = this;
  v51 = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  LOBYTE(v51) = 2;
  sub_10004DE0((int)&v49, (int)&a3);
  v5 = v50;
  _EBX = -1;
  if ( v50 )
  {
    _EAX = v50 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      _EAX = v5 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v5 + 4))(v5, _EDX);
    }
  }
  v21 = a2;
  if ( !a2 )
    v21 = 2;
  sub_10005980(v6, v21);
  v23 = *(_DWORD *)v6;
  v47 = 0;
  *(_DWORD *)(v23 + 148) = v52;
  sub_10004DE0((int)&v45, (int)&a3);
  sub_10006970(*(int *)&v45, v46);
  sub_10006EE0((int *)&a3, -1, v6);
  LOBYTE(v51) = 0;
  v22 = a4;
  if ( a4 )
  {
    _EAX = a4 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v22)(v22);
      _EAX = v22 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v22 + 4))(v22, _EDX);
    }
  }
  v51 = -1;
  if ( a2 )
  {
    _EDX = a2 + 4;
    __asm { lock xadd [edx], ebx }
    if ( _EBX == 1 )
      (*(void (**)(void))(*(_DWORD *)a2 + 4))();
  }
  return v6;
}

//----- (10005660) --------------------------------------------------------
int __thiscall sub_10005660(int this, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9)
{
  int v9; // edi@1
  int v10; // esi@1
  int v26; // eax@8
  void *v27; // eax@8
  int v28; // ecx@10
  int v36; // ecx@13
  int v51; // eax@20
  int v52; // eax@20
  int v53; // eax@21
  int v54; // ecx@23
  void *v62; // [sp+1Ch] [bp-54h]@1
  int v63; // [sp+2Ch] [bp-44h]@1
  unsigned int v64; // [sp+30h] [bp-40h]@1
  int v65; // [sp+34h] [bp-3Ch]@3
  int v66; // [sp+38h] [bp-38h]@13
  void *v67; // [sp+3Ch] [bp-34h]@13
  int v68; // [sp+4Ch] [bp-24h]@13
  unsigned int v69; // [sp+50h] [bp-20h]@13
  int v70; // [sp+54h] [bp-1Ch]@15
  int v71; // [sp+5Ch] [bp-14h]@8
  int v72; // [sp+60h] [bp-10h]@20
  int v73; // [sp+6Ch] [bp-4h]@1
  void *v74; // [sp+74h] [bp+4h]@13

  v10 = this;
  v73 = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  LOBYTE(v73) = 1;
  LOWORD(v62) = 0;
  v64 = 7;
  v63 = 0;
  loc_10009CC0(&v62, &a3, 0, -1);
  v9 = a9;
  if ( a9 )
  {
    _EAX = a9 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v65 = v9;
  _EBX = -1;
  LOBYTE(v73) = 2;
  if ( v9 )
  {
    _EAX = v9 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (__thiscall **)(int))(*(_DWORD *)v9 + 4))(v9);
  }
  v65 = 0;
  if ( v64 >= 8 )
    sub_1002A4AA(v62);
  v27 = sub_100099D0(&v71);
  LOBYTE(v73) = 3;
  v26 = *(_DWORD *)v27;
  if ( !v26 )
    v26 = 2;
  sub_10005980(v10, v26);
  LOBYTE(v73) = 1;
  v28 = v71;
  if ( v71 )
  {
    _EAX = v71 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v28 + 4))();
  }
  *(_DWORD *)(*(_DWORD *)v10 + 148) = v74;
  v66 = a2;
  LOWORD(v67) = 0;
  v69 = 7;
  v68 = 0;
  loc_10009CC0(&v67, &a3, 0, -1);
  v36 = a9;
  if ( a9 )
  {
    _EAX = a9 + 4;
    _EDX = 1;
    __asm { lock xadd [eax], edx }
  }
  v70 = v36;
  LOBYTE(v73) = 4;
  if ( v36 )
  {
    _EAX = v36 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v36 + 4))();
  }
  LOBYTE(v73) = 1;
  v70 = 0;
  if ( v69 >= 8 )
    sub_1002A4AA(v67);
  LOWORD(v67) = 0;
  v52 = *(_DWORD *)v10;
  v69 = 7;
  v68 = 0;
  *(_BYTE *)(v52 + 88) = 0;
  *(_BYTE *)(*(_DWORD *)v10 + 90) = 1;
  v51 = sub_1002CB88(-1, v9, 0x3Cu);
  v72 = v51;
  LOBYTE(v73) = 5;
  if ( v51 )
    v53 = sub_10007940(v51, v10, (int)&a2);
  else
    v53 = 0;
  LOBYTE(v73) = 1;
  sub_1000A5C0(*(_DWORD *)v10, -1, v9, v53, 0);
  v73 = 6;
  v54 = a9;
  if ( a9 )
  {
    _EAX = a9 + 4;
    __asm { lock xadd [eax], ebx }
    if ( _EBX == 1 )
      (*(void (**)(void))(*(_DWORD *)v54 + 4))();
  }
  a9 = 0;
  if ( a8 >= 8 )
    sub_1002A4AA(a3);
  return v10;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10005880) --------------------------------------------------------
int __userpurge sub_10005880<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5)
{
  int result; // eax@1
  int v6; // ST08_4@1
  int v7; // ST0C_4@1
  int v8; // ST10_4@1
  int v9; // ST14_4@1
  void *v10; // [sp+Ch] [bp+4h]@1

  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_100069B0(a1, a2, a3, a4, a5, v6, v7, v8, v9);
  result = a4;
  *(_DWORD *)(*(_DWORD *)a4 + 148) = v10;
  return result;
}

//----- (100058C0) --------------------------------------------------------
void __cdecl sub_100058C0(int a2)
{
  sub_10005A40(a2);
}

//----- (100058D0) --------------------------------------------------------
int __usercall sub_100058D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // esi@1
  int v6; // eax@2

  v5 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a4, 96);
  if ( v4 )
    v6 = sub_10005B40(v4);
  else
    v6 = 0;
  *(_DWORD *)(v5 + 4) = v6;
  *(_DWORD *)v5 = v6 + 16;
  return v5;
}

//----- (10005980) --------------------------------------------------------
int __thiscall sub_10005980(int this, int a2)
{
  int result; // eax@1
  int v4; // ecx@1
  int v5; // ebx@1
  int v7; // esi@3
  int v19; // esi@7
  int v31; // esi@12
  char v32; // [sp+10h] [bp-14h]@1
  char v33; // [sp+18h] [bp-Ch]@1
  int v34; // [sp+1Ch] [bp-8h]@7

  v5 = this;
  result = sub_10005DA0(a2, (int)&v33, this);
  v4 = 0;
  _EDX = 0;
  if ( &v32 != (char *)result )
  {
    _EDX = *(_DWORD *)(result + 4);
    *(_DWORD *)(result + 4) = 0;
    v4 = *(_DWORD *)result;
    *(_DWORD *)result = 0;
  }
  v7 = *(_DWORD *)(v5 + 4);
  _EDI = -1;
  *(_DWORD *)(v5 + 4) = _EDX;
  *(_DWORD *)v5 = v4;
  if ( v7 )
  {
    result = v7 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v7)(v7);
      result = v7 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v7 + 4))(v7, _EDX);
    }
  }
  v19 = v34;
  if ( v34 )
  {
    result = v34 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v19)(v19);
      result = v19 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v19 + 4))(v19);
    }
  }
  if ( a2 != 2 )
  {
    v31 = *(_DWORD *)v5;
    result = sub_1002B396(_EDX, *(_DWORD *)(*(_DWORD *)v5 + 136), v5, (int)sub_100097E0, *(_DWORD *)v5, 1);
    *(_DWORD *)(v31 + 140) = result;
  }
  return result;
}

//----- (10005A40) --------------------------------------------------------
void __thiscall sub_10005A40(int this)
{
  int ebp0; // ebp@0
  int v2; // edi@1
  int v3; // esi@1
  int v4; // edx@4
  unsigned int v5; // [sp-4h] [bp-54h]@1
  int v6; // [sp+14h] [bp-3Ch]@4
  int v7; // [sp+18h] [bp-38h]@4
  int v8; // [sp+1Ch] [bp-34h]@1
  unsigned int v9; // [sp+3Ch] [bp-14h]@1
  unsigned int *v10; // [sp+40h] [bp-10h]@1
  int v11; // [sp+4Ch] [bp-4h]@1
  int v12; // [sp+50h] [bp+0h]@1

  v9 = (unsigned int)&v12 ^ __security_cookie;
  v5 = (unsigned int)&v12 ^ __security_cookie;
  v10 = &v5;
  v2 = this;
  v3 = *(_DWORD *)(this + 32);
  v8 = this;
  sub_1002B62D(ebp0, v3 + 100);
  v11 = -1;
  if ( *(_DWORD *)(v3 + 84) == 4 )
  {
    sub_1002B6D6();
  }
  else
  {
    *(_DWORD *)(v3 + 84) = 1;
    sub_1002B6D6();
    v11 = 1;
    LOBYTE(v6) = 0;
    LOBYTE(v7) = 0;
    sub_10005DE0(v4, v2, v2, v7, v6);
  }
}
// 10073200: using guessed type int __security_cookie;

//----- (10005B40) --------------------------------------------------------
int __thiscall sub_10005B40(int this)
{
  int v1; // edi@1
  int v2; // esi@1

  v1 = this;
  *(_DWORD *)(this + 4) = 1;
  *(_DWORD *)(this + 8) = 1;
  v2 = this + 16;
  *(_DWORD *)this = off_1006709C;
  if ( this != -16 )
  {
    *(_DWORD *)v2 = 0;
    *(_DWORD *)(this + 20) = 0;
    *(_DWORD *)(this + 24) = 0;
    sub_1002B5CC(this + 28);
    *(_BYTE *)(v2 + 56) = 0;
    *(_DWORD *)(v2 + 56) &= 0xFFFFFEFFu;
    *(_DWORD *)(v2 + 60) = 0;
    *(_DWORD *)(v2 + 64) = 0;
    *(_DWORD *)(v2 + 68) = 0;
    *(_WORD *)(v2 + 72) = 0;
  }
  return v1;
}
// 1006709C: using guessed type int (__stdcall *off_1006709C[4])(int);

//----- (10005BF0) --------------------------------------------------------
int __userpurge sub_10005BF0<eax>(int a1<eax>, int a2<ecx>, int _EBX<ebx>, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  int v6; // esi@3
  int v20; // eax@7
  void *v21; // esi@9
  int v22; // eax@14
  void *v23; // esi@15
  int result; // eax@16
  char v25; // [sp-18h] [bp-18h]@10
  int v26; // [sp-14h] [bp-14h]@1
  int v27; // [sp-10h] [bp-10h]@1
  int (__cdecl *v28)(int, int); // [sp-Ch] [bp-Ch]@1
  signed int v29; // [sp-8h] [bp-8h]@1

  v28 = sub_1005A7B9;
  v27 = a1;
  v4 = a2 + 16;
  v26 = a2 + 16;
  v29 = 3;
  v5 = *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 20) )
  {
    do
    {
      (*(void (__stdcall **)(signed int, _DWORD, _DWORD, int))(**(_DWORD **)v5 + 4))(1, 0, 0, *(_DWORD *)v5 + 92);
      v5 += 8;
    }
    while ( v5 != *(_DWORD *)(v4 + 4) );
  }
  LOBYTE(v29) = 2;
  v6 = *(_DWORD *)(v4 + 68);
  if ( v6 )
  {
    _EBX = -1;
    _ECX = v6 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v6)(v6);
      _EAX = v6 + 8;
      __asm { lock xadd [eax], ebx }
      _EBX = _EBX - 1;
      if ( !_EBX )
        (*(void (__thiscall **)(int))(*(_DWORD *)v6 + 4))(v6);
    }
  }
  LOBYTE(v29) = 1;
  v20 = *(_BYTE *)(v4 + 56);
  if ( v20 == 4 )
  {
    if ( *(_DWORD *)(v4 + 56) & 0x100 )
    {
      if ( *(_DWORD *)(v4 + 48) )
        sub_100309C2(_EBX, *(LPVOID *)(v4 + 48));
    }
  }
  else
  {
    if ( (unsigned int)(v20 - 6) <= 1 )
    {
      v21 = *(void **)(v4 + 48);
      if ( v21 )
      {
        sub_100130F0(v21, (int)&v25, **(_DWORD **)v21, *(_DWORD *)v21);
        sub_1002A4AA(*(LPVOID *)v21);
        sub_1002A4AA(v21);
      }
    }
  }
  v22 = *(_DWORD *)(v4 + 60);
  if ( v22 )
  {
    v23 = (void *)(v22 - 4);
    sub_1002B11F(v22, 4, *(_DWORD *)(v22 - 4), (void (__thiscall *)(_DWORD))sub_1000FF60);
    sub_100303A3(v23);
  }
  LOBYTE(v29) = 0;
  result = nullsub_2(v4 + 12);
  if ( *(_DWORD *)v4 )
  {
    sub_10004350(*(_DWORD *)v4, *(_DWORD *)(v4 + 4));
    result = sub_1002A4AA(*(LPVOID *)v4);
    *(_DWORD *)v4 = 0;
    *(_DWORD *)(v4 + 4) = 0;
    *(_DWORD *)(v4 + 8) = 0;
  }
  return result;
}
// 1000FF60: using guessed type int sub_1000FF60();
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1002C171: using guessed type int __thiscall nullsub_2(_DWORD);
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 1005A7B9: using guessed type int __cdecl sub_1005A7B9(int, int);

//----- (10005DA0) --------------------------------------------------------
int __usercall sub_10005DA0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v4; // esi@1
  int v5; // [sp+8h] [bp-8h]@1
  unsigned int v6; // [sp+Ch] [bp-4h]@1
  int v7; // [sp+10h] [bp+0h]@1

  v6 = (unsigned int)&v7 ^ __security_cookie;
  v5 = a1;
  v4 = a2;
  sub_10006A90((int)&v5, a2, a3);
  return v4;
}
// 10073200: using guessed type int __security_cookie;

//----- (10005DE0) --------------------------------------------------------
void __userpurge sub_10005DE0(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // edx@1
  int v6; // ebx@1
  int ebp0; // ebp@0
  int v9; // esi@1
  int v10; // ebx@1
  int v11; // eax@1
  int v26; // ebx@8
  int v27; // eax@9
  int v28; // ebx@11
  int v29; // eax@11
  int v30; // edx@15
  void **v44; // [sp-20h] [bp-94h]@9
  int v45; // [sp-1Ch] [bp-90h]@9
  int v46; // [sp-18h] [bp-8Ch]@11
  int v47; // [sp-14h] [bp-88h]@11
  char v48; // [sp-8h] [bp-7Ch]@6
  int v49; // [sp-4h] [bp-78h]@6
  char v50; // [sp+10h] [bp-64h]@1
  int v51; // [sp+14h] [bp-60h]@1
  int v52; // [sp+18h] [bp-5Ch]@1
  char *v53; // [sp+1Ch] [bp-58h]@1
  int v54; // [sp+20h] [bp-54h]@1
  char v55; // [sp+24h] [bp-50h]@1
  int v56; // [sp+28h] [bp-4Ch]@1
  char v57; // [sp+2Ch] [bp-48h]@11
  int v58; // [sp+3Ch] [bp-38h]@14
  unsigned int v59; // [sp+60h] [bp-14h]@1
  int v60; // [sp+70h] [bp-4h]@1

  v59 = (unsigned int)&v50 ^ __security_cookie;
  v10 = a2;
  v54 = a2;
  v51 = 0;
  v52 = 0;
  sub_10006BC0(a1, (int)&v51, a3, a2);
  v60 = 0;
  v11 = sub_10004DE0((int)&v55, v10 + 40);
  v9 = *(_DWORD *)(v11 + 4);
  *(_DWORD *)(v11 + 4) = v52;
  v5 = *(_DWORD *)v11;
  *(_DWORD *)v11 = v51;
  v6 = v56;
  _EDI = -1;
  v52 = v9;
  v53 = (char *)v5;
  v51 = v5;
  if ( v56 )
  {
    _EAX = v56 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v6)(v6);
      _EAX = v6 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v6 + 4))(v6, _EDX);
      v5 = (int)v53;
    }
  }
  v53 = &v48;
  *(_DWORD *)&v48 = 0;
  v49 = 0;
  if ( (int *)&v48 != &v51 )
  {
    v49 = v9;
    v9 = 0;
    v52 = 0;
    *(_DWORD *)&v48 = v5;
    v51 = 0;
  }
  v26 = v54;
  if ( &v48 )
  {
    v44 = &off_10067020;
    v45 = *(_DWORD *)(v54 + 48);
    v27 = (int)&v44;
  }
  else
  {
    v27 = 0;
  }
  LOBYTE(v60) = 1;
  v29 = sub_10005FD0((int)&v57, (char)v44, v45, v46, v47, v27);
  LOBYTE(v60) = 4;
  v28 = *(_DWORD *)(v26 + 32);
  *(_BYTE *)(v28 + 152) = sub_10006090(v29, v48, v49);
  sub_1002B62D(ebp0, v28 + 100);
  LOBYTE(v60) = 4;
  if ( *(_DWORD *)(v28 + 84) == 4 )
  {
    sub_1002B6D6();
  }
  else
  {
    *(_DWORD *)(v28 + 84) = 3;
    sub_1002B6D6();
    sub_1002C5B1(ebp0);
    sub_1000A690(v28);
  }
  LOBYTE(v60) = 0;
  if ( v58 )
  {
    v30 = *(_DWORD *)v58;
    v49 = v58 != (_DWORD)&v57;
    (*(void (__stdcall **)(int))(v30 + 16))(v49);
    v58 = 0;
  }
  v60 = -1;
  if ( v9 )
  {
    _EAX = v9 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v9)(v9);
      _EAX = v9 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (**)(void))(*(_DWORD *)v9 + 4))();
    }
  }
}
// 10067020: using guessed type void *off_10067020;
// 10073200: using guessed type int __security_cookie;

//----- (10005FD0) --------------------------------------------------------
int __thiscall sub_10005FD0(int this, char a2, int a3, int a4, int a5, int a6)
{
  int v6; // edi@1

  v6 = this;
  sub_10006B10((int)&a2, this, this);
  if ( a6 )
    (*(void (__stdcall **)(bool))(*(_DWORD *)a6 + 16))(a6 != (_DWORD)&a2);
  return v6;
}

//----- (10006050) --------------------------------------------------------
int __thiscall sub_10006050(int this)
{
  int v1; // ecx@1
  int v2; // esi@1
  int result; // eax@2
  int v4; // ecx@3

  v2 = this;
  v1 = *(_DWORD *)(this + 16);
  if ( v1 )
  {
    result = (*(int (__stdcall **)(bool))(*(_DWORD *)v1 + 16))(v1 != v2);
    *(_DWORD *)(v2 + 16) = 0;
  }
  v4 = *(_DWORD *)(v2 + 16);
  if ( v4 )
  {
    result = (*(int (__stdcall **)(bool))(*(_DWORD *)v4 + 16))(v4 != v2);
    *(_DWORD *)(v2 + 16) = 0;
  }
  return result;
}

//----- (10006090) --------------------------------------------------------
char __thiscall sub_10006090(int this, char a2, int a3)
{
  int v3; // ecx@1
  char v4; // bl@3
  int v5; // esi@3

  v3 = *(_DWORD *)(this + 16);
  if ( !v3 )
    sub_10029561();
  v5 = a3;
  v4 = (*(int (__stdcall **)(char *))(*(_DWORD *)v3 + 8))(&a2);
  if ( a3 )
  {
    _EDI = -1;
    _EDX = a3 + 4;
    _ECX = -1;
    __asm { lock xadd [edx], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      _EAX = v5 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (**)(void))(*(_DWORD *)v5 + 4))();
    }
  }
  return v4;
}

//----- (10006160) --------------------------------------------------------
void *__thiscall sub_10006160(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_10067080;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067080: using guessed type int (*off_10067080[5])();

//----- (10006190) --------------------------------------------------------
int __userpurge sub_10006190<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // edi@1
  int v10; // eax@3
  int v11; // eax@4
  int v13; // [sp-8h] [bp-30h]@4
  int v14; // [sp-4h] [bp-2Ch]@3
  char v15; // [sp+Ch] [bp-1Ch]@2
  int v16; // [sp+18h] [bp-10h]@1
  int v17; // [sp+24h] [bp-4h]@1

  v9 = a2;
  v17 = 0;
  v16 = 0;
  if ( !*(_DWORD *)a2 )
  {
    sub_1002FFB9((int)&v15, (unsigned int)"then() cannot be called on a default constructed task.");
    sub_100355BB((int)&v15, (int)&unk_1006C878);
  }
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_10006BC0(a1, a4, v9, a2);
  v17 = 0;
  v16 = 1;
  sub_10005980(a4, 2);
  *(_BYTE *)(*(_DWORD *)a4 + 88) = *(_BYTE *)(*(_DWORD *)v9 + 88) != 0;
  *(_BYTE *)(*(_DWORD *)a4 + 89) = 0;
  *(_BYTE *)(*(_DWORD *)a4 + 90) = 1;
  v10 = sub_1002CB88(a3, v9, 0x34u);
  if ( v10 )
    v11 = sub_10006D10(v10, v9, a4, a5, v13, v14);
  else
    v11 = 0;
  sub_10009430(*(void **)v9, v11);
  return a4;
}

//----- (10006270) --------------------------------------------------------
int __fastcall sub_10006270(int a1, int a2, unsigned int a3, int (__cdecl *a4)(_DWORD, _DWORD))
{
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ecx@1
  signed int v7; // edx@1
  unsigned int v8; // ecx@6
  char v9; // al@8
  int v10; // eax@13
  int v11; // ebx@13
  int *v12; // edi@16
  int v13; // edx@19
  int v14; // ecx@19
  char v15; // cf@19
  char v16; // zf@31
  int *v17; // ebx@32
  int v18; // edi@32
  int v19; // eax@35
  char v20; // cf@35
  int v21; // ecx@39
  unsigned int v22; // ecx@45
  char v23; // cf@52
  int v24; // ecx@52
  int *v25; // edx@56
  int v26; // edx@62
  int v27; // ecx@62
  int v28; // edi@62
  int v29; // eax@62
  char v30; // cf@62
  int *v31; // ecx@66
  int v32; // eax@73
  int result; // eax@78
  int v34; // [sp+10h] [bp-94h]@1
  int v35; // [sp+14h] [bp-90h]@62
  int v36; // [sp+14h] [bp-90h]@66
  int v37; // [sp+1Ch] [bp-88h]@19
  int v38; // [sp+1Ch] [bp-88h]@62
  unsigned int v39; // [sp+20h] [bp-84h]@1
  int v40; // [sp+24h] [bp-80h]@1
  int v41; // [sp+28h] [bp-7Ch]@13
  int v42; // [sp+2Ch] [bp-78h]@2
  int v43; // [sp+2Ch] [bp-78h]@14
  int v44; // [sp+2Ch] [bp-78h]@19
  int v45; // [sp+34h] [bp-70h]@62
  int v46; // [sp+38h] [bp-6Ch]@62
  int v47; // [sp+3Ch] [bp-68h]@62
  int v48; // [sp+40h] [bp-64h]@62
  int v49; // [sp+44h] [bp-60h]@62
  void *v50; // [sp+48h] [bp-5Ch]@62
  int v51; // [sp+58h] [bp-4Ch]@62
  unsigned int v52; // [sp+5Ch] [bp-48h]@62
  int v53; // [sp+64h] [bp-40h]@19
  int v54; // [sp+68h] [bp-3Ch]@19
  int v55; // [sp+6Ch] [bp-38h]@19
  int v56; // [sp+70h] [bp-34h]@19
  int v57; // [sp+74h] [bp-30h]@19
  void *v58; // [sp+78h] [bp-2Ch]@19
  int v59; // [sp+88h] [bp-1Ch]@19
  unsigned int v60; // [sp+8Ch] [bp-18h]@19
  unsigned int v61; // [sp+94h] [bp-10h]@1
  int v62; // [sp+A0h] [bp-4h]@23
  int v63; // [sp+A4h] [bp+0h]@1

  v61 = (unsigned int)&v63 ^ __security_cookie;
  v39 = a2;
  v34 = a1;
  v6 = a2;
  v7 = (signed int)((unsigned __int64)(715827883i64 * (signed int)(a3 - a2)) >> 32) >> 3;
  v5 = v39 + 48 * (signed int)(v7 + ((unsigned int)v7 >> 31)) / 2;
  sub_10007110(v6, v5, a3 - 48, a4);
  v4 = v5 + 48;
  v40 = v5 + 48;
  if ( v39 < v5 )
  {
    do
    {
      v42 = v5 - 48;
      if ( (unsigned __int8)a4(v5 - 48, v5) )
        break;
      if ( (unsigned __int8)a4(v5, v42) )
        break;
      v5 -= 48;
    }
    while ( v39 < v42 );
    v4 = v40;
  }
  v8 = a3;
  if ( v4 < a3 )
  {
    while ( !(unsigned __int8)a4(v4, v5) )
    {
      v9 = a4(v5, v4);
      v8 = a3;
      if ( !v9 )
      {
        v4 += 48;
        if ( v4 < a3 )
          continue;
      }
      goto LABEL_12;
    }
    v8 = a3;
LABEL_12:
    v40 = v4;
  }
  v10 = v5;
  v11 = v4;
  v41 = v5;
  while ( 2 )
  {
    v43 = v11;
LABEL_15:
    if ( v11 < v8 )
    {
      v12 = (int *)(v11 + 20);
      do
      {
        if ( !(unsigned __int8)a4(v5, v11) )
        {
          if ( (unsigned __int8)a4(v11, v5) )
            break;
          v13 = v40;
          v15 = *(_DWORD *)(v40 + 40) < 0x10u;
          v40 += 48;
          v53 = *(_DWORD *)v13;
          v54 = *(_DWORD *)(v13 + 4);
          v55 = *(_DWORD *)(v13 + 8);
          v14 = v13 + 20;
          v56 = *(_DWORD *)(v13 + 12);
          v44 = v13;
          v57 = *(_DWORD *)(v13 + 16);
          v37 = v13 + 20;
          v60 = 15;
          v59 = 0;
          LOBYTE(v58) = 0;
          if ( v15 )
          {
            if ( *(_DWORD *)(v13 + 36) != -1 )
            {
              sub_1002A4B0(&v58, (const void *)(v13 + 20), *(_DWORD *)(v13 + 36) + 1);
              v14 = v37;
              v13 = v44;
            }
          }
          else
          {
            v58 = *(void **)v14;
            *(_DWORD *)v14 = 0;
          }
          v59 = *(_DWORD *)(v14 + 16);
          v60 = *(_DWORD *)(v14 + 20);
          *(_DWORD *)(v14 + 20) = 15;
          *(_DWORD *)(v14 + 16) = 0;
          *(_BYTE *)v14 = 0;
          v62 = 0;
          *(_DWORD *)v13 = *(_DWORD *)v11;
          *(_DWORD *)(v13 + 4) = *(_DWORD *)(v11 + 4);
          *(_DWORD *)(v13 + 8) = *(v12 - 3);
          *(_DWORD *)(v13 + 12) = *(v12 - 2);
          *(_DWORD *)(v13 + 16) = *(v12 - 1);
          if ( (int *)v14 != v12 )
            loc_1000AB40(v12, 0, -1);
          *(_DWORD *)v11 = v53;
          *(_DWORD *)(v11 + 4) = v54;
          *(v12 - 3) = v55;
          *(v12 - 2) = v56;
          *(v12 - 1) = v57;
          if ( (void **)v12 != &v58 )
            loc_1000AB40(v12, &v58, 0, -1);
          v62 = -1;
          if ( v60 >= 0x10 )
            sub_1002A4AA(v58);
        }
        v11 += 48;
        v12 += 12;
      }
      while ( v11 < a3 );
      v10 = v41;
      v43 = v11;
    }
    v16 = v10 == v39;
    if ( v10 <= v39 )
      goto LABEL_49;
    v17 = (int *)(v10 - 28);
    v18 = v5 + 36;
    while ( (unsigned __int8)a4(v17 - 5, v5) )
    {
LABEL_45:
      v22 = v39;
      v10 = v41 - 48;
      v17 -= 12;
      v41 = v10;
      if ( v39 >= v10 )
        goto LABEL_48;
    }
    if ( !(unsigned __int8)a4(v5, v17 - 5) )
    {
      v19 = *(_DWORD *)(v5 - 48);
      v5 -= 48;
      v53 = v19;
      v18 -= 48;
      v54 = *(_DWORD *)(v5 + 4);
      v20 = *(_DWORD *)(v18 + 4) < 0x10u;
      v55 = *(_DWORD *)(v18 - 28);
      v56 = *(_DWORD *)(v18 - 24);
      v57 = *(_DWORD *)(v18 - 20);
      v60 = 15;
      v59 = 0;
      LOBYTE(v58) = 0;
      if ( v20 )
      {
        if ( *(_DWORD *)v18 != -1 )
          sub_1002A4B0(&v58, (const void *)(v18 - 16), *(_DWORD *)v18 + 1);
      }
      else
      {
        v58 = *(void **)(v18 - 16);
        *(_DWORD *)(v18 - 16) = 0;
      }
      v59 = *(_DWORD *)v18;
      v60 = *(_DWORD *)(v18 + 4);
      *(_DWORD *)(v18 + 4) = 15;
      *(_DWORD *)v18 = 0;
      *(_BYTE *)(v18 - 16) = 0;
      v62 = 1;
      v21 = (int)(v17 - 5);
      *(_DWORD *)v5 = *(v17 - 5);
      *(_DWORD *)(v5 + 4) = *(int *)((char *)v17 - 1);
      *(_DWORD *)(v18 - 28) = *(v17 - 3);
      *(_DWORD *)(v18 - 24) = *(v17 - 2);
      *(_DWORD *)(v18 - 20) = *(v17 - 1);
      if ( (int *)(v18 - 16) != v17 )
      {
        loc_1000AB40(v18 - 16, v17, 0, -1);
        v21 = (int)(v17 - 5);
      }
      *(_DWORD *)v21 = v53;
      *(_DWORD *)(v21 + 4) = v54;
      *(v17 - 3) = v55;
      *(v17 - 2) = v56;
      *(v17 - 1) = v57;
      if ( (void **)v17 != &v58 )
        loc_1000AB40(v17, &v58, 0, -1);
      v62 = -1;
      if ( v60 >= 0x10 )
        sub_1002A4AA(v58);
      goto LABEL_45;
    }
    v10 = v41;
    v22 = v39;
LABEL_48:
    v11 = v43;
    v16 = v10 == v22;
LABEL_49:
    if ( !v16 )
    {
      v32 = v10 - 48;
      v41 = v32;
      if ( v11 != a3 )
      {
        sub_10008190(v11, v32);
        v10 = v41;
        v8 = a3;
        v11 += 48;
        continue;
      }
      v5 -= 48;
      if ( v32 != v5 )
        sub_10008190(v32, v5);
      v40 -= 48;
      sub_10008190(v5, v40);
      v10 = v41;
      v8 = a3;
      goto LABEL_15;
    }
    break;
  }
  if ( v11 != a3 )
  {
    if ( v40 != v11 )
    {
      v23 = *(_DWORD *)(v5 + 40) < 0x10u;
      v53 = *(_DWORD *)v5;
      v54 = *(_DWORD *)(v5 + 4);
      v55 = *(_DWORD *)(v5 + 8);
      v24 = v5 + 20;
      v56 = *(_DWORD *)(v5 + 12);
      v57 = *(_DWORD *)(v5 + 16);
      v60 = 15;
      v59 = 0;
      LOBYTE(v58) = 0;
      if ( v23 )
      {
        if ( *(_DWORD *)(v5 + 36) != -1 )
        {
          sub_1002A4B0(&v58, (const void *)(v5 + 20), *(_DWORD *)(v5 + 36) + 1);
          v24 = v5 + 20;
        }
      }
      else
      {
        v58 = *(void **)v24;
        *(_DWORD *)v24 = 0;
      }
      v59 = *(_DWORD *)(v24 + 16);
      v60 = *(_DWORD *)(v24 + 20);
      *(_DWORD *)(v24 + 20) = 15;
      *(_DWORD *)(v24 + 16) = 0;
      *(_BYTE *)v24 = 0;
      v62 = 2;
      *(_DWORD *)v5 = *(_DWORD *)v40;
      *(_DWORD *)(v5 + 4) = *(_DWORD *)(v40 + 4);
      *(_DWORD *)(v5 + 8) = *(_DWORD *)(v40 + 8);
      *(_DWORD *)(v5 + 12) = *(_DWORD *)(v40 + 12);
      v25 = (int *)(v40 + 20);
      *(_DWORD *)(v5 + 16) = *(_DWORD *)(v40 + 16);
      if ( v24 != v40 + 20 )
      {
        loc_1000AB40(v40 + 20, 0, -1);
        v25 = (int *)(v40 + 20);
      }
      *(_DWORD *)v40 = v53;
      *(_DWORD *)(v40 + 4) = v54;
      *(_DWORD *)(v40 + 8) = v55;
      *(_DWORD *)(v40 + 12) = v56;
      *(_DWORD *)(v40 + 16) = v57;
      if ( (void **)v25 != &v58 )
        loc_1000AB40(v25, &v58, 0, -1);
      if ( v60 >= 0x10 )
        sub_1002A4AA(v58);
    }
    v27 = v5;
    v45 = *(_DWORD *)v5;
    v46 = *(_DWORD *)(v5 + 4);
    v47 = *(_DWORD *)(v5 + 8);
    v40 += 48;
    v26 = v11;
    v28 = v5 + 20;
    v11 += 48;
    v48 = *(_DWORD *)(v5 + 12);
    v29 = *(_DWORD *)(v5 + 16);
    v5 += 48;
    v30 = *(_DWORD *)(v28 + 20) < 0x10u;
    v38 = v26;
    v35 = v27;
    v43 = v11;
    v49 = v29;
    v52 = 15;
    v51 = 0;
    LOBYTE(v50) = 0;
    if ( v30 )
    {
      if ( *(_DWORD *)(v28 + 16) != -1 )
      {
        sub_1002A4B0(&v50, (const void *)v28, *(_DWORD *)(v28 + 16) + 1);
        v27 = v35;
        v26 = v38;
      }
    }
    else
    {
      v50 = *(void **)v28;
      *(_DWORD *)v28 = 0;
    }
    v51 = *(_DWORD *)(v28 + 16);
    v52 = *(_DWORD *)(v28 + 20);
    *(_DWORD *)(v28 + 20) = 15;
    *(_DWORD *)(v28 + 16) = 0;
    *(_BYTE *)v28 = 0;
    v62 = 3;
    *(_DWORD *)v27 = *(_DWORD *)v26;
    *(_DWORD *)(v27 + 4) = *(_DWORD *)(v26 + 4);
    *(_DWORD *)(v27 + 8) = *(_DWORD *)(v26 + 8);
    *(_DWORD *)(v27 + 12) = *(_DWORD *)(v26 + 12);
    *(_DWORD *)(v27 + 16) = *(_DWORD *)(v26 + 16);
    v31 = (int *)(v26 + 20);
    v36 = v26 + 20;
    if ( v28 != v26 + 20 )
    {
      loc_1000AB40(v28, v26 + 20, 0, -1);
      v26 = v38;
      v31 = (int *)v36;
    }
    *(_DWORD *)v26 = v45;
    *(_DWORD *)(v26 + 4) = v46;
    *(_DWORD *)(v26 + 8) = v47;
    *(_DWORD *)(v26 + 12) = v48;
    *(_DWORD *)(v26 + 16) = v49;
    if ( (void **)v31 != &v50 )
      loc_1000AB40(&v50, 0, -1);
    v62 = -1;
    if ( v52 >= 0x10 )
      sub_1002A4AA(v50);
    v10 = v41;
    v8 = a3;
    v52 = 15;
    v51 = 0;
    LOBYTE(v50) = 0;
    goto LABEL_15;
  }
  result = v34;
  *(_DWORD *)v34 = v5;
  *(_DWORD *)(v34 + 4) = v40;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10006900) --------------------------------------------------------
int __fastcall sub_10006900(int a1, int a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax@1
  int v4; // edi@1
  signed int v5; // esi@1
  signed int v6; // edx@1
  int v7; // [sp+10h] [bp-4h]@1

  v4 = a2;
  v5 = a2 - a1;
  v6 = (signed int)((unsigned __int64)(715827883i64 * (a2 - a1)) >> 32) >> 3;
  result = v6 + ((unsigned int)v6 >> 31);
  v7 = a1;
  if ( result > 1 )
  {
    do
    {
      sub_10008790(a1, v4, a3);
      a1 = v7;
      v5 -= 48;
      result = v5 / 48;
      v4 -= 48;
    }
    while ( v5 / 48 > 1 );
  }
  return result;
}

//----- (10006970) --------------------------------------------------------
char __cdecl sub_10006970(int a1, int a2)
{
  char result; // al@1

  result = 0;
  if ( a2 )
  {
    _EDI = -1;
    _EDX = a2 + 4;
    _ECX = -1;
    __asm { lock xadd [edx], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))a2)(a2);
      _EAX = a2 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)a2 + 4))(a2);
      result = 0;
    }
  }
  return result;
}

//----- (100069B0) --------------------------------------------------------
int __userpurge sub_100069B0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // edi@1
  int v10; // eax@3
  int v11; // eax@4
  int v13; // [sp-8h] [bp-30h]@4
  int v14; // [sp-4h] [bp-2Ch]@3
  char v15; // [sp+Ch] [bp-1Ch]@2
  int v16; // [sp+18h] [bp-10h]@1
  int v17; // [sp+24h] [bp-4h]@1

  v9 = a2;
  v17 = 0;
  v16 = 0;
  if ( !*(_DWORD *)a2 )
  {
    sub_1002FFB9((int)&v15, (unsigned int)"then() cannot be called on a default constructed task.");
    sub_100355BB((int)&v15, (int)&unk_1006C878);
  }
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_10006BC0(a1, a4, v9, a2);
  v17 = 0;
  v16 = 1;
  sub_10005980(a4, 2);
  *(_BYTE *)(*(_DWORD *)a4 + 88) = *(_BYTE *)(*(_DWORD *)v9 + 88) != 0;
  *(_BYTE *)(*(_DWORD *)a4 + 89) = 0;
  *(_BYTE *)(*(_DWORD *)a4 + 90) = 1;
  v10 = sub_1002CB88(a3, v9, 0x34u);
  if ( v10 )
    v11 = sub_10006E20(v10, v9, a4, a5, v13, v14);
  else
    v11 = 0;
  sub_10009430(*(void **)v9, v11);
  return a4;
}

//----- (10006A90) --------------------------------------------------------
int __usercall sub_10006A90<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v3; // eax@1
  int *v4; // edi@1
  int v5; // esi@1
  int v6; // eax@2

  v4 = (int *)a1;
  v5 = a2;
  v3 = sub_1002ADB1(a1, a2, a3, a1, 184);
  if ( v3 )
    v6 = sub_10007630(v3, v4);
  else
    v6 = 0;
  *(_DWORD *)(v5 + 4) = v6;
  *(_DWORD *)v5 = v6 + 16;
  return v5;
}

//----- (10006B10) --------------------------------------------------------
int __usercall sub_10006B10<eax>(int a1<edx>, int a2<ecx>, int a3<edi>)
{
  int v3; // ecx@1
  int v4; // esi@1
  char *v6; // [sp-4h] [bp-3Ch]@4
  char v7; // [sp+8h] [bp-30h]@1
  int v8; // [sp+18h] [bp-20h]@2
  char *v9; // [sp+20h] [bp-18h]@1
  int v10; // [sp+24h] [bp-14h]@1
  int v11; // [sp+28h] [bp-10h]@1
  int v12; // [sp+34h] [bp-4h]@1

  v4 = a2;
  v11 = a2;
  v10 = 0;
  v9 = &v7;
  v12 = 0;
  v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    if ( v3 == a1 )
    {
      a1 = (int)&v7;
      v6 = &v7;
    }
    else
    {
      v6 = 0;
    }
    v8 = (**(int (__fastcall ***)(int, int, char *))v3)(v3, a1, v6);
  }
  else
  {
    v8 = 0;
  }
  v12 = 2;
  sub_100089A0(a1, v4, a3, (int)&v7, v3);
  v12 = -1;
  if ( v8 )
    (*(void (__stdcall **)(bool))(*(_DWORD *)v8 + 16))(v8 != (_DWORD)&v7);
  return v4;
}

//----- (10006BC0) --------------------------------------------------------
int __userpurge sub_10006BC0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4)
{
  int result; // eax@1
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // edi@4
  char v20; // [sp+0h] [bp-20h]@1
  char *v21; // [sp+10h] [bp-10h]@1
  int v22; // [sp+1Ch] [bp-4h]@1

  v21 = &v20;
  v5 = a2;
  v22 = 0;
  result = sub_1002ADB1(a1, a2, a2, a3, 16);
  v6 = result;
  if ( result )
  {
    *(_DWORD *)(result + 4) = 1;
    *(_DWORD *)(result + 8) = 1;
    *(_DWORD *)result = &off_10067054;
    *(_DWORD *)(result + 12) = 0;
  }
  else
  {
    v6 = 0;
  }
  v7 = *(_DWORD *)(v5 + 4);
  if ( v7 )
  {
    _ECX = v7 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v7)(v7);
      result = v7 + 8;
      _ECX = -1;
      __asm { lock xadd [eax], ecx }
      if ( _ZF )
        result = (*(int (**)(void))(*(_DWORD *)v7 + 4))();
    }
  }
  *(_DWORD *)(v5 + 4) = v6;
  *(_DWORD *)v5 = 0;
  return result;
}
// 10067054: using guessed type int (*off_10067054)();

//----- (10006C80) --------------------------------------------------------
int __thiscall sub_10006C80(int this, char a2, int a3)
{
  int v3; // ecx@1
  int result; // eax@3
  int v5; // esi@3

  v3 = *(_DWORD *)(this + 16);
  if ( !v3 )
    sub_10029561();
  result = (*(int (__stdcall **)(char *))(*(_DWORD *)v3 + 8))(&a2);
  v5 = a3;
  if ( a3 )
  {
    _EDI = -1;
    _ECX = a3 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      result = v5 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (**)(void))(*(_DWORD *)v5 + 4))();
    }
  }
  return result;
}

//----- (10006D10) --------------------------------------------------------
int __thiscall sub_10006D10(int this, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // esi@1

  v7 = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_BYTE *)(this + 25) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = &off_100670C8;
  sub_10004DE0(this + 32, a3);
  *(_DWORD *)(v7 + 4) = sub_10007740;
  *(_BYTE *)(v7 + 16) = 1;
  *(_DWORD *)v7 = &off_100670D0;
  sub_10004DE0(v7 + 40, a2);
  *(_DWORD *)(v7 + 48) = *(_DWORD *)a4;
  *(_BYTE *)(v7 + 25) = 1;
  *(_DWORD *)(v7 + 28) = 0;
  return v7;
}
// 100670C8: using guessed type int (__stdcall *off_100670C8)(char);
// 100670D0: using guessed type int (__stdcall *off_100670D0)(char);

//----- (10006DC0) --------------------------------------------------------
int __thiscall sub_10006DC0(int this)
{
  return sub_1000A690(*(_DWORD *)(this + 4));
}

//----- (10006DD0) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10006DD0())(char)
{
  return &off_100749E8;
}
// 100749E8: using guessed type int (__stdcall **off_100749E8)(char);

//----- (10006DE0) --------------------------------------------------------
int __thiscall sub_10006DE0(void *this)
{
  return (int)((char *)this + 4);
}

//----- (10006DF0) --------------------------------------------------------
int __thiscall sub_10006DF0(void *this, char a2)
{
  int result; // eax@1
  void *v3; // esi@1

  v3 = this;
  result = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)this + 20))(0);
  if ( a2 )
    result = sub_1002A4AA(v3);
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10006E20) --------------------------------------------------------
int __thiscall sub_10006E20(int this, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // esi@1

  v7 = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_BYTE *)(this + 25) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = &off_100670C8;
  sub_10004DE0(this + 32, a3);
  *(_DWORD *)(v7 + 4) = sub_10007750;
  *(_BYTE *)(v7 + 16) = 1;
  *(_DWORD *)v7 = &off_100670D0;
  sub_10004DE0(v7 + 40, a2);
  *(_DWORD *)(v7 + 48) = *(_DWORD *)a4;
  *(_BYTE *)(v7 + 25) = 1;
  *(_DWORD *)(v7 + 28) = 0;
  return v7;
}
// 100670C8: using guessed type int (__stdcall *off_100670C8)(char);
// 100670D0: using guessed type int (__stdcall *off_100670D0)(char);

//----- (10006E90) --------------------------------------------------------
int __thiscall sub_10006E90(int this)
{
  return (**(int (__thiscall ***)(_DWORD, _DWORD))(this + 16))(this + 16, 0);
}

//----- (10006EA0) --------------------------------------------------------
int __thiscall sub_10006EA0(int this)
{
  int v1; // ecx@1
  int result; // eax@2

  v1 = *(_DWORD *)(this + 12);
  if ( v1 )
    result = (**(int (__stdcall ***)(_DWORD))v1)(1);
  return result;
}

//----- (10006EB0) --------------------------------------------------------
void *__thiscall sub_10006EB0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_10067080;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067080: using guessed type int (*off_10067080[5])();

//----- (10006EE0) --------------------------------------------------------
void __userpurge sub_10006EE0(int *a1<ecx>, int a2<ebx>, int a3)
{
  int v3; // eax@1
  int v4; // edx@1
  int ebp0; // ebp@0
  int *v6; // esi@1
  int v7; // edx@4
  char v8; // [sp-14h] [bp-4Ch]@4
  int v9; // [sp-10h] [bp-48h]@4
  int v10; // [sp-Ch] [bp-44h]@4
  int v11; // [sp-8h] [bp-40h]@4
  unsigned int v12; // [sp-4h] [bp-3Ch]@1
  unsigned int v13; // [sp+28h] [bp-10h]@1
  int v14; // [sp+34h] [bp-4h]@1
  int v15; // [sp+38h] [bp+0h]@1

  v13 = (unsigned int)&v15 ^ __security_cookie;
  v12 = (unsigned int)&v15 ^ __security_cookie;
  v6 = a1;
  sub_1002C5B1(ebp0);
  sub_1002B62D(ebp0, *v6 + 12);
  v14 = 0;
  v3 = *v6;
  if ( *(_DWORD *)(*v6 + 64) )
  {
    (*(void (__stdcall **)(signed int, signed int, signed int, int))(**(_DWORD **)a3 + 4))(1, 1, 1, v3 + 64);
  }
  else
  {
    if ( *(_BYTE *)(v3 + 72) )
    {
      sub_10010010((int)&v8, v4, v3 + 48);
      sub_10003520(v7, *(_DWORD *)a3, a2, v8, v9, v10, v11);
    }
    else
    {
      sub_10006FA0(v3, a3);
    }
  }
  v14 = -1;
  sub_1002B6D6();
}
// 10073200: using guessed type int __security_cookie;

//----- (10006FA0) --------------------------------------------------------
int __thiscall sub_10006FA0(int this, int a2)
{
  int result; // eax@1
  int v3; // esi@1
  int v4; // edi@3
  int v5; // ecx@5
  int v6; // ecx@9

  v3 = this;
  result = *(_DWORD *)(this + 4);
  if ( a2 >= (unsigned int)result || (this = *(_DWORD *)this, *(_DWORD *)v3 > (unsigned int)a2) )
  {
    if ( result == *(_DWORD *)(v3 + 8) )
      result = loc_10007010(v3, this);
    v6 = *(_DWORD *)(v3 + 4);
    if ( v6 )
      result = sub_10004DE0(v6, a2);
  }
  else
  {
    v4 = (a2 - this) >> 3;
    if ( result == *(_DWORD *)(v3 + 8) )
      result = loc_10007010(v3, *(_DWORD *)v3);
    v5 = *(_DWORD *)(v3 + 4);
    if ( v5 )
    {
      result = sub_10004DE0(v5, *(_DWORD *)v3 + 8 * v4);
      *(_DWORD *)(v3 + 4) += 8;
      return result;
    }
  }
  *(_DWORD *)(v3 + 4) += 8;
  return result;
}

//----- (10007110) --------------------------------------------------------
int __fastcall sub_10007110(int a1, int a2, int a3, int (__cdecl *a4)(_DWORD, _DWORD))
{
  int v4; // eax@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // eax@2
  int v8; // esi@7
  int v9; // esi@12
  int result; // eax@19
  int v11; // [sp+10h] [bp-10h]@2
  int v12; // [sp+14h] [bp-Ch]@1
  int v13; // [sp+14h] [bp-Ch]@7
  int v14; // [sp+18h] [bp-8h]@2
  int v15; // [sp+18h] [bp-8h]@12
  int v16; // [sp+1Ch] [bp-4h]@2

  v5 = a1;
  v6 = a2;
  v4 = (a3 - a1) / 48;
  v12 = a1;
  if ( v4 <= 40 )
  {
    if ( (unsigned __int8)a4(a2, a1) )
      sub_10008190(v6, v5);
    result = a4(a3, v6);
    if ( (_BYTE)result )
    {
      sub_10008190(a3, v6);
      result = a4(v6, v5);
      if ( (_BYTE)result )
        result = (int)sub_10008190(v6, v5);
    }
  }
  else
  {
    v7 = (v4 + 1) / 8;
    v11 = 48 * v7;
    v14 = 96 * v7;
    v16 = a1 + 48 * v7;
    if ( (unsigned __int8)a4(a1 + 48 * v7, a1) )
      sub_10008190(v16, v12);
    if ( (unsigned __int8)a4(v12 + v14, v16) )
    {
      sub_10008190(v14 + v12, v16);
      if ( (unsigned __int8)a4(v16, v12) )
        sub_10008190(v16, v12);
    }
    v8 = v6 - v11;
    v13 = v11 + v6;
    if ( (unsigned __int8)a4(v6, v6 - v11) )
      sub_10008190(v6, v8);
    if ( (unsigned __int8)a4(v13, v6) )
    {
      sub_10008190(v13, v6);
      if ( (unsigned __int8)a4(v6, v8) )
        sub_10008190(v6, v8);
    }
    v9 = a3 - v11;
    v15 = a3 - v14;
    if ( (unsigned __int8)a4(a3 - v11, v15) )
      sub_10008190(v9, v15);
    if ( (unsigned __int8)a4(a3, v9) )
    {
      sub_10008190(a3, v9);
      if ( (unsigned __int8)a4(v9, v15) )
        sub_10008190(v9, v15);
    }
    if ( (unsigned __int8)a4(v6, v16) )
      sub_10008190(v6, v16);
    result = a4(v9, v6);
    if ( (_BYTE)result )
    {
      sub_10008190(v9, v6);
      result = a4(v6, v16);
      if ( (_BYTE)result )
        result = (int)sub_10008190(v6, v16);
    }
  }
  return result;
}

//----- (100072E0) --------------------------------------------------------
int __fastcall sub_100072E0(int a1, int a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int result; // eax@1
  int v4; // ebx@1
  int v5; // edi@1
  signed int v6; // edx@1
  int v7; // esi@2
  int v8; // eax@3
  char v9; // cf@3
  int v10; // [sp+10h] [bp-48h]@1
  int v11; // [sp+14h] [bp-44h]@3
  int v12; // [sp+18h] [bp-40h]@3
  int v13; // [sp+1Ch] [bp-3Ch]@3
  int v14; // [sp+20h] [bp-38h]@3
  int v15; // [sp+24h] [bp-34h]@3
  void *v16; // [sp+28h] [bp-30h]@3
  int v17; // [sp+38h] [bp-20h]@3
  unsigned int v18; // [sp+3Ch] [bp-1Ch]@3
  unsigned int v19; // [sp+44h] [bp-14h]@1
  int v20; // [sp+54h] [bp-4h]@7
  int v21; // [sp+58h] [bp+0h]@1

  v19 = (unsigned int)&v21 ^ __security_cookie;
  v4 = a1;
  v6 = (signed int)((unsigned __int64)(715827883i64 * (a2 - a1)) >> 32) >> 3;
  v10 = v6 + ((unsigned int)v6 >> 31);
  result = v10 - ((unsigned __int64)v10 >> 32);
  v5 = v10 / 2;
  if ( v10 / 2 > 0 )
  {
    v7 = 48 * v5 + a1 + 36;
    do
    {
      v8 = *(_DWORD *)(v7 - 84);
      v7 -= 48;
      v11 = v8;
      v12 = *(_DWORD *)(v7 - 32);
      v13 = *(_DWORD *)(v7 - 28);
      v14 = *(_DWORD *)(v7 - 24);
      --v5;
      v9 = *(_DWORD *)(v7 + 4) < 0x10u;
      v15 = *(_DWORD *)(v7 - 20);
      v18 = 15;
      v17 = 0;
      LOBYTE(v16) = 0;
      if ( v9 )
      {
        if ( *(_DWORD *)v7 != -1 )
          sub_1002A4B0(&v16, (const void *)(v7 - 16), *(_DWORD *)v7 + 1);
      }
      else
      {
        v16 = *(void **)(v7 - 16);
        *(_DWORD *)(v7 - 16) = 0;
      }
      v17 = *(_DWORD *)v7;
      v18 = *(_DWORD *)(v7 + 4);
      *(_DWORD *)(v7 + 4) = 15;
      *(_DWORD *)v7 = 0;
      *(_BYTE *)(v7 - 16) = 0;
      v20 = 0;
      result = sub_10008260(v4, v5, v10, (int)&v11, a3);
      v20 = -1;
      if ( v18 >= 0x10 )
        result = sub_1002A4AA(v16);
    }
    while ( v5 > 0 );
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10007420) --------------------------------------------------------
int __fastcall sub_10007420(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // edi@2
  char v6; // cf@3
  int v7; // ebx@3
  int v8; // esi@10
  int v9; // edi@11
  int v10; // [sp+10h] [bp-58h]@1
  int v11; // [sp+14h] [bp-54h]@2
  int v12; // [sp+1Ch] [bp-4Ch]@1
  int v13; // [sp+20h] [bp-48h]@1
  int v14; // [sp+24h] [bp-44h]@3
  int v15; // [sp+28h] [bp-40h]@3
  int v16; // [sp+2Ch] [bp-3Ch]@3
  int v17; // [sp+30h] [bp-38h]@3
  int v18; // [sp+34h] [bp-34h]@3
  void *v19; // [sp+38h] [bp-30h]@3
  int v20; // [sp+48h] [bp-20h]@3
  unsigned int v21; // [sp+4Ch] [bp-1Ch]@3
  unsigned int v22; // [sp+54h] [bp-14h]@1
  int v23; // [sp+64h] [bp-4h]@7
  int v24; // [sp+68h] [bp+0h]@1

  v22 = (unsigned int)&v24 ^ __security_cookie;
  v10 = a2;
  v13 = a1;
  result = a3;
  v4 = a1 + 48;
  v12 = a1 + 48;
  if ( a1 + 48 != a2 )
  {
    v5 = a1 + 84;
    v11 = a1 + 84;
    do
    {
      v6 = *(_DWORD *)(v5 + 4) < 0x10u;
      v14 = *(_DWORD *)v4;
      v15 = *(_DWORD *)(v4 + 4);
      v16 = *(_DWORD *)(v5 - 28);
      v17 = *(_DWORD *)(v5 - 24);
      v7 = v4;
      v18 = *(_DWORD *)(v5 - 20);
      v21 = 15;
      v20 = 0;
      LOBYTE(v19) = 0;
      if ( v6 )
      {
        if ( *(_DWORD *)v5 != -1 )
        {
          sub_1002A4B0(&v19, (const void *)(v5 - 16), *(_DWORD *)v5 + 1);
          a1 = v13;
        }
      }
      else
      {
        v19 = *(void **)(v5 - 16);
        *(_DWORD *)(v5 - 16) = 0;
      }
      v20 = *(_DWORD *)v5;
      v21 = *(_DWORD *)(v5 + 4);
      *(_DWORD *)(v5 + 4) = 15;
      *(_DWORD *)v5 = 0;
      *(_BYTE *)(v5 - 16) = 0;
      v23 = 0;
      if ( (unsigned __int8)((int (__cdecl *)(int *, int))a3)(&v14, a1) )
      {
        sub_10008860(v13, v4, v5 + 12);
        *(_DWORD *)v13 = v14;
        *(_DWORD *)(v13 + 4) = v15;
        *(_DWORD *)(v13 + 8) = v16;
        *(_DWORD *)(v13 + 12) = v17;
        *(_DWORD *)(v13 + 16) = v18;
        result = (int)&v19;
        if ( (void **)(v13 + 20) != &v19 )
          result = loc_1000AB40(v13 + 20, &v19, 0, -1);
      }
      else
      {
        v8 = v5 - 84;
        if ( (unsigned __int8)((int (__cdecl *)(int *, int))a3)(&v14, v5 - 84) )
        {
          v9 = v5 - 64;
          do
          {
            *(_DWORD *)v7 = *(_DWORD *)v8;
            *(_DWORD *)(v7 + 4) = *(_DWORD *)(v8 + 4);
            *(_DWORD *)(v7 + 8) = *(_DWORD *)(v9 - 12);
            *(_DWORD *)(v7 + 12) = *(_DWORD *)(v9 - 8);
            *(_DWORD *)(v7 + 16) = *(_DWORD *)(v9 - 4);
            if ( v7 + 20 != v9 )
              loc_1000AB40(v7 + 20, v9, 0, -1);
            v7 = v8;
            v8 -= 48;
            v9 -= 48;
          }
          while ( (unsigned __int8)((int (__cdecl *)(int *, int))a3)(&v14, v8) );
          v5 = v11;
        }
        *(_DWORD *)v7 = v14;
        *(_DWORD *)(v7 + 4) = v15;
        *(_DWORD *)(v7 + 8) = v16;
        *(_DWORD *)(v7 + 12) = v17;
        *(_DWORD *)(v7 + 16) = v18;
        result = (int)&v19;
        if ( (void **)(v7 + 20) != &v19 )
          result = loc_1000AB40(v7 + 20, &v19, 0, -1);
        v4 = v12;
      }
      v23 = -1;
      if ( v21 >= 0x10 )
        result = sub_1002A4AA(v19);
      a1 = v13;
      v4 += 48;
      v5 += 48;
      v12 = v4;
      v11 = v5;
    }
    while ( v4 != v10 );
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10007630) --------------------------------------------------------
int __thiscall sub_10007630(int this, int *a2)
{
  int v2; // edi@1
  int v3; // esi@1

  v3 = this;
  *(_DWORD *)(this + 4) = 1;
  *(_DWORD *)(this + 8) = 1;
  v2 = this + 16;
  *(_DWORD *)this = &off_10067044;
  if ( this != -16 )
  {
    sub_10009600((void *)(this + 16), *a2);
    *(_DWORD *)v2 = &off_10067144;
    *(_BYTE *)(v2 + 160) = 0;
    *(_DWORD *)(v2 + 160) &= 0xFFFFFEFFu;
    *(_DWORD *)(v2 + 164) = 0;
  }
  return v3;
}
// 10067044: using guessed type int (*off_10067044)();
// 10067144: using guessed type int (__stdcall *off_10067144)(char);

//----- (100076D0) --------------------------------------------------------
int __thiscall sub_100076D0(int this, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // esi@1
  int v12; // edi@3
  int v28; // [sp+14h] [bp+8h]@1

  v4 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  v3 = *(_DWORD *)(a2 + 4);
  v28 = *(_DWORD *)a2;
  if ( v3 )
  {
    _EAX = v3 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v12 = *(_DWORD *)(v4 + 4);
  if ( v12 )
  {
    _ECX = v12 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v12)(v12);
      _EAX = v12 + 8;
      _ECX = -1;
      __asm { lock xadd [eax], ecx }
      if ( _ZF )
        (*(void (__thiscall **)(int))(*(_DWORD *)v12 + 4))(v12);
    }
  }
  *(_DWORD *)v4 = v28;
  *(_DWORD *)(v4 + 4) = v3;
  return v4;
}

//----- (10007740) --------------------------------------------------------
void __cdecl sub_10007740(int a1)
{
  JUMPOUT(*(unsigned int *)loc_10007760);
}
// 10007760: using guessed type int __cdecl loc_10007760(int);

//----- (10007750) --------------------------------------------------------
int __usercall sub_10007750<eax>(int a1<eax>, int a2)
{
  int v2; // esi@1
  int v4; // edx@4
  unsigned int v5; // [sp-18h] [bp-50h]@1
  int v6; // [sp-14h] [bp-4Ch]@3
  int v7; // [sp-10h] [bp-48h]@3
  int v8; // [sp-Ch] [bp-44h]@3
  char v9; // [sp-8h] [bp-40h]@3
  int v10; // [sp+0h] [bp-38h]@4
  int v11; // [sp+4h] [bp-34h]@1
  unsigned int v12; // [sp+24h] [bp-14h]@1
  unsigned int *v13; // [sp+28h] [bp-10h]@1
  int v14; // [sp+2Ch] [bp-Ch]@1
  int (__cdecl *v15)(int, int); // [sp+30h] [bp-8h]@1
  int v16; // [sp+34h] [bp-4h]@1
  _DWORD *v17; // [sp+38h] [bp+0h]@1

  v17 = &v17;
  v16 = -1;
  v15 = sub_1005AAA0;
  v14 = a1;
  v12 = (unsigned int)&v17 ^ __security_cookie;
  v5 = (unsigned int)&v17 ^ __security_cookie;
  v13 = &v5;
  v2 = *(_DWORD *)(a2 + 32);
  v11 = a2;
  sub_1002B62D((int)&v17, v2 + 100);
  v16 = -1;
  if ( *(_DWORD *)(v2 + 84) == 4 )
  {
    sub_1002B6D6();
  }
  else
  {
    *(_DWORD *)(v2 + 84) = 1;
    sub_1002B6D6();
    v16 = 1;
    LOBYTE(v10) = 0;
    sub_10007D20(v4, a2, a2, v10, v10);
  }
  return sub_1002A49B(v8, v6, v7, (unsigned int)&v17 ^ v12, v9);
}
// 1005AAA0: using guessed type int __cdecl sub_1005AAA0(int, int);
// 10073200: using guessed type int __security_cookie;

//----- (10007940) --------------------------------------------------------
int __thiscall sub_10007940(int this, int a2, int a3)
{
  int v3; // edx@1
  int v4; // edi@1
  int result; // eax@3

  v4 = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)this = off_1006703C;
  sub_10004DE0(this + 20, a2);
  *(_DWORD *)(v4 + 4) = sub_100083A0;
  *(_BYTE *)(v4 + 16) = 1;
  *(_DWORD *)v4 = &off_10067040;
  *(_DWORD *)(v4 + 28) = *(_DWORD *)a3;
  *(_DWORD *)(v4 + 52) = 7;
  *(_DWORD *)(v4 + 48) = 0;
  *(_WORD *)(v4 + 32) = 0;
  loc_10009CC0(a3 + 4, 0, -1);
  v3 = *(_DWORD *)(a3 + 28);
  if ( v3 )
  {
    _EAX = v3 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  result = v4;
  *(_DWORD *)(v4 + 56) = v3;
  return result;
}
// 1006703C: using guessed type int (__stdcall *off_1006703C[2])(char);
// 10067040: using guessed type int (__stdcall *off_10067040)(char);

//----- (100079F0) --------------------------------------------------------
int __thiscall sub_100079F0(int this)
{
  int v1; // ecx@1
  int v3; // edi@1
  int v4; // esi@1
  int result; // eax@6
  int v13; // edi@6

  v4 = this;
  *(_DWORD *)this = &off_10067040;
  v3 = this + 28;
  v1 = *(_DWORD *)(this + 56);
  _EBX = -1;
  if ( v1 )
  {
    _EAX = v1 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v1 + 4))();
  }
  *(_DWORD *)(v3 + 28) = 0;
  if ( *(_DWORD *)(v3 + 24) >= 8u )
    sub_1002A4AA(*(LPVOID *)(v3 + 4));
  *(_DWORD *)(v3 + 24) = 7;
  *(_DWORD *)(v3 + 20) = 0;
  result = 0;
  *(_WORD *)(v3 + 4) = 0;
  *(_DWORD *)v4 = off_1006703C;
  v13 = *(_DWORD *)(v4 + 24);
  if ( v13 )
  {
    result = v13 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v13)(v13);
      result = v13 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        result = (*(int (**)(void))(*(_DWORD *)v13 + 4))();
    }
  }
  *(_DWORD *)v4 = &off_10060E80;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10060E80: using guessed type int (__stdcall *off_10060E80)(char);
// 1006703C: using guessed type int (__stdcall *off_1006703C[2])(char);
// 10067040: using guessed type int (__stdcall *off_10067040)(char);

//----- (10007B20) --------------------------------------------------------
int __userpurge sub_10007B20<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  int v4; // esi@1

  v4 = a1;
  sub_100079F0(a1);
  if ( a4 & 1 )
    sub_1002CC4D(a2, a3, v4);
  return v4;
}

//----- (10007B50) --------------------------------------------------------
int __userpurge sub_10007B50<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int v20; // [sp-4h] [bp-Ch]@2

  v4 = a1;
  *(_DWORD *)a1 = off_1006703C;
  v3 = *(_DWORD *)(a1 + 24);
  if ( v3 )
  {
    v20 = a2;
    _EBX = -1;
    _EDX = v3 + 4;
    _EAX = -1;
    __asm { lock xadd [edx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v3)(v3);
      _EAX = v3 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
    }
    a2 = v20;
  }
  *(_DWORD *)v4 = &off_10060E80;
  if ( a3 & 1 )
    sub_1002CC4D(a2, v3, v4);
  return v4;
}
// 10060E80: using guessed type int (__stdcall *off_10060E80)(char);
// 1006703C: using guessed type int (__stdcall *off_1006703C[2])(char);

//----- (10007BB0) --------------------------------------------------------
int __userpurge sub_10007BB0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // edx@1
  int v6; // ebx@1
  int v8; // esi@1
  int v9; // ebx@1
  int v10; // eax@1
  int result; // eax@8
  int v26; // ebx@8
  int v27; // ebx@8
  int v28; // eax@8
  int v52; // [sp-8h] [bp-44h]@6
  int v53; // [sp-4h] [bp-40h]@6
  int v54; // [sp+14h] [bp-28h]@1
  int v55; // [sp+18h] [bp-24h]@1
  int v56; // [sp+1Ch] [bp-20h]@1
  int v57; // [sp+20h] [bp-1Ch]@1
  char v58; // [sp+24h] [bp-18h]@1
  int v59; // [sp+28h] [bp-14h]@1
  int v60; // [sp+38h] [bp-4h]@1

  v9 = a2;
  v55 = a2;
  v56 = 0;
  v57 = 0;
  sub_10006BC0(a1, (int)&v56, a3, a2);
  v60 = 0;
  v10 = sub_10004DE0((int)&v58, v9 + 40);
  v8 = *(_DWORD *)(v10 + 4);
  *(_DWORD *)(v10 + 4) = v57;
  v5 = *(_DWORD *)v10;
  *(_DWORD *)v10 = v56;
  v6 = v59;
  _EDI = -1;
  v57 = v8;
  v54 = v5;
  v56 = v5;
  if ( v59 )
  {
    _EAX = v59 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v6)(v6);
      _EAX = v6 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v6 + 4))(v6, _EDX);
      v5 = v54;
    }
  }
  v52 = 0;
  v53 = 0;
  if ( &v52 != &v56 )
  {
    v53 = v8;
    v8 = 0;
    v57 = 0;
    v52 = v5;
    v56 = 0;
  }
  v27 = v55;
  v28 = sub_100043A0((void *)(v55 + 48), (int)&v58, v52, v53);
  LOBYTE(v60) = 1;
  result = sub_100083B0(v28, v27 + 32, v27);
  LOBYTE(v60) = 0;
  v26 = v59;
  if ( v59 )
  {
    result = v59 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v26)(v26);
      result = v26 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v26 + 4))(v26, _EDX);
    }
  }
  v60 = -1;
  if ( v8 )
  {
    result = v8 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v8)(v8);
      result = v8 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (**)(void))(*(_DWORD *)v8 + 4))();
    }
  }
  return result;
}

//----- (10007D20) --------------------------------------------------------
int __userpurge sub_10007D20<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // edx@1
  int v6; // ebx@1
  int v8; // esi@1
  int v9; // ebx@1
  int v10; // eax@1
  int result; // eax@8
  int v26; // ebx@8
  int v27; // ebx@8
  int v28; // eax@8
  int v52; // [sp-8h] [bp-44h]@6
  int v53; // [sp-4h] [bp-40h]@6
  int v54; // [sp+14h] [bp-28h]@1
  int v55; // [sp+18h] [bp-24h]@1
  int v56; // [sp+1Ch] [bp-20h]@1
  int v57; // [sp+20h] [bp-1Ch]@1
  char v58; // [sp+24h] [bp-18h]@1
  int v59; // [sp+28h] [bp-14h]@1
  int v60; // [sp+38h] [bp-4h]@1

  v9 = a2;
  v55 = a2;
  v56 = 0;
  v57 = 0;
  sub_10006BC0(a1, (int)&v56, a3, a2);
  v60 = 0;
  v10 = sub_10004DE0((int)&v58, v9 + 40);
  v8 = *(_DWORD *)(v10 + 4);
  *(_DWORD *)(v10 + 4) = v57;
  v5 = *(_DWORD *)v10;
  *(_DWORD *)v10 = v56;
  v6 = v59;
  _EDI = -1;
  v57 = v8;
  v54 = v5;
  v56 = v5;
  if ( v59 )
  {
    _EAX = v59 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v6)(v6);
      _EAX = v6 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v6 + 4))(v6, _EDX);
      v5 = v54;
    }
  }
  v52 = 0;
  v53 = 0;
  if ( &v52 != &v56 )
  {
    v53 = v8;
    v8 = 0;
    v57 = 0;
    v52 = v5;
    v56 = 0;
  }
  v27 = v55;
  v28 = sub_10004650((void *)(v55 + 48), (int)&v58, v52, v53);
  LOBYTE(v60) = 1;
  result = sub_100083B0(v28, v27 + 32, v27);
  LOBYTE(v60) = 0;
  v26 = v59;
  if ( v59 )
  {
    result = v59 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v26)(v26);
      result = v26 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v26 + 4))(v26, _EDX);
    }
  }
  v60 = -1;
  if ( v8 )
  {
    result = v8 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v8)(v8);
      result = v8 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (**)(void))(*(_DWORD *)v8 + 4))();
    }
  }
  return result;
}

//----- (10007E90) --------------------------------------------------------
int __fastcall sub_10007E90(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  char v7; // [sp+0h] [bp-28h]@1
  int v8; // [sp+10h] [bp-18h]@3
  int v9; // [sp+14h] [bp-14h]@1
  char *v10; // [sp+18h] [bp-10h]@1
  int v11; // [sp+24h] [bp-4h]@1

  v10 = &v7;
  v3 = a2;
  v4 = a1;
  v5 = a3;
  v9 = a3;
  v11 = 0;
  while ( v4 != v3 )
  {
    v8 = v5;
    LOBYTE(v11) = 1;
    if ( v5 )
    {
      *(_DWORD *)v5 = *(_DWORD *)v4;
      *(_DWORD *)(v5 + 4) = *(_DWORD *)(v4 + 4);
      *(_DWORD *)(v5 + 8) = *(_DWORD *)(v4 + 8);
      *(_DWORD *)(v5 + 12) = *(_DWORD *)(v4 + 12);
      *(_DWORD *)(v5 + 16) = *(_DWORD *)(v4 + 16);
      *(_DWORD *)(v5 + 40) = 15;
      *(_DWORD *)(v5 + 36) = 0;
      *(_BYTE *)(v5 + 20) = 0;
      loc_1000AB40(v4 + 20, 0, -1);
    }
    v5 += 48;
    LOBYTE(v11) = 0;
    v4 += 48;
  }
  return v5;
}

//----- (10007F60) --------------------------------------------------------
int __fastcall sub_10007F60(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // edx@1
  signed int v5; // ecx@1
  int v6; // edi@1
  int v7; // esi@1
  signed int v8; // edx@1
  signed int v9; // edi@2
  int v10; // edx@3
  int v11; // eax@7
  int v12; // edx@7
  int v13; // ecx@7
  int v14; // ebx@8
  int v15; // esi@8
  char v16; // cf@10
  int v17; // edi@10
  int v18; // ecx@20
  signed int v19; // edx@20
  int v20; // eax@22
  int v21; // edx@24
  unsigned __int8 v22; // zf@24
  unsigned __int8 v23; // sf@24
  int v24; // [sp+10h] [bp-58h]@7
  int v25; // [sp+14h] [bp-54h]@7
  int v26; // [sp+18h] [bp-50h]@1
  int v27; // [sp+1Ch] [bp-4Ch]@1
  int v28; // [sp+20h] [bp-48h]@1
  int v29; // [sp+24h] [bp-44h]@10
  int v30; // [sp+28h] [bp-40h]@10
  int v31; // [sp+2Ch] [bp-3Ch]@10
  int v32; // [sp+30h] [bp-38h]@10
  int v33; // [sp+34h] [bp-34h]@10
  void *v34; // [sp+38h] [bp-30h]@10
  int v35; // [sp+48h] [bp-20h]@10
  unsigned int v36; // [sp+4Ch] [bp-1Ch]@10
  unsigned int v37; // [sp+54h] [bp-14h]@1
  int v38; // [sp+64h] [bp-4h]@14
  int v39; // [sp+68h] [bp+0h]@1

  v37 = (unsigned int)&v39 ^ __security_cookie;
  v27 = a1;
  v8 = (signed int)((unsigned __int64)(715827883i64 * (a2 - a1)) >> 32) >> 3;
  v6 = v8 + ((unsigned int)v8 >> 31);
  result = 715827883 * (a3 - a1);
  v7 = (a3 - a1) / 48;
  v4 = (a3 - a1) / 48;
  v26 = v6;
  v28 = (a3 - a1) / 48;
  v5 = v6;
  if ( v6 )
  {
    v9 = v4;
    do
    {
      result = v9 / v5;
      v10 = v9 % v5;
      v9 = v5;
      v5 = v10;
    }
    while ( v10 );
    v28 = v9;
    v6 = v26;
    v4 = v28;
  }
  if ( v4 < v7 )
  {
    if ( v4 > 0 )
    {
      v11 = 3 * v4;
      v12 = v27;
      v13 = 48 * v6;
      result = v27 + 16 * v11;
      v24 = 48 * v6;
      v25 = result;
      do
      {
        v15 = v13 + result;
        v14 = result;
        if ( v13 + result == a3 )
          v15 = v12;
        do
        {
          v16 = *(_DWORD *)(v14 + 40) < 0x10u;
          v29 = *(_DWORD *)v14;
          v30 = *(_DWORD *)(v14 + 4);
          v31 = *(_DWORD *)(v14 + 8);
          v17 = v14 + 20;
          v32 = *(_DWORD *)(v14 + 12);
          v33 = *(_DWORD *)(v14 + 16);
          v36 = 15;
          v35 = 0;
          LOBYTE(v34) = 0;
          if ( v16 )
          {
            if ( *(_DWORD *)(v14 + 36) != -1 )
              sub_1002A4B0(&v34, (const void *)(v14 + 20), *(_DWORD *)(v14 + 36) + 1);
          }
          else
          {
            v34 = *(void **)v17;
            *(_DWORD *)v17 = 0;
          }
          v35 = *(_DWORD *)(v14 + 36);
          v36 = *(_DWORD *)(v14 + 40);
          *(_DWORD *)(v14 + 40) = 15;
          *(_DWORD *)(v14 + 36) = 0;
          *(_BYTE *)v17 = 0;
          v38 = 0;
          *(_DWORD *)v14 = *(_DWORD *)v15;
          *(_DWORD *)(v14 + 4) = *(_DWORD *)(v15 + 4);
          *(_DWORD *)(v14 + 8) = *(_DWORD *)(v15 + 8);
          *(_DWORD *)(v14 + 12) = *(_DWORD *)(v15 + 12);
          *(_DWORD *)(v14 + 16) = *(_DWORD *)(v15 + 16);
          if ( v17 != v15 + 20 )
            loc_1000AB40(v17, v15 + 20, 0, -1);
          *(_DWORD *)v15 = v29;
          *(_DWORD *)(v15 + 4) = v30;
          *(_DWORD *)(v15 + 8) = v31;
          *(_DWORD *)(v15 + 12) = v32;
          *(_DWORD *)(v15 + 16) = v33;
          if ( (void **)(v15 + 20) != &v34 )
            loc_1000AB40(v15 + 20, &v34, 0, -1);
          v38 = -1;
          if ( v36 >= 0x10 )
            sub_1002A4AA(v34);
          v19 = (signed int)((unsigned __int64)(715827883i64 * (a3 - v15)) >> 32) >> 3;
          v18 = v19 + ((unsigned int)v19 >> 31);
          v14 = v15;
          if ( v26 >= v18 )
          {
            v20 = v26 - v18;
            v13 = v24;
            v15 = v27 + 48 * v20;
          }
          else
          {
            v13 = v24;
            v15 += v24;
          }
        }
        while ( v15 != v25 );
        v21 = v28 - 1;
        result = v25 - 48;
        v28 = v21;
        v22 = v21 == 0;
        v23 = v21 < 0;
        v12 = v27;
        v25 -= 48;
      }
      while ( !(v23 | v22) );
    }
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10008190) --------------------------------------------------------
int *__fastcall sub_10008190(int a1, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int *result; // eax@3
  int v5; // [sp+Ch] [bp-40h]@1
  int v6; // [sp+10h] [bp-3Ch]@3
  int v7; // [sp+14h] [bp-38h]@3
  int v8; // [sp+18h] [bp-34h]@3
  int v9; // [sp+1Ch] [bp-30h]@3
  void *v10; // [sp+20h] [bp-2Ch]@3
  unsigned int v11; // [sp+34h] [bp-18h]@5
  unsigned int v12; // [sp+3Ch] [bp-10h]@1
  int v13; // [sp+48h] [bp-4h]@1
  int v14; // [sp+4Ch] [bp+0h]@1

  v12 = (unsigned int)&v14 ^ __security_cookie;
  v2 = a2;
  v3 = a1;
  sub_100016C0((int)&v5, a1);
  v13 = 0;
  *(_DWORD *)v3 = *(_DWORD *)v2;
  *(_DWORD *)(v3 + 4) = *(_DWORD *)(v2 + 4);
  *(_DWORD *)(v3 + 8) = *(_DWORD *)(v2 + 8);
  *(_DWORD *)(v3 + 12) = *(_DWORD *)(v2 + 12);
  *(_DWORD *)(v3 + 16) = *(_DWORD *)(v2 + 16);
  if ( v3 + 20 != v2 + 20 )
    loc_1000AB40(v3 + 20, v2 + 20, 0, -1);
  *(_DWORD *)v2 = v5;
  *(_DWORD *)(v2 + 4) = v6;
  *(_DWORD *)(v2 + 8) = v7;
  *(_DWORD *)(v2 + 12) = v8;
  *(_DWORD *)(v2 + 16) = v9;
  result = (int *)&v10;
  if ( (void **)(v2 + 20) != &v10 )
    result = (int *)loc_1000AB40(v2 + 20, &v10, 0, -1);
  if ( v11 >= 0x10 )
    result = (int *)sub_1002A4AA(v10);
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10008260) --------------------------------------------------------
int __fastcall sub_10008260(int a1, int a2, int a3, int a4, int (__cdecl *a5)(_DWORD, _DWORD))
{
  char i; // zf@1
  int v6; // edi@1
  int v7; // esi@1
  int v8; // edx@4
  int v9; // edx@4
  int v10; // ecx@4
  int v11; // edx@8
  int v12; // edx@8
  int v13; // ecx@8
  int v15; // [sp+Ch] [bp-8h]@1
  int v16; // [sp+10h] [bp-4h]@1

  v6 = a2;
  v16 = a1;
  v7 = 2 * a2 + 2;
  v15 = a2;
  for ( i = v7 == a3; v7 < a3; i = v7 == a3 )
  {
    if ( (unsigned __int8)a5(48 * v7 + a1, 48 * v7 + a1 - 48) )
      --v7;
    v9 = v16 + 48 * v7;
    v10 = 48 * v6 + v16;
    *(_DWORD *)v10 = *(_DWORD *)v9;
    *(_DWORD *)(v10 + 4) = *(_DWORD *)(v9 + 4);
    *(_DWORD *)(v10 + 8) = *(_DWORD *)(v9 + 8);
    *(_DWORD *)(v10 + 12) = *(_DWORD *)(v9 + 12);
    *(_DWORD *)(v10 + 16) = *(_DWORD *)(v9 + 16);
    v8 = v9 + 20;
    if ( v10 + 20 != v8 )
      loc_1000AB40(v8, 0, -1);
    a1 = v16;
    v6 = v7;
    v7 = 2 * v7 + 2;
  }
  if ( i )
  {
    v12 = a1 + 48 * a3;
    v13 = 48 * v6 + a1;
    *(_DWORD *)v13 = *(_DWORD *)(v12 - 48);
    *(_DWORD *)(v13 + 4) = *(_DWORD *)(v12 - 44);
    *(_DWORD *)(v13 + 8) = *(_DWORD *)(v12 - 40);
    *(_DWORD *)(v13 + 12) = *(_DWORD *)(v12 - 36);
    *(_DWORD *)(v13 + 16) = *(_DWORD *)(v12 - 32);
    v11 = v12 - 28;
    if ( v13 + 20 != v11 )
      loc_1000AB40(v11, 0, -1);
    v6 = a3 - 1;
  }
  return sub_100086C0(v16, v6, v15, a4, a5);
}

//----- (10008350) --------------------------------------------------------
int __fastcall sub_10008350(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // edi@1
  int i; // esi@1
  int v6; // edx@4

  result = a3;
  v4 = a2;
  for ( i = a1; i != v4; result += 8 )
  {
    if ( result )
    {
      *(_DWORD *)result = 0;
      *(_DWORD *)(result + 4) = 0;
      if ( result != i )
      {
        *(_DWORD *)(result + 4) = *(_DWORD *)(i + 4);
        *(_DWORD *)(i + 4) = 0;
        v6 = *(_DWORD *)result;
        *(_DWORD *)result = *(_DWORD *)i;
        *(_DWORD *)i = v6;
      }
    }
    i += 8;
  }
  return result;
}

//----- (100083A0) --------------------------------------------------------
void __usercall sub_100083A0(int a1<ecx>, int a2<ebx>, int a3)
{
  sub_10008530(a3, a2);
}

//----- (100083B0) --------------------------------------------------------
int __usercall sub_100083B0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int result; // eax@1
  int v5; // esi@1
  int v6; // esi@1
  int v7; // edx@1
  int v8; // ST08_4@1
  int v9; // ST0C_4@1
  int v10; // ST10_4@1
  int v23; // esi@5
  char v35; // [sp+Ch] [bp-1Ch]@1
  int v36; // [sp+10h] [bp-18h]@1
  char v37; // [sp+14h] [bp-14h]@1
  int v38; // [sp+18h] [bp-10h]@5
  int v39; // [sp+24h] [bp-4h]@1

  v6 = a1;
  sub_10004DE0((int)&v37, a2);
  v39 = 0;
  result = sub_100088D0(v7, v6, a3, (int)&v35, (int)&v37, v8, v9, v10);
  v5 = v36;
  _EDI = -1;
  if ( v36 )
  {
    result = v36 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      result = v5 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v5 + 4))(v5, _EDX);
    }
  }
  v39 = -1;
  v23 = v38;
  if ( v38 )
  {
    result = v38 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v23)(v23);
      result = v23 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (**)(void))(*(_DWORD *)v23 + 4))();
    }
  }
  return result;
}

//----- (10008470) --------------------------------------------------------
int __userpurge sub_10008470<eax>(int a1<edx>, int *a2<ecx>, int a3<ebx>, int a4, int a5)
{
  int *v5; // esi@1
  int result; // eax@2
  int v7; // edx@2
  int v8; // ecx@3
  char v21; // [sp-10h] [bp-30h]@2
  int v22; // [sp-Ch] [bp-2Ch]@2
  int v23; // [sp-8h] [bp-28h]@2
  int v24; // [sp-4h] [bp-24h]@2
  int v25; // [sp+1Ch] [bp-4h]@1

  v5 = a2;
  v25 = 0;
  if ( *(_DWORD *)(a4 + 84) == 3 )
  {
    sub_10003420(a4, a1, (int)&v21);
    result = sub_10003520(v7, *v5, a3, v21, v22, v23, v24);
  }
  else
  {
    v8 = *a2;
    if ( *(_DWORD *)(a4 + 92) )
      result = (*(int (__stdcall **)(signed int, signed int, _DWORD, int))(*(_DWORD *)v8 + 4))(1, 1, 0, a4 + 92);
    else
      result = (*(int (__stdcall **)(signed int, _DWORD, _DWORD, int))(*(_DWORD *)v8 + 4))(1, 0, 0, v8 + 92);
  }
  v25 = -1;
  if ( a5 )
  {
    _EDI = -1;
    _ECX = a5 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))a5)(a5);
      result = a5 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (**)(void))(*(_DWORD *)a5 + 4))();
    }
  }
  return result;
}

//----- (10008530) --------------------------------------------------------
void __usercall sub_10008530(int a1<ecx>, int a2<ebx>)
{
  int ebp0; // ebp@0
  int v3; // edi@1
  int v4; // esi@1
  unsigned int v5; // [sp-4h] [bp-4Ch]@1
  int v6; // [sp+14h] [bp-34h]@1
  unsigned int v7; // [sp+34h] [bp-14h]@1
  unsigned int *v8; // [sp+38h] [bp-10h]@1
  int v9; // [sp+44h] [bp-4h]@1
  int v10; // [sp+48h] [bp+0h]@1

  v7 = (unsigned int)&v10 ^ __security_cookie;
  v5 = (unsigned int)&v10 ^ __security_cookie;
  v8 = &v5;
  v3 = a1;
  v4 = *(_DWORD *)(a1 + 20);
  v6 = a1;
  sub_1002B62D(ebp0, v4 + 100);
  v9 = -1;
  if ( *(_DWORD *)(v4 + 84) == 4 )
  {
    sub_1002B6D6();
  }
  else
  {
    *(_DWORD *)(v4 + 84) = 1;
    sub_1002B6D6();
    v9 = 1;
    sub_10008620(v3, a2, v6);
  }
}
// 10073200: using guessed type int __security_cookie;

//----- (10008620) --------------------------------------------------------
int __userpurge sub_10008620<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // esi@1
  int v6; // eax@1
  char v19; // [sp+Ch] [bp-18h]@1
  int v20; // [sp+10h] [bp-14h]@1
  int v21; // [sp+20h] [bp-4h]@1

  v5 = a1;
  v6 = sub_100045A0((void *)(a1 + 28), (int)&v19);
  v21 = 0;
  result = sub_100083B0(v6, v5 + 20, a2);
  v21 = -1;
  v4 = v20;
  if ( v20 )
  {
    _EDI = -1;
    _ECX = v20 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v4)(v4);
      result = v4 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (**)(void))(*(_DWORD *)v4 + 4))();
    }
  }
  return result;
}

//----- (100086C0) --------------------------------------------------------
int __fastcall sub_100086C0(int a1, int a2, int a3, int a4, int (__cdecl *a5)(_DWORD, _DWORD))
{
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // edi@2
  int v8; // edi@3
  int v9; // ecx@3
  int result; // eax@7
  int v11; // ecx@7
  int v12; // [sp+8h] [bp-4h]@1

  v5 = a2;
  v6 = (a2 - 1) / 2;
  v12 = a1;
  if ( a3 < a2 )
  {
    do
    {
      v7 = a1 + 48 * v6;
      if ( !(unsigned __int8)a5(a1 + 48 * v6, a4) )
        break;
      v9 = 48 * v5 + v12;
      *(_DWORD *)v9 = *(_DWORD *)v7;
      *(_DWORD *)(v9 + 4) = *(_DWORD *)(v7 + 4);
      *(_DWORD *)(v9 + 8) = *(_DWORD *)(v7 + 8);
      *(_DWORD *)(v9 + 12) = *(_DWORD *)(v7 + 12);
      *(_DWORD *)(v9 + 16) = *(_DWORD *)(v7 + 16);
      v8 = v7 + 20;
      if ( v9 + 20 != v8 )
        loc_1000AB40(v8, 0, -1);
      a1 = v12;
      v5 = v6;
      v6 = (v6 - 1) / 2;
    }
    while ( a3 < v5 );
    a1 = v12;
  }
  v11 = 48 * v5 + a1;
  *(_DWORD *)v11 = *(_DWORD *)a4;
  *(_DWORD *)(v11 + 4) = *(_DWORD *)(a4 + 4);
  *(_DWORD *)(v11 + 8) = *(_DWORD *)(a4 + 8);
  *(_DWORD *)(v11 + 12) = *(_DWORD *)(a4 + 12);
  result = *(_DWORD *)(a4 + 16);
  *(_DWORD *)(v11 + 16) = result;
  if ( v11 + 20 != a4 + 20 )
    result = loc_1000AB40(a4 + 20, 0, -1);
  return result;
}

//----- (10008790) --------------------------------------------------------
int __fastcall sub_10008790(int a1, int a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  int result; // eax@3
  char v7; // [sp+14h] [bp-40h]@1
  void *v8; // [sp+28h] [bp-2Ch]@4
  unsigned int v9; // [sp+3Ch] [bp-18h]@3
  unsigned int v10; // [sp+44h] [bp-10h]@1
  int v11; // [sp+50h] [bp-4h]@1
  int v12; // [sp+54h] [bp+0h]@1

  v10 = (unsigned int)&v12 ^ __security_cookie;
  v4 = a2;
  v3 = a1;
  v5 = a2 - 48;
  sub_100016C0((int)&v7, a2 - 48);
  v11 = 0;
  *(_DWORD *)v5 = *(_DWORD *)v3;
  *(_DWORD *)(v5 + 4) = *(_DWORD *)(v3 + 4);
  *(_DWORD *)(v5 + 8) = *(_DWORD *)(v3 + 8);
  *(_DWORD *)(v5 + 12) = *(_DWORD *)(v3 + 12);
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v3 + 16);
  if ( v5 + 20 != v3 + 20 )
    loc_1000AB40(v5 + 20, v3 + 20, 0, -1);
  result = sub_10008260(v3, 0, (v4 - v3 - 48) / 48, (int)&v7, a3);
  if ( v9 >= 0x10 )
    result = sub_1002A4AA(v8);
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10008860) --------------------------------------------------------
int __fastcall sub_10008860(int a1, int a2, int a3)
{
  int v3; // ebx@2
  int v4; // edi@2
  int v5; // esi@2
  int v6; // eax@3
  int result; // eax@6
  int v8; // [sp+0h] [bp-4h]@1

  v8 = a1;
  if ( a1 == a2 )
  {
    result = a3;
  }
  else
  {
    v3 = a3;
    v4 = a3 + 20;
    v5 = a2 + 20;
    do
    {
      v6 = *(_DWORD *)(v5 - 68);
      v5 -= 48;
      v3 -= 48;
      v4 -= 48;
      *(_DWORD *)v3 = v6;
      *(_DWORD *)(v3 + 4) = *(_DWORD *)(v5 - 16);
      *(_DWORD *)(v4 - 12) = *(_DWORD *)(v5 - 12);
      *(_DWORD *)(v4 - 8) = *(_DWORD *)(v5 - 8);
      *(_DWORD *)(v4 - 4) = *(_DWORD *)(v5 - 4);
      if ( v4 != v5 )
        loc_1000AB40(v4, v5, 0, -1);
    }
    while ( v5 - 20 != v8 );
    result = v3;
  }
  return result;
}

//----- (100088D0) --------------------------------------------------------
int __userpurge sub_100088D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8)
{
  int v9; // ST08_4@1
  int v10; // ST0C_4@1
  int v11; // ST10_4@1
  int v12; // ST14_4@1

  sub_10008A40(a1, a2, a3, a4, a5, v9, v10, v11, v12);
  return a4;
}

//----- (10008940) --------------------------------------------------------
int __thiscall sub_10008940(void *this, int a2)
{
  void *v2; // edi@1
  int v3; // ecx@2
  int v5; // [sp-8h] [bp-18h]@1
  int v6; // [sp-4h] [bp-14h]@1

  v2 = this;
  v5 = 0;
  v6 = 0;
  if ( &v5 != (int *)a2 )
  {
    v6 = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a2 + 4) = 0;
    v3 = v5;
    v5 = *(_DWORD *)a2;
    *(_DWORD *)a2 = v3;
  }
  return sub_100023C0((int)((char *)v2 + 4), v5, v6);
}

//----- (10008990) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10008990())(char)
{
  return &off_100749B0;
}
// 100749B0: using guessed type int (__stdcall **off_100749B0)(char);

//----- (100089A0) --------------------------------------------------------
int __userpurge sub_100089A0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // esi@1
  int v6; // ecx@3
  int result; // eax@9
  int v8; // [sp-4h] [bp-30h]@6
  int v9; // [sp+1Ch] [bp-10h]@1

  v9 = a2;
  v5 = sub_1002ADB1(a1, a2, a4, a3, 40);
  if ( !v5 )
    sub_10029530();
  *(_DWORD *)v5 = off_10067004;
  v6 = *(_DWORD *)(a4 + 16);
  if ( v6 )
  {
    if ( v6 == a4 )
      v8 = v5 + 8;
    else
      v8 = 0;
    *(_DWORD *)(v5 + 24) = (**(int (__stdcall ***)(_DWORD))v6)(v8);
  }
  else
  {
    *(_DWORD *)(v5 + 24) = 0;
  }
  result = v9;
  *(_DWORD *)(v9 + 16) = v5;
  return result;
}
// 10067004: using guessed type int (__stdcall *off_10067004[2])(int);

//----- (10008A40) --------------------------------------------------------
int __userpurge sub_10008A40<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // edi@1
  int v10; // eax@3
  int v11; // eax@4
  int v13; // [sp-8h] [bp-30h]@4
  int v14; // [sp-4h] [bp-2Ch]@3
  char v15; // [sp+Ch] [bp-1Ch]@2
  int v16; // [sp+18h] [bp-10h]@1
  int v17; // [sp+24h] [bp-4h]@1

  v9 = a2;
  v17 = 0;
  v16 = 0;
  if ( !*(_DWORD *)a2 )
  {
    sub_1002FFB9((int)&v15, (unsigned int)"then() cannot be called on a default constructed task.");
    sub_100355BB((int)&v15, (int)&unk_1006C878);
  }
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_10006BC0(a1, a4, v9, a2);
  v17 = 0;
  v16 = 1;
  sub_10009800(a4, 2);
  *(_BYTE *)(*(_DWORD *)a4 + 88) = *(_BYTE *)(*(_DWORD *)v9 + 88) != 0;
  *(_BYTE *)(*(_DWORD *)a4 + 89) = 0;
  *(_BYTE *)(*(_DWORD *)a4 + 90) = 0;
  v10 = sub_1002CB88(a3, v9, 0x38u);
  if ( v10 )
    v11 = sub_10008BF0(v10, v9, a4, a5, v13, v14);
  else
    v11 = 0;
  sub_10009430(*(void **)v9, v11);
  return a4;
}

//----- (10008B20) --------------------------------------------------------
int __userpurge sub_10008B20<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4)
{
  int v4; // ebx@1
  int v5; // esi@1
  int v6; // ecx@5
  int v7; // eax@8

  v4 = a2;
  v5 = a4;
  if ( !a4 )
  {
    v5 = sub_1002ADB1(a1, a2, a2, a3, 40);
    if ( !v5 )
      sub_10029530();
  }
  if ( v5 )
  {
    *(_DWORD *)v5 = off_10067004;
    v6 = *(_DWORD *)(v4 + 24);
    if ( v6 )
    {
      if ( v6 == v4 + 8 )
        v7 = (**(int (__stdcall ***)(_DWORD))v6)(v5 + 8);
      else
        v7 = (**(int (__stdcall ***)(_DWORD))v6)(0);
      *(_DWORD *)(v5 + 24) = v7;
    }
    else
    {
      *(_DWORD *)(v5 + 24) = 0;
    }
  }
  return v5;
}
// 10067004: using guessed type int (__stdcall *off_10067004[2])(int);

//----- (10008BC0) --------------------------------------------------------
char __thiscall sub_10008BC0(void *this, int a2)
{
  return sub_10008DA0((char *)this + 8, a2);
}

//----- (10008BD0) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10008BD0())(char)
{
  return &off_10074978;
}
// 10074978: using guessed type int (__stdcall **off_10074978)(char);

//----- (10008BE0) --------------------------------------------------------
int __thiscall sub_10008BE0(void *this)
{
  return (int)((char *)this + 8);
}

//----- (10008BF0) --------------------------------------------------------
int __thiscall sub_10008BF0(int this, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // esi@1

  v7 = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_BYTE *)(this + 25) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = &off_100670C8;
  sub_10004DE0(this + 32, a3);
  *(_DWORD *)(v7 + 4) = sub_10008E60;
  *(_BYTE *)(v7 + 16) = 1;
  *(_DWORD *)v7 = &off_10066FFC;
  sub_10004DE0(v7 + 40, a2);
  sub_10004DE0(v7 + 48, a4);
  *(_BYTE *)(v7 + 25) = 1;
  *(_DWORD *)(v7 + 28) = 16;
  return v7;
}
// 10066FFC: using guessed type int (__stdcall *off_10066FFC)(char);
// 100670C8: using guessed type int (__stdcall *off_100670C8)(char);

//----- (10008C60) --------------------------------------------------------
int __thiscall sub_10008C60(int this)
{
  int v2; // edi@1
  int v3; // esi@1
  int result; // eax@2
  int v17; // edi@5
  int v30; // edi@9

  v3 = this;
  *(_DWORD *)this = &off_10066FFC;
  v2 = *(_DWORD *)(this + 52);
  _EBX = -1;
  if ( v2 )
  {
    result = v2 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v2)(v2);
      result = v2 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v2 + 4))(v2, _EDX);
    }
  }
  v17 = *(_DWORD *)(v3 + 44);
  if ( v17 )
  {
    result = v17 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v17)(v17);
      result = v17 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v17 + 4))(v17, _EDX);
    }
  }
  *(_DWORD *)v3 = &off_100670C8;
  v30 = *(_DWORD *)(v3 + 36);
  if ( v30 )
  {
    result = v30 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v30)(v30);
      result = v30 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v30 + 4))(v30);
    }
  }
  *(_DWORD *)v3 = &off_10060E80;
  return result;
}
// 10060E80: using guessed type int (__stdcall *off_10060E80)(char);
// 10066FFC: using guessed type int (__stdcall *off_10066FFC)(char);
// 100670C8: using guessed type int (__stdcall *off_100670C8)(char);

//----- (10008D00) --------------------------------------------------------
void *__thiscall sub_10008D00(int this, char a2)
{
  int v2; // ecx@1
  int v3; // edi@1
  void *v4; // esi@1
  int v5; // ecx@3

  v4 = (void *)this;
  v3 = this + 8;
  *(_DWORD *)this = off_10067004;
  v2 = *(_DWORD *)(this + 24);
  if ( v2 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v2 + 16))(v2 != v3);
    *(_DWORD *)(v3 + 16) = 0;
  }
  v5 = *(_DWORD *)(v3 + 16);
  if ( v5 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v5 + 16))(v5 != v3);
    *(_DWORD *)(v3 + 16) = 0;
  }
  *(_DWORD *)v4 = off_10067080;
  if ( a2 & 1 )
    sub_1002A4AA(v4);
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067004: using guessed type int (__stdcall *off_10067004[2])(int);
// 10067080: using guessed type int (*off_10067080[5])();

//----- (10008D70) --------------------------------------------------------
int __userpurge sub_10008D70<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  int v4; // esi@1

  v4 = a1;
  sub_10008C60(a1);
  if ( a4 & 1 )
    sub_1002CC4D(a2, a3, v4);
  return v4;
}

//----- (10008DA0) --------------------------------------------------------
char __thiscall sub_10008DA0(void *this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v4; // eax@2
  char v20; // [sp-8h] [bp-28h]@3
  int v21; // [sp-4h] [bp-24h]@3
  int v22; // [sp+Ch] [bp-14h]@1
  int v23; // [sp+10h] [bp-10h]@1
  int v24; // [sp+1Ch] [bp-4h]@3

  v2 = (int)this;
  v3 = 0;
  v22 = 0;
  v23 = 0;
  if ( &v22 != (int *)a2 )
  {
    v3 = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a2 + 4) = 0;
    v4 = *(_DWORD *)a2;
    v23 = v3;
    v22 = v4;
    *(_DWORD *)a2 = 0;
  }
  v24 = 0;
  sub_10004DE0((int)&v20, (int)&v22);
  sub_10006C80(v2, v20, v21);
  v24 = -1;
  if ( v3 )
  {
    _EDI = -1;
    _ECX = v3 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v3)(v3);
      _EAX = v3 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
    }
  }
  return 0;
}

//----- (10008E60) --------------------------------------------------------
int __usercall sub_10008E60<eax>(int a1<eax>, int a2)
{
  int v2; // esi@1
  int v4; // edx@4
  unsigned int v5; // [sp-18h] [bp-54h]@1
  int v6; // [sp-14h] [bp-50h]@3
  int v7; // [sp-10h] [bp-4Ch]@3
  int v8; // [sp-Ch] [bp-48h]@3
  char v9; // [sp-8h] [bp-44h]@3
  int v10; // [sp+0h] [bp-3Ch]@4
  int v11; // [sp+4h] [bp-38h]@4
  int v12; // [sp+8h] [bp-34h]@1
  unsigned int v13; // [sp+28h] [bp-14h]@1
  unsigned int *v14; // [sp+2Ch] [bp-10h]@1
  int v15; // [sp+30h] [bp-Ch]@1
  int (__cdecl *v16)(int, int); // [sp+34h] [bp-8h]@1
  int v17; // [sp+38h] [bp-4h]@1
  _DWORD *v18; // [sp+3Ch] [bp+0h]@1

  v18 = &v18;
  v17 = -1;
  v16 = sub_1005AA20;
  v15 = a1;
  v13 = (unsigned int)&v18 ^ __security_cookie;
  v5 = (unsigned int)&v18 ^ __security_cookie;
  v14 = &v5;
  v2 = *(_DWORD *)(a2 + 32);
  v12 = a2;
  sub_1002B62D((int)&v18, v2 + 100);
  v17 = -1;
  if ( *(_DWORD *)(v2 + 84) == 4 )
  {
    sub_1002B6D6();
  }
  else
  {
    *(_DWORD *)(v2 + 84) = 1;
    sub_1002B6D6();
    v17 = 1;
    LOBYTE(v10) = 0;
    LOBYTE(v11) = 0;
    sub_10008F70(v4, a2, a2, v11, v10);
  }
  return sub_1002A49B(v8, v6, v7, (unsigned int)&v18 ^ v13, v9);
}
// 1005AA20: using guessed type int __cdecl sub_1005AA20(int, int);
// 10073200: using guessed type int __security_cookie;

//----- (10008F70) --------------------------------------------------------
void __userpurge sub_10008F70(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // edx@1
  int v6; // ebx@1
  int ebp0; // ebp@0
  int v9; // esi@1
  int v10; // ebx@1
  int v11; // eax@1
  int v26; // eax@9
  int v27; // ebx@11
  int v28; // eax@11
  int v29; // edx@15
  void **v43; // [sp-20h] [bp-94h]@9
  char v44; // [sp-1Ch] [bp-90h]@9
  int v45; // [sp-18h] [bp-8Ch]@11
  int v46; // [sp-14h] [bp-88h]@11
  char v47; // [sp-8h] [bp-7Ch]@6
  int v48; // [sp-4h] [bp-78h]@6
  char v49; // [sp+10h] [bp-64h]@1
  int v50; // [sp+14h] [bp-60h]@1
  int v51; // [sp+18h] [bp-5Ch]@1
  char *v52; // [sp+1Ch] [bp-58h]@1
  int v53; // [sp+20h] [bp-54h]@1
  char v54; // [sp+24h] [bp-50h]@1
  int v55; // [sp+28h] [bp-4Ch]@1
  char v56; // [sp+2Ch] [bp-48h]@11
  int v57; // [sp+3Ch] [bp-38h]@14
  unsigned int v58; // [sp+60h] [bp-14h]@1
  int v59; // [sp+70h] [bp-4h]@1

  v58 = (unsigned int)&v49 ^ __security_cookie;
  v10 = a2;
  v53 = a2;
  v50 = 0;
  v51 = 0;
  sub_10006BC0(a1, (int)&v50, a3, a2);
  v59 = 0;
  v11 = sub_10004DE0((int)&v54, v10 + 40);
  v9 = *(_DWORD *)(v11 + 4);
  *(_DWORD *)(v11 + 4) = v51;
  v5 = *(_DWORD *)v11;
  *(_DWORD *)v11 = v50;
  v6 = v55;
  _EDI = -1;
  v51 = v9;
  v52 = (char *)v5;
  v50 = v5;
  if ( v55 )
  {
    _EAX = v55 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v6)(v6);
      _EAX = v6 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v6 + 4))(v6, _EDX);
      v5 = (int)v52;
    }
  }
  v52 = &v47;
  *(_DWORD *)&v47 = 0;
  v48 = 0;
  if ( (int *)&v47 != &v50 )
  {
    v48 = v9;
    v9 = 0;
    v51 = 0;
    *(_DWORD *)&v47 = v5;
    v50 = 0;
  }
  if ( &v47 )
  {
    v43 = &off_10066FE0;
    sub_10004DE0((int)&v44, v53 + 48);
    v26 = (int)&v43;
  }
  else
  {
    v26 = 0;
  }
  LOBYTE(v59) = 1;
  v28 = sub_10005FD0((int)&v56, (char)v43, *(int *)&v44, v45, v46, v26);
  LOBYTE(v59) = 4;
  v27 = *(_DWORD *)(v53 + 32);
  *(_BYTE *)(v27 + 152) = sub_10006090(v28, v47, v48);
  sub_1002B62D(ebp0, v27 + 100);
  LOBYTE(v59) = 4;
  if ( *(_DWORD *)(v27 + 84) == 4 )
  {
    sub_1002B6D6();
  }
  else
  {
    *(_DWORD *)(v27 + 84) = 3;
    sub_1002B6D6();
    sub_1002C5B1(ebp0);
    sub_1000A690(v27);
  }
  LOBYTE(v59) = 0;
  if ( v57 )
  {
    v29 = *(_DWORD *)v57;
    v48 = v57 != (_DWORD)&v56;
    (*(void (__stdcall **)(int))(v29 + 16))(v48);
    v57 = 0;
  }
  v59 = -1;
  if ( v9 )
  {
    _EAX = v9 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v9)(v9);
      _EAX = v9 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (**)(void))(*(_DWORD *)v9 + 4))();
    }
  }
}
// 10066FE0: using guessed type void *off_10066FE0;
// 10073200: using guessed type int __security_cookie;

//----- (100091B0) --------------------------------------------------------
int __userpurge sub_100091B0<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v3; // edi@1
  int v4; // ecx@2
  int v6; // [sp-8h] [bp-18h]@1
  int v7; // [sp-4h] [bp-14h]@1

  v3 = a1;
  v6 = 0;
  v7 = 0;
  if ( &v6 != (int *)a3 )
  {
    v7 = *(_DWORD *)(a3 + 4);
    *(_DWORD *)(a3 + 4) = 0;
    v4 = v6;
    v6 = *(_DWORD *)a3;
    *(_DWORD *)a3 = v4;
  }
  return sub_10008470((int)&v6, (int *)(v3 + 4), a2, v6, v7);
}

//----- (10009200) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10009200())(char)
{
  return &off_10074940;
}
// 10074940: using guessed type int (__stdcall **off_10074940)(char);

//----- (10009210) --------------------------------------------------------
void *__thiscall sub_10009210(int this, char a2)
{
  int v2; // edi@1
  void *v3; // esi@1

  v3 = (void *)this;
  *(_DWORD *)this = &off_10066FE0;
  v2 = *(_DWORD *)(this + 8);
  if ( v2 )
  {
    _EBX = -1;
    _EDX = v2 + 4;
    _EAX = -1;
    __asm { lock xadd [edx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v2)(v2);
      _EAX = v2 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 4))(v2);
    }
  }
  *(_DWORD *)v3 = off_10067080;
  if ( a2 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10066FE0: using guessed type void *off_10066FE0;
// 10067080: using guessed type int (*off_10067080[5])();

//----- (10009270) --------------------------------------------------------
int __thiscall sub_10009270(int this, char a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_100670D8;
  if ( *(_DWORD *)(this + 24) >= 0x10u )
    sub_1002A4AA(*(LPVOID *)(this + 4));
  *(_DWORD *)(v2 + 24) = 15;
  *(_DWORD *)(v2 + 20) = 0;
  *(_BYTE *)(v2 + 4) = 0;
  *(_DWORD *)v2 = &off_1006737C;
  if ( a2 & 1 )
    sub_1002A4AA((LPVOID)v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100670D8: using guessed type int (__stdcall *off_100670D8)(char);
// 1006737C: using guessed type int (__stdcall *off_1006737C)(char);

//----- (10009300) --------------------------------------------------------
int __usercall sub_10009300<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4)
{
  int v4; // eax@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // esi@3
  int v9; // [sp+20h] [bp-10h]@1

  v9 = a1;
  v5 = a2;
  v4 = sub_1002ADB1(a1, a2, a2, a3, 28);
  v6 = v4;
  if ( v4 )
  {
    *(_DWORD *)(v4 + 4) = 1;
    *(_DWORD *)(v4 + 8) = 1;
    *(_DWORD *)v4 = &off_100671D0;
    if ( v4 != -12 )
    {
      v7 = *(_DWORD *)a4;
      *(_DWORD *)(v4 + 12) = 0;
      sub_1002FD39(v4 + 16, v9);
      *(_DWORD *)(v6 + 24) = v7;
    }
  }
  else
  {
    v6 = 0;
  }
  *(_DWORD *)v5 = v6 + 12;
  *(_DWORD *)(v5 + 4) = v6;
  return v5;
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);
// 100671D0: using guessed type int (*off_100671D0)();

//----- (100093C0) --------------------------------------------------------
void *__thiscall sub_100093C0(void *this, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  void *v4; // esi@1
  int v5; // edi@3
  void *result; // eax@7
  char v21; // [sp+8h] [bp-8h]@1

  v2 = 0;
  v4 = this;
  v3 = 0;
  if ( &v21 != (char *)a2 )
  {
    v2 = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a2 + 4) = 0;
    v3 = *(_DWORD *)a2;
    *(_DWORD *)a2 = 0;
  }
  v5 = *((_DWORD *)v4 + 1);
  *((_DWORD *)v4 + 1) = v2;
  *(_DWORD *)v4 = v3;
  if ( v5 )
  {
    _EBX = -1;
    _ECX = v5 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      _EAX = v5 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
    }
    result = v4;
  }
  else
  {
    result = v4;
  }
  return result;
}

//----- (10009430) --------------------------------------------------------
void __thiscall sub_10009430(void *this, int a2)
{
  int v2; // eax@1
  signed int v3; // ebx@1
  int ebp0; // ebp@0
  void *v5; // esi@1
  int v6; // ebx@7
  int v7; // ebx@8
  int v8; // ebx@10
  int v9; // eax@10
  int v24; // ebx@15
  int v25; // eax@15
  int v40; // edi@20
  int *v41; // eax@20
  char v56; // [sp+10h] [bp-48h]@10
  int v57; // [sp+14h] [bp-44h]@10
  char v58; // [sp+18h] [bp-40h]@20
  int v59; // [sp+1Ch] [bp-3Ch]@20
  char v60; // [sp+20h] [bp-38h]@15
  int v61; // [sp+24h] [bp-34h]@15
  unsigned int v62; // [sp+44h] [bp-14h]@1
  int v63; // [sp+54h] [bp-4h]@10
  int v64; // [sp+58h] [bp+0h]@1

  v62 = (unsigned int)&v64 ^ __security_cookie;
  v5 = this;
  v3 = 0;
  sub_1002B62D(ebp0, (int)((char *)this + 100));
  v2 = *((_DWORD *)v5 + 21);
  if ( v2 != 3 )
  {
    if ( v2 != 4 )
    {
      *(_DWORD *)(a2 + 20) = *((_DWORD *)v5 + 33);
      *((_DWORD *)v5 + 33) = a2;
      goto LABEL_7;
    }
    if ( !*(_BYTE *)(a2 + 25) )
    {
      v3 = 2;
      goto LABEL_7;
    }
  }
  v3 = 1;
LABEL_7:
  sub_1002B6D6();
  v6 = v3 - 1;
  if ( v6 )
  {
    v7 = v6 - 1;
    if ( v7 )
    {
      if ( v7 == 1 )
      {
        v9 = (*(int (__thiscall **)(int, char *))(*(_DWORD *)a2 + 4))(a2, &v56);
        v63 = 4;
        (*(void (__stdcall **)(signed int, signed int, signed int, char *))(**(_DWORD **)v9 + 4))(
          1,
          1,
          1,
          (char *)v5 + 92);
        v63 = -1;
        v8 = v57;
        if ( v57 )
        {
          _ESI = -1;
          _ECX = v57 + 4;
          _EAX = -1;
          __asm { lock xadd [ecx], eax }
          if ( _ZF )
          {
            (**(void (__thiscall ***)(_DWORD))v8)(v8);
            _EAX = v8 + 8;
            __asm { lock xadd [eax], esi }
            if ( _ESI == 1 )
              (*(void (__thiscall **)(int))(*(_DWORD *)v8 + 4))(v8);
          }
        }
        (**(void (__thiscall ***)(_DWORD, _DWORD))a2)(a2, 1);
      }
    }
    else
    {
      v25 = (*(int (__thiscall **)(int, char *))(*(_DWORD *)a2 + 4))(a2, &v60);
      v63 = 3;
      (*(void (__stdcall **)(signed int, _DWORD, _DWORD, int))(**(_DWORD **)v25 + 4))(1, 0, 0, *(_DWORD *)v25 + 92);
      v63 = -1;
      v24 = v61;
      if ( v61 )
      {
        _ESI = -1;
        _ECX = v61 + 4;
        _EAX = -1;
        __asm { lock xadd [ecx], eax }
        if ( _ZF )
        {
          (**(void (__thiscall ***)(_DWORD))v24)(v24);
          _EAX = v24 + 8;
          __asm { lock xadd [eax], esi }
          if ( _ESI == 1 )
            (*(void (__thiscall **)(int))(*(_DWORD *)v24 + 4))(v24);
        }
      }
      (**(void (__thiscall ***)(_DWORD, _DWORD))a2)(a2, 1);
    }
  }
  else
  {
    v41 = (int *)(*(int (__thiscall **)(_DWORD, char *))(*(_DWORD *)a2 + 4))(a2, &v58);
    v63 = 0;
    sub_1000A5C0(*v41, 0, a2, a2, *(_DWORD *)(a2 + 28));
    v63 = -1;
    v40 = v59;
    if ( v59 )
    {
      _ESI = -1;
      _ECX = v59 + 4;
      _EAX = -1;
      __asm { lock xadd [ecx], eax }
      if ( _ZF )
      {
        (**(void (__thiscall ***)(_DWORD))v40)(v40);
        _EAX = v40 + 8;
        __asm { lock xadd [eax], esi }
        if ( _ESI == 1 )
          (*(void (**)(void))(*(_DWORD *)v40 + 4))();
      }
    }
  }
}
// 10073200: using guessed type int __security_cookie;

//----- (100095F0) --------------------------------------------------------
int __thiscall sub_100095F0(int this)
{
  return (**(int (__thiscall ***)(_DWORD, _DWORD))(this + 12))(this + 12, 0);
}

//----- (10009600) --------------------------------------------------------
void *__thiscall sub_10009600(void *this, int a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10067204;
  sub_1002C08B((int)((char *)this + 4));
  sub_1002C08B((int)((char *)v2 + 44));
  *((_DWORD *)v2 + 21) = 0;
  *((_WORD *)v2 + 44) = 0;
  *((_BYTE *)v2 + 90) = 0;
  *((_DWORD *)v2 + 23) = 0;
  *((_DWORD *)v2 + 24) = 0;
  sub_1002B5CC((int)((char *)v2 + 100));
  *((_DWORD *)v2 + 33) = 0;
  *((_DWORD *)v2 + 35) = 0;
  *((_DWORD *)v2 + 36) = 0;
  *((_DWORD *)v2 + 37) = 0;
  *((_DWORD *)v2 + 34) = a2;
  if ( a2 != 2 )
  {
    _EAX = a2 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  return v2;
}
// 10067204: using guessed type int (__stdcall *off_10067204)(char);

//----- (100096D0) --------------------------------------------------------
int __usercall sub_100096D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v3; // eax@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ebx@2
  int *v8; // [sp+20h] [bp-10h]@1

  v8 = (int *)a1;
  v4 = a2;
  v3 = sub_1002ADB1(a1, a2, a3, a2, 168);
  v5 = v3;
  if ( v3 )
  {
    *(_DWORD *)(v3 + 4) = 1;
    *(_DWORD *)(v3 + 8) = 1;
    v6 = v3 + 12;
    *(_DWORD *)v3 = &off_100670FC;
    if ( v3 != -12 )
    {
      sub_10009600((void *)(v3 + 12), *v8);
      *(_DWORD *)v6 = &off_100671FC;
    }
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)v4 = v5 + 12;
  *(_DWORD *)(v4 + 4) = v5;
  return v4;
}
// 100670FC: using guessed type int (*off_100670FC)();
// 100671FC: using guessed type int (__stdcall *off_100671FC)(char);

//----- (10009780) --------------------------------------------------------
int __usercall sub_10009780<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v4; // esi@1
  int v5; // [sp+8h] [bp-8h]@1
  unsigned int v6; // [sp+Ch] [bp-4h]@1
  int v7; // [sp+10h] [bp+0h]@1

  v6 = (unsigned int)&v7 ^ __security_cookie;
  v5 = a1;
  v4 = a2;
  sub_100096D0((int)&v5, a2, a3);
  return v4;
}
// 10073200: using guessed type int __security_cookie;

//----- (100097C0) --------------------------------------------------------
char __cdecl sub_100097C0(int a1)
{
  return a1 && a1 != 2;
}

//----- (100097E0) --------------------------------------------------------
int __cdecl sub_100097E0(int a1)
{
  return (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD, int))(*(_DWORD *)a1 + 4))(0, 0, 0, a1 + 92);
}

//----- (10009800) --------------------------------------------------------
int __thiscall sub_10009800(int this, int a2)
{
  int result; // eax@1
  int v4; // ecx@1
  int v5; // ebx@1
  int v7; // esi@3
  int v19; // esi@7
  int v31; // esi@12
  char v32; // [sp+10h] [bp-14h]@1
  char v33; // [sp+18h] [bp-Ch]@1
  int v34; // [sp+1Ch] [bp-8h]@7

  v5 = this;
  result = sub_10009780(a2, (int)&v33, this);
  v4 = 0;
  _EDX = 0;
  if ( &v32 != (char *)result )
  {
    _EDX = *(_DWORD *)(result + 4);
    *(_DWORD *)(result + 4) = 0;
    v4 = *(_DWORD *)result;
    *(_DWORD *)result = 0;
  }
  v7 = *(_DWORD *)(v5 + 4);
  _EDI = -1;
  *(_DWORD *)(v5 + 4) = _EDX;
  *(_DWORD *)v5 = v4;
  if ( v7 )
  {
    result = v7 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v7)(v7);
      result = v7 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v7 + 4))(v7, _EDX);
    }
  }
  v19 = v34;
  if ( v34 )
  {
    result = v34 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v19)(v19);
      result = v19 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v19 + 4))(v19);
    }
  }
  if ( a2 != 2 )
  {
    v31 = *(_DWORD *)v5;
    result = sub_1002B396(_EDX, *(_DWORD *)(*(_DWORD *)v5 + 136), v5, (int)sub_100097E0, *(_DWORD *)v5, 1);
    *(_DWORD *)(v31 + 140) = result;
  }
  return result;
}

//----- (100098C0) --------------------------------------------------------
int __thiscall sub_100098C0(void *this, int a2)
{
  int v2; // esi@1
  int v4; // [sp+14h] [bp-1Ch]@1
  int v5; // [sp+18h] [bp-18h]@1
  unsigned int v6; // [sp+1Ch] [bp-14h]@1
  int v7; // [sp+2Ch] [bp-4h]@1
  int v8; // [sp+30h] [bp+0h]@1

  v6 = (unsigned int)&v8 ^ __security_cookie;
  v2 = (int)this;
  v4 = 0;
  v5 = 0;
  sub_1002FD89((int)&v4);
  v7 = 0;
  if ( a2 )
  {
    sub_1002FD59(&v4);
    sub_1002FD39(v2, (int)&v4);
    v7 = -1;
    sub_1002FDDA((int)&v4);
  }
  else
  {
    sub_1002FD39(v2, (int)&v4);
    v7 = -1;
    sub_1002FDDA((int)&v4);
  }
  return v2;
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);
// 10073200: using guessed type int __security_cookie;

//----- (10009980) --------------------------------------------------------
int __userpurge sub_10009980<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_1005F310;
  return v4;
}
// 1005F310: using guessed type int (__stdcall *off_1005F310)(char);

//----- (100099A0) --------------------------------------------------------
int __thiscall sub_100099A0(void *this)
{
  int v1; // ecx@1
  void *v2; // esi@1
  int result; // eax@2

  v2 = this;
  v1 = *(_DWORD *)this;
  if ( v1 )
  {
    result = v1 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      result = (*(int (**)(void))(*(_DWORD *)v1 + 4))();
  }
  *(_DWORD *)v2 = 0;
  return result;
}

//----- (100099D0) --------------------------------------------------------
void *__thiscall sub_100099D0(void *this)
{
  *(_DWORD *)this = 0;
  return this;
}

//----- (100099E0) --------------------------------------------------------
int __fastcall sub_100099E0(int a1, int a2, unsigned int a3)
{
  int v3; // esi@2
  char v4; // cf@4
  unsigned __int8 v5; // cf@6
  unsigned __int8 v6; // al@8
  unsigned __int8 v7; // al@10
  unsigned __int8 v8; // al@12

  if ( !a3 )
    return 0;
  v3 = a3 - 4;
  if ( a3 < 4 )
  {
LABEL_5:
    if ( v3 == -4 )
      return 0;
  }
  else
  {
    while ( *(_DWORD *)a1 == *(_DWORD *)a2 )
    {
      a1 += 4;
      a2 += 4;
      v4 = (unsigned int)v3 < 4;
      v3 -= 4;
      if ( v4 )
        goto LABEL_5;
    }
  }
  v5 = *(_BYTE *)a1 < *(_BYTE *)a2;
  if ( *(_BYTE *)a1 != *(_BYTE *)a2
    || v3 != -3
    && ((v6 = *(_BYTE *)(a1 + 1), v5 = v6 < *(_BYTE *)(a2 + 1), v6 != *(_BYTE *)(a2 + 1))
     || v3 != -2
     && ((v7 = *(_BYTE *)(a1 + 2), v5 = v7 < *(_BYTE *)(a2 + 2), v7 != *(_BYTE *)(a2 + 2))
      || v3 != -1 && (v8 = *(_BYTE *)(a1 + 3), v5 = v8 < *(_BYTE *)(a2 + 3), v8 != *(_BYTE *)(a2 + 3)))) )
    return -v5 | 1;
  return 0;
}

//----- (10009A40) --------------------------------------------------------
int __userpurge sub_10009A40<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10060D74;
  return v4;
}
// 10060D74: using guessed type int (__stdcall *off_10060D74)(char);

//----- (10009A60) --------------------------------------------------------
int __userpurge sub_10009A60<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_1005F2E0;
  return v4;
}
// 1005F2E0: using guessed type int (__stdcall *off_1005F2E0)(char);

//----- (10009B30) --------------------------------------------------------
int __userpurge sub_10009B30<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, unsigned int a4)
{
  int v4; // ecx@1

  v4 = 0;
  if ( a4 )
  {
    if ( a4 > 0x7FFFFFFF || (v4 = sub_1002ADB1(a1, 0, a2, a3, 2 * a4), !v4) )
    {
      sub_10029530();
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_10009B60);
    }
  }
  return v4;
}

//----- (10009B60) --------------------------------------------------------
int (__cdecl *__usercall sub_10009B60<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<ebx>, int a5<edi>, int a6<esi>, int a7, int a8))(int, int)
{
  unsigned int v8; // edi@1
  int v9; // esi@1
  unsigned int v10; // ecx@3
  int v11; // eax@6
  int v12; // ecx@6
  int (__cdecl *result)(int, int); // eax@9
  int v14; // edx@9
  const void *v15; // edx@12
  int v16; // eax@18
  int v17; // [sp-10h] [bp-28h]@1
  int v18; // [sp-Ch] [bp-24h]@1
  int v19; // [sp-8h] [bp-20h]@1
  int v20; // [sp-4h] [bp-1Ch]@1
  int v21; // [sp+0h] [bp-18h]@1
  int v22; // [sp+4h] [bp-14h]@6
  void **v23; // [sp+8h] [bp-10h]@1
  int v24; // [sp+Ch] [bp-Ch]@1
  int (__cdecl *v25)(int, int); // [sp+10h] [bp-8h]@1
  int v26; // [sp+14h] [bp-4h]@1
  void *v27; // [sp+1Ch] [bp+4h]@9

  v26 = -1;
  v25 = sub_1005AE20;
  v24 = a1;
  v20 = a4;
  v19 = a6;
  v18 = a5;
  v17 = a1;
  v23 = (void **)&v17;
  v9 = a3;
  v21 = a3;
  v8 = a7 | 7;
  if ( (a7 | 7u) <= 0x7FFFFFFE )
  {
    a4 = *(_DWORD *)(a3 + 20);
    v10 = *(_DWORD *)(a3 + 20) >> 1;
    a2 = v8 / 3;
    if ( v10 > v8 / 3 )
    {
      v8 = v10 + a4;
      if ( a4 > 2147483646 - v10 )
        v8 = 2147483646;
    }
  }
  else
  {
    v8 = a7;
  }
  v11 = v8 + 1;
  v12 = 0;
  v26 = 0;
  v22 = 0;
  if ( v8 == -1 || (unsigned int)v11 <= 0x7FFFFFFF && (v12 = sub_1002ADB1(a2, 0, a4, v8, 2 * v11), v22 = v12, v12) )
  {
    if ( a8 )
    {
      if ( *(_DWORD *)(v9 + 20) < 8u )
        v15 = (const void *)v9;
      else
        v15 = *(const void **)v9;
      if ( a8 )
        sub_10034EE0((void *)v12, v15, 2 * a8);
    }
    if ( *(_DWORD *)(v9 + 20) >= 8u )
      sub_1002A4AA(*(LPVOID *)v9);
    v16 = v22;
    *(_DWORD *)v9 = v22;
    *(_DWORD *)(v9 + 20) = v8;
    *(_DWORD *)(v9 + 16) = a8;
    if ( v8 >= 8 )
      v9 = v16;
    result = 0;
    *(_WORD *)(v9 + 2 * a8) = 0;
  }
  else
  {
    sub_10029530();
    v22 = a7;
    v23 = &v27;
    LOBYTE(v26) = 2;
    sub_10009B30(v14, a4, v8, a7 + 1);
    result = loc_10009C1E;
  }
  return result;
}
// 10009C1E: using guessed type int __cdecl loc_10009C1E(int, int);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1005AE20: using guessed type int __cdecl sub_1005AE20(int, int);

//----- (10009E10) --------------------------------------------------------
int __userpurge sub_10009E10<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_100606BC;
  return v4;
}
// 100606BC: using guessed type int (__stdcall *off_100606BC)(char);

//----- (10009E30) --------------------------------------------------------
int __usercall sub_10009E30<eax>(const void *a1<ecx>, int a2<edi>, char a3)
{
  sub_1002FDE9(a1, a2, (const void **)&a3);
  return sub_1002FDDA((int)&a3);
}

//----- (10009E90) --------------------------------------------------------
int __usercall sub_10009E90<eax>(int a1<ecx>, int a2<edi>)
{
  const void *v3; // ecx@3
  char v4; // [sp+4h] [bp-18h]@3
  int v5; // [sp+18h] [bp-4h]@3

  if ( !*(_DWORD *)a1 )
    *(_DWORD *)a1 = 1;
  sub_1002FD39((int)&v4, a1 + 4);
  v5 = 0;
  sub_1002FDE9(v3, a2, (const void **)&v4);
  v5 = -1;
  return sub_1002FDDA((int)&v4);
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);

//----- (10009F10) --------------------------------------------------------
signed int __usercall sub_10009F10<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // ebx@1
  int ebp0; // ebp@0
  int v4; // edi@1
  char *v5; // esi@3
  int v6; // ecx@5
  signed int result; // eax@7
  char v8; // [sp+0h] [bp-30h]@1
  char *v9; // [sp+18h] [bp-18h]@3
  int v10; // [sp+1Ch] [bp-14h]@1
  char *v11; // [sp+20h] [bp-10h]@1
  int v12; // [sp+2Ch] [bp-4h]@3

  v11 = &v8;
  v4 = a1;
  v10 = a1;
  sub_1002C6B2(ebp0, a2, a1, -1);
  v2 = *(_DWORD *)(v4 + 144);
  if ( !v2
    || *(_BYTE *)(v4 + 88)
    || (v12 = 0,
        v5 = sub_1002F41A(v2, ebp0, v4),
        v9 = v5,
        ++*(_DWORD *)v5,
        LOBYTE(v12) = 1,
        sub_1002DB66(v2, ebp0, v4, v2 + 8, 0),
        --*(_DWORD *)v5,
        v12 = -1,
        *(_BYTE *)(v4 + 90)) )
    sub_1002C6B2(ebp0, v2, v4, -1);
  v6 = *(_DWORD *)(v4 + 92);
  if ( v6 )
  {
    sub_10009E90(v6, v4);
  }
  else
  {
    result = 2;
    if ( *(_DWORD *)(v4 + 84) == 4 )
      return result;
  }
  return 1;
}

//----- (1000A010) --------------------------------------------------------
void *__thiscall sub_1000A010(void *this, int a2)
{
  void *v2; // esi@1
  int v3; // edx@2
  int v4; // ecx@2
  int v5; // edi@4
  void *result; // eax@8
  char v21; // [sp+4h] [bp-8h]@2

  v2 = this;
  if ( this == (void *)a2 )
  {
    result = this;
  }
  else
  {
    v4 = 0;
    v3 = 0;
    if ( &v21 != (char *)a2 )
    {
      v3 = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a2 + 4) = 0;
      v4 = *(_DWORD *)a2;
      *(_DWORD *)a2 = 0;
    }
    v5 = *((_DWORD *)v2 + 1);
    *((_DWORD *)v2 + 1) = v3;
    *(_DWORD *)v2 = v4;
    if ( v5 )
    {
      _EBX = -1;
      _ECX = v5 + 4;
      _EAX = -1;
      __asm { lock xadd [ecx], eax }
      if ( _ZF )
      {
        (**(void (__thiscall ***)(_DWORD))v5)(v5);
        _EAX = v5 + 8;
        __asm { lock xadd [eax], ebx }
        if ( _EBX == 1 )
          (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
      }
      result = v2;
    }
    else
    {
      result = v2;
    }
  }
  return result;
}

//----- (1000A090) --------------------------------------------------------
int __thiscall sub_1000A090(int this, char a2)
{
  int v2; // eax@1
  int ebp0; // ebp@0
  int v4; // esi@1
  int v5; // ecx@2

  v4 = this;
  *(_DWORD *)this = &off_100671FC;
  v2 = *(_DWORD *)(this + 140);
  if ( v2 )
  {
    sub_1002B29A(ebp0, v2);
    v5 = *(_DWORD *)(v4 + 140);
    _EDX = -1;
    _EAX = v5 + 4;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v5 + 4))();
    *(_DWORD *)(v4 + 140) = 0;
  }
  sub_1000A960(v4);
  if ( a2 & 1 )
    sub_1002A4AA((LPVOID)v4);
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100671FC: using guessed type int (__stdcall *off_100671FC)(char);

//----- (1000A140) --------------------------------------------------------
void *__thiscall sub_1000A140(void *this, int a2)
{
  int v2; // edi@1
  void *v3; // esi@1
  int v4; // eax@1
  int v5; // edx@1
  int v6; // edx@1
  char v22; // [sp+10h] [bp-Ch]@1
  int v23; // [sp+14h] [bp-8h]@1

  v3 = this;
  v4 = sub_10004DE0((int)&v22, a2);
  v5 = *(_DWORD *)(v4 + 4);
  *(_DWORD *)(v4 + 4) = *((_DWORD *)v3 + 1);
  *((_DWORD *)v3 + 1) = v5;
  v6 = *(_DWORD *)v4;
  *(_DWORD *)v4 = *(_DWORD *)v3;
  v2 = v23;
  *(_DWORD *)v3 = v6;
  if ( v2 )
  {
    _EBX = -1;
    _ECX = v2 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v2)(v2);
      _EAX = v2 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 4))(v2);
    }
  }
  return v3;
}

//----- (1000A250) --------------------------------------------------------
int __fastcall sub_1000A250(int a1, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // ebx@1
  int ebp0; // ebp@0
  int v6; // edi@1
  char *v7; // esi@1
  int v8; // ecx@2
  int result; // eax@4
  int v10; // eax@5
  int v11; // ecx@5
  int v12; // edi@5
  int v13; // eax@8

  v6 = a2;
  v4 = a1;
  v7 = sub_1002F41A(a1, ebp0, a2);
  ++*(_DWORD *)v7;
  if ( *(_DWORD *)v7 > (unsigned int)v6 )
  {
    v10 = sub_1002ADB1(v2, v3, v4, v6, 24);
    v12 = v10;
    if ( v10 )
    {
      v11 = *(_DWORD *)(v4 + 16);
      if ( v11 )
      {
        v13 = *(_DWORD *)v11;
        if ( v11 == v4 )
          *(_DWORD *)(v12 + 16) = (*(int (__stdcall **)(int))v13)(v12);
        else
          *(_DWORD *)(v12 + 16) = (*(int (__stdcall **)(_DWORD))v13)(0);
      }
      else
      {
        *(_DWORD *)(v10 + 16) = 0;
      }
    }
    else
    {
      v12 = 0;
    }
    result = sub_1002FEEC(v11, v4, v12, (int)&loc_1000A1F0, v12);
    --*(_DWORD *)v7;
  }
  else
  {
    v8 = *(_DWORD *)(v4 + 16);
    if ( !v8 )
      sub_10029561();
    result = (*(int (**)(void))(*(_DWORD *)v8 + 8))();
    --*(_DWORD *)v7;
  }
  return result;
}

//----- (1000A320) --------------------------------------------------------
int __usercall sub_1000A320<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // esi@1

  v3 = a1;
  if ( !*(_DWORD *)a1 )
    sub_1002DA2E(a2, a3);
  return sub_1002FDDA(v3 + 4);
}

//----- (1000A380) --------------------------------------------------------
int __usercall sub_1000A380<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  return sub_1000A320(a1 + 12, a2, a3);
}

//----- (1000A3A0) --------------------------------------------------------
int __stdcall sub_1000A3A0(int a1)
{
  return 0;
}

//----- (1000A3B0) --------------------------------------------------------
char __userpurge sub_1000A3B0<al>(int a1<ecx>, int a2<edi>, int a3)
{
  char v3; // bl@1
  int v4; // esi@1
  int v5; // esi@1
  int v6; // eax@1
  char v7; // al@1
  char v23; // [sp+10h] [bp-1Ch]@1
  int v24; // [sp+14h] [bp-18h]@1
  int v25; // [sp+18h] [bp-14h]@1
  int v26; // [sp+28h] [bp-4h]@1

  v5 = a1;
  v25 = *(_DWORD *)(a1 + 148);
  v6 = sub_10009300(a3, (int)&v23, a2, (int)&v25);
  v26 = 0;
  v7 = (*(int (__thiscall **)(int, signed int, signed int, _DWORD, int))(*(_DWORD *)v5 + 4))(v5, 1, 1, 0, v6);
  v26 = -1;
  v4 = v24;
  v3 = v7;
  if ( v24 )
  {
    _EDI = -1;
    _EDX = v24 + 4;
    _ECX = -1;
    __asm { lock xadd [edx], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v4)(v4);
      _EAX = v4 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (**)(void))(*(_DWORD *)v4 + 4))();
    }
  }
  return v3;
}

//----- (1000A460) --------------------------------------------------------
int __cdecl sub_1000A460(int a1)
{
  int ebp0; // ebp@0

  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  sub_1002FD89(a1);
  sub_1002FD9C(ebp0);
  return a1;
}

//----- (1000A4E0) --------------------------------------------------------
int __cdecl sub_1000A4E0(int a1)
{
  sub_1000A460(a1);
  return a1;
}

//----- (1000A520) --------------------------------------------------------
int __thiscall sub_1000A520(int this, int a2, int a3)
{
  int ebp0; // ebp@0
  int v4; // edi@1
  int result; // eax@2
  char *v13; // esi@3

  v4 = this;
  _EAX = this + 4;
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  if ( a3 )
  {
    v13 = sub_1002F41A(a3, ebp0, this);
    ++*(_DWORD *)v13;
    if ( *(_DWORD *)v13 > (unsigned int)a3 )
    {
      sub_1002DF26(ebp0, a2);
      result = 0;
    }
    else
    {
      result = sub_1002DB66(a3, ebp0, v4, v4 + 8, a2);
    }
    --*(_DWORD *)v13;
  }
  else
  {
    sub_1002DF26(ebp0, a2);
    result = 0;
  }
  return result;
}

//----- (1000A5C0) --------------------------------------------------------
int __userpurge sub_1000A5C0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4, int a5)
{
  int ebp0; // ebp@0
  int v7; // esi@1
  int v8; // eax@1
  char v9; // [sp+0h] [bp-24h]@1
  int v10; // [sp+10h] [bp-14h]@1
  char *v11; // [sp+14h] [bp-10h]@1
  int v12; // [sp+20h] [bp-4h]@1

  v11 = &v9;
  v7 = a1;
  v10 = a1;
  v8 = sub_1002D91E(a2, ebp0, a3);
  *(_DWORD *)(v7 + 144) = v8;
  v12 = 0;
  sub_1000A520(v8, a4, a5);
  v12 = -1;
  return sub_1002C5B1(ebp0);
}

//----- (1000A642) --------------------------------------------------------
int (__stdcall *__cdecl sub_1000A642())(int, int)
{
  return loc_1000A61C;
}
// 1000A61C: using guessed type int __stdcall loc_1000A61C(int, int);

//----- (1000A650) --------------------------------------------------------
void *__thiscall sub_1000A650(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10060E80;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10060E80: using guessed type int (__stdcall *off_10060E80)(char);

//----- (1000A690) --------------------------------------------------------
int __thiscall sub_1000A690(int this)
{
  int result; // eax@1
  int v2; // ebx@1
  int v3; // esi@1
  int (__thiscall **v4)(_DWORD, _DWORD); // eax@2
  int v5; // edi@2
  int v6; // esi@7
  int v19; // [sp+14h] [bp-1Ch]@1
  int v20; // [sp+18h] [bp-18h]@2
  unsigned int v21; // [sp+1Ch] [bp-14h]@1
  int v22; // [sp+24h] [bp-Ch]@1
  int v23; // [sp+2Ch] [bp-4h]@2

  v21 = (unsigned int)&v19 ^ __security_cookie;
  result = (int)&v22;
  v2 = this;
  v3 = *(_DWORD *)(this + 132);
  *(_DWORD *)(this + 132) = 0;
  if ( v3 )
  {
    do
    {
      v4 = *(int (__thiscall ***)(_DWORD, _DWORD))v3;
      v5 = *(_DWORD *)(v3 + 20);
      v19 = 0;
      v20 = 0;
      ((int (__thiscall **)(int, int *))v4)[1](v3, &v19);
      v23 = 0;
      if ( *(_DWORD *)(v2 + 84) != 4 || *(_BYTE *)(v3 + 25) )
      {
        if ( *(_DWORD *)(v19 + 84) != 4 )
        {
          result = sub_1000A5C0(v19, v2, v5, v3, *(_DWORD *)(v3 + 28));
          goto LABEL_7;
        }
      }
      else
      {
        if ( *(_DWORD *)(v2 + 92) )
          (*(void (__stdcall **)(signed int, signed int, signed int, int))(*(_DWORD *)v19 + 4))(1, 1, 1, v2 + 92);
        else
          (*(void (__stdcall **)(signed int, _DWORD, _DWORD, int))(*(_DWORD *)v19 + 4))(1, 0, 0, v19 + 92);
      }
      result = (**(int (__thiscall ***)(_DWORD, _DWORD))v3)(v3, 1);
LABEL_7:
      v23 = -1;
      v6 = v20;
      if ( v20 )
      {
        _ECX = -1;
        result = v20 + 4;
        __asm { lock xadd [eax], ecx }
        if ( _ZF )
        {
          (**(void (__thiscall ***)(_DWORD))v6)(v6);
          _EDX = -1;
          result = v6 + 8;
          __asm { lock xadd [eax], edx }
          if ( _ZF )
            result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v6 + 4))(v6, _EDX);
        }
      }
      v3 = v5;
    }
    while ( v5 );
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;

//----- (1000A7D0) --------------------------------------------------------
int (__stdcall ***__cdecl sub_1000A7D0())(char)
{
  return &off_10074B58;
}
// 10074B58: using guessed type int (__stdcall **off_10074B58)(char);

//----- (1000A7E0) --------------------------------------------------------
char __thiscall sub_1000A7E0(void *this, char a2, char a3, int a4, int a5)
{
  char v5; // bl@1
  int ebp0; // ebp@0
  int v7; // esi@1
  int v8; // eax@7
  int v10; // ecx@14
  char v11; // [sp+10h] [bp-4Ch]@1
  void **v12; // [sp+14h] [bp-48h]@18
  int v13; // [sp+18h] [bp-44h]@18
  int *v14; // [sp+24h] [bp-38h]@18
  unsigned int v15; // [sp+48h] [bp-14h]@1
  int v16; // [sp+58h] [bp-4h]@1

  v15 = (unsigned int)&v11 ^ __security_cookie;
  v7 = (int)this;
  v5 = 0;
  sub_1002B62D(ebp0, (int)((char *)this + 100));
  v16 = 0;
  if ( !a3 )
  {
    v8 = *(_DWORD *)(v7 + 84);
    if ( v8 != 3 && v8 != 4 )
    {
      if ( v8 != 2 )
        goto LABEL_4;
      if ( a2 )
      {
LABEL_13:
        *(_DWORD *)(v7 + 84) = 4;
        sub_1002C5B1(ebp0);
        v5 = 1;
        goto LABEL_14;
      }
    }
LABEL_11:
    v16 = -1;
    sub_1002B6D6();
    return 0;
  }
  if ( *(_DWORD *)(v7 + 84) == 4 )
    goto LABEL_11;
  sub_1000A140((void *)(v7 + 92), a5);
LABEL_4:
  if ( a2 || !*(_DWORD *)(v7 + 84) )
    goto LABEL_13;
  *(_DWORD *)(v7 + 84) = 2;
LABEL_14:
  v10 = *(_DWORD *)(v7 + 144);
  if ( v10 )
    sub_1002D593(v10 + 8, v5, a5);
  v16 = -1;
  sub_1002B6D6();
  if ( v5 )
  {
    sub_1002C5B1(ebp0);
    if ( *(_DWORD *)(v7 + 132) )
    {
      v12 = &off_100671E0;
      v13 = v7;
      v14 = (int *)&v12;
      v16 = 2;
      sub_1000A250((int)&v12, 16);
      sub_10006050((int)&v12);
    }
  }
  return 1;
}
// 100671E0: using guessed type void *off_100671E0;
// 10073200: using guessed type int __security_cookie;

//----- (1000A930) --------------------------------------------------------
void *__thiscall sub_1000A930(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_1000A960(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1000A960) --------------------------------------------------------
int __thiscall sub_1000A960(int this)
{
  int v1; // ecx@1
  int ebp0; // ebp@0
  int v4; // esi@1
  int v12; // ecx@4
  int v20; // edi@8

  v4 = this;
  *(_DWORD *)this = &off_10067204;
  v1 = *(_DWORD *)(this + 136);
  _EBX = -1;
  if ( v1 != 2 )
  {
    _EAX = v1 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v1 + 4))();
  }
  v12 = *(_DWORD *)(v4 + 144);
  if ( v12 )
  {
    _EAX = v12 + 4;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v12 + 4))();
    *(_DWORD *)(v4 + 144) = 0;
  }
  nullsub_2(v4 + 100);
  v20 = *(_DWORD *)(v4 + 96);
  if ( v20 )
  {
    _EAX = v20 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v20)(v20);
      _EAX = v20 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v20 + 4))(v20);
    }
  }
  sub_1002C0CE(ebp0);
  return sub_1002C0CE(ebp0);
}
// 1002C171: using guessed type int __thiscall nullsub_2(_DWORD);
// 10067204: using guessed type int (__stdcall *off_10067204)(char);

//----- (1000AA50) --------------------------------------------------------
int __thiscall sub_1000AA50(void *this)
{
  int v1; // esi@1

  _EDX = (int)((char *)this + 4);
  _ESI = -1;
  __asm { lock xadd [edx], esi }
  v1 = _ESI - 1;
  if ( !v1 )
    (*(void (**)(void))(*(_DWORD *)this + 4))();
  return v1;
}

//----- (1000AA70) --------------------------------------------------------
int __thiscall sub_1000AA70(void *this)
{
  int result; // eax@1
  void *v3; // esi@1

  v3 = this;
  _EDI = -1;
  _EDX = (int)((char *)this + 4);
  _EAX = -1;
  __asm { lock xadd [edx], eax }
  if ( _ZF )
  {
    (**(void (***)(void))this)();
    result = (int)((char *)v3 + 8);
    __asm { lock xadd [eax], edi }
    if ( _EDI == 1 )
      result = (*(int (__thiscall **)(void *))(*(_DWORD *)v3 + 4))(v3);
  }
  return result;
}

//----- (1000ACA0) --------------------------------------------------------
int (__cdecl *__usercall sub_1000ACA0<eax>(int a1<eax>, int a2<edx>, int a3<ecx>, int a4<ebx>, int a5<edi>, int a6<esi>, int a7, unsigned int a8))(int, int)
{
  unsigned int v8; // edi@1
  int (__cdecl *v9)(int, int); // esi@1
  unsigned int v10; // ecx@3
  int v11; // eax@6
  int v12; // ecx@6
  int (__cdecl *result)(int, int); // eax@9
  unsigned int v14; // ebx@10
  const void *v15; // ecx@12
  int v16; // [sp-10h] [bp-28h]@1
  int v17; // [sp-Ch] [bp-24h]@1
  int v18; // [sp-8h] [bp-20h]@1
  int v19; // [sp-4h] [bp-1Ch]@1
  int v20; // [sp+0h] [bp-18h]@1
  int v21; // [sp+4h] [bp-14h]@6
  void **v22; // [sp+8h] [bp-10h]@1
  int v23; // [sp+Ch] [bp-Ch]@1
  int (__cdecl *v24)(int, int); // [sp+10h] [bp-8h]@1
  int v25; // [sp+14h] [bp-4h]@1
  void *v26; // [sp+1Ch] [bp+4h]@9

  v25 = -1;
  v24 = sub_1005AE00;
  v23 = a1;
  v19 = a4;
  v18 = a6;
  v17 = a5;
  v16 = a1;
  v22 = (void **)&v16;
  v9 = (int (__cdecl *)(int, int))a3;
  v20 = a3;
  v8 = a7 | 0xF;
  if ( (a7 | 0xFu) <= 0xFFFFFFFE )
  {
    a4 = *(_DWORD *)(a3 + 20);
    v10 = *(_DWORD *)(a3 + 20) >> 1;
    a2 = v8 / 3;
    if ( v10 > v8 / 3 )
    {
      v8 = v10 + a4;
      if ( a4 > -2 - v10 )
        v8 = -2;
    }
  }
  else
  {
    v8 = a7;
  }
  v12 = v8 + 1;
  v11 = 0;
  v25 = 0;
  v21 = 0;
  if ( v8 == -1 || (unsigned int)v12 <= 0xFFFFFFFF && (v11 = sub_1002ADB1(a2, v12, a4, v8, v8 + 1), v21 = v11, v11) )
  {
    v14 = a8;
    if ( a8 )
    {
      if ( *((_DWORD *)v9 + 5) < 0x10u )
        v15 = v9;
      else
        v15 = *(const void **)v9;
      if ( a8 )
        sub_10034EE0((void *)v11, v15, a8);
    }
    if ( *((_DWORD *)v9 + 5) >= 0x10u )
      sub_1002A4AA(*(LPVOID *)v9);
    result = (int (__cdecl *)(int, int))v21;
    *(_BYTE *)v9 = 0;
    *(_DWORD *)v9 = result;
    *((_DWORD *)v9 + 5) = v8;
    *((_DWORD *)v9 + 4) = v14;
    if ( v8 >= 0x10 )
      v9 = result;
    *((_BYTE *)v9 + v14) = 0;
  }
  else
  {
    sub_10029530();
    v21 = a7;
    v22 = &v26;
    LOBYTE(v25) = 2;
    loc_1000AC70((char *)&a7 + 3, a7 + 1);
    result = loc_1000AD55;
  }
  return result;
}
// 1000AD55: using guessed type int __cdecl loc_1000AD55(int, int);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1005AE00: using guessed type int __cdecl sub_1005AE00(int, int);

//----- (1000AFB0) --------------------------------------------------------
int __thiscall sub_1000AFB0(int this, const char *a2)
{
  int v2; // esi@1
  int result; // eax@2

  v2 = this;
  *(_DWORD *)(this + 20) = 15;
  *(_DWORD *)(this + 16) = 0;
  *(_BYTE *)this = 0;
  if ( *a2 )
  {
    loc_1000AEB0(this, a2, strlen(a2));
    result = v2;
  }
  else
  {
    loc_1000AEB0(this, a2, 0);
    result = v2;
  }
  return result;
}

//----- (1000B010) --------------------------------------------------------
int __thiscall sub_1000B010(int this, __int16 a2, char a3, void *a4, int a5, int a6, int a7, int a8, unsigned int a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, int a15, int a16)
{
  int v17; // ecx@1
  __int64 v18; // qax@5
  char v19; // cf@5
  signed int v21; // [sp+10h] [bp-10h]@1
  signed int v22; // [sp+10h] [bp-10h]@3

  _ESI = this;
  *(_DWORD *)(this + 16) = a15;
  *(_DWORD *)(this + 20) = a16;
  *(_DWORD *)(this + 8) = 0;
  *(_BYTE *)(this + 12) = a3;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_WORD *)(this + 40) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 52) = 0;
  *(_WORD *)(this + 56) = a2;
  v17 = this + 64;
  *(_DWORD *)_ESI = &off_10067240;
  *(_DWORD *)(v17 + 20) = 15;
  *(_DWORD *)(v17 + 16) = 0;
  *(_BYTE *)v17 = 0;
  loc_1000AB40(&a4, 0, -1);
  __asm
  {
    movq    xmm0, [ebp+arg_20]
    movq    qword ptr [esi+58h], xmm0
    movq    xmm0, [ebp+arg_28]
    movq    qword ptr [esi+60h], xmm0
    movq    xmm0, [ebp+arg_30]
    movq    qword ptr [esi+68h], xmm0
    movq    xmm0, [ebp+arg_38]
    movq    qword ptr [esi+70h], xmm0
    movq    xmm0, [ebp+arg_40]
    movq    qword ptr [esi+78h], xmm0
    movsd   xmm0, ds:qword_10068488
    movsd   qword ptr [esi+80h], xmm0
    movsd   xmm0, ds:qword_10068460
    movsd   qword ptr [esi+88h], xmm0
  }
  *(_DWORD *)(_ESI + 160) = 0;
  *(_DWORD *)(_ESI + 164) = 0;
  *(_DWORD *)(_ESI + 168) = 0;
  *(_DWORD *)(_ESI + 172) = 0;
  *(_DWORD *)(_ESI + 176) = 0;
  *(_DWORD *)(_ESI + 180) = 0;
  *(_DWORD *)(_ESI + 184) = 0;
  *(_DWORD *)(_ESI + 188) = 0;
  *(_DWORD *)(_ESI + 192) = 0;
  *(_DWORD *)(_ESI + 196) = 0;
  *(_DWORD *)(_ESI + 200) = 0;
  *(_DWORD *)(_ESI + 204) = 0;
  *(_DWORD *)(_ESI + 208) = 0;
  *(_DWORD *)(_ESI + 212) = 0;
  *(_DWORD *)(_ESI + 240) = 15;
  *(_DWORD *)(_ESI + 236) = 0;
  *(_BYTE *)(_ESI + 220) = 0;
  *(_DWORD *)(_ESI + 248) = 60;
  *(_DWORD *)(_ESI + 272) = 15;
  *(_DWORD *)(_ESI + 268) = 0;
  *(_BYTE *)(_ESI + 252) = 0;
  *(_DWORD *)(_ESI + 276) = 0;
  *(_DWORD *)(_ESI + 280) = 0;
  *(_DWORD *)(_ESI + 284) = 0;
  *(_DWORD *)(_ESI + 288) = 0;
  *(_DWORD *)(_ESI + 296) = 0;
  *(_DWORD *)(_ESI + 300) = 0;
  *(_DWORD *)(_ESI + 304) = 0;
  *(_DWORD *)(_ESI + 308) = 0;
  v21 = 8760;
  if ( !a3 )
    v21 = 3;
  *(_QWORD *)(_ESI + 296) = sub_10039A20(v21, 36000000000i64);
  v22 = 14400;
  if ( !a3 )
    v22 = 10;
  v18 = sub_10039A20(v22, 600000000i64);
  v19 = a9 < 0x10;
  *(_QWORD *)(_ESI + 304) = v18;
  if ( !v19 )
    sub_1002A4AA(a4);
  return _ESI;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067240: using guessed type int (__stdcall *off_10067240)(char);

//----- (1000B2B0) --------------------------------------------------------
void *__thiscall sub_1000B2B0(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_1000B2E0(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1000B2E0) --------------------------------------------------------
int __thiscall sub_1000B2E0(int this)
{
  int result; // eax@1
  int v2; // esi@1
  int v4; // edi@7
  int v17; // edi@11

  v2 = this;
  *(_DWORD *)this = &off_10067240;
  result = *(_DWORD *)(this + 276);
  if ( result )
  {
    result = sub_1002A4AA(*(LPVOID *)(this + 276));
    *(_DWORD *)(v2 + 276) = 0;
    *(_DWORD *)(v2 + 280) = 0;
    *(_DWORD *)(v2 + 284) = 0;
  }
  if ( *(_DWORD *)(v2 + 272) >= 0x10u )
    result = sub_1002A4AA(*(LPVOID *)(v2 + 252));
  *(_DWORD *)(v2 + 272) = 15;
  *(_DWORD *)(v2 + 268) = 0;
  *(_BYTE *)(v2 + 252) = 0;
  if ( *(_DWORD *)(v2 + 240) >= 0x10u )
    result = sub_1002A4AA(*(LPVOID *)(v2 + 220));
  *(_DWORD *)(v2 + 240) = 15;
  *(_DWORD *)(v2 + 236) = 0;
  *(_BYTE *)(v2 + 220) = 0;
  v4 = *(_DWORD *)(v2 + 196);
  _EBX = -1;
  if ( v4 )
  {
    result = v4 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v4)(v4);
      result = v4 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v4 + 4))(v4, _EDX);
    }
  }
  v17 = *(_DWORD *)(v2 + 188);
  if ( v17 )
  {
    result = v17 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v17)(v17);
      result = v17 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v17 + 4))(v17);
    }
  }
  if ( *(_DWORD *)(v2 + 84) >= 0x10u )
    result = sub_1002A4AA(*(LPVOID *)(v2 + 64));
  *(_DWORD *)(v2 + 84) = 15;
  *(_DWORD *)(v2 + 80) = 0;
  *(_BYTE *)(v2 + 64) = 0;
  *(_DWORD *)v2 = off_10067B0C;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067240: using guessed type int (__stdcall *off_10067240)(char);
// 10067B0C: using guessed type int (__stdcall *off_10067B0C[2])(char);

//----- (1000B410) --------------------------------------------------------
char __thiscall sub_1000B410(int this, __int64 a2, __int64 a3, __int64 a4)
{
  char v5; // al@1
  int v6; // eax@5
  int v7; // esi@5
  int v8; // ecx@5
  int v9; // edx@5
  double v10; // st7@5
  __int64 v11; // qax@5
  int v12; // esi@5
  unsigned __int8 v17; // cf@6
  __int64 v19; // qax@7
  int v20; // esi@7
  char v21; // zf@7
  int v22; // ecx@8
  int v23; // eax@9
  int v24; // eax@13
  unsigned int v25; // esi@13
  int v26; // esi@16
  __int64 v27; // qax@19
  int v28; // ecx@19
  unsigned __int8 v29; // cf@19
  int v30; // ecx@19
  int v31; // eax@19
  __int64 v32; // qax@19
  int v33; // eax@23
  int v34; // edx@23
  int v35; // ecx@23
  int v36; // esi@25
  int v51; // esi@29
  int v66; // eax@33
  int v67; // eax@34
  unsigned int v68; // ecx@34
  int v69; // esi@37
  int v70; // ecx@37
  int v71; // ecx@37
  int v85; // eax@41
  int v86; // ecx@42
  int v87; // ecx@45
  int v88; // eax@46
  int v89; // eax@51
  int v90; // eax@54
  char result; // al@57
  int v92; // eax@61
  int v93; // eax@63
  unsigned int v94; // edx@63
  int v95; // eax@66
  char v104; // [sp-2Ch] [bp-98h]@23
  int v105; // [sp-28h] [bp-94h]@23
  int v106; // [sp-24h] [bp-90h]@23
  int v107; // [sp-20h] [bp-8Ch]@23
  signed __int64 v108; // [sp-1Ch] [bp-88h]@23
  int v109; // [sp-14h] [bp-80h]@19
  int v110; // [sp-10h] [bp-7Ch]@19
  unsigned int v111; // [sp-Ch] [bp-78h]@19
  int v112; // [sp-8h] [bp-74h]@19
  unsigned int v113; // [sp-4h] [bp-70h]@1
  char v114; // [sp+Ch] [bp-60h]@23
  void *v115; // [sp+14h] [bp-58h]@59
  int v116; // [sp+24h] [bp-48h]@59
  unsigned int v117; // [sp+28h] [bp-44h]@59
  double v119; // [sp+34h] [bp-38h]@5
  double v120; // [sp+3Ch] [bp-30h]@5
  int v121; // [sp+44h] [bp-28h]@29
  __int64 v122; // [sp+4Ch] [bp-20h]@5
  __int64 v123; // [sp+54h] [bp-18h]@1
  unsigned int v124; // [sp+5Ch] [bp-10h]@1
  int v125; // [sp+68h] [bp-4h]@59
  int v126; // [sp+6Ch] [bp+0h]@1

  v124 = (unsigned int)&v126 ^ __security_cookie;
  v113 = (unsigned int)&v126 ^ __security_cookie;
  __asm
  {
    movsd   [ebp+var_40], xmm3
    movsd   [ebp+var_18], xmm2
  }
  _EDI = this;
  sub_1000C940(this, this, a2);
  __asm { movsd   xmm0, [ebp+var_18] }
  v5 = *(_BYTE *)(_EDI + 12);
  __asm
  {
    movsd   qword ptr [edi+88h], xmm0
    movsd   xmm0, [ebp+var_40]
    movsd   qword ptr [edi+80h], xmm0
    movsd   xmm0, [ebp+arg_8]
    movsd   qword ptr [edi+90h], xmm0
    movsd   xmm0, [ebp+arg_10]
    movsd   qword ptr [edi+98h], xmm0
  }
  if ( v5 || !sub_1000CA40(_EDI + 24) )
    __asm { xorps   xmm0, xmm0 }
  else
    __asm { movsd   xmm0, ds:qword_10068540 }
  __asm { movsd   [ebp+var_18], xmm0 }
  v122 = v123;
  __asm
  {
    movsd   xmm1, [ebp+var_20]
    movaps  xmm0, xmm1
    addsd   xmm0, qword ptr [edi+60h]
    movsd   [ebp+var_18], xmm0
    movsd   xmm0, qword ptr [edi+58h]
    addsd   xmm0, xmm1
    movsd   [ebp+var_30], xmm0
    mulsd   xmm0, ds:qword_10068510
    movsd   [ebp+var_38], xmm0
  }
  v6 = sub_1004D276(v119);
  __asm
  {
    movsd   xmm0, [ebp+var_18]
    mulsd   xmm0, ds:qword_10068510
  }
  v7 = *(_DWORD *)(_EDI + 32);
  v8 = *(_DWORD *)(_EDI + 36);
  __asm { movsd   [ebp+var_38], xmm0 }
  v10 = v119;
  *(_DWORD *)(_EDI + 160) = v6 + v7;
  *(_DWORD *)(_EDI + 164) = v9 + (v6 >= (unsigned int)-v7) + v8;
  LODWORD(v11) = sub_1004D276(v10);
  __asm { movsd   xmm0, [ebp+var_30] }
  v12 = (unsigned __int64)(v11 + *(_QWORD *)(_EDI + 32)) >> 32;
  __asm { comisd  xmm0, [ebp+var_18] }
  *(_DWORD *)(_EDI + 168) = v11 + *(_DWORD *)(_EDI + 32);
  *(_DWORD *)(_EDI + 172) = v12;
  if ( !_CF )
  {
    v17 = *(_DWORD *)(_EDI + 160) >= 0x61C46800u;
    *(_DWORD *)(_EDI + 160) -= 1640261632;
    *(_DWORD *)(_EDI + 164) = v17 + *(_DWORD *)(_EDI + 164) - 9;
  }
  __asm
  {
    movsd   xmm0, qword ptr [edi+68h]
    addsd   xmm0, [ebp+var_20]
    mulsd   xmm0, ds:qword_10068510
    movsd   [ebp+var_30], xmm0
  }
  LODWORD(v19) = sub_1004D276(v120);
  v20 = (unsigned __int64)(v19 + *(_QWORD *)(_EDI + 32)) >> 32;
  _EBX = -1;
  v21 = *(_DWORD *)(_EDI + 192) == 0;
  *(_DWORD *)(_EDI + 176) = v19 + *(_DWORD *)(_EDI + 32);
  *(_DWORD *)(_EDI + 180) = v20;
  if ( v21 )
  {
    v22 = *(_DWORD *)(_EDI + 184);
    if ( !v22 )
      goto LABEL_18;
    v23 = (*(_QWORD *)(v22 + 32) - *(_QWORD *)(_EDI + 304)) >> 32;
    if ( v23 <= *(_DWORD *)(_EDI + 28)
      && (v23 < *(_DWORD *)(_EDI + 28)
       || (unsigned int)(*(_DWORD *)(v22 + 32) - *(_DWORD *)(_EDI + 304)) < *(_DWORD *)(_EDI + 24)) )
    {
      if ( v22 )
      {
        v25 = *(_DWORD *)(_EDI + 24);
        LODWORD(v123) = *(_DWORD *)(v22 + 32);
        v24 = *(_DWORD *)(v22 + 36);
        HIDWORD(v123) = v24;
        if ( v24 > *(_DWORD *)(_EDI + 28) || v24 >= *(_DWORD *)(_EDI + 28) && *(_DWORD *)(v22 + 32) >= v25 )
          v26 = _EDI + 24;
        else
          v26 = _EDI + 24;
        goto LABEL_19;
      }
LABEL_18:
      v26 = _EDI + 24;
LABEL_19:
      v112 = *(_DWORD *)(_EDI + 300);
      v29 = *(_DWORD *)(_EDI + 296) >= (unsigned int)-*(_DWORD *)v26;
      v30 = *(_DWORD *)(_EDI + 296) + *(_DWORD *)v26;
      v31 = *(_DWORD *)(v26 + 4);
      v111 = *(_DWORD *)(_EDI + 296);
      v110 = *(_DWORD *)(_EDI + 300) + v29 + v31;
      v109 = v30;
      LODWORD(v32) = sub_1003AC40(*(unsigned __int64 *)&v109, v111, v112);
      v27 = sub_10039A20(*(_QWORD *)(_EDI + 296), v32);
      _EBX = -1;
      v28 = (unsigned __int64)(v27 - *(_QWORD *)v26) >> 32;
      HIDWORD(v122) = v27 - *(_DWORD *)v26;
      if ( v28 <= *(_DWORD *)(_EDI + 308) )
      {
        if ( v28 < *(_DWORD *)(_EDI + 308) || HIDWORD(v122) < *(_DWORD *)(_EDI + 304) )
          v27 += *(_QWORD *)(_EDI + 296);
      }
      *(_QWORD *)&v111 = v27;
      *(_QWORD *)&v109 = *(_QWORD *)v26;
      v108 = 64424509440i64;
      v104 = 0;
      loc_1000AB40(_EDI + 64, 0, -1);
      v33 = sub_10022BA0(
              *(_DWORD *)(_EDI + 8),
              _EDI,
              (int)((char *)&v120 + 4),
              *(void **)&v104,
              v105,
              v106,
              v107,
              v108,
              HIDWORD(v108),
              *(__int64 *)&v109,
              *(__int64 *)&v111);
      v35 = 0;
      v34 = 0;
      if ( &v114 != (char *)v33 )
      {
        v34 = *(_DWORD *)(v33 + 4);
        *(_DWORD *)(v33 + 4) = 0;
        v35 = *(_DWORD *)v33;
        *(_DWORD *)v33 = 0;
      }
      v36 = *(_DWORD *)(_EDI + 196);
      *(_DWORD *)(_EDI + 196) = v34;
      *(_DWORD *)(_EDI + 192) = v35;
      if ( v36 )
      {
        _EAX = v36 + 4;
        _ECX = -1;
        __asm { lock xadd [eax], ecx }
        if ( _ZF )
        {
          (**(void (__thiscall ***)(_DWORD))v36)(v36);
          _EAX = v36 + 8;
          _EDX = -1;
          __asm { lock xadd [eax], edx }
          if ( _ZF )
            (*(void (__fastcall **)(int, int))(*(_DWORD *)v36 + 4))(v36, _EDX);
        }
      }
      v51 = v121;
      if ( v121 )
      {
        _EAX = v121 + 4;
        _ECX = -1;
        __asm { lock xadd [eax], ecx }
        if ( _ZF )
        {
          (**(void (__thiscall ***)(_DWORD))v51)(v51);
          _EAX = v51 + 8;
          _EDX = -1;
          __asm { lock xadd [eax], edx }
          if ( _ZF )
            (*(void (__fastcall **)(int, int))(*(_DWORD *)v51 + 4))(v51, _EDX);
        }
      }
      goto LABEL_33;
    }
  }
LABEL_33:
  v66 = *(_DWORD *)(_EDI + 192);
  if ( v66 )
  {
    v68 = *(_DWORD *)(v66 + 24);
    v67 = *(_DWORD *)(v66 + 28);
    if ( v67 <= *(_DWORD *)(_EDI + 28) )
    {
      if ( v67 < *(_DWORD *)(_EDI + 28) || v68 < *(_DWORD *)(_EDI + 24) )
      {
        v70 = *(_DWORD *)(_EDI + 188);
        *(_DWORD *)(_EDI + 188) = *(_DWORD *)(_EDI + 196);
        *(_DWORD *)(_EDI + 196) = v70;
        v71 = *(_DWORD *)(_EDI + 184);
        *(_DWORD *)(_EDI + 184) = *(_DWORD *)(_EDI + 192);
        *(_DWORD *)(_EDI + 192) = v71;
        v69 = *(_DWORD *)(_EDI + 196);
        *(_DWORD *)(_EDI + 196) = 0;
        *(_DWORD *)(_EDI + 192) = 0;
        if ( v69 )
        {
          _EAX = v69 + 4;
          _ECX = _EBX;
          __asm { lock xadd [eax], ecx }
          if ( _ZF )
          {
            (**(void (__thiscall ***)(_DWORD))v69)(v69);
            _EAX = v69 + 8;
            __asm { lock xadd [eax], ebx }
            _EBX = _EBX - 1;
            if ( !_EBX )
              (*(void (__thiscall **)(int))(*(_DWORD *)v69 + 4))(v69);
          }
        }
        v85 = *(_DWORD *)(_EDI + 184);
        if ( *(_DWORD *)(v85 + 52) == 1 )
        {
          v86 = *(_DWORD *)(v85 + 56);
          if ( !v86 )
          {
            sub_1002FFB9((int)&v120, (unsigned int)"wait() cannot be called on a default constructed task.");
            sub_100355BB((int)&v120, (int)&unk_1006C878);
          }
          sub_10009F10(v86, _EBX);
        }
      }
    }
  }
  v87 = *(_DWORD *)(_EDI + 184);
  if ( !v87 )
    goto LABEL_77;
  v88 = *(_DWORD *)(_EDI + 212);
  if ( v88 <= *(_DWORD *)(_EDI + 28) )
  {
    if ( v88 < *(_DWORD *)(_EDI + 28) || *(_DWORD *)(_EDI + 208) < *(_DWORD *)(_EDI + 24) )
    {
      *(_QWORD *)&v111 = *(_QWORD *)(_EDI + 24);
      sub_10002040(v87, _EDI + 200, *(__int64 *)&v111);
    }
  }
  if ( (*(_DWORD *)(_EDI + 120) & *(_DWORD *)(_EDI + 216)) == *(_DWORD *)(_EDI + 120)
    && (v89 = *(_DWORD *)(_EDI + 28), v89 >= *(_DWORD *)(_EDI + 204))
    && (v89 > *(_DWORD *)(_EDI + 204) || *(_DWORD *)(_EDI + 24) >= *(_DWORD *)(_EDI + 200))
    && (v90 = *(_DWORD *)(_EDI + 212), v90 >= *(_DWORD *)(_EDI + 28))
    && (v90 > *(_DWORD *)(_EDI + 28) || *(_DWORD *)(_EDI + 208) >= *(_DWORD *)(_EDI + 24)) )
  {
    sub_10018590((void *)(_EDI + 248), _EDI + 220);
    result = 0;
  }
  else
  {
LABEL_77:
    if ( *(_DWORD *)(_EDI + 276) != *(_DWORD *)(_EDI + 280) )
    {
      v117 = 15;
      v116 = 0;
      LOBYTE(v115) = 0;
      loc_1000AEB0(&v115, &unk_1006723C, 0);
      v125 = 0;
      sub_10018590((void *)(_EDI + 248), (int)&v115);
      if ( v117 >= 0x10 )
        sub_1002A4AA(v115);
    }
    v92 = *(_DWORD *)(_EDI + 8);
    if ( !v92 )
      goto LABEL_78;
    if ( !(*(_BYTE *)(v92 + 112) & 4) )
      goto LABEL_78;
    v93 = *(_DWORD *)(_EDI + 164);
    v94 = *(_DWORD *)(_EDI + 24);
    if ( v93 > *(_DWORD *)(_EDI + 28) )
      goto LABEL_78;
    if ( v93 >= *(_DWORD *)(_EDI + 28) && *(_DWORD *)(_EDI + 160) >= v94 )
      goto LABEL_78;
    v95 = *(_DWORD *)(_EDI + 172);
    if ( v95 < *(_DWORD *)(_EDI + 28) )
      goto LABEL_78;
    if ( v95 <= *(_DWORD *)(_EDI + 28) && *(_DWORD *)(_EDI + 168) < v94 )
      goto LABEL_78;
    if ( *(_WORD *)(_EDI + 40) == 5 && !sub_10001780(_EDI + 24, _EDI + 176) )
      goto LABEL_78;
    __asm
    {
      movsd   xmm0, qword ptr [edi+70h]
      xorps   xmm1, xmm1
      comisd  xmm1, xmm0
    }
    if ( !_CF )
      goto LABEL_79;
    __asm
    {
      mulsd   xmm0, [ebp+var_40]
      comisd  xmm0, [ebp+arg_8]
    }
    if ( !(_CF | _ZF) )
LABEL_79:
      result = 1;
    else
LABEL_78:
      result = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (1000B970) --------------------------------------------------------
int __cdecl sub_1000B970(double a1, __int64 a2, __int64 a3)
{
  int result; // eax@1
  int v4; // edx@5
  int v5; // esi@5
  double v6; // [sp+18h] [bp+8h]@5
  signed __int64 v7; // [sp+28h] [bp+18h]@5
  double v8; // [sp+28h] [bp+18h]@5

  result = a3;
  __asm
  {
    movapd  xmm1, xmm2
    movapd  xmm2, xmm0
  }
  if ( *(_QWORD *)&a1 < a3 )
  {
    if ( a3 < a2 )
    {
      result = a3 - LODWORD(a1);
      v4 = a2 - LODWORD(a1);
      v5 = (unsigned __int64)(a2 - *(_QWORD *)&a1) >> 32;
      v6 = (double)(a3 - *(_QWORD *)&a1);
      __asm { movsd   xmm0, [ebp+arg_0] }
      HIDWORD(v7) = v5;
      LODWORD(v7) = v4;
      __asm { subsd   xmm1, xmm2 }
      v8 = (double)v7;
      __asm
      {
        divsd   xmm0, [ebp+arg_10]
        mulsd   xmm0, xmm1
        addsd   xmm0, xmm2
      }
    }
    else
    {
      __asm { movapd  xmm0, xmm1 }
    }
  }
  else
  {
    __asm { movapd  xmm0, xmm2 }
  }
  return result;
}

//----- (1000BA00) --------------------------------------------------------
int __thiscall sub_1000BA00(void *this, int a2, char a3, int a4, int a5)
{
  int v7; // ebx@1
  char v9; // [sp-48h] [bp-58h]@1
  int v10; // [sp-44h] [bp-54h]@1
  int v11; // [sp-40h] [bp-50h]@1
  int v12; // [sp-3Ch] [bp-4Ch]@1
  int v13; // [sp-38h] [bp-48h]@1
  unsigned int v14; // [sp-34h] [bp-44h]@1
  char v15; // [sp-30h] [bp-40h]@1
  __int64 v16; // [sp-28h] [bp-38h]@1
  __int64 v17; // [sp-20h] [bp-30h]@1
  __int64 v18; // [sp-18h] [bp-28h]@1
  __int64 v19; // [sp-10h] [bp-20h]@1
  int v20; // [sp-8h] [bp-18h]@1
  int v21; // [sp-4h] [bp-14h]@1

  _ESI = a2;
  v21 = a5;
  __asm { movq    xmm0, qword ptr [esi+18h] }
  v20 = a4;
  v7 = (int)this;
  _EAX = &v15;
  __asm
  {
    movq    qword ptr [eax], xmm0
    movq    xmm0, qword ptr [esi+20h]
    movq    qword ptr [eax+8], xmm0
    movq    xmm0, qword ptr [esi+28h]
    movq    qword ptr [eax+10h], xmm0
    movq    xmm0, qword ptr [esi+30h]
    movq    qword ptr [eax+18h], xmm0
    movq    xmm0, qword ptr [esi+38h]
  }
  v14 = 15;
  v13 = 0;
  __asm { movq    qword ptr [eax+20h], xmm0 }
  v9 = 0;
  loc_1000AB40(a2, 0, -1);
  sub_1000B010(
    v7,
    word_10074E78,
    a3,
    *(void **)&v9,
    v10,
    v11,
    v12,
    v13,
    v14,
    *(__int64 *)&v15,
    v16,
    v17,
    v18,
    v19,
    v20,
    v21);
  *(_DWORD *)v7 = &off_1006727C;
  memcpy((void *)(v7 + 312), (const void *)(a2 + 64), 0x50u);
  return v7;
}
// 1006727C: using guessed type int (__stdcall *off_1006727C)(char);
// 10074E78: using guessed type __int16 word_10074E78;

//----- (1000BAA0) --------------------------------------------------------
void *__thiscall sub_1000BAA0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_1006727C;
  sub_1000B2E0((int)this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1006727C: using guessed type int (__stdcall *off_1006727C)(char);

//----- (1000BAD0) --------------------------------------------------------
int __fastcall sub_1000BAD0(int a1, char a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9, int a10)
{
  int v10; // edx@1
  char v11; // bl@1
  int v12; // edi@1
  int v13; // ecx@1
  signed int v14; // eax@2
  int v15; // eax@4
  int v16; // ecx@4
  void *v17; // esi@4
  int v18; // esi@5
  char v20; // [sp-1Ch] [bp-D0h]@1
  void *v21; // [sp-18h] [bp-CCh]@1
  int v22; // [sp-14h] [bp-C8h]@1
  int v23; // [sp-10h] [bp-C4h]@1
  int v24; // [sp-Ch] [bp-C0h]@1
  int v25; // [sp-8h] [bp-BCh]@1
  unsigned int v26; // [sp-4h] [bp-B8h]@1
  int v27; // [sp+10h] [bp-A4h]@4
  void *v28; // [sp+14h] [bp-A0h]@1
  int v29; // [sp+24h] [bp-90h]@1
  unsigned int v30; // [sp+28h] [bp-8Ch]@1
  int v31; // [sp+4Ch] [bp-68h]@2
  unsigned int v32; // [sp+A4h] [bp-10h]@1
  int v33; // [sp+B0h] [bp-4h]@1
  int v34; // [sp+B4h] [bp+0h]@1

  v32 = (unsigned int)&v34 ^ __security_cookie;
  v26 = (unsigned int)&v34 ^ __security_cookie;
  v11 = a2;
  v12 = a1;
  v33 = 0;
  v30 = 15;
  v29 = 0;
  LOBYTE(v28) = 0;
  LOBYTE(v33) = 1;
  v25 = 15;
  v24 = 0;
  v20 = 0;
  loc_1000AB40(&a3, 0, -1, *(_DWORD *)&v20);
  if ( !sub_1000C2A0(v13, (int)&v28, v21, v22, v23, v24, v25, v26) )
    goto LABEL_14;
  v14 = v31;
  if ( !v11 )
    v14 = 15;
  v31 = v14;
  v15 = sub_1002ADB1(v10, 15, v11, v12, 456);
  v17 = (void *)v15;
  v27 = v15;
  LOBYTE(v33) = 2;
  if ( v15 )
  {
    sub_1000BC10(v15, v16);
    v18 = sub_1000BA00(v17, (int)&v28, v12, a9, a10);
  }
  else
  {
LABEL_14:
    v18 = 0;
  }
  if ( v30 >= 0x10 )
    sub_1002A4AA(v28);
  v30 = 15;
  v29 = 0;
  LOBYTE(v28) = 0;
  if ( a8 >= 0x10 )
    sub_1002A4AA(a3);
  return v18;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (1000BC10) --------------------------------------------------------
void __thiscall sub_1000BC10(int this, int a2)
{
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 184) = 0;
  *(_DWORD *)(this + 188) = 0;
  *(_DWORD *)(this + 192) = 0;
  *(_DWORD *)(this + 196) = 0;
  *(_DWORD *)(this + 276) = 0;
  *(_DWORD *)(this + 280) = 0;
  *(_DWORD *)(this + 284) = 0;
}

//----- (1000BC60) --------------------------------------------------------
char __thiscall sub_1000BC60(int _ECX)
{
  char result; // al@4
  int v14; // eax@5

  __asm
  {
    movsd   xmm0, ds:qword_10068550
    comisd  xmm0, qword ptr [ecx+1A8h]
    movapd  xmm4, xmm1
  }
  if ( !(_CF | _ZF) )
    goto LABEL_14;
  __asm
  {
    movsd   xmm0, ds:qword_10068558
    comisd  xmm0, qword ptr [ecx+1B0h]
  }
  if ( _CF | _ZF )
    goto LABEL_15;
  __asm { comisd  xmm0, qword ptr [ecx+1B8h] }
  if ( _CF | _ZF )
  {
LABEL_15:
    result = 0;
  }
  else
  {
LABEL_14:
    __asm { movsd   xmm2, qword ptr [ecx+190h] }
    v14 = *(_DWORD *)(_ECX + 8);
    __asm
    {
      movsd   xmm3, ds:qword_10068570
      movapd  xmm1, xmm2
      subsd   xmm1, qword ptr [ecx+188h]
      mulsd   xmm1, ds:qword_10068468
      andpd   xmm1, xmm3
    }
    if ( !v14 )
      goto LABEL_16;
    if ( !(*(_BYTE *)(v14 + 112) & 4) )
      goto LABEL_16;
    __asm
    {
      xorpd   xmm1, ds:xmmword_10068580
      movaps  xmm0, xmm2
      subsd   xmm0, xmm4
      comisd  xmm1, xmm0
    }
    if ( _CF )
      goto LABEL_16;
    __asm
    {
      movsd   xmm0, qword ptr [ecx+140h]
      comisd  xmm0, qword ptr [ecx+1A0h]
    }
    if ( _CF | _ZF )
      goto LABEL_16;
    __asm
    {
      movsd   xmm1, qword ptr [ecx+198h]
      movsd   xmm0, qword ptr [ecx+1C0h]
      subsd   xmm0, xmm1
      subsd   xmm2, xmm1
      andpd   xmm0, xmm3
      comisd  xmm2, xmm0
    }
    if ( _CF | _ZF )
LABEL_16:
      result = 0;
    else
      result = 1;
  }
  return result;
}

//----- (1000BD30) --------------------------------------------------------
char __thiscall sub_1000BD30(int _ECX)
{
  char result; // al@4
  int v14; // eax@5

  __asm
  {
    movsd   xmm0, qword ptr [ecx+1A8h]
    comisd  xmm0, ds:qword_10068548
    movapd  xmm5, xmm1
  }
  if ( !(_CF | _ZF) )
    goto LABEL_14;
  __asm
  {
    movsd   xmm0, qword ptr [ecx+1B0h]
    movsd   xmm2, ds:qword_100684F8
    comisd  xmm0, xmm2
  }
  if ( _CF | _ZF )
    goto LABEL_15;
  __asm
  {
    movsd   xmm0, qword ptr [ecx+1B8h]
    comisd  xmm0, xmm2
  }
  if ( _CF | _ZF )
  {
LABEL_15:
    result = 0;
  }
  else
  {
LABEL_14:
    __asm { movsd   xmm3, qword ptr [ecx+190h] }
    v14 = *(_DWORD *)(_ECX + 8);
    __asm
    {
      movsd   xmm4, ds:qword_10068570
      movapd  xmm1, xmm3
      subsd   xmm1, qword ptr [ecx+188h]
      mulsd   xmm1, ds:qword_10068468
      andpd   xmm1, xmm4
    }
    if ( !v14 )
      goto LABEL_16;
    if ( !(*(_BYTE *)(v14 + 112) & 4) )
      goto LABEL_16;
    __asm
    {
      movaps  xmm0, xmm3
      subsd   xmm0, xmm5
      comisd  xmm0, xmm1
    }
    if ( _CF )
      goto LABEL_16;
    __asm
    {
      movsd   xmm1, ds:qword_100684F0
      subsd   xmm1, qword ptr [ecx+140h]
      movsd   xmm0, qword ptr [ecx+1A0h]
      comisd  xmm0, xmm1
    }
    if ( _CF | _ZF )
      goto LABEL_16;
    __asm
    {
      movsd   xmm1, qword ptr [ecx+198h]
      movsd   xmm0, qword ptr [ecx+1C0h]
      movapd  xmm2, xmm1
      subsd   xmm0, xmm1
      subsd   xmm2, xmm3
      andpd   xmm0, xmm4
      comisd  xmm2, xmm0
    }
    if ( _CF | _ZF )
LABEL_16:
      result = 0;
    else
      result = 1;
  }
  return result;
}

//----- (1000BE10) --------------------------------------------------------
char __thiscall sub_1000BE10(int _ECX)
{
  char result; // al@4
  int v14; // eax@5

  __asm
  {
    movsd   xmm0, qword ptr [ecx+1A8h]
    comisd  xmm0, ds:qword_10068548
  }
  if ( !(_CF | _ZF) )
    goto LABEL_13;
  __asm
  {
    movsd   xmm0, qword ptr [ecx+1B0h]
    movsd   xmm2, ds:qword_100684F8
    comisd  xmm0, xmm2
  }
  if ( _CF | _ZF )
    goto LABEL_14;
  __asm
  {
    movsd   xmm0, qword ptr [ecx+1B8h]
    comisd  xmm0, xmm2
  }
  if ( _CF | _ZF )
  {
LABEL_14:
    result = 0;
  }
  else
  {
LABEL_13:
    v14 = *(_DWORD *)(_ECX + 8);
    if ( !v14 )
      goto LABEL_15;
    if ( !(*(_BYTE *)(v14 + 112) & 4) )
      goto LABEL_15;
    __asm
    {
      movsd   xmm0, qword ptr [ecx+190h]
      subsd   xmm0, xmm1
      comisd  xmm0, ds:qword_10068450
    }
    if ( _CF )
      goto LABEL_15;
    __asm
    {
      movsd   xmm1, ds:qword_100684F0
      subsd   xmm1, qword ptr [ecx+148h]
      movsd   xmm0, qword ptr [ecx+1A0h]
      comisd  xmm0, xmm1
    }
    if ( _CF | _ZF )
LABEL_15:
      result = 0;
    else
      result = 1;
  }
  return result;
}

//----- (1000BEA0) --------------------------------------------------------
char __thiscall sub_1000BEA0(int this, __int64 a2)
{
  unsigned int v5; // ebx@2
  unsigned int v6; // edi@2
  double v8; // ST30_8@2
  __int64 v9; // qax@2
  double v10; // ST30_8@2
  __int64 v11; // qax@2
  double v12; // ST20_8@12
  double v13; // ST30_8@12
  char result; // al@14
  unsigned int v21; // [sp+2Ch] [bp-14h]@2
  unsigned int v22; // [sp+34h] [bp-Ch]@2

  _ESI = this;
  __asm
  {
    movsd   [ebp+var_30], xmm2
    movsd   [ebp+var_28], xmm1
  }
  if ( !*(_BYTE *)(this + 352) )
    goto LABEL_18;
  __asm
  {
    movsd   xmm0, qword ptr [esi+178h]
    mulsd   xmm0, ds:qword_10068560
    movsd   [ebp+var_10], xmm0
  }
  LODWORD(v9) = sub_1004D276(v8);
  __asm
  {
    movsd   xmm0, qword ptr [esi+180h]
    mulsd   xmm0, ds:qword_10068560
  }
  v6 = a2 - v9;
  __asm { movsd   [ebp+var_10], xmm0 }
  v21 = (unsigned __int64)(a2 - v9) >> 32;
  LODWORD(v11) = sub_1004D276(v10);
  v22 = (unsigned __int64)(a2 - v11) >> 32;
  v5 = a2 - v11;
  if ( (signed int)v21 > *(_DWORD *)(_ESI + 52) )
    goto LABEL_18;
  if ( (signed int)v21 >= *(_DWORD *)(_ESI + 52) && v6 >= *(_DWORD *)(_ESI + 48) )
    goto LABEL_18;
  __asm
  {
    movsd   xmm0, qword ptr [esi+80h]
    movsd   xmm1, qword ptr [esi+168h]
    movsd   xmm2, qword ptr [esi+170h]
    mulsd   xmm1, xmm0
    mulsd   xmm2, xmm0
  }
  if ( (signed int)v21 < *(_DWORD *)(_ESI + 52)
    || (signed int)v21 <= *(_DWORD *)(_ESI + 52) && v6 < *(_DWORD *)(_ESI + 48) )
  {
    if ( *(_DWORD *)(_ESI + 52) < (signed int)v22
      || *(_DWORD *)(_ESI + 52) <= (signed int)v22 && *(_DWORD *)(_ESI + 48) < v5 )
    {
      v12 = (double)(signed __int64)(*(_QWORD *)(_ESI + 48) - __PAIR__(v21, v6));
      __asm
      {
        movsd   xmm0, [ebp+var_20]
        subsd   xmm2, xmm1
      }
      v13 = (double)(signed __int64)(__PAIR__(v22, v5) - __PAIR__(v21, v6));
      __asm
      {
        divsd   xmm0, [ebp+var_10]
        mulsd   xmm0, xmm2
        addsd   xmm0, xmm1
        movaps  xmm1, xmm0
      }
    }
    else
    {
      __asm { movaps  xmm1, xmm2 }
    }
  }
  __asm
  {
    movsd   xmm0, [ebp+var_28]
    subsd   xmm0, [ebp+var_30]
    divsd   xmm0, qword ptr [esi+88h]
    comisd  xmm0, xmm1
  }
  if ( _CF )
LABEL_18:
    result = 0;
  else
    result = 1;
  return result;
}

//----- (1000C000) --------------------------------------------------------
char __thiscall sub_1000C000(int this, __int64 a2)
{
  unsigned int v5; // ebx@2
  unsigned int v6; // edi@2
  double v8; // ST30_8@2
  __int64 v9; // qax@2
  double v10; // ST30_8@2
  __int64 v11; // qax@2
  double v12; // ST20_8@12
  double v13; // ST30_8@12
  char result; // al@14
  unsigned int v21; // [sp+2Ch] [bp-14h]@2
  unsigned int v22; // [sp+34h] [bp-Ch]@2

  _ESI = this;
  __asm
  {
    movsd   [ebp+var_28], xmm2
    movsd   [ebp+var_30], xmm1
  }
  if ( !*(_BYTE *)(this + 352) )
    goto LABEL_18;
  __asm
  {
    movsd   xmm0, qword ptr [esi+178h]
    mulsd   xmm0, ds:qword_10068560
    movsd   [ebp+var_10], xmm0
  }
  LODWORD(v9) = sub_1004D276(v8);
  __asm
  {
    movsd   xmm0, qword ptr [esi+180h]
    mulsd   xmm0, ds:qword_10068560
  }
  v6 = a2 - v9;
  __asm { movsd   [ebp+var_10], xmm0 }
  v21 = (unsigned __int64)(a2 - v9) >> 32;
  LODWORD(v11) = sub_1004D276(v10);
  v22 = (unsigned __int64)(a2 - v11) >> 32;
  v5 = a2 - v11;
  if ( (signed int)v21 > *(_DWORD *)(_ESI + 52) )
    goto LABEL_18;
  if ( (signed int)v21 >= *(_DWORD *)(_ESI + 52) && v6 >= *(_DWORD *)(_ESI + 48) )
    goto LABEL_18;
  __asm
  {
    movsd   xmm0, qword ptr [esi+80h]
    movsd   xmm1, qword ptr [esi+168h]
    movsd   xmm2, qword ptr [esi+170h]
    mulsd   xmm1, xmm0
    mulsd   xmm2, xmm0
  }
  if ( (signed int)v21 < *(_DWORD *)(_ESI + 52)
    || (signed int)v21 <= *(_DWORD *)(_ESI + 52) && v6 < *(_DWORD *)(_ESI + 48) )
  {
    if ( *(_DWORD *)(_ESI + 52) < (signed int)v22
      || *(_DWORD *)(_ESI + 52) <= (signed int)v22 && *(_DWORD *)(_ESI + 48) < v5 )
    {
      v12 = (double)(signed __int64)(*(_QWORD *)(_ESI + 48) - __PAIR__(v21, v6));
      __asm
      {
        movsd   xmm0, [ebp+var_20]
        subsd   xmm2, xmm1
      }
      v13 = (double)(signed __int64)(__PAIR__(v22, v5) - __PAIR__(v21, v6));
      __asm
      {
        divsd   xmm0, [ebp+var_10]
        mulsd   xmm0, xmm2
        addsd   xmm0, xmm1
        movaps  xmm1, xmm0
      }
    }
    else
    {
      __asm { movaps  xmm1, xmm2 }
    }
  }
  __asm
  {
    movsd   xmm0, [ebp+var_28]
    subsd   xmm0, [ebp+var_30]
    divsd   xmm0, qword ptr [esi+88h]
    comisd  xmm0, xmm1
  }
  if ( _CF )
LABEL_18:
    result = 0;
  else
    result = 1;
  return result;
}

//----- (1000C160) --------------------------------------------------------
char __thiscall sub_1000C160(int this, __int64 a2, __int64 a3)
{
  int v11; // eax@3
  unsigned int v12; // ebx@3
  unsigned int v13; // edi@3
  __int64 v14; // kr00_8@3
  double v16; // ST40_8@3
  __int64 v17; // qax@3
  double v18; // ST40_8@3
  __int64 v19; // qax@3
  __int64 v20; // ST10_8@4
  __int64 v21; // ST08_8@4
  double v22; // ST00_8@4
  char result; // al@6

  _ESI = this;
  __asm
  {
    movsd   xmm1, qword ptr [esi+158h]
    comisd  xmm1, ds:qword_10068450
    movsd   [ebp+var_28], xmm3
    movsd   [ebp+var_20], xmm2
  }
  if ( _CF )
  {
    result = 0;
  }
  else
  {
    __asm
    {
      movsd   xmm0, qword ptr [esi+80h]
      mulsd   xmm0, xmm1
      movsd   [ebp+var_18], xmm0
    }
    if ( *(_BYTE *)(this + 352) )
    {
      __asm
      {
        movsd   xmm0, qword ptr [esi+178h]
        mulsd   xmm0, ds:qword_10068560
        movsd   [ebp+var_10], xmm0
      }
      LODWORD(v17) = sub_1004D276(v16);
      __asm
      {
        movsd   xmm0, qword ptr [esi+180h]
        mulsd   xmm0, ds:qword_10068560
      }
      v13 = a2 - v17;
      __asm { movsd   [ebp+var_10], xmm0 }
      v12 = (unsigned __int64)(a2 - v17) >> 32;
      LODWORD(v19) = sub_1004D276(v18);
      v14 = a2 - v19;
      v11 = (unsigned __int64)(a2 - v19) >> 32;
      if ( (signed __int64)__PAIR__(v12, v13) >= *(_QWORD *)(_ESI + 48) )
      {
        __asm { movsd   xmm0, [ebp+var_18] }
      }
      else
      {
        __asm { movsd   xmm2, qword ptr [esi+80h] }
        HIDWORD(v20) = *(_DWORD *)(_ESI + 52);
        __asm { movsd   xmm1, qword ptr [esi+170h] }
        LODWORD(v20) = *(_DWORD *)(_ESI + 48);
        __asm
        {
          movsd   xmm0, qword ptr [esi+168h]
          mulsd   xmm1, xmm2
        }
        HIDWORD(v21) = v11;
        LODWORD(v21) = v14;
        __asm { mulsd   xmm0, xmm2 }
        HIDWORD(v22) = v12;
        LODWORD(v22) = v13;
        __asm { movaps  xmm2, xmm1 }
        sub_1000B970(v22, v21, v20);
      }
    }
    __asm
    {
      mulsd   xmm0, [ebp+arg_8]
      movsd   xmm1, [ebp+var_20]
      addsd   xmm1, [ebp+var_28]
      mulsd   xmm0, qword ptr [esi+98h]
      comisd  xmm1, xmm0
    }
    result = !_CF;
  }
  return result;
}

//----- (1000C2A0) --------------------------------------------------------
char __fastcall sub_1000C2A0(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8)
{
  char *v8; // ecx@1
  char *v9; // eax@3
  int v10; // edi@5
  int v11; // esi@5
  int v12; // ebx@8
  int v13; // esi@10
  int v14; // eax@10
  void *v15; // ST00_4@10
  int v16; // ST04_4@10
  int v17; // ST08_4@10
  char v18; // bl@13
  char v20; // [sp-Ch] [bp-48h]@10
  int v21; // [sp-8h] [bp-44h]@10
  unsigned int v22; // [sp-4h] [bp-40h]@10
  int v23; // [sp+0h] [bp-3Ch]@10
  int v24; // [sp+4h] [bp-38h]@10
  signed int v25; // [sp+8h] [bp-34h]@10
  void *v26; // [sp+10h] [bp-2Ch]@10
  int v27; // [sp+20h] [bp-1Ch]@10
  unsigned int v28; // [sp+24h] [bp-18h]@10
  void *v29; // [sp+28h] [bp-14h]@1
  int v30; // [sp+38h] [bp-4h]@1

  v29 = (void *)a2;
  v30 = 0;
  v8 = (char *)&a3;
  if ( a8 >= 0x10 )
    v8 = (char *)a3;
  v9 = (char *)&a3;
  if ( a8 >= 0x10 )
    v9 = (char *)a3;
  v11 = (int)&v8[a7];
  v10 = (int)&a3;
  if ( a8 >= 0x10 )
    v10 = (int)a3;
  if ( v10 != v11 )
  {
    v12 = (int)&v9[-v10];
    do
    {
      *(_BYTE *)(v12 + v10) = sub_10030377(v12, v10, *(_BYTE *)v10);
      ++v10;
    }
    while ( v10 != v11 );
  }
  v28 = 15;
  v27 = 0;
  LOBYTE(v26) = 0;
  loc_1000AB40(&v26, &a3, 0, -1, v23, v24, v25);
  LOBYTE(v30) = 1;
  v25 = 15;
  v24 = 0;
  v20 = 0;
  loc_1000AB40(&v26, 0, -1, *(_DWORD *)&v20);
  v14 = sub_1000C450((int)&unk_10074E80, (int)&dword_10074F10, v15, v16, v17, *(int *)&v20, v21, v22);
  LOBYTE(v30) = 0;
  v13 = v14;
  if ( v28 >= 0x10 )
    sub_1002A4AA(v26);
  v28 = 15;
  v27 = 0;
  LOBYTE(v26) = 0;
  if ( (int *)v13 == &dword_10074F10 )
  {
    v18 = 0;
  }
  else
  {
    sub_1000C3E0(v29, v13);
    v18 = 1;
  }
  if ( a8 >= 0x10 )
    sub_1002A4AA(a3);
  return v18;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074F10: using guessed type int dword_10074F10;

//----- (1000C3E0) --------------------------------------------------------
void *__thiscall sub_1000C3E0(void *this, int a2)
{
  _ESI = a2;
  _EBX = this;
  if ( this != (void *)a2 )
    loc_1000AB40(a2, 0, -1);
  __asm
  {
    movq    xmm0, qword ptr [esi+18h]
    movq    qword ptr [ebx+18h], xmm0
    movq    xmm0, qword ptr [esi+20h]
    movq    qword ptr [ebx+20h], xmm0
    movq    xmm0, qword ptr [esi+28h]
    movq    qword ptr [ebx+28h], xmm0
    movq    xmm0, qword ptr [esi+30h]
    movq    qword ptr [ebx+30h], xmm0
    movq    xmm0, qword ptr [esi+38h]
    movq    qword ptr [ebx+38h], xmm0
  }
  memcpy((char *)_EBX + 64, (const void *)(a2 + 64), 0x50u);
  return _EBX;
}

//----- (1000C450) --------------------------------------------------------
int __fastcall sub_1000C450(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8)
{
  int v8; // edi@1
  int i; // esi@1
  unsigned __int8 *v10; // eax@3

  v8 = a2;
  for ( i = a1; i != v8; i += 144 )
  {
    if ( *(_DWORD *)(i + 20) < 0x10u )
      v10 = (unsigned __int8 *)i;
    else
      v10 = *(unsigned __int8 **)i;
    if ( sub_10002C30((int)&a3, v10, a1, *(_DWORD *)(i + 16)) != -1 )
      break;
  }
  if ( a8 >= 0x10 )
    sub_1002A4AA(a3);
  return i;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1000C4A0) --------------------------------------------------------
void *__thiscall sub_1000C4A0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_1005F33C;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1005F33C: using guessed type int (__stdcall *off_1005F33C)(char);

//----- (1000C4D0) --------------------------------------------------------
int __thiscall sub_1000C4D0(void *this, int a2, int a3)
{
  int result; // eax@1

  result = a2;
  *(_DWORD *)a2 = a3;
  *(_DWORD *)(a2 + 4) = this;
  return result;
}

//----- (1000C4F0) --------------------------------------------------------
char __thiscall sub_1000C4F0(void *this, int a2, int a3)
{
  int v3; // eax@1
  char v5; // [sp+0h] [bp-8h]@1

  v3 = (*(int (__stdcall **)(char *, int))(*(_DWORD *)this + 12))(&v5, a2);
  return *(_DWORD *)(v3 + 4) == *(_DWORD *)(a3 + 4) && *(_DWORD *)v3 == *(_DWORD *)a3;
}

//----- (1000C530) --------------------------------------------------------
char __thiscall sub_1000C530(void *this, int a2, int a3)
{
  return this == *(void **)(a2 + 4) && *(_DWORD *)a2 == a3;
}

//----- (1000C550) --------------------------------------------------------
int __cdecl sub_1000C550()
{
  return (int)"generic";
}

//----- (1000C560) --------------------------------------------------------
int __stdcall sub_1000C560(int a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edx@1
  int result; // eax@4

  v2 = sub_10029607(a2);
  v3 = "unknown error";
  if ( v2 )
    v3 = (const char *)v2;
  *(_DWORD *)(a1 + 20) = 15;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)a1 = 0;
  if ( *v3 )
  {
    loc_1000AEB0(a1, v3, strlen(v3));
    result = a1;
  }
  else
  {
    loc_1000AEB0(a1, v3, 0);
    result = a1;
  }
  return result;
}

//----- (1000C5D0) --------------------------------------------------------
int __cdecl sub_1000C5D0()
{
  return (int)"iostream";
}

//----- (1000C5E0) --------------------------------------------------------
int __stdcall sub_1000C5E0(int a1, int a2)
{
  int result; // eax@2

  if ( a2 == 1 )
  {
    *(_DWORD *)(a1 + 20) = 15;
    *(_DWORD *)(a1 + 16) = 0;
    *(_BYTE *)a1 = 0;
    loc_1000AEB0(a1, "iostream stream error", 21);
    result = a1;
  }
  else
  {
    sub_1000C560(a1, a2);
    result = a1;
  }
  return result;
}

//----- (1000C630) --------------------------------------------------------
int __cdecl sub_1000C630()
{
  return (int)"system";
}

//----- (1000C640) --------------------------------------------------------
int __stdcall sub_1000C640(int a1, int a2)
{
  int v2; // eax@1
  const char *v3; // edx@1
  int result; // eax@4

  v2 = sub_10029631(a2);
  v3 = "unknown error";
  if ( v2 )
    v3 = (const char *)v2;
  *(_DWORD *)(a1 + 20) = 15;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)a1 = 0;
  if ( *v3 )
  {
    loc_1000AEB0(a1, v3, strlen(v3));
    result = a1;
  }
  else
  {
    loc_1000AEB0(a1, v3, 0);
    result = a1;
  }
  return result;
}

//----- (1000C6B0) --------------------------------------------------------
int __stdcall sub_1000C6B0(int a1, int a2)
{
  int result; // eax@1
  char v3; // zf@1

  v3 = sub_10029607(a2) == 0;
  result = a1;
  *(_DWORD *)a1 = a2;
  if ( v3 )
    *(_DWORD *)(a1 + 4) = off_10075048;
  else
    *(_DWORD *)(a1 + 4) = off_1007504C;
  return result;
}
// 10075048: using guessed type int (__stdcall *off_10075048[3])(char);
// 1007504C: using guessed type int (__stdcall *off_1007504C[2])(char);

//----- (1000C700) --------------------------------------------------------
int __thiscall sub_1000C700(void *this)
{
  int result; // eax@2

  if ( this )
    result = (**(int (__stdcall ***)(_DWORD))this)(1);
  return result;
}

//----- (1000C710) --------------------------------------------------------
void *__thiscall sub_1000C710(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10060920;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10060920: using guessed type int (__stdcall *off_10060920)(char);

//----- (1000C740) --------------------------------------------------------
int __thiscall sub_1000C740(int this, int a2)
{
  *(_DWORD *)this = &off_10060920;
  *(_DWORD *)(this + 4) = a2;
  *(_DWORD *)this = &off_1006092C;
  *(_DWORD *)(this + 8) = 3;
  *(_DWORD *)(this + 16) = 0;
  return this;
}
// 10060920: using guessed type int (__stdcall *off_10060920)(char);
// 1006092C: using guessed type int (__stdcall *off_1006092C)(char);

//----- (1000C770) --------------------------------------------------------
void __thiscall sub_1000C770(int this, int a2)
{
  dword_100765FC = 0;
  dword_10076600 = 0;
  dword_10076604 = 0;
  dword_10076628 = 0;
  dword_1007662C = 0;
  dword_10076630 = 0;
  dword_10076638 = 0;
  dword_1007663C = 0;
  dword_10076640 = 0;
  dword_10076644 = 0;
  dword_10076648 = 0;
  dword_1007664C = 0;
  sub_1000C870((int)&dword_10076658, this);
  dword_10076760 = 0;
  dword_10076768 = 0;
  dword_1007676C = 0;
  dword_10076770 = 0;
  dword_1007678C = 0;
  dword_10076790 = 0;
  dword_10076794 = 0;
  dword_100767B4 = 0;
  dword_100767B8 = 0;
  dword_100767D4 = 0;
  dword_100767D8 = 0;
}
// 100765FC: using guessed type int dword_100765FC;
// 10076600: using guessed type int dword_10076600;
// 10076604: using guessed type int dword_10076604;
// 10076628: using guessed type int dword_10076628;
// 1007662C: using guessed type int dword_1007662C;
// 10076630: using guessed type int dword_10076630;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;
// 10076640: using guessed type int dword_10076640;
// 10076644: using guessed type int dword_10076644;
// 10076648: using guessed type int dword_10076648;
// 1007664C: using guessed type int dword_1007664C;
// 10076658: using guessed type int dword_10076658;
// 10076760: using guessed type int dword_10076760;
// 10076768: using guessed type int dword_10076768;
// 1007676C: using guessed type int dword_1007676C;
// 10076770: using guessed type int dword_10076770;
// 1007678C: using guessed type int dword_1007678C;
// 10076790: using guessed type int dword_10076790;
// 10076794: using guessed type int dword_10076794;
// 100767B4: using guessed type int dword_100767B4;
// 100767B8: using guessed type int dword_100767B8;
// 100767D4: using guessed type int dword_100767D4;
// 100767D8: using guessed type int dword_100767D8;

//----- (1000C870) --------------------------------------------------------
void __thiscall sub_1000C870(int this, int a2)
{
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 68) = 0;
  *(_DWORD *)(this + 80) = 0;
  *(_DWORD *)(this + 84) = 0;
  *(_DWORD *)(this + 104) = 0;
  *(_DWORD *)(this + 144) = 0;
  *(_DWORD *)(this + 148) = 0;
  *(_DWORD *)(this + 156) = 0;
  *(_DWORD *)(this + 160) = 0;
  *(_DWORD *)(this + 192) = 0;
  *(_DWORD *)(this + 216) = 0;
  *(_DWORD *)(this + 240) = 0;
}

//----- (1000C8F0) --------------------------------------------------------
signed int __stdcall sub_1000C8F0(int a1, int a2, int a3)
{
  return 1;
}

//----- (1000C900) --------------------------------------------------------
void *__thiscall sub_1000C900(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_10067B0C;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067B0C: using guessed type int (__stdcall *off_10067B0C[2])(char);

//----- (1000C940) --------------------------------------------------------
__int16 __userpurge sub_1000C940<ax>(int a1<ecx>, int a2<edi>, __int64 a3)
{
  int v3; // ebx@1
  char v4; // zf@1
  int v5; // esi@2
  __int64 v6; // qax@6
  __int64 v7; // qax@6
  __int16 result; // ax@9
  unsigned __int64 v9; // ST00_8@9
  __int64 v10; // qax@9
  __int64 v11; // qax@9
  int v12; // [sp+Ch] [bp-34h]@9
  int v13; // [sp+10h] [bp-30h]@9
  int v14; // [sp+14h] [bp-2Ch]@9
  __int16 v15; // [sp+24h] [bp-1Ch]@9
  __int64 v16; // [sp+30h] [bp-10h]@9
  unsigned int v17; // [sp+3Ch] [bp-4h]@1
  int v18; // [sp+40h] [bp+0h]@1

  v17 = (unsigned int)&v18 ^ __security_cookie;
  v3 = a1;
  v4 = *(_BYTE *)(a1 + 12) == 0;
  *(_QWORD *)(a1 + 48) = a3;
  if ( v4 && (v5 = *(_DWORD *)(a1 + 8)) != 0 )
  {
    if ( *(_DWORD *)(v5 + 132) >= -2147483648 && (*(_DWORD *)(v5 + 132) > -2147483648 || *(_DWORD *)(v5 + 128)) )
    {
      LODWORD(v7) = sub_10029F21();
      v6 = v7 - *(_QWORD *)(v5 + 128);
      *(_DWORD *)(v3 + 28) = HIDWORD(v6);
    }
    else
    {
      LODWORD(v6) = sub_10029F21();
      *(_DWORD *)(v3 + 28) = HIDWORD(v6);
    }
  }
  else
  {
    LODWORD(v6) = a3 - *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 28) = (unsigned __int64)(a3 - *(_QWORD *)(a1 + 16)) >> 32;
  }
  *(_DWORD *)(v3 + 24) = v6;
  HIDWORD(v9) = ((_DWORD)v6 >= 0xFFB3B4C0u) + *(_DWORD *)(v3 + 28);
  LODWORD(v9) = v6 + 5000000;
  LODWORD(v10) = sub_1003AC40(v9, 0x989680u, 0);
  v16 = v10;
  sub_100303A8(v3, a2, (int)&v12, (int)&v16);
  v11 = sub_10039A20(v16 - 3600 * v14 - 60 * v13 - v12, 10000000i64);
  *(_DWORD *)(v3 + 32) = v11;
  result = v15;
  *(_DWORD *)(v3 + 36) = HIDWORD(v11);
  *(_WORD *)(v3 + 40) = result;
  return result;
}
// 10073200: using guessed type int __security_cookie;

//----- (1000CA40) --------------------------------------------------------
char __stdcall sub_1000CA40(int a1)
{
  int *v1; // eax@1
  int v2; // ebx@1
  unsigned int v3; // edi@1

  v3 = *(_DWORD *)a1;
  v2 = *(_DWORD *)(a1 + 4);
  v1 = &dword_100767E0;
  while ( v2 < v1[1] || v2 <= v1[1] && v3 < *v1 || v2 >= v1[3] && (v2 > v1[3] || v3 >= v1[2]) )
  {
    v1 += 4;
    if ( (_UNKNOWN *)v1 == &unk_10076830 )
      return 0;
  }
  return 1;
}
// 100767E0: using guessed type int dword_100767E0;

//----- (1000CA90) --------------------------------------------------------
int __userpurge sub_1000CA90<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_1005F2EC;
  return v4;
}
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);

//----- (1000CAB0) --------------------------------------------------------
int __fastcall sub_1000CAB0(int a1, const char *a2)
{
  int v2; // esi@1
  char v3; // bl@2
  int *v4; // edi@2
  char v5; // zf@3
  unsigned int v6; // ecx@4
  char v7; // bl@11
  void *v9; // [sp+10h] [bp-40h]@2
  int v10; // [sp+20h] [bp-30h]@2
  unsigned int v11; // [sp+24h] [bp-2Ch]@2
  void *v12; // [sp+28h] [bp-28h]@3
  int v13; // [sp+38h] [bp-18h]@3
  unsigned int v14; // [sp+3Ch] [bp-14h]@3
  int v15; // [sp+40h] [bp-10h]@1

  v2 = a1;
  v15 = 0;
  if ( a2 )
  {
    v5 = *a2 == 0;
    v14 = 15;
    v13 = 0;
    LOBYTE(v12) = 0;
    if ( v5 )
      v6 = 0;
    else
      v6 = strlen(a2);
    loc_1000AEB0(&v12, a2, v6);
    v4 = (int *)&v12;
    v3 = 2;
  }
  else
  {
    v11 = 15;
    v10 = 0;
    LOBYTE(v9) = 0;
    v4 = (int *)&v9;
    v3 = 1;
  }
  *(_DWORD *)(v2 + 20) = 15;
  *(_DWORD *)(v2 + 16) = 0;
  *(_BYTE *)v2 = 0;
  if ( (unsigned int)v4[5] >= 0x10 )
  {
    *(_DWORD *)v2 = *v4;
    *v4 = 0;
  }
  else
  {
    if ( v4[4] != -1 )
      sub_1002A4B0((void *)v2, v4, v4[4] + 1);
  }
  *(_DWORD *)(v2 + 16) = v4[4];
  v7 = v3 | 4;
  *(_DWORD *)(v2 + 20) = v4[5];
  v4[5] = 15;
  v4[4] = 0;
  *(_BYTE *)v4 = 0;
  if ( v7 & 2 )
  {
    v7 &= 0xFDu;
    if ( v14 >= 0x10 )
      sub_1002A4AA(v12);
    v14 = 15;
    v13 = 0;
    LOBYTE(v12) = 0;
  }
  if ( v7 & 1 )
  {
    if ( v11 >= 0x10 )
      sub_1002A4AA(v9);
  }
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1000CBF0) --------------------------------------------------------
void __userpurge SetBalance(int a1<ebx>, unsigned int a2, __int64 a3, const char *a4)
{
  int v4; // esi@3
  char v5; // [sp-18h] [bp-48h]@6
  int v6; // [sp-14h] [bp-44h]@6
  int v7; // [sp-10h] [bp-40h]@6
  int v8; // [sp-Ch] [bp-3Ch]@6
  int v9; // [sp-8h] [bp-38h]@6
  unsigned int v10; // [sp-4h] [bp-34h]@6
  char v11; // [sp+8h] [bp-28h]@1
  char v12; // [sp+10h] [bp-20h]@4
  unsigned int v13; // [sp+24h] [bp-Ch]@7
  char v14; // [sp+28h] [bp-8h]@1
  unsigned int v15; // [sp+2Ch] [bp-4h]@1

  v15 = (unsigned int)&v11 ^ __security_cookie;
  sub_1002B6B7((int)&v14, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    sub_1002B6E4(&v14);
  }
  else
  {
    v4 = *(_DWORD *)(dword_10076638 + 4 * a2);
    sub_1002B6E4(&v14);
    if ( v4 )
    {
      sub_1000CAB0((int)&v12, a4);
      if ( !*(_BYTE *)(v4 + 12) )
      {
        if ( *(_DWORD *)(v4 + 8) )
        {
          v10 = 15;
          v9 = 0;
          v5 = 0;
          loc_1000AB40(&v12, 0, -1);
          __asm { movsd   xmm1, [ebp+arg_4] }
          sub_10021CA0(*(void **)(v4 + 8), *(void **)&v5, v6, v7, v8, v9, v10);
        }
      }
      if ( v13 >= 0x10 )
        sub_1002A4AA(*(LPVOID *)&v12);
    }
  }
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (1000CCD0) --------------------------------------------------------
char __userpurge SetMarket<al>(int a1<ebx>, unsigned int a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  int v7; // esi@3
  int v8; // eax@5
  int v9; // ecx@5
  __int64 v10; // ST10_8@5
  __int64 v12; // ST08_8@5
  char v15; // [sp+14h] [bp-3Ch]@1
  char v16; // [sp+48h] [bp-8h]@1
  unsigned int v17; // [sp+4Ch] [bp-4h]@1

  v17 = (unsigned int)&v15 ^ __security_cookie;
  sub_1002B6B7((int)&v16, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    sub_1002B6E4(&v16);
LABEL_7:
    LOBYTE(v8) = 0;
    return v8;
  }
  v7 = *(_DWORD *)(dword_10076638 + 4 * a2);
  sub_1002B6E4(&v16);
  if ( !v7 || !(*(_BYTE *)(v7 + 56) & 1) )
    goto LABEL_7;
  __asm
  {
    movsd   xmm0, [ebp+arg_20]
    movsd   xmm3, [ebp+arg_10]
    movsd   xmm2, [ebp+arg_8]
  }
  v9 = v7;
  __asm
  {
    movsd   [esp+50h+var_48], xmm0
    movsd   xmm0, [ebp+arg_18]
    movsd   [esp+50h+var_50], xmm0
  }
  return sub_1000B410(v9, 10000000i64 * a3, v12, v10);
}
// 10073200: using guessed type int __security_cookie;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (1000CD90) --------------------------------------------------------
char __userpurge SetMaxSpread<al>(int a1<ebx>, unsigned int a2, __int64 a3)
{
  char result; // al@3
  char v5; // [sp+4h] [bp-8h]@1
  unsigned int v6; // [sp+8h] [bp-4h]@1
  int v7; // [sp+Ch] [bp+0h]@1

  v6 = (unsigned int)&v7 ^ __security_cookie;
  sub_1002B6B7((int)&v5, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    result = sub_1002B6E4(&v5);
  }
  else
  {
    _ESI = *(_DWORD *)(dword_10076638 + 4 * a2);
    result = sub_1002B6E4(&v5);
    if ( _ESI )
    {
      if ( *(_BYTE *)(_ESI + 56) & 1 )
      {
        __asm
        {
          movsd   xmm0, [ebp+arg_4]
          movsd   qword ptr [esi+70h], xmm0
        }
      }
    }
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (1000CE20) --------------------------------------------------------
char __userpurge S1_SetIndicators<al>(int a1<ebx>, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10)
{
  __int16 v10; // ax@3
  char v13; // [sp+4h] [bp-Ch]@1
  char v14; // [sp+8h] [bp-8h]@1
  unsigned int v15; // [sp+Ch] [bp-4h]@1

  v15 = (unsigned int)&v13 ^ __security_cookie;
  sub_1002B6B7((int)&v14, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    LOBYTE(v10) = sub_1002B6E4(&v14);
  }
  else
  {
    _ESI = *(_DWORD *)(dword_10076638 + 4 * a2);
    LOBYTE(v10) = sub_1002B6E4(&v14);
    if ( _ESI )
    {
      v10 = *(_WORD *)(_ESI + 56);
      if ( v10 == word_10074E78 )
      {
        __asm
        {
          movsd   xmm0, [ebp+arg_4]
          movsd   qword ptr [esi+188h], xmm0
          movsd   xmm0, [ebp+arg_C]
          movsd   qword ptr [esi+190h], xmm0
          movsd   xmm0, [ebp+arg_14]
          movsd   qword ptr [esi+198h], xmm0
          movsd   xmm0, [ebp+arg_1C]
          movsd   qword ptr [esi+1A0h], xmm0
          movsd   xmm0, [ebp+arg_24]
          movsd   qword ptr [esi+1A8h], xmm0
          movsd   xmm0, [ebp+arg_2C]
          movsd   qword ptr [esi+1B0h], xmm0
          movsd   xmm0, [ebp+arg_34]
          movsd   qword ptr [esi+1B8h], xmm0
          movsd   xmm0, [ebp+arg_3C]
          movsd   qword ptr [esi+1C0h], xmm0
        }
      }
    }
  }
  return v10;
}
// 10073200: using guessed type int __security_cookie;
// 10074E78: using guessed type __int16 word_10074E78;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (1000CF20) --------------------------------------------------------
char __userpurge S1_OpenLong1<al>(int a1<ebx>, unsigned int a2, __int64 a3)
{
  int v3; // esi@3
  int v4; // eax@5
  char v6; // [sp+4h] [bp-Ch]@1
  char v7; // [sp+8h] [bp-8h]@1
  unsigned int v8; // [sp+Ch] [bp-4h]@1

  v8 = (unsigned int)&v6 ^ __security_cookie;
  sub_1002B6B7((int)&v7, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    sub_1002B6E4(&v7);
LABEL_7:
    LOBYTE(v4) = 0;
    return v4;
  }
  v3 = *(_DWORD *)(dword_10076638 + 4 * a2);
  sub_1002B6E4(&v7);
  if ( !v3 || *(_WORD *)(v3 + 56) != word_10074E78 )
    goto LABEL_7;
  __asm { movsd   xmm1, [ebp+arg_4] }
  return sub_1000BC60(v3);
}
// 10073200: using guessed type int __security_cookie;
// 10074E78: using guessed type __int16 word_10074E78;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (1000CFC0) --------------------------------------------------------
char __userpurge S1_OpenShort1<al>(int a1<ebx>, unsigned int a2, __int64 a3)
{
  int v3; // esi@3
  int v4; // eax@5
  char v6; // [sp+4h] [bp-Ch]@1
  char v7; // [sp+8h] [bp-8h]@1
  unsigned int v8; // [sp+Ch] [bp-4h]@1

  v8 = (unsigned int)&v6 ^ __security_cookie;
  sub_1002B6B7((int)&v7, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    sub_1002B6E4(&v7);
LABEL_7:
    LOBYTE(v4) = 0;
    return v4;
  }
  v3 = *(_DWORD *)(dword_10076638 + 4 * a2);
  sub_1002B6E4(&v7);
  if ( !v3 || *(_WORD *)(v3 + 56) != word_10074E78 )
    goto LABEL_7;
  __asm { movsd   xmm1, [ebp+arg_4] }
  return sub_1000BD30(v3);
}
// 10073200: using guessed type int __security_cookie;
// 10074E78: using guessed type __int16 word_10074E78;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (1000D060) --------------------------------------------------------
signed int __userpurge S1_OpenLong2<eax>(int a1<ebx>, unsigned int a2, __int64 a3)
{
  int v16; // eax@8
  signed int result; // eax@12
  char v26; // [sp+4h] [bp-8h]@1
  unsigned int v27; // [sp+8h] [bp-4h]@1
  int v28; // [sp+Ch] [bp+0h]@1

  v27 = (unsigned int)&v28 ^ __security_cookie;
  sub_1002B6B7((int)&v26, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    sub_1002B6E4(&v26);
    return 0;
  }
  _ESI = *(_DWORD *)(dword_10076638 + 4 * a2);
  sub_1002B6E4(&v26);
  if ( !_ESI || *(_WORD *)(_ESI + 56) != word_10074E78 )
    return 0;
  __asm
  {
    movsd   xmm0, ds:qword_10068550
    comisd  xmm0, qword ptr [esi+1A8h]
  }
  if ( _CF | _ZF )
  {
    __asm
    {
      movsd   xmm0, ds:qword_10068558
      comisd  xmm0, qword ptr [esi+1B0h]
    }
    if ( _CF | _ZF )
      goto LABEL_18;
    __asm { comisd  xmm0, qword ptr [esi+1B8h] }
    if ( _CF | _ZF )
      goto LABEL_18;
  }
  v16 = *(_DWORD *)(_ESI + 8);
  if ( !v16 )
    goto LABEL_18;
  if ( !(*(_BYTE *)(v16 + 112) & 4) )
    goto LABEL_18;
  __asm
  {
    movsd   xmm1, qword ptr [esi+190h]
    subsd   xmm1, [ebp+arg_4]
    xorps   xmm0, xmm0
    comisd  xmm0, xmm1
  }
  if ( _CF )
    goto LABEL_18;
  __asm
  {
    movsd   xmm0, qword ptr [esi+148h]
    comisd  xmm0, qword ptr [esi+1A0h]
  }
  if ( _CF | _ZF )
LABEL_18:
    result = 0;
  else
    result = 1;
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10074E78: using guessed type __int16 word_10074E78;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (1000D170) --------------------------------------------------------
char __userpurge S1_OpenShort2<al>(int a1<ebx>, unsigned int a2, __int64 a3)
{
  int v3; // esi@3
  int v4; // eax@5
  char v6; // [sp+4h] [bp-8h]@1
  unsigned int v7; // [sp+8h] [bp-4h]@1
  int v8; // [sp+Ch] [bp+0h]@1

  v7 = (unsigned int)&v8 ^ __security_cookie;
  sub_1002B6B7((int)&v6, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    sub_1002B6E4(&v6);
LABEL_7:
    LOBYTE(v4) = 0;
    return v4;
  }
  v3 = *(_DWORD *)(dword_10076638 + 4 * a2);
  sub_1002B6E4(&v6);
  if ( !v3 || *(_WORD *)(v3 + 56) != word_10074E78 )
    goto LABEL_7;
  __asm { movsd   xmm1, [ebp+arg_4] }
  return sub_1000BE10(v3);
}
// 10073200: using guessed type int __security_cookie;
// 10074E78: using guessed type __int16 word_10074E78;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (1000D200) --------------------------------------------------------
signed int __userpurge S1_OpenLong22<eax>(int a1<ebx>, unsigned int a2, signed int a3, __int64 a4, __int64 a5)
{
  signed int result; // eax@10
  char v23; // [sp+4h] [bp-Ch]@1
  char v24; // [sp+8h] [bp-8h]@1
  unsigned int v25; // [sp+Ch] [bp-4h]@1

  v25 = (unsigned int)&v23 ^ __security_cookie;
  sub_1002B6B7((int)&v24, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    sub_1002B6E4(&v24);
    return 0;
  }
  _ESI = *(_DWORD *)(dword_10076638 + 4 * a2);
  sub_1002B6E4(&v24);
  if ( !_ESI || *(_WORD *)(_ESI + 56) != word_10074E78 )
    return 0;
  if ( a3 > 20 )
    goto LABEL_16;
  __asm
  {
    movd    xmm0, dword ptr [esi+154h]
    movsd   xmm3, qword ptr [esi+88h]
    movsd   xmm2, [ebp+arg_8]
    movsd   xmm4, qword ptr [esi+80h]
    cvtdq2pd xmm0, xmm0
    movapd  xmm1, xmm2
    subsd   xmm1, [ebp+arg_10]
    mulsd   xmm0, xmm3
    mulsd   xmm0, xmm4
    comisd  xmm0, xmm1
  }
  if ( _CF )
    goto LABEL_16;
  __asm
  {
    movd    xmm0, dword ptr [esi+150h]
    cvtdq2pd xmm0, xmm0
    mulsd   xmm0, xmm3
    mulsd   xmm0, xmm4
    comisd  xmm1, xmm0
  }
  if ( _CF )
    goto LABEL_16;
  __asm
  {
    subsd   xmm2, qword ptr [esi+190h]
    movapd  xmm0, xmm1
    mulsd   xmm0, ds:qword_10068480
    comisd  xmm0, xmm2
  }
  if ( _CF | _ZF )
    goto LABEL_16;
  __asm
  {
    mulsd   xmm1, ds:qword_10068470
    comisd  xmm2, xmm1
  }
  if ( _CF | _ZF )
LABEL_16:
    result = 0;
  else
    result = 1;
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10074E78: using guessed type __int16 word_10074E78;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (1000D340) --------------------------------------------------------
signed int __userpurge S1_OpenShort22<eax>(int a1<ebx>, unsigned int a2, signed int a3, __int64 a4, __int64 a5)
{
  signed int result; // eax@10
  char v23; // [sp+4h] [bp-Ch]@1
  char v24; // [sp+8h] [bp-8h]@1
  unsigned int v25; // [sp+Ch] [bp-4h]@1

  v25 = (unsigned int)&v23 ^ __security_cookie;
  sub_1002B6B7((int)&v24, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    sub_1002B6E4(&v24);
    return 0;
  }
  _ESI = *(_DWORD *)(dword_10076638 + 4 * a2);
  sub_1002B6E4(&v24);
  if ( !_ESI || *(_WORD *)(_ESI + 56) != word_10074E78 )
    return 0;
  if ( a3 > 20 )
    goto LABEL_16;
  __asm
  {
    movd    xmm0, dword ptr [esi+154h]
    movsd   xmm2, qword ptr [esi+88h]
    movsd   xmm1, [ebp+arg_10]
    movsd   xmm3, [ebp+arg_8]
    movsd   xmm4, qword ptr [esi+80h]
    cvtdq2pd xmm0, xmm0
    subsd   xmm1, xmm3
    mulsd   xmm0, xmm2
    mulsd   xmm0, xmm4
    comisd  xmm0, xmm1
  }
  if ( _CF )
    goto LABEL_16;
  __asm
  {
    movd    xmm0, dword ptr [esi+150h]
    cvtdq2pd xmm0, xmm0
    mulsd   xmm0, xmm2
    mulsd   xmm0, xmm4
    comisd  xmm1, xmm0
  }
  if ( _CF )
    goto LABEL_16;
  __asm
  {
    movsd   xmm2, qword ptr [esi+190h]
    movaps  xmm0, xmm1
    mulsd   xmm0, ds:qword_10068480
    subsd   xmm2, xmm3
    comisd  xmm0, xmm2
  }
  if ( _CF | _ZF )
    goto LABEL_16;
  __asm
  {
    mulsd   xmm1, ds:qword_10068470
    comisd  xmm2, xmm1
  }
  if ( _CF | _ZF )
LABEL_16:
    result = 0;
  else
    result = 1;
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10074E78: using guessed type __int16 word_10074E78;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (1000D480) --------------------------------------------------------
char __userpurge S1_CloseLong<al>(int a1<ebx>, unsigned int a2, __int64 a3, __int64 a4, unsigned int a5)
{
  int v5; // esi@3
  int v6; // eax@5
  char v8; // [sp+4h] [bp-Ch]@1
  char v9; // [sp+8h] [bp-8h]@1
  unsigned int v10; // [sp+Ch] [bp-4h]@1

  v10 = (unsigned int)&v8 ^ __security_cookie;
  sub_1002B6B7((int)&v9, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    sub_1002B6E4(&v9);
LABEL_7:
    LOBYTE(v6) = 0;
    return v6;
  }
  v5 = *(_DWORD *)(dword_10076638 + 4 * a2);
  sub_1002B6E4(&v9);
  if ( !v5 || *(_WORD *)(v5 + 56) != word_10074E78 )
    goto LABEL_7;
  __asm
  {
    movsd   xmm2, [ebp+arg_C]
    movsd   xmm1, [ebp+arg_4]
  }
  return sub_1000BEA0(v5, 10000000i64 * a5);
}
// 10073200: using guessed type int __security_cookie;
// 10074E78: using guessed type __int16 word_10074E78;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (1000D530) --------------------------------------------------------
char __userpurge S1_CloseShort<al>(int a1<ebx>, unsigned int a2, __int64 a3, __int64 a4, unsigned int a5)
{
  int v5; // esi@3
  int v6; // eax@5
  char v8; // [sp+4h] [bp-Ch]@1
  char v9; // [sp+8h] [bp-8h]@1
  unsigned int v10; // [sp+Ch] [bp-4h]@1

  v10 = (unsigned int)&v8 ^ __security_cookie;
  sub_1002B6B7((int)&v9, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    sub_1002B6E4(&v9);
LABEL_7:
    LOBYTE(v6) = 0;
    return v6;
  }
  v5 = *(_DWORD *)(dword_10076638 + 4 * a2);
  sub_1002B6E4(&v9);
  if ( !v5 || *(_WORD *)(v5 + 56) != word_10074E78 )
    goto LABEL_7;
  __asm
  {
    movsd   xmm2, [ebp+arg_C]
    movsd   xmm1, [ebp+arg_4]
  }
  return sub_1000C000(v5, 10000000i64 * a5);
}
// 10073200: using guessed type int __security_cookie;
// 10074E78: using guessed type __int16 word_10074E78;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (1000D5E0) --------------------------------------------------------
char __userpurge S1_CloseDa<al>(int a1<ebx>, unsigned int a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  int v6; // esi@3
  int v7; // eax@5
  int v8; // ecx@5
  __int64 v9; // ST08_8@5
  char v12; // [sp+Ch] [bp-3Ch]@1
  char v13; // [sp+40h] [bp-8h]@1
  unsigned int v14; // [sp+44h] [bp-4h]@1

  v14 = (unsigned int)&v12 ^ __security_cookie;
  sub_1002B6B7((int)&v13, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
  {
    sub_1002B6E4(&v13);
LABEL_7:
    LOBYTE(v7) = 0;
    return v7;
  }
  v6 = *(_DWORD *)(dword_10076638 + 4 * a2);
  sub_1002B6E4(&v13);
  if ( !v6 || *(_WORD *)(v6 + 56) != word_10074E78 )
    goto LABEL_7;
  __asm
  {
    movsd   xmm0, [ebp+arg_18]
    movsd   xmm3, [ebp+arg_10]
    movsd   xmm2, [ebp+arg_8]
  }
  v8 = v6;
  __asm { movsd   [esp+48h+var_48], xmm0 }
  return sub_1000C160(v8, 10000000i64 * a3, v9);
}
// 10073200: using guessed type int __security_cookie;
// 10074E78: using guessed type __int16 word_10074E78;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (1000D6A0) --------------------------------------------------------
bool __stdcall CheckVersion(const char *a1)
{
  int v1; // eax@1
  int v2; // edx@1
  int v3; // ecx@1
  unsigned int v4; // edi@3
  unsigned int v5; // eax@5
  int v6; // esi@5
  signed int v7; // eax@7
  bool v8; // ebx@11
  void *v10; // [sp+10h] [bp-18h]@1
  unsigned int v11; // [sp+24h] [bp-4h]@11

  v1 = sub_1000CAB0((int)&v10, a1);
  v3 = v1;
  v2 = (int)&dword_10075000;
  if ( (unsigned int)dword_10075014 >= 0x10 )
    v2 = dword_10075000;
  v4 = *(_DWORD *)(v1 + 16);
  if ( *(_DWORD *)(v1 + 20) >= 0x10u )
    v3 = *(_DWORD *)v1;
  v6 = dword_10075010;
  v5 = dword_10075010;
  if ( v4 < dword_10075010 )
    v5 = v4;
  v7 = sub_100099E0(v3, v2, v5);
  if ( !v7 )
  {
    if ( v4 >= v6 )
      v7 = v4 != v6;
    else
      v7 = -1;
  }
  v8 = v7 == 0;
  if ( v11 >= 0x10 )
    sub_1002A4AA(v10);
  return v8;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10075000: using guessed type int dword_10075000;
// 10075010: using guessed type int dword_10075010;
// 10075014: using guessed type int dword_10075014;

//----- (1000D730) --------------------------------------------------------
void __stdcall Initialize(const char *a1, const char *a2, int a3, int a4, const char *a5)
{
  char v5; // [sp-48h] [bp-50h]@1
  int v6; // [sp-44h] [bp-4Ch]@1
  int v7; // [sp-40h] [bp-48h]@1
  int v8; // [sp-3Ch] [bp-44h]@1
  unsigned int v9; // [sp-38h] [bp-40h]@1
  signed int v10; // [sp-34h] [bp-3Ch]@1
  char v11; // [sp-30h] [bp-38h]@1
  int v12; // [sp-2Ch] [bp-34h]@1
  int v13; // [sp-28h] [bp-30h]@1
  int v14; // [sp-24h] [bp-2Ch]@1
  int v15; // [sp-20h] [bp-28h]@1
  signed int v16; // [sp-1Ch] [bp-24h]@1
  char v17; // [sp-18h] [bp-20h]@1
  int v18; // [sp-14h] [bp-1Ch]@1
  int v19; // [sp-10h] [bp-18h]@1
  int v20; // [sp-Ch] [bp-14h]@1
  unsigned int v21; // [sp-8h] [bp-10h]@1
  unsigned int v22; // [sp-4h] [bp-Ch]@1

  sub_1000CAB0((int)&v17, a5);
  sub_1000CAB0((int)&v11, a2);
  sub_1000CAB0((int)&v5, a1);
  sub_10021A90(
    a3,
    a4,
    *(void **)&v5,
    v6,
    v7,
    v8,
    v9,
    v10,
    *(void **)&v11,
    v12,
    v13,
    v14,
    v15,
    v16,
    *(void **)&v17,
    v18,
    v19,
    v20,
    v21,
    v22);
}

//----- (1000D7F0) --------------------------------------------------------
int __cdecl Status()
{
  return dword_100765C8;
}
// 100765C8: using guessed type int dword_100765C8;

//----- (1000D800) --------------------------------------------------------
int __cdecl ErrorCode()
{
  return dword_100765CC;
}
// 100765CC: using guessed type int dword_100765CC;

//----- (1000D810) --------------------------------------------------------
int __cdecl Utc()
{
  __int64 v0; // qax@4
  __int64 v1; // qax@4

  if ( HIDWORD(qword_100765D8) >= -2147483648 && (HIDWORD(qword_100765D8) > -2147483648 || (_DWORD)qword_100765D8) )
  {
    LODWORD(v1) = sub_10029F21();
    v0 = v1 - qword_100765D8;
  }
  else
  {
    LODWORD(v0) = sub_10029F21();
  }
  return sub_1003AC40(v0 + 5000000, 0x989680u, 0);
}
// 100765D8: using guessed type __int64 qword_100765D8;

//----- (1000D860) --------------------------------------------------------
int __userpurge Msg<eax>(int a1<ebx>, int a2, unsigned int a3, int a4)
{
  int v4; // eax@4
  int *v5; // edx@6

  if ( a2 == 1 )
  {
    v5 = &dword_100765E0;
  }
  else
  {
    if ( a2 == 2 )
    {
      v5 = &dword_1007660C;
    }
    else
    {
      if ( a2 != 3
        || (v4 = sub_10021E10(a1, a3), !v4)
        || !(*(_BYTE *)(v4 + 56) & 1)
        || (v5 = (int *)(v4 + 248), v4 == -248) )
        return 0;
    }
  }
  *(_DWORD *)a4 = v5[10];
  return (v5[8] - v5[7]) / 12;
}
// 100765E0: using guessed type int dword_100765E0;
// 1007660C: using guessed type int dword_1007660C;

//----- (1000D8C0) --------------------------------------------------------
signed int __userpurge GetMsg<eax>(int a1<ebx>, int a2, unsigned int a3, int a4, int a5, int a6)
{
  int v6; // eax@4
  int v7; // esi@6
  int *v9; // eax@11
  int v10; // ebx@13
  int v11; // eax@14
  int v12; // ecx@14
  int v13; // edi@14
  int v14; // eax@16
  int v15; // esi@16
  char v16; // cf@18
  int v17; // [sp+Ch] [bp-2Ch]@1
  int v18; // [sp+10h] [bp-28h]@6
  int v19; // [sp+14h] [bp-24h]@13
  int v20; // [sp+18h] [bp-20h]@1
  void *v21; // [sp+1Ch] [bp-1Ch]@16
  unsigned int v22; // [sp+30h] [bp-8h]@16
  unsigned int v23; // [sp+34h] [bp-4h]@1

  v23 = (unsigned int)&v17 ^ __security_cookie;
  v20 = a5;
  if ( a2 == 1 )
  {
    v7 = (int)&dword_100765E0;
    goto LABEL_10;
  }
  if ( a2 == 2 )
  {
    v7 = (int)&dword_1007660C;
LABEL_10:
    v18 = v7;
    goto LABEL_11;
  }
  if ( a2 != 3
    || (v6 = sub_10021E10(a1, a3), !v6)
    || !(*(_BYTE *)(v6 + 56) & 1)
    || (v7 = v6 + 248, v18 = v6 + 248, v6 == -248) )
    return 0;
LABEL_11:
  sub_10021D60(a1, 0);
  v9 = &v17;
  if ( (*(_DWORD *)(v7 + 32) - *(_DWORD *)(v7 + 28)) / 12 >= a6 )
    v9 = &a6;
  v17 = (*(_DWORD *)(v7 + 32) - *(_DWORD *)(v7 + 28)) / 12;
  v10 = 0;
  v19 = *v9;
  if ( v19 > 0 )
  {
    v12 = v19;
    v11 = 0;
    v17 = 0;
    v13 = a4 + 4;
    do
    {
      if ( *(_DWORD *)v13 )
      {
        v15 = v11 + *(_DWORD *)(v7 + 28);
        sub_10018500(v15, (int)&v21);
        v14 = (int)&v21;
        if ( v22 >= 0x10 )
          v14 = (int)v21;
        sub_100305D1(v10, v13, *(_DWORD *)v13, 60, v14, -1);
        v16 = v22 < 0x10;
        *(_DWORD *)(v20 + 4 * v10) = *(_DWORD *)(v15 + 8);
        if ( !v16 )
          sub_1002A4AA(v21);
        v12 = v19;
        v7 = v18;
        v11 = v17;
      }
      ++v10;
      v11 += 12;
      v13 += 8;
      v17 = v11;
    }
    while ( v10 < v12 );
  }
  return 1;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;
// 100765E0: using guessed type int dword_100765E0;
// 1007660C: using guessed type int dword_1007660C;

//----- (1000DA10) --------------------------------------------------------
int __fastcall StartExpert(int a1, int a2, int a3, int a4, const char *a5, __int64 a6, unsigned int a7)
{
  int v7; // eax@5
  int v8; // ecx@5
  int v9; // ecx@6
  int v10; // ecx@7
  char v12; // [sp-20h] [bp-38h]@5
  int v13; // [sp-1Ch] [bp-34h]@5
  int v14; // [sp-18h] [bp-30h]@5
  int v15; // [sp-14h] [bp-2Ch]@5
  int v16; // [sp-10h] [bp-28h]@5
  unsigned int v17; // [sp-Ch] [bp-24h]@5
  int v18; // [sp-8h] [bp-20h]@5
  int v19; // [sp-4h] [bp-1Ch]@5
  double v20; // [sp+10h] [bp-8h]@5

  if ( !a5 )
    return -1;
  if ( a3 == 1 )
  {
    __asm
    {
      movsd   xmm0, [ebp+arg_C]
      mulsd   xmm0, ds:qword_10068510
      movsd   [esp+18h+var_8], xmm0
    }
    v19 = a2;
    v18 = sub_1004D276(v20);
    sub_1000AFB0((int)&v12, a5);
    LOBYTE(v10) = a4 != 0;
    v7 = sub_1000BAD0(v10, ~(unsigned __int8)(a7 >> 4) & 1, *(void **)&v12, v13, v14, v15, v16, v17, v18, v19);
  }
  else
  {
    if ( a3 == 2 )
    {
      __asm
      {
        movsd   xmm0, [ebp+arg_C]
        mulsd   xmm0, ds:qword_10068510
        movsd   [esp+18h+var_8], xmm0
      }
      v19 = a2;
      v18 = sub_1004D276(v20);
      sub_1000AFB0((int)&v12, a5);
      LOBYTE(v9) = a4 != 0;
      v7 = sub_10020C70(v9, ~(unsigned __int8)(a7 >> 4) & 1, *(void **)&v12, v13, v14, v15, v16, v17, v18, v19);
    }
    else
    {
      if ( a3 != 3 )
        return -1;
      __asm
      {
        movsd   xmm0, [ebp+arg_C]
        mulsd   xmm0, ds:qword_10068510
        movsd   [esp+18h+var_8], xmm0
      }
      v19 = a2;
      v18 = sub_1004D276(v20);
      sub_1000AFB0((int)&v12, a5);
      LOBYTE(v8) = a4 != 0;
      v7 = sub_10021170(
             v8,
             ~(unsigned __int8)(a7 >> 4) & 1,
             (a7 >> 20) & 1,
             *(void **)&v12,
             v13,
             v14,
             v15,
             v16,
             v17,
             v18,
             v19);
    }
  }
  if ( v7 )
    return sub_10021EA0(v7);
  return -1;
}

//----- (1000DB30) --------------------------------------------------------
char __stdcall StopExpert(unsigned int a1)
{
  int ebp0; // ebp@0
  int v2; // esi@3
  char v4; // [sp+0h] [bp-20h]@5
  unsigned int v5; // [sp+1Ch] [bp-4h]@1
  int v6; // [sp+20h] [bp+0h]@1

  v5 = (unsigned int)&v6 ^ __security_cookie;
  sub_1002B672(ebp0, (int)&unk_10076774);
  if ( (signed int)a1 >= 0 )
  {
    if ( a1 < (dword_1007663C - dword_10076638) >> 2 )
    {
      v2 = dword_10076638 + 4 * a1;
      if ( *(_DWORD *)v2 )
      {
        (***(void (__stdcall ****)(_DWORD))v2)(1);
        *(_DWORD *)v2 = 0;
      }
    }
  }
  return sub_1002B6E4(&v4);
}
// 10073200: using guessed type int __security_cookie;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (1000DBA0) --------------------------------------------------------
int __fastcall sub_1000DBA0(int a1, unsigned int a2)
{
  unsigned int v2; // ebx@1
  int v3; // esi@1
  unsigned int v4; // ecx@2
  char v5; // cf@3
  int v6; // eax@8
  unsigned int v7; // ecx@11
  char v8; // cf@12
  int v9; // ecx@17
  unsigned int v10; // ecx@23
  char v11; // cf@24
  int v12; // ecx@29
  int v13; // ecx@32
  int v14; // ecx@39
  int v15; // ecx@42
  int v16; // ecx@45

  v2 = a2;
  v3 = a1;
  *(_DWORD *)(a1 + 20) = 15;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)a1 = 0;
  if ( a2 <= 0x7F )
  {
    v4 = *(_DWORD *)(a1 + 16);
    if ( v4 < 1 )
    {
      loc_10012FA0(v3, 1 - v4, 0);
    }
    else
    {
      v5 = *(_DWORD *)(v3 + 20) < 0x10u;
      *(_DWORD *)(v3 + 16) = 1;
      if ( v5 )
        *(_BYTE *)(v3 + 1) = 0;
      else
        *(_BYTE *)(*(_DWORD *)v3 + 1) = 0;
    }
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v6 = v3;
    else
      v6 = *(_DWORD *)v3;
LABEL_51:
    *(_BYTE *)v6 = v2;
    return v3;
  }
  if ( a2 <= 0x7FF )
  {
    v7 = *(_DWORD *)(a1 + 16);
    if ( v7 < 2 )
    {
      loc_10012FA0(v3, 2 - v7, 0);
    }
    else
    {
      v8 = *(_DWORD *)(v3 + 20) < 0x10u;
      *(_DWORD *)(v3 + 16) = 2;
      if ( v8 )
        *(_BYTE *)(v3 + 2) = 0;
      else
        *(_BYTE *)(*(_DWORD *)v3 + 2) = 0;
    }
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v9 = v3;
    else
      v9 = *(_DWORD *)v3;
    *(_BYTE *)(v9 + 1) = v2 & 0x3F | 0x80;
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
    {
      v6 = v3;
      LOBYTE(v2) = (v2 >> 6) & 0x1F | 0xC0;
    }
    else
    {
      v6 = *(_DWORD *)v3;
      LOBYTE(v2) = (v2 >> 6) & 0x1F | 0xC0;
    }
    goto LABEL_51;
  }
  if ( a2 <= 0xFFFF )
  {
    v10 = *(_DWORD *)(a1 + 16);
    if ( v10 < 3 )
    {
      loc_10012FA0(v3, 3 - v10, 0);
    }
    else
    {
      v11 = *(_DWORD *)(v3 + 20) < 0x10u;
      *(_DWORD *)(v3 + 16) = 3;
      if ( v11 )
        *(_BYTE *)(v3 + 3) = 0;
      else
        *(_BYTE *)(*(_DWORD *)v3 + 3) = 0;
    }
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v12 = v3;
    else
      v12 = *(_DWORD *)v3;
    *(_BYTE *)(v12 + 2) = v2 & 0x3F | 0x80;
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v13 = v3;
    else
      v13 = *(_DWORD *)v3;
    *(_BYTE *)(v13 + 1) = (v2 >> 6) & 0x3F | 0x80;
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
    {
      v6 = v3;
      LOBYTE(v2) = (v2 >> 12) & 0xF | 0xE0;
    }
    else
    {
      v6 = *(_DWORD *)v3;
      LOBYTE(v2) = (v2 >> 12) & 0xF | 0xE0;
    }
    goto LABEL_51;
  }
  if ( a2 <= 0x10FFFF )
  {
    sub_10012020(a1, 4);
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v14 = v3;
    else
      v14 = *(_DWORD *)v3;
    *(_BYTE *)(v14 + 3) = v2 & 0x3F | 0x80;
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v15 = v3;
    else
      v15 = *(_DWORD *)v3;
    *(_BYTE *)(v15 + 2) = (v2 >> 6) & 0x3F | 0x80;
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v16 = v3;
    else
      v16 = *(_DWORD *)v3;
    *(_BYTE *)(v16 + 1) = (v2 >> 12) & 0x3F | 0x80;
    if ( *(_DWORD *)(v3 + 20) < 0x10u )
      v6 = v3;
    else
      v6 = *(_DWORD *)v3;
    LOBYTE(v2) = (v2 >> 18) & 7 | 0xF0;
    goto LABEL_51;
  }
  return v3;
}

//----- (1000DDD0) --------------------------------------------------------
char __fastcall sub_1000DDD0(unsigned int a1, unsigned int a2)
{
  char result; // al@5

  if ( a1 >= a2 )
  {
LABEL_5:
    result = 0;
  }
  else
  {
    while ( *(_BYTE *)a1 != 10 && *(_BYTE *)a1 != 13 )
    {
      ++a1;
      if ( a1 >= a2 )
        goto LABEL_5;
    }
    result = 1;
  }
  return result;
}

//----- (1000DDF0) --------------------------------------------------------
int __usercall sub_1000DDF0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // esi@1
  int v8; // eax@3
  int v9; // edi@3

  v7 = a2;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  v4 = sub_1002ADB1(a1, a2, a3, a4, 8);
  if ( !v4 )
    sub_10029530();
  *(_DWORD *)v7 = v4;
  *(_DWORD *)v4 = 0;
  *(_DWORD *)(v4 + 4) = 0;
  **(_DWORD **)v7 = v7;
  v9 = v7 + 20;
  *(_DWORD *)(v7 + 20) = 0;
  *(_DWORD *)(v7 + 24) = 0;
  *(_DWORD *)(v7 + 28) = 0;
  *(_DWORD *)(v7 + 32) = 0;
  *(_DWORD *)(v7 + 36) = 0;
  v8 = sub_1002ADB1(v5, v6, a3, v7 + 20, 8);
  if ( !v8 )
    sub_10029530();
  *(_DWORD *)v9 = v8;
  *(_DWORD *)v8 = 0;
  *(_DWORD *)(v8 + 4) = 0;
  **(_DWORD **)v9 = v9;
  *(_DWORD *)(v7 + 60) = 15;
  *(_DWORD *)(v7 + 56) = 0;
  *(_BYTE *)(v7 + 40) = 0;
  *(_DWORD *)(v7 + 104) = 15;
  *(_DWORD *)(v7 + 100) = 0;
  *(_BYTE *)(v7 + 84) = 0;
  *(_WORD *)(v7 + 108) = 1;
  return v7;
}

//----- (1000DF00) --------------------------------------------------------
char __thiscall sub_1000DF00(int this, int a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  unsigned int v6; // ST08_4@1
  int v7; // eax@2
  int v8; // edx@7
  char v9; // bl@7
  char v10; // al@11
  char result; // al@16
  void *v12; // [sp+Ch] [bp-40h]@14
  unsigned int v13; // [sp+20h] [bp-2Ch]@14
  int v14; // [sp+24h] [bp-28h]@7
  int v15; // [sp+28h] [bp-24h]@14
  int v16; // [sp+2Ch] [bp-20h]@14
  int v17; // [sp+30h] [bp-1Ch]@1
  int v18; // [sp+34h] [bp-18h]@1
  int v19; // [sp+38h] [bp-14h]@1
  unsigned int v20; // [sp+3Ch] [bp-10h]@1
  int v21; // [sp+48h] [bp-4h]@14
  int v22; // [sp+4Ch] [bp+0h]@1

  v20 = (unsigned int)&v22 ^ __security_cookie;
  v6 = (unsigned int)&v22 ^ __security_cookie;
  v5 = this;
  v18 = a3;
  *(_DWORD *)(this + 68) = a3;
  v17 = a2;
  v19 = a4;
  *(_DWORD *)(this + 64) = a2;
  *(_BYTE *)(this + 110) = 0;
  *(_DWORD *)(this + 72) = a2;
  *(_DWORD *)(this + 76) = 0;
  *(_DWORD *)(this + 80) = 0;
  loc_1000AEB0(this + 84, &unk_1006723C, 0, v6);
  sub_10002D80(v5 + 20);
  if ( *(_DWORD *)(v5 + 16) )
  {
    v7 = *(_DWORD *)(v5 + 16);
    while ( v7 )
    {
      --v7;
      if ( !v7 )
        *(_DWORD *)(v5 + 12) = 0;
    }
    *(_DWORD *)(v5 + 16) = v7;
  }
  loc_100134C0(v5, &v19);
  v9 = sub_1000E050(v5);
  sub_1000E2C0(v5, (int)&v14);
  if ( *(_BYTE *)(v5 + 110) )
  {
    if ( *(_DWORD *)(v5 + 100) )
      sub_10011140(v8, a4, a4, v5 + 84, 2);
  }
  if ( *(_BYTE *)(v5 + 109) && (v10 = *(_BYTE *)(a4 + 8)) != 0 && v10 != 6 && v10 != 7 )
  {
    v15 = v17;
    v14 = 13;
    v16 = v18;
    sub_1000AFB0((int)&v12, "A valid JSON document must be either an array or an object value.");
    v21 = 0;
    sub_1000FD10((void *)v5, (int *)&v12, (int)&v14, 0);
    if ( v13 >= 0x10 )
      sub_1002A4AA(v12);
    result = 0;
  }
  else
  {
    result = v9;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (1000E050) --------------------------------------------------------
char __thiscall sub_1000E050(int this)
{
  int v1; // edx@1
  int v2; // ecx@1
  char v3; // bl@1
  int v4; // edi@1
  int v5; // eax@3
  int v6; // esi@3
  int v7; // ST08_4@3
  int v8; // eax@3
  int v9; // edx@3
  int v10; // ecx@7
  int v11; // eax@14
  int v12; // edx@14
  int v13; // eax@16
  int v14; // esi@16
  int v15; // ST08_4@16
  int v16; // eax@16
  int v17; // edx@16
  char result; // al@18
  int v19; // [sp+10h] [bp-5Ch]@1
  LPVOID v20[4]; // [sp+1Ch] [bp-50h]@3
  int v21; // [sp+2Ch] [bp-40h]@19
  unsigned int v22; // [sp+30h] [bp-3Ch]@19
  int v23; // [sp+34h] [bp-38h]@3
  int v24; // [sp+3Ch] [bp-30h]@11
  int v25; // [sp+40h] [bp-2Ch]@11
  char v26; // [sp+44h] [bp-28h]@16
  char v27; // [sp+50h] [bp-1Ch]@16
  int v28; // [sp+68h] [bp-4h]@11

  v4 = this;
  sub_1000E2C0(this, (int)&v19);
  v3 = 1;
  if ( *(_BYTE *)(v4 + 110) )
  {
    if ( *(_DWORD *)(v4 + 100) )
    {
      v7 = v2;
      v8 = sub_10013580(v4, (int)&v23);
      v5 = sub_10015510(v8, v9, (int)v20, v7);
      v6 = *(_DWORD *)v5;
      if ( *(_DWORD *)v5 )
        v6 = *(_DWORD *)v6;
      sub_10011140(
        *(_DWORD *)(v5 + 8) & 3,
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 4 * ((*(_DWORD *)(v5 + 8) >> 2) & (*(_DWORD *)(v6 + 8) - 1)))
                  + 4 * (*(_DWORD *)(v5 + 8) & 3)),
        v4,
        v4 + 84,
        0);
      loc_1000AEB0(v4 + 84, &unk_1006723C, 0);
    }
  }
  switch ( v19 )
  {
    case 1:
      v3 = sub_1000EA70(v1, v4, 1, v4, v2);
      goto LABEL_15;
    case 3:
      v3 = sub_1000EDD0(v1, v4, 1, v4, v2);
      goto LABEL_15;
    case 6:
      v3 = sub_1000F050((void *)v4, (int)&v19);
      goto LABEL_15;
    case 5:
      v3 = sub_1000F5C0(v4, 1, (int)&v19);
      goto LABEL_15;
    case 7:
      v24 = v24 & 0xFFFFFF05 | 5;
      v25 = 0;
      LOBYTE(v23) = 1;
      v28 = 0;
      goto LABEL_14;
    case 8:
      v24 = v24 & 0xFFFFFF05 | 5;
      v25 = 0;
      LOBYTE(v23) = 0;
      v28 = 1;
      goto LABEL_14;
    case 9:
      v24 &= 0xFFFFFE00u;
      v25 = 0;
      v28 = 3;
LABEL_14:
      v11 = sub_1000FE80(v4);
      sub_10010260(v11, v12, (int)&v23);
      v28 = -1;
      sub_100101D0((int)&v23, 1);
LABEL_15:
      if ( !*(_BYTE *)(v4 + 110) )
        goto LABEL_21;
      *(_DWORD *)(v4 + 76) = *(_DWORD *)(v4 + 72);
      v15 = v10;
      v16 = sub_10013580(v4, (int)&v27);
      v13 = sub_10015510(v16, v17, (int)&v26, v15);
      v14 = *(_DWORD *)v13;
      if ( *(_DWORD *)v13 )
        v14 = *(_DWORD *)v14;
      *(_DWORD *)(v4 + 80) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v14 + 4)
                                                   + 4 * ((*(_DWORD *)(v14 + 8) - 1) & (*(_DWORD *)(v13 + 8) >> 2)))
                                       + 4 * (*(_DWORD *)(v13 + 8) & 3));
      result = v3;
      break;
    default:
      v22 = 15;
      v21 = 0;
      LOBYTE(v20[0]) = 0;
      loc_1000AEB0(v20, "Syntax error: value, object or array expected.", 46);
      v28 = 4;
      v3 = sub_1000FD10((void *)v4, (int *)v20, (int)&v19, 0);
      if ( v22 >= 0x10 )
        sub_1002A4AA(v20[0]);
LABEL_21:
      result = v3;
      break;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1000E2C0) --------------------------------------------------------
char __thiscall sub_1000E2C0(int this, int a2)
{
  int v2; // esi@1
  int v3; // edx@2
  char v4; // al@3
  int v5; // ecx@3
  int v6; // eax@8
  char v7; // cl@9
  char v8; // al@16
  char v9; // zf@20
  int v10; // eax@20
  int v11; // edx@23
  signed int v12; // ecx@24
  char v13; // al@25
  int v14; // edx@28
  signed int v15; // ecx@29
  char v16; // al@30
  int v17; // edx@33
  signed int v18; // ecx@34
  char v19; // al@35

  v2 = this;
  if ( *(_BYTE *)(this + 108) )
  {
    do
    {
      v3 = *(_DWORD *)(v2 + 68);
      if ( *(_DWORD *)(v2 + 72) != v3 )
      {
        do
        {
          v5 = *(_DWORD *)(v2 + 72);
          v4 = *(_BYTE *)v5;
          if ( *(_BYTE *)v5 != 32 && v4 != 9 && v4 != 13 && v4 != 10 )
            break;
          *(_DWORD *)(v2 + 72) = v5 + 1;
        }
        while ( v5 + 1 != v3 );
      }
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(v2 + 72);
      v6 = *(_DWORD *)(v2 + 72);
      if ( v6 == *(_DWORD *)(v2 + 68) )
      {
        v7 = 0;
      }
      else
      {
        v7 = *(_BYTE *)v6;
        *(_DWORD *)(v2 + 72) = v6 + 1;
      }
      switch ( v7 )
      {
        case 123:
          *(_DWORD *)a2 = 1;
          goto LABEL_20;
        case 125:
          *(_DWORD *)a2 = 2;
          goto LABEL_20;
        case 91:
          *(_DWORD *)a2 = 3;
          goto LABEL_20;
        case 93:
          *(_DWORD *)a2 = 4;
          goto LABEL_20;
        case 34:
          *(_DWORD *)a2 = 5;
          v8 = sub_1000EA30(v2);
          goto LABEL_18;
        case 47:
          *(_DWORD *)a2 = 12;
          v8 = sub_1000E800(v2);
LABEL_18:
          if ( !v8 )
            goto LABEL_19;
          goto LABEL_20;
        default:
          goto LABEL_19;
        case 45:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          *(_DWORD *)a2 = 6;
          sub_1000E9F0(v2);
          goto LABEL_20;
        case 116:
          *(_DWORD *)a2 = 7;
          v11 = *(_DWORD *)(v2 + 72);
          if ( *(_DWORD *)(v2 + 68) - v11 < 3 )
            goto LABEL_19;
          v12 = 3;
          while ( 1 )
          {
            v13 = *(_BYTE *)(v11 + v12-- - 1);
            if ( v13 != byte_10067424[v12] )
              goto LABEL_19;
            if ( !v12 )
            {
              *(_DWORD *)(v2 + 72) = v11 + 3;
              goto LABEL_20;
            }
          }
        case 102:
          *(_DWORD *)a2 = 8;
          v14 = *(_DWORD *)(v2 + 72);
          if ( *(_DWORD *)(v2 + 68) - v14 < 4 )
            goto LABEL_19;
          v15 = 4;
          while ( 1 )
          {
            v16 = *(_BYTE *)(v14 + v15-- - 1);
            if ( v16 != byte_10067428[v15] )
              goto LABEL_19;
            if ( !v15 )
            {
              *(_DWORD *)(v2 + 72) = v14 + 4;
              goto LABEL_20;
            }
          }
        case 110:
          *(_DWORD *)a2 = 9;
          v17 = *(_DWORD *)(v2 + 72);
          if ( *(_DWORD *)(v2 + 68) - v17 < 3 )
            goto LABEL_19;
          v18 = 3;
          break;
        case 44:
          *(_DWORD *)a2 = 10;
          goto LABEL_20;
        case 58:
          *(_DWORD *)a2 = 11;
          goto LABEL_20;
        case 0:
          *(_DWORD *)a2 = 0;
          goto LABEL_20;
      }
      do
      {
        v19 = *(_BYTE *)(v17 + v18-- - 1);
        if ( v19 != byte_10067430[v18] )
        {
LABEL_19:
          *(_DWORD *)a2 = 13;
          goto LABEL_20;
        }
      }
      while ( v18 );
      *(_DWORD *)(v2 + 72) = v17 + 3;
LABEL_20:
      v9 = *(_DWORD *)a2 == 12;
      v10 = *(_DWORD *)(v2 + 72);
      *(_DWORD *)(a2 + 8) = v10;
    }
    while ( v9 );
  }
  else
  {
    LOBYTE(v10) = sub_1000E530(this, a2);
  }
  return v10;
}

//----- (1000E530) --------------------------------------------------------
char __thiscall sub_1000E530(int this, int a2)
{
  int v2; // edx@1
  int v3; // esi@1
  char v4; // al@2
  int v5; // ecx@2
  int v6; // eax@7
  char v7; // cl@8
  char v9; // al@15
  int v10; // edx@21
  signed int v11; // ecx@22
  char v12; // al@23
  int v13; // edx@26
  signed int v14; // ecx@27
  char v15; // al@28
  int v16; // edx@31
  signed int v17; // ecx@32
  char v18; // al@33

  v3 = this;
  v2 = *(_DWORD *)(this + 68);
  if ( *(_DWORD *)(this + 72) != v2 )
  {
    do
    {
      v5 = *(_DWORD *)(v3 + 72);
      v4 = *(_BYTE *)v5;
      if ( *(_BYTE *)v5 != 32 && v4 != 9 && v4 != 13 && v4 != 10 )
        break;
      *(_DWORD *)(v3 + 72) = v5 + 1;
    }
    while ( v5 + 1 != v2 );
  }
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(v3 + 72);
  v6 = *(_DWORD *)(v3 + 72);
  if ( v6 == *(_DWORD *)(v3 + 68) )
  {
    v7 = 0;
  }
  else
  {
    v7 = *(_BYTE *)v6;
    *(_DWORD *)(v3 + 72) = v6 + 1;
  }
  switch ( v7 )
  {
    case 123:
      *(_DWORD *)a2 = 1;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 125:
      *(_DWORD *)a2 = 2;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 91:
      *(_DWORD *)a2 = 3;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 93:
      *(_DWORD *)a2 = 4;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 34:
      *(_DWORD *)a2 = 5;
      v9 = sub_1000EA30(v3);
      goto LABEL_17;
    case 47:
      *(_DWORD *)a2 = 12;
      v9 = sub_1000E800(v3);
LABEL_17:
      if ( !v9 )
        goto LABEL_18;
      goto LABEL_19;
    default:
      goto LABEL_18;
    case 45:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      *(_DWORD *)a2 = 6;
      sub_1000E9F0(v3);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 116:
      *(_DWORD *)a2 = 7;
      v10 = *(_DWORD *)(v3 + 72);
      if ( *(_DWORD *)(v3 + 68) - v10 < 3 )
        goto LABEL_18;
      v11 = 3;
      while ( 1 )
      {
        v12 = *(_BYTE *)(v10 + v11-- - 1);
        if ( v12 != byte_10067424[v11] )
          break;
        if ( !v11 )
        {
          *(_DWORD *)(v3 + 72) = v10 + 3;
          *(_DWORD *)(a2 + 8) = v10 + 3;
          return 1;
        }
      }
      goto LABEL_18;
    case 102:
      *(_DWORD *)a2 = 8;
      v13 = *(_DWORD *)(v3 + 72);
      if ( *(_DWORD *)(v3 + 68) - v13 < 4 )
        goto LABEL_18;
      v14 = 4;
      while ( 1 )
      {
        v15 = *(_BYTE *)(v13 + v14-- - 1);
        if ( v15 != byte_10067428[v14] )
          break;
        if ( !v14 )
        {
          *(_DWORD *)(v3 + 72) = v13 + 4;
          *(_DWORD *)(a2 + 8) = v13 + 4;
          return 1;
        }
      }
      goto LABEL_18;
    case 110:
      *(_DWORD *)a2 = 9;
      v16 = *(_DWORD *)(v3 + 72);
      if ( *(_DWORD *)(v3 + 68) - v16 < 3 )
        goto LABEL_18;
      v17 = 3;
      break;
    case 44:
      *(_DWORD *)a2 = 10;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 58:
      *(_DWORD *)a2 = 11;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
    case 0:
      *(_DWORD *)a2 = 0;
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
      return 1;
  }
  while ( 1 )
  {
    v18 = *(_BYTE *)(v16 + v17-- - 1);
    if ( v18 != byte_10067430[v17] )
      break;
    if ( !v17 )
    {
      *(_DWORD *)(v3 + 72) = v16 + 3;
      *(_DWORD *)(a2 + 8) = v16 + 3;
      return 1;
    }
  }
LABEL_18:
  *(_DWORD *)a2 = 13;
LABEL_19:
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(v3 + 72);
  return 1;
}

//----- (1000E800) --------------------------------------------------------
char __thiscall sub_1000E800(int this)
{
  int v1; // eax@1
  int v2; // edx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // eax@2
  char v6; // ch@2
  char v8; // cl@7
  unsigned int v9; // eax@13
  int v10; // ebx@13
  char v11; // [sp+Fh] [bp-1h]@2

  v4 = this;
  v1 = *(_DWORD *)(this + 72);
  v2 = *(_DWORD *)(this + 68);
  v3 = v1 - 1;
  if ( v1 == v2 )
    return 0;
  v6 = *(_BYTE *)v1;
  v5 = v1 + 1;
  v11 = v6;
  *(_DWORD *)(v4 + 72) = v5;
  if ( v6 == 42 )
  {
    if ( !sub_1000E9A0(v4) )
      return 0;
    v6 = v11;
  }
  else
  {
    if ( v6 != 47 )
      return 0;
    if ( v5 != v2 )
    {
      do
      {
        v8 = *(_BYTE *)v5++;
        *(_DWORD *)(v4 + 72) = v5;
      }
      while ( v8 != 13 && v8 != 10 && v5 != v2 );
    }
  }
  if ( *(_BYTE *)(v4 + 110) )
  {
    v9 = *(_DWORD *)(v4 + 76);
    v10 = 0;
    if ( v9 )
    {
      if ( v9 >= v3 )
      {
LABEL_18:
        if ( v6 != 42 || !sub_1000DDD0(v3, *(_DWORD *)(v4 + 72)) )
          v10 = 1;
      }
      else
      {
        while ( *(_BYTE *)v9 != 10 && *(_BYTE *)v9 != 13 )
        {
          ++v9;
          if ( v9 >= v3 )
            goto LABEL_18;
        }
      }
    }
    sub_1000E8B0(v2, v4, v3, v3, *(_DWORD *)(v4 + 72), v10);
  }
  return 1;
}

//----- (1000E8B0) --------------------------------------------------------
int __userpurge sub_1000E8B0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5, int a6)
{
  int v6; // esi@1
  int result; // eax@4
  int v8; // [sp-4h] [bp-50h]@5
  int v9; // [sp+Ch] [bp-40h]@8
  int v10; // [sp+1Ch] [bp-30h]@8
  unsigned int v11; // [sp+20h] [bp-2Ch]@8
  int v12; // [sp+24h] [bp-28h]@2
  int v13; // [sp+34h] [bp-18h]@2
  unsigned int v14; // [sp+38h] [bp-14h]@2
  int v15; // [sp+48h] [bp-4h]@4

  v6 = a2;
  if ( a6 == 1 )
  {
    v14 = 15;
    v13 = 0;
    LOBYTE(v12) = 0;
    if ( a4 != a5 )
      loc_1000AEB0(&v12, a4, a5 - a4);
    v15 = 0;
    result = sub_10011140(a1, *(_DWORD *)(v6 + 80), a3, (int)&v12, 1);
    if ( v14 >= 0x10 )
    {
      v8 = v12;
      return sub_1002A4AA((LPVOID)v8);
    }
  }
  else
  {
    if ( *(_DWORD *)(a2 + 100) )
      loc_10014700(a2 + 84, &unk_10067434, 1);
    v11 = 15;
    v10 = 0;
    LOBYTE(v9) = 0;
    if ( a4 != a5 )
      loc_1000AEB0(&v9, a4, a5 - a4);
    v15 = 1;
    result = loc_10014600(v6 + 84, &v9, 0, -1);
    if ( v11 >= 0x10 )
    {
      v8 = v9;
      return sub_1002A4AA((LPVOID)v8);
    }
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1000E9A0) --------------------------------------------------------
bool __thiscall sub_1000E9A0(int this)
{
  int v1; // eax@1
  int v2; // edx@1
  int v3; // esi@1
  char v4; // cl@2
  int v5; // eax@5
  bool result; // eax@6
  char v7; // cl@7

  v3 = this;
  v1 = *(_DWORD *)(this + 72);
  v2 = *(_DWORD *)(this + 68);
  if ( v1 != v2 )
  {
    do
    {
      v4 = *(_BYTE *)v1++;
      *(_DWORD *)(v3 + 72) = v1;
    }
    while ( (v4 != 42 || *(_BYTE *)v1 != 47) && v1 != v2 );
  }
  v5 = *(_DWORD *)(v3 + 72);
  if ( v5 == v2 )
  {
    result = 0;
  }
  else
  {
    v7 = *(_BYTE *)v5;
    *(_DWORD *)(v3 + 72) = v5 + 1;
    result = v7 == 47;
  }
  return result;
}

//----- (1000E9F0) --------------------------------------------------------
void __thiscall sub_1000E9F0(int this)
{
  int v1; // esi@1
  char v2; // al@2
  int v3; // edx@2

  v1 = *(_DWORD *)(this + 68);
  if ( *(_DWORD *)(this + 72) != v1 )
  {
    do
    {
      v3 = *(_DWORD *)(this + 72);
      v2 = *(_BYTE *)v3;
      if ( (*(_BYTE *)v3 < 48 || v2 > 57) && v2 != 46 && v2 != 101 && v2 != 69 && v2 != 43 && v2 != 45 )
        break;
      *(_DWORD *)(this + 72) = v3 + 1;
    }
    while ( v3 + 1 != v1 );
  }
}

//----- (1000EA30) --------------------------------------------------------
bool __thiscall sub_1000EA30(int this)
{
  int v1; // eax@1
  char i; // dl@1
  int v3; // esi@1
  int v4; // eax@2

  v1 = *(_DWORD *)(this + 72);
  v3 = *(_DWORD *)(this + 68);
  for ( i = 0; v1 != v3; v1 = *(_DWORD *)(this + 72) )
  {
    i = *(_BYTE *)v1;
    v4 = v1 + 1;
    *(_DWORD *)(this + 72) = v4;
    if ( i == 92 )
    {
      if ( v4 != v3 )
        *(_DWORD *)(this + 72) = v4 + 1;
    }
    else
    {
      if ( i == 34 )
        return i == 34;
    }
  }
  return i == 34;
}

//----- (1000EA70) --------------------------------------------------------
char __userpurge sub_1000EA70<al>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // eax@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // eax@4
  int v11; // edi@4
  int v12; // ST08_4@4
  int v13; // eax@4
  int v14; // edx@4
  int v15; // eax@7
  char v16; // cl@7
  int v17; // ecx@13
  char v18; // al@13
  int v19; // ecx@14
  int v20; // eax@16
  int v21; // ST08_4@16
  int v22; // eax@16
  int v23; // edx@16
  int v24; // edi@17
  int v25; // eax@19
  int v26; // edx@19
  int v27; // ecx@19
  char v28; // al@21
  int v29; // ecx@21
  int v30; // ecx@22
  int v31; // eax@26
  char i; // cl@29
  char v33; // bl@34
  int *v35; // eax@40
  char v36; // [sp+10h] [bp-78h]@16
  int v37; // [sp+1Ch] [bp-6Ch]@4
  int v38; // [sp+28h] [bp-60h]@4
  int v39; // [sp+34h] [bp-54h]@6
  int v40; // [sp+40h] [bp-48h]@1
  void *v41; // [sp+44h] [bp-44h]@34
  int v42; // [sp+4Ch] [bp-3Ch]@4
  char v43; // [sp+50h] [bp-38h]@16
  int v44; // [sp+54h] [bp-34h]@1
  unsigned int v45; // [sp+58h] [bp-30h]@1
  void *v46; // [sp+5Ch] [bp-2Ch]@1
  int v47; // [sp+6Ch] [bp-1Ch]@1
  unsigned int v48; // [sp+70h] [bp-18h]@1
  unsigned int v49; // [sp+74h] [bp-14h]@1
  int v50; // [sp+84h] [bp-4h]@1
  int v51; // [sp+88h] [bp+0h]@1

  v49 = (unsigned int)&v51 ^ __security_cookie;
  v9 = a2;
  v48 = 15;
  v47 = 0;
  LOBYTE(v46) = 0;
  v50 = 0;
  v44 = v44 & 0xFFFFFE07 | 7;
  v45 = 0;
  v5 = sub_1002ADB1(a1, a2, a3, a4, 8);
  v8 = v5;
  v40 = v5;
  LOBYTE(v50) = 1;
  if ( v5 )
  {
    *(_DWORD *)v5 = 0;
    *(_DWORD *)(v5 + 4) = 0;
    *(_DWORD *)v5 = sub_100155A0(v6, v7, a3, v5);
  }
  else
  {
    v8 = 0;
  }
  v42 = v8;
  v12 = v7;
  LOBYTE(v50) = 2;
  v13 = sub_10013580(v9, (int)&v38);
  v10 = sub_10015510(v13, v14, (int)&v37, v12);
  v11 = *(_DWORD *)v10;
  if ( *(_DWORD *)v10 )
    v11 = *(_DWORD *)v11;
  sub_10010260(
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v11 + 4) + 4 * ((*(_DWORD *)(v10 + 8) >> 2) & (*(_DWORD *)(v11 + 8) - 1)))
              + 4 * (*(_DWORD *)(v10 + 8) & 3)),
    *(_DWORD *)(v10 + 8) & 3,
    (int)&v42);
  LOBYTE(v50) = 0;
  sub_100101D0((int)&v42, a3);
  if ( sub_1000E530(v9, (int)&v39) )
  {
    while ( 1 )
    {
      v15 = v39;
      v16 = 1;
      if ( v39 == 12 )
      {
        while ( v16 )
        {
          v16 = sub_1000E530(v9, (int)&v39);
          v15 = v39;
          if ( v39 != 12 )
          {
            if ( !v16 )
              goto LABEL_34;
            goto LABEL_11;
          }
        }
        goto LABEL_34;
      }
LABEL_11:
      if ( v15 == 2 )
        break;
      if ( v15 != 5 )
        goto LABEL_34;
      loc_1000AEB0(&v46, &unk_1006723C, 0);
      v18 = loc_1000F6D0(v9, &v39, &v46);
      v17 = v9;
      if ( !v18 )
      {
LABEL_44:
        v33 = sub_1000FDD0(v17, 2);
        goto LABEL_37;
      }
      if ( !sub_1000E530(v9, (int)&v37) || v37 != 11 )
      {
        sub_1000AFB0((int)&v41, "Missing ':' after object member name");
        LOBYTE(v50) = 3;
        v35 = &v37;
LABEL_42:
        v33 = sub_1000FE20((void *)v9, (int *)&v41, (int)v35, 2);
        if ( v45 >= 0x10 )
          sub_1002A4AA(v41);
        goto LABEL_37;
      }
      v21 = v19;
      v22 = sub_10013580(v9, (int)&v43);
      v20 = sub_10015510(v22, v23, (int)&v36, v21);
      if ( *(_DWORD *)v20 )
        v24 = **(_DWORD **)v20;
      else
        v24 = 0;
      v26 = *(_DWORD *)(v20 + 8) & 3;
      v27 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v24 + 4) + 4
                                                         * ((*(_DWORD *)(v20 + 8) >> 2) & (*(_DWORD *)(v24 + 8) - 1)))
                      + 4 * v26);
      v25 = (int)&v46;
      if ( v48 >= 0x10 )
        v25 = (int)v46;
      v40 = sub_10010C90(v27, v26, v25, v27);
      loc_100134C0(v9, &v40);
      v28 = sub_1000E050(v9);
      v29 = *(_DWORD *)(v9 + 16);
      if ( v29 )
      {
        v30 = v29 - 1;
        *(_DWORD *)(v9 + 16) = v30;
        if ( !v30 )
          *(_DWORD *)(v9 + 12) = 0;
      }
      v17 = v9;
      if ( !v28 )
        goto LABEL_44;
      if ( !sub_1000E530(v9, (int)&v38) || (v31 = v38, v38 != 2) && v38 != 10 && v38 != 12 )
      {
        sub_1000AFB0((int)&v41, "Missing ',' or '}' in object declaration");
        LOBYTE(v50) = 4;
        v35 = &v38;
        goto LABEL_42;
      }
      for ( i = 1; v38 == 12; v31 = v38 )
      {
        if ( !i )
          break;
        i = sub_1000E530(v9, (int)&v38);
      }
      if ( v31 == 2 )
        goto LABEL_46;
      if ( !sub_1000E530(v9, (int)&v39) )
        goto LABEL_34;
    }
    if ( v47 )
      goto LABEL_34;
LABEL_46:
    v33 = 1;
  }
  else
  {
LABEL_34:
    v45 = 15;
    v44 = 0;
    LOBYTE(v41) = 0;
    loc_1000AEB0(&v41, "Missing '}' or object member name", 33);
    LOBYTE(v50) = 5;
    v33 = sub_1000FE20((void *)v9, (int *)&v41, (int)&v39, 2);
    if ( v45 >= 0x10 )
      sub_1002A4AA(v41);
    v45 = 15;
    v44 = 0;
    LOBYTE(v41) = 0;
  }
LABEL_37:
  if ( v48 >= 0x10 )
    sub_1002A4AA(v46);
  return v33;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (1000EDD0) --------------------------------------------------------
char __userpurge sub_1000EDD0<al>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // eax@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // eax@4
  int v11; // edi@4
  int v12; // ST08_4@4
  int v13; // eax@4
  int v14; // edx@4
  int v15; // edx@6
  int i; // ecx@6
  char v17; // al@7
  char result; // al@13
  int v19; // ebx@14
  int v20; // eax@15
  int v21; // ST08_4@15
  int v22; // eax@15
  int v23; // edx@15
  int v24; // edi@16
  char v25; // al@18
  int v26; // ecx@18
  int v27; // ecx@19
  char v28; // al@22
  char v29; // dl@27
  char v30; // bl@33
  void *v31; // [sp+10h] [bp-54h]@33
  int v32; // [sp+20h] [bp-44h]@33
  unsigned int v33; // [sp+24h] [bp-40h]@33
  int v34; // [sp+28h] [bp-3Ch]@4
  char v35; // [sp+2Ch] [bp-38h]@15
  int v36; // [sp+30h] [bp-34h]@1
  int v37; // [sp+34h] [bp-30h]@1
  char v38; // [sp+38h] [bp-2Ch]@4
  int v39; // [sp+44h] [bp-20h]@4
  int v40; // [sp+50h] [bp-14h]@1
  int v41; // [sp+60h] [bp-4h]@1

  v9 = a2;
  v36 = v36 & 0xFFFFFE06 | 6;
  v37 = 0;
  v5 = sub_1002ADB1(a1, a2, a3, a4, 8);
  v8 = v5;
  v40 = v5;
  v41 = 0;
  if ( v5 )
  {
    *(_DWORD *)v5 = 0;
    *(_DWORD *)(v5 + 4) = 0;
    *(_DWORD *)v5 = sub_100155A0(v6, v7, a3, v5);
  }
  else
  {
    v8 = 0;
  }
  v34 = v8;
  v12 = v7;
  v41 = 1;
  v13 = sub_10013580(v9, (int)&v38);
  v10 = sub_10015510(v13, v14, (int)&v39, v12);
  v11 = *(_DWORD *)v10;
  if ( *(_DWORD *)v10 )
    v11 = *(_DWORD *)v11;
  sub_10010260(
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v11 + 4) + 4 * ((*(_DWORD *)(v10 + 8) >> 2) & (*(_DWORD *)(v11 + 8) - 1)))
              + 4 * (*(_DWORD *)(v10 + 8) & 3)),
    *(_DWORD *)(v10 + 8) & 3,
    (int)&v34);
  v41 = -1;
  sub_100101D0((int)&v34, a3);
  v15 = *(_DWORD *)(v9 + 68);
  if ( *(_DWORD *)(v9 + 72) != v15 )
  {
    do
    {
      i = *(_DWORD *)(v9 + 72);
      v17 = *(_BYTE *)i;
      if ( *(_BYTE *)i != 32 && v17 != 9 && v17 != 13 && v17 != 10 )
        break;
      *(_DWORD *)(v9 + 72) = i + 1;
    }
    while ( i + 1 != v15 );
  }
  if ( **(_BYTE **)(v9 + 72) == 93 )
  {
    sub_1000E530(v9, (int)&v38);
    result = 1;
  }
  else
  {
    v19 = 0;
    while ( 1 )
    {
      v21 = i;
      v22 = sub_10013580(v9, (int)&v35);
      v20 = sub_10015510(v22, v23, (int)&v38, v21);
      if ( *(_DWORD *)v20 )
        v24 = **(_DWORD **)v20;
      else
        v24 = 0;
      v40 = sub_10010A90(
              *(_DWORD *)(v20 + 8) & 3,
              *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v24 + 4)
                                    + 4 * ((*(_DWORD *)(v20 + 8) >> 2) & (*(_DWORD *)(v24 + 8) - 1)))
                        + 4 * (*(_DWORD *)(v20 + 8) & 3)),
              v24,
              v19++);
      loc_100134C0(v9, &v40);
      v25 = sub_1000E050(v9);
      v26 = *(_DWORD *)(v9 + 16);
      if ( v26 )
      {
        v27 = v26 - 1;
        *(_DWORD *)(v9 + 16) = v27;
        if ( !v27 )
          *(_DWORD *)(v9 + 12) = 0;
      }
      if ( !v25 )
        return sub_1000FDD0(v9, 4);
      v28 = sub_1000E530(v9, (int)&v39);
      for ( i = v39; v39 == 12; i = v39 )
      {
        if ( !v28 )
          break;
        v28 = sub_1000E530(v9, (int)&v39);
      }
      v29 = i == 10 || i == 4 ? 0 : 1;
      if ( !v28 || v29 )
        break;
      if ( i == 4 )
        return 1;
    }
    v33 = 15;
    v32 = 0;
    LOBYTE(v31) = 0;
    loc_1000AEB0(&v31, "Missing ',' or ']' in array declaration", 39);
    v41 = 2;
    v30 = sub_1000FE20((void *)v9, (int *)&v31, (int)&v39, 4);
    if ( v33 >= 0x10 )
      sub_1002A4AA(v31);
    result = v30;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1000F050) --------------------------------------------------------
char __thiscall sub_1000F050(void *this, int a2)
{
  char v2; // al@1
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // ebx@1
  void *v6; // esi@1
  char v7; // al@3
  char result; // al@13
  int v9; // esi@14
  signed int v10; // eax@15
  signed int v11; // edi@15
  int v12; // edx@17
  int v13; // ecx@17
  unsigned int v14; // edi@17
  unsigned __int64 v15; // ST00_8@17
  __int64 v16; // qax@17
  char v17; // al@18
  int v18; // eax@20
  __int64 v19; // qt0@25
  unsigned __int8 v20; // cf@25
  int v21; // edx@25
  unsigned __int8 v22; // cf@25
  int v23; // eax@27
  int v24; // esi@27
  int v25; // edx@27
  int v26; // ST0C_4@27
  int v27; // eax@27
  int v28; // edx@27
  int v29; // eax@30
  char v30; // bl@32
  int v31; // eax@32
  int v32; // eax@32
  int v33; // edx@40
  int v34; // ecx@40
  int v35; // [sp-4h] [bp-80h]@40
  void *v36; // [sp+10h] [bp-6Ch]@30
  int v37; // [sp+18h] [bp-64h]@27
  int v38; // [sp+1Ch] [bp-60h]@27
  int v39; // [sp+20h] [bp-5Ch]@27
  unsigned int v40; // [sp+24h] [bp-58h]@27
  void *v41; // [sp+28h] [bp-54h]@32
  char v42; // [sp+34h] [bp-48h]@27
  int v43; // [sp+38h] [bp-44h]@34
  unsigned int v44; // [sp+3Ch] [bp-40h]@32
  void *v45; // [sp+40h] [bp-3Ch]@32
  char v46; // [sp+4Ch] [bp-30h]@27
  __int64 v47; // [sp+50h] [bp-2Ch]@17
  unsigned int v48; // [sp+58h] [bp-24h]@17
  unsigned int v49; // [sp+5Ch] [bp-20h]@17
  unsigned int v50; // [sp+60h] [bp-1Ch]@17
  void *v51; // [sp+64h] [bp-18h]@1
  char v52; // [sp+6Bh] [bp-11h]@14
  int v53; // [sp+78h] [bp-4h]@27

  v6 = this;
  v51 = this;
  v2 = 0;
  v4 = *(_DWORD *)(a2 + 4);
  v5 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)(a2 + 4);
  if ( v3 == v5 )
    goto LABEL_49;
  do
  {
    v2 = v2 || (v7 = *(_BYTE *)v3, *(_BYTE *)v3 == 46) || v7 == 101 || v7 == 69 || v7 == 43 || v7 == 45 && v3 != v4;
    ++v3;
  }
  while ( v3 != v5 );
  if ( v2 )
  {
    result = sub_1000F380(v6, a2);
  }
  else
  {
LABEL_49:
    v9 = *(_DWORD *)(a2 + 4);
    v52 = *(_BYTE *)v4 == 45;
    if ( v52 )
    {
      v9 = v4 + 1;
      v11 = 0;
      v10 = -2147483648;
    }
    else
    {
      v11 = -1;
      v10 = -1;
    }
    HIDWORD(v15) = v10;
    LODWORD(v15) = v11;
    v16 = sub_10039A60(v15, 0xAu, 0);
    v13 = 10 * v16;
    __asm
    {
      xorps   xmm0, xmm0
      movlpd  [ebp+var_2C], xmm0
    }
    v50 = HIDWORD(v16);
    v12 = v47;
    v48 = v11 - 10 * v16;
    v14 = HIDWORD(v47);
    v49 = v16;
    if ( v9 >= (unsigned int)v5 )
    {
LABEL_26:
      if ( v52 )
      {
        v25 = -v12;
        v39 = v39 & 0xFFFFFF01 | 1;
        v40 = 0;
        v37 = v25;
        v38 = (unsigned __int64)-__PAIR__(v14, v25) >> 32;
        v26 = v13;
        v53 = 3;
        v27 = sub_10013580((int)v51, (int)&v42);
        v23 = sub_10015510(v27, v28, (int)&v46, v26);
        v24 = *(_DWORD *)v23;
        if ( *(_DWORD *)v23 )
          v24 = *(_DWORD *)v24;
        v33 = *(_DWORD *)(v23 + 8) & 3;
        v35 = (int)&v37;
        v34 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v24 + 4)
                                    + 4 * ((*(_DWORD *)(v23 + 8) >> 2) & (*(_DWORD *)(v24 + 8) - 1)))
                        + 4 * v33);
      }
      else
      {
        if ( v14 || (unsigned int)v12 > 0x7FFFFFFF )
        {
          v39 = v39 & 0xFFFFFF02 | 2;
          v40 = 0;
          v37 = v12;
          v38 = v14;
          v53 = 5;
        }
        else
        {
          v39 = v39 & 0xFFFFFF01 | 1;
          v40 = 0;
          v37 = v12;
          v38 = v14;
          v53 = 4;
        }
        v35 = (int)&v37;
        v34 = sub_1000FE80((int)v51);
      }
      sub_10010260(v34, v33, v35);
      v53 = -1;
      sub_100101D0((int)&v37, v5);
      result = 1;
    }
    else
    {
      while ( 1 )
      {
        v17 = *(_BYTE *)v9++;
        if ( v17 < 48 )
          break;
        if ( v17 > 57 )
          break;
        v18 = v17 - 48;
        HIDWORD(v47) = v18;
        if ( v14 >= v50 && (v14 > v50 || v12 >= v49) && (v9 != v5 || v18 > v48) )
          return sub_1000F380(v51, a2);
        HIDWORD(v19) = v14;
        LODWORD(v19) = v12;
        v13 = (unsigned __int64)(4 * v19) >> 32;
        v20 = 4 * v12 >= (unsigned int)-v12;
        v21 = 5 * v12;
        HIDWORD(v19) = v13 + v20 + v14;
        LODWORD(v19) = v21;
        v21 *= 2;
        v22 = HIDWORD(v47) >= (unsigned int)-v21;
        v12 = HIDWORD(v47) + v21;
        v14 = v22 + ((unsigned __int64)(2 * v19) >> 32);
        if ( v9 >= (unsigned int)v5 )
          goto LABEL_26;
      }
      v40 = 15;
      v29 = *(_DWORD *)(a2 + 4);
      v39 = 0;
      LOBYTE(v36) = 0;
      if ( v29 != v5 )
        loc_1000AEB0(&v36, v29, v5 - v29);
      v53 = 0;
      v31 = sub_100155D0((int)&v45, (int)"'", (int)&v36);
      LOBYTE(v53) = 1;
      v32 = sub_10015660((int)&v41, v31, "' is not a number.");
      LOBYTE(v53) = 2;
      v30 = sub_1000FD10(v51, (int *)v32, a2, 0);
      if ( v44 >= 0x10 )
        sub_1002A4AA(v41);
      v44 = 15;
      v43 = 0;
      LOBYTE(v41) = 0;
      if ( HIDWORD(v47) >= 0x10u )
        sub_1002A4AA(v45);
      v47 = 64424509440i64;
      LOBYTE(v45) = 0;
      if ( v40 >= 0x10 )
        sub_1002A4AA(v36);
      result = v30;
    }
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1000F380) --------------------------------------------------------
char __thiscall sub_1000F380(void *this, int a2)
{
  int v2; // eax@1
  int v3; // ecx@1
  int v4; // ebx@1
  int v5; // esi@1
  int v6; // ecx@3
  int v7; // esi@3
  int v8; // eax@6
  int v9; // eax@11
  int v10; // ecx@11
  char v11; // bl@13
  int v12; // eax@13
  int v13; // eax@13
  char result; // al@19
  int v15; // eax@20
  int v16; // esi@20
  int v17; // ST08_4@20
  int v18; // eax@20
  int v19; // edx@20
  char v20; // [sp+Ch] [bp-8Ch]@20
  char v21; // [sp+18h] [bp-80h]@20
  void *v22; // [sp+24h] [bp-74h]@13
  int v23; // [sp+34h] [bp-64h]@15
  unsigned int v24; // [sp+38h] [bp-60h]@13
  __int64 v25; // [sp+3Ch] [bp-5Ch]@1
  void *v26; // [sp+44h] [bp-54h]@5
  __int64 v27; // [sp+4Ch] [bp-4Ch]@20
  int v28; // [sp+54h] [bp-44h]@5
  unsigned int v29; // [sp+58h] [bp-40h]@5
  char v30[8]; // [sp+60h] [bp-38h]@2
  void *v31; // [sp+68h] [bp-30h]@13
  int v32; // [sp+78h] [bp-20h]@17
  unsigned int v33; // [sp+7Ch] [bp-1Ch]@15
  unsigned int v34; // [sp+84h] [bp-14h]@1
  int v35; // [sp+94h] [bp-4h]@13
  int v36; // [sp+98h] [bp+0h]@1

  v34 = (unsigned int)&v36 ^ __security_cookie;
  v4 = (int)this;
  __asm { xorps   xmm0, xmm0 }
  v3 = *(_DWORD *)(a2 + 8);
  v2 = *(_DWORD *)(a2 + 4);
  v5 = *(_DWORD *)(a2 + 8) - v2;
  __asm { movsd   [ebp+var_5C], xmm0 }
  if ( v5 <= 32 )
  {
    sub_10034EE0(v30, (const void *)v2, v5);
    if ( (unsigned int)v5 < 0x21 )
    {
      v30[v5] = 0;
      v7 = sub_10030885(v4, (int)v30, (int)"%lf", (unsigned int)&v25);
      goto LABEL_10;
    }
    v2 = sub_100307AB(v4, a2, v5);
  }
  v29 = 15;
  v28 = 0;
  LOBYTE(v26) = 0;
  if ( v2 == v3 || (loc_1000AEB0(&v26, v2, v3 - v2), v8 = (int)v26, v29 < 0x10) )
    v8 = (int)&v26;
  v7 = sub_10030885(v4, v8, (int)"%lf", (unsigned int)&v25);
  if ( v29 >= 0x10 )
    sub_1002A4AA(v26);
LABEL_10:
  if ( v7 == 1 )
  {
    __asm { movsd   xmm0, [ebp+var_5C] }
    v28 = v28 & 0xFFFFFF03 | 3;
    v29 = 0;
    __asm { movsd   [ebp+var_4C], xmm0 }
    v17 = v6;
    v35 = 3;
    v18 = sub_10013580(v4, (int)&v21);
    v15 = sub_10015510(v18, v19, (int)&v20, v17);
    v16 = *(_DWORD *)v15;
    if ( *(_DWORD *)v15 )
      v16 = *(_DWORD *)v16;
    sub_10010260(
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v16 + 4) + 4 * ((*(_DWORD *)(v15 + 8) >> 2) & (*(_DWORD *)(v16 + 8) - 1)))
                + 4 * (*(_DWORD *)(v15 + 8) & 3)),
      *(_DWORD *)(v15 + 8) & 3,
      (int)&v27);
    v35 = -1;
    sub_100101D0((int)&v27, v4);
    result = 1;
  }
  else
  {
    v9 = *(_DWORD *)(a2 + 8);
    v10 = *(_DWORD *)(a2 + 4);
    v29 = 15;
    v28 = 0;
    LOBYTE(v26) = 0;
    if ( v10 != v9 )
      loc_1000AEB0(&v26, v10, v9 - v10);
    v35 = 0;
    v12 = sub_100155D0((int)&v31, (int)"'", (int)&v26);
    LOBYTE(v35) = 1;
    v13 = sub_10015660((int)&v22, v12, "' is not a number.");
    LOBYTE(v35) = 2;
    v11 = sub_1000FD10((void *)v4, (int *)v13, a2, 0);
    if ( v24 >= 0x10 )
      sub_1002A4AA(v22);
    v24 = 15;
    v23 = 0;
    LOBYTE(v22) = 0;
    if ( v33 >= 0x10 )
      sub_1002A4AA(v31);
    v33 = 15;
    v32 = 0;
    LOBYTE(v31) = 0;
    if ( v29 >= 0x10 )
      sub_1002A4AA(v26);
    result = v11;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;
// 1000F380: using guessed type char var_38[8];

//----- (1000F5C0) --------------------------------------------------------
char __userpurge sub_1000F5C0<al>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v3; // esi@1
  char v4; // bl@2
  int *v5; // ecx@3
  int v6; // eax@5
  int v7; // esi@5
  int v8; // ecx@5
  int v9; // ST08_4@5
  int v10; // eax@5
  int v11; // edx@5
  char v13; // [sp+Ch] [bp-54h]@5
  char v14; // [sp+18h] [bp-48h]@5
  int v15; // [sp+24h] [bp-3Ch]@5
  int v16; // [sp+2Ch] [bp-34h]@5
  int v17; // [sp+30h] [bp-30h]@5
  void *v18; // [sp+34h] [bp-2Ch]@1
  int v19; // [sp+44h] [bp-1Ch]@1
  unsigned int v20; // [sp+48h] [bp-18h]@1
  unsigned int v21; // [sp+4Ch] [bp-14h]@1
  int v22; // [sp+5Ch] [bp-4h]@1
  int v23; // [sp+60h] [bp+0h]@1

  v21 = (unsigned int)&v23 ^ __security_cookie;
  v3 = a1;
  v20 = 15;
  v19 = 0;
  LOBYTE(v18) = 0;
  v22 = 0;
  if ( (unsigned __int8)loc_1000F6D0(a3, &v18, (unsigned int)&v23 ^ __security_cookie) )
  {
    v5 = (int *)&v18;
    if ( v20 >= 0x10 )
      v5 = (int *)v18;
    v16 = v16 & 0xFFFFFF04 | 0x104;
    v17 = 0;
    v15 = loc_1000FED0(v5, v19);
    v9 = v8;
    LOBYTE(v22) = 1;
    v10 = sub_10013580(v3, (int)&v14);
    v6 = sub_10015510(v10, v11, (int)&v13, v9);
    v7 = *(_DWORD *)v6;
    if ( *(_DWORD *)v6 )
      v7 = *(_DWORD *)v7;
    sub_10010260(
      *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 4) + 4 * ((*(_DWORD *)(v6 + 8) >> 2) & (*(_DWORD *)(v7 + 8) - 1)))
                + 4 * (*(_DWORD *)(v6 + 8) & 3)),
      *(_DWORD *)(v6 + 8) & 3,
      (int)&v15);
    LOBYTE(v22) = 0;
    sub_100101D0((int)&v15, a2);
    v4 = 1;
  }
  else
  {
    v4 = 0;
  }
  if ( v20 >= 0x10 )
    sub_1002A4AA(v18);
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (1000FA50) --------------------------------------------------------
char __thiscall sub_1000FA50(void *this, int a2, int *a3, int a4, int a5)
{
  int v5; // edi@1
  int v7; // ecx@5
  char v8; // bl@6
  char v9; // al@7
  int v10; // edx@7
  char v11; // cl@8
  char v12; // bl@12
  char v13; // [sp+10h] [bp-40h]@12
  char v14; // [sp+28h] [bp-28h]@6
  void *v15; // [sp+40h] [bp-10h]@1
  int v16; // [sp+4Ch] [bp-4h]@6

  v15 = this;
  v5 = a5;
  if ( !sub_1000FBC0(this, a2, a3, a4, a5) )
    return 0;
  if ( *(_DWORD *)v5 < 0xD800u || *(_DWORD *)v5 > 0xDBFFu )
    return 1;
  v7 = *a3;
  if ( a4 - *a3 < 6 )
  {
    sub_1000AFB0((int)&v14, "additional six characters expected to parse unicode surrogate pair.");
    v16 = 0;
    v8 = sub_1000FD10(v15, (int *)&v14, a2, *a3);
    sub_10001880((int)&v14);
    return v8;
  }
  v9 = *(_BYTE *)v7;
  v10 = v7 + 1;
  *a3 = v7 + 1;
  if ( v9 == 92 )
  {
    v11 = *(_BYTE *)v10;
    *a3 = v10 + 1;
    if ( v11 == 117 )
    {
      if ( !sub_1000FBC0(v15, a2, a3, a4, (int)&a5) )
        return 0;
      *(_DWORD *)v5 = (a5 & 0x3FF) + (((*(_DWORD *)v5 & 0x3FF) + 64) << 10);
      return 1;
    }
  }
  sub_1000AFB0((int)&v13, "expecting another \\u token to begin the second half of a unicode surrogate pair");
  v16 = 1;
  v12 = sub_1000FD10(v15, (int *)&v13, a2, *a3);
  sub_10001880((int)&v13);
  return v12;
}

//----- (1000FBC0) --------------------------------------------------------
char __thiscall sub_1000FBC0(void *this, int a2, int *a3, int a4, int a5)
{
  void *v5; // esi@1
  char v6; // bl@2
  signed int v7; // edi@4
  int v8; // edx@5
  char v9; // cl@5
  int v10; // eax@6
  int v12; // [sp-4h] [bp-54h]@3
  int v13; // [sp+10h] [bp-40h]@13
  int v14; // [sp+20h] [bp-30h]@13
  unsigned int v15; // [sp+24h] [bp-2Ch]@13
  int v16; // [sp+28h] [bp-28h]@2
  int v17; // [sp+38h] [bp-18h]@2
  unsigned int v18; // [sp+3Ch] [bp-14h]@2
  void *v19; // [sp+40h] [bp-10h]@1
  int v20; // [sp+4Ch] [bp-4h]@2

  v5 = this;
  v19 = this;
  if ( a4 - *a3 < 4 )
  {
    v18 = 15;
    v17 = 0;
    LOBYTE(v16) = 0;
    loc_1000AEB0(&v16, "Bad unicode escape sequence in string: four digits expected.", 60);
    v20 = 0;
    v6 = sub_1000FD10(v5, &v16, a2, *a3);
    if ( v18 >= 0x10 )
    {
      v12 = v16;
      goto LABEL_15;
    }
    return v6;
  }
  v7 = 0;
  *(_DWORD *)a5 = 0;
  while ( 1 )
  {
    v9 = *(_BYTE *)*a3++;
    v8 = 16 * *(_DWORD *)a5;
    *(_DWORD *)a5 = v8;
    if ( (unsigned __int8)(v9 - 48) > 9u )
      break;
    v10 = v9 - 48;
LABEL_11:
    ++v7;
    *(_DWORD *)a5 = v8 + v10;
    if ( v7 >= 4 )
      return 1;
  }
  if ( (unsigned __int8)(v9 - 97) <= 5u )
  {
    v10 = v9 - 87;
    goto LABEL_11;
  }
  if ( (unsigned __int8)(v9 - 65) <= 5u )
  {
    v10 = v9 - 55;
    goto LABEL_11;
  }
  v15 = 15;
  v14 = 0;
  LOBYTE(v13) = 0;
  loc_1000AEB0(&v13, "Bad unicode escape sequence in string: hexadecimal digit expected.", 66);
  v20 = 1;
  v6 = sub_1000FD10(v19, &v13, a2, *a3);
  if ( v15 >= 0x10 )
  {
    v12 = v13;
LABEL_15:
    sub_1002A4AA((LPVOID)v12);
  }
  return v6;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1000FD10) --------------------------------------------------------
char __thiscall sub_1000FD10(void *this, int *a2, int a3, int a4)
{
  int v4; // edx@1
  void *v5; // esi@1
  __int64 v8; // [sp+Ch] [bp-3Ch]@1
  int v9; // [sp+14h] [bp-34h]@1
  void *v10; // [sp+18h] [bp-30h]@1
  int v11; // [sp+28h] [bp-20h]@1
  unsigned int v12; // [sp+2Ch] [bp-1Ch]@1
  int v13; // [sp+30h] [bp-18h]@1
  unsigned int v14; // [sp+34h] [bp-14h]@1
  int v15; // [sp+44h] [bp-4h]@1
  int v16; // [sp+48h] [bp+0h]@1

  v14 = (unsigned int)&v16 ^ __security_cookie;
  v5 = this;
  v4 = (int)a2;
  _EAX = a3;
  v13 = 0;
  v12 = 15;
  v11 = 0;
  LOBYTE(v10) = 0;
  v15 = 0;
  __asm { movq    xmm0, qword ptr [eax] }
  v9 = *(_DWORD *)(a3 + 8);
  __asm { movq    [ebp+var_3C], xmm0 }
  if ( &v10 != (void **)a2 )
    loc_1000AB40(&v10, a2, 0, -1);
  v13 = a4;
  sub_100126C0((int)((char *)v5 + 20), v4, (int)&v8);
  if ( v12 >= 0x10 )
    sub_1002A4AA(v10);
  return 0;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (1000FDD0) --------------------------------------------------------
char __thiscall sub_1000FDD0(int this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v5; // [sp+10h] [bp-Ch]@2

  v3 = this;
  v2 = *(_DWORD *)(this + 36);
  do
  {
    if ( !sub_1000E530(v3, (int)&v5) )
      loc_10012540(v3 + 20, v2);
  }
  while ( v5 != a2 && v5 );
  loc_10012540(v3 + 20, v2);
  return 0;
}

//----- (1000FE20) --------------------------------------------------------
char __thiscall sub_1000FE20(void *this, int *a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  int v7; // [sp+10h] [bp-Ch]@2

  v5 = (int)this;
  sub_1000FD10(this, a2, a3, 0);
  v4 = *(_DWORD *)(v5 + 36);
  do
  {
    if ( !sub_1000E530(v5, (int)&v7) )
      loc_10012540(v5 + 20, v4);
  }
  while ( v7 != a4 && v7 );
  loc_10012540(v5 + 20, v4);
  return 0;
}

//----- (1000FE80) --------------------------------------------------------
int __thiscall sub_1000FE80(int this)
{
  int v1; // eax@1
  int v2; // esi@1
  int v3; // ST08_4@1
  int v4; // eax@1
  int v5; // eax@1
  int v6; // edx@1
  char v8; // [sp+4h] [bp-18h]@1
  char v9; // [sp+10h] [bp-Ch]@1

  v3 = this;
  v4 = sub_10013580(this, (int)&v8);
  v5 = sub_10015510(v4, v6, (int)&v9, v3);
  v2 = v5;
  v1 = *(_DWORD *)v5;
  if ( v1 )
    v1 = *(_DWORD *)v1;
  return *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 4) + 4 * ((*(_DWORD *)(v1 + 8) - 1) & (*(_DWORD *)(v2 + 8) >> 2)))
                   + 4 * (*(_DWORD *)(v2 + 8) & 3));
}

//----- (10010010) --------------------------------------------------------
int __fastcall sub_10010010(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  char v5; // al@1
  int v6; // eax@4
  int v7; // eax@6
  int v8; // esi@6
  int v9; // eax@11
  int v10; // esi@12
  signed int v11; // esi@14
  int v12; // edi@15
  void *v13; // eax@16
  int v14; // eax@16
  int (__stdcall **v16)(char); // [sp+Ch] [bp-24h]@23
  int v17; // [sp+18h] [bp-18h]@6
  int v18; // [sp+1Ch] [bp-14h]@1
  unsigned int v19; // [sp+20h] [bp-10h]@1
  int v20; // [sp+2Ch] [bp-4h]@6
  int v21; // [sp+30h] [bp+0h]@1

  v19 = (unsigned int)&v21 ^ __security_cookie;
  v3 = a1;
  v4 = a3;
  v18 = a3;
  v5 = *(_BYTE *)(a3 + 8);
  *(_BYTE *)(a1 + 8) = v5;
  *(_DWORD *)(a1 + 12) = 0;
  switch ( v5 )
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 5:
      *(_DWORD *)a1 = *(_DWORD *)a3;
      *(_DWORD *)(a1 + 4) = *(_DWORD *)(a3 + 4);
      break;
    case 4:
      a1 = *(_DWORD *)a3;
      if ( *(_DWORD *)a3 )
      {
        v6 = loc_1000FED0(a1, -1);
        *(_DWORD *)(v3 + 8) |= 0x100u;
        *(_DWORD *)v3 = v6;
      }
      else
      {
        *(_DWORD *)v3 = 0;
      }
      break;
    case 6:
    case 7:
      v7 = sub_1002ADB1(a2, a1, a1, a3, 8);
      v8 = v7;
      v17 = v7;
      v20 = 0;
      if ( v7 )
      {
        *(_DWORD *)v7 = 0;
        sub_10013050(a2, v7, v3, a3, *(_DWORD *)a3, a1);
      }
      else
      {
        v8 = 0;
      }
      v20 = -1;
      *(_DWORD *)v3 = v8;
      break;
    default:
      break;
  }
  if ( *(_DWORD *)(a3 + 12) )
  {
    v9 = sub_1002965B(a2, a1, v3, a3, 16);
    v17 = v9;
    v20 = 1;
    if ( v9 )
    {
      v10 = v9 + 4;
      *(_DWORD *)v9 = 3;
      sub_100309FA(v9 + 4, 4, 3, (void (__thiscall *)(_DWORD))sub_100099D0, (int)sub_1000FF60);
    }
    else
    {
      v10 = 0;
    }
    v20 = -1;
    *(_DWORD *)(v3 + 12) = v10;
    v11 = 0;
    while ( 1 )
    {
      v12 = *(_DWORD *)(*(_DWORD *)(v4 + 12) + v11);
      if ( v12 )
      {
        v14 = v11 + *(_DWORD *)(v3 + 12);
        v17 = v14;
        v13 = *(void **)v14;
        if ( v13 )
          sub_100309C2(v3, v13);
        if ( *(_BYTE *)v12 && *(_BYTE *)v12 != 47 )
        {
          v18 = (int)"Comments must start with /";
          sub_1002AEA4((int)&v16, &v18);
          v16 = &off_1005F310;
          sub_100355BB((int)&v16, (int)&unk_1006C92C);
          return v3;
        }
        *(_DWORD *)v17 = loc_1000FED0(v12, -1);
      }
      v11 += 4;
      if ( v11 >= 12 )
        return v3;
      v4 = v18;
    }
  }
  return v3;
}
// 1000FF60: using guessed type int sub_1000FF60();
// 1005F310: using guessed type int (__stdcall *off_1005F310)(char);
// 10073200: using guessed type int __security_cookie;

//----- (100101D0) --------------------------------------------------------
int __usercall sub_100101D0<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // eax@1
  int v3; // esi@1
  void *v4; // edi@3
  int result; // eax@8
  void *v6; // esi@9
  char v7; // [sp+8h] [bp-4h]@4

  v3 = a1;
  v2 = *(_BYTE *)(a1 + 8);
  if ( v2 == 4 )
  {
    if ( *(_DWORD *)(a1 + 8) & 0x100 )
    {
      if ( *(_DWORD *)a1 )
        sub_100309C2(a2, *(LPVOID *)a1);
    }
  }
  else
  {
    if ( (unsigned int)(v2 - 6) <= 1 )
    {
      v4 = *(void **)a1;
      if ( *(_DWORD *)a1 )
      {
        sub_100130F0(v4, (int)&v7, **(_DWORD **)v4, *(_DWORD *)v4);
        sub_1002A4AA(*(LPVOID *)v4);
        sub_1002A4AA(v4);
      }
    }
  }
  result = *(_DWORD *)(v3 + 12);
  if ( result )
  {
    v6 = (void *)(result - 4);
    sub_1002B11F(result, 4, *(_DWORD *)(result - 4), (void (__thiscall *)(_DWORD))sub_1000FF60);
    result = sub_100303A3(v6);
  }
  return result;
}
// 1000FF60: using guessed type int sub_1000FF60();
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (10010260) --------------------------------------------------------
int __fastcall sub_10010260(int a1, int a2, int a3)
{
  int v4; // esi@1
  int v5; // ebx@1
  unsigned __int8 v6; // al@1
  int v7; // ecx@1
  int v8; // edx@1
  int v9; // ebx@1
  int v10; // eax@1
  int v11; // ebx@1
  int v12; // [sp+8h] [bp-14h]@1
  int v13; // [sp+Ch] [bp-10h]@1
  int v14; // [sp+10h] [bp-Ch]@1
  int v15; // [sp+14h] [bp-8h]@1

  v4 = a1;
  v15 = 0;
  sub_10010010((int)&v12, a2, a3);
  v5 = v14;
  v6 = v14 ^ *(_BYTE *)(v4 + 8);
  *(_BYTE *)(v4 + 8) = v14;
  v7 = *(_DWORD *)v4;
  v8 = *(_DWORD *)(v4 + 4);
  v9 = v6 ^ v5;
  *(_DWORD *)v4 = v12;
  *(_DWORD *)(v4 + 4) = v13;
  v13 = v8;
  v12 = v7;
  v10 = *(_DWORD *)(v4 + 8) ^ ((_WORD)v9 ^ (unsigned __int16)*(_DWORD *)(v4 + 8)) & 0x100;
  v11 = ((_WORD)v9 ^ (unsigned __int16)((unsigned __int16)(*(_DWORD *)(v4 + 8) << 23 >> 31) << 8)) & 0x100 ^ v9;
  *(_DWORD *)(v4 + 8) = v10;
  v14 = v11;
  sub_100101D0((int)&v12, v11);
  return v4;
}

//----- (100109A0) --------------------------------------------------------
char __thiscall sub_100109A0(void *_ECX)
{
  char result; // al@3

  switch ( *((_BYTE *)_ECX + 8) )
  {
    case 1:
    case 2:
      if ( *(_QWORD *)_ECX )
        goto LABEL_5;
      goto LABEL_3;
    case 3:
      __asm
      {
        movsd   xmm0, qword ptr [ecx]; jumptable 100109A9 case 3
        ucomisd xmm0, ds:qword_10068450
        lahf
      }
      if ( !__SETP__(_AH & 0x44, 0) )
        goto LABEL_3;
LABEL_5:
      result = 1;
      break;
    case 5:
      result = *(_BYTE *)_ECX;
      break;
    case 4:
      if ( *(_DWORD *)_ECX && **(_BYTE **)_ECX )
        result = 1;
      else
LABEL_3:
        result = 0;
      break;
    case 6:
    case 7:
      result = *(_DWORD *)(*(_DWORD *)_ECX + 4) != 0;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (10010A20) --------------------------------------------------------
int __thiscall sub_10010A20(void *this)
{
  int result; // eax@3
  void *v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  switch ( *((_BYTE *)this + 8) )
  {
    case 6:
      if ( !*(_DWORD *)(*(_DWORD *)this + 4) )
        goto LABEL_5;
      v2 = (void *)**(_DWORD **)this;
      sub_10013460(&v2);
      result = *((_DWORD *)v2 + 5) + 1;
      break;
    case 7:
      result = *(_DWORD *)(*(_DWORD *)this + 4);
      break;
    default:
LABEL_5:
      result = 0;
      break;
  }
  return result;
}

//----- (10010A90) --------------------------------------------------------
int __userpurge sub_10010A90<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4)
{
  void **v4; // ebx@1
  int v5; // eax@2
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // esi@2
  int v9; // eax@6
  int v10; // edx@6
  int v11; // esi@6
  void *v12; // edi@6
  int v13; // eax@7
  int v14; // ecx@8
  unsigned __int8 v15; // cf@9
  char v16; // zf@13
  int result; // eax@17
  int v18; // esi@18
  void *v19; // edi@18
  int v20; // eax@18
  int v21; // [sp+Ch] [bp-44h]@5
  int v22; // [sp+14h] [bp-3Ch]@2
  int v23; // [sp+18h] [bp-38h]@2
  int v24; // [sp+20h] [bp-30h]@2
  LPVOID lpMem; // [sp+24h] [bp-2Ch]@18
  int v26; // [sp+28h] [bp-28h]@18
  char v27; // [sp+2Ch] [bp-24h]@18
  unsigned int v28; // [sp+3Ch] [bp-14h]@1
  int v29; // [sp+4Ch] [bp-4h]@2
  int v30; // [sp+50h] [bp+0h]@1

  v28 = (unsigned int)&v30 ^ __security_cookie;
  v4 = (void **)a2;
  if ( !*(_BYTE *)(a2 + 8) )
  {
    v22 = v22 & 0xFFFFFE06 | 6;
    v23 = 0;
    v5 = sub_1002ADB1(a1, a2, a2, a3, 8);
    v8 = v5;
    v24 = v5;
    v29 = 0;
    if ( v5 )
    {
      *(_DWORD *)v5 = 0;
      *(_DWORD *)(v5 + 4) = 0;
      *(_DWORD *)v5 = sub_100155A0(v6, v7, (int)v4, a3);
    }
    else
    {
      v8 = 0;
    }
    v21 = v8;
    v29 = 1;
    sub_10010260((int)v4, v6, (int)&v21);
    v29 = -1;
    sub_100101D0((int)&v21, (int)v4);
  }
  v22 = 0;
  v23 = a4;
  v29 = 2;
  v12 = *v4;
  v9 = sub_10013250(*v4, (int)&v22);
  v11 = v9;
  if ( v9 == *(_DWORD *)v12 )
    goto LABEL_24;
  v13 = *(_DWORD *)(v9 + 16);
  if ( v13 )
  {
    v14 = 0;
    while ( 1 )
    {
      LOBYTE(v10) = *(_BYTE *)v13;
      v15 = *(_BYTE *)v13 < *(_BYTE *)v14;
      if ( *(_BYTE *)v13 != *(_BYTE *)v14 )
        break;
      if ( !(_BYTE)v10 )
        goto LABEL_13;
      LOBYTE(v10) = *(_BYTE *)(v13 + 1);
      v15 = (_BYTE)v10 < *(_BYTE *)(v14 + 1);
      if ( (_BYTE)v10 != *(_BYTE *)(v14 + 1) )
        break;
      v13 += 2;
      v14 += 2;
      if ( !(_BYTE)v10 )
      {
LABEL_13:
        v16 = 1;
        goto LABEL_16;
      }
    }
    v16 = (-v15 | 1) == 0;
  }
  else
  {
    v16 = *(_DWORD *)(v11 + 20) == a4;
  }
LABEL_16:
  if ( v16 )
  {
    result = v11 + 24;
  }
  else
  {
LABEL_24:
    lpMem = 0;
    v26 = a4;
    LOBYTE(v29) = 3;
    sub_10010010((int)&v27, v10, (int)&unk_10076830);
    LOBYTE(v29) = 4;
    v19 = *v4;
    v20 = sub_100160E0((int)&lpMem);
    sub_100161A0((int)v19, (int)&v24, v11, v20 + 16, v20);
    v18 = v24 + 24;
    LOBYTE(v29) = 5;
    sub_100101D0((int)&v27, (int)v4);
    if ( lpMem )
    {
      if ( v26 == 1 )
        sub_100309C2((int)v4, lpMem);
    }
    result = v18;
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;

//----- (10010C30) --------------------------------------------------------
void __usercall sub_10010C30(int a1<ecx>, int a2<ebx>)
{
  int v2; // esi@1

  v2 = a1;
  sub_100101D0(a1 + 8, a2);
  if ( *(_DWORD *)v2 )
  {
    if ( *(_DWORD *)(v2 + 4) == 1 )
      sub_100309C2(a2, *(LPVOID *)v2);
  }
}

//----- (10010C90) --------------------------------------------------------
int __fastcall sub_10010C90(int a1, int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // eax@2
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // esi@2
  int v9; // eax@6
  int v10; // edx@6
  int v11; // esi@6
  void *v12; // edi@6
  int v13; // eax@7
  int v14; // ecx@8
  unsigned __int8 v15; // cf@9
  char v16; // zf@13
  int result; // eax@17
  void *v18; // eax@19
  int v19; // ebx@21
  int v20; // esi@21
  int v21; // edi@21
  int v22; // eax@21
  int v23; // [sp+Ch] [bp-48h]@5
  int v24; // [sp+14h] [bp-40h]@2
  int v25; // [sp+18h] [bp-3Ch]@2
  int v26; // [sp+20h] [bp-34h]@6
  int v27; // [sp+24h] [bp-30h]@2
  int v28; // [sp+28h] [bp-2Ch]@1
  LPVOID lpMem; // [sp+2Ch] [bp-28h]@21
  int v30; // [sp+30h] [bp-24h]@21
  char v31; // [sp+34h] [bp-20h]@21
  unsigned int v32; // [sp+44h] [bp-10h]@1
  int v33; // [sp+50h] [bp-4h]@2
  int v34; // [sp+54h] [bp+0h]@1

  v32 = (unsigned int)&v34 ^ __security_cookie;
  v4 = a1;
  v28 = a1;
  if ( !*(_BYTE *)(a1 + 8) )
  {
    v24 = v24 & 0xFFFFFE07 | 7;
    v25 = 0;
    v5 = sub_1002ADB1(a2, a1, a3, a1, 8);
    v8 = v5;
    v27 = v5;
    v33 = 0;
    if ( v5 )
    {
      *(_DWORD *)v5 = 0;
      *(_DWORD *)(v5 + 4) = 0;
      *(_DWORD *)v5 = sub_100155A0(v6, v7, a3, v4);
    }
    else
    {
      v8 = 0;
    }
    v23 = v8;
    v33 = 1;
    sub_10010260(v4, v6, (int)&v23);
    v33 = -1;
    sub_100101D0((int)&v23, a3);
  }
  v26 = a3;
  v27 = 2;
  v33 = 2;
  v12 = *(void **)v4;
  v9 = sub_10013250(v12, (int)&v26);
  v11 = v9;
  if ( v9 == *(_DWORD *)v12 )
    goto LABEL_27;
  v13 = *(_DWORD *)(v9 + 16);
  if ( v13 )
  {
    v14 = a3;
    while ( 1 )
    {
      LOBYTE(v10) = *(_BYTE *)v13;
      v15 = *(_BYTE *)v13 < *(_BYTE *)v14;
      if ( *(_BYTE *)v13 != *(_BYTE *)v14 )
        break;
      if ( !(_BYTE)v10 )
        goto LABEL_13;
      LOBYTE(v10) = *(_BYTE *)(v13 + 1);
      v15 = (_BYTE)v10 < *(_BYTE *)(v14 + 1);
      if ( (_BYTE)v10 != *(_BYTE *)(v14 + 1) )
        break;
      v13 += 2;
      v14 += 2;
      if ( !(_BYTE)v10 )
      {
LABEL_13:
        v16 = 1;
        goto LABEL_16;
      }
    }
    v16 = (-v15 | 1) == 0;
  }
  else
  {
    v16 = *(_DWORD *)(v11 + 20) == 2;
  }
LABEL_16:
  if ( v16 )
  {
    result = v11 + 24;
  }
  else
  {
LABEL_27:
    if ( a3 )
      v18 = (void *)loc_1000FED0(a3, -1);
    else
      v18 = 0;
    v19 = 2 - (a3 != 0);
    lpMem = v18;
    v30 = 2 - (a3 != 0);
    LOBYTE(v33) = 3;
    sub_10010010((int)&v31, v10, (int)&unk_10076830);
    LOBYTE(v33) = 4;
    v21 = *(_DWORD *)v28;
    v22 = sub_100160E0((int)&lpMem);
    sub_100161A0(v21, (int)&v28, v11, v22 + 16, v22);
    v20 = v28 + 24;
    LOBYTE(v33) = 5;
    sub_100101D0((int)&v31, v19);
    if ( lpMem )
    {
      if ( v30 == 1 )
        sub_100309C2(v19, lpMem);
    }
    result = v20;
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;

//----- (10010E40) --------------------------------------------------------
int __fastcall sub_10010E40(int a1, int a2, int a3, int a4, int a5)
{
  char v5; // zf@1
  int v6; // eax@2
  int v7; // eax@3
  void *v8; // esi@3
  int v10; // [sp+4h] [bp-10h]@3
  int v11; // [sp+8h] [bp-Ch]@3
  int v12; // [sp+Ch] [bp-8h]@1

  v5 = *(_BYTE *)(a1 + 8) == 0;
  v12 = 0;
  if ( v5
    || (v8 = *(void **)a1, v10 = a4, v11 = 0, v7 = *(_DWORD *)sub_100124C0(v8, (int)&a4, (int)&v10), v7 == *(_DWORD *)v8) )
    v6 = (int)&unk_10076830;
  else
    v6 = v7 + 24;
  if ( (_UNKNOWN *)v6 == &unk_10076830 )
    v6 = a5;
  sub_10010010(a3, a2, v6);
  return a3;
}

//----- (10010EA0) --------------------------------------------------------
int __thiscall sub_10010EA0(void *this, int a2)
{
  void *v2; // edi@1
  char v3; // zf@1
  int result; // eax@2
  unsigned int v5; // eax@3
  unsigned int v6; // ebx@3
  int v7; // edi@7
  int v8; // esi@7
  int v9; // edx@8
  int v10; // ecx@9
  int v11; // ecx@10
  char v12; // al@11
  int *v13; // ecx@13
  int v14; // eax@15
  int v15; // ecx@17
  int v16; // eax@17
  int v17; // eax@34
  int j; // eax@35
  int i; // eax@38
  int v20; // ecx@43
  void *v21; // [sp+10h] [bp-3Ch]@8
  int v22; // [sp+20h] [bp-2Ch]@8
  unsigned int v23; // [sp+24h] [bp-28h]@8
  unsigned int v24; // [sp+28h] [bp-24h]@3
  unsigned int v25; // [sp+2Ch] [bp-20h]@3
  int v26; // [sp+30h] [bp-1Ch]@3
  int v27; // [sp+34h] [bp-18h]@1
  int v28; // [sp+38h] [bp-14h]@10
  int v29; // [sp+48h] [bp-4h]@3

  v2 = this;
  v3 = *((_BYTE *)this + 8) == 0;
  v27 = 0;
  if ( v3 )
  {
    result = a2;
    *(_DWORD *)a2 = 0;
    *(_DWORD *)(a2 + 4) = 0;
    *(_DWORD *)(a2 + 8) = 0;
  }
  else
  {
    v6 = 0;
    v24 = 0;
    v25 = 0;
    v26 = 0;
    v29 = 0;
    v5 = *(_DWORD *)(*(_DWORD *)this + 4);
    if ( v5 )
    {
      if ( v5 > 0xAAAAAAA )
        sub_10029585((int)"vector<T> too long");
      loc_10013A40(&v24, v5);
      v6 = v25;
    }
    v7 = **(_DWORD **)v2;
    v8 = *(_DWORD *)v7;
    while ( v8 != v7 )
    {
      v9 = *(_DWORD *)(v8 + 16);
      v23 = 15;
      v22 = 0;
      LOBYTE(v21) = 0;
      if ( *(_BYTE *)v9 )
      {
        v11 = v9;
        v28 = v9 + 1;
        do
          v12 = *(_BYTE *)v11++;
        while ( v12 );
        v10 = v11 - v28;
      }
      else
      {
        v10 = 0;
      }
      loc_1000AEB0(&v21, v9, v10);
      LOBYTE(v29) = 1;
      if ( (unsigned int)&v21 >= v6 || (v13 = (int *)&v21, v24 > (unsigned int)&v21) )
      {
        if ( v6 == v26 )
        {
          loc_10013AE0(&v24, v13);
          v6 = v25;
        }
        if ( v6 )
        {
          *(_DWORD *)(v6 + 20) = 15;
          *(_DWORD *)(v6 + 16) = 0;
          *(_BYTE *)v6 = 0;
          if ( v23 >= 0x10 )
          {
            *(_DWORD *)v6 = v21;
            v21 = 0;
          }
          else
          {
            if ( v22 != -1 )
              sub_1002A4B0((void *)v6, &v21, v22 + 1);
          }
          *(_DWORD *)(v6 + 16) = v22;
          *(_DWORD *)(v6 + 20) = v23;
          v23 = 15;
          v22 = 0;
          LOBYTE(v21) = 0;
        }
      }
      else
      {
        v14 = (signed int)((char *)&v21 - v24) / 24;
        v28 = (signed int)((char *)&v21 - v24) / 24;
        if ( v6 == v26 )
        {
          loc_10013AE0(
            &v24,
            (signed int)((unsigned __int64)(715827883i64 * (signed int)((char *)&v21 - v24)) >> 32) >> 2,
            (char *)&v21 - v24);
          v6 = v25;
          v14 = v28;
        }
        v16 = 3 * v14;
        v15 = v24 + 8 * v16;
        v28 = v24 + 8 * v16;
        if ( v6 )
        {
          *(_DWORD *)(v6 + 20) = 15;
          *(_DWORD *)(v6 + 16) = 0;
          *(_BYTE *)v6 = 0;
          if ( *(_DWORD *)(v15 + 20) >= 0x10u )
          {
            *(_DWORD *)v6 = *(_DWORD *)v15;
            *(_DWORD *)v15 = 0;
          }
          else
          {
            if ( *(_DWORD *)(v15 + 16) != -1 )
            {
              sub_1002A4B0((void *)v6, (const void *)v15, *(_DWORD *)(v15 + 16) + 1);
              v15 = v28;
            }
          }
          *(_DWORD *)(v6 + 16) = *(_DWORD *)(v15 + 16);
          *(_DWORD *)(v6 + 20) = *(_DWORD *)(v15 + 20);
          *(_DWORD *)(v15 + 20) = 15;
          *(_DWORD *)(v15 + 16) = 0;
          *(_BYTE *)v15 = 0;
        }
      }
      v6 += 24;
      LOBYTE(v29) = 0;
      v25 = v6;
      if ( v23 >= 0x10 )
        sub_1002A4AA(v21);
      if ( !*(_BYTE *)(v8 + 13) )
      {
        v17 = *(_DWORD *)(v8 + 8);
        if ( *(_BYTE *)(v17 + 13) )
        {
          for ( i = *(_DWORD *)(v8 + 4); !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 4) )
          {
            if ( v8 != *(_DWORD *)(i + 8) )
              break;
            v8 = i;
          }
          v8 = i;
        }
        else
        {
          v8 = *(_DWORD *)(v8 + 8);
          for ( j = *(_DWORD *)v17; !*(_BYTE *)(j + 13); j = *(_DWORD *)j )
            v8 = j;
        }
      }
    }
    result = a2;
    *(_DWORD *)a2 = v24;
    v20 = v26;
    *(_DWORD *)(a2 + 4) = v6;
    *(_DWORD *)(a2 + 8) = v20;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10011140) --------------------------------------------------------
int __userpurge sub_10011140<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@4
  int v8; // edi@5

  v5 = a2;
  v6 = a4;
  if ( *(_DWORD *)(a4 + 20) >= 0x10u )
    v6 = *(_DWORD *)a4;
  if ( !*(_DWORD *)(a2 + 12) )
  {
    v7 = sub_1002965B(a1, a2, a2, a3, 16);
    if ( v7 )
    {
      v8 = v7 + 4;
      *(_DWORD *)v7 = 3;
      sub_100309FA(v7 + 4, 4, 3, (void (__thiscall *)(_DWORD))sub_100099D0, (int)sub_1000FF60);
    }
    else
    {
      v8 = 0;
    }
    *(_DWORD *)(v5 + 12) = v8;
  }
  return loc_1000FF70(v6);
}
// 1000FF60: using guessed type int sub_1000FF60();

//----- (100111E0) --------------------------------------------------------
void *__thiscall sub_100111E0(void *this, int a2, unsigned int a3)
{
  int v3; // edx@1
  int v4; // edi@1
  char *v5; // esi@6
  char v6; // al@7
  unsigned __int64 v7; // ST00_8@7
  __int64 v8; // qax@7
  unsigned int v9; // eax@11
  void *v11; // [sp+10h] [bp-2Ch]@1
  int v12; // [sp+14h] [bp-28h]@1
  char v13; // [sp+1Bh] [bp-21h]@4
  char v14; // [sp+34h] [bp-8h]@6
  unsigned int v15; // [sp+38h] [bp-4h]@1
  int v16; // [sp+3Ch] [bp+0h]@1

  v15 = (unsigned int)&v16 ^ __security_cookie;
  v3 = a2;
  v4 = a3;
  v11 = this;
  LOBYTE(v12) = a2;
  if ( (signed int)a3 <= 0 && (signed int)a3 < 0 )
  {
    v3 = -a2;
    v13 = 1;
    v12 = -a2;
    v4 = (unsigned __int64)-__PAIR__(a3, -a2) >> 32;
  }
  else
  {
    v13 = 0;
  }
  v5 = &v14;
  v14 = 0;
  do
  {
    HIDWORD(v7) = v4;
    LODWORD(v7) = v3;
    --v5;
    v8 = sub_10039A60(v7, 0xAu, 0);
    v4 = HIDWORD(v8);
    *v5 = (_BYTE)v12 - 10 * v8 + 48;
    v3 = v8;
    v6 = v4 | v8;
    LOBYTE(v12) = v3;
  }
  while ( v4 | v3 );
  if ( v13 != v6 )
  {
    --v5;
    *v5 = 45;
  }
  *((_DWORD *)v11 + 5) = 15;
  *((_DWORD *)v11 + 4) = 0;
  *(_BYTE *)v11 = 0;
  if ( *v5 )
    v9 = strlen(v5);
  else
    v9 = 0;
  loc_1000AEB0(v11, v5, v9);
  return v11;
}
// 10073200: using guessed type int __security_cookie;

//----- (100112C0) --------------------------------------------------------
void *__thiscall sub_100112C0(void *this, int a2, int a3)
{
  int v3; // edx@1
  int v4; // edi@1
  char *v5; // esi@1
  unsigned int v6; // eax@2
  unsigned __int64 v7; // ST00_8@2
  __int64 v8; // qax@2
  void *v10; // [sp+10h] [bp-28h]@1
  char v11; // [sp+14h] [bp-24h]@1
  char v12; // [sp+30h] [bp-8h]@1
  unsigned int v13; // [sp+34h] [bp-4h]@1
  int v14; // [sp+38h] [bp+0h]@1

  v13 = (unsigned int)&v14 ^ __security_cookie;
  v3 = a2;
  v4 = a3;
  v10 = this;
  v11 = a2;
  v5 = &v12;
  v12 = 0;
  do
  {
    HIDWORD(v7) = v4;
    LODWORD(v7) = v3;
    --v5;
    v8 = sub_10039A60(v7, 0xAu, 0);
    v4 = HIDWORD(v8);
    *v5 = v11 - 10 * v8 + 48;
    v3 = v8;
    v6 = v4 | v8;
    v11 = v3;
  }
  while ( v4 | v3 );
  *((_DWORD *)v10 + 5) = 15;
  *((_DWORD *)v10 + 4) = v6;
  *(_BYTE *)v10 = v6;
  if ( *v5 != (_BYTE)v6 )
    v6 = strlen(v5);
  loc_1000AEB0(v10, v5, v6);
  return v10;
}
// 10073200: using guessed type int __security_cookie;

//----- (10011360) --------------------------------------------------------
int __usercall sub_10011360<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  char *v3; // ecx@1
  int v4; // esi@1
  __int64 v6; // ST0C_8@1
  char v7; // al@2
  char *v8; // eax@3
  char *v9; // edx@5
  char *v10; // ecx@5
  char v11; // al@6
  char *v12; // edx@11
  int v13; // ecx@16
  char v14; // al@19
  char v15; // al@23
  char v16; // al@26
  int v18; // [sp+10h] [bp-28h]@3
  char v19; // [sp+14h] [bp-24h]@1
  char v20; // [sp+15h] [bp-23h]@3
  unsigned int v21; // [sp+34h] [bp-4h]@1
  int v22; // [sp+38h] [bp+0h]@1

  v21 = (unsigned int)&v22 ^ __security_cookie;
  __asm
  {
    movapd  xmm0, xmm1
    movsd   [esp+38h+var_38], xmm0
  }
  v4 = a1;
  sub_10030914(a2, a3, (int)&v19, 0x20u, (int)"%#.16g", v6);
  v3 = &v19;
  do
    v7 = *v3++;
  while ( v7 );
  v8 = (char *)&v18 + v3 - &v20 + 3;
  if ( *v8 == 48 )
  {
    for ( ; v8 > &v19; --v8 )
    {
      if ( *v8 != 48 )
        break;
    }
    v12 = v8;
    if ( v8 >= &v19 )
    {
      while ( *v8 != 46 )
      {
        if ( (unsigned __int8)(*v8 - 48) > 9u )
        {
          *(_DWORD *)(v4 + 20) = 15;
          *(_DWORD *)(v4 + 16) = 0;
          *(_BYTE *)v4 = 0;
          if ( !v19 )
            goto LABEL_16;
          v10 = &v19;
          v9 = &v20;
          do
            v14 = *v10++;
          while ( v14 );
          goto LABEL_27;
        }
        --v8;
        if ( v8 < &v19 )
          goto LABEL_15;
      }
      v12[2] = 0;
      *(_DWORD *)(v4 + 20) = 15;
      *(_DWORD *)(v4 + 16) = 0;
      *(_BYTE *)v4 = 0;
      if ( !v19 )
        goto LABEL_16;
      v10 = &v19;
      v9 = &v20;
      do
        v15 = *v10++;
      while ( v15 );
      goto LABEL_27;
    }
LABEL_15:
    *(_DWORD *)(v4 + 20) = 15;
    *(_DWORD *)(v4 + 16) = 0;
    *(_BYTE *)v4 = 0;
    if ( v19 )
    {
      v10 = &v19;
      v9 = &v20;
      do
        v16 = *v10++;
      while ( v16 );
      goto LABEL_27;
    }
  }
  else
  {
    *(_DWORD *)(v4 + 20) = 15;
    *(_DWORD *)(v4 + 16) = 0;
    *(_BYTE *)v4 = 0;
    if ( v19 )
    {
      v10 = &v19;
      v9 = &v20;
      do
        v11 = *v10++;
      while ( v11 );
LABEL_27:
      v13 = v10 - v9;
      goto LABEL_28;
    }
  }
LABEL_16:
  v13 = 0;
LABEL_28:
  loc_1000AEB0(v4, &v19, v13);
  return v4;
}
// 10073200: using guessed type int __security_cookie;

//----- (100114C0) --------------------------------------------------------
int __fastcall sub_100114C0(int a1, char a2)
{
  const char *v2; // edi@1
  int v3; // esi@1
  int result; // eax@4

  v3 = a1;
  v2 = "true";
  if ( !a2 )
    v2 = "false";
  *(_DWORD *)(a1 + 20) = 15;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)a1 = 0;
  if ( *v2 )
  {
    loc_1000AEB0(a1, v2, strlen(v2));
    result = v3;
  }
  else
  {
    loc_1000AEB0(v2, 0);
    result = v3;
  }
  return result;
}

//----- (10011530) --------------------------------------------------------
int __fastcall sub_10011530(int a1, int a2)
{
  int v2; // ebx@1
  const char *v3; // edi@1
  int v4; // eax@1
  const char *v5; // ecx@2
  char v6; // cf@3
  int v7; // eax@5
  unsigned int v8; // ecx@9
  int *v9; // eax@11
  int v10; // ecx@14
  int v11; // esi@24
  int v12; // edx@24
  int v13; // ST08_4@24
  int v14; // ecx@25
  int v15; // eax@28
  int v16; // eax@30
  int v17; // eax@30
  int v18; // ecx@35
  int v20; // [sp-8h] [bp-10Ch]@14
  unsigned int v21; // [sp-4h] [bp-108h]@1
  void *v22; // [sp+14h] [bp-F0h]@5
  char v23; // [sp+1Ch] [bp-E8h]@30
  int v24; // [sp+24h] [bp-E0h]@5
  unsigned int v25; // [sp+28h] [bp-DCh]@5
  void *v26; // [sp+2Ch] [bp-D8h]@5
  int v27; // [sp+3Ch] [bp-C8h]@7
  unsigned int v28; // [sp+40h] [bp-C4h]@5
  int v29; // [sp+44h] [bp-C0h]@24
  char v30; // [sp+48h] [bp-BCh]@32
  int (__stdcall **v31)(char); // [sp+94h] [bp-70h]@32
  int *v32; // [sp+DCh] [bp-28h]@9
  int v33; // [sp+ECh] [bp-18h]@9
  unsigned int v34; // [sp+F0h] [bp-14h]@9
  unsigned int v35; // [sp+F4h] [bp-10h]@1
  int v36; // [sp+100h] [bp-4h]@5
  int v37; // [sp+104h] [bp+0h]@1

  v35 = (unsigned int)&v37 ^ __security_cookie;
  v21 = (unsigned int)&v37 ^ __security_cookie;
  v3 = (const char *)a2;
  v2 = a1;
  LOBYTE(v4) = sub_10030BA0(a2, (int)&unk_10067880);
  if ( !v4 )
  {
    v5 = v3;
    if ( !*v3 )
    {
LABEL_5:
      v25 = 15;
      v24 = 0;
      LOBYTE(v22) = 0;
      loc_1000AEB0(&v22, &unk_10067888, 1, v21);
      v36 = 0;
      v7 = sub_10015660((int)&v26, (int)&v22, v3);
      LOBYTE(v36) = 1;
      sub_10015660(v2, v7, (const char *)&unk_10067888);
      if ( v28 >= 0x10 )
        sub_1002A4AA(v26);
      v28 = 15;
      v27 = 0;
      LOBYTE(v26) = 0;
      if ( v25 >= 0x10 )
        sub_1002A4AA(v22);
      return v2;
    }
    while ( 1 )
    {
      v6 = (unsigned __int8)(*v5++ - 1) > 0x1Eu;
      if ( 1 != v6 )
        break;
      if ( !*v5 )
        goto LABEL_5;
    }
  }
  v34 = 15;
  v8 = 2 * strlen(v3) + 3;
  v33 = 0;
  LOBYTE(v32) = 0;
  v36 = 2;
  if ( v8 != 15 )
  {
    if ( (unsigned __int8)loc_1000ADF0(&v32, v8, 1) )
    {
      v9 = (int *)&v32;
      if ( v34 >= 0x10 )
        v9 = v32;
      v33 = 0;
      *(_BYTE *)v9 = 0;
    }
  }
  loc_10014700(&v32, &unk_10067888, 1, v21);
  for ( ; *v3; ++v3 )
  {
    LOBYTE(v10) = *v3;
    switch ( *v3 )
    {
      case 34:
        loc_10014700(&v32, &unk_1006788C, 2);
        break;
      case 92:
        loc_10014700(&v32, &unk_10067890, 2);
        break;
      case 8:
        loc_10014700(&v32, &unk_10067894, 2);
        break;
      case 12:
        loc_10014700(&v32, &unk_10067898, 2);
        break;
      case 10:
        loc_10014700(&v32, &unk_1006789C, 2);
        break;
      case 13:
        loc_10014700(&v32, &unk_100678A0, 2);
        break;
      case 9:
        loc_10014700(&v32, &unk_100678A4, 2);
        break;
      default:
        if ( (unsigned __int8)(v10 - 1) > 0x1Eu )
        {
          loc_10012FA0(&v32, 1, v10);
        }
        else
        {
          sub_10011A40((int)&v29, v10);
          sub_100127A0(v12, (int)&v29, v2, v20, v13);
          LOBYTE(v36) = 3;
          v11 = sub_10015700(&v29);
          if ( v11 )
            v14 = v11 + *(_DWORD *)(*(_DWORD *)v11 + 4);
          else
            v14 = 0;
          *(_DWORD *)(v14 + 20) = *(_DWORD *)(v14 + 20) & 0xFFFFF9FF | 0x800;
          if ( v11 )
            v15 = v11 + *(_DWORD *)(*(_DWORD *)v11 + 4);
          else
            v15 = 0;
          *(_DWORD *)(v15 + 20) |= 4u;
          *(_BYTE *)(*(_DWORD *)(*(_DWORD *)v11 + 4) + v11 + 64) = 48;
          v16 = sub_10029664((int)&v23, 4, 0);
          (*(void (__cdecl **)(int, _DWORD, _DWORD))v16)(
            v11 + *(_DWORD *)(*(_DWORD *)v11 + 4),
            *(_DWORD *)(v16 + 8),
            *(_DWORD *)(v16 + 12));
          sub_10012050(*v3);
          v17 = sub_10012870(&v29, (int)&v26);
          LOBYTE(v36) = 4;
          loc_10014600(&v32, v17, 0, -1);
          if ( v28 >= 0x10 )
            sub_1002A4AA(v26);
          LOBYTE(v36) = 2;
          v28 = 15;
          v27 = 0;
          LOBYTE(v26) = 0;
          *(int *)((char *)&v29 + *(_DWORD *)(v29 + 4)) = (int)off_100679AC;
          *(unsigned int *)((char *)&v28 + *(_DWORD *)(v29 + 4)) = *(_DWORD *)(v29 + 4) - 80;
          sub_10012890((int)&v30);
          *(int *)((char *)&v29 + *(_DWORD *)(v29 + 4)) = (int)off_100679B8;
          *(unsigned int *)((char *)&v28 + *(_DWORD *)(v29 + 4)) = *(_DWORD *)(v29 + 4) - 8;
          v31 = &off_10067398;
          sub_100296B7((int)&v31);
        }
        break;
    }
  }
  loc_10014700(&v32, &unk_10067888, 1);
  *(_DWORD *)(v2 + 20) = 15;
  *(_DWORD *)(v2 + 16) = 0;
  *(_BYTE *)v2 = 0;
  v18 = v34;
  if ( v34 >= 0x10 )
  {
    *(_DWORD *)v2 = v32;
  }
  else
  {
    if ( v33 != -1 )
    {
      sub_1002A4B0((void *)v2, &v32, v33 + 1);
      v18 = v34;
    }
  }
  *(_DWORD *)(v2 + 16) = v33;
  *(_DWORD *)(v2 + 20) = v18;
  return v2;
}
// 10012050: using guessed type _DWORD __stdcall sub_10012050(_DWORD);
// 10015700: using guessed type int __thiscall sub_10015700(_DWORD);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067398: using guessed type int (__stdcall *off_10067398)(char);
// 100679AC: using guessed type int (*off_100679AC[6])();
// 100679B8: using guessed type int (*off_100679B8[3])();
// 10073200: using guessed type int __security_cookie;

//----- (10011A40) --------------------------------------------------------
void __thiscall sub_10011A40(int this, int a2)
{
  *(_DWORD *)this = &unk_10067384;
  *(_DWORD *)(this + 120) = 0;
  *(_DWORD *)(this + 124) = 0;
  *(_DWORD *)(this + 128) = 0;
  *(_DWORD *)(this + 136) = 0;
  *(_DWORD *)(this + 140) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 52) = 0;
  *(_DWORD *)(this + 56) = 0;
  *(_DWORD *)(this + 60) = 0;
}

//----- (10011AD0) --------------------------------------------------------
void *__thiscall sub_10011AD0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_1006737C;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1006737C: using guessed type int (__stdcall *off_1006737C)(char);

//----- (10011B00) --------------------------------------------------------
int __thiscall sub_10011B00(void *this, int a2, int a3)
{
  int v4; // esi@1
  int v5; // edi@1

  v4 = (int)this;
  v5 = (int)((char *)this + 4);
  loc_1000AEB0((char *)this + 4, &unk_1006723C, 0);
  sub_10011B70(v4, v5, a3);
  loc_10014700(v5, &unk_10067434, 1);
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  loc_1000AB40(a2, v5, 0, -1);
  return a2;
}

//----- (10011B70) --------------------------------------------------------
int __userpurge sub_10011B70<eax>(int a1<ecx>, int a2<edi>, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // eax@3
  void *v6; // eax@3
  unsigned int v7; // edx@3
  int v8; // eax@4
  void *v9; // eax@4
  int v10; // edx@4
  int v11; // eax@5
  int v12; // eax@6
  char v13; // al@7
  int v14; // eax@7
  int v15; // edi@8
  int v16; // esi@8
  int v17; // eax@12
  int v18; // eax@13
  int v19; // esi@13
  int v20; // ecx@13
  char v21; // zf@13
  int v22; // eax@18
  int v23; // edi@18
  int i; // esi@18
  int v25; // edx@22
  int v26; // eax@24
  const char *v27; // edx@26
  char v28; // zf@28
  unsigned int v29; // ecx@29
  int v30; // eax@32
  int v31; // eax@35
  int v32; // eax@36
  int v33; // edi@36
  char v34; // zf@36
  void *v35; // esi@40
  int v36; // [sp+1Ch] [bp-C4h]@8
  int v37; // [sp+1Ch] [bp-C4h]@18
  int v38; // [sp+20h] [bp-C0h]@1
  int v39; // [sp+24h] [bp-BCh]@18
  int v40; // [sp+28h] [bp-B8h]@18
  int v41; // [sp+2Ch] [bp-B4h]@18
  int v42; // [sp+30h] [bp-B0h]@13
  int v43; // [sp+34h] [bp-ACh]@13
  int v44; // [sp+38h] [bp-A8h]@8
  char v45; // [sp+3Ch] [bp-A4h]@13
  void *v46; // [sp+40h] [bp-A0h]@24
  int v47; // [sp+50h] [bp-90h]@28
  unsigned int v48; // [sp+54h] [bp-8Ch]@24
  char v49; // [sp+88h] [bp-58h]@6
  char v50; // [sp+B8h] [bp-28h]@7
  int v51; // [sp+DCh] [bp-4h]@6
  char v52; // [sp+11Ch] [bp+3Ch]@3
  char v53; // [sp+134h] [bp+54h]@5
  char v54; // [sp+14Ch] [bp+6Ch]@6
  char v55; // [sp+164h] [bp+84h]@4
  char v56; // [sp+17Ch] [bp+9Ch]@7
  int v57; // [sp+1A0h] [bp+C0h]@3

  v4 = a1;
  v38 = a1;
  result = *(_BYTE *)(a3 + 8);
  switch ( result )
  {
    case 0:
      result = sub_10011FE0("null");
      break;
    case 1:
      v5 = loc_100105E0(a3);
      v6 = sub_100111E0(&v52, v5, v7);
      v57 = 0;
      loc_10014600(v4 + 4, v6, 0, -1);
      result = sub_10001880((int)&v52);
      break;
    case 2:
      v8 = loc_10010720(a3);
      v9 = sub_100112C0(&v55, v8, v10);
      v57 = 1;
      loc_10014600(v4 + 4, v9, 0, -1);
      result = sub_10001880((int)&v55);
      break;
    case 3:
      loc_10010890(a3);
      __asm { movapd  xmm1, xmm0 }
      v11 = sub_10011360((int)&v53, a3, a2);
      v57 = 2;
      loc_10014600(v4 + 4, v11, 0, -1);
      result = sub_10001880((int)&v53);
      break;
    case 4:
      v12 = sub_10011530((int)&v49, *(_DWORD *)a3);
      v51 = 3;
      loc_10014600(v4 + 4, v12, 0, -1);
      result = sub_10001880((int)&v54);
      break;
    case 5:
      v13 = sub_100109A0((void *)a3);
      v14 = sub_100114C0((int)&v50, v13);
      v51 = 4;
      loc_10014600(v4 + 4, v14, 0, -1);
      result = sub_10001880((int)&v56);
      break;
    case 6:
      v16 = a1 + 4;
      v36 = a1 + 4;
      sub_10011FE0("[");
      v15 = 0;
      v44 = sub_10010A20((void *)a3);
      if ( v44 > 0 )
      {
        do
        {
          if ( v15 > 0 )
            loc_10014700(v16, ",", 1);
          if ( *(_BYTE *)(a3 + 8) )
          {
            v19 = *(_DWORD *)a3;
            v20 = *(_DWORD *)a3;
            v42 = 0;
            v43 = v15;
            v18 = *(_DWORD *)sub_100124C0((void *)v20, (int)&v45, (int)&v42);
            v21 = v18 == *(_DWORD *)v19;
            v16 = v36;
            if ( v21 )
              v17 = (int)&unk_10076830;
            else
              v17 = v18 + 24;
          }
          else
          {
            v17 = (int)&unk_10076830;
          }
          sub_10011B70(v17);
          ++v15;
        }
        while ( v15 < v44 );
      }
      result = loc_10014700("]");
      break;
    case 7:
      v39 = 0;
      v40 = 0;
      v41 = 0;
      sub_10010EA0((void *)a3, (int)&v39);
      v23 = v4 + 4;
      v51 = 5;
      v37 = v4 + 4;
      sub_10011FE0("{");
      v22 = v39;
      for ( i = v39; i != v40; i += 24 )
      {
        if ( i != v22 )
          loc_10014700(v23, ",", 1);
        if ( *(_DWORD *)(i + 20) < 0x10u )
          v25 = i;
        else
          v25 = *(_DWORD *)i;
        v26 = sub_10011530((int)&v46, v25);
        LOBYTE(v51) = 6;
        loc_10014600(v23, v26, 0, -1);
        LOBYTE(v51) = 5;
        if ( v48 >= 0x10 )
          sub_1002A4AA(v46);
        v27 = ": ";
        if ( !*(_BYTE *)(v38 + 28) )
          v27 = ":";
        v48 = 15;
        v28 = *v27 == 0;
        v47 = 0;
        LOBYTE(v46) = 0;
        if ( v28 )
        {
          v29 = 0;
        }
        else
        {
          v29 = strlen(v27);
          v23 = v37;
        }
        loc_10014700(v23, v27, v29);
        if ( *(_DWORD *)(i + 20) < 0x10u )
          v30 = i;
        else
          v30 = *(_DWORD *)i;
        if ( *(_BYTE *)(a3 + 8) )
        {
          v33 = *(_DWORD *)a3;
          v42 = v30;
          v43 = 0;
          v32 = *(_DWORD *)sub_100124C0((void *)v33, (int)&v45, (int)&v42);
          v34 = v32 == *(_DWORD *)v33;
          v23 = v37;
          if ( v34 )
            v31 = (int)&unk_10076830;
          else
            v31 = v32 + 24;
        }
        else
        {
          v31 = (int)&unk_10076830;
        }
        sub_10011B70(v31);
        v22 = v39;
      }
      result = loc_10014700(v23, "}", 1);
      v35 = (void *)v39;
      if ( v39 )
      {
        sub_10018370(v39, v40);
        result = sub_1002A4AA(v35);
      }
      break;
    default:
      return result;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10011FE0) --------------------------------------------------------
int __stdcall sub_10011FE0(const char *a1)
{
  int result; // eax@2

  if ( *a1 )
    result = loc_10014700(a1, strlen(a1));
  else
    result = loc_10014700(a1, 0);
  return result;
}

//----- (10012020) --------------------------------------------------------
int __thiscall sub_10012020(int this, int a2)
{
  int result; // eax@1
  unsigned int v3; // edx@1
  char v4; // cf@2

  v3 = *(_DWORD *)(this + 16);
  result = a2;
  if ( a2 > v3 )
  {
    result = loc_10012FA0(a2 - v3, 0);
  }
  else
  {
    v4 = *(_DWORD *)(this + 20) < 0x10u;
    *(_DWORD *)(this + 16) = a2;
    if ( !v4 )
      this = *(_DWORD *)this;
    *(_BYTE *)(this + a2) = 0;
  }
  return result;
}

//----- (10012050) --------------------------------------------------------
#error "100121F0: positive sp value has been found (funcsize=125)"

//----- (10012200) --------------------------------------------------------
int __thiscall sub_10012200(void *this, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@4
  int v5; // edx@7
  int v6; // esi@8
  int v7; // eax@15
  int i; // edx@17
  int v9; // eax@18
  int v10; // eax@33
  char v11; // cl@36
  int v12; // ecx@37
  int v13; // ecx@40
  int v14; // esi@62
  int v15; // ecx@65
  int result; // eax@67
  int v17; // [sp+18h] [bp-10h]@1

  v3 = (int)this;
  v17 = a3;
  if ( *(_BYTE *)(a3 + 13) )
    sub_100295B3((int)"invalid map/set<T> iterator");
  sub_10013410(&a3);
  if ( *(_BYTE *)(*(_DWORD *)v17 + 13) )
  {
    v4 = *(_DWORD *)(v17 + 8);
  }
  else
  {
    if ( *(_BYTE *)(*(_DWORD *)(v17 + 8) + 13) )
    {
      v4 = *(_DWORD *)v17;
    }
    else
    {
      v5 = a3;
      v4 = *(_DWORD *)(a3 + 8);
      if ( a3 != v17 )
      {
        *(_DWORD *)(*(_DWORD *)v17 + 4) = a3;
        *(_DWORD *)v5 = *(_DWORD *)v17;
        if ( v5 == *(_DWORD *)(v17 + 8) )
        {
          v6 = v5;
        }
        else
        {
          v6 = *(_DWORD *)(v5 + 4);
          if ( !*(_BYTE *)(v4 + 13) )
            *(_DWORD *)(v4 + 4) = v6;
          *(_DWORD *)v6 = v4;
          *(_DWORD *)(v5 + 8) = *(_DWORD *)(v17 + 8);
          *(_DWORD *)(*(_DWORD *)(v17 + 8) + 4) = v5;
        }
        if ( *(_DWORD *)(*(_DWORD *)v3 + 4) == v17 )
        {
          *(_DWORD *)(*(_DWORD *)v3 + 4) = v5;
        }
        else
        {
          v10 = *(_DWORD *)(v17 + 4);
          if ( *(_DWORD *)v10 == v17 )
            *(_DWORD *)v10 = v5;
          else
            *(_DWORD *)(v10 + 8) = v5;
        }
        *(_DWORD *)(v5 + 4) = *(_DWORD *)(v17 + 4);
        v11 = *(_BYTE *)(v5 + 12);
        *(_BYTE *)(v5 + 12) = *(_BYTE *)(v17 + 12);
        *(_BYTE *)(v17 + 12) = v11;
        goto LABEL_37;
      }
    }
  }
  v6 = *(_DWORD *)(v17 + 4);
  if ( !*(_BYTE *)(v4 + 13) )
    *(_DWORD *)(v4 + 4) = v6;
  if ( *(_DWORD *)(*(_DWORD *)v3 + 4) == v17 )
  {
    *(_DWORD *)(*(_DWORD *)v3 + 4) = v4;
  }
  else
  {
    if ( *(_DWORD *)v6 == v17 )
      *(_DWORD *)v6 = v4;
    else
      *(_DWORD *)(v6 + 8) = v4;
  }
  v7 = *(_DWORD *)v3;
  if ( **(_DWORD **)v3 == v17 )
  {
    if ( *(_BYTE *)(v4 + 13) )
    {
      i = v6;
    }
    else
    {
      v9 = *(_DWORD *)v4;
      for ( i = v4; !*(_BYTE *)(v9 + 13); v9 = *(_DWORD *)v9 )
        i = v9;
      v7 = *(_DWORD *)v3;
    }
    *(_DWORD *)v7 = i;
  }
  if ( *(_DWORD *)(*(_DWORD *)v3 + 8) == v17 )
  {
    if ( *(_BYTE *)(v4 + 13) )
      *(_DWORD *)(*(_DWORD *)v3 + 8) = v6;
    else
      *(_DWORD *)(*(_DWORD *)v3 + 8) = sub_100133F0(v4);
  }
LABEL_37:
  v12 = v17;
  if ( *(_BYTE *)(v17 + 12) != 1 )
    goto LABEL_62;
  if ( v4 == *(_DWORD *)(*(_DWORD *)v3 + 4) )
    goto LABEL_61;
  while ( *(_BYTE *)(v4 + 12) == 1 )
  {
    v13 = *(_DWORD *)v6;
    if ( v4 == *(_DWORD *)v6 )
    {
      v13 = *(_DWORD *)(v6 + 8);
      if ( !*(_BYTE *)(v13 + 12) )
      {
        *(_BYTE *)(v13 + 12) = 1;
        *(_BYTE *)(v6 + 12) = 0;
        sub_100132D0((void *)v3, v6);
        v13 = *(_DWORD *)(v6 + 8);
      }
      if ( *(_BYTE *)(v13 + 13) )
        goto LABEL_55;
      if ( *(_BYTE *)(*(_DWORD *)v13 + 12) != 1 || *(_BYTE *)(*(_DWORD *)(v13 + 8) + 12) != 1 )
      {
        if ( *(_BYTE *)(*(_DWORD *)(v13 + 8) + 12) == 1 )
        {
          *(_BYTE *)(*(_DWORD *)v13 + 12) = 1;
          *(_BYTE *)(v13 + 12) = 0;
          sub_10013330((void *)v3, v13);
          v13 = *(_DWORD *)(v6 + 8);
        }
        *(_BYTE *)(v13 + 12) = *(_BYTE *)(v6 + 12);
        *(_BYTE *)(v6 + 12) = 1;
        *(_BYTE *)(*(_DWORD *)(v13 + 8) + 12) = 1;
        sub_100132D0((void *)v3, v6);
        break;
      }
    }
    else
    {
      if ( !*(_BYTE *)(v13 + 12) )
      {
        *(_BYTE *)(v13 + 12) = 1;
        *(_BYTE *)(v6 + 12) = 0;
        sub_10013330((void *)v3, v6);
        v13 = *(_DWORD *)v6;
      }
      if ( *(_BYTE *)(v13 + 13) )
        goto LABEL_55;
      if ( *(_BYTE *)(*(_DWORD *)(v13 + 8) + 12) != 1 || *(_BYTE *)(*(_DWORD *)v13 + 12) != 1 )
      {
        if ( *(_BYTE *)(*(_DWORD *)v13 + 12) == 1 )
        {
          *(_BYTE *)(*(_DWORD *)(v13 + 8) + 12) = 1;
          *(_BYTE *)(v13 + 12) = 0;
          sub_100132D0((void *)v3, v13);
          v13 = *(_DWORD *)v6;
        }
        *(_BYTE *)(v13 + 12) = *(_BYTE *)(v6 + 12);
        *(_BYTE *)(v6 + 12) = 1;
        *(_BYTE *)(*(_DWORD *)v13 + 12) = 1;
        sub_10013330((void *)v3, v6);
        break;
      }
    }
    *(_BYTE *)(v13 + 12) = 0;
LABEL_55:
    v4 = v6;
    v6 = *(_DWORD *)(v6 + 4);
    if ( v4 == *(_DWORD *)(*(_DWORD *)v3 + 4) )
      break;
  }
  v12 = v17;
LABEL_61:
  *(_BYTE *)(v4 + 12) = 1;
LABEL_62:
  v14 = v12 + 16;
  sub_100101D0(v12 + 24, v3);
  if ( *(_DWORD *)v14 )
  {
    if ( *(_DWORD *)(v14 + 4) == 1 )
      sub_100309C2(v3, *(LPVOID *)v14);
  }
  sub_1002A4AA((LPVOID)v17);
  v15 = *(_DWORD *)(v3 + 4);
  if ( v15 )
    *(_DWORD *)(v3 + 4) = v15 - 1;
  result = a2;
  *(_DWORD *)a2 = a3;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100124C0) --------------------------------------------------------
int __thiscall sub_100124C0(void *this, int a2, int a3)
{
  int v3; // eax@1
  int v4; // esi@1
  void *v5; // esi@1
  int v6; // ecx@2
  int v7; // edx@3
  char v8; // bl@6
  int result; // eax@13
  int v11; // [sp+14h] [bp+Ch]@11

  v5 = this;
  v3 = sub_10013250(this, a3);
  v4 = *(_DWORD *)v5;
  if ( v3 == v4 )
    goto LABEL_16;
  v6 = *(_DWORD *)a3;
  if ( *(_DWORD *)a3 )
  {
    v7 = *(_DWORD *)(v3 + 16);
    while ( *(_BYTE *)v6 == *(_BYTE *)v7 )
    {
      if ( !*(_BYTE *)v6 )
        goto LABEL_8;
      v8 = *(_BYTE *)(v6 + 1);
      if ( v8 != *(_BYTE *)(v7 + 1) )
        break;
      v6 += 2;
      v7 += 2;
      if ( !v8 )
      {
LABEL_8:
        __asm { sets    cl }
        goto LABEL_11;
      }
    }
    __asm { sets    cl }
  }
  else
  {
    _CL = *(_DWORD *)(a3 + 4) < *(_DWORD *)(v3 + 20);
  }
LABEL_11:
  v11 = v3;
  if ( _CL )
LABEL_16:
    v11 = v4;
  result = a2;
  *(_DWORD *)a2 = v11;
  return result;
}

//----- (100126C0) --------------------------------------------------------
int __fastcall sub_100126C0(int a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // ecx@3
  int v5; // ebx@3
  int v6; // eax@3
  int v7; // ecx@3
  int v8; // ecx@4
  int result; // eax@7

  v3 = a1;
  if ( *(_DWORD *)(a1 + 8) <= (unsigned int)(*(_DWORD *)(a1 + 16) + 1) )
    loc_100138D0(a1);
  v6 = *(_DWORD *)(v3 + 16);
  v7 = *(_DWORD *)(v3 + 8) - 1;
  *(_DWORD *)(v3 + 12) &= v7;
  v4 = (*(_DWORD *)(v3 + 12) + v6) & v7;
  v5 = 4 * v4;
  if ( !*(_DWORD *)(4 * v4 + *(_DWORD *)(v3 + 4)) )
  {
    v8 = sub_1002ADB1(a2, v4, v5, v3, 40);
    if ( !v8 )
      sub_10029530();
    *(_DWORD *)(v5 + *(_DWORD *)(v3 + 4)) = v8;
  }
  result = *(_DWORD *)(v3 + 4);
  _EBX = *(_DWORD *)(v5 + result);
  if ( _EBX )
  {
    _ESI = a3;
    __asm
    {
      movq    xmm0, qword ptr [esi]
      movq    qword ptr [ebx], xmm0
    }
    *(_DWORD *)(_EBX + 8) = *(_DWORD *)(a3 + 8);
    *(_DWORD *)(_EBX + 32) = 15;
    *(_DWORD *)(_EBX + 28) = 0;
    *(_BYTE *)(_EBX + 12) = 0;
    loc_1000AB40(a3 + 12, 0, -1);
    result = *(_DWORD *)(a3 + 36);
    *(_DWORD *)(_EBX + 36) = result;
  }
  ++*(_DWORD *)(v3 + 16);
  return result;
}

//----- (100127A0) --------------------------------------------------------
int __userpurge sub_100127A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5)
{
  int ebp0; // ebp@0
  int v7; // edi@1
  int v8; // esi@1
  int v9; // ST04_4@1
  int v10; // edx@1

  v7 = a2;
  *(_DWORD *)a2 = &unk_10067384;
  *(_DWORD *)(a2 + 80) = &off_1006738C;
  v8 = a2 + 4;
  *(_DWORD *)(a2 + *(_DWORD *)(*(_DWORD *)a2 + 4)) = off_100679B8;
  v9 = *(_DWORD *)(*(_DWORD *)a2 + 4);
  *(_DWORD *)(v9 + a2 - 4) = v9 - 8;
  sub_10017C90(a1, v7 + *(_DWORD *)(*(_DWORD *)a2 + 4), a3, v7, a2 + 4, v9);
  *(_DWORD *)(v7 + *(_DWORD *)(*(_DWORD *)v7 + 4)) = off_100679AC;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v7 + 4) + v7 - 4) = *(_DWORD *)(*(_DWORD *)v7 + 4) - 80;
  sub_10014830(v10, v8, a3, ebp0, v7);
  *(_DWORD *)v8 = &off_10067970;
  *(_DWORD *)(v8 + 56) = 0;
  *(_DWORD *)(v8 + 60) = 4;
  return v7;
}
// 1006738C: using guessed type int (__stdcall *off_1006738C)(char);
// 10067970: using guessed type int (__stdcall *off_10067970)(char);
// 100679AC: using guessed type int (*off_100679AC[6])();
// 100679B8: using guessed type int (*off_100679B8[3])();

//----- (10012870) --------------------------------------------------------
int __thiscall sub_10012870(void *this, int a2)
{
  sub_10013B80((int)((char *)this + 4), a2);
  return a2;
}

//----- (10012890) --------------------------------------------------------
int __thiscall sub_10012890(int this)
{
  int v1; // esi@1
  char v2; // zf@1
  int result; // eax@3
  void *v4; // esi@3
  int v5; // eax@5

  v1 = this;
  v2 = (*(_BYTE *)(this + 60) & 1) == 0;
  *(_DWORD *)this = &off_10067970;
  if ( !v2 )
    sub_1002A4AA(**(LPVOID **)(this + 12));
  **(_DWORD **)(v1 + 12) = 0;
  **(_DWORD **)(v1 + 28) = 0;
  **(_DWORD **)(v1 + 44) = 0;
  **(_DWORD **)(v1 + 16) = 0;
  **(_DWORD **)(v1 + 32) = 0;
  result = *(_DWORD *)(v1 + 48);
  *(_DWORD *)result = 0;
  *(_DWORD *)(v1 + 60) &= 0xFFFFFFFEu;
  *(_DWORD *)(v1 + 56) = 0;
  *(_DWORD *)v1 = &off_10067934;
  v4 = *(void **)(v1 + 52);
  if ( v4 )
  {
    if ( *(_DWORD *)v4 )
    {
      v5 = (*(int (**)(void))(**(_DWORD **)v4 + 8))();
      if ( v5 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v5)(v5, 1);
    }
    result = sub_1002A4AA(v4);
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067934: using guessed type int (__stdcall *off_10067934)(char);
// 10067970: using guessed type int (__stdcall *off_10067970)(char);

//----- (10012B20) --------------------------------------------------------
signed int __thiscall sub_10012B20(int this, signed int a2)
{
  unsigned int v2; // esi@1
  signed int result; // eax@7

  v2 = **(_DWORD **)(this + 28);
  if ( !v2 || v2 <= **(_DWORD **)(this + 12) || a2 != -1 && (_BYTE)a2 != *(_BYTE *)(v2 - 1) && *(_BYTE *)(this + 60) & 2 )
  {
    result = -1;
  }
  else
  {
    ++**(_DWORD **)(this + 44);
    --**(_DWORD **)(this + 28);
    if ( a2 == -1 )
    {
      result = 0;
    }
    else
    {
      ***(_BYTE ***)(this + 28) = a2;
      result = a2;
    }
  }
  return result;
}

//----- (10012B80) --------------------------------------------------------
signed int __thiscall sub_10012B80(int this)
{
  unsigned int v1; // edx@1
  unsigned int *v2; // esi@1
  signed int result; // eax@2
  int v4; // edi@3
  unsigned int v5; // eax@6

  v2 = *(unsigned int **)(this + 28);
  v1 = *v2;
  if ( *v2 )
  {
    v4 = *(_DWORD *)(this + 44);
    if ( v1 >= v1 + *(_DWORD *)v4 )
    {
      if ( *(_BYTE *)(this + 60) & 4 || (v5 = **(_DWORD **)(this + 32), !v5) || v5 <= v1 && *(_DWORD *)(this + 56) <= v1 )
      {
        result = -1;
      }
      else
      {
        if ( *(_DWORD *)(this + 56) < v5 )
          *(_DWORD *)(this + 56) = v5;
        *(_DWORD *)v4 = *(_DWORD *)(this + 56) - *v2;
        result = ***(_BYTE ***)(this + 28);
      }
    }
    else
    {
      result = *(_BYTE *)v1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (10012BE0) --------------------------------------------------------
int __thiscall sub_10012BE0(int this, int a2, __int64 a3, int a4, char a5)
{
  unsigned int v5; // eax@1
  unsigned int *v6; // edx@1
  int v7; // ebx@1
  int v8; // esi@5
  int v9; // edi@7
  int v10; // esi@7
  __int64 v11; // qax@7
  int v12; // eax@10
  __int64 v13; // qax@15
  int v14; // ecx@15
  int v15; // ecx@18
  int v16; // edx@20
  int v17; // ecx@20
  unsigned int v18; // edx@22
  __int64 v19; // qax@24
  __int64 v20; // qax@26
  __int64 v21; // qax@31
  int v22; // ecx@31
  int v23; // ecx@34
  int result; // eax@37
  int v25; // [sp+Ch] [bp-4h]@5
  int v26; // [sp+28h] [bp+18h]@19
  unsigned int v27; // [sp+28h] [bp+18h]@22

  v7 = this;
  v6 = *(unsigned int **)(this + 32);
  v5 = *v6;
  if ( *v6 )
  {
    if ( *(_DWORD *)(this + 56) < v5 )
      *(_DWORD *)(this + 56) = v5;
  }
  if ( !(a5 & 1) || (v8 = **(_DWORD **)(this + 28), v25 = v8, !v8) )
  {
    if ( a5 & 2 && (v18 = *v6, v27 = v18, v18) )
    {
      if ( a4 == 2 )
      {
        v19 = *(_DWORD *)(this + 56) - **(_DWORD **)(this + 12);
        v10 = v19 + a3;
        v9 = (unsigned __int64)(v19 + a3) >> 32;
      }
      else
      {
        if ( a4 == 1 )
        {
          v20 = (signed int)(v18 - **(_DWORD **)(this + 12));
          v10 = v20 + a3;
          v9 = (unsigned __int64)(v20 + a3) >> 32;
        }
        else
        {
          if ( a4 )
          {
            v10 = dword_10060648;
            v9 = dword_1006064C;
          }
          else
          {
            v9 = HIDWORD(a3);
            v10 = a3;
          }
        }
      }
      if ( v9 >= 0 )
      {
        v22 = **(_DWORD **)(this + 12);
        v21 = *(_DWORD *)(v7 + 56) - v22;
        if ( v9 <= HIDWORD(v21) )
        {
          if ( v9 < HIDWORD(v21) || (unsigned int)v10 <= (_DWORD)v21 )
          {
            v23 = v10 + v22 - v27;
            **(_DWORD **)(v7 + 48) -= v23;
            **(_DWORD **)(v7 + 32) += v23;
            goto LABEL_37;
          }
        }
      }
    }
    else
    {
      v10 = a3;
      v9 = HIDWORD(a3);
      if ( !a3 )
        goto LABEL_37;
    }
LABEL_36:
    v10 = dword_10060648;
    v9 = dword_1006064C;
    goto LABEL_37;
  }
  if ( a4 != 2 )
  {
    if ( a4 == 1 )
    {
      if ( !(a5 & 2) )
      {
        v12 = v8 - **(_DWORD **)(this + 12);
        v10 = v12 + a3;
        v9 = (unsigned __int64)(v12 + a3) >> 32;
        goto LABEL_14;
      }
    }
    else
    {
      if ( !a4 )
      {
        v9 = HIDWORD(a3);
        v10 = a3;
        goto LABEL_14;
      }
    }
    v10 = dword_10060648;
    v9 = dword_1006064C;
    goto LABEL_14;
  }
  v11 = *(_DWORD *)(this + 56) - **(_DWORD **)(this + 12);
  v10 = v11 + a3;
  v9 = (unsigned __int64)(v11 + a3) >> 32;
LABEL_14:
  if ( v9 < 0
    || (v14 = **(_DWORD **)(this + 12), v13 = *(_DWORD *)(v7 + 56) - v14, v9 > HIDWORD(v13))
    || v9 >= HIDWORD(v13) && (unsigned int)v10 > (_DWORD)v13 )
    goto LABEL_36;
  v15 = v10 + v14 - v25;
  **(_DWORD **)(v7 + 44) -= v15;
  **(_DWORD **)(v7 + 28) += v15;
  if ( a5 & 2 )
  {
    v26 = **(_DWORD **)(v7 + 32);
    if ( v26 )
    {
      v16 = **(_DWORD **)(v7 + 28);
      v17 = v26 + **(_DWORD **)(v7 + 48);
      **(_DWORD **)(v7 + 32) = v16;
      **(_DWORD **)(v7 + 48) = v17 - v16;
    }
  }
LABEL_37:
  result = a2;
  *(_DWORD *)(a2 + 4) = v9;
  *(_DWORD *)a2 = v10;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  return result;
}
// 10060648: using guessed type int dword_10060648;
// 1006064C: using guessed type int dword_1006064C;

//----- (10012DB0) --------------------------------------------------------
int __thiscall sub_10012DB0(int this, int a2, __int64 a3, __int64 a4, int a5, int a6, char a7)
{
  unsigned int v7; // eax@1
  unsigned int *v8; // edx@1
  int v9; // ebx@1
  int v10; // edi@1
  int v11; // esi@1
  int v12; // eax@4
  __int64 v13; // qax@9
  int v14; // ecx@9
  int v15; // ecx@12
  int v16; // edx@14
  int v17; // ecx@14
  __int64 v18; // qax@20
  int v19; // ecx@20
  int v20; // ecx@23
  int result; // eax@26
  int v22; // [sp+Ch] [bp-Ch]@7
  int v23; // [sp+Ch] [bp-Ch]@13

  v11 = a4 + a3;
  v9 = (unsigned __int64)(a4 + a3) >> 32;
  v10 = this;
  v8 = *(unsigned int **)(this + 32);
  v7 = *v8;
  if ( *v8 )
  {
    if ( *(_DWORD *)(this + 56) < v7 )
      *(_DWORD *)(this + 56) = v7;
  }
  v12 = dword_1006064C;
  if ( v11 != dword_10060648 || v9 != dword_1006064C )
  {
    if ( a7 & 1 )
    {
      v22 = **(_DWORD **)(this + 28);
      if ( v22 )
      {
        if ( v9 >= 0 )
        {
          v14 = **(_DWORD **)(this + 12);
          v13 = *(_DWORD *)(v10 + 56) - v14;
          if ( v9 <= HIDWORD(v13) )
          {
            if ( v9 < HIDWORD(v13) || (unsigned int)v11 <= (_DWORD)v13 )
            {
              v15 = v11 + v14 - v22;
              **(_DWORD **)(v10 + 44) -= v15;
              **(_DWORD **)(v10 + 28) += v15;
              if ( a7 & 2 )
              {
                v23 = **(_DWORD **)(v10 + 32);
                if ( v23 )
                {
                  v16 = **(_DWORD **)(v10 + 28);
                  v17 = v23 + **(_DWORD **)(v10 + 48);
                  **(_DWORD **)(v10 + 32) = v16;
                  **(_DWORD **)(v10 + 48) = v17 - v16;
                }
              }
              goto LABEL_26;
            }
          }
        }
        goto LABEL_15;
      }
      v12 = dword_1006064C;
    }
    if ( !(a7 & 2) || !*v8 )
    {
      v9 = v12;
      goto LABEL_25;
    }
    if ( v9 >= 0 )
    {
      v19 = **(_DWORD **)(this + 12);
      v18 = *(_DWORD *)(v10 + 56) - v19;
      if ( v9 <= HIDWORD(v18) )
      {
        if ( v9 < HIDWORD(v18) || (unsigned int)v11 <= (_DWORD)v18 )
        {
          v20 = v11 + v19 - **(_DWORD **)(v10 + 32);
          **(_DWORD **)(v10 + 48) -= v20;
          **(_DWORD **)(v10 + 32) += v20;
          goto LABEL_26;
        }
      }
    }
LABEL_15:
    v9 = dword_1006064C;
LABEL_25:
    v11 = dword_10060648;
  }
LABEL_26:
  result = a2;
  *(_DWORD *)a2 = v11;
  *(_DWORD *)(a2 + 4) = v9;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  return result;
}
// 10060648: using guessed type int dword_10060648;
// 1006064C: using guessed type int dword_1006064C;

//----- (10012F00) --------------------------------------------------------
void *__thiscall sub_10012F00(void *this, char a2)
{
  void *v2; // edi@1
  int v3; // esi@1

  v2 = (char *)this - 80;
  v3 = (int)this;
  *(_DWORD *)(this + *(_DWORD *)(*((_DWORD *)this - 20) + 4) - 80) = off_100679AC;
  *(_DWORD *)(this + *(_DWORD *)(*((_DWORD *)this - 20) + 4) - 84) = *(_DWORD *)(*((_DWORD *)this - 20) + 4) - 80;
  sub_10012890((int)((char *)this - 76));
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v3 - 80) + 4) + v3 - 80) = off_100679B8;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v3 - 80) + 4) + v3 - 84) = *(_DWORD *)(*(_DWORD *)(v3 - 80) + 4) - 8;
  *(_DWORD *)v3 = &off_10067398;
  sub_100296B7(v3);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067398: using guessed type int (__stdcall *off_10067398)(char);
// 100679AC: using guessed type int (*off_100679AC[6])();
// 100679B8: using guessed type int (*off_100679B8[3])();

//----- (10012F70) --------------------------------------------------------
void *__thiscall sub_10012F70(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_10012890(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10013050) --------------------------------------------------------
void *__userpurge sub_10013050<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6)
{
  void *v7; // esi@1
  char v8; // [sp+0h] [bp-28h]@1
  int v9; // [sp+10h] [bp-18h]@1
  int v10; // [sp+14h] [bp-14h]@1
  char *v11; // [sp+18h] [bp-10h]@1
  int v12; // [sp+24h] [bp-4h]@1

  v11 = &v8;
  v7 = (void *)a2;
  v9 = a2;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)a2 = sub_100155A0(a1, a2, a3, a4);
  v12 = 0;
  LOBYTE(v12) = 1;
  LOBYTE(v10) = 0;
  sub_10015AE0(v7, a5, v10);
  return v7;
}

//----- (100130F0) --------------------------------------------------------
int __thiscall sub_100130F0(void *this, int a2, int a3, int a4)
{
  int v4; // eax@1
  void *v5; // edi@1
  int v6; // esi@1
  int result; // eax@3
  int v8; // ecx@3
  int v9; // ecx@5
  int i; // edx@6
  int j; // eax@7
  char v12; // [sp+Ch] [bp-4h]@14

  v4 = a3;
  v5 = this;
  v6 = *(_DWORD *)this;
  if ( a3 != **(_DWORD **)this || a4 != v6 )
  {
    for ( ; a3 != a4; v4 = a3 )
    {
      v9 = v4;
      if ( !*(_BYTE *)(v4 + 13) )
      {
        i = *(_DWORD *)(v4 + 8);
        if ( *(_BYTE *)(i + 13) )
        {
          for ( i = *(_DWORD *)(v4 + 4); !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 4) )
          {
            if ( v4 != *(_DWORD *)(i + 8) )
              break;
            v4 = i;
          }
        }
        else
        {
          for ( j = *(_DWORD *)i; !*(_BYTE *)(j + 13); j = *(_DWORD *)j )
            i = j;
        }
        a3 = i;
      }
      sub_10012200(v5, (int)&v12, v9);
    }
    *(_DWORD *)a2 = v4;
    result = a2;
  }
  else
  {
    sub_100131B0(this, *(_DWORD *)(v6 + 4));
    result = a2;
    *(_DWORD *)(*(_DWORD *)v5 + 4) = *(_DWORD *)v5;
    **(_DWORD **)v5 = *(_DWORD *)v5;
    *(_DWORD *)(*(_DWORD *)v5 + 8) = *(_DWORD *)v5;
    v8 = *(_DWORD *)v5;
    *((_DWORD *)v5 + 1) = 0;
    *(_DWORD *)a2 = *(_DWORD *)v8;
  }
  return result;
}

//----- (100131B0) --------------------------------------------------------
void *__thiscall sub_100131B0(void *this, int a2)
{
  void *result; // eax@1
  int v3; // edi@1
  int i; // esi@1
  void *v5; // [sp+10h] [bp-10h]@1

  result = this;
  v5 = this;
  v3 = a2;
  for ( i = a2; !*(_BYTE *)(i + 13); v3 = i )
  {
    sub_100131B0(result, *(_DWORD *)(i + 8));
    i = *(_DWORD *)i;
    sub_100101D0(v3 + 24, v3 + 16);
    if ( *(_DWORD *)(v3 + 16) )
    {
      if ( *(_DWORD *)(v3 + 20) == 1 )
        sub_100309C2(v3 + 16, *(LPVOID *)(v3 + 16));
    }
    sub_1002A4AA((LPVOID)v3);
    result = v5;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10013250) --------------------------------------------------------
int __thiscall sub_10013250(void *this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v4; // eax@2
  int v5; // ecx@3
  char v6; // dl@6

  v2 = *(_DWORD *)this;
  v3 = *(_DWORD *)(*(_DWORD *)this + 4);
  while ( !*(_BYTE *)(v3 + 13) )
  {
    v4 = *(_DWORD *)(v3 + 16);
    if ( v4 )
    {
      v5 = *(_DWORD *)a2;
      while ( *(_BYTE *)v4 == *(_BYTE *)v5 )
      {
        if ( !*(_BYTE *)v4 )
          goto LABEL_8;
        v6 = *(_BYTE *)(v4 + 1);
        if ( v6 != *(_BYTE *)(v5 + 1) )
          break;
        v4 += 2;
        v5 += 2;
        if ( !v6 )
        {
LABEL_8:
          __asm { sets    al }
          goto LABEL_11;
        }
      }
      __asm { sets    al }
    }
    else
    {
      _AL = *(_DWORD *)(v3 + 20) < *(_DWORD *)(a2 + 4);
    }
LABEL_11:
    if ( _AL )
    {
      v3 = *(_DWORD *)(v3 + 8);
    }
    else
    {
      v2 = v3;
      v3 = *(_DWORD *)v3;
    }
  }
  return v2;
}

//----- (100132D0) --------------------------------------------------------
int __thiscall sub_100132D0(void *this, int a2)
{
  int v2; // esi@1
  int result; // eax@3

  v2 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)v2;
  if ( !*(_BYTE *)(*(_DWORD *)v2 + 13) )
    *(_DWORD *)(*(_DWORD *)v2 + 4) = a2;
  *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
  result = *(_DWORD *)this;
  if ( a2 == *(_DWORD *)(*(_DWORD *)this + 4) )
  {
    *(_DWORD *)(result + 4) = v2;
    *(_DWORD *)v2 = a2;
    *(_DWORD *)(a2 + 4) = v2;
  }
  else
  {
    result = *(_DWORD *)(a2 + 4);
    if ( a2 == *(_DWORD *)result )
    {
      *(_DWORD *)result = v2;
      *(_DWORD *)v2 = a2;
      *(_DWORD *)(a2 + 4) = v2;
    }
    else
    {
      *(_DWORD *)(result + 8) = v2;
      *(_DWORD *)v2 = a2;
      *(_DWORD *)(a2 + 4) = v2;
    }
  }
  return result;
}

//----- (10013330) --------------------------------------------------------
int __thiscall sub_10013330(void *this, int a2)
{
  int v2; // eax@1
  int v3; // esi@1
  int result; // eax@3

  v3 = *(_DWORD *)a2;
  *(_DWORD *)a2 = *(_DWORD *)(*(_DWORD *)a2 + 8);
  v2 = *(_DWORD *)(v3 + 8);
  if ( !*(_BYTE *)(v2 + 13) )
    *(_DWORD *)(v2 + 4) = a2;
  *(_DWORD *)(v3 + 4) = *(_DWORD *)(a2 + 4);
  result = *(_DWORD *)this;
  if ( a2 == *(_DWORD *)(*(_DWORD *)this + 4) )
  {
    *(_DWORD *)(result + 4) = v3;
    *(_DWORD *)(v3 + 8) = a2;
    *(_DWORD *)(a2 + 4) = v3;
  }
  else
  {
    result = *(_DWORD *)(a2 + 4);
    if ( a2 == *(_DWORD *)(result + 8) )
    {
      *(_DWORD *)(result + 8) = v3;
      *(_DWORD *)(v3 + 8) = a2;
      *(_DWORD *)(a2 + 4) = v3;
    }
    else
    {
      *(_DWORD *)result = v3;
      *(_DWORD *)(v3 + 8) = a2;
      *(_DWORD *)(a2 + 4) = v3;
    }
  }
  return result;
}

//----- (10013390) --------------------------------------------------------
char __stdcall sub_10013390(int a1, int a2)
{
  char result; // al@3

  if ( *(_DWORD *)a1 )
  {
    if ( strcmp(*(const char **)a1, *(const char **)a2) )
      __asm { sets    al }
    else
      __asm { sets    al }
  }
  else
  {
    result = *(_DWORD *)(a1 + 4) < *(_DWORD *)(a2 + 4);
  }
  return result;
}

//----- (100133F0) --------------------------------------------------------
int __fastcall sub_100133F0(int a1)
{
  int i; // eax@1

  for ( i = *(_DWORD *)(a1 + 8); !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 8) )
    a1 = i;
  return a1;
}

//----- (10013410) --------------------------------------------------------
void *__thiscall sub_10013410(void *this)
{
  int v1; // eax@1
  void *v2; // edx@1
  int v3; // ecx@2
  int j; // eax@3
  int i; // eax@6

  v2 = this;
  v1 = *(_DWORD *)this;
  if ( *(_BYTE *)(*(_DWORD *)this + 13) )
    return v2;
  v3 = *(_DWORD *)(v1 + 8);
  if ( *(_BYTE *)(v3 + 13) )
  {
    for ( i = *(_DWORD *)(v1 + 4); !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 4) )
    {
      if ( *(_DWORD *)v2 != *(_DWORD *)(i + 8) )
        break;
      *(_DWORD *)v2 = i;
    }
    *(_DWORD *)v2 = i;
    return v2;
  }
  for ( j = *(_DWORD *)v3; !*(_BYTE *)(j + 13); j = *(_DWORD *)j )
    v3 = j;
  *(_DWORD *)v2 = v3;
  return v2;
}

//----- (10013460) --------------------------------------------------------
void *__thiscall sub_10013460(void *this)
{
  int v1; // eax@1
  void *v2; // edx@1
  int i; // ecx@3
  int v5; // eax@4
  int v6; // ecx@5

  v2 = this;
  v1 = *(_DWORD *)this;
  if ( *(_BYTE *)(*(_DWORD *)this + 13) )
  {
    *(_DWORD *)this = *(_DWORD *)(v1 + 8);
    return this;
  }
  i = *(_DWORD *)v1;
  if ( *(_BYTE *)(*(_DWORD *)v1 + 13) )
  {
    for ( i = *(_DWORD *)(v1 + 4); !*(_BYTE *)(i + 13); i = *(_DWORD *)(i + 4) )
    {
      if ( *(_DWORD *)v2 != *(_DWORD *)i )
        break;
      *(_DWORD *)v2 = i;
    }
    if ( *(_BYTE *)(*(_DWORD *)v2 + 13) )
      return v2;
    goto LABEL_11;
  }
  v5 = *(_DWORD *)(i + 8);
  if ( *(_BYTE *)(v5 + 13) )
  {
LABEL_11:
    *(_DWORD *)v2 = i;
    return v2;
  }
  do
  {
    v6 = v5;
    v5 = *(_DWORD *)(v5 + 8);
  }
  while ( !*(_BYTE *)(v5 + 13) );
  *(_DWORD *)v2 = v6;
  return v2;
}

//----- (10013550) --------------------------------------------------------
int __thiscall sub_10013550(int this, int a2)
{
  int result; // eax@1
  int v3; // edx@1

  result = a2;
  v3 = *(_DWORD *)(this + 12);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)a2 = *(_DWORD *)this;
  *(_DWORD *)(a2 + 8) = v3;
  return result;
}

//----- (10013580) --------------------------------------------------------
int __thiscall sub_10013580(int this, int a2)
{
  int result; // eax@1
  int v3; // edx@1

  result = a2;
  v3 = *(_DWORD *)(this + 12) + *(_DWORD *)(this + 16);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)a2 = *(_DWORD *)this;
  *(_DWORD *)(a2 + 8) = v3;
  return result;
}

//----- (100135B0) --------------------------------------------------------
int __userpurge sub_100135B0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int **a5, int a6, int a7, int **a8, int a9, int a10)
{
  int v10; // esi@1
  int v11; // edx@5
  int v12; // edx@9
  int v13; // edi@9
  int v14; // eax@9
  unsigned int v15; // ebx@9
  int v16; // eax@9
  int v17; // edx@18
  int v18; // ebx@20
  char v19; // zf@22
  int v20; // edx@31
  int v21; // ecx@36
  int v22; // ebx@37
  char v23; // zf@39
  int v25; // edi@42
  int v26; // eax@42
  int v27; // edx@42
  char v28; // [sp-28h] [bp-84h]@18
  int v29; // [sp-24h] [bp-80h]@18
  int v30; // [sp-20h] [bp-7Ch]@18
  int **v31; // [sp-1Ch] [bp-78h]@14
  int v32; // [sp-18h] [bp-74h]@14
  int v33; // [sp-14h] [bp-70h]@18
  int v34; // [sp-10h] [bp-6Ch]@1
  int v35; // [sp-Ch] [bp-68h]@1
  int v36; // [sp-8h] [bp-64h]@14
  unsigned int v37; // [sp-4h] [bp-60h]@1
  char v38; // [sp+Ch] [bp-50h]@42
  char v39; // [sp+18h] [bp-44h]@9
  int v40; // [sp+24h] [bp-38h]@1
  char v41; // [sp+28h] [bp-34h]@12
  int ****v42; // [sp+2Ch] [bp-30h]@5
  int v43; // [sp+34h] [bp-28h]@9
  int **v44; // [sp+38h] [bp-24h]@9
  int v45; // [sp+40h] [bp-1Ch]@9
  int v46; // [sp+44h] [bp-18h]@3
  char v47; // [sp+48h] [bp-14h]@16
  unsigned int v48; // [sp+4Ch] [bp-10h]@1
  int v49; // [sp+58h] [bp-4h]@14
  int v50; // [sp+5Ch] [bp+0h]@1

  v48 = (unsigned int)&v50 ^ __security_cookie;
  v37 = (unsigned int)&v50 ^ __security_cookie;
  v10 = a2;
  v40 = a4;
  v34 = 0;
  v35 = 0;
  if ( a5 )
  {
    if ( *a5 )
    {
      v34 = **a5;
    }
    else
    {
      sub_10029A76(a1, (int)&v46, a3, (int)&v34, 3);
      sub_10029AD2(&v46);
    }
  }
  sub_10014A40(a1, v10, a3, (int)&v42, v34, v35, a7);
  v34 = 0;
  v35 = 0;
  if ( a8 )
  {
    if ( *a8 )
    {
      v34 = **a8;
    }
    else
    {
      sub_10029A76(v11, (int)&v46, a3, (int)&v34, 3);
      sub_10029AD2(&v46);
    }
  }
  sub_10014A40(v11, v10, a3, (int)&v44, v34, v35, a10);
  v14 = sub_10013550(v10, (int)&v39);
  v13 = v45 - v43;
  v46 = v43 - *(_DWORD *)(v14 + 8);
  v15 = v46;
  v16 = sub_10013580(v10, (int)&v39);
  LOBYTE(v16) = v15 < *(_DWORD *)(v16 + 8) - v45;
  v34 = 0;
  v35 = 0;
  if ( (_BYTE)v16 )
  {
    if ( v44 )
    {
      if ( *v44 )
      {
        v34 = **v44;
      }
      else
      {
        sub_10029A76(v12, (int)&v41, (int)&v34, v13, 3);
        sub_10029AD2(&v41);
      }
    }
    v36 = v45;
    v49 = 0;
    v31 = 0;
    v32 = 0;
    if ( v42 )
    {
      if ( *v42 )
      {
        v31 = **v42;
      }
      else
      {
        sub_10029A76(v12, (int)&v47, (int)&v31, v13, 3);
        sub_10029AD2(&v47);
      }
    }
    v33 = v43;
    sub_10013550(v10, (int)&v28);
    v49 = -1;
    sub_10015B60(v17, (int)&v39, (int)&v31, *(int ***)&v28, v29, v30, v31, v32, v33, (int **)v34, v35, v36);
    for ( ; v13; --v13 )
    {
      if ( *(_DWORD *)(v10 + 16) )
      {
        v18 = *(_DWORD *)(*(_DWORD *)(v10 + 4) + 4 * (*(_DWORD *)(v10 + 12) & (*(_DWORD *)(v10 + 8) - 1)));
        if ( *(_DWORD *)(v18 + 32) >= 0x10u )
        {
          v36 = *(_DWORD *)(v18 + 12);
          sub_1002A4AA((LPVOID)v36);
        }
        *(_DWORD *)(v18 + 32) = 15;
        *(_DWORD *)(v18 + 28) = 0;
        *(_BYTE *)(v18 + 12) = 0;
        v19 = *(_DWORD *)(v10 + 16)-- == 1;
        if ( v19 )
          *(_DWORD *)(v10 + 12) = 0;
        else
          ++*(_DWORD *)(v10 + 12);
      }
    }
  }
  else
  {
    if ( v42 )
    {
      if ( *v42 )
      {
        v34 = (int)**v42;
      }
      else
      {
        sub_10029A76(v12, (int)&v47, (int)&v34, v13, 3);
        sub_10029AD2(&v47);
      }
    }
    v36 = v43;
    v49 = 1;
    sub_10013580(v10, (int)&v31);
    LOBYTE(v49) = 2;
    *(_DWORD *)&v28 = 0;
    v29 = 0;
    if ( v44 )
    {
      if ( *v44 )
      {
        *(_DWORD *)&v28 = **v44;
      }
      else
      {
        sub_10029A76(v20, (int)&v47, (int)&v28, v13, 3);
        sub_10029AD2(&v47);
      }
    }
    v49 = -1;
    sub_10015C80(v20, (int)&v39, (int)&v28, *(int ***)&v28, v29, v45, v31, v32, v33, (int **)v34, v35, v36);
    for ( ; v13; --v13 )
    {
      v21 = *(_DWORD *)(v10 + 16);
      if ( v21 )
      {
        v22 = *(_DWORD *)(*(_DWORD *)(v10 + 4) + 4 * ((v21 - 1 + *(_DWORD *)(v10 + 12)) & (*(_DWORD *)(v10 + 8) - 1)));
        if ( *(_DWORD *)(v22 + 32) >= 0x10u )
        {
          v36 = *(_DWORD *)(v22 + 12);
          sub_1002A4AA((LPVOID)v36);
        }
        *(_DWORD *)(v22 + 32) = 15;
        *(_DWORD *)(v22 + 28) = 0;
        *(_BYTE *)(v22 + 12) = 0;
        v23 = *(_DWORD *)(v10 + 16)-- == 1;
        if ( v23 )
          *(_DWORD *)(v10 + 12) = 0;
      }
    }
  }
  v36 = v46;
  v25 = v40;
  v35 = v40;
  v26 = sub_10013550(v10, (int)&v38);
  sub_10014540(v26, v27, v35, v36);
  return v25;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10013B80) --------------------------------------------------------
int __thiscall sub_10013B80(int this, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  unsigned int v4; // eax@2
  unsigned int v5; // ecx@3
  int v6; // ST08_4@5
  int v7; // ST04_4@5
  int v9; // eax@8
  int v10; // ST08_4@9
  int v11; // ST04_4@9
  int v12; // ecx@11
  void *v13; // [sp+Ch] [bp-20h]@5
  int v14; // [sp+1Ch] [bp-10h]@5
  unsigned int v15; // [sp+20h] [bp-Ch]@5
  unsigned int v16; // [sp+24h] [bp-8h]@1
  int v17; // [sp+2Ch] [bp+0h]@1

  v16 = (unsigned int)&v17 ^ __security_cookie;
  v2 = this;
  v3 = *(_DWORD *)(this + 60);
  if ( v3 & 2 || (v4 = **(_DWORD **)(v2 + 32), !v4) )
  {
    if ( v3 & 4 || (v9 = *(_DWORD *)(v2 + 28), !*(_DWORD *)v9) )
    {
      v15 = 15;
      v14 = 0;
      LOBYTE(v13) = 0;
      *(_DWORD *)(a2 + 20) = 15;
      *(_DWORD *)(a2 + 16) = 0;
      *(_BYTE *)a2 = 0;
      v12 = v15;
      if ( v15 >= 0x10 )
      {
        *(_DWORD *)a2 = v13;
      }
      else
      {
        if ( v14 != -1 )
        {
          sub_1002A4B0((void *)a2, &v13, v14 + 1);
          v12 = v15;
        }
      }
      *(_DWORD *)(a2 + 16) = v14;
      *(_DWORD *)(a2 + 20) = v12;
    }
    else
    {
      v10 = *(_DWORD *)v9 + **(_DWORD **)(v2 + 44) - **(_DWORD **)(v2 + 12);
      v11 = **(_DWORD **)(v2 + 12);
      v15 = 15;
      v14 = 0;
      LOBYTE(v13) = 0;
      loc_1000AEB0(&v13, v11, v10);
      sub_10001810(a2, (int)&v13);
      if ( v15 >= 0x10 )
      {
        sub_1002A4AA(v13);
        return a2;
      }
    }
  }
  else
  {
    v5 = *(_DWORD *)(v2 + 56);
    if ( v5 < v4 )
      v5 = **(_DWORD **)(v2 + 32);
    v6 = v5 - **(_DWORD **)(v2 + 16);
    v7 = **(_DWORD **)(v2 + 16);
    v15 = 15;
    v14 = 0;
    LOBYTE(v13) = 0;
    loc_1000AEB0(&v13, v7, v6);
    sub_10001810(a2, (int)&v13);
    if ( v15 >= 0x10 )
    {
      sub_1002A4AA(v13);
      return a2;
    }
  }
  return a2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10013CE0) --------------------------------------------------------
int __userpurge sub_10013CE0<eax>(int a1<ecx>, int a2<edi>, int a3, int a4, int a5, int a6, char a7, unsigned __int8 a8)
{
  char v8; // zf@1
  void *v9; // edi@3
  int v10; // eax@3
  int v11; // eax@3
  int v12; // edx@3
  int v13; // eax@4
  int v14; // eax@7
  int v15; // ecx@11
  unsigned int v16; // edi@14
  int v17; // edi@15
  int v18; // eax@18
  int v19; // edx@18
  int v20; // eax@18
  unsigned __int8 *v21; // eax@20
  int v22; // eax@22
  unsigned __int8 v23; // ST10_1@22
  int v24; // ST08_4@22
  int v25; // ST00_4@22
  int v27; // [sp+10h] [bp-54h]@1
  int v28; // [sp+14h] [bp-50h]@1
  int v29; // [sp+18h] [bp-4Ch]@3
  void *v30; // [sp+20h] [bp-44h]@7
  unsigned int v31; // [sp+34h] [bp-30h]@9
  void *v32; // [sp+38h] [bp-2Ch]@6
  unsigned int v33; // [sp+48h] [bp-1Ch]@6
  unsigned int v34; // [sp+4Ch] [bp-18h]@6
  unsigned int v35; // [sp+50h] [bp-14h]@1
  int v36; // [sp+60h] [bp-4h]@3
  int v37; // [sp+74h] [bp+10h]@22

  v35 = (unsigned int)&v27 ^ __security_cookie;
  v28 = a1;
  v8 = (*(_DWORD *)(a6 + 20) & 0x4000) == 0;
  LOBYTE(v27) = a7;
  if ( v8 )
  {
    (*(void (__stdcall **)(int, int, int, int, int, _DWORD))(*(_DWORD *)a1 + 36))(a3, a4, a5, a6, v27, a8);
  }
  else
  {
    v10 = sub_10017D70(a6, (int)&v29);
    v36 = 0;
    v11 = sub_100171B0(v12, a3, a2, v10);
    v36 = -1;
    v9 = (void *)v11;
    if ( v29 )
    {
      v13 = (*(int (**)(void))(*(_DWORD *)v29 + 8))();
      if ( v13 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v13)(v13, 1);
    }
    v34 = 15;
    v33 = 0;
    LOBYTE(v32) = 0;
    v36 = 1;
    if ( a8 )
      v14 = sub_10016D30(v9, (int)&v30);
    else
      v14 = sub_10016D10(v9, (int)&v30);
    sub_10016D50((int)&v32, v14);
    if ( v31 >= 0x10 )
      sub_1002A4AA(v30);
    v15 = v33;
    if ( *(_DWORD *)(a6 + 36) >= 0
      && (*(_DWORD *)(a6 + 36) > 0 || *(_DWORD *)(a6 + 32))
      && (v16 = *(_DWORD *)(a6 + 32), v16 > v33) )
      v17 = v16 - v33;
    else
      v17 = 0;
    if ( (*(_DWORD *)(a6 + 20) & 0x1C0) == 64 )
    {
      v18 = a5;
      v19 = a4;
    }
    else
    {
      v20 = sub_10015490(v28, (int)&v29, a4, a5, v27, v17);
      v19 = *(_DWORD *)v20;
      v15 = v33;
      v18 = *(_DWORD *)(v20 + 4);
      v17 = 0;
    }
    v29 = v18;
    v21 = (unsigned __int8 *)&v32;
    if ( v34 >= 0x10 )
      v21 = (unsigned __int8 *)v32;
    v22 = sub_10015410(v28, (int)&v29, v19, v29, v21, v15);
    v23 = v27;
    v24 = *(_DWORD *)v22;
    v25 = v28;
    v37 = *(_DWORD *)(v22 + 4);
    *(_DWORD *)(a6 + 32) = 0;
    *(_DWORD *)(a6 + 36) = 0;
    sub_10015490(v25, a3, v24, v37, v23, v17);
    if ( v34 >= 0x10 )
      sub_1002A4AA(v32);
  }
  return a3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10013ED0) --------------------------------------------------------
int __thiscall sub_10013ED0(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7)
{
  int v8; // edi@1
  int v9; // eax@1
  int v10; // eax@1
  char v11; // [sp+Ch] [bp-54h]@1
  char v12; // [sp+10h] [bp-50h]@1
  char v13; // [sp+18h] [bp-48h]@1
  unsigned int v14; // [sp+5Ch] [bp-4h]@1

  v14 = (unsigned int)&v11 ^ __security_cookie;
  v8 = this;
  v9 = sub_10014FE0(this, (int)&v12, (int)"ld", *(_DWORD *)(a5 + 20));
  v10 = sub_10030914(a2, v8, (int)&v13, 0x40u, v9, a7);
  sub_10015070(v8, a2, a3, a4, a5, a6, (int)&v13, v10);
  return a2;
}
// 10073200: using guessed type int __security_cookie;

//----- (10013F50) --------------------------------------------------------
int __thiscall sub_10013F50(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7)
{
  int v8; // edi@1
  int v9; // eax@1
  int v10; // eax@1
  char v11; // [sp+Ch] [bp-54h]@1
  char v12; // [sp+10h] [bp-50h]@1
  char v13; // [sp+18h] [bp-48h]@1
  unsigned int v14; // [sp+5Ch] [bp-4h]@1

  v14 = (unsigned int)&v11 ^ __security_cookie;
  v8 = this;
  v9 = sub_10014FE0(this, (int)&v12, (int)"lu", *(_DWORD *)(a5 + 20));
  v10 = sub_10030914(a2, v8, (int)&v13, 0x40u, v9, a7);
  sub_10015070(v8, a2, a3, a4, a5, a6, (int)&v13, v10);
  return a2;
}
// 10073200: using guessed type int __security_cookie;

//----- (10013FE0) --------------------------------------------------------
int __thiscall sub_10013FE0(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7, int a8)
{
  int v9; // edi@1
  int v10; // eax@1
  int v11; // eax@1
  char v12; // [sp+Ch] [bp-54h]@1
  char v13; // [sp+10h] [bp-50h]@1
  char v14; // [sp+18h] [bp-48h]@1
  unsigned int v15; // [sp+5Ch] [bp-4h]@1

  v15 = (unsigned int)&v12 ^ __security_cookie;
  v9 = this;
  v10 = sub_10014FE0(this, (int)&v13, (int)"Ld", *(_DWORD *)(a5 + 20));
  v11 = sub_10030914(a2, v9, (int)&v14, 0x40u, v10, a7);
  sub_10015070(v9, a2, a3, a4, a5, a6, (int)&v14, v11);
  return a2;
}
// 10073200: using guessed type int __security_cookie;

//----- (10014060) --------------------------------------------------------
int __thiscall sub_10014060(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7, int a8)
{
  int v9; // edi@1
  int v10; // eax@1
  int v11; // eax@1
  char v12; // [sp+Ch] [bp-54h]@1
  char v13; // [sp+10h] [bp-50h]@1
  char v14; // [sp+18h] [bp-48h]@1
  unsigned int v15; // [sp+5Ch] [bp-4h]@1

  v15 = (unsigned int)&v12 ^ __security_cookie;
  v9 = this;
  v10 = sub_10014FE0(this, (int)&v13, (int)"Lu", *(_DWORD *)(a5 + 20));
  v11 = sub_10030914(a2, v9, (int)&v14, 0x40u, v10, a7);
  sub_10015070(v9, a2, a3, a4, a5, a6, (int)&v14, v11);
  return a2;
}
// 10073200: using guessed type int __security_cookie;

//----- (100140E0) --------------------------------------------------------
int __userpurge sub_100140E0<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6, unsigned __int8 a7, __int64 a8)
{
  int v8; // edi@1
  signed int v9; // esi@1
  signed int v10; // eax@9
  unsigned int v11; // edx@11
  unsigned int v12; // ecx@11
  int v13; // edi@11
  int v14; // esi@11
  unsigned __int8 v15; // cf@11
  int v16; // eax@11
  char v22; // al@13
  unsigned __int8 v43; // cf@26
  char *v44; // eax@32
  int v45; // edx@32
  int v46; // edi@32
  int v47; // ecx@36
  int v48; // ecx@39
  char v52; // ST38_1@46
  int v53; // eax@46
  int v54; // ST24_4@46
  int v55; // esi@46
  int v56; // [sp+10h] [bp-98h]@1
  int v57; // [sp+14h] [bp-94h]@11
  int v58; // [sp+18h] [bp-90h]@9
  int v59; // [sp+1Ch] [bp-8Ch]@1
  int v60; // [sp+20h] [bp-88h]@1
  int v61; // [sp+24h] [bp-84h]@1
  char v62; // [sp+28h] [bp-80h]@32
  char v63; // [sp+29h] [bp-7Fh]@32
  char v64; // [sp+2Ah] [bp-7Eh]@33
  char v65; // [sp+30h] [bp-78h]@46
  unsigned int v66; // [sp+A4h] [bp-4h]@1

  v66 = (unsigned int)&v56 ^ __security_cookie;
  v60 = a3;
  v8 = *(_DWORD *)(a6 + 28);
  v9 = *(_DWORD *)(a6 + 24);
  v61 = a1;
  v59 = a6;
  if ( v8 > 0 )
    goto LABEL_49;
  if ( v8 < 0 || !v9 )
  {
    if ( !(*(_DWORD *)(a6 + 20) & 0x2000) )
    {
      v9 = 6;
      v8 = 0;
    }
  }
  if ( v8 < 0 || v8 <= 0 && (unsigned int)v9 <= 0x24 )
  {
    v10 = v9;
    v58 = v9;
  }
  else
  {
LABEL_49:
    v10 = 36;
    v58 = 36;
  }
  __asm { movsd   xmm1, [ebp+arg_14] }
  v15 = v9 < (unsigned int)v10;
  v14 = v9 - v10;
  v13 = v8 - (v15 + ((unsigned __int64)v10 >> 32));
  v11 = 0;
  v12 = 0;
  v16 = *(_DWORD *)(v59 + 20) & 0x3000;
  v56 = 0;
  v57 = 0;
  if ( v16 == 8192 )
  {
    __asm
    {
      movapd  xmm0, xmm1
      mulsd   xmm0, ds:qword_10068478
      ucomisd xmm0, xmm1
      lahf
    }
    if ( __SETP__(_AH & 0x44, 0) )
    {
      __asm
      {
        movsd   xmm4, qword ptr ds:xmmword_10068580
        xorps   xmm3, xmm3
        comisd  xmm3, xmm1
      }
      v22 = !(_CF | _ZF);
      if ( !(_CF | _ZF) )
        __asm { xorpd   xmm1, xmm4 }
      __asm
      {
        movsd   xmm0, ds:qword_10068538
        comisd  xmm1, xmm0
        movsd   xmm2, ds:qword_10068508
      }
      if ( !_CF )
      {
        do
        {
          if ( v11 >= 0x1388 )
            break;
          __asm { divsd   xmm1, xmm2 }
          v11 += 10;
          __asm { comisd  xmm1, xmm0 }
        }
        while ( !_CF );
        v56 = v11;
      }
      __asm { comisd  xmm1, xmm3 }
      if ( !(_CF | _ZF) )
      {
        if ( v13 >= 0 )
        {
          if ( v13 > 0 || (unsigned int)v14 >= 0xA )
          {
            __asm { movsd   xmm0, ds:qword_10068458 }
            while ( 1 )
            {
              __asm { comisd  xmm0, xmm1 }
              if ( _CF )
                break;
              if ( v12 >= 0x1388 )
                break;
              v43 = (unsigned int)v14 >= 0xA;
              v14 -= 10;
              v13 = v43 + v13 - 1;
              v12 += 10;
              __asm { mulsd   xmm1, xmm2 }
              if ( v13 <= 0 )
              {
                if ( v13 < 0 || (unsigned int)v14 < 0xA )
                  break;
              }
            }
            v57 = v12;
          }
        }
      }
      if ( v22 )
        __asm { xorpd   xmm1, xmm4 }
    }
  }
  v46 = v59;
  v62 = 37;
  v45 = *(_DWORD *)(v59 + 20);
  v44 = &v63;
  if ( v45 & 0x20 )
  {
    v63 = 43;
    v44 = &v64;
  }
  if ( v45 & 0x10 )
    *v44++ = 35;
  v47 = v45 & 0x3000;
  *(_WORD *)v44 = 10798;
  if ( v45 & 4 )
  {
    if ( v47 != 8192 )
    {
      if ( v47 == 12288 )
      {
        LOBYTE(v48) = 65;
      }
      else
      {
        LOBYTE(v47) = v47 != 4096;
        v48 = 2 * v47 + 69;
      }
      goto LABEL_46;
    }
LABEL_42:
    LOBYTE(v48) = 102;
    goto LABEL_46;
  }
  if ( v47 == 8192 )
    goto LABEL_42;
  if ( v47 == 12288 )
  {
    LOBYTE(v48) = 97;
  }
  else
  {
    LOBYTE(v47) = v47 != 4096;
    v48 = 2 * v47 + 101;
  }
LABEL_46:
  v44[2] = v48;
  __asm { movsd   [esp+0A8h+var_A8], xmm1 }
  v52 = v58;
  v44[3] = 0;
  v53 = sub_10030914(a2, v46, (int)&v65, 0x6Cu, (int)&v62, v52);
  v54 = v14;
  v55 = v60;
  sub_10014B60(v61, v60, a4, a5, v46, a7, (int)&v65, v56, v57, v54, v53);
  return v55;
}
// 10073200: using guessed type int __security_cookie;

//----- (10014320) --------------------------------------------------------
int __userpurge sub_10014320<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6, unsigned __int8 a7, __int64 a8)
{
  int v8; // edi@1
  signed int v9; // esi@1
  signed int v10; // eax@9
  unsigned int v11; // edx@11
  unsigned int v12; // ecx@11
  int v13; // edi@11
  int v14; // esi@11
  unsigned __int8 v15; // cf@11
  char v16; // al@12
  unsigned __int8 v37; // cf@25
  int v39; // edi@31
  char v42; // ST38_1@31
  int v43; // eax@31
  int v44; // eax@31
  int v45; // ST24_4@31
  int v46; // esi@31
  int v47; // [sp+10h] [bp-98h]@1
  int v48; // [sp+14h] [bp-94h]@9
  int v49; // [sp+18h] [bp-90h]@11
  int v50; // [sp+1Ch] [bp-8Ch]@11
  int v51; // [sp+20h] [bp-88h]@1
  int v52; // [sp+24h] [bp-84h]@1
  int v53; // [sp+28h] [bp-80h]@11
  char v54; // [sp+30h] [bp-78h]@31
  unsigned int v55; // [sp+A4h] [bp-4h]@1

  v55 = (unsigned int)&v47 ^ __security_cookie;
  v51 = a3;
  v8 = *(_DWORD *)(a6 + 28);
  v9 = *(_DWORD *)(a6 + 24);
  v52 = a1;
  v47 = a6;
  if ( v8 > 0 )
    goto LABEL_34;
  if ( v8 < 0 || !v9 )
  {
    if ( !(*(_DWORD *)(a6 + 20) & 0x2000) )
    {
      v9 = 6;
      v8 = 0;
    }
  }
  if ( v8 < 0 || v8 <= 0 && (unsigned int)v9 <= 0x24 )
  {
    v10 = v9;
    v48 = v9;
  }
  else
  {
LABEL_34:
    v10 = 36;
    v48 = 36;
  }
  __asm { movsd   xmm0, [ebp+arg_14] }
  v15 = v9 < (unsigned int)v10;
  v14 = v9 - v10;
  v13 = v8 - (v15 + ((unsigned __int64)v10 >> 32));
  v53 = *(_DWORD *)(v47 + 20);
  v11 = 0;
  v12 = 0;
  v50 = 0;
  v49 = 0;
  if ( (v53 & 0x3000) == 8192 )
  {
    __asm
    {
      movsd   xmm4, qword ptr ds:xmmword_10068580
      xorps   xmm3, xmm3
      comisd  xmm3, xmm0
    }
    v16 = !(_CF | _ZF);
    if ( !(_CF | _ZF) )
      __asm { xorpd   xmm0, xmm4 }
    __asm
    {
      movsd   xmm1, ds:qword_10068538
      comisd  xmm0, xmm1
      movsd   xmm2, ds:qword_10068508
    }
    if ( !_CF )
    {
      do
      {
        if ( v11 >= 0x1388 )
          break;
        __asm { divsd   xmm0, xmm2 }
        v11 += 10;
        __asm { comisd  xmm0, xmm1 }
      }
      while ( !_CF );
      v50 = v11;
    }
    __asm { comisd  xmm0, xmm3 }
    if ( !(_CF | _ZF) )
    {
      if ( v13 >= 0 )
      {
        if ( v13 > 0 || (unsigned int)v14 >= 0xA )
        {
          __asm { movsd   xmm1, ds:qword_10068458 }
          while ( 1 )
          {
            __asm { comisd  xmm1, xmm0 }
            if ( _CF )
              break;
            if ( v12 >= 0x1388 )
              break;
            v37 = (unsigned int)v14 >= 0xA;
            v14 -= 10;
            v13 = v37 + v13 - 1;
            v12 += 10;
            __asm { mulsd   xmm0, xmm2 }
            if ( v13 <= 0 )
            {
              if ( v13 < 0 || (unsigned int)v14 < 0xA )
                break;
            }
          }
          v49 = v12;
        }
      }
    }
    if ( v16 )
      __asm { xorpd   xmm0, xmm4 }
  }
  v39 = v52;
  __asm { movsd   [esp+0A8h+var_A8], xmm0 }
  v42 = v48;
  v43 = sub_10014AA0(v52, (int)&v53, 76, v53);
  v44 = sub_10030914(a2, v39, (int)&v54, 0x6Cu, v43, v42);
  v45 = v14;
  v46 = v51;
  sub_10014B60(v39, v51, a4, a5, v47, a7, (int)&v54, v50, v49, v45, v44);
  return v46;
}
// 10073200: using guessed type int __security_cookie;

//----- (100144D0) --------------------------------------------------------
int __thiscall sub_100144D0(int this, int a2, int a3, int a4, int a5, unsigned __int8 a6, char a7)
{
  int v8; // edi@1
  int v9; // eax@1
  char v10; // [sp+Ch] [bp-4Ch]@1
  char v11; // [sp+10h] [bp-48h]@1
  unsigned int v12; // [sp+54h] [bp-4h]@1

  v12 = (unsigned int)&v10 ^ __security_cookie;
  v8 = this;
  v9 = sub_10030914(a2, this, (int)&v11, 0x40u, (int)"%p", a7);
  sub_10015070(v8, a2, a3, a4, a5, a6, (int)&v11, v9);
  return a2;
}
// 10073200: using guessed type int __security_cookie;

//----- (10014540) --------------------------------------------------------
int __fastcall sub_10014540(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@1
  int *v6; // eax@2
  int v7; // edi@5
  char v9; // [sp+Ch] [bp-8h]@3
  unsigned int v10; // [sp+10h] [bp-4h]@1
  int v11; // [sp+14h] [bp+0h]@1

  v10 = (unsigned int)&v11 ^ __security_cookie;
  v5 = a1;
  v4 = 0;
  if ( *(_DWORD *)a1 )
  {
    v6 = (int *)**(_DWORD **)a1;
    if ( v6 )
    {
      v4 = *v6;
    }
    else
    {
      sub_10029A76(a2, (int)&v9, 0, a1, 3);
      sub_10029AD2(&v9);
    }
  }
  v7 = a4 + *(_DWORD *)(v5 + 8);
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  if ( v4 )
  {
    if ( *(_DWORD *)v4 )
    {
      *(_DWORD *)a3 = **(_DWORD **)v4;
    }
    else
    {
      sub_10029A76(a2, (int)&v9, v4, v7, 3);
      sub_10029AD2(&v9);
    }
  }
  *(_DWORD *)(a3 + 8) = v7;
  return a3;
}
// 10073200: using guessed type int __security_cookie;

//----- (100145D0) --------------------------------------------------------
void *__thiscall sub_100145D0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10060654;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10060654: using guessed type int (__stdcall *off_10060654)(char);

//----- (10014830) --------------------------------------------------------
int __usercall sub_10014830<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<ebp>, int a5<edi>)
{
  int v5; // eax@1
  int v6; // edi@1
  int v7; // esi@1

  v7 = a2;
  *(_DWORD *)a2 = &off_10067934;
  v5 = sub_1002ADB1(a1, a2, a3, a5, 4);
  v6 = v5;
  if ( v5 )
  {
    *(_DWORD *)v5 = 0;
    *(_DWORD *)v5 = sub_1002987D(a3, a4, v5);
  }
  else
  {
    v6 = 0;
  }
  *(_DWORD *)(v7 + 12) = v7 + 4;
  *(_DWORD *)(v7 + 28) = v7 + 20;
  *(_DWORD *)(v7 + 32) = v7 + 24;
  *(_DWORD *)(v7 + 52) = v6;
  *(_DWORD *)(v7 + 44) = v7 + 36;
  *(_DWORD *)(v7 + 16) = v7 + 8;
  *(_DWORD *)(v7 + 48) = v7 + 40;
  *(_DWORD *)(v7 + 8) = 0;
  **(_DWORD **)(v7 + 32) = 0;
  **(_DWORD **)(v7 + 48) = 0;
  **(_DWORD **)(v7 + 12) = 0;
  **(_DWORD **)(v7 + 28) = 0;
  **(_DWORD **)(v7 + 44) = 0;
  return v7;
}
// 10067934: using guessed type int (__stdcall *off_10067934)(char);

//----- (10014A40) --------------------------------------------------------
int __userpurge sub_10014A40<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7)
{
  char v8; // [sp+8h] [bp-8h]@2
  unsigned int v9; // [sp+Ch] [bp-4h]@1
  int v10; // [sp+10h] [bp+0h]@1

  v9 = (unsigned int)&v10 ^ __security_cookie;
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  if ( a2 )
  {
    *(_DWORD *)a4 = *(_DWORD *)a2;
  }
  else
  {
    sub_10029A76(a1, (int)&v8, a3, a7, 3);
    sub_10029AD2(&v8);
  }
  *(_DWORD *)(a4 + 8) = a7;
  return a4;
}
// 10073200: using guessed type int __security_cookie;

//----- (10014AA0) --------------------------------------------------------
int __cdecl sub_10014AA0(int a1, int a2, char a3, __int16 a4)
{
  int v4; // eax@1
  int v5; // eax@5
  int v6; // ecx@7
  int result; // eax@10

  *(_BYTE *)a2 = 37;
  v4 = a2 + 1;
  if ( a4 & 0x20 )
  {
    *(_BYTE *)v4 = 43;
    v4 = a2 + 2;
  }
  if ( a4 & 0x10 )
    *(_BYTE *)v4++ = 35;
  *(_WORD *)v4 = 10798;
  v5 = v4 + 2;
  if ( a3 )
    *(_BYTE *)v5++ = a3;
  v6 = a4 & 0x3000;
  if ( a4 & 4 )
  {
    if ( v6 != 8192 )
    {
      if ( v6 == 12288 )
      {
        *(_BYTE *)v5 = 65;
        *(_BYTE *)(v5 + 1) = 0;
        result = a2;
      }
      else
      {
        *(_BYTE *)v5 = 2 * (v6 != 4096) + 69;
        *(_BYTE *)(v5 + 1) = 0;
        result = a2;
      }
      return result;
    }
LABEL_13:
    *(_BYTE *)v5 = 102;
    *(_BYTE *)(v5 + 1) = 0;
    return a2;
  }
  if ( v6 == 8192 )
    goto LABEL_13;
  if ( v6 == 12288 )
  {
    *(_BYTE *)v5 = 97;
    *(_BYTE *)(v5 + 1) = 0;
    result = a2;
  }
  else
  {
    *(_BYTE *)v5 = 2 * (v6 != 4096) + 101;
    *(_BYTE *)(v5 + 1) = 0;
    result = a2;
  }
  return result;
}

//----- (10014B60) --------------------------------------------------------
int __cdecl sub_10014B60(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8, int a9, int a10, unsigned int a11)
{
  int v11; // edi@4
  int v12; // eax@6
  int v13; // edx@7
  int v14; // eax@8
  char v15; // cl@10
  int v16; // eax@13
  int v17; // eax@13
  int v18; // edx@13
  int v19; // eax@14
  int *v20; // eax@16
  void *v21; // ebx@18
  int v22; // eax@18
  int v23; // eax@18
  int v24; // edx@18
  int v25; // eax@19
  int v26; // ebx@22
  int *v27; // eax@23
  int v28; // edx@23
  char v29; // cl@23
  int v30; // esi@23
  char v31; // al@23
  int *v32; // esi@26
  char i; // al@28
  unsigned __int8 v34; // zf@34
  unsigned __int8 v35; // sf@34
  int v36; // ebx@34
  unsigned int v37; // esi@37
  int v38; // esi@38
  int v39; // eax@40
  unsigned __int8 *v40; // eax@42
  int v41; // ecx@42
  int v42; // eax@44
  unsigned __int8 *v43; // eax@45
  int v44; // eax@47
  unsigned __int8 *v45; // eax@48
  int *v46; // eax@51
  int v47; // edx@51
  int v48; // ebx@53
  int v49; // eax@53
  int v50; // ST1C_4@53
  int v52; // [sp+50h] [bp-74h]@1
  int v53; // [sp+54h] [bp-70h]@13
  int v54; // [sp+58h] [bp-6Ch]@1
  int v55; // [sp+60h] [bp-64h]@13
  int v56; // [sp+64h] [bp-60h]@13
  unsigned int v57; // [sp+68h] [bp-5Ch]@1
  unsigned int v58; // [sp+6Ch] [bp-58h]@21
  int v59; // [sp+70h] [bp-54h]@13
  int v60; // [sp+74h] [bp-50h]@16
  int v61; // [sp+78h] [bp-4Ch]@1
  __int16 v62; // [sp+7Ch] [bp-48h]@13
  void *v63; // [sp+80h] [bp-44h]@16
  unsigned int v64; // [sp+90h] [bp-34h]@16
  unsigned int v65; // [sp+94h] [bp-30h]@16
  void *v66; // [sp+98h] [bp-2Ch]@21
  int v67; // [sp+A8h] [bp-1Ch]@55
  unsigned int v68; // [sp+ACh] [bp-18h]@26
  unsigned int v69; // [sp+B0h] [bp-14h]@1
  int v70; // [sp+C0h] [bp-4h]@13
  int v71; // [sp+D4h] [bp+10h]@53

  v69 = (unsigned int)&v52 ^ __security_cookie;
  v61 = a2;
  v54 = a5;
  v57 = a11;
  v11 = a11 && (*(_BYTE *)a7 == 43 || *(_BYTE *)a7 == 45);
  v12 = *(_DWORD *)(a5 + 20) & 0x3000;
  v52 = v11;
  if ( v12 == 12288 )
  {
    v14 = v11 + 2;
    v13 = (int)"pP";
    if ( v11 + 2 <= a11 )
    {
      if ( *(_BYTE *)(a7 + v11) == 48 )
      {
        v15 = *(_BYTE *)(a7 + v11 + 1);
        if ( v15 == 120 || v15 == 88 )
        {
          v11 += 2;
          v52 = v14;
        }
      }
    }
  }
  else
  {
    v13 = (int)"eE";
  }
  v59 = sub_10030C10(a7, v13);
  v62 = 46;
  LOBYTE(v62) = *(_BYTE *)*sub_10030BE0(a7, v11);
  v55 = sub_10030C10(a7, (int)&v62);
  v16 = sub_10017D70(a5, (int)&v56);
  v70 = 0;
  v17 = sub_10017B50(v18, a7, v11, v16);
  v70 = -1;
  v53 = v17;
  if ( v56 )
  {
    v19 = (*(int (**)(void))(*(_DWORD *)v56 + 8))();
    if ( v19 )
      (**(void (__stdcall ***)(_DWORD))v19)(1);
  }
  LOBYTE(v60) = (*(int (__stdcall **)(signed int))(*(_DWORD *)v53 + 32))(48);
  v65 = 15;
  v64 = 0;
  LOBYTE(v63) = 0;
  loc_10018220(&v63, v57, 0);
  v70 = 1;
  v20 = (int *)&v63;
  if ( v65 >= 0x10 )
    v20 = (int *)v63;
  (*(void (__thiscall **)(int, int, unsigned int, int *))(*(_DWORD *)v53 + 28))(v53, a7, a7 + v57, v20);
  v22 = sub_10017D70(a5, (int)&v56);
  LOBYTE(v70) = 2;
  v23 = sub_100171B0(v24, a7, v11, v22);
  LOBYTE(v70) = 1;
  v21 = (void *)v23;
  v53 = v23;
  if ( v56 )
  {
    v25 = (*(int (**)(void))(*(_DWORD *)v56 + 8))();
    if ( v25 )
      (**(void (__stdcall ***)(_DWORD))v25)(1);
  }
  sub_10016CF0(v21, (int)&v66);
  LOBYTE(v70) = 3;
  LOBYTE(v58) = (*(int (__thiscall **)(void *))(*(_DWORD *)v21 + 16))(v21);
  if ( v55 == v57 )
  {
    v26 = v59 + a8;
    loc_10016BE0(&v63, v59, a8, v60);
  }
  else
  {
    v30 = v60;
    v26 = v55 + a8;
    loc_10016BE0(&v63, v59, a10, v60);
    loc_10016BE0(&v63, v55 + 1, a9, v30);
    v31 = (*(int (__thiscall **)(int))(*(_DWORD *)v53 + 12))(v53);
    v28 = v55;
    v29 = v31;
    v27 = (int *)&v63;
    if ( v65 >= 0x10 )
      v27 = (int *)v63;
    *((_BYTE *)v27 + v55) = v29;
    loc_10016BE0(&v63, v28, a8, v30);
    v11 = v52;
  }
  v32 = (int *)&v66;
  if ( v68 >= 0x10 )
    v32 = (int *)v66;
  for ( i = *(_BYTE *)v32; *(_BYTE *)v32 != 127; i = *(_BYTE *)v32 )
  {
    if ( i <= 0 )
      break;
    if ( i >= (unsigned int)(v26 - v11) )
      break;
    v26 -= i;
    loc_10016BE0(&v63, v26, 1, v58);
    if ( *((_BYTE *)v32 + 1) > 0 )
      v32 = (int *)((char *)v32 + 1);
  }
  v36 = v54;
  v34 = *(_DWORD *)(v54 + 36) == 0;
  v35 = *(_DWORD *)(v54 + 36) < 0;
  v58 = v64;
  if ( v35 || v35 | v34 && !*(_DWORD *)(v54 + 32) || (v37 = *(_DWORD *)(v54 + 32), v37 <= v64) )
    v38 = 0;
  else
    v38 = v37 - v64;
  v39 = *(_DWORD *)(v54 + 20) & 0x1C0;
  if ( v39 == 64 )
  {
    v45 = (unsigned __int8 *)&v63;
    if ( v65 >= 0x10 )
      v45 = (unsigned __int8 *)v63;
    v42 = sub_10015410(a1, (int)&v54, a3, a4, v45, v11);
  }
  else
  {
    if ( v39 == 256 )
    {
      v43 = (unsigned __int8 *)&v63;
      if ( v65 >= 0x10 )
        v43 = (unsigned __int8 *)v63;
      v44 = sub_10015410(a1, (int)&v54, a3, a4, v43, v11);
      v42 = sub_10015490(a1, (int)&v54, *(_DWORD *)v44, *(_DWORD *)(v44 + 4), a6, v38);
      v38 = 0;
    }
    else
    {
      v41 = sub_10015490(a1, (int)&v54, a3, a4, a6, v38);
      v38 = 0;
      v40 = (unsigned __int8 *)&v63;
      if ( v65 >= 0x10 )
        v40 = (unsigned __int8 *)v63;
      v42 = sub_10015410(a1, (int)&v54, *(_DWORD *)v41, *(_DWORD *)(v41 + 4), v40, v11);
    }
  }
  v47 = *(_DWORD *)v42;
  v52 = *(_DWORD *)(v42 + 4);
  v46 = (int *)&v63;
  if ( v65 >= 0x10 )
    v46 = (int *)v63;
  v49 = sub_10015410(a1, (int)&v54, v47, v52, (unsigned __int8 *)v46 + v11, v58 - v11);
  v71 = *(_DWORD *)v49;
  v50 = *(_DWORD *)(v49 + 4);
  *(_DWORD *)(v36 + 32) = 0;
  *(_DWORD *)(v36 + 36) = 0;
  v48 = v61;
  sub_10015490(a1, v61, v71, v50, a6, v38);
  if ( v68 >= 0x10 )
    sub_1002A4AA(v66);
  v68 = 15;
  v67 = 0;
  LOBYTE(v66) = 0;
  if ( v65 >= 0x10 )
    sub_1002A4AA(v63);
  return v48;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10014FE0) --------------------------------------------------------
int __cdecl sub_10014FE0(int a1, int a2, int a3, __int16 a4)
{
  int v4; // eax@1
  int v5; // eax@6
  int v6; // edx@8
  int result; // eax@9

  *(_BYTE *)a2 = 37;
  v4 = a2 + 1;
  if ( a4 & 0x20 )
  {
    *(_BYTE *)v4 = 43;
    v4 = a2 + 2;
  }
  if ( a4 & 8 )
    *(_BYTE *)v4++ = 35;
  if ( *(_BYTE *)a3 == 76 )
  {
    *(_WORD *)v4 = 13897;
    *(_BYTE *)(v4 + 2) = 52;
    v5 = v4 + 3;
  }
  else
  {
    *(_BYTE *)v4 = *(_BYTE *)a3;
    v5 = v4 + 1;
  }
  v6 = a4 & 0xE00;
  if ( v6 == 1024 )
  {
    *(_BYTE *)v5 = 111;
    *(_BYTE *)(v5 + 1) = 0;
    result = a2;
  }
  else
  {
    if ( v6 == 2048 )
    {
      *(_BYTE *)v5 = ~(8 * a4) & 0x20 | 0x58;
      *(_BYTE *)(v5 + 1) = 0;
      result = a2;
    }
    else
    {
      *(_BYTE *)v5 = *(_BYTE *)(a3 + 1);
      *(_BYTE *)(v5 + 1) = 0;
      result = a2;
    }
  }
  return result;
}

//----- (10015070) --------------------------------------------------------
int __cdecl sub_10015070(int a1, int a2, int a3, int a4, int a5, unsigned __int8 a6, int a7, int a8)
{
  int v8; // edi@1
  int v9; // ebx@4
  char v10; // cl@9
  int v11; // eax@12
  int v12; // eax@12
  int v13; // edx@12
  int v14; // eax@13
  int *v15; // eax@15
  void *v16; // esi@17
  int v17; // eax@17
  int v18; // eax@17
  int v19; // edx@17
  int v20; // eax@18
  int *v21; // esi@20
  char i; // al@24
  unsigned __int8 v23; // zf@30
  unsigned __int8 v24; // sf@30
  int v25; // esi@30
  unsigned int v26; // edi@33
  int v27; // edi@34
  int v28; // eax@36
  int v29; // edx@38
  unsigned __int8 *v30; // ecx@38
  int v31; // eax@40
  unsigned __int8 *v32; // eax@41
  int v33; // eax@43
  unsigned __int8 *v34; // eax@44
  int *v35; // eax@47
  int v36; // edx@47
  int v37; // esi@49
  int v38; // eax@49
  int v39; // ST0C_4@49
  int v41; // [sp+28h] [bp-5Ch]@1
  int v42; // [sp+2Ch] [bp-58h]@12
  int v43; // [sp+30h] [bp-54h]@1
  int v44; // [sp+38h] [bp-4Ch]@12
  int v45; // [sp+3Ch] [bp-48h]@1
  void *v46; // [sp+40h] [bp-44h]@15
  unsigned int v47; // [sp+50h] [bp-34h]@15
  unsigned int v48; // [sp+54h] [bp-30h]@15
  void *v49; // [sp+58h] [bp-2Ch]@20
  int v50; // [sp+68h] [bp-1Ch]@51
  unsigned int v51; // [sp+6Ch] [bp-18h]@20
  unsigned int v52; // [sp+70h] [bp-14h]@1
  int v53; // [sp+80h] [bp-4h]@12
  int v54; // [sp+94h] [bp+10h]@49

  v52 = (unsigned int)&v41 ^ __security_cookie;
  v8 = a8;
  v45 = a2;
  v43 = a5;
  v41 = a7;
  v9 = a8 && (*(_BYTE *)a7 == 43 || *(_BYTE *)a7 == 45);
  if ( (*(_DWORD *)(a5 + 20) & 0xE00) == 2048 )
  {
    if ( v9 + 2 <= (unsigned int)a8 )
    {
      if ( *(_BYTE *)(a7 + v9) == 48 )
      {
        v10 = *(_BYTE *)(a7 + v9 + 1);
        if ( v10 == 120 || v10 == 88 )
          v9 += 2;
      }
    }
  }
  v11 = sub_10017D70(a5, (int)&v44);
  v53 = 0;
  v12 = sub_10017B50(v13, v9, a8, v11);
  v53 = -1;
  v42 = v12;
  if ( v44 )
  {
    v14 = (*(int (**)(void))(*(_DWORD *)v44 + 8))();
    if ( v14 )
      (**(void (__thiscall ***)(_DWORD, _DWORD))v14)(v14, 1);
  }
  v48 = 15;
  v47 = 0;
  LOBYTE(v46) = 0;
  loc_10018220(&v46, a8, 0);
  v53 = 1;
  v15 = (int *)&v46;
  if ( v48 >= 0x10 )
    v15 = (int *)v46;
  (*(void (__thiscall **)(int, int, int, int *))(*(_DWORD *)v42 + 28))(v42, v41, a8 + v41, v15);
  v17 = sub_10017D70(a5, (int)&v41);
  LOBYTE(v53) = 2;
  v18 = sub_100171B0(v19, v9, a8, v17);
  LOBYTE(v53) = 1;
  v16 = (void *)v18;
  v44 = v18;
  if ( v41 )
  {
    v20 = (*(int (**)(void))(*(_DWORD *)v41 + 8))();
    if ( v20 )
      (**(void (__thiscall ***)(_DWORD, _DWORD))v20)(v20, 1);
  }
  sub_10016CF0(v16, (int)&v49);
  LOBYTE(v53) = 3;
  v21 = (int *)&v49;
  if ( v51 >= 0x10 )
    v21 = (int *)v49;
  if ( *(_BYTE *)v21 != 127 )
  {
    if ( *(_BYTE *)v21 > 0 )
    {
      LOBYTE(v41) = (*(int (__thiscall **)(int))(*(_DWORD *)v44 + 16))(v44);
      for ( i = *(_BYTE *)v21; *(_BYTE *)v21 != 127; i = *(_BYTE *)v21 )
      {
        if ( i <= 0 )
          break;
        if ( i >= (unsigned int)(v8 - v9) )
          break;
        v8 -= i;
        loc_10016BE0(&v46, v8, 1, v41);
        if ( *((_BYTE *)v21 + 1) > 0 )
          v21 = (int *)((char *)v21 + 1);
      }
    }
  }
  v25 = v43;
  v23 = *(_DWORD *)(v43 + 36) == 0;
  v24 = *(_DWORD *)(v43 + 36) < 0;
  v41 = v47;
  if ( v24 || v24 | v23 && !*(_DWORD *)(v43 + 32) || (v26 = *(_DWORD *)(v43 + 32), v26 <= v47) )
    v27 = 0;
  else
    v27 = v26 - v47;
  v28 = *(_DWORD *)(v43 + 20) & 0x1C0;
  if ( v28 == 64 )
  {
    v34 = (unsigned __int8 *)&v46;
    if ( v48 >= 0x10 )
      v34 = (unsigned __int8 *)v46;
    v31 = sub_10015410(a1, (int)&v43, a3, a4, v34, v9);
  }
  else
  {
    if ( v28 == 256 )
    {
      v32 = (unsigned __int8 *)&v46;
      if ( v48 >= 0x10 )
        v32 = (unsigned __int8 *)v46;
      v33 = sub_10015410(a1, (int)&v43, a3, a4, v32, v9);
      v31 = sub_10015490(a1, (int)&v43, *(_DWORD *)v33, *(_DWORD *)(v33 + 4), a6, v27);
      v27 = 0;
    }
    else
    {
      v29 = sub_10015490(a1, (int)&v43, a3, a4, a6, v27);
      v27 = 0;
      v30 = (unsigned __int8 *)&v46;
      if ( v48 >= 0x10 )
        v30 = (unsigned __int8 *)v46;
      v31 = sub_10015410(a1, (int)&v43, *(_DWORD *)v29, *(_DWORD *)(v29 + 4), v30, v9);
    }
  }
  v36 = *(_DWORD *)v31;
  v42 = *(_DWORD *)(v31 + 4);
  v35 = (int *)&v46;
  if ( v48 >= 0x10 )
    v35 = (int *)v46;
  v38 = sub_10015410(a1, (int)&v43, v36, v42, (unsigned __int8 *)v35 + v9, v41 - v9);
  v54 = *(_DWORD *)v38;
  v39 = *(_DWORD *)(v38 + 4);
  *(_DWORD *)(v25 + 32) = 0;
  *(_DWORD *)(v25 + 36) = 0;
  v37 = v45;
  sub_10015490(a1, v45, v54, v39, a6, v27);
  if ( v51 >= 0x10 )
    sub_1002A4AA(v49);
  v51 = 15;
  v50 = 0;
  LOBYTE(v49) = 0;
  if ( v48 >= 0x10 )
    sub_1002A4AA(v46);
  return v37;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10015410) --------------------------------------------------------
int __cdecl sub_10015410(int a1, int a2, int a3, int a4, unsigned __int8 *a5, int a6)
{
  int result; // eax@1
  unsigned __int8 *v7; // ebx@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // edx@4
  int v11; // eax@5
  int v12; // ecx@5
  int v13; // edx@5
  unsigned __int8 v14; // [sp+13h] [bp-1h]@3

  result = a2;
  v7 = a5;
  v9 = a4;
  v8 = a6;
  if ( a6 )
  {
    do
    {
      if ( !v9
        || ((v14 = *v7, !**(_DWORD **)(v9 + 32)) || (v10 = *(_DWORD *)(v9 + 48), *(_DWORD *)v10 <= 0) ? (v11 = (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)v9 + 12))(v9, *v7)) : (--*(_DWORD *)v10, v12 = *(_DWORD *)(v9 + 32), v13 = *(_DWORD *)v12, ++*(_DWORD *)v12, *(_BYTE *)v13 = v14, v11 = v14),
            v9 = a4,
            v11 == -1) )
        LOBYTE(a3) = 1;
      ++v7;
      --v8;
    }
    while ( v8 );
    result = a2;
  }
  *(_DWORD *)(result + 4) = v9;
  *(_DWORD *)result = a3;
  return result;
}

//----- (10015490) --------------------------------------------------------
int __cdecl sub_10015490(int a1, int a2, int a3, int a4, unsigned __int8 a5, int a6)
{
  int result; // eax@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // ecx@4
  int v10; // eax@5
  int v11; // ecx@5
  int v12; // edx@5

  result = a2;
  v8 = a4;
  v7 = a6;
  if ( a6 )
  {
    do
    {
      if ( !v8
        || (!**(_DWORD **)(v8 + 32) || (v9 = *(_DWORD *)(v8 + 48), *(_DWORD *)v9 <= 0) ? (v10 = (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)v8 + 12))(
                                                                                                  v8,
                                                                                                  a5)) : (--*(_DWORD *)v9, v11 = *(_DWORD *)(v8 + 32), v12 = *(_DWORD *)v11, ++*(_DWORD *)v11, *(_BYTE *)v12 = a5, v10 = a5),
            v8 = a4,
            v10 == -1) )
        LOBYTE(a3) = 1;
      --v7;
    }
    while ( v7 );
    result = a2;
  }
  *(_DWORD *)(result + 4) = v8;
  *(_DWORD *)result = a3;
  return result;
}

//----- (10015510) --------------------------------------------------------
int __fastcall sub_10015510(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@1
  int *v6; // eax@2
  int v7; // edi@5
  char v9; // [sp+Ch] [bp-8h]@3
  unsigned int v10; // [sp+10h] [bp-4h]@1
  int v11; // [sp+14h] [bp+0h]@1

  v10 = (unsigned int)&v11 ^ __security_cookie;
  v5 = a1;
  v4 = 0;
  if ( *(_DWORD *)a1 )
  {
    v6 = (int *)**(_DWORD **)a1;
    if ( v6 )
    {
      v4 = *v6;
    }
    else
    {
      sub_10029A76(a2, (int)&v9, 0, a1, 3);
      sub_10029AD2(&v9);
    }
  }
  v7 = *(_DWORD *)(v5 + 8) - 1;
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  if ( v4 )
  {
    if ( *(_DWORD *)v4 )
    {
      *(_DWORD *)a3 = **(_DWORD **)v4;
    }
    else
    {
      sub_10029A76(a2, (int)&v9, v4, v7, 3);
      sub_10029AD2(&v9);
    }
  }
  *(_DWORD *)(a3 + 8) = v7;
  return a3;
}
// 10073200: using guessed type int __security_cookie;

//----- (100155A0) --------------------------------------------------------
int __usercall sub_100155A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int result; // eax@1

  result = sub_1002ADB1(a1, a2, a3, a4, 40);
  JUMPOUT(result, 0, *(unsigned int *)sub_10029530);
  *(_DWORD *)result = result;
  if ( result != -4 )
    *(_DWORD *)(result + 4) = result;
  if ( result != -8 )
    *(_DWORD *)(result + 8) = result;
  *(_WORD *)(result + 12) = 257;
  return result;
}

//----- (100155D0) --------------------------------------------------------
int __fastcall sub_100155D0(int a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@2
  int v5; // esi@3
  char v6; // al@4
  int v7; // eax@6
  int v8; // esi@6
  unsigned int v9; // eax@7
  int result; // eax@10

  v3 = a1;
  if ( *(_BYTE *)a2 )
  {
    v5 = a2;
    a1 = a2 + 1;
    do
      v6 = *(_BYTE *)v5++;
    while ( v6 );
    v4 = v5 - a1;
  }
  else
  {
    v4 = 0;
  }
  v7 = loc_10015E50(a3, a1, a2, v4);
  v8 = v7;
  *(_DWORD *)(v3 + 20) = 15;
  *(_DWORD *)(v3 + 16) = 0;
  *(_BYTE *)v3 = 0;
  if ( *(_DWORD *)(v7 + 20) >= 0x10u )
  {
    *(_DWORD *)v3 = *(_DWORD *)v7;
    *(_DWORD *)v7 = 0;
  }
  else
  {
    v9 = *(_DWORD *)(v7 + 16) + 1;
    if ( v9 )
      sub_1002A4B0((void *)v3, (const void *)v8, v9);
  }
  *(_DWORD *)(v3 + 16) = *(_DWORD *)(v8 + 16);
  *(_DWORD *)(v3 + 20) = *(_DWORD *)(v8 + 20);
  *(_DWORD *)(v8 + 20) = 15;
  *(_DWORD *)(v8 + 16) = 0;
  result = v3;
  *(_BYTE *)v8 = 0;
  return result;
}

//----- (10015660) --------------------------------------------------------
int __fastcall sub_10015660(int a1, int a2, const char *a3)
{
  int v3; // edi@1
  unsigned int v4; // esi@2
  int v5; // eax@4
  int v6; // esi@4
  unsigned int v7; // eax@5
  int result; // eax@8

  v3 = a1;
  if ( *a3 )
    v4 = strlen(a3);
  else
    v4 = 0;
  v5 = loc_10014700(a2, a3, v4);
  v6 = v5;
  *(_DWORD *)(v3 + 20) = 15;
  *(_DWORD *)(v3 + 16) = 0;
  *(_BYTE *)v3 = 0;
  if ( *(_DWORD *)(v5 + 20) >= 0x10u )
  {
    *(_DWORD *)v3 = *(_DWORD *)v5;
    *(_DWORD *)v5 = 0;
  }
  else
  {
    v7 = *(_DWORD *)(v5 + 16) + 1;
    if ( v7 )
      sub_1002A4B0((void *)v3, (const void *)v6, v7);
  }
  *(_DWORD *)(v3 + 16) = *(_DWORD *)(v6 + 16);
  *(_DWORD *)(v3 + 20) = *(_DWORD *)(v6 + 20);
  *(_DWORD *)(v6 + 20) = 15;
  *(_DWORD *)(v6 + 16) = 0;
  result = v3;
  *(_BYTE *)v6 = 0;
  return result;
}

//----- (10015700) --------------------------------------------------------
#error "100159A3: positive sp value has been found (funcsize=219)"

//----- (100159B0) --------------------------------------------------------
int __usercall sub_100159B0<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4)
{
  int v4; // edx@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // ecx@5
  int v8; // esi@6
  int v9; // eax@10
  int v10; // edx@17
  int v11; // ecx@17
  char v13; // [sp+Ch] [bp-2Ch]@16
  int v14; // [sp+18h] [bp-20h]@1
  int v15; // [sp+1Ch] [bp-1Ch]@1
  char v16; // [sp+20h] [bp-18h]@1
  char v17; // [sp+24h] [bp-14h]@2
  unsigned int v18; // [sp+28h] [bp-10h]@1
  int v19; // [sp+34h] [bp-4h]@1
  int v20; // [sp+38h] [bp+0h]@1

  v18 = (unsigned int)&v20 ^ __security_cookie;
  v14 = a4;
  sub_10029A76(a1, (int)&v16, a2, a3, 0);
  v19 = 0;
  v6 = dword_10076888;
  v5 = dword_100762A0;
  v15 = dword_100762A0;
  if ( !dword_10076888 )
  {
    sub_10029A76(v4, (int)&v17, dword_100762A0, dword_10076888, dword_10076888);
    if ( dword_10076888 == v6 )
    {
      ++dword_100750C4;
      dword_10076888 = dword_100750C4;
    }
    sub_10029AD2(&v17);
    v6 = dword_10076888;
  }
  v7 = *(_DWORD *)a4;
  if ( (unsigned int)v6 >= *(_DWORD *)(*(_DWORD *)a4 + 12) )
  {
    v8 = 0;
  }
  else
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v7 + 8) + 4 * v6);
    if ( v8 )
      goto LABEL_18;
  }
  if ( !*(_BYTE *)(v7 + 20) )
    goto LABEL_12;
  v9 = sub_10029877();
  if ( (unsigned int)v6 < *(_DWORD *)(v9 + 12) )
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v9 + 8) + 4 * v6);
LABEL_12:
    if ( v8 )
      goto LABEL_18;
  }
  if ( v5 )
  {
    v8 = v5;
  }
  else
  {
    if ( sub_10015DA0(v7, v4, (int)&v15, v14) == -1 )
    {
      sub_1002AE51((int)&v13, (unsigned int)"bad cast");
      sub_100355BB((int)&v13, (int)&unk_1006C964);
    }
    v8 = v15;
    dword_100762A0 = v15;
    (*(void (__thiscall **)(int))(*(_DWORD *)v15 + 4))(v15);
    sub_1002984F(v10, v11, v5, v6, v8);
  }
LABEL_18:
  sub_10029AD2(&v16);
  return v8;
}
// 10073200: using guessed type int __security_cookie;
// 100750C4: using guessed type int dword_100750C4;
// 100762A0: using guessed type int dword_100762A0;
// 10076888: using guessed type int dword_10076888;

//----- (10015AE0) --------------------------------------------------------
int __thiscall sub_10015AE0(void *this, int a2, int a3)
{
  int v3; // edx@1
  int v4; // ecx@1
  void *v5; // ebx@1
  int i; // eax@2
  int result; // eax@4
  int v8; // ecx@4

  v5 = this;
  *(_DWORD *)(*(_DWORD *)this + 4) = sub_100163C0(this, *(_DWORD *)(*(_DWORD *)a2 + 4), *(_DWORD *)this, a3);
  v3 = *(_DWORD *)v5;
  *((_DWORD *)v5 + 1) = *(_DWORD *)(a2 + 4);
  v4 = *(_DWORD *)(v3 + 4);
  if ( *(_BYTE *)(v4 + 13) )
  {
    *(_DWORD *)v3 = v3;
    result = *(_DWORD *)v5;
    *(_DWORD *)(result + 8) = result;
  }
  else
  {
    for ( i = *(_DWORD *)v4; !*(_BYTE *)(i + 13); i = *(_DWORD *)i )
      v4 = i;
    *(_DWORD *)v3 = v4;
    v8 = *(_DWORD *)(*(_DWORD *)v5 + 4);
    for ( result = *(_DWORD *)(v8 + 8); !*(_BYTE *)(result + 13); result = *(_DWORD *)(result + 8) )
      v8 = result;
    *(_DWORD *)(*(_DWORD *)v5 + 8) = v8;
  }
  return result;
}

//----- (10015B60) --------------------------------------------------------
int __usercall sub_10015B60<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int **a4, int a5, int a6, int **a7, int a8, int a9, int **a10, int a11, int a12)
{
  int v12; // edi@1
  int v14; // [sp-2Ch] [bp-50h]@9
  int v15; // [sp-20h] [bp-44h]@5
  int v16; // [sp-14h] [bp-38h]@1
  char v17; // [sp+8h] [bp-1Ch]@3
  char v18; // [sp+Ch] [bp-18h]@7
  int v19; // [sp+10h] [bp-14h]@11
  unsigned int v20; // [sp+14h] [bp-10h]@1
  int v21; // [sp+20h] [bp-4h]@5
  int v22; // [sp+24h] [bp+0h]@1

  v20 = (unsigned int)&v22 ^ __security_cookie;
  v12 = a2;
  v16 = 0;
  if ( a10 )
  {
    if ( *a10 )
    {
      v16 = **a10;
    }
    else
    {
      sub_10029A76(a1, (int)&v17, a3, a2, 3);
      sub_10029AD2(&v17);
    }
  }
  v21 = 0;
  v15 = 0;
  if ( a7 )
  {
    if ( *a7 )
    {
      v15 = **a7;
    }
    else
    {
      sub_10029A76(a1, (int)&v18, a3, v12, 3);
      sub_10029AD2(&v18);
    }
  }
  LOBYTE(v21) = 1;
  v14 = 0;
  if ( a4 )
  {
    if ( *a4 )
    {
      v14 = **a4;
    }
    else
    {
      sub_10029A76(a1, (int)&v19, a3, v12, 3);
      sub_10029AD2(&v19);
    }
  }
  v21 = -1;
  sub_10016480(a1, v12, v12, v14, 0, a6, v15, 0, a9, v16, 0, a12);
  return v12;
}
// 10073200: using guessed type int __security_cookie;

//----- (10015C80) --------------------------------------------------------
int __usercall sub_10015C80<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int **a4, int a5, int a6, int **a7, int a8, int a9, int **a10, int a11, int a12)
{
  int v12; // edi@1
  int v14; // [sp-2Ch] [bp-50h]@9
  int v15; // [sp-20h] [bp-44h]@5
  int v16; // [sp-14h] [bp-38h]@1
  char v17; // [sp+8h] [bp-1Ch]@3
  char v18; // [sp+Ch] [bp-18h]@7
  int v19; // [sp+10h] [bp-14h]@11
  unsigned int v20; // [sp+14h] [bp-10h]@1
  int v21; // [sp+20h] [bp-4h]@5
  int v22; // [sp+24h] [bp+0h]@1

  v20 = (unsigned int)&v22 ^ __security_cookie;
  v12 = a2;
  v16 = 0;
  if ( a10 )
  {
    if ( *a10 )
    {
      v16 = **a10;
    }
    else
    {
      sub_10029A76(a1, (int)&v17, a3, a2, 3);
      sub_10029AD2(&v17);
    }
  }
  v21 = 0;
  v15 = 0;
  if ( a7 )
  {
    if ( *a7 )
    {
      v15 = **a7;
    }
    else
    {
      sub_10029A76(a1, (int)&v18, a3, v12, 3);
      sub_10029AD2(&v18);
    }
  }
  LOBYTE(v21) = 1;
  v14 = 0;
  if ( a4 )
  {
    if ( *a4 )
    {
      v14 = **a4;
    }
    else
    {
      sub_10029A76(a1, (int)&v19, a3, v12, 3);
      sub_10029AD2(&v19);
    }
  }
  v21 = -1;
  sub_10016570(v12, v12, v14, 0, a6, v15, 0, a9, v16, 0, a12);
  return v12;
}
// 10073200: using guessed type int __security_cookie;

//----- (10015DA0) --------------------------------------------------------
signed int __fastcall sub_10015DA0(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edx@3
  int v6; // esi@3
  int v7; // ecx@4
  int v8; // eax@5
  char v10; // [sp+10h] [bp-44h]@8
  int v11; // [sp+44h] [bp-10h]@1
  int v12; // [sp+50h] [bp-4h]@3

  v4 = 0;
  v11 = 0;
  if ( a3 )
  {
    if ( !*(_DWORD *)a3 )
    {
      v6 = sub_1002ADB1(a2, a1, 0, a3, 8);
      v12 = 0;
      if ( v6 )
      {
        v7 = *(_DWORD *)a4;
        if ( *(_DWORD *)a4 )
        {
          v8 = *(_DWORD *)(v7 + 24);
          if ( !v8 )
            v8 = v7 + 28;
        }
        else
        {
          v8 = (int)&unk_1006723C;
        }
        sub_100178F0(v5, (int)&v10, 0, v8);
        v4 = 1;
        *(_DWORD *)(v6 + 4) = 0;
        *(_DWORD *)v6 = &off_10060700;
      }
      else
      {
        v6 = 0;
      }
      *(_DWORD *)a3 = v6;
      if ( v4 & 1 )
        sub_100179E0(&v10, v4);
    }
  }
  return 4;
}
// 10060700: using guessed type int (__stdcall *off_10060700)(char);

//----- (100160E0) --------------------------------------------------------
int __stdcall sub_100160E0(int a1)
{
  int v1; // edx@1
  int v2; // ebx@1
  int v3; // eax@4
  bool v4; // eax@7
  char v6; // [sp+0h] [bp-2Ch]@1
  int v7; // [sp+10h] [bp-1Ch]@1
  int v8; // [sp+14h] [bp-18h]@1
  int v9; // [sp+18h] [bp-14h]@1
  char *v10; // [sp+1Ch] [bp-10h]@1
  int v11; // [sp+28h] [bp-4h]@1

  v10 = &v6;
  v2 = loc_100166D0();
  v11 = 0;
  v9 = v2;
  *(_WORD *)(v2 + 12) = 0;
  v8 = v2 + 16;
  v7 = v2 + 16;
  LOBYTE(v11) = 1;
  if ( v2 != -16 )
  {
    if ( *(_DWORD *)(a1 + 4) && *(_DWORD *)a1 )
      v3 = loc_1000FED0(*(_DWORD *)a1, -1);
    else
      v3 = *(_DWORD *)a1;
    *(_DWORD *)(v2 + 16) = v3;
    if ( *(_DWORD *)a1 )
      v4 = *(_DWORD *)(a1 + 4) != 0;
    else
      v4 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)(v2 + 20) = v4;
    LOBYTE(v11) = 2;
    sub_10010010(v2 + 24, v1, a1 + 8);
  }
  return v2;
}

//----- (1001618B) --------------------------------------------------------
void __usercall sub_1001618B(int a1<ebp>)
{
  sub_1002A4AA(*(LPVOID *)(a1 - 20));
  sub_100355BB(0, 0);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_100161A0);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100161A0) --------------------------------------------------------
int __thiscall sub_100161A0(int this, int a2, int a3, int a4, int a5)
{
  char v5; // zf@1
  int v7; // edi@3
  int v8; // ecx@4
  int v9; // esi@7
  int v10; // ebx@9
  int v11; // ecx@10
  int v12; // ebx@10
  int v13; // esi@12
  int v14; // ebx@16
  int v15; // eax@21
  char v16; // [sp+0h] [bp-38h]@1
  char v17; // [sp+10h] [bp-28h]@21
  int v18; // [sp+14h] [bp-24h]@1
  int v19; // [sp+18h] [bp-20h]@1
  int v20; // [sp+1Ch] [bp-1Ch]@10
  int v21; // [sp+20h] [bp-18h]@1
  int v22; // [sp+24h] [bp-14h]@1
  char *v23; // [sp+28h] [bp-10h]@1
  int v24; // [sp+34h] [bp-4h]@1

  v23 = &v16;
  v21 = this;
  v24 = 0;
  v5 = *(_DWORD *)(this + 4) == 0;
  v19 = a2;
  v22 = a5;
  v18 = a5;
  if ( v5 )
  {
    sub_10016710(this, a2, a2, 1, *(_DWORD *)this, a5, a5);
    return a2;
  }
  v7 = *(_DWORD *)this;
  if ( a3 == **(_DWORD **)this )
  {
    if ( sub_10013390(a4, a3 + 16) )
    {
      sub_10016710(v21, a2, a2, 1, a3, v8, v22);
      return a2;
    }
  }
  else
  {
    if ( a3 == v7 )
    {
      v9 = *(_DWORD *)(v7 + 8);
      if ( sub_10013390(v9 + 16, a4) )
      {
        sub_10016710(v21, a2, a2, 0, v9, v8, v22);
        return a2;
      }
    }
    else
    {
      v10 = a4;
      if ( sub_10013390(a4, a3 + 16) )
      {
        v20 = a3;
        sub_10013460(&v20);
        v12 = v20;
        if ( sub_10013390(v20 + 16, a4) )
        {
          if ( *(_BYTE *)(*(_DWORD *)(v12 + 8) + 13) )
          {
            v13 = v19;
            sub_10016710(v21, v12, v19, 0, v12, v11, v22);
          }
          else
          {
            v13 = v19;
            sub_10016710(v21, v12, v19, 1, a3, v11, v22);
          }
          return v13;
        }
        v10 = a4;
      }
      if ( sub_10013390(a3 + 16, v10) )
      {
        v20 = a3;
        sub_10013410(&v20);
        v14 = v20;
        if ( v20 == v7 || sub_10013390(a4, v20 + 16) )
        {
          if ( *(_BYTE *)(*(_DWORD *)(a3 + 8) + 13) )
          {
            v13 = v19;
            sub_10016710(v21, v14, v19, 0, a3, v8, v22);
          }
          else
          {
            v13 = v19;
            sub_10016710(v21, v14, v19, 1, v14, v8, v22);
          }
          return v13;
        }
      }
    }
  }
  v24 = -1;
  v15 = sub_10016980((void *)v21, (int)&v17, v8, a4, v22);
  v13 = v19;
  *(_DWORD *)v19 = *(_DWORD *)v15;
  return v13;
}

//----- (100163A0) --------------------------------------------------------
void __thiscall sub_100163A0(int this)
{
  if ( this )
  {
    *(_DWORD *)(this + 32) = 15;
    *(_DWORD *)(this + 28) = 0;
    *(_BYTE *)(this + 12) = 0;
  }
}

//----- (100163C0) --------------------------------------------------------
int __thiscall sub_100163C0(void *this, int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // eax@2
  int v6; // ebx@2
  char v7; // zf@2
  char v9; // [sp+0h] [bp-24h]@1
  void *v10; // [sp+10h] [bp-14h]@1
  char *v11; // [sp+14h] [bp-10h]@1
  int v12; // [sp+20h] [bp-4h]@2

  v11 = &v9;
  v10 = this;
  v4 = *(_DWORD *)this;
  if ( !*(_BYTE *)(a2 + 13) )
  {
    v5 = sub_100160E0(a2 + 16);
    v6 = v5;
    *(_DWORD *)(v5 + 4) = a3;
    *(_BYTE *)(v5 + 12) = *(_BYTE *)(a2 + 12);
    v7 = *(_BYTE *)(v4 + 13) == 0;
    v12 = 0;
    if ( !v7 )
      v4 = v5;
    *(_DWORD *)v5 = sub_100163C0(*(_DWORD *)a2, v5, a4);
    *(_DWORD *)(v6 + 8) = sub_100163C0(*(_DWORD *)(a2 + 8), v6, a4);
  }
  return v4;
}

//----- (10016480) --------------------------------------------------------
int __usercall sub_10016480<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12)
{
  int v12; // eax@1
  int v13; // ebx@1
  int v14; // eax@3
  int v15; // edx@3
  int v16; // eax@5
  int v18; // ecx@5
  int v19; // eax@5
  int v22; // [sp-8h] [bp-14h]@2
  char v23; // [sp+4h] [bp-8h]@13
  unsigned int v24; // [sp+8h] [bp-4h]@1
  int v25; // [sp+Ch] [bp+0h]@1
  int v26; // [sp+28h] [bp+1Ch]@3

  v24 = (unsigned int)&v25 ^ __security_cookie;
  v12 = a9;
  v13 = a2;
  if ( a6 != a9 )
  {
    v22 = a3;
    do
    {
      v15 = a7;
      v14 = v12 - 1;
      v26 = v14;
      if ( a7 )
        v15 = *(_DWORD *)a7;
      v18 = v14 & (*(_DWORD *)(v15 + 8) - 1);
      v19 = *(_DWORD *)(v15 + 4);
      a1 = a10;
      _ESI = *(_DWORD *)(v19 + 4 * v18);
      v16 = a12-- - 1;
      if ( a10 )
        a1 = *(_DWORD *)a10;
      __asm { movq    xmm0, qword ptr [esi] }
      _EDI = *(_DWORD *)(*(_DWORD *)(a1 + 4) + 4 * (v16 & (*(_DWORD *)(a1 + 8) - 1)));
      __asm { movq    qword ptr [edi], xmm0 }
      *(_DWORD *)(_EDI + 8) = *(_DWORD *)(_ESI + 8);
      if ( _EDI + 12 != _ESI + 12 )
        loc_1000AB40(_EDI + 12, _ESI + 12, 0, -1);
      *(_DWORD *)(_EDI + 36) = *(_DWORD *)(_ESI + 36);
      v12 = v26;
    }
    while ( a6 != v26 );
    a3 = v22;
  }
  *(_DWORD *)v13 = 0;
  *(_DWORD *)(v13 + 4) = 0;
  if ( a10 )
  {
    if ( !*(_DWORD *)a10 )
    {
      sub_10029A76(a1, (int)&v23, v13, a3, 3);
      sub_10029AD2(&v23);
      *(_DWORD *)(v13 + 8) = a12;
      return v13;
    }
    *(_DWORD *)v13 = **(_DWORD **)a10;
  }
  *(_DWORD *)(v13 + 8) = a12;
  return v13;
}
// 10073200: using guessed type int __security_cookie;

//----- (10016570) --------------------------------------------------------
int __usercall sub_10016570<eax>(int a1<ecx>, int a2<edi>, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11)
{
  int v11; // eax@1
  int v12; // edx@1
  int v13; // ebx@1
  int v14; // esi@4
  int v15; // edi@7
  int v19; // [sp-8h] [bp-14h]@2
  char v20; // [sp+4h] [bp-8h]@15
  unsigned int v21; // [sp+8h] [bp-4h]@1
  int v22; // [sp+Ch] [bp+0h]@1

  v21 = (unsigned int)&v22 ^ __security_cookie;
  v11 = a5;
  v12 = a11;
  v13 = a1;
  if ( a5 != a8 )
  {
    v19 = a2;
    do
    {
      if ( a3 )
        v14 = *(_DWORD *)a3;
      else
        v14 = 0;
      if ( a9 )
        v15 = *(_DWORD *)a9;
      else
        v15 = 0;
      _ESI = *(_DWORD *)(*(_DWORD *)(v14 + 4) + 4 * (v11 & (*(_DWORD *)(v14 + 8) - 1)));
      __asm { movq    xmm0, qword ptr [esi] }
      _EDI = *(_DWORD *)(*(_DWORD *)(v15 + 4) + 4 * (v12 & (*(_DWORD *)(v15 + 8) - 1)));
      __asm { movq    qword ptr [edi], xmm0 }
      *(_DWORD *)(_EDI + 8) = *(_DWORD *)(_ESI + 8);
      if ( _EDI + 12 != _ESI + 12 )
        loc_1000AB40(_EDI + 12, _ESI + 12, 0, -1);
      *(_DWORD *)(_EDI + 36) = *(_DWORD *)(_ESI + 36);
      v11 = a5 + 1;
      v12 = a11++ + 1;
      a5 = v11;
    }
    while ( v11 != a8 );
    a2 = v19;
  }
  *(_DWORD *)v13 = 0;
  *(_DWORD *)(v13 + 4) = 0;
  if ( a9 )
  {
    if ( !*(_DWORD *)a9 )
    {
      sub_10029A76(v12, (int)&v20, v13, a2, 3);
      sub_10029AD2(&v20);
      *(_DWORD *)(v13 + 8) = a11;
      return v13;
    }
    *(_DWORD *)v13 = **(_DWORD **)a9;
  }
  *(_DWORD *)(v13 + 8) = v12;
  return v13;
}
// 10073200: using guessed type int __security_cookie;

//----- (10016660) --------------------------------------------------------
int __userpurge sub_10016660<eax>(int a1<ebx>, int a2)
{
  sub_100101D0(a2 + 24, a1);
  if ( *(_DWORD *)(a2 + 16) )
  {
    if ( *(_DWORD *)(a2 + 20) == 1 )
      sub_100309C2(a1, *(LPVOID *)(a2 + 16));
  }
  return sub_1002A4AA((LPVOID)a2);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10016710) --------------------------------------------------------
int __userpurge sub_10016710<eax>(int a1<ecx>, int a2<ebx>, int a3, char a4, int a5, int a6, int a7)
{
  unsigned int v7; // eax@1
  int v8; // edi@1
  int v9; // eax@13
  int v10; // edx@14
  int v11; // ecx@14
  int v12; // esi@14
  int v13; // edx@17
  int v14; // ecx@21
  int v15; // edx@25
  int v16; // ecx@25
  int v17; // esi@25
  int v18; // ecx@29
  int v19; // edx@35
  int v20; // ecx@35
  int v21; // ecx@39
  int v22; // ecx@47
  int result; // eax@53

  v8 = a1;
  v7 = *(_DWORD *)(a1 + 4);
  if ( v7 >= 0x6666665 )
  {
    v8 = a7;
    *(_DWORD *)&a4 = a7 + 16;
    sub_100101D0(a7 + 24, a2);
    if ( *(_DWORD *)(a7 + 16) )
    {
      if ( *(_DWORD *)(a7 + 20) == 1 )
        sub_100309C2(a2, *(LPVOID *)(a7 + 16));
    }
    sub_1002A4AA((LPVOID)a7);
    sub_10029585((int)"map/set<T> too long");
  }
  *(_DWORD *)(v8 + 4) = v7 + 1;
  *(_DWORD *)(a7 + 4) = a5;
  if ( a5 == *(_DWORD *)v8 )
  {
    *(_DWORD *)(*(_DWORD *)v8 + 4) = a7;
    **(_DWORD **)v8 = a7;
    *(_DWORD *)(*(_DWORD *)v8 + 8) = a7;
  }
  else
  {
    if ( a4 )
    {
      *(_DWORD *)a5 = a7;
      if ( a5 == **(_DWORD **)v8 )
        **(_DWORD **)v8 = a7;
    }
    else
    {
      *(_DWORD *)(a5 + 8) = a7;
      if ( a5 == *(_DWORD *)(*(_DWORD *)v8 + 8) )
        *(_DWORD *)(*(_DWORD *)v8 + 8) = a7;
    }
  }
  v9 = a7;
  while ( !*(_BYTE *)(*(_DWORD *)(v9 + 4) + 12) )
  {
    v11 = *(_DWORD *)(v9 + 4);
    v12 = *(_DWORD *)(v11 + 4);
    v10 = *(_DWORD *)v12;
    if ( v11 == *(_DWORD *)v12 )
    {
      v10 = *(_DWORD *)(v12 + 8);
      if ( *(_BYTE *)(v10 + 12) )
      {
        if ( v9 == *(_DWORD *)(v11 + 8) )
        {
          v9 = *(_DWORD *)(v9 + 4);
          v13 = *(_DWORD *)(v11 + 8);
          *(_DWORD *)(v11 + 8) = *(_DWORD *)v13;
          if ( !*(_BYTE *)(*(_DWORD *)v13 + 13) )
            *(_DWORD *)(*(_DWORD *)v13 + 4) = v9;
          *(_DWORD *)(v13 + 4) = *(_DWORD *)(v9 + 4);
          if ( v9 == *(_DWORD *)(*(_DWORD *)v8 + 4) )
          {
            *(_DWORD *)(*(_DWORD *)v8 + 4) = v13;
          }
          else
          {
            v14 = *(_DWORD *)(v9 + 4);
            if ( v9 == *(_DWORD *)v14 )
              *(_DWORD *)v14 = v13;
            else
              *(_DWORD *)(v14 + 8) = v13;
          }
          *(_DWORD *)v13 = v9;
          *(_DWORD *)(v9 + 4) = v13;
        }
        *(_BYTE *)(*(_DWORD *)(v9 + 4) + 12) = 1;
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 12) = 0;
        v15 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
        v17 = *(_DWORD *)v15;
        *(_DWORD *)v15 = *(_DWORD *)(*(_DWORD *)v15 + 8);
        v16 = *(_DWORD *)(v17 + 8);
        if ( !*(_BYTE *)(v16 + 13) )
          *(_DWORD *)(v16 + 4) = v15;
        *(_DWORD *)(v17 + 4) = *(_DWORD *)(v15 + 4);
        if ( v15 == *(_DWORD *)(*(_DWORD *)v8 + 4) )
        {
          *(_DWORD *)(*(_DWORD *)v8 + 4) = v17;
          *(_DWORD *)(v17 + 8) = v15;
        }
        else
        {
          v18 = *(_DWORD *)(v15 + 4);
          if ( v15 == *(_DWORD *)(v18 + 8) )
          {
            *(_DWORD *)(v18 + 8) = v17;
            *(_DWORD *)(v17 + 8) = v15;
          }
          else
          {
            *(_DWORD *)v18 = v17;
            *(_DWORD *)(v17 + 8) = v15;
          }
        }
LABEL_51:
        *(_DWORD *)(v15 + 4) = v17;
        continue;
      }
    }
    else
    {
      if ( *(_BYTE *)(v10 + 12) )
      {
        if ( v9 == *(_DWORD *)v11 )
        {
          v9 = *(_DWORD *)(v9 + 4);
          v19 = *(_DWORD *)v11;
          *(_DWORD *)v11 = *(_DWORD *)(*(_DWORD *)v11 + 8);
          v20 = *(_DWORD *)(v19 + 8);
          if ( !*(_BYTE *)(v20 + 13) )
            *(_DWORD *)(v20 + 4) = v9;
          *(_DWORD *)(v19 + 4) = *(_DWORD *)(v9 + 4);
          if ( v9 == *(_DWORD *)(*(_DWORD *)v8 + 4) )
          {
            *(_DWORD *)(*(_DWORD *)v8 + 4) = v19;
          }
          else
          {
            v21 = *(_DWORD *)(v9 + 4);
            if ( v9 == *(_DWORD *)(v21 + 8) )
              *(_DWORD *)(v21 + 8) = v19;
            else
              *(_DWORD *)v21 = v19;
          }
          *(_DWORD *)(v19 + 8) = v9;
          *(_DWORD *)(v9 + 4) = v19;
        }
        *(_BYTE *)(*(_DWORD *)(v9 + 4) + 12) = 1;
        *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 12) = 0;
        v15 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
        v17 = *(_DWORD *)(v15 + 8);
        *(_DWORD *)(v15 + 8) = *(_DWORD *)v17;
        if ( !*(_BYTE *)(*(_DWORD *)v17 + 13) )
          *(_DWORD *)(*(_DWORD *)v17 + 4) = v15;
        *(_DWORD *)(v17 + 4) = *(_DWORD *)(v15 + 4);
        if ( v15 == *(_DWORD *)(*(_DWORD *)v8 + 4) )
        {
          *(_DWORD *)(*(_DWORD *)v8 + 4) = v17;
        }
        else
        {
          v22 = *(_DWORD *)(v15 + 4);
          if ( v15 == *(_DWORD *)v22 )
            *(_DWORD *)v22 = v17;
          else
            *(_DWORD *)(v22 + 8) = v17;
        }
        *(_DWORD *)v17 = v15;
        goto LABEL_51;
      }
    }
    *(_BYTE *)(v11 + 12) = 1;
    *(_BYTE *)(v10 + 12) = 1;
    *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v9 + 4) + 4) + 12) = 0;
    v9 = *(_DWORD *)(*(_DWORD *)(v9 + 4) + 4);
  }
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)v8 + 4) + 12) = 1;
  result = a3;
  *(_DWORD *)a3 = a7;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10016980) --------------------------------------------------------
int __thiscall sub_10016980(void *this, int a2, int a3, int a4, int a5)
{
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // ebx@1
  int v9; // edi@1
  int v10; // esi@1
  char v11; // zf@1
  int v12; // edi@2
  int v13; // eax@4
  int v14; // ecx@4
  char v15; // dl@7
  int v16; // esi@17
  int result; // eax@20
  int v18; // ecx@20
  int v19; // eax@22
  char v20; // dl@26
  int v22; // ebx@33
  int v23; // edi@33
  char v24; // [sp-10h] [bp-40h]@19
  int v25; // [sp-Ch] [bp-3Ch]@19
  int v26; // [sp-8h] [bp-38h]@19
  int v27; // [sp-4h] [bp-34h]@19
  char v28; // [sp+0h] [bp-30h]@1
  int v29; // [sp+10h] [bp-20h]@1
  int v30; // [sp+14h] [bp-1Ch]@1
  int v31; // [sp+18h] [bp-18h]@1
  int v32; // [sp+1Ch] [bp-14h]@1
  char *v33; // [sp+20h] [bp-10h]@1
  int v34; // [sp+2Ch] [bp-4h]@1

  v33 = &v28;
  v9 = (int)this;
  v29 = (int)this;
  v34 = 0;
  v6 = *(_DWORD *)this;
  v8 = a4;
  v10 = *(_DWORD *)(*(_DWORD *)this + 4);
  v7 = v6;
  v11 = *(_BYTE *)(v10 + 13) == 0;
  _AL = 1;
  v30 = v6;
  v32 = v6;
  LOBYTE(v31) = 1;
  if ( v11 )
  {
    v12 = *(_DWORD *)a4;
    do
    {
      v7 = v10;
      v32 = v10;
      if ( v12 )
      {
        v14 = *(_DWORD *)(v10 + 16);
        v13 = v12;
        while ( *(_BYTE *)v13 == *(_BYTE *)v14 )
        {
          if ( !*(_BYTE *)v13 )
            goto LABEL_9;
          v15 = *(_BYTE *)(v13 + 1);
          if ( v15 != *(_BYTE *)(v14 + 1) )
            break;
          v13 += 2;
          v14 += 2;
          if ( !v15 )
          {
LABEL_9:
            v7 = v32;
            __asm { sets    al }
            goto LABEL_12;
          }
        }
        v7 = v32;
        __asm { sets    al }
      }
      else
      {
        _AL = *(_DWORD *)(a4 + 4) < *(_DWORD *)(v10 + 20);
      }
LABEL_12:
      LOBYTE(v31) = _AL;
      if ( _AL )
        v10 = *(_DWORD *)v10;
      else
        v10 = *(_DWORD *)(v10 + 8);
    }
    while ( !*(_BYTE *)(v10 + 13) );
    v6 = v30;
    v9 = v29;
  }
  v16 = v7;
  a4 = v7;
  if ( _AL )
  {
    if ( v7 == *(_DWORD *)v6 )
    {
      v27 = a5;
      v26 = v7;
      v25 = v7;
      v24 = 1;
LABEL_20:
      v18 = *(_DWORD *)sub_10016710(v9, v8, (int)&a4, v24, v25, v26, v27);
      result = a2;
      *(_DWORD *)a2 = v18;
      *(_BYTE *)(a2 + 4) = 1;
      return result;
    }
    sub_10013460(&a4);
    v16 = a4;
  }
  v19 = *(_DWORD *)(v16 + 16);
  if ( v19 )
  {
    v7 = *(_DWORD *)v8;
    while ( *(_BYTE *)v19 == *(_BYTE *)v7 )
    {
      if ( !*(_BYTE *)v19 )
        goto LABEL_28;
      v20 = *(_BYTE *)(v19 + 1);
      if ( v20 != *(_BYTE *)(v7 + 1) )
        break;
      v19 += 2;
      v7 += 2;
      if ( !v20 )
      {
LABEL_28:
        __asm { sets    al }
        goto LABEL_31;
      }
    }
    __asm { sets    al }
  }
  else
  {
    _AL = *(_DWORD *)(v16 + 20) < *(_DWORD *)(v8 + 4);
  }
LABEL_31:
  if ( _AL )
  {
    v27 = a5;
    v26 = v7;
    v25 = v32;
    v24 = v31;
    goto LABEL_20;
  }
  v22 = a5;
  v23 = a5 + 16;
  a4 = a5 + 16;
  LOBYTE(v34) = 1;
  sub_100101D0(a5 + 24, a5);
  if ( *(_DWORD *)v23 )
  {
    if ( *(_DWORD *)(v23 + 4) == 1 )
      sub_100309C2(v22, *(LPVOID *)v23);
  }
  sub_1002A4AA((LPVOID)v22);
  result = a2;
  *(_DWORD *)a2 = v16;
  *(_BYTE *)(a2 + 4) = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10016B40) --------------------------------------------------------
int __fastcall sub_10016B40(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@2
  int v5; // esi@2
  int result; // eax@10

  v3 = a2;
  if ( a1 == a2 )
  {
    result = a3;
  }
  else
  {
    v4 = a3;
    v5 = a1 + 16;
    do
    {
      if ( v4 )
      {
        *(_DWORD *)(v4 + 20) = 15;
        *(_DWORD *)(v4 + 16) = 0;
        *(_BYTE *)v4 = 0;
        if ( *(_DWORD *)(v5 + 4) >= 0x10u )
        {
          *(_DWORD *)v4 = *(_DWORD *)(v5 - 16);
          *(_DWORD *)(v5 - 16) = 0;
        }
        else
        {
          if ( *(_DWORD *)v5 != -1 )
            sub_1002A4B0((void *)v4, (const void *)(v5 - 16), *(_DWORD *)v5 + 1);
        }
        *(_DWORD *)(v4 + 16) = *(_DWORD *)v5;
        *(_DWORD *)(v4 + 20) = *(_DWORD *)(v5 + 4);
        *(_DWORD *)(v5 + 4) = 15;
        *(_DWORD *)v5 = 0;
        *(_BYTE *)(v5 - 16) = 0;
      }
      v5 += 24;
      v4 += 24;
    }
    while ( v5 - 16 != v3 );
    result = v4;
  }
  return result;
}

//----- (10016BC4) --------------------------------------------------------
int __thiscall sub_10016BC4(void *this)
{
  return nullsub_3(this + -*((_DWORD *)this - 1) - 72);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (10016BCF) --------------------------------------------------------
void *__thiscall sub_10016BCF(void *this, char a2)
{
  return sub_10012F00((char *)this - *((_DWORD *)this - 1), a2);
}

//----- (10016CF0) --------------------------------------------------------
int __thiscall sub_10016CF0(void *this, int a2)
{
  (*(void (__stdcall **)(int, _DWORD))(*(_DWORD *)this + 20))(a2, 0);
  return a2;
}

//----- (10016D10) --------------------------------------------------------
int __thiscall sub_10016D10(void *this, int a2)
{
  (*(void (__stdcall **)(int, _DWORD))(*(_DWORD *)this + 24))(a2, 0);
  return a2;
}

//----- (10016D30) --------------------------------------------------------
int __thiscall sub_10016D30(void *this, int a2)
{
  (*(void (__stdcall **)(int, _DWORD))(*(_DWORD *)this + 28))(a2, 0);
  return a2;
}

//----- (10016D50) --------------------------------------------------------
int __thiscall sub_10016D50(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  if ( this != a2 )
  {
    if ( *(_DWORD *)(this + 20) >= 0x10u )
      sub_1002A4AA(*(LPVOID *)this);
    *(_DWORD *)(v2 + 20) = 15;
    *(_DWORD *)(v2 + 16) = 0;
    *(_BYTE *)v2 = 0;
    if ( *(_DWORD *)(a2 + 20) >= 0x10u )
    {
      *(_DWORD *)v2 = *(_DWORD *)a2;
      *(_DWORD *)a2 = 0;
    }
    else
    {
      if ( *(_DWORD *)(a2 + 16) != -1 )
        sub_1002A4B0((void *)v2, (const void *)a2, *(_DWORD *)(a2 + 16) + 1);
    }
    *(_DWORD *)(v2 + 16) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(v2 + 20) = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(a2 + 20) = 15;
    *(_DWORD *)(a2 + 16) = 0;
    *(_BYTE *)a2 = 0;
  }
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10016DD0) --------------------------------------------------------
int __thiscall sub_10016DD0(int this, char a2)
{
  int v2; // esi@1
  void *v3; // ST08_4@1

  v2 = this;
  v3 = *(void **)(this + 8);
  *(_DWORD *)this = &off_10060730;
  sub_100303A3(v3);
  sub_100303A3(*(LPVOID *)(v2 + 16));
  sub_100303A3(*(LPVOID *)(v2 + 20));
  *(_DWORD *)v2 = &off_10060654;
  if ( a2 & 1 )
    sub_1002A4AA((LPVOID)v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 10060654: using guessed type int (__stdcall *off_10060654)(char);
// 10060730: using guessed type int (__stdcall *off_10060730)(char);

//----- (10016E20) --------------------------------------------------------
char __thiscall sub_10016E20(int this)
{
  return *(_BYTE *)(this + 12);
}

//----- (10016E30) --------------------------------------------------------
char __thiscall sub_10016E30(int this)
{
  return *(_BYTE *)(this + 13);
}

//----- (10016E40) --------------------------------------------------------
int __thiscall sub_10016E40(int this, int a2)
{
  const char *v2; // edx@1
  int result; // eax@2

  v2 = *(const char **)(this + 8);
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  if ( *v2 )
  {
    loc_1000AEB0(a2, v2, strlen(v2));
    result = a2;
  }
  else
  {
    loc_1000AEB0(a2, v2, 0);
    result = a2;
  }
  return result;
}

//----- (10016EA0) --------------------------------------------------------
int __thiscall sub_10016EA0(int this, int a2)
{
  const char *v2; // edx@1
  int result; // eax@2

  v2 = *(const char **)(this + 16);
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  if ( *v2 )
  {
    loc_1000AEB0(a2, v2, strlen(v2));
    result = a2;
  }
  else
  {
    loc_1000AEB0(a2, v2, 0);
    result = a2;
  }
  return result;
}

//----- (10016F00) --------------------------------------------------------
int __thiscall sub_10016F00(int this, int a2)
{
  const char *v2; // edx@1
  int result; // eax@2

  v2 = *(const char **)(this + 20);
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  if ( *v2 )
  {
    loc_1000AEB0(a2, v2, strlen(v2));
    result = a2;
  }
  else
  {
    loc_1000AEB0(a2, v2, 0);
    result = a2;
  }
  return result;
}

//----- (10016F60) --------------------------------------------------------
int __thiscall sub_10016F60(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100303A3(*(LPVOID *)(this + 8));
  sub_100303A3(*(LPVOID *)(v2 + 16));
  return sub_100303A3(*(LPVOID *)(v2 + 20));
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (10016F80) --------------------------------------------------------
int __userpurge sub_10016F80<eax>(int a1<ecx>, int a2<edi>, int a3, char a4)
{
  int v4; // ebx@1
  void **v5; // esi@1
  void *v6; // esi@2
  int v7; // edx@4
  int v8; // ecx@4
  void *v9; // edi@4
  char v10; // al@5
  int v11; // eax@6
  int v12; // ecx@6
  int v13; // edi@6
  int v14; // eax@9
  int v15; // edx@9
  int v16; // ecx@9
  signed int v17; // edi@9
  int v18; // esi@9
  int result; // eax@11
  signed int v20; // edi@11
  int v21; // esi@11
  int v22; // ecx@15
  char v23; // [sp+0h] [bp-54h]@1
  char v24; // [sp+10h] [bp-44h]@1
  int v25; // [sp+3Ch] [bp-18h]@1
  int v26; // [sp+40h] [bp-14h]@1
  char *v27; // [sp+44h] [bp-10h]@1
  int v28; // [sp+50h] [bp-4h]@1

  v27 = &v23;
  v4 = a1;
  v26 = a1;
  v5 = sub_10030BE0(a1, a2);
  v25 = (int)v5;
  sub_10029D5C((int)&v24);
  *(_DWORD *)(v4 + 8) = 0;
  *(_DWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 20) = 0;
  v28 = 0;
  if ( a4 )
    v6 = &unk_1006723C;
  else
    v6 = v5[2];
  sub_10029D5C((int)&v24);
  v9 = v6;
  v8 = (int)((char *)v6 + 1);
  do
  {
    v10 = *(_BYTE *)v9;
    v9 = (char *)v9 + 1;
  }
  while ( v10 );
  v13 = (int)(v9 + -v8 + 1);
  v11 = sub_1002965B(v7, v8, v4, v13, v13);
  if ( v13 )
  {
    v12 = v11 - (_DWORD)v6;
    do
    {
      *((_BYTE *)v6 + v12) = *(_BYTE *)v6;
      v6 = (char *)v6 + 1;
      --v13;
    }
    while ( v13 );
  }
  v17 = 6;
  *(_DWORD *)(v4 + 8) = v11;
  v18 = (int)"false";
  v14 = sub_1002965B(v11, v12, v4, 6, 6);
  v15 = v14 - (_DWORD)"false";
  do
  {
    LOBYTE(v16) = *(_BYTE *)v18;
    *(_BYTE *)(v15 + v18) = *(_BYTE *)v18;
    ++v18;
    --v17;
  }
  while ( v17 );
  v20 = 5;
  *(_DWORD *)(v4 + 16) = v14;
  v21 = (int)"true";
  result = sub_1002965B(v15, v16, v4, 5, 5);
  do
  {
    *(_BYTE *)(result - (_DWORD)"true" + v21) = *(_BYTE *)v21;
    ++v21;
    --v20;
  }
  while ( v20 );
  *(_DWORD *)(v4 + 20) = result;
  if ( a4 )
  {
    *(_WORD *)(v4 + 12) = 11310;
  }
  else
  {
    v22 = v25;
    *(_BYTE *)(v4 + 12) = **(_BYTE **)v25;
    result = **(_BYTE **)(v22 + 4);
    *(_BYTE *)(v4 + 13) = result;
  }
  return result;
}

//----- (100170E0) --------------------------------------------------------
signed int __fastcall sub_100170E0(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edx@3
  int v6; // esi@3
  int v7; // ecx@4
  int v8; // eax@5
  int v9; // eax@8
  char v11; // [sp+10h] [bp-44h]@8
  int v12; // [sp+44h] [bp-10h]@1
  int v13; // [sp+50h] [bp-4h]@3

  v4 = 0;
  v12 = 0;
  if ( a3 )
  {
    if ( !*(_DWORD *)a3 )
    {
      v6 = sub_1002ADB1(a2, a1, 0, a3, 24);
      v13 = 0;
      if ( v6 )
      {
        *(_DWORD *)(v6 + 8) = 0;
        *(_DWORD *)(v6 + 16) = 0;
        *(_DWORD *)(v6 + 20) = 0;
        v7 = *(_DWORD *)a4;
        if ( *(_DWORD *)a4 )
        {
          v8 = *(_DWORD *)(v7 + 24);
          if ( !v8 )
            v8 = v7 + 28;
        }
        else
        {
          v8 = (int)&unk_1006723C;
        }
        v9 = sub_100178F0(v5, (int)&v11, 0, v8);
        v4 = 1;
        v12 = 1;
        *(_DWORD *)(v6 + 4) = 0;
        v13 = 2;
        *(_DWORD *)v6 = &off_10060730;
        sub_10016F80(v6, a3, v9, 1);
      }
      else
      {
        v6 = 0;
      }
      *(_DWORD *)a3 = v6;
      if ( v4 & 1 )
        sub_100179E0(&v11, v4);
    }
  }
  return 4;
}
// 10060730: using guessed type int (__stdcall *off_10060730)(char);

//----- (100171B0) --------------------------------------------------------
int __usercall sub_100171B0<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4)
{
  int v4; // edx@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // ecx@5
  int v8; // esi@6
  int v9; // eax@10
  int v10; // edx@17
  int v11; // ecx@17
  char v13; // [sp+Ch] [bp-2Ch]@16
  int v14; // [sp+18h] [bp-20h]@1
  int v15; // [sp+1Ch] [bp-1Ch]@1
  char v16; // [sp+20h] [bp-18h]@1
  char v17; // [sp+24h] [bp-14h]@2
  unsigned int v18; // [sp+28h] [bp-10h]@1
  int v19; // [sp+34h] [bp-4h]@1
  int v20; // [sp+38h] [bp+0h]@1

  v18 = (unsigned int)&v20 ^ __security_cookie;
  v14 = a4;
  sub_10029A76(a1, (int)&v16, a2, a3, 0);
  v19 = 0;
  v6 = dword_10076884;
  v5 = dword_100762A4;
  v15 = dword_100762A4;
  if ( !dword_10076884 )
  {
    sub_10029A76(v4, (int)&v17, dword_100762A4, dword_10076884, dword_10076884);
    if ( dword_10076884 == v6 )
    {
      ++dword_100750C4;
      dword_10076884 = dword_100750C4;
    }
    sub_10029AD2(&v17);
    v6 = dword_10076884;
  }
  v7 = *(_DWORD *)a4;
  if ( (unsigned int)v6 >= *(_DWORD *)(*(_DWORD *)a4 + 12) )
  {
    v8 = 0;
  }
  else
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v7 + 8) + 4 * v6);
    if ( v8 )
      goto LABEL_18;
  }
  if ( !*(_BYTE *)(v7 + 20) )
    goto LABEL_12;
  v9 = sub_10029877();
  if ( (unsigned int)v6 < *(_DWORD *)(v9 + 12) )
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v9 + 8) + 4 * v6);
LABEL_12:
    if ( v8 )
      goto LABEL_18;
  }
  if ( v5 )
  {
    v8 = v5;
  }
  else
  {
    if ( sub_100170E0(v7, v4, (int)&v15, v14) == -1 )
    {
      sub_1002AE51((int)&v13, (unsigned int)"bad cast");
      sub_100355BB((int)&v13, (int)&unk_1006C964);
    }
    v8 = v15;
    dword_100762A4 = v15;
    (*(void (__thiscall **)(int))(*(_DWORD *)v15 + 4))(v15);
    sub_1002984F(v10, v11, v5, v6, v8);
  }
LABEL_18:
  sub_10029AD2(&v16);
  return v8;
}
// 10073200: using guessed type int __security_cookie;
// 100750C4: using guessed type int dword_100750C4;
// 100762A4: using guessed type int dword_100762A4;
// 10076884: using guessed type int dword_10076884;

//----- (100172E0) --------------------------------------------------------
int __thiscall sub_100172E0(int this, char a2)
{
  void *v2; // edi@1
  int v3; // esi@1
  int v4; // eax@3

  v3 = this;
  v2 = *(void **)(this + 52);
  *(_DWORD *)this = &off_10067934;
  if ( v2 )
  {
    if ( *(_DWORD *)v2 )
    {
      v4 = (*(int (**)(void))(**(_DWORD **)v2 + 8))();
      if ( v4 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v4)(v4, 1);
    }
    sub_1002A4AA(v2);
  }
  if ( a2 & 1 )
    sub_1002A4AA((LPVOID)v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067934: using guessed type int (__stdcall *off_10067934)(char);

//----- (10017330) --------------------------------------------------------
signed int __stdcall sub_10017330(int a1)
{
  return -1;
}

//----- (10017340) --------------------------------------------------------
__int64 __cdecl sub_10017340()
{
  return 0i64;
}

//----- (10017350) --------------------------------------------------------
__int64 __thiscall sub_10017350(int this)
{
  __int64 result; // qax@2

  if ( **(_DWORD **)(this + 28) )
    result = **(_DWORD **)(this + 44);
  else
    result = 0i64;
  return result;
}

//----- (10017370) --------------------------------------------------------
signed int __cdecl sub_10017370()
{
  return -1;
}

//----- (10017380) --------------------------------------------------------
int __thiscall sub_10017380(void *this)
{
  int result; // eax@1
  void *v2; // esi@1
  int v3; // ecx@3
  int *v4; // edx@3

  v2 = this;
  result = (*(int (**)(void))(*(_DWORD *)this + 24))();
  if ( result != -1 )
  {
    --**((_DWORD **)v2 + 11);
    v3 = *((_DWORD *)v2 + 7);
    v4 = (int *)*(_DWORD *)v3++;
    result = *(_BYTE *)v4;
  }
  return result;
}

//----- (100173B0) --------------------------------------------------------
int __thiscall sub_100173B0(int this, void *a2, unsigned int a3, int a4)
{
  int v4; // ebx@1
  unsigned int v5; // edi@2
  __int64 v6; // qax@5
  unsigned int v7; // esi@5
  unsigned __int8 v8; // cf@14
  unsigned __int8 v9; // cf@14
  int v10; // eax@15
  unsigned __int8 v11; // cf@16
  unsigned __int8 v12; // cf@16
  int result; // eax@20
  int v14; // [sp+8h] [bp-14h]@4
  int v15; // [sp+Ch] [bp-10h]@4
  int v16; // [sp+10h] [bp-Ch]@1
  __int64 v17; // [sp+14h] [bp-8h]@1
  int v18; // [sp+14h] [bp-8h]@5

  v4 = a4;
  __asm { xorps   xmm0, xmm0 }
  v16 = this;
  __asm { movlpd  [esp+20h+var_8], xmm0 }
  if ( a4 >= 0 && ((v5 = a3, a4 > 0) || a3) )
  {
    v14 = HIDWORD(v17);
    v15 = v17;
    do
    {
      v6 = sub_10017350(this);
      v7 = v6;
      v18 = HIDWORD(v6);
      if ( HIDWORD(v6) >= 0 && (HIDWORD(v6) > 0 || (_DWORD)v6) )
      {
        if ( v4 <= HIDWORD(v6) )
        {
          if ( v4 < HIDWORD(v6) || v5 < (_DWORD)v6 )
          {
            v7 = v5;
            v18 = v4;
          }
        }
        if ( v7 )
          sub_10034EE0(a2, **(const void ***)(v16 + 28), v7);
        a2 = (char *)a2 + v7;
        v8 = v7 >= -v15;
        v15 += v7;
        this = v16;
        v14 += v18 + v8;
        v9 = v5 < v7;
        v5 -= v7;
        v4 -= v9 + v18;
        **(_DWORD **)(v16 + 44) -= v7;
        **(_DWORD **)(v16 + 28) += v7;
      }
      else
      {
        v10 = (*(int (**)(void))(*(_DWORD *)v16 + 28))();
        if ( v10 == -1 )
          break;
        v11 = (unsigned int)v15++ >= 0xFFFFFFFF;
        *(_BYTE *)a2 = v10;
        a2 = (char *)a2 + 1;
        v14 += v11;
        this = v16;
        v12 = v5-- >= 1;
        v4 = v12 + v4 - 1;
      }
    }
    while ( v4 > 0 || v4 >= 0 && v5 );
    result = v15;
  }
  else
  {
    result = v17;
  }
  return result;
}

//----- (100174C0) --------------------------------------------------------
__int64 __thiscall sub_100174C0(int this)
{
  __int64 result; // qax@2

  if ( **(_DWORD **)(this + 32) )
    result = **(_DWORD **)(this + 48);
  else
    result = 0i64;
  return result;
}

//----- (100174E0) --------------------------------------------------------
int __thiscall sub_100174E0(int this, const void *a2, unsigned int a3, int a4)
{
  int v4; // ebx@1
  unsigned int v5; // edi@2
  __int64 v6; // qax@5
  unsigned int v7; // esi@5
  unsigned __int8 v8; // cf@14
  unsigned __int8 v9; // cf@14
  unsigned __int8 v10; // cf@16
  unsigned __int8 v11; // cf@16
  int result; // eax@20
  int v13; // [sp+8h] [bp-14h]@4
  int v14; // [sp+Ch] [bp-10h]@4
  int v15; // [sp+10h] [bp-Ch]@1
  __int64 v16; // [sp+14h] [bp-8h]@1
  int v17; // [sp+14h] [bp-8h]@5

  v4 = a4;
  __asm { xorps   xmm0, xmm0 }
  v15 = this;
  __asm { movlpd  [esp+20h+var_8], xmm0 }
  if ( a4 >= 0 && ((v5 = a3, a4 > 0) || a3) )
  {
    v13 = HIDWORD(v16);
    v14 = v16;
    do
    {
      v6 = sub_100174C0(this);
      v7 = v6;
      v17 = HIDWORD(v6);
      if ( HIDWORD(v6) >= 0 && (HIDWORD(v6) > 0 || (_DWORD)v6) )
      {
        if ( v4 <= HIDWORD(v6) )
        {
          if ( v4 < HIDWORD(v6) || v5 < (_DWORD)v6 )
          {
            v7 = v5;
            v17 = v4;
          }
        }
        if ( v7 )
          sub_10034EE0(**(void ***)(v15 + 32), a2, v7);
        a2 = (char *)a2 + v7;
        v8 = v7 >= -v14;
        v14 += v7;
        this = v15;
        v13 += v17 + v8;
        v9 = v5 < v7;
        v5 -= v7;
        v4 -= v9 + v17;
        **(_DWORD **)(v15 + 48) -= v7;
        **(_DWORD **)(v15 + 32) += v7;
      }
      else
      {
        if ( (*(int (__stdcall **)(_DWORD))(*(_DWORD *)v15 + 12))(*(_BYTE *)a2) == -1 )
          break;
        this = v15;
        v10 = (unsigned int)v14++ >= 0xFFFFFFFF;
        a2 = (char *)a2 + 1;
        v13 += v10;
        v11 = v5-- >= 1;
        v4 = v11 + v4 - 1;
      }
    }
    while ( v4 > 0 || v4 >= 0 && v5 );
    result = v14;
  }
  else
  {
    result = v16;
  }
  return result;
}

//----- (100175F0) --------------------------------------------------------
int __stdcall sub_100175F0(int a1, int a2, int a3, int a4, int a5)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = dword_10060648;
  *(_DWORD *)(a1 + 4) = dword_1006064C;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}
// 10060648: using guessed type int dword_10060648;
// 1006064C: using guessed type int dword_1006064C;

//----- (10017620) --------------------------------------------------------
int __stdcall sub_10017620(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = dword_10060648;
  *(_DWORD *)(a1 + 4) = dword_1006064C;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}
// 10060648: using guessed type int dword_10060648;
// 1006064C: using guessed type int dword_1006064C;

//----- (10017650) --------------------------------------------------------
void *__thiscall sub_10017650(void *this, int a2, int a3, int a4)
{
  return this;
}

//----- (100176B0) --------------------------------------------------------
void *__thiscall sub_100176B0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = (char *)this - 8;
  *(_DWORD *)(this + *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 8) = off_100679B8;
  *(_DWORD *)(this + *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 12) = *(_DWORD *)(*((_DWORD *)this - 2) + 4) - 8;
  *(_DWORD *)this = &off_10067398;
  sub_100296B7((int)this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067398: using guessed type int (__stdcall *off_10067398)(char);
// 100679B8: using guessed type int (*off_100679B8[3])();

//----- (100176F9) --------------------------------------------------------
void *__thiscall sub_100176F9(void *this, char a2)
{
  return sub_100176B0((char *)this - *((_DWORD *)this - 1), a2);
}

//----- (10017701) --------------------------------------------------------
int __thiscall sub_10017701(void *this)
{
  return nullsub_3((char *)this - *((_DWORD *)this - 1));
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (10017710) --------------------------------------------------------
int __usercall sub_10017710<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<ebp>, int a5<edi>)
{
  int result; // eax@1
  int v6; // edi@1
  int v7; // esi@1

  v7 = a2;
  *(_DWORD *)(a2 + 48) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = 513;
  *(_DWORD *)(a2 + 24) = 6;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 32) = 0;
  *(_DWORD *)(a2 + 36) = 0;
  *(_DWORD *)(a2 + 40) = 0;
  *(_DWORD *)(a2 + 44) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  result = sub_1002ADB1(a1, a2, a3, a5, 4);
  v6 = result;
  if ( result )
  {
    *(_DWORD *)result = 0;
    result = sub_1002987D(a3, a4, result);
    *(_DWORD *)v6 = result;
    *(_DWORD *)(v7 + 48) = v6;
  }
  else
  {
    *(_DWORD *)(v7 + 48) = 0;
  }
  return result;
}

//----- (100177A0) --------------------------------------------------------
int __userpurge sub_100177A0<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  int v3; // eax@1
  int v4; // esi@1

  v4 = a1;
  v3 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)a1 = &off_100606D0;
  if ( v3 <= 0 )
  {
    if ( v3 < 0 )
      sub_100303A3(*(LPVOID *)(a1 + 12));
  }
  else
  {
    sub_100309C2(a2, *(LPVOID *)(a1 + 12));
  }
  sub_100309C2(a2, *(LPVOID *)(v4 + 20));
  *(_DWORD *)v4 = &off_10060654;
  if ( a3 & 1 )
    sub_1002A4AA((LPVOID)v4);
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 10060654: using guessed type int (__stdcall *off_10060654)(char);
// 100606D0: using guessed type int (__stdcall *off_100606D0)(char);

//----- (10017800) --------------------------------------------------------
int *__thiscall sub_10017800(void *this, int *a2, int a3)
{
  int *v3; // esi@1
  int v4; // ebx@2

  v3 = a2;
  if ( a2 != (int *)a3 )
  {
    v4 = (int)((char *)this + 8);
    do
    {
      *(_BYTE *)v3 = sub_10029B62(v4, a3, *(_BYTE *)v3, v4);
      v3 = (int *)((char *)v3 + 1);
    }
    while ( v3 != (int *)a3 );
  }
  return v3;
}

//----- (10017830) --------------------------------------------------------
int __userpurge sub_10017830<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned __int8 a4)
{
  return sub_10029B62(a2, a3, a4, a1 + 8);
}

//----- (10017850) --------------------------------------------------------
int *__thiscall sub_10017850(void *this, int *a2, int a3)
{
  int *v3; // esi@1
  int v4; // ebx@2

  v3 = a2;
  if ( a2 != (int *)a3 )
  {
    v4 = (int)((char *)this + 8);
    do
    {
      *(_BYTE *)v3 = sub_10029C5F(v4, a3, *(_BYTE *)v3, v4);
      v3 = (int *)((char *)v3 + 1);
    }
    while ( v3 != (int *)a3 );
  }
  return v3;
}

//----- (10017880) --------------------------------------------------------
int __userpurge sub_10017880<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned __int8 a4)
{
  return sub_10029C5F(a2, a3, a4, a1 + 8);
}

//----- (100178A0) --------------------------------------------------------
int __stdcall sub_100178A0(const void *a1, int a2, void *a3)
{
  sub_10034EE0(a3, a1, a2 - (_DWORD)a1);
  return a2;
}

//----- (100178C0) --------------------------------------------------------
int __stdcall sub_100178C0(const void *a1, int a2, int a3, void *a4)
{
  sub_10034EE0(a4, a1, a2 - (_DWORD)a1);
  return a2;
}

//----- (100178E0) --------------------------------------------------------
char __stdcall sub_100178E0(char a1, int a2)
{
  return a1;
}

//----- (100178F0) --------------------------------------------------------
int __userpurge sub_100178F0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // esi@1
  int (__stdcall **v6)(char); // [sp+8h] [bp-24h]@2
  int v7; // [sp+14h] [bp-18h]@1
  int v8; // [sp+18h] [bp-14h]@2
  unsigned int v9; // [sp+1Ch] [bp-10h]@1
  int v10; // [sp+28h] [bp-4h]@1
  int v11; // [sp+2Ch] [bp+0h]@1

  v9 = (unsigned int)&v11 ^ __security_cookie;
  v4 = a2;
  v7 = a2;
  sub_10029A76(a1, a2, a3, a4, 0);
  v10 = 0;
  *(_DWORD *)(v4 + 4) = 0;
  *(_BYTE *)(v4 + 8) = 0;
  *(_DWORD *)(v4 + 12) = 0;
  *(_BYTE *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 20) = 0;
  *(_WORD *)(v4 + 24) = 0;
  *(_DWORD *)(v4 + 28) = 0;
  *(_WORD *)(v4 + 32) = 0;
  *(_DWORD *)(v4 + 36) = 0;
  *(_BYTE *)(v4 + 40) = 0;
  *(_DWORD *)(v4 + 44) = 0;
  *(_BYTE *)(v4 + 48) = 0;
  LOBYTE(v10) = 6;
  if ( !a4 )
  {
    v8 = (int)"bad locale name";
    sub_1002AEA4((int)&v6, &v8);
    v6 = &off_1005F310;
    sub_100355BB((int)&v6, (int)&unk_1006C92C);
  }
  sub_10029952(v4, (const CHAR *)a4);
  return v4;
}
// 1005F310: using guessed type int (__stdcall *off_1005F310)(char);
// 10073200: using guessed type int __security_cookie;

//----- (100179E0) --------------------------------------------------------
void __usercall sub_100179E0(void *this<ecx>, int a2<ebx>)
{
  void *v2; // esi@1

  v2 = this;
  sub_1002999D((int)this);
  if ( *((_DWORD *)v2 + 11) )
    sub_100309C2(a2, *((LPVOID *)v2 + 11));
  *((_DWORD *)v2 + 11) = 0;
  if ( *((_DWORD *)v2 + 9) )
    sub_100309C2(a2, *((LPVOID *)v2 + 9));
  *((_DWORD *)v2 + 9) = 0;
  if ( *((_DWORD *)v2 + 7) )
    sub_100309C2(a2, *((LPVOID *)v2 + 7));
  *((_DWORD *)v2 + 7) = 0;
  if ( *((_DWORD *)v2 + 5) )
    sub_100309C2(a2, *((LPVOID *)v2 + 5));
  *((_DWORD *)v2 + 5) = 0;
  if ( *((_DWORD *)v2 + 3) )
    sub_100309C2(a2, *((LPVOID *)v2 + 3));
  *((_DWORD *)v2 + 3) = 0;
  if ( *((_DWORD *)v2 + 1) )
    sub_100309C2(a2, *((LPVOID *)v2 + 1));
  *((_DWORD *)v2 + 1) = 0;
  sub_10029AD2(v2);
}

//----- (10017A80) --------------------------------------------------------
signed int __fastcall sub_10017A80(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edx@3
  int v7; // ecx@4
  int v8; // eax@5
  char v11; // [sp+14h] [bp-54h]@8
  char v12; // [sp+48h] [bp-20h]@8
  int v13; // [sp+58h] [bp-10h]@1
  int v14; // [sp+64h] [bp-4h]@3

  v4 = 0;
  v13 = 0;
  if ( a3 )
  {
    if ( !*(_DWORD *)a3 )
    {
      _ESI = sub_1002ADB1(a2, a1, 0, a3, 24);
      v14 = 0;
      if ( _ESI )
      {
        v7 = *(_DWORD *)a4;
        if ( *(_DWORD *)a4 )
        {
          v8 = *(_DWORD *)(v7 + 24);
          if ( !v8 )
            v8 = v7 + 28;
        }
        else
        {
          v8 = (int)&unk_1006723C;
        }
        sub_100178F0(v5, (int)&v11, 0, v8);
        v4 = 1;
        *(_DWORD *)(_ESI + 4) = 0;
        *(_DWORD *)_ESI = &off_100606D0;
        _EAX = sub_10029AF6(1, a3, (int)&v12);
        __asm
        {
          movq    xmm0, qword ptr [eax]
          movq    qword ptr [esi+8], xmm0
          movq    xmm0, qword ptr [eax+8]
          movq    qword ptr [esi+10h], xmm0
        }
      }
      else
      {
        _ESI = 0;
      }
      *(_DWORD *)a3 = _ESI;
      if ( v4 & 1 )
        sub_100179E0(&v11, v4);
    }
  }
  return 2;
}
// 100606D0: using guessed type int (__stdcall *off_100606D0)(char);

//----- (10017B50) --------------------------------------------------------
int __usercall sub_10017B50<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4)
{
  int v4; // edx@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // ecx@5
  int v8; // esi@6
  int v9; // eax@10
  int v10; // edx@17
  int v11; // ecx@17
  char v13; // [sp+Ch] [bp-2Ch]@16
  int v14; // [sp+18h] [bp-20h]@1
  int v15; // [sp+1Ch] [bp-1Ch]@1
  char v16; // [sp+20h] [bp-18h]@1
  char v17; // [sp+24h] [bp-14h]@2
  unsigned int v18; // [sp+28h] [bp-10h]@1
  int v19; // [sp+34h] [bp-4h]@1
  int v20; // [sp+38h] [bp+0h]@1

  v18 = (unsigned int)&v20 ^ __security_cookie;
  v14 = a4;
  sub_10029A76(a1, (int)&v16, a2, a3, 0);
  v19 = 0;
  v6 = dword_100750D4;
  v5 = dword_100762A8;
  v15 = dword_100762A8;
  if ( !dword_100750D4 )
  {
    sub_10029A76(v4, (int)&v17, dword_100762A8, dword_100750D4, dword_100750D4);
    if ( dword_100750D4 == v6 )
    {
      ++dword_100750C4;
      dword_100750D4 = dword_100750C4;
    }
    sub_10029AD2(&v17);
    v6 = dword_100750D4;
  }
  v7 = *(_DWORD *)a4;
  if ( (unsigned int)v6 >= *(_DWORD *)(*(_DWORD *)a4 + 12) )
  {
    v8 = 0;
  }
  else
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v7 + 8) + 4 * v6);
    if ( v8 )
      goto LABEL_18;
  }
  if ( !*(_BYTE *)(v7 + 20) )
    goto LABEL_12;
  v9 = sub_10029877();
  if ( (unsigned int)v6 < *(_DWORD *)(v9 + 12) )
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v9 + 8) + 4 * v6);
LABEL_12:
    if ( v8 )
      goto LABEL_18;
  }
  if ( v5 )
  {
    v8 = v5;
  }
  else
  {
    if ( sub_10017A80(v7, v4, (int)&v15, v14) == -1 )
    {
      sub_1002AE51((int)&v13, (unsigned int)"bad cast");
      sub_100355BB((int)&v13, (int)&unk_1006C964);
    }
    v8 = v15;
    dword_100762A8 = v15;
    (*(void (__thiscall **)(int))(*(_DWORD *)v15 + 4))(v15);
    sub_1002984F(v10, v11, v5, v6, v8);
  }
LABEL_18:
  sub_10029AD2(&v16);
  return v8;
}
// 10073200: using guessed type int __security_cookie;
// 100750C4: using guessed type int dword_100750C4;
// 100750D4: using guessed type int dword_100750D4;
// 100762A8: using guessed type int dword_100762A8;

//----- (10017C80) --------------------------------------------------------
char __stdcall sub_10017C80(char a1)
{
  return a1;
}

//----- (10017C90) --------------------------------------------------------
int __userpurge sub_10017C90<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6)
{
  int ebp0; // ebp@0
  int v7; // edi@1
  int v8; // esi@1
  int v9; // eax@1
  int v10; // edx@1
  int v11; // eax@2
  int result; // eax@4
  char v13; // zf@4

  v8 = a2;
  sub_10017710(a1, a2, a3, ebp0, a4);
  *(_DWORD *)(v8 + 56) = a5;
  *(_DWORD *)(v8 + 60) = 0;
  v9 = sub_10017D70(v8, (int)&a5);
  v7 = sub_10017B50(v10, a3, a4, v9);
  if ( a5 )
  {
    v11 = (*(int (**)(void))(*(_DWORD *)a5 + 8))();
    if ( v11 )
      (**(void (__thiscall ***)(_DWORD, _DWORD))v11)(v11, 1);
  }
  result = (*(int (__thiscall **)(int, signed int))(*(_DWORD *)v7 + 32))(v7, 32);
  v13 = *(_DWORD *)(v8 + 56) == 0;
  *(_BYTE *)(v8 + 64) = result;
  if ( v13 )
  {
    result = ((unsigned __int8)*(_DWORD *)(v8 + 12) | 4) & 0x17;
    *(_DWORD *)(v8 + 12) = result;
    if ( result & *(_DWORD *)(v8 + 16) )
      result = loc_10017FD0(v8, 0);
  }
  return result;
}

//----- (10017D50) --------------------------------------------------------
void __thiscall sub_10017D50(void *this)
{
  int v1; // ecx@1
  int v2; // eax@2

  v1 = *(_DWORD *)this;
  if ( v1 )
  {
    v2 = (*(int (**)(void))(*(_DWORD *)v1 + 8))();
    if ( v2 )
      (**(void (__thiscall ***)(_DWORD, _DWORD))v2)(v2, 1);
  }
}

//----- (10017D70) --------------------------------------------------------
int __thiscall sub_10017D70(int this, int a2)
{
  int v3; // eax@1
  int v4; // ecx@1

  v3 = *(_DWORD *)(this + 48);
  v4 = *(_DWORD *)v3;
  *(_DWORD *)a2 = *(_DWORD *)v3;
  (*(void (**)(void))(*(_DWORD *)v4 + 4))();
  return a2;
}

//----- (10017DB0) --------------------------------------------------------
int __thiscall sub_10017DB0(void *this)
{
  int result; // eax@1
  void *v2; // esi@1
  char v3; // al@4
  int v4; // ecx@4
  int v5; // ecx@4
  int v6; // eax@4
  char v7; // [sp+0h] [bp-20h]@1
  char *v8; // [sp+10h] [bp-10h]@1
  int v9; // [sp+1Ch] [bp-4h]@1

  v8 = &v7;
  v2 = this;
  v9 = 0;
  result = *(_DWORD *)(*(_DWORD *)this + 4);
  if ( !*(_DWORD *)(this + result + 12) )
  {
    if ( *((_BYTE *)this + result + 20) & 2 )
    {
      result = (*(int (**)(void))(**(_DWORD **)(this + result + 56) + 52))();
      if ( result == -1 )
      {
        v5 = *(_DWORD *)(*(_DWORD *)v2 + 4);
        v6 = *(_DWORD *)(v2 + v5 + 12);
        v4 = (int)((char *)v2 + v5);
        v3 = v6 | 4;
        if ( !*(_DWORD *)(v4 + 56) )
          v3 |= 4u;
        result = v3 & 0x17;
        *(_DWORD *)(v4 + 12) = result;
        if ( result & *(_DWORD *)(v4 + 16) )
          result = loc_10017FD0(0);
      }
    }
  }
  return result;
}

//----- (10017E3E) --------------------------------------------------------
int (*__cdecl sub_10017E3E())()
{
  return loc_10017E2C;
}
// 10017E2C: using guessed type int loc_10017E2C();

//----- (10017E80) --------------------------------------------------------
int __cdecl sub_10017E80()
{
  return 0;
}

//----- (10017E90) --------------------------------------------------------
int __thiscall sub_10017E90(void *this, const char *a2, int a3)
{
  int v3; // ebx@1
  char v4; // zf@1
  unsigned int v5; // eax@2
  int *v6; // eax@4
  int v7; // edi@4
  int v8; // esi@4
  char v9; // cf@6
  int result; // eax@8
  void *v11; // [sp+14h] [bp-24h]@1
  int v12; // [sp+24h] [bp-14h]@1
  unsigned int v13; // [sp+28h] [bp-10h]@1
  int v14; // [sp+34h] [bp-4h]@4

  v3 = (int)this;
  v13 = 15;
  v4 = *a2 == 0;
  v12 = 0;
  LOBYTE(v11) = 0;
  if ( v4 )
    v5 = 0;
  else
    v5 = strlen(a2);
  loc_1000AEB0(&v11, a2, v5);
  v14 = 0;
  v8 = *(_DWORD *)a3;
  v7 = *(_DWORD *)(a3 + 4);
  v6 = (int *)&v11;
  if ( v13 >= 0x10 )
    v6 = (int *)v11;
  a2 = (const char *)v6;
  sub_1002AEA4(v3, (int *)&a2);
  v9 = v13 < 0x10;
  *(_DWORD *)v3 = &off_1006720C;
  *(_DWORD *)(v3 + 12) = v8;
  *(_DWORD *)(v3 + 16) = v7;
  if ( !v9 )
    sub_1002A4AA(v11);
  result = v3;
  *(_DWORD *)v3 = &off_1006720C;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1006720C: using guessed type int (__stdcall *off_1006720C)(char);

//----- (10017F60) --------------------------------------------------------
int __userpurge sub_10017F60<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // edi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_1006720C;
  *(_DWORD *)(v4 + 12) = *(_DWORD *)(a3 + 12);
  *(_DWORD *)(v4 + 16) = *(_DWORD *)(a3 + 16);
  *(_DWORD *)v4 = &off_1006720C;
  return v4;
}
// 1006720C: using guessed type int (__stdcall *off_1006720C)(char);

//----- (10017F90) --------------------------------------------------------
int __userpurge sub_10017F90<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // edi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_1006720C;
  *(_DWORD *)(v4 + 12) = *(_DWORD *)(a3 + 12);
  *(_DWORD *)(v4 + 16) = *(_DWORD *)(a3 + 16);
  return v4;
}
// 1006720C: using guessed type int (__stdcall *off_1006720C)(char);

//----- (10018060) --------------------------------------------------------
int __thiscall sub_10018060(int this)
{
  int v1; // esi@1
  char v2; // al@4
  int v3; // ecx@4
  int v4; // ecx@4
  int v5; // eax@4
  int v6; // eax@6
  int v7; // ecx@10
  void *v9; // [sp+8h] [bp-1Ch]@1
  int v10; // [sp+Ch] [bp-18h]@2
  unsigned int v11; // [sp+10h] [bp-14h]@1
  int v12; // [sp+20h] [bp-4h]@2

  v11 = (unsigned int)&v9 ^ __security_cookie;
  v1 = this;
  if ( *(_DWORD *)(*(_DWORD *)(*(_DWORD *)this + 4) + this + 56) )
  {
    sub_10018150(&v9, this);
    v12 = 0;
    if ( (_BYTE)v10 )
    {
      if ( (*(int (**)(void))(**(_DWORD **)(*(_DWORD *)(*(_DWORD *)v1 + 4) + v1 + 56) + 52))() == -1 )
      {
        v4 = *(_DWORD *)(*(_DWORD *)v1 + 4);
        v5 = *(_DWORD *)(v4 + v1 + 12);
        v3 = v1 + v4;
        v2 = v5 | 4;
        if ( !*(_DWORD *)(v3 + 56) )
          v2 |= 4u;
        v6 = v2 & 0x17;
        *(_DWORD *)(v3 + 12) = v6;
        if ( v6 & *(_DWORD *)(v3 + 16) )
          loc_10017FD0(0);
      }
    }
    v12 = -1;
    if ( !(unsigned __int8)sub_10029736() )
      sub_10017DB0(v9);
    v7 = *(_DWORD *)(v9 + *(_DWORD *)(*(_DWORD *)v9 + 4) + 56);
    if ( v7 )
      (*(void (**)(void))(*(_DWORD *)v7 + 8))();
  }
  return v1;
}
// 10029736: using guessed type int sub_10029736(void);
// 10073200: using guessed type int __security_cookie;

//----- (10018150) --------------------------------------------------------
void *__thiscall sub_10018150(void *this, int a2)
{
  int v2; // ecx@1
  void *v3; // edi@1
  int v4; // eax@3
  int v5; // ecx@4

  v3 = this;
  *(_DWORD *)this = a2;
  v2 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a2 + 4) + a2 + 56);
  if ( v2 )
    (*(void (**)(void))(*(_DWORD *)v2 + 4))();
  v4 = *(_DWORD *)(*(_DWORD *)a2 + 4);
  if ( !*(_DWORD *)(v4 + a2 + 12) )
  {
    v5 = *(_DWORD *)(v4 + a2 + 60);
    if ( v5 )
      sub_10018060(v5);
  }
  *((_BYTE *)v3 + 4) = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a2 + 4) + a2 + 12) == 0;
  return v3;
}

//----- (100181E0) --------------------------------------------------------
char __thiscall sub_100181E0(int this, int a2, signed int a3, unsigned __int8 a4)
{
  char result; // al@4

  if ( a3 == 1 )
  {
    if ( *(_DWORD *)(this + 20) >= 0x10u )
      this = *(_DWORD *)this;
    result = a4;
    *(_BYTE *)(this + a2) = a4;
  }
  else
  {
    if ( *(_DWORD *)(this + 20) >= 0x10u )
      this = *(_DWORD *)this;
    result = (unsigned int)sub_100391F0((void *)(this + a2), a4, a3);
  }
  return result;
}

//----- (100182F0) --------------------------------------------------------
void *__thiscall sub_100182F0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10067398;
  sub_100296B7((int)this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067398: using guessed type int (__stdcall *off_10067398)(char);

//----- (10018340) --------------------------------------------------------
int __thiscall sub_10018340(void *this)
{
  int result; // eax@1

  _ECX = (int)((char *)this + 4);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (10018350) --------------------------------------------------------
void *__thiscall sub_10018350(void *this)
{
  void *result; // eax@1

  _EAX = (int)((char *)this + 4);
  _EDX = -1;
  __asm { lock xadd [eax], edx }
  result = 0;
  if ( _ZF )
    result = this;
  return result;
}

//----- (10018370) --------------------------------------------------------
int __stdcall sub_10018370(int a1, int a2)
{
  int i; // esi@1
  int result; // eax@3

  for ( i = a1; i != a2; i += 24 )
  {
    if ( *(_DWORD *)(i + 20) >= 0x10u )
      result = sub_1002A4AA(*(LPVOID *)i);
    *(_DWORD *)(i + 20) = 15;
    *(_DWORD *)(i + 16) = 0;
    *(_BYTE *)i = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100183F0) --------------------------------------------------------
int __fastcall sub_100183F0(int a1, int a2)
{
  int v2; // edi@1
  int i; // esi@1
  int v4; // eax@3
  int result; // eax@3
  int v6; // ecx@3

  v2 = a2;
  for ( i = a1; i != v2; result = (**(int (__stdcall ***)(_DWORD))v6)(1) )
  {
    if ( !i )
      break;
    v4 = i + 12;
    v6 = i;
    i = *(_DWORD *)(i + 12);
    *(_DWORD *)v4 = 0;
  }
  return result;
}

//----- (10018420) --------------------------------------------------------
void *__thiscall sub_10018420(int this, char a2)
{
  void *v2; // edi@1
  int v3; // esi@1
  int v4; // eax@2
  int v5; // ecx@2

  v2 = (void *)this;
  v3 = *(_DWORD *)(this + 20);
  *(_DWORD *)this = &off_10067B10;
  while ( v3 )
  {
    v4 = v3 + 12;
    v5 = v3;
    v3 = *(_DWORD *)(v3 + 12);
    *(_DWORD *)v4 = 0;
    (**(void (__stdcall ***)(_DWORD))v5)(1);
  }
  *(_DWORD *)v2 = off_10067B0C;
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067B0C: using guessed type int (__stdcall *off_10067B0C[2])(char);
// 10067B10: using guessed type int (__stdcall *off_10067B10)(char);

//----- (10018470) --------------------------------------------------------
int __fastcall sub_10018470(int a1)
{
  int v1; // edi@1
  int result; // eax@2
  int v3; // ebx@2
  int v4; // esi@2
  int v5; // eax@4
  int v6; // ecx@4
  int v7; // [sp+4h] [bp-4h]@1

  v1 = *(_DWORD *)(a1 + 24);
  v7 = a1;
  *(_DWORD *)a1 = off_10067B08;
  while ( v1 )
  {
    result = v1 + 24;
    v4 = v1;
    v1 = *(_DWORD *)(v1 + 24);
    *(_DWORD *)result = 0;
    v3 = *(_DWORD *)(a1 + 20);
    if ( v4 != v3 )
    {
      do
      {
        if ( !v4 )
          break;
        v5 = v4 + 12;
        v6 = v4;
        v4 = *(_DWORD *)(v4 + 12);
        *(_DWORD *)v5 = 0;
        result = (**(int (__stdcall ***)(_DWORD))v6)(1);
      }
      while ( v4 != v3 );
      a1 = v7;
    }
  }
  *(_DWORD *)a1 = off_10067B0C;
  return result;
}
// 10067B08: using guessed type int (__stdcall *off_10067B08[3])(char);
// 10067B0C: using guessed type int (__stdcall *off_10067B0C[2])(char);

//----- (100184D0) --------------------------------------------------------
void *__thiscall sub_100184D0(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_10018470(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10018500) --------------------------------------------------------
int __thiscall sub_10018500(int this, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1

  v2 = *(_DWORD *)(this + 4);
  v3 = *(_DWORD *)this;
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  if ( v3 != v2 )
    loc_1000AEB0(a2, v3, v2 - v3);
  return a2;
}

//----- (10018590) --------------------------------------------------------
char __thiscall sub_10018590(void *this, int a2)
{
  int v2; // ecx@1
  unsigned int v3; // edi@1
  int v4; // edx@2
  unsigned int v5; // ebx@4
  unsigned int v6; // eax@6
  char v7; // zf@8
  int v8; // eax@8
  bool v9; // eax@10
  int v10; // eax@13
  int v11; // ebx@14
  unsigned int v12; // edi@16
  int v13; // esi@17
  int v14; // edx@19
  unsigned int v15; // ecx@19
  int v16; // eax@20
  unsigned int v17; // edx@21
  int v18; // edi@21
  int v19; // ecx@22
  int v20; // eax@24
  int v21; // ecx@25
  int v22; // esi@28
  int v26; // ecx@40
  int *v27; // ecx@42
  unsigned int v28; // edi@42
  signed int v29; // edx@44
  int v30; // edx@47
  int v31; // esi@47
  char v32; // cf@47
  char v33; // cf@49
  unsigned __int8 v34; // cf@51
  unsigned __int8 v35; // al@53
  unsigned __int8 v36; // al@55
  unsigned __int8 v37; // al@57
  int v38; // eax@58
  char v39; // zf@60
  bool v40; // eax@62
  signed int v41; // edi@66
  int *v42; // edx@67
  signed int v43; // ecx@69
  int v44; // ecx@72
  int v45; // esi@72
  char v46; // cf@72
  char v47; // cf@74
  unsigned __int8 v48; // cf@76
  unsigned __int8 v49; // al@78
  unsigned __int8 v50; // al@80
  unsigned __int8 v51; // al@82
  int v52; // eax@83
  char v53; // zf@85
  bool v54; // eax@87
  int v55; // ecx@92
  unsigned int v56; // eax@94
  char v57; // zf@96
  int v58; // eax@96
  bool v59; // eax@98
  int v60; // ecx@103
  int v61; // ecx@105
  unsigned int v63; // ecx@109
  int v64; // ebx@109
  int v65; // eax@110
  int v66; // edx@112
  char v68; // zf@121
  int i; // esi@122
  int v70; // eax@123
  int v71; // ecx@123
  int v72; // eax@123
  int v73; // edx@126
  char v75; // [sp-10h] [bp-168h]@39
  int v76; // [sp-Ch] [bp-164h]@21
  int v77; // [sp-8h] [bp-160h]@21
  unsigned int v78; // [sp-4h] [bp-15Ch]@1
  char v79; // [sp+Ch] [bp-14Ch]@107
  void *v80; // [sp+24h] [bp-134h]@107
  int v81; // [sp+54h] [bp-104h]@27
  int v82; // [sp+58h] [bp-100h]@27
  int v83; // [sp+5Ch] [bp-FCh]@27
  int v84; // [sp+60h] [bp-F8h]@35
  int v85; // [sp+64h] [bp-F4h]@27
  void *v86; // [sp+6Ch] [bp-ECh]@27
  int v87; // [sp+70h] [bp-E8h]@27
  int v88; // [sp+74h] [bp-E4h]@27
  __int64 v89; // [sp+9Ch] [bp-BCh]@36
  int v90; // [sp+A4h] [bp-B4h]@36
  __int64 v91; // [sp+A8h] [bp-B0h]@39
  __int64 v92; // [sp+B4h] [bp-A4h]@36
  int v93; // [sp+BCh] [bp-9Ch]@36
  int v94; // [sp+C0h] [bp-98h]@46
  __int64 v95; // [sp+C4h] [bp-94h]@105
  int v96; // [sp+D0h] [bp-88h]@1
  int v97; // [sp+D4h] [bp-84h]@21
  int v98; // [sp+D8h] [bp-80h]@21
  int v99; // [sp+DCh] [bp-7Ch]@21
  int v100; // [sp+E0h] [bp-78h]@35
  int v101; // [sp+E4h] [bp-74h]@21
  int v102; // [sp+ECh] [bp-6Ch]@21
  int v103; // [sp+F0h] [bp-68h]@21
  int v104; // [sp+F4h] [bp-64h]@21
  __int64 v105; // [sp+F8h] [bp-60h]@38
  char v106; // [sp+100h] [bp-58h]@37
  int v107; // [sp+104h] [bp-54h]@105
  char v108; // [sp+110h] [bp-48h]@40
  void *v109; // [sp+11Ch] [bp-3Ch]@42
  unsigned int v110; // [sp+12Ch] [bp-2Ch]@42
  unsigned int v111; // [sp+130h] [bp-28h]@42
  int v112; // [sp+134h] [bp-24h]@21
  int v113; // [sp+138h] [bp-20h]@21
  int v114; // [sp+13Ch] [bp-1Ch]@21
  int v115; // [sp+140h] [bp-18h]@21
  unsigned int v116; // [sp+144h] [bp-14h]@1
  int v117; // [sp+154h] [bp-4h]@21
  int v118; // [sp+158h] [bp+0h]@1

  v116 = (unsigned int)&v118 ^ __security_cookie;
  v78 = (unsigned int)&v118 ^ __security_cookie;
  v96 = (int)this;
  v2 = (int)((char *)this + 4);
  v3 = *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)(a2 + 20) < 0x10u )
    v4 = a2;
  else
    v4 = *(_DWORD *)a2;
  v5 = *(_DWORD *)(v2 + 16);
  if ( *(_DWORD *)(v2 + 20) >= 0x10u )
    v2 = *(_DWORD *)v2;
  v6 = *(_DWORD *)(a2 + 16);
  if ( v5 < v3 )
    v6 = v5;
  v8 = sub_100099E0(v2, v4, v6);
  v7 = v8 == 0;
  if ( !v8 )
  {
    if ( v5 >= v3 )
      v9 = v5 != v3;
    else
      v9 = -1;
    v7 = v9 == 0;
  }
  LOBYTE(v10) = v7;
  if ( !v7 )
  {
    v11 = v96 + 4;
    *(_DWORD *)(v96 + 32) = *(_DWORD *)(v96 + 28);
    if ( v11 != a2 )
      loc_1000AB40(v11, a2, 0, -1);
    v12 = *(_DWORD *)(v11 + 16);
    if ( *(_DWORD *)(v11 + 20) < 0x10u )
      v13 = v11;
    else
      v13 = *(_DWORD *)v11;
    v15 = 0;
    v14 = -2128831035;
    if ( v12 )
    {
      do
      {
        v16 = *(_BYTE *)(v13 + v15++);
        v14 = 16777619 * (v16 ^ v14);
      }
      while ( v15 < v12 );
    }
    v18 = v96;
    *(_DWORD *)(v96 + 40) = v14;
    v112 = 0;
    v113 = 0;
    v114 = 0;
    v115 = 0;
    sub_10019500((int)&v112, v18, v76, v77);
    v117 = 0;
    v17 = *(_DWORD *)(v11 + 20);
    v97 = 0;
    v98 = 0;
    v99 = 0;
    v101 = 0;
    v102 = 0;
    v103 = 0;
    v104 = 0;
    if ( v17 < 0x10 )
      v19 = v11;
    else
      v19 = *(_DWORD *)v11;
    v20 = v19 + *(_DWORD *)(v11 + 16);
    if ( v17 < 0x10 )
      v21 = v11;
    else
      v21 = *(_DWORD *)v11;
    sub_10018F50((int)&v97, v21, v20, (int)&v112, v21);
    v81 = 0;
    v82 = 0;
    v83 = 0;
    v85 = 0;
    v86 = 0;
    v87 = 0;
    v88 = 0;
    sub_10018EE0((int)&v81);
    LOBYTE(v117) = 2;
    if ( *(_DWORD *)(v11 + 20) < 0x10u )
      v22 = v11;
    else
      v22 = *(_DWORD *)v11;
    _EBX = (int)v86;
    while ( 1 )
    {
      if ( v99 == v83 )
      {
        if ( !v99 )
          goto LABEL_130;
        if ( v97 == v81 )
        {
          if ( v98 == v82 )
          {
            if ( v100 == v84 )
            {
              __asm { movq    xmm0, qword ptr [ebx] }
              v90 = *(_DWORD *)(_EBX + 8);
              _EAX = v102;
              __asm
              {
                movq    [ebp+var_BC], xmm0
                movq    xmm0, qword ptr [eax]
              }
              v93 = *(_DWORD *)(v102 + 8);
              __asm { movq    [ebp+var_A4], xmm0 }
              if ( !sub_100199B0(&v92, (int)&v89) )
              {
LABEL_130:
                v63 = *(_DWORD *)(v18 + 24);
                v64 = v18 + 4;
                if ( v63 < 0x10 )
                  v65 = v18 + 4;
                else
                  v65 = *(_DWORD *)v64;
                v66 = *(_DWORD *)(v18 + 20);
                if ( v22 != v66 + v65 )
                {
                  if ( v63 >= 0x10 )
                    v64 = *(_DWORD *)v64;
                  HIDWORD(v95) = v64 + v66;
                  _EAX = &v75;
                  LODWORD(v95) = v22;
                  __asm
                  {
                    movq    xmm0, [ebp+var_94]
                    movq    qword ptr [eax], xmm0
                  }
                  sub_10018BD0((void *)v18, *(__int64 *)&v75, 0);
                }
                if ( v86 )
                  sub_1002A4AA(v86);
                if ( v102 )
                {
                  sub_1002A4AA((LPVOID)v102);
                  v102 = 0;
                  v103 = 0;
                  v104 = 0;
                }
                v117 = -1;
                LOBYTE(v10) = v112;
                if ( v112 )
                {
                  v68 = *(_DWORD *)(v112 + 32)-- == 1;
                  if ( v68 )
                  {
                    for ( i = v112; i; LOBYTE(v10) = (*(int (__stdcall **)(signed int))v72)(1) )
                    {
                      v70 = i + 12;
                      v71 = i;
                      i = *(_DWORD *)(i + 12);
                      *(_DWORD *)v70 = 0;
                      v72 = *(_DWORD *)v71;
                      v77 = 1;
                    }
                  }
                }
                v112 = 0;
                if ( v115 )
                {
                  v10 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v115 + 8))(v78);
                  if ( v10 )
                  {
                    v73 = *(_DWORD *)v10;
                    v77 = 1;
                    LOBYTE(v10) = (*(int (__thiscall **)(int, signed int))v73)(v10, 1);
                  }
                }
                return v10;
              }
            }
          }
        }
      }
      if ( v106 )
      {
        if ( HIDWORD(v105) - (_DWORD)v105 > 0 )
        {
          _EAX = &v75;
          v91 = v105;
          __asm
          {
            movq    xmm0, [ebp+var_B0]
            movq    qword ptr [eax], xmm0
          }
          sub_10018BD0((void *)v18, *(__int64 *)&v75, 0);
        }
      }
      v26 = (int)&v108;
      if ( (unsigned int)((v103 - v102) / 12) > 1 )
        v26 = v102 + 12;
      sub_100190D0(v26, (int)&v109);
      LOBYTE(v117) = 3;
      v28 = v110;
      v27 = (int *)&v109;
      if ( v111 >= 0x10 )
        v27 = (int *)v109;
      v29 = 1;
      if ( v110 < 1 )
        v29 = v110;
      v94 = 0;
      if ( v29 )
        break;
LABEL_61:
      if ( v110 >= 1 )
        v40 = v110 != 1;
      else
        v40 = -1;
      v39 = v40 == 0;
LABEL_65:
      if ( v39 )
      {
        v41 = 1;
        goto LABEL_103;
      }
      v42 = (int *)&v109;
      if ( v111 >= 0x10 )
        v42 = (int *)v109;
      v43 = 1;
      if ( v110 < 1 )
        v43 = v110;
      if ( !v43 )
      {
LABEL_86:
        if ( v110 >= 1 )
          v54 = v110 != 1;
        else
          v54 = -1;
        v53 = v54 == 0;
        goto LABEL_90;
      }
      v45 = (int)"i";
      v46 = (unsigned int)v43 < 4;
      v44 = v43 - 4;
      if ( v46 )
      {
LABEL_75:
        if ( v44 == -4 )
          goto LABEL_84;
      }
      else
      {
        while ( *v42 == *(_DWORD *)v45 )
        {
          ++v42;
          v45 += 4;
          v47 = (unsigned int)v44 < 4;
          v44 -= 4;
          if ( v47 )
            goto LABEL_75;
        }
      }
      v48 = *(_BYTE *)v42 < *(_BYTE *)v45;
      if ( *(_BYTE *)v42 != *(_BYTE *)v45
        || v44 != -3
        && ((v49 = *((_BYTE *)v42 + 1), v48 = v49 < *(_BYTE *)(v45 + 1), v49 != *(_BYTE *)(v45 + 1))
         || v44 != -2
         && ((v50 = *((_BYTE *)v42 + 2), v48 = v50 < *(_BYTE *)(v45 + 2), v50 != *(_BYTE *)(v45 + 2))
          || v44 != -1 && (v51 = *((_BYTE *)v42 + 3), v48 = v51 < *(_BYTE *)(v45 + 3), v51 != *(_BYTE *)(v45 + 3)))) )
      {
        v52 = -v48 | 1;
        goto LABEL_85;
      }
LABEL_84:
      v52 = 0;
LABEL_85:
      v53 = v52 == 0;
      if ( !v52 )
        goto LABEL_86;
LABEL_90:
      if ( v53 )
      {
        v41 = 2;
      }
      else
      {
        v55 = (int)&v109;
        if ( v111 >= 0x10 )
          v55 = (int)v109;
        v56 = 3;
        if ( v110 < 3 )
          v56 = v110;
        v58 = sub_100099E0(v55, (int)"url", v56);
        v57 = v58 == 0;
        if ( !v58 )
        {
          if ( v28 >= 3 )
            v59 = v28 != 3;
          else
            v59 = -1;
          v57 = v59 == 0;
        }
        v41 = v94;
        if ( v57 )
          v41 = 8;
      }
LABEL_103:
      v60 = (int)&v108;
      if ( (unsigned int)((v103 - v102) / 12) > 2 )
        v60 = v102 + 24;
      v95 = *(_QWORD *)v60;
      __asm { movq    xmm0, [ebp+var_94] }
      _EAX = &v75;
      __asm { movq    qword ptr [eax], xmm0 }
      v77 = v41;
      v18 = v96;
      sub_10018BD0((void *)v96, *(__int64 *)&v75, v77);
      v22 = v107;
      LOBYTE(v117) = 2;
      if ( v111 >= 0x10 )
        sub_1002A4AA(v109);
      sub_10019030((int)&v97, (int)&v79, v61);
      if ( v80 )
        sub_1002A4AA(v80);
    }
    v31 = (int)"b";
    v32 = (unsigned int)v29 < 4;
    v30 = v29 - 4;
    if ( v32 )
    {
LABEL_50:
      if ( v30 == -4 )
        goto LABEL_59;
    }
    else
    {
      while ( *v27 == *(_DWORD *)v31 )
      {
        ++v27;
        v31 += 4;
        v33 = (unsigned int)v30 < 4;
        v30 -= 4;
        if ( v33 )
          goto LABEL_50;
      }
    }
    v34 = *(_BYTE *)v27 < *(_BYTE *)v31;
    if ( *(_BYTE *)v27 != *(_BYTE *)v31
      || v30 != -3
      && ((v35 = *((_BYTE *)v27 + 1), v34 = v35 < *(_BYTE *)(v31 + 1), v35 != *(_BYTE *)(v31 + 1))
       || v30 != -2
       && ((v36 = *((_BYTE *)v27 + 2), v34 = v36 < *(_BYTE *)(v31 + 2), v36 != *(_BYTE *)(v31 + 2))
        || v30 != -1 && (v37 = *((_BYTE *)v27 + 3), v34 = v37 < *(_BYTE *)(v31 + 3), v37 != *(_BYTE *)(v31 + 3)))) )
    {
      v38 = -v34 | 1;
      goto LABEL_60;
    }
LABEL_59:
    v38 = 0;
LABEL_60:
    v39 = v38 == 0;
    if ( v38 )
      goto LABEL_65;
    goto LABEL_61;
  }
  return v10;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10018BD0) --------------------------------------------------------
void __thiscall sub_10018BD0(void *this, __int64 a2, int a3)
{
  int v3; // eax@1
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // ebx@2
  void *v8; // ecx@6
  unsigned int v9; // edx@12
  int v10; // esi@13
  int v11; // ecx@14
  int v12; // ebx@14
  unsigned int v13; // eax@15
  unsigned int v14; // edx@16
  signed int v15; // edx@17
  int v16; // ecx@17
  int v17; // eax@17
  int v21; // eax@25
  char v22; // [sp-Ch] [bp-50h]@6
  int v23; // [sp-8h] [bp-4Ch]@6
  _DWORD v24[3]; // [sp+Ch] [bp-38h]@12
  __int64 v25; // [sp+18h] [bp-2Ch]@15
  int v26; // [sp+20h] [bp-24h]@14
  int v27; // [sp+24h] [bp-20h]@2
  int v28; // [sp+28h] [bp-1Ch]@1
  int v29; // [sp+2Ch] [bp-18h]@13
  int v30; // [sp+30h] [bp-14h]@12
  __int64 v31; // [sp+34h] [bp-10h]@12
  int v32; // [sp+3Ch] [bp-8h]@12
  unsigned int v33; // [sp+40h] [bp-4h]@1
  int v34; // [sp+44h] [bp+0h]@1

  v33 = (unsigned int)&v34 ^ __security_cookie;
  v3 = a2;
  v5 = (int)this;
  v4 = HIDWORD(a2);
  v28 = v5;
  while ( 1 )
  {
    v6 = v3;
    v27 = v3;
    if ( v3 == v4 )
      break;
    while ( *(_BYTE *)v6 != 10 )
    {
      ++v6;
      v27 = v6;
      if ( v6 == v4 )
        goto LABEL_5;
    }
    if ( v6 == v4 )
    {
LABEL_5:
      if ( v3 != v4 )
      {
        __asm { movq    xmm0, [ebp+arg_0] }
        _EDX = &v22;
        v8 = (void *)v5;
        __asm { movq    qword ptr [edx], xmm0 }
        sub_10018DA0(v8, *(int *)&v22, v23, a3);
      }
      return;
    }
    if ( v6 == v3 )
    {
      if ( (*(_DWORD *)(v5 + 32) - *(_DWORD *)(v5 + 28)) / 12 )
      {
        *(_DWORD *)(*(_DWORD *)(v5 + 32) - 4) |= 4u;
        v4 = HIDWORD(a2);
        v3 = v6 + 1;
        LODWORD(a2) = v6 + 1;
        continue;
      }
    }
    else
    {
      v30 = a3 | 4;
      v32 = a3 | 4;
      v9 = *(_DWORD *)v5;
      v24[0] = v3;
      v24[1] = v6;
      __asm
      {
        movq    xmm0, qword ptr [ebp+var_38]
        movq    [ebp+var_10], xmm0
      }
      if ( !v9 )
        goto LABEL_32;
      v29 = v6 - v3;
      v10 = v31;
      if ( v6 - v3 > v9 )
      {
        v11 = v30;
        v12 = v29;
        v26 = v30;
        do
        {
          HIDWORD(v25) = v9 + v10;
          v13 = *(_DWORD *)(v5 + 32);
          LODWORD(v25) = v10;
          if ( (unsigned int)&v25 >= v13 || (v14 = *(_DWORD *)(v5 + 28), v11 = v30, v14 > (unsigned int)&v25) )
          {
            if ( v13 == *(_DWORD *)(v5 + 36) )
            {
              loc_10019280(v5 + 28, v11);
              v11 = v30;
            }
            _EAX = *(_DWORD *)(v5 + 32);
            if ( _EAX )
            {
              __asm
              {
                movq    xmm0, [ebp+var_2C]
                movq    qword ptr [eax], xmm0
              }
              *(_DWORD *)(_EAX + 8) = v11;
            }
          }
          else
          {
            v17 = *(_DWORD *)(v5 + 32);
            v15 = (signed int)((unsigned __int64)(715827883i64 * (signed int)((char *)&v25 - v14)) >> 32) >> 1;
            v16 = v15 + ((unsigned int)v15 >> 31);
            v29 = v15 + ((unsigned int)v15 >> 31);
            if ( v17 == *(_DWORD *)(v5 + 36) )
            {
              loc_10019280(v5 + 28, v15 + ((unsigned int)v15 >> 31));
              v16 = v29;
            }
            _EAX = *(_DWORD *)(v5 + 28) + 12 * v16;
            _ECX = *(_DWORD *)(v5 + 32);
            if ( _ECX )
            {
              __asm
              {
                movq    xmm0, qword ptr [eax]
                movq    qword ptr [ecx], xmm0
              }
              *(_DWORD *)(_ECX + 8) = *(_DWORD *)(_EAX + 8);
            }
          }
          v21 = v28;
          *(_DWORD *)(v5 + 32) += 12;
          v9 = *(_DWORD *)v21;
          v11 = v30;
          v12 -= *(_DWORD *)v21;
          v10 += *(_DWORD *)v21;
        }
        while ( (unsigned int)v12 > *(_DWORD *)v21 );
        v4 = HIDWORD(a2);
        v6 = v27;
        LODWORD(v31) = v10;
        v5 = v21;
      }
      if ( v10 != HIDWORD(v31) )
      {
LABEL_32:
        sub_10018E10(v5 + 28, (unsigned int)&v31);
        v4 = HIDWORD(a2);
      }
    }
    v3 = v6 + 1;
    LODWORD(a2) = v6 + 1;
  }
}
// 10073200: using guessed type int __security_cookie;

//----- (10018DA0) --------------------------------------------------------
void __thiscall sub_10018DA0(void *this, int a2, int a3, int a4)
{
  void *v4; // ebx@1
  unsigned int v5; // esi@1
  int v6; // eax@2
  int v7; // edx@2
  int v8; // edi@2
  int v9; // ecx@3
  int v10; // [sp+8h] [bp-Ch]@4
  unsigned int v11; // [sp+Ch] [bp-8h]@4
  int v12; // [sp+10h] [bp-4h]@4

  v4 = this;
  v5 = *(_DWORD *)this;
  if ( !*(_DWORD *)this )
    goto LABEL_10;
  v7 = a3;
  v6 = a2;
  v8 = a3 - a2;
  if ( a3 - a2 > v5 )
  {
    v9 = (int)((char *)this + 28);
    do
    {
      v10 = v6;
      v11 = v5 + v6;
      v12 = a4;
      sub_10018E10(v9, (unsigned int)&v10);
      v5 = *(_DWORD *)v4;
      v6 = *(_DWORD *)v4 + a2;
      v8 -= *(_DWORD *)v4;
      a2 += *(_DWORD *)v4;
      v9 = (int)((char *)v4 + 28);
    }
    while ( v8 > v5 );
    v7 = a3;
  }
  if ( v6 != v7 )
LABEL_10:
    sub_10018E10((int)((char *)v4 + 28), (unsigned int)&a2);
}

//----- (10018E10) --------------------------------------------------------
void __thiscall sub_10018E10(int this, unsigned int a2)
{
  unsigned int v2; // ecx@1
  int v4; // esi@1
  int v5; // edi@3
  signed int v6; // edx@3

  v4 = this;
  v2 = *(_DWORD *)(this + 4);
  _EDI = a2;
  if ( a2 >= v2 || *(_DWORD *)v4 > a2 )
  {
    if ( v2 == *(_DWORD *)(v4 + 8) )
      loc_10019280(v4, v2);
    _ECX = *(_DWORD *)(v4 + 4);
    if ( _ECX )
    {
      __asm
      {
        movq    xmm0, qword ptr [edi]
        movq    qword ptr [ecx], xmm0
      }
      *(_DWORD *)(_ECX + 8) = *(_DWORD *)(a2 + 8);
    }
  }
  else
  {
    v6 = (signed int)((unsigned __int64)(715827883i64 * (signed int)(a2 - *(_DWORD *)v4)) >> 32) >> 1;
    v5 = v6 + ((unsigned int)v6 >> 31);
    if ( v2 == *(_DWORD *)(v4 + 8) )
      loc_10019280(v4, v2);
    _EAX = *(_DWORD *)v4 + 12 * v5;
    _ECX = *(_DWORD *)(v4 + 4);
    if ( _ECX )
    {
      __asm
      {
        movq    xmm0, qword ptr [eax]
        movq    qword ptr [ecx], xmm0
      }
      *(_DWORD *)(_ECX + 8) = *(_DWORD *)(_EAX + 8);
      *(_DWORD *)(v4 + 4) += 12;
      return;
    }
  }
  *(_DWORD *)(v4 + 4) += 12;
}

//----- (10018EE0) --------------------------------------------------------
int __thiscall sub_10018EE0(int this)
{
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_BYTE *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 40) = 0;
  *(_BYTE *)(this + 44) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 52) = 0;
  *(_BYTE *)(this + 56) = 0;
  *(_DWORD *)(this + 60) = 0;
  *(_DWORD *)(this + 64) = 0;
  *(_BYTE *)(this + 68) = 0;
  return this;
}

//----- (10018F50) --------------------------------------------------------
int __thiscall sub_10018F50(int this, int a2, int a3, int a4, int a5)
{
  int result; // eax@1
  int v6; // esi@1
  int v7; // ecx@1
  char v8; // zf@1

  v6 = this;
  *(_DWORD *)this = a2;
  *(_DWORD *)(this + 4) = a3;
  v7 = this + 16;
  *(_DWORD *)(v6 + 8) = a4;
  *(_DWORD *)(v6 + 12) = 0;
  *(_DWORD *)v7 = 0;
  *(_BYTE *)(v7 + 4) = 0;
  *(_DWORD *)(v7 + 8) = 0;
  *(_DWORD *)(v7 + 12) = 0;
  *(_DWORD *)(v7 + 16) = 0;
  *(_DWORD *)(v7 + 20) = 0;
  *(_DWORD *)(v7 + 24) = 0;
  *(_BYTE *)(v7 + 28) = 0;
  *(_DWORD *)(v7 + 32) = 0;
  *(_DWORD *)(v7 + 36) = 0;
  *(_BYTE *)(v7 + 40) = 0;
  *(_DWORD *)(v7 + 44) = 0;
  *(_DWORD *)(v7 + 48) = 0;
  *(_BYTE *)(v7 + 52) = 0;
  v8 = sub_100195A0(v7, *(_DWORD *)(v6 + 8), *(_DWORD *)v6, *(_DWORD *)(v6 + 4), *(_DWORD *)(v6 + 12), *(_DWORD *)v6) == 0;
  result = v6;
  if ( v8 )
    *(_DWORD *)(v6 + 8) = 0;
  return result;
}

//----- (10019030) --------------------------------------------------------
int __thiscall sub_10019030(int this, int a2, int a3)
{
  int v4; // edi@1

  v4 = this;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(_DWORD *)(a2 + 28) = 0;
  *(_DWORD *)(a2 + 32) = 0;
  sub_10019200(a2, this);
  sub_10019310(v4);
  return a2;
}

//----- (100190D0) --------------------------------------------------------
int __thiscall sub_100190D0(int this, int a2)
{
  int v2; // eax@2
  int v3; // ecx@2
  char v4; // bl@4
  int *v5; // edi@4
  char v6; // bl@10
  void *v8; // [sp+10h] [bp-34h]@2
  int v9; // [sp+20h] [bp-24h]@2
  unsigned int v10; // [sp+24h] [bp-20h]@2
  void *v11; // [sp+28h] [bp-1Ch]@5
  int v12; // [sp+38h] [bp-Ch]@5
  unsigned int v13; // [sp+3Ch] [bp-8h]@5

  if ( *(_BYTE *)(this + 8) )
  {
    v2 = *(_DWORD *)(this + 4);
    v3 = *(_DWORD *)this;
    v10 = 15;
    v9 = 0;
    LOBYTE(v8) = 0;
    if ( v3 != v2 )
      loc_1000AEB0(&v8, v3, v2 - v3);
    v5 = (int *)&v8;
    v4 = 1;
  }
  else
  {
    v13 = 15;
    v12 = 0;
    LOBYTE(v11) = 0;
    v5 = (int *)&v11;
    v4 = 2;
  }
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  if ( (unsigned int)v5[5] >= 0x10 )
  {
    *(_DWORD *)a2 = *v5;
    *v5 = 0;
  }
  else
  {
    if ( v5[4] != -1 )
      sub_1002A4B0((void *)a2, v5, v5[4] + 1);
  }
  *(_DWORD *)(a2 + 16) = v5[4];
  v6 = v4 | 4;
  *(_DWORD *)(a2 + 20) = v5[5];
  v5[5] = 15;
  v5[4] = 0;
  *(_BYTE *)v5 = 0;
  if ( v6 & 2 )
  {
    v6 &= 0xFDu;
    if ( v13 >= 0x10 )
      sub_1002A4AA(v11);
    v13 = 15;
    v12 = 0;
    LOBYTE(v11) = 0;
  }
  if ( v6 & 1 )
  {
    if ( v10 >= 0x10 )
      sub_1002A4AA(v8);
  }
  return a2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10019200) --------------------------------------------------------
int __thiscall sub_10019200(int this, int a2)
{
  _ESI = a2;
  _EDI = this;
  *(_DWORD *)this = *(_DWORD *)a2;
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(this + 12) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(this + 16) = *(_DWORD *)(a2 + 16);
  *(_BYTE *)(this + 20) = *(_BYTE *)(a2 + 20);
  sub_10019410(this + 24, a2 + 24);
  __asm
  {
    movq    xmm0, qword ptr [esi+24h]
    movq    qword ptr [edi+24h], xmm0
  }
  *(_DWORD *)(_EDI + 44) = *(_DWORD *)(a2 + 44);
  __asm
  {
    movq    xmm0, qword ptr [esi+30h]
    movq    qword ptr [edi+30h], xmm0
  }
  *(_DWORD *)(_EDI + 56) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(_EDI + 60) = 0;
  *(_DWORD *)(_EDI + 64) = 0;
  *(_BYTE *)(_EDI + 68) = 0;
  return _EDI;
}

//----- (10019310) --------------------------------------------------------
int __thiscall sub_10019310(int this)
{
  int v1; // edx@1
  int v2; // edi@1
  int v3; // eax@2
  int v4; // esi@2
  int v5; // ST0C_4@6

  v2 = this;
  v1 = *(_DWORD *)(this + 8);
  if ( !v1 )
    return v2;
  v3 = *(_DWORD *)(this + 24);
  v4 = *(_DWORD *)(v3 + 4);
  if ( *(_DWORD *)v3 != v4 )
    goto LABEL_6;
  if ( v4 == *(_DWORD *)(this + 4) )
  {
LABEL_7:
    *(_DWORD *)(v2 + 8) = 0;
    return v2;
  }
  if ( !sub_100195A0(this + 16, v1, v4, *(_DWORD *)(this + 4), *(_DWORD *)(this + 12) | 0x60, *(_DWORD *)this) )
  {
    ++v4;
LABEL_6:
    v5 = *(_DWORD *)v2;
    *(_DWORD *)(v2 + 12) |= 0x100u;
    if ( !sub_100195A0(v2 + 16, *(_DWORD *)(v2 + 8), v4, *(_DWORD *)(v2 + 4), *(_DWORD *)(v2 + 12), v5) )
      goto LABEL_7;
  }
  return v2;
}

//----- (10019410) --------------------------------------------------------
int __thiscall sub_10019410(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  if ( (unsigned __int8)loc_10019490((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) / 12) )
    *(_DWORD *)(v2 + 4) = sub_1001C280(*(void **)v2, *(_DWORD *)a2, *(_DWORD *)(a2 + 4));
  return v2;
}

//----- (10019500) --------------------------------------------------------
int __userpurge sub_10019500<eax>(int a1<ecx>, int a2<edi>, int a3, int a4)
{
  int v4; // ecx@1
  int v5; // ebx@1
  int ebp0; // ebp@0
  int v7; // edi@1
  int v9; // [sp+10h] [bp-10h]@1

  v5 = a1;
  v9 = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = sub_1002987D(a1, ebp0, a2);
  v7 = (int)&dword_10074F10;
  v4 = (int)&dword_10074F10;
  if ( (unsigned int)dword_10074F24 >= 0x10 )
    v4 = dword_10074F10;
  if ( (unsigned int)dword_10074F24 >= 0x10 )
    v7 = dword_10074F10;
  sub_10019E30(v5, v5, v7, v4 + dword_10074F20, v4, v9);
  return v5;
}
// 10074F10: using guessed type int dword_10074F10;
// 10074F20: using guessed type int dword_10074F20;
// 10074F24: using guessed type int dword_10074F24;

//----- (100195A0) --------------------------------------------------------
char __fastcall sub_100195A0(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // edi@1
  int v8; // edx@3
  int v9; // ecx@3
  char v10; // bl@3
  int v11; // esi@3
  int v12; // eax@7
  int v13; // ecx@9
  int v14; // eax@12
  int v15; // ecx@12
  int v16; // [sp+10h] [bp-94h]@1
  char v17; // [sp+14h] [bp-90h]@3
  int v18; // [sp+68h] [bp-3Ch]@13
  int v19; // [sp+74h] [bp-30h]@12
  unsigned int v20; // [sp+94h] [bp-10h]@1
  int v21; // [sp+A0h] [bp-4h]@9
  int v22; // [sp+A4h] [bp+0h]@1
  int i; // [sp+ACh] [bp+8h]@12

  v20 = (unsigned int)&v22 ^ __security_cookie;
  v16 = a2;
  v6 = a1;
  if ( !*(_DWORD *)a2 )
    return 0;
  v11 = a3;
  v10 = 0;
  sub_10019810((int)&v17, a1);
  v8 = v16;
  v9 = *(_DWORD *)v16;
  if ( *(_DWORD *)v16 )
    v16 = *(_DWORD *)(v9 + 20);
  else
    v16 = 0;
  if ( v9 )
    v12 = *(_DWORD *)(v9 + 28) - 1;
  else
    v12 = 0;
  sub_10019A90((int)&v17, a3, a4, v8 + 4, v9, v12 + 1, v16, a5);
  v21 = 0;
  if ( sub_1001A270((int)&v17, v6, v13) )
    goto LABEL_16;
  if ( a3 == a4 || a5 & 0x40 )
    goto LABEL_18;
  v19 = (v19 | 0x100) & 0xFFFFDFFF;
  v14 = *(_DWORD *)sub_10019F10((int)&v17, (int)&v16, a3 + 1, a4, 0);
  v15 = a4;
  for ( i = v14; v14 != a4; i = v14 )
  {
    v18 = v14;
    if ( sub_1001A270((int)&v17, v6, v15) )
      goto LABEL_16;
    v14 = *(_DWORD *)sub_10019F10((int)&v17, (int)&v16, i + 1, a4, 0);
    v15 = a4;
  }
  v18 = v15;
  if ( sub_1001A270((int)&v17, v6, v15) )
  {
LABEL_16:
    v10 = 1;
    if ( v6 )
    {
      *(_DWORD *)v6 = a6;
      *(_DWORD *)(v6 + 20) = v11;
    }
  }
LABEL_18:
  sub_10019740((int)&v17);
  return v10;
}
// 10073200: using guessed type int __security_cookie;

//----- (10019740) --------------------------------------------------------
int __thiscall sub_10019740(int this)
{
  int v1; // esi@1
  int result; // eax@9

  v1 = this;
  if ( *(_DWORD *)(this + 64) )
  {
    sub_1002A4AA(*(LPVOID *)(this + 64));
    *(_DWORD *)(v1 + 64) = 0;
    *(_DWORD *)(v1 + 68) = 0;
    *(_DWORD *)(v1 + 72) = 0;
  }
  if ( *(_DWORD *)(v1 + 52) )
  {
    sub_1002A4AA(*(LPVOID *)(v1 + 52));
    *(_DWORD *)(v1 + 52) = 0;
    *(_DWORD *)(v1 + 56) = 0;
    *(_DWORD *)(v1 + 60) = 0;
  }
  *(_DWORD *)(v1 + 48) = 0;
  if ( *(_DWORD *)(v1 + 36) )
  {
    sub_1002A4AA(*(LPVOID *)(v1 + 36));
    *(_DWORD *)(v1 + 36) = 0;
    *(_DWORD *)(v1 + 40) = 0;
    *(_DWORD *)(v1 + 44) = 0;
  }
  if ( *(_DWORD *)(v1 + 20) )
  {
    sub_1002A4AA(*(LPVOID *)(v1 + 20));
    *(_DWORD *)(v1 + 20) = 0;
    *(_DWORD *)(v1 + 24) = 0;
    *(_DWORD *)(v1 + 28) = 0;
  }
  *(_DWORD *)(v1 + 16) = 0;
  result = *(_DWORD *)(v1 + 4);
  if ( result )
  {
    result = sub_1002A4AA(*(LPVOID *)(v1 + 4));
    *(_DWORD *)(v1 + 4) = 0;
    *(_DWORD *)(v1 + 8) = 0;
    *(_DWORD *)(v1 + 12) = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10019810) --------------------------------------------------------
void __thiscall sub_10019810(int this, int a2)
{
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 40) = 0;
  *(_DWORD *)(this + 44) = 0;
  *(_DWORD *)(this + 52) = 0;
  *(_DWORD *)(this + 56) = 0;
  *(_DWORD *)(this + 60) = 0;
  *(_DWORD *)(this + 64) = 0;
  *(_DWORD *)(this + 68) = 0;
  *(_DWORD *)(this + 72) = 0;
  *(_DWORD *)(this + 76) = 0;
  *(_DWORD *)(this + 80) = 0;
  *(_DWORD *)(this + 84) = 0;
  *(_DWORD *)(this + 88) = 0;
}

//----- (10019980) --------------------------------------------------------
LPVOID __thiscall sub_10019980(LPVOID *this)
{
  LPVOID result; // eax@1
  LPVOID *v2; // esi@1

  v2 = this;
  result = *this;
  if ( *this )
  {
    result = (LPVOID)sub_1002A4AA(*this);
    *v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100199B0) --------------------------------------------------------
signed int __thiscall sub_100199B0(void *this, int a2)
{
  int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  unsigned int v7; // esi@3
  unsigned int v8; // eax@5
  signed int v9; // ebx@7
  void *v11; // [sp+14h] [bp-40h]@1
  unsigned int v12; // [sp+28h] [bp-2Ch]@13
  void *v13; // [sp+2Ch] [bp-28h]@1
  int v14; // [sp+3Ch] [bp-18h]@13
  unsigned int v15; // [sp+40h] [bp-14h]@11
  int v16; // [sp+50h] [bp-4h]@1
  unsigned int v17; // [sp+5Ch] [bp+8h]@1

  v6 = (int)this;
  v5 = sub_100190D0(a2, (int)&v11);
  v16 = 0;
  v2 = sub_100190D0(v6, (int)&v13);
  v3 = *(_DWORD *)(v5 + 16);
  v4 = v2;
  v17 = *(_DWORD *)(v5 + 16);
  if ( *(_DWORD *)(v5 + 20) >= 0x10u )
    v5 = *(_DWORD *)v5;
  v7 = *(_DWORD *)(v2 + 16);
  if ( *(_DWORD *)(v2 + 20) >= 0x10u )
    v4 = *(_DWORD *)v2;
  v8 = v3;
  if ( v7 < v3 )
    v8 = v7;
  v9 = sub_100099E0(v4, v5, v8);
  if ( !v9 )
  {
    if ( v7 >= v17 )
      v9 = v7 != v17;
    else
      v9 = -1;
  }
  if ( v15 >= 0x10 )
    sub_1002A4AA(v13);
  v15 = 15;
  v14 = 0;
  LOBYTE(v13) = 0;
  if ( v12 >= 0x10 )
    sub_1002A4AA(v11);
  return v9;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10019A90) --------------------------------------------------------
int __thiscall sub_10019A90(int this, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // edi@1
  char v9; // al@3
  int v11; // [sp+10h] [bp-10h]@1
  int v12; // [sp+1Ch] [bp-4h]@1

  v8 = this;
  *(_DWORD *)this = 0;
  v11 = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  sub_10019D80((void *)(this + 4), 0, (int)&v11);
  *(_DWORD *)(v8 + 16) = 0;
  *(_DWORD *)(v8 + 20) = 0;
  *(_DWORD *)(v8 + 24) = 0;
  *(_DWORD *)(v8 + 28) = 0;
  v12 = 0;
  *(_DWORD *)(v8 + 32) = 0;
  v11 = 0;
  *(_DWORD *)(v8 + 36) = 0;
  *(_DWORD *)(v8 + 40) = 0;
  *(_DWORD *)(v8 + 44) = 0;
  sub_10019D80((void *)(v8 + 36), 0, (int)&v11);
  *(_DWORD *)(v8 + 48) = 0;
  *(_DWORD *)(v8 + 52) = 0;
  *(_DWORD *)(v8 + 56) = 0;
  *(_DWORD *)(v8 + 60) = 0;
  *(_DWORD *)(v8 + 64) = 0;
  *(_DWORD *)(v8 + 68) = 0;
  *(_DWORD *)(v8 + 72) = 0;
  LOBYTE(v12) = 2;
  *(_DWORD *)(v8 + 76) = 0;
  *(_DWORD *)(v8 + 80) = a3;
  *(_DWORD *)(v8 + 84) = a2;
  *(_DWORD *)(v8 + 92) = a7;
  *(_DWORD *)(v8 + 88) = a5;
  *(_DWORD *)(v8 + 96) = a8;
  *(_BYTE *)(v8 + 100) = 0;
  *(_DWORD *)(v8 + 104) = a6;
  v9 = *(_BYTE *)(a5 + 8) & 8 && !(a8 & 0x10);
  *(_BYTE *)(v8 + 108) = v9;
  *(_DWORD *)(v8 + 112) = a4;
  sub_10019BE0(v8 + 64, *(_DWORD *)(a5 + 24));
  return v8;
}

//----- (10019BE0) --------------------------------------------------------
int __thiscall sub_10019BE0(int this, unsigned int a2)
{
  int result; // eax@1
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // edx@2

  v4 = this;
  v5 = *(_DWORD *)(this + 4);
  result = *(_DWORD *)this;
  v3 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 3;
  if ( v3 <= a2 )
  {
    if ( v3 >= a2 )
      return result;
    loc_10019C80(v4, a2 - v3);
    sub_1001C2C0(*(_DWORD *)(v4 + 4), a2 - ((*(_DWORD *)(v4 + 4) - *(_DWORD *)v4) >> 3));
    result = *(_DWORD *)(v4 + 4) + 8 * (a2 - ((*(_DWORD *)(v4 + 4) - *(_DWORD *)v4) >> 3));
    goto LABEL_9;
  }
  v6 = result + 8 * a2;
  if ( v6 == result )
  {
LABEL_9:
    *(_DWORD *)(v4 + 4) = result;
    return result;
  }
  if ( v6 != v5 )
  {
    result = v5;
    *(_DWORD *)(v4 + 4) = v6;
  }
  return result;
}

//----- (10019D80) --------------------------------------------------------
int __thiscall sub_10019D80(void *this, int a2, int a3)
{
  int result; // eax@1
  void *v4; // ebx@1
  int v5; // esi@1
  int v6; // eax@2
  int v7; // edx@2
  int v8; // ecx@2
  int v9; // [sp+10h] [bp+8h]@2

  v5 = a2;
  v4 = this;
  result = loc_10019DC0(a2);
  if ( (_BYTE)result )
  {
    v6 = *(_DWORD *)v4;
    v9 = *(_DWORD *)v4;
    v8 = v5;
    v7 = *(_DWORD *)v4;
    if ( v5 )
    {
      do
      {
        *(_DWORD *)v7 = *(_DWORD *)a3;
        v7 += 4;
        --v8;
      }
      while ( v8 );
      v6 = v9;
    }
    result = v6 + 4 * v5;
    *((_DWORD *)v4 + 1) = result;
  }
  return result;
}

//----- (10019E30) --------------------------------------------------------
void *__userpurge sub_10019E30<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int *v7; // edi@1
  int v8; // esi@1
  int v9; // ecx@3
  char v10; // zf@4
  void *result; // eax@6
  int v12; // [sp+Ch] [bp-68h]@1
  int v13; // [sp+10h] [bp-64h]@1
  int v14; // [sp+14h] [bp-60h]@1
  void *v15; // [sp+20h] [bp-54h]@1
  int v16; // [sp+24h] [bp-50h]@1
  int v17; // [sp+28h] [bp-4Ch]@1
  int v18; // [sp+2Ch] [bp-48h]@6
  int v19; // [sp+30h] [bp-44h]@1
  int v20; // [sp+34h] [bp-40h]@1
  unsigned int v21; // [sp+64h] [bp-10h]@1
  int v22; // [sp+70h] [bp-4h]@1
  int v23; // [sp+74h] [bp+0h]@1

  v21 = (unsigned int)&v23 ^ __security_cookie;
  v7 = (int *)a1;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v19 = 0;
  v20 = 0;
  sub_1001B7B0((int)&v12, a2, a1 + 4, a3, a4, a1);
  v22 = 0;
  v6 = sub_1001B890(&v12);
  v8 = v6;
  if ( v6 )
    ++*(_DWORD *)(v6 + 32);
  v9 = *v7;
  if ( *v7 )
  {
    v10 = *(_DWORD *)(v9 + 32)-- == 1;
    if ( v10 )
      sub_100183F0(*v7, 0);
  }
  result = v15;
  *v7 = v8;
  v18 = 0;
  if ( result )
    result = (void *)sub_1002A4AA(result);
  return result;
}
// 1001B890: using guessed type int __thiscall sub_1001B890(_DWORD);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10019F10) --------------------------------------------------------
int __thiscall sub_10019F10(int this, int a2, int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // esi@1
  int v8; // eax@3
  int v9; // edx@3
  int v10; // edx@19
  int v11; // ebx@19
  int v12; // esi@19
  int v13; // eax@20
  int v14; // ecx@24
  int v16; // esi@30
  int v17; // eax@31
  int v18; // ecx@31
  char v19; // bl@32
  char v20; // bl@35
  char v21; // al@35
  int v22; // ecx@37
  int v23; // esi@37
  int v24; // esi@38
  int v25; // edx@41
  unsigned __int8 v26; // sf@41
  unsigned __int8 v27; // of@41
  int v28; // ebx@47
  int v29; // ecx@48
  int v30; // esi@48
  int v31; // ebx@54
  char v32; // al@55
  char v33; // zf@55
  int v34; // esi@57
  char v35; // al@58
  char v36; // zf@58
  int v37; // ecx@64
  char v38; // [sp+10h] [bp-28h]@67
  char v39; // [sp+14h] [bp-24h]@22
  char v40; // [sp+18h] [bp-20h]@31
  char v41; // [sp+1Ch] [bp-1Ch]@23
  char v42; // [sp+20h] [bp-18h]@20
  int v43; // [sp+24h] [bp-14h]@23
  int v44; // [sp+28h] [bp-10h]@1
  int v45; // [sp+2Ch] [bp-Ch]@1
  int v46; // [sp+30h] [bp-8h]@19
  unsigned int v47; // [sp+34h] [bp-4h]@1
  int v48; // [sp+38h] [bp+0h]@1

  v47 = (unsigned int)&v48 ^ __security_cookie;
  v7 = a2;
  v6 = a5;
  v5 = this;
  v45 = this;
  v44 = a2;
  if ( !a5 )
    v6 = *(_DWORD *)(this + 88);
  v8 = a3;
  v9 = a4;
  if ( a3 != a4 )
  {
    while ( 2 )
    {
      if ( v6 )
      {
        switch ( *(_DWORD *)(v6 + 4) )
        {
          case 0xC:
          case 0x15:
            v6 = 0;
            continue;
          case 1:
          case 8:
          case 9:
          case 0xD:
          case 0xE:
          case 0x14:
            v6 = *(_DWORD *)(v6 + 12);
            continue;
          case 2:
            if ( *(_BYTE *)(this + 96) & 1 )
              goto LABEL_68;
            if ( a3 != a4 )
            {
              do
              {
                if ( *(_BYTE *)(v8 - 1) == 10 )
                  break;
                ++v8;
              }
              while ( v8 != a4 );
            }
            goto LABEL_27;
          case 3:
            if ( *(_BYTE *)(this + 96) & 2 )
              goto LABEL_68;
            if ( a3 != a4 )
            {
              do
              {
                if ( *(_BYTE *)v8 == 10 )
                  break;
                ++v8;
              }
              while ( v8 != a4 );
            }
            goto LABEL_27;
          case 6:
            if ( a3 == a4 )
              goto LABEL_27;
            do
            {
              v12 = *(_DWORD *)(v5 + 92);
              v10 = *(_DWORD *)(v6 + 28);
              LOBYTE(v46) = (*(_DWORD *)(v5 + 96) >> 7) & 1;
              v11 = v10 + 1;
              if ( v12 & 0x800 )
              {
                v13 = sub_1001D2B0((int)&v42, *(_DWORD *)(v6 + 28), v8, v8 + 1, v11, *(_DWORD *)(v45 + 112), v46);
              }
              else
              {
                if ( v12 & 0x100 )
                {
                  v13 = sub_1001D4B0(
                          (int)&v39,
                          *(_DWORD *)(v6 + 28),
                          v8,
                          (int *)(v8 + 1),
                          v11,
                          *(_DWORD *)(v45 + 112),
                          v46);
                }
                else
                {
                  LOBYTE(v43) = 0;
                  v13 = sub_1001D560((int)&v41, v10, v8, v8 + 1, v10 + 1, v43, v46);
                }
              }
              v14 = *(_DWORD *)v13;
              v8 = a3;
              if ( v14 != a3 )
                break;
              v5 = v45;
              v8 = a3 + 1;
              a3 = v8;
            }
            while ( v8 != a4 );
            goto LABEL_26;
          default:
            goto LABEL_27;
          case 7:
            if ( a3 == a4 )
              goto LABEL_27;
            break;
          case 0x10:
            if ( a3 != a4 )
            {
              do
              {
                if ( !v6 )
                  break;
                v9 = *(_DWORD *)sub_10019F10(&v38, v8, v9, *(_DWORD *)(v6 + 12));
                v8 = a3;
                v6 = *(_DWORD *)(v6 + 24);
              }
              while ( a3 != v9 );
            }
LABEL_68:
            *(_DWORD *)a2 = v9;
            return v7;
        }
        while ( 1 )
        {
          v16 = *(_DWORD *)(v6 + 20);
          LOBYTE(v46) = *(_BYTE *)v8;
          if ( v16 )
          {
            v17 = sub_1001BF10((int)&v40, v16, v8, v8 + 1);
            v9 = a4;
            v18 = v17;
            v8 = a3;
            if ( *(_DWORD *)v18 != a3 )
            {
              v19 = 1;
              goto LABEL_61;
            }
          }
          if ( *(_DWORD *)(v6 + 32) )
          {
            if ( *(_DWORD *)(v5 + 92) & 0x800 )
            {
              v21 = sub_1001A460(*(_DWORD *)(v5 + 112), v5, v6, v46);
              v9 = a4;
              v20 = v21;
              v8 = a3;
            }
            else
            {
              v20 = v46;
            }
            v23 = *(_DWORD *)(v6 + 32);
            v22 = 0;
            if ( *(_DWORD *)(v23 + 4) > 0 )
              break;
          }
LABEL_42:
          if ( dword_100762B8 > (char)v46 || (char)v46 >= 256 )
          {
            v28 = *(_DWORD *)(v6 + 28);
            if ( v28 )
            {
              v30 = *(_DWORD *)(v28 + 8);
              v29 = v30 + *(_DWORD *)(v28 + 4);
              if ( v30 != v29 )
              {
                do
                {
                  if ( *(_BYTE *)v30 == (_BYTE)v46 )
                    break;
                  ++v30;
                }
                while ( v30 != v29 );
                v9 = a4;
              }
              if ( v30 != *(_DWORD *)(v28 + 4) + *(_DWORD *)(v28 + 8) )
              {
                v19 = 1;
                goto LABEL_61;
              }
            }
            v31 = v45;
            if ( *(_WORD *)(v6 + 36) )
            {
              v32 = sub_1001A530(*(_DWORD *)(v45 + 112), v45, v46, *(_WORD *)(v6 + 36));
              v9 = a4;
              v33 = v32 == 0;
              v8 = a3;
              if ( !v33 )
              {
                v19 = 1;
                goto LABEL_61;
              }
            }
            v34 = *(_DWORD *)(v6 + 40);
            if ( v34 )
            {
              v35 = sub_1001BFA0(v46, v34, *(void **)(v31 + 112));
              v9 = a4;
              v36 = v35 == 0;
              v8 = a3;
              if ( !v36 )
                goto LABEL_59;
            }
          }
          else
          {
            if ( *(_DWORD *)(v6 + 24)
              && (unsigned __int8)(1 << (v46 & 7)) & *(_BYTE *)(((unsigned int)(char)v46 >> 3) + *(_DWORD *)(v6 + 24)) )
            {
              v19 = 1;
              goto LABEL_61;
            }
          }
          v19 = 0;
LABEL_61:
          if ( v19 != (*(_BYTE *)(v6 + 8) & 1) )
          {
            v37 = v44;
            *(_DWORD *)v44 = v8;
            return v37;
          }
          v5 = v45;
          ++v8;
          a3 = v8;
          if ( v8 == v9 )
          {
LABEL_26:
            v7 = v44;
            goto LABEL_27;
          }
        }
        v24 = *(_DWORD *)(v23 + 8);
        while ( *(_BYTE *)(v24 + v22) > v20 || v20 > *(_BYTE *)(v24 + v22 + 1) )
        {
          v25 = *(_DWORD *)(v6 + 32);
          v22 += 2;
          v27 = __SETO__(v22, *(_DWORD *)(v25 + 4));
          v26 = v22 - *(_DWORD *)(v25 + 4) < 0;
          v9 = a4;
          if ( !(v26 ^ v27) )
            goto LABEL_42;
        }
LABEL_59:
        v19 = 1;
        goto LABEL_61;
      }
      break;
    }
  }
LABEL_27:
  *(_DWORD *)v7 = v8;
  return v7;
}
// 10073200: using guessed type int __security_cookie;
// 100762B8: using guessed type int dword_100762B8;

//----- (1001A270) --------------------------------------------------------
char __thiscall sub_1001A270(int this, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int v5; // eax@1
  int v6; // ST00_4@1
  int v7; // ST04_4@1
  int v8; // eax@3
  unsigned int v9; // edx@7
  int v10; // ebx@7
  int v11; // edi@8
  int v12; // ebx@9
  int v13; // ebx@11
  int v15; // eax@15
  int v16; // ecx@19

  v4 = this;
  v5 = *(_DWORD *)(this + 84);
  v6 = *(_DWORD *)(this + 104);
  *(_DWORD *)(this + 76) = v5;
  *(_DWORD *)this = v5;
  sub_1001A620(this + 4, v6, this);
  sub_1001A830(v4 + 20, *(_DWORD *)(v4 + 104));
  v3 = a2;
  v7 = *(_DWORD *)(v4 + 88);
  *(_BYTE *)(v4 + 101) = a2 != 0;
  *(_BYTE *)(v4 + 116) = 0;
  *(_DWORD *)(v4 + 120) = 10000000;
  *(_DWORD *)(v4 + 124) = 1000;
  *(_BYTE *)(v4 + 100) = 0;
  if ( !(unsigned __int8)loc_1001B950(v4, v7) )
  {
    if ( !(*(_BYTE *)(v4 + 96) & 0x80) || (v8 = *(_DWORD *)(v4 + 80), *(_DWORD *)v4 != v8) || *(_DWORD *)(v4 + 84) == v8 )
      return 0;
    sub_1001A420((void *)(v4 + 32), v4);
    *(_BYTE *)(v4 + 100) = 1;
  }
  if ( a2 )
  {
    v10 = a2 + 8;
    sub_1001ADC0(a2 + 8, *(_DWORD *)(v4 + 104));
    v9 = 0;
    if ( *(_DWORD *)(v4 + 104) > 0 )
    {
      v11 = 0;
      do
      {
        v12 = *(_DWORD *)(v4 + 36);
        if ( (signed int)v9 < 0 && v9 )
          v13 = v12 - (4 * ((-1 - v9) >> 5) + 4);
        else
          v13 = v12 + 4 * (v9 >> 5);
        if ( (1 << (v9 & 0x1F)) & *(_DWORD *)v13 )
        {
          v10 = a2 + 8;
          *(_BYTE *)(v11 + *(_DWORD *)(a2 + 8) + 8) = 1;
          *(_DWORD *)(v11 + *(_DWORD *)(a2 + 8)) = *(_DWORD *)(*(_DWORD *)(v4 + 52) + 8 * v9);
          v15 = *(_DWORD *)(*(_DWORD *)(v4 + 52) + 8 * v9 + 4);
        }
        else
        {
          v10 = a2 + 8;
          *(_BYTE *)(v11 + *(_DWORD *)(a2 + 8) + 8) = 0;
          *(_DWORD *)(v11 + *(_DWORD *)(a2 + 8)) = *(_DWORD *)(v4 + 80);
          v15 = *(_DWORD *)(v4 + 80);
        }
        ++v9;
        *(_DWORD *)(v11 + *(_DWORD *)v10 + 4) = v15;
        v11 += 12;
      }
      while ( (signed int)v9 < *(_DWORD *)(v4 + 104) );
      v3 = a2;
    }
    v16 = *(_DWORD *)v10;
    *(_DWORD *)v3 = *(_DWORD *)(v4 + 76);
    *(_BYTE *)(v3 + 28) = 1;
    *(_DWORD *)(v3 + 20) = *(_DWORD *)(v4 + 76);
    *(_DWORD *)(v3 + 24) = *(_DWORD *)v16;
    *(_BYTE *)(v3 + 40) = 1;
    *(_DWORD *)(v3 + 32) = *(_DWORD *)(v16 + 4);
    *(_DWORD *)(v3 + 36) = *(_DWORD *)(v4 + 80);
    *(_DWORD *)(v3 + 44) = *(_DWORD *)(v4 + 80);
    *(_DWORD *)(v3 + 48) = *(_DWORD *)(v4 + 80);
    *(_BYTE *)(v3 + 4) = 1;
  }
  return 1;
}

//----- (1001A420) --------------------------------------------------------
void *__thiscall sub_1001A420(void *this, int a2)
{
  void *v3; // edi@1
  int v4; // ecx@1

  v3 = this;
  *(_DWORD *)this = *(_DWORD *)a2;
  v4 = (int)((char *)this + 4);
  *(_DWORD *)(v4 + 12) = *(_DWORD *)(a2 + 16);
  sub_1001ACB0(v4, a2 + 4);
  sub_1001A740((char *)v3 + 20, a2 + 20);
  return v3;
}

//----- (1001A460) --------------------------------------------------------
char __userpurge sub_1001A460<al>(int a1<ecx>, int a2<ebx>, int a3<edi>, __int16 a4)
{
  void **v4; // esi@1
  int v5; // ecx@2
  int v6; // eax@2
  int v7; // eax@2
  int v8; // edx@2
  int v9; // eax@3
  int *v10; // eax@6
  char v11; // bl@8
  unsigned int v13; // [sp-4h] [bp-3Ch]@1
  int v14; // [sp+8h] [bp-30h]@2
  void *v15; // [sp+Ch] [bp-2Ch]@5
  int v16; // [sp+1Ch] [bp-1Ch]@5
  unsigned int v17; // [sp+20h] [bp-18h]@6
  unsigned int v18; // [sp+24h] [bp-14h]@1
  int v19; // [sp+34h] [bp-4h]@2
  int v20; // [sp+38h] [bp+0h]@1

  v18 = (unsigned int)&v20 ^ __security_cookie;
  v13 = (unsigned int)&v20 ^ __security_cookie;
  v4 = (void **)a1;
  if ( !*(_DWORD *)a1 )
  {
    v6 = sub_1001B150(a1, (int)&v14);
    v19 = 0;
    v7 = sub_1001C310(v8, a2, a3, v6);
    v19 = -1;
    v5 = v14;
    *v4 = (void *)v7;
    if ( v5 )
    {
      v9 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v5 + 8))(v13);
      if ( v9 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v9)(v9, 1);
    }
  }
  sub_1001AEF0(*v4, (int)&v15, (int)&a4, (int)((char *)&a4 + 1));
  if ( v16 == 1 )
  {
    v10 = (int *)&v15;
    if ( v17 >= 0x10 )
      v10 = (int *)v15;
    v11 = *(_BYTE *)v10;
  }
  else
  {
    v11 = a4;
  }
  if ( v17 >= 0x10 )
    sub_1002A4AA(v15);
  return v11;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (1001A530) --------------------------------------------------------
bool __userpurge sub_1001A530<eax>(int a1<ecx>, char a2<bl>, unsigned __int8 a3, int a4)
{
  unsigned __int16 v4; // di@1
  int v5; // esi@1
  int v6; // ecx@3
  int v7; // eax@3
  int v8; // eax@3
  int v9; // edx@3
  int v10; // eax@4
  bool result; // eax@6

  v5 = a1;
  v4 = a4;
  if ( (_WORD)a4 == -1 )
  {
    result = a3 == 95 || *(_WORD *)(*(_DWORD *)(sub_1001A9A0(a1, a3, (unsigned __int16)a4) + 12) + 2 * a3) & 0x107;
  }
  else
  {
    if ( !*(_DWORD *)(a1 + 4) )
    {
      v7 = sub_1001B150(a1, (int)&a4);
      v8 = sub_10017B50(v9, a2, v4, v7);
      v6 = a4;
      *(_DWORD *)(v5 + 4) = v8;
      if ( v6 )
      {
        v10 = (*(int (**)(void))(*(_DWORD *)v6 + 8))();
        if ( v10 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v10)(v10, 1);
      }
    }
    result = (v4 & *(_WORD *)(*(_DWORD *)(*(_DWORD *)(v5 + 4) + 12) + 2 * a3)) != 0;
  }
  return result;
}

//----- (1001A620) --------------------------------------------------------
void __thiscall sub_1001A620(int this, int a2, int a3)
{
  unsigned int v3; // esi@1
  int v4; // edx@2
  int v5; // edi@2
  int v6; // eax@10
  int v7; // edi@10
  int v8; // esi@10
  int v9; // eax@10
  char v10; // [sp+10h] [bp-20h]@10
  char v11; // [sp+18h] [bp-18h]@10
  int v12; // [sp+20h] [bp-10h]@8
  int v13; // [sp+24h] [bp-Ch]@10
  int v14; // [sp+28h] [bp-8h]@1
  char v15; // [sp+2Ch] [bp-4h]@1

  v3 = *(_DWORD *)(this + 12);
  v14 = this;
  v15 = 0;
  if ( a2 <= v3 )
  {
    if ( a2 < v3 )
    {
      v6 = sub_1001AA20(this, (int)&v11);
      v7 = *(_DWORD *)v6;
      v8 = *(_DWORD *)(v6 + 4);
      v12 = *(_DWORD *)v14;
      v13 = 0;
      v9 = sub_1001B0B0((int)&v12, (int)&v10, a2);
      sub_1001AA80(v14, (int)&v12, *(_DWORD *)v9, *(_DWORD *)(v9 + 4), v7, v8);
    }
  }
  else
  {
    v5 = *(_DWORD *)this;
    v4 = 0;
    if ( v3 )
    {
      if ( (signed int)v3 < 0 && v3 )
      {
        this = v14;
        v5 += -4 - 4 * ((-1 - v3) >> 5);
      }
      else
      {
        v5 += 4 * (v3 >> 5);
      }
      v4 = v3 & 0x1F;
    }
    sub_1001ABB0((void *)this, (int)&v12, a2 - v3, (int)&v15, v5, v4);
  }
}

//----- (1001A6E0) --------------------------------------------------------
int __thiscall sub_1001A6E0(void *this, int a2, unsigned int a3)
{
  int v3; // esi@1
  int result; // eax@3

  v3 = *(_DWORD *)this;
  if ( (signed int)a3 < 0 && a3 )
  {
    result = a2;
    *(_DWORD *)a2 = -4 - 4 * ((-1 - a3) >> 5) + v3;
    *(_DWORD *)(a2 + 4) = a3 & 0x1F;
  }
  else
  {
    result = a2;
    *(_DWORD *)a2 = v3 + 4 * (a3 >> 5);
    *(_DWORD *)(a2 + 4) = a3 & 0x1F;
  }
  return result;
}

//----- (1001A740) --------------------------------------------------------
void *__thiscall sub_1001A740(void *this, int a2)
{
  void *v2; // edi@1
  int v3; // ecx@2
  int v4; // esi@2
  int v6; // edx@4
  int v7; // eax@6
  int v8; // ecx@9
  int v9; // esi@9
  int v10; // [sp-10h] [bp-20h]@9
  int v11; // [sp+8h] [bp-8h]@4

  v2 = this;
  if ( this == (void *)a2 )
    return v2;
  v3 = *(_DWORD *)a2;
  v4 = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)a2 == v4 )
  {
    *((_DWORD *)v2 + 1) = *(_DWORD *)v2;
    return v2;
  }
  v6 = *(_DWORD *)v2;
  v11 = (*((_DWORD *)v2 + 1) - *(_DWORD *)v2) >> 3;
  if ( (v4 - v3) >> 3 > (unsigned int)v11 )
  {
    if ( (v4 - v3) >> 3 > (unsigned int)((*((_DWORD *)v2 + 2) - v6) >> 3) )
    {
      if ( v6 )
        sub_1002A4AA((LPVOID)v6);
      if ( !(unsigned __int8)loc_1001AE80(v2, (*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 3) )
        return v2;
      v10 = *(_DWORD *)v2;
      v8 = *(_DWORD *)a2;
    }
    else
    {
      v9 = v3 + 8 * v11;
      sub_1001C2E0(v3, v3 + 8 * v11, v6);
      v10 = *((_DWORD *)v2 + 1);
      v8 = v9;
    }
    *((_DWORD *)v2 + 1) = sub_1001D7A0(v8, *(_DWORD *)(a2 + 4), v10);
    return v2;
  }
  for ( ; v3 != v4; v6 += 8 )
  {
    *(_DWORD *)v6 = *(_DWORD *)v3;
    v7 = *(_DWORD *)(v3 + 4);
    v3 += 8;
    *(_DWORD *)(v6 + 4) = v7;
  }
  *((_DWORD *)v2 + 1) = *(_DWORD *)v2 + 8 * ((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 3);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1001A830) --------------------------------------------------------
int __thiscall sub_1001A830(int this, unsigned int a2)
{
  int result; // eax@1
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // edx@2

  v4 = this;
  v5 = *(_DWORD *)(this + 4);
  result = *(_DWORD *)this;
  v3 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 3;
  if ( v3 <= a2 )
  {
    if ( v3 >= a2 )
      return result;
    loc_10019C80(v4, a2 - v3);
    sub_1001D7D0(*(_DWORD *)(v4 + 4), a2 - ((*(_DWORD *)(v4 + 4) - *(_DWORD *)v4) >> 3));
    result = *(_DWORD *)(v4 + 4) + 8 * (a2 - ((*(_DWORD *)(v4 + 4) - *(_DWORD *)v4) >> 3));
    goto LABEL_9;
  }
  v6 = result + 8 * a2;
  if ( v6 == result )
  {
LABEL_9:
    *(_DWORD *)(v4 + 4) = result;
    return result;
  }
  if ( v6 != v5 )
  {
    result = v5;
    *(_DWORD *)(v4 + 4) = v6;
  }
  return result;
}

//----- (1001A8D0) --------------------------------------------------------
int __thiscall sub_1001A8D0(int this)
{
  int v1; // ebx@1
  int v2; // edi@1
  int v3; // esi@2
  int result; // eax@3
  int v5; // esi@3
  int v6; // esi@5
  int i; // edi@7
  int v8; // esi@8

  v1 = this;
  v2 = *(_DWORD *)(this + 20);
  *(_DWORD *)this = off_10067B04;
  while ( v2 )
  {
    v3 = v2;
    v2 = *(_DWORD *)(v2 + 16);
    sub_100309C2(v1, *(LPVOID *)(v3 + 12));
    sub_1002A4AA((LPVOID)v3);
  }
  result = sub_1002A4AA(*(LPVOID *)(v1 + 24));
  v5 = *(_DWORD *)(v1 + 28);
  if ( v5 )
  {
    sub_100309C2(v1, *(LPVOID *)(v5 + 8));
    result = sub_1002A4AA((LPVOID)v5);
  }
  v6 = *(_DWORD *)(v1 + 32);
  if ( v6 )
  {
    sub_100309C2(v1, *(LPVOID *)(v6 + 8));
    result = sub_1002A4AA((LPVOID)v6);
  }
  for ( i = *(_DWORD *)(v1 + 40); i; result = sub_1002A4AA((LPVOID)v8) )
  {
    v8 = i;
    i = *(_DWORD *)(i + 16);
    sub_100309C2(v1, *(LPVOID *)(v8 + 12));
  }
  *(_DWORD *)v1 = off_10067B0C;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067B04: using guessed type int (__stdcall *off_10067B04[4])(char);
// 10067B0C: using guessed type int (__stdcall *off_10067B0C[2])(char);

//----- (1001A970) --------------------------------------------------------
void *__thiscall sub_1001A970(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_1001A8D0(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1001A9A0) --------------------------------------------------------
int __usercall sub_1001A9A0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // esi@1
  int result; // eax@2
  int v5; // ecx@2
  int v6; // eax@2
  int v7; // edx@2
  int v8; // eax@3
  int v9; // [sp+8h] [bp-10h]@2
  int v10; // [sp+14h] [bp-4h]@2

  v3 = a1;
  if ( !*(_DWORD *)(a1 + 4) )
  {
    v6 = sub_1001B150(a1, (int)&v9);
    v10 = 0;
    result = sub_10017B50(v7, a2, a3, v6);
    v10 = -1;
    v5 = v9;
    *(_DWORD *)(v3 + 4) = result;
    if ( !v5 )
      return result;
    v8 = (*(int (**)(void))(*(_DWORD *)v5 + 8))();
    if ( v8 )
      (**(void (__thiscall ***)(_DWORD, _DWORD))v8)(v8, 1);
  }
  return *(_DWORD *)(v3 + 4);
}

//----- (1001AA20) --------------------------------------------------------
int __thiscall sub_1001AA20(int this, int a2)
{
  unsigned int v2; // edx@1
  int v3; // edi@1
  int result; // eax@4

  v2 = *(_DWORD *)(this + 12);
  v3 = *(_DWORD *)this;
  *(_DWORD *)a2 = *(_DWORD *)this;
  *(_DWORD *)(a2 + 4) = 0;
  if ( v2 )
  {
    if ( (signed int)v2 < 0 && v2 )
    {
      result = a2;
      *(_DWORD *)a2 = v3 - (4 * ((-1 - v2) >> 5) + 4);
      *(_DWORD *)(a2 + 4) = v2 & 0x1F;
      return result;
    }
    *(_DWORD *)a2 = v3 + 4 * (v2 >> 5);
    *(_DWORD *)(a2 + 4) = v2 & 0x1F;
  }
  return a2;
}

//----- (1001AA80) --------------------------------------------------------
int __thiscall sub_1001AA80(int this, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // ecx@1
  int v7; // ebx@1
  unsigned int v8; // esi@1
  int v9; // eax@3
  int v10; // edx@3
  unsigned int v11; // edx@4
  int v12; // ecx@10
  int v13; // ecx@12
  int result; // eax@14
  int v15; // [sp+14h] [bp-20h]@1
  unsigned int v16; // [sp+18h] [bp-1Ch]@1
  int v17; // [sp+1Ch] [bp-18h]@1
  int v18; // [sp+20h] [bp-14h]@1
  int v19; // [sp+24h] [bp-10h]@1
  unsigned int v20; // [sp+28h] [bp-Ch]@2
  unsigned int v21; // [sp+2Ch] [bp-8h]@1
  int v22; // [sp+34h] [bp+0h]@1

  v21 = (unsigned int)&v22 ^ __security_cookie;
  v17 = a2;
  v7 = this;
  v18 = this;
  v15 = 0;
  sub_1001B170(this, (int)&v15, a3, a4);
  v19 = 0;
  sub_1001B170(v7, (int)&v19, a5, a6);
  v6 = *(_DWORD *)v7;
  v8 = v16 + 32 * ((v15 - *(_DWORD *)v7) >> 2);
  if ( v15 != v19 || v16 != v20 )
  {
    v10 = 0;
    v9 = *(_DWORD *)(v18 + 12);
    if ( v9 )
    {
      v11 = *(_DWORD *)(v18 + 12);
      if ( v9 < 0 && v9 )
      {
        v8 = v16 + 32 * ((v15 - *(_DWORD *)v7) >> 2);
        v6 = -4 - 4 * ((-1 - v11) >> 5) + *(_DWORD *)v18;
      }
      else
      {
        v6 += 4 * (v11 >> 5);
      }
      v10 = v11 & 0x1F;
    }
    sub_1001E690(&v19, v17, v19, v20, v6, v10, v15, v16);
    loc_1001B2C0(v18, v20 + 32 * ((v19 - *(_DWORD *)v18) >> 2));
  }
  v20 = 0;
  v12 = *(_DWORD *)v18;
  if ( (signed int)v8 < 0 && v8 )
    v13 = -4 - 4 * ((-1 - v8) >> 5) + v12;
  else
    v13 = v12 + 4 * (v8 >> 5);
  result = v17;
  *(_DWORD *)v17 = v13;
  *(_DWORD *)(result + 4) = v8 & 0x1F;
  return result;
}
// 10073200: using guessed type int __security_cookie;

//----- (1001ABB0) --------------------------------------------------------
int __thiscall sub_1001ABB0(void *this, int a2, int a3, int a4, int a5, int a6)
{
  unsigned int v6; // edx@1
  unsigned int v7; // edi@1
  void *v8; // ebx@1
  int v9; // edx@5
  int v10; // ecx@7
  int v11; // ecx@9
  int v12; // esi@9
  int result; // eax@11
  void *v14; // [sp+14h] [bp-8h]@1
  int v15; // [sp+18h] [bp-4h]@1
  int v16; // [sp+28h] [bp+Ch]@1
  int v17; // [sp+28h] [bp+Ch]@3

  v8 = this;
  v14 = this;
  v7 = loc_1001B1E0(a3, a5, a6);
  v6 = v7 + a3;
  v15 = *(_DWORD *)v8;
  v16 = *(_DWORD *)v8;
  if ( (signed int)v6 < 0 && v6 )
    v17 = -4 - 4 * ((-1 - v6) >> 5) + v16;
  else
    v17 = v16 + 4 * (v6 >> 5);
  v9 = v6 & 0x1F;
  if ( (signed int)v7 < 0 && v7 )
    v10 = -4 - 4 * ((-1 - v7) >> 5) + v15;
  else
    v10 = v15 + 4 * (v7 >> 5);
  v12 = v7 & 0x1F;
  sub_1001D7F0(v7 & 0x1F, a4, v10, v7 & 0x1F, v17, v9);
  v11 = *(_DWORD *)v14;
  if ( (signed int)v7 < 0 && v7 )
  {
    result = a2;
    *(_DWORD *)a2 = -4 - 4 * ((-1 - v7) >> 5) + v11;
    *(_DWORD *)(a2 + 4) = v12;
  }
  else
  {
    result = a2;
    *(_DWORD *)(a2 + 4) = v12;
    *(_DWORD *)a2 = v11 + 4 * (v7 >> 5);
  }
  return result;
}

//----- (1001ACB0) --------------------------------------------------------
int __thiscall sub_1001ACB0(int this, int a2)
{
  int v2; // ebx@1
  int v3; // eax@2
  const void *v4; // edi@2
  int v6; // edx@4
  void *v7; // ecx@4
  const void *v8; // edi@7
  unsigned int v9; // esi@7
  unsigned int v10; // esi@11
  int v11; // [sp+8h] [bp-4h]@4

  v2 = this;
  if ( this != a2 )
  {
    v3 = *(_DWORD *)(a2 + 4);
    v4 = *(const void **)a2;
    if ( *(_DWORD *)a2 == v3 )
    {
      *(_DWORD *)(this + 4) = *(_DWORD *)this;
      return this;
    }
    v7 = *(void **)this;
    v6 = (v3 - (_DWORD)v4) >> 2;
    v11 = (*(_DWORD *)(v2 + 4) - *(_DWORD *)v2) >> 2;
    if ( v6 <= (unsigned int)v11 )
    {
      sub_1002A4B0(v7, v4, (v3 - (_DWORD)v4) & 0xFFFFFFFC);
      *(_DWORD *)(v2 + 4) = *(_DWORD *)v2 + 4 * ((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 2);
      return v2;
    }
    if ( v6 <= (unsigned int)((*(_DWORD *)(v2 + 8) - (_DWORD)v7) >> 2) )
    {
      v8 = (char *)v4 + 4 * v11;
      sub_1002A4B0(v7, *(const void **)a2, (unsigned int)((char *)v8 - *(_DWORD *)a2) & 0xFFFFFFFC);
      v9 = 4 * ((*(_DWORD *)(a2 + 4) - (_DWORD)v8) >> 2);
      *(_DWORD *)(v2 + 4) = (char *)sub_1002A4B0(*(void **)(v2 + 4), v8, v9) + v9;
      return v2;
    }
    if ( v7 )
      sub_1002A4AA(v7);
    if ( (unsigned __int8)loc_10019DC0(v2, (*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 2) )
    {
      v10 = 4 * ((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 2);
      *(_DWORD *)(v2 + 4) = (char *)sub_1002A4B0(*(void **)v2, *(const void **)a2, v10) + v10;
    }
  }
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1001ADC0) --------------------------------------------------------
int __thiscall sub_1001ADC0(int this, unsigned int a2)
{
  signed __int64 v2; // qax@1
  int v3; // ecx@1
  unsigned int v4; // ebx@1
  int v5; // edi@1
  int v6; // esi@1
  int v8; // [sp+Ch] [bp-4h]@1

  v4 = a2;
  v5 = this;
  v6 = *(_DWORD *)(this + 4);
  v8 = this;
  v2 = 715827883i64 * (*(_DWORD *)(this + 4) - *(_DWORD *)this);
  v3 = (HIDWORD(v2) >> 1) + (HIDWORD(v2) >> 31);
  if ( v3 <= a2 )
  {
    if ( v3 < a2 )
    {
      loc_1001B3B0(v5, a2 - v3);
      sub_1001D840(*(_DWORD *)(v5 + 4), v4 - (*(_DWORD *)(v5 + 4) - *(_DWORD *)v8) / 12);
      LODWORD(v2) = *(_DWORD *)(v8 + 4) + 12 * (v4 - (*(_DWORD *)(v8 + 4) - *(_DWORD *)v8) / 12);
      *(_DWORD *)(v8 + 4) = v2;
    }
  }
  else
  {
    LODWORD(v2) = sub_1001B330(v5, (int)&a2, *(_DWORD *)v5 + 12 * a2, v6);
  }
  return v2;
}

//----- (1001AEF0) --------------------------------------------------------
int __thiscall sub_1001AEF0(void *this, int a2, int a3, int a4)
{
  (*(void (__stdcall **)(int, int, int, _DWORD))(*(_DWORD *)this + 16))(a2, a3, a4, 0);
  return a2;
}

//----- (1001AF20) --------------------------------------------------------
bool __userpurge sub_1001AF20<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  bool result; // eax@2

  v6 = sub_10029DE6(a2, a3, a4, a5, a6, a1 + 8);
  if ( v6 >= 0 )
    result = v6 != 0;
  else
    result = -1;
  return result;
}

//----- (1001AF60) --------------------------------------------------------
int __thiscall sub_1001AF60(void *this, int a2, const CHAR *a3, UINT a4)
{
  signed int v4; // eax@1
  UINT v5; // ebx@1
  unsigned int v6; // ecx@3
  char v7; // cf@4
  unsigned int v8; // eax@8
  int v9; // edx@9
  WCHAR *v10; // ecx@12
  unsigned int v11; // ecx@16
  char v12; // cf@17
  int v14; // [sp+30h] [bp+10h]@2

  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  v5 = a4;
  v4 = a4 - (_DWORD)a3;
  if ( (const CHAR *)a4 != a3 )
  {
    v14 = (int)((char *)this + 8);
    do
    {
      v6 = *(_DWORD *)(a2 + 16);
      if ( v4 > v6 )
      {
        loc_10012FA0(a2, v4 - v6, 0);
      }
      else
      {
        v7 = *(_DWORD *)(a2 + 20) < 0x10u;
        *(_DWORD *)(a2 + 16) = v4;
        if ( v7 )
          *(_BYTE *)(a2 + v4) = 0;
        else
          *(_BYTE *)(*(_DWORD *)a2 + v4) = 0;
      }
      v8 = *(_DWORD *)(a2 + 20);
      if ( v8 < 0x10 )
        v9 = a2;
      else
        v9 = *(_DWORD *)a2;
      if ( v8 < 0x10 )
        v10 = (WCHAR *)a2;
      else
        v10 = *(WCHAR **)a2;
      v4 = sub_10029E7B(v10, v9 + *(_DWORD *)(a2 + 16), a3, v5, v14);
    }
    while ( (unsigned int)v4 > *(_DWORD *)(a2 + 16) && v4 );
  }
  v11 = *(_DWORD *)(a2 + 16);
  if ( v4 > v11 )
  {
    loc_10012FA0(a2, v4 - v11, 0);
  }
  else
  {
    v12 = *(_DWORD *)(a2 + 20) < 0x10u;
    *(_DWORD *)(a2 + 16) = v4;
    if ( v12 )
      *(_BYTE *)(a2 + v4) = 0;
    else
      *(_BYTE *)(*(_DWORD *)a2 + v4) = 0;
  }
  return a2;
}

//----- (1001B070) --------------------------------------------------------
int __stdcall sub_1001B070(int a1, int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  int v4; // eax@2

  v2 = -2128831035;
  v3 = 0;
  if ( a2 != a1 )
  {
    do
    {
      v4 = *(_BYTE *)(v3++ + a1);
      v2 = 16777619 * (v4 ^ v2);
    }
    while ( v3 < a2 - a1 );
  }
  return v2;
}

//----- (1001B0B0) --------------------------------------------------------
int __thiscall sub_1001B0B0(int this, int a2, int a3)
{
  unsigned int v3; // edx@1
  int v4; // esi@1
  int result; // eax@3
  int v6; // edx@3
  unsigned int v7; // edx@4

  v3 = *(_DWORD *)(this + 4);
  v4 = *(_DWORD *)this;
  if ( a3 >= 0 || v3 >= -a3 )
  {
    v7 = a3 + v3;
    result = a2;
    *(_DWORD *)a2 = v4 + 4 * (v7 >> 5);
    *(_DWORD *)(a2 + 4) = v7 & 0x1F;
  }
  else
  {
    v6 = a3 + v3;
    result = a2;
    *(_DWORD *)a2 = -4 - 4 * ((unsigned int)(-1 - v6) >> 5) + v4;
    *(_DWORD *)(a2 + 4) = v6 & 0x1F;
  }
  return result;
}

//----- (1001B110) --------------------------------------------------------
void *__userpurge sub_1001B110<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1
  void *v4; // ST00_4@1

  v3 = (void *)a1;
  v4 = *(void **)(a1 + 12);
  *(_DWORD *)a1 = &off_1006075C;
  sub_100309C2(a2, v4);
  *(_DWORD *)v3 = &off_10060654;
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10060654: using guessed type int (__stdcall *off_10060654)(char);
// 1006075C: using guessed type int (__stdcall *off_1006075C)(char);

//----- (1001B150) --------------------------------------------------------
int __thiscall sub_1001B150(int this, int a2)
{
  int v3; // ecx@1

  v3 = *(_DWORD *)(this + 8);
  *(_DWORD *)a2 = v3;
  (*(void (**)(void))(*(_DWORD *)v3 + 4))();
  return a2;
}

//----- (1001B170) --------------------------------------------------------
int __thiscall sub_1001B170(int this, int a2, int a3, int a4)
{
  unsigned int v4; // esi@2
  int v5; // esi@2
  char v6; // sf@2

  *(_DWORD *)a2 = 0;
  *(_DWORD *)a2 = *(_DWORD *)this;
  *(_DWORD *)(a2 + 4) = 0;
  if ( *(_DWORD *)(this + 12) )
  {
    v5 = 32 * ((a3 - *(_DWORD *)this) >> 2);
    v6 = a4 + v5 < 0;
    v4 = a4 + v5;
    if ( v6 && v4 )
    {
      *(_DWORD *)a2 += -4 - 4 * ((-1 - v4) >> 5);
      *(_DWORD *)(a2 + 4) = v4 & 0x1F;
      return a2;
    }
    *(_DWORD *)a2 += 4 * (v4 >> 5);
    *(_DWORD *)(a2 + 4) = v4 & 0x1F;
  }
  return a2;
}

//----- (1001B330) --------------------------------------------------------
int __thiscall sub_1001B330(int this, int a2, int a3, int a4)
{
  int v4; // edx@1
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@5
  int v8; // ecx@5
  int v9; // edx@6

  v4 = a3;
  v5 = this;
  v6 = a4;
  if ( a3 != *(_DWORD *)this || a4 != *(_DWORD *)(this + 4) )
  {
    if ( a3 != a4 )
    {
      v7 = *(_DWORD *)(this + 4);
      v8 = a3;
      if ( a4 != v7 )
      {
        v9 = *(_DWORD *)(v5 + 4);
        do
        {
          *(_DWORD *)v8 = *(_DWORD *)v6;
          *(_DWORD *)(v8 + 4) = *(_DWORD *)(v6 + 4);
          *(_BYTE *)(v8 + 8) = *(_BYTE *)(v6 + 8);
          v6 += 12;
          v8 += 12;
        }
        while ( v6 != v9 );
        v4 = a3;
      }
      *(_DWORD *)(v5 + 4) = v8;
    }
  }
  else
  {
    *(_DWORD *)(this + 4) = *(_DWORD *)this;
  }
  *(_DWORD *)a2 = v4;
  return a2;
}

//----- (1001B450) --------------------------------------------------------
int __thiscall sub_1001B450(int this, unsigned int a2, int a3)
{
  int result; // eax@1
  int v4; // ecx@1
  int v5; // ebx@1
  void *v6; // edi@1
  void *v7; // esi@2
  char v8; // [sp+8h] [bp-4h]@8

  v5 = this;
  result = *(_DWORD *)(this + 4);
  v6 = *(void **)this;
  v4 = (*(_DWORD *)(this + 4) - *(_DWORD *)this) >> 2;
  if ( v4 <= a2 )
  {
    if ( v4 < a2 )
      result = loc_1001B560(v5, &v8, result, a2 - v4, a3);
  }
  else
  {
    v7 = (char *)v6 + 4 * a2;
    if ( v7 == v6 )
    {
      *(_DWORD *)(v5 + 4) = v6;
    }
    else
    {
      if ( v7 != (void *)result )
      {
        sub_1002A4B0(v7, (const void *)result, 0);
        result = (int)((char *)v6 + 4 * a2);
        *(_DWORD *)(v5 + 4) = v7;
      }
    }
  }
  return result;
}

//----- (1001B4D0) --------------------------------------------------------
int __thiscall sub_1001B4D0(void *this, int a2, void *a3, const void *a4)
{
  void *v4; // eax@1
  void *v5; // ecx@1
  unsigned int v7; // esi@6
  void *v8; // [sp+8h] [bp-8h]@1

  v4 = this;
  v5 = *(void **)this;
  v8 = v4;
  if ( a3 == v5 && a4 == *((const void **)v4 + 1) )
  {
    *((_DWORD *)v4 + 1) = v5;
LABEL_4:
    *(_DWORD *)a2 = a3;
    return a2;
  }
  if ( a3 == a4 )
    goto LABEL_4;
  v7 = 4 * ((*((_DWORD *)v4 + 1) - (_DWORD)a4) >> 2);
  sub_1002A4B0(a3, a4, v7);
  *((_DWORD *)v8 + 1) = (char *)a3 + v7;
  *(_DWORD *)a2 = a3;
  return a2;
}

//----- (1001B770) --------------------------------------------------------
int __thiscall sub_1001B770(int this, int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  int v4; // edx@2
  int result; // eax@4
  int v6; // edx@5

  v2 = (*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 2;
  v3 = (unsigned int)(*(_DWORD *)(this + 8) - *(_DWORD *)this) >> 3;
  if ( 1073741823 - v3 >= v2 )
  {
    v6 = v3 + v2;
    if ( v6 < (unsigned int)a2 )
      v6 = a2;
    result = v6;
  }
  else
  {
    v4 = 0;
    if ( (unsigned int)a2 > 0 )
      v4 = a2;
    result = v4;
  }
  return result;
}

//----- (1001B7B0) --------------------------------------------------------
int __userpurge sub_1001B7B0<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5, int a6)
{
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // edi@1
  int v10; // [sp+14h] [bp-10h]@1
  int v11; // [sp+20h] [bp-4h]@3

  v8 = a1;
  *(_DWORD *)a1 = a4;
  *(_DWORD *)(a1 + 4) = a4;
  *(_DWORD *)(a1 + 8) = a5;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  v10 = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  sub_10019D80((void *)(a1 + 20), 0, (int)&v10);
  *(_DWORD *)(v8 + 32) = 0;
  v7 = *(_DWORD *)(v8 + 20);
  v6 = (*(_DWORD *)(v8 + 24) - v7) >> 2;
  if ( v6 )
    sub_1001B4D0((void *)(v8 + 20), (int)&v10, (void *)v7, *(const void **)(v8 + 24));
  *(_DWORD *)(v8 + 32) = 0;
  v11 = 1;
  sub_1001C870(v6, v8 + 36, a2, v8, a3, v7);
  *(_DWORD *)(v8 + 60) = a3;
  *(_DWORD *)(v8 + 64) = 1;
  *(_DWORD *)(v8 + 80) = 142040571;
  sub_1001C5A0((void *)v8);
  return v8;
}

//----- (1001B890) --------------------------------------------------------
#error "1001B916: positive sp value has been found (funcsize=47)"

//----- (1001BE80) --------------------------------------------------------
int __fastcall sub_1001BE80(int a1, int a2, int a3, int a4, int a5, int a6, __int16 a7, char a8)
{
  int v8; // esi@1
  int v9; // eax@2
  int v11; // [sp+8h] [bp-8h]@2
  unsigned int v12; // [sp+Ch] [bp-4h]@1
  int v13; // [sp+10h] [bp+0h]@1

  v12 = (unsigned int)&v13 ^ __security_cookie;
  v8 = a1;
  *(_DWORD *)a1 = a4;
  if ( a7 & 0x800 )
  {
    v9 = sub_1001D2B0((int)&v11, a2, a3, a4, a5, a6, a8);
  }
  else
  {
    if ( a7 & 0x100 )
    {
      v9 = sub_1001D4B0((int)&v11, a2, a3, (int *)a4, a5, a6, a8);
    }
    else
    {
      LOBYTE(v11) = 0;
      v9 = sub_1001D560((int)&v11, a2, a3, a4, a5, v11, a8);
    }
  }
  *(_DWORD *)v8 = *(_DWORD *)v9;
  return v8;
}
// 10073200: using guessed type int __security_cookie;

//----- (1001BF10) --------------------------------------------------------
int __fastcall sub_1001BF10(int a1, int a2, int a3, int a4)
{
  int v4; // eax@1
  int v5; // edx@2
  unsigned int v6; // eax@3
  int v7; // ecx@4
  unsigned int v8; // ebx@4
  int v9; // edx@5
  char v10; // al@6
  char v11; // zf@6
  int result; // eax@14
  int v13; // [sp+Ch] [bp-14h]@2
  int v14; // [sp+10h] [bp-10h]@1
  unsigned int v15; // [sp+14h] [bp-Ch]@3
  int v16; // [sp+18h] [bp-8h]@1
  int v17; // [sp+1Ch] [bp-4h]@2

  v4 = a2;
  v16 = a2;
  v14 = a1;
  if ( a2 )
  {
    while ( 1 )
    {
      v5 = 0;
      v17 = 0;
      v13 = *(_DWORD *)(v4 + 8);
      if ( v13 > 0 )
        break;
LABEL_12:
      v4 = *(_DWORD *)(v4 + 16);
      v16 = v4;
      if ( !v4 )
      {
        a1 = v14;
        goto LABEL_14;
      }
    }
    v6 = *(_DWORD *)v4;
    v15 = v6;
    while ( 1 )
    {
      v8 = 0;
      v7 = a3;
      if ( v6 )
      {
        v9 = v17 + *(_DWORD *)(v16 + 12);
        do
        {
          v10 = *(_BYTE *)v7++;
          v11 = v10 == *(_BYTE *)v9;
          v6 = v15;
          if ( !v11 )
            break;
          ++v8;
          ++v9;
        }
        while ( v8 < v15 );
        v5 = v17;
      }
      if ( v7 == a4 )
        break;
      v5 += v6;
      v17 = v5;
      if ( v5 >= v13 )
      {
        v4 = v16;
        goto LABEL_12;
      }
    }
    result = v14;
    *(_DWORD *)v14 = a4;
  }
  else
  {
LABEL_14:
    *(_DWORD *)a1 = a3;
    result = a1;
  }
  return result;
}

//----- (1001BFA0) --------------------------------------------------------
char __fastcall sub_1001BFA0(unsigned __int8 a1, int a2, void *a3)
{
  int v3; // ebx@1
  void *v4; // edi@1
  int v5; // esi@1
  int v6; // ecx@8
  int *v7; // ecx@9
  int v8; // ecx@11
  int v9; // esi@13
  int *v10; // edx@23
  int *v11; // eax@25
  unsigned int v12; // esi@27
  char v13; // cf@30
  int v14; // esi@30
  char v15; // cf@32
  unsigned __int8 v16; // cf@34
  unsigned __int8 v17; // cl@36
  unsigned __int8 v18; // cl@38
  unsigned __int8 v19; // al@40
  int v20; // eax@41
  char v21; // bl@48
  int v23; // [sp-8h] [bp-80h]@11
  void *v24; // [sp+10h] [bp-68h]@1
  unsigned int v25; // [sp+24h] [bp-54h]@5
  void *v26; // [sp+28h] [bp-50h]@1
  int v27; // [sp+2Ch] [bp-4Ch]@8
  int v28; // [sp+30h] [bp-48h]@1
  void *v29; // [sp+34h] [bp-44h]@1
  unsigned int v30; // [sp+44h] [bp-34h]@1
  unsigned int v31; // [sp+48h] [bp-30h]@1
  void *v32; // [sp+4Ch] [bp-2Ch]@1
  unsigned int v33; // [sp+5Ch] [bp-1Ch]@1
  unsigned int v34; // [sp+60h] [bp-18h]@1
  unsigned int v35; // [sp+64h] [bp-14h]@1
  int v36; // [sp+74h] [bp-4h]@1
  int v37; // [sp+78h] [bp+0h]@1

  v35 = (unsigned int)&v37 ^ __security_cookie;
  v3 = a2;
  v28 = a2;
  v4 = a3;
  v26 = a3;
  v34 = 15;
  v33 = 0;
  LOBYTE(v32) = 0;
  v36 = 0;
  v31 = 15;
  LOWORD(v29) = a1;
  v30 = 1;
  LOBYTE(v36) = 1;
  v5 = sub_1001D600(a3, (int)&v24, (int)&v29, (int)((char *)&v29 + 1));
  if ( &v29 != (void **)v5 )
  {
    if ( v31 >= 0x10 )
      sub_1002A4AA(v29);
    v31 = 15;
    v30 = 0;
    LOBYTE(v29) = 0;
    sub_100017B0(&v29, v5);
  }
  if ( v25 >= 0x10 )
    sub_1002A4AA(v24);
  if ( !v3 )
  {
LABEL_48:
    v21 = 0;
    goto LABEL_49;
  }
  while ( 1 )
  {
    v6 = 0;
    v27 = 0;
    if ( *(_DWORD *)(v3 + 8) > 0 )
      break;
LABEL_47:
    v3 = *(_DWORD *)(v3 + 16);
    v28 = v3;
    if ( !v3 )
      goto LABEL_48;
  }
  while ( 1 )
  {
    loc_1000AEB0(&v32, v6 + *(_DWORD *)(v3 + 12), *(_DWORD *)v3);
    v7 = (int *)&v32;
    if ( v34 >= 0x10 )
      v7 = (int *)v32;
    v23 = (int)((char *)v7 + v33);
    v8 = (int)&v32;
    if ( v34 >= 0x10 )
      v8 = (int)v32;
    v9 = sub_1001D600(v4, (int)&v24, v8, v23);
    if ( &v32 != (void **)v9 )
    {
      if ( v34 >= 0x10 )
        sub_1002A4AA(v32);
      v34 = 15;
      v33 = 0;
      LOBYTE(v32) = 0;
      if ( *(_DWORD *)(v9 + 20) >= 0x10u )
      {
        v32 = *(void **)v9;
        *(_DWORD *)v9 = 0;
      }
      else
      {
        if ( *(_DWORD *)(v9 + 16) != -1 )
          sub_1002A4B0(&v32, (const void *)v9, *(_DWORD *)(v9 + 16) + 1);
      }
      v33 = *(_DWORD *)(v9 + 16);
      v34 = *(_DWORD *)(v9 + 20);
      *(_DWORD *)(v9 + 20) = 15;
      *(_DWORD *)(v9 + 16) = 0;
      *(_BYTE *)v9 = 0;
    }
    if ( v25 >= 0x10 )
      sub_1002A4AA(v24);
    v10 = (int *)&v29;
    if ( v31 >= 0x10 )
      v10 = (int *)v29;
    v11 = (int *)&v32;
    if ( v34 >= 0x10 )
      v11 = (int *)v32;
    v12 = v30;
    if ( v33 < v30 )
      v12 = v33;
    if ( !v12 )
      break;
    v13 = v12 < 4;
    v14 = v12 - 4;
    if ( v13 )
    {
LABEL_33:
      if ( v14 == -4 )
        goto LABEL_42;
    }
    else
    {
      while ( *v11 == *v10 )
      {
        ++v11;
        ++v10;
        v15 = (unsigned int)v14 < 4;
        v14 -= 4;
        if ( v15 )
          goto LABEL_33;
      }
    }
    v16 = *(_BYTE *)v11 < *(_BYTE *)v10;
    if ( *(_BYTE *)v11 != *(_BYTE *)v10
      || v14 != -3
      && ((v17 = *((_BYTE *)v11 + 1), v16 = v17 < *((_BYTE *)v10 + 1), v17 != *((_BYTE *)v10 + 1))
       || v14 != -2
       && ((v18 = *((_BYTE *)v11 + 2), v16 = v18 < *((_BYTE *)v10 + 2), v18 != *((_BYTE *)v10 + 2))
        || v14 != -1 && (v19 = *((_BYTE *)v11 + 3), v16 = v19 < *((_BYTE *)v10 + 3), v19 != *((_BYTE *)v10 + 3)))) )
    {
      v20 = -v16 | 1;
      goto LABEL_43;
    }
LABEL_42:
    v20 = 0;
LABEL_43:
    if ( !v20 )
      break;
LABEL_46:
    v3 = v28;
    v6 = *(_DWORD *)v28 + v27;
    v4 = v26;
    v27 = v6;
    if ( v6 >= *(_DWORD *)(v28 + 8) )
      goto LABEL_47;
  }
  if ( v33 < v30 || v33 != v30 )
    goto LABEL_46;
  v21 = 1;
LABEL_49:
  if ( v31 >= 0x10 )
    sub_1002A4AA(v29);
  v31 = 15;
  v30 = 0;
  LOBYTE(v29) = 0;
  if ( v34 >= 0x10 )
    sub_1002A4AA(v32);
  return v21;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (1001C250) --------------------------------------------------------
int __fastcall sub_1001C250(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a3;
  for ( _ESI = a1; _ESI != a2; result += 12 )
  {
    if ( result )
    {
      __asm
      {
        movq    xmm0, qword ptr [esi]
        movq    qword ptr [eax], xmm0
      }
      *(_DWORD *)(result + 8) = *(_DWORD *)(_ESI + 8);
    }
    _ESI += 12;
  }
  return result;
}

//----- (1001C280) --------------------------------------------------------
void *__thiscall sub_1001C280(void *this, int a2, int a3)
{
  void *result; // eax@1

  result = this;
  for ( _ECX = a2; _ECX != a3; result = (char *)result + 12 )
  {
    if ( result )
    {
      __asm
      {
        movq    xmm0, qword ptr [ecx]
        movq    qword ptr [eax], xmm0
      }
      *((_DWORD *)result + 2) = *(_DWORD *)(_ECX + 8);
    }
    _ECX += 12;
  }
  return result;
}

//----- (1001C2C0) --------------------------------------------------------
void __fastcall sub_1001C2C0(int _ECX, int a2)
{
  for ( ; a2; --a2 )
  {
    if ( _ECX )
    {
      __asm
      {
        xorps   xmm0, xmm0
        movq    qword ptr [ecx], xmm0
      }
    }
    _ECX += 8;
  }
}

//----- (1001C2E0) --------------------------------------------------------
int __fastcall sub_1001C2E0(int a1, int a2, int a3)
{
  int result; // eax@1

  for ( result = a3; a1 != a2; result += 8 )
  {
    *(_DWORD *)result = *(_DWORD *)a1;
    *(_DWORD *)(result + 4) = *(_DWORD *)(a1 + 4);
    a1 += 8;
  }
  return result;
}

//----- (1001C310) --------------------------------------------------------
int __usercall sub_1001C310<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4)
{
  int v4; // edx@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // ecx@5
  int v8; // esi@6
  int v9; // eax@10
  int v10; // edx@17
  int v11; // ecx@17
  char v13; // [sp+Ch] [bp-2Ch]@16
  void *v14; // [sp+18h] [bp-20h]@1
  int v15; // [sp+1Ch] [bp-1Ch]@1
  char v16; // [sp+20h] [bp-18h]@1
  char v17; // [sp+24h] [bp-14h]@2
  unsigned int v18; // [sp+28h] [bp-10h]@1
  int v19; // [sp+34h] [bp-4h]@1
  int v20; // [sp+38h] [bp+0h]@1

  v18 = (unsigned int)&v20 ^ __security_cookie;
  v14 = (void *)a4;
  sub_10029A76(a1, (int)&v16, a2, a3, 0);
  v19 = 0;
  v6 = dword_1007688C;
  v5 = dword_100762B4;
  v15 = dword_100762B4;
  if ( !dword_1007688C )
  {
    sub_10029A76(v4, (int)&v17, dword_100762B4, dword_1007688C, dword_1007688C);
    if ( dword_1007688C == v6 )
    {
      ++dword_100750C4;
      dword_1007688C = dword_100750C4;
    }
    sub_10029AD2(&v17);
    v6 = dword_1007688C;
  }
  v7 = *(_DWORD *)a4;
  if ( (unsigned int)v6 >= *(_DWORD *)(*(_DWORD *)a4 + 12) )
  {
    v8 = 0;
  }
  else
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v7 + 8) + 4 * v6);
    if ( v8 )
      goto LABEL_18;
  }
  if ( !*(_BYTE *)(v7 + 20) )
    goto LABEL_12;
  v9 = sub_10029877();
  if ( (unsigned int)v6 < *(_DWORD *)(v9 + 12) )
  {
    v8 = *(_DWORD *)(*(_DWORD *)(v9 + 8) + 4 * v6);
LABEL_12:
    if ( v8 )
      goto LABEL_18;
  }
  if ( v5 )
  {
    v8 = v5;
  }
  else
  {
    if ( sub_1001C440(v7, v4, (int)&v15, v14) == -1 )
    {
      sub_1002AE51((int)&v13, (unsigned int)"bad cast");
      sub_100355BB((int)&v13, (int)&unk_1006C964);
    }
    v8 = v15;
    dword_100762B4 = v15;
    (*(void (__thiscall **)(int))(*(_DWORD *)v15 + 4))(v15);
    sub_1002984F(v10, v11, v5, v6, v8);
  }
LABEL_18:
  sub_10029AD2(&v16);
  return v8;
}
// 10073200: using guessed type int __security_cookie;
// 100750C4: using guessed type int dword_100750C4;
// 100762B4: using guessed type int dword_100762B4;
// 1007688C: using guessed type int dword_1007688C;

//----- (1001C440) --------------------------------------------------------
signed int __fastcall sub_1001C440(int a1, int a2, int a3, void *a4)
{
  int v4; // ebx@1
  int v5; // esi@3
  int v6; // eax@4
  int v7; // edx@4
  int v8; // edx@6
  void *v10; // [sp+18h] [bp-5Ch]@4
  unsigned int v11; // [sp+2Ch] [bp-48h]@11
  char v12; // [sp+30h] [bp-44h]@6
  int v13; // [sp+70h] [bp-4h]@3

  v4 = 0;
  if ( a3 )
  {
    if ( !*(_DWORD *)a3 )
    {
      v5 = sub_1002ADB1(a2, a1, 0, a3, 16);
      v13 = 0;
      if ( v5 )
      {
        v6 = sub_10020A40(a4, (int)&v10);
        LOBYTE(v13) = 1;
        if ( *(_DWORD *)(v6 + 20) >= 0x10u )
          v6 = *(_DWORD *)v6;
        sub_100178F0(v7, (int)&v12, 0, v6);
        v4 = 3;
        *(_DWORD *)(v5 + 4) = 0;
        *(_DWORD *)v5 = &off_1006075C;
        *(_DWORD *)(v5 + 8) = sub_10029DC5(3, a3);
        *(_DWORD *)(v5 + 12) = v8;
      }
      else
      {
        v5 = 0;
      }
      *(_DWORD *)a3 = v5;
      if ( v4 & 2 )
      {
        v4 &= 0xFFFFFFFDu;
        sub_100179E0(&v12, v4);
      }
      if ( v4 & 1 )
      {
        if ( v11 >= 0x10 )
          sub_1002A4AA(v10);
      }
    }
  }
  return 1;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1006075C: using guessed type int (__stdcall *off_1006075C)(char);

//----- (1001C530) --------------------------------------------------------
int __thiscall sub_1001C530(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  if ( (unsigned __int8)loc_10019DC0((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 2) )
    *(_DWORD *)(v2 + 4) = sub_1001EE10(*(void **)v2, *(_DWORD *)a2, *(_DWORD *)(a2 + 4));
  return v2;
}

//----- (1001C5A0) --------------------------------------------------------
char __thiscall sub_1001C5A0(void *this)
{
  int v1; // esi@1
  unsigned __int8 v2; // al@3
  int v3; // eax@4
  int v4; // eax@7
  char v5; // zf@13

  v1 = (int)this;
  if ( *(_DWORD *)this == *((_DWORD *)this + 2) )
  {
    *((_DWORD *)this + 19) = -1;
    *((_BYTE *)this + 72) = -1;
  }
  else
  {
    v2 = **(_BYTE **)this;
    *((_BYTE *)this + 72) = v2;
    if ( sub_10030A70((int)"()$^.*+?[]|\\-{},:=!\n\r\b", v2) )
      v3 = *(_BYTE *)(v1 + 72);
    else
      v3 = 0;
    *(_DWORD *)(v1 + 76) = v3;
  }
  v4 = *(_BYTE *)(v1 + 72) - 10;
  switch ( *(_BYTE *)(v1 + 72) )
  {
    case 92:
      LOBYTE(v4) = sub_1001D9C0(v1);
      if ( (_BYTE)v4 )
      {
        LOBYTE(v4) = *(_BYTE *)(*(_DWORD *)v1 + 1);
        *(_BYTE *)(v1 + 72) = v4;
        *(_DWORD *)(v1 + 76) = (char)v4;
      }
      return v4;
    case 10:
      if ( *(_BYTE *)(v1 + 80) & 4 )
      {
        if ( !*(_DWORD *)(v1 + 16) )
          *(_DWORD *)(v1 + 76) = 124;
      }
      return v4;
    case 40:
    case 41:
      v5 = (*(_BYTE *)(v1 + 80) & 8) == 0;
      goto LABEL_26;
    case 123:
    case 125:
      v5 = (*(_BYTE *)(v1 + 80) & 0x10) == 0;
      goto LABEL_26;
    case 42:
      if ( *(_DWORD *)(v1 + 80) & 0x4000000 )
      {
        LOBYTE(v4) = sub_1001DE90(v1 + 36);
        if ( (_BYTE)v4 )
          *(_DWORD *)(v1 + 76) = 0;
      }
      return v4;
    case 94:
      if ( !(*(_DWORD *)(v1 + 80) & 0x2000000) )
        return v4;
      LOBYTE(v4) = sub_1001DE90(v1 + 36);
      v5 = (_BYTE)v4 == 0;
      goto LABEL_26;
    case 36:
      if ( *(_DWORD *)(v1 + 80) & 0x2000000 )
      {
        v4 = *(_DWORD *)v1 + 1;
        if ( v4 != *(_DWORD *)(v1 + 8) )
        {
          if ( *(_BYTE *)v4 != 10 )
            *(_DWORD *)(v1 + 76) = 0;
        }
      }
      return v4;
    case 43:
    case 63:
      v5 = (*(_BYTE *)(v1 + 80) & 1) == 0;
      goto LABEL_26;
    case 124:
      v5 = (*(_BYTE *)(v1 + 80) & 2) == 0;
LABEL_26:
      if ( v5 )
        *(_DWORD *)(v1 + 76) = 0;
      break;
    default:
      return v4;
  }
  return v4;
}

//----- (1001C750) --------------------------------------------------------
int __thiscall sub_1001C750(int this)
{
  int result; // eax@1
  int v2; // edx@1
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // eax@3
  int v6; // eax@5
  int v7; // ecx@5
  int v8; // eax@7
  int v9; // ecx@8
  int v10; // edx@16
  int v11; // ecx@16
  int v12; // eax@17
  int v14; // ecx@20
  int i; // [sp+Ch] [bp-4h]@4

  v4 = this;
  v3 = *(_DWORD *)(this + 40);
  result = loc_1001DA50();
  if ( !(_BYTE)result )
  {
    if ( *(_DWORD *)(v4 + 76) != 124 )
      return result;
    v5 = sub_1001DED0(v2, v4 + 36, v3, v4);
    sub_1001C8F0(v4 + 36, v2, v5);
  }
  result = sub_1001DF40(v2, v4 + 36, v3, v3);
  for ( i = result; *(_DWORD *)(v4 + 76) == 124; result = sub_1001E000(v4 + 36, v10, v3, i) )
  {
    v6 = *(_DWORD *)v4;
    v7 = *(_DWORD *)(v4 + 8);
    if ( *(_DWORD *)v4 != v7 )
    {
      if ( *(_BYTE *)v6 == 92 )
      {
        v8 = v6 + 1;
        if ( v8 != v7 )
        {
          v9 = *(_DWORD *)(v4 + 80);
          if ( !(v9 & 8) && (*(_BYTE *)v8 == 40 || *(_BYTE *)v8 == 41)
            || !(v9 & 0x10) && (*(_BYTE *)v8 == 123 || *(_BYTE *)v8 == 125) )
            *(_DWORD *)v4 = v8;
        }
      }
      ++*(_DWORD *)v4;
    }
    sub_1001C5A0((void *)v4);
    if ( !(unsigned __int8)loc_1001DA50(v4) )
    {
      v12 = sub_1002ADB1(v10, v11, v3, v4, 20);
      if ( v12 )
      {
        *(_DWORD *)v12 = off_10067B0C;
        *(_DWORD *)(v12 + 4) = 8;
        *(_DWORD *)(v12 + 8) = 0;
        *(_DWORD *)(v12 + 12) = 0;
        *(_DWORD *)(v12 + 16) = 0;
      }
      else
      {
        v12 = 0;
      }
      *(_DWORD *)(v12 + 16) = *(_DWORD *)(v4 + 40);
      v14 = *(_DWORD *)(*(_DWORD *)(v4 + 40) + 12);
      if ( v14 )
      {
        *(_DWORD *)(v12 + 12) = v14;
        *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v4 + 40) + 12) + 16) = v12;
      }
      *(_DWORD *)(*(_DWORD *)(v4 + 40) + 12) = v12;
      *(_DWORD *)(v4 + 40) = v12;
      sub_1001C8F0(v4 + 36, v10, v12);
    }
  }
  return result;
}
// 10067B0C: using guessed type int (__stdcall *off_10067B0C[2])(char);

//----- (1001C870) --------------------------------------------------------
int __userpurge sub_1001C870<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6)
{
  int v6; // eax@1
  int v7; // esi@1

  v7 = a2;
  v6 = sub_1002ADB1(a1, a2, a3, a4, 36);
  if ( v6 )
  {
    *(_DWORD *)(v6 + 4) = 20;
    *(_DWORD *)(v6 + 8) = 0;
    *(_DWORD *)(v6 + 12) = 0;
    *(_DWORD *)(v6 + 16) = 0;
    *(_DWORD *)v6 = off_10067B0C;
    *(_DWORD *)(v6 + 24) = 0;
    *(_DWORD *)(v6 + 28) = 0;
    *(_DWORD *)(v6 + 32) = 0;
  }
  else
  {
    v6 = 0;
  }
  *(_DWORD *)v7 = v6;
  *(_DWORD *)(v7 + 4) = v6;
  *(_DWORD *)(v7 + 12) = a5;
  *(_DWORD *)(v7 + 8) = 1;
  *(_DWORD *)(v7 + 16) = 256;
  *(_DWORD *)(v7 + 20) = 4;
  return v7;
}
// 10067B0C: using guessed type int (__stdcall *off_10067B0C[2])(char);

//----- (1001C8F0) --------------------------------------------------------
int __fastcall sub_1001C8F0(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // esi@1
  int v5; // ebx@2
  int v6; // eax@6
  int v7; // ecx@6
  int v8; // eax@9
  int result; // eax@11

  v4 = a1;
  v3 = *(_DWORD *)(a3 + 4);
  if ( v3 == 8 )
  {
    v5 = 9;
  }
  else
  {
    if ( v3 == 10 )
      v5 = 12;
    else
      v5 = 2 * (v3 != 11) + 12;
  }
  v6 = sub_1002ADB1(a2, a1, v5, a3, 24);
  v7 = v6;
  if ( v6 )
  {
    *(_DWORD *)(v6 + 4) = v5;
    *(_DWORD *)(v6 + 8) = 0;
    *(_DWORD *)(v6 + 12) = 0;
    *(_DWORD *)(v6 + 16) = 0;
    *(_DWORD *)v6 = off_10067B0C;
    *(_DWORD *)(v6 + 20) = a3;
  }
  else
  {
    v7 = 0;
  }
  *(_DWORD *)(v7 + 16) = *(_DWORD *)(v4 + 4);
  v8 = *(_DWORD *)(*(_DWORD *)(v4 + 4) + 12);
  if ( v8 )
  {
    *(_DWORD *)(v7 + 12) = v8;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v4 + 4) + 12) + 16) = v7;
  }
  result = *(_DWORD *)(v4 + 4);
  *(_DWORD *)(result + 12) = v7;
  *(_DWORD *)(v4 + 4) = v7;
  return result;
}
// 10067B0C: using guessed type int (__stdcall *off_10067B0C[2])(char);

//----- (1001C990) --------------------------------------------------------
int __userpurge sub_1001C990<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v5 = sub_1002ADB1(a1, a2, a3, a4, 24);
  if ( v5 )
  {
    *(_DWORD *)(v5 + 4) = 13;
    *(_DWORD *)(v5 + 8) = 0;
    *(_DWORD *)(v5 + 12) = 0;
    *(_DWORD *)(v5 + 16) = 0;
    *(_DWORD *)v5 = off_10067B0C;
    *(_DWORD *)(v5 + 20) = a5;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  result = v5;
  *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) = v5;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 10067B0C: using guessed type int (__stdcall *off_10067B0C[2])(char);

//----- (1001CA00) --------------------------------------------------------
int __usercall sub_1001CA00<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a4, 20);
  v5 = v4;
  if ( v4 )
  {
    *(_DWORD *)v4 = off_10067B0C;
    *(_DWORD *)(v4 + 4) = 21;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) = v5;
  result = *(_DWORD *)v6;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 10067B0C: using guessed type int (__stdcall *off_10067B0C[2])(char);

//----- (1001CA70) --------------------------------------------------------
char __thiscall sub_1001CA70(void *this, int a2)
{
  char v2; // al@1
  int v3; // ebx@1
  void *v4; // edi@1
  int v5; // eax@1
  int v6; // esi@1
  int v7; // eax@1
  int v8; // esi@2
  int v9; // ecx@3
  int v10; // eax@5
  int v11; // edi@5
  int *v12; // esi@10
  char v13; // bl@12
  void *v15; // [sp+10h] [bp-68h]@1
  int v16; // [sp+14h] [bp-64h]@1
  int v17; // [sp+18h] [bp-60h]@1
  signed int v18; // [sp+1Ch] [bp-5Ch]@1
  char v19; // [sp+23h] [bp-55h]@1
  int v20; // [sp+24h] [bp-54h]@1
  void *v21; // [sp+28h] [bp-50h]@1
  int v22; // [sp+2Ch] [bp-4Ch]@1
  int v23; // [sp+30h] [bp-48h]@1
  int v24; // [sp+34h] [bp-44h]@1
  void *v25; // [sp+38h] [bp-40h]@1
  int v26; // [sp+3Ch] [bp-3Ch]@1
  int v27; // [sp+40h] [bp-38h]@1
  int v28; // [sp+44h] [bp-34h]@1
  void *v29; // [sp+48h] [bp-30h]@1
  int v30; // [sp+4Ch] [bp-2Ch]@1
  int v31; // [sp+50h] [bp-28h]@1
  int v32; // [sp+54h] [bp-24h]@1
  void *v33; // [sp+58h] [bp-20h]@1
  int v34; // [sp+5Ch] [bp-1Ch]@1
  int v35; // [sp+60h] [bp-18h]@1
  unsigned int v36; // [sp+64h] [bp-14h]@1
  int v37; // [sp+74h] [bp-4h]@1
  int v38; // [sp+78h] [bp+0h]@1

  v36 = (unsigned int)&v38 ^ __security_cookie;
  v4 = this;
  v15 = this;
  v5 = *(_DWORD *)this;
  v3 = a2;
  v6 = (int)((char *)this + 4);
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v28 = v5;
  v16 = (int)((char *)this + 4);
  sub_1001C530((int)&v29, (int)((char *)this + 4));
  v32 = *(_DWORD *)(v6 + 12);
  v37 = 0;
  v17 = (int)((char *)v4 + 20);
  sub_1001D860((int)&v33, (int)((char *)v4 + 20));
  v37 = 1;
  v7 = *(_DWORD *)v4;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v20 = v7;
  sub_1001C530((int)&v21, v6);
  v24 = *(_DWORD *)(v6 + 12);
  LOBYTE(v37) = 2;
  sub_1001D860((int)&v25, (int)((char *)v4 + 20));
  v2 = 0;
  LOBYTE(v37) = 3;
  v19 = 0;
  v18 = -1;
  if ( a2 )
  {
    v8 = v28;
    do
    {
      v9 = v32;
      *(_DWORD *)v4 = v8;
      *((_DWORD *)v4 + 4) = v9;
      sub_1001ACB0((int)((char *)v4 + 4), (int)&v29);
      sub_1001A740((char *)v4 + 20, (int)&v33);
      if ( (unsigned __int8)loc_1001B950(v4, *(_DWORD *)(v3 + 12)) )
      {
        if ( !*((_BYTE *)v4 + 108) )
        {
          v13 = 1;
          goto LABEL_13;
        }
        v10 = *(_DWORD *)v4;
        v11 = *(_DWORD *)v4 - v8;
        if ( v18 < v11 )
        {
          v20 = v10;
          v24 = *(_DWORD *)(v16 + 12);
          sub_1001ACB0((int)&v21, v16);
          sub_1001A740(&v25, v17);
          v18 = v11;
        }
        v4 = v15;
        v2 = 1;
        v19 = 1;
      }
      else
      {
        v2 = v19;
      }
      v3 = *(_DWORD *)(v3 + 24);
    }
    while ( v3 );
  }
  v12 = &v20;
  if ( !v2 )
    v12 = &v28;
  *(_DWORD *)v4 = *v12;
  *((_DWORD *)v4 + 4) = v12[4];
  sub_1001ACB0((int)((char *)v4 + 4), (int)(v12 + 1));
  sub_1001A740((char *)v4 + 20, (int)(v12 + 5));
  v13 = v19;
LABEL_13:
  if ( v25 )
    sub_1002A4AA(v25);
  if ( v21 )
    sub_1002A4AA(v21);
  if ( v33 )
    sub_1002A4AA(v33);
  if ( v29 )
    sub_1002A4AA(v29);
  return v13;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (1001CC80) --------------------------------------------------------
char __thiscall sub_1001CC80(void *this, int a2, char a3, signed int a4)
{
  unsigned __int8 v4; // zf@1
  char v5; // sf@1
  char v6; // of@1
  void *v7; // ebx@1
  int i; // eax@2
  int v9; // ecx@2
  bool v10; // eax@6
  int v12; // eax@9
  int v13; // eax@9
  int v14; // ecx@9
  int v15; // esi@9
  int v16; // eax@9
  int v17; // ecx@9
  char v18; // al@11
  char v19; // sf@13
  int v20; // eax@21
  int v21; // ecx@21
  int v22; // eax@26
  int v23; // edx@29
  int v24; // eax@30
  int v25; // [sp-8h] [bp-60h]@17
  int v26; // [sp+10h] [bp-48h]@9
  void *v27; // [sp+14h] [bp-44h]@9
  int v28; // [sp+18h] [bp-40h]@9
  int v29; // [sp+1Ch] [bp-3Ch]@9
  int v30; // [sp+20h] [bp-38h]@9
  void *v31; // [sp+24h] [bp-34h]@9
  int v32; // [sp+28h] [bp-30h]@9
  int v33; // [sp+2Ch] [bp-2Ch]@9
  int v34; // [sp+30h] [bp-28h]@9
  int v35; // [sp+34h] [bp-24h]@9
  int v36; // [sp+38h] [bp-20h]@9
  char v37; // [sp+3Eh] [bp-1Ah]@13
  char v38; // [sp+3Fh] [bp-19h]@9
  int v39; // [sp+40h] [bp-18h]@9
  unsigned int v40; // [sp+44h] [bp-14h]@1
  int v41; // [sp+54h] [bp-4h]@9
  int v42; // [sp+58h] [bp+0h]@1

  v40 = (unsigned int)&v42 ^ __security_cookie;
  v7 = this;
  v6 = 0;
  v4 = *(_DWORD *)(a2 + 36) == 0;
  v5 = *(_DWORD *)(a2 + 36) < 0;
  if ( *(_DWORD *)(a2 + 36) < 0 )
  {
    v9 = *(_DWORD *)(a2 + 12);
    for ( i = *(_DWORD *)(v9 + 4); i != 19; i = *(_DWORD *)(v9 + 4) )
    {
      if ( i == 16 )
        break;
      if ( i == 18 )
        break;
      v9 = *(_DWORD *)(v9 + 12);
    }
    v10 = *(_DWORD *)(v9 + 4) == 19;
    *(_DWORD *)(a2 + 36) = v10;
    v6 = 0;
    v4 = v10 == 0;
    v5 = v10 < 0;
  }
  if ( !((unsigned __int8)(v5 ^ v6) | v4) )
    return sub_1001E0A0(v7, a2, a3);
  v13 = *(_DWORD *)v7;
  v38 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
  v26 = v13;
  sub_1001C530((int)&v27, (int)((char *)v7 + 4));
  v30 = *((_DWORD *)v7 + 4);
  v41 = 0;
  sub_1001D860((int)&v31, (int)((char *)v7 + 20));
  v41 = 1;
  v16 = *((_DWORD *)v7 + 16);
  v17 = *(_DWORD *)(a2 + 32);
  v15 = *(_DWORD *)(v16 + 8 * v17 + 4);
  v14 = v16 + 8 * v17;
  v36 = v14;
  v34 = *(_DWORD *)v14;
  v12 = *(_DWORD *)v7;
  v35 = v15;
  v39 = v12;
  v18 = !a4 || *(_DWORD *)v15 != v12;
  v19 = *(_DWORD *)(a2 + 24) < 0;
  v37 = v18;
  if ( v19 || *(_DWORD *)(a2 + 24) > a4 )
  {
    if ( a4 < *(_DWORD *)(a2 + 20) )
    {
      if ( v18 )
      {
        *(_DWORD *)v14 = a4 + 1;
        *(_DWORD *)(v14 + 4) = &v39;
        v25 = *(_DWORD *)(a2 + 12);
        goto LABEL_28;
      }
      goto LABEL_27;
    }
    if ( !a3 )
    {
      v38 = loc_1001B950(v7, *(_DWORD *)(*(_DWORD *)(a2 + 28) + 12));
      if ( v38 )
        goto LABEL_30;
      if ( v37 )
      {
        v20 = v30;
        *(_DWORD *)v7 = v26;
        *((_DWORD *)v7 + 4) = v20;
        sub_1001ACB0((int)((char *)v7 + 4), (int)&v27);
        sub_1001A740((char *)v7 + 20, (int)&v31);
        v21 = v36;
        *(_DWORD *)v36 = a4 + 1;
        *(_DWORD *)(v21 + 4) = &v39;
        v25 = *(_DWORD *)(a2 + 12);
        goto LABEL_28;
      }
LABEL_29:
      v23 = v30;
      *(_DWORD *)v7 = v26;
      *((_DWORD *)v7 + 4) = v23;
      sub_1001ACB0((int)((char *)v7 + 4), (int)&v27);
      sub_1001A740((char *)v7 + 20, (int)&v31);
      goto LABEL_30;
    }
    if ( v18 )
    {
      *(_DWORD *)v14 = a4 + 1;
      *(_DWORD *)(v14 + 4) = &v39;
      v38 = loc_1001B950(v7, *(_DWORD *)(a2 + 12));
      if ( v38 )
        goto LABEL_30;
      v14 = v36;
    }
    else
    {
      if ( a4 > 1 )
        goto LABEL_29;
    }
    *(_DWORD *)v14 = v34;
    *(_DWORD *)(v14 + 4) = v35;
    v22 = v30;
    *(_DWORD *)v7 = v26;
    *((_DWORD *)v7 + 4) = v22;
    sub_1001ACB0((int)((char *)v7 + 4), (int)&v27);
    sub_1001A740((char *)v7 + 20, (int)&v31);
  }
LABEL_27:
  v25 = *(_DWORD *)(*(_DWORD *)(a2 + 28) + 12);
LABEL_28:
  v38 = loc_1001B950(v7, v25);
  if ( !v38 )
    goto LABEL_29;
LABEL_30:
  v24 = v36;
  *(_DWORD *)v36 = v34;
  *(_DWORD *)(v24 + 4) = v35;
  if ( v31 )
    sub_1002A4AA(v31);
  if ( v27 )
    sub_1002A4AA(v27);
  return v38;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (1001CEF0) --------------------------------------------------------
char __thiscall sub_1001CEF0(int this, int a2)
{
  int v2; // ecx@1
  char v3; // bl@1
  int v4; // edi@1
  char v5; // zf@1
  int v6; // eax@1
  int v7; // esi@2
  int v8; // ecx@3
  int v9; // eax@3
  int v10; // eax@3
  int v11; // edx@3
  int v12; // eax@4
  char v13; // al@6
  int v14; // edx@7
  int v15; // esi@7
  int v16; // eax@8
  char v17; // cl@9
  char v18; // cl@13
  int v19; // eax@15
  int v20; // edx@15
  int v21; // edx@16
  unsigned int v22; // edx@21
  int v23; // ebx@23
  char v24; // zf@24
  int v25; // edx@25
  int i; // eax@26
  int v27; // ecx@26
  int v28; // eax@32
  int v29; // edx@36
  char result; // al@42
  unsigned int v31; // [sp-4h] [bp-3Ch]@1
  char v32; // [sp+10h] [bp-28h]@8
  int v33; // [sp+14h] [bp-24h]@15
  int v34; // [sp+18h] [bp-20h]@7
  int v35; // [sp+1Ch] [bp-1Ch]@3
  int v36; // [sp+20h] [bp-18h]@1
  int v37; // [sp+24h] [bp-14h]@1
  unsigned int v38; // [sp+28h] [bp-10h]@1
  int v39; // [sp+34h] [bp-4h]@3
  int v40; // [sp+38h] [bp+0h]@1

  v38 = (unsigned int)&v40 ^ __security_cookie;
  v31 = (unsigned int)&v40 ^ __security_cookie;
  v4 = this;
  v5 = (*(_DWORD *)(this + 92) & 0x100) == 0;
  v6 = *(_DWORD *)this;
  v2 = a2;
  v3 = *(_BYTE *)v6;
  v37 = a2;
  LOBYTE(v36) = v3;
  if ( !v5 )
  {
    v7 = *(_DWORD *)(v4 + 112);
    if ( !*(_DWORD *)(v7 + 4) )
    {
      v9 = sub_1001B150(v7, (int)&v35);
      v39 = 0;
      v10 = sub_10017B50(v11, v3, v4, v9);
      v39 = -1;
      v8 = v35;
      *(_DWORD *)(v7 + 4) = v10;
      if ( v8 )
      {
        v12 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v8 + 8))(v31);
        if ( v12 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v12)(v12, 1);
      }
    }
    v13 = (*(int (__stdcall **)(int))(**(_DWORD **)(v7 + 4) + 16))(v36);
    v2 = v37;
    v3 = v13;
    LOBYTE(v36) = v13;
  }
  v14 = *(_DWORD *)(v2 + 20);
  v15 = *(_DWORD *)v4 + 1;
  v34 = *(_DWORD *)v4 + 1;
  if ( v14 )
  {
    v16 = *(_DWORD *)sub_1001BF10((int)&v32, v14, *(_DWORD *)v4, *(_DWORD *)(v4 + 80));
    if ( v16 != *(_DWORD *)v4 )
    {
      v15 = v16;
      v17 = 1;
      goto LABEL_41;
    }
    v2 = v37;
  }
  if ( *(_DWORD *)(v2 + 32) )
  {
    if ( *(_DWORD *)(v4 + 92) & 0x800 )
      v18 = sub_1001A460(*(_DWORD *)(v4 + 112), v3, v4, v36);
    else
      v18 = v3;
    v20 = *(_DWORD *)(v37 + 32);
    v19 = 0;
    v33 = v20;
    if ( *(_DWORD *)(v20 + 4) > 0 )
    {
      v21 = *(_DWORD *)(v20 + 8);
      while ( *(_BYTE *)(v21 + v19) > v18 || v18 > *(_BYTE *)(v21 + v19 + 1) )
      {
        v19 += 2;
        v15 = v34;
        if ( v19 >= *(_DWORD *)(v33 + 4) )
          goto LABEL_20;
      }
      goto LABEL_39;
    }
LABEL_20:
    v2 = v37;
  }
  v22 = v3;
  if ( dword_100762B0 > v3 || v3 >= 256 )
  {
    v25 = *(_DWORD *)(v2 + 28);
    if ( v25 )
    {
      v27 = *(_DWORD *)(v25 + 8);
      for ( i = v27 + *(_DWORD *)(v25 + 4); v27 != i; ++v27 )
      {
        if ( *(_BYTE *)v27 == v3 )
          break;
      }
      if ( v27 != *(_DWORD *)(v25 + 4) + *(_DWORD *)(v25 + 8) )
      {
        v17 = 1;
        goto LABEL_41;
      }
      v2 = v37;
    }
    v28 = *(_WORD *)(v2 + 36);
    if ( (_WORD)v28 )
    {
      if ( sub_1001A530(*(_DWORD *)(v4 + 112), v3, v36, v28) )
      {
        v17 = 1;
        goto LABEL_41;
      }
      v2 = v37;
    }
    v29 = *(_DWORD *)(v2 + 40);
    if ( !v29 )
      goto LABEL_40;
    v24 = sub_1001BFA0(v3, v29, *(void **)(v4 + 112)) == 0;
  }
  else
  {
    v23 = *(_DWORD *)(v2 + 24);
    if ( !v23 )
      goto LABEL_40;
    v24 = ((unsigned __int8)(1 << (v22 & 7)) & *(_BYTE *)((v22 >> 3) + v23)) == 0;
  }
  if ( !v24 )
  {
LABEL_39:
    v17 = 1;
    goto LABEL_41;
  }
LABEL_40:
  v17 = 0;
LABEL_41:
  if ( v17 == (*(_BYTE *)(v37 + 8) & 1) )
  {
    result = 0;
  }
  else
  {
    *(_DWORD *)v4 = v15;
    result = 1;
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 100762B0: using guessed type int dword_100762B0;

//----- (1001D0F0) --------------------------------------------------------
char __thiscall sub_1001D0F0(int this)
{
  unsigned int v1; // eax@1
  int v2; // edx@2
  int v3; // edi@4
  int v4; // edi@7
  int v5; // edi@9
  int v6; // edx@12
  int v7; // esi@12

  v1 = 0;
  if ( *(_DWORD *)(this + 104) <= 0 )
    return 0;
  while ( 1 )
  {
    v2 = *(_DWORD *)(this + 36);
    if ( (signed int)v1 < 0 && v1 )
      v3 = v2 - (4 * ((-1 - v1) >> 5) + 4);
    else
      v3 = v2 + 4 * (v1 >> 5);
    if ( !((1 << (v1 & 0x1F)) & *(_DWORD *)v3)
      || ((v4 = *(_DWORD *)(this + 4), (signed int)v1 >= 0) || !v1 ? (v5 = v4 + 4 * (v1 >> 5)) : (v5 = v4 - (4 * ((-1 - v1) >> 5) + 4)),
          !((1 << (v1 & 0x1F)) & *(_DWORD *)v5)) )
      goto LABEL_14;
    v6 = *(_DWORD *)(this + 52) + 8 * v1;
    v7 = *(_DWORD *)(this + 20) + 8 * v1;
    if ( *(_DWORD *)v6 != *(_DWORD *)v7 )
      return *(_DWORD *)(*(_DWORD *)(this + 52) + 8 * v1) - *(_DWORD *)(this + 76) < *(_DWORD *)(*(_DWORD *)(this + 20)
                                                                                               + 8 * v1)
                                                                                   - *(_DWORD *)(this + 76);
    if ( *(_DWORD *)(v6 + 4) != *(_DWORD *)(v7 + 4) )
      return *(_DWORD *)(*(_DWORD *)(this + 52) + 8 * v1 + 4) - *(_DWORD *)(this + 76) < *(_DWORD *)(*(_DWORD *)(this + 20) + 8 * v1 + 4)
                                                                                       - *(_DWORD *)(this + 76);
LABEL_14:
    ++v1;
    if ( (signed int)v1 >= *(_DWORD *)(this + 104) )
      return 0;
  }
}

//----- (1001D220) --------------------------------------------------------
int __usercall sub_1001D220<eax>(char a1<dl>, int a2<ecx>, __int16 a3<bx>, int a4, int a5, int a6, int a7, __int16 a8, char a9)
{
  int v9; // esi@1
  int v10; // eax@2
  int v12; // [sp+8h] [bp-8h]@2
  unsigned int v13; // [sp+Ch] [bp-4h]@1
  int v14; // [sp+10h] [bp+0h]@1

  v13 = (unsigned int)&v14 ^ __security_cookie;
  v9 = a2;
  *(_DWORD *)a2 = a5;
  if ( a8 & 0x800 )
  {
    v10 = sub_1001E340(a9, (int)&v12, a3, a4, a5, a6, a7, a1);
  }
  else
  {
    if ( a8 & 0x100 )
    {
      v10 = sub_1001E540((int)&v12, a9, a4, (int *)a5, a6, a7, a1);
    }
    else
    {
      LOBYTE(v12) = 0;
      v10 = sub_1001E5F0((int)&v12, a9, a4, a5, a6, a7);
    }
  }
  *(_DWORD *)v9 = *(_DWORD *)v10;
  return v9;
}
// 10073200: using guessed type int __security_cookie;

//----- (1001D2B0) --------------------------------------------------------
int __fastcall sub_1001D2B0(int a1, int a2, int a3, int a4, int a5, int a6, char a7)
{
  int v7; // eax@1
  int v8; // ecx@1
  int v9; // ebx@1
  int v10; // edi@1
  int v11; // esi@1
  void **v12; // edi@3
  int v13; // ecx@4
  int v14; // eax@4
  int v15; // eax@4
  int v16; // edx@4
  int v17; // eax@5
  int *v18; // eax@8
  void **v19; // edi@14
  int v20; // ecx@15
  int v21; // eax@15
  int v22; // eax@15
  int v23; // edx@15
  int v24; // eax@16
  int *v25; // eax@19
  char v26; // zf@30
  int *v27; // eax@30
  int result; // eax@32
  unsigned int v29; // [sp-4h] [bp-74h]@1
  int v30; // [sp+10h] [bp-60h]@15
  int v31; // [sp+14h] [bp-5Ch]@4
  int v32; // [sp+18h] [bp-58h]@1
  int v33; // [sp+1Ch] [bp-54h]@1
  void *v34; // [sp+20h] [bp-50h]@18
  int v35; // [sp+30h] [bp-40h]@18
  unsigned int v36; // [sp+34h] [bp-3Ch]@19
  void *v37; // [sp+38h] [bp-38h]@7
  int v38; // [sp+48h] [bp-28h]@7
  unsigned int v39; // [sp+4Ch] [bp-24h]@8
  int v40; // [sp+50h] [bp-20h]@1
  char v41; // [sp+54h] [bp-1Ch]@3
  char v42; // [sp+55h] [bp-1Bh]@7
  char v43; // [sp+58h] [bp-18h]@14
  char v44; // [sp+59h] [bp-17h]@18
  unsigned int v45; // [sp+5Ch] [bp-14h]@1
  int v46; // [sp+6Ch] [bp-4h]@4
  int v47; // [sp+70h] [bp+0h]@1

  v45 = (unsigned int)&v47 ^ __security_cookie;
  v29 = (unsigned int)&v47 ^ __security_cookie;
  v32 = a2;
  v10 = a1;
  v33 = a1;
  v8 = a3;
  v7 = a4;
  v9 = a5;
  v11 = a3;
  v40 = a3;
  if ( a3 == a4 )
  {
LABEL_28:
    if ( a2 != v9 )
    {
      if ( !a7 || (v26 = v8 == v7, v27 = &a3, !v26) )
        v27 = &v40;
      goto LABEL_32;
    }
  }
  else
  {
    while ( a2 != v9 )
    {
      v12 = (void **)a6;
      LOBYTE(v9) = *(_BYTE *)a2;
      a3 = v8 + 1;
      v41 = *(_BYTE *)v8;
      if ( !*(_DWORD *)a6 )
      {
        v14 = sub_1001B150(a6, (int)&v31);
        v46 = 0;
        v15 = sub_1001C310(v16, v9, (int)v12, v14);
        v46 = -1;
        v13 = v31;
        *v12 = (void *)v15;
        if ( v13 )
        {
          v17 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v13 + 8))(v29);
          if ( v17 )
            (**(void (__thiscall ***)(_DWORD, _DWORD))v17)(v17, 1);
        }
      }
      sub_1001AEF0(*v12, (int)&v37, (int)&v41, (int)&v42);
      if ( v38 == 1 )
      {
        v18 = (int *)&v37;
        if ( v39 >= 0x10 )
          v18 = (int *)v37;
        BYTE1(v9) = *(_BYTE *)v18;
      }
      else
      {
        BYTE1(v9) = v41;
      }
      if ( v39 >= 0x10 )
        sub_1002A4AA(v37);
      v19 = (void **)a6;
      v39 = 15;
      v38 = 0;
      LOBYTE(v37) = 0;
      v43 = v9;
      if ( !*(_DWORD *)a6 )
      {
        v21 = sub_1001B150(a6, (int)&v30);
        v46 = 1;
        v22 = sub_1001C310(v23, v9, (int)v19, v21);
        v46 = -1;
        v20 = v30;
        *v19 = (void *)v22;
        if ( v20 )
        {
          v24 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v20 + 8))(v29);
          if ( v24 )
            (**(void (__thiscall ***)(_DWORD, _DWORD))v24)(v24, 1);
        }
      }
      sub_1001AEF0(*v19, (int)&v34, (int)&v43, (int)&v44);
      if ( v35 == 1 )
      {
        v25 = (int *)&v34;
        if ( v36 >= 0x10 )
          v25 = (int *)v34;
        LOBYTE(v9) = *(_BYTE *)v25;
      }
      else
      {
        LOBYTE(v9) = v43;
      }
      if ( v36 >= 0x10 )
        sub_1002A4AA(v34);
      a2 = v32 + 1;
      v36 = 15;
      v35 = 0;
      LOBYTE(v34) = 0;
      ++v32;
      if ( BYTE1(v9) != (_BYTE)v9 )
      {
        result = v33;
        *(_DWORD *)v33 = v11;
        return result;
      }
      v8 = a3;
      v7 = a4;
      v9 = a5;
      if ( a3 == a4 )
      {
        v10 = v33;
        goto LABEL_28;
      }
    }
    v10 = v33;
  }
  v27 = &a3;
LABEL_32:
  *(_DWORD *)v10 = *v27;
  return v10;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (1001D4B0) --------------------------------------------------------
int __fastcall sub_1001D4B0(int a1, int a2, int a3, int *a4, int a5, char a6, char a7)
{
  int *v7; // eax@1
  int v8; // edx@1
  int *v9; // ecx@1
  int v10; // ebx@1
  int v11; // edi@1
  int v12; // esi@1
  char v13; // zf@8
  int *v14; // eax@8
  int result; // eax@10
  int v16; // [sp+Ch] [bp-Ch]@1
  int v17; // [sp+10h] [bp-8h]@1
  unsigned int v18; // [sp+14h] [bp-4h]@1
  int v19; // [sp+18h] [bp+0h]@1

  v18 = (unsigned int)&v19 ^ __security_cookie;
  v7 = a4;
  v10 = a5;
  v11 = a2;
  v8 = a1;
  v9 = (int *)a3;
  v12 = a3;
  v16 = v8;
  v17 = a3;
  if ( (int *)a3 == a4 )
  {
LABEL_6:
    if ( v11 != v10 )
    {
      if ( !a7 || (v13 = v9 == v7, v14 = &a3, !v13) )
        v14 = &v17;
      goto LABEL_10;
    }
  }
  else
  {
    while ( v11 != v10 )
    {
      LOBYTE(v8) = *(_BYTE *)v11;
      a3 = (int)((char *)v9 + 1);
      ++v11;
      if ( !sub_1001D8D0((int)&a6, v10, *(_BYTE *)v9, v8) )
      {
        result = v16;
        *(_DWORD *)v16 = v12;
        return result;
      }
      v9 = (int *)a3;
      v7 = a4;
      if ( (int *)a3 == a4 )
      {
        v8 = v16;
        goto LABEL_6;
      }
    }
    v8 = v16;
  }
  v14 = &a3;
LABEL_10:
  *(_DWORD *)v8 = *v14;
  return v8;
}
// 10073200: using guessed type int __security_cookie;

//----- (1001D560) --------------------------------------------------------
int __fastcall sub_1001D560(int a1, int a2, int a3, int a4, int a5, int a6, char a7)
{
  int v7; // eax@1
  int v8; // edx@1
  int v9; // ecx@1
  int v10; // ebx@1
  int v11; // edi@1
  char v12; // dl@3
  int v13; // eax@3
  int *v14; // eax@8
  int result; // eax@10
  int v16; // [sp+Ch] [bp-Ch]@1
  int v17; // [sp+10h] [bp-8h]@1
  unsigned int v18; // [sp+14h] [bp-4h]@1
  int v19; // [sp+18h] [bp+0h]@1

  v18 = (unsigned int)&v19 ^ __security_cookie;
  v7 = a5;
  v10 = a2;
  v8 = a1;
  v9 = a3;
  v11 = a3;
  v16 = v8;
  v17 = a3;
  if ( a3 == a4 )
  {
LABEL_6:
    if ( v10 != v7 )
    {
      if ( !a7 || (v14 = &a3, v9 != a4) )
        v14 = &v17;
      goto LABEL_10;
    }
  }
  else
  {
    while ( v10 != v7 )
    {
      v12 = *(_BYTE *)v10;
      v13 = v9++;
      a3 = v9;
      ++v10;
      if ( *(_BYTE *)v13 != v12 )
      {
        result = v16;
        *(_DWORD *)v16 = v11;
        return result;
      }
      v7 = a5;
      if ( v9 == a4 )
      {
        v8 = v16;
        goto LABEL_6;
      }
    }
    v8 = v16;
  }
  v14 = &a3;
LABEL_10:
  *(_DWORD *)v8 = *v14;
  return v8;
}
// 10073200: using guessed type int __security_cookie;

//----- (1001D600) --------------------------------------------------------
int __thiscall sub_1001D600(void *this, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@2
  char v6; // zf@2
  int v7; // ecx@3
  int v8; // eax@3
  int v9; // eax@3
  int v10; // edx@3
  int v11; // eax@4
  int v12; // ecx@7
  int v13; // eax@7
  int v14; // eax@7
  int v15; // edx@7
  int v16; // eax@8
  int v17; // ebx@10
  void *v19; // [sp+10h] [bp-44h]@10
  unsigned int v20; // [sp+24h] [bp-30h]@14
  int v21; // [sp+28h] [bp-2Ch]@1
  int v22; // [sp+2Ch] [bp-28h]@1
  int v23; // [sp+30h] [bp-24h]@2
  int v24; // [sp+34h] [bp-20h]@2
  int v25; // [sp+38h] [bp-1Ch]@2
  int v26; // [sp+3Ch] [bp-18h]@2
  int v27; // [sp+40h] [bp-14h]@3
  int v28; // [sp+50h] [bp-4h]@1

  v4 = (int)this;
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  v21 = a2;
  *(_BYTE *)a2 = 0;
  v28 = 0;
  v22 = 1;
  if ( a3 != a4 )
  {
    v23 = 0;
    v24 = 0;
    v25 = 0;
    sub_1001EDA0((int)&v23, a3, a4);
    v28 = 1;
    v5 = v23;
    v6 = *(_DWORD *)(v4 + 4) == 0;
    v26 = v24 - v23;
    if ( v6 )
    {
      v8 = sub_1001B150(v4, (int)&v27);
      LOBYTE(v28) = 2;
      v9 = sub_10017B50(v10, v4, v5, v8);
      LOBYTE(v28) = 1;
      v7 = v27;
      *(_DWORD *)(v4 + 4) = v9;
      if ( v7 )
      {
        v11 = (*(int (**)(void))(*(_DWORD *)v7 + 8))();
        if ( v11 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v11)(v11, 1);
      }
    }
    (*(void (__stdcall **)(int, int))(**(_DWORD **)(v4 + 4) + 12))(v5, v5 + v26);
    if ( !*(_DWORD *)v4 )
    {
      v13 = sub_1001B150(v4, (int)&v27);
      LOBYTE(v28) = 3;
      v14 = sub_1001C310(v15, v4, v5, v13);
      LOBYTE(v28) = 1;
      v12 = v27;
      *(_DWORD *)v4 = v14;
      if ( v12 )
      {
        v16 = (*(int (**)(void))(*(_DWORD *)v12 + 8))();
        if ( v16 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v16)(v16, 1);
      }
    }
    v17 = sub_1001AEF0(*(void **)v4, (int)&v19, v5, v5 + v26);
    if ( a2 != v17 )
    {
      if ( *(_DWORD *)(a2 + 20) >= 0x10u )
        sub_1002A4AA(*(LPVOID *)a2);
      *(_DWORD *)(a2 + 20) = 15;
      *(_DWORD *)(a2 + 16) = 0;
      *(_BYTE *)a2 = 0;
      sub_100017B0((void *)a2, v17);
    }
    if ( v20 >= 0x10 )
      sub_1002A4AA(v19);
    if ( v5 )
      sub_1002A4AA((LPVOID)v5);
  }
  return a2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1001D7A0) --------------------------------------------------------
int __fastcall sub_1001D7A0(int a1, int a2, int a3)
{
  int result; // eax@1
  int i; // esi@1

  result = a3;
  for ( i = a1; i != a2; result += 8 )
  {
    if ( result )
    {
      *(_DWORD *)result = *(_DWORD *)i;
      *(_DWORD *)(result + 4) = *(_DWORD *)(i + 4);
    }
    i += 8;
  }
  return result;
}

//----- (1001D7D0) --------------------------------------------------------
void __fastcall sub_1001D7D0(int a1, int a2)
{
  for ( ; a2; --a2 )
  {
    if ( a1 )
    {
      *(_DWORD *)a1 = 0;
      *(_DWORD *)(a1 + 4) = 0;
    }
    a1 += 8;
  }
}

//----- (1001D7F0) --------------------------------------------------------
signed int __usercall sub_1001D7F0<eax>(signed int result<eax>, int a2<ecx>, int a3, unsigned int a4, int a5, int a6)
{
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // esi@1

  v6 = a3;
  v8 = a2;
  v7 = a4;
  while ( v6 != a5 || v7 != a6 )
  {
    result = 1 << v7;
    if ( *(_BYTE *)v8 )
    {
      *(_DWORD *)v6 |= result;
    }
    else
    {
      result = ~result;
      *(_DWORD *)v6 &= result;
    }
    v6 = a3;
    if ( a4 >= 0x1F )
    {
      v7 = 0;
      v6 = a3 + 4;
      a4 = 0;
      a3 += 4;
    }
    else
    {
      v7 = a4++ + 1;
    }
  }
  return result;
}

//----- (1001D840) --------------------------------------------------------
void __fastcall sub_1001D840(int a1, int a2)
{
  for ( ; a2; --a2 )
  {
    if ( a1 )
    {
      *(_DWORD *)a1 = 0;
      *(_DWORD *)(a1 + 4) = 0;
      *(_BYTE *)(a1 + 8) = 0;
    }
    a1 += 12;
  }
}

//----- (1001D860) --------------------------------------------------------
int __thiscall sub_1001D860(int this, int a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  if ( (unsigned __int8)loc_1001AE80((*(_DWORD *)(a2 + 4) - *(_DWORD *)a2) >> 3) )
    *(_DWORD *)(v2 + 4) = sub_1001F560(*(void **)v2, *(_DWORD *)a2, *(_DWORD *)(a2 + 4));
  return v2;
}

//----- (1001D8D0) --------------------------------------------------------
char __userpurge sub_1001D8D0<al>(int a1<ecx>, char a2<bl>, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ecx@2
  int v7; // eax@2
  int v8; // eax@2
  int v9; // edx@2
  int v10; // eax@3
  char v11; // bl@5
  int v12; // esi@5
  char v13; // al@5
  int v14; // ecx@6
  int v15; // eax@6
  int v16; // eax@6
  int v17; // edx@6
  int v18; // eax@7
  int v20; // [sp+10h] [bp-10h]@2
  int v21; // [sp+1Ch] [bp-4h]@2

  v4 = a1;
  v5 = *(_DWORD *)a1;
  if ( !*(_DWORD *)(*(_DWORD *)a1 + 4) )
  {
    v7 = sub_1001B150(v5, (int)&v20);
    v21 = 0;
    v8 = sub_10017B50(v9, a2, v4, v7);
    v21 = -1;
    v6 = v20;
    *(_DWORD *)(v5 + 4) = v8;
    if ( v6 )
    {
      v10 = (*(int (**)(void))(*(_DWORD *)v6 + 8))();
      if ( v10 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v10)(v10, 1);
    }
  }
  v13 = (*(int (__stdcall **)(int))(**(_DWORD **)(v5 + 4) + 16))(a3);
  v12 = *(_DWORD *)v4;
  v11 = v13;
  if ( !*(_DWORD *)(*(_DWORD *)v4 + 4) )
  {
    v15 = sub_1001B150(v12, (int)&a3);
    v21 = 1;
    v16 = sub_10017B50(v17, v11, v4, v15);
    v21 = -1;
    v14 = a3;
    *(_DWORD *)(v12 + 4) = v16;
    if ( v14 )
    {
      v18 = (*(int (**)(void))(*(_DWORD *)v14 + 8))();
      if ( v18 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v18)(v18, 1);
    }
  }
  return v11 == (unsigned __int8)(*(int (__cdecl **)(int))(**(_DWORD **)(v12 + 4) + 16))(a4);
}

//----- (1001D9C0) --------------------------------------------------------
char __thiscall sub_1001D9C0(int this)
{
  int v1; // eax@1
  int v2; // ecx@2
  char v3; // al@6

  v1 = *(_DWORD *)this + 1;
  return v1 != *(_DWORD *)(this + 8)
      && ((v2 = *(_DWORD *)(this + 80), !(v2 & 8)) && (*(_BYTE *)v1 == 40 || *(_BYTE *)v1 == 41)
       || !(v2 & 0x10) && ((v3 = *(_BYTE *)v1, v3 == 123) || v3 == 125));
}

//----- (1001DA00) --------------------------------------------------------
char __thiscall sub_1001DA00(void *this)
{
  int v1; // eax@1
  int v2; // edx@1
  int v3; // eax@3
  int v4; // edx@4

  v1 = *(_DWORD *)this;
  v2 = *((_DWORD *)this + 2);
  if ( *(_DWORD *)this != v2 )
  {
    if ( *(_BYTE *)v1 == 92 )
    {
      v3 = v1 + 1;
      if ( v3 != v2 )
      {
        v4 = *((_DWORD *)this + 20);
        if ( !(v4 & 8) && (*(_BYTE *)v3 == 40 || *(_BYTE *)v3 == 41)
          || !(v4 & 0x10) && (*(_BYTE *)v3 == 123 || *(_BYTE *)v3 == 125) )
          *(_DWORD *)this = v3;
      }
    }
    ++*(_DWORD *)this;
  }
  return sub_1001C5A0(this);
}

//----- (1001DE90) --------------------------------------------------------
char __thiscall sub_1001DE90(int this)
{
  int v1; // eax@1
  int v2; // ecx@1
  int v3; // eax@5

  v2 = *(_DWORD *)(this + 4);
  v1 = *(_DWORD *)(v2 + 4);
  return v1 == 20
      || v1 == 8
      || v1 == 13
      || v1 == 2 && ((v3 = *(_DWORD *)(*(_DWORD *)(v2 + 16) + 4), v3 == 20) || v3 == 8 || v3 == 13);
}

//----- (1001DED0) --------------------------------------------------------
int __usercall sub_1001DED0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a4, 20);
  v5 = v4;
  if ( v4 )
  {
    *(_DWORD *)v4 = off_10067B0C;
    *(_DWORD *)(v4 + 4) = 8;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  result = v5;
  *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) = v5;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 10067B0C: using guessed type int (__stdcall *off_10067B0C[2])(char);

//----- (1001DF40) --------------------------------------------------------
int __userpurge sub_1001DF40<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // eax@4
  int v10; // eax@6
  int v12; // edx@9

  v7 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a2, 20);
  v8 = v4;
  if ( v4 )
  {
    *(_DWORD *)(v4 + 4) = 17;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    *(_DWORD *)v4 = off_10067B0C;
  }
  else
  {
    v8 = 0;
  }
  *(_DWORD *)(v8 + 16) = *(_DWORD *)(v7 + 4);
  v9 = *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12);
  if ( v9 )
  {
    *(_DWORD *)(v8 + 12) = v9;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) + 16) = v8;
  }
  *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) = v8;
  *(_DWORD *)(v7 + 4) = v8;
  v10 = sub_1002ADB1(v5, v6, a3, v7, 28);
  if ( v10 )
  {
    *(_DWORD *)(v10 + 4) = 16;
    *(_DWORD *)(v10 + 8) = 0;
    *(_DWORD *)(v10 + 12) = 0;
    *(_DWORD *)(v10 + 16) = 0;
    *(_DWORD *)v10 = off_10067B08;
    *(_DWORD *)(v10 + 20) = v8;
    *(_DWORD *)(v10 + 24) = 0;
  }
  else
  {
    v10 = 0;
  }
  v12 = *(_DWORD *)(a4 + 12);
  *(_DWORD *)(v10 + 16) = *(_DWORD *)(v12 + 16);
  *(_DWORD *)(*(_DWORD *)(v12 + 16) + 12) = v10;
  *(_DWORD *)(v10 + 12) = v12;
  *(_DWORD *)(v12 + 16) = v10;
  return v8;
}
// 10067B08: using guessed type int (__stdcall *off_10067B08[3])(char);
// 10067B0C: using guessed type int (__stdcall *off_10067B0C[2])(char);

//----- (1001E000) --------------------------------------------------------
int __fastcall sub_1001E000(int a1, int a2, int a3, int a4)
{
  int v4; // eax@1
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@1
  char v8; // zf@2
  int v9; // eax@3
  int result; // eax@4

  v6 = *(_DWORD *)(a3 + 12);
  v5 = *(_DWORD *)(a4 + 12);
  *(_DWORD *)(a4 + 12) = 0;
  v7 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 4) = a4;
  *(_DWORD *)(a4 + 12) = 0;
  *(_DWORD *)(v7 + 12) = a4;
  v4 = v6 + 24;
  if ( *(_DWORD *)(v6 + 24) )
  {
    do
    {
      v6 = *(_DWORD *)v4;
      v8 = *(_DWORD *)(*(_DWORD *)v4 + 24) == 0;
      v4 = *(_DWORD *)v4 + 24;
    }
    while ( !v8 );
  }
  v9 = sub_1002ADB1(a2, a1, v5, a4, 28);
  if ( v9 )
  {
    *(_DWORD *)(v9 + 20) = a4;
    *(_DWORD *)(v9 + 4) = 16;
    *(_DWORD *)(v9 + 8) = 0;
    *(_DWORD *)(v9 + 12) = 0;
    *(_DWORD *)(v9 + 16) = 0;
    *(_DWORD *)v9 = off_10067B08;
    *(_DWORD *)(v9 + 24) = 0;
    *(_DWORD *)(v6 + 24) = v9;
    *(_DWORD *)(v9 + 12) = v5;
    result = *(_DWORD *)(v6 + 24);
    *(_DWORD *)(v5 + 16) = result;
  }
  else
  {
    *(_DWORD *)(v6 + 24) = 0;
    vc = v5;
    result = *(_DWORD *)(v6 + 24);
    *(_DWORD *)(v5 + 16) = result;
  }
  return result;
}
// 10067B08: using guessed type int (__stdcall *off_10067B08[3])(char);

//----- (1001E0A0) --------------------------------------------------------
char __thiscall sub_1001E0A0(void *this, int a2, char a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  void *v5; // esi@1
  int v6; // esi@2
  int v7; // eax@6
  int v8; // edi@6
  int v9; // ecx@9
  int v10; // eax@10
  int v11; // ecx@11
  int v12; // esi@12
  char v13; // bl@17
  int *v14; // esi@19
  int v16; // [sp+10h] [bp-64h]@1
  int v17; // [sp+14h] [bp-60h]@1
  void *v18; // [sp+1Ch] [bp-58h]@1
  char v19; // [sp+23h] [bp-51h]@6
  int v20; // [sp+24h] [bp-50h]@1
  void *v21; // [sp+28h] [bp-4Ch]@1
  int v22; // [sp+2Ch] [bp-48h]@1
  int v23; // [sp+30h] [bp-44h]@1
  int v24; // [sp+34h] [bp-40h]@1
  void *v25; // [sp+38h] [bp-3Ch]@1
  int v26; // [sp+3Ch] [bp-38h]@1
  int v27; // [sp+40h] [bp-34h]@1
  int v28; // [sp+44h] [bp-30h]@6
  void *v29; // [sp+48h] [bp-2Ch]@6
  int v30; // [sp+4Ch] [bp-28h]@6
  int v31; // [sp+50h] [bp-24h]@6
  int v32; // [sp+54h] [bp-20h]@6
  void *v33; // [sp+58h] [bp-1Ch]@6
  int v34; // [sp+5Ch] [bp-18h]@6
  int v35; // [sp+60h] [bp-14h]@6
  unsigned int v36; // [sp+64h] [bp-10h]@1
  int v37; // [sp+70h] [bp-4h]@1
  int v38; // [sp+74h] [bp+0h]@1

  v36 = (unsigned int)&v38 ^ __security_cookie;
  v5 = this;
  v18 = this;
  v4 = a2;
  v3 = 0;
  v20 = *(_DWORD *)this;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v17 = (int)((char *)this + 4);
  sub_1001C530((int)&v21, (int)((char *)this + 4));
  v24 = *((_DWORD *)v5 + 4);
  v37 = 0;
  v16 = (int)((char *)v5 + 20);
  sub_1001D860((int)&v25, (int)((char *)v5 + 20));
  v37 = 1;
  if ( *(_DWORD *)(a2 + 20) <= 0 )
  {
LABEL_6:
    v7 = *(_DWORD *)v5;
    v29 = 0;
    v30 = 0;
    v31 = 0;
    v33 = 0;
    v34 = 0;
    v35 = 0;
    v28 = v7;
    sub_1001C530((int)&v29, (int)((char *)v5 + 4));
    v32 = *((_DWORD *)v5 + 4);
    LOBYTE(v37) = 2;
    sub_1001D860((int)&v33, (int)((char *)v5 + 20));
    v19 = 0;
    LOBYTE(v37) = 3;
    v8 = *(_DWORD *)v5;
    if ( !(unsigned __int8)loc_1001B950(v5, *(_DWORD *)(*(_DWORD *)(a2 + 28) + 12)) )
      goto LABEL_9;
    if ( a3 )
    {
      v28 = *(_DWORD *)v5;
      v32 = *((_DWORD *)v5 + 4);
      sub_1001ACB0((int)&v29, (int)((char *)v5 + 4));
      sub_1001A740(&v33, (int)((char *)v5 + 20));
      v19 = 1;
LABEL_9:
      while ( 1 )
      {
        v9 = *(_DWORD *)(a2 + 24);
        if ( v9 != -1 )
        {
          v10 = v3++;
          if ( v10 >= v9 )
            break;
        }
        v11 = v24;
        *(_DWORD *)v5 = v8;
        *((_DWORD *)v5 + 4) = v11;
        sub_1001ACB0((int)((char *)v5 + 4), (int)&v21);
        if ( !(unsigned __int8)loc_1001B950(v5, *(_DWORD *)(a2 + 12)) )
          break;
        v12 = *(_DWORD *)v5;
        if ( (unsigned __int8)loc_1001B950(v18, *(_DWORD *)(*(_DWORD *)(a2 + 28) + 12)) )
        {
          if ( !a3 )
            goto LABEL_18;
          v28 = *(_DWORD *)v18;
          v32 = *(_DWORD *)(v17 + 12);
          sub_1001ACB0((int)&v29, v17);
          sub_1001A740(&v33, v16);
          v19 = 1;
        }
        if ( v8 == v12 )
          break;
        v8 = v12;
        v5 = v18;
      }
      v13 = v19;
      v14 = &v28;
      if ( !v19 )
        v14 = &v20;
      *(_DWORD *)v18 = *v14;
      *(_DWORD *)(v17 + 12) = v14[4];
      sub_1001ACB0(v17, (int)(v14 + 1));
      sub_1001A740((void *)v16, (int)(v14 + 5));
    }
    else
    {
LABEL_18:
      v13 = 1;
    }
    if ( v33 )
      sub_1002A4AA(v33);
    if ( v29 )
      sub_1002A4AA(v29);
  }
  else
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)v5;
      if ( !(unsigned __int8)loc_1001B950(v18, *(_DWORD *)(v4 + 12)) )
        break;
      v4 = a2;
      if ( v6 == *(_DWORD *)v18 )
        v3 = *(_DWORD *)(a2 + 20) - 1;
      v5 = v18;
      ++v3;
      if ( v3 >= *(_DWORD *)(a2 + 20) )
        goto LABEL_6;
    }
    *(_DWORD *)v18 = v20;
    *((_DWORD *)v18 + 4) = v24;
    sub_1001ACB0((int)((char *)v18 + 4), (int)&v21);
    sub_1001A740((char *)v18 + 20, (int)&v25);
    v13 = 0;
  }
  if ( v25 )
    sub_1002A4AA(v25);
  if ( v21 )
    sub_1002A4AA(v21);
  return v13;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (1001E340) --------------------------------------------------------
int __usercall sub_1001E340<eax>(char a1<dl>, int a2<ecx>, __int16 a3<bx>, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // eax@1
  int v9; // edx@1
  char v10; // bl@1
  int v11; // edi@1
  int v12; // esi@1
  int v13; // ecx@3
  void **v14; // esi@3
  char v15; // al@3
  int v16; // ecx@4
  int v17; // eax@4
  int v18; // eax@4
  int v19; // edx@4
  int v20; // eax@5
  int *v21; // eax@8
  void **v22; // esi@14
  int v23; // ecx@15
  int v24; // eax@15
  int v25; // eax@15
  int v26; // edx@15
  int v27; // eax@16
  int *v28; // eax@19
  char v29; // zf@30
  int *v30; // eax@30
  int result; // eax@32
  unsigned int v32; // [sp-4h] [bp-74h]@1
  int v33; // [sp+10h] [bp-60h]@15
  int v34; // [sp+14h] [bp-5Ch]@4
  int v35; // [sp+18h] [bp-58h]@1
  char v36; // [sp+1Fh] [bp-51h]@1
  void *v37; // [sp+20h] [bp-50h]@18
  int v38; // [sp+30h] [bp-40h]@18
  unsigned int v39; // [sp+34h] [bp-3Ch]@19
  void *v40; // [sp+38h] [bp-38h]@7
  int v41; // [sp+48h] [bp-28h]@7
  unsigned int v42; // [sp+4Ch] [bp-24h]@8
  int v43; // [sp+50h] [bp-20h]@1
  char v44; // [sp+54h] [bp-1Ch]@3
  char v45; // [sp+55h] [bp-1Bh]@7
  char v46; // [sp+58h] [bp-18h]@14
  char v47; // [sp+59h] [bp-17h]@18
  unsigned int v48; // [sp+5Ch] [bp-14h]@1
  int v49; // [sp+6Ch] [bp-4h]@4
  int v50; // [sp+70h] [bp+0h]@1

  v48 = (unsigned int)&v50 ^ __security_cookie;
  v32 = (unsigned int)&v50 ^ __security_cookie;
  v10 = a1;
  v36 = a1;
  v9 = a2;
  v35 = a2;
  v12 = a4;
  v8 = a5;
  v11 = a4;
  v43 = a4;
  if ( a4 == a5 )
  {
LABEL_28:
    if ( a6 != a7 )
    {
      if ( !v10 || (v29 = v12 == v8, v30 = &a4, !v29) )
        v30 = &v43;
      goto LABEL_32;
    }
  }
  else
  {
    while ( a6 != a7 )
    {
      v13 = a6++;
      a4 = v12 + 1;
      v15 = *(_BYTE *)v12;
      v14 = (void **)a8;
      LOBYTE(a3) = *(_BYTE *)v13;
      v44 = v15;
      if ( !*(_DWORD *)a8 )
      {
        v17 = sub_1001B150(a8, (int)&v34);
        v49 = 0;
        v18 = sub_1001C310(v19, a3, v11, v17);
        v49 = -1;
        v16 = v34;
        *v14 = (void *)v18;
        if ( v16 )
        {
          v20 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v16 + 8))(v32);
          if ( v20 )
            (**(void (__thiscall ***)(_DWORD, _DWORD))v20)(v20, 1);
        }
      }
      sub_1001AEF0(*v14, (int)&v40, (int)&v44, (int)&v45);
      if ( v41 == 1 )
      {
        v21 = (int *)&v40;
        if ( v42 >= 0x10 )
          v21 = (int *)v40;
        HIBYTE(a3) = *(_BYTE *)v21;
      }
      else
      {
        HIBYTE(a3) = v44;
      }
      if ( v42 >= 0x10 )
        sub_1002A4AA(v40);
      v22 = (void **)a8;
      v42 = 15;
      v41 = 0;
      LOBYTE(v40) = 0;
      v46 = a3;
      if ( !*(_DWORD *)a8 )
      {
        v24 = sub_1001B150(a8, (int)&v33);
        v49 = 1;
        v25 = sub_1001C310(v26, a3, v11, v24);
        v49 = -1;
        v23 = v33;
        *v22 = (void *)v25;
        if ( v23 )
        {
          v27 = (*(int (__cdecl **)(unsigned int))(*(_DWORD *)v23 + 8))(v32);
          if ( v27 )
            (**(void (__thiscall ***)(_DWORD, _DWORD))v27)(v27, 1);
        }
      }
      sub_1001AEF0(*v22, (int)&v37, (int)&v46, (int)&v47);
      if ( v38 == 1 )
      {
        v28 = (int *)&v37;
        if ( v39 >= 0x10 )
          v28 = (int *)v37;
        LOBYTE(a3) = *(_BYTE *)v28;
      }
      else
      {
        LOBYTE(a3) = v46;
      }
      if ( v39 >= 0x10 )
        sub_1002A4AA(v37);
      v39 = 15;
      v38 = 0;
      LOBYTE(v37) = 0;
      if ( HIBYTE(a3) != (_BYTE)a3 )
      {
        result = v35;
        *(_DWORD *)v35 = v11;
        return result;
      }
      v12 = a4;
      v8 = a5;
      if ( a4 == a5 )
      {
        v9 = v35;
        v10 = v36;
        goto LABEL_28;
      }
    }
    v9 = v35;
  }
  v30 = &a4;
LABEL_32:
  *(_DWORD *)v9 = *v30;
  return v9;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (1001E540) --------------------------------------------------------
int __fastcall sub_1001E540(int a1, char a2, int a3, int *a4, int a5, int a6, char a7)
{
  int *v7; // eax@1
  int v8; // ebx@1
  int v9; // edi@1
  int *v10; // esi@1
  int *v11; // ecx@3
  int *v12; // eax@7
  char v14; // zf@10
  char v15; // [sp+Fh] [bp-9h]@1
  int v16; // [sp+10h] [bp-8h]@1
  unsigned int v17; // [sp+14h] [bp-4h]@1
  int v18; // [sp+18h] [bp+0h]@1

  v17 = (unsigned int)&v18 ^ __security_cookie;
  v7 = a4;
  v10 = (int *)a3;
  v9 = a3;
  v15 = a2;
  v8 = a1;
  v16 = a3;
  if ( (int *)a3 == a4 )
  {
LABEL_6:
    if ( a5 != a6 )
    {
      if ( !a2 || (v14 = v10 == v7, v12 = &a3, !v14) )
        v12 = &v16;
      goto LABEL_12;
    }
  }
  else
  {
    while ( a5 != a6 )
    {
      v11 = (int *)a5++;
      a3 = (int)((char *)v10 + 1);
      if ( !sub_1001D8D0((int)&a7, v8, *(_BYTE *)v10, *(_BYTE *)v11) )
      {
        *(_DWORD *)v8 = v9;
        return v8;
      }
      v10 = (int *)a3;
      v7 = a4;
      if ( (int *)a3 == a4 )
      {
        a2 = v15;
        goto LABEL_6;
      }
    }
  }
  v12 = &a3;
LABEL_12:
  *(_DWORD *)v8 = *v12;
  return v8;
}
// 10073200: using guessed type int __security_cookie;

//----- (1001E5F0) --------------------------------------------------------
int __fastcall sub_1001E5F0(int a1, char a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int v7; // edx@1
  int v8; // ebx@1
  int v9; // esi@1
  int v10; // ecx@3
  int v11; // eax@3
  int *v12; // eax@6
  char v14; // [sp+Fh] [bp-9h]@1
  int v15; // [sp+10h] [bp-8h]@1
  unsigned int v16; // [sp+14h] [bp-4h]@1
  int v17; // [sp+18h] [bp+0h]@1

  v16 = (unsigned int)&v17 ^ __security_cookie;
  v6 = a6;
  v9 = a3;
  v14 = a2;
  v7 = a5;
  v8 = a1;
  v15 = a3;
  if ( a3 == a4 )
  {
LABEL_5:
    if ( v7 != v6 )
    {
      if ( !v14 || (v12 = &a3, v9 != a4) )
        v12 = &v15;
      goto LABEL_11;
    }
  }
  else
  {
    while ( v7 != v6 )
    {
      v10 = v7;
      v11 = v9;
      ++v7;
      ++v9;
      a5 = v7;
      a3 = v9;
      if ( *(_BYTE *)v11 != *(_BYTE *)v10 )
      {
        *(_DWORD *)v8 = v15;
        return v8;
      }
      v6 = a6;
      if ( v9 == a4 )
        goto LABEL_5;
    }
  }
  v12 = &a3;
LABEL_11:
  *(_DWORD *)v8 = *v12;
  return v8;
}
// 10073200: using guessed type int __security_cookie;

//----- (1001E690) --------------------------------------------------------
void *__thiscall sub_1001E690(void *this, int a2, int a3, unsigned int a4, int a5, int a6, int a7, unsigned int a8)
{
  int v8; // edx@1
  int v9; // ecx@1
  void *v10; // ebx@1
  int v11; // edi@1
  int v12; // esi@1

  v8 = a8;
  v12 = a7;
  v11 = a3;
  v10 = this;
  v9 = a4;
  while ( v11 != a5 || v9 != a6 )
  {
    if ( (1 << v9) & *(_DWORD *)v11 )
      *(_DWORD *)v12 |= 1 << v8;
    else
      *(_DWORD *)v12 &= ~(1 << v8);
    v12 = a7;
    if ( a8 >= 0x1F )
    {
      v8 = 0;
      v12 = a7 + 4;
      a7 += 4;
    }
    else
    {
      v8 = a8 + 1;
    }
    v11 = a3;
    a8 = v8;
    if ( a4 >= 0x1F )
    {
      v9 = 0;
      v11 = a3 + 4;
      a4 = 0;
      a3 += 4;
    }
    else
    {
      v9 = a4++ + 1;
    }
  }
  *(_DWORD *)v10 = v12;
  *((_DWORD *)v10 + 1) = v8;
  return v10;
}

//----- (1001E710) --------------------------------------------------------
void *__thiscall sub_1001E710(void *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  void *v8; // ebx@1
  int v9; // edi@2
  int v10; // ecx@5
  int v11; // esi@7
  int v12; // edx@8

  v8 = this;
  while ( 1 )
  {
    v9 = a5;
    if ( a3 == a5 )
    {
      if ( a4 == a6 )
        break;
    }
    if ( a6 )
    {
      v10 = a6 - 1;
    }
    else
    {
      v9 = a5 - 4;
      v10 = 31;
      a5 -= 4;
    }
    v11 = a7;
    a6 = v10;
    if ( a8 )
    {
      v12 = a8 - 1;
    }
    else
    {
      v11 = a7 - 4;
      v12 = 31;
      a7 -= 4;
    }
    a8 = v12;
    if ( (1 << v10) & *(_DWORD *)v9 )
      *(_DWORD *)v11 |= 1 << v12;
    else
      *(_DWORD *)v11 &= ~(1 << v12);
  }
  *(_DWORD *)v8 = a7;
  *((_DWORD *)v8 + 1) = a8;
  return v8;
}

//----- (1001E800) --------------------------------------------------------
int __usercall sub_1001E800<eax>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>)
{
  int v4; // edx@1
  int v5; // esi@1
  int v6; // eax@2
  int v7; // ecx@2
  int v8; // eax@4
  int v9; // ecx@5
  int v10; // ecx@16

  v5 = a2;
  sub_1001F2A0(a1, a2 + 36, a3, a4);
  if ( *(_DWORD *)(v5 + 76) == 94 )
  {
    *(_DWORD *)(*(_DWORD *)(v5 + 40) + 8) ^= 1u;
    v6 = *(_DWORD *)v5;
    v7 = *(_DWORD *)(v5 + 8);
    if ( *(_DWORD *)v5 != v7 )
    {
      if ( *(_BYTE *)v6 == 92 )
      {
        v8 = v6 + 1;
        if ( v8 != v7 )
        {
          v9 = *(_DWORD *)(v5 + 80);
          if ( !(v9 & 8) && (*(_BYTE *)v8 == 40 || *(_BYTE *)v8 == 41)
            || !(v9 & 0x10) && (*(_BYTE *)v8 == 123 || *(_BYTE *)v8 == 125) )
            *(_DWORD *)v5 = v8;
        }
      }
      ++*(_DWORD *)v5;
    }
    sub_1001C5A0((void *)v5);
  }
  if ( *(_DWORD *)(v5 + 80) & 0x20000000 && *(_DWORD *)(v5 + 76) == 93 )
  {
    v10 = v5 + 36;
    if ( dword_100762AC <= 93 )
    {
      sub_1001FDE0(v4, v10, a3, a4, 93);
      sub_1001DA00((void *)v5);
      return loc_1001EF00(v5);
    }
    sub_1001FED0(v4, v10, a3, a4, 93);
    sub_1001DA00((void *)v5);
  }
  return loc_1001EF00(v5);
}
// 100762AC: using guessed type int dword_100762AC;

//----- (1001EB70) --------------------------------------------------------
int __usercall sub_1001EB70<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a4, 20);
  v5 = v4;
  if ( v4 )
  {
    *(_DWORD *)v4 = off_10067B0C;
    *(_DWORD *)(v4 + 4) = 2;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  result = *(_DWORD *)(v6 + 4);
  *(_DWORD *)(result + 12) = v5;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 10067B0C: using guessed type int (__stdcall *off_10067B0C[2])(char);

//----- (1001EBD0) --------------------------------------------------------
int __usercall sub_1001EBD0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a4, 20);
  v5 = v4;
  if ( v4 )
  {
    *(_DWORD *)v4 = off_10067B0C;
    *(_DWORD *)(v4 + 4) = 3;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  result = *(_DWORD *)(v6 + 4);
  *(_DWORD *)(result + 12) = v5;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 10067B0C: using guessed type int (__stdcall *off_10067B0C[2])(char);

//----- (1001EC30) --------------------------------------------------------
int __usercall sub_1001EC30<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a4, 20);
  v5 = v4;
  if ( v4 )
  {
    *(_DWORD *)v4 = off_10067B0C;
    *(_DWORD *)(v4 + 4) = 4;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  result = *(_DWORD *)(v6 + 4);
  *(_DWORD *)(result + 12) = v5;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 10067B0C: using guessed type int (__stdcall *off_10067B0C[2])(char);

//----- (1001EC90) --------------------------------------------------------
int __userpurge sub_1001EC90<eax>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>, int a5)
{
  int v5; // eax@1
  int v6; // esi@1
  int v7; // eax@4
  int v8; // edi@5
  int v9; // ecx@6
  int v10; // eax@6
  int v11; // eax@6
  int v12; // edx@6
  int v13; // eax@7
  char v14; // bl@9
  unsigned int v15; // eax@13
  int v16; // esi@13
  int v17; // eax@14
  int v18; // edi@14
  int result; // eax@17
  int v20; // [sp+14h] [bp-10h]@6
  int v21; // [sp+20h] [bp-4h]@6

  v6 = a2;
  v5 = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(v5 + 4) != 6 || *(_BYTE *)(v5 + 8) & 4 )
    sub_1001F4E0(a1, a2, a3, a4);
  v7 = *(_DWORD *)(v6 + 8);
  if ( v7 & 0x100 )
  {
    v8 = *(_DWORD *)(v6 + 12);
    if ( !*(_DWORD *)(v8 + 4) )
    {
      v10 = sub_1001B150(v8, (int)&v20);
      v21 = 0;
      v11 = sub_10017B50(v12, a3, v8, v10);
      v21 = -1;
      v9 = v20;
      *(_DWORD *)(v8 + 4) = v11;
      if ( v9 )
      {
        v13 = (*(int (**)(void))(*(_DWORD *)v9 + 8))();
        if ( v13 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v13)(v13, 1);
      }
    }
    v14 = (*(int (__stdcall **)(int))(**(_DWORD **)(v8 + 4) + 16))(a5);
  }
  else
  {
    if ( v7 & 0x800 )
      v14 = sub_1001A460(*(_DWORD *)(v6 + 12), a3, a4, a5);
    else
      v14 = a5;
  }
  v16 = *(_DWORD *)(v6 + 4);
  v15 = *(_DWORD *)(v16 + 24);
  if ( *(_DWORD *)(v16 + 20) <= v15 )
  {
    v18 = v15 + 16;
    v17 = sub_10030C56(a1, a2, v14, v15 + 16, *(LPVOID *)(v16 + 28), v15 + 16);
    if ( !v17 )
      sub_10029530();
    *(_DWORD *)(v16 + 28) = v17;
    *(_DWORD *)(v16 + 20) = v18;
  }
  result = *(_DWORD *)(v16 + 24);
  *(_BYTE *)(*(_DWORD *)(v16 + 28) + result) = v14;
  ++*(_DWORD *)(v16 + 24);
  return result;
}

//----- (1001EDA0) --------------------------------------------------------
int __thiscall sub_1001EDA0(int this, int a2, int a3)
{
  char v4; // [sp+0h] [bp-24h]@1
  int v5; // [sp+10h] [bp-14h]@1
  char *v6; // [sp+14h] [bp-10h]@1
  int v7; // [sp+20h] [bp-4h]@1

  v6 = &v4;
  v7 = 0;
  v5 = this;
  return sub_1001FFE0(this, *(_DWORD *)this, a2, a3, this);
}

//----- (1001EE10) --------------------------------------------------------
void *__thiscall sub_1001EE10(void *this, int a2, int a3)
{
  void *result; // eax@1
  int i; // ecx@1

  result = this;
  for ( i = a2; i != a3; result = (char *)result + 4 )
  {
    if ( result )
      *(_DWORD *)result = *(_DWORD *)i;
    i += 4;
  }
  return result;
}

//----- (1001EE40) --------------------------------------------------------
char __thiscall sub_1001EE40(int this)
{
  return sub_1001F5C0(this, 10, 2147483647) != 2147483647;
}

//----- (1001EE60) --------------------------------------------------------
char __userpurge sub_1001EE60<al>(int a1<ecx>, char a2<bl>, char a3)
{
  int v3; // esi@1
  unsigned __int16 v4; // ax@2
  int v5; // edx@2
  int v6; // edi@2
  char result; // al@7

  v3 = a1;
  if ( *(_DWORD *)a1 != *(_DWORD *)(a1 + 8)
    && (v4 = sub_1001F9B0(*(void **)(a1 + 60), *(_DWORD *)a1, *(_DWORD *)a1 + 1, (*(_DWORD *)(a1 + 64) & 0x100) != 0),
        v6 = v4,
        v4) )
  {
    if ( a3 )
      sub_1001F2A0(v5, v3 + 36, a2, v4);
    sub_10020320(*(_DWORD *)(v3 + 40), v6, *(_DWORD *)(v3 + 48));
    if ( sub_1001A530(*(_DWORD *)(v3 + 60), a2, *(_BYTE *)(v3 + 72), 1) )
      *(_DWORD *)(*(_DWORD *)(v3 + 40) + 8) ^= 1u;
    sub_1001DA00((void *)v3);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1001F1E0) --------------------------------------------------------
signed int __usercall sub_1001F1E0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>)
{
  unsigned int v3; // edx@1
  int v4; // esi@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // edx@1
  int v8; // ecx@1
  int v9; // esi@3
  signed int result; // eax@5

  v5 = a2;
  ++*(_DWORD *)(v5 + 12);
  v6 = sub_1001C990(a1, a2 + 36, a2, a3, *(_DWORD *)(a2 + 12));
  sub_1001C750(v5);
  sub_1001C8F0(v5 + 36, v7, v6);
  sub_1001A620(v5 + 20, *(_DWORD *)(v5 + 12) + 1, v8);
  v3 = *(_DWORD *)(v6 + 20);
  v4 = *(_DWORD *)(v5 + 20);
  if ( (signed int)v3 < 0 && v3 )
    v9 = -4 - 4 * ((-1 - v3) >> 5) + v4;
  else
    v9 = v4 + 4 * (v3 >> 5);
  result = 1 << (v3 & 0x1F);
  *(_DWORD *)v9 |= result;
  return result;
}

//----- (1001F270) --------------------------------------------------------
int __userpurge sub_1001F270<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, char a4)
{
  int result; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // edx@1

  v5 = a2;
  v6 = sub_1001FCD0(a1, a2 + 36, a3, a4);
  sub_1001C750(v5);
  result = sub_1001C8F0(v5 + 36, v7, v6);
  *(_DWORD *)(v5 + 40) = v6;
  return result;
}

//----- (1001F2A0) --------------------------------------------------------
int __usercall sub_1001F2A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // edx@1
  int v5; // esi@1
  int v6; // eax@4
  int result; // eax@6

  v5 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a4, 44);
  if ( v4 )
  {
    *(_DWORD *)(v4 + 4) = 7;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    *(_DWORD *)v4 = off_10067B04;
    *(_DWORD *)(v4 + 20) = 0;
    *(_DWORD *)(v4 + 24) = 0;
    *(_DWORD *)(v4 + 28) = 0;
    *(_DWORD *)(v4 + 32) = 0;
    *(_WORD *)(v4 + 36) = 0;
    *(_DWORD *)(v4 + 40) = 0;
  }
  else
  {
    v4 = 0;
  }
  *(_DWORD *)(v4 + 16) = *(_DWORD *)(v5 + 4);
  v6 = *(_DWORD *)(*(_DWORD *)(v5 + 4) + 12);
  if ( v6 )
  {
    *(_DWORD *)(v4 + 12) = v6;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v5 + 4) + 12) + 16) = v4;
  }
  result = *(_DWORD *)(v5 + 4);
  *(_DWORD *)(result + 12) = v4;
  *(_DWORD *)(v5 + 4) = v4;
  return result;
}
// 10067B04: using guessed type int (__stdcall *off_10067B04[4])(char);

//----- (1001F330) --------------------------------------------------------
int __userpurge sub_1001F330<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // eax@1
  int v6; // edx@1
  int v7; // esi@1
  int v8; // eax@4
  int result; // eax@6

  v7 = a2;
  v5 = sub_1002ADB1(a1, a2, a3, a4, 24);
  v6 = v5;
  if ( v5 )
  {
    *(_DWORD *)(v5 + 4) = 15;
    *(_DWORD *)(v5 + 8) = 0;
    *(_DWORD *)(v5 + 12) = 0;
    *(_DWORD *)(v5 + 16) = 0;
    *(_DWORD *)v5 = off_10067B0C;
    *(_DWORD *)(v5 + 20) = a5;
  }
  else
  {
    v6 = 0;
  }
  *(_DWORD *)(v6 + 16) = *(_DWORD *)(v7 + 4);
  v8 = *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12);
  if ( v8 )
  {
    *(_DWORD *)(v6 + 12) = v8;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) + 16) = v6;
  }
  result = *(_DWORD *)(v7 + 4);
  *(_DWORD *)(result + 12) = v6;
  *(_DWORD *)(v7 + 4) = v6;
  return result;
}
// 10067B0C: using guessed type int (__stdcall *off_10067B0C[2])(char);

//----- (1001F3A0) --------------------------------------------------------
int __userpurge sub_1001F3A0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5, char a6)
{
  int v6; // eax@1
  int v7; // ebx@1
  int v8; // eax@4
  int v9; // edx@4
  int v10; // ecx@4
  int v11; // esi@4
  int v12; // eax@7
  int v13; // edi@7
  signed int v14; // eax@8
  int v15; // edx@8
  int v16; // eax@12
  int v17; // eax@14
  int v18; // ecx@14
  int result; // eax@17
  int v20; // [sp+10h] [bp-4h]@4

  v7 = a2;
  v6 = *(_DWORD *)(a2 + 4);
  if ( *(_DWORD *)(v6 + 4) == 6 )
  {
    if ( *(_DWORD *)(v6 + 24) != 1 )
    {
      --*(_DWORD *)(v6 + 24);
      sub_1001EC90(a1, a2, a2, a3, *(_BYTE *)(*(_DWORD *)(v6 + 28) + *(_DWORD *)(v6 + 24)));
    }
  }
  v20 = *(_DWORD *)(v7 + 4);
  v8 = sub_1002ADB1(a1, a2, v7, a3, 24);
  v11 = v8;
  if ( v8 )
  {
    *(_DWORD *)(v8 + 4) = 19;
    *(_DWORD *)(v8 + 8) = 0;
    *(_DWORD *)(v8 + 12) = 0;
    *(_DWORD *)(v8 + 16) = 0;
    *(_DWORD *)v8 = off_10067B0C;
    *(_DWORD *)(v8 + 20) = 0;
  }
  else
  {
    v11 = 0;
  }
  v12 = sub_1002ADB1(v9, v10, v7, a3, 40);
  v13 = v12;
  if ( v12 )
  {
    *(_DWORD *)(v12 + 12) = 0;
    *(_DWORD *)(v12 + 16) = 0;
    *(_DWORD *)(v12 + 28) = 0;
    v15 = *(_DWORD *)(*(_DWORD *)v7 + 24);
    *(_DWORD *)(*(_DWORD *)v7 + 24) = v15 + 1;
    v14 = 0;
    if ( a6 )
      v14 = 2;
    *(_DWORD *)(v13 + 8) = v14;
    *(_DWORD *)(v13 + 20) = a4;
    *(_DWORD *)(v13 + 4) = 18;
    *(_DWORD *)(v13 + 12) = 0;
    *(_DWORD *)(v13 + 16) = 0;
    *(_DWORD *)v13 = off_10067B0C;
    *(_DWORD *)(v13 + 24) = a5;
    *(_DWORD *)(v13 + 28) = v11;
    *(_DWORD *)(v13 + 32) = v15;
    *(_DWORD *)(v13 + 36) = -1;
  }
  else
  {
    v13 = 0;
  }
  *(_DWORD *)(v11 + 20) = v13;
  *(_DWORD *)(v11 + 16) = *(_DWORD *)(v7 + 4);
  v16 = *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12);
  if ( v16 )
  {
    *(_DWORD *)(v11 + 12) = v16;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) + 16) = v11;
  }
  v18 = v20;
  *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) = v11;
  *(_DWORD *)(v7 + 4) = v11;
  v17 = *(_DWORD *)(v20 + 4);
  if ( v17 == 9 || v17 == 14 )
    v18 = *(_DWORD *)(v20 + 20);
  *(_DWORD *)(*(_DWORD *)(v18 + 16) + 12) = v13;
  result = *(_DWORD *)(v18 + 16);
  *(_DWORD *)(v13 + 16) = result;
  *(_DWORD *)(v18 + 16) = v13;
  *(_DWORD *)(v13 + 12) = v18;
  return result;
}
// 10067B0C: using guessed type int (__stdcall *off_10067B0C[2])(char);

//----- (1001F4E0) --------------------------------------------------------
int __usercall sub_1001F4E0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // esi@1
  int v7; // eax@4
  int result; // eax@6

  v6 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a4, 32);
  v5 = v4;
  if ( v4 )
  {
    *(_DWORD *)(v4 + 4) = 6;
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    *(_DWORD *)v4 = off_10067B00;
    *(_DWORD *)(v4 + 20) = 0;
    *(_DWORD *)(v4 + 24) = 0;
    *(_DWORD *)(v4 + 28) = 0;
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(v5 + 16) = *(_DWORD *)(v6 + 4);
  v7 = *(_DWORD *)(*(_DWORD *)(v6 + 4) + 12);
  if ( v7 )
  {
    *(_DWORD *)(v5 + 12) = v7;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 4) + 12) + 16) = v5;
  }
  result = *(_DWORD *)(v6 + 4);
  *(_DWORD *)(result + 12) = v5;
  *(_DWORD *)(v6 + 4) = v5;
  return result;
}
// 10067B00: using guessed type int (__stdcall *off_10067B00[5])(char);

//----- (1001F560) --------------------------------------------------------
void *__thiscall sub_1001F560(void *this, int a2, int a3)
{
  void *result; // eax@1
  int i; // ecx@1

  result = this;
  for ( i = a2; i != a3; result = (char *)result + 8 )
  {
    if ( result )
    {
      *(_DWORD *)result = *(_DWORD *)i;
      *((_DWORD *)result + 1) = *(_DWORD *)(i + 4);
    }
    i += 8;
  }
  return result;
}

//----- (1001F590) --------------------------------------------------------
void *__userpurge sub_1001F590<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_100309C2(a2, *(LPVOID *)(a1 + 28));
  *(_DWORD *)v3 = off_10067B0C;
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067B0C: using guessed type int (__stdcall *off_10067B0C[2])(char);

//----- (1001F5C0) --------------------------------------------------------
int __thiscall sub_1001F5C0(int this, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@1
  char v5; // cl@2
  int v6; // ecx@7
  int v7; // eax@13
  int v8; // ecx@13
  int v9; // eax@13
  int v10; // eax@15
  int v11; // ecx@16

  v3 = a3;
  v4 = this;
  *(_DWORD *)(this + 68) = 0;
  if ( a3 )
  {
    while ( 1 )
    {
      v5 = *(_BYTE *)(v4 + 72);
      if ( a2 == 8 )
      {
        if ( (unsigned __int8)(v5 - 48) > 7u )
          return v3;
      }
      else
      {
        if ( v5 < 48 || v5 > 57 )
        {
          if ( a2 != 16 )
            return v3;
          if ( (unsigned __int8)(v5 - 97) > 5u )
          {
            if ( (unsigned __int8)(v5 - 65) > 5u )
              return v3;
            v6 = v5 - 55;
          }
          else
          {
            v6 = v5 - 87;
          }
          goto LABEL_12;
        }
      }
      v6 = v5 - 48;
LABEL_12:
      if ( v6 != -1 )
      {
        v9 = v6 + a2 * *(_DWORD *)(v4 + 68);
        v8 = *(_DWORD *)(v4 + 8);
        *(_DWORD *)(v4 + 68) = v9;
        v7 = *(_DWORD *)v4;
        --v3;
        if ( *(_DWORD *)v4 != v8 )
        {
          if ( *(_BYTE *)v7 == 92 )
          {
            v10 = v7 + 1;
            if ( v10 != v8 )
            {
              v11 = *(_DWORD *)(v4 + 80);
              if ( !(v11 & 8) && (*(_BYTE *)v10 == 40 || *(_BYTE *)v10 == 41)
                || !(v11 & 0x10) && (*(_BYTE *)v10 == 123 || *(_BYTE *)v10 == 125) )
                *(_DWORD *)v4 = v10;
            }
          }
          ++*(_DWORD *)v4;
        }
        sub_1001C5A0((void *)v4);
        if ( v3 )
          continue;
      }
      return v3;
    }
  }
  return 0;
}

//----- (1001F6A0) --------------------------------------------------------
int __thiscall sub_1001F6A0(int this)
{
  int v1; // eax@1
  int v2; // esi@1
  int v3; // eax@2
  int v4; // ecx@2
  int v5; // eax@4
  int v6; // ecx@5
  int v7; // eax@13
  int v8; // ecx@13
  int result; // eax@14
  int v10; // edi@23

  v2 = this;
  v1 = *(_DWORD *)(this + 76);
  switch ( v1 )
  {
    case -4294967204:
      v3 = *(_DWORD *)this;
      v4 = *(_DWORD *)(this + 8);
      if ( *(_DWORD *)v2 != v4 )
      {
        if ( *(_BYTE *)v3 == 92 )
        {
          v5 = v3 + 1;
          if ( v5 != v4 )
          {
            v6 = *(_DWORD *)(v2 + 80);
            if ( !(v6 & 8) && (*(_BYTE *)v5 == 40 || *(_BYTE *)v5 == 41)
              || !(v6 & 0x10) && (*(_BYTE *)v5 == 123 || *(_BYTE *)v5 == 125) )
              *(_DWORD *)v2 = v5;
          }
        }
        ++*(_DWORD *)v2;
      }
      sub_1001C5A0((void *)v2);
      v7 = *(_DWORD *)(v2 + 80);
      if ( v7 & 0x200000 )
        return loc_100202A0(v2, v8);
      if ( v7 & 0x10000 && sub_1001F930(v2, *(_BYTE *)(v2 + 72)) )
        goto LABEL_20;
      if ( *(_DWORD *)(v2 + 80) & 0x8000 && *(_BYTE *)(v2 + 72) == 97 )
      {
        *(_DWORD *)(v2 + 68) = 7;
LABEL_20:
        sub_1001DA00((void *)v2);
        return 1;
      }
      *(_DWORD *)(v2 + 68) = 92;
      result = 1;
      break;
    case -4294967205:
      sub_1001DA00((void *)this);
      v10 = *(_DWORD *)(v2 + 76);
      if ( v10 == 58 || v10 == 61 || v10 == 46 )
      {
        sub_1001DA00((void *)v2);
        loc_10020130(v2, v10);
        result = 2;
      }
      else
      {
        *(_DWORD *)(v2 + 68) = 91;
        result = 1;
      }
      break;
    case -4294967203:
    case -1:
      result = 0;
      break;
    default:
      *(_DWORD *)(this + 68) = *(_BYTE *)(this + 72);
      sub_1001DA00((void *)this);
      result = 1;
      break;
  }
  return result;
}

//----- (1001F930) --------------------------------------------------------
char __thiscall sub_1001F930(int this, char a2)
{
  char result; // al@2

  switch ( a2 )
  {
    case 98:
      *(_DWORD *)(this + 68) = 8;
      result = 1;
      break;
    case 102:
      *(_DWORD *)(this + 68) = 12;
      result = 1;
      break;
    case 110:
      *(_DWORD *)(this + 68) = 10;
      result = 1;
      break;
    case 114:
      *(_DWORD *)(this + 68) = 13;
      result = 1;
      break;
    case 116:
      *(_DWORD *)(this + 68) = 9;
      result = 1;
      break;
    case 118:
      *(_DWORD *)(this + 68) = 11;
      result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

//----- (1001F9B0) --------------------------------------------------------
int __thiscall sub_1001F9B0(void *this, int a2, int a3, char a4)
{
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // eax@2
  char **v7; // edx@2
  int v8; // eax@3
  char *v9; // ebx@3
  int v10; // esi@3
  int v11; // eax@5
  char v12; // al@5
  int result; // eax@10
  int v14; // ecx@10
  int v15; // [sp+0h] [bp-Ch]@2
  int v16; // [sp+4h] [bp-8h]@3
  int v17; // [sp+8h] [bp-4h]@1

  v4 = (int)this;
  v5 = 0;
  v17 = 0;
  if ( off_10067B18 )
  {
    v15 = v4;
    v6 = 0;
    v7 = &off_10067B18;
    do
    {
      v9 = *v7;
      v10 = a2;
      v8 = (int)&(*v7)[*(int *)((char *)&dword_10067B1C + v6)];
      v16 = v8;
      if ( a2 == a3 )
      {
LABEL_8:
        if ( v9 == (char *)v8 )
          break;
      }
      else
      {
        while ( v9 != (char *)v8 )
        {
          LOBYTE(v5) = *v9;
          v11 = *(_BYTE *)v10++;
          v12 = sub_1001D8D0((int)&v15, (char)v9++, v11, v5);
          if ( !v12 )
            goto LABEL_17;
          v8 = v16;
          if ( v10 == a3 )
            goto LABEL_7;
        }
        if ( v10 == a3 )
        {
LABEL_7:
          v5 = v17;
          goto LABEL_8;
        }
LABEL_17:
        v5 = v17;
      }
      ++v5;
      v17 = v5;
      v6 = 12 * v5;
      v7 = &(&off_10067B18)[12 * v5];
    }
    while ( (&off_10067B18)[12 * v5] );
  }
  v14 = 3 * v5;
  result = 0;
  if ( (&off_10067B18)[4 * v14] )
    result = (unsigned __int16)word_10067B20[2 * v14];
  if ( a4 )
  {
    if ( result & 3 )
      result |= 3u;
  }
  return result;
}
// 10067B18: using guessed type char *off_10067B18;
// 10067B1C: using guessed type int dword_10067B1C;
// 10067B20: using guessed type __int16 word_10067B20[];

//----- (1001FA70) --------------------------------------------------------
int __userpurge sub_1001FA70<eax>(int a1<edx>, int a2<ecx>, __int16 a3<bx>, int a4, int a5)
{
  int v5; // edi@1
  int v6; // esi@2
  int v7; // ecx@3
  int v8; // eax@3
  int v9; // eax@3
  int v10; // edx@3
  int v11; // eax@4
  int v12; // esi@6
  char v13; // al@6
  int v14; // ecx@7
  int v15; // eax@7
  int v16; // eax@7
  int v17; // edx@7
  int v18; // eax@8
  int v19; // esi@12
  int v20; // eax@14
  int result; // eax@25
  int v23; // eax@31
  unsigned int v24; // eax@35
  int v25; // edi@35
  int v26; // eax@36
  int v27; // ecx@39
  unsigned int v28; // edi@39
  int v29; // esi@39
  int v30; // eax@40
  int v31; // edi@40
  int v32; // [sp+10h] [bp-14h]@7
  int v33; // [sp+14h] [bp-10h]@3
  int v34; // [sp+20h] [bp-4h]@3
  int v35; // [sp+2Ch] [bp+8h]@36
  int v36; // [sp+30h] [bp+Ch]@14

  v5 = a2;
  if ( *(_DWORD *)(a2 + 8) & 0x100 )
  {
    v6 = *(_DWORD *)(a2 + 12);
    if ( !*(_DWORD *)(v6 + 4) )
    {
      v8 = sub_1001B150(v6, (int)&v33);
      v34 = 0;
      v9 = sub_10017B50(v10, a3, v5, v8);
      v34 = -1;
      v7 = v33;
      *(_DWORD *)(v6 + 4) = v9;
      if ( v7 )
      {
        v11 = (*(int (**)(void))(*(_DWORD *)v7 + 8))();
        if ( v11 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v11)(v11, 1);
      }
    }
    v13 = (*(int (__stdcall **)(int))(**(_DWORD **)(v6 + 4) + 16))(a4);
    v12 = *(_DWORD *)(v5 + 12);
    LOBYTE(a3) = v13;
    LOBYTE(a4) = v13;
    if ( !*(_DWORD *)(v12 + 4) )
    {
      v15 = sub_1001B150(v12, (int)&v32);
      v34 = 1;
      v16 = sub_10017B50(v17, a3, v5, v15);
      v34 = -1;
      v14 = v32;
      *(_DWORD *)(v12 + 4) = v16;
      if ( v14 )
      {
        v18 = (*(int (**)(void))(*(_DWORD *)v14 + 8))();
        if ( v18 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v18)(v18, 1);
      }
    }
    HIBYTE(a3) = (*(int (__stdcall **)(int))(**(_DWORD **)(v12 + 4) + 16))(a5);
  }
  else
  {
    LOBYTE(a3) = a4;
    HIBYTE(a3) = a5;
  }
  v19 = *(_DWORD *)(v5 + 4);
  if ( (_BYTE)a3 < 0 )
    goto LABEL_46;
  if ( (_BYTE)a3 <= HIBYTE(a3) )
  {
    v20 = SHIBYTE(a3);
    v36 = SHIBYTE(a3);
    do
    {
      if ( v20 >= *(_DWORD *)(v5 + 16) )
        break;
      if ( !*(_DWORD *)(v19 + 24) )
      {
        _EAX = sub_1002ADB1(a1, a2, a3, v5, 32);
        if ( _EAX )
        {
          __asm
          {
            xorps   xmm0, xmm0
            movq    qword ptr [eax], xmm0
            movq    qword ptr [eax+8], xmm0
            movq    qword ptr [eax+10h], xmm0
            movq    qword ptr [eax+18h], xmm0
          }
        }
        else
        {
          _EAX = 0;
        }
        *(_DWORD *)(v19 + 24) = _EAX;
      }
      a1 = ((unsigned int)(char)a3 >> 3) + *(_DWORD *)(v19 + 24);
      a2 = a3 & 7;
      *(_BYTE *)a1 |= 1 << a2;
      if ( (_BYTE)a3 == HIBYTE(a3) )
        break;
      v20 = v36;
      LOBYTE(a3) = a3 + 1;
    }
    while ( (_BYTE)a3 <= HIBYTE(a3) );
    LOBYTE(a4) = a3;
  }
  if ( (_BYTE)a3 < 0 || (result = (char)a3, a2 = SHIBYTE(a3) - (char)a3, a2 >= *(_DWORD *)(v5 + 20)) )
  {
LABEL_46:
    if ( !*(_DWORD *)(v19 + 32) )
    {
      v23 = sub_1002ADB1(a1, a2, a3, v5, 12);
      if ( v23 )
      {
        *(_DWORD *)v23 = 0;
        *(_DWORD *)(v23 + 4) = 0;
        *(_DWORD *)(v23 + 8) = 0;
      }
      else
      {
        v23 = 0;
      }
      *(_DWORD *)(v19 + 32) = v23;
    }
    v25 = *(_DWORD *)(v19 + 32);
    v24 = *(_DWORD *)(v25 + 4);
    if ( *(_DWORD *)v25 <= v24 )
    {
      v35 = v24 + 16;
      v26 = sub_10030C56(a1, a2, a3, v25, *(LPVOID *)(v25 + 8), v24 + 16);
      if ( !v26 )
        sub_10029530();
      *(_DWORD *)(v25 + 8) = v26;
      *(_DWORD *)v25 = v35;
    }
    v27 = *(_DWORD *)(v25 + 8);
    *(_BYTE *)(v27 + *(_DWORD *)(v25 + 4)++) = a3;
    v29 = *(_DWORD *)(v19 + 32);
    v28 = *(_DWORD *)(v29 + 4);
    if ( *(_DWORD *)v29 <= v28 )
    {
      v31 = v28 + 16;
      v30 = sub_10030C56(a1, v27, a3, v31, *(LPVOID *)(v29 + 8), v31);
      if ( !v30 )
        sub_10029530();
      *(_DWORD *)(v29 + 8) = v30;
      *(_DWORD *)v29 = v31;
    }
    result = *(_DWORD *)(v29 + 4);
    *(_BYTE *)(*(_DWORD *)(v29 + 8) + result) = HIBYTE(a3);
    ++*(_DWORD *)(v29 + 4);
  }
  else
  {
    for ( ; (_BYTE)a3 <= HIBYTE(a3); LOBYTE(a4) = a3 )
    {
      result = sub_1001FED0(a1, v5, a3, v5, a4);
      if ( (_BYTE)a3 == HIBYTE(a3) )
        break;
      LOBYTE(a3) = a3 + 1;
    }
  }
  return result;
}

//----- (1001FCD0) --------------------------------------------------------
int __userpurge sub_1001FCD0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, char a4)
{
  int v4; // eax@1
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // eax@4
  int v10; // edx@4
  int v11; // eax@7
  int result; // eax@9
  char v13; // [sp+0h] [bp-20h]@1
  char *v14; // [sp+10h] [bp-10h]@1
  int v15; // [sp+1Ch] [bp-4h]@4

  v14 = &v13;
  v7 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a2, 24);
  v8 = v4;
  if ( v4 )
  {
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    *(_DWORD *)v4 = &off_10067B10;
    *(_DWORD *)(v4 + 20) = 0;
    *(_DWORD *)(v4 + 4) = (a4 != 0) + 10;
  }
  else
  {
    v8 = 0;
  }
  v15 = 0;
  v9 = sub_1002ADB1(v5, v6, a3, v7, 20);
  v10 = v9;
  if ( v9 )
  {
    *(_DWORD *)v9 = off_10067B0C;
    *(_DWORD *)(v9 + 4) = 1;
    *(_DWORD *)(v9 + 8) = 0;
    *(_DWORD *)(v9 + 12) = 0;
    *(_DWORD *)(v9 + 16) = 0;
  }
  else
  {
    v10 = 0;
  }
  *(_DWORD *)(v8 + 16) = *(_DWORD *)(v7 + 4);
  v11 = *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12);
  if ( v11 )
  {
    *(_DWORD *)(v8 + 12) = v11;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) + 16) = v8;
  }
  result = v8;
  *(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) = v8;
  *(_DWORD *)(v8 + 20) = v10;
  *(_DWORD *)(v10 + 16) = v8;
  *(_DWORD *)(v7 + 4) = v10;
  return result;
}
// 10067B0C: using guessed type int (__stdcall *off_10067B0C[2])(char);
// 10067B10: using guessed type int (__stdcall *off_10067B10)(char);

//----- (1001FDE0) --------------------------------------------------------
char __userpurge sub_1001FDE0<al>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>, int a5)
{
  int v5; // esi@1
  int v6; // ecx@3
  int v7; // eax@3
  int v8; // eax@3
  int v9; // edx@3
  int v10; // eax@4
  char v11; // bl@6
  int v12; // esi@8
  char result; // al@13
  unsigned int v15; // edx@13
  int v16; // [sp+10h] [bp-10h]@3
  int v17; // [sp+1Ch] [bp-4h]@3

  v5 = a2;
  if ( *(_DWORD *)(a2 + 8) & 0x100 )
  {
    a4 = *(_DWORD *)(a2 + 12);
    if ( !*(_DWORD *)(a4 + 4) )
    {
      v7 = sub_1001B150(a4, (int)&v16);
      v17 = 0;
      v8 = sub_10017B50(v9, a3, a4, v7);
      v17 = -1;
      v6 = v16;
      *(_DWORD *)(a4 + 4) = v8;
      if ( v6 )
      {
        v10 = (*(int (**)(void))(*(_DWORD *)v6 + 8))();
        if ( v10 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v10)(v10, 1);
      }
    }
    v11 = (*(int (__stdcall **)(int))(**(_DWORD **)(a4 + 4) + 16))(a5);
  }
  else
  {
    v11 = a5;
  }
  v12 = *(_DWORD *)(v5 + 4);
  if ( !*(_DWORD *)(v12 + 24) )
  {
    _EAX = sub_1002ADB1(a1, a2, v11, a4, 32);
    if ( _EAX )
    {
      __asm
      {
        xorps   xmm0, xmm0
        movq    qword ptr [eax], xmm0
        movq    qword ptr [eax+8], xmm0
        movq    qword ptr [eax+10h], xmm0
        movq    qword ptr [eax+18h], xmm0
      }
    }
    else
    {
      _EAX = 0;
    }
    *(_DWORD *)(v12 + 24) = _EAX;
  }
  v15 = ((unsigned int)v11 >> 3) + *(_DWORD *)(v12 + 24);
  result = 1 << (v11 & 7);
  *(_BYTE *)v15 |= result;
  return result;
}

//----- (1001FED0) --------------------------------------------------------
int __userpurge sub_1001FED0<eax>(int a1<edx>, int a2<ecx>, char a3<bl>, int a4<edi>, int a5)
{
  int v5; // esi@1
  int v6; // ecx@3
  int v7; // eax@3
  int v8; // eax@3
  int v9; // edx@3
  int v10; // eax@4
  char v11; // bl@6
  int v12; // esi@8
  int v13; // eax@9
  unsigned int v14; // eax@13
  int v15; // esi@13
  int v16; // eax@14
  int v17; // edi@14
  int result; // eax@17
  int v19; // [sp+10h] [bp-10h]@3
  int v20; // [sp+1Ch] [bp-4h]@3

  v5 = a2;
  if ( *(_DWORD *)(a2 + 8) & 0x100 )
  {
    a4 = *(_DWORD *)(a2 + 12);
    if ( !*(_DWORD *)(a4 + 4) )
    {
      v7 = sub_1001B150(a4, (int)&v19);
      v20 = 0;
      v8 = sub_10017B50(v9, a3, a4, v7);
      v20 = -1;
      v6 = v19;
      *(_DWORD *)(a4 + 4) = v8;
      if ( v6 )
      {
        v10 = (*(int (**)(void))(*(_DWORD *)v6 + 8))();
        if ( v10 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v10)(v10, 1);
      }
    }
    v11 = (*(int (__stdcall **)(int))(**(_DWORD **)(a4 + 4) + 16))(a5);
  }
  else
  {
    v11 = a5;
  }
  v12 = *(_DWORD *)(v5 + 4);
  if ( !*(_DWORD *)(v12 + 28) )
  {
    v13 = sub_1002ADB1(a1, a2, v11, a4, 12);
    if ( v13 )
    {
      *(_DWORD *)v13 = 0;
      *(_DWORD *)(v13 + 4) = 0;
      *(_DWORD *)(v13 + 8) = 0;
    }
    else
    {
      v13 = 0;
    }
    *(_DWORD *)(v12 + 28) = v13;
  }
  v15 = *(_DWORD *)(v12 + 28);
  v14 = *(_DWORD *)(v15 + 4);
  if ( *(_DWORD *)v15 <= v14 )
  {
    v17 = v14 + 16;
    v16 = sub_10030C56(a1, a2, v11, v14 + 16, *(LPVOID *)(v15 + 8), v14 + 16);
    if ( !v16 )
      sub_10029530();
    *(_DWORD *)(v15 + 8) = v16;
    *(_DWORD *)v15 = v17;
  }
  result = *(_DWORD *)(v15 + 4);
  *(_BYTE *)(*(_DWORD *)(v15 + 8) + result) = v11;
  ++*(_DWORD *)(v15 + 4);
  return result;
}

//----- (1001FFE0) --------------------------------------------------------
int __thiscall sub_1001FFE0(int this, int a2, int a3, int a4, int a5)
{
  int result; // eax@1
  int v6; // ebx@1
  int v7; // esi@1
  void *v8; // ecx@2
  char v9; // cf@2
  const void *v10; // edx@3
  int v11; // edx@4
  int v12; // ecx@4
  int v13; // ecx@4
  unsigned int v14; // edi@4
  int v15; // edi@5
  int v16; // ecx@9
  int v17; // esi@12
  int v18; // esi@12
  void *v19; // eax@12
  void *v20; // eax@12
  int v21; // edx@15
  int v22; // [sp+8h] [bp-Ch]@9

  result = a4;
  v7 = a4 - a3;
  v6 = this;
  if ( a4 != a3 )
  {
    v9 = *(_DWORD *)(this + 8) - *(_DWORD *)(this + 4) < (unsigned int)v7;
    v8 = *(void **)(this + 4);
    if ( v9 )
    {
      v10 = *(const void **)v6;
      if ( *(_DWORD *)v6 - (_DWORD)v8 - 1 < (unsigned int)v7 )
      {
        sub_10029585((int)"vector<T> too long");
      }
      else
      {
        v13 = v8 - v10;
        v14 = *(_DWORD *)(v6 + 8) - (_DWORD)v10;
        v11 = v14 >> 1;
        v12 = v7 + v13;
        if ( -1 - (v14 >> 1) >= v14 )
          v15 = v11 + v14;
        else
          v15 = 0;
        if ( v15 < (unsigned int)v12 )
          v15 = v12;
        v16 = 0;
        v22 = 0;
        if ( !v15 || (unsigned int)v15 <= 0xFFFFFFFF && (v16 = sub_1002ADB1(v11, 0, v6, v15, v15), v22 = v16, v16) )
        {
          v18 = a2 - *(_DWORD *)v6;
          v19 = sub_1002A4B0((void *)v16, *(const void **)v6, a2 - *(_DWORD *)v6);
          v20 = sub_10020740((char *)v19 + v18, a3, a4);
          sub_1002A4B0(v20, (const void *)a2, *(_DWORD *)(v6 + 4) - a2);
          v17 = *(_DWORD *)(v6 + 4) - *(_DWORD *)v6 + a4 - a3;
          if ( *(_DWORD *)v6 )
            sub_1002A4AA(*(LPVOID *)v6);
          *(_DWORD *)v6 = v22;
          *(_DWORD *)(v6 + 8) = v22 + v15;
          result = v22 + v17;
          *(_DWORD *)(v6 + 4) = v22 + v17;
          return result;
        }
      }
      sub_10029530();
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(loc_10020130);
    }
    sub_10020740(v8, a3, a4);
    v21 = *(_DWORD *)(v6 + 4);
    result = v21 + v7;
    if ( a2 != v21 )
    {
      if ( v21 != result )
        result = sub_10020770(a2, v21, v21 + v7);
    }
    *(_DWORD *)(v6 + 4) += v7;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10020320) --------------------------------------------------------
char __stdcall sub_10020320(int a1, int a2, int a3)
{
  unsigned int v3; // esi@1
  char result; // al@2
  int v5; // edx@2
  int v6; // ecx@2

  v3 = 0;
  do
  {
    result = sub_1001A530(a3, a3, v3, a2);
    if ( result )
    {
      if ( !*(_DWORD *)(a1 + 24) )
      {
        _EAX = sub_1002ADB1(v5, v6, a3, a1, 32);
        if ( _EAX )
        {
          __asm
          {
            xorps   xmm0, xmm0
            movq    qword ptr [eax], xmm0
            movq    qword ptr [eax+8], xmm0
            movq    qword ptr [eax+10h], xmm0
            movq    qword ptr [eax+18h], xmm0
          }
        }
        else
        {
          _EAX = 0;
        }
        *(_DWORD *)(a1 + 24) = _EAX;
      }
      result = 1 << (v3 & 7);
      *(_BYTE *)(*(_DWORD *)(a1 + 24) + (v3 >> 3)) |= result;
    }
    ++v3;
  }
  while ( (signed int)v3 < 256 );
  return result;
}

//----- (100203A0) --------------------------------------------------------
char __thiscall sub_100203A0(int this, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // esi@1
  int v6; // eax@1
  void *v7; // ecx@1
  int v8; // eax@2
  int v9; // ecx@2
  void *v10; // ecx@2
  int *v11; // esi@2
  char v12; // cf@4
  int v13; // edx@6
  char v14; // cf@9
  char v15; // cf@11
  unsigned __int8 v16; // cf@13
  unsigned __int8 v17; // al@19
  int v18; // eax@20
  char v19; // zf@22
  bool v20; // eax@25
  char result; // al@28
  int v22; // edi@31
  void *v24; // [sp+10h] [bp-58h]@2
  unsigned int v25; // [sp+24h] [bp-44h]@28
  int v26; // [sp+28h] [bp-40h]@1
  int v27; // [sp+2Ch] [bp-3Ch]@4
  int v28; // [sp+30h] [bp-38h]@1
  char v29; // [sp+37h] [bp-31h]@28
  void *v30; // [sp+38h] [bp-30h]@1
  unsigned int v31; // [sp+48h] [bp-20h]@6
  unsigned int v32; // [sp+4Ch] [bp-1Ch]@2
  char v33; // [sp+53h] [bp-15h]@2
  unsigned int v34; // [sp+54h] [bp-14h]@1
  int v35; // [sp+64h] [bp-4h]@1
  int v36; // [sp+68h] [bp+0h]@1

  v34 = (unsigned int)&v36 ^ __security_cookie;
  v5 = this;
  v26 = this;
  v6 = *(_DWORD *)(this + 4);
  v7 = *(void **)(this + 12);
  v28 = v6;
  sub_1001D600(v7, (int)&v30, a2, a3);
  v35 = 0;
  v4 = 0;
  do
  {
    v10 = *(void **)(v5 + 12);
    v33 = v4;
    v8 = sub_100205B0(v10, (int)&v24, (int)&v33, (int)&v34);
    v9 = *(_DWORD *)(v8 + 16);
    v11 = (int *)&v30;
    if ( v32 >= 0x10 )
      v11 = (int *)v30;
    v12 = *(_DWORD *)(v8 + 20) < 0x10u;
    v27 = *(_DWORD *)(v8 + 16);
    if ( !v12 )
      v8 = *(_DWORD *)v8;
    v13 = v31;
    if ( v9 < v31 )
      v13 = v9;
    if ( !v13 )
      goto LABEL_24;
    v14 = (unsigned int)v13 < 4;
    v13 -= 4;
    if ( v14 )
    {
LABEL_12:
      if ( v13 == -4 )
        goto LABEL_21;
    }
    else
    {
      while ( 1 )
      {
        v9 = *(_DWORD *)v8;
        if ( *(_DWORD *)v8 != *v11 )
          break;
        v8 += 4;
        ++v11;
        v15 = (unsigned int)v13 < 4;
        v13 -= 4;
        if ( v15 )
          goto LABEL_12;
      }
    }
    LOBYTE(v9) = *(_BYTE *)v8;
    v16 = *(_BYTE *)v8 < *(_BYTE *)v11;
    if ( *(_BYTE *)v8 == *(_BYTE *)v11 )
    {
      if ( v13 == -3
        || (LOBYTE(v9) = *(_BYTE *)(v8 + 1), v16 = (_BYTE)v9 < *((_BYTE *)v11 + 1), (_BYTE)v9 == *((_BYTE *)v11 + 1))
        && (v13 == -2
         || (LOBYTE(v9) = *(_BYTE *)(v8 + 2), v16 = (_BYTE)v9 < *((_BYTE *)v11 + 2), (_BYTE)v9 == *((_BYTE *)v11 + 2))
         && (v13 == -1 || (v17 = *(_BYTE *)(v8 + 3), v16 = v17 < *((_BYTE *)v11 + 3), v17 == *((_BYTE *)v11 + 3)))) )
      {
LABEL_21:
        v18 = 0;
        goto LABEL_22;
      }
    }
    v18 = -v16 | 1;
LABEL_22:
    v19 = v18 == 0;
    if ( v18 )
      goto LABEL_28;
    v9 = v27;
LABEL_24:
    if ( v9 >= v31 )
      v20 = v9 != v31;
    else
      v20 = -1;
    v19 = v20 == 0;
LABEL_28:
    result = v19;
    v29 = v19;
    if ( v25 >= 0x10 )
    {
      sub_1002A4AA(v24);
      result = v29;
    }
    if ( result )
    {
      v22 = v28;
      if ( !*(_DWORD *)(v28 + 24) )
      {
        _EAX = sub_1002ADB1(v13, v9, v4, v28, 32);
        if ( _EAX )
        {
          __asm
          {
            xorps   xmm0, xmm0
            movq    qword ptr [eax], xmm0
            movq    qword ptr [eax+8], xmm0
            movq    qword ptr [eax+10h], xmm0
            movq    qword ptr [eax+18h], xmm0
          }
        }
        else
        {
          _EAX = 0;
        }
        *(_DWORD *)(v22 + 24) = _EAX;
      }
      result = 1 << (v4 & 7);
      *(_BYTE *)(*(_DWORD *)(v22 + 24) + ((unsigned int)v4 >> 3)) |= result;
    }
    v5 = v26;
    ++v4;
  }
  while ( v4 < 256 );
  if ( v32 >= 0x10 )
    result = sub_1002A4AA(v30);
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10020540) --------------------------------------------------------
int __fastcall sub_10020540(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // ebx@1
  int v7; // esi@1
  int v8; // eax@2
  int v9; // eax@6

  v7 = a6;
  v6 = *(_DWORD *)a6;
  if ( !*(_DWORD *)a6 )
    goto LABEL_13;
  do
  {
    v8 = *(_DWORD *)v7;
    if ( (unsigned int)a5 >= **(_DWORD **)v7 )
      break;
    v7 = v8 + 16;
  }
  while ( *(_DWORD *)(v8 + 16) );
  v6 = *(_DWORD *)v7;
  if ( !*(_DWORD *)v7 || a5 != *(_DWORD *)v6 )
  {
LABEL_13:
    v9 = sub_1002ADB1(a2, a1, v6, a5, 20);
    if ( v9 )
    {
      *(_DWORD *)v9 = a5;
      *(_DWORD *)(v9 + 4) = 0;
      *(_DWORD *)(v9 + 8) = 0;
      *(_DWORD *)(v9 + 12) = 0;
    }
    else
    {
      v9 = 0;
    }
    *(_DWORD *)v7 = v9;
    *(_DWORD *)(v9 + 16) = v6;
  }
  return loc_10020840(*(_DWORD *)v7 + 4, a3, a4);
}

//----- (100205B0) --------------------------------------------------------
int __thiscall sub_100205B0(void *this, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@2
  int v6; // ecx@3
  int v7; // eax@3
  int v8; // eax@3
  int v9; // edx@3
  int v10; // eax@4
  int v11; // ecx@7
  int v12; // eax@7
  int v13; // eax@7
  int v14; // edx@7
  int v15; // eax@8
  int v16; // ebx@10
  void *v18; // [sp+14h] [bp-38h]@10
  unsigned int v19; // [sp+28h] [bp-24h]@14
  int v20; // [sp+2Ch] [bp-20h]@2
  int v21; // [sp+30h] [bp-1Ch]@2
  int v22; // [sp+34h] [bp-18h]@2
  int v23; // [sp+38h] [bp-14h]@1
  int v24; // [sp+48h] [bp-4h]@1
  int v25; // [sp+58h] [bp+Ch]@2

  v4 = (int)this;
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  v24 = 0;
  v23 = 1;
  if ( a3 != a4 )
  {
    v20 = 0;
    v21 = 0;
    v22 = 0;
    sub_100208A0(&v20, a3, a4);
    v24 = 1;
    v5 = v20;
    v25 = v21 - v20;
    if ( !*(_DWORD *)(v4 + 4) )
    {
      v7 = sub_1001B150(v4, (int)&a4);
      LOBYTE(v24) = 2;
      v8 = sub_10017B50(v9, v4, v5, v7);
      LOBYTE(v24) = 1;
      v6 = a4;
      *(_DWORD *)(v4 + 4) = v8;
      if ( v6 )
      {
        v10 = (*(int (**)(void))(*(_DWORD *)v6 + 8))();
        if ( v10 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v10)(v10, 1);
      }
    }
    (*(void (__stdcall **)(int, int))(**(_DWORD **)(v4 + 4) + 12))(v5, v5 + v25);
    if ( !*(_DWORD *)v4 )
    {
      v12 = sub_1001B150(v4, (int)&a4);
      LOBYTE(v24) = 3;
      v13 = sub_1001C310(v14, v4, v5, v12);
      LOBYTE(v24) = 1;
      v11 = a4;
      *(_DWORD *)v4 = v13;
      if ( v11 )
      {
        v15 = (*(int (**)(void))(*(_DWORD *)v11 + 8))();
        if ( v15 )
          (**(void (__thiscall ***)(_DWORD, _DWORD))v15)(v15, 1);
      }
    }
    v16 = sub_1001AEF0(*(void **)v4, (int)&v18, v5, v5 + v25);
    if ( a2 != v16 )
    {
      if ( *(_DWORD *)(a2 + 20) >= 0x10u )
        sub_1002A4AA(*(LPVOID *)a2);
      *(_DWORD *)(a2 + 20) = 15;
      *(_DWORD *)(a2 + 16) = 0;
      *(_BYTE *)a2 = 0;
      sub_100017B0((void *)a2, v16);
    }
    if ( v19 >= 0x10 )
      sub_1002A4AA(v18);
    if ( v5 )
      sub_1002A4AA((LPVOID)v5);
  }
  return a2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10020740) --------------------------------------------------------
void *__thiscall sub_10020740(void *this, int a2, int a3)
{
  void *result; // eax@1
  int i; // ecx@1

  result = this;
  for ( i = a2; i != a3; result = (char *)result + 1 )
  {
    if ( result )
      *(_BYTE *)result = *(_BYTE *)i;
    ++i;
  }
  return result;
}

//----- (10020770) --------------------------------------------------------
int __fastcall sub_10020770(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // edx@1
  int v5; // ecx@1
  signed int v6; // ebx@1
  int v7; // edi@1
  signed int v8; // esi@1
  int v9; // edi@1
  int v10; // edx@2
  int v11; // ebx@6
  int v12; // eax@7
  int v13; // edx@9
  int v14; // esi@9
  char v15; // dl@10
  int v16; // [sp+Ch] [bp-1Ch]@6
  int v17; // [sp+14h] [bp-14h]@1
  int v18; // [sp+18h] [bp-10h]@1
  int v19; // [sp+18h] [bp-10h]@6
  int v20; // [sp+1Ch] [bp-Ch]@1
  int v21; // [sp+20h] [bp-8h]@9
  int v22; // [sp+24h] [bp-4h]@1

  v9 = a2;
  v4 = a1;
  v5 = a3;
  v7 = v9 - v4;
  result = a3 - v4;
  v22 = v4;
  v17 = v7;
  v18 = a3 - v4;
  v6 = a3 - v4;
  v20 = a3 - v4;
  v8 = v7;
  if ( v7 )
  {
    do
    {
      v10 = v6 % v8;
      v6 = v8;
      v8 = v10;
    }
    while ( v10 );
    v4 = v22;
    result = v18;
    v20 = v6;
  }
  if ( v6 < result )
  {
    if ( v6 > 0 )
    {
      v16 = -v4;
      v19 = -v7;
      v11 = v4 + v6;
      do
      {
        v12 = v11 + v7;
        if ( v11 + v7 == v5 )
          v12 = v22;
        v13 = v11;
        v21 = v11;
        v14 = -v12;
        do
        {
          v15 = *(_BYTE *)v13;
          *(_BYTE *)v21 = *(_BYTE *)v12;
          v7 = v17;
          *(_BYTE *)v12 = v15;
          v13 = v12;
          v21 = v12;
          if ( v17 >= v14 + a3 )
          {
            v12 += v22 + v17 - a3;
            v14 += a3 + v19 + v16;
            v13 = v21;
          }
          else
          {
            v12 += v17;
            v14 += v19;
          }
        }
        while ( v12 != v11 );
        v5 = a3;
        result = v20 - 1;
        --v11;
        v20 = result;
      }
      while ( result > 0 );
    }
  }
  return result;
}

//----- (100208A0) --------------------------------------------------------
int __thiscall sub_100208A0(void *this, int a2, int a3)
{
  char v4; // [sp+0h] [bp-24h]@1
  void *v5; // [sp+10h] [bp-14h]@1
  char *v6; // [sp+14h] [bp-10h]@1
  int v7; // [sp+20h] [bp-4h]@1

  v6 = &v4;
  v7 = 0;
  v5 = this;
  return loc_10020910(*(_DWORD *)this);
}

//----- (10020A40) --------------------------------------------------------
int __thiscall sub_10020A40(void *this, int a2)
{
  int v2; // eax@1
  int v3; // ebx@2
  char *v4; // edi@2
  const char *v5; // edx@3
  unsigned int v6; // ecx@6
  char v7; // bl@13
  LPVOID v9[4]; // [sp+14h] [bp-40h]@5
  int v10; // [sp+24h] [bp-30h]@5
  unsigned int v11; // [sp+28h] [bp-2Ch]@5
  LPVOID v12[4]; // [sp+2Ch] [bp-28h]@2
  int v13; // [sp+3Ch] [bp-18h]@2
  unsigned int v14; // [sp+40h] [bp-14h]@2

  v2 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    v5 = *(const char **)(v2 + 24);
    if ( !v5 )
      v5 = (const char *)(v2 + 28);
    v11 = 15;
    v10 = 0;
    LOBYTE(v9[0]) = 0;
    if ( *v5 )
      v6 = strlen(v5);
    else
      v6 = 0;
    loc_1000AEB0(v9, v5, v6);
    v4 = (char *)v9;
    LOBYTE(v3) = 2;
  }
  else
  {
    v14 = 15;
    v13 = v2;
    LOBYTE(v12[0]) = v2;
    v4 = (char *)v12;
    v3 = v2 + 1;
  }
  *(_DWORD *)(a2 + 20) = 15;
  *(_DWORD *)(a2 + 16) = 0;
  *(_BYTE *)a2 = 0;
  if ( *((_DWORD *)v4 + 5) >= 0x10u )
  {
    *(_DWORD *)a2 = *(_DWORD *)v4;
    *(_DWORD *)v4 = 0;
  }
  else
  {
    if ( *((_DWORD *)v4 + 4) != -1 )
      sub_1002A4B0((void *)a2, v4, *((_DWORD *)v4 + 4) + 1);
  }
  *(_DWORD *)(a2 + 16) = *((_DWORD *)v4 + 4);
  v7 = v3 | 4;
  *(_DWORD *)(a2 + 20) = *((_DWORD *)v4 + 5);
  *((_DWORD *)v4 + 5) = 15;
  *((_DWORD *)v4 + 4) = 0;
  *v4 = 0;
  if ( v7 & 2 )
  {
    v7 &= 0xFDu;
    if ( v11 >= 0x10 )
      sub_1002A4AA(v9[0]);
    v11 = 15;
    v10 = 0;
    LOBYTE(v9[0]) = 0;
  }
  if ( v7 & 1 )
  {
    if ( v14 >= 0x10 )
      sub_1002A4AA(v12[0]);
  }
  return a2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10020BA0) --------------------------------------------------------
int __thiscall sub_10020BA0(void *this, int a2, char a3, int a4, int a5)
{
  char v9; // [sp-48h] [bp-50h]@1
  int v10; // [sp-44h] [bp-4Ch]@1
  int v11; // [sp-40h] [bp-48h]@1
  int v12; // [sp-3Ch] [bp-44h]@1
  int v13; // [sp-38h] [bp-40h]@1
  unsigned int v14; // [sp-34h] [bp-3Ch]@1
  char v15; // [sp-30h] [bp-38h]@1
  __int64 v16; // [sp-28h] [bp-30h]@1
  __int64 v17; // [sp-20h] [bp-28h]@1
  __int64 v18; // [sp-18h] [bp-20h]@1
  __int64 v19; // [sp-10h] [bp-18h]@1
  int v20; // [sp-8h] [bp-10h]@1
  int v21; // [sp-4h] [bp-Ch]@1

  _ESI = a2;
  v21 = a5;
  __asm { movq    xmm0, qword ptr [esi+18h] }
  v20 = a4;
  _EDI = (int)this;
  _EAX = &v15;
  __asm
  {
    movq    qword ptr [eax], xmm0
    movq    xmm0, qword ptr [esi+20h]
    movq    qword ptr [eax+8], xmm0
    movq    xmm0, qword ptr [esi+28h]
    movq    qword ptr [eax+10h], xmm0
    movq    xmm0, qword ptr [esi+30h]
    movq    qword ptr [eax+18h], xmm0
    movq    xmm0, qword ptr [esi+38h]
  }
  v14 = 15;
  v13 = 0;
  __asm { movq    qword ptr [eax+20h], xmm0 }
  v9 = 0;
  loc_1000AB40(a2, 0, -1);
  sub_1000B010(
    _EDI,
    word_10074F78,
    a3,
    *(void **)&v9,
    v10,
    v11,
    v12,
    v13,
    v14,
    *(__int64 *)&v15,
    v16,
    v17,
    v18,
    v19,
    v20,
    v21);
  *(_DWORD *)_EDI = &off_1006727C;
  __asm
  {
    movq    xmm0, qword ptr [esi+40h]
    movq    qword ptr [edi+138h], xmm0
    movq    xmm0, qword ptr [esi+48h]
    movq    qword ptr [edi+140h], xmm0
  }
  *(_DWORD *)(_EDI + 344) = 0;
  *(_DWORD *)(_EDI + 348) = 0;
  *(_DWORD *)(_EDI + 352) = 0;
  *(_DWORD *)(_EDI + 356) = 0;
  return _EDI;
}
// 1006727C: using guessed type int (__stdcall *off_1006727C)(char);
// 10074F78: using guessed type __int16 word_10074F78;

//----- (10020C70) --------------------------------------------------------
int __fastcall sub_10020C70(int a1, char a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8, int a9, int a10)
{
  int v10; // edx@1
  char v11; // bl@1
  int v12; // edi@1
  int v13; // ecx@1
  signed int v14; // eax@2
  int v15; // eax@4
  int v16; // ecx@4
  void *v17; // esi@4
  int v18; // esi@5
  char v20; // [sp-1Ch] [bp-90h]@1
  void *v21; // [sp-18h] [bp-8Ch]@1
  int v22; // [sp-14h] [bp-88h]@1
  int v23; // [sp-10h] [bp-84h]@1
  int v24; // [sp-Ch] [bp-80h]@1
  int v25; // [sp-8h] [bp-7Ch]@1
  unsigned int v26; // [sp-4h] [bp-78h]@1
  int v27; // [sp+10h] [bp-64h]@4
  void *v28; // [sp+14h] [bp-60h]@1
  int v29; // [sp+24h] [bp-50h]@1
  unsigned int v30; // [sp+28h] [bp-4Ch]@1
  int v31; // [sp+4Ch] [bp-28h]@2
  unsigned int v32; // [sp+64h] [bp-10h]@1
  int v33; // [sp+70h] [bp-4h]@1
  int v34; // [sp+74h] [bp+0h]@1

  v32 = (unsigned int)&v34 ^ __security_cookie;
  v26 = (unsigned int)&v34 ^ __security_cookie;
  v11 = a2;
  v12 = a1;
  v33 = 0;
  v30 = 15;
  v29 = 0;
  LOBYTE(v28) = 0;
  LOBYTE(v33) = 1;
  v25 = 15;
  v24 = 0;
  v20 = 0;
  loc_1000AB40(&a3, 0, -1, *(_DWORD *)&v20);
  if ( !sub_10020ED0(v13, (int)&v28, v21, v22, v23, v24, v25, v26) )
    goto LABEL_14;
  v14 = v31;
  if ( !v11 )
    v14 = 15;
  v31 = v14;
  v15 = sub_1002ADB1(v10, 15, v11, v12, 360);
  v17 = (void *)v15;
  v27 = v15;
  LOBYTE(v33) = 2;
  if ( v15 )
  {
    sub_1000BC10(v15, v16);
    v18 = sub_10020BA0(v17, (int)&v28, v12, a9, a10);
  }
  else
  {
LABEL_14:
    v18 = 0;
  }
  if ( v30 >= 0x10 )
    sub_1002A4AA(v28);
  v30 = 15;
  v29 = 0;
  LOBYTE(v28) = 0;
  if ( a8 >= 0x10 )
    sub_1002A4AA(a3);
  return v18;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10020D90) --------------------------------------------------------
int __thiscall sub_10020D90(int _ECX, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6, int a7, __int64 a8, int a9, int a10)
{
  int result; // eax@1

  result = *(_DWORD *)(_ECX + 344);
  __asm
  {
    movsd   xmm4, [ebp+arg_10]
    movapd  xmm7, xmm1
    movsd   qword ptr [ecx+148h], xmm7
    movsd   qword ptr [ecx+150h], xmm2
  }
  if ( result && result != 2 )
    goto LABEL_21;
  __asm
  {
    movsd   xmm5, qword ptr [ecx+88h]
    movsd   xmm0, qword ptr [ecx+138h]
    movsd   xmm6, qword ptr [ecx+80h]
    mulsd   xmm0, xmm5
    movapd  xmm1, xmm2
    subsd   xmm1, xmm7
    mulsd   xmm0, xmm6
    comisd  xmm1, xmm0
  }
  if ( _CF | _ZF )
    goto LABEL_21;
  __asm
  {
    movsd   xmm0, qword ptr [ecx+140h]
    movsd   xmm1, [ebp+arg_18]
    mulsd   xmm0, xmm5
    subsd   xmm1, xmm4
    mulsd   xmm0, xmm6
    comisd  xmm1, xmm0
  }
  if ( _CF | _ZF )
  {
LABEL_21:
    __asm { movsd   xmm6, [ebp+arg_8] }
  }
  else
  {
    __asm
    {
      comisd  xmm2, xmm3
      movsd   xmm6, [ebp+arg_8]
    }
    if ( !(_CF | _ZF) )
    {
      __asm
      {
        movsd   xmm0, [ebp+arg_28]
        comisd  xmm0, xmm3
      }
      if ( !(_CF | _ZF) )
      {
        __asm
        {
          movsd   xmm0, [ebp+arg_0]
          comisd  xmm0, xmm6
        }
        if ( !(_CF | _ZF) )
        {
          *(_DWORD *)(_ECX + 344) = 1;
LABEL_18:
          *(_DWORD *)(_ECX + 348) = result;
          *(_DWORD *)(_ECX + 352) = a9;
          result = a10;
          *(_DWORD *)(_ECX + 356) = a10;
          return result;
        }
      }
    }
  }
  if ( !result || result == 1 )
  {
    __asm
    {
      movsd   xmm1, qword ptr [ecx+88h]
      movsd   xmm0, qword ptr [ecx+138h]
      movsd   xmm5, qword ptr [ecx+80h]
      mulsd   xmm0, xmm1
      subsd   xmm7, xmm2
      mulsd   xmm0, xmm5
      comisd  xmm7, xmm0
    }
    if ( !(_CF | _ZF) )
    {
      __asm
      {
        movsd   xmm0, qword ptr [ecx+140h]
        subsd   xmm4, [ebp+arg_18]
        mulsd   xmm0, xmm1
        mulsd   xmm0, xmm5
        comisd  xmm4, xmm0
      }
      if ( !(_CF | _ZF) )
      {
        __asm { comisd  xmm3, xmm2 }
        if ( !(_CF | _ZF) )
        {
          __asm { comisd  xmm3, [ebp+arg_28] }
          if ( !(_CF | _ZF) )
          {
            __asm { comisd  xmm6, [ebp+arg_0] }
            if ( !(_CF | _ZF) )
            {
              *(_DWORD *)(_ECX + 344) = 2;
              goto LABEL_18;
            }
          }
        }
      }
    }
  }
  return result;
}

//----- (10020ED0) --------------------------------------------------------
char __fastcall sub_10020ED0(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8)
{
  char *v8; // ecx@1
  char *v9; // eax@3
  int v10; // edi@5
  int v11; // esi@5
  int v12; // ebx@8
  void *v13; // esi@10
  int v14; // eax@10
  void *v15; // ST00_4@10
  int v16; // ST04_4@10
  int v17; // ST08_4@10
  char v18; // bl@13
  char v20; // [sp-Ch] [bp-48h]@10
  int v21; // [sp-8h] [bp-44h]@10
  unsigned int v22; // [sp-4h] [bp-40h]@10
  int v23; // [sp+0h] [bp-3Ch]@10
  int v24; // [sp+4h] [bp-38h]@10
  signed int v25; // [sp+8h] [bp-34h]@10
  void *v26; // [sp+10h] [bp-2Ch]@10
  int v27; // [sp+20h] [bp-1Ch]@10
  unsigned int v28; // [sp+24h] [bp-18h]@10
  void *v29; // [sp+28h] [bp-14h]@1
  int v30; // [sp+38h] [bp-4h]@1

  v29 = (void *)a2;
  v30 = 0;
  v8 = (char *)&a3;
  if ( a8 >= 0x10 )
    v8 = (char *)a3;
  v9 = (char *)&a3;
  if ( a8 >= 0x10 )
    v9 = (char *)a3;
  v11 = (int)&v8[a7];
  v10 = (int)&a3;
  if ( a8 >= 0x10 )
    v10 = (int)a3;
  if ( v10 != v11 )
  {
    v12 = (int)&v9[-v10];
    do
    {
      *(_BYTE *)(v12 + v10) = sub_10030377(v12, v10, *(_BYTE *)v10);
      ++v10;
    }
    while ( v10 != v11 );
  }
  v28 = 15;
  v27 = 0;
  LOBYTE(v26) = 0;
  loc_1000AB40(&v26, &a3, 0, -1, v23, v24, v25);
  LOBYTE(v30) = 1;
  v25 = 15;
  v24 = 0;
  v20 = 0;
  loc_1000AB40(&v26, 0, -1, *(_DWORD *)&v20);
  v14 = sub_10021080((int)&unk_10074F28, (int)&word_10074F78, v15, v16, v17, *(int *)&v20, v21, v22);
  LOBYTE(v30) = 0;
  v13 = (void *)v14;
  if ( v28 >= 0x10 )
    sub_1002A4AA(v26);
  v28 = 15;
  v27 = 0;
  LOBYTE(v26) = 0;
  if ( v13 == &word_10074F78 )
  {
    v18 = 0;
  }
  else
  {
    sub_10021010(v29, v13);
    v18 = 1;
  }
  if ( a8 >= 0x10 )
    sub_1002A4AA(a3);
  return v18;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074F78: using guessed type __int16 word_10074F78;

//----- (10021010) --------------------------------------------------------
void *__thiscall sub_10021010(void *this, void *a2)
{
  _EDI = a2;
  _ESI = this;
  if ( this != a2 )
    loc_1000AB40(a2, 0, -1);
  __asm
  {
    movq    xmm0, qword ptr [edi+18h]
    movq    qword ptr [esi+18h], xmm0
    movq    xmm0, qword ptr [edi+20h]
    movq    qword ptr [esi+20h], xmm0
    movq    xmm0, qword ptr [edi+28h]
    movq    qword ptr [esi+28h], xmm0
    movq    xmm0, qword ptr [edi+30h]
    movq    qword ptr [esi+30h], xmm0
    movq    xmm0, qword ptr [edi+38h]
    movq    qword ptr [esi+38h], xmm0
    movq    xmm0, qword ptr [edi+40h]
    movq    qword ptr [esi+40h], xmm0
    movq    xmm0, qword ptr [edi+48h]
    movq    qword ptr [esi+48h], xmm0
  }
  return _ESI;
}

//----- (10021080) --------------------------------------------------------
int __fastcall sub_10021080(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8)
{
  int v8; // edi@1
  int i; // esi@1
  unsigned __int8 *v10; // eax@3

  v8 = a2;
  for ( i = a1; i != v8; i += 80 )
  {
    if ( *(_DWORD *)(i + 20) < 0x10u )
      v10 = (unsigned __int8 *)i;
    else
      v10 = *(unsigned __int8 **)i;
    if ( sub_10002C30((int)&a3, v10, a1, *(_DWORD *)(i + 16)) != -1 )
      break;
  }
  if ( a8 >= 0x10 )
    sub_1002A4AA(a3);
  return i;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100210D0) --------------------------------------------------------
int __thiscall sub_100210D0(void *this, int a2, char a3, int a4, int a5)
{
  char v9; // [sp-48h] [bp-50h]@1
  int v10; // [sp-44h] [bp-4Ch]@1
  int v11; // [sp-40h] [bp-48h]@1
  int v12; // [sp-3Ch] [bp-44h]@1
  int v13; // [sp-38h] [bp-40h]@1
  unsigned int v14; // [sp-34h] [bp-3Ch]@1
  char v15; // [sp-30h] [bp-38h]@1
  __int64 v16; // [sp-28h] [bp-30h]@1
  __int64 v17; // [sp-20h] [bp-28h]@1
  __int64 v18; // [sp-18h] [bp-20h]@1
  __int64 v19; // [sp-10h] [bp-18h]@1
  int v20; // [sp-8h] [bp-10h]@1
  int v21; // [sp-4h] [bp-Ch]@1

  _ESI = a2;
  v21 = a5;
  __asm { movq    xmm0, qword ptr [esi+18h] }
  v20 = a4;
  _EDI = (int)this;
  _EAX = &v15;
  __asm
  {
    movq    qword ptr [eax], xmm0
    movq    xmm0, qword ptr [esi+20h]
    movq    qword ptr [eax+8], xmm0
    movq    xmm0, qword ptr [esi+28h]
    movq    qword ptr [eax+10h], xmm0
    movq    xmm0, qword ptr [esi+30h]
    movq    qword ptr [eax+18h], xmm0
    movq    xmm0, qword ptr [esi+38h]
  }
  v14 = 15;
  v13 = 0;
  __asm { movq    qword ptr [eax+20h], xmm0 }
  v9 = 0;
  loc_1000AB40(a2, 0, -1);
  sub_1000B010(
    _EDI,
    word_10074F7C,
    a3,
    *(void **)&v9,
    v10,
    v11,
    v12,
    v13,
    v14,
    *(__int64 *)&v15,
    v16,
    v17,
    v18,
    v19,
    v20,
    v21);
  *(_DWORD *)_EDI = &off_1006727C;
  __asm
  {
    movq    xmm0, qword ptr [esi+40h]
    movq    qword ptr [edi+138h], xmm0
    movq    xmm0, qword ptr [esi+48h]
    movq    qword ptr [edi+140h], xmm0
  }
  return _EDI;
}
// 1006727C: using guessed type int (__stdcall *off_1006727C)(char);
// 10074F7C: using guessed type __int16 word_10074F7C;

//----- (10021170) --------------------------------------------------------
int __fastcall sub_10021170(int a1, char a2, char a3, void *a4, int a5, int a6, int a7, int a8, unsigned int a9, int a10, int a11)
{
  int v11; // edx@1
  char v12; // bl@1
  int v13; // edi@1
  int v14; // ecx@1
  signed int v15; // eax@2
  int v16; // eax@4
  int v17; // ecx@4
  void *v18; // esi@4
  int v19; // esi@5
  char v21; // [sp-1Ch] [bp-94h]@1
  void *v22; // [sp-18h] [bp-90h]@1
  int v23; // [sp-14h] [bp-8Ch]@1
  int v24; // [sp-10h] [bp-88h]@1
  int v25; // [sp-Ch] [bp-84h]@1
  int v26; // [sp-8h] [bp-80h]@1
  unsigned int v27; // [sp-4h] [bp-7Ch]@1
  int v28; // [sp+10h] [bp-68h]@4
  void *v29; // [sp+14h] [bp-64h]@1
  int v30; // [sp+24h] [bp-54h]@1
  unsigned int v31; // [sp+28h] [bp-50h]@1
  int v32; // [sp+4Ch] [bp-2Ch]@2
  char v33; // [sp+54h] [bp-24h]@4
  unsigned int v34; // [sp+64h] [bp-14h]@1
  int v35; // [sp+74h] [bp-4h]@1
  int v36; // [sp+78h] [bp+0h]@1

  v34 = (unsigned int)&v36 ^ __security_cookie;
  v27 = (unsigned int)&v36 ^ __security_cookie;
  v12 = a2;
  v13 = a1;
  v35 = 0;
  v31 = 15;
  v30 = 0;
  LOBYTE(v29) = 0;
  LOBYTE(v35) = 1;
  v26 = 15;
  v25 = 0;
  v21 = 0;
  loc_1000AB40(&a4, 0, -1, *(_DWORD *)&v21);
  if ( !sub_100213C0(v14, (int)&v29, v22, v23, v24, v25, v26, v27) )
    goto LABEL_14;
  v15 = v32;
  if ( !v12 )
    v15 = 15;
  v32 = v15;
  v33 = a3;
  v16 = sub_1002ADB1(v11, 15, v12, v13, 384);
  v18 = (void *)v16;
  v28 = v16;
  LOBYTE(v35) = 2;
  if ( v16 )
  {
    sub_1000BC10(v16, v17);
    v19 = sub_100210D0(v18, (int)&v29, v13, a10, a11);
  }
  else
  {
LABEL_14:
    v19 = 0;
  }
  if ( v31 >= 0x10 )
    sub_1002A4AA(v29);
  v31 = 15;
  v30 = 0;
  LOBYTE(v29) = 0;
  if ( a9 >= 0x10 )
    sub_1002A4AA(a4);
  return v19;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (100212A0) --------------------------------------------------------
char __thiscall sub_100212A0(int _ECX)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(_ECX + 8);
  if ( !v1 || !(*(_BYTE *)(v1 + 112) & 4) )
    return 0;
  if ( *(_BYTE *)(_ECX + 312) )
  {
    __asm
    {
      movsd   xmm0, qword ptr [ecx+170h]
      comisd  xmm0, qword ptr [ecx+178h]
    }
    if ( _CF | _ZF )
      return 0;
  }
  else
  {
    __asm
    {
      movsd   xmm1, qword ptr [ecx+168h]
      movsd   xmm0, qword ptr [ecx+148h]
      comisd  xmm0, xmm1
    }
    if ( _CF | _ZF )
      return 0;
    __asm { comisd  xmm1, qword ptr [ecx+160h] }
    if ( _CF | _ZF )
      return 0;
    __asm
    {
      movsd   xmm0, qword ptr [ecx+140h]
      mulsd   xmm0, qword ptr [ecx+88h]
      movsd   xmm1, qword ptr [ecx+158h]
      subsd   xmm1, qword ptr [ecx+150h]
      mulsd   xmm0, qword ptr [ecx+80h]
      comisd  xmm1, xmm0
    }
    if ( _CF | _ZF )
      return 0;
  }
  return 1;
}

//----- (10021330) --------------------------------------------------------
char __thiscall sub_10021330(int _ECX)
{
  int v1; // eax@1

  v1 = *(_DWORD *)(_ECX + 8);
  if ( !v1 || !(*(_BYTE *)(v1 + 112) & 4) )
    return 0;
  if ( *(_BYTE *)(_ECX + 312) )
  {
    __asm
    {
      movsd   xmm0, qword ptr [ecx+178h]
      comisd  xmm0, qword ptr [ecx+170h]
    }
    if ( _CF | _ZF )
      return 0;
  }
  else
  {
    __asm
    {
      movsd   xmm1, qword ptr [ecx+168h]
      comisd  xmm1, qword ptr [ecx+148h]
    }
    if ( _CF | _ZF )
      return 0;
    __asm
    {
      movsd   xmm0, qword ptr [ecx+160h]
      comisd  xmm0, xmm1
    }
    if ( _CF | _ZF )
      return 0;
    __asm
    {
      movsd   xmm0, qword ptr [ecx+140h]
      mulsd   xmm0, qword ptr [ecx+88h]
      movsd   xmm1, qword ptr [ecx+150h]
      subsd   xmm1, qword ptr [ecx+158h]
      mulsd   xmm0, qword ptr [ecx+80h]
      comisd  xmm1, xmm0
    }
    if ( _CF | _ZF )
      return 0;
  }
  return 1;
}

//----- (100213C0) --------------------------------------------------------
char __fastcall sub_100213C0(int a1, int a2, void *a3, int a4, int a5, int a6, int a7, unsigned int a8)
{
  char *v8; // ecx@1
  char *v9; // eax@3
  int v10; // edi@5
  int v11; // esi@5
  int v12; // ebx@8
  void *v13; // esi@10
  int v14; // eax@10
  void *v15; // ST00_4@10
  int v16; // ST04_4@10
  int v17; // ST08_4@10
  char v18; // bl@13
  char v20; // [sp-Ch] [bp-48h]@10
  int v21; // [sp-8h] [bp-44h]@10
  unsigned int v22; // [sp-4h] [bp-40h]@10
  int v23; // [sp+0h] [bp-3Ch]@10
  int v24; // [sp+4h] [bp-38h]@10
  signed int v25; // [sp+8h] [bp-34h]@10
  void *v26; // [sp+10h] [bp-2Ch]@10
  int v27; // [sp+20h] [bp-1Ch]@10
  unsigned int v28; // [sp+24h] [bp-18h]@10
  void *v29; // [sp+28h] [bp-14h]@1
  int v30; // [sp+38h] [bp-4h]@1

  v29 = (void *)a2;
  v30 = 0;
  v8 = (char *)&a3;
  if ( a8 >= 0x10 )
    v8 = (char *)a3;
  v9 = (char *)&a3;
  if ( a8 >= 0x10 )
    v9 = (char *)a3;
  v11 = (int)&v8[a7];
  v10 = (int)&a3;
  if ( a8 >= 0x10 )
    v10 = (int)a3;
  if ( v10 != v11 )
  {
    v12 = (int)&v9[-v10];
    do
    {
      *(_BYTE *)(v12 + v10) = sub_10030377(v12, v10, *(_BYTE *)v10);
      ++v10;
    }
    while ( v10 != v11 );
  }
  v28 = 15;
  v27 = 0;
  LOBYTE(v26) = 0;
  loc_1000AB40(&v26, &a3, 0, -1, v23, v24, v25);
  LOBYTE(v30) = 1;
  v25 = 15;
  v24 = 0;
  v20 = 0;
  loc_1000AB40(&v26, 0, -1, *(_DWORD *)&v20);
  v14 = sub_10021080((int)&unk_10074F80, (int)&dword_10074FD0, v15, v16, v17, *(int *)&v20, v21, v22);
  LOBYTE(v30) = 0;
  v13 = (void *)v14;
  if ( v28 >= 0x10 )
    sub_1002A4AA(v26);
  v28 = 15;
  v27 = 0;
  LOBYTE(v26) = 0;
  if ( v13 == &dword_10074FD0 )
  {
    v18 = 0;
  }
  else
  {
    sub_10021010(v29, v13);
    v18 = 1;
  }
  if ( a8 >= 0x10 )
    sub_1002A4AA(a3);
  return v18;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074FD0: using guessed type int dword_10074FD0;

//----- (10021500) --------------------------------------------------------
int *__usercall sub_10021500<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // edx@7
  int v3; // ecx@7
  int v4; // ST00_4@7
  _UNKNOWN *v6; // [sp-4h] [bp-38h]@4
  int v7; // [sp-4h] [bp-38h]@7
  void **v8; // [sp+4h] [bp-30h]@1
  void (__userpurge *v9)(int<ecx>, int<ebx>, int); // [sp+8h] [bp-2Ch]@1
  int *v10; // [sp+Ch] [bp-28h]@1
  int *v11; // [sp+14h] [bp-20h]@1
  int v12; // [sp+1Ch] [bp-18h]@1
  int *v13; // [sp+20h] [bp-14h]@1
  int *v14; // [sp+24h] [bp-10h]@1
  int v15; // [sp+30h] [bp-4h]@1

  v14 = &dword_10076558;
  dword_1007656C = 15;
  dword_10076568 = 0;
  LOBYTE(dword_10076558) = 0;
  v15 = 0;
  dword_10076584 = 15;
  dword_10076580 = 0;
  LOBYTE(dword_10076570) = 0;
  dword_1007659C = 15;
  dword_10076598 = 0;
  LOBYTE(dword_10076588) = 0;
  __asm
  {
    movsd   xmm0, ds:qword_10068540
    movsd   qword_100765A8, xmm0
  }
  dword_100765C4 = 15;
  dword_100765C0 = 0;
  LOBYTE(dword_100765B0) = 0;
  dword_100765C8 = 0;
  dword_100765D0 = 3600000;
  qword_100765D8 = -9223372036854775808i64;
  dword_100765E0 = 60;
  dword_100765F8 = 15;
  dword_100765F4 = 0;
  LOBYTE(dword_100765E4) = 0;
  dword_100765FC = 0;
  dword_10076600 = 0;
  dword_10076604 = 0;
  dword_10076608 = 0;
  dword_1007660C = 60;
  dword_10076624 = 15;
  dword_10076620 = 0;
  LOBYTE(dword_10076610) = 0;
  dword_10076628 = 0;
  dword_1007662C = 0;
  dword_10076630 = 0;
  dword_10076634 = 0;
  dword_10076638 = 0;
  dword_1007663C = 0;
  dword_10076640 = 0;
  dword_10076644 = 0;
  dword_10076648 = 0;
  dword_1007664C = 0;
  dword_10076650 = 0;
  v8 = &off_10067F84;
  v9 = sub_10021F90;
  v10 = &dword_10076558;
  v11 = (int *)&v8;
  LOBYTE(v15) = 9;
  v13 = &dword_10076658;
  sub_10024D60((int)&dword_10076658, a1);
  dword_10076658 = (int)&off_100683A4;
  v12 = (int)&unk_10076750;
  LOBYTE(v15) = 11;
  if ( v11 )
  {
    if ( (void ***)v11 == &v8 )
      v6 = &unk_10076750;
    else
      v6 = 0;
    dword_10076760 = (*(int (__stdcall **)(int))*v11)(v7);
  }
  else
  {
    dword_10076760 = 0;
  }
  LOBYTE(v15) = 12;
  sub_10024E30((int)&dword_10076658, v4, v7);
  sub_10024ED0((int)&dword_10076658);
  LOBYTE(v15) = 14;
  v3 = (int)v11;
  if ( v11 )
    (*(void (__stdcall **)(bool))(*v11 + 16))((void ***)v11 != &v8);
  dword_10076768 = 0;
  LOBYTE(v15) = 15;
  dword_1007676C = 0;
  dword_10076770 = 0;
  sub_10006BC0(v2, (int)&dword_1007676C, a2, v3);
  LOBYTE(v15) = 16;
  sub_1002B607((int)&unk_10076774);
  LOBYTE(v15) = 17;
  sub_1002B5CC((int)&unk_1007679C);
  LOBYTE(v15) = 18;
  sub_1002B5CC((int)&unk_100767BC);
  return &dword_10076558;
}
// 10067F84: using guessed type void *off_10067F84;
// 100683A4: using guessed type int (__stdcall *off_100683A4)(char);
// 10076558: using guessed type int dword_10076558;
// 10076568: using guessed type int dword_10076568;
// 1007656C: using guessed type int dword_1007656C;
// 10076570: using guessed type int dword_10076570;
// 10076580: using guessed type int dword_10076580;
// 10076584: using guessed type int dword_10076584;
// 10076588: using guessed type int dword_10076588;
// 10076598: using guessed type int dword_10076598;
// 1007659C: using guessed type int dword_1007659C;
// 100765B0: using guessed type int dword_100765B0;
// 100765C0: using guessed type int dword_100765C0;
// 100765C4: using guessed type int dword_100765C4;
// 100765C8: using guessed type int dword_100765C8;
// 100765D0: using guessed type int dword_100765D0;
// 100765D8: using guessed type __int64 qword_100765D8;
// 100765E0: using guessed type int dword_100765E0;
// 100765E4: using guessed type int dword_100765E4;
// 100765F4: using guessed type int dword_100765F4;
// 100765F8: using guessed type int dword_100765F8;
// 100765FC: using guessed type int dword_100765FC;
// 10076600: using guessed type int dword_10076600;
// 10076604: using guessed type int dword_10076604;
// 10076608: using guessed type int dword_10076608;
// 1007660C: using guessed type int dword_1007660C;
// 10076610: using guessed type int dword_10076610;
// 10076620: using guessed type int dword_10076620;
// 10076624: using guessed type int dword_10076624;
// 10076628: using guessed type int dword_10076628;
// 1007662C: using guessed type int dword_1007662C;
// 10076630: using guessed type int dword_10076630;
// 10076634: using guessed type int dword_10076634;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;
// 10076640: using guessed type int dword_10076640;
// 10076644: using guessed type int dword_10076644;
// 10076648: using guessed type int dword_10076648;
// 1007664C: using guessed type int dword_1007664C;
// 10076650: using guessed type int dword_10076650;
// 10076658: using guessed type int dword_10076658;
// 10076760: using guessed type int dword_10076760;
// 10076768: using guessed type int dword_10076768;
// 1007676C: using guessed type int dword_1007676C;
// 10076770: using guessed type int dword_10076770;

//----- (100217D0) --------------------------------------------------------
int __usercall sub_100217D0<eax>(int a1<ebx>)
{
  int v1; // ecx@4
  int v2; // esi@7
  int result; // eax@17
  char v18; // [sp+Ch] [bp-1Ch]@5
  int *v19; // [sp+18h] [bp-10h]@1
  int v20; // [sp+24h] [bp-4h]@1

  v19 = &dword_10076558;
  v20 = 13;
  if ( dword_10076768 )
  {
    (**(void (__stdcall ***)(_DWORD))dword_10076768)(1);
    dword_10076768 = 0;
  }
  if ( dword_10076650 )
  {
    v1 = dword_1007676C;
    if ( !dword_1007676C )
    {
      sub_1002FFB9((int)&v18, (unsigned int)"wait() cannot be called on a default constructed task.");
      sub_100355BB((int)&v18, (int)&unk_1006C878);
    }
    sub_10009F10(v1, a1);
  }
  LOBYTE(v20) = 12;
  nullsub_2(&unk_100767BC);
  LOBYTE(v20) = 11;
  nullsub_2(&unk_1007679C);
  LOBYTE(v20) = 10;
  nullsub_2(&unk_10076774);
  LOBYTE(v20) = 9;
  v2 = dword_10076770;
  if ( dword_10076770 )
  {
    _EDI = -1;
    _ECX = dword_10076770 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v2)(v2);
      _EAX = v2 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 4))(v2);
    }
  }
  LOBYTE(v20) = 8;
  if ( dword_10076768 )
    (**(void (__stdcall ***)(_DWORD))dword_10076768)(1);
  LOBYTE(v20) = 7;
  sub_100230C0((int)&dword_10076658, a1);
  sub_10024BC0((int)&dword_10076644);
  sub_10024B00((int)&dword_10076638);
  if ( dword_10076628 )
  {
    sub_1002A4AA((LPVOID)dword_10076628);
    dword_10076628 = 0;
    dword_1007662C = 0;
    dword_10076630 = 0;
  }
  if ( (unsigned int)dword_10076624 >= 0x10 )
    sub_1002A4AA((LPVOID)dword_10076610);
  result = dword_100765FC;
  dword_10076624 = 15;
  dword_10076620 = 0;
  LOBYTE(dword_10076610) = 0;
  if ( dword_100765FC )
  {
    result = sub_1002A4AA((LPVOID)dword_100765FC);
    dword_100765FC = 0;
    dword_10076600 = 0;
    dword_10076604 = 0;
  }
  if ( (unsigned int)dword_100765F8 >= 0x10 )
    result = sub_1002A4AA((LPVOID)dword_100765E4);
  dword_100765F8 = 15;
  dword_100765F4 = 0;
  LOBYTE(dword_100765E4) = 0;
  if ( (unsigned int)dword_100765C4 >= 0x10 )
    result = sub_1002A4AA((LPVOID)dword_100765B0);
  dword_100765C4 = 15;
  dword_100765C0 = 0;
  LOBYTE(dword_100765B0) = 0;
  if ( (unsigned int)dword_1007659C >= 0x10 )
    result = sub_1002A4AA((LPVOID)dword_10076588);
  dword_1007659C = 15;
  dword_10076598 = 0;
  LOBYTE(dword_10076588) = 0;
  if ( (unsigned int)dword_10076584 >= 0x10 )
    result = sub_1002A4AA((LPVOID)dword_10076570);
  dword_10076584 = 15;
  dword_10076580 = 0;
  LOBYTE(dword_10076570) = 0;
  if ( (unsigned int)dword_1007656C >= 0x10 )
    result = sub_1002A4AA((LPVOID)dword_10076558);
  dword_1007656C = 15;
  dword_10076568 = 0;
  LOBYTE(dword_10076558) = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1002C171: using guessed type int __thiscall nullsub_2(_DWORD);
// 10076558: using guessed type int dword_10076558;
// 10076568: using guessed type int dword_10076568;
// 1007656C: using guessed type int dword_1007656C;
// 10076570: using guessed type int dword_10076570;
// 10076580: using guessed type int dword_10076580;
// 10076584: using guessed type int dword_10076584;
// 10076588: using guessed type int dword_10076588;
// 10076598: using guessed type int dword_10076598;
// 1007659C: using guessed type int dword_1007659C;
// 100765B0: using guessed type int dword_100765B0;
// 100765C0: using guessed type int dword_100765C0;
// 100765C4: using guessed type int dword_100765C4;
// 100765E4: using guessed type int dword_100765E4;
// 100765F4: using guessed type int dword_100765F4;
// 100765F8: using guessed type int dword_100765F8;
// 100765FC: using guessed type int dword_100765FC;
// 10076600: using guessed type int dword_10076600;
// 10076604: using guessed type int dword_10076604;
// 10076610: using guessed type int dword_10076610;
// 10076620: using guessed type int dword_10076620;
// 10076624: using guessed type int dword_10076624;
// 10076628: using guessed type int dword_10076628;
// 1007662C: using guessed type int dword_1007662C;
// 10076630: using guessed type int dword_10076630;
// 10076638: using guessed type int dword_10076638;
// 10076644: using guessed type int dword_10076644;
// 10076650: using guessed type int dword_10076650;
// 10076658: using guessed type int dword_10076658;
// 10076768: using guessed type int dword_10076768;
// 1007676C: using guessed type int dword_1007676C;
// 10076770: using guessed type int dword_10076770;

//----- (10021A90) --------------------------------------------------------
void __stdcall sub_10021A90(int a1, int a2, void *a3, int a4, int a5, int a6, unsigned int a7, signed int a8, void *a9, int a10, int a11, int a12, int a13, signed int a14, void *a15, int a16, int a17, int a18, unsigned int a19, unsigned int a20)
{
  int v20; // edx@1
  int ebp0; // ebp@0
  int v22; // edi@1
  unsigned int v23; // esi@1
  int v24; // ecx@3
  unsigned int v25; // eax@5
  char v26; // zf@7
  int v27; // eax@7
  bool v28; // eax@9
  int v29; // edx@13
  int v30; // edi@13
  unsigned int v31; // esi@13
  int v32; // ecx@15
  unsigned int v33; // eax@17
  char v34; // zf@19
  int v35; // eax@19
  bool v36; // eax@21
  unsigned int v37; // [sp-4h] [bp-40h]@1
  int v38; // [sp+Ch] [bp-30h]@30
  unsigned int v39; // [sp+2Ch] [bp-10h]@1
  int v40; // [sp+38h] [bp-4h]@1
  int v41; // [sp+3Ch] [bp+0h]@1

  v39 = (unsigned int)&v41 ^ __security_cookie;
  v37 = (unsigned int)&v41 ^ __security_cookie;
  v40 = 2;
  sub_1002B62D(ebp0, (int)&unk_1007679C);
  LOBYTE(v40) = 3;
  v23 = a19;
  v22 = dword_10076568;
  v20 = (int)&a15;
  if ( a20 >= 0x10 )
    v20 = (int)a15;
  v24 = (int)&dword_10076558;
  if ( (unsigned int)dword_1007656C >= 0x10 )
    v24 = dword_10076558;
  v25 = a19;
  if ( dword_10076568 < a19 )
    v25 = dword_10076568;
  v27 = sub_100099E0(v24, v20, v25);
  v26 = v27 == 0;
  if ( !v27 )
  {
    if ( v22 >= v23 )
      v28 = v22 != v23;
    else
      v28 = -1;
    v26 = v28 == 0;
  }
  if ( !v26 )
    goto LABEL_39;
  v31 = a7;
  v30 = dword_10076580;
  v29 = (int)&a3;
  if ( (unsigned int)a8 >= 0x10 )
    v29 = (int)a3;
  v32 = (int)&dword_10076570;
  if ( (unsigned int)dword_10076584 >= 0x10 )
    v32 = dword_10076570;
  v33 = a7;
  if ( dword_10076580 < a7 )
    v33 = dword_10076580;
  v35 = sub_100099E0(v32, v29, v33);
  v34 = v35 == 0;
  if ( !v35 )
  {
    if ( v30 >= v31 )
      v36 = v30 != v31;
    else
      v36 = -1;
    v34 = v36 == 0;
  }
  if ( v34
    && sub_100036A0((int)&dword_10076588, (int)&a9)
    && dword_100765A0 == a1
    && dword_100765A4 == a2
    && dword_100765C8 & 1 )
  {
    LOBYTE(v40) = 2;
    sub_1002B6D6();
  }
  else
  {
LABEL_39:
    loc_1000AB40(&dword_10076558, &a15, 0, -1, v37);
    loc_1000AB40(&dword_10076570, &a3, 0, -1);
    loc_1000AB40(&dword_10076588, &a9, 0, -1);
    dword_100765A0 = a1;
    dword_100765A4 = a2;
    LOBYTE(v40) = 2;
    sub_1002B6D6();
    v38 = 1;
    sub_10026770((int)&v38, (int)&dword_10076658, a2);
  }
  if ( (unsigned int)a8 >= 0x10 )
    sub_1002A4AA(a3);
  a8 = 15;
  a7 = 0;
  LOBYTE(a3) = 0;
  if ( (unsigned int)a14 >= 0x10 )
    sub_1002A4AA(a9);
  a14 = 15;
  a13 = 0;
  LOBYTE(a9) = 0;
  if ( a20 >= 0x10 )
    sub_1002A4AA(a15);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;
// 10076558: using guessed type int dword_10076558;
// 10076568: using guessed type int dword_10076568;
// 1007656C: using guessed type int dword_1007656C;
// 10076570: using guessed type int dword_10076570;
// 10076580: using guessed type int dword_10076580;
// 10076584: using guessed type int dword_10076584;
// 10076588: using guessed type int dword_10076588;
// 100765A0: using guessed type int dword_100765A0;
// 100765A4: using guessed type int dword_100765A4;
// 100765C8: using guessed type int dword_100765C8;
// 10076658: using guessed type int dword_10076658;

//----- (10021CA0) --------------------------------------------------------
void __thiscall sub_10021CA0(void *this, void *a2, int a3, int a4, int a5, int a6, unsigned int a7)
{
  int ebp0; // ebp@0

  __asm { movsd   [ebp+var_34], xmm1 }
  _ESI = this;
  sub_1002B62D(ebp0, (int)((char *)this + 580));
  __asm
  {
    movsd   xmm0, [ebp+var_34]
    comisd  xmm0, ds:qword_10068450
  }
  if ( !(_CF | _ZF) )
    __asm { movsd   qword ptr [esi+50h], xmm0 }
  if ( a6 )
  {
    if ( (void **)((char *)_ESI + 88) != &a2 )
      loc_1000AB40((char *)_ESI + 88, &a2, 0, -1);
  }
  sub_1002B6D6();
  if ( a7 >= 0x10 )
    sub_1002A4AA(a2);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10021D60) --------------------------------------------------------
int __userpurge sub_10021D60<eax>(int a1<ebx>, char a2)
{
  int ebp0; // ebp@0
  int v3; // ecx@4
  char v5; // [sp+0h] [bp-38h]@5
  unsigned int v6; // [sp+28h] [bp-10h]@1
  int v7; // [sp+34h] [bp-4h]@4
  int v8; // [sp+38h] [bp+0h]@1

  v6 = (unsigned int)&v8 ^ __security_cookie;
  if ( !a2 && dword_10076650 || dword_10076650 == 1 )
  {
    sub_1002B62D(ebp0, (int)&unk_1007679C);
    v7 = 0;
    v3 = dword_1007676C;
    if ( !dword_1007676C )
    {
      sub_1002FFB9((int)&v5, (unsigned int)"wait() cannot be called on a default constructed task.");
      sub_100355BB((int)&v5, (int)&unk_1006C878);
    }
    sub_10009F10(v3, a1);
    v7 = -1;
    sub_1002B6D6();
  }
  return dword_100765C8;
}
// 10073200: using guessed type int __security_cookie;
// 100765C8: using guessed type int dword_100765C8;
// 10076650: using guessed type int dword_10076650;
// 1007676C: using guessed type int dword_1007676C;

//----- (10021E10) --------------------------------------------------------
int __userpurge sub_10021E10<eax>(int a1<ebx>, unsigned int a2)
{
  int v2; // esi@3
  char v4; // [sp+4h] [bp-14h]@1
  unsigned int v5; // [sp+8h] [bp-10h]@1
  int v6; // [sp+14h] [bp-4h]@5
  int v7; // [sp+18h] [bp+0h]@1

  v5 = (unsigned int)&v7 ^ __security_cookie;
  sub_1002B6B7((int)&v4, a1, (int)&unk_10076774);
  if ( (signed int)a2 < 0 || a2 >= (dword_1007663C - dword_10076638) >> 2 )
    v2 = 0;
  else
    v2 = *(_DWORD *)(dword_10076638 + 4 * a2);
  v6 = -1;
  sub_1002B6E4(&v4);
  return v2;
}
// 10073200: using guessed type int __security_cookie;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (10021EA0) --------------------------------------------------------
int __stdcall sub_10021EA0(int a1)
{
  int ebp0; // ebp@0
  int i; // esi@1
  int v3; // ecx@5
  int v4; // esi@9
  int v6; // [sp+8h] [bp-30h]@10
  char v7; // [sp+Ch] [bp-2Ch]@13
  unsigned int v8; // [sp+28h] [bp-10h]@1
  int v9; // [sp+34h] [bp-4h]@1
  int v10; // [sp+38h] [bp+0h]@1

  v8 = (unsigned int)&v10 ^ __security_cookie;
  sub_1002B672(ebp0, (int)&unk_10076774);
  v9 = 0;
  for ( i = dword_10076638; i != dword_1007663C; i += 4 )
  {
    if ( !*(_DWORD *)i )
      break;
  }
  *(_DWORD *)(a1 + 8) = &dword_10076558;
  if ( i == dword_1007663C )
  {
    v6 = a1;
    LOBYTE(v9) = 1;
    sub_10022F30((int)&dword_10076638, &v6);
    LOBYTE(v9) = 0;
    if ( v6 )
      (**(void (__stdcall ***)(_DWORD))v6)(1);
    v4 = ((dword_1007663C - dword_10076638) >> 2) - 1;
  }
  else
  {
    v3 = *(_DWORD *)i;
    if ( a1 != *(_DWORD *)i )
    {
      if ( v3 )
        (**(void (__stdcall ***)(_DWORD))v3)(1);
      *(_DWORD *)i = a1;
    }
    v4 = (i - dword_10076638) >> 2;
  }
  v9 = -1;
  sub_1002B6E4(&v7);
  return v4;
}
// 10073200: using guessed type int __security_cookie;
// 10076558: using guessed type int dword_10076558;
// 10076638: using guessed type int dword_10076638;
// 1007663C: using guessed type int dword_1007663C;

//----- (10021F90) --------------------------------------------------------
void __userpurge sub_10021F90(int a1<ecx>, int a2<ebx>, int a3)
{
  int ebp0; // ebp@0
  int v4; // esi@1
  int v5; // ecx@2
  int v6; // eax@5
  int v7; // eax@5
  int v8; // edx@5
  int v10; // esi@7
  int v25; // esi@11
  int v39; // [sp+Ch] [bp-48h]@1
  char v40; // [sp+10h] [bp-44h]@3
  int v41; // [sp+14h] [bp-40h]@11
  char v42; // [sp+1Ch] [bp-38h]@5
  int v43; // [sp+20h] [bp-34h]@7
  unsigned int v44; // [sp+40h] [bp-14h]@1
  int v45; // [sp+50h] [bp-4h]@1

  v44 = (unsigned int)&v39 ^ __security_cookie;
  v4 = a1;
  sub_1002B62D(ebp0, a1 + 580);
  v45 = 0;
  if ( *(_DWORD *)(v4 + 248) )
  {
    v5 = *(_DWORD *)(v4 + 532);
    if ( !v5 )
    {
      sub_1002FFB9((int)&v40, (unsigned int)"wait() cannot be called on a default constructed task.");
      sub_100355BB((int)&v40, (int)&unk_1006C878);
    }
    sub_10009F10(v5, a2);
  }
  *(_DWORD *)(v4 + 248) = a3;
  v7 = sub_10022280((void *)v4, (int)&v40);
  LOBYTE(v45) = 1;
  v39 = v4;
  v6 = sub_10025F80(v7, v8, (int)&v42, (int)&v39);
  if ( v4 + 532 != v6 )
    sub_1000A010((void *)(v4 + 532), v6);
  v10 = v43;
  _EDI = -1;
  if ( v43 )
  {
    _EAX = v43 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v10)(v10);
      _EAX = v10 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v10 + 4))(v10, _EDX);
    }
  }
  LOBYTE(v45) = 0;
  v25 = v41;
  if ( v41 )
  {
    _EAX = v41 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v25)(v25);
      _EAX = v25 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v25 + 4))(v25);
    }
  }
  v45 = -1;
  sub_1002B6D6();
}
// 10073200: using guessed type int __security_cookie;

//----- (100220F0) --------------------------------------------------------
BOOL __userpurge sub_100220F0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // eax@2
  int v9; // ST0C_4@2
  int v10; // edi@2
  int v11; // edx@2
  int v12; // ST08_4@2
  int v13; // ST0C_4@2
  int v14; // ST10_4@2
  int v15; // ecx@4
  int v16; // esi@4
  BOOL result; // eax@8
  int v18; // ecx@8
  int v19; // [sp+14h] [bp-14h]@1
  int v20; // [sp+18h] [bp-10h]@2
  int v21; // [sp+24h] [bp-4h]@1

  v7 = a2;
  v19 = a2;
  v4 = sub_1002ADB1(a1, a2, a3, a2, 264);
  v6 = v4;
  v21 = 0;
  if ( v4 )
  {
    sub_100221F0(v4, v5);
    v8 = *(_DWORD *)v7;
    v9 = *(_DWORD *)(*(_DWORD *)v7 + 120);
    v20 = 2;
    v10 = v8 + 256;
    sub_1003119C(v6, v9, 0);
    sub_10025510(v11, v6 + 16, v6);
    LOBYTE(v21) = 2;
    *(_DWORD *)v6 = &off_100681E0;
    *(_DWORD *)(v6 + 16) = &off_10068188;
    sub_10025470(v6, (int)&v20, v10, v12, v13, v14);
    v7 = v19;
  }
  else
  {
    v6 = 0;
  }
  v21 = -1;
  v16 = *(_DWORD *)v7;
  v15 = *(_DWORD *)(*(_DWORD *)v7 + 528);
  if ( v6 != v15 )
  {
    if ( v15 )
      (**(void (__stdcall ***)(_DWORD))v15)(1);
    *(_DWORD *)(v16 + 528) = v6;
  }
  v18 = *(_DWORD *)(*(_DWORD *)v7 + 528);
  result = *(_DWORD *)(v18 + 244);
  if ( !result || result == 2 )
  {
    *(_DWORD *)(v18 + 244) = 1;
    result = sub_100311FA((char *)v18);
  }
  return result;
}
// 10068188: using guessed type int (*off_10068188)();
// 100681E0: using guessed type int (__stdcall *off_100681E0)(char);

//----- (100221F0) --------------------------------------------------------
void __thiscall sub_100221F0(int this, int a2)
{
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 88) = 0;
  *(_DWORD *)(this + 92) = 0;
  *(_DWORD *)(this + 100) = 0;
  *(_DWORD *)(this + 104) = 0;
  *(_DWORD *)(this + 136) = 0;
  *(_DWORD *)(this + 160) = 0;
  *(_DWORD *)(this + 184) = 0;
  *(_DWORD *)(this + 216) = 0;
  *(_DWORD *)(this + 220) = 0;
  *(_DWORD *)(this + 240) = 0;
  *(_DWORD *)(this + 256) = 0;
}

//----- (10022280) --------------------------------------------------------
int __thiscall sub_10022280(void *this, int a2)
{
  int *v2; // ecx@1
  int *v4; // ecx@3
  int v5; // eax@3
  int v6; // edx@3
  int v7; // edx@3
  int v8; // eax@5
  int v9; // edx@5
  int v10; // edx@5
  char v11; // cf@5
  int v12; // ecx@6
  int v13; // edx@8
  int v14; // ecx@8
  int v15; // eax@8
  int v16; // edx@8
  int v17; // edx@8
  char v18; // cf@8
  int v19; // edx@10
  int v20; // ecx@10
  int v21; // eax@10
  int v22; // edx@10
  int v23; // edx@10
  char v24; // cf@10
  __int64 v25; // qax@12
  int v26; // eax@12
  int v27; // edx@12
  int v28; // edx@12
  __int64 v29; // qax@12
  int v30; // eax@12
  int v31; // edx@12
  __int64 v32; // qax@12
  int v37; // edx@15
  int v38; // ecx@15
  char v39; // cf@15
  int v40; // edx@17
  int v41; // esi@18
  int v42; // eax@18
  int v43; // edx@18
  int v44; // edx@18
  int v45; // edx@18
  __int16 v61; // [sp-28h] [bp-90h]@18
  int v62; // [sp-24h] [bp-8Ch]@18
  int v63; // [sp-20h] [bp-88h]@18
  int v64; // [sp-1Ch] [bp-84h]@18
  int v65; // [sp-18h] [bp-80h]@18
  signed int v66; // [sp-14h] [bp-7Ch]@18
  char v67; // [sp-10h] [bp-78h]@18
  int v68; // [sp-Ch] [bp-74h]@3
  unsigned int v69; // [sp-4h] [bp-6Ch]@1
  int v70; // [sp+Ch] [bp-5Ch]@18
  DWORD v71; // [sp+14h] [bp-54h]@18
  int v72; // [sp+18h] [bp-50h]@18
  int v73; // [sp+1Ch] [bp-4Ch]@1
  char *v74; // [sp+20h] [bp-48h]@18
  int v75; // [sp+28h] [bp-40h]@1
  int v76; // [sp+2Ch] [bp-3Ch]@18
  int v77; // [sp+30h] [bp-38h]@18
  char v78; // [sp+34h] [bp-34h]@3
  int v79; // [sp+3Ch] [bp-2Ch]@1
  int v80; // [sp+40h] [bp-28h]@1
  __int64 v81; // [sp+44h] [bp-24h]@3
  int v82; // [sp+4Ch] [bp-1Ch]@3
  int v83; // [sp+50h] [bp-18h]@3
  unsigned int v84; // [sp+54h] [bp-14h]@1
  int v85; // [sp+64h] [bp-4h]@1
  int v86; // [sp+68h] [bp+0h]@1

  v84 = (unsigned int)&v86 ^ __security_cookie;
  v69 = (unsigned int)&v86 ^ __security_cookie;
  _ESI = (int)this;
  v75 = 0;
  v79 &= 0xFFFFFE00u;
  v73 = a2;
  v80 = 0;
  v85 = 2;
  v2 = &dword_10074FD0;
  if ( (unsigned int)dword_10074FE4 >= 0x10 )
    v2 = (int *)dword_10074FD0;
  v82 = v82 & 0xFFFFFF04 | 0x104;
  v83 = 0;
  LODWORD(v81) = loc_1000FED0(v2, dword_10074FE0, v69);
  LOBYTE(v85) = 3;
  v5 = sub_10010C90((int)&v78, v6, (int)"name", v68);
  sub_10010260(v5, v7, (int)&v81);
  LOBYTE(v85) = 2;
  sub_100101D0((int)&v81, a2);
  v4 = &dword_10075000;
  if ( (unsigned int)dword_10075014 >= 0x10 )
    v4 = (int *)dword_10075000;
  v82 = v82 & 0xFFFFFF04 | 0x104;
  v83 = 0;
  LODWORD(v81) = loc_1000FED0(v4, dword_10075010);
  LOBYTE(v85) = 4;
  v8 = sub_10010C90((int)&v78, v9, (int)"version", v68);
  sub_10010260(v8, v10, (int)&v81);
  LOBYTE(v85) = 2;
  sub_100101D0((int)&v81, a2);
  v11 = *(_DWORD *)(_ESI + 20) < 0x10u;
  v82 = v82 & 0xFFFFFF04 | 0x104;
  v83 = 0;
  if ( v11 )
    v12 = _ESI;
  else
    v12 = *(_DWORD *)_ESI;
  LODWORD(v81) = loc_1000FED0(v12, *(_DWORD *)(_ESI + 16));
  LOBYTE(v85) = 5;
  v15 = sub_10010C90((int)&v78, v16, (int)"code", v68);
  sub_10010260(v15, v17, (int)&v81);
  LOBYTE(v85) = 2;
  sub_100101D0((int)&v81, a2);
  v13 = *(_DWORD *)(_ESI + 40);
  v14 = _ESI + 24;
  v18 = *(_DWORD *)(_ESI + 44) < 0x10u;
  v82 = v82 & 0xFFFFFF04 | 0x104;
  v83 = 0;
  if ( !v18 )
    v14 = *(_DWORD *)v14;
  LODWORD(v81) = loc_1000FED0(v14, v13);
  LOBYTE(v85) = 6;
  v21 = sub_10010C90((int)&v78, v22, (int)"broker", v68);
  sub_10010260(v21, v23, (int)&v81);
  LOBYTE(v85) = 2;
  sub_100101D0((int)&v81, a2);
  v19 = *(_DWORD *)(_ESI + 64);
  v20 = _ESI + 48;
  v24 = *(_DWORD *)(_ESI + 68) < 0x10u;
  v82 = v82 & 0xFFFFFF04 | 0x104;
  v83 = 0;
  if ( !v24 )
    v20 = *(_DWORD *)v20;
  LODWORD(v81) = loc_1000FED0(v20, v19);
  LOBYTE(v85) = 7;
  v26 = sub_10010C90((int)&v78, v27, (int)"server", v68);
  sub_10010260(v26, v28, (int)&v81);
  LOBYTE(v85) = 2;
  sub_100101D0((int)&v81, a2);
  v82 = v82 & 0xFFFFFF01 | 1;
  v29 = *(_DWORD *)(_ESI + 72);
  v83 = 0;
  v81 = v29;
  LOBYTE(v85) = 8;
  v30 = sub_10010C90((int)&v78, SHIDWORD(v29), (int)"account", v68);
  sub_10010260(v30, v31, (int)&v81);
  LOBYTE(v85) = 2;
  sub_100101D0((int)&v81, a2);
  v82 = v82 & 0xFFFFFF01 | 1;
  v32 = *(_DWORD *)(_ESI + 76);
  v83 = 0;
  v81 = v32;
  LOBYTE(v85) = 9;
  LODWORD(v25) = sub_10010C90((int)&v78, SHIDWORD(v32), (int)"type", v68);
  sub_10010260(v25, SHIDWORD(v25), (int)&v81);
  LOBYTE(v85) = 2;
  sub_100101D0((int)&v81, a2);
  __asm
  {
    movsd   xmm0, qword ptr [esi+50h]
    comisd  xmm0, ds:qword_10068450
  }
  if ( !_CF )
  {
    v82 = v82 & 0xFFFFFF03 | 3;
    v83 = 0;
    __asm { movsd   [ebp+var_24], xmm0 }
    LOBYTE(v85) = 10;
    LODWORD(v25) = sub_10010C90((int)&v78, SHIDWORD(v25), (int)"balance", v68);
    sub_10010260(v25, SHIDWORD(v25), (int)&v81);
    LOBYTE(v85) = 2;
    sub_100101D0((int)&v81, a2);
  }
  if ( *(_DWORD *)(_ESI + 104) )
  {
    v37 = *(_DWORD *)(_ESI + 104);
    v38 = _ESI + 88;
    v39 = *(_DWORD *)(_ESI + 108) < 0x10u;
    v82 = v82 & 0xFFFFFF04 | 0x104;
    v83 = 0;
    if ( !v39 )
      v38 = *(_DWORD *)v38;
    LODWORD(v81) = loc_1000FED0(v38, v37);
    LOBYTE(v85) = 11;
    LODWORD(v25) = sub_10010C90((int)&v78, v40, (int)"currency", v68);
    sub_10010260(v25, SHIDWORD(v25), (int)&v81);
    LOBYTE(v85) = 2;
    sub_100101D0((int)&v81, a2);
  }
  v82 &= 0xFFFFFE00u;
  v83 = 0;
  LOBYTE(v85) = 13;
  v42 = sub_10010C90((int)&v81, SHIDWORD(v25), (int)"data", v68);
  sub_10010260(v42, v43, (int)&v78);
  v74 = &v67;
  v76 = 0;
  v77 = 0;
  sub_10010010((int)&v67, v44, (int)&v81);
  LOBYTE(v85) = 14;
  v66 = 7;
  v65 = 0;
  v61 = 0;
  loc_10009CC0(&dword_10074FE8, 0, -1);
  LOBYTE(v85) = 13;
  sub_100036F0(*(_DWORD *)&v61, v62, v63, v64, v65, v66, v67);
  LOBYTE(v85) = 15;
  v71 = sub_10029F21();
  v70 = _ESI;
  v72 = v45;
  sub_10025FC0(v45, (int)&v76, a2, a2, (int)&v70);
  LOBYTE(v85) = 13;
  v41 = v77;
  v75 = 1;
  if ( v77 )
  {
    _EDI = -1;
    _ECX = v77 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v41)(v41);
      _EAX = v41 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v41 + 4))(v41);
    }
  }
  LOBYTE(v85) = 2;
  sub_100101D0((int)&v81, a2);
  LOBYTE(v85) = 0;
  sub_100101D0((int)&v78, a2);
  return a2;
}
// 100036F0: using guessed type _DWORD __cdecl sub_100036F0(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, char);
// 10073200: using guessed type int __security_cookie;
// 10074FD0: using guessed type int dword_10074FD0;
// 10074FE0: using guessed type int dword_10074FE0;
// 10074FE4: using guessed type int dword_10074FE4;
// 10074FE8: using guessed type int dword_10074FE8;
// 10075000: using guessed type int dword_10075000;
// 10075010: using guessed type int dword_10075010;
// 10075014: using guessed type int dword_10075014;

//----- (10022720) --------------------------------------------------------
int __thiscall sub_10022720(void *this, char a2, int a3)
{
  __int64 v3; // qax@1
  int v4; // ecx@1
  int v5; // ebx@1
  void *v6; // edi@1
  int v7; // eax@1
  int v8; // edx@1
  int v9; // edx@1
  int v10; // eax@2
  __int64 v11; // ST08_8@2
  __int16 v12; // cx@2
  double v13; // ST08_8@2
  double v14; // st7@2
  __int64 v15; // qax@2
  __int64 v16; // ST08_8@2
  int v17; // edx@3
  int v18; // ecx@3
  int v19; // eax@3
  int v20; // eax@3
  int v21; // edx@5
  int v22; // ecx@5
  int v23; // eax@5
  int v24; // eax@5
  int v25; // eax@7
  int v26; // edx@7
  int v27; // ecx@8
  int v28; // eax@8
  int v29; // edx@8
  int v30; // esi@9
  double v46; // [sp+8h] [bp-15Ch]@1
  char v47; // [sp+34h] [bp-130h]@1
  void *v48; // [sp+60h] [bp-104h]@3
  unsigned int v49; // [sp+74h] [bp-F0h]@3
  void *v50; // [sp+90h] [bp-D4h]@5
  unsigned int v51; // [sp+A4h] [bp-C0h]@5
  char v52; // [sp+F4h] [bp-70h]@7
  char v53; // [sp+FCh] [bp-68h]@7
  int v54; // [sp+100h] [bp-64h]@7
  char v55; // [sp+104h] [bp-60h]@1
  char v56; // [sp+10Ch] [bp-58h]@1
  int v57; // [sp+110h] [bp-54h]@1
  __int64 v58; // [sp+114h] [bp-50h]@1
  int v59; // [sp+11Ch] [bp-48h]@1
  int v60; // [sp+120h] [bp-44h]@1
  int v61; // [sp+124h] [bp-40h]@1
  void *v62; // [sp+128h] [bp-3Ch]@1
  double v63; // [sp+12Ch] [bp-38h]@2
  int v64; // [sp+138h] [bp-2Ch]@1
  char v65; // [sp+13Ch] [bp-28h]@1
  int v66; // [sp+148h] [bp-1Ch]@1
  unsigned int v67; // [sp+150h] [bp-14h]@1
  double *v68; // [sp+154h] [bp-10h]@1
  int v69; // [sp+160h] [bp-4h]@1
  int v70; // [sp+164h] [bp+0h]@1

  v67 = (unsigned int)&v70 ^ __security_cookie;
  v68 = (double *)((char *)&v46 + 4);
  v6 = this;
  v62 = this;
  v69 = 0;
  LOBYTE(v69) = 1;
  v64 = 0;
  v61 = 0;
  v66 = 0;
  loc_10002BC0(&a2, &v65, (unsigned int)&v70 ^ __security_cookie);
  __asm { xorps   xmm0, xmm0 }
  v59 = v59 & 0xFFFFFF02 | 2;
  v60 = 0;
  __asm { movlpd  [ebp+var_50], xmm0 }
  LOBYTE(v69) = 3;
  v7 = sub_10010E40((int)&v65, v8, (int)&v47, (int)"flags", (int)&v58);
  LOBYTE(v69) = 4;
  v5 = loc_10010400(v7);
  LOBYTE(v69) = 3;
  sub_100101D0((int)&v47, v5);
  LOBYTE(v69) = 2;
  sub_100101D0((int)&v58, v5);
  v64 = v5;
  v57 = 0;
  LODWORD(v3) = sub_10010C90((int)&v65, v9, (int)"utc", v4);
  sub_10010010((int)&v55, SHIDWORD(v3), v3);
  LOBYTE(v69) = 5;
  if ( v56 )
  {
    v10 = loc_10010400(&v55);
    v11 = 10000000i64;
    *(_QWORD *)&v63 = *((_QWORD *)v6 + 1) - sub_10039A20((unsigned int)v10, v11);
    v12 = WORD2(v63);
    v63 = (double)*(signed __int64 *)&v63;
    __asm { movsd   xmm0, [ebp+var_38] }
    v63 = (double)9000000000i64;
    __asm
    {
      divsd   xmm0, [ebp+var_38]
      addsd   xmm0, ds:qword_10068478
      movsd   [ebp+var_38], xmm0
    }
    v13 = v63;
    v14 = sub_10059030(v12, v5, v13);
    LODWORD(v15) = sub_1004D276(v14);
    v16 = 9000000000i64;
    v3 = sub_10039A20(v15, v16);
    v4 = *(_DWORD *)v6;
    *(_DWORD *)(*(_DWORD *)v6 + 128) = v3;
    *(_DWORD *)(v4 + 132) = HIDWORD(v3);
  }
  v19 = sub_10010C90((int)&v65, SHIDWORD(v3), (int)"msg1", v4);
  v20 = loc_100102E0(v19, &v48);
  LOBYTE(v69) = 6;
  sub_10018590((void *)(*(_DWORD *)v6 + 136), v20);
  LOBYTE(v69) = 5;
  if ( v49 >= 0x10 )
    sub_1002A4AA(v48);
  v23 = sub_10010C90((int)&v65, v17, (int)"msg2", v18);
  v24 = loc_100102E0(v23, &v50);
  LOBYTE(v69) = 7;
  sub_10018590((void *)(*(_DWORD *)v6 + 180), v24);
  LOBYTE(v69) = 5;
  if ( v51 >= 0x10 )
    sub_1002A4AA(v50);
  v54 = 0;
  v25 = sub_10010C90((int)&v65, v21, (int)"auth_interval", v22);
  sub_10010010((int)&v52, v26, v25);
  LOBYTE(v69) = 8;
  if ( v53 )
  {
    v27 = loc_10010720(&v52);
    v28 = *(_DWORD *)v6;
    HIDWORD(v63) = v29;
    *(_DWORD *)(v28 + 120) = v27;
  }
  LOBYTE(v69) = 5;
  sub_100101D0((int)&v52, v5);
  LOBYTE(v69) = 2;
  sub_100101D0((int)&v55, v5);
  LOBYTE(v69) = 1;
  sub_100101D0((int)&v65, v5);
  *(_DWORD *)(*(_DWORD *)v6 + 112) = v5;
  *(_DWORD *)(*(_DWORD *)v6 + 116) = v61;
  v69 = -1;
  v30 = a3;
  if ( a3 )
  {
    _EDI = -1;
    _ECX = a3 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v30)(v30);
      _EDX = v30 + 8;
      __asm { lock xadd [edx], edi }
      if ( _EDI == 1 )
        (*(void (**)(void))(*(_DWORD *)v30 + 4))();
    }
  }
  return v5;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10022A7D) --------------------------------------------------------
int (*__usercall sub_10022A7D<eax>(int a1<ebp>))()
{
  int v1; // eax@1
  int v3; // esi@1

  v1 = *(_DWORD *)(a1 - 116);
  *(_DWORD *)(a1 - 44) |= 0x2000u;
  *(_DWORD *)(a1 - 64) = *(_DWORD *)(v1 + 16);
  sub_1000AFB0(a1 - 188, (const char *)&unk_1006723C);
  v3 = *(_DWORD *)(a1 - 60);
  *(_BYTE *)(a1 - 4) = 12;
  sub_10018590((void *)(*(_DWORD *)v3 + 136), a1 - 188);
  *(_BYTE *)(a1 - 4) = 9;
  sub_10001880(a1 - 188);
  sub_1000AFB0(a1 - 236, (const char *)&unk_1006723C);
  *(_BYTE *)(a1 - 4) = 13;
  sub_10018590((void *)(*(_DWORD *)v3 + 180), a1 - 236);
  sub_10001880(a1 - 236);
  return loc_10022B00;
}
// 10022B00: using guessed type int loc_10022B00();

//----- (10022B17) --------------------------------------------------------
int (__stdcall *__usercall sub_10022B17<eax>(int a1<ebp>))(char, int)
{
  int v2; // esi@1

  *(_DWORD *)(a1 - 44) |= 0x4000u;
  sub_1000AFB0(a1 - 284, (const char *)&unk_1006723C);
  v2 = *(_DWORD *)(a1 - 60);
  *(_BYTE *)(a1 - 4) = 14;
  sub_10018590((void *)(*(_DWORD *)v2 + 136), a1 - 284);
  *(_BYTE *)(a1 - 4) = 9;
  sub_10001880(a1 - 284);
  sub_1000AFB0(a1 - 328, (const char *)&unk_1006723C);
  *(_BYTE *)(a1 - 4) = 15;
  sub_10018590((void *)(*(_DWORD *)v2 + 180), a1 - 328);
  sub_10001880(a1 - 328);
  return loc_10022A17;
}
// 10022A17: using guessed type int __stdcall loc_10022A17(char, int);

//----- (10022BA0) --------------------------------------------------------
int __userpurge sub_10022BA0<eax>(int a1<ecx>, int a2<edi>, int a3, void *a4, int a5, int a6, int a7, int a8, unsigned int a9, __int64 a10, __int64 a11)
{
  int v11; // eax@1
  int ebp0; // ebp@0
  int v15; // esi@1
  int v16; // ebx@1
  int v17; // eax@2
  int v31; // ecx@10
  int i; // esi@10
  int v33; // eax@11
  int v34; // eax@14
  int v35; // edx@14
  int v36; // edi@14
  int v37; // eax@15
  int v38; // edi@16
  int v39; // esi@17
  int v54; // edi@27
  int v62; // ecx@30
  int v70; // ecx@33
  int v78; // ecx@36
  int v86; // esi@40
  int v87; // eax@41
  char v101; // [sp-2Ch] [bp-9Ch]@4
  int v102; // [sp-28h] [bp-98h]@4
  int v103; // [sp-24h] [bp-94h]@4
  int v104; // [sp-20h] [bp-90h]@4
  unsigned int v105; // [sp-1Ch] [bp-8Ch]@4
  unsigned int v106; // [sp-18h] [bp-88h]@4
  __int64 v107; // [sp-14h] [bp-84h]@4
  __int64 v108; // [sp-Ch] [bp-7Ch]@4
  unsigned int v109; // [sp-4h] [bp-74h]@1
  int v110; // [sp+10h] [bp-60h]@1
  int v111; // [sp+14h] [bp-5Ch]@1
  int v112; // [sp+18h] [bp-58h]@14
  int v113; // [sp+1Ch] [bp-54h]@36
  int v114; // [sp+20h] [bp-50h]@36
  int v115; // [sp+24h] [bp-4Ch]@1
  int v116; // [sp+28h] [bp-48h]@1
  int v117; // [sp+2Ch] [bp-44h]@1
  int v118; // [sp+30h] [bp-40h]@4
  int v119; // [sp+34h] [bp-3Ch]@4
  int v120; // [sp+38h] [bp-38h]@27
  int v121; // [sp+3Ch] [bp-34h]@27
  unsigned int v122; // [sp+5Ch] [bp-14h]@1
  int v123; // [sp+6Ch] [bp-4h]@1
  int v124; // [sp+70h] [bp+0h]@1

  v122 = (unsigned int)&v124 ^ __security_cookie;
  v109 = (unsigned int)&v124 ^ __security_cookie;
  v16 = a1;
  v117 = a1;
  v115 = a3;
  v110 = a3;
  v116 = 0;
  v123 = 1;
  sub_1002B62D(ebp0, a1 + 612);
  LOBYTE(v123) = 2;
  v15 = *(_DWORD *)(v16 + 236);
  v111 = v16 + 236;
  v11 = v117;
  _EBX = -1;
  if ( v15 == *(_DWORD *)(v117 + 240) )
  {
LABEL_10:
    v31 = *(_DWORD *)(v11 + 240);
    for ( i = *(_DWORD *)(v11 + 236); i != v31; i += 8 )
    {
      v33 = *(_DWORD *)(i + 4);
      if ( !v33 )
        break;
      if ( !*(_DWORD *)(v33 + 4) )
        break;
    }
    v34 = sub_1002ADB1(_EDX, v31, -1, a2, 64);
    v36 = v34;
    v112 = v34;
    LOBYTE(v123) = 4;
    if ( v34 )
    {
      *(_DWORD *)(v34 + 40) = 0;
      *(_DWORD *)(v34 + 44) = 0;
      *(_DWORD *)(v34 + 48) = 0;
      *(_DWORD *)(v34 + 56) = 0;
      *(_DWORD *)(v34 + 60) = 0;
      v108 = a11;
      v107 = a10;
      v106 = 15;
      v105 = 0;
      v101 = 0;
      loc_1000AB40(&a4, 0, -1);
      v37 = sub_10001BD0(v36, v36, *(void **)&v101, v102, v103, v104, v105, v106, v107, v108);
    }
    else
    {
      v37 = 0;
    }
    LOBYTE(v123) = 2;
    v120 = 0;
    v121 = 0;
    sub_10026430(v35, (int)&v120, -1, v37);
    LOBYTE(v123) = 5;
    v54 = v121;
    if ( i == *(_DWORD *)(v117 + 240) )
    {
      if ( v121 )
      {
        _EAX = v121 + 8;
        _ECX = 1;
        __asm { lock xadd [eax], ecx }
      }
      v114 = v54;
      v113 = v120;
      LOBYTE(v123) = 6;
      sub_10022FC0(v111, (unsigned int)&v113);
      LOBYTE(v123) = 5;
      v78 = v114;
      if ( v114 )
      {
        _EAX = v114 + 8;
        _EDX = -1;
        __asm { lock xadd [eax], edx }
        if ( _ZF )
          (*(void (__fastcall **)(int, int))(*(_DWORD *)v78 + 4))(v78, _EDX);
      }
      v70 = v120;
    }
    else
    {
      if ( v121 )
      {
        _EAX = v121 + 8;
        _ECX = 1;
        __asm { lock xadd [eax], ecx }
      }
      v62 = *(_DWORD *)(i + 4);
      if ( v62 )
      {
        _EAX = v62 + 8;
        _EDX = -1;
        __asm { lock xadd [eax], edx }
        if ( _ZF )
          (*(void (__fastcall **)(int, int))(*(_DWORD *)v62 + 4))(v62, _EDX);
      }
      v70 = v120;
      *(_DWORD *)(i + 4) = v54;
      *(_DWORD *)i = v70;
    }
    v86 = v115;
    *(_DWORD *)v115 = 0;
    *(_DWORD *)(v86 + 4) = 0;
    if ( (int *)v86 != &v120 )
    {
      v87 = *(_DWORD *)(v86 + 4);
      *(_DWORD *)(v86 + 4) = v54;
      v54 = v87;
      *(_DWORD *)v86 = v70;
    }
    v116 = 1;
    LOBYTE(v123) = 2;
    if ( v54 )
    {
      _EAX = v54 + 4;
      _ECX = -1;
      __asm { lock xadd [eax], ecx }
      if ( _ZF )
      {
        (**(void (__thiscall ***)(_DWORD))v54)(v54);
        _EAX = v54 + 8;
        __asm { lock xadd [eax], ebx }
        if ( _EBX == 1 )
          (*(void (__thiscall **)(int))(*(_DWORD *)v54 + 4))(v54);
      }
    }
    LOBYTE(v123) = 1;
    sub_1002B6D6();
    if ( a9 >= 0x10 )
      sub_1002A4AA(a4);
    return v86;
  }
  while ( 1 )
  {
    v17 = *(_DWORD *)(v15 + 4);
    if ( !v17 || !*(_DWORD *)(v17 + 4) )
      goto LABEL_9;
    v118 = 0;
    v119 = 0;
    sub_100248A0(v15, (int)&v118);
    LOBYTE(v123) = 3;
    v108 = a11;
    v107 = a10;
    v106 = 15;
    v105 = 0;
    v101 = 0;
    loc_1000AB40(&a4, 0, -1);
    if ( sub_10001FA0(v118, *(void **)&v101, v102, v103, v104, v105, v106, v107, v108) )
      break;
    LOBYTE(v123) = 2;
    a2 = v119;
    if ( v119 )
    {
      _EAX = v119 + 4;
      _ECX = -1;
      __asm { lock xadd [eax], ecx }
      if ( _ZF )
      {
        (**(void (__thiscall ***)(_DWORD))a2)(a2);
        _EAX = a2 + 8;
        _EDX = -1;
        __asm { lock xadd [eax], edx }
        if ( _ZF )
          (*(void (__fastcall **)(int, int))(*(_DWORD *)a2 + 4))(a2, _EDX);
      }
    }
LABEL_9:
    v11 = v117;
    v15 += 8;
    if ( v15 == *(_DWORD *)(v117 + 240) )
      goto LABEL_10;
  }
  v38 = v115;
  *(_DWORD *)v115 = 0;
  *(_DWORD *)(v38 + 4) = 0;
  if ( (int *)v38 == &v118 )
  {
    v39 = v119;
  }
  else
  {
    v39 = *(_DWORD *)(v38 + 4);
    *(_DWORD *)(v38 + 4) = v119;
    *(_DWORD *)v38 = v118;
  }
  v116 = 1;
  LOBYTE(v123) = 2;
  if ( v39 )
  {
    _EAX = v39 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v39)(v39);
      _EAX = v39 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v39 + 4))(v39);
    }
  }
  LOBYTE(v123) = 1;
  sub_1002B6D6();
  if ( a9 >= 0x10 )
    sub_1002A4AA(a4);
  return v38;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10022F30) --------------------------------------------------------
int __thiscall sub_10022F30(int this, int *a2)
{
  int result; // eax@1
  int v3; // esi@1
  int v4; // edi@3
  int v5; // edx@5
  int v6; // ecx@5
  int v7; // ecx@9

  v3 = this;
  result = *(_DWORD *)(this + 4);
  if ( (unsigned int)a2 >= result || (this = *(_DWORD *)this, *(_DWORD *)v3 > (unsigned int)a2) )
  {
    if ( result == *(_DWORD *)(v3 + 8) )
      result = loc_10024A90(v3, this);
    v7 = *(_DWORD *)(v3 + 4);
    if ( v7 )
    {
      result = *a2;
      *a2 = 0;
      *(_DWORD *)v7 = result;
    }
  }
  else
  {
    v4 = (signed int)((char *)a2 - this) >> 2;
    if ( result == *(_DWORD *)(v3 + 8) )
      loc_10024A90(v3, *(_DWORD *)v3);
    result = *(_DWORD *)v3;
    v5 = *(_DWORD *)(v3 + 4);
    v6 = *(_DWORD *)v3 + 4 * v4;
    if ( v5 )
    {
      result = *(_DWORD *)v6;
      *(_DWORD *)v6 = 0;
      *(_DWORD *)v5 = result;
      *(_DWORD *)(v3 + 4) += 4;
      return result;
    }
  }
  *(_DWORD *)(v3 + 4) += 4;
  return result;
}

//----- (10022FC0) --------------------------------------------------------
int __thiscall sub_10022FC0(int this, unsigned int a2)
{
  int result; // eax@1
  int v3; // esi@1
  int v4; // edi@3
  int v5; // edi@5
  int v6; // ebx@6
  int v14; // ecx@8
  int v22; // ebx@14
  int v23; // eax@15
  int v24; // edi@15
  int v32; // ecx@17
  int v40; // [sp+14h] [bp+8h]@6
  int v41; // [sp+14h] [bp+8h]@15

  v3 = this;
  result = *(_DWORD *)(this + 4);
  if ( a2 >= result || (this = *(_DWORD *)this, *(_DWORD *)v3 > a2) )
  {
    if ( result == *(_DWORD *)(v3 + 8) )
      result = loc_10024B50(v3, this);
    v22 = *(_DWORD *)(v3 + 4);
    if ( v22 )
    {
      *(_DWORD *)v22 = 0;
      *(_DWORD *)(v22 + 4) = 0;
      v23 = *(_DWORD *)(a2 + 4);
      v24 = *(_DWORD *)a2;
      v41 = v23;
      if ( v23 )
      {
        _EAX = v23 + 8;
        _ECX = 1;
        __asm { lock xadd [eax], ecx }
      }
      v32 = *(_DWORD *)(v22 + 4);
      if ( v32 )
      {
        _EAX = v32 + 8;
        _EDX = -1;
        __asm { lock xadd [eax], edx }
        if ( _ZF )
          (*(void (__fastcall **)(int, int))(*(_DWORD *)v32 + 4))(v32, _EDX);
      }
      result = v41;
      *(_DWORD *)(v22 + 4) = v41;
      *(_DWORD *)v22 = v24;
    }
    goto LABEL_21;
  }
  v4 = (signed int)(a2 - this) >> 3;
  if ( result == *(_DWORD *)(v3 + 8) )
    loc_10024B50(v3, *(_DWORD *)v3);
  result = *(_DWORD *)v3 + 8 * v4;
  v5 = *(_DWORD *)(v3 + 4);
  if ( !v5 )
  {
LABEL_21:
    *(_DWORD *)(v3 + 4) += 8;
    return result;
  }
  *(_DWORD *)v5 = 0;
  *(_DWORD *)(v5 + 4) = 0;
  v6 = *(_DWORD *)(result + 4);
  v40 = *(_DWORD *)result;
  if ( v6 )
  {
    _EAX = v6 + 8;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v14 = *(_DWORD *)(v5 + 4);
  if ( v14 )
  {
    _EAX = v14 + 8;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _ZF )
      (*(void (__fastcall **)(int, int))(*(_DWORD *)v14 + 4))(v14, _EDX);
  }
  result = v40;
  *(_DWORD *)(v5 + 4) = v6;
  *(_DWORD *)v5 = v40;
  *(_DWORD *)(v3 + 4) += 8;
  return result;
}

//----- (100230C0) --------------------------------------------------------
int __usercall sub_100230C0<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // ecx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // eax@1
  int v6; // ecx@3

  v3 = a1;
  *(_DWORD *)a1 = &off_100683A4;
  v5 = *(_DWORD *)(a1 + 96);
  *(_BYTE *)(a1 + 88) = 1;
  (*(void (**)(void))(v5 + 8))();
  (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 24))(v3);
  v4 = v3 + 248;
  v2 = *(_DWORD *)(v3 + 264);
  if ( v2 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v2 + 16))(v2 != v4);
    *(_DWORD *)(v3 + 264) = 0;
  }
  v6 = *(_DWORD *)(v3 + 264);
  if ( v6 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v6 + 16))(v6 != v4);
    *(_DWORD *)(v3 + 264) = 0;
  }
  return sub_10023430(v3, a2);
}
// 100683A4: using guessed type int (__stdcall *off_100683A4)(char);

//----- (10023170) --------------------------------------------------------
signed int __thiscall sub_10023170(void *this, int a2, int a3)
{
  int v3; // eax@1
  void *v4; // esi@1
  signed int result; // eax@2

  v4 = this;
  v3 = (*(int (__stdcall **)(_DWORD, void *))(*(_DWORD *)a3 + 16))(*(_DWORD *)(a2 + 4), this);
  if ( v3 )
  {
    (*(void (__thiscall **)(char *, int))*((void (__thiscall ***)(_DWORD, _DWORD))v4 + 24))((char *)v4 + 96, v3);
    result = 0;
  }
  else
  {
    result = 3;
  }
  return result;
}

//----- (100231B0) --------------------------------------------------------
signed int __thiscall sub_100231B0(void *this, int a2, int a3)
{
  int v3; // eax@1
  void *v4; // esi@1
  signed int result; // eax@2

  v4 = this;
  v3 = (*(int (__stdcall **)(_DWORD, void *))(*(_DWORD *)a3 + 16))(*(_DWORD *)(a2 + 4), this);
  if ( v3 )
  {
    (*(void (__thiscall **)(char *, int))(*((_DWORD *)v4 + 24) + 4))((char *)v4 + 96, v3);
    result = 0;
  }
  else
  {
    result = 3;
  }
  return result;
}

//----- (100231F0) --------------------------------------------------------
char __cdecl sub_100231F0()
{
  return 1;
}

//----- (10023230) --------------------------------------------------------
int __thiscall sub_10023230(int this)
{
  unsigned int v1; // eax@1
  int v2; // edx@1
  unsigned int v3; // ecx@1
  int v4; // esi@1
  int result; // eax@7
  char v6; // [sp+Ch] [bp-1Ch]@6
  int v7; // [sp+18h] [bp-10h]@1
  int v8; // [sp+24h] [bp-4h]@1

  v4 = this;
  v7 = this;
  *(_DWORD *)this = off_10068380;
  v8 = 0;
  v3 = *(_DWORD *)(this + 12);
  v2 = 0;
  v1 = 0;
  if ( v3 )
  {
    do
    {
      if ( *(_DWORD *)(*(_DWORD *)(v4 + 8) + 4 * v1) )
        ++v2;
      ++v1;
    }
    while ( v1 < v3 );
    if ( v2 )
    {
      sub_1002FFB9((int)&v6, (unsigned int)"Deleting link registry before removing all the links");
      sub_100355BB((int)&v6, (int)&unk_1006C878);
    }
  }
  result = *(_DWORD *)(v4 + 8);
  if ( result )
  {
    result = sub_100303A3(*(LPVOID *)(v4 + 8));
    *(_DWORD *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
  }
  return result;
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 10068380: using guessed type int (__stdcall *off_10068380[3])(int);

//----- (100232E0) --------------------------------------------------------
int __stdcall sub_100232E0(int a1)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
    JUMPOUT(loc_10024C20);
  return result;
}

//----- (10023300) --------------------------------------------------------
char __thiscall sub_10023300(int this, int a2)
{
  char result; // al@2

  if ( a2 )
    result = sub_10024CD0(this, a2);
  else
    result = 0;
  return result;
}

//----- (10023320) --------------------------------------------------------
char __thiscall sub_10023320(void *this, int a2)
{
  bool v2; // eax@2

  if ( a2 )
    v2 = (unsigned int)(*(int (__stdcall **)(int))(*(_DWORD *)this + 32))(a2) < *((_DWORD *)this + 3);
  else
    LOBYTE(v2) = 0;
  return v2;
}

//----- (10023350) --------------------------------------------------------
int __thiscall sub_10023350(int this)
{
  int result; // eax@1
  int v2; // edx@1
  int v3; // ecx@2

  v2 = *(_DWORD *)(this + 12);
  result = 0;
  if ( v2 )
  {
    v3 = *(_DWORD *)(this + 8);
    do
    {
      if ( *(_DWORD *)v3 )
        ++result;
      v3 += 4;
      --v2;
    }
    while ( v2 );
  }
  return result;
}

//----- (10023370) --------------------------------------------------------
int __thiscall sub_10023370(void *this, int a2)
{
  *(_DWORD *)a2 = this;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  (*(void (__stdcall **)(int))(*(_DWORD *)this + 20))(a2 + 4);
  return a2;
}

//----- (100233A0) --------------------------------------------------------
int __thiscall sub_100233A0(int this, int a2)
{
  int v2; // edi@1
  unsigned int v3; // esi@1
  int result; // eax@2
  int v5; // ecx@2

  v2 = this;
  v3 = *(_DWORD *)(this + 12);
  if ( *(_DWORD *)a2 < v3 )
  {
    do
    {
      v5 = *(_DWORD *)a2;
      result = *(_DWORD *)(v2 + 8);
      if ( *(_DWORD *)(result + 4 * *(_DWORD *)a2) )
        break;
      result = v5 + 1;
      *(_DWORD *)a2 = v5 + 1;
    }
    while ( v5 + 1 < v3 );
  }
  return result;
}

//----- (100233D0) --------------------------------------------------------
int __thiscall sub_100233D0(int this, unsigned int a2)
{
  int result; // eax@2

  if ( a2 >= *(_DWORD *)(this + 12) )
    result = 0;
  else
    result = *(_DWORD *)(*(_DWORD *)(this + 8) + 4 * a2);
  return result;
}

//----- (100233F0) --------------------------------------------------------
unsigned int __thiscall sub_100233F0(int this, int a2)
{
  unsigned int result; // eax@1
  unsigned int v3; // edx@1
  int v4; // ecx@2

  v3 = *(_DWORD *)(this + 12);
  result = 0;
  if ( v3 )
  {
    v4 = *(_DWORD *)(this + 8);
    do
    {
      if ( *(_DWORD *)v4 == a2 )
        break;
      ++result;
      v4 += 4;
    }
    while ( result < v3 );
  }
  return result;
}

//----- (10023430) --------------------------------------------------------
int __usercall sub_10023430<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // edi@1
  int v3; // esi@1
  int v4; // ecx@2
  int v5; // ecx@4
  int v6; // ST0C_4@7
  int v7; // ST10_4@7
  int result; // eax@9

  v2 = a1;
  *(_DWORD *)a1 = &off_100682F4;
  v3 = *(_DWORD *)(a1 + 84);
  if ( v3 )
  {
    v4 = *(_DWORD *)(v3 + 16);
    if ( v4 )
    {
      (*(void (__stdcall **)(bool))(*(_DWORD *)v4 + 16))(v4 != v3);
      *(_DWORD *)(v3 + 16) = 0;
    }
    v5 = *(_DWORD *)(v3 + 16);
    if ( v5 )
    {
      (*(void (__stdcall **)(bool))(*(_DWORD *)v5 + 16))(v5 != v3);
      *(_DWORD *)(v3 + 16) = 0;
    }
    sub_1002A4AA((LPVOID)v3);
  }
  sub_10031064(a2, v2, 3, v2, (unsigned __int64)v2 >> 32, v6, v7);
  sub_100238D0((void *)(v2 + 96), a2);
  sub_10023230(v2 + 60);
  if ( *(_DWORD *)(v2 + 48) )
  {
    sub_100303A3(*(LPVOID *)(v2 + 48));
    *(_DWORD *)(v2 + 48) = 0;
    *(_DWORD *)(v2 + 52) = 0;
    *(_DWORD *)(v2 + 56) = 0;
  }
  result = nullsub_2(v2 + 4);
  *(_DWORD *)v2 = &off_10068264;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1002C171: using guessed type int __thiscall nullsub_2(_DWORD);
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 10068264: using guessed type int (__stdcall *off_10068264)(char);
// 100682F4: using guessed type int (__stdcall *off_100682F4)(char);

//----- (100236B0) --------------------------------------------------------
signed int __stdcall sub_100236B0(int a1, int a2)
{
  return 1;
}

//----- (100236C0) --------------------------------------------------------
int __thiscall sub_100236C0(void *this, int a2)
{
  int v2; // ebx@1
  int ebp0; // ebp@0
  int v4; // esi@1
  char v6; // [sp+Ch] [bp-2Ch]@2
  unsigned int v7; // [sp+28h] [bp-10h]@1
  int v8; // [sp+34h] [bp-4h]@2
  int v9; // [sp+38h] [bp+0h]@1

  v7 = (unsigned int)&v9 ^ __security_cookie;
  v2 = (int)this;
  v4 = (int)((char *)this + 4);
  if ( a2 )
  {
    sub_1002B589(ebp0, (int)((char *)this + 4));
    v8 = 0;
    (**(void (__stdcall ***)(_DWORD))(v4 + 56))(a2);
    ++*(_DWORD *)(v4 + 40);
    v8 = -1;
    sub_1002B6DD(&v6);
    (*(void (__thiscall **)(int, _DWORD))(*(_DWORD *)a2 + 32))(a2, *(_DWORD *)(v2 + 80));
    sub_10025860(v2 + 4);
  }
  return sub_10031064(v2, a2, 5, a2, (unsigned __int64)a2 >> 32, v2, (unsigned __int64)v2 >> 32);
}
// 10073200: using guessed type int __security_cookie;

//----- (10023770) --------------------------------------------------------
char __userpurge sub_10023770<al>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // edi@1

  v4 = a1;
  sub_10031064(a2, a1, 6, a3, (unsigned __int64)a3 >> 32, a1, (unsigned __int64)a1 >> 32);
  return sub_10025010(v4 + 4, a3);
}

//----- (100237A0) --------------------------------------------------------
void __thiscall sub_100237A0(void *this)
{
  int v1; // eax@1
  void *v2; // edi@1
  void *v3; // ecx@2
  int v4; // esi@2
  int (__stdcall **v5)(char); // [sp+8h] [bp-2Ch]@1
  void *v6; // [sp+Ch] [bp-28h]@1
  unsigned int v7; // [sp+10h] [bp-24h]@2
  int v8; // [sp+18h] [bp-1Ch]@1
  int v9; // [sp+1Ch] [bp-18h]@1
  int v10; // [sp+20h] [bp-14h]@1
  unsigned int v11; // [sp+24h] [bp-10h]@1
  int v12; // [sp+30h] [bp-4h]@1
  int v13; // [sp+34h] [bp+0h]@1

  v11 = (unsigned int)&v13 ^ __security_cookie;
  v2 = this;
  v6 = 0;
  v8 = 0;
  v10 = 0;
  sub_100250F0((int)((char *)this + 4), (int)&v5);
  v12 = 0;
  v1 = v9;
  while ( 1 )
  {
    v3 = v6;
    v4 = (int)&v10;
    if ( v1 < v7 )
      v4 = (int)((char *)v6 + 4 * v1);
    if ( !*(_DWORD *)v4 )
      break;
    if ( v1 < v7 )
    {
      (*(void (__stdcall **)(void *))(**((_DWORD **)v6 + v1) + 8))(v2);
      v1 = v9++ + 1;
    }
    else
    {
      (*(void (__stdcall **)(void *))(*(_DWORD *)v10 + 8))(v2);
      v1 = v9++ + 1;
    }
  }
  v5 = &off_10068020;
  v12 = 1;
  if ( v8 )
  {
    sub_10025860(v8);
    v3 = v6;
  }
  if ( v3 )
    sub_100303A3(v3);
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 10068020: using guessed type int (__stdcall *off_10068020)(char);
// 10073200: using guessed type int __security_cookie;

//----- (100238C0) --------------------------------------------------------
char __cdecl sub_100238C0()
{
  return 0;
}

//----- (100238D0) --------------------------------------------------------
void __usercall sub_100238D0(void *a1<ecx>, int a2<ebx>)
{
  int v2; // ecx@1
  int v3; // edi@1
  void *v4; // esi@1
  int v5; // ecx@3
  int v6; // ecx@5
  int v7; // edi@5
  int v8; // ecx@7
  int v9; // ecx@9
  int v10; // edi@9
  int v11; // ecx@11

  v4 = a1;
  *(_DWORD *)a1 = &off_1006824C;
  sub_10023BE0(a1);
  v3 = (int)((char *)v4 + 128);
  v2 = *((_DWORD *)v4 + 36);
  if ( v2 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v2 + 16))(v2 != v3);
    *((_DWORD *)v4 + 36) = 0;
  }
  v5 = *((_DWORD *)v4 + 36);
  if ( v5 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v5 + 16))(v5 != v3);
    *((_DWORD *)v4 + 36) = 0;
  }
  v7 = (int)((char *)v4 + 104);
  v6 = *((_DWORD *)v4 + 30);
  if ( v6 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v6 + 16))(v6 != v7);
    *((_DWORD *)v4 + 30) = 0;
  }
  v8 = *((_DWORD *)v4 + 30);
  if ( v8 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v8 + 16))(v8 != v7);
    *((_DWORD *)v4 + 30) = 0;
  }
  v10 = (int)((char *)v4 + 80);
  v9 = *((_DWORD *)v4 + 24);
  if ( v9 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v9 + 16))(v9 != v10);
    *((_DWORD *)v4 + 24) = 0;
  }
  v11 = *((_DWORD *)v4 + 24);
  if ( v11 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v11 + 16))(v11 != v10);
    *((_DWORD *)v4 + 24) = 0;
  }
  nullsub_2((char *)v4 + 24);
  sub_10025F00((int)((char *)v4 + 4), a2);
}
// 1002C171: using guessed type int __thiscall nullsub_2(_DWORD);
// 1006824C: using guessed type void *off_1006824C;

//----- (10023A00) --------------------------------------------------------
void __thiscall sub_10023A00(int this, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // esi@1
  int v5; // ecx@2
  int v6; // ecx@4
  int v7; // ecx@11
  int v8; // ecx@13
  int v9; // eax@15
  int v10; // [sp-4h] [bp-10h]@7

  v3 = this;
  v4 = this + 104;
  if ( this + 104 != a2 )
  {
    v5 = *(_DWORD *)(this + 120);
    if ( v5 )
    {
      (*(void (__stdcall **)(bool))(*(_DWORD *)v5 + 16))(v5 != v4);
      *(_DWORD *)(v4 + 16) = 0;
    }
    v6 = *(_DWORD *)(a2 + 16);
    if ( v6 )
    {
      if ( v6 == a2 )
        v10 = v4;
      else
        v10 = 0;
      *(_DWORD *)(v4 + 16) = (**(int (__stdcall ***)(_DWORD))v6)(v10);
    }
    else
    {
      *(_DWORD *)(v4 + 16) = 0;
    }
  }
  if ( v3 + 128 != a3 )
  {
    v7 = *(_DWORD *)(v3 + 144);
    if ( v7 )
    {
      (*(void (__stdcall **)(bool))(*(_DWORD *)v7 + 16))(v7 != v3 + 128);
      *(_DWORD *)(v3 + 144) = 0;
    }
    v8 = *(_DWORD *)(a3 + 16);
    if ( v8 )
    {
      v9 = *(_DWORD *)v8;
      if ( v8 == a3 )
        *(_DWORD *)(v3 + 144) = (*(int (__stdcall **)(int))v9)(v3 + 128);
      else
        *(_DWORD *)(v3 + 144) = (*(int (__stdcall **)(_DWORD))v9)(0);
    }
    else
    {
      *(_DWORD *)(v3 + 144) = 0;
    }
  }
}

//----- (10023BE0) --------------------------------------------------------
void __thiscall sub_10023BE0(void *this)
{
  int ebp0; // ebp@0
  void *v2; // esi@1
  char v10; // zf@1
  char v11; // [sp+8h] [bp-44h]@1
  char v12; // [sp+Ch] [bp-40h]@2
  int v13; // [sp+14h] [bp-38h]@1
  int (__usercall *v14)<eax>(int<ebx>, int<ebp>, int<edi>); // [sp+18h] [bp-34h]@1
  unsigned int v15; // [sp+38h] [bp-14h]@1
  int v16; // [sp+48h] [bp-4h]@3

  v15 = (unsigned int)&v11 ^ __security_cookie;
  v2 = this;
  _EAX = (int)((char *)this + 68);
  _ECX = 1;
  __asm { lock xadd [eax], ecx }
  v10 = *((_DWORD *)v2 + 18) == 0;
  v13 = 0;
  v14 = sub_10031190;
  if ( !v10 )
  {
    do
      sub_100282E0((int)&v12);
    while ( *((_DWORD *)v2 + 18) );
  }
  sub_1002B544(ebp0, (int)((char *)v2 + 24));
  v16 = 0;
  sub_10025170(v2);
  v16 = -1;
  sub_1002B6D6();
}
// 10073200: using guessed type int __security_cookie;

//----- (10023CA0) --------------------------------------------------------
int __fastcall sub_10023CA0(int a1)
{
  int result; // eax@1
  int v2; // ebx@1
  __int64 v3; // qdi@1
  int v4; // ST10_4@1
  int v5; // ST14_4@1
  int v6; // eax@1
  int v7; // ST10_4@1

  v2 = a1;
  v3 = a1;
  sub_10031064(a1, a1, 1, a1, (unsigned __int64)a1 >> 32, v4, v5);
  v6 = loc_10025270(v2);
  sub_10031064(v2, v3, 2, v3, SHIDWORD(v3), v6, v7);
  result = v2 + 72;
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  return result;
}

//----- (10023CE0) --------------------------------------------------------
int __stdcall sub_10023CE0(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // ecx@1

  result = a1;
  v4 = a1 + 4 * (a2 + 2);
  if ( v4 )
  {
    result = *(_DWORD *)a3;
    *(_DWORD *)v4 = *(_DWORD *)a3;
  }
  return result;
}

//----- (10023D00) --------------------------------------------------------
int __stdcall sub_10023D00(int a1, int a2, int a3)
{
  int result; // eax@2

  if ( a1 )
  {
    result = *(_DWORD *)(a2 + 4 * a3 + 8);
    *(_DWORD *)a1 = result;
  }
  return result;
}

//----- (10023D60) --------------------------------------------------------
int __stdcall sub_10023D60(void *a1)
{
  return sub_1002A4AA(a1);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10023D90) --------------------------------------------------------
void __usercall sub_10023D90(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // esi@1
  int v4; // ecx@3
  int v5; // ecx@3
  int v6; // [sp+10h] [bp-10h]@6
  int v7; // [sp+1Ch] [bp-4h]@1

  v3 = a1;
  *(_DWORD *)a1 = &off_100681E0;
  *(_DWORD *)(a1 + 16) = &off_10068188;
  v7 = 1;
  if ( *(_DWORD *)(a1 + 244) == 1 )
    sub_1003125D(a1);
  (*(void (__thiscall **)(int))(*(_DWORD *)(v3 + 40) + 8))(v3 + 40);
  (*(void (__thiscall **)(int))(*(_DWORD *)(v3 + 16) + 12))(v3 + 16);
  sub_10025C00(v3 + 16, v5);
  v4 = *(_DWORD *)(v3 + 240);
  if ( v4 )
    (*(void (__stdcall **)(signed int))(*(_DWORD *)v4 + 4))(1);
  if ( *(_BYTE *)(v3 + 253) )
  {
    v6 = *(_DWORD *)(v3 + 256);
    sub_10034897(&v6);
  }
  LOBYTE(v7) = 0;
  sub_10024130(v3 + 16, a2, a3);
  v7 = -1;
  sub_100311BB(v3);
}
// 10068188: using guessed type int (*off_10068188)();
// 100681E0: using guessed type int (__stdcall *off_100681E0)(char);

//----- (10023E50) --------------------------------------------------------
int __thiscall sub_10023E50(int this, int a2)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 224);
  if ( result && a2 == *(_DWORD *)(result + 4) )
    *(_DWORD *)(this + 224) = 0;
  else
    result = 0;
  return result;
}

//----- (10023E80) --------------------------------------------------------
char __thiscall sub_10023E80(int this, int a2)
{
  int v2; // eax@1

  v2 = *(_DWORD *)(this + 224);
  return v2 && *(_DWORD *)(v2 + 4) == a2;
}

//----- (10023EB0) --------------------------------------------------------
int __thiscall sub_10023EB0(void *this)
{
  return (*(int (**)(void))(*(_DWORD *)this + 48))();
}

//----- (10023F10) --------------------------------------------------------
int __thiscall sub_10023F10(int this, int a2)
{
  int v2; // esi@1
  int result; // eax@2

  v2 = *(_DWORD *)(this + 224);
  if ( v2 )
    result = (*(int (__stdcall **)(int, int))(*(_DWORD *)a2 + 4))(v2, this != 16 ? this : 0);
  return result;
}

//----- (10023F40) --------------------------------------------------------
unsigned int __userpurge sub_10023F40<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  unsigned int result; // eax@1
  int v4; // esi@1
  int v5; // eax@2
  int v6; // eax@3
  int v7; // ecx@3
  int v8; // ST00_4@5
  int v9; // [sp+4h] [bp-10h]@2
  int v10; // [sp+8h] [bp-Ch]@2
  unsigned int i; // [sp+Ch] [bp-8h]@2
  unsigned int v12; // [sp+10h] [bp-4h]@1
  int v13; // [sp+14h] [bp+0h]@1

  result = (unsigned int)&v13 ^ __security_cookie;
  v12 = (unsigned int)&v13 ^ __security_cookie;
  v4 = a1;
  if ( !*(_DWORD *)(a1 + 224) )
  {
    *(_DWORD *)(a1 + 224) = sub_100253D0(a1 - 16, a2);
    v5 = *(_DWORD *)(v4 + 12);
    v9 = 0;
    i = 0;
    (*(void (__stdcall **)(int *))(v5 + 16))(&v9);
    result = (*(int (__stdcall **)(int))(*(_DWORD *)v9 + 24))(v10);
    for ( i = result; result; i = result )
    {
      v6 = (*(int (__stdcall **)(int))(*(_DWORD *)v9 + 24))(v10);
      v7 = 0;
      if ( v4 != 16 )
        v7 = v4;
      v8 = *(_DWORD *)(v4 + 224);
      i = v6;
      (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v6 + 4))(v6, v8, v7);
      ++v10;
      (*(void (__stdcall **)(int *))(*(_DWORD *)v9 + 20))(&v10);
      result = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)v9 + 24))(v10);
    }
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;

//----- (10024000) --------------------------------------------------------
int __thiscall sub_10024000(int this)
{
  return (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)(this + 16) + 84))(this + 16, 0);
}

//----- (10024090) --------------------------------------------------------
char __thiscall sub_10024090(int this, int a2)
{
  char result; // al@3

  if ( a2 && *(_DWORD *)(this + 4) == a2 )
  {
    *(_DWORD *)(this + 4) = 0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100240C0) --------------------------------------------------------
char __thiscall sub_100240C0(int this, int a2)
{
  return a2 && *(_DWORD *)(this + 4) == a2;
}

//----- (100240E0) --------------------------------------------------------
bool __thiscall sub_100240E0(int this)
{
  return *(_DWORD *)(this + 4) != 0;
}

//----- (100240F0) --------------------------------------------------------
int __thiscall sub_100240F0(int this, int a2)
{
  int result; // eax@2

  if ( !*(_DWORD *)(this + 4) )
  {
    result = a2;
    ++*(_DWORD *)result;
  }
  return result;
}

//----- (10024110) --------------------------------------------------------
int __thiscall sub_10024110(int this, int a2)
{
  int result; // eax@2

  if ( a2 )
    result = 0;
  else
    result = *(_DWORD *)(this + 4);
  return result;
}

//----- (10024130) --------------------------------------------------------
void __usercall sub_10024130(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // esi@1
  int v4; // ST0C_4@1
  int v5; // ST10_4@1
  char v6; // zf@1
  char v7; // [sp+8h] [bp-1Ch]@2
  int v8; // [sp+14h] [bp-10h]@1
  int v9; // [sp+20h] [bp-4h]@1

  v3 = a1;
  v8 = a1;
  *(_DWORD *)a1 = &off_10068108;
  v9 = 3;
  sub_10031064(a2, a3, 3, a1, (unsigned __int64)a1 >> 32, v4, v5);
  nullsub_2(v3 + 176);
  sub_100238D0((void *)(v3 + 24), a2);
  LOBYTE(v9) = 0;
  v6 = *(_DWORD *)(v3 + 16) == 0;
  *(_DWORD *)(v3 + 12) = &off_10068168;
  if ( !v6 )
  {
    sub_1002FFB9((int)&v7, (unsigned int)"Deleting link registry before removing all the links");
    sub_100355BB((int)&v7, (int)&unk_1006C878);
  }
  *(_DWORD *)v3 = &off_10068320;
}
// 1002C171: using guessed type int __thiscall nullsub_2(_DWORD);
// 10068108: using guessed type int (__stdcall *off_10068108)(char);
// 10068168: using guessed type void *off_10068168;
// 10068320: using guessed type int (__stdcall *off_10068320)(char);

//----- (100241E0) --------------------------------------------------------
void __thiscall sub_100241E0(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1
  int (__stdcall **v4)(char); // [sp+8h] [bp-3Ch]@2
  int v5; // [sp+14h] [bp-30h]@2
  char v6; // [sp+18h] [bp-2Ch]@3
  unsigned int v7; // [sp+34h] [bp-10h]@1
  int v8; // [sp+40h] [bp-4h]@1
  int v9; // [sp+44h] [bp+0h]@1

  v7 = (unsigned int)&v9 ^ __security_cookie;
  v3 = this;
  sub_1002B589(ebp0, (int)((char *)this + 176));
  v8 = 0;
  if ( !a2 )
  {
    v5 = (int)"_PTarget";
    sub_1002AEA4((int)&v4, &v5);
    v4 = &off_1005F2EC;
    sub_100355BB((int)&v4, (int)&unk_1006C8B4);
  }
  (*(void (__thiscall **)(char *, int))*((void (__thiscall ***)(_DWORD, _DWORD))v3 + 3))((char *)v3 + 12, a2);
  (*(void (__thiscall **)(int, void *))(*(_DWORD *)a2 + 16))(a2, v3);
  (*(void (__thiscall **)(void *, int))(*(_DWORD *)v3 + 40))(v3, a2);
  v8 = -1;
  sub_1002B6DD(&v6);
}
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);
// 10073200: using guessed type int __security_cookie;

//----- (100242A0) --------------------------------------------------------
void __thiscall sub_100242A0(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v3; // edi@1
  unsigned int v4; // [sp-4h] [bp-48h]@1
  int (__stdcall **v5)(char); // [sp+8h] [bp-3Ch]@2
  int v6; // [sp+14h] [bp-30h]@2
  char v7; // [sp+18h] [bp-2Ch]@5
  unsigned int v8; // [sp+34h] [bp-10h]@1
  int v9; // [sp+40h] [bp-4h]@1
  int v10; // [sp+44h] [bp+0h]@1

  v8 = (unsigned int)&v10 ^ __security_cookie;
  v4 = (unsigned int)&v10 ^ __security_cookie;
  v3 = this;
  sub_1002B589(ebp0, (int)((char *)this + 176));
  v9 = 0;
  if ( !a2 )
  {
    v6 = (int)"_PTarget";
    sub_1002AEA4((int)&v5, &v6);
    v5 = &off_1005F2EC;
    sub_100355BB((int)&v5, (int)&unk_1006C8B4);
  }
  if ( (unsigned __int8)(*(int (__thiscall **)(char *, int, unsigned int))(*((_DWORD *)v3 + 3) + 4))(
                          (char *)v3 + 12,
                          a2,
                          v4) )
    (*(void (__thiscall **)(int, void *))(*(_DWORD *)a2 + 20))(a2, v3);
  v9 = -1;
  sub_1002B6DD(&v7);
}
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);
// 10073200: using guessed type int __security_cookie;

//----- (10024360) --------------------------------------------------------
void __thiscall sub_10024360(void *this)
{
  int ebp0; // ebp@0
  void *v2; // esi@1
  unsigned int v3; // ST04_4@1
  int v4; // eax@1
  int v5; // eax@2
  int v6; // edx@2
  char v7; // [sp+4h] [bp-38h]@3
  int v8; // [sp+20h] [bp-1Ch]@1
  int v9; // [sp+24h] [bp-18h]@1
  int i; // [sp+28h] [bp-14h]@1
  unsigned int v11; // [sp+2Ch] [bp-10h]@1
  int v12; // [sp+38h] [bp-4h]@1
  int v13; // [sp+3Ch] [bp+0h]@1

  v11 = (unsigned int)&v13 ^ __security_cookie;
  v3 = (unsigned int)&v13 ^ __security_cookie;
  v2 = this;
  sub_1002B589(ebp0, (int)((char *)this + 176));
  v12 = 0;
  v4 = *((_DWORD *)v2 + 3);
  v8 = 0;
  i = 0;
  (*(void (__thiscall **)(char *, int *, unsigned int))(v4 + 16))((char *)v2 + 12, &v8, v3);
  for ( i = (*(int (__stdcall **)(int))(*(_DWORD *)v8 + 24))(v9);
        i;
        i = (*(int (__stdcall **)(int))(*(_DWORD *)v8 + 24))(v9) )
  {
    v5 = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)v8 + 24))(v9);
    v6 = *(_DWORD *)v2;
    i = v5;
    (*(void (__thiscall **)(void *, int))(v6 + 8))(v2, v5);
    ++v9;
    (*(void (__stdcall **)(int *))(*(_DWORD *)v8 + 20))(&v9);
  }
  v12 = -1;
  sub_1002B6DD(&v7);
}
// 10073200: using guessed type int __security_cookie;

//----- (10024490) --------------------------------------------------------
char __thiscall sub_10024490(void *this, int a2, int a3)
{
  int ebp0; // ebp@0
  void *v4; // esi@1
  void *v5; // ecx@4
  char v7; // al@6
  int (__stdcall **v8)(char); // [sp+Ch] [bp-3Ch]@2
  int v9; // [sp+18h] [bp-30h]@2
  char v10; // [sp+1Ch] [bp-2Ch]@4
  unsigned int v11; // [sp+38h] [bp-10h]@1
  int v12; // [sp+44h] [bp-4h]@1
  int v13; // [sp+48h] [bp+0h]@1

  v11 = (unsigned int)&v13 ^ __security_cookie;
  v4 = this;
  sub_1002B589(ebp0, (int)((char *)this + 176));
  v12 = 0;
  if ( !a3 )
  {
    v9 = (int)"_PTarget";
    sub_1002AEA4((int)&v8, &v9);
    v8 = &off_1005F2EC;
    sub_100355BB((int)&v8, (int)&unk_1006C8B4);
  }
  if ( *((_DWORD *)v4 + 1) )
  {
    v12 = -1;
    v5 = &v10;
LABEL_5:
    sub_1002B6DD(v5);
    return 0;
  }
  v7 = (*(int (__thiscall **)(void *, int))(*(_DWORD *)v4 + 52))(v4, a2);
  v12 = -1;
  v5 = &v10;
  if ( !v7 )
    goto LABEL_5;
  *((_DWORD *)v4 + 1) = a3;
  *((_DWORD *)v4 + 2) = a2;
  sub_1002B6DD(&v10);
  return 1;
}
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);
// 10073200: using guessed type int __security_cookie;

//----- (10024570) --------------------------------------------------------
void __thiscall sub_10024570(void *this, int a2, int a3)
{
  int v3; // ecx@1
  int ebp0; // ebp@0
  void *v5; // esi@1
  int v6; // eax@3
  int v7; // edx@6
  int v8; // eax@8
  int v9; // esi@8
  int v10; // ecx@8
  int v11; // eax@12
  unsigned int v12; // [sp-4Ch] [bp-90h]@8
  void *v13; // [sp-48h] [bp-8Ch]@8
  int *v14; // [sp-8h] [bp-4Ch]@8
  unsigned int v15; // [sp-4h] [bp-48h]@1
  int (__stdcall **v16)(char); // [sp+8h] [bp-3Ch]@2
  int v17; // [sp+14h] [bp-30h]@2
  char v18; // [sp+18h] [bp-2Ch]@7
  unsigned int v19; // [sp+34h] [bp-10h]@1
  int v20; // [sp+40h] [bp-4h]@1
  int v21; // [sp+44h] [bp+0h]@1

  v19 = (unsigned int)&v21 ^ __security_cookie;
  v15 = (unsigned int)&v21 ^ __security_cookie;
  v5 = this;
  sub_1002B589(ebp0, (int)((char *)this + 176));
  v3 = a3;
  v20 = 0;
  if ( !a3 )
  {
    v17 = (int)"_PTarget";
    sub_1002AEA4((int)&v16, &v17);
    v16 = &off_1005F2EC;
    sub_100355BB((int)&v16, (int)&unk_1006C8B4);
  }
  v6 = *((_DWORD *)v5 + 1);
  if ( v6 && v3 == v6 )
  {
    if ( (*(int (__thiscall **)(void *, int, unsigned int))(*(_DWORD *)v5 + 56))(v5, a2, v15) )
    {
      v7 = *(_DWORD *)v5;
      *((_DWORD *)v5 + 1) = 0;
      (*(void (__thiscall **)(void *))(v7 + 64))(v5);
    }
    v20 = -1;
    sub_1002B6DD(&v18);
  }
  else
  {
    sub_1002FF15((int)&v16);
    sub_100355BB((int)&v16, (int)&unk_1006C99C);
    __asm { int     3               ; Trap to Debugger }
    v14 = &v21;
    v19 = (unsigned int)&v21 ^ __security_cookie;
    v13 = v5;
    v12 = (unsigned int)&v21 ^ __security_cookie;
    v9 = v10;
    sub_1002B589((int)&v14, v10 + 176);
    v8 = a3;
    v20 = 0;
    if ( !a3 )
    {
      v17 = (int)"_PTarget";
      sub_1002AEA4((int)&v16, &v17);
      v16 = &off_1005F2EC;
      sub_100355BB((int)&v16, (int)&unk_1006C8B4);
    }
    if ( v8 != *(_DWORD *)(v9 + 4) )
    {
      sub_1002FF15((int)&v16);
      sub_100355BB((int)&v16, (int)&unk_1006C99C);
    }
    (*(void (__thiscall **)(int, int, unsigned int, void *))(*(_DWORD *)v9 + 60))(v9, a2, v12, v13);
    v11 = *(_DWORD *)v9;
    *(_DWORD *)(v9 + 4) = 0;
    (*(void (__thiscall **)(int))(v11 + 64))(v9);
    v20 = -1;
    sub_1002B6DD(&v18);
  }
}
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);
// 10073200: using guessed type int __security_cookie;

//----- (10024720) --------------------------------------------------------
int __thiscall sub_10024720(void *this, int a2)
{
  int result; // eax@1

  _ECX = (int)((char *)this + 216);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (10024740) --------------------------------------------------------
int __thiscall sub_10024740(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1
  int result; // eax@3
  char v11; // [sp+8h] [bp-2Ch]@2
  unsigned int v12; // [sp+24h] [bp-10h]@1
  int v13; // [sp+30h] [bp-4h]@2
  int v14; // [sp+34h] [bp+0h]@1

  v12 = (unsigned int)&v14 ^ __security_cookie;
  v3 = this;
  if ( a2 )
  {
    sub_1002B589(ebp0, (int)((char *)this + 176));
    v13 = 0;
    (*(void (__thiscall **)(void *, int))(*(_DWORD *)v3 + 44))(v3, a2);
    v13 = -1;
    sub_1002B6DD(&v11);
  }
  result = (int)((char *)v3 + 216);
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  return result;
}
// 10073200: using guessed type int __security_cookie;

//----- (100247D0) --------------------------------------------------------
int __thiscall sub_100247D0(void *this, int a2)
{
  int result; // eax@2

  if ( !*((_DWORD *)this + 1) )
    result = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)this + 76))(0);
  return result;
}

//----- (100247E0) --------------------------------------------------------
int __thiscall sub_100247E0(void *this, int a2)
{
  int result; // eax@2

  if ( *((_DWORD *)this + 1) == a2 )
    result = (*(int (__stdcall **)(_DWORD, int))(*(_DWORD *)this + 28))(*((_DWORD *)this + 2), a2);
  return result;
}

//----- (10024860) --------------------------------------------------------
int __thiscall sub_10024860(int this)
{
  return (*(int (**)(void))(*(_DWORD *)(this + 24) + 4))();
}

//----- (10024870) --------------------------------------------------------
int __thiscall sub_10024870(int this)
{
  return (**(int (***)(void))(this + 24))();
}

//----- (100248A0) --------------------------------------------------------
int __thiscall sub_100248A0(int this, int a2)
{
  sub_10026000(a2, this, this);
  return a2;
}

//----- (100248C0) --------------------------------------------------------
void *__userpurge sub_100248C0<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_100230C0(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100248F0) --------------------------------------------------------
void *__thiscall sub_100248F0(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_10023230(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10024920) --------------------------------------------------------
void *__thiscall sub_10024920(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10068320;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10068320: using guessed type int (__stdcall *off_10068320)(char);

//----- (10024950) --------------------------------------------------------
void *__userpurge sub_10024950<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_10023430(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10024980) --------------------------------------------------------
void *__thiscall sub_10024980(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10068264;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10068264: using guessed type int (__stdcall *off_10068264)(char);

//----- (100249B0) --------------------------------------------------------
void *__userpurge sub_100249B0<eax>(void *a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = a1;
  sub_100238D0(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100249E0) --------------------------------------------------------
void *__userpurge sub_100249E0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  void *v4; // esi@1

  v4 = (void *)a1;
  sub_10023D90(a1, a2, a3);
  if ( a4 & 1 )
    sub_1002A4AA(v4);
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10024A60) --------------------------------------------------------
void *__userpurge sub_10024A60<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  void *v4; // esi@1

  v4 = (void *)a1;
  sub_10024130(a1, a2, a3);
  if ( a4 & 1 )
    sub_1002A4AA(v4);
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10024B00) --------------------------------------------------------
int __thiscall sub_10024B00(int this)
{
  int v1; // edi@1
  int v2; // esi@1
  int i; // ebx@2
  int result; // eax@6

  v1 = this;
  v2 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    for ( i = *(_DWORD *)(this + 4); v2 != i; v2 += 4 )
    {
      if ( *(_DWORD *)v2 )
        (***(void (__stdcall ****)(_DWORD))v2)(1);
    }
    result = sub_1002A4AA(*(LPVOID *)v1);
    *(_DWORD *)v1 = 0;
    *(_DWORD *)(v1 + 4) = 0;
    *(_DWORD *)(v1 + 8) = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10024BC0) --------------------------------------------------------
int __thiscall sub_10024BC0(int this)
{
  int v1; // edi@1
  int v2; // esi@1
  int i; // ebx@2
  int v4; // ecx@3
  int result; // eax@7

  v1 = this;
  v2 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    for ( i = *(_DWORD *)(this + 4); v2 != i; v2 += 8 )
    {
      v4 = *(_DWORD *)(v2 + 4);
      if ( v4 )
      {
        _EAX = v4 + 8;
        _EDX = -1;
        __asm { lock xadd [eax], edx }
        if ( _ZF )
          (*(void (__fastcall **)(int, int))(*(_DWORD *)v4 + 4))(v4, _EDX);
      }
    }
    result = sub_1002A4AA(*(LPVOID *)v1);
    *(_DWORD *)v1 = 0;
    *(_DWORD *)(v1 + 4) = 0;
    *(_DWORD *)(v1 + 8) = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10024CD0) --------------------------------------------------------
char __thiscall sub_10024CD0(int this, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // esi@1
  int v5; // ecx@2
  char result; // al@5
  int v7; // eax@6

  v4 = this;
  v2 = 0;
  v3 = *(_DWORD *)(this + 12);
  if ( v3 )
  {
    v5 = *(_DWORD *)(this + 8);
    while ( *(_DWORD *)v5 != a2 )
    {
      ++v2;
      v5 += 4;
      if ( v2 >= v3 )
        goto LABEL_5;
    }
    *(_DWORD *)(*(_DWORD *)(v4 + 8) + 4 * v2) = 0;
    v7 = *(_DWORD *)(v4 + 4);
    if ( v7 != -1 )
    {
      if ( v7 )
        *(_DWORD *)(v4 + 4) = 0;
    }
    result = 1;
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (10024D60) --------------------------------------------------------
int __usercall sub_10024D60<eax>(int a1<ecx>, int a2<ebx>)
{
  int v3; // edi@1
  int v4; // edx@1

  v3 = a1;
  *(_DWORD *)a1 = &off_100682F4;
  sub_1002B52D(a1 + 4);
  *(_DWORD *)(v3 + 44) = 0;
  *(_DWORD *)(v3 + 48) = 0;
  *(_DWORD *)(v3 + 52) = 0;
  *(_DWORD *)(v3 + 56) = 0;
  *(_DWORD *)(v3 + 60) = off_10068380;
  *(_DWORD *)(v3 + 64) = -1;
  *(_DWORD *)(v3 + 68) = 0;
  *(_DWORD *)(v3 + 72) = 0;
  *(_DWORD *)(v3 + 76) = 0;
  *(_DWORD *)(v3 + 80) = 0;
  *(_DWORD *)(v3 + 84) = 0;
  *(_BYTE *)(v3 + 88) = 0;
  sub_10025950(v3 + 96, v4);
  sub_10031064(a2, v3, 0, v3, (unsigned __int64)v3 >> 32, v3 + 96, (unsigned __int64)(v3 + 96) >> 32);
  return v3;
}
// 100682F4: using guessed type int (__stdcall *off_100682F4)(char);
// 10068380: using guessed type int (__stdcall *off_10068380[3])(int);

//----- (10024E30) --------------------------------------------------------
int __thiscall sub_10024E30(int this, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  void **v5; // [sp+Ch] [bp-28h]@1
  int v6; // [sp+10h] [bp-24h]@1
  int *v7; // [sp+1Ch] [bp-18h]@1
  int v8; // [sp+30h] [bp-4h]@1

  v4 = this;
  v5 = &off_10067F68;
  v6 = this;
  v7 = (int *)&v5;
  v8 = 1;
  result = sub_100259F0(this + 96, 0, this, (int)&v5);
  v8 = -1;
  if ( v7 )
  {
    result = (*(int (__stdcall **)(bool))(*v7 + 16))((void ***)v7 != &v5);
    v7 = 0;
  }
  *(_DWORD *)(v4 + 80) = v4;
  return result;
}
// 10067F68: using guessed type void *off_10067F68;

//----- (10024ED0) --------------------------------------------------------
int __thiscall sub_10024ED0(int this)
{
  int result; // eax@1
  void **v2; // [sp+8h] [bp-40h]@1
  int v3; // [sp+Ch] [bp-3Ch]@1
  int *v4; // [sp+18h] [bp-30h]@1
  char v5; // [sp+20h] [bp-28h]@1
  int v6; // [sp+30h] [bp-18h]@1
  int v7; // [sp+44h] [bp-4h]@1

  v6 = 0;
  v7 = 0;
  v2 = &off_10067F4C;
  v3 = this;
  v4 = (int *)&v2;
  LOBYTE(v7) = 2;
  result = (*(int (__stdcall **)(void ***, char *))(*(_DWORD *)(this + 96) + 20))(&v2, &v5);
  LOBYTE(v7) = 0;
  if ( v4 )
  {
    result = (*(int (__stdcall **)(bool))(*v4 + 16))((void ***)v4 != &v2);
    v4 = 0;
  }
  v7 = -1;
  if ( v6 )
    result = (*(int (__stdcall **)(bool))(*(_DWORD *)v6 + 16))(v6 != (_DWORD)&v5);
  return result;
}
// 10067F4C: using guessed type void *off_10067F4C;

//----- (10024F90) --------------------------------------------------------
int __thiscall sub_10024F90(void *this)
{
  void *v1; // esi@1

  v1 = this;
  sub_10023230((int)((char *)this + 56));
  if ( *((_DWORD *)v1 + 11) )
  {
    sub_100303A3(*((LPVOID *)v1 + 11));
    *((_DWORD *)v1 + 11) = 0;
    *((_DWORD *)v1 + 12) = 0;
    *((_DWORD *)v1 + 13) = 0;
  }
  return nullsub_2(v1);
}
// 1002C171: using guessed type int __thiscall nullsub_2(_DWORD);
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (10025010) --------------------------------------------------------
char __thiscall sub_10025010(int this, int a2)
{
  int ebp0; // ebp@0
  int v3; // edi@1
  int v4; // esi@1
  unsigned int v6; // eax@7
  int v7; // [sp+Ch] [bp-34h]@1
  char v8; // [sp+13h] [bp-2Dh]@2
  char v9; // [sp+14h] [bp-2Ch]@3
  unsigned int v10; // [sp+30h] [bp-10h]@1
  int v11; // [sp+3Ch] [bp-4h]@2
  int v12; // [sp+40h] [bp+0h]@1

  v10 = (unsigned int)&v12 ^ __security_cookie;
  v4 = this;
  v3 = 0;
  v7 = *(_DWORD *)(this + 76);
  if ( !a2 )
    return 0;
  sub_1002B589(ebp0, this);
  v11 = 0;
  v8 = (*(int (__stdcall **)(int))(*(_DWORD *)(v4 + 56) + 4))(a2);
  if ( !v8 )
  {
    v11 = -1;
    sub_1002B6DD(&v9);
    return 0;
  }
  if ( *(_DWORD *)(v4 + 40) )
  {
    v6 = *(_DWORD *)(v4 + 48);
    if ( v6 >= *(_DWORD *)(v4 + 52) )
      sub_10025D20(v4 + 44, 0, 2 * v6 + 2);
    *(_DWORD *)(*(_DWORD *)(v4 + 44) + 4 * *(_DWORD *)(v4 + 48)++) = a2;
  }
  else
  {
    v3 = a2;
  }
  v11 = -1;
  sub_1002B6DD(&v9);
  if ( v3 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 36))(v3, v7);
  return v8;
}
// 10073200: using guessed type int __security_cookie;

//----- (100250F0) --------------------------------------------------------
int __thiscall sub_100250F0(int this, int a2)
{
  *(_DWORD *)a2 = &off_10068020;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = this;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  sub_10025D80(this, a2 + 4);
  return a2;
}
// 10068020: using guessed type int (__stdcall *off_10068020)(char);

//----- (10025170) --------------------------------------------------------
char __thiscall sub_10025170(void *this)
{
  char result; // al@1
  int v2; // esi@1
  int v3; // [sp+4h] [bp-8h]@1
  unsigned int v4; // [sp+8h] [bp-4h]@1
  int v5; // [sp+Ch] [bp+0h]@1

  v4 = (unsigned int)&v5 ^ __security_cookie;
  v2 = (int)((char *)this + 4);
  v3 = 0;
  for ( result = sub_1002A0FD((int)((char *)this + 4), (int)&v3); result; result = sub_1002A0FD(v2, (int)&v3) )
  {
    if ( v3 )
      (*(void (__stdcall **)(signed int))(*(_DWORD *)v3 + 4))(1);
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;

//----- (100251D0) --------------------------------------------------------
void __thiscall sub_100251D0(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v3; // edi@1
  int v4; // ecx@2
  int v5; // eax@3

  v3 = this;
  sub_1002B544(ebp0, (int)((char *)this + 24));
  if ( *((_DWORD *)v3 + 17) )
  {
    if ( a2 )
      (*(void (__thiscall **)(int, signed int))(*(_DWORD *)a2 + 4))(a2, 1);
  }
  else
  {
    v4 = (int)((char *)v3 + 56);
    if ( *((_DWORD *)v3 + 14) > 0 )
    {
      v5 = *(_DWORD *)v4;
      *(_DWORD *)v4 = 0;
      loc_10025A70(v3, v5);
    }
    loc_10025B00(v3, a2);
  }
  sub_1002B6D6();
}

//----- (100253C0) --------------------------------------------------------
int __cdecl sub_100253C0(int a1)
{
  return (*(int (**)(void))(*(_DWORD *)a1 + 12))();
}

//----- (100253D0) --------------------------------------------------------
int __usercall sub_100253D0<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // eax@1
  int v3; // edi@1
  int v4; // esi@1
  int result; // eax@2

  v3 = a1;
  v2 = sub_1002CB88(a2, a1, 0x14u);
  v4 = v2;
  if ( v2 )
  {
    *(_DWORD *)(v2 + 12) = 0;
    sub_1002A371(v2);
    *(_DWORD *)v4 = &off_10068024;
    *(_DWORD *)(v4 + 8) = *(_DWORD *)(v3 + 248);
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    result = v4;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10068024: using guessed type int (*off_10068024)();

//----- (10025470) --------------------------------------------------------
int __thiscall sub_10025470(int this, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // ecx@1
  int v10; // [sp+Ch] [bp-8h]@1
  unsigned int v11; // [sp+10h] [bp-4h]@1
  int v12; // [sp+14h] [bp+0h]@1

  v11 = (unsigned int)&v12 ^ __security_cookie;
  v7 = this;
  v10 = 0;
  *(_DWORD *)(this + 240) = 0;
  *(_DWORD *)(this + 248) = *(_DWORD *)a2;
  *(_WORD *)(this + 252) = 0;
  *(_DWORD *)(this + 244) = 0;
  sub_1002FEDB(this, a3, this, (int)&v10);
  v8 = v10;
  sub_10034890(&v10);
  *(_BYTE *)(v7 + 253) = 1;
  *(_DWORD *)(v7 + 256) = v8;
  result = sub_10025B70(v7 + 16, v8, v9);
  if ( a3 )
    result = (*(int (__thiscall **)(int, int))(*(_DWORD *)(v7 + 16) + 4))(v7 + 16, a3);
  return result;
}
// 10073200: using guessed type int __security_cookie;

//----- (10025510) --------------------------------------------------------
int __usercall sub_10025510<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v4; // edi@1

  v4 = a2;
  *(_DWORD *)a2 = &off_10068108;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = -1;
  *(_DWORD *)(a2 + 12) = &off_10068168;
  *(_DWORD *)(a2 + 16) = 0;
  sub_10025950(a2 + 24, a1);
  sub_1002B52D(v4 + 176);
  *(_DWORD *)(v4 + 216) = 0;
  sub_10031064(a3, v4, 0, v4, (unsigned __int64)v4 >> 32, v4 + 24, (unsigned __int64)(v4 + 24) >> 32);
  return v4;
}
// 10068108: using guessed type int (__stdcall *off_10068108)(char);
// 10068168: using guessed type void *off_10068168;

//----- (100255C0) --------------------------------------------------------
int __thiscall sub_100255C0(int this)
{
  int v1; // ecx@1
  int v2; // esi@1
  int result; // eax@3

  v2 = this;
  *(_DWORD *)this = &off_10068020;
  v1 = *(_DWORD *)(this + 16);
  if ( v1 )
    sub_10025860(v1);
  result = *(_DWORD *)(v2 + 4);
  if ( result )
  {
    result = sub_100303A3(*(LPVOID *)(v2 + 4));
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
    *(_DWORD *)(v2 + 12) = 0;
  }
  return result;
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 10068020: using guessed type int (__stdcall *off_10068020)(char);

//----- (10025640) --------------------------------------------------------
int __userpurge sub_10025640<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  int v4; // esi@1

  v4 = a1;
  *(_DWORD *)a1 = &off_10068024;
  if ( a4 & 1 )
    sub_1002CC4D(a2, a3, a1);
  return v4;
}
// 10068024: using guessed type int (*off_10068024)();

//----- (10025670) --------------------------------------------------------
int __thiscall sub_10025670(int this, char a2)
{
  int v2; // ecx@1
  int v3; // esi@1

  v3 = this;
  *(_DWORD *)this = &off_10068020;
  v2 = *(_DWORD *)(this + 16);
  if ( v2 )
    sub_10025860(v2);
  if ( *(_DWORD *)(v3 + 4) )
  {
    sub_100303A3(*(LPVOID *)(v3 + 4));
    *(_DWORD *)(v3 + 4) = 0;
    *(_DWORD *)(v3 + 8) = 0;
    *(_DWORD *)(v3 + 12) = 0;
  }
  if ( a2 & 1 )
    sub_1002A4AA((LPVOID)v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 10068020: using guessed type int (__stdcall *off_10068020)(char);

//----- (100257B0) --------------------------------------------------------
int __fastcall sub_100257B0(int a1, int a2, unsigned int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@4
  int v6; // eax@6
  int v7; // ecx@7
  int result; // eax@13
  int v16; // [sp+Ch] [bp-8h]@4
  int v17; // [sp+10h] [bp-4h]@4

  v4 = 0;
  v3 = a1;
  if ( a3 )
  {
    if ( a3 > 0x1FFFFFFF || (v4 = sub_1002ADB1(a2, a1, a1, 0, 8 * a3), !v4) )
    {
      sub_10029530();
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_10025860);
    }
  }
  sub_10026900(*(_DWORD *)v3, *(_DWORD *)(v3 + 4), v4);
  v5 = *(_DWORD *)v3;
  v17 = *(_DWORD *)(v3 + 4);
  v16 = (*(_DWORD *)(v3 + 4) - *(_DWORD *)v3) >> 3;
  if ( *(_DWORD *)v3 )
  {
    if ( v5 != *(_DWORD *)(v3 + 4) )
    {
      v6 = *(_DWORD *)(v3 + 4);
      do
      {
        v7 = *(_DWORD *)(v5 + 4);
        if ( v7 )
        {
          _EAX = v7 + 8;
          _EDX = -1;
          __asm { lock xadd [eax], edx }
          if ( _ZF )
            (*(void (__fastcall **)(int, int))(*(_DWORD *)v7 + 4))(v7, _EDX);
          v6 = v17;
        }
        v5 += 8;
      }
      while ( v5 != v6 );
    }
    sub_1002A4AA(*(LPVOID *)v3);
  }
  *(_DWORD *)v3 = v4;
  *(_DWORD *)(v3 + 8) = v4 + 8 * a3;
  result = v4 + 8 * v16;
  *(_DWORD *)(v3 + 4) = result;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10025860) --------------------------------------------------------
void __thiscall sub_10025860(int this)
{
  int ebp0; // ebp@0
  int v2; // esi@1
  int v3; // esi@3
  int v4; // ebx@4
  int v5; // edi@4
  int v6; // eax@4
  unsigned int v7; // esi@6
  int v8; // [sp+Ch] [bp-3Ch]@1
  int v9; // [sp+10h] [bp-38h]@1
  int v10; // [sp+14h] [bp-34h]@1
  int v11; // [sp+18h] [bp-30h]@1
  char v12; // [sp+1Ch] [bp-2Ch]@6
  unsigned int v13; // [sp+38h] [bp-10h]@1
  int v14; // [sp+44h] [bp-4h]@1
  int v15; // [sp+48h] [bp+0h]@1

  v13 = (unsigned int)&v15 ^ __security_cookie;
  v2 = this;
  v8 = *(_DWORD *)(this + 76);
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v14 = 0;
  sub_1002B589(ebp0, this);
  --*(_DWORD *)(v2 + 40);
  if ( *(_DWORD *)(v2 + 40) || !*(_DWORD *)(v2 + 48) || (v3 = v2 + 44, (int *)v3 == &v9) )
  {
    v4 = v10;
    v5 = v9;
  }
  else
  {
    v5 = *(_DWORD *)v3;
    v4 = *(_DWORD *)(v3 + 4);
    v6 = *(_DWORD *)(v3 + 8);
    *(_DWORD *)v3 = 0;
    *(_DWORD *)(v3 + 4) = 0;
    *(_DWORD *)(v3 + 8) = 0;
    v9 = v5;
    v10 = v4;
    v11 = v6;
  }
  sub_1002B6DD(&v12);
  v7 = 0;
  if ( v4 )
  {
    do
      (*(void (__stdcall **)(int))(**(_DWORD **)(v5 + 4 * v7++) + 36))(v8);
    while ( v7 < v4 );
  }
  if ( v5 )
    sub_100303A3((LPVOID)v5);
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10025950) --------------------------------------------------------
int __fastcall sub_10025950(int a1, int a2)
{
  int v3; // edi@1

  v3 = a1;
  *(_DWORD *)a1 = &off_1006824C;
  sub_10029F48(a1 + 4, a2, 4u);
  *(_DWORD *)(v3 + 4) = off_10068008;
  sub_1002B511(v3 + 24);
  *(_DWORD *)(v3 + 56) = 0;
  *(_DWORD *)(v3 + 60) = 0;
  *(_DWORD *)(v3 + 64) = 0;
  *(_DWORD *)(v3 + 68) = 1;
  *(_DWORD *)(v3 + 72) = 0;
  *(_DWORD *)(v3 + 96) = 0;
  *(_DWORD *)(v3 + 120) = 0;
  *(_DWORD *)(v3 + 144) = 0;
  return v3;
}
// 10068008: using guessed type int (__stdcall *off_10068008[3])(int, int, int);
// 1006824C: using guessed type void *off_1006824C;

//----- (100259F0) --------------------------------------------------------
int __thiscall sub_100259F0(int this, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@2
  int v8; // ecx@4
  int v9; // eax@6

  result = a2;
  v6 = this;
  v5 = this + 80;
  *(_DWORD *)(this + 60) = a2;
  *(_DWORD *)(this + 64) = 0;
  if ( this + 80 != a4 )
  {
    v7 = *(_DWORD *)(this + 96);
    if ( v7 )
    {
      result = (*(int (__stdcall **)(bool))(*(_DWORD *)v7 + 16))(v7 != v5);
      *(_DWORD *)(v5 + 16) = 0;
    }
    v8 = *(_DWORD *)(a4 + 16);
    if ( !v8 )
    {
      *(_DWORD *)(v5 + 16) = 0;
      *(_DWORD *)(v6 + 68) = 0;
      return result;
    }
    v9 = *(_DWORD *)v8;
    if ( v8 == a4 )
    {
      result = (*(int (__stdcall **)(int))v9)(v5);
      *(_DWORD *)(v5 + 16) = result;
      *(_DWORD *)(v6 + 68) = 0;
      return result;
    }
    result = (*(int (__stdcall **)(_DWORD))v9)(0);
    *(_DWORD *)(v5 + 16) = result;
  }
  *(_DWORD *)(v6 + 68) = 0;
  return result;
}

//----- (10025B70) --------------------------------------------------------
int __thiscall sub_10025B70(int this, int a2, int a3)
{
  int result; // eax@1
  void **v4; // [sp+4h] [bp-28h]@1
  int v5; // [sp+8h] [bp-24h]@1
  int *v6; // [sp+14h] [bp-18h]@1
  int v7; // [sp+28h] [bp-4h]@1

  v4 = &off_10067F30;
  v5 = this;
  v6 = (int *)&v4;
  v7 = 1;
  result = sub_100259F0(this + 24, a2, this, (int)&v4);
  v7 = -1;
  if ( v6 )
    result = (*(int (__stdcall **)(bool))(*v6 + 16))((void ***)v6 != &v4);
  return result;
}
// 10067F30: using guessed type void *off_10067F30;

//----- (10025C00) --------------------------------------------------------
char __thiscall sub_10025C00(int this, int a2)
{
  int v2; // eax@1
  int v3; // esi@1
  char v4; // zf@1
  char v5; // zf@3
  char v6; // zf@5
  DWORD v7; // eax@12
  char v9; // [sp+8h] [bp-18h]@1
  DWORD v10; // [sp+Ch] [bp-14h]@3
  int v11; // [sp+10h] [bp-10h]@4
  int v12; // [sp+14h] [bp-Ch]@1
  int (*v13)(void); // [sp+18h] [bp-8h]@1
  unsigned int v14; // [sp+1Ch] [bp-4h]@1

  v2 = (unsigned int)&v9 ^ __security_cookie;
  v14 = (unsigned int)&v9 ^ __security_cookie;
  v3 = this;
  v4 = *(_DWORD *)(this + 216) == 0;
  v12 = 0;
  v13 = sub_10034BF4;
  if ( !v4 )
  {
    do
    {
      v2 = v12;
      switch ( v12 )
      {
        case 1:
          __asm { pause                   ; jumptable 10025C4D case 1 }
          v5 = v10-- == 1;
          if ( v5 )
          {
            v2 = 3 - (v11 != 0);
            v12 = 3 - (v11 != 0);
          }
          break;
        case 2:
          v6 = v11-- == 1;
          if ( v6 )
            v2 = 3;
          v12 = v2;
          goto LABEL_8;
        case 4:
LABEL_8:
          LOBYTE(v2) = v13();
          break;
        case 3:
          v12 = 0;
          v2 = sub_1002BD65();
          if ( v2 )
          {
            v10 = v2;
            v11 = 1;
            v12 = 1;
          }
          else
          {
            v12 = 4;
          }
          break;
        case 0:
          v12 = 0;
          v7 = sub_1002BD65();
          if ( v7 )
          {
            v10 = v7;
            v11 = 1;
            v12 = 1;
          }
          else
          {
            v12 = 4;
          }
          LOBYTE(v2) = sub_100282E0((int)&v10);
          break;
        default:
          break;
      }
    }
    while ( *(_DWORD *)(v3 + 216) );
  }
  return v2;
}
// 10073200: using guessed type int __security_cookie;

//----- (10025D20) --------------------------------------------------------
int __userpurge sub_10025D20<eax>(int a1<ecx>, int a2<edi>, int a3)
{
  int result; // eax@1
  int v4; // edi@1
  int v5; // esi@1
  signed __int64 v7; // qax@1
  unsigned int v8; // ecx@2

  v5 = a1;
  _ECX = 0;
  v7 = 4i64 * (unsigned int)a3;
  __asm { seto    cl }
  result = sub_1002965B(SHIDWORD(v7), v7 | -_ECX, a3, a2, v7 | -_ECX);
  v4 = result;
  if ( *(_DWORD *)v5 )
  {
    v8 = 0;
    if ( *(_DWORD *)(v5 + 8) )
    {
      do
      {
        ++v8;
        *(_DWORD *)(result + 4 * v8 - 4) = *(_DWORD *)(*(_DWORD *)v5 + 4 * v8 - 4);
      }
      while ( v8 < *(_DWORD *)(v5 + 8) );
    }
    result = sub_100303A3(*(LPVOID *)v5);
  }
  *(_DWORD *)v5 = v4;
  *(_DWORD *)(v5 + 8) = a3;
  return result;
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (10025D80) --------------------------------------------------------
void __thiscall sub_10025D80(int this, int a2)
{
  int ebp0; // ebp@0
  unsigned int v3; // ST04_4@1
  int v4; // edi@1
  int v5; // eax@1
  int v6; // edi@2
  unsigned int v7; // eax@3
  int v8; // edx@3
  int v9; // ebx@4
  int v10; // edi@4
  __int64 v12; // qax@4
  unsigned int v13; // ecx@5
  int v14; // ecx@9
  char v15; // [sp+Ch] [bp-38h]@10
  int v16; // [sp+28h] [bp-1Ch]@1
  int v17; // [sp+2Ch] [bp-18h]@1
  int v18; // [sp+30h] [bp-14h]@1
  unsigned int v19; // [sp+34h] [bp-10h]@1
  int v20; // [sp+40h] [bp-4h]@1
  int v21; // [sp+44h] [bp+0h]@1

  v19 = (unsigned int)&v21 ^ __security_cookie;
  v3 = (unsigned int)&v21 ^ __security_cookie;
  v4 = this;
  sub_1002B589(ebp0, this);
  v20 = 0;
  ++*(_DWORD *)(v4 + 40);
  v5 = *(_DWORD *)(v4 + 56);
  v16 = 0;
  v18 = 0;
  (*(void (__thiscall **)(int, int *, unsigned int))(v5 + 16))(v4 + 56, &v16, v3);
  v18 = (*(int (__stdcall **)(int))(*(_DWORD *)v16 + 24))(v17);
  if ( v18 )
  {
    v6 = 4;
    do
    {
      v8 = (*(int (__stdcall **)(int))(*(_DWORD *)v16 + 24))(v17);
      v7 = *(_DWORD *)(a2 + 4);
      v18 = v8;
      if ( v7 >= *(_DWORD *)(a2 + 8) )
      {
        v9 = 2 * v7 + 2;
        _ECX = 0;
        v12 = v6 * (2 * v7 + 2);
        __asm { seto    cl }
        v10 = sub_1002965B(SHIDWORD(v12), v12 | -_ECX, v9, v6, v12 | -_ECX);
        if ( *(_DWORD *)a2 )
        {
          v13 = 0;
          if ( *(_DWORD *)(a2 + 8) )
          {
            do
            {
              ++v13;
              *(_DWORD *)(v10 + 4 * v13 - 4) = *(_DWORD *)(*(_DWORD *)a2 + 4 * v13 - 4);
            }
            while ( v13 < *(_DWORD *)(a2 + 8) );
          }
          sub_100303A3(*(LPVOID *)a2);
        }
        v8 = v18;
        *(_DWORD *)a2 = v10;
        *(_DWORD *)(a2 + 8) = v9;
        v6 = 4;
      }
      *(_DWORD *)(*(_DWORD *)a2 + 4 * *(_DWORD *)(a2 + 4)) = v8;
      v14 = v16;
      ++*(_DWORD *)(a2 + 4);
      ++v17;
      (*(void (__stdcall **)(int *))(*(_DWORD *)v14 + 20))(&v17);
      v18 = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)v16 + 24))(v17);
    }
    while ( v18 );
  }
  v20 = -1;
  sub_1002B6DD(&v15);
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10025ED0) --------------------------------------------------------
void *__userpurge sub_10025ED0<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_10025F00(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10025F00) --------------------------------------------------------
void __usercall sub_10025F00(int a1<ecx>, int a2<ebx>)
{
  int v2; // esi@1

  v2 = a1;
  *(_DWORD *)a1 = off_10068008;
  if ( !sub_1002A09A(a1) )
  {
    while ( sub_1002A0FD(v2, 0) && !sub_1002A09A(v2) )
      ;
  }
  sub_1002A0BD((void *)v2);
  sub_10029FBF(v2, a2);
}
// 10068008: using guessed type int (__stdcall *off_10068008[3])(int, int, int);

//----- (10025F80) --------------------------------------------------------
int __fastcall sub_10025F80(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // ST08_4@1
  int v6; // ST0C_4@1
  int v7; // ST10_4@1
  int v8; // ST14_4@1
  void *v9; // [sp+Ch] [bp+4h]@1

  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  sub_10026260(a1, a2, a3, a4, v5, v6, v7, v8);
  result = a3;
  *(_DWORD *)(*(_DWORD *)a3 + 148) = v9;
  return result;
}

//----- (10025FC0) --------------------------------------------------------
int __userpurge sub_10025FC0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5)
{
  int result; // eax@1
  int v6; // ST08_4@1
  int v7; // ST0C_4@1
  int v8; // ST10_4@1
  int v9; // ST14_4@1
  void *v10; // [sp+Ch] [bp+4h]@1

  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_10026350(a1, a2, a3, a4, a5, v6, v7, v8, v9);
  result = a4;
  *(_DWORD *)(*(_DWORD *)a4 + 148) = v10;
  return result;
}

//----- (10026000) --------------------------------------------------------
int __thiscall sub_10026000(int this, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // esi@1
  int v5; // ecx@2
  int v9; // [sp+10h] [bp+8h]@1

  v4 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  v3 = *(_DWORD *)(a2 + 4);
  v9 = *(_DWORD *)a2;
  if ( v3 )
  {
    v5 = *(_DWORD *)(v3 + 4);
    _EDI = v3 + 4;
    if ( v5 )
    {
      while ( 1 )
      {
        _EDX = v5 + 1;
        __asm { lock cmpxchg [edi], edx }
        if ( v5 == v5 )
          break;
        v5 = *(_DWORD *)_EDI;
        if ( !*(_DWORD *)_EDI )
          return v4;
      }
      sub_10026710(v4, v9, v3);
    }
  }
  return v4;
}

//----- (10026060) --------------------------------------------------------
char __thiscall sub_10026060(void *this, char a2, char a3, int a4, int a5)
{
  char v5; // bl@1
  int ebp0; // ebp@0
  int v7; // esi@1
  int v8; // eax@7
  int v10; // ecx@14
  char v11; // [sp+10h] [bp-4Ch]@1
  void **v12; // [sp+14h] [bp-48h]@18
  int v13; // [sp+18h] [bp-44h]@18
  int *v14; // [sp+24h] [bp-38h]@18
  unsigned int v15; // [sp+48h] [bp-14h]@1
  int v16; // [sp+58h] [bp-4h]@1

  v15 = (unsigned int)&v11 ^ __security_cookie;
  v7 = (int)this;
  v5 = 0;
  sub_1002B62D(ebp0, (int)((char *)this + 100));
  v16 = 0;
  if ( !a3 )
  {
    v8 = *(_DWORD *)(v7 + 84);
    if ( v8 != 3 && v8 != 4 )
    {
      if ( v8 != 2 )
        goto LABEL_4;
      if ( a2 )
      {
LABEL_13:
        *(_DWORD *)(v7 + 84) = 4;
        sub_1002C5B1(ebp0);
        v5 = 1;
        goto LABEL_14;
      }
    }
LABEL_11:
    v16 = -1;
    sub_1002B6D6();
    return 0;
  }
  if ( *(_DWORD *)(v7 + 84) == 4 )
    goto LABEL_11;
  sub_1000A140((void *)(v7 + 92), a5);
LABEL_4:
  if ( a2 || !*(_DWORD *)(v7 + 84) )
    goto LABEL_13;
  *(_DWORD *)(v7 + 84) = 2;
LABEL_14:
  v10 = *(_DWORD *)(v7 + 144);
  if ( v10 )
    sub_1002D593(v10 + 8, v5, a5);
  v16 = -1;
  sub_1002B6D6();
  if ( v5 )
  {
    sub_1002C5B1(ebp0);
    if ( *(_DWORD *)(v7 + 132) )
    {
      v12 = &off_10067F14;
      v13 = v7;
      v14 = (int *)&v12;
      v16 = 2;
      sub_10028360((int)&v12, a5);
      sub_10006050((int)&v12);
    }
  }
  return 1;
}
// 10067F14: using guessed type void *off_10067F14;
// 10073200: using guessed type int __security_cookie;

//----- (100261B0) --------------------------------------------------------
int __thiscall sub_100261B0(int this, char a2)
{
  int v2; // eax@1
  int ebp0; // ebp@0
  int v4; // esi@1
  int v5; // ecx@2

  v4 = this;
  *(_DWORD *)this = &off_10068000;
  v2 = *(_DWORD *)(this + 140);
  if ( v2 )
  {
    sub_1002B29A(ebp0, v2);
    v5 = *(_DWORD *)(v4 + 140);
    _EDX = -1;
    _EAX = v5 + 4;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      (*(void (**)(void))(*(_DWORD *)v5 + 4))();
    *(_DWORD *)(v4 + 140) = 0;
  }
  sub_1000A960(v4);
  if ( a2 & 1 )
    sub_1002A4AA((LPVOID)v4);
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10068000: using guessed type int (__stdcall *off_10068000)(char);

//----- (10026260) --------------------------------------------------------
int __fastcall sub_10026260(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // edi@1
  int v9; // esi@1
  int v10; // eax@3
  int v11; // esi@3
  int v12; // eax@4
  int v14; // [sp-8h] [bp-38h]@4
  int v15; // [sp-4h] [bp-34h]@3
  char v16; // [sp+14h] [bp-1Ch]@2
  int v17; // [sp+20h] [bp-10h]@1
  int v18; // [sp+2Ch] [bp-4h]@1

  v8 = a1;
  v18 = 0;
  v17 = 0;
  v9 = *(_DWORD *)a1;
  if ( !*(_DWORD *)a1 )
  {
    sub_1002FFB9((int)&v16, (unsigned int)"then() cannot be called on a default constructed task.");
    sub_100355BB((int)&v16, (int)&unk_1006C878);
  }
  v11 = *(_DWORD *)(v9 + 136);
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  sub_10006BC0(a2, a3, v8, a1);
  v18 = 0;
  v17 = 1;
  sub_10009800(a3, v11);
  *(_BYTE *)(*(_DWORD *)a3 + 88) = *(_BYTE *)(*(_DWORD *)v8 + 88) != 0;
  *(_BYTE *)(*(_DWORD *)a3 + 89) = 0;
  *(_BYTE *)(*(_DWORD *)a3 + 90) = 0;
  v10 = sub_1002CB88(a3, v8, 0x34u);
  if ( v10 )
    v12 = sub_100265C0(v10, v8, a3, a4, v14, v15);
  else
    v12 = 0;
  sub_10009430(*(void **)v8, v12);
  return a3;
}

//----- (10026350) --------------------------------------------------------
int __userpurge sub_10026350<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6, int a7, int a8, int a9)
{
  int v9; // edi@1
  int v10; // eax@3
  int v11; // eax@4
  int v13; // [sp-8h] [bp-30h]@4
  int v14; // [sp-4h] [bp-2Ch]@3
  char v15; // [sp+Ch] [bp-1Ch]@2
  int v16; // [sp+18h] [bp-10h]@1
  int v17; // [sp+24h] [bp-4h]@1

  v9 = a2;
  v17 = 0;
  v16 = 0;
  if ( !*(_DWORD *)a2 )
  {
    sub_1002FFB9((int)&v15, (unsigned int)"then() cannot be called on a default constructed task.");
    sub_100355BB((int)&v15, (int)&unk_1006C878);
  }
  *(_DWORD *)a4 = 0;
  *(_DWORD *)(a4 + 4) = 0;
  sub_10006BC0(a1, a4, v9, a2);
  v17 = 0;
  v16 = 1;
  sub_10026500(a4, 2);
  *(_BYTE *)(*(_DWORD *)a4 + 88) = *(_BYTE *)(*(_DWORD *)v9 + 88) != 0;
  *(_BYTE *)(*(_DWORD *)a4 + 89) = 0;
  *(_BYTE *)(*(_DWORD *)a4 + 90) = 0;
  v10 = sub_1002CB88(a3, v9, 0x40u);
  if ( v10 )
    v11 = sub_10026630(v10, v9, a4, a5, v13, v14);
  else
    v11 = 0;
  sub_10009430(*(void **)v9, v11);
  return a4;
}

//----- (10026430) --------------------------------------------------------
int __userpurge sub_10026430<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // edi@4
  int result; // eax@8
  char v23; // [sp+0h] [bp-24h]@1
  int v24; // [sp+10h] [bp-14h]@1
  char *v25; // [sp+14h] [bp-10h]@1
  int v26; // [sp+20h] [bp-4h]@1

  v25 = &v23;
  v5 = a2;
  v24 = a2;
  v26 = 0;
  v4 = sub_1002ADB1(a1, a2, a3, a2, 16);
  v6 = v4;
  if ( v4 )
  {
    *(_DWORD *)(v4 + 4) = 1;
    *(_DWORD *)(v4 + 8) = 1;
    *(_DWORD *)v4 = &off_10067FF0;
    *(_DWORD *)(v4 + 12) = a4;
  }
  else
  {
    v6 = 0;
  }
  v7 = *(_DWORD *)(v5 + 4);
  if ( v7 )
  {
    _ECX = v7 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v7)(v7);
      _EAX = v7 + 8;
      _ECX = -1;
      __asm { lock xadd [eax], ecx }
      if ( _ZF )
        (*(void (**)(void))(*(_DWORD *)v7 + 4))();
    }
  }
  result = v24;
  *(_DWORD *)(v24 + 4) = v6;
  *(_DWORD *)result = a4;
  return result;
}
// 10067FF0: using guessed type int (*off_10067FF0)();

//----- (10026500) --------------------------------------------------------
int __thiscall sub_10026500(int this, int a2)
{
  int result; // eax@1
  int v4; // ecx@1
  int v5; // ebx@1
  int v7; // esi@3
  int v19; // esi@7
  int v31; // esi@12
  char v32; // [sp+10h] [bp-14h]@1
  char v33; // [sp+18h] [bp-Ch]@1
  int v34; // [sp+1Ch] [bp-8h]@7

  v5 = this;
  result = sub_100266D0(a2, (int)&v33, this);
  v4 = 0;
  _EDX = 0;
  if ( &v32 != (char *)result )
  {
    _EDX = *(_DWORD *)(result + 4);
    *(_DWORD *)(result + 4) = 0;
    v4 = *(_DWORD *)result;
    *(_DWORD *)result = 0;
  }
  v7 = *(_DWORD *)(v5 + 4);
  _EDI = -1;
  *(_DWORD *)(v5 + 4) = _EDX;
  *(_DWORD *)v5 = v4;
  if ( v7 )
  {
    result = v7 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v7)(v7);
      result = v7 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v7 + 4))(v7, _EDX);
    }
  }
  v19 = v34;
  if ( v34 )
  {
    result = v34 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v19)(v19);
      result = v19 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v19 + 4))(v19);
    }
  }
  if ( a2 != 2 )
  {
    v31 = *(_DWORD *)v5;
    result = sub_1002B396(_EDX, *(_DWORD *)(*(_DWORD *)v5 + 136), v5, (int)sub_100097E0, *(_DWORD *)v5, 1);
    *(_DWORD *)(v31 + 140) = result;
  }
  return result;
}

//----- (100265C0) --------------------------------------------------------
int __thiscall sub_100265C0(int this, int a2, int a3, int a4, int a5, int a6)
{
  int v7; // esi@1

  v7 = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_BYTE *)(this + 25) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = &off_100670C8;
  sub_10004DE0(this + 32, a3);
  *(_DWORD *)(v7 + 4) = sub_10026A30;
  *(_BYTE *)(v7 + 16) = 1;
  *(_DWORD *)v7 = &off_100670D0;
  sub_10004DE0(v7 + 40, a2);
  *(_DWORD *)(v7 + 48) = *(_DWORD *)a4;
  *(_BYTE *)(v7 + 25) = 0;
  *(_DWORD *)(v7 + 28) = 0;
  return v7;
}
// 100670C8: using guessed type int (__stdcall *off_100670C8)(char);
// 100670D0: using guessed type int (__stdcall *off_100670D0)(char);

//----- (10026630) --------------------------------------------------------
int __thiscall sub_10026630(int this, int a2, int a3, int a4, int a5, int a6)
{
  _ESI = this;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_BYTE *)(this + 25) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = &off_100670C8;
  sub_10004DE0(this + 32, a3);
  *(_DWORD *)(_ESI + 4) = sub_10026A40;
  *(_BYTE *)(_ESI + 16) = 1;
  *(_DWORD *)_ESI = &off_100670D0;
  sub_10004DE0(_ESI + 40, a2);
  _EAX = a4;
  __asm
  {
    movq    xmm0, qword ptr [eax]
    movq    qword ptr [esi+30h], xmm0
    movq    xmm0, qword ptr [eax+8]
    movq    qword ptr [esi+38h], xmm0
  }
  *(_BYTE *)(_ESI + 25) = 1;
  *(_DWORD *)(_ESI + 28) = 0;
  return _ESI;
}
// 100670C8: using guessed type int (__stdcall *off_100670C8)(char);
// 100670D0: using guessed type int (__stdcall *off_100670D0)(char);

//----- (100266B0) --------------------------------------------------------
int __usercall sub_100266B0<eax>(int a1<ecx>, int a2<ebx>)
{
  void *v2; // esi@1
  int result; // eax@2

  v2 = *(void **)(a1 + 12);
  if ( v2 )
  {
    sub_10001EA0(*(_DWORD *)(a1 + 12), a2);
    result = sub_1002A4AA(v2);
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100266D0) --------------------------------------------------------
int __usercall sub_100266D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v4; // esi@1
  int v5; // [sp+8h] [bp-8h]@1
  unsigned int v6; // [sp+Ch] [bp-4h]@1
  int v7; // [sp+10h] [bp+0h]@1

  v6 = (unsigned int)&v7 ^ __security_cookie;
  v5 = a1;
  v4 = a2;
  sub_10026980((int)&v5, a2, a3);
  return v4;
}
// 10073200: using guessed type int __security_cookie;

//----- (10026710) --------------------------------------------------------
int __thiscall sub_10026710(int this, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int result; // eax@5

  v4 = this;
  v3 = *(_DWORD *)(this + 4);
  if ( v3 )
  {
    _EBX = -1;
    _EDX = v3 + 4;
    _EAX = -1;
    __asm { lock xadd [edx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v3)(v3);
      _EAX = v3 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
    }
    *(_DWORD *)(v4 + 4) = a3;
    result = a2;
    *(_DWORD *)v4 = a2;
  }
  else
  {
    *(_DWORD *)(this + 4) = a3;
    result = a2;
    *(_DWORD *)this = a2;
  }
  return result;
}

//----- (10026770) --------------------------------------------------------
char __usercall sub_10026770<al>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v3; // edi@1
  int v4; // esi@1
  char v5; // bl@3
  int (__stdcall **v7)(char); // [sp+Ch] [bp-88h]@5
  int v8; // [sp+10h] [bp-84h]@5
  int v9; // [sp+14h] [bp-80h]@5
  int v10; // [sp+18h] [bp-7Ch]@5
  int v11; // [sp+34h] [bp-60h]@5
  int v12; // [sp+38h] [bp-5Ch]@5
  int v13; // [sp+3Ch] [bp-58h]@5
  char v14; // [sp+40h] [bp-54h]@5
  int v15; // [sp+58h] [bp-3Ch]@5
  int v16; // [sp+5Ch] [bp-38h]@5
  void **v17; // [sp+68h] [bp-2Ch]@5
  int v18; // [sp+6Ch] [bp-28h]@5
  int v19; // [sp+70h] [bp-24h]@5
  int (__stdcall **v20)(char); // [sp+78h] [bp-1Ch]@3
  int v21; // [sp+7Ch] [bp-18h]@3
  int v22; // [sp+80h] [bp-14h]@3
  unsigned int v23; // [sp+84h] [bp-10h]@1
  int v24; // [sp+90h] [bp-4h]@3
  int v25; // [sp+94h] [bp+0h]@1

  v23 = (unsigned int)&v25 ^ __security_cookie;
  v3 = a1;
  v4 = a2;
  if ( a2
    && (unsigned __int8)(*(int (__cdecl **)(unsigned int))(*(_DWORD *)a2 + 12))((unsigned int)&v25 ^ __security_cookie) )
  {
    v20 = &off_10067FC8;
    v21 = 0;
    v22 = 0;
    v24 = 0;
    v5 = sub_10026E30((int)&v20, a3, v4, v3);
    v20 = &off_10067FC8;
    v24 = 1;
    if ( v21 )
      (*(void (__stdcall **)(signed int))(*(_DWORD *)v21 + 4))(1);
  }
  else
  {
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v15 = 0;
    v16 = 0;
    v18 = 0;
    v24 = 2;
    v7 = &off_10067FA0;
    v8 = 0;
    sub_1002C08B((int)&v9);
    LOBYTE(v24) = 3;
    v13 = 2;
    sub_1002B52D((int)&v14);
    v17 = &off_10068168;
    v18 = 0;
    v19 = 0;
    v24 = 4;
    v5 = sub_100273E0(&v7, v4, v3);
    v24 = -1;
    sub_10026F10(&v7);
  }
  return v5;
}
// 10067FA0: using guessed type int (__stdcall *off_10067FA0)(char);
// 10067FC8: using guessed type int (__stdcall *off_10067FC8)(char);
// 10068168: using guessed type void *off_10068168;
// 10073200: using guessed type int __security_cookie;

//----- (100268D0) --------------------------------------------------------
int __fastcall sub_100268D0(int a1, int a2, int a3)
{
  int result; // eax@1
  int i; // esi@1
  int v5; // edx@3

  result = a3;
  for ( i = a2; a1 != i; result += 4 )
  {
    if ( result )
    {
      v5 = *(_DWORD *)a1;
      *(_DWORD *)a1 = 0;
      *(_DWORD *)result = v5;
    }
    a1 += 4;
  }
  return result;
}

//----- (10026900) --------------------------------------------------------
int __fastcall sub_10026900(int a1, int a2, int a3)
{
  int v3; // edi@1
  int v4; // esi@2
  int v5; // ebx@4
  int v13; // ecx@6
  int result; // eax@12
  int v22; // [sp+4h] [bp-4h]@1
  int v23; // [sp+10h] [bp+8h]@4

  v3 = a1;
  v22 = a2;
  if ( a1 == a2 )
  {
    result = a3;
  }
  else
  {
    v4 = a3;
    do
    {
      if ( v4 )
      {
        *(_DWORD *)v4 = 0;
        *(_DWORD *)(v4 + 4) = 0;
        v5 = *(_DWORD *)(v3 + 4);
        v23 = *(_DWORD *)v3;
        if ( v5 )
        {
          _EAX = v5 + 8;
          _ECX = 1;
          __asm { lock xadd [eax], ecx }
        }
        v13 = *(_DWORD *)(v4 + 4);
        if ( v13 )
        {
          _EAX = v13 + 8;
          _EDX = -1;
          __asm { lock xadd [eax], edx }
          if ( _ZF )
            (*(void (__fastcall **)(int, int))(*(_DWORD *)v13 + 4))(v13, _EDX);
          a2 = v22;
        }
        *(_DWORD *)(v4 + 4) = v5;
        *(_DWORD *)v4 = v23;
      }
      v3 += 8;
      v4 += 8;
    }
    while ( v3 != a2 );
    result = v4;
  }
  return result;
}

//----- (10026980) --------------------------------------------------------
int __usercall sub_10026980<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v3; // eax@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ebx@2
  int *v8; // [sp+20h] [bp-10h]@1

  v8 = (int *)a1;
  v4 = a2;
  v3 = sub_1002ADB1(a1, a2, a3, a2, 168);
  v5 = v3;
  if ( v3 )
  {
    *(_DWORD *)(v3 + 4) = 1;
    *(_DWORD *)(v3 + 8) = 1;
    v6 = v3 + 12;
    *(_DWORD *)v3 = &off_100670FC;
    if ( v3 != -12 )
    {
      sub_10009600((void *)(v3 + 12), *v8);
      *(_DWORD *)v6 = &off_10068000;
    }
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)v4 = v5 + 12;
  *(_DWORD *)(v4 + 4) = v5;
  return v4;
}
// 100670FC: using guessed type int (*off_100670FC)();
// 10068000: using guessed type int (__stdcall *off_10068000)(char);

//----- (10026A30) --------------------------------------------------------
void __cdecl sub_10026A30(int a1)
{
  JUMPOUT(*(unsigned int *)loc_10026A50);
}
// 10026A50: using guessed type int __cdecl loc_10026A50(int);

//----- (10026A40) --------------------------------------------------------
int __usercall sub_10026A40<eax>(int a1<eax>, int a2)
{
  int v2; // esi@1
  int v4; // edx@4
  unsigned int v5; // [sp-18h] [bp-54h]@1
  int v6; // [sp-14h] [bp-50h]@3
  int v7; // [sp-10h] [bp-4Ch]@3
  int v8; // [sp-Ch] [bp-48h]@3
  char v9; // [sp-8h] [bp-44h]@3
  int v10; // [sp+0h] [bp-3Ch]@4
  int v11; // [sp+4h] [bp-38h]@4
  int v12; // [sp+8h] [bp-34h]@1
  unsigned int v13; // [sp+28h] [bp-14h]@1
  unsigned int *v14; // [sp+2Ch] [bp-10h]@1
  int v15; // [sp+30h] [bp-Ch]@1
  int (__cdecl *v16)(int, int); // [sp+34h] [bp-8h]@1
  int v17; // [sp+38h] [bp-4h]@1
  _DWORD *v18; // [sp+3Ch] [bp+0h]@1

  v18 = &v18;
  v17 = -1;
  v16 = sub_1005CE90;
  v15 = a1;
  v13 = (unsigned int)&v18 ^ __security_cookie;
  v5 = (unsigned int)&v18 ^ __security_cookie;
  v14 = &v5;
  v2 = *(_DWORD *)(a2 + 32);
  v12 = a2;
  sub_1002B62D((int)&v18, v2 + 100);
  v17 = -1;
  if ( *(_DWORD *)(v2 + 84) == 4 )
  {
    sub_1002B6D6();
  }
  else
  {
    *(_DWORD *)(v2 + 84) = 1;
    sub_1002B6D6();
    v17 = 1;
    LOBYTE(v10) = 0;
    LOBYTE(v11) = 0;
    sub_10027860(v4, a2, a2, v11, v10);
  }
  return sub_1002A49B(v8, v6, v7, (unsigned int)&v18 ^ v13, v9);
}
// 1005CE90: using guessed type int __cdecl sub_1005CE90(int, int);
// 10073200: using guessed type int __security_cookie;

//----- (10026C50) --------------------------------------------------------
int *__thiscall sub_10026C50(int this)
{
  int *result; // eax@1
  int v2; // ecx@1
  int v3; // esi@1
  int v4; // [sp+Ch] [bp-Ch]@1
  int v5; // [sp+14h] [bp-4h]@1

  result = &v4;
  v3 = this;
  *(_DWORD *)this = &off_10067FC8;
  v5 = 0;
  v2 = *(_DWORD *)(this + 4);
  if ( v2 )
    result = (int *)(*(int (__stdcall **)(signed int))(*(_DWORD *)v2 + 4))(1);
  *(_DWORD *)v3 = &off_10068320;
  return result;
}
// 10067FC8: using guessed type int (__stdcall *off_10067FC8)(char);
// 10068320: using guessed type int (__stdcall *off_10068320)(char);

//----- (10026D10) --------------------------------------------------------
int __thiscall sub_10026D10(int this, int a2, int a3)
{
  int result; // eax@2

  if ( a3 == *(_DWORD *)(this + 8) && (result = *(_DWORD *)(this + 4)) != 0 && *(_DWORD *)(result + 4) == a2 )
    *(_DWORD *)(this + 4) = 0;
  else
    result = 0;
  return result;
}

//----- (10026E30) --------------------------------------------------------
char __userpurge sub_10026E30<al>(int a1<ecx>, int a2<ebx>, int a3, int a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  int v8; // ecx@4

  v5 = a1;
  *(_DWORD *)(a1 + 8) = a3;
  v4 = sub_1002CB88(a2, a1, 0x14u);
  v6 = v4;
  if ( v4 )
  {
    *(_DWORD *)(v4 + 12) = 0;
    sub_1002A371(v4);
    *(_DWORD *)v6 = &off_10068024;
    *(_DWORD *)(v6 + 8) = *(_DWORD *)a4;
    *(_DWORD *)(v6 + 12) = 0;
    *(_DWORD *)(v6 + 16) = 0;
  }
  else
  {
    v6 = 0;
  }
  v8 = *(_DWORD *)(v5 + 8);
  *(_DWORD *)(v5 + 4) = v6;
  return (*(int (__cdecl **)(int, int))(*(_DWORD *)v8 + 8))(v6, v5) == 0;
}
// 10068024: using guessed type int (*off_10068024)();

//----- (10026F10) --------------------------------------------------------
int __thiscall sub_10026F10(void *this)
{
  int v1; // ecx@1
  int ebp0; // ebp@0
  int v3; // esi@1
  char v4; // zf@3
  int result; // eax@5
  char v6; // [sp+8h] [bp-1Ch]@4
  void *v7; // [sp+14h] [bp-10h]@1
  int v8; // [sp+20h] [bp-4h]@1

  v3 = (int)this;
  v7 = this;
  *(_DWORD *)this = &off_10067FA0;
  v8 = 3;
  sub_10027090(this);
  sub_10027610(v3);
  v1 = *(_DWORD *)(v3 + 4);
  if ( v1 )
    (*(void (__stdcall **)(signed int))(*(_DWORD *)v1 + 4))(1);
  LOBYTE(v8) = 2;
  v4 = *(_DWORD *)(v3 + 96) == 0;
  *(_DWORD *)(v3 + 92) = &off_10068168;
  if ( !v4 )
  {
    sub_1002FFB9((int)&v6, (unsigned int)"Deleting link registry before removing all the links");
    sub_100355BB((int)&v6, (int)&unk_1006C878);
  }
  LOBYTE(v8) = 1;
  nullsub_2(v3 + 52);
  LOBYTE(v8) = 0;
  result = sub_1002C0CE(ebp0);
  *(_DWORD *)v3 = &off_10068320;
  return result;
}
// 1002C171: using guessed type int __thiscall nullsub_2(_DWORD);
// 10067FA0: using guessed type int (__stdcall *off_10067FA0)(char);
// 10068168: using guessed type void *off_10068168;
// 10068320: using guessed type int (__stdcall *off_10068320)(char);

//----- (10026FD0) --------------------------------------------------------
void __thiscall sub_10026FD0(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1
  unsigned int v4; // [sp-4h] [bp-48h]@1
  int (__stdcall **v5)(char); // [sp+8h] [bp-3Ch]@2
  int v6; // [sp+14h] [bp-30h]@2
  char v7; // [sp+18h] [bp-2Ch]@5
  unsigned int v8; // [sp+34h] [bp-10h]@1
  int v9; // [sp+40h] [bp-4h]@3
  int v10; // [sp+44h] [bp+0h]@1

  v8 = (unsigned int)&v10 ^ __security_cookie;
  v4 = (unsigned int)&v10 ^ __security_cookie;
  v3 = this;
  if ( !a2 )
  {
    v6 = (int)"_PTarget";
    sub_1002AEA4((int)&v5, &v6);
    v5 = &off_1005F2EC;
    sub_100355BB((int)&v5, (int)&unk_1006C8B4);
  }
  sub_1002B589(ebp0, (int)((char *)v3 + 52));
  v9 = 0;
  if ( (unsigned __int8)(*(int (__stdcall **)(int, unsigned int))(*((_DWORD *)v3 + 23) + 4))(a2, v4) )
  {
    (*(void (__thiscall **)(int, void *))(*(_DWORD *)a2 + 20))(a2, v3);
    *((_DWORD *)v3 + 12) = 1;
    sub_1002C5B1(ebp0);
  }
  v9 = -1;
  sub_1002B6DD(&v7);
}
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);
// 10073200: using guessed type int __security_cookie;

//----- (10027090) --------------------------------------------------------
void __thiscall sub_10027090(void *this)
{
  int ebp0; // ebp@0
  void *v2; // edi@1
  unsigned int v3; // ST04_4@1
  int v4; // eax@1
  int v5; // esi@2
  int (__thiscall *v6)(_DWORD, _DWORD); // eax@2
  char v7; // [sp+Ch] [bp-38h]@5
  int v8; // [sp+28h] [bp-1Ch]@1
  int v9; // [sp+2Ch] [bp-18h]@1
  int i; // [sp+30h] [bp-14h]@1
  unsigned int v11; // [sp+34h] [bp-10h]@1
  int v12; // [sp+40h] [bp-4h]@1
  int v13; // [sp+44h] [bp+0h]@1

  v11 = (unsigned int)&v13 ^ __security_cookie;
  v3 = (unsigned int)&v13 ^ __security_cookie;
  v2 = this;
  sub_1002B589(ebp0, (int)((char *)this + 52));
  v12 = 0;
  v4 = *((_DWORD *)v2 + 23);
  v8 = 0;
  i = 0;
  (*(void (__thiscall **)(char *, int *, unsigned int))(v4 + 16))((char *)v2 + 92, &v8, v3);
  for ( i = (*(int (__stdcall **)(int))(*(_DWORD *)v8 + 24))(v9);
        i;
        i = (*(int (__stdcall **)(int))(*(_DWORD *)v8 + 24))(v9) )
  {
    v5 = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)v8 + 24))(v9);
    v6 = *(int (__thiscall **)(_DWORD, _DWORD))(*((_DWORD *)v2 + 23) + 4);
    i = v5;
    if ( (unsigned __int8)v6((char *)v2 + 92, v5) )
      (*(void (__thiscall **)(int, void *))(*(_DWORD *)v5 + 20))(v5, v2);
    ++v9;
    (*(void (__stdcall **)(int *))(*(_DWORD *)v8 + 20))(&v9);
  }
  *((_DWORD *)v2 + 12) = 1;
  sub_1002C5B1(ebp0);
  v12 = -1;
  sub_1002B6DD(&v7);
}
// 10073200: using guessed type int __security_cookie;

//----- (10027190) --------------------------------------------------------
int __thiscall sub_10027190(int this, int a2, int a3)
{
  int ebp0; // ebp@0
  int v4; // esi@1
  int result; // eax@2
  int v6; // edi@4

  v4 = this;
  if ( a3 && (unsigned __int8)(*(int (__thiscall **)(int, int))(*(_DWORD *)(this + 92) + 8))(this + 92, a3) )
  {
    v6 = *(_DWORD *)(v4 + 4);
    if ( v6 && *(_DWORD *)(v6 + 4) == a2 )
    {
      *(_DWORD *)(v4 + 4) = 0;
      *(_DWORD *)(v4 + 48) = 0;
      sub_1002C5B1(ebp0);
      result = v6;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100273C0) --------------------------------------------------------
int __thiscall sub_100273C0(void *this, int a2)
{
  int result; // eax@1

  _ECX = (int)((char *)this + 100);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (100273D0) --------------------------------------------------------
int __thiscall sub_100273D0(void *this, int a2)
{
  int result; // eax@1

  _ECX = (int)((char *)this + 100);
  _EAX = -1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (100273E0) --------------------------------------------------------
bool __thiscall sub_100273E0(void *this, int a2, int a3)
{
  int ebp0; // ebp@0
  int v4; // edi@1
  int v5; // eax@3
  int v6; // esi@3
  int v7; // esi@6
  unsigned int v9; // [sp-4h] [bp-4Ch]@1
  int (__stdcall **v10)(char); // [sp+Ch] [bp-3Ch]@2
  int v11; // [sp+18h] [bp-30h]@2
  char v12; // [sp+1Ch] [bp-2Ch]@6
  unsigned int v13; // [sp+38h] [bp-10h]@1
  int v14; // [sp+44h] [bp-4h]@3
  int v15; // [sp+48h] [bp+0h]@1

  v13 = (unsigned int)&v15 ^ __security_cookie;
  v9 = (unsigned int)&v15 ^ __security_cookie;
  v4 = (int)this;
  if ( !a2 )
  {
    v11 = (int)"_PTarget";
    sub_1002AEA4((int)&v10, &v11);
    v10 = &off_1005F2EC;
    sub_100355BB((int)&v10, (int)&unk_1006C8B4);
  }
  v5 = sub_1002CB88(a2, v4, 0x14u);
  v6 = v5;
  v11 = v5;
  v14 = 0;
  if ( v5 )
  {
    *(_DWORD *)(v5 + 12) = 0;
    sub_1002A371(v5);
    *(_DWORD *)v6 = &off_10068024;
    *(_DWORD *)(v6 + 8) = *(_DWORD *)a3;
    *(_DWORD *)(v6 + 12) = 0;
    *(_DWORD *)(v6 + 16) = 0;
  }
  else
  {
    v6 = 0;
  }
  v14 = -1;
  sub_1002B589(ebp0, v4 + 52);
  v14 = 1;
  (*(void (__thiscall **)(int, int, unsigned int))(*(_DWORD *)v4 + 4))(v4, a2, v9);
  *(_DWORD *)(v4 + 4) = v6;
  v7 = (*(int (__thiscall **)(int, int, int))(*(_DWORD *)a2 + 8))(a2, v6, v4);
  v14 = -1;
  sub_1002B6DD(&v12);
  if ( v7 == 2 )
  {
    sub_1002C6B2(ebp0, a2, v4, -1);
    v7 = *(_DWORD *)(v4 + 48);
  }
  return v7 == 0;
}
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);
// 10068024: using guessed type int (*off_10068024)();
// 10073200: using guessed type int __security_cookie;

//----- (10027570) --------------------------------------------------------
void *__thiscall sub_10027570(int this, char a2)
{
  int v2; // ecx@1
  void *v3; // esi@1

  v3 = (void *)this;
  *(_DWORD *)this = &off_10067FC8;
  v2 = *(_DWORD *)(this + 4);
  if ( v2 )
    (*(void (__stdcall **)(signed int))(*(_DWORD *)v2 + 4))(1);
  *(_DWORD *)v3 = &off_10068320;
  if ( a2 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067FC8: using guessed type int (__stdcall *off_10067FC8)(char);
// 10068320: using guessed type int (__stdcall *off_10068320)(char);

//----- (100275E0) --------------------------------------------------------
void *__thiscall sub_100275E0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_10026F10(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10027610) --------------------------------------------------------
char __thiscall sub_10027610(int this)
{
  int v1; // eax@1
  int v2; // esi@1
  char v3; // zf@1
  char v4; // zf@3
  char v5; // zf@5
  DWORD v6; // eax@12
  char v8; // [sp+8h] [bp-18h]@1
  DWORD v9; // [sp+Ch] [bp-14h]@3
  int v10; // [sp+10h] [bp-10h]@4
  int v11; // [sp+14h] [bp-Ch]@1
  int (*v12)(void); // [sp+18h] [bp-8h]@1
  unsigned int v13; // [sp+1Ch] [bp-4h]@1

  v1 = (unsigned int)&v8 ^ __security_cookie;
  v13 = (unsigned int)&v8 ^ __security_cookie;
  v2 = this;
  v3 = *(_DWORD *)(this + 100) == 0;
  v11 = 0;
  v12 = sub_10034BF4;
  if ( !v3 )
  {
    do
    {
      v1 = v11;
      switch ( v11 )
      {
        case 1:
          __asm { pause                   ; jumptable 1002765D case 1 }
          v4 = v9-- == 1;
          if ( v4 )
          {
            v1 = 3 - (v10 != 0);
            v11 = 3 - (v10 != 0);
          }
          break;
        case 2:
          v5 = v10-- == 1;
          if ( v5 )
            v1 = 3;
          v11 = v1;
          goto LABEL_8;
        case 4:
LABEL_8:
          LOBYTE(v1) = v12();
          break;
        case 3:
          v11 = 0;
          v1 = sub_1002BD65();
          if ( v1 )
          {
            v9 = v1;
            v10 = 1;
            v11 = 1;
          }
          else
          {
            v11 = 4;
          }
          break;
        case 0:
          v11 = 0;
          v6 = sub_1002BD65();
          if ( v6 )
          {
            v9 = v6;
            v10 = 1;
            v11 = 1;
          }
          else
          {
            v11 = 4;
          }
          LOBYTE(v1) = sub_100282E0((int)&v9);
          break;
        default:
          break;
      }
    }
    while ( *(_DWORD *)(v2 + 100) );
  }
  return v1;
}
// 10073200: using guessed type int __security_cookie;

//----- (10027730) --------------------------------------------------------
#error "1002784F: positive sp value has been found (funcsize=85)"

//----- (10027860) --------------------------------------------------------
void __userpurge sub_10027860(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // edx@1
  int ebp0; // ebp@0
  int v8; // edi@1
  int v9; // esi@1
  int v10; // ebx@1
  int v11; // eax@1
  int v28; // edi@10
  int v29; // eax@10
  int v30; // edx@14
  char v44; // [sp-20h] [bp-94h]@8
  int v45; // [sp-1Ch] [bp-90h]@10
  int v46; // [sp-18h] [bp-8Ch]@10
  int v47; // [sp-14h] [bp-88h]@10
  char v48; // [sp-8h] [bp-7Ch]@6
  int v49; // [sp-4h] [bp-78h]@6
  char v50; // [sp+10h] [bp-64h]@1
  int v51; // [sp+14h] [bp-60h]@1
  int v52; // [sp+18h] [bp-5Ch]@1
  char *v53; // [sp+1Ch] [bp-58h]@1
  int v54; // [sp+20h] [bp-54h]@1
  char *v55; // [sp+24h] [bp-50h]@1
  int v56; // [sp+28h] [bp-4Ch]@1
  char v57; // [sp+2Ch] [bp-48h]@10
  int v58; // [sp+3Ch] [bp-38h]@13
  unsigned int v59; // [sp+60h] [bp-14h]@1
  int v60; // [sp+70h] [bp-4h]@1

  v59 = (unsigned int)&v50 ^ __security_cookie;
  v10 = a2;
  v54 = a2;
  v51 = 0;
  v52 = 0;
  sub_10006BC0(a1, (int)&v51, a3, a2);
  v60 = 0;
  v11 = sub_10004DE0((int)&v55, v10 + 40);
  v9 = *(_DWORD *)(v11 + 4);
  *(_DWORD *)(v11 + 4) = v52;
  v5 = *(_DWORD *)v11;
  *(_DWORD *)v11 = v51;
  v8 = v56;
  _EBX = -1;
  v52 = v9;
  v53 = (char *)v5;
  v51 = v5;
  if ( v56 )
  {
    _EAX = v56 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v8)(v8);
      _EAX = v8 + 8;
      _EDX = -1;
      __asm { lock xadd [eax], edx }
      if ( _ZF )
        (*(void (__fastcall **)(int, int))(*(_DWORD *)v8 + 4))(v8, _EDX);
      v5 = (int)v53;
    }
  }
  v53 = &v48;
  *(_DWORD *)&v48 = 0;
  v49 = 0;
  if ( (int *)&v48 != &v51 )
  {
    v49 = v9;
    v9 = 0;
    v52 = 0;
    *(_DWORD *)&v48 = v5;
    v51 = 0;
  }
  v55 = &v44;
  LOBYTE(v60) = 2;
  _EAX = (char *)sub_1002ADB1(v5, (int)&v51, -1, (int)&v44, 32);
  if ( !_EAX )
    sub_10029530();
  _ECX = v54;
  *(_DWORD *)_EAX = off_10067EDC;
  __asm
  {
    movq    xmm0, qword ptr [ecx+30h]
    movq    qword ptr [eax+8], xmm0
    movq    xmm0, qword ptr [ecx+38h]
    movq    qword ptr [eax+10h], xmm0
  }
  LOBYTE(v60) = 1;
  v29 = sub_10027B00((int)&v57, v44, v45, v46, v47, _EAX);
  LOBYTE(v60) = 4;
  v28 = *(_DWORD *)(v54 + 32);
  *(_DWORD *)(v28 + 152) = sub_10027B90(v29, v48, v49);
  sub_1002B62D(ebp0, v28 + 100);
  LOBYTE(v60) = 4;
  if ( *(_DWORD *)(v28 + 84) == 4 )
  {
    sub_1002B6D6();
  }
  else
  {
    *(_DWORD *)(v28 + 84) = 3;
    sub_1002B6D6();
    sub_1002C5B1(ebp0);
    sub_1000A690(v28);
  }
  LOBYTE(v60) = 0;
  if ( v58 )
  {
    v30 = *(_DWORD *)v58;
    v49 = v58 != (_DWORD)&v57;
    (*(void (__stdcall **)(int))(v30 + 16))(v49);
    v58 = 0;
  }
  v60 = -1;
  if ( v9 )
  {
    _EAX = v9 + 4;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v9)(v9);
      _EAX = v9 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        (*(void (**)(void))(*(_DWORD *)v9 + 4))();
    }
  }
}
// 10067EDC: using guessed type int (__stdcall *off_10067EDC[3])(int);
// 10073200: using guessed type int __security_cookie;

//----- (10027A80) --------------------------------------------------------
int __thiscall sub_10027A80(int this, char a2, int a3, int a4, int a5, int a6)
{
  int v6; // edi@1

  v6 = this;
  sub_10027C20((int)&a2, this, this);
  if ( a6 )
    (*(void (__stdcall **)(bool))(*(_DWORD *)a6 + 16))(a6 != (_DWORD)&a2);
  return v6;
}

//----- (10027B00) --------------------------------------------------------
int __thiscall sub_10027B00(int this, char a2, int a3, int a4, int a5, char *a6)
{
  int v6; // edi@1
  char *v7; // esi@1
  int v9; // [sp-4h] [bp-24h]@4

  v6 = this;
  v7 = a6;
  if ( a6 )
  {
    if ( a6 == &a2 )
      v9 = this;
    else
      v9 = 0;
    v7 = a6;
    *(_DWORD *)(this + 16) = (**(int (__stdcall ***)(_DWORD))a6)(v9);
  }
  else
  {
    *(_DWORD *)(this + 16) = a6;
  }
  if ( v7 )
    (*(void (__thiscall **)(char *, bool))(*(_DWORD *)v7 + 16))(v7, v7 != &a2);
  return v6;
}

//----- (10027B90) --------------------------------------------------------
int __thiscall sub_10027B90(int this, char a2, int a3)
{
  int v3; // ecx@1
  int v4; // ebx@3
  int v5; // esi@3

  v3 = *(_DWORD *)(this + 16);
  if ( !v3 )
    sub_10029561();
  v5 = a3;
  v4 = (*(int (__stdcall **)(char *))(*(_DWORD *)v3 + 8))(&a2);
  if ( a3 )
  {
    _EDI = -1;
    _EDX = a3 + 4;
    _ECX = -1;
    __asm { lock xadd [edx], ecx }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v5)(v5);
      _EAX = v5 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (**)(void))(*(_DWORD *)v5 + 4))();
    }
  }
  return v4;
}

//----- (10027C20) --------------------------------------------------------
int __usercall sub_10027C20<eax>(int a1<edx>, int a2<ecx>, int a3<edi>)
{
  int v3; // ecx@1
  int v4; // esi@1
  char *v6; // [sp-4h] [bp-3Ch]@4
  char v7; // [sp+8h] [bp-30h]@1
  int v8; // [sp+18h] [bp-20h]@2
  char *v9; // [sp+20h] [bp-18h]@1
  int v10; // [sp+24h] [bp-14h]@1
  int v11; // [sp+28h] [bp-10h]@1
  int v12; // [sp+34h] [bp-4h]@1

  v4 = a2;
  v11 = a2;
  v10 = 0;
  v9 = &v7;
  v12 = 0;
  v3 = *(_DWORD *)(a1 + 16);
  if ( v3 )
  {
    if ( v3 == a1 )
    {
      a1 = (int)&v7;
      v6 = &v7;
    }
    else
    {
      v6 = 0;
    }
    v8 = (**(int (__fastcall ***)(int, int, char *))v3)(v3, a1, v6);
  }
  else
  {
    v8 = 0;
  }
  v12 = 2;
  sub_10028040(a1, v4, a3, (int)&v7, v3);
  v12 = -1;
  if ( v8 )
    (*(void (__stdcall **)(bool))(*(_DWORD *)v8 + 16))(v8 != (_DWORD)&v7);
  return v4;
}

//----- (10027D10) --------------------------------------------------------
int __thiscall sub_10027D10(int this, int a2)
{
  return (*(int (__thiscall **)(_DWORD, _DWORD))(this + 4))(*(_DWORD *)(this + 8), *(_DWORD *)a2);
}

//----- (10027D30) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10027D30())(char)
{
  return &off_10074DA0;
}
// 10074DA0: using guessed type int (__stdcall **off_10074DA0)(char);

//----- (10027D80) --------------------------------------------------------
int __thiscall sub_10027D80(int this, int a2)
{
  return (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(this + 4) + 36))(*(_DWORD *)a2);
}

//----- (10027DA0) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10027DA0())(char)
{
  return &off_10074D64;
}
// 10074D64: using guessed type int (__stdcall **off_10074D64)(char);

//----- (10027DF0) --------------------------------------------------------
int __thiscall sub_10027DF0(int this, int a2)
{
  return (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(this + 4) + 40))(*(_DWORD *)a2);
}

//----- (10027E10) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10027E10())(char)
{
  return &off_10074D2C;
}
// 10074D2C: using guessed type int (__stdcall **off_10074D2C)(char);

//----- (10027E60) --------------------------------------------------------
void __thiscall sub_10027E60(int this, int a2)
{
  int ebp0; // ebp@0
  int v3; // edi@1
  int v4; // esi@1
  char v5; // [sp+8h] [bp-2Ch]@1
  unsigned int v6; // [sp+24h] [bp-10h]@1
  int v7; // [sp+30h] [bp-4h]@1
  int v8; // [sp+34h] [bp+0h]@1

  v6 = (unsigned int)&v8 ^ __security_cookie;
  v3 = *(_DWORD *)(this + 4);
  v4 = *(_DWORD *)a2;
  sub_1002B589(ebp0, v3 + 176);
  v7 = 0;
  (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 76))(v3, v4);
  v7 = -1;
  sub_1002B6DD(&v5);
}
// 10073200: using guessed type int __security_cookie;

//----- (10027EE0) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10027EE0())(char)
{
  return &off_10074CF4;
}
// 10074CF4: using guessed type int (__stdcall **off_10074CF4)(char);

//----- (10027F30) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10027F30())(char)
{
  return &off_10074CBC;
}
// 10074CBC: using guessed type int (__stdcall **off_10074CBC)(char);

//----- (10027F80) --------------------------------------------------------
BOOL __userpurge sub_10027F80<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  return sub_100220F0(a1, a2 + 4, a3, a4);
}

//----- (10027F90) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10027F90())(char)
{
  return &off_10074C84;
}
// 10074C84: using guessed type int (__stdcall **off_10074C84)(char);

//----- (10027FA0) --------------------------------------------------------
int __userpurge sub_10027FA0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int result; // eax@1
  int v7; // edi@4
  int v8; // ecx@4
  int v9; // ecx@5
  int v10; // [sp-14h] [bp-18h]@4
  int v11; // [sp-10h] [bp-14h]@4
  int v12; // [sp-Ch] [bp-10h]@4
  int v13; // [sp-8h] [bp-Ch]@4
  _DWORD *v14; // [sp+4h] [bp+0h]@4

  result = a5;
  _ESI = a2;
  if ( a5 || (result = sub_1002ADB1(a1, a2, a3, a4, 32)) != 0 )
  {
    *(_DWORD *)result = off_10067EDC;
    __asm
    {
      movq    xmm0, qword ptr [esi+8]
      movq    qword ptr [eax+8], xmm0
      movq    xmm0, qword ptr [esi+10h]
      movq    qword ptr [eax+10h], xmm0
    }
  }
  else
  {
    sub_10029530();
    __asm { int     3               ; Trap to Debugger }
    v14 = &v14;
    v13 = _ESI;
    v12 = a4;
    v7 = v8;
    v10 = 0;
    v11 = 0;
    if ( &v10 != (int *)a5 )
    {
      v11 = *(_DWORD *)(a5 + 4);
      *(_DWORD *)(a5 + 4) = 0;
      v9 = v10;
      v10 = *(_DWORD *)a5;
      *(_DWORD *)a5 = v9;
    }
    result = sub_10022720((void *)(v7 + 8), v10, v11);
  }
  return result;
}
// 10067EDC: using guessed type int (__stdcall *off_10067EDC[3])(int);

//----- (10028030) --------------------------------------------------------
int (__stdcall ***__cdecl sub_10028030())(char)
{
  return &off_10074C4C;
}
// 10074C4C: using guessed type int (__stdcall **off_10074C4C)(char);

//----- (10028040) --------------------------------------------------------
int __userpurge sub_10028040<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4, int a5)
{
  int v5; // esi@1
  int v6; // ecx@3
  int result; // eax@9
  int v8; // [sp-4h] [bp-30h]@6
  int v9; // [sp+1Ch] [bp-10h]@1

  v9 = a2;
  v5 = sub_1002ADB1(a1, a2, a4, a3, 40);
  if ( !v5 )
    sub_10029530();
  *(_DWORD *)v5 = off_10067EC0;
  v6 = *(_DWORD *)(a4 + 16);
  if ( v6 )
  {
    if ( v6 == a4 )
      v8 = v5 + 8;
    else
      v8 = 0;
    *(_DWORD *)(v5 + 24) = (**(int (__stdcall ***)(_DWORD))v6)(v8);
  }
  else
  {
    *(_DWORD *)(v5 + 24) = 0;
  }
  result = v9;
  *(_DWORD *)(v9 + 16) = v5;
  return result;
}
// 10067EC0: using guessed type int (__stdcall *off_10067EC0[2])(int);

//----- (100280E0) --------------------------------------------------------
int __userpurge sub_100280E0<eax>(int a1<edx>, int a2<ecx>, int a3<edi>, int a4)
{
  int v4; // ebx@1
  int v5; // esi@1
  int v6; // ecx@5
  int v7; // eax@8

  v4 = a2;
  v5 = a4;
  if ( !a4 )
  {
    v5 = sub_1002ADB1(a1, a2, a2, a3, 40);
    if ( !v5 )
      sub_10029530();
  }
  if ( v5 )
  {
    *(_DWORD *)v5 = off_10067EC0;
    v6 = *(_DWORD *)(v4 + 24);
    if ( v6 )
    {
      if ( v6 == v4 + 8 )
        v7 = (**(int (__stdcall ***)(_DWORD))v6)(v5 + 8);
      else
        v7 = (**(int (__stdcall ***)(_DWORD))v6)(0);
      *(_DWORD *)(v5 + 24) = v7;
    }
    else
    {
      *(_DWORD *)(v5 + 24) = 0;
    }
  }
  return v5;
}
// 10067EC0: using guessed type int (__stdcall *off_10067EC0[2])(int);

//----- (100281B0) --------------------------------------------------------
int (__stdcall ***__cdecl sub_100281B0())(char)
{
  return &off_10074C14;
}
// 10074C14: using guessed type int (__stdcall **off_10074C14)(char);

//----- (100281C0) --------------------------------------------------------
void *__thiscall sub_100281C0(int this, char a2)
{
  int v2; // ecx@1
  int v3; // edi@1
  void *v4; // esi@1
  int v5; // ecx@3

  v4 = (void *)this;
  v3 = this + 8;
  *(_DWORD *)this = off_10067EC0;
  v2 = *(_DWORD *)(this + 24);
  if ( v2 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v2 + 16))(v2 != v3);
    *(_DWORD *)(v3 + 16) = 0;
  }
  v5 = *(_DWORD *)(v3 + 16);
  if ( v5 )
  {
    (*(void (__stdcall **)(bool))(*(_DWORD *)v5 + 16))(v5 != v3);
    *(_DWORD *)(v3 + 16) = 0;
  }
  *(_DWORD *)v4 = off_10067080;
  if ( a2 & 1 )
    sub_1002A4AA(v4);
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067080: using guessed type int (*off_10067080[5])();
// 10067EC0: using guessed type int (__stdcall *off_10067EC0[2])(int);

//----- (10028225) --------------------------------------------------------
void *__userpurge sub_10028225<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  return sub_100249E0(a1 - 16, a2, a3, a4);
}

//----- (10028230) --------------------------------------------------------
int __thiscall sub_10028230(int this)
{
  return *(_DWORD *)(this + 4);
}

//----- (10028240) --------------------------------------------------------
int __userpurge sub_10028240<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10060698;
  return v4;
}
// 10060698: using guessed type int (__stdcall *off_10060698)(char);

//----- (10028270) --------------------------------------------------------
int __userpurge sub_10028270<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_100606B0;
  return v4;
}
// 100606B0: using guessed type int (__stdcall *off_100606B0)(char);

//----- (10028290) --------------------------------------------------------
int __userpurge sub_10028290<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_100606A4;
  return v4;
}
// 100606A4: using guessed type int (__stdcall *off_100606A4)(char);

//----- (100282B0) --------------------------------------------------------
DWORD __thiscall sub_100282B0(int this)
{
  DWORD result; // eax@1
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 8) = 0;
  result = sub_1002BD65();
  if ( result )
  {
    *(_DWORD *)v2 = result;
    *(_DWORD *)(v2 + 4) = 1;
    *(_DWORD *)(v2 + 8) = 1;
  }
  else
  {
    *(_DWORD *)(v2 + 8) = 4;
  }
  return result;
}

//----- (100282E0) --------------------------------------------------------
char __thiscall sub_100282E0(int this)
{
  unsigned int v1; // eax@1
  int v2; // esi@1
  char result; // al@4
  char v4; // zf@5
  char v5; // zf@8

  v2 = this;
  v1 = *(_DWORD *)(this + 8);
  while ( 2 )
  {
    switch ( v1 )
    {
      case 0u:
        sub_100282B0(v2);
        v1 = *(_DWORD *)(v2 + 8);
        if ( v1 <= 4 )
          continue;
        result = 0;
        break;
      case 1u:
        __asm { pause                   ; jumptable 100282F0 case 1 }
        v4 = *(_DWORD *)v2-- == 1;
        if ( v4 )
          *(_DWORD *)(v2 + 8) = 3 - (*(_DWORD *)(v2 + 4) != 0);
        result = 1;
        break;
      case 2u:
        v5 = *(_DWORD *)(v2 + 4)-- == 1;
        if ( v5 )
          *(_DWORD *)(v2 + 8) = 3;
        (*(void (**)(void))(v2 + 12))();
        result = 1;
        break;
      case 3u:
        sub_100282B0(v2);
        result = 0;
        break;
      case 4u:
        (*(void (**)(void))(v2 + 12))();
        goto LABEL_13;
      default:
LABEL_13:
        result = 0;
        break;
    }
    return result;
  }
}

//----- (10028360) --------------------------------------------------------
int __usercall sub_10028360<eax>(int a1<ecx>, int a2<edi>)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // ebx@1
  int ebp0; // ebp@0
  char *v6; // esi@1
  int v7; // ecx@2
  int result; // eax@4
  int v9; // eax@5
  int v10; // ecx@5
  int v11; // edi@5
  int v12; // eax@8

  v4 = a1;
  v6 = sub_1002F41A(a1, ebp0, a2);
  ++*(_DWORD *)v6;
  if ( *(_DWORD *)v6 > 0x10u )
  {
    v9 = sub_1002ADB1(v2, v3, v4, a2, 24);
    v11 = v9;
    if ( v9 )
    {
      v10 = *(_DWORD *)(v4 + 16);
      if ( v10 )
      {
        v12 = *(_DWORD *)v10;
        if ( v10 == v4 )
          *(_DWORD *)(v11 + 16) = (*(int (__stdcall **)(int))v12)(v11);
        else
          *(_DWORD *)(v11 + 16) = (*(int (__stdcall **)(_DWORD))v12)(0);
      }
      else
      {
        *(_DWORD *)(v9 + 16) = 0;
      }
    }
    else
    {
      v11 = 0;
    }
    result = sub_1002FEEC(v10, v4, v11, (int)&loc_1000A1F0, v11);
    --*(_DWORD *)v6;
  }
  else
  {
    v7 = *(_DWORD *)(v4 + 16);
    if ( !v7 )
      sub_10029561();
    result = (*(int (**)(void))(*(_DWORD *)v7 + 8))();
    --*(_DWORD *)v6;
  }
  return result;
}

//----- (10028530) --------------------------------------------------------
int __thiscall sub_10028530(void *this, int a2, DWORD a3)
{
  int v3; // eax@1
  int v4; // esi@1
  char v5; // cf@3
  int v7; // [sp+10h] [bp-2Ch]@3
  void *v8; // [sp+14h] [bp-28h]@1
  unsigned int v9; // [sp+28h] [bp-14h]@3
  int v10; // [sp+38h] [bp-4h]@1

  v4 = (int)this;
  v3 = sub_100285D0((int)&v8, a3);
  v10 = 0;
  if ( *(_DWORD *)(v3 + 20) >= 0x10u )
    v3 = *(_DWORD *)v3;
  v7 = v3;
  sub_1002AEA4(v4, &v7);
  v5 = v9 < 0x10;
  *(_DWORD *)v4 = &off_1005F310;
  if ( !v5 )
    sub_1002A4AA(v8);
  *(_DWORD *)(v4 + 12) = a2;
  *(_DWORD *)v4 = &off_1006720C;
  *(_DWORD *)(v4 + 16) = a3;
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1005F310: using guessed type int (__stdcall *off_1005F310)(char);
// 1006720C: using guessed type int (__stdcall *off_1006720C)(char);

//----- (100285D0) --------------------------------------------------------
int __fastcall sub_100285D0(int a1, DWORD a2)
{
  int v2; // esi@1
  unsigned int v3; // ecx@3
  void *v5; // [sp+Ch] [bp-30h]@2
  int v6; // [sp+1Ch] [bp-20h]@2
  unsigned int v7; // [sp+20h] [bp-1Ch]@2
  int v8; // [sp+24h] [bp-18h]@1
  CHAR hMem[4]; // [sp+28h] [bp-14h]@1
  unsigned int v10; // [sp+2Ch] [bp-10h]@1
  int v11; // [sp+38h] [bp-4h]@1
  int v12; // [sp+3Ch] [bp+0h]@1

  v10 = (unsigned int)&v12 ^ __security_cookie;
  v2 = a1;
  *(_DWORD *)(a1 + 20) = 15;
  *(_DWORD *)(a1 + 16) = 0;
  *(_BYTE *)a1 = 0;
  v11 = 0;
  v8 = 1;
  FormatMessageA(0x1300u, 0, a2, 0x400u, hMem, 0, 0);
  GetLastError();
  if ( *(_DWORD *)hMem )
  {
    v7 = 15;
    v6 = 0;
    LOBYTE(v5) = 0;
    if ( **(_BYTE **)hMem )
      v3 = strlen(*(const char **)hMem);
    else
      v3 = 0;
    loc_1000AEB0(&v5, *(_DWORD *)hMem, v3);
    if ( (void **)v2 != &v5 )
    {
      if ( *(_DWORD *)(v2 + 20) >= 0x10u )
        sub_1002A4AA(*(LPVOID *)v2);
      *(_DWORD *)(v2 + 20) = 15;
      *(_DWORD *)(v2 + 16) = 0;
      *(_BYTE *)v2 = 0;
      sub_100017B0((void *)v2, (int)&v5);
    }
    if ( v7 >= 0x10 )
      sub_1002A4AA(v5);
    LocalFree(*(HLOCAL *)hMem);
  }
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (100286F0) --------------------------------------------------------
HINTERNET __cdecl sub_100286F0()
{
  HINTERNET result; // eax@1
  int ebp0; // ebp@0
  const WCHAR *v2; // eax@6
  DWORD v3; // [sp-14h] [bp-54h]@7
  const WCHAR *v4; // [sp-10h] [bp-50h]@7
  int i; // [sp-Ch] [bp-4Ch]@4
  const WCHAR *v6; // [sp-Ch] [bp-4Ch]@7
  DWORD v7; // [sp-8h] [bp-48h]@4
  char v8; // [sp+0h] [bp-40h]@5
  unsigned int v9; // [sp+30h] [bp-10h]@1
  int v10; // [sp+3Ch] [bp-4h]@2
  int v11; // [sp+40h] [bp+0h]@1

  v9 = (unsigned int)&v11 ^ __security_cookie;
  result = hInternet;
  if ( !hInternet )
  {
    sub_1002B62D(ebp0, (int)&unk_10076844);
    v10 = 0;
    if ( !hInternet )
    {
      if ( WinHttpGetIEProxyConfigForCurrentUser(&pProxyConfig) )
        goto LABEL_6;
      v7 = GetLastError();
      for ( i = 12; ; i = 11 )
      {
        sub_10028530(&v8, i, v7);
        sub_100355BB((int)&v8, (int)&unk_1006CA48);
LABEL_6:
        v2 = (const WCHAR *)&pszAgentW;
        if ( pProxyConfig.lpszProxy )
        {
          v6 = pProxyConfig.lpszProxyBypass;
          v4 = pProxyConfig.lpszProxy;
          v3 = 3;
        }
        else
        {
          v6 = 0;
          v4 = 0;
          v3 = 0;
        }
        if ( (unsigned int)dword_10075044 >= 8 )
          v2 = pszAgentW;
        hInternet = WinHttpOpen(v2, v3, v4, v6, 0x10000000u);
        if ( hInternet )
          break;
        v7 = GetLastError();
      }
    }
    v10 = -1;
    sub_1002B6D6();
    result = hInternet;
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10075044: using guessed type int dword_10075044;

//----- (100287F0) --------------------------------------------------------
void *__userpurge sub_100287F0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  void *v4; // esi@1

  v4 = (void *)a1;
  sub_10028820(a1, a2, a3);
  if ( a4 & 1 )
    sub_1002A4AA(v4);
  return v4;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10028820) --------------------------------------------------------
int __usercall sub_10028820<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // eax@1
  int ebp0; // ebp@0
  int v5; // esi@1
  void *v6; // eax@3

  v5 = a1;
  *(_DWORD *)a1 = &off_10068434;
  v3 = *(_DWORD *)(a1 + 12);
  if ( v3 == 1 || v3 == 2 )
  {
    v6 = *(void **)(a1 + 4);
    *(_DWORD *)(a1 + 12) = 3;
    if ( v6 )
    {
      WinHttpCloseHandle(v6);
      sub_1002C6B2(ebp0, a2, a3, 1000);
      *(_DWORD *)(v5 + 4) = 0;
    }
    if ( *(_DWORD *)(v5 + 8) )
    {
      WinHttpCloseHandle(*(HINTERNET *)(v5 + 8));
      *(_DWORD *)(v5 + 8) = 0;
    }
    *(_DWORD *)(v5 + 12) = 4;
  }
  if ( *(_DWORD *)(v5 + 76) >= 0x10u )
    sub_1002A4AA(*(LPVOID *)(v5 + 56));
  *(_DWORD *)(v5 + 76) = 15;
  *(_DWORD *)(v5 + 72) = 0;
  *(_BYTE *)(v5 + 56) = 0;
  return sub_1002C0CE(ebp0);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10068434: using guessed type int (__stdcall *off_10068434)(char);

//----- (100288F0) --------------------------------------------------------
int __thiscall sub_100288F0(int this, int a2)
{
  int v2; // esi@1
  char v3; // cf@3
  const WCHAR *v4; // eax@4
  DWORD v5; // eax@7
  int v7; // eax@12
  unsigned int v8; // [sp-4h] [bp-94h]@1
  void *v9; // [sp+Ch] [bp-84h]@10
  int v10; // [sp+1Ch] [bp-74h]@10
  unsigned int v11; // [sp+20h] [bp-70h]@10
  void *v12; // [sp+24h] [bp-6Ch]@8
  char v13; // [sp+28h] [bp-68h]@7
  int (__stdcall **v14)(char); // [sp+30h] [bp-60h]@2
  int v15; // [sp+34h] [bp-5Ch]@8
  unsigned int v16; // [sp+38h] [bp-58h]@8
  struct $BC2FB811D417144E831EE3AEA4A279C8 UrlComponents; // [sp+3Ch] [bp-54h]@3
  int v18; // [sp+78h] [bp-18h]@2
  unsigned int v19; // [sp+7Ch] [bp-14h]@1
  int v20; // [sp+8Ch] [bp-4h]@8
  int v21; // [sp+90h] [bp+0h]@1

  v19 = (unsigned int)&v21 ^ __security_cookie;
  v8 = (unsigned int)&v21 ^ __security_cookie;
  v2 = this;
  if ( *(_DWORD *)(this + 12) )
  {
    v18 = (int)"Request is not ready";
    sub_1002AEA4((int)&v14, &v18);
    v14 = &off_1005F2E0;
    sub_100355BB((int)&v14, (int)&unk_1006C778);
  }
  sub_100286F0();
  *(_DWORD *)(v2 + 12) = 1;
  UrlComponents.dwStructSize = 60;
  sub_100391F0(&UrlComponents.lpszScheme, 0, 56);
  v3 = *(_DWORD *)(a2 + 20) < 8u;
  UrlComponents.dwSchemeLength = -1;
  UrlComponents.dwHostNameLength = -1;
  UrlComponents.dwUrlPathLength = -1;
  if ( v3 )
    v4 = (const WCHAR *)a2;
  else
    v4 = *(const WCHAR **)a2;
  if ( !WinHttpCrackUrl(v4, *(_DWORD *)(a2 + 16), 0, &UrlComponents) )
  {
    v5 = GetLastError();
    sub_10028530(&v13, 8, v5);
    sub_100355BB((int)&v13, (int)&unk_1006CA48);
  }
  v16 = 7;
  v15 = 0;
  LOWORD(v12) = 0;
  loc_10028430(&v12, UrlComponents.lpszHostName, UrlComponents.dwHostNameLength, v8);
  v20 = 0;
  (*(void (__thiscall **)(int, void **))(*(_DWORD *)v2 + 4))(v2, &v12);
  v20 = -1;
  if ( v16 >= 8 )
    sub_1002A4AA(v12);
  v11 = 7;
  v10 = 0;
  LOWORD(v9) = 0;
  loc_10028430(&v9, UrlComponents.lpszUrlPath, UrlComponents.dwUrlPathLength);
  v20 = 1;
  (*(void (__thiscall **)(int, void **))(*(_DWORD *)v2 + 8))(v2, &v9);
  v20 = -1;
  if ( v11 >= 8 )
    sub_1002A4AA(v9);
  LOWORD(v9) = 0;
  v7 = *(_DWORD *)v2;
  v11 = 7;
  v10 = 0;
  (*(void (__thiscall **)(int))(v7 + 16))(v2);
  return (*(int (__cdecl **)(int))(*(_DWORD *)v2 + 12))(a2);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1005F2E0: using guessed type int (__stdcall *off_1005F2E0)(char);
// 10073200: using guessed type int __security_cookie;

//----- (10028AB0) --------------------------------------------------------
int __thiscall sub_10028AB0(void *this, int a2)
{
  return loc_10028E10(a2, this);
}

//----- (10028AC0) --------------------------------------------------------
void __thiscall sub_10028AC0(int this, LPCWSTR pwszObjectName)
{
  int v2; // edi@1
  const WCHAR *v3; // esi@1
  const WCHAR *v4; // eax@5
  DWORD v5; // eax@7
  DWORD v6; // eax@10
  char v7; // [sp+Ch] [bp-48h]@1
  int (__stdcall **v8)(char); // [sp+10h] [bp-44h]@2
  int v9; // [sp+24h] [bp-30h]@2
  LPCWSTR pwszVerb; // [sp+28h] [bp-2Ch]@3
  int v11; // [sp+38h] [bp-1Ch]@3
  unsigned int v12; // [sp+3Ch] [bp-18h]@3
  unsigned int v13; // [sp+40h] [bp-14h]@1
  int v14; // [sp+50h] [bp-4h]@3

  v13 = (unsigned int)&v7 ^ __security_cookie;
  v2 = this;
  v3 = pwszObjectName;
  if ( !*(_DWORD *)(this + 8) )
  {
    v9 = (int)"Invalid connection";
    sub_1002AEA4((int)&v8, &v9);
    v8 = &off_1005F2E0;
    sub_100355BB((int)&v8, (int)&unk_1006C778);
  }
  v12 = 7;
  v11 = 0;
  LOWORD(pwszVerb) = 0;
  v14 = 0;
  loc_10028430(&pwszVerb, L"GET", 3);
  if ( *((_DWORD *)pwszObjectName + 5) >= 8u )
    v3 = *(const WCHAR **)pwszObjectName;
  v4 = (const WCHAR *)&pwszVerb;
  if ( v12 >= 8 )
    v4 = pwszVerb;
  v5 = (DWORD)WinHttpOpenRequest(*(HINTERNET *)(v2 + 8), v4, v3, 0, 0, 0, 0);
  *(_DWORD *)(v2 + 4) = v5;
  if ( !v5 )
  {
    v5 = GetLastError();
    sub_10028530(&v8, 9, v5);
    sub_100355BB((int)&v8, (int)&unk_1006CA48);
  }
  if ( WinHttpSetStatusCallback((HINTERNET)v5, (WINHTTP_STATUS_CALLBACK)fnInternetCallback, 0xFFFFFFFFu, 0) == (WINHTTP_STATUS_CALLBACK)-1 )
  {
    v6 = GetLastError();
    sub_10028530(&v8, 10, v6);
    sub_100355BB((int)&v8, (int)&unk_1006CA48);
  }
  if ( v12 >= 8 )
    sub_1002A4AA((LPVOID)pwszVerb);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1005F2E0: using guessed type int (__stdcall *off_1005F2E0)(char);
// 1006842C: using guessed type wchar_t aGet[4];
// 10073200: using guessed type int __security_cookie;

//----- (10028C20) --------------------------------------------------------
void __thiscall sub_10028C20(DWORD_PTR this)
{
  sub_10028EB0(this, 0, 0, 0, 0);
}

//----- (10028D60) --------------------------------------------------------
int __stdcall sub_10028D60(char a1, int a2)
{
  return sub_1002FDDA((int)&a1);
}

//----- (10028EB0) --------------------------------------------------------
void __thiscall sub_10028EB0(DWORD_PTR dwContext, LPVOID lpOptional, DWORD dwOptionalLength, DWORD dwTotalLength, LPCWSTR lpszHeaders)
{
  int v5; // eax@2
  DWORD v6; // eax@2
  int v7; // esi@2
  int v8; // [sp+Ch] [bp-40h]@4
  int (__stdcall **v9)(char); // [sp+10h] [bp-3Ch]@4
  int v10; // [sp+1Ch] [bp-30h]@6
  int v11; // [sp+20h] [bp-2Ch]@6
  void *v12; // [sp+24h] [bp-28h]@2
  int v13; // [sp+34h] [bp-18h]@6
  unsigned int v14; // [sp+38h] [bp-14h]@4
  int v15; // [sp+48h] [bp-4h]@2

  if ( !WinHttpSendRequest(
          *(HINTERNET *)(dwContext + 4),
          lpszHeaders,
          0xFFFFFFFFu,
          lpOptional,
          dwOptionalLength,
          dwTotalLength,
          dwContext) )
  {
    v6 = GetLastError();
    v7 = v6;
    v5 = sub_100285D0((int)&v12, v6);
    v15 = 0;
    if ( *(_DWORD *)(v5 + 20) >= 0x10u )
      v5 = *(_DWORD *)v5;
    v8 = v5;
    sub_1002AEA4((int)&v9, &v8);
    v15 = -1;
    v9 = &off_1005F310;
    if ( v14 >= 0x10 )
      sub_1002A4AA(v12);
    v14 = 15;
    v13 = 0;
    LOBYTE(v12) = 0;
    v9 = &off_1006720C;
    v10 = 5;
    v11 = v7;
    sub_100355BB((int)&v9, (int)&unk_1006CA48);
  }
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1005F310: using guessed type int (__stdcall *off_1005F310)(char);
// 1006720C: using guessed type int (__stdcall *off_1006720C)(char);

//----- (10028FA0) --------------------------------------------------------
void __userpurge fnInternetCallback(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, unsigned int a6, int a7, int a8)
{
  int ebp0; // ebp@0
  void *v9; // esi@9
  char *v10; // ecx@10
  DWORD v11; // eax@10
  int v12; // eax@10
  void *v13; // ST00_4@11
  DWORD v14; // eax@12
  int v15; // eax@12
  DWORD v16; // eax@14
  int v17; // eax@14
  DWORD v18; // eax@18
  int v19; // eax@18
  DWORD v20; // eax@22
  int v21; // eax@22
  int v22; // eax@23
  char v23; // [sp+10h] [bp-94h]@1
  char v24; // [sp+14h] [bp-90h]@14
  char v25; // [sp+28h] [bp-7Ch]@10
  char v26; // [sp+3Ch] [bp-68h]@23
  char v27; // [sp+50h] [bp-54h]@18
  char v28; // [sp+64h] [bp-40h]@12
  char v29; // [sp+78h] [bp-2Ch]@22
  LPVOID dwBufferLength; // [sp+8Ch] [bp-18h]@9
  unsigned int v31; // [sp+90h] [bp-14h]@1
  int v32; // [sp+A0h] [bp-4h]@10

  v31 = (unsigned int)&v23 ^ __security_cookie;
  if ( a5 )
  {
    if ( a6 > 0x80000 )
    {
      if ( a6 == 2097152 )
      {
        v22 = sub_10028530(&v26, *(_DWORD *)a7, *(_DWORD *)(a7 + 4));
        v32 = 5;
        sub_10029260(a5, v22);
        v10 = &v26;
        goto LABEL_24;
      }
      if ( a6 == 4194304 && !WinHttpReceiveResponse(*(HINTERNET *)(a5 + 4), 0) )
      {
        v20 = GetLastError();
        v21 = sub_10028530(&v29, 1, v20);
        v32 = 0;
        sub_10029260(a5, v21);
        v10 = &v29;
        goto LABEL_24;
      }
    }
    else
    {
      if ( a6 == 524288 )
      {
        if ( !a8 )
        {
LABEL_8:
          (*(void (__thiscall **)(int, int))(*(_DWORD *)a5 + 20))(a5, a5 + 56);
          *(_DWORD *)(a5 + 12) = 2;
          return;
        }
        loc_10014700(a5 + 56, a7, a8);
        sub_100303A3((LPVOID)a7);
        if ( !WinHttpQueryDataAvailable(*(HINTERNET *)(a5 + 4), 0) )
        {
          v18 = GetLastError();
          v19 = sub_10028530(&v27, 2, v18);
          v32 = 4;
          sub_10029260(a5, v19);
          v10 = &v27;
          goto LABEL_24;
        }
      }
      else
      {
        if ( a6 == 2048 )
        {
          sub_1002C5B1(ebp0);
          return;
        }
        if ( a6 == 131072 )
        {
          v13 = *(void **)(a5 + 4);
          dwBufferLength = (LPVOID)4;
          if ( !WinHttpQueryHeaders(v13, 0x20000013u, 0, (LPVOID)(a5 + 80), (LPDWORD)&dwBufferLength, 0) )
          {
            v14 = GetLastError();
            v15 = sub_10028530(&v28, 6, v14);
            v32 = 1;
            sub_10029260(a5, v15);
            v32 = -1;
            sub_1002AF18((int)&v28, a3);
          }
          if ( !WinHttpQueryDataAvailable(*(HINTERNET *)(a5 + 4), 0) )
          {
            v16 = GetLastError();
            v17 = sub_10028530(&v24, 2, v16);
            v32 = 2;
            sub_10029260(a5, v17);
            v10 = &v24;
            goto LABEL_24;
          }
        }
        else
        {
          if ( a6 != 262144 )
            return;
          a3 = *(_DWORD *)a7;
          if ( !*(_DWORD *)a7 )
            goto LABEL_8;
          dwBufferLength = (LPVOID)sub_1002965B(a1, a2, a3, a5, a3 + 1);
          sub_100391F0(dwBufferLength, 0, a3 + 1);
          v9 = dwBufferLength;
          if ( !WinHttpReadData(*(HINTERNET *)(a5 + 4), dwBufferLength, a3, 0) )
          {
            sub_100303A3(v9);
            v11 = GetLastError();
            v12 = sub_10028530(&v25, 3, v11);
            v32 = 3;
            sub_10029260(a5, v12);
            v10 = &v25;
LABEL_24:
            sub_1002AF18((int)v10, a3);
            return;
          }
        }
      }
    }
  }
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 10073200: using guessed type int __security_cookie;

//----- (10029260) --------------------------------------------------------
int __thiscall sub_10029260(int this, int a2)
{
  int v3; // ebx@1
  char v4; // [sp-18h] [bp-48h]@1
  int v5; // [sp-Ch] [bp-3Ch]@1
  int v6; // [sp-8h] [bp-38h]@1
  unsigned int v7; // [sp-4h] [bp-34h]@1
  int v8; // [sp+14h] [bp-1Ch]@1
  int v9; // [sp+18h] [bp-18h]@1
  unsigned int v10; // [sp+1Ch] [bp-14h]@1
  int v11; // [sp+2Ch] [bp-4h]@1
  int v12; // [sp+30h] [bp+0h]@1

  v10 = (unsigned int)&v12 ^ __security_cookie;
  v7 = (unsigned int)&v12 ^ __security_cookie;
  v3 = this;
  v8 = 0;
  v9 = 0;
  sub_1002AEE4((int)&v4, this, a2);
  *(_DWORD *)&v4 = &off_1006720C;
  v5 = *(_DWORD *)(a2 + 12);
  v6 = *(_DWORD *)(a2 + 16);
  sub_10029320(&v8, v3, (unsigned int)&off_1006720C);
  v11 = 0;
  sub_1002FD39((int)&v5, (int)&v8);
  (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 24))(v3);
  v11 = -1;
  return sub_1002FDDA((int)&v8);
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);
// 1006720C: using guessed type int (__stdcall *off_1006720C)(char);
// 10073200: using guessed type int __security_cookie;

//----- (10029320) --------------------------------------------------------
void *__usercall sub_10029320<eax>(void *a1<ecx>, int a2<ebx>, char a3)
{
  void *v4; // esi@1

  v4 = a1;
  sub_100098C0(a1, (int)&unk_1006CA48);
  sub_1002AF18((int)&a3, a2);
  return v4;
}

//----- (10029380) --------------------------------------------------------
int __userpurge sub_10029380<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_1005F2C4;
  return v4;
}
// 1005F2C4: using guessed type int (__stdcall *off_1005F2C4)(char);

//----- (1002939B) --------------------------------------------------------
int __userpurge sub_1002939B<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_1005F31C;
  return v4;
}
// 1005F31C: using guessed type int (__stdcall *off_1005F31C)(char);

//----- (100293B6) --------------------------------------------------------
int __userpurge sub_100293B6<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_1005F2F8;
  return v4;
}
// 1005F2F8: using guessed type int (__stdcall *off_1005F2F8)(char);

//----- (100293D1) --------------------------------------------------------
int __userpurge sub_100293D1<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_1005F304;
  return v4;
}
// 1005F304: using guessed type int (__stdcall *off_1005F304)(char);

//----- (100293EC) --------------------------------------------------------
int __userpurge sub_100293EC<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // edi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_1005F3AC;
  *(_DWORD *)(v4 + 12) = *(_DWORD *)(a3 + 12);
  return v4;
}
// 1005F3AC: using guessed type int (__stdcall *off_1005F3AC)(char);

//----- (10029410) --------------------------------------------------------
int __thiscall sub_10029410(void *this, int a2)
{
  int v3; // esi@1
  int v4; // edi@1

  v3 = a2;
  v4 = (int)this;
  a2 = sub_10029470(a2);
  sub_1002AEA4(v4, &a2);
  *(_DWORD *)(v4 + 12) = v3;
  *(_DWORD *)v4 = &off_1005F3AC;
  return v4;
}
// 1005F3AC: using guessed type int (__stdcall *off_1005F3AC)(char);

//----- (10029440) --------------------------------------------------------
void __usercall sub_10029440(int a1<ecx>, int a2<ebx>)
{
  *(_DWORD *)a1 = &off_1005F2C4;
  sub_1002AF18(a1, a2);
}
// 1005F2C4: using guessed type int (__stdcall *off_1005F2C4)(char);

//----- (1002944B) --------------------------------------------------------
void *__userpurge sub_1002944B<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  *(_DWORD *)a1 = &off_1005F2C4;
  sub_1002AF18(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1005F2C4: using guessed type int (__stdcall *off_1005F2C4)(char);

//----- (10029470) --------------------------------------------------------
int __cdecl sub_10029470(int a1)
{
  int result; // eax@2

  switch ( a1 )
  {
    case 0:
      result = (int)"regex_error(error_collate): The expression contained an invalid collating element name.";
      break;
    case 1:
      result = (int)"regex_error(error_ctype): The expression contained an invalid character class name.";
      break;
    case 2:
      result = (int)"regex_error(error_escape): The expression contained an invalid escaped character, or a trailing escape.";
      break;
    case 3:
      result = (int)"regex_error(error_backref): The expression contained an invalid back reference.";
      break;
    case 4:
      result = (int)"regex_error(error_brack): The expression contained mismatched [ and ].";
      break;
    case 5:
      result = (int)"regex_error(error_paren): The expression contained mismatched ( and ).";
      break;
    case 6:
      result = (int)"regex_error(error_brace): The expression contained mismatched { and }.";
      break;
    case 7:
      result = (int)"regex_error(error_badbrace): The expression contained an invalid range in a { expression }.";
      break;
    case 8:
      result = (int)"regex_error(error_range): The expression contained an invalid character range, such as [b-a] in most encodings.";
      break;
    case 9:
      result = (int)"regex_error(error_space): There was insufficient memory to convert the expression into a finite state machine.";
      break;
    case 10:
      result = (int)"regex_error(error_badrepeat): One of *?+{ was not preceded by a valid regular expression.";
      break;
    case 11:
      result = (int)"regex_error(error_complexity): The complexity of an attempted match against a regular expression exceeded a pre-set level.";
      break;
    case 12:
      result = (int)"regex_error(error_stack): There was insufficient memory to determine whether the regular expression could match the specified character sequence.";
      break;
    case 13:
      result = (int)"regex_error(error_parse)";
      break;
    case 14:
      result = (int)"regex_error(error_syntax)";
      break;
    default:
      result = (int)"regex_error";
      break;
  }
  return result;
}

//----- (10029530) --------------------------------------------------------
void __cdecl sub_10029530()
{
  int (__stdcall **v0)(char); // [sp+0h] [bp-10h]@1
  int v1; // [sp+Ch] [bp-4h]@1

  v1 = (int)"bad allocation";
  sub_1002AEC9((int)&v0, (int)&v1, 1);
  v0 = &off_1005F2C4;
  sub_100355BB((int)&v0, (int)&unk_1006AA70);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_10029561);
}
// 1005F2C4: using guessed type int (__stdcall *off_1005F2C4)(char);

//----- (10029561) --------------------------------------------------------
void __cdecl sub_10029561()
{
  int (__stdcall **v0)(char); // [sp+0h] [bp-Ch]@1

  sub_1002AF07((int)&v0);
  v0 = &off_1005F31C;
  sub_100355BB((int)&v0, (int)&unk_1006AB20);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_10029585);
}
// 1005F31C: using guessed type int (__stdcall *off_1005F31C)(char);

//----- (10029585) --------------------------------------------------------
void __cdecl sub_10029585(int a1)
{
  int (__stdcall **v1)(char); // [sp+0h] [bp-Ch]@1

  sub_1002AEA4((int)&v1, &a1);
  v1 = &off_1005F2F8;
  sub_100355BB((int)&v1, (int)&unk_1006AAA8);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_100295B3);
}
// 1005F2F8: using guessed type int (__stdcall *off_1005F2F8)(char);

//----- (100295B3) --------------------------------------------------------
void __cdecl sub_100295B3(int a1)
{
  int (__stdcall **v1)(char); // [sp+0h] [bp-Ch]@1

  sub_1002AEA4((int)&v1, &a1);
  v1 = &off_1005F304;
  sub_100355BB((int)&v1, (int)&unk_1006AAE4);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_100295E1);
}
// 100295E1: using guessed type int __cdecl sub_100295E1(int);
// 1005F304: using guessed type int (__stdcall *off_1005F304)(char);

//----- (100295E1) --------------------------------------------------------
int __cdecl sub_100295E1(int a1)
{
  char v2; // [sp+0h] [bp-10h]@1

  sub_10029410(&v2, a1);
  sub_100355BB((int)&v2, (int)&unk_1006AB58);
  __asm { int     3               ; Trap to Debugger }
  return (int)"bad function call";
}
// 100295E1: using guessed type int __cdecl sub_100295E1(int);

//----- (10029607) --------------------------------------------------------
int __cdecl sub_10029607(int a1)
{
  _UNKNOWN *v1; // eax@1
  int result; // eax@4

  v1 = &unk_1005FB48;
  if ( off_1005FB4C )
  {
    while ( *(_DWORD *)v1 != a1 )
    {
      v1 = (char *)v1 + 8;
      if ( !*((_DWORD *)v1 + 1) )
        goto LABEL_4;
    }
    result = *((_DWORD *)v1 + 1);
  }
  else
  {
LABEL_4:
    result = 0;
  }
  return result;
}
// 1005FB4C: using guessed type char *off_1005FB4C;

//----- (10029631) --------------------------------------------------------
int __cdecl sub_10029631(int a1)
{
  _UNKNOWN *v1; // eax@1
  int result; // eax@4

  v1 = &unk_1005F8F0;
  if ( off_1005F8F4 )
  {
    while ( *(_DWORD *)v1 != a1 )
    {
      v1 = (char *)v1 + 8;
      if ( !*((_DWORD *)v1 + 1) )
        goto LABEL_4;
    }
    result = *((_DWORD *)v1 + 1);
  }
  else
  {
LABEL_4:
    result = 0;
  }
  return result;
}
// 1005F8F4: using guessed type char *off_1005F8F4;

//----- (1002965B) --------------------------------------------------------
int __usercall sub_1002965B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int dwBytes)
{
  return sub_1002ADB1(a1, a2, a3, a4, dwBytes);
}

//----- (10029664) --------------------------------------------------------
int __cdecl sub_10029664(int a1, int a2, int a3)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)a1 = sub_1002967E;
  *(_DWORD *)(a1 + 12) = a3;
  return result;
}

//----- (1002967E) --------------------------------------------------------
int __cdecl sub_1002967E(int a1, int a2, int a3)
{
  int result; // eax@1

  *(_DWORD *)(a1 + 32) = a2;
  result = a3;
  *(_DWORD *)(a1 + 36) = a3;
  return result;
}

//----- (10029692) --------------------------------------------------------
int __thiscall sub_10029692(int this, int a2)
{
  int v2; // edi@1
  int i; // esi@1
  int result; // eax@2

  v2 = this;
  for ( i = *(_DWORD *)(this + 44); i; i = *(_DWORD *)i )
    result = (*(int (__cdecl **)(int, int, _DWORD))(i + 8))(a2, v2, *(_DWORD *)(i + 4));
  return result;
}

//----- (100296B7) --------------------------------------------------------
char __cdecl sub_100296B7(int a1)
{
  int v1; // eax@1
  char result; // al@2
  void *v3; // esi@3

  v1 = *(_DWORD *)(a1 + 8);
  if ( !v1 || (--byte_100750B0[v1], result = byte_100750B0[v1], result <= 0) )
  {
    result = (unsigned int)sub_100296F4(a1);
    v3 = *(void **)(a1 + 48);
    if ( v3 )
    {
      sub_10017D50(v3);
      result = sub_1002A4AA(v3);
    }
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100296F4) --------------------------------------------------------
void *__thiscall sub_100296F4(int this)
{
  void *v1; // eax@1
  int v2; // edi@1
  void *v3; // esi@2
  void *result; // eax@3
  void *v5; // esi@4

  v2 = this;
  sub_10029692(this, 0);
  v1 = *(void **)(v2 + 40);
  if ( v1 )
  {
    do
    {
      v3 = *(void **)v1;
      sub_1002A4AA(v1);
      v1 = v3;
    }
    while ( v3 );
  }
  result = *(void **)(v2 + 44);
  *(_DWORD *)(v2 + 40) = 0;
  if ( result )
  {
    do
    {
      v5 = *(void **)result;
      sub_1002A4AA(result);
      result = v5;
    }
    while ( v5 );
  }
  *(_DWORD *)(v2 + 44) = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002973B) --------------------------------------------------------
void *__thiscall sub_1002973B(void *this, char a2)
{
  void *v3; // esi@1
  int v4; // ecx@1

  v3 = this;
  v4 = (int)((char *)this + 24);
  *((_DWORD *)v3 + 1) = 1;
  *(_DWORD *)v3 = &off_10060664;
  *((_DWORD *)v3 + 2) = 0;
  *((_DWORD *)v3 + 3) = 0;
  *((_DWORD *)v3 + 4) = 0;
  *((_BYTE *)v3 + 20) = a2;
  *(_DWORD *)v4 = 0;
  *(_BYTE *)(v4 + 4) = 0;
  sub_100297DC(v4, 0, (int)&unk_10060670);
  return v3;
}
// 10060664: using guessed type int (__stdcall *off_10060664)(char);

//----- (10029778) --------------------------------------------------------
int __thiscall sub_10029778(int this)
{
  int result; // eax@1

  result = (*(int (**)(void))(**(_DWORD **)(this + 4) + 8))();
  if ( result )
    result = (**(int (__thiscall ***)(_DWORD, _DWORD))result)(result, 1);
  return result;
}

//----- (100297B1) --------------------------------------------------------
void __usercall sub_100297B1(int a1<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>)
{
  int v4; // esi@1

  v4 = a1;
  *(_DWORD *)a1 = &off_10060664;
  sub_100298F9(a2, a3, a4);
  if ( *(_DWORD *)(v4 + 24) )
    sub_100309C2(a2, *(LPVOID *)(v4 + 24));
  *(_DWORD *)(v4 + 24) = 0;
  *(_DWORD *)v4 = &off_10060654;
}
// 10060654: using guessed type int (__stdcall *off_10060654)(char);
// 10060664: using guessed type int (__stdcall *off_10060664)(char);

//----- (100297DC) --------------------------------------------------------
int __fastcall sub_100297DC(int a1, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // ST0C_4@3
  int i; // esi@5
  int v6; // eax@7
  int v7; // esi@7

  v3 = a1;
  if ( *(_DWORD *)a1 != a3 )
  {
    if ( *(_DWORD *)a1 )
    {
      sub_100309C2(a1, *(LPVOID *)a1);
      a1 = v4;
    }
    *(_DWORD *)v3 = 0;
    if ( a3 )
    {
      for ( i = a3; *(_BYTE *)i; ++i )
        ;
      v7 = i - a3 + 1;
      v6 = sub_10030930(a2, a1, v3, a3, v7);
      *(_DWORD *)v3 = v6;
      if ( v6 )
        sub_10034EE0((void *)v6, (const void *)a3, v7);
    }
  }
  return v3;
}

//----- (10029830) --------------------------------------------------------
void *__userpurge sub_10029830<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, char a4)
{
  int ebp0; // ebp@0
  void *v5; // esi@1

  v5 = (void *)a1;
  sub_100297B1(a1, a2, ebp0, a3);
  if ( a4 & 1 )
    sub_1002A4AA(v5);
  return v5;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002984F) --------------------------------------------------------
int __usercall sub_1002984F<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int result; // eax@1

  result = sub_1002ADB1(a1, a2, a3, a4, 8);
  if ( result )
  {
    *(_DWORD *)result = dword_100750D0;
    *(_DWORD *)(result + 4) = a5;
  }
  else
  {
    result = 0;
  }
  dword_100750D0 = result;
  return result;
}
// 100750D0: using guessed type int dword_100750D0;

//----- (10029877) --------------------------------------------------------
int __cdecl sub_10029877()
{
  return dword_100750CC;
}
// 100750CC: using guessed type int dword_100750CC;

//----- (1002987D) --------------------------------------------------------
int __usercall sub_1002987D<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // esi@1
  int v6; // edx@2

  sub_10035648();
  sub_10029A76(v3, a2 - 16, a1, a3, 0);
  v5 = dword_100750CC;
  *(_DWORD *)(a2 - 4) = 0;
  if ( !v5 )
  {
    v5 = (int)sub_100299B7(v3, v4, a1, a3, 0);
    sub_100299D6(v5);
    *(_DWORD *)(v5 + 16) = 63;
    sub_100297DC(v5 + 24, v6, (int)&unk_10060674);
    dword_100750C8 = v5;
    (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
    dword_100750E8 = dword_100750C8;
  }
  if ( *(_BYTE *)(a2 + 8) )
    (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 4))(v5);
  sub_10029AD2((void *)(a2 - 16));
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 100750C8: using guessed type int dword_100750C8;
// 100750CC: using guessed type int dword_100750CC;
// 100750E8: using guessed type int dword_100750E8;

//----- (100298F9) --------------------------------------------------------
int __usercall sub_100298F9<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // edi@1
  int v4; // esi@1
  int v5; // edx@1
  int v6; // ecx@2
  int v7; // eax@3
  signed int v9; // [sp-8h] [bp-8h]@1
  signed int v10; // [sp-4h] [bp-4h]@1

  v10 = 4;
  sub_10035648();
  sub_10029A76(v5, a2 - 16, a1, a3, 0);
  v3 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a2 - 4) = 0;
  v4 = *(_DWORD *)(v3 + 12);
  while ( v4 )
  {
    --v4;
    v6 = *(_DWORD *)(*(_DWORD *)(v3 + 8) + 4 * v4);
    if ( v6 )
    {
      v7 = (*(int (__cdecl **)(signed int))(*(_DWORD *)v6 + 8))(v10);
      if ( v7 )
      {
        v9 = 1;
        (**(void (__thiscall ***)(_DWORD))v7)(v7);
      }
    }
  }
  sub_100309C2(a1, *(LPVOID *)(v3 + 8));
  sub_10029AD2((void *)(a2 - 16));
  return sub_10035616(v9);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (10029952) --------------------------------------------------------
int __cdecl sub_10029952(int a1, const CHAR *a2)
{
  int v2; // eax@1
  int v3; // edx@1
  int v4; // edx@3
  int v5; // eax@4

  sub_1003684B(0, 0);
  if ( !v2 )
    v2 = (int)&unk_1006723C;
  sub_100297DC(a1 + 36, v3, v2);
  if ( !a2 || (sub_1003684B(0, a2), !v5) )
    v5 = (int)&unk_10060670;
  return sub_100297DC(a1 + 44, v4, v5);
}

//----- (1002999D) --------------------------------------------------------
void __cdecl sub_1002999D(int a1)
{
  if ( *(_DWORD *)(a1 + 36) )
    sub_1003684B(0, *(LPCSTR *)(a1 + 36));
}

//----- (100299B7) --------------------------------------------------------
void *__usercall sub_100299B7<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, char a5)
{
  int v5; // eax@1
  void *result; // eax@2

  v5 = sub_1002ADB1(a1, a2, a3, a4, 32);
  if ( v5 )
    result = sub_1002973B((void *)v5, a5);
  else
    result = 0;
  return result;
}

//----- (100299D6) --------------------------------------------------------
int __cdecl sub_100299D6(int a1)
{
  int result; // eax@3

  if ( !byte_100750F0 )
  {
    byte_100750F0 = 1;
    sub_1002A3B2(sub_10029A1D);
  }
  result = a1;
  dword_100750CC = a1;
  return result;
}
// 100750CC: using guessed type int dword_100750CC;
// 100750F0: using guessed type char byte_100750F0;

//----- (100299FE) --------------------------------------------------------
int __cdecl sub_100299FE(int a1)
{
  int result; // eax@1

  result = a1;
  if ( *(_DWORD *)a1 )
  {
    result = (*(int (**)(void))(**(_DWORD **)a1 + 8))();
    if ( result )
      result = (**(int (__thiscall ***)(_DWORD, _DWORD))result)(result, 1);
  }
  return result;
}

//----- (10029A1D) --------------------------------------------------------
void __usercall sub_10029A1D(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // [sp+0h] [bp-4h]@1

  v4 = a2;
  sub_10029A76(a1, (int)&v4, a3, a4, 0);
  sub_100299FE((int)&dword_100750CC);
  dword_100750CC = 0;
  sub_10029AD2(&v4);
}
// 100750CC: using guessed type int dword_100750CC;

//----- (10029A47) --------------------------------------------------------
void *__thiscall sub_10029A47(void *this)
{
  void *v1; // edi@1
  struct _RTL_CRITICAL_SECTION *v2; // esi@2

  v1 = this;
  if ( !InterlockedIncrement(&Addend) )
  {
    v2 = &CriticalSection;
    do
    {
      sub_1002A3EE(v2);
      ++v2;
    }
    while ( (signed int)v2 < (signed int)&unk_10075160 );
  }
  return v1;
}

//----- (10029A76) --------------------------------------------------------
int __userpurge sub_10029A76<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5)
{
  int v5; // esi@1

  v5 = a2;
  *(_DWORD *)a2 = a5;
  if ( a5 )
  {
    if ( a5 < 4 )
      sub_1002A405(&CriticalSection + a5);
  }
  else
  {
    sub_10036A23(a1, a2, a3, a4, 12);
  }
  return v5;
}

//----- (10029AD2) --------------------------------------------------------
void __thiscall sub_10029AD2(void *this)
{
  signed int v1; // eax@1

  v1 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    if ( v1 < 4 )
      sub_1002A413(&CriticalSection + v1);
  }
  else
  {
    sub_10036B87(12);
  }
}

//----- (10029AF6) --------------------------------------------------------
int __usercall sub_10029AF6<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  LPVOID v3; // eax@1
  int v4; // ecx@1
  int v5; // eax@2
  int v6; // eax@3
  int v7; // eax@4

  *(_DWORD *)a3 = sub_10036E87(a1, a2);
  v3 = sub_100374E6(v4, a1, 0x100u, 2u);
  *(_DWORD *)(a3 + 4) = v3;
  if ( v3 )
  {
    v5 = sub_10036B9C(a1, a2);
    sub_10034EE0(*(void **)(a3 + 4), (const void *)v5, 0x200u);
    *(_DWORD *)(a3 + 8) = 1;
  }
  else
  {
    v6 = sub_10036B9C(a1, a2);
    *(_DWORD *)(a3 + 8) = 0;
    *(_DWORD *)(a3 + 4) = v6;
  }
  v7 = *(_DWORD *)(sub_10036ED3(a1, a2) + 4);
  *(_DWORD *)(a3 + 12) = v7;
  if ( v7 )
    *(_DWORD *)(a3 + 12) = sub_10036E34(a1, v7);
  return a3;
}

//----- (10029B62) --------------------------------------------------------
int __usercall sub_10029B62<eax>(int a1<ebx>, int a2<edi>, int a3, int MultiByteStr)
{
  int v4; // esi@1
  int v5; // eax@2
  int v6; // edi@2
  int result; // eax@5
  unsigned int v8; // eax@13
  int v9; // edx@13
  int v10; // eax@13
  int v11; // eax@16
  unsigned int v12; // eax@18
  char v13; // zf@20
  UINT v14; // [sp+Ch] [bp-8h]@4
  WCHAR DestStr; // [sp+10h] [bp-4h]@18

  v4 = MultiByteStr;
  if ( MultiByteStr )
  {
    v6 = *(_DWORD *)(MultiByteStr + 12);
    v5 = *(_DWORD *)MultiByteStr;
  }
  else
  {
    v6 = *(_DWORD *)(sub_10036ED3(a1, a2) + 8);
    v5 = sub_10036E87(a1, v6);
  }
  v14 = v5;
  if ( !v6 )
  {
    result = a3;
    if ( (unsigned int)(a3 - 65) <= 0x19 )
      result = a3 + 32;
    return result;
  }
  if ( (unsigned int)a3 < 0x100 )
  {
    if ( !v4 )
    {
      if ( !sub_10036DDC(a3, v6, a3) )
        return a3;
      goto LABEL_13;
    }
    if ( !(*(_BYTE *)(*(_DWORD *)(v4 + 4) + 2 * a3) & 1) )
      return a3;
  }
  if ( !v4 )
  {
LABEL_13:
    v10 = sub_10036B9C(a3, v6);
    v9 = a3 >> 8;
    v8 = *(_WORD *)(v10 + 2 * BYTE1(a3)) & 0x8000;
    goto LABEL_15;
  }
  v9 = a3 >> 8;
  v8 = ((unsigned int)*(_WORD *)(*(_DWORD *)(v4 + 4) + 2 * BYTE1(a3)) >> 15) & 1;
LABEL_15:
  if ( v8 )
  {
    LOBYTE(MultiByteStr) = v9;
    *(_WORD *)((char *)&MultiByteStr + 1) = (unsigned __int8)a3;
    v11 = 2;
  }
  else
  {
    LOWORD(MultiByteStr) = (unsigned __int8)a3;
    v11 = 1;
  }
  v12 = sub_100374A2(a3, v6, 0, v6, 0x100u, (LPCSTR)&MultiByteStr, v11, &DestStr, 3, v14, 1);
  if ( !v12 )
    return a3;
  v13 = v12 == 1;
  result = (unsigned __int8)DestStr;
  if ( !v13 )
    result = HIBYTE(DestStr) | ((unsigned __int8)DestStr << 8);
  return result;
}

//----- (10029C5F) --------------------------------------------------------
int __usercall sub_10029C5F<eax>(int a1<ebx>, int a2<edi>, int a3, int MultiByteStr)
{
  int v4; // esi@1
  int v5; // eax@2
  int v6; // edi@2
  int result; // eax@5
  unsigned int v8; // eax@13
  int v9; // edx@13
  int v10; // eax@13
  int v11; // eax@16
  unsigned int v12; // eax@18
  char v13; // zf@20
  UINT v14; // [sp+Ch] [bp-8h]@4
  WCHAR DestStr; // [sp+10h] [bp-4h]@18

  v4 = MultiByteStr;
  if ( MultiByteStr )
  {
    v6 = *(_DWORD *)(MultiByteStr + 12);
    v5 = *(_DWORD *)MultiByteStr;
  }
  else
  {
    v6 = *(_DWORD *)(sub_10036ED3(a1, a2) + 8);
    v5 = sub_10036E87(a1, v6);
  }
  v14 = v5;
  if ( !v6 )
  {
    result = a3;
    if ( (unsigned int)(a3 - 97) <= 0x19 )
      result = a3 - 32;
    return result;
  }
  if ( (unsigned int)a3 < 0x100 )
  {
    if ( !v4 )
    {
      if ( !sub_10036D86(a3, v6, a3) )
        return a3;
      goto LABEL_13;
    }
    if ( !(*(_BYTE *)(*(_DWORD *)(v4 + 4) + 2 * a3) & 2) )
      return a3;
  }
  if ( !v4 )
  {
LABEL_13:
    v10 = sub_10036B9C(a3, v6);
    v9 = a3 >> 8;
    v8 = *(_WORD *)(v10 + 2 * BYTE1(a3)) & 0x8000;
    goto LABEL_15;
  }
  v9 = a3 >> 8;
  v8 = ((unsigned int)*(_WORD *)(*(_DWORD *)(v4 + 4) + 2 * BYTE1(a3)) >> 15) & 1;
LABEL_15:
  if ( v8 )
  {
    LOBYTE(MultiByteStr) = v9;
    *(_WORD *)((char *)&MultiByteStr + 1) = (unsigned __int8)a3;
    v11 = 2;
  }
  else
  {
    LOWORD(MultiByteStr) = (unsigned __int8)a3;
    v11 = 1;
  }
  v12 = sub_100374A2(a3, v6, 0, v6, 0x200u, (LPCSTR)&MultiByteStr, v11, &DestStr, 3, v14, 1);
  if ( !v12 )
    return a3;
  v13 = v12 == 1;
  result = (unsigned __int8)DestStr;
  if ( !v13 )
    result = HIBYTE(DestStr) | ((unsigned __int8)DestStr << 8);
  return result;
}

//----- (10029D5C) --------------------------------------------------------
int __cdecl sub_10029D5C(int a1)
{
  signed int v1; // ebx@1
  bool v2; // ecx@1

  v1 = 0;
  *(_DWORD *)a1 = 0;
  memset((void *)(a1 + 4), 0, 0x28u);
  *(_DWORD *)a1 = sub_10036E87(0, a1 + 44);
  *(_DWORD *)(a1 + 4) = sub_10036EFB(0, a1);
  v2 = *(_DWORD *)(sub_10036ED3(0, a1) + 8) == 0;
  *(_DWORD *)(a1 + 8) = v2;
  if ( !v2 )
  {
    do
    {
      if ( sub_100376F3(v1, a1, v1) )
        *(_BYTE *)((v1 >> 3) + a1 + 12) |= 1 << (v1 & 7);
      ++v1;
    }
    while ( v1 < 256 );
  }
  return a1;
}

//----- (10029DC5) --------------------------------------------------------
int __usercall sub_10029DC5<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // esi@1

  v3 = sub_10036EAD(a1, a2);
  v2 = sub_10036ED3(a1, a2);
  if ( *(_DWORD *)(v2 + 4) )
    sub_10036E34(a1, *(_DWORD *)(v2 + 4));
  return v3;
}

//----- (10029DE6) --------------------------------------------------------
int __usercall sub_10029DE6<eax>(int a1<ebx>, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // edi@1
  int v7; // esi@1
  int v8; // eax@2
  int v9; // ebx@2
  unsigned int v10; // eax@5
  int result; // eax@7
  int v12; // eax@10

  v7 = a3 - a2;
  v6 = a5 - a4;
  if ( a6 )
  {
    v9 = *(_DWORD *)(a6 + 4);
    v8 = *(_DWORD *)a6;
  }
  else
  {
    v9 = *(_DWORD *)(sub_10036ED3(a1, v6) + 4);
    v8 = sub_10036EAD(v9, v6);
  }
  if ( v9 )
  {
    v12 = sub_1003910C(v9, v6, 0, v9, 0x1000u, a2, v7, a4, v6, v8);
    if ( v12 )
    {
      result = v12 - 2;
    }
    else
    {
      *(_DWORD *)sub_10037649(v9) = 22;
      result = 2147483647;
    }
  }
  else
  {
    v10 = a3 - a2;
    if ( v7 >= v6 )
      v10 = a5 - a4;
    result = sub_10037709(a2, a4, v10);
    if ( !result )
    {
      if ( v7 != v6 )
      {
        LOBYTE(result) = v7 >= v6;
        result = 2 * result - 1;
      }
    }
  }
  return result;
}

//----- (10029E7B) --------------------------------------------------------
signed int __cdecl sub_10029E7B(LPWSTR lpDestStr, int a2, LPCSTR lpMultiByteStr, UINT CodePage, int a5)
{
  signed int v5; // ebx@1
  int v6; // edi@1
  unsigned int v7; // esi@1
  int v8; // eax@2
  int v9; // ecx@2
  int v10; // eax@9
  int v12; // [sp+18h] [bp+Ch]@2
  UINT v13; // [sp+20h] [bp+14h]@4

  v7 = CodePage - (_DWORD)lpMultiByteStr;
  v6 = a2 - (_DWORD)lpDestStr;
  v5 = -1;
  if ( a5 )
  {
    v9 = *(_DWORD *)(a5 + 4);
    v8 = *(_DWORD *)a5;
    v12 = *(_DWORD *)(a5 + 4);
  }
  else
  {
    v12 = *(_DWORD *)(sub_10036ED3(-1, v6) + 4);
    v8 = sub_10036EAD(-1, v6);
    v9 = v12;
  }
  v13 = v8;
  if ( v9 || v8 )
  {
    v10 = sub_100374A2(-1, v6, 0, v9, 0x400u, lpMultiByteStr, v7, 0, 0, v8, 1);
    if ( v10 )
    {
      v5 = v10;
      if ( v10 <= v6 )
        sub_100374A2(v10, v6, 0, v12, 0x400u, lpMultiByteStr, v7, lpDestStr, v6, v13, 1);
    }
  }
  else
  {
    if ( v7 <= v6 )
      sub_10034EE0(lpDestStr, lpMultiByteStr, v7);
    v5 = v7;
  }
  return v5;
}

//----- (10029F21) --------------------------------------------------------
DWORD __cdecl sub_10029F21()
{
  struct _FILETIME SystemTimeAsFileTime; // [sp+0h] [bp-8h]@1

  GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
  return SystemTimeAsFileTime.dwLowDateTime + 717324288;
}

//----- (10029F48) --------------------------------------------------------
int __fastcall sub_10029F48(int a1, int a2, unsigned int a3)
{
  int v3; // edi@1
  int v4; // eax@3
  int v6; // eax@10
  signed int v7; // [sp-4h] [bp-10h]@2

  v3 = a1;
  *(_DWORD *)a1 = off_1006067C;
  if ( a3 <= 8 )
  {
    v7 = 32;
LABEL_8:
    v4 = v7;
    goto LABEL_10;
  }
  v4 = 16;
  if ( a3 > 0x10 )
  {
    if ( a3 > 0x20 )
    {
      if ( a3 > 0x40 )
      {
        v4 = 2 - (a3 > 0x80);
        goto LABEL_10;
      }
      v7 = 4;
    }
    else
    {
      v7 = 8;
    }
    goto LABEL_8;
  }
LABEL_10:
  *(_DWORD *)(a1 + 8) = v4;
  v6 = sub_1002A421(a2, 320, a1, 1u, 320);
  *(_DWORD *)(v3 + 4) = v6;
  sub_100391F0((void *)v6, 0, 320);
  *(_DWORD *)(v3 + 12) = a3;
  return v3;
}
// 1006067C: using guessed type int (*off_1006067C[3])();

//----- (10029FB5) --------------------------------------------------------
int __thiscall sub_10029FB5(int this)
{
  return sub_1002A4AA(*(LPVOID *)(this + 32));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10029FBF) --------------------------------------------------------
void __usercall sub_10029FBF(int a1<ecx>, int a2<ebx>)
{
  int v2; // ST00_4@1

  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = off_1006067C;
  sub_1002A486(a2, v2);
}
// 1006067C: using guessed type int (*off_1006067C[3])();

//----- (10029FCF) --------------------------------------------------------
int __thiscall sub_10029FCF(int this)
{
  int v1; // edi@1
  int v2; // esi@1
  int v3; // ecx@2
  int result; // eax@5
  char v5; // [sp+8h] [bp-4h]@2

  v2 = this;
  v1 = *(_DWORD *)(this + 8);
  if ( v1 )
  {
    sub_100348AC(&v5, *(_DWORD *)(this + 4) + 16);
    v3 = *(_DWORD *)v1;
    **(_DWORD **)(v2 + 4) = *(_DWORD *)v1;
    if ( !v3 )
      *(_DWORD *)(*(_DWORD *)(v2 + 4) + 8) = 0;
    sub_100348F2(&v5);
  }
  result = *(_DWORD *)(v2 + 4);
  *(_DWORD *)(result + 4) = *(_DWORD *)v2;
  if ( v1 )
    result = (*(int (__stdcall **)(int))(**(_DWORD **)(v2 + 12) + 20))(v1);
  return result;
}

//----- (1002A02D) --------------------------------------------------------
int __thiscall sub_1002A02D(int this, char a2)
{
  void *v2; // esi@1
  int result; // eax@4

  v2 = (void *)this;
  if ( a2 & 2 )
  {
    sub_1002B11F(this, 36, *(_DWORD *)(this - 4), sub_10029FB5);
    if ( a2 & 1 )
      sub_100303A3((char *)v2 - 4);
    result = (int)((char *)v2 - 4);
  }
  else
  {
    sub_1002A4AA(*(LPVOID *)(this + 32));
    if ( a2 & 1 )
      sub_1002A4AA(v2);
    result = (int)v2;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (1002A07B) --------------------------------------------------------
void *__userpurge sub_1002A07B<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_10029FBF(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002A09A) --------------------------------------------------------
char __thiscall sub_1002A09A(int this)
{
  int v1; // edx@1
  char result; // al@2

  v1 = *(_DWORD *)(*(_DWORD *)(this + 4) + 64);
  if ( v1 == *(_DWORD *)(*(_DWORD *)(this + 4) + 64) )
    result = v1 == **(_DWORD **)(this + 4);
  else
    result = 0;
  return result;
}

//----- (1002A0BD) --------------------------------------------------------
int __thiscall sub_1002A0BD(void *this)
{
  void *v1; // edi@1
  unsigned int v2; // esi@1
  int result; // eax@2
  int v4; // ecx@2

  v1 = this;
  v2 = 0;
  do
  {
    result = *((_DWORD *)v1 + 1);
    v4 = *(_DWORD *)(result + v2 + 136);
    if ( v4 )
    {
      if ( v4 != dword_10075164 )
        (*(void (__thiscall **)(void *, int))(*(_DWORD *)v1 + 20))(v1, v4);
      result = *((_DWORD *)v1 + 1);
      *(_DWORD *)(result + v2 + 136) = 0;
    }
    v2 += 20;
  }
  while ( v2 < 0xA0 );
  return result;
}
// 10075164: using guessed type int dword_10075164;

//----- (1002A0FD) --------------------------------------------------------
char __thiscall sub_1002A0FD(int this, int a2)
{
  int ebp0; // ebp@0
  int v3; // edi@1
  int v5; // eax@2

  v3 = this;
  _ESI = *(_DWORD *)(this + 4);
  while ( 2 )
  {
    v5 = *(_DWORD *)_ESI;
    do
    {
      if ( v5 == *(_DWORD *)(_ESI + 64) )
        return 0;
      _ECX = v5 + 1;
      __asm { lock cmpxchg [esi], ecx }
    }
    while ( v5 != v5 );
    if ( !(unsigned __int8)sub_1002A17E(ebp0, a2, v5, v3) )
      continue;
    break;
  }
  return 1;
}

//----- (1002A146) --------------------------------------------------------
int __thiscall sub_1002A146(int this, int a2)
{
  _EAX = *(_DWORD *)(this + 4) + 64;
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  return sub_1002A233(a2, _EDX, this, sub_1002A028);
}
// 1002A028: using guessed type int sub_1002A028();
// 1002A233: using guessed type _DWORD __stdcall sub_1002A233(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1002A17E) --------------------------------------------------------
int __userpurge sub_1002A17E<eax>(int a1<ebp>, int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ecx@1
  int v7; // esi@7
  int v8; // eax@7
  int v9; // edx@7
  int v10; // ecx@7
  int v11; // eax@7
  int v12; // ecx@7
  int v14; // [sp-10h] [bp-10h]@9

  sub_10035648();
  v4 = v6;
  v5 = *(_DWORD *)(a1 + 12) & 0xFFFFFFF8;
  *(_DWORD *)(a1 - 40) = 0;
  *(_DWORD *)(a1 - 36) = sub_10034BF4;
  while ( *(_DWORD *)(v4 + 4) != v5 )
    sub_100282E0(a1 - 48);
  *(_DWORD *)(a1 - 56) = 0;
  *(_DWORD *)(a1 - 52) = sub_10034BF4;
  while ( *(_DWORD *)(v4 + 12) == v5 )
    sub_100282E0(a1 - 64);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)v4;
  v8 = *(_DWORD *)(*(_DWORD *)(a1 + 16) + 8) - 1;
  v9 = v8 & ((unsigned int)v5 >> 3);
  v10 = (v8 & ((unsigned int)v5 >> 3)) == v8 ? *(_DWORD *)(a1 + 12) : 0;
  v11 = v5 + 8;
  v7 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 - 16) = v9;
  *(_DWORD *)(a1 - 32) = v11;
  *(_DWORD *)(a1 - 28) = v4;
  *(_DWORD *)(a1 - 24) = v10;
  *(_DWORD *)(a1 - 20) = v7;
  v12 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 - 4) = 0;
  if ( (1 << v9) & *(_DWORD *)(v12 + 4) )
  {
    v14 = *(_DWORD *)(a1 + 8);
    (*(void (__thiscall **)(int))(*(_DWORD *)v7 + 8))(v7);
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_10029FCF(a1 - 32);
  return sub_10035616(v14);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002A233) --------------------------------------------------------
#error "1002A369: call analysis failed (funcsize=86)"

//----- (1002A371) --------------------------------------------------------
int __thiscall sub_1002A371(int this)
{
  *(_DWORD *)this = &off_100606C8;
  _EAX = 2;
  _EDX = &unk_10075168;
  __asm { lock xadd [edx], eax }
  *(_DWORD *)(this + 4) = _EAX;
  return this;
}
// 100606C8: using guessed type int (*off_100606C8)();

//----- (1002A3B2) --------------------------------------------------------
PVOID __cdecl sub_1002A3B2(PVOID Ptr)
{
  PVOID result; // eax@1

  JUMPOUT(dword_10072258--, 0, loc_1003929F);
  result = EncodePointer(Ptr);
  dword_10075190[dword_10072258] = (int)result;
  return result;
}
// 10072258: using guessed type int dword_10072258;
// 10075190: using guessed type int dword_10075190[];

//----- (1002A3E0) --------------------------------------------------------
void __cdecl sub_1002A3E0(LPCRITICAL_SECTION lpCriticalSection)
{
  DeleteCriticalSection(lpCriticalSection);
}

//----- (1002A3EE) --------------------------------------------------------
int __cdecl sub_1002A3EE(LPCRITICAL_SECTION lpCriticalSection)
{
  return sub_1003956C(lpCriticalSection, 0xFA0u, 0);
}

//----- (1002A405) --------------------------------------------------------
void __cdecl sub_1002A405(LPCRITICAL_SECTION lpCriticalSection)
{
  EnterCriticalSection(lpCriticalSection);
}

//----- (1002A413) --------------------------------------------------------
void __cdecl sub_1002A413(LPCRITICAL_SECTION lpCriticalSection)
{
  LeaveCriticalSection(lpCriticalSection);
}

//----- (1002A421) --------------------------------------------------------
int __usercall sub_1002A421<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, unsigned int a4, int a5)
{
  int v5; // eax@1
  int v6; // esi@2
  int v7; // eax@3
  int v8; // ecx@3
  int result; // eax@4
  int (__stdcall **v10)(char); // [sp+0h] [bp-Ch]@5

  v5 = a5 * a4;
  if ( a5 * a4 < a4
    || (v6 = dword_1007236C, dword_1007236C + v5 < (unsigned int)v5)
    || (v7 = sub_10030930(a1, dword_1007236C + v5, a2, a3, dword_1007236C + v5), v8 = v7, !v7) )
  {
    a4 = (unsigned int)"bad allocation";
    sub_1002AEC9((int)&v10, (int)&a4, 1);
    v10 = &off_1005F2C4;
    sub_100355BB((int)&v10, (int)&unk_1006AA70);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1002A486);
  }
  result = -v6 & (v6 + v7);
  *(_DWORD *)(result - 4) = v8;
  return result;
}
// 1005F2C4: using guessed type int (__stdcall *off_1005F2C4)(char);
// 1007236C: using guessed type int dword_1007236C;

//----- (1002A486) --------------------------------------------------------
void __usercall sub_1002A486(int a1<ebx>, int a2)
{
  if ( a2 )
    sub_100309C2(a1, *(LPVOID *)(a2 - 4));
}

//----- (1002A49B) --------------------------------------------------------
int __usercall sub_1002A49B<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, int ecx0<ecx>, char a4)
{
  if ( ecx0 == __security_cookie )
    __asm { rep retn }
  return sub_100306B2(a1, a2, a3, a4);
}
// 10073200: using guessed type int __security_cookie;

//----- (1002A4B0) --------------------------------------------------------
void *__cdecl sub_1002A4B0(void *a1, const void *a2, unsigned int a3)
{
  int v38; // eax@29
  int v43; // edx@34
  unsigned int v44; // ecx@34
  void *result; // eax@48
  int v46; // edi@52
  int v47; // esi@52
  int v48; // edx@53
  unsigned int v49; // ecx@53
  int v50; // eax@64
  unsigned int k; // edx@65
  unsigned int v52; // edx@65
  int v53; // ecx@65
  unsigned int l; // edx@68
  int v55; // ecx@70
  char v56; // al@71
  unsigned int m; // ecx@71
  int n; // ecx@73
  unsigned int v59; // eax@76
  int i; // ecx@76
  unsigned int j; // eax@78
  int v62; // [sp-8h] [bp-10h]@76

  _ESI = (int)a2;
  _ECX = a3;
  _EDI = (int)a1;
  if ( a1 > a2 && a1 < (char *)a2 + a3 )
  {
    v47 = (int)(a2 + a3 - 4);
    v46 = (int)(a1 + a3 - 4);
    if ( v46 & 3 )
    {
      if ( a3 >= 4 )
        JUMPOUT(__CS__, *((_DWORD *)loc_1002A884 + (v46 & 3) + 1));
      switch ( a3 )
      {
        case 0u:
LABEL_60:
          result = a1;
          break;
        case 1u:
LABEL_61:
          *(_BYTE *)(v46 + 3) = *(_BYTE *)(v47 + 3);
          result = a1;
          break;
        case 2u:
LABEL_62:
          *(_BYTE *)(v46 + 3) = *(_BYTE *)(v47 + 3);
          *(_BYTE *)(v46 + 2) = *(_BYTE *)(v47 + 2);
          result = a1;
          break;
        case 3u:
          goto LABEL_63;
      }
    }
    else
    {
      v49 = a3 >> 2;
      v48 = a3 & 3;
      if ( a3 >> 2 < 8 )
      {
        switch ( -v49 )
        {
          case 0:
            switch ( v48 )
            {
              case 0:
                goto LABEL_60;
              case 1:
                goto LABEL_61;
              case 2:
                goto LABEL_62;
              case 3:
                goto LABEL_63;
            }
        }
      }
      else
      {
        memcpy((void *)v46, (const void *)v47, 4 * v49);
        v47 += 4 * v49;
        v46 += 4 * v49;
        switch ( v48 )
        {
          case 0:
            goto LABEL_60;
          case 1:
            goto LABEL_61;
          case 2:
            goto LABEL_62;
          case 3:
            break;
        }
      }
LABEL_63:
      *(_BYTE *)(v46 + 3) = *(_BYTE *)(v47 + 3);
      *(_BYTE *)(v46 + 2) = *(_BYTE *)(v47 + 2);
      *(_BYTE *)(v46 + 1) = *(_BYTE *)(v47 + 1);
      result = a1;
    }
  }
  else
  {
    __asm { bt      dword_10075780, 1 }
    if ( _CF )
    {
      memcpy(a1, a2, a3);
      return a1;
    }
    if ( a3 < 0x80 )
      goto LABEL_33;
    if ( ((unsigned int)a2 ^ (unsigned int)a1) & 0xF )
      goto LABEL_83;
    __asm { bt      dword_10073238, 1 }
    if ( !_CF )
    {
LABEL_83:
      __asm { bt      dword_10075780, 0 }
      if ( _CF )
      {
        if ( !((_BYTE)a1 & 3) )
        {
          if ( !((_BYTE)a2 & 3) )
          {
            __asm { bt      edi, 2 }
            if ( _CF )
            {
              _ECX = a3 - 4;
              _ESI = (int)((char *)a2 + 4);
              *(_DWORD *)a1 = *(_DWORD *)a2;
              _EDI = (int)((char *)a1 + 4);
            }
            __asm { bt      edi, 3 }
            if ( _CF )
            {
              __asm { movq    xmm1, qword ptr [esi] }
              _ECX -= 8;
              _ESI += 8;
              __asm { movq    qword ptr [edi], xmm1 }
              _EDI += 8;
            }
            if ( _ESI & 7 )
            {
              __asm { bt      esi, 3 }
              if ( _CF )
              {
                __asm { movdqa  xmm1, xmmword ptr [esi-0Ch] }
                _ESI = _ESI - 12;
                do
                {
                  __asm { movdqa  xmm3, xmmword ptr [esi+10h] }
                  _ECX -= 48;
                  __asm
                  {
                    movdqa  xmm0, xmmword ptr [esi+20h]
                    movdqa  xmm5, xmmword ptr [esi+30h]
                  }
                  _ESI += 48;
                  __asm
                  {
                    movdqa  xmm2, xmm3
                    palignr xmm3, xmm1, 0Ch
                    movdqa  xmmword ptr [edi], xmm3
                    movdqa  xmm4, xmm0
                    palignr xmm0, xmm2, 0Ch
                    movdqa  xmmword ptr [edi+10h], xmm0
                    movdqa  xmm1, xmm5
                    palignr xmm5, xmm4, 0Ch
                    movdqa  xmmword ptr [edi+20h], xmm5
                  }
                  _EDI += 48;
                }
                while ( _ECX >= 48 );
                _ESI = _ESI + 12;
              }
              else
              {
                __asm { movdqa  xmm1, xmmword ptr [esi-4] }
                _ESI = _ESI - 4;
                do
                {
                  __asm { movdqa  xmm3, xmmword ptr [esi+10h] }
                  _ECX -= 48;
                  __asm
                  {
                    movdqa  xmm0, xmmword ptr [esi+20h]
                    movdqa  xmm5, xmmword ptr [esi+30h]
                  }
                  _ESI += 48;
                  __asm
                  {
                    movdqa  xmm2, xmm3
                    palignr xmm3, xmm1, 4
                    movdqa  xmmword ptr [edi], xmm3
                    movdqa  xmm4, xmm0
                    palignr xmm0, xmm2, 4
                    movdqa  xmmword ptr [edi+10h], xmm0
                    movdqa  xmm1, xmm5
                    palignr xmm5, xmm4, 4
                    movdqa  xmmword ptr [edi+20h], xmm5
                  }
                  _EDI += 48;
                }
                while ( _ECX >= 48 );
                _ESI = _ESI + 4;
              }
            }
            else
            {
              __asm { movdqa  xmm1, xmmword ptr [esi-8] }
              _ESI = _ESI - 8;
              do
              {
                __asm { movdqa  xmm3, xmmword ptr [esi+10h] }
                _ECX -= 48;
                __asm
                {
                  movdqa  xmm0, xmmword ptr [esi+20h]
                  movdqa  xmm5, xmmword ptr [esi+30h]
                }
                _ESI += 48;
                __asm
                {
                  movdqa  xmm2, xmm3
                  palignr xmm3, xmm1, 8
                  movdqa  xmmword ptr [edi], xmm3
                  movdqa  xmm4, xmm0
                  palignr xmm0, xmm2, 8
                  movdqa  xmmword ptr [edi+10h], xmm0
                  movdqa  xmm1, xmm5
                  palignr xmm5, xmm4, 8
                  movdqa  xmmword ptr [edi+20h], xmm5
                }
                _EDI += 48;
              }
              while ( _ECX >= 48 );
              _ESI = _ESI + 8;
            }
            while ( _ECX >= 16 )
            {
              __asm { movdqu  xmm1, xmmword ptr [esi] }
              _ECX -= 16;
              _ESI += 16;
              __asm { movdqa  xmmword ptr [edi], xmm1 }
              _EDI += 16;
            }
            __asm { bt      ecx, 2 }
            if ( _CF )
            {
              v38 = *(_DWORD *)_ESI;
              _ECX -= 4;
              _ESI += 4;
              *(_DWORD *)_EDI = v38;
              _EDI += 4;
            }
            __asm { bt      ecx, 3 }
            if ( _CF )
            {
              __asm { movq    xmm1, qword ptr [esi] }
              _ECX -= 8;
              __asm { movq    qword ptr [edi], xmm1 }
            }
            JUMPOUT(__CS__, *((_DWORD *)off_1002A7E8 + _ECX));
          }
          goto LABEL_34;
        }
        goto LABEL_36;
      }
LABEL_33:
      if ( !((_BYTE)a1 & 3) )
      {
LABEL_34:
        v44 = a3 >> 2;
        v43 = a3 & 3;
        if ( a3 >> 2 < 8 )
        {
          switch ( v44 )
          {
            case 0u:
              goto LABEL_47;
            case 1u:
              goto LABEL_46;
            case 2u:
              goto LABEL_45;
            case 3u:
              goto LABEL_44;
            case 4u:
              goto LABEL_43;
            case 5u:
              goto LABEL_42;
            case 6u:
              break;
            case 7u:
              *((_DWORD *)a1 + v44 - 7) = *((_DWORD *)a2 + v44 - 7);
              break;
          }
          *((_DWORD *)a1 + v44 - 6) = *((_DWORD *)a2 + v44 - 6);
LABEL_42:
          *((_DWORD *)a1 + v44 - 5) = *((_DWORD *)a2 + v44 - 5);
LABEL_43:
          *((_DWORD *)a1 + v44 - 4) = *((_DWORD *)a2 + v44 - 4);
LABEL_44:
          *((_DWORD *)a1 + v44 - 3) = *((_DWORD *)a2 + v44 - 3);
LABEL_45:
          *((_DWORD *)a1 + v44 - 2) = *((_DWORD *)a2 + v44 - 2);
LABEL_46:
          *((_DWORD *)a1 + v44 - 1) = *((_DWORD *)a2 + v44 - 1);
          _ESI = (int)((char *)a2 + 4 * v44);
          _EDI = (int)((char *)a1 + 4 * v44);
LABEL_47:
          switch ( v43 )
          {
            case 0:
              return a1;
            case 1:
LABEL_49:
              *(_BYTE *)_EDI = *(_BYTE *)_ESI;
              return a1;
            case 2:
LABEL_50:
              *(_BYTE *)_EDI = *(_BYTE *)_ESI;
              *(_BYTE *)(_EDI + 1) = *(_BYTE *)(_ESI + 1);
              return a1;
            case 3:
              break;
          }
        }
        else
        {
          memcpy(a1, a2, 4 * v44);
          _ESI = (int)((char *)a2 + 4 * v44);
          _EDI = (int)((char *)a1 + 4 * v44);
          switch ( v43 )
          {
            case 0:
              return a1;
            case 1:
              goto LABEL_49;
            case 2:
              goto LABEL_50;
            case 3:
              break;
          }
        }
        *(_BYTE *)_EDI = *(_BYTE *)_ESI;
        *(_BYTE *)(_EDI + 1) = *(_BYTE *)(_ESI + 1);
        *(_BYTE *)(_EDI + 2) = *(_BYTE *)(_ESI + 2);
        return a1;
      }
LABEL_36:
      if ( a3 >= 4 )
        JUMPOUT(__CS__, *((_DWORD *)loc_1002A6F8 + ((_BYTE)a1 & 3) + 1));
      JUMPOUT(__CS__, *((_DWORD *)loc_1002A7F8 + a3 - 4));
    }
    v50 = (_BYTE)a2 & 0xF;
    if ( (_BYTE)a2 & 0xF )
    {
      v62 = a3 - (16 - v50);
      v59 = 16 - v50;
      for ( i = v59 & 3; i; --i )
        *(_BYTE *)_EDI++ = *(_BYTE *)_ESI++;
      for ( j = v59 >> 2; j; --j )
      {
        *(_DWORD *)_EDI = *(_DWORD *)_ESI;
        _ESI += 4;
        _EDI += 4;
      }
      _ECX = v62;
    }
    v52 = _ECX;
    v53 = _ECX & 0x7F;
    for ( k = v52 >> 7; k; --k )
    {
      __asm
      {
        movdqa  xmm0, xmmword ptr [esi]
        movdqa  xmm1, xmmword ptr [esi+10h]
        movdqa  xmm2, xmmword ptr [esi+20h]
        movdqa  xmm3, xmmword ptr [esi+30h]
        movdqa  xmmword ptr [edi], xmm0
        movdqa  xmmword ptr [edi+10h], xmm1
        movdqa  xmmword ptr [edi+20h], xmm2
        movdqa  xmmword ptr [edi+30h], xmm3
        movdqa  xmm4, xmmword ptr [esi+40h]
        movdqa  xmm5, xmmword ptr [esi+50h]
        movdqa  xmm6, xmmword ptr [esi+60h]
        movdqa  xmm7, xmmword ptr [esi+70h]
        movdqa  xmmword ptr [edi+40h], xmm4
        movdqa  xmmword ptr [edi+50h], xmm5
        movdqa  xmmword ptr [edi+60h], xmm6
        movdqa  xmmword ptr [edi+70h], xmm7
      }
      _ESI += 128;
      _EDI += 128;
    }
    if ( v53 )
    {
      for ( l = (unsigned int)v53 >> 4; l; --l )
      {
        __asm
        {
          movdqa  xmm0, xmmword ptr [esi]
          movdqa  xmmword ptr [edi], xmm0
        }
        _ESI += 16;
        _EDI += 16;
      }
      v55 = v53 & 0xF;
      if ( v55 )
      {
        v56 = v55;
        for ( m = (unsigned int)v55 >> 2; m; --m )
        {
          *(_DWORD *)_EDI = *(_DWORD *)_ESI;
          _ESI += 4;
          _EDI += 4;
        }
        for ( n = v56 & 3; n; --n )
          *(_BYTE *)_EDI++ = *(_BYTE *)_ESI++;
      }
    }
    result = a1;
  }
  return result;
}
// 1002A6F8: using guessed type int __cdecl loc_1002A6F8(int, int, int);
// 1002A7E8: using guessed type int __cdecl off_1002A7E8(int, int, int);
// 1002A7F8: using guessed type int __cdecl loc_1002A7F8(int, int, int);
// 1002A884: using guessed type int __cdecl loc_1002A884(int, int, int);

//----- (1002AAF4) --------------------------------------------------------
__int64 __usercall sub_1002AAF4<edx:eax>(int a1<ebx>, int a2, int a3)
{
  __int64 result; // qax@2
  unsigned int v4; // eax@3
  int v5; // ebx@3
  int v6; // esi@3
  __int64 v7; // qax@3
  unsigned __int8 v8; // cf@3
  signed int v9; // eax@5
  int v10; // ecx@7
  __int64 v11; // qax@7
  unsigned __int8 v12; // cf@7
  unsigned __int8 v13; // cf@8
  int v14; // edi@11
  unsigned __int64 v15; // ST04_8@11
  __int64 v16; // qax@11
  unsigned __int64 v17; // ST04_8@12
  __int64 v18; // qax@12
  unsigned __int64 v19; // ST04_8@13
  __int64 v20; // qax@13
  __int64 v21; // qax@16
  int v22; // ecx@16
  unsigned __int64 v23; // qdi@16
  unsigned __int64 v24; // ST04_8@16
  __int64 v25; // qax@16
  __int64 v26; // qcx@16
  __int64 v27; // qax@16
  int v28; // eax@16
  unsigned __int8 v29; // cf@16
  int v30; // edx@16
  int v31; // eax@16
  int v32; // edx@16
  __int64 v33; // qax@16
  __int64 v34; // qax@16
  __int64 v35; // qax@16
  __int64 v36; // qax@16
  __int64 v37; // qax@16
  __int64 v38; // qax@16
  int v39; // eax@20
  signed int v40; // eax@23
  int v41; // [sp+4h] [bp-48h]@1
  int v42; // [sp+8h] [bp-44h]@1
  int v43; // [sp+Ch] [bp-40h]@11
  int v44; // [sp+10h] [bp-3Ch]@1
  int v45; // [sp+14h] [bp-38h]@11
  unsigned int v46; // [sp+18h] [bp-34h]@11
  __int64 v47; // [sp+1Ch] [bp-30h]@3
  char v48; // [sp+24h] [bp-28h]@19
  int v49; // [sp+44h] [bp-8h]@22
  unsigned int v50; // [sp+48h] [bp-4h]@1
  int v51; // [sp+4Ch] [bp+0h]@1

  v50 = (unsigned int)&v51 ^ __security_cookie;
  v42 = 0;
  v41 = 0;
  v44 = a2;
  if ( !a2 )
  {
    *(_DWORD *)sub_10037649(a1) = 22;
    sub_1003A151(a1, 0);
    return -1i64;
  }
  v7 = *(_DWORD *)(a2 + 20);
  v6 = (unsigned __int64)*(_DWORD *)(a2 + 20) >> 32;
  v5 = v7;
  v8 = (_DWORD)v7 >= 0x45u;
  v4 = v7 - 69;
  LODWORD(v47) = v5;
  HIDWORD(v47) = HIDWORD(v7);
  if ( v8 + HIDWORD(v7) != 1 )
    goto LABEL_27;
  if ( v4 > 0x408 )
    goto LABEL_27;
  v9 = *(_DWORD *)(a2 + 16);
  if ( v9 < 0 || v9 > 11 )
  {
    v10 = v9 % 12;
    v11 = v9 / 12;
    v12 = (_DWORD)v11 >= (unsigned int)-v5;
    v5 += v11;
    v6 += HIDWORD(v11) + v12;
    LODWORD(v47) = v5;
    HIDWORD(v47) = v6;
    *(_DWORD *)(a2 + 16) = v10;
    if ( v10 < 0 )
    {
      v13 = (unsigned int)v5-- >= 1;
      v6 = v13 + v6 - 1;
      *(_DWORD *)(a2 + 16) = v10 + 12;
      LODWORD(v47) = v5;
      HIDWORD(v47) = v6;
    }
    if ( ((unsigned int)v5 >= 0x45) + v6 != 1 || (unsigned int)(v5 - 69) > 0x408 )
      goto LABEL_27;
  }
  v46 = *(_DWORD *)(a2 + 16);
  HIDWORD(v15) = v6;
  v14 = dword_100732F0[v46];
  LODWORD(v15) = v5;
  v43 = v14;
  v45 = (unsigned __int64)v14 >> 32;
  LODWORD(v16) = sub_1003ACF0(v15, 4i64);
  if ( !v16 && (HIDWORD(v17) = v6, LODWORD(v17) = v5, LODWORD(v18) = sub_1003ACF0(v17, 100i64), v18)
    || (HIDWORD(v19) = ((unsigned int)v5 >= 0xFFFFF894) + v6,
        LODWORD(v19) = v5 + 1900,
        LODWORD(v20) = sub_1003ACF0(v19, 400i64),
        !v20) )
  {
    if ( (signed int)v46 > 1 )
    {
      v45 += (unsigned int)v14 >= 0xFFFFFFFF;
      v43 = v14 + 1;
    }
  }
  v23 = __PAIR__(v6, v5) - 1;
  HIDWORD(v24) = ((unsigned int)v5 >= 0xFFFFFED5) + HIDWORD(v47);
  LODWORD(v24) = v5 + 299;
  LODWORD(v25) = sub_1003AC40(v24, 0x190u, 0);
  v26 = v25;
  v27 = *(_DWORD *)(v44 + 12);
  v46 = v27 + v26;
  HIDWORD(v26) = (unsigned __int64)(v27 + v26) >> 32;
  v28 = sub_1003AC40(v23, 0x64u, 0);
  v29 = v46 < v28;
  v46 -= v28;
  HIDWORD(v26) -= v29 + v30;
  v31 = sub_1003AC40(v23, 4u, 0);
  HIDWORD(v23) = v31 + v46;
  HIDWORD(v26) += v32 + (v31 >= (unsigned int)-v46);
  v33 = sub_10039A20(v47, 365i64);
  v34 = sub_10039A20(
          __PAIR__(
            v45
          + (v43 >= (unsigned int)-(v33 + HIDWORD(v23)))
          + HIDWORD(v33)
          + (unsigned int)((_DWORD)v33 >= (unsigned int)-HIDWORD(v23))
          + HIDWORD(v26),
            v43 + (_DWORD)v33 + HIDWORD(v23))
        - 25567,
          24i64);
  v5 = v44;
  HIDWORD(v23) = HIDWORD(v34);
  v35 = (unsigned int)v34 + *(_DWORD *)(v44 + 8);
  HIDWORD(v35) += HIDWORD(v23);
  v36 = sub_10039A20(v35, 60i64);
  HIDWORD(v23) = HIDWORD(v36);
  v37 = (unsigned int)v36 + *(_DWORD *)(v44 + 4);
  HIDWORD(v37) += HIDWORD(v23);
  v38 = sub_10039A20(v37, 60i64);
  v22 = v38;
  HIDWORD(v23) = HIDWORD(v38);
  v21 = (unsigned int)v38 + *(_DWORD *)v44;
  HIDWORD(v21) += HIDWORD(v23);
  v47 = v21;
  if ( a3 )
  {
    sub_1003A49A(SHIDWORD(v21), v22, v44, 0);
    if ( sub_1003A1CE(v44, 0, (int)&v42) || sub_1003A1F8(v5, 0, (int)&v41) )
    {
      sub_1003A161(v5, 0);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1002ADA0);
    }
    v47 += v41;
    if ( sub_1003A222((int)&v48, (int)&v47) )
      goto LABEL_27;
    v39 = *(_DWORD *)(v5 + 32);
    if ( v39 <= 0 && (v39 >= 0 || v49 <= 0) )
      goto LABEL_26;
    v47 += v42;
    v40 = sub_1003A222((int)&v48, (int)&v47);
  }
  else
  {
    v40 = sub_100303A8(v44, 0, (int)&v48, (int)&v47);
  }
  if ( !v40 )
  {
LABEL_26:
    result = v47;
    memcpy((void *)v5, &v48, 0x24u);
    return result;
  }
LABEL_27:
  *(_DWORD *)sub_10037649(v5) = 22;
  return -1i64;
}
// 10073200: using guessed type int __security_cookie;
// 100732F0: using guessed type int dword_100732F0[];

//----- (1002ADA0) --------------------------------------------------------
__int64 __usercall sub_1002ADA0<edx:eax>(int a1<ebx>, int a2)
{
  return sub_1002AAF4(a1, a2, 0);
}

//----- (1002ADB1) --------------------------------------------------------
int __usercall sub_1002ADB1<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int dwBytes)
{
  bool v5; // eax@2
  int v6; // ST08_4@2
  int result; // eax@3
  int v8; // ecx@5
  int v9; // esi@5
  int (__stdcall **v10)(char); // [sp+0h] [bp-10h]@5
  int v11; // [sp+Ch] [bp-4h]@5

  while ( 1 )
  {
    result = sub_10030930(a1, a2, a3, a4, dwBytes);
    if ( result )
      break;
    v5 = sub_1003ADA2(dwBytes);
    a2 = v6;
    if ( !v5 )
    {
      v11 = (int)"bad allocation";
      sub_1002AEC9((int)&v10, (int)&v11, 1);
      v10 = &off_1005F2C4;
      sub_100355BB((int)&v10, (int)&unk_1006AA70);
      __asm { int     3               ; Trap to Debugger }
      v9 = v8;
      sub_1002AE6D(v8, a3, dwBytes);
      *(_DWORD *)v9 = &off_10060914;
      return v9;
    }
  }
  return result;
}
// 1005F2C4: using guessed type int (__stdcall *off_1005F2C4)(char);
// 10060914: using guessed type int (__stdcall *off_10060914)(char);

//----- (1002AE1B) --------------------------------------------------------
int __thiscall sub_1002AE1B(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002AE88(this, a2);
  *(_DWORD *)v3 = &off_10060914;
  return v3;
}
// 10060914: using guessed type int (__stdcall *off_10060914)(char);

//----- (1002AE36) --------------------------------------------------------
int __userpurge sub_1002AE36<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_100608FC;
  return v4;
}
// 100608FC: using guessed type int (__stdcall *off_100608FC)(char);

//----- (1002AE51) --------------------------------------------------------
int __thiscall sub_1002AE51(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002AEA4(this, (int *)&a2);
  *(_DWORD *)v3 = &off_100608FC;
  return v3;
}
// 100608FC: using guessed type int (__stdcall *off_100608FC)(char);

//----- (1002AE6D) --------------------------------------------------------
int __userpurge sub_1002AE6D<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10060908;
  return v4;
}
// 10060908: using guessed type int (__stdcall *off_10060908)(char);

//----- (1002AE88) --------------------------------------------------------
int __thiscall sub_1002AE88(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002AEA4(this, (int *)&a2);
  *(_DWORD *)v3 = &off_10060908;
  return v3;
}
// 10060908: using guessed type int (__stdcall *off_10060908)(char);

//----- (1002AEA4) --------------------------------------------------------
int __thiscall sub_1002AEA4(int this, int *a2)
{
  int v3; // esi@1

  v3 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = &off_100608DC;
  *(_BYTE *)(this + 8) = 0;
  sub_1002AF7B((void *)this, *a2);
  return v3;
}
// 100608DC: using guessed type int (__stdcall *off_100608DC)(char);

//----- (1002AEC9) --------------------------------------------------------
int __thiscall sub_1002AEC9(int this, int a2, int a3)
{
  *(_DWORD *)this = &off_100608DC;
  *(_DWORD *)(this + 4) = *(_DWORD *)a2;
  *(_BYTE *)(this + 8) = 0;
  return this;
}
// 100608DC: using guessed type int (__stdcall *off_100608DC)(char);

//----- (1002AEE4) --------------------------------------------------------
int __userpurge sub_1002AEE4<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = &off_100608DC;
  *(_BYTE *)(a1 + 8) = 0;
  sub_1002AF23(a1, a2, a3);
  return v4;
}
// 100608DC: using guessed type int (__stdcall *off_100608DC)(char);

//----- (1002AF07) --------------------------------------------------------
int __thiscall sub_1002AF07(int this)
{
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = &off_100608DC;
  *(_BYTE *)(this + 8) = 0;
  return this;
}
// 100608DC: using guessed type int (__stdcall *off_100608DC)(char);

//----- (1002AF18) --------------------------------------------------------
void __usercall sub_1002AF18(int a1<ecx>, int a2<ebx>)
{
  *(_DWORD *)a1 = &off_100608DC;
  sub_1002AFB9(a1, a2);
}
// 100608DC: using guessed type int (__stdcall *off_100608DC)(char);

//----- (1002AF23) --------------------------------------------------------
int __userpurge sub_1002AF23<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v3; // esi@1

  v3 = a1;
  if ( a1 != a3 )
  {
    sub_1002AFB9(a1, a2);
    if ( *(_BYTE *)(a3 + 8) )
      sub_1002AF7B((void *)v3, *(_DWORD *)(a3 + 4));
    else
      *(_DWORD *)(v3 + 4) = *(_DWORD *)(a3 + 4);
  }
  return v3;
}

//----- (1002AF56) --------------------------------------------------------
void *__userpurge sub_1002AF56<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  *(_DWORD *)a1 = &off_100608DC;
  sub_1002AFB9(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100608DC: using guessed type int (__stdcall *off_100608DC)(char);

//----- (1002AF7B) --------------------------------------------------------
void __thiscall sub_1002AF7B(void *this, int a2)
{
  int v2; // ebx@1
  int v3; // eax@2
  int v4; // edi@2
  int v5; // eax@2
  int v6; // edx@2
  int v7; // ecx@2

  v2 = (int)this;
  if ( a2 )
  {
    v5 = sub_10035530(a2);
    v4 = v5 + 1;
    v3 = sub_10030930(v6, v7, v2, v5 + 1, v5 + 1);
    *(_DWORD *)(v2 + 4) = v3;
    if ( v3 )
    {
      sub_1003ADD5(v2, v4, v3, v4, a2);
      *(_BYTE *)(v2 + 8) = 1;
    }
  }
}

//----- (1002AFB9) --------------------------------------------------------
void __usercall sub_1002AFB9(int a1<ecx>, int a2<ebx>)
{
  int v2; // esi@1

  v2 = a1;
  if ( *(_BYTE *)(a1 + 8) )
    sub_100309C2(a2, *(LPVOID *)(a1 + 4));
  *(_DWORD *)(v2 + 4) = 0;
  *(_BYTE *)(v2 + 8) = 0;
}

//----- (1002AFD5) --------------------------------------------------------
int __thiscall sub_1002AFD5(int this)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 4);
  if ( !result )
    result = (int)"Unknown exception";
  return result;
}

//----- (1002AFE5) --------------------------------------------------------
signed int __usercall sub_1002AFE5<eax>(int a1<ecx>, int a2<ebx>)
{
  void *v2; // esi@1
  signed int result; // eax@2

  v2 = sub_100374E6(a1, a2, 0x20u, 4u);
  Ptr = EncodePointer(v2);
  dword_100778C8 = Ptr;
  if ( v2 )
  {
    *(_DWORD *)v2 = 0;
    result = 0;
  }
  else
  {
    result = 24;
  }
  return result;
}

//----- (1002B014) --------------------------------------------------------
void __usercall sub_1002B014(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, PVOID Ptr)
{
  sub_1003B0C9(a1, a2, a3, a4);
  sub_1002B054(Ptr);
  sub_1003B0D2();
}

//----- (1002B054) --------------------------------------------------------
PVOID __cdecl sub_1002B054(PVOID Ptr)
{
  int v1; // ebx@1
  int v2; // edi@2
  int v3; // edx@3
  int v4; // ecx@3
  SIZE_T v5; // esi@3
  signed int v6; // eax@4
  int v7; // eax@6
  int v8; // eax@7
  int v9; // ST04_4@7
  int v11; // [sp-4h] [bp-14h]@3
  PVOID v12; // [sp+Ch] [bp-4h]@1

  v12 = DecodePointer(::Ptr);
  v1 = (int)DecodePointer(dword_100778C8);
  if ( v1 >= (unsigned int)v12 )
  {
    v2 = v1 - (_DWORD)v12;
    if ( (unsigned int)(v1 - (_DWORD)v12 + 4) >= 4 )
    {
      v5 = sub_1003B20A(v1, v2, v12);
      v4 = v11;
      if ( v5 >= v2 + 4 )
      {
LABEL_11:
        *(_DWORD *)v1 = EncodePointer(Ptr);
        dword_100778C8 = EncodePointer((PVOID)(v1 + 4));
        return Ptr;
      }
      v6 = 2048;
      if ( v5 < 0x800 )
        v6 = v5;
      v7 = v5 + v6;
      if ( v7 >= v5 && (v8 = sub_10037579(v3, v11, (int)v12, v2, v12, v7), v4 = v9, v8)
        || v5 + 16 >= v5 && (v8 = sub_10037579(v3, v4, (int)v12, v2, v12, v5 + 16)) != 0 )
      {
        v1 = v8 + 4 * (v2 >> 2);
        ::Ptr = EncodePointer((PVOID)v8);
        goto LABEL_11;
      }
    }
  }
  return 0;
}

//----- (1002B10A) --------------------------------------------------------
int __usercall sub_1002B10A<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, void *a5)
{
  int v6; // eax@1

  sub_1002B014(a1, a2, a3, a4, a5);
  return (v6 != 0) - 1;
}

//----- (1002B11F) --------------------------------------------------------
signed int __stdcall sub_1002B11F(int a1, int a2, int a3, void (__thiscall *a4)(_DWORD))
{
  int v4; // edi@1
  int i; // esi@1

  v4 = a3;
  for ( i = a3 * a2 + a1; ; a4(i) )
  {
    --v4;
    if ( v4 < 0 )
      break;
    i -= a2;
  }
  return 1;
}

//----- (1002B18E) --------------------------------------------------------
int __stdcall sub_1002B18E(int a1, int a2, int a3, int (*a4)(void))
{
  char v4; // sf@1
  int result; // eax@2

  while ( 1 )
  {
    v4 = a3-- - 1 < 0;
    if ( v4 )
      break;
    a1 -= a2;
    result = a4();
  }
  return result;
}

//----- (1002B1EC) --------------------------------------------------------
int __thiscall sub_1002B1EC(int this, int a2, int a3, int a4)
{
  int v5; // esi@1

  v5 = this;
  sub_1000C740(this, a4);
  *(_DWORD *)(v5 + 28) = a2;
  *(_DWORD *)(v5 + 32) = a3;
  *(_DWORD *)v5 = &off_1006093C;
  return v5;
}
// 1006093C: using guessed type int (__stdcall *off_1006093C)(char);

//----- (1002B21D) --------------------------------------------------------
void *__thiscall sub_1002B21D(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10060920;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10060920: using guessed type int (__stdcall *off_10060920)(char);

//----- (1002B23D) --------------------------------------------------------
int __thiscall sub_1002B23D(void *this, int a2)
{
  int result; // eax@1

  result = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(result + 4);
    *(_DWORD *)a2 = *(_DWORD *)this;
    **(_DWORD **)(*(_DWORD *)this + 4) = a2;
    result = *(_DWORD *)this;
    *(_DWORD *)(*(_DWORD *)this + 4) = a2;
  }
  else
  {
    *(_DWORD *)(a2 + 4) = a2;
    *(_DWORD *)a2 = a2;
  }
  *(_DWORD *)this = a2;
  return result;
}

//----- (1002B26C) --------------------------------------------------------
int __thiscall sub_1002B26C(void *this, int a2)
{
  int result; // eax@1

  **(_DWORD **)(a2 + 4) = *(_DWORD *)a2;
  *(_DWORD *)(*(_DWORD *)a2 + 4) = *(_DWORD *)(a2 + 4);
  result = *(_DWORD *)this;
  if ( a2 == *(_DWORD *)this )
  {
    if ( result == *(_DWORD *)(result + 4) )
      result = 0;
    else
      result = *(_DWORD *)result;
    *(_DWORD *)this = result;
  }
  return result;
}

//----- (1002B29A) --------------------------------------------------------
int __userpurge sub_1002B29A<eax>(int a1<ebp>, int a2)
{
  char v2; // bl@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // ecx@1

  sub_10035648();
  v3 = v5 + 52;
  v2 = 0;
  *(_DWORD *)(a1 - 16) = v5 + 52;
  sub_1002B98A((void *)(v5 + 56));
  v4 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  if ( *(_DWORD *)v3 )
  {
    sub_1002B26C((void *)v3, v4 + 20);
    *(_DWORD *)(v4 + 8) = 2;
    sub_1000AA50((void *)v4);
  }
  else
  {
    v2 = 1;
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002BB74((void *)(v3 + 4));
  if ( v2 )
  {
    _EBX = v4 + 8;
    _ECX = 1;
    __asm { lock cmpxchg [ebx], ecx }
  }
  return sub_10035616(44);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002B34B) --------------------------------------------------------
int __thiscall sub_1002B34B(int this)
{
  return (*(int (__cdecl **)(_DWORD))(this + 28))(*(_DWORD *)(this + 32));
}

//----- (1002B353) --------------------------------------------------------
int __usercall sub_1002B353<eax>(void *this<ecx>, int a2<ebp>)
{
  void *v2; // esi@1
  DWORD v3; // edi@1

  v2 = this;
  v3 = GetCurrentThreadId();
  _EBX = (int)((char *)v2 + 8);
  _EDX = v3;
  __asm { lock cmpxchg [ebx], edx }
  (*(void (__thiscall **)(_DWORD))(*(_DWORD *)v2 + 8))(v2);
  _ECX = 3;
  __asm { lock cmpxchg [ebx], ecx }
  if ( v3 == 2 )
    sub_1002C5B1(a2);
  return sub_1000AA50(v2);
}

//----- (1002B396) --------------------------------------------------------
int __userpurge sub_1002B396<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6)
{
  int v6; // eax@1
  int v7; // edi@1
  int v8; // esi@2

  v7 = a2;
  v6 = sub_1002ADB1(a1, a2, a3, a2, 36);
  if ( v6 )
    v8 = sub_1002B1EC(v6, a4, a5, a6);
  else
    v8 = 0;
  sub_1002B3CF(v7, v8);
  return v8;
}

//----- (1002B3CF) --------------------------------------------------------
int __thiscall sub_1002B3CF(int this, int a2)
{
  char v2; // bl@1
  int ebp0; // ebp@0
  int v4; // edi@1
  void *v5; // esi@1
  int result; // eax@4
  int v14; // [sp+14h] [bp+8h]@2

  v5 = (void *)a2;
  v2 = 1;
  *(_DWORD *)(a2 + 8) = 0;
  v4 = this;
  _EDX = a2 + 4;
  _EAX = 1;
  __asm { lock xadd [edx], eax }
  *(_DWORD *)(a2 + 16) = this;
  if ( *(_DWORD *)(this + 8) )
    goto LABEL_8;
  v14 = this + 52;
  sub_1002B98A((void *)(this + 56));
  if ( !*(_DWORD *)(v4 + 8) )
  {
    v2 = 0;
    sub_1002B23D((void *)v14, (int)((char *)v5 + 20));
  }
  result = sub_1002BB74((void *)(v14 + 4));
  if ( v2 )
LABEL_8:
    result = sub_1002B353(v5, ebp0);
  return result;
}

//----- (1002B434) --------------------------------------------------------
PVOID __thiscall sub_1002B434(PVOID Parameter, DWORD DueTime)
{
  int ebp0; // ebp@0
  HANDLE *v3; // edi@1
  PVOID v4; // esi@1
  int v5; // eax@3
  int *v6; // eax@4
  int v7; // eax@5
  int v9; // [sp-4h] [bp-30h]@4
  int (__stdcall **v10)(char); // [sp+Ch] [bp-20h]@6
  int (__stdcall **v11)(char); // [sp+18h] [bp-14h]@4
  int v12; // [sp+24h] [bp-8h]@6
  int v13; // [sp+28h] [bp-4h]@4

  v4 = Parameter;
  *((_DWORD *)Parameter + 1) = 0;
  v3 = (HANDLE *)((char *)Parameter + 12);
  *((_DWORD *)Parameter + 2) = 1;
  *((_DWORD *)Parameter + 3) = 0;
  *((_DWORD *)Parameter + 4) = 0;
  *((_DWORD *)Parameter + 5) = 0;
  *(_DWORD *)Parameter = sub_1002B771(0, ebp0, (int)((char *)Parameter + 12));
  if ( DueTime != -1 )
  {
    if ( sub_1003D685() < 3 )
    {
      v7 = sub_1002C20D();
      if ( !CreateTimerQueueTimer(v3, (HANDLE)v7, (WAITORTIMERCALLBACK)Callback, v4, DueTime, 0, 0x20u) )
      {
        v12 = (int)"bad allocation";
        sub_1002AEC9((int)&v10, (int)&v12, 1);
        v10 = &off_1005F2C4;
        v9 = (int)&unk_1006AA70;
        v6 = (int *)&v10;
        goto LABEL_8;
      }
    }
    else
    {
      v5 = sub_10034A98(DueTime, (int)sub_1002B7B1, (int)v4);
      *v3 = (HANDLE)v5;
      if ( !v5 )
      {
        v13 = (int)"bad allocation";
        sub_1002AEC9((int)&v11, (int)&v13, 1);
        v11 = &off_1005F2C4;
        v9 = (int)&unk_1006AA70;
        v6 = (int *)&v11;
LABEL_8:
        sub_100355BB((int)v6, v9);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_1002B4FD);
      }
    }
  }
  return v4;
}
// 1003D685: using guessed type int sub_1003D685(void);
// 1005F2C4: using guessed type int (__stdcall *off_1005F2C4)(char);

//----- (1002B4FD) --------------------------------------------------------
LPCRITICAL_SECTION __thiscall sub_1002B4FD(LPCRITICAL_SECTION lpCriticalSection)
{
  LPCRITICAL_SECTION v2; // esi@1

  v2 = lpCriticalSection;
  InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
  return v2;
}

//----- (1002B511) --------------------------------------------------------
int __thiscall sub_1002B511(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002B5CC(this);
  return v2;
}

//----- (1002B51D) --------------------------------------------------------
int __thiscall sub_1002B51D(int this)
{
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  return this;
}

//----- (1002B52D) --------------------------------------------------------
int __thiscall sub_1002B52D(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002B5CC(this);
  *(_DWORD *)(v2 + 32) = 0;
  *(_DWORD *)(v2 + 36) = -1;
  return v2;
}

//----- (1002B544) --------------------------------------------------------
int __userpurge sub_1002B544<eax>(int a1<ebp>, int a2)
{
  int v2; // ecx@1
  int v3; // edi@1
  int *v4; // esi@1
  int v6; // ecx@3

  sub_10035648();
  v4 = (int *)v2;
  *(_DWORD *)(a1 - 16) = v2;
  v3 = v2 + 4;
  *(_DWORD *)v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v2 + 4;
  *(_DWORD *)(a1 - 4) = 0;
  if ( v2 != -4 )
    sub_1002B434((PVOID)(v2 + 4), 0xFFFFFFFFu);
  v6 = *v4;
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002B9BE(v6, v3, 1);
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002B589) --------------------------------------------------------
int __userpurge sub_1002B589<eax>(int a1<ebp>, int a2)
{
  int v2; // ecx@1
  int v3; // edi@1
  void **v4; // esi@1
  void *v6; // ecx@3

  sub_10035648();
  v4 = (void **)v2;
  *(_DWORD *)(a1 - 16) = v2;
  v3 = v2 + 4;
  *(_DWORD *)v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v2 + 4;
  *(_DWORD *)(a1 - 4) = 0;
  if ( v2 != -4 )
    sub_1002B434((PVOID)(v2 + 4), 0xFFFFFFFFu);
  v6 = *v4;
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002B925(v6, v3);
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002B5CC) --------------------------------------------------------
int __thiscall sub_1002B5CC(int this)
{
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 8) = 2;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  return this;
}

//----- (1002B5EC) --------------------------------------------------------
int __userpurge sub_1002B5EC<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_1006094C;
  return v4;
}
// 1006094C: using guessed type int (__stdcall *off_1006094C)(char);

//----- (1002B607) --------------------------------------------------------
int __thiscall sub_1002B607(int this)
{
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 8) = 2;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 20) = 0;
  return this;
}

//----- (1002B62D) --------------------------------------------------------
int __userpurge sub_1002B62D<eax>(int a1<ebp>, int a2)
{
  int v2; // ecx@1
  int *v3; // edi@1
  int v4; // esi@1
  int v6; // ecx@3

  sub_10035648();
  v3 = (int *)v2;
  v4 = v2 + 4;
  *(_DWORD *)v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v2 + 4;
  *(_DWORD *)(a1 - 16) = v2 + 4;
  *(_DWORD *)(a1 - 4) = 0;
  if ( v2 != -4 )
    sub_1002B434((PVOID)(v2 + 4), 0xFFFFFFFFu);
  v6 = *v3;
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002B9BE(v6, v4, 1);
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002B672) --------------------------------------------------------
int __userpurge sub_1002B672<eax>(int a1<ebp>, int a2)
{
  int v2; // ecx@1
  int *v3; // edi@1
  int v4; // esi@1
  int v6; // ecx@3

  sub_10035648();
  v3 = (int *)v2;
  v4 = v2 + 4;
  *(_DWORD *)v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 8) = v2 + 4;
  *(_DWORD *)(a1 - 16) = v2 + 4;
  *(_DWORD *)(a1 - 4) = 0;
  if ( v2 != -4 )
    sub_1002B434((PVOID)(v2 + 4), 0xFFFFFFFFu);
  v6 = *v3;
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002BA5D(v6, v4, 1);
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002B6B7) --------------------------------------------------------
int __userpurge sub_1002B6B7<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  *(_DWORD *)a1 = a3;
  sub_1002BDD2(a3, a2);
  return v4;
}

//----- (1002B6CE) --------------------------------------------------------
void __thiscall sub_1002B6CE(LPCRITICAL_SECTION lpCriticalSection)
{
  DeleteCriticalSection(lpCriticalSection);
}

//----- (1002B6D6) --------------------------------------------------------
void __cdecl sub_1002B6D6()
{
  JUMPOUT(*(unsigned int *)loc_1002BE76);
}
// 1002BE76: using guessed type int loc_1002BE76();

//----- (1002B6DD) --------------------------------------------------------
void __thiscall sub_1002B6DD(void *this)
{
  int v1; // ecx@1
  char v2; // zf@1

  v1 = *(_DWORD *)this;
  v2 = *(_DWORD *)(v1 + 32)-- == 1;
  if ( v2 )
  {
    *(_DWORD *)(v1 + 36) = -1;
    JUMPOUT(*(unsigned int *)loc_1002BE76);
  }
}
// 1002BE76: using guessed type int loc_1002BE76();

//----- (1002B6E4) --------------------------------------------------------
char __thiscall sub_1002B6E4(void *this)
{
  int v1; // ecx@1
  void *v9; // ecx@5
  int v10; // edi@5
  int v11; // esi@5
  int v12; // eax@7
  int v15; // eax@10

  v1 = *(_DWORD *)this;
  if ( *(_DWORD *)(v1 + 36) >= 8 )
  {
    _EDX = -8;
    _EAX = v1 + 36;
    __asm { lock xadd [eax], edx }
    if ( (_EDX & 0xFFFFFFFB) == 11 )
      LOBYTE(_EAX) = sub_1002B84E(*(void **)(v1 + 28));
  }
  else
  {
    _EAX = *(_DWORD *)(v1 + 36);
    if ( _EAX & 2 )
    {
      v11 = v1;
      v10 = *(_DWORD *)(v1 + 28);
      v9 = *(void **)(v10 + 4);
      *(_DWORD *)v11 = 0;
      *(_DWORD *)(v11 + 28) = v9;
      if ( v9 )
      {
        LOBYTE(_EAX) = sub_1002B84E(v9);
      }
      else
      {
        _EDX = v11 + 36;
        v12 = *(_DWORD *)(v11 + 36);
        do
        {
          _ECX = v12 & 0xFFFFFFFC;
          __asm { lock cmpxchg [edx], ecx }
        }
        while ( v12 & 0xFFFFFFFC );
        if ( v12 & 4 )
        {
          v15 = sub_1002BB1B((void *)v11);
          sub_1002B84E((void *)v15);
        }
        LOBYTE(_EAX) = sub_1002BB85((void *)v11, v10);
      }
    }
  }
  return _EAX;
}

//----- (1002B6EB) --------------------------------------------------------
int __userpurge sub_1002B6EB<eax>(void *this<ecx>, int ebx0<ebx>, unsigned int a2)
{
  int ebp0; // ebp@0
  unsigned int v4; // edi@1
  void *v5; // esi@1
  unsigned int v6; // edx@3
  char v8; // [sp+8h] [bp-10h]@6
  int v9; // [sp+10h] [bp-8h]@6
  BOOL (__cdecl *v10)(); // [sp+14h] [bp-4h]@6

  v5 = this;
  v4 = sub_1003D68A();
  if ( !((*((_DWORD *)v5 + 2) >> 2) & 1) )
  {
    if ( (*((_DWORD *)v5 + 2) >> 1) & 1 )
      v6 = (*((_DWORD *)v5 + 2) >> 3) - (a2 >> 3);
    else
      v6 = 1;
    v4 += 2;
    if ( v6 <= v4 )
    {
      v9 = 0;
      v10 = sub_10034BF4;
      sub_1002BBBE((int)&v8, dwSpinCount + dwSpinCount * (v6 - 1) / v4);
      while ( *((_DWORD *)v5 + 2) & 1 && sub_1002BC25(&v8) )
        ;
    }
  }
  return sub_1003117F(ebx0, ebp0, v4);
}

//----- (1002B771) --------------------------------------------------------
LPVOID __usercall sub_1002B771<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  LPVOID result; // eax@2
  int v4; // edi@2
  int v5; // esi@2

  if ( !(dword_10072D14 & 0x80000000) || (result = TlsGetValue(dwTlsIndex), !result) )
  {
    v4 = sub_1003284C(a2, a3);
    v5 = sub_10031DB6((void *)v4, a1, 0);
    (*(void (__thiscall **)(_DWORD))(*(_DWORD *)v4 + 20))(v4);
    result = (LPVOID)v5;
  }
  return result;
}
// 10072D14: using guessed type int dword_10072D14;

//----- (1002B793) --------------------------------------------------------
int __thiscall sub_1002B793(int this)
{
  int result; // eax@2

  if ( *(_DWORD *)(this + 12) )
  {
    result = this + 20;
    _EDX = 1;
    __asm { lock xadd [eax], edx }
    if ( _EDX == 1 )
      result = sub_1002A4AA((LPVOID)this);
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002B7B1) --------------------------------------------------------
int __stdcall sub_1002B7B1(int a1, int a2, int a3)
{
  _EDX = 2;
  _ECX = a2 + 16;
  __asm { lock cmpxchg [ecx], edx }
  (*(void (**)(void))(**(_DWORD **)a2 + 12))();
  return sub_10034B30(a1, a3);
}

//----- (1002B7EA) --------------------------------------------------------
int __stdcall Callback(int a1, int a2)
{
  void *v3; // ST04_4@1
  int v4; // eax@1

  v3 = *(void **)(a1 + 12);
  v4 = sub_1002C20D();
  sub_1003B577((HANDLE)v4, v3, 0);
  _ECX = a1 + 16;
  _EDX = 2;
  __asm { lock cmpxchg [ecx], edx }
  return (*(int (**)(void))(**(_DWORD **)a1 + 12))();
}

//----- (1002B829) --------------------------------------------------------
int __usercall sub_1002B829<eax>(int this<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>)
{
  int v4; // esi@1
  int result; // eax@2
  int v6; // edx@2

  v4 = this;
  if ( *(_DWORD *)(this + 12) )
  {
    result = this + 16;
    v6 = *(_DWORD *)(this + 16);
    *(_DWORD *)(this + 16) = 1;
    if ( v6 == 2 )
    {
      sub_1003117F(a2, a3, a4);
      result = sub_1002B793(v4);
    }
  }
  return result;
}

//----- (1002B84E) --------------------------------------------------------
char __thiscall sub_1002B84E(void *this)
{
  _ESI = 1;
  _EDX = (int)((char *)this + 16);
  __asm { lock cmpxchg [edx], esi }
  *((_DWORD *)this + 2) &= 0xFFFFFFFEu;
  (*(void (**)(void))(**(_DWORD **)this + 12))();
  return 1;
}

//----- (1002B871) --------------------------------------------------------
int __thiscall sub_1002B871(void *this, int a2)
{
  int result; // eax@1
  void *v3; // esi@1

  v3 = this;
  result = *(_DWORD *)(a2 + 8);
  if ( result & 1 )
  {
    result = *(_DWORD *)(a2 + 8) >> 2;
    if ( result & 1 || (result = (*(int (**)(void))(**(_DWORD **)a2 + 16))(), (_BYTE)result) )
      *((_DWORD *)v3 + 2) |= 4u;
  }
  return result;
}

//----- (1002B89F) --------------------------------------------------------
int __thiscall sub_1002B89F(int this, int a2)
{
  int result; // eax@1
  int v3; // edi@1
  int v4; // esi@3

  v3 = this;
  result = *(_DWORD *)(this + 8) >> 1;
  if ( !(result & 1) )
  {
    result = *(_DWORD *)(a2 + 8) >> 1;
    if ( result & 1 )
    {
      result = *(_DWORD *)(a2 + 8);
      v4 = (*(_DWORD *)(a2 + 8) + 8) & 0xFFFFFFFA;
      if ( result & 1 )
      {
        result = *(_DWORD *)(a2 + 8) >> 2;
        if ( result & 1
          || !*(_DWORD *)(a2 + 12) && (result = (*(int (**)(void))(**(_DWORD **)a2 + 16))(), (_BYTE)result) )
          v4 |= 4u;
      }
      *(_DWORD *)(v3 + 8) |= v4;
    }
  }
  return result;
}

//----- (1002B8F2) --------------------------------------------------------
int __thiscall sub_1002B8F2(int this)
{
  int result; // eax@1
  int v2; // esi@1
  char v3; // [sp+4h] [bp-10h]@2
  int v4; // [sp+Ch] [bp-8h]@1
  BOOL (__cdecl *v5)(); // [sp+10h] [bp-4h]@1

  v2 = this;
  result = *(_DWORD *)(this + 4);
  v4 = 0;
  v5 = sub_10034BF4;
  while ( !result )
  {
    sub_100282E0((int)&v3);
    result = *(_DWORD *)(v2 + 4);
  }
  return result;
}

//----- (1002B91D) --------------------------------------------------------
void __thiscall sub_1002B91D(LPCRITICAL_SECTION lpCriticalSection)
{
  EnterCriticalSection(lpCriticalSection);
}

//----- (1002B925) --------------------------------------------------------
DWORD __thiscall sub_1002B925(void *this, int a2)
{
  DWORD result; // eax@1
  DWORD v3; // edi@1
  int v4; // esi@1

  v4 = (int)this;
  result = GetCurrentThreadId();
  v3 = result;
  if ( *(_DWORD *)(v4 + 36) == result )
  {
    ++*(_DWORD *)(v4 + 32);
  }
  else
  {
    result = sub_1002B9BE(v4, a2, 1);
    *(_DWORD *)(v4 + 36) = v3;
    *(_DWORD *)(v4 + 32) = 1;
  }
  return result;
}

//----- (1002B95A) --------------------------------------------------------
int __thiscall sub_1002B95A(void *this)
{
  int v1; // edi@1
  int v3; // edx@4
  int result; // eax@5

  _ESI = this;
  v1 = (int)((char *)this + 4);
  while ( 1 )
  {
    if ( *(_DWORD *)v1 > 0 )
      sub_1002BD6B(v1, 0, -1);
    v3 = *(_DWORD *)_ESI;
    if ( *(_DWORD *)_ESI != -1 )
    {
      _ECX = v3 + 1;
      result = *(_DWORD *)_ESI;
      __asm { lock cmpxchg [esi], ecx }
      if ( v3 == v3 )
        break;
    }
  }
  return result;
}

//----- (1002B98A) --------------------------------------------------------
int __thiscall sub_1002B98A(void *this)
{
  int result; // eax@1

  _ESI = (int)this;
  _EAX = (int)((char *)this + 4);
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  _EDX = -1;
  result = 0;
  __asm { lock cmpxchg [esi], edx }
  while ( result )
  {
    sub_1002BD6B(_ESI, 0, -1);
    _ECX = -1;
    result = 0;
    __asm { lock cmpxchg [esi], ecx }
  }
  return result;
}

//----- (1002B9BE) --------------------------------------------------------
bool __thiscall sub_1002B9BE(int this, int a2, char a3)
{
  int ebp0; // ebp@0
  int v4; // edi@1
  int v5; // ebx@2
  char v7; // [sp+8h] [bp-Ch]@9

  v4 = this;
  if ( *(_DWORD *)a2 == *(_DWORD *)this )
  {
    sub_1002FF4B((int)&v7, (unsigned int)"Lock already taken");
    sub_100355BB((int)&v7, (int)&unk_1006AD40);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1002BA5D);
  }
  v5 = *(_DWORD *)(this + 28);
  *(_DWORD *)(this + 28) = a2;
  if ( v5 )
  {
    sub_1002B89F(a2, v5);
    *(_DWORD *)(v5 + 4) = a2;
    sub_1002B6EB((void *)a2, v5, *(_DWORD *)(v4 + 8));
    if ( *(_DWORD *)(a2 + 16) != 2 )
      sub_1002B89F(a2, v4);
  }
  else
  {
    *(_DWORD *)(this + 24) = a2;
    sub_1002B89F(a2, this);
    *(_DWORD *)(a2 + 8) &= 0xFFFFFFFEu;
    sub_1002B829(a2, 0, ebp0, v4);
  }
  if ( a3 )
  {
    *(_DWORD *)(v4 + 8) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(v4 + 4) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)v4 = *(_DWORD *)a2;
    *(_DWORD *)(v4 + 24) = a2;
  }
  return *(_DWORD *)(a2 + 16) != 2;
}

//----- (1002BA5D) --------------------------------------------------------
char __thiscall sub_1002BA5D(int this, int a2, char a3)
{
  int v3; // edi@1
  int v4; // ebx@2
  int v5; // eax@3
  char v7; // [sp+8h] [bp-Ch]@10

  v3 = this;
  if ( *(_DWORD *)a2 == *(_DWORD *)this )
  {
    sub_1002FF4B((int)&v7, (unsigned int)"Lock already taken");
    sub_100355BB((int)&v7, (int)&unk_1006AD40);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1002BAED);
  }
  v4 = *(_DWORD *)(this + 32);
  *(_DWORD *)(this + 32) = a2;
  if ( v4 )
  {
    sub_1002B89F(a2, v4);
    *(_DWORD *)(v4 + 4) = a2;
  }
  else
  {
    sub_1002B89F(a2, this);
    LOBYTE(v5) = sub_1002BBE2(v3, a2);
    if ( (_BYTE)v5 )
    {
      *(_DWORD *)(a2 + 8) &= 0xFFFFFFFEu;
      goto LABEL_7;
    }
  }
  sub_1002B6EB((void *)a2, v4, *(_DWORD *)(v3 + 8));
  LOBYTE(v5) = sub_1002B89F(a2, v3);
LABEL_7:
  if ( a3 )
  {
    *(_DWORD *)(v3 + 8) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(v3 + 4) = *(_DWORD *)(a2 + 4);
    v5 = *(_DWORD *)a2;
    *(_DWORD *)v3 = *(_DWORD *)a2;
    *(_DWORD *)(v3 + 28) = a2;
  }
  return v5;
}

//----- (1002BAED) --------------------------------------------------------
int __thiscall sub_1002BAED(void *this)
{
  int v1; // ecx@1
  int result; // eax@2

  v1 = (int)((char *)this + 4);
  if ( *(_DWORD *)v1 > 0 )
    result = sub_1002BD6B(v1, 0, -1);
  return result;
}

//----- (1002BB03) --------------------------------------------------------
void __thiscall sub_1002BB03(int this)
{
  if ( *(_DWORD *)(this + 28) )
  {
    sub_1002BDA4((void *)this);
    JUMPOUT(*(unsigned int *)loc_1002BE76);
  }
}
// 1002BE76: using guessed type int loc_1002BE76();

//----- (1002BB1B) --------------------------------------------------------
int __thiscall sub_1002BB1B(void *this)
{
  int result; // eax@4
  int v10; // ecx@4

  _EDX = (int)((char *)this + 36);
  _EAX = 4;
  __asm { lock xadd [edx], eax }
  if ( _EAX & 1 )
  {
    if ( !(_EAX & 2) )
    {
      _EAX = 2;
      __asm { lock or [edx], eax }
    }
  }
  v10 = (int)((char *)this + 24);
  result = *(_DWORD *)v10;
  *(_DWORD *)v10 = 0;
  return result;
}

//----- (1002BB3B) --------------------------------------------------------
int __cdecl sub_1002BB3B()
{
  int result; // eax@1

  result = (unsigned int)sub_1003D68A() > 1 ? 0xFA0 : 0;
  dwSpinCount = result;
  return result;
}

//----- (1002BB52) --------------------------------------------------------
void __thiscall sub_1002BB52(LPCRITICAL_SECTION lpCriticalSection)
{
  LeaveCriticalSection(lpCriticalSection);
}

//----- (1002BB6C) --------------------------------------------------------
int __cdecl sub_1002BB6C()
{
  int result; // eax@1

  _EAX = -1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (1002BB74) --------------------------------------------------------
int __thiscall sub_1002BB74(void *this)
{
  int result; // eax@1

  *(_DWORD *)this = 0;
  result = (int)((char *)this + 4);
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  return result;
}

//----- (1002BB85) --------------------------------------------------------
char __thiscall sub_1002BB85(void *this, int a2)
{
  char result; // al@1
  int v3; // edi@1
  int v6; // eax@2
  void *v7; // esi@2

  v3 = (int)this;
  _ESI = 0;
  _EDX = (int)((char *)this + 32);
  result = a2;
  __asm { lock cmpxchg [edx], esi }
  if ( a2 != a2 )
  {
    v6 = sub_1002B8F2(a2);
    v7 = (void *)v6;
    result = sub_1002BBE2(v3, v6);
    if ( result )
      result = sub_1002B84E(v7);
  }
  return result;
}

//----- (1002BBBE) --------------------------------------------------------
int __thiscall sub_1002BBBE(int this, int a2)
{
  int result; // eax@1

  result = a2;
  if ( a2 )
  {
    *(_DWORD *)(this + 4) = 0;
    *(_DWORD *)this = a2;
    *(_DWORD *)(this + 8) = 1;
  }
  else
  {
    *(_DWORD *)(this + 8) = 4;
  }
  return result;
}

//----- (1002BBE2) --------------------------------------------------------
char __thiscall sub_1002BBE2(int this, int a2)
{
  int v2; // eax@1
  signed int v5; // eax@4
  char result; // al@7

  *(_DWORD *)(this + 28) = a2;
  _EDX = this + 36;
  v2 = *(_DWORD *)(this + 36);
  do
  {
    _ECX = v2 | 1;
    __asm { lock cmpxchg [edx], ecx }
  }
  while ( v2 | 1 );
  if ( v2 & 4 )
    goto LABEL_11;
  v5 = *(_DWORD *)_EDX;
  do
  {
    _ECX = v5 | 2;
    __asm { lock cmpxchg [edx], ecx }
  }
  while ( v5 | 2 );
  if ( v5 >= 8 )
LABEL_11:
    result = 0;
  else
    result = 1;
  return result;
}

//----- (1002BC25) --------------------------------------------------------
char __thiscall sub_1002BC25(void *this)
{
  char v1; // bl@1
  int v2; // esi@1
  int v3; // eax@2
  int v4; // eax@4
  int v5; // eax@5
  int v6; // eax@6
  char result; // al@10
  char v8; // zf@11
  char v9; // zf@15

  v2 = (int)this;
  v1 = 0;
  while ( 1 )
  {
    v3 = *(_DWORD *)(v2 + 8);
    if ( v3 )
      break;
    *(_DWORD *)(v2 + 8) = 0;
    sub_1002BBBE(v2, dwSpinCount);
  }
  v4 = v3 - 1;
  if ( v4 )
  {
    v5 = v4 - 1;
    if ( v5 )
    {
      v6 = v5 - 1;
      if ( !v6 )
      {
        *(_DWORD *)(v2 + 8) = 0;
        sub_1002BBBE(v2, dwSpinCount);
        return 0;
      }
      if ( v6 != 1 )
        return 0;
    }
    else
    {
      v8 = *(_DWORD *)(v2 + 4)-- == 1;
      if ( v8 )
        *(_DWORD *)(v2 + 8) = 3;
      v1 = 1;
    }
    __asm { pause }
    result = v1;
  }
  else
  {
    __asm { pause }
    v9 = *(_DWORD *)v2-- == 1;
    if ( v9 )
      *(_DWORD *)(v2 + 8) = 3 - (*(_DWORD *)(v2 + 4) != 0);
    result = 1;
  }
  return result;
}

//----- (1002BC92) --------------------------------------------------------
int __thiscall sub_1002BC92(int this, int a2)
{
  int result; // eax@1
  int v3; // esi@1
  char v4; // zf@1

  v3 = this;
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  v4 = *(_DWORD *)(this + 4) == 0;
  result = *(_DWORD *)a2;
  *(_DWORD *)this = *(_DWORD *)a2;
  if ( v4 )
  {
    _EDX = this;
    _ECX = this + 28;
    result = a2;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 != a2 )
    {
      sub_1002B8F2(a2);
      *(_DWORD *)(v3 + 8) = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(v3 + 4) = *(_DWORD *)(a2 + 4);
      result = *(_DWORD *)a2;
      *(_DWORD *)v3 = *(_DWORD *)a2;
    }
  }
  *(_DWORD *)(v3 + 24) = v3;
  return result;
}

//----- (1002BCE1) --------------------------------------------------------
char __thiscall sub_1002BCE1(void *_ECX)
{
  _EDX = -1;
  __asm { lock cmpxchg [ecx], edx }
  _EDX = (int)((char *)_ECX + 4);
  _ECX = 1;
  __asm { lock xadd [edx], ecx }
  return 1;
}

//----- (1002BD65) --------------------------------------------------------
DWORD __cdecl sub_1002BD65()
{
  return dwSpinCount;
}

//----- (1002BD6B) --------------------------------------------------------
int __cdecl sub_1002BD6B(int a1, int a2, int a3)
{
  signed int v3; // esi@1
  DWORD v4; // ecx@2
  int result; // eax@8
  DWORD v6; // [sp-4h] [bp-Ch]@4

  v3 = 10;
LABEL_7:
  v4 = 0;
  while ( 1 )
  {
    result = a3 & *(_DWORD *)a1;
    if ( result == a2 )
      return result;
    __asm { pause }
    ++v4;
    if ( v4 >= dwSpinCount )
    {
      if ( v3 <= 0 )
      {
        v6 = 1;
      }
      else
      {
        --v3;
        v6 = 0;
      }
      Sleep(v6);
      goto LABEL_7;
    }
  }
}

//----- (1002BDA4) --------------------------------------------------------
int __thiscall sub_1002BDA4(void *this)
{
  int v2; // esi@1
  char Parameter; // [sp+4h] [bp-18h]@1

  v2 = (int)this;
  sub_1002B434(&Parameter, 0xFFFFFFFFu);
  sub_1002B9BE(v2, (int)&Parameter, 0);
  return sub_1002BC92(v2, (int)&Parameter);
}

//----- (1002BDD2) --------------------------------------------------------
char __usercall sub_1002BDD2<al>(int a1<ecx>, int a2<ebx>)
{
  int v2; // edi@1
  int v3; // esi@2
  int v4; // eax@3
  int v7; // eax@6
  int v15; // ecx@13
  int v16; // edi@13
  int v18; // ecx@13
  int v20; // ebx@17
  int Parameter; // [sp+8h] [bp-24h]@1
  char v25; // [sp+20h] [bp-Ch]@13

  v2 = a1;
  sub_1002B434(&Parameter, 0xFFFFFFFFu);
  if ( Parameter == *(_DWORD *)v2 )
  {
    sub_1002FF4B((int)&v25, (unsigned int)"Lock already taken as a writer");
    sub_100355BB((int)&v25, (int)&unk_1006AD40);
    __asm { int     3               ; Trap to Debugger }
    v16 = v18;
    v15 = *(_DWORD *)(v18 + 24);
    *(_DWORD *)v16 = 0;
    _ESI = *(_DWORD *)(v15 + 4);
    *(_DWORD *)(v16 + 24) = _ESI;
    if ( _ESI )
      goto LABEL_24;
    _EDX = v16 + 28;
    LOBYTE(v7) = v15;
    __asm { lock cmpxchg [edx], esi }
    if ( v15 != v15 )
    {
      v7 = sub_1002B8F2(v15);
      _ESI = v7;
      *(_DWORD *)(v16 + 24) = v7;
      if ( v7 )
      {
LABEL_24:
        do
        {
          LOBYTE(v7) = sub_1002B84E((void *)_ESI);
          if ( (_BYTE)v7 )
            break;
          v20 = _ESI;
          _ESI = *(_DWORD *)(_ESI + 4);
          *(_DWORD *)(v16 + 24) = _ESI;
          if ( !_ESI )
          {
            _EDX = 0;
            _ECX = v16 + 28;
            __asm { lock cmpxchg [ecx], edx }
            if ( v20 != v20 )
            {
              _ESI = sub_1002B8F2(v20);
              *(_DWORD *)(v16 + 24) = _ESI;
            }
          }
          LOBYTE(v7) = sub_1002B793(v20);
        }
        while ( _ESI );
      }
    }
  }
  else
  {
    v3 = *(_DWORD *)(v2 + 24);
    *(_DWORD *)(v2 + 24) = &Parameter;
    if ( v3 )
    {
      sub_1002B871(&Parameter, v3);
    }
    else
    {
      _EDX = v2 + 36;
      v4 = *(_DWORD *)(v2 + 36);
      do
      {
        _ECX = v4 | 4;
        __asm { lock cmpxchg [edx], ecx }
      }
      while ( v4 | 4 );
      if ( !(v4 & 3) )
      {
        v7 = sub_1002BB1B((void *)v2);
        if ( (int *)v7 == &Parameter )
        {
          *(_DWORD *)(v7 + 8) &= 0xFFFFFFFEu;
          return v7;
        }
        sub_1002B84E((void *)v7);
      }
    }
    LOBYTE(v7) = sub_1002B6EB(&Parameter, a2, 0);
    if ( v3 )
    {
      _EDX = 8;
      _EAX = v2 + 36;
      __asm { lock xadd [eax], edx }
      LOBYTE(v7) = sub_1002B84E((void *)v3);
    }
  }
  return v7;
}

//----- (1002BEFD) --------------------------------------------------------
int __thiscall sub_1002BEFD(int this, int a2, char a3, char a4)
{
  signed int i; // ecx@1
  int v5; // edi@1
  int v6; // esi@1

  v5 = this;
  v6 = sub_1002C06B(this);
  for ( i = 3; i; --i )
    v6 += 4;
  *(_DWORD *)v5 = off_100609BC;
  *(_DWORD *)(v5 + 12) = 0;
  *(_DWORD *)(v5 + 16) = 0;
  *(_DWORD *)(v5 + 20) = 0;
  *(_DWORD *)(v5 + 24) = a2 + (a4 != 0);
  *(_DWORD *)(v5 + 32) = 0;
  *(_BYTE *)(v5 + 40) = a3;
  *(_DWORD *)(v5 + 36) = 0;
  *(_BYTE *)(v5 + 41) = 0;
  return v5;
}
// 100609BC: using guessed type int (*off_100609BC[5])();

//----- (1002BF46) --------------------------------------------------------
#error "1002BFE7: call analysis failed (funcsize=57)"

//----- (1002BFEF) --------------------------------------------------------
int __thiscall sub_1002BFEF(int this)
{
  signed int v1; // ecx@1
  int v2; // edi@1
  int v3; // esi@1
  int v4; // eax@1

  v2 = this;
  v4 = sub_1002C06B(this);
  v1 = 3;
  v3 = v4;
  while ( v1 )
  {
    v3 += 4;
    --v1;
  }
  *(_DWORD *)v2 = &off_100609A4;
  return v2;
}
// 100609A4: using guessed type int (__stdcall *off_100609A4)(int, int);

//----- (1002C00A) --------------------------------------------------------
int __thiscall sub_1002C00A(int this, int a2, char a3, char a4)
{
  signed int v4; // ecx@1
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@1

  v5 = this;
  v7 = sub_1002BEFD(this, a2, a3, a4);
  v4 = 11;
  *(_DWORD *)v5 = &off_100609D8;
  v6 = v7;
  *(_DWORD *)(v5 + 28) = a2;
  while ( v4 )
  {
    v6 += 4;
    --v4;
  }
  return v5;
}
// 100609D8: using guessed type int (__stdcall *off_100609D8)(int, int);

//----- (1002C03A) --------------------------------------------------------
int __thiscall sub_1002C03A(int this, int a2, char a3, char a4)
{
  signed int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // eax@1

  v5 = this;
  v7 = sub_1002BEFD(this, a2, a3, a4);
  v4 = 11;
  v6 = v7;
  while ( v4 )
  {
    v6 += 4;
    --v4;
  }
  *(_DWORD *)v5 = &off_100609F4;
  *(_DWORD *)(v5 + 28) = 1;
  return v5;
}
// 100609F4: using guessed type int (__stdcall *off_100609F4)(int, int);

//----- (1002C06B) --------------------------------------------------------
int __thiscall sub_1002C06B(int this)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = off_1006098C;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 4) = sub_1003118B();
  return v2;
}
// 1003118B: using guessed type int sub_1003118B(void);
// 1006098C: using guessed type int (*off_1006098C[5])();

//----- (1002C08B) --------------------------------------------------------
int __thiscall sub_1002C08B(int this)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)this = 0;
  sub_1002B5CC(this + 8);
  return v2;
}

//----- (1002C0B4) --------------------------------------------------------
unsigned int __thiscall sub_1002C0B4(void *this)
{
  void *i; // esi@1
  unsigned int result; // eax@3
  char v3; // cf@3

  for ( i = this; ; sub_1002C2AB(*((_DWORD *)i + 4)) )
  {
    result = *((_DWORD *)i + 5);
    v3 = result < *((_DWORD *)i + 6);
    ++*((_DWORD *)i + 5);
    if ( !v3 )
      break;
  }
  return result;
}

//----- (1002C0CE) --------------------------------------------------------
int __usercall sub_1002C0CE<eax>(int a1<ebp>)
{
  int v1; // edi@1
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // ecx@3
  int v5; // ecx@6
  int v6; // esi@7
  int v8; // [sp-Ch] [bp-Ch]@8
  signed int v9; // [sp-4h] [bp-4h]@1

  v9 = 8;
  sub_10035648();
  v1 = v3;
  *(_DWORD *)(a1 - 20) = v3;
  *(_DWORD *)(a1 - 4) = 0;
  sub_1002BB03(v3 + 8);
  v2 = *(_DWORD *)v1;
  if ( *(_DWORD *)v1 > 1u )
  {
    for ( ; v2; v2 = *(_DWORD *)(a1 - 16) )
    {
      v4 = *(_DWORD *)(v2 + 4);
      *(_DWORD *)(a1 - 16) = *(_DWORD *)v2;
      if ( (unsigned __int8)(**(int (__cdecl ***)(_DWORD, _DWORD, _DWORD))v4)(0, v2, v9) )
        (*(void (**)(void))(**(_DWORD **)(v2 + 4) + 8))();
    }
  }
  v5 = *(_DWORD *)(v1 + 4);
  if ( v5 )
  {
    do
    {
      v6 = *(_DWORD *)v5;
      (*(void (**)(void))(**(_DWORD **)(v5 + 4) + 8))();
      v5 = v6;
    }
    while ( v6 );
  }
  *(_DWORD *)(a1 - 4) = -1;
  nullsub_2(v1 + 8);
  return sub_10035616(v8);
}
// 1002C171: using guessed type int __thiscall nullsub_2(_DWORD);
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002C143) --------------------------------------------------------
void *__userpurge sub_1002C143<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1
  int v4; // ST00_4@1

  v3 = (void *)a1;
  v4 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = &off_10060A10;
  sub_1002CAA4(a2, v4);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10060A10: using guessed type int (__stdcall *off_10060A10)(char);

//----- (1002C172) --------------------------------------------------------
int __stdcall sub_1002C172(int a1, int a2, int a3)
{
  char v3; // bl@1
  int v11; // ecx@2
  int result; // eax@4

  v3 = 0;
  _ECX = a2 + 20;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  if ( _EAX == 0 )
  {
    v11 = *(_DWORD *)(a2 + 4);
    v3 = 1;
    *(_BYTE *)(a2 + 41) = 1;
    if ( v11 )
    {
      *(_DWORD *)(a2 + 12) = 0;
      (*(void (**)(void))(*(_DWORD *)v11 + 12))();
    }
  }
  result = sub_1002C2AB(a2);
  if ( v3 )
    result = sub_10034B30(a1, a3);
  return result;
}

//----- (1002C1BF) --------------------------------------------------------
int __stdcall sub_1002C1BF(int a1, int a2)
{
  int v9; // edi@2
  void *v10; // ST04_4@2
  int v11; // eax@2

  _ECX = a1 + 20;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  if ( _EAX == 0 )
  {
    v9 = *(_DWORD *)(a1 + 4);
    v10 = *(void **)(a1 + 16);
    v11 = sub_1002C20D();
    sub_1003B577((HANDLE)v11, v10, 0);
    *(_BYTE *)(a1 + 41) = 1;
    if ( v9 )
    {
      *(_DWORD *)(a1 + 12) = 0;
      (*(void (__thiscall **)(int))(*(_DWORD *)v9 + 12))(v9);
    }
  }
  return sub_1002C2AB(a1);
}

//----- (1002C20D) --------------------------------------------------------
int __cdecl sub_1002C20D()
{
  char v0; // zf@2
  int (__stdcall **v6)(char); // [sp+14h] [bp-10h]@9
  int v7; // [sp+20h] [bp-4h]@9

  if ( !dword_10075260 )
  {
    _ECX = 1;
    _EDI = &dword_1007525C;
    __asm { lock cmpxchg [edi], ecx }
    dword_10075260 = (int)CreateTimerQueue();
    v0 = dword_10075260 == 0;
    if ( !dword_10075260 )
    {
      dword_1007525C = 0;
      v0 = dword_10075260 == 0;
    }
    if ( v0 )
    {
      v7 = (int)"bad allocation";
      sub_1002AEC9((int)&v6, (int)&v7, 1);
      v6 = &off_1005F2C4;
      sub_100355BB((int)&v6, (int)&unk_1006AA70);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1002C2AB);
    }
  }
  return dword_10075260;
}
// 1005F2C4: using guessed type int (__stdcall *off_1005F2C4)(char);
// 1007525C: using guessed type int dword_1007525C;
// 10075260: using guessed type int dword_10075260;

//----- (1002C2AB) --------------------------------------------------------
int __thiscall sub_1002C2AB(int this)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = *(_DWORD *)(this + 24);
  _EAX = this + 36;
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  result = v2 + 1;
  if ( _EDX + 1 == v2 + 1 )
    result = sub_100303A3((LPVOID)this);
  return result;
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (1002C2CA) --------------------------------------------------------
char __thiscall sub_1002C2CA(int this)
{
  int v1; // edx@1
  int v3; // edi@1
  int v4; // esi@1
  char result; // al@5

  v3 = this;
  v4 = *(_DWORD *)(this + 28);
  _EBX = this + 32;
  v1 = *(_DWORD *)(this + 32);
  if ( v1 == v4 )
    goto LABEL_9;
  do
  {
    _ECX = v1 - 1;
    __asm { lock cmpxchg [ebx], ecx }
  }
  while ( v1 != v1 && v1 != v4 );
  if ( v1 == v4 )
  {
LABEL_9:
    sub_1002C2AB(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1002C304) --------------------------------------------------------
char __thiscall sub_1002C304(int this, int a2, int a3)
{
  if ( *(_DWORD *)(*(_DWORD *)(a3 + 4) + 8) == 2 )
  {
    if ( a2 )
      *(_DWORD *)a2 = *(_DWORD *)(this + 4);
    else
      (*(void (**)(void))(**(_DWORD **)(this + 4) + 12))();
  }
  else
  {
    _EDX = 1;
    _ECX = *(_DWORD *)(a3 + 4) + 8;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 )
      *(_DWORD *)a2 = 0;
  }
  return 0;
}

//----- (1002C353) --------------------------------------------------------
char __thiscall sub_1002C353(void *this, int a2, int a3)
{
  int v3; // esi@1
  char result; // al@4

  v3 = (int)this;
  if ( a2 )
    *(_DWORD *)a2 = 0;
  _EAX = (int)((char *)this + 32);
  _ECX = 1;
  __asm { lock xadd [eax], ecx }
  if ( _ECX + 1 == *(_DWORD *)(v3 + 28) )
  {
    (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v3 + 20))(v3, a2, a3);
    sub_1002C2AB(v3);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1002C390) --------------------------------------------------------
char __thiscall sub_1002C390(void *this, int a2, int a3)
{
  int v3; // esi@1

  v3 = (int)this;
  if ( a2 )
    *(_DWORD *)a2 = 0;
  _EAX = (int)((char *)this + 32);
  _ECX = 1;
  __asm { lock xadd [eax], ecx }
  if ( _ECX + 1 == *(_DWORD *)(v3 + 28) )
    (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v3 + 20))(v3, a2, a3);
  sub_1002C2AB(v3);
  return 0;
}

//----- (1002C3C9) --------------------------------------------------------
int __thiscall sub_1002C3C9(void *this)
{
  int result; // eax@1
  unsigned int v2; // edi@1
  unsigned int v6; // esi@6

  _ESI = this;
  v2 = *(_DWORD *)this;
  _EDX = 1;
  result = *(_DWORD *)this;
  __asm { lock cmpxchg [esi], edx }
  while ( result != v2 )
  {
    v2 = result;
    _ECX = 1;
    __asm { lock cmpxchg [esi], ecx }
  }
  if ( v2 > 1 )
  {
    if ( v2 )
    {
      do
      {
        v6 = *(_DWORD *)v2;
        result = (*(int (**)(void))(**(_DWORD **)(v2 + 4) + 12))();
        v2 = v6;
      }
      while ( v6 );
    }
  }
  return result;
}

//----- (1002C403) --------------------------------------------------------
int __thiscall sub_1002C403(int this, int a2, int a3)
{
  int v3; // ebx@1
  int v5; // esi@1
  int result; // eax@2
  char v13; // zf@3
  void *v14; // ST04_4@6
  int v15; // eax@6

  v5 = this;
  v3 = *(_DWORD *)(this + 4);
  _EDI = 1;
  if ( !*(_BYTE *)(this + 40) )
    goto LABEL_17;
  result = this + 20;
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  if ( _EDX == 0 )
  {
LABEL_17:
    v13 = *(_DWORD *)(this + 16) == 0;
    *(_DWORD *)(this + 12) = a3;
    if ( !v13 )
    {
      if ( sub_1003D685() < 3 )
      {
        v14 = *(void **)(v5 + 16);
        v15 = sub_1002C20D();
        sub_1003B577((HANDLE)v15, v14, (HANDLE)0xFFFFFFFF);
      }
      else
      {
        sub_10034906(*(_DWORD *)(v5 + 16));
      }
      if ( *(_DWORD *)(v5 + 20) == 1 )
        sub_1002C2AB(v5);
    }
    if ( *(_DWORD *)(*(_DWORD *)(a3 + 4) + 8) == 2 )
    {
      result = a2;
      if ( a2 )
        *(_DWORD *)a2 = v3;
      else
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 12))(v3);
    }
    else
    {
      _ECX = *(_DWORD *)(a3 + 4) + 8;
      __asm { lock cmpxchg [ecx], edi }
      result = a2;
      if ( a2 )
        *(_DWORD *)a2 = 0;
    }
  }
  return result;
}
// 1003D685: using guessed type int sub_1003D685(void);

//----- (1002C4A7) --------------------------------------------------------
int __cdecl sub_1002C4A7(int a1, char a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v4; // eax@2
  int v5; // ebx@2
  char v6; // al@3

  v3 = a1;
  v2 = 0;
  if ( a1 )
  {
    do
    {
      v5 = *(_DWORD *)v3;
      v4 = **(_DWORD **)(v3 + 4);
      if ( a2 )
        v6 = (*(int (**)(void))(v4 + 12))();
      else
        v6 = (*(int (**)(void))(v4 + 16))();
      if ( v6 )
      {
        *(_DWORD *)v3 = v2;
        v2 = v3;
      }
      v3 = v5;
    }
    while ( v5 );
  }
  return v2;
}

//----- (1002C4E0) --------------------------------------------------------
char __thiscall sub_1002C4E0(void *this)
{
  if ( *((_DWORD *)this + 8) >= *((_DWORD *)this + 7) )
  {
    (*(void (**)(void))(*(_DWORD *)this + 4))();
    return 0;
  }
  if ( *((_BYTE *)this + 41) )
  {
    (*(void (**)(void))(*(_DWORD *)this + 8))();
    return 0;
  }
  return 1;
}

//----- (1002C500) --------------------------------------------------------
char __thiscall sub_1002C500(int this)
{
  int v1; // esi@1
  char result; // al@4
  char v3; // [sp+4h] [bp-4h]@2

  v1 = this;
  if ( *(_BYTE *)(this + 41) )
  {
    if ( (unsigned __int8)(**(int (__stdcall ***)(char *, _DWORD))this)(&v3, 0) )
      (*(void (__thiscall **)(int))(*(_DWORD *)v1 + 8))(v1);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1002C52D) --------------------------------------------------------
char __thiscall sub_1002C52D(int this)
{
  char result; // al@3
  int v2; // [sp+0h] [bp-4h]@1

  v2 = this;
  if ( *(_DWORD *)(this + 32) >= *(_DWORD *)(this + 28) || *(_BYTE *)(this + 41) )
  {
    (**(void (__stdcall ***)(int *, _DWORD, int))this)(&v2, 0, v2);
    result = 0;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1002C5B1) --------------------------------------------------------
int __usercall sub_1002C5B1<eax>(int a1<ebp>)
{
  int v1; // edx@1
  int j; // ebx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // ecx@1
  int *v6; // eax@1
  int i; // eax@2
  int v8; // ecx@2
  int v9; // ecx@4
  int v10; // eax@5
  int v11; // ecx@11
  int v12; // ecx@12
  int v13; // eax@13
  signed int v15; // [sp-4h] [bp-4h]@1

  v15 = 56;
  sub_1003567B();
  *(_DWORD *)(a1 - 20) = v5;
  j = 0;
  v4 = 0;
  *(_DWORD *)(a1 - 40) = &off_10060A10;
  *(_DWORD *)(a1 - 36) = 0;
  *(_DWORD *)(a1 - 32) = 0;
  *(_DWORD *)(a1 - 4) = 0;
  sub_1002B62D(a1, v5 + 8);
  v6 = *(int **)(a1 - 20);
  *(_BYTE *)(a1 - 4) = 1;
  v3 = *v6;
  *v6 = 1;
  if ( (unsigned int)v3 > 1 )
  {
    v8 = 0;
    for ( i = v3; i; ++v8 )
      i = *(_DWORD *)i;
    v9 = 4 * v8 + 8;
    if ( (unsigned int)v9 > 0x400 )
    {
      v10 = sub_10030930(v1, v9, 0, v3, v9);
      if ( !v10 )
        goto LABEL_10;
      *(_DWORD *)v10 = 56797;
    }
    else
    {
      sub_1003F580(v9, v9, v15);
      v10 = (int)&v15;
      if ( !&v15 )
        goto LABEL_10;
      v15 = 52428;
    }
    v10 += 8;
LABEL_10:
    v4 = 0;
    for ( j = sub_1002D81D(a1 - 40, v10); v3; v3 = *(_DWORD *)(a1 - 24) )
    {
      v11 = *(_DWORD *)(v3 + 4);
      *(_DWORD *)(a1 - 24) = *(_DWORD *)v3;
      if ( (unsigned __int8)(**(int (__stdcall ***)(_DWORD, _DWORD))v11)(a1 - 28, v3) )
      {
        v12 = *(_DWORD *)(a1 - 20);
        *(_DWORD *)v3 = *(_DWORD *)(v12 + 4);
        *(_DWORD *)(v12 + 4) = v3;
      }
      v13 = *(_DWORD *)(a1 - 28);
      if ( v13 )
        *(_DWORD *)(j + 4 * v4++) = v13;
    }
  }
  *(_BYTE *)(a1 - 4) = 0;
  sub_1002B6D6();
  while ( v4 )
  {
    --v4;
    (*(void (**)(void))(**(_DWORD **)(j + 4 * v4) + 12))();
  }
  v15 = *(_DWORD *)(a1 - 36);
  sub_1002CAA4(j, v15);
  return sub_1003562A(v15);
}
// 1003562A: using guessed type int __thiscall sub_1003562A(_DWORD);
// 10060A10: using guessed type int (__stdcall *off_10060A10)(char);

//----- (1002C6B2) --------------------------------------------------------
int __userpurge sub_1002C6B2<eax>(int a1<ebp>, int ebx0<ebx>, int a3<edi>, int a2)
{
  int v4; // eax@1
  int *v5; // ecx@1
  int *v6; // esi@1

  sub_10035648();
  v6 = v5;
  v4 = *(_DWORD *)(a1 + 8);
  if ( v4 == -1 )
  {
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 - 44) = 0;
    *(_DWORD *)(a1 - 40) = sub_10034BF4;
    while ( *v6 != 1 )
    {
      if ( !sub_1002BC25((void *)(a1 - 52)) )
      {
        sub_1002BFEF(a1 - 36);
        *(_DWORD *)(a1 - 20) = a1 - 36;
        sub_1002B62D(a1, (int)(v6 + 2));
        *(_DWORD *)(a1 - 4) = 0;
        if ( *v6 == 1 )
        {
          *(_BYTE *)(a1 + 8) = 1;
        }
        else
        {
          *(_DWORD *)(a1 - 24) = sub_1002C4A7(*v6, 1);
          *v6 = a1 - 24;
        }
        *(_DWORD *)(a1 - 4) = -1;
        sub_1002B6D6();
        if ( !*(_BYTE *)(a1 + 8) )
        {
          if ( *(_DWORD *)(a1 - 28) != 1 )
          {
            _ECX = 2;
            _EDX = a1 - 28;
            __asm { lock cmpxchg [edx], ecx }
            sub_1003117F(ebx0, a1, a3);
          }
        }
        return sub_10035616(68);
      }
    }
  }
  else
  {
    if ( v4 )
    {
      *(_DWORD *)(a1 - 16) = v5;
      sub_1002C787(a1);
    }
  }
  return sub_10035616(68);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002C787) --------------------------------------------------------
int __usercall sub_1002C787<eax>(int a1<ebp>)
{
  int v1; // edx@1
  int v2; // eax@2
  int v3; // ebx@4
  DWORD v4; // edi@6
  unsigned int v5; // eax@12
  int v6; // ecx@20
  int v7; // esi@20
  int v8; // eax@21
  int v9; // edx@21
  int v10; // eax@21
  int *v11; // eax@21
  int v12; // eax@22
  int v13; // edx@22
  int v14; // ecx@22
  int v15; // eax@24
  int v16; // ecx@24
  int v17; // eax@27
  int v18; // ecx@27
  int v19; // eax@32
  int v20; // edi@33
  int v21; // edx@34
  int v32; // eax@48
  int v33; // eax@50
  int v34; // [sp-14h] [bp-14h]@43
  int v35; // [sp-Ch] [bp-Ch]@22
  int v36; // [sp-8h] [bp-8h]@2
  signed int v37; // [sp-4h] [bp-4h]@1

  v37 = 156;
  sub_10035648();
  v1 = *(_DWORD *)(a1 + 8);
  if ( !v1 )
  {
    *(_DWORD *)(a1 - 68) = "pEvents";
    sub_1002AEA4(a1 - 128, (int *)(a1 - 68));
    *(_DWORD *)(a1 - 128) = &off_1005F2EC;
    v36 = (int)&unk_1006C8B4;
    v2 = a1 - 128;
    goto LABEL_3;
  }
  while ( 1 )
  {
    v3 = *(_DWORD *)(a1 + 12);
    if ( !v3 )
      return sub_10035616(v34);
    v4 = *(_DWORD *)(a1 + 20);
    if ( v3 == 1 && (!v4 || v4 == -1) )
    {
      if ( !*(_DWORD *)v1 )
      {
        *(_DWORD *)(a1 - 76) = "pEvents";
        sub_1002AEA4(a1 - 92, (int *)(a1 - 76));
        *(_DWORD *)(a1 - 92) = &off_1005F2EC;
        v36 = (int)&unk_1006C8B4;
        v2 = a1 - 92;
        goto LABEL_3;
      }
      sub_1002C6B2(a1, v3, v4, *(_DWORD *)(a1 + 20));
      return sub_10035616(v34);
    }
    v5 = 0;
    if ( v3 )
    {
      do
      {
        if ( !*(_DWORD *)(v1 + 4 * v5) )
        {
          *(_DWORD *)(a1 - 80) = "pEvents";
          sub_1002AEA4(a1 - 116, (int *)(a1 - 80));
          *(_DWORD *)(a1 - 116) = &off_1005F2EC;
          v36 = (int)&unk_1006C8B4;
          v2 = a1 - 116;
          goto LABEL_3;
        }
        ++v5;
      }
      while ( v5 < v3 );
    }
    LOBYTE(v5) = v4 && v4 != -1;
    sub_1002BF46(*(_DWORD *)(a1 + 16), v3, v4 != -1, v5);
    *(_DWORD *)(a1 - 4) = 0;
    v7 = *(_DWORD *)(a1 - 44);
    v6 = 0;
    *(_BYTE *)(a1 - 13) = 0;
    *(_DWORD *)(a1 - 20) = 0;
    if ( !v3 )
      goto LABEL_38;
    while ( 1 )
    {
      v10 = *(_DWORD *)(*(_DWORD *)(a1 + 8) + 4 * v6);
      *(_DWORD *)(a1 - 28) = v10;
      sub_1002B62D(a1, v10 + 8);
      v11 = *(int **)(a1 - 28);
      v9 = *(_DWORD *)(a1 - 60) + *(_DWORD *)(a1 - 48) + *(_DWORD *)(a1 - 20) * *(_DWORD *)(a1 - 56);
      ++*(_DWORD *)(a1 - 40);
      v8 = *v11;
      *(_BYTE *)(a1 - 4) = 1;
      *(_DWORD *)(a1 - 32) = v9;
      if ( v8 == 1 )
        break;
      v17 = sub_1002C4A7(v8, 1);
      v18 = *(_DWORD *)(a1 - 32);
      *(_DWORD *)v18 = v17;
      **(_DWORD **)(a1 - 28) = v18;
LABEL_28:
      *(_BYTE *)(a1 - 4) = 0;
      sub_1002B6D6();
      v6 = *(_DWORD *)(a1 - 20) + 1;
      *(_DWORD *)(a1 - 20) = v6;
      if ( v6 >= (unsigned int)v3 )
        goto LABEL_37;
    }
    v14 = *(_DWORD *)(v9 + 4);
    v36 = v9;
    v12 = *(_DWORD *)v14;
    v13 = a1 - 24;
    v35 = a1 - 24;
    if ( *(_BYTE *)(a1 + 16) )
    {
      if ( (unsigned __int8)(*(int (__fastcall **)(int, int))v12)(v14, v13) )
      {
        v15 = sub_1002C4A7(*(_DWORD *)(*(_DWORD *)(a1 - 28) + 4), 0);
        v16 = *(_DWORD *)(a1 - 32);
        *(_DWORD *)v16 = v15;
        *(_DWORD *)(*(_DWORD *)(a1 - 28) + 4) = v16;
      }
      if ( *(_DWORD *)(a1 - 24) )
        *(_BYTE *)(a1 - 13) = 1;
      goto LABEL_28;
    }
    (*(void (__fastcall **)(int, int))v12)(v14, v13);
    if ( *(_DWORD *)(a1 - 24) )
      *(_BYTE *)(a1 - 13) = 1;
    v19 = *(_DWORD *)(a1 - 20) + 1;
    *(_DWORD *)(a1 + 8) = v19;
    if ( v19 < (unsigned int)v3 )
    {
      v20 = v19;
      do
      {
        v21 = *(_DWORD *)(a1 - 60) + *(_DWORD *)(a1 - 48) + v20 * *(_DWORD *)(a1 - 56);
        ++*(_DWORD *)(a1 - 40);
        (***(void (__cdecl ****)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(v21 + 4))(a1 - 24, v21, v35, v36, v37);
        ++v20;
      }
      while ( v20 < (unsigned int)v3 );
      v4 = *(_DWORD *)(a1 + 20);
    }
    *(_BYTE *)(a1 - 4) = 0;
    sub_1002B6D6();
LABEL_37:
    if ( *(_BYTE *)(a1 - 13) )
    {
LABEL_42:
      sub_1002C0B4((void *)(a1 - 60));
      return sub_10035616(v34);
    }
LABEL_38:
    _EDX = v7 + 8;
    if ( *(_DWORD *)(v7 + 8) == 1 )
      goto LABEL_42;
    _ECX = 2;
    __asm { lock cmpxchg [edx], ecx }
    if ( !v4 )
    {
      _EAX = v7 + 20;
      _ECX = 1;
      __asm { lock xadd [eax], ecx }
      if ( _ECX == 0 )
      {
        *(_DWORD *)(v7 + 12) &= v4;
        *(_BYTE *)(v7 + 41) = 1;
      }
      else
      {
        sub_1003117F(1, a1, v4);
      }
      goto LABEL_42;
    }
    if ( v4 == -1 || *(_DWORD *)(v7 + 20) )
      goto LABEL_53;
    if ( sub_1003D685() >= 3 )
    {
      v32 = sub_10034A98(v4, (int)sub_1002C172, v7);
      *(_DWORD *)(v7 + 16) = v32;
      if ( !v32 )
      {
        *(_DWORD *)(a1 - 64) = "bad allocation";
        sub_1002AEC9(a1 - 140, a1 - 64, 1);
        *(_DWORD *)(a1 - 140) = &off_1005F2C4;
        v2 = a1 - 140;
        goto LABEL_3;
      }
LABEL_52:
      ++*(_DWORD *)(a1 - 40);
LABEL_53:
      sub_1003117F(-1, a1, v4);
      goto LABEL_42;
    }
    v33 = sub_1002C20D();
    if ( CreateTimerQueueTimer(
           (PHANDLE)(v7 + 16),
           (HANDLE)v33,
           (WAITORTIMERCALLBACK)sub_1002C1BF,
           (PVOID)v7,
           v4,
           0,
           0x20u) )
      goto LABEL_52;
    *(_DWORD *)(a1 - 72) = "bad allocation";
    sub_1002AEC9(a1 - 104, a1 - 72, 1);
    *(_DWORD *)(a1 - 104) = &off_1005F2C4;
    v2 = a1 - 104;
LABEL_3:
    sub_100355BB(v2, v36);
  }
}
// 1002BF46: using guessed type _DWORD __stdcall sub_1002BF46(_DWORD, _DWORD, _DWORD, _DWORD);
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 1003D685: using guessed type int sub_1003D685(void);
// 1005F2C4: using guessed type int (__stdcall *off_1005F2C4)(char);
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);

//----- (1002CAA4) --------------------------------------------------------
void __usercall sub_1002CAA4(int a1<ebx>, int a2)
{
  if ( a2 )
  {
    if ( *(_DWORD *)(a2 - 8) == 56797 )
      sub_100309C2(a1, (LPVOID)(a2 - 8));
  }
}

//----- (1002CAC2) --------------------------------------------------------
void __usercall sub_1002CAC2(int a1<ebx>)
{
  void (*v1)(void); // eax@1

  v1 = (void (*)(void))DecodePointer(dword_10075EF8);
  if ( v1 )
    v1();
  sub_1003F609(a1, 25);
  sub_10039280(0, 1);
  JUMPOUT(loc_1003929F);
}

//----- (1002CAEC) --------------------------------------------------------
void __usercall sub_1002CAEC(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  *(_DWORD *)a2 = &off_10060A20;
  sub_1003F9A8(a1, a2, a3, a4, a2);
}
// 10060A20: using guessed type int (__stdcall *off_10060A20)(char);

//----- (1002CAFA) --------------------------------------------------------
bool __thiscall sub_1002CAFA(void *this, int a2)
{
  return sub_100392F0(a2 + 9, (int)((char *)this + 9)) == 0;
}

//----- (1002CB18) --------------------------------------------------------
void *__userpurge sub_1002CB18<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, char a5)
{
  void *v5; // esi@1

  v5 = (void *)a2;
  sub_1002CAEC(a1, a2, a3, a4);
  if ( a5 & 1 )
    sub_1002A4AA(v5);
  return v5;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002CB6F) --------------------------------------------------------
int __thiscall sub_1002CB6F(int this)
{
  int result; // eax@1
  int v2; // esi@1
  int v3; // ecx@2

  v2 = this;
  result = sub_100348F9(*(_DWORD *)(this + 4));
  if ( result )
  {
    v3 = *(_DWORD *)result;
    --*(_DWORD *)v2;
    *(_DWORD *)(v2 + 4) = v3;
  }
  return result;
}

//----- (1002CB88) --------------------------------------------------------
int __usercall sub_1002CB88<eax>(int a1<ebx>, int a2<edi>, unsigned int a3)
{
  int ebp0; // ebp@0
  LPVOID v4; // eax@2
  int v6; // eax@3
  int v7; // edx@3
  int v8; // ecx@3
  int v9; // ebx@3
  int v10; // edi@3
  int v11; // esi@3
  int v12; // ecx@3
  int v13; // ST00_4@3
  int v14; // esi@4
  int (__stdcall **v15)(char); // [sp+0h] [bp-Ch]@3

  if ( a3 <= 0x7FFFFFFF )
  {
    v4 = sub_1002B771(a1, ebp0, a2);
    return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v4 + 40))(v4);
  }
  a3 = (unsigned int)"bad allocation";
  sub_1002AEC9((int)&v15, (int)&a3, 1);
  v15 = &off_1005F2C4;
  sub_100355BB((int)&v15, (int)&unk_1006AA70);
  __asm { int     3               ; Trap to Debugger }
  v11 = a3 + 4;
  v9 = v12;
  v6 = sub_1002CC9E(a3 + 4);
  v10 = v6;
  v8 = v13;
  if ( v6 == -1 )
    goto LABEL_6;
  v14 = sub_1002CB6F(v9 + 4 + 8 * v6);
  if ( !v14 )
  {
    v11 = dword_10060A28[v10];
LABEL_6:
    v14 = sub_1002965B(v7, v8, v9, v10, v11);
  }
  *(_DWORD *)v14 = sub_100348F9(v10);
  return v14 + 4;
}
// 1005F2C4: using guessed type int (__stdcall *off_1005F2C4)(char);
// 10060A28: using guessed type int dword_10060A28[];

//----- (1002CC23) --------------------------------------------------------
char __thiscall sub_1002CC23(int this, int a2)
{
  int v2; // esi@1
  char result; // al@2
  int v4; // eax@2

  v2 = this;
  if ( *(_DWORD *)this >= 32 )
  {
    result = 0;
  }
  else
  {
    *(_DWORD *)a2 = *(_DWORD *)(this + 4);
    v4 = sub_100348F9(a2);
    ++*(_DWORD *)v2;
    *(_DWORD *)(v2 + 4) = v4;
    result = 1;
  }
  return result;
}

//----- (1002CC4D) --------------------------------------------------------
void __usercall sub_1002CC4D(int a1<ebx>, int a2<edi>, int a3)
{
  int ebp0; // ebp@0
  LPVOID v4; // eax@2

  if ( a3 )
  {
    v4 = sub_1002B771(a1, ebp0, a2);
    (*(void (__thiscall **)(LPVOID, int))(*(_DWORD *)v4 + 44))(v4, a3);
  }
}

//----- (1002CC67) --------------------------------------------------------
char __thiscall sub_1002CC67(void *this, int a2)
{
  int v2; // eax@1
  void *v3; // edi@1
  int v4; // esi@1
  char result; // al@2

  v4 = a2 - 4;
  v3 = this;
  v2 = sub_100348F9(*(_DWORD *)(a2 - 4));
  if ( v2 == -1 || (result = sub_1002CC23((int)(v3 + 8 * v2 + 4), v4), !result) )
    result = sub_100303A3((LPVOID)v4);
  return result;
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (1002CC9E) --------------------------------------------------------
int __cdecl sub_1002CC9E(int a1)
{
  int v1; // edx@1
  int result; // eax@2
  signed int v3; // edx@3
  signed int v4; // ecx@5

  v1 = (a1 + 7) & 0xFFFFFFF8;
  if ( (unsigned int)v1 <= 0x1000 )
  {
    v3 = (unsigned int)v1 >> 3;
    if ( v3 > 32 )
    {
      v4 = 5;
      if ( (v3 & 0xFFFFFFE0) > 0 )
      {
        do
          ++v4;
        while ( v3 >> v4 > 0 );
      }
      result = ((~((1 << (v4 - 5)) - 1) & ((1 << (v4 - 5)) - 1 + v3)) >> (v4 - 5)) + 16 * (v4 - 5) - 1;
    }
    else
    {
      result = v3 - 1;
    }
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1002CCF3) --------------------------------------------------------
int __usercall sub_1002CCF3<eax>(int a1<ebx>, int a2)
{
  int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // esi@3
  int v8; // [sp-4h] [bp-Ch]@1

  v5 = a2 + 4;
  v2 = sub_1002CC9E(a2 + 4);
  v4 = v2;
  if ( v2 != -1 )
    v5 = dword_10060A28[v2];
  v7 = sub_1002965B(v3, v8, a1, v2, v5);
  *(_DWORD *)v7 = sub_100348F9(v4);
  return v7 + 4;
}
// 10060A28: using guessed type int dword_10060A28[];

//----- (1002CD2C) --------------------------------------------------------
int __userpurge sub_1002CD2C<eax>(int a1<ebp>, int a2)
{
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // ST00_4@1

  sub_10035648();
  v4 = v3;
  *(_DWORD *)(a1 - 16) = v3;
  *(_DWORD *)v3 = &off_10060920;
  *(_DWORD *)(v3 + 4) = 1;
  v5 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)v3 = &off_10060BD8;
  sub_1002CE92(a1, v5);
  *(_DWORD *)(v4 + 144) = sub_1002D70A;
  *(_DWORD *)(v4 + 148) = v4;
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 10060920: using guessed type int (__stdcall *off_10060920)(char);
// 10060BD8: using guessed type int (__stdcall *off_10060BD8)(int);

//----- (1002CD79) --------------------------------------------------------
int __userpurge sub_1002CD79<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10060BB4;
  return v4;
}
// 10060BB4: using guessed type int (__stdcall *off_10060BB4)(char);

//----- (1002CD94) --------------------------------------------------------
int __userpurge sub_1002CD94<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4)
{
  signed int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // esi@4
  int v9; // esi@4
  LPVOID v10; // eax@4
  int v18; // eax@7
  int v19; // esi@7
  LPVOID v24; // esi@12
  int v26; // eax@14

  sub_10035648();
  v5 = v7;
  *(_DWORD *)(a2 - 16) = v7;
  *(_DWORD *)(v5 + 4) |= 0xFFFFFFFu;
  v4 = 7;
  *(_DWORD *)(v5 + 8) = 0;
  *(_DWORD *)(v5 + 16) = 0;
  v6 = v5;
  while ( v4 )
  {
    v6 += 4;
    --v4;
  }
  *(_DWORD *)(v5 + 20) = -2147483648;
  *(_DWORD *)(v5 + 24) = 0;
  *(_DWORD *)(v5 + 56) = 0;
  sub_1002C08B(v5 + 60);
  v9 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(v5 + 100) = *(_DWORD *)(v9 + 100);
  *(_DWORD *)(v5 + 108) = 0;
  *(_DWORD *)(a2 - 4) = 0;
  *(_DWORD *)(v5 + 120) = 0;
  *(_DWORD *)(v5 + 132) = 0;
  *(_DWORD *)(v5 + 136) = 0;
  v10 = sub_1002B771(a1, a2, v5);
  *(_DWORD *)(v5 + 12) = v10;
  *(_DWORD *)v5 = *((_DWORD *)v10 + 13);
  v8 = *(_DWORD *)(v9 + 8);
  *(_DWORD *)(v5 + 8) = v8;
  if ( sub_100097C0(v8) )
  {
    _EAX = v8 + 4;
    _EDX = 1;
    __asm { lock xadd [eax], edx }
  }
  sub_1002D8B1(a2);
  sub_1002C5B1(a2);
  if ( *(_BYTE *)(a2 + 12) )
  {
    _EDX = *(_DWORD *)(v5 + 100) + 104;
    _ECX = v5;
    v19 = *(_DWORD *)_EDX;
    *(_DWORD *)(v5 + 104) = *(_DWORD *)_EDX;
    v18 = v19;
    __asm { lock cmpxchg [edx], ecx }
    while ( v18 != v19 )
    {
      *(_DWORD *)(v5 + 104) = v18;
      v19 = v18;
      _EDX = v5;
      _ECX = *(_DWORD *)(v5 + 100) + 104;
      __asm { lock cmpxchg [ecx], edx }
    }
  }
  else
  {
    *(_DWORD *)(v5 + 120) |= 1u;
    *(_DWORD *)(v5 + 104) = 0;
  }
  v24 = sub_10032356();
  if ( !*((_DWORD *)v24 + 8) )
    sub_1002E746(a1, a2);
  v26 = *(_DWORD *)(*((_DWORD *)v24 + 8) + 64);
  *(_DWORD *)(v5 + 4) &= 0xFFFFFFFu;
  *(_DWORD *)(v5 + 128) = v26;
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002CE92) --------------------------------------------------------
int __userpurge sub_1002CE92<eax>(int a1<ebp>, int a2)
{
  signed int v2; // ecx@1
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ecx@1
  LPVOID v14; // eax@6
  LPVOID v15; // esi@6
  int v17; // eax@8

  sub_10035648();
  v4 = v6;
  *(_DWORD *)(a1 - 16) = v6;
  *(_DWORD *)(v4 + 4) |= 0xFFFFFFFu;
  v3 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(v6 + 16) = 0;
  *(_DWORD *)(v6 + 24) = 0;
  v2 = 7;
  *(_DWORD *)(v4 + 8) = v3;
  v5 = v4;
  while ( v2 )
  {
    v5 += 4;
    --v2;
  }
  *(_DWORD *)(v4 + 20) = -2147483648;
  *(_DWORD *)(v4 + 56) = 0;
  sub_1002C08B(v4 + 60);
  *(_DWORD *)(v4 + 104) = 0;
  *(_DWORD *)(v4 + 108) = 0;
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)(v4 + 120) = 0;
  *(_DWORD *)(v4 + 132) = 0;
  *(_DWORD *)(v4 + 136) = 0;
  if ( sub_100097C0(v3) )
  {
    _EAX = v3 + 4;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  v14 = sub_1002B771(v3, a1, v4);
  *(_DWORD *)(v4 + 12) = v14;
  *(_DWORD *)v4 = *((_DWORD *)v14 + 13);
  sub_1002D8B1(a1);
  sub_1002C5B1(a1);
  *(_DWORD *)(v4 + 100) = v4;
  v15 = sub_10032356();
  if ( !*((_DWORD *)v15 + 8) )
    sub_1002E746(v3, a1);
  v17 = *(_DWORD *)(*((_DWORD *)v15 + 8) + 64);
  *(_DWORD *)(v4 + 4) &= 0xFFFFFFFu;
  *(_DWORD *)(v4 + 128) = v17;
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002CF54) --------------------------------------------------------
int __userpurge sub_1002CF54<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10060BCC;
  return v4;
}
// 10060BCC: using guessed type int (__stdcall *off_10060BCC)(char);

//----- (1002CF6F) --------------------------------------------------------
int __userpurge sub_1002CF6F<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10060BC0;
  return v4;
}
// 10060BC0: using guessed type int (__stdcall *off_10060BC0)(char);

//----- (1002CF9A) --------------------------------------------------------
int __thiscall sub_1002CF9A(int this)
{
  int result; // eax@2

  if ( *(_DWORD *)(this + 8) )
    result = sub_100303A3(*(LPVOID *)(this + 8));
  return result;
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (1002CFB4) --------------------------------------------------------
int __usercall sub_1002CFB4<eax>(int a1<ebp>)
{
  char v1; // bl@1
  int v2; // edi@1
  int v3; // ecx@1
  int v4; // ecx@3
  int v5; // esi@4
  void *v6; // esi@5
  int v7; // esi@7

  sub_10035648();
  v2 = v3;
  *(_DWORD *)(a1 - 16) = v3;
  v1 = 0;
  *(_DWORD *)(a1 - 4) = 0;
  if ( !sub_1002D8E1(v3) )
  {
    v1 = sub_1002E05F(v2, v2, 0) == 0;
    if ( *(_DWORD *)(v2 + 100) == v2 )
    {
      v4 = *(_DWORD *)(v2 + 104);
      if ( v4 )
      {
        do
        {
          v5 = *(_DWORD *)(v4 + 104);
          sub_1002D9FA(v4, a1);
          v4 = v5;
        }
        while ( v5 );
      }
    }
  }
  v6 = *(void **)(v2 + 108);
  if ( v6 )
  {
    sub_1002CF9A(*(_DWORD *)(v2 + 108));
    sub_1002A4AA(v6);
  }
  v7 = *(_DWORD *)(v2 + 24) & 0xFFFFFFFC;
  if ( *(_DWORD *)(v2 + 24) & 0xFFFFFFFC )
  {
    if ( v7 != 12 )
    {
      sub_1002FDDA(*(_DWORD *)(v2 + 24) & 0xFFFFFFFC);
      sub_1002A4AA((LPVOID)v7);
    }
  }
  if ( sub_100097C0(*(_DWORD *)(v2 + 8)) )
    sub_1000AA50(*(void **)(v2 + 8));
  if ( v1 )
  {
    sub_10030055(a1 - 28);
    sub_100355BB(a1 - 28, (int)&unk_1006B060);
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002C0CE(a1);
  return sub_10035616(16);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002D06E) --------------------------------------------------------
void *__userpurge sub_1002D06E<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1
  int v4; // ST00_4@1

  v3 = (void *)a1;
  v4 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)a1 = &off_10060BE4;
  sub_1002CAA4(a2, v4);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10060BE4: using guessed type int (__stdcall *off_10060BE4)(char);

//----- (1002D097) --------------------------------------------------------
int __userpurge sub_1002D097<eax>(int a1<ebp>, int a2)
{
  void *v2; // esi@1
  void *v3; // ecx@1
  char v4; // zf@1

  sub_10035648();
  v2 = v3;
  *(_DWORD *)(a1 - 16) = v3;
  *(_DWORD *)(a1 - 4) = 0;
  sub_1002CFB4(a1);
  v4 = (*(_BYTE *)(a1 + 8) & 1) == 0;
  *(_DWORD *)v2 = &off_10060920;
  if ( !v4 )
    sub_1002A4AA(v2);
  return sub_10035616(4);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 10060920: using guessed type int (__stdcall *off_10060920)(char);

//----- (1002D0D1) --------------------------------------------------------
int __thiscall sub_1002D0D1(void *this, char a2, char a3)
{
  void *v4; // esi@1

  v4 = this;
  sub_1002EF98(this);
  return sub_10033214((unsigned int *)v4 + 32, (int)&a2, (int)&a3);
}

//----- (1002D0F4) --------------------------------------------------------
char __thiscall sub_1002D0F4(unsigned int *this, int a2, int a3)
{
  int v3; // eax@1
  int v4; // esi@1
  int v5; // eax@1
  char result; // al@4

  v4 = (int)this;
  v5 = sub_1002D18F(a2, *this);
  v3 = sub_1002D257(v4, a2, v5);
  if ( v3 )
  {
    if ( a3 )
      *(_DWORD *)a3 = *(_DWORD *)(v3 + 8);
    sub_1002A4AA((LPVOID)v3);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002D133) --------------------------------------------------------
int __thiscall sub_1002D133(int this, char a2)
{
  int v2; // eax@1
  int ebp0; // ebp@0
  unsigned int *v4; // edi@1
  int v5; // esi@2
  int v7; // [sp+8h] [bp-4h]@6

  v4 = (unsigned int *)(this + 128);
  v2 = sub_1003248C((unsigned int *)(this + 128), (int)&a2, 0);
  if ( v2 )
    v5 = *(_DWORD *)(v2 + 8);
  else
    v5 = 0;
  if ( v5 )
  {
    if ( (*(_DWORD *)(v5 + 120) >> 1) & 1 )
    {
      v7 = *(_DWORD *)(v5 + 100);
      sub_1002D0F4(v4, (int)&v7, 0);
      sub_1002CFB4(ebp0);
      sub_1002A4AA((LPVOID)v5);
      v5 = 0;
    }
  }
  return v5;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002D18F) --------------------------------------------------------
int __cdecl sub_1002D18F(int a1, unsigned int a2)
{
  unsigned int v2; // edx@1
  unsigned int v3; // ecx@1

  v2 = -2128831035;
  v3 = 0;
  do
    v2 = 16777619 * (*(_BYTE *)(v3++ + a1) ^ v2);
  while ( v3 < 4 );
  return v2 % a2;
}

//----- (1002D1BB) --------------------------------------------------------
int __thiscall sub_1002D1BB(int this, int a2, int a3)
{
  int v3; // ecx@1
  int result; // eax@4

  v3 = *(_DWORD *)(*(_DWORD *)(this + 8) + 4 * a3);
  if ( v3 )
  {
    while ( *(_DWORD *)(v3 + 4) != *(_DWORD *)a2 )
    {
      v3 = *(_DWORD *)v3;
      if ( !v3 )
        goto LABEL_4;
    }
    result = v3;
  }
  else
  {
LABEL_4:
    result = 0;
  }
  return result;
}

//----- (1002D1E5) --------------------------------------------------------
char __thiscall sub_1002D1E5(int this, int a2)
{
  int v2; // ebx@1
  int v4; // edi@4
  signed __int64 v6; // qax@4
  int v7; // esi@4
  void *v8; // ST00_4@4

  v2 = this;
  if ( *(_DWORD *)(this + 4) >= *(_DWORD *)this )
  {
    if ( *(_DWORD *)(this + 4) >= 1024 )
    {
      *(_BYTE *)(this + 12) = 1;
      return 0;
    }
    v4 = *(_DWORD *)this + 8;
    _ECX = 0;
    v6 = 4i64 * (unsigned int)v4;
    __asm { seto    cl }
    v7 = sub_1002965B(SHIDWORD(v6), v6 | -_ECX, v2, v4, v6 | -_ECX);
    sub_10034EE0((void *)v7, *(const void **)(v2 + 8), 4 * *(_DWORD *)v2);
    v8 = *(void **)(v2 + 8);
    *(_DWORD *)v2 = v4;
    sub_100303A3(v8);
    *(_DWORD *)(v2 + 8) = v7;
  }
  *(_DWORD *)(*(_DWORD *)(v2 + 8) + 4 * *(_DWORD *)(v2 + 4)++) = a2;
  return 1;
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (1002D257) --------------------------------------------------------
int __thiscall sub_1002D257(int this, int a2, int a3)
{
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  int result; // eax@4

  v5 = this;
  v6 = 0;
  v4 = *(_DWORD *)(this + 8);
  v3 = *(_DWORD *)(v4 + 4 * a3);
  if ( v3 )
  {
    while ( *(_DWORD *)(v3 + 4) != *(_DWORD *)a2 )
    {
      v6 = v3;
      v3 = *(_DWORD *)v3;
      if ( !v3 )
        goto LABEL_4;
    }
    if ( v6 )
      *(_DWORD *)v6 = *(_DWORD *)v3;
    else
      *(_DWORD *)(v4 + 4 * a3) = *(_DWORD *)v3;
    --*(_DWORD *)(v5 + 4);
    result = v3;
  }
  else
  {
LABEL_4:
    result = 0;
  }
  return result;
}

//----- (1002D29F) --------------------------------------------------------
int __thiscall sub_1002D29F(int this, char a2)
{
  int v2; // ebx@1
  int ebp0; // ebp@0
  int v4; // esi@1
  int v5; // edi@2
  unsigned int v6; // eax@8
  int v7; // eax@9
  int v8; // eax@11
  int v9; // ecx@11
  int v10; // eax@13
  int result; // eax@25
  int v12; // [sp+Ch] [bp-Ch]@1
  int v13; // [sp+14h] [bp-4h]@1

  v4 = this;
  v2 = *(_DWORD *)(this + 108);
  v13 = (int)sub_10032356();
  v12 = *(_DWORD *)(v4 + 108);
  if ( sub_1002D8F4(v4) )
    v5 = 0;
  else
    v5 = *(_DWORD *)(*(_DWORD *)(v4 + 100) + 104);
  if ( v2 && *(_BYTE *)(v2 + 12) )
  {
    sub_1002D3CC((void *)v4, v13);
    *(_BYTE *)(v2 + 12) = 0;
  }
  else
  {
    while ( *(_DWORD *)(v4 + 132) > 0 )
    {
      v6 = *(_DWORD *)(v4 + 132);
      if ( v6 <= 2 )
      {
        v7 = *(_DWORD *)(v4 + 4 * v6 + 108);
      }
      else
      {
        --*(_DWORD *)(v2 + 4);
        v7 = *(_DWORD *)(*(_DWORD *)(v2 + 8) + 4 * *(_DWORD *)(v2 + 4));
      }
      --*(_DWORD *)(v4 + 132);
      v8 = sub_1002F38C(v13, v7);
      v9 = v8;
      if ( !v8 )
        break;
      if ( v8 != 1 )
      {
        v10 = *(_DWORD *)(v13 + 156);
        if ( *(_BYTE *)(v13 + 76) )
          ++*(_DWORD *)(v10 + 12);
        else
          ++*(_DWORD *)(v10 + 96);
        *(_DWORD *)(v9 + 8) = 0;
        sub_1002D951((void *)v4, v9);
      }
    }
  }
  LOBYTE(v2) = a2;
  while ( 1 )
  {
    if ( a2 || *(_DWORD *)(v4 + 16) > 0 || sub_1002D8E1(v4) || v5 )
      sub_1002D4F4(*(void **)(v4 + 100), v2, v5, 0, v5);
    sub_1002D74F(ebp0, v5);
    result = sub_1002D8F4(v4) ? 0 : *(_DWORD *)(*(_DWORD *)(v4 + 100) + 104);
    if ( v5 == result )
      break;
    v5 = result;
  }
  *(_DWORD *)(v4 + 132) = 0;
  if ( v12 )
    *(_DWORD *)(v12 + 4) = 0;
  if ( !a2 )
    result = sub_1002DA6B((void *)v4, v5);
  return result;
}

//----- (1002D3CC) --------------------------------------------------------
int __thiscall sub_1002D3CC(void *this, int a2)
{
  int result; // eax@1
  LPVOID v3; // eax@2
  int v4; // ecx@2
  char v5; // zf@2
  void *v6; // [sp+0h] [bp-8h]@1
  int v7; // [sp+4h] [bp-4h]@1

  v7 = 0;
  v6 = this;
  result = sub_1002F014(
             (int (__cdecl *)(_DWORD, _DWORD))sub_1002D6F5,
             (int)&v6,
             (int (__cdecl *)(_DWORD, _DWORD))sub_1002E046);
  if ( v7 )
  {
    v3 = sub_10032356();
    v5 = *((_BYTE *)v3 + 76) == 0;
    v4 = *((_DWORD *)v3 + 39);
    result = v7;
    if ( v5 )
      *(_DWORD *)(v4 + 96) += v7;
    else
      *(_DWORD *)(v4 + 12) += v7;
  }
  return result;
}

//----- (1002D414) --------------------------------------------------------
int __usercall sub_1002D414<eax>(int a1<ebp>, int a2<ebx>, int a3<edi>)
{
  char v3; // bl@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // ecx@1
  int v7; // eax@6
  int v8; // edx@8
  int v9; // ecx@8
  int v10; // eax@9

  sub_10035648();
  v5 = v6;
  v4 = (int)sub_1002B771(a2, a1, a3);
  v3 = 0;
  if ( !*(_DWORD *)(v4 + 32) )
    sub_1002E746(0, a1);
  if ( v4 != *(_DWORD *)(v5 + 12) || *(_DWORD *)(*(_DWORD *)(v4 + 32) + 64) != *(_DWORD *)(v5 + 128) )
  {
    v7 = sub_1002E9D9(v4);
    if ( !v7 || *(_DWORD *)(v7 + 100) != v5 )
    {
      if ( !sub_1002D133(v4, v5) )
      {
        v10 = sub_1002ADB1(v8, v9, 0, v4, 144);
        *(_DWORD *)(a1 - 16) = v10;
        *(_DWORD *)(a1 - 4) = 0;
        if ( v10 )
          v3 = sub_1002CD94(0, a1, v5, 1);
        *(_DWORD *)(a1 - 4) = -1;
        sub_1002D0D1((void *)v4, v5, v3);
      }
    }
  }
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002D4A0) --------------------------------------------------------
char __usercall sub_1002D4A0<al>(int a1<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>)
{
  int v4; // esi@1
  char result; // al@3
  int v6; // ecx@4
  int v14; // [sp-4h] [bp-8h]@5

  v4 = a1;
  if ( !*(_DWORD *)(a1 + 12) )
    *(_DWORD *)(a1 + 12) = sub_1002B771(a2, a3, a4);
  result = sub_1003FF63(v4);
  if ( result )
  {
    v6 = *(_DWORD *)(v4 + 12);
    if ( 16 * *(_DWORD *)(v4 + 4) >> 4 < 0 )
    {
      _EAX = v6 + 120;
      _ECX = 1;
      __asm { lock xadd [eax], ecx }
      v14 = 2;
    }
    else
    {
      sub_1002E4F8(v6, 16 * *(_DWORD *)(v4 + 4) >> 4);
      v14 = 3;
    }
    sub_1003FF15(v4, v14);
    result = sub_1002E597(a3, v4);
  }
  return result;
}

//----- (1002D4F4) --------------------------------------------------------
char __userpurge sub_1002D4F4<al>(void *this<ecx>, int ebx0<ebx>, int edi0<edi>, int a2, int a3)
{
  char result; // al@1
  int ebp0; // ebp@0
  int v7; // edi@1
  int v8; // esi@1
  int v9; // edi@4
  int v11; // edi@6
  int v13; // [sp+8h] [bp-4h]@12

  v8 = (int)this;
  v7 = sub_1002D414(ebp0, ebx0, edi0);
  result = sub_1002E00C(v8, 1);
  if ( result )
  {
    if ( sub_1002D8F4(v7) || v7 == v8 )
    {
      _EBX = v8 + 56;
      do
      {
        while ( 1 )
        {
          v11 = *(_DWORD *)_EBX;
          if ( *(_DWORD *)_EBX != 1 )
          {
            if ( v11 != 5 )
              break;
          }
          v13 = *(_DWORD *)(v8 + 12);
          sub_1002E4F8(v13, 16 * *(_DWORD *)(v8 + 4) >> 4);
          if ( v11 == 5 )
            sub_1002D3CC((void *)v8, v13);
          *(_DWORD *)_EBX = 4;
        }
        _ECX = 3;
        __asm { lock cmpxchg [ebx], ecx }
      }
      while ( v11 );
      v9 = a2;
      sub_1002D661(ebp0, a2, 1);
    }
    else
    {
      v9 = a2;
      sub_1002D5C0(v8, a2);
    }
    result = sub_1002D5A1(v9, a3);
  }
  return result;
}

//----- (1002D593) --------------------------------------------------------
char __usercall sub_1002D593<al>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  return sub_1002D4F4(*(void **)(a1 + 100), a2, a3, 0, *(_DWORD *)(a1 + 104));
}

//----- (1002D5A1) --------------------------------------------------------
int __stdcall sub_1002D5A1(int a1, int a2)
{
  int i; // esi@1
  int result; // eax@2

  for ( i = a2; i; i = *(_DWORD *)(i + 104) )
    result = sub_1002D5C0(i, a1);
  return result;
}

//----- (1002D5C0) --------------------------------------------------------
int __thiscall sub_1002D5C0(int this, int a2)
{
  char v3; // bl@1
  int ebp0; // ebp@0
  int v5; // esi@1
  int result; // eax@2
  int v8; // [sp+Ch] [bp-10h]@12
  int v9; // [sp+10h] [bp-Ch]@1
  int v10; // [sp+14h] [bp-8h]@14
  int v11; // [sp+18h] [bp-4h]@1

  v3 = 0;
  v5 = *(_DWORD *)(this + 56);
  v11 = this;
  v9 = this + 56;
  _EDX = 0;
  do
  {
    result = v5;
    if ( v5 )
    {
      if ( v5 == 1 || (result = v5 - 5, v5 == 5) )
      {
        _EDX = 9;
        goto LABEL_8;
      }
    }
    else
    {
      _EDX = 3;
    }
    if ( !_EDX )
      return result;
LABEL_8:
    _ECX = v9;
    __asm { lock cmpxchg [ecx], edx }
    _EDX = v5;
  }
  while ( v5 != v5 );
  LOBYTE(v10) = 0;
  if ( v5 == 1 || v5 == 5 )
  {
    v3 = 1;
    LOBYTE(v10) = 1;
    v8 = *(_DWORD *)(v11 + 12);
    sub_1002E4F8(v8, 16 * *(_DWORD *)(v11 + 4) >> 4);
    if ( v5 == 5 )
      sub_1002D3CC((void *)v11, v8);
  }
  result = sub_1002D661(ebp0, a2, v10);
  if ( v3 )
  {
    result = v9;
    *(_DWORD *)v9 = 4;
  }
  return result;
}

//----- (1002D661) --------------------------------------------------------
int __userpurge sub_1002D661<eax>(int a1<ebp>, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // esi@1
  void *v5; // ecx@1
  int v6; // edi@3
  char i; // zf@5

  sub_10035648();
  v4 = (int)v5;
  v3 = (int)((char *)v5 + 28);
  *(_DWORD *)(a1 - 20) = (char *)v5 + 28;
  v5 = (char *)v5 + 32;
  *(_DWORD *)(a1 - 16) = v5;
  sub_1002B95A(v5);
  *(_DWORD *)(a1 - 4) = 0;
  if ( *(_BYTE *)(a1 + 12) )
  {
LABEL_4:
    sub_1002E597(a1, v4);
    goto LABEL_5;
  }
  if ( *(_DWORD *)(v4 + 48) > 0 )
  {
    v6 = *(_DWORD *)v3;
    if ( *(_DWORD *)v3 )
      goto LABEL_8;
    goto LABEL_4;
  }
LABEL_5:
  v6 = *(_DWORD *)v3;
  for ( i = *(_DWORD *)v3 == 0; ; i = v6 == *(_DWORD *)v3 )
  {
    if ( i )
      v6 = 0;
    else
LABEL_8:
      v6 = *(_DWORD *)(v6 + 4);
    if ( !v6 )
      break;
    *(_DWORD *)(v6 + 24) = 1;
    sub_1002E4F8(v6 - 92, -999);
    sub_1002E597(a1, 0);
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002BB6C();
  return sub_10035616(8);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002D6E9) --------------------------------------------------------
char __usercall sub_1002D6E9<al>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  return sub_1002D593(a4, a2, a3);
}

//----- (1002D6F5) --------------------------------------------------------
bool __cdecl sub_1002D6F5(int a1, int a2)
{
  return *(_DWORD *)(a1 + 8) == *(_DWORD *)a2;
}

//----- (1002D70A) --------------------------------------------------------
int __cdecl sub_1002D70A(void *a2)
{
  return sub_1000AA50(a2);
}

//----- (1002D716) --------------------------------------------------------
int __thiscall sub_1002D716(int this)
{
  int v2; // esi@1
  int result; // eax@3

  v2 = this;
  _EDI = this + 20;
  if ( *(_DWORD *)(this + 20) <= -2147483647 )
    sub_1002D860(this);
  _EAX = 1;
  __asm { lock xadd [edi], eax }
  result = _EAX + 1;
  if ( !result )
    result = sub_1002C3C9((void *)(v2 + 28));
  return result;
}

//----- (1002D744) --------------------------------------------------------
int __thiscall sub_1002D744(void *this)
{
  int result; // eax@2

  if ( this )
    result = (**(int (__stdcall ***)(_DWORD))this)(1);
  return result;
}

//----- (1002D74F) --------------------------------------------------------
int __userpurge sub_1002D74F<eax>(int a1<ebp>, int a2)
{
  int v2; // eax@1
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // esi@1
  unsigned int v8; // eax@4
  int v9; // eax@5
  int v10; // edx@10
  signed int v11; // ecx@10
  int v12; // esi@10
  int v13; // ecx@12
  signed int v15; // [sp-4h] [bp-4h]@1

  v15 = 16;
  sub_1003567B();
  v5 = v4;
  v6 = *(_DWORD *)(a1 + 8);
  v2 = v6;
  v7 = 0;
  if ( !v6 )
    goto LABEL_17;
  do
  {
    v2 = *(_DWORD *)(v2 + 104);
    ++v7;
  }
  while ( v2 );
  if ( v7 <= 0 )
  {
LABEL_17:
    sub_1002C6B2(a1, v4, v6, -1);
    return sub_1003562A(v13);
  }
  *(_DWORD *)(a1 - 28) = &off_10060BE4;
  *(_DWORD *)(a1 - 24) = 0;
  *(_DWORD *)(a1 - 20) = 0;
  v8 = 4 * v7 + 12;
  *(_DWORD *)(a1 - 4) = 0;
  if ( v8 > 0x400 )
  {
    v9 = sub_10030930(v3, 0, v4, v6, 4 * v7 + 12);
    if ( v9 )
    {
      *(_DWORD *)v9 = 56797;
      goto LABEL_9;
    }
  }
  else
  {
    sub_1003F580(v8, 0, v15);
    v9 = (int)&v15;
    if ( &v15 )
    {
      v15 = 52428;
LABEL_9:
      v9 += 8;
      goto LABEL_10;
    }
  }
LABEL_10:
  v10 = sub_1002D81D(a1 - 28, v9);
  *(_DWORD *)v10 = *(_DWORD *)(v5 + 100) + 60;
  v11 = 1;
  v12 = v7 + 1;
  if ( v12 > 1 )
  {
    do
    {
      *(_DWORD *)(v10 + 4 * v11) = v6 + 60;
      v6 = *(_DWORD *)(v6 + 104);
      ++v11;
    }
    while ( v11 < v12 );
  }
  sub_1002C787(a1);
  sub_1002CAA4(v5, *(_DWORD *)(a1 - 24));
  return sub_1003562A(v13);
}
// 1003562A: using guessed type int __thiscall sub_1003562A(_DWORD);
// 10060BE4: using guessed type int (__stdcall *off_10060BE4)(char);

//----- (1002D819) --------------------------------------------------------
int __thiscall sub_1002D819(void *this)
{
  return (int)((char *)this + 28);
}

//----- (1002D81D) --------------------------------------------------------
int __thiscall sub_1002D81D(int this, int a2)
{
  int result; // eax@1
  int (__stdcall **v3)(char); // [sp+0h] [bp-Ch]@3

  result = a2;
  if ( !a2 )
  {
    a2 = (int)"bad allocation";
    sub_1002AEC9((int)&v3, (int)&a2, 1);
    v3 = &off_1005F2C4;
    sub_100355BB((int)&v3, (int)&unk_1006AA70);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1002D860);
  }
  *(_DWORD *)(this + 4) = a2;
  *(_DWORD *)(this + 8) = 0;
  return result;
}
// 1005F2C4: using guessed type int (__stdcall *off_1005F2C4)(char);

//----- (1002D860) --------------------------------------------------------
char __thiscall sub_1002D860(int this)
{
  int v3; // eax@3

  _ESI = this + 20;
  _EDX = -2147483647;
  __asm { lock cmpxchg [esi], edx }
  if ( this != -28 )
    *(_DWORD *)(this + 28) = 0;
  v3 = *(_DWORD *)_ESI;
  *(_DWORD *)_ESI = 0;
  return v3;
}

//----- (1002D8B1) --------------------------------------------------------
int __usercall sub_1002D8B1<eax>(int a1<ebp>)
{
  void *v1; // ecx@1
  int v2; // ecx@1
  char v3; // zf@1

  sub_10035648();
  *(_DWORD *)(a1 - 16) = v2;
  *(_DWORD *)(v2 + 48) = 0;
  *(_DWORD *)(v2 + 52) = 0;
  *(_DWORD *)(v2 + 124) = 0;
  v3 = v2 == -28;
  v1 = (void *)(v2 + 28);
  *(_DWORD *)(a1 - 20) = v1;
  *(_DWORD *)(a1 - 4) = 0;
  if ( !v3 )
    sub_10031279(v1);
  return sub_10035616(8);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002D8E1) --------------------------------------------------------
bool __thiscall sub_1002D8E1(int this)
{
  return *(_DWORD *)(this + 100) != this && !(*(_DWORD *)(this + 120) & 1);
}

//----- (1002D8F4) --------------------------------------------------------
bool __thiscall sub_1002D8F4(int this)
{
  return *(_DWORD *)(this + 100) != this && *(_DWORD *)(this + 120) & 1;
}

//----- (1002D907) --------------------------------------------------------
bool __thiscall sub_1002D907(int this)
{
  return *(_DWORD *)(*(_DWORD *)(this + 100) + 52) != 0;
}

//----- (1002D915) --------------------------------------------------------
int __thiscall sub_1002D915(int this)
{
  return (*(_DWORD *)(this + 120) >> 1) & 1;
}

//----- (1002D91E) --------------------------------------------------------
int __usercall sub_1002D91E<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // eax@1
  int v4; // edx@1
  int v5; // ecx@1

  sub_10035648();
  v3 = sub_1002ADB1(v4, v5, a1, a3, 152);
  *(_DWORD *)(a2 - 16) = v3;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v3 )
    sub_1002CD2C(a2, *(_DWORD *)(a2 + 8));
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002D951) --------------------------------------------------------
int __thiscall sub_1002D951(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1
  int result; // eax@3
  int v5; // ebx@3
  int (__cdecl *v6)(_DWORD); // edi@3

  v3 = this;
  if ( *(_BYTE *)(a2 + 16) )
    sub_1003FA40(a2);
  v6 = (int (__cdecl *)(_DWORD))*((_DWORD *)v3 + 34);
  v5 = *((_DWORD *)v3 + 35);
  result = (int)((char *)v3 + 16);
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  if ( _ECX == 1 )
    result = sub_1002C5B1(ebp0);
  if ( v6 )
    result = v6(v5);
  return result;
}

//----- (1002D99A) --------------------------------------------------------
#error "1002C5AB: call analysis failed (funcsize=51)"

//----- (1002D9C0) --------------------------------------------------------
int __thiscall sub_1002D9C0(int this)
{
  return *(_DWORD *)(this + 100);
}

//----- (1002D9C4) --------------------------------------------------------
int __thiscall sub_1002D9C4(int this)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = this;
  sub_1003FF8B(*(_DWORD *)(this + 100));
  _ECX = 1073741824;
  result = *(_DWORD *)(v2 + 100) + 52;
  __asm { lock or [eax], ecx }
  return result;
}

//----- (1002D9DF) --------------------------------------------------------
int __usercall sub_1002D9DF<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  int result; // eax@1
  int v4; // esi@1

  v4 = a1;
  sub_1003FFB6(a2, a3);
  _ECX = -2147483648;
  result = *(_DWORD *)(v4 + 100) + 52;
  __asm { lock or [eax], ecx }
  return result;
}

//----- (1002D9FA) --------------------------------------------------------
int __usercall sub_1002D9FA<eax>(int a1<ecx>, int a2<ebp>)
{
  int v2; // ecx@1
  void *v4; // esi@1
  int result; // eax@2

  v4 = (void *)a1;
  _EDI = a1 + 120;
  v2 = *(_DWORD *)(a1 + 120);
  if ( v2 & 2 )
  {
LABEL_4:
    sub_1002CFB4(a2);
    result = sub_1002A4AA(v4);
  }
  else
  {
    while ( 1 )
    {
      _EDX = v2 | 2;
      result = v2;
      __asm { lock cmpxchg [edi], edx }
      if ( v2 == v2 )
        break;
      if ( v2 & 2 )
        goto LABEL_4;
    }
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002DA2E) --------------------------------------------------------
int __usercall sub_1002DA2E<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@2
  int v3; // ST10_4@2

  if ( dword_10075268 )
  {
    v2 = sub_100348F9(dword_10075268);
    ((void (__thiscall *)(int))v2)(v3);
  }
  if ( IsProcessorFeaturePresent(0x17u) )
    __asm { int     29h             ; DOS 2+ internal - FAST PUTCHAR }
  sub_10039FF6(a1, a2, 1073741845, 3, 1073741845, 1);
  return sub_10039854(0x40000015u);
}
// 10075268: using guessed type int dword_10075268;

//----- (1002DA6B) --------------------------------------------------------
int __thiscall sub_1002DA6B(void *this, int a2)
{
  int ebp0; // ebp@0
  int v3; // edi@1
  int v4; // esi@1
  LPVOID v5; // eax@2
  int v6; // ecx@2
  int v8; // edx@3
  int result; // eax@14
  int v12; // ecx@23
  char v13; // [sp+Ch] [bp-24h]@25
  int v14; // [sp+14h] [bp-1Ch]@24
  BOOL (__cdecl *v15)(); // [sp+18h] [bp-18h]@24
  char v16; // [sp+1Ch] [bp-14h]@6
  int v17; // [sp+24h] [bp-Ch]@5
  BOOL (__cdecl *v18)(); // [sp+28h] [bp-8h]@5
  int v19; // [sp+2Ch] [bp-4h]@2
  int v20; // [sp+38h] [bp+8h]@2

  v3 = a2;
  v4 = (int)this;
  while ( 2 )
  {
    v5 = sub_10032356();
    v6 = *(_DWORD *)(v4 + 12);
    v20 = (int)v5;
    v19 = *(_DWORD *)(v4 + 12);
    _EBX = v4 + 56;
LABEL_3:
    v8 = *(_DWORD *)_EBX;
    while ( 1 )
    {
      if ( v8 == 9 )
      {
        v17 = 0;
        v18 = sub_10034BF4;
        if ( *(_DWORD *)_EBX == 9 )
        {
          do
            sub_100282E0((int)&v16);
          while ( *(_DWORD *)_EBX == 9 );
          v5 = (LPVOID)v20;
          v6 = v19;
        }
        goto LABEL_3;
      }
      if ( v5 != (LPVOID)v6 )
      {
        _ECX = 0;
        __asm { lock cmpxchg [ebx], ecx }
        goto LABEL_13;
      }
      _ECX = 0;
      __asm { lock cmpxchg [ebx], ecx }
      if ( v8 == v8 )
        break;
      v6 = v19;
      v5 = (LPVOID)v20;
    }
    if ( v8 == 4 )
      sub_1002E565(v20, 16 * *(_DWORD *)(v4 + 4) >> 4);
    *(_DWORD *)(v4 + 4) |= 0xFFFFFFFu;
LABEL_13:
    if ( *(_DWORD *)(v4 + 100) == v4 )
    {
      while ( v3 )
      {
        if ( !((*(_DWORD *)(v3 + 120) >> 1) & 1) )
          sub_1002DA6B(0);
        v3 = *(_DWORD *)(v3 + 104);
      }
      result = v4 + 52;
      v12 = *(_DWORD *)(v4 + 52);
      *(_DWORD *)(v4 + 52) = 0;
      if ( v12 < 0 )
      {
        v14 &= v3;
        v15 = sub_10034BF4;
        while ( *(_DWORD *)(v4 + 24) == 8 )
          sub_100282E0((int)&v13);
        result = sub_10040025(_EBX, ebp0);
      }
    }
    else
    {
      result = sub_1002D8E1(v4);
      if ( (_BYTE)result && v3 )
      {
        v4 = *(_DWORD *)(v4 + 100);
        continue;
      }
    }
    return result;
  }
}

//----- (1002DB66) --------------------------------------------------------
int __userpurge sub_1002DB66<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // edi@1
  int v8; // esi@1
  LPVOID v9; // eax@1
  int v10; // eax@1
  int v11; // edx@2
  int v12; // eax@4
  int v13; // eax@7
  int v16; // eax@15
  int i; // eax@17
  unsigned int v18; // ecx@22
  int v19; // eax@23
  int v20; // eax@23
  int v21; // eax@24
  int v22; // ecx@26
  int v23; // eax@27
  int v24; // eax@30
  int v27; // eax@34
  int v33; // [sp-8h] [bp-8h]@10

  sub_100356B1();
  v8 = sub_1002D414(a2, a1, a3);
  *(_DWORD *)(a2 - 24) = v8;
  v9 = sub_10032356();
  v6 = *(_DWORD *)(a2 + 8);
  v7 = (int)v9;
  v10 = *(_DWORD *)(v6 + 104);
  v5 = *(_DWORD *)(v7 + 52);
  *(_DWORD *)(a2 - 36) = v7;
  *(_DWORD *)(a2 - 28) = v10;
  *(_BYTE *)(a2 - 17) = 0;
  *(_DWORD *)v8 = v5;
  if ( v5 )
    v11 = (16 * *(_DWORD *)(v5 + 4) >> 4) + 1;
  else
    v11 = 0;
  *(_DWORD *)(v8 + 4) ^= (v11 ^ *(_DWORD *)(v8 + 4)) & 0xFFFFFFF;
  *(_DWORD *)(v7 + 52) = v8;
  v12 = *(_DWORD *)(v6 + 8);
  *(_DWORD *)(a2 - 32) = 0;
  if ( v12 )
  {
    if ( v12 != 2 )
    {
      if ( v12 != *(_DWORD *)(v7 + 56) )
      {
        v13 = sub_1002B396(v11, v12, 0, (int)sub_1002D6E9, v6, 1);
        v6 = *(_DWORD *)(a2 + 8);
        *(_DWORD *)(a2 - 32) = v13;
      }
    }
    sub_1002ECB3(v7, *(_DWORD *)(v6 + 8), 16 * *(_DWORD *)(v8 + 4) >> 4);
  }
  *(_DWORD *)(a2 - 4) = 0;
  _EDX = 1;
  _ECX = v8 + 56;
  __asm { lock cmpxchg [ecx], edx }
  while ( *(_DWORD *)(a2 + 12) )
  {
    sub_1002D99A(v8);
    if ( !*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 8) + 100) + 52)
      && (*(_DWORD *)(v7 + 112) + *(_DWORD *)(v7 + 120) <= 0 || !sub_1002EAEE(v7, v8, 0)) )
    {
      (*(void (__cdecl **)(_DWORD))(*(_DWORD *)(a2 + 12) + 4))(*(_DWORD *)(a2 + 12));
      v16 = *(_DWORD *)(a2 + 12);
LABEL_16:
      *(_DWORD *)(v16 + 8) = 0;
      sub_1002D951((void *)v8, v16);
      *(_DWORD *)(a2 + 12) = 0;
      break;
    }
    sub_1002FF03(a2 - 64);
    v33 = (int)&unk_1006B0D0;
    v21 = a2 - 64;
LABEL_10:
    sub_100355BB(v21, v33);
  }
  for ( i = *(_DWORD *)(a2 + 8); ; *(_DWORD *)(a2 - 28) = *(_DWORD *)(i + 104) )
  {
    while ( 1 )
    {
      if ( *(_DWORD *)(v8 + 132) <= 0 )
        goto LABEL_30;
      if ( *(_DWORD *)(*(_DWORD *)(i + 100) + 52)
        || *(_DWORD *)(v7 + 112) + *(_DWORD *)(v7 + 120) > 0 && sub_1002EAEE(v7, v8, 0) )
      {
        sub_1002FF03(a2 - 76);
        v33 = (int)&unk_1006B0D0;
        v21 = a2 - 76;
        goto LABEL_10;
      }
      v18 = *(_DWORD *)(v8 + 132);
      if ( v18 <= 2 )
      {
        v19 = *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4 * v18 + 108);
      }
      else
      {
        v20 = *(_DWORD *)(v8 + 108);
        --*(_DWORD *)(v20 + 4);
        v19 = *(_DWORD *)(*(_DWORD *)(v20 + 8) + 4 * *(_DWORD *)(v20 + 4));
      }
      --*(_DWORD *)(v8 + 132);
      v22 = sub_1002F38C(v7, v19);
      *(_DWORD *)(a2 - 40) = v22;
      *(_DWORD *)(a2 + 12) = v22;
      if ( !v22 )
        break;
      i = *(_DWORD *)(a2 + 8);
      if ( v22 != 1 )
      {
        v27 = *(_DWORD *)(v7 + 156);
        if ( *(_BYTE *)(v7 + 76) )
          ++*(_DWORD *)(v27 + 12);
        else
          ++*(_DWORD *)(v27 + 96);
        (*(void (__cdecl **)(int))(v22 + 4))(v22);
        v16 = *(_DWORD *)(a2 - 40);
        goto LABEL_16;
      }
    }
    v23 = *(_DWORD *)(v8 + 108);
    if ( v23 )
      *(_DWORD *)(v23 + 4) = 0;
    *(_DWORD *)(v8 + 132) = 0;
LABEL_30:
    v24 = *(_DWORD *)(v8 + 108);
    if ( v24 )
    {
      if ( *(_BYTE *)(v24 + 12) )
      {
        *(_BYTE *)(a2 - 17) = 1;
        _EDX = 5;
        _ECX = v8 + 56;
        __asm { lock cmpxchg [ecx], edx }
      }
    }
    sub_1002D74F(a2, *(_DWORD *)(a2 - 28));
    if ( *(_BYTE *)(a2 - 17) )
    {
      _EDX = 1;
      _ECX = v8 + 56;
      __asm { lock cmpxchg [ecx], edx }
    }
    i = *(_DWORD *)(a2 + 8);
    if ( *(_DWORD *)(a2 - 28) == *(_DWORD *)(i + 104) )
      break;
  }
  *(_DWORD *)(a2 - 4) = -1;
  if ( *(_DWORD *)(i + 8) )
  {
    sub_1002EBF2(v7, *(_DWORD *)(i + 8));
    if ( *(_DWORD *)(a2 - 32) )
    {
      sub_1002B29A(a2, *(_DWORD *)(a2 - 32));
      sub_1000AA50(*(void **)(a2 - 32));
    }
  }
  *(_DWORD *)(v7 + 52) = *(_DWORD *)v8;
  if ( *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 8) + 100) + 52) )
  {
    sub_1002D29F(v8, 0);
    if ( *(_DWORD *)(v7 + 112) + *(_DWORD *)(v7 + 120) > 0
      && sub_1002EAEE(v7, v8, *(_DWORD *)(*(_DWORD *)(a2 + 8) + 8) != 0) )
    {
      sub_1002FF03(a2 - 100);
      v21 = a2 - 100;
      goto LABEL_10;
    }
  }
  else
  {
    sub_1002DA6B((void *)v8, *(_DWORD *)(a2 - 28));
    if ( *(_DWORD *)(v7 + 112) + *(_DWORD *)(v7 + 120) > 0
      && sub_1002EAEE(v7, v8, *(_DWORD *)(*(_DWORD *)(a2 + 8) + 8) != 0) )
    {
      sub_1002FF03(a2 - 112);
      v21 = a2 - 112;
      goto LABEL_10;
    }
  }
  return sub_10035616(v33);
}
// 1002D99A: using guessed type int __thiscall sub_1002D99A(_DWORD);
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002DF26) --------------------------------------------------------
int __userpurge sub_1002DF26<eax>(int a1<ebp>, int a2)
{
  int v2; // edi@1
  int v3; // edx@3
  int v4; // ecx@3
  int v5; // esi@3
  int v6; // edi@4
  int v7; // eax@5
  int v8; // eax@9
  int v9; // eax@9
  int v11; // eax@12

  sub_100356B1();
  v2 = *(_DWORD *)(a1 + 8);
  if ( *(_DWORD *)(v2 + 8) )
  {
    sub_1002FFA7(a1 - 32);
    sub_100355BB(a1 - 32, (int)&unk_1006B098);
  }
  *(_DWORD *)(a1 - 4) = 0;
  v5 = sub_1002D414(a1, 0, v2);
  *(_DWORD *)(v2 + 8) = v5;
  *(_DWORD *)(v2 + 12) = sub_1003FC50;
  v4 = *(_DWORD *)(v5 + 132);
  *(_DWORD *)(a1 - 20) = v4;
  *(_DWORD *)(v5 + 132) = v4 + 1;
  if ( (unsigned int)v4 < 2 )
  {
    sub_1002D99A(v5);
    v11 = (int)sub_10032356();
    *(_DWORD *)(v5 + 4 * *(_DWORD *)(a1 - 20) + 112) = sub_1002ECC6(v11, 0, v2);
  }
  else
  {
    v6 = *(_DWORD *)(v5 + 108);
    if ( !v6 )
    {
      v7 = sub_1002ADB1(v3, v4, 0, 0, 16);
      v6 = v7;
      if ( v7 )
      {
        *(_DWORD *)v7 = 0;
        *(_DWORD *)(v7 + 4) = 0;
        *(_DWORD *)(v7 + 8) = 0;
        *(_BYTE *)(v7 + 12) = 0;
      }
      else
      {
        v6 = 0;
      }
      *(_DWORD *)(v5 + 108) = v6;
    }
    sub_1002D99A(v5);
    v8 = (int)sub_10032356();
    v9 = sub_1002ECC6(v8, 0, *(_DWORD *)(a1 + 8));
    if ( !sub_1002D1E5(v6, v9) )
      --*(_DWORD *)(v5 + 132);
  }
  return sub_10035616(20);
}
// 1002D99A: using guessed type int __thiscall sub_1002D99A(_DWORD);
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 1003FC50: using guessed type int sub_1003FC50();

//----- (1002DFF3) --------------------------------------------------------
void __userpurge sub_1002DFF3(int a1<ebp>, int a2)
{
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 8) + 16) )
    sub_1003FA40(*(_DWORD *)(a1 + 8));
  JUMPOUT(*(unsigned int *)loc_1002DF4D);
}
// 1002DF4D: using guessed type int __stdcall loc_1002DF4D(int);

//----- (1002E00C) --------------------------------------------------------
char __thiscall sub_1002E00C(int this, int a2)
{
  int v2; // edx@1
  char result; // al@4

  _ESI = this + 52;
  v2 = *(_DWORD *)(this + 52);
  if ( v2 & 0x3FFFFFFF )
  {
LABEL_4:
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      _ECX = a2 | v2 & 0xC0000000;
      __asm { lock cmpxchg [esi], ecx }
      if ( v2 == v2 )
        break;
      if ( v2 & 0x3FFFFFFF )
        goto LABEL_4;
    }
    result = 1;
  }
  return result;
}

//----- (1002E046) --------------------------------------------------------
char __cdecl sub_1002E046(int a1, int a2)
{
  void *v3; // ecx@1

  v3 = *(void **)(a1 + 8);
  ++*(_DWORD *)(a2 + 4);
  sub_1002D951(v3, a1);
  return 1;
}

//----- (1002E05F) --------------------------------------------------------
bool __userpurge sub_1002E05F<eax>(int a1<ecx>, int a2<edi>, char a3)
{
  char v3; // bl@1
  int v4; // esi@1
  int i; // eax@4

  v4 = a1;
  v3 = 0;
  if ( !sub_1002D8E1(a1) )
  {
    if ( sub_1003639F(0, a2) )
      goto LABEL_14;
    v3 = *(_DWORD *)(v4 + 16) > 0;
    if ( *(_DWORD *)(v4 + 100) == v4 )
    {
      for ( i = *(_DWORD *)(v4 + 104); i; i = *(_DWORD *)(i + 104) )
      {
        if ( *(_DWORD *)(i + 16) > 0 )
          v3 = 1;
      }
    }
    if ( v3 )
LABEL_14:
      sub_1002D29F(v4, a3);
  }
  return v3 == 0;
}

//----- (1002E0B5) --------------------------------------------------------
int __userpurge sub_1002E0B5<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned int a4)
{
  int v5; // esi@1
  signed __int64 v7; // qax@1
  int v8; // eax@1
  signed int v9; // ST08_4@1

  v5 = a1;
  _ECX = 0;
  *(_DWORD *)(v5 + 4) = 0;
  *(_DWORD *)v5 = a4;
  v7 = 4i64 * a4;
  __asm { seto    cl }
  v8 = sub_1002965B(SHIDWORD(v7), v7 | -_ECX, a2, a3, v7 | -_ECX);
  v9 = 4 * *(_DWORD *)v5;
  *(_DWORD *)(v5 + 8) = v8;
  sub_100391F0((void *)v8, 0, v9);
  return v5;
}

//----- (1002E0F3) --------------------------------------------------------
int __usercall sub_1002E0F3<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v5; // esi@1

  v5 = a2;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  *(_DWORD *)(a2 + 8) = sub_1002965B(a1, a2, a3, a4, 16);
  return v5;
}

//----- (1002E10C) --------------------------------------------------------
#error "1002E1C7: call analysis failed (funcsize=56)"

//----- (1002E1E2) --------------------------------------------------------
int __thiscall sub_1002E1E2(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100303A3(*(LPVOID *)(this + 28));
  return sub_100303A3(*(LPVOID *)(v2 + 32));
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (1002E1F9) --------------------------------------------------------
int __thiscall sub_1002E1F9(int this)
{
  int v1; // ebx@1
  int v2; // edi@2
  int v3; // esi@3

  v1 = this;
  if ( *(_DWORD *)(this + 4) > 0 )
  {
    v2 = **(_DWORD **)(this + 8);
    if ( v2 )
    {
      do
      {
        v3 = *(_DWORD *)(v2 + 4);
        sub_100303A3(*(LPVOID *)v2);
        sub_1002A4AA((LPVOID)v2);
        v2 = v3;
      }
      while ( v3 );
    }
  }
  return sub_1002A4AA(*(LPVOID *)(v1 + 8));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (1002E239) --------------------------------------------------------
int __thiscall sub_1002E239(void *this)
{
  int result; // eax@1
  void *v2; // edi@1

  v2 = this;
  sub_1002E1F9((int)((char *)this + 140));
  sub_1002F39B((int)((char *)v2 + 128));
  result = sub_100303A3(*((LPVOID *)v2 + 34));
  *(_DWORD *)v2 = off_10060BEC;
  return result;
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 10060BEC: using guessed type int (*off_10060BEC[5])();

//----- (1002E271) --------------------------------------------------------
int __thiscall sub_1002E271(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100303A3(*(LPVOID *)(this + 12));
  return sub_100303A3(*(LPVOID *)(v2 + 8));
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (1002E288) --------------------------------------------------------
bool __thiscall sub_1002E288(int this, int a2)
{
  return !((*(_DWORD *)this ^ *(_DWORD *)a2) & 0xFFFFFFF) && *(_DWORD *)(this + 8) == *(_DWORD *)(a2 + 8);
}

//----- (1002E2AC) --------------------------------------------------------
int __thiscall sub_1002E2AC(int this, signed int a2)
{
  int v2; // eax@1
  signed int v3; // edx@1
  int v4; // eax@2
  int i; // edx@3

  v2 = *(_DWORD *)(this + 8);
  v3 = a2 >> 4;
  if ( a2 >> 4 >= 4 )
  {
    v4 = *(_DWORD *)(v2 + 12);
    for ( i = v3 - 3; i; --i )
      v4 = *(_DWORD *)(v4 + 4);
  }
  else
  {
    v4 = *(_DWORD *)(v2 + 4 * v3);
  }
  return *(_DWORD *)v4 + 8 * (a2 & 0xF);
}

//----- (1002E2E0) --------------------------------------------------------
void *__thiscall sub_1002E2E0(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_10060BEC;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10060BEC: using guessed type int (*off_10060BEC[5])();

//----- (1002E300) --------------------------------------------------------
void *__thiscall sub_1002E300(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_1002E239(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002E31F) --------------------------------------------------------
int __thiscall sub_1002E31F(void *this, char a2)
{
  int v2; // esi@1

  v2 = (int)this;
  sub_1002E1E2((int)((char *)this + 76));
  sub_10044E10(v2);
  if ( a2 & 1 )
    sub_1002A4AA((LPVOID)v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002E348) --------------------------------------------------------
int __thiscall sub_1002E348(int this, int a2)
{
  signed int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // edx@3
  int v12; // ecx@11
  signed __int64 v15; // qax@11
  signed int v16; // ST0C_4@11
  int v17; // edx@11
  int v18; // ecx@11
  int v19; // eax@12
  int v28; // edx@17
  char v30; // [sp+Ch] [bp-20h]@22
  int v31; // [sp+14h] [bp-18h]@21
  BOOL (__cdecl *v32)(); // [sp+18h] [bp-14h]@21
  int v33; // [sp+1Ch] [bp-10h]@5
  int v34; // [sp+20h] [bp-Ch]@2
  int v35; // [sp+24h] [bp-8h]@1
  char v36; // [sp+2Bh] [bp-1h]@1

  v5 = this;
  v3 = *(_DWORD *)(this + 48);
  v36 = 0;
  v4 = 0;
  v35 = v3;
  v2 = 4;
  do
  {
    _EBX = v3 + 8;
    v34 = v3 + 8;
    if ( *(_DWORD *)(v3 + 8) >= -1 )
    {
      _EBX = *(_DWORD *)v3;
      v7 = 0;
      if ( *(_DWORD *)(v5 + 40) <= 0 )
      {
LABEL_7:
        _EBX = v34;
      }
      else
      {
        while ( *(_DWORD *)_EBX )
        {
          ++v7;
          _EBX += v2;
          if ( v7 >= *(_DWORD *)(v5 + 40) )
            goto LABEL_7;
        }
        _ECX = a2;
        *(_DWORD *)(a2 + 68) = v7 + v4;
        v33 = *(_DWORD *)(v5 + 64);
        __asm { lock cmpxchg [ebx], ecx }
        v4 += v7;
        v36 = 1;
        if ( v4 >= v33 )
        {
          _EAX = v5 + 64;
          _ECX = 1;
          __asm { lock xadd [eax], ecx }
        }
        _EBX = v34;
        _ECX = -1;
        __asm { lock cmpxchg [ebx], ecx }
      }
      v3 = v35;
    }
    if ( !v36 )
    {
      _ECX = -2;
      __asm { lock cmpxchg [ebx], ecx }
      v4 += *(_DWORD *)(v5 + 40);
      _EBX = v3 + 4;
      if ( !*(_DWORD *)(v3 + 4) )
      {
        _ECX = 1;
        __asm { lock cmpxchg [ebx], ecx }
        _ECX = 0;
        v15 = 4i64 * *(_DWORD *)(v5 + 40);
        __asm { seto    cl }
        v16 = 4 * *(_DWORD *)(v5 + 40);
        v33 = sub_1002965B(SHIDWORD(v15), v15 | -_ECX, _EBX, v4, v15 | -_ECX);
        sub_100391F0((void *)v33, 0, v16);
        v12 = sub_1002ADB1(v17, v18, _EBX, v4, 12);
        if ( v12 )
        {
          v19 = v33;
          *(_DWORD *)(v12 + 4) = 0;
          *(_DWORD *)(v12 + 8) = -1;
          *(_DWORD *)v12 = v19;
        }
        else
        {
          v12 = 0;
        }
        v28 = *(_DWORD *)(v5 + 60);
        if ( v28 < *(_DWORD *)(v5 + 56) )
        {
          *(_DWORD *)(*(_DWORD *)(v5 + 52) + 4 * v28) = v12;
          ++*(_DWORD *)(v5 + 60);
        }
        *(_DWORD *)_EBX = v12;
        v3 = v35;
      }
      if ( *(_DWORD *)_EBX == 1 )
      {
        v31 = 0;
        v32 = sub_10034BF4;
        do
          sub_100282E0((int)&v30);
        while ( *(_DWORD *)_EBX == 1 );
        v3 = v35;
      }
    }
    v3 = *(_DWORD *)(v3 + 4);
    v35 = v3;
    v2 = 4;
  }
  while ( !v36 );
  return v4;
}

//----- (1002E4A1) --------------------------------------------------------
int __thiscall sub_1002E4A1(void *this, int a2, char a3)
{
  int result; // eax@1
  void *v4; // edi@1

  v4 = this;
  result = sub_1002E4D1((int)((char *)this + 80), a2 + 92);
  *(_BYTE *)(a2 + 77) = 1;
  if ( a3 )
  {
    result = (int)((char *)v4 + 100);
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
  }
  return result;
}

//----- (1002E4D1) --------------------------------------------------------
int __thiscall sub_1002E4D1(int this, int a2)
{
  int v3; // edi@1

  v3 = this;
  sub_1002B98A((void *)(this + 4));
  sub_1002B23D((void *)v3, a2);
  return sub_1002BB74((void *)(v3 + 4));
}

//----- (1002E4F8) --------------------------------------------------------
int __thiscall sub_1002E4F8(int this, int a2)
{
  int result; // eax@1
  int v3; // edx@1
  int v5; // esi@1
  int v13; // eax@7
  int v14; // edx@10

  v5 = this;
  result = this + 112;
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  _EBX = this + 104;
  v3 = *(_DWORD *)(this + 104);
  while ( v3 == -1 || a2 <= v3 )
  {
    _ECX = a2;
    result = v3;
    __asm { lock cmpxchg [ebx], ecx }
    if ( v3 == v3 )
    {
      if ( *(_DWORD *)(v5 + 116) )
        v13 = -1;
      else
        v13 = a2;
      result = sub_1002E975(v5, v13);
      break;
    }
  }
  _ESI = v5 + 108;
  v14 = *(_DWORD *)_ESI;
  do
  {
    if ( v14 != -1 && a2 < v14 )
      break;
    _ECX = a2;
    result = v14;
    __asm { lock cmpxchg [esi], ecx }
  }
  while ( v14 != v14 );
  return result;
}

//----- (1002E565) --------------------------------------------------------
bool __thiscall sub_1002E565(int this, int a2)
{
  int v3; // edi@1

  v3 = this;
  _EBX = -1;
  _ESI = -1;
  _EDX = this + 104;
  __asm { lock cmpxchg [edx], esi }
  sub_1002ED43(this);
  _EAX = v3 + 112;
  __asm { lock xadd [eax], ebx }
  return _EBX == 1;
}

//----- (1002E597) --------------------------------------------------------
int __userpurge sub_1002E597<eax>(int a1<ebp>, int a2)
{
  char i; // zf@1
  signed int v3; // edi@1
  int v4; // esi@1
  void *v5; // ecx@1
  int v6; // eax@3
  int v7; // edx@3
  int v8; // eax@5
  int v9; // ecx@7
  int v10; // ecx@9

  sub_10035648();
  *(_DWORD *)(a1 - 16) = v5;
  v4 = (int)((char *)v5 + 80);
  *(_DWORD *)(a1 - 24) = (char *)v5 + 80;
  v5 = (char *)v5 + 84;
  *(_DWORD *)(a1 - 20) = v5;
  sub_1002B95A(v5);
  v3 = *(_DWORD *)v4;
  *(_DWORD *)(a1 - 4) = 0;
  for ( i = v3 == 0; ; i = v3 == *(_DWORD *)v4 )
  {
    v3 = i ? 0 : *(_DWORD *)(v3 + 4);
    if ( !v3 )
      break;
    if ( *(_DWORD *)(v3 + 24) )
      continue;
    v7 = *(_DWORD *)(v3 - 44);
    v6 = *(_DWORD *)(a1 + 8);
    if ( v7 == v6 )
    {
LABEL_11:
      *(_DWORD *)(v3 + 24) = 1;
      sub_1002E4F8(v3 - 92, -999);
      sub_1002E597(0);
      continue;
    }
    if ( v6 )
    {
      v9 = 16 * *(_DWORD *)(v6 + 4) >> 4;
      if ( v9 == -1 )
        continue;
      v8 = 16 * *(_DWORD *)(v7 + 4) >> 4;
      if ( v8 <= v9 )
        continue;
    }
    else
    {
      v8 = 16 * *(_DWORD *)(v7 + 4) >> 4;
      if ( v8 == -1 )
        continue;
    }
    v10 = *(_DWORD *)(a1 - 16);
    if ( *(_DWORD *)(v10 + 60) == -1 || sub_1002EA04(v10, v7, v8) )
      goto LABEL_11;
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002BB6C();
  return sub_10035616(12);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002E684) --------------------------------------------------------
bool __cdecl sub_1002E684(int a1)
{
  bool result; // eax@1

  result = sub_10032DBB(*(_DWORD *)(a1 + 36));
  if ( !result )
  {
    sub_1002E7C5(*(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    *(_DWORD *)(a1 + 72) = 0;
  }
  return result;
}

//----- (1002E690) --------------------------------------------------------
char __thiscall sub_1002E690(int this, int a2)
{
  int v2; // edi@1
  int v3; // eax@2
  int v4; // edx@2
  char result; // al@5

  v2 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)this + 12) + 4 * *(_DWORD *)(this + 4));
  if ( v2 == 1
    || (v3 = *(_DWORD *)(*(_DWORD *)this + 12) + 4 * *(_DWORD *)(this + 4),
        v4 = *(_DWORD *)v3,
        *(_DWORD *)v3 = 1,
        v4 != v2) )
  {
    sub_1002E7E7(*(_DWORD *)this);
    result = 0;
  }
  else
  {
    if ( a2 )
      *(_DWORD *)a2 = v2;
    result = 1;
  }
  return result;
}

//----- (1002E6D7) --------------------------------------------------------
int __usercall sub_1002E6D7<eax>(int a1<ecx>, int a2<ebp>)
{
  int v3; // esi@1
  int v4; // ST0C_4@1
  int v5; // eax@1

  v3 = a1;
  sub_1002EDD5(a1, a2);
  v4 = *(_DWORD *)(v3 + 8);
  v5 = (*(int (**)(void))(**(_DWORD **)(v3 + 28) + 4))();
  return sub_1002F2FC(2, 4, v5, v4);
}

//----- (1002E6F8) --------------------------------------------------------
void __thiscall sub_1002E6F8(void *this)
{
  int ebp0; // ebp@0
  int v2; // edi@1
  int v3; // esi@2
  int v4; // [sp+8h] [bp-4h]@1

  v4 = 0;
  v2 = (int)((char *)this + 128);
  while ( 1 )
  {
    v3 = sub_1002EB4A(v2, (int)&v4);
    if ( !v3 )
      break;
    do
    {
      sub_1002D9FA(*(_DWORD *)(v3 + 8), ebp0);
      v3 = *(_DWORD *)v3;
    }
    while ( v3 );
    ++v4;
  }
  sub_1002F39B(v2);
}

//----- (1002E737) --------------------------------------------------------
BOOL __cdecl sub_1002E737()
{
  return TlsSetValue(dwTlsIndex, 0);
}

//----- (1002E746) --------------------------------------------------------
int __usercall sub_1002E746<eax>(int a1<ebx>, int a2<ebp>)
{
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // eax@1
  PSINGLE_LIST_ENTRY v5; // eax@2
  int v6; // edx@2
  void *v7; // ecx@2
  int v8; // edi@2
  int v9; // eax@5

  sub_10035648();
  v2 = v3;
  v4 = sub_10040F74(*(_DWORD *)(v3 + 24));
  *(_DWORD *)(v2 + 32) = v4;
  if ( !v4 )
  {
    v5 = InterlockedPopEntrySList((PSLIST_HEADER)(*(_DWORD *)(v2 + 24) + 88));
    v8 = 0;
    v7 = 0;
    if ( v5 )
      v7 = &v5[-6];
    *(_DWORD *)(v2 + 32) = v7;
    if ( v7 )
    {
      sub_100402A4(v7);
    }
    else
    {
      v9 = sub_1002ADB1(v6, 0, a1, 0, 116);
      *(_DWORD *)(a2 - 16) = v9;
      *(_DWORD *)(a2 - 4) = 0;
      if ( v9 )
        v8 = sub_100401C8(a2);
      *(_DWORD *)(a2 - 4) = -1;
      *(_DWORD *)(v2 + 32) = v8;
    }
    sub_1002E348(*(_DWORD *)(v2 + 24) + 88, *(_DWORD *)(v2 + 32));
  }
  *(_DWORD *)(*(_DWORD *)(v2 + 32) + 72) = v2;
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002E7C5) --------------------------------------------------------
int __stdcall sub_1002E7C5(int a1)
{
  int v1; // esi@1
  void *v2; // ecx@2
  int result; // eax@3

  v1 = a1;
  while ( v1 )
  {
    v2 = (void *)(v1 - 24);
    v1 = *(_DWORD *)v1;
    if ( v2 )
      result = sub_1002E31F(v2, 1);
  }
  return result;
}

//----- (1002E7E7) --------------------------------------------------------
int __thiscall sub_1002E7E7(int this)
{
  int result; // eax@1

  result = this + 20;
  _EDX = -1;
  __asm { lock xadd [eax], edx }
  if ( _ZF )
    result = sub_100333A7(this + 28, sub_1002EF7A, this, *(_DWORD *)this);
  return result;
}

//----- (1002E921) --------------------------------------------------------
void __cdecl sub_1002E921()
{
  JUMPOUT(*(int *)sub_1002E929);
}

//----- (1002E929) --------------------------------------------------------
int __usercall sub_1002E929<eax>(int a1<ebp>)
{
  return sub_1002BB74((void *)(*(_DWORD *)(a1 - 40) + 4));
}

//----- (1002E935) --------------------------------------------------------
void __usercall sub_1002E935(int a1<eax>, int a2<ebp>)
{
  LOBYTE(a1) = *(_BYTE *)(a2 - 26);
  *(_DWORD *)(a2 - 32) = a1;
  JUMPOUT(*(int *)sub_1002E940);
}

//----- (1002E940) --------------------------------------------------------
int __usercall sub_1002E940<eax>(int a1<ebp>, int a2<edi>)
{
  int result; // eax@2

  if ( *(_BYTE *)(a1 - 25) )
    result = sub_1002BB74((void *)(a2 + 84));
  return result;
}

//----- (1002E94F) --------------------------------------------------------
int __thiscall sub_1002E94F(int this)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 12) + 1;
  *(_DWORD *)(this + 12) = result;
  return result;
}

//----- (1002E957) --------------------------------------------------------
int __thiscall sub_1002E957(int this)
{
  int v1; // eax@1
  int result; // eax@1

  v1 = *(_DWORD *)(this + 16);
  ++*(_DWORD *)(this + 12);
  result = v1 + 1;
  *(_DWORD *)(this + 16) = result;
  return result;
}

//----- (1002E962) --------------------------------------------------------
int __thiscall sub_1002E962(int this)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 12) - 1;
  *(_DWORD *)(this + 12) = result;
  return result;
}

//----- (1002E96A) --------------------------------------------------------
int __thiscall sub_1002E96A(int this)
{
  int v1; // eax@1
  int result; // eax@1

  v1 = *(_DWORD *)(this + 16);
  --*(_DWORD *)(this + 12);
  result = v1 - 1;
  *(_DWORD *)(this + 16) = result;
  return result;
}

//----- (1002E975) --------------------------------------------------------
int __thiscall sub_1002E975(int this, int a2)
{
  int result; // eax@1
  int v3; // ebx@1
  signed int v4; // edi@1
  signed int i; // esi@1

  v3 = this;
  result = this + 140;
  v4 = *(_DWORD *)(this + 140);
  for ( i = 0; i < v4; result = v3 + 140 )
  {
    _ECX = sub_1002E2AC(result, i);
    if ( *(_DWORD *)(_ECX + 4) >= a2 )
    {
      if ( *(_DWORD *)(v3 + 60) == -1 || *(_DWORD *)(v3 + 60) <= a2 )
      {
        _EAX = 1;
        __asm { lock xadd [ecx], eax }
      }
    }
    ++i;
  }
  return result;
}

//----- (1002E9C1) --------------------------------------------------------
bool __thiscall sub_1002E9C1(int this)
{
  bool result; // eax@2

  if ( *(_DWORD *)(this + 16) )
    result = 2;
  else
    result = *(_DWORD *)(this + 12) > 0u;
  return result;
}

//----- (1002E9D5) --------------------------------------------------------
int __thiscall sub_1002E9D5(int this)
{
  return *(_DWORD *)(this + 8);
}

//----- (1002E9D9) --------------------------------------------------------
int __thiscall sub_1002E9D9(int this)
{
  return *(_DWORD *)(this + 124);
}

//----- (1002E9DD) --------------------------------------------------------
int __thiscall sub_1002E9DD(int this)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = *(_DWORD *)(this + 24);
  if ( v1 )
    result = *(_DWORD *)(v1 + 256);
  else
    result = 0;
  return result;
}

//----- (1002E9EE) --------------------------------------------------------
int __thiscall sub_1002E9EE(int this)
{
  int v1; // ecx@1
  int result; // eax@2

  v1 = *(_DWORD *)(this + 24);
  if ( v1 )
    result = (*(int (**)(void))(**(_DWORD **)(v1 + 256) + 4))();
  else
    result = -1;
  return result;
}

//----- (1002EA04) --------------------------------------------------------
char __thiscall sub_1002EA04(int this, int a2, int a3)
{
  int v3; // edi@1
  int v4; // eax@5
  int v5; // esi@5
  int v6; // ecx@7
  int v7; // ecx@8
  char v9; // al@16
  signed int v10; // eax@26

  v3 = this;
  if ( *(_DWORD *)(this + 112) <= 0 || *(_DWORD *)(this + 104) > a3 )
    return 0;
  if ( *(_DWORD *)(this + 60) == -1 || *(_DWORD *)(this + 104) >= *(_DWORD *)(this + 60) )
    return 1;
  v4 = *(_DWORD *)(this + 52);
  v5 = a2;
  if ( a2 != v4 || a3 != 16 * *(_DWORD *)(v4 + 4) >> 4 )
  {
    do
    {
      if ( v5 == *(_DWORD *)(v3 + 48) )
        break;
      if ( 16 * *(_DWORD *)(v5 + 4) >> 4 == a3 )
        break;
      v5 = sub_1002F423(v5);
    }
    while ( v5 );
    while ( v5 )
    {
      if ( v5 == *(_DWORD *)(v3 + 48) || sub_1003FF3B(v5, 0) )
      {
        if ( v5 )
        {
          if ( v5 != *(_DWORD *)(v3 + 48) )
          {
            v10 = sub_1003FF3B(v5, 0);
            if ( v10 != 2 )
            {
              v7 = *(_DWORD *)(v10 + 8);
              return v7 != 0;
            }
          }
        }
        return 0;
      }
      v9 = (*(_DWORD *)(v5 + 4) >> 28) & 1;
      if ( v9 && *(_BYTE *)(v5 + 24) & 3 || !v9 && sub_1002D907(v5) )
        return 1;
      v5 = sub_1002F423(v5);
    }
    return 0;
  }
  v6 = *(_DWORD *)(this + 56);
  if ( v6 == 2 )
    return 0;
  v7 = *(_DWORD *)(v6 + 8);
  return v7 != 0;
}

//----- (1002EAEE) --------------------------------------------------------
char __thiscall sub_1002EAEE(int this, int a2, char a3)
{
  char v3; // bl@1
  int v4; // esi@1

  v4 = this;
  v3 = 0;
  if ( *(_DWORD *)(this + 112) > 0 && !sub_1002F2AF((void *)this, a2, a3)
    || *(_DWORD *)(v4 + 120) > 0 && sub_10040095(a2) )
    v3 = 1;
  return v3;
}

//----- (1002EB27) --------------------------------------------------------
int __thiscall sub_1002EB27(int this, int a2)
{
  int v3; // edi@1

  v3 = this;
  sub_10034B9B((void *)(this + 112));
  *(_DWORD *)(v3 + 72) = a2;
  return sub_10034BAB((void *)(v3 + 112));
}

//----- (1002EB4A) --------------------------------------------------------
int __thiscall sub_1002EB4A(int this, int a2)
{
  int v2; // edx@1
  int v3; // eax@2
  int result; // eax@5

  v2 = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 >= *(_DWORD *)this )
  {
LABEL_5:
    result = 0;
  }
  else
  {
    v3 = *(_DWORD *)(this + 8) + 4 * v2;
    while ( !*(_DWORD *)v3 )
    {
      ++v2;
      v3 += 4;
      if ( v2 >= *(_DWORD *)this )
        goto LABEL_5;
    }
    *(_DWORD *)a2 = v2;
    result = *(_DWORD *)(*(_DWORD *)(this + 8) + 4 * v2);
  }
  return result;
}

//----- (1002EB7B) --------------------------------------------------------
int __usercall sub_1002EB7B<eax>(int a1<ecx>, int a2<ebp>)
{
  int v2; // edi@1
  int v3; // esi@2
  int v4; // ebx@3
  int result; // eax@6
  int v6; // ecx@9
  int v7; // ebx@9
  int v8; // edi@9
  int v9; // esi@9
  int v10; // ecx@9
  void *v11; // ecx@9
  int v12; // ecx@10
  int v13; // edx@10
  void *v14; // ecx@16

  v2 = a1 + 4;
  while ( 1 )
  {
    v3 = *(_DWORD *)v2-- - 1;
    if ( *(_DWORD *)a1 > v3 )
      break;
    v4 = *(_DWORD *)(*(_DWORD *)(a1 + 28) + 4 * (v3 & *(_DWORD *)(a1 + 8)));
    if ( v4 )
    {
      if ( !(v4 & 1) || (v4 &= 0xFFFFFFFEu, sub_1002E690(*(_DWORD *)(a1 + 32) + 8 * (v3 & *(_DWORD *)(a1 + 8)), 0)) )
        result = v4;
      else
        result = 1;
      return result;
    }
  }
  *(_DWORD *)v2 = v3 + 1;
  sub_10035648();
  v9 = v10;
  v11 = *(void **)(v10 + 16);
  *(_DWORD *)(a2 - 16) = v11;
  sub_10034B9B(v11);
  v6 = 0;
  v8 = *(_DWORD *)(v9 + 4) - 1;
  *(_DWORD *)(a2 - 24) = 0;
  *(_DWORD *)(a2 - 20) = 0;
  *(_DWORD *)(v9 + 4) = v8;
  *(_DWORD *)(a2 - 4) = 0;
  LOBYTE(v7) = 0;
  if ( *(_DWORD *)v9 > v8 )
  {
    *(_DWORD *)(v9 + 4) = v8 + 1;
  }
  else
  {
    v12 = *(_DWORD *)(v9 + 32);
    v13 = v8 & *(_DWORD *)(v9 + 8);
    v7 = *(_DWORD *)(*(_DWORD *)(v9 + 28) + 4 * v13);
    *(_DWORD *)(a2 - 24) = *(_DWORD *)(v12 + 8 * v13);
    *(_DWORD *)(a2 - 20) = *(_DWORD *)(v12 + 8 * v13 + 4);
    v6 = 0;
  }
  if ( *(_DWORD *)v9 >= v8 )
  {
    *(_DWORD *)(v9 + 12) += *(_DWORD *)v9;
    *(_DWORD *)v9 = v6;
    *(_DWORD *)(v9 + 4) = v6;
    *(_DWORD *)(v9 + 24) = v6;
    *(_BYTE *)(v9 + 20) = v6;
  }
  if ( v7 & 1 )
    sub_1002E690(a2 - 24, v6);
  v14 = *(void **)(a2 - 16);
  *(_DWORD *)(a2 - 4) = -1;
  sub_10034BAB(v14);
  return sub_10035616(12);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002EBD5) --------------------------------------------------------
int __thiscall sub_1002EBD5(int this)
{
  int v2; // edi@1
  int v3; // esi@1

  v2 = this;
  v3 = *(_DWORD *)(this + 36);
  TlsSetValue(dwTlsIndex, *(LPVOID *)(this + 36));
  *(_DWORD *)(v2 + 36) = 0;
  return v3;
}

//----- (1002EBF2) --------------------------------------------------------
int __thiscall sub_1002EBF2(int this, int a2)
{
  int result; // eax@1
  int v3; // edi@1
  int v4; // esi@1

  v3 = this;
  result = sub_1002F423(*(_DWORD *)(this + 52));
  v4 = result;
  if ( !result )
    goto LABEL_11;
  do
  {
    if ( v4 == *(_DWORD *)(v3 + 48) )
      break;
    result = sub_1003FF3B(v4, 0);
    if ( result )
      break;
    result = sub_1002F423(v4);
    v4 = result;
  }
  while ( result );
  if ( v4 && v4 != *(_DWORD *)(v3 + 48) )
  {
    *(_DWORD *)(v3 + 56) = sub_1003FF3B(v4, 0);
    result = 16 * *(_DWORD *)(v4 + 4) >> 4;
    *(_DWORD *)(v3 + 60) = result;
  }
  else
  {
LABEL_11:
    *(_DWORD *)(v3 + 56) = 0;
    *(_DWORD *)(v3 + 60) = -1;
  }
  return result;
}

//----- (1002EC53) --------------------------------------------------------
int __thiscall sub_1002EC53(int this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int result; // eax@2

  v3 = *(_DWORD *)(this + 4);
  v2 = *(_DWORD *)(this + 8);
  if ( v3 >= v2 + *(_DWORD *)this )
  {
    result = sub_1002F0B6((void *)this, a2, 0, 0);
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(this + 28) + 4 * (v3 & v2)) = a2;
    *(_DWORD *)(this + 4) = v3 + 1;
    result = v3 + *(_DWORD *)(this + 12);
  }
  return result;
}

//----- (1002EC99) --------------------------------------------------------
BOOL __thiscall sub_1002EC99(LPVOID lpTlsValue, int a2)
{
  *((_DWORD *)lpTlsValue + 9) = a2;
  return TlsSetValue(dwTlsIndex, lpTlsValue);
}

//----- (1002ECB3) --------------------------------------------------------
int __thiscall sub_1002ECB3(int this, int a2, int a3)
{
  int result; // eax@1

  *(_DWORD *)(this + 56) = a2;
  result = a3;
  *(_DWORD *)(this + 60) = a3;
  return result;
}

//----- (1002ECC6) --------------------------------------------------------
int __userpurge sub_1002ECC6<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int ebp0; // ebp@0
  int v4; // esi@1
  int v5; // edi@3
  int v6; // ST08_4@7

  v4 = a1;
  if ( !*(_DWORD *)(a1 + 32) )
    sub_1002E746(a2, ebp0);
  v5 = sub_1002EC53(*(_DWORD *)(v4 + 32) + 76, a3);
  if ( *(_BYTE *)(v4 + 76) )
    ++*(_DWORD *)(*(_DWORD *)(v4 + 156) + 8);
  else
    ++*(_DWORD *)(*(_DWORD *)(v4 + 156) + 92);
  if ( *(_DWORD *)(*(_DWORD *)(v4 + 28) + 428) - *(_DWORD *)(*(_DWORD *)(v4 + 28) + 432) > 0 )
    (*(void (__stdcall **)(_DWORD, _DWORD, int, _DWORD, _DWORD))(**(_DWORD **)(v4 + 28) + 56))(
      *(_DWORD *)(v4 + 24),
      0,
      v6,
      0,
      0);
  return v5;
}

//----- (1002ED43) --------------------------------------------------------
char __thiscall sub_1002ED43(int this)
{
  int v1; // ebx@1
  int v2; // edi@1
  int v3; // esi@1
  char v4; // al@3
  char result; // al@14
  int v9; // [sp+Ch] [bp-4h]@1

  v1 = this;
  v9 = this + 108;
  *(_DWORD *)(this + 108) = -1;
  v2 = *(_DWORD *)(this + 52);
  v3 = (*(_DWORD *)(this + 116) != 0 ? 0xFFFFFC1A : 0) - 1;
  while ( v2 && v2 != *(_DWORD *)(v1 + 48) )
  {
    v4 = (*(_DWORD *)(v2 + 4) >> 28) & 1;
    if ( v4 && *(_BYTE *)(v2 + 24) & 3 || !v4 && sub_1002D907(v2) )
    {
      v3 = 16 * *(_DWORD *)(v2 + 4) >> 4;
      break;
    }
    v2 = sub_1002F423(v2);
  }
  _EDI = v9;
  _ECX = v3;
  result = -1;
  __asm { lock cmpxchg [edi], ecx }
  return result;
}

//----- (1002EDCA) --------------------------------------------------------
int __thiscall sub_1002EDCA(void *this)
{
  int result; // eax@1

  _ECX = (int)((char *)this + 100);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (1002EDD5) --------------------------------------------------------
int __usercall sub_1002EDD5<eax>(int a1<ecx>, int a2<ebp>)
{
  int v2; // ecx@8
  int v4; // ST14_4@15
  int v5; // ST18_4@15
  int v6; // ST1C_4@15
  int v7; // ST20_4@15
  int v8; // ST24_4@15
  int v9; // ST28_4@15
  int v10; // ST2C_4@15
  int v11; // ST30_4@15
  int v12; // ST34_4@15
  int v13; // ST38_4@15
  int v14; // ST3C_4@15
  int v15; // ST40_4@15
  int v16; // ST44_4@15
  int v17; // ST48_4@15
  int v18; // ST4C_4@15
  int v19; // ST50_4@15
  int v20; // ST54_4@15
  int v21; // ST58_4@15
  int v22; // eax@16
  char v23; // al@18
  int v24; // esi@18
  int v25; // esi@19
  int v26; // eax@26
  bool v27; // eax@28
  int v28; // esi@29
  int v29; // edi@1
  int v30; // esi@1
  int v31; // edi@8
  int v32; // [sp+0h] [bp-8h]@8
  int v33; // [sp+4h] [bp-4h]@8

  v29 = a1;
  v30 = *(_DWORD *)(a1 + 32);
  if ( v30 )
  {
    *(_DWORD *)(a1 + 32) = 0;
    if ( *(_DWORD *)(v30 + 80) <= *(_DWORD *)(v30 + 76) )
    {
      if ( *(_DWORD *)(v30 + 112) )
        sub_1002EB27(v30, 0);
      else
        *(_DWORD *)(v30 + 72) = 0;
      sub_1002EE2C((void *)(*(_DWORD *)(v29 + 24) + 88), v30, *(_DWORD *)(v30 + 68), 1);
    }
    else
    {
      sub_1002EB27(v30, 0);
      sub_10040EAC(*(_DWORD *)(v29 + 24), v30);
    }
  }
  _SEH_prolog4(&unk_1006B170, 44);
  v31 = v2;
  *(_DWORD *)(a2 - 44) = v2;
  if ( *(_DWORD *)(v2 + 100) )
  {
    *(_DWORD *)(a2 - 52) = 0;
    *(_DWORD *)(a2 - 48) = sub_10034BF4;
    do
      sub_1002BC25((void *)(a2 - 60));
    while ( *(_DWORD *)(v31 + 100) );
  }
  if ( *(_DWORD *)(v31 + 132) > 0 )
    sub_1002E6F8((void *)v31);
  if ( *(_DWORD *)(v31 + 80) )
  {
    LOBYTE(v22) = 0;
    *(_BYTE *)(a2 - 26) = 0;
    while ( !(_BYTE)v22 )
    {
      *(_BYTE *)(a2 - 25) = 1;
      sub_1002B98A((void *)(v31 + 84));
      *(_DWORD *)(a2 - 4) = 0;
      v23 = 1;
      *(_BYTE *)(a2 - 25) = 1;
      v24 = *(_DWORD *)(v31 + 80);
      if ( v24 )
        v25 = *(_DWORD *)(v24 + 4);
      else
        v25 = 0;
      while ( v25 && v23 )
      {
        if ( v25 == *(_DWORD *)(v31 + 80) )
          *(_DWORD *)(a2 - 32) = 0;
        else
          *(_DWORD *)(a2 - 32) = *(_DWORD *)(v25 + 4);
        *(_DWORD *)(a2 - 36) = v25 - 92;
        v26 = sub_1002D819(*(void **)(v25 - 92 + 48));
        *(_DWORD *)(a2 - 40) = v26;
        if ( !sub_1002BCE1((void *)(v26 + 4)) )
        {
          sub_1002BB74((void *)(v31 + 84));
          *(_BYTE *)(a2 - 25) = 0;
          Sleep(1u);
          break;
        }
        *(_DWORD *)(a2 - 4) = 1;
        v28 = *(_DWORD *)(a2 - 36) + 92;
        sub_1002B26C((void *)(v31 + 80), v28);
        *(_BYTE *)(*(_DWORD *)(a2 - 36) + 77) = 0;
        sub_1002B23D(*(void **)(a2 - 40), v28);
        *(_DWORD *)(a2 - 4) = 0;
        v25 = *(_DWORD *)(a2 - 32);
        sub_1002E929(a2);
        v23 = *(_BYTE *)(a2 - 25);
      }
      v27 = v25 == 0;
      *(_DWORD *)(a2 - 32) = v27;
      *(_BYTE *)(a2 - 26) = v27;
      *(_DWORD *)(a2 - 4) = -2;
      sub_1002E940(a2, v31);
      v22 = *(_DWORD *)(a2 - 32);
    }
  }
  else
  {
    sub_1002BAED((void *)(v31 + 84));
  }
  return _SEH_epilog4(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v32, v33);
}
// 1003B240: using guessed type _DWORD __cdecl _SEH_prolog4(_DWORD, _DWORD);
// 1003B285: using guessed type int __stdcall _SEH_epilog4(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (1002EE2C) --------------------------------------------------------
char __thiscall sub_1002EE2C(void *ListHead, int a2, signed int a3, char a4)
{
  signed int v4; // edx@1
  int v6; // esi@1
  char result; // al@2
  int v8; // eax@3
  int v9; // ecx@3
  int v10; // edx@4
  int v11; // edi@4
  int v12; // edx@5
  PSINGLE_LIST_ENTRY v18; // eax@14
  int v19; // ST08_4@14

  v6 = (int)ListHead;
  v4 = a3 >> *((_DWORD *)ListHead + 11);
  _EBX = a3 & (*((_DWORD *)ListHead + 10) - 1);
  if ( v4 < *((_DWORD *)ListHead + 15) )
  {
    v9 = *((_DWORD *)ListHead + 14);
    v8 = *(_DWORD *)(v6 + 52);
    if ( v4 < v9 )
    {
      v11 = *(_DWORD *)(v8 + 4 * v4);
    }
    else
    {
      v10 = v4 - v9;
      v11 = *(_DWORD *)(v8 + 4 * v9 - 4);
      if ( v10 >= 0 )
      {
        v12 = v10 + 1;
        do
        {
          v11 = *(_DWORD *)(v11 + 4);
          --v12;
        }
        while ( v12 );
      }
    }
    _ECX = *(_DWORD *)v11 + 4 * _EBX;
    _EDX = 0;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 == a2 )
    {
      _ECX = v11 + 8;
      __asm { lock cmpxchg [ecx], ebx }
      if ( a4 )
      {
        if ( (signed int)QueryDepthSList((PSLIST_HEADER)v6) <= *(_DWORD *)(v6 + 68) )
        {
          InterlockedPushEntrySList((PSLIST_HEADER)v6, (PSINGLE_LIST_ENTRY)(a2 + 24));
        }
        else
        {
          InterlockedPushEntrySList((PSLIST_HEADER)(v6 + 8), (PSINGLE_LIST_ENTRY)(a2 + 24));
          if ( (signed int)QueryDepthSList((PSLIST_HEADER)(v6 + 8)) > *(_DWORD *)(v6 + 68) )
          {
            if ( !sub_10032DBB(*(_DWORD *)(v6 + 36)) )
            {
              _EDX = 1;
              _ECX = v6 + 72;
              __asm { lock cmpxchg [ecx], edx }
              v18 = InterlockedFlushSList((PSLIST_HEADER)(v6 + 8));
              v19 = *(_DWORD *)(v6 + 36);
              *(_DWORD *)(v6 + 16) = v18;
              sub_100333A7(v6 + 20, (int (__cdecl *)(_DWORD))sub_1002E684, v6, v19);
            }
          }
        }
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1002EF22) --------------------------------------------------------
int __thiscall sub_1002EF22(int this, int a2)
{
  int v3; // edi@1

  v3 = this;
  sub_1002B98A((void *)(this + 4));
  sub_1002B26C((void *)v3, a2);
  return sub_1002BB74((void *)(v3 + 4));
}

//----- (1002EF49) --------------------------------------------------------
int __thiscall sub_1002EF49(void *this, int a2)
{
  return sub_1002EF22((int)((char *)this + 80), a2 + 92);
}

//----- (1002EF5F) --------------------------------------------------------
BOOL __thiscall sub_1002EF5F(LPVOID lpTlsValue)
{
  return TlsSetValue(dwTlsIndex, lpTlsValue);
}

//----- (1002EF6D) --------------------------------------------------------
int __thiscall sub_1002EF6D(int this, int a2)
{
  int result; // eax@1

  result = a2;
  *(_DWORD *)(this + 124) = a2;
  return result;
}

//----- (1002EF7A) --------------------------------------------------------
int __cdecl sub_1002EF7A(int a1)
{
  int result; // eax@2

  if ( a1 )
  {
    sub_1002E271(a1);
    result = sub_1002A4AA((LPVOID)a1);
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002EF98) --------------------------------------------------------
char __thiscall sub_1002EF98(void *this)
{
  int v1; // eax@1
  int v2; // ebx@1
  int ebp0; // ebp@0
  int v4; // edi@1
  int v5; // esi@2
  int v6; // edi@5
  int v8; // [sp+8h] [bp-8h]@5
  int v9; // [sp+Ch] [bp-4h]@1

  v9 = 0;
  v2 = (int)((char *)this + 128);
  v1 = sub_1002EB4A((int)((char *)this + 128), (int)&v9);
  v4 = v1;
  if ( v1 )
  {
    do
    {
      v5 = *(_DWORD *)v4;
      if ( !*(_DWORD *)v4 )
      {
        ++v9;
        v5 = sub_1002EB4A(v2, (int)&v9);
      }
      LOBYTE(v1) = sub_1002D915(*(_DWORD *)(v4 + 8));
      if ( (_BYTE)v1 )
      {
        v6 = *(_DWORD *)(v4 + 8);
        v8 = sub_1002D9C0(v6);
        LOBYTE(v1) = sub_1002D0F4((unsigned int *)v2, (int)&v8, 0);
        if ( v6 )
        {
          sub_1002CFB4(ebp0);
          LOBYTE(v1) = sub_1002A4AA((LPVOID)v6);
        }
      }
      v4 = v5;
    }
    while ( v5 );
  }
  return v1;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002F014) --------------------------------------------------------
int __cdecl sub_1002F014(int (__cdecl *a1)(_DWORD, _DWORD), int a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  return sub_10040403(a1, a2, a3);
}

//----- (1002F0B6) --------------------------------------------------------
int __thiscall sub_1002F0B6(void *this, int a2, int a3, int a4)
{
  int v4; // eax@1
  int v5; // ebx@1
  int v6; // edi@1
  signed __int64 v8; // qax@1
  signed __int64 v10; // qax@1
  int v11; // edx@2
  int i; // ecx@2
  int v13; // edx@6
  int v14; // ebx@6
  void *v15; // esi@6
  int v16; // edx@7
  int v17; // ecx@8
  int v18; // edx@8
  int v19; // eax@8
  int v20; // ebx@12
  int v21; // edx@13
  int v22; // ecx@13
  int v23; // edx@13
  void *v25; // [sp+Ch] [bp-24h]@6
  void *v26; // [sp+10h] [bp-20h]@1
  int v27; // [sp+14h] [bp-1Ch]@1
  void *v28; // [sp+18h] [bp-18h]@6
  int v29; // [sp+1Ch] [bp-14h]@1
  int v30; // [sp+20h] [bp-10h]@1
  int v31; // [sp+24h] [bp-Ch]@6
  int v32; // [sp+28h] [bp-8h]@6
  int v33; // [sp+2Ch] [bp-4h]@1

  v6 = (int)this;
  _ECX = 0;
  v5 = 2 * (*(_DWORD *)(v6 + 8) + 1);
  v8 = 4i64 * (unsigned int)(2 * (*(_DWORD *)(v6 + 8) + 1));
  __asm { seto    cl }
  v29 = v6;
  v27 = v5;
  v30 = sub_1002965B(SHIDWORD(v8), v8 | -_ECX, v5, v6, v8 | -_ECX);
  v26 = *(void **)(v6 + 28);
  _ECX = 0;
  v10 = 8i64 * (unsigned int)v5;
  __asm { seto    cl }
  v4 = sub_1002965B(SHIDWORD(v10), v10 | -_ECX, v5, v6, v10 | -_ECX);
  v33 = v4;
  if ( v4 )
  {
    v11 = v5 - 1;
    for ( i = v4; v11 >= 0; --v11 )
    {
      *(_DWORD *)i = 0;
      *(_DWORD *)(i + 4) = 0;
      i += 8;
    }
  }
  else
  {
    v33 = 0;
  }
  v15 = *(void **)(v6 + 16);
  v25 = *(void **)(v6 + 32);
  v28 = *(void **)(v6 + 16);
  sub_10034B9B(v15);
  v32 = 0;
  v13 = *(_DWORD *)(v6 + 4) - *(_DWORD *)v6;
  v14 = *(_DWORD *)(v6 + 8) & *(_DWORD *)v6;
  v31 = v13;
  *(_DWORD *)(v6 + 12) = *(_DWORD *)(v6 + 12) - v14 - v13 + *(_DWORD *)(v6 + 4);
  *(_DWORD *)v6 = v14;
  *(_DWORD *)(v6 + 4) = v14 + v13;
  if ( v13 > 0 )
  {
    v16 = 0;
    do
    {
      *(_DWORD *)(v30 + 4 * v16) = *(_DWORD *)(*(_DWORD *)(v6 + 28) + 4 * (*(_DWORD *)(v6 + 8) & v14));
      v17 = *(_DWORD *)(v6 + 32);
      v18 = *(_DWORD *)(v6 + 8) & v14;
      *(_DWORD *)(v33 + 8 * v32) = *(_DWORD *)(v17 + 8 * v18);
      v19 = *(_DWORD *)(v17 + 8 * v18 + 4);
      v6 = v29;
      v16 = v32 + 1;
      *(_DWORD *)(v33 + 8 * (v32 + 1) - 4) = v19;
      ++v14;
      v32 = v16;
    }
    while ( v16 < v31 );
    v15 = v28;
    v13 = v31;
  }
  *(_DWORD *)(v6 + 28) = v30;
  *(_DWORD *)(v6 + 32) = v33;
  *(_DWORD *)(v6 + 12) += *(_DWORD *)v6;
  if ( *(_BYTE *)(v6 + 20) )
    *(_DWORD *)(v6 + 24) -= *(_DWORD *)v6;
  *(_DWORD *)(v6 + 8) = v27 - 1;
  *(_DWORD *)v6 = 0;
  *(_DWORD *)(v6 + 4) = v13;
  v20 = *(_DWORD *)(v6 + 4);
  if ( a3 )
  {
    v22 = *(_DWORD *)(v6 + 32);
    v23 = *(_DWORD *)(v6 + 8) & v20;
    *(_DWORD *)(v22 + 8 * v23) = a3;
    *(_DWORD *)(v22 + 8 * v23 + 4) = a4;
    v21 = a2 | 1;
  }
  else
  {
    v21 = a2;
  }
  *(_DWORD *)(*(_DWORD *)(v6 + 28) + 4 * (*(_DWORD *)(v6 + 8) & v20)) = v21;
  *(_DWORD *)(v6 + 4) = v20 + 1;
  sub_10034BAB(v15);
  sub_100303A3(v26);
  sub_100303A3(v25);
  return *(_DWORD *)(v6 + 12) - 1 + *(_DWORD *)(v6 + 4);
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (1002F23E) --------------------------------------------------------
int __cdecl sub_1002F23E(char a1, char a2, int a3, int a4)
{
  int v4; // ebx@1
  int result; // eax@2
  __int16 v6; // [sp+4h] [bp-40h]@2
  char v7; // [sp+6h] [bp-3Eh]@2
  char v8; // [sp+8h] [bp-3Ch]@2
  char v9; // [sp+9h] [bp-3Bh]@2
  int v10; // [sp+1Ch] [bp-28h]@2
  int v11; // [sp+20h] [bp-24h]@2
  int v12; // [sp+24h] [bp-20h]@2
  int v13; // [sp+28h] [bp-1Ch]@2
  int v14; // [sp+30h] [bp-14h]@2
  int v15; // [sp+38h] [bp-Ch]@2
  int v16; // [sp+3Ch] [bp-8h]@2

  v4 = dword_100755B8;
  if ( dword_100755B8 )
  {
    sub_100391F0(&v7, 0, 62);
    v14 = 131072;
    v6 = 64;
    v8 = a1;
    v9 = a2;
    v10 = dword_10067304[0];
    v11 = dword_10067304[1];
    v12 = dword_10067304[2];
    v13 = dword_10067304[3];
    v15 = a3;
    v16 = a4;
    result = sub_10030F55(v4, dword_100755B0, dword_100755B4, (int)&v6);
  }
  return result;
}
// 100755B0: using guessed type int dword_100755B0;
// 100755B4: using guessed type int dword_100755B4;
// 100755B8: using guessed type int dword_100755B8;

//----- (1002F2AF) --------------------------------------------------------
char __thiscall sub_1002F2AF(void *this, int a2, char a3)
{
  void *v3; // esi@1
  signed int v4; // eax@2
  char result; // al@4
  int v6; // eax@5
  int v7; // ecx@7

  v3 = this;
  if ( a3 )
  {
    v4 = sub_1003FF3B(a2, 0);
    if ( v4 == 2 || !*(_DWORD *)(v4 + 8) )
      return 1;
  }
  v6 = *((_DWORD *)v3 + 15);
  if ( *((_DWORD *)v3 + 27) >= v6 || v6 == -1 )
  {
    result = 0;
  }
  else
  {
    v7 = *((_DWORD *)v3 + 14);
    if ( v7 == 2 )
      return 1;
    result = *(_DWORD *)(v7 + 8) == 0;
  }
  return result;
}

//----- (1002F2FC) --------------------------------------------------------
int __stdcall sub_1002F2FC(char a1, char a2, int a3, int a4)
{
  int result; // eax@2

  if ( a2 <= (unsigned __int8)byte_100755AC )
  {
    result = dword_100755A8;
    if ( dword_100755A8 & 2 )
      result = sub_1002F23E(a1, a2, a3, a4);
  }
  return result;
}
// 100755A8: using guessed type int dword_100755A8;
// 100755AC: using guessed type char byte_100755AC;

//----- (1002F329) --------------------------------------------------------
int __thiscall sub_1002F329(int this, int a2)
{
  int ebp0; // ebp@0
  int v3; // esi@1
  int result; // eax@2
  int v5; // ebx@5
  int v6; // eax@5

  v3 = a2 - *(_DWORD *)(this + 12);
  if ( v3 == *(_DWORD *)(this + 4) - 1 )
  {
    result = sub_1002EB7B(this, ebp0);
  }
  else
  {
    if ( v3 >= *(_DWORD *)(this + 4) || v3 < *(_DWORD *)this )
    {
      result = 0;
    }
    else
    {
      v6 = *(_DWORD *)(this + 28) + 4 * (v3 & *(_DWORD *)(this + 8));
      v5 = *(_DWORD *)v6;
      *(_DWORD *)v6 = 0;
      if ( !(v5 & 1) || (v5 &= 0xFFFFFFFEu, sub_1002E690(*(_DWORD *)(this + 32) + 8 * (v3 & *(_DWORD *)(this + 8)), 0)) )
        result = v5;
      else
        result = 1;
    }
  }
  return result;
}

//----- (1002F38C) --------------------------------------------------------
int __thiscall sub_1002F38C(int this, int a2)
{
  return sub_1002F329(*(_DWORD *)(this + 32) + 76, a2);
}

//----- (1002F39B) --------------------------------------------------------
void __thiscall sub_1002F39B(int this)
{
  int v1; // edi@1
  int v2; // ebx@2
  void *v3; // eax@3
  void *v4; // esi@4
  int v5; // eax@6

  v1 = this;
  if ( *(_DWORD *)(this + 4) > 0 )
  {
    v2 = 0;
    if ( *(_DWORD *)this > 0 )
    {
      do
      {
        v3 = *(void **)(*(_DWORD *)(v1 + 8) + 4 * v2);
        if ( v3 )
        {
          do
          {
            v4 = *(void **)v3;
            sub_1002A4AA(v3);
            v3 = v4;
          }
          while ( v4 );
        }
        ++v2;
      }
      while ( v2 < *(_DWORD *)v1 );
    }
    v5 = *(_DWORD *)v1;
    *(_DWORD *)(v1 + 4) = 0;
    sub_100391F0(*(void **)(v1 + 8), 0, 4 * v5);
  }
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002F3E5) --------------------------------------------------------
int __thiscall sub_1002F3E5(int this, int a2)
{
  int result; // eax@1

  *(_DWORD *)this ^= (*(_DWORD *)this ^ *(_DWORD *)a2) & 0xFFFFFFF;
  *(_DWORD *)this = *(_DWORD *)a2 ^ (*(_DWORD *)this ^ *(_DWORD *)a2) & 0xFFFFFFF;
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  result = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(this + 12) = result;
  return result;
}

//----- (1002F41A) --------------------------------------------------------
char *__usercall sub_1002F41A<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  return (char *)sub_1002B771(a1, a2, a3) + 64;
}

//----- (1002F423) --------------------------------------------------------
int __thiscall sub_1002F423(int this)
{
  int result; // eax@2

  if ( (*(_DWORD *)(this + 4) & 0xFFFFFFF) == 268435455 )
    result = 0;
  else
    result = *(_DWORD *)this;
  return result;
}

//----- (1002F437) --------------------------------------------------------
int __userpurge sub_1002F437<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4)
{
  int v4; // eax@1
  int v5; // esi@1
  int v6; // ecx@1
  int v7; // edx@1
  int v8; // ecx@2

  sub_100356B1();
  v5 = v6;
  *(_DWORD *)(a2 - 4) = 0;
  v4 = sub_1002ADB1(v7, v6, a1, a3, 16);
  if ( v4 )
  {
    *(_DWORD *)(v4 + 4) = 1;
    *(_DWORD *)(v4 + 8) = 1;
    v8 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)v4 = off_10060CBC;
    *(_DWORD *)(v4 + 12) = v8;
  }
  else
  {
    v8 = *(_DWORD *)(a2 + 8);
    v4 = 0;
  }
  sub_1002FBE7(v5, v8, v4);
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 10060CBC: using guessed type int (*off_10060CBC[2])();

//----- (1002F482) --------------------------------------------------------
void __usercall sub_1002F482(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  void *v3; // esi@1

  v3 = *(void **)(a2 + 8);
  if ( v3 )
  {
    sub_1002F6D1(*(_DWORD *)(a2 + 8), a1, a3);
    sub_1002A4AA(v3);
  }
  sub_100355BB(0, 0);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_1002F4A1);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002F4A1) --------------------------------------------------------
int __userpurge sub_1002F4A1<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4, int a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // esi@1
  int v8; // ecx@1
  unsigned int v9; // eax@1
  int v10; // edx@1
  int v11; // eax@2

  sub_100356B1();
  v7 = v8;
  *(_DWORD *)(a2 - 4) = 0;
  v9 = sub_1002FDF7(v10, a2 - 17, a1, 1u);
  v6 = *(_DWORD *)(a2 + 8);
  v5 = v9;
  if ( v9 )
  {
    v11 = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(v5 + 4) = 1;
    *(_DWORD *)(v5 + 8) = 1;
    *(_DWORD *)v5 = &off_10060CD0;
    *(_DWORD *)(v5 + 12) = v6;
    *(_DWORD *)(v5 + 16) = v11;
  }
  sub_1002FBE7(v7, v6, v5);
  return sub_10035616(8);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 10060CD0: using guessed type int (*off_10060CD0)();

//----- (1002F4EE) --------------------------------------------------------
void __usercall sub_1002F4EE(int a1<ebp>)
{
  (*(void (__cdecl **)(_DWORD))(a1 + 12))(*(_DWORD *)(a1 + 8));
  sub_100355BB(0, 0);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_1002F4FF);
}

//----- (1002F4FF) --------------------------------------------------------
int __userpurge sub_1002F4FF<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  int result; // eax@1
  void *v5; // ecx@1
  int ebp0; // ebp@0
  int v7; // esi@1

  v7 = a1;
  sub_1002F437(a2, ebp0, a3, a4);
  v5 = *(void **)(v7 + 4);
  *(_DWORD *)(v7 + 4) = 0;
  result = 0;
  *(_DWORD *)v7 = 0;
  if ( v5 )
    result = sub_1000AA70(v5);
  return result;
}

//----- (1002F536) --------------------------------------------------------
int __userpurge sub_1002F536<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, int a5)
{
  int result; // eax@1
  void *v6; // ecx@1
  int ebp0; // ebp@0
  int v8; // esi@1

  v8 = a1;
  sub_1002F4A1(a2, ebp0, a3, a4, a1);
  v6 = *(void **)(v8 + 4);
  *(_DWORD *)(v8 + 4) = 0;
  result = 0;
  *(_DWORD *)v8 = 0;
  if ( v6 )
    result = sub_1000AA70(v6);
  return result;
}

//----- (1002F572) --------------------------------------------------------
int __thiscall sub_1002F572(int this, int a2, char a3)
{
  int v3; // edx@1
  int v4; // ebx@1
  int ebp0; // ebp@0
  unsigned int v6; // edi@1
  int v7; // esi@1
  int v8; // eax@1
  int v9; // edx@2
  unsigned int v10; // eax@6
  int v11; // eax@10
  int v12; // edi@14
  int v13; // eax@16
  int v14; // edx@18
  int v15; // ecx@18
  PVOID v16; // eax@18
  char v17; // zf@18
  int v18; // eax@19
  int v20; // ecx@25
  int v21; // esi@25
  int v22; // [sp-4h] [bp-20h]@18
  int (__stdcall **v23)(char); // [sp+Ch] [bp-10h]@24
  int v24; // [sp+18h] [bp-4h]@25
  _DWORD *v25; // [sp+1Ch] [bp+0h]@25

  v3 = 0;
  v4 = a2;
  v7 = this;
  *(_BYTE *)(this + 80) = a3;
  *(_DWORD *)this = *(_DWORD *)a2;
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  v8 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(this + 16) = v8;
  v6 = 0;
  if ( v8 )
  {
    v9 = this + 20;
    do
    {
      if ( v6 >= 0xF )
        break;
      *(_DWORD *)v9 = *(_DWORD *)(a2 - this + v9);
      ++v6;
      v9 += 4;
    }
    while ( v6 < *(_DWORD *)(this + 16) );
    v4 = a2;
    v3 = 0;
  }
  v10 = *(_DWORD *)(this + 16);
  if ( v10 < 0xF )
    memset((void *)(this + 20 + 4 * v10), 0, 4 * (15 - v10));
  if ( *(_DWORD *)v4 != -529697949
    || *(_DWORD *)(v4 + 16) != 3
    || (v11 = *(_DWORD *)(v4 + 20), v11 != 429065504) && v11 != 429065505 && v11 != 429065506 && v11 != 26820608 )
    return v7;
  *(_DWORD *)(this + 24) = v3;
  v12 = *(_DWORD *)(v4 + 28);
  if ( *(_DWORD *)(v4 + 24) != v3 )
  {
    if ( v12 )
    {
      v13 = *(_DWORD *)(v12 + 12);
      if ( v13 )
      {
        if ( *(_DWORD *)v13 > v3 )
        {
          v16 = EncodePointer(*(PVOID *)(v4 + 28));
          v17 = a3 == 0;
          *(_DWORD *)(v7 + 28) = v16;
          a2 = *(_DWORD *)(*(_DWORD *)(v12 + 12) + 4);
          v22 = *(_DWORD *)(a2 + 20);
          if ( v17 )
            v18 = sub_10037530(v14, v15, v4, v22);
          else
            v18 = sub_10030930(v14, v15, v4, v12, v22);
          v12 = v18;
          if ( v18 )
          {
            sub_1002F851(ebp0, v18, *(_DWORD *)(v4 + 24), *(_DWORD *)(a2 + 20), a2);
            *(_DWORD *)(v7 + 24) = v12;
            return v7;
          }
          *(_DWORD *)&a3 = "bad allocation";
          sub_1002AEC9((int)&v23, (int)&a3, 1);
          v23 = &off_1005F2C4;
          sub_100355BB((int)&v23, (int)&unk_1006AA70);
        }
      }
    }
  }
  sub_1003B46D(v4, v12);
  __asm { int     3               ; Trap to Debugger }
  v25 = &v25;
  v24 = v7;
  v21 = v20;
  sub_1002AEE4(v20, v4, a2);
  *(_DWORD *)v21 = &off_10060C58;
  return v21;
}
// 1005F2C4: using guessed type int (__stdcall *off_1005F2C4)(char);
// 10060C58: using guessed type int (__stdcall *off_10060C58)(char);

//----- (1002F6D1) --------------------------------------------------------
void __usercall sub_1002F6D1(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // esi@1
  int v4; // eax@3
  PVOID v5; // eax@7
  PVOID v6; // edx@7
  int v7; // ecx@8
  int v8; // eax@9
  int v9; // ecx@12
  int v10; // ecx@16

  v3 = a1;
  if ( *(_DWORD *)a1 == -529697949 )
  {
    if ( *(_DWORD *)(a1 + 16) == 3 )
    {
      v4 = *(_DWORD *)(a1 + 20);
      if ( v4 == 429065504 || v4 == 429065505 || v4 == 429065506 || v4 == 26820608 )
      {
        v5 = DecodePointer(*(PVOID *)(a1 + 28));
        v6 = v5;
        if ( v5 )
        {
          v7 = *(_DWORD *)(v3 + 24);
          if ( v7 )
          {
            v8 = *(_DWORD *)(*((_DWORD *)v5 + 3) + 4);
            if ( *((_DWORD *)v6 + 1) )
            {
              sub_1003584C(v7, *((_DWORD *)v6 + 1));
            }
            else
            {
              if ( *(_BYTE *)v8 & 8 )
              {
                v9 = *(_DWORD *)v7;
                if ( v9 )
                  (*(void (__stdcall **)(int))(*(_DWORD *)v9 + 8))(v9);
              }
            }
          }
          sub_100309C2(a2, *(LPVOID *)(v3 + 24));
        }
        else
        {
          sub_1003B46D(a2, a3);
          __asm { int     3               ; Trap to Debugger }
          *(_DWORD *)v10 = &off_10060C58;
          sub_1002AF18(v10, a2);
        }
      }
    }
  }
}
// 1003584C: using guessed type _DWORD __cdecl sub_1003584C(_DWORD, _DWORD);
// 10060C58: using guessed type int (__stdcall *off_10060C58)(char);

//----- (1002F75B) --------------------------------------------------------
void *__thiscall sub_1002F75B(void *this, int a2)
{
  void *v2; // ecx@1
  void *v3; // esi@1
  int v5; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@1

  v5 = 0;
  v6 = 0;
  v3 = this;
  sub_1002F7FF((int)&v5, a2);
  v2 = (void *)*((_DWORD *)v3 + 1);
  *((_DWORD *)v3 + 1) = v6;
  *(_DWORD *)v3 = v5;
  if ( v2 )
    sub_1000AA70(v2);
  return v3;
}

//----- (1002F794) --------------------------------------------------------
void *__thiscall sub_1002F794(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_10060C64;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10060C64: using guessed type int (*off_10060C64[2])();

//----- (1002F7B4) --------------------------------------------------------
int __thiscall sub_1002F7B4(int this, char a2)
{
  void *v2; // ecx@1
  int v3; // esi@1

  v3 = this;
  v2 = *(void **)(this + 4);
  if ( v2 )
    sub_1000AA70(v2);
  if ( a2 & 1 )
    sub_1002A4AA((LPVOID)v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002F7DA) --------------------------------------------------------
void *__userpurge sub_1002F7DA<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  *(_DWORD *)a1 = &off_10060C58;
  sub_1002AF18(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10060C58: using guessed type int (__stdcall *off_10060C58)(char);

//----- (1002F7FF) --------------------------------------------------------
int __thiscall sub_1002F7FF(int this, int a2)
{
  int v2; // esi@1
  int result; // eax@2
  int v4; // edx@2
  int v5; // ecx@2

  v2 = this;
  if ( this != a2 )
  {
    v4 = *(_DWORD *)(this + 4);
    *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a2 + 4) = v4;
    result = *(_DWORD *)a2;
    v5 = *(_DWORD *)this;
    *(_DWORD *)v2 = *(_DWORD *)a2;
    *(_DWORD *)a2 = v5;
  }
  return result;
}

//----- (1002F827) --------------------------------------------------------
int __cdecl sub_1002F827(int a1)
{
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  sub_1002FC09(a1, dword_10075270, dword_10075274);
  return a1;
}
// 10075270: using guessed type int dword_10075270;
// 10075274: using guessed type int dword_10075274;

//----- (1002F851) --------------------------------------------------------
int __userpurge sub_1002F851<eax>(int a1<ebp>, int a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  int v6; // edi@6
  int v8; // [sp-8h] [bp-8h]@4

  sub_100356B1();
  v5 = *(_DWORD *)(a1 + 20);
  if ( *(_BYTE *)v5 & 1 || !*(_DWORD *)(v5 + 24) )
  {
    v6 = *(_DWORD *)(a1 + 12);
    sub_10034EE0(*(void **)(a1 + 8), *(const void **)(a1 + 12), *(_DWORD *)(a1 + 16));
    if ( *(_BYTE *)v5 & 8 )
    {
      if ( *(_DWORD *)v6 )
        (*(void (__cdecl **)(_DWORD, signed int))(**(_DWORD **)v6 + 4))(*(_DWORD *)v6, 4);
    }
  }
  else
  {
    *(_DWORD *)(a1 - 4) = 0;
    if ( *(_BYTE *)v5 & 4 )
    {
      v8 = 1;
      sub_100363B0(*(_DWORD *)(a1 + 12), v5 + 8);
      sub_1003584C(*(_DWORD *)(a1 + 8), *(_DWORD *)(v5 + 24));
    }
    else
    {
      v8 = sub_100363B0(*(_DWORD *)(a1 + 12), v5 + 8);
      sub_1003584C(*(_DWORD *)(a1 + 8), *(_DWORD *)(v5 + 24));
    }
  }
  return sub_10035616(v8);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 1003584C: using guessed type _DWORD __cdecl sub_1003584C(_DWORD, _DWORD);

//----- (1002F8DB) --------------------------------------------------------
int __usercall sub_1002F8DB<eax>(int a1<ebp>)
{
  int v1; // eax@1
  int v2; // edx@1
  int v3; // ecx@1
  char v4; // zf@7
  int v5; // eax@8
  int v6; // eax@9
  int v7; // eax@12
  int v8; // ecx@12
  int v9; // eax@13
  void *v10; // ecx@16
  int v11; // esi@16

  sub_100356B1();
  v1 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 - 20) = 0;
  v3 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 - 4) = 1;
  *(_DWORD *)(a1 - 72) = -529697949;
  *(_DWORD *)(a1 - 68) = 1;
  *(_DWORD *)(a1 - 64) = 0;
  *(_DWORD *)(a1 - 60) = 0;
  *(_DWORD *)(a1 - 56) = 3;
  *(_DWORD *)(a1 - 52) = 429065504;
  *(_DWORD *)(a1 - 48) = v3;
  if ( v1 )
  {
    if ( *(_BYTE *)v1 & 0x10 )
      v1 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v3 - 4) + 24);
  }
  *(_DWORD *)(a1 - 44) = v1;
  if ( v1 )
  {
    if ( *(_BYTE *)v1 & 8 )
      *(_DWORD *)(a1 - 52) = 26820608;
  }
  *(_DWORD *)(a1 - 28) = 0;
  *(_DWORD *)(a1 - 24) = 0;
  v4 = *(_BYTE *)(a1 + 20) == 0;
  *(_BYTE *)(a1 - 4) = 2;
  if ( v4 )
  {
    v7 = sub_1002FE69(v2, a1 + 23, 1, 1u);
    *(_DWORD *)(a1 + 20) = v7;
    *(_DWORD *)(a1 + 12) = v7;
    *(_BYTE *)(a1 - 4) = 4;
    if ( v7 )
      v9 = sub_1002F572(v7, a1 - 72, 0);
    else
      v9 = 0;
    *(_BYTE *)(a1 - 4) = 2;
    sub_1002F536(a1 - 28, 1, v9, (int)sub_1002FB18, v8);
  }
  else
  {
    v5 = sub_1002ADB1(v2, v3, 1, 0, 84);
    *(_DWORD *)(a1 + 20) = v5;
    *(_BYTE *)(a1 - 4) = 3;
    if ( v5 )
      v6 = sub_1002F572(v5, a1 - 72, 1);
    else
      v6 = 0;
    *(_BYTE *)(a1 - 4) = 2;
    sub_1002F4FF(a1 - 28, 1, 0, v6);
  }
  v11 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)v11 = 0;
  *(_DWORD *)(v11 + 4) = 0;
  sub_1002F7FF(v11, a1 - 28);
  v10 = *(void **)(a1 - 24);
  *(_DWORD *)(a1 - 20) = 1;
  *(_BYTE *)(a1 - 4) = 1;
  if ( v10 )
    sub_1000AA70(v10);
  return sub_10035616(60);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002F9E6) --------------------------------------------------------
int (*__usercall sub_1002F9E6<eax>(int a1<ebx>, int a2<ebp>))()
{
  int v3; // ST00_4@1

  v3 = *(_DWORD *)(a2 + 8);
  *(_BYTE *)(a2 - 4) = 6;
  sub_1002F827(v3);
  *(_DWORD *)(a2 - 40) = &off_1005F2C4;
  sub_1002AF18(a2 - 40, a1);
  return loc_1002FA08;
}
// 1002FA08: using guessed type int loc_1002FA08();
// 1005F2C4: using guessed type int (__stdcall *off_1005F2C4)(char);

//----- (1002FA0D) --------------------------------------------------------
void __usercall sub_1002FA0D(int a1<ebx>, int a2<edi>)
{
  sub_1003B46D(a1, a2);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_1002FA13);
}

//----- (1002FA13) --------------------------------------------------------
int __usercall sub_1002FA13<eax>(int a1<ebp>)
{
  int v1; // edx@4
  int v2; // ecx@4
  int v3; // esi@5
  int v4; // eax@6
  int v5; // eax@6
  void *v6; // ecx@8
  int v7; // esi@8
  int v8; // eax@11

  sub_100356B1();
  *(_DWORD *)(a1 - 20) = 0;
  *(_DWORD *)(a1 - 4) = 1;
  if ( !*(_DWORD *)(sub_10041952(1, 0) + 136)
    || *(_DWORD *)(sub_10041952(1, 0) + 144)
    || **(_DWORD **)(sub_10041952(1, 0) + 136) == -532459699
    || **(_DWORD **)(sub_10041952(1, 0) + 136) == -532462766 )
  {
    v8 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)v8 = 0;
    *(_DWORD *)(v8 + 4) = 0;
  }
  else
  {
    v3 = sub_1002ADB1(v1, v2, 1, 0, 84);
    *(_DWORD *)(a1 - 24) = v3;
    *(_BYTE *)(a1 - 4) = 2;
    if ( v3 )
    {
      v5 = sub_10041952(1, 0);
      v4 = sub_1002F572(v3, *(_DWORD *)(v5 + 136), 1);
    }
    else
    {
      v4 = 0;
    }
    *(_BYTE *)(a1 - 4) = 1;
    *(_DWORD *)(a1 - 28) = 0;
    *(_DWORD *)(a1 - 24) = 0;
    sub_1002F437(1, a1, 0, v4);
    v7 = *(_DWORD *)(a1 + 8);
    *(_DWORD *)v7 = 0;
    *(_DWORD *)(v7 + 4) = 0;
    sub_1002F7FF(v7, a1 - 28);
    v6 = *(void **)(a1 - 24);
    *(_DWORD *)(a1 - 20) = 1;
    if ( v6 )
      sub_1000AA70(v6);
  }
  return sub_10035616(28);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002FB18) --------------------------------------------------------
void __usercall sub_1002FB18(int a1<ebx>, int a2<edi>, LPVOID lpMem)
{
  sub_1002F6D1((int)lpMem, a1, a2);
  sub_100309C2(a1, lpMem);
}

//----- (1002FB29) --------------------------------------------------------
int __thiscall sub_1002FB29(void *this)
{
  int result; // eax@2

  if ( this )
    result = (*(int (__stdcall **)(_DWORD))(*(_DWORD *)this + 8))(1);
  return result;
}

//----- (1002FB35) --------------------------------------------------------
void __usercall sub_1002FB35(LPVOID lpMem<ecx>, int a2<ebx>)
{
  void *v2; // esi@1

  v2 = lpMem;
  (*(void (__stdcall **)(_DWORD))(*(_DWORD *)lpMem + 8))(0);
  sub_100309C2(a2, v2);
}

//----- (1002FB48) --------------------------------------------------------
int __usercall sub_1002FB48<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  void *v3; // esi@1
  int result; // eax@2

  v3 = *(void **)(a1 + 12);
  if ( v3 )
  {
    sub_1002F6D1(*(_DWORD *)(a1 + 12), a2, a3);
    result = sub_1002A4AA(v3);
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1002FB60) --------------------------------------------------------
int __thiscall sub_1002FB60(int this)
{
  return (*(int (__cdecl **)(_DWORD))(this + 16))(*(_DWORD *)(this + 12));
}

//----- (1002FB68) --------------------------------------------------------
int __thiscall sub_1002FB68(void *this, void *a2)
{
  return sub_1002CAFA(a2, (int)&off_100728C4) != 0 ? (int)((char *)this + 16) : 0;
}
// 100728C4: using guessed type int (__stdcall **off_100728C4)(char);

//----- (1002FB8C) --------------------------------------------------------
#error "1002FBE1: call analysis failed (funcsize=26)"

//----- (1002FBE7) --------------------------------------------------------
int __thiscall sub_1002FBE7(int this, int a2, int a3)
{
  void *v3; // ecx@1
  int v4; // esi@1
  int result; // eax@3

  v4 = this;
  v3 = *(void **)(this + 4);
  if ( v3 )
    sub_1000AA70(v3);
  *(_DWORD *)(v4 + 4) = a3;
  result = a2;
  *(_DWORD *)v4 = a2;
  return result;
}

//----- (1002FC09) --------------------------------------------------------
int __thiscall sub_1002FC09(int this, int a2, int a3)
{
  if ( a3 )
  {
    _EAX = a3 + 4;
    _EDX = 1;
    __asm { lock xadd [eax], edx }
  }
  return sub_1002FBE7(this, a2, a3);
}

//----- (1002FC2C) --------------------------------------------------------
void __usercall sub_1002FC2C(const void *a1<ecx>, int a2<edi>)
{
  int v2; // ebx@1
  int ebp0; // ebp@0
  signed int v4; // eax@2
  DWORD v5; // edx@2
  PVOID v6; // eax@8
  int v7; // ecx@10
  int v8; // esi@12
  char v9; // [sp+0h] [bp-70h]@12
  int (__stdcall **v10)(char); // [sp+Ch] [bp-64h]@16
  int v11; // [sp+18h] [bp-58h]@16
  DWORD dwExceptionCode; // [sp+1Ch] [bp-54h]@2
  DWORD dwExceptionFlags; // [sp+20h] [bp-50h]@15
  DWORD nNumberOfArguments; // [sp+2Ch] [bp-44h]@2
  ULONG_PTR Arguments; // [sp+30h] [bp-40h]@4
  int v16; // [sp+34h] [bp-3Ch]@8
  PVOID Ptr; // [sp+38h] [bp-38h]@8
  unsigned int v18; // [sp+6Ch] [bp-4h]@1
  int v19; // [sp+70h] [bp+0h]@1

  v18 = (unsigned int)&v19 ^ __security_cookie;
  v2 = (int)a1;
  if ( !a1 )
  {
    v11 = (int)"bad exception";
    sub_1002AEA4((int)&v10, &v11);
    v10 = &off_10060C58;
    sub_100355BB((int)&v10, (int)&unk_1006B434);
    goto LABEL_17;
  }
  memcpy(&dwExceptionCode, a1, 0x50u);
  a2 = (int)&v18;
  v5 = dwExceptionCode;
  v4 = nNumberOfArguments;
  if ( dwExceptionCode != -529697949 || nNumberOfArguments != 3 )
    goto LABEL_13;
  if ( Arguments == 429065504 || Arguments == 429065505 || Arguments == 429065506 || Arguments == 26820608 )
  {
    v6 = DecodePointer(Ptr);
    if ( v16 )
    {
      if ( v6 )
      {
        v7 = *((_DWORD *)v6 + 3);
        if ( v7 )
        {
          if ( *(_DWORD *)v7 > 0 )
          {
            Ptr = v6;
            v8 = *(_DWORD *)(*((_DWORD *)v6 + 3) + 4);
            sub_1003F580(*(_DWORD *)(v8 + 20), v7, v9);
            sub_1002F851(ebp0, (int)&v9, v16, *(_DWORD *)(v8 + 20), v8);
            v4 = nNumberOfArguments;
            v5 = dwExceptionCode;
            v16 = (int)&v9;
LABEL_13:
            if ( (unsigned int)v4 > 0xF )
            {
              v4 = 15;
              nNumberOfArguments = 15;
            }
            goto LABEL_15;
          }
        }
      }
    }
LABEL_17:
    sub_1003B46D(v2, a2);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1002FD39);
  }
LABEL_15:
  RaiseException(v5, dwExceptionFlags, v4, &Arguments);
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);
// 10060C58: using guessed type int (__stdcall *off_10060C58)(char);
// 10073200: using guessed type int __security_cookie;

//----- (1002FD39) --------------------------------------------------------
int __cdecl sub_1002FD39(int a1, int a2)
{
  int result; // eax@2

  if ( a1 )
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
    result = sub_1002FC09(a1, *(_DWORD *)a2, *(_DWORD *)(a2 + 4));
  }
  return result;
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);

//----- (1002FD59) --------------------------------------------------------
void *__cdecl sub_1002FD59(void *a1)
{
  void *result; // eax@1
  int ebp0; // ebp@0
  int v3; // eax@1
  void *v4; // [sp+4h] [bp-4h]@1

  v3 = sub_1002F8DB(ebp0);
  result = sub_1002F75B(a1, v3);
  if ( v4 )
    result = (void *)sub_1000AA70(v4);
  return result;
}

//----- (1002FD89) --------------------------------------------------------
int __cdecl sub_1002FD89(int a1)
{
  int result; // eax@1

  result = a1;
  if ( a1 )
  {
    *(_DWORD *)a1 = 0;
    *(_DWORD *)(a1 + 4) = 0;
  }
  return result;
}

//----- (1002FD9C) --------------------------------------------------------
int __usercall sub_1002FD9C<eax>(int a1<ebp>)
{
  void *v1; // ecx@1

  sub_10035648();
  sub_1002FA13(a1);
  *(_DWORD *)(a1 - 4) = 0;
  sub_1002FD39(*(_DWORD *)(a1 + 8), a1 - 20);
  v1 = *(void **)(a1 - 16);
  *(_DWORD *)(a1 - 4) = -1;
  if ( v1 )
    sub_1000AA70(v1);
  return sub_10035616(8);
}
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1002FDDA) --------------------------------------------------------
int __cdecl sub_1002FDDA(int a1)
{
  return sub_1002F7B4(a1, 0);
}

//----- (1002FDE9) --------------------------------------------------------
void __usercall sub_1002FDE9(const void *a1<ecx>, int a2<edi>, const void **a3)
{
  sub_1002FC2C(*a3, a2);
}

//----- (1002FDF7) --------------------------------------------------------
unsigned int __userpurge sub_1002FDF7<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, unsigned int a4)
{
  unsigned int result; // eax@1
  int v5; // [sp-4h] [bp-10h]@5
  int (__stdcall **v6)(char); // [sp+0h] [bp-Ch]@5

  result = a4;
  if ( a4 )
  {
    if ( a4 > 0xAAAAAAA )
    {
      a4 = (unsigned int)"_DebugMallocator<T>::allocate() - Integer overflow.";
      sub_1002AEA4((int)&v6, (int *)&a4);
      v6 = &off_1005F2F8;
      v5 = (int)&unk_1006AAA8;
    }
    else
    {
      result = sub_10037530(a1, a2, a3, 24 * a4);
      if ( result )
        return result;
      a4 = (unsigned int)"bad allocation";
      sub_1002AEC9((int)&v6, (int)&a4, 1);
      v6 = &off_1005F2C4;
      v5 = (int)&unk_1006AA70;
    }
    sub_100355BB((int)&v6, v5);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1002FE69);
  }
  return result;
}
// 1005F2C4: using guessed type int (__stdcall *off_1005F2C4)(char);
// 1005F2F8: using guessed type int (__stdcall *off_1005F2F8)(char);

//----- (1002FE69) --------------------------------------------------------
unsigned int __userpurge sub_1002FE69<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, unsigned int a4)
{
  unsigned int result; // eax@1
  int v5; // [sp-4h] [bp-10h]@5
  int (__stdcall **v6)(char); // [sp+0h] [bp-Ch]@5

  result = a4;
  if ( a4 )
  {
    if ( a4 > 0x30C30C3 )
    {
      a4 = (unsigned int)"_DebugMallocator<T>::allocate() - Integer overflow.";
      sub_1002AEA4((int)&v6, (int *)&a4);
      v6 = &off_1005F2F8;
      v5 = (int)&unk_1006AAA8;
    }
    else
    {
      result = sub_10037530(a1, a2, a3, 84 * a4);
      if ( result )
        return result;
      a4 = (unsigned int)"bad allocation";
      sub_1002AEC9((int)&v6, (int)&a4, 1);
      v6 = &off_1005F2C4;
      v5 = (int)&unk_1006AA70;
    }
    sub_100355BB((int)&v6, v5);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1002FEDB);
  }
  return result;
}
// 1005F2C4: using guessed type int (__stdcall *off_1005F2C4)(char);
// 1005F2F8: using guessed type int (__stdcall *off_1005F2F8)(char);

//----- (1002FEDB) --------------------------------------------------------
int __usercall sub_1002FEDB<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  int ebp0; // ebp@0

  *(_DWORD *)a4 = sub_100321FB(a1, a2, ebp0, a3);
  return a4;
}

//----- (1002FEEC) --------------------------------------------------------
int __usercall sub_1002FEEC<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4, int a5)
{
  int ebp0; // ebp@0
  int v7; // eax@1

  v7 = sub_100321FB(a1, a2, ebp0, a3);
  return (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v7 + 44))(v7, a4, a5);
}

//----- (1002FF03) --------------------------------------------------------
int __thiscall sub_1002FF03(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10060BB4;
  return v2;
}
// 10060BB4: using guessed type int (__stdcall *off_10060BB4)(char);

//----- (1002FF15) --------------------------------------------------------
int __thiscall sub_1002FF15(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10060698;
  return v2;
}
// 10060698: using guessed type int (__stdcall *off_10060698)(char);

//----- (1002FF27) --------------------------------------------------------
int __thiscall sub_1002FF27(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10060D2C;
  return v2;
}
// 10060D2C: using guessed type int (__stdcall *off_10060D2C)(char);

//----- (1002FF39) --------------------------------------------------------
int __thiscall sub_1002FF39(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10060D20;
  return v2;
}
// 10060D20: using guessed type int (__stdcall *off_10060D20)(char);

//----- (1002FF4B) --------------------------------------------------------
int __thiscall sub_1002FF4B(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002AEA4(this, (int *)&a2);
  *(_DWORD *)v3 = &off_1006094C;
  return v3;
}
// 1006094C: using guessed type int (__stdcall *off_1006094C)(char);

//----- (1002FF67) --------------------------------------------------------
int __thiscall sub_1002FF67(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10060D08;
  return v2;
}
// 10060D08: using guessed type int (__stdcall *off_10060D08)(char);

//----- (1002FF79) --------------------------------------------------------
int __thiscall sub_1002FF79(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10060D14;
  return v2;
}
// 10060D14: using guessed type int (__stdcall *off_10060D14)(char);

//----- (1002FF8B) --------------------------------------------------------
int __thiscall sub_1002FF8B(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002AEA4(this, (int *)&a2);
  *(_DWORD *)v3 = &off_100606B0;
  return v3;
}
// 100606B0: using guessed type int (__stdcall *off_100606B0)(char);

//----- (1002FFA7) --------------------------------------------------------
int __thiscall sub_1002FFA7(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10060BCC;
  return v2;
}
// 10060BCC: using guessed type int (__stdcall *off_10060BCC)(char);

//----- (1002FFB9) --------------------------------------------------------
int __thiscall sub_1002FFB9(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002AEA4(this, (int *)&a2);
  *(_DWORD *)v3 = &off_100606BC;
  return v3;
}
// 100606BC: using guessed type int (__stdcall *off_100606BC)(char);

//----- (1002FFD5) --------------------------------------------------------
int __thiscall sub_1002FFD5(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_100606BC;
  return v2;
}
// 100606BC: using guessed type int (__stdcall *off_100606BC)(char);

//----- (1002FFE7) --------------------------------------------------------
int __thiscall sub_1002FFE7(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10060D68;
  return v2;
}
// 10060D68: using guessed type int (__stdcall *off_10060D68)(char);

//----- (1002FFF9) --------------------------------------------------------
int __thiscall sub_1002FFF9(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002AEA4(this, (int *)&a2);
  *(_DWORD *)v3 = &off_10060D38;
  return v3;
}
// 10060D38: using guessed type int (__stdcall *off_10060D38)(char);

//----- (10030015) --------------------------------------------------------
int __thiscall sub_10030015(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10060D50;
  return v2;
}
// 10060D50: using guessed type int (__stdcall *off_10060D50)(char);

//----- (10030027) --------------------------------------------------------
int __thiscall sub_10030027(int this, char a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002AEA4(this, (int *)&a2);
  *(_DWORD *)v3 = &off_10060D44;
  return v3;
}
// 10060D44: using guessed type int (__stdcall *off_10060D44)(char);

//----- (10030043) --------------------------------------------------------
int __thiscall sub_10030043(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_100606A4;
  return v2;
}
// 100606A4: using guessed type int (__stdcall *off_100606A4)(char);

//----- (10030055) --------------------------------------------------------
int __thiscall sub_10030055(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10060BC0;
  return v2;
}
// 10060BC0: using guessed type int (__stdcall *off_10060BC0)(char);

//----- (10030067) --------------------------------------------------------
int __thiscall sub_10030067(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10060D5C;
  return v2;
}
// 10060D5C: using guessed type int (__stdcall *off_10060D5C)(char);

//----- (10030079) --------------------------------------------------------
int __thiscall sub_10030079(int this, int a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002AF07(this);
  *(_DWORD *)(v3 + 12) = a2;
  *(_DWORD *)v3 = &off_10060CE4;
  return v3;
}
// 10060CE4: using guessed type int (__stdcall *off_10060CE4)(char);

//----- (10030097) --------------------------------------------------------
int __thiscall sub_10030097(int this, int a2)
{
  int v3; // esi@1

  v3 = this;
  sub_10030079(this, a2);
  *(_DWORD *)v3 = &off_10060CF0;
  return v3;
}
// 10060CF0: using guessed type int (__stdcall *off_10060CF0)(char);

//----- (100300B2) --------------------------------------------------------
int __thiscall sub_100300B2(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10060D74;
  return v2;
}
// 10060D74: using guessed type int (__stdcall *off_10060D74)(char);

//----- (100300C4) --------------------------------------------------------
int __thiscall sub_100300C4(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_1002AF07(this);
  *(_DWORD *)v2 = &off_10060CFC;
  return v2;
}
// 10060CFC: using guessed type int (__stdcall *off_10060CFC)(char);

//----- (100300DB) --------------------------------------------------------
void *__userpurge sub_100300DB<eax>(int a1<ecx>, int a2<ebx>, char a3)
{
  void *v3; // esi@1

  v3 = (void *)a1;
  sub_1002AF18(a1, a2);
  if ( a3 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10030100) --------------------------------------------------------
int __cdecl sub_10030100(int a1, unsigned __int8 a2, int a3)
{
  int result; // eax@1
  int v4; // edx@2
  int v5; // ebx@2
  unsigned __int8 v6; // cl@3
  char v7; // cf@6
  int v8; // eax@6
  char v9; // zf@8
  unsigned __int8 v10; // cl@9
  char v11; // cf@12
  int v12; // ecx@13
  unsigned int v13; // ecx@14
  unsigned int v14; // ecx@16

  result = a3;
  if ( a3 )
  {
    v4 = a1;
    LOBYTE(v5) = a2;
    while ( v4 & 3 )
    {
      v6 = *(_BYTE *)v4++;
      if ( !(a2 ^ v6) )
        return v4 - 1;
      --result;
      if ( !result )
        return result;
    }
    v7 = (unsigned int)result < 4;
    v8 = result - 4;
    if ( !v7 )
    {
      v5 = 16843009 * a2;
      do
      {
        v12 = v5 ^ *(_DWORD *)v4;
        v4 += 4;
        if ( ((v12 + 2130640639) ^ ~v12) & 0x81010100 )
        {
          v13 = *(_DWORD *)(v4 - 4);
          LOBYTE(v13) = v5 ^ v13;
          if ( !(_BYTE)v13 )
            return v4 - 4;
          BYTE1(v13) ^= v5;
          if ( !BYTE1(v13) )
            return v4 - 3;
          v14 = v13 >> 16;
          if ( !((_BYTE)v5 ^ (_BYTE)v14) )
            return v4 - 2;
          if ( !((_BYTE)v5 ^ BYTE1(v14)) )
            return v4 - 1;
        }
        v11 = (unsigned int)v8 < 4;
        v8 -= 4;
      }
      while ( !v11 );
    }
    v9 = v8 == -4;
    result = v8 + 4;
    if ( !v9 )
    {
      while ( 1 )
      {
        v10 = *(_BYTE *)v4++;
        if ( !((_BYTE)v5 ^ v10) )
          break;
        --result;
        if ( !result )
          return result;
      }
      return v4 - 1;
    }
  }
  return result;
}

//----- (100301AD) --------------------------------------------------------
int __userpurge sub_100301AD<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  int v4; // esi@1
  int v5; // edx@2
  int v6; // eax@4
  int v7; // eax@7
  int v8; // eax@8
  int v9; // ecx@8

  v4 = a1;
  *(_BYTE *)(a1 + 12) = 0;
  if ( a4 )
  {
    *(_DWORD *)a1 = *(_DWORD *)a4;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a4 + 4);
  }
  else
  {
    v5 = sub_10041952(a2, a3);
    *(_DWORD *)(v4 + 8) = v5;
    *(_DWORD *)v4 = *(_DWORD *)(v5 + 108);
    *(_DWORD *)(v4 + 4) = *(_DWORD *)(v5 + 104);
    if ( *(volatile LONG **)v4 != off_10073B44 )
    {
      if ( !(dword_10073C0C & *(_DWORD *)(v5 + 112)) )
      {
        sub_10041DA4(a2, a3);
        *(_DWORD *)v4 = v6;
      }
    }
    if ( *(LPVOID *)(v4 + 4) != lpAddend )
    {
      if ( !(dword_10073C0C & *(_DWORD *)(*(_DWORD *)(v4 + 8) + 112)) )
      {
        sub_10042126(a2, a3);
        *(_DWORD *)(v4 + 4) = v7;
      }
    }
    v9 = *(_DWORD *)(v4 + 8);
    v8 = *(_DWORD *)(v9 + 112);
    if ( !(v8 & 2) )
    {
      *(_DWORD *)(v9 + 112) = v8 | 2;
      *(_BYTE *)(v4 + 12) = 1;
    }
  }
  return v4;
}
// 10073C0C: using guessed type int dword_10073C0C;

//----- (10030235) --------------------------------------------------------
int __usercall sub_10030235<eax>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // ecx@2
  int v6; // eax@3
  __int16 v7; // ax@4
  int v8; // ecx@6
  int result; // eax@8
  int v10; // ecx@14
  unsigned int v11; // eax@16
  int v12; // edx@22
  int v13; // [sp+4h] [bp-18h]@1
  int v14; // [sp+Ch] [bp-10h]@7
  char v15; // [sp+10h] [bp-Ch]@6
  WCHAR DestStr; // [sp+14h] [bp-8h]@16
  const CHAR MultiByteStr; // [sp+18h] [bp-4h]@14
  char v18; // [sp+19h] [bp-3h]@14
  char v19; // [sp+1Ah] [bp-2h]@14
  int v20; // [sp+24h] [bp+8h]@13

  sub_100301AD((int)&v13, a1, a2, a4);
  v4 = a3;
  if ( (unsigned int)a3 < 0x100 )
  {
    v5 = v13;
    if ( *(_DWORD *)(v13 + 116) <= 1 )
    {
      v7 = *(_WORD *)(*(_DWORD *)(v13 + 144) + 2 * a3);
      v6 = v7 & 2;
    }
    else
    {
      v6 = sub_1004256E(a3, a2, a3, 2, (int)&v13);
      v5 = v13;
    }
    if ( v6 )
    {
      v8 = *(_BYTE *)(*(_DWORD *)(v5 + 152) + a3);
      if ( v15 )
        *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
      return v8;
    }
    if ( v15 )
      *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
    return v4;
  }
  if ( *(_DWORD *)(v13 + 116) > 1 && (v20 = a3 >> 8, sub_1004261D(v4, a2, BYTE1(v4), (int)&v13)) )
  {
    MultiByteStr = v20;
    v18 = v4;
    v19 = 0;
    v10 = 2;
  }
  else
  {
    *(_DWORD *)sub_10037649(v4) = 42;
    MultiByteStr = v4;
    v18 = 0;
    v10 = 1;
  }
  v11 = sub_100374A2(
          v4,
          a2,
          (int)&v13,
          *(_DWORD *)(v13 + 168),
          0x200u,
          &MultiByteStr,
          v10,
          &DestStr,
          3,
          *(_DWORD *)(v13 + 4),
          1);
  if ( !v11 )
  {
    if ( v15 )
      *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
    return v4;
  }
  if ( v11 == 1 )
  {
    result = (unsigned __int8)DestStr;
    if ( v15 )
      *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
  }
  else
  {
    v12 = HIBYTE(DestStr) | ((unsigned __int8)DestStr << 8);
    if ( v15 )
      *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
    result = v12;
  }
  return result;
}

//----- (10030377) --------------------------------------------------------
int __usercall sub_10030377<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // ecx@2
  int result; // eax@4

  if ( dword_10075F28 )
  {
    result = sub_10030235(a1, a2, a3, 0);
  }
  else
  {
    v3 = a3;
    if ( (unsigned int)(a3 - 97) <= 0x19 )
      v3 = a3 - 32;
    result = v3;
  }
  return result;
}
// 10075F28: using guessed type int dword_10075F28;

//----- (100303A8) --------------------------------------------------------
signed int __usercall sub_100303A8<eax>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  signed int v5; // eax@4
  int v6; // ebx@4
  unsigned int v7; // ebx@11
  int v8; // esi@11
  __int64 v9; // qax@11
  __int64 v10; // qax@11
  unsigned __int8 v11; // cf@11
  char v12; // zf@14
  int v13; // ecx@14
  unsigned __int8 v14; // cf@14
  unsigned __int8 v15; // cf@19
  char v16; // zf@20
  int *v17; // ecx@26
  int v18; // ebx@26
  int v19; // esi@26
  unsigned __int64 v20; // ST00_8@26
  int v21; // eax@26
  __int64 v22; // qax@26
  unsigned __int8 v23; // cf@26
  signed int v24; // eax@28
  int v25; // edx@28
  int v26; // eax@30
  int v27; // eax@30
  unsigned __int64 v28; // ST00_8@30
  int v29; // eax@30
  __int64 v30; // qax@30
  unsigned __int8 v31; // cf@30
  int v32; // ebx@30
  unsigned __int64 v33; // ST00_8@30
  int v34; // eax@30
  signed int v35; // [sp+4h] [bp-18h]@11
  signed int v36; // [sp+8h] [bp-14h]@4
  signed int v37; // [sp+14h] [bp-8h]@11
  signed int v38; // [sp+18h] [bp-4h]@1

  v38 = 0;
  if ( !a3 || (sub_100391F0((void *)a3, 0xFFu, 36), !a4) )
  {
    *(_DWORD *)sub_10037649(a1) = 22;
    sub_1003A151(a1, a2);
    return 22;
  }
  v6 = *(_DWORD *)a4;
  v5 = *(_DWORD *)(a4 + 4);
  v36 = v5;
  if ( v5 <= -1 && (v5 < -1 || (unsigned int)v6 < 0xFFFF5740) || v5 >= 7 && (v5 > 7 || (unsigned int)v6 > 0x934126CF) )
  {
    *(_DWORD *)sub_10037649(v6) = 22;
    return 22;
  }
  v37 = sub_1003AC40(*(_QWORD *)a4, 0x1E13380u, 0) + 70;
  v35 = v37 - 1;
  v9 = sub_10039A20(v37 - 70, -365i64);
  v10 = sub_10039A20(v9 - ((v37 + 299) / 400 - (v37 - 1) / 100 + (v37 - 1) / 4 - 17), 86400i64);
  v11 = (_DWORD)v10 >= (unsigned int)-v6;
  v7 = v10 + v6;
  v8 = HIDWORD(v10) + v11 + v36;
  if ( v8 <= 0 && v8 < 0 )
  {
    v13 = v37 - 1;
    v14 = v7 >= 0xFE1ECC80;
    v7 += 31536000;
    v8 += v14;
    v12 = (v35 & 0x80000003) == 0;
    if ( (v35 & 0x80000003) < 0 )
      v12 = (((v35 & 0x80000003) - 1) | 0xFFFFFFFC) == -1;
    if ( (!v12 || !(v35 % 100)) && (v35 + 1900) % 400 )
      goto LABEL_26;
    v15 = v7 >= 0xFFFEAE80;
    v7 += 86400;
    v8 += v15;
  }
  else
  {
    v13 = v37;
    v16 = (v37 & 0x80000003) == 0;
    if ( (v37 & 0x80000003) < 0 )
      v16 = (((v37 & 0x80000003) - 1) | 0xFFFFFFFC) == -1;
    if ( (!v16 || !(v37 % 100)) && (v37 + 1900) % 400 )
      goto LABEL_26;
  }
  v38 = 1;
LABEL_26:
  HIDWORD(v20) = v8;
  LODWORD(v20) = v7;
  *(_DWORD *)(a3 + 20) = v13;
  v21 = sub_1003AC40(v20, 0x15180u, 0);
  *(_DWORD *)(a3 + 28) = v21;
  v22 = sub_10039A20(v21, -86400i64);
  v23 = (_DWORD)v22 >= (unsigned int)-v7;
  v18 = v22 + v7;
  v19 = HIDWORD(v22) + v23 + v8;
  v17 = &dword_10073324;
  if ( !v38 )
    v17 = dword_100732F0;
  v25 = *(_DWORD *)(a3 + 28);
  v24 = 1;
  if ( v17[1] < v25 )
  {
    do
      ++v24;
    while ( v17[v24] < v25 );
  }
  v26 = v24 - 1;
  *(_DWORD *)(a3 + 16) = v26;
  *(_DWORD *)(a3 + 12) = v25 - v17[v26];
  v27 = sub_1003AC40(*(_QWORD *)a4, 0x15180u, 0);
  HIDWORD(v28) = v19;
  LODWORD(v28) = v18;
  *(_DWORD *)(a3 + 24) = (v27 + 4) % 7;
  v29 = sub_1003AC40(v28, 0xE10u, 0);
  *(_DWORD *)(a3 + 8) = v29;
  v30 = sub_10039A20(v29, -3600i64);
  v31 = (_DWORD)v30 >= (unsigned int)-v18;
  v32 = v30 + v18;
  HIDWORD(v33) = HIDWORD(v30) + v31 + v19;
  LODWORD(v33) = v32;
  v34 = sub_1003AC40(v33, 0x3Cu, 0);
  *(_DWORD *)(a3 + 32) = 0;
  *(_DWORD *)(a3 + 4) = v34;
  *(_DWORD *)a3 = v32 - 60 * v34;
  return 0;
}
// 100732F0: using guessed type int dword_100732F0[];
// 10073324: using guessed type int dword_10073324;

//----- (100305D1) --------------------------------------------------------
signed int __usercall sub_100305D1<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6)
{
  int v6; // edx@1
  int v8; // esi@9
  int v9; // eax@11
  int v10; // ebx@14
  int v11; // edi@14
  char v12; // al@15
  char v13; // al@18
  char v14; // zf@23
  int v15; // [sp-8h] [bp-Ch]@14
  signed int v16; // [sp-4h] [bp-8h]@11
  int v17; // [sp-4h] [bp-8h]@14

  v6 = a6;
  if ( a6 )
  {
    if ( !a3 )
    {
LABEL_11:
      v9 = sub_10037649(a1);
      v16 = 22;
LABEL_12:
      *(_DWORD *)v9 = v16;
      sub_1003A151(a1, a2);
      return v16;
    }
  }
  else
  {
    if ( !a3 )
    {
      if ( !a4 )
        return 0;
      goto LABEL_11;
    }
  }
  if ( !a4 )
    goto LABEL_11;
  if ( !a6 )
  {
    *(_BYTE *)a3 = 0;
    return 0;
  }
  v8 = a5;
  if ( !a5 )
  {
    *(_BYTE *)a3 = 0;
    goto LABEL_11;
  }
  v17 = a1;
  v15 = a2;
  v10 = a3;
  v11 = a4;
  if ( a6 == -1 )
  {
    do
    {
      v12 = *(_BYTE *)v8;
      *(_BYTE *)(a3 - a5 + v8) = *(_BYTE *)v8;
      ++v8;
      if ( !v12 )
        break;
      --v11;
    }
    while ( v11 );
  }
  else
  {
    do
    {
      v13 = *(_BYTE *)(a5 - a3 + v10);
      *(_BYTE *)v10++ = v13;
      if ( !v13 )
        break;
      --v11;
      if ( !v11 )
        break;
      --v6;
    }
    while ( v6 );
    if ( !v6 )
      *(_BYTE *)v10 = 0;
  }
  v14 = v11 == 0;
  a2 = v15;
  a1 = v17;
  if ( !v14 )
    return 0;
  if ( v6 != -1 )
  {
    *(_BYTE *)a3 = 0;
    v9 = sub_10037649(v17);
    v16 = 34;
    goto LABEL_12;
  }
  *(_BYTE *)(a3 + a4 - 1) = 0;
  return 80;
}

//----- (10030675) --------------------------------------------------------
int __cdecl sub_10030675(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  dword_1007559C = IsDebuggerPresent();
  sub_10043522();
  sub_10039869(ExceptionInfo);
  if ( !dword_1007559C )
    sub_10043522();
  return sub_10039854(0xC0000409u);
}
// 1007559C: using guessed type int dword_1007559C;

//----- (100306B2) --------------------------------------------------------
int __usercall sub_100306B2<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, char a4)
{
  BOOL v8; // eax@1
  int v9; // edx@1
  signed int v10; // ecx@1
  int v12; // ST328_4@3
  int v13; // [sp-4h] [bp-328h]@1
  int v14; // [sp+328h] [bp+4h]@3

  v8 = IsProcessorFeaturePresent(0x17u);
  _OF = 0;
  _CF = 0;
  _ZF = v8 == 0;
  _SF = v8 < 0;
  if ( v8 )
  {
    v10 = 2;
    __asm { int     29h             ; DOS 2+ internal - FAST PUTCHAR }
  }
  dword_10075380 = v8;
  dword_1007537C = v10;
  dword_10075378 = v9;
  dword_10075374 = a1;
  dword_10075370 = a3;
  dword_1007536C = a2;
  word_10075398 = __SS__;
  word_1007538C = __CS__;
  word_10075368 = __DS__;
  word_10075364 = __ES__;
  word_10075360 = __FS__;
  word_1007535C = __GS__;
  __asm { pushf }
  dword_10075390 = v13;
  dword_10075384 = v12;
  dword_10075388 = v14;
  dword_10075394 = (int)&a4;
  dword_100752D0 = 65537;
  dword_1007528C = dword_10075388;
  dword_10075280 = -1073740791;
  dword_10075284 = 1;
  dword_10075290 = 1;
  dword_10075294 = 2;
  return sub_10030675(&ExceptionInfo);
}
// 10075280: using guessed type int dword_10075280;
// 10075284: using guessed type int dword_10075284;
// 1007528C: using guessed type int dword_1007528C;
// 10075290: using guessed type int dword_10075290;
// 10075294: using guessed type int dword_10075294;
// 100752D0: using guessed type int dword_100752D0;
// 1007535C: using guessed type __int16 word_1007535C;
// 10075360: using guessed type __int16 word_10075360;
// 10075364: using guessed type __int16 word_10075364;
// 10075368: using guessed type __int16 word_10075368;
// 1007536C: using guessed type int dword_1007536C;
// 10075370: using guessed type int dword_10075370;
// 10075374: using guessed type int dword_10075374;
// 10075378: using guessed type int dword_10075378;
// 1007537C: using guessed type int dword_1007537C;
// 10075380: using guessed type int dword_10075380;
// 10075384: using guessed type int dword_10075384;
// 10075388: using guessed type int dword_10075388;
// 1007538C: using guessed type __int16 word_1007538C;
// 10075390: using guessed type int dword_10075390;
// 10075394: using guessed type int dword_10075394;
// 10075398: using guessed type __int16 word_10075398;

//----- (100307AB) --------------------------------------------------------
int __usercall sub_100307AB<eax>(int a1<ebx>, int a2<edi>, int a3<esi>)
{
  return sub_100307B7(a1, a2, a3, 8);
}

//----- (100307B7) --------------------------------------------------------
int __usercall sub_100307B7<eax>(int a1<ebx>, int a2<edi>, int a3<esi>, int a4)
{
  BOOL v8; // eax@1
  int v9; // edx@1
  int v10; // ecx@1
  int v12; // ST320_4@3
  int v13; // [sp-4h] [bp-320h]@1
  int v14; // [sp+320h] [bp+4h]@3

  v8 = IsProcessorFeaturePresent(0x17u);
  _OF = 0;
  _CF = 0;
  _ZF = v8 == 0;
  _SF = v8 < 0;
  if ( v8 )
  {
    v10 = a4;
    __asm { int     29h             ; DOS 2+ internal - FAST PUTCHAR }
  }
  dword_10075380 = v8;
  dword_1007537C = v10;
  dword_10075378 = v9;
  dword_10075374 = a1;
  dword_10075370 = a3;
  dword_1007536C = a2;
  word_10075398 = __SS__;
  word_1007538C = __CS__;
  word_10075368 = __DS__;
  word_10075364 = __ES__;
  word_10075360 = __FS__;
  word_1007535C = __GS__;
  __asm { pushf }
  dword_10075390 = v13;
  dword_10075384 = v12;
  dword_10075388 = v14;
  dword_10075394 = (int)&a4;
  dword_1007528C = dword_10075388;
  dword_10075280 = -1073740791;
  dword_10075284 = 1;
  dword_10075290 = 1;
  dword_10075294 = a4;
  return sub_10030675(&ExceptionInfo);
}
// 10075280: using guessed type int dword_10075280;
// 10075284: using guessed type int dword_10075284;
// 1007528C: using guessed type int dword_1007528C;
// 10075290: using guessed type int dword_10075290;
// 10075294: using guessed type int dword_10075294;
// 1007535C: using guessed type __int16 word_1007535C;
// 10075360: using guessed type __int16 word_10075360;
// 10075364: using guessed type __int16 word_10075364;
// 10075368: using guessed type __int16 word_10075368;
// 1007536C: using guessed type int dword_1007536C;
// 10075370: using guessed type int dword_10075370;
// 10075374: using guessed type int dword_10075374;
// 10075378: using guessed type int dword_10075378;
// 1007537C: using guessed type int dword_1007537C;
// 10075380: using guessed type int dword_10075380;
// 10075384: using guessed type int dword_10075384;
// 10075388: using guessed type int dword_10075388;
// 1007538C: using guessed type __int16 word_1007538C;
// 10075390: using guessed type int dword_10075390;
// 10075394: using guessed type int dword_10075394;
// 10075398: using guessed type __int16 word_10075398;

//----- (10030885) --------------------------------------------------------
int __usercall sub_10030885<eax>(int a1<ebx>, int a2, int a3, char a4)
{
  return sub_100308A3(a1, sub_100435CC, a2, a3, 0, (int)&a4);
}

//----- (100308A3) --------------------------------------------------------
int __usercall sub_100308A3<eax>(int a1<ebx>, int (__cdecl *a2)(_DWORD, _DWORD, _DWORD, _DWORD), int a3, int a4, int a5, int a6)
{
  int result; // eax@2
  int v7; // eax@4
  int v8; // [sp+8h] [bp-20h]@1
  int v9; // [sp+Ch] [bp-1Ch]@1
  int v10; // [sp+10h] [bp-18h]@4
  int v11; // [sp+14h] [bp-14h]@4
  int v12; // [sp+28h] [bp+0h]@2

  v8 = 0;
  memset(&v9, 0, 0x1Cu);
  if ( a3 && a4 )
  {
    v7 = sub_10035530(a3);
    v11 = 73;
    v10 = a3;
    v8 = a3;
    v9 = 2147483647;
    if ( (unsigned int)v7 <= 0x7FFFFFFF )
      v9 = v7;
    result = a2(&v8, a4, a5, a6);
  }
  else
  {
    *(_DWORD *)sub_10037649(a1) = 22;
    sub_1003A151(a1, (int)&v12);
    result = -1;
  }
  return result;
}

//----- (10030914) --------------------------------------------------------
int __usercall sub_10030914<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned int a4, int a5, char a6)
{
  return sub_100448FD(a1, a2, a3, a4, a5, 0, (int)&a6);
}

//----- (10030930) --------------------------------------------------------
int __usercall sub_10030930<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int dwBytes)
{
  HMODULE v5; // ecx@3
  SIZE_T v6; // ecx@6
  bool v7; // eax@10
  int v8; // ST08_4@10
  int result; // eax@14

  if ( (unsigned int)dwBytes > 0xFFFFFFE0 )
  {
    sub_1003ADA2(dwBytes);
    *(_DWORD *)sub_10037649(a3) = 12;
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      if ( !hHeap )
      {
        sub_1003F5AC(a1, a2, a3, a4);
        sub_1003F609(a3, 30);
        sub_1003AE5C(v5, 0xFFu);
      }
      v6 = dwBytes ? dwBytes : 1;
      a4 = (int)HeapAlloc(hHeap, 0, v6);
      if ( a4 )
        break;
      a3 = 12;
      if ( !dword_10075F2C )
      {
        *(_DWORD *)sub_10037649(12) = 12;
LABEL_13:
        *(_DWORD *)sub_10037649(12) = 12;
        break;
      }
      v7 = sub_1003ADA2(dwBytes);
      a2 = v8;
      if ( !v7 )
        goto LABEL_13;
    }
    result = a4;
  }
  return result;
}
// 10075F2C: using guessed type int dword_10075F2C;

//----- (100309C2) --------------------------------------------------------
void __usercall sub_100309C2(int a1<ebx>, LPVOID lpMem)
{
  int v2; // esi@3
  int v3; // eax@3

  if ( lpMem )
  {
    if ( !HeapFree(hHeap, 0, lpMem) )
    {
      v2 = sub_10037649(a1);
      v3 = GetLastError();
      *(_DWORD *)v2 = sub_1003765C(v3);
    }
  }
}

//----- (100309FA) --------------------------------------------------------
signed int __stdcall sub_100309FA(int a1, int a2, int a3, void (__thiscall *a4)(_DWORD), int a5)
{
  int v5; // edi@1
  int v6; // esi@1

  v6 = 0;
  v5 = a1;
  while ( v6 < a3 )
  {
    a4(v5);
    v5 += a2;
    ++v6;
  }
  return 1;
}

//----- (10030A70) --------------------------------------------------------
int __cdecl sub_10030A70(int a1, unsigned __int8 a2)
{
  signed int v2; // eax@2
  int result; // eax@5
  int v14; // edx@8
  char v15; // cl@9
  int v16; // ebx@12
  int v17; // eax@13
  int v18; // esi@13
  int v19; // ecx@13
  int v20; // eax@14
  unsigned int v21; // eax@19
  unsigned int v22; // eax@23

  if ( (unsigned int)dword_1007577C < 1 )
  {
    v14 = a1;
    if ( a1 & 3 )
    {
      while ( 1 )
      {
        v15 = *(_BYTE *)v14++;
        if ( v15 == a2 )
          break;
        if ( !v15 )
          return 0;
        if ( !(v14 & 3) )
          goto LABEL_12;
      }
      result = v14 - 1;
    }
    else
    {
LABEL_12:
      v16 = (a2 << 8) | a2 | (((a2 << 8) | a2) << 16);
      while ( 1 )
      {
        while ( 1 )
        {
          v19 = v16 ^ *(_DWORD *)v14;
          v18 = *(_DWORD *)v14 + 2130640639;
          v17 = (*(_DWORD *)v14 + 2130640639) ^ ~*(_DWORD *)v14;
          v14 += 4;
          if ( ((v19 + 2130640639) ^ ~v19) & 0x81010100 )
            break;
          v20 = v17 & 0x81010100;
          if ( v20 && (v20 & 0x1010100 || !(v18 & 0x80000000)) )
            return 0;
        }
        v21 = *(_DWORD *)(v14 - 4);
        if ( (_BYTE)v21 == (_BYTE)v16 )
          break;
        if ( !(_BYTE)v21 )
          return 0;
        if ( BYTE1(v21) == (_BYTE)v16 )
          return v14 - 3;
        if ( !BYTE1(v21) )
          return 0;
        v22 = v21 >> 16;
        if ( (_BYTE)v22 == (_BYTE)v16 )
          return v14 - 2;
        if ( !(_BYTE)v22 )
          return 0;
        if ( BYTE1(v22) == (_BYTE)v16 )
          return v14 - 1;
        if ( !BYTE1(v22) )
          return 0;
      }
      result = v14 - 4;
    }
  }
  else
  {
    _EDX = (a2 << 8) | a2;
    __asm
    {
      movd    xmm3, edx
      pshuflw xmm3, xmm3, 0
      movlhps xmm3, xmm3
    }
    v2 = -1 << (a1 & 0xF);
    for ( _EDX = a1 - (a1 & 0xF); ; _EDX += 16 )
    {
      __asm
      {
        movdqu  xmm1, xmmword ptr [edx]
        pxor    xmm2, xmm2
        pcmpeqb xmm2, xmm1
        pcmpeqb xmm1, xmm3
        por     xmm2, xmm1
        pmovmskb ecx, xmm2
      }
      _ECX = v2 & _ECX;
      if ( _ECX )
        break;
      v2 = -1;
    }
    __asm { bsf     eax, ecx }
    result = _EDX + _EAX;
    __asm { movd    edx, xmm3 }
    if ( (_BYTE)_EDX != *(_BYTE *)result )
      result = 0;
  }
  return result;
}
// 1007577C: using guessed type int dword_1007577C;

//----- (10030BA0) --------------------------------------------------------
char __cdecl sub_10030BA0(int a1, int a2)
{
  int v3; // edx@1
  int v8; // esi@4
  int v14; // [sp+0h] [bp-24h]@1

  _EAX = 0;
  v14 = 0;
  v3 = a2;
  while ( 1 )
  {
    LOBYTE(_EAX) = *(_BYTE *)v3;
    if ( !*(_BYTE *)v3 )
      break;
    ++v3;
    __asm { bts     [esp+24h+var_24], eax }
  }
  v8 = a1;
  while ( 1 )
  {
    LOBYTE(_EAX) = *(_BYTE *)v8;
    if ( !*(_BYTE *)v8 )
      break;
    ++v8;
    __asm { bt      [esp+24h+var_24], eax }
    if ( _CF )
      return v8 - 1;
  }
  return _EAX;
}

//----- (10030BE0) --------------------------------------------------------
void **__usercall sub_10030BE0<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1

  v2 = sub_10041952(a1, a2);
  if ( *(volatile LONG **)(v2 + 108) != off_10073B44 )
  {
    if ( !(dword_10073C0C & *(_DWORD *)(v2 + 112)) )
      sub_10041DA4(a1, a2);
  }
  return off_10072C50;
}
// 10072C50: using guessed type void **off_10072C50;
// 10073C0C: using guessed type int dword_10073C0C;

//----- (10030C10) --------------------------------------------------------
signed int __cdecl sub_10030C10(int a1, int a2)
{
  int v3; // edx@1
  signed int v8; // ecx@4
  int v9; // esi@4
  int v15; // [sp+0h] [bp-24h]@1

  _EAX = 0;
  v15 = 0;
  v3 = a2;
  while ( 1 )
  {
    LOBYTE(_EAX) = *(_BYTE *)v3;
    if ( !*(_BYTE *)v3 )
      break;
    ++v3;
    __asm { bts     [esp+24h+var_24], eax }
  }
  v9 = a1;
  v8 = -1;
  do
  {
    ++v8;
    LOBYTE(_EAX) = *(_BYTE *)v9;
    if ( !*(_BYTE *)v9 )
      break;
    ++v9;
    __asm { bt      [esp+24h+var_24], eax }
  }
  while ( !_CF );
  return v8;
}

//----- (10030C56) --------------------------------------------------------
int __usercall sub_10030C56<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, LPVOID lpMem, int dwBytes)
{
  signed int v7; // esi@3
  int v8; // esi@15
  int v9; // eax@15
  int v10; // esi@16
  int v11; // eax@16

  if ( !lpMem )
    return sub_10030930(a1, a2, a3, a4, dwBytes);
  v7 = dwBytes;
  if ( !dwBytes )
  {
    sub_100309C2(a3, lpMem);
    return 0;
  }
  while ( 1 )
  {
    if ( (unsigned int)v7 > 0xFFFFFFE0 )
    {
      sub_1003ADA2(v7);
      *(_DWORD *)sub_10037649(a3) = 12;
      return 0;
    }
    if ( !v7 )
      v7 = 1;
    a3 = (int)HeapReAlloc(hHeap, 0, lpMem, v7);
    if ( a3 )
      return a3;
    if ( !dword_10075F2C )
      break;
    if ( !sub_1003ADA2(v7) )
    {
      v8 = sub_10037649(a3);
      v9 = GetLastError();
      *(_DWORD *)v8 = sub_1003765C(v9);
      return 0;
    }
  }
  v10 = sub_10037649(a3);
  v11 = GetLastError();
  *(_DWORD *)v10 = sub_1003765C(v11);
  return a3;
}
// 10075F2C: using guessed type int dword_10075F2C;

//----- (10030D01) --------------------------------------------------------
void *__thiscall sub_10030D01(void *this)
{
  void *v1; // ebx@1
  HMODULE v2; // edi@1
  int v3; // eax@4
  int v4; // eax@4
  int v5; // eax@4
  int v6; // eax@4
  int v7; // eax@4
  int v8; // eax@4

  v1 = this;
  v2 = LoadLibraryExW(L"advapi32.dll", 0, 0x800u);
  if ( v2 || GetLastError() == 87 && (v2 = LoadLibraryW(L"advapi32.dll")) != 0 )
  {
    v3 = (int)GetProcAddress(v2, "RegisterTraceGuidsW");
    *(_DWORD *)v1 = sub_100348F9(v3);
    v4 = (int)GetProcAddress(v2, "UnregisterTraceGuids");
    *((_DWORD *)v1 + 1) = sub_100348F9(v4);
    v5 = (int)GetProcAddress(v2, "TraceEvent");
    *((_DWORD *)v1 + 2) = sub_100348F9(v5);
    v6 = (int)GetProcAddress(v2, "GetTraceLoggerHandle");
    *((_DWORD *)v1 + 3) = sub_100348F9(v6);
    v7 = (int)GetProcAddress(v2, "GetTraceEnableLevel");
    *((_DWORD *)v1 + 4) = sub_100348F9(v7);
    v8 = (int)GetProcAddress(v2, "GetTraceEnableFlags");
    *((_DWORD *)v1 + 5) = sub_100348F9(v8);
  }
  return v1;
}

//----- (10030DC0) --------------------------------------------------------
signed int __stdcall sub_10030DC0(int a1, int a2, int a3, int a4)
{
  signed int result; // eax@3
  int v5; // edx@5
  char v6; // bl@7
  int v7; // eax@10

  if ( a1 == 4 )
  {
    dword_100755B0 = sub_10030EEB(dword_100755B8, a4);
    dword_100755B4 = v5;
    if ( dword_100755B0 == -1 )
      return GetLastError();
    SetLastError(0);
    v6 = sub_10030EB8(dword_100755B8, dword_100755B0, dword_100755B4);
    if ( !v6 )
    {
      result = GetLastError();
      if ( result )
        return result;
      v6 = 4;
    }
    v7 = sub_10030E85(dword_100755B8, dword_100755B0, dword_100755B4);
    if ( !v7 )
    {
      result = GetLastError();
      if ( result )
        return result;
      v7 = -1;
    }
    dword_100755A8 = v7;
    byte_100755AC = v6;
  }
  else
  {
    if ( a1 != 5 )
      return 87;
    byte_100755AC = 0;
    dword_100755A8 = 0;
    dword_100755B0 = 0;
    dword_100755B4 = 0;
  }
  return 0;
}
// 100755A8: using guessed type int dword_100755A8;
// 100755AC: using guessed type char byte_100755AC;
// 100755B0: using guessed type int dword_100755B0;
// 100755B4: using guessed type int dword_100755B4;
// 100755B8: using guessed type int dword_100755B8;

//----- (10030E85) --------------------------------------------------------
int __thiscall sub_10030E85(int this, int a2, int a3)
{
  int v3; // esi@1
  int result; // eax@2
  int v5; // eax@2
  int v6; // ST04_4@2

  v3 = *(_DWORD *)(this + 20);
  if ( (PVOID)v3 == EncodePointer(0) )
  {
    SetLastError(0x7Fu);
    result = 0;
  }
  else
  {
    v5 = sub_100348F9(v3);
    result = ((int (__thiscall *)(int, int, int))v5)(v6, a2, a3);
  }
  return result;
}

//----- (10030EB8) --------------------------------------------------------
char __thiscall sub_10030EB8(int this, int a2, int a3)
{
  int v3; // esi@1
  char result; // al@2
  int v5; // eax@2
  int v6; // ST04_4@2

  v3 = *(_DWORD *)(this + 16);
  if ( (PVOID)v3 == EncodePointer(0) )
  {
    SetLastError(0x7Fu);
    result = 0;
  }
  else
  {
    v5 = sub_100348F9(v3);
    result = ((int (__thiscall *)(int, int, int))v5)(v6, a2, a3);
  }
  return result;
}

//----- (10030EEB) --------------------------------------------------------
int __thiscall sub_10030EEB(int this, int a2)
{
  int v2; // esi@1
  int result; // eax@2
  int v4; // eax@2
  int v5; // ST00_4@2

  v2 = *(_DWORD *)(this + 12);
  if ( (PVOID)v2 == EncodePointer(0) )
  {
    SetLastError(0x7Fu);
    result = -1;
  }
  else
  {
    v4 = sub_100348F9(v2);
    result = ((int (__thiscall *)(int, int))v4)(v5, a2);
  }
  return result;
}

//----- (10030F1B) --------------------------------------------------------
int __thiscall sub_10030F1B(void *this, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // esi@1
  int result; // eax@2
  int v8; // eax@2
  int v9; // ST1C_4@2

  v6 = *(_DWORD *)this;
  if ( *(PVOID *)this == EncodePointer(0) )
  {
    result = 127;
  }
  else
  {
    v8 = sub_100348F9(v6);
    result = ((int (__thiscall *)(int, int, _DWORD, int, int, int, _DWORD, _DWORD, int))v8)(
               v9,
               a2,
               0,
               a3,
               a4,
               a5,
               0,
               0,
               a6);
  }
  return result;
}

//----- (10030F55) --------------------------------------------------------
int __thiscall sub_10030F55(int this, int a2, int a3, int a4)
{
  int v4; // esi@1
  int result; // eax@2
  int v6; // eax@2
  int v7; // ST08_4@2

  v4 = *(_DWORD *)(this + 8);
  if ( (PVOID)v4 == EncodePointer(0) )
  {
    result = 127;
  }
  else
  {
    v6 = sub_100348F9(v4);
    result = ((int (__thiscall *)(int, int, int, int))v6)(v7, a2, a3, a4);
  }
  return result;
}

//----- (10030F84) --------------------------------------------------------
int __thiscall sub_10030F84(int this, int a2, int a3)
{
  int v3; // esi@1
  int result; // eax@2
  int v5; // eax@2
  int v6; // ST04_4@2

  v3 = *(_DWORD *)(this + 4);
  if ( (PVOID)v3 == EncodePointer(0) )
  {
    result = 127;
  }
  else
  {
    v5 = sub_100348F9(v3);
    result = ((int (__thiscall *)(int, int, int))v5)(v6, a2, a3);
  }
  return result;
}

//----- (10030FB0) --------------------------------------------------------
int __thiscall sub_10030FB0(void *this)
{
  int result; // eax@1
  void *v2; // esi@1
  char v3; // [sp+4h] [bp-10h]@3
  int v4; // [sp+Ch] [bp-8h]@2
  void (__cdecl *v5)(); // [sp+10h] [bp-4h]@2

  v2 = this;
  result = *(_DWORD *)this;
  *(_DWORD *)this = 1;
  if ( result )
  {
    v4 = 0;
    v5 = sub_10034BB6;
    do
    {
      sub_100282E0((int)&v3);
      result = *(_DWORD *)v2;
      *(_DWORD *)v2 = 1;
    }
    while ( result );
  }
  return result;
}

//----- (10030FE1) --------------------------------------------------------
int *__usercall sub_10030FE1<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  if ( !dword_100755B8 )
    sub_10030FF5(a1, a2, a3);
  return &dword_100755A8;
}
// 100755A8: using guessed type int dword_100755A8;
// 100755B8: using guessed type int dword_100755B8;

//----- (10030FF5) --------------------------------------------------------
int __usercall sub_10030FF5<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // eax@2
  void *v6; // eax@3

  sub_10035648();
  *(_DWORD *)(a2 - 16) = &dword_10075F48;
  sub_10030FB0(&dword_10075F48);
  *(_DWORD *)(a2 - 4) = 0;
  if ( !dword_100755B8 )
  {
    v5 = sub_1002ADB1(v3, v4, a1, a3, 24);
    if ( v5 )
      v6 = sub_10030D01((void *)v5);
    else
      v6 = 0;
    dword_100755B8 = (int)v6;
    sub_10030F1B(v6, (int)sub_10030DC0, (int)&unk_10067334, 7, (int)&off_10072CB0, (int)&dword_100755C0);
  }
  dword_10075F48 = 0;
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 10072CB0: using guessed type void *off_10072CB0;
// 100755B8: using guessed type int dword_100755B8;
// 100755C0: using guessed type int dword_100755C0;
// 10075F48: using guessed type int dword_10075F48;

//----- (10031064) --------------------------------------------------------
int __usercall sub_10031064<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4, int a5, int a6, int a7)
{
  int result; // eax@1
  int ebp0; // ebp@0
  __int16 v9; // [sp+0h] [bp-7Ch]@3
  char v10; // [sp+2h] [bp-7Ah]@3
  char v11; // [sp+4h] [bp-78h]@3
  char v12; // [sp+5h] [bp-77h]@3
  int v13; // [sp+18h] [bp-64h]@3
  int v14; // [sp+1Ch] [bp-60h]@3
  int v15; // [sp+20h] [bp-5Ch]@3
  int v16; // [sp+24h] [bp-58h]@3
  int v17; // [sp+2Ch] [bp-50h]@3
  int v18; // [sp+30h] [bp-4Ch]@3
  int v19; // [sp+34h] [bp-48h]@3
  int v20; // [sp+38h] [bp-44h]@9
  int v21; // [sp+3Ch] [bp-40h]@11
  unsigned int v22; // [sp+78h] [bp-4h]@1
  int v23; // [sp+7Ch] [bp+0h]@1

  v22 = (unsigned int)&v23 ^ __security_cookie;
  result = (int)sub_10030FE1(a1, ebp0, a2);
  if ( *(_BYTE *)(result + 4) >= 4u )
  {
    result = *(_DWORD *)result;
    if ( result & 0x20 )
    {
      sub_100391F0(&v10, 0, 118);
      v17 = 131072;
      v9 = 120;
      v13 = dword_10067324[0];
      v14 = dword_10067324[1];
      v15 = dword_10067324[2];
      v16 = dword_10067324[3];
      v18 = a4;
      v11 = a3;
      v12 = 4;
      v19 = a5;
      if ( a3 )
      {
        if ( a3 == 2 )
        {
          v20 = a6;
        }
        else
        {
          if ( a3 > 4 )
          {
            if ( a3 > 6 )
            {
              if ( a3 == 7 )
              {
                if ( a6 )
                  sub_1004498F(a1, a2, (int)&v20, 32, a6, -1);
              }
              return sub_10030F55(dword_100755B8, dword_100755B0, dword_100755B4, (int)&v9);
            }
            goto LABEL_11;
          }
        }
        return sub_10030F55(dword_100755B8, dword_100755B0, dword_100755B4, (int)&v9);
      }
LABEL_11:
      v20 = a6;
      v21 = a7;
      return sub_10030F55(dword_100755B8, dword_100755B0, dword_100755B4, (int)&v9);
    }
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 100755B0: using guessed type int dword_100755B0;
// 100755B4: using guessed type int dword_100755B4;
// 100755B8: using guessed type int dword_100755B8;

//----- (1003113F) --------------------------------------------------------
int __cdecl sub_1003113F()
{
  int result; // eax@2

  if ( dword_100755B8 )
  {
    byte_100755AC = 0;
    dword_100755A8 = 0;
    sub_10030F84(dword_100755B8, dword_100755C0, dword_100755C4);
    result = sub_1002A4AA((LPVOID)dword_100755B8);
    dword_100755B8 = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100755A8: using guessed type int dword_100755A8;
// 100755AC: using guessed type char byte_100755AC;
// 100755B8: using guessed type int dword_100755B8;
// 100755C0: using guessed type int dword_100755C0;
// 100755C4: using guessed type int dword_100755C4;

//----- (1003117F) --------------------------------------------------------
int __usercall sub_1003117F<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  LPVOID v3; // eax@1

  v3 = sub_1002B771(a1, a2, a3);
  return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v3 + 24))(v3);
}

//----- (10031190) --------------------------------------------------------
int __usercall sub_10031190<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  LPVOID v3; // eax@1

  v3 = sub_1002B771(a1, a2, a3);
  return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v3 + 28))(v3);
}

//----- (1003119C) --------------------------------------------------------
int __thiscall sub_1003119C(int this, int a2, char a3)
{
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = a2;
  *(_BYTE *)(this + 12) = a3;
  *(_DWORD *)this = &off_10060E1C;
  return this;
}
// 10060E1C: using guessed type int (__stdcall *off_10060E1C)(char);

//----- (100311BB) --------------------------------------------------------
void __thiscall sub_100311BB(int this)
{
  char v1; // zf@1

  v1 = *(_DWORD *)(this + 4) == 0;
  *(_DWORD *)this = &off_10060E1C;
  JUMPOUT(!v1, *(unsigned int *)sub_1003125D);
}
// 10060E1C: using guessed type int (__stdcall *off_10060E1C)(char);

//----- (100311CC) --------------------------------------------------------
void *__thiscall sub_100311CC(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_100311BB(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100311EB) --------------------------------------------------------
int __stdcall sub_100311EB(int a1, int a2)
{
  return (*(int (**)(void))(*(_DWORD *)a1 + 4))();
}

//----- (100311FA) --------------------------------------------------------
BOOL __thiscall sub_100311FA(char *Parameter)
{
  BOOL result; // eax@1
  HANDLE *v2; // esi@1
  DWORD v3; // ST14_4@4
  DWORD v4; // ST10_4@4
  void *v5; // ST0C_4@4
  int v6; // eax@4
  int (__stdcall **v7)(char); // [sp+4h] [bp-10h]@6
  int v8; // [sp+10h] [bp-4h]@6

  result = 0;
  v2 = (HANDLE *)(Parameter + 4);
  if ( !*((_DWORD *)Parameter + 1) )
  {
    if ( Parameter[12] )
      result = *((_DWORD *)Parameter + 2);
    v3 = result;
    v4 = *((_DWORD *)Parameter + 2);
    v5 = Parameter;
    v6 = sub_1002C20D();
    result = CreateTimerQueueTimer(v2, (HANDLE)v6, (WAITORTIMERCALLBACK)sub_100311EB, v5, v4, v3, 0x20u);
    if ( !result )
    {
      v8 = (int)"bad allocation";
      sub_1002AEC9((int)&v7, (int)&v8, 1);
      v7 = &off_1005F2C4;
      sub_100355BB((int)&v7, (int)&unk_1006AA70);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1003125D);
    }
  }
  return result;
}
// 1005F2C4: using guessed type int (__stdcall *off_1005F2C4)(char);

//----- (1003125D) --------------------------------------------------------
DWORD __thiscall sub_1003125D(int this)
{
  DWORD result; // eax@1
  int v2; // esi@1
  void *v3; // ST04_4@1
  int v4; // eax@1

  v2 = this;
  v3 = *(void **)(this + 4);
  v4 = sub_1002C20D();
  result = sub_1003B577((HANDLE)v4, v3, (HANDLE)0xFFFFFFFF);
  *(_DWORD *)(v2 + 4) = 0;
  return result;
}

//----- (10031279) --------------------------------------------------------
void *__thiscall sub_10031279(void *this)
{
  void *v2; // esi@1
  int v3; // edx@1

  v2 = this;
  *(_DWORD *)this = 0;
  v3 = *(_DWORD *)sub_1002B51D((int)((char *)this + 4));
  return v2;
}

//----- (10031290) --------------------------------------------------------
void *__thiscall sub_10031290(void *this, int a2, int a3, int a4)
{
  int ebp0; // ebp@0
  void *v6; // esi@1

  v6 = this;
  sub_1004067D(ebp0, a2, a3, a4);
  *(_DWORD *)v6 = &off_10060EF8;
  *((_DWORD *)v6 + 72) = 0;
  *((_DWORD *)v6 + 73) = (char *)v6 + 288;
  *((_DWORD *)v6 + 74) = 0;
  return v6;
}
// 10060EF8: using guessed type int (__stdcall *off_10060EF8)(char);

//----- (100312C7) --------------------------------------------------------
void *__thiscall sub_100312C7(void *this, int a2, int a3, int a4)
{
  int ebp0; // ebp@0
  void *v6; // esi@1

  v6 = this;
  sub_1004067D(ebp0, a2, a3, a4);
  *(_DWORD *)v6 = &off_10060F38;
  *((_DWORD *)v6 + 72) = 0;
  *((_DWORD *)v6 + 73) = (char *)v6 + 288;
  *((_DWORD *)v6 + 74) = 0;
  return v6;
}
// 10060F38: using guessed type int (__stdcall *off_10060F38)(char);

//----- (1003130E) --------------------------------------------------------
int __userpurge sub_1003130E<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  int v5; // esi@1
  unsigned int v7; // eax@1
  int v8; // eax@1
  signed int v9; // ST08_4@1

  v5 = a1;
  _ECX = 0;
  *(_DWORD *)v5 = a4;
  v7 = 4 * ((unsigned int)(a4 + 31) >> 5);
  __asm { seto    cl }
  v8 = sub_1002965B((a4 + 31) / 0x100u, v7 | -_ECX, a2, a3, v7 | -_ECX);
  v9 = 4 * ((unsigned int)(*(_DWORD *)v5 + 31) >> 5);
  *(_DWORD *)(v5 + 4) = v8;
  sub_100391F0((void *)v8, 0, v9);
  return v5;
}

//----- (10031354) --------------------------------------------------------
int __userpurge sub_10031354<eax>(int a1<ebp>, int a2)
{
  int v2; // ebx@1
  int v3; // edi@1
  int v4; // ecx@1
  const void **v5; // ST18_4@1
  int v6; // edx@1
  int v7; // esi@1
  int v8; // eax@2
  DWORD v9; // eax@4
  int v10; // eax@5
  int i; // eax@7
  HANDLE v12; // eax@9
  int v13; // eax@10
  int v14; // eax@14
  int v15; // eax@18
  int v17; // [sp-8h] [bp-8h]@7

  sub_10035648();
  v3 = v4;
  *(_DWORD *)(a1 - 16) = v4;
  v2 = *(_DWORD *)(a1 + 8);
  v5 = *(const void ***)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)v4 = &off_10060E94;
  sub_10044A6B(v6, v4 + 4, v2, v4, v5);
  *(_DWORD *)(v3 + 48) = 0;
  *(_DWORD *)(v3 + 52) = 0;
  *(_DWORD *)(v3 + 56) = 0;
  *(_DWORD *)(v3 + 60) = 0;
  *(_DWORD *)(v3 + 64) = 0;
  *(_DWORD *)(v3 + 68) = 0;
  *(_DWORD *)(v3 + 72) = 0;
  *(_DWORD *)(v3 + 76) = 0;
  *(_DWORD *)(v3 + 80) = 0;
  *(_DWORD *)(v3 + 84) = 0;
  *(_DWORD *)(v3 + 88) = 0;
  *(_BYTE *)(a1 - 4) = 5;
  sub_100458E3((void *)(v3 + 96), 0, 256, 64);
  *(_DWORD *)(v3 + 180) = 0;
  *(_BYTE *)(a1 - 4) = 6;
  sub_10031279((void *)(v3 + 184));
  sub_100458E3((void *)(v3 + 200), 0, 256, 2147483647);
  *(_BYTE *)(a1 - 4) = 7;
  sub_1002B4FD((LPCRITICAL_SECTION)(v3 + 280));
  *(_BYTE *)(a1 - 4) = 8;
  sub_10031279((void *)(v3 + 304));
  *(_DWORD *)(v3 + 316) = 0;
  *(_DWORD *)(v3 + 320) = v3 + 316;
  *(_DWORD *)(v3 + 324) = 0;
  *(_DWORD *)(v3 + 328) = -1;
  *(_DWORD *)(v3 + 332) = -1;
  *(_DWORD *)(v3 + 336) = 0;
  *(_DWORD *)(v3 + 340) = 0;
  *(_DWORD *)(v3 + 344) = 0;
  sub_1002E0B5(v3 + 348, v2, v3, 0x1001u);
  *(_BYTE *)(a1 - 4) = 9;
  sub_1002E0B5(v3 + 360, v2, v3, 0x1001u);
  *(_DWORD *)(v3 + 372) = -1;
  *(_DWORD *)(v3 + 376) = 0;
  *(_DWORD *)(v3 + 384) = 0;
  *(_DWORD *)(v3 + 388) = 0;
  *(_DWORD *)(v3 + 392) = 1;
  *(_DWORD *)(v3 + 396) = 0;
  *(_DWORD *)(v3 + 400) = 0;
  *(_DWORD *)(v3 + 404) = 0;
  *(_BYTE *)(a1 - 4) = 10;
  *(_DWORD *)(v3 + 408) = 0;
  *(_DWORD *)(v3 + 412) = 0;
  *(_DWORD *)(v3 + 416) = 0;
  *(_DWORD *)(v3 + 424) = 0;
  *(_DWORD *)(v3 + 432) = 0;
  *(_DWORD *)(v3 + 436) = 0;
  *(_DWORD *)(v3 + 440) = 0;
  *(_DWORD *)(v3 + 444) = 0;
  *(_DWORD *)(v3 + 448) = 0;
  *(_DWORD *)(v3 + 456) = 0;
  *(_DWORD *)(v3 + 472) = 0;
  InitializeSListHead((PSLIST_HEADER)(v3 + 480));
  InitializeSListHead((PSLIST_HEADER)(v3 + 488));
  InitializeSListHead((PSLIST_HEADER)(v3 + 496));
  InitializeSListHead((PSLIST_HEADER)(v3 + 504));
  *(_DWORD *)(v3 + 132) = v3;
  *(_DWORD *)(v3 + 8) = sub_10044B09((void *)v2, 0);
  *(_WORD *)(v3 + 16) = sub_10044B09((void *)v2, 4u);
  *(_DWORD *)(v3 + 12) = sub_10044B09((void *)v2, 7u);
  v7 = sub_10044B09((void *)v2, 1u);
  if ( 4 * sub_1003D68A() <= (unsigned int)v7 )
    v8 = sub_10044B09((void *)v2, 1u);
  else
    v8 = 4 * sub_1003D68A();
  *(_DWORD *)(v3 + 452) = v8;
  v9 = TlsAlloc();
  *(_DWORD *)(v3 + 24) = v9;
  if ( v9 != -1 )
    goto LABEL_9;
  v10 = GetLastError();
  if ( v10 > 0 )
    v10 = (unsigned __int16)v10 | 0x80070000;
  sub_10030079(a1 - 32, v10);
  v17 = (int)&unk_1006B6E0;
  for ( i = a1 - 32; ; i = a1 - 80 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        sub_100355BB(i, v17);
LABEL_9:
        v12 = CreateEventW(0, 0, 0, 0);
        *(_DWORD *)(v3 + 460) = v12;
        if ( v12 )
          break;
        v13 = GetLastError();
        if ( v13 > 0 )
          v13 = (unsigned __int16)v13 | 0x80070000;
        sub_10030079(a1 - 48, v13);
        v17 = (int)&unk_1006B6E0;
        i = a1 - 48;
      }
      if ( RegisterWaitForSingleObject(
             (PHANDLE)(v3 + 464),
             v12,
             (WAITORTIMERCALLBACK)sub_10034542,
             (PVOID)v3,
             0xFFFFFFFFu,
             0) )
        break;
      v14 = GetLastError();
      if ( v14 > 0 )
        v14 = (unsigned __int16)v14 | 0x80070000;
      sub_10030079(a1 - 64, v14);
      v17 = (int)&unk_1006B6E0;
      i = a1 - 64;
    }
    if ( CreateTimerQueueTimer(
           (PHANDLE)(v3 + 468),
           0,
           (WAITORTIMERCALLBACK)sub_10034533,
           (PVOID)v3,
           0x7FFFFFFFu,
           0x7FFFFFFFu,
           0) )
      break;
    v15 = GetLastError();
    if ( v15 > 0 )
      v15 = (unsigned __int16)v15 | 0x80070000;
    sub_10030079(a1 - 80, v15);
    v17 = (int)&unk_1006B6E0;
  }
  return sub_10035616(68);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 10060E94: using guessed type int (__stdcall *off_10060E94)(char);

//----- (1003165F) --------------------------------------------------------
void *__thiscall sub_1003165F(void *this)
{
  void *v2; // esi@1

  v2 = this;
  sub_100309FA((int)((char *)this + 4), 8, 96, (void (__thiscall *)(_DWORD))sub_1002CB37, (int)sub_1002CB4C);
  *((_BYTE *)v2 + 772) = 0;
  return v2;
}
// 1002CB37: using guessed type int sub_1002CB37();
// 1002CB4C: using guessed type int sub_1002CB4C();

//----- (10031684) --------------------------------------------------------
int __userpurge sub_10031684<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10060D08;
  return v4;
}
// 10060D08: using guessed type int (__stdcall *off_10060D08)(char);

//----- (1003169F) --------------------------------------------------------
int __userpurge sub_1003169F<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10060D14;
  return v4;
}
// 10060D14: using guessed type int (__stdcall *off_10060D14)(char);

//----- (100316BA) --------------------------------------------------------
int __userpurge sub_100316BA<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // edi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10060CE4;
  *(_DWORD *)(v4 + 12) = *(_DWORD *)(a3 + 12);
  return v4;
}
// 10060CE4: using guessed type int (__stdcall *off_10060CE4)(char);

//----- (100316DE) --------------------------------------------------------
int __thiscall sub_100316DE(PSLIST_HEADER ListHead)
{
  int v1; // ebx@1
  PSLIST_HEADER v2; // edi@1
  int v3; // eax@1
  int v4; // eax@1
  int i; // esi@2
  int v6; // esi@4

  v2 = ListHead;
  v3 = (int)InterlockedFlushSList(ListHead);
  sub_10032242(v3);
  v4 = (int)InterlockedFlushSList(v2 + 1);
  sub_10032242(v4);
  sub_10032242(LODWORD(v2[2].Alignment));
  v1 = LODWORD(v2[6].Alignment);
  if ( v1 )
  {
    do
    {
      for ( i = 0; i < LODWORD(v2[5].Alignment); ++i )
        sub_1002A4AA(*(LPVOID *)(*(_DWORD *)v1 + 4 * i));
      v6 = *(_DWORD *)(v1 + 4);
      sub_100303A3(*(LPVOID *)v1);
      sub_1002A4AA((LPVOID)v1);
      v1 = v6;
    }
    while ( v6 );
  }
  return sub_100303A3(HIDWORD(v2[6].Alignment));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (10031750) --------------------------------------------------------
int __thiscall sub_10031750(PSLIST_HEADER ListHead)
{
  int v1; // ebx@1
  PSLIST_HEADER v2; // edi@1
  int v3; // eax@1
  int v4; // eax@1
  int i; // esi@2
  int v6; // ecx@3
  int v7; // esi@6

  v2 = ListHead;
  v3 = (int)InterlockedFlushSList(ListHead);
  sub_10032260(v3);
  v4 = (int)InterlockedFlushSList(v2 + 1);
  sub_10032260(v4);
  sub_10032260(LODWORD(v2[2].Alignment));
  v1 = LODWORD(v2[6].Alignment);
  if ( v1 )
  {
    do
    {
      for ( i = 0; i < LODWORD(v2[5].Alignment); ++i )
      {
        v6 = *(_DWORD *)(*(_DWORD *)v1 + 4 * i);
        if ( v6 )
          (*(void (__stdcall **)(signed int))(*(_DWORD *)v6 + 16))(1);
      }
      v7 = *(_DWORD *)(v1 + 4);
      sub_100303A3(*(LPVOID *)v1);
      sub_1002A4AA((LPVOID)v1);
      v1 = v7;
    }
    while ( v7 );
  }
  return sub_100303A3(HIDWORD(v2[6].Alignment));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (100317C7) --------------------------------------------------------
int __thiscall sub_100317C7(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100303A3(*(LPVOID *)(this + 12));
  return sub_100303A3(*(LPVOID *)(v2 + 4));
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (100317DE) --------------------------------------------------------
int __thiscall sub_100317DE(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100303A3(*(LPVOID *)(this + 8));
  return sub_100303A3(*(LPVOID *)(v2 + 4));
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (10031803) --------------------------------------------------------
#error "100318AB: call analysis failed (funcsize=43)"

//----- (100318B8) --------------------------------------------------------
int __thiscall sub_100318B8(int this, signed int a2)
{
  signed int v2; // edx@1
  int v3; // esi@1
  int result; // eax@2
  int v5; // eax@3
  int v6; // ecx@3
  int v7; // eax@4
  int v8; // edx@4
  int v9; // edx@5

  v3 = this;
  v2 = a2 >> *(_DWORD *)(this + 44);
  if ( v2 < *(_DWORD *)(this + 60) )
  {
    v6 = *(_DWORD *)(this + 56);
    v5 = *(_DWORD *)(v3 + 52);
    if ( v2 < v6 )
    {
      v7 = *(_DWORD *)(v5 + 4 * v2);
    }
    else
    {
      v8 = v2 - v6;
      v7 = *(_DWORD *)(v5 + 4 * v6 - 4);
      if ( v8 >= 0 )
      {
        v9 = v8 + 1;
        do
        {
          v7 = *(_DWORD *)(v7 + 4);
          --v9;
        }
        while ( v9 );
      }
    }
    result = *(_DWORD *)(*(_DWORD *)v7 + 4 * (a2 & (*(_DWORD *)(v3 + 40) - 1)));
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100318FE) --------------------------------------------------------
int __thiscall sub_100318FE(int this, char a2)
{
  void *v2; // esi@1
  int result; // eax@4

  v2 = (void *)this;
  if ( a2 & 2 )
  {
    sub_1002B11F(this, 16, *(_DWORD *)(this - 4), sub_100317C7);
    if ( a2 & 1 )
      sub_100303A3((char *)v2 - 4);
    result = (int)((char *)v2 - 4);
  }
  else
  {
    sub_100317C7(this);
    if ( a2 & 1 )
      sub_1002A4AA(v2);
    result = (int)v2;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (10031948) --------------------------------------------------------
void *__thiscall sub_10031948(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_10060E30;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10060E30: using guessed type int (*off_10060E30[4])();

//----- (10031968) --------------------------------------------------------
void *__thiscall sub_10031968(void *this, char a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1

  v3 = this;
  sub_10040863(ebp0);
  if ( a2 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10031987) --------------------------------------------------------
void *__thiscall sub_10031987(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10060E80;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10060E80: using guessed type int (__stdcall *off_10060E80)(char);

//----- (100319A7) --------------------------------------------------------
void *__thiscall sub_100319A7(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_10060E48;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10060E48: using guessed type int (__stdcall *off_10060E48)(char);

//----- (100319C7) --------------------------------------------------------
void *__thiscall sub_100319C7(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_10031803(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10031803: using guessed type _DWORD __thiscall sub_10031803(_DWORD ecx0);

//----- (100319E6) --------------------------------------------------------
void *__thiscall sub_100319E6(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  sub_1002B11F((int)((char *)this + 4), 8, 96, (void (__thiscall *)(_DWORD))sub_1002CB4C);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1002CB4C: using guessed type int sub_1002CB4C();

//----- (10031A12) --------------------------------------------------------
int __thiscall sub_10031A12(int this, int a2)
{
  signed int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // edx@3
  int v12; // ecx@11
  signed __int64 v15; // qax@11
  signed int v16; // ST0C_4@11
  int v17; // edx@11
  int v18; // ecx@11
  int v19; // eax@12
  int v28; // edx@17
  char v30; // [sp+Ch] [bp-20h]@22
  int v31; // [sp+14h] [bp-18h]@21
  BOOL (__cdecl *v32)(); // [sp+18h] [bp-14h]@21
  int v33; // [sp+1Ch] [bp-10h]@5
  int v34; // [sp+20h] [bp-Ch]@2
  int v35; // [sp+24h] [bp-8h]@1
  char v36; // [sp+2Bh] [bp-1h]@1

  v5 = this;
  v3 = *(_DWORD *)(this + 48);
  v36 = 0;
  v4 = 0;
  v35 = v3;
  v2 = 4;
  do
  {
    _EBX = v3 + 8;
    v34 = v3 + 8;
    if ( *(_DWORD *)(v3 + 8) >= -1 )
    {
      _EBX = *(_DWORD *)v3;
      v7 = 0;
      if ( *(_DWORD *)(v5 + 40) <= 0 )
      {
LABEL_7:
        _EBX = v34;
      }
      else
      {
        while ( *(_DWORD *)_EBX )
        {
          ++v7;
          _EBX += v2;
          if ( v7 >= *(_DWORD *)(v5 + 40) )
            goto LABEL_7;
        }
        _ECX = a2;
        *(_DWORD *)(a2 + 24) = v7 + v4;
        v33 = *(_DWORD *)(v5 + 64);
        __asm { lock cmpxchg [ebx], ecx }
        v4 += v7;
        v36 = 1;
        if ( v4 >= v33 )
        {
          _EAX = v5 + 64;
          _ECX = 1;
          __asm { lock xadd [eax], ecx }
        }
        _EBX = v34;
        _ECX = -1;
        __asm { lock cmpxchg [ebx], ecx }
      }
      v3 = v35;
    }
    if ( !v36 )
    {
      _ECX = -2;
      __asm { lock cmpxchg [ebx], ecx }
      v4 += *(_DWORD *)(v5 + 40);
      _EBX = v3 + 4;
      if ( !*(_DWORD *)(v3 + 4) )
      {
        _ECX = 1;
        __asm { lock cmpxchg [ebx], ecx }
        _ECX = 0;
        v15 = 4i64 * *(_DWORD *)(v5 + 40);
        __asm { seto    cl }
        v16 = 4 * *(_DWORD *)(v5 + 40);
        v33 = sub_1002965B(SHIDWORD(v15), v15 | -_ECX, _EBX, v4, v15 | -_ECX);
        sub_100391F0((void *)v33, 0, v16);
        v12 = sub_1002ADB1(v17, v18, _EBX, v4, 12);
        if ( v12 )
        {
          v19 = v33;
          *(_DWORD *)(v12 + 4) = 0;
          *(_DWORD *)(v12 + 8) = -1;
          *(_DWORD *)v12 = v19;
        }
        else
        {
          v12 = 0;
        }
        v28 = *(_DWORD *)(v5 + 60);
        if ( v28 < *(_DWORD *)(v5 + 56) )
        {
          *(_DWORD *)(*(_DWORD *)(v5 + 52) + 4 * v28) = v12;
          ++*(_DWORD *)(v5 + 60);
        }
        *(_DWORD *)_EBX = v12;
        v3 = v35;
      }
      if ( *(_DWORD *)_EBX == 1 )
      {
        v31 = 0;
        v32 = sub_10034BF4;
        do
          sub_100282E0((int)&v30);
        while ( *(_DWORD *)_EBX == 1 );
        v3 = v35;
      }
    }
    v3 = *(_DWORD *)(v3 + 4);
    v35 = v3;
    v2 = 4;
  }
  while ( !v36 );
  return v4;
}

//----- (10031B6B) --------------------------------------------------------
int __userpurge sub_10031B6B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // eax@1
  int v6; // esi@1

  v6 = a2;
  v5 = sub_1002ADB1(a1, a2, a3, a4, 8);
  if ( v5 )
    *(_DWORD *)(v5 + 4) = a5;
  else
    v5 = 0;
  return sub_1003384B((void *)(v6 + 180), v5);
}

//----- (10031B98) --------------------------------------------------------
int __thiscall sub_10031B98(void *this, int a2)
{
  int result; // eax@2

  if ( *(_DWORD *)this )
  {
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(*(_DWORD *)this + 4);
    *(_DWORD *)(a2 + 8) = *(_DWORD *)this;
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)this + 4) + 8) = a2;
    result = *(_DWORD *)this;
    *(_DWORD *)(*(_DWORD *)this + 4) = a2;
  }
  else
  {
    *(_DWORD *)this = a2;
    *(_DWORD *)(a2 + 8) = a2;
    result = *(_DWORD *)this;
    *(_DWORD *)(result + 4) = result;
  }
  return result;
}

//----- (10031BD1) --------------------------------------------------------
int __thiscall sub_10031BD1(void *this, int a2)
{
  int result; // eax@1

  result = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    *(_DWORD *)a2 = *(_DWORD *)result;
    *(_DWORD *)(a2 + 4) = *(_DWORD *)this;
    *(_DWORD *)(**(_DWORD **)this + 4) = a2;
    result = *(_DWORD *)this;
    **(_DWORD **)this = a2;
  }
  else
  {
    *(_DWORD *)a2 = a2;
    *(_DWORD *)(a2 + 4) = a2;
  }
  *(_DWORD *)this = a2;
  return result;
}

//----- (10031BFE) --------------------------------------------------------
int __thiscall sub_10031BFE(int this, int a2)
{
  int v3; // edi@1

  v3 = this;
  sub_1002B98A((void *)(this + 4));
  sub_10031BD1((void *)v3, a2);
  return sub_1002BB74((void *)(v3 + 4));
}

//----- (10031C25) --------------------------------------------------------
int __thiscall sub_10031C25(void *this, int a2, unsigned int a3)
{
  int result; // eax@1
  void *v4; // edi@1
  unsigned int v5; // esi@2
  int *v6; // eax@3
  unsigned int v7; // ebx@4
  int v8; // eax@5
  int v9; // ecx@5
  int v17; // [sp-4h] [bp-34h]@3
  int (__stdcall **v18)(char); // [sp+Ch] [bp-24h]@3
  int (__stdcall **v19)(char); // [sp+18h] [bp-18h]@9
  int v20; // [sp+24h] [bp-Ch]@5
  int v21; // [sp+28h] [bp-8h]@5
  int v22; // [sp+2Ch] [bp-4h]@3

  result = a2;
  v4 = this;
  if ( !a2 )
  {
    a3 = (unsigned int)"ppVirtualProcessorRoots";
    sub_1002AEA4((int)&v19, (int *)&a3);
    v19 = &off_1005F2EC;
    v17 = (int)&unk_1006C8B4;
    v6 = (int *)&v19;
    goto LABEL_10;
  }
  v5 = a3;
  if ( a3 < 1 )
  {
    v22 = (int)"count";
    sub_1002AEA4((int)&v18, &v22);
    v18 = &off_1005F2EC;
    v17 = (int)&unk_1006C8B4;
    v6 = (int *)&v18;
LABEL_10:
    sub_100355BB((int)v6, v17);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10031CE9);
  }
  v7 = 0;
  if ( a3 )
  {
    do
    {
      v20 = *(_DWORD *)(result + 4 * v7);
      v8 = (**(int (***)(void))v20)();
      v9 = *((_DWORD *)v4 + 9);
      v21 = v8;
      if ( !*(_DWORD *)(*(_DWORD *)(v9 + 4 * v8) + 188) )
      {
        sub_100473F5(*(_DWORD *)(*((_DWORD *)v4 + 9) + 4 * v8));
        v8 = v21;
      }
      sub_10045C60(*(void **)(*((_DWORD *)v4 + 8) + 4 * v8), v20, 0);
      _EAX = 1;
      _ECX = (int)((char *)v4 + 20);
      __asm { lock xadd [ecx], eax }
      result = a2;
      ++v7;
    }
    while ( v7 < v5 );
  }
  return result;
}
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);

//----- (10031CE9) --------------------------------------------------------
int __userpurge sub_10031CE9<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@1

  sub_10035648();
  v6 = v7;
  v5 = sub_1002ADB1(v8, v7, a1, a3, 304);
  *(_DWORD *)(a2 - 16) = v5;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v5 )
    sub_10031290((void *)v5, v6, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12));
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (10031D24) --------------------------------------------------------
int __userpurge sub_10031D24<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // ecx@1
  int v7; // edx@1

  sub_10035648();
  v5 = v6;
  *(_DWORD *)(a2 - 32) = 0;
  *(_DWORD *)(a2 - 24) = 0;
  *(_DWORD *)(a2 - 20) = 0;
  v4 = sub_1002ADB1(v7, v6, a1, v6, 304);
  *(_DWORD *)(a2 - 16) = v4;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v4 )
    sub_100312C7((void *)v4, v5, *(_DWORD *)(a2 + 8), a2 - 32);
  return sub_10035616(20);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (10031D6D) --------------------------------------------------------
char __cdecl sub_10031D6D()
{
  return 1;
}

//----- (10031D70) --------------------------------------------------------
int __usercall sub_10031D70<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // esi@1
  char v4; // [sp+4h] [bp-Ch]@3

  v2 = a1;
  if ( sub_10032363() == a1 )
  {
    sub_1002FF67((int)&v4);
    sub_100355BB((int)&v4, (int)&unk_1006B750);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10031DB6);
  }
  sub_10031DB6((void *)v2, a2, 1);
  return sub_1003468C(7, 4, *(_DWORD *)(v2 + 372));
}

//----- (10031DB6) --------------------------------------------------------
int __userpurge sub_10031DB6<eax>(void *a1<ecx>, int a2<ebx>, int a3)
{
  LPVOID v3; // eax@1
  int ebp0; // ebp@0
  int v5; // edi@1
  void *v6; // esi@1
  int v8; // esi@6
  char v9; // [sp+8h] [bp-Ch]@7

  v6 = a1;
  v3 = sub_10032356();
  v5 = (int)v3;
  if ( v3 )
  {
    if ( *((void **)v3 + 7) == v6 )
    {
      sub_1002FF67((int)&v9);
      sub_100355BB((int)&v9, (int)&unk_1006B750);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_10031E1F);
    }
    if ( !*((_BYTE *)v3 + 76) )
      sub_10046998((char *)v3 - 4);
    sub_1002E737();
  }
  sub_10033987(v6);
  v8 = sub_100328DC(a2, ebp0, a3);
  sub_1002EC99((LPVOID)v8, v5);
  return v8;
}

//----- (10031E1F) --------------------------------------------------------
BOOL __thiscall sub_10031E1F(void *this)
{
  _ESI = -1073741824;
  _EDX = (char *)this + 404;
  __asm { lock cmpxchg [edx], esi }
  return sub_10034384(this);
}

//----- (10031E42) --------------------------------------------------------
int __thiscall sub_10031E42(void *this)
{
  int result; // eax@1
  int i; // esi@1
  int v3; // esi@1
  int v4; // ecx@1

  v3 = (int)this;
  sub_1002EF93(this);
  sub_10033B41(v3);
  result = sub_1002EF93(v4);
  for ( i = *(_DWORD *)(v3 + 180); i; i = *(_DWORD *)i )
    result = (*(int (**)(void))(**(_DWORD **)(i + 4) + 24))();
  return result;
}
// 1002EF93: using guessed type _DWORD __thiscall sub_1002EF93(_DWORD ecx0);

//----- (10031ECA) --------------------------------------------------------
int __cdecl sub_10031ECA(int a1)
{
  int result; // eax@1

  result = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 404) & 0xA0000000;
  if ( result != -1610612736 )
  {
    sub_10032242(*(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    *(_DWORD *)(a1 + 72) = 0;
  }
  return result;
}

//----- (10031ED6) --------------------------------------------------------
int __cdecl sub_10031ED6(int a1)
{
  int result; // eax@1

  result = *(_DWORD *)(*(_DWORD *)(a1 + 36) + 404) & 0xA0000000;
  if ( result != -1610612736 )
  {
    sub_10032260(*(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    *(_DWORD *)(a1 + 72) = 0;
  }
  return result;
}

//----- (10031EE2) --------------------------------------------------------
int __cdecl sub_10031EE2()
{
  int result; // eax@1

  _ESI = &dword_10072D14;
  _EAX = -1;
  __asm { lock xadd [esi], eax }
  result = _EAX - 1;
  if ( result == -2147483648 )
  {
    sub_1003357F();
    result = 2147483647;
    __asm { lock and [esi], eax }
  }
  return result;
}
// 10072D14: using guessed type int dword_10072D14;

//----- (10031F06) --------------------------------------------------------
int __usercall sub_10031F06<eax>(int a1<ebp>)
{
  int v1; // eax@1

  sub_10035648();
  *(_DWORD *)(a1 - 16) = &dword_10075F4C;
  sub_10030FB0(&dword_10075F4C);
  v1 = dword_100755E0;
  *(_DWORD *)(a1 - 4) = 0;
  dword_100755E0 = v1 + 1;
  if ( dword_100755E0 == 1 )
  {
    sub_100341E8();
    _ESI = -2147483648;
    if ( !(dword_10072D14 & 0x80000000) )
    {
      sub_10033531();
      _EAX = &dword_10072D14;
      __asm { lock or [eax], esi }
    }
  }
  dword_10075F4C = 0;
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 10072D14: using guessed type int dword_10072D14;
// 100755E0: using guessed type int dword_100755E0;
// 10075F4C: using guessed type int dword_10075F4C;

//----- (10031F62) --------------------------------------------------------
int __usercall sub_10031F62<eax>(int a1<ecx>, int a2<ebp>)
{
  int i; // edi@1
  int v3; // esi@1
  void *v4; // ebx@2
  int j; // edi@5
  void *v6; // ebx@6
  int v7; // ecx@9
  int v8; // ecx@11
  char v9; // zf@11
  PSINGLE_LIST_ENTRY v10; // eax@14

  v3 = a1;
  for ( i = 0; i < *(_DWORD *)(v3 + 44); ++i )
  {
    v4 = *(void **)(*(_DWORD *)(v3 + 32) + 4 * i);
    if ( v4 )
    {
      sub_10045AC7(a2);
      sub_1002A4AA(v4);
    }
  }
  for ( j = 0; j < *(_DWORD *)(v3 + 44); ++j )
  {
    v6 = *(void **)(*(_DWORD *)(v3 + 36) + 4 * j);
    if ( v6 )
    {
      sub_100473C2(a2);
      sub_1002A4AA(v6);
    }
  }
  sub_100303A3(*(LPVOID *)(v3 + 92));
  sub_100303A3(*(LPVOID *)(v3 + 32));
  sub_100303A3(*(LPVOID *)(v3 + 36));
  v7 = *(_DWORD *)(v3 + 28);
  if ( v7 )
    sub_100318FE(v7, 3);
  TlsFree(*(_DWORD *)(v3 + 24));
  v8 = *(_DWORD *)(v3 + 416);
  *(_DWORD *)(v3 + 24) = 0;
  (*(void (**)(void))(*(_DWORD *)v8 + 4))();
  sub_10035648();
  *(_DWORD *)(a2 - 16) = &dword_10075F4C;
  sub_10030FB0(&dword_10075F4C);
  *(_DWORD *)(a2 - 4) = 0;
  v9 = dword_100755E0-- == 1;
  if ( v9 )
  {
    sub_1003113F();
    while ( 1 )
    {
      v10 = InterlockedPopEntrySList(&ListHead);
      if ( !v10 )
        break;
      sub_100319E6(v10, 1);
    }
  }
  dword_10075F4C = 0;
  return sub_10035616(4);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 100755E0: using guessed type int dword_100755E0;
// 10075F4C: using guessed type int dword_10075F4C;

//----- (10031FFA) --------------------------------------------------------
int __thiscall sub_10031FFA(int this)
{
  signed int i; // eax@1
  void *v2; // ebx@1
  int v3; // edi@1
  int result; // eax@3
  unsigned int v5; // esi@3

  v3 = this;
  v2 = (void *)(this + 324);
  sub_10034B9B((void *)(this + 324));
  for ( i = sub_10034761(v3); ; i = sub_10034719(v3, v5) )
  {
    v5 = i;
    result = sub_10034BAB(v2);
    if ( !v5 )
      break;
    sub_1003203D(v3, v5);
    sub_10034B9B(v2);
  }
  return result;
}

//----- (1003203D) --------------------------------------------------------
int __thiscall sub_1003203D(int this, unsigned int a2)
{
  int v2; // eax@1
  int v3; // ebx@1
  int v4; // edi@1
  unsigned int v5; // eax@3
  int v6; // eax@5
  int v7; // esi@5
  int result; // eax@7
  int v9; // eax@8
  int v10; // [sp+8h] [bp-Ch]@1
  int *v11; // [sp+Ch] [bp-8h]@1
  int v12; // [sp+10h] [bp-4h]@1

  v10 = 0;
  v4 = this;
  v3 = this + 324;
  v11 = &v10;
  v12 = this + 324;
  sub_10034B9B((void *)(this + 324));
  v2 = *(_DWORD *)(v4 + 316);
  if ( v2 )
  {
    do
    {
      if ( a2 )
      {
        v5 = *(_DWORD *)(v2 + 8);
        if ( v5 < *(_DWORD *)(v4 + 340) )
          break;
        if ( v5 > a2 )
          break;
      }
      v6 = sub_1003229F((void *)(v4 + 316));
      v7 = v6 + 12;
      *(_DWORD *)(v6 + 12) = 0;
      *v11 = v6;
      v2 = *(_DWORD *)(v4 + 316);
      v11 = (int *)v7;
    }
    while ( v2 );
    v3 = v12;
  }
  result = sub_10034BAB((void *)v3);
  while ( v10 )
  {
    v9 = sub_1003229F(&v10);
    result = (*(int (__cdecl **)(_DWORD))v9)(*(_DWORD *)(v9 + 4));
  }
  return result;
}

//----- (100320CA) --------------------------------------------------------
signed int __thiscall sub_100320CA(int this)
{
  int v1; // ebx@1
  signed int v2; // edi@1
  int v3; // esi@1
  int v4; // eax@2
  signed int v5; // ecx@3
  int v6; // eax@4
  int v7; // eax@5
  signed int v8; // eax@6
  int v10; // [sp+Ch] [bp-10h]@2
  int v11; // [sp+10h] [bp-Ch]@1
  signed int v12; // [sp+14h] [bp-8h]@3
  char v13; // [sp+1Bh] [bp-1h]@1

  v1 = this;
  v3 = 0;
  v2 = 0;
  v13 = 0;
  v11 = 0;
  if ( *(_DWORD *)(this + 44) > 0 )
  {
    while ( 1 )
    {
      v4 = *(_DWORD *)(*(_DWORD *)(v1 + 32) + 4 * v3);
      v10 = v4;
      if ( v4 )
      {
        v5 = 0;
        v12 = 0;
        if ( *(_DWORD *)(v4 + 120) > 0 )
          break;
      }
LABEL_15:
      ++v3;
      v11 = v3;
      if ( v3 >= *(_DWORD *)(v1 + 44) )
        return v2;
    }
    v6 = v4 + 56;
    while ( 1 )
    {
      v7 = sub_100318B8(v6, v5);
      if ( v7 )
      {
        v8 = *(_DWORD *)(v7 + 180);
        if ( (unsigned int)v8 < *(_DWORD *)(v1 + 340) )
          v8 = -1;
        if ( !v13 )
        {
          v13 = 1;
LABEL_12:
          v2 = v8;
          goto LABEL_13;
        }
        if ( v2 > (unsigned int)v8 )
          goto LABEL_12;
      }
LABEL_13:
      v5 = v12 + 1;
      v12 = v5;
      v6 = v10 + 56;
      if ( v5 >= *(_DWORD *)(v10 + 120) )
      {
        v3 = v11;
        goto LABEL_15;
      }
    }
  }
  return v2;
}

//----- (10032153) --------------------------------------------------------
int __userpurge sub_10032153<eax>(int a1<ecx>, int a2<edi>, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  unsigned int v5; // edx@3
  unsigned int v6; // edi@3

  result = *(_DWORD *)a3;
  v4 = a1;
  if ( *(_DWORD *)a1 != *(_DWORD *)a3 )
    result = sub_100338CD(a1, a3, a2, *(_DWORD *)a3);
  v5 = (unsigned int)(*(_DWORD *)v4 + 31) >> 5;
  v6 = 0;
  if ( v5 )
  {
    do
    {
      result = *(_DWORD *)(*(_DWORD *)(a3 + 4) + 4 * v6);
      *(_DWORD *)(*(_DWORD *)(v4 + 4) + 4 * v6++) = result;
    }
    while ( v6 < v5 );
  }
  return result;
}

//----- (100321B0) --------------------------------------------------------
int __stdcall sub_100321B0(int a2)
{
  int v2; // ST00_4@1

  return sub_10033278(v2, a2);
}

//----- (100321B9) --------------------------------------------------------
int __cdecl sub_100321B9()
{
  int ebp0; // ebp@0
  int v2; // [sp+0h] [bp-10h]@1
  int v3; // [sp+8h] [bp-8h]@1
  int v4; // [sp+Ch] [bp-4h]@1

  v2 = 0;
  v3 = 0;
  v4 = 0;
  return sub_10033278(ebp0, (int)&v2);
}

//----- (100321D5) --------------------------------------------------------
int __usercall sub_100321D5<eax>(int a1<ebx>, int a2<edi>, void *a3)
{
  int v3; // eax@1
  int ebp0; // ebp@0
  int result; // eax@2

  sub_10044D76(a3);
  sub_10031F06(ebp0);
  v3 = sub_10047CEB(a1, ebp0, a2);
  if ( v3 )
    result = v3 + 8;
  else
    result = 0;
  return result;
}

//----- (100321FB) --------------------------------------------------------
int __usercall sub_100321FB<eax>(int this<ecx>, int a2<ebx>, int a3<ebp>, int a4<edi>)
{
  int v4; // eax@1

  v4 = (int)sub_1002B771(a2, a3, a4);
  return sub_10032DD0(v4);
}

//----- (10032207) --------------------------------------------------------
int __thiscall sub_10032207(int this)
{
  int result; // eax@1

  result = this + 392;
  _EDX = -1;
  __asm { lock xadd [eax], edx }
  if ( _EDX == 1 )
    result = sub_10032393(this);
  return result;
}

//----- (10032222) --------------------------------------------------------
BOOL __thiscall sub_10032222(int this)
{
  BOOL result; // eax@1

  _EDX = this + 472;
  _EAX = 1;
  __asm { lock xadd [edx], eax }
  result = _EAX + 1;
  if ( result == 1 )
    result = SetEvent(*(HANDLE *)(this + 460));
  return result;
}

//----- (10032242) --------------------------------------------------------
int __stdcall sub_10032242(int a1)
{
  int v1; // esi@1
  void *v2; // eax@2
  int result; // eax@2

  v1 = a1;
  while ( v1 )
  {
    v2 = (void *)(v1 - 4);
    v1 = *(_DWORD *)v1;
    result = sub_1002A4AA(v2);
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10032260) --------------------------------------------------------
int __stdcall sub_10032260(int a1)
{
  int v1; // esi@1
  int v2; // ecx@2
  int result; // eax@3

  v1 = a1;
  while ( v1 )
  {
    v2 = v1 - 52;
    v1 = *(_DWORD *)v1;
    if ( v2 )
      result = (*(int (__stdcall **)(signed int))(*(_DWORD *)v2 + 16))(1);
  }
  return result;
}

//----- (10032282) --------------------------------------------------------
int __thiscall sub_10032282(void *this)
{
  void *v1; // eax@1
  int v2; // edx@1
  int result; // eax@2
  int v4; // ecx@3

  v1 = this;
  v2 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    v4 = *(_DWORD *)(v2 + 232);
    *(_DWORD *)v1 = v4;
    if ( !v4 )
      *((_DWORD *)v1 + 1) = v1;
    result = v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1003229F) --------------------------------------------------------
int __thiscall sub_1003229F(void *this)
{
  void *v1; // eax@1
  int v2; // edx@1
  int result; // eax@2
  int v4; // ecx@3

  v1 = this;
  v2 = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    v4 = *(_DWORD *)(v2 + 12);
    *(_DWORD *)v1 = v4;
    if ( !v4 )
      *((_DWORD *)v1 + 1) = v1;
    result = v2;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100322DC) --------------------------------------------------------
int __thiscall sub_100322DC(int this)
{
  int v2; // esi@1

  v2 = this;
  UnregisterWaitEx(*(HANDLE *)(this + 464), (HANDLE)0xFFFFFFFF);
  sub_1003B577(0, *(HANDLE *)(v2 + 468), (HANDLE)0xFFFFFFFF);
  CloseHandle(*(HANDLE *)(v2 + 460));
  return sub_10032207(v2);
}

//----- (10032313) --------------------------------------------------------
char __thiscall sub_10032313(void *this, int a2, char a3)
{
  int v3; // edi@1
  int v4; // esi@1
  char result; // al@3

  v4 = 0;
  v3 = (int)this;
  if ( a3 )
    v4 = sub_1002EBD5(a2);
  sub_10033A64(v3, a2);
  result = sub_10033AAB((void *)v3);
  if ( v4 )
  {
    result = *(_BYTE *)(v4 + 76);
    if ( !result )
      result = sub_10046BF2((void *)(v4 - 4));
  }
  return result;
}

//----- (10032356) --------------------------------------------------------
LPVOID __cdecl sub_10032356()
{
  return TlsGetValue(dwTlsIndex);
}

//----- (10032363) --------------------------------------------------------
int __cdecl sub_10032363()
{
  int v1; // eax@1
  int result; // eax@2

  v1 = (int)sub_10032356();
  if ( v1 )
    result = sub_10032DD0(v1);
  else
    result = 0;
  return result;
}

//----- (10032376) --------------------------------------------------------
int __thiscall sub_10032376(int this)
{
  unsigned int v1; // edx@1
  unsigned int v2; // esi@1
  int result; // eax@2

  v1 = (unsigned int)(*(_DWORD *)this + 31) >> 5;
  v2 = 0;
  if ( v1 )
  {
    do
    {
      result = *(_DWORD *)(this + 4);
      *(_DWORD *)(result + 4 * v2++) = -1;
    }
    while ( v2 < v1 );
  }
  return result;
}

//----- (10032393) --------------------------------------------------------
int __thiscall sub_10032393(int this)
{
  int v1; // ecx@1
  int v2; // edi@1
  int v3; // esi@1
  int v4; // ecx@2
  int v5; // ebx@2
  int v6; // ST08_4@4
  int v7; // ecx@5
  int v8; // eax@5
  int v9; // esi@6
  int v10; // ecx@7
  PSINGLE_LIST_ENTRY v11; // eax@7
  int v12; // esi@8
  void *v13; // esi@10

  v2 = this;
  (*(void (**)(void))(**(_DWORD **)(this + 420) + 4))();
  CloseHandle(*(HANDLE *)(v2 + 380));
  v3 = *(_DWORD *)(v2 + 180);
  *(_DWORD *)(v2 + 180) = 0;
  if ( v3 )
  {
    do
    {
      v4 = *(_DWORD *)(v3 + 4);
      v5 = *(_DWORD *)v3;
      if ( v4 )
        (*(void (__stdcall **)(signed int))(*(_DWORD *)(v4 + 4) + 20))(1);
      sub_1002A4AA((LPVOID)v3);
      v1 = v6;
      v3 = v5;
    }
    while ( v5 );
  }
  v8 = ((int (__thiscall *)(int, int))InterlockedFlushSList)(v1, v2 + 488);
  v7 = v8 != 0 ? v8 - 4 : 0;
  if ( v7 )
  {
    do
    {
      v9 = *(_DWORD *)(v7 + 4) != 0 ? *(_DWORD *)(v7 + 4) - 4 : 0;
      (*(void (__stdcall **)(signed int))(*(_DWORD *)v7 + 20))(1);
      v7 = v9;
    }
    while ( v9 );
  }
  v11 = InterlockedFlushSList((PSLIST_HEADER)(v2 + 496));
  v10 = v11 != 0 ? (int)&v11[-3] : 0;
  if ( v10 )
  {
    do
    {
      v12 = *(_DWORD *)(v10 + 12) != 0 ? *(_DWORD *)(v10 + 12) - 12 : 0;
      (**(void (__stdcall ***)(_DWORD))v10)(1);
      v10 = v12;
    }
    while ( v12 );
  }
  sub_1003468C(2, 4, *(_DWORD *)(v2 + 372));
  while ( *(_DWORD *)(v2 + 184) )
  {
    v13 = sub_10033E26(v2 + 184);
    SetEvent(*((HANDLE *)v13 + 2));
    CloseHandle(*((HANDLE *)v13 + 2));
    sub_1002A4AA(v13);
  }
  return (**(int (__thiscall ***)(_DWORD, _DWORD))v2)(v2, 1);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1003248C) --------------------------------------------------------
int __thiscall sub_1003248C(unsigned int *this, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // eax@1

  v4 = (int)this;
  v5 = sub_1002D18F(a2, *this);
  result = sub_1002D1BB(v4, a2, v5);
  if ( result )
  {
    if ( a3 )
      *(_DWORD *)a3 = *(_DWORD *)(result + 8);
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100324C2) --------------------------------------------------------
int __thiscall sub_100324C2(void *this)
{
  LPVOID v1; // eax@1
  int v2; // ebx@1
  LPVOID v3; // edi@1
  void *v4; // esi@1

  v4 = this;
  v2 = 0;
  v1 = sub_10032356();
  v3 = v1;
  if ( v1 )
  {
    if ( *((void **)v1 + 7) == v4 )
    {
      if ( !*((_BYTE *)v1 + 76) )
      {
        sub_1004EAE4();
        v2 = *(_DWORD *)(*((_DWORD *)v3 + 39) + 68);
        sub_1004EAE4();
      }
    }
  }
  return v2;
}

//----- (100324FD) --------------------------------------------------------
int __thiscall sub_100324FD(int this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v5; // [sp+8h] [bp-4h]@3

  v2 = this;
  v3 = 0;
  if ( (*(_DWORD *)a2 & 0xFFFFFFF) == 2 )
  {
    v3 = *(_DWORD *)(*(_DWORD *)(this + 32) + 4 * *(_DWORD *)(a2 + 8));
  }
  else
  {
    if ( (*(_DWORD *)a2 & 0xFFFFFFF) == 3 )
    {
      a2 = *(_DWORD *)(a2 + 8);
      if ( sub_1003248C((unsigned int *)(this + 348), (int)&a2, (int)&v5) )
        v3 = *(_DWORD *)(*(_DWORD *)(v2 + 32) + 4 * v5);
    }
  }
  return v3;
}

//----- (10032551) --------------------------------------------------------
int __stdcall sub_10032551(int a1, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // esi@1

  v5 = a1;
  for ( result = 0; v5 < a2 && !result; result = sub_100318B8(a4, v5++) )
    ;
  *(_DWORD *)a3 = v5 - 1;
  return result;
}

//----- (1003257C) --------------------------------------------------------
int __thiscall sub_1003257C(void *this, int a2, int a3, int a4)
{
  int result; // eax@1
  void *v5; // edi@1
  int v6; // esi@1

  v6 = a2;
  v5 = this;
  for ( result = 0; v6 < a3 && !result; result = sub_100318B8((int)((char *)v5 + 56), v6++) )
    ;
  *(_DWORD *)a4 = v6 - 1;
  return result;
}

//----- (100325AB) --------------------------------------------------------
char __thiscall sub_100325AB(int this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  char v7; // bl@1
  int v8; // esi@1
  int v9; // edi@3
  int v10; // eax@6
  unsigned int v11; // edi@6
  int v12; // edi@10
  int v13; // ecx@11
  char v15; // [sp-14h] [bp-28h]@4
  int v16; // [sp-10h] [bp-24h]@4
  int v17; // [sp-Ch] [bp-20h]@4
  int v18; // [sp-8h] [bp-1Ch]@4
  int v19; // [sp-4h] [bp-18h]@4
  int v20; // [sp+10h] [bp-4h]@6

  v7 = 1;
  v8 = this;
  if ( (a3 & 0xFFFFFFF) != 1 )
  {
    if ( (a3 & 0xFFFFFFFu) - 2 <= 1 )
    {
      v9 = sub_100324FD(this, (int)&a3);
      if ( v9 )
      {
        v19 = a7;
        sub_1002F3E5((int)&v15, (int)&a3);
        if ( sub_10045DE3((void *)v9, a2, *(int *)&v15, v16, v17, v18, v19) )
          return v7;
      }
    }
    goto LABEL_10;
  }
  v10 = *(_DWORD *)(this + 28) + 16 * a5;
  v11 = 0;
  v20 = *(_DWORD *)(this + 28) + 16 * a5;
  if ( *(_DWORD *)(this + 44) <= 0 )
  {
LABEL_10:
    v12 = 0;
    if ( *(_DWORD *)(v8 + 44) <= 0 )
    {
LABEL_15:
      v7 = 0;
    }
    else
    {
      while ( 1 )
      {
        v13 = *(_DWORD *)(*(_DWORD *)(v8 + 32) + 4 * v12);
        if ( v13 )
        {
          if ( *(_DWORD *)(v13 + 28) > 0 )
          {
            *(_DWORD *)&v15 &= 0xF0000000u;
            *(_DWORD *)&v15 &= 0xFFFFFFFu;
            if ( sub_10045DE3((void *)v13, a2, *(int *)&v15, v16, 0, 0, a7) )
              break;
          }
        }
        ++v12;
        if ( v12 >= *(_DWORD *)(v8 + 44) )
          goto LABEL_15;
      }
    }
    return v7;
  }
  while ( 1 )
  {
    if ( (1 << (v11 & 0x1F)) & *(_DWORD *)(*(_DWORD *)(v10 + 4) + 4 * (v11 >> 5)) )
    {
      v19 = a7;
      sub_1002F3E5((int)&v15, (int)&a3);
      if ( sub_10045DE3(*(void **)(*(_DWORD *)(v8 + 32) + 4 * v11), a2, *(int *)&v15, v16, v17, v18, v19) )
        return v7;
    }
    v10 = v20;
    ++v11;
    if ( (signed int)v11 >= *(_DWORD *)(v8 + 44) )
      goto LABEL_10;
  }
}

//----- (100326A8) --------------------------------------------------------
char __thiscall sub_100326A8(int this)
{
  char v1; // dl@1
  int v2; // ecx@1

  v2 = *(_DWORD *)(this + 180);
  v1 = 0;
  while ( v2 )
  {
    if ( !*(_BYTE *)(*(_DWORD *)(v2 + 4) + 236) && *(_DWORD *)(*(_DWORD *)(v2 + 4) + 44) )
      return 1;
    v2 = *(_DWORD *)v2;
  }
  return v1;
}

//----- (100326D2) --------------------------------------------------------
char __thiscall sub_100326D2(void *this)
{
  void *v1; // eax@1
  int v2; // ecx@1
  char v3; // bl@1
  int v4; // esi@2
  signed int v5; // edi@3
  int v6; // eax@4
  signed int v7; // edi@12
  int v8; // eax@13
  void *v10; // [sp+4h] [bp-Ch]@1
  void *v11; // [sp+8h] [bp-8h]@4
  void *v12; // [sp+8h] [bp-8h]@13
  int i; // [sp+Ch] [bp-4h]@1

  v1 = this;
  v2 = 0;
  v3 = 0;
  v10 = v1;
  for ( i = 0; v2 < *((_DWORD *)v10 + 11); i = v2 )
  {
    v4 = *(_DWORD *)(*((_DWORD *)v1 + 9) + 4 * v2);
    if ( v4 )
    {
      v5 = 0;
      if ( *(_DWORD *)(v4 + 80) > 0 )
      {
        while ( 1 )
        {
          v6 = sub_100318B8(v4 + 16, v5);
          v11 = (void *)v6;
          if ( v6 )
          {
            if ( sub_10041066(v6) || sub_1004106F(v11) )
              break;
          }
          ++v5;
          if ( v5 >= *(_DWORD *)(v4 + 80) )
            goto LABEL_10;
        }
        v3 = 1;
LABEL_10:
        v2 = i;
      }
      if ( v3 )
        return v3;
      v7 = 0;
      if ( *(_DWORD *)(v4 + 160) > 0 )
      {
        while ( 1 )
        {
          v8 = sub_100318B8(v4 + 96, v7);
          v12 = (void *)v8;
          if ( v8 )
          {
            if ( sub_10041066(v8) || sub_1004106F(v12) )
              break;
          }
          ++v7;
          if ( v7 >= *(_DWORD *)(v4 + 160) )
            goto LABEL_19;
        }
        v3 = 1;
LABEL_19:
        v2 = i;
      }
    }
    v1 = v10;
    ++v2;
  }
  return v3;
}

//----- (10032799) --------------------------------------------------------
int __thiscall sub_10032799(int this)
{
  return *(_DWORD *)(sub_10032B10(this) + 8);
}

//----- (100327A2) --------------------------------------------------------
int __userpurge sub_100327A2<eax>(int a1<ebp>, int a2, int a3)
{
  int v3; // eax@1
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // eax@1
  int v9; // eax@2
  int v10; // eax@3
  int v11; // eax@6

  sub_10035648();
  v5 = v7;
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)(a1 - 16) = 0;
  v8 = sub_1003D68A();
  v6 = *(_DWORD *)(a1 + 8);
  sub_1003130E(*(_DWORD *)(a1 + 8), 0, v5, v8);
  v4 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 - 4) = 0;
  v3 = *(_DWORD *)v4 & 0xFFFFFFF;
  *(_DWORD *)(a1 - 16) = 1;
  if ( !v3 )
  {
    sub_10032376(v6);
    return sub_10035616(4);
  }
  v9 = v3 - 1;
  if ( !v9 )
  {
    v11 = 16 * *(_DWORD *)(v4 + 8) + 8 + *(_DWORD *)(v5 + 28);
    goto LABEL_8;
  }
  v10 = v9 - 1;
  if ( !v10 )
  {
    v11 = *(_DWORD *)(*(_DWORD *)(v5 + 32) + 4 * *(_DWORD *)(v4 + 8)) + 8;
LABEL_8:
    sub_10032153(v6, v5, v11);
    return sub_10035616(4);
  }
  if ( v10 == 1 )
  {
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(v4 + 8);
    sub_1003248C((unsigned int *)(v5 + 360), a1 + 8, a1 + 12);
    *(_DWORD *)(*(_DWORD *)(v6 + 4) + 4 * (*(_DWORD *)(a1 + 12) >> 5)) |= 1 << (*(_DWORD *)(a1 + 12) & 0x1F);
  }
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1003284C) --------------------------------------------------------
int __usercall sub_1003284C<eax>(int a1<ebp>, int a2<edi>)
{
  void *v2; // ecx@1
  const void **v3; // eax@3
  signed int v5; // [sp-4h] [bp-4h]@1

  v5 = 8;
  sub_10035648();
  *(_DWORD *)(a1 - 20) = &dword_10075F50;
  sub_10030FB0(&dword_10075F50);
  v2 = (void *)dword_100755D0;
  *(_DWORD *)(a1 - 4) = 0;
  if ( !v2 || !sub_10034051(v2) )
  {
    sub_10044A4D(0, a1 - 16, 0, 8);
    v3 = (const void **)dword_100755D4;
    *(_BYTE *)(a1 - 4) = 1;
    if ( v3 )
      sub_10044AEB((void **)(a1 - 16), v3);
    dword_100755D0 = sub_100321D5(0, a2, (void *)(a1 - 16));
    sub_10032DDB(dword_100755D0);
    (*(void (**)(void))(*(_DWORD *)dword_100755D0 + 16))();
    *(_BYTE *)(a1 - 4) = 0;
    sub_10044AE2((LPVOID *)(a1 - 16));
  }
  dword_10075F50 = 0;
  return sub_10035616(v5);
}
// 10032DDB: using guessed type int __thiscall sub_10032DDB(_DWORD);
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 100755D0: using guessed type int dword_100755D0;
// 100755D4: using guessed type int dword_100755D4;
// 10075F50: using guessed type int dword_10075F50;

//----- (100328DC) --------------------------------------------------------
int __userpurge sub_100328DC<eax>(int a1<ebx>, int a2<ebp>, int a3)
{
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  PSINGLE_LIST_ENTRY v7; // eax@1
  int v8; // eax@2

  sub_10035648();
  v5 = v4;
  v7 = InterlockedPopEntrySList((PSLIST_HEADER)(v4 + 488));
  v6 = v7 != 0 ? (int)&v7[-1] : 0;
  if ( v6 )
  {
    sub_10047A97(v6, *(_DWORD *)(a2 + 8));
  }
  else
  {
    v8 = sub_1002ADB1(v3, v4, a1, v5, 176);
    *(_DWORD *)(a2 - 16) = v8;
    *(_DWORD *)(a2 - 4) = 0;
    if ( v8 )
      sub_100477FF(a1, a2, v5, *(_DWORD *)(a2 + 8));
  }
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1003293C) --------------------------------------------------------
int __userpurge sub_1003293C<eax>(int a1<ebp>, int a2)
{
  int v2; // ecx@1
  int v3; // edi@1
  int v5; // esi@4
  int v13; // esi@11
  PSINGLE_LIST_ENTRY v14; // eax@11
  int v15; // edx@12
  int v23; // [sp-8h] [bp-8h]@15
  signed int v24; // [sp-4h] [bp-4h]@1

  v24 = 8;
  sub_100356B1();
  v3 = v2;
  *(_DWORD *)(a1 - 20) = v2;
  if ( !*(_BYTE *)(a1 + 8) )
  {
    _EBX = 1;
LABEL_9:
    _EAX = v3 + 400;
    _ECX = _EBX;
    __asm { lock xadd [eax], ecx }
    if ( !*(_BYTE *)(a1 + 8) )
      *(_DWORD *)(v3 + 456) = GetTickCount();
    v14 = InterlockedPopEntrySList((PSLIST_HEADER)(v3 + 480));
    v13 = v14 != 0 ? (int)&v14[-2] : 0;
    *(_DWORD *)(a1 + 8) = v13;
    if ( !v13 )
    {
      v13 = (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 64))(v3);
      *(_DWORD *)(a1 + 8) = v13;
      sub_10031B6B(v15, v3, _EBX, v3, v13);
      _ECX = v3 + 392;
      __asm { lock xadd [ecx], ebx }
    }
    sub_10046C74(v13);
    *(_DWORD *)(a1 - 4) = 0;
    *(_DWORD *)(v13 + 156) = 0;
    (*(void (__cdecl **)(int, signed int))(**(_DWORD **)(v3 + 420) + 8))(v13, v24);
    if ( v13 )
    {
      *(_DWORD *)(v13 + 16) = 0;
      *(_DWORD *)(v13 + 20) = 0;
    }
    return sub_10035616(v23);
  }
  if ( !(unsigned __int8)(*(int (__cdecl **)(signed int))(*(_DWORD *)v2 + 88))(8) || !sub_10032C00(v3) )
  {
    _EBX = 1;
    v5 = sub_1003458A(v3, 1);
    if ( v5 )
    {
      if ( GetTickCount() - *(_DWORD *)(v3 + 456) < v5 )
        return sub_10035616(v23);
      *(_BYTE *)(a1 + 8) = 0;
    }
    goto LABEL_9;
  }
  return sub_10035616(v23);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (10032A49) --------------------------------------------------------
int __thiscall sub_10032A49(void *this)
{
  _ECX = (int)((char *)this + 328);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return _EAX + 1;
}

//----- (10032A58) --------------------------------------------------------
int __thiscall sub_10032A58(void *this)
{
  _ECX = (int)((char *)this + 332);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return _EAX + 1;
}

//----- (10032A67) --------------------------------------------------------
int __cdecl sub_10032A67()
{
  _ECX = &unk_100755DC;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return _EAX + 1;
}

//----- (10032A75) --------------------------------------------------------
int __thiscall sub_10032A75(int this)
{
  int v1; // eax@1
  void *v2; // edi@1
  int v3; // esi@1
  int v4; // esi@1

  v4 = this;
  v2 = (void *)(this + 308);
  sub_1002B98A((void *)(this + 308));
  v1 = sub_10033DDA((void *)(v4 + 304));
  v3 = v1;
  if ( v1 )
    *(_DWORD *)(v1 + 12) = 1;
  sub_1002BB74(v2);
  return v3;
}

//----- (10032AAA) --------------------------------------------------------
int __stdcall sub_10032AAA(int a1, int a2, int a3)
{
  int v3; // edx@1
  int result; // eax@2

  v3 = *(_DWORD *)a1 + 1;
  if ( v3 <= a2 || (result = sub_10032551(v3, *(_DWORD *)(a3 + 64), a1, a3), v3 = 0, !result) )
    result = sub_10032551(v3, a2, a1, a3);
  return result;
}

//----- (10032AE6) --------------------------------------------------------
int __thiscall sub_10032AE6(int this, int a2, int a3)
{
  int v4; // esi@1
  int v5; // eax@1

  v4 = this;
  v5 = sub_10032B31(this, *(_DWORD *)(a3 + 184));
  return *(_DWORD *)(*(_DWORD *)(v4 + 36) + 4 * v5) != a2 ? *(_DWORD *)(*(_DWORD *)(v4 + 36) + 4 * v5) : 0;
}

//----- (10032B10) --------------------------------------------------------
int __thiscall sub_10032B10(int this)
{
  int v2; // edx@1
  int v3; // esi@1

  v2 = *(_DWORD *)(this + 376);
  v3 = *(_DWORD *)(*(_DWORD *)(this + 36) + 4 * v2);
  *(_DWORD *)(this + 376) = sub_10032B31(this, v2);
  return v3;
}

//----- (10032B31) --------------------------------------------------------
int __thiscall sub_10032B31(int this, int a2)
{
  int v2; // edx@1

  v2 = a2;
  do
    v2 = (v2 + 1) % *(_DWORD *)(this + 44);
  while ( !*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 36) + 4 * v2) + 188) );
  return v2;
}

//----- (10032B53) --------------------------------------------------------
int __thiscall sub_10032B53(int this, int a2, int a3)
{
  int v3; // edx@1
  void *v4; // edi@1
  int result; // eax@2

  v3 = *(_DWORD *)a2 + 1;
  v4 = (void *)this;
  if ( v3 <= a3 || (result = sub_1003257C((void *)this, v3, *(_DWORD *)(this + 120), a2), v3 = 0, !result) )
    result = sub_1003257C(v4, v3, a3, a2);
  return result;
}

//----- (10032B88) --------------------------------------------------------
int __thiscall sub_10032B88(int this)
{
  return *(_DWORD *)(this + 20);
}

//----- (10032B8C) --------------------------------------------------------
int __userpurge sub_10032B8C<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  sub_10044A6B(a1, a5, a3, a4, (const void **)(a2 + 4));
  return a5;
}

//----- (10032BA7) --------------------------------------------------------
int __userpurge sub_10032BA7<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4, int a5)
{
  PSINGLE_LIST_ENTRY v5; // eax@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // eax@2

  v5 = InterlockedPopEntrySList((PSLIST_HEADER)(a1 + 496));
  v6 = v5 != 0 ? (int)&v5[-3] : 0;
  if ( v6 )
  {
    *(_DWORD *)(v5 != 0 ? (int)&v5[-3] + 4 : 4) = a4;
    *(_DWORD *)(v5 != 0 ? (int)&v5[-3] + 8 : 8) = a5;
    goto LABEL_6;
  }
  v8 = sub_1002ADB1(0, v7, a2, a3, 16);
  v6 = v8;
  if ( v8 )
  {
    *(_DWORD *)(v8 + 4) = a4;
    *(_DWORD *)v8 = &off_10060E88;
    *(_DWORD *)(v8 + 8) = a5;
LABEL_6:
    *(_DWORD *)(v6 + 12) = 0;
    return v6;
  }
  return 0;
}
// 10060E88: using guessed type int (__stdcall *off_10060E88)(char);

//----- (10032C00) --------------------------------------------------------
int __thiscall sub_10032C00(int this)
{
  PSINGLE_LIST_ENTRY v2; // eax@1

  v2 = InterlockedPopEntrySList((PSLIST_HEADER)(this + 504));
  return v2 != 0 ? (int)&v2[-2] : 0;
}

//----- (10032C17) --------------------------------------------------------
int __thiscall sub_10032C17(int this, char a2)
{
  int v3; // [sp+0h] [bp-4h]@1

  v3 = this;
  sub_1003248C((unsigned int *)(this + 360), (int)&a2, (int)&v3);
  return v3;
}

//----- (10032C35) --------------------------------------------------------
int __thiscall sub_10032C35(void *this)
{
  void *v1; // edi@3
  void *v2; // esi@3
  int v3; // edi@3
  int v4; // ecx@1
  int result; // eax@2

  v4 = (int)((char *)this + 288);
  if ( *(_DWORD *)v4 )
  {
    v1 = (void *)v4;
    v2 = (void *)(v4 + 8);
    sub_10034B9B((void *)(v4 + 8));
    v3 = sub_10032282(v1);
    sub_10034BAB(v2);
    result = v3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10032C48) --------------------------------------------------------
int __usercall sub_10032C48<eax>(int a1<ebp>, int a2<edi>)
{
  char v2; // bl@1
  void *v10; // eax@4
  int v11; // edx@4
  int v12; // ecx@4
  void *v13; // ecx@5
  int v14; // eax@5

  sub_10035648();
  v2 = *(_BYTE *)(a1 + 8);
  if ( v2 )
  {
    if ( dword_100755E4 >= 32 )
      return sub_10035616(0);
    _ECX = &dword_100755E4;
    _EAX = 1;
    __asm { lock xadd [ecx], eax }
  }
  v10 = InterlockedPopEntrySList(&ListHead);
  if ( !v10 )
  {
    v14 = sub_1002ADB1(v11, v12, v2, a2, 776);
    v13 = (void *)v14;
    *(_DWORD *)(a1 + 8) = v14;
    v10 = 0;
    *(_DWORD *)(a1 - 4) = 0;
    if ( v13 )
      v10 = sub_1003165F(v13);
  }
  *((_BYTE *)v10 + 772) = v2;
  return sub_10035616(0);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 100755E4: using guessed type int dword_100755E4;

//----- (10032CA9) --------------------------------------------------------
int __thiscall sub_10032CA9(int this, int a2)
{
  int result; // eax@2

  if ( *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 36) + 4 * a2) + 188) )
    result = a2;
  else
    result = sub_10032B31(this, a2);
  return result;
}

//----- (10032CCC) --------------------------------------------------------
void __thiscall sub_10032CCC(void *this, int a2)
{
  int v2; // ebx@1
  void *v3; // esi@1
  int v4; // eax@2
  unsigned int v5; // edx@2
  unsigned int v6; // ecx@2
  int v7; // edi@2
  unsigned int v9; // eax@2
  int v10; // [sp+8h] [bp-4h]@2

  v2 = a2;
  v3 = this;
  if ( a2 != *(_DWORD *)this )
  {
    v7 = (unsigned int)(a2 + 31) >> 5;
    _ECX = 0;
    v9 = 4 * ((unsigned int)(a2 + 31) >> 5);
    __asm { seto    cl }
    v4 = sub_1002965B((a2 + 31) / 0x100u, v9 | -_ECX, a2, v7, v9 | -_ECX);
    v6 = (unsigned int)(*(_DWORD *)v3 + 31) >> 5;
    v5 = 0;
    v10 = v4;
    if ( v6 )
    {
      do
      {
        *(_DWORD *)(v4 + 4 * v5) = *(_DWORD *)(*((_DWORD *)v3 + 1) + 4 * v5);
        ++v5;
      }
      while ( v5 < v6 );
      v2 = a2;
    }
    sub_100391F0((void *)(v4 + 4 * v6), 0, 4 * (v7 - v6));
    sub_100303A3(*((LPVOID *)v3 + 1));
    *((_DWORD *)v3 + 1) = v10;
    *(_DWORD *)v3 = v2;
  }
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (10032D4B) --------------------------------------------------------
void __thiscall sub_10032D4B(void *this, int a2)
{
  int v2; // ebx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // edx@2
  unsigned int v6; // ecx@2
  signed __int64 v8; // qax@2
  int v9; // [sp+14h] [bp+8h]@2

  v4 = a2;
  v3 = (int)this;
  v2 = *(_DWORD *)this;
  if ( a2 != *(_DWORD *)this )
  {
    sub_10032CCC(this, a2);
    _ECX = 0;
    v8 = 4i64 * (unsigned int)a2;
    __asm { seto    cl }
    v5 = sub_1002965B(SHIDWORD(v8), v8 | -_ECX, v2, v3, v8 | -_ECX);
    v6 = 0;
    v9 = v5;
    if ( v2 )
    {
      do
      {
        *(_DWORD *)(v5 + 4 * v6) = *(_DWORD *)(*(_DWORD *)(v3 + 8) + 4 * v6);
        ++v6;
      }
      while ( v6 < v2 );
    }
    sub_100391F0((void *)(v5 + 4 * v2), 0, 4 * (v4 - v2));
    sub_100303A3(*(LPVOID *)(v3 + 8));
    *(_DWORD *)(v3 + 8) = v9;
  }
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (10032DBB) --------------------------------------------------------
bool __thiscall sub_10032DBB(int this)
{
  return (*(_DWORD *)(this + 404) & 0xA0000000) == -1610612736;
}

//----- (10032DD0) --------------------------------------------------------
int __thiscall sub_10032DD0(int this)
{
  return *(_DWORD *)(this + 28);
}

//----- (10032DD4) --------------------------------------------------------
int __thiscall sub_10032DD4(int this)
{
  return *(_DWORD *)(this + 372);
}

//----- (10032DDB) --------------------------------------------------------
#error "10033200: call analysis failed (funcsize=373)"

//----- (10033206) --------------------------------------------------------
int __thiscall sub_10033206(void *this)
{
  int result; // eax@1

  _ECX = (int)((char *)this + 392);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return result;
}

//----- (10033214) --------------------------------------------------------
int __thiscall sub_10033214(unsigned int *this, int a2, int a3)
{
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@2
  int v8; // edx@2
  int result; // eax@5

  v6 = (int)this;
  v5 = sub_1002D18F(a2, *this);
  if ( sub_1002D1BB(v6, a2, v5) )
  {
    result = 0;
  }
  else
  {
    v7 = sub_1002ADB1(v3, v4, v5, a2, 12);
    v8 = v7;
    if ( v7 )
    {
      *(_DWORD *)v7 = 0;
      *(_DWORD *)(v7 + 4) = *(_DWORD *)a2;
      *(_DWORD *)(v7 + 8) = *(_DWORD *)a3;
    }
    else
    {
      v8 = 0;
    }
    result = v8;
    *(_DWORD *)v8 = *(_DWORD *)(*(_DWORD *)(v6 + 8) + 4 * v5);
    *(_DWORD *)(*(_DWORD *)(v6 + 8) + 4 * v5) = v8;
    ++*(_DWORD *)(v6 + 4);
  }
  return result;
}

//----- (10033278) --------------------------------------------------------
int __userpurge sub_10033278<eax>(int a1<ebp>, int a2)
{
  PSINGLE_LIST_ENTRY v2; // eax@1
  int v3; // edx@1
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v9; // [sp-8h] [bp-8h]@7

  sub_10035648();
  v5 = v7;
  v4 = v7 + 96;
  v2 = InterlockedPopEntrySList((PSLIST_HEADER)(v7 + 96));
  v6 = 0;
  if ( v2 )
    v6 = (int)&v2[-13];
  if ( *(_DWORD *)(v5 + 12) )
  {
    *(_DWORD *)(a1 - 32) = 0;
    *(_DWORD *)(a1 - 24) = 0;
    *(_DWORD *)(a1 - 20) = 0;
    if ( !v6 )
    {
      v6 = sub_1002ADB1(v3, 0, v4, v5, 60);
      *(_DWORD *)(a1 + 8) = v6;
      *(_DWORD *)(a1 - 4) = 1;
      if ( v6 )
      {
        sub_10040624(a1, v5, a1 - 32);
        *(_DWORD *)(v6 + 56) = 0;
        *(_DWORD *)v6 = &off_10060F4C;
        *(_BYTE *)(v6 + 48) = 2;
        goto LABEL_12;
      }
LABEL_11:
      v6 = 0;
      goto LABEL_12;
    }
    v9 = a1 - 32;
LABEL_14:
    sub_100410A4(v6, v9);
    goto LABEL_15;
  }
  if ( v6 )
  {
    v9 = *(_DWORD *)(a1 + 8);
    goto LABEL_14;
  }
  v6 = sub_1002ADB1(v3, 0, v4, v5, 56);
  *(_DWORD *)(a1 - 16) = v6;
  *(_DWORD *)(a1 - 4) = 0;
  if ( !v6 )
    goto LABEL_11;
  sub_10040624(a1, v5, *(_DWORD *)(a1 + 8));
  *(_DWORD *)v6 = &off_10060F0C;
  *(_BYTE *)(v6 + 48) = 1;
LABEL_12:
  *(_DWORD *)(a1 - 4) = -1;
LABEL_15:
  sub_10031A12(v4, v6);
  return sub_10035616(20);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 10060F0C: using guessed type int (__stdcall *off_10060F0C)(int, int);
// 10060F4C: using guessed type int (__stdcall *off_10060F4C)(int, int);

//----- (1003333B) --------------------------------------------------------
int __thiscall sub_1003333B(void *this)
{
  int v1; // esi@1
  int v2; // edi@2
  int result; // eax@4

  v1 = (int)this;
  if ( *((_BYTE *)this + 48) & 4 )
  {
    result = 0;
  }
  else
  {
    _EAX = (int)((char *)this + 20);
    _EDI = -1;
    __asm { lock xadd [eax], edi }
    v2 = _EDI - 1;
    if ( !v2 )
    {
      (*(void (**)(void))(*(_DWORD *)this + 28))();
      sub_10033E85(*(_DWORD *)(v1 + 4), v1);
    }
    result = v2;
  }
  return result;
}

//----- (10033369) --------------------------------------------------------
bool __thiscall sub_10033369(int this, int a2)
{
  int v2; // edx@1
  unsigned int v3; // edi@1
  unsigned int v4; // esi@1

  v2 = 0;
  v4 = (unsigned int)(*(_DWORD *)this + 31) >> 5;
  v3 = 0;
  if ( v4 )
  {
    do
    {
      if ( v2 )
        break;
      v2 = *(_DWORD *)(*(_DWORD *)(this + 4) + 4 * v3) & *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * v3);
      ++v3;
    }
    while ( v3 < v4 );
  }
  return v2 != 0;
}

//----- (100333A7) --------------------------------------------------------
int __thiscall sub_100333A7(int this, int (__cdecl *a2)(_DWORD), int a3, int a4)
{
  int result; // eax@2

  if ( *(_DWORD *)(a4 + 404) & 0x20000000 )
  {
    result = a2(a3);
  }
  else
  {
    *(_DWORD *)this = a2;
    *(_DWORD *)(this + 4) = a3;
    result = sub_100333DA(a4, this);
  }
  return result;
}

//----- (100333DA) --------------------------------------------------------
int __thiscall sub_100333DA(int this, int a2)
{
  int v3; // ebx@1
  void *v4; // edi@1

  v3 = this;
  v4 = (void *)(this + 324);
  sub_10034B9B((void *)(this + 324));
  *(_DWORD *)(a2 + 8) = sub_10033833((void *)v3);
  *(_DWORD *)(a2 + 12) = 0;
  **(_DWORD **)(v3 + 320) = a2;
  *(_DWORD *)(v3 + 320) = a2 + 12;
  return sub_10034BAB(v4);
}

//----- (1003341E) --------------------------------------------------------
char __thiscall sub_1003341E(int this)
{
  char v1; // dl@1

  v1 = 0;
  if ( *(_DWORD *)(this + 24)
    || *(_DWORD *)(this + 8) != *(_DWORD *)(this + 16)
    || *(_DWORD *)(this + 12) != *(_DWORD *)(this + 20) )
    v1 = 1;
  return v1;
}

//----- (1003343B) --------------------------------------------------------
char __thiscall sub_1003343B(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v4; // esi@1
  char v5; // bl@1
  char v6; // [sp+8h] [bp-8h]@1
  void *v7; // [sp+Ch] [bp-4h]@1

  v4 = this;
  sub_100327A2(ebp0, (int)&v6, a2);
  v5 = sub_10033369((int)&v6, (int)((char *)v4 + 48));
  sub_100303A3(v7);
  return v5;
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (1003346F) --------------------------------------------------------
int __stdcall sub_1003346F(int a1, int a2, int a3, int a4)
{
  int result; // eax@1

  result = a1;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

//----- (10033480) --------------------------------------------------------
char __thiscall sub_10033480(int this, int a2)
{
  char result; // al@2

  if ( *(_DWORD *)a2 == *(_DWORD *)(this + 336) )
  {
    result = 0;
  }
  else
  {
    *(_DWORD *)a2 = *(_DWORD *)(this + 336);
    result = 1;
  }
  return result;
}

//----- (100334A2) --------------------------------------------------------
char __thiscall sub_100334A2(int this, int a2)
{
  int v2; // esi@1
  int v3; // ST08_4@1
  char result; // al@6
  int v5; // [sp+8h] [bp-Ch]@1
  int v6; // [sp+Ch] [bp-8h]@5

  v5 = 0;
  v2 = this;
  if ( sub_100325AB(this, (int)&v5, 0, v3, 0, 0, 12) )
  {
    if ( v5 == 2 || v5 == 8 )
    {
      InterlockedPushEntrySList((PSLIST_HEADER)(v2 + 504), (PSINGLE_LIST_ENTRY)(a2 + 8));
      sub_1004505B(v6, v5, 0, 0);
    }
    else
    {
      sub_100450CF((int)&v5, a2);
    }
    result = 1;
  }
  else
  {
    InterlockedPushEntrySList((PSLIST_HEADER)(v2 + 504), (PSINGLE_LIST_ENTRY)(a2 + 8));
    result = 0;
  }
  return result;
}

//----- (10033531) --------------------------------------------------------
DWORD __cdecl sub_10033531()
{
  int v0; // eax@2
  char v2; // [sp+0h] [bp-10h]@5

  sub_1002BB3B();
  dwTlsIndex = TlsAlloc();
  if ( dwTlsIndex == -1 )
  {
    v0 = GetLastError();
    if ( v0 > 0 )
      v0 = (unsigned __int16)v0 | 0x80070000;
    sub_10030079((int)&v2, v0);
    sub_100355BB((int)&v2, (int)&unk_1006B6E0);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003357F);
  }
  return sub_10047DD9();
}

//----- (1003357F) --------------------------------------------------------
BOOL __cdecl sub_1003357F()
{
  BOOL result; // eax@1

  sub_10047E1D();
  result = TlsFree(dwTlsIndex);
  dwTlsIndex = 0;
  return result;
}

//----- (10033598) --------------------------------------------------------
int __thiscall sub_10033598(void *this, int a2)
{
  void *v3; // edi@1
  int v4; // esi@2
  int v6; // esi@3
  int v7; // eax@4
  int v8; // ecx@4
  int v9; // ST04_4@4
  int v10; // esi@5
  int v11; // eax@11
  int v12; // esi@12
  int v13; // eax@18
  int v14; // esi@19
  char v16; // [sp+Ch] [bp-14h]@18
  int v17; // [sp+10h] [bp-10h]@4
  char v18; // [sp+14h] [bp-Ch]@4
  int v19; // [sp+18h] [bp-8h]@4
  int i; // [sp+1Ch] [bp-4h]@3

  v3 = this;
  _ECX = (int)((char *)this + 412);
  do
  {
    v4 = *(_DWORD *)_ECX;
    _EDX = a2;
    __asm { lock cmpxchg [ecx], edx }
  }
  while ( v4 != v4 );
  sub_1002B98A((char *)v3 + 308);
  v6 = 0;
  for ( i = 0; v6 < *((_DWORD *)v3 + 11); i = v6 )
  {
    v8 = *(_DWORD *)(*((_DWORD *)v3 + 9) + 4 * v6);
    v17 = *(_DWORD *)(*((_DWORD *)v3 + 8) + 4 * v6);
    v9 = *(_DWORD *)(v8 + 80);
    v19 = v8;
    v7 = sub_10032551(0, v9, (int)&v18, v8 + 16);
    if ( v7 )
    {
      v10 = v19;
      do
      {
        if ( (unsigned int)(a2 - *(_DWORD *)(v7 + 264)) > 0x7D0 )
        {
          if ( *(_DWORD *)(v7 + 280) == 1 )
          {
            *(_DWORD *)(v7 + 280) = 2;
            sub_10031B98((char *)v3 + 304, v7 + 268);
          }
        }
        v7 = sub_10032AAA((int)&v18, 0, v10 + 16);
      }
      while ( v7 );
      v6 = i;
    }
    v11 = sub_10032551(0, *(_DWORD *)(v19 + 160), (int)&v18, v19 + 96);
    if ( v11 )
    {
      v12 = v19;
      do
      {
        if ( (unsigned int)(a2 - *(_DWORD *)(v11 + 264)) > 0x7D0 )
        {
          if ( *(_DWORD *)(v11 + 280) == 1 )
          {
            *(_DWORD *)(v11 + 280) = 2;
            sub_10031B98((char *)v3 + 304, v11 + 268);
          }
        }
        v11 = sub_10032AAA((int)&v18, 0, v12 + 96);
      }
      while ( v11 );
      v6 = i;
    }
    v13 = sub_1003257C((void *)v17, 0, *(_DWORD *)(v17 + 120), (int)&v16);
    if ( v13 )
    {
      v14 = v17;
      do
      {
        if ( (unsigned int)(a2 - *(_DWORD *)(v13 + 184)) > 0x7D0 )
        {
          if ( *(_DWORD *)(v13 + 204) == 1 )
          {
            *(_DWORD *)(v13 + 204) = 2;
            sub_10031B98((char *)v3 + 304, v13 + 192);
          }
        }
        v13 = sub_10032B53(v14, (int)&v16, 0);
      }
      while ( v13 );
      v6 = i;
    }
    ++v6;
  }
  return sub_1002BB74((char *)v3 + 308);
}

//----- (10033735) --------------------------------------------------------
int __thiscall sub_10033735(int this)
{
  int v1; // esi@1
  int i; // eax@4
  int v3; // edx@4
  int v4; // ecx@4

  v1 = this;
  if ( dword_100755D0 == this )
  {
    sub_10030FB0(&dword_10075F50);
    dword_100755D0 = dword_100755D0 != v1 ? dword_100755D0 : 0;
    dword_10075F50 = 0;
  }
  if ( *(_DWORD *)(v1 + 392) > 1 )
  {
    _EDI = v1 + 404;
    v3 = *(_DWORD *)(v1 + 404);
    v4 = *(_DWORD *)(v1 + 404);
    for ( i = *(_DWORD *)(v1 + 404); ; v4 = i )
    {
      _ECX = v4 | 0x80000000;
      __asm { lock cmpxchg [edi], ecx }
      if ( i == v3 )
        break;
      v3 = i;
    }
    if ( !(v3 & 0x1FFFFFFF) )
      sub_10031E1F((void *)v1);
  }
  return sub_10032207(v1);
}
// 100755D0: using guessed type int dword_100755D0;
// 10075F50: using guessed type int dword_10075F50;

//----- (100337AB) --------------------------------------------------------
int __thiscall sub_100337AB(int this)
{
  int v1; // eax@1
  int v2; // esi@1
  char v3; // bl@4
  int v11; // eax@6
  int result; // eax@8

  v2 = this;
  v1 = (int)sub_10032356();
  if ( !v1 || *(_BYTE *)(v1 + 76) || sub_10032DD0(v1) != v2 )
  {
    v3 = 1;
    _EAX = v2 + 392;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
  }
  else
  {
    v3 = 0;
  }
  sub_1003203D(v2, 0);
  (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 84))(v2);
  _EDI = v2 + 404;
  v11 = *(_DWORD *)(v2 + 404);
  do
  {
    _ECX = v11 & 0xBFFFFFFF | 0x20000000;
    __asm { lock cmpxchg [edi], ecx }
  }
  while ( v11 != v11 );
  sub_10033B8E(v2, v11 & 0x1FFFFFFF);
  result = (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 80))(v2);
  if ( v3 )
    result = sub_10032207(v2);
  return result;
}

//----- (10033833) --------------------------------------------------------
int __thiscall sub_10033833(void *this)
{
  int result; // eax@2

  _ECX = (int)((char *)this + 336);
  do
  {
    do
    {
      _EAX = 1;
      __asm { lock xadd [ecx], eax }
      result = _EAX + 1;
    }
    while ( !result );
  }
  while ( result == -1 );
  return result;
}

//----- (1003384B) --------------------------------------------------------
int __thiscall sub_1003384B(void *_ECX, int a2)
{
  int result; // eax@1
  int v3; // esi@1

  do
  {
    v3 = *(_DWORD *)_ECX;
    *(_DWORD *)a2 = *(_DWORD *)_ECX;
    _EDX = a2;
    result = v3;
    __asm { lock cmpxchg [ecx], edx }
  }
  while ( v3 != v3 );
  return result;
}

//----- (10033869) --------------------------------------------------------
char __thiscall sub_10033869(void *this, int a2, char a3, int a4, int a5, int a6)
{
  char v6; // bl@1
  void *v7; // edi@1
  int v8; // ecx@3
  int v9; // ecx@4
  char v11; // [sp-14h] [bp-2Ch]@4
  int v12; // [sp-10h] [bp-28h]@4
  int v13; // [sp-Ch] [bp-24h]@4
  int v14; // [sp-8h] [bp-20h]@4
  int v15; // [sp-4h] [bp-1Ch]@4
  int v16; // [sp+Ch] [bp-Ch]@4
  int v17; // [sp+14h] [bp-4h]@1

  v6 = 0;
  v17 = (int)this;
  v7 = (void *)(a2 + 4);
  if ( !a2 )
    v7 = 0;
  if ( sub_10032356() != v7 )
  {
    sub_1002EF93(v8);
    v15 = 5;
    v16 = 0;
    sub_1002F3E5((int)&v11, (int)&a3);
    if ( sub_100325AB(v17, (int)&v16, *(int *)&v11, v12, v13, v14, v15) )
    {
      sub_100450CF((int)&v16, a2);
      v6 = 1;
    }
    sub_1002EF93(v9);
  }
  return v6;
}
// 1002EF93: using guessed type _DWORD __thiscall sub_1002EF93(_DWORD ecx0);

//----- (100338CD) --------------------------------------------------------
int __userpurge sub_100338CD<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  int result; // eax@1
  int v5; // esi@1
  unsigned int v7; // eax@1

  v5 = a1;
  sub_100303A3(*(LPVOID *)(a1 + 4));
  *(_DWORD *)v5 = a4;
  _ECX = 0;
  v7 = 4 * ((unsigned int)(a4 + 31) >> 5);
  __asm { seto    cl }
  result = sub_1002965B((a4 + 31) / 0x100u, v7 | -_ECX, a2, a3, v7 | -_ECX);
  *(_DWORD *)(v5 + 4) = result;
  return result;
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (10033904) --------------------------------------------------------
int __thiscall sub_10033904(int this)
{
  int v2; // ecx@2

  if ( *(_BYTE *)(this + 48) & 4 )
  {
    v2 = 0;
  }
  else
  {
    _EAX = this + 20;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
    v2 = _ECX + 1;
  }
  return v2;
}

//----- (1003391C) --------------------------------------------------------
int __thiscall sub_1003391C(int this)
{
  int v1; // edi@1
  void *v2; // esi@1
  int v10; // eax@3
  char v12; // [sp+8h] [bp-Ch]@9

  v2 = (void *)this;
  _EAX = this + 384;
  _EDI = 1;
  __asm { lock xadd [eax], edi }
  v1 = _EDI + 1;
  if ( v1 == 1 )
  {
    if ( *(_DWORD *)(this + 396) <= 0 )
    {
      *(_DWORD *)(this + 396) = 1;
    }
    else
    {
      v10 = (int)sub_10032356();
      if ( !v10 || *(_BYTE *)(v10 + 76) || (void *)sub_10032DD0(v10) != v2 )
      {
        sub_1002FF79((int)&v12);
        sub_100355BB((int)&v12, (int)&unk_1006B718);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_10033987);
      }
      sub_10033FA1(v2);
    }
  }
  return v1;
}

//----- (10033987) --------------------------------------------------------
int __thiscall sub_10033987(void *this)
{
  _EAX = (int)((char *)this + 388);
  _EDX = 1;
  __asm { lock xadd [eax], edx }
  return (*(int (**)(void))(*(_DWORD *)this + 16))();
}

//----- (10033999) --------------------------------------------------------
int __userpurge sub_10033999<eax>(int a1<ecx>, int a2<edi>, HANDLE hSourceHandle)
{
  int v3; // ebx@1
  int v4; // edx@3
  int v5; // ecx@3
  HANDLE v6; // ST08_4@3
  HANDLE v7; // ST04_4@3
  HANDLE v8; // eax@3
  int v9; // eax@4
  int v11; // eax@6
  int v12; // eax@7
  void *v13; // ecx@9
  int v14; // [sp-4h] [bp-1Ch]@7
  char v15; // [sp+4h] [bp-14h]@8
  int (__stdcall **v16)(char); // [sp+8h] [bp-10h]@7
  HANDLE TargetHandle; // [sp+14h] [bp-4h]@3

  v3 = a1;
  if ( hSourceHandle && hSourceHandle != (HANDLE)-1 )
  {
    TargetHandle = 0;
    v6 = GetCurrentProcess();
    v7 = hSourceHandle;
    v8 = GetCurrentProcess();
    if ( DuplicateHandle(v8, v7, v6, &TargetHandle, 0, 0, 2u) )
    {
      v11 = sub_1002ADB1(v4, v5, v3, a2, 12);
      *(_DWORD *)(v11 + 8) = TargetHandle;
      return sub_10031BFE(v3 + 184, v11);
    }
    v9 = GetLastError();
    if ( v9 > 0 )
      v9 = (unsigned __int16)v9 | 0x80070000;
    sub_10030079((int)&v15, v9);
    v14 = (int)&unk_1006B6E0;
    v12 = (int)&v15;
  }
  else
  {
    hSourceHandle = "eventObject";
    sub_1002AEA4((int)&v16, (int *)&hSourceHandle);
    v16 = &off_1005F2EC;
    v14 = (int)&unk_1006C8B4;
    v12 = (int)&v16;
  }
  sub_100355BB(v12, v14);
  __asm { int     3               ; Trap to Debugger }
  return sub_1003333B(v13);
}
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);

//----- (10033A4A) --------------------------------------------------------
int __thiscall sub_10033A4A(int this)
{
  int v1; // esi@1

  _EDX = this + 384;
  _ESI = -1;
  __asm { lock xadd [edx], esi }
  v1 = _ESI - 1;
  if ( !v1 )
    sub_10033735(this);
  return v1;
}

//----- (10033A64) --------------------------------------------------------
USHORT __thiscall sub_10033A64(int this, int a2)
{
  USHORT result; // ax@1
  int ebp0; // ebp@0
  union _SLIST_HEADER *v4; // edi@1
  int v5; // esi@1

  v5 = this;
  v4 = (union _SLIST_HEADER *)(this + 488);
  result = QueryDepthSList((PSLIST_HEADER)(this + 488));
  if ( (signed int)result >= *(_DWORD *)(v5 + 20) )
  {
    if ( a2 )
      result = (*(int (__stdcall **)(signed int))(*(_DWORD *)a2 + 20))(1);
  }
  else
  {
    sub_10047B64(a2, ebp0);
    result = (unsigned int)InterlockedPushEntrySList(v4, (PSINGLE_LIST_ENTRY)(a2 + 4));
  }
  return result;
}

//----- (10033AAB) --------------------------------------------------------
int __thiscall sub_10033AAB(void *this)
{
  _EAX = (int)((char *)this + 388);
  _EDX = -1;
  __asm { lock xadd [eax], edx }
  return (*(int (**)(void))(*(_DWORD *)this + 20))();
}

//----- (10033ABD) --------------------------------------------------------
PSINGLE_LIST_ENTRY __thiscall sub_10033ABD(int this, int a2, char a3)
{
  int v3; // esi@1

  v3 = this;
  if ( a3 )
    (*(void (__stdcall **)(int))(**(_DWORD **)(this + 420) + 12))(a2);
  _EAX = v3 + 400;
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  return InterlockedPushEntrySList((PSLIST_HEADER)(v3 + 480), (PSINGLE_LIST_ENTRY)(a2 + 8));
}

//----- (10033AFD) --------------------------------------------------------
int __thiscall sub_10033AFD(int this, int a2)
{
  int result; // eax@1
  union _SLIST_HEADER *v3; // edi@1
  int v4; // esi@1
  int v5; // edx@1

  v4 = this;
  v3 = (union _SLIST_HEADER *)(this + 496);
  v5 = QueryDepthSList((PSLIST_HEADER)(this + 496));
  result = 32 * *(_DWORD *)(v4 + 20);
  if ( v5 >= result )
  {
    if ( a2 )
      result = (**(int (__stdcall ***)(_DWORD))a2)(1);
  }
  else
  {
    result = (int)InterlockedPushEntrySList(v3, (PSINGLE_LIST_ENTRY)(a2 + 12));
  }
  return result;
}

//----- (10033B41) --------------------------------------------------------
PSINGLE_LIST_ENTRY __thiscall sub_10033B41(int this)
{
  PSINGLE_LIST_ENTRY result; // eax@1
  int v2; // edx@1
  union _SLIST_HEADER *v3; // ebx@1
  int v4; // edi@1
  int i; // esi@1
  PSINGLE_LIST_ENTRY v6; // eax@2
  PSINGLE_LIST_ENTRY v7; // esi@2

  v4 = this;
  v3 = (union _SLIST_HEADER *)(this + 504);
  result = InterlockedPopEntrySList((PSLIST_HEADER)(this + 504));
  v2 = (int)&result[-2];
  for ( i = result != 0 ? (int)&result[-2] : 0; i; i = v7 != 0 ? (int)result : 0 )
  {
    (*(void (__fastcall **)(_DWORD, _DWORD, _DWORD))(**(_DWORD **)(v4 + 420) + 12))(*(_DWORD *)(v4 + 420), v2, i);
    sub_10033ABD(v4, i, 0);
    v6 = InterlockedPopEntrySList(v3);
    v7 = v6;
    result = v6 - 2;
  }
  return result;
}

//----- (10033B8E) --------------------------------------------------------
BOOL __thiscall sub_10033B8E(int this, LONG lReleaseCount)
{
  BOOL result; // eax@2

  if ( lReleaseCount > 0 )
    result = ReleaseSemaphore(*(HANDLE *)(this + 380), lReleaseCount, 0);
  return result;
}

//----- (10033BAC) --------------------------------------------------------
int __thiscall sub_10033BAC(void *this, int a2)
{
  int result; // eax@1

  *(_DWORD *)(*(_DWORD *)(a2 + 4) + 8) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4) = *(_DWORD *)(a2 + 4);
  result = *(_DWORD *)this;
  if ( a2 == *(_DWORD *)this )
  {
    if ( result == *(_DWORD *)(result + 4) )
      result = 0;
    else
      result = *(_DWORD *)(result + 8);
    *(_DWORD *)this = result;
  }
  return result;
}

//----- (10033BDE) --------------------------------------------------------
char __thiscall sub_10033BDE(void *ListHead, int a2, signed int a3, char a4)
{
  signed int v4; // edx@1
  int v6; // esi@1
  char result; // al@2
  int v8; // eax@3
  int v9; // ecx@3
  int v10; // edx@4
  int v11; // edi@4
  int v12; // edx@5
  PSINGLE_LIST_ENTRY v18; // eax@14
  int v19; // ST08_4@14

  v6 = (int)ListHead;
  v4 = a3 >> *((_DWORD *)ListHead + 11);
  _EBX = a3 & (*((_DWORD *)ListHead + 10) - 1);
  if ( v4 < *((_DWORD *)ListHead + 15) )
  {
    v9 = *((_DWORD *)ListHead + 14);
    v8 = *(_DWORD *)(v6 + 52);
    if ( v4 < v9 )
    {
      v11 = *(_DWORD *)(v8 + 4 * v4);
    }
    else
    {
      v10 = v4 - v9;
      v11 = *(_DWORD *)(v8 + 4 * v9 - 4);
      if ( v10 >= 0 )
      {
        v12 = v10 + 1;
        do
        {
          v11 = *(_DWORD *)(v11 + 4);
          --v12;
        }
        while ( v12 );
      }
    }
    _ECX = *(_DWORD *)v11 + 4 * _EBX;
    _EDX = 0;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 == a2 )
    {
      _ECX = v11 + 8;
      __asm { lock cmpxchg [ecx], ebx }
      if ( a4 )
      {
        if ( (signed int)QueryDepthSList((PSLIST_HEADER)v6) <= *(_DWORD *)(v6 + 68) )
        {
          InterlockedPushEntrySList((PSLIST_HEADER)v6, (PSINGLE_LIST_ENTRY)(a2 + 4));
        }
        else
        {
          InterlockedPushEntrySList((PSLIST_HEADER)(v6 + 8), (PSINGLE_LIST_ENTRY)(a2 + 4));
          if ( (signed int)QueryDepthSList((PSLIST_HEADER)(v6 + 8)) > *(_DWORD *)(v6 + 68) )
          {
            if ( (*(_DWORD *)(*(_DWORD *)(v6 + 36) + 404) & 0xA0000000) != -1610612736 )
            {
              _EDX = 1;
              _ECX = v6 + 72;
              __asm { lock cmpxchg [ecx], edx }
              v18 = InterlockedFlushSList((PSLIST_HEADER)(v6 + 8));
              v19 = *(_DWORD *)(v6 + 36);
              *(_DWORD *)(v6 + 16) = v18;
              sub_100333A7(v6 + 20, sub_10031ECA, v6, v19);
            }
          }
        }
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10033CDC) --------------------------------------------------------
char __thiscall sub_10033CDC(void *ListHead, int a2, signed int a3, char a4)
{
  signed int v4; // edx@1
  int v6; // esi@1
  char result; // al@2
  int v8; // eax@3
  int v9; // ecx@3
  int v10; // edx@4
  int v11; // edi@4
  int v12; // edx@5
  PSINGLE_LIST_ENTRY v18; // eax@14
  int v19; // ST08_4@14

  v6 = (int)ListHead;
  v4 = a3 >> *((_DWORD *)ListHead + 11);
  _EBX = a3 & (*((_DWORD *)ListHead + 10) - 1);
  if ( v4 < *((_DWORD *)ListHead + 15) )
  {
    v9 = *((_DWORD *)ListHead + 14);
    v8 = *(_DWORD *)(v6 + 52);
    if ( v4 < v9 )
    {
      v11 = *(_DWORD *)(v8 + 4 * v4);
    }
    else
    {
      v10 = v4 - v9;
      v11 = *(_DWORD *)(v8 + 4 * v9 - 4);
      if ( v10 >= 0 )
      {
        v12 = v10 + 1;
        do
        {
          v11 = *(_DWORD *)(v11 + 4);
          --v12;
        }
        while ( v12 );
      }
    }
    _ECX = *(_DWORD *)v11 + 4 * _EBX;
    _EDX = 0;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 == a2 )
    {
      _ECX = v11 + 8;
      __asm { lock cmpxchg [ecx], ebx }
      if ( a4 )
      {
        if ( (signed int)QueryDepthSList((PSLIST_HEADER)v6) <= *(_DWORD *)(v6 + 68) )
        {
          InterlockedPushEntrySList((PSLIST_HEADER)v6, (PSINGLE_LIST_ENTRY)(a2 + 52));
        }
        else
        {
          InterlockedPushEntrySList((PSLIST_HEADER)(v6 + 8), (PSINGLE_LIST_ENTRY)(a2 + 52));
          if ( (signed int)QueryDepthSList((PSLIST_HEADER)(v6 + 8)) > *(_DWORD *)(v6 + 68) )
          {
            if ( (*(_DWORD *)(*(_DWORD *)(v6 + 36) + 404) & 0xA0000000) != -1610612736 )
            {
              _EDX = 1;
              _ECX = v6 + 72;
              __asm { lock cmpxchg [ecx], edx }
              v18 = InterlockedFlushSList((PSLIST_HEADER)(v6 + 8));
              v19 = *(_DWORD *)(v6 + 36);
              *(_DWORD *)(v6 + 16) = v18;
              sub_100333A7(v6 + 20, sub_10031ED6, v6, v19);
            }
          }
        }
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10033DDA) --------------------------------------------------------
int __thiscall sub_10033DDA(void *this)
{
  int result; // eax@1
  int v2; // esi@3

  result = *(_DWORD *)this;
  if ( *(_DWORD *)this )
  {
    v2 = *(_DWORD *)(result + 4);
    if ( result == v2 )
    {
      *(_DWORD *)this = 0;
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)(v2 + 4) + 8) = result;
      *(_DWORD *)(*(_DWORD *)this + 4) = *(_DWORD *)(v2 + 4);
    }
    result = v2;
  }
  return result;
}

//----- (10033E02) --------------------------------------------------------
_DWORD *__thiscall sub_10033E02(void *this)
{
  _DWORD *result; // eax@1
  _DWORD *v2; // esi@3

  result = *(_DWORD **)this;
  if ( *(_DWORD *)this )
  {
    v2 = (_DWORD *)*result;
    if ( result == (_DWORD *)*result )
    {
      *(_DWORD *)this = 0;
    }
    else
    {
      *(_DWORD *)(*v2 + 4) = result;
      **(_DWORD **)this = *v2;
    }
    result = v2;
  }
  return result;
}

//----- (10033E26) --------------------------------------------------------
_DWORD *__thiscall sub_10033E26(int this)
{
  void *v2; // edi@1
  void *v3; // esi@1
  _DWORD *v4; // edi@1

  v2 = (void *)this;
  v3 = (void *)(this + 4);
  sub_1002B98A((void *)(this + 4));
  v4 = sub_10033E02(v2);
  sub_1002BB74(v3);
  return v4;
}

//----- (10033E49) --------------------------------------------------------
int __thiscall sub_10033E49(int this, int a2)
{
  int v2; // ebx@1
  void *v3; // edi@1

  v2 = this;
  v3 = (void *)(this + 308);
  sub_1002B98A((void *)(this + 308));
  if ( *(_DWORD *)(a2 + 12) == 2 )
    sub_10033BAC((void *)(v2 + 304), a2);
  *(_DWORD *)(a2 + 12) = 0;
  return sub_1002BB74(v3);
}

//----- (10033E85) --------------------------------------------------------
char __thiscall sub_10033E85(int this, int a2)
{
  return sub_10033CDC((void *)(this + 96), a2, *(_DWORD *)(a2 + 24), 1);
}

//----- (10033E9D) --------------------------------------------------------
char __thiscall sub_10033E9D(int this)
{
  char result; // al@1
  int v2; // esi@1

  v2 = this;
  result = sub_10041408(this);
  *(_DWORD *)(v2 + 56) = 0;
  return result;
}

//----- (10033EAB) --------------------------------------------------------
int __thiscall sub_10033EAB(void *this, int a2, unsigned int a3)
{
  int result; // eax@1
  unsigned int v4; // esi@2
  unsigned int v5; // edi@4
  int v6; // eax@5
  int v7; // ebx@5
  char v8; // al@5
  int v9; // eax@5
  int v10; // esi@6
  int v11; // eax@9
  char v12; // [sp+0h] [bp-14h]@8
  int (__stdcall **v13)(char); // [sp+4h] [bp-10h]@18
  int v14; // [sp+8h] [bp-Ch]@7
  BOOL (__cdecl *v15)(); // [sp+Ch] [bp-8h]@7
  int v16; // [sp+10h] [bp-4h]@1

  result = a2;
  v16 = (int)this;
  if ( !a2 )
  {
    a3 = (unsigned int)"ppVirtualProcessorRoots";
    goto LABEL_18;
  }
  v4 = a3;
  if ( a3 < 1 )
  {
    a3 = (unsigned int)"count";
LABEL_18:
    sub_1002AEA4((int)&v13, (int *)&a3);
    v13 = &off_1005F2EC;
    sub_100355BB((int)&v13, (int)&unk_1006C8B4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10033FA1);
  }
  v5 = 0;
  if ( a3 )
  {
    do
    {
      v7 = *(_DWORD *)(result + 4 * v5);
      v8 = (*(int (__thiscall **)(int))(*(_DWORD *)v7 + 4))(v7);
      sub_10032C17(v16, v8);
      v9 = (**(int (__thiscall ***)(_DWORD))v7)(v7);
      v6 = sub_10045D49(*(_DWORD *)(*(_DWORD *)(v16 + 32) + 4 * v9), v7);
      if ( !v6 )
      {
        v10 = v16;
        do
        {
          v14 = 0;
          v15 = sub_10034BF4;
          while ( sub_100282E0((int)&v12) )
            ;
          SwitchToThread();
          v11 = (**(int (__thiscall ***)(_DWORD))v7)(v7);
          v6 = sub_10045D49(*(_DWORD *)(*(_DWORD *)(v10 + 32) + 4 * v11), v7);
        }
        while ( !v6 );
        v4 = a3;
      }
      if ( *(_BYTE *)(v6 + 160) )
        v6 = sub_10046752(*(_DWORD *)(v6 + 164), v6);
      if ( v6 )
        sub_10045356(v6);
      result = a2;
      ++v5;
    }
    while ( v5 < v4 );
  }
  return result;
}
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);

//----- (10033FA1) --------------------------------------------------------
int __thiscall sub_10033FA1(void *this)
{
  int v1; // eax@1
  void *v3; // edi@1
  int result; // eax@3

  v3 = this;
  _EBX = (int)((char *)this + 404);
  v1 = sub_10034134((int)((char *)this + 404), -2147483648);
  _EDX = v1 & 0x7FFFFFFF;
  __asm { lock cmpxchg [ebx], edx }
  while ( v1 != v1 )
  {
    _ECX = v1 & 0x7FFFFFFF;
    __asm { lock cmpxchg [ebx], ecx }
  }
  result = (int)((char *)v3 + 392);
  _ECX = 1;
  __asm { lock xadd [eax], ecx }
  return result;
}

//----- (10033FEE) --------------------------------------------------------
void *__cdecl sub_10033FEE(void *ListEntry)
{
  void *result; // eax@4

  if ( *((_BYTE *)ListEntry + 772) )
  {
    _ECX = &dword_100755E4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
  }
  if ( QueryDepthSList(&ListHead) >= 0x10u )
    result = sub_100319E6(ListEntry, 1);
  else
    result = InterlockedPushEntrySList(&ListHead, (PSINGLE_LIST_ENTRY)ListEntry);
  return result;
}
// 100755E4: using guessed type int dword_100755E4;

//----- (10034035) --------------------------------------------------------
LPVOID __cdecl sub_10034035()
{
  LPVOID result; // eax@2

  if ( dword_10072D14 & 0x80000000 )
    result = TlsGetValue(dwTlsIndex);
  else
    result = 0;
  return result;
}
// 10072D14: using guessed type int dword_10072D14;

//----- (10034051) --------------------------------------------------------
char __thiscall sub_10034051(void *this)
{
  int v2; // edx@2

  _ESI = (int)((char *)this + 384);
  while ( 1 )
  {
    v2 = *(_DWORD *)_ESI;
    if ( !*(_DWORD *)_ESI )
      break;
    _ECX = v2 + 1;
    __asm { lock cmpxchg [esi], ecx }
    if ( v2 == v2 )
      return 1;
  }
  return 0;
}

//----- (10034073) --------------------------------------------------------
int __thiscall sub_10034073(void *this)
{
  int v1; // eax@1
  void *v2; // edi@1
  int v3; // esi@1
  int v4; // ecx@3

  v2 = this;
  v1 = (int)sub_10032356();
  v3 = v1;
  if ( v1 && (void *)sub_10032DD0(v1) == v2 )
    v4 = sub_1002E9DD(v3);
  else
    v4 = *((_DWORD *)v2 + 44);
  return (**(int (***)(void))v4)();
}

//----- (100340A8) --------------------------------------------------------
int __thiscall sub_100340A8(void *this, int a2, int a3, int a4)
{
  int v4; // eax@1
  void *v5; // edi@1
  int v6; // esi@1
  int v7; // eax@3

  v5 = this;
  v4 = (int)sub_10032356();
  v6 = v4;
  if ( v4 && (void *)sub_10032DD0(v4) == v5 )
    v7 = sub_1002E9DD(v6);
  else
    v7 = *((_DWORD *)v5 + 44);
  return sub_100414B0((void *)v7, a2, a3, a4);
}

//----- (100340DE) --------------------------------------------------------
void __thiscall sub_100340DE(int this, int a2)
{
  if ( *(_DWORD *)(this + 12) == 1 )
    *(_DWORD *)(this + 376) = sub_10032B31(this, *(_DWORD *)(a2 + 184));
}

//----- (10034103) --------------------------------------------------------
int __cdecl sub_10034103(int a1, int a2)
{
  int result; // eax@1
  char v3; // [sp+8h] [bp-10h]@3
  int v4; // [sp+10h] [bp-8h]@2
  void (__cdecl *v5)(); // [sp+14h] [bp-4h]@2

  result = *(_DWORD *)a1;
  if ( *(_DWORD *)a1 & a2 )
  {
    v4 = 0;
    v5 = sub_10034BB6;
    do
    {
      sub_100282E0((int)&v3);
      result = *(_DWORD *)a1;
    }
    while ( *(_DWORD *)a1 & a2 );
  }
  return result;
}

//----- (10034134) --------------------------------------------------------
int __cdecl sub_10034134(int a1, int a2)
{
  int v2; // edx@1
  char v4; // [sp+4h] [bp-10h]@3
  int v5; // [sp+Ch] [bp-8h]@2
  void (__cdecl *v6)(); // [sp+10h] [bp-4h]@2

  v2 = *(_DWORD *)a1;
  if ( (a2 & *(_DWORD *)a1) != a2 )
  {
    v5 = 0;
    v6 = sub_10034BB6;
    do
    {
      sub_100282E0((int)&v4);
      v2 = *(_DWORD *)a1;
    }
    while ( (a2 & *(_DWORD *)a1) != a2 );
  }
  return v2;
}

//----- (1003416E) --------------------------------------------------------
char __thiscall sub_1003416E(void *this, int a2, char a3, int a4, int a5, int a6)
{
  void *v7; // esi@1
  char v8; // [sp-14h] [bp-1Ch]@1
  int v9; // [sp-10h] [bp-18h]@1
  int v10; // [sp-Ch] [bp-14h]@1
  int v11; // [sp-8h] [bp-10h]@1
  int v12; // [sp-4h] [bp-Ch]@1

  v12 = 3;
  v7 = this;
  sub_1002F3E5((int)&v8, (int)&a3);
  return sub_10034194(v7, a2, v8, v9, v10, v11, v12);
}

//----- (10034194) --------------------------------------------------------
char __thiscall sub_10034194(void *this, int a2, char a3, int a4, int a5, int a6, int a7)
{
  int v7; // ecx@1
  char v8; // bl@1
  int v9; // esi@1
  char v11; // [sp-14h] [bp-24h]@1
  int v12; // [sp-10h] [bp-20h]@1
  int v13; // [sp-Ch] [bp-1Ch]@1
  int v14; // [sp-8h] [bp-18h]@1
  int v15; // [sp-4h] [bp-14h]@1
  int v16; // [sp+8h] [bp-8h]@1
  int v17; // [sp+Ch] [bp-4h]@2

  v9 = (int)this;
  v8 = 0;
  sub_1002EF93(this);
  v15 = a7;
  v16 = 0;
  sub_1002F3E5((int)&v11, (int)&a3);
  if ( sub_100325AB(v9, (int)&v16, *(int *)&v11, v12, v13, v14, v15) )
  {
    sub_1004505B(v17, v16, a2, 0);
    v16 = 0;
    v8 = 1;
  }
  sub_1002EF93(v7);
  return v8;
}
// 1002EF93: using guessed type _DWORD __thiscall sub_1002EF93(_DWORD ecx0);

//----- (100341E8) --------------------------------------------------------
void __cdecl sub_100341E8()
{
  JUMPOUT(dword_100755B8, 0, *(unsigned int *)sub_10030FF5);
}
// 100755B8: using guessed type int dword_100755B8;

//----- (1003424B) --------------------------------------------------------
int __thiscall sub_1003424B(void *this, int a2, int a3, int a4)
{
  int v4; // edi@1
  void *v5; // esi@1
  int v6; // ebx@2
  int v7; // eax@4
  signed int v8; // esi@4
  int v9; // eax@5
  int v10; // edx@6
  int v11; // eax@6
  int v12; // ecx@6
  int result; // eax@10
  signed int v14; // ebx@10
  int v15; // edx@10
  int v16; // ecx@10
  int v17; // eax@12
  int v18; // edi@12
  int v19; // eax@13
  int v20; // edx@13
  int v21; // ecx@13
  void *v22; // [sp+Ch] [bp-Ch]@1
  int v23; // [sp+10h] [bp-8h]@5
  int i; // [sp+14h] [bp-4h]@1

  v5 = this;
  v4 = 0;
  v22 = this;
  for ( i = 0; v4 < *((_DWORD *)v5 + 11); i = v4 )
  {
    v6 = *(_DWORD *)(*((_DWORD *)v5 + 8) + 4 * v4);
    if ( v6 )
    {
      if ( *(_DWORD *)(v6 + 120) > 0 )
      {
        v8 = 0;
        v7 = v6 + 56;
        do
        {
          v9 = sub_100318B8(v7, v8);
          v23 = v9;
          if ( v9 )
          {
            v10 = *(_DWORD *)(v9 + 92) - *(_DWORD *)(v9 + 100);
            *(_DWORD *)(v9 + 100) = *(_DWORD *)(v9 + 92);
            v11 = *(_DWORD *)(v9 + 96);
            v12 = v11 - *(_DWORD *)(v23 + 104);
            *(_DWORD *)(v23 + 104) = v11;
            *(_DWORD *)a3 += v10;
            *(_DWORD *)a2 += v12;
            *(_DWORD *)a4 += v10 - v12;
          }
          ++v8;
          v7 = v6 + 56;
        }
        while ( v8 < *(_DWORD *)(v6 + 120) );
        v5 = v22;
        v4 = i;
      }
    }
    ++v4;
  }
  v15 = *((_DWORD *)v5 + 109) - *((_DWORD *)v5 + 111);
  *((_DWORD *)v5 + 111) = *((_DWORD *)v5 + 109);
  v16 = *((_DWORD *)v5 + 110) - *((_DWORD *)v5 + 112);
  *((_DWORD *)v5 + 112) = *((_DWORD *)v5 + 110);
  v14 = 0;
  *(_DWORD *)a3 += v15;
  *(_DWORD *)a2 += v16;
  result = a4;
  *(_DWORD *)result += v15 - v16;
  if ( *((_DWORD *)v5 + 66) > 0 )
  {
    result = (int)((char *)v5 + 200);
    do
    {
      v17 = sub_100318B8(result, v14);
      v18 = v17;
      if ( v17 )
      {
        v19 = *(_DWORD *)(v17 + 12);
        v20 = *(_DWORD *)(v18 + 8) - *(_DWORD *)(v18 + 16);
        *(_DWORD *)(v18 + 16) = *(_DWORD *)(v18 + 8);
        v21 = v19 - *(_DWORD *)(v18 + 20);
        *(_DWORD *)(v18 + 20) = v19;
        *(_DWORD *)a3 += v20;
        *(_DWORD *)a2 += v21;
        *(_DWORD *)a4 += v20 - v21;
        if ( !sub_1003341E(v18) )
        {
          sub_10033BDE((char *)v5 + 200, v18, *(_DWORD *)v18, 0);
          sub_1002A4AA((LPVOID)v18);
        }
      }
      ++v14;
      result = (int)((char *)v5 + 200);
    }
    while ( v14 < *((_DWORD *)v5 + 66) );
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10034384) --------------------------------------------------------
BOOL __thiscall sub_10034384(void *this)
{
  LPVOID v1; // eax@1
  int v2; // esi@1
  int v3; // eax@4
  BOOL result; // eax@5
  int v5; // eax@9
  char v8; // [sp+Fh] [bp-1h]@1

  v2 = (int)this;
  v1 = sub_10032356();
  v8 = 1;
  if ( v1 )
  {
    if ( !*((_BYTE *)v1 + 76) )
    {
      v8 = 0;
      sub_1004EAE4();
    }
  }
  v3 = (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 72))(v2);
  if ( v3 )
  {
    if ( v3 == 2 )
    {
      if ( !*(_DWORD *)(v2 + 408) )
        *(_DWORD *)(v2 + 408) = 1;
    }
    _EBX = v2 + 404;
    v5 = *(_DWORD *)(v2 + 404);
    do
    {
      _ECX = v5 & 0xBFFFFFFF;
      __asm { lock cmpxchg [ebx], ecx }
    }
    while ( v5 != v5 );
    result = sub_10033B8E(v2, v5 & 0x1FFFFFFF);
  }
  else
  {
    result = sub_100337AB(v2);
  }
  if ( !v8 )
    result = sub_1004EAE4();
  return result;
}

//----- (1003440E) --------------------------------------------------------
char __thiscall sub_1003440E(int this)
{
  char result; // al@1
  int ebp0; // ebp@0
  int v4; // edi@1
  int i; // eax@2
  char v6; // dl@4
  char v7; // al@4
  char v8; // al@7
  int v9; // ecx@13
  int v16; // esi@16
  ULONG v17; // eax@18
  int v18; // esi@18
  DWORD v19; // eax@18
  char v20; // [sp-14h] [bp-38h]@16
  int v21; // [sp-10h] [bp-34h]@16
  int v22; // [sp-Ch] [bp-30h]@16
  int v23; // [sp-8h] [bp-2Ch]@16
  int v24; // [sp-4h] [bp-28h]@16
  int v25; // [sp+Ch] [bp-18h]@16
  int v26; // [sp+14h] [bp-10h]@16
  int v27; // [sp+18h] [bp-Ch]@16
  __int16 v28; // [sp+22h] [bp-2h]@2

  result = 0;
  v4 = this;
  _EBX = this + 472;
  if ( *(_DWORD *)(this + 472) > 0 )
  {
    v28 = 0;
    for ( i = sub_1003293C(ebp0, 0); ; i = sub_1003293C(ebp0, 0) )
    {
      if ( !i )
      {
        v6 = HIBYTE(v28);
        v8 = 1;
        LOBYTE(v28) = 1;
        goto LABEL_10;
      }
      v7 = sub_100334A2(v4, i);
      v6 = v7 | HIBYTE(v28);
      HIBYTE(v28) |= v7;
      if ( *(_DWORD *)(v4 + 432) <= 0 )
        break;
      if ( sub_1003458A(v4, 1) )
      {
        v6 = HIBYTE(v28);
        break;
      }
    }
    v8 = v28;
LABEL_10:
    if ( !*(_DWORD *)(v4 + 408) && (v8 || *(_DWORD *)(v4 + 432) > 0) )
      goto LABEL_24;
    v9 = *(_DWORD *)_EBX;
    _EAX = -*(_DWORD *)_EBX;
    __asm { lock xadd [ebx], eax }
    result = _EAX != v9;
    if ( result )
    {
LABEL_18:
      v18 = sub_1003458A(v4, 1);
      v19 = GetTickCount();
      v17 = v19 - *(_DWORD *)(v4 + 456) < v18 ? v18 - (v19 - *(_DWORD *)(v4 + 456)) : 0;
      if ( (_BYTE)v28 )
      {
        if ( v17 < 0x1F4 )
          v17 = 500;
      }
      v24 = 2147483647;
      v23 = v17;
      v22 = *(_DWORD *)(v4 + 468);
      return ChangeTimerQueueTimer(0, (HANDLE)v22, v17, 0x7FFFFFFFu);
    }
    if ( *(_DWORD *)(v4 + 408) )
    {
      if ( !v6 )
      {
        v25 = 0;
        v26 = 0;
        v27 = 0;
        v16 = *(_DWORD *)(sub_10032B10(v4) + 8);
        v24 = 11;
        sub_1002F3E5((int)&v20, (int)&v25);
        result = sub_10034194((void *)v4, v16, v20, v21, v22, v23, v24);
        if ( !result )
        {
LABEL_24:
          *(_DWORD *)_EBX = 1;
          goto LABEL_18;
        }
      }
    }
  }
  return result;
}

//----- (10034533) --------------------------------------------------------
char __stdcall sub_10034533(int a1, int a2)
{
  return sub_1003440E(a1);
}

//----- (10034542) --------------------------------------------------------
char __stdcall sub_10034542(int a1, int a2)
{
  DWORD v2; // eax@1
  int v3; // esi@1
  char result; // al@2

  v3 = sub_1003458A(a1, 1);
  v2 = GetTickCount() - *(_DWORD *)(a1 + 456);
  if ( v2 >= v3 )
    result = sub_1003440E(a1);
  else
    result = ChangeTimerQueueTimer(0, *(HANDLE *)(a1 + 468), v3 - v2, 0x7FFFFFFFu);
  return result;
}

//----- (1003458A) --------------------------------------------------------
int __thiscall sub_1003458A(int this, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // ecx@1
  int result; // eax@2
  unsigned int v5; // eax@3
  int v6; // eax@4

  v2 = *(_DWORD *)(this + 400);
  v3 = *(_DWORD *)(this + 452);
  if ( v2 >= v3 )
  {
    v5 = v2 - v3;
    if ( v5 >= 0x64 )
    {
      if ( v5 >= 0x12C )
      {
        if ( v5 >= 0x258 )
        {
          if ( v5 >= 0x5DC )
          {
            if ( v5 >= 0x9C4 )
            {
              if ( v5 >= 0xFA0 )
                v6 = (v5 >> 1) + 8200;
              else
                v6 = v5 / 3 + 2500;
            }
            else
            {
              v6 = v5 / 3 + 555;
            }
          }
          else
          {
            v6 = (v5 >> 2) + 180;
          }
        }
        else
        {
          v6 = v5 / 5 + 60;
        }
      }
      else
      {
        v6 = (v5 >> 3) + 15;
      }
    }
    else
    {
      v6 = v5 / 0xA + 5;
    }
    result = a2 * v6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10034621) --------------------------------------------------------
int __cdecl sub_10034621(char a1, char a2, int a3)
{
  int v3; // ebx@1
  int result; // eax@2
  __int16 v5; // [sp+4h] [bp-40h]@2
  char v6; // [sp+6h] [bp-3Eh]@2
  char v7; // [sp+8h] [bp-3Ch]@2
  char v8; // [sp+9h] [bp-3Bh]@2
  int v9; // [sp+1Ch] [bp-28h]@2
  int v10; // [sp+20h] [bp-24h]@2
  int v11; // [sp+24h] [bp-20h]@2
  int v12; // [sp+28h] [bp-1Ch]@2
  int v13; // [sp+30h] [bp-14h]@2
  int v14; // [sp+38h] [bp-Ch]@2

  v3 = dword_100755B8;
  if ( dword_100755B8 )
  {
    sub_100391F0(&v6, 0, 62);
    v13 = 131072;
    v5 = 64;
    v7 = a1;
    v8 = a2;
    v9 = dword_100672E4[0];
    v10 = dword_100672E4[1];
    v11 = dword_100672E4[2];
    v12 = dword_100672E4[3];
    v14 = a3;
    result = sub_10030F55(v3, dword_100755B0, dword_100755B4, (int)&v5);
  }
  return result;
}
// 100755B0: using guessed type int dword_100755B0;
// 100755B4: using guessed type int dword_100755B4;
// 100755B8: using guessed type int dword_100755B8;

//----- (1003468C) --------------------------------------------------------
int __stdcall sub_1003468C(char a1, char a2, int a3)
{
  int result; // eax@2

  if ( a2 <= (unsigned __int8)byte_100755AC )
  {
    result = dword_100755A8;
    if ( dword_100755A8 & 1 )
      result = sub_10034621(a1, a2, a3);
  }
  return result;
}
// 100755A8: using guessed type int dword_100755A8;
// 100755AC: using guessed type char byte_100755AC;

//----- (100346B6) --------------------------------------------------------
int __thiscall sub_100346B6(int this, int a2)
{
  void *v2; // edi@1
  int v3; // esi@1

  v3 = this;
  v2 = (void *)(this + 324);
  sub_10034B9B((void *)(this + 324));
  if ( *(_DWORD *)a2 != *(_DWORD *)(v3 + 336) )
    sub_10033833((void *)v3);
  return sub_10034BAB(v2);
}

//----- (100346EB) --------------------------------------------------------
signed int __thiscall sub_100346EB(int this)
{
  int v1; // esi@1
  signed int result; // eax@4

  v1 = this;
  if ( sub_100326A8(this) || sub_100326D2((void *)v1) )
  {
    result = 1;
  }
  else
  {
    if ( *(_DWORD *)(v1 + 472) <= 0 )
      result = 0;
    else
      result = 2;
  }
  return result;
}

//----- (10034719) --------------------------------------------------------
int __thiscall sub_10034719(int this, int a2)
{
  int v2; // esi@1
  int result; // eax@5

  v2 = this;
  if ( a2 == -1 )
  {
    *(_DWORD *)(this + 340) = 0;
    *(_DWORD *)(this + 344) = sub_100320CA(this);
  }
  else
  {
    *(_DWORD *)(this + 340) = a2;
  }
  if ( *(_DWORD *)(v2 + 340) == *(_DWORD *)(v2 + 344) )
    result = 0;
  else
    result = *(_DWORD *)(v2 + 344);
  return result;
}

//----- (10034761) --------------------------------------------------------
signed int __thiscall sub_10034761(int this)
{
  signed int v1; // ecx@1
  int v2; // esi@1
  signed int result; // eax@2

  v2 = this;
  v1 = sub_100320CA(this);
  if ( (unsigned int)v1 > *(_DWORD *)(v2 + 344) )
  {
    if ( *(_DWORD *)(v2 + 344) == *(_DWORD *)(v2 + 340) )
      result = v1;
    else
      result = 0;
    *(_DWORD *)(v2 + 344) = v1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10034793) --------------------------------------------------------
char __thiscall sub_10034793(int this, int a2)
{
  void *v2; // esi@1
  int v3; // eax@2
  int v5; // edx@3
  char result; // al@8
  int v15; // edi@9

  v2 = (void *)this;
  if ( (_BYTE)a2 )
  {
    _EDI = this + 404;
    v3 = *(_DWORD *)(this + 404);
    while ( 1 )
    {
      v5 = v3;
      if ( v3 & 0x40000000 )
        v5 = sub_10034103((int)((char *)v2 + 404), 1073741824);
      if ( v5 & 0x20000000 )
        break;
      _ECX = v5 + 1;
      v3 = v5;
      __asm { lock cmpxchg [edi], ecx }
      if ( v5 == v5 )
      {
        _EAX = (int)((char *)v2 + 424);
        _ECX = 1;
        __asm { lock xadd [eax], ecx }
        (*(void (__thiscall **)(void *, int, int))(*(_DWORD *)v2 + 68))(v2, a2, _ECX + 1);
        goto LABEL_12;
      }
    }
    result = 0;
  }
  else
  {
    _EDI = -1;
    _EAX = this + 424;
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    (*(void (__thiscall **)(void *, _DWORD, int))(*(_DWORD *)v2 + 68))(v2, 0, _ECX - 1);
    _EAX = (int)((char *)v2 + 404);
    __asm { lock xadd [eax], edi }
    v15 = _EDI - 1;
    if ( !(v15 & 0x1FFFFFFF) )
    {
      if ( v15 < 0 )
        sub_10031E1F(v2);
    }
LABEL_12:
    result = 1;
  }
  return result;
}

//----- (10034834) --------------------------------------------------------
int __thiscall sub_10034834(void *this, char a2)
{
  void *v3; // esi@1
  int v4; // ecx@2

  v3 = this;
  sub_1002EF93(this);
  _EAX = (int)((char *)v3 + 404);
  if ( a2 )
  {
    _ECX = -1;
    __asm { lock xadd [eax], ecx }
    v4 = _ECX - 1;
    if ( !(v4 & 0x1FFFFFFF) )
    {
      if ( v4 < 0 )
        sub_10031E1F(v3);
    }
  }
  else
  {
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
    v4 = _ECX + 1;
    if ( v4 & 0x40000000 )
      WaitForSingleObject(*((HANDLE *)v3 + 95), 0xFFFFFFFFu);
  }
  return sub_1002EF93(v4);
}
// 1002EF93: using guessed type _DWORD __thiscall sub_1002EF93(_DWORD ecx0);

//----- (10034890) --------------------------------------------------------
int __thiscall sub_10034890(void *this)
{
  return (*(int (**)(void))(**(_DWORD **)this + 16))();
}

//----- (10034897) --------------------------------------------------------
int __thiscall sub_10034897(void *this)
{
  return (*(int (**)(void))(**(_DWORD **)this + 20))();
}

//----- (1003489E) --------------------------------------------------------
void __cdecl sub_1003489E()
{
  JUMPOUT((unsigned int)hLibModule, 0, *(unsigned int *)sub_10031EE2);
}

//----- (100348AC) --------------------------------------------------------
void *__thiscall sub_100348AC(void *this, int a2)
{
  _ESI = a2;
  _EDX = 1;
  *(_DWORD *)this = a2;
  __asm { lock cmpxchg [esi], edx }
  return this;
}

//----- (100348F2) --------------------------------------------------------
_DWORD *__thiscall sub_100348F2(void *this)
{
  _DWORD *result; // eax@1

  result = *(_DWORD **)this;
  **(_DWORD **)this = 0;
  return result;
}

//----- (100348F9) --------------------------------------------------------
int __cdecl sub_100348F9(int a1)
{
  return a1 ^ dword_10075F58;
}
// 10075F58: using guessed type int dword_10075F58;

//----- (10034906) --------------------------------------------------------
BOOL __cdecl sub_10034906(int a1)
{
  BOOL result; // eax@1

  sub_10039817(a1, 0, 0, 0);
  sub_1003987F(a1, 1);
  sub_100393F3(a1);
  sub_10031EE2();
  result = (BOOL)hLibModule;
  if ( hLibModule )
    result = FreeLibrary(hLibModule);
  return result;
}

//----- (10034942) --------------------------------------------------------
HMODULE __cdecl sub_10034942(DWORD dwExitCode)
{
  HMODULE result; // eax@1

  _ECX = &unk_10075600;
  _EAX = -1;
  __asm { lock xadd [ecx], eax }
  if ( _ZF )
  {
    sub_10031EE2();
    result = hLibModule;
    if ( hLibModule )
      FreeLibraryAndExitThread(hLibModule, dwExitCode);
  }
  return result;
}

//----- (1003496D) --------------------------------------------------------
unsigned int __cdecl sub_1003496D()
{
  unsigned int v0; // esi@1
  HANDLE v1; // eax@1
  struct _FILETIME CreationTime; // [sp+4h] [bp-10h]@1
  struct _FILETIME ExitTime; // [sp+Ch] [bp-8h]@1

  dword_10075F38 = 1;
  v0 = __security_cookie ^ (unsigned int)EncodePointer(&dword_10075F58);
  v1 = GetCurrentThread();
  if ( GetThreadTimes(v1, &CreationTime, &ExitTime, &ExitTime, &ExitTime) )
    v0 ^= CreationTime.dwLowDateTime ^ CreationTime.dwHighDateTime;
  return v0;
}
// 10073200: using guessed type int __security_cookie;
// 10075F38: using guessed type int dword_10075F38;
// 10075F58: using guessed type int dword_10075F58;

//----- (100349B9) --------------------------------------------------------
HANDLE __cdecl sub_100349B9(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
{
  HANDLE v6; // edi@1

  v6 = CreateThread(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
  if ( v6 )
  {
    _ESI = 1;
    _EAX = &unk_10075600;
    _ECX = 1;
    __asm { lock xadd [eax], ecx }
    if ( _ECX == 0 )
    {
      sub_10034A04();
      _EAX = &dword_10072D14;
      __asm { lock xadd [eax], esi }
    }
  }
  return v6;
}
// 10072D14: using guessed type int dword_10072D14;

//----- (10034A04) --------------------------------------------------------
HMODULE __cdecl sub_10034A04()
{
  HMODULE result; // eax@1
  DWORD v1; // eax@2
  int v2; // eax@6
  char v3; // [sp+4h] [bp-21Ch]@8
  WCHAR LibFileName; // [sp+14h] [bp-20Ch]@2
  unsigned int v5; // [sp+21Ch] [bp-4h]@1
  int v6; // [sp+220h] [bp+0h]@1

  v5 = (unsigned int)&v6 ^ __security_cookie;
  result = GetModuleHandleA(0);
  if ( result != (HMODULE)268435456 )
  {
    v1 = GetModuleFileNameW((HMODULE)0x10000000, &LibFileName, 0x104u);
    if ( !v1 || v1 == 260 )
    {
      v2 = GetLastError();
      if ( v2 > 0 )
        v2 = (unsigned __int16)v2 | 0x80070000;
      sub_10030079((int)&v3, v2);
      sub_100355BB((int)&v3, (int)&unk_1006B6E0);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_10034A98);
    }
    result = LoadLibraryExW(&LibFileName, 0, 0);
    hLibModule = result;
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;

//----- (10034A98) --------------------------------------------------------
int __cdecl sub_10034A98(unsigned int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  __int64 v12; // [sp+8h] [bp-8h]@2

  result = sub_1003944A(a2, a3, 0);
  v4 = result;
  if ( result )
  {
    sub_10034A04();
    _ECX = &dword_10072D14;
    _EAX = 1;
    __asm { lock xadd [ecx], eax }
    v12 = sub_10039A20(a1, -10000i64);
    sub_10039817(v4, (int)&v12, 0, 0);
    result = v4;
  }
  return result;
}
// 10072D14: using guessed type int dword_10072D14;

//----- (10034AF2) --------------------------------------------------------
int __cdecl sub_10034AF2(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  result = sub_1003946B(a2, a3, 0);
  v4 = result;
  if ( result )
  {
    sub_10034A04();
    _ECX = &dword_10072D14;
    _EAX = 1;
    __asm { lock xadd [ecx], eax }
    sub_10039837(v4, a1, 0);
    result = v4;
  }
  return result;
}
// 10072D14: using guessed type int dword_10072D14;

//----- (10034B30) --------------------------------------------------------
int __cdecl sub_10034B30(int a1, int a2)
{
  int result; // eax@1

  sub_10039817(a2, 0, 0, 0);
  sub_100393F3(a2);
  sub_10031EE2();
  result = (int)hLibModule;
  if ( hLibModule )
    result = sub_1003951A(a1, (int)hLibModule);
  return result;
}

//----- (10034B66) --------------------------------------------------------
int __cdecl sub_10034B66(int a1, int a2)
{
  int result; // eax@1

  sub_10039837(a2, 0, 0);
  sub_1003940A(a2);
  sub_10031EE2();
  result = (int)hLibModule;
  if ( hLibModule )
    result = sub_1003951A(a1, (int)hLibModule);
  return result;
}

//----- (10034B9B) --------------------------------------------------------
int __thiscall sub_10034B9B(void *this)
{
  void *v2; // esi@1

  v2 = this;
  sub_1002EF93(this);
  return sub_10030FB0(v2);
}
// 1002EF93: using guessed type _DWORD __thiscall sub_1002EF93(_DWORD ecx0);

//----- (10034BAB) --------------------------------------------------------
int __thiscall sub_10034BAB(void *this)
{
  *(_DWORD *)this = 0;
  return sub_1002EF93(this);
}
// 1002EF93: using guessed type _DWORD __thiscall sub_1002EF93(_DWORD ecx0);

//----- (10034BB6) --------------------------------------------------------
void __cdecl sub_10034BB6()
{
  Sleep(0);
}

//----- (10034BBF) --------------------------------------------------------
char __thiscall sub_10034BBF(void *this)
{
  int v1; // ecx@1
  char v2; // bl@1
  void *v3; // esi@1

  v3 = this;
  sub_1002EF93(this);
  v2 = sub_10034BDF(v3);
  if ( !v2 )
    sub_1002EF93(v1);
  return v2;
}
// 1002EF93: using guessed type _DWORD __thiscall sub_1002EF93(_DWORD ecx0);

//----- (10034BDF) --------------------------------------------------------
char __thiscall sub_10034BDF(void *this)
{
  char v1; // dl@2
  int v2; // eax@2

  if ( *(_DWORD *)this || (v1 = 1, v2 = *(_DWORD *)this, *(_DWORD *)this = 1, v2) )
    v1 = 0;
  return v1;
}

//----- (10034BF4) --------------------------------------------------------
BOOL __cdecl sub_10034BF4()
{
  LPVOID v0; // eax@1
  BOOL result; // eax@2

  v0 = sub_10034035();
  if ( v0 )
    result = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v0 + 32))(v0);
  else
    result = SwitchToThread();
  return result;
}

//----- (10034C0A) --------------------------------------------------------
void __usercall sub_10034C0A(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, int a7)
{
  int v7; // edx@6
  int v8; // ecx@6
  int v9; // eax@6
  int v10; // ecx@8
  int v11; // eax@9
  void *v12; // eax@25
  int v13; // esi@25
  int v14; // edx@26
  int v15; // [sp-4h] [bp-2Ch]@24
  int v16; // [sp-4h] [bp-2Ch]@26

  if ( a6 == 1 )
  {
    if ( sub_10044972() )
    {
      if ( sub_10041A8C(a3) )
      {
        sub_10048A61();
        dword_10077954 = (int)GetCommandLineA();
        dword_10075614 = (LPVOID)sub_100489D6(a3);
        sub_1004832E(v7, v8, a3, a4);
        if ( v9 >= 0 )
        {
          if ( sub_1004862E(a3) >= 0 )
          {
            v11 = sub_1004885B(v10, a3);
            if ( v11 >= 0 )
            {
              if ( !sub_1003AFAE(v11, a3, a4, 0) )
              {
                ++dword_10075610;
                return;
              }
            }
          }
          sub_100485DC(a3);
        }
        sub_10041B02();
      }
      sub_10044987();
    }
  }
  else
  {
    if ( a6 )
    {
      if ( a6 == 2 )
      {
        if ( !sub_100394C9(dword_100734B0) )
        {
          v12 = sub_100374E6(v15, a3, 1u, 0x3BCu);
          v13 = (int)v12;
          if ( v12 )
          {
            if ( sub_100394E8(dword_100734B0, v12) )
            {
              sub_100419D9(v14, v16, a3, v13);
              *(_DWORD *)v13 = GetCurrentThreadId();
              *(_DWORD *)(v13 + 4) = -1;
            }
            else
            {
              sub_100309C2(a3, (LPVOID)v13);
            }
          }
        }
      }
      else
      {
        if ( a6 == 3 )
          sub_1004191C(a3, a4, 0);
      }
    }
    else
    {
      if ( dword_10075610 > 0 )
      {
        --dword_10075610;
        if ( !dword_10075850 )
          sub_1003AF9E(a1, a2, a3, a4);
        sub_1003AE72(a3);
        if ( !a7 )
        {
          sub_100485DC(a3);
          sub_10041B02();
          sub_10044987();
        }
        if ( !a7 )
        {
          if ( dword_100734B0 != -1 )
            sub_10041B02();
        }
      }
    }
  }
}
// 100734B0: using guessed type int dword_100734B0;
// 10075610: using guessed type int dword_10075610;
// 10075850: using guessed type int dword_10075850;
// 10077954: using guessed type int dword_10077954;

//----- (10034D7C) --------------------------------------------------------
BOOL __stdcall DllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)
{
  int v4; // edx@3
  int v5; // ebx@3
  int v6; // edi@3

  if ( fdwReason == 1 )
    sub_1004893C();
  return sub_10034D9F(v4, v5, v6, (int)hinstDLL, fdwReason, (int)lpReserved);
}

//----- (10034D9F) --------------------------------------------------------
int __usercall sub_10034D9F<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4, int a5, int a6)
{
  int v6; // eax@1
  int v7; // ecx@5
  int v8; // eax@8
  signed int v9; // eax@9
  int v10; // edx@9
  int v11; // ecx@9
  int v12; // edi@9
  int v13; // eax@15
  int result; // eax@18

  v6 = 1;
  if ( !a5 && !dword_10075610 )
    goto LABEL_22;
  if ( a5 != 1 && a5 != 2 )
    goto LABEL_23;
  v7 = (int)dword_10060FA0;
  if ( dword_10060FA0 )
    v6 = dword_10060FA0(a4, a5, a6);
  if ( v6 && (sub_10034C0A(a1, v7, a2, a3, a4, a5, a6), v8) )
  {
LABEL_23:
    v9 = sub_1000C8F0(a4, a5, a6);
    v12 = v9;
    if ( a5 == 1 )
    {
      if ( !v9 )
      {
        sub_1000C8F0(a4, 0, a6);
        sub_10034C0A(v10, v11, a6, v12, a4, v12, a6);
        if ( dword_10060FA0 )
          dword_10060FA0(a4, v12, a6);
      }
    }
    if ( !a5 || a5 == 3 )
    {
      sub_10034C0A(v10, v11, a6, v12, a4, a5, a6);
      v12 = v13 != 0 ? v12 : 0;
      if ( v12 )
      {
        if ( dword_10060FA0 )
          v12 = dword_10060FA0(a4, a5, a6);
      }
    }
    result = v12;
  }
  else
  {
LABEL_22:
    result = 0;
  }
  return result;
}
// 10060FA0: using guessed type int (__stdcall *dword_10060FA0)(_DWORD, _DWORD, _DWORD);
// 10075610: using guessed type int dword_10075610;

//----- (10034EAD) --------------------------------------------------------
int __usercall sub_10034EAD<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, int a7, int a8, int a9)
{
  if ( a6 == 1 )
    sub_10034C0A(a1, a2, a3, a4, a5, 0, a7);
  return sub_10048310(a3, a8, a9);
}

//----- (10034EE0) --------------------------------------------------------
void *__cdecl sub_10034EE0(void *a1, const void *a2, unsigned int a3)
{
  int v38; // eax@29
  int v43; // edx@34
  unsigned int v44; // ecx@34
  void *result; // eax@48
  int v46; // edi@52
  int v47; // esi@52
  int v48; // edx@53
  unsigned int v49; // ecx@53
  int v50; // eax@64
  unsigned int k; // edx@65
  unsigned int v52; // edx@65
  int v53; // ecx@65
  unsigned int l; // edx@68
  int v55; // ecx@70
  char v56; // al@71
  unsigned int m; // ecx@71
  int n; // ecx@73
  unsigned int v59; // eax@76
  int i; // ecx@76
  unsigned int j; // eax@78
  int v62; // [sp-8h] [bp-10h]@76

  _ESI = (int)a2;
  _ECX = a3;
  _EDI = (int)a1;
  if ( a1 > a2 && a1 < (char *)a2 + a3 )
  {
    v47 = (int)(a2 + a3 - 4);
    v46 = (int)(a1 + a3 - 4);
    if ( v46 & 3 )
    {
      if ( a3 >= 4 )
        JUMPOUT(__CS__, *((_DWORD *)loc_100352B4 + (v46 & 3) + 1));
      switch ( a3 )
      {
        case 0u:
LABEL_60:
          result = a1;
          break;
        case 1u:
LABEL_61:
          *(_BYTE *)(v46 + 3) = *(_BYTE *)(v47 + 3);
          result = a1;
          break;
        case 2u:
LABEL_62:
          *(_BYTE *)(v46 + 3) = *(_BYTE *)(v47 + 3);
          *(_BYTE *)(v46 + 2) = *(_BYTE *)(v47 + 2);
          result = a1;
          break;
        case 3u:
          goto LABEL_63;
      }
    }
    else
    {
      v49 = a3 >> 2;
      v48 = a3 & 3;
      if ( a3 >> 2 < 8 )
      {
        switch ( -v49 )
        {
          case 0:
            switch ( v48 )
            {
              case 0:
                goto LABEL_60;
              case 1:
                goto LABEL_61;
              case 2:
                goto LABEL_62;
              case 3:
                goto LABEL_63;
            }
        }
      }
      else
      {
        memcpy((void *)v46, (const void *)v47, 4 * v49);
        v47 += 4 * v49;
        v46 += 4 * v49;
        switch ( v48 )
        {
          case 0:
            goto LABEL_60;
          case 1:
            goto LABEL_61;
          case 2:
            goto LABEL_62;
          case 3:
            break;
        }
      }
LABEL_63:
      *(_BYTE *)(v46 + 3) = *(_BYTE *)(v47 + 3);
      *(_BYTE *)(v46 + 2) = *(_BYTE *)(v47 + 2);
      *(_BYTE *)(v46 + 1) = *(_BYTE *)(v47 + 1);
      result = a1;
    }
  }
  else
  {
    __asm { bt      dword_10075780, 1 }
    if ( _CF )
    {
      memcpy(a1, a2, a3);
      return a1;
    }
    if ( a3 < 0x80 )
      goto LABEL_33;
    if ( ((unsigned int)a2 ^ (unsigned int)a1) & 0xF )
      goto LABEL_83;
    __asm { bt      dword_10073238, 1 }
    if ( !_CF )
    {
LABEL_83:
      __asm { bt      dword_10075780, 0 }
      if ( _CF )
      {
        if ( !((_BYTE)a1 & 3) )
        {
          if ( !((_BYTE)a2 & 3) )
          {
            __asm { bt      edi, 2 }
            if ( _CF )
            {
              _ECX = a3 - 4;
              _ESI = (int)((char *)a2 + 4);
              *(_DWORD *)a1 = *(_DWORD *)a2;
              _EDI = (int)((char *)a1 + 4);
            }
            __asm { bt      edi, 3 }
            if ( _CF )
            {
              __asm { movq    xmm1, qword ptr [esi] }
              _ECX -= 8;
              _ESI += 8;
              __asm { movq    qword ptr [edi], xmm1 }
              _EDI += 8;
            }
            if ( _ESI & 7 )
            {
              __asm { bt      esi, 3 }
              if ( _CF )
              {
                __asm { movdqa  xmm1, xmmword ptr [esi-0Ch] }
                _ESI = _ESI - 12;
                do
                {
                  __asm { movdqa  xmm3, xmmword ptr [esi+10h] }
                  _ECX -= 48;
                  __asm
                  {
                    movdqa  xmm0, xmmword ptr [esi+20h]
                    movdqa  xmm5, xmmword ptr [esi+30h]
                  }
                  _ESI += 48;
                  __asm
                  {
                    movdqa  xmm2, xmm3
                    palignr xmm3, xmm1, 0Ch
                    movdqa  xmmword ptr [edi], xmm3
                    movdqa  xmm4, xmm0
                    palignr xmm0, xmm2, 0Ch
                    movdqa  xmmword ptr [edi+10h], xmm0
                    movdqa  xmm1, xmm5
                    palignr xmm5, xmm4, 0Ch
                    movdqa  xmmword ptr [edi+20h], xmm5
                  }
                  _EDI += 48;
                }
                while ( _ECX >= 48 );
                _ESI = _ESI + 12;
              }
              else
              {
                __asm { movdqa  xmm1, xmmword ptr [esi-4] }
                _ESI = _ESI - 4;
                do
                {
                  __asm { movdqa  xmm3, xmmword ptr [esi+10h] }
                  _ECX -= 48;
                  __asm
                  {
                    movdqa  xmm0, xmmword ptr [esi+20h]
                    movdqa  xmm5, xmmword ptr [esi+30h]
                  }
                  _ESI += 48;
                  __asm
                  {
                    movdqa  xmm2, xmm3
                    palignr xmm3, xmm1, 4
                    movdqa  xmmword ptr [edi], xmm3
                    movdqa  xmm4, xmm0
                    palignr xmm0, xmm2, 4
                    movdqa  xmmword ptr [edi+10h], xmm0
                    movdqa  xmm1, xmm5
                    palignr xmm5, xmm4, 4
                    movdqa  xmmword ptr [edi+20h], xmm5
                  }
                  _EDI += 48;
                }
                while ( _ECX >= 48 );
                _ESI = _ESI + 4;
              }
            }
            else
            {
              __asm { movdqa  xmm1, xmmword ptr [esi-8] }
              _ESI = _ESI - 8;
              do
              {
                __asm { movdqa  xmm3, xmmword ptr [esi+10h] }
                _ECX -= 48;
                __asm
                {
                  movdqa  xmm0, xmmword ptr [esi+20h]
                  movdqa  xmm5, xmmword ptr [esi+30h]
                }
                _ESI += 48;
                __asm
                {
                  movdqa  xmm2, xmm3
                  palignr xmm3, xmm1, 8
                  movdqa  xmmword ptr [edi], xmm3
                  movdqa  xmm4, xmm0
                  palignr xmm0, xmm2, 8
                  movdqa  xmmword ptr [edi+10h], xmm0
                  movdqa  xmm1, xmm5
                  palignr xmm5, xmm4, 8
                  movdqa  xmmword ptr [edi+20h], xmm5
                }
                _EDI += 48;
              }
              while ( _ECX >= 48 );
              _ESI = _ESI + 8;
            }
            while ( _ECX >= 16 )
            {
              __asm { movdqu  xmm1, xmmword ptr [esi] }
              _ECX -= 16;
              _ESI += 16;
              __asm { movdqa  xmmword ptr [edi], xmm1 }
              _EDI += 16;
            }
            __asm { bt      ecx, 2 }
            if ( _CF )
            {
              v38 = *(_DWORD *)_ESI;
              _ECX -= 4;
              _ESI += 4;
              *(_DWORD *)_EDI = v38;
              _EDI += 4;
            }
            __asm { bt      ecx, 3 }
            if ( _CF )
            {
              __asm { movq    xmm1, qword ptr [esi] }
              _ECX -= 8;
              __asm { movq    qword ptr [edi], xmm1 }
            }
            JUMPOUT(__CS__, *((_DWORD *)off_10035218 + _ECX));
          }
          goto LABEL_34;
        }
        goto LABEL_36;
      }
LABEL_33:
      if ( !((_BYTE)a1 & 3) )
      {
LABEL_34:
        v44 = a3 >> 2;
        v43 = a3 & 3;
        if ( a3 >> 2 < 8 )
        {
          switch ( v44 )
          {
            case 0u:
              goto LABEL_47;
            case 1u:
              goto LABEL_46;
            case 2u:
              goto LABEL_45;
            case 3u:
              goto LABEL_44;
            case 4u:
              goto LABEL_43;
            case 5u:
              goto LABEL_42;
            case 6u:
              break;
            case 7u:
              *((_DWORD *)a1 + v44 - 7) = *((_DWORD *)a2 + v44 - 7);
              break;
          }
          *((_DWORD *)a1 + v44 - 6) = *((_DWORD *)a2 + v44 - 6);
LABEL_42:
          *((_DWORD *)a1 + v44 - 5) = *((_DWORD *)a2 + v44 - 5);
LABEL_43:
          *((_DWORD *)a1 + v44 - 4) = *((_DWORD *)a2 + v44 - 4);
LABEL_44:
          *((_DWORD *)a1 + v44 - 3) = *((_DWORD *)a2 + v44 - 3);
LABEL_45:
          *((_DWORD *)a1 + v44 - 2) = *((_DWORD *)a2 + v44 - 2);
LABEL_46:
          *((_DWORD *)a1 + v44 - 1) = *((_DWORD *)a2 + v44 - 1);
          _ESI = (int)((char *)a2 + 4 * v44);
          _EDI = (int)((char *)a1 + 4 * v44);
LABEL_47:
          switch ( v43 )
          {
            case 0:
              return a1;
            case 1:
LABEL_49:
              *(_BYTE *)_EDI = *(_BYTE *)_ESI;
              return a1;
            case 2:
LABEL_50:
              *(_BYTE *)_EDI = *(_BYTE *)_ESI;
              *(_BYTE *)(_EDI + 1) = *(_BYTE *)(_ESI + 1);
              return a1;
            case 3:
              break;
          }
        }
        else
        {
          memcpy(a1, a2, 4 * v44);
          _ESI = (int)((char *)a2 + 4 * v44);
          _EDI = (int)((char *)a1 + 4 * v44);
          switch ( v43 )
          {
            case 0:
              return a1;
            case 1:
              goto LABEL_49;
            case 2:
              goto LABEL_50;
            case 3:
              break;
          }
        }
        *(_BYTE *)_EDI = *(_BYTE *)_ESI;
        *(_BYTE *)(_EDI + 1) = *(_BYTE *)(_ESI + 1);
        *(_BYTE *)(_EDI + 2) = *(_BYTE *)(_ESI + 2);
        return a1;
      }
LABEL_36:
      if ( a3 >= 4 )
        JUMPOUT(__CS__, *((_DWORD *)loc_10035128 + ((_BYTE)a1 & 3) + 1));
      JUMPOUT(__CS__, *((_DWORD *)loc_10035228 + a3 - 4));
    }
    v50 = (_BYTE)a2 & 0xF;
    if ( (_BYTE)a2 & 0xF )
    {
      v62 = a3 - (16 - v50);
      v59 = 16 - v50;
      for ( i = v59 & 3; i; --i )
        *(_BYTE *)_EDI++ = *(_BYTE *)_ESI++;
      for ( j = v59 >> 2; j; --j )
      {
        *(_DWORD *)_EDI = *(_DWORD *)_ESI;
        _ESI += 4;
        _EDI += 4;
      }
      _ECX = v62;
    }
    v52 = _ECX;
    v53 = _ECX & 0x7F;
    for ( k = v52 >> 7; k; --k )
    {
      __asm
      {
        movdqa  xmm0, xmmword ptr [esi]
        movdqa  xmm1, xmmword ptr [esi+10h]
        movdqa  xmm2, xmmword ptr [esi+20h]
        movdqa  xmm3, xmmword ptr [esi+30h]
        movdqa  xmmword ptr [edi], xmm0
        movdqa  xmmword ptr [edi+10h], xmm1
        movdqa  xmmword ptr [edi+20h], xmm2
        movdqa  xmmword ptr [edi+30h], xmm3
        movdqa  xmm4, xmmword ptr [esi+40h]
        movdqa  xmm5, xmmword ptr [esi+50h]
        movdqa  xmm6, xmmword ptr [esi+60h]
        movdqa  xmm7, xmmword ptr [esi+70h]
        movdqa  xmmword ptr [edi+40h], xmm4
        movdqa  xmmword ptr [edi+50h], xmm5
        movdqa  xmmword ptr [edi+60h], xmm6
        movdqa  xmmword ptr [edi+70h], xmm7
      }
      _ESI += 128;
      _EDI += 128;
    }
    if ( v53 )
    {
      for ( l = (unsigned int)v53 >> 4; l; --l )
      {
        __asm
        {
          movdqa  xmm0, xmmword ptr [esi]
          movdqa  xmmword ptr [edi], xmm0
        }
        _ESI += 16;
        _EDI += 16;
      }
      v55 = v53 & 0xF;
      if ( v55 )
      {
        v56 = v55;
        for ( m = (unsigned int)v55 >> 2; m; --m )
        {
          *(_DWORD *)_EDI = *(_DWORD *)_ESI;
          _ESI += 4;
          _EDI += 4;
        }
        for ( n = v56 & 3; n; --n )
          *(_BYTE *)_EDI++ = *(_BYTE *)_ESI++;
      }
    }
    result = a1;
  }
  return result;
}
// 10035128: using guessed type int __cdecl loc_10035128(int, int, int);
// 10035218: using guessed type int __cdecl off_10035218(int, int, int);
// 10035228: using guessed type int __cdecl loc_10035228(int, int, int);
// 100352B4: using guessed type int __cdecl loc_100352B4(int, int, int);

//----- (10035530) --------------------------------------------------------
int __cdecl sub_10035530(int a1)
{
  int v1; // ecx@1
  char v2; // al@2
  int v3; // eax@4
  int v4; // eax@5
  int result; // eax@10

  v1 = a1;
  if ( a1 & 3 )
  {
    while ( 1 )
    {
      v2 = *(_BYTE *)v1++;
      if ( !v2 )
        break;
      if ( !(v1 & 3) )
        goto LABEL_4;
    }
LABEL_10:
    result = v1 - 1 - a1;
  }
  else
  {
    while ( 1 )
    {
      do
      {
LABEL_4:
        v3 = (*(_DWORD *)v1 + 2130640639) ^ ~*(_DWORD *)v1;
        v1 += 4;
      }
      while ( !(v3 & 0x81010100) );
      v4 = *(_DWORD *)(v1 - 4);
      if ( !(_BYTE)v4 )
        break;
      if ( !BYTE1(v4) )
        return v1 - 3 - a1;
      if ( !(v4 & 0xFF0000) )
        return v1 - 2 - a1;
      if ( !(v4 & 0xFF000000) )
        goto LABEL_10;
    }
    result = v1 - 4 - a1;
  }
  return result;
}

//----- (100355BB) --------------------------------------------------------
void __stdcall sub_100355BB(int a1, int a2)
{
  int v2; // eax@1
  DWORD dwExceptionCode; // [sp+8h] [bp-20h]@1
  DWORD dwExceptionFlags; // [sp+Ch] [bp-1Ch]@7
  DWORD nNumberOfArguments; // [sp+18h] [bp-10h]@7
  ULONG_PTR Arguments; // [sp+1Ch] [bp-Ch]@6
  int v7; // [sp+20h] [bp-8h]@4
  int v8; // [sp+24h] [bp-4h]@4

  v2 = a2;
  memcpy(&dwExceptionCode, &unk_10060FA4, 0x20u);
  if ( a2 )
  {
    if ( *(_BYTE *)a2 & 0x10 )
      v2 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 - 4) + 24);
  }
  v7 = a1;
  v8 = v2;
  if ( v2 )
  {
    if ( *(_BYTE *)v2 & 8 )
      Arguments = 26820608;
  }
  RaiseException(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, &Arguments);
}

//----- (10035616) --------------------------------------------------------
#error "10035621: positive sp value has been found (funcsize=3)"

//----- (1003562A) --------------------------------------------------------
#error "1003562F: call analysis failed (funcsize=4)"

//----- (10035639) --------------------------------------------------------
#error "1003563E: call analysis failed (funcsize=4)"

//----- (10035648) --------------------------------------------------------
char *__cdecl sub_10035648()
{
  char v1; // [sp-8h] [bp-8h]@1

  return &v1;
}

//----- (1003567B) --------------------------------------------------------
char *__cdecl sub_1003567B()
{
  char v1; // [sp-8h] [bp-8h]@1

  return &v1;
}

//----- (100356B1) --------------------------------------------------------
char *__cdecl sub_100356B1()
{
  char v1; // [sp-8h] [bp-8h]@1

  return &v1;
}

//----- (100356E7) --------------------------------------------------------
char *__cdecl sub_100356E7()
{
  char v1; // [sp-8h] [bp-8h]@1

  return &v1;
}

//----- (10035720) --------------------------------------------------------
int __usercall sub_10035720<eax>(int a1<ebx>, int a2<edi>, PEXCEPTION_RECORD ExceptionRecord, int TargetFrame, int a5)
{
  char v6; // ST20_1@1

  sub_1002A49B(a1, a2, TargetFrame, TargetFrame ^ *(_DWORD *)(TargetFrame + 8), v6);
  return sub_1003670F(
           a1,
           a2,
           (int)ExceptionRecord,
           *(_DWORD *)(TargetFrame + 16),
           a5,
           0,
           *(_DWORD *)(TargetFrame + 12),
           *(_DWORD *)(TargetFrame + 20),
           (PVOID)TargetFrame,
           0);
}

//----- (10035751) --------------------------------------------------------
int __usercall sub_10035751<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4<esi>)
{
  char v4; // ST20_1@1
  int result; // eax@2

  sub_1002A49B(a1, a3, a4, *(_DWORD *)(a2 + 12) ^ *(_DWORD *)(*(_DWORD *)(a2 + 12) + 8), v4);
  if ( *(_DWORD *)(*(_DWORD *)(a2 + 8) + 4) & 0x66 )
  {
    *(_DWORD *)(*(_DWORD *)(a2 + 12) + 36) = 1;
    result = 1;
  }
  else
  {
    sub_1003670F(
      a1,
      a3,
      *(_DWORD *)(a2 + 8),
      *(_DWORD *)(*(_DWORD *)(a2 + 12) + 16),
      *(_DWORD *)(a2 + 16),
      0,
      *(_DWORD *)(*(_DWORD *)(a2 + 12) + 12),
      *(_DWORD *)(*(_DWORD *)(a2 + 12) + 20),
      *(PVOID *)(*(_DWORD *)(a2 + 12) + 24),
      1);
    if ( !*(_DWORD *)(*(_DWORD *)(a2 + 12) + 36) )
      sub_100359D7(a3, a4, *(PVOID *)(a2 + 12), *(PEXCEPTION_RECORD *)(a2 + 8));
    sub_10035853(a1, a3, 291, a2 - 4, 0, 0, 0, 0, 0);
    result = (*(int (**)(void))(a2 - 4))();
  }
  return result;
}

//----- (100357EE) --------------------------------------------------------
void __usercall sub_100357EE(int a1<edi>, int a2<esi>, int a3, int a4, int a5, int a6, int a7)
{
  int ebp0; // ebp@0
  int v8; // [sp+0h] [bp-18h]@1
  int (__usercall *v9)<eax>(int<ebx>, int<edi>, PEXCEPTION_RECORD, int, int); // [sp+4h] [bp-14h]@1
  unsigned int v10; // [sp+8h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-Ch]@1
  int v12; // [sp+10h] [bp-8h]@1
  int v13; // [sp+14h] [bp-4h]@1

  v10 = (unsigned int)&v8 ^ __security_cookie;
  v11 = a4;
  v9 = sub_10035720;
  v12 = a3;
  v13 = a6 + 1;
  v8 = a6 + 1;
  sub_10048AB0(ebp0, a1, a2, a5, a3, a7);
}
// 10073200: using guessed type int __security_cookie;

//----- (1003584C) --------------------------------------------------------
#error "FFFFFFFF: positive sp value has been found (funcsize=0)"

//----- (10035853) --------------------------------------------------------
signed int __usercall sub_10035853<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  signed int result; // eax@2
  char v10; // [sp+0h] [bp-3Ch]@3
  int v11; // [sp+4h] [bp-38h]@3
  int (__usercall *v12)<eax>(int<ebx>, int<ebp>, int<edi>, int<esi>); // [sp+8h] [bp-34h]@3
  unsigned int v13; // [sp+Ch] [bp-30h]@3
  int v14; // [sp+10h] [bp-2Ch]@3
  int v15; // [sp+14h] [bp-28h]@3
  int v16; // [sp+18h] [bp-24h]@3
  int v17; // [sp+1Ch] [bp-20h]@3
  char *v18; // [sp+20h] [bp-1Ch]@3
  int *v19; // [sp+24h] [bp-18h]@3
  int v20; // [sp+28h] [bp-14h]@3
  int v21; // [sp+2Ch] [bp-10h]@3
  int v22; // [sp+30h] [bp-Ch]@3
  int v23; // [sp+34h] [bp-8h]@3
  int v24; // [sp+38h] [bp-4h]@3
  int v25; // [sp+3Ch] [bp+0h]@3

  if ( a3 == 291 )
  {
    *(_DWORD *)a4 = loc_100358FC;
    result = 1;
  }
  else
  {
    v12 = sub_10035751;
    v13 = (unsigned int)&v11 ^ __security_cookie;
    v14 = a7;
    v15 = a4;
    v16 = a8;
    v17 = a9;
    v20 = 0;
    v18 = &v10;
    v19 = &v25;
    v11 = a9;
    v24 = 1;
    v21 = a3;
    v22 = a5;
    v23 = *(_DWORD *)(sub_10041952(a1, a2) + 128);
    ((void (__cdecl *)(_DWORD, int *))v23)(*(_DWORD *)a3, &v21);
    v24 = 0;
    if ( v20 )
      *(_DWORD *)v11 = *(_DWORD *)a1;
    result = v24;
  }
  return result;
}
// 100358FC: using guessed type int __cdecl loc_100358FC(int, int, int, int, int, int, int);
// 10073200: using guessed type int __security_cookie;

//----- (10035928) --------------------------------------------------------
int __cdecl sub_10035928(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // edx@2
  int v10; // esi@10
  int v12; // [sp+Ch] [bp-8h]@1
  int v13; // [sp+10h] [bp-4h]@1

  v6 = a2;
  v5 = *(_DWORD *)(a1 + 16);
  v8 = *(_DWORD *)(a1 + 12);
  v12 = *(_DWORD *)(a1 + 16);
  v7 = *(_DWORD *)(a1 + 12);
  v13 = *(_DWORD *)(a1 + 12);
  if ( a2 >= 0 )
  {
    v9 = a3;
    do
    {
      if ( v8 == -1 )
      {
        sub_1003B435(v6, v7);
        v5 = v12;
        v9 = a3;
      }
      --v8;
      if ( *(_DWORD *)(20 * v8 + v5 + 4) < v9 && v9 <= *(_DWORD *)(20 * v8 + v5 + 8) || v8 == -1 )
      {
        v7 = v13;
        --v6;
        v13 = v8;
      }
    }
    while ( v6 >= 0 );
  }
  v10 = v8 + 1;
  *(_DWORD *)a4 = v10;
  *(_DWORD *)a5 = v7;
  if ( (unsigned int)v7 > *(_DWORD *)(a1 + 12) || v10 > (unsigned int)v7 )
  {
    sub_1003B435(v6, v7);
    v5 = v12;
  }
  return v5 + 20 * v10;
}

//----- (100359A7) --------------------------------------------------------
int __usercall sub_100359A7<eax>(int a1<ebp>, int a2, int a3)
{
  *(_DWORD *)(a1 - 4) = *(_DWORD *)(a1 + 12) + 12;
  return (*(int (**)(void))(a1 + 8))();
}

//----- (100359D7) --------------------------------------------------------
DWORD __userpurge sub_100359D7<eax>(int a1<edi>, int a2<esi>, PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord)
{
  DWORD result; // eax@1

  RtlUnwind(TargetFrame, loc_10035A01, ExceptionRecord, 0);
  result = ExceptionRecord->ExceptionFlags & 0xFFFFFFFD;
  ExceptionRecord->ExceptionFlags = result;
  *(_DWORD *)a2 = a1;
  return result;
}
// 10035A01: using guessed type int __stdcall loc_10035A01(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord);

//----- (10035A2A) --------------------------------------------------------
int __usercall sub_10035A2A<eax>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  *(_DWORD *)a3 = a4;
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(sub_10041952(a1, a2) + 152);
  *(_DWORD *)(sub_10041952(a1, a2) + 152) = a3;
  return a3;
}

//----- (10035A54) --------------------------------------------------------
void __usercall sub_10035A54(int a1<ebx>, int a2<edi>, int a3)
{
  int i; // ecx@4

  if ( a3 == *(_DWORD *)(sub_10041952(a1, a2) + 152) )
  {
    *(_DWORD *)(sub_10041952(a1, a2) + 152) = *(_DWORD *)(a3 + 4);
  }
  else
  {
    for ( i = *(_DWORD *)(sub_10041952(a1, a2) + 152); ; i = *(_DWORD *)(i + 4) )
    {
      if ( !*(_DWORD *)(i + 4) )
      {
        sub_1003B435(a1, a2);
        return;
      }
      if ( a3 == *(_DWORD *)(i + 4) )
        break;
    }
    *(_DWORD *)(i + 4) = *(_DWORD *)(a3 + 4);
  }
}

//----- (10035AA4) --------------------------------------------------------
signed int __usercall sub_10035AA4<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // eax@1
  signed int result; // eax@4

  v3 = *(_DWORD *)(sub_10041952(a1, a2) + 152);
  if ( v3 )
  {
    while ( *(_DWORD *)v3 != a3 )
    {
      v3 = *(_DWORD *)(v3 + 4);
      if ( !v3 )
        goto LABEL_4;
    }
    result = 0;
  }
  else
  {
LABEL_4:
    result = 1;
  }
  return result;
}

//----- (10035ACD) --------------------------------------------------------
int __usercall sub_10035ACD<eax>(int a1<eax>, int a2<ebx>, int a3<edi>, int ExceptionRecord, int a5, int a6, int a7)
{
  return sub_1003670F(a2, a3, ExceptionRecord, a5, a6, a7, a1, 0, 0, 0);
}

//----- (10035B03) --------------------------------------------------------
int __cdecl sub_10035B03(int a1)
{
  int result; // eax@1
  int v2; // ecx@7
  int v3; // edx@8

  result = a1;
  if ( a1 )
  {
    if ( *(_DWORD *)a1 == -529697949 )
    {
      if ( *(_DWORD *)(a1 + 16) == 3 )
      {
        if ( *(_DWORD *)(a1 + 20) == 429065504 || *(_DWORD *)(a1 + 20) == 429065505 || *(_DWORD *)(a1 + 20) == 429065506 )
        {
          v2 = *(_DWORD *)(a1 + 28);
          if ( v2 )
          {
            v3 = *(_DWORD *)(v2 + 4);
            if ( v3 )
            {
              result = sub_1003584C(*(_DWORD *)(a1 + 24), v3);
            }
            else
            {
              if ( *(_BYTE *)v2 & 0x10 )
              {
                result = *(_DWORD *)(a1 + 24);
                if ( *(_DWORD *)result )
                  result = (*(int (__stdcall **)(_DWORD))(**(_DWORD **)result + 8))(*(_DWORD *)result);
              }
            }
          }
        }
      }
    }
  }
  return result;
}
// 1003584C: using guessed type _DWORD __cdecl sub_1003584C(_DWORD, _DWORD);

//----- (10035B8E) --------------------------------------------------------
int __cdecl sub_10035B8E(int a1, int a2, int a3, int a4, int a5, int a6, int a7)
{
  int result; // eax@1
  int v8; // eax@1
  int v9; // eax@1
  char v10; // [sp+10h] [bp-40h]@1
  int v11; // [sp+18h] [bp-38h]@1
  int v12; // [sp+1Ch] [bp-34h]@1
  int v13; // [sp+20h] [bp-30h]@1
  int v14; // [sp+24h] [bp-2Ch]@1
  int v15; // [sp+28h] [bp-28h]@1
  int v16; // [sp+34h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+38h] [bp-18h]@1

  v16 = a5;
  v11 = 0;
  v15 = *(_DWORD *)(a2 - 4);
  v14 = sub_10035A2A(0, a2, (int)&v10, *(_DWORD *)(a1 + 24));
  v13 = *(_DWORD *)(sub_10041952(0, a2) + 136);
  v12 = *(_DWORD *)(sub_10041952(0, a2) + 140);
  *(_DWORD *)(sub_10041952(0, a2) + 136) = a1;
  *(_DWORD *)(sub_10041952(0, a2) + 140) = a3;
  ms_exc.disabled = 1;
  sub_100357EE(a2, a1, a2, a4, a5, a6, a7);
  v16 = v8;
  ms_exc.disabled = -2;
  *(_DWORD *)(a2 - 4) = v15;
  sub_10035A54(0, a2, v14);
  v9 = sub_10041952(0, a2);
  *(_DWORD *)(v9 + 136) = v13;
  result = sub_10041952(0, a2);
  *(_DWORD *)(result + 140) = v12;
  if ( *(_DWORD *)a1 == -529697949 )
  {
    if ( *(_DWORD *)(a1 + 16) == 3 )
    {
      if ( *(_DWORD *)(a1 + 20) == 429065504 || *(_DWORD *)(a1 + 20) == 429065505 || *(_DWORD *)(a1 + 20) == 429065506 )
      {
        if ( !v11 )
        {
          if ( v16 )
          {
            result = sub_10035AA4(0, v16, *(_DWORD *)(a1 + 24));
            if ( result )
              result = sub_10035B03(a1);
          }
        }
      }
    }
  }
  return result;
}

//----- (10035D5C) --------------------------------------------------------
void __usercall sub_10035D5C(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  sub_100356B1();
  if ( *(_DWORD *)(sub_10041952(a1, a3) + 148) )
    sub_1003B435(a1, a3);
  *(_DWORD *)(a2 - 4) = 0;
  sub_1003B4A1(a1, a3);
  *(_DWORD *)(sub_10041952(a1, a3) + 148) = *(_DWORD *)(a2 + 8);
  sub_100355BB(0, 0);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_10035D9C);
}

//----- (10035D9C) --------------------------------------------------------
int __usercall sub_10035D9C<eax>(int a1<ebx>, int a2<esi>, PEXCEPTION_RECORD ExceptionRecord, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, PVOID TargetFrame)
{
  int ebp0; // ebp@0
  int result; // eax@6
  PVOID v14; // [sp-8h] [bp-Ch]@4

  if ( a9 )
    sub_100363D5((int)ExceptionRecord, a4, a8, a9);
  if ( TargetFrame )
    v14 = TargetFrame;
  else
    v14 = (PVOID)a4;
  sub_100359D7(a4, a2, v14, ExceptionRecord);
  sub_10036636(a1, a4, a4, a6, a7, *(_DWORD *)a10);
  *(_DWORD *)(a4 + 8) = *(_DWORD *)(a10 + 4) + 1;
  result = sub_10035B8E((int)ExceptionRecord, a4, a5, a7, *(_DWORD *)(a8 + 12), a11, 256);
  if ( result )
    result = sub_100359A7(ebp0, result, a4);
  return result;
}

//----- (10035E17) --------------------------------------------------------
signed int __usercall sub_10035E17<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  _DWORD *v3; // eax@1
  signed int result; // eax@7

  v3 = *(_DWORD **)a3;
  if ( **(_DWORD **)a3 != -529697949
    || v3[4] != 3
    || v3[5] != 429065504 && v3[5] != 429065505 && v3[5] != 429065506
    || v3[7] )
  {
    result = 0;
  }
  else
  {
    *(_DWORD *)(sub_10041952(a1, a2) + 940) = 1;
    result = 1;
  }
  return result;
}

//----- (10035E64) --------------------------------------------------------
void __cdecl sub_10035E64(int ExceptionRecord, int a2, int a3, int a4, int a5, char a6, int a7, PVOID TargetFrame)
{
  int v8; // ebx@1
  int ebp0; // ebp@0
  int v10; // edi@1
  unsigned __int8 v11; // zf@1
  char v12; // sf@1
  unsigned __int8 v13; // of@1
  int v14; // eax@2
  int v15; // esi@7
  int v16; // ST28_4@24
  int v17; // eax@26
  int v18; // eax@30
  int v19; // eax@38
  unsigned int v20; // ecx@38
  int v21; // eax@39
  int v22; // edx@39
  int v23; // edi@42
  unsigned __int8 v24; // zf@42
  unsigned __int8 v25; // sf@42
  int v26; // ecx@43
  int v27; // eax@44
  int v28; // edx@44
  int *v29; // eax@44
  int v30; // ST28_4@45
  int v31; // eax@60
  char v32; // zf@60
  PEXCEPTION_RECORD v33; // ST2C_4@72
  PVOID v34; // [sp-4h] [bp-4Ch]@60
  int (__stdcall **v35)(char); // [sp+Ch] [bp-3Ch]@70
  int v36; // [sp+18h] [bp-30h]@45
  int v37; // [sp+1Ch] [bp-2Ch]@40
  unsigned int v38; // [sp+20h] [bp-28h]@38
  int v39; // [sp+24h] [bp-24h]@1
  int v40; // [sp+28h] [bp-20h]@42
  int v41; // [sp+2Ch] [bp-1Ch]@46
  int v42; // [sp+30h] [bp-18h]@46
  int v43; // [sp+34h] [bp-14h]@24
  unsigned int v44; // [sp+38h] [bp-10h]@38
  int v45; // [sp+3Ch] [bp-Ch]@42
  int v46; // [sp+40h] [bp-8h]@4
  char v47; // [sp+47h] [bp-1h]@1
  int v48; // [sp+50h] [bp+8h]@14

  v10 = a5;
  v8 = 0;
  v13 = __SETO__(*(_DWORD *)(a5 + 4), 128);
  v11 = *(_DWORD *)(a5 + 4) == 128;
  v12 = *(_DWORD *)(a5 + 4) - 128 < 0;
  LOBYTE(v39) = 0;
  v47 = 0;
  if ( (unsigned __int8)(v12 ^ v13) | v11 )
    v14 = *(_BYTE *)(a2 + 8);
  else
    v14 = *(_DWORD *)(a2 + 8);
  v46 = v14;
  if ( v14 < -1 || v14 >= *(_DWORD *)(a5 + 4) )
    sub_1003B435(0, a5);
  v15 = ExceptionRecord;
  if ( *(_DWORD *)ExceptionRecord != -529697949 )
  {
    v18 = a3;
LABEL_63:
    if ( *(_DWORD *)(v10 + 12) > 0u )
    {
      if ( a6 )
        goto LABEL_69;
      sub_100361FF(0, (PEXCEPTION_RECORD)v15, a2, v18, a4, v10, v46, a7, TargetFrame);
    }
    goto LABEL_66;
  }
  if ( *(_DWORD *)(ExceptionRecord + 16) != 3
    || *(_DWORD *)(ExceptionRecord + 20) != 429065504
    && *(_DWORD *)(ExceptionRecord + 20) != 429065505
    && *(_DWORD *)(ExceptionRecord + 20) != 429065506
    || *(_DWORD *)(ExceptionRecord + 28) )
  {
    v18 = a3;
    v48 = a3;
  }
  else
  {
    if ( !*(_DWORD *)(sub_10041952(0, v10) + 136) )
      return;
    v15 = *(_DWORD *)(sub_10041952(0, v10) + 136);
    v48 = *(_DWORD *)(sub_10041952(0, v10) + 140);
    LOBYTE(v39) = 1;
    if ( !sub_10048AFC(v15) )
      sub_1003B435(0, v10);
    if ( *(_DWORD *)v15 == -529697949 )
    {
      if ( *(_DWORD *)(v15 + 16) == 3 )
      {
        if ( *(_DWORD *)(v15 + 20) == 429065504
          || *(_DWORD *)(v15 + 20) == 429065505
          || *(_DWORD *)(v15 + 20) == 429065506 )
        {
          if ( !*(_DWORD *)(v15 + 28) )
            sub_1003B435(0, v10);
        }
      }
    }
    if ( *(_DWORD *)(sub_10041952(0, v10) + 148) )
    {
      v43 = *(_DWORD *)(sub_10041952(0, v10) + 148);
      v16 = v43;
      *(_DWORD *)(sub_10041952(0, v10) + 148) = 0;
      if ( !sub_10036319(0, v10, v15, v16) )
      {
        v10 = v43;
        if ( *(_DWORD *)v43 > 0 )
        {
          v17 = 0;
          a5 = 0;
          while ( !sub_1002CAFA(*(void **)(v17 + *(_DWORD *)(v43 + 4) + 4), (int)&off_100728A4) )
          {
            ++v8;
            v17 = a5 + 16;
            a5 += 16;
            if ( v8 >= *(_DWORD *)v43 )
              goto LABEL_69;
          }
          goto LABEL_70;
        }
LABEL_69:
        sub_1003B46D(v8, v10);
LABEL_70:
        sub_10035B03(v15);
        a5 = (int)"bad exception";
        sub_1002AEA4((int)&v35, &a5);
        v35 = &off_10060C58;
        sub_100355BB((int)&v35, (int)&unk_1006B434);
LABEL_71:
        v34 = TargetFrame;
LABEL_72:
        sub_100359D7(v10, v15, v34, v33);
        sub_10036636(v8, v10, a2, a4, v10, -1);
        sub_10035D5C(v8, ebp0, v10);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_100361FF);
      }
    }
    v18 = v48;
  }
  if ( *(_DWORD *)v15 != -529697949
    || *(_DWORD *)(v15 + 16) != 3
    || *(_DWORD *)(v15 + 20) != 429065504 && *(_DWORD *)(v15 + 20) != 429065505 && *(_DWORD *)(v15 + 20) != 429065506 )
    goto LABEL_63;
  if ( *(_DWORD *)(v10 + 12) > 0u )
  {
    v19 = sub_10035928(v10, a7, v46, (int)&v44, (int)&v38);
    v20 = v44;
    if ( v44 < v38 )
    {
      v22 = v19 + 16;
      v21 = v46;
      v43 = v22;
      do
      {
        v37 = v22 - 16;
        if ( *(_DWORD *)(v22 - 16) <= v21 )
        {
          if ( v21 <= *(_DWORD *)(v22 - 12) )
          {
            v45 = *(_DWORD *)v22;
            v23 = *(_DWORD *)(v22 - 4);
            v40 = v23;
            v24 = v23 == 0;
            v25 = v23 < 0;
            v10 = a5;
            if ( !(v25 | v24) )
            {
              v26 = v45;
              while ( 2 )
              {
                v29 = *(int **)(*(_DWORD *)(v15 + 28) + 12);
                v28 = (int)(v29 + 1);
                v27 = *v29;
                while ( 1 )
                {
                  v42 = v27;
                  v41 = v28;
                  if ( v27 <= 0 )
                    break;
                  v30 = *(_DWORD *)(v15 + 28);
                  v36 = *(_DWORD *)v28;
                  if ( sub_100367EE(v26, v36, v30) )
                  {
                    v47 = 1;
                    sub_10035D9C(a2, v15, (PEXCEPTION_RECORD)v15, a2, v48, a4, v10, v45, v36, v37, a7, TargetFrame);
                    goto LABEL_51;
                  }
                  v26 = v45;
                  v27 = v42 - 1;
                  v28 = v41 + 4;
                }
                v26 += 16;
                --v40;
                v45 = v26;
                if ( v40 > 0 )
                  continue;
                break;
              }
LABEL_51:
              v22 = v43;
              v21 = v46;
              v20 = v44;
            }
          }
        }
        ++v20;
        v22 += 20;
        v44 = v20;
        v43 = v22;
      }
      while ( v20 < v38 );
      v8 = 0;
    }
  }
  if ( a6 )
    sub_10035B03(v15);
  if ( !v47
    && (*(_DWORD *)v10 & 0x1FFFFFFFu) >= 0x19930521
    && *(_DWORD *)(v10 + 28)
    && !sub_10036319(v8, v10, v15, *(_DWORD *)(v10 + 28)) )
  {
    sub_10041952(v8, v10);
    sub_10041952(v8, v10);
    *(_DWORD *)(sub_10041952(v8, v10) + 136) = v15;
    v31 = sub_10041952(v8, v10);
    v32 = TargetFrame == 0;
    *(_DWORD *)(v31 + 140) = v48;
    v34 = (PVOID)v15;
    if ( v32 )
      goto LABEL_72;
    goto LABEL_71;
  }
LABEL_66:
  if ( *(_DWORD *)(sub_10041952(v8, v10) + 148) != v8 )
    sub_1003B435(v8, v10);
}
// 10060C58: using guessed type int (__stdcall *off_10060C58)(char);
// 100728A4: using guessed type int (__stdcall **off_100728A4)(char);

//----- (100361FF) --------------------------------------------------------
void __usercall sub_100361FF(int a1<ebx>, PEXCEPTION_RECORD ExceptionRecord, int a3, int a4, int a5, int a6, int a7, int a8, PVOID TargetFrame)
{
  int v9; // ebx@2
  int v10; // eax@2
  PVOID v11; // esi@3
  int v12; // eax@9
  int v13; // edx@9
  int v14; // ecx@9
  int v15; // eax@10
  int v16; // esi@10
  int v17; // eax@13
  int v18; // eax@15
  unsigned int v19; // [sp+4h] [bp-8h]@9
  unsigned int v20; // [sp+8h] [bp-4h]@9

  if ( ExceptionRecord->ExceptionCode != -2147483645 )
  {
    v10 = sub_10041952(a1, (int)ExceptionRecord);
    v9 = a6;
    if ( !*(_DWORD *)(v10 + 128)
      || (v11 = EncodePointer(0), *(PVOID *)(sub_10041952(a6, (int)ExceptionRecord) + 128) == v11)
      || ExceptionRecord->ExceptionCode == -532459699
      || ExceptionRecord->ExceptionCode == -532462766
      || !sub_10035853(a6, (int)ExceptionRecord, (int)ExceptionRecord, a3, a4, a5, a6, a8, (int)TargetFrame) )
    {
      if ( !*(_DWORD *)(a6 + 12) )
        sub_1003B435(a6, (int)ExceptionRecord);
      v12 = sub_10035928(a6, a8, a7, (int)&v19, (int)&v20);
      v14 = v19;
      v13 = v20;
      if ( v19 < v20 )
      {
        v16 = v12 + 12;
        v15 = a7;
        do
        {
          if ( v15 >= *(_DWORD *)(v16 - 12) )
          {
            if ( v15 <= *(_DWORD *)(v16 - 8) )
            {
              v17 = 16 * *(_DWORD *)v16;
              if ( !*(_DWORD *)(*(_DWORD *)(v16 + 4) + v17 - 12)
                || (v13 = v20, v9 = a6, !*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v16 + 4) + v17 - 12) + 8)) )
              {
                v18 = *(_DWORD *)(v16 + 4) - 16 + v17;
                if ( !(*(_BYTE *)v18 & 0x40) )
                {
                  sub_10035D9C(v9, v16, ExceptionRecord, a3, a4, a5, v9, v18, 0, v16 - 12, a8, TargetFrame);
                  v13 = v20;
                  v14 = v19;
                }
              }
              v15 = a7;
            }
          }
          ++v14;
          v16 += 20;
          v19 = v14;
        }
        while ( v14 < (unsigned int)v13 );
      }
    }
  }
}

//----- (10036319) --------------------------------------------------------
char __usercall sub_10036319<al>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  int v4; // esi@1
  char v5; // bl@2
  int v6; // edi@2
  int v7; // ecx@3
  int v8; // edx@4
  int v9; // eax@4
  bool v10; // eax@5
  int v12; // [sp+Ch] [bp-8h]@4
  int v13; // [sp+10h] [bp-4h]@4
  int v14; // [sp+20h] [bp+Ch]@3

  v4 = a4;
  if ( !a4 )
  {
    sub_1003B435(a1, a2);
    sub_1003B46D(a1, a2);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003639F);
  }
  v5 = 0;
  v6 = 0;
  if ( *(_DWORD *)a4 > 0 )
  {
    v7 = 0;
    v14 = 0;
    do
    {
      v9 = *(_DWORD *)(*(_DWORD *)(a3 + 28) + 12);
      v8 = v9 + 4;
      v12 = v9 + 4;
      v13 = *(_DWORD *)v9;
      if ( *(_DWORD *)v9 > 0 )
      {
        while ( 1 )
        {
          v10 = sub_100367EE(v7 + *(_DWORD *)(v4 + 4), *(_DWORD *)v8, *(_DWORD *)(a3 + 28));
          v7 = v14;
          if ( v10 )
            break;
          v8 = v12 + 4;
          --v13;
          v12 += 4;
          if ( v13 <= 0 )
            goto LABEL_9;
        }
        v5 = 1;
      }
LABEL_9:
      ++v6;
      v7 += 16;
      v14 = v7;
    }
    while ( v6 < *(_DWORD *)v4 );
  }
  return v5;
}

//----- (1003639F) --------------------------------------------------------
char __usercall sub_1003639F<al>(int a1<ebx>, int a2<edi>)
{
  return *(_DWORD *)(sub_10041952(a1, a2) + 144) != 0;
}

//----- (100363B0) --------------------------------------------------------
int __cdecl sub_100363B0(int a1, int a2)
{
  int result; // eax@1
  int v3; // esi@1

  v3 = *(_DWORD *)(a2 + 4);
  result = a1 + *(_DWORD *)a2;
  if ( v3 >= 0 )
    result += v3 + *(_DWORD *)(*(_DWORD *)(v3 + a1) + *(_DWORD *)(a2 + 8));
  return result;
}

//----- (100363D5) --------------------------------------------------------
int __cdecl sub_100363D5(int a1, int a2, int a3, int a4)
{
  int v4; // edi@2
  int v5; // eax@4
  int result; // eax@5

  _SEH_prolog4(stru_1006B818, 8);
  if ( *(_DWORD *)a3 & 0x80000000 )
    v4 = a2;
  else
    v4 = *(_DWORD *)(a3 + 8) + a2 + 12;
  v5 = sub_10036463(a1, a2, a3, a4) - 1;
  if ( v5 )
  {
    result = v5 - 1;
    if ( !result )
    {
      sub_100363B0(*(_DWORD *)(a1 + 24), a4 + 8);
      result = sub_1003584C(v4, *(_DWORD *)(a4 + 24));
    }
  }
  else
  {
    sub_100363B0(*(_DWORD *)(a1 + 24), a4 + 8);
    result = sub_1003584C(v4, *(_DWORD *)(a4 + 24));
  }
  return result;
}
// 1003584C: using guessed type _DWORD __cdecl sub_1003584C(_DWORD, _DWORD);
// 1003B240: using guessed type _DWORD __cdecl _SEH_prolog4(_DWORD, _DWORD);
// 1006B818: using guessed type _EH4_SCOPETABLE stru_1006B818[1];

//----- (10036463) --------------------------------------------------------
int __cdecl sub_10036463(int a1, int a2, int a3, int a4)
{
  int v4; // ecx@1
  int v5; // ebx@1
  int v6; // ecx@3
  int v7; // edx@5
  int v8; // edi@5
  int v9; // ecx@10
  unsigned int v10; // ST08_4@21
  int v11; // eax@21
  int v13; // [sp-8h] [bp-34h]@10
  int v14; // [sp-8h] [bp-34h]@12
  int v15; // [sp-4h] [bp-30h]@10

  v5 = 0;
  v4 = *(_DWORD *)(a3 + 4);
  if ( v4 )
  {
    if ( *(_BYTE *)(v4 + 8) )
    {
      v6 = *(_DWORD *)(a3 + 8);
      if ( v6 || *(_DWORD *)a3 & 0x80000000 )
      {
        v7 = *(_DWORD *)a3;
        v8 = a2;
        if ( *(_DWORD *)a3 >= 0 )
          v8 = v6 + a2 + 12;
        if ( v7 & 8 )
        {
          if ( sub_10048AFC(*(_DWORD *)(a1 + 24)) && sub_10048AFC(v8) )
          {
            v9 = *(_DWORD *)(a1 + 24);
            *(_DWORD *)v8 = v9;
            v15 = a4 + 8;
            v13 = v9;
LABEL_11:
            *(_DWORD *)v8 = sub_100363B0(v13, v15);
            return v5;
          }
        }
        else
        {
          v14 = *(_DWORD *)(a1 + 24);
          if ( *(_BYTE *)a4 & 1 )
          {
            if ( sub_10048AFC(v14) && sub_10048AFC(v8) )
            {
              sub_1002A4B0((void *)v8, *(const void **)(a1 + 24), *(_DWORD *)(a4 + 20));
              if ( *(_DWORD *)(a4 + 20) != 4 || !*(_DWORD *)v8 )
                return v5;
              v15 = a4 + 8;
              v13 = *(_DWORD *)v8;
              goto LABEL_11;
            }
          }
          else
          {
            if ( *(_DWORD *)(a4 + 24) )
            {
              if ( sub_10048AFC(v14) && sub_10048AFC(v8) && sub_10048AFC(*(_DWORD *)(a4 + 24)) )
                return ((*(_BYTE *)a4 & 4) != 0) + 1;
            }
            else
            {
              if ( sub_10048AFC(v14) && sub_10048AFC(v8) )
              {
                v10 = *(_DWORD *)(a4 + 20);
                v11 = sub_100363B0(*(_DWORD *)(a1 + 24), a4 + 8);
                sub_1002A4B0((void *)v8, (const void *)v11, v10);
                return v5;
              }
            }
          }
        }
        sub_1003B435(0, v8);
        return v5;
      }
    }
  }
  return 0;
}

//----- (100365E8) --------------------------------------------------------
void __usercall sub_100365E8(int a1<ebx>, int a2<edi>, int a3)
{
  _DWORD *v3; // eax@1
  int v4; // eax@6

  v3 = *(_DWORD **)a3;
  if ( **(_DWORD **)a3 == -532462766 || *v3 == -532459699 )
  {
    if ( *(_DWORD *)(sub_10041952(a1, a2) + 144) > 0 )
    {
      v4 = sub_10041952(a1, a2);
      --*(_DWORD *)(v4 + 144);
    }
  }
  else
  {
    if ( *v3 == -529697949 )
    {
      *(_DWORD *)(sub_10041952(a1, a2) + 144) = 0;
      sub_1003B46D(a1, a2);
    }
  }
}

//----- (10036636) --------------------------------------------------------
int __usercall sub_10036636<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6)
{
  int ebp0; // ebp@0
  int v7; // esi@2
  int v8; // eax@4
  int v9; // eax@9
  int result; // eax@12
  int v11; // [sp+10h] [bp-20h]@9

  if ( *(_DWORD *)(a5 + 4) > 128 )
    v7 = *(_DWORD *)(a3 + 8);
  else
    v7 = *(_BYTE *)(a3 + 8);
  v8 = sub_10041952(a1, a2);
  ++*(_DWORD *)(v8 + 144);
  while ( v7 != a6 )
  {
    if ( v7 <= -1 || v7 >= *(_DWORD *)(a5 + 4) )
      sub_1003B435(a1, a2);
    v9 = *(_DWORD *)(a5 + 8);
    v11 = *(_DWORD *)(v9 + 8 * v7);
    if ( *(_DWORD *)(v9 + 8 * v7 + 4) )
    {
      *(_DWORD *)(a3 + 8) = *(_DWORD *)(v9 + 8 * v7);
      sub_10048AB0(ebp0, a2, v7, *(_DWORD *)(*(_DWORD *)(a5 + 8) + 8 * v7 + 4), a3, 259);
    }
    v7 = v11;
  }
  result = sub_10041952(a1, a2);
  if ( *(_DWORD *)(result + 144) > 0 )
  {
    result = sub_10041952(a1, a2);
    --*(_DWORD *)(result + 144);
  }
  return result;
}

//----- (1003670F) --------------------------------------------------------
int __usercall sub_1003670F<eax>(int a1<ebx>, int a2<edi>, int ExceptionRecord, int a4, int a5, int a6, int a7, int a8, PVOID TargetFrame, char a10)
{
  int (__cdecl *v10)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // esi@16

  if ( *(_DWORD *)(sub_10041952(a1, a2) + 940)
    || *(_DWORD *)ExceptionRecord == -529697949
    || *(_DWORD *)ExceptionRecord == -2147483610
    || (*(_DWORD *)a7 & 0x1FFFFFFFu) < 0x19930522
    || !(*(_BYTE *)(a7 + 32) & 1) )
  {
    if ( *(_BYTE *)(ExceptionRecord + 4) & 0x66 )
    {
      if ( *(_DWORD *)(a7 + 4) )
      {
        if ( !a8 )
          sub_10036636(-529697949, 429065506, a4, a6, a7, -1);
      }
    }
    else
    {
      if ( *(_DWORD *)(a7 + 12) || (*(_DWORD *)a7 & 0x1FFFFFFFu) >= 0x19930521 && *(_DWORD *)(a7 + 28) )
      {
        if ( *(_DWORD *)ExceptionRecord == -529697949 )
        {
          if ( *(_DWORD *)(ExceptionRecord + 16) >= 3u )
          {
            if ( *(_DWORD *)(ExceptionRecord + 20) > 0x19930522u )
            {
              v10 = *(int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)(ExceptionRecord + 28) + 8);
              if ( v10 )
                return v10(ExceptionRecord, a4, a5, a6, a7, a8, TargetFrame, (unsigned __int8)a10);
            }
          }
        }
        sub_10035E64(ExceptionRecord, a4, a5, a6, a7, a10, a8, TargetFrame);
      }
    }
  }
  return 1;
}

//----- (100367EE) --------------------------------------------------------
bool __cdecl sub_100367EE(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // edx@3

  v3 = *(_DWORD *)(a1 + 4);
  return !v3
      || !*(_BYTE *)(v3 + 8)
      || ((v4 = *(_DWORD *)(a2 + 4), v3 == v4) || !sub_100392F0(v3 + 8, v4 + 8))
      && (!(*(_BYTE *)a2 & 2) || *(_BYTE *)a1 & 8)
      && (!(*(_BYTE *)a3 & 1) || *(_BYTE *)a1 & 1)
      && (!(*(_BYTE *)a3 & 2) || *(_BYTE *)a1 & 2);
}

//----- (1003684B) --------------------------------------------------------
void __cdecl sub_1003684B(unsigned int a1, LPCSTR lpWideCharStr)
{
  int v2; // ebx@1
  int v3; // edi@1
  const CHAR *v4; // esi@1
  int v5; // eax@2
  int v6; // ecx@2
  WCHAR *v7; // eax@6
  int v8; // eax@8
  int v9; // eax@13
  signed int v10; // eax@14
  int v11; // eax@14
  int v12; // edx@14
  int v13; // ecx@14
  int v14; // eax@19
  signed int v15; // eax@20
  int v16; // edx@20
  int v17; // ecx@20
  int v18; // edi@25
  int v19; // ecx@33
  int v20; // [sp+10h] [bp-30h]@14
  int v21; // [sp+14h] [bp-2Ch]@14
  int v22; // [sp+18h] [bp-28h]@20
  int v23; // [sp+1Ch] [bp-24h]@19
  int v24; // [sp+20h] [bp-20h]@14
  int cbMultiByte; // [sp+24h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+28h] [bp-18h]@25
  int v27; // [sp+4Ch] [bp+Ch]@13

  v2 = 0;
  cbMultiByte = 0;
  v3 = 0;
  v4 = lpWideCharStr;
  if ( !lpWideCharStr )
    goto LABEL_13;
  v5 = sub_10048D46((int)&cbMultiByte, 0, 0, lpWideCharStr, 2147483647);
  if ( !v5 || v5 != 22 && v5 != 34 )
    goto LABEL_6;
  while ( 1 )
  {
    sub_1003A161(v2, v3);
LABEL_6:
    v7 = (WCHAR *)sub_100374E6(v6, v2, cbMultiByte, 2u);
    v3 = (int)v7;
    if ( !v7 )
      break;
    v8 = sub_10048D46(v2, v7, cbMultiByte, v4, -1);
    if ( !v8 )
      goto LABEL_13;
    if ( v8 != 22 && v8 != 34 )
    {
      if ( v8 )
        goto LABEL_12;
LABEL_13:
      v4 = (const CHAR *)a1;
      sub_10042C12(v3, a1, v3);
      v2 = v9;
      v27 = v9;
      sub_100309C2(v9, (LPVOID)v3);
      if ( !v2 )
        return;
      v11 = sub_10041952(v2, v3);
      v24 = v11;
      v20 = *(_DWORD *)(v11 + 108);
      v21 = *(_DWORD *)(v11 + 104);
      v3 = 0;
      cbMultiByte = 0;
      v10 = sub_10048FC9(v2, (int)&cbMultiByte, 0, 0, v2, 0, (int)&v20);
      if ( !v10 )
        goto LABEL_19;
      if ( v10 != 22 && v10 != 34 )
      {
        if ( v10 )
          return;
LABEL_19:
        v14 = sub_10037530(v12, v13, v2, cbMultiByte + 4);
        v3 = v14;
        v23 = v14;
        if ( !v14 )
          return;
        v2 = v14 + 4;
        v22 = v14 + 4;
        v15 = sub_10048FC9(v14 + 4, 0, (CHAR *)(v14 + 4), cbMultiByte, v27, -1, (int)&v20);
        if ( !v15 )
          goto LABEL_25;
        if ( v15 != 22 && v15 != 34 )
        {
          if ( v15 )
          {
LABEL_12:
            sub_100309C2(v2, (LPVOID)v3);
            return;
          }
LABEL_25:
          v18 = v20;
          sub_10036A23(v16, v17, v2, v20, 12);
          ms_exc.disabled = 0;
          if ( *(_DWORD *)(v18 + 16 * a1 + 24) )
          {
            if ( !InterlockedDecrement(*(volatile LONG **)(v18 + 16 * a1 + 24)) )
              sub_100309C2(v2, *(LPVOID *)(v18 + 16 * a1 + 24));
          }
          if ( !(*(_BYTE *)(v24 + 112) & 2) )
          {
            if ( !(dword_10073C0C & 1) )
            {
              if ( *(_DWORD *)(v18 + 16 * a1 + 24) )
              {
                if ( !InterlockedDecrement(*(volatile LONG **)(v18 + 16 * a1 + 24)) )
                  sub_100309C2(v2, *(LPVOID *)(v18 + 16 * a1 + 24));
              }
            }
          }
          v19 = v23;
          *(_DWORD *)v23 = *(_DWORD *)v18;
          *(_DWORD *)(v18 + 16 * a1 + 24) = v19;
          *(_DWORD *)(v18 + 16 * a1 + 16) = v2;
          sub_10036B87(12);
          return;
        }
      }
    }
  }
}
// 10073C0C: using guessed type int dword_10073C0C;

//----- (10036A23) --------------------------------------------------------
void __usercall sub_10036A23(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // edx@2
  int v6; // eax@2
  int v7; // [sp-4h] [bp-8h]@2

  if ( !*(&lpCriticalSection + 2 * a5) )
  {
    sub_10036AAB(a1, a2, a3, a4, a5);
    if ( !v6 )
      sub_1003AF82(v5, v7, a3, a4, 17);
  }
  EnterCriticalSection(*(&lpCriticalSection + 2 * a5));
}

//----- (10036AAB) --------------------------------------------------------
void __usercall sub_10036AAB(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  HMODULE v5; // ecx@2
  int v6; // edx@5
  int v7; // esi@5
  int v8; // [sp-4h] [bp-2Ch]@5

  if ( !hHeap )
  {
    sub_1003F5AC(a1, a2, a3, a4);
    sub_1003F609(a3, 30);
    sub_1003AE5C(v5, 0xFFu);
  }
  if ( !*(&lpCriticalSection + 2 * a5) )
  {
    v7 = sub_10037530(a1, a2, a3, 24);
    if ( v7 )
    {
      sub_10036A23(v6, v8, a3, a5, 10);
      if ( *(&lpCriticalSection + 2 * a5) )
      {
        sub_100309C2(a3, (LPVOID)v7);
      }
      else
      {
        InitializeCriticalSectionAndSpinCount((LPCRITICAL_SECTION)v7, 0xFA0u);
        *(&lpCriticalSection + 2 * a5) = (LPCRITICAL_SECTION)v7;
      }
      sub_10036B87(10);
    }
    else
    {
      *(_DWORD *)sub_10037649(a3) = 12;
    }
  }
}

//----- (10036B52) --------------------------------------------------------
signed int __cdecl sub_10036B52()
{
  _UNKNOWN *v0; // edi@1
  signed int v1; // esi@1

  v1 = (signed int)&lpCriticalSection;
  v0 = &unk_10075620;
  do
  {
    if ( *(_DWORD *)(v1 + 4) == 1 )
    {
      *(_DWORD *)v1 = v0;
      v0 = (char *)v0 + 24;
      InitializeCriticalSectionAndSpinCount(*(LPCRITICAL_SECTION *)v1, 0xFA0u);
    }
    v1 += 8;
  }
  while ( v1 < (signed int)&off_10073080 );
  return 1;
}
// 10073080: using guessed type wchar_t *off_10073080;

//----- (10036B87) --------------------------------------------------------
void __cdecl sub_10036B87(int a1)
{
  LeaveCriticalSection(*(&lpCriticalSection + 2 * a1));
}

//----- (10036B9C) --------------------------------------------------------
int __usercall sub_10036B9C<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // eax@1
  int v4; // edx@1

  v3 = sub_10041952(a1, a2);
  v4 = v3;
  v2 = *(_DWORD *)(v3 + 108);
  if ( (volatile LONG *)v2 != off_10073B44 )
  {
    if ( !(dword_10073C0C & *(_DWORD *)(v4 + 112)) )
      sub_10041DA4(a1, a2);
  }
  return *(_DWORD *)(v2 + 144);
}
// 10073C0C: using guessed type int dword_10073C0C;

//----- (10036BC5) --------------------------------------------------------
int __usercall sub_10036BC5<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4)
{
  int v4; // ecx@2
  __int16 v5; // cx@3
  int v7; // [sp+0h] [bp-10h]@1
  int v8; // [sp+8h] [bp-8h]@5
  char v9; // [sp+Ch] [bp-4h]@4

  sub_100301AD((int)&v7, a1, a2, a4);
  if ( *(_DWORD *)(v7 + 116) <= 1 )
  {
    v5 = *(_WORD *)(*(_DWORD *)(v7 + 144) + 2 * a3);
    v4 = v5 & 4;
  }
  else
  {
    v4 = sub_1004256E(a1, a2, a3, 4, (int)&v7);
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFDu;
  return v4;
}

//----- (10036C15) --------------------------------------------------------
int __usercall sub_10036C15<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4)
{
  int v4; // ecx@2
  __int16 v5; // cx@3
  int v7; // [sp+0h] [bp-10h]@1
  int v8; // [sp+8h] [bp-8h]@5
  char v9; // [sp+Ch] [bp-4h]@4

  sub_100301AD((int)&v7, a1, a2, a4);
  if ( *(_DWORD *)(v7 + 116) <= 1 )
  {
    v5 = *(_WORD *)(*(_DWORD *)(v7 + 144) + 2 * a3);
    v4 = v5 & 2;
  }
  else
  {
    v4 = sub_1004256E(a1, a2, a3, 2, (int)&v7);
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFDu;
  return v4;
}

//----- (10036C65) --------------------------------------------------------
int __usercall sub_10036C65<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4)
{
  int v4; // ecx@2
  __int16 v5; // cx@3
  int v7; // [sp+0h] [bp-10h]@1
  int v8; // [sp+8h] [bp-8h]@5
  char v9; // [sp+Ch] [bp-4h]@4

  sub_100301AD((int)&v7, a1, a2, a4);
  if ( *(_DWORD *)(v7 + 116) <= 1 )
  {
    v5 = *(_WORD *)(*(_DWORD *)(v7 + 144) + 2 * a3);
    v4 = v5 & 8;
  }
  else
  {
    v4 = sub_1004256E(a1, a2, a3, 8, (int)&v7);
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFDu;
  return v4;
}

//----- (10036CB5) --------------------------------------------------------
int __usercall sub_10036CB5<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4)
{
  int v4; // ecx@2
  __int16 v5; // cx@3
  int v7; // [sp+0h] [bp-10h]@1
  int v8; // [sp+8h] [bp-8h]@5
  char v9; // [sp+Ch] [bp-4h]@4

  sub_100301AD((int)&v7, a1, a2, a4);
  if ( *(_DWORD *)(v7 + 116) <= 1 )
  {
    v5 = *(_WORD *)(*(_DWORD *)(v7 + 144) + 2 * a3);
    v4 = v5 & 1;
  }
  else
  {
    v4 = sub_1004256E(a1, a2, a3, 1, (int)&v7);
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFDu;
  return v4;
}

//----- (10036D05) --------------------------------------------------------
int __usercall sub_10036D05<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4)
{
  int v4; // ecx@2
  __int16 v5; // cx@3
  int v7; // [sp+0h] [bp-10h]@1
  int v8; // [sp+8h] [bp-8h]@5
  char v9; // [sp+Ch] [bp-4h]@4

  sub_100301AD((int)&v7, a1, a2, a4);
  if ( *(_DWORD *)(v7 + 116) <= 1 )
  {
    v5 = *(_WORD *)(*(_DWORD *)(v7 + 144) + 2 * a3);
    v4 = v5 & 0x80;
  }
  else
  {
    v4 = sub_1004256E(a1, a2, a3, 128, (int)&v7);
  }
  if ( v9 )
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFDu;
  return v4;
}

//----- (10036D5B) --------------------------------------------------------
int __usercall sub_10036D5B<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  int result; // eax@2
  wchar_t v4; // ax@2

  if ( dword_10075F28 )
  {
    result = sub_10036BC5(a1, a2, a3, 0);
  }
  else
  {
    v4 = off_10073BD8[a3];
    result = v4 & 4;
  }
  return result;
}
// 10073BD8: using guessed type wchar_t *off_10073BD8;
// 10075F28: using guessed type int dword_10075F28;

//----- (10036D86) --------------------------------------------------------
int __usercall sub_10036D86<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  int result; // eax@2
  wchar_t v4; // ax@2

  if ( dword_10075F28 )
  {
    result = sub_10036C15(a1, a2, a3, 0);
  }
  else
  {
    v4 = off_10073BD8[a3];
    result = v4 & 2;
  }
  return result;
}
// 10073BD8: using guessed type wchar_t *off_10073BD8;
// 10075F28: using guessed type int dword_10075F28;

//----- (10036DB1) --------------------------------------------------------
int __usercall sub_10036DB1<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  int result; // eax@2
  wchar_t v4; // ax@2

  if ( dword_10075F28 )
  {
    result = sub_10036C65(a1, a2, a3, 0);
  }
  else
  {
    v4 = off_10073BD8[a3];
    result = v4 & 8;
  }
  return result;
}
// 10073BD8: using guessed type wchar_t *off_10073BD8;
// 10075F28: using guessed type int dword_10075F28;

//----- (10036DDC) --------------------------------------------------------
int __usercall sub_10036DDC<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  int result; // eax@2
  wchar_t v4; // ax@2

  if ( dword_10075F28 )
  {
    result = sub_10036CB5(a1, a2, a3, 0);
  }
  else
  {
    v4 = off_10073BD8[a3];
    result = v4 & 1;
  }
  return result;
}
// 10073BD8: using guessed type wchar_t *off_10073BD8;
// 10075F28: using guessed type int dword_10075F28;

//----- (10036E07) --------------------------------------------------------
int __usercall sub_10036E07<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  int result; // eax@2
  wchar_t v4; // ax@2

  if ( dword_10075F28 )
  {
    result = sub_10036D05(a1, a2, a3, 0);
  }
  else
  {
    v4 = off_10073BD8[a3];
    result = v4 & 0x80;
  }
  return result;
}
// 10073BD8: using guessed type wchar_t *off_10073BD8;
// 10075F28: using guessed type int dword_10075F28;

//----- (10036E34) --------------------------------------------------------
int __usercall sub_10036E34<eax>(int a1<ebx>, int a2)
{
  int result; // eax@2
  int v3; // eax@3
  int v4; // edx@3
  int v5; // ecx@3
  int v6; // ebx@3
  int v7; // edi@3
  int v8; // eax@3

  if ( a2 )
  {
    v8 = sub_10039899(a2);
    v7 = v8 + 1;
    v3 = (int)sub_10049092((void *)v5, a1, v8 + 1, 2u);
    v6 = v3;
    if ( v3 )
    {
      if ( sub_100490D0(v4, v5, v3, v7, v3, v7, a2) )
      {
        sub_1003A161(v6, v7);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_10036E87);
      }
      result = v6;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10036E87) --------------------------------------------------------
int __usercall sub_10036E87<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // eax@1
  int v4; // edx@1

  v3 = sub_10041952(a1, a2);
  v4 = v3;
  v2 = *(_DWORD *)(v3 + 108);
  if ( (volatile LONG *)v2 != off_10073B44 )
  {
    if ( !(dword_10073C0C & *(_DWORD *)(v4 + 112)) )
      sub_10041DA4(a1, a2);
  }
  return *(_DWORD *)(v2 + 4);
}
// 10073C0C: using guessed type int dword_10073C0C;

//----- (10036EAD) --------------------------------------------------------
int __usercall sub_10036EAD<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // eax@1
  int v4; // edx@1

  v3 = sub_10041952(a1, a2);
  v4 = v3;
  v2 = *(_DWORD *)(v3 + 108);
  if ( (volatile LONG *)v2 != off_10073B44 )
  {
    if ( !(dword_10073C0C & *(_DWORD *)(v4 + 112)) )
      sub_10041DA4(a1, a2);
  }
  return *(_DWORD *)(v2 + 8);
}
// 10073C0C: using guessed type int dword_10073C0C;

//----- (10036ED3) --------------------------------------------------------
int __usercall sub_10036ED3<eax>(int a1<ebx>, int a2<edi>)
{
  volatile LONG *v2; // eax@1
  int v3; // eax@1
  int v4; // edx@1

  v3 = sub_10041952(a1, a2);
  v4 = v3;
  v2 = *(volatile LONG **)(v3 + 108);
  if ( v2 != off_10073B44 )
  {
    if ( !(dword_10073C0C & *(_DWORD *)(v4 + 112)) )
      sub_10041DA4(a1, a2);
  }
  return (int)(v2 + 40);
}
// 10073C0C: using guessed type int dword_10073C0C;

//----- (10036EFB) --------------------------------------------------------
int __usercall sub_10036EFB<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // eax@1
  int v4; // edx@1

  v3 = sub_10041952(a1, a2);
  v4 = v3;
  v2 = *(_DWORD *)(v3 + 108);
  if ( (volatile LONG *)v2 != off_10073B44 )
  {
    if ( !(dword_10073C0C & *(_DWORD *)(v4 + 112)) )
      sub_10041DA4(a1, a2);
  }
  return *(_DWORD *)(v2 + 116);
}
// 10073C0C: using guessed type int dword_10073C0C;

//----- (10036F21) --------------------------------------------------------
int __fastcall sub_10036F21(int a1, int a2, int a3)
{
  int v3; // eax@1
  int v4; // ebx@1
  int v5; // edi@2
  LPVOID v6; // ecx@4
  int v7; // ecx@4
  int v8; // ecx@4
  int v9; // ecx@4
  int v10; // ecx@4
  signed int v11; // eax@9
  UINT v12; // ST1C_4@13
  int v13; // ST04_4@13
  char *v14; // ecx@17
  int v15; // edi@17
  int v16; // eax@18
  int v17; // edx@19
  int v18; // edi@25
  int v19; // eax@25
  int v20; // ecx@25
  unsigned __int8 v21; // zf@25
  char v22; // sf@25
  unsigned __int8 v23; // of@25
  char *v24; // ecx@27
  signed int v25; // edx@29
  int v26; // edi@30
  LPVOID v27; // eax@37
  int result; // eax@39
  int v29; // [sp+8h] [bp-44h]@1
  int v30; // [sp+Ch] [bp-40h]@1
  int v31; // [sp+10h] [bp-3Ch]@25
  int v32; // [sp+14h] [bp-38h]@25
  LPCSTR lpMultiByteStr; // [sp+18h] [bp-34h]@13
  int v34; // [sp+1Ch] [bp-30h]@13
  LPVOID lpMem; // [sp+20h] [bp-2Ch]@1
  int v36; // [sp+24h] [bp-28h]@1
  LPVOID v37; // [sp+28h] [bp-24h]@1
  LPVOID v38; // [sp+2Ch] [bp-20h]@1
  LPVOID v39; // [sp+30h] [bp-1Ch]@1
  struct _cpinfo CPInfo; // [sp+34h] [bp-18h]@11
  unsigned int v41; // [sp+48h] [bp-4h]@1
  int v42; // [sp+4Ch] [bp+0h]@1

  v41 = (unsigned int)&v42 ^ __security_cookie;
  v4 = 0;
  lpMem = 0;
  v3 = *(_DWORD *)(a3 + 168);
  v38 = 0;
  v37 = 0;
  v39 = 0;
  v36 = 0;
  v29 = a3;
  v30 = 0;
  if ( v3 )
  {
    v5 = a3 + 4;
    if ( !*(_DWORD *)(a3 + 4) && sub_1003F7C4((int)&v29, 0, v3, 0x1004u, (LPVOID *)(a3 + 4)) )
      goto LABEL_45;
    lpMem = (LPVOID)sub_10037530(a2, a1, 0, 4);
    v38 = sub_100374E6(v7, 0, 0x180u, 2u);
    v37 = sub_100374E6(v8, 0, 0x180u, 1u);
    v39 = sub_100374E6(v9, 0, 0x180u, 1u);
    v6 = sub_100374E6(v10, 0, 0x101u, 1u);
    v36 = (int)v6;
    if ( !lpMem )
      goto LABEL_45;
    if ( !v38 )
      goto LABEL_45;
    if ( !v6 )
      goto LABEL_45;
    if ( !v37 )
      goto LABEL_45;
    if ( !v39 )
      goto LABEL_45;
    *(_DWORD *)lpMem = 0;
    v11 = 0;
    do
    {
      *((_BYTE *)v6 + v11) = v11;
      ++v11;
    }
    while ( v11 < 256 );
    if ( !GetCPInfo(*(_DWORD *)v5, &CPInfo) )
      goto LABEL_45;
    if ( (_DWORD)CPInfo.MaxCharSize > 5u )
      goto LABEL_45;
    v12 = *(_DWORD *)v5;
    v34 = (unsigned __int16)CPInfo.MaxCharSize;
    v13 = *(_DWORD *)(a3 + 168);
    lpMultiByteStr = (LPCSTR)(v36 + 1);
    if ( !sub_100374A2(0, v5, 0, v13, 0x100u, (LPCSTR)(v36 + 1), 255, (LPWSTR)((char *)v37 + 129), 255, v12, 0) )
      goto LABEL_45;
    if ( !sub_100374A2(
            0,
            v5,
            0,
            *(_DWORD *)(a3 + 168),
            0x200u,
            lpMultiByteStr,
            255,
            (LPWSTR)((char *)v39 + 129),
            255,
            *(_DWORD *)v5,
            0) )
      goto LABEL_45;
    if ( v34 > 1 )
    {
      if ( CPInfo.LeadByte[0] )
      {
        v15 = v36;
        v14 = (char *)&CPInfo.LeadByte[1];
        do
        {
          LOBYTE(v16) = *v14;
          if ( !*v14 )
            break;
          v17 = (unsigned __int8)*(v14 - 1);
          v16 = (unsigned __int8)v16;
          while ( v17 <= v16 )
          {
            *(_BYTE *)(v17 + v15) = 32;
            v16 = (unsigned __int8)*v14;
            ++v17;
          }
          v14 += 2;
        }
        while ( *(v14 - 1) );
        v5 = a3 + 4;
      }
    }
    if ( sub_10049218(0, v5, 0, 1u, (LPCSTR)v36, 256, (LPWORD)v38 + 128, *(_DWORD *)v5, 0) )
    {
      v18 = (int)v38;
      v19 = (int)v39;
      *((_WORD *)v38 + 127) = 0;
      v20 = (int)((char *)v37 + 128);
      *((_BYTE *)v37 + 127) = 0;
      *(_BYTE *)(v19 + 127) = 0;
      v23 = __SETO__(v34, 1);
      v21 = v34 == 1;
      v22 = v34 - 1 < 0;
      *(_BYTE *)v20 = 0;
      v31 = v20;
      v32 = v19 + 128;
      *(_BYTE *)(v19 + 128) = 0;
      if ( !((unsigned __int8)(v22 ^ v23) | v21) )
      {
        if ( CPInfo.LeadByte[0] )
        {
          v24 = (char *)&CPInfo.LeadByte[1];
          do
          {
            if ( !*v24 )
              break;
            v25 = (unsigned __int8)*(v24 - 1);
            if ( v25 <= (unsigned __int8)*v24 )
            {
              lpMultiByteStr = (LPCSTR)(v18 + 256 + 2 * v25);
              v26 = v18 + 256 + 2 * v25;
              do
              {
                *(_WORD *)v26 = -32768;
                ++v25;
                v26 += 2;
              }
              while ( v25 <= (unsigned __int8)*v24 );
              v18 = (int)v38;
            }
            v24 += 2;
          }
          while ( *(v24 - 1) );
        }
      }
      sub_10034EE0((void *)v18, (const void *)(v18 + 512), 0xFEu);
      sub_10034EE0(v37, (char *)v37 + 256, 0x7Fu);
      sub_10034EE0(v39, (char *)v39 + 256, 0x7Fu);
      if ( *(_DWORD *)(a3 + 136) )
      {
        if ( !InterlockedDecrement(*(volatile LONG **)(a3 + 136)) )
        {
          sub_100309C2(0, (LPVOID)(*(_DWORD *)(a3 + 140) - 254));
          sub_100309C2(0, (LPVOID)(*(_DWORD *)(a3 + 148) - 128));
          sub_100309C2(0, (LPVOID)(*(_DWORD *)(a3 + 152) - 128));
          sub_100309C2(0, *(LPVOID *)(a3 + 136));
        }
      }
      v27 = lpMem;
      *(_DWORD *)lpMem = 1;
      *(_DWORD *)(a3 + 136) = v27;
      *(_DWORD *)(a3 + 144) = v18 + 256;
      *(_DWORD *)(a3 + 140) = v18 + 254;
      *(_DWORD *)(a3 + 148) = v31;
      *(_DWORD *)(a3 + 152) = v32;
      *(_DWORD *)(a3 + 116) = v34;
    }
    else
    {
LABEL_45:
      sub_100309C2(0, lpMem);
      sub_100309C2(0, v38);
      sub_100309C2(0, v37);
      sub_100309C2(0, v39);
      v4 = 1;
    }
    sub_100309C2(v4, (LPVOID)v36);
    result = v4;
  }
  else
  {
    if ( *(_DWORD *)(a3 + 136) )
      InterlockedDecrement(*(volatile LONG **)(a3 + 136));
    *(_DWORD *)(a3 + 136) = 0;
    *(_DWORD *)(a3 + 140) = 0;
    *(_DWORD *)(a3 + 144) = L"         (((((                  H";
    *(_DWORD *)(a3 + 148) = &unk_10061550;
    *(_DWORD *)(a3 + 152) = &unk_100616D0;
    *(_DWORD *)(a3 + 116) = 1;
    result = 0;
  }
  return result;
}
// 100610C8: using guessed type wchar_t asc_100610C8[33];
// 10073200: using guessed type int __security_cookie;

//----- (100372B9) --------------------------------------------------------
unsigned int __usercall sub_100372B9<eax>(int a1<ebx>, int a2, int a3, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpDestStr, int cchDest, UINT CodePage, int a10)
{
  int v10; // esi@1
  LPCSTR v11; // eax@2
  signed int v12; // ecx@2
  UINT v13; // ecx@8
  unsigned int v14; // edi@8
  unsigned int v15; // eax@10
  int v16; // ecx@10
  int v18; // ecx@14
  int v19; // ebx@15
  int v20; // eax@17
  unsigned int v21; // eax@24
  int v22; // esi@24
  unsigned int v23; // eax@31
  char *v24; // esi@32
  int v25; // eax@34
  int v26; // esi@36
  CHAR *v27; // [sp-10h] [bp-24h]@41
  int v28; // [sp-Ch] [bp-20h]@41
  char v29; // [sp+0h] [bp-14h]@15
  int cchSrc; // [sp+Ch] [bp-8h]@10
  unsigned int v31; // [sp+10h] [bp-4h]@1
  int v32; // [sp+14h] [bp+0h]@1

  v31 = (unsigned int)&v32 ^ __security_cookie;
  v10 = cbMultiByte;
  if ( cbMultiByte > 0 )
  {
    v11 = lpMultiByteStr;
    v12 = cbMultiByte;
    while ( 1 )
    {
      --v12;
      if ( !*v11 )
        break;
      ++v11;
      if ( !v12 )
      {
        v12 = -1;
        break;
      }
    }
    v10 = cbMultiByte - v12;
    if ( cbMultiByte - v12 - 1 >= cbMultiByte )
      v10 = cbMultiByte - v12 - 1;
  }
  v13 = CodePage;
  v14 = 0;
  if ( !CodePage )
  {
    CodePage = *(_DWORD *)(*(_DWORD *)a2 + 4);
    v13 = *(_DWORD *)(*(_DWORD *)a2 + 4);
  }
  v15 = MultiByteToWideChar(v13, 8 * (a10 != 0) + 1, lpMultiByteStr, v10, 0, 0);
  v16 = v15;
  cchSrc = v15;
  if ( !v15 )
    return 0;
  if ( (signed int)v15 > 0 && 0xFFFFFFE0 / v15 >= 2 )
  {
    v18 = 2 * v15 + 8;
    if ( (unsigned int)v18 > 0x400 )
    {
      v20 = sub_10030930(0xFFFFFFE0 % v15, v18, a1, 0, v18);
      v19 = v20;
      if ( v20 )
      {
        *(_DWORD *)v20 = 56797;
        goto LABEL_19;
      }
    }
    else
    {
      sub_1003F580(v18, v18, v29);
      v19 = (int)&v29;
      if ( &v29 )
      {
        *(_DWORD *)&v29 = 52428;
LABEL_19:
        v19 += 8;
        goto LABEL_20;
      }
    }
LABEL_20:
    v16 = cchSrc;
    goto LABEL_22;
  }
  v19 = 0;
LABEL_22:
  if ( !v19 )
    return 0;
  if ( MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, v10, (LPWSTR)v19, v16) )
  {
    v22 = cchSrc;
    v21 = sub_10039D13(a3, dwMapFlags, (LPCWSTR)v19, cchSrc, 0, 0);
    v14 = v21;
    if ( v21 )
    {
      if ( dwMapFlags & 0x400 )
      {
        if ( cchDest )
        {
          if ( (signed int)v21 <= cchDest )
            sub_10039D13(a3, dwMapFlags, (LPCWSTR)v19, v22, lpDestStr, cchDest);
        }
        goto LABEL_45;
      }
      if ( (signed int)v21 <= 0 || 0xFFFFFFE0 / v21 < 2 )
      {
        v26 = 0;
LABEL_38:
        if ( v26 )
        {
          if ( sub_10039D13(a3, dwMapFlags, (LPCWSTR)v19, cchSrc, (LPWSTR)v26, v14) )
          {
            if ( cchDest )
            {
              v28 = cchDest;
              v27 = (CHAR *)lpDestStr;
            }
            else
            {
              v28 = 0;
              v27 = 0;
            }
            v14 = WideCharToMultiByte(CodePage, 0, (LPCWSTR)v26, v14, v27, v28, 0, 0);
          }
          sub_1002CAA4(v19, v26);
        }
        goto LABEL_45;
      }
      v23 = 2 * v21 + 8;
      if ( v23 > 0x400 )
      {
        v25 = sub_10030930(0xFFFFFFE0 % v14, 1024, v19, v14, 2 * v14 + 8);
        v24 = (char *)v25;
        if ( v25 )
        {
          *(_DWORD *)v25 = 56797;
          goto LABEL_36;
        }
      }
      else
      {
        sub_1003F580(v23, 1024, v29);
        v24 = &v29;
        if ( &v29 )
        {
          *(_DWORD *)&v29 = 52428;
LABEL_36:
          v26 = (int)(v24 + 8);
          goto LABEL_38;
        }
      }
    }
  }
LABEL_45:
  sub_1002CAA4(v19, v19);
  return v14;
}
// 10073200: using guessed type int __security_cookie;

//----- (100374A2) --------------------------------------------------------
unsigned int __usercall sub_100374A2<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, DWORD dwMapFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpDestStr, int cchDest, UINT CodePage, int a11)
{
  unsigned int result; // eax@1
  int v12; // [sp+0h] [bp-10h]@1
  int v13; // [sp+8h] [bp-8h]@2
  char v14; // [sp+Ch] [bp-4h]@1

  sub_100301AD((int)&v12, a1, a2, a3);
  result = sub_100372B9(a1, (int)&v12, a4, dwMapFlags, lpMultiByteStr, cbMultiByte, lpDestStr, cchDest, CodePage, a11);
  if ( v14 )
    *(_DWORD *)(v13 + 112) &= 0xFFFFFFFDu;
  return result;
}

//----- (100374E6) --------------------------------------------------------
LPVOID __usercall sub_100374E6<eax>(int this<ecx>, int ebx0<ebx>, unsigned int a2, unsigned int a3)
{
  int v4; // esi@1
  LPVOID v5; // edi@2

  v4 = 0;
  do
  {
    v5 = sub_100492BF((void *)this, ebx0, a2, a3, 0);
    if ( v5 )
      break;
    if ( (unsigned int)dword_10075770 <= 0 )
      break;
    Sleep(v4);
    this = v4 + 1000;
    v4 = this;
    if ( this > (unsigned int)dword_10075770 )
      v4 = -1;
  }
  while ( v4 != -1 );
  return v5;
}
// 10075770: using guessed type int dword_10075770;

//----- (10037530) --------------------------------------------------------
int __usercall sub_10037530<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int dwBytes)
{
  int v4; // edi@1
  DWORD v5; // esi@1

  v4 = dword_10075770;
  v5 = 0;
  do
  {
    a3 = sub_10030930(a1, a2, a3, v4, dwBytes);
    if ( a3 )
      break;
    if ( !v4 )
      break;
    Sleep(v5);
    v4 = dword_10075770;
    a2 = v5 + 1000;
    v5 = a2;
    if ( a2 > (unsigned int)dword_10075770 )
      v5 = -1;
  }
  while ( v5 != -1 );
  return a3;
}
// 10075770: using guessed type int dword_10075770;

//----- (10037579) --------------------------------------------------------
int __usercall sub_10037579<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, LPVOID lpMem, int dwBytes)
{
  DWORD v6; // esi@1
  int v7; // eax@2

  v6 = 0;
  do
  {
    v7 = sub_10030C56(a1, a2, a3, a4, lpMem, dwBytes);
    a4 = v7;
    if ( v7 )
      break;
    if ( !dwBytes )
      break;
    if ( dword_10075770 <= (unsigned int)v7 )
      break;
    Sleep(v6);
    v6 += 1000;
    if ( v6 > dword_10075770 )
      v6 = -1;
  }
  while ( v6 != -1 );
  return a4;
}
// 10075770: using guessed type int dword_10075770;

//----- (100375C5) --------------------------------------------------------
int __usercall sub_100375C5<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, const void *lpMem, unsigned int a5, unsigned int a6)
{
  DWORD v6; // esi@1
  int v7; // eax@2
  int v8; // edi@2

  v6 = 0;
  do
  {
    v7 = sub_10049256(a1, a2, a3, lpMem, a5, a6);
    v8 = v7;
    if ( v7 )
      break;
    if ( !a6 )
      break;
    if ( dword_10075770 <= (unsigned int)v7 )
      break;
    Sleep(v6);
    v6 += 1000;
    if ( v6 > dword_10075770 )
      v6 = -1;
  }
  while ( v6 != -1 );
  return v8;
}
// 10075770: using guessed type int dword_10075770;

//----- (10037615) --------------------------------------------------------
int __usercall sub_10037615<eax>(int a1<ebx>)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1004196A(a1);
  if ( v1 )
    result = v1 + 12;
  else
    result = (int)&unk_100731F4;
  return result;
}

//----- (10037628) --------------------------------------------------------
int __usercall sub_10037628<eax>(int a1<ebx>, int a2)
{
  int result; // eax@1
  signed int v3; // esi@1

  *(_DWORD *)sub_10037615(a1) = a2;
  v3 = sub_1003765C(a2);
  result = sub_10037649(a1);
  *(_DWORD *)result = v3;
  return result;
}

//----- (10037649) --------------------------------------------------------
int __usercall sub_10037649<eax>(int a1<ebx>)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1004196A(a1);
  if ( v1 )
    result = v1 + 8;
  else
    result = (int)&unk_100731F0;
  return result;
}

//----- (1003765C) --------------------------------------------------------
signed int __cdecl sub_1003765C(int a1)
{
  unsigned int v1; // eax@1
  signed int result; // eax@5

  v1 = 0;
  do
  {
    if ( a1 == dword_10073088[2 * v1] )
      return dword_1007308C[2 * v1];
    ++v1;
  }
  while ( v1 < 0x2D );
  if ( (unsigned int)(a1 - 19) > 0x11 )
    result = (unsigned int)(a1 - 188) > 0xE ? 22 : 8;
  else
    result = 13;
  return result;
}
// 10073088: using guessed type int dword_10073088[];
// 1007308C: using guessed type int dword_1007308C[];

//----- (1003769D) --------------------------------------------------------
signed int __usercall sub_1003769D<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned __int8 a4, int a5, unsigned __int8 a6)
{
  signed int v6; // edx@2
  int v7; // eax@3
  int v9; // [sp+4h] [bp-10h]@1
  int v10; // [sp+8h] [bp-Ch]@1
  int v11; // [sp+Ch] [bp-8h]@8
  char v12; // [sp+10h] [bp-4h]@7

  sub_100301AD((int)&v9, a1, a2, a3);
  if ( a6 & *(_BYTE *)(v10 + a4 + 25)
    || ((v6 = 0, !a5) ? (v7 = 0) : (v7 = (unsigned __int16)(a5 & *(_WORD *)(*(_DWORD *)(v9 + 144) + 2 * a4))), v7) )
    v6 = 1;
  if ( v12 )
    *(_DWORD *)(v11 + 112) &= 0xFFFFFFFDu;
  return v6;
}

//----- (100376F3) --------------------------------------------------------
signed int __usercall sub_100376F3<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3)
{
  return sub_1003769D(a1, a2, 0, a3, 0, 4u);
}

//----- (10037709) --------------------------------------------------------
int __cdecl sub_10037709(int a1, int a2, unsigned int a3)
{
  unsigned int v3; // ebx@1
  int v4; // edx@5
  int v5; // esi@6
  int v6; // eax@7
  int v7; // edi@8
  int v8; // ecx@9
  bool v9; // ecx@9
  int v10; // edi@10
  bool v11; // ecx@11
  int v12; // edi@12
  bool v13; // ecx@13
  int v14; // eax@18
  int v15; // edi@21
  bool v16; // ecx@22
  int v17; // edi@23
  bool v18; // ecx@24
  int v19; // eax@29
  int v20; // edi@32
  bool v21; // ecx@33
  int v22; // edi@34
  bool v23; // ecx@35
  int v24; // eax@40
  int v25; // edi@43
  bool v26; // ecx@44
  int v27; // edi@45
  bool v28; // ecx@46
  int v29; // edi@54
  bool v30; // ecx@55
  int v31; // edi@56
  bool v32; // ecx@57
  int v33; // eax@62
  int v34; // edi@65
  bool v35; // ecx@66
  int v36; // edi@67
  bool v37; // ecx@68
  int v38; // eax@73
  int v39; // edi@76
  bool v40; // ecx@77
  int v41; // edi@78
  bool v42; // ecx@79
  int v43; // eax@84
  int v44; // edi@87
  bool v45; // ecx@88
  int v46; // edi@89
  bool v47; // ecx@90
  int v48; // edx@96
  int v49; // esi@96
  int v50; // eax@97
  int v51; // edi@98
  bool v52; // ecx@99
  int v53; // edi@100
  bool v54; // ecx@101
  int v55; // edi@102
  bool v56; // ecx@103
  int v57; // eax@108
  int v58; // edi@109
  bool v59; // ecx@110
  int v60; // edi@111
  bool v61; // ecx@112
  int v62; // edi@113
  bool v63; // ecx@114
  int v64; // eax@119
  int v65; // edi@120
  bool v66; // ecx@121
  int v67; // edi@122
  bool v68; // ecx@123
  int v69; // edi@124
  bool v70; // ecx@125
  int v71; // eax@130
  int v72; // edi@131
  bool v73; // ecx@132
  int v74; // edi@133
  bool v75; // ecx@134
  int v76; // edi@135
  bool v77; // ecx@136
  int v78; // edi@142
  bool v79; // ecx@143
  int v80; // edi@144
  bool v81; // ecx@145
  int v82; // edi@146
  bool v83; // ecx@147
  int v84; // eax@152
  int v85; // edi@153
  bool v86; // ecx@154
  int v87; // edi@155
  bool v88; // ecx@156
  int v89; // edi@157
  bool v90; // ecx@158
  int v91; // eax@163
  int v92; // edi@164
  bool v93; // ecx@165
  int v94; // edi@166
  bool v95; // ecx@167
  int v96; // edi@168
  bool v97; // ecx@169
  int result; // eax@175
  int v99; // eax@176
  int v100; // edi@177
  bool v101; // ecx@178
  int v102; // edi@179
  bool v103; // ecx@180
  int v104; // edi@181
  bool v105; // ecx@182
  int v106; // eax@187
  int v107; // edi@188
  bool v108; // ecx@189
  int v109; // edi@190
  bool v110; // ecx@191
  int v111; // edi@192
  bool v112; // ecx@193
  int v113; // eax@198
  int v114; // edi@199
  bool v115; // ecx@200
  int v116; // edi@201
  bool v117; // ecx@202
  int v118; // edi@203
  bool v119; // ecx@204
  int v120; // eax@209
  int v121; // edi@210
  bool v122; // ecx@211
  int v123; // edi@212
  bool v124; // ecx@213
  int v125; // edi@214
  bool v126; // ecx@215
  int v127; // eax@220
  int v128; // edi@221
  bool v129; // ecx@222
  int v130; // edi@223
  bool v131; // ecx@224
  int v132; // edi@225
  bool v133; // ecx@226
  int v134; // edi@232
  bool v135; // ecx@233
  int v136; // edi@234
  bool v137; // ecx@235
  int v138; // edi@236
  bool v139; // ecx@237
  int v140; // eax@242
  int v141; // edi@243
  bool v142; // ecx@244
  int v143; // edi@245
  bool v144; // ecx@246
  int v145; // edi@247
  bool v146; // ecx@248
  int v147; // eax@255
  int v148; // edi@256
  bool v149; // ecx@257
  int v150; // edi@258
  bool v151; // ecx@259
  int v152; // edi@260
  bool v153; // ecx@261
  int v154; // eax@266
  int v155; // edi@267
  bool v156; // ecx@268
  int v157; // edi@269
  bool v158; // ecx@270
  int v159; // edi@271
  bool v160; // ecx@272
  int v161; // eax@277
  int v162; // edi@278
  bool v163; // ecx@279
  int v164; // edi@280
  bool v165; // ecx@281
  int v166; // edi@282
  bool v167; // ecx@283
  int v168; // eax@288
  int v169; // edi@289
  bool v170; // ecx@290
  int v171; // edi@291
  bool v172; // ecx@292
  int v173; // edi@293
  bool v174; // ecx@294
  int v175; // eax@299
  int v176; // edi@300
  bool v177; // ecx@301
  int v178; // edi@302
  bool v179; // ecx@303
  int v180; // edi@304
  bool v181; // ecx@305
  int v182; // edi@311
  bool v183; // ecx@312
  int v184; // edi@313
  bool v185; // ecx@314
  int v186; // edi@315
  bool v187; // ecx@316
  int v188; // eax@321
  int v189; // edi@322
  bool v190; // ecx@323
  int v191; // edi@324
  bool v192; // ecx@325
  int v193; // edi@326
  bool v194; // ecx@327
  int v195; // eax@334
  int v196; // edi@335
  bool v197; // ecx@336
  int v198; // edi@337
  bool v199; // ecx@338
  int v200; // edi@339
  bool v201; // ecx@340
  int v202; // eax@345
  int v203; // edi@346
  bool v204; // ecx@347
  int v205; // edi@348
  bool v206; // ecx@349
  int v207; // edi@350
  bool v208; // ecx@351
  int v209; // eax@356
  int v210; // edi@357
  bool v211; // ecx@358
  int v212; // edi@359
  bool v213; // ecx@360
  int v214; // edi@361
  bool v215; // ecx@362
  int v216; // eax@367
  int v217; // edi@368
  bool v218; // ecx@369
  int v219; // edi@370
  bool v220; // ecx@371
  int v221; // edi@372
  bool v222; // ecx@373
  int v223; // edi@379
  bool v224; // ecx@380
  int v225; // edi@381
  bool v226; // ecx@382
  int v227; // edi@383
  bool v228; // ecx@384
  int v229; // eax@389
  int v230; // edi@390
  bool v231; // ecx@391
  int v232; // edi@392
  bool v233; // ecx@393
  int v234; // edi@394
  bool v235; // ecx@395
  int v236; // eax@400
  int v237; // edi@401
  bool v238; // ecx@402
  int v239; // edi@403
  bool v240; // ecx@404
  int v241; // edi@405
  bool v242; // ecx@406
  int v243; // edi@411
  bool v244; // ecx@412
  int v245; // edi@413
  bool v246; // ecx@414
  int v247; // esi@415
  bool v248; // eax@416
  int v249; // esi@417
  bool v250; // eax@418
  int v251; // esi@419
  bool v252; // eax@420
  int v253; // eax@421
  int v254; // ecx@421
  int v255; // ecx@422
  int v256; // ecx@425
  bool v257; // eax@426
  int v258; // ecx@427
  bool v259; // eax@428
  int v260; // ecx@430
  bool v261; // eax@431

  v3 = a3;
  if ( !a3 )
    return 0;
  if ( a3 == 1 )
  {
    v254 = *(_BYTE *)a1;
    v253 = *(_BYTE *)a2;
    goto LABEL_422;
  }
  if ( a3 == 2 )
  {
    v260 = *(_BYTE *)a1 - *(_BYTE *)a2;
    if ( *(_BYTE *)a1 != *(_BYTE *)a2 )
    {
      v261 = v260 < 0;
      LOBYTE(v261) = v260 > 0;
      result = 2 * v261 - 1;
      if ( result )
        return result;
    }
    v254 = *(_BYTE *)(a1 + 1);
    v253 = *(_BYTE *)(a2 + 1);
LABEL_422:
    v255 = v254 - v253;
    if ( v255 )
      v255 = 2 * (v255 > 0) - 1;
    return v255;
  }
  if ( a3 == 3 )
  {
    v256 = *(_BYTE *)a1 - *(_BYTE *)a2;
    if ( *(_BYTE *)a1 != *(_BYTE *)a2 && (v257 = v256 < 0, LOBYTE(v257) = v256 > 0, (result = 2 * v257 - 1) != 0)
      || (v258 = *(_BYTE *)(a1 + 1) - *(_BYTE *)(a2 + 1), *(_BYTE *)(a1 + 1) != *(_BYTE *)(a2 + 1))
      && (v259 = v258 < 0, LOBYTE(v259) = v258 > 0, (result = 2 * v259 - 1) != 0) )
      return result;
    v254 = *(_BYTE *)(a1 + 2);
    v253 = *(_BYTE *)(a2 + 2);
    goto LABEL_422;
  }
  v4 = a2;
  if ( a3 == 4 )
  {
    v247 = *(_BYTE *)a1 - *(_BYTE *)a2;
    if ( *(_BYTE *)a1 != *(_BYTE *)a2 && (v248 = v247 < 0, LOBYTE(v248) = v247 > 0, (result = 2 * v248 - 1) != 0)
      || (v249 = *(_BYTE *)(a1 + 1) - *(_BYTE *)(a2 + 1), *(_BYTE *)(a1 + 1) != *(_BYTE *)(a2 + 1))
      && (v250 = v249 < 0, LOBYTE(v250) = v249 > 0, (result = 2 * v250 - 1) != 0)
      || (v251 = *(_BYTE *)(a1 + 2) - *(_BYTE *)(a2 + 2), *(_BYTE *)(a1 + 2) != *(_BYTE *)(a2 + 2))
      && (v252 = v251 < 0, LOBYTE(v252) = v251 > 0, (result = 2 * v252 - 1) != 0) )
      return result;
    v254 = *(_BYTE *)(a1 + 3);
    v253 = *(_BYTE *)(a2 + 3);
    goto LABEL_422;
  }
  v5 = a1;
  if ( a3 >= 0x20 )
  {
    do
    {
      v6 = *(_DWORD *)v5;
      if ( *(_DWORD *)v5 == *(_DWORD *)v4 )
      {
        v8 = 0;
      }
      else
      {
        v7 = (unsigned __int8)v6 - *(_BYTE *)v4;
        if ( (unsigned __int8)v6 != *(_BYTE *)v4 && (v9 = v7 < 0, LOBYTE(v9) = v7 > 0, (v8 = 2 * v9 - 1) != 0)
          || (v10 = *(_BYTE *)(v5 + 1) - *(_BYTE *)(v4 + 1), *(_BYTE *)(v5 + 1) != *(_BYTE *)(v4 + 1))
          && (v11 = v10 < 0, LOBYTE(v11) = v10 > 0, (v8 = 2 * v11 - 1) != 0)
          || (v12 = *(_BYTE *)(v5 + 2) - *(_BYTE *)(v4 + 2), *(_BYTE *)(v5 + 2) != *(_BYTE *)(v4 + 2))
          && (v13 = v12 < 0, LOBYTE(v13) = v12 > 0, (v8 = 2 * v13 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 3) - *(_BYTE *)(v4 + 3);
        if ( *(_BYTE *)(v5 + 3) != *(_BYTE *)(v4 + 3) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v14 = *(_DWORD *)(v5 + 4);
      if ( v14 == *(_DWORD *)(v4 + 4) )
      {
        v8 = 0;
      }
      else
      {
        if ( (unsigned __int8)v14 != *(_BYTE *)(v4 + 4)
          && (LOBYTE(v8) = (unsigned __int8)v14 - *(_BYTE *)(v4 + 4) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v15 = *(_BYTE *)(v5 + 5) - *(_BYTE *)(v4 + 5), *(_BYTE *)(v5 + 5) != *(_BYTE *)(v4 + 5))
          && (v16 = v15 < 0, LOBYTE(v16) = v15 > 0, (v8 = 2 * v16 - 1) != 0)
          || (v17 = *(_BYTE *)(v5 + 6) - *(_BYTE *)(v4 + 6), *(_BYTE *)(v5 + 6) != *(_BYTE *)(v4 + 6))
          && (v18 = v17 < 0, LOBYTE(v18) = v17 > 0, (v8 = 2 * v18 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 7) - *(_BYTE *)(v4 + 7);
        if ( *(_BYTE *)(v5 + 7) != *(_BYTE *)(v4 + 7) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v19 = *(_DWORD *)(v5 + 8);
      if ( v19 == *(_DWORD *)(v4 + 8) )
      {
        v8 = 0;
      }
      else
      {
        if ( (unsigned __int8)v19 != *(_BYTE *)(v4 + 8)
          && (LOBYTE(v8) = (unsigned __int8)v19 - *(_BYTE *)(v4 + 8) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v20 = *(_BYTE *)(v5 + 9) - *(_BYTE *)(v4 + 9), *(_BYTE *)(v5 + 9) != *(_BYTE *)(v4 + 9))
          && (v21 = v20 < 0, LOBYTE(v21) = v20 > 0, (v8 = 2 * v21 - 1) != 0)
          || (v22 = *(_BYTE *)(v5 + 10) - *(_BYTE *)(v4 + 10), *(_BYTE *)(v5 + 10) != *(_BYTE *)(v4 + 10))
          && (v23 = v22 < 0, LOBYTE(v23) = v22 > 0, (v8 = 2 * v23 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 11) - *(_BYTE *)(v4 + 11);
        if ( *(_BYTE *)(v5 + 11) != *(_BYTE *)(v4 + 11) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v24 = *(_DWORD *)(v5 + 12);
      if ( v24 == *(_DWORD *)(v4 + 12) )
      {
        v8 = 0;
      }
      else
      {
        if ( (unsigned __int8)v24 != *(_BYTE *)(v4 + 12)
          && (LOBYTE(v8) = (unsigned __int8)v24 - *(_BYTE *)(v4 + 12) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v25 = *(_BYTE *)(v5 + 13) - *(_BYTE *)(v4 + 13), *(_BYTE *)(v5 + 13) != *(_BYTE *)(v4 + 13))
          && (v26 = v25 < 0, LOBYTE(v26) = v25 > 0, (v8 = 2 * v26 - 1) != 0)
          || (v27 = *(_BYTE *)(v5 + 14) - *(_BYTE *)(v4 + 14), *(_BYTE *)(v5 + 14) != *(_BYTE *)(v4 + 14))
          && (v28 = v27 < 0, LOBYTE(v28) = v27 > 0, (v8 = 2 * v28 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 15) - *(_BYTE *)(v4 + 15);
        if ( *(_BYTE *)(v5 + 15) != *(_BYTE *)(v4 + 15) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      if ( *(_DWORD *)(v5 + 16) == *(_DWORD *)(v4 + 16) )
      {
        v8 = 0;
      }
      else
      {
        if ( *(_BYTE *)(v5 + 16) != *(_BYTE *)(v4 + 16)
          && (LOBYTE(v8) = *(_BYTE *)(v5 + 16) - *(_BYTE *)(v4 + 16) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v29 = *(_BYTE *)(v5 + 17) - *(_BYTE *)(v4 + 17), *(_BYTE *)(v5 + 17) != *(_BYTE *)(v4 + 17))
          && (v30 = v29 < 0, LOBYTE(v30) = v29 > 0, (v8 = 2 * v30 - 1) != 0)
          || (v31 = *(_BYTE *)(v5 + 18) - *(_BYTE *)(v4 + 18), *(_BYTE *)(v5 + 18) != *(_BYTE *)(v4 + 18))
          && (v32 = v31 < 0, LOBYTE(v32) = v31 > 0, (v8 = 2 * v32 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 19) - *(_BYTE *)(v4 + 19);
        if ( *(_BYTE *)(v5 + 19) != *(_BYTE *)(v4 + 19) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v33 = *(_DWORD *)(v5 + 20);
      if ( v33 == *(_DWORD *)(v4 + 20) )
      {
        v8 = 0;
      }
      else
      {
        if ( (unsigned __int8)v33 != *(_BYTE *)(v4 + 20)
          && (LOBYTE(v8) = (unsigned __int8)v33 - *(_BYTE *)(v4 + 20) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v34 = *(_BYTE *)(v5 + 21) - *(_BYTE *)(v4 + 21), *(_BYTE *)(v5 + 21) != *(_BYTE *)(v4 + 21))
          && (v35 = v34 < 0, LOBYTE(v35) = v34 > 0, (v8 = 2 * v35 - 1) != 0)
          || (v36 = *(_BYTE *)(v5 + 22) - *(_BYTE *)(v4 + 22), *(_BYTE *)(v5 + 22) != *(_BYTE *)(v4 + 22))
          && (v37 = v36 < 0, LOBYTE(v37) = v36 > 0, (v8 = 2 * v37 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 23) - *(_BYTE *)(v4 + 23);
        if ( *(_BYTE *)(v5 + 23) != *(_BYTE *)(v4 + 23) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v38 = *(_DWORD *)(v5 + 24);
      if ( v38 == *(_DWORD *)(v4 + 24) )
      {
        v8 = 0;
      }
      else
      {
        if ( (unsigned __int8)v38 != *(_BYTE *)(v4 + 24)
          && (LOBYTE(v8) = (unsigned __int8)v38 - *(_BYTE *)(v4 + 24) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v39 = *(_BYTE *)(v5 + 25) - *(_BYTE *)(v4 + 25), *(_BYTE *)(v5 + 25) != *(_BYTE *)(v4 + 25))
          && (v40 = v39 < 0, LOBYTE(v40) = v39 > 0, (v8 = 2 * v40 - 1) != 0)
          || (v41 = *(_BYTE *)(v5 + 26) - *(_BYTE *)(v4 + 26), *(_BYTE *)(v5 + 26) != *(_BYTE *)(v4 + 26))
          && (v42 = v41 < 0, LOBYTE(v42) = v41 > 0, (v8 = 2 * v42 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 27) - *(_BYTE *)(v4 + 27);
        if ( *(_BYTE *)(v5 + 27) != *(_BYTE *)(v4 + 27) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v43 = *(_DWORD *)(v5 + 28);
      if ( v43 == *(_DWORD *)(v4 + 28) )
      {
        v8 = 0;
      }
      else
      {
        if ( (unsigned __int8)v43 != *(_BYTE *)(v4 + 28)
          && (LOBYTE(v8) = (unsigned __int8)v43 - *(_BYTE *)(v4 + 28) > 0, (v8 = 2 * v8 - 1) != 0)
          || (v44 = *(_BYTE *)(v5 + 29) - *(_BYTE *)(v4 + 29), *(_BYTE *)(v5 + 29) != *(_BYTE *)(v4 + 29))
          && (v45 = v44 < 0, LOBYTE(v45) = v44 > 0, (v8 = 2 * v45 - 1) != 0)
          || (v46 = *(_BYTE *)(v5 + 30) - *(_BYTE *)(v4 + 30), *(_BYTE *)(v5 + 30) != *(_BYTE *)(v4 + 30))
          && (v47 = v46 < 0, LOBYTE(v47) = v46 > 0, (v8 = 2 * v47 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v5 + 31) - *(_BYTE *)(v4 + 31);
        if ( *(_BYTE *)(v5 + 31) != *(_BYTE *)(v4 + 31) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
      v3 -= 32;
      v5 += 32;
      v4 += 32;
    }
    while ( v3 >= 0x20 );
  }
  v49 = v3 + v5;
  v48 = v3 + v4;
  switch ( v3 )
  {
    case 0x1Cu:
      v50 = *(_DWORD *)(v49 - 28);
      if ( v50 == *(_DWORD *)(v48 - 28) )
      {
        v8 = 0;
      }
      else
      {
        v51 = (unsigned __int8)v50 - *(_BYTE *)(v48 - 28);
        if ( (unsigned __int8)v50 != *(_BYTE *)(v48 - 28)
          && (v52 = v51 < 0, LOBYTE(v52) = v51 > 0, (v8 = 2 * v52 - 1) != 0)
          || (v53 = *(_BYTE *)(v49 - 27) - *(_BYTE *)(v48 - 27), *(_BYTE *)(v49 - 27) != *(_BYTE *)(v48 - 27))
          && (v54 = v53 < 0, LOBYTE(v54) = v53 > 0, (v8 = 2 * v54 - 1) != 0)
          || (v55 = *(_BYTE *)(v49 - 26) - *(_BYTE *)(v48 - 26), *(_BYTE *)(v49 - 26) != *(_BYTE *)(v48 - 26))
          && (v56 = v55 < 0, LOBYTE(v56) = v55 > 0, (v8 = 2 * v56 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 25) - *(_BYTE *)(v48 - 25);
        if ( *(_BYTE *)(v49 - 25) != *(_BYTE *)(v48 - 25) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        goto LABEL_108;
      return v8;
    case 0x18u:
LABEL_108:
      v57 = *(_DWORD *)(v49 - 24);
      if ( v57 == *(_DWORD *)(v48 - 24) )
      {
        v8 = 0;
      }
      else
      {
        v58 = (unsigned __int8)v57 - *(_BYTE *)(v48 - 24);
        if ( (unsigned __int8)v57 != *(_BYTE *)(v48 - 24)
          && (v59 = v58 < 0, LOBYTE(v59) = v58 > 0, (v8 = 2 * v59 - 1) != 0)
          || (v60 = *(_BYTE *)(v49 - 23) - *(_BYTE *)(v48 - 23), *(_BYTE *)(v49 - 23) != *(_BYTE *)(v48 - 23))
          && (v61 = v60 < 0, LOBYTE(v61) = v60 > 0, (v8 = 2 * v61 - 1) != 0)
          || (v62 = *(_BYTE *)(v49 - 22) - *(_BYTE *)(v48 - 22), *(_BYTE *)(v49 - 22) != *(_BYTE *)(v48 - 22))
          && (v63 = v62 < 0, LOBYTE(v63) = v62 > 0, (v8 = 2 * v63 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 21) - *(_BYTE *)(v48 - 21);
        if ( *(_BYTE *)(v49 - 21) != *(_BYTE *)(v48 - 21) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        goto LABEL_119;
      return v8;
    case 0x14u:
LABEL_119:
      v64 = *(_DWORD *)(v49 - 20);
      if ( v64 == *(_DWORD *)(v48 - 20) )
      {
        v8 = 0;
      }
      else
      {
        v65 = (unsigned __int8)v64 - *(_BYTE *)(v48 - 20);
        if ( (unsigned __int8)v64 != *(_BYTE *)(v48 - 20)
          && (v66 = v65 < 0, LOBYTE(v66) = v65 > 0, (v8 = 2 * v66 - 1) != 0)
          || (v67 = *(_BYTE *)(v49 - 19) - *(_BYTE *)(v48 - 19), *(_BYTE *)(v49 - 19) != *(_BYTE *)(v48 - 19))
          && (v68 = v67 < 0, LOBYTE(v68) = v67 > 0, (v8 = 2 * v68 - 1) != 0)
          || (v69 = *(_BYTE *)(v49 - 18) - *(_BYTE *)(v48 - 18), *(_BYTE *)(v49 - 18) != *(_BYTE *)(v48 - 18))
          && (v70 = v69 < 0, LOBYTE(v70) = v69 > 0, (v8 = 2 * v70 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 17) - *(_BYTE *)(v48 - 17);
        if ( *(_BYTE *)(v49 - 17) != *(_BYTE *)(v48 - 17) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        goto LABEL_130;
      return v8;
    case 0x10u:
LABEL_130:
      v71 = *(_DWORD *)(v49 - 16);
      if ( v71 == *(_DWORD *)(v48 - 16) )
      {
        v8 = 0;
      }
      else
      {
        v72 = (unsigned __int8)v71 - *(_BYTE *)(v48 - 16);
        if ( (unsigned __int8)v71 != *(_BYTE *)(v48 - 16)
          && (v73 = v72 < 0, LOBYTE(v73) = v72 > 0, (v8 = 2 * v73 - 1) != 0)
          || (v74 = *(_BYTE *)(v49 - 15) - *(_BYTE *)(v48 - 15), *(_BYTE *)(v49 - 15) != *(_BYTE *)(v48 - 15))
          && (v75 = v74 < 0, LOBYTE(v75) = v74 > 0, (v8 = 2 * v75 - 1) != 0)
          || (v76 = *(_BYTE *)(v49 - 14) - *(_BYTE *)(v48 - 14), *(_BYTE *)(v49 - 14) != *(_BYTE *)(v48 - 14))
          && (v77 = v76 < 0, LOBYTE(v77) = v76 > 0, (v8 = 2 * v77 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 13) - *(_BYTE *)(v48 - 13);
        if ( *(_BYTE *)(v49 - 13) != *(_BYTE *)(v48 - 13) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        goto LABEL_141;
      return v8;
    case 0xCu:
LABEL_141:
      if ( *(_DWORD *)(v49 - 12) == *(_DWORD *)(v48 - 12) )
      {
        v8 = 0;
      }
      else
      {
        v78 = *(_BYTE *)(v49 - 12) - *(_BYTE *)(v48 - 12);
        if ( *(_BYTE *)(v49 - 12) != *(_BYTE *)(v48 - 12)
          && (v79 = v78 < 0, LOBYTE(v79) = v78 > 0, (v8 = 2 * v79 - 1) != 0)
          || (v80 = *(_BYTE *)(v49 - 11) - *(_BYTE *)(v48 - 11), *(_BYTE *)(v49 - 11) != *(_BYTE *)(v48 - 11))
          && (v81 = v80 < 0, LOBYTE(v81) = v80 > 0, (v8 = 2 * v81 - 1) != 0)
          || (v82 = *(_BYTE *)(v49 - 10) - *(_BYTE *)(v48 - 10), *(_BYTE *)(v49 - 10) != *(_BYTE *)(v48 - 10))
          && (v83 = v82 < 0, LOBYTE(v83) = v82 > 0, (v8 = 2 * v83 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 9) - *(_BYTE *)(v48 - 9);
        if ( *(_BYTE *)(v49 - 9) != *(_BYTE *)(v48 - 9) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        goto LABEL_152;
      return v8;
    case 8u:
LABEL_152:
      v84 = *(_DWORD *)(v49 - 8);
      if ( v84 == *(_DWORD *)(v48 - 8) )
      {
        v8 = 0;
      }
      else
      {
        v85 = (unsigned __int8)v84 - *(_BYTE *)(v48 - 8);
        if ( (unsigned __int8)v84 != *(_BYTE *)(v48 - 8)
          && (v86 = v85 < 0, LOBYTE(v86) = v85 > 0, (v8 = 2 * v86 - 1) != 0)
          || (v87 = *(_BYTE *)(v49 - 7) - *(_BYTE *)(v48 - 7), *(_BYTE *)(v49 - 7) != *(_BYTE *)(v48 - 7))
          && (v88 = v87 < 0, LOBYTE(v88) = v87 > 0, (v8 = 2 * v88 - 1) != 0)
          || (v89 = *(_BYTE *)(v49 - 6) - *(_BYTE *)(v48 - 6), *(_BYTE *)(v49 - 6) != *(_BYTE *)(v48 - 6))
          && (v90 = v89 < 0, LOBYTE(v90) = v89 > 0, (v8 = 2 * v90 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 5) - *(_BYTE *)(v48 - 5);
        if ( *(_BYTE *)(v49 - 5) != *(_BYTE *)(v48 - 5) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        goto LABEL_163;
      return v8;
    case 4u:
LABEL_163:
      v91 = *(_DWORD *)(v49 - 4);
      if ( v91 == *(_DWORD *)(v48 - 4) )
      {
        v8 = 0;
      }
      else
      {
        v92 = (unsigned __int8)v91 - *(_BYTE *)(v48 - 4);
        if ( (unsigned __int8)v91 != *(_BYTE *)(v48 - 4)
          && (v93 = v92 < 0, LOBYTE(v93) = v92 > 0, (v8 = 2 * v93 - 1) != 0)
          || (v94 = *(_BYTE *)(v49 - 3) - *(_BYTE *)(v48 - 3), *(_BYTE *)(v49 - 3) != *(_BYTE *)(v48 - 3))
          && (v95 = v94 < 0, LOBYTE(v95) = v94 > 0, (v8 = 2 * v95 - 1) != 0)
          || (v96 = *(_BYTE *)(v49 - 2) - *(_BYTE *)(v48 - 2), *(_BYTE *)(v49 - 2) != *(_BYTE *)(v48 - 2))
          && (v97 = v96 < 0, LOBYTE(v97) = v96 > 0, (v8 = 2 * v97 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 1) - *(_BYTE *)(v48 - 1);
        if ( *(_BYTE *)(v49 - 1) != *(_BYTE *)(v48 - 1) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
        return 0;
      return v8;
    default:
      return 0;
    case 0x1Du:
      v99 = *(_DWORD *)(v49 - 29);
      if ( v99 == *(_DWORD *)(v48 - 29) )
      {
        v8 = 0;
      }
      else
      {
        v100 = (unsigned __int8)v99 - *(_BYTE *)(v48 - 29);
        if ( (unsigned __int8)v99 != *(_BYTE *)(v48 - 29)
          && (v101 = v100 < 0, LOBYTE(v101) = v100 > 0, (v8 = 2 * v101 - 1) != 0)
          || (v102 = *(_BYTE *)(v49 - 28) - *(_BYTE *)(v48 - 28), *(_BYTE *)(v49 - 28) != *(_BYTE *)(v48 - 28))
          && (v103 = v102 < 0, LOBYTE(v103) = v102 > 0, (v8 = 2 * v103 - 1) != 0)
          || (v104 = *(_BYTE *)(v49 - 27) - *(_BYTE *)(v48 - 27), *(_BYTE *)(v49 - 27) != *(_BYTE *)(v48 - 27))
          && (v105 = v104 < 0, LOBYTE(v105) = v104 > 0, (v8 = 2 * v105 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 26) - *(_BYTE *)(v48 - 26);
        if ( *(_BYTE *)(v49 - 26) != *(_BYTE *)(v48 - 26) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_187:
      v106 = *(_DWORD *)(v49 - 25);
      if ( v106 == *(_DWORD *)(v48 - 25) )
      {
        v8 = 0;
      }
      else
      {
        v107 = (unsigned __int8)v106 - *(_BYTE *)(v48 - 25);
        if ( (unsigned __int8)v106 != *(_BYTE *)(v48 - 25)
          && (v108 = v107 < 0, LOBYTE(v108) = v107 > 0, (v8 = 2 * v108 - 1) != 0)
          || (v109 = *(_BYTE *)(v49 - 24) - *(_BYTE *)(v48 - 24), *(_BYTE *)(v49 - 24) != *(_BYTE *)(v48 - 24))
          && (v110 = v109 < 0, LOBYTE(v110) = v109 > 0, (v8 = 2 * v110 - 1) != 0)
          || (v111 = *(_BYTE *)(v49 - 23) - *(_BYTE *)(v48 - 23), *(_BYTE *)(v49 - 23) != *(_BYTE *)(v48 - 23))
          && (v112 = v111 < 0, LOBYTE(v112) = v111 > 0, (v8 = 2 * v112 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 22) - *(_BYTE *)(v48 - 22);
        if ( *(_BYTE *)(v49 - 22) != *(_BYTE *)(v48 - 22) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_198:
      v113 = *(_DWORD *)(v49 - 21);
      if ( v113 == *(_DWORD *)(v48 - 21) )
      {
        v8 = 0;
      }
      else
      {
        v114 = (unsigned __int8)v113 - *(_BYTE *)(v48 - 21);
        if ( (unsigned __int8)v113 != *(_BYTE *)(v48 - 21)
          && (v115 = v114 < 0, LOBYTE(v115) = v114 > 0, (v8 = 2 * v115 - 1) != 0)
          || (v116 = *(_BYTE *)(v49 - 20) - *(_BYTE *)(v48 - 20), *(_BYTE *)(v49 - 20) != *(_BYTE *)(v48 - 20))
          && (v117 = v116 < 0, LOBYTE(v117) = v116 > 0, (v8 = 2 * v117 - 1) != 0)
          || (v118 = *(_BYTE *)(v49 - 19) - *(_BYTE *)(v48 - 19), *(_BYTE *)(v49 - 19) != *(_BYTE *)(v48 - 19))
          && (v119 = v118 < 0, LOBYTE(v119) = v118 > 0, (v8 = 2 * v119 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 18) - *(_BYTE *)(v48 - 18);
        if ( *(_BYTE *)(v49 - 18) != *(_BYTE *)(v48 - 18) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_209:
      v120 = *(_DWORD *)(v49 - 17);
      if ( v120 == *(_DWORD *)(v48 - 17) )
      {
        v8 = 0;
      }
      else
      {
        v121 = (unsigned __int8)v120 - *(_BYTE *)(v48 - 17);
        if ( (unsigned __int8)v120 != *(_BYTE *)(v48 - 17)
          && (v122 = v121 < 0, LOBYTE(v122) = v121 > 0, (v8 = 2 * v122 - 1) != 0)
          || (v123 = *(_BYTE *)(v49 - 16) - *(_BYTE *)(v48 - 16), *(_BYTE *)(v49 - 16) != *(_BYTE *)(v48 - 16))
          && (v124 = v123 < 0, LOBYTE(v124) = v123 > 0, (v8 = 2 * v124 - 1) != 0)
          || (v125 = *(_BYTE *)(v49 - 15) - *(_BYTE *)(v48 - 15), *(_BYTE *)(v49 - 15) != *(_BYTE *)(v48 - 15))
          && (v126 = v125 < 0, LOBYTE(v126) = v125 > 0, (v8 = 2 * v126 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 14) - *(_BYTE *)(v48 - 14);
        if ( *(_BYTE *)(v49 - 14) != *(_BYTE *)(v48 - 14) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_220:
      v127 = *(_DWORD *)(v49 - 13);
      if ( v127 == *(_DWORD *)(v48 - 13) )
      {
        v8 = 0;
      }
      else
      {
        v128 = (unsigned __int8)v127 - *(_BYTE *)(v48 - 13);
        if ( (unsigned __int8)v127 != *(_BYTE *)(v48 - 13)
          && (v129 = v128 < 0, LOBYTE(v129) = v128 > 0, (v8 = 2 * v129 - 1) != 0)
          || (v130 = *(_BYTE *)(v49 - 12) - *(_BYTE *)(v48 - 12), *(_BYTE *)(v49 - 12) != *(_BYTE *)(v48 - 12))
          && (v131 = v130 < 0, LOBYTE(v131) = v130 > 0, (v8 = 2 * v131 - 1) != 0)
          || (v132 = *(_BYTE *)(v49 - 11) - *(_BYTE *)(v48 - 11), *(_BYTE *)(v49 - 11) != *(_BYTE *)(v48 - 11))
          && (v133 = v132 < 0, LOBYTE(v133) = v132 > 0, (v8 = 2 * v133 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 10) - *(_BYTE *)(v48 - 10);
        if ( *(_BYTE *)(v49 - 10) != *(_BYTE *)(v48 - 10) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_231:
      if ( *(_DWORD *)(v49 - 9) == *(_DWORD *)(v48 - 9) )
      {
        v8 = 0;
      }
      else
      {
        v134 = *(_BYTE *)(v49 - 9) - *(_BYTE *)(v48 - 9);
        if ( *(_BYTE *)(v49 - 9) != *(_BYTE *)(v48 - 9)
          && (v135 = v134 < 0, LOBYTE(v135) = v134 > 0, (v8 = 2 * v135 - 1) != 0)
          || (v136 = *(_BYTE *)(v49 - 8) - *(_BYTE *)(v48 - 8), *(_BYTE *)(v49 - 8) != *(_BYTE *)(v48 - 8))
          && (v137 = v136 < 0, LOBYTE(v137) = v136 > 0, (v8 = 2 * v137 - 1) != 0)
          || (v138 = *(_BYTE *)(v49 - 7) - *(_BYTE *)(v48 - 7), *(_BYTE *)(v49 - 7) != *(_BYTE *)(v48 - 7))
          && (v139 = v138 < 0, LOBYTE(v139) = v138 > 0, (v8 = 2 * v139 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 6) - *(_BYTE *)(v48 - 6);
        if ( *(_BYTE *)(v49 - 6) != *(_BYTE *)(v48 - 6) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_242:
      v140 = *(_DWORD *)(v49 - 5);
      if ( v140 == *(_DWORD *)(v48 - 5) )
      {
        v8 = 0;
        goto LABEL_252;
      }
      v141 = (unsigned __int8)v140 - *(_BYTE *)(v48 - 5);
      if ( (unsigned __int8)v140 == *(_BYTE *)(v48 - 5)
        || (v142 = v141 < 0, LOBYTE(v142) = v141 > 0, v8 = 2 * v142 - 1, !v8) )
      {
        v143 = *(_BYTE *)(v49 - 4) - *(_BYTE *)(v48 - 4);
        if ( *(_BYTE *)(v49 - 4) == *(_BYTE *)(v48 - 4)
          || (v144 = v143 < 0, LOBYTE(v144) = v143 > 0, v8 = 2 * v144 - 1, !v8) )
        {
          v145 = *(_BYTE *)(v49 - 3) - *(_BYTE *)(v48 - 3);
          if ( *(_BYTE *)(v49 - 3) == *(_BYTE *)(v48 - 3)
            || (v146 = v145 < 0, LOBYTE(v146) = v145 > 0, v8 = 2 * v146 - 1, !v8) )
          {
            v8 = *(_BYTE *)(v49 - 2) - *(_BYTE *)(v48 - 2);
            if ( *(_BYTE *)(v49 - 2) != *(_BYTE *)(v48 - 2) )
              v8 = 2 * (v8 > 0) - 1;
            goto LABEL_252;
          }
        }
      }
      return v8;
    case 0x19u:
      goto LABEL_187;
    case 0x15u:
      goto LABEL_198;
    case 0x11u:
      goto LABEL_209;
    case 0xDu:
      goto LABEL_220;
    case 9u:
      goto LABEL_231;
    case 5u:
      goto LABEL_242;
    case 1u:
      goto LABEL_253;
    case 0x1Eu:
      v147 = *(_DWORD *)(v49 - 30);
      if ( v147 == *(_DWORD *)(v48 - 30) )
      {
        v8 = 0;
      }
      else
      {
        v148 = (unsigned __int8)v147 - *(_BYTE *)(v48 - 30);
        if ( (unsigned __int8)v147 != *(_BYTE *)(v48 - 30)
          && (v149 = v148 < 0, LOBYTE(v149) = v148 > 0, (v8 = 2 * v149 - 1) != 0)
          || (v150 = *(_BYTE *)(v49 - 29) - *(_BYTE *)(v48 - 29), *(_BYTE *)(v49 - 29) != *(_BYTE *)(v48 - 29))
          && (v151 = v150 < 0, LOBYTE(v151) = v150 > 0, (v8 = 2 * v151 - 1) != 0)
          || (v152 = *(_BYTE *)(v49 - 28) - *(_BYTE *)(v48 - 28), *(_BYTE *)(v49 - 28) != *(_BYTE *)(v48 - 28))
          && (v153 = v152 < 0, LOBYTE(v153) = v152 > 0, (v8 = 2 * v153 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 27) - *(_BYTE *)(v48 - 27);
        if ( *(_BYTE *)(v49 - 27) != *(_BYTE *)(v48 - 27) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_266:
      v154 = *(_DWORD *)(v49 - 26);
      if ( v154 == *(_DWORD *)(v48 - 26) )
      {
        v8 = 0;
      }
      else
      {
        v155 = (unsigned __int8)v154 - *(_BYTE *)(v48 - 26);
        if ( (unsigned __int8)v154 != *(_BYTE *)(v48 - 26)
          && (v156 = v155 < 0, LOBYTE(v156) = v155 > 0, (v8 = 2 * v156 - 1) != 0)
          || (v157 = *(_BYTE *)(v49 - 25) - *(_BYTE *)(v48 - 25), *(_BYTE *)(v49 - 25) != *(_BYTE *)(v48 - 25))
          && (v158 = v157 < 0, LOBYTE(v158) = v157 > 0, (v8 = 2 * v158 - 1) != 0)
          || (v159 = *(_BYTE *)(v49 - 24) - *(_BYTE *)(v48 - 24), *(_BYTE *)(v49 - 24) != *(_BYTE *)(v48 - 24))
          && (v160 = v159 < 0, LOBYTE(v160) = v159 > 0, (v8 = 2 * v160 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 23) - *(_BYTE *)(v48 - 23);
        if ( *(_BYTE *)(v49 - 23) != *(_BYTE *)(v48 - 23) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_277:
      v161 = *(_DWORD *)(v49 - 22);
      if ( v161 == *(_DWORD *)(v48 - 22) )
      {
        v8 = 0;
      }
      else
      {
        v162 = (unsigned __int8)v161 - *(_BYTE *)(v48 - 22);
        if ( (unsigned __int8)v161 != *(_BYTE *)(v48 - 22)
          && (v163 = v162 < 0, LOBYTE(v163) = v162 > 0, (v8 = 2 * v163 - 1) != 0)
          || (v164 = *(_BYTE *)(v49 - 21) - *(_BYTE *)(v48 - 21), *(_BYTE *)(v49 - 21) != *(_BYTE *)(v48 - 21))
          && (v165 = v164 < 0, LOBYTE(v165) = v164 > 0, (v8 = 2 * v165 - 1) != 0)
          || (v166 = *(_BYTE *)(v49 - 20) - *(_BYTE *)(v48 - 20), *(_BYTE *)(v49 - 20) != *(_BYTE *)(v48 - 20))
          && (v167 = v166 < 0, LOBYTE(v167) = v166 > 0, (v8 = 2 * v167 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 19) - *(_BYTE *)(v48 - 19);
        if ( *(_BYTE *)(v49 - 19) != *(_BYTE *)(v48 - 19) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_288:
      v168 = *(_DWORD *)(v49 - 18);
      if ( v168 == *(_DWORD *)(v48 - 18) )
      {
        v8 = 0;
      }
      else
      {
        v169 = (unsigned __int8)v168 - *(_BYTE *)(v48 - 18);
        if ( (unsigned __int8)v168 != *(_BYTE *)(v48 - 18)
          && (v170 = v169 < 0, LOBYTE(v170) = v169 > 0, (v8 = 2 * v170 - 1) != 0)
          || (v171 = *(_BYTE *)(v49 - 17) - *(_BYTE *)(v48 - 17), *(_BYTE *)(v49 - 17) != *(_BYTE *)(v48 - 17))
          && (v172 = v171 < 0, LOBYTE(v172) = v171 > 0, (v8 = 2 * v172 - 1) != 0)
          || (v173 = *(_BYTE *)(v49 - 16) - *(_BYTE *)(v48 - 16), *(_BYTE *)(v49 - 16) != *(_BYTE *)(v48 - 16))
          && (v174 = v173 < 0, LOBYTE(v174) = v173 > 0, (v8 = 2 * v174 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 15) - *(_BYTE *)(v48 - 15);
        if ( *(_BYTE *)(v49 - 15) != *(_BYTE *)(v48 - 15) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_299:
      v175 = *(_DWORD *)(v49 - 14);
      if ( v175 == *(_DWORD *)(v48 - 14) )
      {
        v8 = 0;
      }
      else
      {
        v176 = (unsigned __int8)v175 - *(_BYTE *)(v48 - 14);
        if ( (unsigned __int8)v175 != *(_BYTE *)(v48 - 14)
          && (v177 = v176 < 0, LOBYTE(v177) = v176 > 0, (v8 = 2 * v177 - 1) != 0)
          || (v178 = *(_BYTE *)(v49 - 13) - *(_BYTE *)(v48 - 13), *(_BYTE *)(v49 - 13) != *(_BYTE *)(v48 - 13))
          && (v179 = v178 < 0, LOBYTE(v179) = v178 > 0, (v8 = 2 * v179 - 1) != 0)
          || (v180 = *(_BYTE *)(v49 - 12) - *(_BYTE *)(v48 - 12), *(_BYTE *)(v49 - 12) != *(_BYTE *)(v48 - 12))
          && (v181 = v180 < 0, LOBYTE(v181) = v180 > 0, (v8 = 2 * v181 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 11) - *(_BYTE *)(v48 - 11);
        if ( *(_BYTE *)(v49 - 11) != *(_BYTE *)(v48 - 11) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_310:
      if ( *(_DWORD *)(v49 - 10) == *(_DWORD *)(v48 - 10) )
      {
        v8 = 0;
      }
      else
      {
        v182 = *(_BYTE *)(v49 - 10) - *(_BYTE *)(v48 - 10);
        if ( *(_BYTE *)(v49 - 10) != *(_BYTE *)(v48 - 10)
          && (v183 = v182 < 0, LOBYTE(v183) = v182 > 0, (v8 = 2 * v183 - 1) != 0)
          || (v184 = *(_BYTE *)(v49 - 9) - *(_BYTE *)(v48 - 9), *(_BYTE *)(v49 - 9) != *(_BYTE *)(v48 - 9))
          && (v185 = v184 < 0, LOBYTE(v185) = v184 > 0, (v8 = 2 * v185 - 1) != 0)
          || (v186 = *(_BYTE *)(v49 - 8) - *(_BYTE *)(v48 - 8), *(_BYTE *)(v49 - 8) != *(_BYTE *)(v48 - 8))
          && (v187 = v186 < 0, LOBYTE(v187) = v186 > 0, (v8 = 2 * v187 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 7) - *(_BYTE *)(v48 - 7);
        if ( *(_BYTE *)(v49 - 7) != *(_BYTE *)(v48 - 7) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_321:
      v188 = *(_DWORD *)(v49 - 6);
      if ( v188 == *(_DWORD *)(v48 - 6) )
      {
        v8 = 0;
      }
      else
      {
        v189 = (unsigned __int8)v188 - *(_BYTE *)(v48 - 6);
        if ( (unsigned __int8)v188 != *(_BYTE *)(v48 - 6)
          && (v190 = v189 < 0, LOBYTE(v190) = v189 > 0, (v8 = 2 * v190 - 1) != 0)
          || (v191 = *(_BYTE *)(v49 - 5) - *(_BYTE *)(v48 - 5), *(_BYTE *)(v49 - 5) != *(_BYTE *)(v48 - 5))
          && (v192 = v191 < 0, LOBYTE(v192) = v191 > 0, (v8 = 2 * v192 - 1) != 0)
          || (v193 = *(_BYTE *)(v49 - 4) - *(_BYTE *)(v48 - 4), *(_BYTE *)(v49 - 4) != *(_BYTE *)(v48 - 4))
          && (v194 = v193 < 0, LOBYTE(v194) = v193 > 0, (v8 = 2 * v194 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 3) - *(_BYTE *)(v48 - 3);
        if ( *(_BYTE *)(v49 - 3) != *(_BYTE *)(v48 - 3) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_332:
      if ( *(_WORD *)(v49 - 2) == *(_WORD *)(v48 - 2) )
        return 0;
      goto LABEL_413;
    case 0x1Au:
      goto LABEL_266;
    case 0x16u:
      goto LABEL_277;
    case 0x12u:
      goto LABEL_288;
    case 0xEu:
      goto LABEL_299;
    case 0xAu:
      goto LABEL_310;
    case 6u:
      goto LABEL_321;
    case 2u:
      goto LABEL_332;
    case 0x1Fu:
      v195 = *(_DWORD *)(v49 - 31);
      if ( v195 == *(_DWORD *)(v48 - 31) )
      {
        v8 = 0;
      }
      else
      {
        v196 = (unsigned __int8)v195 - *(_BYTE *)(v48 - 31);
        if ( (unsigned __int8)v195 != *(_BYTE *)(v48 - 31)
          && (v197 = v196 < 0, LOBYTE(v197) = v196 > 0, (v8 = 2 * v197 - 1) != 0)
          || (v198 = *(_BYTE *)(v49 - 30) - *(_BYTE *)(v48 - 30), *(_BYTE *)(v49 - 30) != *(_BYTE *)(v48 - 30))
          && (v199 = v198 < 0, LOBYTE(v199) = v198 > 0, (v8 = 2 * v199 - 1) != 0)
          || (v200 = *(_BYTE *)(v49 - 29) - *(_BYTE *)(v48 - 29), *(_BYTE *)(v49 - 29) != *(_BYTE *)(v48 - 29))
          && (v201 = v200 < 0, LOBYTE(v201) = v200 > 0, (v8 = 2 * v201 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 28) - *(_BYTE *)(v48 - 28);
        if ( *(_BYTE *)(v49 - 28) != *(_BYTE *)(v48 - 28) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_345:
      v202 = *(_DWORD *)(v49 - 27);
      if ( v202 == *(_DWORD *)(v48 - 27) )
      {
        v8 = 0;
      }
      else
      {
        v203 = (unsigned __int8)v202 - *(_BYTE *)(v48 - 27);
        if ( (unsigned __int8)v202 != *(_BYTE *)(v48 - 27)
          && (v204 = v203 < 0, LOBYTE(v204) = v203 > 0, (v8 = 2 * v204 - 1) != 0)
          || (v205 = *(_BYTE *)(v49 - 26) - *(_BYTE *)(v48 - 26), *(_BYTE *)(v49 - 26) != *(_BYTE *)(v48 - 26))
          && (v206 = v205 < 0, LOBYTE(v206) = v205 > 0, (v8 = 2 * v206 - 1) != 0)
          || (v207 = *(_BYTE *)(v49 - 25) - *(_BYTE *)(v48 - 25), *(_BYTE *)(v49 - 25) != *(_BYTE *)(v48 - 25))
          && (v208 = v207 < 0, LOBYTE(v208) = v207 > 0, (v8 = 2 * v208 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 24) - *(_BYTE *)(v48 - 24);
        if ( *(_BYTE *)(v49 - 24) != *(_BYTE *)(v48 - 24) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_356:
      v209 = *(_DWORD *)(v49 - 23);
      if ( v209 == *(_DWORD *)(v48 - 23) )
      {
        v8 = 0;
      }
      else
      {
        v210 = (unsigned __int8)v209 - *(_BYTE *)(v48 - 23);
        if ( (unsigned __int8)v209 != *(_BYTE *)(v48 - 23)
          && (v211 = v210 < 0, LOBYTE(v211) = v210 > 0, (v8 = 2 * v211 - 1) != 0)
          || (v212 = *(_BYTE *)(v49 - 22) - *(_BYTE *)(v48 - 22), *(_BYTE *)(v49 - 22) != *(_BYTE *)(v48 - 22))
          && (v213 = v212 < 0, LOBYTE(v213) = v212 > 0, (v8 = 2 * v213 - 1) != 0)
          || (v214 = *(_BYTE *)(v49 - 21) - *(_BYTE *)(v48 - 21), *(_BYTE *)(v49 - 21) != *(_BYTE *)(v48 - 21))
          && (v215 = v214 < 0, LOBYTE(v215) = v214 > 0, (v8 = 2 * v215 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 20) - *(_BYTE *)(v48 - 20);
        if ( *(_BYTE *)(v49 - 20) != *(_BYTE *)(v48 - 20) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_367:
      v216 = *(_DWORD *)(v49 - 19);
      if ( v216 == *(_DWORD *)(v48 - 19) )
      {
        v8 = 0;
      }
      else
      {
        v217 = (unsigned __int8)v216 - *(_BYTE *)(v48 - 19);
        if ( (unsigned __int8)v216 != *(_BYTE *)(v48 - 19)
          && (v218 = v217 < 0, LOBYTE(v218) = v217 > 0, (v8 = 2 * v218 - 1) != 0)
          || (v219 = *(_BYTE *)(v49 - 18) - *(_BYTE *)(v48 - 18), *(_BYTE *)(v49 - 18) != *(_BYTE *)(v48 - 18))
          && (v220 = v219 < 0, LOBYTE(v220) = v219 > 0, (v8 = 2 * v220 - 1) != 0)
          || (v221 = *(_BYTE *)(v49 - 17) - *(_BYTE *)(v48 - 17), *(_BYTE *)(v49 - 17) != *(_BYTE *)(v48 - 17))
          && (v222 = v221 < 0, LOBYTE(v222) = v221 > 0, (v8 = 2 * v222 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 16) - *(_BYTE *)(v48 - 16);
        if ( *(_BYTE *)(v49 - 16) != *(_BYTE *)(v48 - 16) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_378:
      if ( *(_DWORD *)(v49 - 15) == *(_DWORD *)(v48 - 15) )
      {
        v8 = 0;
      }
      else
      {
        v223 = *(_BYTE *)(v49 - 15) - *(_BYTE *)(v48 - 15);
        if ( *(_BYTE *)(v49 - 15) != *(_BYTE *)(v48 - 15)
          && (v224 = v223 < 0, LOBYTE(v224) = v223 > 0, (v8 = 2 * v224 - 1) != 0)
          || (v225 = *(_BYTE *)(v49 - 14) - *(_BYTE *)(v48 - 14), *(_BYTE *)(v49 - 14) != *(_BYTE *)(v48 - 14))
          && (v226 = v225 < 0, LOBYTE(v226) = v225 > 0, (v8 = 2 * v226 - 1) != 0)
          || (v227 = *(_BYTE *)(v49 - 13) - *(_BYTE *)(v48 - 13), *(_BYTE *)(v49 - 13) != *(_BYTE *)(v48 - 13))
          && (v228 = v227 < 0, LOBYTE(v228) = v227 > 0, (v8 = 2 * v228 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 12) - *(_BYTE *)(v48 - 12);
        if ( *(_BYTE *)(v49 - 12) != *(_BYTE *)(v48 - 12) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_389:
      v229 = *(_DWORD *)(v49 - 11);
      if ( v229 == *(_DWORD *)(v48 - 11) )
      {
        v8 = 0;
      }
      else
      {
        v230 = (unsigned __int8)v229 - *(_BYTE *)(v48 - 11);
        if ( (unsigned __int8)v229 != *(_BYTE *)(v48 - 11)
          && (v231 = v230 < 0, LOBYTE(v231) = v230 > 0, (v8 = 2 * v231 - 1) != 0)
          || (v232 = *(_BYTE *)(v49 - 10) - *(_BYTE *)(v48 - 10), *(_BYTE *)(v49 - 10) != *(_BYTE *)(v48 - 10))
          && (v233 = v232 < 0, LOBYTE(v233) = v232 > 0, (v8 = 2 * v233 - 1) != 0)
          || (v234 = *(_BYTE *)(v49 - 9) - *(_BYTE *)(v48 - 9), *(_BYTE *)(v49 - 9) != *(_BYTE *)(v48 - 9))
          && (v235 = v234 < 0, LOBYTE(v235) = v234 > 0, (v8 = 2 * v235 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 8) - *(_BYTE *)(v48 - 8);
        if ( *(_BYTE *)(v49 - 8) != *(_BYTE *)(v48 - 8) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( v8 )
        return v8;
LABEL_400:
      v236 = *(_DWORD *)(v49 - 7);
      if ( v236 == *(_DWORD *)(v48 - 7) )
      {
        v8 = 0;
      }
      else
      {
        v237 = (unsigned __int8)v236 - *(_BYTE *)(v48 - 7);
        if ( (unsigned __int8)v236 != *(_BYTE *)(v48 - 7)
          && (v238 = v237 < 0, LOBYTE(v238) = v237 > 0, (v8 = 2 * v238 - 1) != 0)
          || (v239 = *(_BYTE *)(v49 - 6) - *(_BYTE *)(v48 - 6), *(_BYTE *)(v49 - 6) != *(_BYTE *)(v48 - 6))
          && (v240 = v239 < 0, LOBYTE(v240) = v239 > 0, (v8 = 2 * v240 - 1) != 0)
          || (v241 = *(_BYTE *)(v49 - 5) - *(_BYTE *)(v48 - 5), *(_BYTE *)(v49 - 5) != *(_BYTE *)(v48 - 5))
          && (v242 = v241 < 0, LOBYTE(v242) = v241 > 0, (v8 = 2 * v242 - 1) != 0) )
          return v8;
        v8 = *(_BYTE *)(v49 - 4) - *(_BYTE *)(v48 - 4);
        if ( *(_BYTE *)(v49 - 4) != *(_BYTE *)(v48 - 4) )
          v8 = 2 * (v8 > 0) - 1;
      }
      if ( !v8 )
      {
LABEL_411:
        v243 = *(_BYTE *)(v49 - 3) - *(_BYTE *)(v48 - 3);
        if ( *(_BYTE *)(v49 - 3) == *(_BYTE *)(v48 - 3)
          || (v244 = v243 < 0, LOBYTE(v244) = v243 > 0, v8 = 2 * v244 - 1, !v8) )
        {
LABEL_413:
          v245 = *(_BYTE *)(v49 - 2) - *(_BYTE *)(v48 - 2);
          if ( *(_BYTE *)(v49 - 2) == *(_BYTE *)(v48 - 2) )
            goto LABEL_253;
          v246 = v245 < 0;
          LOBYTE(v246) = v245 > 0;
          v8 = 2 * v246 - 1;
LABEL_252:
          if ( !v8 )
          {
LABEL_253:
            v8 = *(_BYTE *)(v49 - 1) - *(_BYTE *)(v48 - 1);
            if ( *(_BYTE *)(v49 - 1) != *(_BYTE *)(v48 - 1) )
              v8 = 2 * (v8 > 0) - 1;
          }
        }
      }
      break;
    case 0x1Bu:
      goto LABEL_345;
    case 0x17u:
      goto LABEL_356;
    case 0x13u:
      goto LABEL_367;
    case 0xFu:
      goto LABEL_378;
    case 0xBu:
      goto LABEL_389;
    case 7u:
      goto LABEL_400;
    case 3u:
      goto LABEL_411;
  }
  return v8;
}

//----- (10038E81) --------------------------------------------------------
int __cdecl sub_10038E81(int a1, int a2, DWORD dwCmpFlags, int a4, int a5, int a6, int a7, UINT CodePage)
{
  int v8; // ecx@1
  int v9; // esi@1
  int v10; // eax@2
  signed int v11; // edi@3
  UINT v13; // eax@8
  int v14; // ebx@8
  char *v15; // eax@22
  unsigned __int8 v16; // cl@23
  char *v17; // eax@30
  unsigned __int8 v18; // cl@31
  unsigned int v19; // eax@36
  int v20; // ecx@36
  int v21; // ecx@39
  int v22; // eax@42
  int v23; // eax@48
  int v24; // ecx@48
  int v25; // ecx@51
  int v26; // esi@52
  int v27; // eax@54
  char v29; // [sp+0h] [bp-38h]@40
  int v30; // [sp+Ch] [bp-2Ch]@1
  int v31; // [sp+10h] [bp-28h]@8
  const CHAR *v32; // [sp+14h] [bp-24h]@1
  int cchCount1; // [sp+18h] [bp-20h]@1
  LPCSTR cchWideChar; // [sp+1Ch] [bp-1Ch]@1
  struct _cpinfo CPInfo; // [sp+20h] [bp-18h]@19
  unsigned int v36; // [sp+34h] [bp-4h]@1
  int v37; // [sp+38h] [bp+0h]@1

  v36 = (unsigned int)&v37 ^ __security_cookie;
  v8 = a6;
  cchCount1 = a1;
  v9 = a5;
  v30 = a2;
  cchWideChar = (LPCSTR)a4;
  v32 = (const CHAR *)a6;
  if ( a5 <= 0 )
  {
    if ( a5 < -1 )
      return 0;
  }
  else
  {
    v10 = sub_100390EC(a4, a5);
    v8 = (int)v32;
    v9 = v10;
  }
  v11 = a7;
  if ( a7 <= 0 )
  {
    if ( a7 < -1 )
      return 0;
  }
  else
  {
    v11 = sub_100390EC(v8, a7);
  }
  v13 = CodePage;
  v14 = 0;
  v31 = 0;
  if ( !CodePage )
  {
    v13 = *(_DWORD *)(*(_DWORD *)cchCount1 + 4);
    CodePage = *(_DWORD *)(*(_DWORD *)cchCount1 + 4);
  }
  if ( v9 && v11 )
    goto LABEL_36;
  if ( v9 == v11 )
    return 2;
  if ( v11 > 1 )
    return 1;
  if ( v9 > 1 )
    return 3;
  if ( !GetCPInfo(v13, &CPInfo) )
    return 0;
  if ( v9 > 0 )
  {
    if ( (_DWORD)CPInfo.MaxCharSize >= 2u )
    {
      v15 = (char *)CPInfo.LeadByte;
      if ( CPInfo.LeadByte[0] )
      {
        while ( 1 )
        {
          v16 = v15[1];
          if ( !v16 )
            break;
          if ( *cchWideChar >= (unsigned __int8)*v15 && *cchWideChar <= v16 )
            return 2;
          v15 += 2;
          if ( !*v15 )
            return 3;
        }
      }
    }
    return 3;
  }
  if ( v11 > 0 )
  {
    if ( (_DWORD)CPInfo.MaxCharSize >= 2u )
    {
      v17 = (char *)CPInfo.LeadByte;
      if ( CPInfo.LeadByte[0] )
      {
        do
        {
          v18 = v17[1];
          if ( !v18 )
            break;
          if ( *v32 >= (unsigned __int8)*v17 && *v32 <= v18 )
            return 2;
          v17 += 2;
        }
        while ( *v17 );
      }
    }
    return 1;
  }
LABEL_36:
  v19 = MultiByteToWideChar(CodePage, 9u, cchWideChar, v9, 0, 0);
  v20 = v19;
  cchCount1 = v19;
  if ( !v19 )
    return 0;
  if ( (signed int)v19 > 0 && 0xFFFFFFE0 / v19 >= 2 )
  {
    v21 = 2 * v19 + 8;
    if ( (unsigned int)v21 > 0x400 )
    {
      v22 = sub_10030930(0xFFFFFFE0 % v19, v21, 0, v11, v21);
      v14 = v22;
      if ( v22 )
      {
        *(_DWORD *)v22 = 56797;
        goto LABEL_44;
      }
    }
    else
    {
      sub_1003F580(v21, v21, v29);
      v14 = (int)&v29;
      if ( &v29 )
      {
        *(_DWORD *)&v29 = 52428;
LABEL_44:
        v14 += 8;
        goto LABEL_45;
      }
    }
LABEL_45:
    v20 = cchCount1;
  }
  if ( !v14 )
    return 0;
  if ( !MultiByteToWideChar(CodePage, 1u, cchWideChar, v9, (LPWSTR)v14, v20)
    || (v23 = MultiByteToWideChar(CodePage, 9u, v32, v11, 0, 0), v24 = v23, cchWideChar = (LPCSTR)v23, !v23) )
    goto LABEL_63;
  if ( v23 > 0 && 0xFFFFFFE0u / v23 >= 2 )
  {
    v25 = 2 * v23 + 8;
    if ( (unsigned int)v25 > 0x400 )
    {
      v27 = sub_10030930(0xFFFFFFE0u % v23, v25, v14, v11, v25);
      v26 = v27;
      if ( v27 )
      {
        *(_DWORD *)v27 = 56797;
        goto LABEL_56;
      }
    }
    else
    {
      sub_1003F580(v25, v25, v29);
      v26 = (int)&v29;
      if ( &v29 )
      {
        *(_DWORD *)&v29 = 52428;
LABEL_56:
        v26 += 8;
        goto LABEL_57;
      }
    }
LABEL_57:
    v24 = (int)cchWideChar;
    goto LABEL_59;
  }
  v26 = 0;
LABEL_59:
  if ( v26 )
  {
    if ( MultiByteToWideChar(CodePage, 1u, v32, v11, (LPWSTR)v26, v24) )
      v31 = sub_10039B4B(v30, dwCmpFlags, (PCNZWCH)v14, cchCount1, (PCNZWCH)v26, (int)cchWideChar);
    sub_1002CAA4(v14, v26);
  }
LABEL_63:
  sub_1002CAA4(v14, v14);
  return v31;
}
// 10073200: using guessed type int __security_cookie;

//----- (100390EC) --------------------------------------------------------
int __cdecl sub_100390EC(int a1, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1

  v2 = a1;
  v3 = a2;
  if ( a2 )
  {
    while ( 1 )
    {
      --v3;
      if ( !*(_BYTE *)v2 )
        break;
      ++v2;
      if ( !v3 )
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    --v3;
  }
  return a2 - v3 - 1;
}

//----- (1003910C) --------------------------------------------------------
int __usercall sub_1003910C<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, DWORD dwCmpFlags, int a6, int a7, int a8, int a9, UINT CodePage)
{
  int result; // eax@1
  int v11; // [sp+0h] [bp-10h]@1
  int v12; // [sp+8h] [bp-8h]@2
  char v13; // [sp+Ch] [bp-4h]@1

  sub_100301AD((int)&v11, a1, a2, a3);
  result = sub_10038E81((int)&v11, a4, dwCmpFlags, a6, a7, a8, a9, CodePage);
  if ( v13 )
    *(_DWORD *)(v12 + 112) &= 0xFFFFFFFDu;
  return result;
}

//----- (10039150) --------------------------------------------------------
int __stdcall sub_10039150(unsigned __int64 a1, __int64 a2)
{
  int v2; // esi@2
  unsigned __int64 v3; // qtt@2
  unsigned __int64 v4; // qax@3
  unsigned int v5; // ecx@3
  unsigned int v6; // ebx@3
  char v7; // cf@4
  char v8; // cf@4
  int v9; // eax@5
  unsigned __int64 v10; // qax@5
  int v11; // ecx@5
  char v12; // cf@5

  if ( HIDWORD(a2) )
  {
    v5 = HIDWORD(a2);
    v6 = a2;
    v4 = a1;
    do
    {
      v7 = v5 & 1;
      v5 >>= 1;
      v6 = __RCR__(v6, v7);
      v8 = BYTE4(v4) & 1;
      HIDWORD(v4) >>= 1;
      LODWORD(v4) = __RCR__(v4, v8);
    }
    while ( v5 );
    v9 = v4 / v6;
    v2 = v9;
    v11 = HIDWORD(a2) * v9;
    v10 = v9 * (unsigned int)a2;
    v12 = v11 >= (unsigned int)-HIDWORD(v10);
    HIDWORD(v10) += v11;
    if ( v12 || HIDWORD(v10) > HIDWORD(a1) || v10 > a1 )
      --v2;
  }
  else
  {
    LODWORD(v3) = a1;
    HIDWORD(v3) = HIDWORD(a1) % (_DWORD)a2;
    v2 = v3 / (unsigned int)a2;
  }
  return v2;
}

//----- (100391F0) --------------------------------------------------------
void *__cdecl sub_100391F0(void *a1, unsigned __int8 a2, signed int a3)
{
  signed int v9; // ecx@3
  void *v10; // edi@3
  int v11; // edx@7
  void *v16; // edi@9
  int v17; // ecx@10
  unsigned int v18; // ecx@13
  unsigned int v19; // ecx@13
  void *result; // eax@16
  int v21; // edx@22
  unsigned int k; // ebx@22
  unsigned int v23; // ebx@22
  unsigned int l; // ebx@25
  int v25; // edx@27
  unsigned int m; // edx@28
  char v27; // bl@28
  int n; // ebx@30
  int i; // edx@33
  unsigned int v30; // ebx@33
  unsigned int j; // ebx@35
  int v32; // [sp-Ch] [bp-Ch]@33

  _ECX = a1;
  if ( a3 )
  {
    _EAX = a2;
    __asm { bt      dword_10075780, 1 }
    if ( _CF )
    {
      v9 = a3;
      v10 = a1;
      while ( v9 )
      {
        *(_BYTE *)v10 = _EAX;
        v10 = (char *)v10 + 1;
        --v9;
      }
      return a1;
    }
    v11 = a3;
    if ( a3 < 128 )
      goto LABEL_40;
    __asm { bt      dword_10073238, 1 }
    if ( !_CF )
    {
LABEL_40:
      v16 = a1;
      if ( (unsigned int)a3 < 4 )
        goto LABEL_41;
      v17 = -(signed int)a1 & 3;
      if ( v17 )
      {
        v11 = a3 - v17;
        do
        {
          *(_BYTE *)v16 = _EAX;
          v16 = (char *)v16 + 1;
          --v17;
        }
        while ( v17 );
      }
      _EAX = 16843009 * a2;
      v19 = v11;
      v11 &= 3u;
      v18 = v19 >> 2;
      if ( !v18 || (memset(v16, _EAX, 4 * v18), v16 = (char *)v16 + 4 * v18, v11) )
      {
LABEL_41:
        do
        {
          *(_BYTE *)v16 = _EAX;
          v16 = (char *)v16 + 1;
          --v11;
        }
        while ( v11 );
      }
      return a1;
    }
    if ( a2 )
    {
      __asm
      {
        movd    xmm0, eax
        punpcklbw xmm0, xmm0
        punpcklwd xmm0, xmm0
        pshufd  xmm0, xmm0, 0
      }
    }
    else
    {
      __asm { pxor    xmm0, xmm0 }
    }
    if ( (_BYTE)a1 & 0xF )
    {
      v30 = 16 - ((_BYTE)a1 & 0xF);
      v32 = a3 - v30;
      for ( i = v30 & 3; i; --i )
      {
        *(_BYTE *)_ECX = _EAX;
        _ECX = (char *)_ECX + 1;
      }
      for ( j = v30 >> 2; j; --j )
      {
        __asm { movd    dword ptr [ecx], xmm0 }
        _ECX = (char *)_ECX + 4;
      }
      v11 = v32;
    }
    v23 = v11;
    v21 = v11 & 0x7F;
    for ( k = v23 >> 7; k; --k )
    {
      __asm
      {
        movdqa  xmmword ptr [ecx], xmm0
        movdqa  xmmword ptr [ecx+10h], xmm0
        movdqa  xmmword ptr [ecx+20h], xmm0
        movdqa  xmmword ptr [ecx+30h], xmm0
        movdqa  xmmword ptr [ecx+40h], xmm0
        movdqa  xmmword ptr [ecx+50h], xmm0
        movdqa  xmmword ptr [ecx+60h], xmm0
        movdqa  xmmword ptr [ecx+70h], xmm0
      }
      _ECX = (char *)_ECX + 128;
    }
    if ( v21 )
    {
      for ( l = (unsigned int)v21 >> 4; l; --l )
      {
        __asm { movdqa  xmmword ptr [ecx], xmm0 }
        _ECX = (char *)_ECX + 16;
      }
      v25 = v21 & 0xF;
      if ( v25 )
      {
        v27 = v25;
        for ( m = (unsigned int)v25 >> 2; m; --m )
        {
          __asm { movd    dword ptr [ecx], xmm0 }
          _ECX = (char *)_ECX + 4;
        }
        for ( n = v27 & 3; n; --n )
        {
          *(_BYTE *)_ECX = _EAX;
          _ECX = (char *)_ECX + 1;
        }
      }
    }
    result = a1;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10039280) --------------------------------------------------------
int __cdecl sub_10039280(int a1, int a2)
{
  int result; // eax@1

  result = dword_10073210;
  dword_10073210 = a2 & a1 | dword_10073210 & ~a2;
  return result;
}
// 10073210: using guessed type int dword_10073210;

//----- (100392F0) --------------------------------------------------------
int __cdecl sub_100392F0(int a1, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  unsigned __int8 v4; // cf@2
  unsigned int v5; // eax@2
  unsigned int v6; // eax@6
  __int16 v8; // ax@16

  v2 = a1;
  v3 = a2;
  if ( !(a1 & 3) )
  {
LABEL_2:
    while ( 1 )
    {
      v5 = *(_DWORD *)v2;
      v4 = (unsigned __int8)*(_DWORD *)v2 < *(_BYTE *)v3;
      if ( (unsigned __int8)*(_DWORD *)v2 != *(_BYTE *)v3 )
        break;
      if ( !(_BYTE)v5 )
        return 0;
      v4 = BYTE1(v5) < *(_BYTE *)(v3 + 1);
      if ( BYTE1(v5) != *(_BYTE *)(v3 + 1) )
        break;
      if ( !BYTE1(v5) )
        return 0;
      v6 = v5 >> 16;
      v4 = (_BYTE)v6 < *(_BYTE *)(v3 + 2);
      if ( (_BYTE)v6 != *(_BYTE *)(v3 + 2) )
        break;
      if ( !(_BYTE)v6 )
        return 0;
      v4 = BYTE1(v6) < *(_BYTE *)(v3 + 3);
      if ( BYTE1(v6) != *(_BYTE *)(v3 + 3) )
        break;
      v3 += 4;
      v2 += 4;
      if ( !BYTE1(v6) )
        return 0;
    }
    return -v4 | 1;
  }
  if ( a1 & 1 )
  {
    v2 = a1 + 1;
    v4 = *(_BYTE *)a1 < *(_BYTE *)a2;
    if ( *(_BYTE *)a1 != *(_BYTE *)a2 )
      return -v4 | 1;
    v3 = a2 + 1;
    if ( !*(_BYTE *)a1 )
      return 0;
    if ( !(v2 & 2) )
      goto LABEL_2;
  }
  v8 = *(_WORD *)v2;
  v2 += 2;
  v4 = (_BYTE)v8 < *(_BYTE *)v3;
  if ( (_BYTE)v8 != *(_BYTE *)v3 )
    return -v4 | 1;
  if ( !(_BYTE)v8 )
    return 0;
  v4 = HIBYTE(v8) < *(_BYTE *)(v3 + 1);
  if ( HIBYTE(v8) == *(_BYTE *)(v3 + 1) )
  {
    if ( HIBYTE(v8) )
    {
      v3 += 2;
      goto LABEL_2;
    }
    return 0;
  }
  return -v4 | 1;
}

//----- (1003937C) --------------------------------------------------------
signed int (__usercall *__usercall sub_1003937C<eax>(int a1<ebx>, int a2<edi>, int a3))<eax>(int<edi>, int, int, unsigned int, int, int, int)
{
  signed int (__usercall *result)<eax>(int<edi>, int, int, unsigned int, int, int, int); // eax@1

  result = sub_10039393();
  if ( a3 )
    result = (signed int (__usercall *)<eax>(int<edi>, int, int, unsigned int, int, int, int))sub_1004AAA5(a1, a2);
  __asm { fnclex }
  return result;
}

//----- (10039393) --------------------------------------------------------
signed int (__usercall *__cdecl sub_10039393())<eax>(int<edi>, int, int, unsigned int, int, int, int)
{
  signed int (__usercall *result)<eax>(int<edi>, int, int, unsigned int, int, int, int); // eax@1

  result = sub_1004A019;
  off_100741CC[0] = (int (*)())sub_1004A019;
  off_100741D0[0] = (int (*)())sub_1004A8F9;
  off_100741D4[0] = (int (*)())sub_1004A988;
  off_100741D8[0] = (int (*)())sub_1004A9E0;
  off_100741DC[0] = (int (*)())sub_1004AA63;
  off_100741E0[0] = (int (*)())sub_1004A019;
  off_100741E4 = sub_1004A03A;
  off_100741E8 = sub_1004A9A0;
  off_100741EC = sub_1004A90A;
  off_100741F0 = sub_1004A9F1;
  return result;
}
// 100741CC: using guessed type int (*off_100741CC[10])();
// 100741D0: using guessed type int (*off_100741D0[9])();
// 100741D4: using guessed type int (*off_100741D4[8])();
// 100741D8: using guessed type int (*off_100741D8[7])();
// 100741DC: using guessed type int (*off_100741DC[6])();
// 100741E0: using guessed type int (*off_100741E0[5])();

//----- (100393F3) --------------------------------------------------------
int __cdecl sub_100393F3(int a1)
{
  int result; // eax@1

  result = __security_cookie ^ dword_10077908;
  if ( __security_cookie != dword_10077908 )
    result = ((int (__stdcall *)(int))result)(a1);
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10077908: using guessed type int dword_10077908;

//----- (1003940A) --------------------------------------------------------
int __cdecl sub_1003940A(int a1)
{
  int result; // eax@1

  result = __security_cookie ^ dword_10077914;
  if ( __security_cookie != dword_10077914 )
    result = ((int (__stdcall *)(int))result)(a1);
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10077914: using guessed type int dword_10077914;

//----- (10039421) --------------------------------------------------------
HANDLE __stdcall sub_10039421(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, int a5, int a6)
{
  HANDLE result; // eax@2

  if ( __security_cookie == dword_100778F4 )
    result = CreateSemaphoreW(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
  else
    result = (HANDLE)((int (__stdcall *)(LPSECURITY_ATTRIBUTES, LONG, LONG, LPCWSTR, int, int))(__security_cookie ^ dword_100778F4))(
                       lpSemaphoreAttributes,
                       lInitialCount,
                       lMaximumCount,
                       lpName,
                       a5,
                       a6);
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 100778F4: using guessed type int dword_100778F4;

//----- (1003944A) --------------------------------------------------------
int __cdecl sub_1003944A(int a1, int a2, int a3)
{
  int result; // eax@2

  if ( __security_cookie == dword_100778FC )
    result = 0;
  else
    result = ((int (__stdcall *)(int, int, int))(__security_cookie ^ dword_100778FC))(a1, a2, a3);
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 100778FC: using guessed type int dword_100778FC;

//----- (1003946B) --------------------------------------------------------
int __cdecl sub_1003946B(int a1, int a2, int a3)
{
  int result; // eax@2

  if ( __security_cookie == dword_1007790C )
    result = 0;
  else
    result = ((int (__stdcall *)(int, int, int))(__security_cookie ^ dword_1007790C))(a1, a2, a3);
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 1007790C: using guessed type int dword_1007790C;

//----- (1003948C) --------------------------------------------------------
DWORD __cdecl sub_1003948C(int a1)
{
  DWORD result; // eax@2

  if ( __security_cookie == dword_100778E0 )
    result = TlsAlloc();
  else
    result = ((int (__stdcall *)(int))(__security_cookie ^ dword_100778E0))(a1);
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 100778E0: using guessed type int dword_100778E0;

//----- (100394AA) --------------------------------------------------------
BOOL __cdecl sub_100394AA(DWORD a1)
{
  BOOL result; // eax@2

  if ( __security_cookie == dword_100778E4 )
    result = TlsFree(a1);
  else
    result = ((int (__stdcall *)(_DWORD))(__security_cookie ^ dword_100778E4))(a1);
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 100778E4: using guessed type int dword_100778E4;

//----- (100394C9) --------------------------------------------------------
LPVOID __cdecl sub_100394C9(DWORD a1)
{
  LPVOID result; // eax@2

  if ( __security_cookie == dword_100778E8 )
    result = TlsGetValue(a1);
  else
    result = (LPVOID)((int (__stdcall *)(_DWORD))(__security_cookie ^ dword_100778E8))(a1);
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 100778E8: using guessed type int dword_100778E8;

//----- (100394E8) --------------------------------------------------------
BOOL __cdecl sub_100394E8(DWORD a1, void *a2)
{
  BOOL result; // eax@2

  if ( __security_cookie == dword_100778EC )
    result = TlsSetValue(a1, a2);
  else
    result = ((int (__stdcall *)(_DWORD, _DWORD))(__security_cookie ^ dword_100778EC))(a1, a2);
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 100778EC: using guessed type int dword_100778EC;

//----- (1003950A) --------------------------------------------------------
int __cdecl sub_1003950A()
{
  int result; // eax@1

  result = __security_cookie ^ dword_10077918;
  if ( __security_cookie != dword_10077918 )
    result = ((int (*)(void))result)();
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10077918: using guessed type int dword_10077918;

//----- (1003951A) --------------------------------------------------------
int __cdecl sub_1003951A(int a1, int a2)
{
  int result; // eax@1

  result = __security_cookie ^ dword_1007791C;
  if ( __security_cookie != dword_1007791C )
    result = ((int (__stdcall *)(int, int))result)(a1, a2);
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 1007791C: using guessed type int dword_1007791C;

//----- (10039534) --------------------------------------------------------
int __cdecl sub_10039534()
{
  int result; // eax@2

  if ( __security_cookie == dword_10077920 )
    result = 0;
  else
    result = ((int (*)(void))(__security_cookie ^ dword_10077920))();
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10077920: using guessed type int dword_10077920;

//----- (10039546) --------------------------------------------------------
int __cdecl sub_10039546(int a1, int a2)
{
  int result; // eax@2

  if ( __security_cookie == dword_10077924 )
  {
    SetLastError(0x78u);
    result = 0;
  }
  else
  {
    result = ((int (__stdcall *)(int, int))(__security_cookie ^ dword_10077924))(a1, a2);
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10077924: using guessed type int dword_10077924;

//----- (1003956C) --------------------------------------------------------
int __cdecl sub_1003956C(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, int a3)
{
  int result; // eax@2

  if ( __security_cookie == dword_100778F0 )
  {
    InitializeCriticalSectionAndSpinCount(lpCriticalSection, dwSpinCount);
    result = 1;
  }
  else
  {
    result = ((int (__stdcall *)(LPCRITICAL_SECTION, DWORD, int))(__security_cookie ^ dword_100778F0))(
               lpCriticalSection,
               dwSpinCount,
               a3);
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 100778F0: using guessed type int dword_100778F0;

//----- (1003959A) --------------------------------------------------------
char __cdecl sub_1003959A()
{
  signed int v0; // esi@1
  int v2; // [sp+4h] [bp-4h]@2

  v0 = dword_10073228;
  if ( dword_10073228 < 0 )
  {
    v0 = 0;
    v2 = 0;
    if ( __security_cookie != dword_10077950 )
    {
      if ( ((int (__stdcall *)(int *, _DWORD))(__security_cookie ^ dword_10077950))(&v2, 0) == 122 )
        v0 = 1;
    }
    dword_10073228 = v0;
  }
  return v0 > 0;
}
// 10073200: using guessed type int __security_cookie;
// 10073228: using guessed type int dword_10073228;
// 10077950: using guessed type int dword_10077950;

//----- (10039817) --------------------------------------------------------
int __cdecl sub_10039817(int a1, int a2, int a3, int a4)
{
  int result; // eax@1

  result = __security_cookie ^ dword_10077900;
  if ( __security_cookie != dword_10077900 )
    result = ((int (__stdcall *)(int, int, int, int))result)(a1, a2, a3, a4);
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10077900: using guessed type int dword_10077900;

//----- (10039837) --------------------------------------------------------
int __cdecl sub_10039837(int a1, int a2, int a3)
{
  int result; // eax@1

  result = __security_cookie ^ dword_10077910;
  if ( __security_cookie != dword_10077910 )
    result = ((int (__stdcall *)(int, int, int))result)(a1, a2, a3);
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10077910: using guessed type int dword_10077910;

//----- (10039854) --------------------------------------------------------
BOOL __cdecl sub_10039854(UINT uExitCode)
{
  HANDLE v2; // eax@1

  v2 = GetCurrentProcess();
  return TerminateProcess(v2, uExitCode);
}

//----- (10039869) --------------------------------------------------------
LONG __cdecl sub_10039869(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  SetUnhandledExceptionFilter(0);
  return UnhandledExceptionFilter(ExceptionInfo);
}

//----- (1003987F) --------------------------------------------------------
int __cdecl sub_1003987F(int a1, int a2)
{
  int result; // eax@1

  result = __security_cookie ^ dword_10077904;
  if ( __security_cookie != dword_10077904 )
    result = ((int (__stdcall *)(int, int))result)(a1, a2);
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10077904: using guessed type int dword_10077904;

//----- (10039899) --------------------------------------------------------
int __cdecl sub_10039899(int a1)
{
  int v1; // eax@1
  __int16 v2; // cx@2

  v1 = a1;
  do
  {
    v2 = *(_WORD *)v1;
    v1 += 2;
  }
  while ( v2 );
  return ((v1 - a1) >> 1) - 1;
}

//----- (100398B2) --------------------------------------------------------
int __usercall sub_100398B2<eax>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // ecx@2
  int v6; // eax@3
  __int16 v7; // ax@4
  int v8; // ecx@6
  int result; // eax@8
  int v10; // ecx@14
  unsigned int v11; // eax@16
  int v12; // edx@22
  int v13; // [sp+8h] [bp-18h]@1
  int v14; // [sp+10h] [bp-10h]@7
  char v15; // [sp+14h] [bp-Ch]@6
  WCHAR DestStr; // [sp+18h] [bp-8h]@16
  const CHAR MultiByteStr; // [sp+1Ch] [bp-4h]@14
  char v18; // [sp+1Dh] [bp-3h]@14
  char v19; // [sp+1Eh] [bp-2h]@14
  int v20; // [sp+28h] [bp+8h]@13

  sub_100301AD((int)&v13, a1, a2, a4);
  v4 = a3;
  if ( (unsigned int)a3 < 0x100 )
  {
    v5 = v13;
    if ( *(_DWORD *)(v13 + 116) <= 1 )
    {
      v7 = *(_WORD *)(*(_DWORD *)(v13 + 144) + 2 * a3);
      v6 = v7 & 1;
    }
    else
    {
      v6 = sub_1004256E(a3, 256, a3, 1, (int)&v13);
      v5 = v13;
    }
    if ( v6 )
    {
      v8 = *(_BYTE *)(*(_DWORD *)(v5 + 148) + a3);
      if ( v15 )
        *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
      return v8;
    }
    if ( v15 )
      *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
    return v4;
  }
  if ( *(_DWORD *)(v13 + 116) > 1 && (v20 = a3 >> 8, sub_1004261D(v4, 256, BYTE1(v4), (int)&v13)) )
  {
    MultiByteStr = v20;
    v18 = v4;
    v19 = 0;
    v10 = 2;
  }
  else
  {
    *(_DWORD *)sub_10037649(v4) = 42;
    MultiByteStr = v4;
    v18 = 0;
    v10 = 1;
  }
  v11 = sub_100374A2(
          v4,
          256,
          (int)&v13,
          *(_DWORD *)(v13 + 168),
          0x100u,
          &MultiByteStr,
          v10,
          &DestStr,
          3,
          *(_DWORD *)(v13 + 4),
          1);
  if ( !v11 )
  {
    if ( v15 )
      *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
    return v4;
  }
  if ( v11 == 1 )
  {
    result = (unsigned __int8)DestStr;
    if ( v15 )
      *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
  }
  else
  {
    v12 = HIBYTE(DestStr) | ((unsigned __int8)DestStr << 8);
    if ( v15 )
      *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
    result = v12;
  }
  return result;
}

//----- (100399F3) --------------------------------------------------------
int __usercall sub_100399F3<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // ecx@2
  int result; // eax@4

  if ( dword_10075F28 )
  {
    result = sub_100398B2(a1, a2, a3, 0);
  }
  else
  {
    v3 = a3;
    if ( (unsigned int)(a3 - 65) <= 0x19 )
      v3 = a3 + 32;
    result = v3;
  }
  return result;
}
// 10075F28: using guessed type int dword_10075F28;

//----- (10039A20) --------------------------------------------------------
__int64 __stdcall sub_10039A20(__int64 a1, __int64 a2)
{
  __int64 result; // qax@2

  if ( HIDWORD(a1) | HIDWORD(a2) )
    result = a2 * a1;
  else
    result = (unsigned int)a2 * (unsigned int)a1;
  return result;
}

//----- (10039A60) --------------------------------------------------------
__int64 __stdcall sub_10039A60(unsigned __int64 a1, unsigned int a2, unsigned int a3)
{
  __int64 result; // qax@2
  unsigned __int64 v4; // qtt@2
  unsigned __int64 v5; // qax@3
  unsigned int v6; // ecx@3
  unsigned int v7; // ebx@3
  char v8; // cf@4
  char v9; // cf@4
  unsigned int v10; // eax@5
  unsigned __int64 v11; // qax@5
  unsigned int v12; // esi@5
  int v13; // ecx@5
  char v14; // cf@5

  if ( a3 )
  {
    v6 = a3;
    v7 = a2;
    v5 = a1;
    do
    {
      v8 = v6 & 1;
      v6 >>= 1;
      v7 = __RCR__(v7, v8);
      v9 = BYTE4(v5) & 1;
      HIDWORD(v5) >>= 1;
      LODWORD(v5) = __RCR__(v5, v9);
    }
    while ( v6 );
    v10 = v5 / v7;
    v12 = v10;
    v13 = a3 * v10;
    v11 = v10 * a2;
    v14 = v13 >= (unsigned int)-HIDWORD(v11);
    HIDWORD(v11) += v13;
    if ( v14 || HIDWORD(v11) > HIDWORD(a1) || v11 > a1 )
      --v12;
    result = v12;
  }
  else
  {
    LODWORD(v4) = a1;
    HIDWORD(v4) = HIDWORD(a1) % a2;
    LODWORD(result) = v4 / a2;
    HIDWORD(result) = HIDWORD(a1) / a2;
  }
  return result;
}

//----- (10039AC8) --------------------------------------------------------
int __cdecl sub_10039AC8(int a1)
{
  int v1; // ecx@1
  int v2; // esi@1
  int result; // eax@2

  v1 = 0;
  v2 = 227;
  while ( 1 )
  {
    result = (v2 + v1) / 2;
    if ( a1 == dword_10061A58[2 * result] )
      break;
    if ( a1 - dword_10061A58[2 * result] >= 0 )
      v1 = result + 1;
    else
      v2 = result - 1;
    if ( v1 > v2 )
      return -1;
  }
  return result;
}
// 10061A58: using guessed type int dword_10061A58[];

//----- (10039AFD) --------------------------------------------------------
int __cdecl sub_10039AFD(int a1)
{
  int v1; // ebx@1
  int v2; // edi@1
  int v3; // eax@2
  int v4; // esi@2

  v2 = 0;
  v1 = 227;
  while ( 1 )
  {
    v4 = (v1 + v2) / 2;
    v3 = sub_10039D5F(a1, (unsigned __int16 *)*(&off_10062178 + 2 * (v1 + v2) / 2), 85);
    if ( !v3 )
      break;
    if ( v3 >= 0 )
      v2 = v4 + 1;
    else
      v1 = v4 - 1;
    if ( v2 > v1 )
      return -1;
  }
  return dword_1006217C[2 * v4];
}
// 10062178: using guessed type void *off_10062178;
// 1006217C: using guessed type int dword_1006217C[];

//----- (10039B4B) --------------------------------------------------------
int __cdecl sub_10039B4B(int a1, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2)
{
  int result; // eax@2
  int v7; // eax@3

  if ( __security_cookie == dword_10077930 )
  {
    v7 = sub_10039C13(a1);
    result = CompareStringW(v7, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
  }
  else
  {
    result = ((int (__stdcall *)(int, DWORD, PCNZWCH, int, PCNZWCH, int, _DWORD, _DWORD, _DWORD))(__security_cookie ^ dword_10077930))(
               a1,
               dwCmpFlags,
               lpString1,
               cchCount1,
               lpString2,
               cchCount2,
               0,
               0,
               0);
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10077930: using guessed type int dword_10077930;

//----- (10039B97) --------------------------------------------------------
int __cdecl sub_10039B97(int a1, int a2, int a3)
{
  int v3; // eax@7
  int v4; // eax@8
  int v5; // edx@8
  int v6; // ebx@8
  int v7; // edi@8
  int v9; // [sp-4h] [bp-10h]@8

  if ( a1 )
  {
    if ( a1 != 1024 )
    {
      if ( a1 != 2048 )
      {
        if ( a2 || a3 <= 0 )
        {
          if ( a3 >= 0 )
          {
            v3 = sub_10039AC8(a1);
            if ( v3 >= 0 )
            {
              v6 = off_10061A5C[2 * v3];
              v4 = sub_1004AC57(off_10061A5C[2 * v3], 0x55u);
              v7 = v4;
              if ( a3 <= 0 )
                return v7 + 1;
              if ( v4 < a3 )
              {
                if ( sub_100490D0(v5, v9, v6, v4, a2, a3, v6) )
                {
                  sub_1003A161(v6, v7);
                  __asm { int     3               ; Trap to Debugger }
                  JUMPOUT(*(int *)sub_10039C13);
                }
                return v7 + 1;
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

//----- (10039C13) --------------------------------------------------------
int __cdecl sub_10039C13(int a1)
{
  int v1; // eax@2
  int result; // eax@4

  if ( a1 && (v1 = sub_10039AFD(a1), v1 >= 0) && (unsigned int)v1 < 0xE4 )
    result = dword_10061A58[2 * v1];
  else
    result = 0;
  return result;
}
// 10061A58: using guessed type int dword_10061A58[];

//----- (10039C3D) --------------------------------------------------------
int __stdcall LocaleEnumProc(int a1)
{
  return dword_10075778(a1, 0, 0);
}
// 10075778: using guessed type int (__stdcall *dword_10075778)(_DWORD, _DWORD, _DWORD);

//----- (10039C51) --------------------------------------------------------
BOOL __cdecl sub_10039C51(int (__stdcall *a1)(_DWORD, _DWORD, _DWORD), int a2, int a3)
{
  BOOL result; // eax@2

  if ( __security_cookie == dword_10077934 )
  {
    dword_10075778 = a1;
    result = EnumSystemLocalesW((LOCALE_ENUMPROCW)LocaleEnumProc, 1u);
    dword_10075778 = 0;
  }
  else
  {
    result = ((int (__stdcall *)(int (__stdcall *)(_DWORD, _DWORD, _DWORD), int, int, _DWORD))(__security_cookie ^ dword_10077934))(
               a1,
               a2,
               a3,
               0);
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10075778: using guessed type int (__stdcall *dword_10075778)(_DWORD, _DWORD, _DWORD);
// 10077934: using guessed type int dword_10077934;

//----- (10039C8E) --------------------------------------------------------
int __cdecl sub_10039C8E(int a1, LCTYPE a2, WCHAR *a3, int a4)
{
  int result; // eax@2
  int v5; // eax@3

  if ( __security_cookie == dword_1007793C )
  {
    v5 = sub_10039C13(a1);
    result = GetLocaleInfoW(v5, a2, a3, a4);
  }
  else
  {
    result = ((int (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))(__security_cookie ^ dword_1007793C))(a1, a2, a3, a4);
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 1007793C: using guessed type int dword_1007793C;

//----- (10039CBD) --------------------------------------------------------
int __cdecl sub_10039CBD(int a1, int a2)
{
  int result; // eax@2
  int v3; // eax@3

  if ( __security_cookie == dword_10077944 )
  {
    v3 = GetUserDefaultLCID();
    result = sub_10039B97(v3, a1, a2);
  }
  else
  {
    result = ((int (__stdcall *)(_DWORD, _DWORD))(__security_cookie ^ dword_10077944))(a1, a2);
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10077944: using guessed type int dword_10077944;

//----- (10039CE8) --------------------------------------------------------
BOOL __cdecl sub_10039CE8(int a1)
{
  BOOL result; // eax@2
  int v2; // eax@3

  if ( __security_cookie == dword_10077948 )
  {
    v2 = sub_10039C13(a1);
    result = IsValidLocale(v2, 1u);
  }
  else
  {
    result = ((int (__stdcall *)(_DWORD))(__security_cookie ^ dword_10077948))(a1);
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10077948: using guessed type int dword_10077948;

//----- (10039D13) --------------------------------------------------------
int __cdecl sub_10039D13(int a1, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
{
  int result; // eax@2
  int v7; // eax@3

  if ( __security_cookie == dword_1007794C )
  {
    v7 = sub_10039C13(a1);
    result = LCMapStringW(v7, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
  }
  else
  {
    result = ((int (__stdcall *)(int, DWORD, LPCWSTR, int, LPWSTR, int, _DWORD, _DWORD, _DWORD))(__security_cookie ^ dword_1007794C))(
               a1,
               dwMapFlags,
               lpSrcStr,
               cchSrc,
               lpDestStr,
               cchDest,
               0,
               0,
               0);
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 1007794C: using guessed type int dword_1007794C;

//----- (10039D5F) --------------------------------------------------------
int __cdecl sub_10039D5F(int a1, unsigned __int16 *a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  signed __int16 v5; // dx@2
  unsigned __int16 *v6; // ecx@2
  unsigned __int16 v7; // ax@4
  unsigned __int16 v8; // dx@6
  unsigned __int16 v9; // ax@8
  signed int v10; // [sp+14h] [bp+10h]@2

  v4 = a3;
  result = 0;
  if ( a3 )
  {
    v6 = a2;
    v5 = 90;
    v10 = 90;
    while ( 1 )
    {
      v7 = *(unsigned __int16 *)((char *)v6 + a1 - (_DWORD)a2);
      if ( v7 < 0x41u || v7 > v5 )
        v8 = *(unsigned __int16 *)((char *)v6 + a1 - (_DWORD)a2);
      else
        v8 = v7 + 32;
      v9 = *v6;
      if ( *v6 >= 0x41u )
      {
        if ( v9 <= (_WORD)v10 )
          v9 += 32;
      }
      ++v6;
      --v4;
      if ( !v4 )
        break;
      if ( !v8 || v8 != v9 )
        break;
      v5 = 90;
    }
    result = v8 - v9;
  }
  return result;
}

//----- (10039DCD) --------------------------------------------------------
int __cdecl sub_10039DCD(int a1, DWORD dwMapFlags, LPCWSTR lpSrcStr, unsigned int cchSrc, LPWSTR lpDestStr, int cchDest)
{
  int v6; // eax@1

  v6 = cchSrc;
  if ( (signed int)cchSrc > 0 )
    v6 = sub_1004AC57((int)lpSrcStr, cchSrc);
  return sub_10039D13(a1, dwMapFlags, lpSrcStr, v6, lpDestStr, cchDest);
}

//----- (10039E00) --------------------------------------------------------
void __usercall sub_10039E00(unsigned __int64 a1<st0>)
{
  int v1; // ST00_4@1
  int v2; // ST04_4@1

  sub_1004AF38(a1, a1 >> 32);
  sub_10039E1D(v1, v2);
}
// 10039E1D: using guessed type double __cdecl sub_10039E1D(_DWORD, _DWORD);

//----- (10039E1D) --------------------------------------------------------
#error "10039EB3: call analysis failed (funcsize=60)"

//----- (10039EBA) --------------------------------------------------------
int __cdecl sub_10039EBA()
{
  int v1; // esi@2
  int v6; // ST18_4@2

  dword_1007577C = 0;
  dword_10073238 |= 1u;
  if ( IsProcessorFeaturePresent(0xAu) )
  {
    _EAX = 1;
    dword_1007577C = 1;
    __asm { cpuid }
    v1 = dword_10073238 | 2;
    v6 = _ECX;
    dword_10073238 |= 2u;
    if ( v6 & 0x100000 )
    {
      v1 |= 4u;
      dword_1007577C = 2;
      dword_10073238 = v1;
    }
    if ( _ECX & 0x10000000 )
    {
      dword_1007577C = 3;
      dword_10073238 = v1 | 8;
    }
    _EAX = 7;
    __asm { cpuid }
    _EAX = 0;
    __asm { cpuid }
  }
  return 0;
}
// 10073238: using guessed type int dword_10073238;
// 1007577C: using guessed type int dword_1007577C;

//----- (10039FF6) --------------------------------------------------------
void __usercall sub_10039FF6(int a1<ebx>, int a2<edi>, int a3<esi>, int a4, int a5, int a6)
{
  BOOL v6; // edi@3
  int v11; // ecx@3
  int v12; // edx@3
  int v13; // ST08_4@3
  char v14; // [sp-Ch] [bp-338h]@3
  char v15; // [sp+0h] [bp-32Ch]@3
  struct _EXCEPTION_POINTERS ExceptionInfo; // [sp+4h] [bp-328h]@3
  int v17; // [sp+Ch] [bp-320h]@3
  int v18; // [sp+10h] [bp-31Ch]@3
  void *v19; // [sp+18h] [bp-314h]@3
  int v20; // [sp+5Ch] [bp-2D0h]@3
  __int16 v21; // [sp+E8h] [bp-244h]@3
  __int16 v22; // [sp+ECh] [bp-240h]@3
  __int16 v23; // [sp+F0h] [bp-23Ch]@3
  __int16 v24; // [sp+F4h] [bp-238h]@3
  int v25; // [sp+F8h] [bp-234h]@3
  int v26; // [sp+FCh] [bp-230h]@3
  int v27; // [sp+100h] [bp-22Ch]@3
  int v28; // [sp+104h] [bp-228h]@3
  int v29; // [sp+108h] [bp-224h]@3
  int *v30; // [sp+10Ch] [bp-220h]@3
  int v31; // [sp+110h] [bp-21Ch]@3
  void *v32; // [sp+114h] [bp-218h]@3
  __int16 v33; // [sp+118h] [bp-214h]@3
  int v34; // [sp+11Ch] [bp-210h]@3
  void **v35; // [sp+120h] [bp-20Ch]@3
  __int16 v36; // [sp+124h] [bp-208h]@3
  unsigned int v37; // [sp+328h] [bp-4h]@1
  int v38; // [sp+32Ch] [bp+0h]@1
  int v39; // [sp+330h] [bp+4h]@3

  v37 = (unsigned int)&v38 ^ __security_cookie;
  if ( a4 != -1 )
    sub_10043522();
  sub_100391F0(&v18, 0, 76);
  ExceptionInfo.ExceptionRecord = (PEXCEPTION_RECORD)&v17;
  _CF = (unsigned int)&v14 >= 0xFFFFFFF4;
  _OF = __SETO__(&v14, -12);
  _ZF = &v15 == 0;
  _SF = (signed int)&v15 < 0;
  ExceptionInfo.ContextRecord = (PCONTEXT)&v20;
  v30 = &v20;
  v29 = v11;
  v28 = v12;
  v27 = a1;
  v26 = a3;
  v25 = a2;
  v36 = __SS__;
  v33 = __CS__;
  v24 = __DS__;
  v23 = __ES__;
  v22 = __FS__;
  v21 = __GS__;
  __asm { pushf }
  v34 = v13;
  v32 = (void *)v39;
  v35 = (void **)&v39;
  v20 = 65537;
  v31 = v38;
  v17 = a5;
  v18 = a6;
  v19 = (void *)v39;
  v6 = IsDebuggerPresent();
  if ( !sub_10039869(&ExceptionInfo) )
  {
    if ( !v6 )
    {
      if ( a4 != -1 )
        sub_10043522();
    }
  }
}
// 10073200: using guessed type int __security_cookie;

//----- (1003A119) --------------------------------------------------------
void *__cdecl sub_1003A119(void *a1)
{
  void *result; // eax@1

  result = a1;
  dword_10075784 = a1;
  return result;
}

//----- (1003A126) --------------------------------------------------------
int __usercall sub_1003A126<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6, int a7)
{
  int (*v7)(void); // eax@1

  v7 = (int (*)(void))DecodePointer(dword_10075784);
  if ( !v7 )
  {
    sub_1003A161(a1, a2);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003A151);
  }
  return v7();
}

//----- (1003A151) --------------------------------------------------------
int __usercall sub_1003A151<eax>(int a1<ebx>, int a2<edi>)
{
  return sub_1003A126(a1, a2, 0, 0, 0, 0, 0);
}

//----- (1003A161) --------------------------------------------------------
int __usercall sub_1003A161<eax>(int a1<ebx>, int a2<edi>)
{
  if ( IsProcessorFeaturePresent(0x17u) )
    __asm { int     29h             ; DOS 2+ internal - FAST PUTCHAR }
  sub_10039FF6(a1, a2, -1073740777, 2, -1073740777, 1);
  return sub_10039854(0xC0000417u);
}

//----- (1003A18C) --------------------------------------------------------
int *__cdecl sub_1003A18C()
{
  return &dword_10073244;
}
// 10073244: using guessed type int dword_10073244;

//----- (1003A192) --------------------------------------------------------
int *__cdecl sub_1003A192()
{
  return &dword_10073248;
}
// 10073248: using guessed type int dword_10073248;

//----- (1003A198) --------------------------------------------------------
int *__cdecl sub_1003A198()
{
  return &dword_10073240;
}
// 10073240: using guessed type int dword_10073240;

//----- (1003A19E) --------------------------------------------------------
void **__cdecl sub_1003A19E()
{
  return &off_100732D0;
}
// 100732D0: using guessed type void *off_100732D0;

//----- (1003A1A4) --------------------------------------------------------
signed int __usercall sub_1003A1A4<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  signed int result; // eax@2

  if ( a3 )
  {
    *(_DWORD *)a3 = dword_10073244;
    result = 0;
  }
  else
  {
    *(_DWORD *)sub_10037649(a1) = 22;
    sub_1003A151(a1, a2);
    result = 22;
  }
  return result;
}
// 10073244: using guessed type int dword_10073244;

//----- (1003A1CE) --------------------------------------------------------
signed int __usercall sub_1003A1CE<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  signed int result; // eax@2

  if ( a3 )
  {
    *(_DWORD *)a3 = dword_10073248;
    result = 0;
  }
  else
  {
    *(_DWORD *)sub_10037649(a1) = 22;
    sub_1003A151(a1, a2);
    result = 22;
  }
  return result;
}
// 10073248: using guessed type int dword_10073248;

//----- (1003A1F8) --------------------------------------------------------
signed int __usercall sub_1003A1F8<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  signed int result; // eax@2

  if ( a3 )
  {
    *(_DWORD *)a3 = dword_10073240;
    result = 0;
  }
  else
  {
    *(_DWORD *)sub_10037649(a1) = 22;
    sub_1003A151(a1, a2);
    result = 22;
  }
  return result;
}
// 10073240: using guessed type int dword_10073240;

//----- (1003A222) --------------------------------------------------------
signed int __cdecl sub_1003A222(int a1, int a2)
{
  signed int v2; // esi@2
  signed int result; // eax@3
  int v4; // edx@5
  int v5; // ecx@5
  __int64 v6; // qcx@16
  int v7; // edx@17
  __int64 v8; // qcx@17
  int v9; // eax@19
  int v10; // edx@22
  int v11; // eax@24
  int v12; // ebx@25
  int v13; // esi@25
  int v14; // eax@25
  int v15; // eax@27
  unsigned __int64 v16; // ST04_8@27
  unsigned __int8 v17; // cf@28
  int v18; // eax@29
  int v19; // ebx@29
  unsigned int v20; // esi@29
  unsigned __int64 v21; // ST04_8@29
  int v22; // esi@29
  int v23; // edx@29
  int v24; // ebx@29
  __int64 v25; // qax@29
  unsigned __int8 v26; // cf@29
  unsigned __int64 v27; // ST04_8@29
  unsigned __int8 v28; // cf@30
  int v29; // eax@31
  int v30; // ebx@31
  unsigned int v31; // esi@31
  unsigned __int64 v32; // ST04_8@31
  int v33; // esi@31
  int v34; // edx@31
  int v35; // ebx@31
  __int64 v36; // qax@31
  unsigned __int8 v37; // cf@31
  unsigned __int64 v38; // ST04_8@31
  unsigned __int8 v39; // cf@32
  int v40; // eax@33
  int v41; // edx@33
  int v42; // ecx@33
  unsigned __int64 v43; // ST04_8@33
  int v44; // edx@36
  int v45; // eax@42
  int v46; // edx@42
  int v47; // [sp-4h] [bp-24h]@17
  int v48; // [sp-4h] [bp-24h]@22
  __int64 v49; // [sp+Ch] [bp-14h]@17
  int v50; // [sp+14h] [bp-Ch]@1
  int v51; // [sp+18h] [bp-8h]@1
  int v52; // [sp+1Ch] [bp-4h]@1

  v51 = 0;
  v50 = 0;
  v52 = 0;
  if ( !a1 || (sub_100391F0((void *)a1, 0xFFu, 36), !a2) )
  {
    v2 = 22;
    *(_DWORD *)sub_10037649(0) = 22;
    sub_1003A151(0, a1);
    return v2;
  }
  if ( *(_DWORD *)(a2 + 4) <= 0 && *(_DWORD *)(a2 + 4) < 0
    || *(_DWORD *)(a2 + 4) >= 7 && (*(_DWORD *)(a2 + 4) > 7 || *(_DWORD *)a2 > 0x93406FFFu) )
  {
    v2 = 22;
    *(_DWORD *)sub_10037649(0) = 22;
    return v2;
  }
  sub_1003A49A(v4, v5, 0, a1);
  if ( sub_1003A1A4(0, a1, (int)&v51) || sub_1003A1CE(0, a1, (int)&v50) || sub_1003A1F8(0, a1, (int)&v52) )
  {
    sub_1003A161(0, a1);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003A49A);
  }
  v6 = *(_QWORD *)a2;
  if ( *(_QWORD *)a2 > 259200i64 )
  {
    v8 = v6 - v52;
    v49 = v8;
    result = sub_100303A8(SHIDWORD(v8), a1, a1, (int)&v49);
    if ( result )
      return result;
    if ( v51 )
    {
      sub_1003A4EA(v7, v47, SHIDWORD(v8), a1, a1);
      if ( v9 )
      {
        v49 -= v50;
        result = sub_100303A8(SHIDWORD(v8), a1, a1, (int)&v49);
        if ( result )
          return result;
        *(_DWORD *)(a1 + 32) = 1;
      }
    }
    return 0;
  }
  result = sub_100303A8(SHIDWORD(v6), a1, a1, a2);
  if ( result )
    return result;
  if ( v51 && (sub_1003A4EA(v10, v48, SHIDWORD(v6), a1, a1), v11) )
  {
    v14 = v52 + v50;
    *(_DWORD *)(a1 + 32) = 1;
    v12 = *(_DWORD *)a1 - v14;
    v13 = (unsigned __int64)(*(_DWORD *)a1 - v14) >> 32;
  }
  else
  {
    v12 = *(_DWORD *)a1 - v52;
    v13 = (unsigned __int64)(*(_DWORD *)a1 - v52) >> 32;
  }
  HIDWORD(v16) = v13;
  LODWORD(v16) = v12;
  v15 = sub_1003ACF0(v16, 60i64);
  *(_DWORD *)a1 = v15;
  if ( v15 < 0 )
  {
    v17 = (unsigned int)v12 >= 0x3C;
    v12 -= 60;
    *(_DWORD *)a1 = v15 + 60;
    v13 = v17 + v13 - 1;
  }
  HIDWORD(v21) = v13;
  LODWORD(v21) = v12;
  v22 = sub_1003AC40(v21, 0x3Cu, 0);
  v24 = v23;
  v25 = *(_DWORD *)(a1 + 4);
  v26 = (_DWORD)v25 >= (unsigned int)-v22;
  v20 = v25 + v22;
  v19 = HIDWORD(v25) + v26 + v24;
  HIDWORD(v27) = v19;
  LODWORD(v27) = v20;
  v18 = sub_1003ACF0(v27, 60i64);
  *(_DWORD *)(a1 + 4) = v18;
  if ( v18 < 0 )
  {
    v28 = v20 >= 0x3C;
    v20 -= 60;
    *(_DWORD *)(a1 + 4) = v18 + 60;
    v19 = v28 + v19 - 1;
  }
  HIDWORD(v32) = v19;
  LODWORD(v32) = v20;
  v33 = sub_1003AC40(v32, 0x3Cu, 0);
  v35 = v34;
  v36 = *(_DWORD *)(a1 + 8);
  v37 = (_DWORD)v36 >= (unsigned int)-v33;
  v31 = v36 + v33;
  v30 = HIDWORD(v36) + v37 + v35;
  HIDWORD(v38) = v30;
  LODWORD(v38) = v31;
  v29 = sub_1003ACF0(v38, 24i64);
  *(_DWORD *)(a1 + 8) = v29;
  if ( v29 < 0 )
  {
    v39 = v31 >= 0x18;
    v31 -= 24;
    *(_DWORD *)(a1 + 8) = v29 + 24;
    v30 = v39 + v30 - 1;
  }
  HIDWORD(v43) = v30;
  LODWORD(v43) = v31;
  v40 = sub_1003AC40(v43, 0x18u, 0);
  v42 = v40;
  if ( v41 >= 0 )
  {
    if ( v41 > 0 || v40 )
    {
      v44 = (v40 + *(_DWORD *)(a1 + 24)) % 7;
      *(_DWORD *)(a1 + 12) += v40;
      *(_DWORD *)(a1 + 24) = v44;
      goto LABEL_37;
    }
    if ( v41 > 0 || v41 >= 0 )
      return 0;
  }
  v46 = (v40 + *(_DWORD *)(a1 + 24) + 7) % 7;
  *(_DWORD *)(a1 + 12) += v40;
  v45 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 + 24) = v46;
  if ( v45 <= 0 )
  {
    *(_DWORD *)(a1 + 12) = v45 + 31;
    *(_DWORD *)(a1 + 28) += v42 + 365;
    --*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 16) = 11;
    return 0;
  }
LABEL_37:
  *(_DWORD *)(a1 + 28) += v42;
  return 0;
}

//----- (1003A49A) --------------------------------------------------------
void __usercall sub_1003A49A(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // edx@2
  int v5; // [sp-4h] [bp-2Ch]@2

  if ( !dword_1007578C )
  {
    sub_10036A23(a1, a2, a3, a4, 6);
    if ( !dword_1007578C )
    {
      sub_1003A714(v4, v5, a4);
      ++dword_1007578C;
    }
    sub_10036B87(6);
  }
}
// 1007578C: using guessed type int dword_1007578C;

//----- (1003A4EA) --------------------------------------------------------
void __usercall sub_1003A4EA(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  sub_10036A23(a1, a2, a3, a4, 6);
  sub_1003A530(a4, a5);
  sub_10036B87(6);
}

//----- (1003A530) --------------------------------------------------------
char __usercall sub_1003A530<al>(int a1<edi>, int a2)
{
  signed int v2; // eax@1
  signed int v3; // ecx@3
  signed int v4; // eax@13
  signed int v5; // edx@13
  signed int v6; // ebx@13
  signed int v7; // edi@13
  int v8; // edx@16
  int v9; // ecx@28
  signed int v11; // [sp-30h] [bp-38h]@7
  signed int v12; // [sp-30h] [bp-38h]@10
  int v13; // [sp-2Ch] [bp-34h]@7
  int v14; // [sp-2Ch] [bp-34h]@10
  int v15; // [sp-28h] [bp-30h]@7
  int v16; // [sp-28h] [bp-30h]@10
  int v17; // [sp-24h] [bp-2Ch]@7
  int v18; // [sp-24h] [bp-2Ch]@10
  int v19; // [sp-20h] [bp-28h]@7
  int v20; // [sp-20h] [bp-28h]@10
  int v21; // [sp-1Ch] [bp-24h]@7
  int v22; // [sp-1Ch] [bp-24h]@10
  int v23; // [sp+4h] [bp-4h]@1

  v23 = 0;
  v2 = sub_1003A1A4(0, a1, (int)&v23);
  if ( v2 )
  {
    sub_1003A161(0, a1);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003A714);
  }
  if ( v23 )
  {
    v3 = *(_DWORD *)(a2 + 20);
    if ( v3 != dword_100732D8 || v3 != dword_100732E4 )
    {
      if ( dword_10075790 )
      {
        if ( TimeZoneInformation.DaylightDate.wYear )
        {
          v21 = TimeZoneInformation.DaylightDate.wDay;
          v19 = 0;
          v17 = 0;
          v15 = TimeZoneInformation.DaylightDate.wMonth;
          v13 = *(_DWORD *)(a2 + 20);
          v11 = 0;
        }
        else
        {
          v21 = 0;
          v19 = TimeZoneInformation.DaylightDate.wDayOfWeek;
          v17 = TimeZoneInformation.DaylightDate.wDay;
          v15 = TimeZoneInformation.DaylightDate.wMonth;
          v13 = *(_DWORD *)(a2 + 20);
          v11 = 1;
        }
        loc_1003AA48(
          1,
          v11,
          v13,
          v15,
          v17,
          v19,
          v21,
          TimeZoneInformation.DaylightDate.wHour,
          TimeZoneInformation.DaylightDate.wMinute,
          TimeZoneInformation.DaylightDate.wSecond,
          TimeZoneInformation.DaylightDate.wMilliseconds);
        if ( TimeZoneInformation.StandardDate.wYear )
        {
          v22 = TimeZoneInformation.StandardDate.wDay;
          v20 = 0;
          v18 = 0;
          v16 = TimeZoneInformation.StandardDate.wMonth;
          v14 = *(_DWORD *)(a2 + 20);
          v12 = 0;
        }
        else
        {
          v22 = 0;
          v20 = TimeZoneInformation.StandardDate.wDayOfWeek;
          v18 = TimeZoneInformation.StandardDate.wDay;
          v16 = TimeZoneInformation.StandardDate.wMonth;
          v14 = *(_DWORD *)(a2 + 20);
          v12 = 1;
        }
        loc_1003AA48(
          0,
          v12,
          v14,
          v16,
          v18,
          v20,
          v22,
          TimeZoneInformation.StandardDate.wHour,
          TimeZoneInformation.StandardDate.wMinute,
          TimeZoneInformation.StandardDate.wSecond,
          TimeZoneInformation.StandardDate.wMilliseconds);
      }
      else
      {
        v4 = 3;
        v5 = 2;
        v6 = 1;
        v7 = 11;
        if ( v3 < 107 )
        {
          v4 = 4;
          v7 = 10;
          v5 = 1;
          v6 = 5;
        }
        loc_1003AA48(1, 1, v3, v4, v5, 0, 0, 2, 0, 0, 0);
        loc_1003AA48(0, 1, *(_DWORD *)(a2 + 20), v7, v6, 0, 0, 2, 0, 0, 0);
      }
    }
    v8 = *(_DWORD *)(a2 + 28);
    if ( dword_100732DC >= dword_100732E8 )
    {
      if ( v8 < dword_100732E8 || v8 > dword_100732DC )
        goto LABEL_21;
      if ( v8 <= dword_100732E8 || v8 >= dword_100732DC )
        goto LABEL_28;
    }
    else
    {
      if ( v8 >= dword_100732DC && v8 <= dword_100732E8 )
      {
        if ( v8 > dword_100732DC && v8 < dword_100732E8 )
        {
LABEL_21:
          LOBYTE(v2) = 1;
          return v2;
        }
LABEL_28:
        v9 = 1000 * (*(_DWORD *)a2 + 60 * (*(_DWORD *)(a2 + 4) + 60 * *(_DWORD *)(a2 + 8)));
        if ( v8 == dword_100732DC )
          LOBYTE(v2) = v9 >= dword_100732E0;
        else
          LOBYTE(v2) = v9 < dword_100732EC;
        return v2;
      }
    }
    LOBYTE(v2) = 0;
  }
  return v2;
}
// 100732D8: using guessed type int dword_100732D8;
// 100732DC: using guessed type int dword_100732DC;
// 100732E0: using guessed type int dword_100732E0;
// 100732E4: using guessed type int dword_100732E4;
// 100732E8: using guessed type int dword_100732E8;
// 100732EC: using guessed type int dword_100732EC;
// 10075790: using guessed type int dword_10075790;

//----- (1003A714) --------------------------------------------------------
void __usercall sub_1003A714(int a1<edx>, int a2<ecx>, int a3<edi>)
{
  int v3; // eax@4
  int v4; // eax@10
  int v5; // edx@10
  int v6; // ecx@10
  int v7; // eax@12
  int v21; // [sp+18h] [bp-38h]@23
  BOOL UsedDefaultChar; // [sp+20h] [bp-30h]@23
  int v23; // [sp+24h] [bp-2Ch]@1
  int v24; // [sp+28h] [bp-28h]@1
  int v25; // [sp+2Ch] [bp-24h]@1
  void **v26; // [sp+30h] [bp-20h]@1
  int v27; // [sp+34h] [bp-1Ch]@1
  CPPEH_RECORD ms_exc; // [sp+38h] [bp-18h]@1

  v23 = 0;
  v27 = 0;
  v25 = 0;
  v24 = 0;
  sub_10036A23(a1, a2, 0, a3, 7);
  ms_exc.disabled = 0;
  v26 = sub_1003A19E();
  if ( !sub_1003A1F8(0, a3, (int)&v27) && !sub_1003A1A4(0, a3, (int)&v25) && !sub_1003A1CE(0, a3, (int)&v24) )
  {
    v21 = sub_10036E87(0, a3);
    dword_10075790 = 0;
    dword_100732E4 = -1;
    dword_100732D8 = -1;
    v3 = sub_1004B050(0, (int)"TZ");
    a3 = v3;
    if ( !v3 || !*(_BYTE *)v3 )
      goto LABEL_14;
    if ( lpMem )
    {
      if ( !sub_100392F0(v3, (int)lpMem) )
      {
LABEL_11:
        v23 = 1;
        goto LABEL_32;
      }
      if ( lpMem )
        sub_100309C2(0, lpMem);
    }
    v4 = sub_10035530(a3);
    lpMem = (LPVOID)sub_10037530(v5, v6, 0, v4 + 1);
    if ( !lpMem )
      goto LABEL_11;
    v7 = sub_10035530(a3);
    if ( !sub_1003ADD5(0, a3, (int)lpMem, v7 + 1, a3) )
      goto LABEL_32;
  }
  sub_1003A161(0, a3);
LABEL_14:
  if ( lpMem )
  {
    sub_100309C2(0, lpMem);
    lpMem = 0;
  }
  if ( GetTimeZoneInformation(&TimeZoneInformation) != -1 )
  {
    dword_10075790 = 1;
    v27 = 60 * TimeZoneInformation.Bias;
    if ( TimeZoneInformation.StandardDate.wMonth )
      v27 = 60 * TimeZoneInformation.StandardBias + 60 * TimeZoneInformation.Bias;
    if ( TimeZoneInformation.DaylightDate.wMonth && TimeZoneInformation.DaylightBias )
    {
      v25 = 1;
      v24 = 60 * (TimeZoneInformation.DaylightBias - TimeZoneInformation.StandardBias);
    }
    else
    {
      v25 = 0;
      v24 = 0;
    }
    if ( !WideCharToMultiByte(v21, 0, TimeZoneInformation.StandardName, -1, (LPSTR)*v26, 63, 0, &UsedDefaultChar)
      || UsedDefaultChar )
      *(_BYTE *)*v26 = 0;
    else
      *((_BYTE *)*v26 + 63) = 0;
    if ( !WideCharToMultiByte(v21, 0, TimeZoneInformation.DaylightName, -1, (LPSTR)v26[1], 63, 0, &UsedDefaultChar)
      || UsedDefaultChar )
      *(_BYTE *)v26[1] = 0;
    else
      *((_BYTE *)v26[1] + 63) = 0;
  }
  v23 = 1;
LABEL_32:
  *sub_1003A198() = v27;
  *sub_1003A18C() = v25;
  *sub_1003A192() = v24;
  ms_exc.disabled = -2;
  sub_10036B87(7);
}
// 100732D8: using guessed type int dword_100732D8;
// 100732E4: using guessed type int dword_100732E4;
// 10075790: using guessed type int dword_10075790;

//----- (1003AC40) --------------------------------------------------------
int __stdcall sub_1003AC40(unsigned __int64 a1, unsigned int a2, int a3)
{
  signed int v3; // edi@1
  int v4; // eax@3
  int result; // eax@6
  unsigned __int64 v6; // qtt@6
  unsigned __int64 v7; // qax@7
  unsigned int v8; // ecx@7
  unsigned int v9; // ebx@7
  char v10; // cf@8
  char v11; // cf@8
  int v12; // eax@9
  unsigned __int64 v13; // qax@9
  int v14; // esi@9
  int v15; // ecx@9
  char v16; // cf@9

  v3 = 0;
  if ( HIDWORD(a1) < 0 )
  {
    v3 = 1;
    HIDWORD(a1) = -HIDWORD(a1) - ((_DWORD)a1 != 0);
    LODWORD(a1) = -(_DWORD)a1;
  }
  v4 = a3;
  if ( a3 < 0 )
  {
    ++v3;
    v4 = -a3 - (a2 != 0);
    a3 = -a3 - (a2 != 0);
    a2 = -a2;
  }
  if ( v4 )
  {
    v9 = v4;
    v8 = a2;
    v7 = a1;
    do
    {
      v10 = v9 & 1;
      v9 >>= 1;
      v8 = __RCR__(v8, v10);
      v11 = BYTE4(v7) & 1;
      HIDWORD(v7) >>= 1;
      LODWORD(v7) = __RCR__(v7, v11);
    }
    while ( v9 );
    v12 = v7 / v8;
    v14 = v12;
    v15 = a3 * v12;
    v13 = v12 * a2;
    v16 = v15 >= (unsigned int)-HIDWORD(v13);
    HIDWORD(v13) += v15;
    if ( v16 || HIDWORD(v13) > HIDWORD(a1) || v13 > a1 )
      --v14;
    result = v14;
  }
  else
  {
    LODWORD(v6) = a1;
    HIDWORD(v6) = HIDWORD(a1) % a2;
    result = v6 / a2;
  }
  if ( v3 == 1 )
    result = -result;
  return result;
}

//----- (1003ACF0) --------------------------------------------------------
int __stdcall sub_1003ACF0(unsigned __int64 a1, __int64 a2)
{
  signed int v2; // edi@1
  int v3; // eax@3
  unsigned __int64 v4; // qax@6
  unsigned __int64 v5; // qtt@6
  unsigned __int64 v6; // qax@8
  unsigned int v7; // ecx@8
  unsigned int v8; // ebx@8
  char v9; // cf@9
  char v10; // cf@9
  int v11; // eax@10
  unsigned __int64 v12; // qax@10
  int v13; // ecx@10
  char v14; // cf@10

  v2 = 0;
  if ( HIDWORD(a1) < 0 )
  {
    v2 = 1;
    HIDWORD(a1) = -HIDWORD(a1) - ((_DWORD)a1 != 0);
    LODWORD(a1) = -(_DWORD)a1;
  }
  v3 = HIDWORD(a2);
  if ( HIDWORD(a2) < 0 )
  {
    v3 = -HIDWORD(a2) - ((_DWORD)a2 != 0);
    HIDWORD(a2) = -HIDWORD(a2) - ((_DWORD)a2 != 0);
    LODWORD(a2) = -(_DWORD)a2;
  }
  if ( !v3 )
  {
    LODWORD(v5) = a1;
    HIDWORD(v5) = HIDWORD(a1) % (_DWORD)a2;
    LODWORD(v4) = v5 % (unsigned int)a2;
    if ( v2 - 1 < 0 )
      return v4;
    goto LABEL_15;
  }
  v8 = v3;
  v7 = a2;
  v6 = a1;
  do
  {
    v9 = v8 & 1;
    v8 >>= 1;
    v7 = __RCR__(v7, v9);
    v10 = BYTE4(v6) & 1;
    HIDWORD(v6) >>= 1;
    LODWORD(v6) = __RCR__(v6, v10);
  }
  while ( v8 );
  v11 = v6 / v7;
  v13 = HIDWORD(a2) * v11;
  v12 = (unsigned int)a2 * v11;
  v14 = v13 >= (unsigned int)-HIDWORD(v12);
  HIDWORD(v12) += v13;
  if ( v14 || HIDWORD(v12) > HIDWORD(a1) || v12 > a1 )
    v12 -= a2;
  v4 = v12 - a1;
  if ( v2 - 1 < 0 )
LABEL_15:
    LODWORD(v4) = -(_DWORD)v4;
  return v4;
}

//----- (1003ADA2) --------------------------------------------------------
bool __cdecl sub_1003ADA2(int a1)
{
  PVOID v1; // eax@1

  v1 = DecodePointer(dword_10075844);
  return v1 && ((int (__cdecl *)(int))v1)(a1);
}

//----- (1003ADC8) --------------------------------------------------------
void *__cdecl sub_1003ADC8(void *a1)
{
  void *result; // eax@1

  result = a1;
  dword_10075844 = a1;
  return result;
}

//----- (1003ADD5) --------------------------------------------------------
signed int __usercall sub_1003ADD5<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  int v5; // edx@2
  int v6; // ecx@3
  int v7; // eax@5
  char v9; // al@8
  signed int v10; // [sp-4h] [bp-8h]@5

  if ( !a3 || (v5 = a4, !a4) )
    goto LABEL_5;
  v6 = a5;
  if ( !a5 )
  {
    *(_BYTE *)a3 = a5;
LABEL_5:
    v7 = sub_10037649(a1);
    v10 = 22;
LABEL_6:
    *(_DWORD *)v7 = v10;
    sub_1003A151(a1, a2);
    return v10;
  }
  do
  {
    v9 = *(_BYTE *)v6;
    *(_BYTE *)(a3 - a5 + v6) = *(_BYTE *)v6;
    ++v6;
    if ( !v9 )
      break;
    --v5;
  }
  while ( v5 );
  if ( !v5 )
  {
    *(_BYTE *)a3 = 0;
    v7 = sub_10037649(a1);
    v10 = 34;
    goto LABEL_6;
  }
  return 0;
}

//----- (1003AE2A) --------------------------------------------------------
int (__stdcall *__thiscall sub_1003AE2A(HMODULE this, int a2))()
{
  int (__stdcall *result)(); // eax@1
  HMODULE hModule; // [sp+0h] [bp-4h]@1

  hModule = this;
  result = (int (__stdcall *)())GetModuleHandleExW(0, L"mscoree.dll", &hModule);
  if ( result )
  {
    result = GetProcAddress(hModule, "CorExitProcess");
    if ( result )
      result = (int (__stdcall *)())((int (__stdcall *)(int))result)(a2);
  }
  return result;
}

//----- (1003AE5C) --------------------------------------------------------
void __thiscall sub_1003AE5C(HMODULE this, UINT uExitCode)
{
  sub_1003AE2A(this, uExitCode);
  ExitProcess(uExitCode);
}

//----- (1003AE72) --------------------------------------------------------
void __usercall sub_1003AE72(int a1<ebx>)
{
  PVOID v1; // edi@1
  LPVOID v2; // esi@1
  char v3; // zf@3
  LPVOID v4; // esi@5
  char v5; // zf@7

  v2 = dword_10075870;
  v1 = DecodePointer(Ptr);
  if ( dword_10075870 )
  {
    do
    {
      if ( !*(_DWORD *)v2 )
        break;
      sub_100309C2(a1, *(LPVOID *)v2);
      v3 = (char *)v2 + 4 == 0;
      v2 = (char *)v2 + 4;
    }
    while ( !v3 );
    v2 = dword_10075870;
  }
  sub_100309C2(a1, v2);
  v4 = dword_1007586C;
  dword_10075870 = 0;
  if ( dword_1007586C )
  {
    do
    {
      if ( !*(_DWORD *)v4 )
        break;
      sub_100309C2(0, *(LPVOID *)v4);
      v5 = (char *)v4 + 4 == 0;
      v4 = (char *)v4 + 4;
    }
    while ( !v5 );
    v4 = dword_1007586C;
  }
  sub_100309C2(0, v4);
  dword_1007586C = 0;
  sub_100309C2(0, dword_10075868);
  sub_100309C2(0, dword_10075864);
  dword_10075868 = 0;
  dword_10075864 = 0;
  if ( v1 != (PVOID)-1 )
  {
    if ( Ptr )
      sub_100309C2(0, v1);
  }
  Ptr = EncodePointer((PVOID)0xFFFFFFFF);
  if ( dword_100761A0 )
  {
    sub_100309C2(0, dword_100761A0);
    dword_100761A0 = 0;
  }
  if ( dword_100761A4 )
  {
    sub_100309C2(0, dword_100761A4);
    dword_100761A4 = 0;
  }
  if ( !InterlockedDecrement((volatile LONG *)lpAddend) )
  {
    if ( lpAddend != &unk_100737B8 )
    {
      sub_100309C2(a1, lpAddend);
      lpAddend = &unk_100737B8;
    }
  }
}

//----- (1003AF82) --------------------------------------------------------
void __usercall sub_1003AF82(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // edx@1
  int v6; // ST00_4@1

  sub_1003F5AC(a1, a2, a3, a4);
  sub_1003F609(a3, a5);
  sub_1003B03F(v5, v6, a3, a4, 0xFFu);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_1003AF9E);
}

//----- (1003AF9E) --------------------------------------------------------
void __usercall sub_1003AF9E(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  sub_1003B0DB(a1, a2, a3, a4, 0, 0, 1);
}

//----- (1003AFAE) --------------------------------------------------------
int __usercall sub_1003AFAE<eax>(int a1<eax>, int a2<ebx>, int a3<edi>, int a4)
{
  int result; // eax@4
  int v5; // edx@4
  int v6; // eax@5
  unsigned int i; // esi@5
  int v8; // [sp-4h] [bp-4h]@4
  int v9; // [sp-4h] [bp-4h]@11

  if ( off_100617D0 )
  {
    if ( sub_1004B130(a1, (int)&off_100617D0) )
      off_100617D0(a4);
  }
  sub_1004AACC();
  result = sub_1003B0A7((unsigned int)&unk_1005F284, (unsigned int)&unk_1005F29C);
  if ( !result )
  {
    v6 = sub_1002B10A(v5, v8, a2, a3, sub_10048A81);
    for ( i = (unsigned int)&unk_1005F200; i < (unsigned int)&unk_1005F280; i += 4 )
    {
      v6 = *(_DWORD *)i;
      if ( *(_DWORD *)i )
        v6 = ((int (*)(void))v6)();
    }
    if ( dword_100778C4 )
    {
      if ( sub_1004B130(v6, (int)&dword_100778C4) )
        dword_100778C4(v9, 0, 2, 0);
    }
    result = 0;
  }
  return result;
}
// 100617D0: using guessed type int (__cdecl *off_100617D0)(_DWORD);
// 100778C4: using guessed type int (__thiscall *dword_100778C4)(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (1003B03F) --------------------------------------------------------
void __usercall sub_1003B03F(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, UINT uExitCode)
{
  sub_1003B0DB(a1, a2, a3, a4, uExitCode, 1, 0);
}

//----- (1003B053) --------------------------------------------------------
unsigned int __cdecl sub_1003B053()
{
  HMODULE v0; // edi@1
  unsigned int result; // eax@1
  PVOID v2; // esi@1

  v2 = EncodePointer(0);
  sub_1003ADC8(v2);
  sub_1003A119(v2);
  sub_1003F99B(v2);
  sub_1004B221((int)v2);
  sub_1004940E((int)v2);
  sub_1003B4B4();
  v0 = GetModuleHandleW(L"kernel32.dll");
  dword_100778E0 = __security_cookie ^ (int)GetProcAddress(v0, "FlsAlloc");
  dword_100778E4 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "FlsFree");
  dword_100778E8 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "FlsGetValue");
  dword_100778EC = __security_cookie ^ (unsigned int)GetProcAddress(v0, "FlsSetValue");
  dword_100778F0 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "InitializeCriticalSectionEx");
  dword_100778F4 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CreateSemaphoreExW");
  dword_100778F8 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "SetThreadStackGuarantee");
  dword_100778FC = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CreateThreadpoolTimer");
  dword_10077900 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "SetThreadpoolTimer");
  dword_10077904 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "WaitForThreadpoolTimerCallbacks");
  dword_10077908 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CloseThreadpoolTimer");
  dword_1007790C = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CreateThreadpoolWait");
  dword_10077910 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "SetThreadpoolWait");
  dword_10077914 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CloseThreadpoolWait");
  dword_10077918 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "FlushProcessWriteBuffers");
  dword_1007791C = __security_cookie ^ (unsigned int)GetProcAddress(v0, "FreeLibraryWhenCallbackReturns");
  dword_10077920 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetCurrentProcessorNumber");
  dword_10077924 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetLogicalProcessorInformation");
  dword_10077928 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CreateSymbolicLinkW");
  dword_1007792C = __security_cookie ^ (unsigned int)GetProcAddress(v0, "SetDefaultDllDirectories");
  dword_10077934 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "EnumSystemLocalesEx");
  dword_10077930 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "CompareStringEx");
  dword_10077938 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetDateFormatEx");
  dword_1007793C = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetLocaleInfoEx");
  dword_10077940 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetTimeFormatEx");
  dword_10077944 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetUserDefaultLocaleName");
  dword_10077948 = __security_cookie ^ (unsigned int)GetProcAddress(v0, "IsValidLocaleName");
  dword_1007794C = __security_cookie ^ (unsigned int)GetProcAddress(v0, "LCMapStringEx");
  result = __security_cookie ^ (unsigned int)GetProcAddress(v0, "GetCurrentPackageId");
  dword_10077950 = result;
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 100778E0: using guessed type int dword_100778E0;
// 100778E4: using guessed type int dword_100778E4;
// 100778E8: using guessed type int dword_100778E8;
// 100778EC: using guessed type int dword_100778EC;
// 100778F0: using guessed type int dword_100778F0;
// 100778F4: using guessed type int dword_100778F4;
// 100778F8: using guessed type int dword_100778F8;
// 100778FC: using guessed type int dword_100778FC;
// 10077900: using guessed type int dword_10077900;
// 10077904: using guessed type int dword_10077904;
// 10077908: using guessed type int dword_10077908;
// 1007790C: using guessed type int dword_1007790C;
// 10077910: using guessed type int dword_10077910;
// 10077914: using guessed type int dword_10077914;
// 10077918: using guessed type int dword_10077918;
// 1007791C: using guessed type int dword_1007791C;
// 10077920: using guessed type int dword_10077920;
// 10077924: using guessed type int dword_10077924;
// 10077928: using guessed type int dword_10077928;
// 1007792C: using guessed type int dword_1007792C;
// 10077930: using guessed type int dword_10077930;
// 10077934: using guessed type int dword_10077934;
// 10077938: using guessed type int dword_10077938;
// 1007793C: using guessed type int dword_1007793C;
// 10077940: using guessed type int dword_10077940;
// 10077944: using guessed type int dword_10077944;
// 10077948: using guessed type int dword_10077948;
// 1007794C: using guessed type int dword_1007794C;
// 10077950: using guessed type int dword_10077950;

//----- (1003B08B) --------------------------------------------------------
void __cdecl sub_1003B08B(unsigned int a1, unsigned int a2)
{
  unsigned int i; // esi@1

  for ( i = a1; i < a2; i += 4 )
  {
    if ( *(_DWORD *)i )
      (*(void (**)(void))i)();
  }
}

//----- (1003B0A7) --------------------------------------------------------
int __cdecl sub_1003B0A7(unsigned int a1, unsigned int a2)
{
  int result; // eax@1
  unsigned int v3; // esi@1

  v3 = a1;
  result = 0;
  while ( v3 < a2 && !result )
  {
    if ( *(_DWORD *)v3 )
      result = (*(int (**)(void))v3)();
    v3 += 4;
  }
  return result;
}

//----- (1003B0C9) --------------------------------------------------------
void __usercall sub_1003B0C9(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  sub_10036A23(a1, a2, a3, a4, 8);
}

//----- (1003B0D2) --------------------------------------------------------
void __cdecl sub_1003B0D2()
{
  sub_10036B87(8);
}

//----- (1003B0DB) --------------------------------------------------------
void __usercall sub_1003B0DB(int a1<edx>, int ecx0<ecx>, int ebx0<ebx>, int a4<edi>, UINT uExitCode, int a2, int a3)
{
  PVOID v7; // ebx@3
  PVOID (__stdcall *v8)(PVOID); // esi@3
  PVOID v9; // edi@4
  PVOID v10; // eax@8
  void (*v11)(void); // esi@8
  PVOID v12; // [sp+14h] [bp-28h]@8
  PVOID v13; // [sp+1Ch] [bp-20h]@4
  PVOID v14; // [sp+20h] [bp-1Ch]@4

  sub_10036A23(a1, ecx0, ebx0, a4, 8);
  if ( dword_1007585C != 1 )
  {
    dword_10075850 = 1;
    byte_1007584C = a3;
    if ( !a2 )
    {
      v8 = DecodePointer;
      v7 = DecodePointer(Ptr);
      if ( v7 )
      {
        v9 = DecodePointer(dword_100778C8);
        v14 = v7;
        v13 = v9;
        while ( 1 )
        {
          v9 = (char *)v9 - 4;
          if ( v9 < v7 )
            break;
          if ( *(PVOID *)v9 != EncodePointer(0) )
          {
            if ( v9 < v7 )
              break;
            v11 = (void (*)(void))v8(*(PVOID *)v9);
            *(_DWORD *)v9 = EncodePointer(0);
            v11();
            v8 = DecodePointer;
            v12 = DecodePointer(Ptr);
            v10 = DecodePointer(dword_100778C8);
            if ( v14 != v12 || v13 != v10 )
            {
              v14 = v12;
              v7 = v12;
              v13 = v10;
              v9 = v10;
            }
          }
        }
      }
      sub_1003B08B((unsigned int)&unk_1005F2A0, (unsigned int)&unk_1005F2B4);
    }
    sub_1003B08B((unsigned int)&unk_1005F2B8, (unsigned int)&unk_1005F2BC);
  }
  if ( a3 )
    sub_10036B87(8);
}
// 1007584C: using guessed type char byte_1007584C;
// 10075850: using guessed type int dword_10075850;
// 1007585C: using guessed type int dword_1007585C;

//----- (1003B20A) --------------------------------------------------------
SIZE_T __usercall sub_1003B20A<eax>(int a1<ebx>, int a2<edi>, LPCVOID lpMem)
{
  SIZE_T result; // eax@2

  if ( lpMem )
  {
    result = HeapSize(hHeap, 0, lpMem);
  }
  else
  {
    *(_DWORD *)sub_10037649(a1) = 22;
    sub_1003A151(a1, a2);
    result = -1;
  }
  return result;
}

//----- (1003B2A0) --------------------------------------------------------
int __cdecl sub_1003B2A0(PEXCEPTION_RECORD ExceptionRecord, int TargetFrame, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  int v6; // eax@4
  void *v7; // ecx@5
  int v8; // eax@5
  int v9; // eax@6
  char v10; // cl@6
  int v11; // eax@12
  char v13; // [sp+0h] [bp-24h]@3
  char v14; // [sp+0h] [bp-24h]@3
  PEXCEPTION_RECORD v15; // [sp+Ch] [bp-18h]@4
  int v16; // [sp+10h] [bp-14h]@4
  int v17; // [sp+14h] [bp-10h]@5
  int v18; // [sp+18h] [bp-Ch]@1
  unsigned int v19; // [sp+1Ch] [bp-8h]@4
  char v20; // [sp+23h] [bp-1h]@1

  v3 = TargetFrame;
  v4 = __security_cookie ^ *(_DWORD *)(TargetFrame + 8);
  v20 = 0;
  v18 = 1;
  v5 = TargetFrame + 16;
  if ( *(_DWORD *)v4 != -2 )
    sub_1002A49B(TargetFrame, v4, v5, *(_DWORD *)(*(_DWORD *)v4 + v5) ^ (v5 + *(_DWORD *)(v4 + 4)), v13);
  sub_1002A49B(TargetFrame, v4, v5, *(_DWORD *)(*(_DWORD *)(v4 + 8) + v5) ^ (v5 + *(_DWORD *)(v4 + 12)), v13);
  if ( ExceptionRecord->ExceptionFlags & 0x66 )
  {
    if ( *(_DWORD *)(TargetFrame + 12) == -2 )
      return v18;
    sub_1004B36B(TargetFrame, 0xFFFFFFFEu, v5, (int)&__security_cookie);
  }
  else
  {
    v15 = ExceptionRecord;
    v16 = a3;
    *(_DWORD *)(TargetFrame - 4) = &v15;
    v6 = *(_DWORD *)(TargetFrame + 12);
    v19 = v6;
    if ( v6 == -2 )
      return v18;
    do
    {
      v8 = 3 * v6 + 4;
      v7 = *(void **)(v4 + 4 * v8 + 4);
      v3 = *(_DWORD *)(v4 + 4 * v8);
      v17 = v4 + 4 * v8;
      if ( v7 )
      {
        v9 = sub_1004B322(v7);
        v10 = 1;
        v20 = 1;
        if ( v9 < 0 )
        {
          v18 = 0;
          goto LABEL_23;
        }
        if ( v9 > 0 )
        {
          if ( ExceptionRecord->ExceptionCode == -529697949 )
          {
            if ( off_10060FC4 )
            {
              if ( sub_1004B130((int)ExceptionRecord, (int)&off_10060FC4) )
                off_10060FC4(ExceptionRecord, 1);
            }
          }
          sub_1004B352((PVOID)TargetFrame, ExceptionRecord);
          v11 = TargetFrame;
          if ( *(_DWORD *)(TargetFrame + 12) != v19 )
          {
            sub_1004B36B(TargetFrame, v19, v5, (int)&__security_cookie);
            v11 = TargetFrame;
          }
          *(_DWORD *)(v11 + 12) = v3;
          if ( *(_DWORD *)v4 != -2 )
            sub_1002A49B(v3, v4, v5, *(_DWORD *)(*(_DWORD *)v4 + v5) ^ (v5 + *(_DWORD *)(v4 + 4)), v14);
          sub_1002A49B(v3, v4, v5, *(_DWORD *)(*(_DWORD *)(v4 + 8) + v5) ^ (v5 + *(_DWORD *)(v4 + 12)), v14);
          sub_1004B339(*(_DWORD *)(v17 + 8), v5);
          __asm { int     3               ; Trap to Debugger }
          JUMPOUT(*(int *)sub_1003B435);
        }
      }
      else
      {
        v10 = v20;
      }
      v6 = v3;
      v19 = v3;
    }
    while ( v3 != -2 );
    if ( !v10 )
      return v18;
  }
LABEL_23:
  if ( *(_DWORD *)v4 != -2 )
    sub_1002A49B(v3, v4, v5, *(_DWORD *)(*(_DWORD *)v4 + v5) ^ (v5 + *(_DWORD *)(v4 + 4)), v14);
  sub_1002A49B(v3, v4, v5, *(_DWORD *)(*(_DWORD *)(v4 + 8) + v5) ^ (v5 + *(_DWORD *)(v4 + 12)), v14);
  return v18;
}
// 10060FC4: using guessed type int (__cdecl *off_10060FC4)(_DWORD, _DWORD);
// 10073200: using guessed type int __security_cookie;

//----- (1003B435) --------------------------------------------------------
void __usercall sub_1003B435(int a1<ebx>, int a2<edi>)
{
  void (*v2)(void); // eax@1

  v2 = (void (*)(void))DecodePointer(dword_1007587C);
  if ( v2 )
    v2();
  sub_1003B46D(a1, a2);
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_1003B46D);
}

//----- (1003B46D) --------------------------------------------------------
void __usercall sub_1003B46D(int a1<ebx>, int a2<edi>)
{
  void (*v2)(void); // eax@1

  v2 = *(void (**)(void))(sub_10041952(a1, a2) + 120);
  if ( v2 )
    v2();
  loc_1003929F();
  __asm { int     3               ; Trap to Debugger }
  JUMPOUT(*(int *)sub_1003B4A1);
}

//----- (1003B4A1) --------------------------------------------------------
void __usercall sub_1003B4A1(int a1<ebx>, int a2<edi>)
{
  void (*v2)(void); // eax@1

  v2 = *(void (**)(void))(sub_10041952(a1, a2) + 124);
  if ( v2 )
    v2();
  sub_1003B46D(a1, a2);
}

//----- (1003B4B4) --------------------------------------------------------
PVOID __cdecl sub_1003B4B4()
{
  PVOID result; // eax@1

  result = EncodePointer(sub_1003B46D);
  dword_1007587C = result;
  return result;
}

//----- (1003B4C5) --------------------------------------------------------
int __cdecl sub_1003B4C5()
{
  int v0; // esi@1
  HMODULE v1; // esi@1
  int v2; // eax@3
  HMODULE v3; // eax@3
  int v4; // eax@4
  int result; // eax@6
  char v6; // [sp+8h] [bp-14h]@9
  int v7; // [sp+18h] [bp-4h]@1

  v1 = GetModuleHandleW(L"kernel32.dll");
  v7 = (int)GetProcAddress(v1, "SetThreadGroupAffinity");
  v0 = (int)GetProcAddress(v1, "GetThreadGroupAffinity");
  if ( !v7 || !v0 )
  {
    v4 = GetLastError();
    if ( v4 > 0 )
LABEL_8:
      v4 = (unsigned __int16)v4 | 0x80070000;
LABEL_9:
    sub_10030079((int)&v6, v4);
    sub_100355BB((int)&v6, (int)&unk_1006B6E0);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003B577);
  }
  dword_10075884 = sub_100348F9(v7);
  dword_10075888 = sub_100348F9(v0);
  v3 = GetModuleHandleW(L"kernel32.dll");
  v2 = (int)GetProcAddress(v3, "GetCurrentProcessorNumberEx");
  if ( !v2 )
  {
    v4 = GetLastError();
    if ( v4 > 0 )
      goto LABEL_8;
    goto LABEL_9;
  }
  result = sub_100348F9(v2);
  dword_10075880 = result;
  return result;
}
// 10075880: using guessed type int dword_10075880;
// 10075884: using guessed type int dword_10075884;
// 10075888: using guessed type int dword_10075888;

//----- (1003B577) --------------------------------------------------------
DWORD __cdecl sub_1003B577(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent)
{
  DWORD result; // eax@2

  do
  {
    result = DeleteTimerQueueTimer(TimerQueue, Timer, CompletionEvent);
    if ( result )
      break;
    result = GetLastError();
  }
  while ( result != 997 );
  return result;
}

//----- (1003B59E) --------------------------------------------------------
int __cdecl sub_1003B59E(int a1)
{
  int v2; // eax@1
  int v3; // ST00_4@1

  v2 = sub_100348F9(dword_10075880);
  return ((int (__thiscall *)(int, int))v2)(v3, a1);
}
// 10075880: using guessed type int dword_10075880;

//----- (1003B5B4) --------------------------------------------------------
int __usercall sub_1003B5B4<eax>(int a1<ebx>, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // ST04_4@1
  int v5; // eax@2
  int v6; // eax@4
  int v7; // ebx@4
  int v8; // eax@5
  int v10; // [sp-4h] [bp-24h]@5
  char v11; // [sp+Ch] [bp-14h]@11
  int (__stdcall **v12)(char); // [sp+10h] [bp-10h]@5
  int v13; // [sp+1Ch] [bp-4h]@5

  sub_10039546(0, a2);
  if ( ((int (__thiscall *)(int))GetLastError)(v4) != 122 )
  {
    v5 = GetLastError();
    if ( v5 > 0 )
LABEL_10:
      v5 = (unsigned __int16)v5 | 0x80070000;
LABEL_11:
    sub_10030079((int)&v11, v5);
    v10 = (int)&unk_1006B6E0;
    v8 = (int)&v11;
    goto LABEL_12;
  }
  v6 = sub_10030930(v2, v3, a1, a2, *(_DWORD *)a2);
  v7 = v6;
  if ( !v6 )
  {
    v13 = (int)"bad allocation";
    sub_1002AEC9((int)&v12, (int)&v13, 1);
    v12 = &off_1005F2C4;
    v10 = (int)&unk_1006AA70;
    v8 = (int)&v12;
LABEL_12:
    sub_100355BB(v8, v10);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003B64F);
  }
  if ( !sub_10039546(v6, a2) )
  {
    v5 = GetLastError();
    if ( v5 > 0 )
      goto LABEL_10;
    goto LABEL_11;
  }
  return v7;
}
// 1003B64F: using guessed type int __cdecl sub_1003B64F(int, int);
// 1005F2C4: using guessed type int (__stdcall *off_1005F2C4)(char);

//----- (1003B64F) --------------------------------------------------------
int __cdecl sub_1003B64F(int a1, int a2)
{
  FARPROC v2; // eax@1
  int v3; // edi@1
  HMODULE v4; // eax@1
  int v5; // eax@2
  int v6; // edx@4
  int v7; // ecx@4
  int v8; // ebx@7
  int v9; // eax@8
  int v11; // [sp-10h] [bp-30h]@7
  int v12; // [sp-4h] [bp-24h]@4
  char v13; // [sp+Ch] [bp-14h]@12
  int (__stdcall **v14)(char); // [sp+10h] [bp-10h]@8
  int v15; // [sp+1Ch] [bp-4h]@8

  v4 = GetModuleHandleW(L"kernel32.dll");
  v2 = GetProcAddress(v4, "GetLogicalProcessorInformationEx");
  v3 = (int)v2;
  if ( !v2 )
  {
    v5 = GetLastError();
    if ( v5 > 0 )
LABEL_11:
      v5 = (unsigned __int16)v5 | 0x80070000;
LABEL_12:
    sub_10030079((int)&v13, v5);
    v12 = (int)&unk_1006B6E0;
    v9 = (int)&v13;
    goto LABEL_13;
  }
  v12 = a2;
  ((void (__cdecl *)(int, _DWORD))v2)(a1, 0);
  if ( GetLastError() != 122 )
    goto LABEL_17;
  v8 = sub_10030930(v6, v7, a2, v3, *(_DWORD *)a2);
  if ( !v8 )
  {
    v15 = (int)"bad allocation";
    sub_1002AEC9((int)&v14, (int)&v15, 1);
    v14 = &off_1005F2C4;
    v9 = (int)&v14;
LABEL_13:
    sub_100355BB(v9, v12);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003B709);
  }
  if ( !((int (__thiscall *)(int))v3)(v11) )
  {
LABEL_17:
    v5 = GetLastError();
    if ( v5 > 0 )
      goto LABEL_11;
    goto LABEL_12;
  }
  return v8;
}
// 1003B64F: using guessed type int __cdecl sub_1003B64F(int, int);
// 1005F2C4: using guessed type int (__stdcall *off_1005F2C4)(char);

//----- (1003B709) --------------------------------------------------------
signed int __cdecl sub_1003B709(int a1, int a2)
{
  int v2; // eax@2
  int v3; // ST08_4@2
  HANDLE v4; // eax@3
  ULONG_PTR SystemAffinityMask; // [sp+0h] [bp-8h]@3
  ULONG_PTR ProcessAffinityMask; // [sp+4h] [bp-4h]@3

  if ( sub_1003D685() < 4 )
  {
    v4 = GetCurrentProcess();
    GetProcessAffinityMask(v4, &ProcessAffinityMask, &SystemAffinityMask);
    *(_WORD *)(a2 + 4) = 0;
    *(_DWORD *)a2 = ProcessAffinityMask;
  }
  else
  {
    v2 = sub_100348F9(dword_10075888);
    ((void (__thiscall *)(int, int, int))v2)(v3, a1, a2);
  }
  return 1;
}
// 1003D685: using guessed type int sub_1003D685(void);
// 10075888: using guessed type int dword_10075888;

//----- (1003B756) --------------------------------------------------------
signed int __cdecl sub_1003B756(HANDLE hThread, DWORD_PTR *a2)
{
  int v2; // eax@2
  int v3; // ST08_4@2

  if ( sub_1003D685() < 4 )
  {
    SetThreadAffinityMask(hThread, *a2);
  }
  else
  {
    v2 = sub_100348F9(dword_10075884);
    ((void (__thiscall *)(int, HANDLE, DWORD_PTR *, _DWORD))v2)(v3, hThread, a2, 0);
  }
  return 1;
}
// 1003D685: using guessed type int sub_1003D685(void);
// 10075884: using guessed type int dword_10075884;

//----- (1003B78E) --------------------------------------------------------
int __thiscall sub_1003B78E(int this, int a2)
{
  int v3; // esi@1

  v3 = this;
  *(_DWORD *)this = 0;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  sub_1003B709(a2, this);
  return v3;
}

//----- (1003B7AF) --------------------------------------------------------
#error "1003B8A3: call analysis failed (funcsize=78)"

//----- (1003B8A9) --------------------------------------------------------
int __userpurge sub_1003B8A9<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10060CFC;
  return v4;
}
// 10060CFC: using guessed type int (__stdcall *off_10060CFC)(char);

//----- (1003B8CE) --------------------------------------------------------
int __usercall sub_1003B8CE<eax>(int a1<ebp>)
{
  unsigned int v1; // edi@1
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // ebx@2
  int v5; // ecx@3
  int v6; // ecx@6
  void *v7; // eax@8
  int v8; // ecx@8
  int v9; // ST08_4@8

  sub_10035648();
  v2 = v3;
  *(_DWORD *)(a1 - 16) = v3;
  *(_DWORD *)v3 = off_10063C0C;
  v1 = 0;
  *(_DWORD *)(a1 - 4) = 1;
  if ( *(_DWORD *)(v3 + 24) )
  {
    v4 = 0;
    do
    {
      v5 = *(_DWORD *)(v4 + *(_DWORD *)(v2 + 72) + 32);
      if ( v5 )
        sub_1002A02D(v5, 3);
      ++v1;
      v4 += 40;
    }
    while ( v1 < *(_DWORD *)(v2 + 24) );
  }
  v6 = *(_DWORD *)(v2 + 72);
  if ( v6 )
    sub_1003B995(v6, 3);
  sub_100303A3(*(LPVOID *)(v2 + 68));
  v7 = *(void **)(v2 + 140);
  v8 = v9;
  if ( v7 )
    VirtualFree(v7, 0, 0x8000u);
  ((void (__thiscall *)(int, _DWORD))CloseHandle)(v8, *(_DWORD *)(v2 + 80));
  sub_100303A3(*(LPVOID *)(v2 + 84));
  if ( *(_DWORD *)(v2 + 76) )
  {
    CloseHandle(*(HANDLE *)(v2 + 76));
    sub_100303A3(*(LPVOID *)(v2 + 88));
    sub_100303A3(*(LPVOID *)(v2 + 92));
  }
  *(_BYTE *)(a1 - 4) = 0;
  sub_1004CED6(a1);
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002B6CE((LPCRITICAL_SECTION)(v2 + 44));
  return sub_10035616(4);
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 10063C0C: using guessed type int (*off_10063C0C[2])();

//----- (1003B995) --------------------------------------------------------
int __thiscall sub_1003B995(int this, char a2)
{
  void *v2; // esi@1
  int result; // eax@4

  v2 = (void *)this;
  if ( a2 & 2 )
  {
    sub_1002B11F(this, 40, *(_DWORD *)(this - 4), (void (__thiscall *)(_DWORD))sub_1003B8C4);
    if ( a2 & 1 )
      sub_100303A3((char *)v2 - 4);
    result = (int)((char *)v2 - 4);
  }
  else
  {
    sub_1002A4AA(*(LPVOID *)(this + 36));
    if ( a2 & 1 )
      sub_1002A4AA(v2);
    result = (int)v2;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 1003B8C4: using guessed type int sub_1003B8C4();

//----- (1003B9E3) --------------------------------------------------------
int __thiscall sub_1003B9E3(int this, int a2)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 4);
  if ( result )
  {
    *(_DWORD *)(a2 + 24) = *(_DWORD *)(result + 24);
    *(_DWORD *)(a2 + 28) = *(_DWORD *)(this + 4);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 4) + 24) + 28) = a2;
    result = *(_DWORD *)(this + 4);
    *(_DWORD *)(result + 24) = a2;
  }
  else
  {
    *(_DWORD *)(a2 + 24) = a2;
    *(_DWORD *)(a2 + 28) = a2;
  }
  *(_DWORD *)(this + 4) = a2;
  ++*(_DWORD *)this;
  return result;
}

//----- (1003BA1C) --------------------------------------------------------
unsigned int __thiscall sub_1003BA1C(int this, unsigned int a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4; // eax@1
  unsigned int v5; // esi@1
  unsigned int v6; // esi@5
  int v7; // edx@6
  unsigned int v8; // esi@10
  int v9; // edx@11

  v4 = a3;
  v5 = a2;
  if ( a2 >= a3 )
  {
    v8 = 0;
    if ( a4 )
    {
      do
      {
        v9 = *(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v8++);
        *(_DWORD *)(v9 + 4) = *(_DWORD *)(v9 + 36) - *(_DWORD *)(*(_DWORD *)(v9 + 16) + 160);
      }
      while ( v8 < a4 );
      v4 = a3;
    }
    v5 = v4;
  }
  else
  {
    if ( a4 == 1 )
    {
      *(_DWORD *)(**(_DWORD **)(this + 92) + 4) = a2;
    }
    else
    {
      if ( a4 )
      {
        v6 = 0;
        do
        {
          v7 = *(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v6++);
          *(double *)(v7 + 8) = (double)(unsigned int)(*(_DWORD *)(v7 + 36) - *(_DWORD *)(*(_DWORD *)(v7 + 16) + 160))
                              * (double)a2
                              / (double)a3;
        }
        while ( v6 < a4 );
        v5 = a2;
      }
      sub_1003EF44(*(_DWORD *)(this + 92), a4);
    }
  }
  return v5;
}

//----- (1003BAEC) --------------------------------------------------------
int __thiscall sub_1003BAEC(int this, int a2)
{
  int result; // eax@1

  result = sub_1003D3D4(this, *(_WORD *)(a2 + 4));
  if ( result )
  {
    result = *(_DWORD *)result;
    *(_DWORD *)a2 &= result;
  }
  else
  {
    *(_DWORD *)a2 = 0;
  }
  return result;
}

//----- (1003BB0F) --------------------------------------------------------
int __cdecl sub_1003BB0F(int a1)
{
  int result; // eax@1
  int v2; // [sp+4h] [bp-Ch]@1
  int v3; // [sp+8h] [bp-8h]@1
  int v4; // [sp+Ch] [bp-4h]@1

  v3 = 0;
  v4 = 0;
  LOWORD(v3) = 0;
  v2 = *(_DWORD *)a1;
  sub_1003BB3E((int)&v2);
  result = v2;
  *(_DWORD *)a1 = v2;
  return result;
}

//----- (1003BB3E) --------------------------------------------------------
int __cdecl sub_1003BB3E(int a1)
{
  int result; // eax@1
  int v2; // ecx@2

  result = a1;
  if ( *(_DWORD *)a1 )
  {
    v2 = dword_100758A0;
    if ( dword_100758A0 || (v2 = dword_1007589C, dword_1007589C) )
      result = sub_1003BAEC(v2, a1);
  }
  return result;
}
// 1007589C: using guessed type int dword_1007589C;
// 100758A0: using guessed type int dword_100758A0;

//----- (1003BB65) --------------------------------------------------------
signed int __thiscall sub_1003BB65(DWORD_PTR *this, HANDLE hThread)
{
  return sub_1003B756(hThread, this);
}

//----- (1003BB77) --------------------------------------------------------
int __usercall sub_1003BB77<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1
  HANDLE v5; // eax@1
  int v6; // eax@2
  int v7; // eax@7
  int v8; // edx@7
  int v9; // ecx@7
  int v10; // esi@7
  int v11; // ecx@7
  int v12; // ST08_4@7
  int v13; // eax@10
  int v14; // ST08_4@10
  int v15; // edx@14
  int v16; // esi@14
  int v17; // eax@15
  int v18; // edx@15
  int v19; // ST08_4@15
  int v21; // [sp-8h] [bp-8h]@14

  sub_1003567B();
  v5 = GetCurrentProcess();
  if ( !GetProcessAffinityMask(v5, &ProcessAffinityMask, &SystemAffinityMask) )
  {
    v6 = GetLastError();
    if ( v6 > 0 )
      v6 = (unsigned __int16)v6 | 0x80070000;
    sub_10030079(a2 - 48, v6);
    sub_100355BB(a2 - 48, (int)&unk_1006B6E0);
  }
  if ( ProcessAffinityMask != SystemAffinityMask )
  {
    if ( dword_100758B4 < 4 )
    {
      v16 = sub_1002ADB1(v3, v4, a1, a3, 8);
      v4 = v21;
      *(_DWORD *)(a2 - 32) = v16;
      *(_DWORD *)(a2 - 4) = 0;
      if ( v16 )
      {
        v17 = sub_1002ADB1(v15, v21, a1, a3, 12);
        v18 = v17;
        v4 = v19;
        if ( v17 )
        {
          v4 = ProcessAffinityMask;
          *(_DWORD *)v17 = 0;
          *(_DWORD *)(v17 + 4) = 0;
          *(_DWORD *)(v17 + 8) = 0;
          *(_WORD *)(v17 + 4) = 0;
          *(_DWORD *)v17 = v4;
        }
        else
        {
          v18 = 0;
        }
        *(_WORD *)v16 = 1;
        *(_DWORD *)(v16 + 4) = v18;
      }
      else
      {
        v16 = 0;
      }
      dword_100758A0 = v16;
    }
    else
    {
      v7 = (int)GetCurrentThread();
      sub_1003B78E(a2 - 28, v7);
      v10 = sub_1002ADB1(v8, v11, a1, a3, 12);
      v9 = v12;
      if ( v10 )
      {
        v9 = *(_WORD *)(a2 - 24);
        v8 = ProcessAffinityMask;
        *(_DWORD *)v10 = 0;
        *(_DWORD *)(v10 + 4) = 0;
        *(_DWORD *)(v10 + 8) = 0;
        a3 = v10 + 12;
        *(_WORD *)(v10 + 4) = v9;
        *(_DWORD *)v10 = v8;
      }
      else
      {
        v10 = 0;
      }
      v13 = sub_1002ADB1(v8, v9, a1, a3, 8);
      v4 = v14;
      if ( v13 )
      {
        v4 = 1;
        *(_WORD *)v13 = 1;
        *(_DWORD *)(v13 + 4) = v10;
      }
      else
      {
        v13 = 0;
      }
      dword_100758A0 = v13;
    }
  }
  return sub_1003562A(v4);
}
// 1003562A: using guessed type int __thiscall sub_1003562A(_DWORD);
// 100758A0: using guessed type int dword_100758A0;
// 100758B4: using guessed type int dword_100758B4;

//----- (1003BC8E) --------------------------------------------------------
void __usercall sub_1003BC8E(int a1<ebx>)
{
  sub_100309C2(a1, dword_100758BC);
  dword_100758BC = 0;
  dword_100758B8 = 0;
}
// 100758B8: using guessed type int dword_100758B8;

//----- (1003BCA9) --------------------------------------------------------
int __thiscall sub_1003BCA9(void *this, int a2)
{
  int result; // eax@1
  unsigned int v3; // ecx@1
  void *v4; // ebx@1
  int ebp0; // ebp@0
  int v6; // esi@2
  int v7; // edi@3
  int v8; // ecx@4
  signed int v9; // edx@5
  int v10; // eax@6
  int v11; // edx@7
  int v12; // ecx@7
  char v13; // zf@12
  int v14; // eax@22
  int v15; // [sp+4h] [bp-18h]@2
  unsigned int v16; // [sp+8h] [bp-14h]@1
  signed int v17; // [sp+Ch] [bp-10h]@5
  int v18; // [sp+10h] [bp-Ch]@5
  signed int v19; // [sp+14h] [bp-8h]@5
  int v20; // [sp+24h] [bp+8h]@4

  result = *(_DWORD *)(a2 + 16);
  v4 = this;
  v3 = 0;
  v16 = 0;
  if ( *((_DWORD *)v4 + 6) )
  {
    v6 = result + 4;
    v15 = -4 - result;
    do
    {
      v7 = 0;
      if ( *(_DWORD *)v6 )
      {
        v8 = 0;
        v20 = 0;
        do
        {
          v17 = 0;
          v9 = 1;
          result = v8 + *(_DWORD *)(v6 + 44);
          v18 = v8 + *(_DWORD *)(v6 + 44);
          v19 = 1;
          if ( *((_DWORD *)v4 + 2) > 1u )
          {
            do
            {
              v10 = *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v4 + 21) + 4 * v9) + 16);
              if ( *(_DWORD *)(v10 + 108) )
              {
                v12 = *(_DWORD *)(v10 + 16) + v6 + v15;
                v11 = v20 + *(_DWORD *)(v12 + 48);
                if ( *(_DWORD *)v11 == 5 )
                {
                  if ( *(_DWORD *)v18 != 4 )
                  {
                    ++**(_DWORD **)(v11 + 20);
                    v14 = *(_DWORD *)(v12 + 48);
                    v8 = v20;
                    *(_DWORD *)(v20 + v14) = 4;
                    goto LABEL_16;
                  }
                  if ( *(_DWORD *)(v18 + 24) || *(_BYTE *)(v11 + 48) || v17 )
                  {
                    sub_1004CAB7(ebp0, v12, v7);
                  }
                  else
                  {
                    ++**(_DWORD **)(v11 + 20);
                    v13 = *(_BYTE *)(v11 + 49) == 0;
                    *(_DWORD *)v11 = 4;
                    if ( v13 )
                      sub_1004CC9B(v10, v12, v7);
                    v17 = 1;
                  }
                }
                v8 = v20;
              }
LABEL_16:
              result = v19 + 1;
              v19 = result;
              v9 = result;
            }
            while ( (unsigned int)result < *((_DWORD *)v4 + 2) );
          }
          ++v7;
          v8 += 52;
          v20 = v8;
        }
        while ( (unsigned int)v7 < *(_DWORD *)v6 );
        v3 = v16;
      }
      ++v3;
      v6 += 52;
      v16 = v3;
    }
    while ( v3 < *((_DWORD *)v4 + 6) );
  }
  return result;
}

//----- (1003BDB6) --------------------------------------------------------
int __thiscall sub_1003BDB6(int this)
{
  int v1; // edi@1
  int v2; // esi@1

  v1 = this;
  v2 = *(_DWORD *)(this + 188);
  if ( v2 >= (unsigned int)(sub_1003C109(this) + 1) )
    v2 = sub_1003C109(v1) + 1;
  return v2;
}

//----- (1003BDD9) --------------------------------------------------------
int __thiscall sub_1003BDD9(int this)
{
  int v1; // edx@1
  int v2; // edi@1
  int v3; // esi@1
  int v4; // eax@1

  v3 = this;
  v2 = *(_DWORD *)(this + 184);
  v4 = sub_1003DDC2(this);
  v1 = *(_DWORD *)(v3 + 188);
  if ( v1 >= (unsigned int)(v2 + v4 + 1) )
    v1 = sub_1003DDC2(v3) + v2 + 1;
  return v1;
}

//----- (1003BE06) --------------------------------------------------------
int __usercall sub_1003BE06<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v3; // ebx@1
  int v4; // esi@1
  unsigned int v5; // eax@1
  signed __int64 v7; // qax@1
  int v8; // ecx@2
  int v9; // edx@3
  signed int v10; // edi@3
  unsigned int v11; // esi@3
  const void *v12; // eax@3
  signed __int64 v14; // qax@3
  int v15; // eax@4
  int v16; // ecx@5
  signed int v17; // ST0C_4@9
  int v18; // edx@10
  int v19; // ecx@10
  int v20; // edi@11
  int v21; // esi@11
  int v23; // [sp+Ch] [bp-1Ch]@1
  int v24; // [sp+10h] [bp-18h]@1
  int v25; // [sp+14h] [bp-14h]@2
  unsigned int v26; // [sp+18h] [bp-10h]@1
  int v27; // [sp+1Ch] [bp-Ch]@10
  unsigned int v28; // [sp+20h] [bp-8h]@9
  const void *v29; // [sp+24h] [bp-4h]@3

  v4 = a1;
  v5 = *(_DWORD *)(a1 + 24);
  _ECX = 0;
  v7 = 52i64 * v5;
  __asm { seto    cl }
  v24 = v4;
  v3 = sub_1002965B(SHIDWORD(v7), v7 | -_ECX, a2, a3, v7 | -_ECX);
  v23 = v3;
  sub_100391F0((void *)v3, 0, 52 * *(_DWORD *)(v4 + 24));
  v26 = 0;
  if ( *(_DWORD *)(v4 + 24) > 0u )
  {
    v8 = 0;
    v25 = 0;
    do
    {
      v12 = (const void *)(v8 + *(_DWORD *)(v4 + 72));
      memcpy((void *)v3, v12, 0x18u);
      v11 = *(_DWORD *)(v3 + 4);
      v29 = v12;
      _ECX = 0;
      v10 = 52;
      v14 = 52i64 * v11;
      __asm { seto    cl }
      v9 = sub_1002965B(SHIDWORD(v14), v14 | -_ECX, v3, 52, v14 | -_ECX);
      if ( v9 )
      {
        v15 = v11 - 1;
        if ( (signed int)(v11 - 1) >= 0 )
        {
          v16 = v9 + 12;
          do
          {
            *(_DWORD *)v16 = 0;
            *(_DWORD *)(v16 + 4) = 0;
            v16 += 52;
            --v15;
          }
          while ( v15 >= 0 );
        }
      }
      else
      {
        v9 = 0;
      }
      v17 = 52 * *(_DWORD *)(v3 + 4);
      *(_DWORD *)(v3 + 48) = v9;
      sub_100391F0((void *)v9, 0, v17);
      v28 = 0;
      if ( *(_DWORD *)(v3 + 4) )
      {
        v18 = 0;
        v19 = 0;
        v27 = 0;
        do
        {
          v20 = v18 + *(_DWORD *)(v3 + 48);
          v21 = v19 + *((_DWORD *)v29 + 8);
          *(_DWORD *)v20 = *(_DWORD *)v21;
          v21 += 4;
          v20 += 4;
          *(_DWORD *)v20 = *(_DWORD *)v21;
          *(_DWORD *)(v20 + 4) = *(_DWORD *)(v21 + 4);
          *(_DWORD *)(v18 + *(_DWORD *)(v3 + 48)) = 1;
          v10 = 52;
          *(_DWORD *)(v18 + *(_DWORD *)(v3 + 48) + 20) = *((_DWORD *)v29 + 8) + 16 + v19;
          v19 = v27 + 36;
          v18 += 52;
          ++v28;
          v27 += 36;
        }
        while ( v28 < *(_DWORD *)(v3 + 4) );
      }
      v4 = v24;
      v8 = v25 + 40;
      v3 += v10;
      ++v26;
      v25 += 40;
    }
    while ( v26 < *(_DWORD *)(v24 + 24) );
    v3 = v23;
  }
  return v3;
}

//----- (1003BF33) --------------------------------------------------------
void __thiscall sub_1003BF33(LPVOID lpParameter)
{
  HANDLE v1; // eax@1
  LPVOID v2; // esi@1
  int v3; // eax@2
  char v4; // [sp+4h] [bp-10h]@9

  v2 = lpParameter;
  v1 = sub_100349B9(0, 0x10000u, (LPTHREAD_START_ROUTINE)StartAddress, lpParameter, 0, 0);
  *((_DWORD *)v2 + 19) = v1;
  if ( !v1 )
  {
    v3 = GetLastError();
    if ( v3 > 0 )
LABEL_8:
      v3 = (unsigned __int16)v3 | 0x80070000;
LABEL_9:
    sub_10030079((int)&v4, v3);
    sub_100355BB((int)&v4, (int)&unk_1006B6E0);
    __asm { int     3               ; Trap to Debugger }
    return;
  }
  if ( !SetThreadPriority(v1, 15) )
  {
    v3 = GetLastError();
    if ( v3 > 0 )
      goto LABEL_8;
    goto LABEL_9;
  }
}

//----- (1003BFAB) --------------------------------------------------------
#error "1003BFFF: call analysis failed (funcsize=32)"

//----- (1003C007) --------------------------------------------------------
int __usercall sub_1003C007<eax>(int a1<ebp>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // edx@1
  int v4; // ecx@1
  int v5; // eax@2
  int v6; // edx@3
  int v7; // ecx@3
  int v8; // esi@3
  int v9; // esi@6
  int v10; // eax@8

  sub_10035648();
  *(_DWORD *)(a1 - 16) = &dword_10075F54;
  sub_10030FB0(&dword_10075F54);
  v2 = dword_10075890;
  *(_DWORD *)(a1 - 4) = 0;
  if ( v2 )
  {
    v8 = sub_100348F9(v2);
    if ( sub_1003F103((void *)v8) )
      goto LABEL_9;
    v5 = sub_1002ADB1(v6, v7, 0, a2, 144);
    *(_DWORD *)(a1 - 20) = v5;
    *(_BYTE *)(a1 - 4) = 2;
  }
  else
  {
    v5 = sub_1002ADB1(v3, v4, 0, a2, 144);
    *(_DWORD *)(a1 - 20) = v5;
    *(_BYTE *)(a1 - 4) = 1;
  }
  if ( v5 )
    v9 = sub_1003B7AF(v5);
  else
    v9 = 0;
  v10 = *(_DWORD *)v9;
  *(_BYTE *)(a1 - 4) = 0;
  (*(void (__thiscall **)(int))v10)(v9);
  dword_10075890 = sub_100348F9(v9);
LABEL_9:
  dword_10075F54 = 0;
  return sub_10035616(8);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 1003B7AF: using guessed type int __thiscall sub_1003B7AF(_DWORD);
// 10075890: using guessed type int dword_10075890;
// 10075F54: using guessed type int dword_10075F54;

//----- (1003C09C) --------------------------------------------------------
int __thiscall sub_1003C09C(int this, int a2, int a3)
{
  int v3; // ecx@1
  int v4; // ebx@1
  struct _RTL_CRITICAL_SECTION *v5; // esi@1
  int v6; // edi@1
  int v7; // ecx@2
  int v9; // [sp+Ch] [bp-8h]@1
  int v10; // [sp+10h] [bp-4h]@1

  v6 = this;
  v10 = this;
  v5 = (struct _RTL_CRITICAL_SECTION *)(this + 44);
  v4 = 0;
  v9 = this + 44;
  sub_1002B91D((LPCRITICAL_SECTION)(this + 44));
  v3 = *(_DWORD *)(v6 + 100);
  if ( v3 )
    v7 = *(_DWORD *)(v3 + 24);
  else
    v7 = 0;
  if ( v7 )
  {
    do
    {
      v4 += *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v7 + 16) + 52 * a2 + 48) + 52 * a3 + 24);
      if ( v7 == *(_DWORD *)(v10 + 100) )
        v7 = 0;
      else
        v7 = *(_DWORD *)(v7 + 24);
    }
    while ( v7 );
    v5 = (struct _RTL_CRITICAL_SECTION *)v9;
  }
  sub_1002BB52(v5);
  return v4;
}

//----- (1003C109) --------------------------------------------------------
int __thiscall sub_1003C109(int this)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 188);
  if ( result >= (unsigned int)(*(_DWORD *)(this + 128) + *(_DWORD *)(this + 184)) )
    result = *(_DWORD *)(this + 128) + *(_DWORD *)(this + 184);
  return result;
}

//----- (1003C122) --------------------------------------------------------
int __thiscall sub_1003C122(int this, int a2)
{
  void *v2; // ebx@1
  unsigned int v3; // esi@1
  int v4; // ebx@2
  LPVOID *v5; // edi@2

  v2 = (void *)a2;
  v3 = 0;
  if ( *(_DWORD *)(this + 24) )
  {
    v5 = (LPVOID *)(a2 + 48);
    v4 = this;
    do
    {
      sub_100303A3(*v5);
      ++v3;
      v5 += 13;
    }
    while ( v3 < *(_DWORD *)(v4 + 24) );
    v2 = (void *)a2;
  }
  return sub_100303A3(v2);
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (1003C15C) --------------------------------------------------------
void __usercall sub_1003C15C(int a1<ecx>, int a2<ebx>)
{
  int v2; // eax@1
  __int64 v3; // qcx@1
  int v4; // edi@1
  int v5; // esi@1
  signed __int64 v7; // qax@1
  int v8; // eax@1
  signed int v9; // ST10_4@1
  signed __int64 v11; // qax@1
  void *v12; // ecx@2
  int v13; // edx@4
  signed int v14; // ST14_4@4
  int v15; // edx@5
  int v16; // eax@10
  int v17; // edx@10
  int v18; // esi@10
  int v19; // eax@13
  unsigned __int8 v20; // sf@13
  unsigned __int8 v21; // of@13
  int v22; // esi@17
  int v23; // esi@18
  int v24; // edx@19
  LPVOID v25; // esi@23
  ULONG_PTR v26; // esi@25
  int v27; // edx@28
  int v28; // eax@31
  int v29; // eax@39
  unsigned int v30; // ebx@43
  int v31; // edx@44
  unsigned int v32; // ecx@45
  int v33; // esi@46
  int v34; // [sp+Ch] [bp-14h]@10
  void *v35; // [sp+Ch] [bp-14h]@38
  int v36; // [sp+10h] [bp-10h]@6
  int v37; // [sp+10h] [bp-10h]@29
  int v38; // [sp+14h] [bp-Ch]@10
  int v39; // [sp+14h] [bp-Ch]@28
  int v40; // [sp+18h] [bp-8h]@5
  int v41; // [sp+1Ch] [bp-4h]@5
  int v42; // [sp+1Ch] [bp-4h]@28

  v4 = a1;
  _ECX = 0;
  *(_DWORD *)(v4 + 20) = dword_100758B0;
  *(_DWORD *)(v4 + 24) = dword_100758AC;
  *(_DWORD *)(v4 + 28) = dword_100758A4;
  v7 = 12i64 * *(_DWORD *)(v4 + 20);
  __asm { seto    cl }
  v8 = sub_1002965B(SHIDWORD(v7), v7 | -_ECX, a2, v4, v7 | -_ECX);
  v9 = 12 * *(_DWORD *)(v4 + 20);
  *(_DWORD *)(v4 + 68) = v8;
  sub_100391F0((void *)v8, 0, v9);
  v5 = *(_DWORD *)(v4 + 24);
  _ECX = 0;
  v11 = 40i64 * *(_DWORD *)(v4 + 24);
  __asm { seto    cl }
  v3 = (_DWORD)v11 | (unsigned int)-_ECX;
  v2 = sub_1002965B(SHIDWORD(v11), v3 + 4, SHIDWORD(v3), v4, (v3 + 4) | -((_DWORD)v3 >= 0xFFFFFFFCu));
  if ( v2 )
  {
    *(_DWORD *)v2 = v5;
    v12 = (void *)(v2 + 4);
  }
  else
  {
    v12 = 0;
  }
  v14 = 40 * *(_DWORD *)(v4 + 24);
  *(_DWORD *)(v4 + 72) = v12;
  sub_100391F0(v12, 0, v14);
  if ( dword_100758B4 >= 4 )
  {
    LODWORD(v3) = 0;
    v15 = 0;
    HIDWORD(v3) = dword_100758BC;
    v40 = 0;
    v41 = 0;
    if ( dword_100758B8 )
    {
      v36 = 0;
      while ( 1 )
      {
        if ( *HIDWORD(v3) == 1 )
        {
          if ( !byte_100758A8 )
          {
            if ( *(_DWORD *)(HIDWORD(v3) + 32) )
            {
              v22 = 40 * v3;
              sub_1003D9A8(
                v15,
                40 * v3 + *(_DWORD *)(v4 + 72),
                SHIDWORD(v3),
                v4,
                v4,
                v3,
                *(_WORD *)(HIDWORD(v3) + 36),
                *(void **)(HIDWORD(v3) + 32),
                0,
                0);
              ++v41;
              v15 = v40;
              *(_DWORD *)(v22 + *(_DWORD *)(v4 + 72) + 20) = *(_DWORD *)(HIDWORD(v3) + 8);
            }
          }
          v23 = *(_DWORD *)(HIDWORD(v3) + 32);
          if ( !v23 )
            goto LABEL_21;
          v24 = v36 + *(_DWORD *)(v4 + 68);
          LODWORD(v3) = *(_WORD *)(HIDWORD(v3) + 36);
          v36 += 12;
          *(_DWORD *)(v24 + 8) = *(_DWORD *)(HIDWORD(v3) + 8);
          *(_DWORD *)(v24 + 4) = v3;
          *(_DWORD *)v24 = v23;
        }
        else
        {
          if ( *HIDWORD(v3) != 3 || !byte_100758A8 )
            goto LABEL_21;
          v17 = 0;
          v16 = HIDWORD(v3) + 32;
          v18 = 40 * v3;
          v34 = 0;
          v38 = HIDWORD(v3) + 32;
          do
          {
            if ( *(_DWORD *)v16 )
            {
              sub_1003D9A8(
                v17,
                v18 + *(_DWORD *)(v4 + 72),
                SHIDWORD(v3),
                v4,
                v4,
                v3,
                *(_WORD *)(v16 + 4),
                *(void **)v16,
                0,
                0);
              v16 = v38;
              v17 = v34;
              LODWORD(v3) = v41++ + 1;
              v18 += 40;
            }
            v38 = v16 + 12;
            v19 = *(_WORD *)(HIDWORD(v3) + 30);
            ++v17;
            v21 = __SETO__(v17, v19);
            v20 = v17 - v19 < 0;
            v16 = v38;
            v34 = v17;
          }
          while ( v20 ^ v21 );
        }
        v15 = v40;
LABEL_21:
        v15 += *(_DWORD *)(HIDWORD(v3) + 4);
        HIDWORD(v3) += *(_DWORD *)(HIDWORD(v3) + 4);
        LODWORD(v3) = v41;
        v40 = v15;
        if ( v15 >= (unsigned int)dword_100758B8 )
          goto LABEL_41;
      }
    }
    goto LABEL_41;
  }
  v25 = dword_100758BC;
  if ( dword_100758BC )
  {
    LOWORD(v3) = 0;
    v27 = 0;
    v39 = 0;
    v42 = 0;
    if ( (unsigned int)dword_100758B8 <= 0 )
    {
LABEL_41:
      sub_1003BC8E(SHIDWORD(v3));
      goto LABEL_42;
    }
    v37 = 0;
    while ( 1 )
    {
      if ( *((_DWORD *)v25 + 1) == 1 )
      {
        if ( byte_100758A8 )
          goto LABEL_38;
        if ( *(_DWORD *)v25 )
        {
          sub_1003D9A8(v27, HIDWORD(v3) + *(_DWORD *)(v4 + 72), SHIDWORD(v3), v4, v4, v3, 0, *(void **)v25, 0, 0);
          v27 = v39;
          *(_DWORD *)(HIDWORD(v3) + *(_DWORD *)(v4 + 72) + 20) = *((_DWORD *)v25 + 2);
          ++v42;
          LODWORD(v3) = v42;
          v3 += 171798691840i64;
LABEL_38:
          v35 = *(void **)v25;
          if ( *(_DWORD *)v25 )
          {
            LODWORD(v3) = v37 + *(_DWORD *)(v4 + 68);
            v29 = *((_DWORD *)v25 + 2);
            *(_DWORD *)(v3 + 4) = 0;
            v37 += 12;
            *(_DWORD *)(v3 + 8) = v29;
            *(_DWORD *)v3 = v35;
            LOWORD(v3) = v42;
          }
          goto LABEL_40;
        }
      }
      else
      {
        v28 = *((_DWORD *)v25 + 1) - 3;
        if ( *((_DWORD *)v25 + 1) == 3 )
        {
          if ( byte_100758A8 )
          {
            if ( *(_DWORD *)v25 != v28 )
            {
              sub_1003D9A8(
                v27,
                HIDWORD(v3) + *(_DWORD *)(v4 + 72),
                SHIDWORD(v3),
                v4,
                v4,
                v3,
                v28,
                *(void **)v25,
                v28,
                v28);
              v27 = v39;
              ++v42;
              LODWORD(v3) = v42;
              v3 += 171798691840i64;
            }
          }
        }
      }
LABEL_40:
      v27 += 24;
      v25 = (char *)v25 + 24;
      v39 = v27;
      if ( v27 >= (unsigned int)dword_100758B8 )
        goto LABEL_41;
    }
  }
  if ( dword_1007589C )
    v26 = *(_DWORD *)sub_1003D3D4(dword_1007589C, 0);
  else
    v26 = ProcessAffinityMask;
  sub_1003D9A8(v13, *(_DWORD *)(v4 + 72), SHIDWORD(v3), v4, v4, 0, 0, (void *)v26, 0, 0);
  **(_DWORD **)(v4 + 68) = v26;
LABEL_42:
  if ( byte_100758A8 )
  {
    v30 = 0;
    if ( *(_DWORD *)(v4 + 24) )
    {
      v31 = 0;
      do
      {
        v32 = 0;
        if ( *(_DWORD *)(v4 + 20) )
        {
          v33 = *(_DWORD *)(v4 + 68);
          while ( *(_DWORD *)(v31 + *(_DWORD *)(v4 + 72) + 12) != *(_DWORD *)(v33 + 4)
               || !(*(_DWORD *)(v31 + *(_DWORD *)(v4 + 72)) & *(_DWORD *)v33) )
          {
            ++v32;
            v33 += 12;
            if ( v32 >= *(_DWORD *)(v4 + 20) )
              goto LABEL_52;
          }
          *(_DWORD *)(v31 + *(_DWORD *)(v4 + 72) + 20) = *(_DWORD *)(12 * v32 + *(_DWORD *)(v4 + 68) + 8);
        }
LABEL_52:
        ++v30;
        v31 += 40;
      }
      while ( v30 < *(_DWORD *)(v4 + 24) );
    }
  }
}
// 1007589C: using guessed type int dword_1007589C;
// 100758A4: using guessed type int dword_100758A4;
// 100758A8: using guessed type char byte_100758A8;
// 100758AC: using guessed type int dword_100758AC;
// 100758B0: using guessed type int dword_100758B0;
// 100758B4: using guessed type int dword_100758B4;
// 100758B8: using guessed type int dword_100758B8;

//----- (1003C474) --------------------------------------------------------
int __thiscall sub_1003C474(int this)
{
  char i; // zf@1
  int v2; // edi@1
  signed int v3; // esi@1
  int v4; // eax@2
  int result; // eax@2
  int v6; // ecx@2
  int v7; // [sp+8h] [bp-Ch]@2
  int v8; // [sp+Ch] [bp-8h]@2
  int v9; // [sp+10h] [bp-4h]@2

  v2 = this;
  v3 = *(_DWORD *)(this + 100);
  for ( i = v3 == 0; ; i = v3 == *(_DWORD *)(v2 + 100) )
  {
    v3 = i ? 0 : *(_DWORD *)(v3 + 24);
    if ( !v3 )
      break;
    v4 = *(_DWORD *)(v3 + 120);
    v6 = *(_DWORD *)(v3 + 8);
    v7 = 0;
    v8 = 0;
    v9 = v4;
    (*(void (__stdcall **)(int *, int *, int *))(*(_DWORD *)v6 + 4))(&v7, &v8, &v9);
    result = v9;
    *(_DWORD *)(v3 + 120) = v9;
  }
  return result;
}

//----- (1003C4C1) --------------------------------------------------------
char __thiscall sub_1003C4C1(int this)
{
  int v1; // ebx@1
  int v2; // esi@2
  int v3; // esi@3
  char v4; // dl@7
  unsigned int v5; // ecx@7
  unsigned int v6; // edi@7
  int v7; // eax@7
  int v8; // edx@9
  int v9; // ecx@10
  int v10; // esi@10
  char v11; // zf@14
  int v12; // edi@16
  int v13; // ecx@17
  int v14; // ebx@17
  int v15; // eax@18
  char result; // al@29
  int v17; // [sp+4h] [bp-2Ch]@9
  unsigned int v18; // [sp+Ch] [bp-24h]@7
  int v19; // [sp+10h] [bp-20h]@1
  int v20; // [sp+14h] [bp-1Ch]@5
  unsigned int v21; // [sp+18h] [bp-18h]@7
  int v22; // [sp+1Ch] [bp-14h]@7
  int v23; // [sp+20h] [bp-10h]@14
  int v24; // [sp+20h] [bp-10h]@17
  int v25; // [sp+24h] [bp-Ch]@7
  int v26; // [sp+28h] [bp-8h]@7
  char v27; // [sp+2Fh] [bp-1h]@8

  v1 = this;
  v19 = this;
  if ( *(_DWORD *)(this + 100) )
  {
    v2 = *(_DWORD *)(this + 100);
    if ( v2 )
      v3 = *(_DWORD *)(v2 + 24);
    else
      v3 = 0;
    v20 = v3;
    if ( *(_DWORD *)(v3 + 160) < (unsigned int)sub_1003C109(v3) || *(_DWORD *)(v3 + 168) )
    {
      v7 = sub_1003C109(v3);
      v25 = sub_1004C0EA((void *)v3, v7) - *(_DWORD *)(v3 + 160);
      v22 = *(_DWORD *)(v3 + 16);
      v26 = *(_DWORD *)(v3 + 20);
      v6 = *(_DWORD *)(v1 + 24);
      v4 = sub_1003C109(v3) != *(_DWORD *)(v1 + 28);
      v5 = 0;
      v21 = 0;
      v18 = v6;
      if ( v6 )
      {
        while ( 1 )
        {
          v27 = v25 != 0 & v4;
          if ( v27 )
          {
            v8 = v5 + 1;
            v17 = *(_DWORD *)(v26 + 4 * v5);
            if ( v5 + 1 < v6 )
            {
              v10 = v5;
              v9 = v22 + 52 * v17;
              do
              {
                if ( *(_DWORD *)(v22 + 52 * *(_DWORD *)(v26 + 4 * v8) + 28) > *(_DWORD *)(v9 + 28) )
                {
                  v10 = v8;
                  v9 = v22 + 52 * *(_DWORD *)(v26 + 4 * v8);
                }
                ++v8;
              }
              while ( v8 < v18 );
              v5 = v21;
              v1 = v19;
              v23 = v10;
              v11 = v21 == v10;
              v3 = v20;
              if ( !v11 )
              {
                *(_DWORD *)(v26 + 4 * v21) = *(_DWORD *)(v26 + 4 * v23);
                *(_DWORD *)(v26 + 4 * v23) = v17;
              }
            }
          }
          v12 = v22 + 52 * *(_DWORD *)(v26 + 4 * v5);
          if ( *(_DWORD *)(v12 + 4) )
            break;
LABEL_26:
          v6 = *(_DWORD *)(v1 + 24);
          v4 = v27;
          ++v5;
          v21 = v5;
          v18 = v6;
          if ( v5 >= v6 )
            goto LABEL_27;
        }
        v14 = 0;
        v13 = 0;
        v24 = 0;
        while ( 1 )
        {
          v15 = *(_DWORD *)(v12 + 48);
          if ( *(_DWORD *)(v15 + v13) == 1 )
          {
            if ( v25 )
            {
              ++**(_DWORD **)(v15 + v13 + 20);
              sub_1004BEFE(v3, v12, v14, 0);
              --v25;
LABEL_23:
              v13 = v24;
              goto LABEL_24;
            }
          }
          else
          {
            if ( *(_BYTE *)(v15 + v13 + 49) )
            {
              sub_1004CC9B(v3, v12, v14);
              goto LABEL_23;
            }
          }
LABEL_24:
          ++v14;
          v13 += 52;
          v24 = v13;
          if ( (unsigned int)v14 >= *(_DWORD *)(v12 + 4) )
          {
            v1 = v19;
            v5 = v21;
            goto LABEL_26;
          }
        }
      }
    }
LABEL_27:
    if ( *(_DWORD *)(v3 + 132) == *(_DWORD *)(v3 + 128) )
      sub_1003F122((void *)v1, 0);
    result = *(_DWORD *)(v3 + 160) == sub_1003C109(v3);
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1003C66E) --------------------------------------------------------
void __thiscall sub_1003C66E(int this, int a2, char a3, char a4, int a5, unsigned int a6)
{
  int v6; // ebx@1
  int v7; // esi@1
  unsigned int v8; // edi@2
  int v9; // ecx@3
  int v10; // edx@10
  int v11; // edi@11
  int v12; // edx@12
  int v13; // ebx@12
  int v14; // eax@14
  int v15; // ecx@18
  int v16; // eax@24
  unsigned int v17; // edi@25
  int v18; // eax@26
  int v19; // eax@27
  int v20; // [sp+Ch] [bp-10h]@11
  int v21; // [sp+10h] [bp-Ch]@10
  int v22; // [sp+14h] [bp-8h]@12
  int v23; // [sp+18h] [bp-4h]@1
  int v24; // [sp+24h] [bp+8h]@26

  v6 = a2;
  v7 = a5;
  v23 = this;
  do
  {
    v8 = 0;
    BYTE3(a5) = 0;
    if ( !v7 )
      break;
    do
    {
      v9 = *(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v8);
      if ( *(_DWORD *)(v9 + 4) )
      {
        if ( *(_DWORD *)(v9 + 40) > *(_DWORD *)(v9 + 44) )
        {
          BYTE3(a5) = 1;
          if ( sub_1003D2CA((void *)v23, (int)&a3, (int)&a4, v9, a6) )
            --v6;
        }
      }
      this = v23;
      ++v8;
    }
    while ( v8 < v7 );
    a2 = v6;
  }
  while ( BYTE3(a5) );
  if ( v6 )
  {
    v10 = 0;
    v21 = 0;
    if ( v7 )
    {
      while ( 1 )
      {
        a5 = v10;
        v20 = v10 + 1;
        v11 = v10 + 1;
        if ( v10 + 1 < (unsigned int)v7 )
        {
          v22 = *(_DWORD *)(this + 92);
          v13 = 4 * v10;
          v12 = *(_DWORD *)(this + 92);
          do
          {
            if ( *(_DWORD *)(*(_DWORD *)(v12 + 4 * v11) + 4) <= *(_DWORD *)(*(_DWORD *)(v13 + v12) + 4) )
            {
              v14 = a5;
            }
            else
            {
              v14 = v11;
              a5 = v11;
              v13 = 4 * v11;
            }
            ++v11;
          }
          while ( v11 < (unsigned int)v7 );
          v10 = v21;
          v6 = a2;
          if ( v21 != v14 )
          {
            v15 = *(_DWORD *)(v22 + 4 * v21);
            *(_DWORD *)(v22 + 4 * v21) = *(_DWORD *)(v22 + 4 * v14);
            *(_DWORD *)(*(_DWORD *)(v23 + 92) + 4 * a5) = v15;
          }
          this = v23;
        }
        if ( !*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v10) + 4) )
          break;
        v10 = v20;
        v21 = v20;
        if ( v20 >= (unsigned int)v7 )
          goto LABEL_24;
      }
      v7 = v10;
    }
LABEL_24:
    v16 = v7;
    a5 = v7;
    do
    {
      v17 = 0;
      if ( v16 )
      {
        do
        {
          v18 = *(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v17);
          v24 = v18;
          if ( *(_DWORD *)(v18 + 4) )
          {
            v19 = sub_1003CE79(this, (int *)&a3, (unsigned int *)&a4, v18, v7, a6);
            this = v23;
            v6 -= v19;
            if ( !*(_DWORD *)(v24 + 4) )
              --v7;
          }
          v16 = a5;
          ++v17;
        }
        while ( v17 < a5 );
      }
    }
    while ( v6 );
  }
}

//----- (1003C7A8) --------------------------------------------------------
void __thiscall sub_1003C7A8(int this, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // esi@1
  int v5; // edi@2
  int v6; // edi@4
  unsigned int v7; // edx@5
  int v8; // ecx@6
  int v9; // edx@14
  int v10; // edi@15
  int v11; // ebx@16
  int v12; // eax@18
  int v13; // ecx@22
  int v14; // eax@28
  unsigned int v15; // edi@29
  int v16; // eax@31
  int v17; // eax@32
  int v18; // [sp+Ch] [bp-10h]@15
  int v19; // [sp+10h] [bp-Ch]@6
  int v20; // [sp+10h] [bp-Ch]@14
  int v21; // [sp+14h] [bp-8h]@2
  int v22; // [sp+14h] [bp-8h]@16
  int v23; // [sp+18h] [bp-4h]@1
  int v24; // [sp+24h] [bp+8h]@6
  int v25; // [sp+24h] [bp+8h]@31
  int v26; // [sp+28h] [bp+Ch]@15
  int v27; // [sp+28h] [bp+Ch]@28
  char v28; // [sp+2Bh] [bp+Fh]@2

  v3 = a2;
  v4 = a3;
  v23 = this;
  do
  {
    v5 = 0;
    v28 = 0;
    v21 = 0;
    if ( !v4 )
      break;
    do
    {
      if ( !v3 )
        break;
      v6 = *(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v5);
      if ( *(_DWORD *)(v6 + 4) )
      {
        v7 = *(_DWORD *)(v6 + 44);
        if ( *(_DWORD *)(v6 + 40) > v7 )
        {
          v8 = *(_DWORD *)(v6 + 16);
          v28 = 1;
          v24 = *(_DWORD *)(*(_DWORD *)(v8 + 20) + 4 * v7);
          v19 = *(_DWORD *)(v8 + 16) + 52 * v24;
          this = v23;
          if ( *(_DWORD *)(40 * v24 + *(_DWORD *)(v23 + 72) + 28) )
          {
            sub_1003CB8B(v23, *(_DWORD *)(v6 + 16), v24, 1, 1);
            if ( *(_DWORD *)(v19 + 28) == *(_DWORD *)(v19 + 4) )
              ++*(_DWORD *)(v6 + 44);
            --*(_DWORD *)(v6 + 4);
            this = v23;
            --v3;
          }
          else
          {
            ++*(_DWORD *)(v6 + 44);
          }
        }
      }
      v5 = v21 + 1;
      v21 = v5;
    }
    while ( v5 < (unsigned int)v4 );
    a2 = v3;
  }
  while ( v28 );
  if ( v3 )
  {
    v9 = 0;
    v20 = 0;
    if ( v4 )
    {
      while ( 1 )
      {
        v26 = v9;
        v18 = v9 + 1;
        v10 = v9 + 1;
        if ( v9 + 1 < (unsigned int)v4 )
        {
          v22 = *(_DWORD *)(this + 92);
          v11 = 4 * v9;
          do
          {
            if ( *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v10) + 4) <= *(_DWORD *)(*(_DWORD *)(v11 + *(_DWORD *)(this + 92))
                                                                                             + 4) )
            {
              v12 = v26;
            }
            else
            {
              v12 = v10;
              v26 = v10;
              v11 = 4 * v10;
            }
            ++v10;
          }
          while ( v10 < (unsigned int)v4 );
          v9 = v20;
          v3 = a2;
          if ( v20 != v12 )
          {
            v13 = *(_DWORD *)(v22 + 4 * v20);
            *(_DWORD *)(v22 + 4 * v20) = *(_DWORD *)(v22 + 4 * v12);
            *(_DWORD *)(*(_DWORD *)(v23 + 92) + 4 * v26) = v13;
          }
          this = v23;
        }
        if ( !*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v9) + 4) )
          break;
        v9 = v18;
        v20 = v18;
        if ( v18 >= (unsigned int)v4 )
          goto LABEL_28;
      }
      v4 = v9;
    }
LABEL_28:
    v14 = v4;
    v27 = v4;
    while ( 1 )
    {
      v15 = 0;
      if ( v14 )
        break;
LABEL_35:
      if ( !v3 )
        return;
    }
    while ( v3 )
    {
      v16 = *(_DWORD *)(*(_DWORD *)(this + 92) + 4 * v15);
      v25 = v16;
      if ( *(_DWORD *)(v16 + 4) )
      {
        v17 = sub_1003D1BE((void *)this, v3, v16, v4);
        this = v23;
        v3 -= v17;
        if ( !*(_DWORD *)(v25 + 4) )
          --v4;
      }
      v14 = v27;
      ++v15;
      if ( v15 >= v27 )
        goto LABEL_35;
    }
  }
}

//----- (1003C929) --------------------------------------------------------
int __thiscall sub_1003C929(int this)
{
  unsigned int v1; // ecx@1
  unsigned int v2; // ebx@1
  int v3; // edi@1
  int v4; // edx@2
  int v5; // ecx@3
  int v6; // esi@3
  int v7; // esi@4
  int v8; // ecx@7
  int v9; // eax@9
  int v10; // eax@9
  unsigned int v11; // edx@11
  int v12; // ecx@11
  int v13; // esi@12
  int v14; // eax@13
  unsigned int v15; // edx@14
  int v16; // ebx@14
  int v17; // ecx@15
  int v18; // esi@15
  int v19; // esi@23
  unsigned int v20; // edx@29
  unsigned int v21; // ecx@29
  unsigned int v22; // ebx@29
  int v23; // esi@30
  int v24; // edx@35
  int v25; // ecx@35
  int v26; // esi@35
  int v27; // esi@44
  int v28; // eax@44
  int v30; // [sp+Ch] [bp-18h]@35
  unsigned int v31; // [sp+10h] [bp-14h]@1
  int v32; // [sp+14h] [bp-10h]@6
  unsigned int v33; // [sp+14h] [bp-10h]@11
  unsigned int v34; // [sp+14h] [bp-10h]@29
  unsigned int v35; // [sp+18h] [bp-Ch]@1
  int v36; // [sp+1Ch] [bp-8h]@6
  int v37; // [sp+1Ch] [bp-8h]@12
  unsigned int v38; // [sp+1Ch] [bp-8h]@23
  int v39; // [sp+20h] [bp-4h]@11

  v3 = this;
  sub_1003DFF7(this);
  sub_1003E107(v3);
  v35 = 0;
  v1 = 0;
  v2 = 0;
  v31 = 0;
  if ( *(_DWORD *)(v3 + 8) )
  {
    do
    {
      v4 = *(_DWORD *)(*(_DWORD *)(v3 + 84) + 4 * v2);
      if ( *(_DWORD *)(*(_DWORD *)(v4 + 16) + 160) > *(_DWORD *)(v4 + 36) )
      {
        *(_DWORD *)(*(_DWORD *)(v3 + 88) + 4 * v1) = v4;
        v31 = v1 + 1;
        v5 = *(_DWORD *)(v4 + 16);
        v6 = *(_DWORD *)(v5 + 160);
        v35 += *(_DWORD *)(v5 + 160) - *(_DWORD *)(v4 + 36);
        if ( *(_DWORD *)(v4 + 24) >= (unsigned int)(v6 - *(_DWORD *)(v4 + 36)) )
          v7 = v6 - *(_DWORD *)(v4 + 36);
        else
          v7 = *(_DWORD *)(v4 + 24);
        *(_DWORD *)(v4 + 40) = v7;
        v36 = *(_DWORD *)(v5 + 160);
        v32 = *(_DWORD *)(v5 + 168);
        if ( v32 - *(_DWORD *)(v4 + 24) >= (unsigned int)(v36 - *(_DWORD *)(v4 + 36) - v7) )
          v8 = v36 - *(_DWORD *)(v4 + 36) - v7;
        else
          v8 = v32 - *(_DWORD *)(v4 + 24);
        v9 = *(_DWORD *)(v4 + 16);
        *(_DWORD *)(v4 + 44) = v8;
        v10 = *(_DWORD *)(v9 + 160) - *(_DWORD *)(v4 + 36) - v8;
        v1 = v31;
        *(_DWORD *)(v4 + 48) = v10 - v7;
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)(v3 + 8) );
  }
  v12 = 0;
  *(_DWORD *)(v3 + 32) = 0;
  v11 = 0;
  v39 = 0;
  v33 = 0;
  if ( *(_DWORD *)(v3 + 24) )
  {
    v13 = 0;
    v37 = 0;
    do
    {
      v14 = v13 + *(_DWORD *)(v3 + 72);
      if ( *(_DWORD *)(v14 + 4) )
      {
        v15 = 0;
        v16 = 0;
        do
        {
          v17 = v16 + *(_DWORD *)(v14 + 32);
          v18 = *(_DWORD *)(v17 + 16);
          if ( v18 )
          {
            if ( v18 == *(_DWORD *)(v17 + 28) )
            {
              *(_DWORD *)v17 = 6;
              ++*(_DWORD *)(v14 + 28);
              ++*(_DWORD *)(v3 + 32);
            }
            v12 = v39;
          }
          else
          {
            *(_DWORD *)v17 = 2;
            ++*(_DWORD *)(v14 + 8);
            v12 = v39++ + 1;
          }
          ++v15;
          v16 += 36;
        }
        while ( v15 < *(_DWORD *)(v14 + 4) );
        v11 = v33;
        v13 = v37;
      }
      ++v11;
      v13 += 40;
      v33 = v11;
      v37 = v13;
    }
    while ( v11 < *(_DWORD *)(v3 + 24) );
  }
  v19 = v12 + v35;
  *(_DWORD *)(v3 + 36) = 0;
  v38 = v12 + v35;
  while ( (v19 || *(_DWORD *)(v3 + 32) > 0u) && *(_DWORD *)(v3 + 36) < 2u )
  {
    if ( *(_DWORD *)(v3 + 36) == 1 )
      sub_1003D939(v3);
    v21 = 0;
    v22 = 0;
    v20 = 0;
    v34 = 0;
    if ( *(_DWORD *)(v3 + 8) )
    {
      do
      {
        v23 = *(_DWORD *)(*(_DWORD *)(v3 + 84) + 4 * v20);
        if ( *(_DWORD *)(*(_DWORD *)(v23 + 16) + 160) < *(_DWORD *)(v23 + 36) )
        {
          *(_DWORD *)(*(_DWORD *)(v3 + 92) + 4 * v21) = v23;
          v34 = v21 + 1;
          v22 += *(_DWORD *)(v23 + 36) - *(_DWORD *)(*(_DWORD *)(v23 + 16) + 160);
          ++v21;
        }
        ++v20;
      }
      while ( v20 < *(_DWORD *)(v3 + 8) );
      v19 = v38;
      if ( v21 )
      {
        if ( v38 )
        {
          v26 = sub_1003BA1C(v3, v38, v22, v21);
          v30 = sub_1003E207((void *)v3, v34);
          LOBYTE(v25) = 0;
          v24 = v39;
          if ( v39 >= (unsigned int)v26 )
            v24 = v26;
          v39 -= v24;
          if ( v24 < (unsigned int)v26 )
          {
            v25 = v26 - v24;
            if ( v26 - v24 >= v35 )
              v25 = v35;
            v35 -= v25;
          }
          sub_1003C66E(v3, v26, v24, v25, v30, v31);
          v38 -= v26;
          v21 = v34;
          v22 -= v26;
          v19 = v38;
        }
        if ( v22 )
        {
          if ( *(_DWORD *)(v3 + 32) )
          {
            v27 = sub_1003BA1C(v3, *(_DWORD *)(v3 + 32), v22, v21);
            v28 = sub_1003E207((void *)v3, v34);
            sub_1003C7A8(v3, v27, v28);
            *(_DWORD *)(v3 + 32) -= v27;
            v19 = v38;
          }
        }
      }
    }
    ++*(_DWORD *)(v3 + 36);
  }
  return sub_1003EE05(v3);
}

//----- (1003CB8B) --------------------------------------------------------
char *__thiscall sub_1003CB8B(int this, int a2, int a3, int a4, char a5)
{
  int i; // ecx@1
  int v6; // edi@1
  int v7; // esi@1
  int v8; // eax@2
  char *result; // eax@9
  char v10; // zf@9
  int v11; // [sp+Ch] [bp-4h]@2

  v7 = *(_DWORD *)(this + 72) + 40 * a3;
  v6 = 0;
  for ( i = 0; ; i += 36 )
  {
    v8 = i + *(_DWORD *)(v7 + 32);
    v11 = i;
    if ( *(_DWORD *)v8 == 2 )
    {
      if ( !a5 )
        break;
    }
    if ( *(_DWORD *)v8 == 6 && a5 )
      break;
LABEL_11:
    ++v6;
  }
  ++*(_DWORD *)(v8 + 16);
  *(_DWORD *)v8 = 0;
  if ( a5 )
    --*(_DWORD *)(v7 + 28);
  else
    --*(_DWORD *)(v7 + 8);
  result = sub_1004BEFE(a2, *(_DWORD *)(a2 + 16) + 52 * a3, v6, a5);
  v10 = a4-- == 1;
  if ( !v10 )
  {
    i = v11;
    goto LABEL_11;
  }
  return result;
}

//----- (1003CBF7) --------------------------------------------------------
char *__thiscall sub_1003CBF7(void *this, int a2, int a3, int a4, unsigned int a5)
{
  int v5; // eax@1
  int v6; // edx@1
  unsigned int v7; // ecx@1
  int ebp0; // ebp@0
  unsigned int v9; // esi@2
  int v10; // edi@4
  int v11; // edx@6
  int v12; // esi@6
  int v13; // eax@8
  int v14; // ecx@8
  int v15; // esi@8
  int v16; // ebx@9
  char v17; // al@11
  char v18; // cl@22
  char *result; // eax@29
  char v20; // zf@29
  char v21; // [sp+14h] [bp-24h]@24
  int v22; // [sp+18h] [bp-20h]@1
  int v23; // [sp+1Ch] [bp-1Ch]@8
  int v24; // [sp+20h] [bp-18h]@8
  int v25; // [sp+24h] [bp-14h]@6
  int v26; // [sp+28h] [bp-10h]@1
  unsigned int v27; // [sp+2Ch] [bp-Ch]@2
  int v28; // [sp+30h] [bp-8h]@9
  char v29; // [sp+37h] [bp-1h]@11

  v22 = (int)this;
  v5 = *(_DWORD *)(a2 + 16);
  v6 = 52 * a4 + *(_DWORD *)(v5 + 16);
  v7 = *(_DWORD *)(v6 + 44);
  v26 = 52 * a4 + *(_DWORD *)(v5 + 16);
  if ( a5 >= v7 )
  {
    v9 = *(_DWORD *)(v6 + 44);
    v27 = *(_DWORD *)(v6 + 44);
  }
  else
  {
    v9 = a5;
    v27 = a5;
  }
  v10 = a5 - v9;
  if ( a5 - v9 >= *(_DWORD *)(v6 + 32) - v7 )
    v10 = *(_DWORD *)(v6 + 32) - v7;
  v12 = a5 - v10 - v27;
  v11 = *(_DWORD *)(v6 + 40) - v7;
  v25 = v11;
  if ( v12 < (unsigned int)v11 )
  {
    v11 = a5 - v10 - v27;
    v25 = a5 - v10 - v27;
  }
  v14 = 52 * a4 + *(_DWORD *)(v5 + 16);
  v13 = 0;
  v23 = 0;
  v15 = v12 - v11;
  v24 = 0;
  while ( 1 )
  {
    v16 = v24 + *(_DWORD *)(v14 + 48);
    v28 = v13;
    if ( *(_DWORD *)v16 == 4 )
    {
      if ( !*(_DWORD *)(v16 + 40) )
        break;
    }
LABEL_32:
    v24 += 52;
    ++v13;
    v23 += 36;
  }
  v17 = *(_BYTE *)(v16 + 48);
  v29 = *(_BYTE *)(v16 + 48);
  if ( *(_BYTE *)(v16 + 49) )
  {
    if ( v17 && v27 )
    {
      --v27;
      goto LABEL_22;
    }
    if ( v10 )
    {
      --v10;
      goto LABEL_22;
    }
LABEL_31:
    v13 = v28;
    goto LABEL_32;
  }
  if ( v17 && v11 )
  {
    v25 = v11 - 1;
  }
  else
  {
    if ( !v15 )
      goto LABEL_31;
    --v15;
  }
LABEL_22:
  v18 = *(_BYTE *)(v16 + 48);
  if ( v29 )
  {
    sub_1003F4C9(
      v22,
      v26,
      v16,
      40 * a4 + *(_DWORD *)(v22 + 72),
      v23 + *(_DWORD *)(40 * a4 + *(_DWORD *)(v22 + 72) + 32),
      a2);
    v18 = v29;
  }
  v21 = 0;
  if ( *(_BYTE *)(v16 + 49) )
  {
    v21 = 1;
    if ( v18 )
      --*(_DWORD *)(a2 + 40);
    else
      --*(_DWORD *)(a2 + 44);
  }
  else
  {
    --*(_DWORD *)(a2 + 48);
  }
  sub_1004CAB7(ebp0, v26, v28);
  result = sub_1004BEFE(a3, 52 * a4 + *(_DWORD *)(a3 + 16), v28, v21);
  v20 = a5-- == 1;
  if ( !v20 )
  {
    v11 = v25;
    v14 = v26;
    goto LABEL_31;
  }
  return result;
}

//----- (1003CD5F) --------------------------------------------------------
int __stdcall StartAddress(int a1)
{
  int ebp0; // ebp@0

  sub_1003CD78(ebp0);
  sub_10034942(0);
  return 0;
}

//----- (1003CD78) --------------------------------------------------------
int __usercall sub_1003CD78<eax>(int a1<ebp>)
{
  DWORD v1; // ebx@1
  int v2; // edi@1
  int v3; // ecx@1
  DWORD v4; // eax@1
  char v5; // zf@1
  struct _RTL_CRITICAL_SECTION *v6; // esi@2
  int v7; // eax@3
  DWORD v8; // eax@8
  int v9; // esi@9
  struct _RTL_CRITICAL_SECTION *v10; // ecx@20
  signed int v12; // [sp-4h] [bp-4h]@1

  v12 = 12;
  sub_10035648();
  v2 = v3;
  v1 = 100;
  v4 = GetTickCount();
  v5 = *(_DWORD *)(v2 + 40) == 2;
  *(_DWORD *)(a1 - 16) = v4 - 500;
  if ( !v5 )
  {
    v6 = (struct _RTL_CRITICAL_SECTION *)(v2 + 44);
    for ( *(_DWORD *)(a1 - 20) = v2 + 44; ; v6 = *(struct _RTL_CRITICAL_SECTION **)(a1 - 20) )
    {
      *(_DWORD *)(a1 - 24) = WaitForSingleObject(*(HANDLE *)(v2 + 80), v1);
      sub_1002B91D(v6);
      v7 = *(_DWORD *)(v2 + 40);
      *(_DWORD *)(a1 - 4) = 0;
      if ( v7 )
      {
        if ( v7 != 1 )
          goto LABEL_20;
        if ( *(_DWORD *)(a1 - 24) == 258 )
        {
          sub_1003C929(v2);
          if ( *(_DWORD *)(v2 + 16) > 0u )
            sub_1003F122((void *)v2, 0);
          v8 = GetTickCount();
LABEL_15:
          *(_DWORD *)(a1 - 16) = v8;
          v1 = 100;
          goto LABEL_20;
        }
        v9 = ((int (__cdecl *)(signed int))GetTickCount)(v12) - *(_DWORD *)(a1 - 16);
        if ( (unsigned int)v9 > 0x64 )
        {
          if ( (unsigned int)v9 <= 0x82 )
          {
            if ( *(_DWORD *)(v2 + 16) )
              sub_1003F122((void *)v2, 0);
          }
          else
          {
            sub_1003C474(v2);
          }
          v8 = GetTickCount();
          goto LABEL_15;
        }
        if ( *(_DWORD *)(v2 + 16) )
          sub_1003F122((void *)v2, 0);
        v1 = 100 - v9;
      }
      else
      {
        v1 = (unsigned __int8)sub_1003C4C1(v2) != 0 ? -1 : 100;
      }
LABEL_20:
      v10 = *(struct _RTL_CRITICAL_SECTION **)(a1 - 20);
      *(_DWORD *)(a1 - 4) = -1;
      sub_1002BB52(v10);
      if ( *(_DWORD *)(v2 + 40) == 2 )
        return sub_10035616(v12);
    }
  }
  return sub_10035616(v12);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1003CE79) --------------------------------------------------------
int __thiscall sub_1003CE79(int this, int *a2, unsigned int *a3, int a4, int a5, unsigned int a6)
{
  int v6; // edx@1
  unsigned int v7; // ebx@1
  int v8; // esi@1
  int v9; // eax@1
  int v10; // eax@4
  int v11; // eax@5
  int v12; // ecx@5
  int v13; // edi@5
  int v14; // esi@8
  int v15; // eax@9
  unsigned int *v16; // eax@13
  int v17; // ecx@13
  int v18; // ebx@15
  int v19; // ecx@17
  int v20; // eax@18
  unsigned int v21; // esi@19
  int v22; // edx@21
  int v23; // edx@21
  int v24; // ecx@23
  int v25; // ecx@25
  int v26; // ecx@25
  char v27; // zf@25
  int v28; // eax@26
  char v29; // cf@30
  int v30; // eax@32
  char v31; // zf@33
  signed int v32; // ecx@39
  unsigned int v33; // eax@44
  int v34; // ecx@44
  int v35; // esi@46
  int v36; // eax@47
  int v37; // ecx@48
  unsigned int *v38; // eax@56
  unsigned int v39; // esi@58
  int v40; // eax@60
  int v41; // edx@63
  int v42; // edx@63
  int v43; // ecx@65
  int v44; // eax@67
  unsigned int v45; // ecx@68
  int v46; // edx@77
  int v47; // ecx@77
  int v49; // [sp+Ch] [bp-48h]@1
  int v50; // [sp+Ch] [bp-48h]@59
  int v51; // [sp+Ch] [bp-48h]@63
  unsigned int v52; // [sp+10h] [bp-44h]@4
  int v53; // [sp+14h] [bp-40h]@21
  int v54; // [sp+18h] [bp-3Ch]@4
  int v55; // [sp+1Ch] [bp-38h]@5
  unsigned int v56; // [sp+1Ch] [bp-38h]@19
  unsigned int v57; // [sp+1Ch] [bp-38h]@61
  int v58; // [sp+20h] [bp-34h]@17
  int v59; // [sp+24h] [bp-30h]@4
  int v60; // [sp+28h] [bp-2Ch]@4
  unsigned int v61; // [sp+2Ch] [bp-28h]@6
  unsigned int v62; // [sp+30h] [bp-24h]@8
  unsigned int v63; // [sp+34h] [bp-20h]@14
  int v64; // [sp+38h] [bp-1Ch]@1
  int v65; // [sp+3Ch] [bp-18h]@4
  int v66; // [sp+40h] [bp-14h]@1
  int v67; // [sp+44h] [bp-10h]@1
  int v68; // [sp+48h] [bp-Ch]@13
  signed int v69; // [sp+4Ch] [bp-8h]@8
  signed int v70; // [sp+50h] [bp-4h]@4
  int v71; // [sp+5Ch] [bp+8h]@59
  int v72; // [sp+68h] [bp+14h]@44
  char v73; // [sp+6Bh] [bp+17h]@2

  v6 = a4;
  v9 = *(_DWORD *)(a4 + 16);
  v8 = *(_DWORD *)(v9 + 20);
  v64 = *(_DWORD *)(v9 + 16);
  v7 = 0;
  v67 = this;
  v49 = *(_DWORD *)(a4 + 16);
  v66 = *(_DWORD *)(v9 + 20);
  if ( a5 == 1 )
    v73 = 0;
  else
    v73 = *(_BYTE *)(a4 + 32);
  v10 = *(_DWORD *)(a4 + 44);
  v54 = 0;
  v70 = -1;
  v65 = 0;
  v60 = 0;
  v59 = v10;
  v52 = *(_DWORD *)(this + 24);
  if ( v10 >= v52 )
    goto LABEL_78;
  do
  {
    v12 = *(_DWORD *)(v8 + 4 * v10);
    v11 = 52 * *(_DWORD *)(v8 + 4 * v10);
    v55 = v11;
    v13 = v65;
    if ( *(_DWORD *)(v11 + v64 + 28) == v7 )
    {
      v61 = *(_DWORD *)(v6 + 4);
      if ( v61 >= *(_DWORD *)(v11 + v64 + 4) )
        v61 = *(_DWORD *)(v11 + v64 + 4);
      v13 = v65;
      v14 = v7;
      v62 = v7;
      v69 = v7;
      if ( *a2 )
      {
        v15 = *(_DWORD *)(40 * v12 + *(_DWORD *)(v67 + 72) + 8);
        if ( v15 )
        {
          if ( *a2 < (unsigned int)v15 )
            v15 = *a2;
          v14 = 1;
          v62 = v15;
          v69 = 1;
        }
      }
      v16 = a3;
      v17 = v7;
      v68 = v7;
      if ( *a3 )
      {
        v63 = v7;
        if ( a6 )
        {
          v18 = v55;
          do
          {
            if ( v17 >= *v16 )
              break;
            v58 = *(_DWORD *)(*(_DWORD *)(v67 + 88) + 4 * v63);
            v19 = *(_DWORD *)(v58 + 16);
            if ( *(_DWORD *)(v19 + 160) <= *(_DWORD *)(v58 + 36) )
              goto LABEL_82;
            v20 = *(_DWORD *)(v19 + 16);
            if ( *(_DWORD *)(v18 + v20 + 28) == *(_DWORD *)(v18 + v20 + 36) )
              goto LABEL_82;
            v21 = *(_DWORD *)(v18 + v20 + 44);
            v56 = *(_DWORD *)(v58 + 40);
            if ( v21 < v56 )
              v56 = *(_DWORD *)(v18 + v20 + 44);
            v23 = *(_DWORD *)(v18 + v20 + 32);
            v53 = v23;
            v22 = v23 - v21;
            if ( (unsigned int)v22 >= *(_DWORD *)(v58 + 44) )
              v22 = *(_DWORD *)(v58 + 44);
            v24 = *(_DWORD *)(v18 + v20 + 28) - *(_DWORD *)(v18 + v20 + 36) - v53;
            if ( (unsigned int)v24 >= *(_DWORD *)(v58 + 48) )
              v24 = *(_DWORD *)(v58 + 48);
            v26 = v22 + v24;
            v27 = v56 + v26 == 0;
            v25 = v56 + v26;
            if ( v27 )
            {
LABEL_82:
              v14 = v69;
              v17 = v68;
            }
            else
            {
              v28 = *a3 - v68;
              if ( v28 >= (unsigned int)v25 )
                v28 = v25;
              v17 = v28 + v68;
              v14 = v69 + 1;
              v68 += v28;
              ++v69;
            }
            v29 = v63++ + 1 < a6;
            v16 = a3;
          }
          while ( v29 );
          v13 = v65;
          v6 = a4;
          v7 = 0;
        }
      }
      v30 = v17 + v62;
      if ( v73 )
      {
        v31 = v30 == v61;
      }
      else
      {
        if ( v13 < v61 && v30 > (unsigned int)v13 )
        {
LABEL_39:
          v32 = v59;
          v13 = v30;
          v60 = v14;
          v8 = v66;
          v70 = v59;
          v65 = v30;
          goto LABEL_42;
        }
        v31 = v30 == v13;
      }
      if ( v31 && v14 > (unsigned int)v60 )
        goto LABEL_39;
      v8 = v66;
    }
    v32 = v70;
LABEL_42:
    v10 = v59 + 1;
    v59 = v10;
  }
  while ( v10 < v52 );
  if ( v32 == -1 )
  {
LABEL_78:
    *(_BYTE *)(v6 + 32) = v7;
    return v54;
  }
  v33 = *(_DWORD *)(v6 + 4);
  v34 = *(_DWORD *)(v8 + 4 * v32);
  v72 = v34;
  if ( v33 < v13 )
    v13 = *(_DWORD *)(v6 + 4);
  *(_DWORD *)(v6 + 4) = v33 - v13;
  v54 = v13;
  v35 = *a2;
  if ( *a2 )
  {
    v36 = *(_DWORD *)(40 * v34 + *(_DWORD *)(v67 + 72) + 8);
    if ( v36 )
    {
      v37 = *a2;
      if ( v35 >= (unsigned int)v36 )
        v37 = v36;
      if ( v37 >= (unsigned int)v13 )
      {
        v35 = v13;
      }
      else
      {
        if ( v35 >= (unsigned int)v36 )
          v35 = v36;
      }
      sub_1003CB8B(v67, v49, v72, v35, v7);
      *a2 -= v35;
      v13 -= v35;
    }
  }
  if ( v13 )
  {
    v38 = a3;
    if ( *a3 > v7 )
    {
      do
      {
        if ( v7 >= a6 )
          break;
        v39 = *v38;
        if ( !*v38 )
          break;
        v71 = *(_DWORD *)(*(_DWORD *)(v67 + 88) + 4 * v7++);
        v50 = *(_DWORD *)(v71 + 16);
        if ( *(_DWORD *)(v50 + 160) <= *(_DWORD *)(v71 + 36) )
          goto LABEL_83;
        v40 = *(_DWORD *)(v50 + 16) + 52 * v72;
        if ( *(_DWORD *)(v40 + 28) == *(_DWORD *)(v40 + 36) )
          goto LABEL_83;
        v57 = *(_DWORD *)(v71 + 40);
        if ( *(_DWORD *)(v40 + 44) < v57 )
          v57 = *(_DWORD *)(v40 + 44);
        v42 = *(_DWORD *)(v40 + 32);
        v51 = v42;
        v41 = v42 - *(_DWORD *)(v40 + 44);
        if ( (unsigned int)v41 >= *(_DWORD *)(v71 + 44) )
          v41 = *(_DWORD *)(v71 + 44);
        v43 = *(_DWORD *)(v40 + 28) - *(_DWORD *)(v40 + 36) - v51;
        if ( (unsigned int)v43 >= *(_DWORD *)(v71 + 48) )
          v43 = *(_DWORD *)(v71 + 48);
        v44 = v57 + v43 + v41;
        if ( v57 + v43 + v41 )
        {
          v45 = v39;
          if ( v39 >= v44 )
            v45 = v44;
          if ( v45 >= v13 )
          {
            v39 = v13;
          }
          else
          {
            if ( v39 >= v44 )
              v39 = v44;
          }
          sub_1003CBF7((void *)v67, v71, *(_DWORD *)(a4 + 16), v72, v39);
          v38 = a3;
          *v38 -= v39;
          v13 -= v39;
        }
        else
        {
LABEL_83:
          v38 = a3;
        }
      }
      while ( v13 );
    }
  }
  v46 = *(_DWORD *)(a4 + 44);
  v47 = *(_DWORD *)(v66 + 4 * v46);
  *(_DWORD *)(v66 + 4 * v46) = *(_DWORD *)(v66 + 4 * v70);
  *(_DWORD *)(v66 + 4 * v70) = v47;
  ++*(_DWORD *)(a4 + 44);
  *(_BYTE *)(a4 + 32) = 1;
  return v54;
}

//----- (1003D1BE) --------------------------------------------------------
int __thiscall sub_1003D1BE(void *this, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // eax@1
  signed int v8; // edx@4
  int v9; // ecx@4
  int v10; // eax@5
  int v11; // eax@5
  unsigned int v12; // eax@8
  signed int v13; // eax@14
  int v14; // edx@19
  int v15; // ecx@19
  unsigned int v17; // [sp+Ch] [bp-1Ch]@4
  int v18; // [sp+10h] [bp-18h]@1
  unsigned int v19; // [sp+14h] [bp-14h]@6
  int v20; // [sp+18h] [bp-10h]@1
  int v21; // [sp+1Ch] [bp-Ch]@5
  int v22; // [sp+1Ch] [bp-Ch]@8
  unsigned int v23; // [sp+20h] [bp-8h]@4
  signed int v24; // [sp+24h] [bp-4h]@4
  char v25; // [sp+3Bh] [bp+13h]@2

  v6 = a3;
  v20 = (int)this;
  v7 = *(_DWORD *)(a3 + 16);
  v4 = 0;
  v5 = *(_DWORD *)(v7 + 20);
  v18 = *(_DWORD *)(v7 + 16);
  if ( a4 == 1 )
    v25 = 0;
  else
    v25 = *(_BYTE *)(a3 + 32);
  v8 = *(_DWORD *)(a3 + 44);
  v24 = -1;
  v9 = 0;
  v23 = 0;
  v17 = *(_DWORD *)(v20 + 24);
  if ( v8 >= v17 )
    goto LABEL_27;
  while ( 1 )
  {
    v11 = *(_DWORD *)(v5 + 4 * v8);
    v21 = v11;
    v10 = v18 + 52 * v11;
    if ( !*(_DWORD *)(v10 + 28) )
      break;
LABEL_14:
    v13 = v24;
LABEL_15:
    ++v8;
    if ( v8 >= v17 )
      goto LABEL_16;
  }
  v19 = *(_DWORD *)(v6 + 4);
  if ( v19 >= *(_DWORD *)(v10 + 4) )
    v19 = *(_DWORD *)(v10 + 4);
  v22 = 40 * v21;
  v9 = 0;
  v12 = *(_DWORD *)(v22 + *(_DWORD *)(v20 + 72) + 28);
  v6 = a3;
  if ( v12 )
  {
    v9 = a2;
    if ( a2 >= v12 )
      v9 = *(_DWORD *)(v22 + *(_DWORD *)(v20 + 72) + 28);
  }
  if ( v25 )
  {
    if ( v9 == v19 )
      goto LABEL_21;
    goto LABEL_13;
  }
  if ( v9 <= v23 )
  {
LABEL_13:
    v9 = v23;
    goto LABEL_14;
  }
LABEL_21:
  v13 = v8;
  v24 = v8;
  v23 = v9;
  if ( !v25 )
    goto LABEL_15;
LABEL_16:
  if ( v13 == -1 )
  {
LABEL_27:
    *(_BYTE *)(v6 + 32) = 0;
    return v4;
  }
  v4 = *(_DWORD *)(v6 + 4);
  if ( v4 >= (unsigned int)v9 )
    v4 = v9;
  sub_1003CB8B(v20, *(_DWORD *)(v6 + 16), *(_DWORD *)(v5 + 4 * v13), v4, 1);
  *(_DWORD *)(v6 + 4) -= v4;
  v14 = *(_DWORD *)(v6 + 44);
  v15 = *(_DWORD *)(v5 + 4 * v14);
  *(_DWORD *)(v5 + 4 * v14) = *(_DWORD *)(v5 + 4 * v24);
  *(_DWORD *)(v5 + 4 * v24) = v15;
  ++*(_DWORD *)(v6 + 44);
  *(_BYTE *)(v6 + 32) = 1;
  return v4;
}

//----- (1003D2CA) --------------------------------------------------------
char __thiscall sub_1003D2CA(void *this, int a2, int a3, int a4, unsigned int a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  char v7; // bl@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // eax@1
  int v11; // ecx@5
  int v12; // ecx@7
  int v13; // edx@8
  int v15; // [sp+Ch] [bp-8h]@1
  int v16; // [sp+10h] [bp-4h]@1
  int v17; // [sp+1Ch] [bp+8h]@5
  int v18; // [sp+24h] [bp+10h]@1

  v9 = a4;
  v16 = (int)this;
  v10 = *(_DWORD *)(a4 + 16);
  v15 = *(_DWORD *)(v10 + 16);
  v6 = *(_DWORD *)(*(_DWORD *)(v10 + 20) + 4 * *(_DWORD *)(a4 + 44));
  v5 = v16;
  v7 = 0;
  v8 = 52 * v6;
  v18 = *(_DWORD *)(*(_DWORD *)(v10 + 20) + 4 * *(_DWORD *)(a4 + 44));
  if ( *(_DWORD *)a2 && *(_DWORD *)(40 * v6 + *(_DWORD *)(v16 + 72) + 8) )
  {
    v7 = 1;
    sub_1003CB8B(v16, *(_DWORD *)(v9 + 16), v18, 1, 0);
    --*(_DWORD *)a2;
  }
  else
  {
    if ( !*(_DWORD *)a3 || (v11 = 0, v17 = 0, !a5) )
    {
LABEL_20:
      ++*(_DWORD *)(v9 + 44);
      return v7;
    }
    while ( !v7 )
    {
      v12 = *(_DWORD *)(*(_DWORD *)(v5 + 88) + 4 * v11);
      if ( *(_DWORD *)(*(_DWORD *)(v12 + 16) + 160) > *(_DWORD *)(v12 + 36) )
      {
        v13 = *(_DWORD *)(*(_DWORD *)(v12 + 16) + 16);
        if ( *(_DWORD *)(v8 + v13 + 44)
          || *(_DWORD *)(v8 + v13 + 32) != *(_DWORD *)(v8 + v13 + 44) && *(_DWORD *)(v12 + 44)
          || *(_DWORD *)(v8 + v13 + 28) != *(_DWORD *)(v8 + v13 + 36) && *(_DWORD *)(v12 + 48) )
        {
          v7 = 1;
          sub_1003CBF7((void *)v16, v12, *(_DWORD *)(v9 + 16), v18, 1u);
          --*(_DWORD *)a3;
        }
        v5 = v16;
      }
      v11 = v17 + 1;
      v17 = v11;
      if ( v11 >= a5 )
      {
        if ( !v7 )
          goto LABEL_20;
        break;
      }
    }
  }
  if ( *(_DWORD *)(v8 + v15 + 28) == *(_DWORD *)(v8 + v15 + 4) )
    ++*(_DWORD *)(v9 + 44);
  --*(_DWORD *)(v9 + 4);
  return v7;
}

//----- (1003D3D4) --------------------------------------------------------
int __thiscall sub_1003D3D4(int this, __int16 a2)
{
  int v2; // eax@1
  signed int v3; // esi@1
  int v4; // edx@2
  int v5; // ecx@2
  int result; // eax@5

  v3 = *(_WORD *)this;
  v2 = 0;
  if ( v3 <= 0 )
  {
LABEL_5:
    result = 0;
  }
  else
  {
    v5 = *(_DWORD *)(this + 4);
    v4 = 0;
    while ( *(_WORD *)(12 * v4 + v5 + 4) != a2 )
    {
      ++v2;
      v4 = (unsigned __int16)v2;
      if ( (unsigned __int16)v2 >= v3 )
        goto LABEL_5;
    }
    result = v5 + 12 * (unsigned __int16)v2;
  }
  return result;
}

//----- (1003D40F) --------------------------------------------------------
BOOL __thiscall sub_1003D40F(DWORD this)
{
  BOOL result; // eax@2
  DWORD flOldProtect; // [sp+0h] [bp-4h]@1

  flOldProtect = this;
  if ( dword_100758B4 < 3 )
  {
    result = *(_DWORD *)(this + 140);
    if ( *(_BYTE *)result == 1 )
      result = VirtualProtect((LPVOID)result, 1u, 2u, &flOldProtect);
  }
  else
  {
    result = sub_1003950A();
  }
  return result;
}
// 100758B4: using guessed type int dword_100758B4;

//----- (1003D43F) --------------------------------------------------------
int __thiscall sub_1003D43F(int this)
{
  return *(_DWORD *)(this + 24);
}

//----- (1003D443) --------------------------------------------------------
int __usercall sub_1003D443<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4<esi>)
{
  int v4; // eax@2

  sub_10035648();
  if ( !dword_100758A4 )
  {
    *(_DWORD *)(a2 - 16) = &dword_10075F54;
    sub_10030FB0(&dword_10075F54);
    v4 = dword_100758A4;
    *(_DWORD *)(a2 - 4) = 0;
    if ( !v4 )
      sub_1003DB83(a1, a3, a4, 0);
    dword_10075F54 = 0;
  }
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 100758A4: using guessed type int dword_100758A4;
// 10075F54: using guessed type int dword_10075F54;

//----- (1003D48E) --------------------------------------------------------
int __userpurge sub_1003D48E<eax>(int a1<ecx>, int a2<esi>, int a3)
{
  int v3; // ebx@1
  int ebp0; // ebp@0
  signed int v5; // eax@2
  int v6; // edx@2
  int v7; // ecx@2
  int v8; // esi@2
  unsigned int v9; // edx@5
  int v10; // edi@6
  int result; // eax@14
  signed int v12; // eax@21
  int v13; // eax@21
  int v14; // edx@21
  int v15; // ecx@21
  int v16; // ecx@21
  unsigned int v17; // esi@23
  int v18; // edi@24
  int v19; // ecx@33
  char v20; // [sp+Ch] [bp-18h]@33
  int v21; // [sp+18h] [bp-Ch]@2
  int v22; // [sp+1Ch] [bp-8h]@2
  unsigned __int16 v23; // [sp+20h] [bp-4h]@2
  unsigned __int8 v24; // [sp+22h] [bp-2h]@2

  v3 = a1;
  if ( sub_1003F536(ebp0, a2) < 4 )
  {
    if ( sub_1003F536(ebp0, a2) != 2 && sub_1003F536(ebp0, a2) != 3 )
    {
      if ( dword_100758B4 == 1 )
      {
        if ( a3 )
          *(_DWORD *)a3 = 0;
        result = 0;
      }
      else
      {
        sub_100300C4((int)&v20);
        sub_100355BB((int)&v20, (int)&unk_1006BB80);
        __asm { int     3               ; Trap to Debugger }
        result = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v19 + 4) + 32) + 32);
      }
      return result;
    }
    v13 = sub_10039534();
    v16 = v13;
    v12 = 1 << v13;
    v21 = v16;
    v15 = *(_DWORD *)(v3 + 72);
    v14 = 0;
    v22 = v12;
    while ( 1 )
    {
      if ( v12 & *(_DWORD *)v15 )
      {
        v17 = 0;
        if ( *(_DWORD *)(v15 + 4) )
        {
          v18 = *(_DWORD *)(v15 + 32) + 8;
          do
          {
            if ( *(_BYTE *)v18 == v21 )
            {
              if ( a3 )
                *(_DWORD *)a3 = v17;
              return v14;
            }
            ++v17;
            v18 += 36;
          }
          while ( v17 < *(_DWORD *)(v15 + 4) );
          v12 = v22;
        }
      }
      ++v14;
      v15 += 40;
    }
  }
  sub_1003B59E((int)&v23);
  v6 = v23;
  v5 = 1 << v24;
  v22 = v24;
  v7 = *(_DWORD *)(v3 + 72);
  v8 = 0;
  v21 = 1 << v24;
  while ( *(_DWORD *)(v7 + 12) != v6 || !(v5 & *(_DWORD *)v7) )
  {
LABEL_11:
    ++v8;
    v7 += 40;
  }
  v9 = 0;
  if ( !*(_DWORD *)(v7 + 4) )
  {
LABEL_10:
    v6 = v23;
    goto LABEL_11;
  }
  v10 = *(_DWORD *)(v7 + 32) + 8;
  while ( *(_BYTE *)v10 != v22 )
  {
    ++v9;
    v10 += 36;
    if ( v9 >= *(_DWORD *)(v7 + 4) )
    {
      v5 = v21;
      goto LABEL_10;
    }
  }
  if ( a3 )
    *(_DWORD *)a3 = v9;
  return v8;
}
// 100758B4: using guessed type int dword_100758B4;

//----- (1003D5A6) --------------------------------------------------------
int __thiscall sub_1003D5A6(int this)
{
  return *(_DWORD *)(*(_DWORD *)(this + 72) + 36);
}

//----- (1003D5AD) --------------------------------------------------------
int __thiscall sub_1003D5AD(int this)
{
  return *(_DWORD *)(*(_DWORD *)(this + 4) + 4);
}

//----- (1003D5B4) --------------------------------------------------------
int __thiscall sub_1003D5B4(int this)
{
  return *(_DWORD *)(*(_DWORD *)(this + 4) + 16);
}

//----- (1003D5BB) --------------------------------------------------------
int __thiscall sub_1003D5BB(int this)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1003D5E9(*(_DWORD *)(*(_DWORD *)(this + 4) + 12), *(_DWORD *)(this + 4));
  if ( v1 )
    result = *(_DWORD *)(v1 + 32);
  else
    result = 0;
  return result;
}

//----- (1003D5D2) --------------------------------------------------------
int __thiscall sub_1003D5D2(int this)
{
  int v1; // eax@1
  int result; // eax@2

  v1 = sub_1003D60E(*(_DWORD *)(*(_DWORD *)(this + 4) + 24), *(_DWORD *)(this + 4));
  if ( v1 )
    result = *(_DWORD *)(v1 + 36);
  else
    result = 0;
  return result;
}

//----- (1003D5E9) --------------------------------------------------------
int __thiscall sub_1003D5E9(int this, int a2)
{
  int v2; // eax@1
  int result; // eax@2

  v2 = (a2 - *(_DWORD *)(this + 32)) / 36 + 1;
  if ( (unsigned int)v2 >= *(_DWORD *)(this + 4) )
    result = 0;
  else
    result = *(_DWORD *)(this + 32) + 36 * v2;
  return result;
}

//----- (1003D60E) --------------------------------------------------------
int __thiscall sub_1003D60E(int this, int a2)
{
  int v2; // eax@1
  int result; // eax@2

  v2 = (a2 - *(_DWORD *)(this + 72)) / 40 + 1;
  if ( (unsigned int)v2 >= *(_DWORD *)(this + 24) )
    result = 0;
  else
    result = *(_DWORD *)(this + 72) + 40 * v2;
  return result;
}

//----- (1003D633) --------------------------------------------------------
int __usercall sub_1003D633<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4<esi>)
{
  int v4; // eax@2

  sub_10035648();
  if ( !dword_100758AC )
  {
    *(_DWORD *)(a2 - 16) = &dword_10075F54;
    sub_10030FB0(&dword_10075F54);
    v4 = dword_100758AC;
    *(_DWORD *)(a2 - 4) = 0;
    if ( !v4 )
      sub_1003DB83(a1, a3, a4, 0);
    dword_10075F54 = 0;
  }
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 100758AC: using guessed type int dword_100758AC;
// 10075F54: using guessed type int dword_10075F54;

//----- (1003D67E) --------------------------------------------------------
int __thiscall sub_1003D67E(int this)
{
  return *(_DWORD *)(*(_DWORD *)(this + 4) + 20);
}

//----- (1003D694) --------------------------------------------------------
int __cdecl sub_1003D694()
{
  _ECX = &unk_10073360;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return _EAX + 1;
}

//----- (1003D6A2) --------------------------------------------------------
int __usercall sub_1003D6A2<eax>(int a1<ebx>, int a2)
{
  int result; // eax@2

  if ( dword_100758B4 < 4 )
    result = sub_1003B5B4(a1, (int)&dword_100758B8);
  else
    result = sub_1003B64F(a2, (int)&dword_100758B8);
  dword_100758BC = (LPVOID)result;
  return result;
}
// 1003B64F: using guessed type int __cdecl sub_1003B64F(int, int);
// 100758B4: using guessed type int dword_100758B4;
// 100758B8: using guessed type int dword_100758B8;

//----- (1003D6CB) --------------------------------------------------------
unsigned int __thiscall sub_1003D6CB(int this, int a2, int a3)
{
  unsigned int result; // eax@1
  int v4; // edx@1
  int ebp0; // ebp@0
  int v6; // ecx@2
  int v7; // esi@2
  int v8; // ebx@4
  int v9; // eax@5
  int v10; // edi@6
  int v11; // eax@8
  int v12; // ecx@8
  unsigned int v13; // [sp+Ch] [bp-14h]@1
  int v14; // [sp+10h] [bp-10h]@5
  int v15; // [sp+14h] [bp-Ch]@5
  int v16; // [sp+18h] [bp-8h]@1
  int v17; // [sp+1Ch] [bp-4h]@2

  v4 = this;
  result = 0;
  v16 = this;
  v13 = 0;
  if ( *(_DWORD *)(this + 24) )
  {
    v6 = 0;
    v17 = 0;
    v7 = *(_DWORD *)(a2 + 16) + 44;
    do
    {
      if ( *(_DWORD *)(v7 - 12) )
      {
        v8 = 0;
        if ( *(_DWORD *)(v7 - 40) )
        {
          v15 = 0;
          v9 = 0;
          v14 = 0;
          do
          {
            v10 = v9 + *(_DWORD *)(v7 + 4);
            if ( *(_DWORD *)v10 == 4 )
            {
              if ( *(_BYTE *)(v10 + 49) )
              {
                v11 = v15 + *(_DWORD *)(v6 + *(_DWORD *)(v4 + 72) + 32);
                v12 = *(_DWORD *)(v11 + 16);
                if ( v12 == 1 )
                {
                  sub_1004CC9B(a2, v7 - 44, v8);
                  v4 = v16;
                  v6 = v17;
                  if ( *(_BYTE *)(v10 + 48) )
                  {
                    --*(_DWORD *)v7;
                    --*(_DWORD *)(a3 + 24);
                  }
                }
                else
                {
                  if ( v12 - *(_DWORD *)(v11 + 28) > (unsigned int)(*(_BYTE *)(v10 + 48) == 0) )
                  {
                    *(_DWORD *)(v11 + 16) = v12 - 1;
                    if ( *(_BYTE *)(v10 + 48) )
                      sub_1003F4C9(v4, v7 - 44, v10, v17 + *(_DWORD *)(v4 + 72), v11, a3);
                    sub_1004CAB7(ebp0, v7 - 44, v8);
                    v4 = v16;
                  }
                  v6 = v17;
                }
              }
            }
            v14 += 52;
            v15 += 36;
            v9 = v14;
            ++v8;
          }
          while ( (unsigned int)v8 < *(_DWORD *)(v7 - 40) );
          result = v13;
        }
      }
      ++result;
      v6 += 40;
      v7 += 52;
      v13 = result;
      v17 = v6;
    }
    while ( result < *(_DWORD *)(v4 + 24) );
  }
  return result;
}

//----- (1003D7E4) --------------------------------------------------------
int __thiscall sub_1003D7E4(void *this, int a2, int a3)
{
  int ebp0; // ebp@0
  int v4; // edi@1
  int v5; // esi@1
  int result; // eax@2
  int v7; // esi@2
  unsigned int v8; // edx@4
  int v9; // edi@5
  int v10; // ecx@8
  int v11; // edx@9
  int v12; // ecx@11
  unsigned int v13; // eax@14
  int v14; // eax@14
  unsigned int v15; // [sp+Ch] [bp-1Ch]@4
  int v16; // [sp+10h] [bp-18h]@14
  int v17; // [sp+14h] [bp-14h]@5
  int v18; // [sp+18h] [bp-10h]@9
  int v19; // [sp+1Ch] [bp-Ch]@8
  int v20; // [sp+20h] [bp-8h]@1
  int v21; // [sp+24h] [bp-4h]@9

  v5 = *(_DWORD *)(a2 + 160);
  v20 = (int)this;
  v4 = v5 - *(_DWORD *)(a2 + 168);
  if ( v5 - *(_DWORD *)(a3 + 24) - *(_DWORD *)(a3 + 36) >= (unsigned int)(v5
                                                                        - *(_DWORD *)(a2 + 168)
                                                                        - (*(_DWORD *)(a2 + 184)
                                                                         + sub_1003DDC2(a2))) )
  {
    result = *(_DWORD *)(a2 + 184) + sub_1003DDC2(a2);
    v7 = v4 - result;
  }
  else
  {
    result = a3;
    v7 = v5 - *(_DWORD *)(a3 + 24) - *(_DWORD *)(a3 + 36);
  }
  v8 = 0;
  v15 = 0;
  if ( v7 )
  {
    v17 = 0;
    v9 = *(_DWORD *)(a2 + 16) + 36;
    do
    {
      result = v20;
      if ( v8 >= *(_DWORD *)(v20 + 24) )
        break;
      result = *(_DWORD *)(v9 - 8) - *(_DWORD *)v9;
      if ( *(_DWORD *)(v9 - 8) != *(_DWORD *)v9 )
      {
        v10 = 0;
        v19 = 0;
        if ( v7 )
        {
          v21 = 0;
          result = 0;
          v11 = 0;
          v18 = 0;
          do
          {
            if ( (unsigned int)v10 >= *(_DWORD *)(v9 - 32) )
              break;
            v12 = v11 + *(_DWORD *)(v9 + 12);
            if ( *(_DWORD *)v12 == 4 )
            {
              if ( !*(_DWORD *)(v12 + 40) )
              {
                if ( !*(_BYTE *)(v12 + 49) )
                {
                  v14 = v21 + *(_DWORD *)(*(_DWORD *)(v20 + 72) + v17 + 32);
                  v16 = v14;
                  v13 = *(_DWORD *)(v14 + 16);
                  if ( v13 > 1 )
                  {
                    *(_DWORD *)(v16 + 16) = v13 - 1;
                    if ( *(_BYTE *)(v12 + 48) )
                      sub_1003F4C9(v20, v9 - 36, v12, v17 + *(_DWORD *)(v20 + 72), v16, a3);
                    sub_1004CAB7(ebp0, v9 - 36, v19);
                    --v7;
                  }
                  v11 = v18;
                }
                result = v21;
              }
            }
            v10 = v19 + 1;
            v11 += 52;
            result += 36;
            ++v19;
            v18 = v11;
            v21 = result;
          }
          while ( v7 );
          v8 = v15;
        }
      }
      v17 += 40;
      ++v8;
      v9 += 52;
      v15 = v8;
    }
    while ( v7 );
  }
  return result;
}

//----- (1003D939) --------------------------------------------------------
void __thiscall sub_1003D939(int this)
{
  int v1; // edi@1
  unsigned int v2; // esi@1
  int v3; // ebx@2
  int v4; // eax@3

  v1 = this;
  v2 = 0;
  if ( *(_DWORD *)(this + 8) )
  {
    do
    {
      v3 = *(_DWORD *)(*(_DWORD *)(v1 + 84) + 4 * v2);
      if ( *(_BYTE *)(v3 + 33) == 1 )
      {
        v4 = sub_1003C109(*(_DWORD *)(v3 + 16));
        *(_DWORD *)(v3 + 36) = sub_1004C0EA(*(void **)(v3 + 16), v4);
      }
      ++v2;
    }
    while ( v2 < *(_DWORD *)(v1 + 8) );
  }
}

//----- (1003D96F) --------------------------------------------------------
char __userpurge sub_1003D96F<al>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, char a7)
{
  int v7; // eax@1
  int v8; // esi@1
  char result; // al@4

  v8 = a2;
  v7 = sub_1002ADB1(a1, a2, a3, a4, 8);
  if ( v7 )
  {
    *(_DWORD *)v7 = off_10063BE8;
    *(_DWORD *)(v7 + 4) = v8;
  }
  else
  {
    v7 = 0;
  }
  *(_DWORD *)(v8 + 32) = v7;
  *(_DWORD *)(v8 + 12) = a5;
  *(_DWORD *)(v8 + 4) = a6;
  result = a7;
  *(_BYTE *)(v8 + 8) = a7;
  return result;
}
// 10063BE8: using guessed type int (*off_10063BE8[2])();

//----- (1003D9A8) --------------------------------------------------------
void *__userpurge sub_1003D9A8<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, unsigned __int16 a6, unsigned __int16 a7, void *a8, int a9, char a10)
{
  int v10; // eax@1
  int v11; // esi@1
  int i; // edx@5
  void *v13; // ecx@5
  int v14; // eax@9
  __int64 v15; // qcx@9
  int v16; // edi@9
  signed __int64 v18; // qax@9
  void *v19; // ecx@10
  void *result; // eax@12
  int v21; // edx@12
  signed int v22; // ST08_4@12
  int v23; // edi@13
  int v24; // eax@16
  int v25; // edx@16
  char v26; // [sp-4h] [bp-10h]@16
  int v27; // [sp+1Ch] [bp+10h]@16

  v11 = a2;
  v10 = sub_1002ADB1(a1, a2, a3, a4, 8);
  if ( v10 )
  {
    *(_DWORD *)v10 = off_10063BF4;
    *(_DWORD *)(v10 + 4) = v11;
  }
  else
  {
    v10 = 0;
  }
  *(_DWORD *)(v11 + 36) = v10;
  *(_DWORD *)(v11 + 24) = a5;
  *(_DWORD *)(v11 + 16) = a6;
  *(_DWORD *)(v11 + 12) = a7;
  *(_DWORD *)v11 = a8;
  if ( a9 )
  {
    *(_DWORD *)(v11 + 4) = a9;
  }
  else
  {
    v13 = a8;
    for ( i = 0; v13; v13 = (void *)((unsigned int)((char *)v13 - 1) & (unsigned int)v13) )
      ++i;
    *(_DWORD *)(v11 + 4) = (unsigned __int16)i;
  }
  v16 = *(_DWORD *)(v11 + 4);
  _ECX = 0;
  v18 = 36i64 * *(_DWORD *)(v11 + 4);
  __asm { seto    cl }
  *(_DWORD *)(v11 + 8) = 0;
  v15 = (_DWORD)v18 | (unsigned int)-_ECX;
  v14 = sub_1002965B(SHIDWORD(v18), v15 + 4, SHIDWORD(v15), v16, (v15 + 4) | -((_DWORD)v15 >= 0xFFFFFFFCu));
  if ( v14 )
  {
    *(_DWORD *)v14 = v16;
    v19 = (void *)(v14 + 4);
  }
  else
  {
    v19 = 0;
  }
  v22 = 36 * *(_DWORD *)(v11 + 4);
  *(_DWORD *)(v11 + 32) = v19;
  result = sub_100391F0(v19, 0, v22);
  v21 = 0;
  if ( *(_DWORD *)(v11 + 4) > 0u )
  {
    result = a8;
    LODWORD(v15) = a9;
    v23 = 0;
    while ( !(_DWORD)v15 )
    {
      if ( (_BYTE)result & 1 )
      {
        v24 = *(_DWORD *)(v11 + 12);
        LODWORD(v15) = v23 + *(_DWORD *)(v11 + 32);
        v25 = v21 + 1;
        v27 = v25;
        v26 = BYTE4(v15);
LABEL_18:
        v23 += 36;
        sub_1003D96F(v25, v15, SHIDWORD(v15), v23, v11, HIDWORD(v15) + (v24 << 8), v26);
        LODWORD(v15) = a9;
        v21 = v27;
        result = a8;
      }
      result = (void *)((unsigned int)result >> 1);
      v15 += 4294967296i64;
      a8 = result;
      if ( (unsigned int)v21 >= *(_DWORD *)(v11 + 4) )
        return result;
    }
    LODWORD(v15) = v23 + *(_DWORD *)(v11 + 32);
    v26 = BYTE4(v15) + a10;
    v27 = v21 + 1;
    v25 = a6;
    v24 = a6 + (*(_DWORD *)(v11 + 12) << 8);
    goto LABEL_18;
  }
  return result;
}
// 10063BF4: using guessed type int (*off_10063BF4[4])();

//----- (1003DAC1) --------------------------------------------------------
void *__thiscall sub_1003DAC1(int this)
{
  unsigned int v1; // eax@1
  int v2; // esi@1
  void *v3; // ST10_4@3
  signed __int64 v5; // qax@3
  signed __int64 v7; // qax@4
  signed __int64 v9; // qax@4
  void *result; // eax@5

  v2 = this;
  v1 = *(_DWORD *)(this + 12);
  if ( v1 < *(_DWORD *)(this + 8) )
  {
    do
      v1 *= 2;
    while ( v1 < *(_DWORD *)(this + 8) );
    v3 = *(void **)(this + 84);
    *(_DWORD *)(this + 12) = v1;
    sub_100303A3(v3);
    sub_100303A3(*(LPVOID *)(v2 + 88));
    sub_100303A3(*(LPVOID *)(v2 + 92));
    _ECX = 0;
    v5 = 4i64 * *(_DWORD *)(v2 + 12);
    __asm { seto    cl }
    *(_DWORD *)(v2 + 84) = sub_1002965B(SHIDWORD(v5), v5 | -_ECX, 4, 0, v5 | -_ECX);
    if ( *(_DWORD *)(v2 + 88) )
    {
      _ECX = 0;
      v7 = 4i64 * *(_DWORD *)(v2 + 12);
      __asm { seto    cl }
      *(_DWORD *)(v2 + 88) = sub_1002965B(SHIDWORD(v7), v7 | -_ECX, 4, 0, v7 | -_ECX);
      _ECX = 0;
      v9 = 4i64 * *(_DWORD *)(v2 + 12);
      __asm { seto    cl }
      *(_DWORD *)(v2 + 92) = sub_1002965B(SHIDWORD(v9), v9 | -_ECX, 4, 0, v9 | -_ECX);
    }
  }
  result = sub_100391F0(*(void **)(v2 + 84), 0, 4 * *(_DWORD *)(v2 + 8));
  if ( *(_DWORD *)(v2 + 88) )
  {
    sub_100391F0(*(void **)(v2 + 88), 0, 4 * *(_DWORD *)(v2 + 8));
    result = sub_100391F0(*(void **)(v2 + 92), 0, 4 * *(_DWORD *)(v2 + 8));
  }
  return result;
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (1003DB83) --------------------------------------------------------
void __usercall sub_1003DB83(int a1<ebx>, int a2<edi>, int a3<esi>, char a4)
{
  signed int v4; // eax@1
  int ebp0; // ebp@0
  int v6; // ecx@3
  int v7; // edx@6
  unsigned int v8; // ecx@6
  int v9; // ebx@6
  LPVOID v10; // edi@6
  int v11; // esi@6
  int v12; // ebx@8
  int v13; // ecx@9
  int v14; // edx@10
  unsigned int v15; // eax@24
  int v16; // ecx@24
  int v17; // edi@24
  int v18; // esi@24
  int v19; // ecx@26
  int v20; // edx@27
  ULONG_PTR v21; // ecx@42
  int i; // edx@44
  void *v23; // esi@47
  int v24; // [sp+0h] [bp-10h]@6
  int v25; // [sp+4h] [bp-Ch]@6
  int v26; // [sp+4h] [bp-Ch]@24
  int v27; // [sp+8h] [bp-8h]@6
  signed int v28; // [sp+8h] [bp-8h]@8
  unsigned int v29; // [sp+Ch] [bp-4h]@6
  unsigned int v30; // [sp+Ch] [bp-4h]@24

  v4 = dword_100758B4;
  if ( !dword_100758B4 )
  {
    sub_1003EE5C(a3);
    v4 = dword_100758B4;
  }
  v6 = dword_1007589C;
  if ( !dword_1007589C )
  {
    sub_1003BB77(a1, ebp0, a2);
    v4 = dword_100758B4;
    v6 = dword_1007589C;
  }
  if ( v4 >= 4 )
  {
    sub_1003D6A2(a1, 65535);
    v10 = dword_100758BC;
    v8 = 0;
    v11 = 0;
    v7 = 0;
    v9 = 0;
    v29 = 0;
    v27 = 0;
    v25 = 0;
    v24 = 0;
    if ( dword_100758B8 )
    {
      do
      {
        if ( *(_DWORD *)v10 == 3 )
        {
          v28 = 0;
          v12 = (int)((char *)v10 + 32);
          do
          {
            sub_1003BB3E(v12);
            v13 = *(_DWORD *)v12;
            if ( *(_DWORD *)v12 )
            {
              ++v11;
              v14 = 0;
              do
              {
                ++v14;
                v13 &= v13 - 1;
              }
              while ( v13 );
              v25 += (unsigned __int16)v14;
            }
            v12 += 12;
            ++v28;
          }
          while ( v28 < *((_WORD *)v10 + 15) );
          v9 = v24;
          v8 = v29;
          v27 = v11;
        }
        if ( *(_DWORD *)v10 == 1 )
        {
          sub_1003BB3E((int)((char *)v10 + 32));
          v11 = v27;
          v8 = v29;
          if ( *((_DWORD *)v10 + 8) )
          {
            ++v9;
            v24 = v9;
          }
        }
        v8 += *((_DWORD *)v10 + 1);
        v10 = (char *)v10 + *((_DWORD *)v10 + 1);
        v29 = v8;
      }
      while ( v8 < dword_100758B8 );
      v7 = v25;
    }
    byte_100758A8 = v11 > (unsigned int)v9;
    dword_100758AC = v11;
    if ( v11 <= (unsigned int)v9 )
      dword_100758AC = v9;
    dword_100758A4 = v7;
    dword_100758B0 = v9;
LABEL_39:
    if ( !a4 )
      sub_1003BC8E(v9);
    goto LABEL_47;
  }
  if ( v4 == 3 )
  {
    sub_1003D6A2(a1, 65535);
    v18 = (int)dword_100758BC;
    v15 = 0;
    v16 = 0;
    v9 = 0;
    v17 = 0;
    v30 = 0;
    v26 = 0;
    if ( dword_100758B8 )
    {
      do
      {
        if ( *(_DWORD *)(v18 + 4) == 3 )
        {
          sub_1003BB0F(v18);
          v19 = *(_DWORD *)v18;
          if ( *(_DWORD *)v18 )
          {
            ++v9;
            v20 = 0;
            do
            {
              ++v20;
              v19 &= v19 - 1;
            }
            while ( v19 );
            v26 += (unsigned __int16)v20;
          }
          v15 = v30;
        }
        if ( *(_DWORD *)(v18 + 4) == 1 )
        {
          sub_1003BB0F(v18);
          v15 = v30;
          if ( *(_DWORD *)v18 )
            ++v17;
        }
        v15 += 24;
        v18 += 24;
        v30 = v15;
      }
      while ( v15 < dword_100758B8 );
      v16 = v26;
    }
    byte_100758A8 = v9 > (unsigned int)v17;
    dword_100758AC = v9;
    if ( v9 <= (unsigned int)v17 )
      dword_100758AC = v17;
    dword_100758A4 = v16;
    dword_100758B0 = v17;
    goto LABEL_39;
  }
  byte_100758A8 = 0;
  dword_100758AC = 1;
  if ( v6 )
  {
    sub_1003BB77(a1, ebp0, a2);
    v21 = *(_DWORD *)sub_1003D3D4(dword_1007589C, 0) & ProcessAffinityMask;
  }
  else
  {
    v21 = ProcessAffinityMask;
  }
  for ( i = 0; v21; v21 &= v21 - 1 )
    ++i;
  dword_100758A4 = (unsigned __int16)i;
  dword_100758B0 = 1;
LABEL_47:
  v23 = (void *)dword_100758A0;
  if ( dword_100758A0 )
  {
    sub_1002A4AA(*(LPVOID *)(dword_100758A0 + 4));
    sub_1002A4AA(v23);
  }
  dword_100758A0 = 0;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1007589C: using guessed type int dword_1007589C;
// 100758A0: using guessed type int dword_100758A0;
// 100758A4: using guessed type int dword_100758A4;
// 100758A8: using guessed type char byte_100758A8;
// 100758AC: using guessed type int dword_100758AC;
// 100758B0: using guessed type int dword_100758B0;
// 100758B4: using guessed type int dword_100758B4;
// 100758B8: using guessed type int dword_100758B8;

//----- (1003DDC2) --------------------------------------------------------
int __thiscall sub_1003DDC2(int this)
{
  int result; // eax@1
  int v2; // ecx@1

  result = *(_DWORD *)(this + 172) - *(_DWORD *)(this + 184);
  v2 = *(_DWORD *)(this + 132);
  if ( result <= (unsigned int)v2 )
    result = v2;
  return result;
}

//----- (1003DDDB) --------------------------------------------------------
int __userpurge sub_1003DDDB<eax>(int a1<ecx>, int a2<ebx>, int a3, int a4, char a5)
{
  int v5; // edi@1
  int v6; // esi@1
  unsigned int v7; // ebx@3
  int v8; // ecx@4
  bool v9; // eax@5
  int v10; // eax@6
  int v11; // ebx@18
  unsigned int v13; // [sp+Ch] [bp-10h]@3
  int v14; // [sp+10h] [bp-Ch]@4
  unsigned int v15; // [sp+14h] [bp-8h]@7
  bool v16; // [sp+18h] [bp-4h]@4
  char v17; // [sp+27h] [bp+Bh]@9

  v6 = a3;
  v5 = a1;
  if ( (_BYTE)a4 )
    *(_DWORD *)(a3 + 16) = sub_1003BE06(a1, a2, a1);
  v7 = 0;
  v13 = *(_DWORD *)(a3 + 160);
  if ( a5 )
  {
    v14 = sub_1003BDD9(a3);
    v8 = sub_1003BDB6(a3);
    v16 = v8;
    if ( (_BYTE)a4 )
    {
      v9 = v14;
    }
    else
    {
      v10 = sub_1003DDC2(a3);
      v8 = (unsigned int)(*(_DWORD *)(a3 + 184) + v10) < *(_DWORD *)(v5 + 28);
      v16 = (unsigned int)(*(_DWORD *)(a3 + 184) + v10) < *(_DWORD *)(v5 + 28);
      v9 = v13 < v14;
    }
    v15 = v9;
  }
  else
  {
    v14 = *(_DWORD *)(a3 + 184) + sub_1003DDC2(a3);
    v15 = v14;
    v8 = sub_1003C109(a3);
    v16 = v8;
  }
  v17 = 0;
  if ( v8 )
  {
    sub_1003F2F1(v5, v6, a5);
    sub_1003E1D8(v5);
    v7 = sub_1003EC33(v5, v6, v16, 0);
    if ( v7 < v16 )
    {
      if ( (_BYTE)a4 || v15 )
      {
        v17 = 1;
        v7 += sub_1003E8FF(v5, v6, v16 - v7, -2);
        if ( v7 < v16 )
        {
          v7 += sub_1003E436(v5, v6, v7 + v13, v14, v13 + v16);
          if ( v7 < v15 )
          {
            v7 += sub_1003E8FF(v5, v6, v15 - v7, -1);
            if ( v7 < v15 )
              v7 += sub_1003EBFF(v5, v6, v15 - v7);
          }
        }
      }
    }
    sub_1003EE05(v5);
  }
  v11 = sub_1004C63F(v6, v7, a4, a5);
  if ( v17 )
    sub_1003BCA9((void *)v5, v6);
  return v11;
}

//----- (1003DF31) --------------------------------------------------------
int __thiscall sub_1003DF31(int this, int a2, int a3, int a4)
{
  int result; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  unsigned int v7; // edx@2
  unsigned int v8; // ebx@2
  int v9; // esi@3
  unsigned int v10; // ecx@6
  int v11; // edx@7
  char v12; // zf@7
  int v13; // [sp+8h] [bp-Ch]@3
  unsigned int v14; // [sp+Ch] [bp-8h]@2
  int v15; // [sp+10h] [bp-4h]@1
  unsigned int v16; // [sp+1Ch] [bp+8h]@6
  unsigned int v17; // [sp+20h] [bp+Ch]@6
  unsigned int v18; // [sp+24h] [bp+10h]@5

  v5 = a4;
  v15 = this;
  *(_DWORD *)a4 = a2;
  *(double *)(a4 + 8) = 0.0;
  result = a3;
  *(_DWORD *)(a4 + 16) = a3;
  v6 = *(_DWORD *)(a3 + 16);
  if ( v6 )
  {
    v7 = 0;
    v8 = 0;
    v14 = 0;
    if ( *(_DWORD *)(this + 24) )
    {
      result = 0;
      v13 = 0;
      v9 = v6 + 44;
      do
      {
        *(_DWORD *)(v9 - 4) = v7;
        *(_DWORD *)v9 = v7;
        if ( *(_DWORD *)(v9 - 16) > v7 )
        {
          v18 = v7;
          if ( *(_DWORD *)(v9 - 40) > v7 )
          {
            v17 = v7;
            v16 = v7;
            v10 = v7;
            do
            {
              v11 = v16 + *(_DWORD *)(v9 + 4);
              v12 = *(_DWORD *)v11 == 4;
              *(_BYTE *)(v11 + 48) = 0;
              if ( v12 )
              {
                if ( !*(_DWORD *)(v11 + 24) )
                {
                  sub_1003F4C9(
                    v15,
                    v9 - 44,
                    v11,
                    result + *(_DWORD *)(v15 + 72),
                    v17 + *(_DWORD *)(result + *(_DWORD *)(v15 + 72) + 32),
                    v5);
                  result = v13;
                  v10 = v18;
                }
              }
              v16 += 52;
              v17 += 36;
              ++v10;
              v18 = v10;
            }
            while ( v10 < *(_DWORD *)(v9 - 40) );
            v8 = v14;
            this = v15;
            v7 = 0;
          }
        }
        ++v8;
        result += 40;
        v9 += 52;
        v14 = v8;
        v13 = result;
      }
      while ( v8 < *(_DWORD *)(this + 24) );
    }
  }
  return result;
}

//----- (1003DFF7) --------------------------------------------------------
void *__thiscall sub_1003DFF7(int this)
{
  void *result; // eax@1
  int v2; // edi@1
  int v3; // esi@1
  int v4; // edi@2
  int v5; // eax@6
  int v6; // eax@6
  int v7; // ecx@6
  int v8; // esi@6
  unsigned int v9; // esi@10
  char v10; // al@12
  int v11; // ecx@13
  int v12; // [sp+8h] [bp-14h]@1
  unsigned int v13; // [sp+Ch] [bp-10h]@6
  int v14; // [sp+10h] [bp-Ch]@6
  int v15; // [sp+14h] [bp-8h]@1
  int v16; // [sp+18h] [bp-4h]@6

  v15 = 0;
  v3 = this;
  v12 = this;
  result = sub_1003DAC1(this);
  v2 = *(_DWORD *)(v3 + 100);
  if ( v2 )
    v4 = *(_DWORD *)(v2 + 24);
  else
    v4 = 0;
  while ( v4 )
  {
    sub_100391F0((void *)(v4 + 64), 0, 56);
    sub_1003DF31(v3, v15, v4, v4 + 64);
    if ( *(_BYTE *)(v4 + 204) )
    {
      v6 = *(_DWORD *)(v4 + 120);
      v7 = *(_DWORD *)(v4 + 8);
      v13 = 0;
      v14 = 0;
      v8 = *(_DWORD *)(v4 + 160);
      v16 = v6;
      (*(void (__stdcall **)(unsigned int *, int *, int *))(*(_DWORD *)v7 + 4))(&v13, &v14, &v16);
      v5 = sub_1004BA54(*(_DWORD *)(v4 + 56), v8, v13, v14, v16);
      *(_DWORD *)(v4 + 100) = v5;
      if ( (unsigned int)v5 > *(_DWORD *)(v4 + 160) )
        *(_DWORD *)(v4 + 100) = sub_1004C0EA((void *)v4, v5);
      *(_DWORD *)(v4 + 120) = v16;
    }
    else
    {
      *(_DWORD *)(v4 + 100) = *(_DWORD *)(v4 + 160);
    }
    v9 = *(_DWORD *)(v4 + 160);
    if ( v9 )
    {
      if ( *(_DWORD *)(v4 + 84) )
        goto LABEL_12;
    }
    else
    {
      if ( !*(_DWORD *)(v4 + 196) )
        goto LABEL_12;
    }
    if ( v9 <= *(_DWORD *)(v4 + 100) && v9 < sub_1003C109(v4) )
    {
      v10 = 1;
      goto LABEL_13;
    }
LABEL_12:
    v10 = 0;
LABEL_13:
    v3 = v12;
    v11 = v15;
    *(_BYTE *)(v4 + 97) = v10;
    result = *(void **)(v12 + 84);
    *((_DWORD *)result + v11) = v4 + 64;
    v15 = v11 + 1;
    if ( v4 == *(_DWORD *)(v12 + 100) )
      v4 = 0;
    else
      v4 = *(_DWORD *)(v4 + 24);
  }
  return result;
}

//----- (1003E107) --------------------------------------------------------
void __fastcall sub_1003E107(int a1)
{
  unsigned int v1; // ebx@1
  int v2; // eax@2
  int v3; // edi@2
  int v4; // esi@2
  int v5; // edx@7
  unsigned int v6; // eax@14
  int v7; // [sp+4h] [bp-8h]@5
  unsigned int v8; // [sp+4h] [bp-8h]@10
  int v9; // [sp+8h] [bp-4h]@1

  v1 = 0;
  v9 = a1;
  if ( *(_DWORD *)(a1 + 8) )
  {
    do
    {
      v2 = *(_DWORD *)(a1 + 84);
      v3 = *(_DWORD *)(v2 + 4 * v1);
      v4 = *(_DWORD *)(v3 + 16);
      if ( *(_DWORD *)(v4 + 168) )
        sub_1003D6CB(a1, v4, *(_DWORD *)(v2 + 4 * v1));
      if ( *(_DWORD *)(v3 + 20) )
      {
        v7 = *(_DWORD *)(v4 + 160);
        if ( *(_DWORD *)(v3 + 36) > (unsigned int)(v7 - *(_DWORD *)(v3 + 20)) )
        {
          if ( *(_DWORD *)(v4 + 184) + sub_1003DDC2(v4) <= (unsigned int)(v7 - *(_DWORD *)(v3 + 20)) )
            v5 = v7 - *(_DWORD *)(v3 + 20);
          else
            v5 = *(_DWORD *)(v4 + 184) + sub_1003DDC2(v4);
          *(_DWORD *)(v3 + 36) = v5;
        }
      }
      v8 = *(_DWORD *)(v4 + 160);
      if ( *(_DWORD *)(v3 + 36) < v8 )
      {
        if ( v8 - *(_DWORD *)(v4 + 168) > *(_DWORD *)(v4 + 184) + sub_1003DDC2(v4) )
          sub_1003D7E4((void *)v9, v4, v3);
      }
      if ( !*(_BYTE *)(v4 + 204) )
      {
        v6 = *(_DWORD *)(v4 + 160);
        if ( *(_DWORD *)(v3 + 36) > v6 )
          *(_DWORD *)(v3 + 36) = v6;
      }
      a1 = v9;
      ++v1;
    }
    while ( v1 < *(_DWORD *)(v9 + 8) );
  }
}

//----- (1003E1D8) --------------------------------------------------------
unsigned int __thiscall sub_1003E1D8(int this)
{
  int v1; // edi@1
  unsigned int v2; // esi@1
  unsigned int result; // eax@2
  int v4; // ecx@2

  v1 = this;
  v2 = 0;
  if ( *(_DWORD *)(this + 8) )
  {
    do
    {
      result = *(_DWORD *)(*(_DWORD *)(v1 + 84) + 4 * v2);
      v4 = *(_DWORD *)(result + 16);
      if ( *(_DWORD *)(v4 + 168) )
        result = sub_1003D6CB(v1, v4, *(_DWORD *)(*(_DWORD *)(v1 + 84) + 4 * v2));
      ++v2;
    }
    while ( v2 < *(_DWORD *)(v1 + 8) );
  }
  return result;
}

//----- (1003E207) --------------------------------------------------------
unsigned int __thiscall sub_1003E207(void *this, unsigned int a2)
{
  unsigned int v2; // edx@1
  unsigned int v3; // ecx@1
  void *v4; // esi@1
  int v5; // ebx@3
  int v6; // edi@3
  int v7; // eax@6
  unsigned int v8; // ecx@7
  int v9; // eax@9
  unsigned int v10; // ebx@10
  int v11; // edi@11
  int v12; // eax@14
  int v13; // ebx@16
  int v14; // edi@16
  int v15; // edi@21
  int v16; // ebx@22
  int v17; // ecx@23
  int v18; // esi@23
  char v19; // zf@28
  int v20; // ecx@29
  int v21; // eax@30
  int v22; // ebx@30
  int v23; // ecx@30
  int v24; // eax@30
  int v25; // ebx@30
  int v26; // edx@31
  int v27; // eax@32
  int v28; // ecx@32
  int v29; // edi@32
  unsigned int v30; // edi@32
  char v31; // cf@32
  unsigned int v32; // ebx@33
  int v33; // edi@33
  int v34; // eax@34
  unsigned int v35; // edx@34
  unsigned int v36; // eax@36
  int v37; // eax@39
  unsigned int v39; // [sp+Ch] [bp-30h]@7
  int v40; // [sp+10h] [bp-2Ch]@22
  int v41; // [sp+14h] [bp-28h]@32
  unsigned int v42; // [sp+18h] [bp-24h]@32
  int v43; // [sp+18h] [bp-24h]@34
  int v44; // [sp+20h] [bp-1Ch]@30
  int v45; // [sp+24h] [bp-18h]@23
  int v46; // [sp+24h] [bp-18h]@30
  int v47; // [sp+28h] [bp-14h]@23
  int v48; // [sp+28h] [bp-14h]@32
  void *v49; // [sp+2Ch] [bp-10h]@1
  int v50; // [sp+30h] [bp-Ch]@28
  int v51; // [sp+30h] [bp-Ch]@30
  int v52; // [sp+34h] [bp-8h]@21
  int v53; // [sp+38h] [bp-4h]@23
  int v54; // [sp+38h] [bp-4h]@32

  v2 = a2;
  v4 = this;
  v3 = 0;
  v49 = v4;
  if ( a2 )
  {
    if ( a2 <= 0 )
      goto LABEL_6;
    do
    {
      do
      {
        v6 = *((_DWORD *)v4 + 23);
        v5 = *(_DWORD *)(v6 + 4 * v3);
        if ( *(_DWORD *)(v5 + 4) )
          break;
        --v2;
        *(_DWORD *)(v6 + 4 * v3) = *(_DWORD *)(v6 + 4 * v2);
        *(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v2) = v5;
      }
      while ( v3 < v2 );
      a2 = v2;
LABEL_6:
      *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v3) + 40) = 0;
      *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v3) + 44) = 0;
      v7 = *(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v3++);
      *(_BYTE *)(v7 + 32) = 1;
    }
    while ( v3 < v2 );
  }
  v8 = 0;
  v39 = v2;
  if ( v2 )
  {
    if ( v2 <= 0 )
      goto LABEL_20;
    do
    {
      do
      {
        v9 = *(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v8);
        if ( *(_DWORD *)(v9 + 40) )
          break;
        v10 = 0;
        if ( *((_DWORD *)v4 + 6) )
        {
          v11 = *(_DWORD *)(*(_DWORD *)(v9 + 16) + 16) + 28;
          do
          {
            if ( *(_DWORD *)v11 )
            {
              if ( *(_DWORD *)v11 < *(_DWORD *)(v11 - 24) )
              {
                v12 = *(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v8);
                ++*(_DWORD *)(v12 + 40);
              }
            }
            ++v10;
            v11 += 52;
          }
          while ( v10 < *((_DWORD *)v4 + 6) );
        }
        v14 = *((_DWORD *)v4 + 23);
        v13 = *(_DWORD *)(v14 + 4 * v8);
        if ( !*(_DWORD *)(v13 + 40) )
        {
          --v2;
          *(_DWORD *)(v14 + 4 * v8) = *(_DWORD *)(v14 + 4 * v2);
          *(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v2) = v13;
        }
      }
      while ( v8 < v2 );
      a2 = v2;
LABEL_20:
      ++v8;
    }
    while ( v8 < v2 );
  }
  v15 = 0;
  v52 = 0;
  if ( v2 )
  {
    do
    {
      v40 = v15 + 1;
      v16 = v15 + 1;
      if ( v15 + 1 < v2 )
      {
        v53 = *((_DWORD *)v4 + 23);
        v17 = 4 * v15;
        v18 = v15;
        v45 = 4 * v15;
        v47 = 4 * v15;
        do
        {
          if ( *(_DWORD *)(*(_DWORD *)(v53 + 4 * v16) + 40) >= *(_DWORD *)(*(_DWORD *)(v17 + v53) + 40) )
          {
            v17 = v47;
          }
          else
          {
            v17 = 4 * v16;
            v18 = v16;
            v47 = 4 * v16;
          }
          ++v16;
        }
        while ( v16 < v2 );
        v15 = v52;
        v50 = v18;
        v19 = v52 == v18;
        v4 = v49;
        if ( !v19 )
        {
          v20 = *(_DWORD *)(v45 + v53);
          *(_DWORD *)(v45 + v53) = *(_DWORD *)(v53 + 4 * v50);
          v4 = v49;
          v15 = v52;
          *(_DWORD *)(*((_DWORD *)v49 + 23) + 4 * v50) = v20;
        }
      }
      v23 = *(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v15);
      v24 = *(_DWORD *)(v23 + 16);
      v25 = *(_DWORD *)(v24 + 16);
      v21 = *(_DWORD *)(v24 + 20);
      v46 = v25;
      v22 = 0;
      v51 = v21;
      v44 = 0;
      if ( *(_DWORD *)(v23 + 40) )
      {
        v26 = v21;
        do
        {
          v30 = *((_DWORD *)v4 + 6);
          v28 = v46 + 52 * *(_DWORD *)(v26 + 4 * v22);
          v41 = *(_DWORD *)(v26 + 4 * v22);
          v27 = v22 + 1;
          v42 = v30;
          v31 = v22 + 1 < v30;
          v29 = v52;
          v54 = v22;
          v48 = v22 + 1;
          if ( v31 )
          {
            v32 = v42;
            v33 = v27;
            do
            {
              v34 = v46 + 52 * *(_DWORD *)(v51 + 4 * v33);
              v43 = v34;
              v35 = *(_DWORD *)(v34 + 28);
              if ( !v35
                || v35 >= *(_DWORD *)(v34 + 4)
                || (v36 = *(_DWORD *)(v28 + 28)) != 0 && v36 < *(_DWORD *)(v28 + 4) && v35 <= v36 )
              {
                v37 = v54;
              }
              else
              {
                v28 = v43;
                v37 = v33;
                v54 = v33;
              }
              ++v33;
            }
            while ( v33 < v32 );
            v4 = v49;
            v29 = v52;
            v26 = v51;
            if ( v44 != v37 )
            {
              *(_DWORD *)(v51 + 4 * v44) = *(_DWORD *)(v51 + 4 * v37);
              *(_DWORD *)(v51 + 4 * v54) = v41;
            }
            v27 = v48;
          }
          v22 = v27;
          v44 = v27;
        }
        while ( (unsigned int)v27 < *(_DWORD *)(*(_DWORD *)(*((_DWORD *)v4 + 23) + 4 * v29) + 40) );
        v2 = a2;
      }
      v15 = v40;
      v52 = v40;
    }
    while ( v40 < v2 );
  }
  return v39;
}

//----- (1003E436) --------------------------------------------------------
unsigned int __thiscall sub_1003E436(int this, int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  int v5; // eax@1
  unsigned int v6; // ecx@1
  unsigned int v7; // ebx@2
  int v8; // edi@2
  unsigned int v9; // esi@2
  int v10; // ecx@3
  int v11; // ST40_4@3
  int v12; // eax@3
  int v13; // eax@4
  signed int v15; // ebx@7
  int v16; // eax@9
  int v18; // edi@9
  double v19; // st7@9
  signed __int64 v20; // qax@9
  int v21; // ecx@9
  signed int v22; // edi@10
  int v23; // esi@10
  double v24; // st6@16
  unsigned int v25; // ecx@17
  double v26; // st7@17
  int v27; // eax@18
  char v28; // dl@19
  signed int v29; // ecx@19
  unsigned int v30; // edi@20
  unsigned __int8 v31; // cf@20
  unsigned __int8 v32; // zf@20
  double v33; // st7@21
  double v34; // st6@21
  int v35; // eax@25
  char v36; // dl@27
  double v37; // st7@27
  double v38; // st6@27
  int v39; // eax@31
  int v40; // eax@32
  int v41; // eax@32
  char v42; // cl@33
  double v43; // st7@33
  double v44; // st7@33
  double v45; // st6@33
  unsigned int v46; // ecx@37
  int v47; // eax@39
  int v48; // edx@39
  double v50; // [sp+4h] [bp-3Ch]@17
  double v51; // [sp+Ch] [bp-34h]@16
  double v52; // [sp+14h] [bp-2Ch]@9
  int v53; // [sp+20h] [bp-20h]@26
  unsigned int v54; // [sp+24h] [bp-1Ch]@1
  int v55; // [sp+2Ch] [bp-14h]@3
  unsigned int v56; // [sp+2Ch] [bp-14h]@20
  int v57; // [sp+2Ch] [bp-14h]@26
  int v58; // [sp+2Ch] [bp-14h]@31
  int v59; // [sp+30h] [bp-10h]@9
  int v60; // [sp+34h] [bp-Ch]@2
  unsigned int v61; // [sp+34h] [bp-Ch]@7
  int v62; // [sp+34h] [bp-Ch]@25
  int v63; // [sp+34h] [bp-Ch]@32
  int v64; // [sp+38h] [bp-8h]@1
  unsigned int v65; // [sp+3Ch] [bp-4h]@2
  int v66; // [sp+50h] [bp+10h]@3
  unsigned int v67; // [sp+50h] [bp+10h]@7
  signed int v68; // [sp+50h] [bp+10h]@9
  int v69; // [sp+50h] [bp+10h]@11
  int v70; // [sp+50h] [bp+10h]@20
  char v71; // [sp+53h] [bp+13h]@19
  int v72; // [sp+54h] [bp+14h]@20
  unsigned int v73; // [sp+54h] [bp+14h]@26
  int v74; // [sp+54h] [bp+14h]@32

  v54 = 0;
  v5 = this;
  v6 = *(_DWORD *)(this + 8);
  v64 = v5;
  if ( v6 > 1 )
  {
    v8 = *(_DWORD *)(v5 + 84) + 4;
    v9 = 1;
    v7 = a4;
    v65 = a3;
    v60 = v6 - 1;
    do
    {
      v11 = *(_DWORD *)(*(_DWORD *)v8 + 16);
      v66 = *(_DWORD *)(v11 + 184);
      v12 = sub_1003DDC2(*(_DWORD *)(*(_DWORD *)v8 + 16));
      v10 = v11;
      v55 = *(_DWORD *)(v11 + 160) - *(_DWORD *)(v11 + 168);
      if ( v55 <= (unsigned int)(v66 + v12) )
      {
        v13 = v65;
      }
      else
      {
        ++v9;
        v7 += v66 + sub_1003DDC2(v10);
        v13 = v55 + v65;
        v65 += v55;
      }
      v8 += 4;
    }
    while ( v60-- != 1 );
    v67 = v7;
    v15 = 1;
    v61 = v9;
    if ( v9 > 1 )
    {
      if ( v67 <= v13 )
      {
        _ECX = 0;
        v20 = 4i64 * v9;
        __asm { seto    cl }
        v16 = sub_1002965B(SHIDWORD(v20), v20 | -_ECX, 1, v8, v20 | -_ECX);
        v18 = v16;
        v21 = **(_DWORD **)(v64 + 84);
        v59 = v16;
        *(_DWORD *)v16 = v21;
        *(double *)(v21 + 32) = (double)a5;
        v68 = 1;
        v19 = *(double *)(*(_DWORD *)v16 + 32) + 0.0;
        v52 = v19;
        if ( *(_DWORD *)(v64 + 8) > 1u )
        {
          v23 = v16 + 4;
          v22 = v68;
          do
          {
            v69 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v64 + 84) + 4 * v22) + 16);
            if ( *(_DWORD *)(v69 + 160) - *(_DWORD *)(v69 + 168) <= (unsigned int)(*(_DWORD *)(v69 + 184)
                                                                                 + sub_1003DDC2(v69)) )
            {
              v19 = v52;
            }
            else
            {
              *(_DWORD *)v23 = v69 + 64;
              v23 += 4;
              v19 = *(double *)(v69 + 96) + v52;
              v52 = v19;
            }
            ++v22;
          }
          while ( (unsigned int)v22 < *(_DWORD *)(v64 + 8) );
          v9 = v61;
          v18 = v59;
          v15 = 1;
        }
        v24 = (double)v65;
        v51 = v24;
        while ( 1 )
        {
          v26 = v24 / v19;
          v25 = 0;
          v50 = v26;
          if ( v9 )
          {
            do
            {
              v27 = *(_DWORD *)(v18 + 4 * v25++);
              *(double *)(v27 + 8) = *(double *)(v27 + 32) * v26;
            }
            while ( v25 < v9 );
          }
          sub_1003EF44(v18, v9);
          v28 = 0;
          v71 = 0;
          v29 = v15;
          if ( v9 <= v15 )
            goto LABEL_48;
          do
          {
            v70 = *(_DWORD *)(v18 + 4 * v29);
            v72 = *(_DWORD *)(*(_DWORD *)(v70 + 16) + 160) - *(_DWORD *)(*(_DWORD *)(v70 + 16) + 168);
            v30 = *(_DWORD *)(v70 + 4);
            v56 = v30;
            v31 = v30 < v72;
            v32 = v30 == v72;
            v18 = v59;
            if ( v31 | v32 )
            {
              v19 = v52;
            }
            else
            {
              v33 = (double)(unsigned int)v72 / (double)v56;
              v28 = v15;
              v52 = v52 - (1.0 - v33) * *(double *)(v70 + 32);
              v34 = v33 * *(double *)(v70 + 32);
              v19 = v52;
              *(_QWORD *)(v70 + 32) = *(_QWORD *)&v34;
            }
            ++v29;
          }
          while ( v29 < v9 );
          v24 = v51;
          v71 = v28;
          if ( !v28 )
          {
LABEL_48:
            v35 = 0;
            v62 = 0;
            if ( !v9 )
              goto LABEL_49;
            do
            {
              v53 = *(_DWORD *)(v18 + 4 * v35);
              v57 = *(_DWORD *)(v53 + 16);
              v73 = *(_DWORD *)(v53 + 4);
              if ( v73 <= sub_1003C109(v57) )
              {
                v19 = v52;
                v36 = v71;
              }
              else
              {
                v37 = (double)(unsigned int)sub_1003C109(v57) / (double)v73;
                v36 = v15;
                v71 = v15;
                v52 = v52 - (1.0 - v37) * *(double *)(v53 + 32);
                v38 = v37 * *(double *)(v53 + 32);
                v19 = v52;
                *(_QWORD *)(v53 + 32) = *(_QWORD *)&v38;
              }
              v35 = v62 + 1;
              v62 = v35;
            }
            while ( v35 < v9 );
            v24 = v51;
            if ( !v36 )
            {
LABEL_49:
              v39 = 0;
              v58 = 0;
              if ( !v9 )
                break;
              do
              {
                v40 = *(_DWORD *)(v18 + 4 * v39);
                v63 = v40;
                v41 = *(_DWORD *)(v40 + 16);
                v74 = *(_DWORD *)(v41 + 184);
                if ( (unsigned int)(v74 + sub_1003DDC2(v41)) <= *(_DWORD *)(v63 + 4) )
                {
                  v19 = v52;
                  v42 = v71;
                }
                else
                {
                  v43 = (double)(unsigned int)(v74 + sub_1003DDC2(*(_DWORD *)(v63 + 16)));
                  v42 = v15;
                  v44 = v43 / v50;
                  v71 = v15;
                  v52 = v44 - *(double *)(v63 + 32) + v52;
                  v45 = v44;
                  v19 = v52;
                  *(_QWORD *)(v63 + 32) = *(_QWORD *)&v45;
                }
                v39 = v58 + 1;
                v58 = v39;
              }
              while ( v39 < v9 );
              v24 = v51;
              if ( !v42 )
                break;
            }
          }
        }
        v46 = a3;
        if ( *(_DWORD *)(*(_DWORD *)v18 + 4) > a3 )
        {
          if ( v9 > v15 )
          {
            do
            {
              v47 = *(_DWORD *)(v18 + 4 * v15);
              v48 = *(_DWORD *)(v47 + 16);
              if ( *(_DWORD *)(v48 + 160) - *(_DWORD *)(v47 + 4) != *(_DWORD *)(v48 + 168) )
                sub_1003E954(v64, a2, v48, *(_DWORD *)(v48 + 160) - *(_DWORD *)(v47 + 4) - *(_DWORD *)(v48 + 168));
              ++v15;
            }
            while ( v15 < v9 );
            v46 = a3;
          }
          v54 = sub_1003EC33(v64, a2, *(_DWORD *)(*(_DWORD *)v18 + 4) - v46, 0);
        }
        sub_100303A3((LPVOID)v18);
      }
    }
  }
  return v54;
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (1003E809) --------------------------------------------------------
int __thiscall sub_1003E809(void *this)
{
  _ECX = (int)((char *)this + 4);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return _EAX + 1;
}

//----- (1003E815) --------------------------------------------------------
int __stdcall sub_1003E815(int a1, int a2)
{
  int (__stdcall **v3)(char); // [sp+0h] [bp-Ch]@6

  if ( !a1 )
  {
    a1 = (int)"pScheduler";
    goto LABEL_6;
  }
  if ( a2 != 65536 )
  {
    a1 = (int)"version";
LABEL_6:
    sub_1002AEA4((int)&v3, &a1);
    v3 = &off_1005F2EC;
    sub_100355BB((int)&v3, (int)&unk_1006C8B4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003E868);
  }
  return sub_1003BFAB(a1);
}
// 1003BFAB: using guessed type _DWORD __stdcall sub_1003BFAB(_DWORD);
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);

//----- (1003E868) --------------------------------------------------------
int __usercall sub_1003E868<eax>(int a1<ebp>)
{
  int v1; // edi@1
  int v2; // ecx@1
  int v10; // ST04_4@2

  sub_10035648();
  v1 = v2;
  _EAX = v2 + 4;
  _EBX = -1;
  __asm { lock xadd [eax], ebx }
  if ( _EBX == 1 )
  {
    *(_DWORD *)(a1 - 16) = &dword_10075F54;
    sub_10030FB0(&dword_10075F54);
    v10 = dword_10075890;
    *(_DWORD *)(a1 - 4) = 0;
    dword_10075890 = v1 != sub_100348F9(v10) ? dword_10075890 : 0;
    *(_DWORD *)(a1 - 4) = -1;
    dword_10075F54 = 0;
    if ( *(_DWORD *)(v1 + 76) )
    {
      sub_1002B91D((LPCRITICAL_SECTION)(v1 + 44));
      *(_DWORD *)(v1 + 40) = 2;
      sub_1002BB52((LPCRITICAL_SECTION)(v1 + 44));
      SetEvent(*(HANDLE *)(v1 + 80));
      WaitForSingleObject(*(HANDLE *)(v1 + 76), 0xFFFFFFFFu);
    }
    sub_1003B8CE(a1);
    sub_1002A4AA((LPVOID)v1);
  }
  return sub_10035616(4);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 10075890: using guessed type int dword_10075890;
// 10075F54: using guessed type int dword_10075F54;

//----- (1003E8FF) --------------------------------------------------------
unsigned int __thiscall sub_1003E8FF(int this, int a2, unsigned int a3, int a4)
{
  unsigned int v4; // ebx@1
  signed int v5; // edi@1
  int v6; // esi@1
  char v7; // zf@5

  v6 = this;
  v5 = 1;
  v4 = 0;
  if ( *(_DWORD *)(this + 8) > 1u )
  {
    do
    {
      if ( sub_1003E954(v6, a2, *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 84) + 4 * v5) + 16), a4) )
        LOBYTE(v4) = 1;
      ++v5;
    }
    while ( (unsigned int)v5 < *(_DWORD *)(v6 + 8) );
    v7 = (_BYTE)v4 == 0;
    v4 = 0;
    if ( !v7 )
      v4 = sub_1003EC33(v6, a2, a3, 0);
  }
  return v4;
}

//----- (1003E954) --------------------------------------------------------
char __thiscall sub_1003E954(int this, int a2, int a3, int a4)
{
  int v4; // edx@1
  int v5; // esi@1
  int v6; // eax@2
  int v7; // ebx@6
  int v8; // eax@7
  int v9; // edi@7
  int v10; // ecx@8
  unsigned int v11; // eax@9
  int v12; // edi@11
  int v14; // [sp+Ch] [bp-Ch]@7
  int v15; // [sp+10h] [bp-8h]@7
  int v16; // [sp+14h] [bp-4h]@1
  int v17; // [sp+20h] [bp+8h]@7
  unsigned int v18; // [sp+24h] [bp+Ch]@9
  int v19; // [sp+28h] [bp+10h]@10

  v4 = a4;
  v5 = a3;
  v16 = this;
  if ( a4 == -2 )
  {
    v6 = *(_DWORD *)(a3 + 168);
    v4 = *(_DWORD *)(a3 + 168);
  }
  else
  {
    if ( a4 == -1 )
    {
      v4 = *(_DWORD *)(a3 + 168)
         + *(_DWORD *)(a3 + 160)
         - *(_DWORD *)(a3 + 108)
         - *(_DWORD *)(a3 + 168)
         - (*(_DWORD *)(a3 + 184)
          + sub_1003DDC2(a3));
      this = v16;
    }
    v6 = 0;
  }
  v7 = v4 - v6;
  if ( !v4
    || (v9 = *(_DWORD *)(a3 + 16),
        v15 = *(_DWORD *)(a2 + 20),
        v8 = 0,
        v14 = *(_DWORD *)(a3 + 16),
        v17 = 0,
        !*(_DWORD *)(this + 24)) )
    return 0;
  while ( 1 )
  {
    v10 = v9 + 52 * *(_DWORD *)(v15 + 4 * v8);
    if ( *(_DWORD *)(v10 + 28) != *(_DWORD *)(v10 + 36) )
    {
      v11 = 0;
      v18 = 0;
      if ( *(_DWORD *)(v10 + 4) )
        break;
    }
LABEL_21:
    v8 = v17 + 1;
    v17 = v8;
    if ( (unsigned int)v8 >= *(_DWORD *)(v16 + 24) )
      return 0;
  }
  v19 = 0;
  while ( 1 )
  {
    v12 = v19 + *(_DWORD *)(v10 + 48);
    if ( *(_DWORD *)v12 != 4 || *(_DWORD *)(v12 + 40) )
      goto LABEL_19;
    if ( *(_BYTE *)(v12 + 49) || v7 )
    {
      *(_DWORD *)v12 = 5;
      ++*(_DWORD *)(v5 + 108);
      --**(_DWORD **)(v12 + 20);
      if ( !*(_BYTE *)(v12 + 49) )
        --v7;
      --v4;
      if ( !v4 )
        return 1;
    }
    v11 = v18;
LABEL_19:
    v19 += 52;
    ++v11;
    v18 = v11;
    if ( v11 >= *(_DWORD *)(v10 + 4) )
    {
      v9 = v14;
      goto LABEL_21;
    }
  }
}

//----- (1003EA4A) --------------------------------------------------------
int __thiscall sub_1003EA4A(int this, int a2)
{
  int result; // eax@1

  --*(_DWORD *)this;
  *(_DWORD *)(*(_DWORD *)(a2 + 24) + 28) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(*(_DWORD *)(a2 + 28) + 24) = *(_DWORD *)(a2 + 24);
  result = *(_DWORD *)(this + 4);
  if ( a2 == result )
  {
    if ( result == *(_DWORD *)(result + 24) )
      result = 0;
    else
      result = *(_DWORD *)(result + 28);
    *(_DWORD *)(this + 4) = result;
  }
  return result;
}

//----- (1003EA80) --------------------------------------------------------
int __userpurge sub_1003EA80<eax>(int a1<ebp>, int a2)
{
  int v2; // ebx@1
  struct _RTL_CRITICAL_SECTION *v3; // esi@1
  int v4; // ecx@1
  int v5; // ecx@1
  int v6; // edi@1

  sub_10035648();
  v2 = v4;
  *(_DWORD *)(a1 - 16) = 0;
  v3 = (struct _RTL_CRITICAL_SECTION *)(v4 + 44);
  *(_DWORD *)(a1 - 20) = v4 + 44;
  sub_1002B91D((LPCRITICAL_SECTION)(v4 + 44));
  v5 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  v6 = *(_DWORD *)(v5 + 20);
  sub_1004B45A(v5);
  if ( *(_DWORD *)(v6 + 160) < (unsigned int)sub_1003C109(v6) )
  {
    if ( *(_DWORD *)(v2 + 8) == 1 )
    {
      if ( !sub_1003C4C1(v2) )
        *(_BYTE *)(a1 - 16) = 1;
    }
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002BB52(v3);
  if ( *(_BYTE *)(a1 - 16) )
    SetEvent(*(HANDLE *)(v2 + 80));
  return sub_10035616(8);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1003EAF4) --------------------------------------------------------
int __userpurge sub_1003EAF4<eax>(int a1<ebp>, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  struct _RTL_CRITICAL_SECTION *v5; // esi@1
  int v6; // ecx@1
  char v7; // zf@1
  int v8; // eax@2
  int v9; // eax@6
  char v10; // bl@12
  int v12; // ebx@13
  signed __int64 v13; // qax@13
  signed __int64 v15; // qax@13

  sub_10035648();
  v4 = v6;
  v5 = (struct _RTL_CRITICAL_SECTION *)(v6 + 44);
  *(_DWORD *)(a1 - 16) = 0;
  *(_BYTE *)(a1 - 20) = 0;
  *(_DWORD *)(a1 - 24) = v6 + 44;
  sub_1002B91D((LPCRITICAL_SECTION)(v6 + 44));
  v7 = *(_BYTE *)(a1 + 12) == 0;
  *(_DWORD *)(a1 - 4) = 0;
  v3 = *(_DWORD *)(a1 + 8);
  if ( !v7 )
  {
    v8 = sub_1004C9FB(*(_DWORD *)(a1 + 8), a1);
    *(_DWORD *)(a1 - 16) = v8;
    if ( !v8 )
      *(_BYTE *)(a1 - 20) = 1;
  }
  if ( *(_DWORD *)(v3 + 132) == *(_DWORD *)(v3 + 128) )
    ++*(_DWORD *)(v4 + 16);
  ++*(_DWORD *)(v4 + 8);
  sub_1003B9E3(v4 + 96, v3);
  v9 = sub_1003DDDB(v4, v3, v3, 1, *(_DWORD *)(a1 - 20));
  if ( !*(_DWORD *)(a1 - 16) )
    *(_DWORD *)(a1 - 16) = v9;
  if ( *(_DWORD *)(v3 + 132) == *(_DWORD *)(v3 + 128) )
    sub_1003F122((void *)v4, v3);
  if ( *(_DWORD *)(v4 + 8) == 2 )
  {
    v10 = 0;
    *(_DWORD *)(v4 + 40) = 1;
    if ( !*(_DWORD *)(v4 + 76) )
    {
      *(_DWORD *)(v4 + 76) = 1;
      _ECX = 0;
      v12 = 4;
      v13 = 4i64 * *(_DWORD *)(v4 + 12);
      __asm { seto    cl }
      *(_DWORD *)(v4 + 88) = sub_1002965B(SHIDWORD(v13), v13 | -_ECX, 4, v4, v13 | -_ECX);
      _ECX = 0;
      v15 = 4i64 * *(_DWORD *)(v4 + 12);
      __asm { seto    cl }
      *(_DWORD *)(v4 + 92) = sub_1002965B(SHIDWORD(v15), v15 | -_ECX, v12, v4, v15 | -_ECX);
      v10 = 1;
    }
    *(_DWORD *)(a1 - 4) = -1;
    sub_1002BB52(v5);
    SetEvent(*(HANDLE *)(v4 + 80));
    if ( v10 )
      sub_1003BF33((LPVOID)v4);
  }
  else
  {
    *(_DWORD *)(a1 - 4) = -1;
    sub_1002BB52(v5);
  }
  return sub_10035616(12);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1003EBFF) --------------------------------------------------------
unsigned int __thiscall sub_1003EBFF(int this, int a2, unsigned int a3)
{
  int v3; // edi@1
  unsigned int v4; // esi@1
  unsigned int v5; // eax@2
  int v7; // [sp+8h] [bp-4h]@1

  v3 = 0;
  v4 = 0;
  v7 = this;
  if ( a3 )
  {
    do
    {
      ++v3;
      v5 = sub_1003EC33(this, a2, a3 - v4, v3);
      this = v7;
      v4 += v5;
    }
    while ( v4 < a3 );
  }
  return v4;
}

//----- (1003EC33) --------------------------------------------------------
unsigned int __thiscall sub_1003EC33(int this, int a2, unsigned int a3, int a4)
{
  int v4; // ebx@1
  char v5; // dl@3
  int v6; // ecx@3
  unsigned int v7; // esi@3
  int v8; // ecx@4
  unsigned int v9; // eax@5
  int v10; // edi@6
  int v11; // edx@7
  unsigned int result; // eax@14
  int v13; // edi@15
  int v14; // eax@16
  int v15; // edx@17
  int v16; // ebx@17
  int v17; // esi@17
  int v18; // esi@20
  int v19; // eax@21
  char v20; // zf@23
  int v21; // ST10_4@23
  int v22; // ecx@23
  char v23; // cf@23
  int v24; // ebx@33
  unsigned int v25; // edi@33
  int v26; // eax@34
  int v27; // ecx@45
  unsigned int v28; // [sp+10h] [bp-1Ch]@3
  int v29; // [sp+10h] [bp-1Ch]@15
  int v30; // [sp+14h] [bp-18h]@1
  int v31; // [sp+18h] [bp-14h]@1
  unsigned int v32; // [sp+1Ch] [bp-10h]@5
  int v33; // [sp+1Ch] [bp-10h]@17
  int v34; // [sp+20h] [bp-Ch]@3
  int v35; // [sp+24h] [bp-8h]@3
  char v36; // [sp+2Bh] [bp-1h]@3
  unsigned int v37; // [sp+3Ch] [bp+10h]@14

  v30 = -1;
  v4 = this;
  v31 = this;
  if ( *(_BYTE *)(a2 + 104) )
    v30 = sub_1003D48E(this, a2, 0);
  v6 = *(_DWORD *)(a2 + 20);
  v7 = 0;
  v5 = 0;
  v34 = *(_DWORD *)(a2 + 16);
  v35 = *(_DWORD *)(a2 + 20);
  v36 = 0;
  v28 = 0;
  if ( *(_DWORD *)(v4 + 24) )
  {
    v8 = *(_DWORD *)(a2 + 16) + 8;
    do
    {
      v9 = 0;
      v32 = 0;
      if ( *(_DWORD *)(v8 - 4) )
      {
        v10 = 0;
        do
        {
          v11 = v10 + *(_DWORD *)(v8 + 40);
          if ( *(_DWORD *)v11 == 1 )
          {
            v9 = v32;
            if ( a4 == **(_DWORD **)(v11 + 20) )
            {
              *(_DWORD *)v11 = 2;
              ++*(_DWORD *)v8;
              v36 = 1;
            }
          }
          ++v9;
          v10 += 52;
          v32 = v9;
        }
        while ( v9 < *(_DWORD *)(v8 - 4) );
        v7 = v28;
        v4 = v31;
      }
      ++v7;
      v8 += 52;
      v28 = v7;
    }
    while ( v7 < *(_DWORD *)(v4 + 24) );
    v6 = v35;
    v5 = v36;
  }
  result = 0;
  v37 = 0;
  if ( v5 )
  {
    v13 = 0;
    v29 = 0;
    if ( *(_DWORD *)(v4 + 24) > 0u )
    {
      v14 = v31;
      do
      {
        v15 = v34 + 52 * *(_DWORD *)(v6 + 4 * v13);
        v17 = v13;
        v33 = v13;
        v16 = a3 - v37;
        if ( a3 != v37 )
        {
          if ( *(_DWORD *)(v15 + 8) > (unsigned int)v16 )
            *(_DWORD *)(v15 + 8) = v16;
          v18 = v13 + 1;
          if ( (unsigned int)(v13 + 1) < *(_DWORD *)(v14 + 24) )
          {
            do
            {
              v19 = v34 + 52 * *(_DWORD *)(v6 + 4 * v18);
              if ( *(_DWORD *)(v19 + 8) > (unsigned int)v16 )
                *(_DWORD *)(v19 + 8) = v16;
              v21 = *(_DWORD *)(v19 + 24) + *(_DWORD *)(v19 + 28) + *(_DWORD *)(v19 + 8);
              v22 = *(_DWORD *)(v15 + 8) + *(_DWORD *)(v15 + 24) + *(_DWORD *)(v15 + 28);
              v23 = v22 < (unsigned int)v21;
              v20 = v22 == v21;
              v6 = v35;
              if ( v23 || v20 && *(_BYTE *)(a2 + 104) && *(_DWORD *)(v35 + 4 * v18) == v30 )
              {
                v15 = v34 + 52 * *(_DWORD *)(v35 + 4 * v18);
                v33 = v18;
              }
              ++v18;
            }
            while ( (unsigned int)v18 < *(_DWORD *)(v31 + 24) );
            v13 = v29;
          }
          v17 = v33;
        }
        if ( *(_DWORD *)(v15 + 8) )
        {
          if ( *(_DWORD *)(v15 + 4) )
          {
            v25 = 0;
            v24 = 0;
            do
            {
              v26 = v24 + *(_DWORD *)(v15 + 48);
              if ( *(_DWORD *)v26 == 2 )
              {
                v6 = v35;
                if ( v37 >= a3 )
                {
                  *(_DWORD *)v26 = 1;
                }
                else
                {
                  *(_DWORD *)v26 = 3;
                  ++**(_DWORD **)(v26 + 20);
                  ++*(_DWORD *)(v15 + 24);
                  if ( *(_BYTE *)(a2 + 104) )
                  {
                    if ( *(_DWORD *)(v35 + 4 * v17) == v30 )
                      *(_BYTE *)(a2 + 104) = 0;
                  }
                  ++v37;
                }
              }
              ++v25;
              v24 += 52;
            }
            while ( v25 < *(_DWORD *)(v15 + 4) );
            v13 = v29;
          }
          *(_DWORD *)(v15 + 8) = 0;
        }
        if ( v13 != v17 )
        {
          v27 = *(_DWORD *)(v6 + 4 * v13);
          *(_DWORD *)(v35 + 4 * v13) = *(_DWORD *)(v35 + 4 * v17);
          *(_DWORD *)(v35 + 4 * v17) = v27;
        }
        v14 = v31;
        v6 = v35;
        ++v13;
        v29 = v13;
      }
      while ( (unsigned int)v13 < *(_DWORD *)(v31 + 24) );
      result = v37;
    }
  }
  return result;
}

//----- (1003EE05) --------------------------------------------------------
int __thiscall sub_1003EE05(int this)
{
  __int64 v1; // qax@1
  int v2; // esi@1
  int v3; // edi@2
  int v4; // ecx@3
  int v5; // ebx@4
  unsigned int v6; // esi@4
  int v7; // eax@5
  int v9; // [sp+4h] [bp-8h]@1

  v2 = this;
  v1 = 0i64;
  v9 = this;
  if ( *(_DWORD *)(this + 24) )
  {
    v3 = 0;
    do
    {
      v4 = v3 + *(_DWORD *)(v2 + 72);
      *(_DWORD *)(v4 + 8) = v1;
      *(_DWORD *)(v4 + 28) = v1;
      if ( *(_DWORD *)(v4 + 4) > (_DWORD)v1 )
      {
        v5 = v1;
        v6 = v1;
        do
        {
          v7 = v5 + *(_DWORD *)(v4 + 32);
          v5 += 36;
          *(_DWORD *)v7 = 0;
          *(_DWORD *)(v7 + 28) = 0;
          ++v6;
        }
        while ( v6 < *(_DWORD *)(v4 + 4) );
        v2 = v9;
        LODWORD(v1) = 0;
      }
      v1 += 4294967296i64;
      v3 += 40;
    }
    while ( HIDWORD(v1) < *(_DWORD *)(v2 + 24) );
  }
  return v1;
}

//----- (1003EE5C) --------------------------------------------------------
DWORD __usercall sub_1003EE5C<eax>(int a1<esi>)
{
  DWORD result; // eax@5
  char v2; // [sp+0h] [bp-124h]@20
  struct _OSVERSIONINFOW VersionInformation; // [sp+Ch] [bp-118h]@1
  unsigned int v4; // [sp+120h] [bp-4h]@1
  int v5; // [sp+124h] [bp+0h]@1

  v4 = (unsigned int)&v5 ^ __security_cookie;
  VersionInformation.dwOSVersionInfoSize = 276;
  if ( !GetVersionExW(&VersionInformation) )
  {
LABEL_20:
    sub_100300C4((int)&v2);
    sub_100355BB((int)&v2, (int)&unk_1006BB80);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1003EF44);
  }
  if ( VersionInformation.dwMajorVersion != 5 )
  {
    if ( VersionInformation.dwMajorVersion != 6 )
      goto LABEL_24;
    result = VersionInformation.dwMinorVersion;
    if ( !VersionInformation.dwMinorVersion )
    {
      dword_100758B4 = 3;
      return result;
    }
    if ( VersionInformation.dwMinorVersion != 1 )
LABEL_24:
      dword_100758B4 = 6;
    else
      dword_100758B4 = 4;
LABEL_17:
    result = sub_1003B4C5();
    if ( dword_100758B4 >= 6 )
      result = sub_1004CD16(a1);
    return result;
  }
  if ( !VersionInformation.dwMinorVersion )
  {
    dword_100758B4 = 0;
    goto LABEL_20;
  }
  if ( VersionInformation.dwMinorVersion == 1 )
  {
    result = 1;
    dword_100758B4 = 1;
  }
  else
  {
    result = VersionInformation.dwMinorVersion - 2;
    if ( VersionInformation.dwMinorVersion == 2 )
    {
      dword_100758B4 = 2;
      return result;
    }
    result = dword_100758B4;
  }
  if ( (signed int)result >= 4 )
    goto LABEL_17;
  return result;
}
// 1003EE5C: could not find valid save-restore pair for esi
// 10073200: using guessed type int __security_cookie;
// 100758B4: using guessed type int dword_100758B4;

//----- (1003EF44) --------------------------------------------------------
void __cdecl sub_1003EF44(int a1, unsigned int a2)
{
  int v2; // edx@1
  unsigned int v3; // edi@1
  int v4; // esi@1
  double v5; // st6@1
  int v6; // ecx@2
  int v7; // esi@4
  double v8; // st5@4
  int v9; // eax@5
  int v10; // edx@5
  int v11; // esi@6
  int v12; // eax@8
  int v13; // ecx@12
  int v14; // ecx@16
  unsigned int v15; // esi@16
  double v16; // st4@17
  double v17; // qt0@18
  double v18; // st4@18
  double v19; // qt1@18
  double v20; // qt2@19
  double v21; // st4@19
  double v22; // st6@19
  double v23; // st4@20
  double v24; // st5@20
  double v25; // qtt@20
  double v26; // qt0@21
  double v27; // st4@24
  double v28; // st5@24
  double v29; // qt1@24
  int v30; // eax@25
  int v31; // eax@28
  int v32; // esi@28
  int v33; // edx@29
  int v34; // eax@31
  double v35; // qt0@32
  int v36; // eax@33
  double v37; // qt1@33
  double v38; // st4@33
  double v39; // qt2@33
  int v40; // ecx@40
  int v41; // [sp+Ch] [bp-10h]@1
  int v42; // [sp+14h] [bp-8h]@4
  int v43; // [sp+14h] [bp-8h]@28
  int v44; // [sp+18h] [bp-4h]@1
  int v45; // [sp+18h] [bp-4h]@5
  int v46; // [sp+28h] [bp+Ch]@5
  int v47; // [sp+28h] [bp+Ch]@28

  v5 = 0.0;
  v2 = 0;
  v3 = a2;
  v4 = 0;
  v41 = 0;
  v44 = 0;
  if ( a2 )
  {
    do
    {
      *(_DWORD *)(*(_DWORD *)(a1 + 4 * v4) + 4) = sub_1004D276(0.0);
      v6 = *(_DWORD *)(a1 + 4 * v44);
      v4 = v44 + 1;
      v44 = v4;
      *(double *)(v6 + 8) = *(double *)(v6 + 8) - (double)*(unsigned int *)(v6 + 4);
    }
    while ( v4 < a2 );
    v2 = 0;
  }
  v8 = 0.0000001;
  v7 = v2;
  v42 = v2;
  if ( a2 )
  {
    do
    {
      v9 = v7 + 1;
      v46 = v7;
      v45 = v7 + 1;
      v10 = v7 + 1;
      if ( v7 + 1 < v3 )
      {
        v11 = 4 * v7;
        do
        {
          if ( *(double *)(*(_DWORD *)(v11 + a1) + 8) + 0.0000001 >= *(double *)(*(_DWORD *)(a1 + 4 * v10) + 8) )
          {
            v12 = v46;
          }
          else
          {
            v12 = v10;
            v46 = v10;
            v11 = 4 * v10;
          }
          ++v10;
        }
        while ( v10 < v3 );
        if ( v42 != v12 )
        {
          v13 = *(_DWORD *)(a1 + 4 * v42);
          *(_DWORD *)(a1 + 4 * v42) = *(_DWORD *)(a1 + 4 * v12);
          *(_DWORD *)(a1 + 4 * v46) = v13;
        }
        v9 = v45;
      }
      v7 = v9;
      v42 = v9;
    }
    while ( v9 < v3 );
    v2 = 0;
  }
  v15 = v2;
  v14 = v3 - 1;
  if ( v3 )
  {
    v16 = 1.0;
    while ( 1 )
    {
      v20 = v16;
      v21 = v5;
      v22 = v20;
      while ( v21 > v8 )
      {
        v25 = v21;
        v23 = v8;
        v24 = v25;
        if ( v23 < *(double *)(*(_DWORD *)(a1 + 4 * v14) + 8) )
        {
          while ( 1 )
          {
            v36 = *(_DWORD *)(a1 + 4 * v14);
            v37 = v23;
            v38 = v24;
            v8 = v37;
            --v14;
            v39 = v38 - *(double *)(v36 + 8);
            *(double *)(v36 + 8) = 0.0;
            v21 = v39;
            if ( v39 <= v37 )
              break;
            v35 = v21;
            v23 = v8;
            v24 = v35;
          }
        }
        else
        {
          --v14;
          v26 = v23;
          v21 = v24;
          v8 = v26;
        }
      }
      if ( v15 > v14 )
        break;
      v29 = v21;
      v27 = v8;
      v28 = v29;
      if ( v27 < *(double *)(*(_DWORD *)(a1 + 4 * v15) + 8) )
      {
        v30 = *(_DWORD *)(a1 + 4 * v15);
        v28 = v28 + v22 - *(double *)(v30 + 8);
        *(double *)(v30 + 8) = 0.0;
        ++*(_DWORD *)(*(_DWORD *)(a1 + 4 * v15) + 4);
      }
      ++v15;
      if ( v15 >= v3 )
        break;
      v17 = v27;
      v18 = v28;
      v8 = v17;
      v19 = v18;
      v16 = v22;
      v5 = v19;
    }
  }
  if ( v3 )
  {
    do
    {
      v31 = v2 + 1;
      v47 = v2;
      v43 = v2 + 1;
      v32 = v2 + 1;
      if ( v2 + 1 < v3 )
      {
        v33 = 4 * v2;
        do
        {
          if ( **(_DWORD **)(a1 + 4 * v32) >= **(_DWORD **)(v33 + a1) )
          {
            v34 = v47;
          }
          else
          {
            v34 = v32;
            v47 = v32;
            v33 = 4 * v32;
          }
          ++v32;
        }
        while ( v32 < v3 );
        if ( v41 != v34 )
        {
          v40 = *(_DWORD *)(a1 + 4 * v41);
          *(_DWORD *)(a1 + 4 * v41) = *(_DWORD *)(a1 + 4 * v34);
          *(_DWORD *)(a1 + 4 * v47) = v40;
        }
        v31 = v43;
      }
      v2 = v31;
      v41 = v31;
    }
    while ( v31 < v3 );
  }
}

//----- (1003F103) --------------------------------------------------------
char __thiscall sub_1003F103(void *this)
{
  int v2; // edx@2

  _ESI = (int)((char *)this + 4);
  while ( 1 )
  {
    v2 = *(_DWORD *)_ESI;
    if ( !*(_DWORD *)_ESI )
      break;
    _ECX = v2 + 1;
    __asm { lock cmpxchg [esi], ecx }
    if ( v2 == v2 )
      return 1;
  }
  return 0;
}

//----- (1003F122) --------------------------------------------------------
int __thiscall sub_1003F122(void *this, int a2)
{
  int result; // eax@1
  unsigned int v3; // ecx@1
  int v4; // ebx@1
  void *v5; // edi@1
  signed int v6; // edx@2
  int v7; // esi@2
  int v8; // edx@4
  int v9; // ecx@4
  int v10; // edx@5
  int v11; // ebx@5
  int v12; // eax@5
  int v13; // edx@6
  int v14; // ecx@9
  int v15; // eax@9
  int v16; // ecx@17
  unsigned int v17; // edx@19
  int v18; // ecx@20
  int v19; // eax@21
  int v20; // esi@21
  int v21; // esi@22
  int v22; // eax@27
  char v23; // zf@32
  signed int v24; // [sp-4h] [bp-30h]@30
  unsigned int v25; // [sp+Ch] [bp-20h]@21
  int v26; // [sp+10h] [bp-1Ch]@2
  unsigned int v27; // [sp+10h] [bp-1Ch]@19
  unsigned int v28; // [sp+14h] [bp-18h]@1
  int v29; // [sp+14h] [bp-18h]@20
  int v30; // [sp+18h] [bp-14h]@4
  int v31; // [sp+18h] [bp-14h]@17
  signed int v32; // [sp+1Ch] [bp-10h]@1
  signed int v33; // [sp+20h] [bp-Ch]@2
  int v34; // [sp+20h] [bp-Ch]@20
  int v35; // [sp+24h] [bp-8h]@4
  int v36; // [sp+24h] [bp-8h]@18
  int v37; // [sp+28h] [bp-4h]@3
  unsigned int v38; // [sp+28h] [bp-4h]@25

  v5 = this;
  v4 = 0;
  v3 = 0;
  result = 48;
  v28 = 0;
  v32 = 48;
  if ( *((_DWORD *)v5 + 6) )
  {
    v7 = 0;
    v26 = 0;
    v6 = 48;
    v33 = 48;
    do
    {
      result = v7 + *((_DWORD *)v5 + 18);
      v37 = v4;
      if ( *(_DWORD *)(result + 4) > (unsigned int)v4 )
      {
        v8 = v4;
        v35 = v4;
        v30 = v4;
        v9 = v4;
        do
        {
          v11 = v8 + *(_DWORD *)(result + 32);
          v12 = *(_DWORD *)(v11 + 20);
          *(_DWORD *)(v11 + 20) = 0;
          *(_DWORD *)(v11 + 24) = v12;
          v10 = *((_DWORD *)v5 + 25);
          if ( v10 )
            v13 = *(_DWORD *)(v10 + 24);
          else
            v13 = 0;
          if ( v13 )
          {
            do
            {
              v14 = v35 + *(_DWORD *)(v33 + *(_DWORD *)(v13 + 16));
              *(_DWORD *)(v14 + 32) = *(_DWORD *)(v14 + 28);
              v15 = *(_DWORD *)(v14 + 24);
              *(_DWORD *)(v14 + 28) = v15;
              *(_DWORD *)(v11 + 20) += v15;
              if ( v13 == *((_DWORD *)v5 + 25) )
                v13 = 0;
              else
                v13 = *(_DWORD *)(v13 + 24);
            }
            while ( v13 );
            v7 = v26;
            v9 = v37;
          }
          v35 += 52;
          ++v9;
          result = v7 + *((_DWORD *)v5 + 18);
          v8 = v30 + 36;
          v37 = v9;
          v30 += 36;
        }
        while ( (unsigned int)v9 < *(_DWORD *)(result + 4) );
        v3 = v28;
        v6 = v33;
        v4 = 0;
      }
      ++v3;
      v7 += 40;
      v6 += 52;
      v28 = v3;
      v26 = v7;
      v33 = v6;
    }
    while ( v3 < *((_DWORD *)v5 + 6) );
  }
  v16 = v4;
  v31 = v4;
  if ( *((_DWORD *)v5 + 6) <= (unsigned int)v4 )
    return result;
  v36 = v4;
  do
  {
    v17 = 0;
    result = v4 + *((_DWORD *)v5 + 18);
    v27 = 0;
    if ( !*(_DWORD *)(result + 4) )
      goto LABEL_46;
    v34 = 0;
    v18 = 0;
    v29 = 0;
    do
    {
      v19 = *(_DWORD *)(result + 32);
      v25 = *(_DWORD *)(v19 + v18 + 24);
      v20 = *((_DWORD *)v5 + 25);
      if ( v20 )
        v21 = *(_DWORD *)(v20 + 24);
      else
        v21 = 0;
      if ( v21 )
      {
        v38 = *(_DWORD *)(v19 + v18 + 20);
        while ( 1 )
        {
          if ( *(_DWORD *)(v21 + 132) != *(_DWORD *)(v21 + 128)
            || (v22 = v34 + *(_DWORD *)(v32 + *(_DWORD *)(v21 + 16)), !*(_DWORD *)(v22 + 36)) )
            goto LABEL_39;
          if ( v21 == a2 )
          {
            if ( v38 <= *(_DWORD *)(v22 + 28) )
              goto LABEL_37;
            v24 = 1;
          }
          else
          {
            if ( v25 != *(_DWORD *)(v22 + 32) )
            {
              v23 = v38 == *(_DWORD *)(v22 + 28);
LABEL_35:
              if ( !v23 || v25 <= *(_DWORD *)(v22 + 32) )
                goto LABEL_39;
LABEL_37:
              v24 = 0;
              goto LABEL_38;
            }
            v23 = v38 == *(_DWORD *)(v22 + 28);
            if ( v38 <= *(_DWORD *)(v22 + 28) )
              goto LABEL_35;
            v24 = 1;
          }
LABEL_38:
          sub_1004CBC2(v22, v24);
LABEL_39:
          if ( v21 == *((_DWORD *)v5 + 25) )
            v21 = 0;
          else
            v21 = *(_DWORD *)(v21 + 24);
          if ( !v21 )
          {
            v4 = v36;
            v17 = v27;
            v18 = v29;
            break;
          }
        }
      }
      v34 += 52;
      ++v17;
      result = v4 + *((_DWORD *)v5 + 18);
      v18 += 36;
      v27 = v17;
      v29 = v18;
    }
    while ( v17 < *(_DWORD *)(result + 4) );
    v16 = v31;
LABEL_46:
    v32 += 52;
    ++v16;
    v4 += 40;
    v31 = v16;
    v36 = v4;
  }
  while ( (unsigned int)v16 < *((_DWORD *)v5 + 6) );
  return result;
}
// 1004CBC2: using guessed type _DWORD __stdcall sub_1004CBC2(_DWORD, _DWORD);

//----- (1003F2F1) --------------------------------------------------------
int __thiscall sub_1003F2F1(int this, int a2, char a3)
{
  int result; // eax@1
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // edi@2
  int v7; // [sp+1Ch] [bp+Ch]@1

  v4 = this;
  sub_1003DAC1(this);
  sub_100391F0((void *)(a2 + 64), 0, 48);
  sub_1003DF31(v4, 0, a2, a2 + 64);
  *(double *)(a2 + 96) = (double)(unsigned int)sub_1003C109(a2);
  *(_BYTE *)(a2 + 104) = a3;
  result = *(_DWORD *)(v4 + 84);
  v7 = 1;
  *(_DWORD *)result = a2 + 64;
  v5 = *(_DWORD *)(v4 + 100);
  if ( v5 )
    v6 = *(_DWORD *)(v5 + 24);
  else
    v6 = 0;
  if ( v6 )
  {
    result = a2;
    do
    {
      if ( v6 != result )
      {
        sub_100391F0((void *)(v6 + 64), 0, 48);
        sub_1003DF31(v4, v7, v6, v6 + 64);
        *(double *)(v6 + 96) = (double)(unsigned int)sub_1003C109(v6);
        *(_DWORD *)(*(_DWORD *)(v4 + 84) + 4 * v7) = v6 + 64;
        result = a2;
        ++v7;
      }
      if ( v6 == *(_DWORD *)(v4 + 100) )
        v6 = 0;
      else
        v6 = *(_DWORD *)(v6 + 24);
    }
    while ( v6 );
  }
  return result;
}

//----- (1003F3BF) --------------------------------------------------------
int __thiscall sub_1003F3BF(int this, int a2)
{
  unsigned int v2; // eax@1
  int v3; // ecx@1
  char v4; // bl@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // edx@2
  unsigned int v8; // eax@4
  int v9; // esi@5
  int v10; // ecx@6
  unsigned int v12; // [sp+Ch] [bp-8h]@4
  unsigned int v13; // [sp+10h] [bp-4h]@1

  v5 = this;
  v4 = 0;
  v6 = this + 44;
  sub_1002B91D((LPCRITICAL_SECTION)(this + 44));
  sub_1003EA4A(v5 + 96, a2);
  v3 = a2;
  v2 = 0;
  v13 = 0;
  if ( *(_DWORD *)(v5 + 24) > 0u )
  {
    v7 = *(_DWORD *)(a2 + 16) + 4;
    do
    {
      if ( *(_DWORD *)(v7 + 24) > 0u )
      {
        v8 = 0;
        v12 = 0;
        if ( *(_DWORD *)v7 > 0u )
        {
          v9 = 0;
          do
          {
            v10 = *(_DWORD *)(v7 + 44);
            if ( *(_DWORD *)(v9 + v10) == 4 )
            {
              --**(_DWORD **)(v9 + v10 + 20);
              v8 = v12;
            }
            ++v8;
            v9 += 52;
            v12 = v8;
          }
          while ( v8 < *(_DWORD *)v7 );
        }
        v2 = v13;
      }
      ++v2;
      v7 += 52;
      v13 = v2;
    }
    while ( v2 < *(_DWORD *)(v5 + 24) );
    v3 = a2;
    v6 = v5 + 44;
  }
  if ( *(_DWORD *)(v3 + 132) == *(_DWORD *)(v3 + 128) )
    --*(_DWORD *)(v5 + 16);
  --*(_DWORD *)(v5 + 8);
  if ( *(_DWORD *)(v5 + 8) == 1 )
  {
    *(_DWORD *)(v5 + 40) = 0;
    v4 = 1;
  }
  sub_1002BB52((LPCRITICAL_SECTION)v6);
  if ( v4 )
    SetEvent(*(HANDLE *)(v5 + 80));
  return (*(int (**)(void))(*(_DWORD *)a2 + 32))();
}

//----- (1003F478) --------------------------------------------------------
int __userpurge sub_1003F478<eax>(int a1<ebp>, int a2)
{
  int v2; // ebx@1
  struct _RTL_CRITICAL_SECTION *v3; // esi@1
  int v4; // ecx@1
  int v5; // ecx@1

  sub_10035648();
  v2 = v4;
  v3 = (struct _RTL_CRITICAL_SECTION *)(v4 + 44);
  *(_DWORD *)(a1 - 16) = v4 + 44;
  sub_1002B91D((LPCRITICAL_SECTION)(v4 + 44));
  v5 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  if ( !sub_1004C9FB(v5, a1) )
    sub_1003DDDB(v2, v2, *(_DWORD *)(a1 + 8), 0, 1);
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002BB52(v3);
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1003F4C9) --------------------------------------------------------
int __thiscall sub_1003F4C9(int this, int a2, int a3, int a4, int a5, int a6)
{
  int result; // eax@2

  if ( *(_BYTE *)(a3 + 48) )
  {
    result = a6;
    *(_BYTE *)(a3 + 48) = 0;
    --*(_DWORD *)(result + 20);
    --*(_DWORD *)(a2 + 40);
    if ( *(_BYTE *)(a3 + 49) )
    {
      --*(_DWORD *)(a6 + 24);
      --*(_DWORD *)(a2 + 44);
    }
    if ( *(_DWORD *)a5 == 6 )
    {
      result = a4;
      *(_DWORD *)a5 = 0;
      --*(_DWORD *)(result + 28);
      --*(_DWORD *)(this + 32);
    }
    --*(_DWORD *)(a5 + 28);
  }
  else
  {
    *(_BYTE *)(a3 + 48) = 1;
    ++*(_DWORD *)(a6 + 20);
    ++*(_DWORD *)(a2 + 40);
    if ( *(_BYTE *)(a3 + 49) )
    {
      ++*(_DWORD *)(a6 + 24);
      ++*(_DWORD *)(a2 + 44);
    }
    result = a5;
    ++*(_DWORD *)(result + 28);
  }
  return result;
}

//----- (1003F536) --------------------------------------------------------
int __usercall sub_1003F536<eax>(int a1<ebp>, int a2<esi>)
{
  int v2; // eax@2

  sub_10035648();
  if ( !dword_100758B4 )
  {
    *(_DWORD *)(a1 - 16) = &dword_10075F54;
    sub_10030FB0(&dword_10075F54);
    v2 = dword_100758B4;
    *(_DWORD *)(a1 - 4) = 0;
    if ( !v2 )
      sub_1003EE5C(a2);
    dword_10075F54 = 0;
  }
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 100758B4: using guessed type int dword_100758B4;
// 10075F54: using guessed type int dword_10075F54;

//----- (1003F580) --------------------------------------------------------
int __usercall sub_1003F580<eax>(unsigned int a1<eax>, int a2<ecx>, char a3)
{
  return sub_1004D2F0(-(((unsigned int)(&a3 - a1) & 0xF) >= -a1) | (((unsigned int)(&a3 - a1) & 0xF) + a1), a2);
}

//----- (1003F5AC) --------------------------------------------------------
void *__usercall sub_1003F5AC<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int v4; // edx@1
  void *result; // eax@2
  int v6; // [sp-4h] [bp-4h]@1

  if ( sub_1004D387(a1, a2, a3, a4, 3) == 1
    || (result = (void *)sub_1004D387(v4, v6, a3, a4, 3), !result) && dword_100758C8 == 1 )
  {
    sub_1003F609(a3, 252);
    result = sub_1003F609(a3, 255);
  }
  return result;
}
// 100758C8: using guessed type int dword_100758C8;

//----- (1003F5E5) --------------------------------------------------------
wchar_t *__cdecl sub_1003F5E5(int a1)
{
  unsigned int v1; // eax@1

  v1 = 0;
  while ( a1 != dword_100644C8[2 * v1] )
  {
    ++v1;
    if ( v1 >= 0x17 )
      return 0;
  }
  return (wchar_t *)off_100644CC[2 * v1];
}
// 100644C8: using guessed type int dword_100644C8[];

//----- (1003F609) --------------------------------------------------------
void *__usercall sub_1003F609<eax>(int a1<ebx>, int a2)
{
  void *result; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // edx@2
  int v6; // edx@3
  int v7; // edx@7
  int v8; // ecx@7
  int v9; // edx@9
  int v10; // ecx@9
  int v11; // eax@9
  int v12; // ST10_4@9
  int v13; // eax@10
  int v14; // edx@11
  int v15; // ecx@11
  void *v16; // esi@14
  unsigned int v17; // ecx@16
  int v18; // eax@19
  int v19; // [sp-8h] [bp-20Ch]@2
  int v20; // [sp-8h] [bp-20Ch]@3
  int v21; // [sp-4h] [bp-208h]@1
  DWORD NumberOfBytesWritten; // [sp+8h] [bp-1FCh]@19
  char Buffer[499]; // [sp+Ch] [bp-1F8h]@17
  char v24; // [sp+1FFh] [bp-5h]@19
  unsigned int v25; // [sp+200h] [bp-4h]@1
  int v26; // [sp+204h] [bp+0h]@1

  v25 = (unsigned int)&v26 ^ __security_cookie;
  result = sub_1003F5E5(a2);
  v4 = (int)result;
  if ( result )
  {
    if ( sub_1004D387(v3, v21, a1, (int)result, 3) != 1
      && ((result = (void *)sub_1004D387(v5, v19, a1, v4, 3)) != 0 || dword_100758C8 != 1) )
    {
      if ( a2 != 252 )
      {
        if ( sub_100490D0(v6, v20, a1, v4, (int)&unk_100758D0, 788, (int)L"Runtime Error!\n\nProgram: ")
          || (word_10075B0A = 0, !GetModuleFileNameW(0, &Filename, 0x104u))
          && sub_100490D0(v7, v8, 0, v4, (int)&Filename, 763, (int)L"<program name unknown>")
          || (v11 = sub_10039899((int)&Filename), v10 = v12, (unsigned int)(v11 + 1) > 0x3C)
          && (v13 = sub_10039899((int)&Filename),
              sub_1004498F(
                0,
                v4,
                (int)((char *)&unk_1007588C + 2 * v13),
                763 - ((signed int)((_UNKNOWN *)((char *)&unk_1007588C + 2 * v13) - (_UNKNOWN *)&Filename) >> 1),
                (int)L"...",
                3))
          || sub_1004D31B(v9, v10, 0, (int)&unk_100758D0, 788, (int)L"\n\n")
          || sub_1004D31B(v14, v15, 0, (int)&unk_100758D0, 788, v4) )
        {
          sub_1003A161(0, v4);
          __asm { int     3               ; Trap to Debugger }
          JUMPOUT(*(int *)sub_1003F7C4);
        }
        result = (void *)sub_1004D3C7((const WCHAR *)&unk_100758D0, (int)L"Microsoft Visual C++ Runtime Library", 73744);
      }
    }
    else
    {
      result = GetStdHandle(0xFFFFFFF4u);
      v16 = result;
      if ( result )
      {
        if ( result != (void *)-1 )
        {
          v17 = 0;
          do
          {
            Buffer[v17] = *(_BYTE *)(v4 + 2 * v17);
            if ( !*(_WORD *)(v4 + 2 * v17) )
              break;
            ++v17;
          }
          while ( v17 < 0x1F4 );
          v24 = 0;
          v18 = sub_10035530((int)Buffer);
          result = (void *)WriteFile(v16, Buffer, v18, &NumberOfBytesWritten, 0);
        }
      }
    }
  }
  return result;
}
// 100645DC: using guessed type wchar_t aRuntimeErrorPr[26];
// 10064610: using guessed type wchar_t aProgramNameUnk[23];
// 10064640: using guessed type wchar_t a___[4];
// 10064648: using guessed type wchar_t asc_10064648[3];
// 10064650: using guessed type wchar_t aMicrosoftVisua[37];
// 10073200: using guessed type int __security_cookie;
// 100758C8: using guessed type int dword_100758C8;
// 10075B0A: using guessed type __int16 word_10075B0A;
// 1003F609: using guessed type char Buffer[499];

//----- (1003F7C4) --------------------------------------------------------
signed int __cdecl sub_1003F7C4(int a1, int a2, int a3, LCTYPE a4, LPVOID *a5)
{
  int v5; // eax@2
  int v6; // ecx@2
  void *v7; // ebx@2
  int v8; // eax@4
  int v9; // ecx@4
  CHAR *v10; // eax@5
  int v11; // edx@7
  int v13; // eax@17
  int v14; // ecx@17
  int v15; // ebx@17
  WCHAR *v16; // eax@18
  signed int v17; // [sp+10h] [bp-90h]@2
  int cbMultiByte; // [sp+18h] [bp-88h]@2
  char Mem; // [sp+1Ch] [bp-84h]@2
  unsigned int v20; // [sp+9Ch] [bp-4h]@1
  int v21; // [sp+A0h] [bp+0h]@1

  v20 = (unsigned int)&v21 ^ __security_cookie;
  if ( a2 == 1 )
  {
    v7 = &Mem;
    v17 = 0;
    v5 = sub_1004D681((int)&Mem, (int)a5, a1, a3, a4, &Mem, 128);
    cbMultiByte = v5;
    if ( !v5 )
    {
      if ( GetLastError() != 122
        || (v8 = sub_1004D681((int)&Mem, (int)a5, a1, a3, a4, 0, 0), cbMultiByte = v8, !v8)
        || (v10 = (CHAR *)sub_100374E6(v9, (int)&Mem, v8, 1u), v7 = v10, !v10) )
        return -1;
      v17 = 1;
      v5 = sub_1004D681((int)v10, (int)a5, a1, a3, a4, v10, cbMultiByte);
      cbMultiByte = v5;
      if ( !v5 )
        goto LABEL_9;
    }
    v11 = (int)sub_100374E6(v6, (int)v7, v5, 1u);
    *a5 = (LPVOID)v11;
    if ( !v11 )
    {
      if ( !v17 )
        return -1;
LABEL_9:
      sub_100309C2((int)v7, v7);
      return -1;
    }
    if ( sub_100305D1((int)v7, (int)a5, v11, cbMultiByte, (int)v7, cbMultiByte - 1) )
    {
      sub_1003A161((int)v7, (int)a5);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1003F99B);
    }
    if ( v17 )
      sub_100309C2((int)v7, v7);
  }
  else
  {
    if ( a2 == 2 )
    {
      *a5 = 0;
      v13 = sub_10039C8E(a3, a4, 0, 0);
      v15 = v13;
      if ( !v13 || (v16 = (WCHAR *)sub_100374E6(v14, v13, v13, 2u), *a5 = v16, !v16) || !sub_10039C8E(a3, a4, v16, v15) )
      {
        sub_100309C2(v15, *a5);
        *a5 = 0;
        return -1;
      }
    }
    else
    {
      if ( a2 || (cbMultiByte = 0, !sub_10039C8E(a3, a4 | 0x20000000, (WCHAR *)&cbMultiByte, 2)) )
        return -1;
      *(_BYTE *)a5 = cbMultiByte;
    }
  }
  return 0;
}
// 10073200: using guessed type int __security_cookie;

//----- (1003F99B) --------------------------------------------------------
void *__cdecl sub_1003F99B(void *a1)
{
  void *result; // eax@1

  result = a1;
  dword_10075EF8 = a1;
  return result;
}

//----- (1003F9A8) --------------------------------------------------------
void __usercall sub_1003F9A8(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  int v5; // eax@1
  LPVOID v6; // edx@2
  void *v7; // ecx@2

  sub_10036A23(a1, a2, a3, a4, 14);
  v5 = *(_DWORD *)(a5 + 4);
  if ( v5 )
  {
    v7 = dword_10075F00;
    v6 = &unk_10075EFC;
    while ( dword_10075F00 )
    {
      if ( *(_DWORD *)dword_10075F00 == v5 )
      {
        *((_DWORD *)v6 + 1) = *((_DWORD *)dword_10075F00 + 1);
        sub_100309C2(a3, v7);
        break;
      }
      v6 = dword_10075F00;
    }
    sub_100309C2(a3, *(LPVOID *)(a5 + 4));
    *(_DWORD *)(a5 + 4) = 0;
  }
  sub_10036B87(14);
}

//----- (1003FA19) --------------------------------------------------------
int __cdecl sub_1003FA19(int a1)
{
  int ebp0; // ebp@0

  *(_DWORD *)(a1 + 116) = 1;
  sub_1002E4F8(a1, -999);
  return sub_1002E597(ebp0, 0);
}

//----- (1003FA40) --------------------------------------------------------
int __cdecl sub_1003FA40(int a1)
{
  return (**(int (__stdcall ***)(_DWORD))a1)(1);
}

//----- (1003FA4E) --------------------------------------------------------
void __thiscall sub_1003FA4E(int this, int a2)
{
  int v2; // edx@5
  int v3; // eax@8
  int v4; // edx@8
  void *v5; // ecx@8
  int v6; // eax@11
  int v7; // ebx@14
  int v8; // edi@14
  void *v9; // edx@14
  _DWORD *v10; // [sp+0h] [bp+0h]@4
  void *v11; // [sp+8h] [bp+8h]@14

  if ( *(int (**)())(this + 12) == sub_1003FB0E )
  {
    v10 = &v10;
    if ( a2 )
      v2 = a2 - 4;
    else
      v2 = 0;
    if ( !*(_DWORD *)(v2 + 52) )
    {
      v3 = *(_DWORD *)(this + 8);
      v4 = v2 + 4;
      v5 = *(void **)(v3 + 12);
      *(_DWORD *)(v4 + 48) = v3;
      *(_DWORD *)(v4 + 52) = v3;
      sub_1002E4A1(v5, v4, 0);
    }
  }
  else
  {
    v10 = &v10;
    if ( a2 )
      v6 = a2 - 4;
    else
      v6 = 0;
    if ( !*(_DWORD *)(v6 + 52) )
    {
      v8 = *(_DWORD *)(this + 8);
      v7 = v6 + 4;
      v9 = *(void **)(v8 + 12);
      *(_DWORD *)(v6 + 52) = v8;
      *(_DWORD *)(v6 + 56) = v8;
      v11 = v9;
      if ( *(_BYTE *)(this + 17) )
      {
        *(_BYTE *)(v6 + 81) = 0;
        sub_1002E4D1(v8 + 28, v6 + 96);
      }
      else
      {
        sub_1002B98A((void *)(v8 + 32));
        ++*(_DWORD *)(v8 + 48);
        sub_1002BB74((void *)(v8 + 32));
        sub_1002E4A1(v11, v7, 1);
      }
    }
  }
}
// 1003FB0E: using guessed type int sub_1003FB0E();

//----- (1003FB01) --------------------------------------------------------
char __thiscall sub_1003FB01(int this, char a2)
{
  char result; // al@1

  result = a2;
  *(_BYTE *)(this + 17) = a2;
  return result;
}

//----- (1003FB0E) --------------------------------------------------------
#error "1003FC4A: call analysis failed (funcsize=85)"

//----- (1003FD7A) --------------------------------------------------------
void (__usercall *__usercall sub_1003FD7A<eax>(int a1<ebp>, int a2<edi>))(int<ebp>)
{
  int v2; // eax@1

  v2 = *(_DWORD *)(a1 - 172);
  if ( *(_DWORD *)(v2 + 116) > 0 )
  {
    if ( !*(_DWORD *)(v2 + 120) )
      sub_1002D593(*(_DWORD *)(a1 - 168), 0, a2);
  }
  return sub_1003FD9D;
}

//----- (1003FD9D) --------------------------------------------------------
void __usercall sub_1003FD9D(int a1<ebp>)
{
  int v1; // edi@1

  v1 = *(_DWORD *)(a1 - 168);
  *(_DWORD *)(a1 - 4) = 1;
  sub_1002DB66(0, a1, v1, a1 - 164, 0);
  *(_BYTE *)(a1 - 4) = 0;
  sub_1002CFB4(a1);
  *(_DWORD *)(a1 - 4) = -1;
  JUMPOUT(*(unsigned int *)loc_1003FE24);
}
// 1003FE24: using guessed type int loc_1003FE24();

//----- (1003FDD3) --------------------------------------------------------
void (__usercall *__usercall sub_1003FDD3<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>))(int<ebp>)
{
  sub_1002D9DF(*(_DWORD *)(a2 - 168), a1, a2);
  sub_1002D593(*(_DWORD *)(a2 - 168), a1, a3);
  return sub_1003FD9D;
}

//----- (1003FDEF) --------------------------------------------------------
int (__usercall *__usercall sub_1003FDEF<eax>(int a1<ebp>, int a2<edi>))<eax>(int<ebp>)
{
  int v2; // eax@1

  v2 = *(_DWORD *)(a1 - 172);
  if ( *(_DWORD *)(v2 + 116) > 0 )
  {
    if ( !*(_DWORD *)(v2 + 120) )
      sub_1002D593(*(_DWORD *)(a1 - 168), 0, a2);
  }
  return sub_1003FE12;
}

//----- (1003FE12) --------------------------------------------------------
int __usercall sub_1003FE12<eax>(int a1<ebp>)
{
  int v1; // edi@1
  int v2; // esi@1
  int v3; // eax@2
  void *v4; // ecx@5
  void *v5; // esi@7
  int v7; // esi@9
  int v8; // eax@9

  *(_DWORD *)(a1 - 4) = -1;
  v1 = *(_DWORD *)(a1 - 168);
  v2 = *(_DWORD *)(a1 - 172);
  *(_DWORD *)(a1 - 172) = v2 + 4;
  sub_1002EF6D(v2 + 4, 0);
  if ( *(_BYTE *)(*(_DWORD *)(a1 - 176) + 17) )
  {
    sub_1002EF22(*(_DWORD *)(a1 - 184), v2 + 96);
  }
  else
  {
    v3 = *(_DWORD *)(a1 - 184);
    *(_DWORD *)(a1 - 168) = v3 + 4;
    sub_1002B98A((void *)(v3 + 4));
    if ( *(_BYTE *)(v2 + 81) )
      sub_1002EF49(*(void **)(a1 - 196), *(_DWORD *)(a1 - 172));
    else
      sub_1002B26C(*(void **)(a1 - 184), v2 + 96);
    v4 = *(void **)(a1 - 168);
    --*(_DWORD *)(v1 + 48);
    sub_1002BB74(v4);
  }
  v5 = *(void **)(a1 - 192);
  if ( v5 )
  {
    sub_1002B29A(a1, *(_DWORD *)(a1 - 192));
    sub_1000AA50(v5);
  }
  v7 = *(_DWORD *)(a1 - 172);
  *(_DWORD *)(v7 + 104) = -1;
  *(_DWORD *)(v7 + 108) = -1;
  *(_DWORD *)(v7 + 112) = 0;
  *(_DWORD *)(v7 + 116) = 0;
  sub_1002E6F8((void *)v7);
  v8 = *(_DWORD *)(a1 - 176);
  *(_DWORD *)(v7 + 48) = 0;
  *(_DWORD *)(v7 + 52) = 0;
  *(_DWORD *)(v8 + 8) = 0;
  sub_1002D951((void *)v1, v8);
  return sub_10035639();
}
// 10035639: using guessed type int sub_10035639(void);

//----- (1003FF15) --------------------------------------------------------
int __thiscall sub_1003FF15(int this, int a2)
{
  int result; // eax@1
  int v3; // edx@1
  int v4; // ecx@1

  _ESI = this + 24;
  v3 = *(_DWORD *)(this + 24);
  v4 = v3;
  for ( result = v3; ; v4 = result )
  {
    _ECX = a2 | v4 & 0xFFFFFFFC;
    __asm { lock cmpxchg [esi], ecx }
    if ( result == v3 )
      break;
    v3 = result;
  }
  return result;
}

//----- (1003FF3B) --------------------------------------------------------
signed int __thiscall sub_1003FF3B(int this, int a2)
{
  signed int result; // eax@1
  int v3; // ecx@1

  result = *(_DWORD *)(this + 8);
  v3 = 0;
  if ( result & 1 )
  {
    v3 = result & 0xFFFFFFFE;
    if ( result & 0xFFFFFFFE )
      result = *(_DWORD *)((result & 0xFFFFFFFE) + 0x10);
    else
      result = 2;
  }
  if ( a2 )
    *(_DWORD *)a2 = v3;
  return result;
}

//----- (1003FF63) --------------------------------------------------------
char __thiscall sub_1003FF63(int this)
{
  int v1; // edx@1
  char result; // al@4

  _ESI = this + 24;
  v1 = *(_DWORD *)(this + 24);
  if ( v1 & 3 )
  {
LABEL_4:
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      _ECX = v1 | 1;
      __asm { lock cmpxchg [esi], ecx }
      if ( v1 == v1 )
        break;
      if ( v1 & 3 )
        goto LABEL_4;
    }
    result = 1;
  }
  return result;
}

//----- (1003FF8B) --------------------------------------------------------
int __thiscall sub_1003FF8B(int this)
{
  int v1; // edx@1
  int result; // eax@2

  _ESI = this + 24;
  v1 = *(_DWORD *)(this + 24);
  if ( !(v1 & 0xFFFFFFFC) )
  {
    do
    {
      _ECX = v1 & 3 | 0xC;
      result = v1;
      __asm { lock cmpxchg [esi], ecx }
    }
    while ( v1 != v1 && !(v1 & 0xFFFFFFFC) );
  }
  return result;
}

//----- (1003FFB6) --------------------------------------------------------
int __usercall sub_1003FFB6<eax>(int a1<ebx>, int a2<ebp>)
{
  int v2; // edx@1
  int v4; // ecx@1
  int v6; // eax@6
  int v7; // esi@6
  int i; // eax@8
  int v9; // edx@8
  int v10; // ecx@8

  sub_10035648();
  _EDI = v4 + 24;
  v2 = *(_DWORD *)(v4 + 24);
  while ( !(v2 & 0xFFFFFFFC) || (v2 & 0xFFFFFFFC) == 12 )
  {
    _ECX = v2 & 3 | 8;
    __asm { lock cmpxchg [edi], ecx }
    if ( v2 == v2 )
    {
      v6 = sub_1002ADB1(v2, _ECX, a1, _EDI, 8);
      *(_DWORD *)(a2 - 16) = v6;
      v7 = 0;
      *(_DWORD *)(a2 - 4) = 0;
      if ( v6 )
        v7 = sub_1000A4E0(v6);
      v9 = *(_DWORD *)_EDI;
      v10 = *(_DWORD *)_EDI;
      for ( i = *(_DWORD *)_EDI; ; LOBYTE(v10) = i )
      {
        _ECX = v7 | v10 & 3;
        __asm { lock cmpxchg [edi], ecx }
        if ( i == v9 )
          break;
        v9 = i;
      }
      return sub_10035616(4);
    }
  }
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (10040025) --------------------------------------------------------
int __usercall sub_10040025<eax>(int a1<ebx>, int a2<ebp>)
{
  int v2; // ecx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // ecx@3
  const void *v6; // ST04_4@4
  int v8; // [sp-Ch] [bp-Ch]@4
  int v9; // [sp-8h] [bp-8h]@4
  signed int v10; // [sp-4h] [bp-4h]@1

  v10 = 12;
  sub_10035648();
  v3 = v2;
  v4 = *(_DWORD *)(v2 + 24) & 0xFFFFFFFC;
  if ( *(_DWORD *)(v2 + 24) & 0xFFFFFFFC )
  {
    if ( v4 != 12 )
    {
      sub_1002FD39(a2 - 24, *(_DWORD *)(v2 + 24) & 0xFFFFFFFC);
      *(_DWORD *)(a2 - 4) = 0;
      sub_1002FDDA(v4);
      sub_1002A4AA((LPVOID)v4);
      *(_DWORD *)(v3 + 24) = 0;
      if ( !sub_1003639F(a1, v3) )
      {
        v9 = v5;
        v8 = v5;
        sub_1002FD39((int)&v8, a2 - 24);
        sub_10009E30(v6, v3, v8);
      }
      *(_DWORD *)(a2 - 4) = -1;
      sub_1002FDDA(a2 - 24);
    }
  }
  return sub_10035616(v10);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1002FD39: using guessed type int __cdecl sub_1002FD39(int, int);
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (10040095) --------------------------------------------------------
char __thiscall sub_10040095(int this)
{
  int v1; // edi@1
  signed int v2; // esi@1
  int v3; // esi@1
  char v4; // al@3

  v3 = this;
  v1 = sub_1002F423(this);
  v2 = sub_1003FF3B(v3, 0);
  while ( 1 )
  {
    if ( !v1 )
      return 0;
    if ( v2 )
      break;
    v4 = (*(_DWORD *)(v1 + 4) >> 28) & 1;
    if ( v4 && *(_BYTE *)(v1 + 24) & 3 || !v4 && sub_1002D907(v1) )
      return 1;
    v2 = sub_1003FF3B(v1, 0);
    v1 = sub_1002F423(v1);
  }
  if ( v2 == 2 )
    return 0;
  return *(_DWORD *)(v2 + 8) != 0;
}

//----- (10040102) --------------------------------------------------------
int __fastcall sub_10040102(int a1, int a2, int a3)
{
  int v3; // eax@1
  signed int v4; // edi@1
  int v5; // esi@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // ecx@2
  void *v10; // ST00_4@6

  v5 = a1;
  v4 = 63;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 20) = a3;
  *(_DWORD *)(a1 + 8) = 63;
  *(_DWORD *)(a1 + 12) = sub_1002965B(a2, a1, 0, 63, 256);
  v3 = sub_1002965B(v6, v7, 0, 63, 512);
  if ( v3 )
  {
    v8 = v3;
    do
    {
      --v4;
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      v8 += 8;
    }
    while ( v4 >= 0 );
  }
  else
  {
    v3 = 0;
  }
  v10 = *(void **)(v5 + 12);
  *(_DWORD *)(v5 + 16) = v3;
  sub_100391F0(v10, 0, 256);
  return v5;
}

//----- (10040169) --------------------------------------------------------
int __fastcall sub_10040169(int a1, int a2, int a3)
{
  int v3; // eax@1
  signed int v4; // edi@1
  int v5; // esi@1
  int v6; // edx@1
  int v7; // ecx@1
  int v8; // ecx@2

  v5 = a1;
  *(_DWORD *)(a1 + 16) = a3;
  v4 = 63;
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 8) = 63;
  *(_DWORD *)(a1 + 28) = sub_1002965B(a2, a1, 0, 63, 256);
  v3 = sub_1002965B(v6, v7, 0, 63, 512);
  if ( v3 )
  {
    v8 = v3;
    do
    {
      --v4;
      *(_DWORD *)v8 = 0;
      *(_DWORD *)(v8 + 4) = 0;
      v8 += 8;
    }
    while ( v4 >= 0 );
  }
  else
  {
    v3 = 0;
  }
  *(_DWORD *)(v5 + 32) = v3;
  return v5;
}

//----- (100401C8) --------------------------------------------------------
int __usercall sub_100401C8<eax>(int a1<ebp>)
{
  int v2; // ecx@1
  int v3; // edi@1
  int v4; // esi@1
  int v5; // edx@1
  int v6; // edx@1

  sub_10035648();
  v3 = v2;
  *(_DWORD *)(a1 - 16) = v2;
  v4 = v2 + 112;
  sub_10040102(v2, v5, v2 + 112);
  *(_DWORD *)(v3 + 56) = 0;
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)(v3 + 72) = 0;
  sub_10040169(v3 + 76, v6, v4);
  *(_DWORD *)v4 = 0;
  *(_BYTE *)(a1 - 4) = 1;
  *(_DWORD *)(v3 + 44) = 0;
  *(_DWORD *)(v3 + 52) = v3;
  *(_DWORD *)(v3 + 64) = sub_10032A67();
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (10040214) --------------------------------------------------------
char __thiscall sub_10040214(void *this)
{
  LPVOID v1; // eax@1
  void *v2; // edi@1
  int v3; // esi@2
  char v4; // bl@5

  v2 = this;
  v1 = sub_10032356();
  if ( v1 )
    v3 = (int)((char *)v1 - 4);
  else
    v3 = 0;
  if ( !sub_10033369(**(_DWORD **)v2 + 60, *(_DWORD *)v2 + 4)
    || (v4 = 1,
        (1 << (*(_DWORD *)(*(_DWORD *)(v3 + 160) + 132) & 0x1F)) & *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v2 + 8)
                                                                             + 4
                                                                             * (*(_DWORD *)(*(_DWORD *)(v3 + 160) + 132) >> 5))) )
    v4 = 0;
  return v4;
}

//----- (1004026A) --------------------------------------------------------
bool __thiscall sub_1004026A(int this)
{
  return *(_DWORD *)(this + 4) <= *(_DWORD *)this && *(_DWORD *)(this + 80) <= *(_DWORD *)(this + 76);
}

//----- (10040280) --------------------------------------------------------
int __thiscall sub_10040280(int this, int a2)
{
  *(_DWORD *)(this + 60) = a2;
  return sub_100333A7(this + 28, sub_10040302, this, *(_DWORD *)(*(_DWORD *)(a2 + 256) + 4));
}

//----- (100402A4) --------------------------------------------------------
int __thiscall sub_100402A4(void *this)
{
  void *v2; // edi@1

  v2 = this;
  sub_10034B9B((char *)this + 112);
  *((_DWORD *)v2 + 16) = sub_10032A67();
  *(_DWORD *)v2 = 0;
  *((_DWORD *)v2 + 1) = 0;
  *((_DWORD *)v2 + 19) = 0;
  *((_DWORD *)v2 + 20) = 0;
  *((_WORD *)v2 + 48) = 0;
  *((_DWORD *)v2 + 22) = 0;
  *((_DWORD *)v2 + 14) = 0;
  *((_DWORD *)v2 + 18) = 0;
  return sub_10034BAB((char *)v2 + 112);
}

//----- (100402DE) --------------------------------------------------------
int __thiscall sub_100402DE(int this, int a2)
{
  *(_DWORD *)(this + 60) = a2;
  return sub_100333A7(this + 28, sub_10040313, this, *(_DWORD *)(*(_DWORD *)(a2 + 256) + 4));
}

//----- (10040302) --------------------------------------------------------
int __cdecl sub_10040302(int a1)
{
  return sub_100412B0(*(void **)(a1 + 60), a1);
}

//----- (10040313) --------------------------------------------------------
int __cdecl sub_10040313(int a1)
{
  return sub_10041447(*(_DWORD *)(a1 + 60), a1);
}

//----- (10040324) --------------------------------------------------------
int __userpurge sub_10040324<eax>(int a1<ebp>, int a2)
{
  int v3; // ecx@1
  int v4; // edi@1
  void *v5; // esi@1
  int v6; // ST00_4@1

  sub_10035648();
  v4 = v3;
  v5 = (void *)(v3 + 112);
  *(_DWORD *)(a1 - 16) = v3 + 112;
  sub_10034B9B((void *)(v3 + 112));
  v6 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  sub_10040503(v4, v6);
  *(_DWORD *)(a1 - 4) = -1;
  sub_10034BAB(v5);
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (10040403) --------------------------------------------------------
int __cdecl sub_10040403(int (__cdecl *a1)(_DWORD, _DWORD), int a2, int (__cdecl *a3)(_DWORD, _DWORD))
{
  int v3; // ecx@1
  int v4; // edx@2
  int v5; // eax@3
  char v6; // al@5
  int v8; // eax@1
  int v9; // ebx@1
  int v10; // edi@1
  int v11; // esi@1
  void *v12; // [sp+0h] [bp-1Ch]@1
  int v13; // [sp+8h] [bp-14h]@3
  int v14; // [sp+Ch] [bp-10h]@2

  sub_10035648();
  v9 = v3;
  v12 = *(void **)(v3 + 16);
  sub_10034B9B(v12);
  v8 = v9 + 4;
  v10 = *(_DWORD *)(v9 + 4);
  v11 = *(_DWORD *)(v9 + 4) - 1;
  if ( v11 >= *(_DWORD *)v9 )
  {
    v14 = *(_DWORD *)(v9 + 4);
    v4 = *(_DWORD *)(v9 + 4);
    do
    {
      v5 = *(_DWORD *)(*(_DWORD *)(v9 + 28) + 4 * (*(_DWORD *)(v9 + 8) & v11));
      v13 = v5;
      if ( v5 )
      {
        if ( (unsigned __int8)a1(v5, a2) )
        {
          v6 = a3(v13, a2);
          v4 = v14;
          if ( v6 )
          {
            if ( v14 == v10 )
              --v10;
            else
              *(_DWORD *)(*(_DWORD *)(v9 + 28) + 4 * (*(_DWORD *)(v9 + 8) & v11)) = 0;
          }
        }
        else
        {
          v4 = v14;
        }
      }
      --v11;
      --v4;
      v14 = v4;
    }
    while ( v11 >= *(_DWORD *)v9 );
    v8 = v9 + 4;
  }
  *(_DWORD *)v8 = v10;
  sub_10034BAB(v12);
  return sub_10035616(16);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1004040F) --------------------------------------------------------
int __thiscall sub_1004040F(int this, char a2, int a3)
{
  int v3; // esi@1
  int result; // eax@2

  v3 = this;
  if ( sub_10034BBF((void *)(this + 112)) )
  {
    sub_10040503(v3, a2);
    result = sub_10034BAB((void *)(v3 + 112));
  }
  else
  {
    *(_BYTE *)a3 = 0;
    result = 0;
  }
  return result;
}

//----- (10040475) --------------------------------------------------------
int __thiscall sub_10040475(void *this, char a2, int a3)
{
  void *v3; // esi@1
  int v4; // ecx@2
  int v5; // ebx@8
  int v6; // eax@8
  int v7; // edi@12

  v3 = this;
LABEL_11:
  v5 = 0;
  while ( 1 )
  {
    v7 = *(_DWORD *)v3++;
    if ( v7 >= *((_DWORD *)v3 + 1) )
    {
      *(_DWORD *)v3 = v7;
      return v5;
    }
    v4 = v7 & *((_DWORD *)v3 + 2);
    if ( *(_BYTE *)(*((_DWORD *)v3 + 7) + 4 * v4) & 1 )
    {
      if ( !a2 && sub_10040214((void *)(*((_DWORD *)v3 + 8) + 8 * v4)) )
        break;
    }
    if ( *((_BYTE *)v3 + 20) )
    {
      if ( *(_DWORD *)v3 >= *((_DWORD *)v3 + 6) )
        *((_BYTE *)v3 + 20) = 0;
    }
    v6 = *((_DWORD *)v3 + 7) + 4 * (v7 & *((_DWORD *)v3 + 2));
    v5 = *(_DWORD *)v6;
    *(_DWORD *)v6 = 0;
    if ( v5 )
    {
      if ( !(v5 & 1) || (v5 &= 0xFFFFFFFEu, sub_1002E690(*((_DWORD *)v3 + 8) + 8 * (v7 & *((_DWORD *)v3 + 2)), 0)) )
        return v5;
      goto LABEL_11;
    }
  }
  *(_DWORD *)v3 = v7;
  return 0;
}

//----- (10040503) --------------------------------------------------------
int __thiscall sub_10040503(int this, char a2)
{
  int v2; // ebx@1
  int result; // eax@2
  int v4; // ecx@3
  int v5; // edi@3
  int v6; // esi@3
  LPVOID v7; // eax@8
  int v8; // eax@12
  void *v9; // ecx@13
  char v10; // [sp-Ch] [bp-10h]@15

  v2 = this;
  if ( sub_1004026A(this) )
    return 0;
  v4 = *(_DWORD *)(v2 + 72);
  v5 = 0;
  v6 = 0;
  if ( v4 && *(_DWORD *)(v4 + 112) > 0 && !(unsigned __int8)(*(int (**)(void))(*(_DWORD *)v4 + 16))() )
  {
    if ( !*(_BYTE *)(v2 + 96) || (v6 = sub_10040475((void *)(v2 + 76), a2, 1), !v6) )
    {
      v7 = sub_10032356();
      if ( v7 )
        v5 = (int)((char *)v7 - 4);
      *(_BYTE *)(v5 + 179) |= 2u;
      return v6;
    }
    goto LABEL_16;
  }
  result = sub_10045EB7((void *)v2, a2);
  if ( result )
    return result;
  v8 = sub_10040475((void *)(v2 + 76), a2, 0);
  v6 = v8;
  if ( v8 )
  {
    v9 = *(void **)(v2 + 72);
    if ( v9 && *(void **)(*(_DWORD *)(v8 + 8) + 12) == v9 )
    {
      sub_1002EDCA(v9);
      v10 = 0;
LABEL_17:
      sub_1003FB01(v6, v10);
      return v6;
    }
LABEL_16:
    v10 = 1;
    goto LABEL_17;
  }
  return v6;
}

//----- (100405AA) --------------------------------------------------------
int __userpurge sub_100405AA<eax>(int a1<ebp>, int a2, int a3, int a4, int a5)
{
  int v5; // edx@1
  int v6; // ecx@1
  int v7; // ebx@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // eax@2

  sub_10035648();
  v9 = v6;
  *(_DWORD *)(a1 - 16) = v6;
  v7 = v6 + 4;
  v8 = 0;
  *(_DWORD *)v6 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(v6 + 4) = 0;
  *(_DWORD *)(v6 + 8) = 0;
  *(_DWORD *)(v6 + 12) = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(v6 + 16) = 0;
  *(_DWORD *)(v6 + 20) = 0;
  *(_DWORD *)(v6 + 24) = 0;
  *(_DWORD *)(v6 + 28) = 0;
  *(_DWORD *)(v6 + 32) = 0;
  *(_DWORD *)(a1 - 4) = 0;
  sub_1004107B(v6, 0, v6 + 4);
  if ( !*(_BYTE *)(a1 + 16) )
  {
    v10 = sub_1002ADB1(v5, v6, v7, 0, 44);
    *(_DWORD *)(a1 + 16) = v10;
    *(_BYTE *)(a1 - 4) = 1;
    if ( v10 )
      v8 = sub_10040736(*(_DWORD *)v9, v7, *(_DWORD *)(a1 + 20), 0);
    *(_DWORD *)(v9 + 16) = v8;
    *(_DWORD *)(v9 + 20) = v8;
  }
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 10040736: using guessed type _DWORD __stdcall sub_10040736(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10040624) --------------------------------------------------------
int __userpurge sub_10040624<eax>(int a1<ebp>, int a2, int a3)
{
  int v4; // ecx@1
  int v5; // esi@1
  int v6; // eax@1
  int v7; // ST00_4@1

  sub_10035648();
  v5 = v4;
  *(_DWORD *)(a1 - 16) = v4;
  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)v4 = &off_100646B4;
  *(_DWORD *)(v4 + 4) = v6;
  *(_DWORD *)(v4 + 8) = 0;
  *(_DWORD *)(v4 + 12) = 0;
  *(_DWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 20) = 0;
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)(v4 + 32) = 0;
  *(_DWORD *)(v4 + 40) = 0;
  *(_DWORD *)(v4 + 44) = 0;
  sub_100410A4(v4, v7);
  *(_DWORD *)(v5 + 28) = sub_10032A58(*(void **)(v5 + 4));
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 100646B4: using guessed type int (__stdcall *off_100646B4)(int, int);

//----- (1004067D) --------------------------------------------------------
int __userpurge sub_1004067D<eax>(int a1<ebp>, int a2, int a3, int a4)
{
  int v5; // ecx@1
  int v6; // edi@1
  int v7; // esi@1
  int v8; // eax@1
  int v9; // ST00_4@1
  void *v10; // ST0C_4@1
  int v11; // ST04_4@1
  int v12; // ST0C_4@1
  int v13; // ST08_4@1

  sub_10035648();
  v6 = v5;
  *(_DWORD *)(a1 - 16) = v5;
  *(_DWORD *)v5 = &off_100646A0;
  *(_DWORD *)(v5 + 12) = 0;
  *(_DWORD *)(v5 + 20) = 0;
  *(_DWORD *)(v5 + 24) = 0;
  *(_DWORD *)(v5 + 28) = 0;
  *(_DWORD *)(v5 + 32) = 0;
  v7 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(v5 + 40) = 0;
  *(_DWORD *)(v5 + 44) = v5 + 40;
  *(_DWORD *)(v5 + 48) = 0;
  *(_DWORD *)(a1 - 4) = 0;
  v8 = sub_100327A2(a1, a1 - 24, v5 + 12);
  v9 = *(_DWORD *)(v7 + 4);
  *(_BYTE *)(a1 - 4) = 1;
  sub_100405AA(a1, v9, v8, 0, 64);
  v10 = *(void **)(a1 - 20);
  *(_BYTE *)(a1 - 4) = 3;
  sub_100303A3(v10);
  sub_100458E3((void *)(v6 + 88), *(_DWORD *)(v7 + 4), 256, 64);
  v11 = *(_DWORD *)(v7 + 4);
  *(_BYTE *)(a1 - 4) = 4;
  sub_100458E3((void *)(v6 + 168), v11, 256, 2147483647);
  v12 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(v6 + 264) = 0;
  v13 = *(_DWORD *)(a1 + 12);
  *(_BYTE *)(a1 - 4) = 5;
  sub_100410B7(v6, v7, v13, v12);
  return sub_10035616(12);
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 100646A0: using guessed type int (__stdcall *off_100646A0)(char);

//----- (10040736) --------------------------------------------------------
#error "1004079A: call analysis failed (funcsize=39)"

//----- (100407A2) --------------------------------------------------------
int __thiscall sub_100407A2(PSLIST_HEADER ListHead)
{
  int v1; // ebx@1
  PSLIST_HEADER v2; // edi@1
  int v3; // eax@1
  int v4; // eax@1
  int i; // esi@2
  void *v6; // ecx@3
  int v7; // esi@6

  v2 = ListHead;
  v3 = (int)InterlockedFlushSList(ListHead);
  sub_1002E7C5(v3);
  v4 = (int)InterlockedFlushSList(v2 + 1);
  sub_1002E7C5(v4);
  sub_1002E7C5(LODWORD(v2[2].Alignment));
  v1 = LODWORD(v2[6].Alignment);
  if ( v1 )
  {
    do
    {
      for ( i = 0; i < LODWORD(v2[5].Alignment); ++i )
      {
        v6 = *(void **)(*(_DWORD *)v1 + 4 * i);
        if ( v6 )
          sub_1002E31F(v6, 1);
      }
      v7 = *(_DWORD *)(v1 + 4);
      sub_100303A3(*(LPVOID *)v1);
      sub_1002A4AA((LPVOID)v1);
      v1 = v7;
    }
    while ( v7 );
  }
  return sub_100303A3(HIDWORD(v2[6].Alignment));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (10040819) --------------------------------------------------------
int __usercall sub_10040819<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // edi@2
  int v6; // [sp-8h] [bp-8h]@3

  sub_10035648();
  v2 = v3;
  *(_DWORD *)(a1 - 16) = v3;
  v1 = *(_DWORD *)(v3 + 20);
  *(_DWORD *)(a1 - 4) = 0;
  if ( v1 )
  {
    do
    {
      v4 = *(_DWORD *)(v1 + 24);
      if ( v1 == *(_DWORD *)(v2 + 16) )
        v6 = *(_DWORD *)(v2 + 28) - *(_DWORD *)(v1 + 16);
      else
        v6 = *(_DWORD *)(v2 + 12);
      sub_10041610(v1, v6);
      v1 = v4;
    }
    while ( v4 );
  }
  sub_100303A3(*(LPVOID *)(v2 + 8));
  return sub_10035616(4);
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (10040863) --------------------------------------------------------
int __usercall sub_10040863<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int v2; // esi@1
  int v3; // eax@1

  sub_10035648();
  v2 = v1;
  *(_DWORD *)(a1 - 16) = v1;
  *(_DWORD *)v1 = &off_100646A0;
  v3 = *(_DWORD *)(v1 + 12);
  *(_DWORD *)(a1 - 4) = 0;
  if ( (v3 & 0xFFFFFFF) == 3 )
    sub_10040C94(*(_DWORD *)(*(_DWORD *)(v1 + 256) + 4), *(_DWORD *)(v1 + 36), v1);
  sub_100316DE((PSLIST_HEADER)(v2 + 168));
  sub_100407A2((PSLIST_HEADER)(v2 + 88));
  sub_10040819(a1);
  sub_100303A3(*(LPVOID *)(v2 + 32));
  return sub_10035616(4);
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 100646A0: using guessed type int (__stdcall *off_100646A0)(char);

//----- (100408C7) --------------------------------------------------------
int __thiscall sub_100408C7(int this, int a2)
{
  int v3; // esi@1

  v3 = this;
  sub_100303A3(*(LPVOID *)(this + 4));
  *(_DWORD *)v3 = *(_DWORD *)a2;
  *(_DWORD *)(v3 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 4) = 0;
  return v3;
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (100408F1) --------------------------------------------------------
int __thiscall sub_100408F1(int this, int a2)
{
  signed int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // edx@3
  int v12; // ecx@11
  signed __int64 v15; // qax@11
  signed int v16; // ST0C_4@11
  int v17; // edx@11
  int v18; // ecx@11
  int v19; // eax@12
  int v28; // edx@17
  char v30; // [sp+Ch] [bp-20h]@22
  int v31; // [sp+14h] [bp-18h]@21
  BOOL (__cdecl *v32)(); // [sp+18h] [bp-14h]@21
  int v33; // [sp+1Ch] [bp-10h]@5
  int v34; // [sp+20h] [bp-Ch]@2
  int v35; // [sp+24h] [bp-8h]@1
  char v36; // [sp+2Bh] [bp-1h]@1

  v5 = this;
  v3 = *(_DWORD *)(this + 48);
  v36 = 0;
  v4 = 0;
  v35 = v3;
  v2 = 4;
  do
  {
    _EBX = v3 + 8;
    v34 = v3 + 8;
    if ( *(_DWORD *)(v3 + 8) >= -1 )
    {
      _EBX = *(_DWORD *)v3;
      v7 = 0;
      if ( *(_DWORD *)(v5 + 40) <= 0 )
      {
LABEL_7:
        _EBX = v34;
      }
      else
      {
        while ( *(_DWORD *)_EBX )
        {
          ++v7;
          _EBX += v2;
          if ( v7 >= *(_DWORD *)(v5 + 40) )
            goto LABEL_7;
        }
        _ECX = a2;
        *(_DWORD *)a2 = v7 + v4;
        v33 = *(_DWORD *)(v5 + 64);
        __asm { lock cmpxchg [ebx], ecx }
        v4 += v7;
        v36 = 1;
        if ( v4 >= v33 )
        {
          _EAX = v5 + 64;
          _ECX = 1;
          __asm { lock xadd [eax], ecx }
        }
        _EBX = v34;
        _ECX = -1;
        __asm { lock cmpxchg [ebx], ecx }
      }
      v3 = v35;
    }
    if ( !v36 )
    {
      _ECX = -2;
      __asm { lock cmpxchg [ebx], ecx }
      v4 += *(_DWORD *)(v5 + 40);
      _EBX = v3 + 4;
      if ( !*(_DWORD *)(v3 + 4) )
      {
        _ECX = 1;
        __asm { lock cmpxchg [ebx], ecx }
        _ECX = 0;
        v15 = 4i64 * *(_DWORD *)(v5 + 40);
        __asm { seto    cl }
        v16 = 4 * *(_DWORD *)(v5 + 40);
        v33 = sub_1002965B(SHIDWORD(v15), v15 | -_ECX, _EBX, v4, v15 | -_ECX);
        sub_100391F0((void *)v33, 0, v16);
        v12 = sub_1002ADB1(v17, v18, _EBX, v4, 12);
        if ( v12 )
        {
          v19 = v33;
          *(_DWORD *)(v12 + 4) = 0;
          *(_DWORD *)(v12 + 8) = -1;
          *(_DWORD *)v12 = v19;
        }
        else
        {
          v12 = 0;
        }
        v28 = *(_DWORD *)(v5 + 60);
        if ( v28 < *(_DWORD *)(v5 + 56) )
        {
          *(_DWORD *)(*(_DWORD *)(v5 + 52) + 4 * v28) = v12;
          ++*(_DWORD *)(v5 + 60);
        }
        *(_DWORD *)_EBX = v12;
        v3 = v35;
      }
      if ( *(_DWORD *)_EBX == 1 )
      {
        v31 = 0;
        v32 = sub_10034BF4;
        do
          sub_100282E0((int)&v30);
        while ( *(_DWORD *)_EBX == 1 );
        v3 = v35;
      }
    }
    v3 = *(_DWORD *)(v3 + 4);
    v35 = v3;
    v2 = 4;
  }
  while ( !v36 );
  return v4;
}

//----- (10040A49) --------------------------------------------------------
int __thiscall sub_10040A49(int this, int a2)
{
  signed int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // edx@3
  int v12; // ecx@11
  signed __int64 v15; // qax@11
  signed int v16; // ST0C_4@11
  int v17; // edx@11
  int v18; // ecx@11
  int v19; // eax@12
  int v28; // edx@17
  char v30; // [sp+Ch] [bp-20h]@22
  int v31; // [sp+14h] [bp-18h]@21
  BOOL (__cdecl *v32)(); // [sp+18h] [bp-14h]@21
  int v33; // [sp+1Ch] [bp-10h]@5
  int v34; // [sp+20h] [bp-Ch]@2
  int v35; // [sp+24h] [bp-8h]@1
  char v36; // [sp+2Bh] [bp-1h]@1

  v5 = this;
  v3 = *(_DWORD *)(this + 48);
  v36 = 0;
  v4 = 0;
  v35 = v3;
  v2 = 4;
  do
  {
    _EBX = v3 + 8;
    v34 = v3 + 8;
    if ( *(_DWORD *)(v3 + 8) >= -1 )
    {
      _EBX = *(_DWORD *)v3;
      v7 = 0;
      if ( *(_DWORD *)(v5 + 40) <= 0 )
      {
LABEL_7:
        _EBX = v34;
      }
      else
      {
        while ( *(_DWORD *)_EBX )
        {
          ++v7;
          _EBX += v2;
          if ( v7 >= *(_DWORD *)(v5 + 40) )
            goto LABEL_7;
        }
        _ECX = a2;
        *(_DWORD *)(a2 + 248) = v7 + v4;
        v33 = *(_DWORD *)(v5 + 64);
        __asm { lock cmpxchg [ebx], ecx }
        v4 += v7;
        v36 = 1;
        if ( v4 >= v33 )
        {
          _EAX = v5 + 64;
          _ECX = 1;
          __asm { lock xadd [eax], ecx }
        }
        _EBX = v34;
        _ECX = -1;
        __asm { lock cmpxchg [ebx], ecx }
      }
      v3 = v35;
    }
    if ( !v36 )
    {
      _ECX = -2;
      __asm { lock cmpxchg [ebx], ecx }
      v4 += *(_DWORD *)(v5 + 40);
      _EBX = v3 + 4;
      if ( !*(_DWORD *)(v3 + 4) )
      {
        _ECX = 1;
        __asm { lock cmpxchg [ebx], ecx }
        _ECX = 0;
        v15 = 4i64 * *(_DWORD *)(v5 + 40);
        __asm { seto    cl }
        v16 = 4 * *(_DWORD *)(v5 + 40);
        v33 = sub_1002965B(SHIDWORD(v15), v15 | -_ECX, _EBX, v4, v15 | -_ECX);
        sub_100391F0((void *)v33, 0, v16);
        v12 = sub_1002ADB1(v17, v18, _EBX, v4, 12);
        if ( v12 )
        {
          v19 = v33;
          *(_DWORD *)(v12 + 4) = 0;
          *(_DWORD *)(v12 + 8) = -1;
          *(_DWORD *)v12 = v19;
        }
        else
        {
          v12 = 0;
        }
        v28 = *(_DWORD *)(v5 + 60);
        if ( v28 < *(_DWORD *)(v5 + 56) )
        {
          *(_DWORD *)(*(_DWORD *)(v5 + 52) + 4 * v28) = v12;
          ++*(_DWORD *)(v5 + 60);
        }
        *(_DWORD *)_EBX = v12;
        v3 = v35;
      }
      if ( *(_DWORD *)_EBX == 1 )
      {
        v31 = 0;
        v32 = sub_10034BF4;
        do
          sub_100282E0((int)&v30);
        while ( *(_DWORD *)_EBX == 1 );
        v3 = v35;
      }
    }
    v3 = *(_DWORD *)(v3 + 4);
    v35 = v3;
    v2 = 4;
  }
  while ( !v36 );
  return v4;
}

//----- (10040BA5) --------------------------------------------------------
char __thiscall sub_10040BA5(void *this, int a2, char a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int v7; // esi@1
  int v8; // ebx@4
  int v9; // eax@5
  int v10; // eax@6
  char v12; // [sp-14h] [bp-30h]@10
  char v13; // [sp-10h] [bp-2Ch]@5
  int v14; // [sp-Ch] [bp-28h]@5
  int v15; // [sp-8h] [bp-24h]@5
  int v16; // [sp-4h] [bp-20h]@5
  char v17; // [sp+Ch] [bp-10h]@10

  v7 = (int)this;
  v6 = (int)sub_10032356();
  if ( !v6 || sub_1003D43F(v6) != v7 )
    *(_DWORD *)(a2 + 228) = 1;
  v8 = *(_DWORD *)(*(_DWORD *)(v7 + 256) + 4);
  if ( *(_DWORD *)(v8 + 432) <= 0
    || (sub_1002F3E5((int)&v13, (int)&a3),
        LOBYTE(v9) = (*(int (__thiscall **)(int, int, _DWORD, int, int, int))(*(_DWORD *)v8 + 60))(
                       v8,
                       a2,
                       *(_DWORD *)&v13,
                       v14,
                       v15,
                       v16),
        !(_BYTE)v9) )
  {
    v10 = *(_DWORD *)v7;
    v16 = a2;
    (*(void (__thiscall **)(int, int))(v10 + 8))(v7, a2);
    v9 = v7 + 12;
    if ( *(_DWORD *)(v7 + 12) & 0xFFFFFFF )
    {
      LOBYTE(v9) = sub_1002E288((int)&a3, v7 + 12);
      if ( (_BYTE)v9 )
        LOBYTE(v9) = (*(int (__thiscall **)(int))(*(_DWORD *)v7 + 4))(v7);
    }
    if ( *(_DWORD *)(v8 + 428) > 0 )
    {
      sub_1002F3E5((int)&v17, (int)&a3);
      v16 = 11;
      sub_1002F3E5((int)&v12, (int)&v17);
      LOBYTE(v9) = sub_10034194((void *)v8, v7, v12, *(int *)&v13, v14, v15, v16);
    }
  }
  *(_DWORD *)(a2 + 228) = 0;
  return v9;
}

//----- (10040C88) --------------------------------------------------------
bool __cdecl sub_10040C88(int a1)
{
  bool result; // eax@1

  result = sub_10032DBB(*(_DWORD *)(a1 + 36));
  if ( !result )
  {
    sub_10032242(*(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    *(_DWORD *)(a1 + 72) = 0;
  }
  return result;
}

//----- (10040C94) --------------------------------------------------------
int __thiscall sub_10040C94(int this, int a2, int a3)
{
  int result; // eax@1

  result = a3;
  if ( *(_DWORD *)((a2 << 7) + *(_DWORD *)(this + 92)) == a3 )
  {
    _EDX = 0;
    _ECX = (a2 << 7) + *(_DWORD *)(this + 92);
    __asm { lock cmpxchg [ecx], edx }
  }
  return result;
}

//----- (10040CB9) --------------------------------------------------------
int __thiscall sub_10040CB9(void *this, int a2, int a3)
{
  int v3; // ecx@1
  int v4; // ebx@1
  int v5; // eax@3
  PSINGLE_LIST_ENTRY v6; // eax@5
  int v7; // esi@6
  int v8; // ecx@11
  int v10; // [sp+Ch] [bp-4h]@3

  v4 = (int)this;
  v3 = (int)((char *)this + 16);
  if ( *(_DWORD *)a2 & 0xFFFFFFF )
    v3 = v4 + 12;
  v10 = v3;
  v5 = a3 + 96;
  if ( *(_DWORD *)a2 & 0xFFFFFFF )
    v5 = a3 + 16;
  v6 = InterlockedPopEntrySList((PSLIST_HEADER)v5);
  if ( v6 && (v7 = (int)&v6[-71], v6 != (PSINGLE_LIST_ENTRY)284) )
    sub_100410B7((int)&v6[-71], v4, a3, a2);
  else
    v7 = (*(int (__thiscall **)(_DWORD, _DWORD, _DWORD))(*(_DWORD *)v4 + 32))(v4, a3, a2);
  *(_DWORD *)(v7 + 260) = *(_DWORD *)v10;
  *(_DWORD *)v10 = v7;
  if ( !*(_DWORD *)(a3 + 188) )
    sub_100473F5(a3);
  v8 = a3 + 96;
  if ( *(_DWORD *)a2 & 0xFFFFFFF )
    v8 = a3 + 16;
  sub_10040A49(v8, v7);
  return v7;
}

//----- (10040D51) --------------------------------------------------------
int __usercall sub_10040D51<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int v3; // esi@1
  int v5; // eax@2
  int v6; // eax@3

  sub_10035648();
  v3 = v1;
  _EDI = v1 + 16;
  if ( !*(_DWORD *)(v1 + 16) )
  {
    _EDX = 1;
    __asm { lock cmpxchg [edi], edx }
    v5 = sub_1002ADB1(1, v1, 0, _EDI, 44);
    *(_DWORD *)(a1 - 16) = v5;
    *(_DWORD *)(a1 - 4) = 0;
    if ( v5 )
      v6 = sub_10040736(*(_DWORD *)v3, v3 + 4, *(_DWORD *)(v3 + 12), 0);
    else
      v6 = 0;
    *(_DWORD *)(a1 - 4) = -1;
    *(_DWORD *)_EDI = v6;
    *(_DWORD *)(v3 + 20) = v6;
  }
  if ( !*(_DWORD *)(v3 + 20) )
  {
    *(_DWORD *)(a1 - 24) = 0;
    *(_DWORD *)(a1 - 20) = sub_10034BB6;
    do
      sub_100282E0(a1 - 32);
    while ( !*(_DWORD *)(v3 + 20) );
  }
  return sub_10035616(20);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 10040736: using guessed type _DWORD __stdcall sub_10040736(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10040DC7) --------------------------------------------------------
char __userpurge sub_10040DC7<al>(int a1<ecx>, int i<edi>, int a3)
{
  int v4; // ebx@1
  unsigned int v5; // esi@2
  int v7; // eax@6
  int v8; // ecx@6
  int v9; // edx@7
  int v10; // eax@11
  int v13; // esi@16
  char v14; // al@16
  int v16; // [sp+Ch] [bp-18h]@16
  int v17; // [sp+10h] [bp-14h]@16
  int v18; // [sp+14h] [bp-10h]@1
  int v19; // [sp+18h] [bp-Ch]@6
  int v20; // [sp+1Ch] [bp-8h]@11
  int v21; // [sp+20h] [bp-4h]@6

  v4 = a1;
  v18 = a1;
  _EDX = a1 + 24;
LABEL_2:
  v5 = *(_DWORD *)_EDX;
  while ( v5 != *(_DWORD *)(v4 + 28) )
  {
    _ECX = v5 + 1;
    __asm { lock cmpxchg [edx], ecx }
    if ( v5 == v5 )
    {
      v8 = sub_10041139(v4, v4, i, v5, 0);
      v7 = v4 + 20;
      v21 = v8;
      v19 = v4 + 20;
      if ( v8 != *(_DWORD *)(v4 + 20) )
      {
        v9 = *(_DWORD *)v7;
        for ( i = *(_DWORD *)v7; ; i = v9 )
        {
          while ( !(*(_DWORD *)(v4 + 12) + *(_DWORD *)(i + 20)) )
            i = *(_DWORD *)(i + 24);
          if ( *(_DWORD *)(i + 16) <= *(_DWORD *)(v9 + 16) )
            break;
          _EBX = v19;
          _ECX = i;
          v10 = v9;
          __asm { lock cmpxchg [ebx], ecx }
          v4 = v18;
          v20 = v9;
          if ( v9 == v9 )
          {
            while ( v10 != i )
            {
              sub_10041610(v10, *(_DWORD *)(v4 + 12));
              v10 = *(_DWORD *)(v20 + 24);
              v20 = *(_DWORD *)(v20 + 24);
            }
            break;
          }
        }
        v8 = v21;
      }
      v13 = v5 - *(_DWORD *)(v8 + 16);
      v16 = v8;
      v17 = v13;
      v14 = sub_1002E690((int)&v16, a3);
      _EDX = v4 + 24;
      if ( v14 )
        return 1;
      goto LABEL_2;
    }
  }
  return 0;
}

//----- (10040EAC) --------------------------------------------------------
int __thiscall sub_10040EAC(int this, int a2)
{
  int v2; // eax@1
  int v3; // ebx@1

  v3 = this;
  v2 = *(_DWORD *)(this + 256);
  if ( !(*(_BYTE *)(v2 + 48) & 4) )
  {
    _EAX = v2 + 20;
    _EDX = 1;
    __asm { lock xadd [eax], edx }
  }
  sub_1004128F((void *)(a2 + 76));
  *(_DWORD *)(a2 + 56) = 1;
  return sub_100408F1(v3 + 168, a2 + 44);
}

//----- (10040EF2) --------------------------------------------------------
int __thiscall sub_10040EF2(int this, int a2)
{
  int v3; // ebx@1

  v3 = this;
  sub_10034B9B((void *)(this + 8));
  *(_DWORD *)(a2 + 12) = 0;
  **(_DWORD **)(v3 + 4) = a2;
  *(_DWORD *)(v3 + 4) = a2 + 12;
  return sub_10034BAB((void *)(v3 + 8));
}

//----- (10040F22) --------------------------------------------------------
int __thiscall sub_10040F22(void *this, int a2, int a3)
{
  int v3; // esi@1
  int v4; // esi@3
  char v6; // [sp+Ch] [bp-10h]@3

  v3 = (int)((char *)this + 16);
  if ( *(_DWORD *)a2 & 0xFFFFFFF )
    v3 = (int)((char *)this + 12);
  v4 = *(_DWORD *)v3;
  sub_10045E53(*(void **)(a3 + 4), (int)&v6);
  while ( v4 && (!sub_1002E288(v4 + 12, a2) || *(_DWORD *)(v4 + 8) != a3) )
    v4 = *(_DWORD *)(v4 + 260);
  return v4;
}

//----- (10040F74) --------------------------------------------------------
int __thiscall sub_10040F74(int this)
{
  signed int v1; // ebx@1
  int v2; // edi@1
  signed int v3; // esi@1
  int v4; // eax@2
  int result; // eax@5
  int v6; // esi@7
  int v7; // [sp+Ch] [bp-4h]@2

  v2 = this;
  v3 = 0;
  v1 = *(_DWORD *)(this + 232);
  if ( v1 <= 0 )
  {
LABEL_5:
    result = 0;
  }
  else
  {
    while ( 1 )
    {
      v4 = sub_100318B8(v2 + 168, v3);
      v7 = v4;
      if ( v4 )
      {
        if ( sub_100412EF((void *)(v2 + 168), v4, v3, 0) )
          break;
      }
      ++v3;
      if ( v3 >= v1 )
        goto LABEL_5;
    }
    v6 = *(_DWORD *)(v7 + 8);
    *(_DWORD *)(v6 + 56) = 0;
    sub_1003333B(*(void **)(v2 + 256));
    result = v6;
  }
  return result;
}

//----- (10040FD9) --------------------------------------------------------
int __thiscall sub_10040FD9(void *this, int a2, char a3)
{
  int v3; // eax@1
  int ebp0; // ebp@0
  int v5; // edi@1
  int v6; // esi@1

  v5 = (int)this;
  v3 = sub_1003293C(ebp0, 1);
  v6 = v3;
  if ( v3 )
    sub_10046AE2(v3, v5, a2, a3);
  return v6;
}

//----- (1004100C) --------------------------------------------------------
int __thiscall sub_1004100C(void *this)
{
  void *v1; // edi@3
  void *v2; // esi@3
  int v3; // edi@3
  int v4; // ecx@1
  int result; // eax@2

  v4 = (int)((char *)this + 40);
  if ( *(_DWORD *)v4 )
  {
    v1 = (void *)v4;
    v2 = (void *)(v4 + 8);
    sub_10034B9B((void *)(v4 + 8));
    v3 = sub_1003229F(v1);
    sub_10034BAB(v2);
    result = v3;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004101C) --------------------------------------------------------
int __userpurge sub_1004101C<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // eax@1
  int v9; // edx@1
  int v10; // ecx@1

  sub_10035648();
  v6 = v7;
  v8 = sub_1002ADB1(v9, v7, a1, a3, 44);
  v10 = v8;
  *(_DWORD *)(a2 - 16) = v8;
  v5 = *(_DWORD *)(a2 + 8);
  v4 = 0;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v10 )
    v4 = sub_10040736(*(_DWORD *)v6, v6 + 4, *(_DWORD *)(v6 + 12), *(_DWORD *)(v6 + 12) + *(_DWORD *)(v5 + 16));
  *(_DWORD *)(v6 + 16) = v4;
  *(_DWORD *)(v5 + 24) = v4;
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 10040736: using guessed type _DWORD __stdcall sub_10040736(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (10041066) --------------------------------------------------------
bool __thiscall sub_10041066(int this)
{
  return *(_DWORD *)(this + 40) != 0;
}

//----- (1004106F) --------------------------------------------------------
bool __thiscall sub_1004106F(void *this)
{
  return sub_1004123C(this) != 0;
}

//----- (1004107B) --------------------------------------------------------
int __userpurge sub_1004107B<eax>(int a1<ecx>, int a2<edi>, int a3)
{
  int result; // eax@1
  int v4; // esi@1

  v4 = a1;
  result = sub_10032153(a1 + 4, a2, a3);
  if ( *(_DWORD *)(v4 + 20) )
    result = sub_10032153(*(_DWORD *)(v4 + 20) + 4, a2, a3);
  return result;
}

//----- (100410A4) --------------------------------------------------------
int __thiscall sub_100410A4(int this, int a2)
{
  *(_DWORD *)(this + 20) = 1;
  return sub_1002F3E5(this + 32, a2);
}

//----- (100410B7) --------------------------------------------------------
int __thiscall sub_100410B7(int this, int a2, int a3, int a4)
{
  int ebp0; // ebp@0
  int v5; // esi@1
  int v6; // eax@1
  char v8; // [sp+Ch] [bp-8h]@1
  void *v9; // [sp+10h] [bp-4h]@1

  v5 = this;
  *(_DWORD *)(this + 256) = a2;
  *(_DWORD *)(this + 8) = a3;
  sub_1002F3E5(this + 12, a4);
  *(_DWORD *)(v5 + 268) = 0;
  *(_DWORD *)(v5 + 280) = 1;
  v6 = sub_100327A2(ebp0, (int)&v8, a4);
  sub_100408C7(v5 + 28, v6);
  sub_100303A3(v9);
  if ( (*(_DWORD *)a4 & 0xFFFFFFF) == 3 )
    *(_DWORD *)(v5 + 36) = sub_10032C17(*(_DWORD *)(a2 + 4), *(_DWORD *)(a4 + 8));
  return sub_1004107B(v5 + 52, a4, v5 + 28);
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (10041139) --------------------------------------------------------
int __userpurge sub_10041139<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, unsigned int a4, char a5)
{
  int ebp0; // ebp@0
  int v6; // esi@1
  int v7; // ecx@4
  int v8; // edx@6

  v6 = a1;
  if ( !*(_DWORD *)(a1 + 20) )
    sub_10040D51(ebp0);
  if ( a5 )
    v7 = *(_DWORD *)(v6 + 16);
  else
    v7 = *(_DWORD *)(v6 + 20);
  v8 = v7;
  do
  {
    if ( a4 < *(_DWORD *)(v6 + 12) + *(_DWORD *)(v7 + 16) )
      break;
    v7 = *(_DWORD *)(v7 + 24);
    if ( !v7 )
      v7 = sub_1004101C(a2, ebp0, a3, v8);
    v8 = v7;
  }
  while ( v7 );
  return v7;
}

//----- (10041183) --------------------------------------------------------
int __thiscall sub_10041183(int this, int a2, char a3)
{
  int v3; // eax@1
  int v4; // esi@1
  int v5; // edi@2
  int v6; // ebx@4
  int v7; // eax@5
  int v8; // eax@5
  int result; // eax@8
  char v10; // [sp+Ch] [bp-34h]@5
  char v11; // [sp+1Ch] [bp-24h]@4
  int v12; // [sp+2Ch] [bp-14h]@4
  int v13; // [sp+34h] [bp-Ch]@4
  int v14; // [sp+38h] [bp-8h]@4
  int v15; // [sp+3Ch] [bp-4h]@4

  v4 = this;
  v3 = sub_100324C2(*(void **)(this + 4));
  if ( v3 )
    v5 = *(_DWORD *)(v3 + 4);
  else
    v5 = sub_10032B10(*(_DWORD *)(v4 + 4));
  sub_10045E53(*(void **)(v5 + 4), (int)&v11);
  v6 = a2;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = v5;
  while ( !sub_1004D709((int)&v11, v6) )
  {
    v7 = sub_10032AE6(*(_DWORD *)(v4 + 4), 0, v5);
    v5 = v7;
    v8 = sub_10045E53(*(void **)(v7 + 4), (int)&v10);
    sub_1002F3E5((int)&v11, v8);
    if ( v5 == v15 )
      v6 = (int)&v12;
  }
  result = (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v4 + 36))(v4, v6, v5);
  if ( !result )
  {
    if ( a3 )
    {
      sub_10030FB0((void *)(v4 + 8));
      result = (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v4 + 36))(v4, v6, v5);
      if ( !result )
        result = sub_10040CB9((void *)v4, v6, v5);
      *(_DWORD *)(v4 + 8) = 0;
    }
  }
  return result;
}

//----- (1004123C) --------------------------------------------------------
bool __thiscall sub_1004123C(void *this)
{
  signed int i; // edi@1
  int v2; // esi@1
  bool result; // eax@2

  v2 = (int)this;
  for ( i = 0; i < *(_DWORD *)(v2 + 152); ++i )
  {
    result = sub_100318B8(v2 + 88, i);
    if ( result )
    {
      if ( *(_DWORD *)(result + 4) > *(_DWORD *)result || *(_DWORD *)(result + 80) > *(_DWORD *)(result + 76) )
        return result;
      if ( *(_DWORD *)(result + 56) == 1 )
        sub_1004146E(v2, result);
    }
  }
  return *(_DWORD *)(v2 + 76) != *(_DWORD *)(v2 + 80);
}

//----- (1004128F) --------------------------------------------------------
int __thiscall sub_1004128F(void *this)
{
  void *v2; // edi@1
  void *v3; // esi@1
  int v4; // eax@1

  v2 = this;
  v3 = (void *)*((_DWORD *)this + 4);
  sub_10034B9B(*((void **)this + 4));
  v4 = *((_DWORD *)v2 + 1);
  *((_BYTE *)v2 + 20) = 1;
  *((_DWORD *)v2 + 6) = v4;
  return sub_10034BAB(v3);
}

//----- (100412B0) --------------------------------------------------------
int __thiscall sub_100412B0(void *this, int a2)
{
  return sub_100408F1((int)((char *)this + 168), a2 + 44);
}

//----- (100412C9) --------------------------------------------------------
PSINGLE_LIST_ENTRY __thiscall sub_100412C9(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v4; // esi@1

  v4 = this;
  sub_10046C11(a2, ebp0);
  return sub_10033ABD(*(_DWORD *)(*((_DWORD *)v4 + 64) + 4), a2, 0);
}

//----- (100412EF) --------------------------------------------------------
char __thiscall sub_100412EF(void *ListHead, int a2, signed int a3, char a4)
{
  signed int v4; // edx@1
  int v6; // esi@1
  char result; // al@2
  int v8; // eax@3
  int v9; // ecx@3
  int v10; // edx@4
  int v11; // edi@4
  int v12; // edx@5
  PSINGLE_LIST_ENTRY v18; // eax@14
  int v19; // ST08_4@14

  v6 = (int)ListHead;
  v4 = a3 >> *((_DWORD *)ListHead + 11);
  _EBX = a3 & (*((_DWORD *)ListHead + 10) - 1);
  if ( v4 < *((_DWORD *)ListHead + 15) )
  {
    v9 = *((_DWORD *)ListHead + 14);
    v8 = *(_DWORD *)(v6 + 52);
    if ( v4 < v9 )
    {
      v11 = *(_DWORD *)(v8 + 4 * v4);
    }
    else
    {
      v10 = v4 - v9;
      v11 = *(_DWORD *)(v8 + 4 * v9 - 4);
      if ( v10 >= 0 )
      {
        v12 = v10 + 1;
        do
        {
          v11 = *(_DWORD *)(v11 + 4);
          --v12;
        }
        while ( v12 );
      }
    }
    _ECX = *(_DWORD *)v11 + 4 * _EBX;
    _EDX = 0;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 == a2 )
    {
      _ECX = v11 + 8;
      __asm { lock cmpxchg [ecx], ebx }
      if ( a4 )
      {
        if ( (signed int)QueryDepthSList((PSLIST_HEADER)v6) <= *(_DWORD *)(v6 + 68) )
        {
          InterlockedPushEntrySList((PSLIST_HEADER)v6, (PSINGLE_LIST_ENTRY)(a2 + 4));
        }
        else
        {
          InterlockedPushEntrySList((PSLIST_HEADER)(v6 + 8), (PSINGLE_LIST_ENTRY)(a2 + 4));
          if ( (signed int)QueryDepthSList((PSLIST_HEADER)(v6 + 8)) > *(_DWORD *)(v6 + 68) )
          {
            if ( !sub_10032DBB(*(_DWORD *)(v6 + 36)) )
            {
              _EDX = 1;
              _ECX = v6 + 72;
              __asm { lock cmpxchg [ecx], edx }
              v18 = InterlockedFlushSList((PSLIST_HEADER)(v6 + 8));
              v19 = *(_DWORD *)(v6 + 36);
              *(_DWORD *)(v6 + 16) = v18;
              sub_100333A7(v6 + 20, (int (__cdecl *)(_DWORD))sub_10040C88, v6, v19);
            }
          }
        }
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100413E5) --------------------------------------------------------
char __thiscall sub_100413E5(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_10033E49(*(_DWORD *)(*(_DWORD *)(this + 256) + 4), this + 268);
  return sub_10047552(*(void **)(v2 + 8), v2);
}

//----- (10041408) --------------------------------------------------------
char __thiscall sub_10041408(int this)
{
  int v1; // ecx@1
  int v2; // edi@1
  char result; // al@2
  int v4; // esi@2
  int v5; // ecx@3
  int v6; // esi@4

  v2 = this;
  v1 = *(_DWORD *)(this + 16);
  if ( v1 )
  {
    do
    {
      v4 = *(_DWORD *)(v1 + 260);
      result = sub_100413E5(v1);
      v1 = v4;
    }
    while ( v4 );
  }
  v5 = *(_DWORD *)(v2 + 12);
  if ( v5 )
  {
    do
    {
      v6 = *(_DWORD *)(v5 + 260);
      result = sub_100413E5(v5);
      v5 = v6;
    }
    while ( v6 );
  }
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)(v2 + 12) = 0;
  return result;
}

//----- (10041447) --------------------------------------------------------
int __thiscall sub_10041447(int this, int a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1002EE2C((void *)(this + 88), a2, *(_DWORD *)(a2 + 68), 1);
  return sub_1003333B(*(void **)(v3 + 256));
}

//----- (1004146E) --------------------------------------------------------
char __thiscall sub_1004146E(int this, int a2)
{
  int v2; // edi@1

  v2 = this;
  if ( sub_100412EF((void *)(this + 168), a2 + 44, *(_DWORD *)(a2 + 44), 0) )
  {
    if ( *(_DWORD *)(a2 + 80) <= *(_DWORD *)(a2 + 76) )
    {
      sub_100402DE(a2, v2);
      return 1;
    }
    sub_10040280(a2, v2);
  }
  return 0;
}

//----- (100414B0) --------------------------------------------------------
int __thiscall sub_100414B0(void *this, int a2, int a3, int a4)
{
  int v5; // eax@1

  v5 = (*(int (__stdcall **)(int, signed int))(*(_DWORD *)this + 20))(a4, 1);
  return sub_100414E4(v5, a2, a3);
}

//----- (100414CE) --------------------------------------------------------
int __thiscall sub_100414CE(void *this, int a2, int a3)
{
  int v4; // eax@1

  v4 = (*(int (__cdecl **)(_DWORD, _DWORD))(*(_DWORD *)this + 20))((char *)this + 32, 1);
  return sub_100414E4(v4, a2, a3);
}

//----- (100414E4) --------------------------------------------------------
int __thiscall sub_100414E4(int this, int a2, int a3)
{
  int v3; // ebx@1
  int v4; // eax@2
  int v5; // eax@2
  int v6; // ecx@2
  int v7; // edi@2
  int v15; // eax@4
  int v16; // esi@4
  int v17; // eax@6
  int v18; // edx@9
  int v19; // ecx@9
  void *v20; // esi@9
  int result; // eax@17
  char v22; // [sp-10h] [bp-28h]@18
  int v23; // [sp-4h] [bp-1Ch]@2
  int (__stdcall **v24)(char); // [sp+Ch] [bp-Ch]@20

  v3 = this;
  if ( !a2 )
  {
    a2 = (int)"proc";
    sub_1002AEA4((int)&v24, &a2);
    v24 = &off_1005F2EC;
    sub_100355BB((int)&v24, (int)&unk_1006C8B4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10041610);
  }
  v5 = *(_DWORD *)(this + 256);
  v23 = a3;
  v7 = *(_DWORD *)(v5 + 4);
  v4 = sub_10032BA7(v7, this, v7, a2, a3);
  v6 = *(_DWORD *)(v3 + 256);
  if ( !(*(_BYTE *)(v6 + 48) & 4) )
  {
    _ECX = v6 + 20;
    _EDX = 1;
    __asm { lock xadd [ecx], edx }
  }
  sub_10040EF2(v3 + 40, v4);
  v15 = (int)sub_10032356();
  v16 = v15;
  if ( v15 && sub_10032DD0(v15) == v7 )
  {
    v17 = *(_DWORD *)(v16 + 156);
    if ( *(_BYTE *)(v16 + 76) )
      ++*(_DWORD *)(v17 + 8);
    else
      ++*(_DWORD *)(v17 + 92);
  }
  else
  {
    v20 = TlsGetValue(*(_DWORD *)(v7 + 24));
    if ( !v20 )
    {
      v20 = (void *)sub_1002ADB1(v18, v19, v3, v7, 28);
      if ( v20 )
      {
        *((_DWORD *)v20 + 2) = 0;
        *((_DWORD *)v20 + 3) = 0;
        *((_DWORD *)v20 + 4) = 0;
        *((_DWORD *)v20 + 5) = 0;
        *((_DWORD *)v20 + 6) = 1;
      }
      else
      {
        v20 = 0;
      }
      sub_100408F1(v7 + 200, (int)v20);
      TlsSetValue(*(_DWORD *)(v7 + 24), v20);
    }
    ++*((_DWORD *)v20 + 2);
  }
  if ( *(_DWORD *)(v3 + 12) & 0xFFFFFFF )
    (*(void (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
  result = *(_DWORD *)(v7 + 432);
  if ( *(_DWORD *)(v7 + 428) - result > 0 )
  {
    sub_1002F3E5((int)&v22, v3 + 12);
    result = (*(int (__thiscall **)(int))(*(_DWORD *)v7 + 56))(v7);
  }
  return result;
}
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);

//----- (10041610) --------------------------------------------------------
int __thiscall sub_10041610(int this, int a2)
{
  int result; // eax@1

  _EDX = a2;
  result = this + 20;
  __asm { lock xadd [eax], edx }
  if ( !(a2 + _EDX) )
    result = sub_100333A7(this + 28, sub_1002EF7A, this, *(_DWORD *)this);
  return result;
}

//----- (10041636) --------------------------------------------------------
int __userpurge sub_10041636<eax>(int a1<ecx>, int a2<edi>, char a3)
{
  signed int v3; // ebx@1
  int ebp0; // ebp@0
  int v5; // esi@1
  int v6; // ecx@1
  signed int v7; // eax@2
  int v8; // eax@3
  int result; // eax@5
  int v10; // eax@7
  int v11; // eax@8
  int v12; // ecx@8
  char v13; // al@12
  int v14; // ecx@17
  int v15; // ecx@20
  int v16; // eax@21
  char v17; // al@26
  int v18; // eax@35
  int v19; // [sp+Ch] [bp-5Ch]@1
  int v20; // [sp+10h] [bp-58h]@9
  int v21; // [sp+14h] [bp-54h]@5
  int v22; // [sp+18h] [bp-50h]@2
  int v23; // [sp+1Ch] [bp-4Ch]@2
  char v24; // [sp+22h] [bp-46h]@2
  char v25; // [sp+23h] [bp-45h]@1
  int v26[16]; // [sp+24h] [bp-44h]@8
  unsigned int v27; // [sp+64h] [bp-4h]@1
  int v28; // [sp+68h] [bp+0h]@1

  v27 = (unsigned int)&v28 ^ __security_cookie;
  v5 = a1;
  v3 = 0;
  v6 = *(_DWORD *)(a1 + 152);
  LOBYTE(v20) = a3;
  v25 = 0;
  v19 = v6;
  if ( v6 > 0 )
  {
    v7 = 0;
    v22 = 0;
    v24 = 0;
    v23 = 0;
    while ( 1 )
    {
      v8 = sub_100318B8(v5 + 88, v7);
      a2 = v8;
      if ( v8 )
      {
        if ( sub_1004026A(v8) )
        {
          v13 = *(_DWORD *)(a2 + 56) == 1;
        }
        else
        {
          result = sub_1004040F(a2, a3, (int)&v24);
          v21 = result;
          if ( result )
            return result;
          if ( !v24 )
          {
            v10 = v22;
            if ( v22 < 15 )
            {
              v12 = v23;
              v26[v22] = v23;
              v11 = v10 + 1;
              v22 = v11;
              goto LABEL_17;
            }
            result = sub_10040324(ebp0, v20);
            v21 = result;
            if ( result )
              return result;
          }
          v13 = *(_DWORD *)(a2 + 56) == 1 && sub_1004026A(a2);
        }
        v25 |= v13;
      }
      v11 = v22;
      v12 = v23;
LABEL_17:
      v14 = v12 + 1;
      v23 = v14;
      if ( v14 >= v19 )
      {
        if ( v11 > 0 )
        {
          v15 = 0;
          v23 = 0;
          while ( 1 )
          {
            v16 = sub_100318B8(v5 + 88, v26[v15]);
            a2 = v16;
            if ( v16 )
            {
              if ( !sub_1004026A(v16) )
              {
                result = sub_10040324(ebp0, v20);
                v21 = result;
                if ( result )
                  return result;
              }
              v17 = *(_DWORD *)(a2 + 56) == 1 && sub_1004026A(a2);
              v25 |= v17;
            }
            v15 = v23 + 1;
            v23 = v15;
            if ( v15 >= v22 )
              goto LABEL_30;
          }
        }
        break;
      }
      v7 = v14;
    }
  }
LABEL_30:
  if ( sub_10040DC7(v5 + 52, a2, (int)&v21) )
  {
    sub_1003FB01(v21, 1);
    result = v21;
  }
  else
  {
    if ( *(_DWORD *)(v5 + 232) > 0 )
    {
      if ( v25 )
      {
        if ( *(_DWORD *)(v5 + 152) > 0 )
        {
          do
          {
            v18 = sub_100318B8(v5 + 88, v3);
            if ( v18 )
            {
              if ( *(_DWORD *)(v18 + 56) == 1 )
              {
                if ( *(_DWORD *)(v18 + 80) <= *(_DWORD *)(v18 + 76) )
                  sub_1004146E(v5, v18);
              }
            }
            ++v3;
          }
          while ( v3 < *(_DWORD *)(v5 + 152) );
        }
      }
    }
    result = 0;
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10041636: using guessed type int var_44[16];

//----- (100417E5) --------------------------------------------------------
void __userpurge sub_100417E5(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, LPVOID lpMem)
{
  int v5; // ST04_4@3
  int v6; // ST04_4@5
  int v7; // ST04_4@7
  int v8; // ST04_4@9
  int v9; // ST04_4@11
  int v10; // ST04_4@13
  int v11; // ST04_4@15
  int v12; // ST04_4@17
  void *v13; // edi@18

  if ( lpMem )
  {
    if ( *((_DWORD *)lpMem + 9) )
    {
      sub_100309C2(a3, *((LPVOID *)lpMem + 9));
      a2 = v5;
    }
    if ( *((_DWORD *)lpMem + 11) )
    {
      sub_100309C2(a3, *((LPVOID *)lpMem + 11));
      a2 = v6;
    }
    if ( *((_DWORD *)lpMem + 13) )
    {
      sub_100309C2(a3, *((LPVOID *)lpMem + 13));
      a2 = v7;
    }
    if ( *((_DWORD *)lpMem + 15) )
    {
      sub_100309C2(a3, *((LPVOID *)lpMem + 15));
      a2 = v8;
    }
    if ( *((_DWORD *)lpMem + 16) )
    {
      sub_100309C2(a3, *((LPVOID *)lpMem + 16));
      a2 = v9;
    }
    if ( *((_DWORD *)lpMem + 17) )
    {
      sub_100309C2(a3, *((LPVOID *)lpMem + 17));
      a2 = v10;
    }
    if ( *((_DWORD *)lpMem + 18) )
    {
      sub_100309C2(a3, *((LPVOID *)lpMem + 18));
      a2 = v11;
    }
    if ( *((_UNKNOWN **)lpMem + 23) != &unk_10064F48 )
    {
      sub_100309C2(a3, *((LPVOID *)lpMem + 23));
      a2 = v12;
    }
    sub_10036A23(a1, a2, a3, a4, 13);
    v13 = (void *)*((_DWORD *)lpMem + 26);
    if ( v13 )
    {
      if ( !InterlockedDecrement(*((volatile LONG **)lpMem + 26)) )
      {
        if ( v13 != &unk_100737B8 )
          sub_100309C2(a3, v13);
      }
    }
    sub_10036B87(13);
  }
}

//----- (1004191C) --------------------------------------------------------
void __usercall sub_1004191C(int a1<ebx>, int a2<edi>, LPVOID lpMem)
{
  DWORD v3; // eax@1
  void *v4; // esi@2
  int v5; // edx@4
  int v6; // ST04_4@4

  v3 = dword_100734B0;
  if ( dword_100734B0 != -1 )
  {
    v4 = lpMem;
    if ( !lpMem )
    {
      v4 = sub_100394C9(dword_100734B0);
      v3 = dword_100734B0;
    }
    sub_100394E8(v3, 0);
    sub_100417E5(v5, v6, a1, a2, v4);
  }
}
// 100734B0: using guessed type int dword_100734B0;

//----- (10041952) --------------------------------------------------------
int __usercall sub_10041952<eax>(int a1<ebx>, int a2<edi>)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // esi@1

  v4 = sub_1004196A(a1);
  if ( !v4 )
    sub_1003AF82(v2, v3, a1, a2, 16);
  return v4;
}

//----- (1004196A) --------------------------------------------------------
int __usercall sub_1004196A<eax>(int a1<ebx>)
{
  DWORD v1; // edi@1
  int v2; // esi@1
  void *v3; // eax@2
  int v4; // edx@3
  DWORD v5; // eax@4
  int v7; // [sp-4h] [bp-Ch]@1
  int v8; // [sp-4h] [bp-Ch]@3

  v1 = GetLastError();
  v2 = (int)sub_100394C9(dword_100734B0);
  if ( !v2 )
  {
    v3 = sub_100374E6(v7, a1, 1u, 0x3BCu);
    v2 = (int)v3;
    if ( v3 )
    {
      if ( sub_100394E8(dword_100734B0, v3) )
      {
        sub_100419D9(v4, v8, a1, v2);
        v5 = GetCurrentThreadId();
        *(_DWORD *)(v2 + 4) = -1;
        *(_DWORD *)v2 = v5;
      }
      else
      {
        sub_100309C2(a1, (LPVOID)v2);
        v2 = 0;
      }
    }
  }
  SetLastError(v1);
  return v2;
}
// 100734B0: using guessed type int dword_100734B0;

//----- (100419D9) --------------------------------------------------------
void __usercall sub_100419D9(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  *(_DWORD *)(a4 + 92) = &unk_10064F48;
  *(_DWORD *)(a4 + 8) = 0;
  *(_DWORD *)(a4 + 20) = 1;
  *(_DWORD *)(a4 + 112) = 1;
  *(_WORD *)(a4 + 184) = 67;
  *(_WORD *)(a4 + 446) = 67;
  *(_DWORD *)(a4 + 104) = &unk_100737B8;
  *(_DWORD *)(a4 + 952) = 0;
  sub_10036A23(a1, a2, a3, 1, 13);
  InterlockedIncrement(*(volatile LONG **)(a4 + 104));
  sub_10036B87(13);
}

//----- (10041A8C) --------------------------------------------------------
signed int __usercall sub_10041A8C<eax>(int a1<ebx>)
{
  signed int result; // eax@2
  void *v2; // eax@4
  int v3; // esi@4
  int v4; // edx@5
  DWORD v5; // eax@6
  int v6; // [sp-8h] [bp-8h]@5
  int v7; // [sp-4h] [bp-4h]@3

  sub_1003B053();
  if ( sub_10036B52() && (dword_100734B0 = sub_1003948C((int)sub_100417E5), dword_100734B0 != -1) )
  {
    v2 = sub_100374E6(v7, a1, 1u, 0x3BCu);
    v3 = (int)v2;
    if ( v2 && sub_100394E8(dword_100734B0, v2) )
    {
      sub_100419D9(v4, v6, a1, v3);
      v5 = GetCurrentThreadId();
      *(_DWORD *)(v3 + 4) = -1;
      *(_DWORD *)v3 = v5;
      result = 1;
    }
    else
    {
      sub_10041B02();
      result = 0;
    }
  }
  else
  {
    sub_10041B02();
    result = 0;
  }
  return result;
}
// 100734B0: using guessed type int dword_100734B0;

//----- (10041B02) --------------------------------------------------------
void __cdecl sub_10041B02()
{
  signed int v0; // edi@3
  signed int v1; // esi@3
  LPCRITICAL_SECTION v2; // ebx@4

  if ( dword_100734B0 != -1 )
  {
    sub_100394AA(dword_100734B0);
    dword_100734B0 = -1;
  }
  v1 = (signed int)&lpCriticalSection;
  v0 = (signed int)&lpCriticalSection;
  do
  {
    v2 = *(LPCRITICAL_SECTION *)v0;
    if ( *(_DWORD *)v0 )
    {
      if ( *(_DWORD *)(v0 + 4) != 1 )
      {
        DeleteCriticalSection(*(LPCRITICAL_SECTION *)v0);
        sub_100309C2((int)v2, v2);
        *(_DWORD *)v0 = 0;
      }
    }
    v0 += 8;
  }
  while ( v0 < (signed int)&off_10073080 );
  do
  {
    if ( *(_DWORD *)v1 )
    {
      if ( *(_DWORD *)(v1 + 4) == 1 )
        DeleteCriticalSection(*(LPCRITICAL_SECTION *)v1);
    }
    v1 += 8;
  }
  while ( v1 < (signed int)&off_10073080 );
}
// 10073080: using guessed type wchar_t *off_10073080;
// 100734B0: using guessed type int dword_100734B0;

//----- (10041B1F) --------------------------------------------------------
LONG __cdecl sub_10041B1F(volatile LONG *lpAddend)
{
  volatile LONG *v1; // edi@1
  signed int v2; // eax@9
  volatile LONG **v3; // ebx@9
  signed int v5; // [sp+14h] [bp+8h]@9

  v1 = lpAddend;
  InterlockedIncrement(lpAddend);
  if ( lpAddend[30] )
    InterlockedIncrement((volatile LONG *)lpAddend[30]);
  if ( lpAddend[32] )
    InterlockedIncrement((volatile LONG *)lpAddend[32]);
  if ( lpAddend[31] )
    InterlockedIncrement((volatile LONG *)lpAddend[31]);
  if ( lpAddend[34] )
    InterlockedIncrement((volatile LONG *)lpAddend[34]);
  v2 = 6;
  v3 = (volatile LONG **)(lpAddend + 7);
  v5 = 6;
  do
  {
    if ( (_UNKNOWN *)*(v3 - 2) != &unk_100739D8 )
    {
      if ( *v3 )
      {
        InterlockedIncrement(*v3);
        v2 = v5;
      }
    }
    if ( *(v3 - 3) )
    {
      if ( *(v3 - 1) )
      {
        InterlockedIncrement(*(v3 - 1));
        v2 = v5;
      }
    }
    v3 += 4;
    --v2;
    v5 = v2;
  }
  while ( v2 );
  return InterlockedIncrement((volatile LONG *)(v1[39] + 176));
}

//----- (10041BAF) --------------------------------------------------------
void __cdecl sub_10041BAF(LPVOID lpMem)
{
  void **v1; // eax@1
  void *v2; // esi@1
  int v3; // eax@3
  int v4; // eax@5
  int v5; // eax@8
  int v6; // eax@12
  int v7; // eax@15
  signed int v8; // eax@18
  int v9; // ebx@18
  LPVOID *v10; // edi@18
  int v11; // eax@25
  signed int v12; // [sp+14h] [bp+8h]@18

  v2 = lpMem;
  v1 = (void **)*((_DWORD *)lpMem + 33);
  if ( v1 )
  {
    if ( v1 != &off_10072C58 )
    {
      v3 = *((_DWORD *)lpMem + 30);
      if ( v3 )
      {
        if ( !*(_DWORD *)v3 )
        {
          v4 = *((_DWORD *)lpMem + 32);
          if ( v4 )
          {
            if ( !*(_DWORD *)v4 )
            {
              sub_100309C2(0, *((LPVOID *)lpMem + 32));
              sub_1004D798(0, *((_DWORD *)lpMem + 33));
            }
          }
          v5 = *((_DWORD *)lpMem + 31);
          if ( v5 )
          {
            if ( !*(_DWORD *)v5 )
            {
              sub_100309C2(0, *((LPVOID *)lpMem + 31));
              sub_1004DC36(0, *((_DWORD *)lpMem + 33));
            }
          }
          sub_100309C2(0, *((LPVOID *)lpMem + 30));
          sub_100309C2(0, *((LPVOID *)lpMem + 33));
        }
      }
    }
  }
  v6 = *((_DWORD *)lpMem + 34);
  if ( v6 )
  {
    if ( !*(_DWORD *)v6 )
    {
      sub_100309C2(0, (LPVOID)(*((_DWORD *)lpMem + 35) - 254));
      sub_100309C2(0, (LPVOID)(*((_DWORD *)lpMem + 37) - 128));
      sub_100309C2(0, (LPVOID)(*((_DWORD *)lpMem + 38) - 128));
      sub_100309C2(0, *((LPVOID *)lpMem + 34));
    }
  }
  v7 = *((_DWORD *)lpMem + 39);
  if ( (void **)v7 != &off_100739E0 )
  {
    if ( !*(_DWORD *)(v7 + 176) )
    {
      sub_1004DEA5(0, *((_DWORD *)lpMem + 39));
      sub_100309C2(0, *((LPVOID *)lpMem + 39));
    }
  }
  v8 = 6;
  v9 = (int)((char *)lpMem + 160);
  v10 = (LPVOID *)((char *)lpMem + 28);
  v12 = 6;
  do
  {
    if ( *(v10 - 2) != &unk_100739D8 )
    {
      if ( *v10 )
      {
        if ( !*(_DWORD *)*v10 )
        {
          sub_100309C2(v9, *v10);
          sub_100309C2(v9, *(LPVOID *)v9);
        }
      }
      v8 = v12;
    }
    if ( *(v10 - 3) )
    {
      v11 = (int)*(v10 - 1);
      if ( v11 )
      {
        if ( !*(_DWORD *)v11 )
          sub_100309C2(v9, *(v10 - 1));
      }
      v8 = v12;
    }
    v9 += 4;
    v10 += 4;
    --v8;
    v12 = v8;
  }
  while ( v8 );
  sub_100309C2(v9, v2);
}
// 10072C58: using guessed type void *off_10072C58;
// 100739E0: using guessed type void *off_100739E0;

//----- (10041D09) --------------------------------------------------------
volatile LONG *__cdecl sub_10041D09(volatile LONG *lpAddend)
{
  volatile LONG *v1; // esi@1
  signed int v2; // eax@10
  volatile LONG **v3; // ebx@10
  signed int v5; // [sp+Ch] [bp+8h]@10

  v1 = lpAddend;
  if ( lpAddend )
  {
    InterlockedDecrement(lpAddend);
    if ( lpAddend[30] )
      InterlockedDecrement((volatile LONG *)lpAddend[30]);
    if ( lpAddend[32] )
      InterlockedDecrement((volatile LONG *)lpAddend[32]);
    if ( lpAddend[31] )
      InterlockedDecrement((volatile LONG *)lpAddend[31]);
    if ( lpAddend[34] )
      InterlockedDecrement((volatile LONG *)lpAddend[34]);
    v2 = 6;
    v3 = (volatile LONG **)(lpAddend + 7);
    v5 = 6;
    do
    {
      if ( (_UNKNOWN *)*(v3 - 2) != &unk_100739D8 )
      {
        if ( *v3 )
        {
          InterlockedDecrement(*v3);
          v2 = v5;
        }
      }
      if ( *(v3 - 3) )
      {
        if ( *(v3 - 1) )
        {
          InterlockedDecrement(*(v3 - 1));
          v2 = v5;
        }
      }
      v3 += 4;
      --v2;
      v5 = v2;
    }
    while ( v2 );
    InterlockedDecrement((volatile LONG *)(v1[39] + 176));
  }
  return v1;
}

//----- (10041DA4) --------------------------------------------------------
void __usercall sub_10041DA4(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // edx@1
  int v4; // esi@1
  int v5; // edx@3
  int v6; // ecx@3

  v2 = sub_10041952(a1, a2);
  v4 = v2;
  if ( dword_10073C0C & *(_DWORD *)(v2 + 112) && *(_DWORD *)(v2 + 108) )
  {
    if ( !*(_DWORD *)(sub_10041952(a1, a2) + 108) )
      sub_1003AF82(v5, v6, a1, a2, 32);
  }
  else
  {
    sub_10036A23(v3, dword_10073C0C, a1, a2, 12);
    sub_10041E20((volatile LONG **)(v4 + 108), off_10073B44);
    sub_10036B87(12);
  }
}
// 10073C0C: using guessed type int dword_10073C0C;

//----- (10041E20) --------------------------------------------------------
volatile LONG *__cdecl sub_10041E20(volatile LONG **a1, volatile LONG *lpAddend)
{
  volatile LONG *v2; // esi@3
  volatile LONG *result; // eax@8

  if ( lpAddend && a1 )
  {
    v2 = *a1;
    if ( *a1 != lpAddend )
    {
      *a1 = lpAddend;
      sub_10041B1F(lpAddend);
      if ( v2 )
      {
        sub_10041D09(v2);
        if ( !*v2 )
        {
          if ( v2 != &dword_10073B48 )
            sub_10041BAF(v2);
        }
      }
    }
    result = lpAddend;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10041E6B) --------------------------------------------------------
int __usercall sub_10041E6B<eax>(int a1<ebx>)
{
  if ( !dword_100778D0 )
  {
    sub_100421CB(a1, 0xFFFFFFFDu);
    dword_100778D0 = 1;
  }
  return 0;
}
// 100778D0: using guessed type int dword_100778D0;

//----- (10041E89) --------------------------------------------------------
wchar_t *__cdecl sub_10041E89(int a1)
{
  wchar_t *result; // eax@5

  switch ( a1 )
  {
    case 932:
      result = off_100646E4[0];
      break;
    case 936:
      result = off_100646E8[0];
      break;
    case 949:
      result = off_100646EC[0];
      break;
    case 950:
      result = off_100646F0;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}
// 100646E4: using guessed type wchar_t *off_100646E4[4];
// 100646E8: using guessed type wchar_t *off_100646E8[3];
// 100646EC: using guessed type wchar_t *off_100646EC[2];
// 100646F0: using guessed type wchar_t *off_100646F0;

//----- (10041EC3) --------------------------------------------------------
UINT __usercall sub_10041EC3<eax>(int a1<ebx>, int a2<edi>, UINT a3)
{
  UINT result; // eax@1
  int v4; // [sp+0h] [bp-10h]@1
  int v5; // [sp+8h] [bp-8h]@8
  char v6; // [sp+Ch] [bp-4h]@7

  sub_100301AD((int)&v4, a1, a2, 0);
  result = a3;
  dword_10075F24 = 0;
  switch ( a3 )
  {
    case 0xFFFFFFFEu:
      dword_10075F24 = 1;
      result = GetOEMCP();
      break;
    case 0xFFFFFFFDu:
      dword_10075F24 = 1;
      result = GetACP();
      break;
    case 0xFFFFFFFCu:
      dword_10075F24 = 1;
      result = *(_DWORD *)(v4 + 4);
      break;
  }
  if ( v6 )
    *(_DWORD *)(v5 + 112) &= 0xFFFFFFFDu;
  return result;
}
// 10075F24: using guessed type int dword_10075F24;

//----- (10041F2F) --------------------------------------------------------
int __cdecl sub_10041F2F(int a1)
{
  int result; // eax@1
  signed int v2; // ecx@1
  char *v3; // edi@1
  int v4; // esi@1
  signed int v5; // edx@3
  int v6; // ecx@3

  v4 = a1 + 24;
  sub_100391F0((void *)(a1 + 24), 0, 257);
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 540) = 0;
  result = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  v3 = (char *)&unk_100737B8 - a1;
  v2 = 257;
  do
  {
    *(_BYTE *)v4 = v3[v4];
    ++v4;
    --v2;
  }
  while ( v2 );
  v6 = a1 + 281;
  v5 = 256;
  do
  {
    LOBYTE(result) = v3[v6];
    *(_BYTE *)v6++ = result;
    --v5;
  }
  while ( v5 );
  return result;
}

//----- (10041F98) --------------------------------------------------------
char __cdecl sub_10041F98(int a1)
{
  unsigned int v1; // eax@2
  unsigned int i; // eax@4
  char *v3; // ecx@4
  unsigned int v4; // edx@5
  unsigned int v5; // ecx@11
  int v6; // eax@12
  int v7; // edx@20
  unsigned int v8; // ecx@20
  int v9; // edx@21
  int v10; // eax@22
  struct _cpinfo CPInfo; // [sp+14h] [bp-518h]@1
  WORD CharType[256]; // [sp+28h] [bp-504h]@11
  char v14[256]; // [sp+228h] [bp-304h]@11
  _BYTE DestStr[256]; // [sp+328h] [bp-204h]@11
  const CHAR MultiByteStr[256]; // [sp+428h] [bp-104h]@3
  unsigned int v17; // [sp+528h] [bp-4h]@1
  int v18; // [sp+52Ch] [bp+0h]@1

  v17 = (unsigned int)&v18 ^ __security_cookie;
  if ( GetCPInfo(*(_DWORD *)(a1 + 4), &CPInfo) )
  {
    v1 = 0;
    do
    {
      MultiByteStr[v1] = v1;
      ++v1;
    }
    while ( v1 < 0x100 );
    LOBYTE(i) = CPInfo.LeadByte[0];
    MultiByteStr[0] = 32;
    v3 = (char *)CPInfo.LeadByte;
    while ( (_BYTE)i )
    {
      v4 = (unsigned __int8)v3[1];
      for ( i = (unsigned __int8)i; i <= v4 && i < 0x100; ++i )
        MultiByteStr[i] = 32;
      v3 += 2;
      LOBYTE(i) = *v3;
    }
    sub_10049218(0, 256, 0, 1u, MultiByteStr, 256, CharType, *(_DWORD *)(a1 + 4), 0);
    sub_100374A2(
      0,
      256,
      0,
      *(_DWORD *)(a1 + 540),
      0x100u,
      MultiByteStr,
      256,
      (LPWSTR)DestStr,
      256,
      *(_DWORD *)(a1 + 4),
      0);
    sub_100374A2(0, 256, 0, *(_DWORD *)(a1 + 540), 0x200u, MultiByteStr, 256, (LPWSTR)v14, 256, *(_DWORD *)(a1 + 4), 0);
    v5 = 0;
    while ( 1 )
    {
      LOWORD(v6) = CharType[v5];
      if ( v6 & 1 )
      {
        *(_BYTE *)(a1 + v5 + 25) |= 0x10u;
        LOBYTE(v6) = DestStr[v5];
      }
      else
      {
        if ( !(v6 & 2) )
        {
          *(_BYTE *)(a1 + v5 + 281) = 0;
          goto LABEL_18;
        }
        *(_BYTE *)(a1 + v5 + 25) |= 0x20u;
        LOBYTE(v6) = v14[v5];
      }
      *(_BYTE *)(a1 + v5 + 281) = v6;
LABEL_18:
      ++v5;
      if ( v5 >= 0x100 )
        return v6;
    }
  }
  v7 = a1 + 281;
  v6 = -97 - (a1 + 281);
  v8 = 0;
  do
  {
    v9 = v8 + v7;
    if ( (unsigned int)(v9 + v6 + 32) <= 0x19 )
    {
      *(_BYTE *)(a1 + v8 + 25) |= 0x10u;
      v10 = v8 + 32;
LABEL_25:
      *(_BYTE *)v9 = v10;
      goto LABEL_27;
    }
    if ( (unsigned int)(v9 + v6) <= 0x19 )
    {
      *(_BYTE *)(a1 + v8 + 25) |= 0x20u;
      v10 = v8 - 32;
      goto LABEL_25;
    }
    *(_BYTE *)v9 = 0;
LABEL_27:
    v6 = -97 - (a1 + 281);
    ++v8;
    v7 = a1 + 281;
  }
  while ( v8 < 0x100 );
  return v6;
}
// 10073200: using guessed type int __security_cookie;
// 10041F98: using guessed type const CHAR MultiByteStr[256];
// 10041F98: using guessed type WORD CharType[256];
// 10041F98: using guessed type char var_304[256];

//----- (10042126) --------------------------------------------------------
void __usercall sub_10042126(int a1<ebx>, int a2<edi>)
{
  int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  void *v5; // esi@6

  v2 = sub_10041952(a1, a2);
  v4 = v2;
  if ( dword_10073C0C & *(_DWORD *)(v2 + 112) && *(_DWORD *)(v2 + 108) )
  {
    if ( !*(_DWORD *)(v2 + 104) )
      sub_1003AF82(v3, dword_10073C0C, a1, v2, 32);
  }
  else
  {
    sub_10036A23(v3, dword_10073C0C, a1, v2, 13);
    v5 = *(void **)(v4 + 104);
    if ( v5 != lpAddend )
    {
      if ( v5 )
      {
        if ( !InterlockedDecrement((volatile LONG *)v5) )
        {
          if ( v5 != &unk_100737B8 )
            sub_100309C2(a1, v5);
        }
      }
      *(_DWORD *)(v4 + 104) = lpAddend;
      InterlockedIncrement((volatile LONG *)lpAddend);
    }
    sub_10036B87(13);
  }
}
// 10073C0C: using guessed type int dword_10073C0C;

//----- (100421CB) --------------------------------------------------------
void __usercall sub_100421CB(int a1<ebx>, UINT a2)
{
  int v2; // edx@1
  int v3; // ebx@1
  int v4; // esi@1
  int v5; // eax@2
  int v6; // ebx@2
  signed int v7; // eax@3
  int v8; // edi@3
  signed int v9; // esi@3
  int v10; // eax@4
  char v11; // zf@4
  int v12; // edx@7
  int v13; // ecx@7
  signed int i; // ecx@9
  signed int j; // ecx@12
  int v16; // [sp-4h] [bp-34h]@1
  int v17; // [sp+14h] [bp-1Ch]@1
  UINT v18; // [sp+38h] [bp+8h]@1

  v3 = sub_10041952(a1, -1);
  v17 = v3;
  sub_10042126(v3, -1);
  v4 = *(_DWORD *)(v3 + 104);
  v18 = sub_10041EC3(v3, -1, a2);
  if ( v18 != *(_DWORD *)(v4 + 4) )
  {
    v5 = sub_10037530(v2, v16, v3, 544);
    v6 = v5;
    if ( v5 )
    {
      memcpy((void *)v5, *(const void **)(v17 + 104), 0x220u);
      v9 = 0;
      *(_DWORD *)v5 = 0;
      v7 = sub_10042379(v5, v5 + 544, v18, v5);
      v8 = v7;
      if ( v7 )
      {
        if ( v7 == -1 )
        {
          if ( (_UNKNOWN *)v6 != &unk_100737B8 )
            sub_100309C2(v6, (LPVOID)v6);
          *(_DWORD *)sub_10037649(v6) = 22;
        }
      }
      else
      {
        v11 = InterlockedDecrement(*(volatile LONG **)(v17 + 104)) == 0;
        v10 = v17;
        if ( v11 )
        {
          if ( *(_UNKNOWN **)(v17 + 104) != &unk_100737B8 )
          {
            sub_100309C2(v6, *(LPVOID *)(v17 + 104));
            v10 = v17;
          }
        }
        *(_DWORD *)(v10 + 104) = v6;
        InterlockedIncrement((volatile LONG *)v6);
        if ( !(*(_BYTE *)(v17 + 112) & 2) )
        {
          if ( !(dword_10073C0C & 1) )
          {
            sub_10036A23(v12, v13, v6, v8, 13);
            dword_10075F10 = *(_DWORD *)(v6 + 4);
            dword_10075F14 = *(_DWORD *)(v6 + 8);
            dword_10075F0C = *(_DWORD *)(v6 + 540);
            for ( i = 0; i < 5; ++i )
              word_10075F18[i] = *(_WORD *)(v6 + 2 * i + 12);
            for ( j = 0; j < 257; ++j )
              byte_100735B0[j] = *(_BYTE *)(j + v6 + 24);
            while ( v9 < 256 )
            {
              byte_100736B8[v9] = *(_BYTE *)(v9 + v6 + 281);
              ++v9;
            }
            if ( !InterlockedDecrement((volatile LONG *)lpAddend) )
            {
              if ( lpAddend != &unk_100737B8 )
                sub_100309C2(v6, lpAddend);
            }
            lpAddend = (LPVOID)v6;
            InterlockedIncrement((volatile LONG *)v6);
            sub_10036B87(13);
          }
        }
      }
    }
  }
}
// 10073C0C: using guessed type int dword_10073C0C;
// 10075F0C: using guessed type int dword_10075F0C;
// 10075F10: using guessed type int dword_10075F10;
// 10075F14: using guessed type int dword_10075F14;
// 10075F18: using guessed type __int16 word_10075F18[];

//----- (10042379) --------------------------------------------------------
signed int __usercall sub_10042379<eax>(int a1<ebx>, int a2<edi>, UINT a3, int a4)
{
  UINT v4; // ebx@1
  signed int result; // eax@2
  unsigned int v6; // eax@3
  int v7; // ecx@3
  unsigned int v8; // edi@3
  char *v9; // eax@11
  unsigned int v10; // edx@12
  unsigned int v11; // ecx@13
  int v12; // eax@17
  signed int v13; // ecx@17
  char *v14; // eax@25
  char *v15; // ecx@26
  unsigned int v16; // eax@27
  unsigned int v17; // ebx@28
  char *v18; // edx@35
  int v19; // ecx@35
  signed int v20; // edi@35
  int v21; // edx@35
  int v22; // [sp+8h] [bp-20h]@1
  int v23; // [sp+Ch] [bp-1Ch]@3
  char *v24; // [sp+Ch] [bp-1Ch]@25
  struct _cpinfo CPInfo; // [sp+10h] [bp-18h]@9
  unsigned int v26; // [sp+24h] [bp-4h]@1
  int v27; // [sp+28h] [bp+0h]@1

  v26 = (unsigned int)&v27 ^ __security_cookie;
  v4 = sub_10041EC3(a1, a2, a3);
  v22 = v4;
  if ( v4 )
  {
    v8 = 0;
    v7 = 0;
    v23 = 0;
    v6 = 0;
    while ( *(int *)((char *)&dword_100734C0 + v6) != v4 )
    {
      ++v7;
      v6 += 48;
      v23 = v7;
      if ( v6 >= 0xF0 )
      {
        if ( v4 == 65000 || v4 == 65001 || !IsValidCodePage((unsigned __int16)v4) )
          return -1;
        if ( GetCPInfo(v4, &CPInfo) )
        {
          sub_100391F0((void *)(a4 + 24), 0, 257);
          *(_DWORD *)(a4 + 4) = v4;
          *(_DWORD *)(a4 + 540) = 0;
          if ( (_DWORD)CPInfo.MaxCharSize <= 1u )
          {
            *(_DWORD *)(a4 + 8) = 0;
          }
          else
          {
            v9 = (char *)CPInfo.LeadByte;
            if ( CPInfo.LeadByte[0] )
            {
              do
              {
                LOBYTE(v10) = v9[1];
                if ( !(_BYTE)v10 )
                  break;
                v11 = (unsigned __int8)*v9;
                v10 = (unsigned __int8)v10;
                while ( v11 <= v10 )
                  *(_BYTE *)(a4 + v11++ + 25) |= 4u;
                v9 += 2;
              }
              while ( *v9 );
            }
            v12 = a4 + 26;
            v13 = 254;
            do
            {
              *(_BYTE *)v12++ |= 8u;
              --v13;
            }
            while ( v13 );
            *(_DWORD *)(a4 + 540) = sub_10041E89(*(_DWORD *)(a4 + 4));
            *(_DWORD *)(a4 + 8) = 1;
          }
          *(_DWORD *)(a4 + 12) = 0;
          *(_DWORD *)(a4 + 16) = 0;
          *(_DWORD *)(a4 + 20) = 0;
          goto LABEL_37;
        }
        if ( !dword_10075F24 )
          return -1;
        sub_10041F2F(a4);
        goto LABEL_38;
      }
    }
    sub_100391F0((void *)(a4 + 24), 0, 257);
    v14 = &aJ[48 * v23];
    v24 = &aJ[48 * v23];
    do
    {
      v15 = v14;
      if ( *v14 )
      {
        do
        {
          LOBYTE(v16) = v15[1];
          if ( !(_BYTE)v16 )
            break;
          v17 = (unsigned __int8)*v15;
          v16 = (unsigned __int8)v16;
          while ( v17 <= v16 && v17 < 0x100 )
          {
            *(_BYTE *)(a4 + v17 + 25) |= byte_100734BC[v8];
            v16 = (unsigned __int8)v15[1];
            ++v17;
          }
          v15 += 2;
        }
        while ( *v15 );
        v14 = v24;
      }
      ++v8;
      v14 += 8;
      v24 = v14;
    }
    while ( v8 < 4 );
    *(_DWORD *)(a4 + 4) = v22;
    *(_DWORD *)(a4 + 8) = 1;
    *(_DWORD *)(a4 + 540) = sub_10041E89(v22);
    v19 = a4 + 12;
    v18 = &aVyv[v21];
    v20 = 6;
    do
    {
      *(_WORD *)v19 = *(_WORD *)v18;
      v18 += 2;
      v19 += 2;
      --v20;
    }
    while ( v20 );
LABEL_37:
    sub_10041F98(a4);
LABEL_38:
    result = 0;
  }
  else
  {
    sub_10041F2F(a4);
    result = 0;
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 100734C0: using guessed type int dword_100734C0;
// 10075F24: using guessed type int dword_10075F24;

//----- (1004256E) --------------------------------------------------------
int __usercall sub_1004256E<eax>(int a1<ebx>, int a2<edi>, signed int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // eax@2
  int v7; // ecx@4
  int result; // eax@9
  int v9; // [sp+4h] [bp-18h]@1
  int v10; // [sp+Ch] [bp-10h]@8
  char v11; // [sp+10h] [bp-Ch]@7
  const CHAR MultiByteStr; // [sp+14h] [bp-8h]@4
  char v13; // [sp+15h] [bp-7h]@4
  char v14; // [sp+16h] [bp-6h]@4
  WORD CharType; // [sp+18h] [bp-4h]@6
  signed int v16; // [sp+24h] [bp+8h]@3

  sub_100301AD((int)&v9, a1, a2, a5);
  v5 = a3;
  if ( (unsigned int)(a3 + 1) <= 0x100 )
  {
    v6 = *(_WORD *)(*(_DWORD *)(v9 + 144) + 2 * a3);
    goto LABEL_11;
  }
  v16 = a3 >> 8;
  if ( sub_1004261D(v5, a2, BYTE1(v5), (int)&v9) )
  {
    MultiByteStr = v16;
    v13 = v5;
    v14 = 0;
    v7 = 2;
  }
  else
  {
    MultiByteStr = v5;
    v13 = 0;
    v7 = 1;
  }
  if ( sub_10049218(v5, a2, (int)&v9, 1u, &MultiByteStr, v7, &CharType, *(_DWORD *)(v9 + 4), 1) )
  {
    v6 = CharType;
LABEL_11:
    result = a4 & v6;
    if ( v11 )
      *(_DWORD *)(v10 + 112) &= 0xFFFFFFFDu;
    return result;
  }
  if ( v11 )
    *(_DWORD *)(v10 + 112) &= 0xFFFFFFFDu;
  return 0;
}

//----- (1004261D) --------------------------------------------------------
int __usercall sub_1004261D<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3, int a4)
{
  int result; // eax@1
  int v5; // [sp+0h] [bp-10h]@1
  int v6; // [sp+8h] [bp-8h]@2
  char v7; // [sp+Ch] [bp-4h]@1

  sub_100301AD((int)&v5, a1, a2, a4);
  result = *(_WORD *)(*(_DWORD *)(v5 + 144) + 2 * a3) & 0x8000;
  if ( v7 )
    *(_DWORD *)(v6 + 112) &= 0xFFFFFFFDu;
  return result;
}

//----- (10042653) --------------------------------------------------------
int __usercall sub_10042653<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3)
{
  return sub_1004261D(a1, a2, a3, 0);
}

//----- (10042664) --------------------------------------------------------
void __usercall sub_10042664(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  if ( off_10073B44 != &dword_10073B48 )
  {
    sub_10036A23(a1, a2, a3, a4, 12);
    off_10073B44 = sub_10041E20(&off_10073B44, &dword_10073B48);
    sub_10036B87(12);
  }
}

//----- (100426B6) --------------------------------------------------------
int __cdecl sub_100426B6(int a1)
{
  int result; // eax@2
  int v2; // edx@3
  int v3; // ebx@3
  int v4; // edi@5
  int v5; // [sp-8h] [bp-8h]@3

  if ( a1 )
  {
    v3 = sub_1004AC57(a1, 0x55u);
    if ( (unsigned int)v3 < 0x55 )
    {
      result = sub_10037530(v2, v5, v3, 2 * v3 + 2);
      v4 = result;
      if ( result )
      {
        if ( sub_1004498F(v3, result, result, v3 + 1, a1, v3 + 1) )
        {
          sub_1003A161(v3, v4);
          __asm { int     3               ; Trap to Debugger }
          JUMPOUT(*(int *)sub_1004271A);
        }
        result = v4;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004271A) --------------------------------------------------------
void __usercall sub_1004271A(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6)
{
  int v6; // edx@1
  int v7; // ecx@1

  if ( sub_100490D0(a1, a2, a3, a6, a4, a5, a6) )
  {
    sub_1003A161(a3, a6);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10042788);
  }
  if ( *(_WORD *)(a6 + 128) )
    sub_10042BD3(v7, v6, a4, a5, 2);
  if ( *(_WORD *)(a6 + 256) )
    sub_10042BD3(v7, v6, a4, a5, 2);
}
// 10042788: using guessed type int __cdecl sub_10042788(int, int);

//----- (10042788) --------------------------------------------------------
signed int __cdecl sub_10042788(int a1, int a2)
{
  int v2; // ebx@1
  int v3; // esi@1
  int v5; // eax@8
  int v6; // eax@16
  int v7; // [sp-10h] [bp-20h]@12
  int v8; // [sp-Ch] [bp-1Ch]@12
  int v9; // [sp-8h] [bp-18h]@12
  int v10; // [sp-4h] [bp-14h]@12
  int v11; // [sp+Ch] [bp-4h]@9
  int i; // [sp+1Ch] [bp+Ch]@7

  v2 = 0;
  sub_100391F0((void *)a1, 0, 458);
  v3 = a2;
  if ( !*(_WORD *)a2 )
    return 0;
  if ( *(_WORD *)a2 == 46 && *(_WORD *)(a2 + 2) )
  {
    if ( sub_1004498F(0, a1, a1 + 256, 16, a2 + 2, 15) )
    {
LABEL_30:
      sub_1003A161(v2, a1);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_100428B2);
    }
    *(_WORD *)(a1 + 286) = 0;
    return 0;
  }
  for ( i = 0; ; ++i )
  {
    v5 = sub_1004EB25(v3, (int)L"_.,");
    if ( !v5 )
      break;
    v11 = v3 + 2 * v5;
    v2 = *(_WORD *)v11;
    if ( i )
    {
      if ( i == 1 )
      {
        if ( (unsigned int)v5 >= 0x40 || v2 == 95 )
          return -1;
        v10 = v5;
        v9 = v3;
        v8 = 64;
        v6 = a1 + 128;
      }
      else
      {
        if ( i != 2 || (unsigned int)v5 >= 0x10 || (_WORD)v2 && (_WORD)v2 != 44 )
          return -1;
        v10 = v5;
        v9 = v3;
        v8 = 16;
        v6 = a1 + 256;
      }
      v7 = v6;
    }
    else
    {
      if ( (unsigned int)v5 >= 0x40 || (_WORD)v2 == 46 )
        return -1;
      v10 = v5;
      v9 = v3;
      v8 = 64;
      v7 = a1;
    }
    if ( sub_1004498F(v2, a1, v7, v8, v9, v10) )
      goto LABEL_30;
    if ( (_WORD)v2 == 44 || !(_WORD)v2 )
      return 0;
    v3 = v11 + 2;
  }
  return -1;
}
// 10042788: using guessed type int __cdecl sub_10042788(int, int);
// 10064BA4: using guessed type wchar_t a__[4];

//----- (100428B2) --------------------------------------------------------
void __cdecl sub_100428B2(void *lpAddend, const void *a2)
{
  if ( a2 )
  {
    if ( lpAddend )
    {
      if ( lpAddend != a2 )
      {
        memcpy(lpAddend, a2, 0xB8u);
        *(_DWORD *)lpAddend = 0;
        sub_10041B1F((volatile LONG *)lpAddend);
      }
    }
  }
}

//----- (100428DE) --------------------------------------------------------
int __cdecl sub_100428DE(int a1, int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax@1
  int v7; // ebx@1
  int v8; // edi@1
  signed int v10; // eax@4
  int v11; // edx@4
  int v12; // ecx@4
  signed int v13; // eax@7
  int v14; // edx@12
  int v15; // ecx@12
  int v16; // eax@12
  int v17; // ST10_4@12
  int v18; // eax@13
  int v19; // ST10_4@13
  int v20; // edi@14
  char v21; // zf@15
  signed int v22; // eax@16
  int v24; // ecx@16
  int v25; // eax@20
  UINT v26; // eax@25
  int v27; // eax@41
  int v28; // [sp+14h] [bp-1E8h]@4
  int v29; // [sp+18h] [bp-1E4h]@11
  int v30; // [sp+1Ch] [bp-1E0h]@1
  UINT v31; // [sp+20h] [bp-1DCh]@1
  int v32; // [sp+24h] [bp-1D8h]@1
  int v33; // [sp+28h] [bp-1D4h]@1
  char v34; // [sp+2Ch] [bp-1D0h]@14
  char v35; // [sp+14Ch] [bp-B0h]@20
  unsigned int v36; // [sp+1F8h] [bp-4h]@1
  int v37; // [sp+1FCh] [bp+0h]@1

  v36 = (unsigned int)&v37 ^ __security_cookie;
  v7 = a4;
  v8 = a6;
  v6 = sub_10041952(a4, a6);
  v32 = v6 + 180;
  v30 = v6 + 184;
  v33 = v6 + 446;
  v31 = 0;
  if ( !a1 )
    return 0;
  v28 = v6 + 748;
  v10 = sub_1004498F(a4, a6, a4, a5, v6 + 748, 85);
  if ( v10 )
    goto LABEL_43;
  if ( *(_WORD *)a1 != 67 || *(_WORD *)(a1 + 2) != (_WORD)v10 )
  {
    v29 = sub_10039899(a1);
    if ( (unsigned int)v29 < 0x83 )
    {
      v16 = sub_1004EAE7(v33, a1);
      v15 = v17;
      if ( !v16 || (v18 = sub_1004EAE7(v30, a1), v15 = v19, !v18) )
      {
LABEL_37:
        if ( v8 )
          sub_10034EE0((void *)v8, (const void *)v32, 4u);
        v7 = v33;
        if ( !sub_100490D0(v14, v15, v33, v8, a2, a3, v33) )
          return v7;
LABEL_43:
        sub_1003A161(v7, v8);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_10042BD3);
      }
    }
    v20 = __security_cookie == dword_10077934 ? 1 : 0;
    if ( sub_10042788((int)&v34, a1) )
    {
      v8 = v32;
    }
    else
    {
      v21 = v20 == 0;
      v8 = v32;
      if ( v21 )
        v22 = sub_1004F16D(a4, v32, (int)&v34, v32, (int)&v34);
      else
        v22 = sub_1004F94D(a4, v32, (int)&v34, v32, (int)&v34);
      if ( v22 )
      {
        v8 = 131;
        sub_1004271A(v14, v24, a4, v33, 131, (int)&v34);
        if ( a4 )
        {
          v25 = sub_10039899((int)&v35);
          if ( sub_1004498F(a4, 131, a4, a5, (int)&v35, v25 + 1) )
            goto LABEL_43;
        }
LABEL_31:
        v7 = 0;
        if ( *(_WORD *)a1 && v29 < (unsigned int)v8 )
        {
          if ( sub_1004498F(0, v8, v30, v8, a1, v29 + 1) )
            goto LABEL_43;
        }
        else
        {
          v15 = 0;
          *(_WORD *)v30 = 0;
        }
        v8 = a6;
        goto LABEL_37;
      }
    }
    if ( !sub_10039CE8(a1) )
    {
      v27 = sub_10039899(a4);
      if ( !sub_1004498F(a4, v8, v28, 85, a4, v27 + 1) )
        return 0;
      goto LABEL_43;
    }
    if ( !sub_10039C8E(a1, 0x20001004u, (WCHAR *)&v31, 2) || (LOWORD(v26) = v31, !v31) )
    {
      v26 = GetACP();
      v31 = v26;
    }
    *(_DWORD *)v8 = (unsigned __int16)v26;
    v8 = v29 + 1;
    if ( sub_1004498F(a4, v29 + 1, v33, 131, a1, v29 + 1)
      || sub_1004498F(a4, v8, a4, a5, a1, v8)
      || sub_1004498F(a4, v8, v28, 85, a1, v8) )
      goto LABEL_43;
    v8 = 131;
    goto LABEL_31;
  }
  v13 = sub_100490D0(v11, v12, a4, a6, a2, a3, (int)L"C");
  if ( v13 )
    goto LABEL_43;
  if ( a6 )
    *(_DWORD *)a6 = v13;
  return a2;
}
// 10042788: using guessed type int __cdecl sub_10042788(int, int);
// 10064BA0: using guessed type wchar_t aC[2];
// 10073200: using guessed type int __security_cookie;
// 10077934: using guessed type int dword_10077934;

//----- (10042BD3) --------------------------------------------------------
void __fastcall sub_10042BD3(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  int *v6; // edi@2

  v5 = 0;
  if ( a5 > 0 )
  {
    v6 = &a5;
    do
    {
      ++v6;
      if ( sub_1004D31B(a2, a1, 0, a3, a4, *v6) )
      {
        sub_1003A161(0, (int)v6);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_10042C12);
      }
      ++v5;
    }
    while ( v5 < a5 );
  }
}

//----- (10042C12) --------------------------------------------------------
void __usercall sub_10042C12(int a1<edi>, unsigned int a2, int a3)
{
  int v3; // eax@3
  int v4; // edx@3
  void *v5; // edi@3
  int v6; // esi@3
  int v7; // ecx@3
  int v8; // [sp-4h] [bp-38h]@3

  if ( a2 <= 5 )
  {
    v6 = sub_10041952(0, a1);
    sub_10041DA4(0, a1);
    *(_DWORD *)(v6 + 112) |= 0x10u;
    v3 = (int)sub_100374E6(v7, 0, 0xB8u, 1u);
    v5 = (void *)v3;
    if ( v3 )
    {
      sub_10036A23(v4, v8, 0, v3, 12);
      sub_100428B2(v5, *(const void **)(v6 + 108));
      sub_10036B87(12);
    }
    else
    {
      *(_DWORD *)(v6 + 112) &= 0xFFFFFFEFu;
    }
  }
  else
  {
    *(_DWORD *)sub_10037649(0) = 22;
    sub_1003A151(0, a1);
  }
}

//----- (10042D8F) --------------------------------------------------------
int __usercall sub_10042D8F<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int result; // eax@1
  int v5; // edx@1
  int v6; // ebx@1
  int v7; // edx@2
  int v8; // ecx@2
  int v9; // esi@2
  int v10; // [sp-4h] [bp-18h]@1
  int v11; // [sp+8h] [bp-Ch]@2
  signed int v12; // [sp+Ch] [bp-8h]@1
  signed int v13; // [sp+10h] [bp-4h]@2

  v12 = 1;
  v6 = sub_10037530(a1, a2, a3, 1702);
  result = 0;
  if ( v6 )
  {
    v9 = v6 + 4;
    *(_WORD *)(v6 + 4) = 0;
    *(_DWORD *)v6 = 1;
    sub_10042BD3(v10, v5, v6 + 4, 849, 3);
    v13 = (signed int)&off_10064A54;
    v11 = a4 + 36;
    do
    {
      if ( sub_1004D31B(v7, v8, v6, v9, 849, (int)L";") )
      {
        sub_1003A161(v6, a4);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_10042F03);
      }
      v12 = sub_1004EAE7(*(_DWORD *)v11, *(_DWORD *)(v11 + 16)) == 0 ? v12 : 0;
      v9 = v6 + 4;
      v11 += 16;
      v13 += 12;
      sub_10042BD3(v11, v7, v6 + 4, 849, 3);
    }
    while ( v13 < (signed int)&off_10064A84 );
    if ( v12 )
    {
      sub_100309C2(v6, (LPVOID)v6);
      if ( *(_DWORD *)(a4 + 28) )
      {
        if ( !InterlockedDecrement(*(volatile LONG **)(a4 + 28)) )
          sub_100309C2(v6, *(LPVOID *)(a4 + 28));
      }
      if ( *(_DWORD *)(a4 + 24) )
      {
        if ( !InterlockedDecrement(*(volatile LONG **)(a4 + 24)) )
          sub_100309C2(v6, *(LPVOID *)(a4 + 24));
      }
      result = *(_DWORD *)(a4 + 52);
      *(_DWORD *)(a4 + 24) = 0;
      *(_DWORD *)(a4 + 16) = 0;
      *(_DWORD *)(a4 + 28) = 0;
      *(_DWORD *)(a4 + 20) = 0;
    }
    else
    {
      if ( *(_DWORD *)(a4 + 28) )
      {
        if ( !InterlockedDecrement(*(volatile LONG **)(a4 + 28)) )
          sub_100309C2(v6, *(LPVOID *)(a4 + 28));
      }
      if ( *(_DWORD *)(a4 + 24) )
      {
        if ( !InterlockedDecrement(*(volatile LONG **)(a4 + 24)) )
          sub_100309C2(v6, *(LPVOID *)(a4 + 24));
      }
      *(_DWORD *)(a4 + 24) = 0;
      *(_DWORD *)(a4 + 16) = 0;
      *(_DWORD *)(a4 + 28) = v6;
      *(_DWORD *)(a4 + 20) = v9;
      result = v6 + 4;
    }
  }
  return result;
}
// 10064A54: using guessed type wchar_t *off_10064A54;
// 10064A84: using guessed type wchar_t *off_10064A84;
// 10064B98: using guessed type wchar_t asc_10064B98[2];

//----- (10042F03) --------------------------------------------------------
int __fastcall sub_10042F03(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // edi@1
  int v6; // esi@1
  int result; // eax@3
  int v8; // ebx@5
  int v9; // eax@9
  int *v10; // ebx@12
  int v11; // eax@16
  int v12; // esi@16
  int v13; // ST14_4@16
  char v14; // zf@21
  int v15; // esi@23
  int *v16; // eax@29
  int v17; // esi@29
  char v18; // zf@32
  int v19; // [sp+10h] [bp-1C8h]@9
  int v20; // [sp+14h] [bp-1C4h]@5
  signed int v21; // [sp+18h] [bp-1C0h]@5
  int v22; // [sp+18h] [bp-1C0h]@12
  int v23; // [sp+1Ch] [bp-1BCh]@12
  int v24; // [sp+1Ch] [bp-1BCh]@16
  int v25; // [sp+1Ch] [bp-1BCh]@29
  char v26; // [sp+20h] [bp-1B8h]@28
  __int16 v27[132]; // [sp+CCh] [bp-10Ch]@19
  unsigned int v28; // [sp+1D4h] [bp-4h]@1
  int v29; // [sp+1D8h] [bp+0h]@1

  v28 = (unsigned int)&v29 ^ __security_cookie;
  v6 = a5;
  v5 = a3;
  if ( !a4 )
  {
    v8 = 0;
    v21 = 1;
    v20 = 0;
    if ( !a5 )
      return sub_10042D8F(a2, a1, v8, v5);
    if ( *(_WORD *)a5 == 76 && *(_WORD *)(a5 + 2) == 67 && *(_WORD *)(a5 + 4) == 95 )
    {
      while ( 1 )
      {
        v9 = sub_1004EBAA(v6, (int)L"=;");
        v19 = v9;
        if ( !v9 )
          return 0;
        if ( !((v9 - v6) >> 1) )
          return 0;
        if ( *(_WORD *)v9 == 59 )
          return 0;
        v23 = (v9 - v6) >> 1;
        v22 = 1;
        v10 = (int *)&off_10064A54;
        do
        {
          if ( !sub_1004EB74(*v10, v6, v23) && v23 == sub_10039899(*v10) )
            break;
          ++v22;
          v10 += 3;
        }
        while ( (signed int)v10 <= (signed int)&off_10064A84 );
        v12 = v19 + 2;
        v11 = sub_1004EB25(v19 + 2, (int)L";");
        v5 = a3;
        v8 = v20;
        a1 = v13;
        v24 = v11;
        if ( !v11 )
        {
          a1 = 59;
          if ( *(_WORD *)v12 != 59 )
            return 0;
        }
        if ( v22 <= 5 )
        {
          if ( sub_1004498F(v20, a3, (int)v27, 131, v12, v11) )
            goto LABEL_43;
          if ( (unsigned int)(2 * v24) >= 0x106 )
          {
            sub_100307AB(v20, a3, v12);
LABEL_43:
            sub_1003A161(v20, a3);
            __asm { int     3               ; Trap to Debugger }
            JUMPOUT(*(int *)sub_1004318A);
          }
          v27[v24] = 0;
          v14 = sub_1004318A(a3, v22, (int)v27) == 0;
          v11 = v24;
          if ( !v14 )
            v8 = v20++ + 1;
        }
        v15 = v12 + 2 * v11;
        result = 0;
        if ( *(_WORD *)v15 )
        {
          v6 = v15 + 2;
          if ( *(_WORD *)v6 )
            continue;
        }
        if ( v8 )
          return sub_10042D8F(a2, a1, v8, v5);
        return result;
      }
    }
    result = sub_100428DE(a5, (int)v27, 131, (int)&v26, 85, 0);
    if ( !result )
      return result;
    v16 = (int *)(a3 + 20);
    v17 = 0;
    v25 = a3 + 20;
    while ( 1 )
    {
      if ( !v17 )
        goto LABEL_36;
      if ( !sub_1004EAE7((int)v27, *v16) )
      {
        v16 = (int *)v25;
LABEL_35:
        ++v8;
LABEL_36:
        a1 = v21;
        goto LABEL_37;
      }
      v18 = sub_1004318A(a3, v17, (int)v27) == 0;
      v16 = (int *)v25;
      if ( !v18 )
        goto LABEL_35;
      a1 = 0;
      v21 = 0;
LABEL_37:
      ++v17;
      v16 += 4;
      v25 = (int)v16;
      if ( v17 > 5 )
      {
        if ( a1 || v8 )
          return sub_10042D8F(a2, a1, v8, v5);
        return 0;
      }
    }
  }
  if ( a5 )
    result = sub_1004318A(a3, a4, a5);
  else
    result = *(_DWORD *)(a3 + 16 * a4 + 20);
  return result;
}
// 10064A54: using guessed type wchar_t *off_10064A54;
// 10064A84: using guessed type wchar_t *off_10064A84;
// 10064B90: using guessed type wchar_t asc_10064B90[3];
// 10064B98: using guessed type wchar_t asc_10064B98[2];
// 10073200: using guessed type int __security_cookie;
// 10042F03: using guessed type __int16 var_10C[132];

//----- (1004318A) --------------------------------------------------------
int __cdecl sub_1004318A(int a1, int a2, int a3)
{
  int v4; // ebx@4
  int v5; // eax@6
  int v6; // edx@6
  int v7; // esi@6
  int v8; // eax@6
  char v9; // zf@8
  int v10; // edx@12
  int v11; // ecx@13
  int v12; // edx@15
  int v13; // eax@15
  int v14; // ecx@15
  int v15; // ebx@15
  int v16; // eax@16
  int v17; // ecx@16
  unsigned int v18; // eax@19
  int v19; // eax@21
  int v20; // ebx@32
  int v21; // eax@35
  LPVOID v22; // [sp+Ch] [bp-2ECh]@7
  int v23; // [sp+10h] [bp-2E8h]@7
  _UNKNOWN *v24; // [sp+18h] [bp-2E0h]@7
  void *v25; // [sp+1Ch] [bp-2DCh]@6
  int v26; // [sp+20h] [bp-2D8h]@13
  int v27; // [sp+24h] [bp-2D4h]@1
  int v28; // [sp+28h] [bp-2D0h]@7
  int v29; // [sp+2Ch] [bp-2CCh]@1
  int v30; // [sp+30h] [bp-2C8h]@13
  int v31; // [sp+34h] [bp-2C4h]@7
  int v32; // [sp+38h] [bp-2C0h]@1
  int v33; // [sp+3Ch] [bp-2BCh]@13
  char v34; // [sp+40h] [bp-2B8h]@1
  WORD CharType[128]; // [sp+ECh] [bp-20Ch]@18
  __int16 v36; // [sp+1ECh] [bp-10Ch]@1
  __int16 v37; // [sp+1EEh] [bp-10Ah]@9
  unsigned int v38; // [sp+2F4h] [bp-4h]@1
  int v39; // [sp+2F8h] [bp+0h]@1

  v38 = (unsigned int)&v39 ^ __security_cookie;
  v29 = a2;
  v32 = sub_10041952(a2, a1) + 708;
  if ( !sub_100428DE(a3, (int)&v36, 131, (int)&v34, 85, (int)&v27) )
    return 0;
  v4 = 16 * a2;
  if ( sub_1004EAE7((int)&v36, *(_DWORD *)(16 * a2 + a1 + 20)) )
  {
    v8 = sub_10039899((int)&v36);
    v7 = v8 + 1;
    v5 = sub_10037530(v6, 2 * (v8 + 1) + 4, v4, 2 * (v8 + 1) + 4);
    v25 = (void *)v5;
    if ( v5 )
    {
      v24 = *(_UNKNOWN **)(v4 + a1 + 20);
      v28 = v5 + 4;
      v31 = a1 + 4 * (v29 + 40);
      v22 = *(LPVOID *)v31;
      v23 = *(_DWORD *)(a1 + 4);
      if ( sub_100490D0(v6, v28, v4, a1, v28, v7, (int)&v36) )
      {
        sub_1003A161(v4, a1);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_10043522);
      }
      v9 = v36 == 67;
      *(_DWORD *)(v4 + a1 + 20) = v28;
      if ( !v9 || v37 )
        *(_DWORD *)v31 = sub_100426B6((int)&v34);
      else
        *(_DWORD *)v31 = 0;
      v10 = v29;
      switch ( v29 )
      {
        case 2:
          *(_DWORD *)(a1 + 4) = v27;
          v30 = v32;
          v26 = *(_DWORD *)(v32 + 32);
          v28 = *(_DWORD *)(v32 + 36);
          v11 = 0;
          v33 = 0;
          while ( 1 )
          {
            v10 = v29;
            if ( *(_DWORD *)(a1 + 4) == *(_DWORD *)v30 )
              break;
            v12 = v30;
            v13 = *(_DWORD *)v30;
            v14 = *(_DWORD *)(v30 + 4);
            v30 += 8;
            *(_DWORD *)v12 = v26;
            v15 = v28;
            v28 = v14;
            v11 = v33 + 1;
            *(_DWORD *)(v12 + 4) = v15;
            v4 = 16 * a2;
            v10 = v29;
            v26 = v13;
            v33 = v11;
            if ( v11 >= 5 )
              goto LABEL_16;
          }
          if ( !v11 )
          {
LABEL_16:
            v16 = v33;
            v17 = v32;
            goto LABEL_17;
          }
          v17 = v32;
          *(_DWORD *)v32 = *(_DWORD *)(v32 + 8 * v33);
          *(_DWORD *)(v17 + 4) = *(_DWORD *)(v17 + 8 * v33 + 4);
          v16 = v33;
          *(_DWORD *)(v17 + 8 * v33) = v26;
          *(_DWORD *)(v17 + 8 * v16 + 4) = v28;
          v4 = 16 * a2;
LABEL_17:
          if ( v16 == 5 )
          {
            if ( sub_10049218(v4, a1, 0, 1u, &MultiByteStr, 127, CharType, *(_DWORD *)(a1 + 4), 1) )
            {
              v18 = 0;
              do
                CharType[v18++] &= 0x1FFu;
              while ( v18 < 0x7F );
              v19 = sub_10037709((int)CharType, (int)off_10073C10, 0xFEu);
              v17 = v32;
              *(_DWORD *)(v32 + 4) = v19 == 0;
            }
            else
            {
              v17 = v32;
              *(_DWORD *)(v32 + 4) = 0;
            }
            v10 = v29;
            *(_DWORD *)v17 = *(_DWORD *)(a1 + 4);
          }
          *(_DWORD *)(a1 + 112) = *(_DWORD *)(v17 + 4);
          break;
        case 1:
          *(_DWORD *)(a1 + 8) = v27;
          break;
        case 5:
          *(_DWORD *)(a1 + 12) = v27;
          break;
      }
      if ( !((int (__cdecl *)(int))*(&off_10064A50 + 3 * v10))(a1) )
      {
        if ( v24 != &unk_100739D8 )
        {
          if ( !InterlockedDecrement(*(volatile LONG **)(v4 + a1 + 28)) )
          {
            sub_100309C2(v4, *(LPVOID *)(v4 + a1 + 28));
            sub_100309C2(v4, *(LPVOID *)(v4 + a1 + 24));
            sub_100309C2(v4, *(LPVOID *)v31);
            v21 = v31;
            *(_DWORD *)(v4 + a1 + 20) = 0;
            *(_DWORD *)v21 = 0;
          }
        }
        *(_DWORD *)v25 = 1;
        *(_DWORD *)(v4 + a1 + 28) = v25;
        return *(_DWORD *)(v4 + a1 + 20);
      }
      *(_DWORD *)(v4 + a1 + 20) = v24;
      v20 = v31;
      sub_100309C2(v31, *(LPVOID *)v31);
      *(_DWORD *)v20 = v22;
      sub_100309C2(v20, v25);
      *(_DWORD *)(a1 + 4) = v23;
    }
    return 0;
  }
  return *(_DWORD *)(v4 + a1 + 20);
}
// 10064A50: using guessed type int (*off_10064A50)();
// 10073200: using guessed type int __security_cookie;
// 10073C10: using guessed type wchar_t *off_10073C10;
// 1004318A: using guessed type WORD CharType[128];

//----- (10043522) --------------------------------------------------------
void __cdecl sub_10043522()
{
  dword_100778C0 = 0;
}
// 100778C0: using guessed type int dword_100778C0;

//----- (1004352A) --------------------------------------------------------
signed int __usercall sub_1004352A<eax>(int a1<edx>, int a2<ebx>, int a3, unsigned int *a4, void **a5, const void *a6, int a7)
{
  unsigned int v7; // eax@2
  const void *v8; // ecx@2
  LPVOID v9; // eax@3
  int v11; // eax@6

  if ( a3 == *a4 )
  {
    v8 = *a5;
    v7 = *a4;
    if ( *a5 == a6 )
    {
      v9 = sub_100374E6((int)v8, a2, v7, 2u);
      *a5 = v9;
      if ( !v9 )
        return 0;
      *(_DWORD *)a7 = 1;
      sub_10034EE0(*a5, a6, *a4);
    }
    else
    {
      v11 = sub_100375C5(a1, (int)v8, a2, v8, v7, 2u);
      if ( !v11 )
        return 0;
      *a5 = (void *)v11;
    }
    *a4 *= 2;
  }
  return 1;
}

//----- (10043589) --------------------------------------------------------
int __usercall sub_10043589<eax>(int a1<edi>, unsigned __int8 a2)
{
  int result; // eax@1
  char v3; // zf@1

  v3 = sub_10036D5B(a2, a1, a2) == 0;
  result = (char)a2;
  if ( v3 )
    result = ((char)a2 & 0xFFFFFFDF) - 7;
  return result;
}

//----- (100435AA) --------------------------------------------------------
signed int __usercall sub_100435AA<eax>(int a1<edx>, int a2<ebx>, int a3)
{
  char v3; // sf@1
  signed int v4; // edx@2

  v3 = *(_DWORD *)(a3 + 4)-- - 1 < 0;
  if ( v3 )
    v4 = sub_1004FB67(a1, a3, a2, a3);
  else
    v4 = *(_BYTE *)*(_DWORD *)a3++;
  return v4;
}

//----- (100435CC) --------------------------------------------------------
signed int __cdecl sub_100435CC(int a1, int a2, int a3, int a4)
{
  signed int v4; // ebx@1
  int v5; // edi@1
  signed int result; // eax@2
  signed int v7; // eax@5
  int v8; // edx@7
  int v9; // ecx@12
  unsigned __int8 v10; // al@16
  int v11; // ecx@16
  int v12; // esi@16
  int v13; // edx@18
  int v14; // eax@19
  int v15; // edx@19
  int v16; // esi@19
  int v17; // edi@25
  int v18; // esi@25
  char v19; // al@28
  char v20; // cl@29
  int v21; // esi@31
  int v22; // edx@32
  char v23; // al@40
  int v24; // edx@67
  char v25; // al@68
  signed int v26; // edi@71
  signed int v27; // eax@74
  int v28; // eax@78
  int v29; // ecx@78
  int v30; // eax@88
  int v31; // esi@91
  int v32; // edi@94
  int i; // eax@98
  int v34; // edx@98
  int v35; // ecx@99
  int v36; // eax@100
  int v38; // eax@102
  int v39; // eax@104
  int v40; // edx@105
  int j; // eax@106
  int v42; // eax@107
  int v44; // eax@109
  int v45; // eax@114
  int v46; // edx@115
  int v47; // eax@116
  int v48; // edx@116
  int v49; // eax@120
  int k; // eax@123
  int v51; // eax@124
  int v53; // eax@126
  int v54; // ecx@132
  LPVOID v55; // ST10_4@132
  int v56; // ST0C_4@132
  int v57; // ST08_4@132
  PVOID v58; // eax@132
  int v59; // ecx@137
  int v60; // esi@137
  int v61; // eax@141
  signed int v62; // eax@142
  int v63; // ecx@142
  int v64; // ST14_4@142
  int v65; // edx@152
  int v66; // edx@154
  char v67; // al@161
  int v68; // edx@165
  char v69; // ah@168
  int v70; // edx@170
  char v71; // cl@172
  char v72; // al@174
  char v73; // al@182
  int v74; // eax@194
  int v75; // edx@194
  char v76; // zf@198
  int v77; // eax@209
  char v78; // al@226
  int v79; // edx@234
  int v80; // ecx@234
  int v81; // eax@234
  int v82; // ST14_4@234
  int v83; // ecx@237
  __int64 v84; // qt0@237
  __int64 v85; // ST08_8@238
  __int64 v86; // qax@238
  int v87; // eax@239
  int v88; // ST14_4@239
  __int64 v89; // qt0@240
  __int64 v90; // qax@241
  int v91; // ecx@241
  unsigned __int8 v92; // cf@241
  char v93; // zf@242
  int v94; // ecx@248
  int v95; // edx@252
  int v96; // ecx@252
  int v97; // eax@252
  int v98; // ST14_4@252
  int v99; // eax@255
  int v100; // eax@257
  int v101; // ST14_4@257
  int v102; // eax@259
  char v103; // zf@260
  int v104; // eax@271
  int v105; // eax@280
  int v106; // ST14_4@280
  int v108; // eax@282
  int v109; // esi@289
  int v110; // ST14_4@290
  int v111; // [sp-8h] [bp-20Ch]@19
  int v112; // [sp-8h] [bp-20Ch]@106
  int v113; // [sp-8h] [bp-20Ch]@123
  int v114; // [sp-8h] [bp-20Ch]@194
  signed int v115; // [sp-8h] [bp-20Ch]@200
  int v116; // [sp-8h] [bp-20Ch]@292
  int v117; // [sp+8h] [bp-1FCh]@16
  int v118; // [sp+10h] [bp-1F4h]@303
  char v119; // [sp+14h] [bp-1F0h]@302
  int v120; // [sp+18h] [bp-1ECh]@17
  int v121; // [sp+1Ch] [bp-1E8h]@17
  int v122; // [sp+20h] [bp-1E4h]@1
  WCHAR WideCharStr[2]; // [sp+24h] [bp-1E0h]@1
  const CHAR MultiByteStr; // [sp+28h] [bp-1DCh]@152
  char v125; // [sp+29h] [bp-1DBh]@153
  int v126; // [sp+2Ch] [bp-1D8h]@1
  int v127; // [sp+30h] [bp-1D4h]@25
  char v128; // [sp+37h] [bp-1CDh]@25
  int v129; // [sp+38h] [bp-1CCh]@1
  int v130; // [sp+3Ch] [bp-1C8h]@16
  int v131; // [sp+40h] [bp-1C4h]@25
  int v132; // [sp+44h] [bp-1C0h]@25
  int v133; // [sp+48h] [bp-1BCh]@17
  int v134; // [sp+4Ch] [bp-1B8h]@26
  int v135; // [sp+50h] [bp-1B4h]@25
  LPVOID lpMem; // [sp+54h] [bp-1B0h]@1
  int v137; // [sp+58h] [bp-1ACh]@17
  __int16 v138; // [sp+5Eh] [bp-1A6h]@25
  int v139; // [sp+60h] [bp-1A4h]@1
  int v140; // [sp+64h] [bp-1A0h]@1
  int v141; // [sp+68h] [bp-19Ch]@16
  char v142; // [sp+6Eh] [bp-196h]@25
  char v143; // [sp+6Fh] [bp-195h]@31
  int v144; // [sp+70h] [bp-194h]@16
  int v145; // [sp+74h] [bp-190h]@1
  int v146; // [sp+78h] [bp-18Ch]@31
  char v147; // [sp+7Ch] [bp-188h]@67
  char v148; // [sp+7Dh] [bp-187h]@16
  char v149; // [sp+7Eh] [bp-186h]@25
  char v150; // [sp+7Fh] [bp-185h]@25
  char v151; // [sp+80h] [bp-184h]@1
  char v152[11]; // [sp+1E0h] [bp-24h]@149
  char v153; // [sp+1EBh] [bp-19h]@168
  unsigned int v154; // [sp+200h] [bp-4h]@1
  int v155; // [sp+204h] [bp+0h]@1

  v154 = (unsigned int)&v155 ^ __security_cookie;
  v129 = 0;
  *(_DWORD *)WideCharStr = 0;
  v5 = a2;
  v122 = a4;
  v4 = 0;
  v145 = a1;
  v139 = a2;
  lpMem = &v151;
  v126 = 350;
  v140 = 0;
  if ( !a2 || !a1 )
  {
    *(_DWORD *)sub_10037649(0) = 22;
    sub_1003A151(0, a2);
    return -1;
  }
  if ( !(*(_BYTE *)(a1 + 12) & 0x40) )
  {
    v7 = sub_1004FC88(0, a2, a1);
    if ( v7 == -1 || v7 == -2 )
      v8 = (int)&unk_10074060;
    else
      v8 = dword_10075F80[v7 >> 5] + ((v7 & 0x1F) << 6);
    if ( *(_BYTE *)(v8 + 36) & 0x7F
      || (v7 == -1 || v7 == -2 ? (v9 = (int)&unk_10074060) : (v9 = dword_10075F80[v7 >> 5] + ((v7 & 0x1F) << 6)),
          *(_BYTE *)(v9 + 36) & 0x80) )
    {
      *(_DWORD *)sub_10037649(0) = 22;
      sub_1003A151(0, a2);
      return -1;
    }
  }
  sub_100301AD((int)&v117, 0, a2, a3);
  v10 = *(_BYTE *)a2;
  v12 = 0;
  v11 = 0;
  v148 = 0;
  v144 = 0;
  v141 = 0;
  v130 = 0;
  if ( !v10 )
    goto LABEL_301;
  v137 = v121;
  v133 = v120;
  while ( 1 )
  {
    if ( sub_10036DB1(v4, v5, v10) )
    {
      v141 = v12 - 1;
      v16 = v145;
      v14 = sub_100446BA(v13, v4, v5, (int)&v141, v145);
      if ( v14 != -1 )
        sub_1004FCAC(v15, v111, v4, v14, v16);
      do
        ++v5;
      while ( sub_10036DB1(v4, v5, *(_BYTE *)v5) );
      v12 = v141;
      v139 = v5;
      v144 = v141;
      goto LABEL_287;
    }
    if ( *(_BYTE *)v5 != 37 )
      goto LABEL_280;
    if ( *(_BYTE *)(v5 + 1) != 37 )
      break;
    if ( *(_BYTE *)v5 == 37 )
    {
      if ( *(_BYTE *)(v5 + 1) == 37 )
        ++v5;
    }
LABEL_280:
    ++v12;
    v144 = v12;
    v141 = v12;
    v4 = sub_100435AA(v13, v4, v145);
    v105 = *(_BYTE *)v5++;
    v29 = v106;
    v140 = v4;
    v139 = v5;
    if ( v105 != v4 )
      goto LABEL_293;
    if ( !sub_10042653(v4, v5, v4) )
      goto LABEL_284;
    v108 = sub_100435AA(v24, v4, v145);
    v29 = *(_BYTE *)v5++;
    v139 = v5;
    if ( v29 != v108 )
    {
      v109 = v145;
      if ( v108 != -1 )
      {
        sub_1004FCAC(v24, v29, v4, v108, v145);
        v29 = v110;
      }
      if ( v4 == -1 )
        goto LABEL_296;
      v116 = v109;
LABEL_295:
      sub_1004FCAC(v24, v29, v4, v4, v116);
      goto LABEL_296;
    }
    v144 = v12;
    v141 = v12;
LABEL_284:
    if ( v4 == -1 && (*(_BYTE *)v5 != 37 || *(_BYTE *)(v5 + 1) != 110) )
      goto LABEL_296;
LABEL_287:
    v10 = *(_BYTE *)v5;
    if ( !*(_BYTE *)v5 )
      goto LABEL_296;
  }
  v18 = v139;
  v131 = 0;
  v128 = 0;
  v135 = 0;
  v132 = 0;
  v17 = 0;
  v138 = 0;
  v149 = 0;
  v142 = 0;
  v150 = 0;
  v127 = 0;
  LOWORD(v4) = 256;
  do
  {
    ++v18;
    v134 = *(_BYTE *)v18;
    if ( sub_10036D5B(v4, v17, (unsigned __int8)v134) )
    {
      ++v132;
      v17 = v134 + 10 * v17 - 48;
      goto LABEL_28;
    }
    if ( v134 > 78 )
    {
      if ( v134 == 104 )
      {
        --BYTE1(v4);
        v20 = v150 - 1;
      }
      else
      {
        if ( v134 == 108 )
        {
          if ( *(_BYTE *)(v18 + 1) == 108 )
          {
            ++v18;
            goto LABEL_43;
          }
          LOWORD(v4) = v4 + 256;
        }
        else
        {
          if ( v134 != 119 )
            goto LABEL_57;
        }
        v20 = v150 + 1;
      }
      v150 = v20;
    }
    else
    {
      if ( v134 == 78 )
        goto LABEL_28;
      if ( v134 == 42 )
      {
        v19 = v149++ + 1;
        goto LABEL_29;
      }
      if ( v134 == 70 )
        goto LABEL_28;
      if ( v134 != 73 )
      {
        if ( v134 == 76 )
        {
          LOWORD(v4) = v4 + 256;
          goto LABEL_28;
        }
        goto LABEL_57;
      }
      v23 = *(_BYTE *)(v18 + 1);
      if ( v23 == 54 && *(_BYTE *)(v18 + 2) == 52 )
      {
        v18 += 2;
LABEL_43:
        ++v127;
        v133 = 0;
        v137 = 0;
        goto LABEL_28;
      }
      if ( v23 == 51 && *(_BYTE *)(v18 + 2) == 50 )
      {
        v18 += 2;
        goto LABEL_28;
      }
      if ( v23 == 100 )
        goto LABEL_28;
      if ( v23 != 105 )
      {
        if ( v23 == 111 || v23 == 120 || v23 == 88 )
        {
LABEL_28:
          v19 = v149;
LABEL_29:
          v20 = v150;
          continue;
        }
LABEL_57:
        LOBYTE(v4) = v4 + 1;
        goto LABEL_28;
      }
      v20 = v150;
    }
    v19 = v149;
  }
  while ( !(_BYTE)v4 );
  v143 = BYTE1(v4);
  v4 = v140;
  v139 = v18;
  v21 = v144;
  v146 = v17;
  if ( v19 )
  {
    v134 = 0;
  }
  else
  {
    v121 = v122;
    v22 = *(_DWORD *)v122;
    v122 += 4;
    v134 = v22;
  }
  v24 = v139;
  v147 = 0;
  if ( !v20 )
  {
    v25 = *(_BYTE *)v139;
    if ( *(_BYTE *)v139 == 83 || (v150 = -1, v25 == 67) )
      v150 = 1;
  }
  v26 = *(_BYTE *)v139 | 0x20;
  if ( v26 == 110 )
  {
LABEL_78:
    v28 = v132;
    v29 = v146;
    if ( v132 && !v146 )
    {
LABEL_293:
      if ( v4 == -1 )
        goto LABEL_296;
      v116 = v145;
      goto LABEL_295;
    }
    if ( v26 <= 111 )
    {
      if ( v26 == 111 )
        goto LABEL_221;
      if ( v26 != 99 )
      {
        if ( v26 != 100 )
        {
          if ( v26 <= 100 )
            goto LABEL_160;
          if ( v26 > 103 )
          {
            if ( v26 != 105 )
            {
              if ( v26 == 110 )
              {
                v30 = v21;
                if ( v149 )
                {
LABEL_275:
                  v67 = v148;
LABEL_276:
                  v12 = v144;
                  v5 = v139 + 1;
                  v148 = v67 + 1;
                  ++v139;
                  goto LABEL_284;
                }
LABEL_270:
                if ( v127 )
                {
                  v104 = v134;
                  *(_DWORD *)v134 = v133;
                  *(_DWORD *)(v104 + 4) = v137;
                }
                else
                {
                  if ( v143 )
                    *(_DWORD *)v134 = v30;
                  else
                    *(_WORD *)v134 = v30;
                }
                goto LABEL_275;
              }
LABEL_160:
              if ( *(_BYTE *)v24 != v4 )
                goto LABEL_293;
              v67 = v148 - 1;
              if ( !v149 )
                v122 = v121;
              goto LABEL_276;
            }
            v26 = 100;
LABEL_186:
            if ( v4 == 45 )
            {
              LOBYTE(v138) = 1;
            }
            else
            {
              if ( v4 != 43 )
              {
LABEL_193:
                if ( v4 != 48 )
                {
LABEL_229:
                  v78 = v147;
                  goto LABEL_230;
                }
                ++v21;
                v144 = v21;
                v141 = v21;
                v74 = sub_100435AA(v24, 48, v145);
                v4 = v74;
                v140 = v74;
                if ( (_BYTE)v74 == 120 || (_BYTE)v74 == 88 )
                {
                  ++v21;
                  v144 = v21;
                  v141 = v21;
                  v4 = sub_100435AA(v75, v74, v145);
                  v140 = v4;
                  if ( v132 )
                  {
                    v146 -= 2;
                    if ( v146 < 1 )
                      ++v147;
                  }
                  v115 = 120;
                  goto LABEL_201;
                }
                v135 = 1;
                if ( v26 != 120 )
                {
                  if ( v132 )
                  {
                    v76 = v146-- == 1;
                    if ( v76 )
                      ++v147;
                  }
                  v115 = 111;
LABEL_201:
                  v26 = v115;
                  goto LABEL_229;
                }
                --v21;
                v144 = v21;
                v141 = v21;
                if ( v74 != -1 )
                  sub_1004FCAC(v75, v114, v74, v74, v145);
                v4 = 48;
LABEL_228:
                v140 = v4;
                goto LABEL_229;
              }
            }
            --v146;
            if ( v146 || !v28 )
            {
              ++v21;
              v144 = v21;
              v141 = v21;
              v4 = sub_100435AA(v24, v4, v145);
              v140 = v4;
            }
            else
            {
              v147 = 1;
            }
            goto LABEL_193;
          }
          v31 = 0;
          if ( v4 == 45 )
          {
            v31 = 1;
            *(_BYTE *)lpMem = 45;
          }
          else
          {
            if ( v4 != 43 )
            {
              v32 = v144;
              goto LABEL_96;
            }
          }
          v146 = v29 - 1;
          v32 = v144 + 1;
          v4 = sub_100435AA(v24, v4, v145);
          v28 = v132;
          v140 = v4;
LABEL_96:
          if ( !v28 )
            v146 = -1;
          for ( i = sub_10036D5B(v4, v32, (unsigned __int8)v4); ; i = sub_10036D5B(v38, v32, (unsigned __int8)v38) )
          {
            v35 = v146;
            if ( !i )
              break;
            v36 = v146;
            v35 = v146-- - 1;
            if ( !v36 )
              break;
            ++v135;
            *((_BYTE *)lpMem + v31++) = v4;
            if ( !sub_1004352A(v34, v4, v31, (unsigned int *)&v126, &lpMem, &v151, (int)&v129) )
              goto LABEL_296;
            ++v32;
            v38 = sub_100435AA(v34, v4, v145);
            v4 = v38;
            v140 = v38;
          }
          HIBYTE(v138) = ***(_BYTE ***)(v117 + 132);
          if ( HIBYTE(v138) == (_BYTE)v4 )
          {
            v39 = v35--;
            v146 = v35;
            if ( v39 )
            {
              ++v32;
              v4 = sub_100435AA(v34, v4, v145);
              *((_BYTE *)lpMem + v31++) = HIBYTE(v138);
              v140 = v4;
              if ( !sub_1004352A(v40, v4, v31, (unsigned int *)&v126, &lpMem, &v151, (int)&v129) )
                goto LABEL_296;
              for ( j = sub_10036D5B(v4, v32, (unsigned __int8)v4); ; j = sub_10036D5B(v44, v32, (unsigned __int8)v44) )
              {
                v35 = v112;
                if ( !j )
                  break;
                v42 = v146;
                v35 = v146-- - 1;
                if ( !v42 )
                  break;
                ++v135;
                *((_BYTE *)lpMem + v31++) = v4;
                if ( !sub_1004352A(v34, v4, v31, (unsigned int *)&v126, &lpMem, &v151, (int)&v129) )
                  goto LABEL_296;
                ++v32;
                v44 = sub_100435AA(v34, v4, v145);
                v4 = v44;
                v140 = v44;
              }
            }
          }
          if ( !v135 || v4 != 101 && v4 != 69 || (v45 = v146, v35 = v146 - 1, --v146, !v45) )
            goto LABEL_128;
          *((_BYTE *)lpMem + v31++) = 101;
          if ( !sub_1004352A(v34, v4, v31, (unsigned int *)&v126, &lpMem, &v151, (int)&v129) )
            goto LABEL_296;
          ++v32;
          v47 = sub_100435AA(v46, v4, v145);
          v4 = v47;
          v140 = v47;
          if ( v47 == 45 )
          {
            *((_BYTE *)lpMem + v31++) = 45;
            if ( !sub_1004352A(v48, v47, v31, (unsigned int *)&v126, &lpMem, &v151, (int)&v129) )
              goto LABEL_296;
          }
          else
          {
            if ( v47 != 43 )
              goto LABEL_123;
          }
          v49 = v146--;
          if ( v49 )
          {
            ++v32;
            v4 = sub_100435AA(v48, v4, v145);
            v140 = v4;
          }
          else
          {
            v146 = 0;
          }
LABEL_123:
          for ( k = sub_10036D5B(v4, v32, (unsigned __int8)v4); ; k = sub_10036D5B(v53, v32, (unsigned __int8)v53) )
          {
            v35 = v113;
            if ( !k )
              break;
            v51 = v146;
            v35 = v146-- - 1;
            if ( !v51 )
              break;
            ++v135;
            *((_BYTE *)lpMem + v31++) = v4;
            if ( !sub_1004352A(v34, v4, v31, (unsigned int *)&v126, &lpMem, &v151, (int)&v129) )
              goto LABEL_296;
            ++v32;
            v53 = sub_100435AA(v34, v4, v145);
            v4 = v53;
            v140 = v53;
          }
LABEL_128:
          v144 = v32 - 1;
          v141 = v32 - 1;
          if ( v4 != -1 )
            sub_1004FCAC(v34, v35, v4, v4, v145);
          if ( !v135 )
            goto LABEL_296;
          if ( !v149 )
          {
            ++v130;
            v54 = v134;
            v55 = lpMem;
            *((_BYTE *)lpMem + v31) = 0;
            v56 = v54;
            v57 = v143 - 1;
            v58 = DecodePointer(off_100741E8);
            ((void (__cdecl *)(int, int, LPVOID, int *))v58)(v57, v56, v55, &v117);
          }
          goto LABEL_275;
        }
LABEL_221:
        if ( v4 == 45 )
        {
          LOBYTE(v138) = 1;
        }
        else
        {
          if ( v4 != 43 )
            goto LABEL_229;
        }
        --v146;
        if ( !v146 && v28 )
        {
          v78 = 1;
LABEL_230:
          if ( v127 )
          {
            if ( !v78 )
            {
              while ( 1 )
              {
                if ( v26 == 120 || v26 == 112 )
                {
                  v87 = sub_10036E07(v4, v26, (unsigned __int8)v4);
                  v80 = v88;
                  if ( !v87 )
                  {
LABEL_244:
                    v144 = v21 - 1;
                    v141 = v21 - 1;
                    if ( v4 != -1 )
                      sub_1004FCAC(v79, v80, v4, v4, v145);
                    break;
                  }
                  HIDWORD(v89) = v137;
                  LODWORD(v89) = v133;
                  v137 = (unsigned __int64)(16 * v89) >> 32;
                  v133 *= 16;
                  v4 = sub_10043589(v26, v4);
                  v83 = v133;
                  v140 = v4;
                }
                else
                {
                  v81 = sub_10036D5B(v4, v26, (unsigned __int8)v4);
                  v80 = v82;
                  if ( !v81 )
                    goto LABEL_244;
                  if ( v26 == 111 )
                  {
                    if ( v4 >= 56 )
                      goto LABEL_244;
                    HIDWORD(v84) = v137;
                    LODWORD(v84) = v133;
                    v137 = (unsigned __int64)(8 * v84) >> 32;
                    v83 = 8 * v133;
                  }
                  else
                  {
                    HIDWORD(v85) = v137;
                    LODWORD(v85) = v133;
                    v86 = sub_10039A20(v85, 10i64);
                    v83 = v86;
                    v137 = HIDWORD(v86);
                  }
                }
                ++v135;
                v90 = v4 - 48;
                v92 = (_DWORD)v90 >= (unsigned int)-v83;
                v91 = v90 + v83;
                LODWORD(v90) = HIDWORD(v90) + v92 + v137;
                v133 = v91;
                v137 += HIDWORD(v90) + v92;
                if ( v132 )
                {
                  v93 = v146-- == 1;
                  if ( v93 )
                    goto LABEL_247;
                }
                ++v21;
                v144 = v21;
                v141 = v21;
                v4 = sub_100435AA(SHIDWORD(v90), v4, v145);
                v140 = v4;
              }
            }
            v91 = v133;
            LODWORD(v90) = v137;
LABEL_247:
            if ( (_BYTE)v138 )
            {
              v94 = -v91;
              v133 = v94;
              v137 = (unsigned __int64)-__PAIR__(v90, v94) >> 32;
            }
          }
          else
          {
            if ( !v78 )
            {
              while ( 1 )
              {
                if ( v26 == 120 || v26 == 112 )
                {
                  v100 = sub_10036E07(v4, v26, (unsigned __int8)v4);
                  v96 = v101;
                  if ( !v100 )
                  {
LABEL_262:
                    v144 = v21 - 1;
                    v141 = v21 - 1;
                    if ( v4 != -1 )
                      sub_1004FCAC(v95, v96, v4, v4, v145);
                    break;
                  }
                  v131 *= 16;
                  v4 = sub_10043589(v26, v4);
                  v99 = v131;
                  v140 = v4;
                }
                else
                {
                  v97 = sub_10036D5B(v4, v26, (unsigned __int8)v4);
                  v96 = v98;
                  if ( !v97 )
                    goto LABEL_262;
                  if ( v26 == 111 )
                  {
                    if ( v4 >= 56 )
                      goto LABEL_262;
                    v99 = 8 * v131;
                  }
                  else
                  {
                    v99 = 10 * v131;
                  }
                }
                ++v135;
                v102 = v4 + v99 - 48;
                v131 = v102;
                if ( v132 )
                {
                  v103 = v146-- == 1;
                  if ( v103 )
                    goto LABEL_265;
                }
                ++v21;
                v144 = v21;
                v141 = v21;
                v4 = sub_100435AA(v95, v4, v145);
                v140 = v4;
              }
            }
            v102 = v131;
LABEL_265:
            if ( (_BYTE)v138 )
              v131 = -v102;
          }
          if ( !(v26 != 70 ? v135 : 0) )
            goto LABEL_296;
          if ( v149 )
            goto LABEL_275;
          ++v130;
          v30 = v131;
          goto LABEL_270;
        }
        ++v21;
        v144 = v21;
        v141 = v21;
        v4 = sub_100435AA(v24, v4, v145);
        goto LABEL_228;
      }
      if ( !v132 )
      {
        v132 = 1;
        ++v146;
      }
      goto LABEL_135;
    }
    if ( v26 == 112 )
    {
      v143 = 1;
    }
    else
    {
      if ( v26 == 115 )
      {
LABEL_135:
        if ( v150 > 0 )
          v142 = 1;
        goto LABEL_137;
      }
      if ( v26 != 117 )
      {
        if ( v26 == 120 )
        {
          v28 = v132;
          goto LABEL_186;
        }
        if ( v26 != 123 )
          goto LABEL_160;
        if ( v150 > 0 )
          v142 = 1;
        v68 = v24 + 1;
        v139 = v68;
        if ( *(_BYTE *)v68 == 94 )
        {
          v139 = v68 + 1;
          HIBYTE(v138) = -1;
        }
        sub_100391F0(v152, 0, 32);
        v24 = v139;
        if ( *(_BYTE *)v139 == 93 )
        {
          v69 = 93;
          v24 = v139 + 1;
          v153 = 32;
        }
        else
        {
          v69 = v128;
        }
        while ( 1 )
        {
          v73 = *(_BYTE *)v24;
          if ( *(_BYTE *)v24 == 93 )
            break;
          v70 = v24 + 1;
          v139 = v70;
          if ( v73 == 45 && v69 && (v71 = *(_BYTE *)v70, *(_BYTE *)v70 != 93) )
          {
            v139 = v70 + 1;
            if ( v69 >= (unsigned __int8)v71 )
            {
              v72 = v69;
              v69 = v71;
            }
            else
            {
              v72 = v71;
            }
            while ( (unsigned __int8)v69 < (signed int)(unsigned __int8)v72 )
            {
              v152[(unsigned int)(unsigned __int8)v69 >> 3] |= 1 << (v69 & 7);
              ++v69;
            }
            v152[(unsigned int)(unsigned __int8)v72 >> 3] |= 1 << (v72 & 7);
            v69 = 0;
          }
          else
          {
            v69 = v73;
            v152[(unsigned int)(unsigned __int8)v73 >> 3] |= 1 << (v73 & 7);
          }
          v24 = v139;
        }
        if ( !v73 )
          goto LABEL_296;
        v139 = v24;
LABEL_137:
        v60 = v134;
        v59 = v144 - 1;
        v144 = v59;
        v141 = v59;
        if ( v4 != -1 )
        {
          sub_1004FCAC(v24, v59, v4, v4, v145);
          goto LABEL_139;
        }
        while ( 1 )
        {
          if ( v132 )
          {
            v61 = v146;
            v24 = v146-- - 1;
            if ( !v61 )
              break;
          }
          v144 = v59 + 1;
          v141 = v59 + 1;
          v62 = sub_100435AA(v24, v4, v145);
          v4 = v62;
          v63 = v64;
          v140 = v62;
          if ( v62 == -1 )
            goto LABEL_211;
          if ( v26 != 99 )
          {
            if ( v26 != 115 )
              goto LABEL_306;
            if ( v62 >= 9 && v62 <= 13 )
            {
LABEL_211:
              --v144;
              v141 = v144;
              if ( v62 != -1 )
                sub_1004FCAC(v24, v63, v62, v62, v145);
              break;
            }
            if ( v62 == 32 )
            {
LABEL_306:
              if ( v26 != 123 || (v24 = 1 << (v62 & 7), v63 = SHIBYTE(v138) ^ v152[v62 >> 3], !(v24 & v63)) )
                goto LABEL_211;
            }
          }
          if ( v149 )
          {
            ++v60;
          }
          else
          {
            if ( v142 )
            {
              MultiByteStr = v62;
              if ( sub_10042653(v62, v26, v62) )
              {
                ++v144;
                v141 = v144;
                v125 = sub_100435AA(v65, v4, v145);
              }
              *(_DWORD *)WideCharStr = 63;
              sub_1004FD8C(v26, WideCharStr, &MultiByteStr, *(_DWORD *)(v117 + 116), (int)&v117);
              v66 = v134;
              *(_WORD *)v134 = WideCharStr[0];
              v24 = v66 + 2;
              v134 = v24;
            }
            else
            {
              v77 = v134;
              *(_BYTE *)v134 = v4;
              v134 = v77 + 1;
            }
          }
LABEL_139:
          v59 = v144;
        }
        if ( v60 == v134 )
          goto LABEL_296;
        if ( !v149 )
        {
          ++v130;
          if ( v26 != 99 )
          {
            if ( v142 )
              *(_WORD *)v134 = 0;
            else
              *(_BYTE *)v134 = 0;
          }
        }
        goto LABEL_275;
      }
    }
    v28 = v132;
    goto LABEL_221;
  }
  if ( v26 == 99 || v26 == 123 )
  {
    v21 = v144 + 1;
    v144 = v21;
    v141 = v21;
    v27 = sub_100435AA(v139, v140, v145);
  }
  else
  {
    v27 = sub_100446BA(v139, v140, v26, (int)&v141, v145);
    v21 = v141;
    v144 = v141;
  }
  v4 = v27;
  v140 = v27;
  if ( v27 != -1 )
  {
    v24 = v139;
    goto LABEL_78;
  }
LABEL_296:
  if ( v129 == 1 )
    sub_100309C2(v4, lpMem);
  v11 = v130;
  result = -1;
  if ( v4 != -1 || v130 || v148 )
LABEL_301:
    result = v11;
  if ( v119 )
    *(_DWORD *)(v118 + 112) &= 0xFFFFFFFDu;
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10075F80: using guessed type int dword_10075F80[];
// 100435CC: using guessed type char var_24[11];

//----- (100446BA) --------------------------------------------------------
int __usercall sub_100446BA<eax>(int a1<edx>, int a2<ebx>, int a3<edi>, int a4, int a5)
{
  int v5; // eax@1

  do
  {
    ++*(_DWORD *)a4;
    v5 = sub_100435AA(a1, a2, a5);
    a2 = v5;
  }
  while ( v5 != -1 && sub_10036DB1(v5, a3, (unsigned __int8)v5) );
  return a2;
}

//----- (100446E8) --------------------------------------------------------
signed int __usercall sub_100446E8<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3, int a4)
{
  int v4; // edx@1
  int v5; // ecx@1
  int v6; // edi@1
  int v7; // esi@1
  signed int v8; // eax@1
  int v10; // ebx@6
  int v11; // eax@9
  int v12; // eax@12
  int v13; // ST0C_4@12
  int v14; // ST0C_4@13
  int v15; // edx@15
  int v16; // ecx@15
  void *v17; // ecx@15
  int v18; // eax@15
  int v19; // eax@16
  int v20; // ecx@20
  int v21; // eax@23
  int v22; // edx@23
  int v23; // eax@25

  v7 = a4;
  v8 = sub_1004FC88(a1, a2, a4);
  v5 = *(_DWORD *)(v7 + 12);
  v6 = v8;
  if ( !(v5 & 0x82) )
  {
    *(_DWORD *)sub_10037649(a1) = 9;
LABEL_3:
    *(_DWORD *)(v7 + 12) |= 0x20u;
    return -1;
  }
  if ( v5 & 0x40 )
  {
    *(_DWORD *)sub_10037649(a1) = 34;
    goto LABEL_3;
  }
  v10 = 0;
  if ( v5 & 1 )
  {
    *(_DWORD *)(v7 + 4) = 0;
    if ( !(v5 & 0x10) )
    {
      *(_DWORD *)(v7 + 12) = v5 | 0x20;
      return -1;
    }
    v5 &= 0xFFFFFFFEu;
    *(_DWORD *)v7 = *(_DWORD *)(v7 + 8);
    *(_DWORD *)(v7 + 12) = v5;
  }
  v11 = *(_DWORD *)(v7 + 12) & 0xFFFFFFEF | 2;
  *(_DWORD *)(v7 + 12) = v11;
  *(_DWORD *)(v7 + 4) = 0;
  if ( !(v11 & 0x10C) )
  {
    if ( (void **)v7 != sub_10047ECB() + 8 && (void **)v7 != sub_10047ECB() + 16
      || (v12 = sub_1004FE97(0, v6, v6), v5 = v13, !v12) )
    {
      sub_10050964(v4, v5, 0, v7);
      v5 = v14;
    }
  }
  if ( *(_DWORD *)(v7 + 12) & 0x108 )
  {
    v15 = *(_DWORD *)(v7 + 8);
    v17 = *(void **)v7;
    *(_DWORD *)v7 = v15 + 1;
    v16 = (int)((char *)v17 - v15);
    v18 = *(_DWORD *)(v7 + 24) - 1;
    a4 = v16;
    *(_DWORD *)(v7 + 4) = v18;
    if ( v16 <= 0 )
    {
      if ( v6 == -1 || v6 == -2 )
        v20 = (int)&unk_10074060;
      else
        v20 = dword_10075F80[v6 >> 5] + ((v6 & 0x1F) << 6);
      if ( *(_BYTE *)(v20 + 4) & 0x20 )
      {
        sub_100507F7(v15, v20, 0, v6, 0i64, 2u);
        if ( (v22 & v21) == -1 )
          goto LABEL_27;
      }
    }
    else
    {
      sub_1004FEEB(v15, v16, 0, v6, v6, (const void *)v15, v16);
      v10 = v19;
    }
    **(_BYTE **)(v7 + 8) = a3;
  }
  else
  {
    a4 = 1;
    sub_1004FEEB(v4, v5, 0, v6, v6, &a3, 1);
    v10 = v23;
  }
  if ( v10 != a4 )
  {
LABEL_27:
    *(_DWORD *)(v7 + 12) |= 0x20u;
    return -1;
  }
  return a3;
}
// 10075F80: using guessed type int dword_10075F80[];

//----- (10044835) --------------------------------------------------------
int __usercall sub_10044835<eax>(int a1<ebx>, int (__cdecl *a2)(_DWORD, _DWORD, _DWORD, _DWORD), int a3, unsigned int a4, int a5, int a6, int a7)
{
  int result; // eax@2
  int v8; // ebx@8
  char v9; // sf@10
  char v10; // sf@14
  int v11; // [sp+4h] [bp-20h]@1
  unsigned int v12; // [sp+8h] [bp-1Ch]@1
  int v13; // [sp+Ch] [bp-18h]@8
  int v14; // [sp+10h] [bp-14h]@8
  int v15; // [sp+24h] [bp+0h]@2

  v11 = 0;
  memset(&v12, 0, 0x1Cu);
  if ( !a5 )
  {
    *(_DWORD *)sub_10037649(a1) = 22;
    sub_1003A151(a1, (int)&v15);
    return -1;
  }
  if ( a4 && !a3 )
  {
    *(_DWORD *)sub_10037649(a1) = 22;
    sub_1003A151(a1, 0);
    return -1;
  }
  v12 = 2147483647;
  if ( a4 <= 0x7FFFFFFF )
    v12 = a4;
  v14 = 66;
  v13 = a3;
  v11 = a3;
  result = a2(&v11, a5, a6, a7);
  v8 = result;
  if ( a3 )
  {
    if ( result >= 0 )
    {
      v9 = (signed int)(v12-- - 1) < 0;
      if ( !v9 )
      {
        *(_BYTE *)v11 = 0;
        return v8;
      }
      if ( sub_100446E8(result, a3, 0, (int)&v11) != -1 )
        return v8;
    }
    v10 = (signed int)v12 < 0;
    *(_BYTE *)(a3 + a4 - 1) = 0;
    result = !v10 - 2;
  }
  return result;
}

//----- (100448FD) --------------------------------------------------------
int __usercall sub_100448FD<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned int a4, int a5, int a6, int a7)
{
  int result; // eax@2

  if ( !a5 )
  {
    *(_DWORD *)sub_10037649(a1) = 22;
    sub_1003A151(a1, a2);
    return -1;
  }
  if ( !a3 || !a4 )
  {
    *(_DWORD *)sub_10037649(a1) = 22;
    goto LABEL_10;
  }
  result = sub_10044835(a1, sub_100509AA, a3, a4, a5, a6, a7);
  if ( result < 0 )
    *(_BYTE *)a3 = 0;
  if ( result == -2 )
  {
    *(_DWORD *)sub_10037649(a1) = 34;
LABEL_10:
    sub_1003A151(a1, a2);
    result = -1;
  }
  return result;
}

//----- (10044972) --------------------------------------------------------
bool __cdecl sub_10044972()
{
  hHeap = GetProcessHeap();
  return hHeap != 0;
}

//----- (10044987) --------------------------------------------------------
void __cdecl sub_10044987()
{
  hHeap = 0;
}

//----- (1004498F) --------------------------------------------------------
signed int __usercall sub_1004498F<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6)
{
  int v6; // edx@1
  int v8; // esi@9
  int v9; // eax@11
  int v10; // ebx@14
  int v11; // edi@14
  __int16 v12; // ax@15
  __int16 v13; // ax@18
  char v14; // zf@23
  int v15; // [sp-8h] [bp-Ch]@14
  signed int v16; // [sp-4h] [bp-8h]@11
  int v17; // [sp-4h] [bp-8h]@14

  v6 = a6;
  if ( a6 )
  {
    if ( !a3 )
    {
LABEL_11:
      v9 = sub_10037649(a1);
      v16 = 22;
LABEL_12:
      *(_DWORD *)v9 = v16;
      sub_1003A151(a1, a2);
      return v16;
    }
  }
  else
  {
    if ( !a3 )
    {
      if ( !a4 )
        return 0;
      goto LABEL_11;
    }
  }
  if ( !a4 )
    goto LABEL_11;
  if ( !a6 )
  {
    *(_WORD *)a3 = 0;
    return 0;
  }
  v8 = a5;
  if ( !a5 )
  {
    *(_WORD *)a3 = 0;
    goto LABEL_11;
  }
  v17 = a1;
  v15 = a2;
  v10 = a3;
  v11 = a4;
  if ( a6 == -1 )
  {
    do
    {
      v12 = *(_WORD *)v8;
      *(_WORD *)(a3 - a5 + v8) = *(_WORD *)v8;
      v8 += 2;
      if ( !v12 )
        break;
      --v11;
    }
    while ( v11 );
  }
  else
  {
    do
    {
      v13 = *(_WORD *)(a5 - a3 + v10);
      *(_WORD *)v10 = v13;
      v10 += 2;
      if ( !v13 )
        break;
      --v11;
      if ( !v11 )
        break;
      --v6;
    }
    while ( v6 );
    if ( !v6 )
      *(_WORD *)v10 = 0;
  }
  v14 = v11 == 0;
  a2 = v15;
  a1 = v17;
  if ( !v14 )
    return 0;
  if ( v6 != -1 )
  {
    *(_WORD *)a3 = 0;
    v9 = sub_10037649(v17);
    v16 = 34;
    goto LABEL_12;
  }
  *(_WORD *)(a3 + 2 * a4 - 2) = 0;
  return 80;
}

//----- (10044A4D) --------------------------------------------------------
int __usercall sub_10044A4D<eax>(int a1<ebx>, int a2, int a3, char a4)
{
  int ebp0; // ebp@0
  char *v6; // [sp+0h] [bp-4h]@1

  v6 = &a4;
  sub_10044B7B(a1, ebp0, a3, (int)&v6);
  return a2;
}

//----- (10044A6B) --------------------------------------------------------
int __userpurge sub_10044A6B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, const void **a5)
{
  int v6; // esi@1
  int v7; // eax@1

  v6 = a2;
  v7 = sub_1002ADB1(a1, a2, a3, a4, 40);
  *(_DWORD *)v6 = v7;
  sub_10034EE0((void *)v7, *a5, 0x28u);
  return v6;
}

//----- (10044A91) --------------------------------------------------------
int __userpurge sub_10044A91<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10060D38;
  return v4;
}
// 10060D38: using guessed type int (__stdcall *off_10060D38)(char);

//----- (10044AAC) --------------------------------------------------------
int __userpurge sub_10044AAC<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10060D50;
  return v4;
}
// 10060D50: using guessed type int (__stdcall *off_10060D50)(char);

//----- (10044AC7) --------------------------------------------------------
int __userpurge sub_10044AC7<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10060D44;
  return v4;
}
// 10060D44: using guessed type int (__stdcall *off_10060D44)(char);

//----- (10044AE2) --------------------------------------------------------
int __thiscall sub_10044AE2(LPVOID *this)
{
  return sub_1002A4AA(*this);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10044AEB) --------------------------------------------------------
void **__thiscall sub_10044AEB(void **this, const void **a2)
{
  void **v3; // esi@1

  v3 = this;
  sub_10034EE0(*this, *a2, 0x28u);
  return v3;
}

//----- (10044B09) --------------------------------------------------------
int __thiscall sub_10044B09(void *this, unsigned int a2)
{
  char v3; // al@3
  char v4; // [sp+0h] [bp-Ch]@3

  if ( a2 > 9 )
  {
    v3 = (unsigned int)sub_10044CA3(a2);
    sub_1002FFF9((int)&v4, v3);
    sub_100355BB((int)&v4, (int)&unk_1006C02C);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10044B3F);
  }
  return *(_DWORD *)(*(_DWORD *)this + 4 * a2);
}

//----- (10044B3F) --------------------------------------------------------
char __thiscall sub_10044B3F(void *this)
{
  void *v2; // esi@1
  int v3; // ST04_4@1
  int v4; // eax@1

  v2 = this;
  v3 = sub_10044B09(this, 1u);
  v4 = sub_10044B09(v2, 2u);
  return sub_10044B5D(v4, v3);
}

//----- (10044B5D) --------------------------------------------------------
char __cdecl sub_10044B5D(unsigned int a1, unsigned int a2)
{
  return a2 == -1 || a1 == -1 || a2 >= a1;
}

//----- (10044B7B) --------------------------------------------------------
int __userpurge sub_10044B7B<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4)
{
  int v4; // ebx@1
  unsigned int v5; // esi@1
  int v6; // ecx@1
  int v7; // edi@1
  int v8; // edx@1
  int v9; // eax@3
  int v10; // ecx@3
  unsigned int v11; // edi@3
  int v12; // eax@3
  int i; // eax@4
  char v14; // al@4
  char v15; // al@7
  int v17; // [sp-8h] [bp-8h]@4

  sub_100356B1();
  v7 = v6;
  *(_DWORD *)(a2 - 24) = v6;
  v4 = sub_1002ADB1(v8, v6, a1, v6, 40);
  v5 = 0;
  *(_DWORD *)(a2 - 28) = v4;
  *(_DWORD *)v7 = v4;
  *(_DWORD *)(a2 - 4) = 0;
  sub_10034EE0((void *)v4, &unk_10073C1C, 0x28u);
  while ( 1 )
  {
    if ( v5 < *(_DWORD *)(a2 + 8) )
    {
      v10 = *(_DWORD *)(a2 + 12);
      *(_DWORD *)v10 += 4;
      v12 = *(_DWORD *)v10 + 4;
      v11 = *(_DWORD *)(*(_DWORD *)v10 - 4);
      *(_DWORD *)v10 = v12;
      v9 = *(_DWORD *)(v12 - 4);
      *(_DWORD *)(a2 - 20) = v9;
      if ( v11 > 9 )
      {
        v14 = (unsigned int)sub_10044CA3(v11);
        sub_1002FFF9(a2 - 40, v14);
        v17 = (int)&unk_1006C02C;
        i = a2 - 40;
        goto LABEL_5;
      }
      goto LABEL_6;
    }
    v11 = *(_DWORD *)(a2 - 24);
    if ( sub_10044B3F(*(void **)(a2 - 24)) )
      break;
    sub_10030015(a2 - 64);
    v17 = (int)&unk_1006C09C;
LABEL_5:
    for ( i = a2 - 64; ; i = a2 - 52 )
    {
      sub_100355BB(v9, v17);
LABEL_6:
      if ( sub_10044CBA(v11, v9) )
        break;
      v15 = (unsigned int)sub_10044CA3(v11);
      sub_10030027(a2 - 52, v15);
      v17 = (int)&unk_1006C064;
    }
    *(_DWORD *)(v4 + 4 * v11) = *(_DWORD *)(a2 - 20);
    ++v5;
  }
  sub_10044C5B((void *)v11);
  return sub_10035616(52);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (10044C4C) --------------------------------------------------------
void __userpurge sub_10044C4C(int a1<ebp>, int a2, int a3)
{
  sub_1002A4AA(*(LPVOID *)(a1 - 28));
  JUMPOUT(*(unsigned int *)loc_10044BE8);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10044BE8: using guessed type int __stdcall loc_10044BE8(int, int);

//----- (10044C5B) --------------------------------------------------------
int __thiscall sub_10044C5B(void *this)
{
  int result; // eax@1
  int v2; // edx@1
  void *v3; // edi@1
  int v4; // esi@1
  int v5; // ecx@2

  v3 = this;
  **(_DWORD **)this = 0;
  v2 = sub_1003D68A();
  result = *(_DWORD *)v3;
  v4 = *(_DWORD *)(*(_DWORD *)v3 + 8);
  if ( v4 == -1 )
  {
    v5 = *(_DWORD *)(result + 4);
    if ( v5 == -1 )
    {
      *(_DWORD *)(result + 4) = v2;
      result = *(_DWORD *)v3;
      *(_DWORD *)(*(_DWORD *)v3 + 8) = v2;
    }
    else
    {
      if ( v5 >= (unsigned int)v2 )
        v5 = v2;
      *(_DWORD *)(result + 8) = v5;
    }
  }
  else
  {
    if ( *(_DWORD *)(result + 4) == -1 )
    {
      if ( v4 <= (unsigned int)v2 )
        v4 = v2;
      *(_DWORD *)(result + 4) = v4;
    }
  }
  return result;
}

//----- (10044CA3) --------------------------------------------------------
char *__cdecl sub_10044CA3(unsigned int a1)
{
  signed int v1; // eax@1

  v1 = a1;
  if ( a1 > 0xA )
    v1 = 10;
  return off_10073C44[v1];
}
// 10073C44: using guessed type char *off_10073C44[11];

//----- (10044CBA) --------------------------------------------------------
char __cdecl sub_10044CBA(int a1, signed int a2)
{
  char v2; // cl@1
  char v3; // zf@2

  v2 = 1;
  switch ( a1 )
  {
    case 0:
      goto LABEL_2;
    case 1:
      if ( a2 && (unsigned int)a2 <= 0x7FFFFFFF )
        return v2;
      v3 = a2 == -1;
      goto LABEL_3;
    case 2:
      if ( (unsigned int)a2 <= 0x7FFFFFFF )
        return v2;
      v3 = a2 == -1;
      goto LABEL_3;
    case 3:
      if ( a2 )
        goto LABEL_17;
      goto LABEL_4;
    case 4:
    case 5:
LABEL_17:
      if ( (unsigned int)a2 > 0x7FFFFFFF )
        goto LABEL_4;
      return v2;
    case 6:
      if ( a2 >= -7 && a2 < 7 || a2 == 15 || a2 == -15 )
        return v2;
      v3 = a2 == 61440;
      goto LABEL_3;
    case 7:
      if ( !a2 )
        return v2;
      v3 = a2 == 1;
      goto LABEL_3;
    case 8:
      if ( a2 != 1 )
      {
LABEL_2:
        v3 = a2 == 0;
LABEL_3:
        if ( !v3 )
LABEL_4:
          v2 = 0;
      }
      break;
    case 9:
      if ( a2 )
        v2 = ((a2 != 1) - 1) & 1;
      break;
  }
  return v2;
}

//----- (10044D76) --------------------------------------------------------
int __thiscall sub_10044D76(void *this)
{
  void *v1; // esi@1
  int result; // eax@2
  int v3; // ecx@6
  int v4; // edi@6
  int v5; // esi@6
  int v6; // edx@6
  char v7; // [sp-4h] [bp-14h]@2
  char v8; // [sp+4h] [bp-Ch]@6

  v1 = this;
  if ( !sub_10044B09(this, 2u) )
  {
    v7 = LOBYTE(off_10073C4C[0]);
LABEL_6:
    sub_10030027((int)&v8, v7);
    sub_100355BB((int)&v8, (int)&unk_1006C064);
    __asm { int     3               ; Trap to Debugger }
    v4 = v3;
    v5 = v3 + 120;
    *(_DWORD *)v3 = &off_10064D10;
    sub_10040102(v3 + 12, v6, v3 + 120);
    *(_DWORD *)(v4 + 36) = 0;
    *(_DWORD *)(v4 + 40) = 0;
    *(_DWORD *)(v4 + 60) = 0;
    *(_DWORD *)(v4 + 64) = 0;
    *(_DWORD *)v5 = 0;
    *(_DWORD *)(v4 + 136) = 0;
    *(_DWORD *)(v4 + 144) = 0;
    *(_DWORD *)(v4 + 148) = 0;
    *(_DWORD *)(v4 + 152) = 0;
    *(_DWORD *)(v4 + 156) = 0;
    *(_DWORD *)(v4 + 180) = 0;
    return v4;
  }
  result = sub_10044B09(v1, 8u);
  if ( !result )
    goto LABEL_6;
  return result;
}
// 10064D10: using guessed type int (__stdcall *off_10064D10)(char);
// 10073C4C: using guessed type char *off_10073C4C[9];

//----- (10044E10) --------------------------------------------------------
int __thiscall sub_10044E10(int this)
{
  int v2; // esi@1

  v2 = this;
  sub_100303A3(*(LPVOID *)(this + 12));
  return sub_100303A3(*(LPVOID *)(v2 + 16));
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (10044E27) --------------------------------------------------------
int __usercall sub_10044E27<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int v2; // esi@1
  char v3; // zf@1

  sub_10035648();
  v2 = v1;
  *(_DWORD *)(a1 - 16) = v1;
  *(_DWORD *)v1 = &off_10064D10;
  v3 = *(_DWORD *)(v1 + 80) == 0;
  *(_DWORD *)(a1 - 4) = 1;
  if ( !v3 )
  {
    sub_10033FEE(*(void **)(v1 + 80));
    *(_DWORD *)(v2 + 80) = 0;
  }
  sub_100303A3(*(LPVOID *)(v2 + 156));
  sub_10044E10(v2 + 12);
  return sub_10035616(4);
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 10064D10: using guessed type int (__stdcall *off_10064D10)(char);

//----- (10044E72) --------------------------------------------------------
void *__thiscall sub_10044E72(void *this, char a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1

  v3 = this;
  sub_10044E27(ebp0);
  if ( a2 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10044E91) --------------------------------------------------------
char __thiscall sub_10044E91(int this, unsigned int a2)
{
  char result; // al@1
  signed int v3; // edx@1
  int v4; // edi@1

  v3 = 1 << (a2 & 0x1F);
  v4 = 4 * (a2 >> 5);
  result = (v3 & *(_DWORD *)(v4 + *(_DWORD *)(this + 88))) != 0;
  if ( result )
  {
    _EDX = ~v3;
    _ECX = v4 + *(_DWORD *)(this + 88);
    __asm { lock and [ecx], edx }
  }
  return result;
}

//----- (10044EC8) --------------------------------------------------------
int __thiscall sub_10044EC8(void *this, int a2)
{
  void *v2; // edi@1
  int result; // eax@2

  v2 = this;
  if ( a2 )
  {
    sub_10046C74(a2);
    result = (*(int (__thiscall **)(_DWORD, _DWORD))(*(_DWORD *)a2 + 28))(a2, v2);
  }
  *((_DWORD *)v2 + 28) = a2;
  if ( a2 )
  {
    if ( *(_BYTE *)(a2 + 179) & 1 )
    {
      ++*((_DWORD *)v2 + 24);
      *(_BYTE *)(a2 + 179) &= 0xFEu;
    }
  }
  return result;
}

//----- (10044F05) --------------------------------------------------------
char __thiscall sub_10044F05(int this)
{
  char result; // al@2

  if ( *(_BYTE *)(this + 86) )
  {
    *(_BYTE *)(this + 86) = 0;
    result = 1;
  }
  else
  {
    result = sub_10044E91(**(_DWORD **)(this + 68), *(_DWORD *)(this + 132));
  }
  return result;
}

//----- (10044F49) --------------------------------------------------------
bool __cdecl sub_10044F49(int a1)
{
  bool result; // eax@1

  result = sub_10032DBB(*(_DWORD *)(a1 + 36));
  if ( !result )
  {
    sub_1004502B(*(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    *(_DWORD *)(a1 + 72) = 0;
  }
  return result;
}

//----- (10044F55) --------------------------------------------------------
char __thiscall sub_10044F55(int this, int a2, int a3, char a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  char v7; // al@3
  int v8; // edx@3
  char result; // al@6

  v6 = this;
  v4 = this + 4;
  v5 = *(_DWORD *)(this + 4);
  if ( !(v5 & a3) )
    goto LABEL_6;
  if ( a3 == 15 )
  {
    v8 = *(_DWORD *)v4;
    *(_DWORD *)v4 = 0;
    v7 = v8 != 0;
  }
  else
  {
    while ( 1 )
    {
      _ECX = 0;
      _EDX = v6 + 4;
      __asm { lock cmpxchg [edx], ecx }
      v8 = v5;
      if ( v5 == v5 )
        break;
      if ( !(v5 & a3) )
        goto LABEL_6;
    }
    v7 = 1;
  }
  if ( v7 )
  {
    if ( a4 )
    {
      _EDI = -1;
      _ECX = **(_DWORD **)(v6 + 68) + 428;
      _EAX = -1;
      __asm { lock xadd [ecx], eax }
      _ECX = *(_DWORD *)(v6 + 68) + 28;
      _EAX = -1;
      __asm { lock xadd [ecx], eax }
      if ( v8 == 4 || v8 == 8 )
      {
        _ECX = **(_DWORD **)(v6 + 68) + 432;
        _EAX = -1;
        __asm { lock xadd [ecx], eax }
        _ECX = *(_DWORD *)(v6 + 68) + 32;
        __asm { lock xadd [ecx], edi }
      }
    }
    result = 1;
    *(_DWORD *)a2 = v8;
    *(_DWORD *)(a2 + 4) = v6;
    *(_DWORD *)(v6 + 8) = v8;
  }
  else
  {
LABEL_6:
    result = 0;
  }
  return result;
}

//----- (10044FFA) --------------------------------------------------------
signed int __thiscall sub_10044FFA(int this, int a2)
{
  signed int result; // eax@1

  result = 1;
  if ( *(_DWORD *)((a2 << 7) + *(_DWORD *)(this + 92)) == 1 )
  {
    _EDX = 0;
    _ECX = (a2 << 7) + *(_DWORD *)(this + 92);
    __asm { lock cmpxchg [ecx], edx }
  }
  return result;
}

//----- (1004501F) --------------------------------------------------------
int __thiscall sub_1004501F(int this)
{
  return (*(int (**)(void))(**(_DWORD **)(this + 76) + 24))();
}

//----- (1004502B) --------------------------------------------------------
int __stdcall sub_1004502B(int a1)
{
  int v1; // esi@1
  int v2; // ecx@2
  int result; // eax@3

  v1 = a1;
  while ( v1 )
  {
    v2 = v1 - 176;
    v1 = *(_DWORD *)v1;
    if ( v2 )
      result = (**(int (__stdcall ***)(_DWORD))v2)(1);
  }
  return result;
}

//----- (1004504F) --------------------------------------------------------
int __thiscall sub_1004504F(int this)
{
  return (*(int (**)(void))(**(_DWORD **)(this + 76) + 28))();
}

//----- (1004505B) --------------------------------------------------------
char __thiscall sub_1004505B(int this, int a2, int a3, int a4)
{
  int v4; // edi@1
  int v5; // esi@1
  char result; // al@3
  int v7; // eax@8

  v5 = this;
  v4 = **(_DWORD **)(this + 68);
  if ( a2 == 1 || a2 == 4 )
  {
    if ( sub_10034793(v4, 1) )
    {
      v7 = a3;
      if ( !a3 )
        v7 = sub_10032799(v4);
      result = (*(int (__thiscall **)(_DWORD, _DWORD, _DWORD))(*(_DWORD *)v5 + 28))(v5, v7, a4);
    }
    else
    {
      if ( a4 )
        sub_10033ABD(v4, a4, 1);
      sub_100452D8(v5, a2, 0);
      result = 0;
    }
  }
  else
  {
    (*(void (__stdcall **)(_DWORD))(**(_DWORD **)(this + 76) + 20))(*(_DWORD *)(this + 116));
    result = 1;
  }
  return result;
}

//----- (100450CF) --------------------------------------------------------
char __thiscall sub_100450CF(int this, int a2)
{
  char result; // al@1
  int v3; // esi@1

  v3 = this;
  result = 0;
  if ( *(_DWORD *)this )
  {
    result = sub_1004505B(
               *(_DWORD *)(this + 4),
               *(_DWORD *)this,
               *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 4) + 68) + 4) + 8),
               a2);
    *(_DWORD *)v3 = 0;
  }
  return result;
}

//----- (100450FA) --------------------------------------------------------
int __usercall sub_100450FA<eax>(int a1<ecx>, int a2<ebp>, int a3<edi>)
{
  int v3; // esi@1

  v3 = a1;
  if ( !*(_DWORD *)(a1 + 80) )
    *(_DWORD *)(a1 + 80) = sub_10032C48(a2, a3);
  return *(_DWORD *)(v3 + 80);
}

//----- (10045113) --------------------------------------------------------
int __thiscall sub_10045113(int this, int a2, int a3)
{
  int v3; // ebx@1
  int *v4; // eax@1
  int v5; // edi@1
  int v6; // eax@1
  int v7; // eax@1
  int v9; // eax@4
  int v10; // eax@4
  int v11; // esi@4
  int v12; // ST0C_4@4
  int v13; // eax@4
  int v14; // [sp-4h] [bp-20h]@2
  char v15; // [sp+Ch] [bp-10h]@4
  int v16; // [sp+24h] [bp+8h]@1

  v3 = this;
  *(_DWORD *)(this + 184) = 0;
  *(_DWORD *)(this + 108) = 0;
  *(_DWORD *)(this + 68) = a2;
  *(_DWORD *)(this + 204) = 1;
  *(_DWORD *)(this + 192) = 1;
  *(_DWORD *)(this + 72) = *(_DWORD *)(a2 + 4);
  v4 = *(int **)(this + 68);
  *(_WORD *)(this + 160) = 0;
  *(_DWORD *)(this + 76) = a3;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 92) = 0;
  *(_DWORD *)(this + 96) = 0;
  *(_DWORD *)(this + 100) = 0;
  *(_DWORD *)(this + 104) = 0;
  *(_DWORD *)(this + 112) = 0;
  *(_DWORD *)(this + 164) = 0;
  *(_DWORD *)(this + 180) = 0;
  *(_DWORD *)(this + 80) = 0;
  *(_WORD *)(this + 84) = 0;
  *(_BYTE *)(this + 86) = 1;
  v5 = *v4;
  v16 = *v4;
  *(_DWORD *)(this + 124) = (*(int (__thiscall **)(int))(*(_DWORD *)a3 + 16))(a3);
  v6 = (*(int (__thiscall **)(int))(*(_DWORD *)a3 + 4))(a3);
  *(_DWORD *)(v3 + 128) = v6;
  *(_DWORD *)(v3 + 132) = sub_10032C17(v5, v6);
  v7 = sub_1003D68A();
  sub_10032CCC((void *)(v3 + 152), v7);
  sub_100458C6(v3 + 152);
  *(_DWORD *)(*(_DWORD *)(v3 + 156) + 4 * (*(_DWORD *)(v3 + 132) >> 5)) |= 1 << (*(_DWORD *)(v3 + 132) & 0x1F);
  if ( *(_DWORD *)(v16 + 12) )
    v14 = 2;
  else
    v14 = 1;
  sub_10051D7C(v3 + 36, v3, v14);
  v9 = (*(int (**)(void))(***(_DWORD ***)(v3 + 68) + 4))();
  v10 = sub_1004D6B9((int)&v15, 3, *(_DWORD *)(v3 + 128), v9, v3);
  sub_1002F3E5(v3 + 136, v10);
  v11 = *(_DWORD *)(v3 + 132);
  sub_10045292(v16 + 72, *(_DWORD *)(v3 + 132));
  sub_10044FFA(v16, v11);
  v12 = *(_DWORD *)(v3 + 124);
  v13 = (*(int (**)(void))(***(_DWORD ***)(v3 + 68) + 4))();
  return sub_1004583B(1, 4, v13, v12);
}

//----- (10045250) --------------------------------------------------------
int __thiscall sub_10045250(int this, unsigned int a2)
{
  int v2; // ebx@1
  int v3; // esi@1

  v2 = this;
  _ESI = -1;
  _EAX = *(_DWORD *)(this + 8) + 4 * a2;
  __asm { lock xadd [eax], esi }
  v3 = _ESI - 1;
  if ( !v3 )
  {
    sub_100456EF(this, a2);
    _EDX = ~(1 << (a2 & 0x1F));
    _ECX = *(_DWORD *)(v2 + 4) + 4 * (a2 >> 5);
    __asm { lock and [ecx], edx }
  }
  return v3;
}

//----- (10045292) --------------------------------------------------------
int __thiscall sub_10045292(int this, unsigned int a2)
{
  int v2; // esi@1
  int v13; // [sp+Ch] [bp-4h]@1

  v13 = this;
  _EAX = *(_DWORD *)(this + 8) + 4 * a2;
  _ESI = 1;
  __asm { lock xadd [eax], esi }
  v2 = _ESI + 1;
  if ( v2 == 1 )
  {
    sub_100456A7(this, a2);
    _EDI = 1 << (a2 & 0x1F);
    _ECX = *(_DWORD *)(v13 + 4) + 4 * (a2 >> 5);
    __asm { lock or [ecx], edi }
  }
  return v2;
}

//----- (100452D8) --------------------------------------------------------
int __thiscall sub_100452D8(int this, int a2, char a3)
{
  int v4; // edi@1
  int result; // eax@8

  v4 = this;
  _EBX = 1;
  *(_DWORD *)(this + 116) = *(_DWORD *)(this + 112);
  if ( a3 )
  {
    if ( a2 == 1 || a2 == 4 )
      sub_10034793(**(_DWORD **)(this + 68), 0);
  }
  _ECX = **(_DWORD **)(v4 + 68) + 428;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  _ECX = *(_DWORD *)(v4 + 68) + 28;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  if ( a2 == 4 || a2 == 8 )
  {
    _ECX = **(_DWORD **)(v4 + 68) + 432;
    _EAX = 1;
    __asm { lock xadd [ecx], eax }
    _EAX = *(_DWORD *)(v4 + 68) + 32;
    __asm { lock xadd [eax], ebx }
  }
  result = v4 + 4;
  *(_DWORD *)(v4 + 4) = a2;
  return result;
}

//----- (10045356) --------------------------------------------------------
char __thiscall sub_10045356(int this)
{
  char result; // al@1
  int v2; // esi@1
  int v3; // ecx@5
  int v4; // ST00_4@5
  int v5; // [sp+4h] [bp-8h]@1
  int v6; // [sp+8h] [bp-4h]@5

  v5 = 0;
  v2 = this;
  result = sub_10044F55(this, (int)&v5, 15, 1);
  if ( result )
  {
    if ( v5 == 2 || v5 == 8 )
    {
      v3 = v6;
      v4 = v5;
      *(_BYTE *)(v2 + 161) = 1;
      result = sub_1004505B(v3, v4, 0, 0);
    }
    else
    {
      result = (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 12))(v2);
    }
  }
  else
  {
    *(_BYTE *)(v2 + 161) = 1;
  }
  return result;
}

//----- (100453AA) --------------------------------------------------------
int __thiscall sub_100453AA(int this)
{
  int v2; // esi@1
  int v3; // eax@1

  v2 = this;
  v3 = (*(int (__stdcall **)(_DWORD))(**(_DWORD **)(**(_DWORD **)(this + 68) + 420) + 20))(*(_DWORD *)(this + 76));
  return sub_10045C60(*(void **)(v2 + 68), v3, 1);
}

//----- (100453CD) --------------------------------------------------------
signed int __thiscall sub_100453CD(int this)
{
  signed int v1; // ebx@1
  int v2; // edi@1
  int v3; // eax@1
  int v4; // edx@1
  int v5; // eax@1
  signed int result; // eax@5

  v3 = *(_DWORD *)(this + 12);
  v2 = *(_DWORD *)(this + 4) - 1;
  v4 = v2 & *(_DWORD *)(this + 8);
  *(_DWORD *)(this + 4) = v2;
  v5 = v3 + 4 * v4;
  v1 = *(_DWORD *)v5;
  *(_DWORD *)v5 = 0;
  if ( !v1 )
    *(_DWORD *)(this + 4) = v2 + 1;
  if ( !(v1 & 1) || (v1 &= 0xFFFFFFFEu, sub_1002E690(*(_DWORD *)(this + 16) + 8 * (v2 & *(_DWORD *)(this + 8)), 0)) )
    result = v1;
  else
    result = 1;
  return result;
}

//----- (1004541B) --------------------------------------------------------
char __thiscall sub_1004541B(void *ListHead, int a2, signed int a3, char a4)
{
  signed int v4; // edx@1
  int v6; // esi@1
  char result; // al@2
  int v8; // eax@3
  int v9; // ecx@3
  int v10; // edx@4
  int v11; // edi@4
  int v12; // edx@5
  PSINGLE_LIST_ENTRY v18; // eax@14
  int v19; // ST08_4@14

  v6 = (int)ListHead;
  v4 = a3 >> *((_DWORD *)ListHead + 11);
  _EBX = a3 & (*((_DWORD *)ListHead + 10) - 1);
  if ( v4 < *((_DWORD *)ListHead + 15) )
  {
    v9 = *((_DWORD *)ListHead + 14);
    v8 = *(_DWORD *)(v6 + 52);
    if ( v4 < v9 )
    {
      v11 = *(_DWORD *)(v8 + 4 * v4);
    }
    else
    {
      v10 = v4 - v9;
      v11 = *(_DWORD *)(v8 + 4 * v9 - 4);
      if ( v10 >= 0 )
      {
        v12 = v10 + 1;
        do
        {
          v11 = *(_DWORD *)(v11 + 4);
          --v12;
        }
        while ( v12 );
      }
    }
    _ECX = *(_DWORD *)v11 + 4 * _EBX;
    _EDX = 0;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 == a2 )
    {
      _ECX = v11 + 8;
      __asm { lock cmpxchg [ecx], ebx }
      if ( a4 )
      {
        if ( (signed int)QueryDepthSList((PSLIST_HEADER)v6) <= *(_DWORD *)(v6 + 68) )
        {
          InterlockedPushEntrySList((PSLIST_HEADER)v6, (PSINGLE_LIST_ENTRY)(a2 + 176));
        }
        else
        {
          InterlockedPushEntrySList((PSLIST_HEADER)(v6 + 8), (PSINGLE_LIST_ENTRY)(a2 + 176));
          if ( (signed int)QueryDepthSList((PSLIST_HEADER)(v6 + 8)) > *(_DWORD *)(v6 + 68) )
          {
            if ( !sub_10032DBB(*(_DWORD *)(v6 + 36)) )
            {
              _EDX = 1;
              _ECX = v6 + 72;
              __asm { lock cmpxchg [ecx], edx }
              v18 = InterlockedFlushSList((PSLIST_HEADER)(v6 + 8));
              v19 = *(_DWORD *)(v6 + 36);
              *(_DWORD *)(v6 + 16) = v18;
              sub_100333A7(v6 + 20, (int (__cdecl *)(_DWORD))sub_10044F49, v6, v19);
            }
          }
        }
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10045516) --------------------------------------------------------
char __thiscall sub_10045516(int this)
{
  int v2; // edi@1
  int v16; // ecx@5
  int v17; // ebx@6
  int v18; // edi@9
  int v19; // esi@10
  int v20; // esi@15
  int v21; // eax@15
  int v22; // ecx@15
  int v23; // eax@15
  int v24; // ecx@15
  int v25; // eax@15
  int v27; // ecx@17
  char v28; // [sp-10h] [bp-24h]@10
  int v29; // [sp-Ch] [bp-20h]@10
  int v30; // [sp-8h] [bp-1Ch]@10
  int v31; // [sp-4h] [bp-18h]@10
  int v32; // [sp+Ch] [bp-8h]@1
  int v33; // [sp+10h] [bp-4h]@5

  v2 = this;
  v32 = this;
  sub_10033E49(**(_DWORD **)(this + 68), this + 192);
  sub_10045250(**(_DWORD **)(v2 + 68) + 48, *(_DWORD *)(v2 + 132));
  _EDX = -1;
  _ECX = *(_DWORD *)(v2 + 68) + 36;
  _EAX = -1;
  __asm { lock xadd [ecx], eax }
  if ( !*(_BYTE *)(v2 + 160) )
  {
    _EAX = **(_DWORD **)(v2 + 68) + 20;
    __asm { lock xadd [eax], edx }
  }
  sub_1004566D(**(void ***)(v2 + 68), v2);
  if ( !*(_BYTE *)(v2 + 84) )
    sub_10045250(**(_DWORD **)(v2 + 68) + 72, *(_DWORD *)(v2 + 132));
  *(_DWORD *)(v2 + 112) = 0;
  v16 = *(_DWORD *)(v2 + 16) - *(_DWORD *)(v2 + 12);
  v33 = v2 + 12;
  if ( v16 <= 0 )
    v17 = 0;
  else
    v17 = sub_100453CD(v2 + 12);
  if ( v17 )
  {
    v18 = v33;
    do
    {
      v19 = sub_1003D43F(v17 + 4);
      sub_1002F3E5((int)&v28, v19 + 12);
      sub_10040BA5((void *)v19, v17, v28, v29, v30, v31);
      if ( *(_DWORD *)(v18 + 4) - *(_DWORD *)v18 <= 0 )
        v17 = 0;
      else
        v17 = sub_100453CD(v18);
    }
    while ( v17 );
    v2 = v32;
  }
  v20 = **(_DWORD **)(v2 + 76);
  v21 = (*(int (**)(void))(***(_DWORD ***)(v2 + 68) + 52))();
  v22 = *(_DWORD *)(v2 + 76);
  v31 = v21;
  (*(void (__thiscall **)(int))(v20 + 8))(v22);
  v23 = *(_DWORD *)(v2 + 68);
  *(_DWORD *)(v2 + 76) = 0;
  v24 = *(_DWORD *)v23;
  v30 = *(_DWORD *)(v2 + 124);
  v25 = (*(int (__stdcall **)(int))(*(_DWORD *)v24 + 4))(v30);
  sub_1004583B(2, 4, v25, v31);
  if ( *(_DWORD *)(v2 + 80) )
  {
    v31 = *(_DWORD *)(v2 + 80);
    sub_10033FEE((void *)v31);
    *(_DWORD *)(v2 + 80) = 0;
  }
  v27 = *(_DWORD *)(v2 + 68);
  v31 = 1;
  v30 = *(_DWORD *)(v2 + 88);
  return sub_1004541B((void *)(v27 + 56), v2, v30, 1);
}

//----- (10045659) --------------------------------------------------------
char __thiscall sub_10045659(int this)
{
  return sub_10033480(**(_DWORD **)(this + 68), this + 180);
}

//----- (1004566D) --------------------------------------------------------
int __thiscall sub_1004566D(void *this, int a2)
{
  int result; // eax@1
  int v3; // esi@1
  void *v5; // edi@1

  v3 = a2;
  _EDX = *(_DWORD *)(a2 + 92) - *(_DWORD *)(a2 + 100);
  v5 = this;
  *(_DWORD *)(a2 + 100) = *(_DWORD *)(a2 + 92);
  _EAX = (int)((char *)this + 436);
  __asm { lock xadd [eax], edx }
  _ECX = *(_DWORD *)(v3 + 96) - *(_DWORD *)(v3 + 104);
  *(_DWORD *)(v3 + 104) = *(_DWORD *)(v3 + 96);
  result = (int)((char *)v5 + 440);
  __asm { lock xadd [eax], ecx }
  return result;
}

//----- (100456A7) --------------------------------------------------------
int __thiscall sub_100456A7(int this, unsigned int a2)
{
  int result; // eax@1
  int v3; // ebx@1
  signed int v4; // edi@1
  char v5; // [sp+Ch] [bp-10h]@3
  int v6; // [sp+14h] [bp-8h]@2
  void (__cdecl *v7)(); // [sp+18h] [bp-4h]@2

  v3 = *(_DWORD *)(this + 4);
  v4 = 1 << (a2 & 0x1F);
  result = *(_DWORD *)(v3 + 4 * (a2 >> 5));
  if ( result & v4 )
  {
    v6 = 0;
    v7 = sub_10034BB6;
    while ( 1 )
    {
      result = *(_DWORD *)(v3 + 4 * (a2 >> 5));
      if ( !(result & v4) )
        break;
      sub_100282E0((int)&v5);
    }
  }
  return result;
}

//----- (100456EF) --------------------------------------------------------
int __thiscall sub_100456EF(int this, unsigned int a2)
{
  int result; // eax@1
  int v3; // ebx@1
  signed int v4; // edi@1
  char v5; // [sp+Ch] [bp-10h]@3
  int v6; // [sp+14h] [bp-8h]@2
  void (__cdecl *v7)(); // [sp+18h] [bp-4h]@2

  v3 = *(_DWORD *)(this + 4);
  v4 = 1 << (a2 & 0x1F);
  result = *(_DWORD *)(v3 + 4 * (a2 >> 5));
  if ( !(result & v4) )
  {
    v6 = 0;
    v7 = sub_10034BB6;
    while ( 1 )
    {
      result = *(_DWORD *)(v3 + 4 * (a2 >> 5));
      if ( result & v4 )
        break;
      sub_100282E0((int)&v5);
    }
  }
  return result;
}

//----- (10045737) --------------------------------------------------------
char __thiscall sub_10045737(int this, int a2, int a3)
{
  int v3; // esi@1
  int v4; // edi@4
  char result; // al@9
  char v6; // [sp+Ch] [bp-10h]@3
  int v7; // [sp+14h] [bp-8h]@2
  void (__cdecl *v8)(); // [sp+18h] [bp-4h]@2

  v3 = this;
  if ( *(_DWORD *)(this + 112) )
  {
    v7 = 0;
    v8 = sub_10034BB6;
    do
      sub_100282E0((int)&v6);
    while ( *(_DWORD *)(v3 + 112) );
  }
  v4 = a3;
  if ( a3 )
  {
    if ( !*(_DWORD *)(a3 + 28) )
      sub_10046AE2(a3, a2, 0, 0);
  }
  else
  {
    v4 = sub_10040FD9((void *)a2, 0, 0);
  }
  if ( v4 )
  {
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 16))(v3, v4);
    (*(void (__thiscall **)(_DWORD, _DWORD))(**(_DWORD **)(v3 + 76) + 20))(*(_DWORD *)(v3 + 76), *(_DWORD *)(v3 + 112));
    result = 1;
  }
  else
  {
    sub_100452D8(v3, 4, 1);
    sub_10032222(**(_DWORD **)(v3 + 68));
    result = 0;
  }
  return result;
}

//----- (100457C0) --------------------------------------------------------
int __cdecl sub_100457C0(char a1, char a2, int a3, int a4)
{
  int v4; // ebx@1
  int result; // eax@2
  __int16 v6; // [sp+4h] [bp-40h]@2
  char v7; // [sp+6h] [bp-3Eh]@2
  char v8; // [sp+8h] [bp-3Ch]@2
  char v9; // [sp+9h] [bp-3Bh]@2
  int v10; // [sp+1Ch] [bp-28h]@2
  int v11; // [sp+20h] [bp-24h]@2
  int v12; // [sp+24h] [bp-20h]@2
  int v13; // [sp+28h] [bp-1Ch]@2
  int v14; // [sp+30h] [bp-14h]@2
  int v15; // [sp+34h] [bp-10h]@2
  int v16; // [sp+38h] [bp-Ch]@2

  v4 = dword_100755B8;
  if ( dword_100755B8 )
  {
    sub_100391F0(&v7, 0, 62);
    v14 = 131072;
    v6 = 64;
    v8 = a1;
    v9 = a2;
    v10 = dword_100672F4[0];
    v11 = dword_100672F4[1];
    v12 = dword_100672F4[2];
    v13 = dword_100672F4[3];
    v16 = a3;
    v15 = a4;
    result = sub_10030F55(v4, dword_100755B0, dword_100755B4, (int)&v6);
  }
  return result;
}
// 100755B0: using guessed type int dword_100755B0;
// 100755B4: using guessed type int dword_100755B4;
// 100755B8: using guessed type int dword_100755B8;

//----- (10045831) --------------------------------------------------------
int __stdcall sub_10045831(int a1)
{
  return a1;
}

//----- (1004583B) --------------------------------------------------------
int __stdcall sub_1004583B(char a1, char a2, int a3, int a4)
{
  int result; // eax@2

  if ( a2 <= (unsigned __int8)byte_100755AC )
  {
    result = dword_100755A8;
    if ( dword_100755A8 & 4 )
      result = sub_100457C0(a1, a2, a3, a4);
  }
  return result;
}
// 100755A8: using guessed type int dword_100755A8;
// 100755AC: using guessed type char byte_100755AC;

//----- (10045868) --------------------------------------------------------
char __thiscall sub_10045868(int this, char a2, char a3)
{
  int v3; // eax@1
  int v4; // edi@1
  int v5; // esi@3
  unsigned int v6; // ST00_4@3
  char result; // al@6
  int v8; // [sp+8h] [bp-4h]@1

  v4 = this;
  v3 = **(_DWORD **)(this + 68);
  v8 = **(_DWORD **)(this + 68);
  if ( *(_BYTE *)(this + 84) )
  {
    if ( !a2 )
    {
      v5 = *(_DWORD *)(this + 132);
      v6 = *(_DWORD *)(this + 132);
      *(_BYTE *)(this + 86) = 1;
      sub_10045292(v3 + 72, v6);
      sub_10044FFA(v8, v5);
    }
  }
  else
  {
    if ( a2 )
      sub_10045250(v3 + 72, *(_DWORD *)(this + 132));
  }
  result = a3;
  *(_BYTE *)(v4 + 84) = a2;
  *(_BYTE *)(v4 + 85) = a3;
  return result;
}

//----- (100458C6) --------------------------------------------------------
int __thiscall sub_100458C6(int this)
{
  unsigned int v1; // edx@1
  unsigned int v2; // esi@1
  int result; // eax@2

  v1 = (unsigned int)(*(_DWORD *)this + 31) >> 5;
  v2 = 0;
  if ( v1 )
  {
    do
    {
      result = *(_DWORD *)(this + 4);
      *(_DWORD *)(result + 4 * v2++) = 0;
    }
    while ( v2 < v1 );
  }
  return result;
}

//----- (100458E3) --------------------------------------------------------
int __thiscall sub_100458E3(void *ListHead, int a2, signed int a3, int a4)
{
  int v4; // edx@1
  int v5; // edi@1
  int v6; // edx@2
  int v7; // edx@2
  int v8; // eax@3
  int v10; // esi@3
  signed __int64 v12; // qax@3
  int v13; // edx@3
  signed int v14; // ecx@6
  signed __int64 v15; // qax@6
  int v16; // eax@6
  int v17; // ecx@6
  int v18; // eax@7

  v4 = a3;
  v5 = (int)ListHead;
  *((_DWORD *)ListHead + 9) = a2;
  *((_DWORD *)ListHead + 17) = a4;
  *((_DWORD *)ListHead + 4) = 0;
  *((_DWORD *)ListHead + 11) = 0;
  *((_DWORD *)ListHead + 12) = 0;
  *((_DWORD *)ListHead + 14) = 512;
  *((_DWORD *)ListHead + 15) = 1;
  *((_DWORD *)ListHead + 16) = 0;
  *((_DWORD *)ListHead + 18) = 0;
  if ( (v4 - 1) & v4 )
  {
    v6 = (((a3 >> 1) | a3) >> 2) | (a3 >> 1) | a3;
    v7 = (((v6 >> 4) | v6) >> 8) | (v6 >> 4) | v6;
    v4 = ((v7 >> 16) | v7) + 1;
  }
  *((_DWORD *)ListHead + 10) = v4;
  _ECX = 0;
  v12 = 4i64 * (unsigned int)v4;
  __asm { seto    cl }
  _QCX = (_DWORD)v12 | (unsigned int)-_ECX;
  v10 = sub_1002965B(SHIDWORD(v12), _QCX, SHIDWORD(_QCX), v5, _QCX);
  sub_100391F0((void *)v10, 0, 4 * *(_DWORD *)(v5 + 40));
  v8 = sub_1002ADB1(v13, _QCX, SHIDWORD(_QCX), v5, 12);
  if ( v8 )
  {
    *(_DWORD *)(v8 + 8) = -1;
    *(_DWORD *)v8 = v10;
    *(_DWORD *)(v8 + 4) = 0;
  }
  else
  {
    v8 = 0;
  }
  *(_DWORD *)(v5 + 48) = v8;
  LODWORD(_QCX) = 0;
  v15 = 4i64 * *(_DWORD *)(v5 + 56);
  __asm { seto    cl }
  v16 = sub_1002965B(SHIDWORD(v15), v15 | -(_DWORD)_QCX, SHIDWORD(_QCX), v5, v15 | -(_DWORD)_QCX);
  v17 = *(_DWORD *)(v5 + 48);
  *(_DWORD *)(v5 + 52) = v16;
  *(_DWORD *)v16 = v17;
  InitializeSListHead((PSLIST_HEADER)v5);
  InitializeSListHead((PSLIST_HEADER)(v5 + 8));
  v14 = *(_DWORD *)(v5 + 40) >> 1;
  if ( v14 )
  {
    v18 = *(_DWORD *)(v5 + 44);
    do
    {
      ++v18;
      v14 >>= 1;
    }
    while ( v14 );
    *(_DWORD *)(v5 + 44) = v18;
  }
  return v5;
}

//----- (100459D4) --------------------------------------------------------
int __userpurge sub_100459D4<eax>(int a1<ebp>, int a2, int a3, int a4)
{
  int v5; // ecx@1
  int v6; // edi@1
  int *v7; // esi@1
  int v8; // ST08_4@1
  int v9; // eax@1
  int v10; // ST00_4@1
  int v11; // ecx@1

  sub_10035648();
  v6 = v5;
  *(_DWORD *)(a1 - 16) = v5;
  v7 = *(int **)(a1 + 16);
  v8 = *(_DWORD *)(a1 + 8);
  v5 += 8;
  *(_DWORD *)(v6 + 4) = v7;
  *(_DWORD *)v5 = 0;
  *(_DWORD *)(v5 + 4) = 0;
  sub_10032153(v5, v6, v8);
  *(_DWORD *)(a1 - 4) = 0;
  sub_1002E0B5(v6 + 16, 0, v6, 0x1001u);
  v9 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(v6 + 28) = 0;
  *(_DWORD *)(v6 + 32) = 0;
  *(_DWORD *)(v6 + 36) = 0;
  *(_DWORD *)(v6 + 40) = 0;
  *(_DWORD *)(v6 + 44) = v9;
  v10 = *v7;
  *(_BYTE *)(a1 - 4) = 1;
  sub_100458E3((void *)(v6 + 56), v10, 256, 2147483647);
  v11 = *(_DWORD *)(v6 + 4);
  *(_DWORD *)v6 = *(_DWORD *)v11;
  *(_DWORD *)(v6 + 48) = *(_DWORD *)(v11 + 184);
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (10045A51) --------------------------------------------------------
int __thiscall sub_10045A51(PSLIST_HEADER ListHead)
{
  int v1; // ebx@1
  PSLIST_HEADER v2; // edi@1
  int v3; // eax@1
  int v4; // eax@1
  int i; // esi@2
  int v6; // ecx@3
  int v7; // esi@6

  v2 = ListHead;
  v3 = (int)InterlockedFlushSList(ListHead);
  sub_1004502B(v3);
  v4 = (int)InterlockedFlushSList(v2 + 1);
  sub_1004502B(v4);
  sub_1004502B(LODWORD(v2[2].Alignment));
  v1 = LODWORD(v2[6].Alignment);
  if ( v1 )
  {
    do
    {
      for ( i = 0; i < LODWORD(v2[5].Alignment); ++i )
      {
        v6 = *(_DWORD *)(*(_DWORD *)v1 + 4 * i);
        if ( v6 )
          (**(void (__stdcall ***)(_DWORD))v6)(1);
      }
      v7 = *(_DWORD *)(v1 + 4);
      sub_100303A3(*(LPVOID *)v1);
      sub_1002A4AA((LPVOID)v1);
      v1 = v7;
    }
    while ( v7 );
  }
  return sub_100303A3(HIDWORD(v2[6].Alignment));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (10045AC7) --------------------------------------------------------
int __usercall sub_10045AC7<eax>(int a1<ebp>)
{
  int v2; // ecx@1
  int v3; // edi@1

  sub_10035648();
  v3 = v2;
  *(_DWORD *)(a1 - 16) = v2;
  *(_DWORD *)(a1 - 4) = 1;
  sub_10045A51((PSLIST_HEADER)(v2 + 56));
  sub_1002F39B(v3 + 16);
  sub_100303A3(*(LPVOID *)(v3 + 24));
  sub_100303A3(*(LPVOID *)(v3 + 12));
  return sub_10035616(4);
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (10045B07) --------------------------------------------------------
int __thiscall sub_10045B07(int this, int a2)
{
  signed int v2; // eax@1
  int v3; // edx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // edx@3
  int v12; // ecx@11
  signed __int64 v15; // qax@11
  signed int v16; // ST0C_4@11
  int v17; // edx@11
  int v18; // ecx@11
  int v19; // eax@12
  int v28; // edx@17
  char v30; // [sp+Ch] [bp-20h]@22
  int v31; // [sp+14h] [bp-18h]@21
  BOOL (__cdecl *v32)(); // [sp+18h] [bp-14h]@21
  int v33; // [sp+1Ch] [bp-10h]@5
  int v34; // [sp+20h] [bp-Ch]@2
  int v35; // [sp+24h] [bp-8h]@1
  char v36; // [sp+2Bh] [bp-1h]@1

  v5 = this;
  v3 = *(_DWORD *)(this + 48);
  v36 = 0;
  v4 = 0;
  v35 = v3;
  v2 = 4;
  do
  {
    _EBX = v3 + 8;
    v34 = v3 + 8;
    if ( *(_DWORD *)(v3 + 8) >= -1 )
    {
      _EBX = *(_DWORD *)v3;
      v7 = 0;
      if ( *(_DWORD *)(v5 + 40) <= 0 )
      {
LABEL_7:
        _EBX = v34;
      }
      else
      {
        while ( *(_DWORD *)_EBX )
        {
          ++v7;
          _EBX += v2;
          if ( v7 >= *(_DWORD *)(v5 + 40) )
            goto LABEL_7;
        }
        _ECX = a2;
        *(_DWORD *)(a2 + 88) = v7 + v4;
        v33 = *(_DWORD *)(v5 + 64);
        __asm { lock cmpxchg [ebx], ecx }
        v4 += v7;
        v36 = 1;
        if ( v4 >= v33 )
        {
          _EAX = v5 + 64;
          _ECX = 1;
          __asm { lock xadd [eax], ecx }
        }
        _EBX = v34;
        _ECX = -1;
        __asm { lock cmpxchg [ebx], ecx }
      }
      v3 = v35;
    }
    if ( !v36 )
    {
      _ECX = -2;
      __asm { lock cmpxchg [ebx], ecx }
      v4 += *(_DWORD *)(v5 + 40);
      _EBX = v3 + 4;
      if ( !*(_DWORD *)(v3 + 4) )
      {
        _ECX = 1;
        __asm { lock cmpxchg [ebx], ecx }
        _ECX = 0;
        v15 = 4i64 * *(_DWORD *)(v5 + 40);
        __asm { seto    cl }
        v16 = 4 * *(_DWORD *)(v5 + 40);
        v33 = sub_1002965B(SHIDWORD(v15), v15 | -_ECX, _EBX, v4, v15 | -_ECX);
        sub_100391F0((void *)v33, 0, v16);
        v12 = sub_1002ADB1(v17, v18, _EBX, v4, 12);
        if ( v12 )
        {
          v19 = v33;
          *(_DWORD *)(v12 + 4) = 0;
          *(_DWORD *)(v12 + 8) = -1;
          *(_DWORD *)v12 = v19;
        }
        else
        {
          v12 = 0;
        }
        v28 = *(_DWORD *)(v5 + 60);
        if ( v28 < *(_DWORD *)(v5 + 56) )
        {
          *(_DWORD *)(*(_DWORD *)(v5 + 52) + 4 * v28) = v12;
          ++*(_DWORD *)(v5 + 60);
        }
        *(_DWORD *)_EBX = v12;
        v3 = v35;
      }
      if ( *(_DWORD *)_EBX == 1 )
      {
        v31 = 0;
        v32 = sub_10034BF4;
        do
          sub_100282E0((int)&v30);
        while ( *(_DWORD *)_EBX == 1 );
        v3 = v35;
      }
    }
    v3 = *(_DWORD *)(v3 + 4);
    v35 = v3;
    v2 = 4;
  }
  while ( !v36 );
  return v4;
}

//----- (10045C60) --------------------------------------------------------
int __thiscall sub_10045C60(void *this, int a2, char a3)
{
  PSINGLE_LIST_ENTRY v3; // eax@1
  int v4; // ebx@1
  int *v5; // edi@1
  int v6; // esi@2
  int v14; // ecx@11

  v5 = (int *)this;
  v4 = (int)sub_10032356();
  v3 = InterlockedPopEntrySList((PSLIST_HEADER)v5 + 7);
  if ( v3 && (v6 = (int)&v3[-44], v3 != (PSINGLE_LIST_ENTRY)176) )
    (*(void (__thiscall **)(int, int *, int))(*(_DWORD *)v6 + 24))(v6, v5, a2);
  else
    v6 = (*(int (__stdcall **)(int *, int))(*(_DWORD *)*v5 + 92))(v5, a2);
  if ( a3 )
  {
    *(_BYTE *)(v6 + 160) = 1;
    *(_DWORD *)(v6 + 164) = v4 - 4;
    *(_DWORD *)(v4 - 4 + 164) = v6;
  }
  _EAX = (int)(v5 + 9);
  _ECX = 1;
  __asm { lock xadd [eax], ecx }
  sub_10045292(*v5 + 48, *(_DWORD *)(v6 + 132));
  if ( *(_DWORD *)(*v5 + 428) != *(_DWORD *)(*v5 + 432) || *(_DWORD *)(*v5 + 20) <= 0 )
  {
    sub_10045B07((int)(v5 + 14), v6);
    sub_100452D8(v6, 1, 0);
  }
  else
  {
    sub_10045B07((int)(v5 + 14), v6);
    if ( sub_10034793(*v5, 1) )
    {
      if ( v4 )
        v14 = sub_1003D43F(v4);
      else
        v14 = *(_DWORD *)(v5[1] + 8);
      (*(void (__thiscall **)(int, int, _DWORD))(*(_DWORD *)v6 + 28))(v6, v14, 0);
    }
  }
  return v6;
}

//----- (10045D49) --------------------------------------------------------
int __thiscall sub_10045D49(int this, int a2)
{
  signed int v2; // edi@1
  signed int v3; // esi@1
  int v4; // eax@2
  int result; // eax@3
  int i; // [sp+Ch] [bp-4h]@2

  v2 = *(_DWORD *)(this + 120);
  v3 = 0;
  if ( v2 <= 0 )
  {
LABEL_7:
    result = 0;
  }
  else
  {
    v4 = this + 56;
    for ( i = this + 56; ; v4 = i )
    {
      result = sub_100318B8(v4, v3);
      if ( result )
      {
        if ( *(_DWORD *)(result + 76) == a2 )
          break;
      }
      ++v3;
      if ( v3 >= v2 )
        goto LABEL_7;
    }
  }
  return result;
}

//----- (10045D86) --------------------------------------------------------
int __thiscall sub_10045D86(void *this, int a2)
{
  void *v2; // ebx@1
  int result; // eax@2
  signed int v4; // esi@5

  v2 = this;
  if ( (*(_DWORD *)a2 & 0xFFFFFFF) == 3 )
  {
    if ( *(_DWORD *)(a2 + 4) == *(_DWORD *)(*(_DWORD *)this + 372) )
    {
      result = *(_DWORD *)(a2 + 12);
    }
    else
    {
      v4 = 0;
      if ( *((_DWORD *)this + 30) <= 0 )
      {
LABEL_9:
        result = 0;
      }
      else
      {
        while ( 1 )
        {
          result = sub_100318B8((int)((char *)v2 + 56), v4);
          if ( result )
          {
            if ( *(_DWORD *)(result + 128) == *(_DWORD *)(a2 + 8) )
              break;
          }
          ++v4;
          if ( v4 >= *((_DWORD *)v2 + 30) )
            goto LABEL_9;
        }
      }
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10045DE3) --------------------------------------------------------
char __thiscall sub_10045DE3(void *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  char v7; // bl@1
  void *v8; // esi@1
  int v9; // eax@2
  signed int v10; // edi@4
  int v11; // eax@5

  v7 = 1;
  v8 = this;
  if ( (a3 & 0xFFFFFFF) != 3 || (v9 = sub_10045D86(this, (int)&a3), !v9) || !sub_10044F55(v9, a2, a7, 1) )
  {
    v10 = 0;
    if ( *((_DWORD *)v8 + 30) <= 0 )
    {
LABEL_8:
      v7 = 0;
    }
    else
    {
      while ( 1 )
      {
        v11 = sub_100318B8((int)((char *)v8 + 56), v10);
        if ( v11 )
        {
          if ( sub_10044F55(v11, a2, a7, 1) )
            break;
        }
        ++v10;
        if ( v10 >= *((_DWORD *)v8 + 30) )
          goto LABEL_8;
      }
    }
  }
  return v7;
}

//----- (10045E53) --------------------------------------------------------
int __thiscall sub_10045E53(void *this, int a2)
{
  void *v3; // esi@1
  int v4; // ST0C_4@1
  int v5; // eax@1

  v3 = this;
  v4 = (int)this;
  v5 = (*(int (**)(void))(**(_DWORD **)this + 4))();
  sub_1004D6B9(a2, 2, *((_DWORD *)v3 + 12), v5, v4);
  return a2;
}

//----- (10045E77) --------------------------------------------------------
int __userpurge sub_10045E77<eax>(int a1<ebp>, int a2)
{
  int v3; // ecx@1
  void *v4; // edi@1
  void *v5; // esi@1
  int v6; // ST00_4@1

  sub_10035648();
  v4 = (void *)v3;
  v5 = *(void **)(v3 + 20);
  *(_DWORD *)(a1 - 16) = v5;
  sub_10034B9B(v5);
  v6 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 - 4) = 0;
  sub_10045EB7(v4, v6);
  *(_DWORD *)(a1 - 4) = -1;
  sub_10034BAB(v5);
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (10045EB7) --------------------------------------------------------
int __thiscall sub_10045EB7(void *this, char a2)
{
  void *i; // esi@1
  int v3; // ecx@2
  int v4; // edi@2
  int v5; // ebx@5
  int v6; // eax@5

  for ( i = this; ; *(_DWORD *)i = v4 + 1 )
  {
    if ( *(_DWORD *)i >= *((_DWORD *)i + 1)
      || (v4 = *(_DWORD *)i, v3 = *(_DWORD *)i & *((_DWORD *)i + 2), *(_BYTE *)(*((_DWORD *)i + 3) + 4 * v3) & 1)
      && !a2
      && sub_10040214((void *)(*((_DWORD *)i + 4) + 8 * v3)) )
      return 0;
    v6 = *((_DWORD *)i + 3) + 4 * (*((_DWORD *)i + 2) & v4);
    v5 = *(_DWORD *)v6;
    *(_DWORD *)v6 = 0;
    if ( v5 & 1 )
    {
      v5 &= 0xFFFFFFFEu;
      if ( !sub_1002E690(*((_DWORD *)i + 4) + 8 * (*((_DWORD *)i + 2) & v4), 0) )
        continue;
    }
    break;
  }
  if ( v5 )
    *(_DWORD *)i = v4 + 1;
  return v5;
}

//----- (10045F35) --------------------------------------------------------
void *__thiscall sub_10045F35(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v4; // edi@1

  v4 = this;
  *(_DWORD *)this = off_10064D38;
  sub_1002E10C(0, ebp0, a2, 0);
  *((_BYTE *)v4 + 179) &= 0xFCu;
  *(_DWORD *)v4 = off_10064D50;
  *((_DWORD *)v4 + 1) = off_10064D7C;
  *((_DWORD *)v4 + 39) = 0;
  *((_DWORD *)v4 + 40) = 0;
  *((_DWORD *)v4 + 41) = 0;
  *((_DWORD *)v4 + 42) = 0;
  *((_DWORD *)v4 + 43) = 0;
  *((_BYTE *)v4 + 176) = 0;
  *((_BYTE *)v4 + 178) = 0;
  *((_DWORD *)v4 + 57) = 0;
  *((_DWORD *)v4 + 7) = 0;
  *((_BYTE *)v4 + 236) = 1;
  return v4;
}
// 10064D38: using guessed type int (*off_10064D38[5])();
// 10064D50: using guessed type int (*off_10064D50[3])();
// 10064D7C: using guessed type int (*off_10064D7C[5])();

//----- (10045FA8) --------------------------------------------------------
int __userpurge sub_10045FA8<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10060D2C;
  return v4;
}
// 10060D2C: using guessed type int (__stdcall *off_10060D2C)(char);

//----- (10045FC3) --------------------------------------------------------
int __userpurge sub_10045FC3<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10060D20;
  return v4;
}
// 10060D20: using guessed type int (__stdcall *off_10060D20)(char);

//----- (10045FDE) --------------------------------------------------------
int __userpurge sub_10045FDE<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10060D68;
  return v4;
}
// 10060D68: using guessed type int (__stdcall *off_10060D68)(char);

//----- (10045FF9) --------------------------------------------------------
int __userpurge sub_10045FF9<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int v4; // esi@1

  v4 = a1;
  sub_1002AEE4(a1, a2, a3);
  *(_DWORD *)v4 = &off_10060D5C;
  return v4;
}
// 10060D5C: using guessed type int (__stdcall *off_10060D5C)(char);

//----- (10046014) --------------------------------------------------------
int __usercall sub_10046014<eax>(int a1<ebp>)
{
  int v2; // ecx@1
  void *v3; // esi@1

  sub_10035648();
  *(_DWORD *)(a1 - 16) = v2;
  v3 = (void *)(v2 + 4);
  *(_DWORD *)v2 = off_10064D50;
  *(_DWORD *)(v2 + 4) = off_10064D7C;
  *(_DWORD *)(a1 - 4) = 0;
  sub_100463D6(v2, a1);
  sub_1002E239(v3);
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 10064D50: using guessed type int (*off_10064D50[3])();
// 10064D7C: using guessed type int (*off_10064D7C[5])();

//----- (1004604F) --------------------------------------------------------
void *__thiscall sub_1004604F(void *this, char a2)
{
  void *v2; // esi@1
  char v4; // [sp-4h] [bp-4h]@1

  v2 = (char *)this - 4;
  sub_10046014((int)&v4);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10046076) --------------------------------------------------------
char __thiscall sub_10046076(void *this, char a2, int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // edi@1
  char result; // al@2
  int v8; // esi@9
  int v9; // ebx@12
  void *v10; // esi@12
  char v11; // [sp-14h] [bp-3Ch]@12
  char v12; // [sp-10h] [bp-38h]@2
  int v13; // [sp-Ch] [bp-34h]@2
  int v14; // [sp-8h] [bp-30h]@2
  int v15; // [sp-4h] [bp-2Ch]@2
  char v16; // [sp+Ch] [bp-1Ch]@12
  int v17; // [sp+20h] [bp-8h]@6
  int v18; // [sp+24h] [bp-4h]@9

  v6 = (int)this;
  v5 = (int)sub_10032356();
  if ( *(_DWORD *)(*(_DWORD *)(v6 + 32) + 432) <= 0
    || (sub_1002F3E5((int)&v12, (int)&a2),
        result = (*(int (__stdcall **)(int, _DWORD, int, int, int))(**(_DWORD **)(v6 + 32) + 60))(
                   v6,
                   *(_DWORD *)&v12,
                   v13,
                   v14,
                   v15),
        !result) )
  {
    if ( v5 && !*(_BYTE *)(v5 + 76) && *(_DWORD *)(v6 + 32) == sub_10032DD0(v5) )
    {
      v17 = v5;
      sub_1004EAE4();
      if ( !(*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v6 + 28) + 256) + 48) & 2)
        && (1 << (*(_DWORD *)(*(_DWORD *)(v5 + 156) + 132) & 0x1F)) & *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v6 + 28) + 32)
                                                                                + 4
                                                                                * (*(_DWORD *)(*(_DWORD *)(v5 + 156)
                                                                                             + 132) >> 5))
        && *(_DWORD *)(*(_DWORD *)(v5 + 156) + 16) - *(_DWORD *)(*(_DWORD *)(v5 + 156) + 12) < *(_WORD *)(*(_DWORD *)(v6 + 32) + 16) )
      {
        v8 = *(_DWORD *)(*(_DWORD *)(v6 + 28) + 256);
        v18 = *(_DWORD *)(v6 + 28);
        if ( sub_1002E9DD(v5) != v8 )
          *(_DWORD *)(v6 + 228) = 1;
        sub_10046B62(*(_DWORD *)(v5 + 156) + 12, v6);
        if ( *(_DWORD *)(*(_DWORD *)(v6 + 32) + 428) <= 0 )
        {
          v9 = v18;
        }
        else
        {
          sub_1002F3E5((int)&v16, (int)&a2);
          v10 = *(void **)(v6 + 32);
          v15 = 11;
          sub_1002F3E5((int)&v11, (int)&v16);
          v9 = v18;
          sub_10034194(v10, v18, v11, *(int *)&v12, v13, v14, v15);
        }
        if ( sub_1002E9DD(v17) != *(_DWORD *)(v9 + 256) )
          *(_DWORD *)(v6 + 228) = 0;
        return sub_1004EAE4();
      }
      sub_1004EAE4();
    }
    sub_1002F3E5((int)&v12, (int)&a2);
    result = sub_10040BA5(*(void **)(v6 + 28), v6, v12, v13, v14, v15);
  }
  return result;
}

//----- (100461EF) --------------------------------------------------------
int __userpurge sub_100461EF<eax>(int a1<ebp>, int a2)
{
  int v3; // ecx@1
  int v4; // esi@1
  int v5; // edi@1
  int v6; // ecx@1
  int v7; // ST00_4@1

  sub_10035648();
  v4 = v3;
  v5 = v3 != 4 ? v3 : 0;
  *(_DWORD *)(a1 - 16) = v5;
  sub_1004EAE4();
  v6 = *(_DWORD *)(v4 + 156);
  *(_DWORD *)(a1 - 4) = 0;
  sub_100450FA(v6, a1, v5);
  loc_1002CBD3(*(_DWORD *)(a1 + 8));
  *(_DWORD *)(a1 - 4) = -1;
  sub_1004EAE4();
  return sub_10035616(v7);
}
// 1002CBD3: using guessed type _DWORD __cdecl loc_1002CBD3(_DWORD);
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (10046240) --------------------------------------------------------
int __thiscall sub_10046240(void *this)
{
  void *v2; // edi@1
  int v3; // ecx@1
  int v4; // eax@1
  int v18; // ebx@7
  int v22; // [sp-4h] [bp-18h]@1
  char v23; // [sp+12h] [bp-2h]@7
  char v24; // [sp+13h] [bp-1h]@7

  v2 = this;
  sub_1004EAE4();
  v3 = *((_DWORD *)v2 + 7);
  v22 = *((_DWORD *)v2 + 2);
  v4 = (*(int (**)(void))(*(_DWORD *)v3 + 4))();
  sub_1002F2FC(3, 4, v4, v22);
  _EAX = 1;
  if ( *(_BYTE *)(*((_DWORD *)v2 + 39) + 161) )
  {
    _EDX = (int)((char *)v2 + 44);
    __asm { lock xadd [edx], eax }
    if ( _EAX == 0 )
    {
      _ECX = 2;
      __asm { lock cmpxchg [edx], ecx }
      v22 = 1;
    }
    else
    {
      v22 = 2;
    }
    sub_10046DAD((int)((char *)v2 - 4), v22);
  }
  else
  {
    _ECX = (int)((char *)v2 + 44);
    __asm { lock xadd [ecx], eax }
    if ( _EAX == 0 )
    {
      v24 = 0;
      v23 = 0;
      v18 = sub_10046624((int)((char *)v2 - 4), (int)&v24, (int)&v23);
      _ECX = 2;
      _EDX = (int)((char *)v2 + 44);
      __asm { lock cmpxchg [edx], ecx }
      if ( v24 )
        sub_10046AE2(v18, *((_DWORD *)v2 + 6), 0, 0);
      sub_10046E99((int)((char *)v2 - 4), v18, 1);
    }
  }
  return sub_1004EAE4();
}

//----- (10046364) --------------------------------------------------------
char __thiscall sub_10046364(int this)
{
  int ebp0; // ebp@0
  int v2; // edi@1
  LPVOID v3; // eax@2
  int v4; // ecx@2
  int v5; // esi@4
  int v7; // [sp+8h] [bp-8h]@2
  int v8; // [sp+Ch] [bp-4h]@3

  v2 = this;
  if ( *(_DWORD *)(this + 160) )
  {
    *(_BYTE *)(this + 176) = 1;
    v4 = *(_DWORD *)(this + 160);
    v7 = 0;
    LOBYTE(v3) = sub_10044F55(v4, (int)&v7, 15, 1);
    if ( (_BYTE)v3 )
      LOBYTE(v3) = sub_1004505B(v8, v7, 0, 0);
  }
  else
  {
    v5 = this + 4;
    v3 = sub_10032356();
    if ( v3 == (LPVOID)v5 )
    {
      *(_BYTE *)(v2 + 176) = 1;
    }
    else
    {
      sub_10046C74(v2);
      sub_100463D6(v2, ebp0);
      LOBYTE(v3) = sub_10032207(*(_DWORD *)(v2 + 32));
    }
  }
  return (char)v3;
}

//----- (100463D6) --------------------------------------------------------
void __usercall sub_100463D6(int a1<ecx>, int a2<ebp>)
{
  int v2; // esi@1

  v2 = a1;
  sub_1002E6D7(a1 + 4, a2);
  sub_10046D5C(v2, 0, 0);
}

//----- (100463EE) --------------------------------------------------------
int __usercall sub_100463EE<eax>(int this<ecx>, int a2<ebp>)
{
  int v3; // esi@1

  v3 = this;
  sub_1004EAE4();
  sub_100463D6(v3, a2);
  return sub_10032207(*(_DWORD *)(v3 + 32));
}

//----- (10046409) --------------------------------------------------------
int __userpurge sub_10046409<eax>(int a1<ebp>, int a2)
{
  char v2; // bh@1
  int v3; // esi@1
  int v4; // ecx@1
  void *v5; // eax@1
  char v6; // bl@3
  char v7; // bl@7
  int v9; // [sp-8h] [bp-8h]@1

  sub_10035648();
  v3 = v4;
  *(_DWORD *)(a1 - 16) = 0;
  v2 = 0;
  *(_DWORD *)(v4 + 72) = GetCurrentThreadId();
  sub_1002EF5F((LPVOID)(v3 + 4));
  v5 = (void *)(*(int (__cdecl **)(int, signed int))(**(_DWORD **)(v3 + 32) + 12))(a1 - 20, 32);
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)(a1 - 16) = 1;
  v6 = !sub_10044B09(v5, 9u) && sub_1003D685() == 6;
  *(_DWORD *)(a1 - 4) = -1;
  sub_10044AE2((LPVOID *)(a1 - 20));
  if ( v6 )
  {
    v2 = 1;
    loc_1004CDC5(1);
  }
  sub_1004EAE4();
  *(_DWORD *)(v3 + 172) = 0;
  v7 = 0;
  if ( !sub_100465BA(v3, a1) )
    goto LABEL_9;
LABEL_8:
  v7 = sub_1004693A(v3, a1);
  while ( !v7 )
  {
LABEL_9:
    *(_BYTE *)(v3 + 179) &= 0xFDu;
    *(_DWORD *)(a1 - 32) = 0;
    *(_DWORD *)(a1 - 24) = 0;
    if ( !*(_DWORD *)(v3 + 160) )
    {
      sub_1004EAE4();
      sub_10030067(a1 - 44);
      sub_100355BB(a1 - 44, (int)&unk_1006C294);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1004657D);
    }
    if ( !*(_BYTE *)(v3 + 178) )
    {
      if ( sub_10045659(*(_DWORD *)(v3 + 160)) )
      {
        sub_1004EAE4();
        sub_10031FFA(*(_DWORD *)(v3 + 32));
        sub_1004EAE4();
      }
    }
    if ( sub_10047124(v3, a1 - 32) )
    {
      if ( *(_DWORD *)(a1 - 32) != 1 )
      {
        sub_1004657D(v3, a1 - 32);
        goto LABEL_8;
      }
      sub_10046E99(v3, *(_DWORD *)(a1 - 24), 0);
      break;
    }
    if ( sub_1004693A(v3, a1) )
      break;
    sub_10047034(v3);
    if ( *(_BYTE *)(v3 + 176) )
    {
      sub_100463EE(v3, a1);
      v7 = 1;
    }
  }
  if ( v2 )
    sub_1004CDDB();
  sub_1002E737();
  return sub_10035616(v9);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 1003D685: using guessed type int sub_1003D685(void);
// 1004CDC5: using guessed type _DWORD __cdecl loc_1004CDC5(_DWORD);

//----- (1004657D) --------------------------------------------------------
int __thiscall sub_1004657D(int this, int a2)
{
  int ebp0; // ebp@0
  int v4; // esi@1

  v4 = this;
  sub_10052BC8((void *)a2, this);
  ++*(_DWORD *)(*(_DWORD *)(v4 + 160) + 96);
  sub_1004EAE4();
  sub_10051C1D(a2);
  sub_1004EAE4();
  return sub_1002EDD5(v4 + 4, ebp0);
}

//----- (100465BA) --------------------------------------------------------
char __usercall sub_100465BA<al>(int a1<ecx>, int a2<ebp>)
{
  int v2; // edi@1
  int v3; // esi@4
  int v4; // ecx@4
  char result; // al@5

  v2 = a1;
  if ( *(_DWORD *)(a1 + 168) )
  {
    sub_1004EAE4();
    if ( *(_BYTE *)(v2 + 177) )
    {
      (*(void (__cdecl **)(_DWORD))(*(_DWORD *)(v2 + 168) + 12))(*(_DWORD *)(v2 + 168));
      *(_DWORD *)(v2 + 168) = 0;
    }
    else
    {
      v3 = *(_DWORD *)(v2 + 168);
      sub_10052C1D(*(_DWORD *)(v2 + 168));
      v4 = *(_DWORD *)(v2 + 32);
      *(_DWORD *)(v2 + 168) = 0;
      sub_10033AFD(v4, v3);
    }
    sub_1004EAE4();
    sub_1002EDD5(v2 + 4, a2);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10046624) --------------------------------------------------------
int __thiscall sub_10046624(int this, int a2, int a3)
{
  int v3; // ebx@1
  int ebp0; // ebp@0
  int v5; // edx@1
  int v6; // eax@1
  int v7; // edi@3
  int v9; // [sp+8h] [bp-Ch]@1
  int v10; // [sp+10h] [bp-4h]@1

  v3 = this;
  v5 = *(_DWORD *)(this + 28);
  v6 = *(_DWORD *)(this + 160);
  v9 = 0;
  v10 = 0;
  if ( !(unsigned __int8)(*(int (__thiscall **)(int, int *, int, _DWORD, signed int))(v6 + 60))(v6 + 36, &v9, v5, 0, 25) )
  {
    v7 = sub_1003293C(ebp0, 1);
    *(_BYTE *)a2 = v7 != 0;
    return v7;
  }
  if ( v9 == 1 )
    return v10;
  sub_1004EAE4();
  v7 = sub_1003293C(ebp0, 1);
  sub_1004EAE4();
  if ( !v7 )
  {
    if ( !(unsigned __int8)(*(int (__thiscall **)(int, int *, _DWORD, _DWORD, signed int))(*(_DWORD *)(v3 + 160) + 60))(
                             *(_DWORD *)(v3 + 160) + 36,
                             &v9,
                             *(_DWORD *)(v3 + 28),
                             0,
                             1) )
      return v7;
    return sub_100517C5((int)&v9, v7);
  }
  if ( !sub_10051DD0((int)&v9, v7) )
  {
    if ( !(unsigned __int8)(*(int (__thiscall **)(int, int *, _DWORD, _DWORD, signed int))(*(_DWORD *)(v3 + 160) + 60))(
                             *(_DWORD *)(v3 + 160) + 36,
                             &v9,
                             *(_DWORD *)(v3 + 28),
                             0,
                             7) )
    {
      *(_BYTE *)a2 = 1;
      return v7;
    }
    if ( v9 == 1 )
    {
      sub_10033ABD(*(_DWORD *)(v3 + 32), v7, 1);
      return sub_100517C5((int)&v9, v7);
    }
  }
  *(_BYTE *)a3 = v9 == 4;
  sub_1005180E((int)&v9, v7);
  return v7;
}

//----- (10046726) --------------------------------------------------------
int __userpurge sub_10046726<eax>(int a1<ecx>, int a2<edi>, int a3)
{
  int ebp0; // ebp@0
  int v5; // esi@1
  int v6; // eax@1

  v5 = a1;
  sub_1004EAE4();
  v6 = sub_100450FA(*(_DWORD *)(v5 + 156), ebp0, a2);
  sub_1002CC67((void *)v6, a3);
  return sub_1004EAE4();
}

//----- (10046752) --------------------------------------------------------
int __thiscall sub_10046752(int this, int a2)
{
  int v2; // esi@1

  v2 = 0;
  if ( a2 )
  {
    _EDI = this + 164;
    if ( a2 == *(_DWORD *)(this + 164) )
    {
      _ECX = 0;
      __asm { lock cmpxchg [edi], ecx }
      if ( a2 == a2 )
        v2 = a2;
    }
  }
  return v2;
}

//----- (10046780) --------------------------------------------------------
int __thiscall sub_10046780(int this)
{
  return *(_DWORD *)(this + 12);
}

//----- (10046784) --------------------------------------------------------
int __thiscall sub_10046784(int this)
{
  return sub_10046780(this - 4);
}

//----- (1004678C) --------------------------------------------------------
int __thiscall sub_1004678C(int this)
{
  return *(_DWORD *)(this + 156);
}

//----- (10046793) --------------------------------------------------------
int __thiscall sub_10046793(int this)
{
  return (*(int (**)(void))(**(_DWORD **)(this + 32) + 52))();
}

//----- (1004679B) --------------------------------------------------------
signed int __thiscall sub_1004679B(void *this)
{
  void *v1; // esi@1
  signed int v2; // edi@2

  v1 = this;
  sub_1004EAE4();
  if ( *((_DWORD *)v1 + 39) )
    v2 = *(_DWORD *)(*((_DWORD *)v1 + 39) + 124);
  else
    v2 = -1;
  sub_1004EAE4();
  return v2;
}

//----- (100467C7) --------------------------------------------------------
int __thiscall sub_100467C7(void *this, int a2, int a3, int a4)
{
  int v4; // eax@1
  int v5; // ebx@1
  int v6; // edi@1
  signed __int64 v8; // qax@1
  signed __int64 v10; // qax@1
  int v11; // edx@2
  int i; // ecx@2
  int v13; // eax@6
  int v14; // edx@6
  int v15; // ebx@6
  void *v16; // esi@6
  int v17; // ecx@7
  int v18; // edx@7
  int v19; // edx@10
  int v20; // ecx@10
  int v21; // edx@10
  void *v23; // [sp+Ch] [bp-24h]@6
  void *v24; // [sp+10h] [bp-20h]@1
  void *v25; // [sp+14h] [bp-1Ch]@6
  int v26; // [sp+18h] [bp-18h]@1
  int v27; // [sp+1Ch] [bp-14h]@1
  int v28; // [sp+20h] [bp-10h]@1
  int v29; // [sp+24h] [bp-Ch]@1
  int v30; // [sp+28h] [bp-8h]@6
  int v31; // [sp+2Ch] [bp-4h]@6

  v6 = (int)this;
  _ECX = 0;
  v5 = 2 * *(_DWORD *)(v6 + 8) + 2;
  v8 = 4i64 * (unsigned int)(2 * *(_DWORD *)(v6 + 8) + 2);
  __asm { seto    cl }
  v26 = v6;
  v27 = v5;
  v29 = sub_1002965B(SHIDWORD(v8), v8 | -_ECX, v5, v6, v8 | -_ECX);
  v24 = *(void **)(v6 + 12);
  _ECX = 0;
  v10 = 8i64 * (unsigned int)v5;
  __asm { seto    cl }
  v4 = sub_1002965B(SHIDWORD(v10), v10 | -_ECX, v5, v6, v10 | -_ECX);
  v28 = v4;
  if ( v4 )
  {
    v11 = v5 - 1;
    for ( i = v4; v11 >= 0; --v11 )
    {
      *(_DWORD *)i = 0;
      *(_DWORD *)(i + 4) = 0;
      i += 8;
    }
  }
  else
  {
    v28 = 0;
  }
  v16 = *(void **)(v6 + 20);
  v23 = *(void **)(v6 + 16);
  v25 = *(void **)(v6 + 20);
  sub_10034B9B(v16);
  v13 = *(_DWORD *)v6;
  v15 = *(_DWORD *)(v6 + 4) - *(_DWORD *)v6;
  v14 = 0;
  v30 = *(_DWORD *)v6;
  v31 = 0;
  if ( v15 > 0 )
  {
    do
    {
      *(_DWORD *)(v29 + 4 * v14) = *(_DWORD *)(*(_DWORD *)(v6 + 12) + 4 * (*(_DWORD *)(v6 + 8) & v13));
      v17 = *(_DWORD *)(v6 + 16);
      v18 = *(_DWORD *)(v6 + 8) & v30;
      *(_DWORD *)(v28 + 8 * v31) = *(_DWORD *)(v17 + 8 * v18);
      v6 = v26;
      *(_DWORD *)(v28 + 8 * v31 + 4) = *(_DWORD *)(v17 + 8 * v18 + 4);
      v14 = v31 + 1;
      v13 = v30 + 1;
      v31 = v14;
      ++v30;
    }
    while ( v14 < v15 );
    v16 = v25;
  }
  sub_100391F0((void *)(v29 + 4 * v15), 0, 4 * (v27 - v15));
  *(_DWORD *)(v6 + 12) = v29;
  *(_DWORD *)(v6 + 16) = v28;
  *(_DWORD *)v6 = 0;
  *(_DWORD *)(v6 + 8) = v27 - 1;
  if ( a3 )
  {
    v20 = *(_DWORD *)(v6 + 16);
    v21 = v15 & (v27 - 1);
    *(_DWORD *)(v20 + 8 * v21) = a3;
    *(_DWORD *)(v20 + 8 * v21 + 4) = a4;
    v19 = a2 | 1;
  }
  else
  {
    v19 = a2;
  }
  *(_DWORD *)(*(_DWORD *)(v6 + 12) + 4 * (*(_DWORD *)(v6 + 8) & v15)) = v19;
  *(_DWORD *)(v6 + 4) = v15 + 1;
  sub_10034BAB(v16);
  sub_100303A3(v24);
  return sub_100303A3(v23);
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (1004692E) --------------------------------------------------------
bool __thiscall sub_1004692E(int this)
{
  return *(_DWORD *)(this + 44) == 2;
}

//----- (1004693A) --------------------------------------------------------
char __usercall sub_1004693A<al>(int a1<ecx>, int a2<ebp>)
{
  int v2; // esi@1
  char result; // al@7

  v2 = a1;
  if ( *(_BYTE *)(a1 + 178) || !*(_BYTE *)(*(_DWORD *)(a1 + 160) + 161) )
  {
    result = 0;
  }
  else
  {
    if ( *(_DWORD *)(a1 + 172) )
      sub_10045250(*(_DWORD *)(a1 + 32) + 60, *(_DWORD *)(*(_DWORD *)(a1 + 160) + 132));
    *(_DWORD *)(v2 + 172) = 0;
    if ( sub_10046DAD(v2, 0) )
      sub_100463EE(v2, a2);
    result = 1;
  }
  return result;
}

//----- (10046998) --------------------------------------------------------
int __thiscall sub_10046998(void *this)
{
  int v1; // eax@1
  int v2; // esi@1
  int v3; // eax@3
  int v4; // edi@3
  int v6; // [sp+Ch] [bp-14h]@3
  int v7; // [sp+10h] [bp-10h]@3
  int v8; // [sp+14h] [bp-Ch]@1
  int v9; // [sp+18h] [bp-8h]@3
  char v10; // [sp+1Eh] [bp-2h]@1
  char v11; // [sp+1Fh] [bp-1h]@1

  v2 = (int)this;
  sub_1004EAE4();
  v11 = 0;
  v10 = 0;
  v1 = sub_10046624(v2, (int)&v11, (int)&v10);
  v8 = v1;
  if ( v11 )
    sub_10046AE2(v1, *(_DWORD *)(v2 + 28), 0, 0);
  sub_1004EAE4();
  v3 = *(_DWORD *)(v2 + 160);
  v6 = *(_DWORD *)(v2 + 32);
  *(_DWORD *)(v2 + 160) = 0;
  v4 = *(_DWORD *)(v2 + 156);
  v9 = v3;
  v7 = v8;
  if ( !v8 )
  {
    v7 = (*(int (__thiscall **)(int))(*(_DWORD *)v3 + 4))(v3);
    v3 = v9;
  }
  *(_DWORD *)(v2 + 44) = 1;
  (*(void (__thiscall **)(int, int))(*(_DWORD *)v3 + 16))(v3, v8);
  if ( v7 )
  {
    (*(void (__thiscall **)(int, int, signed int))(*(_DWORD *)v4 + 4))(v4, v7, 2);
  }
  else
  {
    sub_100452D8(v9, 4, 1);
    sub_10032222(v6);
    (*(void (__thiscall **)(int, signed int))(*(_DWORD *)v4 + 8))(v4, 2);
  }
  sub_1004EAE4();
  return sub_1004EAE4();
}

//----- (10046A6E) --------------------------------------------------------
void __thiscall sub_10046A6E(int this, char a2)
{
  int v2; // esi@1
  int v3; // eax@4
  int v4; // eax@5
  int v5; // eax@6
  char v6; // [sp+4h] [bp-Ch]@9

  v2 = this;
  if ( a2 )
  {
    ++*(_DWORD *)(this + 20);
    if ( *(_DWORD *)(this + 20) == 1 )
    {
      sub_1004EAE4();
      (*(void (**)(void))(**(_DWORD **)(v2 + 156) + 32))();
      sub_1004EAE4();
    }
  }
  else
  {
    v3 = *(_DWORD *)(this + 20);
    if ( !v3 )
    {
      sub_1002FFE7((int)&v6);
      sub_100355BB((int)&v6, (int)&unk_1006C25C);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_10046AE2);
    }
    v4 = v3 - 1;
    *(_DWORD *)(this + 20) = v4;
    if ( !v4 )
    {
      v5 = sub_10046752(this - 4, *(_DWORD *)(this + 160));
      if ( v5 )
        sub_10045356(v5);
    }
  }
}

//----- (10046AE2) --------------------------------------------------------
int __thiscall sub_10046AE2(int this, int a2, int a3, char a4)
{
  int result; // eax@1
  int v5; // edx@1

  result = a2;
  v5 = this;
  *(_BYTE *)(this + 236) = 0;
  *(_DWORD *)(this + 28) = a2;
  if ( a3 )
  {
    if ( a4 )
    {
      result = *(_DWORD *)(a2 + 256);
      if ( !(*(_BYTE *)(result + 48) & 4) )
      {
        result += 20;
        _ECX = 1;
        __asm { lock xadd [eax], ecx }
      }
      *(_BYTE *)(v5 + 177) = 1;
    }
    else
    {
      *(_BYTE *)(this + 177) = 0;
    }
    *(_DWORD *)(v5 + 168) = a3;
  }
  else
  {
    result = *(_DWORD *)(a2 + 256);
    if ( !(*(_BYTE *)(result + 48) & 4) )
    {
      result += 20;
      _ECX = 1;
      __asm { lock xadd [eax], ecx }
    }
  }
  return result;
}

//----- (10046B4B) --------------------------------------------------------
int __thiscall sub_10046B4B(int this, int a2)
{
  int result; // eax@1

  *(_DWORD *)(this + 160) = a2;
  result = this + 44;
  *(_DWORD *)(this + 44) = 0;
  return result;
}

//----- (10046B62) --------------------------------------------------------
int __thiscall sub_10046B62(int this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int result; // eax@2

  v2 = *(_DWORD *)(this + 4);
  v3 = *(_DWORD *)(this + 8);
  if ( v2 >= v3 + *(_DWORD *)this )
  {
    result = sub_100467C7((void *)this, a2, 0, 0);
  }
  else
  {
    *(_DWORD *)(*(_DWORD *)(this + 12) + 4 * (v2 & v3)) = a2;
    result = v2 + 1;
    *(_DWORD *)(this + 4) = v2 + 1;
  }
  return result;
}

//----- (10046BA3) --------------------------------------------------------
void __thiscall sub_10046BA3(int this)
{
  int v1; // esi@1
  int v2; // ecx@2
  int v3; // [sp+4h] [bp-8h]@2

  v1 = this;
  if ( *(_BYTE *)(this + 178) )
  {
    v2 = *(_DWORD *)(this + 160);
    v3 = 0;
    if ( !sub_10044F55(v2, (int)&v3, 15, 1) )
    {
      while ( !(unsigned __int8)sub_1004501F(*(_DWORD *)(v1 + 160)) )
        (*(void (__thiscall **)(int))(*(_DWORD *)v1 + 32))(v1);
    }
    *(_BYTE *)(v1 + 178) = 0;
  }
}

//----- (10046BF2) --------------------------------------------------------
int __thiscall sub_10046BF2(void *this)
{
  int v2; // esi@1

  v2 = (int)this;
  sub_1004EAE4();
  sub_10046DAD(v2, 3);
  return sub_1004EAE4();
}

//----- (10046C11) --------------------------------------------------------
void __usercall sub_10046C11(int a1<ecx>, int a2<ebp>)
{
  int v2; // esi@1

  v2 = a1;
  sub_1002EDD5(a1 + 4, a2);
  sub_10046D5C(v2, 0, 0);
  *(_DWORD *)(v2 + 72) = 0;
  *(_BYTE *)(v2 + 236) = 1;
}

//----- (10046C34) --------------------------------------------------------
int __thiscall sub_10046C34(int this, int a2)
{
  int result; // eax@1
  int (__stdcall **v3)(char); // [sp+0h] [bp-Ch]@3

  result = a2;
  if ( !a2 )
  {
    a2 = (int)"pThreadProxy";
    sub_1002AEA4((int)&v3, &a2);
    v3 = &off_1005F2EC;
    sub_100355BB((int)&v3, (int)&unk_1006C8B4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10046C74);
  }
  *(_DWORD *)(this + 156) = a2;
  return result;
}
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);

//----- (10046C74) --------------------------------------------------------
char __thiscall sub_10046C74(int this)
{
  int v1; // esi@1
  char result; // al@3
  char v3; // [sp+4h] [bp-10h]@3
  int v4; // [sp+Ch] [bp-8h]@2
  void (__cdecl *v5)(); // [sp+10h] [bp-4h]@2

  v1 = this;
  if ( !*(_DWORD *)(this + 44) )
  {
    v4 = 0;
    v5 = sub_10034BB6;
    do
      result = sub_100282E0((int)&v3);
    while ( !*(_DWORD *)(v1 + 44) );
  }
  return result;
}

//----- (10046C9F) --------------------------------------------------------
char __cdecl sub_10046C9F(int a1, int a2)
{
  char result; // al@3
  char v3; // [sp+8h] [bp-10h]@3
  int v4; // [sp+10h] [bp-8h]@2
  void (__cdecl *v5)(); // [sp+14h] [bp-4h]@2

  if ( *(_DWORD *)a1 != a2 )
  {
    v4 = 0;
    v5 = sub_10034BB6;
    do
      result = sub_100282E0((int)&v3);
    while ( *(_DWORD *)a1 != a2 );
  }
  return result;
}

//----- (10046CCC) --------------------------------------------------------
int __thiscall sub_10046CCC(void *this)
{
  char v1; // bl@1
  void *v2; // esi@1
  int v3; // ST0C_4@1
  int v4; // eax@1
  int v5; // eax@3
  int v6; // ST04_4@3
  int result; // eax@6
  int v8; // [sp+8h] [bp-Ch]@3
  int v9; // [sp+10h] [bp-4h]@3

  v2 = this;
  v1 = 0;
  sub_1004EAE4();
  v3 = *((_DWORD *)v2 + 2);
  v4 = (*(int (**)(void))(**((_DWORD **)v2 + 7) + 4))();
  sub_1002F2FC(5, 4, v4, v3);
  if ( *(_BYTE *)(*((_DWORD *)v2 + 39) + 161) )
  {
    sub_10046DAD((int)((char *)v2 - 4), 2);
  }
  else
  {
    v5 = *((_DWORD *)v2 + 39);
    v6 = *((_DWORD *)v2 + 6);
    v8 = 0;
    v9 = 0;
    if ( (unsigned __int8)(*(int (__thiscall **)(int, int *, int, _DWORD, signed int))(v5 + 60))(v5 + 36, &v8, v6, 0, 1) )
      sub_10046E99((int)((char *)v2 - 4), v9, 2);
    else
      v1 = 1;
  }
  result = sub_1004EAE4();
  if ( v1 )
    result = (*(int (**)(void))(**((_DWORD **)v2 + 38) + 12))();
  return result;
}

//----- (10046D5C) --------------------------------------------------------
void __thiscall sub_10046D5C(int this, int a2, char a3)
{
  int v3; // esi@1
  int v4; // eax@3

  v3 = this;
  if ( *(_DWORD *)(this + 28) )
  {
    sub_10046C9F(this + 228, 0);
    sub_1003333B(*(void **)(*(_DWORD *)(v3 + 28) + 256));
    if ( a3 )
    {
      v4 = *(_DWORD *)(a2 + 256);
      if ( !(*(_BYTE *)(v4 + 48) & 4) )
      {
        _EAX = v4 + 20;
        _ECX = 1;
        __asm { lock xadd [eax], ecx }
      }
    }
    *(_DWORD *)(v3 + 28) = a2;
  }
}

//----- (10046DAD) --------------------------------------------------------
char __thiscall sub_10046DAD(int this, int a2)
{
  char v2; // bl@1
  int v3; // esi@1
  int v4; // ecx@4
  int v5; // eax@4
  char v7; // [sp-10h] [bp-24h]@9
  int v8; // [sp-Ch] [bp-20h]@9
  int v9; // [sp-8h] [bp-1Ch]@9
  int v10; // [sp-4h] [bp-18h]@4
  int v11; // [sp+Ch] [bp-8h]@1
  int v12; // [sp+10h] [bp-4h]@2

  v3 = this;
  v2 = 0;
  v11 = *(_DWORD *)(this + 156);
  if ( *(_DWORD *)(this + 160) )
  {
    sub_10046BA3(this);
    v12 = *(_DWORD *)(*(_DWORD *)(v3 + 160) + 180);
    sub_1004EAE4();
    (*(void (**)(void))(**(_DWORD **)(v3 + 160) + 12))();
    *(_DWORD *)(v3 + 160) = 0;
    if ( a2 )
    {
      sub_1004EAE4();
      *(_DWORD *)(v3 + 44) = 1;
    }
    else
    {
      v4 = *(_DWORD *)(v3 + 32);
      v10 = *(_DWORD *)(v3 + 12);
      v5 = (*(int (**)(void))(*(_DWORD *)v4 + 4))();
      sub_1002F2FC(6, 4, v5, v10);
      sub_100412C9(*(void **)(v3 + 28), v3);
    }
    sub_100346B6(*(_DWORD *)(v3 + 32), (int)&v12);
    sub_10034793(*(_DWORD *)(v3 + 32), 0);
    v2 = *(_BYTE *)(v3 + 176);
    if ( !a2 )
      *(_DWORD *)(v3 + 44) = 1;
  }
  if ( a2 == 2 || a2 == 3 )
  {
    sub_1002F3E5((int)&v7, *(_DWORD *)(v3 + 28) + 12);
    sub_10040BA5(*(void **)(v3 + 28), v3, v7, v8, v9, v10);
  }
  if ( a2 )
  {
    v10 = 1;
    (*(void (__thiscall **)(int, signed int))(*(_DWORD *)v11 + 8))(v11, 1);
  }
  return v2;
}

//----- (10046E99) --------------------------------------------------------
int __thiscall sub_10046E99(int this, int a2, int a3)
{
  signed int v3; // edi@1
  int v4; // esi@1
  int v5; // ecx@7
  int v6; // eax@7
  int v7; // eax@8
  int v8; // ebx@8
  int v9; // edx@10
  int result; // eax@11
  int v11; // eax@11
  int v12; // eax@12
  char v13; // [sp-10h] [bp-28h]@6
  int v14; // [sp-Ch] [bp-24h]@6
  int v15; // [sp-8h] [bp-20h]@6
  int v16; // [sp-4h] [bp-1Ch]@6
  int v17; // [sp+Ch] [bp-Ch]@8
  int v18; // [sp+10h] [bp-8h]@8
  int v19; // [sp+14h] [bp-4h]@8

  v3 = 1;
  v4 = this;
  if ( a3 )
  {
    if ( a3 != 1 )
    {
      if ( a3 == 2 )
      {
        sub_1002F3E5((int)&v13, *(_DWORD *)(this + 28) + 12);
        sub_10040BA5(*(void **)(v4 + 28), v4, v13, v14, v15, v16);
      }
      else
      {
        if ( a3 == 3 )
          v3 = 2;
      }
    }
  }
  else
  {
    v5 = *(_DWORD *)(this + 32);
    v16 = *(_DWORD *)(v4 + 12);
    v6 = (*(int (**)(void))(*(_DWORD *)v5 + 4))();
    sub_1002F2FC(6, 4, v6, v16);
    sub_100412C9(*(void **)(v4 + 28), v4);
    v3 = 0;
  }
  sub_1004EAE4();
  v7 = *(_DWORD *)(v4 + 160);
  v17 = *(_DWORD *)(v4 + 32);
  *(_DWORD *)(v4 + 160) = 0;
  v8 = *(_DWORD *)(v4 + 156);
  v19 = v7;
  v18 = a2;
  if ( !a2 )
  {
    v18 = (*(int (__thiscall **)(int))(*(_DWORD *)v7 + 4))(v19);
    v7 = v19;
  }
  *(_DWORD *)(v4 + 44) = 1;
  v9 = *(_DWORD *)v7;
  v16 = a2;
  (*(void (__thiscall **)(int, int))(v9 + 16))(v7, a2);
  if ( v18 )
  {
    v12 = *(_DWORD *)v8;
    v16 = v3;
    v15 = v18;
    result = (*(int (__thiscall **)(int, int, signed int))(v12 + 4))(v8, v18, v3);
  }
  else
  {
    sub_100452D8(v19, 4, 1);
    sub_10032222(v17);
    v11 = *(_DWORD *)v8;
    v16 = v3;
    result = (*(int (__thiscall **)(int, signed int))(v11 + 8))(v8, v3);
  }
  if ( a3 )
    result = sub_1004EAE4();
  return result;
}

//----- (10046F90) --------------------------------------------------------
int __fastcall sub_10046F90(int a1)
{
  int v1; // edi@1
  int v3; // esi@2
  int v10; // ecx@2
  int v11; // eax@2
  int result; // eax@3
  char *v13; // eax@6
  char v14; // [sp-10h] [bp-38h]@3
  int v15; // [sp-4h] [bp-2Ch]@2
  char v16; // [sp+Ch] [bp-1Ch]@7
  char v17; // [sp+18h] [bp-10h]@6

  v1 = a1;
  if ( (LPVOID)(a1 != 4 ? a1 : 0) == sub_10032356() )
  {
    sub_1002FF27((int)&v16);
    v15 = (int)&unk_1006C224;
    v13 = &v16;
    goto LABEL_8;
  }
  _EBX = v1 + 44;
  _ESI = -1;
  __asm { lock xadd [ebx], esi }
  v3 = _ESI - 1;
  v10 = *(_DWORD *)(v1 + 28);
  v15 = *(_DWORD *)(v1 + 8);
  v11 = (*(int (**)(void))(*(_DWORD *)v10 + 4))();
  sub_1002F2FC(4, 4, v11, v15);
  if ( v3 == 1 )
  {
    *(_DWORD *)_EBX = 0;
    sub_10046C74(v1 - 4);
    sub_1002F3E5((int)&v14, *(_DWORD *)(v1 + 24) + 12);
    return (*(int (__thiscall **)(int))(*(_DWORD *)(v1 - 4) + 20))(v1 - 4);
  }
  result = v3 + 1;
  if ( (unsigned int)(v3 + 1) > 1 )
  {
    sub_1002FF39((int)&v17);
    v15 = (int)&unk_1006C1EC;
    v13 = &v17;
LABEL_8:
    sub_100355BB((int)v13, v15);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10047034);
  }
  return result;
}

//----- (10047034) --------------------------------------------------------
int __thiscall sub_10047034(int this)
{
  int v1; // ebx@1
  int v2; // esi@2
  int v3; // edi@2
  unsigned int v4; // eax@3
  int result; // eax@4
  int v6; // ecx@6
  int v7; // ecx@8
  char v8; // zf@12

  v1 = this;
  ++*(_DWORD *)(v1 + 172);
  if ( *(_DWORD *)(this + 172) == 1 )
  {
    v2 = *(_DWORD *)(*(_DWORD *)(this + 160) + 132);
    v3 = *(_DWORD *)(this + 32);
    sub_10045292(v3 + 60, *(_DWORD *)(*(_DWORD *)(this + 160) + 132));
    sub_10044FFA(v3, v2);
  }
  v4 = *(_DWORD *)(v1 + 172);
  if ( v4 >= 0x100 )
  {
    if ( v4 == 256 )
    {
      v6 = *(_DWORD *)(v1 + 160);
      *(_BYTE *)(v1 + 178) = 1;
      sub_100452D8(v6, 2, 1);
      result = sub_1004504F(*(_DWORD *)(v1 + 160));
    }
    else
    {
      if ( *(_BYTE *)(v1 + 179) & 2 )
      {
        v7 = *(_DWORD *)(v1 + 156);
        *(_DWORD *)(v1 + 172) = v4 - 1;
        result = (*(int (**)(void))(*(_DWORD *)v7 + 12))();
      }
      else
      {
        sub_10034834(*(void **)(v1 + 32), 1);
        while ( !(unsigned __int8)sub_1004501F(*(_DWORD *)(v1 + 160)) )
          (*(void (__thiscall **)(int))(*(_DWORD *)v1 + 32))(v1);
        result = sub_10034834(*(void **)(v1 + 32), 0);
        v8 = *(_DWORD *)(v1 + 172) == 0;
        *(_BYTE *)(v1 + 178) = 0;
        if ( !v8 )
          result = sub_10045250(*(_DWORD *)(v1 + 32) + 60, *(_DWORD *)(*(_DWORD *)(v1 + 160) + 132));
        *(_DWORD *)(v1 + 172) = 0;
      }
    }
  }
  else
  {
    result = (*(int (**)(void))(**(_DWORD **)(v1 + 156) + 12))();
  }
  return result;
}

//----- (10047124) --------------------------------------------------------
char __thiscall sub_10047124(int this, int a2)
{
  int v2; // esi@1
  char v3; // ST14_1@1
  char result; // al@4

  v2 = this;
  v3 = *(_BYTE *)(this + 178);
  if ( (unsigned __int8)(*(int (__thiscall **)(int, int, _DWORD))(*(_DWORD *)(this + 160) + 60))(
                          *(_DWORD *)(this + 160) + 36,
                          a2,
                          *(_DWORD *)(this + 28)) )
  {
    sub_10046BA3(v2);
    if ( *(_DWORD *)(v2 + 172) )
      sub_10045250(*(_DWORD *)(v2 + 32) + 60, *(_DWORD *)(*(_DWORD *)(v2 + 160) + 132));
    *(_DWORD *)(v2 + 172) = 0;
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004718B) --------------------------------------------------------
int __thiscall sub_1004718B(void *this)
{
  char v1; // bl@1
  int ebp0; // ebp@0
  void *v3; // esi@1
  int v4; // ST10_4@1
  int v5; // eax@1
  int v6; // eax@3
  int v7; // ST04_4@3
  int v8; // edi@5
  int result; // eax@18
  int v10; // [sp+8h] [bp-Ch]@3
  int v11; // [sp+10h] [bp-4h]@3

  v3 = this;
  v1 = 0;
  sub_1004EAE4();
  v4 = *((_DWORD *)v3 + 2);
  v5 = (*(int (**)(void))(**((_DWORD **)v3 + 7) + 4))();
  sub_1002F2FC(5, 4, v5, v4);
  if ( *(_BYTE *)(*((_DWORD *)v3 + 39) + 161) )
  {
    sub_10046DAD((int)((char *)v3 - 4), 2);
    goto LABEL_18;
  }
  v6 = *((_DWORD *)v3 + 39);
  v7 = *((_DWORD *)v3 + 6);
  v10 = 0;
  v11 = 0;
  if ( !(unsigned __int8)(*(int (__thiscall **)(int, int *, int, _DWORD, signed int))(v6 + 64))(v6 + 36, &v10, v7, 0, 9) )
    goto LABEL_17;
  if ( v10 == 1 )
  {
LABEL_11:
    v8 = v11;
    goto LABEL_12;
  }
  sub_1004EAE4();
  v8 = sub_1003293C(ebp0, 1);
  sub_1004EAE4();
  if ( v8 )
  {
    if ( sub_10051DD0((int)&v10, v8) )
    {
LABEL_7:
      sub_1005180E((int)&v10, v8);
      goto LABEL_12;
    }
    if ( (unsigned __int8)(*(int (__thiscall **)(int, int *, _DWORD, _DWORD, signed int))(*((_DWORD *)v3 + 39) + 64))(
                            *((_DWORD *)v3 + 39) + 36,
                            &v10,
                            *((_DWORD *)v3 + 6),
                            0,
                            3) )
    {
      if ( v10 != 1 )
        goto LABEL_7;
      sub_10033ABD(*((_DWORD *)v3 + 7), v8, 1);
      goto LABEL_11;
    }
    sub_10033ABD(*((_DWORD *)v3 + 7), v8, 1);
    v8 = 0;
  }
  else
  {
    if ( !(unsigned __int8)(*(int (__thiscall **)(int, int *, _DWORD, _DWORD, signed int))(*((_DWORD *)v3 + 39) + 64))(
                             *((_DWORD *)v3 + 39) + 36,
                             &v10,
                             *((_DWORD *)v3 + 6),
                             0,
                             1) )
      goto LABEL_17;
    v8 = sub_100517C5((int)&v10, v8);
  }
LABEL_12:
  if ( v8 )
  {
    sub_10046E99((int)((char *)v3 - 4), v8, 2);
    goto LABEL_18;
  }
LABEL_17:
  v1 = 1;
LABEL_18:
  result = sub_1004EAE4();
  if ( v1 )
    result = (*(int (**)(void))(**((_DWORD **)v3 + 38) + 12))();
  return result;
}

//----- (100472C6) --------------------------------------------------------
int __userpurge sub_100472C6<eax>(int a1<ebp>, int a2, int a3)
{
  int v4; // ecx@1
  int v5; // edi@1
  int v6; // esi@1
  void *v7; // ecx@1

  sub_10035648();
  v5 = v4;
  *(_DWORD *)(a1 - 16) = v4;
  v6 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(v4 + 4) = 0;
  *(_DWORD *)(v4 + 8) = 0;
  *(_DWORD *)v4 = v6;
  sub_100458E3((void *)(v4 + 16), v6, 256, 64);
  *(_DWORD *)(a1 - 4) = 0;
  sub_100458E3((void *)(v5 + 96), v6, 256, 64);
  *(_DWORD *)(v5 + 184) = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(v5 + 176) = 0;
  *(_DWORD *)(v5 + 180) = 0;
  *(_DWORD *)(v5 + 188) = 0;
  *(_DWORD *)(a1 - 32) = 0;
  *(_DWORD *)(a1 - 24) = 0;
  *(_DWORD *)(a1 - 20) = 0;
  v7 = *(void **)(v6 + 176);
  *(_BYTE *)(a1 - 4) = 1;
  *(_DWORD *)(v5 + 8) = sub_10040CB9(v7, a1 - 32, v5);
  return sub_10035616(20);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1004734C) --------------------------------------------------------
int __thiscall sub_1004734C(PSLIST_HEADER ListHead)
{
  int v1; // ebx@1
  PSLIST_HEADER v2; // edi@1
  int v3; // eax@1
  int v4; // eax@1
  int i; // esi@2
  int v6; // ecx@3
  int v7; // esi@6

  v2 = ListHead;
  v3 = (int)InterlockedFlushSList(ListHead);
  sub_10047433(v3);
  v4 = (int)InterlockedFlushSList(v2 + 1);
  sub_10047433(v4);
  sub_10047433(LODWORD(v2[2].Alignment));
  v1 = LODWORD(v2[6].Alignment);
  if ( v1 )
  {
    do
    {
      for ( i = 0; i < LODWORD(v2[5].Alignment); ++i )
      {
        v6 = *(_DWORD *)(*(_DWORD *)v1 + 4 * i);
        if ( v6 )
          (**(void (__stdcall ***)(_DWORD))v6)(1);
      }
      v7 = *(_DWORD *)(v1 + 4);
      sub_100303A3(*(LPVOID *)v1);
      sub_1002A4AA((LPVOID)v1);
      v1 = v7;
    }
    while ( v7 );
  }
  return sub_100303A3(HIDWORD(v2[6].Alignment));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (100473C2) --------------------------------------------------------
int __usercall sub_100473C2<eax>(int a1<ebp>)
{
  int v2; // ecx@1
  int v3; // esi@1

  sub_10035648();
  v3 = v2;
  *(_DWORD *)(a1 - 16) = v2;
  *(_DWORD *)(a1 - 4) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  sub_1004734C((PSLIST_HEADER)(v2 + 96));
  *(_DWORD *)(a1 - 4) = -1;
  sub_1004734C((PSLIST_HEADER)(v3 + 16));
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (100473F5) --------------------------------------------------------
int __thiscall sub_100473F5(int this)
{
  int result; // eax@1

  result = this + 188;
  *(_DWORD *)(this + 188) = 1;
  return result;
}

//----- (10047427) --------------------------------------------------------
bool __cdecl sub_10047427(int a1)
{
  bool result; // eax@1

  result = sub_10032DBB(*(_DWORD *)(a1 + 36));
  if ( !result )
  {
    sub_10047433(*(_DWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 16) = 0;
    result = a1 + 72;
    *(_DWORD *)(a1 + 72) = 0;
  }
  return result;
}

//----- (10047433) --------------------------------------------------------
int __stdcall sub_10047433(int a1)
{
  int v1; // esi@1
  int v2; // ecx@2
  int result; // eax@3

  v1 = a1;
  while ( v1 )
  {
    v2 = v1 - 284;
    v1 = *(_DWORD *)v1;
    if ( v2 )
      result = (**(int (__stdcall ***)(_DWORD))v2)(1);
  }
  return result;
}

//----- (10047457) --------------------------------------------------------
char __thiscall sub_10047457(void *ListHead, int a2, signed int a3, char a4)
{
  signed int v4; // edx@1
  int v6; // esi@1
  char result; // al@2
  int v8; // eax@3
  int v9; // ecx@3
  int v10; // edx@4
  int v11; // edi@4
  int v12; // edx@5
  PSINGLE_LIST_ENTRY v18; // eax@14
  int v19; // ST08_4@14

  v6 = (int)ListHead;
  v4 = a3 >> *((_DWORD *)ListHead + 11);
  _EBX = a3 & (*((_DWORD *)ListHead + 10) - 1);
  if ( v4 < *((_DWORD *)ListHead + 15) )
  {
    v9 = *((_DWORD *)ListHead + 14);
    v8 = *(_DWORD *)(v6 + 52);
    if ( v4 < v9 )
    {
      v11 = *(_DWORD *)(v8 + 4 * v4);
    }
    else
    {
      v10 = v4 - v9;
      v11 = *(_DWORD *)(v8 + 4 * v9 - 4);
      if ( v10 >= 0 )
      {
        v12 = v10 + 1;
        do
        {
          v11 = *(_DWORD *)(v11 + 4);
          --v12;
        }
        while ( v12 );
      }
    }
    _ECX = *(_DWORD *)v11 + 4 * _EBX;
    _EDX = 0;
    __asm { lock cmpxchg [ecx], edx }
    if ( a2 == a2 )
    {
      _ECX = v11 + 8;
      __asm { lock cmpxchg [ecx], ebx }
      if ( a4 )
      {
        if ( (signed int)QueryDepthSList((PSLIST_HEADER)v6) <= *(_DWORD *)(v6 + 68) )
        {
          InterlockedPushEntrySList((PSLIST_HEADER)v6, (PSINGLE_LIST_ENTRY)(a2 + 284));
        }
        else
        {
          InterlockedPushEntrySList((PSLIST_HEADER)(v6 + 8), (PSINGLE_LIST_ENTRY)(a2 + 284));
          if ( (signed int)QueryDepthSList((PSLIST_HEADER)(v6 + 8)) > *(_DWORD *)(v6 + 68) )
          {
            if ( !sub_10032DBB(*(_DWORD *)(v6 + 36)) )
            {
              _EDX = 1;
              _ECX = v6 + 72;
              __asm { lock cmpxchg [ecx], edx }
              v18 = InterlockedFlushSList((PSLIST_HEADER)(v6 + 8));
              v19 = *(_DWORD *)(v6 + 36);
              *(_DWORD *)(v6 + 16) = v18;
              sub_100333A7(v6 + 20, (int (__cdecl *)(_DWORD))sub_10047427, v6, v19);
            }
          }
        }
      }
      result = 1;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10047552) --------------------------------------------------------
char __thiscall sub_10047552(void *this, int a2)
{
  int v2; // ecx@2

  if ( *(_DWORD *)(a2 + 12) & 0xFFFFFFF )
    v2 = (int)((char *)this + 16);
  else
    v2 = (int)((char *)this + 96);
  return sub_10047457((void *)v2, a2, *(_DWORD *)(a2 + 248), 1);
}

//----- (1004757B) --------------------------------------------------------
int __thiscall sub_1004757B(int *this, int a2, int a3)
{
  unsigned int v3; // edi@1
  unsigned int v4; // esi@1
  int *v5; // esi@1
  int *v7; // [sp+10h] [bp-4h]@1

  v5 = this;
  v3 = 0;
  v7 = this;
  sub_1003130E(a2, a2, 0, *this);
  v4 = (unsigned int)(*v5 + 31) >> 5;
  if ( v4 )
  {
    do
    {
      *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * v3) = *(_DWORD *)(v7[1] + 4 * v3) & *(_DWORD *)(*(_DWORD *)(a3 + 4) + 4 * v3);
      ++v3;
    }
    while ( v3 < v4 );
  }
  return a2;
}

//----- (100475CB) --------------------------------------------------------
int __userpurge sub_100475CB<eax>(int a1<ecx>, int a2<edi>, int a3, int a4)
{
  int result; // eax@1
  int v5; // esi@1
  int v6; // ST14_4@1
  int v8; // eax@1
  int v9; // esi@1
  int v10; // edi@1
  int v11; // edx@1

  v5 = a1;
  v6 = a1 + 32;
  sub_10030FB0((void *)(a1 + 32));
  _EBX = v5 + 28;
  v8 = sub_10041139(v5, v5 + 28, a2, *(_DWORD *)(v5 + 28), 1);
  v9 = v8;
  v10 = *(_DWORD *)_EBX - *(_DWORD *)(v8 + 16);
  v11 = *(_DWORD *)(v8 + 12);
  _EAX = 1;
  *(_DWORD *)(v11 + 4 * v10) = a4;
  __asm { lock xadd [ebx], eax }
  *(_DWORD *)v6 = 0;
  result = a3;
  *(_DWORD *)(a3 + 4) = v10;
  *(_DWORD *)a3 = v9;
  return result;
}

//----- (1004761E) --------------------------------------------------------
int __thiscall sub_1004761E(int this, int a2)
{
  int v3; // ebx@1

  v3 = this;
  sub_10034B9B((void *)(this + 8));
  *(_DWORD *)(a2 + 232) = 0;
  **(_DWORD **)(v3 + 4) = a2;
  *(_DWORD *)(v3 + 4) = a2 + 232;
  return sub_10034BAB((void *)(v3 + 8));
}

//----- (10047651) --------------------------------------------------------
int __thiscall sub_10047651(int this, int a2)
{
  unsigned int v2; // edi@1
  unsigned int v3; // esi@1
  int result; // eax@2

  v3 = (unsigned int)(*(_DWORD *)this + 31) >> 5;
  v2 = 0;
  if ( v3 )
  {
    do
    {
      _EDX = *(_DWORD *)(*(_DWORD *)(a2 + 4) + 4 * v2);
      result = 4 * v2 + *(_DWORD *)(this + 4);
      __asm { lock or [eax], edx }
      ++v2;
    }
    while ( v2 < v3 );
  }
  return result;
}

//----- (10047689) --------------------------------------------------------
int __userpurge sub_10047689<eax>(int a1<ecx>, int a2<edi>, int a3, int a4, int a5, int a6)
{
  int v7; // eax@1

  v7 = (*(int (__stdcall **)(int, signed int))(*(_DWORD *)a1 + 20))(a5, 1);
  *(_DWORD *)a6 = v7;
  sub_100476AF(v7, a2, a3, a4);
  return a3;
}

//----- (100476AF) --------------------------------------------------------
int __userpurge sub_100476AF<eax>(int a1<ecx>, int a2<edi>, int a3, int a4)
{
  sub_100475CB(a1 + 52, a2, a3, a4);
  return a3;
}

//----- (100476C7) --------------------------------------------------------
int __thiscall sub_100476C7(int this)
{
  int result; // eax@1
  int v2; // edi@1
  int v3; // esi@1

  v3 = this;
  v2 = *(_DWORD *)(*(_DWORD *)(this + 256) + 4);
  sub_100476FA(*(void **)(*(_DWORD *)(this + 256) + 4), this + 28);
  result = *(_DWORD *)(v3 + 12) & 0xFFFFFFF;
  if ( result == 3 )
    result = sub_10047738(v2, *(_DWORD *)(v3 + 36), v3);
  return result;
}

//----- (100476FA) --------------------------------------------------------
bool __thiscall sub_100476FA(void *this, int a2)
{
  bool result; // eax@1
  void *v3; // esi@1
  int v4; // eax@2
  char v5; // [sp+8h] [bp-8h]@2
  void *v6; // [sp+Ch] [bp-4h]@2

  v3 = this;
  result = sub_10033369(a2, (int)((char *)this + 72));
  if ( result )
  {
    v4 = sub_1004757B((int *)a2, (int)&v5, (int)((char *)v3 + 72));
    sub_10047651((int)((char *)v3 + 84), v4);
    result = sub_100303A3(v6);
  }
  return result;
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (10047738) --------------------------------------------------------
int __thiscall sub_10047738(int this, int a2, int a3)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 92);
  if ( !*(_DWORD *)((a2 << 7) + result) )
  {
    _EDX = a3;
    _ECX = (a2 << 7) + *(_DWORD *)(this + 92);
    result = 0;
    __asm { lock cmpxchg [ecx], edx }
  }
  return result;
}

//----- (1004775E) --------------------------------------------------------
int __thiscall sub_1004775E(int this, int a2)
{
  return sub_1004761E(this + 288, a2);
}

//----- (1004776D) --------------------------------------------------------
int __thiscall sub_1004776D(int this, int a2, int a3)
{
  char v3; // zf@1
  int result; // eax@2
  int v5; // [sp+0h] [bp-10h]@1
  int v6; // [sp+8h] [bp-8h]@1
  int v7; // [sp+Ch] [bp-4h]@1

  v3 = (*(_BYTE *)(this + 48) & 4) == 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  if ( v3 )
    result = *(_DWORD *)(this + 56);
  else
    result = sub_10040F22((void *)this, (int)&v5, a3);
  return result;
}

//----- (10047799) --------------------------------------------------------
int __thiscall sub_10047799(int this, int a2, char a3)
{
  int v3; // esi@1
  char v4; // zf@1
  int result; // eax@2
  int v6; // eax@6
  int v7; // [sp+8h] [bp-10h]@1
  int v8; // [sp+10h] [bp-8h]@1
  int v9; // [sp+14h] [bp-4h]@1

  v3 = this;
  v7 = 0;
  v4 = (*(_BYTE *)(this + 48) & 4) == 0;
  v8 = 0;
  v9 = 0;
  if ( v4 )
  {
    result = *(_DWORD *)(this + 56);
    if ( a3 )
    {
      if ( !result )
      {
        sub_10030FB0((void *)(this + 8));
        result = *(_DWORD *)(v3 + 56);
        if ( !result )
        {
          v6 = sub_10032B10(*(_DWORD *)(v3 + 4));
          result = sub_10040CB9((void *)v3, (int)&v7, v6);
          *(_DWORD *)(v3 + 56) = result;
        }
        *(_DWORD *)(v3 + 8) = 0;
      }
    }
  }
  else
  {
    result = sub_10041183(this, (int)&v7, a3);
  }
  return result;
}

//----- (100477FF) --------------------------------------------------------
int __userpurge sub_100477FF<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4)
{
  int v4; // esi@1
  int v5; // ecx@1
  HANDLE v6; // eax@1
  int v7; // eax@2
  int v8; // eax@5
  int v9; // edx@5
  int v10; // ecx@5
  int v12; // ecx@8

  sub_10035648();
  v4 = v5;
  *(_DWORD *)(a2 - 16) = v5;
  sub_1002E10C(a1, a2, *(_DWORD *)(a2 + 8), 1);
  *(_DWORD *)(a2 - 4) = 0;
  *(_DWORD *)v4 = off_10064DDC;
  *(_DWORD *)(v4 + 160) = 0;
  *(_DWORD *)(v4 + 164) = 0;
  v6 = CreateEventW(0, 0, 0, 0);
  *(_DWORD *)(v4 + 168) = v6;
  if ( !v6 )
  {
    v7 = GetLastError();
    if ( v7 > 0 )
      v7 = (unsigned __int16)v7 | 0x80070000;
    sub_10030079(a2 - 32, v7);
    sub_100355BB(a2 - 32, (int)&unk_1006B6E0);
  }
  *(_DWORD *)(v4 + 24) = sub_10032799(*(_DWORD *)(v4 + 28));
  v8 = sub_1002ADB1(v9, v10, a1, 0, 28);
  if ( v8 )
  {
    *(_DWORD *)(v8 + 8) = 0;
    *(_DWORD *)(v8 + 12) = 0;
    *(_DWORD *)(v8 + 16) = 0;
    *(_DWORD *)(v8 + 20) = 0;
    *(_DWORD *)(v8 + 24) = 1;
  }
  else
  {
    v8 = 0;
  }
  v12 = *(_DWORD *)(v4 + 28);
  *(_DWORD *)(v4 + 156) = v8;
  sub_100408F1(v12 + 200, v8);
  sub_10047A97(v4, *(_DWORD *)(a2 + 12));
  return sub_10035616(20);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 10064DDC: using guessed type int (*off_10064DDC[5])();

//----- (100478C5) --------------------------------------------------------
int __usercall sub_100478C5<eax>(int a1<ebp>)
{
  int v2; // ecx@1
  void *v3; // esi@1

  sub_10035648();
  v3 = (void *)v2;
  *(_DWORD *)(a1 - 16) = v2;
  *(_DWORD *)v2 = off_10064DDC;
  *(_DWORD *)(a1 - 4) = 0;
  sub_1004796C(v2, a1);
  sub_1002E239(v3);
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 10064DDC: using guessed type int (*off_10064DDC[5])();

//----- (100478F2) --------------------------------------------------------
void *__thiscall sub_100478F2(void *this, char a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1

  v3 = this;
  sub_100478C5(ebp0);
  if ( a2 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10047911) --------------------------------------------------------
int __userpurge sub_10047911<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4)
{
  int ebp0; // ebp@0

  if ( sub_100479E9(a1, ebp0, a3) )
    JUMPOUT(*(unsigned int *)loc_1002CBD3);
  return sub_1002CCF3(a2, a4);
}
// 1002CBD3: using guessed type _DWORD __cdecl loc_1002CBD3(_DWORD);

//----- (10047932) --------------------------------------------------------
DWORD __thiscall sub_10047932(int this)
{
  DWORD result; // eax@1
  int v2; // esi@1
  int v3; // ST0C_4@1
  int v4; // eax@1

  v2 = this;
  v3 = *(_DWORD *)(this + 8);
  v4 = (*(int (**)(void))(**(_DWORD **)(this + 28) + 4))();
  sub_1002F2FC(3, 4, v4, v3);
  _ECX = v2 + 44;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  result = _EAX + 1;
  if ( result == 1 )
    result = WaitForSingleObject(*(HANDLE *)(v2 + 168), 0xFFFFFFFFu);
  return result;
}

//----- (1004796C) --------------------------------------------------------
int __usercall sub_1004796C<eax>(int a1<ecx>, int a2<ebp>)
{
  int v2; // esi@1
  int result; // eax@7

  v2 = a1;
  sub_1002E6D7(a1, a2);
  if ( *(_DWORD *)(v2 + 164) )
  {
    CloseHandle(*(HANDLE *)(v2 + 164));
    *(_DWORD *)(v2 + 164) = 0;
  }
  if ( *(_DWORD *)(v2 + 168) )
    CloseHandle(*(HANDLE *)(v2 + 168));
  if ( *(_DWORD *)(v2 + 160) )
    sub_10033FEE(*(void **)(v2 + 160));
  result = *(_DWORD *)(v2 + 156);
  *(_DWORD *)(v2 + 156) = 0;
  *(_DWORD *)(result + 24) = 0;
  return result;
}

//----- (100479C4) --------------------------------------------------------
char __userpurge sub_100479C4<al>(void *this<ecx>, int edi0<edi>, int a2)
{
  int v3; // eax@1
  int ebp0; // ebp@0
  char result; // al@2

  v3 = sub_100479E9((int)this, ebp0, edi0);
  if ( v3 )
    result = sub_1002CC67((void *)v3, a2);
  else
    result = sub_100303A3((LPVOID)(a2 - 4));
  return result;
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (100479E9) --------------------------------------------------------
int __usercall sub_100479E9<eax>(int a1<ecx>, int a2<ebp>, int a3<edi>)
{
  int v3; // esi@1

  v3 = a1;
  if ( !*(_DWORD *)(a1 + 160) )
    *(_DWORD *)(a1 + 160) = sub_10032C48(a2, a3);
  return *(_DWORD *)(v3 + 160);
}

//----- (10047A0B) --------------------------------------------------------
signed int __cdecl sub_10047A0B()
{
  return -1;
}

//----- (10047A0F) --------------------------------------------------------
int __stdcall sub_10047A0F(int a1, int a2, int a3, int a4)
{
  sub_10032313(*(void **)(a2 + 28), a2, 0);
  return sub_10034B66(a1, a3);
}

//----- (10047A31) --------------------------------------------------------
char __stdcall sub_10047A31(int a1, int a2)
{
  UnregisterWait(*(HANDLE *)(a1 + 172));
  return sub_10032313(*(void **)(a1 + 28), a1, 0);
}

//----- (10047A54) --------------------------------------------------------
bool __thiscall sub_10047A54(int this)
{
  return *(_DWORD *)(this + 44) == 1;
}

//----- (10047A60) --------------------------------------------------------
void __thiscall sub_10047A60(int this, char a2)
{
  int v2; // eax@3
  char v3; // [sp+0h] [bp-Ch]@6

  if ( a2 )
  {
    ++*(_DWORD *)(this + 20);
  }
  else
  {
    v2 = *(_DWORD *)(this + 20);
    if ( !v2 )
    {
      sub_1002FFE7((int)&v3);
      sub_100355BB((int)&v3, (int)&unk_1006C25C);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_10047A97);
    }
    *(_DWORD *)(this + 20) = v2 - 1;
  }
}

//----- (10047A97) --------------------------------------------------------
DWORD __thiscall sub_10047A97(int Context, char a2)
{
  DWORD result; // eax@1
  int v3; // edi@1
  HANDLE *v4; // ebx@2
  HANDLE v5; // ST08_4@2
  HANDLE v6; // ST04_4@2
  HANDLE v7; // eax@2
  int v8; // eax@3
  char v9; // [sp+8h] [bp-10h]@13

  v3 = Context;
  *(_BYTE *)(Context + 152) = a2;
  result = GetCurrentThreadId();
  *(_DWORD *)(v3 + 68) = result;
  if ( !a2 )
  {
    v4 = (HANDLE *)(v3 + 164);
    v5 = GetCurrentProcess();
    v6 = GetCurrentThread();
    v7 = GetCurrentProcess();
    if ( !DuplicateHandle(v7, v6, v5, (LPHANDLE)(v3 + 164), 0, 0, 2u) )
    {
      v8 = GetLastError();
      if ( v8 > 0 )
LABEL_12:
        v8 = (unsigned __int16)v8 | 0x80070000;
LABEL_13:
      sub_10030079((int)&v9, v8);
      sub_100355BB((int)&v9, (int)&unk_1006B6E0);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_10047B64);
    }
    if ( sub_1003D685() < 3 )
    {
      result = RegisterWaitForSingleObject(
                 (PHANDLE)(v3 + 172),
                 *v4,
                 (WAITORTIMERCALLBACK)sub_10047A31,
                 (PVOID)v3,
                 0xFFFFFFFFu,
                 0xCu);
    }
    else
    {
      result = sub_10034AF2((int)*v4, (int)sub_10047A0F, v3);
      *(_DWORD *)(v3 + 172) = result;
    }
    if ( !result )
    {
      v8 = GetLastError();
      if ( v8 > 0 )
        goto LABEL_12;
      goto LABEL_13;
    }
  }
  return result;
}
// 1003D685: using guessed type int sub_1003D685(void);

//----- (10047B64) --------------------------------------------------------
BOOL __usercall sub_10047B64<eax>(int a1<ecx>, int a2<ebp>)
{
  BOOL result; // eax@1
  int v3; // esi@1

  v3 = a1;
  sub_1002EDD5(a1, a2);
  result = *(_DWORD *)(v3 + 164);
  if ( result )
  {
    result = CloseHandle(*(HANDLE *)(v3 + 164));
    *(_DWORD *)(v3 + 164) = 0;
  }
  return result;
}

//----- (10047B86) --------------------------------------------------------
int __thiscall sub_10047B86(void *this)
{
  return (*(int (**)(void))(*(_DWORD *)this + 28))();
}

//----- (10047B8B) --------------------------------------------------------
int __thiscall sub_10047B8B(void *this)
{
  void *v1; // esi@1
  int v2; // ecx@2
  int v3; // ST0C_4@2
  int v4; // eax@2
  int result; // eax@3
  int v13; // ecx@8
  int v14; // eax@8
  int v15; // ST10_4@8
  int v16; // [sp-4h] [bp-14h]@6
  char v17; // [sp+4h] [bp-Ch]@6
  int v18; // [sp+8h] [bp-8h]@8
  int v19; // [sp+Ch] [bp-4h]@8

  v1 = this;
  if ( this == sub_10032356() )
  {
    sub_1002FF27((int)&v17);
    v16 = (int)&unk_1006C224;
    goto LABEL_8;
  }
  v3 = *((_DWORD *)v1 + 2);
  v4 = (*(int (**)(void))(**((_DWORD **)v1 + 7) + 4))();
  sub_1002F2FC(4, 4, v4, v3);
  _EAX = (int)((char *)v1 + 44);
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  v2 = _ECX - 1;
  if ( !v2 )
    return SetEvent(*((HANDLE *)v1 + 42));
  result = v2 + 1;
  if ( (unsigned int)(v2 + 1) > 1 )
  {
    sub_1002FF39((int)&v17);
    v16 = (int)&unk_1006C1EC;
LABEL_8:
    sub_100355BB((int)&v17, v16);
    __asm { int     3               ; Trap to Debugger }
    v14 = (*(int (__stdcall **)(_DWORD, void *, int, _DWORD, int))(**(_DWORD **)(v13 + 28) + 4))(
            *(_DWORD *)(v13 + 8),
            v1,
            v15,
            *(_DWORD *)&v17,
            v18);
    sub_1002F2FC(5, 4, v14, v19);
    result = SwitchToThread();
  }
  return result;
}

//----- (10047C21) --------------------------------------------------------
void *__thiscall sub_10047C21(void *this, int a2)
{
  void *v3; // esi@1

  v3 = this;
  sub_10045F35(this, a2);
  *(_DWORD *)v3 = off_10064E48;
  *((_DWORD *)v3 + 1) = off_10064E74;
  return v3;
}
// 10064E48: using guessed type int (*off_10064E48[3])();
// 10064E74: using guessed type int (*off_10064E74[5])();

//----- (10047C43) --------------------------------------------------------
void *__thiscall sub_10047C43(void *this, int a2)
{
  int ebp0; // ebp@0
  void *v4; // edi@1

  v4 = this;
  *(_DWORD *)this = off_10064E28;
  sub_10031354(ebp0, a2);
  *(_DWORD *)v4 = off_10064EC0;
  *((_DWORD *)v4 + 2) = &off_10064EE4;
  return v4;
}
// 10064E28: using guessed type int (*off_10064E28[7])();
// 10064EC0: using guessed type int (*off_10064EC0[2])();
// 10064EE4: using guessed type int (__stdcall *off_10064EE4)(int);

//----- (10047C70) --------------------------------------------------------
int __thiscall sub_10047C70(int this)
{
  *(_DWORD *)this = off_10064EC0;
  *(_DWORD *)(this + 8) = &off_10064EE4;
  return sub_10031803(this);
}
// 10031803: using guessed type _DWORD __thiscall sub_10031803(_DWORD ecx0);
// 10064EC0: using guessed type int (*off_10064EC0[2])();
// 10064EE4: using guessed type int (__stdcall *off_10064EE4)(int);

//----- (10047C84) --------------------------------------------------------
void __stdcall sub_10047C84(int a1)
{
  JUMPOUT(*(unsigned int *)loc_10047C94);
}
// 10047C94: using guessed type int __stdcall loc_10047C94(int);

//----- (10047C8C) --------------------------------------------------------
void *__thiscall sub_10047C8C(void *this, char a2)
{
  void *v2; // esi@1

  v2 = (char *)this - 8;
  sub_10047C70((int)((char *)this - 8));
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10047CDF) --------------------------------------------------------
int __thiscall sub_10047CDF(void *this, int a2, unsigned int a3)
{
  return sub_10031C25((char *)this + 8, a2, a3);
}

//----- (10047CEB) --------------------------------------------------------
int __usercall sub_10047CEB<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // ecx@1
  int v4; // edx@1
  int v5; // ecx@1

  sub_10035648();
  v3 = sub_1002ADB1(v4, v5, a1, a3, 520);
  *(_DWORD *)(a2 - 16) = v3;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v3 )
    sub_10047C43((void *)v3, *(_DWORD *)(a2 + 8));
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (10047D1E) --------------------------------------------------------
int __usercall sub_10047D1E<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>)
{
  int v3; // edx@1
  int v4; // esi@1
  int v5; // ecx@1
  int v6; // edx@1

  sub_10035648();
  v4 = v5;
  v3 = sub_1002ADB1(v6, v5, a1, a3, 240);
  *(_DWORD *)(a2 - 16) = v3;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v3 )
    sub_10047C21((void *)v3, v4 != 8 ? v4 : 0);
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (10047D5C) --------------------------------------------------------
int __userpurge sub_10047D5C<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5)
{
  int v5; // eax@1
  int v6; // edx@1
  int v7; // ecx@1

  sub_10035648();
  v5 = sub_1002ADB1(v6, v7, a1, a3, 208);
  *(_DWORD *)(a2 - 16) = v5;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v5 )
    sub_10052C25(a2, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12));
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (10047D94) --------------------------------------------------------
signed int __cdecl sub_10047D94()
{
  return 1;
}

//----- (10047D98) --------------------------------------------------------
int __thiscall sub_10047D98(void *this)
{
  return (int)((char *)this - 8);
}

//----- (10047D9C) --------------------------------------------------------
int __userpurge sub_10047D9C<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  sub_10032B8C(a1, a2 + 8, a3, a4, a5);
  return a5;
}

//----- (10047DB6) --------------------------------------------------------
int __userpurge sub_10047DB6<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  return sub_10047D9C(a1, a2 - 8, a3, a4, a5);
}

//----- (10047DC1) --------------------------------------------------------
int __thiscall sub_10047DC1(void *this, int a2, unsigned int a3)
{
  return sub_10033EAB((char *)this + 8, a2, a3);
}

//----- (10047DCD) --------------------------------------------------------
int __thiscall sub_10047DCD(void *this, int a2, int a3, int a4)
{
  return sub_1003424B((char *)this + 8, a2, a3, a4);
}

//----- (10047DD9) --------------------------------------------------------
DWORD __cdecl sub_10047DD9()
{
  DWORD result; // eax@1
  int v1; // eax@2
  char v2; // [sp+0h] [bp-10h]@5

  result = TlsAlloc();
  dword_10075F70 = result;
  if ( result == -1 )
  {
    v1 = GetLastError();
    if ( v1 > 0 )
      v1 = (unsigned __int16)v1 | 0x80070000;
    sub_10030079((int)&v2, v1);
    sub_100355BB((int)&v2, (int)&unk_1006B6E0);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10047E1D);
  }
  return result;
}

//----- (10047E1D) --------------------------------------------------------
BOOL __cdecl sub_10047E1D()
{
  BOOL result; // eax@1

  result = TlsFree(dword_10075F70);
  dword_10075F70 = 0;
  return result;
}

//----- (10047E31) --------------------------------------------------------
signed int __usercall sub_10047E31<eax>(int a1<ecx>, int a2<ebx>)
{
  unsigned int v2; // eax@1
  void *v3; // eax@6
  signed int result; // eax@8
  int v5; // edx@9
  signed int v6; // ecx@9
  int v7; // [sp-4h] [bp-8h]@6

  v2 = dword_100768A0;
  if ( !dword_100768A0 )
  {
    v2 = 512;
LABEL_5:
    dword_100768A0 = v2;
    goto LABEL_6;
  }
  if ( dword_100768A0 < 20 )
  {
    v2 = 20;
    goto LABEL_5;
  }
LABEL_6:
  v3 = sub_100374E6(a1, a2, v2, 4u);
  dword_1007689C = v3;
  if ( v3 || (dword_100768A0 = 20, v3 = sub_100374E6(v7, a2, 0x14u, 4u), dword_1007689C = v3, v3) )
  {
    v5 = 0;
    v6 = (signed int)&off_10073DD8;
    while ( 1 )
    {
      *(_DWORD *)((char *)v3 + v5) = v6;
      v6 += 32;
      v5 += 4;
      if ( v6 >= (signed int)&unk_10074058 )
        break;
      v3 = dword_1007689C;
    }
    result = 0;
  }
  else
  {
    result = 26;
  }
  return result;
}
// 10073DD8: using guessed type void *off_10073DD8;
// 100768A0: using guessed type int dword_100768A0;

//----- (10047EA4) --------------------------------------------------------
void __usercall sub_10047EA4(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v3; // edx@1
  int v4; // ecx@1

  sub_10048051(a1, a2, a3);
  if ( byte_1007584C )
    sub_10052C81(v3, v4, a3);
  sub_100309C2(a3, dword_1007689C);
  dword_1007689C = 0;
}
// 1007584C: using guessed type char byte_1007584C;

//----- (10047ECB) --------------------------------------------------------
void **__cdecl sub_10047ECB()
{
  return &off_10073DD8;
}
// 10073DD8: using guessed type void *off_10073DD8;

//----- (10047ED1) --------------------------------------------------------
void __usercall sub_10047ED1(int a1<edx>, int a2<ebx>, int a3<edi>, unsigned int a4)
{
  if ( a4 < (unsigned int)&off_10073DD8 || a4 > (unsigned int)&unk_10074038 )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(a4 + 32));
  }
  else
  {
    sub_10036A23(a1, (int)&off_10073DD8, a2, a3, ((signed int)(a4 - (_DWORD)&off_10073DD8) >> 5) + 16);
    *(_DWORD *)(a4 + 12) |= 0x8000u;
  }
}
// 10073DD8: using guessed type void *off_10073DD8;

//----- (10047F10) --------------------------------------------------------
void __usercall sub_10047F10(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5, int a6)
{
  if ( a5 >= 20 )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(a6 + 32));
  }
  else
  {
    sub_10036A23(a1, a2, a3, a4, a5 + 16);
    *(_DWORD *)(a6 + 12) |= 0x8000u;
  }
}

//----- (10047F40) --------------------------------------------------------
void __cdecl sub_10047F40(unsigned int a1)
{
  if ( a1 < (unsigned int)&off_10073DD8 || a1 > (unsigned int)&unk_10074038 )
  {
    LeaveCriticalSection((LPCRITICAL_SECTION)(a1 + 32));
  }
  else
  {
    *(_DWORD *)(a1 + 12) &= 0xFFFF7FFFu;
    sub_10036B87(((signed int)(a1 - (_DWORD)&off_10073DD8) >> 5) + 16);
  }
}
// 10073DD8: using guessed type void *off_10073DD8;

//----- (10047F7A) --------------------------------------------------------
void __cdecl sub_10047F7A(signed int a1, int a2)
{
  if ( a1 >= 20 )
  {
    LeaveCriticalSection((LPCRITICAL_SECTION)(a2 + 32));
  }
  else
  {
    *(_DWORD *)(a2 + 12) &= 0xFFFF7FFFu;
    sub_10036B87(a1 + 16);
  }
}

//----- (10047FA7) --------------------------------------------------------
void __usercall sub_10047FA7(int a1<ebx>, int a2<edi>, int edx0<edx>, int a4<ecx>, int a3)
{
  int v5; // eax@6
  int v6; // edx@6
  int v7; // ecx@6

  if ( a3 )
  {
    if ( !sub_10047FED(a3) )
    {
      if ( *(_DWORD *)(a3 + 12) & 0x4000 )
      {
        v5 = sub_1004FC88(a1, a2, a3);
        sub_10052D1E(v6, v7, a1, v5);
      }
    }
  }
  else
  {
    sub_1004805A(edx0, a4, a1, 0);
  }
}

//----- (10047FED) --------------------------------------------------------
signed int __cdecl sub_10047FED(int a1)
{
  signed int v1; // ebx@1
  int v2; // edi@3
  int v3; // ST08_4@4
  const void *v4; // ST04_4@4
  int v5; // eax@4
  int v6; // edx@4
  int v7; // ST00_4@4
  int v8; // eax@4
  int v9; // eax@5
  int v11; // ecx@8

  v1 = 0;
  if ( (*(_DWORD *)(a1 + 12) & 3) == 2 )
  {
    if ( *(_DWORD *)(a1 + 12) & 0x108 )
    {
      v2 = *(_DWORD *)a1 - *(_DWORD *)(a1 + 8);
      if ( *(_DWORD *)a1 - *(_DWORD *)(a1 + 8) > 0 )
      {
        v3 = *(_DWORD *)a1 - *(_DWORD *)(a1 + 8);
        v4 = *(const void **)(a1 + 8);
        v5 = sub_1004FC88(0, v2, a1);
        sub_1004FEEB(v6, v7, 0, v2, v5, v4, v3);
        if ( v8 == v2 )
        {
          v9 = *(_DWORD *)(a1 + 12);
          if ( (_BYTE)v9 < 0 )
            *(_DWORD *)(a1 + 12) = v9 & 0xFFFFFFFD;
        }
        else
        {
          *(_DWORD *)(a1 + 12) |= 0x20u;
          v1 = -1;
        }
      }
    }
  }
  v11 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = v11;
  return v1;
}

//----- (10048051) --------------------------------------------------------
void __usercall sub_10048051(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  sub_1004805A(a1, a2, a3, 1);
}

//----- (1004805A) --------------------------------------------------------
void __usercall sub_1004805A(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // edx@1
  signed int i; // esi@1
  int v6; // eax@3
  int v7; // eax@5
  int v8; // edx@5
  int v9; // eax@7
  int v10; // [sp-4h] [bp-38h]@1
  int v11; // [sp-4h] [bp-38h]@5

  sub_10036A23(a1, a2, a3, 0, 1);
  for ( i = 0; ; ++i )
  {
    if ( i >= dword_100768A0 )
    {
      sub_10036B87(1);
      return;
    }
    v6 = *((_DWORD *)dword_1007689C + i);
    if ( v6 )
    {
      if ( *(_BYTE *)(v6 + 12) & 0x83 )
        break;
    }
  }
  sub_10047F10(v4, v10, a4, 0, i, *((_DWORD *)dword_1007689C + i));
  v7 = *((_DWORD *)dword_1007689C + i);
  if ( *(_BYTE *)(v7 + 12) & 0x83 )
  {
    if ( a4 == 1 )
    {
      sub_10047FA7(1, 0, v8, v11, *((_DWORD *)dword_1007689C + i));
      v9 == -1;
    }
    else
    {
      if ( !a4 )
      {
        if ( *(_BYTE *)(v7 + 12) & 2 )
          sub_10047FA7(a4, 0, v8, v11, *((_DWORD *)dword_1007689C + i));
      }
    }
  }
  sub_10047F7A(i, *((_DWORD *)dword_1007689C + i));
}
// 100768A0: using guessed type int dword_100768A0;

//----- (100481B5) --------------------------------------------------------
int __usercall sub_100481B5<eax>(int a1<ebx>, int a2, int a3)
{
  int result; // eax@1
  int v4; // esi@1
  int v5; // edx@2
  unsigned int v6; // ecx@2
  void (__cdecl *v7)(_DWORD); // edx@9
  int v8; // ebx@14
  signed int v9; // edi@15
  int v10; // edi@17
  int v11; // ST04_4@36

  result = sub_1004196A(a1);
  v4 = result;
  if ( result )
  {
    v5 = *(_DWORD *)(result + 92);
    v6 = *(_DWORD *)(result + 92);
    do
    {
      if ( *(_DWORD *)v6 == a2 )
        break;
      v6 += 12;
    }
    while ( v6 < v5 + 144 );
    if ( v6 >= v5 + 144 || *(_DWORD *)v6 != a2 )
      v6 = 0;
    if ( v6 && (v7 = *(void (__cdecl **)(_DWORD))(v6 + 8)) != 0 )
    {
      if ( v7 == (void (__cdecl *)(_DWORD))5 )
      {
        *(_DWORD *)(v6 + 8) = 0;
        result = 1;
      }
      else
      {
        if ( v7 == (void (__cdecl *)(_DWORD))1 )
        {
          result = -1;
        }
        else
        {
          v8 = *(_DWORD *)(result + 96);
          *(_DWORD *)(result + 96) = a3;
          if ( *(_DWORD *)(v6 + 4) == 8 )
          {
            v9 = 36;
            do
            {
              v9 += 12;
              *(_DWORD *)(v9 + *(_DWORD *)(result + 92) - 4) = 0;
            }
            while ( v9 < 144 );
            v10 = *(_DWORD *)(result + 100);
            switch ( *(_DWORD *)v6 )
            {
              case 0xC000008E:
                *(_DWORD *)(result + 100) = 131;
                break;
              case 0xC0000090:
                *(_DWORD *)(result + 100) = 129;
                break;
              case 0xC0000091:
                *(_DWORD *)(result + 100) = 132;
                break;
              case 0xC0000093:
                *(_DWORD *)(result + 100) = 133;
                break;
              case 0xC000008D:
                *(_DWORD *)(result + 100) = 130;
                break;
              case 0xC000008F:
                *(_DWORD *)(result + 100) = 134;
                break;
              case 0xC0000092:
                *(_DWORD *)(result + 100) = 138;
                break;
              case 0xC00002B5:
                *(_DWORD *)(result + 100) = 141;
                break;
              case 0xC00002B4:
                *(_DWORD *)(result + 100) = 142;
                break;
            }
            v7(8);
            *(_DWORD *)(v4 + 100) = v10;
          }
          else
          {
            v11 = *(_DWORD *)(v6 + 4);
            *(_DWORD *)(v6 + 8) = 0;
            v7(v11);
          }
          *(_DWORD *)(v4 + 96) = v8;
          result = -1;
        }
      }
    }
    else
    {
      result = 0;
    }
  }
  return result;
}

//----- (10048310) --------------------------------------------------------
int __usercall sub_10048310<eax>(int a1<ebx>, int a2, int a3)
{
  int result; // eax@2

  if ( a2 == -529697949 )
    result = sub_100481B5(a1, -529697949, a3);
  else
    result = 0;
  return result;
}

//----- (1004832E) --------------------------------------------------------
void __usercall sub_1004832E(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  int ebp0; // ebp@0
  int v5; // eax@1
  unsigned int v6; // ecx@1
  signed int v7; // ebx@1
  int v8; // ST08_4@1
  int v9; // ecx@8
  signed int v10; // esi@10
  int v11; // eax@12
  unsigned int v12; // ecx@12
  int v13; // eax@14
  HANDLE *v14; // edx@14
  signed int v15; // edi@14
  char v16; // al@18
  DWORD v17; // eax@20
  int v18; // esi@21
  int v19; // esi@29
  DWORD v20; // eax@33
  HANDLE v21; // eax@35
  HANDLE v22; // edi@35
  DWORD v23; // eax@37
  int v24; // eax@38
  char v25; // al@39
  struct _STARTUPINFOW StartupInfo; // [sp+10h] [bp-74h]@6
  int v27; // [sp+54h] [bp-30h]@10
  int v28; // [sp+58h] [bp-2Ch]@14
  LPBYTE v29; // [sp+5Ch] [bp-28h]@8
  unsigned int v30; // [sp+60h] [bp-24h]@1
  BYTE *v31; // [sp+64h] [bp-20h]@8
  int v32; // [sp+68h] [bp-1Ch]@8
  CPPEH_RECORD ms_exc; // [sp+6Ch] [bp-18h]@1

  sub_10036A23(a1, a2, a3, a4, 11);
  v7 = 0;
  ms_exc.disabled = 0;
  v5 = (int)sub_100374E6(v8, 0, 0x20u, 0x40u);
  v6 = v5;
  v30 = v5;
  if ( !v5 )
  {
    sub_1004B230(ebp0, (int)&__security_cookie, (int)&ms_exc.prev_er, 0xFFFFFFFEu);
    return;
  }
  dword_10075F80[0] = v5;
  dword_10076898 = 32;
  while ( v6 < v5 + 2048 )
  {
    *(_WORD *)(v6 + 4) = 2560;
    *(_DWORD *)v6 = -1;
    *(_DWORD *)(v6 + 8) = 0;
    *(_BYTE *)(v6 + 36) &= 0x80u;
    *(_BYTE *)(v6 + 36) &= 0x7Fu;
    *(_WORD *)(v6 + 37) = 2570;
    *(_WORD *)(v6 + 52) = 0;
    v6 += 64;
    v30 = v6;
    v5 = dword_10075F80[0];
  }
  GetStartupInfoW(&StartupInfo);
  if ( StartupInfo.cbReserved2 && StartupInfo.lpReserved2 )
  {
    v9 = *(_DWORD *)StartupInfo.lpReserved2;
    v32 = v9;
    v29 = StartupInfo.lpReserved2 + 4;
    v31 = &StartupInfo.lpReserved2[v9 + 4];
    if ( v9 >= 2048 )
    {
      v9 = 2048;
      v32 = 2048;
    }
    v10 = 1;
    v27 = 1;
    while ( 1 )
    {
      if ( dword_10076898 >= v9 )
        goto LABEL_14;
      v11 = (int)sub_100374E6(v9, 0, 0x20u, 0x40u);
      v12 = v11;
      v30 = v11;
      if ( !v11 )
      {
        v9 = dword_10076898;
        v32 = dword_10076898;
LABEL_14:
        v15 = 0;
        v28 = 0;
        v13 = (int)v29;
        v14 = (HANDLE *)v31;
        while ( v15 < v9 )
        {
          if ( *v14 != (HANDLE)-1 )
          {
            if ( *v14 != (HANDLE)-2 )
            {
              v16 = *(_BYTE *)v13;
              if ( v16 & 1 )
              {
                if ( v16 & 8 || (v17 = GetFileType(*v14), v14 = (HANDLE *)v31, v17) )
                {
                  v18 = dword_10075F80[v15 >> 5] + ((v15 & 0x1F) << 6);
                  v30 = v18;
                  *(_DWORD *)v18 = *v14;
                  *(_BYTE *)(v18 + 4) = *v29;
                  InitializeCriticalSectionAndSpinCount((LPCRITICAL_SECTION)(v18 + 12), 0xFA0u);
                  ++*(_DWORD *)(v18 + 8);
                  v14 = (HANDLE *)v31;
                }
                v9 = v32;
              }
            }
          }
          ++v15;
          v28 = v15;
          v13 = (int)(v29++ + 1);
          ++v14;
          v31 = (BYTE *)v14;
        }
        break;
      }
      dword_10075F80[v10] = v11;
      dword_10076898 += 32;
      while ( v12 < dword_10075F80[v10] + 2048 )
      {
        *(_WORD *)(v12 + 4) = 2560;
        *(_DWORD *)v12 = -1;
        *(_DWORD *)(v12 + 8) = 0;
        *(_BYTE *)(v12 + 36) &= 0x80u;
        *(_WORD *)(v12 + 37) = 2570;
        *(_WORD *)(v12 + 52) = 0;
        v12 += 64;
        v30 = v12;
      }
      ++v10;
      v27 = v10;
      v9 = v32;
    }
  }
  while ( 1 )
  {
    v28 = v7;
    if ( v7 >= 3 )
      break;
    v19 = dword_10075F80[0] + (v7 << 6);
    v30 = v19;
    if ( *(_DWORD *)v19 != -1 && *(_DWORD *)v19 != -2 )
    {
      *(_BYTE *)(v19 + 4) |= 0x80u;
      goto LABEL_46;
    }
    *(_BYTE *)(v19 + 4) = -127;
    if ( v7 )
      v20 = -(v7 != 1) - 11;
    else
      v20 = -10;
    v21 = GetStdHandle(v20);
    v22 = v21;
    if ( v21 != (HANDLE)-1 )
    {
      if ( v21 )
      {
        v23 = GetFileType(v21);
        if ( v23 )
        {
          *(_DWORD *)v19 = v22;
          v24 = (unsigned __int8)v23;
          if ( v24 == 2 )
          {
            v25 = *(_BYTE *)(v19 + 4) | 0x40;
            goto LABEL_42;
          }
          if ( v24 == 3 )
          {
            v25 = *(_BYTE *)(v19 + 4) | 8;
LABEL_42:
            *(_BYTE *)(v19 + 4) = v25;
          }
          InitializeCriticalSectionAndSpinCount((LPCRITICAL_SECTION)(v19 + 12), 0xFA0u);
          ++*(_DWORD *)(v19 + 8);
          goto LABEL_46;
        }
      }
    }
    *(_BYTE *)(v19 + 4) |= 0x40u;
    *(_DWORD *)v19 = -2;
    if ( dword_1007689C )
      *(_DWORD *)(*((_DWORD *)dword_1007689C + v7) + 16) = -2;
LABEL_46:
    ++v7;
  }
  ms_exc.disabled = -2;
  sub_10036B87(11);
}
// 10073200: using guessed type int __security_cookie;
// 10075F80: using guessed type int dword_10075F80[];
// 10076898: using guessed type int dword_10076898;

//----- (100485DC) --------------------------------------------------------
void __usercall sub_100485DC(int a1<ebx>)
{
  LPVOID *v1; // esi@1
  LPVOID v2; // edi@2
  struct _RTL_CRITICAL_SECTION *v3; // edi@4

  v1 = (LPVOID *)dword_10075F80;
  do
  {
    v2 = *v1;
    if ( *v1 )
    {
      if ( v2 < (char *)v2 + 2048 )
      {
        v3 = (struct _RTL_CRITICAL_SECTION *)((char *)v2 + 12);
        do
        {
          if ( *((_DWORD *)v3 - 1) )
            DeleteCriticalSection(v3);
          v3 = (struct _RTL_CRITICAL_SECTION *)((char *)v3 + 64);
        }
        while ( (char *)((char *)v3 - 12) < (char *)*v1 + 2048 );
      }
      sub_100309C2(a1, *v1);
      *v1 = 0;
    }
    ++v1;
  }
  while ( (signed int)v1 < (signed int)byte_10076080 );
}
// 10075F80: using guessed type int dword_10075F80[];

//----- (1004862E) --------------------------------------------------------
signed int __usercall sub_1004862E<eax>(int a1<ebx>)
{
  int v1; // esi@3
  int v2; // ebx@6
  int v3; // edx@8
  int v4; // edi@9
  signed int result; // eax@10
  int v6; // [sp+0h] [bp-8h]@6
  int v7; // [sp+4h] [bp-4h]@6

  if ( !dword_100778D0 )
    sub_10041E6B(a1);
  byte_10076184 = 0;
  GetModuleFileNameA(0, byte_10076080, 0x104u);
  v1 = dword_10077954;
  dword_10075874 = (int)byte_10076080;
  if ( !dword_10077954 || !*(_BYTE *)dword_10077954 )
    v1 = (int)byte_10076080;
  sub_100486DF(v1, 0, 0, (int)&v7, (int)&v6);
  v2 = v7;
  if ( (unsigned int)v7 < 0x3FFFFFFF
    && (unsigned int)v6 < 0xFFFFFFFF
    && (v3 = v6 + 4 * v7, v3 >= (unsigned int)v6)
    && (v4 = sub_10037530(v3, v6, v7, v6 + 4 * v7)) != 0 )
  {
    sub_100486DF(v1, v4, v4 + 4 * v2, (int)&v7, (int)&v6);
    dword_10075860 = v7 - 1;
    dword_10075864 = (LPVOID)v4;
    result = 0;
  }
  else
  {
    result = -1;
  }
  return result;
}
// 10075860: using guessed type int dword_10075860;
// 10075874: using guessed type int dword_10075874;
// 10076184: using guessed type char byte_10076184;
// 100778D0: using guessed type int dword_100778D0;
// 10077954: using guessed type int dword_10077954;

//----- (100486DF) --------------------------------------------------------
int __cdecl sub_100486DF(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // edi@1
  int v7; // esi@1
  bool v8; // ecx@3
  char v9; // al@5
  unsigned __int8 v10; // ST00_1@8
  signed int v11; // edx@29
  unsigned int v12; // ecx@29
  unsigned __int8 v13; // al@43
  signed int v14; // eax@48
  int result; // eax@61
  bool v16; // [sp+14h] [bp+8h]@3
  bool v17; // [sp+24h] [bp+18h]@20
  char v18; // [sp+27h] [bp+1Bh]@8

  v5 = a5;
  *(_DWORD *)a5 = 0;
  v7 = a1;
  *(_DWORD *)a4 = 1;
  v6 = a3;
  if ( a2 )
  {
    *(_DWORD *)a2 = a3;
    a2 += 4;
  }
  v8 = 0;
  v16 = 0;
  do
  {
    if ( *(_BYTE *)v7 == 34 )
    {
      ++v7;
      v8 = v8 == 0;
      v16 = v8;
      v9 = 34;
    }
    else
    {
      ++*(_DWORD *)v5;
      if ( v6 )
        *(_BYTE *)v6++ = *(_BYTE *)v7;
      v18 = *(_BYTE *)v7;
      v10 = *(_BYTE *)v7++;
      if ( sub_100376F3(v5, v6, v10) )
      {
        ++*(_DWORD *)v5;
        if ( v6 )
          *(_BYTE *)v6++ = *(_BYTE *)v7;
        ++v7;
      }
      v9 = v18;
      if ( !v18 )
      {
        --v7;
        goto LABEL_20;
      }
      v8 = v16;
    }
  }
  while ( v8 || v9 != 32 && v9 != 9 );
  if ( v6 )
    *(_BYTE *)(v6 - 1) = 0;
LABEL_20:
  v17 = 0;
  while ( *(_BYTE *)v7 )
  {
    while ( *(_BYTE *)v7 == 32 || *(_BYTE *)v7 == 9 )
      ++v7;
    if ( !*(_BYTE *)v7 )
      break;
    if ( a2 )
    {
      *(_DWORD *)a2 = v6;
      a2 += 4;
    }
    ++*(_DWORD *)a4;
    while ( 1 )
    {
      v11 = 1;
      v12 = 0;
      while ( *(_BYTE *)v7 == 92 )
      {
        ++v7;
        ++v12;
      }
      if ( *(_BYTE *)v7 == 34 )
      {
        if ( !(v12 & 1) )
        {
          if ( v17 && *(_BYTE *)(v7 + 1) == 34 )
          {
            ++v7;
          }
          else
          {
            v11 = 0;
            v17 = v17 == 0;
          }
        }
        v12 >>= 1;
      }
      while ( v12 )
      {
        --v12;
        if ( v6 )
          *(_BYTE *)v6++ = 92;
        ++*(_DWORD *)v5;
      }
      v13 = *(_BYTE *)v7;
      if ( !*(_BYTE *)v7 )
        break;
      if ( v17 == v12 && (v13 == 32 || v13 == 9) )
        break;
      if ( v11 )
      {
        v14 = sub_100376F3(v5, v6, v13);
        if ( v6 )
        {
          if ( v14 )
          {
            *(_BYTE *)v6++ = *(_BYTE *)v7++;
            ++*(_DWORD *)v5;
          }
          *(_BYTE *)v6++ = *(_BYTE *)v7;
        }
        else
        {
          if ( v14 )
          {
            ++v7;
            ++*(_DWORD *)v5;
          }
        }
        ++*(_DWORD *)v5;
      }
      ++v7;
    }
    if ( v6 )
      *(_BYTE *)v6++ = 0;
    ++*(_DWORD *)v5;
  }
  if ( a2 )
    *(_DWORD *)a2 = 0;
  result = a4;
  ++*(_DWORD *)result;
  return result;
}

//----- (1004885B) --------------------------------------------------------
signed int __usercall sub_1004885B<eax>(int a1<ecx>, int a2<ebx>)
{
  int v2; // edi@3
  int v3; // esi@3
  int v5; // eax@7
  int v6; // ST14_4@7
  void *v7; // edi@9
  void *v8; // esi@10
  int v9; // eax@11
  int v10; // eax@12
  int v11; // [sp-10h] [bp-10h]@11

  if ( !dword_100778D0 )
    sub_10041E6B(a2);
  v3 = (int)dword_10075614;
  v2 = 0;
  if ( !dword_10075614 )
    return -1;
  while ( *(_BYTE *)v3 )
  {
    if ( *(_BYTE *)v3 != 61 )
      ++v2;
    v5 = sub_10035530(v3);
    a1 = v6;
    v3 += v5 + 1;
  }
  v7 = sub_100374E6(a1, a2, v2 + 1, 4u);
  dword_1007586C = v7;
  if ( !v7 )
    return -1;
  v8 = dword_10075614;
  if ( !*(_BYTE *)dword_10075614 )
  {
LABEL_17:
    sub_100309C2(a2, v8);
    dword_10075614 = 0;
    *(_DWORD *)v7 = 0;
    dword_100778D4 = 1;
    return 0;
  }
  while ( 1 )
  {
    v9 = sub_10035530((int)v8);
    a2 = v9 + 1;
    if ( *(_BYTE *)v8 != 61 )
      break;
LABEL_15:
    v8 = (char *)v8 + a2;
    if ( !*(_BYTE *)v8 )
    {
      v8 = dword_10075614;
      goto LABEL_17;
    }
  }
  v10 = (int)sub_100374E6(v11, a2, v9 + 1, 1u);
  *(_DWORD *)v7 = v10;
  if ( v10 )
  {
    if ( sub_1003ADD5(a2, (int)v7, v10, a2, (int)v8) )
    {
      sub_1003A161(a2, (int)v7);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1004893C);
    }
    v7 = (char *)v7 + 4;
    goto LABEL_15;
  }
  sub_100309C2(a2, dword_1007586C);
  dword_1007586C = 0;
  return -1;
}
// 100778D0: using guessed type int dword_100778D0;
// 100778D4: using guessed type int dword_100778D4;

//----- (1004893C) --------------------------------------------------------
signed int __cdecl sub_1004893C()
{
  signed int result; // eax@3
  DWORD v1; // ecx@4
  LARGE_INTEGER PerformanceCount; // [sp+8h] [bp-14h]@4
  struct _FILETIME SystemTimeAsFileTime; // [sp+10h] [bp-Ch]@1
  DWORD v4; // [sp+18h] [bp-4h]@4

  SystemTimeAsFileTime.dwLowDateTime = 0;
  SystemTimeAsFileTime.dwHighDateTime = 0;
  if ( __security_cookie != -1153374642 && __security_cookie & 0xFFFF0000 )
  {
    result = ~__security_cookie;
    dword_10073204 = ~__security_cookie;
  }
  else
  {
    GetSystemTimeAsFileTime(&SystemTimeAsFileTime);
    v4 = SystemTimeAsFileTime.dwLowDateTime ^ SystemTimeAsFileTime.dwHighDateTime;
    v4 = GetCurrentThreadId() ^ SystemTimeAsFileTime.dwLowDateTime ^ SystemTimeAsFileTime.dwHighDateTime;
    v4 ^= GetCurrentProcessId();
    QueryPerformanceCounter(&PerformanceCount);
    result = (signed int)&v4;
    v1 = (unsigned int)&v4 ^ v4 ^ PerformanceCount.LowPart ^ PerformanceCount.HighPart;
    if ( v1 == -1153374642 )
    {
      v1 = -1153374641;
    }
    else
    {
      if ( !(v1 & 0xFFFF0000) )
      {
        result = (v1 | 0x4711) << 16;
        v1 |= result;
      }
    }
    __security_cookie = v1;
    dword_10073204 = ~v1;
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 10073204: using guessed type int dword_10073204;

//----- (100489D6) --------------------------------------------------------
int __usercall sub_100489D6<eax>(int a1<ebx>)
{
  int result; // eax@1
  const WCHAR *v2; // edi@1
  const WCHAR *i; // esi@2
  int v4; // eax@5
  int v5; // edx@5
  int v6; // ecx@5
  int v7; // esi@5
  int v8; // ebx@6
  int v9; // [sp+4h] [bp-4h]@5

  v2 = GetEnvironmentStringsW();
  result = 0;
  if ( v2 )
  {
    for ( i = v2; *i; ++i )
    {
      do
        ++i;
      while ( *i );
    }
    v7 = ((signed int)((char *)i - (char *)v2) >> 1) + 1;
    v4 = WideCharToMultiByte(0, 0, v2, v7, 0, 0, 0, 0);
    v9 = v4;
    if ( v4 && (v8 = sub_10037530(v5, v6, a1, v4)) != 0 )
    {
      if ( !WideCharToMultiByte(0, 0, v2, v7, (LPSTR)v8, v9, 0, 0) )
      {
        sub_100309C2(v8, (LPVOID)v8);
        v8 = 0;
      }
      FreeEnvironmentStringsW((LPWCH)v2);
      result = v8;
    }
    else
    {
      FreeEnvironmentStringsW((LPWCH)v2);
      result = 0;
    }
  }
  return result;
}

//----- (10048A61) --------------------------------------------------------
void __cdecl sub_10048A61()
{
  unsigned int i; // esi@1

  for ( i = (unsigned int)&unk_1006AA64; i < (unsigned int)&unk_1006AA64; i += 4 )
  {
    if ( *(_DWORD *)i )
      (*(void (**)(void))i)();
  }
}

//----- (10048A81) --------------------------------------------------------
void __cdecl sub_10048A81()
{
  unsigned int i; // esi@1

  for ( i = (unsigned int)&unk_1006AA6C; i < (unsigned int)&unk_1006AA6C; i += 4 )
  {
    if ( *(_DWORD *)i )
      (*(void (**)(void))i)();
  }
}

//----- (10048AB0) --------------------------------------------------------
void __userpurge sub_10048AB0(int a1<ebp>, int a2<edi>, int a3<esi>, int a4, int a5, int a6)
{
  void (__stdcall *v6)(_DWORD, _DWORD); // eax@1

  *(_DWORD *)(a1 - 4) = *(_DWORD *)(a1 + 12) + 12;
  sub_10052F1C();
  v6(a2, a3);
  sub_10052F1C();
}

//----- (10048AFC) --------------------------------------------------------
int __cdecl sub_10048AFC(int a1)
{
  return a1 != 0 ? 1 : 0;
}

//----- (10048B0B) --------------------------------------------------------
signed int __cdecl sub_10048B0B(LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int cchWideChar, int a4)
{
  signed int result; // eax@1
  LPWSTR v5; // edi@1
  int v6; // esi@1
  int v7; // eax@12
  unsigned __int8 *i; // eax@14
  int v9; // ecx@14
  int v10; // eax@16
  char v11; // zf@16
  int v12; // eax@20
  int v13; // [sp+8h] [bp-14h]@6
  int v14; // [sp+10h] [bp-Ch]@29
  char v15; // [sp+14h] [bp-8h]@28
  int v16; // [sp+18h] [bp-4h]@15
  int v17; // [sp+24h] [bp+8h]@19

  result = cchWideChar;
  v5 = lpWideCharStr;
  v6 = 0;
  if ( lpWideCharStr )
  {
    if ( !cchWideChar )
      return result;
    *lpWideCharStr = 0;
  }
  if ( !lpMultiByteStr )
  {
    *(_DWORD *)sub_10037649(0) = 22;
    sub_1003A151(0, (int)lpWideCharStr);
    return -1;
  }
  sub_100301AD((int)&v13, (int)lpMultiByteStr, (int)lpWideCharStr, a4);
  if ( !lpWideCharStr )
  {
    if ( !*(_DWORD *)(v13 + 168) )
    {
      v12 = sub_10035530((int)lpMultiByteStr);
LABEL_24:
      v6 = v12;
      goto LABEL_28;
    }
    v6 = -1;
    v7 = MultiByteToWideChar(*(_DWORD *)(v13 + 4), 9u, lpMultiByteStr, -1, 0, 0);
    if ( !v7 )
    {
      *(_DWORD *)sub_10037649((int)lpMultiByteStr) = 42;
      goto LABEL_28;
    }
LABEL_27:
    v6 = v7 - 1;
    goto LABEL_28;
  }
  if ( !*(_DWORD *)(v13 + 168) )
  {
    if ( (unsigned int)cchWideChar > 0 )
    {
      do
      {
        *v5 = (unsigned __int8)lpMultiByteStr[v6];
        if ( !lpMultiByteStr[v6] )
          break;
        ++v6;
        ++v5;
      }
      while ( v6 < (unsigned int)cchWideChar );
    }
    goto LABEL_28;
  }
  v6 = -1;
  v7 = MultiByteToWideChar(*(_DWORD *)(v13 + 4), 9u, lpMultiByteStr, -1, lpWideCharStr, cchWideChar);
  if ( v7 )
    goto LABEL_27;
  if ( GetLastError() == 122 )
  {
    v9 = cchWideChar;
    for ( i = (unsigned __int8 *)lpMultiByteStr; ; i = (unsigned __int8 *)(v10 + 1) )
    {
      v17 = (int)i;
      if ( !v9 )
        break;
      v16 = v9 - 1;
      if ( !*i )
        break;
      v11 = sub_1004261D((int)lpMultiByteStr, (int)v5, *i, (int)&v13) == 0;
      v10 = v17;
      if ( !v11 )
      {
        v10 = v17 + 1;
        if ( !*(_BYTE *)(v17 + 1) )
          goto LABEL_21;
      }
      v9 = v16;
    }
    v12 = MultiByteToWideChar(
            *(_DWORD *)(v13 + 4),
            1u,
            lpMultiByteStr,
            i - (unsigned __int8 *)lpMultiByteStr,
            v5,
            cchWideChar);
    if ( v12 )
      goto LABEL_24;
  }
LABEL_21:
  *(_DWORD *)sub_10037649((int)lpMultiByteStr) = 42;
  *v5 = 0;
LABEL_28:
  if ( v15 )
    *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
  return v6;
}

//----- (10048C6A) --------------------------------------------------------
signed int __cdecl sub_10048C6A(int a1, LPWSTR lpWideCharStr, int cchWideChar, LPCSTR lpMultiByteStr, int a5, int a6)
{
  signed int v6; // esi@1
  int v7; // eax@9
  int v8; // eax@12
  int v9; // eax@13
  int v10; // eax@17
  signed int v12; // [sp-4h] [bp-20h]@12
  int v13; // [sp+Ch] [bp-10h]@9
  int v14; // [sp+14h] [bp-8h]@27
  char v15; // [sp+18h] [bp-4h]@26

  v6 = 0;
  if ( lpWideCharStr )
  {
    if ( !cchWideChar )
    {
LABEL_5:
      v6 = 22;
      *(_DWORD *)sub_10037649(cchWideChar) = 22;
      sub_1003A151(cchWideChar, (int)lpWideCharStr);
      return v6;
    }
    *lpWideCharStr = 0;
  }
  else
  {
    if ( cchWideChar )
      goto LABEL_5;
  }
  if ( a1 )
    *(_DWORD *)a1 = 0;
  sub_100301AD((int)&v13, cchWideChar, (int)lpWideCharStr, a6);
  v7 = cchWideChar;
  if ( a5 <= (unsigned int)cchWideChar )
    v7 = a5;
  if ( (unsigned int)v7 <= 0x7FFFFFFF )
  {
    v9 = sub_10048B0B(lpWideCharStr, lpMultiByteStr, v7, (int)&v13);
    if ( v9 == -1 )
    {
      if ( lpWideCharStr )
        *lpWideCharStr = 0;
      v6 = *(_DWORD *)sub_10037649(cchWideChar);
      goto LABEL_26;
    }
    v10 = v9 + 1;
    if ( lpWideCharStr )
    {
      if ( v10 > (unsigned int)cchWideChar )
      {
        if ( a5 != -1 )
        {
          *lpWideCharStr = 0;
          v8 = sub_10037649(cchWideChar);
          v12 = 34;
          goto LABEL_21;
        }
        v10 = cchWideChar;
        v6 = 80;
      }
      lpWideCharStr[v10 - 1] = 0;
    }
    if ( a1 )
      *(_DWORD *)a1 = v10;
    goto LABEL_26;
  }
  v8 = sub_10037649(cchWideChar);
  v12 = 22;
LABEL_21:
  v6 = v12;
  *(_DWORD *)v8 = v12;
  sub_1003A151(cchWideChar, (int)lpWideCharStr);
LABEL_26:
  if ( v15 )
    *(_DWORD *)(v14 + 112) &= 0xFFFFFFFDu;
  return v6;
}

//----- (10048D46) --------------------------------------------------------
int __cdecl sub_10048D46(int a1, LPWSTR lpWideCharStr, int cchWideChar, LPCSTR lpMultiByteStr, int a5)
{
  return sub_10048C6A(a1, lpWideCharStr, cchWideChar, lpMultiByteStr, a5, 0);
}

//----- (10048D64) --------------------------------------------------------
signed int __cdecl sub_10048D64(CHAR *a1, int lpWideCharStr, int cbMultiByte, int a4)
{
  int v4; // ebx@1
  LPCWSTR v5; // edi@1
  int v6; // esi@1
  int v8; // eax@6
  LPSTR v9; // ecx@6
  const WCHAR v10; // ax@10
  LPCWSTR v11; // eax@15
  int v12; // edx@15
  int v13; // eax@26
  int v14; // edi@26
  int v15; // eax@32
  int v16; // eax@33
  int v17; // edx@33
  int v18; // eax@38
  LPSTR v19; // ecx@39
  CHAR v20; // al@40
  const WCHAR v21; // ax@46
  int v22; // eax@50
  int v23; // [sp+Ch] [bp-2Ch]@6
  int v24; // [sp+14h] [bp-24h]@55
  char v25; // [sp+18h] [bp-20h]@54
  int v26; // [sp+1Ch] [bp-1Ch]@38
  LPSTR lpMultiByteStr; // [sp+20h] [bp-18h]@1
  LPCWSTR v28; // [sp+24h] [bp-14h]@1
  BOOL UsedDefaultChar; // [sp+28h] [bp-10h]@1
  CHAR MultiByteStr[8]; // [sp+2Ch] [bp-Ch]@33
  unsigned int v31; // [sp+34h] [bp-4h]@1
  int v32; // [sp+38h] [bp+0h]@1

  v31 = (unsigned int)&v32 ^ __security_cookie;
  v4 = cbMultiByte;
  v5 = (LPCWSTR)lpWideCharStr;
  v6 = 0;
  lpMultiByteStr = a1;
  v28 = (LPCWSTR)lpWideCharStr;
  UsedDefaultChar = 0;
  if ( a1 && !cbMultiByte )
    return 0;
  if ( !lpWideCharStr )
  {
    *(_DWORD *)sub_10037649(cbMultiByte) = 22;
    sub_1003A151(cbMultiByte, 0);
    return -1;
  }
  sub_100301AD((int)&v23, cbMultiByte, lpWideCharStr, a4);
  v9 = lpMultiByteStr;
  v8 = v23;
  if ( !lpMultiByteStr )
  {
    if ( *(_DWORD *)(v23 + 168) )
    {
      v22 = WideCharToMultiByte(*(_DWORD *)(v23 + 4), 0, (LPCWSTR)lpWideCharStr, -1, 0, 0, 0, &UsedDefaultChar);
      if ( v22 && !UsedDefaultChar )
      {
        v14 = v22 - 1;
        goto LABEL_54;
      }
    }
    else
    {
      v21 = *(_WORD *)lpWideCharStr;
      if ( !*(_WORD *)lpWideCharStr )
        goto LABEL_49;
      while ( v21 <= 0xFFu )
      {
        ++v5;
        ++v6;
        v21 = *v5;
        if ( !*v5 )
          goto LABEL_49;
      }
    }
LABEL_53:
    *(_DWORD *)sub_10037649(cbMultiByte) = 42;
    v14 = -1;
    goto LABEL_54;
  }
  if ( !*(_DWORD *)(v23 + 168) )
  {
    if ( cbMultiByte )
    {
      while ( *v5 <= 0xFFu )
      {
        v9[v6] = *(_BYTE *)v5;
        v10 = *v5;
        ++v5;
        if ( v10 )
        {
          ++v6;
          if ( v6 < (unsigned int)cbMultiByte )
            continue;
        }
        goto LABEL_49;
      }
      goto LABEL_44;
    }
LABEL_49:
    v14 = v6;
    goto LABEL_54;
  }
  if ( *(_DWORD *)(v23 + 116) == 1 )
  {
    if ( cbMultiByte )
    {
      v11 = (LPCWSTR)lpWideCharStr;
      v12 = cbMultiByte;
      do
      {
        if ( !*v11 )
          break;
        ++v11;
        --v12;
      }
      while ( v12 );
      if ( v12 )
      {
        if ( !*v11 )
          v4 = ((signed int)((char *)v11 - lpWideCharStr) >> 1) + 1;
      }
      v8 = v23;
    }
    v6 = WideCharToMultiByte(
           *(_DWORD *)(v8 + 4),
           0,
           (LPCWSTR)lpWideCharStr,
           v4,
           lpMultiByteStr,
           v4,
           0,
           &UsedDefaultChar);
    if ( v6 && !UsedDefaultChar )
    {
      if ( !lpMultiByteStr[v6 - 1] )
        --v6;
      goto LABEL_49;
    }
    goto LABEL_44;
  }
  v13 = WideCharToMultiByte(
          *(_DWORD *)(v23 + 4),
          0,
          (LPCWSTR)lpWideCharStr,
          -1,
          lpMultiByteStr,
          cbMultiByte,
          0,
          &UsedDefaultChar);
  v14 = v13;
  if ( v13 )
  {
    if ( !UsedDefaultChar )
    {
      v6 = v13 - 1;
      goto LABEL_49;
    }
LABEL_44:
    *(_DWORD *)sub_10037649(v4) = 42;
    v6 = -1;
    goto LABEL_49;
  }
  if ( UsedDefaultChar || GetLastError() != 122 )
    goto LABEL_44;
  if ( cbMultiByte )
  {
    v15 = (int)v28;
    do
    {
      v16 = WideCharToMultiByte(
              *(_DWORD *)(v23 + 4),
              0,
              (LPCWSTR)v15,
              1,
              MultiByteStr,
              *(_DWORD *)(v23 + 116),
              0,
              &UsedDefaultChar);
      v17 = v16;
      if ( !v16 )
        goto LABEL_53;
      if ( UsedDefaultChar || v16 < 0 || (unsigned int)v16 > 5 )
        goto LABEL_53;
      if ( v16 + v14 > (unsigned int)cbMultiByte )
        break;
      v18 = 0;
      v26 = 0;
      if ( v17 > 0 )
      {
        v19 = lpMultiByteStr;
        do
        {
          v20 = MultiByteStr[v18];
          v19[v14] = v20;
          if ( !v20 )
            goto LABEL_54;
          v18 = v26 + 1;
          ++v14;
          v26 = v18;
        }
        while ( v18 < v17 );
      }
      v15 = (int)(v28 + 1);
      ++v28;
    }
    while ( v14 < (unsigned int)cbMultiByte );
  }
LABEL_54:
  if ( v25 )
    *(_DWORD *)(v24 + 112) &= 0xFFFFFFFDu;
  return v14;
}
// 10073200: using guessed type int __security_cookie;
// 10048D64: using guessed type CHAR MultiByteStr[8];

//----- (10048FC9) --------------------------------------------------------
signed int __usercall sub_10048FC9<eax>(int a1<ebx>, int a2, CHAR *a3, int cbMultiByte, int lpWideCharStr, int a6, int a7)
{
  int v7; // eax@7
  int v8; // eax@10
  signed int result; // eax@12
  signed int v10; // eax@13
  int v11; // eax@17
  signed int v12; // ecx@23
  signed int v13; // [sp-8h] [bp-14h]@10

  if ( a3 )
  {
    if ( cbMultiByte )
      goto LABEL_3;
LABEL_12:
    *(_DWORD *)sub_10037649(a1) = 22;
    sub_1003A151(a1, cbMultiByte);
    return 22;
  }
  if ( cbMultiByte )
    goto LABEL_12;
LABEL_3:
  if ( a3 )
    *a3 = 0;
  if ( a2 )
    *(_DWORD *)a2 = 0;
  v7 = cbMultiByte;
  if ( a6 <= (unsigned int)cbMultiByte )
    v7 = a6;
  if ( (unsigned int)v7 > 0x7FFFFFFF )
  {
    v8 = sub_10037649(a2);
    v13 = 22;
LABEL_22:
    *(_DWORD *)v8 = v13;
    sub_1003A151(a2, cbMultiByte);
    return v13;
  }
  v10 = sub_10048D64(a3, lpWideCharStr, v7, a7);
  if ( v10 == -1 )
  {
    if ( a3 )
      *a3 = 0;
    result = *(_DWORD *)sub_10037649(a2);
  }
  else
  {
    v11 = v10 + 1;
    if ( a3 )
    {
      if ( v11 <= (unsigned int)cbMultiByte )
      {
        v12 = 0;
      }
      else
      {
        if ( a6 != -1 )
        {
          *a3 = 0;
          if ( cbMultiByte <= (unsigned int)v11 )
          {
            v8 = sub_10037649(a2);
            v13 = 34;
            goto LABEL_22;
          }
        }
        v11 = cbMultiByte;
        v12 = 80;
      }
      a3[v11 - 1] = 0;
    }
    else
    {
      v12 = 0;
    }
    if ( a2 )
      *(_DWORD *)a2 = v11;
    result = v12;
  }
  return result;
}

//----- (10049092) --------------------------------------------------------
LPVOID __usercall sub_10049092<eax>(void *a1<ecx>, int a2<ebx>, unsigned int a3, unsigned int a4)
{
  LPVOID v4; // esi@1
  int v5; // eax@4
  int v7; // [sp+4h] [bp-4h]@1

  v7 = 0;
  v4 = sub_100492BF(a1, a2, a3, a4, (int)&v7);
  if ( !v4 )
  {
    if ( v7 )
    {
      if ( sub_10037649(a2) )
      {
        v5 = sub_10037649(a2);
        *(_DWORD *)v5 = v7;
      }
    }
  }
  return v4;
}

//----- (100490D0) --------------------------------------------------------
signed int __usercall sub_100490D0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, int a6, int a7)
{
  int v7; // edx@2
  int v8; // ecx@3
  int v9; // eax@5
  signed int result; // eax@6
  __int16 v11; // ax@8
  signed int v12; // [sp-4h] [bp-8h]@5

  if ( !a5 || (v7 = a6, !a6) )
    goto LABEL_5;
  v8 = a7;
  if ( !a7 )
  {
    *(_WORD *)a5 = 0;
LABEL_5:
    v9 = sub_10037649(a3);
    v12 = 22;
LABEL_6:
    *(_DWORD *)v9 = v12;
    sub_1003A151(a3, a4);
    return v12;
  }
  do
  {
    v11 = *(_WORD *)v8;
    *(_WORD *)(a5 - a7 + v8) = *(_WORD *)v8;
    v8 += 2;
    if ( !v11 )
      break;
    --v7;
  }
  while ( v7 );
  result = 0;
  if ( !v7 )
  {
    *(_WORD *)a5 = 0;
    v9 = sub_10037649(a3);
    v12 = 34;
    goto LABEL_6;
  }
  return result;
}

//----- (1004912C) --------------------------------------------------------
BOOL __cdecl sub_1004912C(int a1, DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, int a7)
{
  UINT v7; // ecx@1
  BOOL v8; // edi@1
  int v9; // eax@3
  int v10; // edx@3
  int v11; // ecx@3
  int v12; // ebx@3
  unsigned int v14; // eax@7
  char *v15; // esi@8
  int v16; // eax@10
  int v17; // esi@12
  int v18; // eax@15
  char v19; // [sp+0h] [bp-10h]@8
  unsigned int v20; // [sp+Ch] [bp-4h]@1
  int v21; // [sp+10h] [bp+0h]@1

  v20 = (unsigned int)&v21 ^ __security_cookie;
  v7 = CodePage;
  v8 = 0;
  if ( !CodePage )
  {
    CodePage = *(_DWORD *)(*(_DWORD *)a1 + 4);
    v7 = *(_DWORD *)(*(_DWORD *)a1 + 4);
  }
  v9 = MultiByteToWideChar(v7, 8 * (a7 != 0) + 1, lpMultiByteStr, cbMultiByte, 0, 0);
  v12 = v9;
  if ( !v9 )
    return 0;
  if ( v9 > 0 && (unsigned int)v9 <= 0x7FFFFFF0 )
  {
    v14 = 2 * v9 + 8;
    if ( v14 > 0x400 )
    {
      v16 = sub_10030930(v10, v11, v12, 0, 2 * v12 + 8);
      v15 = (char *)v16;
      if ( v16 )
      {
        *(_DWORD *)v16 = 56797;
        goto LABEL_12;
      }
    }
    else
    {
      sub_1003F580(v14, v11, v19);
      v15 = &v19;
      if ( &v19 )
      {
        *(_DWORD *)&v19 = 52428;
LABEL_12:
        v17 = (int)(v15 + 8);
        goto LABEL_14;
      }
    }
    return 0;
  }
  v17 = 0;
LABEL_14:
  if ( !v17 )
    return 0;
  sub_100391F0((void *)v17, 0, 2 * v12);
  v18 = MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, cbMultiByte, (LPWSTR)v17, v12);
  if ( v18 )
    v8 = GetStringTypeW(dwInfoType, (LPCWSTR)v17, v18, lpCharType);
  sub_1002CAA4(v12, v17);
  return v8;
}
// 10073200: using guessed type int __security_cookie;

//----- (10049218) --------------------------------------------------------
int __usercall sub_10049218<eax>(int a1<ebx>, int a2<edi>, int a3, DWORD dwInfoType, LPCSTR lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, int a9)
{
  int result; // eax@1
  int v10; // [sp+0h] [bp-10h]@1
  int v11; // [sp+8h] [bp-8h]@2
  char v12; // [sp+Ch] [bp-4h]@1

  sub_100301AD((int)&v10, a1, a2, a3);
  result = sub_1004912C((int)&v10, dwInfoType, lpMultiByteStr, cbMultiByte, lpCharType, CodePage, a9);
  if ( v12 )
    *(_DWORD *)(v11 + 112) &= 0xFFFFFFFDu;
  return result;
}

//----- (10049256) --------------------------------------------------------
int __usercall sub_10049256<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, const void *lpMem, unsigned int a5, unsigned int a6)
{
  int v6; // edi@1
  int result; // eax@3
  int v8; // esi@4
  SIZE_T v9; // eax@5
  int v10; // ST08_4@5
  int v11; // ebx@6

  v6 = 0;
  if ( a5 && (a1 = 0xFFFFFFE0 % a5, 0xFFFFFFE0 / a5 < a6) )
  {
    *(_DWORD *)sub_10037649(a3) = 12;
    result = 0;
  }
  else
  {
    v8 = a6 * a5;
    if ( lpMem )
    {
      v9 = sub_1003B20A((int)lpMem, 0, lpMem);
      a2 = v10;
      v6 = v9;
    }
    v11 = sub_10030C56(a1, a2, (int)lpMem, v6, (LPVOID)lpMem, v8);
    if ( v11 )
    {
      if ( v6 < (unsigned int)v8 )
        sub_100391F0((void *)(v6 + v11), 0, v8 - v6);
    }
    result = v11;
  }
  return result;
}

//----- (100492BF) --------------------------------------------------------
LPVOID __usercall sub_100492BF<eax>(void *this<ecx>, int ebx0<ebx>, unsigned int a2, unsigned int a3, int a4)
{
  int v5; // eax@3
  unsigned int v7; // esi@6
  LPVOID v8; // ecx@8

  if ( a2 && 0xFFFFFFE0 / a2 < a3 )
  {
    v5 = sub_10037649(ebx0);
  }
  else
  {
    v7 = a3 * a2;
    if ( !(a3 * a2) )
      v7 = 1;
    do
    {
      v8 = 0;
      if ( v7 <= 0xFFFFFFE0 )
      {
        v8 = HeapAlloc(hHeap, 8u, v7);
        if ( v8 )
          return v8;
      }
      if ( !dword_10075F2C )
      {
        if ( a4 )
          *(_DWORD *)a4 = 12;
        return v8;
      }
    }
    while ( sub_1003ADA2(v7) );
    v5 = a4;
    if ( !a4 )
      return 0;
  }
  *(_DWORD *)v5 = 12;
  return 0;
}
// 10075F2C: using guessed type int dword_10075F2C;

//----- (10049401) --------------------------------------------------------
PVOID __cdecl sub_10049401()
{
  return DecodePointer(dword_10076190);
}

//----- (1004940E) --------------------------------------------------------
int __cdecl sub_1004940E(int a1)
{
  int result; // eax@1

  result = a1;
  dword_10076188 = (PVOID)a1;
  dword_1007618C = a1;
  dword_10076190 = (PVOID)a1;
  dword_10076194 = a1;
  return result;
}
// 1007618C: using guessed type int dword_1007618C;
// 10076194: using guessed type int dword_10076194;

//----- (1004942A) --------------------------------------------------------
void __cdecl sub_1004942A(int a1)
{
  int v1; // ebx@1
  int v2; // edi@1
  int v3; // eax@7
  PVOID v4; // eax@9
  PVOID v5; // eax@10
  int v6; // edx@10
  int v7; // ecx@10
  unsigned int v8; // eax@10
  int v9; // ST08_4@10
  int v10; // edx@30
  int v11; // ecx@30
  int *v12; // [sp+28h] [bp-1Ch]@9

  v1 = 0;
  v2 = 0;
  if ( a1 > 11 )
  {
    if ( a1 == 15 )
    {
      v12 = &dword_10076194;
      v4 = (PVOID)dword_10076194;
      goto LABEL_18;
    }
    if ( a1 == 21 )
    {
      v12 = &dword_1007618C;
      v4 = (PVOID)dword_1007618C;
      goto LABEL_18;
    }
    if ( a1 != 22 )
      goto LABEL_14;
    goto LABEL_15;
  }
  if ( a1 != 11 )
  {
    if ( a1 == 2 )
    {
      v12 = (int *)&dword_10076188;
      v4 = dword_10076188;
LABEL_18:
      v1 = 1;
      v5 = DecodePointer(v4);
      goto LABEL_19;
    }
    if ( a1 != 4 )
    {
      if ( a1 != 6 )
      {
        if ( a1 == 8 )
          goto LABEL_7;
LABEL_14:
        *(_DWORD *)sub_10037649(0) = 22;
        sub_1003A151(0, 0);
        return;
      }
LABEL_15:
      v12 = (int *)&dword_10076190;
      v4 = dword_10076190;
      goto LABEL_18;
    }
  }
LABEL_7:
  v3 = sub_1004196A(0);
  v2 = v3;
  if ( !v3 )
    return;
  v8 = sub_100495DF(a1, *(_DWORD *)(v3 + 92));
  v7 = v9;
  v12 = (int *)(v8 + 8);
  v5 = *(PVOID *)(v8 + 8);
LABEL_19:
  if ( v5 == (PVOID)1 )
    return;
  if ( !v5 )
    sub_1003B03F(v6, v7, v1, v2, 3u);
  if ( v1 )
    sub_10036A23(v6, v7, v1, v2, 0);
  if ( a1 == 8 || a1 == 11 || a1 == 4 )
  {
    *(_DWORD *)(v2 + 96) = 0;
    if ( a1 != 8 )
      goto LABEL_33;
    *(_DWORD *)(v2 + 100) = 140;
  }
  if ( a1 == 8 )
  {
    v11 = dword_10064FE0;
    v10 = dword_10064FE0;
    while ( v10 < v11 + dword_10064FE4 )
    {
      *(_DWORD *)(12 * v10++ + *(_DWORD *)(v2 + 92) + 8) = 0;
      v11 = dword_10064FE0;
    }
    goto LABEL_34;
  }
LABEL_33:
  *v12 = (int)EncodePointer(0);
LABEL_34:
  if ( v1 )
    sub_10036B87(0);
}
// 10064FE0: using guessed type int dword_10064FE0;
// 10064FE4: using guessed type int dword_10064FE4;
// 1007618C: using guessed type int dword_1007618C;
// 10076194: using guessed type int dword_10076194;

//----- (100495DF) --------------------------------------------------------
unsigned int __cdecl sub_100495DF(int a1, unsigned int a2)
{
  unsigned int v2; // ecx@1
  unsigned int result; // eax@6

  v2 = a2;
  do
  {
    if ( *(_DWORD *)(v2 + 4) == a1 )
      break;
    v2 += 12;
  }
  while ( v2 < a2 + 12 * dword_10064FD8 );
  if ( v2 >= a2 + 12 * dword_10064FD8 || *(_DWORD *)(v2 + 4) != a1 )
    result = 0;
  else
    result = v2;
  return result;
}
// 10064FD8: using guessed type int dword_10064FD8;

//----- (1004961B) --------------------------------------------------------
signed int __cdecl sub_1004961B(double a1)
{
  int v1; // eax@2
  int v2; // eax@3
  signed int result; // eax@5
  int v4; // ecx@10
  signed int v5; // [sp+4h] [bp-4h]@6

  if ( (WORD3(a1) & 0x7FF0) == 32752 )
  {
    v1 = sub_100497B4(SLODWORD(a1), SHIDWORD(a1)) - 1;
    if ( v1 )
    {
      v2 = v1 - 1;
      if ( v2 )
      {
        if ( v2 != 1 )
          return 1;
        v5 = 2;
      }
      else
      {
        v5 = 4;
      }
      result = v5;
    }
    else
    {
      result = 512;
    }
  }
  else
  {
    v4 = WORD3(a1) & 0x8000;
    if ( !(WORD3(a1) & 0x7FF0) && (HIDWORD(a1) & 0xFFFFF || LODWORD(a1)) )
    {
      result = v4 != 0 ? 16 : 128;
    }
    else
    {
      if ( 0.0 == a1 )
        result = v4 != 0 ? 32 : 64;
      else
        result = v4 != 0 ? 8 : 256;
    }
  }
  return result;
}

//----- (100496B7) --------------------------------------------------------
#error "FFFFFFFF: variables would overlap: edx/4 and edx/8 (funcsize=79)"

//----- (10049789) --------------------------------------------------------
double __cdecl sub_10049789(double a1, __int16 a2)
{
  double v3; // ST00_8@1

  v3 = a1;
  WORD3(v3) = WORD3(a1) & 0x800F | 16 * (a2 + 1022);
  return v3;
}

//----- (100497B4) --------------------------------------------------------
signed int __cdecl sub_100497B4(int a1, int a2)
{
  if ( a2 == 2146435072 )
  {
    if ( !a1 )
      return 1;
  }
  else
  {
    if ( a2 == -1048576 && !a1 )
      return 2;
  }
  if ( (HIWORD(a2) & 0x7FF8) == 32760 )
    return 3;
  if ( (HIWORD(a2) & 0x7FF8) == 32752 && (a2 & 0x7FFFF || a1) )
    return 4;
  return 0;
}

//----- (10049810) --------------------------------------------------------
int __cdecl sub_10049810(char a1)
{
  if ( a1 & 0x20 )
    return 5;
  if ( a1 & 8 )
    return 1;
  if ( a1 & 4 )
    return 2;
  if ( a1 & 1 )
    return 3;
  return 2 * (a1 & 2);
}

//----- (10049842) --------------------------------------------------------
int __usercall sub_10049842<eax>(int a1<ebp>, int a2<edi>, signed int a3, int a4, int a5, int a6, double a7, int a8)
{
  double v8; // ST1C_8@1
  int v9; // eax@3
  __int16 v10; // cx@6
  int v12; // ST24_4@7
  char v13; // ST28_1@7
  char v14; // [sp+2Ch] [bp-8Ch]@2
  int v15; // [sp+6Ch] [bp-4Ch]@2
  unsigned int v16; // [sp+A8h] [bp-10h]@1
  int v17; // [sp+ACh] [bp-Ch]@1
  void *v18; // [sp+B0h] [bp-8h]@1
  char v19; // [sp+B4h] [bp-4h]@5
  int v20; // [sp+B8h] [bp+0h]@1

  v17 = a1;
  v18 = (void *)v20;
  v16 = (unsigned int)&v17 ^ __security_cookie;
  HIDWORD(v8) = a8;
  LODWORD(v8) = &a7;
  if ( !sub_1004990A(a3, v8) )
  {
    v15 &= 0xFFFFFFFEu;
    sub_10049B57((ULONG_PTR)&v14, (int)&a8, a3, a4, (int)&a5, (int)&a7, 0);
  }
  v9 = sub_10049810(a3);
  if ( dword_10074480 || !v9 )
  {
    sub_10049E3C((int)&v19, v9);
    sub_10049F8C(v10);
  }
  else
  {
    sub_10049E69((int)&v19, v9, a4, a5, a6, COERCE_UNSIGNED_INT64(0.0), COERCE_UNSIGNED_INT64(0.0) >> 32, a7);
  }
  return sub_1002A49B((int)&v19, a2, v12, (unsigned int)&v17 ^ v16, v13);
}
// 10049842: could not find valid save-restore pair for ebp
// 10073200: using guessed type int __security_cookie;
// 10074480: using guessed type int dword_10074480;

//----- (1004990A) --------------------------------------------------------
bool __cdecl sub_1004990A(signed int a1, double a2)
{
  char v2; // bl@1
  int v3; // esi@1
  int v4; // eax@9
  int v5; // ecx@13
  double v6; // st7@13
  signed int v7; // edi@27
  double v8; // st7@30
  double v9; // st7@31
  signed int v10; // edx@32
  unsigned int v11; // eax@35
  int v12; // ecx@35
  double v14; // [sp+18h] [bp-Ch]@30

  v2 = a1;
  v3 = a1 & 0x1F;
  if ( a1 & 8 && BYTE4(a2) & 1 )
  {
    sub_10049FB5();
    v3 &= 0xFFFFFFF7u;
    goto LABEL_49;
  }
  if ( a1 & 4 && BYTE4(a2) & 4 )
  {
    sub_10049FB5();
    v3 &= 0xFFFFFFFBu;
    goto LABEL_49;
  }
  if ( a1 & 1 && BYTE4(a2) & 8 )
  {
    sub_10049FB5();
    v4 = WORD2(a2) & 0xC00;
    if ( WORD2(a2) & 0xC00 )
    {
      if ( v4 != 1024 )
      {
        if ( v4 != 2048 )
        {
          if ( v4 != 3072 )
          {
LABEL_24:
            v3 &= 0xFFFFFFFEu;
            goto LABEL_49;
          }
          v5 = LODWORD(a2);
          v6 = dbl_100740B0;
          if ( *LODWORD(a2) <= 0.0 )
            goto LABEL_22;
LABEL_23:
          *(_QWORD *)v5 = *(_QWORD *)&v6;
          goto LABEL_24;
        }
        v5 = LODWORD(a2);
        if ( *LODWORD(a2) <= 0.0 )
        {
          v6 = dbl_100740B0;
LABEL_22:
          v6 = -v6;
          goto LABEL_23;
        }
LABEL_20:
        v6 = dbl_100740A0;
        goto LABEL_23;
      }
      v5 = LODWORD(a2);
      if ( *LODWORD(a2) > 0.0 )
      {
        v6 = dbl_100740B0;
        goto LABEL_23;
      }
    }
    else
    {
      v5 = LODWORD(a2);
      if ( *LODWORD(a2) > 0.0 )
        goto LABEL_20;
    }
    v6 = dbl_100740A0;
    goto LABEL_22;
  }
  if ( a1 & 2 )
  {
    if ( BYTE4(a2) & 0x10 )
    {
      v7 = 0;
      if ( a1 & 0x10 )
        v7 = 1;
      if ( 0.0 == *LODWORD(a2) )
      {
        v7 = 1;
      }
      else
      {
        v8 = *LODWORD(a2);
        sub_100496B7(v8, (int)&a1);
        v14 = v8;
        a1 -= 1536;
        if ( a1 >= -1074 )
        {
          v10 = 0;
          if ( v8 < 0.0 )
            v10 = 1;
          WORD3(v14) = BYTE6(v14) & 0xF | 0x10;
          if ( a1 < -1021 )
          {
            v12 = -1021 - a1;
            v11 = LODWORD(v14);
            do
            {
              if ( LOBYTE(v14) & 1 )
              {
                if ( !v7 )
                  v7 = 1;
              }
              v11 >>= 1;
              LODWORD(v14) = v11;
              if ( BYTE4(v14) & 1 )
              {
                v11 |= 0x80000000u;
                LODWORD(v14) = v11;
              }
              HIDWORD(v14) >>= 1;
              --v12;
            }
            while ( v12 );
          }
          v9 = v14;
          if ( v10 )
            v9 = -v14;
        }
        else
        {
          v9 = v8 * 0.0;
          v7 = 1;
        }
        *LODWORD(a2) = *(_QWORD *)&v9;
      }
      if ( v7 )
        sub_10049FB5();
      v3 &= 0xFFFFFFFDu;
    }
  }
LABEL_49:
  if ( v2 & 0x10 )
  {
    if ( BYTE4(a2) & 0x20 )
    {
      sub_10049FB5();
      v3 &= 0xFFFFFFEFu;
    }
  }
  return v3 == 0;
}
// 100740A0: using guessed type double dbl_100740A0;
// 100740B0: using guessed type double dbl_100740B0;

//----- (10049AE6) --------------------------------------------------------
double __usercall sub_10049AE6<st0>(__int16 a1<cx>, int a2<ebx>, int a3, double a4)
{
  double result; // st7@2

  if ( dword_10074480 )
  {
    *(_DWORD *)sub_10037649(a2) = 33;
    sub_10049F8C(a1);
    result = a4;
  }
  else
  {
    result = sub_10049E69(
               a2,
               1,
               a3,
               SLODWORD(a4),
               SHIDWORD(a4),
               COERCE_UNSIGNED_INT64(0.0),
               COERCE_UNSIGNED_INT64(0.0) >> 32,
               a4);
  }
  return result;
}
// 10074480: using guessed type int dword_10074480;

//----- (10049B36) --------------------------------------------------------
int __cdecl sub_10049B36(ULONG_PTR Arguments, int a2, char a3, int a4, int a5, int a6)
{
  return sub_10049B57(Arguments, a2, a3, a4, a5, a6, 0);
}

//----- (10049B57) --------------------------------------------------------
int __cdecl sub_10049B57(ULONG_PTR Arguments, int a2, char a3, int a4, int a5, int a6, int a7)
{
  char v7; // cl@1
  DWORD v8; // edi@2
  char v9; // al@12
  int v10; // esi@12
  ULONG_PTR v11; // ecx@12
  int v12; // eax@22
  int v13; // eax@27
  ULONG_PTR v14; // ecx@27
  int v15; // eax@31
  int v16; // eax@35
  ULONG_PTR v17; // ecx@35
  int v18; // ecx@38
  int v19; // ecx@38
  int v20; // ebx@39
  ULONG_PTR v21; // ecx@41
  int v22; // eax@51
  int v23; // eax@52
  int v24; // eax@53
  int v25; // eax@56
  int v26; // eax@60
  int v27; // eax@61
  int result; // eax@62

  *(_DWORD *)(Arguments + 4) = 0;
  *(_DWORD *)(Arguments + 8) = 0;
  *(_DWORD *)(Arguments + 12) = 0;
  v7 = a3;
  if ( a3 & 0x10 )
  {
    v8 = -1073741681;
    *(_DWORD *)(Arguments + 4) |= 1u;
  }
  else
  {
    v8 = Arguments;
  }
  if ( v7 & 2 )
  {
    v8 = -1073741677;
    *(_DWORD *)(Arguments + 4) |= 2u;
  }
  if ( v7 & 1 )
  {
    v8 = -1073741679;
    *(_DWORD *)(Arguments + 4) |= 4u;
  }
  if ( v7 & 4 )
  {
    v8 = -1073741682;
    *(_DWORD *)(Arguments + 4) |= 8u;
  }
  if ( v7 & 8 )
  {
    v8 = -1073741680;
    *(_DWORD *)(Arguments + 4) |= 0x10u;
  }
  v10 = a2;
  *(_DWORD *)(Arguments + 8) ^= (*(_DWORD *)(Arguments + 8) ^ ~(16 * *(_DWORD *)a2)) & 0x10;
  *(_DWORD *)(Arguments + 8) ^= (*(_DWORD *)(Arguments + 8) ^ ~(2 * *(_DWORD *)v10)) & 8;
  *(_DWORD *)(Arguments + 8) ^= (*(_DWORD *)(Arguments + 8) ^ ~(*(_DWORD *)v10 >> 1)) & 4;
  *(_DWORD *)(Arguments + 8) ^= (*(_DWORD *)(Arguments + 8) ^ ~(*(_DWORD *)v10 >> 3)) & 2;
  v11 = Arguments;
  *(_DWORD *)(v11 + 8) ^= (*(_DWORD *)(Arguments + 8) ^ ~(*(_DWORD *)v10 >> 5)) & 1;
  v9 = sub_1004A00B((int (*)(void))v11);
  if ( v9 & 1 )
    *(_DWORD *)(Arguments + 12) |= 0x10u;
  if ( v9 & 4 )
    *(_DWORD *)(Arguments + 12) |= 8u;
  if ( v9 & 8 )
    *(_DWORD *)(Arguments + 12) |= 4u;
  if ( v9 & 0x10 )
    *(_DWORD *)(Arguments + 12) |= 2u;
  if ( v9 & 0x20 )
    *(_DWORD *)(Arguments + 12) |= 1u;
  v12 = *(_DWORD *)v10 & 0xC00;
  if ( !(*(_DWORD *)v10 & 0xC00) )
  {
    *(_DWORD *)Arguments &= 0xFFFFFFFCu;
    goto LABEL_31;
  }
  if ( v12 == 1024 )
  {
    v14 = Arguments;
    v13 = *(_DWORD *)Arguments & 0xFFFFFFFD | 1;
    goto LABEL_28;
  }
  if ( v12 == 2048 )
  {
    v14 = Arguments;
    v13 = *(_DWORD *)Arguments & 0xFFFFFFFE | 2;
LABEL_28:
    *(_DWORD *)v14 = v13;
    goto LABEL_31;
  }
  if ( v12 == 3072 )
    *(_DWORD *)Arguments |= 3u;
LABEL_31:
  v15 = *(_DWORD *)v10 & 0x300;
  if ( !(*(_DWORD *)v10 & 0x300) )
  {
    v17 = Arguments;
    v16 = *(_DWORD *)Arguments & 0xFFFFFFEB | 8;
    goto LABEL_37;
  }
  if ( v15 == 512 )
  {
    v17 = Arguments;
    v16 = *(_DWORD *)Arguments & 0xFFFFFFE7 | 4;
LABEL_37:
    *(_DWORD *)v17 = v16;
    goto LABEL_38;
  }
  if ( v15 == 768 )
    *(_DWORD *)Arguments &= 0xFFFFFFE3u;
LABEL_38:
  v19 = *(_DWORD *)Arguments ^ 32 * a4;
  v18 = v19 & 0x1FFE0;
  *(_DWORD *)Arguments ^= v18;
  *(_DWORD *)(Arguments + 32) |= 1u;
  if ( a7 )
  {
    *(_DWORD *)(Arguments + 32) &= 0xFFFFFFE1u;
    *(float *)(Arguments + 16) = *(float *)a5;
    *(_DWORD *)(Arguments + 96) |= 1u;
    v20 = a6;
    *(_DWORD *)(Arguments + 96) &= 0xFFFFFFE1u;
    *(float *)(Arguments + 80) = *(float *)v20;
  }
  else
  {
    *(_DWORD *)(Arguments + 32) = *(_DWORD *)(Arguments + 32) & 0xFFFFFFE3 | 2;
    *(double *)(Arguments + 16) = *(double *)a5;
    *(_DWORD *)(Arguments + 96) |= 1u;
    v18 = Arguments;
    v20 = a6;
    *(_DWORD *)(Arguments + 96) = *(_DWORD *)(Arguments + 96) & 0xFFFFFFE3 | 2;
    *(double *)(Arguments + 80) = *(double *)v20;
  }
  sub_10049F7D((int (*)(void))v18);
  RaiseException(v8, 0, 1u, &Arguments);
  v21 = Arguments;
  if ( *(_BYTE *)(Arguments + 8) & 0x10 )
    *(_DWORD *)v10 &= 0xFFFFFFFEu;
  if ( *(_BYTE *)(v21 + 8) & 8 )
    *(_DWORD *)v10 &= 0xFFFFFFFBu;
  if ( *(_BYTE *)(v21 + 8) & 4 )
    *(_DWORD *)v10 &= 0xFFFFFFF7u;
  if ( *(_BYTE *)(v21 + 8) & 2 )
    *(_DWORD *)v10 &= 0xFFFFFFEFu;
  if ( *(_BYTE *)(v21 + 8) & 1 )
    *(_DWORD *)v10 &= 0xFFFFFFDFu;
  v22 = *(_DWORD *)v21 & 3;
  if ( !v22 )
  {
    *(_DWORD *)v10 &= 0xFFFFF3FFu;
    goto LABEL_60;
  }
  v23 = v22 - 1;
  if ( !v23 )
  {
    v25 = *(_DWORD *)v10 & 0xFFFFF7FF | 0x400;
    goto LABEL_57;
  }
  v24 = v23 - 1;
  if ( !v24 )
  {
    v25 = *(_DWORD *)v10 & 0xFFFFFBFF | 0x800;
LABEL_57:
    *(_DWORD *)v10 = v25;
    goto LABEL_60;
  }
  if ( v24 == 1 )
    *(_DWORD *)v10 |= 0xC00u;
LABEL_60:
  v26 = (*(_DWORD *)v21 >> 2) & 7;
  if ( !v26 )
  {
    result = *(_DWORD *)v10 & 0xFFFFF3FF | 0x300;
    goto LABEL_66;
  }
  v27 = v26 - 1;
  if ( !v27 )
  {
    result = *(_DWORD *)v10 & 0xFFFFF3FF | 0x200;
LABEL_66:
    *(_DWORD *)v10 = result;
    goto LABEL_67;
  }
  result = v27 - 1;
  if ( !result )
    *(_DWORD *)v10 &= 0xFFFFF3FFu;
LABEL_67:
  if ( a7 )
    *(float *)v20 = *(float *)(v21 + 80);
  else
    *(double *)v20 = *(double *)(v21 + 80);
  return result;
}

//----- (10049E3C) --------------------------------------------------------
int __usercall sub_10049E3C<eax>(int a1<ebx>, int a2)
{
  int result; // eax@2

  if ( a2 == 1 )
  {
    result = sub_10037649(a1);
    *(_DWORD *)result = 33;
  }
  else
  {
    result = a2 - 2;
    if ( (unsigned int)(a2 - 2) <= 1 )
    {
      result = sub_10037649(a1);
      *(_DWORD *)result = 34;
    }
  }
  return result;
}

//----- (10049E69) --------------------------------------------------------
double __usercall sub_10049E69<st0>(int a1<ebx>, int a2, int a3, int a4, int a5, int a6, int a7, double a8)
{
  signed int v8; // eax@1
  int v9; // ecx@1
  double result; // st7@9
  int v11; // [sp+0h] [bp-20h]@7
  int v12; // [sp+4h] [bp-1Ch]@6
  int v13; // [sp+8h] [bp-18h]@7
  int v14; // [sp+Ch] [bp-14h]@7
  int v15; // [sp+10h] [bp-10h]@7
  int v16; // [sp+14h] [bp-Ch]@7
  double v17; // [sp+18h] [bp-8h]@7

  v9 = 0;
  v8 = 0;
  while ( dword_100740C8[2 * v8] != a3 )
  {
    ++v8;
    if ( v8 >= 29 )
      goto LABEL_6;
  }
  v9 = (int)*(&off_100740CC + 2 * v8);
LABEL_6:
  v12 = v9;
  if ( v9 )
  {
    v13 = a4;
    v14 = a5;
    v15 = a6;
    v16 = a7;
    v17 = a8;
    v11 = a2;
    sub_10049F8C(v9);
    if ( !sub_1004EAE4() )
      sub_10049E3C(a1, a2);
    result = v17;
  }
  else
  {
    sub_10049F8C(0);
    sub_10049E3C(a1, a2);
    result = a8;
  }
  return result;
}
// 100740C8: using guessed type int dword_100740C8[];
// 100740CC: using guessed type void *off_100740CC;

//----- (10049F07) --------------------------------------------------------
int __cdecl sub_10049F07(int a1)
{
  int result; // eax@2
  int v2; // [sp+30h] [bp+8h]@5

  if ( dword_1007577C >= 1 )
  {
    result = a1;
    if ( a1 & 0x40 && dword_100741C8 )
    {
      __asm { ldmxcsr [ebp+arg_0] }
    }
    else
    {
      result = a1 & 0xFFFFFFBF;
      v2 = a1 & 0xFFFFFFBF;
      __asm { ldmxcsr [ebp+arg_0] }
    }
  }
  return result;
}
// 100741C8: using guessed type int dword_100741C8;
// 1007577C: using guessed type int dword_1007577C;

//----- (10049F7D) --------------------------------------------------------
int __thiscall sub_10049F7D(int (*this)(void))
{
  __asm { fnclex }
  return this();
}

//----- (10049F8C) --------------------------------------------------------
int __fastcall sub_10049F8C(__int16 a1)
{
  return a1;
}

//----- (10049FB5) --------------------------------------------------------
void __cdecl sub_10049FB5()
{
  ;
}

//----- (1004A00B) --------------------------------------------------------
int __thiscall sub_1004A00B(int (*this)(void))
{
  return this();
}

//----- (1004A019) --------------------------------------------------------
signed int __usercall sub_1004A019<eax>(int a1<edi>, int a2, int a3, unsigned int a4, int a5, int a6, int a7)
{
  return sub_1004A03A(a1, a2, a3, a4, a5, a6, a7, 0);
}

//----- (1004A03A) --------------------------------------------------------
signed int __usercall sub_1004A03A<eax>(int a1<edi>, int a2, int a3, unsigned int a4, int a5, int a6, int a7, int a8)
{
  signed int result; // eax@4

  switch ( a5 )
  {
    case 101:
    case 69:
      result = sub_1004A587(a2, a3, a4, a6, a7, a8);
      break;
    case 102:
      result = sub_1004A73D(a2, a3, a4, a6, a8);
      break;
    case 97:
    case 65:
      result = sub_1004A0C0(a1, a2, a3, a4, a6, a7, a8);
      break;
    default:
      result = sub_1004A7FC(a2, a3, a4, a6, a7, a8);
      break;
  }
  return result;
}

//----- (1004A0C0) --------------------------------------------------------
signed int __usercall sub_1004A0C0<eax>(int a1<edi>, int a2, int a3, unsigned int a4, int a5, int a6, int a7)
{
  int v7; // edi@1
  int v8; // esi@3
  int v9; // eax@5
  signed int v10; // edi@8
  int v11; // edx@9
  unsigned int v12; // ebx@9
  unsigned int v13; // eax@10
  void *v14; // ecx@12
  int v15; // eax@16
  char v16; // zf@21
  int v17; // esi@22
  int v18; // eax@22
  int v19; // ecx@26
  int v20; // esi@26
  int v21; // eax@29
  int v22; // eax@31
  signed int v23; // ecx@31
  unsigned int v24; // eax@33
  unsigned __int64 v25; // qax@33
  unsigned __int64 v26; // qt0@35
  unsigned __int64 v27; // qax@37
  int i; // eax@38
  signed int v29; // eax@51
  unsigned __int64 v30; // qcx@51
  unsigned int v31; // ecx@51
  unsigned __int8 v32; // cf@51
  int v33; // esi@52
  int v34; // edi@54
  int v35; // edx@57
  __int64 v36; // ST0C_8@61
  int v37; // edx@61
  __int64 v38; // ST0C_8@66
  int v40; // [sp-4h] [bp-3Ch]@5
  int v41; // [sp+Ch] [bp-2Ch]@1
  int v42; // [sp+14h] [bp-24h]@69
  char v43; // [sp+18h] [bp-20h]@68
  int v44; // [sp+20h] [bp-18h]@29
  int v45; // [sp+24h] [bp-14h]@9
  int v46; // [sp+28h] [bp-10h]@21
  int v47; // [sp+2Ch] [bp-Ch]@26
  unsigned int v48; // [sp+30h] [bp-8h]@1
  int v49; // [sp+34h] [bp-4h]@1
  unsigned int v50; // [sp+44h] [bp+Ch]@31
  int v51; // [sp+4Ch] [bp+14h]@31

  v49 = 48;
  v48 = 1023;
  sub_100301AD((int)&v41, 0, a1, a7);
  v7 = a5;
  if ( a5 < 0 )
    v7 = 0;
  v8 = a3;
  if ( !a3 || !a4 )
  {
    v9 = sub_10037649(0);
    v40 = 22;
LABEL_8:
    v10 = v40;
    *(_DWORD *)v9 = v40;
    sub_1003A151(0, v40);
    goto LABEL_68;
  }
  *(_BYTE *)a3 = 0;
  if ( a4 <= v7 + 11 )
  {
    v9 = sub_10037649(0);
    v40 = 34;
    goto LABEL_8;
  }
  v11 = a2;
  v12 = *(_DWORD *)(a2 + 4);
  v45 = *(_DWORD *)a2;
  if ( ((v12 >> 20) & 0x7FF) == 2047 )
  {
    v13 = -1;
    if ( a4 != -1 )
      v13 = a4 - 2;
    v10 = sub_1004A41A(a2, a3 + 2, v13, v7, 0);
    if ( v10 )
    {
      *(_BYTE *)a3 = 0;
    }
    else
    {
      if ( *(_BYTE *)(a3 + 2) == 45 )
      {
        *(_BYTE *)a3 = 45;
        v8 = a3 + 1;
      }
      *(_BYTE *)v8 = 48;
      *(_BYTE *)(v8 + 1) = (((a6 == 0) - 1) & 0xE0) + 120;
      v15 = sub_10052F50(v14, v8 + 2, 0x65u);
      if ( v15 )
      {
        *(_BYTE *)v15 = (((a6 == 0) - 1) & 0xE0) + 112;
        *(_BYTE *)(v15 + 3) = 0;
      }
      v10 = 0;
    }
  }
  else
  {
    if ( v12 & 0x80000000 )
    {
      *(_BYTE *)a3 = 45;
      v8 = a3 + 1;
    }
    *(_BYTE *)v8 = 48;
    *(_BYTE *)(v8 + 1) = (((a6 == 0) - 1) & 0xE0) + 120;
    v16 = (*(_DWORD *)(a2 + 4) & 0x7FF00000) == 0;
    v46 = a6 != 0 ? 7 : 39;
    if ( v16 )
    {
      *(_BYTE *)(v8 + 2) = 48;
      v18 = *(_DWORD *)(a2 + 4);
      v17 = v8 + 3;
      if ( v18 & 0xFFFFF | *(_DWORD *)a2 )
        v48 = 1022;
      else
        v48 = 0;
    }
    else
    {
      *(_BYTE *)(v8 + 2) = 49;
      v17 = v8 + 3;
    }
    v19 = v17;
    v20 = v17 + 1;
    v47 = v19;
    if ( v7 )
      *(_BYTE *)v19 = ***(_BYTE ***)(v41 + 132);
    else
      *(_BYTE *)v19 = 0;
    v21 = *(_DWORD *)(a2 + 4);
    v44 = v21 & 0xFFFFF;
    if ( v21 & 0xFFFFF || *(_DWORD *)a2 )
    {
      v51 = 0;
      LOWORD(v22) = v49;
      v23 = 983040;
      v50 = 983040;
      do
      {
        if ( v7 <= 0 )
          break;
        LODWORD(v25) = v51 & *(_DWORD *)v11;
        HIDWORD(v25) = v23 & *(_DWORD *)(v11 + 4);
        HIDWORD(v25) &= 0xFFFFFu;
        v24 = (unsigned __int16)(sub_10053490(v25, v49) + 48);
        if ( v24 > 0x39 )
          v24 += a6 != 0 ? 7 : 39;
        v11 = a2;
        *(_BYTE *)v20 = v24;
        LODWORD(v26) = v51;
        HIDWORD(v26) = v50;
        v51 = v26 >> 4;
        v23 = v50 >> 4;
        v22 = v49 - 4;
        ++v20;
        --v7;
        v50 >>= 4;
        v49 = v22;
      }
      while ( (_WORD)v22 >= 0 );
      if ( (_WORD)v22 >= 0 )
      {
        LODWORD(v27) = v51 & *(_DWORD *)v11;
        HIDWORD(v27) = v23 & *(_DWORD *)(v11 + 4);
        HIDWORD(v27) &= 0xFFFFFu;
        if ( (unsigned __int16)sub_10053490(v27, v49) > 8u )
        {
          for ( i = v20 - 1; *(_BYTE *)i == 102 || *(_BYTE *)i == 70; --i )
            *(_BYTE *)i = 48;
          if ( i == v47 )
          {
            ++*(_BYTE *)(i - 1);
          }
          else
          {
            if ( *(_BYTE *)i == 57 )
              *(_BYTE *)i = v46 + 58;
            else
              ++*(_BYTE *)i;
          }
        }
      }
    }
    if ( v7 > 0 )
    {
      sub_100391F0((void *)v20, 0x30u, v7);
      v20 += v7;
    }
    if ( !*(_BYTE *)v47 )
      v20 = v47;
    *(_BYTE *)v20 = (((a6 == 0) - 1) & 0xE0) + 112;
    LOWORD(v31) = sub_10053490(*(_QWORD *)a2, 0x34u);
    v29 = 0;
    v31 &= 0x7FFu;
    v32 = v31 < v48;
    LODWORD(v30) = v31 - v48;
    HIDWORD(v30) = -v32;
    if ( (signed int)v32 > 0 )
    {
      *(_BYTE *)(v20 + 1) = 45;
      v33 = v20 + 2;
      v30 = -v30;
    }
    else
    {
      *(_BYTE *)(v20 + 1) = 43;
      v33 = v20 + 2;
    }
    v34 = v33;
    *(_BYTE *)v33 = 48;
    if ( HIDWORD(v30) >= 0 )
    {
      if ( (HIDWORD(v30) > 0 || (_DWORD)v30 >= 0x3E8u)
        && (*(_BYTE *)v33 = sub_100533B0(v30, 1000i64) + 48, ++v33, v29 = 0, v44 = v35, v33 != v34)
        || HIDWORD(v30) >= v29 && (HIDWORD(v30) > v29 || (_DWORD)v30 >= 0x64u) )
      {
        HIDWORD(v36) = v29;
        LODWORD(v36) = 100;
        *(_BYTE *)v33++ = sub_100533B0(v30, v36) + 48;
        v44 = v37;
        v29 = 0;
      }
    }
    if ( v33 != v34 || HIDWORD(v30) >= v29 && (HIDWORD(v30) > v29 || (_DWORD)v30 >= 0xAu) )
    {
      HIDWORD(v38) = v29;
      LODWORD(v38) = 10;
      *(_BYTE *)v33++ = sub_100533B0(v30, v38) + 48;
      v44 = HIDWORD(v30);
      v29 = 0;
    }
    *(_BYTE *)v33 = v30 + 48;
    *(_BYTE *)(v33 + 1) = v29;
    v10 = v29;
  }
LABEL_68:
  if ( v43 )
    *(_DWORD *)(v42 + 112) &= 0xFFFFFFFDu;
  return v10;
}

//----- (1004A41A) --------------------------------------------------------
signed int __cdecl sub_1004A41A(int a1, int a2, unsigned int a3, int a4, int a5)
{
  return sub_1004A587(a1, a2, a3, a4, a5, 0);
}

//----- (1004A438) --------------------------------------------------------
int __usercall sub_1004A438<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned int a4, int a5, int a6, int a7, char a8, int a9)
{
  int v9; // eax@3
  int v10; // eax@4
  int v11; // edx@4
  int v12; // edi@4
  int v13; // esi@11
  int v14; // eax@15
  int v15; // esi@15
  int v16; // edx@21
  signed __int64 v17; // qax@24
  signed __int64 v18; // qtt@24
  signed __int64 v19; // qax@26
  signed __int64 v20; // qtt@26
  int v22; // [sp-4h] [bp-1Ch]@3
  int v23; // [sp+8h] [bp-10h]@1
  int v24; // [sp+10h] [bp-8h]@32
  char v25; // [sp+14h] [bp-4h]@31

  sub_100301AD((int)&v23, a1, a2, a9);
  if ( !a3 || !a4 )
  {
    v9 = sub_10037649(a3);
    v22 = 22;
LABEL_8:
    v12 = v22;
    *(_DWORD *)v9 = v22;
    sub_1003A151(a3, v22);
    goto LABEL_31;
  }
  v11 = a5;
  v12 = 0;
  v10 = a5;
  if ( a5 <= 0 )
    v10 = 0;
  if ( a4 <= v10 + 9 )
  {
    v9 = sub_10037649(a3);
    v22 = 34;
    goto LABEL_8;
  }
  if ( a8 )
  {
    sub_1004AA7D(a3 + (*(_DWORD *)a7 == 45), a5 > 0);
    v11 = a5;
  }
  v13 = a3;
  if ( *(_DWORD *)a7 == 45 )
  {
    *(_BYTE *)a3 = 45;
    v13 = a3 + 1;
  }
  if ( v11 > 0 )
  {
    *(_BYTE *)v13 = *(_BYTE *)(v13 + 1);
    ++v13;
    *(_BYTE *)v13 = ***(_BYTE ***)(v23 + 132);
  }
  v15 = v11 + (a8 == 0) + v13;
  v14 = -1;
  if ( a4 != -1 )
    v14 = a4 + a3 - v15;
  if ( sub_1003ADD5(a3, 0, v15, v14, (int)"e+000") )
  {
    sub_1003A161(a3, 0);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1004A587);
  }
  if ( a6 )
    *(_BYTE *)v15 = 69;
  if ( **(_BYTE **)(a7 + 12) != 48 )
  {
    v16 = *(_DWORD *)(a7 + 4) - 1;
    if ( v16 < 0 )
    {
      v16 = -v16;
      *(_BYTE *)(v15 + 1) = 45;
    }
    if ( v16 >= 100 )
    {
      v17 = v16;
      v18 = v17;
      LODWORD(v17) = v17 / 100;
      v16 = v18 % 100;
      *(_BYTE *)(v15 + 2) += v17;
    }
    if ( v16 >= 10 )
    {
      v19 = v16;
      v20 = v19;
      LODWORD(v19) = v19 / 10;
      v16 = v20 % 10;
      *(_BYTE *)(v15 + 3) += v19;
    }
    *(_BYTE *)(v15 + 4) += v16;
  }
  if ( byte_10076230 & 1 )
  {
    if ( *(_BYTE *)(v15 + 2) == 48 )
      sub_1002A4B0((void *)(v15 + 2), (const void *)(v15 + 3), 3u);
  }
LABEL_31:
  if ( v25 )
    *(_DWORD *)(v24 + 112) &= 0xFFFFFFFDu;
  return v12;
}
// 10076230: using guessed type char byte_10076230;

//----- (1004A587) --------------------------------------------------------
signed int __cdecl sub_1004A587(int a1, int a2, unsigned int a3, int a4, int a5, int a6)
{
  signed int v6; // esi@1
  int v7; // eax@2
  signed int result; // eax@3
  unsigned int v9; // ecx@6
  int v10; // [sp+Ch] [bp-2Ch]@1
  char v11; // [sp+1Ch] [bp-1Ch]@1
  unsigned int v12; // [sp+34h] [bp-4h]@1
  int v13; // [sp+38h] [bp+0h]@1

  v12 = (unsigned int)&v13 ^ __security_cookie;
  v6 = 22;
  loc_10053315(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), &v10, &v11, 22);
  if ( !a2 )
  {
    v7 = sub_10037649(a4);
LABEL_3:
    *(_DWORD *)v7 = v6;
    sub_1003A151(a4, a2);
    return v6;
  }
  if ( !a3 )
  {
    v7 = sub_10037649(a4);
    v6 = 22;
    goto LABEL_3;
  }
  v9 = -1;
  if ( a3 != -1 )
    v9 = a3 - (v10 == 45) - (a4 > 0);
  result = sub_10053087(a4, a2 + (v10 == 45) + (a4 > 0), v9, a4 + 1, (int)&v10);
  if ( result )
    *(_BYTE *)a2 = 0;
  else
    result = sub_1004A438(a4, a2, a2, a3, a4, a5, (int)&v10, 0, a6);
  return result;
}
// 10073200: using guessed type int __security_cookie;

//----- (1004A653) --------------------------------------------------------
signed int __usercall sub_1004A653<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6, char a7, int a8)
{
  int v8; // esi@1
  int v9; // eax@3
  signed int v10; // ebx@3
  int v11; // edi@4
  int v12; // eax@9
  int v13; // esi@10
  int v14; // eax@13
  int v15; // esi@13
  int v16; // eax@16
  int v18; // [sp+8h] [bp-14h]@1
  int v19; // [sp+10h] [bp-Ch]@20
  char v20; // [sp+14h] [bp-8h]@19
  int v21; // [sp+18h] [bp-4h]@1

  v21 = *(_DWORD *)(a6 + 4) - 1;
  sub_100301AD((int)&v18, a1, a2, a8);
  v8 = a3;
  if ( a3 && a4 )
  {
    v10 = 0;
    v11 = a5;
    if ( a7 )
    {
      if ( v21 == a5 )
        *(_WORD *)(v21 + (*(_DWORD *)a6 == 45) + a3) = 48;
    }
    if ( *(_DWORD *)a6 == 45 )
    {
      *(_BYTE *)a3 = 45;
      v8 = a3 + 1;
    }
    v12 = *(_DWORD *)(a6 + 4);
    if ( v12 > 0 )
    {
      v13 = v12 + v8;
    }
    else
    {
      sub_1004AA7D(v8, 1);
      *(_BYTE *)v8 = 48;
      v13 = v8 + 1;
    }
    if ( a5 > 0 )
    {
      sub_1004AA7D(v13, 1);
      *(_BYTE *)v13 = ***(_BYTE ***)(v18 + 132);
      v15 = v13 + 1;
      v14 = *(_DWORD *)(a6 + 4);
      if ( v14 < 0 )
      {
        if ( a7 )
        {
          v11 = -v14;
        }
        else
        {
          v16 = -v14;
          if ( a5 >= v16 )
            v11 = v16;
        }
        sub_1004AA7D(v15, v11);
        sub_100391F0((void *)v15, 0x30u, v11);
      }
    }
  }
  else
  {
    v9 = sub_10037649(a1);
    v10 = 22;
    *(_DWORD *)v9 = 22;
    sub_1003A151(22, a2);
  }
  if ( v20 )
    *(_DWORD *)(v19 + 112) &= 0xFFFFFFFDu;
  return v10;
}

//----- (1004A73D) --------------------------------------------------------
signed int __cdecl sub_1004A73D(int a1, int a2, int a3, int a4, int a5)
{
  signed int result; // eax@2
  unsigned int v6; // ecx@5
  int v7; // [sp+8h] [bp-2Ch]@1
  int v8; // [sp+Ch] [bp-28h]@7
  char v9; // [sp+18h] [bp-1Ch]@1
  unsigned int v10; // [sp+30h] [bp-4h]@1
  int v11; // [sp+34h] [bp+0h]@1

  v10 = (unsigned int)&v11 ^ __security_cookie;
  loc_10053315(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), &v7, &v9, 22);
  if ( a2 )
  {
    if ( a3 )
    {
      v6 = -1;
      if ( a3 != -1 )
        v6 = a3 - (v7 == 45);
      result = sub_10053087(a4, a2 + (v7 == 45), v6, a4 + v8, (int)&v7);
      if ( result )
        *(_BYTE *)a2 = 0;
      else
        result = sub_1004A653(a4, a2, a2, a3, a4, (int)&v7, 0, a5);
    }
    else
    {
      *(_DWORD *)sub_10037649(22) = 22;
      sub_1003A151(22, a2);
      result = 22;
    }
  }
  else
  {
    *(_DWORD *)sub_10037649(22) = 22;
    sub_1003A151(22, 0);
    result = 22;
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;

//----- (1004A7FC) --------------------------------------------------------
signed int __cdecl sub_1004A7FC(int a1, int a2, unsigned int a3, int a4, int a5, int a6)
{
  signed int result; // eax@2
  unsigned int v7; // eax@5
  bool v8; // ecx@5
  int v9; // ebx@5
  char v10; // al@12
  int v11; // [sp+8h] [bp-30h]@1
  int v12; // [sp+Ch] [bp-2Ch]@5
  int v13; // [sp+18h] [bp-20h]@5
  char v14; // [sp+1Ch] [bp-1Ch]@1
  unsigned int v15; // [sp+34h] [bp-4h]@1
  int v16; // [sp+38h] [bp+0h]@1

  v15 = (unsigned int)&v16 ^ __security_cookie;
  loc_10053315(*(_DWORD *)a1, *(_DWORD *)(a1 + 4), &v11, &v14, 22);
  if ( a2 )
  {
    if ( a3 )
    {
      v13 = v12 - 1;
      v8 = v11 == 45;
      v7 = -1;
      v9 = v8 + a2;
      if ( a3 != -1 )
        v7 = a3 - v8;
      result = sub_10053087(v9, v9, v7, a4, (int)&v11);
      if ( result )
      {
        *(_BYTE *)a2 = 0;
      }
      else
      {
        if ( v12 - 1 < -4 || v12 - 1 >= a4 )
        {
          result = sub_1004A438(v9, a2, a2, a3, a4, a5, (int)&v11, 1, a6);
        }
        else
        {
          if ( v13 < v12 - 1 )
          {
            do
              v10 = *(_BYTE *)v9++;
            while ( v10 );
            *(_BYTE *)(v9 - 2) = 0;
          }
          result = sub_1004A653(v9, a2, a2, a3, a4, (int)&v11, 1, a6);
        }
      }
    }
    else
    {
      *(_DWORD *)sub_10037649(22) = 22;
      sub_1003A151(22, a2);
      result = 22;
    }
  }
  else
  {
    *(_DWORD *)sub_10037649(22) = 22;
    sub_1003A151(22, 0);
    result = 22;
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;

//----- (1004A8F9) --------------------------------------------------------
char __usercall sub_1004A8F9<al>(int a1<ebx>, int a2<edi>, int a3)
{
  return sub_1004A90A(a1, a2, a3, 0);
}

//----- (1004A90A) --------------------------------------------------------
char __usercall sub_1004A90A<al>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  int v4; // edx@1
  char i; // cl@1
  int v6; // eax@4
  int v7; // edx@4
  char v8; // al@9
  int v9; // esi@10
  int v11; // [sp+4h] [bp-10h]@1
  int v12; // [sp+Ch] [bp-8h]@16
  char v13; // [sp+10h] [bp-4h]@15

  sub_100301AD((int)&v11, a1, a2, a4);
  v4 = a3;
  for ( i = *(_BYTE *)a3; *(_BYTE *)v4; i = *(_BYTE *)v4 )
  {
    if ( i == ***(_BYTE ***)(v11 + 132) )
      break;
    ++v4;
  }
  LOBYTE(v6) = *(_BYTE *)v4;
  v7 = v4 + 1;
  if ( (_BYTE)v6 )
  {
    while ( 1 )
    {
      v8 = *(_BYTE *)v7;
      if ( !*(_BYTE *)v7 )
        break;
      if ( v8 == 101 || v8 == 69 )
        break;
      ++v7;
    }
    v9 = v7;
    do
      --v7;
    while ( *(_BYTE *)v7 == 48 );
    if ( *(_BYTE *)v7 == ***(_BYTE ***)(v11 + 132) )
      --v7;
    do
    {
      LOBYTE(v6) = *(_BYTE *)v9;
      ++v7;
      ++v9;
      *(_BYTE *)v7 = v6;
    }
    while ( (_BYTE)v6 );
  }
  if ( v13 )
  {
    v6 = v12;
    *(_DWORD *)(v6 + 112) &= 0xFFFFFFFDu;
  }
  return v6;
}

//----- (1004A988) --------------------------------------------------------
int __usercall sub_1004A988<eax>(int a1<ebx>, int a2, int a3, int a4)
{
  return sub_1004A9A0(a1, a2, a3, a4, 0);
}

//----- (1004A9A0) --------------------------------------------------------
int __usercall sub_1004A9A0<eax>(int a1<ebx>, int a2, int a3, int a4, int a5)
{
  int result; // eax@2
  int v6; // ecx@2
  int v7; // [sp+0h] [bp-8h]@2
  int v8; // [sp+4h] [bp-4h]@2

  if ( a2 )
  {
    sub_10053137(a1, (int)&v7, a4, a5);
    v6 = a3;
    *(_DWORD *)a3 = v7;
    result = v8;
    *(_DWORD *)(v6 + 4) = v8;
  }
  else
  {
    sub_100531C3(a1, (int)&a2, a4, a5);
    result = a2;
    *(_DWORD *)a3 = a2;
  }
  return result;
}

//----- (1004A9E0) --------------------------------------------------------
char __usercall sub_1004A9E0<al>(int a1<ebx>, int a2<edi>, int *a3)
{
  return sub_1004A9F1(a1, a2, a3, 0);
}

//----- (1004A9F1) --------------------------------------------------------
char __usercall sub_1004A9F1<al>(int a1<ebx>, int a2<edi>, int *a3, int a4)
{
  char i; // zf@1
  signed int *v5; // esi@1
  char v6; // cl@6
  int v7; // esi@6
  int v8; // eax@7
  int v10; // [sp+4h] [bp-10h]@1
  int v11; // [sp+Ch] [bp-8h]@9
  char v12; // [sp+10h] [bp-4h]@8

  sub_100301AD((int)&v10, a1, a2, a4);
  v5 = a3;
  for ( i = sub_100399F3(a1, a2, *(_BYTE *)a3) == 101; !i; i = sub_10036D5B(a1, a2, *(_BYTE *)v5) == 0 )
    v5 = (signed int *)((char *)v5 + 1);
  if ( sub_100399F3(a1, a2, *(_BYTE *)v5) == 120 )
    v5 = (signed int *)((char *)v5 + 2);
  v6 = *(_BYTE *)v5;
  *(_BYTE *)v5 = ***(_BYTE ***)(v10 + 132);
  v7 = (int)((char *)v5 + 1);
  do
  {
    LOBYTE(v8) = *(_BYTE *)v7;
    *(_BYTE *)v7 = v6;
    v6 = v8;
    LOBYTE(v8) = *(_BYTE *)v7++;
  }
  while ( (_BYTE)v8 );
  if ( v12 )
  {
    v8 = v11;
    *(_DWORD *)(v8 + 112) &= 0xFFFFFFFDu;
  }
  return v8;
}

//----- (1004AA63) --------------------------------------------------------
bool __cdecl sub_1004AA63(int a1)
{
  return *(double *)a1 >= 0.0;
}

//----- (1004AA7D) --------------------------------------------------------
void __cdecl sub_1004AA7D(int a1, int a2)
{
  int v2; // eax@2

  if ( a2 )
  {
    v2 = sub_10035530(a1);
    sub_1002A4B0((void *)(a1 + a2), (const void *)a1, v2 + 1);
  }
}

//----- (1004AAA5) --------------------------------------------------------
signed int __usercall sub_1004AAA5<eax>(int a1<ebx>, int a2<edi>)
{
  signed int result; // eax@1

  result = sub_100534AF(a1, a2, 0, 65536, 196608);
  if ( result )
  {
    sub_1003A161(a1, a2);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1004AACC);
  }
  return result;
}

//----- (1004AACC) --------------------------------------------------------
int (*__cdecl sub_1004AACC())()
{
  unsigned int v0; // esi@1
  int (*result)(); // eax@2

  v0 = 0;
  do
  {
    result = (int (*)())EncodePointer(*(int (**)())((char *)off_100741CC + v0));
    *(int (**)())((char *)off_100741CC + v0) = result;
    v0 += 4;
  }
  while ( v0 < 0x28 );
  return result;
}
// 100741CC: using guessed type int (*off_100741CC[10])();

//----- (1004AAEB) --------------------------------------------------------
int __usercall sub_1004AAEB<eax>(int a1<ebx>, int a2<edi>, int a3, const WCHAR *a4)
{
  int result; // eax@3
  const WCHAR *v5; // ecx@4
  int v6; // edx@5
  unsigned __int16 v7; // ax@6
  unsigned __int16 v8; // si@8
  const WCHAR v9; // ax@10

  if ( dword_10075F28 )
  {
    result = sub_1004AB7E(a1, a2, a3, a4, 0);
  }
  else
  {
    if ( a3 && (v5 = a4, a4) )
    {
      v6 = a3 - (_DWORD)a4;
      do
      {
        v7 = *(const WCHAR *)((char *)v5 + v6);
        if ( v7 < 0x41u || v7 > 0x5Au )
          v8 = *(const WCHAR *)((char *)v5 + v6);
        else
          v8 = v7 + 32;
        v9 = *v5;
        if ( *v5 >= 0x41u )
        {
          if ( v9 <= 0x5Au )
            v9 += 32;
        }
        ++v5;
      }
      while ( v8 && v8 == v9 );
      result = v8 - v9;
    }
    else
    {
      *(_DWORD *)sub_10037649(a1) = 22;
      sub_1003A151(a1, a2);
      result = 2147483647;
    }
  }
  return result;
}
// 10075F28: using guessed type int dword_10075F28;

//----- (1004AB7E) --------------------------------------------------------
int __usercall sub_1004AB7E<eax>(int a1<ebx>, int a2<edi>, int a3, const WCHAR *a4, int a5)
{
  int v5; // ebx@1
  const WCHAR *v6; // esi@2
  int v7; // edx@3
  int v8; // ebx@5
  unsigned __int16 v9; // ax@6
  WCHAR v10; // ax@10
  int v12; // [sp+8h] [bp-10h]@1
  int v13; // [sp+10h] [bp-8h]@20
  char v14; // [sp+14h] [bp-4h]@19

  sub_100301AD((int)&v12, a1, a2, a5);
  v5 = a3;
  if ( a3 && (v6 = a4, a4) )
  {
    if ( *(_DWORD *)(v12 + 168) )
    {
      do
      {
        a2 = sub_10053515(v5, a2, *(_WORD *)v5, (int)&v12);
        v5 += 2;
        v10 = sub_10053515(v5, a2, *v6, (int)&v12);
        ++v6;
      }
      while ( (_WORD)a2 && (_WORD)a2 == v10 );
    }
    else
    {
      v8 = a3 - (_DWORD)a4;
      do
      {
        v9 = *(const WCHAR *)((char *)v6 + v8);
        if ( v9 < 0x41u || v9 > 0x5Au )
          LOWORD(a2) = *(const WCHAR *)((char *)v6 + v8);
        else
          LOWORD(a2) = v9 + 32;
        v10 = *v6;
        if ( *v6 >= 0x41u )
        {
          if ( v10 <= 0x5Au )
            v10 += 32;
        }
        ++v6;
      }
      while ( (_WORD)a2 && (_WORD)a2 == v10 );
    }
    v7 = (unsigned __int16)a2 - v10;
  }
  else
  {
    *(_DWORD *)sub_10037649(a3) = 22;
    sub_1003A151(a3, a2);
    v7 = 2147483647;
  }
  if ( v14 )
    *(_DWORD *)(v13 + 112) &= 0xFFFFFFFDu;
  return v7;
}

//----- (1004AC57) --------------------------------------------------------
unsigned int __cdecl sub_1004AC57(int a1, unsigned int a2)
{
  unsigned int result; // eax@1
  int v3; // ecx@2

  result = 0;
  if ( a2 )
  {
    v3 = a1;
    do
    {
      if ( !*(_WORD *)v3 )
        break;
      ++result;
      v3 += 2;
    }
    while ( result < a2 );
  }
  return result;
}

//----- (1004AC80) --------------------------------------------------------
int __usercall sub_1004AC80<eax>(int a1<edx>, __int16 a2<cx>, int a3<ebp>, __int16 a4<fpstat>, double _ST7<st0>, char a6, char a7, char a8)
{
  signed __int16 v8; // bx@2

  if ( *(_BYTE *)(a1 + 14) == 5 )
  {
    HIBYTE(v8) = ((unsigned __int8)(*(_WORD *)(a3 - 164) >> 8) | 2) & 0xFE;
    LOBYTE(v8) = 63;
  }
  else
  {
    v8 = 4927;
  }
  *(_WORD *)(a3 - 162) = v8;
  _EBX = &unk_100650DC;
  __asm { fxam }
  *(_DWORD *)(a3 - 148) = a1;
  *(_WORD *)(a3 - 160) = a4;
  *(_BYTE *)(a3 - 144) = 0;
  LOBYTE(a2) = __ROL__((char)(2 * *(_BYTE *)(a3 - 159)) >> 1, 1);
  _AL = a2 & 0xF;
  __asm { xlat }
  return (*(int (__thiscall **)(int))(_AL + a1 + 16))(a2 & 0x404);
}

//----- (1004ACE7) --------------------------------------------------------
int __usercall sub_1004ACE7<eax>(int a1<edx>, int a2<ebp>, __int16 a3<fpstat>, double _ST6<st1>, double a5<st0>, char a6, char a7, char a8)
{
  signed __int16 v8; // bx@2
  __int16 v11; // fps@4
  char v13; // cl@4
  __int16 v14; // cx@4
  char v17; // ah@4

  if ( *(_BYTE *)(a1 + 14) == 5 )
  {
    HIBYTE(v8) = ((unsigned __int8)(*(_WORD *)(a2 - 164) >> 8) | 2) & 0xFE;
    LOBYTE(v8) = 63;
  }
  else
  {
    v8 = 4927;
  }
  *(_WORD *)(a2 - 162) = v8;
  _EBX = &unk_100650DC;
  __asm { fxam }
  *(_DWORD *)(a2 - 148) = a1;
  *(_WORD *)(a2 - 160) = a3;
  *(_BYTE *)(a2 - 144) = 0;
  UNDEF(v11);
  _ST6 = a5;
  v13 = *(_BYTE *)(a2 - 159);
  __asm { fxam }
  *(_WORD *)(a2 - 160) = v11;
  HIBYTE(v14) = __ROL__((char)(2 * *(_BYTE *)(a2 - 159)) >> 1, 1);
  _AL = HIBYTE(v14) & 0xF;
  __asm { xlat }
  v17 = _AL;
  LOBYTE(v14) = __ROL__((char)(2 * v13) >> 1, 1);
  _AL = v14 & 0xF;
  __asm { xlat }
  return (*(int (__thiscall **)(int))((char)(4 * v17 | _AL) + a1 + 16))(v14 & 0x404);
}

//----- (1004AD8D) --------------------------------------------------------
double __cdecl sub_1004AD8D()
{
  return 1.0;
}

//----- (1004AD92) --------------------------------------------------------
double __usercall sub_1004AD92<st0>(int a1<ebp>, double a2<st0>)
{
  double result; // st7@1

  *(_QWORD *)(a1 - 158) = *(_QWORD *)&a2;
  result = *(double *)(a1 - 158);
  if ( *(_BYTE *)(a1 - 151) & 0x40 )
  {
    *(_BYTE *)(a1 - 144) = 7;
  }
  else
  {
    *(_BYTE *)(a1 - 144) = 1;
    result = result + 1.0;
  }
  return result;
}

//----- (1004AE39) --------------------------------------------------------
void __usercall sub_1004AE39(int a1<ebp>)
{
  *(_BYTE *)(a1 - 144) = 1;
}

//----- (1004AE50) --------------------------------------------------------
void __cdecl sub_1004AE50()
{
  JUMPOUT(*(unsigned int *)loc_1004AE70);
}
// 1004AE70: using guessed type int __cdecl loc_1004AE70(__int16, int, int, int);

//----- (1004AE67) --------------------------------------------------------
double __usercall sub_1004AE67<st0>(int a1<eax>, int a2<edx>, int a3<ecx>, double a4<st0>, __int16 a5, int a6, int a7, int a8)
{
  int ebp0; // ebp@0
  int v10; // [sp+0h] [bp-20h]@1
  int v11; // [sp+4h] [bp-1Ch]@1
  int v12; // [sp+8h] [bp-18h]@1
  int v13; // [sp+Ch] [bp-14h]@1
  double v14; // [sp+18h] [bp-8h]@1

  v10 = a1;
  v14 = a4;
  v11 = a3;
  v12 = a7;
  v13 = a8;
  sub_100535C7(ebp0, a2, (int)&v10, (int)&a5);
  return v14;
}

//----- (1004AEC5) --------------------------------------------------------
void __cdecl sub_1004AEC5()
{
  ;
}

//----- (1004AEDC) --------------------------------------------------------
double __usercall sub_1004AEDC<st0>(int a1<eax>, double result<st0>)
{
  if ( !(a1 & 0x80000) )
    result = result + 1.0;
  return result;
}

//----- (1004AEF5) --------------------------------------------------------
double __fastcall sub_1004AEF5(int a1, int a2)
{
  double result; // st7@2

  if ( (*(_DWORD *)(a2 + 4) & 0x7FF00000) == 2146435072 )
    result = COERCE_DOUBLE(*(_QWORD *)a2 << 11);
  else
    result = *(double *)a2;
  return result;
}

//----- (1004AF38) --------------------------------------------------------
int __cdecl sub_1004AF38(int a1, int a2)
{
  int result; // eax@1

  result = a2 & 0x7FF00000;
  if ( (a2 & 0x7FF00000) == 2146435072 )
    result = a2;
  return result;
}

//----- (1004B03C) --------------------------------------------------------
int __usercall sub_1004B03C<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  return sub_100538F4(a1, a2, a3, 0, 10);
}

//----- (1004B050) --------------------------------------------------------
int __usercall sub_1004B050<eax>(int a1<ebx>, int a2)
{
  LPVOID v2; // esi@1
  int result; // eax@2
  unsigned int v4; // edi@8

  v2 = dword_1007586C;
  if ( dword_100778D4 )
  {
    if ( dword_1007586C || dword_10075870 && !sub_1005391E(a1) && (v2 = dword_1007586C, dword_1007586C) )
    {
      if ( a2 )
      {
        v4 = sub_10035530(a2);
        while ( *(_DWORD *)v2 )
        {
          if ( sub_10035530(*(_DWORD *)v2) > v4
            && *(_BYTE *)(*(_DWORD *)v2 + v4) == 61
            && !sub_100539AB(a1, v4, *(_DWORD *)v2, a2, v4) )
            return v4 + *(_DWORD *)v2 + 1;
          v2 = (char *)v2 + 4;
        }
      }
    }
    result = 0;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 100778D4: using guessed type int dword_100778D4;

//----- (1004B0E0) --------------------------------------------------------
int __cdecl sub_1004B0E0(int a1, unsigned int a2)
{
  int result; // eax@1
  unsigned int v3; // edx@1
  int v4; // ecx@1
  unsigned int v5; // esi@2

  v4 = a1 + *(_DWORD *)(a1 + 60);
  v3 = 0;
  result = v4 + *(_WORD *)(v4 + 20) + 24;
  if ( *(_WORD *)(v4 + 6) )
  {
    while ( 1 )
    {
      v5 = *(_DWORD *)(result + 12);
      if ( a2 >= v5 )
      {
        if ( a2 < v5 + *(_DWORD *)(result + 8) )
          break;
      }
      ++v3;
      result += 40;
      if ( v3 >= *(_WORD *)(v4 + 6) )
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    result = 0;
  }
  return result;
}

//----- (1004B130) --------------------------------------------------------
unsigned int __usercall sub_1004B130<eax>(int a1<eax>, int a2)
{
  int v2; // eax@1
  int v3; // eax@2
  unsigned int result; // eax@3
  unsigned int v5; // [sp-10h] [bp-28h]@1
  unsigned int *v6; // [sp+0h] [bp-18h]@1
  int v7; // [sp+8h] [bp-10h]@1
  int (__cdecl *v8)(PEXCEPTION_RECORD, int, int); // [sp+Ch] [bp-Ch]@1
  unsigned int v9; // [sp+10h] [bp-8h]@1
  int v10; // [sp+14h] [bp-4h]@1
  int v11; // [sp+18h] [bp+0h]@1

  v8 = sub_1003B2A0;
  v7 = a1;
  v9 = __security_cookie ^ (unsigned int)&unk_1006C410;
  v5 = (unsigned int)&v11 ^ __security_cookie;
  v6 = &v5;
  v10 = 0;
  LOBYTE(v2) = sub_1004B1F0(268435456);
  if ( v2 && (v3 = sub_1004B0E0(268435456, a2 - 268435456)) != 0 )
  {
    result = ~(unsigned __int8)(*(_DWORD *)(v3 + 36) >> 31) & 1;
    v10 = -2;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;

//----- (1004B1F0) --------------------------------------------------------
char __cdecl sub_1004B1F0(int a1)
{
  char result; // al@2
  int v2; // ecx@3

  if ( *(_WORD *)a1 == 23117 )
  {
    v2 = a1 + *(_DWORD *)(a1 + 60);
    result = 0;
    if ( *(_DWORD *)v2 == 17744 )
      result = *(_WORD *)(v2 + 24) == 267;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004B221) --------------------------------------------------------
int __cdecl sub_1004B221(int a1)
{
  int result; // eax@1

  result = a1;
  dword_1007619C = a1;
  return result;
}
// 1007619C: using guessed type int dword_1007619C;

//----- (1004B230) --------------------------------------------------------
int __usercall sub_1004B230<eax>(int a1<ebp>, int a2, int a3, unsigned int a4)
{
  int result; // eax@2
  unsigned int v5; // esi@2
  int v6; // ebx@5
  char v7; // [sp-8h] [bp-28h]@1
  int (__cdecl *v8)(int, int, int, int); // [sp-4h] [bp-24h]@1
  unsigned int v9; // [sp+0h] [bp-20h]@1
  unsigned int v10; // [sp+4h] [bp-1Ch]@1
  int v11; // [sp+8h] [bp-18h]@1
  int v12; // [sp+Ch] [bp-14h]@1

  v12 = a2;
  v11 = a3;
  v10 = a4;
  v8 = loc_1004B2C0;
  v9 = (unsigned int)&v7 ^ __security_cookie;
  while ( 1 )
  {
    result = a3;
    v5 = *(_DWORD *)(a3 + 12);
    if ( v5 == -2 )
      break;
    if ( a4 != -2 && v5 <= a4 )
      break;
    v6 = (*(_DWORD *)a2 ^ *(_DWORD *)(a3 + 8)) + 12 * v5 + 16;
    *(_DWORD *)(a3 + 12) = *(_DWORD *)((*(_DWORD *)a2 ^ *(_DWORD *)(a3 + 8)) + 12 * v5 + 0x10);
    if ( !*(_DWORD *)(v6 + 4) )
    {
      sub_10052F25(*(_DWORD *)(v6 + 8), a1, 257);
      sub_10052F44(*(int (**)(void))(v6 + 8));
    }
  }
  return result;
}
// 1004B2C0: using guessed type int __cdecl loc_1004B2C0(int, int, int, int);
// 10073200: using guessed type int __security_cookie;

//----- (1004B322) --------------------------------------------------------
int __thiscall sub_1004B322(void *this)
{
  return ((int (__fastcall *)(_DWORD, _DWORD))this)(this, 0);
}

//----- (1004B339) --------------------------------------------------------
int __fastcall sub_1004B339(int a1, int a2)
{
  int v3; // esi@1

  v3 = a1;
  sub_10052F25(a1, a2, 1);
  return ((int (__fastcall *)(_DWORD, _DWORD))v3)(0, 0);
}

//----- (1004B352) --------------------------------------------------------
void __fastcall sub_1004B352(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord)
{
  RtlUnwind(TargetFrame, loc_1004B366, ExceptionRecord, 0);
}
// 1004B366: using guessed type int __fastcall loc_1004B366(PVOID TargetFrame, PEXCEPTION_RECORD ExceptionRecord);

//----- (1004B36B) --------------------------------------------------------
int __fastcall sub_1004B36B(int a1, unsigned int a2, int a3, int a4)
{
  return sub_1004B230(a3, a4, a1, a2);
}

//----- (1004B382) --------------------------------------------------------
int __thiscall sub_1004B382(int this, int a2, int a3, int a4)
{
  int v5; // eax@1

  *(_DWORD *)this = off_10065138;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_WORD *)(this + 12) = 0;
  *(_DWORD *)(this + 20) = a2;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  v5 = *(_DWORD *)(a3 + 16);
  *(_DWORD *)(this + 40) = a4;
  *(_DWORD *)(this + 36) = v5;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 44) = (*(_DWORD *)(a3 + 12) << 8) + *(_BYTE *)(*(_DWORD *)(a3 + 48) + 52 * a4 + 8);
  return this;
}
// 10065138: using guessed type int (*off_10065138[2])();

//----- (1004B3E9) --------------------------------------------------------
int __thiscall sub_1004B3E9(int this, int a2, int a3)
{
  int v4; // ebx@1
  int v5; // eax@1

  v4 = this;
  *(_DWORD *)this = off_10065138;
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_WORD *)(this + 12) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 20) = a2;
  *(_DWORD *)(this + 24) = a3;
  *(_DWORD *)(this + 36) = (**(int (__thiscall ***)(_DWORD))a3)(a3);
  v5 = *(_DWORD *)(a3 + 40);
  *(_DWORD *)(v4 + 48) = 0;
  *(_DWORD *)(v4 + 40) = v5;
  *(_DWORD *)(v4 + 44) = (*(int (__thiscall **)(int))(*(_DWORD *)a3 + 4))(a3);
  return v4;
}
// 10065138: using guessed type int (*off_10065138[2])();

//----- (1004B448) --------------------------------------------------------
int __thiscall sub_1004B448(int this)
{
  return sub_1003C09C(*(_DWORD *)(*(_DWORD *)(this + 20) + 12), *(_DWORD *)(this + 36), *(_DWORD *)(this + 40));
}

//----- (1004B45A) --------------------------------------------------------
void __thiscall sub_1004B45A(int this)
{
  int v1; // esi@1
  char v2; // zf@1
  char v3; // bl@2
  HANDLE v4; // eax@4

  v1 = this;
  v2 = *(_DWORD *)(this + 48) == 1;
  --*(_DWORD *)(v1 + 48);
  if ( v2 )
  {
    v3 = *(_DWORD *)(this + 28) != 0;
    sub_1004B605(this);
    if ( *(_DWORD *)(v1 + 24) )
    {
      sub_1004B45A();
      sub_1004CB86(*(void **)(v1 + 20), (void *)v1);
    }
    else
    {
      sub_1004C3FC(*(_DWORD *)(v1 + 20), *(_DWORD *)(v1 + 36), *(_DWORD *)(v1 + 40), v3 == 0);
      if ( !v3 )
      {
        v4 = GetCurrentThread();
        sub_1003BB65((DWORD_PTR *)(v1 + 8), v4);
        sub_1004C3A4(*(_DWORD *)(v1 + 20), v1);
        sub_1004C48C(*(_DWORD *)(v1 + 20), v1);
      }
    }
  }
}

//----- (1004B4C5) --------------------------------------------------------
int __thiscall sub_1004B4C5(int this)
{
  return *(_DWORD *)(this + 44);
}

//----- (1004B4C9) --------------------------------------------------------
int __thiscall sub_1004B4C9(int this)
{
  return *(_DWORD *)(this + 36);
}

//----- (1004B4CD) --------------------------------------------------------
BOOL __thiscall sub_1004B4CD(int lpTlsValue)
{
  BOOL result; // eax@1
  int v2; // ebx@1
  int v3; // ecx@1
  int v4; // ecx@2
  int v5; // eax@4
  void *v6; // esi@4
  int v7; // eax@4
  int v8; // ecx@4
  int v9; // eax@4
  int v10; // edx@4
  char v11; // [sp+7h] [bp-1Dh]@2
  char v12; // [sp+8h] [bp-1Ch]@4
  int v13; // [sp+14h] [bp-10h]@4
  _DWORD v14[2]; // [sp+18h] [bp-Ch]@4
  int v15; // [sp+1Ch] [bp-8h]@4
  unsigned int v16; // [sp+20h] [bp-4h]@1
  int v17; // [sp+24h] [bp+0h]@1

  v16 = (unsigned int)&v17 ^ __security_cookie;
  v2 = lpTlsValue;
  v3 = *(_DWORD *)(lpTlsValue + 48);
  result = v3 + 1;
  *(_DWORD *)(v2 + 48) = v3 + 1;
  if ( !v3 )
  {
    v4 = *(_DWORD *)(v2 + 20);
    v11 = *(_DWORD *)(v2 + 28) != 0;
    if ( *(_DWORD *)(v2 + 24) )
    {
      sub_1004C047(v4, v2);
    }
    else
    {
      sub_1004C979(v4, *(_DWORD *)(v2 + 36), *(_DWORD *)(v2 + 40), (*(_DWORD *)(v2 + 28) != 0) == 0);
      if ( !v11 )
      {
        v5 = (int)GetCurrentThread();
        v6 = (void *)v5;
        v7 = sub_1003B78E((int)&v12, v5);
        *(_WORD *)(v2 + 12) = *(_WORD *)(v7 + 4);
        *(_DWORD *)(v2 + 8) = *(_DWORD *)v7;
        v8 = 52 * *(_DWORD *)(v2 + 36);
        v9 = *(_DWORD *)(*(_DWORD *)(v2 + 20) + 16);
        v10 = *(_DWORD *)(v8 + v9);
        LOWORD(v8) = *(_WORD *)(v8 + v9 + 12);
        v14[0] = 0;
        v15 = 0;
        LOWORD(v14[0]) = v8;
        v13 = v10;
        sub_1003BB65((DWORD_PTR *)&v13, v6);
        sub_1004C91D(*(_DWORD *)(v2 + 20), v2);
        sub_1004BFB6(v2);
      }
    }
    result = sub_1004B620((LPVOID)v2);
  }
  return result;
}
// 1004BFB6: using guessed type _DWORD __stdcall sub_1004BFB6(_DWORD);
// 10073200: using guessed type int __security_cookie;

//----- (1004B599) --------------------------------------------------------
int __thiscall sub_1004B599(int this, int a2)
{
  int ebp0; // ebp@0
  int v3; // edi@1
  int v4; // esi@1
  int v6; // [sp-4h] [bp-18h]@3
  int (__stdcall **v7)(char); // [sp+8h] [bp-Ch]@3

  v3 = a2;
  v4 = this;
  if ( !a2 )
  {
    a2 = (int)"pScheduler";
    sub_1002AEA4((int)&v7, &a2);
    v7 = &off_1005F2EC;
    v6 = (int)&unk_1006C8B4;
    goto LABEL_7;
  }
  if ( sub_1004C594(*(_DWORD *)(this + 20)) != (LPVOID)this || *(_DWORD *)(*(_DWORD *)(v4 + 20) + 8) != v3 )
  {
    sub_1002FFD5((int)&v7);
    v6 = (int)&unk_1006C878;
LABEL_7:
    sub_100355BB((int)&v7, v6);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1004B605);
  }
  return sub_1003EA80(ebp0, v4);
}
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);

//----- (1004B605) --------------------------------------------------------
BOOL __thiscall sub_1004B605(int this)
{
  BOOL result; // eax@1
  int v2; // esi@1

  v2 = this;
  result = TlsSetValue(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 20) + 12) + 112), *(LPVOID *)(this + 32));
  *(_DWORD *)(v2 + 32) = 0;
  return result;
}

//----- (1004B620) --------------------------------------------------------
BOOL __thiscall sub_1004B620(LPVOID lpTlsValue)
{
  void *v2; // edi@1
  DWORD v3; // esi@1

  v2 = lpTlsValue;
  v3 = *(_DWORD *)(*(_DWORD *)(*((_DWORD *)lpTlsValue + 5) + 12) + 112);
  *((_DWORD *)lpTlsValue + 8) = TlsGetValue(v3);
  return TlsSetValue(v3, v2);
}

//----- (1004B642) --------------------------------------------------------
unsigned int __cdecl sub_1004B642(unsigned int a1)
{
  unsigned int result; // eax@1

  result = a1;
  if ( a1 )
    result = (a1 > 0 ? 2 : 0) - 1;
  return result;
}

//----- (1004B65A) --------------------------------------------------------
double __cdecl sub_1004B65A(double a1)
{
  double result; // st7@2
  signed int v2; // [sp+Ch] [bp+Ch]@4

  if ( 0.0 == a1 )
  {
    result = 0.0;
  }
  else
  {
    if ( a1 <= 0.0 )
      v2 = -1;
    else
      v2 = 1;
    result = (double)v2;
  }
  return result;
}

//----- (1004B690) --------------------------------------------------------
int __thiscall sub_1004B690(int this, int a2, unsigned int a3, int a4)
{
  int v4; // eax@1
  signed int v5; // edx@1

  v5 = 63;
  v4 = this + 8;
  do
  {
    *(double *)(v4 - 8) = 0.0;
    *(_DWORD *)(v4 + 8) = 0;
    *(double *)v4 = 0.0;
    *(_DWORD *)(v4 + 12) = 0;
    *(_DWORD *)(v4 + 16) = 0;
    v4 += 32;
    --v5;
  }
  while ( v5 >= 0 );
  *(_DWORD *)(this + 2048) = a4;
  *(_DWORD *)(this + 2076) = a2;
  *(_DWORD *)(this + 2068) = 0;
  *(_DWORD *)(this + 2072) = 0;
  *(_DWORD *)(this + 2080) = 0;
  *(_DWORD *)(this + 2084) = 0;
  *(_DWORD *)(this + 2088) = 0;
  *(_DWORD *)(this + 2092) = 0;
  *(_DWORD *)(this + 2096) = 0;
  *(_BYTE *)(this + 2100) = 1;
  *(_DWORD *)(this + 2064) = a3;
  *(double *)(this + 2056) = (double)a3;
  return this;
}

//----- (1004B71A) --------------------------------------------------------
int __thiscall sub_1004B71A(int this, double a2, int a3)
{
  int result; // eax@1
  double v4; // st7@1

  v4 = *(double *)this;
  result = a3;
  ++*(_DWORD *)(this + 16);
  *(_DWORD *)(this + 24) = a3;
  *(double *)this = v4 + a2;
  *(double *)(this + 8) = a2 * a2 + *(double *)(this + 8);
  return result;
}

//----- (1004B73D) --------------------------------------------------------
double __stdcall sub_1004B73D(unsigned int a1, unsigned int a2, int a3, int a4)
{
  return (double)a2 * 10.0 / (double)a1;
}

//----- (1004B778) --------------------------------------------------------
double __thiscall sub_1004B778(void *this, int a2, int a3)
{
  int v3; // edi@1
  long double v4; // st7@1
  void *v5; // edi@1
  int v6; // esi@1
  double v7; // ST28_8@1
  double v8; // ST28_8@2
  double v9; // ST20_8@2
  double v10; // st7@2
  double v12; // [sp+Ch] [bp-20h]@1
  double v13; // [sp+14h] [bp-18h]@1

  v5 = this;
  v6 = sub_1004B8F0(this, a2);
  v3 = sub_1004B8F0(v5, a3);
  v7 = sub_1004B964(v6);
  v13 = sub_1004B964(v3) - v7;
  v12 = v13 / v7 / ((double)(a3 - a2) / (double)a2) - 0.15;
  v4 = 0.0;
  if ( fabs(v13) > 0.0 )
  {
    v8 = (double)*(signed int *)(v3 + 16);
    v9 = sub_1004BC13(v3) / v8;
    v10 = sub_1004BC13(v3) / v8 + v9;
    sub_10039E00();
    v4 = fabs(v10 / v13);
  }
  sub_10053ABC();
  return -v4 * v12;
}
// 10039E00: using guessed type double sub_10039E00(void);
// 10053ABC: using guessed type double sub_10053ABC(void);

//----- (1004B830) --------------------------------------------------------
double __thiscall sub_1004B830(int this)
{
  int v2; // esi@1
  double v3; // st7@1
  double v4; // ST04_8@1
  double v5; // st7@1

  v2 = this;
  sub_1004BC13(this);
  sub_10039E00();
  v4 = v3;
  v5 = (double)*(signed int *)(v2 + 16);
  sub_10039E00();
  return v4 / v5 / sub_1004B964(v2);
}
// 10039E00: using guessed type double sub_10039E00(void);

//----- (1004B867) --------------------------------------------------------
int __thiscall sub_1004B867(int this, int a2)
{
  int result; // eax@1
  int v3; // ecx@1
  int v4; // esi@1
  int v5; // eax@2

  result = a2;
  v4 = this;
  v3 = *(_DWORD *)(this + 2068);
  if ( a2 != v3 )
  {
    *(_DWORD *)(v4 + 2072) = v3;
    *(_DWORD *)(v4 + 2068) = a2;
    v5 = sub_1004B8F0((void *)v4, a2);
    *(double *)v5 = 0.0;
    *(_DWORD *)(v5 + 16) = 0;
    *(double *)(v5 + 8) = 0.0;
    *(_DWORD *)(v5 + 20) = 0;
    *(_DWORD *)(v5 + 24) = 0;
    result = sub_1004B8AC(v4);
  }
  return result;
}

//----- (1004B8AC) --------------------------------------------------------
__int64 __fastcall sub_1004B8AC(int a1)
{
  __int64 result; // qax@1
  signed int v2; // esi@1

  HIDWORD(result) = a1 + 20;
  v2 = 64;
  do
  {
    LODWORD(result) = *HIDWORD(result);
    if ( *HIDWORD(result) != *(_DWORD *)(a1 + 2068) )
    {
      if ( (_DWORD)result != *(_DWORD *)(a1 + 2072) )
      {
        LODWORD(result) = *(_DWORD *)(a1 + 2084) - *(_DWORD *)(HIDWORD(result) + 4);
        if ( (_DWORD)result > 0x32u )
        {
          *(_DWORD *)(HIDWORD(result) - 4) = 0;
          *(double *)(HIDWORD(result) - 20) = 0.0;
          *HIDWORD(result) = 0;
          *(double *)(HIDWORD(result) - 12) = 0.0;
          *(_DWORD *)(HIDWORD(result) + 4) = 0;
        }
      }
    }
    result += 137438953472i64;
    --v2;
  }
  while ( v2 );
  return result;
}

//----- (1004B8F0) --------------------------------------------------------
int __thiscall sub_1004B8F0(void *this, int a2)
{
  int result; // eax@1

  result = (int)((char *)this + 32 * (a2 & 0x3F));
  if ( *(_DWORD *)(result + 20) != a2 )
  {
    *(_DWORD *)(result + 16) = 0;
    *(_DWORD *)(result + 24) = 0;
    *(double *)result = 0.0;
    *(double *)(result + 8) = 0.0;
    *(_DWORD *)(result + 20) = a2;
  }
  return result;
}

//----- (1004B91B) --------------------------------------------------------
bool __thiscall sub_1004B91B(int this)
{
  bool result; // eax@1
  char v2; // dl@1

  v2 = *(_BYTE *)(this + 2100);
  result = v2 != 0;
  *(_BYTE *)(this + 2100) = v2 == 0;
  return result;
}

//----- (1004B934) --------------------------------------------------------
char __stdcall sub_1004B934(int a1)
{
  return *(_DWORD *)(a1 + 16) > 5u || *(_DWORD *)(a1 + 16) >= 3u && fabs(sub_1004B830(a1)) <= 0.004;
}

//----- (1004B964) --------------------------------------------------------
double __fastcall sub_1004B964(int a1)
{
  double result; // st7@2
  signed int v2; // [sp+4h] [bp-4h]@1

  v2 = *(_DWORD *)(a1 + 16);
  if ( v2 )
    result = *(double *)a1 / (double)v2;
  else
    result = 0.0;
  return result;
}

//----- (1004B984) --------------------------------------------------------
int __thiscall sub_1004B984(int this, unsigned int a2)
{
  int v2; // eax@1
  unsigned int v3; // ecx@1
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // edi@1
  int v8; // esi@1
  int v10; // [sp+Ch] [bp-4h]@1

  v7 = this;
  v10 = this;
  v8 = *(_DWORD *)(this + 2048);
  v4 = *(_DWORD *)(v8 + 184) + sub_1003DDC2(*(_DWORD *)(this + 2048));
  v2 = sub_1003C109(v8);
  v5 = *(_DWORD *)(v7 + 2068);
  v3 = *(_DWORD *)(v10 + 2064);
  v6 = a2;
  if ( v3 + v5 < a2 )
    v6 = v3 + v5;
  if ( v5 > v3 )
  {
    if ( v5 - v3 > v6 )
      v6 = v5 - v3;
  }
  if ( v6 == v5 )
  {
    if ( v6 <= (unsigned int)v4 )
      ++v6;
    else
      --v6;
  }
  if ( v4 > (unsigned int)v6 )
    v6 = v4;
  if ( v2 < (unsigned int)v6 )
    v6 = v2;
  if ( v6 != v5 && sub_1004B642(v6 - v5) == -1 )
  {
    while ( 1 )
    {
      --v5;
      if ( v5 != v6 )
      {
        if ( sub_1004B642(v6 - v5) != -1 )
          break;
      }
      if ( *(_DWORD *)(sub_1004B8F0((void *)v10, v5) + 16) > 0
        && sub_1004B778((void *)v10, *(_DWORD *)(v10 + 2068), v5) * -1.0 <= 0.0 )
        return v5 + 1;
    }
  }
  return v6;
}

//----- (1004BA54) --------------------------------------------------------
int __thiscall sub_1004BA54(int this, int a2, unsigned int a3, int a4, int a5)
{
  int v5; // ebx@1
  int result; // eax@2
  int v7; // edx@3
  unsigned int v8; // ecx@3
  int v9; // edi@3
  unsigned int v10; // esi@8
  int v11; // esi@12
  int v12; // edi@12
  int v13; // edi@14
  unsigned int v14; // eax@14
  int v15; // esi@14
  int v16; // esi@16
  unsigned int v17; // eax@19
  double v18; // st7@19
  int v19; // esi@19
  double v20; // st7@20
  double v21; // [sp+18h] [bp-8h]@14
  double v22; // [sp+18h] [bp-8h]@19
  int v23; // [sp+34h] [bp+14h]@16

  v5 = this;
  if ( !a2 )
    return 0;
  ++*(_DWORD *)(this + 2084);
  sub_1004B867(this, a2);
  v9 = *(_DWORD *)(v5 + 2088);
  v8 = a3;
  v7 = a4;
  if ( v9 )
  {
    v8 = *(_DWORD *)(v5 + 2092) + a3;
    v7 = *(_DWORD *)(v5 + 2096) + a4;
  }
  if ( v8 < a2 )
  {
    if ( v8 < a5 )
    {
      v7 += a2 - v8;
      v8 = a2;
    }
  }
  v10 = *(_DWORD *)(v5 + 2080);
  if ( v10 < 1 || v8 >= 1 || (unsigned int)v7 >= 1 || a5 )
  {
    v14 = v9 + 1;
    v15 = v10 + 1;
    *(_DWORD *)(v5 + 2092) = 0;
    *(_DWORD *)(v5 + 2096) = 0;
    *(_DWORD *)(v5 + 2088) = 0;
    v13 = *(_DWORD *)(v5 + 2068);
    *(_DWORD *)(v5 + 2080) = v15;
    v21 = sub_1004B73D(v14, v8, v7, a5);
    if ( (unsigned int)v15 <= 1 )
    {
      *(_DWORD *)(v5 + 2072) = v13;
      return v13;
    }
    v16 = sub_1004B8F0((void *)v5, v13);
    v23 = sub_1004B8F0((void *)v5, *(_DWORD *)(v5 + 2072));
    sub_1004B71A(v16, v21, *(_DWORD *)(v5 + 2084));
    if ( *(_DWORD *)(v23 + 16) && v16 != v23 )
    {
      if ( !sub_1004B934(v16) )
        return v13;
      v18 = sub_1004B778((void *)v5, *(_DWORD *)(v5 + 2072), *(_DWORD *)(v5 + 2068)) * *(double *)(v5 + 2056);
      v19 = *(_DWORD *)(v5 + 2068);
      v22 = (double)*(unsigned int *)(v5 + 2068);
      sub_1004D276(v18);
      if ( v17 == v19 )
      {
        v20 = sub_1004B65A(v18);
        sub_1004D276(v20 + v22);
      }
    }
    else
    {
      if ( !sub_1004B934(v16) )
        return v13;
      v17 = *(_DWORD *)(v5 + 2068) + sub_1004B91B(v5);
    }
    return sub_1004B984(v5, v17);
  }
  v11 = *(_DWORD *)(v5 + 2048);
  *(_DWORD *)(v5 + 2092) = v8;
  v12 = v9 + 1;
  *(_DWORD *)(v5 + 2088) = v12;
  *(_DWORD *)(v5 + 2096) = v7;
  result = *(_DWORD *)(v11 + 184) + sub_1003DDC2(v11);
  if ( (unsigned int)v12 < 3 )
    result = *(_DWORD *)(v5 + 2068);
  return result;
}
// 1004D276: using guessed type double __usercall sub_1004D276<st0>(double<st0>);

//----- (1004BC13) --------------------------------------------------------
double __fastcall sub_1004BC13(int a1)
{
  signed int v1; // eax@1
  double v2; // st6@1
  double result; // st7@1

  v1 = *(_DWORD *)(a1 + 16);
  result = 0.0;
  v2 = 0.0;
  if ( v1 >= 2 )
    v2 = (*(double *)(a1 + 8) - *(double *)a1 * *(double *)a1 / (double)v1) / (double)(v1 - 1);
  if ( fabs(v2) > 0.0001 )
    result = v2;
  return result;
}

//----- (1004BC5F) --------------------------------------------------------
#error "1004BEAD: call analysis failed (funcsize=178)"

//----- (1004BEB5) --------------------------------------------------------
#error "1004BEF8: call analysis failed (funcsize=21)"

//----- (1004BEFE) --------------------------------------------------------
char *__thiscall sub_1004BEFE(int this, int a2, int a3, char a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // eax@4
  void *v8; // ebx@7
  signed __int64 v10; // qax@8
  char *result; // eax@11
  char v12; // [sp+Ch] [bp-4h]@7
  unsigned int v13; // [sp+20h] [bp+10h]@9

  v6 = this;
  v4 = *(_DWORD *)(this + 164);
  v5 = *(_DWORD *)(this + 144);
  if ( v4 )
    *(_DWORD *)(this + 164) = v4 - 1;
  else
    --v5;
  ++*(_DWORD *)(a2 + 28);
  ++*(_DWORD *)(this + 160);
  v7 = *(_DWORD *)(a2 + 48) + 52 * a3;
  *(_DWORD *)v7 = 4;
  *(_DWORD *)(v7 + 36) = v5;
  *(_DWORD *)(this + 176) += v5;
  if ( a4 )
    sub_1004CC9B(this, a2, a3);
  if ( v5 == 1 )
  {
    v8 = &v12;
  }
  else
  {
    _ECX = 0;
    v10 = 4i64 * (unsigned int)v5;
    __asm { seto    cl }
    v8 = (void *)sub_1002965B(SHIDWORD(v10), v10 | -_ECX, 4, v5, v10 | -_ECX);
  }
  v13 = 0;
  if ( v5 )
  {
    do
      *((_DWORD *)v8 + v13++) = (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v6 + 24))(v6, a2, a3);
    while ( v13 < v5 );
  }
  sub_1004C056(v8, v5);
  result = &v12;
  if ( v8 != &v12 )
    result = (char *)sub_100303A3(v8);
  return result;
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 1004C056: using guessed type _DWORD __stdcall sub_1004C056(_DWORD, _DWORD);

//----- (1004BFB6) --------------------------------------------------------
#error "1004C006: call analysis failed (funcsize=28)"

//----- (1004C00E) --------------------------------------------------------
int __thiscall sub_1004C00E(int this, int a2)
{
  int result; // eax@1

  result = *(_DWORD *)(this + 4);
  if ( result )
  {
    *(_DWORD *)(a2 + 56) = *(_DWORD *)(result + 56);
    *(_DWORD *)(a2 + 52) = *(_DWORD *)(this + 4);
    *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 4) + 56) + 52) = a2;
    result = *(_DWORD *)(this + 4);
    *(_DWORD *)(result + 56) = a2;
  }
  else
  {
    *(_DWORD *)(a2 + 56) = a2;
    *(_DWORD *)(a2 + 52) = a2;
  }
  *(_DWORD *)(this + 4) = a2;
  ++*(_DWORD *)this;
  return result;
}

//----- (1004C047) --------------------------------------------------------
int __thiscall sub_1004C047(int this, int a2)
{
  return sub_1004C00E(this + 196, a2);
}

//----- (1004C056) --------------------------------------------------------
#error "1004C0E2: call analysis failed (funcsize=51)"

//----- (1004C0EA) --------------------------------------------------------
int __thiscall sub_1004C0EA(void *this, int a2)
{
  unsigned int v2; // eax@1
  unsigned int v3; // edx@1
  int v4; // ecx@1
  int v5; // edi@1
  unsigned __int64 v6; // qax@2
  int v7; // ebx@2
  unsigned int v8; // esi@2
  int v9; // esi@5

  v5 = (int)this;
  v4 = 0;
  v2 = *(_DWORD *)(v5 + 140);
  v3 = *(_DWORD *)(v5 + 156);
  if ( v2 > v3 )
  {
    v8 = *(_DWORD *)(v5 + 144);
    v7 = *(_DWORD *)(v5 + 164);
    v6 = v2 - v3;
    if ( v7 * v8 < (_DWORD)v6 )
    {
      LODWORD(v6) = v6 - v7 * v8;
      v4 = v7 + v6 / (v8 - 1);
    }
    else
    {
      v4 = (_DWORD)v6 / v8;
    }
  }
  v9 = v4 + *(_DWORD *)(v5 + 160);
  if ( v9 >= (unsigned int)sub_1003C109(v5) )
    v9 = sub_1003C109(v5);
  if ( v9 >= (unsigned int)a2 )
    v9 = a2;
  return v9;
}

//----- (1004C15A) --------------------------------------------------------
int __thiscall sub_1004C15A(void *this, int a2)
{
  void *v2; // edi@1
  int result; // eax@2
  int (__stdcall **v4)(char); // [sp+8h] [bp-Ch]@5

  v2 = this;
  if ( !a2 )
  {
    a2 = (int)"pContext";
    sub_1002AEA4((int)&v4, &a2);
    v4 = &off_1005F2EC;
    sub_100355BB((int)&v4, (int)&unk_1006C8B4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1004C1AD);
  }
  result = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)a2 + 8))(a2);
  if ( !result )
    result = (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v2 + 28))(v2);
  return result;
}
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);

//----- (1004C1AD) --------------------------------------------------------
int __thiscall sub_1004C1AD(void *this)
{
  unsigned int v1; // ecx@1
  void *v2; // ebx@1
  int v3; // edx@2
  unsigned int v4; // esi@3
  int v5; // ecx@4
  int v6; // ebx@4
  int v7; // edi@5
  int v8; // edi@6
  int v9; // esi@9
  int v10; // esi@12
  void *v12; // [sp+4h] [bp-18h]@1
  int v13; // [sp+Ch] [bp-10h]@2
  unsigned int v14; // [sp+10h] [bp-Ch]@1
  unsigned int v15; // [sp+14h] [bp-8h]@3
  int v16; // [sp+18h] [bp-4h]@4

  v2 = this;
  v1 = 0;
  v12 = v2;
  v14 = 0;
  if ( *((_DWORD *)v2 + 48) )
  {
    v3 = 0;
    v13 = 0;
    do
    {
      v4 = 0;
      v15 = 0;
      if ( *(_DWORD *)(v3 + *((_DWORD *)v2 + 4) + 4) )
      {
        v5 = 0;
        v16 = 0;
        v6 = v3 + *((_DWORD *)v2 + 4);
        do
        {
          v7 = *(_DWORD *)(*(_DWORD *)(v6 + 48) + v5 + 16);
          if ( v7 )
            v8 = *(_DWORD *)(v7 + 56);
          else
            v8 = 0;
          if ( v8 )
          {
            do
            {
              v9 = v8;
              if ( v8 == *(_DWORD *)(*(_DWORD *)(v6 + 48) + v5 + 16) )
                v8 = 0;
              else
                v8 = *(_DWORD *)(v8 + 56);
              v10 = *(_DWORD *)(v9 + 28);
              sub_10053BD2(v10);
              (*(void (__thiscall **)(int))(*(_DWORD *)v10 + 36))(v10);
              v5 = v16;
            }
            while ( v8 );
            v4 = v15;
          }
          ++v4;
          v5 += 52;
          v15 = v4;
          v16 = v5;
        }
        while ( v4 < *(_DWORD *)(v6 + 4) );
        v2 = v12;
        v1 = v14;
        v3 = v13;
      }
      ++v1;
      v3 += 52;
      v14 = v1;
      v13 = v3;
    }
    while ( v1 < *((_DWORD *)v2 + 48) );
  }
  return sub_1002A4AA(*((LPVOID *)v2 + 14));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1004C269) --------------------------------------------------------
int __userpurge sub_1004C269<eax>(int a1<ebx>, int a2<ebp>, int a3, int a4)
{
  int v4; // eax@1
  int v5; // edi@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@1

  sub_10035648();
  v5 = v7;
  v4 = sub_1002ADB1(v8, v7, a1, v7, 60);
  *(_DWORD *)(a2 - 16) = v4;
  v6 = 0;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v4 )
    v6 = sub_1004B382(v4, v5, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12));
  *(_DWORD *)(a2 - 4) = -1;
  sub_1004B4CD(v6);
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1004C2B0) --------------------------------------------------------
#error "1004C364: call analysis failed (funcsize=61)"

//----- (1004C36C) --------------------------------------------------------
int __userpurge sub_1004C36C<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4, int a5)
{
  int v5; // ecx@1
  int v6; // esi@1
  int v7; // ecx@1
  int v8; // edx@1

  sub_10035648();
  v6 = v7;
  v5 = sub_1002ADB1(v8, v7, a1, a3, 88);
  *(_DWORD *)(a2 - 16) = v5;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v5 )
    sub_10053C04(v5, v6, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12));
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1004C3A4) --------------------------------------------------------
int __thiscall sub_1004C3A4(int this, int a2)
{
  int result; // eax@1
  int v3; // edi@1
  int v10; // ecx@2

  v3 = this;
  result = 52 * *(_DWORD *)(a2 + 40)
         + 24
         + *(_DWORD *)(52 * (**(int (__thiscall ***)(_DWORD))a2)(a2) + *(_DWORD *)(this + 16) + 48);
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  if ( _ZF )
  {
    v10 = *(_DWORD *)(v3 + 12);
    result = *(_DWORD *)(v3 + 132) == *(_DWORD *)(v3 + 128);
    if ( *(_DWORD *)(v10 + 16) > (unsigned int)result )
      result = SetEvent(*(HANDLE *)(v10 + 80));
  }
  return result;
}

//----- (1004C3FC) --------------------------------------------------------
int __thiscall sub_1004C3FC(int this, int a2, int a3, char a4)
{
  int result; // eax@1
  int v5; // ecx@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // esi@1
  char v9; // zf@3
  int v10; // [sp+14h] [bp+8h]@1

  v6 = 52 * a2;
  v8 = this;
  result = *(_DWORD *)(this + 16);
  v5 = 52 * a3;
  v7 = 52 * a3 + *(_DWORD *)(result + 52 * a2 + 48);
  v10 = 52 * a3;
  if ( a4 )
  {
    --*(_DWORD *)(v7 + 44);
    --*(_DWORD *)(v8 + 180);
  }
  v9 = *(_DWORD *)(v7 + 40)-- == 1;
  if ( v9 )
  {
    result = v6 + *(_DWORD *)(v8 + 16);
    --*(_DWORD *)(v8 + 172);
    --*(_DWORD *)(result + 36);
    if ( *(_BYTE *)(v7 + 50) )
    {
      result = sub_1004CC9B(v8, result, a3);
      v5 = v10;
      *(_BYTE *)(v7 + 50) = 0;
    }
    if ( a4 )
    {
      result = *(_DWORD *)(*(_DWORD *)(v8 + 16) + v6 + 48);
      if ( !*(_DWORD *)(result + v5 + 36) )
        --*(_DWORD *)(v8 + 184);
    }
  }
  return result;
}

//----- (1004C477) --------------------------------------------------------
int __thiscall sub_1004C477(void *this)
{
  void *v1; // esi@1
  int result; // eax@2

  v1 = this;
  if ( this )
  {
    sub_1004BEB5();
    result = sub_1002A4AA(v1);
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 1004BEB5: using guessed type int sub_1004BEB5(void);

//----- (1004C48C) --------------------------------------------------------
int __thiscall sub_1004C48C(int this, int a2)
{
  int v2; // edx@1
  int v3; // ebx@1
  int v4; // esi@1
  int v5; // esi@2
  int v7; // [sp+Ch] [bp-4h]@1

  v4 = this;
  v7 = this;
  v2 = *(_DWORD *)(this + 16) + 52 * (**(int (__thiscall ***)(_DWORD))a2)(a2);
  v3 = *(_DWORD *)(v2 + 48) + 52 * *(_DWORD *)(a2 + 40);
  if ( !(*(_DWORD *)(v3 + 36) + *(_DWORD *)(v3 + 44)) )
  {
    --*(_DWORD *)(v2 + 28);
    *(_DWORD *)v3 = 1;
    --*(_DWORD *)(v4 + 160);
    v5 = *(_DWORD *)(40 * (**(int (__thiscall ***)(_DWORD))a2)(a2) + *(_DWORD *)(*(_DWORD *)(v7 + 12) + 72) + 32)
       + 36 * *(_DWORD *)(a2 + 40);
    --*(_DWORD *)(v5 + 16);
    v4 = v7;
  }
  sub_1002B91D((LPCRITICAL_SECTION)(v4 + 32));
  sub_1004CA81(v3 + 12, a2);
  sub_1002BB52((LPCRITICAL_SECTION)(v4 + 32));
  *(_DWORD *)a2 = off_10065138;
  return sub_1002A4AA((LPVOID)a2);
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10065138: using guessed type int (*off_10065138[2])();

//----- (1004C518) --------------------------------------------------------
#error "1004C57C: call analysis failed (funcsize=35)"

//----- (1004C584) --------------------------------------------------------
int __thiscall sub_1004C584(void *this)
{
  void *v2; // esi@1

  v2 = this;
  sub_1004C1AD(this);
  return (*(int (__thiscall **)(_DWORD))(*(_DWORD *)v2 + 36))(v2);
}

//----- (1004C594) --------------------------------------------------------
LPVOID __thiscall sub_1004C594(int this)
{
  LPVOID v1; // eax@1
  LPVOID v2; // esi@1

  v2 = 0;
  v1 = TlsGetValue(*(_DWORD *)(*(_DWORD *)(this + 12) + 112));
  if ( v1 )
  {
    if ( !((_BYTE)v1 & 3) )
      v2 = v1;
  }
  return v2;
}

//----- (1004C5B1) --------------------------------------------------------
int __userpurge sub_1004C5B1<eax>(int a1<ecx>, int a2<ebx>, int a3)
{
  int ebp0; // ebp@0
  int v4; // esi@1
  int v6; // esi@3

  v4 = a1;
  if ( !*(_DWORD *)(a1 + 4) )
    *(_DWORD *)(a1 + 4) = sub_1004CFBF(a2, ebp0);
  v6 = (***(int (__stdcall ****)(_DWORD, _DWORD))(v4 + 4))(*(_DWORD *)(v4 + 148), *(_DWORD *)(v4 + 152));
  sub_10053FDD(v6, a3);
  return v6;
}

//----- (1004C5F1) --------------------------------------------------------
int __userpurge sub_1004C5F1<eax>(int a1<ebp>, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // eax@2
  int v7; // esi@2

  sub_10035648();
  v4 = v3;
  v5 = *(_DWORD *)(a1 + 8);
  if ( *(_DWORD *)(v5 + 20) != v3 )
  {
    v6 = sub_1002ADB1(v2, v3, v3, v5, 60);
    *(_DWORD *)(a1 + 8) = v6;
    v7 = 0;
    *(_DWORD *)(a1 - 4) = 0;
    if ( v6 )
      v7 = sub_1004B3E9(v6, v4, v5);
    *(_DWORD *)(a1 - 4) = -1;
    sub_1004B4CD(v7);
  }
  return sub_10035616(0);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1004C63F) --------------------------------------------------------
int __thiscall sub_1004C63F(int this, unsigned int a2, int a3, char a4)
{
  __int64 v4; // qcx@1
  int ebp0; // ebp@0
  int v6; // esi@1
  int v7; // eax@2
  unsigned int v8; // edx@2
  bool v9; // ecx@2
  int v10; // edi@4
  unsigned int v11; // eax@14
  int v12; // edx@15
  signed __int64 v14; // qax@18
  unsigned int v15; // eax@20
  int v16; // edx@20
  char v17; // cl@20
  unsigned int v18; // edi@20
  int v19; // edx@26
  int v20; // edi@30
  char v21; // al@34
  char v22; // dl@35
  int v23; // eax@41
  int v24; // edi@41
  int v25; // eax@53
  int v27; // [sp+Ch] [bp-40h]@30
  int i; // [sp+10h] [bp-3Ch]@20
  int v29; // [sp+14h] [bp-38h]@10
  unsigned int v30; // [sp+18h] [bp-34h]@24
  int v31; // [sp+1Ch] [bp-30h]@20
  bool v32; // [sp+20h] [bp-2Ch]@4
  int v33; // [sp+24h] [bp-28h]@18
  int v34; // [sp+28h] [bp-24h]@13
  int j; // [sp+2Ch] [bp-20h]@26
  int v36; // [sp+30h] [bp-1Ch]@27
  int v37; // [sp+34h] [bp-18h]@11
  unsigned int v38; // [sp+38h] [bp-14h]@1
  int v39; // [sp+3Ch] [bp-10h]@10
  int v40; // [sp+40h] [bp-Ch]@10
  unsigned int v41; // [sp+44h] [bp-8h]@21
  char v42; // [sp+49h] [bp-3h]@5
  char v43; // [sp+4Ah] [bp-2h]@8
  char v44; // [sp+4Bh] [bp-1h]@20

  HIDWORD(v4) = 0;
  v6 = this;
  v38 = 0;
  if ( a4 )
  {
    v7 = sub_1003DDC2(this);
    v8 = a2;
    v9 = *(_DWORD *)(v6 + 184) + v7 < a2 + *(_DWORD *)(v6 + 160);
  }
  else
  {
    v8 = a2;
    v9 = 0;
  }
  v10 = v9 < v8 ? v8 - v9 : 0;
  v32 = v9;
  if ( !v9 || (v42 = 1, v8) )
    v42 = 0;
  if ( !a4 || (v43 = 1, v9) )
    v43 = 0;
  v29 = -1;
  v39 = -1;
  v40 = 0;
  if ( a4 )
    v37 = sub_1003D48E(*(_DWORD *)(v6 + 12), v6, 0);
  else
    v37 = -1;
  v34 = 0;
  if ( v10
    && ((v11 = *(_DWORD *)(v6 + 164), v10 > v11) ? (v12 = *(_DWORD *)(v6 + 164) * *(_DWORD *)(v6 + 144)
                                                        + (*(_DWORD *)(v6 + 144) - 1) * (v10 - v11)) : (v12 = v10 * *(_DWORD *)(v6 + 144)),
        v34 = v12,
        v12) )
  {
    _ECX = 0;
    v14 = 4i64 * (unsigned int)v12;
    __asm { seto    cl }
    v4 = (_DWORD)v14 | (unsigned int)-_ECX;
    v33 = sub_1002965B(SHIDWORD(v14), v4, SHIDWORD(v4), v10, v4);
  }
  else
  {
    v33 = 0;
  }
  v15 = a2;
  v17 = a4 == 0;
  v31 = 0;
  v44 = a4 == 0;
  v18 = 0;
  v16 = 0;
  for ( i = 0; ; i = v16 )
  {
    v41 = v18;
    if ( v38 >= v15 )
    {
      if ( v17 )
        break;
    }
    if ( v18 >= *(_DWORD *)(v6 + 192) )
      break;
    LODWORD(v4) = v16 + *(_DWORD *)(v6 + 16);
    v30 = v4;
    if ( *(_DWORD *)(v4 + 24) > HIDWORD(v4) || *(_DWORD *)(v4 + 28) > HIDWORD(v4) )
    {
      v19 = HIDWORD(v4);
      for ( j = HIDWORD(v4); ; j += 52 )
      {
        v36 = v19;
        if ( v38 >= v15 && v44 || (unsigned int)v19 >= *(_DWORD *)(v4 + 4) )
        {
          v16 = i;
          *(_DWORD *)(v4 + 24) = HIDWORD(v4);
          goto LABEL_64;
        }
        v20 = j + *(_DWORD *)(v4 + 48);
        v27 = v20;
        if ( *(_DWORD *)v20 == 3 )
          break;
        if ( *(_DWORD *)v20 != 4 )
          goto LABEL_49;
        if ( v43 )
        {
          v25 = *(_DWORD *)(v20 + 36) + *(_DWORD *)(v20 + 44);
          if ( v25 < (unsigned int)v29 || v25 == v29 && v41 == v37 )
          {
            v29 = *(_DWORD *)(v20 + 36) + *(_DWORD *)(v20 + 44);
            v40 = v4;
            v39 = v19;
          }
          goto LABEL_48;
        }
        if ( !v42 || *(_DWORD *)(v20 + 40) > HIDWORD(v4) )
          goto LABEL_49;
        v18 = v41;
        if ( !v40 || v41 == v37 )
        {
          v15 = a2;
          v40 = v4;
          v39 = v19;
          if ( v41 == v37 )
            v44 = 1;
        }
LABEL_50:
        ++v19;
      }
      if ( v44 || v38 != v15 - 1 && v37 != v41 )
      {
        v21 = BYTE4(v4);
      }
      else
      {
        v21 = 1;
        if ( v32 )
        {
          v22 = BYTE4(v4);
LABEL_38:
          *(_DWORD *)v20 = 4;
          ++*(_DWORD *)(v4 + 28);
          ++*(_DWORD *)(v6 + 160);
          if ( v21 )
          {
            v40 = v4;
            v39 = v36;
            v44 = 1;
          }
          if ( v22 )
          {
            v23 = *(_DWORD *)(v6 + 164);
            v24 = *(_DWORD *)(v6 + 144);
            if ( v23 )
              *(_DWORD *)(v6 + 164) = v23 - 1;
            else
              --v24;
            *(_DWORD *)(v27 + 36) += v24;
            *(_DWORD *)(v6 + 176) += v24;
            if ( v24 )
            {
              do
              {
                *(_DWORD *)(v33 + 4 * v31++) = (*(int (__thiscall **)(int, unsigned int, int))(*(_DWORD *)v6 + 24))(
                                                 v6,
                                                 v30,
                                                 v36);
                --v24;
              }
              while ( v24 );
              v4 = v30;
            }
          }
          ++v38;
          v19 = v36;
LABEL_48:
          v15 = a2;
LABEL_49:
          v18 = v41;
          goto LABEL_50;
        }
      }
      v22 = 1;
      goto LABEL_38;
    }
LABEL_64:
    v17 = v44;
    ++v18;
    v16 += 52;
  }
  if ( v34 )
  {
    sub_1004C056(v33, v34);
    sub_100303A3((LPVOID)v33);
  }
  if ( a4 )
  {
    if ( !v43 )
    {
      if ( v42 )
      {
        sub_1004CAB7(ebp0, v40, v39);
        *(_DWORD *)(52 * v39 + *(_DWORD *)(v40 + 48)) = 4;
        ++*(_DWORD *)(v40 + 28);
        ++*(_DWORD *)(v6 + 160);
      }
    }
    HIDWORD(v4) = sub_1004C269(v40, ebp0, v40, v39);
  }
  return HIDWORD(v4);
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);
// 1004C056: using guessed type _DWORD __stdcall sub_1004C056(_DWORD, _DWORD);

//----- (1004C91D) --------------------------------------------------------
int __thiscall sub_1004C91D(int this, int a2)
{
  int result; // eax@1
  int v3; // edi@1
  int v11; // ecx@2

  v3 = this;
  _ECX = *(_DWORD *)(52 * (**(int (__thiscall ***)(_DWORD))a2)(a2) + *(_DWORD *)(this + 16) + 48)
       + 52 * *(_DWORD *)(a2 + 40)
       + 24;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  result = _EAX + 1;
  if ( result == 1 )
  {
    v11 = *(_DWORD *)(v3 + 12);
    result = *(_DWORD *)(v3 + 132) == *(_DWORD *)(v3 + 128);
    if ( *(_DWORD *)(v11 + 16) > (unsigned int)result )
      result = SetEvent(*(HANDLE *)(v11 + 80));
  }
  return result;
}

//----- (1004C979) --------------------------------------------------------
int __thiscall sub_1004C979(int this, int a2, int a3, char a4)
{
  int result; // eax@1
  int v5; // edx@1
  int v6; // ebx@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // ecx@1
  int v10; // [sp+14h] [bp+8h]@1

  v5 = 52 * a3;
  v6 = 52 * a2;
  v8 = this;
  v10 = 52 * a3;
  v7 = 52 * a3 + *(_DWORD *)(*(_DWORD *)(this + 16) + v6 + 48);
  v9 = *(_DWORD *)(v7 + 40);
  result = v9 + 1;
  *(_DWORD *)(v7 + 40) = v9 + 1;
  if ( v9 )
    goto LABEL_7;
  result = v6 + *(_DWORD *)(v8 + 16);
  ++*(_DWORD *)(result + 36);
  ++*(_DWORD *)(v8 + 172);
  if ( *(_BYTE *)(v7 + 49) )
  {
    *(_BYTE *)(v7 + 50) = 1;
    result = sub_1004CC9B(v8, result, a3);
    v5 = v10;
  }
  if ( a4 )
  {
    result = *(_DWORD *)(*(_DWORD *)(v8 + 16) + v6 + 48);
    if ( !*(_DWORD *)(result + v5 + 36) )
      ++*(_DWORD *)(v8 + 184);
LABEL_7:
    if ( a4 )
    {
      ++*(_DWORD *)(v8 + 180);
      ++*(_DWORD *)(v7 + 44);
    }
  }
  return result;
}

//----- (1004C9FB) --------------------------------------------------------
int __usercall sub_1004C9FB<eax>(int a1<ecx>, int a2<ebp>)
{
  LPVOID v2; // eax@1
  int v3; // esi@1
  int v4; // eax@2
  int v5; // eax@4
  int v6; // eax@7
  int v7; // edi@7
  int v8; // esi@7
  int v9; // esi@7

  v2 = TlsGetValue(*(_DWORD *)(*(_DWORD *)(a1 + 12) + 112));
  v3 = (int)v2;
  if ( !v2 )
    return 0;
  v4 = (_BYTE)v2 & 3;
  if ( !v4 )
  {
LABEL_6:
    sub_1004B4CD(v3);
    goto LABEL_12;
  }
  if ( v4 == 1 )
  {
    v3 = *(_DWORD *)((v3 & 0xFFFFFFFE) + 0x10) + 8;
    v5 = *(_DWORD *)(v3 + 28);
    if ( v5 && *(_BYTE *)(v5 + 68) )
      return 0;
    goto LABEL_6;
  }
  v8 = v3 & 0xFFFFFFFD;
  v7 = v8 + 4;
  (*(void (__thiscall **)(int))(*(_DWORD *)(v8 + 4) + 16))(v8 + 4);
  v9 = *(_DWORD *)(v8 + 32);
  v6 = *(_DWORD *)(v9 + 44);
  v3 = v9 + 16;
  if ( v6 && *(_BYTE *)(v6 + 68) )
    v3 = 0;
  else
    sub_1004B4CD(v3);
  (*(void (__thiscall **)(int))(*(_DWORD *)v7 + 20))(v7);
LABEL_12:
  if ( v3 )
    return sub_1004C5F1(a2, v3);
  return 0;
}

//----- (1004CA81) --------------------------------------------------------
int __thiscall sub_1004CA81(int this, int a2)
{
  int result; // eax@1

  --*(_DWORD *)this;
  *(_DWORD *)(*(_DWORD *)(a2 + 56) + 52) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(*(_DWORD *)(a2 + 52) + 56) = *(_DWORD *)(a2 + 56);
  result = *(_DWORD *)(this + 4);
  if ( a2 == result )
  {
    if ( result == *(_DWORD *)(result + 56) )
      result = 0;
    else
      result = *(_DWORD *)(result + 52);
    *(_DWORD *)(this + 4) = result;
  }
  return result;
}

//----- (1004CAB7) --------------------------------------------------------
int __userpurge sub_1004CAB7<eax>(int a1<ebp>, int a2, int a3)
{
  int v3; // ecx@1
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // ecx@1
  int v7; // edi@1
  int v8; // eax@1
  int v9; // eax@5
  int v10; // eax@6
  int v11; // ecx@12
  int v13; // [sp-Ch] [bp-Ch]@16
  signed int v14; // [sp-4h] [bp-4h]@1

  v14 = 4;
  sub_10035648();
  v4 = v6;
  v3 = *(_DWORD *)(a1 + 8);
  v7 = 52 * *(_DWORD *)(a1 + 12);
  --*(_DWORD *)(v3 + 28);
  --*(_DWORD *)(v4 + 160);
  v5 = *(_DWORD *)(v3 + 48) + v7;
  v8 = *(_DWORD *)(v5 + 36);
  *(_DWORD *)v5 = 1;
  if ( v8 == *(_DWORD *)(v4 + 144) )
    ++*(_DWORD *)(v4 + 164);
  *(_DWORD *)(v4 + 176) -= *(_DWORD *)(v5 + 36);
  *(_DWORD *)(v5 + 36) = 0;
  if ( *(_BYTE *)(v5 + 49) )
    sub_1004CC9B(v4, v3, *(_DWORD *)(a1 + 12));
  *(_BYTE *)(v5 + 48) = 0;
  *(_DWORD *)(a1 - 16) = v4 + 32;
  sub_1002B91D((LPCRITICAL_SECTION)(v4 + 32));
  v9 = *(_DWORD *)(v5 + 16);
  *(_DWORD *)(a1 - 4) = 0;
  if ( v9 )
    v10 = *(_DWORD *)(v9 + 56);
  else
    v10 = 0;
  for ( ; v10; v10 = *(_DWORD *)(a1 + 12) )
  {
    if ( v10 == *(_DWORD *)(v5 + 16) )
      *(_DWORD *)(a1 + 12) = 0;
    else
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(v10 + 56);
    v11 = *(_DWORD *)(v10 + 28);
    if ( v11 )
    {
      if ( !*(_BYTE *)(v11 + 68) )
      {
        *(_BYTE *)(v11 + 68) = 1;
        *(_DWORD *)(a1 + 8) = v11;
        (*(void (__cdecl **)(int, signed int, signed int))(**(_DWORD **)(v4 + 8) + 16))(a1 + 8, 1, v14);
      }
    }
  }
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002BB52((LPCRITICAL_SECTION)(v4 + 32));
  return sub_10035616(v13);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1004CB86) --------------------------------------------------------
int __thiscall sub_1004CB86(void *this, void *a2)
{
  int result; // eax@1

  result = sub_1004CA81((int)((char *)this + 196), (int)a2);
  if ( a2 )
  {
    *(_DWORD *)a2 = off_10065138;
    result = sub_1002A4AA(a2);
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10065138: using guessed type int (*off_10065138[2])();

//----- (1004CBAF) --------------------------------------------------------
int __thiscall sub_1004CBAF(int this, int a2)
{
  int ebp0; // ebp@0

  return sub_1003EAF4(ebp0, this, a2);
}

//----- (1004CBC2) --------------------------------------------------------
#error "1004CC7F: call analysis failed (funcsize=77)"

//----- (1004CC87) --------------------------------------------------------
int __thiscall sub_1004CC87(int this)
{
  return sub_1003F3BF(*(_DWORD *)(this + 12), this);
}

//----- (1004CC91) --------------------------------------------------------
int __usercall sub_1004CC91<eax>(int a1<ecx>, int a2<ebp>)
{
  return sub_1003F478(a2, a1);
}

//----- (1004CC9B) --------------------------------------------------------
int __thiscall sub_1004CC9B(int this, int a2, int a3)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 + 48) + 52 * a3;
  if ( *(_BYTE *)(result + 49) )
  {
    --*(_DWORD *)(this + 168);
    --*(_DWORD *)(a2 + 32);
    *(_BYTE *)(result + 49) = 0;
  }
  else
  {
    ++*(_DWORD *)(this + 168);
    ++*(_DWORD *)(a2 + 32);
    *(_BYTE *)(result + 49) = 1;
  }
  return result;
}

//----- (1004CCD0) --------------------------------------------------------
int __stdcall sub_1004CCD0(int a1)
{
  int v2; // eax@2
  int (__stdcall **v3)(char); // [sp+0h] [bp-Ch]@3

  if ( !a1 )
  {
    a1 = (int)"pContext";
    sub_1002AEA4((int)&v3, &a1);
    v3 = &off_1005F2EC;
    sub_100355BB((int)&v3, (int)&unk_1006C8B4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1004CD16);
  }
  v2 = (*(int (**)(void))(*(_DWORD *)a1 + 8))();
  return sub_1005406C(v2);
}
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);

//----- (1004CD16) --------------------------------------------------------
int __cdecl sub_1004CD16(int a1)
{
  int v1; // eax@2
  int v2; // eax@4
  HMODULE v3; // eax@4
  int v4; // eax@7
  HMODULE v5; // eax@7
  int result; // eax@8
  int v7; // eax@10
  int v8; // ST04_4@10
  int *v9; // [sp+0h] [bp-18h]@10
  int v10; // [sp+4h] [bp-14h]@10
  char v11; // [sp+8h] [bp-10h]@10
  int v12; // [sp+Ch] [bp-Ch]@10
  int v13; // [sp+10h] [bp-8h]@10
  int v14; // [sp+14h] [bp-4h]@10
  int v15; // [sp+18h] [bp+0h]@10

  dword_100761B8 = (int)LoadLibraryExW(L"combase.dll", 0, 0x800u);
  if ( dword_100761B8 )
  {
    v3 = GetModuleHandleW(L"combase.dll");
    v2 = (int)GetProcAddress(v3, "RoInitialize");
    if ( v2 )
    {
      dword_100761B0 = sub_100348F9(v2);
      v5 = GetModuleHandleW(L"combase.dll");
      v4 = (int)GetProcAddress(v5, "RoUninitialize");
      if ( v4 )
      {
        dword_100761B4 = sub_100348F9(v4);
        result = unk_100761BC;
        unk_100761BC = 1;
        return result;
      }
    }
    v1 = GetLastError();
    if ( v1 > 0 )
      goto LABEL_9;
  }
  else
  {
    v1 = GetLastError();
    if ( v1 > 0 )
    {
LABEL_9:
      v1 = (unsigned __int16)v1 | 0x80070000;
      goto LABEL_10;
    }
  }
LABEL_10:
  sub_10030079((int)&v11, v1);
  sub_100355BB((int)&v11, (int)&unk_1006B6E0);
  __asm { int     3               ; Trap to Debugger }
  v9 = &v15;
  v7 = sub_100348F9(dword_100761B0);
  return ((int (__thiscall *)(int, int, int *, int, _DWORD, int, int, int))v7)(
           v8,
           a1,
           v9,
           v10,
           *(_DWORD *)&v11,
           v12,
           v13,
           v14);
}
// 100761B0: using guessed type int dword_100761B0;
// 100761B4: using guessed type int dword_100761B4;
// 100761B8: using guessed type int dword_100761B8;

//----- (1004CDDB) --------------------------------------------------------
int __cdecl sub_1004CDDB()
{
  int v1; // eax@1
  int v2; // ST00_4@1

  v1 = sub_100348F9(dword_100761B4);
  return ((int (__thiscall *)(int))v1)(v2);
}
// 100761B4: using guessed type int dword_100761B4;

//----- (1004CDE9) --------------------------------------------------------
int __thiscall sub_1004CDE9(int this, int a2)
{
  signed int v2; // ebx@1
  int v3; // edi@1
  union _SLIST_HEADER *v4; // esi@1

  v3 = this;
  *(_DWORD *)this = &off_10065228;
  *(_DWORD *)(this + 4) = *(_DWORD *)(a2 + 8);
  v4 = (union _SLIST_HEADER *)(this + 8);
  v2 = 3;
  do
  {
    InitializeSListHead(v4);
    ++v4;
    --v2;
  }
  while ( v2 >= 0 );
  return v3;
}
// 10065228: using guessed type int (__stdcall *off_10065228)(int, int);

//----- (1004CE1C) --------------------------------------------------------
void *__thiscall sub_1004CE1C(void *this, int a2, int a3)
{
  void *v4; // esi@1

  v4 = this;
  sub_100545B3(this, a2, a3);
  *(_DWORD *)v4 = &off_100651E0;
  *((_DWORD *)v4 + 12) = 0;
  *((_DWORD *)v4 + 13) = 0;
  *((_DWORD *)v4 + 14) = 0;
  *((_DWORD *)v4 + 12) = 0;
  *((_WORD *)v4 + 26) = 0;
  return v4;
}
// 100651E0: using guessed type int (*off_100651E0)();

//----- (1004CE4D) --------------------------------------------------------
int __thiscall sub_1004CE4D(int this, int a2)
{
  int v3; // esi@1

  v3 = this;
  sub_1004CDE9(this, a2);
  *(_DWORD *)v3 = &off_10065254;
  *(_DWORD *)(v3 + 40) = 1;
  *(_BYTE *)(v3 + 44) = 0;
  return v3;
}
// 10065254: using guessed type int (__stdcall *off_10065254)(int, int);

//----- (1004CE73) --------------------------------------------------------
int __usercall sub_1004CE73<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int v2; // esi@1
  DWORD v3; // eax@1
  int v4; // eax@2

  sub_10035648();
  v2 = v1;
  *(_DWORD *)(a1 - 16) = v1;
  *(_DWORD *)v1 = 0;
  *(_DWORD *)(v1 + 4) = 0;
  sub_1002B4FD((LPCRITICAL_SECTION)(v1 + 12));
  *(_DWORD *)(a1 - 4) = 0;
  v3 = TlsAlloc();
  *(_DWORD *)(v2 + 8) = v3;
  if ( v3 == -1 )
  {
    v4 = GetLastError();
    if ( v4 > 0 )
      v4 = (unsigned __int16)v4 | 0x80070000;
    sub_10030079(a1 - 32, v4);
    sub_100355BB(a1 - 32, (int)&unk_1006B6E0);
  }
  return sub_10035616(20);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1004CED6) --------------------------------------------------------
int __usercall sub_1004CED6<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int v2; // esi@1
  int v3; // ecx@1
  int v4; // ecx@3
  signed int v6; // [sp-4h] [bp-4h]@1

  v6 = 4;
  sub_10035648();
  v2 = v3;
  *(_DWORD *)(a1 - 16) = v3;
  v1 = *(_DWORD *)v3;
  *(_DWORD *)(a1 - 4) = 0;
  if ( v1 )
    (*(void (__cdecl **)(signed int))(*(_DWORD *)v1 + 24))(4);
  v4 = *(_DWORD *)(v2 + 4);
  if ( v4 )
    (*(void (__cdecl **)(signed int))(*(_DWORD *)v4 + 24))(v6);
  TlsFree(*(_DWORD *)(v2 + 8));
  *(_DWORD *)(a1 - 4) = -1;
  sub_1002B6CE((LPCRITICAL_SECTION)(v2 + 12));
  return sub_10035616(v6);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1004CF1D) --------------------------------------------------------
void *__thiscall sub_1004CF1D(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = &off_100651E0;
  sub_100546B3((int)this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100651E0: using guessed type int (*off_100651E0)();

//----- (1004CF42) --------------------------------------------------------
void *__thiscall sub_1004CF42(void *this, char a2)
{
  void *v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_100651FC;
  if ( a2 & 1 )
    sub_1002A4AA(this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100651FC: using guessed type int (*off_100651FC[5])();

//----- (1004CF62) --------------------------------------------------------
int __userpurge sub_1004CF62<eax>(int a1<ebx>, int a2<ebp>, int a3<edi>, int a4)
{
  int v4; // ecx@1
  int v5; // esi@1
  int v6; // ecx@1
  int v7; // edx@1

  sub_10035648();
  v5 = v6;
  v4 = sub_1002ADB1(v7, v6, a1, a3, 68);
  *(_DWORD *)(a2 - 16) = v4;
  *(_DWORD *)(a2 - 4) = 0;
  if ( v4 )
    sub_1004CE1C((void *)v4, v5, *(_DWORD *)(a2 + 8));
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1004CF97) --------------------------------------------------------
int __usercall sub_1004CF97<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // eax@1
  int v4; // edx@1
  int v5; // ecx@1
  int result; // eax@2

  sub_1004D216();
  v3 = sub_1002ADB1(v4, v5, a1, a2, 48);
  if ( v3 )
    result = sub_1004CE4D(v3, a3);
  else
    result = 0;
  return result;
}

//----- (1004CFBB) --------------------------------------------------------
int __thiscall sub_1004CFBB(int this)
{
  return *(_DWORD *)(this + 4);
}

//----- (1004CFBF) --------------------------------------------------------
int __usercall sub_1004CFBF<eax>(int a1<ebx>, int a2<ebp>)
{
  int v2; // ecx@1
  int v3; // edi@1

  sub_10035648();
  v3 = v2;
  if ( !*(_DWORD *)v2 )
  {
    *(_DWORD *)(a2 - 16) = v2 + 12;
    sub_1002B91D((LPCRITICAL_SECTION)(v2 + 12));
    *(_DWORD *)(a2 - 4) = 0;
    if ( !*(_DWORD *)v3 )
      *(_DWORD *)v3 = sub_1004CF97(a1, v3, v3);
    *(_DWORD *)(a2 - 4) = -1;
    sub_1002BB52((LPCRITICAL_SECTION)(v3 + 12));
  }
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);

//----- (1004D004) --------------------------------------------------------
BOOL __stdcall sub_1004D004(int a1, int nPriority)
{
  BOOL result; // eax@1

  result = nPriority;
  if ( *(_DWORD *)(a1 + 24) != nPriority )
    result = sub_10054715(a1, nPriority);
  return result;
}

//----- (1004D01C) --------------------------------------------------------
__int16 __thiscall sub_1004D01C(void *this, int a2)
{
  signed int v2; // eax@1
  void *v3; // edi@1
  int v4; // esi@1
  union _SLIST_HEADER *v5; // ebx@5

  v4 = a2;
  v3 = this;
  v2 = 0;
  while ( *(_DWORD *)(a2 + 20) != dword_10065214[v2] )
  {
    ++v2;
    if ( v2 >= 4 )
      goto LABEL_7;
  }
  v5 = (union _SLIST_HEADER *)(this + 8 * v2 + 8);
  LOWORD(v2) = QueryDepthSList((PSLIST_HEADER)this + v2 + 1);
  if ( (unsigned __int16)v2 < dword_100761C4 )
  {
    LOWORD(v2) = (unsigned int)InterlockedPushEntrySList(v5, (PSINGLE_LIST_ENTRY)(a2 + 60));
    v4 = 0;
  }
LABEL_7:
  if ( v4 )
    LOWORD(v2) = (*(int (__thiscall **)(void *, int))(*(_DWORD *)v3 + 32))(v3, v4);
  return v2;
}
// 10065214: using guessed type int dword_10065214[];
// 100761C4: using guessed type int dword_100761C4;

//----- (1004D075) --------------------------------------------------------
void __thiscall sub_1004D075(int this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  signed int v4; // eax@2
  union _SLIST_HEADER *v5; // ebx@6
  int v6; // edx@8
  PSINGLE_LIST_ENTRY v7; // eax@8
  int v8; // esi@9

  v3 = a2;
  v2 = this;
  if ( !*(_BYTE *)(this + 44) )
  {
    v4 = 0;
    while ( *(_DWORD *)(a2 + 20) != dword_10065214[v4] )
    {
      ++v4;
      if ( v4 >= 4 )
        goto LABEL_11;
    }
    v5 = (union _SLIST_HEADER *)(this + 8 + 8 * v4);
    if ( QueryDepthSList((PSLIST_HEADER)(this + 8 + 8 * v4)) < dword_100761C4 )
    {
      InterlockedPushEntrySList(v5, (PSINGLE_LIST_ENTRY)(a2 + 60));
      if ( *(_BYTE *)(v2 + 44) )
      {
        v7 = InterlockedFlushSList(v5);
        v6 = v7 != 0 ? (int)&v7[-15] : 0;
        if ( v7 != 0 ? (int)&v7[-15] : 0 )
        {
          do
          {
            v8 = *(_DWORD *)(v6 + 60);
            (*(void (__thiscall **)(int, int))(*(_DWORD *)v2 + 32))(v2, v6);
            v6 = v8 != 0 ? v8 - 60 : 0;
          }
          while ( v8 != 0 ? v8 - 60 : 0 );
        }
      }
      v3 = 0;
    }
  }
LABEL_11:
  if ( v3 )
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v2 + 32))(v2, v3);
}
// 10065214: using guessed type int dword_10065214[];
// 100761C4: using guessed type int dword_100761C4;

//----- (1004D106) --------------------------------------------------------
int __thiscall sub_1004D106(void *this)
{
  _ECX = (int)((char *)this + 40);
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  return _EAX + 1;
}

//----- (1004D112) --------------------------------------------------------
int __thiscall sub_1004D112(void *this)
{
  int v1; // esi@1

  _EAX = (int)((char *)this + 40);
  _ESI = -1;
  __asm { lock xadd [eax], esi }
  v1 = _ESI - 1;
  if ( !v1 )
  {
    if ( this )
      (*(void (__stdcall **)(signed int))(*(_DWORD *)this + 20))(1);
  }
  return v1;
}

//----- (1004D12F) --------------------------------------------------------
int __thiscall sub_1004D12F(void *this, unsigned int a2, int a3)
{
  union _SLIST_HEADER *v3; // eax@1
  unsigned int v4; // ecx@1
  signed int v5; // ebx@1
  void *v6; // edi@1
  int v7; // esi@1
  PSINGLE_LIST_ENTRY v8; // eax@3
  int v10; // [sp+Ch] [bp-4h]@1

  v6 = this;
  v4 = a2;
  v3 = (union _SLIST_HEADER *)((char *)v6 + 8);
  v7 = 0;
  v5 = (signed int)dword_10065214;
  v10 = (int)((char *)v6 + 8);
  do
  {
    if ( v4 <= *(_DWORD *)v5 )
    {
      v8 = InterlockedPopEntrySList(v3);
      v7 = v8 != 0 ? (int)&v8[-15] : 0;
      if ( v7 )
        goto LABEL_8;
      v3 = (union _SLIST_HEADER *)v10;
      v4 = a2;
    }
    v5 += 4;
    ++v3;
    v10 = (int)v3;
  }
  while ( v5 < (signed int)&off_10065224 );
  if ( v7 || (v7 = (*(int (__thiscall **)(void *, unsigned int))(*(_DWORD *)v6 + 28))(v6, v4)) != 0 )
LABEL_8:
    (*(void (__thiscall **)(void *, int, int))(*(_DWORD *)v6 + 36))(v6, v7, a3);
  return v7;
}
// 10065214: using guessed type int dword_10065214[];
// 10065224: using guessed type void *off_10065224;

//----- (1004D19D) --------------------------------------------------------
BOOL __stdcall sub_1004D19D(int a1)
{
  return sub_100546F6(a1);
}

//----- (1004D1AC) --------------------------------------------------------
PSINGLE_LIST_ENTRY __thiscall sub_1004D1AC(void *this)
{
  signed int v1; // ebx@1
  union _SLIST_HEADER *v2; // edi@1
  PSINGLE_LIST_ENTRY result; // eax@2
  int v4; // edx@2
  int v5; // esi@3
  void *v6; // [sp+Ch] [bp-8h]@1
  signed int v7; // [sp+10h] [bp-4h]@1

  v1 = 4;
  v6 = this;
  v2 = (union _SLIST_HEADER *)((char *)this + 8);
  v7 = 4;
  do
  {
    result = InterlockedFlushSList(v2);
    v4 = result != 0 ? (int)&result[-15] : 0;
    if ( result != 0 ? (int)&result[-15] : 0 )
    {
      do
      {
        v5 = *(_DWORD *)(v4 + 60);
        (*(void (__thiscall **)(void *, int))(*(_DWORD *)v6 + 32))(v6, v4);
        result = (PSINGLE_LIST_ENTRY)(v5 - 60);
        v4 = v5 != 0 ? v5 - 60 : 0;
      }
      while ( v5 != 0 ? v5 - 60 : 0 );
      v1 = v7;
    }
    ++v2;
    --v1;
    v7 = v1;
  }
  while ( v1 );
  return result;
}

//----- (1004D202) --------------------------------------------------------
int __thiscall sub_1004D202(int this)
{
  int v2; // esi@1

  v2 = this;
  *(_BYTE *)(this + 44) = 1;
  sub_1004D1AC((void *)this);
  return (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 12))(v2);
}

//----- (1004D216) --------------------------------------------------------
void __cdecl sub_1004D216()
{
  if ( !dword_100761C4 )
    dword_100761C4 = 4 * sub_1003D68A();
}
// 100761C4: using guessed type int dword_100761C4;

//----- (1004D276) --------------------------------------------------------
int __usercall sub_1004D276<eax>(double a1<st0>)
{
  int result; // eax@1
  float v2; // edx@1
  float v3; // ST18_4@1
  double v4; // st7@2
  float v5; // ST00_4@3
  float v6; // ST00_4@4
  signed __int64 v7; // [sp+10h] [bp-10h]@1

  v3 = a1;
  v7 = (signed __int64)a1;
  v2 = v3;
  result = (signed __int64)a1;
  if ( result || (LODWORD(v2) = HIDWORD(v7), HIDWORD(v7) & 0x7FFFFFFF) )
  {
    v4 = a1 - (double)(signed __int64)a1;
    if ( LODWORD(v2) >= 0 )
    {
      v6 = v4;
      result -= LODWORD(v6) >= 0x80000001u;
    }
    else
    {
      v5 = v4;
      result += (LODWORD(v5) ^ 0x80000000u) >= 0x80000001;
    }
  }
  return result;
}

//----- (1004D2F0) --------------------------------------------------------
int __usercall sub_1004D2F0<eax>(unsigned int a1<eax>, int a2<ecx>)
{
  unsigned int i; // eax@1
  int v3; // ecx@1
  int v5; // [sp-4h] [bp-4h]@1
  void *v6; // [sp+0h] [bp+0h]@1
  int v7; // [sp+0h] [bp+0h]@3

  v5 = a2;
  v3 = (unsigned int)&v6 >= a1 ? (int)((char *)&v6 - a1) : 0;
  for ( i = (unsigned int)&v5 & 0xFFFFF000; v3 < i; i -= 4096 )
    ;
  return v7;
}

//----- (1004D31B) --------------------------------------------------------
signed int __usercall sub_1004D31B<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5, int a6)
{
  int v6; // ecx@2
  int v7; // edx@3
  int v8; // eax@5
  signed int result; // eax@6
  int v10; // esi@8
  int v11; // esi@12
  __int16 v12; // ax@13
  signed int v13; // [sp-4h] [bp-Ch]@5

  if ( !a4 || (v6 = a5, !a5) )
    goto LABEL_5;
  v7 = a6;
  if ( !a6 )
    goto LABEL_19;
  v10 = a4;
  do
  {
    if ( !*(_WORD *)v10 )
      break;
    v10 += 2;
    --v6;
  }
  while ( v6 );
  if ( !v6 )
  {
LABEL_19:
    *(_WORD *)a4 = 0;
LABEL_5:
    v8 = sub_10037649(a3);
    v13 = 22;
LABEL_6:
    *(_DWORD *)v8 = v13;
    sub_1003A151(a3, a4);
    return v13;
  }
  v11 = v10 - a6;
  do
  {
    v12 = *(_WORD *)v7;
    *(_WORD *)(v11 + v7) = *(_WORD *)v7;
    v7 += 2;
    if ( !v12 )
      break;
    --v6;
  }
  while ( v6 );
  result = 0;
  if ( !v6 )
  {
    *(_WORD *)a4 = 0;
    v8 = sub_10037649(a3);
    v13 = 34;
    goto LABEL_6;
  }
  return result;
}

//----- (1004D387) --------------------------------------------------------
signed int __usercall sub_1004D387<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5)
{
  int v5; // ecx@4

  if ( a5 >= 0 )
  {
    if ( a5 <= 2 )
    {
      v5 = dword_100761C8;
      dword_100761C8 = a5;
      return v5;
    }
    if ( a5 == 3 )
      return dword_100761C8;
  }
  *(_DWORD *)sub_10037649(a3) = 22;
  sub_1003A151(a3, a4);
  return -1;
}
// 100761C8: using guessed type int dword_100761C8;

//----- (1004D3C7) --------------------------------------------------------
int __cdecl sub_1004D3C7(const WCHAR *a1, int a2, int a3)
{
  int v3; // edi@1
  PVOID v4; // esi@1
  int v5; // eax@1
  HMODULE v6; // esi@2
  FARPROC v7; // eax@5
  FARPROC v8; // eax@6
  FARPROC v9; // eax@6
  FARPROC v10; // eax@6
  FARPROC v11; // eax@7
  PVOID v13; // eax@19
  int v14; // eax@21
  int v15; // esi@24
  int (*v16)(void); // eax@26
  PVOID v17; // eax@29
  PVOID v18; // eax@32
  char v20; // [sp+Ch] [bp-24h]@22
  int v21; // [sp+10h] [bp-20h]@1
  LPCWSTR lpOutputString; // [sp+14h] [bp-1Ch]@1
  PVOID v23; // [sp+18h] [bp-18h]@1
  int (*v24)(void); // [sp+1Ch] [bp-14h]@1
  char v25; // [sp+20h] [bp-10h]@22
  char v26; // [sp+28h] [bp-8h]@23
  unsigned int v27; // [sp+2Ch] [bp-4h]@1
  int v28; // [sp+30h] [bp+0h]@1

  v27 = (unsigned int)&v28 ^ __security_cookie;
  lpOutputString = a1;
  v3 = 0;
  v21 = a2;
  v4 = EncodePointer(0);
  v23 = v4;
  LOBYTE(v5) = sub_1003959A();
  v24 = (int (*)(void))v5;
  if ( !dword_100761CC )
  {
    v6 = LoadLibraryExW(L"USER32.DLL", 0, 0x800u);
    if ( !v6 && (GetLastError() != 87 || (v6 = LoadLibraryW(L"USER32.DLL"), !v6))
      || (v7 = GetProcAddress(v6, "MessageBoxW"), !v7) )
      return 0;
    dword_100761CC = EncodePointer(v7);
    v8 = GetProcAddress(v6, "GetActiveWindow");
    dword_100761D0 = EncodePointer(v8);
    v9 = GetProcAddress(v6, "GetLastActivePopup");
    dword_100761D4 = EncodePointer(v9);
    v10 = GetProcAddress(v6, "GetUserObjectInformationW");
    dword_100761DC = EncodePointer(v10);
    if ( dword_100761DC )
    {
      v11 = GetProcAddress(v6, "GetProcessWindowStation");
      dword_100761D8 = EncodePointer(v11);
    }
    v4 = v23;
  }
  if ( IsDebuggerPresent() )
  {
    if ( lpOutputString )
      OutputDebugStringW(lpOutputString);
    if ( v24 )
      return 4;
  }
  else
  {
    if ( v24 )
    {
      DecodePointer(dword_100761CC);
      return 3;
    }
  }
  if ( dword_100761D8 == v4
    || dword_100761DC == v4
    || (v24 = (int (*)(void))DecodePointer(dword_100761D8), v13 = DecodePointer(dword_100761DC), v23 = v13, !v24)
    || !v13
    || (v14 = v24()) != 0
    && ((int (__stdcall *)(int, signed int, char *, signed int, char *))v23)(v14, 1, &v25, 12, &v20)
    && v26 & 1 )
  {
    if ( dword_100761D0 != v4 )
    {
      v16 = (int (*)(void))DecodePointer(dword_100761D0);
      if ( v16 )
      {
        v3 = v16();
        if ( v3 )
        {
          if ( dword_100761D4 != v4 )
          {
            v17 = DecodePointer(dword_100761D4);
            if ( v17 )
              v3 = ((int (__stdcall *)(int))v17)(v3);
          }
        }
      }
    }
    v15 = a3;
  }
  else
  {
    v15 = a3 | 0x200000;
  }
  v18 = DecodePointer(dword_100761CC);
  if ( v18 )
    return ((int (__stdcall *)(int, LPCWSTR, int, int))v18)(v3, lpOutputString, v21, v15);
  return 0;
}
// 10073200: using guessed type int __security_cookie;

//----- (1004D5A9) --------------------------------------------------------
int __usercall sub_1004D5A9<eax>(int a1<edi>, int a2, int a3, LCTYPE a4, LPSTR lpMultiByteStr, int cbMultiByte)
{
  int v6; // eax@1
  int v7; // ecx@1
  int v8; // ebx@1
  int v9; // esi@1
  unsigned int v11; // eax@5
  char *v12; // edi@6
  int v13; // eax@8
  int v14; // edi@10
  CHAR *v15; // [sp-10h] [bp-24h]@15
  int v16; // [sp-Ch] [bp-20h]@15
  char v17; // [sp+0h] [bp-14h]@6
  UINT CodePage; // [sp+Ch] [bp-8h]@1
  unsigned int v19; // [sp+10h] [bp-4h]@1
  int v20; // [sp+14h] [bp+0h]@1

  v19 = (unsigned int)&v20 ^ __security_cookie;
  v9 = 0;
  CodePage = *(_DWORD *)(*(_DWORD *)a2 + 4);
  v6 = sub_10039C8E(a3, a4, 0, 0);
  v8 = v6;
  if ( !v6 )
    return 0;
  if ( v6 > 0 && 0xFFFFFFE0u / v6 >= 2 )
  {
    v11 = 2 * v6 + 8;
    if ( v11 > 0x400 )
    {
      v13 = sub_10030930(0xFFFFFFE0u % v8, v7, v8, a1, 2 * v8 + 8);
      v12 = (char *)v13;
      if ( v13 )
      {
        *(_DWORD *)v13 = 56797;
        goto LABEL_10;
      }
    }
    else
    {
      sub_1003F580(v11, v7, v17);
      v12 = &v17;
      if ( &v17 )
      {
        *(_DWORD *)&v17 = 52428;
LABEL_10:
        v14 = (int)(v12 + 8);
        goto LABEL_12;
      }
    }
    return 0;
  }
  v14 = 0;
LABEL_12:
  if ( !v14 )
    return 0;
  if ( sub_10039C8E(a3, a4, (WCHAR *)v14, v8) )
  {
    if ( cbMultiByte )
    {
      v16 = cbMultiByte;
      v15 = lpMultiByteStr;
    }
    else
    {
      v16 = 0;
      v15 = 0;
    }
    v9 = WideCharToMultiByte(CodePage, 0, (LPCWSTR)v14, -1, v15, v16, 0, 0);
  }
  sub_1002CAA4(v8, v14);
  return v9;
}
// 10073200: using guessed type int __security_cookie;

//----- (1004D681) --------------------------------------------------------
int __usercall sub_1004D681<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, LCTYPE a5, LPSTR lpMultiByteStr, int cbMultiByte)
{
  int result; // eax@1
  int v8; // [sp+0h] [bp-10h]@1
  int v9; // [sp+8h] [bp-8h]@2
  char v10; // [sp+Ch] [bp-4h]@1

  sub_100301AD((int)&v8, a1, a2, a3);
  result = sub_1004D5A9(a2, (int)&v8, a4, a5, lpMultiByteStr, cbMultiByte);
  if ( v10 )
    *(_DWORD *)(v9 + 112) &= 0xFFFFFFFDu;
  return result;
}

//----- (1004D6B9) --------------------------------------------------------
int __thiscall sub_1004D6B9(int this, int a2, int a3, int a4, int a5)
{
  *(_DWORD *)this = a2 & 0xFFFFFFF;
  *(_DWORD *)(this + 4) = a4;
  *(_DWORD *)(this + 12) = a5;
  *(_DWORD *)(this + 8) = a3;
  return this;
}

//----- (1004D6DE) --------------------------------------------------------
bool __thiscall sub_1004D6DE(int this, char a2)
{
  int v3; // esi@1
  int v4; // eax@1

  v3 = this + 16;
  v4 = sub_1002D18F((int)&a2, *(_DWORD *)(this + 16));
  return sub_1002D1BB(v3, (int)&a2, v4) != 0;
}

//----- (1004D709) --------------------------------------------------------
char __thiscall sub_1004D709(int this, int a2)
{
  int v2; // eax@1
  int v3; // eax@2
  int v4; // eax@3
  char result; // al@5
  int v6; // eax@7

  v2 = *(_DWORD *)a2 & 0xFFFFFFF;
  if ( !v2 )
    return 1;
  v3 = v2 - 1;
  if ( !v3 )
  {
    v6 = *(_DWORD *)(*(_DWORD *)(this + 12) + 44);
    return v6 == *(_DWORD *)(a2 + 8);
  }
  v4 = v3 - 1;
  if ( !v4 )
  {
    v6 = *(_DWORD *)(this + 8);
    return v6 == *(_DWORD *)(a2 + 8);
  }
  if ( v4 == 1 )
    result = sub_1004D6DE(*(_DWORD *)(this + 12), *(_DWORD *)(a2 + 8));
  else
    result = 0;
  return result;
}

//----- (1004D750) --------------------------------------------------------
char __thiscall sub_1004D750(int this, int a2)
{
  int v2; // eax@1
  int v3; // eax@2
  int v4; // eax@3
  char result; // al@5
  int v6; // eax@6

  v2 = *(_DWORD *)a2 & 0xFFFFFFF;
  if ( v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      v4 = v3 - 1;
      if ( v4 )
      {
        if ( v4 != 1 )
          return 0;
        v6 = *(_DWORD *)(this + 8);
      }
      else
      {
        v6 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 12) + 68) + 48);
      }
    }
    else
    {
      v6 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(this + 12) + 68) + 44);
    }
    result = v6 == *(_DWORD *)(a2 + 8);
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (1004D798) --------------------------------------------------------
void __usercall sub_1004D798(int a1<ebx>, int a2)
{
  if ( a2 )
  {
    if ( *(void **)(a2 + 12) != off_10072C64 )
      sub_100309C2(a1, *(LPVOID *)(a2 + 12));
    if ( *(void **)(a2 + 16) != off_10072C68 )
      sub_100309C2(a1, *(LPVOID *)(a2 + 16));
    if ( *(void **)(a2 + 20) != off_10072C6C )
      sub_100309C2(a1, *(LPVOID *)(a2 + 20));
    if ( *(void **)(a2 + 24) != off_10072C70 )
      sub_100309C2(a1, *(LPVOID *)(a2 + 24));
    if ( *(void **)(a2 + 28) != off_10072C74 )
      sub_100309C2(a1, *(LPVOID *)(a2 + 28));
    if ( *(void **)(a2 + 32) != off_10072C78 )
      sub_100309C2(a1, *(LPVOID *)(a2 + 32));
    if ( *(void **)(a2 + 36) != off_10072C7C )
      sub_100309C2(a1, *(LPVOID *)(a2 + 36));
    if ( *(void **)(a2 + 56) != off_10072C90 )
      sub_100309C2(a1, *(LPVOID *)(a2 + 56));
    if ( *(void **)(a2 + 60) != off_10072C94 )
      sub_100309C2(a1, *(LPVOID *)(a2 + 60));
    if ( *(void **)(a2 + 64) != off_10072C98 )
      sub_100309C2(a1, *(LPVOID *)(a2 + 64));
    if ( *(void **)(a2 + 68) != off_10072C9C )
      sub_100309C2(a1, *(LPVOID *)(a2 + 68));
    if ( *(void **)(a2 + 72) != off_10072CA0 )
      sub_100309C2(a1, *(LPVOID *)(a2 + 72));
    if ( *(void **)(a2 + 76) != off_10072CA4 )
      sub_100309C2(a1, *(LPVOID *)(a2 + 76));
  }
}
// 10072C64: using guessed type void *off_10072C64;
// 10072C68: using guessed type void *off_10072C68;
// 10072C6C: using guessed type void *off_10072C6C;
// 10072C70: using guessed type void *off_10072C70;
// 10072C74: using guessed type void *off_10072C74;
// 10072C78: using guessed type void *off_10072C78;
// 10072C7C: using guessed type void *off_10072C7C;
// 10072C90: using guessed type void *off_10072C90;
// 10072C94: using guessed type void *off_10072C94;
// 10072C98: using guessed type void *off_10072C98;
// 10072C9C: using guessed type void *off_10072C9C;
// 10072CA0: using guessed type void *off_10072CA0;
// 10072CA4: using guessed type void *off_10072CA4;

//----- (1004D894) --------------------------------------------------------
signed int __cdecl sub_1004D894(int lpMem)
{
  int v1; // ebx@1
  int v2; // edi@3
  void **v3; // esi@3
  int v4; // edx@4
  LPVOID v5; // esi@4
  int v7; // eax@6
  int v8; // edx@6
  void *v9; // edi@6
  int v10; // eax@10
  int v11; // edi@12
  signed int v12; // esi@12
  int v13; // esi@12
  int v14; // esi@12
  int v15; // esi@12
  int v16; // esi@12
  int v17; // esi@12
  int v18; // esi@12
  int v19; // esi@12
  int v20; // esi@12
  int v21; // esi@12
  int v22; // esi@12
  int v23; // esi@12
  int v24; // esi@12
  int v25; // esi@12
  int v26; // esi@12
  int v27; // esi@12
  int v28; // esi@12
  int v29; // esi@12
  int v30; // esi@12
  int v31; // esi@12
  int v32; // edx@14
  char v33; // al@15
  int v34; // esi@22
  int v35; // [sp-4h] [bp-24h]@4
  int v36; // [sp-4h] [bp-24h]@6
  LPVOID v37; // [sp+Ch] [bp-14h]@1
  int v38; // [sp+10h] [bp-10h]@1
  int v39; // [sp+14h] [bp-Ch]@12
  void *v40; // [sp+18h] [bp-8h]@1
  void *v41; // [sp+1Ch] [bp-4h]@3
  int v42; // [sp+28h] [bp+8h]@4

  v1 = lpMem;
  v40 = 0;
  v37 = (LPVOID)lpMem;
  v38 = 0;
  if ( *(_DWORD *)(lpMem + 172) || *(_DWORD *)(lpMem + 176) )
  {
    v5 = sub_100374E6(0, lpMem, 1u, 0x50u);
    v42 = (int)v5;
    if ( !v5 )
      return 1;
    v7 = sub_10037530(v4, v35, v1, 4);
    v9 = (void *)v7;
    v41 = (void *)v7;
    if ( !v7 )
    {
      sub_100309C2(v1, v5);
      return 1;
    }
    *(_DWORD *)v7 = 0;
    if ( !*(_DWORD *)(v1 + 172) )
    {
      memcpy((void *)v42, &off_10072C58, 0x50u);
LABEL_26:
      v3 = (void **)v42;
      *(_DWORD *)v42 = **(_DWORD **)(v1 + 132);
      v2 = (int)v40;
      *(_DWORD *)(v42 + 4) = *(_DWORD *)(*(_DWORD *)(v1 + 132) + 4);
      *(_DWORD *)(v42 + 8) = *(_DWORD *)(*(_DWORD *)(v1 + 132) + 8);
      *(_DWORD *)(v42 + 48) = *(_DWORD *)(*(_DWORD *)(v1 + 132) + 48);
      *(_DWORD *)(v42 + 52) = *(_DWORD *)(*(_DWORD *)(v1 + 132) + 52);
      *(_DWORD *)v41 = 1;
      if ( v2 )
        *(_DWORD *)v2 = 1;
      goto LABEL_28;
    }
    v10 = sub_10037530(v8, v36, v1, 4);
    v40 = (void *)v10;
    if ( !v10 )
    {
      sub_100309C2(v1, v5);
      sub_100309C2(v1, v9);
      return 1;
    }
    *(_DWORD *)v10 = 0;
    v11 = *(_DWORD *)(v1 + 172);
    v12 = sub_1003F7C4((int)&v37, 1, *(_DWORD *)(v1 + 172), 0x15u, (LPVOID *)v5 + 3);
    v13 = sub_1003F7C4((int)&v37, 1, v11, 0x14u, (LPVOID *)(v42 + 16)) | v12;
    v14 = sub_1003F7C4((int)&v37, 1, v11, 0x16u, (LPVOID *)(v42 + 20)) | v13;
    v15 = sub_1003F7C4((int)&v37, 1, v11, 0x17u, (LPVOID *)(v42 + 24)) | v14;
    v39 = v42 + 28;
    v16 = sub_1003F7C4((int)&v37, 1, v11, 0x18u, (LPVOID *)(v42 + 28)) | v15;
    v17 = sub_1003F7C4((int)&v37, 1, v11, 0x50u, (LPVOID *)(v42 + 32)) | v16;
    v18 = sub_1003F7C4((int)&v37, 1, v11, 0x51u, (LPVOID *)(v42 + 36)) | v17;
    v19 = sub_1003F7C4((int)&v37, 0, v11, 0x1Au, (LPVOID *)(v42 + 40)) | v18;
    v20 = sub_1003F7C4((int)&v37, 0, v11, 0x19u, (LPVOID *)(v42 + 41)) | v19;
    v21 = sub_1003F7C4((int)&v37, 0, v11, 0x54u, (LPVOID *)(v42 + 42)) | v20;
    v22 = sub_1003F7C4((int)&v37, 0, v11, 0x55u, (LPVOID *)(v42 + 43)) | v21;
    v23 = sub_1003F7C4((int)&v37, 0, v11, 0x56u, (LPVOID *)(v42 + 44)) | v22;
    v24 = sub_1003F7C4((int)&v37, 0, v11, 0x57u, (LPVOID *)(v42 + 45)) | v23;
    v25 = sub_1003F7C4((int)&v37, 0, v11, 0x52u, (LPVOID *)(v42 + 46)) | v24;
    v26 = sub_1003F7C4((int)&v37, 0, v11, 0x53u, (LPVOID *)(v42 + 47)) | v25;
    v27 = sub_1003F7C4((int)&v37, 2, v11, 0x15u, (LPVOID *)(v42 + 56)) | v26;
    v28 = sub_1003F7C4((int)&v37, 2, v11, 0x14u, (LPVOID *)(v42 + 60)) | v27;
    v29 = sub_1003F7C4((int)&v37, 2, v11, 0x16u, (LPVOID *)(v42 + 64)) | v28;
    v30 = sub_1003F7C4((int)&v37, 2, v11, 0x17u, (LPVOID *)(v42 + 68)) | v29;
    v31 = sub_1003F7C4((int)&v37, 2, v11, 0x50u, (LPVOID *)(v42 + 72)) | v30;
    if ( v31 | sub_1003F7C4((int)&v37, 2, v11, 0x51u, (LPVOID *)(v42 + 76)) )
    {
      sub_1004D798(v42, v42);
      sub_100309C2(v42, (LPVOID)v42);
      sub_100309C2(v42, v41);
      sub_100309C2(v42, v40);
      return 1;
    }
    v32 = *(_DWORD *)v39;
    while ( 1 )
    {
      if ( !*(_BYTE *)v32 )
        goto LABEL_26;
      v33 = *(_BYTE *)v32;
      if ( *(_BYTE *)v32 >= 48 )
      {
        if ( v33 <= 57 )
          break;
      }
      if ( v33 == 59 )
      {
        v34 = v32;
        do
        {
          *(_BYTE *)v34 = *(_BYTE *)(v34 + 1);
          ++v34;
        }
        while ( *(_BYTE *)v34 );
      }
      else
      {
LABEL_18:
        ++v32;
      }
    }
    *(_BYTE *)v32 = v33 - 48;
    goto LABEL_18;
  }
  v2 = 0;
  v41 = 0;
  v3 = &off_10072C58;
LABEL_28:
  if ( *(_DWORD *)(v1 + 128) )
    InterlockedDecrement(*(volatile LONG **)(v1 + 128));
  if ( *(_DWORD *)(v1 + 120) )
  {
    if ( !InterlockedDecrement(*(volatile LONG **)(v1 + 120)) )
    {
      sub_100309C2(v1, *(LPVOID *)(v1 + 132));
      sub_100309C2(v1, *(LPVOID *)(v1 + 120));
    }
  }
  *(_DWORD *)(v1 + 120) = v41;
  *(_DWORD *)(v1 + 128) = v2;
  *(_DWORD *)(v1 + 132) = v3;
  return 0;
}
// 10072C58: using guessed type void *off_10072C58;

//----- (1004DC36) --------------------------------------------------------
void __usercall sub_1004DC36(int a1<ebx>, int a2)
{
  if ( a2 )
  {
    if ( *(void **)a2 != off_10072C58 )
      sub_100309C2(a1, *(LPVOID *)a2);
    if ( *(void **)(a2 + 4) != off_10072C5C )
      sub_100309C2(a1, *(LPVOID *)(a2 + 4));
    if ( *(void **)(a2 + 8) != off_10072C60 )
      sub_100309C2(a1, *(LPVOID *)(a2 + 8));
    if ( *(void **)(a2 + 48) != off_10072C88 )
      sub_100309C2(a1, *(LPVOID *)(a2 + 48));
    if ( *(void **)(a2 + 52) != off_10072C8C )
      sub_100309C2(a1, *(LPVOID *)(a2 + 52));
  }
}
// 10072C58: using guessed type void *off_10072C58;
// 10072C5C: using guessed type void *off_10072C5C;
// 10072C60: using guessed type void *off_10072C60;
// 10072C88: using guessed type void *off_10072C88;
// 10072C8C: using guessed type void *off_10072C8C;

//----- (1004DC9D) --------------------------------------------------------
int __thiscall sub_1004DC9D(int this, int lpMem)
{
  int v2; // ebx@1
  int v3; // edi@3
  void **v4; // esi@3
  void *v5; // eax@4
  int v6; // edx@4
  int v8; // eax@6
  int v9; // edx@6
  int v10; // eax@9
  int v11; // edi@10
  signed int v12; // esi@10
  int v13; // esi@10
  int v14; // esi@10
  int v15; // esi@10
  int v16; // edx@13
  char v17; // al@14
  int v18; // esi@30
  int v19; // [sp-4h] [bp-24h]@6
  LPVOID v20; // [sp+Ch] [bp-14h]@1
  int v21; // [sp+10h] [bp-10h]@1
  int v22; // [sp+14h] [bp-Ch]@9
  int v23; // [sp+18h] [bp-8h]@4
  void *v24; // [sp+1Ch] [bp-4h]@3
  int v25; // [sp+28h] [bp+8h]@4

  v2 = lpMem;
  v20 = (LPVOID)lpMem;
  v21 = 0;
  if ( !*(_DWORD *)(lpMem + 176) && !*(_DWORD *)(lpMem + 172) )
  {
    v3 = 0;
    v24 = 0;
    v4 = &off_10072C58;
    goto LABEL_22;
  }
  v23 = 1;
  v5 = sub_100374E6(this, lpMem, 1u, 0x50u);
  v25 = (int)v5;
  if ( !v5 )
    return 1;
  memcpy(v5, *(const void **)(v2 + 132), 0x50u);
  v8 = sub_10037530(v6, 0, v2, 4);
  v24 = (void *)v8;
  if ( !v8 )
  {
    sub_100309C2(v2, (LPVOID)v25);
    return 1;
  }
  v3 = 0;
  *(_DWORD *)v8 = 0;
  if ( !*(_DWORD *)(v2 + 176) )
  {
    v4 = (void **)v25;
    *(_DWORD *)v25 = off_10072C58;
    *(_DWORD *)(v25 + 4) = off_10072C5C;
    *(_DWORD *)(v25 + 8) = off_10072C60;
    *(_DWORD *)(v25 + 48) = off_10072C88;
    *(_DWORD *)(v25 + 52) = off_10072C8C;
    goto LABEL_20;
  }
  v10 = sub_10037530(v9, v19, v2, 4);
  v22 = v10;
  if ( !v10 )
    goto LABEL_12;
  *(_DWORD *)v10 = 0;
  v11 = *(_DWORD *)(v2 + 176);
  v12 = sub_1003F7C4((int)&v20, 1, *(_DWORD *)(v2 + 176), 0xEu, (LPVOID *)v25);
  v13 = sub_1003F7C4((int)&v20, 1, v11, 0xFu, (LPVOID *)(v25 + 4)) | v12;
  v23 = v25 + 8;
  v14 = sub_1003F7C4((int)&v20, 1, v11, 0x10u, (LPVOID *)(v25 + 8)) | v13;
  v15 = sub_1003F7C4((int)&v20, 2, v11, 0xEu, (LPVOID *)(v25 + 48)) | v14;
  if ( v15 | sub_1003F7C4((int)&v20, 2, v11, 0xFu, (LPVOID *)(v25 + 52)) )
  {
    sub_1004DC36(v2, v25);
    v23 = -1;
LABEL_12:
    sub_100309C2(v2, (LPVOID)v25);
    sub_100309C2(v2, v24);
    return v23;
  }
  v16 = *(_DWORD *)v23;
  while ( *(_BYTE *)v16 )
  {
    v17 = *(_BYTE *)v16;
    if ( *(_BYTE *)v16 >= 48 && v17 <= 57 )
    {
      *(_BYTE *)v16 = v17 - 48;
      goto LABEL_17;
    }
    if ( v17 == 59 )
    {
      v18 = v16;
      do
      {
        *(_BYTE *)v18 = *(_BYTE *)(v18 + 1);
        ++v18;
      }
      while ( *(_BYTE *)v18 );
    }
    else
    {
LABEL_17:
      ++v16;
    }
  }
  v3 = v22;
  v4 = (void **)v25;
LABEL_20:
  *(_DWORD *)v24 = 1;
  if ( v3 )
    *(_DWORD *)v3 = 1;
LABEL_22:
  if ( *(_DWORD *)(v2 + 124) )
    InterlockedDecrement(*(volatile LONG **)(v2 + 124));
  if ( *(_DWORD *)(v2 + 120) )
  {
    if ( !InterlockedDecrement(*(volatile LONG **)(v2 + 120)) )
    {
      sub_100309C2(v2, *(LPVOID *)(v2 + 120));
      sub_100309C2(v2, *(LPVOID *)(v2 + 132));
    }
  }
  *(_DWORD *)(v2 + 120) = v24;
  *(_DWORD *)(v2 + 124) = v3;
  *(_DWORD *)(v2 + 132) = v4;
  return 0;
}
// 10072C58: using guessed type void *off_10072C58;
// 10072C5C: using guessed type void *off_10072C5C;
// 10072C60: using guessed type void *off_10072C60;
// 10072C88: using guessed type void *off_10072C88;
// 10072C8C: using guessed type void *off_10072C8C;

//----- (1004DEA5) --------------------------------------------------------
void __usercall sub_1004DEA5(int a1<ebx>, int a2)
{
  if ( a2 )
  {
    sub_100309C2(a1, *(LPVOID *)(a2 + 4));
    sub_100309C2(a1, *(LPVOID *)(a2 + 8));
    sub_100309C2(a1, *(LPVOID *)(a2 + 12));
    sub_100309C2(a1, *(LPVOID *)(a2 + 16));
    sub_100309C2(a1, *(LPVOID *)(a2 + 20));
    sub_100309C2(a1, *(LPVOID *)(a2 + 24));
    sub_100309C2(a1, *(LPVOID *)a2);
    sub_100309C2(a1, *(LPVOID *)(a2 + 32));
    sub_100309C2(a1, *(LPVOID *)(a2 + 36));
    sub_100309C2(a1, *(LPVOID *)(a2 + 40));
    sub_100309C2(a1, *(LPVOID *)(a2 + 44));
    sub_100309C2(a1, *(LPVOID *)(a2 + 48));
    sub_100309C2(a1, *(LPVOID *)(a2 + 52));
    sub_100309C2(a1, *(LPVOID *)(a2 + 28));
    sub_100309C2(a1, *(LPVOID *)(a2 + 56));
    sub_100309C2(a1, *(LPVOID *)(a2 + 60));
    sub_100309C2(a1, *(LPVOID *)(a2 + 64));
    sub_100309C2(a1, *(LPVOID *)(a2 + 68));
    sub_100309C2(a1, *(LPVOID *)(a2 + 72));
    sub_100309C2(a1, *(LPVOID *)(a2 + 76));
    sub_100309C2(a1, *(LPVOID *)(a2 + 80));
    sub_100309C2(a1, *(LPVOID *)(a2 + 84));
    sub_100309C2(a1, *(LPVOID *)(a2 + 88));
    sub_100309C2(a1, *(LPVOID *)(a2 + 92));
    sub_100309C2(a1, *(LPVOID *)(a2 + 96));
    sub_100309C2(a1, *(LPVOID *)(a2 + 100));
    sub_100309C2(a1, *(LPVOID *)(a2 + 104));
    sub_100309C2(a1, *(LPVOID *)(a2 + 108));
    sub_100309C2(a1, *(LPVOID *)(a2 + 112));
    sub_100309C2(a1, *(LPVOID *)(a2 + 116));
    sub_100309C2(a1, *(LPVOID *)(a2 + 120));
    sub_100309C2(a1, *(LPVOID *)(a2 + 124));
    sub_100309C2(a1, *(LPVOID *)(a2 + 128));
    sub_100309C2(a1, *(LPVOID *)(a2 + 132));
    sub_100309C2(a1, *(LPVOID *)(a2 + 136));
    sub_100309C2(a1, *(LPVOID *)(a2 + 140));
    sub_100309C2(a1, *(LPVOID *)(a2 + 144));
    sub_100309C2(a1, *(LPVOID *)(a2 + 148));
    sub_100309C2(a1, *(LPVOID *)(a2 + 152));
    sub_100309C2(a1, *(LPVOID *)(a2 + 156));
    sub_100309C2(a1, *(LPVOID *)(a2 + 160));
    sub_100309C2(a1, *(LPVOID *)(a2 + 164));
    sub_100309C2(a1, *(LPVOID *)(a2 + 168));
    sub_100309C2(a1, *(LPVOID *)(a2 + 184));
    sub_100309C2(a1, *(LPVOID *)(a2 + 188));
    sub_100309C2(a1, *(LPVOID *)(a2 + 192));
    sub_100309C2(a1, *(LPVOID *)(a2 + 196));
    sub_100309C2(a1, *(LPVOID *)(a2 + 200));
    sub_100309C2(a1, *(LPVOID *)(a2 + 204));
    sub_100309C2(a1, *(LPVOID *)(a2 + 180));
    sub_100309C2(a1, *(LPVOID *)(a2 + 212));
    sub_100309C2(a1, *(LPVOID *)(a2 + 216));
    sub_100309C2(a1, *(LPVOID *)(a2 + 220));
    sub_100309C2(a1, *(LPVOID *)(a2 + 224));
    sub_100309C2(a1, *(LPVOID *)(a2 + 228));
    sub_100309C2(a1, *(LPVOID *)(a2 + 232));
    sub_100309C2(a1, *(LPVOID *)(a2 + 208));
    sub_100309C2(a1, *(LPVOID *)(a2 + 236));
    sub_100309C2(a1, *(LPVOID *)(a2 + 240));
    sub_100309C2(a1, *(LPVOID *)(a2 + 244));
    sub_100309C2(a1, *(LPVOID *)(a2 + 248));
    sub_100309C2(a1, *(LPVOID *)(a2 + 252));
    sub_100309C2(a1, *(LPVOID *)(a2 + 256));
    sub_100309C2(a1, *(LPVOID *)(a2 + 260));
    sub_100309C2(a1, *(LPVOID *)(a2 + 264));
    sub_100309C2(a1, *(LPVOID *)(a2 + 268));
    sub_100309C2(a1, *(LPVOID *)(a2 + 272));
    sub_100309C2(a1, *(LPVOID *)(a2 + 276));
    sub_100309C2(a1, *(LPVOID *)(a2 + 280));
    sub_100309C2(a1, *(LPVOID *)(a2 + 284));
    sub_100309C2(a1, *(LPVOID *)(a2 + 288));
    sub_100309C2(a1, *(LPVOID *)(a2 + 292));
    sub_100309C2(a1, *(LPVOID *)(a2 + 296));
    sub_100309C2(a1, *(LPVOID *)(a2 + 300));
    sub_100309C2(a1, *(LPVOID *)(a2 + 304));
    sub_100309C2(a1, *(LPVOID *)(a2 + 308));
    sub_100309C2(a1, *(LPVOID *)(a2 + 312));
    sub_100309C2(a1, *(LPVOID *)(a2 + 316));
    sub_100309C2(a1, *(LPVOID *)(a2 + 320));
    sub_100309C2(a1, *(LPVOID *)(a2 + 324));
    sub_100309C2(a1, *(LPVOID *)(a2 + 328));
    sub_100309C2(a1, *(LPVOID *)(a2 + 332));
    sub_100309C2(a1, *(LPVOID *)(a2 + 336));
    sub_100309C2(a1, *(LPVOID *)(a2 + 340));
    sub_100309C2(a1, *(LPVOID *)(a2 + 344));
    sub_100309C2(a1, *(LPVOID *)(a2 + 348));
    sub_100309C2(a1, *(LPVOID *)(a2 + 352));
  }
}

//----- (1004E225) --------------------------------------------------------
signed int __thiscall sub_1004E225(int this, int a2)
{
  int v2; // eax@2
  int v3; // esi@2
  int v5; // eax@8

  if ( *(_DWORD *)(a2 + 180) )
  {
    v2 = (int)sub_100374E6(this, 1, 1u, 0x164u);
    v3 = v2;
    if ( !v2 )
      return 1;
    if ( sub_1004E2A1(v2, a2) )
    {
      sub_1004DEA5(1, v3);
      sub_100309C2(1, (LPVOID)v3);
      return 1;
    }
    *(_DWORD *)(v3 + 176) = 1;
  }
  else
  {
    v3 = (int)&off_100739E0;
  }
  v5 = *(_DWORD *)(a2 + 156);
  if ( (void **)v5 != &off_100739E0 )
    InterlockedDecrement((volatile LONG *)(v5 + 176));
  *(_DWORD *)(a2 + 156) = v3;
  return 0;
}
// 100739E0: using guessed type void *off_100739E0;

//----- (1004E2A1) --------------------------------------------------------
int __cdecl sub_1004E2A1(int a1, int a2)
{
  int v2; // ebx@1
  int result; // eax@2
  int v4; // eax@3
  signed int v5; // esi@3
  int v6; // esi@3
  int v7; // esi@3
  int v8; // esi@3
  int v9; // esi@3
  int v10; // esi@3
  int v11; // esi@3
  int v12; // esi@3
  int v13; // esi@3
  int v14; // esi@3
  int v15; // esi@3
  int v16; // esi@3
  int v17; // esi@3
  int v18; // esi@3
  int v19; // esi@3
  int v20; // esi@3
  int v21; // esi@3
  int v22; // esi@3
  int v23; // esi@3
  int v24; // esi@3
  int v25; // esi@3
  int v26; // esi@3
  int v27; // esi@3
  int v28; // esi@3
  int v29; // esi@3
  int v30; // esi@3
  int v31; // esi@3
  int v32; // esi@3
  int v33; // esi@3
  int v34; // esi@3
  int v35; // esi@3
  int v36; // esi@3
  int v37; // esi@3
  int v38; // esi@3
  int v39; // esi@3
  int v40; // esi@3
  int v41; // esi@3
  int v42; // esi@3
  int v43; // esi@3
  int v44; // esi@3
  int v45; // esi@3
  int v46; // esi@3
  int v47; // esi@3
  int v48; // esi@3
  int v49; // esi@3
  int v50; // esi@3
  int v51; // esi@3
  int v52; // esi@3
  int v53; // esi@3
  int v54; // esi@3
  int v55; // esi@3
  int v56; // esi@3
  int v57; // esi@3
  int v58; // esi@3
  int v59; // esi@3
  int v60; // esi@3
  int v61; // esi@3
  int v62; // esi@3
  int v63; // esi@3
  int v64; // esi@3
  int v65; // esi@3
  int v66; // esi@3
  int v67; // esi@3
  int v68; // esi@3
  int v69; // esi@3
  int v70; // esi@3
  int v71; // esi@3
  int v72; // esi@3
  int v73; // esi@3
  int v74; // esi@3
  int v75; // esi@3
  int v76; // esi@3
  int v77; // esi@3
  int v78; // esi@3
  int v79; // esi@3
  int v80; // esi@3
  int v81; // esi@3
  int v82; // esi@3
  int v83; // esi@3
  int v84; // esi@3
  int v85; // esi@3
  int v86; // esi@3
  int v87; // esi@3
  int v88; // esi@3
  int v89; // esi@3
  int v90; // esi@3
  int v91; // [sp+Ch] [bp-8h]@3
  int v92; // [sp+10h] [bp-4h]@3

  v2 = *(_DWORD *)(a2 + 180);
  if ( a1 )
  {
    v4 = sub_100426B6(*(_DWORD *)(a2 + 180));
    v92 = 0;
    *(_DWORD *)(a1 + 352) = v4;
    v91 = a2;
    v5 = sub_1003F7C4((int)&v91, 1, v2, 0x31u, (LPVOID *)(a1 + 4));
    v6 = sub_1003F7C4((int)&v91, 1, v2, 0x32u, (LPVOID *)(a1 + 8)) | v5;
    v7 = sub_1003F7C4((int)&v91, 1, v2, 0x33u, (LPVOID *)(a1 + 12)) | v6;
    v8 = sub_1003F7C4((int)&v91, 1, v2, 0x34u, (LPVOID *)(a1 + 16)) | v7;
    v9 = sub_1003F7C4((int)&v91, 1, v2, 0x35u, (LPVOID *)(a1 + 20)) | v8;
    v10 = sub_1003F7C4((int)&v91, 1, v2, 0x36u, (LPVOID *)(a1 + 24)) | v9;
    v11 = sub_1003F7C4((int)&v91, 1, v2, 0x37u, (LPVOID *)a1) | v10;
    v12 = sub_1003F7C4((int)&v91, 1, v2, 0x2Au, (LPVOID *)(a1 + 32)) | v11;
    v13 = sub_1003F7C4((int)&v91, 1, v2, 0x2Bu, (LPVOID *)(a1 + 36)) | v12;
    v14 = sub_1003F7C4((int)&v91, 1, v2, 0x2Cu, (LPVOID *)(a1 + 40)) | v13;
    v15 = sub_1003F7C4((int)&v91, 1, v2, 0x2Du, (LPVOID *)(a1 + 44)) | v14;
    v16 = sub_1003F7C4((int)&v91, 1, v2, 0x2Eu, (LPVOID *)(a1 + 48)) | v15;
    v17 = sub_1003F7C4((int)&v91, 1, v2, 0x2Fu, (LPVOID *)(a1 + 52)) | v16;
    v18 = sub_1003F7C4((int)&v91, 1, v2, 0x30u, (LPVOID *)(a1 + 28)) | v17;
    v19 = sub_1003F7C4((int)&v91, 1, v2, 0x44u, (LPVOID *)(a1 + 56)) | v18;
    v20 = sub_1003F7C4((int)&v91, 1, v2, 0x45u, (LPVOID *)(a1 + 60)) | v19;
    v21 = sub_1003F7C4((int)&v91, 1, v2, 0x46u, (LPVOID *)(a1 + 64)) | v20;
    v22 = sub_1003F7C4((int)&v91, 1, v2, 0x47u, (LPVOID *)(a1 + 68)) | v21;
    v23 = sub_1003F7C4((int)&v91, 1, v2, 0x48u, (LPVOID *)(a1 + 72)) | v22;
    v24 = sub_1003F7C4((int)&v91, 1, v2, 0x49u, (LPVOID *)(a1 + 76)) | v23;
    v25 = sub_1003F7C4((int)&v91, 1, v2, 0x4Au, (LPVOID *)(a1 + 80)) | v24;
    v26 = sub_1003F7C4((int)&v91, 1, v2, 0x4Bu, (LPVOID *)(a1 + 84)) | v25;
    v27 = sub_1003F7C4((int)&v91, 1, v2, 0x4Cu, (LPVOID *)(a1 + 88)) | v26;
    v28 = sub_1003F7C4((int)&v91, 1, v2, 0x4Du, (LPVOID *)(a1 + 92)) | v27;
    v29 = sub_1003F7C4((int)&v91, 1, v2, 0x4Eu, (LPVOID *)(a1 + 96)) | v28;
    v30 = sub_1003F7C4((int)&v91, 1, v2, 0x4Fu, (LPVOID *)(a1 + 100)) | v29;
    v31 = sub_1003F7C4((int)&v91, 1, v2, 0x38u, (LPVOID *)(a1 + 104)) | v30;
    v32 = sub_1003F7C4((int)&v91, 1, v2, 0x39u, (LPVOID *)(a1 + 108)) | v31;
    v33 = sub_1003F7C4((int)&v91, 1, v2, 0x3Au, (LPVOID *)(a1 + 112)) | v32;
    v34 = sub_1003F7C4((int)&v91, 1, v2, 0x3Bu, (LPVOID *)(a1 + 116)) | v33;
    v35 = sub_1003F7C4((int)&v91, 1, v2, 0x3Cu, (LPVOID *)(a1 + 120)) | v34;
    v36 = sub_1003F7C4((int)&v91, 1, v2, 0x3Du, (LPVOID *)(a1 + 124)) | v35;
    v37 = sub_1003F7C4((int)&v91, 1, v2, 0x3Eu, (LPVOID *)(a1 + 128)) | v36;
    v38 = sub_1003F7C4((int)&v91, 1, v2, 0x3Fu, (LPVOID *)(a1 + 132)) | v37;
    v39 = sub_1003F7C4((int)&v91, 1, v2, 0x40u, (LPVOID *)(a1 + 136)) | v38;
    v40 = sub_1003F7C4((int)&v91, 1, v2, 0x41u, (LPVOID *)(a1 + 140)) | v39;
    v41 = sub_1003F7C4((int)&v91, 1, v2, 0x42u, (LPVOID *)(a1 + 144)) | v40;
    v42 = sub_1003F7C4((int)&v91, 1, v2, 0x43u, (LPVOID *)(a1 + 148)) | v41;
    v43 = sub_1003F7C4((int)&v91, 1, v2, 0x28u, (LPVOID *)(a1 + 152)) | v42;
    v44 = sub_1003F7C4((int)&v91, 1, v2, 0x29u, (LPVOID *)(a1 + 156)) | v43;
    v45 = sub_1003F7C4((int)&v91, 1, v2, 0x1Fu, (LPVOID *)(a1 + 160)) | v44;
    v46 = sub_1003F7C4((int)&v91, 1, v2, 0x20u, (LPVOID *)(a1 + 164)) | v45;
    v47 = sub_1003F7C4((int)&v91, 1, v2, 0x1003u, (LPVOID *)(a1 + 168)) | v46;
    v48 = sub_1003F7C4((int)&v91, 0, v2, 0x1009u, (LPVOID *)(a1 + 172)) | v47;
    v49 = sub_1003F7C4((int)&v91, 2, v2, 0x31u, (LPVOID *)(a1 + 184)) | v48;
    v50 = sub_1003F7C4((int)&v91, 2, v2, 0x32u, (LPVOID *)(a1 + 188)) | v49;
    v51 = sub_1003F7C4((int)&v91, 2, v2, 0x33u, (LPVOID *)(a1 + 192)) | v50;
    v52 = sub_1003F7C4((int)&v91, 2, v2, 0x34u, (LPVOID *)(a1 + 196)) | v51;
    v53 = sub_1003F7C4((int)&v91, 2, v2, 0x35u, (LPVOID *)(a1 + 200)) | v52;
    v54 = sub_1003F7C4((int)&v91, 2, v2, 0x36u, (LPVOID *)(a1 + 204)) | v53;
    v55 = sub_1003F7C4((int)&v91, 2, v2, 0x37u, (LPVOID *)(a1 + 180)) | v54;
    v56 = sub_1003F7C4((int)&v91, 2, v2, 0x2Au, (LPVOID *)(a1 + 212)) | v55;
    v57 = sub_1003F7C4((int)&v91, 2, v2, 0x2Bu, (LPVOID *)(a1 + 216)) | v56;
    v58 = sub_1003F7C4((int)&v91, 2, v2, 0x2Cu, (LPVOID *)(a1 + 220)) | v57;
    v59 = sub_1003F7C4((int)&v91, 2, v2, 0x2Du, (LPVOID *)(a1 + 224)) | v58;
    v60 = sub_1003F7C4((int)&v91, 2, v2, 0x2Eu, (LPVOID *)(a1 + 228)) | v59;
    v61 = sub_1003F7C4((int)&v91, 2, v2, 0x2Fu, (LPVOID *)(a1 + 232)) | v60;
    v62 = sub_1003F7C4((int)&v91, 2, v2, 0x30u, (LPVOID *)(a1 + 208)) | v61;
    v63 = sub_1003F7C4((int)&v91, 2, v2, 0x44u, (LPVOID *)(a1 + 236)) | v62;
    v64 = sub_1003F7C4((int)&v91, 2, v2, 0x45u, (LPVOID *)(a1 + 240)) | v63;
    v65 = sub_1003F7C4((int)&v91, 2, v2, 0x46u, (LPVOID *)(a1 + 244)) | v64;
    v66 = sub_1003F7C4((int)&v91, 2, v2, 0x47u, (LPVOID *)(a1 + 248)) | v65;
    v67 = sub_1003F7C4((int)&v91, 2, v2, 0x48u, (LPVOID *)(a1 + 252)) | v66;
    v68 = sub_1003F7C4((int)&v91, 2, v2, 0x49u, (LPVOID *)(a1 + 256)) | v67;
    v69 = sub_1003F7C4((int)&v91, 2, v2, 0x4Au, (LPVOID *)(a1 + 260)) | v68;
    v70 = sub_1003F7C4((int)&v91, 2, v2, 0x4Bu, (LPVOID *)(a1 + 264)) | v69;
    v71 = sub_1003F7C4((int)&v91, 2, v2, 0x4Cu, (LPVOID *)(a1 + 268)) | v70;
    v72 = sub_1003F7C4((int)&v91, 2, v2, 0x4Du, (LPVOID *)(a1 + 272)) | v71;
    v73 = sub_1003F7C4((int)&v91, 2, v2, 0x4Eu, (LPVOID *)(a1 + 276)) | v72;
    v74 = sub_1003F7C4((int)&v91, 2, v2, 0x4Fu, (LPVOID *)(a1 + 280)) | v73;
    v75 = sub_1003F7C4((int)&v91, 2, v2, 0x38u, (LPVOID *)(a1 + 284)) | v74;
    v76 = sub_1003F7C4((int)&v91, 2, v2, 0x39u, (LPVOID *)(a1 + 288)) | v75;
    v77 = sub_1003F7C4((int)&v91, 2, v2, 0x3Au, (LPVOID *)(a1 + 292)) | v76;
    v78 = sub_1003F7C4((int)&v91, 2, v2, 0x3Bu, (LPVOID *)(a1 + 296)) | v77;
    v79 = sub_1003F7C4((int)&v91, 2, v2, 0x3Cu, (LPVOID *)(a1 + 300)) | v78;
    v80 = sub_1003F7C4((int)&v91, 2, v2, 0x3Du, (LPVOID *)(a1 + 304)) | v79;
    v81 = sub_1003F7C4((int)&v91, 2, v2, 0x3Eu, (LPVOID *)(a1 + 308)) | v80;
    v82 = sub_1003F7C4((int)&v91, 2, v2, 0x3Fu, (LPVOID *)(a1 + 312)) | v81;
    v83 = sub_1003F7C4((int)&v91, 2, v2, 0x40u, (LPVOID *)(a1 + 316)) | v82;
    v84 = sub_1003F7C4((int)&v91, 2, v2, 0x41u, (LPVOID *)(a1 + 320)) | v83;
    v85 = sub_1003F7C4((int)&v91, 2, v2, 0x42u, (LPVOID *)(a1 + 324)) | v84;
    v86 = sub_1003F7C4((int)&v91, 2, v2, 0x43u, (LPVOID *)(a1 + 328)) | v85;
    v87 = sub_1003F7C4((int)&v91, 2, v2, 0x28u, (LPVOID *)(a1 + 332)) | v86;
    v88 = sub_1003F7C4((int)&v91, 2, v2, 0x29u, (LPVOID *)(a1 + 336)) | v87;
    v89 = sub_1003F7C4((int)&v91, 2, v2, 0x1Fu, (LPVOID *)(a1 + 340)) | v88;
    v90 = sub_1003F7C4((int)&v91, 2, v2, 0x20u, (LPVOID *)(a1 + 344)) | v89;
    result = v90 | sub_1003F7C4((int)&v91, 2, v2, 0x1003u, (LPVOID *)(a1 + 348));
  }
  else
  {
    result = -1;
  }
  return result;
}

//----- (1004EA92) --------------------------------------------------------
int __thiscall sub_1004EA92(void *this, const WCHAR SrcStr, __int16 a3)
{
  int result; // eax@2
  int v4; // eax@4
  BOOL v5; // eax@5
  WORD CharType[2]; // [sp+0h] [bp-4h]@1

  *(_DWORD *)CharType = this;
  if ( SrcStr == -1 )
  {
    result = 0;
  }
  else
  {
    if ( SrcStr >= 0x100u )
    {
      v5 = GetStringTypeW(1u, &SrcStr, 1, CharType);
      v4 = v5 != 0 ? *(_DWORD *)CharType : 0;
    }
    else
    {
      LOWORD(v4) = *((_WORD *)off_10073084 + SrcStr);
    }
    result = (unsigned __int16)(a3 & v4);
  }
  return result;
}
// 10073084: using guessed type void *off_10073084;

//----- (1004EAE4) --------------------------------------------------------
int __cdecl sub_1004EAE4()
{
  return 0;
}

//----- (1004EAE7) --------------------------------------------------------
int __cdecl sub_1004EAE7(int a1, int a2)
{
  int v2; // edx@1
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // esi@2

  v2 = a2;
  v4 = *(_WORD *)a2;
  v3 = *(_WORD *)a1 - v4;
  if ( *(_WORD *)a1 == v4 )
  {
    v5 = a1 - a2;
    do
    {
      if ( !(_WORD)v4 )
        break;
      v2 += 2;
      v4 = *(_WORD *)v2;
      v3 = *(_WORD *)(v5 + v2) - v4;
    }
    while ( *(_WORD *)(v5 + v2) == v4 );
  }
  if ( v3 >= 0 )
  {
    if ( v3 > 0 )
      v3 = 1;
  }
  else
  {
    v3 = -1;
  }
  return v3;
}

//----- (1004EB25) --------------------------------------------------------
int __cdecl sub_1004EB25(int a1, int a2)
{
  int v2; // eax@1
  __int16 v3; // dx@1
  int v4; // ecx@1
  int v5; // esi@2
  __int16 v6; // dx@3

  v4 = a1;
  v3 = 0;
  v2 = a1;
  if ( *(_WORD *)a1 )
  {
    while ( 1 )
    {
      v5 = a2;
      if ( *(_WORD *)a2 )
        break;
LABEL_7:
      v2 += 2;
      if ( *(_WORD *)v2 == v3 )
        return (v2 - v4) >> 1;
    }
    v4 = a1;
    v6 = *(_WORD *)a2;
    while ( v6 != *(_WORD *)v2 )
    {
      v5 += 2;
      v6 = *(_WORD *)v5;
      if ( !*(_WORD *)v5 )
      {
        v3 = 0;
        goto LABEL_7;
      }
    }
  }
  return (v2 - v4) >> 1;
}

//----- (1004EB74) --------------------------------------------------------
int __cdecl sub_1004EB74(int a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // edx@3
  int v5; // ecx@3

  result = a3;
  if ( a3 )
  {
    v5 = a2;
    v4 = a1;
    while ( 1 )
    {
      --result;
      if ( !result )
        break;
      if ( !*(_WORD *)v4 || *(_WORD *)v4 != *(_WORD *)v5 )
        break;
      v4 += 2;
      v5 += 2;
    }
    result = *(_WORD *)v4 - *(_WORD *)v5;
  }
  return result;
}

//----- (1004EBAA) --------------------------------------------------------
int __cdecl sub_1004EBAA(int a1, int a2)
{
  int result; // eax@1
  __int16 v3; // cx@1
  int v4; // esi@2
  __int16 v5; // dx@3

  result = a1;
  v3 = *(_WORD *)a1;
  if ( *(_WORD *)a1 )
  {
    while ( 1 )
    {
      v4 = a2;
      if ( *(_WORD *)a2 )
        break;
LABEL_6:
      result += 2;
      v3 = *(_WORD *)result;
      if ( !*(_WORD *)result )
        goto LABEL_7;
    }
    v5 = *(_WORD *)a2;
    while ( v5 != v3 )
    {
      v4 += 2;
      v5 = *(_WORD *)v4;
      if ( !*(_WORD *)v4 )
        goto LABEL_6;
    }
  }
  else
  {
LABEL_7:
    result = 0;
  }
  return result;
}

//----- (1004EBEC) --------------------------------------------------------
int __usercall sub_1004EBEC<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int result; // eax@1
  int v4; // eax@2
  char v5; // [sp+4h] [bp-B0h]@1
  unsigned int v6; // [sp+B0h] [bp-4h]@1
  int v7; // [sp+B4h] [bp+0h]@1

  v6 = (unsigned int)&v7 ^ __security_cookie;
  *(_DWORD *)(a3 + 8) |= 0x104u;
  result = sub_10039CBD((int)&v5, 85);
  if ( result > 1 )
  {
    v4 = sub_10039899((int)&v5);
    result = sub_1004498F(a1, a2, a3 + 592, 85, (int)&v5, v4 + 1);
    if ( result )
    {
      sub_1003A161(a1, a2);
      __asm { int     3               ; Trap to Debugger }
      JUMPOUT(*(int *)sub_1004EC63);
    }
  }
  return result;
}
// 1004EC63: using guessed type int __cdecl sub_1004EC63(int);
// 10073200: using guessed type int __security_cookie;

//----- (1004EC63) --------------------------------------------------------
BOOL __cdecl sub_1004EC63(int a1)
{
  int v1; // ST04_4@1
  int v2; // eax@1
  char v3; // zf@1
  int v4; // eax@2
  BOOL result; // eax@4

  v1 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 16) = sub_10039899(*(_DWORD *)a1) == 3;
  v2 = sub_10039899(v1);
  v3 = *(_DWORD *)(a1 + 16) == 0;
  *(_DWORD *)(a1 + 20) = v2 == 3;
  if ( v3 )
    v4 = sub_1004ED21(*(unsigned __int16 **)a1);
  else
    v4 = 2;
  *(_DWORD *)(a1 + 12) = v4;
  result = sub_10039C51((int (__stdcall *)(_DWORD, _DWORD, _DWORD))sub_1004ED53, 3, 0);
  if ( !(*(_DWORD *)(a1 + 8) & 0x100) || !(*(_DWORD *)(a1 + 8) & 0x200) || !(*(_BYTE *)(a1 + 8) & 7) )
    *(_DWORD *)(a1 + 8) = 0;
  return result;
}
// 1004EC63: using guessed type int __cdecl sub_1004EC63(int);

//----- (1004ECD7) --------------------------------------------------------
BOOL __cdecl sub_1004ECD7(int a1)
{
  bool v1; // eax@1
  int v2; // eax@2
  BOOL result; // eax@4

  v1 = sub_10039899(*(_DWORD *)a1) == 3;
  *(_DWORD *)(a1 + 16) = v1;
  if ( v1 )
    v2 = 2;
  else
    v2 = sub_1004ED21(*(unsigned __int16 **)a1);
  *(_DWORD *)(a1 + 12) = v2;
  result = sub_10039C51((int (__stdcall *)(_DWORD, _DWORD, _DWORD))sub_1004EF71, 3, 0);
  if ( !(*(_BYTE *)(a1 + 8) & 4) )
    *(_DWORD *)(a1 + 8) = 0;
  return result;
}

//----- (1004ED21) --------------------------------------------------------
int __cdecl sub_1004ED21(unsigned __int16 *a1)
{
  int v1; // edx@1
  unsigned __int16 *v2; // ecx@1
  int result; // eax@2
  unsigned __int16 v4; // ax@3

  v2 = a1;
  v1 = 0;
  if ( a1 )
  {
    while ( 1 )
    {
      v4 = *v2;
      ++v2;
      if ( v4 < 0x41u || v4 > 0x5Au )
      {
        if ( (unsigned __int16)(v4 - 97) > 0x19u )
          break;
      }
      ++v1;
    }
    result = v1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (1004ED53) --------------------------------------------------------
unsigned int __userpurge sub_1004ED53<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // esi@1
  int v7; // eax@1
  int v9; // eax@7
  int v10; // edi@8
  int v11; // eax@22
  int v12; // esi@28
  const WCHAR v13[64]; // [sp+Ch] [bp-84h]@1
  unsigned int v14; // [sp+8Ch] [bp-4h]@1
  int v15; // [sp+90h] [bp+0h]@1

  v14 = (unsigned int)&v15 ^ __security_cookie;
  v6 = a3;
  v7 = sub_10041952(a1, a2);
  v5 = v7 + 156;
  if ( !sub_10039C8E(a3, *(_DWORD *)(v7 + 176) != 0 ? 7 : 4098, (WCHAR *)v13, 64) )
  {
    *(_DWORD *)(v5 + 8) = 0;
    return 1;
  }
  if ( !sub_1004AAEB(v5, a2, *(_DWORD *)(v5 + 4), v13) )
  {
    if ( !sub_10039C8E(a3, *(_DWORD *)(v5 + 16) != 0 ? 3 : 4097, (WCHAR *)v13, 64) )
    {
LABEL_18:
      *(_DWORD *)(v5 + 8) = 0;
      return 1;
    }
    if ( !sub_1004AAEB(v5, -4094, *(_DWORD *)v5, v13) )
    {
      *(_DWORD *)(v5 + 8) |= 0x304u;
      goto LABEL_7;
    }
    if ( !(*(_BYTE *)(v5 + 8) & 2) )
    {
      if ( *(_DWORD *)(v5 + 12) && !sub_100549BA(v5, -4094, *(_DWORD *)v5, (int)v13, *(_DWORD *)(v5 + 12)) )
      {
        *(_DWORD *)(v5 + 8) |= 2u;
        goto LABEL_7;
      }
      if ( !(*(_BYTE *)(v5 + 8) & 1) && sub_1004F0B7(a3) )
      {
        *(_DWORD *)(v5 + 8) |= 1u;
LABEL_7:
        v9 = sub_10039899(a3);
        if ( sub_1004498F(v5, -4094, v5 + 592, 85, a3, v9 + 1) )
        {
          v10 = 0;
          goto LABEL_30;
        }
        goto LABEL_16;
      }
    }
  }
LABEL_16:
  if ( (*(_DWORD *)(v5 + 8) & 0x300) != 768 )
  {
    if ( !sub_10039C8E(a3, *(_DWORD *)(v5 + 16) != 0 ? 3 : 4097, (WCHAR *)v13, 128) )
      goto LABEL_18;
    if ( !sub_1004AAEB(v5, -4094, *(_DWORD *)v5, v13) )
    {
      *(_DWORD *)(v5 + 8) |= 0x200u;
      v10 = 0;
      if ( *(_DWORD *)(v5 + 16)
        || !*(_DWORD *)(v5 + 12)
        || sub_10039899(*(_DWORD *)v5) != *(_DWORD *)(v5 + 12)
        || sub_1004F0B7(a3) )
      {
LABEL_21:
        *(_DWORD *)(v5 + 8) |= 0x100u;
        if ( !*(_WORD *)(v5 + 592) )
        {
          v11 = sub_10039899(v6);
          if ( sub_1004498F(v5, 0, v5 + 592, 85, v6, v11 + 1) )
          {
LABEL_30:
            sub_1003A161(v5, v10);
            __asm { int     3               ; Trap to Debugger }
            JUMPOUT(*(int *)sub_1004EF71);
          }
        }
        return ~(unsigned __int8)(*(_DWORD *)(v5 + 8) >> 2) & 1;
      }
      v12 = sub_1004ED21(*(unsigned __int16 **)v5);
      if ( v12 != sub_10039899(*(_DWORD *)v5) )
      {
        v6 = a3;
        goto LABEL_21;
      }
    }
  }
  return ~(unsigned __int8)(*(_DWORD *)(v5 + 8) >> 2) & 1;
}
// 10073200: using guessed type int __security_cookie;

//----- (1004EF71) --------------------------------------------------------
unsigned int __userpurge sub_1004EF71<eax>(int a1<ebx>, int a2, int a3, int a4)
{
  int v4; // esi@1
  int v5; // eax@1
  unsigned int result; // eax@2
  int v7; // eax@4
  const WCHAR v8[120]; // [sp+8h] [bp-F4h]@1
  unsigned int v9; // [sp+F8h] [bp-4h]@1
  int v10; // [sp+FCh] [bp+0h]@1

  v9 = (unsigned int)&v10 ^ __security_cookie;
  v5 = sub_10041952(a1, a2);
  v4 = v5 + 156;
  if ( sub_10039C8E(a2, *(_DWORD *)(v5 + 172) != 0 ? 3 : 4097, (WCHAR *)v8, 120) )
  {
    if ( !sub_1004AAEB(a1, a2, *(_DWORD *)v4, v8) )
    {
      v7 = sub_10039899(a2);
      if ( sub_1004498F(a1, a2, v4 + 592, 85, a2, v7 + 1) )
      {
        sub_1003A161(a1, a2);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_1004F022);
      }
      *(_DWORD *)(v4 + 8) |= 4u;
    }
    result = ~(unsigned __int8)(*(_DWORD *)(v4 + 8) >> 2) & 1;
  }
  else
  {
    *(_DWORD *)(v4 + 8) = 0;
    result = 1;
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;

//----- (1004F022) --------------------------------------------------------
int __usercall sub_1004F022<eax>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  int v4; // esi@1
  int result; // eax@6

  v4 = a3;
  if ( a3 && *(_WORD *)a3 && sub_1004EAE7(a3, (int)L"ACP") )
  {
    if ( sub_1004EAE7(v4, (int)L"OCP") )
      return sub_100548F8(a1, a2, v4);
    if ( sub_10039C8E(a4 + 592, 0x2000000Bu, (WCHAR *)&a3, 2) )
      return a3;
    return 0;
  }
  if ( !sub_10039C8E(a4 + 592, 0x20001004u, (WCHAR *)&a3, 2) )
    return 0;
  result = a3;
  if ( !a3 )
    result = GetACP();
  return result;
}
// 100667AC: using guessed type wchar_t aAcp[4];
// 100667B4: using guessed type wchar_t aOcp[4];

//----- (1004F0B7) --------------------------------------------------------
int __cdecl sub_1004F0B7(int a1)
{
  int result; // eax@1
  char v2; // [sp+4h] [bp-18h]@1
  unsigned int v3; // [sp+18h] [bp-4h]@1
  int v4; // [sp+1Ch] [bp+0h]@1

  v3 = (unsigned int)&v4 ^ __security_cookie;
  result = sub_10039C8E(a1, 0x59u, (WCHAR *)&v2, 9);
  if ( result )
    result = sub_1004EB74((int)&v2, a1, 9) == 0;
  return result;
}
// 10073200: using guessed type int __security_cookie;

//----- (1004F101) --------------------------------------------------------
bool __cdecl sub_1004F101(int a1, int a2, int *a3)
{
  signed int v3; // edx@1
  int i; // edi@1
  int v5; // esi@1
  int v6; // eax@3
  int v7; // ebx@3
  int v9; // [sp+14h] [bp+Ch]@3

  v5 = a2;
  v3 = 1;
  for ( i = 0; i <= v5; v6 ? (v6 >= 0 ? (i = v7 + 1) : (v5 = v7 - 1)) : (*a3 = v9 + 4 + a1) )
  {
    if ( !v3 )
      break;
    v7 = (i + v5) / 2;
    v9 = 12 * (i + v5) / 2;
    v6 = sub_1004AAEB(v7, i, *a3, *(const WCHAR **)(v9 + a1));
    v3 = v6;
  }
  return v3 == 0;
}

//----- (1004F16D) --------------------------------------------------------
signed int __usercall sub_1004F16D<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  int v5; // eax@1
  __int16 v6; // cx@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // eax@14
  unsigned int v10; // esi@14
  int v11; // eax@21
  int v13; // [sp+Ch] [bp-4h]@1

  v5 = sub_10041952(a1, a2);
  v8 = v5 + 156;
  v6 = 0;
  v13 = v5 + 748;
  *(_WORD *)(v5 + 748) = 0;
  v7 = v5 + 160;
  *(_DWORD *)(v5 + 164) = 0;
  *(_DWORD *)(v5 + 156) = a3;
  *(_DWORD *)(v5 + 160) = a3 + 128;
  if ( *(_WORD *)(a3 + 128) )
  {
    sub_1004F101((int)&off_100664D0, 22, (int *)(v5 + 160));
    v6 = 0;
  }
  if ( **(_WORD **)v8 == v6 )
  {
    sub_1004EBEC(a3, v7, v8);
  }
  else
  {
    if ( **(_WORD **)v7 == v6 )
      sub_1004ECD7(v8);
    else
      sub_1004EC63(v8);
    if ( !*(_DWORD *)(v8 + 8) )
    {
      if ( sub_1004F101((int)&off_10065A20, 64, (int *)v8) )
      {
        if ( **(_WORD **)v7 )
          sub_1004EC63(v8);
        else
          sub_1004ECD7(v8);
      }
    }
  }
  if ( *(_DWORD *)(v8 + 8) )
  {
    v9 = sub_1004F022(a3, 0, a3 + 256, v8);
    v10 = v9;
    if ( v9 )
    {
      if ( v9 != 65000 && v9 != 65001 && IsValidCodePage((unsigned __int16)v9) )
      {
        if ( a4 )
          *(_DWORD *)a4 = v10;
        if ( !a5 )
          return 1;
        *(_WORD *)(a5 + 288) = 0;
        v11 = sub_10039899(v13);
        if ( sub_1004498F(a5 + 288, a5, a5 + 288, 85, v13, v11 + 1) )
        {
          sub_1003A161(a5 + 288, a5);
          __asm { int     3               ; Trap to Debugger }
          JUMPOUT(*(int *)sub_1004F32F);
        }
        if ( sub_10039C8E(a5 + 288, 0x1001u, (WCHAR *)a5, 64)
          && sub_10039C8E(a5 + 288, 0x1002u, (WCHAR *)(a5 + 128), 64)
          && (!sub_1005490C(a5 + 128, 0x5Fu) && !sub_1005490C(a5 + 128, 0x2Eu)
           || sub_10039C8E(a5 + 288, 7u, (WCHAR *)(a5 + 128), 64)) )
        {
          sub_100547DC(a5 + 128, a5, v10, a5 + 256, 0x10u, 0xAu);
          return 1;
        }
      }
    }
  }
  return 0;
}
// 1004EC63: using guessed type int __cdecl sub_1004EC63(int);
// 10065A20: using guessed type wchar_t *off_10065A20;
// 100664D0: using guessed type wchar_t *off_100664D0;

//----- (1004F32F) --------------------------------------------------------
unsigned int __userpurge sub_1004F32F<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  unsigned int result; // eax@2
  WCHAR LCData; // [sp+Ch] [bp-F4h]@1
  unsigned int v8; // [sp+FCh] [bp-4h]@1
  int v9; // [sp+100h] [bp+0h]@1

  v8 = (unsigned int)&v9 ^ __security_cookie;
  v3 = sub_10041952(a1, a2);
  v4 = *(_DWORD *)(sub_10041952(v3, a2) + 952);
  v5 = sub_1004F7E9(a3);
  if ( GetLocaleInfoW(v5, *(_DWORD *)(v3 + 176) != 0 ? 7 : 4098, &LCData, 240) )
  {
    if ( !sub_1004AAEB(v3, v4, *(_DWORD *)(v3 + 160), &LCData) )
    {
      if ( sub_1004F8C3(v5) )
      {
        *(_DWORD *)v4 |= 4u;
        *(_DWORD *)(v4 + 8) = v5;
        *(_DWORD *)(v4 + 4) = v5;
      }
    }
    result = ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
  }
  else
  {
    *(_DWORD *)v4 = 0;
    result = 1;
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;

//----- (1004F3DD) --------------------------------------------------------
int __usercall sub_1004F3DD<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int result; // eax@1
  int v4; // eax@1

  v4 = sub_10041952(a1, a2);
  *(_DWORD *)(v4 + 176) = sub_10039899(*(_DWORD *)(v4 + 160)) == 3;
  EnumSystemLocalesW((LOCALE_ENUMPROCW)sub_1004F32F, 1u);
  result = a3;
  if ( !(*(_BYTE *)a3 & 4) )
    *(_DWORD *)a3 = 0;
  return result;
}

//----- (1004F41D) --------------------------------------------------------
BOOL __usercall sub_1004F41D<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // esi@1
  int v4; // eax@1
  int v5; // ST00_4@1
  int v6; // eax@2
  BOOL result; // eax@4

  v4 = sub_10041952(a1, a2);
  v3 = v4 + 156;
  v5 = *(_DWORD *)(v4 + 160);
  *(_DWORD *)(v4 + 172) = sub_10039899(*(_DWORD *)(v4 + 156)) == 3;
  *(_DWORD *)(v3 + 20) = sub_10039899(v5) == 3;
  *(_DWORD *)(a3 + 4) = 0;
  if ( *(_DWORD *)(v3 + 16) )
    v6 = 2;
  else
    v6 = sub_1004F4F3(*(unsigned __int16 **)v3);
  *(_DWORD *)(v3 + 12) = v6;
  result = EnumSystemLocalesW((LOCALE_ENUMPROCW)sub_1004F51D, 1u);
  if ( !(*(_DWORD *)a3 & 0x100) || !(*(_DWORD *)a3 & 0x200) || !(*(_BYTE *)a3 & 7) )
    *(_DWORD *)a3 = 0;
  return result;
}

//----- (1004F49A) --------------------------------------------------------
int __usercall sub_1004F49A<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // esi@1
  int v4; // eax@1
  bool v5; // eax@1
  int v6; // eax@2
  int result; // eax@4

  v4 = sub_10041952(a1, a2);
  v3 = v4;
  v5 = sub_10039899(*(_DWORD *)(v4 + 156)) == 3;
  *(_DWORD *)(v3 + 172) = v5;
  if ( v5 )
    v6 = 2;
  else
    v6 = sub_1004F4F3(*(unsigned __int16 **)(v3 + 156));
  *(_DWORD *)(v3 + 168) = v6;
  EnumSystemLocalesW((LOCALE_ENUMPROCW)sub_1004F710, 1u);
  result = a3;
  if ( !(*(_BYTE *)a3 & 4) )
    *(_DWORD *)a3 = 0;
  return result;
}

//----- (1004F4F3) --------------------------------------------------------
int __cdecl sub_1004F4F3(unsigned __int16 *a1)
{
  int i; // edx@1
  unsigned __int16 *v2; // ecx@1
  unsigned __int16 v3; // ax@2

  v2 = a1;
  for ( i = 0; ; ++i )
  {
    v3 = *v2;
    ++v2;
    if ( v3 < 0x41u || v3 > 0x5Au )
    {
      if ( (unsigned __int16)(v3 - 97) > 0x19u )
        break;
    }
  }
  return i;
}

//----- (1004F51D) --------------------------------------------------------
signed int __userpurge sub_1004F51D<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // edx@13
  int v8; // eax@18
  int v9; // [sp-8h] [bp-108h]@22
  WCHAR LCData; // [sp+Ch] [bp-F4h]@1
  unsigned int v11; // [sp+FCh] [bp-4h]@1
  int v12; // [sp+100h] [bp+0h]@1

  v11 = (unsigned int)&v12 ^ __security_cookie;
  v3 = sub_10041952(a1, a2) + 156;
  v4 = *(_DWORD *)(sub_10041952(v3, a2) + 952);
  v5 = sub_1004F7E9(a3);
  if ( !GetLocaleInfoW(v5, *(_DWORD *)(v3 + 20) != 0 ? 7 : 4098, &LCData, 240) )
    goto LABEL_2;
  if ( !sub_1004AAEB(v3, v4, *(_DWORD *)(v3 + 4), &LCData) )
  {
    if ( !GetLocaleInfoW(v5, *(_DWORD *)(v3 + 16) != 0 ? 3 : 4097, &LCData, 240) )
      goto LABEL_2;
    if ( !sub_1004AAEB(v3, v4, *(_DWORD *)v3, &LCData) )
    {
      *(_DWORD *)v4 |= 0x304u;
      *(_DWORD *)(v4 + 4) = v5;
LABEL_15:
      *(_DWORD *)(v4 + 8) = v5;
      goto LABEL_16;
    }
    if ( *(_BYTE *)v4 & 2 )
      goto LABEL_16;
    if ( !*(_DWORD *)(v3 + 12) || sub_100549BA(v3, v4, *(_DWORD *)v3, (int)&LCData, *(_DWORD *)(v3 + 12)) )
    {
      if ( !(*(_DWORD *)v4 & 1) && sub_1004F8C3(v5) )
      {
        *(_DWORD *)v4 = v7 | 1;
        goto LABEL_15;
      }
    }
    else
    {
      *(_DWORD *)v4 |= 2u;
      *(_DWORD *)(v4 + 8) = v5;
      if ( sub_10039899(*(_DWORD *)v3) == *(_DWORD *)(v3 + 12) )
        *(_DWORD *)(v4 + 4) = v5;
    }
  }
LABEL_16:
  if ( (*(_DWORD *)v4 & 0x300) == 768 )
    return ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
  if ( !GetLocaleInfoW(v5, *(_DWORD *)(v3 + 16) != 0 ? 3 : 4097, &LCData, 240) )
  {
LABEL_2:
    *(_DWORD *)v4 = 0;
    return 1;
  }
  v8 = sub_1004AAEB(v3, v4, *(_DWORD *)v3, &LCData);
  if ( v8 )
  {
    if ( *(_DWORD *)(v3 + 16) || !*(_DWORD *)(v3 + 12) || sub_1004AAEB(v3, v4, *(_DWORD *)v3, &LCData) )
      return ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
    v9 = 0;
  }
  else
  {
    *(_DWORD *)v4 |= 0x200u;
    if ( *(_DWORD *)(v3 + 16) || *(_DWORD *)(v3 + 12) == v8 || sub_10039899(*(_DWORD *)v3) != *(_DWORD *)(v3 + 12) )
      goto LABEL_28;
    v9 = 1;
  }
  if ( sub_1004F8E5(v3, v4, v5, v9) )
  {
LABEL_28:
    *(_DWORD *)v4 |= 0x100u;
    if ( !*(_DWORD *)(v4 + 4) )
      *(_DWORD *)(v4 + 4) = v5;
  }
  return ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
}
// 10073200: using guessed type int __security_cookie;

//----- (1004F710) --------------------------------------------------------
signed int __userpurge sub_1004F710<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  int v7; // [sp-8h] [bp-108h]@5
  WCHAR LCData; // [sp+Ch] [bp-F4h]@1
  unsigned int v9; // [sp+FCh] [bp-4h]@1
  int v10; // [sp+100h] [bp+0h]@1

  v9 = (unsigned int)&v10 ^ __security_cookie;
  v3 = sub_10041952(a1, a2) + 156;
  v4 = *(_DWORD *)(sub_10041952(v3, a2) + 952);
  v5 = sub_1004F7E9(a3);
  if ( !GetLocaleInfoW(v5, *(_DWORD *)(v3 + 16) != 0 ? 3 : 4097, &LCData, 240) )
  {
    *(_DWORD *)v4 = 0;
    return 1;
  }
  if ( sub_1004AAEB(v3, v4, *(_DWORD *)v3, &LCData) )
  {
    if ( *(_DWORD *)(v3 + 16) || !*(_DWORD *)(v3 + 12) || sub_1004AAEB(v3, v4, *(_DWORD *)v3, &LCData) )
      return ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
    v7 = 0;
  }
  else
  {
    if ( *(_DWORD *)(v3 + 16) )
    {
LABEL_11:
      *(_DWORD *)v4 |= 4u;
      *(_DWORD *)(v4 + 4) = v5;
      *(_DWORD *)(v4 + 8) = v5;
      return ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
    }
    v7 = 1;
  }
  if ( sub_1004F8E5(v3, v4, v5, v7) )
    goto LABEL_11;
  return ~(unsigned __int8)(*(_DWORD *)v4 >> 2) & 1;
}
// 10073200: using guessed type int __security_cookie;

//----- (1004F7E9) --------------------------------------------------------
int __cdecl sub_1004F7E9(int a1)
{
  int v1; // edx@1
  int v2; // ecx@1
  int i; // esi@1

  v1 = a1;
  v2 = *(_WORD *)a1;
  for ( i = 0; (_WORD)v2; v2 = *(_WORD *)v1 )
  {
    v1 += 2;
    if ( (unsigned __int16)(v2 - 97) > 5u )
    {
      if ( (unsigned __int16)(v2 - 65) <= 5u )
        v2 += 65529;
    }
    else
    {
      v2 += 65497;
    }
    i = (unsigned __int16)v2 - 48 + 16 * i;
  }
  return i;
}

//----- (1004F838) --------------------------------------------------------
int __usercall sub_1004F838<eax>(int a1<ebx>, int a2<edi>, int LCData, int a4)
{
  int v4; // esi@1
  int result; // eax@6

  v4 = LCData;
  if ( LCData && *(_WORD *)LCData && sub_1004EAE7(LCData, (int)L"ACP") )
  {
    if ( sub_1004EAE7(v4, (int)L"OCP") )
      return sub_100548F8(a1, a2, v4);
    if ( GetLocaleInfoW(*(_DWORD *)(a4 + 8), 0x2000000Bu, (LPWSTR)&LCData, 2) )
      return LCData;
    return 0;
  }
  if ( !GetLocaleInfoW(*(_DWORD *)(a4 + 8), 0x20001004u, (LPWSTR)&LCData, 2) )
    return 0;
  result = LCData;
  if ( !LCData )
    result = GetACP();
  return result;
}
// 100667AC: using guessed type wchar_t aAcp[4];
// 100667B4: using guessed type wchar_t aOcp[4];

//----- (1004F8C3) --------------------------------------------------------
signed int __cdecl sub_1004F8C3(__int16 a1)
{
  unsigned int v1; // eax@1

  v1 = 0;
  while ( a1 != *(__int16 *)((char *)&word_100667BC + v1) )
  {
    v1 += 2;
    if ( v1 >= 0x14 )
      return 1;
  }
  return 0;
}
// 100667BC: using guessed type __int16 word_100667BC;

//----- (1004F8E5) --------------------------------------------------------
bool __usercall sub_1004F8E5<eax>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  int v4; // edi@1
  int v6; // esi@5
  WCHAR LCData[2]; // [sp+8h] [bp-4h]@1

  v4 = sub_10041952(a1, a2);
  return GetLocaleInfoW(a3 & 0x3FF | 0x400, 0x20000001u, LCData, 2)
      && (a3 == *(_DWORD *)LCData
       || !a4
       || (v6 = sub_1004F4F3(*(unsigned __int16 **)(v4 + 156)), v6 != sub_10039899(*(_DWORD *)(v4 + 156))));
}

//----- (1004F94D) --------------------------------------------------------
signed int __usercall sub_1004F94D<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  int v5; // ebx@1
  int v6; // ecx@3
  int v7; // eax@25
  unsigned int v8; // esi@25
  int v10; // [sp+14h] [bp-10h]@1
  LCID Locale; // [sp+18h] [bp-Ch]@23
  LCID v12; // [sp+1Ch] [bp-8h]@23
  unsigned int v13; // [sp+20h] [bp-4h]@1
  int v14; // [sp+24h] [bp+0h]@1

  v13 = (unsigned int)&v14 ^ __security_cookie;
  v5 = sub_10041952(a1, a2) + 156;
  sub_100391F0(&v10, 0, 12);
  *(_DWORD *)(sub_10041952(v5, a2) + 952) = &v10;
  if ( !a3 )
  {
    v10 |= 0x104u;
LABEL_23:
    Locale = GetUserDefaultLCID();
    v12 = Locale;
    goto LABEL_24;
  }
  a2 = v5 + 4;
  v6 = 0;
  *(_DWORD *)v5 = a3;
  *(_DWORD *)(v5 + 4) = a3 + 128;
  if ( a3 != -128 )
  {
    if ( *(_WORD *)(a3 + 128) )
    {
      sub_1004F101((int)&off_100664D0, dword_100667A8 - 1, (int *)(v5 + 4));
      v6 = 0;
    }
  }
  v10 = v6;
  if ( !*(_DWORD *)v5 || **(_WORD **)v5 == (_WORD)v6 )
  {
    if ( !*(_DWORD *)a2 || **(_WORD **)a2 == (_WORD)v6 )
    {
      v10 = 260;
      goto LABEL_23;
    }
    sub_1004F3DD(v5, a2, (int)&v10);
LABEL_24:
    if ( !v10 )
      return 0;
    goto LABEL_25;
  }
  if ( *(_DWORD *)a2 && **(_WORD **)a2 != (_WORD)v6 )
    sub_1004F41D(v5, a2, (int)&v10);
  else
    sub_1004F49A(v5, a2, (int)&v10);
  if ( !v10 )
  {
    if ( sub_1004F101((int)&off_10065A20, dword_100667A4 - 1, (int *)v5) )
    {
      if ( *(_DWORD *)a2 && **(_WORD **)a2 )
        sub_1004F41D(v5, a2, (int)&v10);
      else
        sub_1004F49A(v5, a2, (int)&v10);
    }
    goto LABEL_24;
  }
LABEL_25:
  v7 = sub_1004F838(v5, a2, a3 != 0 ? a3 + 256 : 0, (int)&v10);
  v8 = v7;
  if ( v7 && v7 != 65000 && v7 != 65001 && IsValidCodePage((unsigned __int16)v7) && IsValidLocale(Locale, 1u) )
  {
    if ( a4 )
      *(_DWORD *)a4 = v8;
    sub_10039B97(Locale, v5 + 592, 85);
    if ( !a5 )
      return 1;
    sub_10039B97(Locale, a5 + 288, 85);
    if ( GetLocaleInfoW(Locale, 4097u, (LPWSTR)a5, 64) && GetLocaleInfoW(v12, 0x1002u, (LPWSTR)(a5 + 128), 64) )
    {
      sub_100547DC(a5, (int)GetLocaleInfoW, v8, a5 + 256, 0x10u, 0xAu);
      return 1;
    }
  }
  return 0;
}
// 10065A20: using guessed type wchar_t *off_10065A20;
// 100664D0: using guessed type wchar_t *off_100664D0;
// 100667A4: using guessed type int dword_100667A4;
// 100667A8: using guessed type int dword_100667A8;
// 10073200: using guessed type int __security_cookie;

//----- (1004FB67) --------------------------------------------------------
signed int __usercall sub_1004FB67<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // eax@3
  int v5; // eax@7
  signed int v6; // eax@10
  signed int v7; // ST08_4@10
  const CHAR *v8; // ST04_4@10
  int v9; // edx@10
  int v10; // ST00_4@10
  int v11; // eax@15
  signed int v12; // esi@15
  signed int result; // eax@23
  signed int *v14; // ecx@23

  if ( !a4 )
  {
    *(_DWORD *)sub_10037649(a3) = 22;
    sub_1003A151(a3, 0);
    return -1;
  }
  v4 = *(_DWORD *)(a4 + 12);
  if ( !(v4 & 0x83) || v4 & 0x40 )
    return -1;
  if ( v4 & 2 )
  {
    *(_DWORD *)(a4 + 12) = v4 | 0x20;
    return -1;
  }
  v5 = v4 | 1;
  *(_DWORD *)(a4 + 12) = v5;
  if ( v5 & 0x10C )
    *(_DWORD *)a4 = *(_DWORD *)(a4 + 8);
  else
    sub_10050964(a1, a2, a3, a4);
  v7 = *(_DWORD *)(a4 + 24);
  v8 = *(const CHAR **)(a4 + 8);
  v6 = sub_1004FC88(a3, a4, a4);
  sub_10054B65(v9, v10, a3, a4, v6, v8, v7);
  *(_DWORD *)(a4 + 4) = v6;
  if ( !v6 || v6 == -1 )
  {
    *(_DWORD *)(a4 + 12) |= v6 != 0 ? 32 : 16;
    *(_DWORD *)(a4 + 4) = 0;
    return -1;
  }
  if ( !(*(_BYTE *)(a4 + 12) & 0x82) )
  {
    if ( sub_1004FC88(a3, a4, a4) == -1 || sub_1004FC88(a3, a4, a4) == -2 )
    {
      v11 = (int)&unk_10074060;
    }
    else
    {
      v12 = sub_1004FC88(a3, a4, a4) >> 5;
      v11 = dword_10075F80[v12] + ((sub_1004FC88(a3, a4, a4) & 0x1F) << 6);
    }
    if ( (*(_BYTE *)(v11 + 4) & 0x82) == -126 )
      *(_DWORD *)(a4 + 12) |= 0x2000u;
  }
  if ( *(_DWORD *)(a4 + 24) == 512 )
  {
    if ( *(_BYTE *)(a4 + 12) & 8 )
    {
      if ( !(*(_DWORD *)(a4 + 12) & 0x400) )
        *(_DWORD *)(a4 + 24) = 4096;
    }
  }
  v14 = *(signed int **)a4;
  --*(_DWORD *)(a4 + 4);
  result = *(_BYTE *)v14;
  *(_DWORD *)a4 = (char *)v14 + 1;
  return result;
}
// 10075F80: using guessed type int dword_10075F80[];

//----- (1004FC88) --------------------------------------------------------
signed int __usercall sub_1004FC88<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  signed int result; // eax@2

  if ( a3 )
  {
    result = *(_DWORD *)(a3 + 16);
  }
  else
  {
    *(_DWORD *)sub_10037649(a1) = 22;
    sub_1003A151(a1, a2);
    result = -1;
  }
  return result;
}

//----- (1004FCAC) --------------------------------------------------------
signed int __usercall sub_1004FCAC<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, int a5)
{
  signed int v5; // eax@2
  int v7; // eax@24
  int v8; // eax@28

  if ( !(*(_BYTE *)(a5 + 12) & 0x40) )
  {
    v5 = sub_1004FC88(a3, -1, a5);
    if ( v5 == -1 || v5 == -2 )
      a1 = (int)&unk_10074060;
    else
      a1 = dword_10075F80[v5 >> 5] + ((v5 & 0x1F) << 6);
    if ( *(_BYTE *)(a1 + 36) & 0x7F
      || (v5 == -1 || v5 == -2 ? (a2 = (int)&unk_10074060) : (a2 = dword_10075F80[v5 >> 5] + ((v5 & 0x1F) << 6)),
          *(_BYTE *)(a2 + 36) & 0x80) )
    {
      *(_DWORD *)sub_10037649((int)&unk_10074060) = 22;
      sub_1003A151((int)&unk_10074060, -1);
      return -1;
    }
  }
  if ( a4 == -1 || !(*(_BYTE *)(a5 + 12) & 1) && (!(*(_BYTE *)(a5 + 12) & 0x80) || *(_BYTE *)(a5 + 12) & 2) )
    return -1;
  if ( !*(_DWORD *)(a5 + 8) )
    sub_10050964(a1, a2, a4, a5);
  if ( *(_DWORD *)a5 == *(_DWORD *)(a5 + 8) )
  {
    if ( *(_DWORD *)(a5 + 4) )
      return -1;
    ++*(_DWORD *)a5;
  }
  --*(_DWORD *)a5;
  v7 = *(_DWORD *)a5;
  if ( *(_BYTE *)(a5 + 12) & 0x40 )
  {
    if ( *(_BYTE *)v7 != (_BYTE)a4 )
    {
      *(_DWORD *)a5 = v7 + 1;
      return -1;
    }
  }
  else
  {
    *(_BYTE *)v7 = a4;
  }
  v8 = *(_DWORD *)(a5 + 12);
  ++*(_DWORD *)(a5 + 4);
  *(_DWORD *)(a5 + 12) = v8 & 0xFFFFFFEF | 1;
  return (unsigned __int8)a4;
}
// 10075F80: using guessed type int dword_10075F80[];

//----- (1004FD8C) --------------------------------------------------------
signed int __usercall sub_1004FD8C<eax>(int a1<edi>, LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int a4, int a5)
{
  signed int v6; // edi@11
  int v7; // edi@13
  char v8; // cf@14
  int v9; // [sp+8h] [bp-10h]@8
  int v10; // [sp+10h] [bp-8h]@23
  char v11; // [sp+14h] [bp-4h]@22

  if ( !lpMultiByteStr || !a4 )
    return 0;
  if ( !*lpMultiByteStr )
  {
    if ( lpWideCharStr )
      *lpWideCharStr = 0;
    return 0;
  }
  sub_100301AD((int)&v9, a4, a1, a5);
  if ( !*(_DWORD *)(v9 + 168) )
  {
    if ( lpWideCharStr )
      *lpWideCharStr = (unsigned __int8)*lpMultiByteStr;
    v6 = 1;
    goto LABEL_22;
  }
  if ( !sub_1004261D(a4, a1, *lpMultiByteStr, (int)&v9) )
  {
    v6 = 1;
    if ( MultiByteToWideChar(*(_DWORD *)(v9 + 4), 9u, lpMultiByteStr, 1, lpWideCharStr, lpWideCharStr != 0) )
      goto LABEL_22;
    goto LABEL_21;
  }
  v7 = v9;
  if ( *(_DWORD *)(v9 + 116) <= 1 )
    goto LABEL_27;
  v8 = (unsigned int)a4 < *(_DWORD *)(v9 + 116);
  if ( a4 < *(_DWORD *)(v9 + 116) )
  {
LABEL_17:
    if ( !v8 && lpMultiByteStr[1] )
      goto LABEL_19;
LABEL_21:
    v6 = -1;
    *(_DWORD *)sub_10037649(a4) = 42;
    goto LABEL_22;
  }
  v7 = v9;
  if ( !MultiByteToWideChar(
          *(_DWORD *)(v9 + 4),
          9u,
          lpMultiByteStr,
          *(_DWORD *)(v9 + 116),
          lpWideCharStr,
          lpWideCharStr != 0) )
  {
LABEL_27:
    v8 = (unsigned int)a4 < *(_DWORD *)(v7 + 116);
    goto LABEL_17;
  }
LABEL_19:
  v6 = *(_DWORD *)(v7 + 116);
LABEL_22:
  if ( v11 )
    *(_DWORD *)(v10 + 112) &= 0xFFFFFFFDu;
  return v6;
}

//----- (1004FE7F) --------------------------------------------------------
signed int __usercall sub_1004FE7F<eax>(int a1<edi>, LPWSTR lpWideCharStr, LPCSTR lpMultiByteStr, int a4)
{
  return sub_1004FD8C(a1, lpWideCharStr, lpMultiByteStr, a4, 0);
}

//----- (1004FE97) --------------------------------------------------------
int __usercall sub_1004FE97<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  if ( a3 == -2 )
  {
    *(_DWORD *)sub_10037649(a1) = 9;
  }
  else
  {
    if ( a3 >= 0 && a3 < (unsigned int)dword_10076898 )
      return *(_BYTE *)(dword_10075F80[a3 >> 5] + ((a3 & 0x1F) << 6) + 4) & 0x40;
    *(_DWORD *)sub_10037649(a1) = 9;
    sub_1003A151(a1, a2);
  }
  return 0;
}
// 10075F80: using guessed type int dword_10075F80[];
// 10076898: using guessed type int dword_10076898;

//----- (1004FEEB) --------------------------------------------------------
void __usercall sub_1004FEEB(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5, const void *a6, int nNumberOfBytesToWrite)
{
  int v7; // [sp-4h] [bp-34h]@6

  if ( a5 == -2 )
  {
    *(_DWORD *)sub_10037615(a3) = 0;
    *(_DWORD *)sub_10037649(a3) = 9;
  }
  else
  {
    if ( a5 >= 0
      && a5 < (unsigned int)dword_10076898
      && (a3 = a5 >> 5, a4 = (a5 & 0x1F) << 6, *(_BYTE *)(dword_10075F80[a5 >> 5] + a4 + 4) & 1) )
    {
      sub_100553FC(a1, a2, a3, a5);
      if ( *(_BYTE *)(dword_10075F80[a3] + a4 + 4) & 1 )
      {
        sub_1004FFCD(v7, a3, a4, a5, a5, a6, nNumberOfBytesToWrite);
      }
      else
      {
        *(_DWORD *)sub_10037649(a3) = 9;
        *(_DWORD *)sub_10037615(a3) = 0;
      }
      sub_10055575(a5);
    }
    else
    {
      *(_DWORD *)sub_10037615(a3) = 0;
      *(_DWORD *)sub_10037649(a3) = 9;
      sub_1003A151(a3, a4);
    }
  }
}
// 10075F80: using guessed type int dword_10075F80[];
// 10076898: using guessed type int dword_10076898;

//----- (1004FFCD) --------------------------------------------------------
int __usercall sub_1004FFCD<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<esi>, signed int a5, const void *a6, int nNumberOfBytesToWrite)
{
  signed int v7; // eax@1
  int v8; // edi@1
  int v10; // ecx@5
  int v11; // esi@5
  unsigned __int8 v12; // zf@14
  UINT v13; // eax@17
  LPCVOID v14; // edx@17
  const CHAR *v15; // ecx@17
  int v16; // eax@18
  int v17; // edx@20
  unsigned __int8 v18; // cl@20
  LPCSTR v19; // eax@25
  int v20; // eax@29
  unsigned __int8 v21; // zf@38
  signed __int16 v22; // ax@41
  signed __int16 v23; // ax@43
  int v24; // esi@49
  int v25; // eax@51
  LPCVOID v26; // eax@53
  int v27; // eax@54
  char *v28; // edx@54
  char *v29; // ebx@54
  char v30; // cl@56
  int v31; // ecx@56
  char v32; // zf@56
  DWORD v33; // ecx@63
  int v34; // eax@65
  unsigned int v35; // edx@65
  char *v36; // ebx@65
  int v37; // edi@65
  __int16 v38; // si@67
  char *v39; // eax@75
  unsigned int v40; // edx@75
  int v41; // ecx@75
  DWORD v42; // esi@75
  __int16 v43; // di@77
  const CHAR *v44; // eax@80
  int v45; // ecx@81
  DWORD v46; // eax@85
  UINT v47; // [sp+0h] [bp-1AF0h]@17
  int v48; // [sp+4h] [bp-1AECh]@5
  DWORD Mode; // [sp+Ch] [bp-1AE4h]@14
  char v50; // [sp+13h] [bp-1ADDh]@56
  DWORD NumberOfBytesWritten; // [sp+14h] [bp-1ADCh]@17
  int v52; // [sp+18h] [bp-1AD8h]@59
  int v53; // [sp+1Ch] [bp-1AD4h]@1
  int v54; // [sp+20h] [bp-1AD0h]@5
  LPCSTR lpMultiByteStr; // [sp+24h] [bp-1ACCh]@17
  int v56; // [sp+28h] [bp-1AC8h]@18
  const WCHAR WideCharStr[2]; // [sp+2Ch] [bp-1AC4h]@1
  const void *v58; // [sp+30h] [bp-1AC0h]@1
  LPCVOID lpBuffer; // [sp+34h] [bp-1ABCh]@1
  char v60; // [sp+38h] [bp-1AB8h]@54
  CHAR MultiByteStr[3416]; // [sp+6E0h] [bp-1410h]@80
  char v62; // [sp+1438h] [bp-6B8h]@75
  void *v63; // [sp+1AD0h] [bp-20h]@30
  char *v64; // [sp+1AD4h] [bp-1Ch]@30
  LPCSTR v65[3]; // [sp+1AD8h] [bp-18h]@14
  signed int v66; // [sp+1AE0h] [bp-10h]@14
  int Buffer; // [sp+1AE4h] [bp-Ch]@5
  int v68; // [sp+1AE8h] [bp-8h]@5
  int v69; // [sp+1AECh] [bp-4h]@1

  sub_1004D2F0(0x1AF0u, a1);
  v7 = a5;
  v69 = a3;
  v8 = 0;
  v58 = (const void *)a5;
  lpBuffer = a6;
  *(_DWORD *)WideCharStr = 0;
  v53 = 0;
  if ( !nNumberOfBytesToWrite )
    return 0;
  if ( !a6 )
  {
    *(_DWORD *)sub_10037615(a2) = 0;
    *(_DWORD *)sub_10037649(a2) = 22;
    sub_1003A151(a2, 0);
    return -1;
  }
  v68 = a2;
  Buffer = a4;
  v11 = (a5 & 0x1F) << 6;
  v54 = a5 >> 5;
  v10 = dword_10075F80[a5 >> 5];
  v48 = v11;
  LOBYTE(a2) = (char)(2 * *(_BYTE *)(v11 + v10 + 36)) >> 1;
  if ( (_BYTE)a2 == 2 || (_BYTE)a2 == 1 )
  {
    if ( !(~(_BYTE)nNumberOfBytesToWrite & 1) )
    {
      *(_DWORD *)sub_10037615(a2) = 0;
      *(_DWORD *)sub_10037649(a2) = 22;
      sub_1003A151(a2, 0);
      return -1;
    }
    v7 = (signed int)v58;
  }
  if ( *(_BYTE *)(v11 + v10 + 4) & 0x20 )
    sub_100508F3(a2, 0, v7, 0i64, 2u);
  if ( !sub_1004FE97(a2, 0, (signed int)v58)
    || !(*(_BYTE *)(v11 + dword_10075F80[v54] + 4) & 0x80)
    || (v12 = *(_DWORD *)(*(_DWORD *)(sub_10041952(a2, 0) + 108) + 168) == 0,
        v66 = (signed int)&Mode,
        v65[1] = *(LPCSTR *)(v11 + dword_10075F80[v54]),
        v58 = (const void *)v12,
        !GetConsoleMode((HANDLE)v65[1], &Mode))
    || v58 && !(_BYTE)a2 )
  {
    v25 = dword_10075F80[v54];
    if ( *(_BYTE *)(v11 + v25 + 4) & 0x80 )
    {
      v14 = lpBuffer;
      v24 = 0;
      v56 = 0;
      if ( (_BYTE)a2 )
      {
        v33 = (DWORD)lpBuffer;
        if ( (_BYTE)a2 == 2 )
        {
          v58 = lpBuffer;
          if ( (unsigned int)nNumberOfBytesToWrite <= 0 )
            goto LABEL_98;
          while ( 1 )
          {
            Mode = 0;
            v37 = v53;
            v34 = v33 - (_DWORD)v14;
            v35 = 0;
            v36 = &v60;
            do
            {
              if ( v34 >= (unsigned int)nNumberOfBytesToWrite )
                break;
              v38 = *(_WORD *)v33;
              v33 += 2;
              v34 += 2;
              v58 = (const void *)v33;
              if ( v38 == 10 )
              {
                *(_WORD *)v36 = 13;
                v33 = (DWORD)v58;
                v37 += 2;
                v36 += 2;
                v35 += 2;
              }
              *(_WORD *)v36 = v38;
              v35 += 2;
              v36 += 2;
            }
            while ( v35 < 0x13FE );
            a2 = v36 - &v60;
            v66 = 0;
            v65[1] = (LPCSTR)&v52;
            v65[0] = (LPCSTR)a2;
            v64 = &v60;
            v53 = v37;
            v63 = *(void **)(v48 + dword_10075F80[v54]);
            v24 = v56;
            v8 = *(_DWORD *)WideCharStr;
            if ( !WriteFile(v63, &v60, a2, (LPDWORD)&v52, 0) )
              break;
            v8 = v52 + *(_DWORD *)WideCharStr;
            v14 = lpBuffer;
            *(_DWORD *)WideCharStr += v52;
            if ( v52 >= a2 )
            {
              v33 = (DWORD)v58;
              if ( v58 - lpBuffer < nNumberOfBytesToWrite )
                continue;
            }
            goto LABEL_93;
          }
        }
        else
        {
          a2 = nNumberOfBytesToWrite;
          NumberOfBytesWritten = (DWORD)lpBuffer;
          if ( !nNumberOfBytesToWrite )
            goto LABEL_98;
          while ( 1 )
          {
            Mode = 0;
            v42 = NumberOfBytesWritten;
            v41 = v33 - (_DWORD)v14;
            v40 = 0;
            v39 = &v62;
            do
            {
              if ( v41 >= (unsigned int)nNumberOfBytesToWrite )
                break;
              v43 = *(_WORD *)v42;
              v42 += 2;
              v41 += 2;
              NumberOfBytesWritten = v42;
              if ( v43 == 10 )
              {
                *(_WORD *)v39 = 13;
                v42 = NumberOfBytesWritten;
                v39 += 2;
                v40 += 2;
              }
              *(_WORD *)v39 = v43;
              v40 += 2;
              v39 += 2;
            }
            while ( v40 < 0x6A8 );
            v44 = (const CHAR *)WideCharToMultiByte(
                                  0xFDE9u,
                                  0,
                                  (LPCWSTR)&v62,
                                  (signed int)(v39 - &v62) / 2,
                                  MultiByteStr,
                                  3413,
                                  0,
                                  0);
            v24 = v56;
            v8 = *(_DWORD *)WideCharStr;
            lpMultiByteStr = v44;
            if ( !v44 )
              break;
            v45 = 0;
            v58 = 0;
            while ( 1 )
            {
              v66 = 0;
              v65[1] = (LPCSTR)&v52;
              v65[0] = &v44[-v45];
              v64 = &MultiByteStr[v45];
              v63 = *(void **)(v48 + dword_10075F80[v54]);
              if ( !WriteFile(v63, &MultiByteStr[v45], (DWORD)&v44[-v45], (LPDWORD)&v52, 0) )
                break;
              v45 = (int)((char *)v58 + v52);
              v44 = lpMultiByteStr;
              v58 = (const void *)v45;
              if ( (signed int)lpMultiByteStr <= v45 )
                goto LABEL_86;
            }
            v46 = GetLastError();
            v45 = (int)v58;
            v24 = v46;
            v44 = lpMultiByteStr;
            v56 = v24;
LABEL_86:
            if ( (signed int)v44 > v45 )
              goto LABEL_92;
            v33 = NumberOfBytesWritten;
            v14 = lpBuffer;
            v8 = NumberOfBytesWritten - (_DWORD)lpBuffer;
            *(_DWORD *)WideCharStr = NumberOfBytesWritten - (_DWORD)lpBuffer;
            if ( NumberOfBytesWritten - (_DWORD)lpBuffer >= nNumberOfBytesToWrite )
              goto LABEL_93;
          }
        }
      }
      else
      {
        v26 = lpBuffer;
        *(_DWORD *)WideCharStr = lpBuffer;
        if ( (unsigned int)nNumberOfBytesToWrite <= 0 )
          goto LABEL_98;
        while ( 1 )
        {
          v27 = v26 - v14;
          v28 = *(char **)WideCharStr;
          v29 = &v60;
          v58 = 0;
          do
          {
            if ( v27 >= (unsigned int)nNumberOfBytesToWrite )
              break;
            v30 = *v28;
            ++v27;
            v50 = v30;
            v32 = v30 == 10;
            v31 = (int)v58;
            *(_DWORD *)WideCharStr = v28 + 1;
            if ( v32 )
            {
              ++v53;
              *v29++ = 13;
              ++v31;
            }
            *v29 = v50;
            v28 = *(char **)WideCharStr;
            ++v29;
            v58 = (const void *)(v31 + 1);
          }
          while ( (unsigned int)(v31 + 1) < 0x13FF );
          a2 = v29 - &v60;
          v66 = 0;
          v65[1] = (LPCSTR)&v52;
          v65[0] = (LPCSTR)a2;
          v64 = &v60;
          v63 = *(void **)(v48 + dword_10075F80[v54]);
          if ( !WriteFile(v63, &v60, a2, (LPDWORD)&v52, 0) )
            break;
          v8 += v52;
          v14 = lpBuffer;
          if ( v52 >= a2 )
          {
            v26 = *(LPCVOID *)WideCharStr;
            if ( *(_DWORD *)WideCharStr - (_DWORD)lpBuffer < (unsigned int)nNumberOfBytesToWrite )
              continue;
          }
          goto LABEL_93;
        }
      }
    }
    else
    {
      v66 = 0;
      v65[1] = (LPCSTR)&v52;
      v65[0] = (LPCSTR)nNumberOfBytesToWrite;
      v64 = (char *)lpBuffer;
      v63 = *(void **)(v11 + v25);
      if ( WriteFile(v63, lpBuffer, nNumberOfBytesToWrite, (LPDWORD)&v52, 0) )
      {
        v8 = v52;
        v24 = 0;
        goto LABEL_92;
      }
    }
LABEL_91:
    v24 = GetLastError();
    goto LABEL_92;
  }
  v13 = GetConsoleCP();
  v14 = lpBuffer;
  NumberOfBytesWritten = 0;
  v15 = (const CHAR *)lpBuffer;
  v47 = v13;
  lpMultiByteStr = (LPCSTR)lpBuffer;
  if ( (unsigned int)nNumberOfBytesToWrite <= 0 )
  {
    v24 = (int)v58;
    goto LABEL_94;
  }
  v16 = 0;
  v56 = 0;
  while ( (_BYTE)a2 )
  {
    if ( (_BYTE)a2 == 1 || (_BYTE)a2 == 2 )
    {
      v21 = *(_WORD *)v15 == 10;
      *(_DWORD *)WideCharStr = *(_WORD *)v15;
      v15 += 2;
      v16 = v56 + 2;
      lpMultiByteStr = v15;
      v56 += 2;
      v58 = (const void *)v21;
    }
    if ( (_BYTE)a2 != 1 && (_BYTE)a2 != 2 )
      goto LABEL_46;
    v22 = sub_1005559B((DWORD)v15, WideCharStr[0]);
    if ( v22 != WideCharStr[0] )
      goto LABEL_91;
    v8 += 2;
    if ( v58 )
    {
      *(_DWORD *)WideCharStr = 13;
      v23 = sub_1005559B(v66, 13);
      if ( v23 != WideCharStr[0] )
        goto LABEL_91;
      ++v8;
      ++v53;
    }
LABEL_45:
    v16 = v56;
    v15 = lpMultiByteStr;
LABEL_46:
    if ( v16 >= (unsigned int)nNumberOfBytesToWrite )
      goto LABEL_49;
  }
  v18 = *v15;
  v58 = (const void *)(v18 == 10);
  v17 = dword_10075F80[v54];
  if ( *(_DWORD *)(v11 + v17 + 56) )
  {
    LOBYTE(Buffer) = *(_BYTE *)(v11 + v17 + 52);
    v66 = 2;
    BYTE1(Buffer) = v18;
    *(_DWORD *)(v11 + v17 + 56) = 0;
    v65[1] = (LPCSTR)&Buffer;
LABEL_27:
    if ( sub_1004FE7F(v8, (LPWSTR)WideCharStr, v65[1], v66) == -1 )
      goto LABEL_49;
    v19 = lpMultiByteStr;
LABEL_29:
    ++v56;
    lpMultiByteStr = v19 + 1;
    v20 = WideCharToMultiByte(v47, 0, WideCharStr, 1, (LPSTR)&Buffer, 5, 0, 0);
    Mode = v20;
    if ( !v20 )
      goto LABEL_49;
    v66 = 0;
    v65[1] = (LPCSTR)&NumberOfBytesWritten;
    v65[0] = (LPCSTR)v20;
    v64 = (char *)&Buffer;
    v63 = *(void **)(v11 + dword_10075F80[v54]);
    if ( !WriteFile(v63, &Buffer, v20, &NumberOfBytesWritten, 0) )
      goto LABEL_91;
    v8 = v53 + v56;
    if ( (signed int)NumberOfBytesWritten < (signed int)Mode )
      goto LABEL_49;
    if ( v58 )
    {
      v66 = 0;
      v65[1] = (LPCSTR)&NumberOfBytesWritten;
      v65[0] = (LPCSTR)1;
      v64 = (char *)&Buffer;
      LOBYTE(Buffer) = 13;
      v63 = *(void **)(v11 + dword_10075F80[v54]);
      if ( !WriteFile(v63, &Buffer, 1u, &NumberOfBytesWritten, 0) )
        goto LABEL_91;
      if ( (signed int)NumberOfBytesWritten < 1 )
        goto LABEL_49;
      ++v53;
      ++v8;
    }
    goto LABEL_45;
  }
  if ( !sub_10042653(a2, v8, v18) )
  {
    v66 = 1;
    v65[1] = lpMultiByteStr;
    goto LABEL_27;
  }
  if ( nNumberOfBytesToWrite + lpBuffer - lpMultiByteStr > 1 )
  {
    if ( sub_1004FE7F(v8, (LPWSTR)WideCharStr, lpMultiByteStr, 2) == -1 )
      goto LABEL_49;
    v19 = lpMultiByteStr + 1;
    ++v56;
    goto LABEL_29;
  }
  a2 = v54;
  ++v8;
  *(_BYTE *)(v11 + dword_10075F80[v54] + 52) = *lpMultiByteStr;
  *(_DWORD *)(v11 + dword_10075F80[a2] + 56) = 1;
LABEL_49:
  v24 = (int)v58;
LABEL_92:
  v14 = lpBuffer;
LABEL_93:
  if ( v8 )
    return v8 - v53;
LABEL_94:
  if ( v24 )
  {
    if ( v24 == 5 )
    {
      *(_DWORD *)sub_10037649(5) = 9;
      *(_DWORD *)sub_10037615(5) = 5;
    }
    else
    {
      sub_10037628(5, v24);
    }
    return -1;
  }
LABEL_98:
  if ( !(*(_BYTE *)(v48 + dword_10075F80[v54] + 4) & 0x40) || *(_BYTE *)v14 != 26 )
  {
    *(_DWORD *)sub_10037649(a2) = 28;
    *(_DWORD *)sub_10037615(a2) = 0;
    return -1;
  }
  return 0;
}
// 10075F80: using guessed type int dword_10075F80[];
// 1004FFCD: using guessed type CHAR MultiByteStr[3416];

//----- (100507F7) --------------------------------------------------------
void __usercall sub_100507F7(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4, LARGE_INTEGER liDistanceToMove, DWORD dwMoveMethod)
{
  if ( a4 == -2 )
  {
    *(_DWORD *)sub_10037615(a3) = 0;
    *(_DWORD *)sub_10037649(a3) = 9;
  }
  else
  {
    if ( a4 >= 0
      && a4 < (unsigned int)dword_10076898
      && (a3 = (a4 & 0x1F) << 6, *(_BYTE *)(dword_10075F80[a4 >> 5] + a3 + 4) & 1) )
    {
      sub_100553FC(a1, a2, a3, a4);
      if ( *(_BYTE *)(dword_10075F80[a4 >> 5] + a3 + 4) & 1 )
      {
        sub_100508F3(a3, a4, a4, liDistanceToMove, dwMoveMethod);
      }
      else
      {
        *(_DWORD *)sub_10037649(a3) = 9;
        *(_DWORD *)sub_10037615(a3) = 0;
      }
      sub_10055575(a4);
    }
    else
    {
      *(_DWORD *)sub_10037615(a3) = 0;
      *(_DWORD *)sub_10037649(a3) = 9;
      sub_1003A151(a3, a4);
    }
  }
}
// 10075F80: using guessed type int dword_10075F80[];
// 10076898: using guessed type int dword_10076898;

//----- (100508F3) --------------------------------------------------------
LARGE_INTEGER __usercall sub_100508F3<edx:eax>(int a1<ebx>, int a2<edi>, signed int a3, LARGE_INTEGER liDistanceToMove, DWORD dwMoveMethod)
{
  void *v5; // eax@1
  int v7; // eax@5
  LARGE_INTEGER NewFilePointer; // [sp+8h] [bp-8h]@4

  v5 = (void *)sub_1005550E(a1, a2, a3);
  if ( v5 == (void *)-1 )
  {
    *(_DWORD *)sub_10037649(a1) = 9;
    return (LARGE_INTEGER)-1i64;
  }
  if ( !SetFilePointerEx(v5, liDistanceToMove, &NewFilePointer, dwMoveMethod) )
  {
    v7 = GetLastError();
    sub_10037628(a1, v7);
    return (LARGE_INTEGER)-1i64;
  }
  *(_BYTE *)(dword_10075F80[a3 >> 5] + ((a3 & 0x1F) << 6) + 4) &= 0xFDu;
  return NewFilePointer;
}
// 10075F80: using guessed type int dword_10075F80[];

//----- (10050964) --------------------------------------------------------
int __usercall sub_10050964<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // eax@1
  int result; // eax@4

  ++dword_10075F78;
  v4 = sub_10037530(a1, a2, a3, 4096);
  *(_DWORD *)(a4 + 8) = v4;
  if ( v4 )
  {
    *(_DWORD *)(a4 + 12) |= 8u;
    *(_DWORD *)(a4 + 24) = 4096;
  }
  else
  {
    *(_DWORD *)(a4 + 12) |= 4u;
    *(_DWORD *)(a4 + 8) = a4 + 20;
    *(_DWORD *)(a4 + 24) = 2;
  }
  result = *(_DWORD *)(a4 + 8);
  *(_DWORD *)(a4 + 4) = 0;
  *(_DWORD *)a4 = result;
  return result;
}
// 10075F78: using guessed type int dword_10075F78;

//----- (100509AA) --------------------------------------------------------
signed int __cdecl sub_100509AA(int a1, int a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@1
  signed int v6; // eax@3
  signed int v7; // ecx@3
  int v8; // edx@5
  int v9; // ecx@10
  int v10; // edx@13
  signed int result; // eax@14
  int v12; // ecx@14
  int v13; // esi@15
  int v14; // eax@18
  unsigned int v15; // eax@20
  int v16; // eax@35
  int v17; // eax@40
  char v18; // al@52
  int v19; // eax@64
  signed int v20; // eax@78
  int i; // eax@89
  signed int v22; // eax@92
  int v23; // eax@102
  int v24; // ST1C_4@108
  int v25; // esi@127
  int v26; // eax@134
  int v27; // edi@134
  int v28; // eax@138
  int v29; // edi@138
  int v30; // ST18_4@138
  int v31; // ST14_4@138
  int v32; // ST10_4@138
  int v33; // ST0C_4@138
  PVOID v34; // eax@138
  PVOID v35; // eax@140
  PVOID v36; // eax@143
  int v37; // edi@154
  int v38; // eax@156
  signed int v39; // edx@169
  char *k; // esi@175
  int v41; // ecx@178
  unsigned __int64 v42; // ST10_8@178
  int v43; // eax@178
  int v44; // ecx@178
  int v45; // edx@178
  int v46; // eax@181
  int j; // eax@187
  int v48; // eax@202
  int v49; // eax@207
  const WCHAR v50; // ST1C_2@210
  signed int v51; // eax@214
  signed int v52; // [sp-4h] [bp-290h]@147
  int v53; // [sp+Ch] [bp-280h]@138
  int v54; // [sp+10h] [bp-27Ch]@138
  char v55; // [sp+14h] [bp-278h]@1
  int v56; // [sp+1Ch] [bp-270h]@228
  char v57; // [sp+20h] [bp-26Ch]@227
  int v58; // [sp+28h] [bp-264h]@15
  int v59; // [sp+2Ch] [bp-260h]@22
  int v60; // [sp+30h] [bp-25Ch]@210
  int v61; // [sp+34h] [bp-258h]@1
  int v62; // [sp+38h] [bp-254h]@1
  LPVOID lpMem; // [sp+3Ch] [bp-250h]@14
  int v64; // [sp+40h] [bp-24Ch]@14
  int v65; // [sp+44h] [bp-248h]@1
  int v66; // [sp+48h] [bp-244h]@1
  int v67; // [sp+4Ch] [bp-240h]@78
  unsigned int v68; // [sp+50h] [bp-23Ch]@14
  int v69; // [sp+54h] [bp-238h]@1
  int v70; // [sp+58h] [bp-234h]@1
  int v71; // [sp+5Ch] [bp-230h]@1
  int v72; // [sp+60h] [bp-22Ch]@1
  char v73; // [sp+64h] [bp-228h]@153
  char v74; // [sp+65h] [bp-227h]@153
  int v75; // [sp+68h] [bp-224h]@14
  int v76; // [sp+6Ch] [bp-220h]@1
  int v77; // [sp+70h] [bp-21Ch]@14
  int v78; // [sp+74h] [bp-218h]@1
  int v79; // [sp+78h] [bp-214h]@1
  char v80; // [sp+7Fh] [bp-20Dh]@14
  CHAR UsedDefaultChar; // [sp+80h] [bp-20Ch]@78
  char v82; // [sp+27Fh] [bp-Dh]@175
  char v83; // [sp+280h] [bp-Ch]@210
  unsigned int v84; // [sp+288h] [bp-4h]@1
  int v85; // [sp+28Ch] [bp+0h]@1

  v84 = (unsigned int)&v85 ^ __security_cookie;
  v5 = a4;
  v70 = a2;
  v4 = 0;
  v72 = a1;
  v78 = a4;
  v62 = 0;
  v79 = 0;
  v69 = 0;
  v76 = 0;
  v71 = 0;
  v65 = 0;
  v66 = 0;
  sub_100301AD((int)&v55, 0, a4, a3);
  v61 = sub_10037649(0);
  if ( !a1
    || !(*(_BYTE *)(a1 + 12) & 0x40)
    && ((v7 = sub_1004FC88(0, a4, a1), v6 = -1, v7 == -1) || v7 == -2 ? (v8 = (int)&unk_10074060) : (v8 = dword_10075F80[v7 >> 5] + ((v7 & 0x1F) << 6), v6 = -1),
        *(_BYTE *)(v8 + 36) & 0x7F
     || (v7 == v6 || v7 == -2 ? (v9 = (int)&unk_10074060) : (v9 = dword_10075F80[v7 >> 5] + ((v7 & 0x1F) << 6)),
         *(_BYTE *)(v9 + 36) & 0x80))
    || (v10 = v70, !v70) )
    goto LABEL_226;
  result = 0;
  v77 = 0;
  v68 = 0;
  lpMem = 0;
  v12 = *(_BYTE *)v70;
  v75 = 0;
  v80 = v12;
  LOBYTE(v64) = v12;
  if ( (_BYTE)v12 )
  {
    v13 = v58;
    while ( 1 )
    {
      ++v10;
      v70 = v10;
      if ( result < 0 )
        break;
      if ( (unsigned __int8)(v12 - 32) > 0x58u )
        v14 = 0;
      else
        v14 = *((_BYTE *)&aAcp[2] + (char)v12) & 0xF;
      v15 = (unsigned int)(unsigned __int8)*(&byte_100667D0[9 * v14] + v68) >> 4;
      v5 = v78;
      v68 = v15;
      if ( v15 == 8 )
        goto LABEL_226;
      switch ( v15 )
      {
        case 1u:
          v76 = -1;
          v4 = 0;
          v59 = 0;
          v65 = 0;
          v69 = 0;
          v71 = 0;
          v79 = 0;
          v66 = 0;
          goto LABEL_223;
        case 2u:
          switch ( (char)v12 )
          {
            case 32:
              v4 |= 2u;
              break;
            case 35:
              v4 |= 0x80u;
              break;
            case 43:
              v4 |= 1u;
              break;
            case 45:
              v4 |= 4u;
              break;
            default:
              if ( (char)v12 != 48 )
                goto LABEL_223;
              v4 |= 8u;
              break;
          }
          goto LABEL_33;
        case 3u:
          if ( (_BYTE)v12 == 42 )
          {
            v16 = *(_DWORD *)v78;
            v5 = v78 + 4;
            v78 += 4;
            v69 = v16;
            if ( v16 < 0 )
            {
              v4 |= 4u;
              v79 = v4;
              v69 = -v16;
            }
          }
          else
          {
            v69 *= 10;
            v12 = (char)v12 + v69 - 48;
            v69 = v12;
          }
          goto LABEL_223;
        case 4u:
          v76 = 0;
          goto LABEL_223;
        case 5u:
          if ( (_BYTE)v12 != 42 )
          {
            v76 = (char)v12 + 10 * v76 - 48;
            goto LABEL_222;
          }
          v17 = *(_DWORD *)v78;
          v5 = v78 + 4;
          v78 += 4;
          v76 = v17;
          if ( v17 < 0 )
            v76 = -1;
          goto LABEL_223;
        case 6u:
          if ( (_BYTE)v12 == 73 )
          {
            v18 = *(_BYTE *)v10;
            if ( *(_BYTE *)v10 == 54 && *(_BYTE *)(v10 + 1) == 52 )
            {
              v10 += 2;
              v4 |= 0x8000u;
              goto LABEL_33;
            }
            if ( v18 == 51 && *(_BYTE *)(v10 + 1) == 50 )
            {
              v10 += 2;
              v4 &= 0xFFFF7FFFu;
              goto LABEL_33;
            }
            if ( v18 != 100 && v18 != 105 && v18 != 111 && v18 != 117 && v18 != 120 && v18 != 88 )
            {
              v19 = 0;
              v68 = 0;
LABEL_66:
              v66 = v19;
              if ( sub_1004261D(v4, v78, v12, (int)&v55) )
              {
                sub_10051512(v4, v5, v64, v72, (int)&v75);
                LOBYTE(v64) = *(_BYTE *)v70++;
                if ( !(_BYTE)v64 )
                  goto LABEL_226;
              }
              sub_10051512(v4, v5, v64, v72, (int)&v75);
              goto LABEL_222;
            }
          }
          else
          {
            if ( (_BYTE)v12 == 104 )
            {
              v4 |= 0x20u;
              goto LABEL_33;
            }
            if ( (_BYTE)v12 == 108 )
            {
              if ( *(_BYTE *)v10 == 108 )
              {
                ++v10;
                v4 |= 0x1000u;
              }
              else
              {
                v4 |= 0x10u;
              }
              goto LABEL_33;
            }
            if ( (_BYTE)v12 == 119 )
            {
              v4 |= 0x800u;
LABEL_33:
              v79 = v4;
              goto LABEL_223;
            }
          }
          goto LABEL_223;
        case 0u:
          v19 = 0;
          goto LABEL_66;
        case 7u:
          if ( (char)v12 <= 100 )
          {
            if ( (char)v12 == 100 )
            {
LABEL_123:
              v4 |= 0x40u;
              v79 = v4;
              goto LABEL_124;
            }
            if ( (char)v12 <= 83 )
            {
              if ( (char)v12 == 83 )
              {
                if ( !(v4 & 0x830) )
                {
                  v4 |= 0x800u;
                  v79 = v4;
                }
                goto LABEL_84;
              }
              if ( (char)v12 != 65 )
              {
                if ( (char)v12 != 67 )
                {
                  if ( (char)v12 != 69 && (char)v12 != 71 )
                    goto LABEL_193;
                  goto LABEL_77;
                }
                if ( !(v4 & 0x830) )
                {
                  v4 |= 0x800u;
                  v79 = v4;
                }
LABEL_97:
                v5 = v78 + 4;
                v78 += 4;
                if ( v4 & 0x810 )
                {
                  if ( sub_10051733((int)&v77, &UsedDefaultChar, 512, *(_WORD *)(v5 - 4)) )
                    v65 = 1;
                }
                else
                {
                  UsedDefaultChar = *(_BYTE *)(v5 - 4);
                  v77 = 1;
                }
                v13 = (int)&UsedDefaultChar;
                goto LABEL_193;
              }
LABEL_77:
              LOBYTE(v12) = v12 + 32;
              v59 = 1;
              v80 = v12;
              goto LABEL_78;
            }
            if ( (char)v12 == 88 )
              goto LABEL_147;
            if ( (char)v12 == 90 )
            {
              v23 = *(_DWORD *)v78;
              v5 = v78 + 4;
              v78 += 4;
              if ( v23 )
              {
                v13 = *(_DWORD *)(v23 + 4);
                if ( v13 )
                {
                  v22 = *(_WORD *)v23;
                  if ( v4 & 0x800 )
                  {
                    v22 /= 2;
                    v66 = 1;
                  }
                  else
                  {
                    v12 = 0;
                    v66 = 0;
                  }
                  goto LABEL_192;
                }
              }
              v13 = (int)off_10073C14;
            }
            else
            {
              if ( (char)v12 != 97 )
              {
                if ( (char)v12 != 99 )
                  goto LABEL_193;
                goto LABEL_97;
              }
LABEL_78:
              v20 = v76;
              v4 |= 0x40u;
              v79 = v4;
              v13 = (int)&UsedDefaultChar;
              v67 = 512;
              if ( v76 >= 0 )
              {
                if ( v76 )
                {
                  if ( v76 > 512 )
                  {
                    v20 = 512;
                    v76 = 512;
                  }
                  if ( v20 > 163 )
                  {
                    v27 = v20 + 349;
                    v26 = sub_10037530(512, v12, v4, v20 + 349);
                    LOBYTE(v12) = v80;
                    lpMem = (LPVOID)v26;
                    if ( v26 )
                    {
                      v13 = v26;
                      v67 = v27;
                    }
                    else
                    {
                      v76 = 163;
                    }
                    v5 = v78;
                  }
                }
                else
                {
                  if ( (_BYTE)v12 == 103 )
                    v76 = 1;
                }
              }
              else
              {
                v76 = 6;
              }
              v28 = *(_DWORD *)v5;
              v29 = v5 + 8;
              v53 = v28;
              v54 = *(_DWORD *)(v29 - 4);
              v30 = v59;
              v31 = v76;
              v78 = v29;
              v32 = (char)v12;
              v33 = v67;
              v34 = DecodePointer(off_100741E4);
              ((void (__cdecl *)(int *, int, int, int, int, int, char *))v34)(&v53, v13, v33, v32, v31, v30, &v55);
              v5 = v4 & 0x80;
              if ( v4 & 0x80 )
              {
                if ( !v76 )
                {
                  v35 = DecodePointer(off_100741F0);
                  ((void (__cdecl *)(int, char *))v35)(v13, &v55);
                }
              }
              if ( v80 == 103 )
              {
                if ( !(v4 & 0x80) )
                {
                  v36 = DecodePointer(off_100741EC);
                  ((void (__cdecl *)(int, char *))v36)(v13, &v55);
                }
              }
              if ( *(_BYTE *)v13 == 45 )
              {
                v4 |= 0x100u;
                v79 = v4;
                ++v13;
              }
            }
            v22 = sub_10035530(v13);
            v12 = v24;
            goto LABEL_192;
          }
          if ( (char)v12 > 112 )
          {
            if ( (char)v12 != 115 )
            {
              if ( (char)v12 != 117 )
              {
                if ( (char)v12 != 120 )
                  goto LABEL_193;
                v52 = 39;
                goto LABEL_152;
              }
LABEL_124:
              v77 = 10;
              goto LABEL_125;
            }
LABEL_84:
            v12 = 2147483647;
            if ( v76 != -1 )
              v12 = v76;
            v13 = *(_DWORD *)v78;
            v5 = v78 + 4;
            v78 += 4;
            if ( v4 & 0x810 )
            {
              if ( !v13 )
                v13 = (int)off_10073C18;
              v66 = 1;
              for ( i = v13; v12; i += 2 )
              {
                --v12;
                if ( !*(_WORD *)i )
                  break;
              }
              v22 = (i - v13) >> 1;
            }
            else
            {
              if ( !v13 )
                v13 = (int)off_10073C14;
              for ( j = v13; ; ++j )
              {
                if ( v12 )
                {
                  --v12;
                  if ( *(_BYTE *)j )
                    continue;
                }
                break;
              }
              v22 = j - v13;
            }
LABEL_192:
            v77 = v22;
            goto LABEL_193;
          }
          if ( (char)v12 == 112 )
          {
            v76 = 8;
LABEL_147:
            v52 = 7;
LABEL_152:
            v62 = v52;
            v77 = 16;
            if ( (_BYTE)v4 < 0 )
            {
              v73 = 48;
              v74 = v52 + 81;
              v71 = 2;
            }
            goto LABEL_125;
          }
          if ( (char)v12 < 101 )
            goto LABEL_193;
          if ( (char)v12 <= 103 )
            goto LABEL_78;
          if ( (char)v12 == 105 )
            goto LABEL_123;
          if ( (char)v12 != 110 )
          {
            if ( (char)v12 == 111 )
            {
              v77 = 8;
              if ( (_BYTE)v4 < 0 )
              {
                v4 |= 0x200u;
                v79 = v4;
              }
LABEL_125:
              if ( (unsigned __int16)(v4 & 0x8000) || v4 & 0x1000 )
              {
                v12 = *(_DWORD *)v78;
                v78 += 8;
                v5 = *(_DWORD *)(v5 + 4);
                v25 = 0;
                goto LABEL_162;
              }
              v37 = v78 + 4;
              v25 = 0;
              v78 += 4;
              if ( v4 & 0x20 )
              {
                if ( v4 & 0x40 )
                  v38 = *(_WORD *)(v37 - 4);
                else
                  v38 = *(_WORD *)(v37 - 4);
LABEL_160:
                v12 = v38;
                v5 = (unsigned __int64)v38 >> 32;
              }
              else
              {
                if ( v4 & 0x40 )
                {
                  v38 = *(_DWORD *)(v37 - 4);
                  goto LABEL_160;
                }
                v12 = *(_DWORD *)(v37 - 4);
                v5 = 0;
              }
LABEL_162:
              if ( v4 & 0x40 )
              {
                if ( v5 <= v25 )
                {
                  if ( v5 < v25 || v12 < (unsigned int)v25 )
                  {
                    v12 = -v12;
                    v5 = -(v25 + (v12 != 0) + v5);
                    v4 |= 0x100u;
                    v79 = v4;
                  }
                }
              }
              if ( !(v4 & 0x9000) )
                v5 = v25;
              v39 = v76;
              if ( v76 >= 0 )
              {
                v4 &= 0xFFFFFFF7u;
                v79 = v4;
                if ( v76 > 512 )
                  v39 = 512;
              }
              else
              {
                v39 = 1;
              }
              if ( !(v5 | v12) )
                v71 = v25;
              for ( k = &v82; ; --k )
              {
                v76 = v39 - 1;
                if ( v39 <= 0 )
                {
                  if ( !(v5 | v12) )
                    break;
                }
                HIDWORD(v42) = v5;
                LODWORD(v42) = v12;
                v43 = sub_10039150(v42, v77);
                v41 = v44 + 48;
                v58 = v4;
                v67 = v43;
                v5 = v45;
                if ( v41 > 57 )
                  v41 += v62;
                v39 = v76;
                *k = v41;
                v12 = v67;
              }
              v4 = v79;
              v46 = &v82 - k;
              v13 = (int)(k + 1);
              v77 = v46;
              if ( v79 & 0x200 )
              {
                if ( !v46 || *(_BYTE *)v13 != 48 )
                {
                  --v13;
                  ++v77;
                  *(_BYTE *)v13 = 48;
                }
              }
            }
LABEL_193:
            if ( v65 )
              goto LABEL_220;
            if ( v4 & 0x40 )
            {
              if ( v4 & 0x100 )
              {
                v73 = 45;
                goto LABEL_201;
              }
              if ( v4 & 1 )
              {
                v73 = 43;
                goto LABEL_201;
              }
              if ( v4 & 2 )
              {
                v73 = 32;
LABEL_201:
                v71 = 1;
              }
            }
            v48 = v71;
            v5 = v69 - v77 - v71;
            if ( !(v4 & 0xC) )
            {
              sub_10051558(v4, 0x20u, v69 - v77 - v71, v72, (int)&v75);
              v48 = v71;
            }
            sub_10051584((unsigned __int8 *)&v73, v48, v72, (int)&v75, (int *)v61);
            if ( v4 & 8 )
            {
              if ( !(v4 & 4) )
                sub_10051558(v4, 0x30u, v5, v72, (int)&v75);
            }
            v49 = v77;
            if ( v66 && v77 > 0 )
            {
              v12 = v13;
              while ( 1 )
              {
                v67 = v49 - 1;
                v50 = *(_WORD *)v12;
                v58 = v12 + 2;
                if ( sub_10051733((int)&v60, &v83, 6, v50) )
                  break;
                if ( !v60 )
                  break;
                sub_10051584((unsigned __int8 *)&v83, v60, v72, (int)&v75, (int *)v61);
                v49 = v67;
                v12 = v58;
                if ( !v67 )
                  goto LABEL_216;
              }
              v51 = -1;
              v75 = -1;
            }
            else
            {
              sub_10051584((unsigned __int8 *)v13, v77, v72, (int)&v75, (int *)v61);
LABEL_216:
              v51 = v75;
            }
            if ( v51 >= 0 )
            {
              if ( v4 & 4 )
                sub_10051558(v4, 0x20u, v5, v72, (int)&v75);
            }
            goto LABEL_220;
          }
          v78 += 4;
          v5 = *(_DWORD *)v5;
          if ( !sub_100515FC() )
            goto LABEL_226;
          if ( v4 & 0x20 )
            *(_WORD *)v5 = v75;
          else
            *(_DWORD *)v5 = v75;
          v65 = 1;
LABEL_220:
          if ( lpMem )
          {
            sub_100309C2(v4, lpMem);
            v12 = 0;
            lpMem = 0;
          }
LABEL_222:
          v10 = v70;
LABEL_223:
          LOBYTE(v12) = *(_BYTE *)v10;
          result = v75;
          v80 = v12;
          LOBYTE(v64) = v12;
          if ( !(_BYTE)v12 )
            goto LABEL_224;
          break;
        default:
          goto LABEL_223;
      }
    }
LABEL_224:
    if ( v68 && v68 != 7 )
    {
LABEL_226:
      *(_DWORD *)sub_10037649(v4) = 22;
      sub_1003A151(v4, v5);
      result = -1;
    }
  }
  if ( v57 )
    *(_DWORD *)(v56 + 112) &= 0xFFFFFFFDu;
  return result;
}
// 100667AC: using guessed type wchar_t aAcp[4];
// 10073200: using guessed type int __security_cookie;
// 10073C14: using guessed type char *off_10073C14;
// 10073C18: using guessed type wchar_t *off_10073C18;
// 10075F80: using guessed type int dword_10075F80[];

//----- (10051512) --------------------------------------------------------
int __usercall sub_10051512<eax>(int a1<ebx>, int a2<edi>, unsigned __int8 a3, int a4, int a5)
{
  char v5; // sf@3
  signed int v6; // eax@4
  int result; // eax@7

  if ( *(_BYTE *)(a4 + 12) & 0x40 && !*(_DWORD *)(a4 + 8)
    || ((v5 = *(_DWORD *)(a4 + 4) - 1 < 0, --*(_DWORD *)(a4 + 4), v5) ? (v6 = sub_100446E8(a1, a2, a3, a4)) : (**(_BYTE **)a4 = a3, ++*(_DWORD *)a4, v6 = a3),
        v6 != -1) )
  {
    result = a5;
    ++*(_DWORD *)result;
  }
  else
  {
    result = a5;
    *(_DWORD *)a5 = -1;
  }
  return result;
}

//----- (10051558) --------------------------------------------------------
int __usercall sub_10051558<eax>(int a1<ebx>, unsigned __int8 a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  int result; // eax@2

  v5 = a3;
  if ( a3 > 0 )
  {
    do
    {
      --v5;
      result = sub_10051512(a1, a5, a2, a4, a5);
    }
    while ( *(_DWORD *)a5 != -1 && v5 > 0 );
  }
  return result;
}

//----- (10051584) --------------------------------------------------------
int __cdecl sub_10051584(unsigned __int8 *a1, int a2, int a3, int a4, int *a5)
{
  int result; // eax@1
  int *v6; // esi@1
  int v7; // ebx@4
  int v8; // [sp+20h] [bp+18h]@1

  v6 = a5;
  result = *a5;
  v8 = *a5;
  if ( *(_BYTE *)(a3 + 12) & 0x40 && !*(_DWORD *)(a3 + 8) )
  {
    result = a2;
    *(_DWORD *)a4 += a2;
    return result;
  }
  *v6 = 0;
  v7 = a2;
  if ( a2 <= 0 )
    goto LABEL_12;
  result = a4;
  do
  {
    --v7;
    sub_10051512(v7, a3, *a1, a3, result);
    result = a4;
    ++a1;
    if ( *(_DWORD *)a4 == -1 )
    {
      if ( *v6 != 42 )
        break;
      sub_10051512(v7, a3, 0x3Fu, a3, a4);
      result = a4;
    }
  }
  while ( v7 > 0 );
  if ( !*v6 )
  {
    result = v8;
LABEL_12:
    *v6 = result;
  }
  return result;
}

//----- (100515FC) --------------------------------------------------------
bool __cdecl sub_100515FC()
{
  return dword_10076220 == (__security_cookie | 1);
}
// 10073200: using guessed type int __security_cookie;
// 10076220: using guessed type int dword_10076220;

//----- (10051611) --------------------------------------------------------
signed int __cdecl sub_10051611(int a1, LPSTR UsedDefaultChar, int cbMultiByte, const WCHAR WideCharStr, int a5)
{
  CHAR *v5; // ebx@1
  int v6; // edi@1
  signed int v8; // esi@9
  int v9; // ecx@25
  int v10; // [sp+8h] [bp-10h]@10
  int v11; // [sp+10h] [bp-8h]@17
  char v12; // [sp+14h] [bp-4h]@16

  v5 = UsedDefaultChar;
  v6 = cbMultiByte;
  if ( UsedDefaultChar || !cbMultiByte )
  {
    if ( a1 )
      *(_DWORD *)a1 = -1;
    if ( (unsigned int)v6 > 0x7FFFFFFF )
    {
      v8 = 22;
      *(_DWORD *)sub_10037649((int)v5) = 22;
      sub_1003A151((int)v5, v6);
      return v8;
    }
    sub_100301AD((int)&v10, (int)v5, v6, a5);
    v8 = 0;
    if ( *(_DWORD *)(v10 + 168) )
    {
      UsedDefaultChar = 0;
      v9 = WideCharToMultiByte(*(_DWORD *)(v10 + 4), 0, &WideCharStr, 1, v5, v6, 0, (LPBOOL)&UsedDefaultChar);
      if ( v9 )
      {
        if ( !UsedDefaultChar )
        {
          if ( a1 )
            *(_DWORD *)a1 = v9;
          goto LABEL_16;
        }
        goto LABEL_15;
      }
      if ( GetLastError() != 122 )
      {
LABEL_15:
        *(_DWORD *)sub_10037649((int)v5) = 42;
        v8 = *(_DWORD *)sub_10037649((int)v5);
        goto LABEL_16;
      }
      if ( v5 )
      {
        if ( v6 )
          sub_100391F0(v5, 0, v6);
      }
    }
    else
    {
      if ( WideCharStr > 0xFFu )
      {
        if ( v5 )
        {
          if ( v6 )
            sub_100391F0(v5, 0, v6);
        }
        goto LABEL_15;
      }
      if ( !v5 )
      {
LABEL_23:
        if ( a1 )
          *(_DWORD *)a1 = 1;
        goto LABEL_16;
      }
      if ( v6 )
      {
        *v5 = WideCharStr;
        goto LABEL_23;
      }
    }
    v8 = 34;
    *(_DWORD *)sub_10037649((int)v5) = 34;
    sub_1003A151((int)v5, v6);
LABEL_16:
    if ( v12 )
      *(_DWORD *)(v11 + 112) &= 0xFFFFFFFDu;
    return v8;
  }
  if ( a1 )
    *(_DWORD *)a1 = 0;
  return 0;
}

//----- (10051733) --------------------------------------------------------
int __cdecl sub_10051733(int a1, LPSTR UsedDefaultChar, int cbMultiByte, const WCHAR WideCharStr)
{
  return sub_10051611(a1, UsedDefaultChar, cbMultiByte, WideCharStr, 0);
}

//----- (1005174E) --------------------------------------------------------
int __thiscall sub_1005174E(int this, int a2)
{
  int v3; // edi@1

  v3 = this;
  *(_DWORD *)this = 1;
  *(_DWORD *)(this + 4) = sub_1003D43F(a2 + 4);
  *(_DWORD *)(v3 + 8) = a2;
  return v3;
}

//----- (10051774) --------------------------------------------------------
unsigned int __thiscall sub_10051774(int this, int a2)
{
  unsigned int result; // eax@3
  unsigned int v3; // edx@4
  _DWORD *v6; // [sp+0h] [bp+0h]@4

  if ( *(_DWORD *)((a2 << 7) + *(_DWORD *)(this + 92)) <= 1u )
  {
    result = 0;
  }
  else
  {
    v6 = &v6;
    v3 = *(_DWORD *)((a2 << 7) + *(_DWORD *)(this + 92));
    _EDI = 1;
    if ( v3 <= 1 )
      goto LABEL_10;
    _ECX = (a2 << 7) + *(_DWORD *)(this + 92);
    __asm { lock cmpxchg [ecx], edi }
    if ( v3 != v3 )
LABEL_10:
      result = 0;
    else
      result = v3;
  }
  return result;
}

//----- (100517C5) --------------------------------------------------------
int __usercall sub_100517C5<eax>(int a1<ecx>, int a2<edi>)
{
  int v2; // esi@1
  int v4; // eax@8
  char v5; // [sp-4h] [bp-8h]@6

  v2 = a1;
  if ( *(_BYTE *)a1 & 0x18 && !sub_10051DD0(a1, a2) )
    return 0;
  if ( *(_DWORD *)v2 == 2 )
  {
    v5 = 0;
LABEL_8:
    v4 = sub_10040FD9(*(void **)(v2 + 4), *(_DWORD *)(v2 + 8), v5);
    *(_DWORD *)(v2 + 8) = v4;
    if ( v4 )
    {
      *(_BYTE *)(v4 + 179) |= 1u;
      *(_DWORD *)v2 = 1;
    }
    return *(_DWORD *)(v2 + 8);
  }
  if ( *(_DWORD *)v2 == 4 )
  {
    v5 = 1;
    goto LABEL_8;
  }
  return *(_DWORD *)(v2 + 8);
}

//----- (1005180E) --------------------------------------------------------
int __thiscall sub_1005180E(int this, int a2)
{
  int v2; // esi@1
  int result; // eax@2
  char v4; // [sp-4h] [bp-Ch]@3

  v2 = this;
  if ( *(_DWORD *)this == 2 )
  {
    v4 = 0;
    goto LABEL_5;
  }
  result = *(_DWORD *)this - 4;
  if ( *(_DWORD *)this == 4 )
  {
    v4 = 1;
LABEL_5:
    result = sub_10046AE2(a2, *(_DWORD *)(this + 4), *(_DWORD *)(this + 8), v4);
  }
  *(_DWORD *)(v2 + 8) = a2;
  *(_DWORD *)v2 = 1;
  return result;
}

//----- (10051844) --------------------------------------------------------
char __thiscall sub_10051844(int this, int a2)
{
  char result; // al@1

  result = (unsigned int)(a2 - *(_DWORD *)(this + 20)) > 0x3E8;
  if ( result )
    *(_DWORD *)(this + 20) = a2;
  return result;
}

//----- (10051862) --------------------------------------------------------
char __thiscall sub_10051862(int this, int a2, int a3, char a4)
{
  int v4; // ebx@1
  int ebp0; // ebp@0
  int v6; // eax@3
  int v7; // eax@6
  int v9; // eax@10
  int v10; // eax@15
  char v11; // [sp+Ch] [bp-18h]@15
  char v12; // [sp+18h] [bp-Ch]@6

  v4 = this;
  if ( !a4 )
  {
    if ( *(_DWORD *)(this + 12) < 0x65u )
    {
      if ( *(_DWORD *)(a3 + 16) - *(_DWORD *)(a3 + 12) <= 0 )
        v9 = 0;
      else
        v9 = sub_100453CD(a3 + 12);
    }
    else
    {
      if ( *(_DWORD *)(this + 12) >= 0x7Fu )
      {
LABEL_16:
        *(_DWORD *)(v4 + 12) = 0;
        return 0;
      }
      v9 = sub_10052BB1(a3, ebp0);
    }
    if ( v9 )
    {
      v10 = sub_1005174E((int)&v11, v9);
      *(_DWORD *)a2 = *(_DWORD *)v10;
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(v10 + 4);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(v10 + 8);
      ++*(_DWORD *)(v4 + 12);
      return 1;
    }
    goto LABEL_16;
  }
  if ( *(_DWORD *)(a3 + 16) - *(_DWORD *)(a3 + 12) <= 0 )
    v6 = 0;
  else
    v6 = sub_100453CD(a3 + 12);
  if ( v6 )
  {
    v7 = sub_1005174E((int)&v12, v6);
    *(_DWORD *)a2 = *(_DWORD *)v7;
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(v7 + 4);
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(v7 + 8);
    return 1;
  }
  return 0;
}

//----- (100518F9) --------------------------------------------------------
int __thiscall sub_100518F9(int this, int a2, int a3)
{
  signed int v3; // edi@1
  signed int i; // esi@1
  int v5; // edx@2
  int result; // eax@3

  v3 = *(_DWORD *)(this + 44);
  for ( i = 0; i < v3; ++i )
  {
    v5 = (i + *(_DWORD *)a2 + (a3 != -1)) % v3;
    if ( v5 == a3 )
      break;
    result = *(_DWORD *)(*(_DWORD *)(this + 32) + 4 * v5);
    if ( result )
    {
      *(_DWORD *)a2 = v5;
      return result;
    }
  }
  return 0;
}

//----- (10051946) --------------------------------------------------------
int __thiscall sub_10051946(int this, int a2)
{
  int result; // eax@1
  int v3; // ebx@1
  int v4; // edi@1

  v4 = *(_DWORD *)(this + 176);
  v3 = this + 16;
  result = sub_10032551(*(_DWORD *)(this + 176), *(_DWORD *)(this + 80), a2, this + 16);
  if ( !result )
  {
    if ( v4 )
      result = sub_10032551(result, v4, a2, v3);
  }
  return result;
}

//----- (10051981) --------------------------------------------------------
int __thiscall sub_10051981(int this, int a2)
{
  int result; // eax@1
  int v3; // ebx@1
  int v4; // edi@1

  v4 = *(_DWORD *)(this + 180);
  v3 = this + 96;
  result = sub_10032551(*(_DWORD *)(this + 180), *(_DWORD *)(this + 160), a2, this + 96);
  if ( !result )
  {
    if ( v4 )
      result = sub_10032551(result, v4, a2, v3);
  }
  return result;
}

//----- (100519BF) --------------------------------------------------------
char __stdcall sub_100519BF(int a1, int a2, char a3)
{
  int v3; // eax@2
  signed int v5; // [sp+8h] [bp-Ch]@3
  int v6; // [sp+10h] [bp-4h]@4

  if ( a3 )
  {
    v3 = sub_1004100C((void *)a2);
    if ( v3 )
    {
      v5 = 2;
      v6 = v3;
LABEL_4:
      *(_DWORD *)a1 = v5;
      *(_DWORD *)(a1 + 4) = a2;
      *(_DWORD *)(a1 + 8) = v6;
      return 1;
    }
  }
  else
  {
    if ( sub_10041066(a2) )
    {
      v5 = 8;
      goto LABEL_4;
    }
  }
  return 0;
}

//----- (10051A0F) --------------------------------------------------------
char __thiscall sub_10051A0F(void *this, int a2, int a3, char a4, int a5, char a6)
{
  void *v6; // edi@1
  int v7; // esi@1
  char result; // al@3
  int v9; // esi@5

  v7 = *(_DWORD *)(a3 + 256);
  v6 = this;
  if ( sub_10052A7B(this, a3, 0, a5, a6) || !sub_100519BF(a2, a3, a4) )
  {
    if ( a5 )
      v9 = *(_DWORD *)(v7 + 12);
    else
      v9 = *(_DWORD *)(v7 + 16);
    while ( v9 )
    {
      if ( !sub_10052A7B(v6, v9, a3, a5, a6) && sub_100519BF(a2, v9, a4) )
        goto LABEL_3;
      v9 = *(_DWORD *)(v9 + 260);
    }
    result = 0;
  }
  else
  {
LABEL_3:
    result = 1;
  }
  return result;
}

//----- (10051A90) --------------------------------------------------------
char __stdcall sub_10051A90(int a1, int a2)
{
  int v2; // eax@1
  char result; // al@2
  int v4; // eax@2
  char v5; // [sp+0h] [bp-Ch]@2

  v2 = (*(int (**)(void))(*(_DWORD *)a2 + 12))();
  if ( v2 )
  {
    v4 = sub_1005174E((int)&v5, v2);
    *(_DWORD *)a1 = *(_DWORD *)v4;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(v4 + 4);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(v4 + 8);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10051AC1) --------------------------------------------------------
char __thiscall sub_10051AC1(void *this, int a2, int a3, int a4, char a5)
{
  void *v5; // edi@1
  int v6; // esi@1
  char result; // al@3
  int v8; // esi@5

  v6 = *(_DWORD *)(a3 + 256);
  v5 = this;
  if ( sub_10052A7B(this, a3, 0, a4, a5) || !sub_10051A90(a2, a3) )
  {
    if ( a4 )
      v8 = *(_DWORD *)(v6 + 12);
    else
      v8 = *(_DWORD *)(v6 + 16);
    while ( v8 )
    {
      if ( !sub_10052A7B(v5, v8, a3, a4, a5) && sub_10051A90(a2, v8) )
        goto LABEL_3;
      v8 = *(_DWORD *)(v8 + 260);
    }
    result = 0;
  }
  else
  {
LABEL_3:
    result = 1;
  }
  return result;
}

//----- (10051B3C) --------------------------------------------------------
char __userpurge sub_10051B3C<al>(int a1<edi>, int a2, int a3, char a4, char a5)
{
  int v5; // eax@2
  signed int v7; // [sp+8h] [bp-Ch]@3

  if ( a5 )
  {
    v5 = sub_10041636(a3, a1, a4);
    if ( v5 )
    {
      v7 = 4;
LABEL_4:
      *(_DWORD *)a2 = v7;
      *(_DWORD *)(a2 + 4) = a3;
      *(_DWORD *)(a2 + 8) = v5;
      return 1;
    }
  }
  else
  {
    v5 = sub_1004123C((void *)a3);
    if ( v5 )
    {
      v7 = 16;
      goto LABEL_4;
    }
  }
  return 0;
}

//----- (10051B8F) --------------------------------------------------------
char __thiscall sub_10051B8F(void *this, int a2, int a3, char a4, int a5, char a6)
{
  int v6; // edi@1
  char result; // al@3
  int v8; // esi@5
  int v9; // [sp+8h] [bp-4h]@1

  v6 = (int)this;
  v9 = *(_DWORD *)(a3 + 256);
  if ( sub_10052A7B(this, a3, 0, a5, a6) || !sub_10051B3C(v6, a2, a3, a6, a4) )
  {
    if ( a5 )
      v8 = *(_DWORD *)(v9 + 12);
    else
      v8 = *(_DWORD *)(v9 + 16);
    while ( v8 )
    {
      if ( !sub_10052A7B((void *)v6, v8, a3, a5, a6) && sub_10051B3C(v6, a2, v8, a6, a4) )
        goto LABEL_3;
      v8 = *(_DWORD *)(v8 + 260);
    }
    result = 0;
  }
  else
  {
LABEL_3:
    result = 1;
  }
  return result;
}

//----- (10051C1D) --------------------------------------------------------
int __thiscall sub_10051C1D(int this)
{
  int v1; // esi@1
  int result; // eax@2

  v1 = this;
  if ( *(_DWORD *)this == 2 )
  {
    sub_10052C1D(*(_DWORD *)(this + 8));
    result = sub_10033AFD(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v1 + 4) + 256) + 4), *(_DWORD *)(v1 + 8));
  }
  else
  {
    result = *(_DWORD *)this - 4;
    if ( *(_DWORD *)this == 4 )
      result = (*(int (__cdecl **)(_DWORD))(*(_DWORD *)(this + 8) + 12))(*(_DWORD *)(this + 8));
  }
  return result;
}

//----- (10051C52) --------------------------------------------------------
int __thiscall sub_10051C52(void *this, int a2)
{
  int result; // eax@1

  result = a2 - *((_DWORD *)this + 103);
  if ( (unsigned int)result > 0x7D0 )
    result = sub_10033598(this, a2);
  return result;
}

//----- (10051C71) --------------------------------------------------------
char __thiscall sub_10051C71(void *this, int a2)
{
  int v2; // eax@1
  char result; // al@2
  int v4; // eax@2
  char v5; // [sp+0h] [bp-Ch]@2

  v2 = (*(int (**)(void))(**(_DWORD **)this + 8))();
  if ( v2 )
  {
    v4 = sub_1005174E((int)&v5, v2);
    *(_DWORD *)a2 = *(_DWORD *)v4;
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(v4 + 4);
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(v4 + 8);
    result = 1;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10051CA1) --------------------------------------------------------
char __userpurge sub_10051CA1<al>(int a1<edi>, int a2, int a3, char a4, unsigned int a5)
{
  return a5 & 1 && sub_10051A90(a3, a2)
      || a5 & 0xA && sub_100519BF(a3, a2, (a5 >> 1) & 1)
      || a5 & 0x14 && sub_10051B3C(a1, a3, a2, a4, (a5 >> 2) & 1);
}

//----- (10051D0E) --------------------------------------------------------
char __userpurge sub_10051D0E<al>(int a1<edi>, int a2, int a3, char a4, unsigned int a5)
{
  return a5 & 0x14 && sub_10051B3C(a1, a3, a2, a4, (a5 >> 2) & 1)
      || a5 & 0xA && sub_100519BF(a3, a2, (a5 >> 1) & 1)
      || a5 & 1 && sub_10051A90(a3, a2);
}

//----- (10051D7C) --------------------------------------------------------
DWORD __thiscall sub_10051D7C(int this, int a2, int a3)
{
  DWORD result; // eax@1
  int v4; // esi@1

  v4 = this;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)this = a2;
  *(_DWORD *)(this + 8) = *(_DWORD *)(a2 + 132);
  *(_DWORD *)(this + 4) = **(_DWORD **)(a2 + 68);
  result = GetTickCount();
  *(_DWORD *)(v4 + 20) = result;
  *(_DWORD *)(v4 + 16) = result;
  if ( a3 == 1 )
  {
    *(_DWORD *)(v4 + 24) = sub_10051E4E;
    *(_DWORD *)(v4 + 28) = sub_1005210C;
  }
  else
  {
    *(_DWORD *)(v4 + 24) = sub_10052686;
    *(_DWORD *)(v4 + 28) = sub_10052799;
  }
  return result;
}

//----- (10051DD0) --------------------------------------------------------
bool __usercall sub_10051DD0<eax>(int a1<ecx>, int a2<edi>)
{
  int ebp0; // ebp@0
  int v3; // esi@1
  char v4; // al@4
  int v5; // edi@4
  int v6; // eax@6
  int v8; // [sp+8h] [bp-4h]@4

  v3 = a1;
  if ( *(_DWORD *)a1 == 8 )
  {
    v6 = sub_1004100C(*(void **)(a1 + 4));
    if ( !v6 )
      return (*(_BYTE *)v3 & 0x18) == 0;
    *(_DWORD *)v3 = 2;
    goto LABEL_10;
  }
  if ( *(_DWORD *)a1 != 16 )
    return (*(_BYTE *)v3 & 0x18) == 0;
  if ( *(_DWORD *)(a1 + 8) != 1 )
  {
    v6 = sub_10040324(ebp0, 0);
    if ( !v6 )
      return (*(_BYTE *)v3 & 0x18) == 0;
    *(_DWORD *)v3 = 4;
LABEL_10:
    *(_DWORD *)(v3 + 8) = v6;
    return (*(_BYTE *)v3 & 0x18) == 0;
  }
  v4 = sub_10040DC7(*(_DWORD *)(a1 + 4) + 52, a2, (int)&v8);
  v5 = (unsigned __int8)v4 != 0 ? v8 : 0;
  if ( (unsigned __int8)v4 != 0 ? v8 : 0 )
  {
    sub_1003FB01((unsigned __int8)v4 != 0 ? v8 : 0, 1);
    *(_DWORD *)(v3 + 8) = v5;
    *(_DWORD *)v3 = 4;
  }
  return (*(_BYTE *)v3 & 0x18) == 0;
}

//----- (10051E4E) --------------------------------------------------------
char __thiscall sub_10051E4E(void *this, int a2, int a3, char a4, unsigned int a5)
{
  int v5; // ebx@1
  int ebp0; // ebp@0
  int v7; // edi@1
  char result; // al@2
  int v9; // eax@3
  void *v10; // ecx@3
  int v11; // ecx@4
  int v12; // eax@10
  int v13; // eax@12
  int v14; // eax@14
  int v15; // ecx@17
  char v16; // zf@18
  bool v17; // esi@21
  int v18; // eax@26
  int v19; // edi@44
  int v20; // esi@44
  int v21; // esi@44
  int v22; // [sp+10h] [bp-28h]@25
  int v23; // [sp+14h] [bp-24h]@17
  int v24; // [sp+18h] [bp-20h]@25
  int v25; // [sp+1Fh] [bp-19h]@32
  char v26; // [sp+1Fh] [bp-19h]@44
  char v27; // [sp+23h] [bp-15h]@1
  char v28; // [sp+24h] [bp-14h]@45
  int v29; // [sp+28h] [bp-10h]@14
  int v30; // [sp+2Ch] [bp-Ch]@18
  int v31; // [sp+30h] [bp-8h]@18
  unsigned int v32; // [sp+34h] [bp-4h]@1
  int v33; // [sp+38h] [bp+0h]@1

  v32 = (unsigned int)&v33 ^ __security_cookie;
  v7 = a2;
  v5 = (int)this;
  v27 = 0;
  if ( sub_10051C71(this, a2) )
  {
    result = 1;
  }
  else
  {
    v9 = GetTickCount();
    v10 = *(void **)(v5 + 4);
    *(_DWORD *)(v5 + 16) = v9;
    sub_10051C52(v10, v9);
    if ( sub_10051844(v5, *(_DWORD *)(v5 + 16)) )
    {
      v11 = *(_DWORD *)(v5 + 4);
      if ( *(_DWORD *)(v11 + 304) )
      {
        while ( 1 )
        {
          v13 = sub_10032A75(v11);
          if ( !v13 )
            break;
          if ( *(_DWORD *)v13 )
          {
            if ( a5 & 1 )
            {
              v12 = sub_10052BB1(v13 - 192, ebp0);
              if ( v12 )
              {
                v14 = sub_1005174E((int)&v29, v12);
                *(_DWORD *)a2 = *(_DWORD *)v14;
                *(_DWORD *)(a2 + 4) = *(_DWORD *)(v14 + 4);
                *(_DWORD *)(a2 + 8) = *(_DWORD *)(v14 + 8);
                v7 = a2;
LABEL_15:
                v27 = 1;
                break;
              }
            }
          }
          else
          {
            if ( sub_10051CA1(a2, v13 - 268, a2, a4, a5) )
              goto LABEL_15;
          }
          v11 = *(_DWORD *)(v5 + 4);
        }
      }
      *(_BYTE *)(*(_DWORD *)v5 + 86) = 1;
    }
    v15 = *(_DWORD *)v5;
    v23 = *(_DWORD *)(*(_DWORD *)v5 + 72);
    if ( v27 )
      goto LABEL_52;
    v17 = (v30 = 0, v16 = *(_BYTE *)(v15 + 84) == 0, v29 = 1, v31 = 2, v16) && !sub_10044F05(v15) && !a4;
    result = v27;
    LOBYTE(v25) = 1;
    do
    {
      if ( v17 > 2 )
        break;
      v22 = a3;
      v24 = v23;
      if ( v23 )
      {
        while ( 1 )
        {
          v18 = sub_10051774(*(_DWORD *)(v5 + 4), *(_DWORD *)(v5 + 8));
          if ( v18 )
          {
            if ( sub_10051CA1(v7, v18, v7, a4, a5) )
              break;
          }
          if ( (_BYTE)v25 && a5 & 1 && sub_10051862(v5, v7, *(_DWORD *)v5, 0)
            || a5 & 1 && sub_10052484((void *)v5, v7, v24, v22, v25, *(&v29 + v17), a5, a4)
            || a5 & 0xA && sub_1005238B((void *)v5, v7, v24, v22, (a5 >> 1) & 1, *(&v29 + v17), a5, a4)
            || a5 & 0x14 && sub_1005258A((void *)v5, v7, v24, v22, (a5 >> 2) & 1, *(&v29 + v17), a5, a4)
            || a5 & 1 && v17 == 2 && sub_10052B45((void *)v5, v7, *(_DWORD *)(v24 + 4), *(_DWORD *)v5) )
            break;
          v22 = 0;
          LOBYTE(v25) = 0;
          v24 = sub_10032AE6(*(_DWORD *)(v5 + 4), v23, v24);
          if ( !v24 )
          {
            result = v27;
            goto LABEL_42;
          }
        }
        result = 1;
        v27 = 1;
      }
LABEL_42:
      ++v17;
    }
    while ( !result );
    if ( result )
    {
LABEL_52:
      v21 = *(_DWORD *)(v7 + 4);
      v19 = *(_DWORD *)(v21 + 8);
      sub_10052A41(v21, *(_DWORD *)(v5 + 16));
      v20 = v21 + 12;
      v26 = 0;
      if ( *(_DWORD *)v20 & 0xFFFFFFF )
      {
        sub_1002F3E5((int)&v28, *(_DWORD *)v5 + 136);
        if ( sub_1004D750((int)&v28, v20) )
          v26 = 1;
      }
      sub_10045868(*(_DWORD *)v5, v26, v19 == v23);
      result = v27;
    }
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;

//----- (1005210C) --------------------------------------------------------
char __thiscall sub_1005210C(void *this, int a2, int a3, char a4, unsigned int a5)
{
  int v5; // ebx@1
  int ebp0; // ebp@0
  int v7; // edi@1
  char result; // al@2
  int v9; // eax@3
  void *v10; // ecx@3
  int v11; // ecx@4
  int v12; // eax@10
  int v13; // eax@12
  int v14; // eax@14
  int v15; // ecx@17
  char v16; // zf@18
  bool v17; // esi@21
  int v18; // edx@25
  int v19; // ecx@25
  int i; // eax@26
  int v21; // eax@32
  int v22; // ecx@48
  int v23; // esi@48
  int v24; // [sp+10h] [bp-28h]@33
  int v25; // [sp+18h] [bp-20h]@17
  int v26; // [sp+1Ch] [bp-1Ch]@25
  int v27; // [sp+20h] [bp-18h]@25
  char v28; // [sp+27h] [bp-11h]@1
  int v29; // [sp+28h] [bp-10h]@14
  int v30; // [sp+2Ch] [bp-Ch]@18
  int v31; // [sp+30h] [bp-8h]@18
  unsigned int v32; // [sp+34h] [bp-4h]@1
  int v33; // [sp+38h] [bp+0h]@1

  v32 = (unsigned int)&v33 ^ __security_cookie;
  v7 = a2;
  v5 = (int)this;
  v28 = 0;
  if ( sub_10051C71(this, a2) )
  {
    result = 1;
  }
  else
  {
    v9 = GetTickCount();
    v10 = *(void **)(v5 + 4);
    *(_DWORD *)(v5 + 16) = v9;
    sub_10051C52(v10, v9);
    if ( sub_10051844(v5, *(_DWORD *)(v5 + 16)) )
    {
      v11 = *(_DWORD *)(v5 + 4);
      if ( *(_DWORD *)(v11 + 304) )
      {
        while ( 1 )
        {
          v13 = sub_10032A75(v11);
          if ( !v13 )
            break;
          if ( *(_DWORD *)v13 )
          {
            if ( a5 & 1 )
            {
              v12 = sub_10052BB1(v13 - 192, ebp0);
              if ( v12 )
              {
                v14 = sub_1005174E((int)&v29, v12);
                *(_DWORD *)a2 = *(_DWORD *)v14;
                *(_DWORD *)(a2 + 4) = *(_DWORD *)(v14 + 4);
                *(_DWORD *)(a2 + 8) = *(_DWORD *)(v14 + 8);
                v7 = a2;
LABEL_15:
                v28 = 1;
                break;
              }
            }
          }
          else
          {
            if ( sub_10051D0E(a2, v13 - 268, a2, a4, a5) )
              goto LABEL_15;
          }
          v11 = *(_DWORD *)(v5 + 4);
        }
      }
      *(_BYTE *)(*(_DWORD *)v5 + 86) = 1;
    }
    v15 = *(_DWORD *)v5;
    v25 = *(_DWORD *)(*(_DWORD *)v5 + 72);
    if ( v28 )
      goto LABEL_51;
    v17 = (v30 = 0, v16 = *(_BYTE *)(v15 + 84) == 0, v29 = 1, v31 = 2, v16) && !sub_10044F05(v15) && !a4;
    result = v28;
    LOBYTE(v24) = 1;
    do
    {
      if ( v17 > 2 )
        break;
      v19 = v25;
      v18 = a3;
      v26 = a3;
      v27 = v25;
      if ( v25 )
      {
        for ( i = a5 & 0x14; ; i = a5 & 0x14 )
        {
          if ( i )
          {
            if ( sub_1005258A((void *)v5, v7, v19, v18, (a5 >> 2) & 1, *(&v29 + v17), a5, a4) )
              goto LABEL_44;
            v19 = v27;
            v18 = v26;
          }
          if ( a5 & 0xA && sub_1005238B((void *)v5, v7, v19, v18, (a5 >> 1) & 1, *(&v29 + v17), a5, a4) )
            goto LABEL_44;
          v21 = a5 & 1;
          if ( a5 & 1 )
          {
            if ( sub_10052484((void *)v5, v7, v27, v26, v24, *(&v29 + v17), a5, a4) )
              goto LABEL_44;
            v21 = a5 & 1;
          }
          if ( v21 && v17 == 2 )
          {
            if ( sub_10052B45((void *)v5, v7, *(_DWORD *)(v27 + 4), *(_DWORD *)v5) )
              goto LABEL_44;
            v21 = a5 & 1;
          }
          if ( (_BYTE)v24 && v21 && sub_10051862(v5, v7, *(_DWORD *)v5, 1) )
          {
LABEL_44:
            result = 1;
            v28 = 1;
            goto LABEL_46;
          }
          LOBYTE(v24) = 0;
          v26 = 0;
          v19 = sub_10032AE6(*(_DWORD *)(v5 + 4), v25, v27);
          v27 = v19;
          if ( !v19 )
            break;
          v18 = 0;
        }
        result = v28;
      }
LABEL_46:
      ++v17;
    }
    while ( !result );
    if ( result )
    {
LABEL_51:
      v22 = *(_DWORD *)(v7 + 4);
      v23 = *(_DWORD *)(v22 + 8);
      sub_10052A41(v22, *(_DWORD *)(v5 + 16));
      sub_10045868(*(_DWORD *)v5, (*(_DWORD *)(*(_DWORD *)(v7 + 4) + 12) & 0xFFFFFFF) == 0, v23 == v25);
      result = v28;
    }
  }
  return result;
}
// 10073200: using guessed type int __security_cookie;

//----- (1005238B) --------------------------------------------------------
char __thiscall sub_1005238B(void *this, int a2, int a3, int a4, char a5, int a6, unsigned int a7, char a8)
{
  int v8; // edi@1
  char result; // al@3
  int v10; // esi@4
  int v11; // eax@5
  int v12; // ebx@7
  int v13; // eax@8
  int v14; // eax@12
  void *v15; // [sp+4h] [bp-4h]@1
  int i; // [sp+14h] [bp+Ch]@7

  v8 = a6;
  v15 = this;
  if ( a4 && sub_10051A0F(this, a2, a4, a5, a6, a8) )
  {
    result = 1;
  }
  else
  {
    v10 = a3;
    if ( v8 )
      v11 = sub_10051946(a3, (int)&a6);
    else
      v11 = sub_10051981(a3, (int)&a6);
    v12 = v11;
    for ( i = a6; ; v12 = sub_10032AAA((int)&a6, i, v14) )
    {
      if ( !v12 )
        return 0;
      v13 = sub_10051774(*((_DWORD *)v15 + 1), *((_DWORD *)v15 + 2));
      if ( v13 )
      {
        if ( sub_10051CA1(v8, v13, a2, a8, a7) )
          break;
      }
      if ( !sub_10052A7B(v15, v12, a4, v8, a8) && sub_100519BF(a2, v12, a5) )
      {
        if ( v8 )
          *(_DWORD *)(v10 + 176) = (a6 + 1) % *(_DWORD *)(v10 + 80);
        else
          *(_DWORD *)(v10 + 180) = (a6 + 1) % *(_DWORD *)(v10 + 160);
        break;
      }
      v14 = v10 + 96;
      if ( v8 )
        v14 = v10 + 16;
    }
    result = 1;
  }
  return result;
}

//----- (10052484) --------------------------------------------------------
char __thiscall sub_10052484(void *this, int a2, int a3, int a4, int a5, int i, unsigned int a7, char a8)
{
  int v8; // ebx@1
  int v9; // edi@1
  char result; // al@3
  int v11; // esi@6
  int v12; // eax@7
  int v13; // eax@10
  int v14; // eax@14
  int v15; // [sp+14h] [bp+Ch]@17

  v8 = i;
  v9 = (int)this;
  if ( a4 && sub_10051AC1(this, a2, a4, i, a8)
    || (_BYTE)a5 && sub_10052B45((void *)v9, a2, *(_DWORD *)(*(_DWORD *)v9 + 68), *(_DWORD *)v9) )
  {
    result = 1;
  }
  else
  {
    v11 = a3;
    if ( v8 )
      v12 = sub_10051946(a3, (int)&a5);
    else
      v12 = sub_10051981(a3, (int)&a5);
    for ( i = a5; ; v12 = sub_10032AAA((int)&a5, i, v14) )
    {
      v15 = v12;
      if ( !v12 )
        return 0;
      v13 = sub_10051774(*(_DWORD *)(v9 + 4), *(_DWORD *)(v9 + 8));
      if ( v13 )
      {
        if ( sub_10051CA1(v9, v13, a2, a8, a7) )
          break;
      }
      if ( !sub_10052A7B((void *)v9, v15, a4, v8, a8) && sub_10051A90(a2, v15) )
      {
        if ( v8 )
          *(_DWORD *)(v11 + 176) = (a5 + 1) % *(_DWORD *)(v11 + 80);
        else
          *(_DWORD *)(v11 + 180) = (a5 + 1) % *(_DWORD *)(v11 + 160);
        break;
      }
      v14 = v11 + 96;
      if ( v8 )
        v14 = v11 + 16;
    }
    result = 1;
  }
  return result;
}

//----- (1005258A) --------------------------------------------------------
char __thiscall sub_1005258A(void *this, int a2, int a3, int a4, char a5, int a6, unsigned int a7, char a8)
{
  int v8; // edi@1
  char result; // al@3
  int v10; // esi@4
  int v11; // eax@5
  int v12; // ebx@7
  int v13; // eax@8
  int v14; // eax@12
  void *v15; // [sp+4h] [bp-4h]@1
  int i; // [sp+14h] [bp+Ch]@7

  v8 = a6;
  v15 = this;
  if ( a4 && sub_10051B8F(this, a2, a4, a5, a6, a8) )
  {
    result = 1;
  }
  else
  {
    v10 = a3;
    if ( v8 )
      v11 = sub_10051946(a3, (int)&a6);
    else
      v11 = sub_10051981(a3, (int)&a6);
    v12 = v11;
    for ( i = a6; ; v12 = sub_10032AAA((int)&a6, i, v14) )
    {
      if ( !v12 )
        return 0;
      v13 = sub_10051774(*((_DWORD *)v15 + 1), *((_DWORD *)v15 + 2));
      if ( v13 )
      {
        if ( sub_10051CA1(v8, v13, a2, a8, a7) )
          break;
      }
      if ( !sub_10052A7B(v15, v12, a4, v8, a8) && sub_10051B3C(v8, a2, v12, a8, a5) )
      {
        if ( v8 )
          *(_DWORD *)(v10 + 176) = (a6 + 1) % *(_DWORD *)(v10 + 80);
        else
          *(_DWORD *)(v10 + 180) = (a6 + 1) % *(_DWORD *)(v10 + 160);
        break;
      }
      v14 = v10 + 96;
      if ( v8 )
        v14 = v10 + 16;
    }
    result = 1;
  }
  return result;
}

//----- (10052686) --------------------------------------------------------
char __thiscall sub_10052686(void *this, int a2, int a3, int a4, unsigned int a5)
{
  char v5; // bl@1
  void *v6; // esi@1
  unsigned int v8; // eax@3
  int v9; // edi@3
  int v10; // eax@4
  int v11; // ecx@5
  char v12; // al@5
  int v13; // ecx@10
  int v14; // eax@11
  char v15; // al@12
  int v16; // ecx@16
  int v17; // eax@17
  char v18; // al@18
  int v19; // [sp-8h] [bp-18h]@5
  char v20; // [sp+8h] [bp-8h]@11
  int v21; // [sp+Ch] [bp-4h]@4
  int v22; // [sp+Ch] [bp-4h]@10
  int v23; // [sp+Ch] [bp-4h]@16
  int v24; // [sp+24h] [bp+14h]@17

  v6 = this;
  v5 = 0;
  if ( sub_10051C71(this, a2) )
    return 1;
  v9 = sub_10032B10(*((_DWORD *)v6 + 1));
  v8 = a5;
  if ( !(a5 & 1) )
  {
LABEL_9:
    if ( v8 & 0xA && (v13 = v9, v22 = v9, v9) )
    {
      v14 = v8 >> 1;
      v20 = v14;
      while ( 1 )
      {
        v15 = sub_100528A7(a2, v13, v14 & 1);
        v11 = *((_DWORD *)v6 + 1);
        v19 = v22;
        v5 = v15;
        if ( v15 )
          break;
        v14 = sub_10032AE6(v11, v9, v22);
        v13 = v14;
        v22 = v14;
        LOBYTE(v14) = v20;
        if ( !v13 )
        {
          v8 = a5;
          goto LABEL_15;
        }
      }
    }
    else
    {
LABEL_15:
      if ( !(v8 & 0x14) || (v16 = v9, v23 = v9, !v9) )
        return v5;
      v17 = v8 >> 2;
      v24 = v17;
      while ( 1 )
      {
        v18 = sub_100529A9(a2, v16, v17 & 1);
        v11 = *((_DWORD *)v6 + 1);
        v19 = v23;
        v5 = v18;
        if ( v18 )
          break;
        v17 = sub_10032AE6(v11, v9, v23);
        v16 = v17;
        v23 = v17;
        LOBYTE(v17) = v24;
        if ( !v16 )
          return v5;
      }
    }
    goto LABEL_21;
  }
  v10 = v9;
  v21 = v9;
  if ( v9 )
  {
    while ( 1 )
    {
      v12 = sub_1005293B(a2, v10);
      v19 = v21;
      v11 = *((_DWORD *)v6 + 1);
      v5 = v12;
      if ( v12 )
        break;
      v10 = sub_10032AE6(v11, v9, v21);
      v21 = v10;
      if ( !v10 )
        goto LABEL_7;
    }
LABEL_21:
    sub_100340DE(v11, v19);
    return v5;
  }
LABEL_7:
  v5 = sub_10052B03(v6, a2, *(_DWORD *)(*(_DWORD *)v6 + 68));
  if ( !v5 )
  {
    v8 = a5;
    goto LABEL_9;
  }
  return v5;
}

//----- (10052799) --------------------------------------------------------
char __thiscall sub_10052799(void *this, int a2, int a3, int a4, unsigned int a5)
{
  char v5; // bl@1
  void *v6; // esi@1
  int v8; // eax@3
  int v9; // edi@3
  int v10; // ecx@4
  unsigned int v11; // eax@5
  int v12; // ecx@6
  char v13; // al@6
  int v14; // eax@7
  int v15; // ecx@9
  unsigned int v16; // eax@10
  char v17; // al@11
  int v18; // eax@12
  int v19; // eax@14
  char v20; // al@15
  int v21; // [sp-8h] [bp-18h]@6
  int v22; // [sp+Ch] [bp-4h]@4
  int v23; // [sp+Ch] [bp-4h]@9
  int v24; // [sp+24h] [bp+14h]@14

  v6 = this;
  v5 = 0;
  if ( sub_10051C71(this, a2) )
    return 1;
  v8 = sub_10032B10(*((_DWORD *)v6 + 1));
  v9 = v8;
  if ( a5 & 0x14 )
  {
    v10 = v8;
    v22 = v8;
    if ( v8 )
    {
      v11 = a5 >> 2;
      do
      {
        v13 = sub_100529A9(a2, v10, v11 & 1);
        v12 = *((_DWORD *)v6 + 1);
        v21 = v22;
        v5 = v13;
        if ( v13 )
          goto LABEL_20;
        v14 = sub_10032AE6(v12, v9, v22);
        v10 = v14;
        v22 = v14;
        v11 = a5 >> 2;
      }
      while ( v10 );
    }
  }
  if ( a5 & 0xA )
  {
    v15 = v9;
    v23 = v9;
    if ( v9 )
    {
      v16 = a5 >> 1;
      do
      {
        v17 = sub_100528A7(a2, v15, v16 & 1);
        v12 = *((_DWORD *)v6 + 1);
        v21 = v23;
        v5 = v17;
        if ( v17 )
          goto LABEL_20;
        v18 = sub_10032AE6(v12, v9, v23);
        v15 = v18;
        v23 = v18;
        v16 = a5 >> 1;
      }
      while ( v15 );
    }
  }
  if ( a5 & 1 )
  {
    v19 = v9;
    v24 = v9;
    if ( v9 )
    {
      while ( 1 )
      {
        v20 = sub_1005293B(a2, v19);
        v21 = v24;
        v12 = *((_DWORD *)v6 + 1);
        v5 = v20;
        if ( v20 )
          break;
        v19 = sub_10032AE6(v12, v9, v24);
        v24 = v19;
        if ( !v19 )
          goto LABEL_17;
      }
LABEL_20:
      sub_100340DE(v12, v21);
      return v5;
    }
LABEL_17:
    v5 = sub_10052B03(v6, a2, *(_DWORD *)(*(_DWORD *)v6 + 68));
  }
  return v5;
}

//----- (100528A7) --------------------------------------------------------
char __stdcall sub_100528A7(int a1, int a2, char a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int v5; // eax@3
  char result; // al@5
  signed int v7; // [sp+Ch] [bp-10h]@4
  int v8; // [sp+14h] [bp-8h]@5
  int v9; // [sp+18h] [bp-4h]@1
  int v10; // [sp+28h] [bp+Ch]@1

  v3 = a2;
  v4 = sub_10051981(a2, (int)&v9);
  v10 = v9;
  while ( v4 )
  {
    if ( a3 )
    {
      v5 = sub_1004100C((void *)v4);
      if ( v5 )
      {
        v7 = 2;
        v8 = v5;
LABEL_5:
        result = 1;
        *(_DWORD *)(v3 + 180) = (v9 + 1) % *(_DWORD *)(v3 + 160);
        *(_DWORD *)a1 = v7;
        *(_DWORD *)(a1 + 4) = v4;
        *(_DWORD *)(a1 + 8) = v8;
        return result;
      }
    }
    else
    {
      if ( sub_10041066(v4) )
      {
        v7 = 8;
        goto LABEL_5;
      }
    }
    v4 = sub_10032AAA((int)&v9, v10, v3 + 96);
  }
  return 0;
}

//----- (1005293B) --------------------------------------------------------
char __stdcall sub_1005293B(int a1, int a2)
{
  int v2; // eax@1
  int i; // ebx@1
  int v4; // edi@2
  int v6; // eax@7
  char v7; // [sp+Ch] [bp-10h]@7
  int v8; // [sp+18h] [bp-4h]@1

  v2 = sub_10051981(a2, (int)&v8);
  for ( i = v8; ; v2 = sub_10032AAA((int)&v8, i, a2 + 96) )
  {
    if ( !v2 )
      return 0;
    v4 = (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 12))(v2);
    if ( v4 )
      break;
  }
  *(_DWORD *)(a2 + 180) = (v8 + 1) % *(_DWORD *)(a2 + 160);
  v6 = sub_1005174E((int)&v7, v4);
  *(_DWORD *)a1 = *(_DWORD *)v6;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(v6 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(v6 + 8);
  return 1;
}

//----- (100529A9) --------------------------------------------------------
char __stdcall sub_100529A9(int a1, int a2, char a3)
{
  int v3; // edi@1
  int v4; // esi@1
  int v5; // ebx@3
  char result; // al@5
  signed int v7; // [sp+Ch] [bp-10h]@4
  int v8; // [sp+18h] [bp-4h]@1
  int v9; // [sp+28h] [bp+Ch]@1

  v3 = a2;
  v4 = sub_10051981(a2, (int)&v8);
  v9 = v8;
  while ( v4 )
  {
    if ( a3 )
    {
      v5 = sub_10041636(v4, v3, 0);
      if ( v5 )
      {
        v7 = 4;
LABEL_5:
        result = 1;
        *(_DWORD *)(v3 + 180) = (v8 + 1) % *(_DWORD *)(v3 + 160);
        *(_DWORD *)a1 = v7;
        *(_DWORD *)(a1 + 4) = v4;
        *(_DWORD *)(a1 + 8) = v5;
        return result;
      }
    }
    else
    {
      v5 = sub_1004123C((void *)v4);
      if ( v5 )
      {
        v7 = 16;
        goto LABEL_5;
      }
    }
    v4 = sub_10032AAA((int)&v8, v9, v3 + 96);
  }
  return 0;
}

//----- (10052A41) --------------------------------------------------------
int __thiscall sub_10052A41(int this, int a2)
{
  int result; // eax@1

  result = a2 - *(_DWORD *)(this + 264);
  if ( (unsigned int)result > 0x64 )
    *(_DWORD *)(this + 264) = a2;
  return result;
}

//----- (10052A5E) --------------------------------------------------------
int __thiscall sub_10052A5E(int this, int a2)
{
  int result; // eax@1

  result = a2 - *(_DWORD *)(this + 184);
  if ( (unsigned int)result > 0x64 )
    *(_DWORD *)(this + 184) = a2;
  return result;
}

//----- (10052A7B) --------------------------------------------------------
char __thiscall sub_10052A7B(void *this, int a2, int a3, int a4, char a5)
{
  void *v5; // edi@1
  int v7; // edx@3
  char v8; // bl@3
  char v9; // zf@9

  v5 = this;
  if ( a2 == a3 )
    return 1;
  v8 = 0;
  v7 = a2 + 12;
  if ( !a4 )
    return (*(_DWORD *)v7 & 0xFFFFFFF) != 0;
  if ( a4 == 1 )
  {
    if ( !(*(_DWORD *)v7 & 0xFFFFFFF) )
      return 1;
    v9 = sub_1004D750(*(_DWORD *)this + 136, a2 + 12) == 0;
  }
  else
  {
    if ( a4 != 2 )
      return v8;
    if ( !(*(_DWORD *)v7 & 0xFFFFFFF) || sub_1004D750(*(_DWORD *)this + 136, a2 + 12) )
      return 1;
    if ( !sub_10033369(*((_DWORD *)v5 + 1) + 60, a2 + 28) )
      return v8;
    v9 = a5 == 0;
  }
  if ( v9 )
    return 1;
  return v8;
}

//----- (10052B03) --------------------------------------------------------
char __thiscall sub_10052B03(void *this, int a2, int a3)
{
  void *v3; // esi@1
  int v4; // eax@5
  int i; // [sp-4h] [bp-Ch]@1
  int v7; // [sp+4h] [bp-4h]@1

  v7 = 0;
  v3 = this;
  for ( i = -1; ; i = 0 )
  {
    v4 = sub_100518F9(*((_DWORD *)v3 + 1), (int)&v7, i);
    if ( !v4 )
      return 0;
    if ( v4 != a3 && sub_10052B45(v3, a2, v4, 0) )
      break;
  }
  return 1;
}

//----- (10052B45) --------------------------------------------------------
char __thiscall sub_10052B45(void *this, int a2, int a3, int a4)
{
  int i; // eax@1
  void *v5; // ebx@1
  int ebp0; // ebp@0
  int v7; // edi@1
  int v8; // eax@3
  int v9; // esi@5
  int v11; // eax@8
  char v12; // [sp+Ch] [bp-Ch]@8

  v7 = a3;
  v5 = this;
  for ( i = sub_1003257C((void *)a3, 0, *(_DWORD *)(a3 + 120), (int)&a3); ; i = sub_10032B53(v7, (int)&a3, 0) )
  {
    v9 = i;
    if ( !i )
      return 0;
    if ( i != a4 )
    {
      sub_10052A5E(i, *((_DWORD *)v5 + 4));
      v8 = sub_10052BB1(v9, ebp0);
      if ( v8 )
        break;
    }
  }
  v11 = sub_1005174E((int)&v12, v8);
  *(_DWORD *)a2 = *(_DWORD *)v11;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(v11 + 4);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(v11 + 8);
  return 1;
}

//----- (10052BB1) --------------------------------------------------------
int __usercall sub_10052BB1<eax>(int a1<ecx>, int a2<ebp>)
{
  int v2; // edx@1

  v2 = 0;
  if ( *(_DWORD *)(a1 + 16) > *(_DWORD *)(a1 + 12) )
    v2 = sub_10045E77(a2, 0);
  return v2;
}

//----- (10052BC8) --------------------------------------------------------
void __thiscall sub_10052BC8(void *this, int a2)
{
  int v2; // eax@1
  void *v3; // edi@1
  void *v4; // ecx@2
  int v5; // [sp-8h] [bp-10h]@3
  char v6; // [sp-4h] [bp-Ch]@3

  v3 = this;
  v2 = sub_1003D43F(a2 + 4);
  if ( *(_DWORD *)v3 == 2 )
  {
    v4 = *(void **)(v2 + 256);
    if ( v4 == *(void **)(*((_DWORD *)v3 + 1) + 256) )
    {
      sub_1003333B(v4);
      return;
    }
    v6 = 0;
    v5 = *((_DWORD *)v3 + 1);
  }
  else
  {
    if ( *(_DWORD *)(v2 + 256) == *(_DWORD *)(*((_DWORD *)v3 + 1) + 256) )
      return;
    v6 = 1;
    v5 = *((_DWORD *)v3 + 1);
  }
  sub_10046D5C(a2, v5, v6);
}

//----- (10052C1D) --------------------------------------------------------
int __thiscall sub_10052C1D(int this)
{
  return (*(int (__cdecl **)(_DWORD))(this + 4))(*(_DWORD *)(this + 8));
}

//----- (10052C25) --------------------------------------------------------
int __userpurge sub_10052C25<eax>(int a1<ebp>, int a2, int a3)
{
  int v4; // ecx@1
  int v5; // esi@1
  int v6; // ST04_4@1
  int v7; // ST00_4@1

  sub_10035648();
  v5 = v4;
  *(_DWORD *)(a1 - 16) = v4;
  loc_10044DBF();
  v6 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a1 - 4) = 0;
  v7 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)v5 = &off_10066830;
  sub_10045113(v5, v7, v6);
  return sub_10035616(4);
}
// 10035616: using guessed type int __cdecl sub_10035616(_DWORD);
// 10044DBF: using guessed type _DWORD loc_10044DBF();
// 10066830: using guessed type int (__stdcall *off_10066830)(char);

//----- (10052C5C) --------------------------------------------------------
void *__thiscall sub_10052C5C(void *this, char a2)
{
  int ebp0; // ebp@0
  void *v3; // esi@1

  v3 = this;
  *(_DWORD *)this = &off_10066830;
  sub_10044E27(ebp0);
  if ( a2 & 1 )
    sub_1002A4AA(v3);
  return v3;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10066830: using guessed type int (__stdcall *off_10066830)(char);

//----- (10052C81) --------------------------------------------------------
void __usercall sub_10052C81(int a1<edx>, int a2<ecx>, int a3<ebx>)
{
  int v3; // edx@1
  int v4; // edi@1
  signed int i; // esi@1
  int v6; // eax@3
  int v7; // eax@5

  v4 = 0;
  sub_10036A23(a1, a2, a3, 0, 1);
  for ( i = 3; i < dword_100768A0; ++i )
  {
    v6 = *((_DWORD *)dword_1007689C + i);
    if ( v6 )
    {
      if ( *(_BYTE *)(v6 + 12) & 0x83 )
      {
        sub_10055648(v3, a3, *((_DWORD *)dword_1007689C + i));
        if ( v7 != -1 )
          ++v4;
      }
      if ( i >= 20 )
      {
        DeleteCriticalSection((LPCRITICAL_SECTION)(*((_DWORD *)dword_1007689C + i) + 32));
        sub_100309C2(a3, *((LPVOID *)dword_1007689C + i));
        *((_DWORD *)dword_1007689C + i) = 0;
      }
    }
  }
  sub_10036B87(1);
}
// 100768A0: using guessed type int dword_100768A0;

//----- (10052D1E) --------------------------------------------------------
void __usercall sub_10052D1E(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  DWORD v4; // esi@6
  void *v5; // eax@7

  if ( a4 == -2 )
  {
    *(_DWORD *)sub_10037649(a3) = 9;
    return;
  }
  if ( a4 >= 0 )
  {
    if ( a4 < (unsigned int)dword_10076898 )
    {
      a3 = (a4 & 0x1F) << 6;
      if ( *(_BYTE *)(a3 + dword_10075F80[a4 >> 5] + 4) & 1 )
      {
        sub_100553FC(a1, a2, a3, a4);
        v4 = 0;
        if ( *(_BYTE *)(a3 + dword_10075F80[a4 >> 5] + 4) & 1 )
        {
          v5 = (void *)sub_1005550E(a3, a4, a4);
          if ( !FlushFileBuffers(v5) )
            v4 = GetLastError();
          if ( !v4 )
            goto LABEL_12;
          *(_DWORD *)sub_10037615(a3) = v4;
        }
        *(_DWORD *)sub_10037649(a3) = 9;
LABEL_12:
        sub_10055575(a4);
        return;
      }
    }
  }
  *(_DWORD *)sub_10037649(a3) = 9;
  sub_1003A151(a3, a4);
}
// 10075F80: using guessed type int dword_10075F80[];
// 10076898: using guessed type int dword_10076898;

//----- (10052E30) --------------------------------------------------------
#error "10052E4B: call analysis failed (funcsize=22)"

//----- (10052E75) --------------------------------------------------------
int __usercall sub_10052E75<eax>(int a1<ebp>, int a2, unsigned int a3)
{
  int result; // eax@2
  int v4; // ebx@2
  unsigned int v5; // esi@2
  int v6; // esi@5
  int (__cdecl *v7)(int, int, int, int, int); // [sp+4h] [bp-1Ch]@1
  int v8; // [sp+8h] [bp-18h]@1
  int v9; // [sp+Ch] [bp-14h]@1

  v9 = a2;
  v8 = -2;
  v7 = sub_10052E30;
  while ( 1 )
  {
    result = a2;
    v4 = *(_DWORD *)(a2 + 8);
    v5 = *(_DWORD *)(a2 + 12);
    if ( v5 == -1 )
      break;
    if ( a3 != -1 && v5 <= a3 )
      break;
    v6 = 3 * v5;
    v8 = *(_DWORD *)(v4 + 4 * v6);
    *(_DWORD *)(a2 + 12) = v8;
    if ( !*(_DWORD *)(v4 + 4 * v6 + 4) )
    {
      sub_10052F25(*(_DWORD *)(v4 + 4 * v6 + 8), a1, 257);
      sub_10052F44(*(int (**)(void))(v4 + 4 * v6 + 8));
    }
  }
  return result;
}
// 10052E30: using guessed type int __cdecl sub_10052E30(int, int, int, int, int);

//----- (10052F1C) --------------------------------------------------------
void __cdecl sub_10052F1C()
{
  JUMPOUT(*(unsigned int *)loc_10052F30);
}
// 10052F30: using guessed type int __stdcall loc_10052F30(int);

//----- (10052F25) --------------------------------------------------------
int __userpurge sub_10052F25<eax>(int result<eax>, int a2<ebp>, int a3)
{
  dword_10074470[2] = a3;
  dword_10074470[1] = result;
  dword_10074470[3] = a2;
  return result;
}

//----- (10052F44) --------------------------------------------------------
int __usercall sub_10052F44<eax>(int (*a1)(void)<eax>)
{
  return a1();
}

//----- (10052F50) --------------------------------------------------------
int __thiscall sub_10052F50(void *this, unsigned int a2, unsigned __int8 a3)
{
  signed int v4; // eax@3
  int v5; // edx@3
  int v8; // ecx@4
  int v10; // eax@5
  int result; // eax@8
  char v27; // cf@18
  char v28; // zf@18
  signed int v31; // edx@22
  signed int v38; // ecx@25
  unsigned int v39; // edi@25
  char v40; // zf@27
  int v41; // ecx@29
  int v42; // edi@29
  char v43; // zf@31
  int v44; // edi@33

  if ( (unsigned int)dword_1007577C < 1 )
  {
    v39 = a2;
    v38 = -1;
    do
    {
      if ( !v38 )
        break;
      v40 = *(_BYTE *)v39++ == 0;
      --v38;
    }
    while ( !v40 );
    v41 = -(v38 + 1);
    v42 = v39 - 1;
    do
    {
      if ( !v41 )
        break;
      v43 = *(_BYTE *)v42++ == a3;
      --v41;
    }
    while ( !v43 );
    v44 = v42 + 1;
    if ( *(_BYTE *)v44 == a3 )
      result = v44;
    else
      result = 0;
  }
  else
  {
    _EDI = a2;
    if ( (unsigned int)dword_1007577C > 1 )
    {
      _EDX = a3;
      if ( a3 )
      {
        result = 0;
        if ( a2 & 0xF )
        {
          while ( 1 )
          {
            this = (void *)*(_BYTE *)_EDI;
            if ( this == (void *)a3 )
              result = _EDI;
            if ( !*(_BYTE *)_EDI )
              break;
            ++_EDI;
            if ( !(_EDI & 0xF) )
              goto LABEL_17;
          }
        }
        else
        {
LABEL_17:
          __asm { movd    xmm0, edx }
          do
          {
            v27 = _EDI >= 0xFFFFFFF0;
            v28 = _EDI == -16;
            _EDI += 16;
            __asm { pcmpistri xmm0, xmmword ptr [edi-10h], 40h }
            this += _EDI - 16;
            if ( v27 )
              result = (int)this;
          }
          while ( !v28 );
        }
      }
      else
      {
        _EAX = a2 & 0xFFFFFFF0;
        __asm
        {
          pxor    xmm0, xmm0
          pcmpeqb xmm0, xmmword ptr [eax]
        }
        v31 = -1 << (a2 & 0xF);
        __asm { pmovmskb edi, xmm0 }
        _EDI = v31 & _EDI;
        while ( !_EDI )
        {
          __asm
          {
            pxor    xmm0, xmm0
            pcmpeqb xmm0, xmmword ptr [eax+10h]
          }
          _EAX += 16;
          __asm { pmovmskb edi, xmm0 }
        }
        __asm { bsf     edx, edi }
        result = _EDX + _EAX;
      }
    }
    else
    {
      _EDX = a3 | (a3 << 8);
      __asm
      {
        movd    xmm3, edx
        pshuflw xmm3, xmm3, 0
        movlhps xmm3, xmm3
      }
      v4 = -1 << (a2 & 0xF);
      _EDI = a2 - (a2 & 0xF);
      v5 = 0;
      while ( 1 )
      {
        __asm
        {
          movdqu  xmm1, xmmword ptr [edi]
          pxor    xmm2, xmm2
          pcmpeqb xmm2, xmm1
          pcmpeqb xmm1, xmm3
          pmovmskb ecx, xmm2
        }
        v8 = v4 & _ECX;
        if ( v8 )
          break;
        __asm { pmovmskb ecx, xmm1 }
        _ECX = v4 & _ECX;
        __asm { bsr     eax, ecx }
        v10 = _EDI + _EAX;
        if ( _ECX )
          v5 = v10;
        v4 = -1;
        _EDI += 16;
      }
      __asm { pmovmskb ebx, xmm1 }
      _ECX = v4 & _EBX & ((-2 * v8 & 2 * v8) - 1);
      __asm { bsr     eax, ecx }
      result = _EDI + _EAX;
      if ( !_ECX )
        result = v5;
    }
  }
  return result;
}
// 1007577C: using guessed type int dword_1007577C;

//----- (10053087) --------------------------------------------------------
signed int __usercall sub_10053087<eax>(int a1<ebx>, int a2, unsigned int a3, int a4, int a5)
{
  int v5; // edx@1
  int v6; // edi@1
  int v7; // eax@2
  int v9; // ecx@5
  int v10; // eax@6
  int v11; // eax@10
  char v12; // dl@11
  int v13; // eax@24
  signed int v14; // [sp-4h] [bp-Ch]@2

  v5 = a5;
  v6 = *(_DWORD *)(a5 + 12);
  if ( !a2 || !a3 )
  {
    v7 = sub_10037649(a1);
    v14 = 22;
LABEL_3:
    *(_DWORD *)v7 = v14;
    sub_1003A151(a1, v6);
    return v14;
  }
  v9 = a4;
  *(_BYTE *)a2 = 0;
  if ( a4 <= 0 )
    v10 = 0;
  else
    v10 = a4;
  if ( a3 <= v10 + 1 )
  {
    v7 = sub_10037649(a1);
    v14 = 34;
    goto LABEL_3;
  }
  *(_BYTE *)a2 = 48;
  v11 = a2 + 1;
  if ( a4 > 0 )
  {
    do
    {
      v12 = *(_BYTE *)v6;
      if ( *(_BYTE *)v6 )
        ++v6;
      else
        v12 = 48;
      *(_BYTE *)v11++ = v12;
      --v9;
    }
    while ( v9 > 0 );
    v5 = a5;
  }
  *(_BYTE *)v11 = 0;
  if ( v9 >= 0 )
  {
    if ( *(_BYTE *)v6 >= 53 )
    {
      while ( 1 )
      {
        --v11;
        if ( *(_BYTE *)v11 != 57 )
          break;
        *(_BYTE *)v11 = 48;
      }
      ++*(_BYTE *)v11;
    }
  }
  if ( *(_BYTE *)a2 == 49 )
  {
    ++*(_DWORD *)(v5 + 4);
  }
  else
  {
    v13 = sub_10035530(a2 + 1);
    sub_1002A4B0((void *)a2, (const void *)(a2 + 1), v13 + 1);
  }
  return 0;
}

//----- (10053137) --------------------------------------------------------
signed int __usercall sub_10053137<eax>(int a1<ebx>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  signed int v5; // ebx@1
  signed int v7; // [sp-4h] [bp-38h]@4
  char v8; // [sp+Ch] [bp-28h]@1
  int v9; // [sp+14h] [bp-20h]@10
  char v10; // [sp+18h] [bp-1Ch]@9
  char v11; // [sp+1Ch] [bp-18h]@1
  int v12; // [sp+20h] [bp-14h]@1
  char v13; // [sp+24h] [bp-10h]@1
  unsigned int v14; // [sp+30h] [bp-4h]@1
  int v15; // [sp+34h] [bp+0h]@1

  v14 = (unsigned int)&v15 ^ __security_cookie;
  sub_100301AD((int)&v8, a1, a2, a4);
  v5 = 0;
  v12 = sub_10056393((int)&v13, (int)&v11, a3, 0, 0, 0, 0, (int)&v8);
  v4 = sub_100558B3((int)&v13, a2);
  if ( !(v12 & 3) )
  {
    if ( v4 != 1 )
    {
      if ( v4 != 2 )
        goto LABEL_9;
      goto LABEL_4;
    }
LABEL_7:
    v7 = 3;
    goto LABEL_8;
  }
  if ( !(v12 & 1) )
  {
    if ( !(v12 & 2) )
      goto LABEL_9;
    goto LABEL_7;
  }
LABEL_4:
  v7 = 4;
LABEL_8:
  v5 = v7;
LABEL_9:
  if ( v10 )
    *(_DWORD *)(v9 + 112) &= 0xFFFFFFFDu;
  return v5;
}
// 10073200: using guessed type int __security_cookie;

//----- (100531C3) --------------------------------------------------------
signed int __usercall sub_100531C3<eax>(int a1<ebx>, int a2, int a3, int a4)
{
  signed int v4; // ecx@1
  signed int v5; // ebx@1
  signed int v7; // [sp-4h] [bp-38h]@4
  char v8; // [sp+Ch] [bp-28h]@1
  int v9; // [sp+14h] [bp-20h]@10
  char v10; // [sp+18h] [bp-1Ch]@9
  char v11; // [sp+1Ch] [bp-18h]@1
  int v12; // [sp+20h] [bp-14h]@1
  char v13; // [sp+24h] [bp-10h]@1
  unsigned int v14; // [sp+30h] [bp-4h]@1
  int v15; // [sp+34h] [bp+0h]@1

  v14 = (unsigned int)&v15 ^ __security_cookie;
  sub_100301AD((int)&v8, a1, a2, a4);
  v5 = 0;
  v12 = sub_10056393((int)&v13, (int)&v11, a3, 0, 0, 0, 0, (int)&v8);
  v4 = sub_10055E23((int)&v13, a2);
  if ( !(v12 & 3) )
  {
    if ( v4 != 1 )
    {
      if ( v4 != 2 )
        goto LABEL_9;
      goto LABEL_4;
    }
LABEL_7:
    v7 = 3;
    goto LABEL_8;
  }
  if ( !(v12 & 1) )
  {
    if ( !(v12 & 2) )
      goto LABEL_9;
    goto LABEL_7;
  }
LABEL_4:
  v7 = 4;
LABEL_8:
  v5 = v7;
LABEL_9:
  if ( v10 )
    *(_DWORD *)(v9 + 112) &= 0xFFFFFFFDu;
  return v5;
}
// 10073200: using guessed type int __security_cookie;

//----- (1005324F) --------------------------------------------------------
__int16 __cdecl sub_1005324F(int a1, int a2)
{
  int v2; // edx@1
  unsigned int v3; // ecx@1
  signed int v4; // ebx@1
  __int16 v5; // di@1
  unsigned int v6; // esi@1
  int v7; // edx@1
  int v8; // eax@3
  int v9; // esi@10
  int v10; // edi@11
  __int16 v12; // [sp+Ch] [bp-8h]@1
  unsigned int v13; // [sp+10h] [bp-4h]@1
  int v14; // [sp+20h] [bp+Ch]@13

  v7 = *(_DWORD *)(a2 + 4);
  v3 = ((unsigned int)*(_WORD *)(a2 + 6) >> 4) & 0x7FF;
  v5 = *(_WORD *)(a2 + 6) & 0x8000;
  v6 = ((unsigned int)*(_WORD *)(a2 + 6) >> 4) & 0x7FF;
  v2 = v7 & 0xFFFFF;
  v4 = -2147483648;
  v12 = *(_WORD *)(a2 + 6) & 0x8000;
  v13 = *(_DWORD *)a2;
  if ( !v6 )
  {
    if ( !v2 && !*(_DWORD *)a2 )
    {
      v8 = a1;
      *(_DWORD *)(v8 + 4) &= v2;
      *(_DWORD *)v8 &= v2;
      *(_WORD *)(a1 + 8) = v5;
      return v8;
    }
    v8 = v3 + 15361;
    v4 = 0;
    goto LABEL_9;
  }
  if ( v6 != 2047 )
  {
    v8 = v3 + 15360;
LABEL_9:
    v8 = (unsigned __int16)v8;
    goto LABEL_10;
  }
  v8 = 32767;
LABEL_10:
  v9 = v4 | (v2 << 11) | (v13 >> 21);
  *(_DWORD *)(a1 + 4) = v9;
  *(_DWORD *)a1 = v13 << 11;
  if ( v9 >= 0 )
  {
    v10 = v8;
    do
    {
      v10 += 65535;
      v9 = (*(_DWORD *)a1 >> 31) | 2 * v9;
      *(_DWORD *)a1 *= 2;
    }
    while ( v9 >= 0 );
    v14 = v10;
    v5 = v12;
    LOWORD(v8) = v14;
    *(_DWORD *)(a1 + 4) = v9;
  }
  *(_WORD *)(a1 + 8) = v8 | v5;
  return v8;
}

//----- (100533B0) --------------------------------------------------------
int __stdcall sub_100533B0(unsigned __int64 a1, __int64 a2)
{
  signed int v2; // edi@1
  int v3; // eax@3
  int v4; // esi@6
  unsigned __int64 v5; // qtt@6
  unsigned __int64 v6; // qax@7
  unsigned int v7; // ecx@7
  unsigned int v8; // ebx@7
  char v9; // cf@8
  char v10; // cf@8
  int v11; // eax@9
  unsigned __int64 v12; // qax@9
  int v13; // ecx@9
  char v14; // cf@9
  int result; // eax@13

  v2 = 0;
  if ( HIDWORD(a1) < 0 )
  {
    v2 = 1;
    HIDWORD(a1) = -HIDWORD(a1) - ((_DWORD)a1 != 0);
    LODWORD(a1) = -(_DWORD)a1;
  }
  v3 = HIDWORD(a2);
  if ( HIDWORD(a2) < 0 )
  {
    ++v2;
    v3 = -HIDWORD(a2) - ((_DWORD)a2 != 0);
    HIDWORD(a2) = -HIDWORD(a2) - ((_DWORD)a2 != 0);
    LODWORD(a2) = -(_DWORD)a2;
  }
  if ( v3 )
  {
    v8 = v3;
    v7 = a2;
    v6 = a1;
    do
    {
      v9 = v8 & 1;
      v8 >>= 1;
      v7 = __RCR__(v7, v9);
      v10 = BYTE4(v6) & 1;
      HIDWORD(v6) >>= 1;
      LODWORD(v6) = __RCR__(v6, v10);
    }
    while ( v8 );
    v11 = v6 / v7;
    v4 = v11;
    v13 = HIDWORD(a2) * v11;
    v12 = v11 * (unsigned int)a2;
    v14 = v13 >= (unsigned int)-HIDWORD(v12);
    HIDWORD(v12) += v13;
    if ( v14 || HIDWORD(v12) > HIDWORD(a1) || v12 > a1 )
      --v4;
  }
  else
  {
    LODWORD(v5) = a1;
    HIDWORD(v5) = HIDWORD(a1) % (_DWORD)a2;
    v4 = v5 / (unsigned int)a2;
  }
  result = v4;
  if ( v2 == 1 )
    result = -v4;
  return result;
}

//----- (10053490) --------------------------------------------------------
unsigned __int64 __usercall sub_10053490<edx:eax>(unsigned __int64 a1<edx:eax>, unsigned __int8 a2<cl>)
{
  unsigned __int64 result; // qax@2

  if ( a2 >= 0x40u )
    result = 0i64;
  else
    result = a1 >> a2;
  return result;
}

//----- (100534AF) --------------------------------------------------------
signed int __usercall sub_100534AF<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  signed int result; // eax@4
  int v6; // [sp-4h] [bp-8h]@5

  if ( a5 & 0xFFF7FFFF & a4 & 0xFCF0FCE0 )
  {
    if ( a3 )
      *(_DWORD *)a3 = sub_1005757C(0, 0);
    *(_DWORD *)sub_10037649(a1) = 22;
    sub_1003A151(a1, a2);
    result = 22;
  }
  else
  {
    v6 = a5 & 0xFFF7FFFF;
    if ( a3 )
      *(_DWORD *)a3 = sub_1005757C(a4, v6);
    else
      sub_1005757C(a4, v6);
    result = 0;
  }
  return result;
}

//----- (1005350C) --------------------------------------------------------
void __usercall sub_1005350C(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  sub_1003AF82(a1, a2, a3, a4, 2);
}

//----- (10053515) --------------------------------------------------------
WCHAR __usercall sub_10053515<ax>(int a1<ebx>, int a2<edi>, const WCHAR SrcStr, int a4)
{
  WCHAR result; // ax@1
  int v5; // eax@2
  void *v6; // ecx@2
  int v7; // esi@2
  WCHAR v8; // cx@3
  int v9; // [sp+0h] [bp-14h]@2
  int v10; // [sp+8h] [bp-Ch]@17
  char v11; // [sp+Ch] [bp-8h]@16
  WCHAR DestStr; // [sp+10h] [bp-4h]@12

  result = -1;
  if ( SrcStr != -1 )
  {
    sub_100301AD((int)&v9, a1, a2, a4);
    v7 = v9;
    v5 = *(_DWORD *)(v9 + 168);
    if ( v5 )
    {
      if ( SrcStr >= 0x100u )
      {
        if ( sub_10039DCD(v5, 0x100u, &SrcStr, 1u, &DestStr, 1) )
          result = DestStr;
        else
          result = SrcStr;
      }
      else
      {
        if ( sub_1004EA92(v6, SrcStr, 1) )
          result = *(_BYTE *)(*(_DWORD *)(v7 + 148) + SrcStr);
        else
          result = SrcStr;
      }
    }
    else
    {
      v8 = SrcStr;
      if ( (unsigned __int16)(SrcStr - 65) <= 0x19u )
        v8 = SrcStr + 32;
      result = v8;
    }
    if ( v11 )
      *(_DWORD *)(v10 + 112) &= 0xFFFFFFFDu;
  }
  return result;
}

//----- (100535C7) --------------------------------------------------------
int __usercall sub_100535C7<eax>(int a1<ebp>, int a2, int a3, int a4)
{
  int v4; // eax@1
  int v5; // ecx@1
  int v6; // eax@1
  int v7; // eax@2
  int v8; // eax@3
  int v9; // eax@4
  int v10; // eax@5
  int v11; // eax@6
  signed int v12; // edi@14
  double v13; // ST10_8@14
  int v15; // ST18_4@26
  int v16; // ST1C_4@26
  char v17; // ST20_1@26
  signed int v18; // [sp-98h] [bp-A0h]@8
  int v19; // [sp-88h] [bp-90h]@1
  char v20; // [sp-84h] [bp-8Ch]@20
  double v21; // [sp-54h] [bp-5Ch]@19
  int v22; // [sp-44h] [bp-4Ch]@18
  unsigned int v23; // [sp-8h] [bp-10h]@1
  int v24; // [sp-4h] [bp-Ch]@1
  void *v25; // [sp+0h] [bp-8h]@1
  char v26; // [sp+4h] [bp-4h]@25
  int v27; // [sp+8h] [bp+0h]@1

  v24 = a1;
  v25 = (void *)v27;
  v23 = (unsigned int)&v24 ^ __security_cookie;
  v5 = *(_WORD *)a4;
  v6 = *(_DWORD *)a3;
  v19 = *(_WORD *)a4;
  v4 = v6 - 1;
  if ( !v4 )
    goto LABEL_29;
  v7 = v4 - 1;
  if ( !v7 )
  {
    v18 = 4;
    goto LABEL_14;
  }
  v8 = v7 - 1;
  if ( !v8 )
  {
    v18 = 17;
    goto LABEL_14;
  }
  v9 = v8 - 1;
  if ( !v9 )
  {
    v18 = 18;
    goto LABEL_14;
  }
  v10 = v9 - 1;
  if ( !v10 )
  {
LABEL_29:
    v18 = 8;
    goto LABEL_14;
  }
  v11 = v10 - 2;
  if ( !v11 )
  {
    *(_DWORD *)a3 = 1;
    goto LABEL_22;
  }
  if ( v11 == 1 )
  {
    v18 = 16;
LABEL_14:
    v12 = v18;
    HIDWORD(v13) = v5;
    LODWORD(v13) = a3 + 24;
    if ( !sub_1004990A(v12, v13) )
    {
      if ( a2 == 16 || a2 == 22 || a2 == 29 )
      {
        v21 = *(double *)(a3 + 16);
        v22 = v22 & 0xFFFFFFE3 | 3;
      }
      else
      {
        v22 &= 0xFFFFFFFEu;
      }
      sub_10049B36((ULONG_PTR)&v20, (int)&v19, v12, a2, a3 + 8, a3 + 24);
    }
    LOWORD(v5) = v19;
  }
LABEL_22:
  sub_10049F8C(v5);
  if ( *(_DWORD *)a3 == 8 || dword_10074480 || !sub_1004EAE4() )
    sub_10049E3C((int)&v26, *(_DWORD *)a3);
  return sub_1002A49B((int)&v26, v15, v16, (unsigned int)&v24 ^ v23, v17);
}
// 100535C7: could not find valid save-restore pair for ebp
// 10073200: using guessed type int __security_cookie;
// 10074480: using guessed type int dword_10074480;

//----- (100536D0) --------------------------------------------------------
int __usercall sub_100536D0<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, signed int a6, int a7)
{
  int v7; // ebx@8
  int v8; // edi@8
  int i; // esi@8
  int v10; // eax@10
  __int16 v11; // ax@11
  int v12; // eax@14
  char v13; // cl@16
  int v14; // ebx@19
  unsigned int v15; // edi@19
  int v16; // eax@35
  int v17; // edx@35
  __int16 v18; // ax@36
  int v19; // eax@37
  int v20; // eax@39
  int v21; // eax@46
  int v22; // esi@51
  int v23; // eax@61
  signed int v25; // [sp-10h] [bp-34h]@24
  int v26; // [sp+0h] [bp-24h]@1
  int v27; // [sp+8h] [bp-1Ch]@72
  char v28; // [sp+Ch] [bp-18h]@71
  int v29; // [sp+10h] [bp-14h]@35
  unsigned int v30; // [sp+14h] [bp-10h]@35
  unsigned int v31; // [sp+18h] [bp-Ch]@8
  int v32; // [sp+1Ch] [bp-8h]@19
  char v33; // [sp+23h] [bp-1h]@14

  sub_100301AD((int)&v26, a1, a2, a3);
  if ( a5 )
    *(_DWORD *)a5 = a4;
  if ( !a4 || (a2 = a6, a6) && (a6 < 2 || a6 > 36) )
  {
    *(_DWORD *)sub_10037649(a1) = 22;
    sub_1003A151(a1, a2);
LABEL_70:
    v14 = 0;
    goto LABEL_71;
  }
  v8 = v26;
  v31 = 0;
  v7 = *(_BYTE *)a4;
  for ( i = a4 + 1; ; ++i )
  {
    if ( *(_DWORD *)(v8 + 116) <= 1 )
    {
      v11 = *(_WORD *)(*(_DWORD *)(v8 + 144) + 2 * (unsigned __int8)v7);
      v10 = v11 & 8;
    }
    else
    {
      v10 = sub_1004256E(v7, v8, (unsigned __int8)v7, 8, (int)&v26);
      v8 = v26;
    }
    if ( !v10 )
      break;
    LOBYTE(v7) = *(_BYTE *)i;
  }
  v12 = a7;
  v33 = v7;
  if ( (_BYTE)v7 == 45 )
  {
    v12 = a7 | 2;
  }
  else
  {
    if ( (_BYTE)v7 != 43 )
    {
      v13 = v33;
      goto LABEL_19;
    }
  }
  v13 = *(_BYTE *)i;
  v33 = *(_BYTE *)i++;
LABEL_19:
  v15 = a6;
  v14 = v31;
  v32 = v12;
  if ( a6 < 0 || a6 == 1 || a6 > 36 )
  {
    if ( a5 )
      *(_DWORD *)a5 = a4;
    goto LABEL_70;
  }
  if ( !a6 )
  {
    if ( v13 != 48 )
    {
      v25 = 10;
LABEL_25:
      v15 = v25;
      goto LABEL_35;
    }
    if ( *(_BYTE *)i != 120 && *(_BYTE *)i != 88 )
    {
      v25 = 8;
      goto LABEL_25;
    }
    v15 = 16;
    goto LABEL_32;
  }
  if ( a6 == 16 && v13 == 48 )
  {
LABEL_32:
    if ( *(_BYTE *)i == 120 || *(_BYTE *)i == 88 )
    {
      v13 = *(_BYTE *)(i + 1);
      v33 = *(_BYTE *)(i + 1);
      i += 2;
    }
  }
LABEL_35:
  v31 = 0xFFFFFFFF / v15;
  v30 = 0xFFFFFFFF % v15;
  v16 = *(_DWORD *)(v26 + 144);
  v17 = v32;
  v29 = *(_DWORD *)(v26 + 144);
  while ( 1 )
  {
    v18 = *(_WORD *)(v16 + 2 * (unsigned __int8)v13);
    if ( v18 & 4 )
    {
      v19 = v33 - 48;
    }
    else
    {
      if ( !(v18 & 0x103) )
        break;
      v20 = v33;
      if ( (unsigned __int8)(v33 - 97) <= 0x19u )
        v20 = v33 - 32;
      v19 = v20 - 55;
    }
    if ( v19 >= v15 )
      break;
    v17 |= 8u;
    if ( v14 < v31 || v14 == v31 && v19 <= v30 )
    {
      v14 = v19 + v15 * v14;
    }
    else
    {
      v21 = a5;
      v17 |= 4u;
      if ( !a5 )
        goto LABEL_51;
    }
    v13 = *(_BYTE *)i;
    v16 = v29;
    v33 = *(_BYTE *)i++;
  }
  v21 = a5;
LABEL_51:
  v22 = i - 1;
  v32 = v17;
  if ( v17 & 8 )
  {
    if ( v17 & 4
      || !(v17 & 1) && (v17 & 2 && (unsigned int)v14 > 0x80000000 || !(v17 & 2) && (unsigned int)v14 > 0x7FFFFFFF) )
    {
      v23 = sub_10037649(v14);
      LOBYTE(v17) = v32;
      *(_DWORD *)v23 = 34;
      if ( v17 & 1 )
        v14 = -1;
      else
        v14 = ((v17 & 2) != 0) + 2147483647;
    }
  }
  else
  {
    if ( v21 )
      v22 = a4;
    v14 = 0;
  }
  if ( a5 )
    *(_DWORD *)a5 = v22;
  if ( v17 & 2 )
    v14 = -v14;
LABEL_71:
  if ( v28 )
    *(_DWORD *)(v27 + 112) &= 0xFFFFFFFDu;
  return v14;
}

//----- (100538F4) --------------------------------------------------------
int __usercall sub_100538F4<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, signed int a5)
{
  int v6; // [sp-14h] [bp-14h]@2

  if ( dword_10075F28 )
    v6 = 0;
  else
    v6 = (int)&off_10073C00;
  return sub_100536D0(a1, a2, v6, a3, a4, a5, 0);
}
// 10073C00: using guessed type int *off_10073C00;
// 10075F28: using guessed type int dword_10075F28;

//----- (1005391E) --------------------------------------------------------
const WCHAR *__usercall sub_1005391E<eax>(int a1<ebx>)
{
  DWORD v1; // edi@1
  LPVOID v2; // esi@1
  int v3; // eax@2
  int v4; // ecx@2
  int v5; // edi@2
  void *v6; // eax@3
  int v7; // ST14_4@4
  const WCHAR *result; // eax@9
  LPVOID lpMem; // [sp+8h] [bp-4h]@1

  v2 = dword_10075870;
  v1 = 0;
  lpMem = 0;
  while ( 1 )
  {
    result = *(const WCHAR **)v2;
    if ( !*(_DWORD *)v2 )
      break;
    v3 = WideCharToMultiByte(v1, v1, result, -1, (LPSTR)v1, v1, (LPCSTR)v1, (LPBOOL)v1);
    v5 = v3;
    if ( !v3 || (v6 = sub_100374E6(v4, a1, v3, 1u), lpMem = v6, !v6) )
      return (const WCHAR *)-1;
    v7 = v5;
    v1 = 0;
    if ( !WideCharToMultiByte(0, 0, *(LPCWSTR *)v2, -1, (LPSTR)v6, v7, 0, 0) )
    {
      sub_100309C2(a1, lpMem);
      return (const WCHAR *)-1;
    }
    if ( sub_10057913(a1, 0, (int)&lpMem, 0) < 0 )
    {
      if ( lpMem )
      {
        sub_100309C2(a1, lpMem);
        lpMem = 0;
      }
    }
    v2 = (char *)v2 + 4;
  }
  return result;
}

//----- (100539AB) --------------------------------------------------------
signed int __usercall sub_100539AB<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  return sub_100539C3(a1, a2, a3, a4, a5, 0);
}

//----- (100539C3) --------------------------------------------------------
signed int __usercall sub_100539C3<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6)
{
  signed int v6; // esi@2
  int v7; // eax@10
  int v9; // [sp+8h] [bp-10h]@1
  int v10; // [sp+Ch] [bp-Ch]@8
  int v11; // [sp+10h] [bp-8h]@13
  char v12; // [sp+14h] [bp-4h]@12

  sub_100301AD((int)&v9, a1, a2, a6);
  if ( a5 )
  {
    if ( a3 && a4 )
    {
      v6 = 2147483647;
      if ( (unsigned int)a5 <= 0x7FFFFFFF )
      {
        if ( *(_DWORD *)(v10 + 8) )
        {
          v7 = sub_1003910C(a1, v10, (int)&v9, *(_DWORD *)(v10 + 540), 0x1001u, a3, a5, a4, a5, *(_DWORD *)(v10 + 4));
          if ( v7 )
            v6 = v7 - 2;
        }
        else
        {
          v6 = sub_10057C14(a1, v10, a3, a4, a5, a6);
        }
      }
      else
      {
        *(_DWORD *)sub_10037649(a1) = 22;
        sub_1003A151(a1, a2);
      }
    }
    else
    {
      *(_DWORD *)sub_10037649(a1) = 22;
      sub_1003A151(a1, a2);
      v6 = 2147483647;
    }
  }
  else
  {
    v6 = 0;
  }
  if ( v12 )
    *(_DWORD *)(v11 + 112) &= 0xFFFFFFFDu;
  return v6;
}

//----- (10053ABC) --------------------------------------------------------
void __usercall sub_10053ABC(int a1<ebx>, __int64 a2<st0>, int edx0<edx>, __int16 a4<cx>, __int16 a3<fpstat>, char c0_0, char c2_0, char a8, char a5, char a6, char a7)
{
  char v11; // zf@2
  int v12; // ST04_4@2
  int v13; // eax@2
  char v14; // ST00_1@3

  if ( !dword_10076894 )
    goto LABEL_9;
  __asm { stmxcsr [esp+8+var_4] }
  v13 = v12 & 0x7F80;
  v11 = v13 == 8064;
  if ( v13 == 8064 )
    v11 = (v14 & 0x7F) == 127;
  if ( v11 )
    sub_10057CF0(a1, a2);
  else
LABEL_9:
    sub_100581EE((int)&unk_10066E6A, a4, a3, *(double *)&a2, a5, a6, a7);
}
// 10076894: using guessed type int dword_10076894;

//----- (10053B0B) --------------------------------------------------------
int __thiscall sub_10053B0B(int this, int a2, int a3, int a4)
{
  int v5; // edi@1

  v5 = this;
  *(_DWORD *)this = off_10066858;
  *(_DWORD *)(this + 4) = 0;
  sub_1004B382(this + 8, a2, a3, a4);
  *(_WORD *)(v5 + 68) = 0;
  *(_DWORD *)(v5 + 76) = 0;
  _ECX = &unk_10076234;
  _EAX = 1;
  __asm { lock xadd [ecx], eax }
  *(_DWORD *)(v5 + 72) = _EAX + 1;
  *(_DWORD *)(v5 + 36) = v5;
  return v5;
}
// 10066858: using guessed type int (*off_10066858[2])();

//----- (10053B52) --------------------------------------------------------
int __thiscall sub_10053B52(int this)
{
  return (*(int (**)(void))(*(_DWORD *)(this + 8) + 12))();
}

//----- (10053B5A) --------------------------------------------------------
int __thiscall sub_10053B5A(int this)
{
  return (*(int (**)(void))(*(_DWORD *)(this + 8) + 4))();
}

//----- (10053B62) --------------------------------------------------------
int __thiscall sub_10053B62(int this)
{
  return *(_DWORD *)(this + 72);
}

//----- (10053B66) --------------------------------------------------------
int __thiscall sub_10053B66(int this)
{
  return (**(int (***)(void))(this + 8))();
}

//----- (10053B6D) --------------------------------------------------------
int __thiscall sub_10053B6D(int this, int a2)
{
  int v2; // esi@1
  int v4; // [sp-4h] [bp-14h]@3
  int (__stdcall **v5)(char); // [sp+4h] [bp-Ch]@3

  v2 = this;
  if ( !a2 )
  {
    a2 = (int)"pScheduler";
    sub_1002AEA4((int)&v5, &a2);
    v5 = &off_1005F2EC;
    v4 = (int)&unk_1006C8B4;
    goto LABEL_6;
  }
  if ( *(_DWORD *)(*(_DWORD *)(this + 28) + 8) != a2 )
  {
    sub_1002FFD5((int)&v5);
    v4 = (int)&unk_1006C878;
LABEL_6:
    sub_100355BB((int)&v5, v4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10053BD2);
  }
  sub_10053BD2(this);
  return sub_1004C518(v2);
}
// 1004C518: using guessed type _DWORD __stdcall sub_1004C518(_DWORD);
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);

//----- (10053BD2) --------------------------------------------------------
int __thiscall sub_10053BD2(int this)
{
  int result; // eax@1

  result = this + 76;
  _EDX = -1;
  __asm { lock xadd [eax], edx }
  if ( _EDX == 1 )
    result = sub_10053BF7(this);
  return result;
}

//----- (10053BEA) --------------------------------------------------------
int __thiscall sub_10053BEA(int this)
{
  return sub_1004C91D(*(_DWORD *)(this + 28), this + 8);
}

//----- (10053BF7) --------------------------------------------------------
int __thiscall sub_10053BF7(int this)
{
  return sub_1004C3A4(*(_DWORD *)(this + 28), this + 8);
}

//----- (10053C04) --------------------------------------------------------
int __thiscall sub_10053C04(int this, int a2, int a3, int a4)
{
  int v5; // esi@1

  v5 = this;
  sub_10053B0B(this, a2, a3, a4);
  *(_DWORD *)v5 = off_10066884;
  *(_DWORD *)(v5 + 80) = 0;
  *(_DWORD *)(v5 + 84) = 0;
  return v5;
}
// 10066884: using guessed type int (*off_10066884[2])();

//----- (10053C33) --------------------------------------------------------
bool __thiscall sub_10053C33(int this, int a2)
{
  return *(_WORD *)(a2 + 4) == *(_WORD *)(this + 4) && *(_DWORD *)a2 == *(_DWORD *)this;
}

//----- (10053C54) --------------------------------------------------------
int __thiscall sub_10053C54(int this, char a2)
{
  int v2; // esi@1

  v2 = this;
  *(_DWORD *)this = off_10066858;
  *(_DWORD *)(this + 8) = off_10065138;
  if ( a2 & 1 )
    sub_1002A4AA((LPVOID)this);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10065138: using guessed type int (*off_10065138[2])();
// 10066858: using guessed type int (*off_10066858[2])();

//----- (10053C7B) --------------------------------------------------------
int __thiscall sub_10053C7B(void *this)
{
  void *v1; // esi@1
  int result; // eax@4
  char v3; // [sp+8h] [bp-10h]@2
  int v4; // [sp+10h] [bp-8h]@1
  void (__cdecl *v5)(); // [sp+14h] [bp-4h]@1

  v1 = this;
  v4 = 0;
  v5 = sub_10034BB6;
  while ( !*((_DWORD *)v1 + 1) )
    sub_100282E0((int)&v3);
  result = *((_DWORD *)v1 + 1);
  *((_DWORD *)v1 + 1) = 0;
  return result;
}

//----- (10053CAA) --------------------------------------------------------
BOOL __thiscall sub_10053CAA(void *this, int a2)
{
  int v2; // edi@1
  int v3; // esi@1
  int v4; // ebx@2
  BOOL result; // eax@5
  int v13; // eax@8
  int v14; // [sp-4h] [bp-28h]@12
  char v15; // [sp+Ch] [bp-18h]@8
  int (__stdcall **v16)(char); // [sp+18h] [bp-Ch]@11

  v2 = a2;
  v3 = (int)this;
  if ( !a2 )
  {
    a2 = (int)"pContext";
    sub_1002AEA4((int)&v16, &a2);
    v16 = &off_1005F2EC;
    v14 = (int)&unk_1006C8B4;
    v13 = (int)&v16;
    goto LABEL_12;
  }
  v4 = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 8))(a2);
  if ( !v4 )
  {
    v14 = v2;
    v4 = (*(int (**)(void))(**(_DWORD **)(v3 + 28) + 28))();
  }
  _EAX = v3 + 76;
  _ECX = 1;
  __asm { lock xadd [eax], ecx }
  if ( _ECX == 1 )
  {
    result = v3 + 4;
    *(_DWORD *)(v3 + 4) = v2;
    return result;
  }
  sub_10053FAF((void *)v3);
  if ( *(_DWORD *)(v3 + 80) && v4 != *(_DWORD *)(v3 + 80) )
  {
    sub_1002FFD5((int)&v15);
    v13 = (int)&v15;
LABEL_12:
    sub_100355BB(v13, v14);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10053D5C);
  }
  *(_DWORD *)(v3 + 84) = 0;
  sub_10053BEA(v3);
  sub_10053D5C((void *)v3, v4);
  return sub_1005470B(v4);
}
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);

//----- (10053D5C) --------------------------------------------------------
int __thiscall sub_10053D5C(void *this, int a2)
{
  void *v3; // esi@1
  int v4; // ebx@1
  int v5; // eax@1

  v3 = this;
  sub_1005475F(a2);
  *((_DWORD *)v3 + 20) = a2;
  *(_DWORD *)(a2 + 16) = v3;
  v4 = *((_DWORD *)v3 + 7);
  v5 = (**(int (__thiscall ***)(void *))v3)(v3);
  return sub_10053F79(
           (void *)a2,
           *(_DWORD *)(52 * v5 + *(_DWORD *)(v4 + 16)),
           *(_WORD *)(52 * v5 + *(_DWORD *)(v4 + 16) + 12),
           0);
}

//----- (10053DB9) --------------------------------------------------------
char __thiscall sub_10053DB9(int this, int a2)
{
  int v2; // esi@1
  char *v3; // eax@3
  int v4; // edi@4
  LPVOID v13; // eax@11
  int v14; // esi@11
  int v15; // ecx@11
  int v16; // eax@13
  int v17; // [sp-4h] [bp-30h]@3
  int v18; // [sp-4h] [bp-30h]@11
  char v19; // [sp+8h] [bp-24h]@5
  char v20; // [sp+14h] [bp-18h]@3
  int (__stdcall **v21)(char); // [sp+20h] [bp-Ch]@10

  v2 = this;
  if ( !a2 )
  {
    a2 = (int)"pContext";
    sub_1002AEA4((int)&v21, &a2);
    v21 = &off_1005F2EC;
    v17 = (int)&unk_1006C8B4;
    v3 = (char *)&v21;
LABEL_11:
    sub_100355BB((int)v3, v17);
    __asm { int     3               ; Trap to Debugger }
    v18 = v2;
    v14 = v15;
    v13 = TlsGetValue(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v15 + 28) + 12) + 112));
    if ( v13 && ((_BYTE)v13 & 3) == 1 && (v16 = (unsigned int)v13 & 0xFFFFFFFE) != 0 && v16 == *(_DWORD *)(v14 + 80) )
      *(_DWORD *)(v16 + 16) = 0;
    else
      sub_10053FAF((void *)v14);
    return (*(int (__thiscall **)(int, signed int, int))(*(_DWORD *)v14 + 32))(v14, 1, v18);
  }
  if ( !*(_DWORD *)(this + 80) )
  {
    sub_1002FFD5((int)&v20);
    v17 = (int)&unk_1006C878;
    v3 = &v20;
    goto LABEL_11;
  }
  v4 = (*(int (**)(void))(*(_DWORD *)a2 + 8))();
  if ( *(_DWORD *)(v2 + 80) != v4 )
  {
    sub_1002FFD5((int)&v19);
    v17 = (int)&unk_1006C878;
    v3 = &v19;
    goto LABEL_11;
  }
  _EAX = v2 + 76;
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  if ( _ECX == 1 )
  {
    *(_DWORD *)(v2 + 84) = *(_DWORD *)(v2 + 80);
    sub_10053BF7(v2);
    sub_1005478A(v4);
  }
  else
  {
    sub_10053C7B((void *)v2);
  }
  return 1;
}
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);

//----- (10053E9F) --------------------------------------------------------
BOOL __thiscall sub_10053E9F(int this, int a2)
{
  int v2; // esi@1
  char *v3; // eax@3
  int v5; // [sp-4h] [bp-2Ch]@3
  char v6; // [sp+4h] [bp-24h]@5
  char v7; // [sp+10h] [bp-18h]@3
  int (__stdcall **v8)(char); // [sp+1Ch] [bp-Ch]@7

  v2 = this;
  if ( !a2 )
  {
    a2 = (int)"pContext";
    sub_1002AEA4((int)&v8, &a2);
    v8 = &off_1005F2EC;
    v5 = (int)&unk_1006C8B4;
    v3 = (char *)&v8;
    goto LABEL_8;
  }
  if ( !*(_DWORD *)(this + 80) )
  {
    sub_1002FFD5((int)&v7);
    v5 = (int)&unk_1006C878;
    v3 = &v7;
LABEL_8:
    sub_100355BB((int)v3, v5);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10053F1C);
  }
  if ( *(_DWORD *)(this + 80) != (*(int (**)(void))(*(_DWORD *)a2 + 8))() )
  {
    sub_1002FFD5((int)&v6);
    v5 = (int)&unk_1006C878;
    v3 = &v6;
    goto LABEL_8;
  }
  return sub_1003D40F(*(_DWORD *)(*(_DWORD *)(v2 + 28) + 12));
}
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);

//----- (10053F1C) --------------------------------------------------------
int __thiscall sub_10053F1C(int this, int a2)
{
  int result; // eax@1
  int v3; // ecx@1
  int v4; // edi@1
  int v5; // esi@1
  int v12; // esi@6
  int v13; // eax@6

  v5 = this;
  v4 = *(_DWORD *)(this + 80);
  result = this + 76;
  _ECX = -1;
  __asm { lock xadd [eax], ecx }
  v3 = _ECX - 1;
  if ( v3 > 0 )
  {
    v13 = sub_10053C7B((void *)v5);
    v12 = v13;
    result = (*(int (__thiscall **)(int))(*(_DWORD *)v13 + 8))(v13);
    if ( v4 != result )
      result = (*(int (__thiscall **)(int, int, int))(*(_DWORD *)v4 + 4))(v4, v12, a2);
  }
  else
  {
    if ( !v3 )
      result = sub_10053BF7(v5);
    *(_DWORD *)(v5 + 80) = 0;
    if ( a2 == 1 )
      result = sub_1005478A(v4);
  }
  return result;
}

//----- (10053F79) --------------------------------------------------------
int __thiscall sub_10053F79(void *this, int a2, __int16 a3, int a4)
{
  void *v4; // edi@1
  int result; // eax@3

  v4 = this;
  if ( !sub_10053C33((int)((char *)this + 48), (int)&a2) )
    sub_1003BB65((DWORD_PTR *)&a2, *((HANDLE *)v4 + 2));
  *((_WORD *)v4 + 26) = a3;
  result = a2;
  *((_DWORD *)v4 + 12) = a2;
  return result;
}

//----- (10053FAF) --------------------------------------------------------
char __thiscall sub_10053FAF(void *this)
{
  void *v1; // esi@1
  char result; // al@3
  char v3; // [sp+8h] [bp-10h]@3
  int v4; // [sp+10h] [bp-8h]@1
  void (__cdecl *v5)(); // [sp+14h] [bp-4h]@1

  v1 = this;
  v4 = 0;
  v5 = sub_10034BB6;
  while ( *((_DWORD *)v1 + 20) && !*((_DWORD *)v1 + 21) )
    result = sub_100282E0((int)&v3);
  return result;
}

//----- (10053FDD) --------------------------------------------------------
int __thiscall sub_10053FDD(int this, int a2)
{
  *(_DWORD *)(this + 64) = a2;
  return (*(int (__stdcall **)(int))(*(_DWORD *)a2 + 12))(this);
}

//----- (10053FF2) --------------------------------------------------------
void __fastcall sub_10053FF2(int a1)
{
  int v1; // esi@1
  DWORD v2; // eax@2
  int v3; // edi@3
  int v4; // [sp+8h] [bp-8h]@1
  int v5; // [sp+Ch] [bp-4h]@1

  v1 = a1;
  v4 = 8;
  v5 = 0;
  if ( !*(_DWORD *)(a1 + 36) )
  {
    v2 = (*(int (**)(void))(**(_DWORD **)(a1 + 4) + 16))();
    TlsSetValue(v2, (LPVOID)(v1 | 1));
    while ( !*(_DWORD *)(v1 + 36) )
    {
      (*(void (__stdcall **)(int))(**(_DWORD **)(v1 + 64) + 12))(v1);
      (*(void (__stdcall **)(int *))(**(_DWORD **)(v1 + 64) + 16))(&v4);
      v3 = *(_DWORD *)(v1 + 16);
      *(_DWORD *)(v1 + 64) = 0;
      *(_DWORD *)(v1 + 16) = 0;
      sub_1005406C(v1);
      if ( v3 )
        sub_10053F1C(v3, 1);
      else
        sub_1005478A(v1);
    }
  }
}

//----- (1005406C) --------------------------------------------------------
int __thiscall sub_1005406C(int this)
{
  int v2; // edx@1
  int v3; // ecx@1

  v2 = this;
  v3 = *(_DWORD *)(this + 4);
  *(_DWORD *)(v2 + 64) = 0;
  return (*(int (__stdcall **)(int))(*(_DWORD *)v3 + 4))(v2);
}

//----- (1005407C) --------------------------------------------------------
int __thiscall sub_1005407C(int this, int a2)
{
  int v2; // eax@1
  int v3; // edx@2
  int (__stdcall **v5)(char); // [sp+0h] [bp-Ch]@10

  v2 = a2;
  if ( !a2 )
    goto LABEL_14;
  v3 = *(_DWORD *)(this + 16);
  if ( v3 )
    goto LABEL_5;
  if ( a2 != 1 )
  {
LABEL_14:
    a2 = (int)"switchState";
    sub_1002AEA4((int)&v5, &a2);
    v5 = &off_1005F2EC;
    sub_100355BB((int)&v5, (int)&unk_1006C8B4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_100540DE);
  }
  if ( !v3 )
    return sub_1005478A(this);
LABEL_5:
  if ( a2 == 2 )
    *(_DWORD *)(this + 16) = 0;
  return sub_10053F1C(v3, v2);
}
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);

//----- (100540DE) --------------------------------------------------------
BOOL __thiscall sub_100540DE(void *this, int a2, int a3)
{
  int v3; // ebx@1
  void *v4; // edi@1
  int v5; // esi@2
  void *v6; // ecx@4
  int v7; // ebx@4
  BOOL result; // eax@8
  int (__stdcall **v9)(char); // [sp+Ch] [bp-Ch]@11

  v3 = a2;
  v4 = this;
  if ( !a2 )
  {
    a2 = (int)"pContext";
    sub_1002AEA4((int)&v9, &a2);
    v9 = &off_1005F2EC;
    sub_100355BB((int)&v9, (int)&unk_1006C8B4);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_10054180);
  }
  v5 = (*(int (__thiscall **)(int))(*(_DWORD *)a2 + 8))(a2);
  if ( !v5 )
    v5 = (*(int (__cdecl **)(int))(**(_DWORD **)(*((_DWORD *)v4 + 4) + 28) + 28))(v3);
  v6 = (void *)*((_DWORD *)v4 + 4);
  v7 = a3;
  *((_DWORD *)v4 + 4) = 0;
  if ( v7 == 1 )
    *((_DWORD *)v4 + 8) = 1;
  sub_10053D5C(v6, v5);
  if ( v7 && v7 == 1 )
  {
    SignalObjectAndWait(*(HANDLE *)(v5 + 12), *((HANDLE *)v4 + 3), 0xFFFFFFFFu, 1);
    result = (BOOL)((char *)v4 + 32);
    *((_DWORD *)v4 + 8) = 0;
  }
  else
  {
    result = sub_1005470B(v5);
  }
  return result;
}
// 1005F2EC: using guessed type int (__stdcall *off_1005F2EC)(char);

//----- (10054180) --------------------------------------------------------
int __cdecl sub_10054180(int a1)
{
  int result; // eax@1
  int v2; // ecx@1

  v2 = *(_DWORD *)(*(_DWORD *)a1 - 4);
  result = a1 - *(_DWORD *)(v2 + 4);
  if ( *(_DWORD *)(v2 + 8) )
    result -= *(_DWORD *)(a1 - *(_DWORD *)(v2 + 8));
  return result;
}

//----- (1005419D) --------------------------------------------------------
int __cdecl sub_1005419D(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // edx@1
  signed int v6; // ecx@1
  signed int v7; // ebx@1
  int v8; // edi@1
  int v9; // esi@1
  int v10; // eax@1
  int v11; // edi@2
  int v13; // ebx@19
  int v14; // [sp+Ch] [bp-10h]@1
  unsigned int v15; // [sp+10h] [bp-Ch]@1
  unsigned int v16; // [sp+14h] [bp-8h]@1
  int v17; // [sp+18h] [bp-4h]@1
  signed int v18; // [sp+28h] [bp+Ch]@1

  v10 = *(_DWORD *)(a2 + 16);
  v9 = 0;
  v8 = *(_DWORD *)(v10 + 12);
  v6 = -1;
  v5 = 0;
  v17 = 0;
  v14 = *(_DWORD *)(v10 + 12);
  v15 = *(_DWORD *)(v10 + 8);
  v16 = 0;
  v18 = -1;
  v7 = 0;
  if ( !v15 )
    return 0;
  while ( 1 )
  {
    v11 = *(_DWORD *)(v8 + 4 * v7);
    if ( v7 - v6 <= v16 )
      goto LABEL_8;
    if ( *(_DWORD *)v11 != a5 )
    {
      if ( sub_100392F0(*(_DWORD *)v11 + 8, a5 + 8) )
        goto LABEL_8;
      v5 = v17;
    }
    if ( v5 )
    {
      if ( !(*(_BYTE *)(v11 + 20) & 3) && !(*(_BYTE *)(v5 + 20) & 1) )
        return v11;
      return 0;
    }
    v9 = v11;
    v18 = v7;
    v16 = *(_DWORD *)(v11 + 4);
LABEL_8:
    if ( *(_DWORD *)v11 == a3 )
      goto LABEL_29;
    if ( !sub_100392F0(*(_DWORD *)v11 + 8, a3 + 8) )
    {
LABEL_29:
      if ( sub_100544B3(a1, v11 + 8) == a4 )
        break;
    }
    v5 = v17;
LABEL_14:
    ++v7;
    if ( v7 >= v15 )
      return 0;
    v6 = v18;
    v8 = v14;
  }
  if ( !v9 )
  {
    v5 = v11;
    v17 = v11;
    goto LABEL_14;
  }
  v13 = v7 - v18;
  if ( v13 > v16 )
  {
    if ( !(*(_BYTE *)(v9 + 20) & 3) )
      goto LABEL_22;
    return 0;
  }
  if ( !(*(_BYTE *)(v9 + 20) & 0x40) )
  {
    if ( !v18 )
    {
LABEL_22:
      if ( *(_BYTE *)(v11 + 20) & 1 )
        return 0;
    }
    return v9;
  }
  return (*(_BYTE *)(*(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v9 + 24) + 12) + 4 * v13) + 20) & 1) == 0 ? v9 : 0;
}

//----- (100542B0) --------------------------------------------------------
int __cdecl sub_100542B0(int a1, int a2, int a3)
{
  int v3; // edx@1
  unsigned int v4; // edi@1
  unsigned int v5; // esi@1
  int v6; // eax@1
  int v7; // eax@3
  int i; // esi@7
  int v10; // eax@8
  int v11; // [sp+Ch] [bp-4h]@2
  int v12; // [sp+18h] [bp+8h]@1

  v6 = *(_DWORD *)(a1 + 16);
  v3 = *(_DWORD *)(v6 + 12);
  v4 = *(_DWORD *)(v6 + 8);
  v5 = 0;
  v12 = *(_DWORD *)(v6 + 12);
  if ( v4 )
  {
    while ( 1 )
    {
      v11 = *(_DWORD *)(v3 + 4 * v5);
      if ( *(_DWORD *)v11 == a3 )
        break;
      v7 = sub_100392F0(*(_DWORD *)v11 + 8, a3 + 8);
      v3 = v12;
      if ( !v7 )
        break;
      ++v5;
      if ( v5 >= v4 )
        return 0;
    }
    for ( i = v5 + 1; i < v4; ++i )
    {
      v10 = *(_DWORD *)(v3 + 4 * i);
      if ( *(_BYTE *)(v10 + 20) & 4 )
        break;
      if ( *(_DWORD *)v10 == a2 || !sub_100392F0(*(_DWORD *)v10 + 8, a2 + 8) )
        return v11;
      v3 = v12;
    }
  }
  return 0;
}

//----- (10054336) --------------------------------------------------------
int __cdecl sub_10054336(int a1, int a2, int a3, int a4, int a5)
{
  signed int v5; // ecx@1
  signed int v6; // ebx@1
  int v7; // edi@1
  int v8; // esi@1
  int v9; // eax@1
  int v10; // esi@2
  char v11; // dl@11
  char v12; // cl@16
  int v13; // esi@16
  int v14; // eax@17
  int v15; // eax@20
  int v16; // eax@24
  int result; // eax@31
  int v18; // [sp+Ch] [bp-20h]@1
  unsigned int v19; // [sp+10h] [bp-1Ch]@1
  int v20; // [sp+14h] [bp-18h]@1
  signed int v21; // [sp+18h] [bp-14h]@1
  unsigned int v22; // [sp+1Ch] [bp-10h]@1
  signed int v23; // [sp+20h] [bp-Ch]@1
  int v24; // [sp+24h] [bp-8h]@1
  int v25; // [sp+28h] [bp-4h]@1
  char v26; // [sp+3Bh] [bp+Fh]@1

  v9 = *(_DWORD *)(a2 + 16);
  v8 = *(_DWORD *)(v9 + 12);
  v5 = -1;
  v7 = 0;
  v25 = 0;
  v20 = 0;
  v24 = 0;
  v18 = *(_DWORD *)(v9 + 12);
  v19 = *(_DWORD *)(v9 + 8);
  v22 = 0;
  v23 = -1;
  v26 = 1;
  v21 = -1;
  v6 = 0;
  if ( !v19 )
    goto LABEL_34;
  while ( 1 )
  {
    v10 = *(_DWORD *)(v8 + 4 * v6);
    if ( v6 - v5 > v22 )
    {
      if ( *(_DWORD *)v10 == a5 || !sub_100392F0(*(_DWORD *)v10 + 8, a5 + 8) )
      {
        if ( !(*(_BYTE *)(v10 + 20) & 3) )
          v20 = v10;
        v24 = v10;
        v23 = v6;
        v22 = *(_DWORD *)(v10 + 4);
      }
    }
    if ( *(_DWORD *)v10 != a3 && sub_100392F0(*(_DWORD *)v10 + 8, a3 + 8) || sub_100544B3(a1, v10 + 8) != a4 )
      goto LABEL_23;
    v11 = v26;
    if ( v6 - v23 <= v22 )
    {
      if ( v26 )
      {
        if ( *(_BYTE *)(v24 + 20) & 0x40 )
        {
          v13 = v24;
          v14 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(v24 + 24) + 12) + 4 * (v6 - v23));
          v11 = (*(_DWORD *)(v14 + 20) & 1) == 0 ? v26 : 0;
          v26 = (*(_DWORD *)(v14 + 20) & 1) == 0 ? v26 : 0;
          v12 = ~(unsigned __int8)(*(_DWORD *)(v14 + 20) >> 2) & 1;
        }
        else
        {
          if ( !v23 )
          {
            v11 = (*(_BYTE *)(v10 + 20) & 1) == 0 ? v26 : 0;
            v26 = (*(_BYTE *)(v10 + 20) & 1) == 0 ? v26 : 0;
          }
          v13 = v24;
          v12 = 1;
        }
        if ( v11 && v12 )
        {
          v15 = sub_100544B3(a1, v13 + 8);
          if ( v7 && v21 != v15 )
            goto LABEL_34;
          v7 = v13;
          v21 = v15;
LABEL_23:
          v11 = v26;
        }
      }
LABEL_24:
      v16 = v25;
      goto LABEL_25;
    }
    if ( *(_BYTE *)(v10 + 20) & 5 )
      goto LABEL_24;
    v16 = v10;
    v25 = v10;
LABEL_25:
    ++v6;
    if ( v6 >= v19 )
      break;
    v5 = v23;
    v8 = v18;
  }
  if ( v11 && v7 )
    return v7;
  if ( !v16 || (result = v20, !v20) )
LABEL_34:
    result = 0;
  return result;
}

//----- (100544B3) --------------------------------------------------------
int __cdecl sub_100544B3(int a1, int a2)
{
  int v2; // edx@1

  v2 = 0;
  if ( *(_DWORD *)(a2 + 4) >= 0 )
    v2 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 4) + a1) + *(_DWORD *)(a2 + 8)) + *(_DWORD *)(a2 + 4);
  return v2 + *(_DWORD *)a2;
}

//----- (100544D7) --------------------------------------------------------
bool __cdecl sub_100544D7(int a1, int a2, int a3, int a4, int a5)
{
  bool result; // eax@2
  int v6; // eax@4
  int v7; // ecx@4
  int v8; // ebx@4
  int v9; // edi@4
  int v10; // esi@4
  int v11; // eax@5
  int v12; // eax@10
  char v13; // [sp+10h] [bp-28h]@13
  int v14; // [sp+1Ch] [bp-1Ch]@10
  CPPEH_RECORD ms_exc; // [sp+20h] [bp-18h]@4

  if ( a1 )
  {
    v10 = 0;
    ms_exc.disabled = 0;
    v8 = sub_10054180(a1);
    v6 = *(_DWORD *)(*(_DWORD *)a1 - 4);
    v9 = a1 - a2 - v8;
    v7 = *(_DWORD *)(*(_DWORD *)(v6 + 16) + 4);
    if ( v7 & 1 )
    {
      if ( v7 & 2 )
        v11 = sub_10054336(v8, v6, a3, v9, a4);
      else
        v11 = sub_1005419D(v8, v6, a3, v9, a4);
    }
    else
    {
      v11 = sub_100542B0(v6, a3, a4);
    }
    if ( v11 )
    {
      v12 = sub_100544B3(v8, v11 + 8);
      v10 = v8 + v12;
      v14 = v8 + v12;
    }
    else
    {
      v14 = 0;
      if ( a5 )
      {
        sub_1002AE51((int)&v13, (unsigned int)"Bad dynamic_cast!");
        sub_100355BB((int)&v13, (int)&unk_1006C964);
        return ms_exc.exc_ptr->ExceptionRecord->ExceptionCode == -1073741819;
      }
    }
    ms_exc.disabled = -2;
    result = v10;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100545B3) --------------------------------------------------------
LPVOID __thiscall sub_100545B3(LPVOID lpParameter, int a2, int a3)
{
  LPVOID v3; // edi@1
  int v4; // ecx@1
  HANDLE v12; // eax@1
  int v13; // eax@2
  HANDLE v14; // eax@4
  int v15; // eax@5
  char *v16; // eax@7
  int v18; // ecx@10
  int v19; // esi@10
  int v20; // [sp-4h] [bp-30h]@7
  char v21; // [sp+Ch] [bp-20h]@7
  char v22; // [sp+1Ch] [bp-10h]@9

  v3 = lpParameter;
  *((_DWORD *)lpParameter + 1) = a2;
  v4 = *((_DWORD *)lpParameter + 1);
  *(_DWORD *)v3 = off_100668F4;
  *((_DWORD *)v3 + 5) = a3;
  *((_DWORD *)v3 + 6) = 0;
  *((_BYTE *)v3 + 28) = 0;
  _ESI = 1;
  *((_DWORD *)v3 + 8) = 1;
  *((_DWORD *)v3 + 9) = 0;
  (*(void (**)(void))(*(_DWORD *)v4 + 8))();
  _EAX = &unk_10073368;
  __asm { lock xadd [eax], esi }
  *((_DWORD *)v3 + 10) = _ESI + 1;
  v12 = CreateEventW(0, 0, 0, 0);
  *((_DWORD *)v3 + 3) = v12;
  if ( v12 )
  {
    v14 = sub_100349B9(
            0,
            *((_DWORD *)v3 + 5) << 10,
            (LPTHREAD_START_ROUTINE)sub_100547A4,
            v3,
            0x10000u,
            (LPDWORD)v3 + 11);
    *((_DWORD *)v3 + 2) = v14;
    if ( v14 )
      return v3;
    CloseHandle(*((HANDLE *)v3 + 3));
    (*(void (**)(void))(**((_DWORD **)v3 + 1) + 12))();
    v15 = GetLastError();
    if ( v15 > 0 )
      v15 = (unsigned __int16)v15 | 0x80070000;
    sub_10030097((int)&v21, v15);
    v20 = (int)&unk_1006C6B4;
    v16 = &v21;
  }
  else
  {
    v13 = GetLastError();
    if ( v13 > 0 )
      v13 = (unsigned __int16)v13 | 0x80070000;
    sub_10030079((int)&v22, v13);
    v20 = (int)&unk_1006B6E0;
    v16 = &v22;
  }
  sub_100355BB((int)v16, v20);
  __asm { int     3               ; Trap to Debugger }
  v19 = v18;
  sub_100316BA(v18, 0, a2);
  *(_DWORD *)v19 = &off_10060CF0;
  return (LPVOID)v19;
}
// 10060CF0: using guessed type int (__stdcall *off_10060CF0)(char);
// 100668F4: using guessed type int (*off_100668F4[4])();

//----- (100546B3) --------------------------------------------------------
int __thiscall sub_100546B3(int this)
{
  int v2; // edi@1
  void *v3; // ST00_4@1

  v2 = this;
  v3 = *(void **)(this + 12);
  *(_DWORD *)this = off_100668F4;
  CloseHandle(v3);
  CloseHandle(*(HANDLE *)(v2 + 8));
  return (*(int (**)(void))(**(_DWORD **)(v2 + 4) + 12))();
}
// 100668F4: using guessed type int (*off_100668F4[4])();

//----- (100546D7) --------------------------------------------------------
void *__thiscall sub_100546D7(int this, char a2)
{
  void *v2; // esi@1

  v2 = (void *)this;
  sub_100546B3(this);
  if ( a2 & 1 )
    sub_1002A4AA(v2);
  return v2;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100546F6) --------------------------------------------------------
BOOL __thiscall sub_100546F6(int this)
{
  void *v2; // ST00_4@1

  v2 = *(void **)(this + 12);
  *(_DWORD *)(this + 36) = 1;
  return SetEvent(v2);
}

//----- (10054707) --------------------------------------------------------
int __thiscall sub_10054707(int this)
{
  return *(_DWORD *)(this + 40);
}

//----- (1005470B) --------------------------------------------------------
BOOL __thiscall sub_1005470B(int this)
{
  return SetEvent(*(HANDLE *)(this + 12));
}

//----- (10054715) --------------------------------------------------------
BOOL __thiscall sub_10054715(int this, int nPriority)
{
  BOOL result; // eax@1
  int v3; // eax@2
  char v4; // [sp+0h] [bp-10h]@5

  *(_DWORD *)(this + 24) = nPriority;
  result = SetThreadPriority(*(HANDLE *)(this + 8), nPriority);
  if ( !result )
  {
    v3 = GetLastError();
    if ( v3 > 0 )
      v3 = (unsigned __int16)v3 | 0x80070000;
    sub_10030079((int)&v4, v3);
    sub_100355BB((int)&v4, (int)&unk_1006B6E0);
    __asm { int     3               ; Trap to Debugger }
    JUMPOUT(*(int *)sub_1005475F);
  }
  return result;
}

//----- (1005475F) --------------------------------------------------------
char __thiscall sub_1005475F(int this)
{
  int v1; // esi@1
  char result; // al@3
  char v3; // [sp+4h] [bp-10h]@3
  int v4; // [sp+Ch] [bp-8h]@2
  void (__cdecl *v5)(); // [sp+10h] [bp-4h]@2

  v1 = this;
  if ( !*(_DWORD *)(this + 32) )
  {
    v4 = 0;
    v5 = sub_10034BB6;
    do
      result = sub_100282E0((int)&v3);
    while ( !*(_DWORD *)(v1 + 32) );
  }
  return result;
}

//----- (1005478A) --------------------------------------------------------
int __thiscall sub_1005478A(int this)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = this + 32;
  *(_DWORD *)(this + 32) = 1;
  WaitForSingleObject(*(HANDLE *)(this + 12), 0xFFFFFFFFu);
  result = *(_DWORD *)v2;
  *(_DWORD *)v2 = 0;
  return result;
}

//----- (100547A4) --------------------------------------------------------
int __stdcall sub_100547A4(int a1)
{
  int v2; // esi@1

  v2 = a1;
  WaitForSingleObject(*(HANDLE *)(a1 + 12), 0xFFFFFFFFu);
  *(_DWORD *)(a1 + 32) = 0;
  (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 20))(v2);
  (*(void (__thiscall **)(int, signed int))(*(_DWORD *)v2 + 16))(v2, 1);
  sub_10034942(0);
  return 0;
}

//----- (100547DC) --------------------------------------------------------
signed int __usercall sub_100547DC<eax>(int a1<ebx>, int a2<edi>, unsigned int a3, int a4, unsigned int a5, unsigned int a6)
{
  unsigned int v7; // [sp-8h] [bp-8h]@3
  int v8; // [sp-4h] [bp-4h]@3

  if ( a6 != 10 || (signed int)a3 >= 0 )
  {
    v8 = 0;
    v7 = a6;
  }
  else
  {
    v8 = 1;
    v7 = 10;
  }
  return sub_10054805(a1, a2, a3, a4, a5, v7, v8);
}

//----- (10054805) --------------------------------------------------------
signed int __userpurge sub_10054805<eax>(int a1<ebx>, int a2<edi>, unsigned int a3, int a4, unsigned int a5, unsigned int a6, int a7)
{
  int v8; // eax@4
  signed int v9; // esi@5
  unsigned int v10; // edx@9
  char v11; // zf@9
  signed int v12; // ecx@11
  int v13; // eax@12
  unsigned int v14; // ett@12
  int v15; // eax@13
  int v16; // edi@20
  __int16 v17; // cx@21
  signed int v18; // [sp-Ch] [bp-10h]@4
  signed int v19; // [sp+1Ch] [bp+18h]@9

  if ( !a4 )
  {
    *(_DWORD *)sub_10037649(a1) = 22;
    sub_1003A151(a1, a2);
    return 22;
  }
  if ( !a5 )
    goto LABEL_25;
  *(_WORD *)a4 = 0;
  if ( a5 <= (unsigned int)(a7 != 0) + 1 )
  {
    v8 = sub_10037649(a1);
    v18 = 34;
    goto LABEL_5;
  }
  v9 = 34;
  if ( a6 - 2 > 0x22 )
  {
LABEL_25:
    v8 = sub_10037649(a1);
    v18 = 22;
LABEL_5:
    v9 = v18;
LABEL_19:
    *(_DWORD *)v8 = v9;
    sub_1003A151(a1, a2);
    return v9;
  }
  v11 = a7 == 0;
  v10 = a3;
  v19 = 0;
  a2 = a4;
  if ( !v11 )
  {
    *(_WORD *)a4 = 45;
    a2 = a4 + 2;
    v19 = 1;
    v10 = -a3;
  }
  v12 = v19;
  a1 = a2;
  do
  {
    v14 = v10;
    v10 /= a6;
    v13 = v14 % a6;
    if ( v14 % a6 <= 9 )
      v15 = v13 + 48;
    else
      v15 = v13 + 87;
    *(_WORD *)a2 = v15;
    a2 += 2;
    ++v12;
  }
  while ( v10 && v12 < a5 );
  if ( v12 >= a5 )
  {
    *(_WORD *)a4 = 0;
    v8 = sub_10037649(a1);
    goto LABEL_19;
  }
  *(_WORD *)a2 = 0;
  v16 = a2 - 2;
  do
  {
    v17 = *(_WORD *)v16;
    *(_WORD *)v16 = *(_WORD *)a1;
    *(_WORD *)a1 = v17;
    v16 -= 2;
    a1 += 2;
  }
  while ( a1 < (unsigned int)v16 );
  return 0;
}

//----- (100548F8) --------------------------------------------------------
int __usercall sub_100548F8<eax>(int a1<ebx>, int a2<edi>, int a3)
{
  return sub_1005589B(a1, a2, a3, 0, 0xAu);
}

//----- (1005490C) --------------------------------------------------------
int __cdecl sub_1005490C(int a1, unsigned __int16 a2)
{
  int result; // eax@9

  _ECX = a1;
  if ( dword_1007577C < 1 )
  {
    while ( *(_WORD *)_ECX && *(_WORD *)_ECX != a2 )
      _ECX += 2;
LABEL_9:
    result = _ECX & ((*(_WORD *)_ECX != a2) - 1);
  }
  else
  {
    _EAX = a2;
    __asm
    {
      movd    xmm0, eax
      pshuflw xmm0, xmm0, 0
      pshufd  xmm2, xmm0, 0
    }
    while ( 1 )
    {
      while ( (_ECX & 0xFFFu) <= 0xFF0 )
      {
        __asm
        {
          movdqu  xmm0, xmmword ptr [ecx]
          pxor    xmm1, xmm1
          pcmpeqw xmm1, xmm0
          pcmpeqw xmm0, xmm2
          por     xmm1, xmm0
          pmovmskb eax, xmm1
        }
        if ( _EAX )
        {
          __asm { bsf     eax, eax }
          _ECX += _EAX;
          goto LABEL_9;
        }
        _ECX += 16;
      }
      if ( *(_WORD *)_ECX == a2 )
        break;
      if ( !*(_WORD *)_ECX )
        return 0;
      _ECX += 2;
    }
    result = _ECX;
  }
  return result;
}
// 1005490C: could not find valid save-restore pair for ebp
// 1007577C: using guessed type int dword_1007577C;

//----- (100549BA) --------------------------------------------------------
signed int __usercall sub_100549BA<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  signed int result; // eax@2
  int v6; // edi@2
  int v7; // ecx@5
  int v8; // edx@6
  signed __int16 v9; // si@6
  unsigned __int16 v10; // ax@8
  unsigned __int16 v11; // si@10
  unsigned __int16 v12; // ax@12

  if ( dword_10075F28 )
  {
    result = sub_10054A6E(a2, a3, a4, a5, 0);
  }
  else
  {
    v6 = a5;
    result = 0;
    if ( a5 )
    {
      if ( a3 && (v7 = a4, a4) )
      {
        v9 = 90;
        v8 = a3 - a4;
        while ( 1 )
        {
          v10 = *(_WORD *)(v8 + v7);
          if ( v10 < 0x41u || v10 > v9 )
            v11 = *(_WORD *)(v8 + v7);
          else
            v11 = v10 + 32;
          v12 = *(_WORD *)v7;
          if ( *(_WORD *)v7 >= 0x41u )
          {
            if ( v12 <= 0x5Au )
              v12 += 32;
          }
          v7 += 2;
          --v6;
          if ( !v6 )
            break;
          if ( !v11 || v11 != v12 )
            break;
          v9 = 90;
        }
        result = v11 - v12;
      }
      else
      {
        *(_DWORD *)sub_10037649(a1) = 22;
        sub_1003A151(a1, a5);
        result = 2147483647;
      }
    }
  }
  return result;
}
// 10075F28: using guessed type int dword_10075F28;

//----- (10054A6E) --------------------------------------------------------
signed int __usercall sub_10054A6E<eax>(int a1<edi>, int a2, int a3, int a4, int a5)
{
  int v5; // esi@1
  int v6; // ebx@2
  int v8; // ecx@6
  int v9; // ebx@6
  signed __int16 v10; // si@6
  unsigned __int16 v11; // ax@8
  WCHAR v12; // si@10
  WCHAR v13; // ax@12
  char v14; // zf@19
  int v15; // [sp+Ch] [bp-14h]@5
  int v16; // [sp+14h] [bp-Ch]@23
  char v17; // [sp+18h] [bp-8h]@22
  int v18; // [sp+1Ch] [bp-4h]@6

  v5 = 0;
  if ( a4 )
  {
    v6 = a2;
    if ( !a2 || (a1 = a3, !a3) )
    {
      *(_DWORD *)sub_10037649(a2) = 22;
      sub_1003A151(a2, a1);
      return 2147483647;
    }
    sub_100301AD((int)&v15, a2, a3, a5);
    if ( *(_DWORD *)(v15 + 168) )
    {
      do
      {
        v12 = sub_10053515(v6, a1, *(_WORD *)v6, (int)&v15);
        v13 = sub_10053515(v6, a1, *(_WORD *)a1, (int)&v15);
        v14 = a4-- == 1;
        v6 += 2;
        a1 += 2;
      }
      while ( !v14 && v12 && v12 == v13 );
    }
    else
    {
      v8 = a4;
      v10 = 90;
      v9 = a2 - a3;
      v18 = 90;
      while ( 1 )
      {
        v11 = *(_WORD *)(v9 + a1);
        if ( v11 < 0x41u || v11 > v10 )
          v12 = *(_WORD *)(v9 + a1);
        else
          v12 = v11 + 32;
        v13 = *(_WORD *)a1;
        if ( *(_WORD *)a1 >= 0x41u )
        {
          if ( v13 <= (_WORD)v18 )
            v13 += 32;
        }
        a1 += 2;
        --v8;
        if ( !v8 )
          break;
        if ( !v12 || v12 != v13 )
          break;
        v10 = 90;
      }
    }
    v5 = v12 - v13;
    if ( v17 )
      *(_DWORD *)(v16 + 112) &= 0xFFFFFFFDu;
  }
  return v5;
}

//----- (10054B65) --------------------------------------------------------
void __usercall sub_10054B65(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, signed int a5, const CHAR *lpWideCharStr, signed int nNumberOfBytesToRead)
{
  if ( a5 == -2 )
  {
    *(_DWORD *)sub_10037615(a3) = 0;
    *(_DWORD *)sub_10037649(a3) = 9;
    return;
  }
  if ( a5 < 0
    || a5 >= (unsigned int)dword_10076898
    || (a3 = a5 >> 5, a4 = (a5 & 0x1F) << 6, !(*(_BYTE *)(dword_10075F80[a5 >> 5] + a4 + 4) & 1)) )
  {
    *(_DWORD *)sub_10037615(a3) = 0;
    *(_DWORD *)sub_10037649(a3) = 9;
    goto LABEL_13;
  }
  if ( (unsigned int)nNumberOfBytesToRead > 0x7FFFFFFF )
  {
    *(_DWORD *)sub_10037615(a3) = 0;
    *(_DWORD *)sub_10037649(a3) = 22;
LABEL_13:
    sub_1003A151(a3, a4);
    return;
  }
  sub_100553FC(a1, a2, a3, a5);
  if ( *(_BYTE *)(dword_10075F80[a3] + a4 + 4) & 1 )
  {
    sub_10054C6D(a3, a5, lpWideCharStr, nNumberOfBytesToRead);
  }
  else
  {
    *(_DWORD *)sub_10037649(a3) = 9;
    *(_DWORD *)sub_10037615(a3) = 0;
  }
  sub_10055575(a5);
}
// 10075F80: using guessed type int dword_10075F80[];
// 10076898: using guessed type int dword_10076898;

//----- (10054C6D) --------------------------------------------------------
signed int __usercall sub_10054C6D<eax>(int a1<ebx>, unsigned int a2, const CHAR *lpWideCharStr, signed int nNumberOfBytesToRead)
{
  signed int v4; // edi@1
  unsigned int v5; // esi@1
  char v6; // al@5
  int v7; // edx@5
  int v8; // ecx@5
  int v9; // eax@13
  char v10; // al@13
  void *v11; // eax@17
  LARGE_INTEGER v12; // qax@23
  int v13; // ecx@23
  int v14; // edx@24
  int v15; // ecx@24
  char v16; // zf@24
  char v17; // dl@25
  void *v18; // edx@27
  int v19; // eax@27
  char v20; // al@28
  int v21; // edx@30
  int v22; // eax@30
  char v23; // al@31
  int v24; // eax@33
  int v25; // eax@34
  char v26; // zf@34
  int v27; // ecx@35
  int v28; // eax@39
  int v29; // ebx@41
  LPCSTR v30; // eax@42
  DWORD v31; // ecx@43
  char v32; // al@48
  int v33; // edx@48
  int v34; // esi@48
  char v35; // al@52
  LPCSTR v36; // esi@54
  char v37; // cl@55
  int v38; // edi@55
  const CHAR v39; // al@56
  char v40; // al@81
  int v41; // ecx@81
  int v42; // esi@86
  signed int v43; // edx@88
  int v44; // ecx@97
  char v45; // al@98
  int v46; // eax@98
  int v47; // esi@98
  int v48; // esi@104
  bool v49; // ecx@105
  unsigned int v51; // edx@114
  LPCSTR v52; // ecx@114
  LPCSTR v53; // esi@114
  signed __int16 v54; // di@115
  __int16 v55; // ax@116
  signed __int16 v56; // ax@120
  char v57; // al@129
  LPCSTR v58; // esi@131
  signed __int16 v59; // cx@132
  int v60; // edi@132
  __int16 v61; // ax@133
  char v62; // al@159
  int v63; // ecx@159
  char v64; // [sp-4h] [bp-38h]@67
  signed __int16 v65; // [sp-4h] [bp-38h]@145
  unsigned int v66; // [sp+Ch] [bp-28h]@1
  DWORD Mode; // [sp+14h] [bp-20h]@1
  LPVOID lpBuffer; // [sp+18h] [bp-1Ch]@24
  int v69; // [sp+1Ch] [bp-18h]@1
  DWORD NumberOfBytesRead; // [sp+20h] [bp-14h]@38
  LPCSTR lpMem; // [sp+24h] [bp-10h]@17
  int v72; // [sp+28h] [bp-Ch]@5
  __int16 v73; // [sp+2Ch] [bp-8h]@141
  char Buffer; // [sp+33h] [bp-1h]@63
  signed int v75; // [sp+44h] [bp+10h]@115
  signed int v76; // [sp+44h] [bp+10h]@132
  char v77; // [sp+47h] [bp+13h]@13

  v5 = nNumberOfBytesToRead;
  v4 = 0;
  Mode = 0;
  v69 = -2;
  v66 = nNumberOfBytesToRead;
  if ( a2 == -2 )
  {
    *(_DWORD *)sub_10037615(a1) = 0;
    *(_DWORD *)sub_10037649(a1) = 9;
    return -1;
  }
  if ( (signed int)a2 < 0
    || a2 >= dword_10076898
    || (v8 = (signed int)a2 >> 5,
        v7 = dword_10075F80[(signed int)a2 >> 5],
        a1 = (a2 & 0x1F) << 6,
        v72 = (signed int)a2 >> 5,
        v6 = *(_BYTE *)(v7 + a1 + 4),
        !(v6 & 1)) )
  {
    *(_DWORD *)sub_10037615(a1) = 0;
    *(_DWORD *)sub_10037649(a1) = 9;
    goto LABEL_169;
  }
  if ( (unsigned int)nNumberOfBytesToRead > 0x7FFFFFFF )
  {
    *(_DWORD *)sub_10037615(a1) = 0;
LABEL_8:
    *(_DWORD *)sub_10037649(a1) = 22;
LABEL_169:
    sub_1003A151(a1, 0);
    return -1;
  }
  if ( !nNumberOfBytesToRead || v6 & 2 )
    return 0;
  if ( !lpWideCharStr )
  {
LABEL_12:
    *(_DWORD *)sub_10037615(a1) = 0;
    goto LABEL_8;
  }
  v10 = (char)(2 * *(_BYTE *)(v7 + a1 + 36)) >> 1;
  v77 = v10;
  v9 = v10 - 1;
  if ( v9 )
  {
    if ( v9 == 1 )
    {
      if ( !(~(_BYTE)v5 & 1) )
        goto LABEL_12;
      v5 &= 0xFFFFFFFEu;
    }
    v11 = (void *)lpWideCharStr;
    lpMem = lpWideCharStr;
  }
  else
  {
    if ( !(~(_BYTE)v5 & 1) )
      goto LABEL_12;
    v5 >>= 1;
    if ( v5 < 4 )
      v5 = 4;
    lpMem = (LPCSTR)sub_10037530(v7, v8, a1, v5);
    if ( !lpMem )
    {
      *(_DWORD *)sub_10037649(a1) = 12;
      *(_DWORD *)sub_10037615(a1) = 8;
      return -1;
    }
    v12 = sub_100508F3(a1, 0, a2, 0i64, 1u);
    v13 = dword_10075F80[v72];
    *(_DWORD *)(v13 + a1 + 40) = v12.LowPart;
    v11 = (void *)lpMem;
    *(_DWORD *)(v13 + a1 + 44) = v12.HighPart;
    v8 = v72;
  }
  v14 = dword_10075F80[v8];
  v15 = v72;
  v16 = (*(_BYTE *)(v14 + a1 + 4) & 0x48) == 0;
  lpBuffer = v11;
  if ( !v16 )
  {
    v17 = *(_BYTE *)(v14 + a1 + 5);
    if ( v17 != 10 )
    {
      if ( v5 )
      {
        *(_BYTE *)v11 = v17;
        v18 = (char *)v11 + 1;
        v19 = dword_10075F80[v15];
        v4 = 1;
        --v5;
        lpBuffer = v18;
        *(_BYTE *)(v19 + a1 + 5) = 10;
        if ( v77 )
        {
          v20 = *(_BYTE *)(dword_10075F80[v15] + a1 + 37);
          if ( v20 != 10 )
          {
            if ( v5 )
            {
              *(_BYTE *)v18 = v20;
              v22 = dword_10075F80[v15];
              v21 = (int)((char *)v18 + 1);
              --v5;
              lpBuffer = (LPVOID)v21;
              v4 = 2;
              *(_BYTE *)(v22 + a1 + 37) = 10;
              if ( v77 == 1 )
              {
                v23 = *(_BYTE *)(dword_10075F80[v15] + a1 + 38);
                if ( v23 != 10 )
                {
                  if ( v5 )
                  {
                    v4 = 3;
                    *(_BYTE *)v21 = v23;
                    v24 = dword_10075F80[v15];
                    lpBuffer = (LPVOID)(v21 + 1);
                    --v5;
                    *(_BYTE *)(v24 + a1 + 38) = 10;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  v26 = sub_1004FE97(a1, v4, a2) == 0;
  v25 = v72;
  if ( v26 || (v27 = dword_10075F80[v72], !(*(_BYTE *)(v27 + a1 + 4) & 0x80)) )
  {
LABEL_45:
    if ( !ReadFile(*(HANDLE *)(dword_10075F80[v25] + a1), lpBuffer, v5, &NumberOfBytesRead, 0)
      || (v31 = NumberOfBytesRead, (signed int)NumberOfBytesRead < 0)
      || NumberOfBytesRead > v5 )
    {
      v28 = GetLastError();
      if ( v28 == 5 )
      {
        *(_DWORD *)sub_10037649(a1) = 9;
        *(_DWORD *)sub_10037615(a1) = 5;
        goto LABEL_41;
      }
      if ( v28 == 109 )
      {
        v29 = 0;
        goto LABEL_42;
      }
      goto LABEL_40;
    }
    goto LABEL_48;
  }
  Mode = GetConsoleMode(*(HANDLE *)(v27 + a1), &Mode);
  if ( !Mode || v77 != 2 )
  {
    v25 = v72;
    goto LABEL_45;
  }
  if ( ReadConsoleW(*(HANDLE *)(dword_10075F80[v72] + a1), lpBuffer, v5 >> 1, &NumberOfBytesRead, 0) )
  {
    v31 = 2 * NumberOfBytesRead;
    NumberOfBytesRead *= 2;
LABEL_48:
    v33 = v72;
    v4 += v31;
    v34 = dword_10075F80[v72];
    v32 = *(_BYTE *)(v34 + a1 + 4);
    if ( v32 >= 0 )
      goto LABEL_106;
    if ( v77 != 2 )
    {
      if ( v31 && *lpMem == 10 )
        v35 = v32 | 4;
      else
        v35 = v32 & 0xFB;
      *(_BYTE *)(v34 + a1 + 4) = v35;
      v36 = lpMem;
      Mode = (DWORD)lpMem;
      lpBuffer = (LPVOID)&lpMem[v4];
      if ( lpMem < &lpMem[v4] )
      {
        v37 = 13;
        v38 = (int)lpMem;
        do
        {
          v39 = *(_BYTE *)v38;
          if ( *(_BYTE *)v38 == 26 )
          {
            v41 = dword_10075F80[v33];
            v40 = *(_BYTE *)(v41 + a1 + 4);
            if ( v40 & 0x40 )
              *v36++ = *(_BYTE *)v38;
            else
              *(_BYTE *)(v41 + a1 + 4) = v40 | 2;
            break;
          }
          if ( v39 == v37 )
          {
            if ( v38 >= (unsigned int)((char *)lpBuffer - 1) )
            {
              ++v38;
              if ( !ReadFile(*(HANDLE *)(dword_10075F80[v33] + a1), &Buffer, 1u, &NumberOfBytesRead, 0)
                && GetLastError()
                || !NumberOfBytesRead )
              {
                v33 = v72;
                v37 = 13;
                *v36++ = 13;
                continue;
              }
              v33 = v72;
              if ( *(_BYTE *)(dword_10075F80[v72] + a1 + 4) & 0x48 )
              {
                v64 = 13;
                if ( Buffer == 10 )
                {
                  *v36++ = 10;
                }
                else
                {
                  *v36++ = 13;
                  *(_BYTE *)(dword_10075F80[v33] + a1 + 5) = Buffer;
                }
              }
              else
              {
                if ( v36 != lpMem || Buffer != 10 )
                {
                  sub_100508F3(a1, v38, a2, (LARGE_INTEGER)-1i64, 1u);
                  v33 = v72;
                  if ( Buffer != 10 )
                  {
                    v37 = 13;
                    *v36 = 13;
                    goto LABEL_79;
                  }
                }
                else
                {
                  *v36++ = 10;
                }
                v64 = 13;
              }
              v37 = v64;
            }
            else
            {
              if ( *(_BYTE *)(v38 + 1) == 10 )
              {
                v38 += 2;
                *v36 = 10;
LABEL_79:
                ++v36;
                continue;
              }
              *v36++ = v37;
              ++v38;
            }
          }
          else
          {
            *v36++ = v39;
            ++v38;
          }
        }
        while ( v38 < (unsigned int)lpBuffer );
      }
      v30 = lpMem;
      v4 = v36 - lpMem;
      if ( v77 != 1 || v36 == lpMem )
      {
LABEL_107:
        v29 = v69;
        goto LABEL_108;
      }
      v42 = (int)(v36 - 1);
      if ( *(_BYTE *)v42 < 0 )
      {
        v43 = 1;
        if ( !byte_10074538[*(_BYTE *)v42] )
        {
          do
          {
            if ( v43 > 4 )
              break;
            if ( v42 < (unsigned int)lpMem )
              break;
            --v42;
            ++v43;
          }
          while ( !byte_10074538[*(_BYTE *)v42] );
          a1 = (a2 & 0x1F) << 6;
        }
        if ( !byte_10074538[*(_BYTE *)v42] )
        {
          *(_DWORD *)sub_10037649(a1) = 42;
          goto LABEL_41;
        }
        if ( byte_10074538[*(_BYTE *)v42] + 1 == v43 )
        {
          v42 += v43;
        }
        else
        {
          v44 = dword_10075F80[v72];
          if ( *(_BYTE *)(v44 + a1 + 4) & 0x48 )
          {
            v45 = *(_BYTE *)v42;
            v47 = v42 + 1;
            *(_BYTE *)(v44 + a1 + 5) = v45;
            v46 = v72;
            if ( v43 >= 2 )
            {
              *(_BYTE *)(dword_10075F80[v72] + a1 + 37) = *(_BYTE *)v47;
              v46 = v72;
              ++v47;
            }
            if ( v43 == 3 )
              *(_BYTE *)(dword_10075F80[v46] + a1 + 38) = *(_BYTE *)v47++;
            v42 = v47 - v43;
          }
          else
          {
            sub_100508F3(a1, v4, a2, (LARGE_INTEGER)-v43, 1u);
          }
        }
      }
      else
      {
        ++v42;
      }
      v48 = v42 - (_DWORD)lpMem;
      v4 = MultiByteToWideChar(0xFDE9u, 0, lpMem, v48, (LPWSTR)lpWideCharStr, v66 >> 1);
      if ( !v4 )
        goto LABEL_39;
      v49 = v4 != v48;
      v4 *= 2;
      *(_DWORD *)(dword_10075F80[v72] + a1 + 48) = v49;
LABEL_106:
      v30 = lpMem;
      goto LABEL_107;
    }
    if ( Mode )
    {
      v53 = lpMem;
      v52 = lpMem;
      v51 = (unsigned int)&lpMem[2 * v4 / 2];
      if ( (unsigned int)lpMem < v51 )
      {
        v75 = 26;
        v54 = 13;
        while ( 1 )
        {
          v55 = *(_WORD *)v52;
          if ( *(_WORD *)v52 == (_WORD)v75 )
            break;
          if ( v55 == v54 )
          {
            if ( (unsigned int)v52 < v51 - 2 )
            {
              v52 += 2;
              v56 = 10;
              if ( *(_WORD *)v52 != 10 )
              {
                v56 = 13;
                v54 = 13;
              }
              *(_WORD *)v53 = v56;
              v53 += 2;
            }
          }
          else
          {
            *(_WORD *)v53 = v55;
            v53 += 2;
            v52 += 2;
          }
          if ( (unsigned int)v52 >= v51 )
            goto LABEL_126;
        }
        *(_BYTE *)(dword_10075F80[v72] + a1 + 4) |= 2u;
      }
LABEL_126:
      v30 = lpMem;
      v4 = (v53 - lpMem) & 0xFFFFFFFE;
      goto LABEL_107;
    }
    if ( v31 && (v33 = v72, *(_WORD *)lpMem == 10) )
      v57 = v32 | 4;
    else
      v57 = v32 & 0xFB;
    *(_BYTE *)(v34 + a1 + 4) = v57;
    v58 = lpMem;
    Mode = (DWORD)&lpMem[v4];
    if ( lpMem >= &lpMem[v4] )
    {
LABEL_162:
      v30 = lpMem;
      v4 = v58 - lpMem;
      goto LABEL_107;
    }
    v59 = 13;
    v76 = 26;
    v60 = (int)lpMem;
    while ( 1 )
    {
      v61 = *(_WORD *)v60;
      if ( *(_WORD *)v60 == (_WORD)v76 )
      {
        v63 = dword_10075F80[v33];
        v62 = *(_BYTE *)(v63 + a1 + 4);
        if ( v62 & 0x40 )
        {
          *(_WORD *)v58 = *(_WORD *)v60;
          v58 += 2;
        }
        else
        {
          *(_BYTE *)(v63 + a1 + 4) = v62 | 2;
        }
        goto LABEL_162;
      }
      if ( v61 == v59 )
      {
        if ( v60 >= Mode - 2 )
        {
          v60 += 2;
          if ( !ReadFile(*(HANDLE *)(dword_10075F80[v33] + a1), &v73, 2u, &NumberOfBytesRead, 0) && GetLastError()
            || !NumberOfBytesRead )
          {
            v33 = v72;
            v59 = 13;
            *(_WORD *)v58 = 13;
            v58 += 2;
            goto LABEL_150;
          }
          v33 = v72;
          if ( *(_BYTE *)(dword_10075F80[v72] + a1 + 4) & 0x48 )
          {
            v65 = 13;
            if ( v73 == 10 )
            {
              *(_WORD *)v58 = 10;
              v58 += 2;
LABEL_149:
              v59 = v65;
              goto LABEL_150;
            }
            *(_WORD *)v58 = 13;
            *(_BYTE *)(dword_10075F80[v33] + a1 + 5) = v73;
            *(_BYTE *)(dword_10075F80[v33] + a1 + 37) = HIBYTE(v73);
            v58 += 2;
            *(_BYTE *)(dword_10075F80[v33] + a1 + 38) = 10;
          }
          else
          {
            if ( v58 != lpMem || v73 != 10 )
            {
              sub_100508F3(a1, v60, a2, (LARGE_INTEGER)-2i64, 1u);
              v33 = v72;
              if ( v73 != 10 )
              {
                v59 = 13;
                *(_WORD *)v58 = 13;
                goto LABEL_157;
              }
            }
            else
            {
              *(_WORD *)v58 = 10;
              v58 += 2;
            }
          }
          v65 = 13;
          goto LABEL_149;
        }
        v33 = v72;
        if ( *(_WORD *)(v60 + 2) == 10 )
        {
          v60 += 4;
          *(_WORD *)v58 = 10;
LABEL_157:
          v58 += 2;
          goto LABEL_150;
        }
        *(_WORD *)v58 = v59;
      }
      else
      {
        *(_WORD *)v58 = v61;
      }
      v58 += 2;
      v60 += 2;
LABEL_150:
      if ( v60 >= Mode )
        goto LABEL_162;
    }
  }
LABEL_39:
  v28 = GetLastError();
LABEL_40:
  sub_10037628(a1, v28);
LABEL_41:
  v29 = -1;
LABEL_42:
  v30 = lpMem;
LABEL_108:
  if ( v30 != lpWideCharStr )
    sub_100309C2(v29, (LPVOID)v30);
  if ( v29 != -2 )
    v4 = v29;
  return v4;
}
// 10075F80: using guessed type int dword_10075F80[];
// 10076898: using guessed type int dword_10076898;

//----- (100553FC) --------------------------------------------------------
void __usercall sub_100553FC(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4)
{
  int v4; // esi@1

  v4 = dword_10075F80[a4 >> 5] + ((a4 & 0x1F) << 6);
  if ( *(_DWORD *)(v4 + 8) )
  {
    EnterCriticalSection((LPCRITICAL_SECTION)(((a4 & 0x1F) << 6) + dword_10075F80[a4 >> 5] + 12));
  }
  else
  {
    sub_10036A23(a1, a2, a3, a4, 10);
    if ( !*(_DWORD *)(v4 + 8) )
    {
      InitializeCriticalSectionAndSpinCount((LPCRITICAL_SECTION)(v4 + 12), 0xFA0u);
      ++*(_DWORD *)(v4 + 8);
    }
    sub_10036B87(10);
  }
}
// 10075F80: using guessed type int dword_10075F80[];

//----- (10055488) --------------------------------------------------------
signed int __usercall sub_10055488<eax>(int a1<ebx>, signed int a2)
{
  int v2; // ecx@3
  int v3; // esi@3
  DWORD v5; // [sp-8h] [bp-10h]@9
  void *v6; // [sp-4h] [bp-Ch]@9

  if ( a2 >= 0 )
  {
    if ( a2 < (unsigned int)dword_10076898 )
    {
      v2 = dword_10075F80[a2 >> 5];
      v3 = (a2 & 0x1F) << 6;
      if ( *(_BYTE *)(v3 + v2 + 4) & 1 )
      {
        if ( *(_DWORD *)(v3 + v2) != -1 )
        {
          if ( dword_100758C8 == 1 )
          {
            if ( !a2 )
            {
              v6 = 0;
              v5 = -10;
              goto LABEL_12;
            }
            if ( a2 == 1 )
            {
              v6 = 0;
              v5 = -11;
              goto LABEL_12;
            }
            if ( a2 == 2 )
            {
              v6 = 0;
              v5 = -12;
LABEL_12:
              SetStdHandle(v5, v6);
              goto LABEL_13;
            }
          }
LABEL_13:
          *(_DWORD *)(v3 + dword_10075F80[a2 >> 5]) = -1;
          return 0;
        }
      }
    }
  }
  *(_DWORD *)sub_10037649(a1) = 9;
  *(_DWORD *)sub_10037615(a1) = 0;
  return -1;
}
// 100758C8: using guessed type int dword_100758C8;
// 10075F80: using guessed type int dword_10075F80[];
// 10076898: using guessed type int dword_10076898;

//----- (1005550E) --------------------------------------------------------
signed int __usercall sub_1005550E<eax>(int a1<ebx>, int a2<edi>, signed int a3)
{
  int v3; // eax@5
  int v4; // ecx@5

  if ( a3 == -2 )
  {
    *(_DWORD *)sub_10037615(a1) = 0;
    *(_DWORD *)sub_10037649(a1) = 9;
  }
  else
  {
    if ( a3 >= 0 )
    {
      if ( a3 < (unsigned int)dword_10076898 )
      {
        v3 = dword_10075F80[a3 >> 5];
        v4 = (a3 & 0x1F) << 6;
        if ( *(_BYTE *)(v3 + v4 + 4) & 1 )
          return *(_DWORD *)(v3 + v4);
      }
    }
    *(_DWORD *)sub_10037615(a1) = 0;
    *(_DWORD *)sub_10037649(a1) = 9;
    sub_1003A151(a1, a2);
  }
  return -1;
}
// 10075F80: using guessed type int dword_10075F80[];
// 10076898: using guessed type int dword_10076898;

//----- (10055575) --------------------------------------------------------
void __cdecl sub_10055575(signed int a1)
{
  LeaveCriticalSection((LPCRITICAL_SECTION)(((a1 & 0x1F) << 6) + 12 + dword_10075F80[a1 >> 5]));
}
// 10075F80: using guessed type int dword_10075F80[];

//----- (1005559B) --------------------------------------------------------
signed __int16 __thiscall sub_1005559B(DWORD this, __int16 Buffer)
{
  HANDLE v2; // eax@1
  signed __int16 result; // ax@4
  DWORD NumberOfCharsWritten; // [sp+0h] [bp-4h]@1

  NumberOfCharsWritten = this;
  v2 = hConsoleOutput;
  if ( hConsoleOutput == (HANDLE)-2 )
  {
    sub_10058440();
    v2 = hConsoleOutput;
  }
  if ( v2 != (HANDLE)-1 && WriteConsoleW(v2, &Buffer, 1u, &NumberOfCharsWritten, 0) )
    result = Buffer;
  else
    result = -1;
  return result;
}

//----- (100555DC) --------------------------------------------------------
signed int __usercall sub_100555DC<eax>(int a1<ebx>, int a2)
{
  int v2; // edi@1
  signed int result; // eax@2
  int v4; // eax@4
  int v5; // edx@4
  int v6; // ecx@4
  int v7; // eax@4

  v2 = -1;
  if ( a2 )
  {
    if ( *(_BYTE *)(a2 + 12) & 0x83 )
    {
      v2 = sub_10047FED(a2);
      sub_100585C3(a1, a2);
      v4 = sub_1004FC88(a1, v2, a2);
      sub_1005845F(v5, v6, a1, v2, v4);
      if ( v7 >= 0 )
      {
        if ( *(_DWORD *)(a2 + 28) )
        {
          sub_100309C2(a1, *(LPVOID *)(a2 + 28));
          *(_DWORD *)(a2 + 28) = 0;
        }
      }
      else
      {
        v2 = -1;
      }
    }
    *(_DWORD *)(a2 + 12) = 0;
    result = v2;
  }
  else
  {
    *(_DWORD *)sub_10037649(a1) = 22;
    sub_1003A151(a1, -1);
    result = -1;
  }
  return result;
}

//----- (10055648) --------------------------------------------------------
void __usercall sub_10055648(int a1<edx>, int a2<ebx>, unsigned int a3)
{
  if ( a3 != 0 )
  {
    if ( *(_BYTE *)(a3 + 12) & 0x40 )
    {
      *(_DWORD *)(a3 + 12) = 0;
    }
    else
    {
      sub_10047ED1(a1, a2, -1, a3);
      sub_100555DC(a2, a3);
      sub_10047F40(a3);
    }
  }
  else
  {
    *(_DWORD *)sub_10037649(a2) = 22;
    sub_1003A151(a2, -1);
  }
}

//----- (100556BF) --------------------------------------------------------
int __usercall sub_100556BF<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, unsigned int a5, int a6)
{
  void *v6; // ecx@1
  int v8; // ebx@8
  const WCHAR v9; // di@8
  int i; // esi@8
  int v11; // eax@10
  void *v12; // ST04_4@10
  int v13; // eax@11
  signed int v14; // eax@15
  int v15; // edx@28
  unsigned __int16 v16; // cx@31
  int v17; // eax@32
  int v18; // edi@33
  int v19; // esi@34
  int v20; // edx@39
  int v21; // eax@43
  unsigned int v22; // [sp+4h] [bp-8h]@27
  int v23; // [sp+8h] [bp-4h]@15

  v6 = (void *)a3;
  if ( a4 )
    *(_DWORD *)a4 = a3;
  if ( !a3 || a5 && ((signed int)a5 < 2 || (signed int)a5 > 36) )
  {
    *(_DWORD *)sub_10037649(a1) = 22;
    sub_1003A151(a1, a2);
    return 0;
  }
  v9 = *(_WORD *)a3;
  v8 = 0;
  for ( i = a3 + 2; ; i += 2 )
  {
    v11 = sub_1004EA92(v6, v9, 8);
    v6 = v12;
    if ( !v11 )
      break;
    v9 = *(_WORD *)i;
  }
  v13 = a6;
  if ( v9 == 45 )
  {
    v13 = a6 | 2;
  }
  else
  {
    if ( v9 != 43 )
      goto LABEL_15;
  }
  v9 = *(_WORD *)i;
  i += 2;
LABEL_15:
  v23 = v13;
  v14 = a5;
  if ( a5 )
    goto LABEL_22;
  if ( !sub_100585F3(v9) )
  {
    if ( *(_WORD *)i != 120 && *(_WORD *)i != 88 )
    {
      a5 = 8;
      goto LABEL_27;
    }
    v14 = 16;
    a5 = 16;
LABEL_22:
    if ( v14 == 16 )
    {
      if ( !sub_100585F3(v9) )
      {
        if ( *(_WORD *)i == 120 || *(_WORD *)i == 88 )
        {
          v9 = *(_WORD *)(i + 2);
          i += 4;
        }
      }
    }
    goto LABEL_27;
  }
  a5 = 10;
LABEL_27:
  v22 = 0xFFFFFFFF / a5;
  while ( 1 )
  {
    v15 = sub_100585F3(v9);
    if ( v15 != -1 )
      goto LABEL_42;
    if ( v9 >= 0x41u && v9 <= 0x5Au )
    {
      v16 = 25;
      goto LABEL_39;
    }
    v16 = 25;
    if ( (unsigned __int16)(v9 - 97) > 0x19u )
      break;
LABEL_39:
    v20 = v9;
    if ( (unsigned __int16)(v9 - 97) <= v16 )
      v20 = v9 - 32;
    v15 = v20 - 55;
LABEL_42:
    LOBYTE(v17) = v23;
    if ( v15 >= a5 )
      goto LABEL_33;
    v21 = v23 | 8;
    v23 |= 8u;
    if ( v8 < v22 || v8 == v22 && v15 <= 0xFFFFFFFF % a5 )
    {
      v8 = v15 + a5 * v8;
    }
    else
    {
      v18 = a4;
      v17 = v21 | 4;
      v23 = v17;
      if ( !a4 )
        goto LABEL_34;
    }
    v9 = *(_WORD *)i;
    i += 2;
  }
  LOBYTE(v17) = v23;
LABEL_33:
  v18 = a4;
LABEL_34:
  v19 = i - 2;
  if ( v17 & 8 )
  {
    if ( v17 & 4
      || !(v17 & 1) && (v17 & 2 && (unsigned int)v8 > 0x80000000 || !(v17 & 2) && (unsigned int)v8 > 0x7FFFFFFF) )
    {
      *(_DWORD *)sub_10037649(v8) = 34;
      LOBYTE(v17) = v23;
      if ( v23 & 1 )
        v8 = -1;
      else
        v8 = ((v23 & 2) != 0) + 2147483647;
    }
  }
  else
  {
    if ( v18 )
      v19 = a3;
    v8 = 0;
  }
  if ( v18 )
    *(_DWORD *)v18 = v19;
  if ( v17 & 2 )
    v8 = -v8;
  return v8;
}

//----- (1005589B) --------------------------------------------------------
int __usercall sub_1005589B<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, unsigned int a5)
{
  return sub_100556BF(a1, a2, a3, a4, a5, 0);
}

//----- (100558B3) --------------------------------------------------------
signed int __cdecl sub_100558B3(int a1, int a2)
{
  int v2; // edx@1
  signed int v3; // ebx@1
  int v4; // edi@1
  __int16 v5; // dx@1
  signed int v6; // eax@2
  int v7; // esi@2
  int v8; // edx@8
  int v9; // ecx@8
  signed int v10; // edi@8
  char i; // zf@9
  int v12; // eax@14
  signed int v13; // ecx@14
  unsigned int v14; // eax@14
  char v15; // cf@14
  int v16; // edx@17
  int v17; // eax@19
  unsigned int v18; // eax@19
  char v19; // cf@19
  int v20; // ecx@28
  char v21; // di@34
  int v22; // eax@34
  int v23; // eax@35
  unsigned int v24; // edx@35
  int v25; // eax@36
  int *v26; // edx@36
  signed int v27; // ecx@36
  signed int v28; // edi@36
  int v29; // edx@41
  int v30; // ecx@41
  int v31; // ecx@41
  char j; // zf@42
  int v33; // eax@47
  signed int v34; // ecx@47
  unsigned int v35; // eax@47
  signed int v36; // edi@47
  int v37; // edi@47
  char v38; // cf@47
  int v39; // edx@50
  int v40; // eax@52
  unsigned int v41; // eax@52
  char v42; // cf@52
  int v43; // edx@59
  int v44; // eax@61
  char v45; // bl@61
  signed int v46; // edi@61
  int v47; // ecx@61
  unsigned int v48; // edx@62
  int *v49; // edx@63
  signed int v50; // ecx@63
  int v51; // ecx@70
  signed int v52; // edi@70
  int v53; // eax@71
  unsigned int v54; // edx@71
  int *v55; // edx@72
  signed int v56; // ecx@72
  char v57; // bl@78
  signed int v58; // edi@78
  signed int v59; // esi@78
  int v60; // eax@79
  unsigned int v61; // edx@79
  int *v62; // edx@80
  signed int v63; // ecx@80
  int v64; // esi@86
  int v65; // eax@87
  int v67; // [sp+Ch] [bp-44h]@1
  int v68; // [sp+14h] [bp-3Ch]@8
  int v69; // [sp+14h] [bp-3Ch]@34
  signed int v70; // [sp+18h] [bp-38h]@14
  int v71; // [sp+18h] [bp-38h]@34
  int v72; // [sp+18h] [bp-38h]@70
  int v73; // [sp+18h] [bp-38h]@78
  signed int v74; // [sp+1Ch] [bp-34h]@8
  int v75; // [sp+1Ch] [bp-34h]@61
  int v76; // [sp+1Ch] [bp-34h]@70
  char v77; // [sp+20h] [bp-30h]@8
  int v78; // [sp+20h] [bp-30h]@41
  signed int v79; // [sp+24h] [bp-2Ch]@8
  signed int v80; // [sp+28h] [bp-28h]@34
  int v81; // [sp+28h] [bp-28h]@61
  int v82; // [sp+28h] [bp-28h]@70
  int v83; // [sp+28h] [bp-28h]@78
  int v84; // [sp+2Ch] [bp-24h]@8
  signed int v85; // [sp+2Ch] [bp-24h]@47
  int v86; // [sp+2Ch] [bp-24h]@61
  int v87; // [sp+2Ch] [bp-24h]@78
  int v88; // [sp+30h] [bp-20h]@1
  int v89; // [sp+30h] [bp-20h]@34
  int v90; // [sp+30h] [bp-20h]@61
  int v91; // [sp+30h] [bp-20h]@70
  int v92; // [sp+30h] [bp-20h]@78
  int v93; // [sp+34h] [bp-1Ch]@8
  int v94; // [sp+38h] [bp-18h]@8
  int v95; // [sp+3Ch] [bp-14h]@8
  int v96; // [sp+40h] [bp-10h]@1
  int v97; // [sp+44h] [bp-Ch]@1
  int v98; // [sp+48h] [bp-8h]@1
  unsigned int v99; // [sp+4Ch] [bp-4h]@1
  int v100; // [sp+50h] [bp+0h]@1

  v99 = (unsigned int)&v100 ^ __security_cookie;
  v5 = *(_WORD *)(a1 + 10);
  v67 = *(_WORD *)(a1 + 10) & 0x8000;
  v96 = *(_DWORD *)(a1 + 6);
  v97 = *(_DWORD *)(a1 + 2);
  v2 = (v5 & 0x7FFF) - 16383;
  v4 = a2;
  v3 = 0;
  v88 = v2;
  v98 = *(_WORD *)a1 << 16;
  if ( v2 == -16383 )
  {
    v7 = 0;
    v6 = 0;
    while ( !*(&v96 + v6) )
    {
      ++v6;
      if ( v6 >= 3 )
        goto LABEL_86;
    }
    v96 = 0;
    v97 = 0;
    v98 = 0;
  }
  else
  {
    v93 = v96;
    v94 = v97;
    v84 = v2;
    v74 = dword_10074640 - 1;
    v95 = v98;
    v8 = dword_10074640 / 32;
    v79 = 0;
    v68 = dword_10074640 / 32;
    v9 = 31 - dword_10074640 % 32;
    v10 = -1;
    v77 = v9;
    if ( (1 << v9) & *(&v96 + dword_10074640 / 32) )
    {
      for ( i = (~(-1 << v9) & *(&v96 + v8)) == 0; i; i = *(&v96 + v8) == 0 )
      {
        ++v8;
        if ( v8 >= 3 )
          goto LABEL_25;
      }
      v79 = 0;
      v10 = -1;
      v70 = 1 << (31 - v74 % 32);
      v14 = *(&v96 + v74 / 32);
      v15 = v14 + v70 < v14;
      v12 = v14 + v70;
      v13 = 0;
      if ( v15 || v12 < (unsigned int)v70 )
      {
        v13 = 1;
        v79 = 1;
      }
      v16 = v74 / 32 - 1;
      *(&v97 + v16) = v12;
      if ( v16 >= 0 )
      {
        do
        {
          if ( !v13 )
            break;
          v18 = *(&v96 + v16);
          v13 = 0;
          v19 = v18 + 1 < v18;
          v79 = 0;
          v17 = v18 + 1;
          if ( v19 || (unsigned int)v17 < 1 )
          {
            v13 = 1;
            v79 = 1;
          }
          --v16;
          *(&v97 + v16) = v17;
        }
        while ( v16 >= 0 );
        v10 = -1;
      }
      LOBYTE(v9) = v77;
LABEL_25:
      v8 = v68;
    }
    *(&v96 + v8) &= v10 << v9;
    if ( v8 + 1 < 3 )
    {
      memset(&v96 + v8 + 1, 0, 4 * (3 - (v8 + 1)));
      v10 = -1;
    }
    v20 = v88;
    if ( v79 )
      v20 = v88 + 1;
    if ( v20 >= dword_1007463C - dword_10074640 )
    {
      if ( v20 > dword_1007463C )
      {
        if ( v20 < dword_10074638 )
        {
          v96 &= 0x7FFFFFFFu;
          v73 = v20 + dword_1007464C;
          v83 = dword_10074644 / 32;
          v92 = 0;
          v59 = 0;
          v57 = dword_10074644 % 32;
          v58 = ~(v10 << dword_10074644 % 32);
          v87 = 32 - dword_10074644 % 32;
          do
          {
            v60 = (v58 & *(&v96 + v59)) << v87;
            v61 = v92 | ((unsigned int)*(&v96 + v59++) >> v57);
            *(&v95 + v59) = v61;
            v92 = v60;
          }
          while ( v59 < 3 );
          v7 = v73;
          v62 = &v98 - v83;
          v63 = 2;
          v3 = 0;
          do
          {
            if ( v63 < v83 )
              *(&v96 + v63) = 0;
            else
              *(&v96 + v63) = *v62;
            --v62;
            --v63;
          }
          while ( v63 >= 0 );
        }
        else
        {
          v97 = 0;
          v98 = 0;
          v96 = -2147483648;
          v76 = dword_10074644 / 32;
          v51 = dword_10074644 % 32;
          v72 = dword_10074644 % 32;
          v52 = ~(-1 << dword_10074644 % 32);
          v91 = 0;
          v82 = 32 - dword_10074644 % 32;
          do
          {
            v53 = (v52 & *(&v96 + v3)) << v82;
            v54 = v91 | ((unsigned int)*(&v96 + v3) >> v51);
            LOBYTE(v51) = v72;
            *(&v96 + v3++) = v54;
            v91 = v53;
          }
          while ( v3 < 3 );
          v55 = &v98 - v76;
          v56 = 2;
          do
          {
            if ( v56 < v76 )
              *(&v96 + v56) = 0;
            else
              *(&v96 + v56) = *v55;
            --v55;
            --v56;
          }
          while ( v56 >= 0 );
          v7 = dword_10074638 + dword_1007464C;
          v3 = 1;
        }
        goto LABEL_85;
      }
      v96 = v93;
      v97 = v94;
      v69 = (dword_1007463C - v84) / 32;
      v98 = v95;
      v22 = (dword_1007463C - v84) % 32;
      v21 = (dword_1007463C - v84) % 32;
      v89 = 0;
      v80 = ~(-1 << v22);
      v71 = 32 - v22;
      do
      {
        v23 = (v80 & *(&v96 + v3)) << v71;
        v24 = v89 | ((unsigned int)*(&v96 + v3++) >> v21);
        *(&v95 + v3) = v24;
        v89 = v23;
      }
      while ( v3 < 3 );
      v26 = &v98 - v69;
      v25 = v69;
      v27 = 2;
      v28 = -1;
      do
      {
        if ( v27 < v25 )
        {
          *(&v96 + v27) = 0;
        }
        else
        {
          *(&v96 + v27) = *v26;
          v25 = v69;
        }
        --v26;
        --v27;
      }
      while ( v27 >= 0 );
      v29 = (v74 + 1) / 32;
      v31 = (v74 + 1) % 32;
      v78 = 31 - v31;
      v30 = 31 - v31;
      if ( (1 << v30) & *(&v96 + v29) )
      {
        for ( j = (~(-1 << v30) & *(&v96 + v29)) == 0; j; j = *(&v96 + v29) == 0 )
        {
          ++v29;
          if ( v29 >= 3 )
            goto LABEL_58;
        }
        v35 = *(&v96 + v74 / 32);
        v36 = 1 << (31 - v74 % 32);
        v34 = 0;
        v85 = v36;
        v37 = v35 + v36;
        v38 = v37 < v35;
        v33 = v37;
        v28 = -1;
        if ( v38 || v33 < (unsigned int)v85 )
          v34 = 1;
        v39 = v74 / 32 - 1;
        *(&v97 + v39) = v33;
        if ( v39 >= 0 )
        {
          do
          {
            if ( !v34 )
              break;
            v41 = *(&v96 + v39);
            v34 = 0;
            v42 = v41 + 1 < v41;
            v40 = v41 + 1;
            if ( v42 || (unsigned int)v40 < 1 )
              v34 = 1;
            --v39;
            *(&v97 + v39) = v40;
          }
          while ( v39 >= 0 );
          v28 = -1;
        }
        LOBYTE(v30) = v78;
LABEL_58:
        v29 = (v74 + 1) / 32;
      }
      *(&v96 + v29) &= v28 << v30;
      v43 = v29 + 1;
      if ( v43 < 3 )
      {
        memset(&v96 + v43, 0, 4 * (3 - v43));
        v28 = -1;
      }
      v81 = (dword_10074644 + 1) / 32;
      v47 = (dword_10074644 + 1) % 32;
      v44 = 0;
      v90 = 0;
      v45 = (dword_10074644 + 1) % 32;
      v46 = ~(v28 << v47);
      v75 = 0;
      v86 = 32 - v47;
      do
      {
        v48 = *(&v96 + v44);
        *(&v96 + v75) = v90 | (v48 >> v45);
        v90 = (v46 & v48) << v86;
        v44 = v75 + 1;
        v75 = v44;
      }
      while ( v44 < 3 );
      v49 = &v98 - v81;
      v50 = 2;
      v3 = 0;
      do
      {
        if ( v50 < v81 )
          *(&v96 + v50) = 0;
        else
          *(&v96 + v50) = *v49;
        --v49;
        --v50;
      }
      while ( v50 >= 0 );
    }
    else
    {
      v96 = 0;
      v97 = 0;
      v98 = 0;
    }
    v7 = v3;
  }
  v3 = 2;
LABEL_85:
  v4 = a2;
LABEL_86:
  v64 = v96 | (v67 != 0 ? 0x80000000 : 0) | (v7 << (31 - dword_10074644));
  if ( dword_10074648 == 64 )
  {
    v65 = v97;
    *(_DWORD *)(v4 + 4) = v64;
    *(_DWORD *)v4 = v65;
  }
  else
  {
    if ( dword_10074648 == 32 )
      *(_DWORD *)v4 = v64;
  }
  return v3;
}
// 10073200: using guessed type int __security_cookie;
// 10074638: using guessed type int dword_10074638;
// 1007463C: using guessed type int dword_1007463C;
// 10074640: using guessed type int dword_10074640;
// 10074644: using guessed type int dword_10074644;
// 10074648: using guessed type int dword_10074648;
// 1007464C: using guessed type int dword_1007464C;

//----- (10055E23) --------------------------------------------------------
signed int __cdecl sub_10055E23(int a1, int a2)
{
  int v2; // edx@1
  signed int v3; // ebx@1
  int v4; // edi@1
  __int16 v5; // dx@1
  signed int v6; // eax@2
  int v7; // esi@2
  int v8; // edx@8
  int v9; // ecx@8
  signed int v10; // edi@8
  char i; // zf@9
  int v12; // eax@14
  signed int v13; // ecx@14
  unsigned int v14; // eax@14
  char v15; // cf@14
  int v16; // edx@17
  int v17; // eax@19
  unsigned int v18; // eax@19
  char v19; // cf@19
  int v20; // ecx@28
  char v21; // di@34
  int v22; // eax@34
  int v23; // eax@35
  unsigned int v24; // edx@35
  int v25; // eax@36
  int *v26; // edx@36
  signed int v27; // ecx@36
  signed int v28; // edi@36
  int v29; // edx@41
  int v30; // ecx@41
  int v31; // ecx@41
  char j; // zf@42
  int v33; // eax@47
  signed int v34; // ecx@47
  unsigned int v35; // eax@47
  signed int v36; // edi@47
  int v37; // edi@47
  char v38; // cf@47
  int v39; // edx@50
  int v40; // eax@52
  unsigned int v41; // eax@52
  char v42; // cf@52
  int v43; // edx@59
  int v44; // eax@61
  char v45; // bl@61
  signed int v46; // edi@61
  int v47; // ecx@61
  unsigned int v48; // edx@62
  int *v49; // edx@63
  signed int v50; // ecx@63
  int v51; // ecx@70
  signed int v52; // edi@70
  int v53; // eax@71
  unsigned int v54; // edx@71
  int *v55; // edx@72
  signed int v56; // ecx@72
  char v57; // bl@78
  signed int v58; // edi@78
  signed int v59; // esi@78
  int v60; // eax@79
  unsigned int v61; // edx@79
  int *v62; // edx@80
  signed int v63; // ecx@80
  int v64; // esi@86
  int v65; // eax@87
  int v67; // [sp+Ch] [bp-44h]@1
  int v68; // [sp+14h] [bp-3Ch]@8
  int v69; // [sp+14h] [bp-3Ch]@34
  signed int v70; // [sp+18h] [bp-38h]@14
  int v71; // [sp+18h] [bp-38h]@34
  int v72; // [sp+18h] [bp-38h]@70
  int v73; // [sp+18h] [bp-38h]@78
  signed int v74; // [sp+1Ch] [bp-34h]@8
  int v75; // [sp+1Ch] [bp-34h]@61
  int v76; // [sp+1Ch] [bp-34h]@70
  char v77; // [sp+20h] [bp-30h]@8
  int v78; // [sp+20h] [bp-30h]@41
  signed int v79; // [sp+24h] [bp-2Ch]@8
  signed int v80; // [sp+28h] [bp-28h]@34
  int v81; // [sp+28h] [bp-28h]@61
  int v82; // [sp+28h] [bp-28h]@70
  int v83; // [sp+28h] [bp-28h]@78
  int v84; // [sp+2Ch] [bp-24h]@8
  signed int v85; // [sp+2Ch] [bp-24h]@47
  int v86; // [sp+2Ch] [bp-24h]@61
  int v87; // [sp+2Ch] [bp-24h]@78
  int v88; // [sp+30h] [bp-20h]@1
  int v89; // [sp+30h] [bp-20h]@34
  int v90; // [sp+30h] [bp-20h]@61
  int v91; // [sp+30h] [bp-20h]@70
  int v92; // [sp+30h] [bp-20h]@78
  int v93; // [sp+34h] [bp-1Ch]@8
  int v94; // [sp+38h] [bp-18h]@8
  int v95; // [sp+3Ch] [bp-14h]@8
  int v96; // [sp+40h] [bp-10h]@1
  int v97; // [sp+44h] [bp-Ch]@1
  int v98; // [sp+48h] [bp-8h]@1
  unsigned int v99; // [sp+4Ch] [bp-4h]@1
  int v100; // [sp+50h] [bp+0h]@1

  v99 = (unsigned int)&v100 ^ __security_cookie;
  v5 = *(_WORD *)(a1 + 10);
  v67 = *(_WORD *)(a1 + 10) & 0x8000;
  v96 = *(_DWORD *)(a1 + 6);
  v97 = *(_DWORD *)(a1 + 2);
  v2 = (v5 & 0x7FFF) - 16383;
  v4 = a2;
  v3 = 0;
  v88 = v2;
  v98 = *(_WORD *)a1 << 16;
  if ( v2 == -16383 )
  {
    v7 = 0;
    v6 = 0;
    while ( !*(&v96 + v6) )
    {
      ++v6;
      if ( v6 >= 3 )
        goto LABEL_86;
    }
    v96 = 0;
    v97 = 0;
    v98 = 0;
  }
  else
  {
    v93 = v96;
    v94 = v97;
    v84 = v2;
    v74 = dword_10074658 - 1;
    v95 = v98;
    v8 = dword_10074658 / 32;
    v79 = 0;
    v68 = dword_10074658 / 32;
    v9 = 31 - dword_10074658 % 32;
    v10 = -1;
    v77 = v9;
    if ( (1 << v9) & *(&v96 + dword_10074658 / 32) )
    {
      for ( i = (~(-1 << v9) & *(&v96 + v8)) == 0; i; i = *(&v96 + v8) == 0 )
      {
        ++v8;
        if ( v8 >= 3 )
          goto LABEL_25;
      }
      v79 = 0;
      v10 = -1;
      v70 = 1 << (31 - v74 % 32);
      v14 = *(&v96 + v74 / 32);
      v15 = v14 + v70 < v14;
      v12 = v14 + v70;
      v13 = 0;
      if ( v15 || v12 < (unsigned int)v70 )
      {
        v13 = 1;
        v79 = 1;
      }
      v16 = v74 / 32 - 1;
      *(&v97 + v16) = v12;
      if ( v16 >= 0 )
      {
        do
        {
          if ( !v13 )
            break;
          v18 = *(&v96 + v16);
          v13 = 0;
          v19 = v18 + 1 < v18;
          v79 = 0;
          v17 = v18 + 1;
          if ( v19 || (unsigned int)v17 < 1 )
          {
            v13 = 1;
            v79 = 1;
          }
          --v16;
          *(&v97 + v16) = v17;
        }
        while ( v16 >= 0 );
        v10 = -1;
      }
      LOBYTE(v9) = v77;
LABEL_25:
      v8 = v68;
    }
    *(&v96 + v8) &= v10 << v9;
    if ( v8 + 1 < 3 )
    {
      memset(&v96 + v8 + 1, 0, 4 * (3 - (v8 + 1)));
      v10 = -1;
    }
    v20 = v88;
    if ( v79 )
      v20 = v88 + 1;
    if ( v20 >= dword_10074654 - dword_10074658 )
    {
      if ( v20 > dword_10074654 )
      {
        if ( v20 < dword_10074650 )
        {
          v96 &= 0x7FFFFFFFu;
          v73 = v20 + dword_10074664;
          v83 = dword_1007465C / 32;
          v92 = 0;
          v59 = 0;
          v57 = dword_1007465C % 32;
          v58 = ~(v10 << dword_1007465C % 32);
          v87 = 32 - dword_1007465C % 32;
          do
          {
            v60 = (v58 & *(&v96 + v59)) << v87;
            v61 = v92 | ((unsigned int)*(&v96 + v59++) >> v57);
            *(&v95 + v59) = v61;
            v92 = v60;
          }
          while ( v59 < 3 );
          v7 = v73;
          v62 = &v98 - v83;
          v63 = 2;
          v3 = 0;
          do
          {
            if ( v63 < v83 )
              *(&v96 + v63) = 0;
            else
              *(&v96 + v63) = *v62;
            --v62;
            --v63;
          }
          while ( v63 >= 0 );
        }
        else
        {
          v97 = 0;
          v98 = 0;
          v96 = -2147483648;
          v76 = dword_1007465C / 32;
          v51 = dword_1007465C % 32;
          v72 = dword_1007465C % 32;
          v52 = ~(-1 << dword_1007465C % 32);
          v91 = 0;
          v82 = 32 - dword_1007465C % 32;
          do
          {
            v53 = (v52 & *(&v96 + v3)) << v82;
            v54 = v91 | ((unsigned int)*(&v96 + v3) >> v51);
            LOBYTE(v51) = v72;
            *(&v96 + v3++) = v54;
            v91 = v53;
          }
          while ( v3 < 3 );
          v55 = &v98 - v76;
          v56 = 2;
          do
          {
            if ( v56 < v76 )
              *(&v96 + v56) = 0;
            else
              *(&v96 + v56) = *v55;
            --v55;
            --v56;
          }
          while ( v56 >= 0 );
          v7 = dword_10074650 + dword_10074664;
          v3 = 1;
        }
        goto LABEL_85;
      }
      v96 = v93;
      v97 = v94;
      v69 = (dword_10074654 - v84) / 32;
      v98 = v95;
      v22 = (dword_10074654 - v84) % 32;
      v21 = (dword_10074654 - v84) % 32;
      v89 = 0;
      v80 = ~(-1 << v22);
      v71 = 32 - v22;
      do
      {
        v23 = (v80 & *(&v96 + v3)) << v71;
        v24 = v89 | ((unsigned int)*(&v96 + v3++) >> v21);
        *(&v95 + v3) = v24;
        v89 = v23;
      }
      while ( v3 < 3 );
      v26 = &v98 - v69;
      v25 = v69;
      v27 = 2;
      v28 = -1;
      do
      {
        if ( v27 < v25 )
        {
          *(&v96 + v27) = 0;
        }
        else
        {
          *(&v96 + v27) = *v26;
          v25 = v69;
        }
        --v26;
        --v27;
      }
      while ( v27 >= 0 );
      v29 = (v74 + 1) / 32;
      v31 = (v74 + 1) % 32;
      v78 = 31 - v31;
      v30 = 31 - v31;
      if ( (1 << v30) & *(&v96 + v29) )
      {
        for ( j = (~(-1 << v30) & *(&v96 + v29)) == 0; j; j = *(&v96 + v29) == 0 )
        {
          ++v29;
          if ( v29 >= 3 )
            goto LABEL_58;
        }
        v35 = *(&v96 + v74 / 32);
        v36 = 1 << (31 - v74 % 32);
        v34 = 0;
        v85 = v36;
        v37 = v35 + v36;
        v38 = v37 < v35;
        v33 = v37;
        v28 = -1;
        if ( v38 || v33 < (unsigned int)v85 )
          v34 = 1;
        v39 = v74 / 32 - 1;
        *(&v97 + v39) = v33;
        if ( v39 >= 0 )
        {
          do
          {
            if ( !v34 )
              break;
            v41 = *(&v96 + v39);
            v34 = 0;
            v42 = v41 + 1 < v41;
            v40 = v41 + 1;
            if ( v42 || (unsigned int)v40 < 1 )
              v34 = 1;
            --v39;
            *(&v97 + v39) = v40;
          }
          while ( v39 >= 0 );
          v28 = -1;
        }
        LOBYTE(v30) = v78;
LABEL_58:
        v29 = (v74 + 1) / 32;
      }
      *(&v96 + v29) &= v28 << v30;
      v43 = v29 + 1;
      if ( v43 < 3 )
      {
        memset(&v96 + v43, 0, 4 * (3 - v43));
        v28 = -1;
      }
      v81 = (dword_1007465C + 1) / 32;
      v47 = (dword_1007465C + 1) % 32;
      v44 = 0;
      v90 = 0;
      v45 = (dword_1007465C + 1) % 32;
      v46 = ~(v28 << v47);
      v75 = 0;
      v86 = 32 - v47;
      do
      {
        v48 = *(&v96 + v44);
        *(&v96 + v75) = v90 | (v48 >> v45);
        v90 = (v46 & v48) << v86;
        v44 = v75 + 1;
        v75 = v44;
      }
      while ( v44 < 3 );
      v49 = &v98 - v81;
      v50 = 2;
      v3 = 0;
      do
      {
        if ( v50 < v81 )
          *(&v96 + v50) = 0;
        else
          *(&v96 + v50) = *v49;
        --v49;
        --v50;
      }
      while ( v50 >= 0 );
    }
    else
    {
      v96 = 0;
      v97 = 0;
      v98 = 0;
    }
    v7 = v3;
  }
  v3 = 2;
LABEL_85:
  v4 = a2;
LABEL_86:
  v64 = v96 | (v67 != 0 ? 0x80000000 : 0) | (v7 << (31 - dword_1007465C));
  if ( dword_10074660 == 64 )
  {
    v65 = v97;
    *(_DWORD *)(v4 + 4) = v64;
    *(_DWORD *)v4 = v65;
  }
  else
  {
    if ( dword_10074660 == 32 )
      *(_DWORD *)v4 = v64;
  }
  return v3;
}
// 10073200: using guessed type int __security_cookie;
// 10074650: using guessed type int dword_10074650;
// 10074654: using guessed type int dword_10074654;
// 10074658: using guessed type int dword_10074658;
// 1007465C: using guessed type int dword_1007465C;
// 10074660: using guessed type int dword_10074660;
// 10074664: using guessed type int dword_10074664;

//----- (10056393) --------------------------------------------------------
signed int __cdecl sub_10056393(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  signed int v8; // eax@1
  signed int v9; // ebx@1
  char *v10; // edi@1
  int v11; // esi@1
  int v13; // ecx@3
  char v14; // dl@4
  char v15; // dl@9
  unsigned int v16; // eax@38
  int v17; // esi@38
  int v18; // eax@49
  unsigned __int8 v19; // sf@50
  unsigned __int8 v20; // of@50
  int v21; // eax@51
  int v22; // esi@56
  char v23; // zf@74
  int v24; // ecx@109
  int v25; // edi@112
  signed int v26; // esi@117
  char *v27; // eax@123
  char v28; // cl@128
  int v29; // ecx@128
  int v30; // ecx@129
  int v31; // esi@130
  unsigned __int16 v32; // di@131
  int v33; // esi@131
  signed int v34; // eax@145
  char *v35; // edx@145
  signed int v36; // edi@145
  int v37; // eax@147
  signed int v38; // ecx@147
  char *v39; // esi@147
  int v40; // edi@148
  int v41; // edi@148
  signed int v42; // eax@150
  int v43; // edx@157
  int v44; // edi@157
  int v45; // esi@157
  unsigned int v46; // eax@159
  int v47; // eax@165
  char v48; // zf@165
  char v49; // zf@166
  unsigned __int16 v50; // ax@167
  int v51; // ecx@177
  unsigned int v52; // eax@186
  int v53; // edx@186
  __int16 v54; // cx@186
  signed int v55; // esi@186
  signed int v56; // [sp-4h] [bp-8Ch]@11
  signed int v57; // [sp-4h] [bp-8Ch]@14
  signed int v58; // [sp-4h] [bp-8Ch]@188
  signed int v59; // [sp+18h] [bp-70h]@145
  signed __int16 v60; // [sp+1Ch] [bp-6Ch]@1
  signed int v61; // [sp+20h] [bp-68h]@145
  int v62; // [sp+20h] [bp-68h]@162
  signed int v63; // [sp+24h] [bp-64h]@1
  int v64; // [sp+24h] [bp-64h]@147
  signed int v65; // [sp+28h] [bp-60h]@1
  __int16 v66; // [sp+28h] [bp-60h]@131
  signed int v67; // [sp+2Ch] [bp-5Ch]@1
  int v68; // [sp+2Ch] [bp-5Ch]@131
  signed int v69; // [sp+30h] [bp-58h]@1
  int v70; // [sp+30h] [bp-58h]@148
  int v71; // [sp+34h] [bp-54h]@1
  signed int v72; // [sp+34h] [bp-54h]@128
  int v73; // [sp+38h] [bp-50h]@3
  __int64 *v74; // [sp+38h] [bp-50h]@129
  int v75; // [sp+38h] [bp-50h]@157
  unsigned int v76; // [sp+3Ch] [bp-4Ch]@1
  char *v77; // [sp+3Ch] [bp-4Ch]@128
  __int64 v78; // [sp+40h] [bp-48h]@130
  int v79; // [sp+48h] [bp-40h]@130
  int v80; // [sp+4Ch] [bp-3Ch]@115
  int v81; // [sp+50h] [bp-38h]@138
  unsigned int v82; // [sp+54h] [bp-34h]@135
  int v83; // [sp+56h] [bp-32h]@131
  __int64 v84; // [sp+5Ah] [bp-2Eh]@131
  signed int v85; // [sp+62h] [bp-26h]@172
  int v86; // [sp+64h] [bp-24h]@131
  char v87; // [sp+68h] [bp-20h]@1
  char v88; // [sp+7Fh] [bp-9h]@107
  unsigned int v89; // [sp+84h] [bp-4h]@1
  int v90; // [sp+88h] [bp+0h]@1

  v89 = (unsigned int)&v90 ^ __security_cookie;
  v9 = 0;
  v65 = 1;
  v8 = 0;
  v10 = &v87;
  v60 = 0;
  v76 = 0;
  v63 = 0;
  v69 = 0;
  v67 = 0;
  v11 = 0;
  v71 = 0;
  if ( !a8 )
  {
    *(_DWORD *)sub_10037649(0) = 22;
    sub_1003A151(0, (int)&v87);
    return 0;
  }
  v13 = a3;
  v73 = a3;
  while ( 1 )
  {
    v14 = *(_BYTE *)v13;
    if ( *(_BYTE *)v13 != 32 )
    {
      if ( v14 != 9 && v14 != 10 && v14 != 13 )
        break;
    }
    ++v13;
  }
  while ( 2 )
  {
    v15 = *(_BYTE *)v13++;
    switch ( v8 )
    {
      case 0:
        if ( (unsigned __int8)(v15 - 49) <= 8u )
          goto LABEL_11;
        if ( v15 == ***(_BYTE ***)(*(_DWORD *)a8 + 132) )
          goto LABEL_14;
        if ( v15 == 43 )
        {
          v8 = 2;
          v60 = 0;
          continue;
        }
        if ( v15 == 45 )
        {
          v8 = 2;
          v60 = -32768;
          continue;
        }
        if ( v15 != 48 )
          goto LABEL_103;
        goto LABEL_19;
      case 1:
        v63 = 1;
        if ( (unsigned __int8)(v15 - 49) <= 8u )
          goto LABEL_11;
        if ( v15 == ***(_BYTE ***)(*(_DWORD *)a8 + 132) )
          goto LABEL_24;
        if ( v15 == 43 || v15 == 45 )
          goto LABEL_32;
        if ( v15 != 48 )
          goto LABEL_28;
        goto LABEL_19;
      case 2:
        if ( (unsigned __int8)(v15 - 49) <= 8u )
        {
LABEL_11:
          v56 = 3;
          goto LABEL_12;
        }
        if ( v15 == ***(_BYTE ***)(*(_DWORD *)a8 + 132) )
        {
LABEL_14:
          v57 = 5;
          goto LABEL_15;
        }
        if ( v15 != 48 )
          goto LABEL_36;
LABEL_19:
        v8 = 1;
        continue;
      case 3:
        v63 = 1;
        if ( v15 >= 48 )
        {
          v16 = v76;
          v17 = v71;
          do
          {
            if ( v15 > 57 )
              break;
            if ( v16 >= 0x19 )
            {
              ++v17;
            }
            else
            {
              ++v16;
              *v10++ = v15 - 48;
            }
            v15 = *(_BYTE *)v13++;
          }
          while ( v15 >= 48 );
          v71 = v17;
          v76 = v16;
          v11 = 0;
        }
        if ( v15 == ***(_BYTE ***)(*(_DWORD *)a8 + 132) )
        {
LABEL_24:
          v57 = 4;
        }
        else
        {
          if ( v15 == 43 || v15 == 45 )
          {
LABEL_32:
            --v13;
            v57 = 11;
          }
          else
          {
LABEL_28:
            if ( v15 <= 67 || v15 > 69 && (unsigned __int8)(v15 - 100) > 1u )
            {
LABEL_103:
              --v13;
              goto LABEL_104;
            }
LABEL_31:
            v57 = 6;
          }
        }
        goto LABEL_15;
      case 4:
        v63 = 1;
        v69 = 1;
        v18 = v76;
        if ( v76 )
          goto LABEL_54;
        v20 = __SETO__(v15, 48);
        v19 = (char)(v15 - 48) < 0;
        if ( v15 == 48 )
        {
          v21 = v71;
          do
          {
            v15 = *(_BYTE *)v13;
            --v21;
            ++v13;
          }
          while ( v15 == 48 );
          v71 = v21;
          v18 = v76;
LABEL_54:
          v20 = __SETO__(v15, 48);
          v19 = (char)(v15 - 48) < 0;
        }
        if ( !(v19 ^ v20) )
        {
          v22 = v71;
          do
          {
            if ( v15 > 57 )
              break;
            if ( (unsigned int)v18 < 0x19 )
            {
              ++v18;
              *v10++ = v15 - 48;
              --v22;
            }
            v15 = *(_BYTE *)v13++;
          }
          while ( v15 >= 48 );
          v71 = v22;
          v76 = v18;
          v11 = 0;
        }
        if ( v15 == 43 || v15 == 45 )
          goto LABEL_32;
        if ( v15 > 67 && (v15 <= 69 || (unsigned __int8)(v15 - 100) <= 1u) )
          goto LABEL_31;
        --v13;
        goto LABEL_105;
      case 5:
        v69 = 1;
        if ( (unsigned __int8)(v15 - 48) > 9u )
          goto LABEL_36;
        v56 = 4;
        goto LABEL_12;
      case 6:
        v73 = v13 - 2;
        if ( (unsigned __int8)(v15 - 49) <= 8u )
          goto LABEL_71;
        if ( v15 == 43 )
          goto LABEL_78;
        if ( v15 != 45 )
        {
          v23 = v15 == 48;
          goto LABEL_75;
        }
        v8 = 7;
        v65 = -1;
        continue;
      case 8:
        v67 = 1;
        while ( v15 == 48 )
          v15 = *(_BYTE *)v13++;
        if ( (unsigned __int8)(v15 - 49) <= 8u )
          goto LABEL_71;
        goto LABEL_103;
      case 7:
        if ( (unsigned __int8)(v15 - 49) <= 8u )
        {
LABEL_71:
          v56 = 9;
LABEL_12:
          v8 = v56;
          --v13;
          continue;
        }
        v23 = v15 == 48;
LABEL_75:
        if ( !v23 )
          goto LABEL_36;
        v57 = 8;
        goto LABEL_15;
      case 11:
        if ( !a7 )
        {
          v8 = 10;
          --v13;
LABEL_91:
          if ( v8 == 10 )
            goto LABEL_104;
          continue;
        }
        v73 = v13 - 1;
        if ( v15 == 43 )
        {
LABEL_78:
          v57 = 7;
LABEL_15:
          v8 = v57;
          continue;
        }
        if ( v15 == 45 )
        {
          v65 = -1;
          v8 = 7;
          continue;
        }
LABEL_36:
        v13 = v73;
LABEL_104:
        v18 = v76;
LABEL_105:
        *(_DWORD *)a2 = v13;
        if ( !v63 )
        {
          LOWORD(v52) = 0;
          v55 = 0;
          v58 = 4;
          goto LABEL_191;
        }
        if ( (unsigned int)v18 <= 0x18 )
        {
          v24 = v71;
        }
        else
        {
          if ( v88 >= 5 )
            ++v88;
          --v10;
          v24 = v71 + 1;
          v18 = 24;
          ++v71;
        }
        if ( !v18 )
        {
          v54 = 0;
          LOWORD(v52) = 0;
          v55 = 0;
          v53 = 0;
          goto LABEL_192;
        }
        v25 = (int)(v10 - 1);
        if ( !*(_BYTE *)v25 )
        {
          do
          {
            --v18;
            ++v24;
            --v25;
          }
          while ( !*(_BYTE *)v25 );
          v71 = v24;
        }
        sub_10058792((unsigned int *)&v87, v18, (int)&v80);
        if ( v65 < 0 )
          v11 = -v11;
        v26 = v71 + v11;
        if ( !v67 )
          v26 += a5;
        if ( !v69 )
          v26 -= a6;
        if ( v26 > 5200 )
        {
          LOWORD(v52) = 32767;
          v55 = -2147483648;
          v58 = 2;
LABEL_191:
          v54 = 0;
          v53 = 0;
          v9 = v58;
          goto LABEL_192;
        }
        if ( v26 < -5200 )
        {
          v54 = 0;
          LOWORD(v52) = 0;
          v55 = 0;
          v53 = 0;
          v9 = 1;
        }
        else
        {
          v27 = (char *)&unk_10074678 - 96;
          if ( v26 )
          {
            if ( v26 < 0 )
            {
              v26 = -v26;
              v27 = (char *)&unk_100747D8 - 96;
            }
            if ( !a4 )
              LOWORD(v80) = 0;
            do
            {
LABEL_185:
              if ( !v26 )
                goto LABEL_186;
              v28 = v26;
              v27 += 84;
              v26 >>= 3;
              v77 = v27;
              v72 = v26;
              v29 = v28 & 7;
            }
            while ( !v29 );
            v30 = (int)&v27[12 * v29];
            v74 = (__int64 *)v30;
            if ( *(_WORD *)v30 >= 0x8000u )
            {
              v78 = *(_QWORD *)v30;
              v31 = v30 + 8;
              v30 = (int)&v78;
              v79 = *(_DWORD *)v31;
              --*(_DWORD *)((char *)&v78 + 2);
              v74 = &v78;
            }
            v66 = (v83 ^ *(_WORD *)(v30 + 10)) & 0x8000;
            v32 = *(_WORD *)(v30 + 10) & 0x7FFF;
            v33 = (unsigned __int16)(v32 + (v83 & 0x7FFF));
            *(_DWORD *)((char *)&v84 + 2) = v9;
            *(_DWORD *)((char *)&v84 + 6) = v9;
            v86 = v9;
            v68 = (unsigned __int16)(v32 + (v83 & 0x7FFF));
            if ( (v83 & 0x7FFFu) >= 0x7FFF || v32 >= 0x7FFFu || (_WORD)v33 > 0xBFFDu )
              goto LABEL_182;
            if ( (_WORD)v33 <= 0x3FBFu )
              goto LABEL_135;
            if ( !(v83 & 0x7FFF) )
            {
              ++v33;
              v68 = v33;
              if ( !(v82 & 0x7FFFFFFF) )
              {
                if ( !v81 && !v80 )
                {
                  LOWORD(v83) = 0;
LABEL_184:
                  v27 = v77;
                  v26 = v72;
                  goto LABEL_185;
                }
              }
            }
            if ( v32
              || (v68 = v33 + 1, *(_DWORD *)(v30 + 8) & 0x7FFFFFFF)
              || *(_DWORD *)(v30 + 4) != v9
              || *(_DWORD *)v30 != v9 )
            {
              v34 = v9;
              v36 = 5;
              v59 = v9;
              v35 = (char *)&v84 + 6;
              v61 = 5;
              do
              {
                if ( v36 > 0 )
                {
                  v39 = (char *)&v80 + 2 * v34;
                  v37 = v30 + 8;
                  v64 = v30 + 8;
                  v38 = v36;
                  do
                  {
                    v41 = *(_WORD *)v39 * *(_WORD *)v37;
                    v70 = v41;
                    v40 = *((_DWORD *)v35 - 1) + v41;
                    if ( (unsigned int)v40 >= *((_DWORD *)v35 - 1) && v40 >= (unsigned int)v70 )
                      v42 = v9;
                    else
                      v42 = 1;
                    *((_DWORD *)v35 - 1) = v40;
                    if ( v42 )
                      ++*(_WORD *)v35;
                    v37 = v64 - 2;
                    v39 += 2;
                    --v38;
                    v64 -= 2;
                  }
                  while ( v38 > 0 );
                  v30 = (int)v74;
                  v36 = v61;
                  v34 = v59;
                }
                v35 += 2;
                ++v34;
                --v36;
                v59 = v34;
                v61 = v36;
              }
              while ( v36 > 0 );
              v43 = v86;
              v44 = *(_DWORD *)((char *)&v84 + 2);
              v45 = v68 + 49154;
              v75 = v86;
              if ( (signed __int16)(v68 - 16382) > 0 )
              {
                do
                {
                  if ( v43 < 0 )
                    break;
                  v46 = *(_DWORD *)((char *)&v84 + 6);
                  *(_DWORD *)((char *)&v84 + 6) = ((unsigned int)v44 >> 31) | 2 * *(_DWORD *)((char *)&v84 + 6);
                  v43 = (v46 >> 31) | 2 * v75;
                  v44 *= 2;
                  v45 += 65535;
                  *(_DWORD *)((char *)&v84 + 2) = v44;
                  v75 = v43;
                  v86 = v43;
                }
                while ( (_WORD)v45 > 0 );
                if ( (_WORD)v45 > 0 )
                  goto LABEL_195;
              }
              v45 += 65535;
              if ( (_WORD)v45 >= 0 )
                goto LABEL_195;
              v62 = (unsigned __int16)-(_WORD)v45;
              v45 += v62;
              do
              {
                if ( BYTE2(v84) & 1 )
                  ++v9;
                v47 = (v43 << 31) | (*(_DWORD *)((char *)&v84 + 6) >> 1);
                v43 = (unsigned int)v43 >> 1;
                v44 = (*(_DWORD *)((char *)&v84 + 6) << 31) | ((unsigned int)v44 >> 1);
                v48 = v62-- == 1;
                v86 = v43;
                *(_DWORD *)((char *)&v84 + 6) = v47;
                *(_DWORD *)((char *)&v84 + 2) = v44;
              }
              while ( !v48 );
              v49 = v9 == 0;
              v75 = v43;
              v9 = 0;
              if ( v49 )
              {
LABEL_195:
                v50 = WORD1(v84);
              }
              else
              {
                v50 = v44 | 1;
                WORD1(v84) = v44 | 1;
                v44 = *(_DWORD *)((char *)&v84 + 2);
              }
              if ( v50 > 0x8000u || (v44 & 0x1FFFF) == 98304 )
              {
                if ( HIDWORD(v84) == -1 )
                {
                  HIDWORD(v84) = v9;
                  if ( v85 == -1 )
                  {
                    v85 = v9;
                    if ( HIWORD(v86) == -1 )
                    {
                      HIWORD(v86) = -32768;
                      ++v45;
                    }
                    else
                    {
                      v86 += 65536;
                    }
                  }
                  else
                  {
                    *(__int64 *)((char *)&v84 + 4) += 4294967296i64;
                  }
                  v51 = v86;
                  goto LABEL_180;
                }
                v84 += 4294967296i64;
              }
              v51 = v75;
LABEL_180:
              if ( (_WORD)v45 < 0x7FFFu )
              {
                LOWORD(v80) = WORD2(v84);
                *(int *)((char *)&v80 + 2) = *(_DWORD *)((char *)&v84 + 6);
                *(int *)((char *)&v81 + 2) = v51;
                LOWORD(v83) = v66 | v45;
                goto LABEL_184;
              }
LABEL_182:
              v82 = (((v66 == 0) - 1) & 0x80000000) + 2147450880;
            }
            else
            {
LABEL_135:
              v82 = v9;
            }
            v80 = v9;
            v81 = v9;
            goto LABEL_184;
          }
LABEL_186:
          v54 = v80;
          v53 = *(int *)((char *)&v80 + 2);
          v55 = *(int *)((char *)&v81 + 2);
          v52 = v82 >> 16;
        }
LABEL_192:
        *(_WORD *)a1 = v54;
        *(_WORD *)(a1 + 10) = v60 | v52;
        *(_DWORD *)(a1 + 2) = v53;
        *(_DWORD *)(a1 + 6) = v55;
        return v9;
      default:
        goto LABEL_91;
      case 9:
        v67 = 1;
        v11 = 0;
        while ( 2 )
        {
          if ( v15 >= 48 && v15 <= 57 )
          {
            v11 = v15 + 10 * v11 - 48;
            if ( v11 <= 5200 )
            {
              v15 = *(_BYTE *)v13++;
              continue;
            }
            v11 = 5201;
          }
          break;
        }
        while ( v15 >= 48 && v15 <= 57 )
          v15 = *(_BYTE *)v13++;
        goto LABEL_103;
    }
  }
}
// 10073200: using guessed type int __security_cookie;

//----- (10056B0F) --------------------------------------------------------
signed int __cdecl sub_10056B0F(__int64 a1, __int16 a2, int a3, char a4, int a5)
{
  __int16 v5; // dx@1
  unsigned __int16 v6; // si@1
  signed int result; // eax@6
  char v8; // zf@25
  char *v9; // eax@25
  int v10; // ecx@25
  int v11; // ebx@25
  int v12; // ecx@25
  int v13; // edx@29
  int v14; // esi@29
  int v15; // ecx@30
  int v16; // ecx@31
  int v17; // esi@32
  int v18; // edi@33
  unsigned __int16 v19; // di@33
  int v20; // eax@47
  char *v21; // edx@47
  signed int v22; // esi@47
  int v23; // eax@49
  signed int v24; // ecx@49
  int v25; // esi@49
  int v26; // eax@50
  int v27; // edi@50
  unsigned int v28; // eax@50
  char v29; // cf@50
  signed int v30; // esi@52
  int v31; // eax@59
  int v32; // edi@59
  int v33; // esi@59
  unsigned int v34; // eax@61
  unsigned int v35; // ebx@64
  int v36; // edi@64
  int v37; // eax@64
  int v38; // eax@67
  char v39; // zf@67
  char v40; // zf@68
  unsigned __int16 v41; // ax@69
  int v42; // ecx@79
  int v43; // eax@91
  int v44; // edi@92
  signed int v45; // eax@106
  int v46; // edx@106
  char *v47; // ecx@106
  signed int v48; // esi@107
  int v49; // eax@108
  int v50; // edi@108
  int v51; // edx@109
  int v52; // edi@109
  unsigned int v53; // eax@109
  signed int v54; // eax@111
  int v55; // edi@118
  int v56; // esi@118
  unsigned int v57; // ebx@119
  unsigned int v58; // eax@121
  int v59; // edx@122
  unsigned __int16 v60; // cx@123
  int v61; // edi@132
  int v62; // eax@132
  int v63; // ebx@135
  char v64; // zf@135
  char v65; // zf@136
  int v66; // ecx@146
  int v67; // edi@146
  int v68; // ebx@153
  signed int v69; // edi@153
  unsigned int v70; // eax@154
  int v71; // edi@156
  unsigned int v72; // ebx@157
  unsigned int v73; // eax@158
  int v74; // ecx@160
  int v75; // edi@160
  int v76; // esi@160
  unsigned int v77; // edx@161
  unsigned int v78; // ecx@161
  int v79; // esi@161
  int v80; // esi@161
  int v81; // ecx@161
  signed int v82; // ecx@163
  char v83; // zf@166
  unsigned int v84; // edi@168
  char v85; // al@174
  int v86; // ecx@174
  char v87; // cl@182
  int v88; // [sp-4h] [bp-98h]@11
  int v89; // [sp-4h] [bp-98h]@15
  int *v90; // [sp+Ch] [bp-88h]@31
  int v91; // [sp+10h] [bp-84h]@49
  int v92; // [sp+14h] [bp-80h]@47
  int v93; // [sp+18h] [bp-7Ch]@92
  __int16 v94; // [sp+1Ch] [bp-78h]@1
  int v95; // [sp+20h] [bp-74h]@33
  unsigned __int16 v96; // [sp+20h] [bp-74h]@92
  int *v97; // [sp+28h] [bp-6Ch]@108
  int v98; // [sp+2Ch] [bp-68h]@153
  __int16 v99; // [sp+30h] [bp-64h]@33
  unsigned __int16 v100; // [sp+34h] [bp-60h]@33
  signed int v101; // [sp+34h] [bp-60h]@48
  signed int v102; // [sp+38h] [bp-5Ch]@25
  int v103; // [sp+38h] [bp-5Ch]@132
  int v104; // [sp+38h] [bp-5Ch]@160
  char *v105; // [sp+3Ch] [bp-58h]@108
  int v106; // [sp+3Ch] [bp-58h]@160
  char *v107; // [sp+40h] [bp-54h]@30
  __int16 v108; // [sp+40h] [bp-54h]@92
  signed int v109; // [sp+44h] [bp-50h]@47
  int v110; // [sp+44h] [bp-50h]@64
  int v111; // [sp+44h] [bp-50h]@106
  int v112; // [sp+48h] [bp-4Ch]@33
  int v113; // [sp+48h] [bp-4Ch]@64
  int v114; // [sp+48h] [bp-4Ch]@92
  int v115; // [sp+48h] [bp-4Ch]@132
  int v116; // [sp+4Ch] [bp-48h]@25
  signed int v117; // [sp+4Ch] [bp-48h]@147
  unsigned int v118; // [sp+4Ch] [bp-48h]@161
  signed int v119; // [sp+50h] [bp-44h]@25
  unsigned int v120; // [sp+50h] [bp-44h]@155
  int v121; // [sp+54h] [bp-40h]@29
  int v122; // [sp+54h] [bp-40h]@49
  int v123; // [sp+54h] [bp-40h]@59
  unsigned int v124; // [sp+54h] [bp-40h]@155
  int v125; // [sp+58h] [bp-3Ch]@32
  __int64 v126; // [sp+5Ch] [bp-38h]@32
  int v127; // [sp+64h] [bp-30h]@1
  int v128; // [sp+68h] [bp-2Ch]@1
  int v129; // [sp+6Ch] [bp-28h]@1
  _TBYTE v130; // [sp+74h] [bp-20h]@25
  __int16 v131; // [sp+7Eh] [bp-16h]@25
  __int64 v132; // [sp+82h] [bp-12h]@33
  int v133; // [sp+8Ah] [bp-Ah]@74
  int v134; // [sp+8Ch] [bp-8h]@33
  unsigned int v135; // [sp+90h] [bp-4h]@1
  int v136; // [sp+94h] [bp+0h]@1

  v135 = (unsigned int)&v136 ^ __security_cookie;
  v5 = a2 & 0x8000;
  v6 = a2 & 0x7FFF;
  v127 = -858993460;
  v128 = -858993460;
  v129 = 1073466572;
  v94 = a2 & 0x8000;
  if ( a2 & 0x8000 )
    *(_BYTE *)(a5 + 2) = 45;
  else
    *(_BYTE *)(a5 + 2) = 32;
  if ( v6 )
  {
    if ( v6 != 32767 )
      goto LABEL_25;
    *(_WORD *)a5 = 1;
    if ( (HIDWORD(a1) != -2147483648 || (_DWORD)a1) && !(HIDWORD(a1) & 0x40000000) )
    {
      v88 = (int)"1#SNAN";
      goto LABEL_22;
    }
    if ( v5 && HIDWORD(a1) == -1073741824 )
    {
      if ( !(_DWORD)a1 )
      {
        v89 = (int)"1#IND";
        goto LABEL_19;
      }
    }
    else
    {
      if ( HIDWORD(a1) == -2147483648 && !(_DWORD)a1 )
      {
        v89 = (int)"1#INF";
LABEL_19:
        if ( !sub_1003ADD5(a5, SHIDWORD(a1), a5 + 4, 22, v89) )
        {
          *(_BYTE *)(a5 + 3) = 5;
          return 0;
        }
LABEL_189:
        sub_1003A161(0, SHIDWORD(a1));
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_100574D3);
      }
    }
    v88 = (int)"1#QNAN";
LABEL_22:
    if ( !sub_1003ADD5(a5, SHIDWORD(a1), a5 + 4, 22, v88) )
    {
      *(_BYTE *)(a5 + 3) = 6;
      return 0;
    }
    goto LABEL_189;
  }
  if ( !a1 )
  {
    *(_WORD *)a5 = 0;
    *(_BYTE *)(a5 + 2) = (((v5 != -32768) - 1) & 0xD) + 32;
    *(_BYTE *)(a5 + 3) = 1;
    *(_WORD *)(a5 + 4) = 48;
    return 1;
  }
LABEL_25:
  v12 = (unsigned __int16)((signed int)(19728 * v6 - 323162868 + 77
                                                               * (((unsigned int)v6 >> 8) + 2 * (HIDWORD(a1) >> 24))) >> 16);
  *(_QWORD *)((char *)&v130 + 2) = a1;
  v116 = v12;
  LOWORD(v130) = 0;
  v10 = -(signed __int16)v12;
  v9 = (char *)&unk_10074678 - 96;
  v11 = 0;
  v131 = a2 & 0x7FFF;
  v119 = v10;
  v102 = 5;
  v8 = v10 == 0;
  if ( v10 )
  {
    if ( v10 < 0 )
    {
      v10 = -v10;
      v9 = (char *)&unk_100747D8 - 96;
      v119 = v10;
      v8 = v10 == 0;
    }
    if ( !v8 )
    {
      v14 = LODWORD(v130);
      v13 = DWORD1(v130);
      v121 = LODWORD(v130);
      while ( 1 )
      {
        v119 >>= 3;
        v9 += 84;
        v107 = v9;
        v15 = v10 & 7;
        if ( v15 )
          break;
LABEL_88:
        LOBYTE(v10) = v119;
        if ( !v119 )
          goto LABEL_91;
      }
      v16 = (int)&v9[12 * v15];
      v90 = (int *)v16;
      if ( *(_WORD *)v16 >= 0x8000u )
      {
        v125 = *(_DWORD *)v16;
        LODWORD(v126) = *(_DWORD *)(v16 + 4);
        v17 = v16 + 8;
        v16 = (int)&v125;
        HIDWORD(v126) = *(_DWORD *)v17;
        --*(int *)((char *)&v125 + 2);
        v90 = &v125;
      }
      v19 = *(_WORD *)(v16 + 10) & 0x7FFF;
      v99 = (v131 ^ *(_WORD *)(v16 + 10)) & 0x8000;
      v100 = v19;
      v18 = (unsigned __int16)(v19 + (v131 & 0x7FFF));
      v95 = v11;
      *(_DWORD *)((char *)&v132 + 2) = v11;
      *(_DWORD *)((char *)&v132 + 6) = v11;
      v134 = v11;
      v112 = v18;
      if ( (v131 & 0x7FFFu) >= 0x7FFF || (v14 = v121, v100 >= 0x7FFFu) || (_WORD)v18 > 0xBFFDu )
      {
LABEL_84:
        *((_DWORD *)&v130 + 2) = (((v99 == 0) - 1) & 0x80000000) + 2147450880;
        goto LABEL_85;
      }
      if ( (_WORD)v18 <= 0x3FBFu )
        goto LABEL_193;
      if ( !(v131 & 0x7FFF) )
      {
        ++v18;
        v112 = v18;
        if ( !(*((_DWORD *)&v130 + 2) & 0x7FFFFFFF) )
        {
          if ( !v13 && !v121 )
          {
            v131 = 0;
LABEL_87:
            v9 = v107;
            goto LABEL_88;
          }
        }
      }
      if ( !v100 )
      {
        v112 = v18 + 1;
        if ( !(*(_DWORD *)(v16 + 8) & 0x7FFFFFFF) )
        {
          if ( *(_DWORD *)(v16 + 4) == v11 && *(_DWORD *)v16 == v11 )
          {
LABEL_193:
            *((_DWORD *)&v130 + 2) = v11;
LABEL_85:
            v14 = v11;
            v13 = v11;
            LODWORD(v130) = v11;
            DWORD1(v130) = v11;
            goto LABEL_86;
          }
        }
      }
      v20 = v11;
      v22 = 5;
      v92 = v11;
      v21 = (char *)&v132 + 6;
      v109 = 5;
      do
      {
        v101 = v22;
        if ( v22 > 0 )
        {
          v23 = (int)((char *)&v130 + 2 * v20);
          v25 = v16 + 8;
          v24 = v101;
          v122 = v23;
          v91 = v25;
          do
          {
            v27 = *(_WORD *)v25 * *(_WORD *)v23;
            v28 = *((_DWORD *)v21 - 1);
            v29 = v28 + v27 < v28;
            v26 = v28 + v27;
            if ( v29 || v26 < (unsigned int)v27 )
              v30 = 1;
            else
              v30 = v11;
            *((_DWORD *)v21 - 1) = v26;
            if ( v30 )
              ++*(_WORD *)v21;
            v23 = v122 + 2;
            v25 = v91 - 2;
            --v24;
            v122 += 2;
            v91 -= 2;
          }
          while ( v24 > 0 );
          v16 = (int)v90;
          v22 = v109;
          v20 = v92;
        }
        v21 += 2;
        ++v20;
        --v22;
        v92 = v20;
        v109 = v22;
      }
      while ( v22 > 0 );
      v31 = v134;
      v33 = *(_DWORD *)((char *)&v132 + 2);
      v32 = v112 + 49154;
      v123 = v134;
      if ( (signed __int16)(v112 - 16382) > 0 )
      {
        do
        {
          if ( v31 < 0 )
            break;
          v34 = *(_DWORD *)((char *)&v132 + 6);
          *(_DWORD *)((char *)&v132 + 6) = ((unsigned int)v33 >> 31) | 2 * *(_DWORD *)((char *)&v132 + 6);
          v31 = (v34 >> 31) | 2 * v123;
          v33 *= 2;
          v32 += 65535;
          *(_DWORD *)((char *)&v132 + 2) = v33;
          v123 = v31;
          v134 = v31;
        }
        while ( (_WORD)v32 > 0 );
        if ( (_WORD)v32 > 0 )
          goto LABEL_194;
      }
      v32 += 65535;
      if ( (_WORD)v32 >= 0 )
        goto LABEL_194;
      v35 = v123;
      v37 = (unsigned __int16)-(_WORD)v32;
      v113 = v37 + v32;
      v36 = v95;
      v110 = v37;
      do
      {
        if ( BYTE2(v132) & 1 )
          ++v36;
        v38 = (v35 << 31) | (*(_DWORD *)((char *)&v132 + 6) >> 1);
        v35 >>= 1;
        v33 = (*(_DWORD *)((char *)&v132 + 6) << 31) | ((unsigned int)v33 >> 1);
        v39 = v110-- == 1;
        v134 = v35;
        *(_DWORD *)((char *)&v132 + 6) = v38;
        *(_DWORD *)((char *)&v132 + 2) = v33;
      }
      while ( !v39 );
      v123 = v35;
      v40 = v36 == 0;
      v32 = v113;
      v11 = 0;
      if ( v40 )
      {
LABEL_194:
        v41 = WORD1(v132);
      }
      else
      {
        v41 = v33 | 1;
        WORD1(v132) = v33 | 1;
        v33 = *(_DWORD *)((char *)&v132 + 2);
      }
      if ( v41 > 0x8000u || (v33 & 0x1FFFF) == 98304 )
      {
        if ( HIDWORD(v132) == -1 )
        {
          HIDWORD(v132) = v11;
          if ( v133 == -1 )
          {
            v133 = v11;
            if ( HIWORD(v134) == -1 )
            {
              HIWORD(v134) = -32768;
              ++v32;
            }
            else
            {
              v134 += 65536;
            }
          }
          else
          {
            *(__int64 *)((char *)&v132 + 4) += 4294967296i64;
          }
          v42 = v134;
LABEL_82:
          if ( (_WORD)v32 < 0x7FFFu )
          {
            LOWORD(v130) = WORD2(v132);
            *(_DWORD *)((char *)&v130 + 2) = *(_DWORD *)((char *)&v132 + 6);
            v14 = LODWORD(v130);
            *(_DWORD *)((char *)&v130 + 6) = v42;
            v13 = DWORD1(v130);
            v131 = v99 | v32;
LABEL_86:
            v121 = v14;
            goto LABEL_87;
          }
          goto LABEL_84;
        }
        v132 += 4294967296i64;
      }
      v42 = v123;
      goto LABEL_82;
    }
  }
  v13 = DWORD1(v130);
  v14 = LODWORD(v130);
LABEL_91:
  v43 = *((_DWORD *)&v130 + 2) >> 16;
  if ( (unsigned __int16)(*((_DWORD *)&v130 + 2) >> 16) >= 0x3FFFu )
  {
    ++v116;
    v108 = (v43 ^ HIWORD(v129)) & 0x8000;
    v96 = HIWORD(v129) & 0x7FFF;
    v44 = (unsigned __int16)((v43 & 0x7FFF) + (HIWORD(v129) & 0x7FFF));
    v93 = v11;
    *(_DWORD *)((char *)&v132 + 2) = v11;
    *(_DWORD *)((char *)&v132 + 6) = v11;
    v134 = v11;
    v114 = (unsigned __int16)((v43 & 0x7FFF) + (HIWORD(v129) & 0x7FFF));
    if ( (v43 & 0x7FFFu) >= 0x7FFF || v96 >= 0x7FFFu || (_WORD)v44 > 0xBFFDu )
    {
LABEL_144:
      *((_DWORD *)&v130 + 2) = (((v108 == 0) - 1) & 0x80000000) + 2147450880;
      goto LABEL_145;
    }
    if ( (_WORD)v44 <= 0x3FBFu )
      goto LABEL_195;
    if ( !(v43 & 0x7FFF) )
    {
      ++v44;
      v114 = v44;
      if ( !(*((_DWORD *)&v130 + 2) & 0x7FFFFFFF) )
      {
        if ( !v13 && !v14 )
        {
          v131 = 0;
          goto LABEL_146;
        }
      }
    }
    if ( !v96 )
    {
      v114 = v44 + 1;
      if ( !(v129 & 0x7FFFFFFF) )
      {
        if ( !v128 && !v127 )
        {
LABEL_195:
          *((_DWORD *)&v130 + 2) = v11;
LABEL_145:
          v14 = v11;
          v13 = v11;
          goto LABEL_146;
        }
      }
    }
    v46 = v11;
    v111 = v11;
    v47 = (char *)&v132 + 6;
    v45 = 5;
    do
    {
      v48 = v45;
      if ( v45 > 0 )
      {
        v49 = (int)&v129;
        v50 = (int)((char *)&v130 + 2 * v46);
        v97 = &v129;
        v105 = (char *)&v130 + 2 * v46;
        do
        {
          v51 = *(_WORD *)v50 * *(_WORD *)v49;
          v53 = *((_DWORD *)v47 - 1);
          v52 = v53 + v51;
          if ( v53 + v51 >= v53 && v52 >= (unsigned int)v51 )
            v54 = v11;
          else
            v54 = 1;
          *((_DWORD *)v47 - 1) = v52;
          if ( v54 )
            ++*(_WORD *)v47;
          v50 = (int)(v105 + 2);
          v49 = (int)((char *)v97 - 2);
          --v48;
          v105 += 2;
          v97 = (int *)((char *)v97 - 2);
        }
        while ( v48 > 0 );
        v46 = v111;
        v45 = v102;
      }
      v47 += 2;
      ++v46;
      --v45;
      v111 = v46;
      v102 = v45;
    }
    while ( v45 > 0 );
    v56 = v134;
    v55 = v114 + 49154;
    if ( (signed __int16)(v114 - 16382) <= 0 )
    {
      v59 = *(_DWORD *)((char *)&v132 + 2);
    }
    else
    {
      v57 = *(_DWORD *)((char *)&v132 + 2);
      do
      {
        if ( v56 < 0 )
          break;
        v58 = *(_DWORD *)((char *)&v132 + 6);
        *(_DWORD *)((char *)&v132 + 6) = (v57 >> 31) | 2 * *(_DWORD *)((char *)&v132 + 6);
        v57 *= 2;
        v56 = (v58 >> 31) | 2 * v56;
        v55 += 65535;
        *(_DWORD *)((char *)&v132 + 2) = v57;
        v134 = v56;
      }
      while ( (_WORD)v55 > 0 );
      v59 = v57;
      v11 = 0;
      if ( (_WORD)v55 > 0 )
        goto LABEL_123;
    }
    v55 += 65535;
    if ( (_WORD)v55 < 0 )
    {
      v62 = (unsigned __int16)-(_WORD)v55;
      v115 = v62 + v55;
      v61 = v93;
      v103 = v62;
      do
      {
        if ( BYTE2(v132) & 1 )
          ++v61;
        v63 = (v56 << 31) | (*(_DWORD *)((char *)&v132 + 6) >> 1);
        v59 = (*(_DWORD *)((char *)&v132 + 6) << 31) | ((unsigned int)v59 >> 1);
        v56 = (unsigned int)v56 >> 1;
        v64 = v103-- == 1;
        *(_DWORD *)((char *)&v132 + 6) = v63;
        *(_DWORD *)((char *)&v132 + 2) = v59;
      }
      while ( !v64 );
      v65 = v61 == 0;
      v55 = v115;
      v134 = v56;
      v11 = 0;
      if ( !v65 )
      {
        v60 = v59 | 1;
        WORD1(v132) = v59 | 1;
        v59 = *(_DWORD *)((char *)&v132 + 2);
        goto LABEL_124;
      }
    }
LABEL_123:
    v60 = WORD1(v132);
LABEL_124:
    if ( v60 > 0x8000u || (v59 & 0x1FFFF) == 98304 )
    {
      if ( HIDWORD(v132) == -1 )
      {
        HIDWORD(v132) = v11;
        if ( v133 == -1 )
        {
          v133 = v11;
          if ( HIWORD(v134) == -1 )
          {
            HIWORD(v134) = -32768;
            ++v55;
          }
          else
          {
            v134 += 65536;
          }
        }
        else
        {
          ++v133;
        }
        v56 = v134;
      }
      else
      {
        v132 += 4294967296i64;
      }
    }
    if ( (_WORD)v55 < 0x7FFFu )
    {
      LOWORD(v130) = WORD2(v132);
      *(_DWORD *)((char *)&v130 + 2) = *(_DWORD *)((char *)&v132 + 6);
      *(_DWORD *)((char *)&v130 + 6) = v56;
      v13 = DWORD1(v130);
      v14 = LODWORD(v130);
      v131 = v108 | v55;
      goto LABEL_146;
    }
    goto LABEL_144;
  }
LABEL_146:
  v66 = a5;
  v67 = a3;
  *(_WORD *)a5 = v116;
  if ( a4 & 1 )
  {
    v67 = (signed __int16)v116 + a3;
    v117 = v67;
    if ( v67 <= 0 )
    {
      *(_WORD *)a5 = 0;
      *(_BYTE *)(a5 + 2) = (((v94 != -32768) - 1) & 0xD) + 32;
      result = 1;
      *(_BYTE *)(a5 + 3) = 1;
      *(_BYTE *)(a5 + 4) = 48;
LABEL_149:
      *(_BYTE *)(v66 + 5) = v11;
      return result;
    }
  }
  else
  {
    v117 = a3;
  }
  if ( v67 > 21 )
    v117 = 21;
  v98 = (*((_DWORD *)&v130 + 2) >> 16) - 16382;
  v131 = 0;
  v68 = *((_DWORD *)&v130 + 2);
  v69 = 8;
  do
  {
    v70 = (unsigned int)v14 >> 31;
    v14 *= 2;
    v68 = ((unsigned int)v13 >> 31) | 2 * v68;
    v13 = v70 | 2 * v13;
    LODWORD(v130) = v14;
    *((_DWORD *)&v130 + 2) = v68;
    --v69;
  }
  while ( v69 );
  v120 = v68;
  DWORD1(v130) = v13;
  v124 = v14;
  v11 = 0;
  if ( v98 < 0 )
  {
    v71 = -v98 & 0xFF;
    if ( v71 > 0 )
    {
      v72 = v120;
      do
      {
        v73 = v72 << 31;
        v72 >>= 1;
        v14 = (v13 << 31) | ((unsigned int)v14 >> 1);
        v13 = v73 | ((unsigned int)v13 >> 1);
        --v71;
        *((_DWORD *)&v130 + 2) = v72;
        LODWORD(v130) = v14;
      }
      while ( v71 > 0 );
      v120 = v72;
      DWORD1(v130) = v13;
      v124 = v14;
      v11 = 0;
    }
  }
  v76 = a5;
  v75 = a5 + 4;
  v74 = a5 + 4;
  v104 = a5 + 4;
  v106 = v117 + 1;
  if ( v117 + 1 > 0 )
  {
    while ( 1 )
    {
      v125 = LODWORD(v130);
      v126 = *(_QWORD *)((char *)&v130 + 4);
      v80 = ((unsigned int)v13 >> 31) | 2 * v120;
      v81 = (v124 >> 31) | 2 * v13;
      v77 = (2 * v124 >> 31) | 2 * v81;
      v79 = ((unsigned int)v81 >> 31) | 2 * v80;
      v78 = LODWORD(v130) + 4 * v124;
      v118 = v78;
      if ( v78 < 4 * v124 || v78 < LODWORD(v130) )
      {
        v82 = v11;
        if ( v77 + 1 < v77 || v77 + 1 < 1 )
          v82 = 1;
        v83 = v82 == 0;
        v78 = v118;
        ++v77;
        if ( !v83 )
          ++v79;
      }
      v84 = v126 + v77;
      if ( (_DWORD)v126 + v77 < v77 || v84 < (_DWORD)v126 )
        ++v79;
      v124 = 2 * v118;
      LODWORD(v130) = 2 * v118;
      v13 = (v78 >> 31) | 2 * v84;
      *((_DWORD *)&v130 + 2) = (v84 >> 31) | 2 * (HIDWORD(v126) + v79);
      *(_BYTE *)v104 = (*((_DWORD *)&v130 + 2) >> 24) + 48;
      v74 = v104 + 1;
      DWORD1(v130) = v13;
      ++v104;
      HIBYTE(v131) = v11;
      --v106;
      if ( v106 <= 0 )
        break;
      v120 = *((_DWORD *)&v130 + 2);
    }
    v76 = a5;
    v75 = a5 + 4;
  }
  v85 = *(_BYTE *)(v74 - 1);
  v86 = v74 - 2;
  if ( v85 < 53 )
  {
    while ( v86 >= (unsigned int)v75 && *(_BYTE *)v86 == 48 )
      --v86;
    if ( v86 < (unsigned int)v75 )
    {
      v66 = a5;
      *(_WORD *)a5 = 0;
      *(_BYTE *)(a5 + 2) = (((v94 != -32768) - 1) & 0xD) + 32;
      result = 1;
      *(_BYTE *)(a5 + 3) = 1;
      *(_BYTE *)v75 = 48;
      goto LABEL_149;
    }
  }
  else
  {
    while ( v86 >= (unsigned int)v75 && *(_BYTE *)v86 == 57 )
      *(_BYTE *)v86-- = 48;
    if ( v86 < (unsigned int)v75 )
    {
      ++v86;
      ++*(_WORD *)v76;
    }
    ++*(_BYTE *)v86;
  }
  v87 = v86 - (_BYTE)a5 - 3;
  *(_BYTE *)(a5 + 3) = v87;
  *(_BYTE *)(v87 + a5 + 4) = v11;
  return 1;
}
// 10073200: using guessed type int __security_cookie;

//----- (100574D3) --------------------------------------------------------
signed int __cdecl sub_100574D3(int a1)
{
  signed int result; // eax@1
  int v2; // ecx@1
  int v3; // edx@13
  int v4; // ecx@20

  v2 = a1;
  result = 0;
  if ( a1 & 0x10 )
    result = 128;
  if ( a1 & 8 )
    result |= 0x200u;
  if ( a1 & 4 )
    result |= 0x400u;
  if ( a1 & 2 )
    result |= 0x800u;
  if ( a1 & 1 )
    result |= 0x1000u;
  if ( v2 & 0x80000 )
    result |= 0x100u;
  v3 = a1 & 0x300;
  if ( a1 & 0x300 )
  {
    switch ( v3 )
    {
      case 256:
        result |= 0x2000u;
        break;
      case 512:
        result |= 0x4000u;
        break;
      case 768:
        result |= 0x6000u;
        break;
    }
  }
  v4 = a1 & 0x3000000;
  if ( (a1 & 0x3000000) == 16777216 )
  {
    result |= 0x8040u;
  }
  else
  {
    if ( v4 == 33554432 )
    {
      result |= 0x40u;
    }
    else
    {
      if ( v4 == 50331648 )
        result |= 0x8000u;
    }
  }
  return result;
}

//----- (1005757C) --------------------------------------------------------
int __cdecl sub_1005757C(int a1, int a2)
{
  signed int v2; // ecx@1
  char v3; // ST1C_1@1
  char v4; // ST1C_1@3
  char v5; // ST1C_1@5
  char v6; // ST1C_1@7
  char v7; // ST1C_1@9
  char v8; // ST1C_1@11
  int v9; // edx@13
  __int16 v10; // ST1C_2@13
  __int16 v11; // ST1C_2@20
  __int16 v12; // ST1C_2@21
  signed int v13; // edx@24
  __int16 v14; // ST1C_2@24
  int v15; // esi@26
  __int16 v16; // ax@27
  int v17; // ecx@39
  signed int v18; // ecx@53
  int v19; // edx@65
  int v20; // eax@78
  int v21; // eax@79
  int v22; // edx@91
  int v23; // ecx@104
  int v24; // eax@104
  int result; // eax@106
  int v26; // [sp+0h] [bp-Ch]@53
  int v27; // [sp+18h] [bp+Ch]@79

  v2 = 0;
  if ( v3 & 1 )
    v2 = 16;
  if ( v4 & 4 )
    v2 |= 8u;
  if ( v5 & 8 )
    v2 |= 4u;
  if ( v6 & 0x10 )
    v2 |= 2u;
  if ( v7 & 0x20 )
    v2 |= 1u;
  if ( v8 & 2 )
    v2 |= 0x80000u;
  v9 = v10 & 0xC00;
  if ( v10 & 0xC00 )
  {
    switch ( v9 )
    {
      case 1024:
        v2 |= 0x100u;
        break;
      case 2048:
        v2 |= 0x200u;
        break;
      case 3072:
        v2 |= 0x300u;
        break;
    }
  }
  if ( v11 & 0x300 )
  {
    if ( (v12 & 0x300) == 512 )
      v2 |= 0x10000u;
  }
  else
  {
    v2 |= 0x20000u;
  }
  v13 = 4096;
  if ( v14 & 0x1000 )
    v2 |= 0x40000u;
  v15 = a2 & a1 | v2 & ~a2;
  if ( v15 != v2 )
  {
    v16 = sub_1005787C(a2 & a1 | v2 & ~a2);
    v15 = 0;
    if ( v16 & 1 )
      v15 = 16;
    if ( v16 & 4 )
      v15 |= 8u;
    if ( v16 & 8 )
      v15 |= 4u;
    if ( v16 & 0x10 )
      v15 |= 2u;
    if ( v16 & 0x20 )
      v15 |= 1u;
    if ( v16 & 2 )
      v15 |= 0x80000u;
    v17 = v16 & 0xC00;
    if ( v16 & 0xC00 )
    {
      switch ( v17 )
      {
        case 1024:
          v15 |= 0x100u;
          break;
        case 2048:
          v15 |= 0x200u;
          break;
        case 3072:
          v15 |= 0x300u;
          break;
      }
    }
    if ( v16 & 0x300 )
    {
      if ( (v16 & 0x300) == 512 )
        v15 |= 0x10000u;
    }
    else
    {
      v15 |= 0x20000u;
    }
    v13 = 4096;
    if ( v16 & 0x1000 )
      v15 |= 0x40000u;
  }
  if ( dword_1007577C < 1 )
  {
    result = v15;
  }
  else
  {
    __asm { stmxcsr [ebp+var_C] }
    v18 = 0;
    if ( (_BYTE)v26 < 0 )
      v18 = 16;
    if ( v26 & 0x200 )
      v18 |= 8u;
    if ( v26 & 0x400 )
      v18 |= 4u;
    if ( v26 & 0x800 )
      v18 |= 2u;
    if ( v26 & v13 )
      v18 |= 1u;
    if ( v26 & 0x100 )
      v18 |= 0x80000u;
    v19 = v26 & 0x6000;
    if ( v26 & 0x6000 )
    {
      switch ( v19 )
      {
        case 8192:
          v18 |= 0x100u;
          break;
        case 16384:
          v18 |= 0x200u;
          break;
        case 24576:
          v18 |= 0x300u;
          break;
      }
    }
    switch ( v26 & 0x8040 )
    {
      case 0x40:
        v18 |= 0x2000000u;
        break;
      case 0x8000:
        v18 |= 0x3000000u;
        break;
      case 0x8040:
        v18 |= 0x1000000u;
        break;
    }
    v20 = a1 & a2 & 0x308031F | v18 & ~(a2 & 0x308031F);
    if ( v20 != v18 )
    {
      v21 = sub_100574D3(v20);
      sub_10049F07(v21);
      __asm { stmxcsr [ebp+arg_4] }
      v18 = 0;
      if ( (_BYTE)v27 < 0 )
        v18 = 16;
      if ( v27 & 0x200 )
        v18 |= 8u;
      if ( v27 & 0x400 )
        v18 |= 4u;
      if ( v27 & 0x800 )
        v18 |= 2u;
      if ( v27 & 0x1000 )
        v18 |= 1u;
      if ( v27 & 0x100 )
        v18 |= 0x80000u;
      v22 = v27 & 0x6000;
      if ( v27 & 0x6000 )
      {
        switch ( v22 )
        {
          case 8192:
            v18 |= 0x100u;
            break;
          case 16384:
            v18 |= 0x200u;
            break;
          case 24576:
            v18 |= 0x300u;
            break;
        }
      }
      switch ( v27 & 0x8040 )
      {
        case 0x40:
          v18 |= 0x2000000u;
          break;
        case 0x8000:
          v18 |= 0x3000000u;
          break;
        case 0x8040:
          v18 |= 0x1000000u;
          break;
      }
    }
    v24 = v15 ^ v18;
    v23 = v15 | v18;
    if ( v24 & 0x8031F )
      v23 |= 0x80000000u;
    result = v23;
  }
  return result;
}
// 1007577C: using guessed type int dword_1007577C;

//----- (1005787C) --------------------------------------------------------
signed int __cdecl sub_1005787C(int a1)
{
  signed int result; // eax@1
  int v2; // ecx@1
  int v3; // edx@13
  int v4; // edx@20
  int v5; // edx@20

  v2 = a1;
  result = 0;
  if ( a1 & 0x10 )
    result = 1;
  if ( a1 & 8 )
    result |= 4u;
  if ( a1 & 4 )
    result |= 8u;
  if ( a1 & 2 )
    result |= 0x10u;
  if ( a1 & 1 )
    result |= 0x20u;
  if ( v2 & 0x80000 )
    result |= 2u;
  v3 = a1 & 0x300;
  if ( a1 & 0x300 )
  {
    switch ( v3 )
    {
      case 256:
        result |= 0x400u;
        break;
      case 512:
        result |= 0x800u;
        break;
      case 768:
        result |= 0xC00u;
        break;
    }
  }
  v5 = a1;
  v4 = v5 & 0x30000;
  if ( v4 )
  {
    if ( v4 == 65536 )
      result |= 0x200u;
  }
  else
  {
    result |= 0x300u;
  }
  if ( v2 & 0x40000 )
    result |= 0x1000u;
  return result;
}

//----- (10057913) --------------------------------------------------------
signed int __usercall sub_10057913<eax>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  int v5; // ebx@3
  int v6; // eax@4
  int v7; // edx@4
  int v8; // ecx@4
  int v9; // esi@4
  int v10; // ST10_4@4
  bool v11; // eax@6
  void *v12; // edi@6
  int v13; // ST10_4@7
  int v14; // eax@16
  int v15; // edx@16
  int v16; // eax@18
  int v17; // eax@21
  int v18; // edx@21
  unsigned int v19; // esi@21
  int v20; // edx@23
  int v21; // edi@24
  int v22; // eax@28
  const CHAR *v23; // esi@39
  int v24; // eax@39
  int v25; // ST0C_4@39
  int v26; // eax@40
  int v27; // ecx@41
  int v28; // [sp-Ch] [bp-1Ch]@16
  int v29; // [sp-Ch] [bp-1Ch]@21
  int v30; // [sp-Ch] [bp-1Ch]@23
  int v31; // [sp+4h] [bp-Ch]@4
  signed int v32; // [sp+8h] [bp-8h]@1
  bool v33; // [sp+Ch] [bp-4h]@6

  v32 = 0;
  if ( !a3 )
  {
    *(_DWORD *)sub_10037649(a1) = 22;
    sub_1003A151(a1, a2);
    return -1;
  }
  v5 = *(_DWORD *)a3;
  if ( !*(_DWORD *)a3 || (v6 = sub_100589C4(v5, a2, v5, 61), v9 = v6, v8 = v10, v31 = v6, !v6) || v5 == v6 )
    goto LABEL_12;
  v12 = dword_1007586C;
  v11 = *(_BYTE *)(v6 + 1) == 0;
  v33 = *(_BYTE *)(v9 + 1) == 0;
  if ( dword_1007586C == (LPVOID)dword_10075858 )
  {
    v12 = (void *)sub_10057B59(v5, (int *)dword_1007586C);
    v11 = v33;
    v8 = v13;
    dword_1007586C = v12;
  }
  if ( !v12 )
  {
    if ( a4 && dword_10075870 != v12 )
    {
      if ( sub_1005391E(v5) )
      {
LABEL_12:
        *(_DWORD *)sub_10037649(v5) = 22;
        return -1;
      }
    }
    else
    {
      if ( v11 )
        return 0;
      v14 = sub_10037530(v7, v8, v5, 4);
      dword_1007586C = (LPVOID)v14;
      if ( !v14 )
        return -1;
      *(_DWORD *)v14 = 0;
      if ( !dword_10075870 )
      {
        v16 = sub_10037530(v15, v28, v5, 4);
        dword_10075870 = (LPVOID)v16;
        if ( !v16 )
          return -1;
        *(_DWORD *)v16 = 0;
      }
    }
    v12 = dword_1007586C;
    if ( !dword_1007586C )
      return -1;
  }
  v17 = sub_10057BB9(v5, v5, v9 - v5);
  v19 = v17;
  if ( v17 < 0 || !*(_DWORD *)v12 )
  {
    if ( !v33 )
    {
      if ( v17 < 0 )
        v19 = -v17;
      if ( __SETO__(v19 + 2, v19)
        || v19 + 2 >= 0x3FFFFFFF
        || (v22 = sub_100375C5(v18, v29, v5, dword_1007586C, 4u, v19 + 2), !v22) )
        return -1;
      v21 = a3;
      *(_DWORD *)(v22 + 4 * v19 + 4) = 0;
      *(_DWORD *)(v22 + 4 * v19) = v5;
      *(_DWORD *)a3 = 0;
      goto LABEL_29;
    }
    sub_100309C2(v5, (LPVOID)v5);
    *(_DWORD *)a3 = 0;
    return 0;
  }
  sub_100309C2(v5, *((LPVOID *)v12 + v17));
  if ( !v33 )
  {
    *((_DWORD *)v12 + v19) = v5;
    v21 = a3;
    *(_DWORD *)a3 = 0;
    goto LABEL_38;
  }
  while ( *((_DWORD *)v12 + v19) )
  {
    *((_DWORD *)v12 + v19) = *((_DWORD *)v12 + v19 + 1);
    ++v19;
  }
  if ( v19 >= 0x3FFFFFFF )
  {
    v21 = a3;
    goto LABEL_38;
  }
  v22 = sub_100375C5(v20, v30, v5, dword_1007586C, v19, 4u);
  v21 = a3;
  if ( v22 )
LABEL_29:
    dword_1007586C = (LPVOID)v22;
LABEL_38:
  if ( a4 )
  {
    v24 = sub_10035530(v5);
    v23 = (const CHAR *)sub_100374E6(v25, v5, v24 + 2, 1u);
    if ( v23 )
    {
      v26 = sub_10035530(v5);
      if ( sub_1003ADD5(v5, v21, (int)v23, v26 + 2, v5) )
      {
        sub_1003A161(v5, v21);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_10057B59);
      }
      v27 = (int)(&v23[v31] - v5);
      *(_BYTE *)v27 = 0;
      if ( !SetEnvironmentVariableA(v23, (LPCSTR)(v33 == 0 ? v27 + 1 : 0)) )
      {
        v32 = -1;
        *(_DWORD *)sub_10037649(v5) = 42;
      }
      sub_100309C2(v5, (LPVOID)v23);
    }
  }
  if ( v33 )
  {
    sub_100309C2(v5, (LPVOID)v5);
    *(_DWORD *)v21 = 0;
  }
  return v32;
}
// 10075858: using guessed type int dword_10075858;

//----- (10057B59) --------------------------------------------------------
int __usercall sub_10057B59<eax>(int a1<ebx>, int *a2)
{
  int result; // eax@1
  int v3; // ecx@1
  int v4; // edx@4
  int v5; // ebx@4
  int v6; // edi@4
  int v7; // eax@6
  int v8; // esi@7
  int v9; // [sp-Ch] [bp-10h]@4

  v3 = 0;
  result = (int)a2;
  if ( a2 )
  {
    if ( *a2 )
    {
      do
      {
        result += 4;
        ++v3;
      }
      while ( *(_DWORD *)result );
    }
    v6 = (int)sub_100374E6(v3, a1, v3 + 1, 4u);
    v5 = v6;
    if ( !v6 )
      sub_1003AF82(v4, v9, v6, 0, 9);
    v7 = *a2;
    if ( *a2 )
    {
      v8 = (int)((char *)a2 - v6);
      do
      {
        *(_DWORD *)v6 = sub_10058974(v5, v7);
        v6 += 4;
        v7 = *(_DWORD *)(v8 + v6);
      }
      while ( v7 );
    }
    *(_DWORD *)v6 = 0;
    result = v5;
  }
  return result;
}

//----- (10057BB9) --------------------------------------------------------
int __usercall sub_10057BB9<eax>(int a1<ebx>, int a2, int a3)
{
  int v3; // eax@1
  LPVOID v4; // ecx@1
  LPVOID v5; // esi@1
  char v6; // al@3
  int v7; // esi@7

  v4 = dword_1007586C;
  v5 = dword_1007586C;
  v3 = *(_DWORD *)dword_1007586C;
  if ( *(_DWORD *)dword_1007586C )
  {
    while ( 1 )
    {
      if ( !sub_100539AB(a1, a3, a2, v3, a3) )
      {
        v6 = *(_BYTE *)(a3 + *(_DWORD *)v5);
        if ( v6 == 61 )
          break;
        if ( !v6 )
          break;
      }
      v5 = (char *)v5 + 4;
      v3 = *(_DWORD *)v5;
      if ( !*(_DWORD *)v5 )
      {
        v4 = dword_1007586C;
        goto LABEL_7;
      }
    }
    v7 = (signed int)(v5 - dword_1007586C) >> 2;
  }
  else
  {
LABEL_7:
    v7 = -((signed int)(v5 - v4) >> 2);
  }
  return v7;
}

//----- (10057C14) --------------------------------------------------------
signed int __usercall sub_10057C14<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5, int a6)
{
  signed int v6; // esi@2
  int v7; // ebx@8
  int v8; // eax@10
  int v10; // [sp+Ch] [bp-10h]@1
  int v11; // [sp+14h] [bp-8h]@14
  char v12; // [sp+18h] [bp-4h]@13

  sub_100301AD((int)&v10, a1, a2, a6);
  if ( a5 )
  {
    if ( a3 && a4 )
    {
      v6 = 2147483647;
      if ( (unsigned int)a5 <= 0x7FFFFFFF )
      {
        v7 = *(_DWORD *)(v10 + 164);
        if ( v7 )
        {
          v8 = sub_1003910C(v7, v10, (int)&v10, v7, 0x1001u, a3, a5, a4, a5, *(_DWORD *)(v10 + 8));
          if ( v8 )
            v6 = v8 - 2;
          else
            *(_DWORD *)sub_10037649(v7) = 22;
        }
        else
        {
          v6 = sub_10058A74(0, v10, a3, (unsigned __int8 *)a4, a5, (int)&v10);
        }
      }
      else
      {
        *(_DWORD *)sub_10037649(a1) = 22;
        sub_1003A151(a1, a2);
      }
    }
    else
    {
      *(_DWORD *)sub_10037649(a1) = 22;
      sub_1003A151(a1, a2);
      v6 = 2147483647;
    }
  }
  else
  {
    v6 = 0;
  }
  if ( v12 )
    *(_DWORD *)(v11 + 112) &= 0xFFFFFFFDu;
  return v6;
}

//----- (10057CD7) --------------------------------------------------------
int __cdecl sub_10057CD7()
{
  dword_10076894 = IsProcessorFeaturePresent(0xAu);
  return 0;
}
// 10076894: using guessed type int dword_10076894;

//----- (10057CF0) --------------------------------------------------------
void __usercall sub_10057CF0(int a1<ebx>, __int64 a2<st0>)
{
  double v2; // ST00_8@1

  v2 = *(double *)&a2;
  __asm { movq    xmm0, [esp+8+var_8] }
  sub_10057D0E(a1, a2);
}

//----- (10057D0E) --------------------------------------------------------
double __usercall sub_10057D0E<st0>(int a1<ebx>, __int64 a2)
{
  signed int v3; // eax@2
  double result; // st7@3
  int v7; // ecx@4
  signed int v8; // edx@4
  double v11; // ST0A_8@4
  double v12; // st7@4
  double v13; // st7@4
  double v14; // ST0A_8@4
  double v15; // ST0A_8@4
  signed int v17; // edx@7
  int v18; // eax@21
  _BYTE v19[14]; // [sp+Ah] [bp-12h]@3

  __asm
  {
    unpcklpd xmm0, xmm0
    movapd  xmm1, ds:xmmword_10066990
    movapd  xmm6, ds:xmmword_10066970
    movapd  xmm2, ds:xmmword_100669A0
    movapd  xmm3, ds:xmmword_100669B0
    pextrw  eax, xmm0, 3
  }
  if ( (((_EAX & 0x7FFF) - 15504) | (16527 - (_EAX & 0x7FFFu))) < 0x80000000 )
  {
    __asm
    {
      mulpd   xmm1, xmm0
      addpd   xmm1, xmm6
      movapd  xmm7, xmm1
      subpd   xmm1, xmm6
      mulpd   xmm2, xmm1
      movapd  xmm4, ds:xmmword_100669C0
      mulpd   xmm3, xmm1
      movapd  xmm5, ds:xmmword_100669D0
      subpd   xmm0, xmm2
      movd    eax, xmm7
    }
    _ECX = 16 * (_EAX & 0x3F);
    v3 = _EAX >> 6;
    __asm
    {
      subpd   xmm0, xmm3
      movapd  xmm2, ds:xmmword_100669E0[ecx]
      mulpd   xmm4, xmm0
      movapd  xmm1, xmm0
      mulpd   xmm0, xmm0
      addpd   xmm5, xmm4
      mulsd   xmm0, xmm0
      addsd   xmm1, xmm2
      unpckhpd xmm2, xmm2
      movdqa  xmm6, ds:xmmword_10066950
      pand    xmm7, xmm6
      movdqa  xmm6, ds:xmmword_10066960
      paddq   xmm7, xmm6
      psllq   xmm7, 2Eh
      mulpd   xmm0, xmm5
      addsd   xmm1, xmm0
      orpd    xmm2, xmm7
      unpckhpd xmm0, xmm0
      addsd   xmm0, xmm1
    }
    if ( (unsigned int)(v3 + 894) <= 0x77C )
    {
      __asm
      {
        mulsd   xmm0, xmm2
        addsd   xmm0, xmm2
        movlpd  [esp+10h+var_12+6], xmm0
      }
      return *(double *)&v19[6];
    }
    v8 = v3;
    _EAX = v3 >> 1;
    _EDX = v8 - _EAX;
    __asm
    {
      movdqa  xmm6, ds:xmmword_10066940
      pandn   xmm6, xmm2
    }
    _EAX += 1023;
    __asm
    {
      movd    xmm3, eax
      psllq   xmm3, 34h
      orpd    xmm6, xmm3
    }
    _EDX += 1023;
    __asm
    {
      movd    xmm4, edx
      psllq   xmm4, 34h
      movlpd  [esp+12h+var_12], xmm0
    }
    v12 = v11;
    __asm { movlpd  [esp+12h+var_A], xmm6 }
    v13 = v12 * *(double *)&v19[8] + *(double *)&v19[8];
    __asm { movlpd  [esp+12h+var_12], xmm4 }
    v15 = v13 * v14;
    __asm
    {
      movlpd  xmm0, [esp+12h+var_12]
      pextrw  ecx, xmm0, 3
    }
    v7 = _ECX & 0x7FF0;
    if ( (unsigned int)v7 >= 0x7FF0 )
    {
      v17 = 14;
    }
    else
    {
      if ( v7 )
        goto LABEL_10;
      v17 = 15;
    }
LABEL_9:
    __asm { movlpd  [esp+1Ch+var_12+6], xmm0 }
    sub_10058B23(a1, (int)&a2, (int)&a2, (int)&v19[6], v17);
    __asm { movlpd  xmm0, [esp+1Ch+var_12+6] }
LABEL_10:
    __asm { movlpd  [esp+10h+var_12+6], xmm0 }
    return *(double *)&v19[6];
  }
  v18 = HIDWORD(a2) & 0x7FFFFFFF;
  if ( (HIDWORD(a2) & 0x7FFFFFFFu) >= 0x40900000 )
  {
    if ( (unsigned int)v18 < 0x7FF00000 )
    {
      if ( HIDWORD(a2) >= 0x80000000u )
      {
        __asm
        {
          movlpd  xmm0, ds:qword_10066E18
          mulsd   xmm0, xmm0
        }
        v17 = 15;
      }
      else
      {
        __asm
        {
          movlpd  xmm0, ds:qword_10066E10
          mulsd   xmm0, xmm0
        }
        v17 = 14;
      }
      goto LABEL_9;
    }
    if ( (unsigned int)v18 > 0x7FF00000 || (_DWORD)a2 )
    {
      v17 = 1002;
      goto LABEL_9;
    }
    if ( HIDWORD(a2) == 2146435072 )
      result = 1.797693134862316e308;
    else
      result = 0.0;
  }
  else
  {
    __asm
    {
      movlpd  xmm0, [esp+arg_0]
      addsd   xmm0, ds:qword_10066DE0
      movlpd  [esp+10h+var_12+6], xmm0
    }
    result = *(double *)&v19[6];
  }
  return result;
}

//----- (10057FC1) --------------------------------------------------------
double __usercall sub_10057FC1<st0>(int a1<ebp>, double result<st0>)
{
  char v2; // ch@1

  *(_BYTE *)(a1 - 144) = -2;
  sub_100580FE();
  if ( v2 )
    result = -result;
  return result;
}
// 100580FE: using guessed type int sub_100580FE(void);

//----- (100580F1) --------------------------------------------------------
double __fastcall sub_100580F1(char a1)
{
  if ( a1 )
    JUMPOUT(*(unsigned int *)loc_1004AD86);
  return 1.189731495357232e4932;
}
// 1004AD86: using guessed type int loc_1004AD86();

//----- (100580FE) --------------------------------------------------------
#error "FFFFFFFF: positive sp value has been found (funcsize=0)"

//----- (10058141) --------------------------------------------------------
double __usercall sub_10058141<st0>(double result<st0>)
{
  double v3; // st6@2

  _ST6 = result;
  __asm { frndint }
  if ( _ST6 == result )
  {
    v3 = result * 0.5;
    _ST5 = result * 0.5;
    __asm { frndint }
    _ST5 == v3;
  }
  return result;
}

//----- (100581EE) --------------------------------------------------------
void __usercall sub_100581EE(int a1<edx>, __int16 a2<cx>, __int16 a3<fpstat>, double a4<st0>, char a5, char a6, char a7)
{
  int ebp0; // ebp@0
  char v8; // ST00_1@2
  char v9; // ST04_1@2
  char v10; // ST08_1@2

  if ( !dword_10074480 )
    UNDEF(a3);
  sub_1004AC80(a1, a2, ebp0, a3, a4, v8, v9, v10);
  sub_10058273(ebp0, a4);
}
// 10074480: using guessed type int dword_10074480;

//----- (10058273) --------------------------------------------------------
double __usercall sub_10058273<st0>(int a1<ebp>, double result<st0>)
{
  char v2; // al@2
  __int16 v3; // fps@2
  __int16 v7; // ax@11
  int v8; // ebx@20

  if ( dword_10075774 )
    return result;
  UNDEF(v3);
  *(_QWORD *)(a1 - 720) = *(_QWORD *)&result;
  v2 = *(_BYTE *)(a1 - 144);
  if ( v2 )
  {
    if ( v2 == -1 )
    {
      if ( (*(_WORD *)(a1 - 714) & 0x7FF0) != 32752 )
        goto LABEL_7;
    }
    else
    {
      if ( v2 != -2 )
      {
        if ( !v2 )
          return result;
        *(_DWORD *)(a1 - 142) = v2;
        goto LABEL_20;
      }
      v7 = *(_WORD *)(a1 - 714) & 0x7FF0;
      if ( !v7 )
      {
        *(_DWORD *)(a1 - 142) = 4;
        if ( fabs(result) < 2.225073858507201e-308 )
          result = result * 0.0;
        goto LABEL_20;
      }
      if ( v7 != 32752 )
        goto LABEL_7;
    }
    *(_DWORD *)(a1 - 142) = 3;
    if ( fabs(result) > 1.797693134862316e308 )
      result = result * 1.797693134862316e308;
    goto LABEL_20;
  }
LABEL_7:
  if ( !(*(_WORD *)(a1 - 164) & 0x20) && v3 & 0x20 )
  {
    *(_DWORD *)(a1 - 142) = 8;
LABEL_20:
    v8 = *(_DWORD *)(a1 - 148) + 1;
    *(_DWORD *)(a1 - 138) = v8;
    if ( !(*(_BYTE *)(a1 - 712) & 1) )
    {
      *(_DWORD *)(a1 - 134) = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 - 134 + 4) = *(_DWORD *)(a1 + 12);
      if ( *(_BYTE *)(v8 + 12) != 1 )
      {
        *(_DWORD *)(a1 - 126) = *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 - 126 + 4) = *(_DWORD *)(a1 + 20);
      }
    }
    *(_QWORD *)(a1 - 118) = *(_QWORD *)&result;
    sub_100535C7(a1, *(_BYTE *)(*(_DWORD *)(a1 - 148) + 14), a1 - 142, a1 - 164);
    result = *(double *)(a1 - 118);
  }
  return result;
}
// 10075774: using guessed type int dword_10075774;

//----- (100583BA) --------------------------------------------------------
int __usercall sub_100583BA<eax>(__int16 a1<fpstat>, char a2, char a3, char a4, double a5)
{
  int ebp0; // ebp@0
  double v7; // st7@1
  int v8; // edx@1
  __int16 v9; // cx@1
  char v10; // ST08_1@1
  char v11; // ST0C_1@1
  char v12; // ST10_1@1

  v7 = sub_100583ED(a5);
  sub_1004AC80(v8, v9, ebp0, a1, v7, v10, v11, v12);
  return sub_1005826C();
}
// 1005826C: using guessed type int sub_1005826C(void);

//----- (100583ED) --------------------------------------------------------
double __cdecl sub_100583ED(double a1)
{
  double result; // st7@2
  double v2; // ST06_8@2

  if ( (WORD3(a1) & 0x7FF0) == 32752 )
  {
    HIDWORD(v2) = *(_QWORD *)&a1 << 11 >> 32;
    LODWORD(v2) = LODWORD(a1);
    result = v2;
  }
  else
  {
    result = a1;
  }
  return result;
}

//----- (10058429) --------------------------------------------------------
BOOL __cdecl sub_10058429()
{
  BOOL result; // eax@1

  result = (BOOL)hConsoleOutput;
  if ( hConsoleOutput != (HANDLE)-1 )
  {
    if ( hConsoleOutput != (HANDLE)-2 )
      result = CloseHandle(hConsoleOutput);
  }
  return result;
}

//----- (10058440) --------------------------------------------------------
HANDLE __cdecl sub_10058440()
{
  HANDLE result; // eax@1

  result = CreateFileW(L"CONOUT$", 0x40000000u, 3u, 0, 3u, 0, 0);
  hConsoleOutput = result;
  return result;
}

//----- (1005845F) --------------------------------------------------------
void __usercall sub_1005845F(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>, int a5)
{
  if ( a5 == -2 )
  {
    *(_DWORD *)sub_10037615(a3) = 0;
    *(_DWORD *)sub_10037649(a3) = 9;
  }
  else
  {
    if ( a5 >= 0
      && a5 < (unsigned int)dword_10076898
      && (a3 = a5 >> 5, a4 = (a5 & 0x1F) << 6, *(_BYTE *)(dword_10075F80[a5 >> 5] + a4 + 4) & 1) )
    {
      sub_100553FC(a1, a2, a3, a5);
      if ( *(_BYTE *)(dword_10075F80[a3] + a4 + 4) & 1 )
        sub_10058529(a3, a5);
      else
        *(_DWORD *)sub_10037649(a3) = 9;
      sub_10055575(a5);
    }
    else
    {
      *(_DWORD *)sub_10037615(a3) = 0;
      *(_DWORD *)sub_10037649(a3) = 9;
      sub_1003A151(a3, a4);
    }
  }
}
// 10075F80: using guessed type int dword_10075F80[];
// 10076898: using guessed type int dword_10076898;

//----- (10058529) --------------------------------------------------------
signed int __usercall sub_10058529<eax>(int a1<ebx>, int a2)
{
  signed int v2; // esi@6
  void *v3; // eax@7
  int v4; // esi@8
  signed int result; // eax@11

  if ( sub_1005550E(a1, a2, a2) == -1
    || (a2 == 1 && *(_BYTE *)(dword_10075F80[0] + 132) & 1 || a2 == 2 && *(_BYTE *)(dword_10075F80[0] + 68) & 1)
    && (v2 = sub_1005550E(a1, a2, 2), sub_1005550E(a1, a2, 1) == v2)
    || (v3 = (void *)sub_1005550E(a1, a2, a2), CloseHandle(v3)) )
    v4 = 0;
  else
    v4 = GetLastError();
  sub_10055488(a1, a2);
  *(_BYTE *)(dword_10075F80[a2 >> 5] + ((a2 & 0x1F) << 6) + 4) = 0;
  if ( v4 )
  {
    sub_10037628(a1, v4);
    result = -1;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 10075F80: using guessed type int dword_10075F80[];

//----- (100585C3) --------------------------------------------------------
int __usercall sub_100585C3<eax>(int a1<ebx>, int a2)
{
  int result; // eax@3

  if ( *(_BYTE *)(a2 + 12) & 0x83 )
  {
    if ( *(_BYTE *)(a2 + 12) & 8 )
    {
      sub_100309C2(a1, *(LPVOID *)(a2 + 8));
      *(_DWORD *)(a2 + 12) &= 0xFFFFFBF7u;
      result = 0;
      *(_DWORD *)a2 = 0;
      *(_DWORD *)(a2 + 8) = 0;
      *(_DWORD *)(a2 + 4) = 0;
    }
  }
  return result;
}

//----- (100585F3) --------------------------------------------------------
int __cdecl sub_100585F3(unsigned __int16 a1)
{
  signed int v2; // edx@4
  unsigned __int16 v3; // cx@37

  if ( a1 < 0x30u )
    return -1;
  if ( a1 < 0x3Au )
    return a1 - 48;
  v2 = 65296;
  if ( a1 >= 0xFF10u )
  {
    v3 = -230;
LABEL_39:
    if ( a1 < v3 )
      return a1 - v2;
    return -1;
  }
  v2 = 1632;
  if ( a1 >= 0x660u )
  {
    if ( a1 < 0x66Au )
      return a1 - v2;
    v2 = 1776;
    if ( a1 >= 0x6F0u )
    {
      if ( a1 < 0x6FAu )
        return a1 - v2;
      v2 = 2406;
      if ( a1 >= 0x966u )
      {
        if ( a1 < 0x970u )
          return a1 - v2;
        v2 = 2534;
        if ( a1 >= 0x9E6u )
        {
          if ( a1 < 0x9F0u )
            return a1 - v2;
          v2 = 2662;
          if ( a1 >= 0xA66u )
          {
            if ( a1 < 0xA70u )
              return a1 - v2;
            v2 = 2790;
            if ( a1 >= 0xAE6u )
            {
              if ( a1 < 0xAF0u )
                return a1 - v2;
              v2 = 2918;
              if ( a1 >= 0xB66u )
              {
                if ( a1 < 0xB70u )
                  return a1 - v2;
                v2 = 3174;
                if ( a1 >= 0xC66u )
                {
                  if ( a1 < 0xC70u )
                    return a1 - v2;
                  v2 = 3302;
                  if ( a1 >= 0xCE6u )
                  {
                    if ( a1 < 0xCF0u )
                      return a1 - v2;
                    v2 = 3430;
                    if ( a1 >= 0xD66u )
                    {
                      if ( a1 < 0xD70u )
                        return a1 - v2;
                      v2 = 3664;
                      if ( a1 >= 0xE50u )
                      {
                        if ( a1 < 0xE5Au )
                          return a1 - v2;
                        v2 = 3792;
                        if ( a1 >= 0xED0u )
                        {
                          if ( a1 < 0xEDAu )
                            return a1 - v2;
                          v2 = 3872;
                          if ( a1 >= 0xF20u )
                          {
                            if ( a1 < 0xF2Au )
                              return a1 - v2;
                            v2 = 4160;
                            if ( a1 >= 0x1040u )
                            {
                              if ( a1 < 0x104Au )
                                return a1 - v2;
                              v2 = 6112;
                              if ( a1 >= 0x17E0u )
                              {
                                if ( a1 < 0x17EAu )
                                  return a1 - v2;
                                v2 = 6160;
                                if ( a1 >= 0x1810u )
                                {
                                  v3 = 6170;
                                  goto LABEL_39;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return -1;
}

//----- (10058792) --------------------------------------------------------
int __cdecl sub_10058792(unsigned int *a1, int a2, int a3)
{
  int result; // eax@1
  int v4; // edx@1
  int v5; // ebx@1
  unsigned int v6; // ecx@2
  int v7; // eax@3
  signed int v8; // ecx@3
  int v9; // edi@3
  unsigned int v10; // esi@3
  int v11; // esi@3
  unsigned int v12; // ecx@3
  int v13; // edx@3
  unsigned int v14; // eax@7
  signed int v15; // ecx@7
  signed int v16; // eax@12
  unsigned int v17; // ecx@12
  int v18; // eax@17
  unsigned int v19; // edi@17
  int v20; // esi@17
  int v21; // edx@17
  bool v22; // edx@19
  signed int v23; // edx@22
  int v24; // ecx@22
  int v25; // edx@30
  unsigned int v26; // esi@31
  unsigned int v27; // esi@31
  int v28; // edx@33
  unsigned int v29; // edi@34
  int v30; // esi@34
  unsigned int v31; // ecx@35
  unsigned int v32; // [sp+Ch] [bp-1Ch]@3
  int v33; // [sp+10h] [bp-18h]@3
  int v34; // [sp+14h] [bp-14h]@3
  int v35; // [sp+1Ch] [bp-Ch]@2
  int v36; // [sp+1Ch] [bp-Ch]@12
  int v37; // [sp+20h] [bp-8h]@2
  signed int v38; // [sp+24h] [bp-4h]@1
  int v39; // [sp+38h] [bp+10h]@2
  unsigned int v40; // [sp+38h] [bp+10h]@3

  v5 = a3;
  v4 = 0;
  result = 16462;
  v38 = 16462;
  *(_DWORD *)a3 = 0;
  *(_DWORD *)(a3 + 4) = 0;
  *(_DWORD *)(a3 + 8) = 0;
  if ( a2 )
  {
    v6 = 0;
    v39 = 0;
    v37 = 0;
    v35 = 0;
    do
    {
      v32 = *(_DWORD *)v5;
      v33 = *(_DWORD *)(v5 + 4);
      v34 = *(_DWORD *)(v5 + 8);
      v11 = (v6 >> 31) | 2 * v37;
      v12 = v11;
      v10 = ((unsigned int)(2 * v39) >> 31) | 2 * v11;
      v13 = 4 * v39;
      v9 = (v12 >> 31) | 2 * (((unsigned int)v37 >> 31) | 2 * v35);
      v7 = 4 * v39 + *(_DWORD *)v5;
      v8 = 0;
      *(_DWORD *)v5 = 4 * v39;
      *(_DWORD *)(v5 + 4) = v10;
      *(_DWORD *)(v5 + 8) = v9;
      v40 = v7;
      if ( v7 < (unsigned int)v13 || v7 < v32 )
        v8 = 1;
      *(_DWORD *)v5 = v7;
      if ( v8 )
      {
        v14 = v10;
        v15 = 0;
        ++v10;
        if ( v10 < v14 || v10 < 1 )
          v15 = 1;
        *(_DWORD *)(v5 + 4) = v10;
        if ( v15 )
        {
          ++v9;
          *(_DWORD *)(v5 + 8) = v9;
        }
      }
      v16 = 0;
      v17 = v10 + v33;
      v36 = v10 + v33;
      if ( v10 + v33 < v10 || v17 < v33 )
        v16 = 1;
      *(_DWORD *)(v5 + 4) = v17;
      if ( v16 )
      {
        ++v9;
        *(_DWORD *)(v5 + 8) = v9;
      }
      v20 = (v40 >> 31) | 2 * v36;
      v18 = (v17 >> 31) | 2 * (v34 + v9);
      v21 = 2 * v40;
      *(_DWORD *)v5 = 2 * v40;
      *(_DWORD *)(v5 + 4) = v20;
      *(_DWORD *)(v5 + 8) = v18;
      v19 = *(_BYTE *)a1;
      v37 = (v40 >> 31) | 2 * v36;
      v6 = 2 * v40 + v19;
      v35 = v18;
      v39 = 2 * v40 + v19;
      v22 = v21 + v19 < v21 || v6 < v19;
      *(_DWORD *)v5 = v6;
      if ( v22 )
      {
        v24 = v20 + 1;
        v23 = 0;
        if ( v20 + 1 < (unsigned int)v20 || (unsigned int)v24 < 1 )
          v23 = 1;
        ++v20;
        *(_DWORD *)(v5 + 4) = v24;
        v6 = v39;
        v37 = v20;
        if ( v23 )
        {
          ++v18;
          v35 = v18;
          *(_DWORD *)(v5 + 8) = v18;
        }
      }
      *(_DWORD *)(v5 + 8) = v18;
      a1 = (unsigned int *)((char *)a1 + 1);
      *(_DWORD *)(v5 + 4) = v20;
      --a2;
    }
    while ( a2 );
    result = 16462;
    v4 = 0;
  }
  if ( *(_DWORD *)(v5 + 8) == v4 )
  {
    v25 = *(_DWORD *)(v5 + 4);
    do
    {
      v27 = v25;
      v25 = (*(_DWORD *)v5 >> 16) | (v25 << 16);
      v26 = v27 >> 16;
      result = v38 + 65520;
      *(_DWORD *)v5 <<= 16;
      v38 += 65520;
    }
    while ( !v26 );
    *(_DWORD *)(v5 + 4) = v25;
    *(_DWORD *)(v5 + 8) = v26;
  }
  v28 = *(_DWORD *)(v5 + 8);
  if ( !(v28 & 0x8000) )
  {
    v29 = *(_DWORD *)v5;
    v30 = *(_DWORD *)(v5 + 4);
    do
    {
      v31 = v30;
      v30 = (v29 >> 31) | 2 * v30;
      v28 = (v31 >> 31) | 2 * v28;
      result = v38 + 65535;
      v29 *= 2;
      v38 += 65535;
    }
    while ( !(v28 & 0x8000) );
    *(_DWORD *)v5 = v29;
    *(_DWORD *)(v5 + 4) = v30;
    *(_DWORD *)(v5 + 8) = v28;
  }
  *(_WORD *)(v5 + 10) = result;
  return result;
}

//----- (10058974) --------------------------------------------------------
int __usercall sub_10058974<eax>(int a1<ebx>, int a2)
{
  int result; // eax@2
  int v3; // eax@3
  int v4; // ebx@3
  int v5; // edi@3
  int v6; // eax@3
  int v7; // edx@3
  int v8; // ecx@3

  if ( a2 )
  {
    v6 = sub_10035530(a2);
    v5 = v6 + 1;
    v3 = sub_10030930(v7, v8, a1, v6 + 1, v6 + 1);
    v4 = v3;
    if ( v3 )
    {
      if ( sub_1003ADD5(v3, v5, v3, v5, a2) )
      {
        sub_1003A161(v4, v5);
        __asm { int     3               ; Trap to Debugger }
        JUMPOUT(*(int *)sub_100589C4);
      }
      result = v4;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (100589C4) --------------------------------------------------------
int __usercall sub_100589C4<eax>(int a1<ebx>, int a2<edi>, int a3, int a4)
{
  return sub_100589D9(a1, a2, a3, a4, 0);
}

//----- (100589D9) --------------------------------------------------------
int __usercall sub_100589D9<eax>(int a1<ebx>, int a2<edi>, int a3, int a4, int a5)
{
  int v5; // edx@1
  int v6; // esi@2
  unsigned __int16 v7; // cx@11
  char v9; // [sp+8h] [bp-10h]@1
  int v10; // [sp+Ch] [bp-Ch]@3
  int v11; // [sp+10h] [bp-8h]@15
  char v12; // [sp+14h] [bp-4h]@14

  sub_100301AD((int)&v9, a1, a2, a5);
  v5 = a3;
  if ( a3 )
  {
    v6 = 0;
    if ( *(_DWORD *)(v10 + 8) )
    {
      while ( 1 )
      {
        v7 = *(_BYTE *)v5;
        if ( !*(_BYTE *)v5 )
          break;
        if ( *(_BYTE *)((unsigned __int8)v7 + v10 + 25) & 4 )
        {
          ++v5;
          if ( !*(_BYTE *)v5 )
            goto LABEL_14;
          if ( a4 == (*(_BYTE *)v5 | (v7 << 8)) )
          {
            v6 = v5 - 1;
            goto LABEL_14;
          }
        }
        else
        {
          if ( a4 == *(_BYTE *)v5 )
            break;
        }
        ++v5;
      }
      if ( a4 == *(_BYTE *)v5 )
        v6 = v5;
    }
    else
    {
      v6 = sub_10030A70(a3, a4);
    }
  }
  else
  {
    *(_DWORD *)sub_10037649(a1) = 22;
    sub_1003A151(a1, a2);
    v6 = 0;
  }
LABEL_14:
  if ( v12 )
    *(_DWORD *)(v11 + 112) &= 0xFFFFFFFDu;
  return v6;
}

//----- (10058A74) --------------------------------------------------------
signed int __usercall sub_10058A74<eax>(int a1<ebx>, int a2<edi>, int a3, unsigned __int8 *a4, signed int a5, int a6)
{
  signed int v6; // esi@2
  int v7; // edi@8
  int v8; // eax@9
  int v9; // esi@9
  char v10; // zf@9
  signed int result; // eax@15
  int v12; // [sp+0h] [bp-10h]@2
  int v13; // [sp+8h] [bp-8h]@14
  char v14; // [sp+Ch] [bp-4h]@13

  if ( a5 )
  {
    sub_100301AD((int)&v12, a1, a2, a6);
    v6 = 2147483647;
    if ( a3 && (a1 = (int)a4, a4) && (unsigned int)a5 <= 0x7FFFFFFF )
    {
      if ( *(_DWORD *)(v12 + 168) )
      {
        v7 = a3 - (_DWORD)a4;
        do
        {
          v9 = sub_100398B2(a1, v7, *(_BYTE *)(v7 + a1), (int)&v12);
          v8 = sub_100398B2(a1, v7, *(_BYTE *)a1, (int)&v12);
          ++a1;
          v10 = a5-- == 1;
        }
        while ( !v10 && v9 && v9 == v8 );
        v6 = v9 - v8;
      }
      else
      {
        v6 = sub_10058FB0((unsigned __int8 *)a3, a4, a5);
      }
    }
    else
    {
      *(_DWORD *)sub_10037649(a1) = 22;
      sub_1003A151(a1, a3);
    }
    if ( v14 )
      *(_DWORD *)(v13 + 112) &= 0xFFFFFFFDu;
    result = v6;
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (10058B23) --------------------------------------------------------
int __usercall sub_10058B23<eax>(int a1<ebx>, int a2, int a3, int a4, signed int a5)
{
  void *v5; // ecx@2
  int result; // eax@4
  int v7; // esi@17
  int v8; // eax@37
  double v9; // st7@51
  int v10; // [sp+0h] [bp-28h]@15
  char v11[4]; // [sp+4h] [bp-24h]@16
  double v12; // [sp+8h] [bp-20h]@17
  double v13; // [sp+10h] [bp-18h]@17
  double v14; // [sp+18h] [bp-10h]@17
  double v15; // [sp+20h] [bp-8h]@1

  *(_QWORD *)&v15 = 0i64;
  if ( dword_10076298 )
    v5 = DecodePointer(dword_10076890);
  else
    v5 = sub_1004EAE4;
  result = a5;
  if ( a5 <= 166 )
  {
    if ( a5 == 166 )
    {
      v10 = 3;
      *(_DWORD *)v11 = "exp10";
      goto LABEL_17;
    }
    if ( a5 > 25 )
    {
      if ( a5 == 26 )
      {
        result = a4;
        *(double *)a4 = 1.0;
        return result;
      }
      if ( a5 == 27 )
      {
        v10 = 2;
LABEL_16:
        *(_DWORD *)v11 = &unk_10064FEC;
        goto LABEL_17;
      }
      if ( a5 == 28 )
      {
LABEL_38:
        *(_DWORD *)v11 = &unk_10064FEC;
      }
      else
      {
        if ( a5 == 29 )
        {
          *(_DWORD *)v11 = &unk_10064FEC;
LABEL_37:
          v8 = a2;
          v7 = a4;
          *(double *)a4 = *(double *)a2;
LABEL_56:
          v12 = *(double *)v8;
          v13 = *(double *)a3;
          v9 = *(double *)v7;
LABEL_57:
          v14 = v9;
          v10 = 1;
          result = ((int (__cdecl *)(int *))v5)(&v10);
          if ( !result )
          {
            result = sub_10037649(a1);
            *(_DWORD *)result = 33;
          }
          goto LABEL_59;
        }
        if ( a5 == 49 )
        {
LABEL_54:
          *(_DWORD *)v11 = "sqrt";
        }
        else
        {
          if ( a5 == 58 )
          {
LABEL_35:
            *(_DWORD *)v11 = "acos";
          }
          else
          {
            result = a5 - 61;
            if ( a5 != 61 )
              return result;
LABEL_34:
            *(_DWORD *)v11 = "asin";
          }
        }
      }
    }
    else
    {
      if ( a5 == 25 )
      {
        *(_DWORD *)v11 = &unk_10064FEC;
        goto LABEL_20;
      }
      if ( a5 == 2 )
      {
        v10 = 2;
        *(_DWORD *)v11 = &unk_10064FF0;
        goto LABEL_17;
      }
      if ( a5 == 3 )
      {
        *(_DWORD *)v11 = &unk_10064FF0;
      }
      else
      {
        if ( a5 == 8 )
        {
          v10 = 2;
          *(_DWORD *)v11 = "log10";
          goto LABEL_17;
        }
        if ( a5 != 9 )
        {
          if ( a5 != 14 )
          {
            if ( a5 != 15 )
            {
              result = a5 - 24;
              if ( a5 != 24 )
                return result;
              v10 = 3;
              goto LABEL_16;
            }
            *(_DWORD *)v11 = &unk_10064FE8;
LABEL_20:
            v7 = a4;
            v12 = *(double *)a2;
            v10 = 4;
            v13 = *(double *)a3;
            v14 = *(double *)a4;
            result = ((int (__cdecl *)(int *))v5)(&v10);
LABEL_59:
            *(_QWORD *)v7 = *(_QWORD *)&v14;
            return result;
          }
          v10 = 3;
          *(_DWORD *)v11 = &unk_10064FE8;
LABEL_17:
          v7 = a4;
          v12 = *(double *)a2;
          v13 = *(double *)a3;
          v14 = *(double *)a4;
          result = ((int (__cdecl *)(_DWORD))v5)(&v10);
          if ( !result )
          {
            result = sub_10037649(a1);
            *(_DWORD *)result = 34;
          }
          goto LABEL_59;
        }
        *(_DWORD *)v11 = "log10";
      }
    }
    v8 = a2;
    v7 = a4;
    goto LABEL_56;
  }
  switch ( a5 )
  {
    case 1009:
      goto LABEL_34;
    case 1008:
      goto LABEL_35;
    case 1006:
      goto LABEL_38;
    case 1000:
      *(_DWORD *)v11 = &unk_10064FF0;
      goto LABEL_37;
    case 1001:
      *(_DWORD *)v11 = "log10";
      goto LABEL_37;
    case 1002:
      *(_DWORD *)v11 = &unk_10064FE8;
      goto LABEL_37;
    case 1003:
      *(_DWORD *)v11 = "atan";
      goto LABEL_37;
    case 1004:
      *(_DWORD *)v11 = "ceil";
      goto LABEL_37;
    case 1005:
      *(_DWORD *)v11 = "floor";
      goto LABEL_37;
    case 1007:
      *(_DWORD *)v11 = "modf";
      goto LABEL_37;
    case 1010:
      *(_DWORD *)v11 = "sin";
      goto LABEL_51;
    case 1011:
      *(_DWORD *)v11 = "cos";
      goto LABEL_51;
    case 1012:
      *(_DWORD *)v11 = "tan";
LABEL_51:
      v7 = a4;
      v9 = *(double *)a2 * v15;
      *(_QWORD *)a4 = *(_QWORD *)&v9;
      v12 = *(double *)a2;
      v13 = *(double *)a3;
      goto LABEL_57;
    case 1013:
      goto LABEL_54;
    default:
      return result;
  }
  return result;
}
// 10076298: using guessed type int dword_10076298;

//----- (10058E0B) --------------------------------------------------------
signed int __cdecl sub_10058E0B(double a1)
{
  signed int result; // eax@4

  if ( sub_1004961B(a1) & 0x90 || a1 != sub_10059011(a1) )
  {
    result = 0;
  }
  else
  {
    if ( a1 * 0.5 == sub_10059011(a1 * 0.5) )
      result = 2;
    else
      result = 1;
  }
  return result;
}

//----- (10058E71) --------------------------------------------------------
signed int __cdecl sub_10058E71(long double a1, double a2, int a3)
{
  int v3; // esi@1
  long double v4; // st7@1
  double v5; // st7@4
  int v6; // eax@5
  unsigned __int8 v7; // c0@5
  unsigned __int8 v8; // c3@5
  int v9; // ecx@21

  v4 = fabs(a1);
  v3 = 0;
  if ( HIDWORD(a2) == 2146435072 )
  {
    if ( !LODWORD(a2) )
    {
      if ( v4 <= 1.0 )
      {
        v7 = 1.0 < v4;
        v8 = 1.0 == v4;
        v5 = 1.0;
        v6 = a3;
        if ( !(v7 | v8) )
          v5 = 0.0;
        goto LABEL_28;
      }
      goto LABEL_4;
    }
  }
  else
  {
    if ( HIDWORD(a2) == -1048576 && !LODWORD(a2) )
    {
      if ( v4 > 1.0 )
      {
        v5 = 0.0;
        goto LABEL_27;
      }
      v6 = a3;
      if ( v4 < 1.0 )
      {
        v5 = dbl_100740A0;
LABEL_28:
        *(_QWORD *)v6 = *(_QWORD *)&v5;
        return v3;
      }
      *(_QWORD *)a3 = *(_QWORD *)&dbl_100740A8;
      return 1;
    }
  }
  if ( HIDWORD(a1) == 2146435072 )
  {
    if ( !LODWORD(a1) )
    {
      v5 = 0.0;
      if ( a2 <= 0.0 )
      {
        v6 = a3;
        if ( a2 >= 0.0 )
          v5 = 1.0;
        goto LABEL_28;
      }
LABEL_4:
      v5 = dbl_100740A0;
LABEL_27:
      v6 = a3;
      goto LABEL_28;
    }
  }
  else
  {
    if ( HIDWORD(a1) == -1048576 && !LODWORD(a1) )
    {
      v5 = 0.0;
      v9 = sub_10058E0B(a2);
      if ( a2 <= 0.0 )
      {
        if ( a2 >= 0.0 )
        {
          *(double *)a3 = 1.0;
          return v3;
        }
        if ( v9 == 1 )
          v5 = dbl_100740C0;
      }
      else
      {
        v5 = dbl_100740A0;
        if ( v9 == 1 )
          v5 = -dbl_100740A0;
      }
      goto LABEL_27;
    }
  }
  return v3;
}
// 100740A0: using guessed type double dbl_100740A0;
// 100740A8: using guessed type double dbl_100740A8;
// 100740C0: using guessed type double dbl_100740C0;

//----- (10058FB0) --------------------------------------------------------
signed int __cdecl sub_10058FB0(unsigned __int8 *a1, unsigned __int8 *a2, signed int a3)
{
  signed int v3; // ecx@1
  unsigned __int8 *v4; // edi@2
  unsigned __int8 *v5; // esi@2
  unsigned __int8 v6; // al@3
  unsigned __int8 v7; // ah@3
  char v8; // cf@11

  v3 = a3;
  if ( a3 )
  {
    v5 = a1;
    v4 = a2;
    do
    {
      v7 = *v5;
      v6 = *v4;
      if ( !*v5 || !v6 )
        break;
      ++v5;
      ++v4;
      if ( v7 >= 0x41u )
      {
        if ( v7 <= 0x5Au )
          v7 += 32;
      }
      if ( v6 >= 0x41u )
      {
        if ( v6 <= 0x5Au )
          v6 += 32;
      }
      v8 = v7 < v6;
      if ( v7 != v6 )
        goto LABEL_14;
      --v3;
    }
    while ( v3 );
    v3 = 0;
    v8 = v7 < v6;
    if ( v7 == v6 )
      return v3;
LABEL_14:
    v3 = -1;
    if ( !v8 )
      v3 = 1;
  }
  return v3;
}

//----- (10059011) --------------------------------------------------------
double __cdecl sub_10059011(double a1)
{
  double result; // st7@1

  _ST7 = a1;
  __asm { frndint }
  return result;
}

//----- (10059030) --------------------------------------------------------
double __usercall sub_10059030<st0>(__int16 a1<cx>, int a2<ebx>, double a3)
{
  char v3; // zf@2
  int v4; // ST2C_4@2
  int v5; // eax@2
  char v6; // ST28_1@3
  unsigned __int8 v8; // pf@7
  double result; // st7@8
  int v14; // ebx@17
  signed int v15; // eax@18
  __int16 v16; // cx@24
  char v17; // [sp-8h] [bp-30h]@23
  signed int v18; // [sp-4h] [bp-2Ch]@23
  __int64 v19; // [sp+0h] [bp-28h]@23
  __int16 v20; // [sp+10h] [bp-18h]@18

  if ( !dword_10076894 )
    goto LABEL_31;
  __asm { stmxcsr [esp+8+var_4] }
  v5 = v4 & 0x7F80;
  v3 = v5 == 8064;
  if ( v5 == 8064 )
    v3 = (v6 & 0x7F) == 127;
  if ( v3 )
  {
    __asm
    {
      movq    xmm0, [esp+arg_0]
      movapd  xmm2, ds:xmmword_100685A0
      movapd  xmm1, xmm0
      movapd  xmm7, xmm0
      psrlq   xmm0, 34h
      movd    eax, xmm0
      andpd   xmm0, ds:xmmword_100685D0
      psubd   xmm2, xmm0
      psrlq   xmm1, xmm2
    }
    if ( _EAX & 0x800 )
    {
      __asm
      {
        movq    xmm0, [esp+arg_0]
        psllq   xmm1, xmm2
        movapd  xmm3, xmm0
        cmpltpd xmm0, xmm1
      }
      if ( _EAX < 3071 )
      {
        __asm
        {
          cmpltpd xmm3, ds:xmmword_100685C0
          orpd    xmm3, ds:xmmword_100685C0
          andpd   xmm3, ds:xmmword_100685B0
          movq    [esp+arg_0], xmm3
        }
        return a3;
      }
      v8 = __SETP__(_EAX - 3122, 0);
      if ( _EAX <= 3122 )
      {
        __asm
        {
          andpd   xmm0, ds:xmmword_10068590
          subsd   xmm1, xmm0
          movq    [esp+arg_0], xmm1
        }
        return a3;
      }
    }
    else
    {
      if ( _EAX < 1023 )
        return 0.0;
      __asm { psllq   xmm1, xmm2 }
      v8 = __SETP__(_EAX - 1074, 0);
      if ( _EAX <= 1074 )
      {
        __asm { movq    [esp+arg_0], xmm1 }
        return a3;
      }
    }
    __asm { ucomisd xmm7, xmm7 }
    if ( v8 )
      sub_10058B23(a2, (int)&a3, (int)&a3, (int)&a3, 1005);
    result = a3;
  }
  else
  {
LABEL_31:
    v14 = sub_10049F8C(a1);
    if ( (WORD3(a3) & 0x7FF0) == 32752 )
    {
      v15 = sub_100497B4(SLODWORD(a3), SHIDWORD(a3));
      if ( v15 > 0 )
      {
        if ( v15 <= 2 )
        {
          sub_10049F8C(v20);
          return a3;
        }
        if ( v15 == 3 )
          return sub_10049AE6(v20, v14, 11, a3);
      }
      *(double *)&v19 = a3;
      v18 = 11;
      v17 = 8;
    }
    else
    {
      result = sub_10059011(a3);
      if ( a3 == result || v14 & 0x20 )
      {
        sub_10049F8C(v16);
        return result;
      }
      *(double *)&v19 = a3;
      v18 = 11;
      v17 = 16;
    }
    result = sub_10049842(v17, v18, v19);
  }
  return result;
}
// 10059030: could not find valid save-restore pair for ebp
// 10049842: using guessed type double __cdecl sub_10049842(char, _DWORD, _DWORD);
// 10076894: using guessed type int dword_10076894;

//----- (10059230) --------------------------------------------------------
void __usercall sub_10059230(void *this<ecx>, int a2<ebp>)
{
  sub_10029AD2((void *)(a2 - 16));
}

//----- (10059238) --------------------------------------------------------
#error "10059244: call analysis failed (funcsize=7)"

//----- (10059253) --------------------------------------------------------
int __usercall sub_10059253<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10029FCF(a2 - 32);
}

//----- (1005925B) --------------------------------------------------------
#error "10059267: call analysis failed (funcsize=7)"

//----- (10059276) --------------------------------------------------------
int __usercall sub_10059276<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 40 + 4);
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 - 40);
  return result;
}

//----- (1005927E) --------------------------------------------------------
_DWORD *__usercall sub_1005927E<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100348F2((void *)(a2 - 32));
}

//----- (10059286) --------------------------------------------------------
#error "10059292: call analysis failed (funcsize=7)"

//----- (100592A1) --------------------------------------------------------
int __usercall sub_100592A1<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_1002BB74((void *)(*(_DWORD *)(a2 - 16) + 4));
}

//----- (100592A9) --------------------------------------------------------
int __usercall sub_100592A9<eax>(int a1<ebp>)
{
  return sub_1002C0CE(a1);
}

//----- (100592B1) --------------------------------------------------------
#error "100592BD: call analysis failed (funcsize=7)"

//----- (100592CC) --------------------------------------------------------
int __thiscall sub_100592CC(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (100592DE) --------------------------------------------------------
#error "100592EA: call analysis failed (funcsize=7)"

//----- (100592F9) --------------------------------------------------------
int __thiscall sub_100592F9(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (10059307) --------------------------------------------------------
#error "10059313: call analysis failed (funcsize=7)"

//----- (10059322) --------------------------------------------------------
int __thiscall sub_10059322(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (10059333) --------------------------------------------------------
int __thiscall sub_10059333(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (10059344) --------------------------------------------------------
#error "10059350: call analysis failed (funcsize=7)"

//----- (1005935F) --------------------------------------------------------
int __usercall sub_1005935F<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 20) + 8);
}
// 1002C171: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005936A) --------------------------------------------------------
#error "10059376: call analysis failed (funcsize=7)"

//----- (10059385) --------------------------------------------------------
void __cdecl sub_10059385()
{
  sub_1002B6D6();
}

//----- (1005938D) --------------------------------------------------------
#error "10059399: call analysis failed (funcsize=7)"

//----- (100593A8) --------------------------------------------------------
void __usercall sub_100593A8(int a1<ebx>, int a2<ebp>)
{
  int v2; // ST00_4@1

  v2 = *(_DWORD *)(a2 - 40 + 4);
  *(_DWORD *)(a2 - 40) = &off_10060A10;
  sub_1002CAA4(a1, v2);
}
// 10060A10: using guessed type int (__stdcall *off_10060A10)(char);

//----- (100593B0) --------------------------------------------------------
void __cdecl sub_100593B0()
{
  sub_1002B6D6();
}

//----- (100593B8) --------------------------------------------------------
#error "100593C4: call analysis failed (funcsize=10)"

//----- (100593DD) --------------------------------------------------------
void __cdecl sub_100593DD()
{
  sub_1002B6D6();
}

//----- (100593E5) --------------------------------------------------------
#error "100593F1: call analysis failed (funcsize=7)"

//----- (10059400) --------------------------------------------------------
unsigned int __usercall sub_10059400<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_1002C0B4((void *)(a2 - 60));
}

//----- (10059408) --------------------------------------------------------
void __cdecl sub_10059408()
{
  sub_1002B6D6();
}

//----- (10059413) --------------------------------------------------------
#error "10059422: call analysis failed (funcsize=7)"

//----- (10059431) --------------------------------------------------------
int __usercall sub_10059431<eax>(int a1<ebp>)
{
  return sub_1002C0CE(a1);
}

//----- (1005943C) --------------------------------------------------------
#error "10059448: call analysis failed (funcsize=7)"

//----- (10059457) --------------------------------------------------------
int __usercall sub_10059457<eax>(int a1<ebp>)
{
  return sub_1002C0CE(a1);
}

//----- (10059462) --------------------------------------------------------
#error "1005946E: call analysis failed (funcsize=7)"

//----- (1005947D) --------------------------------------------------------
void __usercall sub_1005947D(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = &off_10060920;
}
// 10060920: using guessed type int (__stdcall *off_10060920)(char);

//----- (10059485) --------------------------------------------------------
#error "10059491: call analysis failed (funcsize=7)"

//----- (100594A0) --------------------------------------------------------
int __cdecl sub_100594A0()
{
  return sub_1002BB6C();
}

//----- (100594A8) --------------------------------------------------------
#error "100594B4: call analysis failed (funcsize=7)"

//----- (100594C3) --------------------------------------------------------
void __usercall sub_100594C3(int a1<ebx>, int a2<ebp>)
{
  int v2; // ST00_4@1

  v2 = *(_DWORD *)(a2 - 28 + 4);
  *(_DWORD *)(a2 - 28) = &off_10060BE4;
  sub_1002CAA4(a1, v2);
}
// 10060BE4: using guessed type int (__stdcall *off_10060BE4)(char);

//----- (100594CB) --------------------------------------------------------
#error "100594D7: call analysis failed (funcsize=10)"

//----- (100594F0) --------------------------------------------------------
int __thiscall sub_100594F0(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (10059502) --------------------------------------------------------
#error "1005950E: call analysis failed (funcsize=7)"

//----- (1005951D) --------------------------------------------------------
#error "1005952C: call analysis failed (funcsize=7)"

//----- (1005953B) --------------------------------------------------------
#error "10059547: call analysis failed (funcsize=7)"

//----- (10059556) --------------------------------------------------------
void __usercall sub_10059556(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = off_10060BEC;
}
// 10060BEC: using guessed type int (*off_10060BEC[5])();

//----- (1005955E) --------------------------------------------------------
int __usercall sub_1005955E<eax>(int a1<ebp>)
{
  int v1; // esi@1

  v1 = *(_DWORD *)(a1 - 16) + 128;
  sub_1002F39B(v1);
  return sub_100303A3(*(LPVOID *)(v1 + 8));
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (1005956C) --------------------------------------------------------
int __usercall sub_1005956C<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_1002E1F9(*(_DWORD *)(a2 - 16) + 140);
}

//----- (1005957A) --------------------------------------------------------
#error "10059586: call analysis failed (funcsize=7)"

//----- (10059595) --------------------------------------------------------
void __cdecl sub_10059595()
{
  JUMPOUT(*(unsigned int *)loc_1002CFAA);
}
// 1002CFAA: using guessed type int loc_1002CFAA();

//----- (1005959D) --------------------------------------------------------
#error "100595A9: call analysis failed (funcsize=7)"

//----- (100595B8) --------------------------------------------------------
int __usercall sub_100595B8<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10034BAB(*(void **)(a2 - 16));
}

//----- (100595C0) --------------------------------------------------------
#error "100595CC: call analysis failed (funcsize=7)"

//----- (100595DB) --------------------------------------------------------
#error "100595E7: call analysis failed (funcsize=7)"

//----- (100595F6) --------------------------------------------------------
#error "10059602: call analysis failed (funcsize=7)"

//----- (10059611) --------------------------------------------------------
#error "1005961D: call analysis failed (funcsize=7)"

//----- (1005962C) --------------------------------------------------------
void __cdecl sub_1005962C()
{
  JUMPOUT(*(unsigned int *)loc_1002F6C5);
}
// 1002F6C5: using guessed type int loc_1002F6C5();

//----- (10059634) --------------------------------------------------------
int __usercall sub_10059634<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 + 20));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005963E) --------------------------------------------------------
int __thiscall sub_1005963E(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005964C) --------------------------------------------------------
int __usercall sub_1005964C<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 20) & 1;
  if ( *(_DWORD *)(a1 - 20) & 1 )
  {
    *(_DWORD *)(a1 - 20) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_1002F6C5);
  }
  return result;
}
// 1002F6C5: using guessed type int loc_1002F6C5();

//----- (10059665) --------------------------------------------------------
void __usercall sub_10059665(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_10029440(a3 - 40, a2);
}

//----- (1005966D) --------------------------------------------------------
#error "10059679: call analysis failed (funcsize=7)"

//----- (10059688) --------------------------------------------------------
int __usercall sub_10059688<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 24));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059692) --------------------------------------------------------
void __usercall sub_10059692(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_10029440(a3 - 40, a2);
}

//----- (1005969A) --------------------------------------------------------
int __usercall sub_1005969A<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 20) & 1;
  if ( *(_DWORD *)(a1 - 20) & 1 )
  {
    *(_DWORD *)(a1 - 20) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_1002F6C5);
  }
  return result;
}
// 1002F6C5: using guessed type int loc_1002F6C5();

//----- (100596B3) --------------------------------------------------------
#error "100596BF: call analysis failed (funcsize=7)"

//----- (100596CE) --------------------------------------------------------
void __usercall sub_100596CE(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_10029440(a3 - 32, a2);
}

//----- (100596D6) --------------------------------------------------------
#error "100596E2: call analysis failed (funcsize=7)"

//----- (100596F1) --------------------------------------------------------
void __usercall sub_100596F1(int a1<ebp>)
{
  JUMPOUT(*(_DWORD *)(a1 - 20 + 4), 0, *(unsigned int *)sub_1000AA70);
}

//----- (100596F9) --------------------------------------------------------
#error "10059705: call analysis failed (funcsize=7)"

//----- (10059714) --------------------------------------------------------
int __usercall sub_10059714<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 16);
  **(_DWORD **)(a1 - 16) = 0;
  return result;
}

//----- (1005971C) --------------------------------------------------------
#error "10059728: call analysis failed (funcsize=7)"

//----- (10059737) --------------------------------------------------------
void __usercall sub_10059737(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = &off_10060E48;
}
// 10060E48: using guessed type int (__stdcall *off_10060E48)(char);

//----- (1005973F) --------------------------------------------------------
int __usercall sub_1005973F<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_10044AE2((LPVOID *)(*(_DWORD *)(a2 - 16) + 4));
}

//----- (1005974A) --------------------------------------------------------
int __usercall sub_1005974A<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_100317DE(*(_DWORD *)(a2 - 16) + 48);
}

//----- (10059755) --------------------------------------------------------
int __usercall sub_10059755<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_100317DE(*(_DWORD *)(a2 - 16) + 60);
}

//----- (10059760) --------------------------------------------------------
int __usercall sub_10059760<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_100317DE(*(_DWORD *)(a2 - 16) + 72);
}

//----- (1005976B) --------------------------------------------------------
int __usercall sub_1005976B<eax>(int a1<ebp>)
{
  return sub_100303A3(*(LPVOID *)(*(_DWORD *)(a1 - 16) + 88));
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (10059776) --------------------------------------------------------
int __usercall sub_10059776<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_10031750((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 96));
}

//----- (10059781) --------------------------------------------------------
int __usercall sub_10059781<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_100316DE((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 200));
}

//----- (1005978F) --------------------------------------------------------
void __usercall sub_1005978F(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_1002B6CE((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 280));
}

//----- (1005979D) --------------------------------------------------------
void __cdecl sub_1005979D()
{
  JUMPOUT(*(unsigned int *)loc_1002E1CF);
}
// 1002E1CF: using guessed type int loc_1002E1CF();

//----- (100597AB) --------------------------------------------------------
void __cdecl sub_100597AB()
{
  JUMPOUT(*(unsigned int *)loc_1002E1CF);
}
// 1002E1CF: using guessed type int loc_1002E1CF();

//----- (100597B9) --------------------------------------------------------
#error "100597C5: call analysis failed (funcsize=7)"

//----- (100597D4) --------------------------------------------------------
void __cdecl sub_100597D4()
{
  JUMPOUT(*(unsigned int *)loc_100317FC);
}
// 100317FC: using guessed type int loc_100317FC();

//----- (100597DC) --------------------------------------------------------
int __usercall sub_100597DC<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_10044AE2((LPVOID *)(*(_DWORD *)(a2 - 16) + 4));
}

//----- (100597E7) --------------------------------------------------------
int __usercall sub_100597E7<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_100317DE(*(_DWORD *)(a2 - 16) + 48);
}

//----- (100597F2) --------------------------------------------------------
int __usercall sub_100597F2<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_100317DE(*(_DWORD *)(a2 - 16) + 60);
}

//----- (100597FD) --------------------------------------------------------
int __usercall sub_100597FD<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_100317DE(*(_DWORD *)(a2 - 16) + 72);
}

//----- (10059808) --------------------------------------------------------
void __cdecl sub_10059808()
{
  JUMPOUT(*(unsigned int *)loc_1002E267);
}
// 1002E267: using guessed type int loc_1002E267();

//----- (10059813) --------------------------------------------------------
int __usercall sub_10059813<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_10031750((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 96));
}

//----- (1005981E) --------------------------------------------------------
int __usercall sub_1005981E<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_100316DE((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 200));
}

//----- (1005982C) --------------------------------------------------------
void __usercall sub_1005982C(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_1002B6CE((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 280));
}

//----- (1005983A) --------------------------------------------------------
void __cdecl sub_1005983A()
{
  JUMPOUT(*(unsigned int *)loc_1002E1CF);
}
// 1002E1CF: using guessed type int loc_1002E1CF();

//----- (10059848) --------------------------------------------------------
void __cdecl sub_10059848()
{
  JUMPOUT(*(unsigned int *)loc_1002E1CF);
}
// 1002E1CF: using guessed type int loc_1002E1CF();

//----- (10059856) --------------------------------------------------------
#error "10059862: call analysis failed (funcsize=7)"

//----- (10059871) --------------------------------------------------------
int __usercall sub_10059871<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 16) & 1;
  if ( *(_DWORD *)(a1 - 16) & 1 )
  {
    *(_DWORD *)(a1 - 16) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_1002E267);
  }
  return result;
}
// 1002E267: using guessed type int loc_1002E267();

//----- (1005988A) --------------------------------------------------------
#error "10059896: call analysis failed (funcsize=7)"

//----- (100598A5) --------------------------------------------------------
void __cdecl sub_100598A5()
{
  JUMPOUT(*(unsigned int *)loc_10030DB7);
}
// 10030DB7: using guessed type int loc_10030DB7();

//----- (100598AD) --------------------------------------------------------
int __usercall sub_100598AD<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_10044AE2((LPVOID *)(a2 - 16));
}

//----- (100598B5) --------------------------------------------------------
#error "100598C1: call analysis failed (funcsize=7)"

//----- (100598D0) --------------------------------------------------------
#error "100598DC: call analysis failed (funcsize=7)"

//----- (100598EB) --------------------------------------------------------
int __usercall sub_100598EB<eax>(int a1<ebp>)
{
  return sub_100303A3(*(LPVOID *)(a1 - 60));
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (100598F5) --------------------------------------------------------
void __cdecl sub_100598F5()
{
  JUMPOUT(*(unsigned int *)loc_1002E267);
}
// 1002E267: using guessed type int loc_1002E267();

//----- (100598FD) --------------------------------------------------------
int __usercall sub_100598FD<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 48));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059907) --------------------------------------------------------
int __usercall sub_10059907<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 48));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059911) --------------------------------------------------------
#error "1005991D: call analysis failed (funcsize=7)"

//----- (1005992C) --------------------------------------------------------
int __usercall sub_1005992C<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 16));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059936) --------------------------------------------------------
int __usercall sub_10059936<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 + 8));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059940) --------------------------------------------------------
#error "1005994C: call analysis failed (funcsize=7)"

//----- (1005995B) --------------------------------------------------------
#error "10059967: call analysis failed (funcsize=7)"

//----- (10059976) --------------------------------------------------------
void __usercall sub_10059976(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_1002B6CE((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 20) + 44));
}

//----- (10059981) --------------------------------------------------------
int __usercall sub_10059981<eax>(int a1<ebp>)
{
  return sub_1004CED6(a1);
}

//----- (1005998C) --------------------------------------------------------
#error "10059998: call analysis failed (funcsize=7)"

//----- (100599A7) --------------------------------------------------------
void __usercall sub_100599A7(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_1002B6CE((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 44));
}

//----- (100599B2) --------------------------------------------------------
int __usercall sub_100599B2<eax>(int a1<ebp>)
{
  return sub_1004CED6(a1);
}

//----- (100599BD) --------------------------------------------------------
#error "100599C9: call analysis failed (funcsize=7)"

//----- (100599D8) --------------------------------------------------------
int __usercall sub_100599D8<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 32));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (100599E2) --------------------------------------------------------
#error "100599EE: call analysis failed (funcsize=10)"

//----- (10059A07) --------------------------------------------------------
int __usercall sub_10059A07<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_10044AE2((LPVOID *)(a2 + 8));
}

//----- (10059A0F) --------------------------------------------------------
int __usercall sub_10059A0F<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 16));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059A19) --------------------------------------------------------
#error "10059A25: call analysis failed (funcsize=7)"

//----- (10059A34) --------------------------------------------------------
void __cdecl sub_10059A34()
{
  JUMPOUT(*(unsigned int *)loc_10030DB7);
}
// 10030DB7: using guessed type int loc_10030DB7();

//----- (10059A3C) --------------------------------------------------------
int __usercall sub_10059A3C<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 20));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059A46) --------------------------------------------------------
int __usercall sub_10059A46<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 20));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059A50) --------------------------------------------------------
#error "10059A5C: call analysis failed (funcsize=7)"

//----- (10059A6B) --------------------------------------------------------
void __cdecl sub_10059A6B()
{
  JUMPOUT(*(unsigned int *)loc_1003B98E);
}
// 1003B98E: using guessed type int loc_1003B98E();

//----- (10059A73) --------------------------------------------------------
#error "10059A7F: call analysis failed (funcsize=7)"

//----- (10059A8E) --------------------------------------------------------
void __cdecl sub_10059A8E()
{
  JUMPOUT(*(unsigned int *)loc_1003B98E);
}
// 1003B98E: using guessed type int loc_1003B98E();

//----- (10059A96) --------------------------------------------------------
#error "10059AA2: call analysis failed (funcsize=7)"

//----- (10059AB1) --------------------------------------------------------
void __cdecl sub_10059AB1()
{
  JUMPOUT(*(unsigned int *)loc_1003B98E);
}
// 1003B98E: using guessed type int loc_1003B98E();

//----- (10059AB9) --------------------------------------------------------
#error "10059AC5: call analysis failed (funcsize=7)"

//----- (10059AD4) --------------------------------------------------------
void __usercall sub_10059AD4(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_1002BB52(*(LPCRITICAL_SECTION *)(a2 - 16));
}

//----- (10059ADC) --------------------------------------------------------
#error "10059AE8: call analysis failed (funcsize=7)"

//----- (10059AF7) --------------------------------------------------------
#error "10059B03: call analysis failed (funcsize=7)"

//----- (10059B12) --------------------------------------------------------
int __usercall sub_10059B12<eax>(int a1<ebp>)
{
  return sub_1002CFB4(a1);
}

//----- (10059B1D) --------------------------------------------------------
#error "10059B2C: call analysis failed (funcsize=10)"

//----- (10059B45) --------------------------------------------------------
int __usercall sub_10059B45<eax>(int a1<ebp>)
{
  return sub_1002FDDA(a1 - 24);
}

//----- (10059B4D) --------------------------------------------------------
#error "10059B59: call analysis failed (funcsize=7)"

//----- (10059B68) --------------------------------------------------------
int __usercall sub_10059B68<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10044E10(*(_DWORD *)(a2 - 16));
}

//----- (10059B70) --------------------------------------------------------
int __usercall sub_10059B70<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_1002E1E2(*(_DWORD *)(a2 - 16) + 76);
}

//----- (10059B7B) --------------------------------------------------------
#error "10059B87: call analysis failed (funcsize=7)"

//----- (10059B96) --------------------------------------------------------
void __cdecl sub_10059B96()
{
  JUMPOUT(*(unsigned int *)loc_100318B1);
}
// 100318B1: using guessed type int loc_100318B1();

//----- (10059B9E) --------------------------------------------------------
#error "10059BAA: call analysis failed (funcsize=7)"

//----- (10059BB9) --------------------------------------------------------
void __cdecl sub_10059BB9()
{
  JUMPOUT(*(unsigned int *)loc_1002E267);
}
// 1002E267: using guessed type int loc_1002E267();

//----- (10059BC4) --------------------------------------------------------
int __usercall sub_10059BC4<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 + 16));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059BCE) --------------------------------------------------------
#error "10059BDA: call analysis failed (funcsize=7)"

//----- (10059BE9) --------------------------------------------------------
void __usercall sub_10059BE9(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = off_10060E30;
}
// 10060E30: using guessed type int (*off_10060E30[4])();

//----- (10059BF1) --------------------------------------------------------
#error "10059BFD: call analysis failed (funcsize=7)"

//----- (10059C0C) --------------------------------------------------------
void __cdecl sub_10059C0C()
{
  JUMPOUT(*(unsigned int *)loc_1002E267);
}
// 1002E267: using guessed type int loc_1002E267();

//----- (10059C17) --------------------------------------------------------
void __cdecl sub_10059C17()
{
  JUMPOUT(*(unsigned int *)loc_1002E267);
}
// 1002E267: using guessed type int loc_1002E267();

//----- (10059C1F) --------------------------------------------------------
int __usercall sub_10059C1F<eax>(int a1<ebp>)
{
  return sub_10040819(a1);
}

//----- (10059C2A) --------------------------------------------------------
int __usercall sub_10059C2A<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_100407A2((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 88));
}

//----- (10059C35) --------------------------------------------------------
int __usercall sub_10059C35<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_100316DE((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 168));
}

//----- (10059C43) --------------------------------------------------------
#error "10059C4F: call analysis failed (funcsize=7)"

//----- (10059C5E) --------------------------------------------------------
void __cdecl sub_10059C5E()
{
  JUMPOUT(*(unsigned int *)loc_1002E267);
}
// 1002E267: using guessed type int loc_1002E267();

//----- (10059C69) --------------------------------------------------------
#error "10059C75: call analysis failed (funcsize=7)"

//----- (10059C84) --------------------------------------------------------
void __cdecl sub_10059C84()
{
  JUMPOUT(*(unsigned int *)loc_1002E267);
}
// 1002E267: using guessed type int loc_1002E267();

//----- (10059C8F) --------------------------------------------------------
#error "10059C9B: call analysis failed (funcsize=7)"

//----- (10059CAA) --------------------------------------------------------
int __usercall sub_10059CAA<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 16));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059CB4) --------------------------------------------------------
#error "10059CC0: call analysis failed (funcsize=7)"

//----- (10059CCF) --------------------------------------------------------
#error "10059CDB: call analysis failed (funcsize=7)"

//----- (10059CEA) --------------------------------------------------------
int __usercall sub_10059CEA<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10044E10(*(_DWORD *)(a2 - 16) + 12);
}

//----- (10059CF5) --------------------------------------------------------
void __cdecl sub_10059CF5()
{
  JUMPOUT(*(unsigned int *)loc_1002E267);
}
// 1002E267: using guessed type int loc_1002E267();

//----- (10059D03) --------------------------------------------------------
#error "10059D0F: call analysis failed (funcsize=7)"

//----- (10059D1E) --------------------------------------------------------
void __cdecl sub_10059D1E()
{
  JUMPOUT(*(unsigned int *)loc_1002E267);
}
// 1002E267: using guessed type int loc_1002E267();

//----- (10059D29) --------------------------------------------------------
void __cdecl sub_10059D29()
{
  JUMPOUT(*(unsigned int *)loc_1002E1CF);
}
// 1002E1CF: using guessed type int loc_1002E1CF();

//----- (10059D34) --------------------------------------------------------
#error "10059D40: call analysis failed (funcsize=7)"

//----- (10059D4F) --------------------------------------------------------
void __cdecl sub_10059D4F()
{
  JUMPOUT(*(unsigned int *)loc_100318B1);
}
// 100318B1: using guessed type int loc_100318B1();

//----- (10059D57) --------------------------------------------------------
#error "10059D63: call analysis failed (funcsize=7)"

//----- (10059D72) --------------------------------------------------------
int __usercall sub_10059D72<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_1002E239((void *)(*(_DWORD *)(a2 - 16) + 4));
}

//----- (10059D7D) --------------------------------------------------------
#error "10059D89: call analysis failed (funcsize=7)"

//----- (10059D98) --------------------------------------------------------
int __cdecl sub_10059D98()
{
  return sub_1004EAE4();
}

//----- (10059DA0) --------------------------------------------------------
#error "10059DAC: call analysis failed (funcsize=7)"

//----- (10059DBB) --------------------------------------------------------
int __usercall sub_10059DBB<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 16) & 1;
  if ( *(_DWORD *)(a2 - 16) & 1 )
  {
    *(_DWORD *)(a2 - 16) &= 0xFFFFFFFEu;
    result = sub_10044AE2((LPVOID *)(a2 - 20));
  }
  return result;
}

//----- (10059DD4) --------------------------------------------------------
#error "10059DE0: call analysis failed (funcsize=7)"

//----- (10059DEF) --------------------------------------------------------
int __usercall sub_10059DEF<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_1004734C((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 16));
}

//----- (10059DFA) --------------------------------------------------------
int __usercall sub_10059DFA<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_1004734C((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 96));
}

//----- (10059E05) --------------------------------------------------------
#error "10059E11: call analysis failed (funcsize=7)"

//----- (10059E20) --------------------------------------------------------
int __usercall sub_10059E20<eax>(PSLIST_HEADER ListHead<ecx>, int a2<ebp>)
{
  return sub_1004734C((PSLIST_HEADER)(*(_DWORD *)(a2 - 16) + 16));
}

//----- (10059E2B) --------------------------------------------------------
#error "10059E37: call analysis failed (funcsize=7)"

//----- (10059E46) --------------------------------------------------------
int __usercall sub_10059E46<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_1002E239(*(void **)(a2 - 16));
}

//----- (10059E4E) --------------------------------------------------------
#error "10059E5A: call analysis failed (funcsize=7)"

//----- (10059E69) --------------------------------------------------------
int __usercall sub_10059E69<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_1002E239(*(void **)(a2 - 16));
}

//----- (10059E71) --------------------------------------------------------
#error "10059E7D: call analysis failed (funcsize=7)"

//----- (10059E8C) --------------------------------------------------------
void __usercall sub_10059E8C(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_1002B6CE((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 32));
}

//----- (10059E97) --------------------------------------------------------
int __usercall sub_10059E97<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 + 12));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059EA1) --------------------------------------------------------
#error "10059EAD: call analysis failed (funcsize=7)"

//----- (10059EBC) --------------------------------------------------------
void __usercall sub_10059EBC(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_1002B6CE((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 32));
}

//----- (10059EC7) --------------------------------------------------------
#error "10059ED3: call analysis failed (funcsize=7)"

//----- (10059EE2) --------------------------------------------------------
void __cdecl sub_10059EE2()
{
  JUMPOUT(*(unsigned int *)loc_1003B98E);
}
// 1003B98E: using guessed type int loc_1003B98E();

//----- (10059EEA) --------------------------------------------------------
#error "10059EF6: call analysis failed (funcsize=7)"

//----- (10059F05) --------------------------------------------------------
int __usercall sub_10059F05<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 + 8));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059F0F) --------------------------------------------------------
#error "10059F1B: call analysis failed (funcsize=7)"

//----- (10059F2A) --------------------------------------------------------
void __cdecl sub_10059F2A()
{
  JUMPOUT(*(unsigned int *)loc_1003B98E);
}
// 1003B98E: using guessed type int loc_1003B98E();

//----- (10059F32) --------------------------------------------------------
#error "10059F3E: call analysis failed (funcsize=7)"

//----- (10059F4D) --------------------------------------------------------
void __usercall sub_10059F4D(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_1002B6CE((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 12));
}

//----- (10059F58) --------------------------------------------------------
#error "10059F64: call analysis failed (funcsize=7)"

//----- (10059F73) --------------------------------------------------------
void __usercall sub_10059F73(LPCRITICAL_SECTION lpCriticalSection<ecx>, int a2<ebp>)
{
  sub_1002B6CE((LPCRITICAL_SECTION)(*(_DWORD *)(a2 - 16) + 12));
}

//----- (10059F7E) --------------------------------------------------------
#error "10059F8A: call analysis failed (funcsize=7)"

//----- (10059F99) --------------------------------------------------------
int __usercall sub_10059F99<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 16));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (10059FA3) --------------------------------------------------------
#error "10059FAF: call analysis failed (funcsize=7)"

//----- (10059FBE) --------------------------------------------------------
int __usercall sub_10059FBE<eax>(int a1<ebp>)
{
  return sub_10044E27(a1);
}

//----- (10059FC6) --------------------------------------------------------
#error "10059FD2: call analysis failed (funcsize=7)"

//----- (10059FF0) --------------------------------------------------------
void __cdecl sub_10059FF0()
{
  JUMPOUT(*(unsigned int *)loc_1000A390);
}
// 1000A390: using guessed type int loc_1000A390();

//----- (10059FF8) --------------------------------------------------------
int __thiscall sub_10059FF8(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005A00C) --------------------------------------------------------
int __usercall sub_1005A00C<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_1000A960(*(_DWORD *)(a2 - 20));
}

//----- (1005A014) --------------------------------------------------------
#error "1005A020: call analysis failed (funcsize=7)"

//----- (1005A030) --------------------------------------------------------
int __usercall sub_1005A030<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10004BA0(a2 + 8);
}

//----- (1005A038) --------------------------------------------------------
void __cdecl sub_1005A038()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A040) --------------------------------------------------------
void __cdecl sub_1005A040()
{
  JUMPOUT(*(unsigned int *)loc_10009DE0);
}
// 10009DE0: using guessed type int loc_10009DE0();

//----- (1005A048) --------------------------------------------------------
int __usercall sub_1005A048<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100099A0((void *)(a2 - 20));
}

//----- (1005A050) --------------------------------------------------------
void __cdecl sub_1005A050()
{
  JUMPOUT(*(unsigned int *)loc_10009DE0);
}
// 10009DE0: using guessed type int loc_10009DE0();

//----- (1005A058) --------------------------------------------------------
int __usercall sub_1005A058<eax>(int a1<ebp>)
{
  return sub_1000A680(*(_DWORD *)(a1 - 16));
}
// 1000A680: using guessed type _DWORD __cdecl sub_1000A680(_DWORD);

//----- (1005A063) --------------------------------------------------------
void __cdecl sub_1005A063()
{
  JUMPOUT(*(unsigned int *)loc_10009DE0);
}
// 10009DE0: using guessed type int loc_10009DE0();

//----- (1005A06B) --------------------------------------------------------
#error "1005A077: call analysis failed (funcsize=7)"

//----- (1005A090) --------------------------------------------------------
int __usercall sub_1005A090<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100099A0((void *)(a2 + 8));
}

//----- (1005A098) --------------------------------------------------------
void __cdecl sub_1005A098()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A0A0) --------------------------------------------------------
void __cdecl sub_1005A0A0()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A0A8) --------------------------------------------------------
#error "1005A0B4: call analysis failed (funcsize=7)"

//----- (1005A0D0) --------------------------------------------------------
int __usercall sub_1005A0D0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 + 32, a2);
}

//----- (1005A0D8) --------------------------------------------------------
void __cdecl sub_1005A0D8()
{
  JUMPOUT(*(unsigned int *)loc_10009DE0);
}
// 10009DE0: using guessed type int loc_10009DE0();

//----- (1005A0E0) --------------------------------------------------------
int __usercall sub_1005A0E0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(*(_DWORD *)(a3 - 28), a2);
}

//----- (1005A0E8) --------------------------------------------------------
int __usercall sub_1005A0E8<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 20) & 1;
  if ( *(_DWORD *)(a1 - 20) & 1 )
  {
    *(_DWORD *)(a1 - 20) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A101) --------------------------------------------------------
#error "1005A10D: call analysis failed (funcsize=7)"

//----- (1005A120) --------------------------------------------------------
int __usercall sub_1005A120<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100099A0((void *)(a2 + 8));
}

//----- (1005A128) --------------------------------------------------------
int __usercall sub_1005A128<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 + 36, a2);
}

//----- (1005A130) --------------------------------------------------------
void __cdecl sub_1005A130()
{
  JUMPOUT(*(unsigned int *)loc_10009DE0);
}
// 10009DE0: using guessed type int loc_10009DE0();

//----- (1005A138) --------------------------------------------------------
int __usercall sub_1005A138<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 20));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005A143) --------------------------------------------------------
void __cdecl sub_1005A143()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A14B) --------------------------------------------------------
int __usercall sub_1005A14B<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 24) & 1;
  if ( *(_DWORD *)(a1 - 24) & 1 )
  {
    *(_DWORD *)(a1 - 24) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A164) --------------------------------------------------------
#error "1005A170: call analysis failed (funcsize=7)"

//----- (1005A180) --------------------------------------------------------
void __cdecl sub_1005A180()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A188) --------------------------------------------------------
#error "1005A194: call analysis failed (funcsize=7)"

//----- (1005A1B0) --------------------------------------------------------
void __cdecl sub_1005A1B0()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A1B8) --------------------------------------------------------
#error "1005A1C4: call analysis failed (funcsize=7)"

//----- (1005A1E0) --------------------------------------------------------
int __thiscall sub_1005A1E0(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005A1F1) --------------------------------------------------------
void __usercall sub_1005A1F1(int a1<ebp>)
{
  **(_DWORD **)(a1 - 24) = off_10067080;
}
// 10067080: using guessed type int (*off_10067080[5])();

//----- (1005A1F9) --------------------------------------------------------
void __cdecl sub_1005A1F9()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005A201) --------------------------------------------------------
#error "1005A20D: call analysis failed (funcsize=7)"

//----- (1005A220) --------------------------------------------------------
#error "1005A22C: call analysis failed (funcsize=7)"

//----- (1005A240) --------------------------------------------------------
void __cdecl sub_1005A240()
{
  JUMPOUT(*(unsigned int *)loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();

//----- (1005A248) --------------------------------------------------------
#error "1005A254: call analysis failed (funcsize=10)"

//----- (1005A270) --------------------------------------------------------
int __usercall sub_1005A270<eax>(int a1<ebp>)
{
  int result; // eax@2
  int v2; // esi@1

  v2 = a1 - 64;
  if ( *(_DWORD *)(a1 - 64 + 40) >= 0x10u )
    result = sub_1002A4AA(*(LPVOID *)(a1 - 64 + 20));
  *(_DWORD *)(v2 + 40) = 15;
  *(_DWORD *)(v2 + 36) = 0;
  *(_BYTE *)(v2 + 20) = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005A278) --------------------------------------------------------
#error "1005A284: call analysis failed (funcsize=10)"

//----- (1005A2A0) --------------------------------------------------------
#error "1005A2AC: call analysis failed (funcsize=7)"

//----- (1005A2C0) --------------------------------------------------------
void __cdecl sub_1005A2C0()
{
  JUMPOUT(*(unsigned int *)loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();

//----- (1005A2C8) --------------------------------------------------------
#error "1005A2D4: call analysis failed (funcsize=10)"

//----- (1005A2F0) --------------------------------------------------------
void __cdecl sub_1005A2F0()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005A2F8) --------------------------------------------------------
void __cdecl sub_1005A2F8()
{
  sub_1002B6D6();
}

//----- (1005A300) --------------------------------------------------------
#error "1005A30C: call analysis failed (funcsize=10)"

//----- (1005A330) --------------------------------------------------------
int __usercall sub_1005A330<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 16) & 1;
  if ( *(_DWORD *)(a1 - 16) & 1 )
  {
    *(_DWORD *)(a1 - 16) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A349) --------------------------------------------------------
#error "1005A355: call analysis failed (funcsize=7)"

//----- (1005A370) --------------------------------------------------------
void __cdecl sub_1005A370()
{
  JUMPOUT(*(unsigned int *)loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();

//----- (1005A378) --------------------------------------------------------
void __cdecl sub_1005A378()
{
  JUMPOUT(*(unsigned int *)loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();

//----- (1005A380) --------------------------------------------------------
void __cdecl sub_1005A380()
{
  JUMPOUT(*(unsigned int *)loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();

//----- (1005A388) --------------------------------------------------------
void __cdecl sub_1005A388()
{
  JUMPOUT(*(unsigned int *)loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();

//----- (1005A390) --------------------------------------------------------
#error "1005A39F: call analysis failed (funcsize=10)"

//----- (1005A3C0) --------------------------------------------------------
int __thiscall sub_1005A3C0(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005A3D1) --------------------------------------------------------
#error "1005A3DD: call analysis failed (funcsize=7)"

//----- (1005A3F0) --------------------------------------------------------
int __usercall sub_1005A3F0<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100029F0((void *)(a2 - 48));
}

//----- (1005A3F8) --------------------------------------------------------
#error "1005A404: call analysis failed (funcsize=10)"

//----- (1005A420) --------------------------------------------------------
void __cdecl sub_1005A420()
{
  JUMPOUT(*(unsigned int *)loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();

//----- (1005A428) --------------------------------------------------------
void __cdecl sub_1005A428()
{
  JUMPOUT(*(unsigned int *)loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();

//----- (1005A430) --------------------------------------------------------
#error "1005A43C: call analysis failed (funcsize=10)"

//----- (1005A460) --------------------------------------------------------
int __usercall sub_1005A460<eax>(int a1<ebp>)
{
  return sub_10001940(a1 + 8);
}
// 10001940: using guessed type int __thiscall sub_10001940(_DWORD);

//----- (1005A468) --------------------------------------------------------
#error "1005A474: call analysis failed (funcsize=7)"

//----- (1005A490) --------------------------------------------------------
int __usercall sub_1005A490<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 24));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005A49B) --------------------------------------------------------
int __usercall sub_1005A49B<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 20) & 1;
  if ( *(_DWORD *)(a1 - 20) & 1 )
  {
    *(_DWORD *)(a1 - 20) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A4B4) --------------------------------------------------------
#error "1005A4C0: call analysis failed (funcsize=7)"

//----- (1005A4D0) --------------------------------------------------------
int __usercall sub_1005A4D0<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 28));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005A4DB) --------------------------------------------------------
void __usercall sub_1005A4DB(int a1<ebp>)
{
  **(_DWORD **)(a1 - 28) = off_10060C64;
}
// 10060C64: using guessed type int (*off_10060C64[2])();

//----- (1005A4E3) --------------------------------------------------------
int __thiscall sub_1005A4E3(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005A4F7) --------------------------------------------------------
int __usercall sub_1005A4F7<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 24) & 1;
  if ( *(_DWORD *)(a1 - 24) & 1 )
  {
    *(_DWORD *)(a1 - 24) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A510) --------------------------------------------------------
#error "1005A51C: call analysis failed (funcsize=7)"

//----- (1005A530) --------------------------------------------------------
int __usercall sub_1005A530<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 24));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005A53B) --------------------------------------------------------
int __usercall sub_1005A53B<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 20) & 1;
  if ( *(_DWORD *)(a1 - 20) & 1 )
  {
    *(_DWORD *)(a1 - 20) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A554) --------------------------------------------------------
#error "1005A560: call analysis failed (funcsize=7)"

//----- (1005A570) --------------------------------------------------------
void __cdecl sub_1005A570()
{
  JUMPOUT(*(unsigned int *)loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();

//----- (1005A578) --------------------------------------------------------
#error "1005A584: call analysis failed (funcsize=10)"

//----- (1005A5A0) --------------------------------------------------------
int __usercall sub_1005A5A0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>)
{
  return sub_10028820(*(_DWORD *)(a4 - 56), a2, a3);
}

//----- (1005A5A8) --------------------------------------------------------
int __usercall sub_1005A5A8<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>)
{
  int v19; // ST08_4@6
  int v20; // ebx@1
  int v21; // esi@1
  int v22; // [sp-Ch] [bp-Ch]@2

  v20 = *(_DWORD *)(a4 - 56);
  v21 = *(_DWORD *)(v20 + 88);
  if ( v21 )
  {
    v22 = a3;
    _EDI = -1;
    _EDX = v21 + 4;
    _EAX = -1;
    __asm { lock xadd [edx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v21)(v21);
      _EAX = v21 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        (*(void (__thiscall **)(int))(*(_DWORD *)v21 + 4))(v21);
    }
    a3 = v22;
  }
  return sub_10028820(v20, v19, a3);
}

//----- (1005A5B0) --------------------------------------------------------
int __usercall sub_1005A5B0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 56) + 92);
}

//----- (1005A5BB) --------------------------------------------------------
int __usercall sub_1005A5BB<eax>(int a1<ebp>)
{
  int result; // eax@2
  int v2; // esi@1

  v2 = a1 - 52;
  *(_DWORD *)(a1 - 52) = &off_100670D8;
  if ( *(_DWORD *)(a1 - 52 + 24) >= 0x10u )
    result = sub_1002A4AA(*(LPVOID *)(a1 - 52 + 4));
  *(_DWORD *)(v2 + 24) = 15;
  *(_DWORD *)(v2 + 20) = 0;
  *(_BYTE *)(v2 + 4) = 0;
  *(_DWORD *)v2 = &off_1006737C;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 100670D8: using guessed type int (__stdcall *off_100670D8)(char);
// 1006737C: using guessed type int (__stdcall *off_1006737C)(char);

//----- (1005A5C3) --------------------------------------------------------
#error "1005A5CF: call analysis failed (funcsize=10)"

//----- (1005A5F0) --------------------------------------------------------
void __cdecl sub_1005A5F0()
{
  JUMPOUT(*(unsigned int *)loc_10007AD0);
}
// 10007AD0: using guessed type int loc_10007AD0();

//----- (1005A5F8) --------------------------------------------------------
#error "1005A604: call analysis failed (funcsize=7)"

//----- (1005A620) --------------------------------------------------------
void __cdecl sub_1005A620()
{
  JUMPOUT(*(unsigned int *)loc_1000A390);
}
// 1000A390: using guessed type int loc_1000A390();

//----- (1005A628) --------------------------------------------------------
int __thiscall sub_1005A628(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005A63C) --------------------------------------------------------
int __usercall sub_1005A63C<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100034E0(*(void **)(a2 - 20));
}

//----- (1005A644) --------------------------------------------------------
int __usercall sub_1005A644<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 20) + 12);
}
// 1002C171: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005A64F) --------------------------------------------------------
#error "1005A65B: call analysis failed (funcsize=7)"

//----- (1005A670) --------------------------------------------------------
int __usercall sub_1005A670<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 8);
}

//----- (1005A678) --------------------------------------------------------
int __usercall sub_1005A678<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 24));
}

//----- (1005A680) --------------------------------------------------------
int __usercall sub_1005A680<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100029F0((void *)(*(_DWORD *)(a2 - 24) + 40));
}

//----- (1005A68B) --------------------------------------------------------
void __cdecl sub_1005A68B()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A696) --------------------------------------------------------
int __usercall sub_1005A696<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 64);
}

//----- (1005A69E) --------------------------------------------------------
#error "1005A6AA: call analysis failed (funcsize=7)"

//----- (1005A6C0) --------------------------------------------------------
int __usercall sub_1005A6C0<eax>(int a1<ebp>)
{
  return sub_1002C0CE(a1);
}

//----- (1005A6CB) --------------------------------------------------------
int __usercall sub_1005A6CB<eax>(int a1<ebp>)
{
  return sub_1002C0CE(a1);
}

//----- (1005A6D6) --------------------------------------------------------
void __cdecl sub_1005A6D6()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A6E1) --------------------------------------------------------
#error "1005A6ED: call analysis failed (funcsize=7)"

//----- (1005A700) --------------------------------------------------------
void __cdecl sub_1005A700()
{
  JUMPOUT(*(unsigned int *)loc_10009DE0);
}
// 10009DE0: using guessed type int loc_10009DE0();

//----- (1005A70B) --------------------------------------------------------
#error "1005A717: call analysis failed (funcsize=7)"

//----- (1005A730) --------------------------------------------------------
int __usercall sub_1005A730<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>)
{
  return sub_10028820(*(_DWORD *)(a4 - 16), a2, a3);
}

//----- (1005A738) --------------------------------------------------------
#error "1005A744: call analysis failed (funcsize=7)"

//----- (1005A760) --------------------------------------------------------
int __usercall sub_1005A760<eax>(int a1<ebp>)
{
  int result; // eax@2
  int v14; // ecx@1
  int v15; // edi@1
  int v16; // esi@1

  v14 = *(_DWORD *)(a1 - 16);
  v16 = v14;
  *(_DWORD *)v14 = off_1006703C;
  v15 = *(_DWORD *)(v14 + 24);
  if ( v15 )
  {
    _EBX = -1;
    _EDX = v15 + 4;
    _EAX = -1;
    __asm { lock xadd [edx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v15)(v15);
      result = v15 + 8;
      __asm { lock xadd [eax], ebx }
      if ( _EBX == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v15 + 4))(v15);
    }
    *(_DWORD *)v16 = &off_10060E80;
  }
  else
  {
    *(_DWORD *)v14 = &off_10060E80;
  }
  return result;
}
// 10060E80: using guessed type int (__stdcall *off_10060E80)(char);
// 1006703C: using guessed type int (__stdcall *off_1006703C[2])(char);

//----- (1005A768) --------------------------------------------------------
int __usercall sub_1005A768<eax>(int a1<ebp>)
{
  int result; // eax@3
  int v2; // esi@1

  v2 = *(_DWORD *)(a1 - 20) + 4;
  if ( *(_DWORD *)(*(_DWORD *)(a1 - 20) + 24) >= 8u )
    sub_1002A4AA(*(LPVOID *)(*(_DWORD *)(a1 - 20) + 4));
  *(_DWORD *)(v2 + 20) = 7;
  *(_DWORD *)(v2 + 16) = 0;
  result = 0;
  *(_WORD *)v2 = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005A773) --------------------------------------------------------
#error "1005A77F: call analysis failed (funcsize=7)"

//----- (1005A790) --------------------------------------------------------
int __usercall sub_1005A790<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100034E0(*(void **)(a2 - 16));
}

//----- (1005A798) --------------------------------------------------------
int __usercall sub_1005A798<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 16) + 12);
}
// 1002C171: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005A7A3) --------------------------------------------------------
int __usercall sub_1005A7A3<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(*(_DWORD *)(a3 - 16) + 48, a2);
}

//----- (1005A7AE) --------------------------------------------------------
void __cdecl sub_1005A7AE()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A7B9) --------------------------------------------------------
#error "1005A7C5: call analysis failed (funcsize=7)"

//----- (1005A7E0) --------------------------------------------------------
int __usercall sub_1005A7E0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_1000A960(*(_DWORD *)(a2 - 16));
}

//----- (1005A7E8) --------------------------------------------------------
int __usercall sub_1005A7E8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(*(_DWORD *)(a3 - 16) + 152, a2);
}

//----- (1005A7F6) --------------------------------------------------------
#error "1005A802: call analysis failed (funcsize=7)"

//----- (1005A820) --------------------------------------------------------
int __usercall sub_1005A820<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 16));
}

//----- (1005A828) --------------------------------------------------------
int __usercall sub_1005A828<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100029F0((void *)(*(_DWORD *)(a2 - 16) + 40));
}

//----- (1005A833) --------------------------------------------------------
void __cdecl sub_1005A833()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A83E) --------------------------------------------------------
#error "1005A84A: call analysis failed (funcsize=7)"

//----- (1005A860) --------------------------------------------------------
void __cdecl sub_1005A860()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005A86B) --------------------------------------------------------
#error "1005A877: call analysis failed (funcsize=7)"

//----- (1005A890) --------------------------------------------------------
int __usercall sub_1005A890<eax>(int a1<ebp>)
{
  return sub_1002C0CE(a1);
}

//----- (1005A89B) --------------------------------------------------------
int __usercall sub_1005A89B<eax>(int a1<ebp>)
{
  return sub_1002C0CE(a1);
}

//----- (1005A8A6) --------------------------------------------------------
int __usercall sub_1005A8A6<eax>(int a1<ebp>)
{
  int result; // eax@2
  int v14; // esi@1

  v14 = *(_DWORD *)(*(_DWORD *)(a1 - 16) + 96);
  if ( v14 )
  {
    _EDI = -1;
    _ECX = v14 + 4;
    _EAX = -1;
    __asm { lock xadd [ecx], eax }
    if ( _ZF )
    {
      (**(void (__thiscall ***)(_DWORD))v14)(v14);
      result = v14 + 8;
      __asm { lock xadd [eax], edi }
      if ( _EDI == 1 )
        result = (*(int (__thiscall **)(int))(*(_DWORD *)v14 + 4))(v14);
    }
  }
  return result;
}

//----- (1005A8B1) --------------------------------------------------------
int __usercall sub_1005A8B1<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 16) + 100);
}
// 1002C171: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005A8BC) --------------------------------------------------------
#error "1005A8C8: call analysis failed (funcsize=7)"

//----- (1005A8E0) --------------------------------------------------------
void __cdecl sub_1005A8E0()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A8E8) --------------------------------------------------------
int __usercall sub_1005A8E8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 120, a2);
}

//----- (1005A8F0) --------------------------------------------------------
int __usercall sub_1005A8F0<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100029F0((void *)(a2 - 92));
}

//----- (1005A8F8) --------------------------------------------------------
void __cdecl sub_1005A8F8()
{
  JUMPOUT(*(unsigned int *)loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();

//----- (1005A900) --------------------------------------------------------
int __usercall sub_1005A900<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 136, a2);
}

//----- (1005A90B) --------------------------------------------------------
int __usercall sub_1005A90B<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 160, a2);
}

//----- (1005A916) --------------------------------------------------------
#error "1005A925: call analysis failed (funcsize=10)"

//----- (1005A940) --------------------------------------------------------
void __cdecl sub_1005A940()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A948) --------------------------------------------------------
#error "1005A954: call analysis failed (funcsize=7)"

//----- (1005A970) --------------------------------------------------------
void __cdecl sub_1005A970()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A978) --------------------------------------------------------
#error "1005A984: call analysis failed (funcsize=7)"

//----- (1005A9A0) --------------------------------------------------------
void __cdecl sub_1005A9A0()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005A9A8) --------------------------------------------------------
#error "1005A9B4: call analysis failed (funcsize=7)"

//----- (1005A9D0) --------------------------------------------------------
void __cdecl sub_1005A9D0()
{
  sub_1002B6D6();
}

//----- (1005A9D8) --------------------------------------------------------
void __cdecl sub_1005A9D8()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005A9E0) --------------------------------------------------------
#error "1005A9EC: call analysis failed (funcsize=10)"

//----- (1005AA10) --------------------------------------------------------
void __cdecl sub_1005AA10()
{
  sub_1002B6D6();
}

//----- (1005AA18) --------------------------------------------------------
void __cdecl sub_1005AA18()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005AA20) --------------------------------------------------------
#error "1005AA2C: call analysis failed (funcsize=10)"

//----- (1005AA50) --------------------------------------------------------
void __cdecl sub_1005AA50()
{
  sub_1002B6D6();
}

//----- (1005AA58) --------------------------------------------------------
void __cdecl sub_1005AA58()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005AA60) --------------------------------------------------------
#error "1005AA6C: call analysis failed (funcsize=10)"

//----- (1005AA90) --------------------------------------------------------
void __cdecl sub_1005AA90()
{
  sub_1002B6D6();
}

//----- (1005AA98) --------------------------------------------------------
void __cdecl sub_1005AA98()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005AAA0) --------------------------------------------------------
#error "1005AAAC: call analysis failed (funcsize=10)"

//----- (1005AAD0) --------------------------------------------------------
void __cdecl sub_1005AAD0()
{
  sub_1002B6D6();
}

//----- (1005AAD8) --------------------------------------------------------
void __cdecl sub_1005AAD8()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005AAE0) --------------------------------------------------------
#error "1005AAEC: call analysis failed (funcsize=10)"

//----- (1005AB10) --------------------------------------------------------
int __usercall sub_1005AB10<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_1000A960(*(_DWORD *)(a2 - 16));
}

//----- (1005AB18) --------------------------------------------------------
#error "1005AB24: call analysis failed (funcsize=7)"

//----- (1005AB40) --------------------------------------------------------
int __usercall sub_1005AB40<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 72);
}

//----- (1005AB48) --------------------------------------------------------
int __usercall sub_1005AB48<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 48);
}

//----- (1005AB50) --------------------------------------------------------
#error "1005AB5C: call analysis failed (funcsize=7)"

//----- (1005AB70) --------------------------------------------------------
int __usercall sub_1005AB70<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100099A0((void *)(a2 + 16));
}

//----- (1005AB78) --------------------------------------------------------
void __cdecl sub_1005AB78()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005AB80) --------------------------------------------------------
int __usercall sub_1005AB80<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 28) & 1;
  if ( *(_DWORD *)(a1 - 28) & 1 )
  {
    *(_DWORD *)(a1 - 28) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005AB99) --------------------------------------------------------
#error "1005ABA5: call analysis failed (funcsize=10)"

//----- (1005ABC0) --------------------------------------------------------
int __usercall sub_1005ABC0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 60, a2);
}

//----- (1005ABC8) --------------------------------------------------------
int __usercall sub_1005ABC8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005ABD0) --------------------------------------------------------
int __usercall sub_1005ABD0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005ABD8) --------------------------------------------------------
int __usercall sub_1005ABD8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005ABE0) --------------------------------------------------------
int __usercall sub_1005ABE0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005ABE8) --------------------------------------------------------
int __usercall sub_1005ABE8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(*(_DWORD *)(a3 - 64), a2);
}

//----- (1005ABF0) --------------------------------------------------------
void __cdecl sub_1005ABF0()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005ABF8) --------------------------------------------------------
int __usercall sub_1005ABF8<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 68) & 1;
  if ( *(_DWORD *)(a1 - 68) & 1 )
  {
    *(_DWORD *)(a1 - 68) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005AC11) --------------------------------------------------------
#error "1005AC1D: call analysis failed (funcsize=10)"

//----- (1005AC40) --------------------------------------------------------
void __cdecl sub_1005AC40()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005AC48) --------------------------------------------------------
#error "1005AC54: call analysis failed (funcsize=7)"

//----- (1005AC70) --------------------------------------------------------
int __usercall sub_1005AC70<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001B00(a2 - 136);
}

//----- (1005AC7B) --------------------------------------------------------
int __usercall sub_1005AC7B<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 152, a2);
}

//----- (1005AC86) --------------------------------------------------------
int __usercall sub_1005AC86<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 176, a2);
}

//----- (1005AC91) --------------------------------------------------------
int __usercall sub_1005AC91<eax>(int a1<ebp>)
{
  return sub_10001940(a1 - 176);
}
// 10001940: using guessed type int __thiscall sub_10001940(_DWORD);

//----- (1005AC9C) --------------------------------------------------------
#error "1005ACAE: call analysis failed (funcsize=11)"

//----- (1005ACD0) --------------------------------------------------------
void __cdecl sub_1005ACD0()
{
  sub_1002B6D6();
}

//----- (1005ACD8) --------------------------------------------------------
void __cdecl sub_1005ACD8()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005ACE0) --------------------------------------------------------
int __usercall sub_1005ACE0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 - 72);
}

//----- (1005ACE8) --------------------------------------------------------
#error "1005ACF4: call analysis failed (funcsize=11)"

//----- (1005AD10) --------------------------------------------------------
int __usercall sub_1005AD10<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100034E0((void *)(a2 - 64));
}

//----- (1005AD18) --------------------------------------------------------
void __cdecl sub_1005AD18()
{
  sub_1002B6D6();
}

//----- (1005AD20) --------------------------------------------------------
#error "1005AD2C: call analysis failed (funcsize=10)"

//----- (1005AD50) --------------------------------------------------------
void __cdecl sub_1005AD50()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005AD58) --------------------------------------------------------
#error "1005AD64: call analysis failed (funcsize=7)"

//----- (1005AD80) --------------------------------------------------------
void __cdecl sub_1005AD80()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005AD88) --------------------------------------------------------
void __cdecl sub_1005AD88()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005AD90) --------------------------------------------------------
#error "1005AD9C: call analysis failed (funcsize=7)"

//----- (1005ADB0) --------------------------------------------------------
void __cdecl sub_1005ADB0()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005ADB8) --------------------------------------------------------
void __cdecl sub_1005ADB8()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005ADC0) --------------------------------------------------------
void __cdecl sub_1005ADC0()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005ADC8) --------------------------------------------------------
int __usercall sub_1005ADC8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 - 72);
}

//----- (1005ADD0) --------------------------------------------------------
void __cdecl sub_1005ADD0()
{
  sub_1002B6D6();
}

//----- (1005ADD8) --------------------------------------------------------
#error "1005ADE4: call analysis failed (funcsize=11)"

//----- (1005AE00) --------------------------------------------------------
#error "1005AE0C: call analysis failed (funcsize=7)"

//----- (1005AE20) --------------------------------------------------------
#error "1005AE2C: call analysis failed (funcsize=7)"

//----- (1005AE40) --------------------------------------------------------
void __cdecl sub_1005AE40()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005AE48) --------------------------------------------------------
#error "1005AE54: call analysis failed (funcsize=10)"

//----- (1005AE70) --------------------------------------------------------
int __usercall sub_1005AE70<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 16) & 1;
  if ( *(_DWORD *)(a1 - 16) & 1 )
  {
    *(_DWORD *)(a1 - 16) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_1000A500);
  }
  return result;
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005AE89) --------------------------------------------------------
#error "1005AE95: call analysis failed (funcsize=7)"

//----- (1005AEB0) --------------------------------------------------------
int __usercall sub_1005AEB0<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 + 8, a2);
}

//----- (1005AEB8) --------------------------------------------------------
void __cdecl sub_1005AEB8()
{
  sub_1002B6D6();
}

//----- (1005AEC0) --------------------------------------------------------
#error "1005AECC: call analysis failed (funcsize=10)"

//----- (1005AEF0) --------------------------------------------------------
void __cdecl sub_1005AEF0()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005AEF8) --------------------------------------------------------
#error "1005AF04: call analysis failed (funcsize=7)"

//----- (1005AF20) --------------------------------------------------------
int __usercall sub_1005AF20<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 + 8);
}

//----- (1005AF28) --------------------------------------------------------
#error "1005AF34: call analysis failed (funcsize=7)"

//----- (1005AF50) --------------------------------------------------------
void __cdecl sub_1005AF50()
{
  sub_1002B6D6();
}

//----- (1005AF58) --------------------------------------------------------
#error "1005AF64: call analysis failed (funcsize=10)"

//----- (1005AF80) --------------------------------------------------------
void __cdecl sub_1005AF80()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005AF88) --------------------------------------------------------
#error "1005AF94: call analysis failed (funcsize=7)"

//----- (1005AFB0) --------------------------------------------------------
void __cdecl sub_1005AFB0()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005AFB8) --------------------------------------------------------
#error "1005AFC4: call analysis failed (funcsize=11)"

//----- (1005AFE0) --------------------------------------------------------
void __cdecl sub_1005AFE0()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005AFE8) --------------------------------------------------------
void __cdecl sub_1005AFE8()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005AFF0) --------------------------------------------------------
void __cdecl sub_1005AFF0()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005AFF8) --------------------------------------------------------
#error "1005B004: call analysis failed (funcsize=10)"

//----- (1005B020) --------------------------------------------------------
void __cdecl sub_1005B020()
{
  JUMPOUT(*(unsigned int *)loc_1000A510);
}
// 1000A510: using guessed type int loc_1000A510();

//----- (1005B028) --------------------------------------------------------
int __usercall sub_1005B028<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 20));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005B033) --------------------------------------------------------
int __usercall sub_1005B033<eax>(int a1<ebp>)
{
  int result; // eax@2
  int v2; // ecx@1
  int v3; // ecx@1
  int v4; // esi@1

  v3 = *(_DWORD *)(a1 - 24);
  v4 = v3;
  v2 = *(_DWORD *)(v3 + 16);
  if ( v2 )
  {
    result = (*(int (__stdcall **)(bool))(*(_DWORD *)v2 + 16))(v2 != v4);
    *(_DWORD *)(v4 + 16) = 0;
  }
  return result;
}

//----- (1005B03B) --------------------------------------------------------
#error "1005B047: call analysis failed (funcsize=7)"

//----- (1005B060) --------------------------------------------------------
#error "1005B06C: call analysis failed (funcsize=7)"

//----- (1005B080) --------------------------------------------------------
int __usercall sub_1005B080<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 + 12);
  --*(_DWORD *)result;
  return result;
}

//----- (1005B088) --------------------------------------------------------
#error "1005B094: call analysis failed (funcsize=7)"

//----- (1005B0B0) --------------------------------------------------------
void __cdecl sub_1005B0B0()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005B0B8) --------------------------------------------------------
#error "1005B0C4: call analysis failed (funcsize=10)"

//----- (1005B0E0) --------------------------------------------------------
void __cdecl sub_1005B0E0()
{
  JUMPOUT(*(unsigned int *)loc_1000A510);
}
// 1000A510: using guessed type int loc_1000A510();

//----- (1005B0E8) --------------------------------------------------------
void __cdecl sub_1005B0E8()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005B0F0) --------------------------------------------------------
#error "1005B0FC: call analysis failed (funcsize=7)"

//----- (1005B110) --------------------------------------------------------
int __thiscall sub_1005B110(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005B121) --------------------------------------------------------
int __thiscall sub_1005B121(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005B132) --------------------------------------------------------
#error "1005B13E: call analysis failed (funcsize=7)"

//----- (1005B150) --------------------------------------------------------
void __cdecl sub_1005B150()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005B158) --------------------------------------------------------
#error "1005B164: call analysis failed (funcsize=7)"

//----- (1005B180) --------------------------------------------------------
int __usercall sub_1005B180<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 + 8, a2);
}

//----- (1005B188) --------------------------------------------------------
int __usercall sub_1005B188<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_100034E0((void *)(a2 - 64));
}

//----- (1005B190) --------------------------------------------------------
void __cdecl sub_1005B190()
{
  sub_1002B6D6();
}

//----- (1005B198) --------------------------------------------------------
int __usercall sub_1005B198<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 80, a2);
}

//----- (1005B1A0) --------------------------------------------------------
void __cdecl sub_1005B1A0()
{
  sub_1002B6D6();
}

//----- (1005B1A8) --------------------------------------------------------
#error "1005B1B4: call analysis failed (funcsize=10)"

//----- (1005B1D0) --------------------------------------------------------
void __cdecl sub_1005B1D0()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005B1D8) --------------------------------------------------------
void __cdecl sub_1005B1D8()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005B1E0) --------------------------------------------------------
#error "1005B1EC: call analysis failed (funcsize=7)"

//----- (1005B200) --------------------------------------------------------
int __usercall sub_1005B200<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 16);
}

//----- (1005B208) --------------------------------------------------------
void __usercall sub_1005B208(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = off_10067B0C;
}
// 10067B0C: using guessed type int (__stdcall *off_10067B0C[2])(char);

//----- (1005B210) --------------------------------------------------------
#error "1005B21C: call analysis failed (funcsize=7)"

//----- (1005B230) --------------------------------------------------------
int __usercall sub_1005B230<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 88);
}

//----- (1005B238) --------------------------------------------------------
#error "1005B244: call analysis failed (funcsize=10)"

//----- (1005B260) --------------------------------------------------------
int __usercall sub_1005B260<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 8);
}

//----- (1005B268) --------------------------------------------------------
int __usercall sub_1005B268<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 44);
}

//----- (1005B270) --------------------------------------------------------
#error "1005B27C: call analysis failed (funcsize=7)"

//----- (1005B290) --------------------------------------------------------
int __usercall sub_1005B290<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 8);
}

//----- (1005B298) --------------------------------------------------------
int __usercall sub_1005B298<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 160);
}

//----- (1005B2A3) --------------------------------------------------------
int __usercall sub_1005B2A3<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 164));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005B2B1) --------------------------------------------------------
#error "1005B2C0: call analysis failed (funcsize=10)"

//----- (1005B2E0) --------------------------------------------------------
int __usercall sub_1005B2E0<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 16) & 1;
  if ( *(_DWORD *)(a2 - 16) & 1 )
  {
    *(_DWORD *)(a2 - 16) &= 0xFFFFFFFEu;
    result = sub_10001880(a2 - 64);
  }
  return result;
}

//----- (1005B2F9) --------------------------------------------------------
#error "1005B305: call analysis failed (funcsize=7)"

//----- (1005B320) --------------------------------------------------------
void __cdecl sub_1005B320()
{
  JUMPOUT(*(unsigned int *)loc_10017D90);
}
// 10017D90: using guessed type int loc_10017D90();

//----- (1005B328) --------------------------------------------------------
void __cdecl sub_1005B328()
{
  JUMPOUT(*(unsigned int *)loc_10017E50);
}
// 10017E50: using guessed type int loc_10017E50();

//----- (1005B330) --------------------------------------------------------
#error "1005B33C: call analysis failed (funcsize=7)"

//----- (1005B350) --------------------------------------------------------
int __thiscall sub_1005B350(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005B361) --------------------------------------------------------
void __cdecl sub_1005B361()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005B369) --------------------------------------------------------
#error "1005B375: call analysis failed (funcsize=7)"

//----- (1005B390) --------------------------------------------------------
#error "1005B39C: call analysis failed (funcsize=7)"

//----- (1005B3B0) --------------------------------------------------------
void __cdecl sub_1005B3B0()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005B3B8) --------------------------------------------------------
#error "1005B3C4: call analysis failed (funcsize=7)"

//----- (1005B3E0) --------------------------------------------------------
#error "1005B3EC: call analysis failed (funcsize=7)"

//----- (1005B400) --------------------------------------------------------
void __usercall sub_1005B400(int a1<ebx>, int a2<ebp>)
{
  int v2; // ecx@1

  v2 = *(_DWORD *)(a2 + 16);
  if ( *(_DWORD *)v2 )
  {
    if ( *(_DWORD *)(v2 + 4) == 1 )
      sub_100309C2(a1, *(LPVOID *)v2);
  }
}

//----- (1005B408) --------------------------------------------------------
#error "1005B414: call analysis failed (funcsize=7)"

//----- (1005B43A) --------------------------------------------------------
#error "1005B446: call analysis failed (funcsize=10)"

//----- (1005B460) --------------------------------------------------------
void __usercall sub_1005B460(void *this<ecx>, int a2<ebp>)
{
  sub_10029AD2((void *)(a2 - 24));
}

//----- (1005B468) --------------------------------------------------------
#error "1005B474: call analysis failed (funcsize=10)"

//----- (1005B490) --------------------------------------------------------
int __usercall sub_1005B490<eax>(int a1<ebp>)
{
  return sub_1002A4AA(**(LPVOID **)(a1 - 24));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005B498) --------------------------------------------------------
#error "1005B4A4: call analysis failed (funcsize=7)"

//----- (1005B4C0) --------------------------------------------------------
char __usercall sub_1005B4C0<al>(int a1<ebp>)
{
  int v1; // eax@1
  int v2; // ecx@2

  v1 = *(_DWORD *)(a1 - 16) & 1;
  if ( *(_DWORD *)(a1 - 16) & 1 )
  {
    *(_DWORD *)(a1 - 16) &= 0xFFFFFFFEu;
    v2 = *(_DWORD *)(a1 - 20) + 80;
    *(_DWORD *)v2 = &off_10067398;
    LOBYTE(v1) = sub_100296B7(v2);
  }
  return v1;
}
// 10067398: using guessed type int (__stdcall *off_10067398)(char);

//----- (1005B4DC) --------------------------------------------------------
int __usercall sub_1005B4DC<eax>(int a1<ebp>)
{
  int v1; // edx@1
  int result; // eax@1
  int v3; // ecx@1

  v3 = *(_DWORD *)(a1 - 20) + 8;
  *(_DWORD *)(*(_DWORD *)(**(_DWORD **)(a1 - 20) + 4) + *(_DWORD *)(a1 - 20) + 8 - 8) = off_100679B8;
  v1 = *(_DWORD *)(*(_DWORD *)(v3 - 8) + 4);
  result = v1 - 8;
  *(_DWORD *)(v1 + v3 - 12) = v1 - 8;
  return result;
}
// 100679B8: using guessed type int (*off_100679B8[3])();

//----- (1005B4E7) --------------------------------------------------------
void __usercall sub_1005B4E7(int a1<ebp>)
{
  int v1; // eax@3
  int v2; // ecx@1
  void *v3; // esi@1

  v2 = *(_DWORD *)(a1 - 24);
  v3 = *(void **)(v2 + 52);
  *(_DWORD *)v2 = &off_10067934;
  if ( v3 )
  {
    if ( *(_DWORD *)v3 )
    {
      v1 = (*(int (**)(void))(**(_DWORD **)v3 + 8))();
      if ( v1 )
        (**(void (__thiscall ***)(_DWORD, _DWORD))v1)(v1, 1);
    }
    sub_1002A4AA(v3);
  }
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10067934: using guessed type int (__stdcall *off_10067934)(char);

//----- (1005B4EF) --------------------------------------------------------
#error "1005B4FB: call analysis failed (funcsize=7)"

//----- (1005B510) --------------------------------------------------------
int __usercall sub_1005B510<eax>(int a1<ebp>)
{
  int v1; // esi@1
  int result; // eax@1

  v1 = *(_DWORD *)(a1 - 16);
  sub_10002D20(v1);
  result = sub_1002A4AA(*(LPVOID *)v1);
  *(_DWORD *)v1 = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005B518) --------------------------------------------------------
#error "1005B524: call analysis failed (funcsize=7)"

//----- (1005B540) --------------------------------------------------------
int __usercall sub_1005B540<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 24));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005B54B) --------------------------------------------------------
int __usercall sub_1005B54B<eax>(int a1<ebp>)
{
  return sub_100303A3(*(LPVOID *)(a1 - 24));
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (1005B556) --------------------------------------------------------
#error "1005B562: call analysis failed (funcsize=10)"

//----- (1005B580) --------------------------------------------------------
void __usercall sub_1005B580(void *this<ecx>, int a2<ebp>)
{
  sub_10029AD2(*(void **)(a2 - 24));
}

//----- (1005B588) --------------------------------------------------------
void __usercall sub_1005B588(int a1<ebx>, int a2<ebp>)
{
  LPVOID *v2; // ecx@1
  LPVOID *v3; // esi@1

  v2 = (LPVOID *)(*(_DWORD *)(a2 - 24) + 4);
  v3 = v2;
  if ( *v2 )
    sub_100309C2(a1, *v2);
  *v3 = 0;
}

//----- (1005B593) --------------------------------------------------------
void __cdecl sub_1005B593()
{
  JUMPOUT(*(unsigned int *)loc_100179C0);
}
// 100179C0: using guessed type int loc_100179C0();

//----- (1005B59E) --------------------------------------------------------
void __cdecl sub_1005B59E()
{
  JUMPOUT(*(unsigned int *)loc_100179C0);
}
// 100179C0: using guessed type int loc_100179C0();

//----- (1005B5A9) --------------------------------------------------------
void __cdecl sub_1005B5A9()
{
  JUMPOUT(*(unsigned int *)loc_100179C0);
}
// 100179C0: using guessed type int loc_100179C0();

//----- (1005B5B4) --------------------------------------------------------
void __cdecl sub_1005B5B4()
{
  JUMPOUT(*(unsigned int *)loc_100179C0);
}
// 100179C0: using guessed type int loc_100179C0();

//----- (1005B5BF) --------------------------------------------------------
void __cdecl sub_1005B5BF()
{
  JUMPOUT(*(unsigned int *)loc_100179C0);
}
// 100179C0: using guessed type int loc_100179C0();

//----- (1005B5CA) --------------------------------------------------------
#error "1005B5D6: call analysis failed (funcsize=10)"

//----- (1005B5F0) --------------------------------------------------------
int __usercall sub_1005B5F0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 36);
}

//----- (1005B5F8) --------------------------------------------------------
#error "1005B604: call analysis failed (funcsize=7)"

//----- (1005B620) --------------------------------------------------------
int __usercall sub_1005B620<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // ecx@1
  int v3; // ecx@1

  v3 = **(_DWORD **)(a1 - 16);
  result = *(_DWORD *)(*(_DWORD *)v3 + 4);
  v2 = *(_DWORD *)(result + v3 + 56);
  if ( v2 )
    result = (*(int (**)(void))(*(_DWORD *)v2 + 8))();
  return result;
}

//----- (1005B628) --------------------------------------------------------
#error "1005B634: call analysis failed (funcsize=7)"

//----- (1005B650) --------------------------------------------------------
void __cdecl sub_1005B650()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005B658) --------------------------------------------------------
#error "1005B664: call analysis failed (funcsize=7)"

//----- (1005B680) --------------------------------------------------------
void __cdecl sub_1005B680()
{
  JUMPOUT(*(unsigned int *)loc_10017D90);
}
// 10017D90: using guessed type int loc_10017D90();

//----- (1005B688) --------------------------------------------------------
void __cdecl sub_1005B688()
{
  JUMPOUT(*(unsigned int *)loc_10017E50);
}
// 10017E50: using guessed type int loc_10017E50();

//----- (1005B690) --------------------------------------------------------
void __usercall sub_1005B690(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 28));
}

//----- (1005B698) --------------------------------------------------------
#error "1005B6A4: call analysis failed (funcsize=7)"

//----- (1005B6C0) --------------------------------------------------------
int __usercall sub_1005B6C0<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 48));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005B6CB) --------------------------------------------------------
int __usercall sub_1005B6CB<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 68, a2);
}

//----- (1005B6D3) --------------------------------------------------------
void __cdecl sub_1005B6D3()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005B6DB) --------------------------------------------------------
void __cdecl sub_1005B6DB()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005B6E3) --------------------------------------------------------
void __usercall sub_1005B6E3(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_10010C30(a3 - 44, a2);
}

//----- (1005B6EB) --------------------------------------------------------
void __cdecl sub_1005B6EB()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005B6F3) --------------------------------------------------------
#error "1005B6FF: call analysis failed (funcsize=10)"

//----- (1005B720) --------------------------------------------------------
void __cdecl sub_1005B720()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005B728) --------------------------------------------------------
#error "1005B734: call analysis failed (funcsize=7)"

//----- (1005B750) --------------------------------------------------------
void __cdecl sub_1005B750()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005B758) --------------------------------------------------------
#error "1005B764: call analysis failed (funcsize=7)"

//----- (1005B780) --------------------------------------------------------
void __usercall sub_1005B780(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 96));
}

//----- (1005B788) --------------------------------------------------------
int __usercall sub_1005B788<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 68);
}

//----- (1005B790) --------------------------------------------------------
void __usercall sub_1005B790(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 96));
}

//----- (1005B798) --------------------------------------------------------
int __usercall sub_1005B798<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 44);
}

//----- (1005B7A0) --------------------------------------------------------
#error "1005B7AC: call analysis failed (funcsize=11)"

//----- (1005B7D0) --------------------------------------------------------
int __usercall sub_1005B7D0<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 + 8));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005B7DB) --------------------------------------------------------
#error "1005B7E7: call analysis failed (funcsize=7)"

//----- (1005B800) --------------------------------------------------------
int __usercall sub_1005B800<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 + 8));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005B80B) --------------------------------------------------------
#error "1005B817: call analysis failed (funcsize=7)"

//----- (1005B830) --------------------------------------------------------
int __usercall sub_1005B830<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 + 8));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005B83B) --------------------------------------------------------
void __usercall sub_1005B83B(void *this<ecx>, int a2<ebx>, int a3<ebp>)
{
  if ( *(_DWORD *)(a3 - 16) & 1 )
  {
    *(_DWORD *)(a3 - 16) &= 0xFFFFFFFEu;
    sub_100179E0((void *)(a3 - 68), a2);
  }
}

//----- (1005B854) --------------------------------------------------------
void __usercall sub_1005B854(int a1<ebp>)
{
  **(_DWORD **)(a1 + 8) = &off_10060654;
}
// 10060654: using guessed type int (__stdcall *off_10060654)(char);

//----- (1005B85C) --------------------------------------------------------
#error "1005B868: call analysis failed (funcsize=7)"

//----- (1005B880) --------------------------------------------------------
#error "1005B88C: call analysis failed (funcsize=7)"

//----- (1005B8A0) --------------------------------------------------------
void __usercall sub_1005B8A0(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 76));
}

//----- (1005B8A8) --------------------------------------------------------
int __usercall sub_1005B8A8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 68);
}

//----- (1005B8B0) --------------------------------------------------------
void __usercall sub_1005B8B0(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 92));
}

//----- (1005B8B8) --------------------------------------------------------
int __usercall sub_1005B8B8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 44);
}

//----- (1005B8C0) --------------------------------------------------------
#error "1005B8CC: call analysis failed (funcsize=11)"

//----- (1005B8F0) --------------------------------------------------------
#error "1005B8FC: call analysis failed (funcsize=7)"

//----- (1005B910) --------------------------------------------------------
int __usercall sub_1005B910<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 40);
}

//----- (1005B918) --------------------------------------------------------
int __usercall sub_1005B918<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 64);
}

//----- (1005B920) --------------------------------------------------------
#error "1005B92C: call analysis failed (funcsize=7)"

//----- (1005B940) --------------------------------------------------------
int __usercall sub_1005B940<eax>(int a1<ebp>)
{
  int result; // eax@2
  int v2; // esi@1

  v2 = a1 - 60;
  if ( *(_DWORD *)(a1 - 60 + 32) >= 0x10u )
    result = sub_1002A4AA(*(LPVOID *)(a1 - 60 + 12));
  *(_DWORD *)(v2 + 32) = 15;
  *(_DWORD *)(v2 + 28) = 0;
  *(_BYTE *)(v2 + 12) = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005B948) --------------------------------------------------------
#error "1005B954: call analysis failed (funcsize=10)"

//----- (1005B970) --------------------------------------------------------
int __usercall sub_1005B970<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 16) & 1;
  if ( *(_DWORD *)(a2 - 16) & 1 )
  {
    *(_DWORD *)(a2 - 16) &= 0xFFFFFFFEu;
    result = sub_10001880(*(_DWORD *)(a2 - 20));
  }
  return result;
}

//----- (1005B989) --------------------------------------------------------
#error "1005B995: call analysis failed (funcsize=7)"

//----- (1005B9B0) --------------------------------------------------------
int __usercall sub_1005B9B0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 84);
}

//----- (1005B9B8) --------------------------------------------------------
int __usercall sub_1005B9B8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 48);
}

//----- (1005B9C0) --------------------------------------------------------
int __usercall sub_1005B9C0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 116);
}

//----- (1005B9C8) --------------------------------------------------------
int __usercall sub_1005B9C8<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 76, a2);
}

//----- (1005B9D0) --------------------------------------------------------
#error "1005B9DF: call analysis failed (funcsize=10)"

//----- (1005BA00) --------------------------------------------------------
int __usercall sub_1005BA00<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 100, a2);
}

//----- (1005BA08) --------------------------------------------------------
int __usercall sub_1005BA08<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 108);
}

//----- (1005BA10) --------------------------------------------------------
int __usercall sub_1005BA10<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 60);
}

//----- (1005BA18) --------------------------------------------------------
int __usercall sub_1005BA18<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 84);
}

//----- (1005BA20) --------------------------------------------------------
int __usercall sub_1005BA20<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 100, a2);
}

//----- (1005BA28) --------------------------------------------------------
int __usercall sub_1005BA28<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 100, a2);
}

//----- (1005BA30) --------------------------------------------------------
#error "1005BA3C: call analysis failed (funcsize=7)"

//----- (1005BA50) --------------------------------------------------------
int __usercall sub_1005BA50<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 44);
}

//----- (1005BA58) --------------------------------------------------------
int __usercall sub_1005BA58<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 60, a2);
}

//----- (1005BA60) --------------------------------------------------------
#error "1005BA6C: call analysis failed (funcsize=10)"

//----- (1005BA90) --------------------------------------------------------
int __usercall sub_1005BA90<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 84);
}

//----- (1005BA98) --------------------------------------------------------
int __usercall sub_1005BA98<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 60);
}

//----- (1005BAA0) --------------------------------------------------------
int __usercall sub_1005BAA0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 60);
}

//----- (1005BAA8) --------------------------------------------------------
#error "1005BAB4: call analysis failed (funcsize=7)"

//----- (1005BAD0) --------------------------------------------------------
int __usercall sub_1005BAD0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 40);
}

//----- (1005BAD8) --------------------------------------------------------
int __usercall sub_1005BAD8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 64);
}

//----- (1005BAE0) --------------------------------------------------------
#error "1005BAEC: call analysis failed (funcsize=7)"

//----- (1005BB00) --------------------------------------------------------
void __usercall sub_1005BB00(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 76));
}

//----- (1005BB08) --------------------------------------------------------
int __usercall sub_1005BB08<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 44);
}

//----- (1005BB10) --------------------------------------------------------
#error "1005BB1C: call analysis failed (funcsize=11)"

//----- (1005BB40) --------------------------------------------------------
void __cdecl sub_1005BB40()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005BB48) --------------------------------------------------------
#error "1005BB54: call analysis failed (funcsize=7)"

//----- (1005BB7F) --------------------------------------------------------
#error "1005BB8B: call analysis failed (funcsize=10)"

//----- (1005BBB0) --------------------------------------------------------
int __usercall sub_1005BBB0<eax>(int a1<ebp>)
{
  int result; // eax@3
  int v2; // ecx@3
  void **v3; // esi@1

  v3 = (void **)(a1 - 28);
  if ( !(unsigned __int8)sub_10029736() )
    sub_10017DB0(*v3);
  result = *(_DWORD *)(*(_DWORD *)*v3 + 4);
  v2 = *(_DWORD *)(*v3 + result + 56);
  if ( v2 )
    result = (*(int (**)(void))(*(_DWORD *)v2 + 8))();
  return result;
}
// 10029736: using guessed type int sub_10029736(void);

//----- (1005BBB8) --------------------------------------------------------
#error "1005BBC4: call analysis failed (funcsize=11)"

//----- (1005BBE0) --------------------------------------------------------
void __cdecl sub_1005BBE0()
{
  JUMPOUT(*(unsigned int *)loc_100183B0);
}
// 100183B0: using guessed type int loc_100183B0();

//----- (1005BBE8) --------------------------------------------------------
int __usercall sub_1005BBE8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 60);
}

//----- (1005BBF0) --------------------------------------------------------
#error "1005BBFC: call analysis failed (funcsize=7)"

//----- (1005BC10) --------------------------------------------------------
void __usercall sub_1005BC10(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 + 8));
}

//----- (1005BC18) --------------------------------------------------------
#error "1005BC24: call analysis failed (funcsize=7)"

//----- (1005BC40) --------------------------------------------------------
int __usercall sub_1005BC40<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 64);
}

//----- (1005BC48) --------------------------------------------------------
#error "1005BC54: call analysis failed (funcsize=10)"

//----- (1005BC70) --------------------------------------------------------
int __thiscall sub_1005BC70(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005BC81) --------------------------------------------------------
#error "1005BC8D: call analysis failed (funcsize=7)"

//----- (1005BCA0) --------------------------------------------------------
int __usercall sub_1005BCA0<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 20));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005BCAB) --------------------------------------------------------
int __usercall sub_1005BCAB<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 60, a2);
}

//----- (1005BCB3) --------------------------------------------------------
int __usercall sub_1005BCB3<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 84);
}

//----- (1005BCBB) --------------------------------------------------------
#error "1005BCC7: call analysis failed (funcsize=7)"

//----- (1005BCE0) --------------------------------------------------------
int __usercall sub_1005BCE0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 44);
}

//----- (1005BCE8) --------------------------------------------------------
int __usercall sub_1005BCE8<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 72));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005BCF3) --------------------------------------------------------
int __usercall sub_1005BCF3<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 60, a2);
}

//----- (1005BCFB) --------------------------------------------------------
int __usercall sub_1005BCFB<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 68);
}

//----- (1005BD03) --------------------------------------------------------
int __usercall sub_1005BD03<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 68);
}

//----- (1005BD0B) --------------------------------------------------------
int __usercall sub_1005BD0B<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 68);
}

//----- (1005BD13) --------------------------------------------------------
#error "1005BD1F: call analysis failed (funcsize=10)"

//----- (1005BD40) --------------------------------------------------------
int __usercall sub_1005BD40<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 56, a2);
}

//----- (1005BD48) --------------------------------------------------------
int __usercall sub_1005BD48<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 56, a2);
}

//----- (1005BD50) --------------------------------------------------------
int __usercall sub_1005BD50<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 56, a2);
}

//----- (1005BD58) --------------------------------------------------------
int __usercall sub_1005BD58<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 80);
}

//----- (1005BD60) --------------------------------------------------------
#error "1005BD6C: call analysis failed (funcsize=7)"

//----- (1005BD85) --------------------------------------------------------
#error "1005BD91: call analysis failed (funcsize=10)"

//----- (1005BDB0) --------------------------------------------------------
int __usercall sub_1005BDB0<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 48));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005BDBB) --------------------------------------------------------
int __usercall sub_1005BDBB<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 72, a2);
}

//----- (1005BDC3) --------------------------------------------------------
void __cdecl sub_1005BDC3()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005BDCB) --------------------------------------------------------
void __cdecl sub_1005BDCB()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005BDD3) --------------------------------------------------------
void __usercall sub_1005BDD3(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_10010C30(a3 - 40, a2);
}

//----- (1005BDDB) --------------------------------------------------------
void __cdecl sub_1005BDDB()
{
  JUMPOUT(*(unsigned int *)loc_1000FFF0);
}
// 1000FFF0: using guessed type int loc_1000FFF0();

//----- (1005BDE3) --------------------------------------------------------
#error "1005BDEF: call analysis failed (funcsize=10)"

//----- (1005BE10) --------------------------------------------------------
int __usercall sub_1005BE10<eax>(int a1<ebp>)
{
  return sub_100303A3(*(LPVOID *)(a1 + 8));
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (1005BE1B) --------------------------------------------------------
#error "1005BE27: call analysis failed (funcsize=7)"

//----- (1005BE40) --------------------------------------------------------
int __usercall sub_1005BE40<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 240);
}

//----- (1005BE4B) --------------------------------------------------------
int __usercall sub_1005BE4B<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 216);
}

//----- (1005BE56) --------------------------------------------------------
int __usercall sub_1005BE56<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 40);
}

//----- (1005BE5E) --------------------------------------------------------
char __usercall sub_1005BE5E<al>(int a1<ebp>)
{
  int v1; // esi@1
  int v3; // ecx@1

  v3 = a1 - 192;
  v1 = a1 - 192 + 80;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v3 + 4) + v3 + 80 - 80) = off_100679AC;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)v3 + 4) + v3 + 80 - 84) = *(_DWORD *)(*(_DWORD *)v3 + 4) - 80;
  sub_10012890(a1 - 192 + 4);
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 - 192) + 4) + a1 - 192 + 80 - 80) = off_100679B8;
  *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 - 192) + 4) + a1 - 192 + 80 - 84) = *(_DWORD *)(*(_DWORD *)(a1 - 192) + 4) - 8;
  *(_DWORD *)v1 = &off_10067398;
  return sub_100296B7(v1);
}
// 10067398: using guessed type int (__stdcall *off_10067398)(char);
// 100679AC: using guessed type int (*off_100679AC[6])();
// 100679B8: using guessed type int (*off_100679B8[3])();

//----- (1005BE69) --------------------------------------------------------
int __usercall sub_1005BE69<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 216);
}

//----- (1005BE74) --------------------------------------------------------
#error "1005BE83: call analysis failed (funcsize=10)"

//----- (1005BEA0) --------------------------------------------------------
int __usercall sub_1005BEA0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 136);
}

//----- (1005BEAB) --------------------------------------------------------
int __usercall sub_1005BEAB<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 64);
}

//----- (1005BEB3) --------------------------------------------------------
int __usercall sub_1005BEB3<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 112);
}

//----- (1005BEBB) --------------------------------------------------------
int __usercall sub_1005BEBB<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 88);
}

//----- (1005BEC3) --------------------------------------------------------
int __usercall sub_1005BEC3<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 40);
}

//----- (1005BECB) --------------------------------------------------------
int __usercall sub_1005BECB<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = a1 - 188;
  result = *(_DWORD *)(a1 - 188);
  if ( *(_DWORD *)(a1 - 188) )
  {
    sub_10018370(result, *(_DWORD *)(a1 - 188 + 4));
    result = sub_1002A4AA(*(LPVOID *)v2);
    *(_DWORD *)v2 = 0;
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005BED6) --------------------------------------------------------
int __usercall sub_1005BED6<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 160);
}

//----- (1005BEE1) --------------------------------------------------------
#error "1005BEF3: call analysis failed (funcsize=7)"

//----- (1005BF10) --------------------------------------------------------
void __usercall sub_1005BF10(int a1<ebp>)
{
  int v1; // eax@2
  int v2; // ecx@1

  v2 = *(_DWORD *)(*(_DWORD *)(a1 - 16) + 12);
  if ( v2 )
  {
    v1 = (*(int (**)(void))(*(_DWORD *)v2 + 8))();
    if ( v1 )
      (**(void (__thiscall ***)(_DWORD, _DWORD))v1)(v1, 1);
  }
}

//----- (1005BF1B) --------------------------------------------------------
#error "1005BF27: call analysis failed (funcsize=7)"

//----- (1005BF40) --------------------------------------------------------
void __usercall sub_1005BF40(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 92));
}

//----- (1005BF48) --------------------------------------------------------
void __usercall sub_1005BF48(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 96));
}

//----- (1005BF50) --------------------------------------------------------
#error "1005BF5C: call analysis failed (funcsize=10)"

//----- (1005BF80) --------------------------------------------------------
#error "1005BF8C: call analysis failed (funcsize=7)"

//----- (1005BFA0) --------------------------------------------------------
#error "1005BFAC: call analysis failed (funcsize=7)"

//----- (1005BFC0) --------------------------------------------------------
int __usercall sub_1005BFC0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 44);
}

//----- (1005BFC8) --------------------------------------------------------
int __usercall sub_1005BFC8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 68);
}

//----- (1005BFD0) --------------------------------------------------------
#error "1005BFDC: call analysis failed (funcsize=10)"

//----- (1005C000) --------------------------------------------------------
int __usercall sub_1005C000<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10019740(a2 - 144);
}

//----- (1005C00B) --------------------------------------------------------
#error "1005C01A: call analysis failed (funcsize=10)"

//----- (1005C040) --------------------------------------------------------
int __usercall sub_1005C040<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = a1 - 104;
  *(_DWORD *)(a1 - 104 + 32) = 0;
  result = *(_DWORD *)(a1 - 104 + 20);
  if ( result )
  {
    result = sub_1002A4AA(*(LPVOID *)(a1 - 104 + 20));
    *(_DWORD *)(v2 + 20) = 0;
    *(_DWORD *)(v2 + 24) = 0;
    *(_DWORD *)(v2 + 28) = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005C048) --------------------------------------------------------
#error "1005C054: call analysis failed (funcsize=10)"

//----- (1005C070) --------------------------------------------------------
int __usercall sub_1005C070<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 20) & 1;
  if ( *(_DWORD *)(a2 - 20) & 1 )
  {
    *(_DWORD *)(a2 - 20) &= 0xFFFFFFFEu;
    result = sub_10001880(*(_DWORD *)(a2 + 8));
  }
  return result;
}

//----- (1005C089) --------------------------------------------------------
LPVOID __usercall sub_1005C089<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_10019980((LPVOID *)(a2 - 32));
}

//----- (1005C091) --------------------------------------------------------
void __usercall sub_1005C091(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 + 16));
}

//----- (1005C099) --------------------------------------------------------
void __usercall sub_1005C099(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 + 16));
}

//----- (1005C0A1) --------------------------------------------------------
#error "1005C0AD: call analysis failed (funcsize=7)"

//----- (1005C0C0) --------------------------------------------------------
int __usercall sub_1005C0C0<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 40) & 1;
  if ( *(_DWORD *)(a2 - 40) & 1 )
  {
    *(_DWORD *)(a2 - 40) &= 0xFFFFFFFEu;
    result = sub_10001880(*(_DWORD *)(a2 - 44));
  }
  return result;
}

//----- (1005C0D9) --------------------------------------------------------
LPVOID __usercall sub_1005C0D9<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_10019980((LPVOID *)(a2 - 36));
}

//----- (1005C0E1) --------------------------------------------------------
void __usercall sub_1005C0E1(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 20));
}

//----- (1005C0E9) --------------------------------------------------------
void __usercall sub_1005C0E9(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 20));
}

//----- (1005C0F1) --------------------------------------------------------
#error "1005C0FD: call analysis failed (funcsize=7)"

//----- (1005C110) --------------------------------------------------------
void __cdecl sub_1005C110()
{
  JUMPOUT(*(unsigned int *)loc_100198B0);
}
// 100198B0: using guessed type int loc_100198B0();

//----- (1005C118) --------------------------------------------------------
void __cdecl sub_1005C118()
{
  JUMPOUT(*(unsigned int *)loc_100198B0);
}
// 100198B0: using guessed type int loc_100198B0();

//----- (1005C123) --------------------------------------------------------
LPVOID __usercall sub_1005C123<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_10019980((LPVOID *)(*(_DWORD *)(a2 - 20) + 64));
}

//----- (1005C12E) --------------------------------------------------------
#error "1005C13A: call analysis failed (funcsize=7)"

//----- (1005C150) --------------------------------------------------------
LPVOID __usercall sub_1005C150<eax>(LPVOID *this<ecx>, int a2<ebp>)
{
  return sub_10019980(*(LPVOID **)(a2 - 24));
}

//----- (1005C158) --------------------------------------------------------
LPVOID __usercall sub_1005C158<eax>(int a1<ebp>)
{
  LPVOID result; // eax@1
  LPVOID *v2; // ecx@1
  LPVOID *v3; // esi@1

  v2 = (LPVOID *)(*(_DWORD *)(a1 - 20) + 20);
  v3 = v2;
  *(_DWORD *)(*(_DWORD *)(a1 - 20) + 32) = 0;
  result = *v2;
  if ( *v2 )
  {
    result = (LPVOID)sub_1002A4AA(*v2);
    *v3 = 0;
    v3[1] = 0;
    v3[2] = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005C163) --------------------------------------------------------
#error "1005C16F: call analysis failed (funcsize=7)"

//----- (1005C180) --------------------------------------------------------
int __usercall sub_1005C180<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = *(_DWORD *)(a1 - 16) + 16;
  result = *(_DWORD *)(*(_DWORD *)(a1 - 16) + 24);
  if ( result )
  {
    result = sub_1002A4AA(*(LPVOID *)(*(_DWORD *)(a1 - 16) + 24));
    *(_DWORD *)(v2 + 8) = 0;
    *(_DWORD *)(v2 + 12) = 0;
    *(_DWORD *)(v2 + 16) = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005C18B) --------------------------------------------------------
#error "1005C197: call analysis failed (funcsize=7)"

//----- (1005C1B0) --------------------------------------------------------
int __usercall sub_1005C1B0<eax>(int a1<ebp>)
{
  int v1; // esi@4
  int result; // eax@1
  int v3; // ecx@2

  result = *(_DWORD *)(a1 - 16) & 1;
  if ( *(_DWORD *)(a1 - 16) & 1 )
  {
    *(_DWORD *)(a1 - 16) &= 0xFFFFFFFEu;
    v3 = *(_DWORD *)(a1 + 8);
    v1 = *(_DWORD *)(a1 + 8);
    result = *(_DWORD *)(v3 + 24);
    if ( result )
    {
      result = sub_1002A4AA(*(LPVOID *)(v3 + 24));
      *(_DWORD *)(v1 + 24) = 0;
      *(_DWORD *)(v1 + 28) = 0;
      *(_DWORD *)(v1 + 32) = 0;
    }
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005C1C9) --------------------------------------------------------
#error "1005C1D5: call analysis failed (funcsize=7)"

//----- (1005C1F0) --------------------------------------------------------
void __usercall sub_1005C1F0(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 16));
}

//----- (1005C1F8) --------------------------------------------------------
void __usercall sub_1005C1F8(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 + 8));
}

//----- (1005C200) --------------------------------------------------------
#error "1005C20C: call analysis failed (funcsize=7)"

//----- (1005C220) --------------------------------------------------------
int __usercall sub_1005C220<eax>(int a1<ebp>)
{
  char v1; // zf@2
  int v2; // ecx@4
  int result; // eax@1
  int v4; // esi@1

  v4 = a1 - 36;
  result = *(_DWORD *)(a1 - 36);
  if ( *(_DWORD *)(a1 - 36) )
  {
    v1 = *(_DWORD *)(result + 32)-- == 1;
    if ( v1 )
      result = sub_100183F0(*(_DWORD *)(a1 - 36), 0);
  }
  *(_DWORD *)v4 = 0;
  v2 = *(_DWORD *)(v4 + 12);
  if ( v2 )
  {
    result = (*(int (**)(void))(*(_DWORD *)v2 + 8))();
    if ( result )
      result = (**(int (__thiscall ***)(_DWORD, _DWORD))result)(result, 1);
  }
  return result;
}

//----- (1005C228) --------------------------------------------------------
void __cdecl sub_1005C228()
{
  JUMPOUT(*(unsigned int *)loc_10018B70);
}
// 10018B70: using guessed type int loc_10018B70();

//----- (1005C233) --------------------------------------------------------
void __cdecl sub_1005C233()
{
  JUMPOUT(*(unsigned int *)loc_10018B70);
}
// 10018B70: using guessed type int loc_10018B70();

//----- (1005C23E) --------------------------------------------------------
int __usercall sub_1005C23E<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 60);
}

//----- (1005C246) --------------------------------------------------------
#error "1005C255: call analysis failed (funcsize=10)"

//----- (1005C270) --------------------------------------------------------
void __usercall sub_1005C270(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 16));
}

//----- (1005C278) --------------------------------------------------------
#error "1005C284: call analysis failed (funcsize=7)"

//----- (1005C2A0) --------------------------------------------------------
int __usercall sub_1005C2A0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 48);
}

//----- (1005C2A8) --------------------------------------------------------
#error "1005C2B4: call analysis failed (funcsize=10)"

//----- (1005C2D0) --------------------------------------------------------
void __usercall sub_1005C2D0(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 16));
}

//----- (1005C2D8) --------------------------------------------------------
void __usercall sub_1005C2D8(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 20));
}

//----- (1005C2E0) --------------------------------------------------------
#error "1005C2EC: call analysis failed (funcsize=7)"

//----- (1005C300) --------------------------------------------------------
#error "1005C30C: call analysis failed (funcsize=7)"

//----- (1005C320) --------------------------------------------------------
#error "1005C32C: call analysis failed (funcsize=7)"

//----- (1005C340) --------------------------------------------------------
void __usercall sub_1005C340(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 28));
}

//----- (1005C348) --------------------------------------------------------
#error "1005C354: call analysis failed (funcsize=10)"

//----- (1005C370) --------------------------------------------------------
void __cdecl sub_1005C370()
{
  JUMPOUT(*(unsigned int *)loc_10019910);
}
// 10019910: using guessed type int loc_10019910();

//----- (1005C378) --------------------------------------------------------
void __cdecl sub_1005C378()
{
  JUMPOUT(*(unsigned int *)loc_100198B0);
}
// 100198B0: using guessed type int loc_100198B0();

//----- (1005C380) --------------------------------------------------------
void __cdecl sub_1005C380()
{
  JUMPOUT(*(unsigned int *)loc_10019910);
}
// 10019910: using guessed type int loc_10019910();

//----- (1005C388) --------------------------------------------------------
void __cdecl sub_1005C388()
{
  JUMPOUT(*(unsigned int *)loc_100198B0);
}
// 100198B0: using guessed type int loc_100198B0();

//----- (1005C390) --------------------------------------------------------
#error "1005C39C: call analysis failed (funcsize=10)"

//----- (1005C3C0) --------------------------------------------------------
int __usercall sub_1005C3C0<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = a1 - 80;
  *(_DWORD *)(a1 - 80 + 16) = 0;
  result = *(_DWORD *)(a1 - 80 + 4);
  if ( result )
  {
    result = sub_1002A4AA(*(LPVOID *)(a1 - 80 + 4));
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
    *(_DWORD *)(v2 + 12) = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005C3C8) --------------------------------------------------------
int __usercall sub_1005C3C8<eax>(int a1<ebp>)
{
  int result; // eax@3
  int v2; // esi@1

  v2 = a1 - 80;
  if ( *(_DWORD *)(a1 - 80 + 20) )
  {
    sub_1002A4AA(*(LPVOID *)(a1 - 80 + 20));
    *(_DWORD *)(v2 + 20) = 0;
    *(_DWORD *)(v2 + 24) = 0;
    *(_DWORD *)(v2 + 28) = 0;
  }
  *(_DWORD *)(v2 + 16) = 0;
  result = *(_DWORD *)(v2 + 4);
  if ( result )
  {
    result = sub_1002A4AA(*(LPVOID *)(v2 + 4));
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
    *(_DWORD *)(v2 + 12) = 0;
  }
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005C3D0) --------------------------------------------------------
void __cdecl sub_1005C3D0()
{
  JUMPOUT(*(unsigned int *)loc_10019910);
}
// 10019910: using guessed type int loc_10019910();

//----- (1005C3D8) --------------------------------------------------------
void __cdecl sub_1005C3D8()
{
  JUMPOUT(*(unsigned int *)loc_100198B0);
}
// 100198B0: using guessed type int loc_100198B0();

//----- (1005C3E0) --------------------------------------------------------
#error "1005C3EC: call analysis failed (funcsize=10)"

//----- (1005C410) --------------------------------------------------------
void __cdecl sub_1005C410()
{
  JUMPOUT(*(unsigned int *)loc_10019910);
}
// 10019910: using guessed type int loc_10019910();

//----- (1005C418) --------------------------------------------------------
void __cdecl sub_1005C418()
{
  JUMPOUT(*(unsigned int *)loc_100198B0);
}
// 100198B0: using guessed type int loc_100198B0();

//----- (1005C420) --------------------------------------------------------
#error "1005C42C: call analysis failed (funcsize=10)"

//----- (1005C450) --------------------------------------------------------
int __usercall sub_1005C450<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 96));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005C45B) --------------------------------------------------------
int __usercall sub_1005C45B<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 100) & 1;
  if ( *(_DWORD *)(a2 - 100) & 1 )
  {
    *(_DWORD *)(a2 - 100) &= 0xFFFFFFFEu;
    result = sub_10001880(a2 - 92);
  }
  return result;
}

//----- (1005C474) --------------------------------------------------------
#error "1005C480: call analysis failed (funcsize=7)"

//----- (1005C490) --------------------------------------------------------
void __usercall sub_1005C490(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 16));
}

//----- (1005C498) --------------------------------------------------------
#error "1005C4A4: call analysis failed (funcsize=7)"

//----- (1005C4C0) --------------------------------------------------------
void __usercall sub_1005C4C0(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 16));
}

//----- (1005C4C8) --------------------------------------------------------
#error "1005C4D4: call analysis failed (funcsize=7)"

//----- (1005C4F0) --------------------------------------------------------
void __cdecl sub_1005C4F0()
{
  JUMPOUT(*(unsigned int *)loc_10019910);
}
// 10019910: using guessed type int loc_10019910();

//----- (1005C4F8) --------------------------------------------------------
#error "1005C504: call analysis failed (funcsize=11)"

//----- (1005C520) --------------------------------------------------------
int __usercall sub_1005C520<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 64);
}

//----- (1005C528) --------------------------------------------------------
#error "1005C534: call analysis failed (funcsize=7)"

//----- (1005C550) --------------------------------------------------------
int __usercall sub_1005C550<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 16) & 1;
  if ( *(_DWORD *)(a2 - 16) & 1 )
  {
    *(_DWORD *)(a2 - 16) &= 0xFFFFFFFEu;
    result = sub_10001880(*(_DWORD *)(a2 + 8));
  }
  return result;
}

//----- (1005C569) --------------------------------------------------------
#error "1005C575: call analysis failed (funcsize=7)"

//----- (1005C590) --------------------------------------------------------
void __usercall sub_1005C590(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 + 12));
}

//----- (1005C598) --------------------------------------------------------
#error "1005C5A4: call analysis failed (funcsize=7)"

//----- (1005C5C0) --------------------------------------------------------
int __usercall sub_1005C5C0<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 68) & 1;
  if ( *(_DWORD *)(a2 - 68) & 1 )
  {
    *(_DWORD *)(a2 - 68) &= 0xFFFFFFFEu;
    result = sub_10001880(a2 - 40);
  }
  return result;
}

//----- (1005C5D9) --------------------------------------------------------
#error "1005C5E5: call analysis failed (funcsize=7)"

//----- (1005C600) --------------------------------------------------------
void __usercall sub_1005C600(void *this<ecx>, int a2<ebp>)
{
  sub_10017D50((void *)(a2 - 48));
}

//----- (1005C608) --------------------------------------------------------
#error "1005C614: call analysis failed (funcsize=10)"

//----- (1005C630) --------------------------------------------------------
int __usercall sub_1005C630<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 8);
}

//----- (1005C638) --------------------------------------------------------
int __usercall sub_1005C638<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 96);
}

//----- (1005C640) --------------------------------------------------------
int __usercall sub_1005C640<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 100));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005C64B) --------------------------------------------------------
#error "1005C657: call analysis failed (funcsize=10)"

//----- (1005C670) --------------------------------------------------------
int __usercall sub_1005C670<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 12);
}

//----- (1005C678) --------------------------------------------------------
int __usercall sub_1005C678<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 100);
}

//----- (1005C680) --------------------------------------------------------
int __usercall sub_1005C680<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 104));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005C68B) --------------------------------------------------------
#error "1005C697: call analysis failed (funcsize=10)"

//----- (1005C6B0) --------------------------------------------------------
void __cdecl sub_1005C6B0()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005C6B8) --------------------------------------------------------
int __usercall sub_1005C6B8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 - 48);
}

//----- (1005C6C0) --------------------------------------------------------
void __cdecl sub_1005C6C0()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005C6C8) --------------------------------------------------------
#error "1005C6D4: call analysis failed (funcsize=7)"

//----- (1005C6F0) --------------------------------------------------------
#error "1005C6FC: call analysis failed (funcsize=7)"

//----- (1005C710) --------------------------------------------------------
int __usercall sub_1005C710<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 16) & 1;
  if ( *(_DWORD *)(a1 - 16) & 1 )
  {
    *(_DWORD *)(a1 - 16) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005C729) --------------------------------------------------------
#error "1005C735: call analysis failed (funcsize=7)"

//----- (1005C750) --------------------------------------------------------
int *__usercall sub_1005C750<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10026C50(a2 - 28);
}

//----- (1005C758) --------------------------------------------------------
void __cdecl sub_1005C758()
{
  JUMPOUT(*(unsigned int *)loc_10023420);
}
// 10023420: using guessed type int loc_10023420();

//----- (1005C760) --------------------------------------------------------
void __cdecl sub_1005C760()
{
  JUMPOUT(*(unsigned int *)loc_10023420);
}
// 10023420: using guessed type int loc_10023420();

//----- (1005C76B) --------------------------------------------------------
int __usercall sub_1005C76B<eax>(int a1<ebp>)
{
  return sub_1002C0CE(a1);
}

//----- (1005C773) --------------------------------------------------------
int __usercall sub_1005C773<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10026F10((void *)(a2 - 136));
}

//----- (1005C77E) --------------------------------------------------------
#error "1005C78D: call analysis failed (funcsize=10)"

//----- (1005C7B0) --------------------------------------------------------
void __usercall sub_1005C7B0(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_10025F00(*(_DWORD *)(a3 - 16) + 4, a2);
}

//----- (1005C7BB) --------------------------------------------------------
#error "1005C7C7: call analysis failed (funcsize=7)"

//----- (1005C7E0) --------------------------------------------------------
void __cdecl sub_1005C7E0()
{
  JUMPOUT(*(unsigned int *)loc_10023420);
}
// 10023420: using guessed type int loc_10023420();

//----- (1005C7E8) --------------------------------------------------------
void __cdecl sub_1005C7E8()
{
  JUMPOUT(loc_10024010);
}

//----- (1005C7F3) --------------------------------------------------------
void __usercall sub_1005C7F3(void *a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_100238D0((void *)(*(_DWORD *)(a3 - 16) + 24), a2);
}

//----- (1005C7FE) --------------------------------------------------------
int __usercall sub_1005C7FE<eax>(int a1<ebp>)
{
  return j_nullsub_2(*(_DWORD *)(a1 - 16) + 176);
}
// 10028260: using guessed type int __thiscall j_nullsub_2(_DWORD);

//----- (1005C80C) --------------------------------------------------------
#error "1005C818: call analysis failed (funcsize=7)"

//----- (1005C830) --------------------------------------------------------
void __usercall sub_1005C830(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = &off_10068264;
}
// 10068264: using guessed type int (__stdcall *off_10068264)(char);

//----- (1005C838) --------------------------------------------------------
int __usercall sub_1005C838<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10024F90((void *)(*(_DWORD *)(a2 - 16) + 4));
}

//----- (1005C843) --------------------------------------------------------
void __usercall sub_1005C843(void *a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_100238D0((void *)(*(_DWORD *)(a3 - 16) + 96), a2);
}

//----- (1005C84E) --------------------------------------------------------
#error "1005C85A: call analysis failed (funcsize=7)"

//----- (1005C870) --------------------------------------------------------
int __usercall sub_1005C870<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 16));
}

//----- (1005C878) --------------------------------------------------------
int __usercall sub_1005C878<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 16) + 24);
}

//----- (1005C883) --------------------------------------------------------
int __usercall sub_1005C883<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 16) + 48);
}

//----- (1005C88E) --------------------------------------------------------
int __usercall sub_1005C88E<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 16) + 88);
}

//----- (1005C899) --------------------------------------------------------
void __cdecl sub_1005C899()
{
  JUMPOUT(*(unsigned int *)loc_10018540);
}
// 10018540: using guessed type int loc_10018540();

//----- (1005C8A7) --------------------------------------------------------
void __cdecl sub_1005C8A7()
{
  JUMPOUT(*(unsigned int *)loc_10018540);
}
// 10018540: using guessed type int loc_10018540();

//----- (1005C8B5) --------------------------------------------------------
int __usercall sub_1005C8B5<eax>(int a1<ebp>)
{
  return sub_10022FB0(*(_DWORD *)(a1 - 16) + 224);
}
// 10022FB0: using guessed type int __thiscall sub_10022FB0(_DWORD);

//----- (1005C8C3) --------------------------------------------------------
int __usercall sub_1005C8C3<eax>(int a1<ebp>)
{
  return sub_100230B0(*(_DWORD *)(a1 - 16) + 236);
}
// 100230B0: using guessed type int __thiscall sub_100230B0(_DWORD);

//----- (1005C8D1) --------------------------------------------------------
void __cdecl sub_1005C8D1()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005C8D9) --------------------------------------------------------
int __usercall sub_1005C8D9<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 - 48);
}

//----- (1005C8E1) --------------------------------------------------------
int __usercall sub_1005C8E1<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10023430(*(_DWORD *)(a3 - 20), a2);
}

//----- (1005C8E9) --------------------------------------------------------
void __cdecl sub_1005C8E9()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005C8F1) --------------------------------------------------------
int __usercall sub_1005C8F1<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(*(_DWORD *)(a2 - 20) + 248);
}

//----- (1005C8FF) --------------------------------------------------------
int __usercall sub_1005C8FF<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100230C0(*(_DWORD *)(a3 - 16) + 256, a2);
}

//----- (1005C90D) --------------------------------------------------------
void __cdecl sub_1005C90D()
{
  JUMPOUT(*(unsigned int *)loc_10023D80);
}
// 10023D80: using guessed type int loc_10023D80();

//----- (1005C91B) --------------------------------------------------------
void __cdecl sub_1005C91B()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005C929) --------------------------------------------------------
int __usercall sub_1005C929<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 16) + 540);
}
// 1002C171: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005C937) --------------------------------------------------------
int __usercall sub_1005C937<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 16) + 580);
}
// 1002C171: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005C945) --------------------------------------------------------
#error "1005C951: call analysis failed (funcsize=7)"

//----- (1005C960) --------------------------------------------------------
void __cdecl sub_1005C960()
{
  JUMPOUT(*(unsigned int *)loc_10023420);
}
// 10023420: using guessed type int loc_10023420();

//----- (1005C968) --------------------------------------------------------
#error "1005C974: call analysis failed (funcsize=7)"

//----- (1005C990) --------------------------------------------------------
void __cdecl sub_1005C990()
{
  JUMPOUT(*(unsigned int *)loc_10024D30);
}
// 10024D30: using guessed type int loc_10024D30();

//----- (1005C99B) --------------------------------------------------------
#error "1005C9A7: call analysis failed (funcsize=7)"

//----- (1005C9C0) --------------------------------------------------------
void __usercall sub_1005C9C0(int a1<ebp>)
{
  **(_DWORD **)(a1 - 16) = &off_10068320;
}
// 10068320: using guessed type int (__stdcall *off_10068320)(char);

//----- (1005C9C8) --------------------------------------------------------
int __usercall sub_1005C9C8<eax>(int a1<ebp>)
{
  return sub_1002C0CE(a1);
}

//----- (1005C9D3) --------------------------------------------------------
int __usercall sub_1005C9D3<eax>(int a1<ebp>)
{
  return j_nullsub_2(*(_DWORD *)(a1 - 16) + 52);
}
// 10028260: using guessed type int __thiscall j_nullsub_2(_DWORD);

//----- (1005C9DE) --------------------------------------------------------
void __cdecl sub_1005C9DE()
{
  JUMPOUT(loc_10024010);
}

//----- (1005C9E9) --------------------------------------------------------
#error "1005C9F5: call analysis failed (funcsize=7)"

//----- (1005CA10) --------------------------------------------------------
int __usercall sub_1005CA10<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_10023430(*(_DWORD *)(a3 - 16), a2);
}

//----- (1005CA18) --------------------------------------------------------
int __usercall sub_1005CA18<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(*(_DWORD *)(a2 - 16) + 248);
}

//----- (1005CA26) --------------------------------------------------------
#error "1005CA32: call analysis failed (funcsize=7)"

//----- (1005CA50) --------------------------------------------------------
void __usercall sub_1005CA50(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_10029FBF(*(_DWORD *)(a3 - 16), a2);
}

//----- (1005CA58) --------------------------------------------------------
#error "1005CA64: call analysis failed (funcsize=7)"

//----- (1005CA80) --------------------------------------------------------
void __cdecl sub_1005CA80()
{
  JUMPOUT(*(unsigned int *)loc_10024D30);
}
// 10024D30: using guessed type int loc_10024D30();

//----- (1005CA8B) --------------------------------------------------------
#error "1005CA97: call analysis failed (funcsize=7)"

//----- (1005CAB0) --------------------------------------------------------
void __usercall sub_1005CAB0(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_10025F00(*(_DWORD *)(a3 - 16) + 4, a2);
}

//----- (1005CABB) --------------------------------------------------------
int __usercall sub_1005CABB<eax>(int a1<ebp>)
{
  return j_nullsub_2(*(_DWORD *)(a1 - 16) + 24);
}
// 10028260: using guessed type int __thiscall j_nullsub_2(_DWORD);

//----- (1005CAC6) --------------------------------------------------------
int __usercall sub_1005CAC6<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(*(_DWORD *)(a2 - 16) + 80);
}

//----- (1005CAD1) --------------------------------------------------------
int __usercall sub_1005CAD1<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(*(_DWORD *)(a2 - 16) + 104);
}

//----- (1005CADC) --------------------------------------------------------
int __usercall sub_1005CADC<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(*(_DWORD *)(a2 - 16) + 128);
}

//----- (1005CAEA) --------------------------------------------------------
#error "1005CAF6: call analysis failed (funcsize=7)"

//----- (1005CB10) --------------------------------------------------------
void __cdecl sub_1005CB10()
{
  JUMPOUT(*(unsigned int *)loc_10023420);
}
// 10023420: using guessed type int loc_10023420();

//----- (1005CB18) --------------------------------------------------------
void __cdecl sub_1005CB18()
{
  JUMPOUT(loc_10024010);
}

//----- (1005CB23) --------------------------------------------------------
void __usercall sub_1005CB23(void *a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_100238D0((void *)(*(_DWORD *)(a3 - 16) + 24), a2);
}

//----- (1005CB2E) --------------------------------------------------------
int __usercall sub_1005CB2E<eax>(int a1<ebp>)
{
  return j_nullsub_2(*(_DWORD *)(a1 - 16) + 176);
}
// 10028260: using guessed type int __thiscall j_nullsub_2(_DWORD);

//----- (1005CB3C) --------------------------------------------------------
#error "1005CB48: call analysis failed (funcsize=7)"

//----- (1005CB60) --------------------------------------------------------
int __usercall sub_1005CB60<eax>(int a1<ebp>)
{
  return j_nullsub_2(*(_DWORD *)(a1 - 16));
}
// 10028260: using guessed type int __thiscall j_nullsub_2(_DWORD);

//----- (1005CB68) --------------------------------------------------------
void __cdecl sub_1005CB68()
{
  JUMPOUT(*(unsigned int *)loc_10024D30);
}
// 10024D30: using guessed type int loc_10024D30();

//----- (1005CB73) --------------------------------------------------------
#error "1005CB7F: call analysis failed (funcsize=7)"

//----- (1005CB90) --------------------------------------------------------
void __cdecl sub_1005CB90()
{
  JUMPOUT(*(unsigned int *)loc_100238B0);
}
// 100238B0: using guessed type int loc_100238B0();

//----- (1005CB98) --------------------------------------------------------
int __usercall sub_1005CB98<eax>(void *this<ecx>, int a2<ebp>)
{
  return sub_10024F90((void *)(*(_DWORD *)(a2 - 16) + 4));
}

//----- (1005CBA3) --------------------------------------------------------
void __usercall sub_1005CBA3(void *a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  sub_100238D0((void *)(*(_DWORD *)(a3 - 16) + 96), a2);
}

//----- (1005CBAE) --------------------------------------------------------
int __usercall sub_1005CBAE<eax>(int a1<ebp>)
{
  return j_nullsub_2(*(_DWORD *)(a1 - 20));
}
// 10028260: using guessed type int __thiscall j_nullsub_2(_DWORD);

//----- (1005CBB6) --------------------------------------------------------
void __cdecl sub_1005CBB6()
{
  JUMPOUT(*(unsigned int *)loc_10024D30);
}
// 10024D30: using guessed type int loc_10024D30();

//----- (1005CBC1) --------------------------------------------------------
#error "1005CBCD: call analysis failed (funcsize=7)"

//----- (1005CBE0) --------------------------------------------------------
void __usercall sub_1005CBE0(int this<ecx>, int a2<ebp>)
{
  sub_100311BB(*(_DWORD *)(a2 - 20));
}

//----- (1005CBE8) --------------------------------------------------------
void __usercall sub_1005CBE8(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>)
{
  sub_10024130(*(_DWORD *)(a4 - 20) + 16, a2, a3);
}

//----- (1005CBF3) --------------------------------------------------------
#error "1005CBFF: call analysis failed (funcsize=7)"

//----- (1005CC10) --------------------------------------------------------
int __usercall sub_1005CC10<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 16));
}

//----- (1005CC18) --------------------------------------------------------
int __usercall sub_1005CC18<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 16) + 24);
}

//----- (1005CC23) --------------------------------------------------------
int __usercall sub_1005CC23<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 16) + 48);
}

//----- (1005CC2E) --------------------------------------------------------
int __usercall sub_1005CC2E<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 16) + 88);
}

//----- (1005CC39) --------------------------------------------------------
int __usercall sub_1005CC39<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = *(_DWORD *)(a1 - 16) + 136;
  result = *(_DWORD *)(*(_DWORD *)(a1 - 16) + 164);
  if ( result )
  {
    result = sub_1002A4AA(*(LPVOID *)(*(_DWORD *)(a1 - 16) + 164));
    *(_DWORD *)(v2 + 28) = 0;
    *(_DWORD *)(v2 + 32) = 0;
    *(_DWORD *)(v2 + 36) = 0;
  }
  if ( *(_DWORD *)(v2 + 24) >= 0x10u )
    result = sub_1002A4AA(*(LPVOID *)(v2 + 4));
  *(_DWORD *)(v2 + 24) = 15;
  *(_DWORD *)(v2 + 20) = 0;
  *(_BYTE *)(v2 + 4) = 0;
  return result;
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005CC47) --------------------------------------------------------
void __cdecl sub_1005CC47()
{
  JUMPOUT(*(unsigned int *)loc_10018540);
}
// 10018540: using guessed type int loc_10018540();

//----- (1005CC55) --------------------------------------------------------
int __usercall sub_1005CC55<eax>(int a1<ebp>)
{
  return sub_10022FB0(*(_DWORD *)(a1 - 16) + 224);
}
// 10022FB0: using guessed type int __thiscall sub_10022FB0(_DWORD);

//----- (1005CC63) --------------------------------------------------------
int __usercall sub_1005CC63<eax>(int a1<ebp>)
{
  return sub_100230B0(*(_DWORD *)(a1 - 16) + 236);
}
// 100230B0: using guessed type int __thiscall sub_100230B0(_DWORD);

//----- (1005CC71) --------------------------------------------------------
int __usercall sub_1005CC71<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100230C0(*(_DWORD *)(a3 - 16) + 256, a2);
}

//----- (1005CC7F) --------------------------------------------------------
void __cdecl sub_1005CC7F()
{
  JUMPOUT(*(unsigned int *)loc_10023D80);
}
// 10023D80: using guessed type int loc_10023D80();

//----- (1005CC8D) --------------------------------------------------------
void __cdecl sub_1005CC8D()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005CC9B) --------------------------------------------------------
int __usercall sub_1005CC9B<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 16) + 540);
}
// 1002C171: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005CCA9) --------------------------------------------------------
int __usercall sub_1005CCA9<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 16) + 580);
}
// 1002C171: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005CCB7) --------------------------------------------------------
int __usercall sub_1005CCB7<eax>(int a1<ebp>)
{
  return nullsub_2(*(_DWORD *)(a1 - 16) + 612);
}
// 1002C171: using guessed type int __thiscall nullsub_2(_DWORD);

//----- (1005CCC5) --------------------------------------------------------
#error "1005CCD1: call analysis failed (funcsize=7)"

//----- (1005CCE0) --------------------------------------------------------
char __usercall sub_1005CCE0<al>(void *this<ecx>, int a2<ebp>)
{
  return sub_1002B6E4((void *)(a2 - 20));
}

//----- (1005CCE8) --------------------------------------------------------
#error "1005CCF4: call analysis failed (funcsize=10)"

//----- (1005CD10) --------------------------------------------------------
void __cdecl sub_1005CD10()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005CD18) --------------------------------------------------------
int __usercall sub_1005CD18<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 40, a2);
}

//----- (1005CD20) --------------------------------------------------------
int __usercall sub_1005CD20<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 80, a2);
}

//----- (1005CD28) --------------------------------------------------------
int __usercall sub_1005CD28<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 304, a2);
}

//----- (1005CD33) --------------------------------------------------------
int __usercall sub_1005CD33<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 96, a2);
}

//----- (1005CD3B) --------------------------------------------------------
int __usercall sub_1005CD3B<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 260);
}

//----- (1005CD46) --------------------------------------------------------
int __usercall sub_1005CD46<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 212);
}

//----- (1005CD51) --------------------------------------------------------
int __usercall sub_1005CD51<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 112, a2);
}

//----- (1005CD59) --------------------------------------------------------
int __usercall sub_1005CD59<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 140);
}

//----- (1005CD64) --------------------------------------------------------
int __usercall sub_1005CD64<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 164);
}

//----- (1005CD6F) --------------------------------------------------------
int __usercall sub_1005CD6F<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 188);
}

//----- (1005CD7A) --------------------------------------------------------
int __usercall sub_1005CD7A<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 236);
}

//----- (1005CD85) --------------------------------------------------------
int __usercall sub_1005CD85<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 284);
}

//----- (1005CD90) --------------------------------------------------------
int __usercall sub_1005CD90<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 328);
}

//----- (1005CD9B) --------------------------------------------------------
#error "1005CDAA: call analysis failed (funcsize=10)"

//----- (1005CDD0) --------------------------------------------------------
int __usercall sub_1005CDD0<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 24));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005CDDB) --------------------------------------------------------
void __usercall sub_1005CDDB(int this<ecx>, int a2<ebp>)
{
  sub_100311BB(*(_DWORD *)(a2 - 24));
}

//----- (1005CDE3) --------------------------------------------------------
void __usercall sub_1005CDE3(int a1<ecx>, int a2<ebx>, int a3<edi>, int a4<ebp>)
{
  sub_10024130(*(_DWORD *)(a4 - 24) + 16, a2, a3);
}

//----- (1005CDEE) --------------------------------------------------------
#error "1005CDFA: call analysis failed (funcsize=7)"

//----- (1005CE10) --------------------------------------------------------
void __cdecl sub_1005CE10()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005CE18) --------------------------------------------------------
#error "1005CE24: call analysis failed (funcsize=7)"

//----- (1005CE40) --------------------------------------------------------
void __cdecl sub_1005CE40()
{
  sub_1002B6D6();
}

//----- (1005CE48) --------------------------------------------------------
void __cdecl sub_1005CE48()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005CE50) --------------------------------------------------------
#error "1005CE5C: call analysis failed (funcsize=10)"

//----- (1005CE80) --------------------------------------------------------
void __cdecl sub_1005CE80()
{
  sub_1002B6D6();
}

//----- (1005CE88) --------------------------------------------------------
void __cdecl sub_1005CE88()
{
  JUMPOUT(*(unsigned int *)loc_1000A500);
}
// 1000A500: using guessed type int loc_1000A500();

//----- (1005CE90) --------------------------------------------------------
#error "1005CE9C: call analysis failed (funcsize=10)"

//----- (1005CEC0) --------------------------------------------------------
int __usercall sub_1005CEC0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 8);
}

//----- (1005CEC8) --------------------------------------------------------
void __cdecl sub_1005CEC8()
{
  sub_1002B6D6();
}

//----- (1005CED0) --------------------------------------------------------
#error "1005CEDC: call analysis failed (funcsize=10)"

//----- (1005CF00) --------------------------------------------------------
char __usercall sub_1005CF00<al>(void *this<ecx>, int a2<ebp>)
{
  return sub_1002B6E4((void *)(a2 - 44));
}

//----- (1005CF08) --------------------------------------------------------
int __usercall sub_1005CF08<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int result; // eax@2

  v1 = *(_DWORD *)(a1 - 48);
  if ( v1 )
    result = (**(int (__stdcall ***)(_DWORD))v1)(1);
  return result;
}

//----- (1005CF10) --------------------------------------------------------
#error "1005CF1C: call analysis failed (funcsize=10)"

//----- (1005CF40) --------------------------------------------------------
int __usercall sub_1005CF40<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 12);
}

//----- (1005CF48) --------------------------------------------------------
void __cdecl sub_1005CF48()
{
  sub_1002B6D6();
}

//----- (1005CF50) --------------------------------------------------------
void __cdecl sub_1005CF50()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005CF58) --------------------------------------------------------
int __usercall sub_1005CF58<eax>(int a1<ebp>)
{
  return sub_1002A4AA(*(LPVOID *)(a1 - 88));
}
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);

//----- (1005CF63) --------------------------------------------------------
int __usercall sub_1005CF63<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 72) & 1;
  if ( *(_DWORD *)(a1 - 72) & 1 )
  {
    *(_DWORD *)(a1 - 72) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005CF7C) --------------------------------------------------------
void __cdecl sub_1005CF7C()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005CF84) --------------------------------------------------------
int __usercall sub_1005CF84<eax>(int a1<ebp>)
{
  int v1; // ecx@1
  int result; // eax@2

  v1 = *(_DWORD *)(a1 - 84 + 4);
  if ( v1 )
  {
    result = v1 + 8;
    _EDX = -1;
    __asm { lock xadd [eax], edx }
    if ( _ZF )
      result = (*(int (__fastcall **)(int, int))(*(_DWORD *)v1 + 4))(v1, _EDX);
  }
  return result;
}

//----- (1005CF8C) --------------------------------------------------------
#error "1005CF98: call analysis failed (funcsize=10)"

//----- (1005CFC0) --------------------------------------------------------
int __usercall sub_1005CFC0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 64);
}

//----- (1005CFC8) --------------------------------------------------------
int __usercall sub_1005CFC8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 40);
}

//----- (1005CFD0) --------------------------------------------------------
int __usercall sub_1005CFD0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 + 16);
}

//----- (1005CFD8) --------------------------------------------------------
void __cdecl sub_1005CFD8()
{
  sub_1002B6D6();
}

//----- (1005CFE0) --------------------------------------------------------
#error "1005CFEC: call analysis failed (funcsize=10)"

//----- (1005D010) --------------------------------------------------------
int __usercall sub_1005D010<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 52, a2);
}

//----- (1005D018) --------------------------------------------------------
int __usercall sub_1005D018<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005D020) --------------------------------------------------------
int __usercall sub_1005D020<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005D028) --------------------------------------------------------
int __usercall sub_1005D028<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005D030) --------------------------------------------------------
int __usercall sub_1005D030<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005D038) --------------------------------------------------------
int __usercall sub_1005D038<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005D040) --------------------------------------------------------
int __usercall sub_1005D040<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005D048) --------------------------------------------------------
int __usercall sub_1005D048<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005D050) --------------------------------------------------------
int __usercall sub_1005D050<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005D058) --------------------------------------------------------
int __usercall sub_1005D058<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005D060) --------------------------------------------------------
int __usercall sub_1005D060<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(a3 - 36, a2);
}

//----- (1005D068) --------------------------------------------------------
int __usercall sub_1005D068<eax>(int a1<ecx>, int a2<ebx>, int a3<ebp>)
{
  return sub_100101D0(*(_DWORD *)(a3 - 72), a2);
}

//----- (1005D070) --------------------------------------------------------
void __cdecl sub_1005D070()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005D078) --------------------------------------------------------
int __usercall sub_1005D078<eax>(int a1<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a1 - 64) & 1;
  if ( *(_DWORD *)(a1 - 64) & 1 )
  {
    *(_DWORD *)(a1 - 64) &= 0xFFFFFFFEu;
    JUMPOUT(*(unsigned int *)loc_100029B0);
  }
  return result;
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005D091) --------------------------------------------------------
#error "1005D09D: call analysis failed (funcsize=10)"

//----- (1005D0C0) --------------------------------------------------------
void __cdecl sub_1005D0C0()
{
  sub_1002B6D6();
}

//----- (1005D0C8) --------------------------------------------------------
void __cdecl sub_1005D0C8()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005D0D0) --------------------------------------------------------
#error "1005D0DC: call analysis failed (funcsize=11)"

//----- (1005D100) --------------------------------------------------------
void __cdecl sub_1005D100()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005D108) --------------------------------------------------------
void __cdecl sub_1005D108()
{
  JUMPOUT(*(unsigned int *)loc_100029B0);
}
// 100029B0: using guessed type int loc_100029B0();

//----- (1005D110) --------------------------------------------------------
void __cdecl sub_1005D110()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005D118) --------------------------------------------------------
int __usercall sub_1005D118<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 - 72);
}

//----- (1005D120) --------------------------------------------------------
void __cdecl sub_1005D120()
{
  sub_1002B6D6();
}

//----- (1005D128) --------------------------------------------------------
#error "1005D134: call analysis failed (funcsize=11)"

//----- (1005D150) --------------------------------------------------------
void __cdecl sub_1005D150()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005D158) --------------------------------------------------------
int __usercall sub_1005D158<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 - 80);
}

//----- (1005D160) --------------------------------------------------------
void __cdecl sub_1005D160()
{
  sub_1002B6D6();
}

//----- (1005D168) --------------------------------------------------------
#error "1005D174: call analysis failed (funcsize=11)"

//----- (1005D190) --------------------------------------------------------
int __thiscall sub_1005D190(void *this)
{
  return nullsub_3(this);
}
// 100018B0: using guessed type int __thiscall nullsub_3(_DWORD);

//----- (1005D1A1) --------------------------------------------------------
void __cdecl sub_1005D1A1()
{
  JUMPOUT(*(unsigned int *)loc_10006150);
}
// 10006150: using guessed type int loc_10006150();

//----- (1005D1A9) --------------------------------------------------------
void __cdecl sub_1005D1A9()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005D1B1) --------------------------------------------------------
#error "1005D1BD: call analysis failed (funcsize=7)"

//----- (1005D1D0) --------------------------------------------------------
int __usercall sub_1005D1D0<eax>(int a1<ebp>)
{
  return sub_1000A680(*(_DWORD *)(a1 - 16));
}
// 1000A680: using guessed type _DWORD __cdecl sub_1000A680(_DWORD);

//----- (1005D1DB) --------------------------------------------------------
#error "1005D1E7: call analysis failed (funcsize=7)"

//----- (1005D200) --------------------------------------------------------
int __usercall sub_1005D200<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 + 8);
}

//----- (1005D208) --------------------------------------------------------
void __cdecl sub_1005D208()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005D210) --------------------------------------------------------
#error "1005D21C: call analysis failed (funcsize=7)"

//----- (1005D230) --------------------------------------------------------
void __cdecl sub_1005D230()
{
  sub_1002B6D6();
}

//----- (1005D238) --------------------------------------------------------
#error "1005D244: call analysis failed (funcsize=10)"

//----- (1005D260) --------------------------------------------------------
void __cdecl sub_1005D260()
{
  sub_1002B6D6();
}

//----- (1005D268) --------------------------------------------------------
#error "1005D274: call analysis failed (funcsize=10)"

//----- (1005D290) --------------------------------------------------------
void __usercall sub_1005D290(void *this<ecx>, int a2<ebp>)
{
  sub_1002B6DD((void *)(a2 - 56));
}

//----- (1005D298) --------------------------------------------------------
#error "1005D2A4: call analysis failed (funcsize=10)"

//----- (1005D2C0) --------------------------------------------------------
int __usercall sub_1005D2C0<eax>(int a1<ebp>)
{
  return sub_1000A680(*(_DWORD *)(a1 + 8));
}
// 1000A680: using guessed type _DWORD __cdecl sub_1000A680(_DWORD);

//----- (1005D2CB) --------------------------------------------------------
#error "1005D2D7: call analysis failed (funcsize=7)"

//----- (1005D2F0) --------------------------------------------------------
int __usercall sub_1005D2F0<eax>(int a1<ebp>)
{
  return sub_1000A680(*(_DWORD *)(a1 - 48));
}
// 1000A680: using guessed type _DWORD __cdecl sub_1000A680(_DWORD);

//----- (1005D2FB) --------------------------------------------------------
void __usercall sub_1005D2FB(void *this<ecx>, int a2<ebp>)
{
  sub_1002B6DD((void *)(a2 - 44));
}

//----- (1005D303) --------------------------------------------------------
#error "1005D30F: call analysis failed (funcsize=10)"

//----- (1005D330) --------------------------------------------------------
void __cdecl sub_1005D330()
{
  JUMPOUT(*(unsigned int *)loc_10024D30);
}
// 10024D30: using guessed type int loc_10024D30();

//----- (1005D33B) --------------------------------------------------------
#error "1005D347: call analysis failed (funcsize=7)"

//----- (1005D360) --------------------------------------------------------
int __usercall sub_1005D360<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 - 40);
}

//----- (1005D368) --------------------------------------------------------
void __cdecl sub_1005D368()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005D370) --------------------------------------------------------
int __usercall sub_1005D370<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 - 64);
}

//----- (1005D378) --------------------------------------------------------
#error "1005D384: call analysis failed (funcsize=7)"

//----- (1005D3A0) --------------------------------------------------------
void __cdecl sub_1005D3A0()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005D3A8) --------------------------------------------------------
int __usercall sub_1005D3A8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 - 40);
}

//----- (1005D3B0) --------------------------------------------------------
#error "1005D3BC: call analysis failed (funcsize=7)"

//----- (1005D3D0) --------------------------------------------------------
void __cdecl sub_1005D3D0()
{
  JUMPOUT(*(unsigned int *)loc_10006120);
}
// 10006120: using guessed type int loc_10006120();

//----- (1005D3D8) --------------------------------------------------------
int __usercall sub_1005D3D8<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10006050(a2 - 40);
}

//----- (1005D3E0) --------------------------------------------------------
#error "1005D3EC: call analysis failed (funcsize=7)"

//----- (1005D400) --------------------------------------------------------
void __usercall sub_1005D400(void *this<ecx>, int a2<ebp>)
{
  sub_1002B6DD((void *)(a2 - 44));
}

//----- (1005D408) --------------------------------------------------------
#error "1005D414: call analysis failed (funcsize=10)"

//----- (1005D430) --------------------------------------------------------
void __usercall sub_1005D430(void *this<ecx>, int a2<ebp>)
{
  sub_1002B6DD((void *)(a2 - 44));
}

//----- (1005D438) --------------------------------------------------------
#error "1005D444: call analysis failed (funcsize=10)"

//----- (1005D460) --------------------------------------------------------
int __usercall sub_1005D460<eax>(int a1<ebp>)
{
  int result; // eax@1
  int v2; // esi@1

  v2 = a1 - 56;
  result = *(_DWORD *)(a1 - 56);
  if ( *(_DWORD *)(a1 - 56) )
  {
    result = sub_100303A3(*(LPVOID *)(a1 - 56));
    *(_DWORD *)v2 = 0;
    *(_DWORD *)(v2 + 4) = 0;
    *(_DWORD *)(v2 + 8) = 0;
  }
  return result;
}
// 100303A3: using guessed type _DWORD __cdecl sub_100303A3(LPVOID lpMem);

//----- (1005D468) --------------------------------------------------------
#error "1005D474: call analysis failed (funcsize=10)"

//----- (1005D490) --------------------------------------------------------
void __usercall sub_1005D490(void *this<ecx>, int a2<ebp>)
{
  sub_1002B6DD((void *)(a2 - 44));
}

//----- (1005D498) --------------------------------------------------------
#error "1005D4A4: call analysis failed (funcsize=10)"

//----- (1005D4C0) --------------------------------------------------------
void __usercall sub_1005D4C0(void *this<ecx>, int a2<ebp>)
{
  sub_1002B6DD((void *)(a2 - 44));
}

//----- (1005D4C8) --------------------------------------------------------
#error "1005D4D4: call analysis failed (funcsize=10)"

//----- (1005D4F0) --------------------------------------------------------
void __usercall sub_1005D4F0(void *this<ecx>, int a2<ebp>)
{
  sub_1002B6DD((void *)(a2 - 44));
}

//----- (1005D4F8) --------------------------------------------------------
#error "1005D504: call analysis failed (funcsize=10)"

//----- (1005D520) --------------------------------------------------------
int __usercall sub_1005D520<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_100255C0(a2 - 44);
}

//----- (1005D528) --------------------------------------------------------
void __cdecl sub_1005D528()
{
  JUMPOUT(*(unsigned int *)loc_10024D30);
}
// 10024D30: using guessed type int loc_10024D30();

//----- (1005D530) --------------------------------------------------------
#error "1005D53C: call analysis failed (funcsize=10)"

//----- (1005D560) --------------------------------------------------------
void __usercall sub_1005D560(void *this<ecx>, int a2<ebp>)
{
  sub_1002B6DD((void *)(a2 - 56));
}

//----- (1005D568) --------------------------------------------------------
#error "1005D574: call analysis failed (funcsize=10)"

//----- (1005D590) --------------------------------------------------------
void __cdecl sub_1005D590()
{
  sub_1002B6D6();
}

//----- (1005D598) --------------------------------------------------------
#error "1005D5A4: call analysis failed (funcsize=11)"

//----- (1005D5C0) --------------------------------------------------------
int __usercall sub_1005D5C0<eax>(int a1<ebp>)
{
  return sub_10001940(a1 + 8);
}
// 10001940: using guessed type int __thiscall sub_10001940(_DWORD);

//----- (1005D5C8) --------------------------------------------------------
#error "1005D5D4: call analysis failed (funcsize=7)"

//----- (1005D5F0) --------------------------------------------------------
int __usercall sub_1005D5F0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 40);
}

//----- (1005D5F8) --------------------------------------------------------
#error "1005D604: call analysis failed (funcsize=7)"

//----- (1005D620) --------------------------------------------------------
int __usercall sub_1005D620<eax>(int a1<ebp>)
{
  return sub_1002C0CE(a1);
}

//----- (1005D62B) --------------------------------------------------------
int __usercall sub_1005D62B<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(*(_DWORD *)(a2 - 16) + 56);
}

//----- (1005D636) --------------------------------------------------------
#error "1005D642: call analysis failed (funcsize=7)"

//----- (1005D660) --------------------------------------------------------
void __cdecl sub_1005D660()
{
  JUMPOUT(*(unsigned int *)loc_10009DE0);
}
// 10009DE0: using guessed type int loc_10009DE0();

//----- (1005D668) --------------------------------------------------------
void __cdecl sub_1005D668()
{
  JUMPOUT(*(unsigned int *)loc_10009DE0);
}
// 10009DE0: using guessed type int loc_10009DE0();

//----- (1005D673) --------------------------------------------------------
#error "1005D682: call analysis failed (funcsize=10)"

//----- (1005D6A0) --------------------------------------------------------
int __usercall sub_1005D6A0<eax>(int a1<ebp>)
{
  return sub_10001940(a1 - 124);
}
// 10001940: using guessed type int __thiscall sub_10001940(_DWORD);

//----- (1005D6A8) --------------------------------------------------------
int __usercall sub_1005D6A8<eax>(int a1<ebp>)
{
  return sub_10001940(a1 - 64);
}
// 10001940: using guessed type int __thiscall sub_10001940(_DWORD);

//----- (1005D6B0) --------------------------------------------------------
int __usercall sub_1005D6B0<eax>(int a1<ebp>)
{
  return sub_10001940(a1 - 144);
}
// 10001940: using guessed type int __thiscall sub_10001940(_DWORD);

//----- (1005D6BB) --------------------------------------------------------
int __usercall sub_1005D6BB<eax>(int a1<ebp>)
{
  return sub_10001940(a1 - 84);
}
// 10001940: using guessed type int __thiscall sub_10001940(_DWORD);

//----- (1005D6C3) --------------------------------------------------------
int __usercall sub_1005D6C3<eax>(int a1<ebp>)
{
  return sub_10001940(a1 - 44);
}
// 10001940: using guessed type int __thiscall sub_10001940(_DWORD);

//----- (1005D6CB) --------------------------------------------------------
int __usercall sub_1005D6CB<eax>(int a1<ebp>)
{
  return sub_10001940(a1 - 104);
}
// 10001940: using guessed type int __thiscall sub_10001940(_DWORD);

//----- (1005D6D3) --------------------------------------------------------
#error "1005D6E5: call analysis failed (funcsize=11)"

//----- (1005D710) --------------------------------------------------------
int __usercall sub_1005D710<eax>(int this<ecx>, int a2<ebp>)
{
  int result; // eax@1

  result = *(_DWORD *)(a2 - 24) & 1;
  if ( *(_DWORD *)(a2 - 24) & 1 )
  {
    *(_DWORD *)(a2 - 24) &= 0xFFFFFFFEu;
    result = sub_10001880(*(_DWORD *)(a2 - 52));
  }
  return result;
}

//----- (1005D729) --------------------------------------------------------
#error "1005D735: call analysis failed (funcsize=10)"

//----- (1005D750) --------------------------------------------------------
void __cdecl sub_1005D750()
{
  sub_1002B6D6();
}

//----- (1005D758) --------------------------------------------------------
#error "1005D764: call analysis failed (funcsize=10)"

//----- (1005D780) --------------------------------------------------------
void __cdecl sub_1005D780()
{
  JUMPOUT(*(unsigned int *)loc_10009DE0);
}
// 10009DE0: using guessed type int loc_10009DE0();

//----- (1005D788) --------------------------------------------------------
#error "1005D794: call analysis failed (funcsize=11)"

//----- (1005D7B0) --------------------------------------------------------
int __usercall sub_1005D7B0<eax>(int this<ecx>, int a2<ebp>)
{
  return sub_10001880(a2 - 40);
}

//----- (1005D7B8) --------------------------------------------------------
#error "1005D7C4: call analysis failed (funcsize=7)"

//----- (1005D7E0) --------------------------------------------------------
int __usercall sub_1005D7E0<eax>(int a1<ebx>)
{
  __int64 v3; // qax@1
  __int64 v4; // qax@1
  unsigned int v5; // edi@1
  int v6; // eax@1
  int v7; // edx@1
  __int64 v9; // qax@1
  __int64 v10; // qax@1
  int v11; // edi@1
  __int64 v13; // qax@1
  __int64 v14; // qax@1
  __int64 v16; // qax@1
  __int64 v17; // qax@1
  unsigned int v18; // edi@1
  int v19; // eax@1
  unsigned __int8 v20; // cf@1
  int v21; // eax@1
  int v22; // edx@1
  int v23; // edi@1
  __int64 v25; // qax@1
  __int64 v26; // qax@1
  int v27; // esi@1
  __int64 v29; // qax@1
  __int64 v30; // qax@1
  __int64 v32; // qax@1
  __int64 v33; // qax@1
  __int64 v35; // qax@1
  __int64 v36; // qax@1
  __int64 v38; // qax@1
  __int64 v39; // qax@1
  __int64 v41; // qax@1
  __int64 v42; // qax@1
  __int64 v44; // qax@1
  __int64 v45; // qax@1
  __int64 v47; // qax@1
  __int64 v48; // qax@1
  unsigned int v49; // edi@1
  int v50; // eax@1
  unsigned __int8 v51; // cf@1
  int v52; // eax@1
  int v53; // edx@1
  int v54; // edi@1
  __int64 v56; // qax@1
  __int64 v57; // qax@1
  char v58; // [sp+4h] [bp-58h]@1
  int v59; // [sp+8h] [bp-54h]@1
  int v60; // [sp+Ch] [bp-50h]@1
  int v61; // [sp+10h] [bp-4Ch]@1
  int v62; // [sp+14h] [bp-48h]@1
  int v63; // [sp+18h] [bp-44h]@1
  __int128 v64; // [sp+1Ch] [bp-40h]@1
  __int128 v65; // [sp+2Ch] [bp-30h]@1
  int v66; // [sp+3Ch] [bp-20h]@1
  unsigned int v67; // [sp+58h] [bp-4h]@1

  v67 = (unsigned int)&v58 ^ __security_cookie;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+5Ch+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  v66 = 0;
  *(_QWORD *)&v65 = 485331304449i64;
  *((_QWORD *)&v64 + 1) = 107374182414i64;
  *(_QWORD *)&v64 = 0i64;
  v3 = sub_1002ADA0(a1, (int)&v64);
  v4 = sub_10039A20(v3, 10000000i64);
  v5 = v4;
  v59 = HIDWORD(v4);
  qword_100762C0 = v4;
  sub_1004D276(7.2e10);
  v63 = v6;
  v61 = v7;
  dword_100762C8 = v5 + v6;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_100762CC = v59 + (v5 >= -v6) + v7;
  dword_100762D0 = 15;
  dword_100762E8 = 15;
  dword_100762E4 = 0;
  byte_100762D4 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304453i64;
  *((_QWORD *)&v64 + 1) = 60129542147i64;
  *(_QWORD *)&v64 = 128849018880i64;
  v9 = sub_1002ADA0(a1, (int)&v64);
  v10 = sub_10039A20(v9, 10000000i64);
  v11 = v61;
  qword_100762F0 = v10;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_100762F8 = v10 + v63;
  dword_100762FC = HIDWORD(v10) + ((_DWORD)v10 >= (unsigned int)-v63) + v61;
  dword_10076300 = 15;
  dword_10076318 = 15;
  dword_10076314 = 0;
  byte_10076304 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304453i64;
  *((_QWORD *)&v64 + 1) = 73014444032i64;
  *(_QWORD *)&v64 = 128849018880i64;
  v13 = sub_1002ADA0(a1, (int)&v64);
  v14 = sub_10039A20(v13, 10000000i64);
  qword_10076320 = v14;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_10076328 = v14 + v63;
  dword_1007632C = HIDWORD(v14) + ((_DWORD)v14 >= (unsigned int)-v63) + v11;
  dword_10076330 = 15;
  dword_10076348 = 15;
  dword_10076344 = 0;
  byte_10076334 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304454i64;
  *((_QWORD *)&v64 + 1) = 47244640271i64;
  *(_QWORD *)&v64 = 128849018880i64;
  v16 = sub_1002ADA0(a1, (int)&v64);
  v17 = sub_10039A20(v16, 10000000i64);
  v18 = v17;
  v60 = HIDWORD(v17);
  qword_10076350 = v17;
  sub_1004D276(3.6e10);
  v62 = v19;
  v20 = v18 >= -v19;
  v21 = v18 + v19;
  v23 = v22;
  dword_10076358 = v21;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_1007635C = v60 + v20 + v22;
  dword_10076360 = 15;
  dword_10076378 = 15;
  dword_10076374 = 0;
  byte_10076364 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304454i64;
  *((_QWORD *)&v64 + 1) = 103079215106i64;
  *(_QWORD *)&v64 = 0i64;
  v25 = sub_1002ADA0(a1, (int)&v64);
  v26 = sub_10039A20(v25, 10000000i64);
  v27 = v62;
  qword_10076380 = v26;
  dword_1007638C = HIDWORD(v26) + ((_DWORD)v26 >= (unsigned int)-v62) + v23;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_10076388 = v26 + v62;
  dword_10076390 = 15;
  dword_100763A8 = 15;
  dword_100763A4 = 0;
  byte_10076394 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304454i64;
  *((_QWORD *)&v64 + 1) = 107374182403i64;
  *(_QWORD *)&v64 = 0i64;
  v29 = sub_1002ADA0(a1, (int)&v64);
  v30 = sub_10039A20(v29, 10000000i64);
  qword_100763B0 = v30;
  dword_100763BC = HIDWORD(v30) + ((_DWORD)v30 >= (unsigned int)-v63) + v61;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_100763B8 = v30 + v63;
  dword_100763C0 = 15;
  dword_100763D8 = 15;
  dword_100763D4 = 0;
  byte_100763C4 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304455i64;
  *((_QWORD *)&v64 + 1) = 111669149710i64;
  *(_QWORD *)&v64 = 128849018880i64;
  v32 = sub_1002ADA0(a1, (int)&v64);
  v33 = sub_10039A20(v32, 10000000i64);
  qword_100763E0 = v33;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_100763EC = HIDWORD(v33) + ((_DWORD)v33 >= (unsigned int)-v27) + v23;
  dword_100763E8 = v33 + v27;
  dword_100763F0 = 15;
  dword_10076408 = 15;
  dword_10076404 = 0;
  byte_100763F4 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304455i64;
  *((_QWORD *)&v64 + 1) = 115964117001i64;
  *(_QWORD *)&v64 = 0i64;
  v35 = sub_1002ADA0(a1, (int)&v64);
  v36 = sub_10039A20(v35, 10000000i64);
  qword_10076410 = v36;
  dword_1007641C = HIDWORD(v36) + ((_DWORD)v36 >= (unsigned int)-v27) + v23;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_10076418 = v36 + v27;
  dword_10076420 = 15;
  dword_10076438 = 15;
  dword_10076434 = 0;
  byte_10076424 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304455i64;
  *((_QWORD *)&v64 + 1) = 120259084302i64;
  *(_QWORD *)&v64 = 128849018880i64;
  v38 = sub_1002ADA0(a1, (int)&v64);
  v39 = sub_10039A20(v38, 10000000i64);
  qword_10076440 = v39;
  dword_1007644C = HIDWORD(v39) + ((_DWORD)v39 >= (unsigned int)-v27) + v23;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_10076448 = v39 + v27;
  dword_10076450 = 15;
  dword_10076468 = 15;
  dword_10076464 = 0;
  byte_10076454 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304456i64;
  *((_QWORD *)&v64 + 1) = 47244640260i64;
  *(_QWORD *)&v64 = 0i64;
  v41 = sub_1002ADA0(a1, (int)&v64);
  v42 = sub_10039A20(v41, 10000000i64);
  qword_10076470 = v42;
  dword_10076478 = v42 + v63;
  dword_1007647C = HIDWORD(v42) + ((_DWORD)v42 >= (unsigned int)-v63) + v61;
  dword_10076480 = 15;
  dword_10076498 = 15;
  dword_10076494 = 0;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  byte_10076484 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304456i64;
  *((_QWORD *)&v64 + 1) = 51539607567i64;
  *(_QWORD *)&v64 = 85899345920i64;
  v44 = sub_1002ADA0(a1, (int)&v64);
  v45 = sub_10039A20(v44, 10000000i64);
  qword_100764A0 = v45;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_100764A8 = v45 + v27;
  dword_100764AC = HIDWORD(v45) + ((_DWORD)v45 >= (unsigned int)-v27) + v23;
  dword_100764B0 = 15;
  dword_100764C8 = 15;
  dword_100764C4 = 0;
  byte_100764B4 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304457i64;
  *((_QWORD *)&v64 + 1) = 47244640270i64;
  *(_QWORD *)&v64 = 128849018880i64;
  v47 = sub_1002ADA0(a1, (int)&v64);
  v48 = sub_10039A20(v47, 10000000i64);
  v49 = v48;
  v60 = HIDWORD(v48);
  qword_100764D0 = v48;
  sub_1004D276(5.4e10);
  v59 = v50;
  v51 = v49 >= -v50;
  v52 = v49 + v50;
  v54 = v53;
  dword_100764D8 = v52;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+60h+var_40], xmm0
    movdqa  [esp+60h+var_30], xmm0
  }
  dword_100764DC = v60 + v51 + v53;
  dword_100764E0 = 15;
  dword_100764F8 = 15;
  dword_100764F4 = 0;
  byte_100764E4 = 0;
  v66 = 0;
  *(_QWORD *)&v65 = 485331304457i64;
  *((_QWORD *)&v64 + 1) = 47244640270i64;
  *(_QWORD *)&v64 = 128849018880i64;
  v56 = sub_1002ADA0(a1, (int)&v64);
  v57 = sub_10039A20(v56, 10000000i64);
  qword_10076500 = v57;
  dword_10076508 = v57 + v59;
  dword_1007650C = HIDWORD(v57) + ((_DWORD)v57 >= (unsigned int)-v59) + v54;
  dword_10076510 = 15;
  dword_10076528 = 15;
  dword_10076524 = 0;
  byte_10076514 = 0;
  return sub_1002B10A(SHIDWORD(v57), v57 + v59, a1, dword_1007650C, sub_1005EBB0);
}
// 1004D276: using guessed type double __usercall sub_1004D276<st0>(double<st0>);
// 10073200: using guessed type int __security_cookie;
// 100762C0: using guessed type __int64 qword_100762C0;
// 100762C8: using guessed type int dword_100762C8;
// 100762CC: using guessed type int dword_100762CC;
// 100762D0: using guessed type int dword_100762D0;
// 100762D4: using guessed type char byte_100762D4;
// 100762E4: using guessed type int dword_100762E4;
// 100762E8: using guessed type int dword_100762E8;
// 100762F0: using guessed type __int64 qword_100762F0;
// 100762F8: using guessed type int dword_100762F8;
// 100762FC: using guessed type int dword_100762FC;
// 10076300: using guessed type int dword_10076300;
// 10076304: using guessed type char byte_10076304;
// 10076314: using guessed type int dword_10076314;
// 10076318: using guessed type int dword_10076318;
// 10076320: using guessed type __int64 qword_10076320;
// 10076328: using guessed type int dword_10076328;
// 1007632C: using guessed type int dword_1007632C;
// 10076330: using guessed type int dword_10076330;
// 10076334: using guessed type char byte_10076334;
// 10076344: using guessed type int dword_10076344;
// 10076348: using guessed type int dword_10076348;
// 10076350: using guessed type __int64 qword_10076350;
// 10076358: using guessed type int dword_10076358;
// 1007635C: using guessed type int dword_1007635C;
// 10076360: using guessed type int dword_10076360;
// 10076364: using guessed type char byte_10076364;
// 10076374: using guessed type int dword_10076374;
// 10076378: using guessed type int dword_10076378;
// 10076380: using guessed type __int64 qword_10076380;
// 10076388: using guessed type int dword_10076388;
// 1007638C: using guessed type int dword_1007638C;
// 10076390: using guessed type int dword_10076390;
// 10076394: using guessed type char byte_10076394;
// 100763A4: using guessed type int dword_100763A4;
// 100763A8: using guessed type int dword_100763A8;
// 100763B0: using guessed type __int64 qword_100763B0;
// 100763B8: using guessed type int dword_100763B8;
// 100763BC: using guessed type int dword_100763BC;
// 100763C0: using guessed type int dword_100763C0;
// 100763C4: using guessed type char byte_100763C4;
// 100763D4: using guessed type int dword_100763D4;
// 100763D8: using guessed type int dword_100763D8;
// 100763E0: using guessed type __int64 qword_100763E0;
// 100763E8: using guessed type int dword_100763E8;
// 100763EC: using guessed type int dword_100763EC;
// 100763F0: using guessed type int dword_100763F0;
// 100763F4: using guessed type char byte_100763F4;
// 10076404: using guessed type int dword_10076404;
// 10076408: using guessed type int dword_10076408;
// 10076410: using guessed type __int64 qword_10076410;
// 10076418: using guessed type int dword_10076418;
// 1007641C: using guessed type int dword_1007641C;
// 10076420: using guessed type int dword_10076420;
// 10076424: using guessed type char byte_10076424;
// 10076434: using guessed type int dword_10076434;
// 10076438: using guessed type int dword_10076438;
// 10076440: using guessed type __int64 qword_10076440;
// 10076448: using guessed type int dword_10076448;
// 1007644C: using guessed type int dword_1007644C;
// 10076450: using guessed type int dword_10076450;
// 10076454: using guessed type char byte_10076454;
// 10076464: using guessed type int dword_10076464;
// 10076468: using guessed type int dword_10076468;
// 10076470: using guessed type __int64 qword_10076470;
// 10076478: using guessed type int dword_10076478;
// 1007647C: using guessed type int dword_1007647C;
// 10076480: using guessed type int dword_10076480;
// 10076484: using guessed type char byte_10076484;
// 10076494: using guessed type int dword_10076494;
// 10076498: using guessed type int dword_10076498;
// 100764A0: using guessed type __int64 qword_100764A0;
// 100764A8: using guessed type int dword_100764A8;
// 100764AC: using guessed type int dword_100764AC;
// 100764B0: using guessed type int dword_100764B0;
// 100764B4: using guessed type char byte_100764B4;
// 100764C4: using guessed type int dword_100764C4;
// 100764C8: using guessed type int dword_100764C8;
// 100764D0: using guessed type __int64 qword_100764D0;
// 100764D8: using guessed type int dword_100764D8;
// 100764DC: using guessed type int dword_100764DC;
// 100764E0: using guessed type int dword_100764E0;
// 100764E4: using guessed type char byte_100764E4;
// 100764F4: using guessed type int dword_100764F4;
// 100764F8: using guessed type int dword_100764F8;
// 10076500: using guessed type __int64 qword_10076500;
// 10076508: using guessed type int dword_10076508;
// 1007650C: using guessed type int dword_1007650C;
// 10076510: using guessed type int dword_10076510;
// 10076514: using guessed type char byte_10076514;
// 10076524: using guessed type int dword_10076524;
// 10076528: using guessed type int dword_10076528;

//----- (1005E0E0) --------------------------------------------------------
int __usercall sub_1005E0E0<eax>(int a1<ebx>, int a2<edi>)
{
  signed int v2; // eax@1
  void *v3; // esi@4
  int v4; // edx@5
  int v5; // ecx@5
  void *v6; // esi@6
  char v8; // [sp+1Fh] [bp-4Dh]@3
  char v9; // [sp+20h] [bp-4Ch]@3
  char v10; // [sp+21h] [bp-4Bh]@4
  char v11; // [sp+22h] [bp-4Ah]@3
  char v12; // [sp+23h] [bp-49h]@4
  void *v13; // [sp+24h] [bp-48h]@3
  int v14; // [sp+34h] [bp-38h]@3
  unsigned int v15; // [sp+38h] [bp-34h]@3
  void *v16; // [sp+3Ch] [bp-30h]@3
  int v17; // [sp+4Ch] [bp-20h]@3
  unsigned int v18; // [sp+50h] [bp-1Ch]@3
  __int64 *v19; // [sp+54h] [bp-18h]@3
  char *v20; // [sp+58h] [bp-14h]@3
  int v21; // [sp+68h] [bp-4h]@3

  v2 = 6;
  if ( !byte_10066F54 )
    v2 = 0;
  v15 = 15;
  v14 = 0;
  LOBYTE(v13) = 0;
  loc_1000AEB0(&v13, &byte_10066F54, v2);
  v21 = 0;
  sub_100018D0(&v8);
  sub_100035D0((int)&v9);
  sub_10003480(&v11, (int)&v9);
  v18 = 15;
  v17 = 0;
  LOBYTE(v16) = 0;
  loc_1000AB40(&v16, &v13, 0, -1);
  v19 = &qword_100762C0;
  v20 = &byte_10076530;
  if ( v15 >= 0x10 )
  {
    v3 = v13;
    sub_100018D0(&v10);
    nullsub_1(&v13);
    sub_100018D0(&v12);
    sub_1002A4AA(v3);
  }
  v15 = 15;
  v14 = 0;
  LOBYTE(v13) = 0;
  v21 = 1;
  sub_100018D0(&v10);
  sub_100035D0((int)&v9);
  sub_10003480(&v12, (int)&v9);
  dword_10076544 = 15;
  dword_10076540 = 0;
  byte_10076530 = 0;
  loc_1000AB40(&byte_10076530, &v16, 0, -1);
  dword_10076548 = (int)v19;
  dword_1007654C = (int)v20;
  if ( v18 >= 0x10 )
  {
    v6 = v16;
    sub_100018D0(&v10);
    nullsub_1(&v16);
    sub_100018D0(&v12);
    sub_1002A4AA(v6);
  }
  return sub_1002B10A(v4, v5, a1, a2, sub_1005EBD0);
}
// 100018C0: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10066F54: using guessed type char byte_10066F54;
// 100762C0: using guessed type __int64 qword_100762C0;
// 10076530: using guessed type char byte_10076530;
// 10076540: using guessed type int dword_10076540;
// 10076544: using guessed type int dword_10076544;
// 10076548: using guessed type int dword_10076548;
// 1007654C: using guessed type int dword_1007654C;

//----- (1005E2B0) --------------------------------------------------------
int __usercall sub_1005E2B0<eax>(int a1<ebx>, int a2<edi>)
{
  signed int v2; // eax@1
  int v4; // edx@3
  int v5; // ecx@3

  v2 = 6;
  if ( !byte_10066F54 )
    v2 = 0;
  loc_1000AEB0(&unk_10074E80, &byte_10066F54, v2);
  __asm
  {
    xorps   xmm0, xmm0
    movsd   qword_10074E98, xmm0
    movsd   xmm0, ds:qword_100684E0
    movsd   xmm1, ds:qword_100684B0
    movsd   qword_10074EA0, xmm0
    movsd   xmm0, ds:qword_100684D0
    movsd   qword_10074EA8, xmm0
    movsd   xmm0, ds:qword_10068498
    movsd   qword_10074EB0, xmm0
    movsd   xmm0, ds:qword_100684E8
    movsd   qword_10074EC0, xmm0
    movsd   xmm0, ds:qword_10068488
    movsd   qword_10074EC8, xmm0
    movsd   xmm0, ds:qword_100684A0
    movsd   qword_10074ED0, xmm0
    movsd   xmm0, ds:dbl_100684B8
    movsd   qword_10074EE0, xmm0
    movsd   xmm0, ds:qword_10068490
    movsd   qword_10074EF8, xmm0
    movsd   xmm0, ds:qword_10068478
  }
  dword_10074EB8 = 1;
  dword_10074ED8 = 70;
  dword_10074EDC = 300;
  byte_10074EE8 = 1;
  __asm
  {
    movsd   qword_10074EF0, xmm1
    movsd   qword_10074F00, xmm0
    movsd   qword_10074F08, xmm1
  }
  return sub_1002B10A(v4, v5, a1, a2, sub_1005EBF0);
}
// 10066F54: using guessed type char byte_10066F54;
// 10074EB8: using guessed type int dword_10074EB8;
// 10074ED8: using guessed type int dword_10074ED8;
// 10074EDC: using guessed type int dword_10074EDC;
// 10074EE8: using guessed type char byte_10074EE8;

//----- (1005E3C0) --------------------------------------------------------
int __usercall sub_1005E3C0<eax>(int a1<ecx>, int a2<ebx>, int a3<edi>)
{
  int v4; // edx@1
  int v5; // ecx@1

  sub_1000C770(a1, a1);
  sub_10021500(a2, a3);
  return sub_1002B10A(v4, v5, a2, a3, sub_1005EC10);
}
// 1005EC10: using guessed type int sub_1005EC10();

//----- (1005E3E0) --------------------------------------------------------
int __usercall sub_1005E3E0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  return sub_1002B10A(a1, a2, a3, a4, sub_1005EC40);
}
// 1005EC40: using guessed type int sub_1005EC40();

//----- (1005E3F0) --------------------------------------------------------
int __usercall sub_1005E3F0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  return sub_1002B10A(a1, a2, a3, a4, sub_1005EC30);
}
// 1005EC30: using guessed type int sub_1005EC30();

//----- (1005E400) --------------------------------------------------------
int __usercall sub_1005E400<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  return sub_1002B10A(a1, a2, a3, a4, sub_1005EC20);
}

//----- (1005E410) --------------------------------------------------------
__int64 __usercall sub_1005E410<edx:eax>(int a1<ebx>)
{
  __int64 result; // qax@1
  __int64 v3; // qax@1
  __int64 v4; // qax@1
  int v5; // esi@1
  int v7; // edi@1
  __int64 v8; // qax@1
  __int64 v10; // qax@1
  __int64 v11; // qax@1
  int v12; // esi@1
  int v14; // edi@1
  __int64 v15; // qax@1
  __int64 v17; // qax@1
  __int64 v18; // qax@1
  int v19; // esi@1
  int v21; // edi@1
  __int64 v22; // qax@1
  __int64 v24; // qax@1
  __int64 v25; // qax@1
  int v27; // esi@1
  int v28; // edi@1
  __int64 v29; // qax@1
  __int64 v31; // qax@1
  __int64 v32; // qax@1
  int v33; // esi@1
  int v35; // edi@1
  __int64 v36; // qax@1
  char v37; // [sp+4h] [bp-78h]@1
  __int128 v38; // [sp+Ch] [bp-70h]@1
  __int128 v39; // [sp+1Ch] [bp-60h]@1
  int v40; // [sp+2Ch] [bp-50h]@1
  __int128 v41; // [sp+3Ch] [bp-40h]@1
  __int128 v42; // [sp+4Ch] [bp-30h]@1
  int v43; // [sp+5Ch] [bp-20h]@1
  unsigned int v44; // [sp+78h] [bp-4h]@1

  v44 = (unsigned int)&v37 ^ __security_cookie;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+7Ch+var_70], xmm0
    movdqa  [esp+80h+var_60], xmm0
  }
  v40 = 0;
  *(_QWORD *)&v39 = 485331304457i64;
  *((_QWORD *)&v38 + 1) = 115964116993i64;
  *(_QWORD *)&v38 = 0i64;
  v3 = sub_1002ADA0(a1, (int)&v38);
  v4 = sub_10039A20(v3, 10000000i64);
  v5 = v4;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+80h+var_40], xmm0
    movdqa  [esp+80h+var_30], xmm0
  }
  v7 = HIDWORD(v4);
  v43 = 0;
  *(_QWORD *)&v42 = 485331304450i64;
  *((_QWORD *)&v41 + 1) = 133143986177i64;
  *(_QWORD *)&v41 = 0i64;
  v8 = sub_1002ADA0(a1, (int)&v41);
  qword_100767E0 = sub_10039A20(v8, 10000000i64);
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+80h+var_40], xmm0
    movdqa  [esp+80h+var_30], xmm0
  }
  dword_100767E8 = v5;
  dword_100767EC = v7;
  v43 = 0;
  *(_QWORD *)&v42 = 485331304457i64;
  *((_QWORD *)&v41 + 1) = 111669149697i64;
  *(_QWORD *)&v41 = 0i64;
  v10 = sub_1002ADA0(a1, (int)&v41);
  v11 = sub_10039A20(v10, 10000000i64);
  v12 = v11;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+80h+var_70], xmm0
    movdqa  [esp+80h+var_60], xmm0
  }
  v14 = HIDWORD(v11);
  v40 = 0;
  *(_QWORD *)&v39 = 489626271746i64;
  *((_QWORD *)&v38 + 1) = 128849018881i64;
  *(_QWORD *)&v38 = 0i64;
  v15 = sub_1002ADA0(a1, (int)&v38);
  qword_100767F0 = sub_10039A20(v15, 10000000i64);
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+80h+var_40], xmm0
    movdqa  [esp+80h+var_30], xmm0
  }
  dword_100767F8 = v12;
  dword_100767FC = v14;
  v43 = 0;
  *(_QWORD *)&v42 = 485331304457i64;
  *((_QWORD *)&v41 + 1) = 107374182401i64;
  *(_QWORD *)&v41 = 0i64;
  v17 = sub_1002ADA0(a1, (int)&v41);
  v18 = sub_10039A20(v17, 10000000i64);
  v19 = v18;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+80h+var_70], xmm0
    movdqa  [esp+80h+var_60], xmm0
  }
  v21 = HIDWORD(v18);
  v40 = 0;
  *(_QWORD *)&v39 = 493921239042i64;
  *((_QWORD *)&v38 + 1) = 124554051585i64;
  *(_QWORD *)&v38 = 0i64;
  v22 = sub_1002ADA0(a1, (int)&v38);
  qword_10076800 = sub_10039A20(v22, 10000000i64);
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+80h+var_40], xmm0
    movdqa  [esp+80h+var_30], xmm0
  }
  dword_10076808 = v19;
  dword_1007680C = v21;
  v43 = 0;
  *(_QWORD *)&v42 = 485331304457i64;
  *((_QWORD *)&v41 + 1) = 128849018881i64;
  *(_QWORD *)&v41 = 0i64;
  v24 = sub_1002ADA0(a1, (int)&v41);
  v25 = sub_10039A20(v24, 10000000i64);
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+80h+var_60], xmm0
    movdqa  [esp+80h+var_70], xmm0
  }
  v27 = v25;
  v28 = HIDWORD(v25);
  v40 = 0;
  *(_QWORD *)&v39 = 498216206338i64;
  *((_QWORD *)&v38 + 1) = 115964116993i64;
  *(_QWORD *)&v38 = 0i64;
  v29 = sub_1002ADA0(a1, (int)&v38);
  qword_10076810 = sub_10039A20(v29, 10000000i64);
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+80h+var_40], xmm0
    movdqa  [esp+80h+var_30], xmm0
  }
  dword_10076818 = v27;
  dword_1007681C = v28;
  v43 = 0;
  *(_QWORD *)&v42 = 485331304457i64;
  *((_QWORD *)&v41 + 1) = 124554051585i64;
  *(_QWORD *)&v41 = 0i64;
  v31 = sub_1002ADA0(a1, (int)&v41);
  v32 = sub_10039A20(v31, 10000000i64);
  v33 = v32;
  __asm
  {
    xorps   xmm0, xmm0
    movdqa  [esp+80h+var_70], xmm0
    movdqa  [esp+80h+var_60], xmm0
  }
  v35 = HIDWORD(v32);
  v40 = 0;
  *(_QWORD *)&v39 = 502511173634i64;
  *((_QWORD *)&v38 + 1) = 111669149697i64;
  *(_QWORD *)&v38 = 0i64;
  v36 = sub_1002ADA0(a1, (int)&v38);
  result = sub_10039A20(v36, 10000000i64);
  dword_1007682C = v35;
  dword_10076828 = v33;
  qword_10076820 = result;
  return result;
}
// 10073200: using guessed type int __security_cookie;
// 100767E0: using guessed type __int64 qword_100767E0;
// 100767E8: using guessed type int dword_100767E8;
// 100767EC: using guessed type int dword_100767EC;
// 100767F0: using guessed type __int64 qword_100767F0;
// 100767F8: using guessed type int dword_100767F8;
// 100767FC: using guessed type int dword_100767FC;
// 10076800: using guessed type __int64 qword_10076800;
// 10076808: using guessed type int dword_10076808;
// 1007680C: using guessed type int dword_1007680C;
// 10076810: using guessed type __int64 qword_10076810;
// 10076818: using guessed type int dword_10076818;
// 1007681C: using guessed type int dword_1007681C;
// 10076820: using guessed type __int64 qword_10076820;
// 10076828: using guessed type int dword_10076828;
// 1007682C: using guessed type int dword_1007682C;

//----- (1005E8A0) --------------------------------------------------------
int __usercall sub_1005E8A0<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  dword_10076838 &= 0xFFFFFE00u;
  return sub_1002B10A(a1, a2, a3, a4, sub_1005EC50);
}
// 1005EC50: using guessed type int sub_1005EC50();
// 10076838: using guessed type int dword_10076838;

//----- (1005E8C0) --------------------------------------------------------
int __usercall sub_1005E8C0<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  loc_1000AEB0(&dword_10074F10, "\\[(b|i|url)\\](.+?)\\[/\\1\\]", 25);
  return sub_1002B10A(v3, v4, a1, a2, sub_1005EC60);
}
// 10074F10: using guessed type int dword_10074F10;

//----- (1005E8E0) --------------------------------------------------------
int __usercall sub_1005E8E0<eax>(int a1<ebx>, int a2<edi>)
{
  signed int v2; // eax@1
  int v4; // edx@3
  int v5; // ecx@3

  v2 = 6;
  if ( !byte_10066F54 )
    v2 = 0;
  loc_1000AEB0(&unk_10074F28, &byte_10066F54, v2);
  __asm
  {
    movsd   xmm0, ds:qword_10068490
    movsd   qword_10074F40, xmm0
    movsd   xmm0, ds:qword_100684D8
    movsd   qword_10074F48, xmm0
    movsd   xmm0, ds:qword_100684D0
    movsd   qword_10074F50, xmm0
    xorps   xmm0, xmm0
    movsd   qword_10074F58, xmm0
    movsd   xmm0, ds:qword_100684A8
    movsd   qword_10074F68, xmm0
    movsd   xmm0, ds:qword_10068488
  }
  dword_10074F60 = 7;
  __asm { movsd   qword_10074F70, xmm0 }
  return sub_1002B10A(v4, v5, a1, a2, sub_1005ECC0);
}
// 10066F54: using guessed type char byte_10066F54;
// 10074F60: using guessed type int dword_10074F60;

//----- (1005E980) --------------------------------------------------------
int __usercall sub_1005E980<eax>(int a1<ebx>, int a2<edi>)
{
  signed int v2; // eax@1
  int v4; // edx@3
  int v5; // ecx@3

  v2 = 6;
  if ( !byte_10066F54 )
    v2 = 0;
  loc_1000AEB0(&unk_10074F80, &byte_10066F54, v2);
  __asm
  {
    movsd   xmm0, ds:qword_100684C0
    movsd   qword_10074F98, xmm0
    movsd   xmm0, ds:qword_100684C8
    movsd   qword_10074FA0, xmm0
    movsd   xmm0, ds:qword_100684B0
    movsd   qword_10074FA8, xmm0
    xorps   xmm0, xmm0
    movsd   qword_10074FB0, xmm0
    movsd   xmm0, ds:qword_10068488
  }
  dword_10074FB8 = 7;
  byte_10074FC0 = 0;
  __asm { movsd   qword_10074FC8, xmm0 }
  return sub_1002B10A(v4, v5, a1, a2, sub_1005ECE0);
}
// 10066F54: using guessed type char byte_10066F54;
// 10074FB8: using guessed type int dword_10074FB8;
// 10074FC0: using guessed type char byte_10074FC0;

//----- (1005EA10) --------------------------------------------------------
int __usercall sub_1005EA10<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  loc_1000AEB0(&dword_10074FD0, "ForexSensation", 14);
  return sub_1002B10A(v3, v4, a1, a2, sub_1005ED00);
}
// 10074FD0: using guessed type int dword_10074FD0;

//----- (1005EA30) --------------------------------------------------------
int __usercall sub_1005EA30<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  loc_1000AEB0(&dword_10075000, "1.01", 4);
  return sub_1002B10A(v3, v4, a1, a2, sub_1005ED60);
}
// 10075000: using guessed type int dword_10075000;

//----- (1005EA50) --------------------------------------------------------
int __usercall sub_1005EA50<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  loc_10028430(&dword_10074FE8, L"http://forexsensation.com/access", 32);
  return sub_1002B10A(v3, v4, a1, a2, sub_1005EDC0);
}
// 10067BF0: using guessed type wchar_t aHttpForexsensa[33];
// 10074FE8: using guessed type int dword_10074FE8;

//----- (1005EA70) --------------------------------------------------------
int __usercall sub_1005EA70<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  loc_10028430(&dword_10075018, L"http://forexsensation.com/newsapi/exceptions", 44);
  return sub_1002B10A(v3, v4, a1, a2, sub_1005EE20);
}
// 10067C38: using guessed type wchar_t aHttpForexsen_0[45];
// 10075018: using guessed type int dword_10075018;

//----- (1005EA90) --------------------------------------------------------
int __usercall sub_1005EA90<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  loc_10028430(&pszAgentW, L"Client", 6);
  return sub_1002B10A(v3, v4, a1, a2, sub_1005EE80);
}
// 100683D0: using guessed type wchar_t aClient[7];

//----- (1005EAB0) --------------------------------------------------------
int __usercall sub_1005EAB0<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  dword_1007685C = 0;
  dword_10076860 = 0;
  hInternet = 0;
  sub_1002B5CC((int)&unk_10076844);
  __asm
  {
    xorps   xmm0, xmm0
    movq    qword ptr pProxyConfig.fAutoDetect, xmm0
    movq    qword ptr pProxyConfig.lpszProxy, xmm0
  }
  return sub_1002B10A(v3, v4, a1, a2, sub_1005EEE0);
}
// 1007685C: using guessed type int dword_1007685C;
// 10076860: using guessed type int dword_10076860;

//----- (1005EAF7) --------------------------------------------------------
int __usercall sub_1005EAF7<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  return sub_1002B10A(a1, a2, a3, a4, sub_1005EF30);
}
// 1005EF30: using guessed type int sub_1005EF30();

//----- (1005EB03) --------------------------------------------------------
int __usercall sub_1005EB03<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  return sub_1002B10A(a1, a2, a3, a4, sub_1005EF3A);
}
// 1005EF3A: using guessed type int sub_1005EF3A();

//----- (1005EB0F) --------------------------------------------------------
int __usercall sub_1005EB0F<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  sub_10029A47(&unk_100750F8);
  return sub_1002B10A(v3, v4, a1, a2, sub_1005EF44);
}
// 1005EF44: using guessed type int sub_1005EF44();

//----- (1005EB25) --------------------------------------------------------
int __usercall sub_1005EB25<eax>(int a1<edx>, int a2<ecx>, int a3<ebx>, int a4<edi>)
{
  return sub_1002B10A(a1, a2, a3, a4, sub_1005EF4E);
}
// 1005EF4E: using guessed type int sub_1005EF4E();

//----- (1005EB31) --------------------------------------------------------
int __usercall sub_1005EB31<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  sub_10029A47(&unk_100751B8);
  return sub_1002B10A(v3, v4, a1, a2, sub_1005EF58);
}
// 1005EF58: using guessed type int sub_1005EF58();

//----- (1005EB47) --------------------------------------------------------
int __usercall sub_1005EB47<eax>(int a1<ebx>, int a2<edi>)
{
  int v3; // edx@1
  int v4; // ecx@1

  sub_1002FB8C(&dword_10075270);
  return sub_1002B10A(v3, v4, a1, a2, sub_1005EF62);
}
// 1002FB8C: using guessed type int __cdecl sub_1002FB8C(_DWORD);
// 1005EF62: using guessed type int sub_1005EF62();
// 10075270: using guessed type int dword_10075270;

//----- (1005EB5F) --------------------------------------------------------
void **__cdecl sub_1005EB5F()
{
  void **result; // eax@1

  result = sub_10047ECB() + 16;
  dword_1007560C = (int)result;
  return result;
}
// 1007560C: using guessed type int dword_1007560C;

//----- (1005EB6D) --------------------------------------------------------
unsigned int __cdecl sub_1005EB6D()
{
  unsigned int result; // eax@1

  result = sub_1003496D();
  dword_10075F58 = result;
  return result;
}
// 10075F58: using guessed type int dword_10075F58;

//----- (1005EB78) --------------------------------------------------------
void __cdecl sub_1005EB78()
{
  dword_10075F50 = 0;
}
// 10075F50: using guessed type int dword_10075F50;

//----- (1005EB83) --------------------------------------------------------
void __cdecl sub_1005EB83()
{
  dword_10075F48 = 0;
}
// 10075F48: using guessed type int dword_10075F48;

//----- (1005EB8E) --------------------------------------------------------
void __cdecl sub_1005EB8E()
{
  dword_10075F54 = 0;
}
// 10075F54: using guessed type int dword_10075F54;

//----- (1005EB99) --------------------------------------------------------
void __cdecl sub_1005EB99()
{
  dword_10075F4C = 0;
}
// 10075F4C: using guessed type int dword_10075F4C;

//----- (1005EBA4) --------------------------------------------------------
void __cdecl sub_1005EBA4()
{
  InitializeSListHead(&ListHead);
}

//----- (1005EBB0) --------------------------------------------------------
signed int __cdecl sub_1005EBB0()
{
  return sub_1002B11F((int)&dword_100762C0, 48, 13, (void (__thiscall *)(_DWORD))loc_10001BA0);
}
// 10001BA0: using guessed type int loc_10001BA0();
// 100762C0: using guessed type int dword_100762C0;

//----- (1005EBD0) --------------------------------------------------------
signed int __cdecl sub_1005EBD0()
{
  return sub_1002B11F((int)&byte_10076530, 32, 1, sub_10001880);
}
// 10076530: using guessed type char byte_10076530;

//----- (1005EBF0) --------------------------------------------------------
signed int __cdecl sub_1005EBF0()
{
  return sub_1002B11F((int)&unk_10074E80, 144, 1, sub_10001880);
}

//----- (1005EC20) --------------------------------------------------------
void __cdecl sub_1005EC20()
{
  off_10075048[0] = (int (__stdcall *)(char))&off_1005F33C;
}
// 1005F33C: using guessed type int (__stdcall *off_1005F33C)(char);
// 10075048: using guessed type int (__stdcall *off_10075048[3])(char);

//----- (1005EC60) --------------------------------------------------------
int __cdecl sub_1005EC60()
{
  int result; // eax@2
  void *v1; // esi@2
  char v2; // [sp+1h] [bp-1h]@2

  if ( (unsigned int)dword_10074F24 >= 0x10 )
  {
    v1 = (void *)dword_10074F10;
    sub_100018D0(&v2);
    nullsub_1(&dword_10074F10);
    sub_100018D0(&v2);
    result = sub_1002A4AA(v1);
  }
  dword_10074F24 = 15;
  dword_10074F20 = 0;
  LOBYTE(dword_10074F10) = 0;
  return result;
}
// 100018C0: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074F10: using guessed type int dword_10074F10;
// 10074F20: using guessed type int dword_10074F20;
// 10074F24: using guessed type int dword_10074F24;

//----- (1005ECC0) --------------------------------------------------------
signed int __cdecl sub_1005ECC0()
{
  return sub_1002B11F((int)&unk_10074F28, 80, 1, sub_10001880);
}

//----- (1005ECE0) --------------------------------------------------------
signed int __cdecl sub_1005ECE0()
{
  return sub_1002B11F((int)&unk_10074F80, 80, 1, sub_10001880);
}

//----- (1005ED00) --------------------------------------------------------
int __cdecl sub_1005ED00()
{
  int result; // eax@2
  void *v1; // esi@2
  char v2; // [sp+1h] [bp-1h]@2

  if ( (unsigned int)dword_10074FE4 >= 0x10 )
  {
    v1 = (void *)dword_10074FD0;
    sub_100018D0(&v2);
    nullsub_1(&dword_10074FD0);
    sub_100018D0(&v2);
    result = sub_1002A4AA(v1);
  }
  dword_10074FE4 = 15;
  dword_10074FE0 = 0;
  LOBYTE(dword_10074FD0) = 0;
  return result;
}
// 100018C0: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074FD0: using guessed type int dword_10074FD0;
// 10074FE0: using guessed type int dword_10074FE0;
// 10074FE4: using guessed type int dword_10074FE4;

//----- (1005ED60) --------------------------------------------------------
int __cdecl sub_1005ED60()
{
  int result; // eax@2
  void *v1; // esi@2
  char v2; // [sp+1h] [bp-1h]@2

  if ( (unsigned int)dword_10075014 >= 0x10 )
  {
    v1 = (void *)dword_10075000;
    sub_100018D0(&v2);
    nullsub_1(&dword_10075000);
    sub_100018D0(&v2);
    result = sub_1002A4AA(v1);
  }
  dword_10075014 = 15;
  dword_10075010 = 0;
  LOBYTE(dword_10075000) = 0;
  return result;
}
// 100018C0: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10075000: using guessed type int dword_10075000;
// 10075010: using guessed type int dword_10075010;
// 10075014: using guessed type int dword_10075014;

//----- (1005EDC0) --------------------------------------------------------
int __cdecl sub_1005EDC0()
{
  void *v0; // esi@2
  int result; // eax@3
  char v2; // [sp+1h] [bp-1h]@2

  if ( (unsigned int)dword_10074FFC >= 8 )
  {
    v0 = (void *)dword_10074FE8;
    sub_100018D0(&v2);
    nullsub_1(&dword_10074FE8);
    sub_100018D0(&v2);
    sub_1002A4AA(v0);
  }
  result = 0;
  dword_10074FFC = 7;
  dword_10074FF8 = 0;
  LOWORD(dword_10074FE8) = 0;
  return result;
}
// 100018C0: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10074FE8: using guessed type int dword_10074FE8;
// 10074FF8: using guessed type int dword_10074FF8;
// 10074FFC: using guessed type int dword_10074FFC;

//----- (1005EE20) --------------------------------------------------------
int __cdecl sub_1005EE20()
{
  void *v0; // esi@2
  int result; // eax@3
  char v2; // [sp+1h] [bp-1h]@2

  if ( (unsigned int)dword_1007502C >= 8 )
  {
    v0 = (void *)dword_10075018;
    sub_100018D0(&v2);
    nullsub_1(&dword_10075018);
    sub_100018D0(&v2);
    sub_1002A4AA(v0);
  }
  result = 0;
  dword_1007502C = 7;
  dword_10075028 = 0;
  LOWORD(dword_10075018) = 0;
  return result;
}
// 100018C0: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10075018: using guessed type int dword_10075018;
// 10075028: using guessed type int dword_10075028;
// 1007502C: using guessed type int dword_1007502C;

//----- (1005EE80) --------------------------------------------------------
int __cdecl sub_1005EE80()
{
  LPCWSTR v0; // esi@2
  int result; // eax@3
  char v2; // [sp+1h] [bp-1h]@2

  if ( (unsigned int)dword_10075044 >= 8 )
  {
    v0 = pszAgentW;
    sub_100018D0(&v2);
    nullsub_1(&pszAgentW);
    sub_100018D0(&v2);
    sub_1002A4AA((LPVOID)v0);
  }
  result = 0;
  dword_10075044 = 7;
  dword_10075040 = 0;
  LOWORD(pszAgentW) = 0;
  return result;
}
// 100018C0: using guessed type _DWORD __stdcall nullsub_1(_DWORD);
// 1002A4AA: using guessed type _DWORD __cdecl sub_1002A4AA(LPVOID lpMem);
// 10075040: using guessed type int dword_10075040;
// 10075044: using guessed type int dword_10075044;

//----- (1005EEE0) --------------------------------------------------------
int __cdecl sub_1005EEE0()
{
  if ( hInternet )
  {
    WinHttpCloseHandle(hInternet);
    hInternet = 0;
  }
  if ( pProxyConfig.lpszAutoConfigUrl )
    GlobalFree(pProxyConfig.lpszAutoConfigUrl);
  if ( pProxyConfig.lpszProxy )
    GlobalFree(pProxyConfig.lpszProxy);
  if ( pProxyConfig.lpszProxyBypass )
    GlobalFree(pProxyConfig.lpszProxyBypass);
  return nullsub_2(&unk_10076844);
}
// 1002C171: using guessed type int __thiscall nullsub_2(_DWORD);

#error "There were 343 decompilation failure(s) on 3356 function(s)"
