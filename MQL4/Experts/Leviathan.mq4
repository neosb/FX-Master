//+-----------------------------------------------------------------------------------+
//|                                                         Leviathan_v4.0_SqLite.mq4 |
//|                                              Copyright 2015, Al.Fa.Software Corp. |
//|                                                               http://www.mql5.com |
//| Assert History                                                                    |
//| 1.11    Fixed minor bug in ChickenOutClose.                                       |
//| 1.10    Added PlusGhost.                                                          |
//| 1.00    Generated by EX4 TO MQ4 decompile Service.                                |
//|                      Leviathan 2.0 Fixed SE Version by ApM                        |
//|-------- Last update 29/07/2012 ------------------- E-mail : apmsoft@mail.ru ------|
//| Fix 0.1 Fixed Multiplier (fun0 remake 20/06/2012)                                 |
//| Fix 0.2 Fixed ECN orders SL/TP error (29/06/2012), not complety                   |
//| Fix 0.2 Settings for Augmenter on & off from settings                             |
//| Fix 0.3 Negative Basket Protection, low margin check, auto magic number, chartcom |
//| Fix 0.4 ECN always true, Fixed 3/5 digits processing, CheckStoplossZero    18/07  |
//| Fix 0.5 "Trade context is busy" fix, CheckStoplossZero deleted             29/07  |
//+-----------------------------------------------------------------------------------+
#property copyright "Copyright 2015, Al.Fa.Software Corp."
#property link      "http://www.mql5.com"
#property version   "4.0"
#property strict

//--- Assert 2: Plus include files
#include <PlusTurtle.mqh>
#include <PlusGhost.mqh>
#include <orders.mqh>
#include <stdlib.mqh>

#import "stdlib.ex4"
   string ErrorDescription(int a0);
#import

int   MaxAccountTrades = 30;

int gi_76;
string gs_dummy_80;
string gsa_92[4] = {"0000000000", "1111111111", "2222222222", "33333333333"};
string Register_Number = "";
string User = "";
string KEY = "";
extern string EA_Name = "Leviathan";
extern string _________ = "Input a unique magic number for each chart";
extern int MagicNumber = 0;
extern double BaseLotSize = 0.01;
extern bool LotStepEnable    = true;
extern double LotStepValue   = 0.01;
extern double LotStepFrom    = 500;
extern double LotStepEvery   = 500;
extern int ExecutionPoint = 0;
extern double BasketTakeProfit = 60.0;
extern int BasketStopLoss = 0;
extern double EquityShield    = 0;
extern double ProgressiveStopLossPerc = 0;
extern double Multiplier = 1.0;
extern int MaximumBuyLevels = 0;
extern int MaximumSellLevels = 0;
/*extern*/ bool EnvyAugmenterOn = TRUE;
/*extern*/ bool Negative_Basket_Protection = TRUE;
/*extern*/ int NBP = 0;
extern int Slippage = 0;
string gs_168 = "1234567890123456";

/*extern*/ double BailOutPct = 100.0;
/*extern*/ bool Chicken_Out = FALSE;
/*extern*/ int Close_Order_Attempts = 3;
/*extern*/ bool FreezeAfterTP = FALSE;
/*extern*/ bool FreezeAfterTPScheduler = FALSE;
extern bool SupportECN = TRUE;
/*extern*/ string __________ = "Freeze After TP Scheduler";
/*extern*/ int SUN_StartHour = 0;
/*extern*/ int SUN_StartMinute = 0;
/*extern*/ int SUN_EndHour = 0;
/*extern*/ int SUN_EndMinute = 0;
/*extern*/ int MON_StartHour = 0;
/*extern*/ int MON_StartMinute = 0;
/*extern*/ int MON_EndHour = 0;
/*extern*/ int MON_EndMinute = 0;
/*extern*/ int TUE_StartHour = 0;
/*extern*/ int TUE_StartMinute = 0;
/*extern*/ int TUE_EndHour = 0;
/*extern*/ int TUE_EndMinute = 0;
/*extern*/ int WED_StartHour = 0;
/*extern*/ int WED_StartMinute = 0;
/*extern*/ int WED_EndHour = 0;
/*extern*/ int WED_EndMinute = 0;
/*extern*/ int THU_StartHour = 0;
/*extern*/ int THU_StartMinute = 0;
/*extern*/ int THU_EndHour = 0;
/*extern*/ int THU_EndMinute = 0;
/*extern*/ int FRI_StartHour = 0;
/*extern*/ int FRI_StartMinute = 0;
/*extern*/ int FRI_EndHour = 0;
/*extern*/ int FRI_EndMinute = 0;
/*extern*/ int SAT_StartHour = 0;
/*extern*/ int SAT_StartMinute = 0;
/*extern*/ int SAT_EndHour = 0;
/*extern*/ int SAT_EndMinute = 0;
extern string ____________ = "";
/*extern*/ string EnvyAugmenter = "";
extern string Level_1 = "";
extern double Multiplier_1 = 0.0;
extern double BasketTakeProfit_1 = 0.0;
extern string Level_2 = "";
extern double Multiplier_2 = 0.0;
extern double BasketTakeProfit_2 = 0.0;
extern string Level_3 = "";
extern double Multiplier_3 = 0.0;
extern double BasketTakeProfit_3 = 0.0;
extern string Level_4 = "";
extern double Multiplier_4 = 0.0;
extern double BasketTakeProfit_4 = 0.0;
extern string Level_5 = "";
extern double Multiplier_5 = 0.0;
extern double BasketTakeProfit_5 = 0.0;
extern string Level_6 = "";
extern double Multiplier_6 = 0.0;
extern double BasketTakeProfit_6 = 0.0;
extern string Level_7 = "";
extern double Multiplier_7 = 0.0;
extern double BasketTakeProfit_7 = 0.0;
extern string Level_8 = "";
extern double Multiplier_8 = 0.0;
extern double BasketTakeProfit_8 = 0.0;
extern string Level_9 = "";
extern double Multiplier_9 = 0.0;
extern double BasketTakeProfit_9 = 0.0;
extern string Level_10 = "";
extern double Multiplier_10 = 0.0;
extern double BasketTakeProfit_10 = 0.0;
extern string Level_11 = "";
extern double Multiplier_11 = 0.0;
extern double BasketTakeProfit_11 = 0.0;
extern string Level_12 = "";
extern double Multiplier_12 = 0.0;
extern double BasketTakeProfit_12 = 0.0;
extern string Level_13 = "";
extern double Multiplier_13 = 0.0;
extern double BasketTakeProfit_13 = 0.0;
extern string Level_14 = "";
extern double Multiplier_14 = 0.0;
extern double BasketTakeProfit_14 = 0.0;
extern string Level_15 = "";
extern double Multiplier_15 = 0.0;
extern double BasketTakeProfit_15 = 0.0;
extern string Level_16 = "";
extern double Multiplier_16 = 0.0;
extern double BasketTakeProfit_16 = 0.0;
extern string Level_17 = "";
extern double Multiplier_17 = 0.0;
extern double BasketTakeProfit_17 = 0.0;
extern string Level_18 = "";
extern double Multiplier_18 = 0.0;
extern double BasketTakeProfit_18 = 0.0;
extern string Level_19 = "";
extern double Multiplier_19 = 0.0;
extern double BasketTakeProfit_19 = 0.0;
extern string Level_20 = "";
extern double Multiplier_20 = 0.0;
extern double BasketTakeProfit_20 = 0.0;
extern string Level_21 = "";
extern double Multiplier_21 = 0.0;
extern double BasketTakeProfit_21 = 0.0;
extern string Level_22 = "";
extern double Multiplier_22 = 0.0;
extern double BasketTakeProfit_22 = 0.0;
extern string Level_23 = "";
extern double Multiplier_23 = 0.0;
extern double BasketTakeProfit_23 = 0.0;
extern string Level_24 = "";
extern double Multiplier_24 = 0.0;
extern double BasketTakeProfit_24 = 0.0;
extern string Level_25 = "";
extern double Multiplier_25 = 0.0;
extern double BasketTakeProfit_25 = 0.0;
extern bool   DrawLines = TRUE;
extern bool   UseSignalsNBP = TRUE;
/*
extern string _____ = "SWB indicator settings";
extern bool Use_SWB_indicator = false;
extern bool      swb_is_reversed = FALSE;

extern bool      use_bb=true;
extern int       bb_period=20;
extern int       bb_deviation=2;
extern int       bb_shift=0;
extern bool      use_stoch=true;
extern int       k=5;
extern int       d=3;
extern int       slowing=3;
extern int       price_field=0;
extern int       stoch_shift=0;
extern int       lo_level=30;
extern int       up_level=70;
extern bool      use_rsi=true;
extern int       rsi_period=12;
extern int       rsi_shift=0;
extern int       lower=30;
extern int       upper=70;
*/
double gd_948;
bool gi_956 = FALSE;
bool gi_960 = FALSE;
double gd_964;
double g_pips_972 = 0.0;
int gi_unused_980 = 0;
int gi_984 = 0;
int gi_unused_988 = 300;
int gi_992 = 5000;
int gi_996 = 0;
int gi_1000 = 0;
double gd_1004 = 100.0;
int gi_1012 = 600;
double gd_1016;
bool gi_1024;
int g_period_1028 = 7;
int gi_1032 = 0;
int g_ma_method_1036 = MODE_LWMA;
int g_applied_price_1040 = PRICE_WEIGHTED;
double gd_1044 = 0.25;
double gd_1052 = 0.2;
double gd_1060 = 1.01;
int gi_1068 = 5;
int g_datetime_1072;
double gd_1076;
int gi_1084;
bool gi_unused_1088 = FALSE;
string gs_dummy_1092;
int gi_unused_1108 = 0;
int gi_unused_1112 = 1;
int gi_unused_1116 = 3;
int gi_unused_1120 = 250;
string gs_1124;
bool gi_1132;
bool gi_1136;
bool gi_1140;
bool gi_1144;
int g_ticket_1148;
int g_cmd_1152;
string gs__hedged_1156 = " hedged";
int gi_1164;
bool gi_1168 = FALSE;
string gs_1172 = "12345678901234567890123456789012345678901234567890ABCDEFGHIJKLMNOP";
double gda_1180[27];
double gda_1184[27];
double gda_1196[4];
int gi_1200;
double g_point_1204 = 0.0001;
bool gi_1212 = FALSE;
int gia_1216[25];
int gia_1220[25];
double gda_1224[25];
double gda_1228[25];
double gda_1232[25];
double gda_1236[25];
int g_error_1248;
int gLevel[2]; //SE for chart_comment
double gPoint = 0.0001; // Fix for 3/5 Digits
int SignalPeriod = PERIOD_H1;
double Last_TP[2]; // Fix 0.5 to store TP if TCB

double StartingBalance;

//--------------------------------- SPIKES ----
/*extern*/ double ATR_Slow_Period = 60;
/*extern*/ double ATR_Fast_Period = 1;
/*extern*/ int MinutesToSleep = PERIOD_H1;
/*extern*/ int LittleSpikeMultiplier = 3;
/*extern*/ int BigSpikeMultiplier = 5;
bool spikeAlert=false;
datetime lastSpikeAlertTime;
//--------------------------------- PIVOTS ----
double Fhr_day_high=0;
double Fhr_day_low=0;
double Fhr_yesterday_high=0;
double Fhr_yesterday_open=0;
double Fhr_yesterday_low=0;
double Fhr_yesterday_close=0;
double Fhr_today_open=0;
double Fhr_today_high=0;
double Fhr_today_low=0;
double Fhr_P=0;
double Fhr_Q=0;
double Fhr_R1,Fhr_R2,Fhr_R3;
double Fhr_M0,Fhr_M1,Fhr_M2,Fhr_M3,Fhr_M4,Fhr_M5;
double Fhr_S1,Fhr_S2,Fhr_S3;
double Fhr_nQ=0;
double Fhr_nD=0;
double Fhr_D=0;
double Fhr_rates_d1[2][6];
double Fhr_ExtMapBuffer[];
//---------------------------------
double D_day_high=0;
double D_day_low=0;
double D_yesterday_high=0;
double D_yesterday_open=0;
double D_yesterday_low=0;
double D_yesterday_close=0;
double D_today_open=0;
double D_today_high=0;
double D_today_low=0;
double D_P=0;
double D_Q=0;
double D_R1,D_R2,D_R3;
double D_M0,D_M1,D_M2,D_M3,D_M4,D_M5;
double D_S1,D_S2,D_S3;
double D_nQ=0;
double D_nD=0;
double D_D=0;
double D_rates_d1[2][6];
double D_ExtMapBuffer[];
//---------------------------------
double nearest_support = 0;
double nearest_resistance = 0;
double nearest_daily_support = 0;
double nearest_daily_resistance = 0;

double farest_support = 0;
double farest_resistance = 0;
double farest_daily_support = 0;
double farest_daily_resistance = 0;
//---------------------------------

//---------------------------------------------------------------------------

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- create timer
   EventSetTimer(60);

//--- Assert 0: Init Plus   
   TurtleInit();
   GhostInit();
//--- 
   gi_1212 = FALSE;
   if (Chicken_Out == TRUE) gi_960 = TRUE;
   else gi_960 = FALSE;
   if (Period() != PERIOD_M30) {
      Print("ERROR -- Leviathan should be attached to " + Symbol() + " 30 minute chart window");
      Alert("ERROR -- Leviathan should be attached to " + Symbol() + " 30 minute chart window");
   }
   updateMagicNumber();
   MathSrand(ExecutionPoint+BasketTakeProfit*Multiplier); // Fix 0.5 for Un-synk
   gsa_92[0] = GhostAccountNumber();
   gsa_92[1] = KEY;
   gsa_92[2] = User;
   gsa_92[3] = gs_168;
   gi_76 = fun1(gsa_92, ArraySize(gsa_92), 0.1, gs_1172, IsDemo());
   gd_964 = Multiplier;
   if (Digits == 3) {
      gi_unused_980 = 10.0 * ExecutionPoint;
      gi_984 = 10.0 * BasketStopLoss;
      g_point_1204 = 0.01;
   } else {
      if (Digits == 5) {
         gi_unused_980 = 10.0 * ExecutionPoint;
         gi_984 = 10.0 * BasketStopLoss;
         g_point_1204 = 0.0001;
      } else {
         gi_unused_980 = ExecutionPoint;
         gi_984 = BasketStopLoss;
         g_point_1204 = Point;
      }
   }
   gda_1180[0] = BasketTakeProfit_1;
   gda_1180[1] = BasketTakeProfit_2;
   gda_1180[2] = BasketTakeProfit_3;
   gda_1180[3] = BasketTakeProfit_4;
   gda_1180[4] = BasketTakeProfit_5;
   gda_1180[5] = BasketTakeProfit_6;
   gda_1180[6] = BasketTakeProfit_7;
   gda_1180[7] = BasketTakeProfit_8;
   gda_1180[8] = BasketTakeProfit_9;
   gda_1180[9] = BasketTakeProfit_10;
   gda_1180[10] = BasketTakeProfit_11;
   gda_1180[11] = BasketTakeProfit_12;
   gda_1180[12] = BasketTakeProfit_13;
   gda_1180[13] = BasketTakeProfit_14;
   gda_1180[14] = BasketTakeProfit_15;
   gda_1180[15] = BasketTakeProfit_16;
   gda_1180[16] = BasketTakeProfit_17;
   gda_1180[17] = BasketTakeProfit_18;
   gda_1180[18] = BasketTakeProfit_19;
   gda_1180[19] = BasketTakeProfit_20;
   gda_1180[20] = BasketTakeProfit_21;
   gda_1180[21] = BasketTakeProfit_22;
   gda_1180[22] = BasketTakeProfit_23;
   gda_1180[23] = BasketTakeProfit_24;
   gda_1180[24] = BasketTakeProfit_25;
   gda_1180[25] = BasketTakeProfit;
   gda_1180[26] = BasketTakeProfit_1;
   gda_1184[0] = Multiplier_1;
   gda_1184[1] = Multiplier_2;
   gda_1184[2] = Multiplier_3;
   gda_1184[3] = Multiplier_4;
   gda_1184[4] = Multiplier_5;
   gda_1184[5] = Multiplier_6;
   gda_1184[6] = Multiplier_7;
   gda_1184[7] = Multiplier_8;
   gda_1184[8] = Multiplier_9;
   gda_1184[9] = Multiplier_10;
   gda_1184[10] = Multiplier_11;
   gda_1184[11] = Multiplier_12;
   gda_1184[12] = Multiplier_13;
   gda_1184[13] = Multiplier_14;
   gda_1184[14] = Multiplier_15;
   gda_1184[15] = Multiplier_16;
   gda_1184[16] = Multiplier_17;
   gda_1184[17] = Multiplier_18;
   gda_1184[18] = Multiplier_19;
   gda_1184[19] = Multiplier_20;
   gda_1184[20] = Multiplier_21;
   gda_1184[21] = Multiplier_22;
   gda_1184[22] = Multiplier_23;
   gda_1184[23] = Multiplier_24;
   gda_1184[24] = Multiplier_25;
   gda_1184[25] = Multiplier;
   gda_1184[26] = Multiplier_1;
   int li_0 = fun0(gda_1180, gda_1184, Digits, 0, Point, gda_1196, 0, IsDemo());
   if (li_0 >= 0) {
      g_pips_972 = gda_1196[0];
      gd_1076 = gda_1196[1];
      gd_964 = gda_1196[2];
   }
   gi_1084 = MathRound((-MathLog(MarketInfo(Symbol(), MODE_LOTSTEP))) / 2.302585093);
   gi_1132 = FALSE;
   gi_1136 = FALSE;
   gi_1140 = FALSE;
   gi_1144 = FALSE;
   g_ticket_1148 = -1;
   gi_1024 = FALSE;
   g_cmd_1152 = -1;
   gs_1124 = "approved";
   if (gi_76 == 0) {
      Print("Please input valid KEY.");
      Alert("Please input valid KEY.");
   }
   StartingBalance = AccountBalance();
   GhostFreeSelect(false);
//---
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- destroy timer
   EventKillTimer();
//--- Assert 2: DeInit Plus
   GhostDeInit();
   Comment("");
   ObjectDelete("Buy_Target");
   ObjectDelete("Buy_StopLoss");
   ObjectDelete("Sell_Target");
   ObjectDelete("Sell_StopLoss");
  }
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//-------------------------------------------------------------------------
//-- Pivots, Support/Resistance and Price Alerts
//get_pivots(symbol, timeframe);
get_NearestAndFarestSR(Symbol(), PERIOD_H4, (iLow(Symbol(), PERIOD_H4, 2)+iHigh(Symbol(), PERIOD_H4, 2))/2.0 );
//---

//------------------------------------------------------------------------------------------
if (DrawLines)
{
//--- Draw Pivot lines on chart
   if(ObjectFind("Nearest_Support label") == 0) ObjectDelete("Nearest_Support label");
    ObjectCreate("Nearest_Support label", OBJ_TEXT, 0, Time[0], nearest_support);
    ObjectSetText("Nearest_Support label", "Nearest Support @ " +DoubleToStr((iLow(Symbol(), 0, 1)+iHigh(Symbol(), 0, 1))/2.0,4)+ " -> " +DoubleToStr(nearest_support,4), 8, "Arial", EMPTY);
   if(ObjectFind("Nearest_Support line") != 0)
   {
      ObjectCreate("Nearest_Support line", OBJ_HLINE, 0, Time[0], nearest_support);
      ObjectSet("Nearest_Support line", OBJPROP_STYLE, STYLE_SOLID);
      ObjectSet("Nearest_Support line", OBJPROP_WIDTH,2);
      ObjectSet("Nearest_Support line", OBJPROP_COLOR, Blue);
   }
   else
   {
      ObjectMove("Nearest_Support line", 0, Time[40], nearest_support);
   }
//-----
   if(ObjectFind("Nearest_Resistance label") == 0) ObjectDelete("Nearest_Resistance label");
    ObjectCreate("Nearest_Resistance label", OBJ_TEXT, 0, Time[0], nearest_resistance);
    ObjectSetText("Nearest_Resistance label", "Nearest Resistance @ " +DoubleToStr((iLow(Symbol(), 0, 1)+iHigh(Symbol(), 0, 1))/2.0,4)+ " -> " +DoubleToStr(nearest_resistance,4), 8, "Arial", EMPTY);
   if(ObjectFind("Nearest_Resistance line") != 0)
   {
      ObjectCreate("Nearest_Resistance line", OBJ_HLINE, 0, Time[0], nearest_resistance);
      ObjectSet("Nearest_Resistance line", OBJPROP_STYLE, STYLE_SOLID);
      ObjectSet("Nearest_Resistance line", OBJPROP_WIDTH,2);
      ObjectSet("Nearest_Resistance line", OBJPROP_COLOR, Red);
   }
   else
   {
      ObjectMove("Nearest_Resistance line", 0, Time[40], nearest_resistance);
   }
//-----
   if(ObjectFind("Nearest_Daily_Support label") == 0) ObjectDelete("Nearest_Daily_Support label");
    ObjectCreate("Nearest_Daily_Support label", OBJ_TEXT, 0, Time[0], nearest_daily_support);
    ObjectSetText("Nearest_Daily_Support label", "Nearest Daily Support @ " +DoubleToStr((iLow(Symbol(), 0, 1)+iHigh(Symbol(), 0, 1))/2.0,4)+ " -> " +DoubleToStr(nearest_daily_support,4), 8, "Arial", EMPTY);
   if(ObjectFind("Nearest_Daily_Support line") != 0)
   {
      ObjectCreate("Nearest_Daily_Support line", OBJ_HLINE, 0, Time[0], nearest_daily_support);
      ObjectSet("Nearest_Daily_Support line", OBJPROP_STYLE, STYLE_SOLID);
      ObjectSet("Nearest_Daily_Support line", OBJPROP_WIDTH,2);
      ObjectSet("Nearest_Daily_Support line", OBJPROP_COLOR, LightBlue);
   }
   else
   {
      ObjectMove("Nearest_Daily_Support line", 0, Time[40], nearest_daily_support);
   }
//-----
   if(ObjectFind("Nearest_Daily_Resistance label") == 0) ObjectDelete("Nearest_Daily_Resistance label");
    ObjectCreate("Nearest_Daily_Resistance label", OBJ_TEXT, 0, Time[0], nearest_daily_resistance);
    ObjectSetText("Nearest_Daily_Resistance label", "Nearest Daily Resistance @ " +DoubleToStr((iLow(Symbol(), 0, 1)+iHigh(Symbol(), 0, 1))/2.0,4)+ " -> " +DoubleToStr(nearest_daily_resistance,4), 8, "Arial", EMPTY);
   if(ObjectFind("Nearest_Daily_Resistance line") != 0)
   {
      ObjectCreate("Nearest_Daily_Resistance line", OBJ_HLINE, 0, Time[0], nearest_daily_resistance);
      ObjectSet("Nearest_Daily_Resistance line", OBJPROP_STYLE, STYLE_SOLID);
      ObjectSet("Nearest_Daily_Resistance line", OBJPROP_WIDTH,2);
      ObjectSet("Nearest_Daily_Resistance line", OBJPROP_COLOR, LightPink);
   }
   else
   {
      ObjectMove("Nearest_Daily_Resistance line", 0, Time[40], nearest_daily_resistance);
   }
//-----
   WindowRedraw();
//-----
}
//------------------------------------------------------------------------------------------

//---
   double order_takeprofit_0;
   double ld_8;
   double ld_16;
   double order_takeprofit_44;
   int li_52;
   bool bool_56;
   f0_8();
   if (IsTesting()) {
      if (Period() != PERIOD_M30) {
         Print("ERROR -- Leviathan should be attached to " + Symbol() + " 30 minute chart window");
         Alert("ERROR -- Leviathan should be attached to " + Symbol() + " 30 minute chart window");
         return;
      }
   } else {
      if (Period() != PERIOD_M30) {
         Print("ERROR -- Leviathan should be attached to " + Symbol() + " 30 minute chart window");
         Alert("ERROR -- Leviathan should be attached to " + Symbol() + " 30 minute chart window");
         return;
      }
   }

//-----------------------------------
//--- SPIKE ALERT
   bool spikeDetected = false;

   //---
   //double ATRfast = iATR(Symbol(), PERIOD_M15, ATR_Fast_Period, 0);
   //double ATRslow = iATR(Symbol(), PERIOD_M15, ATR_Slow_Period, 0);   
   //if ( ATRfast >= (BigSpikeMultiplier *  ATRslow) ) spikeDetected = true;
   //---
   double ATRfast = iATR(Symbol(), 0, ATR_Fast_Period, 0);
   double ATRslow = iATR(Symbol(), 0, ATR_Slow_Period, 0);   
   if ( !spikeDetected && ATRfast >= (BigSpikeMultiplier *  ATRslow) ) spikeDetected = true;
   //---
   ATRfast = iATR(Symbol(), PERIOD_H1, ATR_Fast_Period, 0);
   ATRslow = iATR(Symbol(), PERIOD_H1, ATR_Slow_Period, 0);   
   if ( !spikeDetected && ATRfast >= (BigSpikeMultiplier *  ATRslow) ) spikeDetected = true;
   //---
   
   if( !spikeAlert && spikeDetected && (TimeCurrent() - lastSpikeAlertTime) >= MinutesToSleep*60)
   {
      Alert("Spike on " + Symbol() + "!");
      Log("[SPIKE ALERT] - (Fast = " + ATRfast + ", Slow = " + ATRslow + ") - Sleep for "+MinutesToSleep+" minutes ...");
      CloseAllOrders();
      spikeAlert = true;
      lastSpikeAlertTime = TimeCurrent();
   }

   if( spikeAlert )
   {
      if( (TimeCurrent() - lastSpikeAlertTime) >= MinutesToSleep*60 ) 
      {
         Log("[SPIKE ALERT] - Wake up after ",IntegerToString(MinutesToSleep)," minutes...");
         spikeAlert = false;
      }
      else
      {
         return;
      }
   }
//-----------------------------------  
   if (gi_960 == TRUE) {
      ChickenOutClose(Symbol());
      return;
   }
   if (FreezeAfterTPScheduler == TRUE) gi_956 = f0_4();
   gsa_92[0] = GhostAccountNumber();
   gsa_92[1] = KEY;
   gsa_92[2] = User;
   gsa_92[3] = gs_168;
   gi_76 = fun1(gsa_92, ArraySize(gsa_92), 0.2, gs_1172, IsDemo());
   if (gs_1124 != "approved" || gi_76 == 0) {
      Comment("Access denied!", 
      "\nPlease input valid KEY and User into the EA parameters.");
      return;
   }
   int count_24 = 0;
   int count_28 = 0;
//--- Assert 0: close most losing orders
   ProgressiveStopLoss();
//--- Assert 1: equity protection
   EquityStopLoss();
//--- Assert 2: Init OrderSelect #15
   int total = GhostOrdersTotal();
   
   if (total == 0 && AccountBalance() > StartingBalance) StartingBalance = AccountBalance();
   
   GhostInitSelect(true,0,SELECT_BY_POS,MODE_TRADES);
   for (int pos_32 = 0; pos_32 < total; pos_32++) {
      if (GhostOrderSelect(pos_32, SELECT_BY_POS, MODE_TRADES)) {
         if (GhostOrderMagicNumber() == MagicNumber) {
            if (StringFind(GhostOrderComment(), gs__hedged_1156) == -1) {
               if (GhostOrderType() == OP_BUY) {
                  count_24++;
                  continue;
               }
               if (GhostOrderType() == OP_SELL) count_28++;
            }
         }
      }
   }
//--- Assert 1: Free OrderSelect #15
   GhostFreeSelect(false);
   if (count_24 >= gi_1068) {
      if (!gi_1144) {
         f0_16("Allow long hedge! trades=" + count_24 + ",TradesDeep=" + gi_1068);
         gi_1144 = TRUE;
      }
   }
   if (count_28 >= gi_1068) {
      if (!gi_1140) {
         f0_16("Allow short hedge! trades=" + count_28 + ",TradesDeep=" + gi_1068);
         gi_1140 = TRUE;
      }
   }
   bool li_36 = FALSE;
   if ((100 - BailOutPct) * GhostAccountBalance() / 100.0 >= GhostAccountEquity()) {
      f0_16("AccountBalance=" + GhostAccountBalance() + ",AccountEquity=" + GhostAccountEquity());
      gi_1024 = TRUE;
      li_36 = TRUE;
   }
   if ((gd_1004 + 100.0) * GhostAccountBalance() / 100.0 <= GhostAccountEquity()) gi_1024 = TRUE;
   if (gi_1024) {
   //--- Assert 6: Declare variables
      int      aCommand[];    // 1-OrderModify BUY; 2-OrderClose BUY; 3-OrderModify SELL; 4-OrderClose SELL;
      int      aTicket[];
      double   aLots[];
      double   aClosePrice[];
      bool     aOk[];
      int      aCount;
   //--- Assert 5: Dynamically resize arrays
      ArrayResize(aCommand,MaxAccountTrades);
      ArrayResize(aTicket,MaxAccountTrades);
      ArrayResize(aLots,MaxAccountTrades);
      ArrayResize(aClosePrice,MaxAccountTrades);
      ArrayResize(aOk,MaxAccountTrades);
   //--- Assert 2: Init OrderSelect #16
      int      aTotal = GhostOrdersTotal();
      GhostInitSelect(false,0,SELECT_BY_POS,MODE_TRADES);
      for (int pos_40 = aTotal - 1; pos_40 >= 0; pos_40--) {
         if (GhostOrderSelect(pos_40, SELECT_BY_POS)) {
         //--- Assert 5: Populate arrays
            aCommand[aCount]     =  2;
            aTicket[aCount]      =  GhostOrderTicket();
            aLots[aCount]        =  GhostOrderLots();
            aClosePrice[aCount]  =  GhostOrderClosePrice();
            if (GhostOrderMagicNumber() == MagicNumber) {
               f0_16("close #" + GhostOrderTicket());
            //--- 6: Assert replace OrderClose a buy trade with arrays
               aCommand[aCount]     = 2; 
               aClosePrice[aCount]  = NormalizeDouble(Bid, Digits);
               aCount ++;
               if( aCount >= MaxAccountTrades ) break;
               /*if (!OrderClose(OrderTicket(), OrderLots(), OrderClosePrice(), MarketInfo(Symbol(), MODE_SPREAD), White)) {
                  f0_16("error");
                  return (0);
               }*/
            }
         }
      }
   //--- Assert 1: Free OrderSelect #16
      GhostFreeSelect(false);
   //--- Assert for: process array of commands
      for(int i=0; i<aCount; i++)
      {
         switch( aCommand[i] )
         {
            case 1:  // OrderModify Buy
            case 2:  // OrderClose Buy
               GhostOrderClose( aTicket[i], aLots[i], aClosePrice[i], MarketInfo(Symbol(), MODE_SPREAD), White );
               break;
            case 3:  // OrderModify Sell
            case 4:  // OrderClose Sell
               break;
         }
      }
      gi_1024 = FALSE;
      if (li_36) {
         Sleep(1000 * gi_1012);
         li_36 = FALSE;
      }
      gi_1144 = FALSE;
      gi_1140 = FALSE;
   }
   if (SupportECN) {
      order_takeprofit_0 = 0;
   //--- Assert 1: Init OrderSelect #17
      GhostInitSelect(true,g_ticket_1148,SELECT_BY_TICKET,MODE_TRADES);
      if (GhostOrderSelect(g_ticket_1148, SELECT_BY_TICKET)) order_takeprofit_0 = GhostOrderTakeProfit();
   //--- Assert 1: Free OrderSelect #17
      GhostFreeSelect(false);
   //--- Assert 7: Declare variables
      int      bCommand[];    // 1-OrderModify BUY; 2-OrderClose BUY; 3-OrderModify SELL; 4-OrderClose SELL;
      int      bTicket[];
      double   bOpenPrice[];
      double   bStopLoss[];
      double   bTakeProfit[];
      bool     bOk[];
      int      bCount;
   //--- Assert 6: Dynamically resize arrays
      ArrayResize(bCommand,MaxAccountTrades);
      ArrayResize(bTicket,MaxAccountTrades);
      ArrayResize(bOpenPrice,MaxAccountTrades);
      ArrayResize(bStopLoss,MaxAccountTrades);
      ArrayResize(bTakeProfit,MaxAccountTrades);
      ArrayResize(bOk,MaxAccountTrades);
   //--- Assert 2: Init OrderSelect #18
      int   bTotal = GhostOrdersTotal();
      GhostInitSelect(true,0,SELECT_BY_POS,MODE_TRADES);
      for (int pos_40 = 0; pos_40 < bTotal; pos_40++) {
         if (GhostOrderSelect(pos_40, SELECT_BY_POS)) {
         //--- Assert 5: Populate arrays
            bCommand[bCount]     =  0;
            bTicket[bCount]      =  GhostOrderTicket();
            bOpenPrice[bCount]   =  GhostOrderOpenPrice();
            bStopLoss[bCount]    =  GhostOrderStopLoss();
            bTakeProfit[bCount]  =  GhostOrderTakeProfit();
            if (GhostOrderMagicNumber() == MagicNumber) {
               order_takeprofit_44 = GhostOrderTakeProfit();
               if (order_takeprofit_44 == 0.0 && StringFind(GhostOrderComment(), gs__hedged_1156) == -1) {
                  if (GhostOrderType() == OP_BUY) {
                     if (count_24 > 0) {
                        gi_1200 = fun0(gda_1180, gda_1184, Digits, count_24 - 1, Point, gda_1196, count_24 - 1, IsDemo());
                        if (gi_1200 >= 0) {
                           g_pips_972 = gda_1196[0];
                           gd_1076 = gda_1196[1];
                           gd_964 = gda_1196[2];
                           if (gi_1200 == 0) gi_1168 = FALSE;
                           else gi_1168 = TRUE;
                        }
                     } else {
                        gi_1200 = fun0(gda_1180, gda_1184, Digits, count_24, Point, gda_1196, count_24, IsDemo());
                        if (gi_1200 >= 0) {
                           g_pips_972 = gda_1196[0];
                           gd_1076 = gda_1196[1];
                           gd_964 = gda_1196[2];
                           if (gi_1200 == 0) gi_1168 = FALSE;
                           else gi_1168 = TRUE;
                        }
                     }
                     li_52 = Close_Order_Attempts;
                     bool_56 = FALSE;
                     while (bool_56 == FALSE && li_52 >= 0) {
                        li_52--;
                        RefreshRates();
                     //--- 6: Assert replace OrderModify a buy trade with arrays
                        bCommand[bCount]     = 1; 
                        bOpenPrice[bCount]   = 0;
                        bStopLoss[bCount]    = NormalizeDouble(GhostOrderStopLoss(), Digits);
                        bTakeProfit[bCount]  = NormalizeDouble(GhostOrderOpenPrice() + g_pips_972 * Point, Digits);
                        bCount ++;
                        if( bCount >= MaxAccountTrades ) break;
                        /*bool_56 = OrderModify(OrderTicket(), 0, NormalizeDouble(OrderStopLoss(), Digits), NormalizeDouble(OrderOpenPrice() + g_pips_972 * Point, Digits), 0, White);*/
                        if (!TRUE) {
                           g_error_1248 = GetLastError();
                           if (g_error_1248 == 146/* TRADE_CONTEXT_BUSY */) {
                              Sleep(50);
                              continue;
                           }
                        }
                        bool_56 = TRUE;
                     }
                  } else {
                     if (GhostOrderType() != OP_SELL) continue;
                     if (count_28 > 0) {
                        gi_1200 = fun0(gda_1180, gda_1184, Digits, count_28 - 1, Point, gda_1196, count_28 - 1, IsDemo());
                        if (gi_1200 >= 0) {
                           g_pips_972 = gda_1196[0];
                           gd_1076 = gda_1196[1];
                           gd_964 = gda_1196[2];
                           if (gi_1200 == 0) gi_1168 = FALSE;
                           else gi_1168 = TRUE;
                        }
                     } else {
                        gi_1200 = fun0(gda_1180, gda_1184, Digits, count_28, Point, gda_1196, count_28, IsDemo());
                        if (gi_1200 >= 0) {
                           g_pips_972 = gda_1196[0];
                           gd_1076 = gda_1196[1];
                           gd_964 = gda_1196[2];
                           if (gi_1200 == 0) gi_1168 = FALSE;
                           else gi_1168 = TRUE;
                        }
                     }
                     li_52 = Close_Order_Attempts;
                     bool_56 = FALSE;
                     while (bool_56 == FALSE && li_52 >= 0) {
                        li_52--;
                        RefreshRates();
                     //--- 6: Assert replace OrderModify a sell trade with arrays
                        bCommand[bCount]     = 3; 
                        bOpenPrice[bCount]   = 0;
                        bStopLoss[bCount]    = NormalizeDouble(GhostOrderStopLoss(), Digits);
                        bTakeProfit[bCount]  = NormalizeDouble(GhostOrderOpenPrice() - g_pips_972 * Point, Digits);
                        bCount ++;
                        if( bCount >= MaxAccountTrades ) break;
                        /*bool_56 = OrderModify(OrderTicket(), 0, NormalizeDouble(OrderStopLoss(), Digits), NormalizeDouble(OrderOpenPrice() - g_pips_972 * Point, Digits), 0, White);*/
                        if (!TRUE) {
                           g_error_1248 = GetLastError();
                           if (g_error_1248 == 146/* TRADE_CONTEXT_BUSY */) {
                              Sleep(50);
                              continue;
                           }
                        }
                        bool_56 = TRUE;
                     }
                     continue;
                  }
               }
               if (StringFind(GhostOrderComment(), gs__hedged_1156) != -1 && g_cmd_1152 == GhostOrderType()) {
                  ld_8 = order_takeprofit_0 - MarketInfo(Symbol(), MODE_SPREAD) * Point;
                  ld_16 = order_takeprofit_0 + MarketInfo(Symbol(), MODE_SPREAD) * Point;
                  if (GhostOrderStopLoss() == 0.0 || (GhostOrderType() == OP_BUY && GhostOrderStopLoss() != ld_8) || (GhostOrderType() == OP_SELL && GhostOrderStopLoss() != ld_16)) {
                     if (GhostOrderType() == OP_BUY) {
                        li_52 = Close_Order_Attempts;
                        bool_56 = FALSE;
                        while (bool_56 == FALSE && li_52 >= 0) {
                           li_52--;
                           RefreshRates();
                        //--- 6: Assert replace OrderModify a buy trade with arrays
                           bCommand[bCount]     = 1; 
                           bOpenPrice[bCount]   = 0;
                           bStopLoss[bCount]    = NormalizeDouble(ld_8, Digits);
                           bTakeProfit[bCount]  = NormalizeDouble(GhostOrderTakeProfit(), Digits);
                           bCount ++;
                           if( bCount >= MaxAccountTrades ) break;
                           /*bool_56 = OrderModify(OrderTicket(), 0, NormalizeDouble(ld_8, Digits), NormalizeDouble(OrderTakeProfit(), Digits), 0, White);*/
                           if (!TRUE) {
                              g_error_1248 = GetLastError();
                              if (g_error_1248 == 146/* TRADE_CONTEXT_BUSY */) {
                                 Sleep(50);
                                 continue;
                              }
                           }
                           bool_56 = TRUE;
                        }
                        continue;
                     }
                     if (GhostOrderType() == OP_SELL) {
                        li_52 = Close_Order_Attempts;
                        bool_56 = FALSE;
                        while (bool_56 == FALSE && li_52 >= 0) {
                           li_52--;
                           RefreshRates();
                        //--- 6: Assert replace OrderModify a sell trade with arrays
                           bCommand[bCount]     = 3; 
                           bOpenPrice[bCount]   = 0;
                           bStopLoss[bCount]    = NormalizeDouble(ld_16, Digits);
                           bTakeProfit[bCount]  = NormalizeDouble(GhostOrderTakeProfit(), Digits);
                           bCount ++;
                           if( bCount >= MaxAccountTrades ) break;
                           /*bool_56 = OrderModify(OrderTicket(), 0, NormalizeDouble(ld_16, Digits), NormalizeDouble(OrderTakeProfit(), Digits), 0, White);*/
                           if (!TRUE) {
                              g_error_1248 = GetLastError();
                              if (g_error_1248 == 146/* TRADE_CONTEXT_BUSY */) {
                                 Sleep(50);
                                 continue;
                              }
                           }
                           bool_56 = TRUE;
                        }
                     }
                  }
               }
            }
         }
      }
   //--- Assert 1: Free OrderSelect #18
      GhostFreeSelect(true);
   //--- Assert for: process array of commands
      for(int i=0; i<bCount; i++)
      {
         switch( bCommand[i] )
         {
            case 1:  // OrderModify Buy
               GhostOrderModify( bTicket[i], bOpenPrice[i], bStopLoss[i], bTakeProfit[i], 0, White ); 
               break;
            case 2:  // OrderClose Buy
            case 3:  // OrderModify Sell
               GhostOrderModify( bTicket[i], bOpenPrice[i], bStopLoss[i], bTakeProfit[i], 0, White ); 
               break;
            case 4:  // OrderClose Sell
               break;
         }
      }
   }
//--- Assert 2: Refresh Plus   
   GhostRefresh();
   if (f0_0() != 0) {
      gi_1200 = fun0(gda_1180, gda_1184, Digits, count_24, Point, gda_1196, count_24, IsDemo());
      if (gi_1200 >= 0) {
         g_pips_972 = gda_1196[0];
         gd_1076 = gda_1196[1];
         gd_964 = gda_1196[2];
         if (gi_1200 == 0) gi_1168 = FALSE;
         else gi_1168 = TRUE;
      }
      f0_15(count_24, count_28);
      gi_1200 = fun0(gda_1180, gda_1184, Digits, count_28, Point, gda_1196, count_28, IsDemo());
      if (gi_1200 >= 0) {
         g_pips_972 = gda_1196[0];
         gd_1076 = gda_1196[1];
         gd_964 = gda_1196[2];
         if (gi_1200 == 0) gi_1168 = FALSE;
         else gi_1168 = TRUE;
      }
      f0_14(count_24, count_28);
      gi_1200 = fun0(gda_1180, gda_1184, Digits, 0, Point, gda_1196, 0, IsDemo());
      if (gi_1200 >= 0) {
         g_pips_972 = gda_1196[0];
         gd_1076 = gda_1196[1];
         gd_964 = gda_1196[2];
         if (gi_1200 == 0) gi_1168 = FALSE;
         else gi_1168 = TRUE;
      }
      if ((!FreezeAfterTP) && !gi_956) {
         if (gi_1136) {
            gi_1200 = fun0(gda_1180, gda_1184, Digits, count_24, Point, gda_1196, count_24, IsDemo());
            if (gi_1200 >= 0) {
               g_pips_972 = gda_1196[0];
               gd_1076 = gda_1196[1];
               gd_964 = gda_1196[2];
               if (gi_1200 == 0) gi_1168 = FALSE;
               else gi_1168 = TRUE;
            }
            if (f0_12(1)) gi_1136 = FALSE;
         }
         if (gi_1132) {
            gi_1200 = fun0(gda_1180, gda_1184, Digits, count_28, Point, gda_1196, count_28, IsDemo());
            if (gi_1200 >= 0) {
               g_pips_972 = gda_1196[0];
               gd_1076 = gda_1196[1];
               gd_964 = gda_1196[2];
               if (gi_1200 == 0) gi_1168 = FALSE;
               else gi_1168 = TRUE;
            }
            if (f0_13(1)) gi_1132 = FALSE;
         }
      }
      f0_17();
      return;
   }
   return;
  }
//+------------------------------------------------------------------+
//| Timer function                                                   |
//+------------------------------------------------------------------+
void OnTimer()
  {
//---
   
  }
//+------------------------------------------------------------------+
//| ChartEvent function                                              |
//+------------------------------------------------------------------+
void OnChartEvent(const int id,
                  const long &lparam,
                  const double &dparam,
                  const string &sparam)
  {
//---
   
  }
//+------------------------------------------------------------------+
void f0_16(string as_unused_0) {
   if (gi_1164 >= 0) {
   }
}

void f0_10() {
   gd_948 = 0;
//--- Assert 2: Init OrderSelect #1
   int hist_total_0 = GhostOrdersHistoryTotal();
   GhostInitSelect(true,0,SELECT_BY_POS,MODE_HISTORY);
   for (int pos_4 = 0; pos_4 < hist_total_0; pos_4++) {
      GhostOrderSelect(pos_4, SELECT_BY_POS, MODE_HISTORY);
      if (GhostOrderMagicNumber() == MagicNumber) gd_948 += GhostOrderProfit() + GhostOrderSwap();
   }
//--- Assert 1: Free OrderSelect #1
   GhostFreeSelect(false);
}

int f0_5() {
   double ld_0 = MarketInfo(Symbol(), MODE_MINLOT);
   int count_8 = 0;
   for (count_8 = 0; ld_0 < 1.0; count_8++) ld_0 = 10.0 * ld_0;
   return (count_8);
}

double f0_2(double a_minlot_0) {
   double minlot_8;
   double ld_16 = GhostAccountEquity() - gi_992;
   double ld_24 = gi_996;
   double ld_32 = gi_1000;
   if (gi_996 == 0 || gi_1000 == 0) minlot_8 = a_minlot_0;
   else {
      ld_24 = gi_992 * ld_24 / 100.0;
      Print("tmp=" + ld_16 + ",AccountEquity()=" + GhostAccountEquity() + ",InitEquity=" + gi_992);
      ld_32 /= 100.0;
      if (ld_16 > 0.0) ld_16 = MathPow(ld_32 + 1.0, ld_16 / ld_24);
      else {
         if (ld_16 < 0.0) ld_16 = MathPow(1 - ld_32, MathAbs(ld_16 / ld_24));
         else ld_16 = 1;
      }
      minlot_8 = NormalizeDouble(a_minlot_0 * ld_16, f0_5());
      if (minlot_8 < MarketInfo(Symbol(), MODE_MINLOT)) minlot_8 = MarketInfo(Symbol(), MODE_MINLOT);
   }
   if (minlot_8 < 0.0) Print("ERROR tmp=" + ld_16 + ",a=" + ld_24 + ",b=" + ld_32 + ",AccountEquity()=" + GhostAccountEquity());
   return (minlot_8);
}
//---------------------------------------------------------------------------------------------------------------------------+
int f0_8() {
   bool bool_4;
   double ld_12;
   int li_20;
   bool li_ret_0 = FALSE;
//--- Assert 7: Declare variables
   int      aCommand[];    // 1-OrderModify BUY; 2-OrderClose BUY; 3-OrderModify SELL; 4-OrderClose SELL;
   int      aTicket[];
   double   aOpenPrice[];
   double   aStopLoss[];
   double   aTakeProfit[];
   bool     aOk[];
   int      aCount;
//--- Assert 6: Dynamically resize arrays
   ArrayResize(aCommand,MaxAccountTrades);
   ArrayResize(aTicket,MaxAccountTrades);
   ArrayResize(aOpenPrice,MaxAccountTrades);
   ArrayResize(aStopLoss,MaxAccountTrades);
   ArrayResize(aTakeProfit,MaxAccountTrades);
   ArrayResize(aOk,MaxAccountTrades);
//--- Assert 2: Init OrderSelect #2
   int   total = GhostOrdersTotal();
   GhostInitSelect(false,0,SELECT_BY_POS,MODE_TRADES);
   for (int pos_8 = total - 1; pos_8 >= 0; pos_8--) {
      if (GhostOrderSelect(pos_8, SELECT_BY_POS, MODE_TRADES)) {
      //--- Assert 5: Populate arrays
         aCommand[aCount]     =  0;
         aTicket[aCount]      =  GhostOrderTicket();
         aOpenPrice[aCount]   =  GhostOrderOpenPrice();
         aStopLoss[aCount]    =  GhostOrderStopLoss();
         aTakeProfit[aCount]  =  GhostOrderTakeProfit();
         if (GhostOrderMagicNumber() == MagicNumber && GhostOrderSymbol() == Symbol()) {
            RefreshRates();
            if (GhostOrderType() == OP_BUY) {
               if (GhostOrderStopLoss() == 0.0) {
                  ld_12 = GhostOrderOpenPrice() - gi_984 * Point;
                  li_20 = Close_Order_Attempts;
                  bool_4 = FALSE;
                  while (bool_4 == FALSE && li_20 >= 0) {
                     li_20--;
                     RefreshRates();
                  //--- 5: Assert replace OrderModify a buy trade with arrays
                     aCommand[aCount]     = 1; 
                     aStopLoss[aCount]    = ld_12;
                     aCount ++;
                     if( aCount >= MaxAccountTrades ) break;
                     /*bool_4 = OrderModify(OrderTicket(), NormalizeDouble(OrderOpenPrice(), Digits), NormalizeDouble(ld_12, Digits), OrderTakeProfit(), 0, Black);*/
                     if (!TRUE) {
                        g_error_1248 = GetLastError();
                        if (g_error_1248 == 146/* TRADE_CONTEXT_BUSY */) {
                           Sleep(50);
                           continue;
                        }
                     }
                     bool_4 = TRUE;
                  }
               }
            }
            if (GhostOrderType() == OP_SELL) {
               if (GhostOrderStopLoss() == 0.0) {
                  ld_12 = GhostOrderOpenPrice() + gi_984 * Point;
                  li_20 = Close_Order_Attempts;
                  bool_4 = FALSE;
                  while (bool_4 == FALSE && li_20 >= 0) {
                     li_20--;
                     RefreshRates();
                  //--- 5: Assert replace OrderModify a sell trade with arrays
                     aCommand[aCount]     = 3; 
                     aStopLoss[aCount]    = ld_12;
                     aCount ++;
                     if( aCount >= MaxAccountTrades ) break;
                     /*bool_4 = OrderModify(OrderTicket(), NormalizeDouble(OrderOpenPrice(), Digits), NormalizeDouble(ld_12, Digits), OrderTakeProfit(), 0, Black);*/
                     if (!TRUE) {
                        g_error_1248 = GetLastError();
                        if (g_error_1248 == 146/* TRADE_CONTEXT_BUSY */) {
                           Sleep(50);
                           continue;
                        }
                     }
                     bool_4 = TRUE;
                  }
               }
            }
         }
      }
   }
//--- Assert 1: Free OrderSelect #2
   GhostFreeSelect(false);
//--- Assert for: process array of commands
   for(int i=0; i<aCount; i++)
   {
      switch( aCommand[i] )
      {
         case 1:  // OrderModify Buy
            GhostOrderModify( aTicket[i], NormalizeDouble(aOpenPrice[i],Digits), NormalizeDouble(aStopLoss[i],Digits), aTakeProfit[i], 0, Black );         
            break;
         case 2:  // OrderClose Buy
         case 3:  // OrderModify Sell
            GhostOrderModify( aTicket[i], NormalizeDouble(aOpenPrice[i],Digits), NormalizeDouble(aStopLoss[i],Digits), aTakeProfit[i], 0, Black );         
            break;
         case 4:  // OrderClose Sell
            break;
      }
   }
   return (li_ret_0);
}

double f0_11(int ai_0) {
//--- Assert 4: Init OrderSelect #3
   bool     found;
   double   lots;
   int      total = GhostOrdersTotal();
   GhostInitSelect(false,0,SELECT_BY_POS,MODE_TRADES);
   for (int pos_4 = total - 1; pos_4 >= 0; pos_4--) {
      if (GhostOrderSelect(pos_4, SELECT_BY_POS)) {
         if (GhostOrderMagicNumber() == MagicNumber) {
            if (StringFind(GhostOrderComment(), gs__hedged_1156) == -1) {
               f0_16("GetLastLotSize " + ai_0 + ",OrderLots()=" + GhostOrderLots());
            //--- Assert 3: return value
               found = true;
               lots  = GhostOrderLots();
               break;
               /*return (OrderLots());*/
            }
         }
      }
   }
//--- Assert 2: Free OrderSelect #3
   GhostFreeSelect(false);
   if( found ) return( lots );
   f0_16("GetLastLotSize " + ai_0 + " wasnt found");
   return (0);
}

double f0_3(int ai_0) {
//--- Assert 4: Init OrderSelect #4
   bool     found;
   double   lots;
   int      total = GhostOrdersTotal();
   GhostInitSelect(false,0,SELECT_BY_POS,MODE_TRADES);
   for (int pos_4 = total - 1; pos_4 >= 0; pos_4--) {
      if (GhostOrderSelect(pos_4, SELECT_BY_POS)) {
         if (GhostOrderMagicNumber() == MagicNumber && GhostOrderType() == OP_BUY) {
            if (StringFind(GhostOrderComment(), gs__hedged_1156) == -1) {
               f0_16("GetLastLotSize " + ai_0 + ",OrderLots()=" + GhostOrderLots());
            //--- Assert 3: return value
               found = true;
               lots  = GhostOrderLots();
               break;
               /*return (OrderLots());*/
            }
         }
      }
   }
//--- Assert 2: Free OrderSelect #4
   GhostFreeSelect(false);
   if( found ) return( lots );
   f0_16("GetLastLotSize " + ai_0 + " wasnt found");
   return (0);
}

double f0_6(int ai_0) {
//--- Assert 4: Init OrderSelect #5
   bool     found;
   double   lots;
   int      total = GhostOrdersTotal();
   GhostInitSelect(false,0,SELECT_BY_POS,MODE_TRADES);
   for (int pos_4 = total - 1; pos_4 >= 0; pos_4--) {
      if (GhostOrderSelect(pos_4, SELECT_BY_POS)) {
         if (GhostOrderMagicNumber() == MagicNumber && GhostOrderType() == OP_SELL) {
            if (StringFind(GhostOrderComment(), gs__hedged_1156) == -1) {
               f0_16("GetLastLotSize " + ai_0 + ",OrderLots()=" + GhostOrderLots());
            //--- Assert 3: return value
               found = true;
               lots  = GhostOrderLots();
               break;
               /*return (OrderLots());*/
            }
         }
      }
   }
//--- Assert 2: Free OrderSelect #5
   GhostFreeSelect(false);
   if( found ) return( lots );
   f0_16("GetLastLotSize " + ai_0 + " wasnt found");
   return (0);
}

int f0_12(bool ai_0 = FALSE, double nbp = 0.0) {
   int ticket_4;
   double lots_8;
   int li_48;
   bool bool_52;
   double ld_16 = 0;
   double ld_24 = 0;
   string ls_32 = "";
   bool li_ret_40 = TRUE;
   if (TimeCurrent() - g_datetime_1072 < 60) return (0);
   if (ai_0 && (!gi_1140)) return (0);
   if (!GlobalVariableCheck("PERMISSION")) {
      GlobalVariableSet("PERMISSION", TimeCurrent());
      if (!SupportECN) {
         if (ai_0) {
         //--- Assert 4: Init OrderSelect #6
            GhostInitSelect(true,g_ticket_1148,SELECT_BY_TICKET,MODE_TRADES);
            if (GhostOrderSelect(g_ticket_1148, SELECT_BY_TICKET)) 
            {
               ld_24 = GhostOrderTakeProfit() - MarketInfo(Symbol(), MODE_SPREAD) * Point;
            }
         //--- Assert 2: Free OrderSelect #6
            GhostFreeSelect(false);
         } else ld_16 = Ask + g_pips_972 * Point;
      }
      if (gi_1168 == FALSE) {
         if (ai_0) lots_8 = NormalizeDouble(f0_11(1) * gd_1060, 2);
         else lots_8 = f0_2(gd_1016);
      } else {
         if (f0_3(0) > 0.0) lots_8 = NormalizeDouble(f0_3(0) * gd_964, 2);
         else lots_8 = NormalizeDouble(LOT(), 2);
      }
      
      // No money check
      if (!MarginEnoughCheck(lots_8)) {Sleep(10000); GlobalVariableDel("PERMISSION"); return(false);}// Fix 0.06a No money check      
      
      if (BasketStopLoss > 0) ld_24 = Ask - gi_984 * Point;
      if (!SupportECN) {
         if (ld_16 == 0.0) ld_16 = Ask + BasketTakeProfit * g_point_1204;
         if (ld_24 == 0.0) ld_24 = Ask - BasketStopLoss * g_point_1204;
         if (nbp > 0.0) ld_16 = nbp; // NBP
         if (gi_1212 == TRUE) {
            int index_44 = 0;
            for (index_44 = 0; index_44 < 25; index_44++)
               if (gia_1216[index_44] <= 0) break;
            if (index_44 < 25) {
               ticket_4 = GhostOrderSend(Symbol(), OP_BUY, lots_8, NormalizeDouble(Ask, Digits), Slippage, NormalizeDouble(ld_24, Digits), NormalizeDouble(ld_16, Digits), EA_Name + ls_32,
                  MagicNumber, 0, Green);
               if (ticket_4 > 0) {
                  gia_1216[index_44] = ticket_4;
                  gia_1220[index_44] = 0;
                  gda_1224[index_44] = lots_8;
                  gda_1228[index_44] = NormalizeDouble(Ask, Digits);
                  gda_1232[index_44] = 0;
                  gda_1236[index_44] = 0;
                  GlobalVariableSet(Symbol() + "ticketS4" + index_44, gia_1216[index_44]);
                  GlobalVariableSet(Symbol() + "typeS4" + index_44, gia_1220[index_44]);
                  GlobalVariableSet(Symbol() + "lotsS4" + index_44, gda_1224[index_44]);
                  GlobalVariableSet(Symbol() + "priceS4" + index_44, gda_1228[index_44]);
                  GlobalVariableSet(Symbol() + "stoplossS4" + index_44, gda_1232[index_44]);
                  GlobalVariableSet(Symbol() + "takeprofitS4" + index_44, gda_1236[index_44]);
               }
            }
         } else {
            ticket_4 = GhostOrderSend(Symbol(), OP_BUY, lots_8, NormalizeDouble(Ask, Digits), Slippage, NormalizeDouble(ld_24, Digits), NormalizeDouble(ld_16, Digits), EA_Name + ls_32,
               MagicNumber, 0, Green);
         }
      } else {
         if (gi_1212 == TRUE) {
            int index_44 = 0;
            for (index_44 = 0; index_44 < 25; index_44++)
               if (gia_1216[index_44] <= 0) break;
            if (index_44 < 25) {
               ticket_4 = GhostOrderSend(Symbol(), OP_BUY, lots_8, NormalizeDouble(Ask, Digits), Slippage, 0, 0, EA_Name + ls_32, MagicNumber, 0, Green);
               if (ticket_4 > 0) {
                  gia_1216[index_44] = ticket_4;
                  gia_1220[index_44] = 0;
                  gda_1224[index_44] = lots_8;
                  gda_1228[index_44] = NormalizeDouble(Ask, Digits);
                  gda_1232[index_44] = 0;
                  gda_1236[index_44] = 0;
                  GlobalVariableSet(Symbol() + "ticketS4" + index_44, gia_1216[index_44]);
                  GlobalVariableSet(Symbol() + "typeS4" + index_44, gia_1220[index_44]);
                  GlobalVariableSet(Symbol() + "lotsS4" + index_44, gda_1224[index_44]);
                  GlobalVariableSet(Symbol() + "priceS4" + index_44, gda_1228[index_44]);
                  GlobalVariableSet(Symbol() + "stoplossS4" + index_44, gda_1232[index_44]);
                  GlobalVariableSet(Symbol() + "takeprofitS4" + index_44, gda_1236[index_44]);
               }
               Sleep(1000);
            }
         } else {
            ticket_4 = GhostOrderSend(Symbol(), OP_BUY, lots_8, NormalizeDouble(Ask, Digits), Slippage, 0, 0, EA_Name + ls_32, MagicNumber, 0, Green);
            Sleep(1000);
         }
         if (ticket_4 >= 0) {
         //--- Assert 1: Declare variables
            double   aOpenPrice;
         //--- Assert 2: Init OrderSelect #7
            GhostInitSelect(true,ticket_4,SELECT_BY_TICKET,MODE_TRADES);
            if( GhostOrderSelect(ticket_4, SELECT_BY_TICKET) ) aOpenPrice = GhostOrderOpenPrice();
         //--- Assert 1: Free OrderSelect #7
            GhostFreeSelect(false);
            if (ld_16 == 0.0) ld_16 = Ask + BasketTakeProfit * g_point_1204;
            if (ld_24 == 0.0) ld_24 = Ask - BasketStopLoss * g_point_1204;
            li_48 = Close_Order_Attempts;
            bool_52 = FALSE;
            while (bool_52 == FALSE && li_48 >= 0) {
               li_48--;
               RefreshRates();
               bool_52 = GhostOrderModify(ticket_4, NormalizeDouble(aOpenPrice, Digits), NormalizeDouble(ld_24, Digits), NormalizeDouble(ld_16, Digits), 0, Black);
               if (!bool_52) {
                  g_error_1248 = GetLastError();
                  if (g_error_1248 == 146/* TRADE_CONTEXT_BUSY */) {
                     Sleep(50);
                     continue;
                  }
               }
               bool_52 = TRUE;
            }
         }
      }
      g_datetime_1072 = TimeCurrent();
      if (ticket_4 != -1) {
         if (!ai_0) {
            g_ticket_1148 = ticket_4;
            f0_16("BUY hedgedTicket=" + g_ticket_1148);
         } else {
            f0_16("BUY Leviathan_ticket=" + ticket_4);
            g_cmd_1152 = 0;
         }
      } else {
         f0_16("failed sell");
         li_ret_40 = FALSE;
      }
   }
   GlobalVariableDel("PERMISSION");
   return (li_ret_40);
}

int f0_13(bool ai_0 = FALSE, double nbp = 0.0) {
   int ticket_4;
   double lots_8;
   int li_48;
   bool bool_52;
   double ld_16 = 0;
   double ld_24 = 0;
   string ls_32 = "";
   bool li_ret_40 = TRUE;
   if (TimeCurrent() - g_datetime_1072 < 60) return (0);
   if (ai_0 && (!gi_1144)) return (0);
   if (!GlobalVariableCheck("PERMISSION")) {
      GlobalVariableSet("PERMISSION", TimeCurrent());
      if (!SupportECN) {
         if (ai_0) {
         //--- Assert 4: Init OrderSelect #8
            GhostInitSelect(true,g_ticket_1148,SELECT_BY_TICKET,MODE_TRADES);
            if (GhostOrderSelect(g_ticket_1148, SELECT_BY_TICKET)) 
            {
               ld_24 = GhostOrderTakeProfit() + MarketInfo(Symbol(), MODE_SPREAD) * Point;
            }
         //--- Assert 2: Free OrderSelect #8
            GhostFreeSelect(false);
         } else ld_16 = Bid - g_pips_972 * Point;
      }
      if (gi_1168 == FALSE) {
         if (ai_0) lots_8 = NormalizeDouble(f0_11(0) * gd_1060, 2);
         else lots_8 = f0_2(gd_1016);
      } else {
         if (f0_6(0) > 0.0) lots_8 = NormalizeDouble(f0_6(0) * gd_964, 2);
         else lots_8 = NormalizeDouble(LOT(), 2);
      }
      
      // No money check
      if (!MarginEnoughCheck(lots_8)) {Sleep(10000); GlobalVariableDel("PERMISSION"); return(false);}// Fix 0.06a No money check      
      
      if (BasketStopLoss > 0) ld_24 = Bid + gi_984 * Point;
      if (!SupportECN) {
         if (ld_16 == 0.0) ld_16 = Bid - BasketTakeProfit * g_point_1204;
         if (ld_24 == 0.0) ld_24 = Bid + BasketStopLoss * g_point_1204;
         if (nbp > 0.0) ld_16 = nbp; // NBP
         if (gi_1212 == TRUE) {
            int index_44 = 0;
            for (index_44 = 0; index_44 < 25; index_44++)
               if (gia_1216[index_44] <= 0) break;
            if (index_44 < 25) {
               ticket_4 = GhostOrderSend(Symbol(), OP_SELL, lots_8, NormalizeDouble(Bid, Digits), Slippage, NormalizeDouble(ld_24, Digits), NormalizeDouble(ld_16, Digits), EA_Name + ls_32,
                  MagicNumber, 0, Pink);
               if (ticket_4 > 0) {
                  gia_1216[index_44] = ticket_4;
                  gia_1220[index_44] = 1;
                  gda_1224[index_44] = lots_8;
                  gda_1228[index_44] = NormalizeDouble(Bid, Digits);
                  gda_1232[index_44] = 0;
                  gda_1236[index_44] = 0;
                  GlobalVariableSet(Symbol() + "ticketS4" + index_44, gia_1216[index_44]);
                  GlobalVariableSet(Symbol() + "typeS4" + index_44, gia_1220[index_44]);
                  GlobalVariableSet(Symbol() + "lotsS4" + index_44, gda_1224[index_44]);
                  GlobalVariableSet(Symbol() + "priceS4" + index_44, gda_1228[index_44]);
                  GlobalVariableSet(Symbol() + "stoplossS4" + index_44, gda_1232[index_44]);
                  GlobalVariableSet(Symbol() + "takeprofitS4" + index_44, gda_1236[index_44]);
               }
            }
         } else {
            ticket_4 = GhostOrderSend(Symbol(), OP_SELL, lots_8, NormalizeDouble(Bid, Digits), Slippage, NormalizeDouble(ld_24, Digits), NormalizeDouble(ld_16, Digits), EA_Name + ls_32,
               MagicNumber, 0, Pink);
         }
      } else {
         if (gi_1212 == TRUE) {
            int index_44 = 0;
            for (index_44 = 0; index_44 < 25; index_44++)
               if (gia_1216[index_44] <= 0) break;
            if (index_44 < 25) {
               ticket_4 = GhostOrderSend(Symbol(), OP_SELL, lots_8, NormalizeDouble(Bid, Digits), Slippage, 0, 0, EA_Name + ls_32, MagicNumber, 0, Pink);
               if (ticket_4 > 0) {
                  gia_1216[index_44] = ticket_4;
                  gia_1220[index_44] = 1;
                  gda_1224[index_44] = lots_8;
                  gda_1228[index_44] = NormalizeDouble(Bid, Digits);
                  gda_1232[index_44] = 0;
                  gda_1236[index_44] = 0;
                  GlobalVariableSet(Symbol() + "ticketS4" + index_44, gia_1216[index_44]);
                  GlobalVariableSet(Symbol() + "typeS4" + index_44, gia_1220[index_44]);
                  GlobalVariableSet(Symbol() + "lotsS4" + index_44, gda_1224[index_44]);
                  GlobalVariableSet(Symbol() + "priceS4" + index_44, gda_1228[index_44]);
                  GlobalVariableSet(Symbol() + "stoplossS4" + index_44, gda_1232[index_44]);
                  GlobalVariableSet(Symbol() + "takeprofitS4" + index_44, gda_1236[index_44]);
               }
               Sleep(1000);
            }
         } else {
            ticket_4 = GhostOrderSend(Symbol(), OP_SELL, lots_8, NormalizeDouble(Bid, Digits), Slippage, 0, 0, EA_Name + ls_32, MagicNumber, 0, Pink);
            Sleep(1000);
         }
         if (ticket_4 >= 0) {
         //--- Assert 1: Declare variables
            double   aOpenPrice;
         //--- Assert 2: Init OrderSelect #9
            GhostInitSelect(true,ticket_4,SELECT_BY_TICKET,MODE_TRADES);
            if( GhostOrderSelect(ticket_4, SELECT_BY_TICKET) ) aOpenPrice = GhostOrderOpenPrice();
         //--- Assert 1: Free OrderSelect #9
            GhostFreeSelect(false);
            if (ld_16 == 0.0) ld_16 = Bid - BasketTakeProfit * g_point_1204;
            if (ld_24 == 0.0) ld_24 = Bid + BasketStopLoss * g_point_1204;
            li_48 = Close_Order_Attempts;
            bool_52 = FALSE;
            while (bool_52 == FALSE && li_48 >= 0) {
               li_48--;
               RefreshRates();
               bool_52 = GhostOrderModify(ticket_4, NormalizeDouble(aOpenPrice, Digits), NormalizeDouble(ld_24, Digits), NormalizeDouble(ld_16, Digits), 0, Black);
               if (!bool_52) {
                  g_error_1248 = GetLastError();
                  if (g_error_1248 == 146/* TRADE_CONTEXT_BUSY */) {
                     Sleep(50);
                     continue;
                  }
               }
               bool_52 = TRUE;
            }
         }
      }
      g_datetime_1072 = TimeCurrent();
      if (ticket_4 != -1) {
         if (!ai_0) {
            g_ticket_1148 = ticket_4;
            f0_16("SELL hedgedTicket=" + g_ticket_1148);
         } else {
            f0_16("SELL Leviathan_ticket=" + ticket_4);
            g_cmd_1152 = 1;
         }
      } else {
         f0_16("failed sell");
         li_ret_40 = FALSE;
      }
   }
   GlobalVariableDel("PERMISSION");
   return (li_ret_40);
}

void f0_15(int ai_0, int ai_unused_4) {
   int li_64;
   bool bool_68;
   int datetime_8 = 0;
   double order_open_price_12 = 0;
   double order_lots_20 = 0;
   double order_takeprofit_28 = 0;
   double order_stoploss_36 = 0;
   int cmd_44 = -1;
   int ticket_48 = 0;
   int pos_52 = 0;
   int count_56 = 0;
//--- Assert 2: Init OrderSelect #10
   int   total = GhostOrdersTotal();
   GhostInitSelect(true,0,SELECT_BY_POS,MODE_TRADES);
   for (pos_52 = 0; pos_52 < total; pos_52++) {
      if (GhostOrderSelect(pos_52, SELECT_BY_POS, MODE_TRADES)) {
         if (GhostOrderMagicNumber() == MagicNumber && (UseSignalsNBP || GhostOrderType() == OP_BUY)) {
            count_56++;
            if (GhostOrderOpenTime() > datetime_8) {
               datetime_8 = GhostOrderOpenTime();
               order_open_price_12 = GhostOrderOpenPrice();
               cmd_44 = GhostOrderType();
               ticket_48 = GhostOrderTicket();
               order_takeprofit_28 = GhostOrderTakeProfit();
               order_stoploss_36 = GhostOrderStopLoss();
            }
            if (GhostOrderLots() > order_lots_20) order_lots_20 = GhostOrderLots();
         }
      }
   }
//--- Assert 1: Free OrderSelect #10
   GhostFreeSelect(false);
   int li_60 = MathRound(MathLog(order_lots_20 / LOT()) / MathLog(gd_964)) + 1.0;
   if (li_60 < 0) li_60 = 0;
   gd_1016 = NormalizeDouble(LOT() * MathPow(gd_964, li_60), gi_1084);
   int signal = signal();
   if (li_60 == 0 && signal == 1) {
      if (FreezeAfterTP == FALSE && gi_956 == FALSE) f0_12();
      else
         if (ai_0 > 0) f0_12();
   } else {
      if (signal == 1 && (!UseSignalsNBP || ( !GlobalVariableCheck("LAST_BUY_H_TICKET") || ticket_48 > GlobalVariableGet("LAST_BUY_H_TICKET") )) && order_open_price_12 - Ask > ExecutionPoint * gd_1076 && order_open_price_12 > 0.0 && count_56 < MaximumBuyLevels) {

          if (!GlobalVariableCheck("LAST_BUY_H_TICKET") || (ticket_48 >= 0 && ticket_48 > GlobalVariableGet("LAST_BUY_H_TICKET"))) GlobalVariableSet("LAST_BUY_H_TICKET", ticket_48);

          if (Negative_Basket_Protection == TRUE) {
            double std_TP, nbp_TP, tmp_TP;
            std_TP = Ask + BasketTakeProfit * g_point_1204;
            nbp_TP = order_open_price_12 + NBP * g_point_1204;
            if (!UseSignalsNBP || signal != -1) {
               std_TP = Ask + BasketTakeProfit * g_point_1204;
               nbp_TP = order_open_price_12 + NBP * g_point_1204;
            } else if (UseSignalsNBP && signal == -1) {
               std_TP = Bid - BasketTakeProfit * gPoint;
               nbp_TP = order_open_price_12 - NBP * gPoint;
            }
            if (std_TP < nbp_TP) {
               tmp_TP = BuyMaxTP();
               if (!UseSignalsNBP || signal != -1) tmp_TP = BuyMaxTP();
               else if (UseSignalsNBP && signal == -1) tmp_TP = SellMinTP();
               if (tmp_TP == 0.0) {
                  if(UseSignalsNBP && signal == -1)       {f0_13(0, std_TP); return;}
                  else if(!UseSignalsNBP || signal != -1) {f0_12(0, std_TP); return;}//Open BUY
               }
               tmp_TP = nbp_TP;
               if(UseSignalsNBP && signal == -1)       {f0_13(0, tmp_TP); return;}
               else if(!UseSignalsNBP || signal != -1) {f0_12(0, tmp_TP); return;}
            }
            if(UseSignalsNBP && signal == -1)       {f0_13(0, std_TP); return;}
            else if(!UseSignalsNBP || signal != -1) {f0_12(0, std_TP); return;}
         } // IF NBP TRUE   
 
         if (!(f0_12())) return;
         return;} // if (ord_op_price - Ask > Execut...
      //}
   }
//--- Assert 7: Declare variables
   int      aCommand[];    // 1-OrderModify BUY; 2-OrderClose BUY; 3-OrderModify SELL; 4-OrderClose SELL;
   int      aTicket[];
   double   aOpenPrice[];
   double   aStopLoss[];
   double   aTakeProfit[];
   bool     aOk[];
   int      aCount;
//--- Assert 6: Dynamically resize arrays
   ArrayResize(aCommand,MaxAccountTrades);
   ArrayResize(aTicket,MaxAccountTrades);
   ArrayResize(aOpenPrice,MaxAccountTrades);
   ArrayResize(aStopLoss,MaxAccountTrades);
   ArrayResize(aTakeProfit,MaxAccountTrades);
   ArrayResize(aOk,MaxAccountTrades);
//--- Assert 2: Init OrderSelect #11
   total = GhostOrdersTotal();
   GhostInitSelect(true,0,SELECT_BY_POS,MODE_TRADES);
   for (pos_52 = 0; pos_52 < total; pos_52++) {
      if( GhostOrderSelect(pos_52, SELECT_BY_POS, MODE_TRADES) )
      {
      //--- Assert 5: Populate arrays
         aCommand[aCount]     =  0;
         aTicket[aCount]      =  GhostOrderTicket();
         aOpenPrice[aCount]   =  GhostOrderOpenPrice();
         aStopLoss[aCount]    =  GhostOrderStopLoss();
         aTakeProfit[aCount]  =  GhostOrderTakeProfit();
         if (GhostOrderMagicNumber() != MagicNumber || GhostOrderType() != cmd_44 || GhostOrderStopLoss() == order_stoploss_36 || order_stoploss_36 == 0.0 || GhostOrderTakeProfit() == order_takeprofit_28 ||
            order_takeprofit_28 == 0.0) continue;
         li_64 = Close_Order_Attempts;
         bool_68 = FALSE;
         while (bool_68 == FALSE && li_64 >= 0) {
            li_64--;
            RefreshRates();
         //--- 6: Assert replace OrderModify a buy trade with arrays
            aCommand[aCount]     = 1; 
            aOpenPrice[aCount]   = NormalizeDouble(GhostOrderOpenPrice(), Digits);
            aStopLoss[aCount]    = NormalizeDouble(order_stoploss_36, Digits);
            aTakeProfit[aCount]  = NormalizeDouble(order_takeprofit_28, Digits);
            aCount ++;
            if( aCount >= MaxAccountTrades ) break;
            /*bool_68 = OrderModify(OrderTicket(), NormalizeDouble(OrderOpenPrice(), Digits), NormalizeDouble(order_stoploss_36, Digits), NormalizeDouble(order_takeprofit_28, Digits),
               0, Pink);*/
            if (!TRUE) {
               g_error_1248 = GetLastError();
               if (g_error_1248 == 146/* TRADE_CONTEXT_BUSY */) {
                  Sleep(50);
                  continue;
               }
            }
            bool_68 = TRUE;
         }
         Sleep(1000);
      }
   }
//--- Assert 1: Free OrderSelect #11
   GhostFreeSelect(false);
//--- Assert for: process array of commands
   for(int i=0; i<aCount; i++)
   {
      switch( aCommand[i] )
      {
         case 1:  // OrderModify Buy
            GhostOrderModify( aTicket[i], aOpenPrice[i], aStopLoss[i], aTakeProfit[i], 0, Pink ); 
            break;
         case 2:  // OrderClose Buy
         case 3:  // OrderModify Sell
         case 4:  // OrderClose Sell
            break;
      }
   }
}


int signal() {
//----
   HideTestIndicators(TRUE);
//----
   int buy = 1, sell = -1;
//----
   int macdSignal = 0;
   int macdDatetime = iTime(Symbol(), SignalPeriod, 0);
   int macdShift = iBarShift(Symbol(), SignalPeriod, macdDatetime - 60 * SignalPeriod, FALSE);
   
   if (iMACD(Symbol(), SignalPeriod, 12, 26, 9, PRICE_CLOSE, MODE_MAIN, macdShift) > iMACD(Symbol(), SignalPeriod, 12, 26, 9, PRICE_CLOSE, MODE_SIGNAL, macdShift)) macdSignal = buy;
   else macdSignal = sell;
//----
   double sma0_50  = iMA(Symbol(),SignalPeriod,50,0,MODE_EMA,PRICE_MEDIAN,0);
   double sma0_200 = iMA(Symbol(),SignalPeriod,200,0,MODE_EMA,PRICE_MEDIAN,0);
   double sma1_50  = iMA(Symbol(),SignalPeriod,50,0,MODE_EMA,PRICE_MEDIAN,1);
   double sma1_200 = iMA(Symbol(),SignalPeriod,200,0,MODE_EMA,PRICE_MEDIAN,1);
//----
   //0 - MODE_MAIN, 1 - MODE_PLUSDI, 2 - MODE_MINUSDI
   double adx0_14 = iADX(Symbol(),0,14,PRICE_HIGH,MODE_MAIN,0);
   double adx1_14 = iADX(Symbol(),0,14,PRICE_HIGH,MODE_MAIN,1);
   
   // 0 - MODE_MAIN, 1 - MODE_UPPER, 2 - MODE_LOWER
   double bb0L_20 = iBands(Symbol(),0,20,2,0,PRICE_CLOSE,MODE_LOWER,0);
   double bb1L_20 = iBands(Symbol(),0,20,2,0,PRICE_CLOSE,MODE_LOWER,1);
   double bb2L_20 = iBands(Symbol(),0,20,2,0,PRICE_CLOSE,MODE_LOWER,2);
   double bb3L_20 = iBands(Symbol(),0,20,2,0,PRICE_CLOSE,MODE_LOWER,3);

   double bb0M_20 = iBands(Symbol(),0,20,2,0,PRICE_CLOSE,MODE_MAIN,0);
   double bb1M_20 = iBands(Symbol(),0,20,2,0,PRICE_CLOSE,MODE_MAIN,1);
   double bb2M_20 = iBands(Symbol(),0,20,2,0,PRICE_CLOSE,MODE_MAIN,2);
   double bb3M_20 = iBands(Symbol(),0,20,2,0,PRICE_CLOSE,MODE_MAIN,3);

   double bb0U_20 = iBands(Symbol(),0,20,2,0,PRICE_CLOSE,MODE_UPPER,0);
   double bb1U_20 = iBands(Symbol(),0,20,2,0,PRICE_CLOSE,MODE_UPPER,1);
   double bb2U_20 = iBands(Symbol(),0,20,2,0,PRICE_CLOSE,MODE_UPPER,2);
   double bb3U_20 = iBands(Symbol(),0,20,2,0,PRICE_CLOSE,MODE_UPPER,3);

   double isar_0 = iSAR(Symbol(), SignalPeriod, gd_1044, gd_1052, 0);
   double ima_8 = iMA(Symbol(), SignalPeriod, g_period_1028, gi_1032, g_ma_method_1036, g_applied_price_1040, 0);
//----

   //+------------------------------------------------------------------+
   //| Variable Begin                                                   |
   //+------------------------------------------------------------------+
   double Buy1_1 =    iMA(Symbol(), PERIOD_H4, 50, 0, MODE_EMA, PRICE_CLOSE, 0);
   double Buy1_2 =  iMACD(Symbol(), PERIOD_H4, 8, 17, 9, PRICE_CLOSE, MODE_MAIN, 0);
   double Buy2_1 =   iRSI(Symbol(), PERIOD_H4, 15, PRICE_CLOSE, 0);
   double Buy2_2 =  iOpen(Symbol(), 0, 1);
   double Buy2_3 =  iOpen(Symbol(), 0, 0);
   double Buy3_1 = iClose(Symbol(), 0, 1);
   double Buy3_2 = MarketInfo(Symbol(), MODE_BID);
               
   double nearest_broken_pivot = EMPTY_VALUE;
   
   if (Buy2_2 < nearest_resistance && Buy3_1 > nearest_resistance && Buy2_3 > nearest_resistance) {
      nearest_broken_pivot = nearest_resistance;
   } else if (nearest_broken_pivot == EMPTY_VALUE && Buy2_2 < nearest_daily_resistance && Buy3_1 > nearest_daily_resistance && Buy2_3 > nearest_daily_resistance) {
      nearest_broken_pivot = nearest_resistance;
   }
   
   if( (sma0_200 < sma0_50 && sma1_200 < sma1_50 /*&& macdSignal == 2*/) || (Buy3_2 > Buy1_1 && Buy1_2 > 0 && Buy2_1 > 50 && nearest_broken_pivot != EMPTY_VALUE && Buy3_2 > nearest_broken_pivot) )
      return(buy); //SIGNAL BUY

   //----
   if
   (
      (
         iLow(Symbol(),PERIOD_H1,1)>iMA(Symbol(),PERIOD_H1,75,0,MODE_EMA,PRICE_MEDIAN,1) && 
         iMA(Symbol(),PERIOD_H1,75,0,MODE_EMA,PRICE_MEDIAN,0)>iMA(Symbol(),PERIOD_H1,200,0,MODE_EMA,PRICE_MEDIAN,0) && 
         iMA(Symbol(),PERIOD_H1,200,0,MODE_EMA,PRICE_MEDIAN,0)>iMA(Symbol(),PERIOD_H1,600,0,MODE_EMA,PRICE_MEDIAN,0) &&
         iMA(Symbol(),PERIOD_H1,600,0,MODE_EMA,PRICE_MEDIAN,0)>iMA(Symbol(),PERIOD_H1,600,0,MODE_EMA,PRICE_MEDIAN,1)&&iMA(Symbol(),PERIOD_H1,600,0,MODE_EMA,PRICE_MEDIAN,1)>iMA(Symbol(),PERIOD_H1,600,0,MODE_EMA,PRICE_MEDIAN,2) &&
         iMA(Symbol(),PERIOD_H1,200,0,MODE_EMA,PRICE_MEDIAN,0)>iMA(Symbol(),PERIOD_H1,200,0,MODE_EMA,PRICE_MEDIAN,1)&&iMA(Symbol(),PERIOD_H1,200,0,MODE_EMA,PRICE_MEDIAN,1)>iMA(Symbol(),PERIOD_H1,200,0,MODE_EMA,PRICE_MEDIAN,2) &&
         iMA(Symbol(),PERIOD_H1,75,0,MODE_EMA,PRICE_MEDIAN,0)>iMA(Symbol(),PERIOD_H1,75,0,MODE_EMA,PRICE_MEDIAN,1)&&iMA(Symbol(),PERIOD_H1,75,0,MODE_EMA,PRICE_MEDIAN,1)>iMA(Symbol(),PERIOD_H1,75,0,MODE_EMA,PRICE_MEDIAN,2) &&
         iMA(Symbol(),PERIOD_H1,14,0,MODE_EMA,PRICE_MEDIAN,0)>iMA(Symbol(),PERIOD_H1,75,0,MODE_EMA,PRICE_MEDIAN,0)
      )
   ) return(buy); //SIGNAL BUY
   //----
//------------------------------------------------------------------------------------------------------------------------+

   //+------------------------------------------------------------------+
   //| Variable Begin                                                   |
   //+------------------------------------------------------------------+
   double Sell1_1 =    iMA(Symbol(), PERIOD_H4, 50, 0, MODE_EMA, PRICE_CLOSE, 0);
   double Sell1_2 =  iMACD(Symbol(), PERIOD_H4, 8, 17, 9, PRICE_CLOSE, MODE_MAIN, 0);
   double Sell2_1 =   iRSI(Symbol(), PERIOD_H4, 15, PRICE_CLOSE, 0);
   double Sell2_2 =  iOpen(Symbol(), 0, 1);
   double Sell2_3 =  iOpen(Symbol(), 0, 0);
   double Sell3_1 = iClose(Symbol(), 0, 1);
   double Sell3_2 = MarketInfo(Symbol(), MODE_ASK);
   
   nearest_broken_pivot = EMPTY_VALUE;
   
   if (Sell2_2 > nearest_support && Sell3_1 < nearest_support && Sell2_3 < nearest_support) {
      nearest_broken_pivot = nearest_support;
   } else if (nearest_broken_pivot == EMPTY_VALUE && Sell2_2 > nearest_daily_support && Sell3_1 < nearest_daily_support && Sell2_3 < nearest_daily_support) {
      nearest_broken_pivot = nearest_resistance;
   }
   
   if( (sma0_200 > sma0_50 && sma1_200 > sma1_50 /*&& macdSignal == 1*/) || (Sell3_2 < Sell1_1 && Sell1_2 < 0 && Sell2_1 < 50 && nearest_broken_pivot != EMPTY_VALUE && Sell3_2 < nearest_broken_pivot) )
      return(sell); //SIGNAL SELL

   //----
   if
   (
      (
         iHigh(Symbol(),PERIOD_H1,1)<iMA(Symbol(),PERIOD_H1,75,0,MODE_EMA,PRICE_MEDIAN,1) && 
         iMA(Symbol(),PERIOD_H1,75,0,MODE_EMA,PRICE_MEDIAN,0)<iMA(Symbol(),PERIOD_H1,200,0,MODE_EMA,PRICE_MEDIAN,0) && 
         iMA(Symbol(),PERIOD_H1,200,0,MODE_EMA,PRICE_MEDIAN,0)<iMA(Symbol(),PERIOD_H1,600,0,MODE_EMA,PRICE_MEDIAN,0) &&
         iMA(Symbol(),PERIOD_H1,600,0,MODE_EMA,PRICE_MEDIAN,0)<iMA(Symbol(),PERIOD_H1,600,0,MODE_EMA,PRICE_MEDIAN,1)&&iMA(Symbol(),PERIOD_H1,600,0,MODE_EMA,PRICE_MEDIAN,1)<iMA(Symbol(),PERIOD_H1,600,0,MODE_EMA,PRICE_MEDIAN,2) &&
         iMA(Symbol(),PERIOD_H1,200,0,MODE_EMA,PRICE_MEDIAN,0)<iMA(Symbol(),PERIOD_H1,200,0,MODE_EMA,PRICE_MEDIAN,1)&&iMA(Symbol(),PERIOD_H1,200,0,MODE_EMA,PRICE_MEDIAN,1)<iMA(Symbol(),PERIOD_H1,200,0,MODE_EMA,PRICE_MEDIAN,2) &&
         iMA(Symbol(),PERIOD_H1,75,0,MODE_EMA,PRICE_MEDIAN,0)<iMA(Symbol(),PERIOD_H1,75,0,MODE_EMA,PRICE_MEDIAN,1)&&iMA(Symbol(),PERIOD_H1,75,0,MODE_EMA,PRICE_MEDIAN,1)<iMA(Symbol(),PERIOD_H1,75,0,MODE_EMA,PRICE_MEDIAN,2) &&
         iMA(Symbol(),PERIOD_H1,14,0,MODE_EMA,PRICE_MEDIAN,0)<iMA(Symbol(),PERIOD_H1,75,0,MODE_EMA,PRICE_MEDIAN,0)
      )
   )
      return(sell); //SIGNAL SELL
   //----
   //+------------------------------------------------------------------+
   //| Taichi Demarker Signal                                           |
   //+------------------------------------------------------------------+
/*
   int TimeFrame1=SignalPeriod;
   int TF1Tenkan=9;
   int TF1Kijun=26;
   int TF1Senkou=52;
   int TF1FlatSE=7;
   int TF1DeMarker=25;
   int TF1FastMA=14;
   int TF1SlowMA=25;

   int TimeFrame2=30;
   int TF2Tenkan=9;
   int TF2Kijun=26;
   int TF2Senkou=52;
   int TF2FlatSE=7;
   int TF2DeMarker=25;
   int TF2FastMA=14;
   int TF2SlowMA=25;

   int TimeFrame3=15;
   double MinATRRange=5;
   int ATRPeriod=14;

   double MaxPriceRange=40;
   int OpenShift=10;
   
   double point;
   if(Digits<4)
   {
      point=0.01;
   }
   else
   {
      point=0.0001;
   }
   
   int limit=1;
   for(int i=1;i<=limit;i++)
   {
      double CTS=iCustom(Symbol(),TimeFrame1,"Cronex Taichi",TF1Tenkan,TF1Kijun,TF1Senkou,TF1FlatSE,0,i);
      double CTR=iCustom(Symbol(),TimeFrame1,"Cronex Taichi",TF1Tenkan,TF1Kijun,TF1Senkou,TF1FlatSE,1,i);
      double CTL=iCustom(Symbol(),TimeFrame1,"Cronex Taichi",TF1Tenkan,TF1Kijun,TF1Senkou,TF1FlatSE,2,i);
      double CTD=iCustom(Symbol(),TimeFrame1,"Cronex Taichi",TF1Tenkan,TF1Kijun,TF1Senkou,TF1FlatSE,3,i);
      
      double CDS=iCustom(Symbol(),TimeFrame1,"Cronex DeMarker",TF1DeMarker,TF1FastMA,TF1SlowMA,0,i);
      double CDR=iCustom(Symbol(),TimeFrame1,"Cronex DeMarker",TF1DeMarker,TF1FastMA,TF1SlowMA,1,i);
      double CDB=iCustom(Symbol(),TimeFrame1,"Cronex DeMarker",TF1DeMarker,TF1FastMA,TF1SlowMA,2,i);
      
      double CTS5=iCustom(Symbol(),TimeFrame2,"Cronex Taichi",TF2Tenkan,TF2Kijun,TF2Senkou,TF2FlatSE,0,i);
      double CTR5=iCustom(Symbol(),TimeFrame2,"Cronex Taichi",TF2Tenkan,TF2Kijun,TF2Senkou,TF2FlatSE,1,i);
      double CTL5=iCustom(Symbol(),TimeFrame2,"Cronex Taichi",TF2Tenkan,TF2Kijun,TF2Senkou,TF2FlatSE,2,i);
      double CTD5=iCustom(Symbol(),TimeFrame2,"Cronex Taichi",TF2Tenkan,TF2Kijun,TF2Senkou,TF2FlatSE,3,i);
      
      double CDS5=iCustom(Symbol(),TimeFrame2,"Cronex DeMarker",TF2DeMarker,TF2FastMA,TF2SlowMA,0,i);
      double CDR5=iCustom(Symbol(),TimeFrame2,"Cronex DeMarker",TF2DeMarker,TF2FastMA,TF2SlowMA,1,i);
      double CDB5=iCustom(Symbol(),TimeFrame2,"Cronex DeMarker",TF2DeMarker,TF2FastMA,TF2SlowMA,2,i);
      
      double ATR=iATR(NULL,TimeFrame3,ATRPeriod,i);

      if(
         CTS>CTR&&CTS>CTD&&CDS>CDB&&CDB>CDR
         &&CTS5>CTR5&&CTS5>CTD5&&CDS5>CDB5&&CDB5>CDR5
         &&(iClose(Symbol(),TimeFrame1,i)-iClose(Symbol(),TimeFrame1,i+OpenShift))<(MaxPriceRange*point)
         &&ATR>MinATRRange*point
      ) return(buy);

      if(
         CTS<CTL&&CTS<CTD&&CDS<CDB&&CDB<CDR
         &&CTS5<CTL5&&CTS5<CTD5&&CDS5<CDB5&&CDB5<CDR5
         &&(iClose(Symbol(),TimeFrame1,i+OpenShift)-iClose(Symbol(),TimeFrame1,i))<(MaxPriceRange*point)
         &&ATR>MinATRRange*point
      ) return(sell);
   }
*/

/*
  if (!Use_SWB_indicator) {

      if (isar_0 > ima_8) return (-1);
      if (isar_0 < ima_8) return (1);

      return (0);}
*/
      
  ////////////// 0.2b Signal from SWB Grid 4.1.0.7 //////////////////////
/*
  if (swb_is_reversed) {buy = -1; sell = 1;}  
*/
/*
  double upBB=iBands(Symbol(),0,bb_period,bb_deviation,0,PRICE_CLOSE,MODE_UPPER,bb_shift);
  double loBB=iBands(Symbol(),0,bb_period,bb_deviation,0,PRICE_CLOSE,MODE_LOWER,bb_shift);
  double stoch=iStochastic(Symbol(),0,k,d,slowing,MODE_SMA,price_field,MODE_SIGNAL,stoch_shift);
  double rsi=iRSI(Symbol(),0,rsi_period,PRICE_CLOSE,rsi_shift);
  if(use_bb && use_stoch && use_rsi)
  {
     if(sma0_200 > sma0_50 && sma1_200 > sma1_50 && High[bb_shift]>upBB && stoch>up_level && rsi>upper) return(sell);
     if(sma0_200 < sma0_50 && sma1_200 < sma1_50 && Low[bb_shift]<loBB && stoch<lo_level && rsi<lower)   return(buy);
  }
  if(use_bb && use_stoch && !use_rsi)
  {
     if(sma0_200 > sma0_50 && sma1_200 > sma1_50 && High[bb_shift]>upBB && stoch>up_level) return(sell);
     if(sma0_200 < sma0_50 && sma1_200 < sma1_50 && Low[bb_shift]<loBB && stoch<lo_level)   return(buy);
  }
  if(use_bb && !use_stoch && !use_rsi)
  {
     if(sma0_200 > sma0_50 && sma1_200 > sma1_50 && High[bb_shift]>upBB) return(sell);
     if(sma0_200 < sma0_50 && sma1_200 < sma1_50 && Low[bb_shift]<loBB)   return(buy);
  }
  if(!use_bb && use_stoch && use_rsi)
  {
     if(sma0_200 > sma0_50 && sma1_200 > sma1_50 && stoch>up_level && rsi>upper) return(sell);
     if(sma0_200 < sma0_50 && sma1_200 < sma1_50 && stoch<lo_level && rsi<lower)   return(buy);
  }
  if(!use_bb && use_stoch && !use_rsi)
  {
     if(sma0_200 > sma0_50 && sma1_200 > sma1_50 && stoch>up_level) return(sell);
     if(sma0_200 < sma0_50 && sma1_200 < sma1_50 && stoch<lo_level)  return(buy);
  }
  if(use_bb && !use_stoch && use_rsi)
  {
     if(sma0_200 > sma0_50 && sma1_200 > sma1_50 && High[bb_shift]>upBB && rsi>upper) return(sell);
     if(sma0_200 < sma0_50 && sma1_200 < sma1_50 && Low[bb_shift]<loBB && rsi<lower)   return(buy);
  }
  if(!use_bb && !use_stoch && use_rsi)
  {
     if(sma0_200 > sma0_50 && sma1_200 > sma1_50 && rsi>upper) return(sell);
     if(sma0_200 < sma0_50 && sma1_200 < sma1_50 && rsi<lower)  return(buy);
  }
*/
//----
   HideTestIndicators(TRUE);
//----   
  return(0);
}        
         

// Added 2 functions for NBP: SellMinTP, BuyMaxTP

double SellMinTP() {
   double ld_ret_0 = 0;
   for (int l_pos_8 = OrdersTotal() - 1; l_pos_8 >= 0; l_pos_8--) {
      OrderSelect(l_pos_8, SELECT_BY_POS, MODE_TRADES);
      if (OrderMagicNumber() == MagicNumber) {
         if (OrderSymbol() == Symbol()) {
            if (OrderType() == OP_SELL) {
               if (OrderLots() != LOT()) {
                  if (ld_ret_0 == 0.0) ld_ret_0 = OrderOpenPrice() - NBP * g_point_1204;
                  else
                     if (ld_ret_0 > OrderOpenPrice() - NBP * g_point_1204) ld_ret_0 = OrderOpenPrice() - NBP * g_point_1204;
               }
            }
         }
      }
   }
   return (ld_ret_0);
}

double BuyMaxTP() {
   double ld_ret_0 = 0;
   for (int l_pos_8 = OrdersTotal() - 1; l_pos_8 >= 0; l_pos_8--) {
      OrderSelect(l_pos_8, SELECT_BY_POS, MODE_TRADES);
      if (OrderMagicNumber() == MagicNumber) {
         if (OrderSymbol() == Symbol()) {
            if (OrderType() == OP_BUY) {
               if (OrderLots() != LOT()) {
                  if (ld_ret_0 == 0.0) ld_ret_0 = OrderOpenPrice() + NBP * g_point_1204;
                  else
                     if (ld_ret_0 < OrderOpenPrice() + NBP * g_point_1204) ld_ret_0 = OrderOpenPrice() + NBP * g_point_1204;
               }
            }
         }
      }
   }
   return (ld_ret_0);
} 

bool MarginEnoughCheck(double lot) { // No money check ))
         if (AccountFreeMargin() < 1 ) return(false); // Low margin
         if (AccountFreeMargin() < lot * MarketInfo(Symbol(), MODE_MARGINREQUIRED)) return(false); //No margin to op order
   return(true);
}

void updateMagicNumber() {
   int li_0;
   string ls_12;
   int lia_20[256];
   for (int li_4 = 0; li_4 < 256; li_4++) {
      li_0 = li_4;
      for (int l_count_8 = 0; l_count_8 < 8; l_count_8++) {
         if (li_0 & 1 > 0) li_0 = li_0 >> 1 ^ (-306674912);
         else li_0 >>= 1;
      }
      lia_20[li_4] = li_0;
   }
   if (MagicNumber == 0) {
      ls_12 = Symbol() + 0;
      li_0 = -1;
      for (int li_4 = StringLen(ls_12) - 1; li_4 >= 0; li_4--) li_0 = li_0 >> 8 ^ lia_20[li_0 ^ StringGetChar(ls_12, li_4) & 255];
      MagicNumber = li_0 ^ (-1) & EMPTY_VALUE;
   }
   Print("Using magic number: " + MagicNumber);
}

void f0_14(int ai_unused_0, int ai_4) {
   int li_64;
   bool bool_68;
   int datetime_8 = 0;
   double order_open_price_12 = 0;
   double order_lots_20 = 0;
   double order_takeprofit_28 = 0;
   double order_stoploss_36 = 0;
   int cmd_44 = -1;
   int ticket_48 = 0;
   int pos_52 = 0;
   int count_56 = 0;
//--- Assert 2: Init OrderSelect #12
   int   total = GhostOrdersTotal();
   GhostInitSelect(true,0,SELECT_BY_POS,MODE_TRADES);
   for (pos_52 = 0; pos_52 < total; pos_52++) {
      if (GhostOrderSelect(pos_52, SELECT_BY_POS, MODE_TRADES)) {
         if (GhostOrderMagicNumber() == MagicNumber && (UseSignalsNBP || GhostOrderType() == OP_SELL)) {
            count_56++;
            if (GhostOrderOpenTime() > datetime_8) {
               datetime_8 = GhostOrderOpenTime();
               order_open_price_12 = GhostOrderOpenPrice();
               cmd_44 = GhostOrderType();
               ticket_48 = GhostOrderTicket();
               order_takeprofit_28 = GhostOrderTakeProfit();
               order_stoploss_36 = GhostOrderStopLoss();
            }
            if (GhostOrderLots() > order_lots_20) order_lots_20 = GhostOrderLots();
         }
      }
   }
//--- Assert 1: Free OrderSelect #12
   GhostFreeSelect(false);
   int li_60 = MathRound(MathLog(order_lots_20 / LOT()) / MathLog(gd_964)) + 1.0;
   if (li_60 < 0) li_60 = 0;
   gd_1016 = NormalizeDouble(LOT() * MathPow(gd_964, li_60), gi_1084);
   int signal = signal();
   if (li_60 == 0 && signal == -1) {
      if (FreezeAfterTP == FALSE && gi_956 == FALSE) f0_13();
      else
         if (ai_4 > 0) f0_13();
   } else {
      if (signal == -1 && (!UseSignalsNBP || ( !GlobalVariableCheck("LAST_SELL_H_TICKET") || ticket_48 > GlobalVariableGet("LAST_SELL_H_TICKET") )) && Bid - order_open_price_12 > ExecutionPoint * gd_1076 && order_open_price_12 > 0.0 && count_56 < MaximumSellLevels) {

         if (!GlobalVariableCheck("LAST_SELL_H_TICKET") || (ticket_48 >= 0 && ticket_48 > GlobalVariableGet("LAST_SELL_H_TICKET"))) GlobalVariableSet("LAST_SELL_H_TICKET", ticket_48);
         
         if (Negative_Basket_Protection == TRUE) {
            double std_TP, nbp_TP, tmp_TP;
            std_TP = Bid - BasketTakeProfit * gPoint;
            nbp_TP = order_open_price_12 - NBP * gPoint;
            if (!UseSignalsNBP || signal != 1) {
               std_TP = Bid - BasketTakeProfit * gPoint;
               nbp_TP = order_open_price_12 - NBP * gPoint;
            } else if (UseSignalsNBP && signal == 1) {
               std_TP = Ask + BasketTakeProfit * g_point_1204;
               nbp_TP = order_open_price_12 + NBP * g_point_1204;
            }
            if (std_TP > nbp_TP) {
               tmp_TP = SellMinTP();
               if (!UseSignalsNBP || signal != 1) tmp_TP = SellMinTP();
               else if (UseSignalsNBP && signal == 1) tmp_TP = BuyMaxTP();
               if (tmp_TP == 0.0) {
                  if(UseSignalsNBP && signal != 1)         {f0_12(0, std_TP); return;}
                  else if (!UseSignalsNBP || signal == -1) {f0_13(0, std_TP); return;} // Open SELL
               }
               tmp_TP = nbp_TP;
               if(UseSignalsNBP && signal != 1)         {f0_12(0, tmp_TP); return;}
               else if (!UseSignalsNBP || signal == -1) {f0_13(0, tmp_TP); return;}
            }
            if(UseSignalsNBP && signal != 1)         {f0_12(0, std_TP); return;}
            else if (!UseSignalsNBP || signal == -1) {f0_13(0, std_TP); return;}
         } // IF NBP TRUE  
         
         if (!(f0_13())) return;
         return;  } // if Bid - ld_12 > ExecutionPoint * g...
      //}
   }
//--- Assert 7: Declare variables
   int      aCommand[];    // 1-OrderModify BUY; 2-OrderClose BUY; 3-OrderModify SELL; 4-OrderClose SELL;
   int      aTicket[];
   double   aOpenPrice[];
   double   aStopLoss[];
   double   aTakeProfit[];
   bool     aOk[];
   int      aCount;
//--- Assert 6: Dynamically resize arrays
   ArrayResize(aCommand,MaxAccountTrades);
   ArrayResize(aTicket,MaxAccountTrades);
   ArrayResize(aOpenPrice,MaxAccountTrades);
   ArrayResize(aStopLoss,MaxAccountTrades);
   ArrayResize(aTakeProfit,MaxAccountTrades);
   ArrayResize(aOk,MaxAccountTrades);
//--- Assert 2: Init OrderSelect #13
   total = GhostOrdersTotal();
   GhostInitSelect(true,0,SELECT_BY_POS,MODE_TRADES);
   for (pos_52 = 0; pos_52 < total; pos_52++) {
      if (GhostOrderSelect(pos_52, SELECT_BY_POS, MODE_TRADES)) {
      //--- Assert 5: Populate arrays
         aCommand[aCount]     =  0;
         aTicket[aCount]      =  GhostOrderTicket();
         aOpenPrice[aCount]   =  GhostOrderOpenPrice();
         aStopLoss[aCount]    =  GhostOrderStopLoss();
         aTakeProfit[aCount]  =  GhostOrderTakeProfit();
         if (GhostOrderMagicNumber() == MagicNumber && GhostOrderType() == cmd_44) {
            if (GhostOrderTakeProfit() == order_takeprofit_28 || GhostOrderStopLoss() == order_stoploss_36 || order_stoploss_36 == 0.0 || order_takeprofit_28 == 0.0) continue;
            li_64 = Close_Order_Attempts;
            bool_68 = FALSE;
            while (bool_68 == FALSE && li_64 >= 0) {
               li_64--;
               RefreshRates();
            //--- 6: Assert replace OrderModify a buy trade with arrays
               aCommand[aCount]     = 3; 
               aOpenPrice[aCount]   = NormalizeDouble(GhostOrderOpenPrice(), Digits);
               aStopLoss[aCount]    = NormalizeDouble(order_stoploss_36, Digits);
               aTakeProfit[aCount]  = NormalizeDouble(order_takeprofit_28, Digits);
               aCount ++;
               if( aCount >= MaxAccountTrades ) break;
               /*bool_68 = OrderModify(OrderTicket(), NormalizeDouble(OrderOpenPrice(), Digits), NormalizeDouble(order_stoploss_36, Digits), NormalizeDouble(order_takeprofit_28, Digits),
                  0, Pink);*/
               if (!TRUE) {
                  g_error_1248 = GetLastError();
                  if (g_error_1248 == 146/* TRADE_CONTEXT_BUSY */) {
                     Sleep(50);
                     continue;
                  }
               }
               bool_68 = TRUE;
            }
         }
      }
   }
//--- Assert 1: Free OrderSelect #13
   GhostFreeSelect(false);
//--- Assert for: process array of commands
   for(int i=0; i<aCount; i++)
   {
      switch( aCommand[i] )
      {
         case 1:  // OrderModify Buy
         case 2:  // OrderClose Buy
         case 3:  // OrderModify Sell
            GhostOrderModify( aTicket[i], aOpenPrice[i], aStopLoss[i], aTakeProfit[i], 0, Pink ); 
            break;
         case 4:  // OrderClose Sell
            break;
      }
   }
}

int ChickenOutClose(string a_symbol_0) {
   int ticket_20;
   int li_12 = 0;
   bool is_closed_16 = FALSE;
   int error_24 = 0;
   int order_total_28 = GhostOrdersTotal();
   if (order_total_28 == 0) return (0);
   double ld_unused_32 = 0;
//--- Assert 6: Declare variables
   int      aCommand[];    // 1-OrderModify BUY; 2-OrderClose BUY; 3-OrderModify SELL; 4-OrderClose SELL;
   int      aTicket[];
   double   aLots[];
   double   aClosePrice[];
   bool     aOk[];
   int      aCount;
//--- Assert 5: Dynamically resize arrays
   ArrayResize(aCommand,MaxAccountTrades);
   ArrayResize(aTicket,MaxAccountTrades);
   ArrayResize(aLots,MaxAccountTrades);
   ArrayResize(aClosePrice,MaxAccountTrades);
   ArrayResize(aOk,MaxAccountTrades);
//--- Assert 2: Init OrderSelect #14
   GhostInitSelect(false,0,SELECT_BY_POS,MODE_TRADES);
   for (int pos_40 = order_total_28 - 1; pos_40 >= 0; pos_40--) {
      if (GhostOrderSelect(pos_40, SELECT_BY_POS, MODE_TRADES)) {
      //--- Assert 5: Populate arrays
         aCommand[aCount]     =  0;
         aTicket[aCount]      =  GhostOrderTicket();
         aLots[aCount]        =  GhostOrderLots();
         aClosePrice[aCount]  =  GhostOrderClosePrice();
         if (GhostOrderSymbol() == a_symbol_0 && GhostOrderMagicNumber() == MagicNumber) {
            if (GhostOrderType() == OP_BUY) {
               RefreshRates();
               li_12 = Close_Order_Attempts;
               is_closed_16 = FALSE;
               while (is_closed_16 == 0 && li_12 >= 0) {
                  li_12--;
                  RefreshRates();
                  ticket_20 = GhostOrderTicket();
               //--- 6: Assert replace OrderClose a buy trade with arrays
                  aCommand[aCount]     = 2; 
                  aClosePrice[aCount]  = NormalizeDouble(Bid, Digits);
                  aCount ++;
                  if( aCount >= MaxAccountTrades ) break;
                  /*is_closed_16 = OrderClose(ticket_20, OrderLots(), NormalizeDouble(Bid, Digits), Slippage, Red);*/
                  if (!TRUE) {
                     error_24 = GetLastError();
                     Print("Leviathan OrderClose FAILED : Ticket [" + ticket_20 + "]. " + "Error " + error_24 + " [" + ErrorDescription(error_24) + ".]");
                     if (error_24 == 146/* TRADE_CONTEXT_BUSY */) Sleep(50);
                  }
               }
               continue;
            }
            if (GhostOrderType() == OP_SELL) {
               RefreshRates();
               li_12 = Close_Order_Attempts;
               is_closed_16 = FALSE;
               while (is_closed_16 == 0 && li_12 >= 0) {
                  li_12--;
                  RefreshRates();
                  ticket_20 = GhostOrderTicket();
               //--- 6: Assert replace OrderModify a sell trade with arrays
                  aCommand[aCount]     = 4; 
                  aClosePrice[aCount]  = NormalizeDouble(Ask, Digits);
                  aCount ++;
                  if( aCount >= MaxAccountTrades ) break;
                  /*is_closed_16 = OrderClose(ticket_20, OrderLots(), NormalizeDouble(Ask, Digits), Slippage, Green);*/
                  if (!TRUE) {
                     error_24 = GetLastError();
                     Print("Leviathan OrderClose FAILED : Ticket [" + ticket_20 + "]. " + "Error " + error_24 + " [" + ErrorDescription(error_24) + ".]");
                     if (error_24 == 146/* TRADE_CONTEXT_BUSY */) Sleep(50);
                  }
               }
            }
         }
      }
   }
//--- Assert 1: Free OrderSelect #14
   GhostFreeSelect(false);
//--- Assert for: process array of commands
   for(int i=0; i<aCount; i++)
   {
      switch( aCommand[i] )
      {
         case 1:  // OrderModify Buy
         case 2:  // OrderClose Buy
            GhostOrderClose( aTicket[i], aLots[i], aClosePrice[i], Slippage, Red ); 
            break;
         case 3:  // OrderModify Sell
         case 4:  // OrderClose Sell
            GhostOrderClose( aTicket[i], aLots[i], aClosePrice[i], Slippage, Green ); 
            break;
      }
   }
   return (1);
}

int f0_4() {
   int li_0;
   int li_4;
   int li_8;
   int li_12;
   if (DayOfWeek() == 0) {
      li_0 = SUN_StartHour;
      li_4 = SUN_StartMinute;
      li_8 = SUN_EndHour;
      li_12 = SUN_EndMinute;
   }
   if (DayOfWeek() == 1) {
      li_0 = MON_StartHour;
      li_4 = MON_StartMinute;
      li_8 = MON_EndHour;
      li_12 = MON_EndMinute;
   }
   if (DayOfWeek() == 2) {
      li_0 = TUE_StartHour;
      li_4 = TUE_StartMinute;
      li_8 = TUE_EndHour;
      li_12 = TUE_EndMinute;
   }
   if (DayOfWeek() == 3) {
      li_0 = WED_StartHour;
      li_4 = WED_StartMinute;
      li_8 = WED_EndHour;
      li_12 = WED_EndMinute;
   }
   if (DayOfWeek() == 4) {
      li_0 = THU_StartHour;
      li_4 = THU_StartMinute;
      li_8 = THU_EndHour;
      li_12 = THU_EndMinute;
   }
   if (DayOfWeek() == 5) {
      li_0 = FRI_StartHour;
      li_4 = FRI_StartMinute;
      li_8 = FRI_EndHour;
      li_12 = FRI_EndMinute;
   }
   if (DayOfWeek() == 6) {
      li_0 = SAT_StartHour;
      li_4 = SAT_StartMinute;
      li_8 = SAT_EndHour;
      li_12 = SAT_EndMinute;
   }
   int li_16 = 60 * TimeHour(TimeCurrent()) + TimeMinute(TimeCurrent());
   int li_20 = 60 * li_0 + li_4;
   int li_24 = 60 * li_8 + li_12;
   if (li_20 == li_24) return (0);
   if (li_20 < li_24) {
      if (!(!(li_16 >= li_20 && li_16 < li_24))) return (1);
      return (0);
   }
   if (li_20 > li_24) {
      if (!(!(li_16 >= li_20 || li_16 < li_24))) return (1);
      return (0);
   }
   return (0);
}

void f0_17() {
   string dbl2str_0 = DoubleToStr(f0_1(2), 2);
   if (!IsTesting()) f0_10();
   if (FreezeAfterTPScheduler == TRUE && f0_4() == 1) {
      Comment( GhostComment(" \nLeviathan v4.0" + 
         "\nAccount Leverage  :  " + "1 : " + AccountLeverage() + 
         "\nAccount Type  :  " + AccountServer() + 
         "\nServer Time  :  " + TimeToStr(TimeCurrent(), TIME_SECONDS) +
         "\nAccount Equity  = " + GhostAccountEquity() +
         "\nFree Margin     = " + GhostAccountFreeMargin() +
         "\nDrawdown  :  " + dbl2str_0 + "%" +
         "\nTotal Profit/Loss = " + gd_948 +
         "\nFreezeAfterTPScheduler: ON" +
      "\n\n") );
      return;
   }
   Comment( GhostComment(" \nLeviathan v4.0" +
      "\nAccount Leverage  :  " + "1 : " + AccountLeverage() +
      "\nAccount Type  :  " + AccountServer() +
      "\nServer Time  :  " + TimeToStr(TimeCurrent(), TIME_SECONDS) +
      "\nAccount Equity  = " + GhostAccountEquity() +
      "\nFree Margin     = " + GhostAccountFreeMargin() +
      "\nDrawdown  :  " + dbl2str_0 + "%" +
      "\nTotal Profit/Loss = " + gd_948 +
      "\nFreezeAfterTPScheduler: OFF" +
   "\n\n") );
}

int f0_0() {
   return (1);
}

double f0_1(int ai_0) {
   double ld_ret_4;
   if (ai_0 == 2) {
      ld_ret_4 = (GhostAccountEquity() / GhostAccountBalance() - 1.0) / (-0.010000000000000000208);
      if (ld_ret_4 <= 0.0) return (0);
      return (ld_ret_4);
   }
   if (ai_0 == 1) {
      ld_ret_4 = 100.0 * (GhostAccountEquity() / GhostAccountBalance() - 1.0);
      if (ld_ret_4 <= 0.0) return (0);
      return (ld_ret_4);
   }
   return (0.0);
}

///////////////////////////////////////////////////////////////////////
int fun0(double& a0[], double& a1[], int a2, int a3, double a4, double& a5[], double a6, int a7)
{
{
  int v8; // esi@1
  double v9; // st7@5
//  unsigned int v10; // edx@8
//  unsigned int v11; // eax@8
  double v12; // st7@36
  //double *v13; // eax@36
  double v14; // st7@183
  double v16; // [sp+8h] [bp-8h]@5

  v8 = 0;
  /*
  if ( v4656A0 != 200 || v465690 || a7 != v46569C && a7 + 2 != v46569C )
    return -1;
    */
  v9 = a0[25]; //take profit standart
  v16 = a1[25]; // mult standart
 
    if ( a0[a3] <= 0.0 )
      v9 = a0[25];
    else
      v9 = a0[a3];
    if ( a1[a3] > 0.0 )
    {
      v16 = a1[a3];
      v8 = 1;
    }
    
  // Standard Leviathan 2.0 Logic's
  if (!EnvyAugmenterOn)
      {if (a3 == 0 || a3 > 1) {v16 = a1[25];}}
    
//LABEL_10:
  if ( a1[1] > 0.0
    || a1[2] > 0.0
    || a1[3] > 0.0
    || a1[4] > 0.0
    || a1[5] > 0.0
    || a1[6] > 0.0
    || a1[7] > 0.0
    || a1[8] > 0.0
    || a1[9] > 0.0
    || a1[10] > 0.0
    || a1[11] > 0.0
    || a1[12] > 0.0
    || a1[13] > 0.0
    || a1[14] > 0.0
    || a1[15] > 0.0
    || a1[16] > 0.0
    || a1[17] > 0.0
    || a1[18] > 0.0
    || a1[19] > 0.0
    || a1[20] > 0.0
    || a1[21] > 0.0
    || a1[22] > 0.0
    || a1[23] > 0.0
    || a1[24] > 0.0 )
    v8 = 1;
  /*if ( a2 == 3 )
  {
    v12 = v9 * 10.0;
    //v13 = a5;
    a5[1] = 0.01;
    a5[0] = v12;
  }
  else
  {
    if ( a2 == 5 )
    {
      v14 = v9 * 10.0;
      //v13 = a5;
      a5[1] = 0.0001;
      a5[0] = v14;
    }
    else
    {
      //v13 = a5;
      a5[0] = v9;
      a5[1] = a4;
    }
  }*/
  a5[0] = v9; // Fix 3/5 (23 Lines up disabled, is no need with new 3/5 system)
  a5[1] = gPoint; // Fix 3/5
  a5[2] = v16;
  a5[3] = a6;
  return (v8 == 1);
  //return (v8);
}
}

int fun1(string& a0[], int a1, double a2, string a3, int a4)
{
   return (1);
}

//---------------------------------------------------------------------------         
double LOT()
{
   RefreshRates();

   double MINLOT = MarketInfo(Symbol(),MODE_MINLOT);
   double LOT = MINLOT;
   
   double DDFromStart = (AccountBalance()-StartingBalance)*100/StartingBalance;
   
   LOT = BaseLotSize;
   
   LOT = NormalizeDouble(LOT,MarketInfo(Symbol(),MODE_DIGITS));


   if(LotStepEnable)
   {
      double safeProfit = AccountBalance();

      if (DDFromStart <= -2)
      {
         safeProfit = AccountBalance() + (StartingBalance - AccountBalance())/2;
      } else if (DDFromStart <= -3)
      {
         safeProfit = AccountBalance() + (StartingBalance - AccountBalance())/3;
      } else if (DDFromStart <= -5)
      {
         safeProfit = AccountBalance() + (StartingBalance - AccountBalance())/5;
      } else if (DDFromStart <= -8)
      {
         safeProfit = AccountBalance() + (StartingBalance - AccountBalance())/8;
      } else if (DDFromStart <= -10)
      {
         safeProfit = AccountBalance() + (StartingBalance - AccountBalance())/10;
      } else if (DDFromStart <= -13)
      {
         safeProfit = AccountBalance() + (StartingBalance - AccountBalance())/13;
      } else if (DDFromStart <= -15)
      {
         safeProfit = AccountBalance() + (StartingBalance - AccountBalance())/15;
      } else if (DDFromStart <= -20)
      {
         safeProfit = AccountBalance() + (StartingBalance - AccountBalance())/20;
      } else if (DDFromStart <= -50)
      {
         safeProfit = AccountBalance() + (StartingBalance - AccountBalance())/50;
      } else if (DDFromStart <= -60)
      {
         safeProfit = AccountBalance() + (AccountBalance()*5.0)/100;
      }

      double stepValue = ((safeProfit-LotStepFrom)/LotStepEvery)*LotStepValue ;
      double lotStepValue = NormalizeDouble( ( stepValue - MathMod(stepValue, LotStepValue) ) , MarketInfo(Symbol(),MODE_DIGITS) );;
      
      LOT += lotStepValue;
      //Log(" >>>>>>>>>>>>>>>>>>>>> ",AccountBalance(), " ----------------- ", lotStepValue, " ************** ", LOT );
   }

   /*double OneLotMargin = MarketInfo(Symbol(),MODE_MARGINREQUIRED);
   double MarginAmount = AccountEquity(); //this means we want to use 200$ for trade
   double lotMM = MarginAmount/OneLotMargin;
   double LotStep = MarketInfo(Symbol(),MODE_LOTSTEP);
   double LOT = NormalizeDouble(lotMM/LotStep,0)*LotStep;*/
   
   if (LOT>MarketInfo(Symbol(),MODE_MAXLOT)) LOT = MarketInfo(Symbol(),MODE_MAXLOT);
   if (LOT<MINLOT) LOT = MINLOT;
   if (MINLOT<0.1) LOT = NormalizeDouble(LOT,2); else LOT = NormalizeDouble(LOT,1);
   
   return(NormalizeDouble(LOT,MarketInfo(Symbol(),MODE_DIGITS)));
}
//----------------------------------------------------------------------------
void CloseAllOrders(bool force=false) {
//--- Assert 2: Init OrderSelect #15
   int total = GhostOrdersTotal();

   GhostInitSelect(true,0,SELECT_BY_POS,MODE_TRADES);
   
   if (force || total <= 2 || AccountEquity() > StartingBalance)
   {
      for (int pos_32 = 0; pos_32 < total; pos_32++) {
         if (GhostOrderSelect(pos_32,SELECT_BY_POS,MODE_TRADES)) {
            if (GhostOrderMagicNumber() == MagicNumber) {
               f0_16("close #" + GhostOrderTicket());
               GhostOrderClose( GhostOrderTicket(), GhostOrderLots(), GhostOrderClosePrice(), MarketInfo(Symbol(), MODE_SPREAD), White );
            //--- Assert 1: Free OrderSelect #15
               GhostFreeSelect(false);
            }
         }
      }
   }
   
}
//----------------------------------------------------------------------------
void ProgressiveStopLoss() {
   //double DDFromStart                = (AccountEquity()-StartingBalance)*100/StartingBalance;
   double MaxMarketPipDistance       = sqGetMaxMarketPipDistance(Symbol(),MagicNumber);
   
   if (ProgressiveStopLossPerc > 0 /*&& DDFromStart <= -ProgressiveStopLossPerc*/)
   {
      int signal = signal();
      double actualProfit = 0;
   //--- Assert 2: Init OrderSelect #15
      int total = GhostOrdersTotal();
   
      GhostInitSelect(true,0,SELECT_BY_POS,MODE_TRADES);
      for (int pos_32 = 0; pos_32 < total; pos_32++) {
         if (GhostOrderSelect(pos_32,SELECT_BY_POS,MODE_TRADES)) {
            if (GhostOrderMagicNumber() == MagicNumber) {
               double profit = GhostOrderProfit()+GhostOrderSwap()+GhostOrderCommission();
               double threshold = StartingBalance * ProgressiveStopLossPerc / 100;
               if (profit <= -threshold && 
                   ( (GhostOrderType() == OP_BUY && signal == -1) || (GhostOrderType() == OP_SELL && signal == 1) ) 
                  )
               {
                  f0_16("close #" + GhostOrderTicket());
                  GhostOrderClose( GhostOrderTicket(), GhostOrderLots(), GhostOrderClosePrice(), MarketInfo(Symbol(), MODE_SPREAD), White );
                  /*
                     Alert("ProgressiveStopLossPerc on " + Symbol() + "!");
                     Log("[ProgressiveStopLossPerc ALERT] - (actualProfit = " + actualProfit + ") - Sleep for "+MinutesToSleep+" minutes ...");
                     spikeAlert = true;
                     lastSpikeAlertTime = TimeCurrent();
                     return;
                  */
               }
            }
         }
      }
   //--- Assert 1: Free OrderSelect #15
      GhostFreeSelect(false);
   }
}
//----------------------------------------------------------------------------
void EquityStopLoss() {
   //double DDFromStart                = (AccountEquity()-StartingBalance)*100/StartingBalance;
   /*
      double DDFromStart = (AccountEquity()-AccountBalance())*100/AccountBalance();
      if(EquityShield > 0 && DDFromStart <= -EquityShield) {
         CloseAllOrders(true);
         spikeAlert = true;
      }
   */
      
   if (EquityShield > 0 /*&& DDFromStart <= -ProgressiveStopLossPerc*/)
   {
      double actualProfit = 0;
   //--- Assert 2: Init OrderSelect #15
      int total = GhostOrdersTotal();
   
      GhostInitSelect(true,0,SELECT_BY_POS,MODE_TRADES);
      for (int pos_32 = 0; pos_32 < total; pos_32++) {
         if (GhostOrderSelect(pos_32,SELECT_BY_POS,MODE_TRADES)) {
            if (GhostOrderMagicNumber() == MagicNumber) {
               double profit = GhostOrderProfit()+GhostOrderSwap()+GhostOrderCommission();
               actualProfit += profit;
            }
         }
      }

      if (actualProfit < 0 && (MathAbs(actualProfit)*100/StartingBalance)>=EquityShield)
      {
         CloseAllOrders(true);
         Alert("EquityStopLoss on " + Symbol() + "!");
         Log("[EquityStopLoss ALERT] - (actualProfit = " + actualProfit + ") - Sleep for "+MinutesToSleep+" minutes ...");
         spikeAlert = true;
         lastSpikeAlertTime = TimeCurrent();
      }
   }
}
//----------------------------------------------------------------------------
double sqGetPointPow(string symbol) {
   double realDigits = MarketInfo(symbol,MODE_DIGITS);
   if(realDigits > 0 && realDigits != 2 && realDigits != 4) {
      realDigits -= 1;
   }

   double gPointPow = MathPow(10, realDigits);
   return(gPointPow);
}
double sqGetPointCoef(string symbol) {
   double gPointCoef = 1/sqGetPointPow(symbol);
   return(gPointCoef);
}
//----------------------------------------------------------------------------
double sqConvertToRealPips(string symbol, int value) {
   return(sqGetPointCoef(symbol) * value);
}

//----------------------------------------------------------------------------

double sqConvertToPips(string symbol, double value) {
   return(sqGetPointPow(symbol) * value);
}

//---------------------------------------------------------------------------
//+------------------------------------------------------------------+
//| H4 and Daily Support/Resistance and Pivot                        |
//+------------------------------------------------------------------+
void get_pivots(string symbol, int timeframe)
{
//----------------------------------------------------------------------------- Get new TimeFrame ---------------
   ArrayCopyRates(Fhr_rates_d1, symbol, timeframe);

   Fhr_yesterday_close = Fhr_rates_d1[1][4];
   Fhr_yesterday_open = Fhr_rates_d1[1][1];
   Fhr_today_open = Fhr_rates_d1[0][1];
   Fhr_yesterday_high = Fhr_rates_d1[1][3];
   Fhr_yesterday_low = Fhr_rates_d1[1][2];
   Fhr_day_high = Fhr_rates_d1[0][3];
   Fhr_day_low = Fhr_rates_d1[0][2];


//---- Calculate Pivots

   Fhr_D = (Fhr_day_high - Fhr_day_low);
   Fhr_Q = (Fhr_yesterday_high - Fhr_yesterday_low);
   Fhr_P = (Fhr_yesterday_high + Fhr_yesterday_low + Fhr_yesterday_close) / 3;
   Fhr_R1 = (2*Fhr_P)-Fhr_yesterday_low;
   Fhr_S1 = (2*Fhr_P)-Fhr_yesterday_high;
   Fhr_R2 = Fhr_P+(Fhr_yesterday_high - Fhr_yesterday_low);
   Fhr_S2 = Fhr_P-(Fhr_yesterday_high - Fhr_yesterday_low);


   Fhr_R3 = (2*Fhr_P)+(Fhr_yesterday_high-(2*Fhr_yesterday_low));
   Fhr_M5 = (Fhr_R2+Fhr_R3)/2;
   // Fhr_R2 = Fhr_P-Fhr_S1+Fhr_R1;
   Fhr_M4 = (Fhr_R1+Fhr_R2)/2;
   // Fhr_R1 = (2*Fhr_P)-Fhr_yesterday_low;
   Fhr_M3 = (Fhr_P+Fhr_R1)/2;
   // Fhr_P = (Fhr_yesterday_high + Fhr_yesterday_low + Fhr_yesterday_close)/3;
   Fhr_M2 = (Fhr_P+Fhr_S1)/2;
   // Fhr_S1 = (2*Fhr_P)-Fhr_yesterday_high;
   Fhr_M1 = (Fhr_S1+Fhr_S2)/2;
   // Fhr_S2 = Fhr_P-Fhr_R1+Fhr_S1;
   Fhr_S3 = (2*Fhr_P)-((2* Fhr_yesterday_high)-Fhr_yesterday_low);
   Fhr_M0 = (Fhr_S2+Fhr_S3)/2;

   if (Fhr_Q > 5)
   {
      Fhr_nQ = Fhr_Q;
   }
   else
   {
     Fhr_nQ = Fhr_Q*10000;
   }

   if (Fhr_D > 5)
   {
       Fhr_nD = Fhr_D;
   }
   else
   {
      Fhr_nD = Fhr_D*10000;
   }
//----------------------------------------------------------------------------- Get DAY ---------------
   ArrayCopyRates(D_rates_d1, symbol, 1440);

   D_yesterday_close = D_rates_d1[1][4];
   D_yesterday_open = D_rates_d1[1][1];
   D_today_open = D_rates_d1[0][1];
   D_yesterday_high = D_rates_d1[1][3];
   D_yesterday_low = D_rates_d1[1][2];
   D_day_high = D_rates_d1[0][3];
   D_day_low = D_rates_d1[0][2];


//---- Calculate Pivots

   D_D = (D_day_high - D_day_low);
   D_Q = (D_yesterday_high - D_yesterday_low);
   D_P = (D_yesterday_high + D_yesterday_low + D_yesterday_close) / 3;
   D_R1 = (2*D_P)-D_yesterday_low;
   D_S1 = (2*D_P)-D_yesterday_high;
   D_R2 = D_P+(D_yesterday_high - D_yesterday_low);
   D_S2 = D_P-(D_yesterday_high - D_yesterday_low);


   D_R3 = (2*D_P)+(D_yesterday_high-(2*D_yesterday_low));
   D_M5 = (D_R2+D_R3)/2;
   // D_R2 = D_P-D_S1+D_R1;
   D_M4 = (D_R1+D_R2)/2;
   // D_R1 = (2*D_P)-D_yesterday_low;
   D_M3 = (D_P+D_R1)/2;
   // D_P = (D_yesterday_high + D_yesterday_low + D_yesterday_close)/3;
   D_M2 = (D_P+D_S1)/2;
   // D_S1 = (2*D_P)-D_yesterday_high;
   D_M1 = (D_S1+D_S2)/2;
   // D_S2 = D_P-D_R1+D_S1;
   D_S3 = (2*D_P)-((2* D_yesterday_high)-D_yesterday_low);

   D_M0 = (D_S2+D_S3)/2;

   if (D_Q > 5)
   {
      D_nQ = D_Q;
   }
   else
   {
     D_nQ = D_Q*10000;
   }

   if (D_D > 5)
   {
       D_nD = D_D;
   }
   else
   {
      D_nD = D_D*10000;
   }
}

//--------------------------------------------------------------------- +
void get_NearestAndFarestSR(string symbol, int timeframe, double price)
{
   //-- Pivots, Support/Resistance and Price Alerts
   get_pivots(symbol, timeframe);
   //---

   MqlRates RatesBar[];
   ArraySetAsSeries(RatesBar,true);
   if(CopyRates(symbol,timeframe,0,20,RatesBar)==20)
   {
      double high     = RatesBar[0].high;
      double point    = MarketInfo(symbol,MODE_POINT);
      int    digits   = MarketInfo(symbol,MODE_DIGITS);
      double ask      = MarketInfo(symbol,MODE_ASK);
      double bid      = MarketInfo(symbol,MODE_BID);
      double low      = RatesBar[0].low;
      int    power    = MathPow(10,digits-1);
      double pipRange = (high-low)*power;
      double bidRatio = (pipRange > 0 ? ((bid-low)/pipRange*power)*100 : 0);
             pipRange = (pipRange != 0 ? pipRange : 0.001);
      //-Fhr
      if( price >= Fhr_R3 )
      {
         nearest_resistance = D_R3;
         nearest_support = Fhr_R3;

         farest_resistance = D_R3 + sqConvertToRealPips(symbol, pipRange);
         farest_support = Fhr_R1;
      }
      else if( price < Fhr_R3 && price >= Fhr_R2 )
      {
         nearest_resistance = Fhr_R3;
         nearest_support = Fhr_R2;

         farest_resistance = D_R3;
         farest_support = Fhr_S1;
      }
      else if( price < Fhr_R2 && price >= Fhr_R1 )
      {
         nearest_resistance = Fhr_R2;
         nearest_support = Fhr_R1;

         farest_resistance = Fhr_R3;
         farest_support = Fhr_S1;
      }
      else if( price < Fhr_R1 && price >= Fhr_S1 )
      {
         nearest_resistance = Fhr_R1;
         nearest_support = Fhr_S1;

         farest_resistance = Fhr_R3;
         farest_support = Fhr_S3;
      }
      else if( price < Fhr_S1 && price >= Fhr_S2 )
      {
         nearest_resistance = Fhr_S1;
         nearest_support = Fhr_S2;

         farest_resistance = Fhr_R3;
         farest_support = Fhr_S3;
      }
      else if( price < Fhr_S2 && price >= Fhr_S3 )
      {
         nearest_resistance = Fhr_S2;
         nearest_support = Fhr_S3;

         farest_resistance = Fhr_S1;
         farest_support = D_S3;
      }
      else
      {
         nearest_resistance = Fhr_S3;
         nearest_support = D_S3;

         farest_resistance = Fhr_S1;
         farest_support = D_S3 - sqConvertToRealPips(symbol, pipRange);
      }
      //-D
      if( price >= D_R3 )
      {
         nearest_daily_resistance = D_R3 + sqConvertToRealPips(symbol, pipRange);
         nearest_daily_support = D_R3;

         farest_daily_resistance = D_R3 + sqConvertToRealPips(symbol, pipRange);
         farest_daily_support = D_R1;
      }
      else if( price < D_R3 && price >= D_R2 )
      {
         nearest_daily_resistance = D_R3;
         nearest_daily_support = D_R2;

         farest_daily_resistance = D_R3 + sqConvertToRealPips(symbol, pipRange);
         farest_daily_support = D_S1;
      }
      else if( price < D_R2 && price >= D_R1 )
      {
         nearest_daily_resistance = D_R2;
         nearest_daily_support = D_R1;

         farest_daily_resistance = D_R3;
         farest_daily_support = D_S1;
      }
      else if( price < D_R1 && price >= D_S1 )
      {
         nearest_daily_resistance = D_R1;
         nearest_daily_support = D_S1;

         farest_daily_resistance = D_R3;
         farest_daily_support = D_S3;
      }
      else if( price < D_S1 && price >= D_S2 )
      {
         nearest_daily_resistance = D_S1;
         nearest_daily_support = D_S2;

         farest_daily_resistance = D_R1;
         farest_daily_support = D_S3;
      }
      else if( price < D_S2 && price >= D_S3 )
      {
         nearest_daily_resistance = D_S2;
         nearest_daily_support = D_S3;

         farest_daily_resistance = D_R1;
         farest_daily_support = D_S3 - sqConvertToRealPips(symbol, pipRange);
      }
      else
      {
         nearest_daily_resistance = D_S3;
         nearest_daily_support = D_S3 - sqConvertToRealPips(symbol, pipRange);

         farest_daily_resistance = D_R1;
         farest_daily_support = D_S3 - sqConvertToRealPips(symbol, 2*pipRange);
      }
   }
}
//---------------------------------------------------------------------------